<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2015-September/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1442896846.297494.11471.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001870.html">
   <LINK REL="Next"  HREF="001874.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1442896846.297494.11471.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Tue Sep 22 04:40:46 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="001870.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="001874.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1873">[ date ]</a>
              <a href="thread.html#1873">[ thread ]</a>
              <a href="subject.html#1873">[ subject ]</a>
              <a href="author.html#1873">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  18cd23df8a8f2edd800182e1ab62111e4b7f1dbe (commit)
      from  ff03599a2f518dbdf13bca0bb0208e431b892fe9 (commit)


- Log -----------------------------------------------------------------
commit 18cd23df8a8f2edd800182e1ab62111e4b7f1dbe
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at akamai.com</A>&gt;
Date:   Thu May 7 23:41:07 2015 -0400

    Remove &quot;noise&quot; comments from TS files.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 apps/ts.c                 | 163 +++++++++-------------------------------------
 crypto/ts/ts_asn1.c       |   9 ---
 crypto/ts/ts_conf.c       |   8 +--
 crypto/ts/ts_lib.c        |   4 --
 crypto/ts/ts_req_print.c  |   2 -
 crypto/ts/ts_rsp_print.c  |  16 -----
 crypto/ts/ts_rsp_sign.c   |  96 +++------------------------
 crypto/ts/ts_rsp_utils.c  |   3 -
 crypto/ts/ts_rsp_verify.c |  80 +++--------------------
 crypto/ts/ts_verify_ctx.c |   4 --
 10 files changed, 48 insertions(+), 337 deletions(-)

diff --git a/apps/ts.c b/apps/ts.c
index 70729c5..237dd01 100644
--- a/apps/ts.c
+++ b/apps/ts.c
@@ -67,13 +67,17 @@
 #include &lt;openssl/ts.h&gt;
 #include &lt;openssl/bn.h&gt;
 
-/* Length of the nonce of the request in bits (must be a multiple of 8). */
+/* Request nonce length, in bits (must be a multiple of 8). */
 #define NONCE_LENGTH            64
 
-/* Macro definitions for the configuration file. */
+/* Name of config entry that defines the OID file. */
 #define ENV_OID_FILE            &quot;oid_file&quot;
 
-/* Local function declarations. */
+/* Is |EXACTLY_ONE| of three pointers set? */
+#define EXACTLY_ONE(a, b, c) \
+        (( a &amp;&amp; !b &amp;&amp; !c) || \
+         ( b &amp;&amp; !a &amp;&amp; !c) || \
+         ( c &amp;&amp; !a &amp;&amp; !b))
 
 static ASN1_OBJECT *txt2obj(const char *oid);
 static CONF *load_config_file(const char *configfile);
@@ -309,7 +313,6 @@ int ts_main(int argc, char **argv)
                        app_RAND_load_files(rnd));
     }
 
-    /* Get the password if required. */
     if (mode == OPT_REPLY &amp;&amp; passin &amp;&amp;
         !app_passwd(passin, NULL, &amp;password, NULL)) {
         BIO_printf(bio_err, &quot;Error getting password.\n&quot;);
@@ -320,33 +323,22 @@ int ts_main(int argc, char **argv)
     if (!app_load_modules(conf))
         goto end;
 
-    /*
-     * Check consistency of parameters and execute the appropriate function.
-     */
+    /* Check parameter consistency and execute the appropriate function. */
     switch (mode) {
     default:
     case OPT_ERR:
         goto opthelp;
     case OPT_QUERY:
-        /*
-         * Data file and message imprint cannot be specified at the same
-         * time.
-         */
-        ret = data != NULL &amp;&amp; digest != NULL;
-        if (ret)
+        if ((data != NULL) &amp;&amp; (digest != NULL))
             goto opthelp;
         ret = !query_command(data, digest, md, policy, no_nonce, cert,
                              in, out, text);
         break;
     case OPT_REPLY:
+        if ((in != NULL) &amp;&amp; (queryfile != NULL))
+            goto opthelp;
         if (in == NULL) {
-            ret = !(queryfile != NULL &amp;&amp; conf != NULL &amp;&amp; !token_in);
-            if (ret)
-                goto opthelp;
-        } else {
-            /* 'in' and 'queryfile' are exclusive. */
-            ret = !(queryfile == NULL);
-            if (ret)
+            if ((conf == NULL) || (token_in != 0))
                 goto opthelp;
         }
         ret = !reply_command(conf, section, engine, queryfile,
@@ -354,24 +346,17 @@ int ts_main(int argc, char **argv)
                              in, token_in, out, token_out, text);
         break;
     case OPT_VERIFY:
-        ret = !(((queryfile &amp;&amp; !data &amp;&amp; !digest)
-                 || (!queryfile &amp;&amp; data &amp;&amp; !digest)
-                 || (!queryfile &amp;&amp; !data &amp;&amp; digest))
-                &amp;&amp; in != NULL);
-        if (ret)
+        if ((in == NULL) || !EXACTLY_ONE(queryfile, data, digest))
             goto opthelp;
-
         ret = !verify_command(data, digest, queryfile, in, token_in,
                               CApath, CAfile, untrusted);
     }
 
  end:
-    /* Clean up. */
     app_RAND_write_file(NULL);
     NCONF_free(conf);
     OPENSSL_free(password);
     OBJ_cleanup();
-
     return (ret);
 }
 
@@ -427,13 +412,12 @@ static int query_command(const char *data, char *digest, const EVP_MD *md,
     BIO *data_bio = NULL;
     BIO *out_bio = NULL;
 
-    /* Build query object either from file or from scratch. */
+    /* Build query object. */
     if (in != NULL) {
         if ((in_bio = bio_open_default(in, 'r', FORMAT_ASN1)) == NULL)
             goto end;
         query = d2i_TS_REQ_bio(in_bio, NULL);
     } else {
-        /* Open the file if no explicit digest bytes were specified. */
         if (digest == NULL
             &amp;&amp; (data_bio = bio_open_default(data, 'r', FORMAT_ASN1)) == NULL)
             goto end;
@@ -442,15 +426,12 @@ static int query_command(const char *data, char *digest, const EVP_MD *md,
     if (query == NULL)
         goto end;
 
-    /* Write query either in ASN.1 or in text format. */
     if (text) {
-        /* Text output. */
         if ((out_bio = bio_open_default(out, 'w', FORMAT_TEXT)) == NULL)
             goto end;
         if (!TS_REQ_print_bio(out_bio, query))
             goto end;
     } else {
-        /* ASN.1 output. */
         if ((out_bio = bio_open_default(out, 'w', FORMAT_ASN1)) == NULL)
             goto end;
         if (!i2d_TS_REQ_bio(out_bio, query))
@@ -461,13 +442,10 @@ static int query_command(const char *data, char *digest, const EVP_MD *md,
 
  end:
     ERR_print_errors(bio_err);
-
-    /* Clean up. */
     BIO_free_all(in_bio);
     BIO_free_all(data_bio);
     BIO_free_all(out_bio);
     TS_REQ_free(query);
-
     return ret;
 }
 
@@ -483,23 +461,14 @@ static TS_REQ *create_query(BIO *data_bio, char *digest, const EVP_MD *md,
     ASN1_OBJECT *policy_obj = NULL;
     ASN1_INTEGER *nonce_asn1 = NULL;
 
-    /* Setting default message digest. */
     if (md == NULL &amp;&amp; (md = EVP_get_digestbyname(&quot;sha1&quot;)) == NULL)
         goto err;
-
-    /* Creating request object. */
     if ((ts_req = TS_REQ_new()) == NULL)
         goto err;
-
-    /* Setting version. */
     if (!TS_REQ_set_version(ts_req, 1))
         goto err;
-
-    /* Creating and adding MSG_IMPRINT object. */
     if ((msg_imprint = TS_MSG_IMPRINT_new()) == NULL)
         goto err;
-
-    /* Adding algorithm. */
     if ((algo = X509_ALGOR_new()) == NULL)
         goto err;
     if ((algo-&gt;algorithm = OBJ_nid2obj(EVP_MD_type(md))) == NULL)
@@ -509,17 +478,12 @@ static TS_REQ *create_query(BIO *data_bio, char *digest, const EVP_MD *md,
     algo-&gt;parameter-&gt;type = V_ASN1_NULL;
     if (!TS_MSG_IMPRINT_set_algo(msg_imprint, algo))
         goto err;
-
-    /* Adding message digest. */
     if ((len = create_digest(data_bio, digest, md, &amp;data)) == 0)
         goto err;
     if (!TS_MSG_IMPRINT_set_msg(msg_imprint, data, len))
         goto err;
-
     if (!TS_REQ_set_msg_imprint(ts_req, msg_imprint))
         goto err;
-
-    /* Setting policy if requested. */
     if (policy &amp;&amp; (policy_obj = txt2obj(policy)) == NULL)
         goto err;
     if (policy_obj &amp;&amp; !TS_REQ_set_policy_id(ts_req, policy_obj))
@@ -530,8 +494,6 @@ static TS_REQ *create_query(BIO *data_bio, char *digest, const EVP_MD *md,
         goto err;
     if (nonce_asn1 &amp;&amp; !TS_REQ_set_nonce(ts_req, nonce_asn1))
         goto err;
-
-    /* Setting certificate request flag if requested. */
     if (!TS_REQ_set_cert_req(ts_req, cert))
         goto err;
 
@@ -541,6 +503,7 @@ static TS_REQ *create_query(BIO *data_bio, char *digest, const EVP_MD *md,
         TS_REQ_free(ts_req);
         ts_req = NULL;
         BIO_printf(bio_err, &quot;could not create query\n&quot;);
+        ERR_print_errors(bio_err);
     }
     TS_MSG_IMPRINT_free(msg_imprint);
     X509_ALGOR_free(algo);
@@ -557,9 +520,9 @@ static int create_digest(BIO *input, char *digest, const EVP_MD *md,
 
     md_value_len = EVP_MD_size(md);
     if (md_value_len &lt; 0)
-        goto err;
+        return 0;
+
     if (input) {
-        /* Digest must be computed from an input file. */
         EVP_MD_CTX md_ctx;
         unsigned char buffer[4096];
         int length;
@@ -572,7 +535,6 @@ static int create_digest(BIO *input, char *digest, const EVP_MD *md,
         if (!EVP_DigestFinal(&amp;md_ctx, *md_value, NULL))
             return 0;
     } else {
-        /* Digest bytes are specified with digest. */
         long digest_len;
         *md_value = string_to_hex(digest, &amp;digest_len);
         if (!*md_value || md_value_len != digest_len) {
@@ -580,13 +542,10 @@ static int create_digest(BIO *input, char *digest, const EVP_MD *md,
             *md_value = NULL;
             BIO_printf(bio_err, &quot;bad digest, %d bytes &quot;
                        &quot;must be specified\n&quot;, md_value_len);
-            goto err;
+            return 0;
         }
     }
-
     return md_value_len;
- err:
-    return 0;
 }
 
 static ASN1_INTEGER *create_nonce(int bits)
@@ -596,7 +555,6 @@ static ASN1_INTEGER *create_nonce(int bits)
     int len = (bits - 1) / 8 + 1;
     int i;
 
-    /* Generating random byte sequence. */
     if (len &gt; (int)sizeof(buf))
         goto err;
     if (RAND_bytes(buf, len) &lt;= 0)
@@ -608,12 +566,11 @@ static ASN1_INTEGER *create_nonce(int bits)
     if ((nonce = ASN1_INTEGER_new()) == NULL)
         goto err;
     OPENSSL_free(nonce-&gt;data);
-    /* Allocate at least one byte. */
     nonce-&gt;length = len - i;
     nonce-&gt;data = app_malloc(nonce-&gt;length + 1, &quot;nonce buffer&quot;);
     memcpy(nonce-&gt;data, buf + i, nonce-&gt;length);
-
     return nonce;
+
  err:
     BIO_printf(bio_err, &quot;could not create nonce\n&quot;);
     ASN1_INTEGER_free(nonce);
@@ -638,18 +595,12 @@ static int reply_command(CONF *conf, char *section, char *engine,
     BIO *signer_bio = NULL;
     BIO *out_bio = NULL;
 
-    /* Build response object either from response or query. */
     if (in != NULL) {
         if ((in_bio = BIO_new_file(in, &quot;rb&quot;)) == NULL)
             goto end;
         if (token_in) {
-            /*
-             * We have a ContentInfo (PKCS7) object, add 'granted' status
-             * info around it.
-             */
             response = read_PKCS7(in_bio);
         } else {
-            /* We have a ready-made TS_RESP object. */
             response = d2i_TS_RESP_bio(in_bio, NULL);
         }
     } else {
@@ -663,9 +614,8 @@ static int reply_command(CONF *conf, char *section, char *engine,
     if (response == NULL)
         goto end;
 
-    /* Write response either in ASN.1 or text format. */
+    /* Write response. */
     if (text) {
-        /* Text output. */
         if ((out_bio = bio_open_default(out, 'w', FORMAT_TEXT)) == NULL)
         goto end;
         if (token_out) {
@@ -677,7 +627,6 @@ static int reply_command(CONF *conf, char *section, char *engine,
                 goto end;
         }
     } else {
-        /* ASN.1 DER output. */
         if ((out_bio = bio_open_default(out, 'w', FORMAT_ASN1)) == NULL)
             goto end;
         if (token_out) {
@@ -694,15 +643,12 @@ static int reply_command(CONF *conf, char *section, char *engine,
 
  end:
     ERR_print_errors(bio_err);
-
-    /* Clean up. */
     BIO_free_all(in_bio);
     BIO_free_all(query_bio);
     BIO_free_all(inkey_bio);
     BIO_free_all(signer_bio);
     BIO_free_all(out_bio);
     TS_RESP_free(response);
-
     return ret;
 }
 
@@ -715,30 +661,23 @@ static TS_RESP *read_PKCS7(BIO *in_bio)
     TS_RESP *resp = NULL;
     TS_STATUS_INFO *si = NULL;
 
-    /* Read PKCS7 object and extract the signed time stamp info. */
     if ((token = d2i_PKCS7_bio(in_bio, NULL)) == NULL)
         goto end;
     if ((tst_info = PKCS7_to_TS_TST_INFO(token)) == NULL)
         goto end;
-
-    /* Creating response object. */
     if ((resp = TS_RESP_new()) == NULL)
         goto end;
-
-    /* Create granted status info. */
     if ((si = TS_STATUS_INFO_new()) == NULL)
         goto end;
     if (!TS_STATUS_INFO_set_status(si, TS_STATUS_GRANTED))
         goto end;
     if (!TS_RESP_set_status_info(resp, si))
         goto end;
-
-    /* Setting encapsulated token. */
     TS_RESP_set_tst_info(resp, token, tst_info);
     token = NULL;               /* Ownership is lost. */
     tst_info = NULL;            /* Ownership is lost. */
-
     ret = 1;
+
  end:
     PKCS7_free(token);
     TS_TST_INFO_free(tst_info);
@@ -762,73 +701,42 @@ static TS_RESP *create_response(CONF *conf, const char *section, char *engine,
 
     if ((query_bio = BIO_new_file(queryfile, &quot;rb&quot;)) == NULL)
         goto end;
-
-    /* Getting TSA configuration section. */
     if ((section = TS_CONF_get_tsa_section(conf, section)) == NULL)
         goto end;
-
-    /* Setting up response generation context. */
     if ((resp_ctx = TS_RESP_CTX_new()) == NULL)
         goto end;
-
-    /* Setting serial number provider callback. */
     if (!TS_CONF_set_serial(conf, section, serial_cb, resp_ctx))
         goto end;
 #ifndef OPENSSL_NO_ENGINE
-    /* Setting default OpenSSL engine. */
     if (!TS_CONF_set_crypto_device(conf, section, engine))
         goto end;
 #endif
-
-    /* Setting TSA signer certificate. */
     if (!TS_CONF_set_signer_cert(conf, section, signer, resp_ctx))
         goto end;
-
-    /* Setting TSA signer certificate chain. */
     if (!TS_CONF_set_certs(conf, section, chain, resp_ctx))
         goto end;
-
-    /* Setting TSA signer private key. */
     if (!TS_CONF_set_signer_key(conf, section, inkey, passin, resp_ctx))
         goto end;
-
-    /* Setting default policy OID. */
     if (!TS_CONF_set_def_policy(conf, section, policy, resp_ctx))
         goto end;
-
-    /* Setting acceptable policy OIDs. */
     if (!TS_CONF_set_policies(conf, section, resp_ctx))
         goto end;
-
-    /* Setting the acceptable one-way hash algorithms. */
     if (!TS_CONF_set_digests(conf, section, resp_ctx))
         goto end;
-
-    /* Setting guaranteed time stamp accuracy. */
     if (!TS_CONF_set_accuracy(conf, section, resp_ctx))
         goto end;
-
-    /* Setting the precision of the time. */
     if (!TS_CONF_set_clock_precision_digits(conf, section, resp_ctx))
         goto end;
-
-    /* Setting the ordering flaf if requested. */
     if (!TS_CONF_set_ordering(conf, section, resp_ctx))
         goto end;
-
-    /* Setting the TSA name required flag if requested. */
     if (!TS_CONF_set_tsa_name(conf, section, resp_ctx))
         goto end;
-
-    /* Setting the ESS cert id chain flag if requested. */
     if (!TS_CONF_set_ess_cert_id_chain(conf, section, resp_ctx))
         goto end;
-
-    /* Creating the response. */
     if ((response = TS_RESP_create_response(resp_ctx, query_bio)) == NULL)
         goto end;
-
     ret = 1;
+
  end:
     if (!ret) {
         TS_RESP_free(response);
@@ -836,7 +744,6 @@ static TS_RESP *create_response(CONF *conf, const char *section, char *engine,
     }
     TS_RESP_CTX_free(resp_ctx);
     BIO_free_all(query_bio);
-
     return response;
 }
 
@@ -889,6 +796,7 @@ static ASN1_INTEGER *next_serial(const char *serialfile)
             goto err;
     }
     ret = 1;
+
  err:
     if (!ret) {
         ASN1_INTEGER_free(serial);
@@ -919,6 +827,7 @@ static int save_ts_serial(const char *serialfile, ASN1_INTEGER *serial)
     return ret;
 }
 
+
 /*
  * Verify-related method definitions.
  */
@@ -933,7 +842,6 @@ static int verify_command(char *data, char *digest, char *queryfile,
     TS_VERIFY_CTX *verify_ctx = NULL;
     int ret = 0;
 
-    /* Decode the token (PKCS7) or response (TS_RESP) files. */
     if ((in_bio = BIO_new_file(in, &quot;rb&quot;)) == NULL)
         goto end;
     if (token_in) {
@@ -948,10 +856,9 @@ static int verify_command(char *data, char *digest, char *queryfile,
                                         CApath, CAfile, untrusted)) == NULL)
         goto end;
 
-    /* Checking the token or response against the request. */
-    ret = token_in ?
-        TS_RESP_verify_token(verify_ctx, token) :
-        TS_RESP_verify_response(verify_ctx, response);
+    ret = token_in
+        ? TS_RESP_verify_token(verify_ctx, token)
+        : TS_RESP_verify_response(verify_ctx, response);
 
  end:
     printf(&quot;Verification: &quot;);
@@ -959,11 +866,9 @@ static int verify_command(char *data, char *digest, char *queryfile,
         printf(&quot;OK\n&quot;);
     else {
         printf(&quot;FAILED\n&quot;);
-        /* Print errors, if there are any. */
         ERR_print_errors(bio_err);
     }
 
-    /* Clean up. */
     BIO_free_all(in_bio);
     PKCS7_free(token);
     TS_RESP_free(response);
@@ -1001,10 +906,6 @@ static TS_VERIFY_CTX *create_verify_ctx(char *data, char *digest,
         }
 
     } else if (queryfile != NULL) {
-        /*
-         * The request has just to be read, decoded and converted to a verify
-         * context object.
-         */
         if ((input = BIO_new_file(queryfile, &quot;rb&quot;)) == NULL)
             goto err;
         if ((request = d2i_TS_REQ_bio(input, NULL)) == NULL)
@@ -1026,8 +927,8 @@ static TS_VERIFY_CTX *create_verify_ctx(char *data, char *digest,
     if (untrusted
         &amp;&amp; TS_VERIFY_CTS_set_certs(ctx, TS_CONF_load_certs(untrusted)) == NULL)
         goto err;
-
     ret = 1;
+
  err:
     if (!ret) {
         TS_VERIFY_CTX_free(ctx);
@@ -1044,13 +945,8 @@ static X509_STORE *create_cert_store(char *CApath, char *CAfile)
     X509_LOOKUP *lookup = NULL;
     int i;
 
-    /* Creating the X509_STORE object. */
     cert_ctx = X509_STORE_new();
-
-    /* Setting the callback for certificate chain verification. */
     X509_STORE_set_verify_cb(cert_ctx, verify_cb);
-
-    /* Adding a trusted certificate directory source. */
     if (CApath) {
         lookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_hash_dir());
         if (lookup == NULL) {
@@ -1064,7 +960,6 @@ static X509_STORE *create_cert_store(char *CApath, char *CAfile)
         }
     }
 
-    /* Adding a trusted certificate file source. */
     if (CAfile) {
         lookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_file());
         if (lookup == NULL) {
@@ -1077,8 +972,8 @@ static X509_STORE *create_cert_store(char *CApath, char *CAfile)
             goto err;
         }
     }
-
     return cert_ctx;
+
  err:
     X509_STORE_free(cert_ctx);
     return NULL;
diff --git a/crypto/ts/ts_asn1.c b/crypto/ts/ts_asn1.c
index 59cc8b2..ba6c8d9 100644
--- a/crypto/ts/ts_asn1.c
+++ b/crypto/ts/ts_asn1.c
@@ -287,31 +287,22 @@ TS_TST_INFO *PKCS7_to_TS_TST_INFO(PKCS7 *token)
         TSerr(TS_F_PKCS7_TO_TS_TST_INFO, TS_R_BAD_PKCS7_TYPE);
         return NULL;
     }
-
-    /* Content must be present. */
     if (PKCS7_get_detached(token)) {
         TSerr(TS_F_PKCS7_TO_TS_TST_INFO, TS_R_DETACHED_CONTENT);
         return NULL;
     }
-
-    /* We have a signed data with content. */
     pkcs7_signed = token-&gt;d.sign;
     enveloped = pkcs7_signed-&gt;contents;
     if (OBJ_obj2nid(enveloped-&gt;type) != NID_id_smime_ct_TSTInfo) {
         TSerr(TS_F_PKCS7_TO_TS_TST_INFO, TS_R_BAD_PKCS7_TYPE);
         return NULL;
     }
-
-    /* We have a DER encoded TST_INFO as the signed data. */
     tst_info_wrapper = enveloped-&gt;d.other;
     if (tst_info_wrapper-&gt;type != V_ASN1_OCTET_STRING) {
         TSerr(TS_F_PKCS7_TO_TS_TST_INFO, TS_R_BAD_TYPE);
         return NULL;
     }
-
-    /* We have the correct ASN1_OCTET_STRING type. */
     tst_info_der = tst_info_wrapper-&gt;value.octet_string;
-    /* At last, decode the TST_INFO. */
     p = tst_info_der-&gt;data;
     return d2i_TS_TST_INFO(NULL, &amp;p, tst_info_der-&gt;length);
 }
diff --git a/crypto/ts/ts_conf.c b/crypto/ts/ts_conf.c
index 27b3df2..27b3ff6 100644
--- a/crypto/ts/ts_conf.c
+++ b/crypto/ts/ts_conf.c
@@ -68,7 +68,6 @@
 #include &lt;openssl/ts.h&gt;
 
 /* Macro definitions for the configuration file. */
-
 #define BASE_SECTION                    &quot;tsa&quot;
 #define ENV_DEFAULT_TSA                 &quot;default_tsa&quot;
 #define ENV_SERIAL                      &quot;serial&quot;
@@ -214,20 +213,17 @@ int TS_CONF_set_default_engine(const char *name)
     ENGINE *e = NULL;
     int ret = 0;
 
-    /* Leave the default if builtin specified. */
     if (strcmp(name, &quot;builtin&quot;) == 0)
         return 1;
 
     if ((e = ENGINE_by_id(name)) == NULL)
         goto err;
-
-    /* Enable the use of the NCipher HSM for forked children. */
     if (strcmp(name, &quot;chil&quot;) == 0)
         ENGINE_ctrl(e, ENGINE_CTRL_CHIL_SET_FORKCHECK, 1, 0, 0);
-    /* All the operations are going to be carried out by the engine. */
     if (!ENGINE_set_default(e, ENGINE_METHOD_ALL))
         goto err;
     ret = 1;
+
  err:
     if (!ret) {
         TSerr(TS_F_TS_CONF_SET_DEFAULT_ENGINE, TS_R_COULD_NOT_SET_ENGINE);
@@ -467,8 +463,8 @@ int TS_CONF_set_clock_precision_digits(CONF *conf, const char *section,
 static int ts_CONF_add_flag(CONF *conf, const char *section,
                             const char *field, int flag, TS_RESP_CTX *ctx)
 {
-    /* Default is false. */
     const char *value = NCONF_get_string(conf, section, field);
+
     if (value) {
         if (strcmp(value, ENV_VALUE_YES) == 0)
             TS_RESP_CTX_add_flags(ctx, flag);
diff --git a/crypto/ts/ts_lib.c b/crypto/ts/ts_lib.c
index cd9c19f..0b4ee03 100644
--- a/crypto/ts/ts_lib.c
+++ b/crypto/ts/ts_lib.c
@@ -66,10 +66,6 @@
 #include &lt;openssl/ts.h&gt;
 #include &quot;ts_lcl.h&quot;
 
-/* Local function declarations. */
-
-/* Function definitions. */
-
 int TS_ASN1_INTEGER_print_bio(BIO *bio, const ASN1_INTEGER *num)
 {
     BIGNUM *num_bn;
diff --git a/crypto/ts/ts_req_print.c b/crypto/ts/ts_req_print.c
index 0f618d5..2d4ea0e 100644
--- a/crypto/ts/ts_req_print.c
+++ b/crypto/ts/ts_req_print.c
@@ -65,8 +65,6 @@
 #include &lt;openssl/ts.h&gt;
 #include &quot;ts_lcl.h&quot;
 
-/* Function definitions. */
-
 int TS_REQ_print_bio(BIO *bio, TS_REQ *a)
 {
     int v;
diff --git a/crypto/ts/ts_rsp_print.c b/crypto/ts/ts_rsp_print.c
index f2fae69..007cc86 100644
--- a/crypto/ts/ts_rsp_print.c
+++ b/crypto/ts/ts_rsp_print.c
@@ -70,13 +70,10 @@ struct status_map_st {
     const char *text;
 };
 
-/* Local function declarations. */
-
 static int ts_status_map_print(BIO *bio, const struct status_map_st *a,
                                const ASN1_BIT_STRING *v);
 static int ts_ACCURACY_print_bio(BIO *bio, const TS_ACCURACY *accuracy);
 
-/* Function definitions. */
 
 int TS_RESP_print_bio(BIO *bio, TS_RESP *a)
 {
@@ -125,7 +122,6 @@ int TS_STATUS_INFO_print_bio(BIO *bio, TS_STATUS_INFO *a)
     long status;
     int i, lines = 0;
 
-    /* Printing status code. */
     BIO_printf(bio, &quot;Status: &quot;);
     status = ASN1_INTEGER_get(a-&gt;status);
     if (0 &lt;= status &amp;&amp; status &lt; (long)OSSL_NELEM(status_map))
@@ -133,7 +129,6 @@ int TS_STATUS_INFO_print_bio(BIO *bio, TS_STATUS_INFO *a)
     else
         BIO_printf(bio, &quot;out of bounds\n&quot;);
 
-    /* Printing status description. */
     BIO_printf(bio, &quot;Status description: &quot;);
     for (i = 0; i &lt; sk_ASN1_UTF8STRING_num(a-&gt;text); ++i) {
         if (i &gt; 0)
@@ -144,7 +139,6 @@ int TS_STATUS_INFO_print_bio(BIO *bio, TS_STATUS_INFO *a)
     if (i == 0)
         BIO_printf(bio, &quot;unspecified\n&quot;);
 
-    /* Printing failure information. */
     BIO_printf(bio, &quot;Failure info: &quot;);
     if (a-&gt;failure_info != NULL)
         lines = ts_status_map_print(bio, failure_map, a-&gt;failure_info);
@@ -178,18 +172,14 @@ int TS_TST_INFO_print_bio(BIO *bio, TS_TST_INFO *a)
     if (a == NULL)
         return 0;
 
-    /* Print version. */
     v = ASN1_INTEGER_get(a-&gt;version);
     BIO_printf(bio, &quot;Version: %d\n&quot;, v);
 
-    /* Print policy id. */
     BIO_printf(bio, &quot;Policy OID: &quot;);
     TS_OBJ_print_bio(bio, a-&gt;policy_id);
 
-    /* Print message imprint. */
     TS_MSG_IMPRINT_print_bio(bio, a-&gt;msg_imprint);
 
-    /* Print serial number. */
     BIO_printf(bio, &quot;Serial number: &quot;);
     if (a-&gt;serial == NULL)
         BIO_printf(bio, &quot;unspecified&quot;);
@@ -197,12 +187,10 @@ int TS_TST_INFO_print_bio(BIO *bio, TS_TST_INFO *a)
         TS_ASN1_INTEGER_print_bio(bio, a-&gt;serial);
     BIO_write(bio, &quot;\n&quot;, 1);
 
-    /* Print time stamp. */
     BIO_printf(bio, &quot;Time stamp: &quot;);
     ASN1_GENERALIZEDTIME_print(bio, a-&gt;time);
     BIO_write(bio, &quot;\n&quot;, 1);
 
-    /* Print accuracy. */
     BIO_printf(bio, &quot;Accuracy: &quot;);
     if (a-&gt;accuracy == NULL)
         BIO_printf(bio, &quot;unspecified&quot;);
@@ -210,10 +198,8 @@ int TS_TST_INFO_print_bio(BIO *bio, TS_TST_INFO *a)
         ts_ACCURACY_print_bio(bio, a-&gt;accuracy);
     BIO_write(bio, &quot;\n&quot;, 1);
 
-    /* Print ordering. */
     BIO_printf(bio, &quot;Ordering: %s\n&quot;, a-&gt;ordering ? &quot;yes&quot; : &quot;no&quot;);
 
-    /* Print nonce. */
     BIO_printf(bio, &quot;Nonce: &quot;);
     if (a-&gt;nonce == NULL)
         BIO_printf(bio, &quot;unspecified&quot;);
@@ -221,7 +207,6 @@ int TS_TST_INFO_print_bio(BIO *bio, TS_TST_INFO *a)
         TS_ASN1_INTEGER_print_bio(bio, a-&gt;nonce);
     BIO_write(bio, &quot;\n&quot;, 1);
 
-    /* Print TSA name. */
     BIO_printf(bio, &quot;TSA: &quot;);
     if (a-&gt;tsa == NULL)
         BIO_printf(bio, &quot;unspecified&quot;);
@@ -233,7 +218,6 @@ int TS_TST_INFO_print_bio(BIO *bio, TS_TST_INFO *a)
     }
     BIO_write(bio, &quot;\n&quot;, 1);
 
-    /* Print extensions. */
     TS_ext_print_bio(bio, a-&gt;extensions);
 
     return 1;
diff --git a/crypto/ts/ts_rsp_sign.c b/crypto/ts/ts_rsp_sign.c
index f7fb762..3694239 100644
--- a/crypto/ts/ts_rsp_sign.c
+++ b/crypto/ts/ts_rsp_sign.c
@@ -68,8 +68,6 @@
 #include &lt;openssl/pkcs7.h&gt;
 #include &quot;ts_lcl.h&quot;
 
-/* Private function declarations. */
-
 static ASN1_INTEGER *def_serial_cb(struct TS_resp_ctx *, void *);
 static int def_time_cb(struct TS_resp_ctx *, void *, long *sec, long *usec);
 static int def_extension_cb(struct TS_resp_ctx *, X509_EXTENSION *, void *);
@@ -93,16 +91,17 @@ static ASN1_GENERALIZEDTIME
 *TS_RESP_set_genTime_with_precision(ASN1_GENERALIZEDTIME *, long, long,
                                     unsigned);
 
-/* Default callbacks for response generation. */
-
+/* Default callback for response generation. */
 static ASN1_INTEGER *def_serial_cb(struct TS_resp_ctx *ctx, void *data)
 {
     ASN1_INTEGER *serial = ASN1_INTEGER_new();
+
     if (!serial)
         goto err;
     if (!ASN1_INTEGER_set(serial, 1))
         goto err;
     return serial;
+
  err:
     TSerr(TS_F_DEF_SERIAL_CB, ERR_R_MALLOC_FAILURE);
     TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
@@ -112,7 +111,6 @@ static ASN1_INTEGER *def_serial_cb(struct TS_resp_ctx *ctx, void *data)
 
 #if defined(OPENSSL_SYS_UNIX)
 
-/* Use the gettimeofday function call. */
 static int def_time_cb(struct TS_resp_ctx *ctx, void *data,
                        long *sec, long *usec)
 {
@@ -124,7 +122,6 @@ static int def_time_cb(struct TS_resp_ctx *ctx, void *data,
         TS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);
         return 0;
     }
-    /* Return time to caller. */
     *sec = tv.tv_sec;
     *usec = tv.tv_usec;
 
@@ -133,7 +130,6 @@ static int def_time_cb(struct TS_resp_ctx *ctx, void *data,
 
 #else
 
-/* Use the time function call that provides only seconds precision. */
 static int def_time_cb(struct TS_resp_ctx *ctx, void *data,
                        long *sec, long *usec)
 {
@@ -145,7 +141,6 @@ static int def_time_cb(struct TS_resp_ctx *ctx, void *data,
         TS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);
         return 0;
     }
-    /* Return time to caller, only second precision. */
     *sec = (long)t;
     *usec = 0;
 
@@ -157,7 +152,6 @@ static int def_time_cb(struct TS_resp_ctx *ctx, void *data,
 static int def_extension_cb(struct TS_resp_ctx *ctx, X509_EXTENSION *ext,
                             void *data)
 {
-    /* No extensions are processed here. */
     TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
                                 &quot;Unsupported extension.&quot;);
     TS_RESP_CTX_add_failure_info(ctx, TS_INFO_UNACCEPTED_EXTENSION);
@@ -175,7 +169,6 @@ TS_RESP_CTX *TS_RESP_CTX_new()
         return NULL;
     }
 
-    /* Setting default callbacks. */
     ctx-&gt;serial_cb = def_serial_cb;
     ctx-&gt;time_cb = def_time_cb;
     ctx-&gt;extension_cb = def_extension_cb;
@@ -252,7 +245,6 @@ int TS_RESP_CTX_add_policy(TS_RESP_CTX *ctx, ASN1_OBJECT *policy)
 {
     ASN1_OBJECT *copy = NULL;
 
-    /* Create new policy stack if necessary. */
     if (ctx-&gt;policies == NULL
         &amp;&amp; (ctx-&gt;policies = sk_ASN1_OBJECT_new_null()) == NULL)
         goto err;
@@ -270,11 +262,9 @@ int TS_RESP_CTX_add_policy(TS_RESP_CTX *ctx, ASN1_OBJECT *policy)
 
 int TS_RESP_CTX_add_md(TS_RESP_CTX *ctx, const EVP_MD *md)
 {
-    /* Create new md stack if necessary. */
     if (ctx-&gt;mds == NULL
         &amp;&amp; (ctx-&gt;mds = sk_EVP_MD_new_null()) == NULL)
         goto err;
-    /* Add the shared md, no copy needed. */
     if (!sk_EVP_MD_push(ctx-&gt;mds, (EVP_MD *)md))
         goto err;
 
@@ -381,7 +371,6 @@ int TS_RESP_CTX_set_status_info_cond(TS_RESP_CTX *ctx,
     TS_STATUS_INFO *si = ctx-&gt;response-&gt;status_info;
 
     if (ASN1_INTEGER_get(si-&gt;status) == TS_STATUS_GRANTED) {
-        /* Status has not been set, set it now. */
         ret = TS_RESP_CTX_set_status_info(ctx, status, text);
     }
     return ret;
@@ -429,46 +418,30 @@ TS_RESP *TS_RESP_create_response(TS_RESP_CTX *ctx, BIO *req_bio)
 
     ts_RESP_CTX_init(ctx);
 
-    /* Creating the response object. */
     if ((ctx-&gt;response = TS_RESP_new()) == NULL) {
         TSerr(TS_F_TS_RESP_CREATE_RESPONSE, ERR_R_MALLOC_FAILURE);
         goto end;
     }
-
-    /* Parsing DER request. */
     if ((ctx-&gt;request = d2i_TS_REQ_bio(req_bio, NULL)) == NULL) {
         TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
-                                    &quot;Bad request format or &quot; &quot;system error.&quot;);
+                                    &quot;Bad request format or system error.&quot;);
         TS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_DATA_FORMAT);
         goto end;
     }
-
-    /* Setting default status info. */
     if (!TS_RESP_CTX_set_status_info(ctx, TS_STATUS_GRANTED, NULL))
         goto end;
-
-    /* Checking the request format. */
     if (!ts_RESP_check_request(ctx))
         goto end;
-
-    /* Checking acceptable policies. */
     if ((policy = ts_RESP_get_policy(ctx)) == NULL)
         goto end;
-
-    /* Creating the TS_TST_INFO object. */
     if ((ctx-&gt;tst_info = ts_RESP_create_tst_info(ctx, policy)) == NULL)
         goto end;
-
-    /* Processing extensions. */
     if (!ts_RESP_process_extensions(ctx))
         goto end;
-
-    /* Generating the signature. */
     if (!ts_RESP_sign(ctx))
         goto end;
-
-    /* Everything was successful. */
     result = 1;
+
  end:
     if (!result) {
         TSerr(TS_F_TS_RESP_CREATE_RESPONSE, TS_R_RESPONSE_SETUP_ERROR);
@@ -518,7 +491,6 @@ static int ts_RESP_check_request(TS_RESP_CTX *ctx)
     EVP_MD *md = NULL;
     int i;
 
-    /* Checking request version. */
     if (TS_REQ_get_version(request) != 1) {
         TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
                                     &quot;Bad request version.&quot;);
@@ -526,7 +498,6 @@ static int ts_RESP_check_request(TS_RESP_CTX *ctx)
         return 0;
     }
 
-    /* Checking message digest algorithm. */
     msg_imprint = request-&gt;msg_imprint;
     md_alg = msg_imprint-&gt;hash_algo;
     md_alg_id = OBJ_obj2nid(md_alg-&gt;algorithm);
@@ -543,7 +514,6 @@ static int ts_RESP_check_request(TS_RESP_CTX *ctx)
         return 0;
     }
 
-    /* No message digest takes parameter. */
     if (md_alg-&gt;parameter &amp;&amp; ASN1_TYPE_get(md_alg-&gt;parameter) != V_ASN1_NULL) {
         TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
                                     &quot;Superfluous message digest &quot;
@@ -551,7 +521,6 @@ static int ts_RESP_check_request(TS_RESP_CTX *ctx)
         TS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_ALG);
         return 0;
     }
-    /* Checking message digest size. */
     digest = msg_imprint-&gt;hashed_msg;
     if (digest-&gt;length != EVP_MD_size(md)) {
         TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
@@ -574,10 +543,6 @@ static ASN1_OBJECT *ts_RESP_get_policy(TS_RESP_CTX *ctx)
         TSerr(TS_F_TS_RESP_GET_POLICY, TS_R_INVALID_NULL_POINTER);
         return NULL;
     }
-    /*
-     * Return the default policy if none is requested or the default is
-     * requested.
-     */
     if (!requested || !OBJ_cmp(requested, ctx-&gt;default_policy))
         policy = ctx-&gt;default_policy;
 
@@ -627,11 +592,9 @@ static TS_TST_INFO *ts_RESP_create_tst_info(TS_RESP_CTX *ctx,
         || !TS_TST_INFO_set_time(tst_info, asn1_time))
         goto end;
 
-    /* Setting accuracy if needed. */
     if ((ctx-&gt;seconds || ctx-&gt;millis || ctx-&gt;micros)
         &amp;&amp; (accuracy = TS_ACCURACY_new()) == NULL)
         goto end;
-
     if (ctx-&gt;seconds &amp;&amp; !TS_ACCURACY_set_seconds(accuracy, ctx-&gt;seconds))
         goto end;
     if (ctx-&gt;millis &amp;&amp; !TS_ACCURACY_set_millis(accuracy, ctx-&gt;millis))
@@ -641,17 +604,14 @@ static TS_TST_INFO *ts_RESP_create_tst_info(TS_RESP_CTX *ctx,
     if (accuracy &amp;&amp; !TS_TST_INFO_set_accuracy(tst_info, accuracy))
         goto end;
 
-    /* Setting ordering. */
     if ((ctx-&gt;flags &amp; TS_ORDERING)
         &amp;&amp; !TS_TST_INFO_set_ordering(tst_info, 1))
         goto end;
 
-    /* Setting nonce if needed. */
     if ((nonce = ctx-&gt;request-&gt;nonce) != NULL
         &amp;&amp; !TS_TST_INFO_set_nonce(tst_info, nonce))
         goto end;
 
-    /* Setting TSA name to subject of signer certificate. */
     if (ctx-&gt;flags &amp; TS_TSA_NAME) {
         if ((tsa_name = GENERAL_NAME_new()) == NULL)
             goto end;
@@ -692,7 +652,7 @@ static int ts_RESP_process_extensions(TS_RESP_CTX *ctx)
     for (i = 0; ok &amp;&amp; i &lt; sk_X509_EXTENSION_num(exts); ++i) {
         X509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);
         /*
-         * XXXXX The last argument was previously (void *)ctx-&gt;extension_cb,
+         * The last argument was previously (void *)ctx-&gt;extension_cb,
          * but ISO C doesn't permit converting a function pointer to void *.
          * For lack of better information, I'm placing a NULL there instead.
          * The callback can pick its own address out from the ctx anyway...
@@ -715,25 +675,20 @@ static int ts_RESP_sign(TS_RESP_CTX *ctx)
     BIO *p7bio = NULL;
     int i;
 
-    /* Check if signcert and pkey match. */
     if (!X509_check_private_key(ctx-&gt;signer_cert, ctx-&gt;signer_key)) {
         TSerr(TS_F_TS_RESP_SIGN, TS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
         goto err;
     }
 
-    /* Create a new PKCS7 signed object. */
     if ((p7 = PKCS7_new()) == NULL) {
         TSerr(TS_F_TS_RESP_SIGN, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (!PKCS7_set_type(p7, NID_pkcs7_signed))
         goto err;
-
-    /* Force SignedData version to be 3 instead of the default 1. */
     if (!ASN1_INTEGER_set(p7-&gt;d.sign-&gt;version, 3))
         goto err;
 
-    /* Add signer certificate and optional certificate chain. */
     if (ctx-&gt;request-&gt;cert_req) {
         PKCS7_add_certificate(p7, ctx-&gt;signer_cert);
         if (ctx-&gt;certs) {
@@ -744,14 +699,12 @@ static int ts_RESP_sign(TS_RESP_CTX *ctx)
         }
     }
 
-    /* Add a new signer info. */
     if ((si = PKCS7_add_signature(p7, ctx-&gt;signer_cert,
                                   ctx-&gt;signer_key, EVP_sha1())) == NULL) {
         TSerr(TS_F_TS_RESP_SIGN, TS_R_PKCS7_ADD_SIGNATURE_ERROR);
         goto err;
     }
 
-    /* Add content type signed attribute to the signer info. */
     oid = OBJ_nid2obj(NID_id_smime_ct_TSTInfo);
     if (!PKCS7_add_signed_attribute(si, NID_pkcs9_contentType,
                                     V_ASN1_OBJECT, oid)) {
@@ -759,43 +712,28 @@ static int ts_RESP_sign(TS_RESP_CTX *ctx)
         goto err;
     }
 
-    /*
-     * Create the ESS SigningCertificate attribute which contains the signer
-     * certificate id and optionally the certificate chain.
-     */
     certs = ctx-&gt;flags &amp; TS_ESS_CERT_ID_CHAIN ? ctx-&gt;certs : NULL;
     if ((sc = ess_SIGNING_CERT_new_init(ctx-&gt;signer_cert, certs)) == NULL)
         goto err;
-
-    /* Add SigningCertificate signed attribute to the signer info. */
     if (!ESS_add_signing_cert(si, sc)) {
         TSerr(TS_F_TS_RESP_SIGN, TS_R_ESS_ADD_SIGNING_CERT_ERROR);
         goto err;
     }
 
-    /* Add a new empty NID_id_smime_ct_TSTInfo encapsulated content. */
     if (!ts_TST_INFO_content_new(p7))
         goto err;
-
-    /* Add the DER encoded tst_info to the PKCS7 structure. */
     if ((p7bio = PKCS7_dataInit(p7, NULL)) == NULL) {
         TSerr(TS_F_TS_RESP_SIGN, ERR_R_MALLOC_FAILURE);
         goto err;
     }
-
-    /* Convert tst_info to DER. */
     if (!i2d_TS_TST_INFO_bio(p7bio, ctx-&gt;tst_info)) {
         TSerr(TS_F_TS_RESP_SIGN, TS_R_TS_DATASIGN);
         goto err;
     }
-
-    /* Create the signature and add it to the signer info. */
     if (!PKCS7_dataFinal(p7, p7bio)) {
         TSerr(TS_F_TS_RESP_SIGN, TS_R_TS_DATASIGN);
         goto err;
     }
-
-    /* Set new PKCS7 and TST_INFO objects. */
     TS_RESP_set_tst_info(ctx-&gt;response, p7, ctx-&gt;tst_info);
     p7 = NULL;                  /* Ownership is lost. */
     ctx-&gt;tst_info = NULL;       /* Ownership is lost. */
@@ -819,18 +757,15 @@ static ESS_SIGNING_CERT *ess_SIGNING_CERT_new_init(X509 *signcert,
     ESS_SIGNING_CERT *sc = NULL;
     int i;
 
-    /* Creating the ESS_CERT_ID stack. */
     if ((sc = ESS_SIGNING_CERT_new()) == NULL)
         goto err;
     if (sc-&gt;cert_ids == NULL
         &amp;&amp; (sc-&gt;cert_ids = sk_ESS_CERT_ID_new_null()) == NULL)
         goto err;
 
-    /* Adding the signing certificate id. */
     if ((cid = ess_CERT_ID_new_init(signcert, 0)) == NULL
         || !sk_ESS_CERT_ID_push(sc-&gt;cert_ids, cid))
         goto err;
-    /* Adding the certificate chain ids. */
     for (i = 0; i &lt; sk_X509_num(certs); ++i) {
         X509 *cert = sk_X509_value(certs, i);
         if ((cid = ess_CERT_ID_new_init(cert, 1)) == NULL
@@ -850,9 +785,7 @@ static ESS_CERT_ID *ess_CERT_ID_new_init(X509 *cert, int issuer_needed)
     ESS_CERT_ID *cid = NULL;
     GENERAL_NAME *name = NULL;
 
-    /* Recompute SHA1 hash of certificate if necessary (side effect). */
     X509_check_purpose(cert, -1, 0);
-
     if ((cid = ESS_CERT_ID_new()) == NULL)
         goto err;
     if (!ASN1_OCTET_STRING_set(cid-&gt;hash, cert-&gt;sha1_hash,
@@ -861,11 +794,9 @@ static ESS_CERT_ID *ess_CERT_ID_new_init(X509 *cert, int issuer_needed)
 
     /* Setting the issuer/serial if requested. */
     if (issuer_needed) {
-        /* Creating issuer/serial structure. */
         if (cid-&gt;issuer_serial == NULL
             &amp;&amp; (cid-&gt;issuer_serial = ESS_ISSUER_SERIAL_new()) == NULL)
             goto err;
-        /* Creating general name from the certificate issuer. */
         if ((name = GENERAL_NAME_new()) == NULL)
             goto err;
         name-&gt;type = GEN_DIRNAME;
@@ -874,7 +805,6 @@ static ESS_CERT_ID *ess_CERT_ID_new_init(X509 *cert, int issuer_needed)
         if (!sk_GENERAL_NAME_push(cid-&gt;issuer_serial-&gt;issuer, name))
             goto err;
         name = NULL;            /* Ownership is lost. */
-        /* Setting the serial number. */
         ASN1_INTEGER_free(cid-&gt;issuer_serial-&gt;serial);
         if (!(cid-&gt;issuer_serial-&gt;serial =
               ASN1_INTEGER_dup(X509_get_serialNumber(cert))))
@@ -973,12 +903,7 @@ static ASN1_GENERALIZEDTIME
                       tm-&gt;tm_year + 1900, tm-&gt;tm_mon + 1, tm-&gt;tm_mday,
                       tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);
     if (precision &gt; 0) {
-        /* Add fraction of seconds (leave space for dot and null). */
         BIO_snprintf(p, 2 + precision, &quot;.%06ld&quot;, usec);
-        /*
-         * We cannot use the snprintf return value, because it might have
-         * been truncated.
-         */
         p += strlen(p);
 
         /*
@@ -997,18 +922,13 @@ static ASN1_GENERALIZEDTIME
          * this loop even if all the digits are zero.
          */
         while (*--p == '0')
-            /*
-             * empty
-             */ ;
-        /* p points to either the dot or the last non-zero digit. */
+             continue;
         if (*p != '.')
             ++p;
     }
-    /* Add the trailing Z and the terminating null. */
     *p++ = 'Z';
     *p++ = '\0';
 
-    /* Now call OpenSSL to check and set our genTime value */
     if (asn1_time == NULL
         &amp;&amp; (asn1_time = ASN1_GENERALIZEDTIME_new()) == NULL)
         goto err;
@@ -1016,8 +936,8 @@ static ASN1_GENERALIZEDTIME
         ASN1_GENERALIZEDTIME_free(asn1_time);
         goto err;
     }
-
     return asn1_time;
+
  err:
     TSerr(TS_F_TS_RESP_SET_GENTIME_WITH_PRECISION, TS_R_COULD_NOT_SET_TIME);
     return NULL;
diff --git a/crypto/ts/ts_rsp_utils.c b/crypto/ts/ts_rsp_utils.c
index 887d314..2db3b17 100644
--- a/crypto/ts/ts_rsp_utils.c
+++ b/crypto/ts/ts_rsp_utils.c
@@ -64,8 +64,6 @@
 #include &lt;openssl/pkcs7.h&gt;
 #include &quot;ts_lcl.h&quot;
 
-/* Function definitions. */
-
 int TS_RESP_set_status_info(TS_RESP *a, TS_STATUS_INFO *status_info)
 {
     TS_STATUS_INFO *new_status_info;
@@ -91,7 +89,6 @@ TS_STATUS_INFO *TS_RESP_get_status_info(TS_RESP *a)
 /* Caller loses ownership of PKCS7 and TS_TST_INFO objects. */
 void TS_RESP_set_tst_info(TS_RESP *a, PKCS7 *p7, TS_TST_INFO *tst_info)
 {
-    /* Set new PKCS7 and TST_INFO objects. */
     PKCS7_free(a-&gt;token);
     a-&gt;token = p7;
     TS_TST_INFO_free(a-&gt;tst_info);
diff --git a/crypto/ts/ts_rsp_verify.c b/crypto/ts/ts_rsp_verify.c
index 93a775e..1133b5d 100644
--- a/crypto/ts/ts_rsp_verify.c
+++ b/crypto/ts/ts_rsp_verify.c
@@ -64,8 +64,6 @@
 #include &lt;openssl/pkcs7.h&gt;
 #include &quot;ts_lcl.h&quot;
 
-/* Private function declarations. */
-
 static int ts_verify_cert(X509_STORE *store, STACK_OF(X509) *untrusted,
                           X509 *signer, STACK_OF(X509) **chain);
 static int ts_check_signing_certs(PKCS7_SIGNER_INFO *si,
@@ -126,7 +124,6 @@ static struct {
 
 #define TS_FAILURE_INFO_SIZE    OSSL_NELEM(ts_failure_info)
 
-/* Functions for verifying a signed TS_TST_INFO structure. */
 
 /*-
  * This function carries out the following tasks:
@@ -157,22 +154,16 @@ int TS_RESP_verify_signature(PKCS7 *token, STACK_OF(X509) *certs,
         TSerr(TS_F_TS_RESP_VERIFY_SIGNATURE, TS_R_INVALID_NULL_POINTER);
         goto err;
     }
-
-    /* Check for the correct content type */
     if (!PKCS7_type_is_signed(token)) {
         TSerr(TS_F_TS_RESP_VERIFY_SIGNATURE, TS_R_WRONG_CONTENT_TYPE);
         goto err;
     }
-
-    /* Check if there is one and only one signer. */
     sinfos = PKCS7_get_signer_info(token);
     if (!sinfos || sk_PKCS7_SIGNER_INFO_num(sinfos) != 1) {
         TSerr(TS_F_TS_RESP_VERIFY_SIGNATURE, TS_R_THERE_MUST_BE_ONE_SIGNER);
         goto err;
     }
     si = sk_PKCS7_SIGNER_INFO_value(sinfos, 0);
-
-    /* Check for no content: no data to verify signature. */
     if (PKCS7_get_detached(token)) {
         TSerr(TS_F_TS_RESP_VERIFY_SIGNATURE, TS_R_NO_CONTENT);
         goto err;
@@ -187,35 +178,26 @@ int TS_RESP_verify_signature(PKCS7 *token, STACK_OF(X509) *certs,
         goto err;
     signer = sk_X509_value(signers, 0);
 
-    /* Now verify the certificate. */
     if (!ts_verify_cert(store, certs, signer, &amp;chain))
         goto err;
-
-    /*
-     * Check if the signer certificate is consistent with the ESS extension.
-     */
     if (!ts_check_signing_certs(si, chain))
         goto err;
-
-    /* Creating the message digest. */
     p7bio = PKCS7_dataInit(token, NULL);
 
     /* We now have to 'read' from p7bio to calculate digests etc. */
-    while ((i = BIO_read(p7bio, buf, sizeof(buf))) &gt; 0) ;
+    while ((i = BIO_read(p7bio, buf, sizeof(buf))) &gt; 0)
+        continue;
 
-    /* Verifying the signature. */
     j = PKCS7_signatureVerify(p7bio, token, si, signer);
     if (j &lt;= 0) {
         TSerr(TS_F_TS_RESP_VERIFY_SIGNATURE, TS_R_SIGNATURE_FAILURE);
         goto err;
     }
 
-    /* Return the signer certificate if needed. */
     if (signer_out) {
         *signer_out = signer;
         X509_up_ref(signer);
     }
-
     ret = 1;
 
  err:
@@ -237,7 +219,6 @@ static int ts_verify_cert(X509_STORE *store, STACK_OF(X509) *untrusted,
     int i;
     int ret = 1;
 
-    /* chain is an out argument. */
     *chain = NULL;
     X509_STORE_CTX_init(&amp;cert_ctx, store, signer, untrusted);
     X509_STORE_CTX_set_purpose(&amp;cert_ctx, X509_PURPOSE_TIMESTAMP_SIGN);
@@ -249,7 +230,6 @@ static int ts_verify_cert(X509_STORE *store, STACK_OF(X509) *untrusted,
                            X509_verify_cert_error_string(j));
         ret = 0;
     } else {
-        /* Get a copy of the certificate chain. */
         *chain = X509_STORE_CTX_get1_chain(&amp;cert_ctx);
     }
 
@@ -270,7 +250,6 @@ static int ts_check_signing_certs(PKCS7_SIGNER_INFO *si,
     if (!ss)
         goto err;
     cert_ids = ss-&gt;cert_ids;
-    /* The signer certificate must be the first in cert_ids. */
     cert = sk_X509_value(chain, 0);
     if (ts_find_cert(cert_ids, cert) != 0)
         goto err;
@@ -280,7 +259,6 @@ static int ts_check_signing_certs(PKCS7_SIGNER_INFO *si,
      * certificate ids in cert_ids.
      */
     if (sk_ESS_CERT_ID_num(cert_ids) &gt; 1) {
-        /* All the certificates of the chain must be in cert_ids. */
         for (i = 1; i &lt; sk_X509_num(chain); ++i) {
             cert = sk_X509_value(chain, i);
             if (ts_find_cert(cert_ids, cert) &lt; 0)
@@ -322,11 +300,9 @@ static int ts_find_cert(STACK_OF(ESS_CERT_ID) *cert_ids, X509 *cert)
     for (i = 0; i &lt; sk_ESS_CERT_ID_num(cert_ids); ++i) {
         ESS_CERT_ID *cid = sk_ESS_CERT_ID_value(cert_ids, i);
 
-        /* Check the SHA-1 hash first. */
         if (cid-&gt;hash-&gt;length == sizeof(cert-&gt;sha1_hash)
-            &amp;&amp; !memcmp(cid-&gt;hash-&gt;data, cert-&gt;sha1_hash,
-                       sizeof(cert-&gt;sha1_hash))) {
-            /* Check the issuer/serial as well if specified. */
+            &amp;&amp; memcmp(cid-&gt;hash-&gt;data, cert-&gt;sha1_hash,
+                       sizeof(cert-&gt;sha1_hash)) == 0) {
             ESS_ISSUER_SERIAL *is = cid-&gt;issuer_serial;
             if (!is || !ts_issuer_serial_cmp(is, cert))
                 return i;
@@ -343,13 +319,11 @@ static int ts_issuer_serial_cmp(ESS_ISSUER_SERIAL *is, X509 *cert)
     if (!is || !cert || sk_GENERAL_NAME_num(is-&gt;issuer) != 1)
         return -1;
 
-    /* Check the issuer first. It must be a directory name. */
     issuer = sk_GENERAL_NAME_value(is-&gt;issuer, 0);
     if (issuer-&gt;type != GEN_DIRNAME
         || X509_NAME_cmp(issuer-&gt;d.dirn, X509_get_issuer_name(cert)))
         return -1;
 
-    /* Check the serial number, too. */
     if (ASN1_INTEGER_cmp(is-&gt;serial, X509_get_serialNumber(cert)))
         return -1;
 
@@ -368,15 +342,12 @@ int TS_RESP_verify_response(TS_VERIFY_CTX *ctx, TS_RESP *response)
     TS_TST_INFO *tst_info = response-&gt;tst_info;
     int ret = 0;
 
-    /* Check if we have a successful TS_TST_INFO object in place. */
     if (!ts_check_status_info(response))
         goto err;
-
-    /* Check the contents of the time stamp token. */
     if (!int_ts_RESP_verify_token(ctx, token, tst_info))
         goto err;
-
     ret = 1;
+
  err:
     return ret;
 }
@@ -418,56 +389,41 @@ static int int_ts_RESP_verify_token(TS_VERIFY_CTX *ctx,
     unsigned imprint_len = 0;
     int ret = 0;
 
-    /* Verify the signature. */
     if ((ctx-&gt;flags &amp; TS_VFY_SIGNATURE)
         &amp;&amp; !TS_RESP_verify_signature(token, ctx-&gt;certs, ctx-&gt;store, &amp;signer))
         goto err;
-
-    /* Check version number of response. */
     if ((ctx-&gt;flags &amp; TS_VFY_VERSION)
         &amp;&amp; TS_TST_INFO_get_version(tst_info) != 1) {
         TSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_UNSUPPORTED_VERSION);
         goto err;
     }
-
-    /* Check policies. */
     if ((ctx-&gt;flags &amp; TS_VFY_POLICY)
         &amp;&amp; !ts_check_policy(ctx-&gt;policy, tst_info))
         goto err;
-
-    /* Check message imprints. */
     if ((ctx-&gt;flags &amp; TS_VFY_IMPRINT)
         &amp;&amp; !ts_check_imprints(ctx-&gt;md_alg, ctx-&gt;imprint, ctx-&gt;imprint_len,
                               tst_info))
         goto err;
-
-    /* Compute and check message imprints. */
     if ((ctx-&gt;flags &amp; TS_VFY_DATA)
         &amp;&amp; (!ts_compute_imprint(ctx-&gt;data, tst_info,
                                 &amp;md_alg, &amp;imprint, &amp;imprint_len)
             || !ts_check_imprints(md_alg, imprint, imprint_len, tst_info)))
         goto err;
-
-    /* Check nonces. */
     if ((ctx-&gt;flags &amp; TS_VFY_NONCE)
         &amp;&amp; !ts_check_nonces(ctx-&gt;nonce, tst_info))
         goto err;
-
-    /* Check whether TSA name and signer certificate match. */
     if ((ctx-&gt;flags &amp; TS_VFY_SIGNER)
         &amp;&amp; tsa_name &amp;&amp; !ts_check_signer_name(tsa_name, signer)) {
         TSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_TSA_NAME_MISMATCH);
         goto err;
     }
-
-    /* Check whether the TSA is the expected one. */
     if ((ctx-&gt;flags &amp; TS_VFY_TSA_NAME)
         &amp;&amp; !ts_check_signer_name(ctx-&gt;tsa_name, signer)) {
         TSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_TSA_UNTRUSTED);
         goto err;
     }
-
     ret = 1;
+
  err:
     X509_free(signer);
     X509_ALGOR_free(md_alg);
@@ -483,7 +439,6 @@ static int ts_check_status_info(TS_RESP *response)
     char *embedded_status_text = NULL;
     char failure_text[TS_STATUS_BUF_SIZE] = &quot;&quot;;
 
-    /* Check if everything went fine. */
     if (status == 0 || status == 1)
         return 1;
 
@@ -493,16 +448,15 @@ static int ts_check_status_info(TS_RESP *response)
     else
         status_text = &quot;unknown code&quot;;
 
-    /* Set the embedded_status_text to the returned description. */
     if (sk_ASN1_UTF8STRING_num(info-&gt;text) &gt; 0
         &amp;&amp; (embedded_status_text = ts_get_status_text(info-&gt;text)) == NULL)
         return 0;
 
-    /* Filling in failure_text with the failure information. */
+    /* Fill in failure_text with the failure information. */
     if (info-&gt;failure_info) {
         int i;
         int first = 1;
-        for (i = 0; i &lt; (int)TS_FAILURE_INFO_SIZE; ++i) {
+        for (i = 0; i &lt; (int)OSSL_NELEM(ts_failure_info); ++i) {
             if (ASN1_BIT_STRING_get_bit(info-&gt;failure_info,
                                         ts_failure_info[i].code)) {
                 if (!first)
@@ -516,7 +470,6 @@ static int ts_check_status_info(TS_RESP *response)
     if (failure_text[0] == '\0')
         strcpy(failure_text, &quot;unspecified&quot;);
 
-    /* Making up the error string. */
     TSerr(TS_F_TS_CHECK_STATUS_INFO, TS_R_NO_TIME_STAMP_TOKEN);
     ERR_add_error_data(6,
                        &quot;status code: &quot;, status_text,
@@ -535,18 +488,16 @@ static char *ts_get_status_text(STACK_OF(ASN1_UTF8STRING) *text)
     char *result = NULL;
     char *p;
 
-    /* Determine length first. */
     for (i = 0; i &lt; sk_ASN1_UTF8STRING_num(text); ++i) {
         ASN1_UTF8STRING *current = sk_ASN1_UTF8STRING_value(text, i);
         length += ASN1_STRING_length(current);
         length += 1;            /* separator character */
     }
-    /* Allocate memory (closing '\0' included). */
     if ((result = OPENSSL_malloc(length)) == NULL) {
         TSerr(TS_F_TS_GET_STATUS_TEXT, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
-    /* Concatenate the descriptions. */
+    
     for (i = 0, p = result; i &lt; sk_ASN1_UTF8STRING_num(text); ++i) {
         ASN1_UTF8STRING *current = sk_ASN1_UTF8STRING_value(text, i);
         length = ASN1_STRING_length(current);
@@ -555,7 +506,6 @@ static char *ts_get_status_text(STACK_OF(ASN1_UTF8STRING) *text)
         strncpy(p, (const char *)ASN1_STRING_data(current), length);
         p += length;
     }
-    /* We do have space for this, too. */
     *p = '\0';
 
     return result;
@@ -587,17 +537,12 @@ static int ts_compute_imprint(BIO *data, TS_TST_INFO *tst_info,
     *md_alg = NULL;
     *imprint = NULL;
 
-    /* Return the MD algorithm of the response. */
     if ((*md_alg = X509_ALGOR_dup(md_alg_resp)) == NULL)
         goto err;
-
-    /* Getting the MD object. */
     if ((md = EVP_get_digestbyobj((*md_alg)-&gt;algorithm)) == NULL) {
         TSerr(TS_F_TS_COMPUTE_IMPRINT, TS_R_UNSUPPORTED_MD_ALGORITHM);
         goto err;
     }
-
-    /* Compute message digest. */
     length = EVP_MD_size(md);
     if (length &lt; 0)
         goto err;
@@ -633,9 +578,7 @@ static int ts_check_imprints(X509_ALGOR *algor_a,
     X509_ALGOR *algor_b = b-&gt;hash_algo;
     int ret = 0;
 
-    /* algor_a is optional. */
     if (algor_a) {
-        /* Compare algorithm OIDs. */
         if (OBJ_cmp(algor_a-&gt;algorithm, algor_b-&gt;algorithm))
             goto err;
 
@@ -647,7 +590,6 @@ static int ts_check_imprints(X509_ALGOR *algor_a,
             goto err;
     }
 
-    /* Compare octet strings. */
     ret = len_a == (unsigned)ASN1_STRING_length(b-&gt;hashed_msg) &amp;&amp;
         memcmp(imprint_a, ASN1_STRING_data(b-&gt;hashed_msg), len_a) == 0;
  err:
@@ -660,7 +602,6 @@ static int ts_check_nonces(const ASN1_INTEGER *a, TS_TST_INFO *tst_info)
 {
     const ASN1_INTEGER *b = tst_info-&gt;nonce;
 
-    /* Error if nonce is missing. */
     if (!b) {
         TSerr(TS_F_TS_CHECK_NONCES, TS_R_NONCE_NOT_RETURNED);
         return 0;
@@ -685,12 +626,9 @@ static int ts_check_signer_name(GENERAL_NAME *tsa_name, X509 *signer)
     int idx = -1;
     int found = 0;
 
-    /* Check the subject name first. */
     if (tsa_name-&gt;type == GEN_DIRNAME
         &amp;&amp; X509_name_cmp(tsa_name-&gt;d.dirn, X509_get_subject_name(signer)) == 0)
         return 1;
-
-    /* Check all the alternative names. */
     gen_names = X509_get_ext_d2i(signer, NID_subject_alt_name, NULL, &amp;idx);
     while (gen_names != NULL) {
         found = ts_find_name(gen_names, tsa_name) &gt;= 0;
diff --git a/crypto/ts/ts_verify_ctx.c b/crypto/ts/ts_verify_ctx.c
index c370137..48deb2e 100644
--- a/crypto/ts/ts_verify_ctx.c
+++ b/crypto/ts/ts_verify_ctx.c
@@ -162,17 +162,14 @@ TS_VERIFY_CTX *TS_REQ_to_TS_VERIFY_CTX(TS_REQ *req, TS_VERIFY_CTX *ctx)
     else if ((ret = TS_VERIFY_CTX_new()) == NULL)
         return NULL;
 
-    /* Setting flags. */
     ret-&gt;flags = TS_VFY_ALL_IMPRINT &amp; ~(TS_VFY_TSA_NAME | TS_VFY_SIGNATURE);
 
-    /* Setting policy. */
     if ((policy = req-&gt;policy_id) != NULL) {
         if ((ret-&gt;policy = OBJ_dup(policy)) == NULL)
             goto err;
     } else
         ret-&gt;flags &amp;= ~TS_VFY_POLICY;
 
-    /* Setting md_alg, imprint and imprint_len. */
     imprint = req-&gt;msg_imprint;
     md_alg = imprint-&gt;hash_algo;
     if ((ret-&gt;md_alg = X509_ALGOR_dup(md_alg)) == NULL)
@@ -183,7 +180,6 @@ TS_VERIFY_CTX *TS_REQ_to_TS_VERIFY_CTX(TS_REQ *req, TS_VERIFY_CTX *ctx)
         goto err;
     memcpy(ret-&gt;imprint, ASN1_STRING_data(msg), ret-&gt;imprint_len);
 
-    /* Setting nonce. */
     if ((nonce = req-&gt;nonce) != NULL) {
         if ((ret-&gt;nonce = ASN1_INTEGER_dup(nonce)) == NULL)
             goto err;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001870.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="001874.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1873">[ date ]</a>
              <a href="thread.html#1873">[ thread ]</a>
              <a href="subject.html#1873">[ subject ]</a>
              <a href="author.html#1873">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
