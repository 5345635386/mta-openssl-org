<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-October/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1569962100.504748.23467.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025398.html">
   <LINK REL="Next"  HREF="025400.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1569962100.504748.23467.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Tue Oct  1 20:35:00 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="025398.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="025400.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25399">[ date ]</a>
              <a href="thread.html#25399">[ thread ]</a>
              <a href="subject.html#25399">[ subject ]</a>
              <a href="author.html#25399">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  bbecf04e7861b6ab9ca1bd5ee5100bd49a347b4a (commit)
      from  723e9c8983f92bc256a7e8677cc02f05b47e227c (commit)


- Log -----------------------------------------------------------------
commit bbecf04e7861b6ab9ca1bd5ee5100bd49a347b4a
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Sep 28 07:33:38 2019 +0200

    Make manuals with TYPE conform with man-pages(7)
    
    Details from man-pages(7) that are used:
    
        Formatting conventions for manual pages describing functions
    
            ...
            Variable names should, like argument names, be specified in italics.
            ...
    
        Formatting conventions (general)
    
            ...
            Special macros, which are usually in uppercase, are in bold.
            Exception: don't boldface NULL.
            ...
    
    Furthermore, for TYPE used as a placeholder for types and correponding
    part of function names, we extrapolate that it's both a type and a
    variable, and should therefore be bold (typical for types and function
    names) and italic (typical for variables).  POD processors don'e know
    this, so we have to help them along.  Therefore:
    
       SPARSE_ARRAY_OF(TYPE)        =&gt; B&lt;SPARSE_ARRAY_OF&gt;(B&lt;I&lt;TYPE&gt;&gt;)
       ossl_sa_TYPE_num()           =&gt; B&lt;ossl_sa_I&lt;TYPE&gt;_num&gt;()
       TYPE                         =&gt; B&lt;I&lt;TYPE&gt;&gt;
    
    There are some other less typical uses where one simply has to give
    formatting some extra though.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10041">https://github.com/openssl/openssl/pull/10041</A>)

-----------------------------------------------------------------------

Summary of changes:
 doc/internal/man3/DEFINE_SPARSE_ARRAY_OF.pod |   9 +-
 doc/internal/man3/ossl_param_bld_init.pod    |   2 +-
 doc/man3/DEFINE_STACK_OF.pod                 | 197 ++++++++++++++-------------
 doc/man3/OPENSSL_LH_COMPFUNC.pod             |  72 +++++-----
 doc/man3/PEM_read_CMS.pod                    |  25 ++--
 doc/man3/PEM_read_bio_PrivateKey.pod         |  66 ++++-----
 doc/man3/X509_dup.pod                        |  25 ++--
 doc/man3/d2i_X509.pod                        |  96 ++++++-------
 8 files changed, 251 insertions(+), 241 deletions(-)

diff --git a/doc/internal/man3/DEFINE_SPARSE_ARRAY_OF.pod b/doc/internal/man3/DEFINE_SPARSE_ARRAY_OF.pod
index 8617c97581..7917c4c812 100644
--- a/doc/internal/man3/DEFINE_SPARSE_ARRAY_OF.pod
+++ b/doc/internal/man3/DEFINE_SPARSE_ARRAY_OF.pod
@@ -42,10 +42,11 @@ the processor along
 =end comment
 
 SPARSE_ARRAY_OF() returns the name for a sparse array of the specified
-I&lt;TYPE&gt;.  DEFINE_STACK_OF() creates set of functions for a sparse array of
-I&lt;TYPE&gt;. This will mean that a pointer to type I&lt;TYPE&gt; is stored in each
-element of a sparse array, the type is referenced by B&lt;SPARSE_ARRAY_OF&gt;(I&lt;TYPE&gt;)
-and each function name begins with B&lt;ossl_sa_I&lt;TYPE&gt;_&gt;. For example:
+B&lt;I&lt;TYPE&gt;&gt;.  DEFINE_STACK_OF() creates set of functions for a sparse
+array of B&lt;I&lt;TYPE&gt;&gt;. This will mean that a pointer to type B&lt;I&lt;TYPE&gt;&gt;
+is stored in each element of a sparse array, the type is referenced by
+B&lt;SPARSE_ARRAY_OF&gt;(B&lt;I&lt;TYPE&gt;&gt;) and each function name begins with
+B&lt;ossl_sa_I&lt;TYPE&gt;_&gt;. For example:
 
  TYPE *ossl_sa_TYPE_get(SPARSE_ARRAY_OF(TYPE) *sa, ossl_uintmax_t idx);
 
diff --git a/doc/internal/man3/ossl_param_bld_init.pod b/doc/internal/man3/ossl_param_bld_init.pod
index fb439f24a6..5179a8d64a 100644
--- a/doc/internal/man3/ossl_param_bld_init.pod
+++ b/doc/internal/man3/ossl_param_bld_init.pod
@@ -48,7 +48,7 @@ ossl_param_bld_push_octet_ptr
 =head1 DESCRIPTION
 
 A collection of utility functions that simplify the creation of OSSL_PARAM
-arrays.  The B&lt;TYPE&gt; names are as per L&lt;OSSL_PARAM_int(3)&gt;.
+arrays.  The B&lt;I&lt;TYPE&gt;&gt; names are as per L&lt;OSSL_PARAM_int(3)&gt;.
 
 ossl_param_bld_init() initialises the OSSL_PARAM_BLD structure so that values
 can be added.
diff --git a/doc/man3/DEFINE_STACK_OF.pod b/doc/man3/DEFINE_STACK_OF.pod
index f658c760db..a3e9e73f55 100644
--- a/doc/man3/DEFINE_STACK_OF.pod
+++ b/doc/man3/DEFINE_STACK_OF.pod
@@ -61,13 +61,14 @@ sk_TYPE_dup, sk_TYPE_deep_copy, sk_TYPE_set_cmp_func, sk_TYPE_new_reserve
 Applications can create and use their own stacks by placing any of the macros
 described below in a header file. These macros define typesafe inline
 functions that wrap around the utility B&lt;OPENSSL_sk_&gt; API.
-In the description here, I&lt;TYPE&gt; is used
-as a placeholder for any of the OpenSSL datatypes, such as I&lt;X509&gt;.
+In the description here, B&lt;I&lt;TYPE&gt;&gt; is used
+as a placeholder for any of the OpenSSL datatypes, such as B&lt;X509&gt;.
 
-STACK_OF() returns the name for a stack of the specified B&lt;TYPE&gt;.
-DEFINE_STACK_OF() creates set of functions for a stack of B&lt;TYPE&gt;. This
-will mean that type B&lt;TYPE&gt; is stored in each stack, the type is referenced by
-STACK_OF(TYPE) and each function name begins with I&lt;sk_TYPE_&gt;. For example:
+STACK_OF() returns the name for a stack of the specified B&lt;I&lt;TYPE&gt;&gt;.
+DEFINE_STACK_OF() creates set of functions for a stack of B&lt;I&lt;TYPE&gt;&gt;. This
+will mean that type B&lt;I&lt;TYPE&gt;&gt; is stored in each stack, the type is referenced by
+B&lt;STACK_OF&gt;(B&lt;I&lt;TYPE&gt;&gt;) and each function name begins with B&lt;sk_I&lt;TYPE&gt;_&gt;.
+For example:
 
  TYPE *sk_TYPE_value(STACK_OF(TYPE) *sk, int idx);
 
@@ -76,7 +77,7 @@ each element is constant. For example:
 
  const TYPE *sk_TYPE_value(STACK_OF(TYPE) *sk, int idx);
 
-DEFINE_SPECIAL_STACK_OF() defines a stack of B&lt;TYPE&gt; but
+DEFINE_SPECIAL_STACK_OF() defines a stack of B&lt;I&lt;TYPE&gt;&gt; but
 each function uses B&lt;FUNCNAME&gt; in the function name. For example:
 
  TYPE *sk_FUNCNAME_value(STACK_OF(TYPE) *sk, int idx);
@@ -86,117 +87,119 @@ constant:
 
  const TYPE *sk_FUNCNAME_value(STACK_OF(TYPE) *sk, int idx);
 
-sk_TYPE_num() returns the number of elements in B&lt;sk&gt; or -1 if B&lt;sk&gt; is
-B&lt;NULL&gt;.
+B&lt;sk_I&lt;TYPE&gt;_num&gt;() returns the number of elements in I&lt;sk&gt; or -1 if I&lt;sk&gt; is
+NULL.
 
-sk_TYPE_value() returns element B&lt;idx&gt; in B&lt;sk&gt;, where B&lt;idx&gt; starts at
-zero. If B&lt;idx&gt; is out of range then B&lt;NULL&gt; is returned.
+B&lt;sk_I&lt;TYPE&gt;_value&gt;() returns element I&lt;idx&gt; in I&lt;sk&gt;, where I&lt;idx&gt; starts at
+zero. If I&lt;idx&gt; is out of range then NULL is returned.
 
-sk_TYPE_new() allocates a new empty stack using comparison function B&lt;compare&gt;.
-If B&lt;compare&gt; is B&lt;NULL&gt; then no comparison function is used. This function is
-equivalent to sk_TYPE_new_reserve(compare, 0).
+B&lt;sk_I&lt;TYPE&gt;_new&gt;() allocates a new empty stack using comparison function
+I&lt;compare&gt;. If I&lt;compare&gt; is NULL then no comparison function is used. This
+function is equivalent to B&lt;sk_I&lt;TYPE&gt;_new_reserve&gt;(I&lt;compare&gt;, 0).
 
-sk_TYPE_new_null() allocates a new empty stack with no comparison function. This
-function is equivalent to sk_TYPE_new_reserve(NULL, 0).
+B&lt;sk_I&lt;TYPE&gt;_new_null&gt;() allocates a new empty stack with no comparison
+function. This function is equivalent to B&lt;sk_I&lt;TYPE&gt;_new_reserve&gt;(NULL, 0).
 
-sk_TYPE_reserve() allocates additional memory in the B&lt;sk&gt; structure
-such that the next B&lt;n&gt; calls to sk_TYPE_insert(), sk_TYPE_push()
-or sk_TYPE_unshift() will not fail or cause memory to be allocated
-or reallocated. If B&lt;n&gt; is zero, any excess space allocated in the
-B&lt;sk&gt; structure is freed. On error B&lt;sk&gt; is unchanged.
+B&lt;sk_I&lt;TYPE&gt;_reserve&gt;() allocates additional memory in the I&lt;sk&gt; structure
+such that the next I&lt;n&gt; calls to B&lt;sk_I&lt;TYPE&gt;_insert&gt;(), B&lt;sk_I&lt;TYPE&gt;_push&gt;()
+or B&lt;sk_I&lt;TYPE&gt;_unshift&gt;() will not fail or cause memory to be allocated
+or reallocated. If I&lt;n&gt; is zero, any excess space allocated in the
+I&lt;sk&gt; structure is freed. On error I&lt;sk&gt; is unchanged.
 
-sk_TYPE_new_reserve() allocates a new stack. The new stack will have additional
-memory allocated to hold B&lt;n&gt; elements if B&lt;n&gt; is positive. The next B&lt;n&gt; calls
-to sk_TYPE_insert(), sk_TYPE_push() or sk_TYPE_unshift() will not fail or cause
-memory to be allocated or reallocated. If B&lt;n&gt; is zero or less than zero, no
-memory is allocated. sk_TYPE_new_reserve() also sets the comparison function
-B&lt;compare&gt; to the newly created stack. If B&lt;compare&gt; is B&lt;NULL&gt; then no
-comparison function is used.
+B&lt;sk_I&lt;TYPE&gt;_new_reserve&gt;() allocates a new stack. The new stack will have
+additional memory allocated to hold I&lt;n&gt; elements if I&lt;n&gt; is positive.
+The next I&lt;n&gt; calls to B&lt;sk_I&lt;TYPE&gt;_insert&gt;(), B&lt;sk_I&lt;TYPE&gt;_push&gt;() or
+B&lt;sk_I&lt;TYPE&gt;_unshift&gt;() will not fail or cause memory to be allocated or
+reallocated. If I&lt;n&gt; is zero or less than zero, no memory is allocated.
+B&lt;sk_I&lt;TYPE&gt;_new_reserve&gt;() also sets the comparison function I&lt;compare&gt;
+to the newly created stack. If I&lt;compare&gt; is NULL then no comparison
+function is used.
 
-sk_TYPE_set_cmp_func() sets the comparison function of B&lt;sk&gt; to B&lt;compare&gt;.
-The previous comparison function is returned or B&lt;NULL&gt; if there was
-no previous comparison function.
+B&lt;sk_I&lt;TYPE&gt;_set_cmp_func&gt;() sets the comparison function of I&lt;sk&gt; to
+I&lt;compare&gt;. The previous comparison function is returned or NULL if there
+was no previous comparison function.
 
-sk_TYPE_free() frees up the B&lt;sk&gt; structure. It does B&lt;not&gt; free up any
-elements of B&lt;sk&gt;. After this call B&lt;sk&gt; is no longer valid.
+B&lt;sk_I&lt;TYPE&gt;_free&gt;() frees up the I&lt;sk&gt; structure. It does I&lt;not&gt; free up any
+elements of I&lt;sk&gt;. After this call I&lt;sk&gt; is no longer valid.
 
-sk_TYPE_zero() sets the number of elements in B&lt;sk&gt; to zero. It does not free
-B&lt;sk&gt; so after this call B&lt;sk&gt; is still valid.
+B&lt;sk_I&lt;TYPE&gt;_zero&gt;() sets the number of elements in I&lt;sk&gt; to zero. It does not
+free I&lt;sk&gt; so after this call I&lt;sk&gt; is still valid.
 
-sk_TYPE_pop_free() frees up all elements of B&lt;sk&gt; and B&lt;sk&gt; itself. The
+B&lt;sk_I&lt;TYPE&gt;_pop_free&gt;() frees up all elements of I&lt;sk&gt; and I&lt;sk&gt; itself. The
 free function freefunc() is called on each element to free it.
 
-sk_TYPE_delete() deletes element B&lt;i&gt; from B&lt;sk&gt;. It returns the deleted
-element or B&lt;NULL&gt; if B&lt;i&gt; is out of range.
+B&lt;sk_I&lt;TYPE&gt;_delete&gt;() deletes element I&lt;i&gt; from I&lt;sk&gt;. It returns the deleted
+element or NULL if I&lt;i&gt; is out of range.
 
-sk_TYPE_delete_ptr() deletes element matching B&lt;ptr&gt; from B&lt;sk&gt;. It returns
-the deleted element or B&lt;NULL&gt; if no element matching B&lt;ptr&gt; was found.
+B&lt;sk_I&lt;TYPE&gt;_delete_ptr&gt;() deletes element matching I&lt;ptr&gt; from I&lt;sk&gt;. It
+returns the deleted element or NULL if no element matching I&lt;ptr&gt; was found.
 
-sk_TYPE_insert() inserts B&lt;ptr&gt; into B&lt;sk&gt; at position B&lt;idx&gt;. Any existing
-elements at or after B&lt;idx&gt; are moved downwards. If B&lt;idx&gt; is out of range
-the new element is appended to B&lt;sk&gt;. sk_TYPE_insert() either returns the
-number of elements in B&lt;sk&gt; after the new element is inserted or zero if
-an error (such as memory allocation failure) occurred.
+B&lt;sk_I&lt;TYPE&gt;_insert&gt;() inserts I&lt;ptr&gt; into I&lt;sk&gt; at position I&lt;idx&gt;. Any
+existing elements at or after I&lt;idx&gt; are moved downwards. If I&lt;idx&gt; is out
+of range the new element is appended to I&lt;sk&gt;. B&lt;sk_I&lt;TYPE&gt;_insert&gt;() either
+returns the number of elements in I&lt;sk&gt; after the new element is inserted or
+zero if an error (such as memory allocation failure) occurred.
 
-sk_TYPE_push() appends B&lt;ptr&gt; to B&lt;sk&gt; it is equivalent to:
+B&lt;sk_I&lt;TYPE&gt;_push&gt;() appends I&lt;ptr&gt; to I&lt;sk&gt; it is equivalent to:
 
  sk_TYPE_insert(sk, ptr, -1);
 
-sk_TYPE_unshift() inserts B&lt;ptr&gt; at the start of B&lt;sk&gt; it is equivalent to:
+B&lt;sk_I&lt;TYPE&gt;_unshift&gt;() inserts I&lt;ptr&gt; at the start of I&lt;sk&gt; it is equivalent
+to:
 
  sk_TYPE_insert(sk, ptr, 0);
 
-sk_TYPE_pop() returns and removes the last element from B&lt;sk&gt;.
+B&lt;sk_I&lt;TYPE&gt;_pop&gt;() returns and removes the last element from I&lt;sk&gt;.
 
-sk_TYPE_shift() returns and removes the first element from B&lt;sk&gt;.
+B&lt;sk_I&lt;TYPE&gt;_shift&gt;() returns and removes the first element from I&lt;sk&gt;.
 
-sk_TYPE_set() sets element B&lt;idx&gt; of B&lt;sk&gt; to B&lt;ptr&gt; replacing the current
-element. The new element value is returned or B&lt;NULL&gt; if an error occurred:
-this will only happen if B&lt;sk&gt; is B&lt;NULL&gt; or B&lt;idx&gt; is out of range.
+B&lt;sk_I&lt;TYPE&gt;_set&gt;() sets element I&lt;idx&gt; of I&lt;sk&gt; to I&lt;ptr&gt; replacing the current
+element. The new element value is returned or NULL if an error occurred:
+this will only happen if I&lt;sk&gt; is NULL or I&lt;idx&gt; is out of range.
 
-sk_TYPE_find() searches B&lt;sk&gt; for the element B&lt;ptr&gt;.  In the case
+B&lt;sk_I&lt;TYPE&gt;_find&gt;() searches I&lt;sk&gt; for the element I&lt;ptr&gt;.  In the case
 where no comparison function has been specified, the function performs
-a linear search for a pointer equal to B&lt;ptr&gt;. The index of the first
+a linear search for a pointer equal to I&lt;ptr&gt;. The index of the first
 matching element is returned or B&lt;-1&gt; if there is no match. In the case
-where a comparison function has been specified, B&lt;sk&gt; is sorted then
-sk_TYPE_find() returns the index of a matching element or B&lt;-1&gt; if there
+where a comparison function has been specified, I&lt;sk&gt; is sorted then
+B&lt;sk_I&lt;TYPE&gt;_find&gt;() returns the index of a matching element or B&lt;-1&gt; if there
 is no match. Note that, in this case, the matching element returned is
 not guaranteed to be the first; the comparison function will usually
 compare the values pointed to rather than the pointers themselves and
-the order of elements in B&lt;sk&gt; could change.
+the order of elements in I&lt;sk&gt; could change.
 
-sk_TYPE_find_ex() operates like sk_TYPE_find() except when a comparison
-function has been specified and no matching element is found. Instead
-of returning B&lt;-1&gt;, sk_TYPE_find_ex() returns the index of the element
-either before or after the location where B&lt;ptr&gt; would be if it were
-present in B&lt;sk&gt;.
+B&lt;sk_I&lt;TYPE&gt;_find_ex&gt;() operates like B&lt;sk_I&lt;TYPE&gt;_find&gt;() except when a
+comparison function has been specified and no matching element is found.
+Instead of returning B&lt;-1&gt;, B&lt;sk_I&lt;TYPE&gt;_find_ex&gt;() returns the index of the
+element either before or after the location where I&lt;ptr&gt; would be if it were
+present in I&lt;sk&gt;.
 
-sk_TYPE_sort() sorts B&lt;sk&gt; using the supplied comparison function.
+B&lt;sk_I&lt;TYPE&gt;_sort&gt;() sorts I&lt;sk&gt; using the supplied comparison function.
 
-sk_TYPE_is_sorted() returns B&lt;1&gt; if B&lt;sk&gt; is sorted and B&lt;0&gt; otherwise.
+B&lt;sk_I&lt;TYPE&gt;_is_sorted&gt;() returns B&lt;1&gt; if I&lt;sk&gt; is sorted and B&lt;0&gt; otherwise.
 
-sk_TYPE_dup() returns a copy of B&lt;sk&gt;. Note the pointers in the copy
+B&lt;sk_I&lt;TYPE&gt;_dup&gt;() returns a copy of I&lt;sk&gt;. Note the pointers in the copy
 are identical to the original.
 
-sk_TYPE_deep_copy() returns a new stack where each element has been copied.
-Copying is performed by the supplied copyfunc() and freeing by freefunc(). The
-function freefunc() is only called if an error occurs.
+B&lt;sk_I&lt;TYPE&gt;_deep_copy&gt;() returns a new stack where each element has been
+copied. Copying is performed by the supplied copyfunc() and freeing by
+freefunc(). The function freefunc() is only called if an error occurs.
 
 =head1 NOTES
 
 Care should be taken when accessing stacks in multi-threaded environments.
-Any operation which increases the size of a stack such as sk_TYPE_insert() or
-sk_push() can &quot;grow&quot; the size of an internal array and cause race conditions
-if the same stack is accessed in a different thread. Operations such as
-sk_find() and sk_sort() can also reorder the stack.
+Any operation which increases the size of a stack such as B&lt;sk_I&lt;TYPE&gt;_insert&gt;()
+or B&lt;sk_I&lt;TYPE&gt;_push&gt;() can &quot;grow&quot; the size of an internal array and cause race
+conditions if the same stack is accessed in a different thread. Operations such
+as B&lt;sk_I&lt;TYPE&gt;_find&gt;() and B&lt;sk_I&lt;TYPE&gt;_sort&gt;() can also reorder the stack.
 
 Any comparison function supplied should use a metric suitable
 for use in a binary search operation. That is it should return zero, a
-positive or negative value if B&lt;a&gt; is equal to, greater than
-or less than B&lt;b&gt; respectively.
+positive or negative value if I&lt;a&gt; is equal to, greater than
+or less than I&lt;b&gt; respectively.
 
 Care should be taken when checking the return values of the functions
-sk_TYPE_find() and sk_TYPE_find_ex(). They return an index to the
+B&lt;sk_I&lt;TYPE&gt;_find&gt;() and B&lt;sk_I&lt;TYPE&gt;_find_ex&gt;(). They return an index to the
 matching element. In particular B&lt;0&gt; indicates a matching first element.
 A failed search is indicated by a B&lt;-1&gt; return value.
 
@@ -216,48 +219,50 @@ OPENSSL_sk_zero().
 
 =head1 RETURN VALUES
 
-sk_TYPE_num() returns the number of elements in the stack or B&lt;-1&gt; if the
-passed stack is B&lt;NULL&gt;.
+B&lt;sk_I&lt;TYPE&gt;_num&gt;() returns the number of elements in the stack or B&lt;-1&gt; if the
+passed stack is NULL.
 
-sk_TYPE_value() returns a pointer to a stack element or B&lt;NULL&gt; if the
+B&lt;sk_I&lt;TYPE&gt;_value&gt;() returns a pointer to a stack element or NULL if the
 index is out of range.
 
-sk_TYPE_new(), sk_TYPE_new_null() and sk_TYPE_new_reserve() return an empty
-stack or B&lt;NULL&gt; if an error occurs.
+B&lt;sk_I&lt;TYPE&gt;_new&gt;(), B&lt;sk_I&lt;TYPE&gt;_new_null&gt;() and B&lt;sk_I&lt;TYPE&gt;_new_reserve&gt;()
+return an empty stack or NULL if an error occurs.
 
-sk_TYPE_reserve() returns B&lt;1&gt; on successful allocation of the required memory
-or B&lt;0&gt; on error.
+B&lt;sk_I&lt;TYPE&gt;_reserve&gt;() returns B&lt;1&gt; on successful allocation of the required
+memory or B&lt;0&gt; on error.
 
-sk_TYPE_set_cmp_func() returns the old comparison function or B&lt;NULL&gt; if
+B&lt;sk_I&lt;TYPE&gt;_set_cmp_func&gt;() returns the old comparison function or NULL if
 there was no old comparison function.
 
-sk_TYPE_free(), sk_TYPE_zero(), sk_TYPE_pop_free() and sk_TYPE_sort() do
-not return values.
+B&lt;sk_I&lt;TYPE&gt;_free&gt;(), B&lt;sk_I&lt;TYPE&gt;_zero&gt;(), B&lt;sk_I&lt;TYPE&gt;_pop_free&gt;() and
+B&lt;sk_I&lt;TYPE&gt;_sort&gt;() do not return values.
 
-sk_TYPE_pop(), sk_TYPE_shift(), sk_TYPE_delete() and sk_TYPE_delete_ptr()
-return a pointer to the deleted element or B&lt;NULL&gt; on error.
+B&lt;sk_I&lt;TYPE&gt;_pop&gt;(), B&lt;sk_I&lt;TYPE&gt;_shift&gt;(), B&lt;sk_I&lt;TYPE&gt;_delete&gt;() and
+B&lt;sk_I&lt;TYPE&gt;_delete_ptr&gt;() return a pointer to the deleted element or NULL
+on error.
 
-sk_TYPE_insert(), sk_TYPE_push() and sk_TYPE_unshift() return the total
-number of elements in the stack and 0 if an error occurred.
+B&lt;sk_I&lt;TYPE&gt;_insert&gt;(), B&lt;sk_I&lt;TYPE&gt;_push&gt;() and B&lt;sk_I&lt;TYPE&gt;_unshift&gt;() return
+the total number of elements in the stack and 0 if an error occurred.
 
-sk_TYPE_set() returns a pointer to the replacement element or B&lt;NULL&gt; on
+B&lt;sk_I&lt;TYPE&gt;_set&gt;() returns a pointer to the replacement element or NULL on
 error.
 
-sk_TYPE_find() and sk_TYPE_find_ex() return an index to the found element
-or B&lt;-1&gt; on error.
+B&lt;sk_I&lt;TYPE&gt;_find&gt;() and B&lt;sk_I&lt;TYPE&gt;_find_ex&gt;() return an index to the found
+element or B&lt;-1&gt; on error.
 
-sk_TYPE_is_sorted() returns B&lt;1&gt; if the stack is sorted and B&lt;0&gt; if it is
+B&lt;sk_I&lt;TYPE&gt;_is_sorted&gt;() returns B&lt;1&gt; if the stack is sorted and B&lt;0&gt; if it is
 not.
 
-sk_TYPE_dup() and sk_TYPE_deep_copy() return a pointer to the copy of the
-stack.
+B&lt;sk_I&lt;TYPE&gt;_dup&gt;() and B&lt;sk_I&lt;TYPE&gt;_deep_copy&gt;() return a pointer to the copy
+of the stack.
 
 =head1 HISTORY
 
 Before OpenSSL 1.1.0, this was implemented via macros and not inline functions
 and was not a public API.
 
-sk_TYPE_reserve() and sk_TYPE_new_reserve() were added in OpenSSL 1.1.1.
+B&lt;sk_I&lt;TYPE&gt;_reserve&gt;() and B&lt;sk_I&lt;TYPE&gt;_new_reserve&gt;() were added in OpenSSL
+1.1.1.
 
 =head1 COPYRIGHT
 
diff --git a/doc/man3/OPENSSL_LH_COMPFUNC.pod b/doc/man3/OPENSSL_LH_COMPFUNC.pod
index 9a927f885a..bc1fab229c 100644
--- a/doc/man3/OPENSSL_LH_COMPFUNC.pod
+++ b/doc/man3/OPENSSL_LH_COMPFUNC.pod
@@ -41,25 +41,25 @@ lh_TYPE_doall, lh_TYPE_doall_arg, lh_TYPE_error - dynamic hash table
 
 This library implements type-checked dynamic hash tables. The hash
 table entries can be arbitrary structures. Usually they consist of key
-and value fields.  In the description here, I&lt;TYPE&gt; is used a placeholder
+and value fields.  In the description here, B&lt;I&lt;TYPE&gt;&gt; is used a placeholder
 for any of the OpenSSL datatypes, such as I&lt;SSL_SESSION&gt;.
 
-lh_TYPE_new() creates a new B&lt;LHASH_OF(TYPE)&gt; structure to store
+B&lt;lh_I&lt;TYPE&gt;_new&gt;() creates a new B&lt;LHASH_OF&gt;(B&lt;I&lt;TYPE&gt;&gt;) structure to store
 arbitrary data entries, and specifies the 'hash' and 'compare'
-callbacks to be used in organising the table's entries.  The B&lt;hash&gt;
+callbacks to be used in organising the table's entries.  The I&lt;hash&gt;
 callback takes a pointer to a table entry as its argument and returns
 an unsigned long hash value for its key field.  The hash value is
 normally truncated to a power of 2, so make sure that your hash
-function returns well mixed low order bits.  The B&lt;compare&gt; callback
+function returns well mixed low order bits.  The I&lt;compare&gt; callback
 takes two arguments (pointers to two hash table entries), and returns
 0 if their keys are equal, non-zero otherwise.
 
 If your hash table
-will contain items of some particular type and the B&lt;hash&gt; and
-B&lt;compare&gt; callbacks hash/compare these types, then the
+will contain items of some particular type and the I&lt;hash&gt; and
+I&lt;compare&gt; callbacks hash/compare these types, then the
 B&lt;IMPLEMENT_LHASH_HASH_FN&gt; and B&lt;IMPLEMENT_LHASH_COMP_FN&gt; macros can be
 used to create callback wrappers of the prototypes required by
-lh_TYPE_new() as shown in this example:
+B&lt;lh_I&lt;TYPE&gt;_new&gt;() as shown in this example:
 
  /*
   * Implement the hash and compare functions; &quot;stuff&quot; can be any word.
@@ -85,35 +85,35 @@ can be used in a common header file to declare the function wrappers:
  DECLARE_LHASH_HASH_FN(stuff, TYPE)
  DECLARE_LHASH_COMP_FN(stuff, TYPE)
 
-Then a hash table of TYPE objects can be created using this:
+Then a hash table of B&lt;I&lt;TYPE&gt;&gt; objects can be created using this:
 
  LHASH_OF(TYPE) *htable;
 
- htable = lh_TYPE_new(LHASH_HASH_FN(stuff), LHASH_COMP_FN(stuff));
+ htable = B&lt;lh_I&lt;TYPE&gt;_new&gt;(LHASH_HASH_FN(stuff), LHASH_COMP_FN(stuff));
 
-lh_TYPE_free() frees the B&lt;LHASH_OF(TYPE)&gt; structure
-B&lt;table&gt;. Allocated hash table entries will not be freed; consider
-using lh_TYPE_doall() to deallocate any remaining entries in the
+B&lt;lh_I&lt;TYPE&gt;_free&gt;() frees the B&lt;LHASH_OF&gt;(B&lt;I&lt;TYPE&gt;&gt;) structure
+I&lt;table&gt;. Allocated hash table entries will not be freed; consider
+using B&lt;lh_I&lt;TYPE&gt;_doall&gt;() to deallocate any remaining entries in the
 hash table (see below).
 
-lh_TYPE_flush() empties the B&lt;LHASH_OF(TYPE)&gt; structure B&lt;table&gt;. New
+B&lt;lh_I&lt;TYPE&gt;_flush&gt;() empties the B&lt;LHASH_OF&gt;(B&lt;I&lt;TYPE&gt;&gt;) structure I&lt;table&gt;. New
 entries can be added to the flushed table.  Allocated hash table entries
-will not be freed; consider using lh_TYPE_doall() to deallocate any
+will not be freed; consider using B&lt;lh_I&lt;TYPE&gt;_doall&gt;() to deallocate any
 remaining entries in the hash table (see below).
 
-lh_TYPE_insert() inserts the structure pointed to by B&lt;data&gt; into
-B&lt;table&gt;.  If there already is an entry with the same key, the old
-value is replaced. Note that lh_TYPE_insert() stores pointers, the
+B&lt;lh_I&lt;TYPE&gt;_insert&gt;() inserts the structure pointed to by I&lt;data&gt; into
+I&lt;table&gt;.  If there already is an entry with the same key, the old
+value is replaced. Note that B&lt;lh_I&lt;TYPE&gt;_insert&gt;() stores pointers, the
 data are not copied.
 
-lh_TYPE_delete() deletes an entry from B&lt;table&gt;.
+B&lt;lh_I&lt;TYPE&gt;_delete&gt;() deletes an entry from I&lt;table&gt;.
 
-lh_TYPE_retrieve() looks up an entry in B&lt;table&gt;. Normally, B&lt;data&gt;
+B&lt;lh_I&lt;TYPE&gt;_retrieve&gt;() looks up an entry in I&lt;table&gt;. Normally, I&lt;data&gt;
 is a structure with the key field(s) set; the function will return a
 pointer to a fully populated structure.
 
-lh_TYPE_doall() will, for every entry in the hash table, call
-B&lt;func&gt; with the data item as its parameter.
+B&lt;lh_I&lt;TYPE&gt;_doall&gt;() will, for every entry in the hash table, call
+I&lt;func&gt; with the data item as its parameter.
 For example:
 
  /* Cleans up resources belonging to 'a' (this is implemented elsewhere) */
@@ -137,9 +137,9 @@ you start (which will stop the hash table ever decreasing in size).
 The best solution is probably to avoid deleting items from the hash
 table inside a &quot;doall&quot; callback!
 
-lh_TYPE_doall_arg() is the same as lh_TYPE_doall() except that
-B&lt;func&gt; will be called with B&lt;arg&gt; as the second argument and B&lt;func&gt;
-should be of type B&lt;LHASH_DOALL_ARG_FN_TYPE&gt; (a callback prototype
+B&lt;lh_I&lt;TYPE&gt;_doall_arg&gt;() is the same as B&lt;lh_I&lt;TYPE&gt;_doall&gt;() except that
+I&lt;func&gt; will be called with I&lt;arg&gt; as the second argument and I&lt;func&gt;
+should be of type B&lt;LHASH_DOALL_ARG_FN&gt;(B&lt;I&lt;TYPE&gt;&gt;) (a callback prototype
 that is passed both the table entry and an extra argument).  As with
 lh_doall(), you can instead choose to declare your callback with a
 prototype matching the types you are dealing with and use the
@@ -159,33 +159,33 @@ that is provided by the caller):
                    logging_bio);
 
 
-lh_TYPE_error() can be used to determine if an error occurred in the last
+B&lt;lh_I&lt;TYPE&gt;_error&gt;() can be used to determine if an error occurred in the last
 operation.
 
 =head1 RETURN VALUES
 
-lh_TYPE_new() returns B&lt;NULL&gt; on error, otherwise a pointer to the new
+B&lt;lh_I&lt;TYPE&gt;_new&gt;() returns NULL on error, otherwise a pointer to the new
 B&lt;LHASH&gt; structure.
 
-When a hash table entry is replaced, lh_TYPE_insert() returns the value
-being replaced. B&lt;NULL&gt; is returned on normal operation and on error.
+When a hash table entry is replaced, B&lt;lh_I&lt;TYPE&gt;_insert&gt;() returns the value
+being replaced. NULL is returned on normal operation and on error.
 
-lh_TYPE_delete() returns the entry being deleted.  B&lt;NULL&gt; is returned if
+B&lt;lh_I&lt;TYPE&gt;_delete&gt;() returns the entry being deleted.  NULL is returned if
 there is no such value in the hash table.
 
-lh_TYPE_retrieve() returns the hash table entry if it has been found,
-B&lt;NULL&gt; otherwise.
+B&lt;lh_I&lt;TYPE&gt;_retrieve&gt;() returns the hash table entry if it has been found,
+NULL otherwise.
 
-lh_TYPE_error() returns 1 if an error occurred in the last operation, 0
+B&lt;lh_I&lt;TYPE&gt;_error&gt;() returns 1 if an error occurred in the last operation, 0
 otherwise. It's meaningful only after non-retrieve operations.
 
-lh_TYPE_free(), lh_TYPE_flush, lh_TYPE_doall() and lh_TYPE_doall_arg()
-return no values.
+B&lt;lh_I&lt;TYPE&gt;_free&gt;(), B&lt;lh_I&lt;TYPE&gt;_flush&gt;(), B&lt;lh_I&lt;TYPE&gt;_doall&gt;() and
+B&lt;lh_I&lt;TYPE&gt;_doall_arg&gt;() return no values.
 
 =head1 NOTE
 
 The LHASH code is not thread safe. All updating operations, as well as
-lh_TYPE_error call must be performed under a write lock. All retrieve
+B&lt;lh_I&lt;TYPE&gt;_error&gt;() call must be performed under a write lock. All retrieve
 operations should be performed under a read lock, I&lt;unless&gt; accurate
 usage statistics are desired. In which case, a write lock should be used
 for retrieve operations as well. For output of the usage statistics,
@@ -223,7 +223,7 @@ without any &quot;const&quot; qualifiers.
 
 =head1 BUGS
 
-lh_TYPE_insert() returns B&lt;NULL&gt; both for success and error.
+B&lt;lh_I&lt;TYPE&gt;_insert&gt;() returns NULL both for success and error.
 
 =head1 SEE ALSO
 
diff --git a/doc/man3/PEM_read_CMS.pod b/doc/man3/PEM_read_CMS.pod
index 99d31fe521..a18856c81b 100644
--- a/doc/man3/PEM_read_CMS.pod
+++ b/doc/man3/PEM_read_CMS.pod
@@ -53,8 +53,8 @@ PEM_write_bio_SSL_SESSION
 
 =head1 DESCRIPTION
 
-In the description below, I&lt;TYPE&gt; is used
-as a placeholder for any of the OpenSSL datatypes, such as I&lt;X509&gt;.
+In the description below, B&lt;I&lt;TYPE&gt;&gt; is used
+as a placeholder for any of the OpenSSL datatypes, such as B&lt;X509&gt;.
 The macro B&lt;DECLARE_PEM_rw&gt; expands to the set of declarations shown in
 the next four lines of the synopsis.
 
@@ -63,15 +63,17 @@ the PEM encoding.  For more information on the templates, see
 L&lt;ASN1_ITEM(3)&gt;.  For more information on the lower-level routines used
 by the functions here, see L&lt;PEM_read(3)&gt;.
 
-PEM_read_TYPE() reads a PEM-encoded object of I&lt;TYPE&gt; from the file B&lt;fp&gt;
-and returns it.  The B&lt;cb&gt; and B&lt;u&gt; parameters are as described in
+B&lt;PEM_read_I&lt;TYPE&gt;&gt;() reads a PEM-encoded object of B&lt;I&lt;TYPE&gt;&gt; from the file
+I&lt;fp&gt; and returns it.  The I&lt;cb&gt; and I&lt;u&gt; parameters are as described in
 L&lt;pem_password_cb(3)&gt;.
 
-PEM_read_bio_TYPE() is similar to PEM_read_TYPE() but reads from the BIO B&lt;bp&gt;.
+B&lt;PEM_read_bio_I&lt;TYPE&gt;&gt;() is similar to B&lt;PEM_read_I&lt;TYPE&gt;&gt;() but reads from
+the BIO I&lt;bp&gt;.
 
-PEM_write_TYPE() writes the PEM encoding of the object B&lt;a&gt; to the file B&lt;fp&gt;.
+B&lt;PEM_write_I&lt;TYPE&gt;&gt;() writes the PEM encoding of the object I&lt;a&gt; to the file
+I&lt;fp&gt;.
 
-PEM_write_bio_TYPE() similarly writes to the BIO B&lt;bp&gt;.
+B&lt;PEM_write_bio_I&lt;TYPE&gt;&gt;() similarly writes to the BIO I&lt;bp&gt;.
 
 =head1 NOTES
 
@@ -81,11 +83,12 @@ It will simply be treated as a byte sequence.
 
 =head1 RETURN VALUES
 
-PEM_read_TYPE() and PEM_read_bio_TYPE() return a pointer to an allocated
-object, which should be released by calling TYPE_free(), or NULL on error.
+B&lt;PEM_read_I&lt;TYPE&gt;&gt;() and B&lt;PEM_read_bio_I&lt;TYPE&gt;&gt;() return a pointer to an
+allocated object, which should be released by calling B&lt;I&lt;TYPE&gt;_free&gt;(), or
+NULL on error.
 
-PEM_write_TYPE() and PEM_write_bio_TYPE() return the number of bytes written
-or zero on error.
+B&lt;PEM_write_I&lt;TYPE&gt;&gt;() and B&lt;PEM_write_bio_I&lt;TYPE&gt;&gt;() return the number of bytes
+written or zero on error.
 
 =head1 SEE ALSO
 
diff --git a/doc/man3/PEM_read_bio_PrivateKey.pod b/doc/man3/PEM_read_bio_PrivateKey.pod
index 69ff679b2d..78b6c4f7e4 100644
--- a/doc/man3/PEM_read_bio_PrivateKey.pod
+++ b/doc/man3/PEM_read_bio_PrivateKey.pod
@@ -160,9 +160,9 @@ For more details about the meaning of arguments see the
 B&lt;PEM FUNCTION ARGUMENTS&gt; section.
 
 Each operation has four functions associated with it. For
-brevity the term &quot;B&lt;TYPE&gt; functions&quot; will be used below to collectively
-refer to the PEM_read_bio_TYPE(), PEM_read_TYPE(),
-PEM_write_bio_TYPE(), and PEM_write_TYPE() functions.
+brevity the term &quot;B&lt;I&lt;TYPE&gt;&gt; functions&quot; will be used below to collectively
+refer to the B&lt;PEM_read_bio_I&lt;TYPE&gt;&gt;(), B&lt;PEM_read_I&lt;TYPE&gt;&gt;(),
+B&lt;PEM_write_bio_I&lt;TYPE&gt;&gt;(), and B&lt;PEM_write_I&lt;TYPE&gt;&gt;() functions.
 
 The B&lt;PrivateKey&gt; functions read or write a private key in PEM format using an
 EVP_PKEY structure. The write routines use PKCS#8 private key format and are
@@ -175,16 +175,16 @@ be used for compatibility with legacy programs.
 
 PEM_write_bio_PKCS8PrivateKey() and PEM_write_PKCS8PrivateKey() write a private
 key in an EVP_PKEY structure in PKCS#8 EncryptedPrivateKeyInfo format using
-PKCS#5 v2.0 password based encryption algorithms. The B&lt;cipher&gt; argument
+PKCS#5 v2.0 password based encryption algorithms. The I&lt;cipher&gt; argument
 specifies the encryption algorithm to use: unlike some other PEM routines the
 encryption is applied at the PKCS#8 level and not in the PEM headers. If
-B&lt;cipher&gt; is NULL then no encryption is used and a PKCS#8 PrivateKeyInfo
+I&lt;cipher&gt; is NULL then no encryption is used and a PKCS#8 PrivateKeyInfo
 structure is used instead.
 
 PEM_write_bio_PKCS8PrivateKey_nid() and PEM_write_PKCS8PrivateKey_nid()
 also write out a private key as a PKCS#8 EncryptedPrivateKeyInfo however
 it uses PKCS#5 v1.5 or PKCS#12 encryption algorithms instead. The algorithm
-to use is specified in the B&lt;nid&gt; parameter and should be the NID of the
+to use is specified in the I&lt;nid&gt; parameter and should be the NID of the
 corresponding OBJECT IDENTIFIER (see NOTES section).
 
 The B&lt;PUBKEY&gt; functions process a public key using an EVP_PKEY
@@ -247,36 +247,36 @@ structure.
 
 The PEM functions have many common arguments.
 
-The B&lt;bp&gt; BIO parameter (if present) specifies the BIO to read from
+The I&lt;bp&gt; BIO parameter (if present) specifies the BIO to read from
 or write to.
 
-The B&lt;fp&gt; FILE parameter (if present) specifies the FILE pointer to
+The I&lt;fp&gt; FILE parameter (if present) specifies the FILE pointer to
 read from or write to.
 
-The PEM read functions all take an argument B&lt;TYPE **x&gt; and return
-a B&lt;TYPE *&gt; pointer. Where B&lt;TYPE&gt; is whatever structure the function
-uses. If B&lt;x&gt; is NULL then the parameter is ignored. If B&lt;x&gt; is not
-NULL but B&lt;*x&gt; is NULL then the structure returned will be written
-to B&lt;*x&gt;. If neither B&lt;x&gt; nor B&lt;*x&gt; is NULL then an attempt is made
-to reuse the structure at B&lt;*x&gt; (but see BUGS and EXAMPLES sections).
-Irrespective of the value of B&lt;x&gt; a pointer to the structure is always
+The PEM read functions all take an argument I&lt;B&lt;TYPE&gt; **x&gt; and return
+a I&lt;B&lt;TYPE&gt; *&gt; pointer. Where I&lt;B&lt;TYPE&gt;&gt; is whatever structure the function
+uses. If I&lt;x&gt; is NULL then the parameter is ignored. If I&lt;x&gt; is not
+NULL but I&lt;*x&gt; is NULL then the structure returned will be written
+to I&lt;*x&gt;. If neither I&lt;x&gt; nor I&lt;*x&gt; is NULL then an attempt is made
+to reuse the structure at I&lt;*x&gt; (but see BUGS and EXAMPLES sections).
+Irrespective of the value of I&lt;x&gt; a pointer to the structure is always
 returned (or NULL if an error occurred).
 
-The PEM functions which write private keys take an B&lt;enc&gt; parameter
+The PEM functions which write private keys take an I&lt;enc&gt; parameter
 which specifies the encryption algorithm to use, encryption is done
 at the PEM level. If this parameter is set to NULL then the private
 key is written in unencrypted form.
 
-The B&lt;cb&gt; argument is the callback to use when querying for the pass
+The I&lt;cb&gt; argument is the callback to use when querying for the pass
 phrase used for encrypted PEM structures (normally only private keys).
 
-For the PEM write routines if the B&lt;kstr&gt; parameter is not NULL then
-B&lt;klen&gt; bytes at B&lt;kstr&gt; are used as the passphrase and B&lt;cb&gt; is
+For the PEM write routines if the I&lt;kstr&gt; parameter is not NULL then
+I&lt;klen&gt; bytes at I&lt;kstr&gt; are used as the passphrase and I&lt;cb&gt; is
 ignored.
 
-If the B&lt;cb&gt; parameters is set to NULL and the B&lt;u&gt; parameter is not
-NULL then the B&lt;u&gt; parameter is interpreted as a null terminated string
-to use as the passphrase. If both B&lt;cb&gt; and B&lt;u&gt; are NULL then the
+If the I&lt;cb&gt; parameters is set to NULL and the I&lt;u&gt; parameter is not
+NULL then the I&lt;u&gt; parameter is interpreted as a null terminated string
+to use as the passphrase. If both I&lt;cb&gt; and I&lt;u&gt; are NULL then the
 default callback routine is used which will typically prompt for the
 passphrase on the current terminal with echoing turned off.
 
@@ -286,15 +286,15 @@ routine has the following form:
 
  int cb(char *buf, int size, int rwflag, void *u);
 
-B&lt;buf&gt; is the buffer to write the passphrase to. B&lt;size&gt; is the maximum
-length of the passphrase (i.e. the size of buf). B&lt;rwflag&gt; is a flag
+I&lt;buf&gt; is the buffer to write the passphrase to. I&lt;size&gt; is the maximum
+length of the passphrase (i.e. the size of buf). I&lt;rwflag&gt; is a flag
 which is set to 0 when reading and 1 when writing. A typical routine
 will ask the user to verify the passphrase (for example by prompting
-for it twice) if B&lt;rwflag&gt; is 1. The B&lt;u&gt; parameter has the same
-value as the B&lt;u&gt; parameter passed to the PEM routine. It allows
+for it twice) if I&lt;rwflag&gt; is 1. The I&lt;u&gt; parameter has the same
+value as the I&lt;u&gt; parameter passed to the PEM routine. It allows
 arbitrary data to be passed to the callback by the application
 (for example a window handle in a GUI application). The callback
-B&lt;must&gt; return the number of characters in the passphrase or -1 if
+I&lt;must&gt; return the number of characters in the passphrase or -1 if
 an error occurred.
 
 =head1 NOTES
@@ -316,7 +316,7 @@ this:
 
  PEM_read_bio_X509(bp, &amp;x, 0, NULL);
 
-this is a bug because an attempt will be made to reuse the data at B&lt;x&gt;
+this is a bug because an attempt will be made to reuse the data at I&lt;x&gt;
 which is an uninitialised pointer.
 
 These functions make no assumption regarding the pass phrase received from the
@@ -344,15 +344,15 @@ cipher encoded as a set of hexadecimal digits. After those two lines is
 the base64-encoded encrypted data.
 
 The encryption key is derived using EVP_BytesToKey(). The cipher's
-initialization vector is passed to EVP_BytesToKey() as the B&lt;salt&gt;
+initialization vector is passed to EVP_BytesToKey() as the I&lt;salt&gt;
 parameter. Internally, B&lt;PKCS5_SALT_LEN&gt; bytes of the salt are used
 (regardless of the size of the initialization vector). The user's
-password is passed to EVP_BytesToKey() using the B&lt;data&gt; and B&lt;datal&gt;
+password is passed to EVP_BytesToKey() using the I&lt;data&gt; and I&lt;datal&gt;
 parameters. Finally, the library uses an iteration count of 1 for
 EVP_BytesToKey().
 
-The B&lt;key&gt; derived by EVP_BytesToKey() along with the original initialization
-vector is then used to decrypt the encrypted data. The B&lt;iv&gt; produced by
+The I&lt;key&gt; derived by EVP_BytesToKey() along with the original initialization
+vector is then used to decrypt the encrypted data. The I&lt;iv&gt; produced by
 EVP_BytesToKey() is not utilized or needed, and NULL should be passed to
 the function.
 
@@ -380,7 +380,7 @@ an existing structure. Therefore the following:
 
  PEM_read_bio_X509(bp, &amp;x, 0, NULL);
 
-where B&lt;x&gt; already contains a valid certificate, may not work, whereas:
+where I&lt;x&gt; already contains a valid certificate, may not work, whereas:
 
  X509_free(x);
  x = PEM_read_bio_X509(bp, NULL, 0, NULL);
diff --git a/doc/man3/X509_dup.pod b/doc/man3/X509_dup.pod
index 12675c454f..e190100d92 100644
--- a/doc/man3/X509_dup.pod
+++ b/doc/man3/X509_dup.pod
@@ -304,8 +304,8 @@ X509_dup,
 
 =head1 DESCRIPTION
 
-In the description below, I&lt;TYPE&gt; is used
-as a placeholder for any of the OpenSSL datatypes, such as I&lt;X509&gt;.
+In the description below, B&lt;I&lt;TYPE&gt;&gt; is used
+as a placeholder for any of the OpenSSL datatypes, such as B&lt;X509&gt;.
 
 The OpenSSL ASN1 parsing library templates are like a data-driven bytecode
 interpreter.
@@ -321,25 +321,26 @@ The macro IMPLEMENT_ASN1_FUNCTIONS() is used once in a source file
 to generate the function bodies.
 
 
-TYPE_new() allocates an empty object of the indicated type.
-The object returned must be released by calling TYPE_free().
+B&lt;I&lt;TYPE&gt;_new&gt;() allocates an empty object of the indicated type.
+The object returned must be released by calling B&lt;I&lt;TYPE&gt;_free&gt;().
 
-TYPE_dup() copies an existing object, leaving it untouched.
+B&lt;I&lt;TYPE&gt;_dup&gt;() copies an existing object, leaving it untouched.
 
-TYPE_free() releases the object and all pointers and sub-objects
+B&lt;I&lt;TYPE&gt;_free&gt;() releases the object and all pointers and sub-objects
 within it.
 
-TYPE_print_ctx() prints the object B&lt;a&gt; on the specified BIO B&lt;out&gt;.
-Each line will be prefixed with B&lt;indent&gt; spaces.
-The B&lt;pctx&gt; specifies the printing context and is for internal
+B&lt;I&lt;TYPE&gt;_print_ctx&gt;() prints the object I&lt;a&gt; on the specified BIO I&lt;out&gt;.
+Each line will be prefixed with I&lt;indent&gt; spaces.
+The I&lt;pctx&gt; specifies the printing context and is for internal
 use; use NULL to get the default behavior.  If a print function is
-user-defined, then pass in any B&lt;pctx&gt; down to any nested calls.
+user-defined, then pass in any I&lt;pctx&gt; down to any nested calls.
 
 =head1 RETURN VALUES
 
-TYPE_new() and TYPE_dup() return a pointer to the object or NULL on failure.
+B&lt;I&lt;TYPE&gt;_new&gt;() and B&lt;I&lt;TYPE&gt;_dup&gt;() return a pointer to the object or NULL on
+failure.
 
-TYPE_print_ctx() returns 1 on success or zero on failure.
+B&lt;I&lt;TYPE&gt;_print_ctx&gt;() returns 1 on success or zero on failure.
 
 =head1 COPYRIGHT
 
diff --git a/doc/man3/d2i_X509.pod b/doc/man3/d2i_X509.pod
index dcd4ce7151..93d709d7a2 100644
--- a/doc/man3/d2i_X509.pod
+++ b/doc/man3/d2i_X509.pod
@@ -402,7 +402,7 @@ i2d_X509_VAL,
 
 =head1 DESCRIPTION
 
-In the description here, I&lt;TYPE&gt; is used a placeholder
+In the description here, B&lt;I&lt;TYPE&gt;&gt; is used a placeholder
 for any of the OpenSSL datatypes, such as I&lt;X509_CRL&gt;.
 The function parameters I&lt;ppin&gt; and I&lt;ppout&gt; are generally
 either both named I&lt;pp&gt; in the headers, or I&lt;in&gt; and I&lt;out&gt;.
@@ -412,40 +412,40 @@ encoding.  Unlike the C structures which can have pointers to sub-objects
 within, the DER is a serialized encoding, suitable for sending over the
 network, writing to a file, and so on.
 
-d2i_TYPE() attempts to decode B&lt;len&gt; bytes at B&lt;*ppin&gt;. If successful a
-pointer to the B&lt;TYPE&gt; structure is returned and B&lt;*ppin&gt; is incremented to
-the byte following the parsed data.  If B&lt;a&gt; is not B&lt;NULL&gt; then a pointer
-to the returned structure is also written to B&lt;*a&gt;.  If an error occurred
-then B&lt;NULL&gt; is returned.
+B&lt;d2i_I&lt;TYPE&gt;&gt;() attempts to decode I&lt;len&gt; bytes at I&lt;*ppin&gt;. If successful a
+pointer to the B&lt;I&lt;TYPE&gt;&gt; structure is returned and I&lt;*ppin&gt; is incremented to
+the byte following the parsed data.  If I&lt;a&gt; is not NULL then a pointer
+to the returned structure is also written to I&lt;*a&gt;.  If an error occurred
+then NULL is returned.
 
-On a successful return, if B&lt;*a&gt; is not B&lt;NULL&gt; then it is assumed that B&lt;*a&gt;
-contains a valid B&lt;TYPE&gt; structure and an attempt is made to reuse it. This
+On a successful return, if I&lt;*a&gt; is not NULL then it is assumed that I&lt;*a&gt;
+contains a valid B&lt;I&lt;TYPE&gt;&gt; structure and an attempt is made to reuse it. This
 &quot;reuse&quot; capability is present for historical compatibility but its use is
 B&lt;strongly discouraged&gt; (see BUGS below, and the discussion in the RETURN
 VALUES section).
 
-d2i_TYPE_bio() is similar to d2i_TYPE() except it attempts
-to parse data from BIO B&lt;bp&gt;.
+B&lt;d2i_I&lt;TYPE&gt;_bio&gt;() is similar to B&lt;d2i_I&lt;TYPE&gt;&gt;() except it attempts
+to parse data from BIO I&lt;bp&gt;.
 
-d2i_TYPE_fp() is similar to d2i_TYPE() except it attempts
-to parse data from FILE pointer B&lt;fp&gt;.
+B&lt;d2i_I&lt;TYPE&gt;_fp&gt;() is similar to B&lt;d2i_I&lt;TYPE&gt;&gt;() except it attempts
+to parse data from FILE pointer I&lt;fp&gt;.
 
-i2d_TYPE() encodes the structure pointed to by B&lt;a&gt; into DER format.
-If B&lt;ppout&gt; is not B&lt;NULL&gt;, it writes the DER encoded data to the buffer
-at B&lt;*ppout&gt;, and increments it to point after the data just written.
+B&lt;i2d_I&lt;TYPE&gt;&gt;() encodes the structure pointed to by I&lt;a&gt; into DER format.
+If I&lt;ppout&gt; is not NULL, it writes the DER encoded data to the buffer
+at I&lt;*ppout&gt;, and increments it to point after the data just written.
 If the return value is negative an error occurred, otherwise it
 returns the length of the encoded data.
 
-If B&lt;*ppout&gt; is B&lt;NULL&gt; memory will be allocated for a buffer and the encoded
-data written to it. In this case B&lt;*ppout&gt; is not incremented and it points
+If I&lt;*ppout&gt; is NULL memory will be allocated for a buffer and the encoded
+data written to it. In this case I&lt;*ppout&gt; is not incremented and it points
 to the start of the data just written.
 
-i2d_TYPE_bio() is similar to i2d_TYPE() except it writes
-the encoding of the structure B&lt;a&gt; to BIO B&lt;bp&gt; and it
+B&lt;i2d_I&lt;TYPE&gt;_bio&gt;() is similar to B&lt;i2d_I&lt;TYPE&gt;&gt;() except it writes
+the encoding of the structure I&lt;a&gt; to BIO I&lt;bp&gt; and it
 returns 1 for success and 0 for failure.
 
-i2d_TYPE_fp() is similar to i2d_TYPE() except it writes
-the encoding of the structure B&lt;a&gt; to BIO B&lt;bp&gt; and it
+B&lt;i2d_I&lt;TYPE&gt;_fp&gt;() is similar to B&lt;i2d_I&lt;TYPE&gt;&gt;() except it writes
+the encoding of the structure I&lt;a&gt; to BIO I&lt;bp&gt; and it
 returns 1 for success and 0 for failure.
 
 These routines do not encrypt private keys and therefore offer no
@@ -453,14 +453,14 @@ security; use L&lt;PEM_write_PrivateKey(3)&gt; or similar for writing to files.
 
 =head1 NOTES
 
-The letters B&lt;i&gt; and B&lt;d&gt; in B&lt;i2d_TYPE&gt; stand for
+The letters B&lt;i&gt; and B&lt;d&gt; in B&lt;i2d_I&lt;TYPE&gt;&gt;() stand for
 &quot;internal&quot; (that is, an internal C structure) and &quot;DER&quot; respectively.
-So B&lt;i2d_TYPE&gt; converts from internal to DER.
+So B&lt;i2d_I&lt;TYPE&gt;&gt;() converts from internal to DER.
 
 The functions can also understand B&lt;BER&gt; forms.
 
-The actual TYPE structure passed to i2d_TYPE() must be a valid
-populated B&lt;TYPE&gt; structure -- it B&lt;cannot&gt; simply be fed with an
+The actual TYPE structure passed to B&lt;i2d_I&lt;TYPE&gt;&gt;() must be a valid
+populated B&lt;I&lt;TYPE&gt;&gt; structure -- it B&lt;cannot&gt; simply be fed with an
 empty structure such as that returned by TYPE_new().
 
 The encoded data is in binary form and may contain embedded zeroes.
@@ -468,7 +468,7 @@ Therefore any FILE pointers or BIOs should be opened in binary mode.
 Functions such as strlen() will B&lt;not&gt; return the correct length
 of the encoded structure.
 
-The ways that B&lt;*ppin&gt; and B&lt;*ppout&gt; are incremented after the operation
+The ways that I&lt;*ppin&gt; and I&lt;*ppout&gt; are incremented after the operation
 can trap the unwary. See the B&lt;WARNINGS&gt; section for some common
 errors.
 The reason for this-auto increment behaviour is to reflect a typical
@@ -495,10 +495,10 @@ Represents an ANSI X9.42 DH parameters structure.
 
 Represents a DSA public key using a B&lt;SubjectPublicKeyInfo&gt; structure.
 
-=item B&lt;DSAPublicKey, DSAPrivateKey&gt;
+=item B&lt;DSAPublicKey&gt;, B&lt;DSAPrivateKey&gt;
 
 Use a non-standard OpenSSL format and should be avoided; use B&lt;DSA_PUBKEY&gt;,
-B&lt;PEM_write_PrivateKey(3)&gt;, or similar instead.
+L&lt;PEM_write_PrivateKey(3)&gt;, or similar instead.
 
 =item B&lt;ECDSA_SIG&gt;
 
@@ -530,16 +530,16 @@ Represents the B&lt;DigestInfo&gt; structure defined in PKCS#1 and PKCS#7.
 
 =head1 RETURN VALUES
 
-d2i_TYPE(), d2i_TYPE_bio() and d2i_TYPE_fp() return a valid B&lt;TYPE&gt; structure
-or B&lt;NULL&gt; if an error occurs.  If the &quot;reuse&quot; capability has been used with
-a valid structure being passed in via B&lt;a&gt;, then the object is freed in
-the event of error and B&lt;*a&gt; is set to NULL.
+B&lt;d2i_I&lt;TYPE&gt;&gt;(), B&lt;d2i_I&lt;TYPE&gt;_bio&gt;() and B&lt;d2i_I&lt;TYPE&gt;_fp&gt;() return a valid
+B&lt;I&lt;TYPE&gt;&gt; structure or NULL if an error occurs.  If the &quot;reuse&quot; capability has
+been used with a valid structure being passed in via I&lt;a&gt;, then the object is
+freed in the event of error and I&lt;*a&gt; is set to NULL.
 
-i2d_TYPE() returns the number of bytes successfully encoded or a negative
+B&lt;i2d_I&lt;TYPE&gt;&gt;() returns the number of bytes successfully encoded or a negative
 value if an error occurs.
 
-i2d_TYPE_bio() and i2d_TYPE_fp() return 1 for success and 0 if an error
-occurs.
+B&lt;i2d_I&lt;TYPE&gt;_bio&gt;() and B&lt;i2d_I&lt;TYPE&gt;_fp&gt;() return 1 for success and 0 if an
+error occurs.
 
 =head1 EXAMPLES
 
@@ -593,12 +593,12 @@ mistake is to attempt to use a buffer directly as follows:
  ...
  OPENSSL_free(buf);
 
-This code will result in B&lt;buf&gt; apparently containing garbage because
+This code will result in I&lt;buf&gt; apparently containing garbage because
 it was incremented after the call to point after the data just written.
-Also B&lt;buf&gt; will no longer contain the pointer allocated by OPENSSL_malloc()
+Also I&lt;buf&gt; will no longer contain the pointer allocated by OPENSSL_malloc()
 and the subsequent call to OPENSSL_free() is likely to crash.
 
-Another trap to avoid is misuse of the B&lt;a&gt; argument to d2i_TYPE():
+Another trap to avoid is misuse of the I&lt;a&gt; argument to B&lt;d2i_I&lt;TYPE&gt;&gt;():
 
  X509 *x;
 
@@ -606,31 +606,31 @@ Another trap to avoid is misuse of the B&lt;a&gt; argument to d2i_TYPE():
      /* error */
 
 This will probably crash somewhere in d2i_X509(). The reason for this
-is that the variable B&lt;x&gt; is uninitialized and an attempt will be made to
+is that the variable I&lt;x&gt; is uninitialized and an attempt will be made to
 interpret its (invalid) value as an B&lt;X509&gt; structure, typically causing
-a segmentation violation. If B&lt;x&gt; is set to NULL first then this will not
+a segmentation violation. If I&lt;x&gt; is set to NULL first then this will not
 happen.
 
 =head1 BUGS
 
-In some versions of OpenSSL the &quot;reuse&quot; behaviour of d2i_TYPE() when
-B&lt;*a&gt; is valid is broken and some parts of the reused structure may
+In some versions of OpenSSL the &quot;reuse&quot; behaviour of B&lt;d2i_I&lt;TYPE&gt;&gt;() when
+I&lt;*a&gt; is valid is broken and some parts of the reused structure may
 persist if they are not present in the new one. Additionally, in versions of
 OpenSSL prior to 1.1.0, when the &quot;reuse&quot; behaviour is used and an error occurs
 the behaviour is inconsistent. Some functions behaved as described here, while
-some did not free B&lt;*a&gt; on error and did not set B&lt;*a&gt; to NULL.
+some did not free I&lt;*a&gt; on error and did not set I&lt;*a&gt; to NULL.
 
 As a result of the above issues the &quot;reuse&quot; behaviour is strongly discouraged.
 
-i2d_TYPE() will not return an error in many versions of OpenSSL,
+B&lt;i2d_I&lt;TYPE&gt;&gt;() will not return an error in many versions of OpenSSL,
 if mandatory fields are not initialized due to a programming error
 then the encoded structure may contain invalid data or omit the
-fields entirely and will not be parsed by d2i_TYPE(). This may be
-fixed in future so code should not assume that i2d_TYPE() will
+fields entirely and will not be parsed by B&lt;d2i_I&lt;TYPE&gt;&gt;(). This may be
+fixed in future so code should not assume that B&lt;i2d_I&lt;TYPE&gt;&gt;() will
 always succeed.
 
-Any function which encodes a structure (i2d_TYPE(),
-i2d_TYPE() or i2d_TYPE()) may return a stale encoding if the
+Any function which encodes a structure (B&lt;i2d_I&lt;TYPE&gt;&gt;(),
+B&lt;i2d_I&lt;TYPE&gt;&gt;() or B&lt;i2d_I&lt;TYPE&gt;&gt;()) may return a stale encoding if the
 structure has been modified after deserialization or previous
 serialization. This is because some objects cache the encoding for
 efficiency reasons.
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="025398.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="025400.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25399">[ date ]</a>
              <a href="thread.html#25399">[ thread ]</a>
              <a href="subject.html#25399">[ subject ]</a>
              <a href="author.html#25399">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
