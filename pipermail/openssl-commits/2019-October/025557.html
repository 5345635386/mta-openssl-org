<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-October/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1570649617.622945.9542.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025554.html">
   <LINK REL="Next"  HREF="025561.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1570649617.622945.9542.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Wed Oct  9 19:33:37 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="025554.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="025561.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25557">[ date ]</a>
              <a href="thread.html#25557">[ thread ]</a>
              <a href="subject.html#25557">[ subject ]</a>
              <a href="author.html#25557">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  12a765a5235f181c2f4992b615eb5f892c368e88 (commit)
      from  3a4e43de473ee80347036d78163889b6b1221210 (commit)


- Log -----------------------------------------------------------------
commit 12a765a5235f181c2f4992b615eb5f892c368e88
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at akamai.com</A>&gt;
Date:   Mon Sep 16 15:28:57 2019 -0400

    Explicitly test against NULL; do not use !p or similar
    
    Also added blanks lines after declarations in a couple of places.
    
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9916">https://github.com/openssl/openssl/pull/9916</A>)

-----------------------------------------------------------------------

Summary of changes:
 apps/crl.c                  |  4 ++--
 apps/genpkey.c              |  4 ++--
 apps/lib/apps.c             |  6 +++---
 apps/pkcs12.c               |  2 +-
 apps/req.c                  |  5 +++--
 apps/ts.c                   |  3 ++-
 crypto/asn1/a_strnid.c      |  2 +-
 crypto/asn1/a_verify.c      |  2 +-
 crypto/asn1/ameth_lib.c     |  3 ++-
 crypto/asn1/asn_mime.c      |  2 +-
 crypto/asn1/bio_ndef.c      | 10 ++++-----
 crypto/asn1/d2i_pr.c        |  4 ++--
 crypto/asn1/p5_pbev2.c      |  2 +-
 crypto/asn1/t_spki.c        |  2 +-
 crypto/asn1/tasn_dec.c      | 22 ++++++++++++--------
 crypto/asn1/tasn_enc.c      |  8 ++++----
 crypto/asn1/tasn_fre.c      | 10 ++++-----
 crypto/asn1/x_bignum.c      |  6 +++---
 crypto/async/async.c        |  2 +-
 crypto/bn/bn_gf2m.c         |  6 +++---
 crypto/cms/cms_env.c        |  9 ++++----
 crypto/cms/cms_ess.c        |  2 +-
 crypto/cms/cms_kari.c       |  9 ++++----
 crypto/cms/cms_lib.c        | 50 +++++++++++++++++++++++++++------------------
 crypto/cms/cms_pwri.c       |  4 ++--
 crypto/cms/cms_sd.c         |  2 +-
 crypto/cms/cms_smime.c      | 17 +++++++--------
 crypto/conf/conf_mod.c      | 11 +++++-----
 crypto/dh/dh_ameth.c        | 20 ++++++++++--------
 crypto/dh/dh_pmeth.c        |  1 +
 crypto/dsa/dsa_ameth.c      |  4 ++--
 crypto/ec/ec_ameth.c        |  6 +++---
 crypto/ec/ec_asn1.c         | 19 +++++++++--------
 crypto/ec/ec_lib.c          |  4 ++--
 crypto/engine/eng_dyn.c     |  2 +-
 crypto/engine/eng_openssl.c |  3 ++-
 crypto/engine/eng_pkey.c    |  4 ++--
 crypto/engine/eng_table.c   |  2 +-
 crypto/err/err.c            |  2 +-
 crypto/evp/e_aes.c          |  2 +-
 crypto/evp/evp_pbe.c        |  5 +++--
 crypto/evp/p5_crpt.c        |  4 ++--
 crypto/evp/p_lib.c          |  2 +-
 crypto/evp/p_open.c         |  2 +-
 crypto/evp/pmeth_lib.c      |  3 ++-
 crypto/ocsp/ocsp_ht.c       | 10 ++++-----
 crypto/ocsp/ocsp_lib.c      | 15 ++++++--------
 crypto/pem/pem_pk8.c        |  9 ++++----
 crypto/pem/pem_pkey.c       |  8 ++++----
 crypto/pem/pvkfmt.c         |  3 ++-
 crypto/pkcs12/p12_add.c     |  2 +-
 crypto/pkcs12/p12_crpt.c    |  2 +-
 crypto/pkcs12/p12_crt.c     | 29 +++++++++++++-------------
 crypto/pkcs12/p12_key.c     |  4 ++--
 crypto/pkcs12/p12_kiss.c    | 15 +++++++-------
 crypto/pkcs12/p12_mutl.c    |  2 +-
 crypto/pkcs12/p12_npas.c    |  7 ++++---
 crypto/pkcs12/p12_p8e.c     |  2 +-
 crypto/pkcs7/pk7_doit.c     | 10 ++++-----
 crypto/pkcs7/pk7_lib.c      |  2 +-
 crypto/pkcs7/pk7_smime.c    |  6 +++---
 crypto/ts/ts_conf.c         |  5 +++--
 crypto/ts/ts_rsp_sign.c     |  2 +-
 crypto/x509/by_dir.c        |  2 +-
 crypto/x509/v3_cpols.c      |  7 ++++---
 crypto/x509/v3_crld.c       |  6 +++---
 crypto/x509/v3_info.c       |  2 +-
 crypto/x509/v3_ncons.c      | 10 +++++----
 crypto/x509/v3_pci.c        |  3 ++-
 crypto/x509/v3_pcons.c      |  3 ++-
 crypto/x509/v3_purp.c       |  4 ++--
 crypto/x509/v3_sxnet.c      |  3 ++-
 crypto/x509/v3_utl.c        |  9 ++++----
 crypto/x509/x509_trs.c      |  2 +-
 crypto/x509/x509_vfy.c      |  7 ++++---
 crypto/x509/x509_vpm.c      | 10 ++++-----
 crypto/x509/x_all.c         |  6 ++++--
 crypto/x509/x_name.c        |  6 +++---
 crypto/x509/x_pubkey.c      | 31 ++++++++++++++++------------
 engines/e_capi.c            |  7 ++++---
 ssl/ssl_asn1.c              |  2 +-
 ssl/ssl_conf.c              | 11 +++++-----
 ssl/ssl_lib.c               |  2 +-
 ssl/statem/statem_clnt.c    |  2 +-
 test/handshake_helper.c     |  2 +-
 test/testutil/stanza.c      |  2 +-
 86 files changed, 306 insertions(+), 260 deletions(-)

diff --git a/apps/crl.c b/apps/crl.c
index 49ad97b774..d36b93ba64 100644
--- a/apps/crl.c
+++ b/apps/crl.c
@@ -204,7 +204,7 @@ int crl_main(int argc, char **argv)
         }
         pkey = X509_get_pubkey(X509_OBJECT_get0_X509(xobj));
         X509_OBJECT_free(xobj);
-        if (!pkey) {
+        if (pkey == NULL) {
             BIO_printf(bio_err, &quot;Error getting CRL issuer public key\n&quot;);
             goto end;
         }
@@ -228,7 +228,7 @@ int crl_main(int argc, char **argv)
         if (!newcrl)
             goto end;
         pkey = load_key(keyfile, keyformat, 0, NULL, NULL, &quot;CRL signing key&quot;);
-        if (!pkey) {
+        if (pkey == NULL) {
             X509_CRL_free(newcrl);
             goto end;
         }
diff --git a/apps/genpkey.c b/apps/genpkey.c
index f8faf3ba94..afae4b656c 100644
--- a/apps/genpkey.c
+++ b/apps/genpkey.c
@@ -217,7 +217,7 @@ static int init_keygen_file(EVP_PKEY_CTX **pctx, const char *file, ENGINE *e)
     }
 
     pbio = BIO_new_file(file, &quot;r&quot;);
-    if (!pbio) {
+    if (pbio == NULL) {
         BIO_printf(bio_err, &quot;Can't open parameter file %s\n&quot;, file);
         return 0;
     }
@@ -225,7 +225,7 @@ static int init_keygen_file(EVP_PKEY_CTX **pctx, const char *file, ENGINE *e)
     pkey = PEM_read_bio_Parameters(pbio, NULL);
     BIO_free(pbio);
 
-    if (!pkey) {
+    if (pkey == NULL) {
         BIO_printf(bio_err, &quot;Error reading parameter file %s\n&quot;, file);
         return 0;
     }
diff --git a/apps/lib/apps.c b/apps/lib/apps.c
index 5038817750..65bd5a4070 100644
--- a/apps/lib/apps.c
+++ b/apps/lib/apps.c
@@ -85,7 +85,7 @@ int chopup_args(ARGS *arg, char *buf)
         /* Skip whitespace. */
         while (*p &amp;&amp; isspace(_UC(*p)))
             p++;
-        if (!*p)
+        if (*p == '\0')
             break;
 
         /* The start of something good :-) */
@@ -258,7 +258,7 @@ static char *app_get_pass(const char *arg, int keepbio)
 #endif
         } else if (strcmp(arg, &quot;stdin&quot;) == 0) {
             pwdbio = dup_bio_in(FORMAT_TEXT);
-            if (!pwdbio) {
+            if (pwdbio == NULL) {
                 BIO_printf(bio_err, &quot;Can't open BIO for stdin\n&quot;);
                 return NULL;
             }
@@ -407,7 +407,7 @@ static int load_pkcs12(BIO *in, const char *desc,
     if (PKCS12_verify_mac(p12, &quot;&quot;, 0) || PKCS12_verify_mac(p12, NULL, 0)) {
         pass = &quot;&quot;;
     } else {
-        if (!pem_cb)
+        if (pem_cb == NULL)
             pem_cb = (pem_password_cb *)password_callback;
         len = pem_cb(tpass, PEM_BUFSIZE, 0, cb_data);
         if (len &lt; 0) {
diff --git a/apps/pkcs12.c b/apps/pkcs12.c
index 902b75029c..a708064db1 100644
--- a/apps/pkcs12.c
+++ b/apps/pkcs12.c
@@ -465,7 +465,7 @@ int pkcs12_main(int argc, char **argv)
         p12 = PKCS12_create(cpass, name, key, ucert, certs,
                             key_pbe, cert_pbe, iter, -1, keytype);
 
-        if (!p12) {
+        if (p12 == NULL) {
             ERR_print_errors(bio_err);
             goto export_end;
         }
diff --git a/apps/req.c b/apps/req.c
index 1c9672cca1..70b4f0d657 100644
--- a/apps/req.c
+++ b/apps/req.c
@@ -325,9 +325,10 @@ int req_main(int argc, char **argv)
             newreq = 1;
             break;
         case OPT_PKEYOPT:
-            if (!pkeyopts)
+            if (pkeyopts == NULL)
                 pkeyopts = sk_OPENSSL_STRING_new_null();
-            if (!pkeyopts || !sk_OPENSSL_STRING_push(pkeyopts, opt_arg()))
+            if (pkeyopts == NULL
+                    || !sk_OPENSSL_STRING_push(pkeyopts, opt_arg()))
                 goto opthelp;
             break;
         case OPT_SIGOPT:
diff --git a/apps/ts.c b/apps/ts.c
index 4ef8a72eef..aef74adce8 100644
--- a/apps/ts.c
+++ b/apps/ts.c
@@ -507,8 +507,9 @@ static int create_digest(BIO *input, const char *digest, const EVP_MD *md,
         md_value_len = EVP_MD_size(md);
     } else {
         long digest_len;
+
         *md_value = OPENSSL_hexstr2buf(digest, &amp;digest_len);
-        if (!*md_value || md_value_len != digest_len) {
+        if (*md_value == NULL || md_value_len != digest_len) {
             OPENSSL_free(*md_value);
             *md_value = NULL;
             BIO_printf(bio_err, &quot;bad digest, %d bytes &quot;
diff --git a/crypto/asn1/a_strnid.c b/crypto/asn1/a_strnid.c
index 630ac19259..ab54739714 100644
--- a/crypto/asn1/a_strnid.c
+++ b/crypto/asn1/a_strnid.c
@@ -51,7 +51,7 @@ int ASN1_STRING_set_default_mask_asc(const char *p)
     char *end;
 
     if (strncmp(p, &quot;MASK:&quot;, 5) == 0) {
-        if (!p[5])
+        if (p[5] == '\0')
             return 0;
         mask = strtoul(p + 5, &amp;end, 0);
         if (*end)
diff --git a/crypto/asn1/a_verify.c b/crypto/asn1/a_verify.c
index 9484bccf4c..92f9448749 100644
--- a/crypto/asn1/a_verify.c
+++ b/crypto/asn1/a_verify.c
@@ -116,7 +116,7 @@ int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,
         goto err;
     }
     if (mdnid == NID_undef) {
-        if (!pkey-&gt;ameth || !pkey-&gt;ameth-&gt;item_verify) {
+        if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;item_verify == NULL) {
             ASN1err(ASN1_F_ASN1_ITEM_VERIFY,
                     ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
             goto err;
diff --git a/crypto/asn1/ameth_lib.c b/crypto/asn1/ameth_lib.c
index 4295d889cb..9ea5b665ba 100644
--- a/crypto/asn1/ameth_lib.c
+++ b/crypto/asn1/ameth_lib.c
@@ -56,6 +56,7 @@ static const EVP_PKEY_ASN1_METHOD *pkey_asn1_find(int type)
 {
     EVP_PKEY_ASN1_METHOD tmp;
     const EVP_PKEY_ASN1_METHOD *t = &amp;tmp, **ret;
+
     tmp.pkey_id = type;
     if (app_methods) {
         int idx;
@@ -64,7 +65,7 @@ static const EVP_PKEY_ASN1_METHOD *pkey_asn1_find(int type)
             return sk_EVP_PKEY_ASN1_METHOD_value(app_methods, idx);
     }
     ret = OBJ_bsearch_ameth(&amp;t, standard_methods, OSSL_NELEM(standard_methods));
-    if (!ret || !*ret)
+    if (ret == NULL || *ret == NULL)
         return NULL;
     return *ret;
 }
diff --git a/crypto/asn1/asn_mime.c b/crypto/asn1/asn_mime.c
index 3282163199..757fe9eb7a 100644
--- a/crypto/asn1/asn_mime.c
+++ b/crypto/asn1/asn_mime.c
@@ -399,7 +399,7 @@ ASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it)
     if (strcmp(hdr-&gt;value, &quot;multipart/signed&quot;) == 0) {
         /* Split into two parts */
         prm = mime_param_find(hdr, &quot;boundary&quot;);
-        if (!prm || !prm-&gt;param_value) {
+        if (prm == NULL || prm-&gt;param_value == NULL) {
             sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
             ASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_NO_MULTIPART_BOUNDARY);
             return NULL;
diff --git a/crypto/asn1/bio_ndef.c b/crypto/asn1/bio_ndef.c
index db9bbba940..bc7b4499d0 100644
--- a/crypto/asn1/bio_ndef.c
+++ b/crypto/asn1/bio_ndef.c
@@ -108,7 +108,7 @@ static int ndef_prefix(BIO *b, unsigned char **pbuf, int *plen, void *parg)
     unsigned char *p;
     int derlen;
 
-    if (!parg)
+    if (parg == NULL)
         return 0;
 
     ndef_aux = *(NDEF_SUPPORT **)parg;
@@ -123,7 +123,7 @@ static int ndef_prefix(BIO *b, unsigned char **pbuf, int *plen, void *parg)
     *pbuf = p;
     derlen = ASN1_item_ndef_i2d(ndef_aux-&gt;val, &amp;p, ndef_aux-&gt;it);
 
-    if (!*ndef_aux-&gt;boundary)
+    if (*ndef_aux-&gt;boundary == NULL)
         return 0;
 
     *plen = *ndef_aux-&gt;boundary - *pbuf;
@@ -136,7 +136,7 @@ static int ndef_prefix_free(BIO *b, unsigned char **pbuf, int *plen,
 {
     NDEF_SUPPORT *ndef_aux;
 
-    if (!parg)
+    if (parg == NULL)
         return 0;
 
     ndef_aux = *(NDEF_SUPPORT **)parg;
@@ -168,7 +168,7 @@ static int ndef_suffix(BIO *b, unsigned char **pbuf, int *plen, void *parg)
     const ASN1_AUX *aux;
     ASN1_STREAM_ARG sarg;
 
-    if (!parg)
+    if (parg == NULL)
         return 0;
 
     ndef_aux = *(NDEF_SUPPORT **)parg;
@@ -195,7 +195,7 @@ static int ndef_suffix(BIO *b, unsigned char **pbuf, int *plen, void *parg)
     *pbuf = p;
     derlen = ASN1_item_ndef_i2d(ndef_aux-&gt;val, &amp;p, ndef_aux-&gt;it);
 
-    if (!*ndef_aux-&gt;boundary)
+    if (*ndef_aux-&gt;boundary == NULL)
         return 0;
     *pbuf = *ndef_aux-&gt;boundary;
     *plen = derlen - (*ndef_aux-&gt;boundary - ndef_aux-&gt;derbuf);
diff --git a/crypto/asn1/d2i_pr.c b/crypto/asn1/d2i_pr.c
index b24f99118e..08101a826b 100644
--- a/crypto/asn1/d2i_pr.c
+++ b/crypto/asn1/d2i_pr.c
@@ -48,7 +48,7 @@ EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
             EVP_PKEY *tmp;
             PKCS8_PRIV_KEY_INFO *p8 = NULL;
             p8 = d2i_PKCS8_PRIV_KEY_INFO(NULL, &amp;p, length);
-            if (!p8)
+            if (p8 == NULL)
                 goto err;
             tmp = EVP_PKCS82PKEY(p8);
             PKCS8_PRIV_KEY_INFO_free(p8);
@@ -104,7 +104,7 @@ EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
         EVP_PKEY *ret;
 
         sk_ASN1_TYPE_pop_free(inkey, ASN1_TYPE_free);
-        if (!p8) {
+        if (p8 == NULL) {
             ASN1err(ASN1_F_D2I_AUTOPRIVATEKEY,
                     ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
             return NULL;
diff --git a/crypto/asn1/p5_pbev2.c b/crypto/asn1/p5_pbev2.c
index 49298f353f..f7f5f4655a 100644
--- a/crypto/asn1/p5_pbev2.c
+++ b/crypto/asn1/p5_pbev2.c
@@ -107,7 +107,7 @@ X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *cipher, int iter,
 
     pbe2-&gt;keyfunc = PKCS5_pbkdf2_set(iter, salt, saltlen, prf_nid, keylen);
 
-    if (!pbe2-&gt;keyfunc)
+    if (pbe2-&gt;keyfunc == NULL)
         goto merr;
 
     /* Now set up top level AlgorithmIdentifier */
diff --git a/crypto/asn1/t_spki.c b/crypto/asn1/t_spki.c
index 5cbb13e33d..b634808c43 100644
--- a/crypto/asn1/t_spki.c
+++ b/crypto/asn1/t_spki.c
@@ -30,7 +30,7 @@ int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)
     BIO_printf(out, &quot;  Public Key Algorithm: %s\n&quot;,
                (i == NID_undef) ? &quot;UNKNOWN&quot; : OBJ_nid2ln(i));
     pkey = X509_PUBKEY_get(spki-&gt;spkac-&gt;pubkey);
-    if (!pkey)
+    if (pkey == NULL)
         BIO_printf(out, &quot;  Unable to load public key\n&quot;);
     else {
         EVP_PKEY_print_public(out, pkey, 4, NULL);
diff --git a/crypto/asn1/tasn_dec.c b/crypto/asn1/tasn_dec.c
index e7c49526fc..f720c6020a 100644
--- a/crypto/asn1/tasn_dec.c
+++ b/crypto/asn1/tasn_dec.c
@@ -108,7 +108,8 @@ ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval,
 {
     ASN1_TLC c;
     ASN1_VALUE *ptmpval = NULL;
-    if (!pval)
+
+    if (pval == NULL)
         pval = &ptmpval;
     asn1_tlc_clear_nc(&amp;c);
     if (ASN1_item_ex_d2i(pval, in, len, it, -1, 0, 0, &amp;c) &gt; 0)
@@ -149,7 +150,8 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
     int otag;
     int ret = 0;
     ASN1_VALUE **pchptr;
-    if (!pval)
+
+    if (pval == NULL)
         return 0;
     if (aux &amp;&amp; aux-&gt;asn1_cb)
         asn1_cb = aux-&gt;asn1_cb;
@@ -303,7 +305,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
             goto err;
         }
 
-        if (!*pval &amp;&amp; !ASN1_item_ex_new(pval, it)) {
+        if (*pval == NULL &amp;&amp; !ASN1_item_ex_new(pval, it)) {
             ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
@@ -554,7 +556,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
             return 0;
         } else if (ret == -1)
             return -1;
-        if (!*val)
+        if (*val == NULL)
             *val = (ASN1_VALUE *)sk_ASN1_VALUE_new_null();
         else {
             /*
@@ -568,7 +570,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
             }
         }
 
-        if (!*val) {
+        if (*val == NULL) {
             ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_MALLOC_FAILURE);
             goto err;
         }
@@ -649,7 +651,8 @@ static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
     BUF_MEM buf = { 0, NULL, 0, 0 };
     const unsigned char *cont = NULL;
     long len;
-    if (!pval) {
+
+    if (pval == NULL) {
         ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_NULL);
         return 0;               /* Should never happen */
     }
@@ -786,7 +789,7 @@ static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
         return pf-&gt;prim_c2i(pval, cont, len, utype, free_cont, it);
     /* If ANY type clear type and set pointer to internal value */
     if (it-&gt;utype == V_ASN1_ANY) {
-        if (!*pval) {
+        if (*pval == NULL) {
             typ = ASN1_TYPE_new();
             if (typ == NULL)
                 goto err;
@@ -866,7 +869,7 @@ static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
             goto err;
         }
         /* All based on ASN1_STRING and handled the same */
-        if (!*pval) {
+        if (*pval == NULL) {
             stmp = ASN1_STRING_type_new(utype);
             if (stmp == NULL) {
                 ASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE);
@@ -1058,10 +1061,11 @@ static int collect_data(BUF_MEM *buf, const unsigned char **p, long plen)
 static int asn1_check_eoc(const unsigned char **in, long len)
 {
     const unsigned char *p;
+
     if (len &lt; 2)
         return 0;
     p = *in;
-    if (!p[0] &amp;&amp; !p[1]) {
+    if (p[0] == '\0' &amp;&amp; p[1] == '\0') {
         *in += 2;
         return 1;
     }
diff --git a/crypto/asn1/tasn_enc.c b/crypto/asn1/tasn_enc.c
index a499665a2f..d8abd81698 100644
--- a/crypto/asn1/tasn_enc.c
+++ b/crypto/asn1/tasn_enc.c
@@ -55,7 +55,7 @@ int ASN1_item_i2d(const ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *i
 static int asn1_item_flags_i2d(const ASN1_VALUE *val, unsigned char **out,
                                const ASN1_ITEM *it, int flags)
 {
-    if (out &amp;&amp; !*out) {
+    if (out != NULL &amp;&amp; *out == NULL) {
         unsigned char *p, *buf;
         int len;
 
@@ -89,7 +89,7 @@ int ASN1_item_ex_i2d(const ASN1_VALUE **pval, unsigned char **out,
     const ASN1_AUX *aux = it-&gt;funcs;
     ASN1_aux_const_cb *asn1_cb = NULL;
 
-    if ((it-&gt;itype != ASN1_ITYPE_PRIMITIVE) &amp;&amp; !*pval)
+    if ((it-&gt;itype != ASN1_ITYPE_PRIMITIVE) &amp;&amp; *pval == NULL)
         return 0;
 
     if (aux != NULL) {
@@ -258,7 +258,7 @@ static int asn1_template_ex_i2d(const ASN1_VALUE **pval, unsigned char **out,
         int skcontlen, sklen;
         const ASN1_VALUE *skitem;
 
-        if (!*pval)
+        if (*pval == NULL)
             return 0;
 
         if (flags &amp; ASN1_TFLG_SET_OF) {
@@ -510,7 +510,7 @@ static int asn1_ex_i2c(const ASN1_VALUE **pval, unsigned char *cout, int *putype
     /* Should type be omitted? */
     if ((it-&gt;itype != ASN1_ITYPE_PRIMITIVE)
         || (it-&gt;utype != V_ASN1_BOOLEAN)) {
-        if (!*pval)
+        if (*pval == NULL)
             return -1;
     }
 
diff --git a/crypto/asn1/tasn_fre.c b/crypto/asn1/tasn_fre.c
index 5749e2c770..e8d57bdaad 100644
--- a/crypto/asn1/tasn_fre.c
+++ b/crypto/asn1/tasn_fre.c
@@ -33,9 +33,9 @@ void asn1_item_embed_free(ASN1_VALUE **pval, const ASN1_ITEM *it, int embed)
     ASN1_aux_cb *asn1_cb;
     int i;
 
-    if (!pval)
+    if (pval == NULL)
         return;
-    if ((it-&gt;itype != ASN1_ITYPE_PRIMITIVE) &amp;&amp; !*pval)
+    if ((it-&gt;itype != ASN1_ITYPE_PRIMITIVE) &amp;&amp; *pval == NULL)
         return;
     if (aux &amp;&amp; aux-&gt;asn1_cb)
         asn1_cb = aux-&gt;asn1_cb;
@@ -168,15 +168,15 @@ void asn1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it, int embed)
 
         utype = typ-&gt;type;
         pval = &amp;typ-&gt;value.asn1_value;
-        if (!*pval)
+        if (*pval == NULL)
             return;
     } else if (it-&gt;itype == ASN1_ITYPE_MSTRING) {
         utype = -1;
-        if (!*pval)
+        if (*pval == NULL)
             return;
     } else {
         utype = it-&gt;utype;
-        if ((utype != V_ASN1_BOOLEAN) &amp;&amp; !*pval)
+        if ((utype != V_ASN1_BOOLEAN) &amp;&amp; *pval == NULL)
             return;
     }
 
diff --git a/crypto/asn1/x_bignum.c b/crypto/asn1/x_bignum.c
index c5e892900e..3ae58a49f0 100644
--- a/crypto/asn1/x_bignum.c
+++ b/crypto/asn1/x_bignum.c
@@ -82,7 +82,7 @@ static int bn_secure_new(ASN1_VALUE **pval, const ASN1_ITEM *it)
 
 static void bn_free(ASN1_VALUE **pval, const ASN1_ITEM *it)
 {
-    if (!*pval)
+    if (*pval == NULL)
         return;
     if (it-&gt;size &amp; BN_SENSITIVE)
         BN_clear_free((BIGNUM *)*pval);
@@ -96,7 +96,7 @@ static int bn_i2c(const ASN1_VALUE **pval, unsigned char *cont, int *putype,
 {
     BIGNUM *bn;
     int pad;
-    if (!*pval)
+    if (*pval == NULL)
         return -1;
     bn = (BIGNUM *)*pval;
     /* If MSB set in an octet we need a padding byte */
@@ -133,7 +133,7 @@ static int bn_secure_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
     int ret;
     BIGNUM *bn;
 
-    if (!*pval &amp;&amp; !bn_secure_new(pval, it))
+    if (*pval == NULL &amp;&amp; !bn_secure_new(pval, it))
         return 0;
 
     ret = bn_c2i(pval, cont, len, utype, free_cont, it);
diff --git a/crypto/async/async.c b/crypto/async/async.c
index 4743bb702b..312f47325b 100644
--- a/crypto/async/async.c
+++ b/crypto/async/async.c
@@ -287,7 +287,7 @@ static void async_empty_pool(async_pool *pool)
 {
     ASYNC_JOB *job;
 
-    if (!pool || !pool-&gt;jobs)
+    if (pool == NULL || pool-&gt;jobs == NULL)
         return;
 
     do {
diff --git a/crypto/bn/bn_gf2m.c b/crypto/bn/bn_gf2m.c
index bfece40c59..7a56745fe2 100644
--- a/crypto/bn/bn_gf2m.c
+++ b/crypto/bn/bn_gf2m.c
@@ -297,7 +297,7 @@ int BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[])
 
     bn_check_top(a);
 
-    if (!p[0]) {
+    if (p[0] == 0) {
         /* reduction mod 1 =&gt; return 0 */
         BN_zero(r);
         return 1;
@@ -929,7 +929,7 @@ int BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a, const int p[],
 
     bn_check_top(a);
 
-    if (!p[0]) {
+    if (p[0] == 0) {
         /* reduction mod 1 =&gt; return 0 */
         BN_zero(r);
         return 1;
@@ -988,7 +988,7 @@ int BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a_, const int p[],
 
     bn_check_top(a_);
 
-    if (!p[0]) {
+    if (p[0] == 0) {
         /* reduction mod 1 =&gt; return 0 */
         BN_zero(r);
         return 1;
diff --git a/crypto/cms/cms_env.c b/crypto/cms/cms_env.c
index bcb6162b18..ecece987ae 100644
--- a/crypto/cms/cms_env.c
+++ b/crypto/cms/cms_env.c
@@ -56,14 +56,15 @@ int cms_env_asn1_ctrl(CMS_RecipientInfo *ri, int cmd)
         pkey = ri-&gt;d.ktri-&gt;pkey;
     else if (ri-&gt;type == CMS_RECIPINFO_AGREE) {
         EVP_PKEY_CTX *pctx = ri-&gt;d.kari-&gt;pctx;
-        if (!pctx)
+
+        if (pctx == NULL)
             return 0;
         pkey = EVP_PKEY_CTX_get0_pkey(pctx);
-        if (!pkey)
+        if (pkey == NULL)
             return 0;
     } else
         return 0;
-    if (!pkey-&gt;ameth || !pkey-&gt;ameth-&gt;pkey_ctrl)
+    if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;pkey_ctrl == NULL)
         return 1;
     i = pkey-&gt;ameth-&gt;pkey_ctrl(pkey, ASN1_PKEY_CTRL_CMS_ENVELOPE, cmd, ri);
     if (i == -2) {
@@ -191,7 +192,7 @@ CMS_RecipientInfo *CMS_add1_recipient_cert(CMS_ContentInfo *cms,
         goto merr;
 
     pk = X509_get0_pubkey(recip);
-    if (!pk) {
+    if (pk == NULL) {
         CMSerr(CMS_F_CMS_ADD1_RECIPIENT_CERT, CMS_R_ERROR_GETTING_PUBLIC_KEY);
         goto err;
     }
diff --git a/crypto/cms/cms_ess.c b/crypto/cms/cms_ess.c
index 1a6c05f1af..00a08aafea 100644
--- a/crypto/cms/cms_ess.c
+++ b/crypto/cms/cms_ess.c
@@ -202,7 +202,7 @@ int cms_Receipt_verify(CMS_ContentInfo *cms, CMS_ContentInfo *req_cms)
 
     /* Extract and decode receipt content */
     pcont = CMS_get0_content(cms);
-    if (!pcont || !*pcont) {
+    if (pcont == NULL || *pcont == NULL) {
         CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_CONTENT);
         goto err;
     }
diff --git a/crypto/cms/cms_kari.c b/crypto/cms/cms_kari.c
index 3820d0e229..6b0a59ebde 100644
--- a/crypto/cms/cms_kari.c
+++ b/crypto/cms/cms_kari.c
@@ -159,10 +159,10 @@ int CMS_RecipientInfo_kari_set0_pkey(CMS_RecipientInfo *ri, EVP_PKEY *pk)
 
     EVP_PKEY_CTX_free(kari-&gt;pctx);
     kari-&gt;pctx = NULL;
-    if (!pk)
+    if (pk == NULL)
         return 1;
     pctx = EVP_PKEY_CTX_new(pk, NULL);
-    if (!pctx || EVP_PKEY_derive_init(pctx) &lt;= 0)
+    if (pctx == NULL || EVP_PKEY_derive_init(pctx) &lt;= 0)
         goto err;
     kari-&gt;pctx = pctx;
     return 1;
@@ -260,8 +260,9 @@ static int cms_kari_create_ephemeral_key(CMS_KeyAgreeRecipientInfo *kari,
     EVP_PKEY_CTX *pctx = NULL;
     EVP_PKEY *ekey = NULL;
     int rv = 0;
+
     pctx = EVP_PKEY_CTX_new(pk, NULL);
-    if (!pctx)
+    if (pctx == NULL)
         goto err;
     if (EVP_PKEY_keygen_init(pctx) &lt;= 0)
         goto err;
@@ -269,7 +270,7 @@ static int cms_kari_create_ephemeral_key(CMS_KeyAgreeRecipientInfo *kari,
         goto err;
     EVP_PKEY_CTX_free(pctx);
     pctx = EVP_PKEY_CTX_new(ekey, NULL);
-    if (!pctx)
+    if (pctx == NULL)
         goto err;
     if (EVP_PKEY_derive_init(pctx) &lt;= 0)
         goto err;
diff --git a/crypto/cms/cms_lib.c b/crypto/cms/cms_lib.c
index 5de5e9dc6d..245544e3e9 100644
--- a/crypto/cms/cms_lib.c
+++ b/crypto/cms/cms_lib.c
@@ -39,15 +39,16 @@ CMS_ContentInfo *cms_Data_create(void)
 BIO *cms_content_bio(CMS_ContentInfo *cms)
 {
     ASN1_OCTET_STRING **pos = CMS_get0_content(cms);
-    if (!pos)
+
+    if (pos == NULL)
         return NULL;
     /* If content detached data goes nowhere: create NULL BIO */
-    if (!*pos)
+    if (*pos == NULL)
         return BIO_new(BIO_s_null());
     /*
      * If content not detached and created return memory BIO
      */
-    if (!*pos || ((*pos)-&gt;flags == ASN1_STRING_FLAG_CONT))
+    if (*pos == NULL || ((*pos)-&gt;flags == ASN1_STRING_FLAG_CONT))
         return BIO_new(BIO_s_mem());
     /* Else content was read in: return read only BIO for it */
     return BIO_new_mem_buf((*pos)-&gt;data, (*pos)-&gt;length);
@@ -108,7 +109,8 @@ BIO *CMS_dataInit(CMS_ContentInfo *cms, BIO *icont)
 int CMS_dataFinal(CMS_ContentInfo *cms, BIO *cmsbio)
 {
     ASN1_OCTET_STRING **pos = CMS_get0_content(cms);
-    if (!pos)
+
+    if (pos == NULL)
         return 0;
     /* If embedded content find memory BIO and set content */
     if (*pos &amp;&amp; ((*pos)-&gt;flags &amp; ASN1_STRING_FLAG_CONT)) {
@@ -234,13 +236,14 @@ const ASN1_OBJECT *CMS_get0_eContentType(CMS_ContentInfo *cms)
 int CMS_set1_eContentType(CMS_ContentInfo *cms, const ASN1_OBJECT *oid)
 {
     ASN1_OBJECT **petype, *etype;
+
     petype = cms_get0_econtent_type(cms);
-    if (!petype)
+    if (petype == NULL)
         return 0;
-    if (!oid)
+    if (oid == NULL)
         return 1;
     etype = OBJ_dup(oid);
-    if (!etype)
+    if (etype == NULL)
         return 0;
     ASN1_OBJECT_free(*petype);
     *petype = etype;
@@ -250,10 +253,11 @@ int CMS_set1_eContentType(CMS_ContentInfo *cms, const ASN1_OBJECT *oid)
 int CMS_is_detached(CMS_ContentInfo *cms)
 {
     ASN1_OCTET_STRING **pos;
+
     pos = CMS_get0_content(cms);
-    if (!pos)
+    if (pos == NULL)
         return -1;
-    if (*pos)
+    if (*pos != NULL)
         return 0;
     return 1;
 }
@@ -261,8 +265,9 @@ int CMS_is_detached(CMS_ContentInfo *cms)
 int CMS_set_detached(CMS_ContentInfo *cms, int detached)
 {
     ASN1_OCTET_STRING **pos;
+
     pos = CMS_get0_content(cms);
-    if (!pos)
+    if (pos == NULL)
         return 0;
     if (detached) {
         ASN1_OCTET_STRING_free(*pos);
@@ -362,12 +367,13 @@ CMS_CertificateChoices *CMS_add0_CertificateChoices(CMS_ContentInfo *cms)
 {
     STACK_OF(CMS_CertificateChoices) **pcerts;
     CMS_CertificateChoices *cch;
+
     pcerts = cms_get0_certificate_choices(cms);
-    if (!pcerts)
+    if (pcerts == NULL)
         return NULL;
-    if (!*pcerts)
+    if (*pcerts == NULL)
         *pcerts = sk_CMS_CertificateChoices_new_null();
-    if (!*pcerts)
+    if (*pcerts == NULL)
         return NULL;
     cch = M_ASN1_new_of(CMS_CertificateChoices);
     if (!cch)
@@ -384,8 +390,9 @@ int CMS_add0_cert(CMS_ContentInfo *cms, X509 *cert)
     CMS_CertificateChoices *cch;
     STACK_OF(CMS_CertificateChoices) **pcerts;
     int i;
+
     pcerts = cms_get0_certificate_choices(cms);
-    if (!pcerts)
+    if (pcerts == NULL)
         return 0;
     for (i = 0; i &lt; sk_CMS_CertificateChoices_num(*pcerts); i++) {
         cch = sk_CMS_CertificateChoices_value(*pcerts, i);
@@ -439,15 +446,16 @@ CMS_RevocationInfoChoice *CMS_add0_RevocationInfoChoice(CMS_ContentInfo *cms)
 {
     STACK_OF(CMS_RevocationInfoChoice) **pcrls;
     CMS_RevocationInfoChoice *rch;
+
     pcrls = cms_get0_revocation_choices(cms);
-    if (!pcrls)
+    if (pcrls == NULL)
         return NULL;
-    if (!*pcrls)
+    if (*pcrls == NULL)
         *pcrls = sk_CMS_RevocationInfoChoice_new_null();
-    if (!*pcrls)
+    if (*pcrls == NULL)
         return NULL;
     rch = M_ASN1_new_of(CMS_RevocationInfoChoice);
-    if (!rch)
+    if (rch == NULL)
         return NULL;
     if (!sk_CMS_RevocationInfoChoice_push(*pcrls, rch)) {
         M_ASN1_free_of(rch, CMS_RevocationInfoChoice);
@@ -482,8 +490,9 @@ STACK_OF(X509) *CMS_get1_certs(CMS_ContentInfo *cms)
     CMS_CertificateChoices *cch;
     STACK_OF(CMS_CertificateChoices) **pcerts;
     int i;
+
     pcerts = cms_get0_certificate_choices(cms);
-    if (!pcerts)
+    if (pcerts == NULL)
         return NULL;
     for (i = 0; i &lt; sk_CMS_CertificateChoices_num(*pcerts); i++) {
         cch = sk_CMS_CertificateChoices_value(*pcerts, i);
@@ -510,8 +519,9 @@ STACK_OF(X509_CRL) *CMS_get1_crls(CMS_ContentInfo *cms)
     STACK_OF(CMS_RevocationInfoChoice) **pcrls;
     CMS_RevocationInfoChoice *rch;
     int i;
+
     pcrls = cms_get0_revocation_choices(cms);
-    if (!pcrls)
+    if (pcrls == NULL)
         return NULL;
     for (i = 0; i &lt; sk_CMS_RevocationInfoChoice_num(*pcrls); i++) {
         rch = sk_CMS_RevocationInfoChoice_value(*pcrls, i);
diff --git a/crypto/cms/cms_pwri.c b/crypto/cms/cms_pwri.c
index 740c7e6946..a4c32dcdc9 100644
--- a/crypto/cms/cms_pwri.c
+++ b/crypto/cms/cms_pwri.c
@@ -146,7 +146,7 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
 
     pwri-&gt;keyDerivationAlgorithm = PKCS5_pbkdf2_set(iter, NULL, 0, -1, -1);
 
-    if (!pwri-&gt;keyDerivationAlgorithm)
+    if (pwri-&gt;keyDerivationAlgorithm == NULL)
         goto err;
 
     CMS_RecipientInfo_set0_password(ri, pass, passlen);
@@ -289,7 +289,7 @@ int cms_RecipientInfo_pwri_crypt(const CMS_ContentInfo *cms, CMS_RecipientInfo *
 
     pwri = ri-&gt;d.pwri;
 
-    if (!pwri-&gt;pass) {
+    if (pwri-&gt;pass == NULL) {
         CMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, CMS_R_NO_PASSWORD);
         return 0;
     }
diff --git a/crypto/cms/cms_sd.c b/crypto/cms/cms_sd.c
index b207ebe280..4a40226cf5 100644
--- a/crypto/cms/cms_sd.c
+++ b/crypto/cms/cms_sd.c
@@ -227,7 +227,7 @@ static int cms_sd_asn1_ctrl(CMS_SignerInfo *si, int cmd)
 {
     EVP_PKEY *pkey = si-&gt;pkey;
     int i;
-    if (!pkey-&gt;ameth || !pkey-&gt;ameth-&gt;pkey_ctrl)
+    if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;pkey_ctrl == NULL)
         return 1;
     i = pkey-&gt;ameth-&gt;pkey_ctrl(pkey, ASN1_PKEY_CTRL_CMS_SIGN, cmd, si);
     if (i == -2) {
diff --git a/crypto/cms/cms_smime.c b/crypto/cms/cms_smime.c
index 171eeb31b8..4ae85c0335 100644
--- a/crypto/cms/cms_smime.c
+++ b/crypto/cms/cms_smime.c
@@ -78,7 +78,8 @@ static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)
 static int check_content(CMS_ContentInfo *cms)
 {
     ASN1_OCTET_STRING **pos = CMS_get0_content(cms);
-    if (!pos || !*pos) {
+
+    if (pos == NULL || *pos == NULL) {
         CMSerr(CMS_F_CHECK_CONTENT, CMS_R_NO_CONTENT);
         return 0;
     }
@@ -87,14 +88,13 @@ static int check_content(CMS_ContentInfo *cms)
 
 static void do_free_upto(BIO *f, BIO *upto)
 {
-    if (upto) {
+    if (upto != NULL) {
         BIO *tbio;
         do {
             tbio = BIO_pop(f);
             BIO_free(f);
             f = tbio;
-        }
-        while (f &amp;&amp; f != upto);
+        } while (f != NULL &amp;&amp; f != upto);
     } else
         BIO_free_all(f);
 }
@@ -488,7 +488,7 @@ CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si,
     flags &amp;= ~(CMS_STREAM | CMS_TEXT);
     /* Not really detached but avoids content being allocated */
     flags |= CMS_PARTIAL | CMS_BINARY | CMS_DETACHED;
-    if (!pkey || !signcert) {
+    if (pkey == NULL || signcert == NULL) {
         CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_NO_KEY_OR_CERT);
         return NULL;
     }
@@ -733,6 +733,7 @@ int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,
 {
     int r;
     BIO *cont;
+
     if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {
         CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);
         return 0;
@@ -747,12 +748,12 @@ int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,
         cms-&gt;d.envelopedData-&gt;encryptedContentInfo-&gt;havenocert = 1;
     else
         cms-&gt;d.envelopedData-&gt;encryptedContentInfo-&gt;havenocert = 0;
-    if (!pk &amp;&amp; !cert &amp;&amp; !dcont &amp;&amp; !out)
+    if (pk == NULL &amp;&amp; cert == NULL &amp;&amp; dcont == NULL &amp;&amp; out == NULL)
         return 1;
-    if (pk &amp;&amp; !CMS_decrypt_set1_pkey(cms, pk, cert))
+    if (pk != NULL &amp;&amp; !CMS_decrypt_set1_pkey(cms, pk, cert))
         return 0;
     cont = CMS_dataInit(cms, dcont);
-    if (!cont)
+    if (cont == NULL)
         return 0;
     r = cms_copy_content(out, cont, flags);
     do_free_upto(cont, dcont);
diff --git a/crypto/conf/conf_mod.c b/crypto/conf/conf_mod.c
index 56b19467a2..86924c1bff 100644
--- a/crypto/conf/conf_mod.c
+++ b/crypto/conf/conf_mod.c
@@ -198,19 +198,20 @@ static CONF_MODULE *module_load_dso(const CONF *cnf,
     const char *path = NULL;
     int errcode = 0;
     CONF_MODULE *md;
+
     /* Look for alternative path in module section */
     path = NCONF_get_string(cnf, value, &quot;path&quot;);
-    if (!path) {
+    if (path == NULL) {
         ERR_clear_error();
         path = name;
     }
     dso = DSO_load(NULL, path, NULL, 0);
-    if (!dso) {
+    if (dso == NULL) {
         errcode = CONF_R_ERROR_LOADING_DSO;
         goto err;
     }
     ifunc = (conf_init_func *)DSO_bind_func(dso, DSO_mod_init_name);
-    if (!ifunc) {
+    if (ifunc == NULL) {
         errcode = CONF_R_MISSING_INIT_FUNCTION;
         goto err;
     }
@@ -218,7 +219,7 @@ static CONF_MODULE *module_load_dso(const CONF *cnf,
     /* All OK, add module */
     md = module_add(dso, name, ifunc, ffunc);
 
-    if (!md)
+    if (md == NULL)
         goto err;
 
     return md;
@@ -533,7 +534,7 @@ int CONF_parse_list(const char *list_, int sep, int nospc,
                 lstart++;
         }
         p = strchr(lstart, sep);
-        if (p == lstart || !*lstart)
+        if (p == lstart || *lstart == '\0')
             ret = list_cb(NULL, 0, arg);
         else {
             if (p)
diff --git a/crypto/dh/dh_ameth.c b/crypto/dh/dh_ameth.c
index bb319e774d..a699afabbf 100644
--- a/crypto/dh/dh_ameth.c
+++ b/crypto/dh/dh_ameth.c
@@ -120,7 +120,7 @@ static int dh_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
     ptype = V_ASN1_SEQUENCE;
 
     pub_key = BN_to_ASN1_INTEGER(dh-&gt;pub_key, NULL);
-    if (!pub_key)
+    if (pub_key == NULL)
         goto err;
 
     penclen = i2d_ASN1_INTEGER(pub_key, &amp;penc);
@@ -158,7 +158,6 @@ static int dh_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)
     const ASN1_STRING *pstr;
     const X509_ALGOR *palg;
     ASN1_INTEGER *privkey = NULL;
-
     DH *dh = NULL;
 
     if (!PKCS8_pkey_get0(NULL, &amp;p, &amp;pklen, &amp;palg, p8))
@@ -225,7 +224,7 @@ static int dh_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
     /* Get private key into integer */
     prkey = BN_to_ASN1_INTEGER(pkey-&gt;pkey.dh-&gt;priv_key, NULL);
 
-    if (!prkey) {
+    if (prkey == NULL) {
         DHerr(DH_F_DH_PRIV_ENCODE, DH_R_BN_ERROR);
         goto err;
     }
@@ -703,7 +702,7 @@ static int dh_cms_set_peerkey(EVP_PKEY_CTX *pctx,
         goto err;
 
     pk = EVP_PKEY_CTX_get0_pkey(pctx);
-    if (!pk)
+    if (pk == NULL)
         goto err;
     if (pk-&gt;type != EVP_PKEY_DHX)
         goto err;
@@ -712,7 +711,7 @@ static int dh_cms_set_peerkey(EVP_PKEY_CTX *pctx,
     /* We have parameters now set public key */
     plen = ASN1_STRING_length(pubkey);
     p = ASN1_STRING_get0_data(pubkey);
-    if (!p || !plen)
+    if (p == NULL || plen == 0)
         goto err;
 
     if ((public_key = d2i_ASN1_INTEGER(NULL, &amp;p, plen)) == NULL) {
@@ -821,7 +820,8 @@ static int dh_cms_decrypt(CMS_RecipientInfo *ri)
 {
     EVP_PKEY_CTX *pctx;
     pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);
-    if (!pctx)
+
+    if (pctx == NULL)
         return 0;
     /* See if we need to set peer key */
     if (!EVP_PKEY_CTX_get0_peerkey(pctx)) {
@@ -862,8 +862,9 @@ static int dh_cms_encrypt(CMS_RecipientInfo *ri)
     int rv = 0;
     int kdf_type, wrap_nid;
     const EVP_MD *kdf_md;
+
     pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);
-    if (!pctx)
+    if (pctx == NULL)
         return 0;
     /* Get ephemeral key */
     pkey = EVP_PKEY_CTX_get0_pkey(pctx);
@@ -874,7 +875,8 @@ static int dh_cms_encrypt(CMS_RecipientInfo *ri)
     /* Is everything uninitialised? */
     if (aoid == OBJ_nid2obj(NID_undef)) {
         ASN1_INTEGER *pubk = BN_to_ASN1_INTEGER(pkey-&gt;pkey.dh-&gt;pub_key, NULL);
-        if (!pubk)
+
+        if (pubk == NULL)
             goto err;
         /* Set the key */
 
@@ -960,7 +962,7 @@ static int dh_cms_encrypt(CMS_RecipientInfo *ri)
      */
     penc = NULL;
     penclen = i2d_X509_ALGOR(wrap_alg, &amp;penc);
-    if (!penc || !penclen)
+    if (penc == NULL || penclen == 0)
         goto err;
     wrap_str = ASN1_STRING_new();
     if (wrap_str == NULL)
diff --git a/crypto/dh/dh_pmeth.c b/crypto/dh/dh_pmeth.c
index 9eb17b4795..55d11d638b 100644
--- a/crypto/dh/dh_pmeth.c
+++ b/crypto/dh/dh_pmeth.c
@@ -80,6 +80,7 @@ static void pkey_dh_cleanup(EVP_PKEY_CTX *ctx)
 static int pkey_dh_copy(EVP_PKEY_CTX *dst, const EVP_PKEY_CTX *src)
 {
     DH_PKEY_CTX *dctx, *sctx;
+
     if (!pkey_dh_init(dst))
         return 0;
     sctx = src-&gt;data;
diff --git a/crypto/dsa/dsa_ameth.c b/crypto/dsa/dsa_ameth.c
index 3fbec04900..b72005af2c 100644
--- a/crypto/dsa/dsa_ameth.c
+++ b/crypto/dsa/dsa_ameth.c
@@ -211,7 +211,7 @@ static int dsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
     unsigned char *dp = NULL;
     int dplen;
 
-    if (!pkey-&gt;pkey.dsa || !pkey-&gt;pkey.dsa-&gt;priv_key) {
+    if (pkey-&gt;pkey.dsa  == NULL|| pkey-&gt;pkey.dsa-&gt;priv_key == NULL) {
         DSAerr(DSA_F_DSA_PRIV_ENCODE, DSA_R_MISSING_PARAMETERS);
         goto err;
     }
@@ -233,7 +233,7 @@ static int dsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
     /* Get private key into integer */
     prkey = BN_to_ASN1_INTEGER(pkey-&gt;pkey.dsa-&gt;priv_key, NULL);
 
-    if (!prkey) {
+    if (prkey == NULL) {
         DSAerr(DSA_F_DSA_PRIV_ENCODE, DSA_R_BN_ERROR);
         goto err;
     }
diff --git a/crypto/ec/ec_ameth.c b/crypto/ec/ec_ameth.c
index a0965ea78d..6105e6b087 100644
--- a/crypto/ec/ec_ameth.c
+++ b/crypto/ec/ec_ameth.c
@@ -196,7 +196,7 @@ static int eckey_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)
 
     eckey = eckey_type2param(ptype, pval);
 
-    if (!eckey)
+    if (eckey == NULL)
         goto ecliberr;
 
     /* We have parameters now set private key */
@@ -650,7 +650,7 @@ static int ecdh_cms_set_peerkey(EVP_PKEY_CTX *pctx,
         const EC_GROUP *grp;
         EVP_PKEY *pk;
         pk = EVP_PKEY_CTX_get0_pkey(pctx);
-        if (!pk)
+        if (pk == NULL)
             goto err;
         grp = EC_KEY_get0_group(pk-&gt;pkey.ec);
         ecpeer = EC_KEY_new();
@@ -666,7 +666,7 @@ static int ecdh_cms_set_peerkey(EVP_PKEY_CTX *pctx,
     /* We have parameters now set public key */
     plen = ASN1_STRING_length(pubkey);
     p = ASN1_STRING_get0_data(pubkey);
-    if (!p || !plen)
+    if (p == NULL || plen == 0)
         goto err;
     if (!o2i_ECPublicKey(&amp;ecpeer, &amp;p, plen))
         goto err;
diff --git a/crypto/ec/ec_asn1.c b/crypto/ec/ec_asn1.c
index 128ea71afc..502a383435 100644
--- a/crypto/ec/ec_asn1.c
+++ b/crypto/ec/ec_asn1.c
@@ -581,8 +581,9 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
     int curve_name = NID_undef;
     BN_CTX *ctx = NULL;
 
-    if (!params-&gt;fieldID || !params-&gt;fieldID-&gt;fieldType ||
-        !params-&gt;fieldID-&gt;p.ptr) {
+    if (params-&gt;fieldID == NULL
+            || params-&gt;fieldID-&gt;fieldType == NULL
+            || params-&gt;fieldID-&gt;p.ptr == NULL) {
         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
         goto err;
     }
@@ -593,9 +594,9 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
      * encoded them incorrectly, so we must accept any length for backwards
      * compatibility.
      */
-    if (!params-&gt;curve || !params-&gt;curve-&gt;a ||
-        !params-&gt;curve-&gt;a-&gt;data || !params-&gt;curve-&gt;b ||
-        !params-&gt;curve-&gt;b-&gt;data) {
+    if (params-&gt;curve == NULL
+            || params-&gt;curve-&gt;a == NULL || params-&gt;curve-&gt;a-&gt;data == NULL
+            || params-&gt;curve-&gt;b == NULL || params-&gt;curve-&gt;b-&gt;data == NULL) {
         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
         goto err;
     }
@@ -665,7 +666,7 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
             X9_62_PENTANOMIAL *penta;
 
             penta = char_two-&gt;p.ppBasis;
-            if (!penta) {
+            if (penta == NULL) {
                 ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
                 goto err;
             }
@@ -705,7 +706,7 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
     else if (tmp == NID_X9_62_prime_field) {
         /* we have a curve over a prime field */
         /* extract the prime number */
-        if (!params-&gt;fieldID-&gt;p.prime) {
+        if (params-&gt;fieldID-&gt;p.prime == NULL) {
             ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
             goto err;
         }
@@ -750,7 +751,9 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
         ret-&gt;seed_len = params-&gt;curve-&gt;seed-&gt;length;
     }
 
-    if (!params-&gt;order || !params-&gt;base || !params-&gt;base-&gt;data) {
+    if (params-&gt;order == NULL
+            || params-&gt;base == NULL
+            || params-&gt;base-&gt;data == NULL) {
         ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
         goto err;
     }
diff --git a/crypto/ec/ec_lib.c b/crypto/ec/ec_lib.c
index e45b8352cd..69b3c7fca5 100644
--- a/crypto/ec/ec_lib.c
+++ b/crypto/ec/ec_lib.c
@@ -710,7 +710,7 @@ EC_POINT *EC_POINT_new(const EC_GROUP *group)
 
 void EC_POINT_free(EC_POINT *point)
 {
-    if (!point)
+    if (point == NULL)
         return;
 
     if (point-&gt;meth-&gt;point_finish != 0)
@@ -720,7 +720,7 @@ void EC_POINT_free(EC_POINT *point)
 
 void EC_POINT_clear_free(EC_POINT *point)
 {
-    if (!point)
+    if (point == NULL)
         return;
 
     if (point-&gt;meth-&gt;point_clear_finish != 0)
diff --git a/crypto/engine/eng_dyn.c b/crypto/engine/eng_dyn.c
index 7b1bc6ed84..15504410d9 100644
--- a/crypto/engine/eng_dyn.c
+++ b/crypto/engine/eng_dyn.c
@@ -343,7 +343,7 @@ static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
         return 1;
     case DYNAMIC_CMD_DIR_ADD:
         /* a NULL 'p' or a string of zero-length is the same thing */
-        if (!p || (strlen((const char *)p) &lt; 1)) {
+        if (p == NULL || (strlen((const char *)p) &lt; 1)) {
             ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT);
             return 0;
         }
diff --git a/crypto/engine/eng_openssl.c b/crypto/engine/eng_openssl.c
index 53edb41a3e..b5c087830c 100644
--- a/crypto/engine/eng_openssl.c
+++ b/crypto/engine/eng_openssl.c
@@ -625,7 +625,8 @@ static int ossl_pkey_meths(ENGINE *e, EVP_PKEY_METHOD **pmeth,
         EVP_PKEY_HMAC,
         0
     };
-    if (!pmeth) {
+
+    if (pmeth == NULL) {
         *nids = ossl_pkey_nids;
         return 1;
     }
diff --git a/crypto/engine/eng_pkey.c b/crypto/engine/eng_pkey.c
index 1f67eaa4fc..b8853df1cf 100644
--- a/crypto/engine/eng_pkey.c
+++ b/crypto/engine/eng_pkey.c
@@ -73,7 +73,7 @@ EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,
         return 0;
     }
     pkey = e-&gt;load_privkey(e, key_id, ui_method, callback_data);
-    if (!pkey) {
+    if (pkey == NULL) {
         ENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,
                   ENGINE_R_FAILED_LOADING_PRIVATE_KEY);
         return 0;
@@ -103,7 +103,7 @@ EVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,
         return 0;
     }
     pkey = e-&gt;load_pubkey(e, key_id, ui_method, callback_data);
-    if (!pkey) {
+    if (pkey == NULL) {
         ENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY,
                   ENGINE_R_FAILED_LOADING_PUBLIC_KEY);
         return 0;
diff --git a/crypto/engine/eng_table.c b/crypto/engine/eng_table.c
index f6dfad9867..dc85cdf526 100644
--- a/crypto/engine/eng_table.c
+++ b/crypto/engine/eng_table.c
@@ -170,7 +170,7 @@ void engine_table_unregister(ENGINE_TABLE **table, ENGINE *e)
 
 static void int_cleanup_cb_doall(ENGINE_PILE *p)
 {
-    if (!p)
+    if (p == NULL)
         return;
     sk_ENGINE_free(p-&gt;sk);
     if (p-&gt;funct)
diff --git a/crypto/err/err.c b/crypto/err/err.c
index f46f3bef30..b636473ba6 100644
--- a/crypto/err/err.c
+++ b/crypto/err/err.c
@@ -641,7 +641,7 @@ const char *ERR_reason_error_string(unsigned long e)
     r = ERR_GET_REASON(e);
     d.error = ERR_PACK(l, 0, r);
     p = int_err_get_item(&amp;d);
-    if (!p) {
+    if (p == NULL) {
         d.error = ERR_PACK(0, 0, r);
         p = int_err_get_item(&amp;d);
     }
diff --git a/crypto/evp/e_aes.c b/crypto/evp/e_aes.c
index 49ed886e64..42c2e5eb7b 100644
--- a/crypto/evp/e_aes.c
+++ b/crypto/evp/e_aes.c
@@ -3744,7 +3744,7 @@ static int aes_ocb_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         return 1;
 
     case EVP_CTRL_AEAD_SET_TAG:
-        if (!ptr) {
+        if (ptr == NULL) {
             /* Tag len must be 0 to 16 */
             if (arg &lt; 0 || arg &gt; 16)
                 return 0;
diff --git a/crypto/evp/evp_pbe.c b/crypto/evp/evp_pbe.c
index 5ccb8214a3..a9f94bd5bc 100644
--- a/crypto/evp/evp_pbe.c
+++ b/crypto/evp/evp_pbe.c
@@ -93,8 +93,9 @@ int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,
     if (!EVP_PBE_find(EVP_PBE_TYPE_OUTER, OBJ_obj2nid(pbe_obj),
                       &amp;cipher_nid, &amp;md_nid, &amp;keygen)) {
         char obj_tmp[80];
+
         EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM);
-        if (!pbe_obj)
+        if (pbe_obj == NULL)
             OPENSSL_strlcpy(obj_tmp, &quot;NULL&quot;, sizeof(obj_tmp));
         else
             i2t_ASN1_OBJECT(obj_tmp, sizeof(obj_tmp), pbe_obj);
@@ -102,7 +103,7 @@ int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,
         return 0;
     }
 
-    if (!pass)
+    if (pass == NULL)
         passlen = 0;
     else if (passlen == -1)
         passlen = strlen(pass);
diff --git a/crypto/evp/p5_crpt.c b/crypto/evp/p5_crpt.c
index 0f5158e4d6..272643cf37 100644
--- a/crypto/evp/p5_crpt.c
+++ b/crypto/evp/p5_crpt.c
@@ -59,14 +59,14 @@ int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *cctx, const char *pass, int passlen,
         return 0;
     }
 
-    if (!pbe-&gt;iter)
+    if (pbe-&gt;iter == NULL)
         iter = 1;
     else
         iter = ASN1_INTEGER_get(pbe-&gt;iter);
     salt = pbe-&gt;salt-&gt;data;
     saltlen = pbe-&gt;salt-&gt;length;
 
-    if (!pass)
+    if (pass == NULL)
         passlen = 0;
     else if (passlen == -1)
         passlen = strlen(pass);
diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
index e2c6eaa17f..04530063d8 100644
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -40,7 +40,7 @@ int EVP_PKEY_security_bits(const EVP_PKEY *pkey)
 {
     if (pkey == NULL)
         return 0;
-    if (!pkey-&gt;ameth || !pkey-&gt;ameth-&gt;pkey_security_bits)
+    if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;pkey_security_bits == NULL)
         return -2;
     return pkey-&gt;ameth-&gt;pkey_security_bits(pkey);
 }
diff --git a/crypto/evp/p_open.c b/crypto/evp/p_open.c
index a141eb4da5..8cc72ebbf2 100644
--- a/crypto/evp/p_open.c
+++ b/crypto/evp/p_open.c
@@ -31,7 +31,7 @@ int EVP_OpenInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
             return 0;
     }
 
-    if (!priv)
+    if (priv == NULL)
         return 1;
 
     if (EVP_PKEY_id(priv) != EVP_PKEY_RSA) {
diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index 7dbdb460e3..1ae22a7df4 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -95,6 +95,7 @@ const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type)
     pmeth_fn *ret;
     EVP_PKEY_METHOD tmp;
     const EVP_PKEY_METHOD *t = &tmp;
+
     tmp.pkey_id = type;
     if (app_pkey_methods) {
         int idx;
@@ -105,7 +106,7 @@ const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type)
     ret = OBJ_bsearch_pmeth_func(&amp;t, standard_methods,
                                  sizeof(standard_methods) /
                                  sizeof(pmeth_fn));
-    if (!ret || !*ret)
+    if (ret == NULL || *ret == NULL)
         return NULL;
     return (**ret)();
 }
diff --git a/crypto/ocsp/ocsp_ht.c b/crypto/ocsp/ocsp_ht.c
index c75bfdb403..fa147f3b16 100644
--- a/crypto/ocsp/ocsp_ht.c
+++ b/crypto/ocsp/ocsp_ht.c
@@ -142,7 +142,7 @@ int OCSP_REQ_CTX_http(OCSP_REQ_CTX *rctx, const char *op, const char *path)
 {
     static const char http_hdr[] = &quot;%s %s HTTP/1.0\r\n&quot;;
 
-    if (!path)
+    if (path == NULL)
         path = &quot;/&quot;;
 
     if (BIO_printf(rctx-&gt;mem, http_hdr, op, path) &lt;= 0)
@@ -211,7 +211,7 @@ static int parse_http_line1(char *line)
 
     for (p = line; *p &amp;&amp; !ossl_isspace(*p); p++)
         continue;
-    if (!*p) {
+    if (*p == '\0') {
         OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
         return 0;
     }
@@ -220,7 +220,7 @@ static int parse_http_line1(char *line)
     while (*p &amp;&amp; ossl_isspace(*p))
         p++;
 
-    if (!*p) {
+    if (*p == '\0') {
         OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
         return 0;
     }
@@ -229,7 +229,7 @@ static int parse_http_line1(char *line)
     for (q = p; *q &amp;&amp; !ossl_isspace(*q); q++)
         continue;
 
-    if (!*q) {
+    if (*q == '\0') {
         OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);
         return 0;
     }
@@ -258,7 +258,7 @@ static int parse_http_line1(char *line)
     }
     if (retcode != 200) {
         OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_ERROR);
-        if (!*q)
+        if (*q == '\0')
             ERR_add_error_data(2, &quot;Code=&quot;, p);
         else
             ERR_add_error_data(4, &quot;Code=&quot;, p, &quot;,Reason=&quot;, q);
diff --git a/crypto/ocsp/ocsp_lib.c b/crypto/ocsp/ocsp_lib.c
index 90a92b9e60..a027062ccf 100644
--- a/crypto/ocsp/ocsp_lib.c
+++ b/crypto/ocsp/ocsp_lib.c
@@ -132,8 +132,7 @@ int OCSP_parse_url(const char *url, char **phost, char **pport, char **ppath,
 
     /* Check for initial colon */
     p = strchr(buf, ':');
-
-    if (!p)
+    if (p == NULL)
         goto parse_err;
 
     *(p++) = '\0';
@@ -156,10 +155,8 @@ int OCSP_parse_url(const char *url, char **phost, char **pport, char **ppath,
     host = p;
 
     /* Check for trailing part of path */
-
     p = strchr(p, '/');
-
-    if (!p)
+    if (p == NULL)
         *ppath = OPENSSL_strdup(&quot;/&quot;);
     else {
         *ppath = OPENSSL_strdup(p);
@@ -167,7 +164,7 @@ int OCSP_parse_url(const char *url, char **phost, char **pport, char **ppath,
         *p = '\0';
     }
 
-    if (!*ppath)
+    if (*ppath == NULL)
         goto mem_err;
 
     p = host;
@@ -175,7 +172,7 @@ int OCSP_parse_url(const char *url, char **phost, char **pport, char **ppath,
         /* ipv6 literal */
         host++;
         p = strchr(host, ']');
-        if (!p)
+        if (p == NULL)
             goto parse_err;
         *p = '\0';
         p++;
@@ -188,12 +185,12 @@ int OCSP_parse_url(const char *url, char **phost, char **pport, char **ppath,
     }
 
     *pport = OPENSSL_strdup(port);
-    if (!*pport)
+    if (*pport == NULL)
         goto mem_err;
 
     *phost = OPENSSL_strdup(host);
 
-    if (!*phost)
+    if (*phost == NULL)
         goto mem_err;
 
     OPENSSL_free(buf);
diff --git a/crypto/pem/pem_pk8.c b/crypto/pem/pem_pk8.c
index d8bb9bbf8f..642d4f6e24 100644
--- a/crypto/pem/pem_pk8.c
+++ b/crypto/pem/pem_pk8.c
@@ -117,10 +117,11 @@ EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
     int klen;
     EVP_PKEY *ret;
     char psbuf[PEM_BUFSIZE];
+
     p8 = d2i_PKCS8_bio(bp, NULL);
-    if (!p8)
+    if (p8 == NULL)
         return NULL;
-    if (cb)
+    if (cb != NULL)
         klen = cb(psbuf, PEM_BUFSIZE, 0, u);
     else
         klen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
@@ -132,13 +133,13 @@ EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
     p8inf = PKCS8_decrypt(p8, psbuf, klen);
     X509_SIG_free(p8);
     OPENSSL_cleanse(psbuf, klen);
-    if (!p8inf)
+    if (p8inf == NULL)
         return NULL;
     ret = EVP_PKCS82PKEY(p8inf);
     PKCS8_PRIV_KEY_INFO_free(p8inf);
     if (!ret)
         return NULL;
-    if (x) {
+    if (x != NULL) {
         EVP_PKEY_free(*x);
         *x = ret;
     }
diff --git a/crypto/pem/pem_pkey.c b/crypto/pem/pem_pkey.c
index 54596e4093..7132a7ad80 100644
--- a/crypto/pem/pem_pkey.c
+++ b/crypto/pem/pem_pkey.c
@@ -40,10 +40,10 @@ EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
     if (strcmp(nm, PEM_STRING_PKCS8INF) == 0) {
         PKCS8_PRIV_KEY_INFO *p8inf;
         p8inf = d2i_PKCS8_PRIV_KEY_INFO(NULL, &amp;p, len);
-        if (!p8inf)
+        if (p8inf == NULL)
             goto p8err;
         ret = EVP_PKCS82PKEY(p8inf);
-        if (x) {
+        if (x != NULL) {
             EVP_PKEY_free((EVP_PKEY *)*x);
             *x = ret;
         }
@@ -54,7 +54,7 @@ EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
         int klen;
         char psbuf[PEM_BUFSIZE];
         p8 = d2i_X509_SIG(NULL, &amp;p, len);
-        if (!p8)
+        if (p8 == NULL)
             goto p8err;
         if (cb)
             klen = cb(psbuf, PEM_BUFSIZE, 0, u);
@@ -68,7 +68,7 @@ EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
         p8inf = PKCS8_decrypt(p8, psbuf, klen);
         X509_SIG_free(p8);
         OPENSSL_cleanse(psbuf, klen);
-        if (!p8inf)
+        if (p8inf == NULL)
             goto p8err;
         ret = EVP_PKCS82PKEY(p8inf);
         if (x) {
diff --git a/crypto/pem/pvkfmt.c b/crypto/pem/pvkfmt.c
index adf2914433..6bcde93d6c 100644
--- a/crypto/pem/pvkfmt.c
+++ b/crypto/pem/pvkfmt.c
@@ -617,6 +617,7 @@ static int do_PVK_header(const unsigned char **in, unsigned int length,
 {
     const unsigned char *p = *in;
     unsigned int pvk_magic, is_encrypted;
+
     if (skip_magic) {
         if (length &lt; 20) {
             PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);
@@ -645,7 +646,7 @@ static int do_PVK_header(const unsigned char **in, unsigned int length,
     if (*pkeylen &gt; PVK_MAX_KEYLEN || *psaltlen &gt; PVK_MAX_SALTLEN)
         return 0;
 
-    if (is_encrypted &amp;&amp; !*psaltlen) {
+    if (is_encrypted &amp;&amp; *psaltlen == 0) {
         PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_INCONSISTENT_HEADER);
         return 0;
     }
diff --git a/crypto/pkcs12/p12_add.c b/crypto/pkcs12/p12_add.c
index f23bfed853..06837f537f 100644
--- a/crypto/pkcs12/p12_add.c
+++ b/crypto/pkcs12/p12_add.c
@@ -106,7 +106,7 @@ PKCS7 *PKCS12_pack_p7encdata(int pbe_nid, const char *pass, int passlen,
     else
         pbe = PKCS5_pbe_set(pbe_nid, iter, salt, saltlen);
 
-    if (!pbe) {
+    if (pbe == NULL) {
         PKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
diff --git a/crypto/pkcs12/p12_crpt.c b/crypto/pkcs12/p12_crpt.c
index b832e1a8f0..937bfea045 100644
--- a/crypto/pkcs12/p12_crpt.c
+++ b/crypto/pkcs12/p12_crpt.c
@@ -44,7 +44,7 @@ int PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
         return 0;
     }
 
-    if (!pbe-&gt;iter)
+    if (pbe-&gt;iter == NULL)
         iter = 1;
     else
         iter = ASN1_INTEGER_get(pbe-&gt;iter);
diff --git a/crypto/pkcs12/p12_crt.c b/crypto/pkcs12/p12_crt.c
index 063a5bb010..94bd3e1636 100644
--- a/crypto/pkcs12/p12_crt.c
+++ b/crypto/pkcs12/p12_crt.c
@@ -54,7 +54,7 @@ PKCS12 *PKCS12_create(const char *pass, const char *name, EVP_PKEY *pkey, X509 *
     if (!mac_iter)
         mac_iter = 1;
 
-    if (!pkey &amp;&amp; !cert &amp;&amp; !ca) {
+    if (pkey == NULL &amp;&amp; cert == NULL &amp;&amp; ca == NULL) {
         PKCS12err(PKCS12_F_PKCS12_CREATE, PKCS12_R_INVALID_NULL_ARGUMENT);
         return NULL;
     }
@@ -110,7 +110,7 @@ PKCS12 *PKCS12_create(const char *pass, const char *name, EVP_PKEY *pkey, X509 *
 
     p12 = PKCS12_add_safes(safes, 0);
 
-    if (!p12)
+    if (p12 == NULL)
         goto err;
 
     sk_PKCS7_pop_free(safes, PKCS7_free);
@@ -208,13 +208,12 @@ int PKCS12_add_safe(STACK_OF(PKCS7) **psafes, STACK_OF(PKCS12_SAFEBAG) *bags,
     PKCS7 *p7 = NULL;
     int free_safes = 0;
 
-    if (!*psafes) {
+    if (*psafes == NULL) {
         *psafes = sk_PKCS7_new_null();
-        if (!*psafes)
+        if (*psafes == NULL)
             return 0;
         free_safes = 1;
-    } else
-        free_safes = 0;
+    }
 
     if (nid_safe == 0)
 #ifdef OPENSSL_NO_RC2
@@ -227,7 +226,7 @@ int PKCS12_add_safe(STACK_OF(PKCS7) **psafes, STACK_OF(PKCS12_SAFEBAG) *bags,
         p7 = PKCS12_pack_p7data(bags);
     else
         p7 = PKCS12_pack_p7encdata(nid_safe, pass, -1, NULL, 0, iter, bags);
-    if (!p7)
+    if (p7 == NULL)
         goto err;
 
     if (!sk_PKCS7_push(*psafes, p7))
@@ -248,16 +247,16 @@ int PKCS12_add_safe(STACK_OF(PKCS7) **psafes, STACK_OF(PKCS12_SAFEBAG) *bags,
 static int pkcs12_add_bag(STACK_OF(PKCS12_SAFEBAG) **pbags,
                           PKCS12_SAFEBAG *bag)
 {
-    int free_bags;
-    if (!pbags)
+    int free_bags = 0;
+
+    if (pbags == NULL)
         return 1;
-    if (!*pbags) {
+    if (*pbags == NULL) {
         *pbags = sk_PKCS12_SAFEBAG_new_null();
-        if (!*pbags)
+        if (*pbags == NULL)
             return 0;
         free_bags = 1;
-    } else
-        free_bags = 0;
+    }
 
     if (!sk_PKCS12_SAFEBAG_push(*pbags, bag)) {
         if (free_bags) {
@@ -274,11 +273,11 @@ static int pkcs12_add_bag(STACK_OF(PKCS12_SAFEBAG) **pbags,
 PKCS12 *PKCS12_add_safes(STACK_OF(PKCS7) *safes, int nid_p7)
 {
     PKCS12 *p12;
+
     if (nid_p7 &lt;= 0)
         nid_p7 = NID_pkcs7_data;
     p12 = PKCS12_init(nid_p7);
-
-    if (!p12)
+    if (p12 == NULL)
         return NULL;
 
     if (!PKCS12_pack_authsafes(p12, safes)) {
diff --git a/crypto/pkcs12/p12_key.c b/crypto/pkcs12/p12_key.c
index 3580754a58..4849cbd5bc 100644
--- a/crypto/pkcs12/p12_key.c
+++ b/crypto/pkcs12/p12_key.c
@@ -26,7 +26,7 @@ int PKCS12_key_gen_asc(const char *pass, int passlen, unsigned char *salt,
     unsigned char *unipass;
     int uniplen;
 
-    if (!pass) {
+    if (pass == NULL) {
         unipass = NULL;
         uniplen = 0;
     } else if (!OPENSSL_asc2uni(pass, passlen, &amp;unipass, &amp;uniplen)) {
@@ -49,7 +49,7 @@ int PKCS12_key_gen_utf8(const char *pass, int passlen, unsigned char *salt,
     unsigned char *unipass;
     int uniplen;
 
-    if (!pass) {
+    if (pass == NULL) {
         unipass = NULL;
         uniplen = 0;
     } else if (!OPENSSL_utf82uni(pass, passlen, &amp;unipass, &amp;uniplen)) {
diff --git a/crypto/pkcs12/p12_kiss.c b/crypto/pkcs12/p12_kiss.c
index 7fa7488241..a9a3ff54f3 100644
--- a/crypto/pkcs12/p12_kiss.c
+++ b/crypto/pkcs12/p12_kiss.c
@@ -42,7 +42,7 @@ int PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,
 
     /* Check for NULL PKCS12 structure */
 
-    if (!p12) {
+    if (p12 == NULL) {
         PKCS12err(PKCS12_F_PKCS12_PARSE,
                   PKCS12_R_INVALID_NULL_PKCS12_POINTER);
         return 0;
@@ -57,7 +57,7 @@ int PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,
      * password are two different things...
      */
 
-    if (!pass || !*pass) {
+    if (pass == NULL || *pass == '\0') {
         if (PKCS12_verify_mac(p12, NULL, 0))
             pass = NULL;
         else if (PKCS12_verify_mac(p12, &quot;&quot;, 0))
@@ -85,7 +85,8 @@ int PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,
     }
 
     while ((x = sk_X509_pop(ocerts))) {
-        if (pkey &amp;&amp; *pkey &amp;&amp; cert &amp;&amp; !*cert) {
+        if (pkey != NULL &amp;&amp; *pkey != NULL
+                &amp;&amp; cert != NULL &amp;&amp; *cert == NULL) {
             ERR_set_mark();
             if (X509_check_private_key(x, *pkey)) {
                 *cert = x;
@@ -95,9 +96,9 @@ int PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,
         }
 
         if (ca &amp;&amp; x) {
-            if (!*ca)
+            if (*ca == NULL)
                 *ca = sk_X509_new_null();
-            if (!*ca)
+            if (*ca == NULL)
                 goto err;
             if (!sk_X509_push(*ca, x))
                 goto err;
@@ -191,7 +192,7 @@ static int parse_bag(PKCS12_SAFEBAG *bag, const char *pass, int passlen,
 
     switch (PKCS12_SAFEBAG_get_nid(bag)) {
     case NID_keyBag:
-        if (!pkey || *pkey)
+        if (pkey == NULL || *pkey != NULL)
             return 1;
         *pkey = EVP_PKCS82PKEY(PKCS12_SAFEBAG_get0_p8inf(bag));
         if (*pkey == NULL)
@@ -199,7 +200,7 @@ static int parse_bag(PKCS12_SAFEBAG *bag, const char *pass, int passlen,
         break;
 
     case NID_pkcs8ShroudedKeyBag:
-        if (!pkey || *pkey)
+        if (pkey == NULL || *pkey != NULL)
             return 1;
         if ((p8 = PKCS12_decrypt_skey(bag, pass, passlen)) == NULL)
             return 0;
diff --git a/crypto/pkcs12/p12_mutl.c b/crypto/pkcs12/p12_mutl.c
index 6998d32dcb..10e1c5b0fa 100644
--- a/crypto/pkcs12/p12_mutl.c
+++ b/crypto/pkcs12/p12_mutl.c
@@ -95,7 +95,7 @@ static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,
 
     salt = p12-&gt;mac-&gt;salt-&gt;data;
     saltlen = p12-&gt;mac-&gt;salt-&gt;length;
-    if (!p12-&gt;mac-&gt;iter)
+    if (p12-&gt;mac-&gt;iter == NULL)
         iter = 1;
     else
         iter = ASN1_INTEGER_get(p12-&gt;mac-&gt;iter);
diff --git a/crypto/pkcs12/p12_npas.c b/crypto/pkcs12/p12_npas.c
index eece1dd8f7..7c916d46cd 100644
--- a/crypto/pkcs12/p12_npas.c
+++ b/crypto/pkcs12/p12_npas.c
@@ -33,7 +33,7 @@ int PKCS12_newpass(PKCS12 *p12, const char *oldpass, const char *newpass)
 {
     /* Check for NULL PKCS12 structure */
 
-    if (!p12) {
+    if (p12 == NULL) {
         PKCS12err(PKCS12_F_PKCS12_NEWPASS,
                   PKCS12_R_INVALID_NULL_PKCS12_POINTER);
         return 0;
@@ -94,7 +94,7 @@ static int newpass_p12(PKCS12 *p12, const char *oldpass, const char *newpass)
         else
             p7new = PKCS12_pack_p7encdata(pbe_nid, newpass, -1, NULL,
                                           pbe_saltlen, pbe_iter, bags);
-        if (!p7new || !sk_PKCS7_push(newsafes, p7new))
+        if (p7new == NULL || !sk_PKCS7_push(newsafes, p7new))
             goto err;
         sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
         bags = NULL;
@@ -173,8 +173,9 @@ static int alg_get(const X509_ALGOR *alg, int *pnid, int *piter,
                    int *psaltlen)
 {
     PBEPARAM *pbe;
+
     pbe = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(PBEPARAM), alg-&gt;parameter);
-    if (!pbe)
+    if (pbe == NULL)
         return 0;
     *pnid = OBJ_obj2nid(alg-&gt;algorithm);
     *piter = ASN1_INTEGER_get(pbe-&gt;iter);
diff --git a/crypto/pkcs12/p12_p8e.c b/crypto/pkcs12/p12_p8e.c
index b9b34c2495..14df4fdea4 100644
--- a/crypto/pkcs12/p12_p8e.c
+++ b/crypto/pkcs12/p12_p8e.c
@@ -28,7 +28,7 @@ X509_SIG *PKCS8_encrypt(int pbe_nid, const EVP_CIPHER *cipher,
         ERR_clear_error();
         pbe = PKCS5_pbe_set(pbe_nid, iter, salt, saltlen);
     }
-    if (!pbe) {
+    if (pbe == NULL) {
         PKCS12err(PKCS12_F_PKCS8_ENCRYPT, ERR_R_ASN1_LIB);
         return NULL;
     }
diff --git a/crypto/pkcs7/pk7_doit.c b/crypto/pkcs7/pk7_doit.c
index 030718a1cb..2cf62b62cd 100644
--- a/crypto/pkcs7/pk7_doit.c
+++ b/crypto/pkcs7/pk7_doit.c
@@ -94,12 +94,11 @@ static int pkcs7_encode_rinfo(PKCS7_RECIP_INFO *ri,
     size_t eklen;
 
     pkey = X509_get0_pubkey(ri-&gt;cert);
-
-    if (!pkey)
+    if (pkey == NULL)
         return 0;
 
     pctx = EVP_PKEY_CTX_new(pkey, NULL);
-    if (!pctx)
+    if (pctx == NULL)
         return 0;
 
     if (EVP_PKEY_encrypt_init(pctx) &lt;= 0)
@@ -143,11 +142,10 @@ static int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,
     EVP_PKEY_CTX *pctx = NULL;
     unsigned char *ek = NULL;
     size_t eklen;
-
     int ret = -1;
 
     pctx = EVP_PKEY_CTX_new(pkey, NULL);
-    if (!pctx)
+    if (pctx == NULL)
         return -1;
 
     if (EVP_PKEY_decrypt_init(pctx) &lt;= 0)
@@ -1067,7 +1065,7 @@ int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
 
     os = si-&gt;enc_digest;
     pkey = X509_get0_pubkey(x509);
-    if (!pkey) {
+    if (pkey == NULL) {
         ret = -1;
         goto err;
     }
diff --git a/crypto/pkcs7/pk7_lib.c b/crypto/pkcs7/pk7_lib.c
index 815ac8683a..ca039656f0 100644
--- a/crypto/pkcs7/pk7_lib.c
+++ b/crypto/pkcs7/pk7_lib.c
@@ -40,7 +40,7 @@ long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg)
         break;
     case PKCS7_OP_GET_DETACHED_SIGNATURE:
         if (nid == NID_pkcs7_signed) {
-            if (!p7-&gt;d.sign || !p7-&gt;d.sign-&gt;contents-&gt;d.ptr)
+            if (p7-&gt;d.sign == NULL || p7-&gt;d.sign-&gt;contents-&gt;d.ptr == NULL)
                 ret = 1;
             else
                 ret = 0;
diff --git a/crypto/pkcs7/pk7_smime.c b/crypto/pkcs7/pk7_smime.c
index 6012e37e35..43ad266a6c 100644
--- a/crypto/pkcs7/pk7_smime.c
+++ b/crypto/pkcs7/pk7_smime.c
@@ -214,7 +214,7 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
     BIO *p7bio = NULL;
     BIO *tmpin = NULL, *tmpout = NULL;
 
-    if (!p7) {
+    if (p7 == NULL) {
         PKCS7err(PKCS7_F_PKCS7_VERIFY, PKCS7_R_INVALID_NULL_POINTER);
         return 0;
     }
@@ -379,7 +379,7 @@ STACK_OF(X509) *PKCS7_get0_signers(PKCS7 *p7, STACK_OF(X509) *certs,
     X509 *signer;
     int i;
 
-    if (!p7) {
+    if (p7 == NULL) {
         PKCS7err(PKCS7_F_PKCS7_GET0_SIGNERS, PKCS7_R_INVALID_NULL_POINTER);
         return NULL;
     }
@@ -480,7 +480,7 @@ int PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data, int flags)
     int ret = 0, i;
     char *buf = NULL;
 
-    if (!p7) {
+    if (p7 == NULL) {
         PKCS7err(PKCS7_F_PKCS7_DECRYPT, PKCS7_R_INVALID_NULL_POINTER);
         return 0;
     }
diff --git a/crypto/ts/ts_conf.c b/crypto/ts/ts_conf.c
index 403e098d28..4117ccdd87 100644
--- a/crypto/ts/ts_conf.c
+++ b/crypto/ts/ts_conf.c
@@ -283,9 +283,10 @@ int TS_CONF_set_def_policy(CONF *conf, const char *section,
 {
     int ret = 0;
     ASN1_OBJECT *policy_obj = NULL;
-    if (!policy)
+
+    if (policy == NULL)
         policy = NCONF_get_string(conf, section, ENV_DEFAULT_POLICY);
-    if (!policy) {
+    if (policy == NULL) {
         ts_CONF_lookup_fail(section, ENV_DEFAULT_POLICY);
         goto err;
     }
diff --git a/crypto/ts/ts_rsp_sign.c b/crypto/ts/ts_rsp_sign.c
index 9faa42fe3a..ed0979e584 100644
--- a/crypto/ts/ts_rsp_sign.c
+++ b/crypto/ts/ts_rsp_sign.c
@@ -505,7 +505,7 @@ static ASN1_OBJECT *ts_RESP_get_policy(TS_RESP_CTX *ctx)
         if (!OBJ_cmp(requested, current))
             policy = current;
     }
-    if (!policy) {
+    if (policy == NULL) {
         TSerr(TS_F_TS_RESP_GET_POLICY, TS_R_UNACCEPTABLE_POLICY);
         TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
                                     &quot;Requested policy is not &quot; &quot;supported.&quot;);
diff --git a/crypto/x509/by_dir.c b/crypto/x509/by_dir.c
index d38080fb0c..69950b7d61 100644
--- a/crypto/x509/by_dir.c
+++ b/crypto/x509/by_dir.c
@@ -156,7 +156,7 @@ static int add_cert_dir(BY_DIR *ctx, const char *dir, int type)
     size_t len;
     const char *s, *ss, *p;
 
-    if (dir == NULL || !*dir) {
+    if (dir == NULL || *dir == '\0') {
         X509err(X509_F_ADD_CERT_DIR, X509_R_INVALID_DIRECTORY);
         return 0;
     }
diff --git a/crypto/x509/v3_cpols.c b/crypto/x509/v3_cpols.c
index f9a239b6f2..e70ab61d50 100644
--- a/crypto/x509/v3_cpols.c
+++ b/crypto/x509/v3_cpols.c
@@ -124,8 +124,9 @@ static STACK_OF(POLICYINFO) *r2i_certpol(X509V3_EXT_METHOD *method,
             continue;
         } else if (*pstr == '@') {
             STACK_OF(CONF_VALUE) *polsect;
+
             polsect = X509V3_get_section(ctx, pstr + 1);
-            if (!polsect) {
+            if (polsect == NULL) {
                 X509V3err(X509V3_F_R2I_CERTPOL, X509V3_R_INVALID_SECTION);
 
                 X509V3_conf_err(cnf);
@@ -221,7 +222,7 @@ static POLICYINFO *policy_section(X509V3_CTX *ctx,
             X509V3_section_free(ctx, unot);
             if (!qual)
                 goto err;
-            if (!pol-&gt;qualifiers)
+            if (pol-&gt;qualifiers == NULL)
                 pol-&gt;qualifiers = sk_POLICYQUALINFO_new_null();
             if (!sk_POLICYQUALINFO_push(pol-&gt;qualifiers, qual))
                 goto merr;
@@ -232,7 +233,7 @@ static POLICYINFO *policy_section(X509V3_CTX *ctx,
             goto err;
         }
     }
-    if (!pol-&gt;policyid) {
+    if (pol-&gt;policyid == NULL) {
         X509V3err(X509V3_F_POLICY_SECTION, X509V3_R_NO_POLICY_IDENTIFIER);
         goto err;
     }
diff --git a/crypto/x509/v3_crld.c b/crypto/x509/v3_crld.c
index c3517b817c..4b60752ae8 100644
--- a/crypto/x509/v3_crld.c
+++ b/crypto/x509/v3_crld.c
@@ -168,7 +168,7 @@ static int set_reasons(ASN1_BIT_STRING **preas, char *value)
                 break;
             }
         }
-        if (!pbn-&gt;lname)
+        if (pbn-&gt;lname == NULL)
             goto err;
     }
     ret = 1;
@@ -222,7 +222,7 @@ static DIST_POINT *crldp_from_section(X509V3_CTX *ctx,
                 goto err;
         } else if (strcmp(cnf-&gt;name, &quot;CRLissuer&quot;) == 0) {
             point-&gt;CRLissuer = gnames_from_sectname(ctx, cnf-&gt;value);
-            if (!point-&gt;CRLissuer)
+            if (point-&gt;CRLissuer == NULL)
                 goto err;
         }
     }
@@ -258,7 +258,7 @@ static void *v2i_crld(const X509V3_EXT_METHOD *method,
                 goto err;
             point = crldp_from_section(ctx, dpsect);
             X509V3_section_free(ctx, dpsect);
-            if (!point)
+            if (point == NULL)
                 goto err;
             sk_DIST_POINT_push(crld, point); /* no failure as it was reserved */
         } else {
diff --git a/crypto/x509/v3_info.c b/crypto/x509/v3_info.c
index 0b97c9663f..c50cfd1f34 100644
--- a/crypto/x509/v3_info.c
+++ b/crypto/x509/v3_info.c
@@ -123,7 +123,7 @@ static AUTHORITY_INFO_ACCESS *v2i_AUTHORITY_INFO_ACCESS(X509V3_EXT_METHOD
         }
         sk_ACCESS_DESCRIPTION_push(ainfo, acc); /* Cannot fail due to reserve */
         ptmp = strchr(cnf-&gt;name, ';');
-        if (!ptmp) {
+        if (ptmp == NULL) {
             X509V3err(X509V3_F_V2I_AUTHORITY_INFO_ACCESS,
                       X509V3_R_INVALID_SYNTAX);
             goto err;
diff --git a/crypto/x509/v3_ncons.c b/crypto/x509/v3_ncons.c
index 3be0c05fce..927aa8f982 100644
--- a/crypto/x509/v3_ncons.c
+++ b/crypto/x509/v3_ncons.c
@@ -561,8 +561,9 @@ static int nc_dns(ASN1_IA5STRING *dns, ASN1_IA5STRING *base)
 {
     char *baseptr = (char *)base-&gt;data;
     char *dnsptr = (char *)dns-&gt;data;
+
     /* Empty matches everything */
-    if (!*baseptr)
+    if (*baseptr == '\0')
         return X509_V_OK;
     /*
      * Otherwise can add zero or more components on the left so compare RHS
@@ -628,8 +629,9 @@ static int nc_uri(ASN1_IA5STRING *uri, ASN1_IA5STRING *base)
     const char *hostptr = (char *)uri-&gt;data;
     const char *p = strchr(hostptr, ':');
     int hostlen;
+
     /* Check for <A HREF="foo://">foo://</A> and skip past it */
-    if (!p || (p[1] != '/') || (p[2] != '/'))
+    if (p == NULL || p[1] != '/' || p[2] != '/')
         return X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;
     hostptr = p + 3;
 
@@ -639,10 +641,10 @@ static int nc_uri(ASN1_IA5STRING *uri, ASN1_IA5STRING *base)
 
     p = strchr(hostptr, ':');
     /* Otherwise look for trailing slash */
-    if (!p)
+    if (p == NULL)
         p = strchr(hostptr, '/');
 
-    if (!p)
+    if (p == NULL)
         hostlen = strlen(hostptr);
     else
         hostlen = p - hostptr;
diff --git a/crypto/x509/v3_pci.c b/crypto/x509/v3_pci.c
index 856b70d9b5..fb5f35a5ab 100644
--- a/crypto/x509/v3_pci.c
+++ b/crypto/x509/v3_pci.c
@@ -116,7 +116,8 @@ static int process_pci_value(CONF_VALUE *val,
     } else if (strcmp(val-&gt;name, &quot;policy&quot;) == 0) {
         unsigned char *tmp_data = NULL;
         long val_len;
-        if (!*policy) {
+
+        if (*policy == NULL) {
             *policy = ASN1_OCTET_STRING_new();
             if (*policy == NULL) {
                 X509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_MALLOC_FAILURE);
diff --git a/crypto/x509/v3_pcons.c b/crypto/x509/v3_pcons.c
index e6d50a6fe7..33c08cfdaa 100644
--- a/crypto/x509/v3_pcons.c
+++ b/crypto/x509/v3_pcons.c
@@ -78,7 +78,8 @@ static void *v2i_POLICY_CONSTRAINTS(const X509V3_EXT_METHOD *method,
             goto err;
         }
     }
-    if (!pcons-&gt;inhibitPolicyMapping &amp;&amp; !pcons-&gt;requireExplicitPolicy) {
+    if (pcons-&gt;inhibitPolicyMapping == NULL
+            &amp;&amp; pcons-&gt;requireExplicitPolicy == NULL) {
         X509V3err(X509V3_F_V2I_POLICY_CONSTRAINTS,
                   X509V3_R_ILLEGAL_EMPTY_EXTENSION);
         goto err;
diff --git a/crypto/x509/v3_purp.c b/crypto/x509/v3_purp.c
index 3248e286ae..10fd0f73f3 100644
--- a/crypto/x509/v3_purp.c
+++ b/crypto/x509/v3_purp.c
@@ -178,7 +178,7 @@ int X509_PURPOSE_add(int id, int trust, int flags,
     /* dup supplied name */
     ptmp-&gt;name = OPENSSL_strdup(name);
     ptmp-&gt;sname = OPENSSL_strdup(sname);
-    if (!ptmp-&gt;name || !ptmp-&gt;sname) {
+    if (ptmp-&gt;name == NULL|| ptmp-&gt;sname == NULL) {
         X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);
         goto err;
     }
@@ -216,7 +216,7 @@ int X509_PURPOSE_add(int id, int trust, int flags,
 
 static void xptable_free(X509_PURPOSE *p)
 {
-    if (!p)
+    if (p == NULL)
         return;
     if (p-&gt;flags &amp; X509_PURPOSE_DYNAMIC) {
         if (p-&gt;flags &amp; X509_PURPOSE_DYNAMIC_NAME) {
diff --git a/crypto/x509/v3_sxnet.c b/crypto/x509/v3_sxnet.c
index ddb2a0312e..072b8efe82 100644
--- a/crypto/x509/v3_sxnet.c
+++ b/crypto/x509/v3_sxnet.c
@@ -139,7 +139,8 @@ int SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, const char *user,
 {
     SXNET *sx = NULL;
     SXNETID *id = NULL;
-    if (!psx || !zone || !user) {
+
+    if (psx == NULL || zone == NULL || user == NULL) {
         X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,
                   X509V3_R_INVALID_NULL_ARGUMENT);
         return 0;
diff --git a/crypto/x509/v3_utl.c b/crypto/x509/v3_utl.c
index 1516d988f0..50fa404996 100644
--- a/crypto/x509/v3_utl.c
+++ b/crypto/x509/v3_utl.c
@@ -380,14 +380,14 @@ static char *strip_spaces(char *name)
     p = name;
     while (*p &amp;&amp; ossl_isspace(*p))
         p++;
-    if (!*p)
+    if (*p == '\0')
         return NULL;
     q = p + strlen(p) - 1;
     while ((q != p) &amp;&amp; ossl_isspace(*q))
         q--;
     if (p != q)
         q[1] = 0;
-    if (!*p)
+    if (*p == '\0')
         return NULL;
     return p;
 }
@@ -989,11 +989,12 @@ ASN1_OCTET_STRING *a2i_IPADDRESS_NC(const char *ipasc)
     unsigned char ipout[32];
     char *iptmp = NULL, *p;
     int iplen1, iplen2;
+
     p = strchr(ipasc, '/');
-    if (!p)
+    if (p == NULL)
         return NULL;
     iptmp = OPENSSL_strdup(ipasc);
-    if (!iptmp)
+    if (iptmp == NULL)
         return NULL;
     p = iptmp + (p - ipasc);
     *p++ = 0;
diff --git a/crypto/x509/x509_trs.c b/crypto/x509/x509_trs.c
index b6a45acbcd..b077ba584f 100644
--- a/crypto/x509/x509_trs.c
+++ b/crypto/x509/x509_trs.c
@@ -184,7 +184,7 @@ int X509_TRUST_add(int id, int flags, int (*ck) (X509_TRUST *, X509 *, int),
 
 static void trtable_free(X509_TRUST *p)
 {
-    if (!p)
+    if (p == NULL)
         return;
     if (p-&gt;flags &amp; X509_TRUST_DYNAMIC) {
         if (p-&gt;flags &amp; X509_TRUST_DYNAMIC_NAME)
diff --git a/crypto/x509/x509_vfy.c b/crypto/x509/x509_vfy.c
index 126df99142..1e2e4cd557 100644
--- a/crypto/x509/x509_vfy.c
+++ b/crypto/x509/x509_vfy.c
@@ -2134,10 +2134,10 @@ int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
 {
     int idx;
     /* If purpose not set use default */
-    if (!purpose)
+    if (purpose == 0)
         purpose = def_purpose;
     /* If we have a purpose then check it is valid */
-    if (purpose) {
+    if (purpose != 0) {
         X509_PURPOSE *ptmp;
         idx = X509_PURPOSE_get_by_id(purpose);
         if (idx == -1) {
@@ -2502,8 +2502,9 @@ int X509_STORE_CTX_get_num_untrusted(X509_STORE_CTX *ctx)
 int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)
 {
     const X509_VERIFY_PARAM *param;
+
     param = X509_VERIFY_PARAM_lookup(name);
-    if (!param)
+    if (param == NULL)
         return 0;
     return X509_VERIFY_PARAM_inherit(ctx-&gt;param, param);
 }
diff --git a/crypto/x509/x509_vpm.c b/crypto/x509/x509_vpm.c
index 81a0ec997e..782fa136f2 100644
--- a/crypto/x509/x509_vpm.c
+++ b/crypto/x509/x509_vpm.c
@@ -332,9 +332,9 @@ void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t)
 int X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param,
                                   ASN1_OBJECT *policy)
 {
-    if (!param-&gt;policies) {
+    if (param-&gt;policies == NULL) {
         param-&gt;policies = sk_ASN1_OBJECT_new_null();
-        if (!param-&gt;policies)
+        if (param-&gt;policies == NULL)
             return 0;
     }
     if (!sk_ASN1_OBJECT_push(param-&gt;policies, policy))
@@ -348,17 +348,17 @@ int X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param,
     int i;
     ASN1_OBJECT *oid, *doid;
 
-    if (!param)
+    if (param == NULL)
         return 0;
     sk_ASN1_OBJECT_pop_free(param-&gt;policies, ASN1_OBJECT_free);
 
-    if (!policies) {
+    if (policies == NULL) {
         param-&gt;policies = NULL;
         return 1;
     }
 
     param-&gt;policies = sk_ASN1_OBJECT_new_null();
-    if (!param-&gt;policies)
+    if (param-&gt;policies == NULL)
         return 0;
 
     for (i = 0; i &lt; sk_ASN1_OBJECT_num(policies); i++) {
diff --git a/crypto/x509/x_all.c b/crypto/x509/x_all.c
index 43b29d3bc6..9517169b8b 100644
--- a/crypto/x509/x_all.c
+++ b/crypto/x509/x_all.c
@@ -607,8 +607,9 @@ int i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, const EVP_PKEY *key)
 {
     PKCS8_PRIV_KEY_INFO *p8inf;
     int ret;
+
     p8inf = EVP_PKEY2PKCS8(key);
-    if (!p8inf)
+    if (p8inf == NULL)
         return 0;
     ret = i2d_PKCS8_PRIV_KEY_INFO_fp(fp, p8inf);
     PKCS8_PRIV_KEY_INFO_free(p8inf);
@@ -654,8 +655,9 @@ int i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, const EVP_PKEY *key)
 {
     PKCS8_PRIV_KEY_INFO *p8inf;
     int ret;
+
     p8inf = EVP_PKEY2PKCS8(key);
-    if (!p8inf)
+    if (p8inf == NULL)
         return 0;
     ret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);
     PKCS8_PRIV_KEY_INFO_free(p8inf);
diff --git a/crypto/x509/x_name.c b/crypto/x509/x_name.c
index 33faacf5dd..59d6531bf8 100644
--- a/crypto/x509/x_name.c
+++ b/crypto/x509/x_name.c
@@ -114,7 +114,7 @@ static void x509_name_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)
 {
     X509_NAME *a;
 
-    if (!pval || !*pval)
+    if (pval == NULL || *pval == NULL)
         return;
     a = (X509_NAME *)*pval;
 
@@ -503,9 +503,9 @@ int X509_NAME_print(BIO *bp, const X509_NAME *name, int obase)
     l = 80 - 2 - obase;
 
     b = X509_NAME_oneline(name, NULL, 0);
-    if (!b)
+    if (b == NULL)
         return 0;
-    if (!*b) {
+    if (*b == '\0') {
         OPENSSL_free(b);
         return 1;
     }
diff --git a/crypto/x509/x_pubkey.c b/crypto/x509/x_pubkey.c
index 6e8540835f..44b08e8bdf 100644
--- a/crypto/x509/x_pubkey.c
+++ b/crypto/x509/x_pubkey.c
@@ -185,16 +185,17 @@ EVP_PKEY *d2i_PUBKEY(EVP_PKEY **a, const unsigned char **pp, long length)
     X509_PUBKEY *xpk;
     EVP_PKEY *pktmp;
     const unsigned char *q;
+
     q = *pp;
     xpk = d2i_X509_PUBKEY(NULL, &amp;q, length);
-    if (!xpk)
+    if (xpk == NULL)
         return NULL;
     pktmp = X509_PUBKEY_get(xpk);
     X509_PUBKEY_free(xpk);
-    if (!pktmp)
+    if (pktmp == NULL)
         return NULL;
     *pp = q;
-    if (a) {
+    if (a != NULL) {
         EVP_PKEY_free(*a);
         *a = pktmp;
     }
@@ -230,16 +231,17 @@ RSA *d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length)
     EVP_PKEY *pkey;
     RSA *key;
     const unsigned char *q;
+
     q = *pp;
     pkey = d2i_PUBKEY(NULL, &amp;q, length);
-    if (!pkey)
+    if (pkey == NULL)
         return NULL;
     key = EVP_PKEY_get1_RSA(pkey);
     EVP_PKEY_free(pkey);
-    if (!key)
+    if (key == NULL)
         return NULL;
     *pp = q;
-    if (a) {
+    if (a != NULL) {
         RSA_free(*a);
         *a = key;
     }
@@ -271,16 +273,17 @@ DSA *d2i_DSA_PUBKEY(DSA **a, const unsigned char **pp, long length)
     EVP_PKEY *pkey;
     DSA *key;
     const unsigned char *q;
+
     q = *pp;
     pkey = d2i_PUBKEY(NULL, &amp;q, length);
-    if (!pkey)
+    if (pkey == NULL)
         return NULL;
     key = EVP_PKEY_get1_DSA(pkey);
     EVP_PKEY_free(pkey);
-    if (!key)
+    if (key == NULL)
         return NULL;
     *pp = q;
-    if (a) {
+    if (a != NULL) {
         DSA_free(*a);
         *a = key;
     }
@@ -312,16 +315,17 @@ EC_KEY *d2i_EC_PUBKEY(EC_KEY **a, const unsigned char **pp, long length)
     EVP_PKEY *pkey;
     EC_KEY *key;
     const unsigned char *q;
+
     q = *pp;
     pkey = d2i_PUBKEY(NULL, &amp;q, length);
-    if (!pkey)
+    if (pkey == NULL)
         return NULL;
     key = EVP_PKEY_get1_EC_KEY(pkey);
     EVP_PKEY_free(pkey);
-    if (!key)
+    if (key == NULL)
         return NULL;
     *pp = q;
-    if (a) {
+    if (a != NULL) {
         EC_KEY_free(*a);
         *a = key;
     }
@@ -332,7 +336,8 @@ int i2d_EC_PUBKEY(const EC_KEY *a, unsigned char **pp)
 {
     EVP_PKEY *pktmp;
     int ret;
-    if (!a)
+
+    if (a == NULL)
         return 0;
     if ((pktmp = EVP_PKEY_new()) == NULL) {
         ASN1err(ASN1_F_I2D_EC_PUBKEY, ERR_R_MALLOC_FAILURE);
diff --git a/engines/e_capi.c b/engines/e_capi.c
index c3a8306ab1..74b79e31c6 100644
--- a/engines/e_capi.c
+++ b/engines/e_capi.c
@@ -1301,13 +1301,14 @@ static void capi_dump_prov_info(CAPI_CTX *ctx, BIO *out,
                                 CRYPT_KEY_PROV_INFO *pinfo)
 {
     char *provname = NULL, *contname = NULL;
-    if (!pinfo) {
+
+    if (pinfo == NULL) {
         BIO_printf(out, &quot;  No Private Key\n&quot;);
         return;
     }
     provname = wide_to_asc(pinfo-&gt;pwszProvName);
     contname = wide_to_asc(pinfo-&gt;pwszContainerName);
-    if (!provname || !contname)
+    if (provname == NULL || contname == NULL)
         goto err;
 
     BIO_printf(out, &quot;  Private Key Info:\n&quot;);
@@ -1777,7 +1778,7 @@ static int capi_load_ssl_client_cert(ENGINE *e, SSL *ssl,
 
     sk_X509_free(certs);
 
-    if (!*pcert)
+    if (*pcert == NULL)
         return 0;
 
     /* Setup key for selected certificate */
diff --git a/ssl/ssl_asn1.c b/ssl/ssl_asn1.c
index d2d23d5dc9..b5c6654e92 100644
--- a/ssl/ssl_asn1.c
+++ b/ssl/ssl_asn1.c
@@ -250,7 +250,7 @@ SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,
     if (as == NULL)
         goto err;
 
-    if (!a || !*a) {
+    if (a == NULL || *a == NULL) {
         ret = SSL_SESSION_new();
         if (ret == NULL)
             goto err;
diff --git a/ssl/ssl_conf.c b/ssl/ssl_conf.c
index 9ce1e187c4..40db39b2e1 100644
--- a/ssl/ssl_conf.c
+++ b/ssl/ssl_conf.c
@@ -427,7 +427,7 @@ static int cmd_Certificate(SSL_CONF_CTX *cctx, const char *value)
         char **pfilename = &amp;cctx-&gt;cert_filename[c-&gt;key - c-&gt;pkeys];
         OPENSSL_free(*pfilename);
         *pfilename = OPENSSL_strdup(value);
-        if (!*pfilename)
+        if (*pfilename == NULL)
             rv = 0;
     }
 
@@ -712,7 +712,7 @@ static const ssl_switch_tbl ssl_cmd_switches[] = {
 
 static int ssl_conf_cmd_skip_prefix(SSL_CONF_CTX *cctx, const char **pcmd)
 {
-    if (!pcmd || !*pcmd)
+    if (pcmd == NULL || *pcmd == NULL)
         return 0;
     /* If a prefix is set, check and skip */
     if (cctx-&gt;prefix) {
@@ -830,13 +830,14 @@ int SSL_CONF_cmd_argv(SSL_CONF_CTX *cctx, int *pargc, char ***pargv)
 {
     int rv;
     const char *arg = NULL, *argn;
-    if (pargc &amp;&amp; *pargc == 0)
+
+    if (pargc != NULL &amp;&amp; *pargc == 0)
         return 0;
-    if (!pargc || *pargc &gt; 0)
+    if (pargc == NULL || *pargc &gt; 0)
         arg = **pargv;
     if (arg == NULL)
         return 0;
-    if (!pargc || *pargc &gt; 1)
+    if (pargc == NULL || *pargc &gt; 1)
         argn = (*pargv)[1];
     else
         argn = NULL;
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index 120566d8e6..c481e292fc 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -2857,7 +2857,7 @@ void SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data,
                                     unsigned *len)
 {
     *data = s-&gt;ext.npn;
-    if (!*data) {
+    if (*data == NULL) {
         *len = 0;
     } else {
         *len = (unsigned int)s-&gt;ext.npn_len;
diff --git a/ssl/statem/statem_clnt.c b/ssl/statem/statem_clnt.c
index bb37e406c6..13610ba1b7 100644
--- a/ssl/statem/statem_clnt.c
+++ b/ssl/statem/statem_clnt.c
@@ -3183,7 +3183,7 @@ static int tls_construct_cke_gost(SSL *s, WPACKET *pkt)
      * Get server certificate PKEY and create ctx from it
      */
     peer_cert = s-&gt;session-&gt;peer;
-    if (!peer_cert) {
+    if (peer_cert == NULL) {
         SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_F_TLS_CONSTRUCT_CKE_GOST,
                SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);
         return 0;
diff --git a/test/handshake_helper.c b/test/handshake_helper.c
index c2528b9e1e..e8249a7ce2 100644
--- a/test/handshake_helper.c
+++ b/test/handshake_helper.c
@@ -877,7 +877,7 @@ static void do_app_data_step(PEER *peer)
      * to read gives us somewhat better guarantees that all data sent is in fact
      * received.
      */
-    if (!peer-&gt;bytes_to_write &amp;&amp; !peer-&gt;bytes_to_read) {
+    if (peer-&gt;bytes_to_write == 0 &amp;&amp; peer-&gt;bytes_to_read == 0) {
         peer-&gt;status = PEER_SUCCESS;
     }
 }
diff --git a/test/testutil/stanza.c b/test/testutil/stanza.c
index e28362025a..ba62f84517 100644
--- a/test/testutil/stanza.c
+++ b/test/testutil/stanza.c
@@ -72,7 +72,7 @@ static char *strip_spaces(char *p)
     /* Skip over leading spaces */
     while (*p &amp;&amp; isspace((unsigned char)*p))
         p++;
-    if (!*p)
+    if (*p == '\0')
         return NULL;
 
     for (q = p + strlen(p) - 1; q != p &amp;&amp; isspace((unsigned char)*q); )
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="025554.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="025561.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25557">[ date ]</a>
              <a href="thread.html#25557">[ thread ]</a>
              <a href="subject.html#25557">[ subject ]</a>
              <a href="author.html#25557">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
