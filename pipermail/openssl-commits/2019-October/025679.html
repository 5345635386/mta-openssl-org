<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-October/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1571296694.298558.17003.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025678.html">
   <LINK REL="Next"  HREF="025680.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1571296694.298558.17003.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Thu Oct 17 07:18:14 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="025678.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="025680.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25679">[ date ]</a>
              <a href="thread.html#25679">[ thread ]</a>
              <a href="subject.html#25679">[ subject ]</a>
              <a href="author.html#25679">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  5f5edd7d3eb20c39177b9fa6422f1db57634e9e3 (commit)
       via  4dc0d81a1a7b58a0a61102d875eb2cb712fe6a4b (commit)
       via  031873fe03610aa191031b5a36089bc29c67db29 (commit)
       via  506cb0f6322b24c980273ff5cd8f2c973a12b42f (commit)
       via  f651c727f85813085355bb207cf913288108ed79 (commit)
       via  251e610ce4479913e593f9f7a9a711115e6cf1a3 (commit)
       via  ee2161e8a6174a06c9f4efe6bfc0b76b2eda46fa (commit)
      from  d6d74cf4a44f08ed63d942b103198a1e3294295a (commit)


- Log -----------------------------------------------------------------
commit 5f5edd7d3eb20c39177b9fa6422f1db57634e9e3
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon Oct 14 16:28:29 2019 +0200

    Rename internal function name_cmp() to v3_name_cmp()
    
    &quot;name_cmp&quot; caused a clash when linking with the static libcrypto.
    The slight rename is better than nothing, as v3_ is an already existing
    prefix.
    
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9979">https://github.com/openssl/openssl/pull/9979</A>)

commit 4dc0d81a1a7b58a0a61102d875eb2cb712fe6a4b
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Sep 24 03:42:18 2019 +0200

    evp_generic_do_all(): fix passing of method data
    
    Method data was passed down as provider to ossl_algorithm_do_all(),
    which causes trouble as soon a it's non-NULL.  Pass it via the data
    structure instead.
    
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9979">https://github.com/openssl/openssl/pull/9979</A>)

commit 031873fe03610aa191031b5a36089bc29c67db29
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon Sep 23 11:30:05 2019 +0200

    'openssl list' and 'openssl provider': adapt display of multiple names
    
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9979">https://github.com/openssl/openssl/pull/9979</A>)

commit 506cb0f6322b24c980273ff5cd8f2c973a12b42f
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon Sep 23 11:16:21 2019 +0200

    EVP: add functions that return the name number
    
    The returned number can be used for comparison purposes.
    
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9979">https://github.com/openssl/openssl/pull/9979</A>)

commit f651c727f85813085355bb207cf913288108ed79
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon Sep 23 10:56:13 2019 +0200

    EVP: add name traversal functions to all fetchable types
    
    The following new functions all do the same thing; they traverse
    the set of names assigned to implementations of each algorithm type:
    
    EVP_MD_names_do_all(), EVP_CIPHER_names_do_all(),
    EVP_MAC_names_do_all(), EVP_KEYMGMT_names_do_all(),
    EVP_KEYEXCH_names_do_all(), EVP_KDF_names_do_all(),
    EVP_SIGNATURE_names_do_all()
    
    We add a warning to the documentation of EVP_CIPHER_name() and
    EVP_MD_name(), as they aren't suitable to use with multiple-name
    implementation.
    
    We also remove EVP_MAC_name() and evp_KDF_name(), as they serve no
    useful purpose.
    
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9979">https://github.com/openssl/openssl/pull/9979</A>)

commit 251e610ce4479913e593f9f7a9a711115e6cf1a3
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon Sep 23 10:33:26 2019 +0200

    EVP: add missing common functionality
    
    This adds the missing functions that should be common for all
    fetchable EVP sub-APIs:
    
    EVP_KEYMGMT_is_a(), EVP_KEYMGMT_do_all_provided(), EVP_KEYEXCH_is_a(),
    EVP_KEYEXCH_do_all_provided(), EVP_KDF_is_a(), EVP_MD_is_a(),
    EVP_SIGNATURE_do_all_provided(), EVP_SIGNATURE_is_a().
    
    This also renames EVP_MD_do_all_ex(), EVP_CIPHER_do_all_ex(),
    EVP_KDF_do_all_ex(), EVP_MAC_do_all_ex() to change '_ex'
    to '_provided'.
    
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9979">https://github.com/openssl/openssl/pull/9979</A>)

commit ee2161e8a6174a06c9f4efe6bfc0b76b2eda46fa
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon Sep 23 10:17:19 2019 +0200

    Some docs cleanup
    
    Clean up a few manual pages that we're about to touch, according to
    conventions found in Linux' man-pages(7); function arguments in
    descriptions should be in italics, and types, macros and similar
    should be in bold, with the exception for NULL.
    
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9979">https://github.com/openssl/openssl/pull/9979</A>)

-----------------------------------------------------------------------

Summary of changes:
 apps/include/names.h            |  17 ++++++
 apps/lib/build.info             |   2 +-
 apps/lib/names.c                |  48 +++++++++++++++
 apps/list.c                     |  65 +++++++++++++++------
 apps/provider.c                 | 125 ++++++++++++++++++++++++++++++++--------
 crypto/evp/digest.c             |   8 +--
 crypto/evp/evp_enc.c            |   8 +--
 crypto/evp/evp_fetch.c          |  12 ++--
 crypto/evp/evp_lib.c            |  31 ++++++++++
 crypto/evp/evp_local.h          |   6 +-
 crypto/evp/exchange.c           |  32 ++++++++++
 crypto/evp/kdf_lib.c            |  17 +++++-
 crypto/evp/kdf_meth.c           |   6 +-
 crypto/evp/keymgmt_meth.c       |  27 +++++++++
 crypto/evp/mac_lib.c            |  18 ++++++
 crypto/evp/mac_meth.c           |  16 +----
 crypto/evp/pmeth_fn.c           |  34 +++++++++++
 crypto/x509/ext_dat.h           |   2 +-
 crypto/x509/v3_addr.c           |   8 +--
 crypto/x509/v3_alt.c            |  20 +++----
 crypto/x509/v3_asid.c           |   4 +-
 crypto/x509/v3_cpols.c          |   4 +-
 crypto/x509/v3_utl.c            |   2 +-
 doc/man1/openssl-list.pod       |  57 ++++++++++--------
 doc/man3/EVP_DigestInit.pod     |  36 +++++++++---
 doc/man3/EVP_EncryptInit.pod    |  29 +++++++---
 doc/man3/EVP_KDF.pod            |  52 ++++++++++-------
 doc/man3/EVP_KEYEXCH_free.pod   |  37 ++++++++++--
 doc/man3/EVP_KEYMGMT.pod        |  33 ++++++++++-
 doc/man3/EVP_MAC.pod            |  34 ++++++-----
 doc/man3/EVP_SIGNATURE_free.pod |  26 ++++++++-
 include/openssl/evp.h           |  57 ++++++++++++++----
 include/openssl/kdf.h           |  12 ++--
 test/evp_test.c                 |   7 ++-
 util/libcrypto.num              |  34 +++++++++--
 35 files changed, 727 insertions(+), 199 deletions(-)
 create mode 100644 apps/include/names.h
 create mode 100644 apps/lib/names.c

diff --git a/apps/include/names.h b/apps/include/names.h
new file mode 100644
index 0000000000..f4d6f6a9a3
--- /dev/null
+++ b/apps/include/names.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/safestack.h&gt;
+
+/* Standard comparing function for names */
+int name_cmp(const char * const *a, const char * const *b);
+/* collect_names is meant to be used with EVP_{type}_doall_names */
+void collect_names(const char *name, void *vdata);
+/* Sorts and prints a stack of names to |out| */
+void print_names(BIO *out, STACK_OF(OPENSSL_CSTRING) *names);
diff --git a/apps/lib/build.info b/apps/lib/build.info
index f92d4dafc6..0c24d76d3c 100644
--- a/apps/lib/build.info
+++ b/apps/lib/build.info
@@ -9,7 +9,7 @@ ENDIF
 
 # Source for libapps
 $LIBAPPSSRC=apps.c apps_ui.c opt.c fmt.c s_cb.c s_socket.c app_rand.c \
-        bf_prefix.c columns.c app_params.c
+        bf_prefix.c columns.c app_params.c names.c
 
 IF[{- !$disabled{apps} -}]
   LIBS{noinst}=../libapps.a
diff --git a/apps/lib/names.c b/apps/lib/names.c
new file mode 100644
index 0000000000..09ee16fd37
--- /dev/null
+++ b/apps/lib/names.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;string.h&gt;
+#include &lt;openssl/bio.h&gt;
+#include &lt;openssl/safestack.h&gt;
+#include &quot;names.h&quot;
+
+#ifdef _WIN32
+# define strcasecmp _stricmp
+#endif
+
+int name_cmp(const char * const *a, const char * const *b)
+{
+    return strcasecmp(*a, *b);
+}
+
+void collect_names(const char *name, void *vdata)
+{
+    STACK_OF(OPENSSL_CSTRING) *names = vdata;
+
+    sk_OPENSSL_CSTRING_push(names, name);
+}
+
+void print_names(BIO *out, STACK_OF(OPENSSL_CSTRING) *names)
+{
+    int i = sk_OPENSSL_CSTRING_num(names);
+    int j;
+
+    sk_OPENSSL_CSTRING_sort(names);
+    if (i &gt; 1)
+        BIO_printf(out, &quot;{ &quot;);
+    for (j = 0; j &lt; i; j++) {
+        const char *name = sk_OPENSSL_CSTRING_value(names, j);
+
+        if (j &gt; 0)
+            BIO_printf(out, &quot;, &quot;);
+        BIO_printf(out, &quot;%s&quot;, name);
+    }
+    if (i &gt; 1)
+        BIO_printf(out, &quot; }&quot;);
+}
diff --git a/apps/list.c b/apps/list.c
index 1a43e43c56..2e8867df20 100644
--- a/apps/list.c
+++ b/apps/list.c
@@ -17,6 +17,7 @@
 #include &quot;app_params.h&quot;
 #include &quot;progs.h&quot;
 #include &quot;opt.h&quot;
+#include &quot;names.h&quot;
 
 static int verbose = 0;
 
@@ -38,7 +39,7 @@ DEFINE_STACK_OF(EVP_CIPHER)
 static int cipher_cmp(const EVP_CIPHER * const *a,
                       const EVP_CIPHER * const *b)
 {
-    int ret = strcasecmp(EVP_CIPHER_name(*a), EVP_CIPHER_name(*b));
+    int ret = EVP_CIPHER_number(*a) - EVP_CIPHER_number(*b);
 
     if (ret == 0)
         ret = strcmp(OSSL_PROVIDER_name(EVP_CIPHER_provider(*a)),
@@ -64,14 +65,22 @@ static void list_ciphers(void)
     EVP_CIPHER_do_all_sorted(legacy_cipher_fn, bio_out);
 
     BIO_printf(bio_out, &quot;Provided:\n&quot;);
-    EVP_CIPHER_do_all_ex(NULL, collect_ciphers, ciphers);
+    EVP_CIPHER_do_all_provided(NULL, collect_ciphers, ciphers);
     sk_EVP_CIPHER_sort(ciphers);
     for (i = 0; i &lt; sk_EVP_CIPHER_num(ciphers); i++) {
         const EVP_CIPHER *c = sk_EVP_CIPHER_value(ciphers, i);
+        STACK_OF(OPENSSL_CSTRING) *names =
+            sk_OPENSSL_CSTRING_new(name_cmp);
 
-        BIO_printf(bio_out, &quot;  %s&quot;, EVP_CIPHER_name(c));
+        EVP_CIPHER_names_do_all(c, collect_names, names);
+
+        BIO_printf(bio_out, &quot;  &quot;);
+        print_names(bio_out, names);
         BIO_printf(bio_out, &quot; @ %s\n&quot;,
                    OSSL_PROVIDER_name(EVP_CIPHER_provider(c)));
+
+        sk_OPENSSL_CSTRING_free(names);
+
         if (verbose) {
             print_param_types(&quot;retrievable algorithm parameters&quot;,
                               EVP_CIPHER_gettable_params(c), 4);
@@ -101,7 +110,7 @@ static void list_md_fn(const EVP_MD *m,
 DEFINE_STACK_OF(EVP_MD)
 static int md_cmp(const EVP_MD * const *a, const EVP_MD * const *b)
 {
-    int ret = strcasecmp(EVP_MD_name(*a), EVP_MD_name(*b));
+    int ret = EVP_MD_number(*a) - EVP_MD_number(*b);
 
     if (ret == 0)
         ret = strcmp(OSSL_PROVIDER_name(EVP_MD_provider(*a)),
@@ -127,14 +136,22 @@ static void list_digests(void)
     EVP_MD_do_all_sorted(list_md_fn, bio_out);
 
     BIO_printf(bio_out, &quot;Provided:\n&quot;);
-    EVP_MD_do_all_ex(NULL, collect_digests, digests);
+    EVP_MD_do_all_provided(NULL, collect_digests, digests);
     sk_EVP_MD_sort(digests);
     for (i = 0; i &lt; sk_EVP_MD_num(digests); i++) {
         const EVP_MD *m = sk_EVP_MD_value(digests, i);
+        STACK_OF(OPENSSL_CSTRING) *names =
+            sk_OPENSSL_CSTRING_new(name_cmp);
 
-        BIO_printf(bio_out, &quot;  %s&quot;, EVP_MD_name(m));
+        EVP_MD_names_do_all(m, collect_names, names);
+
+        BIO_printf(bio_out, &quot;  &quot;);
+        print_names(bio_out, names);
         BIO_printf(bio_out, &quot; @ %s\n&quot;,
                    OSSL_PROVIDER_name(EVP_MD_provider(m)));
+
+        sk_OPENSSL_CSTRING_free(names);
+
         if (verbose) {
             print_param_types(&quot;retrievable algorithm parameters&quot;,
                               EVP_MD_gettable_params(m), 4);
@@ -150,7 +167,7 @@ static void list_digests(void)
 DEFINE_STACK_OF(EVP_MAC)
 static int mac_cmp(const EVP_MAC * const *a, const EVP_MAC * const *b)
 {
-    int ret = strcasecmp(EVP_MAC_name(*a), EVP_MAC_name(*b));
+    int ret = EVP_MAC_number(*a) - EVP_MAC_number(*b);
 
     if (ret == 0)
         ret = strcmp(OSSL_PROVIDER_name(EVP_MAC_provider(*a)),
@@ -173,15 +190,22 @@ static void list_macs(void)
     int i;
 
     BIO_printf(bio_out, &quot;Provided MACs:\n&quot;);
-    EVP_MAC_do_all_ex(NULL, collect_macs, macs);
+    EVP_MAC_do_all_provided(NULL, collect_macs, macs);
     sk_EVP_MAC_sort(macs);
     for (i = 0; i &lt; sk_EVP_MAC_num(macs); i++) {
         const EVP_MAC *m = sk_EVP_MAC_value(macs, i);
+        STACK_OF(OPENSSL_CSTRING) *names =
+            sk_OPENSSL_CSTRING_new(name_cmp);
+
+        EVP_MAC_names_do_all(m, collect_names, names);
 
-        BIO_printf(bio_out, &quot;  %s&quot;, EVP_MAC_name(m));
+        BIO_printf(bio_out, &quot;  &quot;);
+        print_names(bio_out, names);
         BIO_printf(bio_out, &quot; @ %s\n&quot;,
                    OSSL_PROVIDER_name(EVP_MAC_provider(m)));
 
+        sk_OPENSSL_CSTRING_free(names);
+
         if (verbose) {
             print_param_types(&quot;retrievable algorithm parameters&quot;,
                               EVP_MAC_gettable_params(m), 4);
@@ -200,7 +224,7 @@ static void list_macs(void)
 DEFINE_STACK_OF(EVP_KDF)
 static int kdf_cmp(const EVP_KDF * const *a, const EVP_KDF * const *b)
 {
-    int ret = strcasecmp(EVP_KDF_name(*a), EVP_KDF_name(*b));
+    int ret = EVP_KDF_number(*a) - EVP_KDF_number(*b);
 
     if (ret == 0)
         ret = strcmp(OSSL_PROVIDER_name(EVP_KDF_provider(*a)),
@@ -223,22 +247,29 @@ static void list_kdfs(void)
     int i;
 
     BIO_printf(bio_out, &quot;Provided KDFs and PDFs:\n&quot;);
-    EVP_KDF_do_all_ex(NULL, collect_kdfs, kdfs);
+    EVP_KDF_do_all_provided(NULL, collect_kdfs, kdfs);
     sk_EVP_KDF_sort(kdfs);
     for (i = 0; i &lt; sk_EVP_KDF_num(kdfs); i++) {
-        const EVP_KDF *m = sk_EVP_KDF_value(kdfs, i);
+        const EVP_KDF *k = sk_EVP_KDF_value(kdfs, i);
+        STACK_OF(OPENSSL_CSTRING) *names =
+            sk_OPENSSL_CSTRING_new(name_cmp);
 
-        BIO_printf(bio_out, &quot;  %s&quot;, EVP_KDF_name(m));
+        EVP_KDF_names_do_all(k, collect_names, names);
+
+        BIO_printf(bio_out, &quot;  &quot;);
+        print_names(bio_out, names);
         BIO_printf(bio_out, &quot; @ %s\n&quot;,
-                   OSSL_PROVIDER_name(EVP_KDF_provider(m)));
+                   OSSL_PROVIDER_name(EVP_KDF_provider(k)));
+
+        sk_OPENSSL_CSTRING_free(names);
 
         if (verbose) {
             print_param_types(&quot;retrievable algorithm parameters&quot;,
-                              EVP_KDF_gettable_params(m), 4);
+                              EVP_KDF_gettable_params(k), 4);
             print_param_types(&quot;retrievable operation parameters&quot;,
-                              EVP_KDF_gettable_ctx_params(m), 4);
+                              EVP_KDF_gettable_ctx_params(k), 4);
             print_param_types(&quot;settable operation parameters&quot;,
-                              EVP_KDF_settable_ctx_params(m), 4);
+                              EVP_KDF_settable_ctx_params(k), 4);
         }
     }
     sk_EVP_KDF_pop_free(kdfs, EVP_KDF_free);
diff --git a/apps/provider.c b/apps/provider.c
index ab91e68f43..325a7424cd 100644
--- a/apps/provider.c
+++ b/apps/provider.c
@@ -12,6 +12,7 @@
 #include &quot;apps.h&quot;
 #include &quot;app_params.h&quot;
 #include &quot;progs.h&quot;
+#include &quot;names.h&quot;
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/safestack.h&gt;
@@ -40,7 +41,7 @@ typedef struct info_st INFO;
 typedef struct meta_st META;
 
 struct info_st {
-    const char *name;
+    void (*collect_names_fn)(void *method, STACK_OF(OPENSSL_CSTRING) *names);
     void *method;
     const OSSL_PARAM *gettable_params;
     const OSSL_PARAM *gettable_ctx_params;
@@ -58,11 +59,58 @@ struct meta_st {
     void (*fn)(META *meta, INFO *info);
 };
 
+static void collect_cipher_names(void *method,
+                                 STACK_OF(OPENSSL_CSTRING) *names)
+{
+    EVP_CIPHER_names_do_all(method, collect_names, names);
+}
+
+static void collect_digest_names(void *method,
+                                 STACK_OF(OPENSSL_CSTRING) *names)
+{
+    EVP_MD_names_do_all(method, collect_names, names);
+}
+
+static void collect_mac_names(void *method,
+                              STACK_OF(OPENSSL_CSTRING) *names)
+{
+    EVP_MAC_names_do_all(method, collect_names, names);
+}
+
+static void collect_keymgmt_names(void *method,
+                                  STACK_OF(OPENSSL_CSTRING) *names)
+{
+    EVP_KEYMGMT_names_do_all(method, collect_names, names);
+}
+
+static void collect_keyexch_names(void *method,
+                                  STACK_OF(OPENSSL_CSTRING) *names)
+{
+    EVP_KEYEXCH_names_do_all(method, collect_names, names);
+}
+
+static void collect_signature_names(void *method,
+                                  STACK_OF(OPENSSL_CSTRING) *names)
+{
+    EVP_SIGNATURE_names_do_all(method, collect_names, names);
+}
+
+static void print_method_names(BIO *out, INFO *info)
+{
+    STACK_OF(OPENSSL_CSTRING) *names = sk_OPENSSL_CSTRING_new(name_cmp);
+
+    info-&gt;collect_names_fn(info-&gt;method, names);
+    print_names(out, names);
+    sk_OPENSSL_CSTRING_free(names);
+}
+
 static void print_caps(META *meta, INFO *info)
 {
     switch (meta-&gt;verbose) {
     case 1:
-        BIO_printf(bio_out, meta-&gt;first ? &quot;%s&quot; : &quot; %s&quot;, info-&gt;name);
+        if (!meta-&gt;first)
+            BIO_printf(bio_out, &quot;; &quot;);
+        print_method_names(bio_out, info);
         break;
     case 2:
         if (meta-&gt;first) {
@@ -70,12 +118,14 @@ static void print_caps(META *meta, INFO *info)
                 BIO_printf(bio_out, &quot;\n&quot;);
             BIO_printf(bio_out, &quot;%*s%ss:&quot;, meta-&gt;indent, &quot;&quot;, meta-&gt;label);
         }
-        BIO_printf(bio_out, &quot; %s&quot;, info-&gt;name);
+        BIO_printf(bio_out, &quot; &quot;);
+        print_method_names(bio_out, info);
         break;
     case 3:
     default:
-        BIO_printf(bio_out, &quot;%*s%s %s\n&quot;, meta-&gt;indent, &quot;&quot;, meta-&gt;label,
-                   info-&gt;name);
+        BIO_printf(bio_out, &quot;%*s%s &quot;, meta-&gt;indent, &quot;&quot;, meta-&gt;label);
+        print_method_names(bio_out, info);
+        BIO_printf(bio_out, &quot;\n&quot;);
         print_param_types(&quot;retrievable algorithm parameters&quot;,
                           info-&gt;gettable_params, meta-&gt;subindent);
         print_param_types(&quot;retrievable operation parameters&quot;,
@@ -87,7 +137,9 @@ static void print_caps(META *meta, INFO *info)
     meta-&gt;first = 0;
 }
 
-static void do_method(void *method, const char *name,
+static void do_method(void *method,
+                      void (*collect_names_fn)(void *method,
+                                               STACK_OF(OPENSSL_CSTRING) *names),
                       const OSSL_PARAM *gettable_params,
                       const OSSL_PARAM *gettable_ctx_params,
                       const OSSL_PARAM *settable_ctx_params,
@@ -95,7 +147,7 @@ static void do_method(void *method, const char *name,
 {
     INFO info;
 
-    info.name = name;
+    info.collect_names_fn = collect_names_fn;
     info.method = method;
     info.gettable_params = gettable_params;
     info.gettable_ctx_params = gettable_ctx_params;
@@ -106,7 +158,7 @@ static void do_method(void *method, const char *name,
 
 static void do_cipher(EVP_CIPHER *cipher, void *meta)
 {
-    do_method(cipher, EVP_CIPHER_name(cipher),
+    do_method(cipher, collect_cipher_names,
               EVP_CIPHER_gettable_params(cipher),
               EVP_CIPHER_gettable_ctx_params(cipher),
               EVP_CIPHER_settable_ctx_params(cipher),
@@ -115,7 +167,7 @@ static void do_cipher(EVP_CIPHER *cipher, void *meta)
 
 static void do_digest(EVP_MD *digest, void *meta)
 {
-    do_method(digest, EVP_MD_name(digest),
+    do_method(digest, collect_digest_names,
               EVP_MD_gettable_params(digest),
               EVP_MD_gettable_ctx_params(digest),
               EVP_MD_settable_ctx_params(digest),
@@ -124,35 +176,60 @@ static void do_digest(EVP_MD *digest, void *meta)
 
 static void do_mac(EVP_MAC *mac, void *meta)
 {
-    do_method(mac, EVP_MAC_name(mac),
+    do_method(mac, collect_mac_names,
               EVP_MAC_gettable_params(mac),
               EVP_MAC_gettable_ctx_params(mac),
               EVP_MAC_settable_ctx_params(mac),
               meta);
 }
 
+static void do_keymgmt(EVP_KEYMGMT *keymgmt, void *meta)
+{
+    do_method(keymgmt, collect_keymgmt_names,
 /*
  * TODO(3.0) Enable when KEYMGMT and KEYEXCH have gettables and settables
  */
 #if 0
-static void do_keymgmt(EVP_KEYMGMT *keymgmt, void *meta)
-{
-    do_method(keymgmt, EVP_KEYMGMT_name(keymgmt),
               EVP_KEYMGMT_gettable_params(keymgmt),
               EVP_KEYMGMT_gettable_ctx_params(keymgmt),
               EVP_KEYMGMT_settable_ctx_params(keymgmt),
+#else
+              NULL, NULL, NULL,
+#endif
               meta);
 }
 
 static void do_keyexch(EVP_KEYEXCH *keyexch, void *meta)
 {
-    do_method(keyexch, EVP_KEYEXCH_name(keyexch),
+    do_method(keyexch, collect_keyexch_names,
+/*
+ * TODO(3.0) Enable when KEYMGMT and KEYEXCH have gettables and settables
+ */
+#if 0
               EVP_KEYEXCH_gettable_params(keyexch),
               EVP_KEYEXCH_gettable_ctx_params(keyexch),
               EVP_KEYEXCH_settable_ctx_params(keyexch),
+#else
+              NULL, NULL, NULL,
+#endif
               meta);
 }
+
+static void do_signature(EVP_SIGNATURE *signature, void *meta)
+{
+    do_method(signature, collect_signature_names,
+/*
+ * TODO(3.0) Enable when KEYMGMT and SIGNATURE have gettables and settables
+ */
+#if 0
+              EVP_SIGNATURE_gettable_params(signature),
+              EVP_SIGNATURE_gettable_ctx_params(signature),
+              EVP_SIGNATURE_settable_ctx_params(signature),
+#else
+              NULL, NULL, NULL,
 #endif
+              meta);
+}
 
 int provider_main(int argc, char **argv)
 {
@@ -231,33 +308,33 @@ int provider_main(int argc, char **argv)
                     data.first = 1;
                     data.label = &quot;Cipher&quot;;
                 }
-                EVP_CIPHER_do_all_ex(NULL, do_cipher, &amp;data);
+                EVP_CIPHER_do_all_provided(NULL, do_cipher, &amp;data);
                 if (verbose &gt; 1) {
                     data.first = 1;
                     data.label = &quot;Digest&quot;;
                 }
-                EVP_MD_do_all_ex(NULL, do_digest, &amp;data);
+                EVP_MD_do_all_provided(NULL, do_digest, &amp;data);
                 if (verbose &gt; 1) {
                     data.first = 1;
                     data.label = &quot;MAC&quot;;
                 }
-                EVP_MAC_do_all_ex(NULL, do_mac, &amp;data);
+                EVP_MAC_do_all_provided(NULL, do_mac, &amp;data);
 
-/*
- * TODO(3.0) Enable when KEYMGMT and KEYEXCH have do_all_ex functions
- */
-#if 0
                 if (verbose &gt; 1) {
                     data.first = 1;
                     data.label = &quot;Key manager&quot;;
                 }
-                EVP_KEYMGMT_do_all_ex(NULL, do_keymgmt, &amp;data);
+                EVP_KEYMGMT_do_all_provided(NULL, do_keymgmt, &amp;data);
                 if (verbose &gt; 1) {
                     data.first = 1;
                     data.label = &quot;Key exchange&quot;;
                 }
-                EVP_KEYEXCH_do_all_ex(NULL, do_keyexch, &amp;data);
-#endif
+                EVP_KEYEXCH_do_all_provided(NULL, do_keyexch, &amp;data);
+                if (verbose &gt; 1) {
+                    data.first = 1;
+                    data.label = &quot;Signature&quot;;
+                }
+                EVP_SIGNATURE_do_all_provided(NULL, do_signature, &amp;data);
 
                 switch (verbose) {
                 default:
diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
index e59f082818..11c334cc5e 100644
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -760,7 +760,7 @@ static void *evp_md_from_dispatch(int name_id,
 #ifndef FIPS_MODE
     /* TODO(3.x) get rid of the need for legacy NIDs */
     md-&gt;type = NID_undef;
-    evp_doall_names(prov, name_id, set_legacy_nid, &amp;md-&gt;type);
+    evp_names_do_all(prov, name_id, set_legacy_nid, &amp;md-&gt;type);
     if (md-&gt;type == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_MD_free(md);
@@ -902,9 +902,9 @@ void EVP_MD_free(EVP_MD *md)
     OPENSSL_free(md);
 }
 
-void EVP_MD_do_all_ex(OPENSSL_CTX *libctx,
-                          void (*fn)(EVP_MD *mac, void *arg),
-                          void *arg)
+void EVP_MD_do_all_provided(OPENSSL_CTX *libctx,
+                            void (*fn)(EVP_MD *mac, void *arg),
+                            void *arg)
 {
     evp_generic_do_all(libctx, OSSL_OP_DIGEST,
                        (void (*)(void *, void *))fn, arg,
diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
index 86506d3a4c..efcb7e509a 100644
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -1365,7 +1365,7 @@ static void *evp_cipher_from_dispatch(const int name_id,
 #ifndef FIPS_MODE
     /* TODO(3.x) get rid of the need for legacy NIDs */
     cipher-&gt;nid = NID_undef;
-    evp_doall_names(prov, name_id, set_legacy_nid, &amp;cipher-&gt;nid);
+    evp_names_do_all(prov, name_id, set_legacy_nid, &amp;cipher-&gt;nid);
     if (cipher-&gt;nid == -1) {
         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
         EVP_CIPHER_free(cipher);
@@ -1521,9 +1521,9 @@ void EVP_CIPHER_free(EVP_CIPHER *cipher)
     OPENSSL_free(cipher);
 }
 
-void EVP_CIPHER_do_all_ex(OPENSSL_CTX *libctx,
-                          void (*fn)(EVP_CIPHER *mac, void *arg),
-                          void *arg)
+void EVP_CIPHER_do_all_provided(OPENSSL_CTX *libctx,
+                                void (*fn)(EVP_CIPHER *mac, void *arg),
+                                void *arg)
 {
     evp_generic_do_all(libctx, OSSL_OP_CIPHER,
                        (void (*)(void *, void *))fn, arg,
diff --git a/crypto/evp/evp_fetch.c b/crypto/evp/evp_fetch.c
index 2404dfca30..907091fced 100644
--- a/crypto/evp/evp_fetch.c
+++ b/crypto/evp/evp_fetch.c
@@ -411,6 +411,7 @@ struct do_all_data_st {
     void *user_arg;
     void *(*new_method)(const int name_id, const OSSL_DISPATCH *fns,
                         OSSL_PROVIDER *prov, void *method_data);
+    void *method_data;
     void (*free_method)(void *);
 };
 
@@ -425,7 +426,7 @@ static void do_one(OSSL_PROVIDER *provider, const OSSL_ALGORITHM *algo,
 
     if (name_id != 0)
         method = data-&gt;new_method(name_id, algo-&gt;implementation, provider,
-                                  NULL);
+                                  data-&gt;method_data);
 
     if (method != NULL) {
         data-&gt;user_fn(method, data-&gt;user_arg);
@@ -446,10 +447,11 @@ void evp_generic_do_all(OPENSSL_CTX *libctx, int operation_id,
     struct do_all_data_st data;
 
     data.new_method = new_method;
+    data.method_data = method_data;
     data.free_method = free_method;
     data.user_fn = user_fn;
     data.user_arg = user_arg;
-    ossl_algorithm_do_all(libctx, operation_id, method_data, do_one, &amp;data);
+    ossl_algorithm_do_all(libctx, operation_id, NULL, do_one, &amp;data);
 }
 
 const char *evp_first_name(OSSL_PROVIDER *prov, int name_id)
@@ -468,9 +470,9 @@ int evp_is_a(OSSL_PROVIDER *prov, int number, const char *name)
     return ossl_namemap_name2num(namemap, name) == number;
 }
 
-void evp_doall_names(OSSL_PROVIDER *prov, int number,
-                     void (*fn)(const char *name, void *data),
-                     void *data)
+void evp_names_do_all(OSSL_PROVIDER *prov, int number,
+                      void (*fn)(const char *name, void *data),
+                      void *data)
 {
     OPENSSL_CTX *libctx = ossl_provider_library_context(prov);
     OSSL_NAMEMAP *namemap = ossl_namemap_stored(libctx);
diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
index c567b2efee..c25c40ddb0 100644
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -545,6 +545,11 @@ int EVP_CIPHER_is_a(const EVP_CIPHER *cipher, const char *name)
     return evp_is_a(cipher-&gt;prov, cipher-&gt;name_id, name);
 }
 
+int EVP_CIPHER_number(const EVP_CIPHER *cipher)
+{
+    return cipher-&gt;name_id;
+}
+
 const char *EVP_CIPHER_name(const EVP_CIPHER *cipher)
 {
     if (cipher-&gt;prov != NULL)
@@ -556,6 +561,14 @@ const char *EVP_CIPHER_name(const EVP_CIPHER *cipher)
 #endif
 }
 
+void EVP_CIPHER_names_do_all(const EVP_CIPHER *cipher,
+                             void (*fn)(const char *name, void *data),
+                             void *data)
+{
+    if (cipher-&gt;prov != NULL)
+        evp_names_do_all(cipher-&gt;prov, cipher-&gt;name_id, fn, data);
+}
+
 const OSSL_PROVIDER *EVP_CIPHER_provider(const EVP_CIPHER *cipher)
 {
     return cipher-&gt;prov;
@@ -573,6 +586,16 @@ int EVP_CIPHER_mode(const EVP_CIPHER *cipher)
     return ok != 0 ? (int)v : 0;
 }
 
+int EVP_MD_is_a(const EVP_MD *md, const char *name)
+{
+    return evp_is_a(md-&gt;prov, md-&gt;name_id, name);
+}
+
+int EVP_MD_number(const EVP_MD *md)
+{
+    return md-&gt;name_id;
+}
+
 const char *EVP_MD_name(const EVP_MD *md)
 {
     if (md-&gt;prov != NULL)
@@ -584,6 +607,14 @@ const char *EVP_MD_name(const EVP_MD *md)
 #endif
 }
 
+void EVP_MD_names_do_all(const EVP_MD *md,
+                         void (*fn)(const char *name, void *data),
+                         void *data)
+{
+    if (md-&gt;prov != NULL)
+        evp_names_do_all(md-&gt;prov, md-&gt;name_id, fn, data);
+}
+
 const OSSL_PROVIDER *EVP_MD_provider(const EVP_MD *md)
 {
     return md-&gt;prov;
diff --git a/crypto/evp/evp_local.h b/crypto/evp/evp_local.h
index b14d27c8ba..9b208190fb 100644
--- a/crypto/evp/evp_local.h
+++ b/crypto/evp/evp_local.h
@@ -261,6 +261,6 @@ void evp_pkey_ctx_free_old_ops(EVP_PKEY_CTX *ctx);
 /* OSSL_PROVIDER * is only used to get the library context */
 const char *evp_first_name(OSSL_PROVIDER *prov, int name_id);
 int evp_is_a(OSSL_PROVIDER *prov, int number, const char *name);
-void evp_doall_names(OSSL_PROVIDER *prov, int number,
-                     void (*fn)(const char *name, void *data),
-                     void *data);
+void evp_names_do_all(OSSL_PROVIDER *prov, int number,
+                      void (*fn)(const char *name, void *data),
+                      void *data);
diff --git a/crypto/evp/exchange.c b/crypto/evp/exchange.c
index 4c02c8a6a0..faece8af3c 100644
--- a/crypto/evp/exchange.c
+++ b/crypto/evp/exchange.c
@@ -386,3 +386,35 @@ int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *pkeylen)
     M_check_autoarg(ctx, key, pkeylen, EVP_F_EVP_PKEY_DERIVE)
         return ctx-&gt;pmeth-&gt;derive(ctx, key, pkeylen);
 }
+
+int EVP_KEYEXCH_number(const EVP_KEYEXCH *keyexch)
+{
+    return keyexch-&gt;name_id;
+}
+
+int EVP_KEYEXCH_is_a(const EVP_KEYEXCH *keyexch, const char *name)
+{
+    return evp_is_a(keyexch-&gt;prov, keyexch-&gt;name_id, name);
+}
+
+void EVP_KEYEXCH_do_all_provided(OPENSSL_CTX *libctx,
+                                 void (*fn)(EVP_KEYEXCH *keyexch, void *arg),
+                                 void *arg)
+{
+    struct keymgmt_data_st keymgmt_data;
+
+    keymgmt_data.ctx = libctx;
+    keymgmt_data.properties = NULL;
+    evp_generic_do_all(libctx, OSSL_OP_KEYEXCH,
+                       (void (*)(void *, void *))fn, arg,
+                       evp_keyexch_from_dispatch, &amp;keymgmt_data,
+                       (void (*)(void *))EVP_KEYEXCH_free);
+}
+
+void EVP_KEYEXCH_names_do_all(const EVP_KEYEXCH *keyexch,
+                              void (*fn)(const char *name, void *data),
+                              void *data)
+{
+    if (keyexch-&gt;prov != NULL)
+        evp_names_do_all(keyexch-&gt;prov, keyexch-&gt;name_id, fn, data);
+}
diff --git a/crypto/evp/kdf_lib.c b/crypto/evp/kdf_lib.c
index 7163de397f..5ddf8560d2 100644
--- a/crypto/evp/kdf_lib.c
+++ b/crypto/evp/kdf_lib.c
@@ -83,9 +83,14 @@ EVP_KDF_CTX *EVP_KDF_CTX_dup(const EVP_KDF_CTX *src)
     return dst;
 }
 
-const char *EVP_KDF_name(const EVP_KDF *kdf)
+int EVP_KDF_number(const EVP_KDF *kdf)
 {
-    return evp_first_name(kdf-&gt;prov, kdf-&gt;name_id);
+    return kdf-&gt;name_id;
+}
+
+int EVP_KDF_is_a(const EVP_KDF *kdf, const char *name)
+{
+    return evp_is_a(kdf-&gt;prov, kdf-&gt;name_id, name);
 }
 
 const OSSL_PROVIDER *EVP_KDF_provider(const EVP_KDF *kdf)
@@ -159,3 +164,11 @@ int EVP_KDF_CTX_set_params(EVP_KDF_CTX *ctx, const OSSL_PARAM params[])
         return ctx-&gt;meth-&gt;set_ctx_params(ctx-&gt;data, params);
     return 1;
 }
+
+void EVP_KDF_names_do_all(const EVP_KDF *kdf,
+                          void (*fn)(const char *name, void *data),
+                          void *data)
+{
+    if (kdf-&gt;prov != NULL)
+        evp_names_do_all(kdf-&gt;prov, kdf-&gt;name_id, fn, data);
+}
diff --git a/crypto/evp/kdf_meth.c b/crypto/evp/kdf_meth.c
index e6185e9255..576dde6805 100644
--- a/crypto/evp/kdf_meth.c
+++ b/crypto/evp/kdf_meth.c
@@ -187,9 +187,9 @@ const OSSL_PARAM *EVP_KDF_settable_ctx_params(const EVP_KDF *kdf)
     return kdf-&gt;settable_ctx_params();
 }
 
-void EVP_KDF_do_all_ex(OPENSSL_CTX *libctx,
-                       void (*fn)(EVP_KDF *kdf, void *arg),
-                       void *arg)
+void EVP_KDF_do_all_provided(OPENSSL_CTX *libctx,
+                             void (*fn)(EVP_KDF *kdf, void *arg),
+                             void *arg)
 {
     evp_generic_do_all(libctx, OSSL_OP_KDF,
                        (void (*)(void *, void *))fn, arg,
diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
index a5df564605..9c8d482b4d 100644
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -200,3 +200,30 @@ const OSSL_PROVIDER *EVP_KEYMGMT_provider(const EVP_KEYMGMT *keymgmt)
     return keymgmt-&gt;prov;
 }
 
+int EVP_KEYMGMT_number(const EVP_KEYMGMT *keymgmt)
+{
+    return keymgmt-&gt;name_id;
+}
+
+int EVP_KEYMGMT_is_a(const EVP_KEYMGMT *keymgmt, const char *name)
+{
+    return evp_is_a(keymgmt-&gt;prov, keymgmt-&gt;name_id, name);
+}
+
+void EVP_KEYMGMT_do_all_provided(OPENSSL_CTX *libctx,
+                                 void (*fn)(EVP_KEYMGMT *keymgmt, void *arg),
+                                 void *arg)
+{
+    evp_generic_do_all(libctx, OSSL_OP_KEYMGMT,
+                       (void (*)(void *, void *))fn, arg,
+                       keymgmt_from_dispatch, NULL,
+                       (void (*)(void *))EVP_KEYMGMT_free);
+}
+
+void EVP_KEYMGMT_names_do_all(const EVP_KEYMGMT *keymgmt,
+                              void (*fn)(const char *name, void *data),
+                              void *data)
+{
+    if (keymgmt-&gt;prov != NULL)
+        evp_names_do_all(keymgmt-&gt;prov, keymgmt-&gt;name_id, fn, data);
+}
diff --git a/crypto/evp/mac_lib.c b/crypto/evp/mac_lib.c
index 8b8c9a5067..07ed1c8749 100644
--- a/crypto/evp/mac_lib.c
+++ b/crypto/evp/mac_lib.c
@@ -157,3 +157,21 @@ int EVP_MAC_CTX_set_params(EVP_MAC_CTX *ctx, const OSSL_PARAM params[])
         return ctx-&gt;meth-&gt;set_ctx_params(ctx-&gt;data, params);
     return 1;
 }
+
+int EVP_MAC_number(const EVP_MAC *mac)
+{
+    return mac-&gt;name_id;
+}
+
+int EVP_MAC_is_a(const EVP_MAC *mac, const char *name)
+{
+    return evp_is_a(mac-&gt;prov, mac-&gt;name_id, name);
+}
+
+void EVP_MAC_names_do_all(const EVP_MAC *mac,
+                          void (*fn)(const char *name, void *data),
+                          void *data)
+{
+    if (mac-&gt;prov != NULL)
+        evp_names_do_all(mac-&gt;prov, mac-&gt;name_id, fn, data);
+}
diff --git a/crypto/evp/mac_meth.c b/crypto/evp/mac_meth.c
index f35c2d157e..2c124aef6a 100644
--- a/crypto/evp/mac_meth.c
+++ b/crypto/evp/mac_meth.c
@@ -168,16 +168,6 @@ void EVP_MAC_free(EVP_MAC *mac)
     evp_mac_free(mac);
 }
 
-int EVP_MAC_is_a(const EVP_MAC *mac, const char *name)
-{
-    return evp_is_a(mac-&gt;prov, mac-&gt;name_id, name);
-}
-
-const char *EVP_MAC_name(const EVP_MAC *mac)
-{
-    return evp_first_name(mac-&gt;prov, mac-&gt;name_id);
-}
-
 const OSSL_PROVIDER *EVP_MAC_provider(const EVP_MAC *mac)
 {
     return mac-&gt;prov;
@@ -204,9 +194,9 @@ const OSSL_PARAM *EVP_MAC_settable_ctx_params(const EVP_MAC *mac)
     return mac-&gt;settable_ctx_params();
 }
 
-void EVP_MAC_do_all_ex(OPENSSL_CTX *libctx,
-                       void (*fn)(EVP_MAC *mac, void *arg),
-                       void *arg)
+void EVP_MAC_do_all_provided(OPENSSL_CTX *libctx,
+                             void (*fn)(EVP_MAC *mac, void *arg),
+                             void *arg)
 {
     evp_generic_do_all(libctx, OSSL_OP_MAC,
                        (void (*)(void *, void *))fn, arg,
diff --git a/crypto/evp/pmeth_fn.c b/crypto/evp/pmeth_fn.c
index c7940e8e38..a78839b992 100644
--- a/crypto/evp/pmeth_fn.c
+++ b/crypto/evp/pmeth_fn.c
@@ -312,6 +312,40 @@ EVP_SIGNATURE *EVP_SIGNATURE_fetch(OPENSSL_CTX *ctx, const char *algorithm,
                              (void (*)(void *))EVP_SIGNATURE_free);
 }
 
+int EVP_SIGNATURE_is_a(const EVP_SIGNATURE *signature, const char *name)
+{
+    return evp_is_a(signature-&gt;prov, signature-&gt;name_id, name);
+}
+
+int EVP_SIGNATURE_number(const EVP_SIGNATURE *signature)
+{
+    return signature-&gt;name_id;
+}
+
+void EVP_SIGNATURE_do_all_provided(OPENSSL_CTX *libctx,
+                                   void (*fn)(EVP_SIGNATURE *signature,
+                                              void *arg),
+                                   void *arg)
+{
+    struct keymgmt_data_st keymgmt_data;
+
+    keymgmt_data.ctx = libctx;
+    keymgmt_data.properties = NULL;
+    evp_generic_do_all(libctx, OSSL_OP_SIGNATURE,
+                       (void (*)(void *, void *))fn, arg,
+                       evp_signature_from_dispatch, &amp;keymgmt_data,
+                       (void (*)(void *))EVP_SIGNATURE_free);
+}
+
+
+void EVP_SIGNATURE_names_do_all(const EVP_SIGNATURE *signature,
+                                void (*fn)(const char *name, void *data),
+                                void *data)
+{
+    if (signature-&gt;prov != NULL)
+        evp_names_do_all(signature-&gt;prov, signature-&gt;name_id, fn, data);
+}
+
 static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature,
                                    int operation)
 {
diff --git a/crypto/x509/ext_dat.h b/crypto/x509/ext_dat.h
index aa6fa79774..f48fa1d3f1 100644
--- a/crypto/x509/ext_dat.h
+++ b/crypto/x509/ext_dat.h
@@ -7,7 +7,7 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-int name_cmp(const char *name, const char *cmp);
+int v3_name_cmp(const char *name, const char *cmp);
 
 extern const X509V3_EXT_METHOD v3_bcons, v3_nscert, v3_key_usage, v3_ext_ku;
 extern const X509V3_EXT_METHOD v3_pkey_usage_period, v3_sxnet, v3_info, v3_sinfo;
diff --git a/crypto/x509/v3_addr.c b/crypto/x509/v3_addr.c
index a33dd9990d..766c5bc106 100644
--- a/crypto/x509/v3_addr.c
+++ b/crypto/x509/v3_addr.c
@@ -906,14 +906,14 @@ static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
         const char *addr_chars = NULL;
         int prefixlen, i1, i2, delim, length;
 
-        if (!name_cmp(val-&gt;name, &quot;IPv4&quot;)) {
+        if (!v3_name_cmp(val-&gt;name, &quot;IPv4&quot;)) {
             afi = IANA_AFI_IPV4;
-        } else if (!name_cmp(val-&gt;name, &quot;IPv6&quot;)) {
+        } else if (!v3_name_cmp(val-&gt;name, &quot;IPv6&quot;)) {
             afi = IANA_AFI_IPV6;
-        } else if (!name_cmp(val-&gt;name, &quot;IPv4-SAFI&quot;)) {
+        } else if (!v3_name_cmp(val-&gt;name, &quot;IPv4-SAFI&quot;)) {
             afi = IANA_AFI_IPV4;
             safi = &amp;safi_;
-        } else if (!name_cmp(val-&gt;name, &quot;IPv6-SAFI&quot;)) {
+        } else if (!v3_name_cmp(val-&gt;name, &quot;IPv6-SAFI&quot;)) {
             afi = IANA_AFI_IPV6;
             safi = &amp;safi_;
         } else {
diff --git a/crypto/x509/v3_alt.c b/crypto/x509/v3_alt.c
index af1cd61aee..5d1ece71cb 100644
--- a/crypto/x509/v3_alt.c
+++ b/crypto/x509/v3_alt.c
@@ -252,7 +252,7 @@ static GENERAL_NAMES *v2i_issuer_alt(X509V3_EXT_METHOD *method,
     for (i = 0; i &lt; num; i++) {
         CONF_VALUE *cnf = sk_CONF_VALUE_value(nval, i);
 
-        if (!name_cmp(cnf-&gt;name, &quot;issuer&quot;)
+        if (!v3_name_cmp(cnf-&gt;name, &quot;issuer&quot;)
             &amp;&amp; cnf-&gt;value &amp;&amp; strcmp(cnf-&gt;value, &quot;copy&quot;) == 0) {
             if (!copy_issuer(ctx, gens))
                 goto err;
@@ -331,11 +331,11 @@ static GENERAL_NAMES *v2i_subject_alt(X509V3_EXT_METHOD *method,
 
     for (i = 0; i &lt; num; i++) {
         cnf = sk_CONF_VALUE_value(nval, i);
-        if (!name_cmp(cnf-&gt;name, &quot;email&quot;)
+        if (!v3_name_cmp(cnf-&gt;name, &quot;email&quot;)
             &amp;&amp; cnf-&gt;value &amp;&amp; strcmp(cnf-&gt;value, &quot;copy&quot;) == 0) {
             if (!copy_email(ctx, gens, 0))
                 goto err;
-        } else if (!name_cmp(cnf-&gt;name, &quot;email&quot;)
+        } else if (!v3_name_cmp(cnf-&gt;name, &quot;email&quot;)
                    &amp;&amp; cnf-&gt;value &amp;&amp; strcmp(cnf-&gt;value, &quot;move&quot;) == 0) {
             if (!copy_email(ctx, gens, 1))
                 goto err;
@@ -551,19 +551,19 @@ GENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out,
         return NULL;
     }
 
-    if (!name_cmp(name, &quot;email&quot;))
+    if (!v3_name_cmp(name, &quot;email&quot;))
         type = GEN_EMAIL;
-    else if (!name_cmp(name, &quot;URI&quot;))
+    else if (!v3_name_cmp(name, &quot;URI&quot;))
         type = GEN_URI;
-    else if (!name_cmp(name, &quot;DNS&quot;))
+    else if (!v3_name_cmp(name, &quot;DNS&quot;))
         type = GEN_DNS;
-    else if (!name_cmp(name, &quot;RID&quot;))
+    else if (!v3_name_cmp(name, &quot;RID&quot;))
         type = GEN_RID;
-    else if (!name_cmp(name, &quot;IP&quot;))
+    else if (!v3_name_cmp(name, &quot;IP&quot;))
         type = GEN_IPADD;
-    else if (!name_cmp(name, &quot;dirName&quot;))
+    else if (!v3_name_cmp(name, &quot;dirName&quot;))
         type = GEN_DIRNAME;
-    else if (!name_cmp(name, &quot;otherName&quot;))
+    else if (!v3_name_cmp(name, &quot;otherName&quot;))
         type = GEN_OTHERNAME;
     else {
         X509V3err(X509V3_F_V2I_GENERAL_NAME_EX, X509V3_R_UNSUPPORTED_OPTION);
diff --git a/crypto/x509/v3_asid.c b/crypto/x509/v3_asid.c
index dfd48f7331..6cb5cd5546 100644
--- a/crypto/x509/v3_asid.c
+++ b/crypto/x509/v3_asid.c
@@ -534,9 +534,9 @@ static void *v2i_ASIdentifiers(const struct v3_ext_method *method,
         /*
          * Figure out whether this is an AS or an RDI.
          */
-        if (!name_cmp(val-&gt;name, &quot;AS&quot;)) {
+        if (!v3_name_cmp(val-&gt;name, &quot;AS&quot;)) {
             which = V3_ASID_ASNUM;
-        } else if (!name_cmp(val-&gt;name, &quot;RDI&quot;)) {
+        } else if (!v3_name_cmp(val-&gt;name, &quot;RDI&quot;)) {
             which = V3_ASID_RDI;
         } else {
             X509V3err(X509V3_F_V2I_ASIDENTIFIERS,
diff --git a/crypto/x509/v3_cpols.c b/crypto/x509/v3_cpols.c
index e70ab61d50..470088c90a 100644
--- a/crypto/x509/v3_cpols.c
+++ b/crypto/x509/v3_cpols.c
@@ -187,7 +187,7 @@ static POLICYINFO *policy_section(X509V3_CTX *ctx,
             }
             pol-&gt;policyid = pobj;
 
-        } else if (!name_cmp(cnf-&gt;name, &quot;CPS&quot;)) {
+        } else if (!v3_name_cmp(cnf-&gt;name, &quot;CPS&quot;)) {
             if (pol-&gt;qualifiers == NULL)
                 pol-&gt;qualifiers = sk_POLICYQUALINFO_new_null();
             if ((qual = POLICYQUALINFO_new()) == NULL)
@@ -203,7 +203,7 @@ static POLICYINFO *policy_section(X509V3_CTX *ctx,
             if (!ASN1_STRING_set(qual-&gt;d.cpsuri, cnf-&gt;value,
                                  strlen(cnf-&gt;value)))
                 goto merr;
-        } else if (!name_cmp(cnf-&gt;name, &quot;userNotice&quot;)) {
+        } else if (!v3_name_cmp(cnf-&gt;name, &quot;userNotice&quot;)) {
             STACK_OF(CONF_VALUE) *unot;
             if (*cnf-&gt;value != '@') {
                 X509V3err(X509V3_F_POLICY_SECTION,
diff --git a/crypto/x509/v3_utl.c b/crypto/x509/v3_utl.c
index 50fa404996..19b552c3a3 100644
--- a/crypto/x509/v3_utl.c
+++ b/crypto/x509/v3_utl.c
@@ -397,7 +397,7 @@ static char *strip_spaces(char *name)
  * V2I name comparison function: returns zero if 'name' matches cmp or cmp.*
  */
 
-int name_cmp(const char *name, const char *cmp)
+int v3_name_cmp(const char *name, const char *cmp)
 {
     int len, ret;
     char c;
diff --git a/doc/man1/openssl-list.pod b/doc/man1/openssl-list.pod
index 9e691c60ce..5388b478a5 100644
--- a/doc/man1/openssl-list.pod
+++ b/doc/man1/openssl-list.pod
@@ -54,37 +54,17 @@ Display a list of standard commands.
 Display a list of message digest commands, which are typically used
 as input to the L&lt;openssl-dgst(1)&gt; or L&lt;openssl-speed(1)&gt; commands.
 
-=item B&lt;-digest-algorithms&gt;
-
-Display a list of message digest algorithms.
-If a line is of the form C&lt;foo =E&lt;gt&gt; bar&gt; then C&lt;foo&gt; is an alias for the
-official algorithm name, C&lt;bar&gt;.
-If a line is of the form C&lt;foo @ bar&gt;, then C&lt;foo&gt; is provided by the provider
-C&lt;bar&gt;.
-
-In verbose mode, the algorithms provided by a provider will get additional
-information on what parameters each implementation supports.
-
-=item B&lt;-kdf-algorithms&gt;
-
-Display a list of key derivation function algorithms.
-
-=item B&lt;-mac-algorithms&gt;
-
-Display a list of message authentication code algorithms.
-
 =item B&lt;-cipher-commands&gt;
 
 Display a list of cipher commands, which are typically used as input
 to the L&lt;openssl-dgst(1)&gt; or L&lt;openssl-speed(1)&gt; commands.
 
-=item B&lt;-cipher-algorithms&gt;
+=item B&lt;-digest-algorithms&gt;, B&lt;-kdf-algorithms&gt;, B&lt;-mac-algorithms&gt;,
+B&lt;-cipher-algorithms&gt;
 
-Display a list of cipher algorithms.
-If a line is of the form C&lt;foo =E&lt;gt&gt; bar&gt; then C&lt;foo&gt; is an alias for the
-official algorithm name, B&lt;bar&gt;.
-If a line is of the form C&lt;foo @ bar&gt;, then C&lt;foo&gt; is provided by the provider
-C&lt;bar&gt;.
+Display a list of cipher, digest, kdf and mac algorithms.
+See L&lt;/Display of algorithm names&gt; for a description of how names are
+displayed.
 
 In verbose mode, the algorithms provided by a provider will get additional
 information on what parameters each implementation supports.
@@ -114,6 +94,33 @@ format described in L&lt;config(5)/ASN1 Object Configuration Module&gt;.
 
 =back
 
+=head2 Display of algorithm names
+
+Algorithm names may be displayed in one of two manners:
+
+=over 4
+
+=item Legacy implementations
+
+Legacy implementations will simply display the main name of the
+algorithm on a line of its own, or in the form C&lt;&lt;foo &gt; bar&gt;&gt; to show
+that C&lt;foo&gt; is an alias for the main name, C&lt;bar&gt;
+
+=item Provided implementations
+
+Implementations from a provider are displayed like this if the
+implementation is labeled with a single name:
+
+ foo @ bar
+
+or like this if it's labeled with multiple names:
+
+ { foo1, foo2 } @bar
+
+In both cases, C&lt;bar&gt; is the name of the provider.
+
+=back
+
 =head1 COPYRIGHT
 
 Copyright 2016-2019 The OpenSSL Project Authors. All Rights Reserved.
diff --git a/doc/man3/EVP_DigestInit.pod b/doc/man3/EVP_DigestInit.pod
index dfc63eba49..2c72a0dce3 100644
--- a/doc/man3/EVP_DigestInit.pod
+++ b/doc/man3/EVP_DigestInit.pod
@@ -12,7 +12,7 @@ EVP_MD_CTX_settable_params, EVP_MD_CTX_gettable_params,
 EVP_MD_CTX_set_flags, EVP_MD_CTX_clear_flags, EVP_MD_CTX_test_flags,
 EVP_Digest, EVP_DigestInit_ex, EVP_DigestInit, EVP_DigestUpdate,
 EVP_DigestFinal_ex, EVP_DigestFinalXOF, EVP_DigestFinal,
-EVP_MD_name, EVP_MD_provider,
+EVP_MD_is_a, EVP_MD_name, EVP_MD_number, EVP_MD_names_do_all, EVP_MD_provider,
 EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size, EVP_MD_block_size, EVP_MD_flags,
 EVP_MD_CTX_name,
 EVP_MD_CTX_md, EVP_MD_CTX_type, EVP_MD_CTX_size, EVP_MD_CTX_block_size,
@@ -20,7 +20,7 @@ EVP_MD_CTX_md_data, EVP_MD_CTX_update_fn, EVP_MD_CTX_set_update_fn,
 EVP_md_null,
 EVP_get_digestbyname, EVP_get_digestbynid, EVP_get_digestbyobj,
 EVP_MD_CTX_pkey_ctx, EVP_MD_CTX_set_pkey_ctx,
-EVP_MD_do_all_ex
+EVP_MD_do_all_provided
 - EVP digest routines
 
 =head1 SYNOPSIS
@@ -62,6 +62,11 @@ EVP_MD_do_all_ex
  int EVP_MD_CTX_copy(EVP_MD_CTX *out, EVP_MD_CTX *in);
 
  const char *EVP_MD_name(const EVP_MD *md);
+ int EVP_MD_number(const EVP_MD *md);
+ int EVP_MD_is_a(const EVP_MD *md, const char *name);
+ void EVP_MD_names_do_all(const EVP_MD *md,
+                          void (*fn)(const char *name, void *data),
+                          void *data);
  const OSSL_PROVIDER *EVP_MD_provider(const EVP_MD *md);
  int EVP_MD_type(const EVP_MD *md);
  int EVP_MD_pkey_type(const EVP_MD *md);
@@ -90,9 +95,9 @@ EVP_MD_do_all_ex
  EVP_PKEY_CTX *EVP_MD_CTX_pkey_ctx(const EVP_MD_CTX *ctx);
  void EVP_MD_CTX_set_pkey_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pctx);
 
- void EVP_MD_do_all_ex(OPENSSL_CTX *libctx,
-                       void (*fn)(EVP_MD *mac, void *arg),
-                       void *arg);
+ void EVP_MD_do_all_provided(OPENSSL_CTX *libctx,
+                             void (*fn)(EVP_MD *mac, void *arg),
+                             void *arg);
 
 =head1 DESCRIPTION
 
@@ -238,10 +243,27 @@ automatically cleaned up.
 Similar to EVP_MD_CTX_copy_ex() except the destination B&lt;out&gt; does not have to
 be initialized.
 
+=item EVP_MD_is_a()
+
+Returns 1 if I&lt;md&gt; is an implementation of an algorithm that's
+identifiable with I&lt;name&gt;, otherwise 0.
+
+=item EVP_MD_number()
+
+Returns the internal dynamic number assigned to the I&lt;md&gt;.  This is
+only useful with fetched B&lt;EVP_MD&gt;s.
+
 =item EVP_MD_name(),
 EVP_MD_CTX_name()
 
-Return the name of the given message digest.
+Return the name of the given message digest.  For fetched message
+digests with multiple names, only one of them is returned; it's
+recommended to use EVP_MD_names_do_all() instead.
+
+=item EVP_MD_names_do_all()
+
+Traverses all names for the I&lt;md&gt;, and calls I&lt;fn&gt; with each name and
+I&lt;data&gt;.  This is only useful with fetched B&lt;EVP_MD&gt;s.
 
 =item EVP_MD_provider()
 
@@ -330,7 +352,7 @@ by the caller. A NULL B&lt;pctx&gt; pointer is also allowed to clear the B&lt;EVP_PKEY_CT
 assigned to B&lt;ctx&gt;. In such case, freeing the cleared B&lt;EVP_PKEY_CTX&gt; or not
 depends on how the B&lt;EVP_PKEY_CTX&gt; is created.
 
-=item EVP_MD_do_all_ex()
+=item EVP_MD_do_all_provided()
 
 Traverses all messages digests implemented by all activated providers
 in the given library context I&lt;libctx&gt;, and for each of the implementations,
diff --git a/doc/man3/EVP_EncryptInit.pod b/doc/man3/EVP_EncryptInit.pod
index 722a8e3d36..31e2fdeaf0 100644
--- a/doc/man3/EVP_EncryptInit.pod
+++ b/doc/man3/EVP_EncryptInit.pod
@@ -31,6 +31,8 @@ EVP_get_cipherbynid,
 EVP_get_cipherbyobj,
 EVP_CIPHER_is_a,
 EVP_CIPHER_name,
+EVP_CIPHER_number,
+EVP_CIPHER_names_do_all,
 EVP_CIPHER_provider,
 EVP_CIPHER_nid,
 EVP_CIPHER_get_params,
@@ -61,7 +63,7 @@ EVP_CIPHER_param_to_asn1,
 EVP_CIPHER_asn1_to_param,
 EVP_CIPHER_CTX_set_padding,
 EVP_enc_null,
-EVP_CIPHER_do_all_ex
+EVP_CIPHER_do_all_provided
 - EVP cipher routines
 
 =head1 SYNOPSIS
@@ -121,7 +123,11 @@ EVP_CIPHER_do_all_ex
  const EVP_CIPHER *EVP_get_cipherbyobj(const ASN1_OBJECT *a);
 
  int EVP_CIPHER_nid(const EVP_CIPHER *e);
+ int EVP_CIPHER_number(const EVP_CIPHER *e);
  int EVP_CIPHER_is_a(const EVP_CIPHER *cipher, const char *name);
+ void EVP_CIPHER_names_do_all(const EVP_CIPHER *cipher,
+                              void (*fn)(const char *name, void *data),
+                              void *data);
  const char *EVP_CIPHER_name(const EVP_CIPHER *cipher);
  const OSSL_PROVIDER *EVP_CIPHER_provider(const EVP_CIPHER *cipher);
  int EVP_CIPHER_block_size(const EVP_CIPHER *e);
@@ -153,9 +159,9 @@ EVP_CIPHER_do_all_ex
  int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
  int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
 
- void EVP_CIPHER_do_all_ex(OPENSSL_CTX *libctx,
-                           void (*fn)(EVP_CIPHER *cipher, void *arg),
-                           void *arg);
+ void EVP_CIPHER_do_all_provided(OPENSSL_CTX *libctx,
+                                 void (*fn)(EVP_CIPHER *cipher, void *arg),
+                                 void *arg);
 
 =head1 DESCRIPTION
 
@@ -330,11 +336,20 @@ IDENTIFIER as such it ignores the cipher parameters and 40 bit RC2 and
 identifier or does not have ASN1 support this function will return
 B&lt;NID_undef&gt;.
 
-EVP_CIPHER_is_a() returns 1 if the given I&lt;cipher&gt; is an implementation of an
+EVP_CIPHER_is_a() returns 1 if I&lt;cipher&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;, otherwise 0.
 
+EVP_CIPHER_number() returns the internal dynamic number assigned to
+the I&lt;cipher&gt;.  This is only useful with fetched B&lt;EVP_CIPHER&gt;s.
+
 EVP_CIPHER_name() and EVP_CIPHER_CTX_name() return the name of the passed
-cipher or context.
+cipher or context.  For fetched ciphers with multiple names, only one
+of them is returned; it's recommended to use EVP_CIPHER_names_do_all()
+instead.
+
+EVP_CIPHER_names_do_all() traverses all names for the I&lt;cipher&gt;, and
+calls I&lt;fn&gt; with each name and I&lt;data&gt;.  This is only useful with
+fetched B&lt;EVP_CIPHER&gt;s.
 
 EVP_CIPHER_provider() returns an B&lt;OSSL_PROVIDER&gt; pointer to the provider
 that implements the given B&lt;EVP_CIPHER&gt;.
@@ -377,7 +392,7 @@ based on the cipher context. The EVP_CIPHER can provide its own random key
 generation routine to support keys of a specific form. B&lt;Key&gt; must point to a
 buffer at least as big as the value returned by EVP_CIPHER_CTX_key_length().
 
-EVP_CIPHER_do_all_ex() traverses all ciphers implemented by all activated
+EVP_CIPHER_do_all_provided() traverses all ciphers implemented by all activated
 providers in the given library context I&lt;libctx&gt;, and for each of the
 implementations, calls the given function I&lt;fn&gt; with the implementation method
 and the given I&lt;arg&gt; as argument.
diff --git a/doc/man3/EVP_KDF.pod b/doc/man3/EVP_KDF.pod
index e175124ad0..339129a943 100644
--- a/doc/man3/EVP_KDF.pod
+++ b/doc/man3/EVP_KDF.pod
@@ -2,11 +2,12 @@
 
 =head1 NAME
 
-EVP_KDF, EVP_KDF_fetch, EVP_KDF_free, EVP_KDF_provider, EVP_KDF_up_ref,
-EVP_KDF_name,
-EVP_KDF_CTX, EVP_KDF_CTX_new, EVP_KDF_CTX_free, EVP_KDF_CTX_kdf,
-EVP_KDF_reset, EVP_KDF_size, EVP_KDF_derive, EVP_KDF_CTX_dup,
-EVP_KDF_CTX_get_params, EVP_KDF_CTX_set_params, EVP_KDF_do_all_ex,
+EVP_KDF, EVP_KDF_fetch, EVP_KDF_free, EVP_KDF_up_ref,
+EVP_KDF_CTX, EVP_KDF_CTX_new, EVP_KDF_CTX_free, EVP_KDF_CTX_dup,
+EVP_KDF_reset, EVP_KDF_derive,
+EVP_KDF_size, EVP_KDF_provider, EVP_KDF_CTX_kdf, EVP_KDF_is_a,
+EVP_KDF_number, EVP_KDF_names_do_all,
+EVP_KDF_CTX_get_params, EVP_KDF_CTX_set_params, EVP_KDF_do_all_provided,
 EVP_KDF_get_params, EVP_KDF_gettable_ctx_params, EVP_KDF_settable_ctx_params,
 EVP_KDF_gettable_params - EVP KDF routines
 
@@ -24,14 +25,19 @@ EVP_KDF_gettable_params - EVP KDF routines
  void EVP_KDF_reset(EVP_KDF_CTX *ctx);
  size_t EVP_KDF_size(EVP_KDF_CTX *ctx);
  int EVP_KDF_derive(EVP_KDF_CTX *ctx, unsigned char *key, size_t keylen);
- const char *EVP_KDF_name(const EVP_KDF *kdf);
  int EVP_KDF_up_ref(EVP_KDF *kdf);
  void EVP_KDF_free(EVP_KDF *kdf);
  EVP_KDF *EVP_KDF_fetch(OPENSSL_CTX *libctx, const char *algorithm,
                         const char *properties);
- void EVP_KDF_do_all_ex(OPENSSL_CTX *libctx,
-                        void (*fn)(EVP_KDF *kdf, void *arg),
-                        void *arg);
+ int EVP_KDF_number(const EVP_KDF *kdf);
+ int EVP_KDF_is_a(const EVP_KDF *kdf, const char *name);
+ const OSSL_PROVIDER *EVP_KDF_provider(const EVP_KDF *kdf);
+ void EVP_KDF_do_all_provided(OPENSSL_CTX *libctx,
+                              void (*fn)(EVP_KDF *kdf, void *arg),
+                              void *arg);
+ void EVP_KDF_names_do_all(const EVP_KDF *kdf,
+                           void (*fn)(const char *name, void *data),
+                           void *data);
  int EVP_KDF_get_params(EVP_KDF *kdf, OSSL_PARAM params[]);
  int EVP_KDF_CTX_get_params(EVP_KDF_CTX *ctx, OSSL_PARAM params[]);
  int EVP_KDF_CTX_set_params(EVP_KDF_CTX *ctx, const OSSL_PARAM params[]);
@@ -75,7 +81,7 @@ NULL is a valid parameter, for which this function is a no-op.
 
 EVP_KDF_CTX_new() creates a new context for the KDF implementation I&lt;kdf&gt;.
 
-EVP_KDF_CTX_free() frees up the context C&lt;ctx&gt;.  If I&lt;ctx&gt; is NULL, nothing
+EVP_KDF_CTX_free() frees up the context I&lt;ctx&gt;.  If I&lt;ctx&gt; is NULL, nothing
 is done.
 
 EVP_KDF_CTX_kdf() returns the B&lt;EVP_KDF&gt; associated with the context
@@ -86,9 +92,9 @@ I&lt;ctx&gt;.
 EVP_KDF_reset() resets the context to the default state as if the context
 had just been created.
 
-EVP_KDF_derive() derives C&lt;keylen&gt; bytes of key material and places it in the
+EVP_KDF_derive() derives I&lt;keylen&gt; bytes of key material and places it in the
 I&lt;key&gt; buffer.  If the algorithm produces a fixed amount of output then an
-error will occur unless the C&lt;keylen&gt; parameter is equal to that output size,
+error will occur unless the I&lt;keylen&gt; parameter is equal to that output size,
 as returned by EVP_KDF_size().
 
 EVP_KDF_get_params() retrieves details about the implementation
@@ -128,16 +134,23 @@ of output and B&lt;SIZE_MAX&gt; otherwise.  If an error occurs then 0 is returned.
 For some algorithms an error may result if input parameters necessary to
 calculate a fixed output size have not yet been supplied.
 
-EVP_KDF_name() returns the name of the given KDF implementation.
+EVP_KDF_is_a() returns 1 if I&lt;kdf&gt; is an implementation of an
+algorithm that's identifiable with I&lt;name&gt;, otherwise 0.
 
 EVP_KDF_provider() returns the provider that holds the implementation
 of the given I&lt;kdf&gt;.
 
-EVP_KDF_do_all_ex() traverses all KDF implemented by all activated
+EVP_KDF_do_all_provided() traverses all KDF implemented by all activated
 providers in the given library context I&lt;libctx&gt;, and for each of the
 implementations, calls the given function I&lt;fn&gt; with the implementation method
 and the given I&lt;arg&gt; as argument.
 
+EVP_KDF_number() returns the internal dynamic number assigned to
+I&lt;kdf&gt;.
+
+EVP_KDF_names_do_all() traverses all names for I&lt;kdf&gt;, and calls
+I&lt;fn&gt; with each name and I&lt;data&gt;.
+
 =head1 PARAMETERS
 
 The standard parameter names are:
@@ -211,23 +224,20 @@ The memory size must never exceed what can be given with a B&lt;size_t&gt;.
 
 =head1 RETURN VALUES
 
-EVP_MAC_fetch() returns a pointer to a newly fetched B&lt;EVP_KDF&gt;, or
+EVP_KDF_fetch() returns a pointer to a newly fetched B&lt;EVP_KDF&gt;, or
 NULL if allocation failed.
 
-EVP_KDF_name() returns the name for the given I&lt;kdf&gt;, if it has been
-added to the object database.
-
 EVP_KDF_provider() returns a pointer to the provider for the KDF, or
 NULL on error.
 
-EVP_MAC_up_ref() returns 1 on success, 0 on error.
+EVP_KDF_up_ref() returns 1 on success, 0 on error.
 
 EVP_KDF_CTX_new() returns either the newly allocated
-C&lt;EVP_KDF_CTX&gt; structure or C&lt;NULL&gt; if an error occurred.
+B&lt;EVP_KDF_CTX&gt; structure or NULL if an error occurred.
 
 EVP_KDF_CTX_free() and EVP_KDF_reset() do not return a value.
 
-EVP_KDF_size() returns the output size.  C&lt;SIZE_MAX&gt; is returned to indicate
+EVP_KDF_size() returns the output size.  B&lt;SIZE_MAX&gt; is returned to indicate
 that the algorithm produces a variable amount of output; 0 to indicate failure.
 
 The remaining functions return 1 for success and 0 or a negative value for
diff --git a/doc/man3/EVP_KEYEXCH_free.pod b/doc/man3/EVP_KEYEXCH_free.pod
index 41926f6b12..deb9b9999b 100644
--- a/doc/man3/EVP_KEYEXCH_free.pod
+++ b/doc/man3/EVP_KEYEXCH_free.pod
@@ -2,7 +2,9 @@
 
 =head1 NAME
 
-EVP_KEYEXCH_fetch, EVP_KEYEXCH_free, EVP_KEYEXCH_up_ref, EVP_KEYEXCH_provider
+EVP_KEYEXCH_fetch, EVP_KEYEXCH_free, EVP_KEYEXCH_up_ref, EVP_KEYEXCH_provider,
+EVP_KEYEXCH_is_a, EVP_KEYEXCH_do_all_provided,
+EVP_KEYEXCH_number, EVP_KEYEXCH_names_do_all
 - Functions to manage EVP_KEYEXCH algorithm objects
 
 =head1 SYNOPSIS
@@ -14,12 +16,20 @@ EVP_KEYEXCH_fetch, EVP_KEYEXCH_free, EVP_KEYEXCH_up_ref, EVP_KEYEXCH_provider
  void EVP_KEYEXCH_free(EVP_KEYEXCH *exchange);
  int EVP_KEYEXCH_up_ref(EVP_KEYEXCH *exchange);
  OSSL_PROVIDER *EVP_KEYEXCH_provider(const EVP_KEYEXCH *exchange);
+ int EVP_KEYEXCH_is_a(const EVP_KEYEXCH *exchange, const char *name);
+ int EVP_KEYEXCH_number(const EVP_KEYEXCH *exchange);
+ void EVP_KEYEXCH_do_all_provided(OPENSSL_CTX *libctx,
+                                  void (*fn)(EVP_KEYEXCH *exchange, void *arg),
+                                  void *arg);
+ void EVP_KEYEXCH_names_do_all(const EVP_KEYEXCH *exchange,
+                               void (*fn)(const char *name, void *data),
+                               void *data);
 
 =head1 DESCRIPTION
 
 EVP_KEYEXCH_fetch() fetches the key exchange implementation for the given
-B&lt;algorithm&gt; from any provider offering it, within the criteria given
-by the B&lt;properties&gt;.
+I&lt;algorithm&gt; from any provider offering it, within the criteria given
+by the I&lt;properties&gt;.
 See L&lt;provider(7)/Fetching algorithms&gt; for further information.
 
 The returned value must eventually be freed with EVP_KEYEXCH_free().
@@ -34,13 +44,32 @@ structure.
 
 EVP_KEYEXCH_provider() returns the provider that I&lt;exchange&gt; was fetched from.
 
+EVP_KEYEXCH_is_a() checks if I&lt;exchange&gt; is an implementation of an
+algorithm that's identifiable with I&lt;name&gt;.
+
+EVP_KEYEXCH_number() returns the internal dynamic number assigned to
+the I&lt;exchange&gt;.
+
+EVP_KEYEXCH_names_do_all() traverses all names for the I&lt;exchange&gt;, and
+calls I&lt;fn&gt; with each name and I&lt;data&gt;.
+
+EVP_KEYEXCH_do_all_provided() traverses all key exchange implementations by
+all activated providers in the library context I&lt;libctx&gt;, and for each
+of the implementations, calls I&lt;fn&gt; with the implementation method and
+I&lt;data&gt; as arguments.
+
 =head1 RETURN VALUES
 
 EVP_KEYEXCH_fetch() returns a pointer to a B&lt;EVP_KEYEXCH&gt; for success
-or B&lt;NULL&gt; for failure.
+or NULL for failure.
 
 EVP_KEYEXCH_up_ref() returns 1 for success or 0 otherwise.
 
+EVP_KEYEXCH_is_a() returns 1 of I&lt;exchange&gt; was identifiable,
+otherwise 0.
+
+EVP_KEYEXCH_number() returns an integer.
+
 =head1 SEE ALSO
 
 L&lt;provider(7)/Fetching algorithms&gt;, L&lt;OSSL_PROVIDER(3)&gt;
diff --git a/doc/man3/EVP_KEYMGMT.pod b/doc/man3/EVP_KEYMGMT.pod
index ab209da768..853a15f089 100644
--- a/doc/man3/EVP_KEYMGMT.pod
+++ b/doc/man3/EVP_KEYMGMT.pod
@@ -6,7 +6,11 @@ EVP_KEYMGMT,
 EVP_KEYMGMT_fetch,
 EVP_KEYMGMT_up_ref,
 EVP_KEYMGMT_free,
-EVP_KEYMGMT_provider
+EVP_KEYMGMT_provider,
+EVP_KEYMGMT_is_a,
+EVP_KEYMGMT_number,
+EVP_KEYMGMT_do_all_provided,
+EVP_KEYMGMT_names_do_all
 - EVP key management routines
 
 =head1 SYNOPSIS
@@ -20,6 +24,14 @@ EVP_KEYMGMT_provider
  int EVP_KEYMGMT_up_ref(EVP_KEYMGMT *keymgmt);
  void EVP_KEYMGMT_free(EVP_KEYMGMT *keymgmt);
  const OSSL_PROVIDER *EVP_KEYMGMT_provider(const EVP_KEYMGMT *keymgmt);
+ int EVP_KEYMGMT_is_a(const EVP_KEYMGMT *keymgmt, const char *name);
+ int EVP_KEYMGMT_number(const EVP_KEYMGMT *keymgmt);
+ void EVP_KEYMGMT_do_all_provided(OPENSSL_CTX *libctx,
+                                  void (*fn)(EVP_KEYMGMT *keymgmt, void *arg),
+                                  void *arg);
+ void EVP_KEYMGMT_names_do_all(const EVP_KEYMGMT *keymgmt,
+                               void (*fn)(const char *name, void *data),
+                               void *data);
 
 =head1 DESCRIPTION
 
@@ -45,6 +57,20 @@ B&lt;EVP_KEYMGMT&gt; I&lt;keymgmt&gt;, and when the count reaches zero, frees it.
 EVP_KEYMGMT_provider() returns the provider that has this particular
 implementation.
 
+EVP_KEYMGMT_is_a() checks if I&lt;keymgmt&gt; is an implementation of an
+algorithm that's identifiable with I&lt;name&gt;.
+
+EVP_KEYMGMT_number() returns the internal dynamic number assigned to
+the I&lt;keymgmt&gt;.
+
+EVP_KEYMGMT_names_do_all() traverses all names for the I&lt;keymgmt&gt;, and
+calls I&lt;fn&gt; with each name and I&lt;data&gt;.
+
+EVP_KEYMGMT_do_all_provided() traverses all key keymgmt implementations by
+all activated providers in the library context I&lt;libctx&gt;, and for each
+of the implementations, calls I&lt;fn&gt; with the implementation method and
+I&lt;data&gt; as arguments.
+
 =head1 NOTES
 
 EVP_KEYMGMT_fetch() may be called implicitly by other fetching
@@ -64,6 +90,11 @@ EVP_KEYMGMT_free() doesn't return any value.
 EVP_KEYMGMT_provider() returns a pointer to a provider object, or NULL
 on error.
 
+EVP_KEYMGMT_is_a() returns 1 of I&lt;keymgmt&gt; was identifiable,
+otherwise 0.
+
+EVP_KEYMGMT_number() returns an integer.
+
 =head1 SEE ALSO
 
 L&lt;EVP_MD_fetch(3)&gt;, L&lt;OPENSSL_CTX(3)&gt;
diff --git a/doc/man3/EVP_MAC.pod b/doc/man3/EVP_MAC.pod
index c2087546ea..1081314879 100644
--- a/doc/man3/EVP_MAC.pod
+++ b/doc/man3/EVP_MAC.pod
@@ -3,13 +3,13 @@
 =head1 NAME
 
 EVP_MAC, EVP_MAC_fetch, EVP_MAC_up_ref, EVP_MAC_free,
-EVP_MAC_is_a, EVP_MAC_name,
+EVP_MAC_is_a, EVP_MAC_number, EVP_MAC_names_do_all,
 EVP_MAC_provider, EVP_MAC_get_params, EVP_MAC_gettable_params,
 EVP_MAC_CTX, EVP_MAC_CTX_new, EVP_MAC_CTX_free, EVP_MAC_CTX_dup,
 EVP_MAC_CTX_mac, EVP_MAC_CTX_get_params, EVP_MAC_CTX_set_params,
 EVP_MAC_size, EVP_MAC_init, EVP_MAC_update, EVP_MAC_final,
 EVP_MAC_gettable_ctx_params, EVP_MAC_settable_ctx_params,
-EVP_MAC_do_all_ex - EVP MAC routines
+EVP_MAC_do_all_provided - EVP MAC routines
 
 =head1 SYNOPSIS
 
@@ -23,7 +23,10 @@ EVP_MAC_do_all_ex - EVP MAC routines
  int EVP_MAC_up_ref(EVP_MAC *mac);
  void EVP_MAC_free(EVP_MAC *mac);
  int EVP_MAC_is_a(const EVP_MAC *mac, const char *name);
- const char *EVP_MAC_name(const EVP_MAC *mac);
+ int EVP_MAC_number(const EVP_MAC *mac);
+ void EVP_MAC_names_do_all(const EVP_MAC *mac,
+                           void (*fn)(const char *name, void *data),
+                           void *data);
  const OSSL_PROVIDER *EVP_MAC_provider(const EVP_MAC *mac);
  int EVP_MAC_get_params(EVP_MAC *mac, OSSL_PARAM params[]);
 
@@ -44,9 +47,9 @@ EVP_MAC_do_all_ex - EVP MAC routines
  const OSSL_PARAM *EVP_MAC_gettable_ctx_params(const EVP_MAC *mac);
  const OSSL_PARAM *EVP_MAC_settable_ctx_params(const EVP_MAC *mac);
 
- void EVP_MAC_do_all_ex(OPENSSL_CTX *libctx,
-                        void (*fn)(EVP_MAC *mac, void *arg),
-                        void *arg);
+ void EVP_MAC_do_all_provided(OPENSSL_CTX *libctx,
+                              void (*fn)(EVP_MAC *mac, void *arg),
+                              void *arg);
 
 =head1 DESCRIPTION
 
@@ -116,10 +119,10 @@ EVP_MAC_update() adds I&lt;datalen&gt; bytes from I&lt;data&gt; to the MAC input.
 EVP_MAC_final() does the final computation and stores the result in
 the memory pointed at by I&lt;out&gt; of size I&lt;outsize&gt;, and sets the number
 of bytes written in I&lt;*outl&gt; at.
-If I&lt;out&gt; is B&lt;NULL&gt; or I&lt;outsize&gt; is too small, then no computation
+If I&lt;out&gt; is NULL or I&lt;outsize&gt; is too small, then no computation
 is made.
 To figure out what the output length will be and allocate space for it
-dynamically, simply call with I&lt;out&gt; being B&lt;NULL&gt; and I&lt;outl&gt;
+dynamically, simply call with I&lt;out&gt; being NULL and I&lt;outl&gt;
 pointing at a valid location, then allocate space and make a second
 call with I&lt;out&gt; pointing at the allocated space.
 
@@ -157,19 +160,23 @@ See L&lt;OSSL_PARAM(3)&gt; for the use of B&lt;OSSL_PARAM&gt; as parameter descriptor.
 
 EVP_MAC_size() returns the MAC output size for the given context.
 
-EVP_MAC_name() returns the name of the given MAC implementation.
-
 EVP_MAC_is_a() checks if the given I&lt;mac&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;.
 
 EVP_MAC_provider() returns the provider that holds the implementation
 of the given I&lt;mac&gt;.
 
-EVP_MAC_do_all_ex() traverses all MAC implemented by all activated
+EVP_MAC_do_all_provided() traverses all MAC implemented by all activated
 providers in the given library context I&lt;libctx&gt;, and for each of the
 implementations, calls the given function I&lt;fn&gt; with the implementation method
 and the given I&lt;arg&gt; as argument.
 
+EVP_MAC_number() returns the internal dynamic number assigned to
+I&lt;mac&gt;.
+
+EVP_MAC_names_do_all() traverses all names for I&lt;mac&gt;, and calls
+I&lt;fn&gt; with each name and I&lt;data&gt;.
+
 =head1 PARAMETERS
 
 Parameters are identified by name as strings, and have an expected
@@ -254,9 +261,6 @@ EVP_MAC_up_ref() returns 1 on success, 0 on error.
 
 EVP_MAC_free() returns nothing at all.
 
-EVP_MAC_name() returns the name of the MAC, or NULL if NULL was
-passed.
-
 EVP_MAC_is_a() returns 1 if the given method can be identified with
 the given name, otherwise 0.
 
@@ -278,7 +282,7 @@ EVP_MAC_size() returns the expected output size, or 0 if it isn't
 set.
 If it isn't set, a call to EVP_MAC_init() should get it set.
 
-EVP_MAC_do_all_ex() returns nothing at all.
+EVP_MAC_do_all_provided() returns nothing at all.
 
 =head1 EXAMPLES
 
diff --git a/doc/man3/EVP_SIGNATURE_free.pod b/doc/man3/EVP_SIGNATURE_free.pod
index 3e39b915e7..70a0ee72dc 100644
--- a/doc/man3/EVP_SIGNATURE_free.pod
+++ b/doc/man3/EVP_SIGNATURE_free.pod
@@ -3,7 +3,8 @@
 =head1 NAME
 
 EVP_SIGNATURE_fetch, EVP_SIGNATURE_free, EVP_SIGNATURE_up_ref,
-EVP_SIGNATURE_provider
+EVP_SIGNATURE_number, EVP_SIGNATURE_is_a, EVP_SIGNATURE_provider,
+EVP_SIGNATURE_do_all_provided, EVP_SIGNATURE_names_do_all
 - Functions to manage EVP_SIGNATURE algorithm objects
 
 =head1 SYNOPSIS
@@ -14,7 +15,16 @@ EVP_SIGNATURE_provider
                                     const char *properties);
  void EVP_SIGNATURE_free(EVP_SIGNATURE *signature);
  int EVP_SIGNATURE_up_ref(EVP_SIGNATURE *signature);
+ int EVP_SIGNATURE_number(const EVP_SIGNATURE *signature);
+ int EVP_SIGNATURE_is_a(const EVP_SIGNATURE *signature, const char *name);
  OSSL_PROVIDER *EVP_SIGNATURE_provider(const EVP_SIGNATURE *signature);
+ void EVP_SIGNATURE_do_all_provided(OPENSSL_CTX *libctx,
+                                    void (*fn)(EVP_SIGNATURE *signature,
+                                               void *arg),
+                                    void *arg);
+ void EVP_SIGNATURE_names_do_all(const EVP_SIGNATURE *signature,
+                                 void (*fn)(const char *name, void *data),
+                                 void *data);
 
 =head1 DESCRIPTION
 
@@ -35,8 +45,22 @@ structure is freed.
 EVP_SIGNATURE_up_ref() increments the reference count for an B&lt;EVP_SIGNATURE&gt;
 structure.
 
+EVP_SIGNATURE_is_a() returns 1 if I&lt;signature&gt; is an implementation of an
+algorithm that's identifiable with I&lt;name&gt;, otherwise 0.
+
 EVP_SIGNATURE_provider() returns the provider that I&lt;signature&gt; was fetched from.
 
+EVP_SIGNATURE_do_all_provided() traverses all SIGNATURE implemented by all
+activated roviders in the given library context I&lt;libctx&gt;, and for each of the
+implementations, calls the given function I&lt;fn&gt; with the implementation method
+and the given I&lt;arg&gt; as argument.
+
+EVP_SIGNATURE_number() returns the internal dynamic number assigned to
+I&lt;signature&gt;.
+
+EVP_SIGNATURE_names_do_all() traverses all names for I&lt;signature&gt;, and calls
+I&lt;fn&gt; with each name and I&lt;data&gt;.
+
 =head1 RETURN VALUES
 
 EVP_SIGNATURE_fetch() returns a pointer to an B&lt;EVP_SIGNATURE&gt; for success
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 9223df2f78..a0190c8b08 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -462,6 +462,11 @@ typedef int (EVP_PBE_KEYGEN) (EVP_CIPHER_CTX *ctx, const char *pass,
 int EVP_MD_type(const EVP_MD *md);
 # define EVP_MD_nid(e)                   EVP_MD_type(e)
 const char *EVP_MD_name(const EVP_MD *md);
+int EVP_MD_number(const EVP_MD *md);
+int EVP_MD_is_a(const EVP_MD *md, const char *name);
+void EVP_MD_names_do_all(const EVP_MD *md,
+                         void (*fn)(const char *name, void *data),
+                         void *data);
 const OSSL_PROVIDER *EVP_MD_provider(const EVP_MD *md);
 int EVP_MD_pkey_type(const EVP_MD *md);
 int EVP_MD_size(const EVP_MD *md);
@@ -484,7 +489,11 @@ void *EVP_MD_CTX_md_data(const EVP_MD_CTX *ctx);
 
 int EVP_CIPHER_nid(const EVP_CIPHER *cipher);
 const char *EVP_CIPHER_name(const EVP_CIPHER *cipher);
+int EVP_CIPHER_number(const EVP_CIPHER *cipher);
 int EVP_CIPHER_is_a(const EVP_CIPHER *cipher, const char *name);
+void EVP_CIPHER_names_do_all(const EVP_CIPHER *cipher,
+                             void (*fn)(const char *name, void *data),
+                             void *data);
 const OSSL_PROVIDER *EVP_CIPHER_provider(const EVP_CIPHER *cipher);
 int EVP_CIPHER_block_size(const EVP_CIPHER *cipher);
 int EVP_CIPHER_impl_ctx_size(const EVP_CIPHER *cipher);
@@ -1031,9 +1040,9 @@ void EVP_CIPHER_do_all(void (*fn) (const EVP_CIPHER *ciph,
 void EVP_CIPHER_do_all_sorted(void (*fn)
                                (const EVP_CIPHER *ciph, const char *from,
                                 const char *to, void *x), void *arg);
-void EVP_CIPHER_do_all_ex(OPENSSL_CTX *libctx,
-                          void (*fn)(EVP_CIPHER *cipher, void *arg),
-                          void *arg);
+void EVP_CIPHER_do_all_provided(OPENSSL_CTX *libctx,
+                                void (*fn)(EVP_CIPHER *cipher, void *arg),
+                                void *arg);
 
 void EVP_MD_do_all(void (*fn) (const EVP_MD *ciph,
                                const char *from, const char *to, void *x),
@@ -1041,9 +1050,9 @@ void EVP_MD_do_all(void (*fn) (const EVP_MD *ciph,
 void EVP_MD_do_all_sorted(void (*fn)
                            (const EVP_MD *ciph, const char *from,
                             const char *to, void *x), void *arg);
-void EVP_MD_do_all_ex(OPENSSL_CTX *libctx,
-                      void (*fn)(EVP_MD *md, void *arg),
-                      void *arg);
+void EVP_MD_do_all_provided(OPENSSL_CTX *libctx,
+                            void (*fn)(EVP_MD *md, void *arg),
+                            void *arg);
 
 /* MAC stuff */
 
@@ -1051,7 +1060,7 @@ EVP_MAC *EVP_MAC_fetch(OPENSSL_CTX *libctx, const char *algorithm,
                        const char *properties);
 int EVP_MAC_up_ref(EVP_MAC *mac);
 void EVP_MAC_free(EVP_MAC *mac);
-const char *EVP_MAC_name(const EVP_MAC *mac);
+int EVP_MAC_number(const EVP_MAC *mac);
 int EVP_MAC_is_a(const EVP_MAC *mac, const char *name);
 const OSSL_PROVIDER *EVP_MAC_provider(const EVP_MAC *mac);
 int EVP_MAC_get_params(EVP_MAC *mac, OSSL_PARAM params[]);
@@ -1072,9 +1081,12 @@ const OSSL_PARAM *EVP_MAC_gettable_params(const EVP_MAC *mac);
 const OSSL_PARAM *EVP_MAC_gettable_ctx_params(const EVP_MAC *mac);
 const OSSL_PARAM *EVP_MAC_settable_ctx_params(const EVP_MAC *mac);
 
-void EVP_MAC_do_all_ex(OPENSSL_CTX *libctx,
-                       void (*fn)(EVP_MAC *mac, void *arg),
-                       void *arg);
+void EVP_MAC_do_all_provided(OPENSSL_CTX *libctx,
+                             void (*fn)(EVP_MAC *mac, void *arg),
+                             void *arg);
+void EVP_MAC_names_do_all(const EVP_MAC *mac,
+                          void (*fn)(const char *name, void *data),
+                          void *data);
 
 /* PKEY stuff */
 int EVP_PKEY_decrypt_old(unsigned char *dec_key,
@@ -1438,6 +1450,14 @@ EVP_KEYMGMT *EVP_KEYMGMT_fetch(OPENSSL_CTX *ctx, const char *algorithm,
 int EVP_KEYMGMT_up_ref(EVP_KEYMGMT *keymgmt);
 void EVP_KEYMGMT_free(EVP_KEYMGMT *keymgmt);
 const OSSL_PROVIDER *EVP_KEYMGMT_provider(const EVP_KEYMGMT *keymgmt);
+int EVP_KEYMGMT_number(const EVP_KEYMGMT *keymgmt);
+int EVP_KEYMGMT_is_a(const EVP_KEYMGMT *keymgmt, const char *name);
+void EVP_KEYMGMT_do_all_provided(OPENSSL_CTX *libctx,
+                                 void (*fn)(EVP_KEYMGMT *keymgmt, void *arg),
+                                 void *arg);
+void EVP_KEYMGMT_names_do_all(const EVP_KEYMGMT *keymgmt,
+                              void (*fn)(const char *name, void *data),
+                              void *data);
 
 EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);
 EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);
@@ -1495,6 +1515,15 @@ int EVP_SIGNATURE_up_ref(EVP_SIGNATURE *signature);
 OSSL_PROVIDER *EVP_SIGNATURE_provider(const EVP_SIGNATURE *signature);
 EVP_SIGNATURE *EVP_SIGNATURE_fetch(OPENSSL_CTX *ctx, const char *algorithm,
                                    const char *properties);
+int EVP_SIGNATURE_is_a(const EVP_SIGNATURE *signature, const char *name);
+int EVP_SIGNATURE_number(const EVP_SIGNATURE *signature);
+void EVP_SIGNATURE_do_all_provided(OPENSSL_CTX *libctx,
+                                   void (*fn)(EVP_SIGNATURE *signature,
+                                              void *data),
+                                   void *data);
+void EVP_SIGNATURE_names_do_all(const EVP_SIGNATURE *signature,
+                                void (*fn)(const char *name, void *data),
+                                void *data);
 
 int EVP_PKEY_sign_init_ex(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature);
 int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
@@ -1755,6 +1784,14 @@ int EVP_KEYEXCH_up_ref(EVP_KEYEXCH *exchange);
 EVP_KEYEXCH *EVP_KEYEXCH_fetch(OPENSSL_CTX *ctx, const char *algorithm,
                                const char *properties);
 OSSL_PROVIDER *EVP_KEYEXCH_provider(const EVP_KEYEXCH *exchange);
+int EVP_KEYEXCH_is_a(const EVP_KEYEXCH *keyexch, const char *name);
+int EVP_KEYEXCH_number(const EVP_KEYEXCH *keyexch);
+void EVP_KEYEXCH_do_all_provided(OPENSSL_CTX *libctx,
+                                 void (*fn)(EVP_KEYEXCH *keyexch, void *data),
+                                 void *data);
+void EVP_KEYEXCH_names_do_all(const EVP_KEYEXCH *keyexch,
+                              void (*fn)(const char *name, void *data),
+                              void *data);
 
 void EVP_add_alg_module(void);
 
diff --git a/include/openssl/kdf.h b/include/openssl/kdf.h
index 2193eaeec0..b80f6b3e0f 100644
--- a/include/openssl/kdf.h
+++ b/include/openssl/kdf.h
@@ -33,7 +33,8 @@ EVP_KDF *EVP_KDF_fetch(OPENSSL_CTX *libctx, const char *algorithm,
 EVP_KDF_CTX *EVP_KDF_CTX_new(EVP_KDF *kdf);
 void EVP_KDF_CTX_free(EVP_KDF_CTX *ctx);
 EVP_KDF_CTX *EVP_KDF_CTX_dup(const EVP_KDF_CTX *src);
-const char *EVP_KDF_name(const EVP_KDF *kdf);
+int EVP_KDF_number(const EVP_KDF *kdf);
+int EVP_KDF_is_a(const EVP_KDF *kdf, const char *name);
 const OSSL_PROVIDER *EVP_KDF_provider(const EVP_KDF *kdf);
 const EVP_KDF *EVP_KDF_CTX_kdf(EVP_KDF_CTX *ctx);
 
@@ -47,9 +48,12 @@ const OSSL_PARAM *EVP_KDF_gettable_params(const EVP_KDF *kdf);
 const OSSL_PARAM *EVP_KDF_gettable_ctx_params(const EVP_KDF *kdf);
 const OSSL_PARAM *EVP_KDF_settable_ctx_params(const EVP_KDF *kdf);
 
-void EVP_KDF_do_all_ex(OPENSSL_CTX *libctx,
-                       void (*fn)(EVP_KDF *kdf, void *arg),
-                       void *arg);
+void EVP_KDF_do_all_provided(OPENSSL_CTX *libctx,
+                             void (*fn)(EVP_KDF *kdf, void *arg),
+                             void *arg);
+void EVP_KDF_names_do_all(const EVP_KDF *kdf,
+                          void (*fn)(const char *name, void *data),
+                          void *data);
 
 # define EVP_KDF_CTRL_SET_PASS               0x01 /* unsigned char *, size_t */
 # define EVP_KDF_CTRL_SET_SALT               0x02 /* unsigned char *, size_t */
diff --git a/test/evp_test.c b/test/evp_test.c
index d6f852913c..b68ad3b9c4 100644
--- a/test/evp_test.c
+++ b/test/evp_test.c
@@ -938,6 +938,7 @@ static const EVP_TEST_METHOD cipher_test_method = {
 
 typedef struct mac_data_st {
     /* MAC type in one form or another */
+    char *mac_name;
     EVP_MAC *mac;                /* for mac_test_run_mac */
     int type;                    /* for mac_test_run_pkey */
     /* Algorithm string for this MAC */
@@ -1021,6 +1022,7 @@ static int mac_test_init(EVP_TEST *t, const char *alg)
 
     mdat = OPENSSL_zalloc(sizeof(*mdat));
     mdat-&gt;type = type;
+    mdat-&gt;mac_name = OPENSSL_strdup(alg);
     mdat-&gt;mac = mac;
     mdat-&gt;controls = sk_OPENSSL_STRING_new_null();
     t-&gt;data = mdat;
@@ -1038,6 +1040,7 @@ static void mac_test_cleanup(EVP_TEST *t)
     MAC_DATA *mdat = t-&gt;data;
 
     EVP_MAC_free(mdat-&gt;mac);
+    OPENSSL_free(mdat-&gt;mac_name);
     sk_OPENSSL_STRING_pop_free(mdat-&gt;controls, openssl_free);
     OPENSSL_free(mdat-&gt;alg);
     OPENSSL_free(mdat-&gt;key);
@@ -1198,10 +1201,10 @@ static int mac_test_run_mac(EVP_TEST *t)
         EVP_MAC_settable_ctx_params(expected-&gt;mac);
 
     if (expected-&gt;alg == NULL)
-        TEST_info(&quot;Trying the EVP_MAC %s test&quot;, EVP_MAC_name(expected-&gt;mac));
+        TEST_info(&quot;Trying the EVP_MAC %s test&quot;, expected-&gt;mac_name);
     else
         TEST_info(&quot;Trying the EVP_MAC %s test with %s&quot;,
-                  EVP_MAC_name(expected-&gt;mac), expected-&gt;alg);
+                  expected-&gt;mac_name, expected-&gt;alg);
 
 #ifdef OPENSSL_NO_DES
     if (expected-&gt;alg != NULL &amp;&amp; strstr(expected-&gt;alg, &quot;DES&quot;) != NULL) {
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 032936ed40..3f76771b4d 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4683,8 +4683,8 @@ EVP_CIPHER_name                         4799	3_0_0	EXIST::FUNCTION:
 EVP_MD_provider                         4800	3_0_0	EXIST::FUNCTION:
 EVP_CIPHER_provider                     4801	3_0_0	EXIST::FUNCTION:
 OSSL_PROVIDER_name                      4802	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_do_all_ex                    4803	3_0_0	EXIST::FUNCTION:
-EVP_MD_do_all_ex                        4804	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_do_all_provided              4803	3_0_0	EXIST::FUNCTION:
+EVP_MD_do_all_provided                  4804	3_0_0	EXIST::FUNCTION:
 EVP_KEYEXCH_provider                    4805	3_0_0	EXIST::FUNCTION:
 OSSL_PROVIDER_available                 4806	3_0_0	EXIST::FUNCTION:
 ERR_new                                 4807	3_0_0	EXIST::FUNCTION:
@@ -4718,18 +4718,18 @@ EVP_MAC_CTX_get_params                  4834	3_0_0	EXIST::FUNCTION:
 EVP_MAC_gettable_ctx_params             4835	3_0_0	EXIST::FUNCTION:
 EVP_MAC_free                            4836	3_0_0	EXIST::FUNCTION:
 EVP_MAC_up_ref                          4837	3_0_0	EXIST::FUNCTION:
-EVP_MAC_name                            4838	3_0_0	EXIST::FUNCTION:
+EVP_MAC_name                            4838	3_0_0	NOEXIST::FUNCTION:
 EVP_MAC_get_params                      4839	3_0_0	EXIST::FUNCTION:
 EVP_MAC_gettable_params                 4840	3_0_0	EXIST::FUNCTION:
 EVP_MAC_provider                        4841	3_0_0	EXIST::FUNCTION:
-EVP_MAC_do_all_ex                       4842	3_0_0	EXIST::FUNCTION:
+EVP_MAC_do_all_provided                 4842	3_0_0	EXIST::FUNCTION:
 EVP_MD_free                             4843	3_0_0	EXIST::FUNCTION:
 EVP_CIPHER_free                         4844	3_0_0	EXIST::FUNCTION:
 EVP_KDF_up_ref                          4845	3_0_0	EXIST::FUNCTION:
 EVP_KDF_free                            4846	3_0_0	EXIST::FUNCTION:
 EVP_KDF_fetch                           4847	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_dup                         4848	3_0_0	EXIST::FUNCTION:
-EVP_KDF_name                            4849	3_0_0	EXIST::FUNCTION:
+EVP_KDF_name                            4849	3_0_0	NOEXIST::FUNCTION:
 EVP_KDF_provider                        4850	3_0_0	EXIST::FUNCTION:
 EVP_KDF_get_params                      4851	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_get_params                  4852	3_0_0	EXIST::FUNCTION:
@@ -4737,7 +4737,7 @@ EVP_KDF_CTX_set_params                  4853	3_0_0	EXIST::FUNCTION:
 EVP_KDF_gettable_params                 4854	3_0_0	EXIST::FUNCTION:
 EVP_KDF_gettable_ctx_params             4855	3_0_0	EXIST::FUNCTION:
 EVP_KDF_settable_ctx_params             4856	3_0_0	EXIST::FUNCTION:
-EVP_KDF_do_all_ex                       4857	3_0_0	EXIST::FUNCTION:
+EVP_KDF_do_all_provided                 4857	3_0_0	EXIST::FUNCTION:
 EVP_SIGNATURE_free                      4858	3_0_0	EXIST::FUNCTION:
 EVP_SIGNATURE_up_ref                    4859	3_0_0	EXIST::FUNCTION:
 EVP_SIGNATURE_provider                  4860	3_0_0	EXIST::FUNCTION:
@@ -4828,3 +4828,25 @@ EVP_DigestVerifyInit_ex                 4944	3_0_0	EXIST::FUNCTION:
 EVP_DigestVerifyUpdate                  4945	3_0_0	EXIST::FUNCTION:
 BN_check_prime                          4946	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_new_provided               4947	3_0_0	EXIST::FUNCTION:
+EVP_KEYMGMT_is_a                        4948	3_0_0	EXIST::FUNCTION:
+EVP_KEYMGMT_do_all_provided             4949	3_0_0	EXIST::FUNCTION:
+EVP_KEYEXCH_is_a                        4950	3_0_0	EXIST::FUNCTION:
+EVP_KEYEXCH_do_all_provided             4951	3_0_0	EXIST::FUNCTION:
+EVP_KDF_is_a                            4952	3_0_0	EXIST::FUNCTION:
+EVP_MD_is_a                             4953	3_0_0	EXIST::FUNCTION:
+EVP_SIGNATURE_is_a                      4954	3_0_0	EXIST::FUNCTION:
+EVP_SIGNATURE_do_all_provided           4955	3_0_0	EXIST::FUNCTION:
+EVP_MD_names_do_all                     4956	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_names_do_all                 4957	3_0_0	EXIST::FUNCTION:
+EVP_MAC_names_do_all                    4958	3_0_0	EXIST::FUNCTION:
+EVP_KEYMGMT_names_do_all                4959	3_0_0	EXIST::FUNCTION:
+EVP_KEYEXCH_names_do_all                4960	3_0_0	EXIST::FUNCTION:
+EVP_KDF_names_do_all                    4961	3_0_0	EXIST::FUNCTION:
+EVP_SIGNATURE_names_do_all              4962	3_0_0	EXIST::FUNCTION:
+EVP_MD_number                           4963	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_number                       4964	3_0_0	EXIST::FUNCTION:
+EVP_MAC_number                          4965	3_0_0	EXIST::FUNCTION:
+EVP_KEYMGMT_number                      4966	3_0_0	EXIST::FUNCTION:
+EVP_KEYEXCH_number                      4967	3_0_0	EXIST::FUNCTION:
+EVP_KDF_number                          4968	3_0_0	EXIST::FUNCTION:
+EVP_SIGNATURE_number                    4969	3_0_0	EXIST::FUNCTION:
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="025678.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="025680.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25679">[ date ]</a>
              <a href="thread.html#25679">[ thread ]</a>
              <a href="subject.html#25679">[ subject ]</a>
              <a href="author.html#25679">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
