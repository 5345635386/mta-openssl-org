<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2021-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1621412081.020643.26141.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="034320.html">
   <LINK REL="Next"  HREF="034322.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1621412081.020643.26141.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Wed May 19 08:14:41 UTC 2021</I>
    <P><UL>
        <LI>Previous message: <A HREF="034320.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="034322.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34321">[ date ]</a>
              <a href="thread.html#34321">[ thread ]</a>
              <a href="subject.html#34321">[ subject ]</a>
              <a href="author.html#34321">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  2660b7cfbad710dcd9df26e68c18d6c7d6ebaca0 (commit)
       via  da51dc5f68c9e7924be3d5071ba8aea439a4d1c9 (commit)
      from  8a734d3aaf4e4784581b87cdf2a4b3e2c2403b97 (commit)


- Log -----------------------------------------------------------------
commit 2660b7cfbad710dcd9df26e68c18d6c7d6ebaca0
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon May 17 14:33:16 2021 +0200

    Rework how a build file (Makefile, ...) is produced
    
    The memory footprint of how we produced the Makefile was quite...
    important, because we have all the processing in one perl snippet, and
    generate the details of the build file by appending to the &quot;magic&quot;
    variable $OUT.  The result is that this variable gets to hold the
    majority of the build file text, and depending on memory reallocation
    strategies for strings, the heap may hold multiple (possibly not just
    a few) copies of this string, almost all of them &quot;freed&quot; but still
    taking up space.  This has resulted in memory exhaustion.
    
    We therefore change strategy, and generate the build file in two
    phases, where the first phase generates the full template using small
    perl snippets for each detail, and the second phase processes this
    template.  This is much kinder to process memory.
    
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tomas at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15310">https://github.com/openssl/openssl/pull/15310</A>)

commit da51dc5f68c9e7924be3d5071ba8aea439a4d1c9
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon May 17 14:25:12 2021 +0200

    Move some OpenSSL perl utility functions to OpenSSL::Util
    
    quotify1() and quotify_l() were in OpenSSL::Template, but should be
    more widely usable.
    
    configdata.pm.in's out_item() is also more widely useful and is
    therefore moved to OpenSSL::Util as well, and renamed to dump_data().
    
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tomas at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15310">https://github.com/openssl/openssl/pull/15310</A>)

-----------------------------------------------------------------------

Summary of changes:
 .gitignore                           |   1 +
 Configurations/common.tmpl           | 492 -------------------------------
 Configurations/descrip.mms.tmpl      |   1 +
 Configurations/gentemplate.pm        | 549 +++++++++++++++++++++++++++++++++++
 Configurations/unix-Makefile.tmpl    |   2 +
 Configurations/windows-makefile.tmpl |   1 +
 Configure                            |   6 +-
 configdata.pm.in                     | 162 ++++-------
 tools/c_rehash.in                    |   2 +-
 util/perl/OpenSSL/Template.pm        |  45 ---
 util/perl/OpenSSL/Util.pm            | 136 ++++++++-
 11 files changed, 754 insertions(+), 643 deletions(-)
 delete mode 100644 Configurations/common.tmpl
 create mode 100644 Configurations/gentemplate.pm

diff --git a/.gitignore b/.gitignore
index b88ede1d59..038ccb9773 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,7 @@
 /.dir-locals.el
 
 # Top level excludes
+/Makefile.in
 /Makefile
 /MINFO
 /TABLE
diff --git a/Configurations/common.tmpl b/Configurations/common.tmpl
deleted file mode 100644
index 32190352aa..0000000000
--- a/Configurations/common.tmpl
+++ /dev/null
@@ -1,492 +0,0 @@
-{- # -*- Mode: perl -*-
-
- use File::Basename;
-
- my $debug_resolvedepends = $ENV{BUILDFILE_DEBUG_DEPENDS};
- my $debug_rules = $ENV{BUILDFILE_DEBUG_RULES};
-
- # A cache of objects for which a recipe has already been generated
- my %cache;
-
- # collectdepends, expanddepends and reducedepends work together to make
- # sure there are no duplicate or weak dependencies and that they are in
- # the right order.  This is used to sort the list of libraries  that a
- # build depends on.
- sub extensionlesslib {
-     my @result = map { $_ =~ /(\.a)?$/; $` } @_;
-     return @result if wantarray;
-     return $result[0];
- }
-
- # collectdepends dives into the tree of dependencies and returns
- # a list of all the non-weak ones.
- sub collectdepends {
-     return () unless @_;
-
-     my $thing = shift;
-     my $extensionlessthing = extensionlesslib($thing);
-     my @listsofar = @_;    # to check if we're looping
-     my @list = @{$unified_info{depends}-&gt;{$thing} //
-                      $unified_info{depends}-&gt;{$extensionlessthing}};
-     my @newlist = ();
-
-     print STDERR &quot;DEBUG[collectdepends] $thing &gt; &quot;, join(' ', @listsofar), &quot;\n&quot;
-         if $debug_resolvedepends;
-     foreach my $item (@list) {
-         my $extensionlessitem = extensionlesslib($item);
-         # It's time to break off when the dependency list starts looping
-         next if grep { extensionlesslib($_) eq $extensionlessitem } @listsofar;
-         # Don't add anything here if the dependency is weak
-         next if defined $unified_info{attributes}-&gt;{depends}-&gt;{$thing}-&gt;{$item}-&gt;{'weak'};
-         my @resolved = collectdepends($item, @listsofar, $item);
-         push @newlist, $item, @resolved;
-     }
-     print STDERR &quot;DEBUG[collectdepends] $thing &lt; &quot;, join(' ', @newlist), &quot;\n&quot;
-         if $debug_resolvedepends;
-     @newlist;
- }
-
- # expanddepends goes through a list of stuff, checks if they have any
- # dependencies, and adds them at the end of the current position if
- # they aren't already present later on.
- sub expanddepends {
-     my @after = ( @_ );
-     print STDERR &quot;DEBUG[expanddepends]&gt; &quot;, join(' ', @after), &quot;\n&quot;
-         if $debug_resolvedepends;
-     my @before = ();
-     while (@after) {
-         my $item = shift @after;
-         print STDERR &quot;DEBUG[expanddepends]\\  &quot;, join(' ', @before), &quot;\n&quot;
-             if $debug_resolvedepends;
-         print STDERR &quot;DEBUG[expanddepends] - &quot;, $item, &quot;\n&quot;
-             if $debug_resolvedepends;
-         my @middle = (
-             $item,
-             map {
-                 my $x = $_;
-                 my $extlessx = extensionlesslib($x);
-                 if (grep { $extlessx eq extensionlesslib($_) } @before
-                     and
-                     !grep { $extlessx eq extensionlesslib($_) } @after) {
-                     print STDERR &quot;DEBUG[expanddepends] + &quot;, $x, &quot;\n&quot;
-                         if $debug_resolvedepends;
-                     ( $x )
-                 } else {
-                     print STDERR &quot;DEBUG[expanddepends] ! &quot;, $x, &quot;\n&quot;
-                         if $debug_resolvedepends;
-                     ()
-                 }
-             } @{$unified_info{depends}-&gt;{$item} // []}
-         );
-         print STDERR &quot;DEBUG[expanddepends] = &quot;, join(' ', @middle), &quot;\n&quot;
-             if $debug_resolvedepends;
-         print STDERR &quot;DEBUG[expanddepends]/  &quot;, join(' ', @after), &quot;\n&quot;
-             if $debug_resolvedepends;
-         push @before, @middle;
-     }
-     print STDERR &quot;DEBUG[expanddepends]&lt; &quot;, join(' ', @before), &quot;\n&quot;
-         if $debug_resolvedepends;
-     @before;
- }
-
- # reducedepends looks through a list, and checks if each item is
- # repeated later on.  If it is, the earlier copy is dropped.
- sub reducedepends {
-     my @list = @_;
-     print STDERR &quot;DEBUG[reducedepends]&gt; &quot;, join(' ', @list), &quot;\n&quot;
-         if $debug_resolvedepends;
-     my @newlist = ();
-     my %replace = ();
-     while (@list) {
-         my $item = shift @list;
-         my $extensionlessitem = extensionlesslib($item);
-         if (grep { $extensionlessitem eq extensionlesslib($_) } @list) {
-             if ($item ne $extensionlessitem) {
-                 # If this instance of the library is explicitly static, we
-                 # prefer that to any shared library name, since it must have
-                 # been done on purpose.
-                 $replace{$extensionlessitem} = $item;
-             }
-         } else {
-             push @newlist, $item;
-         }
-     }
-     @newlist = map { $replace{$_} // $_; } @newlist;
-     print STDERR &quot;DEBUG[reducedepends]&lt; &quot;, join(' ', @newlist), &quot;\n&quot;
-         if $debug_resolvedepends;
-     @newlist;
- }
-
- # Do it all
- # This takes multiple inputs and combine them into a single list of
- # interdependent things.  The returned value will include all the input.
- # Callers are responsible for taking away the things they are building.
- sub resolvedepends {
-     print STDERR &quot;DEBUG[resolvedepends] START (&quot;, join(', ', @_), &quot;)\n&quot;
-         if $debug_resolvedepends;
-     my @all =
-         reducedepends(expanddepends(map { ( $_, collectdepends($_) ) } @_));
-     print STDERR &quot;DEBUG[resolvedepends] END (&quot;, join(', ', @_), &quot;) : &quot;,
-         join(',', map { &quot;\n    $_&quot; } @all), &quot;\n&quot;
-         if $debug_resolvedepends;
-     @all;
- }
-
- # dogenerate is responsible for producing all the recipes that build
- # generated source files.  It recurses in case a dependency is also a
- # generated source file.
- sub dogenerate {
-     my $src = shift;
-     # Safety measure
-     return &quot;&quot; unless defined $unified_info{generate}-&gt;{$_};
-     return &quot;&quot; if $cache{$src};
-     my $obj = shift;
-     my $bin = shift;
-     my %opts = @_;
-     if ($unified_info{generate}-&gt;{$src}) {
-         die &quot;$src is generated by Configure, should not appear in build file\n&quot;
-             if ref $unified_info{generate}-&gt;{$src} eq &quot;&quot;;
-         my $script = $unified_info{generate}-&gt;{$src}-&gt;[0];
-         $OUT .= generatesrc(src =&gt; $src,
-                             product =&gt; $bin,
-                             generator =&gt; $unified_info{generate}-&gt;{$src},
-                             generator_incs =&gt; $unified_info{includes}-&gt;{$script},
-                             generator_deps =&gt; $unified_info{depends}-&gt;{$script},
-                             deps =&gt; $unified_info{depends}-&gt;{$src},
-                             incs =&gt; [ defined $obj
-                                           ? @{$unified_info{includes}-&gt;{$obj}}
-                                           : (),
-                                       defined $bin
-                                           ? @{$unified_info{includes}-&gt;{$bin}}
-                                           : () ],
-                             defs =&gt; [ defined $obj
-                                           ? @{$unified_info{defines}-&gt;{$obj}}
-                                           : (),
-                                       defined $bin
-                                           ? @{$unified_info{defines}-&gt;{$bin}}
-                                           : () ],
-                             %opts);
-         foreach (@{$unified_info{depends}-&gt;{$src}}) {
-             dogenerate($_, $obj, $bin, %opts);
-         }
-     }
-     $cache{$src} = 1;
- }
-
- sub dotarget {
-     my $target = shift;
-     return &quot;&quot; if $cache{$target};
-     $OUT .= generatetarget(target =&gt; $target,
-                            deps =&gt; $unified_info{depends}-&gt;{$target});
-     foreach (@{$unified_info{depends}-&gt;{$target}}) {
-         dogenerate($_);
-     }
-     $cache{$target} = 1;
- }
-
- # doobj is responsible for producing all the recipes that build
- # object files as well as dependency files.
- sub doobj {
-     my $obj = shift;
-     return &quot;&quot; if $cache{$obj};
-     my $bin = shift;
-     my %opts = @_;
-     if (@{$unified_info{sources}-&gt;{$obj}}) {
-         my @srcs = @{$unified_info{sources}-&gt;{$obj}};
-         my @deps = @{$unified_info{depends}-&gt;{$obj}};
-         my @incs = ( @{$unified_info{includes}-&gt;{$obj}},
-                      @{$unified_info{includes}-&gt;{$bin}} );
-         my @defs = ( @{$unified_info{defines}-&gt;{$obj}},
-                      @{$unified_info{defines}-&gt;{$bin}} );
-         print STDERR &quot;DEBUG[doobj] \@srcs for $obj ($bin) : &quot;,
-             join(&quot;,&quot;, map { &quot;\n    $_&quot; } @srcs), &quot;\n&quot;
-             if $debug_rules;
-         print STDERR &quot;DEBUG[doobj] \@deps for $obj ($bin) : &quot;,
-             join(&quot;,&quot;, map { &quot;\n    $_&quot; } @deps), &quot;\n&quot;
-             if $debug_rules;
-         print STDERR &quot;DEBUG[doobj] \@incs for $obj ($bin) : &quot;,
-             join(&quot;,&quot;, map { &quot;\n    $_&quot; } @incs), &quot;\n&quot;
-             if $debug_rules;
-         print STDERR &quot;DEBUG[doobj] \@defs for $obj ($bin) : &quot;,
-             join(&quot;,&quot;, map { &quot;\n    $_&quot; } @defs), &quot;\n&quot;
-             if $debug_rules;
-         print STDERR &quot;DEBUG[doobj] \%opts for $obj ($bin) : &quot;, ,
-             join(&quot;,&quot;, map { &quot;\n    $_ = $opts{$_}&quot; } sort keys %opts), &quot;\n&quot;
-             if $debug_rules;
-         $OUT .= src2obj(obj =&gt; $obj, product =&gt; $bin,
-                         srcs =&gt; [ @srcs ], deps =&gt; [ @deps ],
-                         incs =&gt; [ @incs ], defs =&gt; [ @defs ],
-                         %opts);
-         foreach ((@{$unified_info{sources}-&gt;{$obj}},
-                   @{$unified_info{depends}-&gt;{$obj}})) {
-             dogenerate($_, $obj, $bin, %opts);
-         }
-     }
-     $cache{$obj} = 1;
- }
-
- # Helper functions to grab all applicable intermediary files.
- # This is particularly useful when a library is given as source
- # rather than a dependency.  In that case, we consider it to be a
- # container with object file references, or possibly references
- # to further libraries to pilfer in the same way.
- sub getsrclibs {
-     my $section = shift;
-
-     # For all input, see if it sources static libraries.  If it does,
-     # return them together with the result of a recursive call.
-     map { ( $_, getsrclibs($section, $_) ) }
-     grep { $_ =~ m|\.a$| }
-     map { @{$unified_info{$section}-&gt;{$_} // []} }
-     @_;
- }
-
- sub getlibobjs {
-     my $section = shift;
-
-     # For all input, see if it's an intermediary file (library or object).
-     # If it is, collect the result of a recursive call, or if that returns
-     # an empty list, the element itself.  Return the result.
-     map {
-         my @x = getlibobjs($section, @{$unified_info{$section}-&gt;{$_}});
-         @x ? @x : ( $_ );
-     }
-     grep { defined $unified_info{$section}-&gt;{$_} }
-     @_;
- }
-
- # dolib is responsible for building libraries.  It will call
- # obj2shlib if shared libraries are produced, and obj2lib in all
- # cases.  It also makes sure all object files for the library are
- # built.
- sub dolib {
-     my $lib = shift;
-     return &quot;&quot; if $cache{$lib};
-
-     my %attrs = %{$unified_info{attributes}-&gt;{libraries}-&gt;{$lib}};
-
-     my @deps = ( resolvedepends(getsrclibs('sources', $lib)) );
-
-     # We support two types of objs, those who are specific to this library
-     # (they end up in @objs) and those that we get indirectly, via other
-     # libraries (they end up in @foreign_objs).  We get the latter any time
-     # someone has done something like this in build.info:
-     #     SOURCE[libfoo.a]=libbar.a
-     # The indirect object files must be kept in a separate array so they
-     # don't get rebuilt unnecessarily (and with incorrect auxiliary
-     # information).
-     #
-     # Object files can't be collected commonly for shared and static
-     # libraries, because we contain their respective object files in
-     # {shared_sources} and {sources}, and because the implications are
-     # slightly different for each library form.
-     #
-     # We grab all these &quot;foreign&quot; object files recursively with getlibobjs().
-
-     unless ($disabled{shared} || $lib =~ /\.a$/) {
-         my $obj2shlib = defined &amp;obj2shlib ? \&amp;obj2shlib : \&amp;libobj2shlib;
-         # If this library sources other static libraries and those
-         # libraries are marked {noinst}, there's no need to include
-         # all of their object files.  Instead, we treat those static
-         # libraries as dependents alongside any other library this
-         # one depends on, and let symbol resolution do its job.
-         my @sourced_libs = ();
-         my @objs = ();
-         my @foreign_objs = ();
-         my @deps = ();
-         foreach (@{$unified_info{shared_sources}-&gt;{$lib}}) {
-             if ($_ !~ m|\.a$|) {
-                 push @objs, $_;
-             } elsif ($unified_info{attributes}-&gt;{libraries}-&gt;{$_}-&gt;{noinst}) {
-                 push @deps, $_;
-             } else {
-                 push @deps, getsrclibs('sources', $_);
-                 push @foreign_objs, getlibobjs('sources', $_);
-             }
-         }
-         @deps = ( grep { $_ ne $lib } resolvedepends($lib, @deps) );
-         print STDERR &quot;DEBUG[dolib:shlib] \%attrs for $lib : &quot;, ,
-             join(&quot;,&quot;, map { &quot;\n    $_ = $attrs{$_}&quot; } sort keys %attrs), &quot;\n&quot;
-             if %attrs &amp;&amp; $debug_rules;
-         print STDERR &quot;DEBUG[dolib:shlib] \@deps for $lib : &quot;,
-             join(&quot;,&quot;, map { &quot;\n    $_&quot; } @deps), &quot;\n&quot;
-             if @deps &amp;&amp; $debug_rules;
-         print STDERR &quot;DEBUG[dolib:shlib] \@objs for $lib : &quot;,
-             join(&quot;,&quot;, map { &quot;\n    $_&quot; } @objs), &quot;\n&quot;
-             if @objs &amp;&amp; $debug_rules;
-         print STDERR &quot;DEBUG[dolib:shlib] \@foreign_objs for $lib : &quot;,
-             join(&quot;,&quot;, map { &quot;\n    $_&quot; } @foreign_objs), &quot;\n&quot;
-             if @foreign_objs &amp;&amp; $debug_rules;
-         $OUT .= $obj2shlib-&gt;(lib =&gt; $lib,
-                              attrs =&gt; { %attrs },
-                              objs =&gt; [ @objs, @foreign_objs ],
-                              deps =&gt; [ @deps ]);
-         foreach (@objs) {
-             # If this is somehow a compiled object, take care of it that way
-             # Otherwise, it might simply be generated
-             if (defined $unified_info{sources}-&gt;{$_}) {
-                 if($_ =~ /\.a$/) {
-                     dolib($_);
-                 } else {
-                     doobj($_, $lib, intent =&gt; &quot;shlib&quot;, attrs =&gt; { %attrs });
-                 }
-             } else {
-                 dogenerate($_, undef, undef, intent =&gt; &quot;lib&quot;);
-             }
-         }
-     }
-     {
-         # When putting static libraries together, we cannot rely on any
-         # symbol resolution, so for all static libraries used as source for
-         # this one, as well as other libraries they depend on, we simply
-         # grab all their object files unconditionally,
-         # Symbol resolution will happen when any program, module or shared
-         # library is linked with this one.
-         my @objs = ();
-         my @sourcedeps = ();
-         my @foreign_objs = ();
-         foreach (@{$unified_info{sources}-&gt;{$lib}}) {
-             if ($_ !~ m|\.a$|) {
-                 push @objs, $_;
-             } else {
-                 push @sourcedeps, $_;
-             }
-         }
-         @sourcedeps = ( grep { $_ ne $lib } resolvedepends(@sourcedeps) );
-         print STDERR &quot;DEBUG[dolib:lib] : \@sourcedeps for $_ : &quot;,
-             join(&quot;,&quot;, map { &quot;\n    $_&quot; } @sourcedeps), &quot;\n&quot;
-             if @sourcedeps &amp;&amp; $debug_rules;
-         @foreign_objs = getlibobjs('sources', @sourcedeps);
-         print STDERR &quot;DEBUG[dolib:lib] \%attrs for $lib : &quot;, ,
-             join(&quot;,&quot;, map { &quot;\n    $_ = $attrs{$_}&quot; } sort keys %attrs), &quot;\n&quot;
-             if %attrs &amp;&amp; $debug_rules;
-         print STDERR &quot;DEBUG[dolib:lib] \@objs for $lib : &quot;,
-             join(&quot;,&quot;, map { &quot;\n    $_&quot; } @objs), &quot;\n&quot;
-             if @objs &amp;&amp; $debug_rules;
-         print STDERR &quot;DEBUG[dolib:lib] \@foreign_objs for $lib : &quot;,
-             join(&quot;,&quot;, map { &quot;\n    $_&quot; } @foreign_objs), &quot;\n&quot;
-             if @foreign_objs &amp;&amp; $debug_rules;
-         $OUT .= obj2lib(lib =&gt; $lib, attrs =&gt; { %attrs },
-                         objs =&gt; [ @objs, @foreign_objs ]);
-         foreach (@objs) {
-             doobj($_, $lib, intent =&gt; &quot;lib&quot;, attrs =&gt; { %attrs });
-         }
-     }
-     $cache{$lib} = 1;
- }
-
- # domodule is responsible for building modules.  It will call
- # obj2dso, and also makes sure all object files for the library
- # are built.
- sub domodule {
-     my $module = shift;
-     return &quot;&quot; if $cache{$module};
-     my %attrs = %{$unified_info{attributes}-&gt;{modules}-&gt;{$module}};
-     my @objs = @{$unified_info{sources}-&gt;{$module}};
-     my @deps = ( grep { $_ ne $module }
-                  resolvedepends($module) );
-     print STDERR &quot;DEBUG[domodule] \%attrs for $module :&quot;,
-         join(&quot;,&quot;, map { &quot;\n    $_ = $attrs{$_}&quot; } sort keys %attrs), &quot;\n&quot;
-         if $debug_rules;
-     print STDERR &quot;DEBUG[domodule] \@objs for $module : &quot;,
-         join(&quot;,&quot;, map { &quot;\n    $_&quot; } @objs), &quot;\n&quot;
-         if $debug_rules;
-     print STDERR &quot;DEBUG[domodule] \@deps for $module : &quot;,
-         join(&quot;,&quot;, map { &quot;\n    $_&quot; } @deps), &quot;\n&quot;
-         if $debug_rules;
-     $OUT .= obj2dso(module =&gt; $module,
-                     attrs =&gt; { %attrs },
-                     objs =&gt; [ @objs ],
-                     deps =&gt; [ @deps ]);
-     foreach (@{$unified_info{sources}-&gt;{$module}}) {
-         # If this is somehow a compiled object, take care of it that way
-         # Otherwise, it might simply be generated
-         if (defined $unified_info{sources}-&gt;{$_}) {
-             doobj($_, $module, intent =&gt; &quot;dso&quot;, attrs =&gt; { %attrs });
-         } else {
-             dogenerate($_, undef, $module, intent =&gt; &quot;dso&quot;);
-         }
-     }
-     $cache{$module} = 1;
- }
-
- # dobin is responsible for building programs.  It will call obj2bin,
- # and also makes sure all object files for the library are built.
- sub dobin {
-     my $bin = shift;
-     return &quot;&quot; if $cache{$bin};
-     my %attrs = %{$unified_info{attributes}-&gt;{programs}-&gt;{$bin}};
-     my @objs = @{$unified_info{sources}-&gt;{$bin}};
-     my @deps = ( grep { $_ ne $bin } resolvedepends($bin) );
-     print STDERR &quot;DEBUG[dobin] \%attrs for $bin : &quot;,
-         join(&quot;,&quot;, map { &quot;\n    $_ = $attrs{$_}&quot; } sort keys %attrs), &quot;\n&quot;
-         if %attrs &amp;&amp; $debug_rules;
-     print STDERR &quot;DEBUG[dobin] \@objs for $bin : &quot;,
-         join(&quot;,&quot;, map { &quot;\n    $_&quot; } @objs), &quot;\n&quot;
-         if @objs &amp;&amp; $debug_rules;
-     print STDERR &quot;DEBUG[dobin] \@deps for $bin : &quot;,
-         join(&quot;,&quot;, map { &quot;\n    $_&quot; } @deps), &quot;\n&quot;
-         if @deps &amp;&amp; $debug_rules;
-     $OUT .= obj2bin(bin =&gt; $bin,
-                     attrs =&gt; { %attrs },
-                     objs =&gt; [ @objs ],
-                     deps =&gt; [ @deps ]);
-     foreach (@objs) {
-         doobj($_, $bin, intent =&gt; &quot;bin&quot;, attrs =&gt; { %attrs });
-     }
-     $cache{$bin} = 1;
- }
-
- # doscript is responsible for building scripts from templates.  It will
- # call in2script.
- sub doscript {
-     my $script = shift;
-     return &quot;&quot; if $cache{$script};
-     $OUT .= in2script(script =&gt; $script,
-                       attrs =&gt; $unified_info{attributes}-&gt;{$script},
-                       sources =&gt; $unified_info{sources}-&gt;{$script});
-     $cache{$script} = 1;
- }
-
- sub dodir {
-     my $dir = shift;
-     return &quot;&quot; if !exists(&amp;generatedir) or $cache{$dir};
-     $OUT .= generatedir(dir =&gt; $dir,
-                         deps =&gt; $unified_info{dirinfo}-&gt;{$dir}-&gt;{deps},
-                         %{$unified_info{dirinfo}-&gt;{$_}-&gt;{products}});
-     $cache{$dir} = 1;
- }
-
- # dodocs is responsible for building documentation from .pods.
- # It will call generatesrc.
- sub dodocs {
-     my $type = shift;
-     my $section = shift;
-     foreach my $doc (@{$unified_info{&quot;${type}docs&quot;}-&gt;{$section}}) {
-         next if $cache{$doc};
-         $OUT .= generatesrc(src =&gt; $doc,
-                             generator =&gt; $unified_info{generate}-&gt;{$doc});
-         foreach ((@{$unified_info{depends}-&gt;{$doc}})) {
-             dogenerate($_, undef, undef, %opts);
-         }
-         $cache{$doc} = 1;
-     }
- }
-
- # Start with populating the cache with all the overrides
- %cache = map { $_ =&gt; 1 } @{$unified_info{overrides}};
-
- # Build mandatory header file generators
- foreach (@{$unified_info{depends}-&gt;{&quot;&quot;}}) { dogenerate($_); }
-
- # Build all known targets, libraries, modules, programs and scripts.
- # Everything else will be handled as a consequence.
- foreach (@{$unified_info{targets}})   { dotarget($_); }
- foreach (@{$unified_info{libraries}}) { dolib($_);    }
- foreach (@{$unified_info{modules}})   { domodule($_); }
- foreach (@{$unified_info{programs}})  { dobin($_);    }
- foreach (@{$unified_info{scripts}})   { doscript($_); }
- foreach (sort keys %{$unified_info{htmldocs}}) { dodocs('html', $_); }
- foreach (sort keys %{$unified_info{mandocs}})  { dodocs('man', $_); }
- foreach (sort keys %{$unified_info{dirinfo}})  { dodir($_); }
--}
diff --git a/Configurations/descrip.mms.tmpl b/Configurations/descrip.mms.tmpl
index 920c0abfeb..a357ae5c3b 100644
--- a/Configurations/descrip.mms.tmpl
+++ b/Configurations/descrip.mms.tmpl
@@ -4,6 +4,7 @@
 {-
   use File::Spec::Functions qw/:DEFAULT abs2rel rel2abs/;
   use File::Basename;
+  use OpenSSL::Util;
 
   (our $osslprefix_q = platform-&gt;osslprefix()) =~ s/\$/\\\$/;
 
diff --git a/Configurations/gentemplate.pm b/Configurations/gentemplate.pm
new file mode 100644
index 0000000000..4acc017e3b
--- /dev/null
+++ b/Configurations/gentemplate.pm
@@ -0,0 +1,549 @@
+package gentemplate;
+
+use strict;
+use warnings;
+use Carp;
+
+use Exporter;
+use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
<A HREF="../../../mailman/listinfo/openssl-commits.html">+ at ISA</A> = qw(Exporter);
<A HREF="../../../mailman/listinfo/openssl-commits.html">+ at EXPORT</A> = qw(gentemplate);
+
+use File::Basename;
+
+sub gentemplate {
+    my %opts = @_;
+
+    my $generator = OpenSSL::GenTemplate-&gt;new(%opts);
+
+    # Build mandatory header file generators
+    foreach (@{$generator-&gt;{info}-&gt;{depends}-&gt;{&quot;&quot;}}) { $generator-&gt;dogenerate($_); }
+
+    # Build all known targets, libraries, modules, programs and scripts.
+    # Everything else will be handled as a consequence.
+    foreach (@{$generator-&gt;{info}-&gt;{targets}})   { $generator-&gt;dotarget($_); }
+    foreach (@{$generator-&gt;{info}-&gt;{libraries}}) { $generator-&gt;dolib($_);    }
+    foreach (@{$generator-&gt;{info}-&gt;{modules}})   { $generator-&gt;domodule($_); }
+    foreach (@{$generator-&gt;{info}-&gt;{programs}})  { $generator-&gt;dobin($_);    }
+    foreach (@{$generator-&gt;{info}-&gt;{scripts}})   { $generator-&gt;doscript($_); }
+    foreach (sort keys %{$generator-&gt;{info}-&gt;{htmldocs}}) { $generator-&gt;dodocs('html', $_); }
+    foreach (sort keys %{$generator-&gt;{info}-&gt;{mandocs}})  { $generator-&gt;dodocs('man', $_); }
+    foreach (sort keys %{$generator-&gt;{info}-&gt;{dirinfo}})  { $generator-&gt;dodir($_); }
+}
+
+package OpenSSL::GenTemplate;
+
+use OpenSSL::Util;
+
+sub new {
+    my $class = shift;
+    my %opts = @_;
+
+    my $data = {
+        output   =&gt; $opts{output},
+        config   =&gt; $opts{config} // {},
+        disabled =&gt; $opts{disabled} // {},
+        info     =&gt; $opts{unified_info} // {},
+    };
+
+    return bless $data, $class;
+};
+
+sub emit {
+    my $self = shift;
+    my $name = shift;
+    my %opts = @_;
+    my $fh = $self-&gt;{output};
+
+    die &quot;No name?&quot; unless $name;
+    print $fh &quot;{-\n &quot;, $name, '(', dump_data(\%opts), ');', &quot; \n-}&quot;;
+}
+
+my $debug_resolvedepends = $ENV{BUILDFILE_DEBUG_DEPENDS};
+my $debug_rules = $ENV{BUILDFILE_DEBUG_RULES};
+
+# A cache of objects for which a recipe has already been generated
+our %cache;
+
+# collectdepends, expanddepends and reducedepends work together to make
+# sure there are no duplicate or weak dependencies and that they are in
+# the right order.  This is used to sort the list of libraries  that a
+# build depends on.
+sub extensionlesslib {
+    my @result = map { $_ =~ /(\.a)?$/; $` } @_;
+    return @result if wantarray;
+    return $result[0];
+}
+
+# collectdepends dives into the tree of dependencies and returns
+# a list of all the non-weak ones.
+sub collectdepends {
+    my $self = shift;
+    return () unless @_;
+
+    my $thing = shift;
+    my $extensionlessthing = extensionlesslib($thing);
+    my @listsofar = @_;    # to check if we're looping
+    my @list = @{ $self-&gt;{info}-&gt;{depends}-&gt;{$thing} //
+                  $self-&gt;{info}-&gt;{depends}-&gt;{$extensionlessthing}
+                  // [] };
+    my @newlist = ();
+
+    print STDERR &quot;DEBUG[collectdepends] $thing &gt; &quot;, join(' ', @listsofar), &quot;\n&quot;
+        if $debug_resolvedepends;
+    foreach my $item (@list) {
+        my $extensionlessitem = extensionlesslib($item);
+        # It's time to break off when the dependency list starts looping
+        next if grep { extensionlesslib($_) eq $extensionlessitem } @listsofar;
+        # Don't add anything here if the dependency is weak
+        next if defined $self-&gt;{info}-&gt;{attributes}-&gt;{depends}-&gt;{$thing}-&gt;{$item}-&gt;{'weak'};
+        my @resolved = $self-&gt;collectdepends($item, @listsofar, $item);
+        push @newlist, $item, @resolved;
+    }
+    print STDERR &quot;DEBUG[collectdepends] $thing &lt; &quot;, join(' ', @newlist), &quot;\n&quot;
+        if $debug_resolvedepends;
+    @newlist;
+}
+
+# expanddepends goes through a list of stuff, checks if they have any
+# dependencies, and adds them at the end of the current position if
+# they aren't already present later on.
+sub expanddepends {
+    my $self = shift;
+    my @after = ( @_ );
+    print STDERR &quot;DEBUG[expanddepends]&gt; &quot;, join(' ', @after), &quot;\n&quot;
+        if $debug_resolvedepends;
+    my @before = ();
+    while (@after) {
+        my $item = shift @after;
+        print STDERR &quot;DEBUG[expanddepends]\\  &quot;, join(' ', @before), &quot;\n&quot;
+            if $debug_resolvedepends;
+        print STDERR &quot;DEBUG[expanddepends] - &quot;, $item, &quot;\n&quot;
+            if $debug_resolvedepends;
+        my @middle = (
+            $item,
+            map {
+                my $x = $_;
+                my $extlessx = extensionlesslib($x);
+                if (grep { $extlessx eq extensionlesslib($_) } @before
+                    and
+                    !grep { $extlessx eq extensionlesslib($_) } @after) {
+                    print STDERR &quot;DEBUG[expanddepends] + &quot;, $x, &quot;\n&quot;
+                        if $debug_resolvedepends;
+                    ( $x )
+                } else {
+                    print STDERR &quot;DEBUG[expanddepends] ! &quot;, $x, &quot;\n&quot;
+                        if $debug_resolvedepends;
+                    ()
+                }
+            } @{$self-&gt;{info}-&gt;{depends}-&gt;{$item} // []}
+            );
+        print STDERR &quot;DEBUG[expanddepends] = &quot;, join(' ', @middle), &quot;\n&quot;
+            if $debug_resolvedepends;
+        print STDERR &quot;DEBUG[expanddepends]/  &quot;, join(' ', @after), &quot;\n&quot;
+            if $debug_resolvedepends;
+        push @before, @middle;
+    }
+    print STDERR &quot;DEBUG[expanddepends]&lt; &quot;, join(' ', @before), &quot;\n&quot;
+        if $debug_resolvedepends;
+    @before;
+}
+
+# reducedepends looks through a list, and checks if each item is
+# repeated later on.  If it is, the earlier copy is dropped.
+sub reducedepends {
+    my @list = @_;
+    print STDERR &quot;DEBUG[reducedepends]&gt; &quot;, join(' ', @list), &quot;\n&quot;
+        if $debug_resolvedepends;
+    my @newlist = ();
+    my %replace = ();
+    while (@list) {
+        my $item = shift @list;
+        my $extensionlessitem = extensionlesslib($item);
+        if (grep { $extensionlessitem eq extensionlesslib($_) } @list) {
+            if ($item ne $extensionlessitem) {
+                # If this instance of the library is explicitly static, we
+                # prefer that to any shared library name, since it must have
+                # been done on purpose.
+                $replace{$extensionlessitem} = $item;
+            }
+        } else {
+            push @newlist, $item;
+        }
+    }
+    @newlist = map { $replace{$_} // $_; } @newlist;
+    print STDERR &quot;DEBUG[reducedepends]&lt; &quot;, join(' ', @newlist), &quot;\n&quot;
+        if $debug_resolvedepends;
+    @newlist;
+}
+
+# Do it all
+# This takes multiple inputs and combine them into a single list of
+# interdependent things.  The returned value will include all the input.
+# Callers are responsible for taking away the things they are building.
+sub resolvedepends {
+    my $self = shift;
+    print STDERR &quot;DEBUG[resolvedepends] START (&quot;, join(', ', @_), &quot;)\n&quot;
+        if $debug_resolvedepends;
+    my @all =
+        reducedepends($self-&gt;expanddepends(map { ( $_, $self-&gt;collectdepends($_) ) } @_));
+    print STDERR &quot;DEBUG[resolvedepends] END (&quot;, join(', ', @_), &quot;) : &quot;,
+        join(',', map { &quot;\n    $_&quot; } @all), &quot;\n&quot;
+        if $debug_resolvedepends;
+    @all;
+}
+
+# dogenerate is responsible for producing all the recipes that build
+# generated source files.  It recurses in case a dependency is also a
+# generated source file.
+sub dogenerate {
+    my $self = shift;
+    my $src = shift;
+    # Safety measure
+    return &quot;&quot; unless defined $self-&gt;{info}-&gt;{generate}-&gt;{$_};
+    return &quot;&quot; if $cache{$src};
+    my $obj = shift;
+    my $bin = shift;
+    my %opts = @_;
+    if ($self-&gt;{info}-&gt;{generate}-&gt;{$src}) {
+        die &quot;$src is generated by Configure, should not appear in build file\n&quot;
+            if ref $self-&gt;{info}-&gt;{generate}-&gt;{$src} eq &quot;&quot;;
+        my $script = $self-&gt;{info}-&gt;{generate}-&gt;{$src}-&gt;[0];
+        $self-&gt;emit('generatesrc',
+             src =&gt; $src,
+             product =&gt; $bin,
+             generator =&gt; $self-&gt;{info}-&gt;{generate}-&gt;{$src},
+             generator_incs =&gt; $self-&gt;{info}-&gt;{includes}-&gt;{$script} // [],
+             generator_deps =&gt; $self-&gt;{info}-&gt;{depends}-&gt;{$script} // [],
+             deps =&gt; $self-&gt;{info}-&gt;{depends}-&gt;{$src} // [],
+             incs =&gt; [ defined $obj ? @{$self-&gt;{info}-&gt;{includes}-&gt;{$obj} // []} : (),
+                       defined $bin ? @{$self-&gt;{info}-&gt;{includes}-&gt;{$bin} // []} : () ],
+             defs =&gt; [ defined $obj ? @{$self-&gt;{info}-&gt;{defines}-&gt;{$obj} // []} : (),
+                       defined $bin ? @{$self-&gt;{info}-&gt;{defines}-&gt;{$bin} // []} : () ],
+             %opts);
+        foreach (@{$self-&gt;{info}-&gt;{depends}-&gt;{$src} // []}) {
+            $self-&gt;dogenerate($_, $obj, $bin, %opts);
+        }
+    }
+    $cache{$src} = 1;
+}
+
+sub dotarget {
+    my $self = shift;
+    my $target = shift;
+    return &quot;&quot; if $cache{$target};
+    $self-&gt;emit('generatetarget',
+         target =&gt; $target,
+         deps =&gt; $self-&gt;{info}-&gt;{depends}-&gt;{$target} // []);
+    foreach (@{$self-&gt;{info}-&gt;{depends}-&gt;{$target} // []}) {
+        $self-&gt;dogenerate($_);
+    }
+    $cache{$target} = 1;
+}
+
+# doobj is responsible for producing all the recipes that build
+# object files as well as dependency files.
+sub doobj {
+    my $self = shift;
+    my $obj = shift;
+    return &quot;&quot; if $cache{$obj};
+    my $bin = shift;
+    my %opts = @_;
+    if (@{$self-&gt;{info}-&gt;{sources}-&gt;{$obj} // []}) {
+        my @srcs = @{$self-&gt;{info}-&gt;{sources}-&gt;{$obj}};
+        my @deps = @{$self-&gt;{info}-&gt;{depends}-&gt;{$obj} // []};
+        my @incs = ( @{$self-&gt;{info}-&gt;{includes}-&gt;{$obj} // []},
+                     @{$self-&gt;{info}-&gt;{includes}-&gt;{$bin} // []} );
+        my @defs = ( @{$self-&gt;{info}-&gt;{defines}-&gt;{$obj} // []},
+                     @{$self-&gt;{info}-&gt;{defines}-&gt;{$bin} // []} );
+        print STDERR &quot;DEBUG[doobj] \@srcs for $obj ($bin) : &quot;,
+            join(&quot;,&quot;, map { &quot;\n    $_&quot; } @srcs), &quot;\n&quot;
+            if $debug_rules;
+        print STDERR &quot;DEBUG[doobj] \@deps for $obj ($bin) : &quot;,
+            join(&quot;,&quot;, map { &quot;\n    $_&quot; } @deps), &quot;\n&quot;
+            if $debug_rules;
+        print STDERR &quot;DEBUG[doobj] \@incs for $obj ($bin) : &quot;,
+            join(&quot;,&quot;, map { &quot;\n    $_&quot; } @incs), &quot;\n&quot;
+            if $debug_rules;
+        print STDERR &quot;DEBUG[doobj] \@defs for $obj ($bin) : &quot;,
+            join(&quot;,&quot;, map { &quot;\n    $_&quot; } @defs), &quot;\n&quot;
+            if $debug_rules;
+        print STDERR &quot;DEBUG[doobj] \%opts for $obj ($bin) : &quot;, ,
+            join(&quot;,&quot;, map { &quot;\n    $_ = $opts{$_}&quot; } sort keys %opts), &quot;\n&quot;
+            if $debug_rules;
+        $self-&gt;emit('src2obj',
+             obj =&gt; $obj, product =&gt; $bin,
+             srcs =&gt; [ @srcs ], deps =&gt; [ @deps ],
+             incs =&gt; [ @incs ], defs =&gt; [ @defs ],
+             %opts);
+        foreach ((@{$self-&gt;{info}-&gt;{sources}-&gt;{$obj}},
+                  @{$self-&gt;{info}-&gt;{depends}-&gt;{$obj} // []})) {
+            $self-&gt;dogenerate($_, $obj, $bin, %opts);
+        }
+    }
+    $cache{$obj} = 1;
+}
+
+# Helper functions to grab all applicable intermediary files.
+# This is particularly useful when a library is given as source
+# rather than a dependency.  In that case, we consider it to be a
+# container with object file references, or possibly references
+# to further libraries to pilfer in the same way.
+sub getsrclibs {
+    my $self = shift;
+    my $section = shift;
+
+    # For all input, see if it sources static libraries.  If it does,
+    # return them together with the result of a recursive call.
+    map { ( $_, getsrclibs($section, $_) ) }
+    grep { $_ =~ m|\.a$| }
+    map { @{$self-&gt;{info}-&gt;{$section}-&gt;{$_} // []} }
+    @_;
+}
+
+sub getlibobjs {
+    my $self = shift;
+    my $section = shift;
+
+    # For all input, see if it's an intermediary file (library or object).
+    # If it is, collect the result of a recursive call, or if that returns
+    # an empty list, the element itself.  Return the result.
+    map {
+        my @x = $self-&gt;getlibobjs($section, @{$self-&gt;{info}-&gt;{$section}-&gt;{$_}});
+        @x ? @x : ( $_ );
+    }
+    grep { defined $self-&gt;{info}-&gt;{$section}-&gt;{$_} }
+    @_;
+}
+
+# dolib is responsible for building libraries.  It will call
+# obj2shlib if shared libraries are produced, and obj2lib in all
+# cases.  It also makes sure all object files for the library are
+# built.
+sub dolib {
+    my $self = shift;
+    my $lib = shift;
+    return &quot;&quot; if $cache{$lib};
+
+    my %attrs = %{$self-&gt;{info}-&gt;{attributes}-&gt;{libraries}-&gt;{$lib} // {}};
+
+    my @deps = ( $self-&gt;resolvedepends(getsrclibs('sources', $lib)) );
+
+    # We support two types of objs, those who are specific to this library
+    # (they end up in @objs) and those that we get indirectly, via other
+    # libraries (they end up in @foreign_objs).  We get the latter any time
+    # someone has done something like this in build.info:
+    #     SOURCE[libfoo.a]=libbar.a
+    # The indirect object files must be kept in a separate array so they
+    # don't get rebuilt unnecessarily (and with incorrect auxiliary
+    # information).
+    #
+    # Object files can't be collected commonly for shared and static
+    # libraries, because we contain their respective object files in
+    # {shared_sources} and {sources}, and because the implications are
+    # slightly different for each library form.
+    #
+    # We grab all these &quot;foreign&quot; object files recursively with getlibobjs().
+
+    unless ($self-&gt;{disabled}-&gt;{shared} || $lib =~ /\.a$/) {
+        # If this library sources other static libraries and those
+        # libraries are marked {noinst}, there's no need to include
+        # all of their object files.  Instead, we treat those static
+        # libraries as dependents alongside any other library this
+        # one depends on, and let symbol resolution do its job.
+        my @sourced_libs = ();
+        my @objs = ();
+        my @foreign_objs = ();
+        my @deps = ();
+        foreach (@{$self-&gt;{info}-&gt;{shared_sources}-&gt;{$lib} // []}) {
+            if ($_ !~ m|\.a$|) {
+                push @objs, $_;
+            } elsif ($self-&gt;{info}-&gt;{attributes}-&gt;{libraries}-&gt;{$_}-&gt;{noinst}) {
+                push @deps, $_;
+            } else {
+                push @deps, $self-&gt;getsrclibs('sources', $_);
+                push @foreign_objs, $self-&gt;getlibobjs('sources', $_);
+            }
+        }
+        @deps = ( grep { $_ ne $lib } $self-&gt;resolvedepends($lib, @deps) );
+        print STDERR &quot;DEBUG[dolib:shlib] \%attrs for $lib : &quot;, ,
+            join(&quot;,&quot;, map { &quot;\n    $_ = $attrs{$_}&quot; } sort keys %attrs), &quot;\n&quot;
+            if %attrs &amp;&amp; $debug_rules;
+        print STDERR &quot;DEBUG[dolib:shlib] \@deps for $lib : &quot;,
+            join(&quot;,&quot;, map { &quot;\n    $_&quot; } @deps), &quot;\n&quot;
+            if @deps &amp;&amp; $debug_rules;
+        print STDERR &quot;DEBUG[dolib:shlib] \@objs for $lib : &quot;,
+            join(&quot;,&quot;, map { &quot;\n    $_&quot; } @objs), &quot;\n&quot;
+            if @objs &amp;&amp; $debug_rules;
+        print STDERR &quot;DEBUG[dolib:shlib] \@foreign_objs for $lib : &quot;,
+            join(&quot;,&quot;, map { &quot;\n    $_&quot; } @foreign_objs), &quot;\n&quot;
+            if @foreign_objs &amp;&amp; $debug_rules;
+        $self-&gt;emit('obj2shlib',
+             lib =&gt; $lib,
+             attrs =&gt; { %attrs },
+             objs =&gt; [ @objs, @foreign_objs ],
+             deps =&gt; [ @deps ]);
+        foreach (@objs) {
+            # If this is somehow a compiled object, take care of it that way
+            # Otherwise, it might simply be generated
+            if (defined $self-&gt;{info}-&gt;{sources}-&gt;{$_}) {
+                if($_ =~ /\.a$/) {
+                    $self-&gt;dolib($_);
+                } else {
+                    $self-&gt;doobj($_, $lib, intent =&gt; &quot;shlib&quot;, attrs =&gt; { %attrs });
+                }
+            } else {
+                $self-&gt;dogenerate($_, undef, undef, intent =&gt; &quot;lib&quot;);
+            }
+        }
+    }
+    {
+        # When putting static libraries together, we cannot rely on any
+        # symbol resolution, so for all static libraries used as source for
+        # this one, as well as other libraries they depend on, we simply
+        # grab all their object files unconditionally,
+        # Symbol resolution will happen when any program, module or shared
+        # library is linked with this one.
+        my @objs = ();
+        my @sourcedeps = ();
+        my @foreign_objs = ();
+        foreach (@{$self-&gt;{info}-&gt;{sources}-&gt;{$lib}}) {
+            if ($_ !~ m|\.a$|) {
+                push @objs, $_;
+            } else {
+                push @sourcedeps, $_;
+            }
+        }
+        @sourcedeps = ( grep { $_ ne $lib } $self-&gt;resolvedepends(@sourcedeps) );
+        print STDERR &quot;DEBUG[dolib:lib] : \@sourcedeps for $_ : &quot;,
+            join(&quot;,&quot;, map { &quot;\n    $_&quot; } @sourcedeps), &quot;\n&quot;
+            if @sourcedeps &amp;&amp; $debug_rules;
+        @foreign_objs = $self-&gt;getlibobjs('sources', @sourcedeps);
+        print STDERR &quot;DEBUG[dolib:lib] \%attrs for $lib : &quot;, ,
+            join(&quot;,&quot;, map { &quot;\n    $_ = $attrs{$_}&quot; } sort keys %attrs), &quot;\n&quot;
+            if %attrs &amp;&amp; $debug_rules;
+        print STDERR &quot;DEBUG[dolib:lib] \@objs for $lib : &quot;,
+            join(&quot;,&quot;, map { &quot;\n    $_&quot; } @objs), &quot;\n&quot;
+            if @objs &amp;&amp; $debug_rules;
+        print STDERR &quot;DEBUG[dolib:lib] \@foreign_objs for $lib : &quot;,
+            join(&quot;,&quot;, map { &quot;\n    $_&quot; } @foreign_objs), &quot;\n&quot;
+            if @foreign_objs &amp;&amp; $debug_rules;
+        $self-&gt;emit('obj2lib',
+             lib =&gt; $lib, attrs =&gt; { %attrs },
+             objs =&gt; [ @objs, @foreign_objs ]);
+        foreach (@objs) {
+            $self-&gt;doobj($_, $lib, intent =&gt; &quot;lib&quot;, attrs =&gt; { %attrs });
+        }
+    }
+    $cache{$lib} = 1;
+}
+
+# domodule is responsible for building modules.  It will call
+# obj2dso, and also makes sure all object files for the library
+# are built.
+sub domodule {
+    my $self = shift;
+    my $module = shift;
+    return &quot;&quot; if $cache{$module};
+    my %attrs = %{$self-&gt;{info}-&gt;{attributes}-&gt;{modules}-&gt;{$module} // {}};
+    my @objs = @{$self-&gt;{info}-&gt;{sources}-&gt;{$module}};
+    my @deps = ( grep { $_ ne $module }
+                 $self-&gt;resolvedepends($module) );
+    print STDERR &quot;DEBUG[domodule] \%attrs for $module :&quot;,
+        join(&quot;,&quot;, map { &quot;\n    $_ = $attrs{$_}&quot; } sort keys %attrs), &quot;\n&quot;
+        if $debug_rules;
+    print STDERR &quot;DEBUG[domodule] \@objs for $module : &quot;,
+        join(&quot;,&quot;, map { &quot;\n    $_&quot; } @objs), &quot;\n&quot;
+        if $debug_rules;
+    print STDERR &quot;DEBUG[domodule] \@deps for $module : &quot;,
+        join(&quot;,&quot;, map { &quot;\n    $_&quot; } @deps), &quot;\n&quot;
+        if $debug_rules;
+    $self-&gt;emit('obj2dso',
+         module =&gt; $module,
+         attrs =&gt; { %attrs },
+         objs =&gt; [ @objs ],
+         deps =&gt; [ @deps ]);
+    foreach (@{$self-&gt;{info}-&gt;{sources}-&gt;{$module}}) {
+        # If this is somehow a compiled object, take care of it that way
+        # Otherwise, it might simply be generated
+        if (defined $self-&gt;{info}-&gt;{sources}-&gt;{$_}) {
+            $self-&gt;doobj($_, $module, intent =&gt; &quot;dso&quot;, attrs =&gt; { %attrs });
+        } else {
+            $self-&gt;dogenerate($_, undef, $module, intent =&gt; &quot;dso&quot;);
+        }
+    }
+    $cache{$module} = 1;
+}
+
+# dobin is responsible for building programs.  It will call obj2bin,
+# and also makes sure all object files for the library are built.
+sub dobin {
+    my $self = shift;
+    my $bin = shift;
+    return &quot;&quot; if $cache{$bin};
+    my %attrs = %{$self-&gt;{info}-&gt;{attributes}-&gt;{programs}-&gt;{$bin} // {}};
+    my @objs = @{$self-&gt;{info}-&gt;{sources}-&gt;{$bin}};
+    my @deps = ( grep { $_ ne $bin } $self-&gt;resolvedepends($bin) );
+    print STDERR &quot;DEBUG[dobin] \%attrs for $bin : &quot;,
+        join(&quot;,&quot;, map { &quot;\n    $_ = $attrs{$_}&quot; } sort keys %attrs), &quot;\n&quot;
+        if %attrs &amp;&amp; $debug_rules;
+    print STDERR &quot;DEBUG[dobin] \@objs for $bin : &quot;,
+        join(&quot;,&quot;, map { &quot;\n    $_&quot; } @objs), &quot;\n&quot;
+        if @objs &amp;&amp; $debug_rules;
+    print STDERR &quot;DEBUG[dobin] \@deps for $bin : &quot;,
+        join(&quot;,&quot;, map { &quot;\n    $_&quot; } @deps), &quot;\n&quot;
+        if @deps &amp;&amp; $debug_rules;
+    $self-&gt;emit('obj2bin',
+         bin =&gt; $bin,
+         attrs =&gt; { %attrs },
+         objs =&gt; [ @objs ],
+         deps =&gt; [ @deps ]);
+    foreach (@objs) {
+        $self-&gt;doobj($_, $bin, intent =&gt; &quot;bin&quot;, attrs =&gt; { %attrs });
+    }
+    $cache{$bin} = 1;
+}
+
+# doscript is responsible for building scripts from templates.  It will
+# call in2script.
+sub doscript {
+    my $self = shift;
+    my $script = shift;
+    return &quot;&quot; if $cache{$script};
+    $self-&gt;emit('in2script',
+         script =&gt; $script,
+         attrs =&gt; $self-&gt;{info}-&gt;{attributes}-&gt;{$script} // {},
+         sources =&gt; $self-&gt;{info}-&gt;{sources}-&gt;{$script});
+    $cache{$script} = 1;
+}
+
+sub dodir {
+    my $self = shift;
+    my $dir = shift;
+    return &quot;&quot; if !exists(&amp;generatedir) or $cache{$dir};
+    $self-&gt;emit('generatedir',
+         dir =&gt; $dir,
+         deps =&gt; $self-&gt;{info}-&gt;{dirinfo}-&gt;{$dir}-&gt;{deps} // [],
+         %{$self-&gt;{info}-&gt;{dirinfo}-&gt;{$_}-&gt;{products}});
+    $cache{$dir} = 1;
+}
+
+# dodocs is responsible for building documentation from .pods.
+# It will call generatesrc.
+sub dodocs {
+    my $self = shift;
+    my $type = shift;
+    my $section = shift;
+    foreach my $doc (@{$self-&gt;{info}-&gt;{&quot;${type}docs&quot;}-&gt;{$section}}) {
+        next if $cache{$doc};
+        $self-&gt;emit('generatesrc',
+             src =&gt; $doc,
+             generator =&gt; $self-&gt;{info}-&gt;{generate}-&gt;{$doc});
+        foreach ((@{$self-&gt;{info}-&gt;{depends}-&gt;{$doc} // []})) {
+            $self-&gt;dogenerate($_, undef, undef);
+        }
+        $cache{$doc} = 1;
+    }
+}
+
+1;
diff --git a/Configurations/unix-Makefile.tmpl b/Configurations/unix-Makefile.tmpl
index f729416d1d..8b45e75f57 100644
--- a/Configurations/unix-Makefile.tmpl
+++ b/Configurations/unix-Makefile.tmpl
@@ -3,6 +3,8 @@
 ##
 ## {- join(&quot;\n## &quot;, @autowarntext) -}
 {-
+     use OpenSSL::Util;
+
      our $makedep_scheme = $config{makedep_scheme};
      our $makedepcmd = platform-&gt;makedepcmd();
 
diff --git a/Configurations/windows-makefile.tmpl b/Configurations/windows-makefile.tmpl
index 014c1eb8d1..a7123f6a5e 100644
--- a/Configurations/windows-makefile.tmpl
+++ b/Configurations/windows-makefile.tmpl
@@ -4,6 +4,7 @@
 ## {- join(&quot;\n## &quot;, @autowarntext) -}
 {-
  use File::Basename;
+ use OpenSSL::Util;
 
  our $sover_dirname = platform-&gt;shlib_version_as_filename();
 
diff --git a/Configure b/Configure
index 2996cd1b4a..cd40abedf7 100755
--- a/Configure
+++ b/Configure
@@ -1918,9 +1918,7 @@ if ($builder eq &quot;unified&quot;) {
     $config{build_file_templates}
       = [ cleanfile($srcdir, catfile(&quot;Configurations&quot;, &quot;common0.tmpl&quot;),
                     $blddir),
-          $build_file_template,
-          cleanfile($srcdir, catfile(&quot;Configurations&quot;, &quot;common.tmpl&quot;),
-                    $blddir) ];
+           $build_file_template ];
 
     my @build_dirs = ( [ ] );   # current directory
 
@@ -2789,7 +2787,7 @@ my %template_vars = (
 my $configdata_outname = 'configdata.pm';
 print &quot;Creating $configdata_outname\n&quot;;
 open CONFIGDATA, &quot;&gt;$configdata_outname.new&quot;
-            or die &quot;Trying to create $configdata_outname.new: $!&quot;;
+    or die &quot;Trying to create $configdata_outname.new: $!&quot;;
 my $configdata_tmplname = cleanfile($srcdir, &quot;configdata.pm.in&quot;, $blddir);
 my $configdata_tmpl =
     OpenSSL::Template-&gt;new(TYPE =&gt; 'FILE', SOURCE =&gt; $configdata_tmplname);
diff --git a/configdata.pm.in b/configdata.pm.in
index 3481eab277..6c0d30baa0 100644
--- a/configdata.pm.in
+++ b/configdata.pm.in
@@ -1,65 +1,6 @@
 #! {- $config{HASHBANGPERL} -}
 # -*- mode: perl -*-
 {-
- sub out_item {
-     my $ref = shift;
-     # Available options:
-     # indent           =&gt; callers indentation (int)
-     # delimiters       =&gt; 1 if outer delimiters should be added
-     my %opts = @_;
-
-     my $indent = $opts{indent} // 0;
-     # Indentation of the whole structure, where applicable
-     my $nlindent1 = &quot;\n&quot; . ' ' x $indent;
-     # Indentation of individual items, where applicable
-     my $nlindent2 = &quot;\n&quot; . ' ' x ($indent + 4);
-
-     my $product;      # Finished product, or reference to a function that
-                       # produces a string, given $_
-     # The following are only used when $product is a function reference
-     my $delim_l;      # Left delimiter of structure
-     my $delim_r;      # Right delimiter of structure
-     my $separator;    # Item separator
-     my @items;        # Items to iterate over
-
-     if (ref($ref) eq &quot;ARRAY&quot;) {
-         if (scalar @$ref == 0) {
-             $product = $opts{delimiters} ? '[]' : '';
-         } else {
-             $product = sub {
-                 out_item(\$_, delimiters =&gt; 1, indent =&gt; $indent + 4)
-             };
-             $delim_l = ($opts{delimiters} ? '[' : '').$nlindent2;
-             $delim_r = $nlindent1.($opts{delimiters} ? ']' : '');
-             $separator = &quot;,$nlindent2&quot;;
-             @items = @$ref;
-         }
-     } elsif (ref($ref) eq &quot;HASH&quot;) {
-         if (scalar keys %$ref == 0) {
-             $product = $opts{delimiters} ? '{}' : '';
-         } else {
-             $product = sub {
-                 quotify1($_) . &quot; =&gt; &quot;
-                 . out_item($ref-&gt;{$_}, delimiters =&gt; 1, indent =&gt; $indent + 4)
-             };
-             $delim_l = ($opts{delimiters} ? '{' : '').$nlindent2;
-             $delim_r = $nlindent1.($opts{delimiters} ? '}' : '');
-             $separator = &quot;,$nlindent2&quot;;
-             @items = sort keys %$ref;
-         }
-     } elsif (ref($ref) eq &quot;SCALAR&quot;) {
-         $product = defined $$ref ? quotify1 $$ref : &quot;undef&quot;;
-     } else {
-         $product = defined $ref ? quotify1 $ref : &quot;undef&quot;;
-     }
-
-     if (ref($product) eq &quot;CODE&quot;) {
-         $delim_l . join($separator, map { &amp;$product } @items) . $delim_r;
-     } else {
-         $product;
-     }
- }
-
  # We must make sourcedir() return an absolute path, because configdata.pm
  # may be loaded as a module from any script in any directory, making
  # relative paths untrustable.  Because the result is used with 'use lib',
@@ -73,6 +14,8 @@
  sub sourcefile {
      return abs_path(catfile($config{sourcedir}, @_));
  }
+ use lib sourcedir('util', 'perl');
+ use OpenSSL::Util;
 -}
 package configdata;
 
@@ -86,23 +29,23 @@ our @EXPORT = qw(
     @disablables @disablables_int
 );
 
-our %config = ({- out_item(\%config); -});
-our %target = ({- out_item(\%target); -});
-our @disablables = ({- out_item(\@disablables) -});
-our @disablables_int = ({- out_item(\@disablables_int) -});
-our %disabled = ({- out_item(\%disabled); -});
-our %withargs = ({- out_item(\%withargs); -});
-our %unified_info = ({- out_item(\%unified_info); -});
+our %config = ({- dump_data(\%config, indent =&gt; 0); -});
+our %target = ({- dump_data(\%target, indent =&gt; 0); -});
+our @disablables = ({- dump_data(\@disablables, indent =&gt; 0) -});
+our @disablables_int = ({- dump_data(\@disablables_int, indent =&gt; 0) -});
+our %disabled = ({- dump_data(\%disabled, indent =&gt; 0); -});
+our %withargs = ({- dump_data(\%withargs, indent =&gt; 0); -});
+our %unified_info = ({- dump_data(\%unified_info, indent =&gt; 0); -});
 
 # Unexported, only used by OpenSSL::Test::Utils::available_protocols()
 our %available_protocols = (
-    tls  =&gt; [{- out_item(\@tls) -}],
-    dtls =&gt; [{- out_item(\@dtls) -}],
+    tls  =&gt; [{- dump_data(\@tls, indent =&gt; 0) -}],
+    dtls =&gt; [{- dump_data(\@dtls, indent =&gt; 0) -}],
 );
 
 # The following data is only used when this files is use as a script
-my @makevars = ({- out_item(\@makevars); -});
-my %disabled_info = ({- out_item(\%disabled_info); -});
+my @makevars = ({- dump_data(\@makevars, indent =&gt; 0); -});
+my %disabled_info = ({- dump_data(\%disabled_info, indent =&gt; 0); -});
 my @user_crossable = qw( {- join (' ', @user_crossable) -} );
 
 # If run directly, we can give some answers, and even reconfigure
@@ -110,6 +53,7 @@ unless (caller) {
     use Getopt::Long;
     use File::Spec::Functions;
     use File::Basename;
+    use File::Copy;
     use Pod::Usage;
 
     use lib '{- sourcedir('util', 'perl') -}';
@@ -119,6 +63,39 @@ unless (caller) {
 
     if (scalar @ARGV == 0) {
         # With no arguments, re-create the build file
+        # We do that in two steps, where the first step emits perl
+        # snipets.
+
+        my $buildfile = $target{build_file};
+        my $buildfile_template = &quot;$buildfile.in&quot;;
+        my @autowarntext = (
+            'WARNING: do not edit!',
+            &quot;Generated by configdata.pm from &quot;
+            .join(&quot;, &quot;, @{$config{build_file_templates}}),
+            &quot;via $buildfile_template&quot;
+        );
+        my %gendata = (
+            config =&gt; \%config,
+            target =&gt; \%target,
+            disabled =&gt; \%disabled,
+            withargs =&gt; \%withargs,
+            unified_info =&gt; \%unified_info,
+            autowarntext =&gt; \@autowarntext,
+            );
+
+        use lib '.';
+        use lib '{- sourcedir('Configurations') -}';
+        use gentemplate;
+
+        print 'Creating ',$buildfile_template,&quot;\n&quot;;
+        open my $buildfile_template_fh, &quot;&gt;$buildfile_template&quot;
+            or die &quot;Trying to create $buildfile_template: $!&quot;;
+        foreach (@{$config{build_file_templates}}) {
+            copy($_, $buildfile_template_fh)
+                or die &quot;Trying to copy $_ into $buildfile_template: $!&quot;;
+        }
+        gentemplate(output =&gt; $buildfile_template_fh, %gendata);
+        close $buildfile_template_fh;
 
         use OpenSSL::Template;
 
@@ -130,36 +107,23 @@ use lib '{- $config{builddir} -}';
 use platform;
 _____
 
-        my @autowarntext = (
-            'WARNING: do not edit!',
-            &quot;Generated by configdata.pm from &quot;
-            .join(&quot;, &quot;, @{$config{build_file_templates}})
-        );
-
-        print 'Creating ',$target{build_file},&quot;\n&quot;;
-        open BUILDFILE, &quot;&gt;$target{build_file}.new&quot;
-            or die &quot;Trying to create $target{build_file}.new: $!&quot;;
-        foreach (@{$config{build_file_templates}}) {
-            my $tmpl = OpenSSL::Template-&gt;new(TYPE =&gt; 'FILE',
-                                              SOURCE =&gt; $_);
-            $tmpl-&gt;fill_in(FILENAME =&gt; $_,
-                           OUTPUT =&gt; \*BUILDFILE,
-                           HASH =&gt; { config =&gt; \%config,
-                                     target =&gt; \%target,
-                                     disabled =&gt; \%disabled,
-                                     withargs =&gt; \%withargs,
-                                     unified_info =&gt; \%unified_info,
-                                     autowarntext =&gt; \@autowarntext },
-                           PREPEND =&gt; $prepend,
-                           # To ensure that global variables and functions
-                           # defined in one template stick around for the
-                           # next, making them combinable
-                           PACKAGE =&gt; 'OpenSSL::safe')
-                or die $Text::Template::ERROR;
-        }
+        print 'Creating ',$buildfile,&quot;\n&quot;;
+        open BUILDFILE, &quot;&gt;$buildfile.new&quot;
+            or die &quot;Trying to create $buildfile.new: $!&quot;;
+        my $tmpl = OpenSSL::Template-&gt;new(TYPE =&gt; 'FILE',
+                                          SOURCE =&gt; $buildfile_template);
+        $tmpl-&gt;fill_in(FILENAME =&gt; $_,
+                       OUTPUT =&gt; \*BUILDFILE,
+                       HASH =&gt; \%gendata,
+                       PREPEND =&gt; $prepend,
+                       # To ensure that global variables and functions
+                       # defined in one template stick around for the
+                       # next, making them combinable
+                       PACKAGE =&gt; 'OpenSSL::safe')
+            or die $Text::Template::ERROR;
         close BUILDFILE;
-        rename(&quot;$target{build_file}.new&quot;, $target{build_file})
-            or die &quot;Trying to rename $target{build_file}.new to $target{build_file}: $!&quot;;
+        rename(&quot;$buildfile.new&quot;, $buildfile)
+            or die &quot;Trying to rename $buildfile.new to $buildfile: $!&quot;;
 
         exit(0);
     }
diff --git a/tools/c_rehash.in b/tools/c_rehash.in
index 1566d141d3..54cad6138b 100644
--- a/tools/c_rehash.in
+++ b/tools/c_rehash.in
@@ -1,5 +1,5 @@
 #!{- $config{HASHBANGPERL} -}
-
+{- use OpenSSL::Util; -}
 # {- join(&quot;\n# &quot;, @autowarntext) -}
 # Copyright 1999-2021 The OpenSSL Project Authors. All Rights Reserved.
 #
diff --git a/util/perl/OpenSSL/Template.pm b/util/perl/OpenSSL/Template.pm
index ed89d15085..bed13d20f9 100644
--- a/util/perl/OpenSSL/Template.pm
+++ b/util/perl/OpenSSL/Template.pm
@@ -130,51 +130,6 @@ sub output_off {
 
 # Helper functions for the templates #################################
 
-# It might be practical to quotify some strings and have them protected
-# from possible harm.  These functions primarily quote things that might
-# be interpreted wrongly by a perl eval.
-
-# NOTE THAT THESE AREN'T CLASS METHODS!
-
-=over 4
-
-=item quotify1 STRING
-
-This adds quotes (&quot;) around the given string, and escapes any $, @, \,
-&quot; and ' by prepending a \ to them.
-
-=back
-
-=cut
-
-sub quotify1 {
-    my $s = shift @_;
-    $s =~ s/([\$\@\\&quot;'])/\\$1/g;
-    '&quot;'.$s.'&quot;';
-}
-
-=over 4
-
-=item quotify_l LIST
-
-For each defined element in LIST (i.e. elements that aren't undef), have
-it quotified with 'quotify1'.
-Undefined elements are ignored.
-
-=back
-
-=cut
-
-sub quotify_l {
-    map {
-        if (!defined($_)) {
-            ();
-        } else {
-            quotify1($_);
-        }
-    } @_;
-}
-
 =head1 SEE ALSO
 
 L&lt;Text::Template&gt;
diff --git a/util/perl/OpenSSL/Util.pm b/util/perl/OpenSSL/Util.pm
index 1c8c6afa44..8b3743aa2a 100644
--- a/util/perl/OpenSSL/Util.pm
+++ b/util/perl/OpenSSL/Util.pm
@@ -6,7 +6,7 @@
 # in the file LICENSE in the source distribution or at
 # <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
 
-package OpenSSL::Ordinals;
+package OpenSSL::Util;
 
 use strict;
 use warnings;
@@ -16,7 +16,7 @@ use Exporter;
 use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
 $VERSION = &quot;0.1&quot;;
 @ISA = qw(Exporter);
<A HREF="../../../mailman/listinfo/openssl-commits.html">- at EXPORT</A> = qw(cmp_versions);
<A HREF="../../../mailman/listinfo/openssl-commits.html">+ at EXPORT</A> = qw(cmp_versions quotify1 quotify_l dump_data);
 @EXPORT_OK = qw();
 
 =head1 NAME
@@ -85,4 +85,136 @@ sub cmp_versions {
     return $verdict;
 }
 
+# It might be practical to quotify some strings and have them protected
+# from possible harm.  These functions primarily quote things that might
+# be interpreted wrongly by a perl eval.
+
+=over 4
+
+=item quotify1 STRING
+
+This adds quotes (&quot;) around the given string, and escapes any $, @, \,
+&quot; and ' by prepending a \ to them.
+
+=back
+
+=cut
+
+sub quotify1 {
+    my $s = shift @_;
+    $s =~ s/([\$\@\\&quot;'])/\\$1/g;
+    '&quot;'.$s.'&quot;';
+}
+
+=over 4
+
+=item quotify_l LIST
+
+For each defined element in LIST (i.e. elements that aren't undef), have
+it quotified with 'quotify1'.
+Undefined elements are ignored.
+
+=cut
+
+sub quotify_l {
+    map {
+        if (!defined($_)) {
+            ();
+        } else {
+            quotify1($_);
+        }
+    } @_;
+}
+
+=item dump_data REF, OPTS
+
+Dump the data from REF into a string that can be evaluated into the same
+data by Perl.
+
+OPTS is the rest of the arguments, expected to be pairs formed with C&lt;&lt; =&gt; &gt;&gt;.
+The following OPTS keywords are understood:
+
+=over 4
+
+=item B&lt;delimiters =E&lt;gt&gt; 0 | 1&gt;
+
+Include the outer delimiter of the REF type in the resulting string if C&lt;1&gt;,
+otherwise not.
+
+=item B&lt;indent =E&lt;gt&gt; num&gt;
+
+The indentation of the caller, i.e. an initial value.  If not given, there
+will be no indentation at all, and the string will only be one line.
+
+=back
+
+=cut
+
+sub dump_data {
+    my $ref = shift;
+    # Available options:
+    # indent           =&gt; callers indentation ( undef for no indentation,
+    #                     an integer otherwise )
+    # delimiters       =&gt; 1 if outer delimiters should be added
+    my %opts = @_;
+
+    my $indent = $opts{indent} // 1;
+    # Indentation of the whole structure, where applicable
+    my $nlindent1 = defined $opts{indent} ? &quot;\n&quot; . ' ' x $indent : ' ';
+    # Indentation of individual items, where applicable
+    my $nlindent2 = defined $opts{indent} ? &quot;\n&quot; . ' ' x ($indent + 4) : ' ';
+    my %subopts = ();
+
+    $subopts{delimiters} = 1;
+    $subopts{indent} = $opts{indent} + 4 if defined $opts{indent};
+
+    my $product;      # Finished product, or reference to a function that
+                      # produces a string, given $_
+    # The following are only used when $product is a function reference
+    my $delim_l;      # Left delimiter of structure
+    my $delim_r;      # Right delimiter of structure
+    my $separator;    # Item separator
+    my @items;        # Items to iterate over
+
+     if (ref($ref) eq &quot;ARRAY&quot;) {
+         if (scalar @$ref == 0) {
+             $product = $opts{delimiters} ? '[]' : '';
+         } else {
+             $product = sub {
+                 dump_data(\$_, %subopts)
+             };
+             $delim_l = ($opts{delimiters} ? '[' : '').$nlindent2;
+             $delim_r = $nlindent1.($opts{delimiters} ? ']' : '');
+             $separator = &quot;,$nlindent2&quot;;
+             @items = @$ref;
+         }
+     } elsif (ref($ref) eq &quot;HASH&quot;) {
+         if (scalar keys %$ref == 0) {
+             $product = $opts{delimiters} ? '{}' : '';
+         } else {
+             $product = sub {
+                 quotify1($_) . &quot; =&gt; &quot; . dump_data($ref-&gt;{$_}, %subopts);
+             };
+             $delim_l = ($opts{delimiters} ? '{' : '').$nlindent2;
+             $delim_r = $nlindent1.($opts{delimiters} ? '}' : '');
+             $separator = &quot;,$nlindent2&quot;;
+             @items = sort keys %$ref;
+         }
+     } elsif (ref($ref) eq &quot;SCALAR&quot;) {
+         $product = defined $$ref ? quotify1 $$ref : &quot;undef&quot;;
+     } else {
+         $product = defined $ref ? quotify1 $ref : &quot;undef&quot;;
+     }
+
+     if (ref($product) eq &quot;CODE&quot;) {
+         $delim_l . join($separator, map { &amp;$product } @items) . $delim_r;
+     } else {
+         $product;
+     }
+}
+
+=back
+
+=cut
+
 1;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="034320.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="034322.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34321">[ date ]</a>
              <a href="thread.html#34321">[ thread ]</a>
              <a href="subject.html#34321">[ subject ]</a>
              <a href="author.html#34321">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
