<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2021-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1621521026.112333.32526.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="034352.html">
   <LINK REL="Next"  HREF="034354.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>dev at ddvo.net</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1621521026.112333.32526.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">dev at ddvo.net
       </A><BR>
    <I>Thu May 20 14:30:26 UTC 2021</I>
    <P><UL>
        <LI>Previous message: <A HREF="034352.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="034354.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34353">[ date ]</a>
              <a href="thread.html#34353">[ thread ]</a>
              <a href="subject.html#34353">[ subject ]</a>
              <a href="author.html#34353">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  41d331b6f02267dbaa24cf35b9810994199431f4 (commit)
       via  7d3349276a5ff72535747a7f881be51076343165 (commit)
       via  eb9b532089e4b8a1d233fc2486db94f9596d5c98 (commit)
       via  f35a9b6a2d53190b65360b68540bc688fff1c704 (commit)
       via  d3fc80abfc71dbe6e74bdf2af09df328380096a8 (commit)
       via  9ad9002dd5f705d528ae20acb0e1b53767cde3dd (commit)
       via  435e659a03d12e98bb0502634d22002685b71ec9 (commit)
       via  ff3810332483f79b55f90db0ca9f93145d8f06b5 (commit)
      from  f14bead2c4898e484b6c01808c07edf3b61f01e9 (commit)


- Log -----------------------------------------------------------------
commit 41d331b6f02267dbaa24cf35b9810994199431f4
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Fri Apr 30 07:30:33 2021 +0200

    check-format.pl: Rename '*-cmt' options '*-comment'
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15077">https://github.com/openssl/openssl/pull/15077</A>)

commit 7d3349276a5ff72535747a7f881be51076343165
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Thu Apr 29 22:09:55 2021 +0200

    check-format.pl: Rename 'one-letter' to 'single-letter', do not report 'l'
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15077">https://github.com/openssl/openssl/pull/15077</A>)

commit eb9b532089e4b8a1d233fc2486db94f9596d5c98
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Thu Apr 29 22:02:41 2021 +0200

    check-format.pl: Allow extra space before end-of-line comments unless -e|--eol-cmt given
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15077">https://github.com/openssl/openssl/pull/15077</A>)

commit f35a9b6a2d53190b65360b68540bc688fff1c704
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Thu Apr 29 19:43:16 2021 +0200

    check-format.pl: Replace 'SPC' and 'spc' by 'space' in reports and option names
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15077">https://github.com/openssl/openssl/pull/15077</A>)

commit d3fc80abfc71dbe6e74bdf2af09df328380096a8
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Thu Apr 29 09:41:30 2021 +0200

    check-format.pl: Fix false positive on struct/union/enum in func return type
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15077">https://github.com/openssl/openssl/pull/15077</A>)

commit 9ad9002dd5f705d528ae20acb0e1b53767cde3dd
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Thu Apr 29 08:05:10 2021 +0200

    check-format.pl: Fix false positive &quot;no SPC before binary '*'&quot; for '!*'
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15077">https://github.com/openssl/openssl/pull/15077</A>)

commit 435e659a03d12e98bb0502634d22002685b71ec9
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Thu Apr 29 07:57:36 2021 +0200

    check-format.pl: Report needless intermediate multiple SPC only on -e or --extra-spc
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15077">https://github.com/openssl/openssl/pull/15077</A>)

commit ff3810332483f79b55f90db0ca9f93145d8f06b5
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Wed Apr 28 21:45:07 2021 +0200

    check-format.pl: Add check for constant left of comparison operator
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15077">https://github.com/openssl/openssl/pull/15077</A>)

-----------------------------------------------------------------------

Summary of changes:
 util/check-format-test-negatives.c |  17 ++--
 util/check-format-test-positives.c |  15 +--
 util/check-format.pl               | 181 ++++++++++++++++++++-----------------
 3 files changed, 118 insertions(+), 95 deletions(-)

diff --git a/util/check-format-test-negatives.c b/util/check-format-test-negatives.c
index c9f77ecf6c..8149ff2b58 100644
--- a/util/check-format-test-negatives.c
+++ b/util/check-format-test-negatives.c
@@ -15,13 +15,13 @@
  */
 
 /*-
- * allow double space  in format-tagged multi-line comment
+ * allow extra SPC in format-tagged multi-line comment
  */
 int f(void) /*
              * trailing multi-line comment
              */
 {
-    if (ctx == NULL) { /* non-leading intra-line comment */
+    if (ctx == NULL) {    /* non-leading end-of-line comment */
         if (/* comment after '(' */ pem_name != NULL /* comment before ')' */)
             /* entire-line comment indent usually like for the following line */
             return NULL; /* hanging indent also for this line after comment */
@@ -150,6 +150,10 @@ int f(void) /*
         hanging_stmt;
 }
 
+/* should not trigger: constant on LHS of comparison or assignment operator */
+X509 *x509 = NULL;
+int y = a + 1 &lt; b;
+
 const OPTIONS passwd_options[] = {
     {&quot;aixmd5&quot;, OPT_AIXMD5, '-', &quot;AIX MD5-based password algorithm&quot;},
 #if !defined(OPENSSL_NO_DES) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
@@ -269,11 +273,12 @@ static varref cmp_vars[] = { /* comment.  comment?  comment!  */
         /* comment */ \
     }
 
-/* 'struct' in function header */
-static int f(struct pem_pass_data *pass_data)
+union un var; /* struct/union/enum in variable type */
+struct provider_store_st *f() /* struct/union/enum in function return type */
+{
+}
+static void f(struct pem_pass_data *data) /* struct/union/enum in arg list */
 {
-    if (pass_data == NULL)
-        return 0;
 }
 
 static void *fun(void)
diff --git a/util/check-format-test-positives.c b/util/check-format-test-positives.c
index 5174a2b530..6281c5cbce 100644
--- a/util/check-format-test-positives.c
+++ b/util/check-format-test-positives.c
@@ -48,11 +48,11 @@
 */ /*@ unexpected comment ending delimiter outside comment */
 /*@ comment line is 4 columns tooooooooooooooooo wide, reported unless sloppy-len */
 /*@ comment line is 5 columns toooooooooooooooooooooooooooooooooooooooooooooo wide */
-#define X   1       /*@0 double space false negative due to coincidence */
+#define X   1       /*@0 extra space false negative due to coincidence */
  #define Y  2       /*@ indent of preprocessor directive off by 1 (must be 0) */
-typedef struct  {   /*@0 double space in code, reported unless sloppy-spc */
-    enum {          /*@1 double space  in comment, reported unless sloppy-spc */
-           w = 0 /*@2 hanging expr indent off by 1, or 3 for lines after '{' */
+typedef struct  {   /*@0 extra space in code, reported unless sloppy-spc */
+    enum {          /*@1 extra space  in comment, reported unless sloppy-spc */
+           w = 0 /*@ hanging expr indent off by 1, or 3 for lines after '{' */
              &amp;&amp; 1,  /*@ hanging expr indent off by 3, or -1 for leading '&amp;&amp;' */
          x = 1,     /*@ hanging expr indent off by -1 */
           y,z       /*@ no space after ',', reported unless sloppy-spc */
@@ -72,10 +72,11 @@ void main(int n) {  /*@ opening brace at end of function definition header */
 #endif              /*@ unexpected #endif */
 int f (int a,       /*@ space after fn before '(', reported unless sloppy-spc */
       int b,        /*@ hanging expr indent off by -1 */
-       long l)      /*@ one-letter name 'l' */
+       long I)      /*@ single-letter name 'I' */
 { int               /*@ code after '{' opening a block */
     xx = 1) +       /*@ unexpected closing parenthesis */
-        2] -        /*@ unexpected closing bracket */
+        0L &lt;        /*@ constant on LHS of comparison operator */
+        a] -        /*@ unexpected closing bracket */
         3: *        /*@ unexpected ':' (without preceding '?') within expr */
         4};         /*@ unexpected closing brace within expression */
     char y[] = {    /*@0 unclosed brace within initializer/enum expression */
@@ -91,7 +92,7 @@ int f (int a,       /*@ space after fn before '(', reported unless sloppy-spc */
            b,       /*@ expr indent as on line above, accepted if sloppy-hang */
     b, /*@ expr indent off -8 but @ extra indent accepted if sloppy-hang */
    &quot;again aligned&quot; /*@ expr indent off by -9 (left of stmt indent, */ &quot;right&quot;,
-            123 == /*@ .. so reported also with sloppy-hang; this line is too long */ 456
+            abc == /*@ .. so reported also with sloppy-hang; this line is too long */ 456
 # define MAC(A) (A) /*@ nesting indent of preprocessor directive off by 1 */
              ? 1    /*@ hanging expr indent off by 1 */
               : 2); /*@ hanging expr indent off by 2, or 1 for leading ':' */
diff --git a/util/check-format.pl b/util/check-format.pl
index 2a9adc6fb8..72cf53d189 100755
--- a/util/check-format.pl
+++ b/util/check-format.pl
@@ -13,8 +13,9 @@
 #
 # usage:
 #   check-format.pl [-l|--sloppy-len] [-l|--sloppy-bodylen]
-#                   [-s|--sloppy-spc] [-c|--sloppy-cmt] [-m|--sloppy-macro]
-#                   [-h|--sloppy-hang] [-1|--1-stmt]
+#                   [-s|--sloppy-space] [-c|--sloppy-comment]
+#                   [-m|--sloppy-macro] [-h|--sloppy-hang]
+#                   [-e|--eol-comment] [-1|--1-stmt]
 #                   &lt;files&gt;
 #
 # run self-tests:
@@ -27,23 +28,24 @@
 # Still it should be useful for detecting most typical glitches.
 #
 # options:
-#  -l | --sloppy-len   increase accepted max line length from 80 to 84
+#  -l | --sloppy-len     increase accepted max line length from 80 to 84
 #  -l | --sloppy-bodylen do not report function body length &gt; 200
-#  -s | --sloppy-spc   do not report whitespace nits
-#  -c | --sloppy-cmt   do not report indentation of comments
-#                      Otherwise for each multi-line comment the indentation of
-#                      its lines is checked for consistency. For each comment
-#                      that does not begin to the right of normal code its
-#                      indentation must be as for normal code, while in case it
-#                      also has no normal code to its right it is considered to
-#                      refer to the following line and may be indented equally.
-#  -m | --sloppy-macro allow missing extra indentation of macro bodies
-#  -h | --sloppy-hang  when checking hanging indentation, do not report
-#                      * same indentation as on line before
-#                      * same indentation as non-hanging indent level
-#                      * indentation moved left (not beyond non-hanging indent)
-#                        just to fit contents within the line length limit
-#  -1 | --1-stmt       do more aggressive checks for { 1 stmt } - see below
+#  -s | --sloppy-space   do not report whitespace nits
+#  -c | --sloppy-comment do not report indentation of comments
+#                        Otherwise for each multi-line comment the indentation of
+#                        its lines is checked for consistency. For each comment
+#                        that does not begin to the right of normal code its
+#                        indentation must be as for normal code, while in case it
+#                        also has no normal code to its right it is considered to
+#                        refer to the following line and may be indented equally.
+#  -m | --sloppy-macro   allow missing extra indentation of macro bodies
+#  -h | --sloppy-hang    when checking hanging indentation, do not report
+#                        * same indentation as on line before
+#                        * same indentation as non-hanging indent level
+#                        * indentation moved left (not beyond non-hanging indent)
+#                          just to fit contents within the line length limit
+#  -e | --eol-comment    report needless intermediate multiple consecutive spaces also before end-of-line comments
+#  -1 | --1-stmt         do more aggressive checks for { 1 stmt } - see below
 #
 # There are non-trivial false positives and negatives such as the following.
 #
@@ -64,12 +66,13 @@
 #   Yet with the --1-stmt option false positives are preferred over negatives.
 #   False negatives occur if the braces are more than two non-empty lines apart.
 #
-# * Use of multiple consecutive spaces is regarded a coding style nit except
-#   when done in order to align certain columns over multiple lines, e.g.:
+# * The presence of multiple consecutive spaces is regarded a coding style nit
+#   except when this is before end-of-line comments (unless the --eol-comment is given) and
+#   except when done in order to align certain columns over multiple lines, e.g.:
 #   # define AB  1
 #   # define CDE 22
 #   # define F   3333
-#   This pattern is recognized - and consequently double space not reported -
+#   This pattern is recognized - and consequently extra space not reported -
 #   for a given line if in the nonempty line before or after (if existing)
 #   for each occurrence of &quot;  \S&quot; (where \S means non-space) in the given line
 #   there is &quot; \S&quot; in the other line in the respective column position.
@@ -102,6 +105,7 @@ my $sloppy_SPC = 0;
 my $sloppy_hang = 0;
 my $sloppy_cmt = 0;
 my $sloppy_macro = 0;
+my $eol_cmt = 0;
 my $extended_1_stmt = 0;
 
 while ($ARGV[0] =~ m/^-(\w|-[\w\-]+)$/) {
@@ -110,14 +114,16 @@ while ($ARGV[0] =~ m/^-(\w|-[\w\-]+)$/) {
         $max_length += INDENT_LEVEL;
     } elsif ($arg =~ m/^(b|-sloppy-bodylen)$/) {
         $sloppy_bodylen = 1;
-    } elsif ($arg =~ m/^(s|-sloppy-spc)$/) {
-        $sloppy_SPC = 1;
-    } elsif ($arg =~ m/^(c|-sloppy-cmt)$/) {
+    } elsif ($arg =~ m/^(s|-sloppy-space)$/) {
+        $sloppy_SPC= 1;
+    } elsif ($arg =~ m/^(c|-sloppy-comment)$/) {
         $sloppy_cmt = 1;
     } elsif ($arg =~ m/^(m|-sloppy-macro)$/) {
         $sloppy_macro = 1;
     } elsif ($arg =~ m/^(h|-sloppy-hang)$/) {
         $sloppy_hang = 1;
+    } elsif ($arg =~ m/^(e|-eol-comment)$/) {
+        $eol_cmt = 1;
     } elsif ($arg =~ m/^(1|-1-stmt)$/) {
         $extended_1_stmt = 1;
     } else {
@@ -130,10 +136,11 @@ my $self_test;             # whether the current input file is regarded to conta
 my $line;                  # current line number
 my $line_before;           # number of previous not essentially empty line (containing at most whitespace and '\')
 my $line_before2;          # number of not essentially empty line before previous not essentially empty line
-my $contents;              # contents of current line
-my $contents_before;       # contents of $line_before, if $line_before &gt; 0
+my $contents;              # contents of current line (without blinding)
+#  $_                      # current line, where comments etc. get blinded
+my $contents_before;       # contents of $line_before (without blinding), if $line_before &gt; 0
 my $contents_before_;      # contents of $line_before after blinding comments etc., if $line_before &gt; 0
-my $contents_before2;      # contents of $line_before2, if $line_before2 &gt; 0
+my $contents_before2;      # contents of $line_before2  (without blinding), if $line_before2 &gt; 0
 my $contents_before_2;     # contents of $line_before2 after blinding comments etc., if $line_before2 &gt; 0
 my $in_multiline_string;   # line starts within multi-line string literal
 my $count;                 # -1 or number of leading whitespace characters (except newline) in current line,
@@ -214,7 +221,7 @@ sub report_flexibly {
     my $line = shift;
     my $msg = shift;
     my $contents = shift;
-    my $report_SPC = $msg =~ /SPC/;
+    my $report_SPC = $msg =~ /space/;
     return if $report_SPC &amp;&amp; $sloppy_SPC;
 
     print &quot;$ARGV:$line:$msg:$contents&quot; unless $self_test;
@@ -239,9 +246,9 @@ sub parens_balance { # count balance of opening parentheses - closing parenthese
 
 sub blind_nonspace { # blind non-space text of comment as @, preserving length and spaces
     # the @ character is used because it cannot occur in normal program code so there is no confusion
-    # comment text is not blinded to whitespace in order to be able to check double SPC also in comments
+    # comment text is not blinded to whitespace in order to be able to check extra SPC also in comments
     my $comment_text = shift;
-    $comment_text =~ s/([\.\?\!])\s\s/$1. /g; # in double SPC checks allow one extra space after period '.', '?', or '!' in comments
+    $comment_text =~ s/([\.\?\!])\s\s/$1. /g; # in extra SPC checks allow one extra SPC after period '.', '?', or '!' in comments
     return $comment_text =~ tr/ /@/cr;
 }
 
@@ -507,7 +514,7 @@ while (&lt;&gt;) { # loop over all lines of all input files
     if ($in_comment &gt; 0) { # this still includes the last line of multi-line commment
         my ($head, $any_symbol, $cmt_text) = m/^(\s*)(.?)(.*)$/;
         if ($any_symbol eq &quot;*&quot;) {
-            report(&quot;no SPC after leading '*' in multi-line comment&quot;) if $cmt_text =~ m|^[^/\s$self_test_exception]|;
+            report(&quot;no space after leading '*' in multi-line comment&quot;) if $cmt_text =~ m|^[^/\s$self_test_exception]|;
         } else {
             report(&quot;no leading '*' in multi-line comment&quot;);
         }
@@ -516,8 +523,8 @@ while (&lt;&gt;) { # loop over all lines of all input files
 
     # detect end of comment, must be within multi-line comment, check if it is preceded by non-whitespace text
     if ((my ($head, $tail) = m|^(.*?)\*/(.*)$|) &amp;&amp; $1 ne '/') { # ending comment: '*/'
-        report(&quot;neither SPC nor '*' before '*/'&quot;) if $head =~ m/[^*\s]$/;
-        report(&quot;no SPC after '*/'&quot;) if $tail =~ m/^[^\s,;)}\]]/; # no space or ,;)}] after '*/'
+        report(&quot;neither space nor '*' before '*/'&quot;) if $head =~ m/[^*\s]$/;
+        report(&quot;no space after '*/'&quot;) if $tail =~ m/^[^\s,;)}\]]/; # no space or ,;)}] after '*/'
         if (!($head =~ m|/\*|)) { # not begin of comment '/*', which is is handled below
             if ($in_comment == 0) {
                 report(&quot;unexpected '*/' outside comment&quot;);
@@ -540,9 +547,9 @@ while (&lt;&gt;) { # loop over all lines of all input files
     # detect begin of comment, check if it is followed by non-space text
   MATCH_COMMENT:
     if (my ($head, $opt_minus, $tail) = m|^(.*?)/\*(-?)(.*)$|) { # begin of comment: '/*'
-        report(&quot;no SPC before '/*'&quot;)
+        report(&quot;no space before '/*'&quot;)
             if $head =~ m/[^\s(\*]$/; # not space, '(', or or '*' (needed to allow '*/') before comment delimiter
-        report(&quot;neither SPC nor '*' after '/*' or '/*-'&quot;) if $tail =~ m/^[^\s*$self_test_exception]/;
+        report(&quot;neither space nor '*' after '/*' or '/*-'&quot;) if $tail =~ m/^[^\s*$self_test_exception]/;
         my $cmt_text = $opt_minus.$tail; # preliminary
         if ($in_comment &gt; 0) {
             report(&quot;unexpected '/*' inside multi-line comment&quot;);
@@ -604,17 +611,17 @@ while (&lt;&gt;) { # loop over all lines of all input files
 
     my $in_multiline_comment = ($in_comment &gt; 1 || $in_comment &lt; 0); # $in_multiline_comment refers to line before
     if (!$sloppy_SPC &amp;&amp; !($in_multiline_comment &amp;&amp; $formatted_comment)) {
-        sub dbl_SPC {
+        sub extra_SPC {
             my $intra_line = shift;
-            return &quot;double SPC&quot;.($intra_line =~ m/@\s\s/ ?
-                                 $in_comment != 0 ? &quot; in multi-line comment&quot;
-                                                  : &quot; in intra-line comment&quot; : &quot;&quot;);
+            return &quot;extra space&quot;.($intra_line =~ m/@\s\s/ ?
+                                  $in_comment != 0 ? &quot; in multi-line comment&quot;
+                                                   : &quot; in intra-line comment&quot; : &quot;&quot;);
         }
-        sub split_line_head {
+        sub split_line_head { # split line contents into header containing leading spaces and the first non-space char, and the rest of the line
             my $comment_symbol =
                 $in_comment != 0 ? &quot;@&quot; : &quot;&quot;; # '@' will match the blinded leading '*' in multi-line comment
                                              # $in_comment may pertain to the following line due to delayed check
-            # do not check for double SPC in leading spaces including any '#' (or '*' within multi-line comment)
+            # do not check for extra SPC in leading spaces including any '#' (or '*' within multi-line comment)
             shift =~ m/^(\s*([#$comment_symbol]\s*)?)(.*?)\s*$/;
             return ($1, $3);
         }
@@ -622,26 +629,29 @@ while (&lt;&gt;) { # loop over all lines of all input files
         my ($head1, $intra_line1) = split_line_head($contents_before_ ) if $line_before &gt; 0;
         my ($head2, $intra_line2) = split_line_head($contents_before_2) if $line_before2 &gt; 0;
         if ($line_before &gt; 0) { # check with one line delay, such that at least $contents_before is available
-            sub column_alignments_only {
-                my $head = shift;
-                my $intra = shift;
-                my $contents = shift;
-                # check if all double SPC in $intra is used only for multi-line column alignment with $contents
+            sub column_alignments_only { # return 1 if the given line has multiple consecutive spaces only at columns that match the reference line
+                # all parameter strings are assumed to contain contents after blinding comments etc.
+                my $head = shift;     # leading spaces and the first non-space char
+                my $intra = shift;    # the rest of the line contents
+                my $contents = shift; # reference line
+                # check if all extra SPC in $intra is used only for multi-line column alignment with $contents
                 my $offset = length($head);
                 for (my $col = 0; $col &lt; length($intra) - 2; $col++) {
-                   return 0 if substr($intra   , $col, 3) =~ m/\s\s\S/ # double space (after leading space)
-                          &amp;&amp; !(substr($contents, $col + $offset + 1, 2) =~ m/\s\S/)
+                    my $substr = substr($intra, $col);
+                    next unless $substr =~ m/^\s\s\S/; # extra SPC (but not in leading spaces of the line)
+                    next if !$eol_cmt &amp;&amp; $substr =~ m/^[@\s]+$/; # end-of-line comment
+                    return 0 unless substr($contents, $col + $offset + 1, 2) =~ m/\s\S/; # reference line contents do not match
                 }
                 return 1;
             }
-            report_flexibly($line_before, dbl_SPC($intra_line1), $contents_before) if $intra_line1 =~ m/\s\s\S/ &amp;&amp;
+            report_flexibly($line_before, extra_SPC($intra_line1), $contents_before) if $intra_line1 =~ m/\s\s\S/ &amp;&amp;
                !(    column_alignments_only($head1, $intra_line1, $_                )    # compare with $line
                  || ($line_before2 &gt; 0 &amp;&amp;
                      column_alignments_only($head1, $intra_line1, $contents_before_2))); # compare w/ $line_before2
-            report(dbl_SPC($intra_line)) if $intra_line  =~ m/\s\s\S/ &amp;&amp; eof
+            report(extra_SPC($intra_line)) if $intra_line  =~ m/\s\s\S/ &amp;&amp; eof
                 &amp;&amp; ! column_alignments_only($head , $intra_line , $contents_before_ )  ; # compare w/ $line_before
         } elsif (eof) { # special case: just one line exists
-            report(dbl_SPC($intra_line)) if $intra_line  =~ m/\s\s\S/;
+            report(extra_SPC($intra_line)) if $intra_line  =~ m/\s\s\S/;
         }
         # ignore paths in #include
         $intra_line =~ s/^(include\s*)(&quot;.*?&quot;|&lt;.*?&gt;)/$1/e if $head =~ m/#/;
@@ -656,47 +666,47 @@ while (&lt;&gt;) { # loop over all lines of all input files
         # remove blinded comments etc. directly before ,;)}]
         while ($intra_line =~ s/\s?@+([,;\)\}\]])/$1/e) {} # /g does not work here
         # treat remaining blinded comments and string literal contents as (single) space during matching below
-        $intra_line =~ s/@+/ /g;                     # note that double SPC has already been handled above
+        $intra_line =~ s/@+/ /g;                     # note that extra SPC has already been handled above
         $intra_line =~ s/\s+$//;                     # strip any (resulting) space at EOL
         $intra_line =~ s/(for\s*\([^;]*);;(\))/&quot;$1$2&quot;/eg; # strip trailing ';;' in for (;;)
         $intra_line =~ s/(for\s*\([^;]+;[^;]+);(\))/&quot;$1$2&quot;/eg; # strip trailing ';' in for (;;)
         $intra_line =~ s/(=\s*)\{ /&quot;$1@ &quot;/eg;        # do not report {SPC in initializers such as ' = { 0, };'
         $intra_line =~ s/, \};/, @;/g;               # do not report SPC} in initializers such as ' = { 0, };'
-        report(&quot;SPC before '$1'&quot;) if $intra_line =~ m/[\w)\]]\s+(\+\+|--)/;  # postfix ++/-- with preceding space
-        report(&quot;SPC after '$1'&quot;)  if $intra_line =~ m/(\+\+|--)\s+[a-zA-Z_(]/; # prefix ++/-- with following space
+        report(&quot;space before '$1'&quot;) if $intra_line =~ m/[\w)\]]\s+(\+\+|--)/;  # postfix ++/-- with preceding space
+        report(&quot;space after '$1'&quot;)  if $intra_line =~ m/(\+\+|--)\s+[a-zA-Z_(]/; # prefix ++/-- with following space
         $intra_line =~ s/\.\.\./@/g;                 # blind '...'
-        report(&quot;SPC before '$1'&quot;) if $intra_line =~ m/\s(\.|-&gt;)/;            # '.' or '-&gt;' with preceding space
-        report(&quot;SPC after '$1'&quot;)  if $intra_line =~ m/(\.|-&gt;)\s/;            # '.' or '-&gt;' with following space
+        report(&quot;space before '$1'&quot;) if $intra_line =~ m/\s(\.|-&gt;)/;            # '.' or '-&gt;' with preceding space
+        report(&quot;space after '$1'&quot;)  if $intra_line =~ m/(\.|-&gt;)\s/;            # '.' or '-&gt;' with following space
         $intra_line =~ s/\-\&gt;|\+\+|\-\-/@/g;         # blind '-&gt;,', '++', and '--'
-        report(&quot;SPC before '$2'&quot;)     if $intra_line =~ m/[^:]\s+(;)/;       # space before ';' but not after ':'
-        report(&quot;SPC before '$1'&quot;)     if $intra_line =~ m/\s([,)\]])/;       # space before ,)]
-        report(&quot;SPC after '$1'&quot;)      if $intra_line =~ m/([(\[~!])\s/;      # space after ([~!
-        report(&quot;SPC after '$1'&quot;)      if $intra_line =~ m/(defined)\s/;      # space after 'defined'
-        report(&quot;no SPC before '=' or '&lt;op&gt;='&quot;) if $intra_line =~ m/\S(=)/;   # '=' etc. without preceding space
-        report(&quot;no SPC before '$1'&quot;)  if $intra_line =~ m/\S([|\/%&lt;&gt;^\?])/;  # |/%&lt;&gt;^? without preceding space
+        report(&quot;space before '$2'&quot;)     if $intra_line =~ m/[^:]\s+(;)/;       # space before ';' but not after ':'
+        report(&quot;space before '$1'&quot;)     if $intra_line =~ m/\s([,)\]])/;       # space before ,)]
+        report(&quot;space after '$1'&quot;)      if $intra_line =~ m/([(\[~!])\s/;      # space after ([~!
+        report(&quot;space after '$1'&quot;)      if $intra_line =~ m/(defined)\s/;      # space after 'defined'
+        report(&quot;no space before '=' or '&lt;op&gt;='&quot;) if $intra_line =~ m/\S(=)/;   # '=' etc. without preceding space
+        report(&quot;no space before '$1'&quot;)  if $intra_line =~ m/\S([|\/%&lt;&gt;^\?])/;  # |/%&lt;&gt;^? without preceding space
         # TODO ternary ':' without preceding SPC, while allowing no SPC before ':' after 'case'
-        report(&quot;no SPC before binary '$1'&quot;)  if $intra_line =~ m/[^\s{()\[]([+\-])/;# +/- without preceding space or {()[
+        report(&quot;no space before binary '$1'&quot;)  if $intra_line =~ m/[^\s{()\[]([+\-])/;# +/- without preceding space or {()[
                                                                              # or ')' (which is used f type casts)
-        report(&quot;no SPC before binary '$1'&quot;)  if $intra_line =~ m/[^\s{()\[*]([*])/; # '*' without preceding space or {()[*
-        report(&quot;no SPC before binary '$1'&quot;)  if $intra_line =~ m/[^\s{()\[]([&amp;])/;  # '&amp;' without preceding space or {()[
-        report(&quot;no SPC after ternary '$1'&quot;) if $intra_line =~ m/(:)[^\s\d]/; # ':' without following space or digit
-        report(&quot;no SPC after '$1'&quot;)   if $intra_line =~ m/([,;=|\/%&lt;&gt;^\?])\S/; # ,;=|/%&lt;&gt;^? without following space
-        report(&quot;no SPC after binary '$1'&quot;) if $intra_line=~m/[^{(\[]([*])[^\sa-zA-Z_(),*]/;# '*' w/o space or \w(),* after
+        report(&quot;no space before binary '$1'&quot;)  if $intra_line =~ m/[^\s{()\[*!]([*])/; # '*' without preceding space or {()[*!
+        report(&quot;no space before binary '$1'&quot;)  if $intra_line =~ m/[^\s{()\[]([&amp;])/;  # '&amp;' without preceding space or {()[
+        report(&quot;no space after ternary '$1'&quot;) if $intra_line =~ m/(:)[^\s\d]/; # ':' without following space or digit
+        report(&quot;no space after '$1'&quot;)   if $intra_line =~ m/([,;=|\/%&lt;&gt;^\?])\S/; # ,;=|/%&lt;&gt;^? without following space
+        report(&quot;no space after binary '$1'&quot;) if $intra_line=~m/[^{(\[]([*])[^\sa-zA-Z_(),*]/;# '*' w/o space or \w(),* after
         # TODO unary '*' must not be followed by SPC
-        report(&quot;no SPC after binary '$1'&quot;) if $intra_line=~m/([&amp;])[^\sa-zA-Z_(]/;  # '&amp;' w/o following space or \w(
+        report(&quot;no space after binary '$1'&quot;) if $intra_line=~m/([&amp;])[^\sa-zA-Z_(]/;  # '&amp;' w/o following space or \w(
         # TODO unary '&amp;' must not be followed by SPC
-        report(&quot;no SPC after binary '$1'&quot;) if $intra_line=~m/[^{(\[]([+\-])[^\s\d(]/;  # +/- w/o following space or \d(
+        report(&quot;no space after binary '$1'&quot;) if $intra_line=~m/[^{(\[]([+\-])[^\s\d(]/;  # +/- w/o following space or \d(
         # TODO unary '+' and '-' must not be followed by SPC
-        report(&quot;no SPC after '$2'&quot;)   if $intra_line =~ m/(^|\W)(if|while|for|switch|case)[^\w\s]/; # kw w/o SPC
-        report(&quot;no SPC after '$2'&quot;)   if $intra_line =~ m/(^|\W)(return)[^\w\s;]/;  # return w/o SPC or ';'
-        report(&quot;SPC after function/macro name&quot;)
+        report(&quot;no space after '$2'&quot;)   if $intra_line =~ m/(^|\W)(if|while|for|switch|case)[^\w\s]/; # kw w/o SPC
+        report(&quot;no space after '$2'&quot;)   if $intra_line =~ m/(^|\W)(return)[^\w\s;]/;  # return w/o SPC or ';'
+        report(&quot;space after function/macro name&quot;)
                                       if $intra_line =~ m/(\w+)\s+\(/        # fn/macro name with space before '('
        &amp;&amp; !($1 =~ m/^(if|while|for|switch|return|typedef|void|char|unsigned|int|long|float|double)$/) # not keyword
                                     &amp;&amp; !(m/^\s*#\s*define\s/); # we skip macro definitions here because macros
                                     # without parameters but with body beginning with '(', e.g., '#define X (1)',
                                     # would lead to false positives - TODO also check for macros with parameters
-        report(&quot;no SPC before '{'&quot;)   if $intra_line =~ m/[^\s{(\[]\{/;      # '{' without preceding space or {([
-        report(&quot;no SPC after '}'&quot;)    if $intra_line =~ m/\}[^\s,;\])}]/;    # '}' without following space or ,;])}
+        report(&quot;no space before '{'&quot;)   if $intra_line =~ m/[^\s{(\[]\{/;      # '{' without preceding space or {([
+        report(&quot;no space after '}'&quot;)    if $intra_line =~ m/\}[^\s,;\])}]/;    # '}' without following space or ,;])}
     }
 
     # preprocessor directives @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@ -846,7 +856,12 @@ while (&lt;&gt;) { # loop over all lines of all input files
         }
     }
 
-    report(&quot;one-letter name '$2'&quot;) if (m/(^|.*\W)([lIO])(\W.*|$)/); # single-letter name 'l', 'I', or 'O'
+    report(&quot;single-letter name '$2'&quot;) if (m/(^|.*\W)([IO])(\W.*|$)/); # single-letter name 'I' or 'O' # maybe re-add 'l'?
+    # constant on LHS of comparison or assignment, e.g., NULL != x or 'a' &lt; c, but not a + 1 == b
+    report(&quot;constant on LHS of '$2'&quot;)
+        if (m/(['&quot;]|([\+\-\*\/\/%\&amp;\|\^&lt;&gt;]\s*)?\W[0-9]+L?|NULL)\s*([\!&lt;&gt;=]=|[&lt;=&gt;][^&lt;&gt;])/ &amp;&amp; $2 eq &quot;&quot;);
+
+    # TODO report #if 0 and #if 1
 
     # TODO report empty line within local variable definitions
 
@@ -918,10 +933,12 @@ while (&lt;&gt;) { # loop over all lines of all input files
     }
 
     # set $in_typedecl and potentially $hanging_offset for type declaration
-    if (!$in_expr &amp;&amp; @nested_indents == 0 &amp;&amp; # not in expression
-        m/(^|^.*\W)(typedef|struct|union|enum)(\W.*|$)$/ &amp;&amp;
-        parens_balance($1) == 0) { # not in newly started expression
-        # not needed: $keyword_opening_brace = $2 if $3 =~ m/\{/;
+    if (!$in_expr &amp;&amp; @nested_indents == 0 # not in expression
+        &amp;&amp; m/(^|^.*\W)(typedef|struct|union|enum)(\W.*|$)$/
+        &amp;&amp; parens_balance($1) == 0 # not in newly started expression or function arg list
+        &amp;&amp; ($2 eq &quot;typedef&quot; || !($3 =~ m/\s*\w++\s*(.)/ &amp;&amp; $1 ne &quot;{&quot;)) # 'struct'/'union'/'enum' &lt;name&gt; not followed by '{'
+        # not needed: &amp;&amp; $keyword_opening_brace = $2 if $3 =~ m/\{/;
+        ) {
         $in_typedecl++;
         $hanging_offset += INDENT_LEVEL if m/\*.*\(/; # '*' followed by '(' - seems consistent with Emacs C mode
     }
@@ -1079,8 +1096,8 @@ while (&lt;&gt;) { # loop over all lines of all input files
         $hanging_offset = 0; # compensate for this in case macro ends, e.g., as 'while (0)'
     }
 
-    if (m/^\s*$/) { # essentially empty line: just whitespace (and maybe a '\')
-            report(&quot;empty line at beginnig of file&quot;) if $line == 1 &amp;&amp; !$sloppy_SPC;
+    if (m/^\s*$/) { # at begin of file essentially empty line: just whitespace (and maybe a '\')
+            report(&quot;leading &quot;.($1 eq &quot;&quot; ? &quot;empty&quot; :&quot;whitespace&quot;).&quot; line&quot;) if $line == 1 &amp;&amp; !$sloppy_SPC;
     } else {
         if ($line_before &gt; 0) {
             my $linediff = $line - $line_before - 1;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="034352.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="034354.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34353">[ date ]</a>
              <a href="thread.html#34353">[ thread ]</a>
              <a href="subject.html#34353">[ subject ]</a>
              <a href="author.html#34353">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
