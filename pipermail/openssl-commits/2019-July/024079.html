<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-July/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1563806548.903119.14164.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024078.html">
   <LINK REL="Next"  HREF="024082.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1563806548.903119.14164.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Mon Jul 22 14:42:28 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="024078.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="024082.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24079">[ date ]</a>
              <a href="thread.html#24079">[ thread ]</a>
              <a href="subject.html#24079">[ subject ]</a>
              <a href="author.html#24079">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  d4c69c69d171edb17b4d609c15891a9599809ed0 (commit)
       via  2cafb1dff3ef13c470c4d2d7b1d8a1f7142d8813 (commit)
       via  e4c0ec6278f1fbfc50fcdd09769f65ca80866f6b (commit)
      from  a80278b071426c7262c07d3b29100573b94df16d (commit)


- Log -----------------------------------------------------------------
commit d4c69c69d171edb17b4d609c15891a9599809ed0
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Jul 18 15:07:13 2019 +0200

    Documentation: add provider-base(7), describing the base functions
    
    The base functions are the first tables of function pointers that
    libcrypto and the provider pass to each other, thereby providing a
    baseline with which they can communicate further with each other.
    
    This also contains an example for a ficticious provider, providing an
    implement of a fictitious algorithm for a fictitious operation.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9409">https://github.com/openssl/openssl/pull/9409</A>)

commit 2cafb1dff3ef13c470c4d2d7b1d8a1f7142d8813
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Jul 18 12:24:55 2019 +0200

    Documentation: Move the description of the fetching functions
    
    Now that the general descriptions have moved from
    doc/man3/EVP_MD_fetch.pod to doc/man7/provider.pod, the description of
    the fetching functions themselves can be moved to other pages where
    related functions are already described.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9409">https://github.com/openssl/openssl/pull/9409</A>)

commit e4c0ec6278f1fbfc50fcdd09769f65ca80866f6b
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Jul 18 12:23:23 2019 +0200

    Documentation: Add provider(7), for general description of providers
    
    This includes an enumeration of the providers supplied with OpenSSL,
    and what implementations they offer.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9409">https://github.com/openssl/openssl/pull/9409</A>)

-----------------------------------------------------------------------

Summary of changes:
 doc/man3/EVP_DigestInit.pod   |  25 ++-
 doc/man3/EVP_EncryptInit.pod  |  23 ++-
 doc/man3/EVP_KEYEXCH_free.pod |  18 +-
 doc/man3/EVP_MD_fetch.pod     | 249 -----------------------
 doc/man7/provider-base.pod    | 464 ++++++++++++++++++++++++++++++++++++++++++
 doc/man7/provider.pod         | 401 ++++++++++++++++++++++++++++++++++++
 6 files changed, 921 insertions(+), 259 deletions(-)
 delete mode 100644 doc/man3/EVP_MD_fetch.pod
 create mode 100644 doc/man7/provider-base.pod
 create mode 100644 doc/man7/provider.pod

diff --git a/doc/man3/EVP_DigestInit.pod b/doc/man3/EVP_DigestInit.pod
index bc10fa3..6f36f0a 100644
--- a/doc/man3/EVP_DigestInit.pod
+++ b/doc/man3/EVP_DigestInit.pod
@@ -2,6 +2,7 @@
 
 =head1 NAME
 
+EVP_MD_fetch,
 EVP_MD_CTX_new, EVP_MD_CTX_reset, EVP_MD_CTX_free, EVP_MD_CTX_copy,
 EVP_MD_CTX_copy_ex, EVP_MD_CTX_ctrl, EVP_MD_CTX_set_params, EVP_MD_CTX_get_params,
 EVP_MD_CTX_set_flags, EVP_MD_CTX_clear_flags, EVP_MD_CTX_test_flags,
@@ -18,6 +19,8 @@ EVP_MD_CTX_pkey_ctx, EVP_MD_CTX_set_pkey_ctx - EVP digest routines
 
  #include &lt;openssl/evp.h&gt;
 
+ EVP_MD *EVP_MD_fetch(OPENSSL_CTX *ctx, const char *algorithm,
+                      const char *properties);
  EVP_MD_CTX *EVP_MD_CTX_new(void);
  int EVP_MD_CTX_reset(EVP_MD_CTX *ctx);
  void EVP_MD_CTX_free(EVP_MD_CTX *ctx);
@@ -75,6 +78,14 @@ and should be used instead of the cipher-specific functions.
 
 =over 4
 
+=item EVP_MD_fetch()
+
+Fetches the digest implementation for the given B&lt;algorithm&gt; from any
+provider offering it, within the criteria given by the B&lt;properties&gt;.
+See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+
+The returned value must eventually be freed with L&lt;EVP_MD_meth_free(3)&gt;.
+
 =item EVP_MD_CTX_new()
 
 Allocates and returns a digest context.
@@ -123,9 +134,12 @@ If B&lt;impl&gt; is NULL the default implementation of digest B&lt;type&gt; is used.
 
 =item EVP_DigestInit_ex()
 
-Sets up digest context B&lt;ctx&gt; to use a digest B&lt;type&gt; from ENGINE B&lt;impl&gt;.
-B&lt;type&gt; will typically be supplied by a function such as EVP_sha1().  If
-B&lt;impl&gt; is NULL then the default implementation of digest B&lt;type&gt; is used.
+Sets up digest context B&lt;ctx&gt; to use a digest B&lt;type&gt;.
+B&lt;type&gt; is typically supplied by a function such as EVP_sha1(), or a
+value explicitly fetched with EVP_MD_fetch().
+
+If B&lt;impl&gt; is non-NULL, its implementation of the digest B&lt;type&gt; is used if
+there is one, and if not, the default implementation is used.
 
 =item EVP_DigestUpdate()
 
@@ -343,6 +357,10 @@ disabled with this flag.
 
 =over 4
 
+=item EVP_MD_fetch()
+
+Returns a pointer to a B&lt;EVP_MD&gt; for success or NULL for failure.
+
 =item EVP_DigestInit_ex(),
 EVP_DigestUpdate(),
 EVP_DigestFinal_ex()
@@ -487,6 +505,7 @@ L&lt;EVP_sha224(3)&gt;,
 L&lt;EVP_sha3_224(3)&gt;,
 L&lt;EVP_sm3(3)&gt;,
 L&lt;EVP_whirlpool(3)&gt;
+L&lt;provider(7)/Fetching algorithms&gt;
 
 =head1 HISTORY
 
diff --git a/doc/man3/EVP_EncryptInit.pod b/doc/man3/EVP_EncryptInit.pod
index 3c2e36b..e4fb0c4 100644
--- a/doc/man3/EVP_EncryptInit.pod
+++ b/doc/man3/EVP_EncryptInit.pod
@@ -2,6 +2,7 @@
 
 =head1 NAME
 
+EVP_CIPHER_fetch,
 EVP_CIPHER_CTX_new,
 EVP_CIPHER_CTX_reset,
 EVP_CIPHER_CTX_free,
@@ -54,6 +55,8 @@ EVP_enc_null
 
  #include &lt;openssl/evp.h&gt;
 
+ EVP_CIPHER *EVP_CIPHER_fetch(OPENSSL_CTX *ctx, const char *algorithm,
+                              const char *properties);
  EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
  int EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *ctx);
  void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx);
@@ -123,6 +126,14 @@ EVP_enc_null
 The EVP cipher routines are a high level interface to certain
 symmetric ciphers.
 
+EVP_CIPHER_fetch() fetches the cipher implementation for the given
+B&lt;algorithm&gt; from any provider offering it, within the criteria given
+by the B&lt;properties&gt;.
+See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+
+The returned value must eventually be freed with
+L&lt;EVP_CIPHER_meth_free(3)&gt;.
+
 EVP_CIPHER_CTX_new() creates a cipher context.
 
 EVP_CIPHER_CTX_free() clears all information from a cipher context
@@ -132,10 +143,11 @@ cipher are complete so sensitive information does not remain in
 memory.
 
 EVP_EncryptInit_ex() sets up cipher context B&lt;ctx&gt; for encryption
-with cipher B&lt;type&gt; from ENGINE B&lt;impl&gt;. B&lt;ctx&gt; must be created
-before calling this function. B&lt;type&gt; is normally supplied
-by a function such as EVP_aes_256_cbc(). If B&lt;impl&gt; is NULL then the
-default implementation is used. B&lt;key&gt; is the symmetric key to use
+with cipher B&lt;type&gt;. B&lt;type&gt; is typically supplied by a function such
+as EVP_aes_256_cbc(), or a value explicitly fetched with
+EVP_CIPHER_fetch(). If B&lt;impl&gt; is non-NULL, its implementation of the
+cipher B&lt;type&gt; is used if there is one, and if not, the default
+implementation is used. B&lt;key&gt; is the symmetric key to use
 and B&lt;iv&gt; is the IV to use (if necessary), the actual number of bytes
 used for the key and IV depends on the cipher. It is possible to set
 all parameters to NULL except B&lt;type&gt; in an initial call and supply
@@ -280,6 +292,9 @@ buffer at least as big as the value returned by EVP_CIPHER_CTX_key_length().
 
 =head1 RETURN VALUES
 
+EVP_CIPHER_fetch() returns a pointer to a B&lt;EVP_CIPHER&gt; for success
+and B&lt;NULL&gt; for failure.
+
 EVP_CIPHER_CTX_new() returns a pointer to a newly created
 B&lt;EVP_CIPHER_CTX&gt; for success and B&lt;NULL&gt; for failure.
 
diff --git a/doc/man3/EVP_KEYEXCH_free.pod b/doc/man3/EVP_KEYEXCH_free.pod
index d10d768..912434d 100644
--- a/doc/man3/EVP_KEYEXCH_free.pod
+++ b/doc/man3/EVP_KEYEXCH_free.pod
@@ -2,21 +2,30 @@
 
 =head1 NAME
 
-EVP_KEYEXCH_free, EVP_KEYEXCH_up_ref
+EVP_KEYEXCH_fetch, EVP_KEYEXCH_free, EVP_KEYEXCH_up_ref
 - Functions to manage EVP_KEYEXCH algorithm objects
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/evp.h&gt;
 
+ EVP_KEYEXCH *EVP_KEYEXCH_fetch(OPENSSL_CTX *ctx, const char *algorithm,
+                                const char *properties);
  void EVP_KEYEXCH_free(EVP_KEYEXCH *exchange);
  int EVP_KEYEXCH_up_ref(EVP_KEYEXCH *exchange);
 
 =head1 DESCRIPTION
 
+EVP_KEYEXCH_fetch() fetches the key exchange implementation for the given
+B&lt;algorithm&gt; from any provider offering it, within the criteria given
+by the B&lt;properties&gt;.
+See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+
+The returned value must eventually be freed with EVP_KEYEXCH_free().
+
 EVP_KEYEXCH_free() decrements the reference count for the B&lt;EVP_KEYEXCH&gt;
 structure. Typically this structure will have been obtained from an earlier call
-to L&lt;EVP_KEYEXCH_fetch(3)&gt;. If the reference count drops to 0 then the
+to EVP_KEYEXCH_fetch(). If the reference count drops to 0 then the
 structure is freed.
 
 EVP_KEYEXCH_up_ref() increments the reference count for an B&lt;EVP_KEYEXCH&gt;
@@ -24,11 +33,14 @@ structure.
 
 =head1 RETURN VALUES
 
+EVP_KEYEXCH_fetch() returns a pointer to a B&lt;EVP_KEYEXCH&gt; for success
+or B&lt;NULL&gt; for failure.
+
 EVP_KEYEXCH_up_ref() returns 1 for success or 0 otherwise.
 
 =head1 SEE ALSO
 
-L&lt;EVP_KEYEXCH_fetch(3)&gt;
+L&lt;provider(7)/Fetching algorithms&gt;
 
 =head1 HISTORY
 
diff --git a/doc/man3/EVP_MD_fetch.pod b/doc/man3/EVP_MD_fetch.pod
deleted file mode 100644
index 98e4c84..0000000
--- a/doc/man3/EVP_MD_fetch.pod
+++ /dev/null
@@ -1,249 +0,0 @@
-=pod
-
-=head1 NAME
-
-EVP_MD_fetch, EVP_CIPHER_fetch, EVP_KEYEXCH_fetch
-- Functions to explicitly fetch algorithm implementations
-
-=head1 SYNOPSIS
-
- #include &lt;openssl/evp.h&gt;
-
- EVP_MD *EVP_MD_fetch(OPENSSL_CTX *ctx, const char *algorithm,
-                      const char *properties);
- EVP_CIPHER *EVP_CIPHER_fetch(OPENSSL_CTX *ctx, const char *algorithm,
-                              const char *properties);
- EVP_KEYEXCH *EVP_KEYEXCH_fetch(OPENSSL_CTX *ctx, const char *algorithm,
-                                const char *properties);
-
-=head1 DESCRIPTION
-
-Cryptographic algorithms are represented by different OpenSSL objects depending
-on what type of algorithm it is. The following cryptographic algorithm types are
-supported.
-
-=over 4
-
-=item B&lt;EVP_MD&gt;
-
-Represents a digest algorithm.
-
-=item B&lt;EVP_CIPHER&gt;
-
-Represents a symmetric cipher algorithm.
-
-=item B&lt;EVP_MAC&gt;
-
-Represents a Message Authentication Code algorithm.
-
-=item B&lt;EVP_KDF&gt;
-
-Represents a Key Derivation Function algorithm.
-
-=item B&lt;EVP_KEYEXCH&gt;
-
-Represents a Key Exchange algorithm.
-
-=back
-
-The algorithm objects may or may not have an associated algorithm
-implementation.
-Cryptographic algorithms are implemented by providers.
-Any algorithm may be supported by zero or more providers.
-In order to use an algorithm an implementation must first be obtained.
-This can happen in one of three ways, i.e. implicit fetch, explicit fetch or
-user defined.
-
-=over 4
-
-=item Implicit Fetch
-
-With implicit fetch an application can use functions such as L&lt;EVP_sha256(3)&gt;,
-L&lt;EVP_blake2b512(3)&gt; or L&lt;EVP_aes_128_cbc(3)&gt; to obtain an algorithm object with
-no associated implementation.
-When used in a function like L&lt;EVP_DigestInit_ex(3)&gt; or L&lt;EVP_CipherInit_ex(3)&gt;
-the actual implementation to be used will be fetched implicitly using default
-search criteria.
-Typically, this will return an implementation of the appropriate algorithm from
-the default provider unless the default search criteria have been changed and/or
-different providers have been loaded.
-
-Implicit fetching can also occur with functions such as
-L&lt;EVP_PKEY_derive_init_ex(3)&gt; where a NULL algorithm parameter is supplied.
-In this case an algorithm implementation is implicitly fetched using default
-search criteria and an algorithm name that is consistent with the type of
-EVP_PKEY being used.
-
-=item Explicit Fetch
-
-With explicit fetch an application uses one of the &quot;fetch&quot; functions to obtain
-an algorithm object with an associated implementation.
-An implementation with the given name that satisfies the search criteria
-specified in the B&lt;properties&gt; parameter combined with the default search
-criteria will be looked for within the available providers and returned.
-See L&lt;EVP_set_default_properties(3)&gt; for information on default search criteria
-and L&lt;OSSL_PROVIDER(3)&gt; for information about providers.
-
-=item User defined
-
-Using the user defined approach an application constructs its own algorithm
-object.
-See L&lt;EVP_MD_meth_new(3)&gt; and L&lt;EVP_CIPHER_meth_new(3)&gt; for details.
-
-=back
-
-Having obtained an algorithm implementation as an algorithm object it can then
-be used to perform cryptographic operations.
-For example to calculate the digest of input data with an B&lt;EVP_MD&gt; algorithm
-object you can use functions such as L&lt;EVP_DigestInit_ex(3)&gt;,
-L&lt;EVP_DigestUpdate(3)&gt; and L&lt;EVP_DigestFinal_ex(3)&gt;.
-
-The fetch functions will look for an algorithm within the providers that
-have been loaded into the B&lt;OPENSSL_CTX&gt; given in the B&lt;ctx&gt; parameter.
-This parameter may be NULL in which case the default B&lt;OPENSSL_CTX&gt; will be
-used.
-See L&lt;OPENSSL_CTX_new(3)&gt; and L&lt;OSSL_PROVIDER_load(3)&gt; for further details.
-
-The B&lt;algorithm&gt; parameter gives the name of the algorithm to be looked up.
-Different algorithms can be made available by loading different providers.
-
-The built-in default provider digest algorithm implementation names are: SHA1,
-SHA224, SHA256, SHA384, SHA512, SHA512-224, SHA512-256, SHA3-224, SHA3-256,
-SHA3-384, SHA3-512, SHAKE128, SHAKE256, SM3, BLAKE2b512, BLAKE2s256 and
-MD5-SHA1.
-
-The built-in default provider cipher algorithm implementation names are:
-AES-256-ECB, AES-192-ECB, AES-128-ECB, AES-256-CBC, AES-192-CBC, AES-128-CBC,
-AES-256-OFB, AES-192-OFB, AES-128-OFB, AES-256-CFB, AES-192-CFB, AES-128-CFB,
-AES-256-CFB1, AES-192-CFB1, AES-128-CFB1, AES-256-CFB8, AES-192-CFB8,
-AES-128-CFB8, AES-256-CTR, AES-192-CTR, AES-128-CTR, id-aes256-GCM,
-id-aes192-GCM and id-aes128-GCM.
-
-Additional algorithm implementations may be obtained by loading the &quot;legacy&quot;
-provider.
-
-The legacy provider digest algorithms are: RIPEMD160, MD2, MD4, MD5, MDC2 and
-whirlpool.
-
-The B&lt;properties&gt; parameter specifies the search criteria that will be used to
-look for an algorithm implementation. Properties are given as a comma delimited
-string of name value pairs. In order for an implementation to match, all the
-properties in the query string must match those defined for that implementation.
-Any properties defined by an implementation but not given in the query string
-are ignored. All algorithm implementations in the default provider have the
-property &quot;default=yes&quot;. All algorithm implementations in the legacy provider have
-the property &quot;legacy=yes&quot;. All algorithm implementations in the FIPS provider
-have the property &quot;fips=yes&quot;. In the event that more than one implementation
-of the given algorithm name matches the specified properties then an unspecified
-one of those implementations may be returned. The B&lt;properties&gt; parameter may be
-NULL in which case any implementation from the available providers with the
-given algorithm name will be returned.
-
-The return value from a call to EVP_MD_fetch() must be freed by the caller using
-L&lt;EVP_MD_meth_free(3)&gt;.
-Note that EVP_MD objects are reference counted. See L&lt;EVP_MD_up_ref(3)&gt;.
-
-The return value from a call to EVP_CIPHER_fetch() must be freed by the caller
-using L&lt;EVP_CIPHER_meth_free(3)&gt;.
-Note that EVP_CIPHER objects are reference counted.
-See L&lt;EVP_CIPHER_up_ref(3)&gt;.
-
-=head1 NOTES
-
-Where an application that previously used implicit fetch is converted to use
-explicit fetch care should be taken with the L&lt;EVP_MD_CTX_md(3)&gt; function.
-Specifically, this function returns the EVP_MD object originally passed to
-EVP_DigestInit_ex() (or other similar function). With implicit fetch the
-returned EVP_MD object is guaranteed to be available throughout the application
-lifetime. However, with explicit fetch EVP_MD objects are reference counted.
-EVP_MD_CTX_md does not increment the reference count and so the returned EVP_MD
-object may not be accessible beyond the lifetime of the EVP_MD_CTX it is
-associated with.
-
-=head1 RETURN VALUES
-
-EVP_MD_fetch() returns a pointer to the algorithm implementation represented by
-an EVP_MD object, or NULL on error.
-
-=head1 EXAMPLES
-
-Fetch any available implementation of SHA256 in the default context:
-
- EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA256&quot;, NULL);
- ...
- EVP_MD_meth_free(md);
-
-Fetch any available implementation of AES-128-CBC in the default context:
-
- EVP_CIPHER *cipher = EVP_CIPHER_fetch(NULL, &quot;AES-128-CBC&quot;, NULL);
- ...
- EVP_CIPHER_meth_free(cipher);
-
-Fetch an implementation of SHA256 from the default provider in the default
-context:
-
- EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA256&quot;, &quot;default=yes&quot;);
- ...
- EVP_MD_meth_free(md);
-
-Fetch an implementation of SHA256 that is not from the default provider in the
-default context:
-
- EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA256&quot;, &quot;default=no&quot;);
- ...
- EVP_MD_meth_free(md);
-
-Fetch an implementation of SHA256 from the default provider in the specified
-context:
-
- EVP_MD *md = EVP_MD_fetch(ctx, &quot;SHA256&quot;, &quot;default=yes&quot;);
- ...
- EVP_MD_meth_free(md);
-
-Load the legacy provider into the default context and then fetch an
-implementation of whirlpool from it:
-
- /* This only needs to be done once - usually at application start up */
- OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, &quot;legacy&quot;);
-
- EVP_MD *md = EVP_MD_fetch(NULL, &quot;whirlpool&quot;, &quot;legacy=yes&quot;);
- ...
- EVP_MD_meth_free(md);
-
-Note that in the above example the property string &quot;legacy=yes&quot; is optional
-since, assuming no other providers have been loaded, the only implementation of
-the &quot;whirlpool&quot; algorithm is in the &quot;legacy&quot; provider. Also note that the
-default provider should be explicitly loaded if it is required in addition to
-other providers:
-
- /* This only needs to be done once - usually at application start up */
- OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, &quot;legacy&quot;);
- OSSL_PROVIDER *default = OSSL_PROVIDER_load(NULL, &quot;default&quot;);
-
- EVP_MD *md_whirlpool = EVP_MD_fetch(NULL, &quot;whirlpool&quot;, NULL);
- EVP_MD *md_sha256 = EVP_MD_fetch(NULL, &quot;SHA256&quot;, NULL);
- ...
- EVP_MD_meth_free(md_whirlpool);
- EVP_MD_meth_free(md_sha256);
-
-=head1 SEE ALSO
-
-L&lt;EVP_DigestInit_ex(3)&gt;, L&lt;EVP_EncryptInit_ex(3)&gt;, L&lt;EVP_MD_meth_new(3)&gt;,
-L&lt;EVP_MD_meth_free(3)&gt;, L&lt;EVP_CIPHER_meth_new(3)&gt;, L&lt;EVP_CIPHER_meth_free(3)&gt;,
-L&lt;EVP_MD_up_ref(3)&gt;, L&lt;EVP_CIPHER_up_ref(3)&gt;, L&lt;OSSL_PROVIDER_load(3)&gt;,
-L&lt;OPENSSL_CTX(3)&gt;, L&lt;EVP_set_default_properties(3)&gt;
-
-=head1 HISTORY
-
-The functions described here were added in OpenSSL 3.0.
-
-=head1 COPYRIGHT
-
-Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
-
-Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
-this file except in compliance with the License.  You can obtain a copy
-in the file LICENSE in the source distribution or at
-L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
-
-=cut
diff --git a/doc/man7/provider-base.pod b/doc/man7/provider-base.pod
new file mode 100644
index 0000000..e8e5d28
--- /dev/null
+++ b/doc/man7/provider-base.pod
@@ -0,0 +1,464 @@
+=pod
+
+=head1 NAME
+
+provider-base
+- The basic OpenSSL library E&lt;lt&gt;-E&lt;gt&gt; provider functions
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/core_numbers.h&gt;
+
+ /*
+  * None of these are actual functions, but are displayed like this for
+  * the function signatures for functions that are offered as function
+  * pointers in OSSL_DISPATCH arrays.
+  */
+
+ /* Functions offered by libcrypto to the providers */
+ const OSSL_ITEM *core_get_param_types(const OSSL_PROVIDER *prov);
+ int core_get_params(const OSSL_PROVIDER *prov, OSSL_PARAM params[]);
+ int core_thread_start(const OSSL_PROVIDER *prov,
+                       OSSL_thread_stop_handler_fn handfn);
+ void core_put_error(const OSSL_PROVIDER *prov,
+                     uint32_t reason, const char *file, int line);
+ void core_add_error_vdata(const OSSL_PROVIDER *prov,
+                           int num, va_list args);
+ OPENSSL_CTX *core_get_library_context(const OSSL_PROVIDER *prov);
+
+ /*
+  * Some OpenSSL functionality is directly offered to providers via
+  * dispatch
+  */
+ void *CRYPTO_malloc(size_t num, const char *file, int line);
+ void *CRYPTO_zalloc(size_t num, const char *file, int line);
+ void *CRYPTO_memdup(const void *str, size_t siz,
+                     const char *file, int line);
+ char *CRYPTO_strdup(const char *str, const char *file, int line);
+ char *CRYPTO_strndup(const char *str, size_t s,
+                      const char *file, int line);
+ void CRYPTO_free(void *ptr, const char *file, int line);
+ void CRYPTO_clear_free(void *ptr, size_t num,
+                        const char *file, int line);
+ void *CRYPTO_realloc(void *addr, size_t num,
+                      const char *file, int line);
+ void *CRYPTO_clear_realloc(void *addr, size_t old_num, size_t num,
+                            const char *file, int line);
+ void *CRYPTO_secure_malloc(size_t num, const char *file, int line);
+ void *CRYPTO_secure_zalloc(size_t num, const char *file, int line);
+ void CRYPTO_secure_free(void *ptr, const char *file, int line);
+ void CRYPTO_secure_clear_free(void *ptr, size_t num,
+                               const char *file, int line);
+ int CRYPTO_secure_allocated(const void *ptr);
+ void OPENSSL_cleanse(void *ptr, size_t len);
+ unsigned char *OPENSSL_hexstr2buf(const char *str, long *len);
+
+ /* Functions offered by the provider to libcrypto */
+ void provider_teardown(void *provctx);
+ const OSSL_ITEM *provider_get_param_types(void *provctx);
+ int provider_get_params(void *provctx, OSSL_PARAM params[]);
+ const OSSL_ALGORITHM *provider_query_operation(void *provctx,
+                                                int operation_id,
+                                                const int *no_store);
+ const OSSL_ITEM *provider_get_reason_strings(void *provctx);
+
+=head1 DESCRIPTION
+
+All &quot;functions&quot; mentioned here are passed as function pointers between
+F&lt;libcrypto&gt; and the provider in B&lt;OSSL_DISPATCH&gt; arrays, in the call
+of the provider initialization function.  See L&lt;provider(7)/Provider&gt;
+for a description of the initialization function.
+
+All these &quot;functions&quot; have a corresponding function type definition
+named B&lt;OSSL_{name}_fn&gt;, and a helper function to retrieve the
+function pointer from a B&lt;OSSL_DISPATCH&gt; element named
+B&lt;OSSL_get_{name}&gt;.
+For example, the &quot;function&quot; core_get_param_types() has these:
+
+ typedef OSSL_ITEM *
+     (OSSL_core_get_param_types_fn)(const OSSL_PROVIDER *prov);
+ static ossl_inline OSSL_NAME_core_get_param_types_fn
+     OSSL_get_core_get_param_types(const OSSL_DISPATCH *opf);
+
+B&lt;OSSL_DISPATCH&gt; arrays are indexed by numbers that are provided as
+macros in L&lt;openssl-core_numbers.h(7)&gt;, as follows:
+
+For I&lt;in&gt; (the B&lt;OSSL_DISPATCH&gt; array passed from F&lt;libcrypto&gt; to the
+provider):
+
+ core_get_param_types           OSSL_FUNC_CORE_GET_PARAM_TYPES
+ core_get_params                OSSL_FUNC_CORE_GET_PARAMS
+ core_thread_start              OSSL_FUNC_CORE_THREAD_START
+ core_put_error                 OSSL_FUNC_CORE_PUT_ERROR
+ core_add_error_vdata           OSSL_FUNC_CORE_ADD_ERROR_VDATA
+ core_get_library_context       OSSL_FUNC_CORE_GET_LIBRARY_CONTEXT
+ CRYPTO_malloc                  OSSL_FUNC_CRYPTO_MALLOC
+ CRYPTO_zalloc                  OSSL_FUNC_CRYPTO_ZALLOC
+ CRYPTO_memdup                  OSSL_FUNC_CRYPTO_MEMDUP
+ CRYPTO_strdup                  OSSL_FUNC_CRYPTO_STRDUP
+ CRYPTO_strndup                 OSSL_FUNC_CRYPTO_STRNDUP
+ CRYPTO_free                    OSSL_FUNC_CRYPTO_FREE
+ CRYPTO_clear_free              OSSL_FUNC_CRYPTO_CLEAR_FREE
+ CRYPTO_realloc                 OSSL_FUNC_CRYPTO_REALLOC
+ CRYPTO_clear_realloc           OSSL_FUNC_CRYPTO_CLEAR_REALLOC
+ CRYPTO_secure_malloc           OSSL_FUNC_CRYPTO_SECURE_MALLOC
+ CRYPTO_secure_zalloc           OSSL_FUNC_CRYPTO_SECURE_ZALLOC
+ CRYPTO_secure_free             OSSL_FUNC_CRYPTO_SECURE_FREE
+ CRYPTO_secure_clear_free       OSSL_FUNC_CRYPTO_SECURE_CLEAR_FREE
+ CRYPTO_secure_allocated        OSSL_FUNC_CRYPTO_SECURE_ALLOCATED
+ OPENSSL_cleanse                OSSL_FUNC_OPENSSL_CLEANSE
+ OPENSSL_hexstr2buf             OSSL_FUNC_OPENSSL_HEXSTR2BUF
+
+For I&lt;*out&gt; (the B&lt;OSSL_DISPATCH&gt; array passed from the provider to
+F&lt;libcrypto&gt;):
+
+ provider_teardown              OSSL_FUNC_PROVIDER_TEARDOWN
+ provider_get_param_types       OSSL_FUNC_PROVIDER_GET_PARAM_TYPES
+ provider_get_params            OSSL_FUNC_PROVIDER_GET_PARAMS
+ provider_query_operation       OSSL_FUNC_PROVIDER_QUERY_OPERATION
+ provider_get_reason_strings    OSSL_FUNC_PROVIDER_GET_REASON_STRINGS
+
+=head2 Core functions
+
+core_get_param_types() returns a constant array of descriptor
+B&lt;OSSL_PARAM&gt;, for parameters that core_get_params() can handle.
+
+core_get_params() retrieves I&lt;prov&gt; parameters from the core.
+See L&lt;/Core parameters&gt; below for a description of currently known
+parameters.
+
+=for comment core_thread_start() TBA
+
+core_put_error() is used to report an error back to the core, with
+reference to the provider object I&lt;prov&gt;.
+The I&lt;reason&gt; is a number defined by the provider and used to index
+the reason strings table that's returned by
+provider_get_reason_strings().
+I&lt;file&gt; and I&lt;line&gt; may also be passed to indicate exactly where the
+error occured or was reported.
+This corresponds to the OpenSSL function L&lt;ERR_put_error(3)&gt;.
+
+core_add_error_vdata() is used to add additional text data to an
+error already reported with core_put_error().
+It takes I&lt;num&gt; strings in a B&lt;va_list&gt; and concatenates them.
+Provider authors will have to write the corresponding variadic
+argument function.
+
+core_get_library_context() retrieves the library context in which the
+B&lt;OSSL_PROVIDER&gt; object I&lt;prov&gt; is stored.
+This may sometimes be useful if the provider wishes to store a
+reference to its context in the same library context.
+
+CRYPTO_malloc(), CRYPTO_zalloc(), CRYPTO_memdup(), CRYPTO_strdup(),
+CRYPTO_strndup(), CRYPTO_free(), CRYPTO_clear_free(),
+CRYPTO_realloc(), CRYPTO_clear_realloc(), CRYPTO_secure_malloc(),
+CRYPTO_secure_zalloc(), CRYPTO_secure_free(),
+CRYPTO_secure_clear_free(), CRYPTO_secure_allocated(),
+OPENSSL_cleanse(), and OPENSSL_hexstr2buf() correspond exactly to the
+public functions with the same name.
+As a matter of fact, the pointers in the B&lt;OSSL_DISPATCH&gt; array are
+direct pointers to those public functions.
+
+=head2 Provider functions
+
+provider_teardown() is called when a provider is shut down and removed
+from the core's provider store.
+It must free the passed I&lt;provctx&gt;.
+
+provider_get_param_types() should return a constant array of
+descriptor B&lt;OSSL_PARAM&gt;, for parameters that provider_get_params()
+can handle.
+
+provider_get_params() should process the B&lt;OSSL_PARAM&gt; array
+I&lt;params&gt;, setting the values of the parameters it understands.
+
+provider_query_operation() should return a constant B&lt;OSSL_ALGORITHM&gt;
+that corresponds to the given I&lt;operation_id&gt;.
+It should indicate if the core may store a reference to this array by
+setting I&lt;*no_store&gt; to 0 (core may store a reference) or 1 (core may
+not store a reference).
+
+provider_get_reason_strings() should return a constant B&lt;OSSL_ITEM&gt;
+array that provides reason strings for reason codes the provider may
+use when reporting errors using core_put_error().
+
+None of these functions are mandatory, but a provider is fairly
+useless without at least provider_query_operation(), and
+provider_get_param_types() is fairly useless if not accompanied by
+provider_get_params().
+
+=head2 Core parameters
+
+core_get_params() understands the following known parameters:
+
+=over 4
+
+=item &quot;openssl-version&quot;
+
+This is a B&lt;OSSL_PARAM_UTF8_PTR&gt; type of parameter, pointing at the
+OpenSSL libraries' full version string, i.e. the string expanded from
+the macro B&lt;OPENSSL_VERSION_STR&gt;.
+
+=item &quot;provider-name&quot;
+
+This is a B&lt;OSSL_PARAM_UTF8_PTR&gt; type of parameter, pointing at the
+OpenSSL libraries' idea of what the calling provider is called.
+
+=back
+
+Additionally, provider specific configuration parameters from the
+config file are available, in dotted name form.
+The dotted name form is a concatenation of section names and final
+config command name separated by periods.
+
+For example, let's say we have the following config example:
+
+ openssl_conf = openssl_init
+
+ [openssl_init]
+ providers = providers_sect
+
+ [providers_sect]
+ foo = foo_sect
+
+ [foo_sect]
+ activate = 1
+ data1 = 2
+ data2 = str
+ more = foo_more
+
+ [foo_more]
+ data3 = foo,bar
+
+The provider will have these additional parameters available:
+
+=over 4
+
+=item &quot;activate&quot;
+
+pointing at the string &quot;1&quot;
+
+=item &quot;data1&quot;
+
+pointing at the string &quot;2&quot;
+
+=item &quot;data2&quot;
+
+pointing at the string &quot;str&quot;
+
+=item &quot;more.data3&quot;
+
+pointing at the string &quot;foo,bar&quot;
+
+=back
+
+For more information on handling parameters, see L&lt;OSSL_PARAM(3)&gt; as
+L&lt;OSSL_PARAM_int(3)&gt;.
+
+=head1 EXAMPLES
+
+This is an example of a simple provider made available as a
+dynamically loadable module.
+It implements the fictitious algorithm C&lt;FOO&gt; for the fictitious
+operation C&lt;BAR&gt;.
+
+ #include &lt;malloc.h&gt;
+ #include &lt;openssl/core.h&gt;
+ #include &lt;openssl/core_numbers.h&gt;
+
+ /* Errors used in this provider */
+ #define E_MALLOC       1
+
+ static const OSSL_ITEM reasons[] = {
+     { E_MALLOC, &quot;memory allocation failure&quot; }.
+     { 0, NULL } /* Termination */
+ };
+
+ /*
+  * To ensure we get the function signature right, forward declare
+  * them using function types provided by openssl/core_numbers.h
+  */
+ OSSL_OP_bar_newctx_fn foo_newctx;
+ OSSL_OP_bar_freectx_fn foo_freectx;
+ OSSL_OP_bar_init_fn foo_init;
+ OSSL_OP_bar_update_fn foo_update;
+ OSSL_OP_bar_final_fn foo_final;
+
+ OSSL_provider_query_operation_fn p_query;
+ OSSL_provider_get_reason_strings_fn p_reasons;
+ OSSL_provider_teardown_fn p_teardown;
+
+ OSSL_provider_init_fn OSSL_provider_init;
+
+ OSSL_core_put_error *c_put_error = NULL;
+
+ /* Provider context */
+ struct prov_ctx_st {
+     OSSL_PROVIDER *prov;
+ }
+
+ /* operation context for the algorithm FOO */
+ struct foo_ctx_st {
+     struct prov_ctx_st *provctx;
+     int b;
+ };
+
+ static void *foo_newctx(void *provctx)
+ {
+     struct foo_ctx_st *fooctx = malloc(sizeof(*fooctx));
+
+     if (fooctx != NULL)
+         fooctx-&gt;provctx = provctx;
+     else
+         c_put_error(provctx-&gt;prov, E_MALLOC, __FILE__, __LINE__);
+     return fooctx;
+ }
+
+ static void foo_freectx(void *fooctx)
+ {
+     free(fooctx);
+ }
+
+ static int foo_init(void *vfooctx)
+ {
+     struct foo_ctx_st *fooctx = vfooctx;
+
+     fooctx-&gt;b = 0x33;
+ }
+
+ static int foo_update(void *vfooctx, unsigned char *in, size_t inl)
+ {
+     struct foo_ctx_st *fooctx = vfooctx;
+
+     /* did you expect something serious? */
+     if (inl == 0)
+         return 1;
+     for (; inl-- &gt; 0; in++)
+         *in ^= fooctx-&gt;b;
+     return 1;
+ }
+
+ static int foo_final(void *vfooctx)
+ {
+     struct foo_ctx_st *fooctx = vfooctx;
+
+     fooctx-&gt;b = 0x66;
+ }
+
+ static const OSSL_DISPATCH foo_fns[] = {
+     { OSSL_FUNC_BAR_NEWCTX, (void (*)(void))foo_newctx },
+     { OSSL_FUNC_BAR_FREECTX, (void (*)(void))foo_freectx },
+     { OSSL_FUNC_BAR_INIT, (void (*)(void))foo_init },
+     { OSSL_FUNC_BAR_UPDATE, (void (*)(void))foo_update },
+     { OSSL_FUNC_BAR_FINAL, (void (*)(void))foo_final },
+     { 0, NULL }
+ };
+
+ static const OSSL_ALGORITHM bars[] = {
+     { &quot;FOO&quot;, &quot;provider=chumbawamba&quot;, foo_fns },
+     { NULL, NULL, NULL }
+ };
+
+ static const OSSL_ALGORITHM *p_query(void *provctx, int operation_id,
+                                      int *no_store)
+ {
+     switch (operation_id) {
+     case OSSL_OP_BAR:
+         return bars;
+     }
+     return NULL;
+ }
+
+ static const OSSL_ITEM *p_reasons(void *provctx)
+ {
+     return reasons;
+ }
+
+ static void p_teardown(void *provctx)
+ {
+     free(provctx);
+ }
+
+ static const OSSL_DISPATCH prov_fns[] = {
+     { OSSL_FUNC_PROVIDER_TEARDOWN, (void (*)(void))p_teardown },
+     { OSSL_FUNC_PROVIDER_QUERY_OPERATION, (void (*)(void))p_query },
+     { OSSL_FUNC_PROVIDER_GET_REASON_STRINGS, (void (*)(void))p_reasons },
+     { 0, NULL }
+ };
+
+ int OSSL_provider_init(const OSSL_PROVIDER *provider,
+                        const OSSL_DISPATCH *in,
+                        const OSSL_DISPATCH **out,
+                        void **provctx)
+ {
+     struct prov_ctx_st *pctx = NULL;
+
+     for (; in-&gt;function_id != 0; in++)
+         switch (in-&gt;function_id) {
+         case OSSL_FUNC_CORE_PUT_ERROR:
+             c_put_error = OSSL_get_core_put_error(in);
+             break;
+         }
+
+     *out = prov_fns;
+
+     if ((pctx = malloc(sizeof(*pctx))) == NULL) {
+         /*
+          * ALEA IACTA EST, if the core retrieves the reason table
+          * regardless, that string will be displayed, otherwise not.
+          */
+         c_put_error(provider, E_MALLOC, __FILE__, __LINE__);
+         return 0;
+     }
+     return 1;
+ }
+
+This relies on a few things existing in F&lt;openssl/core_numbers.h&gt;:
+
+ #define OSSL_OP_BAR            4711
+
+ #define OSSL_FUNC_BAR_NEWCTX      1
+ typedef void *(OSSL_OP_bar_newctx_fn)(void *provctx);
+ static ossl_inline OSSL_get_bar_newctx(const OSSL_DISPATCH *opf)
+ { return (OSSL_OP_bar_newctx_fn *)opf-&gt;function; }
+
+ #define OSSL_FUNC_BAR_FREECTX     2
+ typedef void (OSSL_OP_bar_freectx_fn)(void *ctx);
+ static ossl_inline OSSL_get_bar_newctx(const OSSL_DISPATCH *opf)
+ { return (OSSL_OP_bar_freectx_fn *)opf-&gt;function; }
+
+ #define OSSL_FUNC_BAR_INIT        3
+ typedef void *(OSSL_OP_bar_init_fn)(void *ctx);
+ static ossl_inline OSSL_get_bar_init(const OSSL_DISPATCH *opf)
+ { return (OSSL_OP_bar_init_fn *)opf-&gt;function; }
+
+ #define OSSL_FUNC_BAR_UPDATE      4
+ typedef void *(OSSL_OP_bar_update_fn)(void *ctx,
+                                       unsigned char *in, size_t inl);
+ static ossl_inline OSSL_get_bar_update(const OSSL_DISPATCH *opf)
+ { return (OSSL_OP_bar_update_fn *)opf-&gt;function; }
+
+ #define OSSL_FUNC_BAR_FINAL       5
+ typedef void *(OSSL_OP_bar_final_fn)(void *ctx);
+ static ossl_inline OSSL_get_bar_final(const OSSL_DISPATCH *opf)
+ { return (OSSL_OP_bar_final_fn *)opf-&gt;function; }
+
+=head1 SEE ALSO
+
+L&lt;provider(7)&gt;
+
+=head1 HISTORY
+
+The concept of providers and everything surrounding them was
+introduced in OpenSSL 3.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man7/provider.pod b/doc/man7/provider.pod
new file mode 100644
index 0000000..d9010dc
--- /dev/null
+++ b/doc/man7/provider.pod
@@ -0,0 +1,401 @@
+=pod
+
+=head1 NAME
+
+provider - OpenSSL operation implementation providers
+
+=head1 SYNOPSIS
+
+=for comment generic
+
+#include &lt;openssl/provider.h&gt;
+
+=head1 DESCRIPTION
+
+=head2 General
+
+A I&lt;provider&gt;, in OpenSSL terms, is a unit of code that provides one
+or more implementations for various operations for diverse algorithms
+that one might want to perform.
+
+An I&lt;operation&gt; is something one wants to do, such as encryption and
+decryption, key derivation, MAC calculation, signing and verification,
+etc.
+
+An I&lt;algorithm&gt; is a named method to perform an operation.
+Very often, the algorithms revolve around cryptographic operations,
+but may also revolve around other types of operation, such as managing
+certain types of objects.
+
+=head2 Provider
+
+I&lt;NOTE: This section is mostly interesting for provider authors.&gt;
+
+A I&lt;provider&gt; offers an initialization function, as a set of base
+functions in the form of an B&lt;OSSL_DISPATCH&gt; array, and by extension,
+a set of B&lt;OSSL_ALGORITHM&gt;s (see L&lt;openssl-core.h(7)&gt;).
+It may be a dynamically loadable module, or may be built-in, in
+OpenSSL libraries or in the application.
+If it's a dynamically loadable module, the initialization function
+must be named C&lt;OSSL_provider_init&gt; and must be exported.
+If it's built-in, the initialization function may have any name.
+
+The initialization function must have the following signature:
+
+ int NAME(const OSSL_PROVIDER *provider,
+          const OSSL_DISPATCH *in, const OSSL_DISPATCH **out,
+          void **provctx);
+
+I&lt;provider&gt; is the OpenSSL library object for the provider, and works
+as a handle for everything the OpenSSL libraries need to know about
+the provider.
+For the provider itself, it may hold some interesting information,
+and is also passed to some of the functions given in the dispatch
+array I&lt;in&gt;.
+
+I&lt;in&gt; is a dispatch array of base functions offered by the OpenSSL
+libraries, and the available functions are further described in
+L&lt;provider-base(7)&gt;.
+
+I&lt;*out&gt; must be assigned a dispatch array of base functions that the
+provider offers to the OpenSSL libraries.
+The functions that may be offered are further described in
+L&lt;provider-base(7)&gt;, and they are the central means of communication
+between the OpenSSL libraries and the provider.
+
+I&lt;*provctx&gt; should be assigned a provider specific context to allow
+the provider multiple simultaneous uses.
+This pointer will be passed to various operation functions offered by
+the provider.
+
+One of the functions the provider offers to the OpenSSL libraries is
+the central mechanism for the OpenSSL libraries to get access to
+operation implementations for diverse algorithms.
+Its referred to with the number B&lt;OSSL_FUNC_PROVIDER_QUERY_OPERATION&gt;
+and has the following signature:
+
+ const OSSL_ALGORITHM *provider_query_operation(void *provctx,
+                                                int operation_id,
+                                                const int *no_store);
+
+I&lt;provctx&gt; is the provider specific context that was passed back by
+the initialization function.
+
+I&lt;operation_id&gt; is an operation identity (see L&lt;/Operations&gt; below).
+
+I&lt;no_store&gt; is a flag back to the OpenSSL libraries which, when
+non-zero, signifies that the OpenSSL libraries will not store a
+reference to the returned data in their internal store of
+implementations.
+
+The returned B&lt;OSSL_ALGORITHM&gt; is the foundation of any OpenSSL
+library API that uses providers for their implementation, most
+commonly in the I&lt;fetching&gt; type of functions
+(see L&lt;/Fetching algorithms&gt; below).
+
+=head2 Operations
+
+I&lt;NOTE: This section is mostly interesting for provider authors.&gt;
+
+Operations are referred to with numbers, via macros with names
+starting with C&lt;OSSL_OP_&gt;.
+
+With each operation comes a set of defined function types that a
+provider may or may not offer, depending on its needs.
+
+Currently available operations are:
+
+=over 4
+
+=item Digests
+
+In the OpenSSL libraries, the corresponding method object is
+B&lt;EVP_MD&gt;.
+The number for this operation is B&lt;OSSL_OP_DIGEST&gt;.
+The functions the provider can offer are described in
+L&lt;provider-digest(7)&gt;
+
+=item Symmetric ciphers
+
+In the OpenSSL libraries, the corresponding method object is
+B&lt;EVP_CIPHER&gt;.
+The number for this operation is B&lt;OSSL_OP_CIPHER&gt;.
+The functions the provider can offer are described in
+L&lt;provider-cipher(7)&gt;
+
+=begin comment NOT AVAILABLE YET
+
+=item Message Authentication Code (MAC)
+
+In the OpenSSL libraries, the corresponding method object is
+B&lt;EVP_MAC&gt;.
+The number for this operation is B&lt;OSSL_OP_MAC&gt;.
+The functions the provider can offer are described in
+L&lt;provider-mac(7)&gt;
+
+=end comment
+
+=begin comment NOT AVAILABLE YET
+
+=item Key Derivation Function (KDF)
+
+In the OpenSSL libraries, the corresponding method object is
+B&lt;EVP_KDF&gt;.
+The number for this operation is B&lt;OSSL_OP_KDF&gt;.
+The functions the provider can offer are described in
+L&lt;provider-kdf(7)&gt;
+
+=end comment
+
+=item Key Exchange
+
+In the OpenSSL libraries, the corresponding method object is
+B&lt;EVP_KEYEXCh&gt;.
+The number for this operation is B&lt;OSSL_OP_KEYEXCH&gt;.
+The functions the provider can offer are described in
+L&lt;provider-keyexch(7)&gt;
+
+=back
+
+=head2 Fetching algorithms
+
+=head3 Explicit fetch
+
+I&lt;NOTE: This section is mostly interesting to OpenSSL users.&gt;
+
+Users of the OpenSSL libraries never query the provider directly for
+its diverse implementations and dispatch tables.
+Instead, the diverse OpenSSL APIs often have fetching functions that
+do the work, and they return an appropriate method object back to the
+user.
+These functions usually have the name C&lt;APINAME_fetch&gt;, where
+C&lt;APINAME&gt; is the name of the API, for example L&lt;EVP_MD_fetch(3)&gt;.
+
+These fetching functions follow a fairly common pattern, where three
+arguments are passed:
+
+=over 4
+
+=item The library context
+
+See L&lt;OPENSSL_CTX(3)&gt; for a more detailed description.
+This may be NULL to signify the default (global) library context, or a
+context created by the user.
+Only providers loaded in this library context (see
+L&lt;OSSL_PROVIDER_load(3)&gt;) will be considered by the fetching
+function.
+
+=item An identifier
+
+This is most commonly an algorithm name (this is the case for all EVP
+methods), but may also be called something else.
+
+=for comment For example, an OSSL_STORE implementation would use the
+URI scheme as an identifier.
+
+=item A property query string
+
+See L&lt;property(7)&gt; for a more detailed description.
+This is used to select more exactly which providers will get to offer
+an implementation.
+
+=back
+
+The method object that is fetched can then be used with diverse other
+functions that use them, for example L&lt;EVP_DigestInit_ex(3)&gt;.
+
+=head2 Implicit fetch
+
+I&lt;NOTE: This section is mostly interesting to OpenSSL users.&gt;
+
+OpenSSL has a number of functions that return a method object with no
+associated implementation, such as L&lt;EVP_sha256(3)&gt;,
+L&lt;EVP_blake2b512(3)&gt; or L&lt;EVP_aes_128_cbc(3)&gt;, which are present for
+compatibility with OpenSSL before version 3.0.
+
+When they are used with functions like L&lt;EVP_DigestInit_ex(3)&gt; or
+L&lt;EVP_CipherInit_ex(3)&gt;, the actual implementation to be used is
+fetched implicitly using default search criteria.
+
+Implicit fetching can also occur with functions such as
+L&lt;EVP_PKEY_CTX_derive_init_ex(3)&gt; where a NULL algorithm parameter is
+supplied.
+In this case an algorithm implementation is implicitly fetched using
+default search criteria and an algorithm name that is consistent with
+the type of EVP_PKEY being used.
+
+=head1 OPENSSL PROVIDERS
+
+OpenSSL comes with a set of providers.
+All the algorithm names mentioned can be used as an algorithm
+identifier to the appropriate fetching function.
+
+=head2 Default provider
+
+The default provider is built in as part of the F&lt;libcrypto&gt; library.
+Should it be needed (if other providers are loaded and offer
+implementations of the same algorithms), the property &quot;default=yes&quot;
+can be used as a search criterion for these implementations.
+
+It currently offers the following named algorithms:
+
+=over 4
+
+=item Digests
+
+SHA1, SHA224, SHA256, SHA384, SHA512, SHA512-224, SHA512-256,
+SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256, SM3,
+BLAKE2b512, BLAKE2s256, KMAC128, KMAC256, MD5, MD5-SHA1
+
+=item Symmetric ciphers
+
+AES-256-ECB, AES-192-ECB, AES-128-ECB, AES-256-CBC, AES-192-CBC,
+AES-128-CBC, AES-256-OFB, AES-192-OFB, AES-128-OFB, AES-256-CFB,
+AES-192-CFB, AES-128-CFB, AES-256-CFB1, AES-192-CFB1, AES-128-CFB1,
+AES-256-CFB8, AES-192-CFB8, AES-128-CFB8, AES-256-CTR, AES-192-CTR,
+AES-128-CTR, id-aes256-GCM, id-aes192-GCM, id-aes128-GCM
+
+=item Key Exchange
+
+dhKeyAgreement
+
+=back
+
+=head2 FIPS provider
+
+The FIPS provider is a dynamically loadable module, and must therefore
+be loaded explicitly, either in code or through OpenSSL configuration
+(see L&lt;config(5)&gt;).
+Should it be needed (if other providers are loaded and offer
+implementations of the same algorithms), the property &quot;fips=yes&quot; can
+be used as a search criterion for these implementations.
+
+It currently offers the following FIPS approved named algorithms:
+
+=over 4
+
+=item Digests
+
+SHA1, SHA224, SHA256, SHA384, SHA512, SHA512-224, SHA512-256,
+SHA3-224, SHA3-256, SHA3-384, SHA3-512, KMAC128, KMAC256
+
+=item Symmetric ciphers
+
+AES-256-ECB, AES-192-ECB, AES-128-ECB, AES-256-CBC, AES-192-CBC,
+AES-128-CBC, AES-256-CTR, AES-192-CTR, AES-128-CTR
+
+=back
+
+=head2 Legacy provider
+
+The legacy provider is a dynamically loadable module, and must therefore
+be loaded explicitly, either in code or through OpenSSL configuration
+(see L&lt;config(5)&gt;).
+Should it be needed (if other providers are loaded and offer
+implementations of the same algorithms), the property &quot;legacy=yes&quot; can be
+used as a search criterion for these implementations.
+
+It currently offers the following named algorithms:
+
+=over 4
+
+=item Digest algorithms:
+
+RIPEMD160, MD2, MD4, MDC2, whirlpool.
+
+=back
+
+=head1 EXAMPLES
+
+=head2 Fetching
+
+Fetch any available implementation of SHA256 in the default context:
+
+ EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA256&quot;, NULL);
+ ...
+ EVP_MD_meth_free(md);
+
+Fetch any available implementation of AES-128-CBC in the default context:
+
+ EVP_CIPHER *cipher = EVP_CIPHER_fetch(NULL, &quot;AES-128-CBC&quot;, NULL);
+ ...
+ EVP_CIPHER_meth_free(cipher);
+
+Fetch an implementation of SHA256 from the default provider in the default
+context:
+
+ EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA256&quot;, &quot;default=yes&quot;);
+ ...
+ EVP_MD_meth_free(md);
+
+Fetch an implementation of SHA256 that is not from the default provider in the
+default context:
+
+ EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA256&quot;, &quot;default=no&quot;);
+ ...
+ EVP_MD_meth_free(md);
+
+Fetch an implementation of SHA256 from the default provider in the specified
+context:
+
+ EVP_MD *md = EVP_MD_fetch(ctx, &quot;SHA256&quot;, &quot;default=yes&quot;);
+ ...
+ EVP_MD_meth_free(md);
+
+Load the legacy provider into the default context and then fetch an
+implementation of whirlpool from it:
+
+ /* This only needs to be done once - usually at application start up */
+ OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, &quot;legacy&quot;);
+
+ EVP_MD *md = EVP_MD_fetch(NULL, &quot;whirlpool&quot;, &quot;legacy=yes&quot;);
+ ...
+ EVP_MD_meth_free(md);
+
+Note that in the above example the property string &quot;legacy=yes&quot; is optional
+since, assuming no other providers have been loaded, the only implementation of
+the &quot;whirlpool&quot; algorithm is in the &quot;legacy&quot; provider. Also note that the
+default provider should be explicitly loaded if it is required in addition to
+other providers:
+
+ /* This only needs to be done once - usually at application start up */
+ OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, &quot;legacy&quot;);
+ OSSL_PROVIDER *default = OSSL_PROVIDER_load(NULL, &quot;default&quot;);
+
+ EVP_MD *md_whirlpool = EVP_MD_fetch(NULL, &quot;whirlpool&quot;, NULL);
+ EVP_MD *md_sha256 = EVP_MD_fetch(NULL, &quot;SHA256&quot;, NULL);
+ ...
+ EVP_MD_meth_free(md_whirlpool);
+ EVP_MD_meth_free(md_sha256);
+
+
+=head1 SEE ALSO
+
+L&lt;EVP_DigestInit_ex(3)&gt;, L&lt;EVP_EncryptInit_ex(3)&gt;,
+L&lt;EVP_PKEY_derive_init_ex(3)&gt;, 
+L&lt;OPENSSL_CTX(3)&gt;,
+L&lt;EVP_set_default_properties(3)&gt;,
+L&lt;EVP_MD_fetch(3)&gt;,
+L&lt;EVP_CIPHER_fetch(3)&gt;,
+L&lt;EVP_KEYMGMT_fetch(3)&gt;,
+L&lt;openssl-core.h(7)&gt;,
+L&lt;provider-base(7)&gt;,
+L&lt;provider-digest(7)&gt;,
+L&lt;provider-cipher(7)&gt;,
+L&lt;provider-keyexch(7)&gt;
+
+=head1 HISTORY
+
+The concept of providers and everything surrounding them was
+introduced in OpenSSL 3.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024078.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="024082.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24079">[ date ]</a>
              <a href="thread.html#24079">[ thread ]</a>
              <a href="subject.html#24079">[ subject ]</a>
              <a href="author.html#24079">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
