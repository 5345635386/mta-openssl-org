<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-July/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1563235504.476033.29147.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023956.html">
   <LINK REL="Next"  HREF="023963.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>shane.lontis at oracle.com</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1563235504.476033.29147.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">shane.lontis at oracle.com
       </A><BR>
    <I>Tue Jul 16 00:05:04 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="023956.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="023963.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23960">[ date ]</a>
              <a href="thread.html#23960">[ thread ]</a>
              <a href="subject.html#23960">[ subject ]</a>
              <a href="author.html#23960">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  459b15d451194ee90834ea58bfb8c91479e9ef9b (commit)
      from  0d03acea7aa45e94903fb12186ed6cc324eb1b03 (commit)


- Log -----------------------------------------------------------------
commit 459b15d451194ee90834ea58bfb8c91479e9ef9b
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Tue Jul 16 09:46:14 2019 +1000

    Add Common shared code needed to move aes ciphers to providers
    
    Custom aes ciphers will be placed into multiple new files
    (instead of the monolithic setup used in the e_aes.c legacy code)
    so it makes sense to have a header for the platform specific
    code that needs to be shared between files.
    modes_lcl.h has also moved to modes_int.h to allow sharing with the
    provider source.
    Code that will be common to AEAD ciphers has also been added. These
    will be used by seperate PR's for GCM, CCM &amp; OCB.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9301">https://github.com/openssl/openssl/pull/9301</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/evp/e_aes.c                                 | 388 +-------------------
 crypto/evp/e_aes_cbc_hmac_sha1.c                   |   6 +-
 crypto/evp/e_aes_cbc_hmac_sha256.c                 |   7 +-
 crypto/evp/e_aria.c                                |   2 +-
 crypto/evp/e_camellia.c                            |   2 +-
 crypto/evp/evp_enc.c                               |  82 ++++-
 crypto/evp/evp_lib.c                               | 108 +++---
 crypto/evp/evp_locl.h                              |  26 +-
 crypto/evp/evp_utils.c                             |  37 +-
 crypto/include/internal/aes_platform.h             | 391 +++++++++++++++++++++
 crypto/include/internal/modes_int.h                | 229 ++++++++++--
 crypto/include/internal/{modes_int.h =&gt; siv_int.h} |   0
 crypto/modes/cbc128.c                              |   4 +-
 crypto/modes/ccm128.c                              |   4 +-
 crypto/modes/cfb128.c                              |   4 +-
 crypto/modes/ctr128.c                              |   4 +-
 crypto/modes/cts128.c                              |   4 +-
 crypto/modes/gcm128.c                              |   4 +-
 crypto/modes/modes_lcl.h                           | 220 ------------
 crypto/modes/ocb128.c                              |   2 +-
 crypto/modes/ofb128.c                              |   4 +-
 crypto/modes/siv128.c                              |   3 +-
 crypto/modes/xts128.c                              |   4 +-
 include/openssl/core_names.h                       |  24 +-
 include/openssl/core_numbers.h                     |   1 +
 providers/common/ciphers/aes_basic.c               | 251 +------------
 test/build.info                                    |   2 +-
 test/modes_internal_test.c                         |   2 +-
 28 files changed, 788 insertions(+), 1027 deletions(-)
 create mode 100644 crypto/include/internal/aes_platform.h
 copy crypto/include/internal/{modes_int.h =&gt; siv_int.h} (100%)
 delete mode 100644 crypto/modes/modes_lcl.h

diff --git a/crypto/evp/e_aes.c b/crypto/evp/e_aes.c
index 6f58e27..f93ba61 100644
--- a/crypto/evp/e_aes.c
+++ b/crypto/evp/e_aes.c
@@ -19,7 +19,8 @@
 #include &quot;internal/evp_int.h&quot;
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;internal/modes_int.h&quot;
-#include &quot;modes_lcl.h&quot;
+#include &quot;internal/siv_int.h&quot;
+#include &quot;internal/aes_platform.h&quot;
 #include &quot;evp_locl.h&quot;
 
 typedef struct {
@@ -111,50 +112,6 @@ typedef struct {
 
 #define MAXBITCHUNK     ((size_t)1&lt;&lt;(sizeof(size_t)*8-4))
 
-#ifdef VPAES_ASM
-int vpaes_set_encrypt_key(const unsigned char *userKey, int bits,
-                          AES_KEY *key);
-int vpaes_set_decrypt_key(const unsigned char *userKey, int bits,
-                          AES_KEY *key);
-
-void vpaes_encrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-void vpaes_decrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-
-void vpaes_cbc_encrypt(const unsigned char *in,
-                       unsigned char *out,
-                       size_t length,
-                       const AES_KEY *key, unsigned char *ivec, int enc);
-#endif
-#ifdef BSAES_ASM
-void bsaes_cbc_encrypt(const unsigned char *in, unsigned char *out,
-                       size_t length, const AES_KEY *key,
-                       unsigned char ivec[16], int enc);
-void bsaes_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
-                                size_t len, const AES_KEY *key,
-                                const unsigned char ivec[16]);
-void bsaes_xts_encrypt(const unsigned char *inp, unsigned char *out,
-                       size_t len, const AES_KEY *key1,
-                       const AES_KEY *key2, const unsigned char iv[16]);
-void bsaes_xts_decrypt(const unsigned char *inp, unsigned char *out,
-                       size_t len, const AES_KEY *key1,
-                       const AES_KEY *key2, const unsigned char iv[16]);
-#endif
-#ifdef AES_CTR_ASM
-void AES_ctr32_encrypt(const unsigned char *in, unsigned char *out,
-                       size_t blocks, const AES_KEY *key,
-                       const unsigned char ivec[AES_BLOCK_SIZE]);
-#endif
-#ifdef AES_XTS_ASM
-void AES_xts_encrypt(const unsigned char *inp, unsigned char *out, size_t len,
-                     const AES_KEY *key1, const AES_KEY *key2,
-                     const unsigned char iv[16]);
-void AES_xts_decrypt(const unsigned char *inp, unsigned char *out, size_t len,
-                     const AES_KEY *key1, const AES_KEY *key2,
-                     const unsigned char iv[16]);
-#endif
-
 /* increment counter (64-bit int) by 1 */
 static void ctr64_inc(unsigned char *counter)
 {
@@ -171,105 +128,10 @@ static void ctr64_inc(unsigned char *counter)
     } while (n);
 }
 
-#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; (defined(__powerpc__) || defined(__ppc__) || defined(_ARCH_PPC))
-# include &quot;ppc_arch.h&quot;
-# ifdef VPAES_ASM
-#  define VPAES_CAPABLE (OPENSSL_ppccap_P &amp; PPC_ALTIVEC)
-# endif
-# define HWAES_CAPABLE  (OPENSSL_ppccap_P &amp; PPC_CRYPTO207)
-# define HWAES_set_encrypt_key aes_p8_set_encrypt_key
-# define HWAES_set_decrypt_key aes_p8_set_decrypt_key
-# define HWAES_encrypt aes_p8_encrypt
-# define HWAES_decrypt aes_p8_decrypt
-# define HWAES_cbc_encrypt aes_p8_cbc_encrypt
-# define HWAES_ctr32_encrypt_blocks aes_p8_ctr32_encrypt_blocks
-# define HWAES_xts_encrypt aes_p8_xts_encrypt
-# define HWAES_xts_decrypt aes_p8_xts_decrypt
-#endif
-
-#if     defined(AES_ASM) &amp;&amp; !defined(I386_ONLY) &amp;&amp;      (  \
-        ((defined(__i386)       || defined(__i386__)    || \
-          defined(_M_IX86)) &amp;&amp; defined(OPENSSL_IA32_SSE2))|| \
-        defined(__x86_64)       || defined(__x86_64__)  || \
-        defined(_M_AMD64)       || defined(_M_X64)      )
-
-extern unsigned int OPENSSL_ia32cap_P[];
-
-# ifdef VPAES_ASM
-#  define VPAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
-# endif
-# ifdef BSAES_ASM
-#  define BSAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
-# endif
-/*
- * AES-NI section
- */
-# define AESNI_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(57-32)))
-
-int aesni_set_encrypt_key(const unsigned char *userKey, int bits,
-                          AES_KEY *key);
-int aesni_set_decrypt_key(const unsigned char *userKey, int bits,
-                          AES_KEY *key);
-
-void aesni_encrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-void aesni_decrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-
-void aesni_ecb_encrypt(const unsigned char *in,
-                       unsigned char *out,
-                       size_t length, const AES_KEY *key, int enc);
-void aesni_cbc_encrypt(const unsigned char *in,
-                       unsigned char *out,
-                       size_t length,
-                       const AES_KEY *key, unsigned char *ivec, int enc);
-
-void aesni_ctr32_encrypt_blocks(const unsigned char *in,
-                                unsigned char *out,
-                                size_t blocks,
-                                const void *key, const unsigned char *ivec);
-
-void aesni_xts_encrypt(const unsigned char *in,
-                       unsigned char *out,
-                       size_t length,
-                       const AES_KEY *key1, const AES_KEY *key2,
-                       const unsigned char iv[16]);
-
-void aesni_xts_decrypt(const unsigned char *in,
-                       unsigned char *out,
-                       size_t length,
-                       const AES_KEY *key1, const AES_KEY *key2,
-                       const unsigned char iv[16]);
-
-void aesni_ccm64_encrypt_blocks(const unsigned char *in,
-                                unsigned char *out,
-                                size_t blocks,
-                                const void *key,
-                                const unsigned char ivec[16],
-                                unsigned char cmac[16]);
-
-void aesni_ccm64_decrypt_blocks(const unsigned char *in,
-                                unsigned char *out,
-                                size_t blocks,
-                                const void *key,
-                                const unsigned char ivec[16],
-                                unsigned char cmac[16]);
-
+#if defined(AESNI_CAPABLE)
 # if defined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)
-size_t aesni_gcm_encrypt(const unsigned char *in,
-                         unsigned char *out,
-                         size_t len,
-                         const void *key, unsigned char ivec[16], u64 *Xi);
 #  define AES_gcm_encrypt aesni_gcm_encrypt
-size_t aesni_gcm_decrypt(const unsigned char *in,
-                         unsigned char *out,
-                         size_t len,
-                         const void *key, unsigned char ivec[16], u64 *Xi);
 #  define AES_gcm_decrypt aesni_gcm_decrypt
-void gcm_ghash_avx(u64 Xi[2], const u128 Htable[16], const u8 *in,
-                   size_t len);
-#  define AES_GCM_ASM(gctx)       (gctx-&gt;ctr==aesni_ctr32_encrypt_blocks &amp;&amp; \
-                                 gctx-&gt;gcm.ghash==gcm_ghash_avx)
 #  define AES_GCM_ASM2(gctx)      (gctx-&gt;gcm.block==(block128_f)aesni_encrypt &amp;&amp; \
                                  gctx-&gt;gcm.ghash==gcm_ghash_avx)
 #  undef AES_GCM_ASM2          /* minor size optimization */
@@ -471,19 +333,6 @@ static int aesni_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t len);
 
 # ifndef OPENSSL_NO_OCB
-void aesni_ocb_encrypt(const unsigned char *in, unsigned char *out,
-                       size_t blocks, const void *key,
-                       size_t start_block_num,
-                       unsigned char offset_i[16],
-                       const unsigned char L_[][16],
-                       unsigned char checksum[16]);
-void aesni_ocb_decrypt(const unsigned char *in, unsigned char *out,
-                       size_t blocks, const void *key,
-                       size_t start_block_num,
-                       unsigned char offset_i[16],
-                       const unsigned char L_[][16],
-                       unsigned char checksum[16]);
-
 static int aesni_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                               const unsigned char *iv, int enc)
 {
@@ -584,81 +433,7 @@ static const EVP_CIPHER aes_##keylen##_##mode = { \
 const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 { return AESNI_CAPABLE?&amp;aesni_##keylen##_##mode:&amp;aes_##keylen##_##mode; }
 
-#elif   defined(AES_ASM) &amp;&amp; (defined(__sparc) || defined(__sparc__))
-
-# include &quot;sparc_arch.h&quot;
-
-extern unsigned int OPENSSL_sparcv9cap_P[];
-
-/*
- * Initial Fujitsu SPARC64 X support
- */
-# define HWAES_CAPABLE           (OPENSSL_sparcv9cap_P[0] &amp; SPARCV9_FJAESX)
-# define HWAES_set_encrypt_key aes_fx_set_encrypt_key
-# define HWAES_set_decrypt_key aes_fx_set_decrypt_key
-# define HWAES_encrypt aes_fx_encrypt
-# define HWAES_decrypt aes_fx_decrypt
-# define HWAES_cbc_encrypt aes_fx_cbc_encrypt
-# define HWAES_ctr32_encrypt_blocks aes_fx_ctr32_encrypt_blocks
-
-# define SPARC_AES_CAPABLE       (OPENSSL_sparcv9cap_P[1] &amp; CFR_AES)
-
-void aes_t4_set_encrypt_key(const unsigned char *key, int bits, AES_KEY *ks);
-void aes_t4_set_decrypt_key(const unsigned char *key, int bits, AES_KEY *ks);
-void aes_t4_encrypt(const unsigned char *in, unsigned char *out,
-                    const AES_KEY *key);
-void aes_t4_decrypt(const unsigned char *in, unsigned char *out,
-                    const AES_KEY *key);
-/*
- * Key-length specific subroutines were chosen for following reason.
- * Each SPARC T4 core can execute up to 8 threads which share core's
- * resources. Loading as much key material to registers allows to
- * minimize references to shared memory interface, as well as amount
- * of instructions in inner loops [much needed on T4]. But then having
- * non-key-length specific routines would require conditional branches
- * either in inner loops or on subroutines' entries. Former is hardly
- * acceptable, while latter means code size increase to size occupied
- * by multiple key-length specific subroutines, so why fight?
- */
-void aes128_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes128_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes192_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes192_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes256_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes256_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes128_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
-                             size_t blocks, const AES_KEY *key,
-                             unsigned char *ivec);
-void aes192_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
-                             size_t blocks, const AES_KEY *key,
-                             unsigned char *ivec);
-void aes256_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
-                             size_t blocks, const AES_KEY *key,
-                             unsigned char *ivec);
-void aes128_t4_xts_encrypt(const unsigned char *in, unsigned char *out,
-                           size_t blocks, const AES_KEY *key1,
-                           const AES_KEY *key2, const unsigned char *ivec);
-void aes128_t4_xts_decrypt(const unsigned char *in, unsigned char *out,
-                           size_t blocks, const AES_KEY *key1,
-                           const AES_KEY *key2, const unsigned char *ivec);
-void aes256_t4_xts_encrypt(const unsigned char *in, unsigned char *out,
-                           size_t blocks, const AES_KEY *key1,
-                           const AES_KEY *key2, const unsigned char *ivec);
-void aes256_t4_xts_decrypt(const unsigned char *in, unsigned char *out,
-                           size_t blocks, const AES_KEY *key1,
-                           const AES_KEY *key2, const unsigned char *ivec);
+#elif defined(SPARC_AES_CAPABLE)
 
 static int aes_t4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                            const unsigned char *iv, int enc)
@@ -1012,12 +787,8 @@ static const EVP_CIPHER aes_##keylen##_##mode = { \
 const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 { return SPARC_AES_CAPABLE?&amp;aes_t4_##keylen##_##mode:&amp;aes_##keylen##_##mode; }
 
-#elif defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__)
-/*
- * IBM S390X support
- */
-# include &quot;s390x_arch.h&quot;
-
+#elif defined(S390X_aes_128_CAPABLE)
+/* IBM S390X support */
 typedef struct {
     union {
         OSSL_UNION_ALIGN;
@@ -1170,24 +941,10 @@ typedef struct {
     } aes;
 } S390X_AES_CCM_CTX;
 
-/* Convert key size to function code: [16,24,32] -&gt; [18,19,20]. */
-# define S390X_AES_FC(keylen)  (S390X_AES_128 + ((((keylen) &lt;&lt; 3) - 128) &gt;&gt; 6))
-
-/* Most modes of operation need km for partial block processing. */
-# define S390X_aes_128_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;	\
-                                S390X_CAPBIT(S390X_AES_128))
-# define S390X_aes_192_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;	\
-                                S390X_CAPBIT(S390X_AES_192))
-# define S390X_aes_256_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;	\
-                                S390X_CAPBIT(S390X_AES_256))
-
 # define s390x_aes_init_key aes_init_key
 static int s390x_aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                               const unsigned char *iv, int enc);
 
-# define S390X_aes_128_cbc_CAPABLE	1	/* checked by callee */
-# define S390X_aes_192_cbc_CAPABLE	1
-# define S390X_aes_256_cbc_CAPABLE	1
 # define S390X_AES_CBC_CTX		EVP_AES_KEY
 
 # define s390x_aes_cbc_init_key aes_init_key
@@ -1196,10 +953,6 @@ static int s390x_aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 static int s390x_aes_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                 const unsigned char *in, size_t len);
 
-# define S390X_aes_128_ecb_CAPABLE	S390X_aes_128_CAPABLE
-# define S390X_aes_192_ecb_CAPABLE	S390X_aes_192_CAPABLE
-# define S390X_aes_256_ecb_CAPABLE	S390X_aes_256_CAPABLE
-
 static int s390x_aes_ecb_init_key(EVP_CIPHER_CTX *ctx,
                                   const unsigned char *key,
                                   const unsigned char *iv, int enc)
@@ -1224,16 +977,6 @@ static int s390x_aes_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     return 1;
 }
 
-# define S390X_aes_128_ofb_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kmo[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_128)))
-# define S390X_aes_192_ofb_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kmo[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_192)))
-# define S390X_aes_256_ofb_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kmo[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_256)))
-
 static int s390x_aes_ofb_init_key(EVP_CIPHER_CTX *ctx,
                                   const unsigned char *key,
                                   const unsigned char *ivec, int enc)
@@ -1289,16 +1032,6 @@ static int s390x_aes_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     return 1;
 }
 
-# define S390X_aes_128_cfb_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kmf[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_128)))
-# define S390X_aes_192_cfb_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kmf[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_192)))
-# define S390X_aes_256_cfb_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kmf[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_256)))
-
 static int s390x_aes_cfb_init_key(EVP_CIPHER_CTX *ctx,
                                   const unsigned char *key,
                                   const unsigned char *ivec, int enc)
@@ -1365,13 +1098,6 @@ static int s390x_aes_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     return 1;
 }
 
-# define S390X_aes_128_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_128))
-# define S390X_aes_192_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_192))
-# define S390X_aes_256_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_256))
-
 static int s390x_aes_cfb8_init_key(EVP_CIPHER_CTX *ctx,
                                    const unsigned char *key,
                                    const unsigned char *ivec, int enc)
@@ -1400,19 +1126,12 @@ static int s390x_aes_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     return 1;
 }
 
-# define S390X_aes_128_cfb1_CAPABLE	0
-# define S390X_aes_192_cfb1_CAPABLE	0
-# define S390X_aes_256_cfb1_CAPABLE	0
-
 # define s390x_aes_cfb1_init_key aes_init_key
 
 # define s390x_aes_cfb1_cipher aes_cfb1_cipher
 static int s390x_aes_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                  const unsigned char *in, size_t len);
 
-# define S390X_aes_128_ctr_CAPABLE	1	/* checked by callee */
-# define S390X_aes_192_ctr_CAPABLE	1
-# define S390X_aes_256_ctr_CAPABLE	1
 # define S390X_AES_CTR_CTX		EVP_AES_KEY
 
 # define s390x_aes_ctr_init_key aes_init_key
@@ -1421,16 +1140,6 @@ static int s390x_aes_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 static int s390x_aes_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                 const unsigned char *in, size_t len);
 
-# define S390X_aes_128_gcm_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kma[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_128)))
-# define S390X_aes_192_gcm_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kma[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_192)))
-# define S390X_aes_256_gcm_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kma[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_256)))
-
 /* iv + padding length for iv lengths != 12 */
 # define S390X_gcm_ivpadlen(i)	((((i) + 15) &gt;&gt; 4 &lt;&lt; 4) + 16)
 
@@ -1954,8 +1663,6 @@ static int s390x_aes_gcm_cleanup(EVP_CIPHER_CTX *c)
 }
 
 # define S390X_AES_XTS_CTX		EVP_AES_XTS_CTX
-# define S390X_aes_128_xts_CAPABLE	1	/* checked by callee */
-# define S390X_aes_256_xts_CAPABLE	1
 
 # define s390x_aes_xts_init_key aes_xts_init_key
 static int s390x_aes_xts_init_key(EVP_CIPHER_CTX *ctx,
@@ -1968,18 +1675,6 @@ static int s390x_aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 static int s390x_aes_xts_ctrl(EVP_CIPHER_CTX *, int type, int arg, void *ptr);
 # define s390x_aes_xts_cleanup aes_xts_cleanup
 
-# define S390X_aes_128_ccm_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kmac[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_128)))
-# define S390X_aes_192_ccm_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kmac[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_192)))
-# define S390X_aes_256_ccm_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;		\
-                                    (OPENSSL_s390xcap_P.kmac[0] &amp;	\
-                                     S390X_CAPBIT(S390X_AES_256)))
-
-# define S390X_CCM_AAD_FLAG	0x40
-
 /*-
  * Set nonce and length fields. Code is big-endian.
  */
@@ -2452,9 +2147,6 @@ static int s390x_aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
 
 # ifndef OPENSSL_NO_OCB
 #  define S390X_AES_OCB_CTX		EVP_AES_OCB_CTX
-#  define S390X_aes_128_ocb_CAPABLE	0
-#  define S390X_aes_192_ocb_CAPABLE	0
-#  define S390X_aes_256_ocb_CAPABLE	0
 
 #  define s390x_aes_ocb_init_key aes_ocb_init_key
 static int s390x_aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
@@ -2470,9 +2162,6 @@ static int s390x_aes_ocb_ctrl(EVP_CIPHER_CTX *, int type, int arg, void *ptr);
 
 # ifndef OPENSSL_NO_SIV
 #  define S390X_AES_SIV_CTX             EVP_AES_SIV_CTX
-#  define S390X_aes_128_siv_CAPABLE     0
-#  define S390X_aes_192_siv_CAPABLE     0
-#  define S390X_aes_256_siv_CAPABLE     0
 
 #  define s390x_aes_siv_init_key aes_siv_init_key
 #  define s390x_aes_siv_cipher aes_siv_cipher
@@ -2583,48 +2272,6 @@ const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 
 #endif
 
-#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; (defined(__arm__) || defined(__arm) || defined(__aarch64__))
-# include &quot;arm_arch.h&quot;
-# if __ARM_MAX_ARCH__&gt;=7
-#  if defined(BSAES_ASM)
-#   define BSAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
-#  endif
-#  if defined(VPAES_ASM)
-#   define VPAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
-#  endif
-#  define HWAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV8_AES)
-#  define HWAES_set_encrypt_key aes_v8_set_encrypt_key
-#  define HWAES_set_decrypt_key aes_v8_set_decrypt_key
-#  define HWAES_encrypt aes_v8_encrypt
-#  define HWAES_decrypt aes_v8_decrypt
-#  define HWAES_cbc_encrypt aes_v8_cbc_encrypt
-#  define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks
-# endif
-#endif
-
-#if defined(HWAES_CAPABLE)
-int HWAES_set_encrypt_key(const unsigned char *userKey, const int bits,
-                          AES_KEY *key);
-int HWAES_set_decrypt_key(const unsigned char *userKey, const int bits,
-                          AES_KEY *key);
-void HWAES_encrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-void HWAES_decrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-void HWAES_cbc_encrypt(const unsigned char *in, unsigned char *out,
-                       size_t length, const AES_KEY *key,
-                       unsigned char *ivec, const int enc);
-void HWAES_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
-                                size_t len, const AES_KEY *key,
-                                const unsigned char ivec[16]);
-void HWAES_xts_encrypt(const unsigned char *inp, unsigned char *out,
-                       size_t len, const AES_KEY *key1,
-                       const AES_KEY *key2, const unsigned char iv[16]);
-void HWAES_xts_decrypt(const unsigned char *inp, unsigned char *out,
-                       size_t len, const AES_KEY *key1,
-                       const AES_KEY *key2, const unsigned char iv[16]);
-#endif
-
 #define BLOCK_CIPHER_generic_pack(nid,keylen,flags)             \
         BLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)     \
         BLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)      \
@@ -4110,29 +3757,6 @@ static int aes_ocb_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
     }
 }
 
-# ifdef HWAES_CAPABLE
-#  ifdef HWAES_ocb_encrypt
-void HWAES_ocb_encrypt(const unsigned char *in, unsigned char *out,
-                       size_t blocks, const void *key,
-                       size_t start_block_num,
-                       unsigned char offset_i[16],
-                       const unsigned char L_[][16],
-                       unsigned char checksum[16]);
-#  else
-#    define HWAES_ocb_encrypt ((ocb128_f)NULL)
-#  endif
-#  ifdef HWAES_ocb_decrypt
-void HWAES_ocb_decrypt(const unsigned char *in, unsigned char *out,
-                       size_t blocks, const void *key,
-                       size_t start_block_num,
-                       unsigned char offset_i[16],
-                       const unsigned char L_[][16],
-                       unsigned char checksum[16]);
-#  else
-#    define HWAES_ocb_decrypt ((ocb128_f)NULL)
-#  endif
-# endif
-
 static int aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                             const unsigned char *iv, int enc)
 {
diff --git a/crypto/evp/e_aes_cbc_hmac_sha1.c b/crypto/evp/e_aes_cbc_hmac_sha1.c
index f6450f3..8d557e5 100644
--- a/crypto/evp/e_aes_cbc_hmac_sha1.c
+++ b/crypto/evp/e_aes_cbc_hmac_sha1.c
@@ -7,17 +7,15 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;openssl/opensslconf.h&gt;
-
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
-
+#include &lt;openssl/opensslconf.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/objects.h&gt;
 #include &lt;openssl/aes.h&gt;
 #include &lt;openssl/sha.h&gt;
 #include &lt;openssl/rand.h&gt;
-#include &quot;modes_lcl.h&quot;
+#include &quot;internal/modes_int.h&quot;
 #include &quot;internal/evp_int.h&quot;
 #include &quot;internal/constant_time_locl.h&quot;
 
diff --git a/crypto/evp/e_aes_cbc_hmac_sha256.c b/crypto/evp/e_aes_cbc_hmac_sha256.c
index cd51e93..6efd300 100644
--- a/crypto/evp/e_aes_cbc_hmac_sha256.c
+++ b/crypto/evp/e_aes_cbc_hmac_sha256.c
@@ -7,18 +7,15 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;openssl/opensslconf.h&gt;
-
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
-
-
+#include &lt;openssl/opensslconf.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/objects.h&gt;
 #include &lt;openssl/aes.h&gt;
 #include &lt;openssl/sha.h&gt;
 #include &lt;openssl/rand.h&gt;
-#include &quot;modes_lcl.h&quot;
+#include &quot;internal/modes_int.h&quot;
 #include &quot;internal/constant_time_locl.h&quot;
 #include &quot;internal/evp_int.h&quot;
 
diff --git a/crypto/evp/e_aria.c b/crypto/evp/e_aria.c
index 5404dd4..f2588f1 100644
--- a/crypto/evp/e_aria.c
+++ b/crypto/evp/e_aria.c
@@ -16,7 +16,7 @@
 # include &lt;openssl/rand_drbg.h&gt;
 # include &quot;internal/aria.h&quot;
 # include &quot;internal/evp_int.h&quot;
-# include &quot;modes_lcl.h&quot;
+# include &quot;internal/modes_int.h&quot;
 # include &quot;evp_locl.h&quot;
 
 /* ARIA subkey Structure */
diff --git a/crypto/evp/e_camellia.c b/crypto/evp/e_camellia.c
index e018ba4..9def167 100644
--- a/crypto/evp/e_camellia.c
+++ b/crypto/evp/e_camellia.c
@@ -18,7 +18,7 @@ NON_EMPTY_TRANSLATION_UNIT
 # include &lt;assert.h&gt;
 # include &lt;openssl/camellia.h&gt;
 # include &quot;internal/evp_int.h&quot;
-# include &quot;modes_lcl.h&quot;
+# include &quot;internal/modes_int.h&quot;
 
 static int camellia_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                              const unsigned char *iv, int enc);
diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
index 3b83d11..c1f7e77 100644
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -920,9 +920,11 @@ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
 
 int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)
 {
-    int ok = evp_do_param(c-&gt;cipher, &amp;keylen, sizeof(keylen),
-                          OSSL_CIPHER_PARAM_KEYLEN, OSSL_PARAM_INTEGER,
-                          evp_do_ciph_ctx_setparams, c-&gt;provctx);
+    int ok;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
+
+    params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_KEYLEN, &amp;keylen);
+    ok = evp_do_ciph_ctx_setparams(c-&gt;cipher, c-&gt;provctx, params);
 
     if (ok != -2)
         return ok;
@@ -943,23 +945,27 @@ int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)
 int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *ctx, int pad)
 {
     int ok;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
     if (pad)
         ctx-&gt;flags &amp;= ~EVP_CIPH_NO_PADDING;
     else
         ctx-&gt;flags |= EVP_CIPH_NO_PADDING;
 
-    ok = evp_do_param(ctx-&gt;cipher, &amp;pad, sizeof(pad),
-                      OSSL_CIPHER_PARAM_PADDING, OSSL_PARAM_INTEGER,
-                      evp_do_ciph_ctx_setparams, ctx-&gt;provctx);
+    params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_PADDING, &amp;pad);
+    ok = evp_do_ciph_ctx_setparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+
     return ok != 0;
 }
 
 int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
 {
     int ret = -2;                /* Unsupported */
+    int set_params = 1;
+    size_t sz;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
-    if (!ctx-&gt;cipher) {
+    if (ctx == NULL || ctx-&gt;cipher == NULL) {
         EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_NO_CIPHER_SET);
         return 0;
     }
@@ -969,25 +975,65 @@ int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
 
     switch (type) {
     case EVP_CTRL_SET_KEY_LENGTH:
-        ret = evp_do_param(ctx-&gt;cipher, &amp;arg, sizeof(arg),
-                           OSSL_CIPHER_PARAM_KEYLEN, OSSL_PARAM_INTEGER,
-                           evp_do_ciph_ctx_setparams, ctx-&gt;provctx);
-        break;
-    case EVP_CTRL_GET_IV:
-        ret = evp_do_param(ctx-&gt;cipher, ptr, arg,
-                           OSSL_CIPHER_PARAM_IV, OSSL_PARAM_OCTET_STRING,
-                           evp_do_ciph_ctx_getparams, ctx-&gt;provctx);
+        params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_KEYLEN, &amp;arg);
         break;
     case EVP_CTRL_RAND_KEY:      /* Used by DES */
     case EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS: /* Used by DASYNC */
     case EVP_CTRL_INIT: /* TODO(3.0) Purely legacy, no provider counterpart */
-        ret = -2;                /* Unsupported */
+    default:
+        return -2;      /* Unsupported */
+    case EVP_CTRL_GET_IV:
+        set_params = 0;
+        params[0] = OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_IV,
+                                                      ptr, (size_t)arg);
+        break;
+    case EVP_CTRL_AEAD_SET_IVLEN:
+        if (arg &lt; 0)
+            return 0;
+        sz = (size_t)arg;
+        params[0] =
+            OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_AEAD_IVLEN, &amp;sz);
         break;
+    case EVP_CTRL_GCM_SET_IV_FIXED:
+        params[0] =
+            OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_TLS1_IV_FIXED,
+                                              ptr, (size_t)arg);
+        break;
+    case EVP_CTRL_AEAD_SET_TAG:
+        params[0] =
+            OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_TAG,
+                                              ptr, (size_t)arg);
+        break;
+    case EVP_CTRL_AEAD_GET_TAG:
+        set_params = 0;
+        params[0] = OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_TAG,
+                                                      ptr, (size_t)arg);
+        break;
+    case EVP_CTRL_AEAD_TLS1_AAD:
+        /* This one does a set and a get - since it returns a padding size */
+        params[0] =
+            OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_TLS1_AAD,
+                                              ptr, (size_t)arg);
+        ret = evp_do_ciph_ctx_setparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+        if (ret &lt;= 0)
+            return ret;
+        params[0] =
+            OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD, &amp;sz);
+        ret = evp_do_ciph_ctx_getparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+        if (ret &lt;= 0)
+            return 0;
+        return sz;
     }
+
+    if (set_params)
+        ret = evp_do_ciph_ctx_setparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+    else
+        ret = evp_do_ciph_ctx_getparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
     return ret;
 
- legacy:
-    if (!ctx-&gt;cipher-&gt;ctrl) {
+/* TODO(3.0): Remove legacy code below */
+legacy:
+    if (ctx-&gt;cipher-&gt;ctrl == NULL) {
         EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_NOT_IMPLEMENTED);
         return 0;
     }
diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
index 9d1d197..615206b 100644
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -217,10 +217,11 @@ int EVP_CIPHER_type(const EVP_CIPHER *ctx)
 
 int EVP_CIPHER_block_size(const EVP_CIPHER *cipher)
 {
-    int v = cipher-&gt;block_size;
-    int ok = evp_do_param(cipher, &amp;v, sizeof(v),
-                          OSSL_CIPHER_PARAM_BLOCK_SIZE, OSSL_PARAM_INTEGER,
-                          evp_do_ciph_getparams, NULL);
+    int ok, v = cipher-&gt;block_size;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
+
+    params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_BLOCK_SIZE, &amp;v);
+    ok = evp_do_ciph_getparams(cipher, params);
 
     return ok != 0 ? v : -1;
 }
@@ -265,10 +266,12 @@ int EVP_CIPHER_CTX_encrypting(const EVP_CIPHER_CTX *ctx)
 
 unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher)
 {
+    int ok;
     unsigned long v = cipher-&gt;flags;
-    int ok = evp_do_param(cipher, &amp;v, sizeof(v),
-                          OSSL_CIPHER_PARAM_FLAGS, OSSL_PARAM_UNSIGNED_INTEGER,
-                          evp_do_ciph_getparams, NULL);
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
+
+    params[0] = OSSL_PARAM_construct_ulong(OSSL_CIPHER_PARAM_FLAGS, &amp;v);
+    ok = evp_do_ciph_getparams(cipher, params);
 
     return ok != 0 ? v : 0;
 }
@@ -300,12 +303,13 @@ void *EVP_CIPHER_CTX_set_cipher_data(EVP_CIPHER_CTX *ctx, void *cipher_data)
 
 int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher)
 {
-    int v = cipher-&gt;iv_len;
-    int ok = evp_do_param(cipher, &amp;v, sizeof(v),
-                          OSSL_CIPHER_PARAM_IVLEN, OSSL_PARAM_UNSIGNED_INTEGER,
-                          evp_do_ciph_getparams, NULL);
+    int ok, v = cipher-&gt;iv_len;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
-    return ok != 0 ? v: -1;
+    params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_IVLEN, &amp;v);
+    ok = evp_do_ciph_getparams(cipher, params);
+
+    return ok != 0 ? v : -1;
 }
 
 int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx)
@@ -323,22 +327,30 @@ const unsigned char *EVP_CIPHER_CTX_original_iv(const EVP_CIPHER_CTX *ctx)
  */
 const unsigned char *EVP_CIPHER_CTX_iv(const EVP_CIPHER_CTX *ctx)
 {
+    int ok;
     const unsigned char *v = ctx-&gt;iv;
-    int ok = evp_do_param(ctx-&gt;cipher, &amp;v, sizeof(ctx-&gt;iv),
-                          OSSL_CIPHER_PARAM_IV, OSSL_PARAM_OCTET_PTR,
-                          evp_do_ciph_ctx_getparams, ctx-&gt;provctx);
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
-    return ok != 0 ? v: NULL;
+    params[0] =
+        OSSL_PARAM_construct_octet_ptr(OSSL_CIPHER_PARAM_IV, (void **)&amp;v,
+                                       sizeof(ctx-&gt;iv));
+    ok = evp_do_ciph_ctx_getparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+
+    return ok != 0 ? v : NULL;
 }
 
 unsigned char *EVP_CIPHER_CTX_iv_noconst(EVP_CIPHER_CTX *ctx)
 {
+    int ok;
     unsigned char *v = ctx-&gt;iv;
-    int ok = evp_do_param(ctx-&gt;cipher, &amp;v, sizeof(ctx-&gt;iv),
-                          OSSL_CIPHER_PARAM_IV, OSSL_PARAM_OCTET_PTR,
-                          evp_do_ciph_ctx_getparams, ctx-&gt;provctx);
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
+
+    params[0] =
+        OSSL_PARAM_construct_octet_ptr(OSSL_CIPHER_PARAM_IV, (void **)&amp;v,
+                                       sizeof(ctx-&gt;iv));
+    ok = evp_do_ciph_ctx_getparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
 
-    return ok != 0 ? v: NULL;
+    return ok != 0 ? v : NULL;
 }
 
 unsigned char *EVP_CIPHER_CTX_buf_noconst(EVP_CIPHER_CTX *ctx)
@@ -348,42 +360,48 @@ unsigned char *EVP_CIPHER_CTX_buf_noconst(EVP_CIPHER_CTX *ctx)
 
 int EVP_CIPHER_CTX_num(const EVP_CIPHER_CTX *ctx)
 {
-    int v = ctx-&gt;num;
-    int ok = evp_do_param(ctx-&gt;cipher, &amp;v, sizeof(v),
-                          OSSL_CIPHER_PARAM_NUM, OSSL_PARAM_INTEGER,
-                          evp_do_ciph_ctx_getparams, ctx-&gt;provctx);
+    int ok, v = ctx-&gt;num;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
-    return ok != 0 ? v: -1;
+    params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_NUM, &amp;v);
+    ok = evp_do_ciph_ctx_getparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+
+    return ok != 0 ? v : -1;
 }
 
 int EVP_CIPHER_CTX_set_num(EVP_CIPHER_CTX *ctx, int num)
 {
-    int ok = evp_do_param(ctx-&gt;cipher, &amp;num, sizeof(num),
-                          OSSL_CIPHER_PARAM_NUM, OSSL_PARAM_INTEGER,
-                          evp_do_ciph_ctx_setparams, ctx-&gt;provctx);
+    int ok;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
-    ctx-&gt;num = num;
+    params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_NUM, &amp;num);
+    ok = evp_do_ciph_ctx_setparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+
+    if (ok != 0)
+        ctx-&gt;num = num;
     return ok != 0;
 }
 
 int EVP_CIPHER_key_length(const EVP_CIPHER *cipher)
 {
-    int v = cipher-&gt;key_len;
-    int ok = evp_do_param(cipher, &amp;v, sizeof(v),
-                          OSSL_CIPHER_PARAM_KEYLEN, OSSL_PARAM_INTEGER,
-                          evp_do_ciph_getparams, NULL);
+    int ok, v = cipher-&gt;key_len;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
+
+    params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_KEYLEN, &amp;v);
+    ok = evp_do_ciph_getparams(cipher, params);
 
-    return ok != 0 ? v: -1;
+    return ok != 0 ? v : -1;
 }
 
 int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx)
 {
-    int v = ctx-&gt;key_len;
-    int ok = evp_do_param(ctx-&gt;cipher, &amp;v, sizeof(v),
-                          OSSL_CIPHER_PARAM_KEYLEN, OSSL_PARAM_INTEGER,
-                          evp_do_ciph_ctx_getparams, ctx-&gt;provctx);
+    int ok, v = ctx-&gt;key_len;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
+
+    params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_KEYLEN, &amp;v);
+    ok = evp_do_ciph_ctx_getparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
 
-    return ok != 0 ? v: -1;
+    return ok != 0 ? v : -1;
 }
 
 int EVP_CIPHER_nid(const EVP_CIPHER *cipher)
@@ -398,14 +416,14 @@ int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx)
 
 int EVP_CIPHER_mode(const EVP_CIPHER *cipher)
 {
-    int v = EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_MODE;
-    int ok = evp_do_param(cipher, &amp;v, sizeof(v),
-                          OSSL_CIPHER_PARAM_MODE, OSSL_PARAM_INTEGER,
-                          evp_do_ciph_getparams, NULL);
+    int ok, v = EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_MODE;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
-    return ok != 0 ? v: 0;
-}
+    params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_MODE, &amp;v);
+    ok = evp_do_ciph_getparams(cipher, params);
 
+    return ok != 0 ? v : 0;
+}
 
 int EVP_MD_block_size(const EVP_MD *md)
 {
diff --git a/crypto/evp/evp_locl.h b/crypto/evp/evp_locl.h
index 54f9e08..b62f1e3 100644
--- a/crypto/evp/evp_locl.h
+++ b/crypto/evp/evp_locl.h
@@ -99,7 +99,7 @@ void *evp_generic_fetch(OPENSSL_CTX *ctx, int operation_id,
 /* Helper functions to avoid duplicating code */
 
 /*
- * The callbacks implement different ways to pass a params array to the
+ * These methods implement different ways to pass a params array to the
  * provider.  They will return one of these values:
  *
  * -2 if the method doesn't come from a provider
@@ -109,26 +109,8 @@ void *evp_generic_fetch(OPENSSL_CTX *ctx, int operation_id,
  * or the return value from the desired function
  *    (evp_do_param will return it to the caller)
  */
-int evp_do_ciph_getparams(const void *vciph, void *ignored,
-                          OSSL_PARAM params[]);
-int evp_do_ciph_ctx_getparams(const void *vciph, void *provctx,
+int evp_do_ciph_getparams(const EVP_CIPHER *ciph, OSSL_PARAM params[]);
+int evp_do_ciph_ctx_getparams(const EVP_CIPHER *ciph, void *provctx,
                               OSSL_PARAM params[]);
-int evp_do_ciph_ctx_setparams(const void *vciph, void *provctx,
+int evp_do_ciph_ctx_setparams(const EVP_CIPHER *ciph, void *provctx,
                               OSSL_PARAM params[]);
-
-/*-
- * prepares a singular parameter, then calls the callback to execute.
- *
- * |method|   points to the method used by the callback.
- *            EVP_CIPHER, EVP_MD, ...
- * |ptr|      points at the data to transfer.
- * |sz|       is the size of the data to transfer.
- * |key|      is the name of the parameter to pass.
- * |datatype| is the data type of the parameter to pass.
- * |cb|       is the callback that actually performs the parameter passing
- * |cb_ctx|   is the cipher context
- */
-int evp_do_param(const void *method, void *ptr, size_t sz, const char *key,
-                 int datatype,
-                 int (*cb)(const void *method, void *ctx, OSSL_PARAM params[]),
-                 void *cb_ctx);
diff --git a/crypto/evp/evp_utils.c b/crypto/evp/evp_utils.c
index 48f548c..c3b5520 100644
--- a/crypto/evp/evp_utils.c
+++ b/crypto/evp/evp_utils.c
@@ -17,11 +17,8 @@
 #include &quot;internal/evp_int.h&quot;    /* evp_locl.h needs it */
 #include &quot;evp_locl.h&quot;
 
-int evp_do_ciph_getparams(const void *vciph, void *ignored,
-                          OSSL_PARAM params[])
+int evp_do_ciph_getparams(const EVP_CIPHER *ciph, OSSL_PARAM params[])
 {
-    const EVP_CIPHER *ciph = vciph;
-
     if (ciph-&gt;prov == NULL)
         return -2;
     if (ciph-&gt;get_params == NULL)
@@ -29,11 +26,9 @@ int evp_do_ciph_getparams(const void *vciph, void *ignored,
     return ciph-&gt;get_params(params);
 }
 
-int evp_do_ciph_ctx_getparams(const void *vciph, void *provctx,
+int evp_do_ciph_ctx_getparams(const EVP_CIPHER *ciph, void *provctx,
                               OSSL_PARAM params[])
 {
-    const EVP_CIPHER *ciph = vciph;
-
     if (ciph-&gt;prov == NULL)
         return -2;
     if (ciph-&gt;ctx_get_params == NULL)
@@ -41,38 +36,12 @@ int evp_do_ciph_ctx_getparams(const void *vciph, void *provctx,
     return ciph-&gt;ctx_get_params(provctx, params);
 }
 
-int evp_do_ciph_ctx_setparams(const void *vciph, void *provctx,
+int evp_do_ciph_ctx_setparams(const EVP_CIPHER *ciph, void *provctx,
                               OSSL_PARAM params[])
 {
-    const EVP_CIPHER *ciph = vciph;
-
     if (ciph-&gt;prov == NULL)
         return -2;
     if (ciph-&gt;ctx_set_params == NULL)
         return -1;
     return ciph-&gt;ctx_set_params(provctx, params);
 }
-
-int evp_do_param(const void *method, void *ptr, size_t sz, const char *key,
-                 int datatype,
-                 int (*cb)(const void *method, void *ctx, OSSL_PARAM params[]),
-                 void *cb_ctx)
-{
-    OSSL_PARAM params[2] = {
-        OSSL_PARAM_END,
-        OSSL_PARAM_END
-    };
-    int ret;
-
-    params[0].key = key;
-    params[0].data_type = datatype;
-    params[0].data = ptr;
-    params[0].data_size = sz;
-
-    ret = cb(method, cb_ctx, params);
-    if (ret == -1) {
-        EVPerr(0, EVP_R_CTRL_NOT_IMPLEMENTED);
-        ret = 0;
-    }
-    return ret;
-}
diff --git a/crypto/include/internal/aes_platform.h b/crypto/include/internal/aes_platform.h
new file mode 100644
index 0000000..115264e
--- /dev/null
+++ b/crypto/include/internal/aes_platform.h
@@ -0,0 +1,391 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef HEADER_INTERNAL_AES_PLATFORM_H
+# define HEADER_INTERNAL_AES_PLATFORM_H
+
+# ifdef VPAES_ASM
+int vpaes_set_encrypt_key(const unsigned char *userKey, int bits,
+                          AES_KEY *key);
+int vpaes_set_decrypt_key(const unsigned char *userKey, int bits,
+                          AES_KEY *key);
+void vpaes_encrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+void vpaes_decrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+void vpaes_cbc_encrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length,
+                       const AES_KEY *key, unsigned char *ivec, int enc);
+# endif /* VPAES_ASM */
+
+# ifdef BSAES_ASM
+void bsaes_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                       size_t length, const AES_KEY *key,
+                       unsigned char ivec[16], int enc);
+void bsaes_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
+                                size_t len, const AES_KEY *key,
+                                const unsigned char ivec[16]);
+void bsaes_xts_encrypt(const unsigned char *inp, unsigned char *out,
+                       size_t len, const AES_KEY *key1,
+                       const AES_KEY *key2, const unsigned char iv[16]);
+void bsaes_xts_decrypt(const unsigned char *inp, unsigned char *out,
+                       size_t len, const AES_KEY *key1,
+                       const AES_KEY *key2, const unsigned char iv[16]);
+# endif /* BSAES_ASM */
+
+# ifdef AES_CTR_ASM
+void AES_ctr32_encrypt(const unsigned char *in, unsigned char *out,
+                       size_t blocks, const AES_KEY *key,
+                       const unsigned char ivec[AES_BLOCK_SIZE]);
+# endif /*  AES_CTR_ASM */
+
+# ifdef AES_XTS_ASM
+void AES_xts_encrypt(const unsigned char *inp, unsigned char *out, size_t len,
+                     const AES_KEY *key1, const AES_KEY *key2,
+                     const unsigned char iv[16]);
+void AES_xts_decrypt(const unsigned char *inp, unsigned char *out, size_t len,
+                     const AES_KEY *key1, const AES_KEY *key2,
+                     const unsigned char iv[16]);
+# endif /* AES_XTS_ASM */
+
+# if defined(OPENSSL_CPUID_OBJ)
+#  if (defined(__powerpc__) || defined(__ppc__) || defined(_ARCH_PPC))
+#   include &quot;ppc_arch.h&quot;
+#   ifdef VPAES_ASM
+#    define VPAES_CAPABLE (OPENSSL_ppccap_P &amp; PPC_ALTIVEC)
+#   endif
+#   define HWAES_CAPABLE  (OPENSSL_ppccap_P &amp; PPC_CRYPTO207)
+#   define HWAES_set_encrypt_key aes_p8_set_encrypt_key
+#   define HWAES_set_decrypt_key aes_p8_set_decrypt_key
+#   define HWAES_encrypt aes_p8_encrypt
+#   define HWAES_decrypt aes_p8_decrypt
+#   define HWAES_cbc_encrypt aes_p8_cbc_encrypt
+#   define HWAES_ctr32_encrypt_blocks aes_p8_ctr32_encrypt_blocks
+#   define HWAES_xts_encrypt aes_p8_xts_encrypt
+#   define HWAES_xts_decrypt aes_p8_xts_decrypt
+#  endif /* PPC */
+
+#  if (defined(__arm__) || defined(__arm) || defined(__aarch64__))
+#   include &quot;arm_arch.h&quot;
+#   if __ARM_MAX_ARCH__&gt;=7
+#    if defined(BSAES_ASM)
+#     define BSAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
+#    endif
+#    if defined(VPAES_ASM)
+#     define VPAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
+#    endif
+#    define HWAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV8_AES)
+#    define HWAES_set_encrypt_key aes_v8_set_encrypt_key
+#    define HWAES_set_decrypt_key aes_v8_set_decrypt_key
+#    define HWAES_encrypt aes_v8_encrypt
+#    define HWAES_decrypt aes_v8_decrypt
+#    define HWAES_cbc_encrypt aes_v8_cbc_encrypt
+#    define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks
+#   endif
+#  endif
+# endif /* OPENSSL_CPUID_OBJ */
+
+# if     defined(AES_ASM) &amp;&amp; !defined(I386_ONLY) &amp;&amp;      (  \
+         ((defined(__i386)       || defined(__i386__)    || \
+           defined(_M_IX86)) &amp;&amp; defined(OPENSSL_IA32_SSE2))|| \
+         defined(__x86_64)       || defined(__x86_64__)  || \
+         defined(_M_AMD64)       || defined(_M_X64)      )
+
+/* AES-NI section */
+extern unsigned int OPENSSL_ia32cap_P[];
+
+#  define AESNI_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(57-32)))
+#  ifdef VPAES_ASM
+#   define VPAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
+#  endif
+#  ifdef BSAES_ASM
+#   define BSAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
+#  endif
+
+int aesni_set_encrypt_key(const unsigned char *userKey, int bits,
+                          AES_KEY *key);
+int aesni_set_decrypt_key(const unsigned char *userKey, int bits,
+                          AES_KEY *key);
+
+void aesni_encrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+void aesni_decrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+
+void aesni_ecb_encrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length, const AES_KEY *key, int enc);
+void aesni_cbc_encrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length,
+                       const AES_KEY *key, unsigned char *ivec, int enc);
+#  ifndef OPENSSL_NO_OCB
+void aesni_ocb_encrypt(const unsigned char *in, unsigned char *out,
+                       size_t blocks, const void *key,
+                       size_t start_block_num,
+                       unsigned char offset_i[16],
+                       const unsigned char L_[][16],
+                       unsigned char checksum[16]);
+void aesni_ocb_decrypt(const unsigned char *in, unsigned char *out,
+                       size_t blocks, const void *key,
+                       size_t start_block_num,
+                       unsigned char offset_i[16],
+                       const unsigned char L_[][16],
+                       unsigned char checksum[16]);
+#  endif /* OPENSSL_NO_OCB */
+
+void aesni_ctr32_encrypt_blocks(const unsigned char *in,
+                                unsigned char *out,
+                                size_t blocks,
+                                const void *key, const unsigned char *ivec);
+
+void aesni_xts_encrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length,
+                       const AES_KEY *key1, const AES_KEY *key2,
+                       const unsigned char iv[16]);
+
+void aesni_xts_decrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length,
+                       const AES_KEY *key1, const AES_KEY *key2,
+                       const unsigned char iv[16]);
+
+void aesni_ccm64_encrypt_blocks(const unsigned char *in,
+                                unsigned char *out,
+                                size_t blocks,
+                                const void *key,
+                                const unsigned char ivec[16],
+                                unsigned char cmac[16]);
+
+void aesni_ccm64_decrypt_blocks(const unsigned char *in,
+                                unsigned char *out,
+                                size_t blocks,
+                                const void *key,
+                                const unsigned char ivec[16],
+                                unsigned char cmac[16]);
+
+#  if defined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)
+size_t aesni_gcm_encrypt(const unsigned char *in, unsigned char *out, size_t len,
+                         const void *key, unsigned char ivec[16], u64 *Xi);
+size_t aesni_gcm_decrypt(const unsigned char *in, unsigned char *out, size_t len,
+                         const void *key, unsigned char ivec[16], u64 *Xi);
+void gcm_ghash_avx(u64 Xi[2], const u128 Htable[16], const u8 *in, size_t len);
+
+#   define AES_GCM_ASM(ctx)    (ctx-&gt;ctr == aesni_ctr32_encrypt_blocks &amp;&amp; \
+                                ctx-&gt;gcm.ghash == gcm_ghash_avx)
+#  endif
+
+
+# elif defined(AES_ASM) &amp;&amp; (defined(__sparc) || defined(__sparc__))
+
+/* Fujitsu SPARC64 X support */
+extern unsigned int OPENSSL_sparcv9cap_P[];
+#  include &quot;sparc_arch.h&quot;
+#  define SPARC_AES_CAPABLE       (OPENSSL_sparcv9cap_P[1] &amp; CFR_AES)
+#  define HWAES_CAPABLE           (OPENSSL_sparcv9cap_P[0] &amp; SPARCV9_FJAESX)
+#  define HWAES_set_encrypt_key aes_fx_set_encrypt_key
+#  define HWAES_set_decrypt_key aes_fx_set_decrypt_key
+#  define HWAES_encrypt aes_fx_encrypt
+#  define HWAES_decrypt aes_fx_decrypt
+#  define HWAES_cbc_encrypt aes_fx_cbc_encrypt
+#  define HWAES_ctr32_encrypt_blocks aes_fx_ctr32_encrypt_blocks
+
+void aes_t4_set_encrypt_key(const unsigned char *key, int bits, AES_KEY *ks);
+void aes_t4_set_decrypt_key(const unsigned char *key, int bits, AES_KEY *ks);
+void aes_t4_encrypt(const unsigned char *in, unsigned char *out,
+                    const AES_KEY *key);
+void aes_t4_decrypt(const unsigned char *in, unsigned char *out,
+                    const AES_KEY *key);
+/*
+ * Key-length specific subroutines were chosen for following reason.
+ * Each SPARC T4 core can execute up to 8 threads which share core's
+ * resources. Loading as much key material to registers allows to
+ * minimize references to shared memory interface, as well as amount
+ * of instructions in inner loops [much needed on T4]. But then having
+ * non-key-length specific routines would require conditional branches
+ * either in inner loops or on subroutines' entries. Former is hardly
+ * acceptable, while latter means code size increase to size occupied
+ * by multiple key-length specific subroutines, so why fight?
+ */
+void aes128_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes128_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes192_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes192_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes256_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes256_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes128_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
+                             size_t blocks, const AES_KEY *key,
+                             unsigned char *ivec);
+void aes192_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
+                             size_t blocks, const AES_KEY *key,
+                             unsigned char *ivec);
+void aes256_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
+                             size_t blocks, const AES_KEY *key,
+                             unsigned char *ivec);
+void aes128_t4_xts_encrypt(const unsigned char *in, unsigned char *out,
+                           size_t blocks, const AES_KEY *key1,
+                           const AES_KEY *key2, const unsigned char *ivec);
+void aes128_t4_xts_decrypt(const unsigned char *in, unsigned char *out,
+                           size_t blocks, const AES_KEY *key1,
+                           const AES_KEY *key2, const unsigned char *ivec);
+void aes256_t4_xts_encrypt(const unsigned char *in, unsigned char *out,
+                           size_t blocks, const AES_KEY *key1,
+                           const AES_KEY *key2, const unsigned char *ivec);
+void aes256_t4_xts_decrypt(const unsigned char *in, unsigned char *out,
+                           size_t blocks, const AES_KEY *key1,
+                           const AES_KEY *key2, const unsigned char *ivec);
+
+# elif defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__)
+/* IBM S390X support */
+#  include &quot;s390x_arch.h&quot;
+
+
+/* Convert key size to function code: [16,24,32] -&gt; [18,19,20]. */
+#  define S390X_AES_FC(keylen)  (S390X_AES_128 + ((((keylen) &lt;&lt; 3) - 128) &gt;&gt; 6))
+
+/* Most modes of operation need km for partial block processing. */
+#  define S390X_aes_128_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;  \
+                                S390X_CAPBIT(S390X_AES_128))
+#  define S390X_aes_192_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;  \
+                                S390X_CAPBIT(S390X_AES_192))
+#  define S390X_aes_256_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;  \
+                                S390X_CAPBIT(S390X_AES_256))
+
+#  define S390X_aes_128_cbc_CAPABLE	1	/* checked by callee */
+#  define S390X_aes_192_cbc_CAPABLE	1
+#  define S390X_aes_256_cbc_CAPABLE	1
+
+#  define S390X_aes_128_ecb_CAPABLE	S390X_aes_128_CAPABLE
+#  define S390X_aes_192_ecb_CAPABLE	S390X_aes_192_CAPABLE
+#  define S390X_aes_256_ecb_CAPABLE	S390X_aes_256_CAPABLE
+
+#  define S390X_aes_128_ofb_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kmo[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_128)))
+#  define S390X_aes_192_ofb_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kmo[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_192)))
+#  define S390X_aes_256_ofb_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kmo[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_256)))
+
+#  define S390X_aes_128_cfb_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kmf[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_128)))
+#  define S390X_aes_192_cfb_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kmf[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_192)))
+#  define S390X_aes_256_cfb_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kmf[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_256)))
+#  define S390X_aes_128_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_128))
+#  define S390X_aes_192_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_192))
+#  define S390X_aes_256_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_256))
+#  define S390X_aes_128_cfb1_CAPABLE	0
+#  define S390X_aes_192_cfb1_CAPABLE	0
+#  define S390X_aes_256_cfb1_CAPABLE	0
+
+#  define S390X_aes_128_ctr_CAPABLE	1	/* checked by callee */
+#  define S390X_aes_192_ctr_CAPABLE	1
+#  define S390X_aes_256_ctr_CAPABLE	1
+
+#  define S390X_aes_128_xts_CAPABLE	1	/* checked by callee */
+#  define S390X_aes_256_xts_CAPABLE	1
+
+#  define S390X_aes_128_ccm_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kmac[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_128)))
+#  define S390X_aes_192_ccm_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kmac[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_192)))
+#  define S390X_aes_256_ccm_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kmac[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_256)))
+#  define S390X_CCM_AAD_FLAG	0x40
+
+#  ifndef OPENSSL_NO_OCB
+#   define S390X_aes_128_ocb_CAPABLE	0
+#   define S390X_aes_192_ocb_CAPABLE	0
+#   define S390X_aes_256_ocb_CAPABLE	0
+#  endif /* OPENSSL_NO_OCB */
+
+#  ifndef OPENSSL_NO_SIV
+#   define S390X_aes_128_siv_CAPABLE    0
+#   define S390X_aes_192_siv_CAPABLE    0
+#   define S390X_aes_256_siv_CAPABLE    0
+#  endif /* OPENSSL_NO_SIV */
+
+/* Convert key size to function code: [16,24,32] -&gt; [18,19,20]. */
+#  define S390X_AES_FC(keylen)  (S390X_AES_128 + ((((keylen) &lt;&lt; 3) - 128) &gt;&gt; 6))
+# endif
+
+# if defined(HWAES_CAPABLE)
+int HWAES_set_encrypt_key(const unsigned char *userKey, const int bits,
+                          AES_KEY *key);
+int HWAES_set_decrypt_key(const unsigned char *userKey, const int bits,
+                          AES_KEY *key);
+void HWAES_encrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+void HWAES_decrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+void HWAES_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                       size_t length, const AES_KEY *key,
+                       unsigned char *ivec, const int enc);
+void HWAES_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
+                                size_t len, const AES_KEY *key,
+                                const unsigned char ivec[16]);
+void HWAES_xts_encrypt(const unsigned char *inp, unsigned char *out,
+                       size_t len, const AES_KEY *key1,
+                       const AES_KEY *key2, const unsigned char iv[16]);
+void HWAES_xts_decrypt(const unsigned char *inp, unsigned char *out,
+                       size_t len, const AES_KEY *key1,
+                       const AES_KEY *key2, const unsigned char iv[16]);
+#  ifndef OPENSSL_NO_OCB
+#   ifdef HWAES_ocb_encrypt
+void HWAES_ocb_encrypt(const unsigned char *in, unsigned char *out,
+                       size_t blocks, const void *key,
+                       size_t start_block_num,
+                       unsigned char offset_i[16],
+                       const unsigned char L_[][16],
+                       unsigned char checksum[16]);
+#   else
+#     define HWAES_ocb_encrypt ((ocb128_f)NULL)
+#   endif
+#   ifdef HWAES_ocb_decrypt
+void HWAES_ocb_decrypt(const unsigned char *in, unsigned char *out,
+                       size_t blocks, const void *key,
+                       size_t start_block_num,
+                       unsigned char offset_i[16],
+                       const unsigned char L_[][16],
+                       unsigned char checksum[16]);
+#   else
+#     define HWAES_ocb_decrypt ((ocb128_f)NULL)
+#   endif
+#  endif /* OPENSSL_NO_OCB */
+
+# endif /* HWAES_CAPABLE */
+
+#endif /* HEADER_INTERNAL_AES_PLATFORM_H */
diff --git a/crypto/include/internal/modes_int.h b/crypto/include/internal/modes_int.h
index 8a8ef6e..5230f08 100644
--- a/crypto/include/internal/modes_int.h
+++ b/crypto/include/internal/modes_int.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2010-2019 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -7,28 +7,213 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
+/* TODO(3.0) Move this header into provider when dependencies are removed */
+#include &lt;openssl/modes.h&gt;
+
+#if (defined(_WIN32) || defined(_WIN64)) &amp;&amp; !defined(__MINGW32__)
+typedef __int64 i64;
+typedef unsigned __int64 u64;
+# define U64(C) C##UI64
+#elif defined(__arch64__)
+typedef long i64;
+typedef unsigned long u64;
+# define U64(C) C##UL
+#else
+typedef long long i64;
+typedef unsigned long long u64;
+# define U64(C) C##ULL
+#endif
+
+typedef unsigned int u32;
+typedef unsigned char u8;
+
+#define STRICT_ALIGNMENT 1
+#ifndef PEDANTIC
+# if defined(__i386)    || defined(__i386__)    || \
+     defined(__x86_64)  || defined(__x86_64__)  || \
+     defined(_M_IX86)   || defined(_M_AMD64)    || defined(_M_X64) || \
+     defined(__aarch64__)                       || \
+     defined(__s390__)  || defined(__s390x__)
+#  undef STRICT_ALIGNMENT
+# endif
+#endif
+
+#if !defined(PEDANTIC) &amp;&amp; !defined(OPENSSL_NO_ASM) &amp;&amp; !defined(OPENSSL_NO_INLINE_ASM)
+# if defined(__GNUC__) &amp;&amp; __GNUC__&gt;=2
+#  if defined(__x86_64) || defined(__x86_64__)
+#   define BSWAP8(x) ({ u64 ret_=(x);                   \
+                        asm (&quot;bswapq %0&quot;                \
+                        : &quot;+r&quot;(ret_));   ret_;          })
+#   define BSWAP4(x) ({ u32 ret_=(x);                   \
+                        asm (&quot;bswapl %0&quot;                \
+                        : &quot;+r&quot;(ret_));   ret_;          })
+#  elif (defined(__i386) || defined(__i386__)) &amp;&amp; !defined(I386_ONLY)
+#   define BSWAP8(x) ({ u32 lo_=(u64)(x)&gt;&gt;32,hi_=(x);   \
+                        asm (&quot;bswapl %0; bswapl %1&quot;     \
+                        : &quot;+r&quot;(hi_),&quot;+r&quot;(lo_));         \
+                        (u64)hi_&lt;&lt;32|lo_;               })
+#   define BSWAP4(x) ({ u32 ret_=(x);                   \
+                        asm (&quot;bswapl %0&quot;                \
+                        : &quot;+r&quot;(ret_));   ret_;          })
+#  elif defined(__aarch64__)
+#   define BSWAP8(x) ({ u64 ret_;                       \
+                        asm (&quot;rev %0,%1&quot;                \
+                        : &quot;=r&quot;(ret_) : &quot;r&quot;(x)); ret_;   })
+#   define BSWAP4(x) ({ u32 ret_;                       \
+                        asm (&quot;rev %w0,%w1&quot;              \
+                        : &quot;=r&quot;(ret_) : &quot;r&quot;(x)); ret_;   })
+#  elif (defined(__arm__) || defined(__arm)) &amp;&amp; !defined(STRICT_ALIGNMENT)
+#   define BSWAP8(x) ({ u32 lo_=(u64)(x)&gt;&gt;32,hi_=(x);   \
+                        asm (&quot;rev %0,%0; rev %1,%1&quot;     \
+                        : &quot;+r&quot;(hi_),&quot;+r&quot;(lo_));         \
+                        (u64)hi_&lt;&lt;32|lo_;               })
+#   define BSWAP4(x) ({ u32 ret_;                       \
+                        asm (&quot;rev %0,%1&quot;                \
+                        : &quot;=r&quot;(ret_) : &quot;r&quot;((u32)(x)));  \
+                        ret_;                           })
+#  endif
+# elif defined(_MSC_VER)
+#  if _MSC_VER&gt;=1300
+#   include &lt;stdlib.h&gt;
+#   pragma intrinsic(_byteswap_uint64,_byteswap_ulong)
+#   define BSWAP8(x)    _byteswap_uint64((u64)(x))
+#   define BSWAP4(x)    _byteswap_ulong((u32)(x))
+#  elif defined(_M_IX86)
+__inline u32 _bswap4(u32 val)
+{
+_asm mov eax, val _asm bswap eax}
+#   define BSWAP4(x)    _bswap4(x)
+#  endif
+# endif
+#endif
+#if defined(BSWAP4) &amp;&amp; !defined(STRICT_ALIGNMENT)
+# define GETU32(p)       BSWAP4(*(const u32 *)(p))
+# define PUTU32(p,v)     *(u32 *)(p) = BSWAP4(v)
+#else
+# define GETU32(p)       ((u32)(p)[0]&lt;&lt;24|(u32)(p)[1]&lt;&lt;16|(u32)(p)[2]&lt;&lt;8|(u32)(p)[3])
+# define PUTU32(p,v)     ((p)[0]=(u8)((v)&gt;&gt;24),(p)[1]=(u8)((v)&gt;&gt;16),(p)[2]=(u8)((v)&gt;&gt;8),(p)[3]=(u8)(v))
+#endif
+/*- GCM definitions */ typedef struct {
+    u64 hi, lo;
+} u128;
+
+#ifdef  TABLE_BITS
+# undef  TABLE_BITS
+#endif
+/*
+ * Even though permitted values for TABLE_BITS are 8, 4 and 1, it should
+ * never be set to 8 [or 1]. For further information see gcm128.c.
+ */
+#define TABLE_BITS 4
+
+struct gcm128_context {
+    /* Following 6 names follow names in GCM specification */
+    union {
+        u64 u[2];
+        u32 d[4];
+        u8 c[16];
+        size_t t[16 / sizeof(size_t)];
+    } Yi, EKi, EK0, len, Xi, H;
+    /*
+     * Relative position of Xi, H and pre-computed Htable is used in some
+     * assembler modules, i.e. don't change the order!
+     */
+#if TABLE_BITS==8
+    u128 Htable[256];
+#else
+    u128 Htable[16];
+    void (*gmult) (u64 Xi[2], const u128 Htable[16]);
+    void (*ghash) (u64 Xi[2], const u128 Htable[16], const u8 *inp,
+                   size_t len);
+#endif
+    unsigned int mres, ares;
+    block128_f block;
+    void *key;
+#if !defined(OPENSSL_SMALL_FOOTPRINT)
+    unsigned char Xn[48];
+#endif
+};
+
+/*
+ * The maximum permitted number of cipher blocks per data unit in XTS mode.
+ * Reference IEEE Std 1619-2018.
+ */
+#define XTS_MAX_BLOCKS_PER_DATA_UNIT            (1&lt;&lt;20)
+
+struct xts128_context {
+    void *key1, *key2;
+    block128_f block1, block2;
+};
+
+struct ccm128_context {
+    union {
+        u64 u[2];
+        u8 c[16];
+    } nonce, cmac;
+    u64 blocks;
+    block128_f block;
+    void *key;
+};
+
+#ifndef OPENSSL_NO_OCB
+
+typedef union {
+    u64 a[2];
+    unsigned char c[16];
+} OCB_BLOCK;
+# define ocb_block16_xor(in1,in2,out) \
+    ( (out)-&gt;a[0]=(in1)-&gt;a[0]^(in2)-&gt;a[0], \
+      (out)-&gt;a[1]=(in1)-&gt;a[1]^(in2)-&gt;a[1] )
+# if STRICT_ALIGNMENT
+#  define ocb_block16_xor_misaligned(in1,in2,out) \
+    ocb_block_xor((in1)-&gt;c,(in2)-&gt;c,16,(out)-&gt;c)
+# else
+#  define ocb_block16_xor_misaligned ocb_block16_xor
+# endif
+
+struct ocb128_context {
+    /* Need both encrypt and decrypt key schedules for decryption */
+    block128_f encrypt;
+    block128_f decrypt;
+    void *keyenc;
+    void *keydec;
+    ocb128_f stream;    /* direction dependent */
+    /* Key dependent variables. Can be reused if key remains the same */
+    size_t l_index;
+    size_t max_l_index;
+    OCB_BLOCK l_star;
+    OCB_BLOCK l_dollar;
+    OCB_BLOCK *l;
+    /* Must be reset for each session */
+    struct {
+        u64 blocks_hashed;
+        u64 blocks_processed;
+        OCB_BLOCK offset_aad;
+        OCB_BLOCK sum;
+        OCB_BLOCK offset;
+        OCB_BLOCK checksum;
+    } sess;
+};
+#endif                          /* OPENSSL_NO_OCB */
+
 #ifndef OPENSSL_NO_SIV
 
-typedef struct siv128_context SIV128_CONTEXT;
-
-SIV128_CONTEXT *CRYPTO_siv128_new(const unsigned char *key, int klen,
-                                  EVP_CIPHER* cbc, EVP_CIPHER* ctr);
-int CRYPTO_siv128_init(SIV128_CONTEXT *ctx, const unsigned char *key, int klen,
-                       const EVP_CIPHER* cbc, const EVP_CIPHER* ctr);
-int CRYPTO_siv128_copy_ctx(SIV128_CONTEXT *dest, SIV128_CONTEXT *src);
-int CRYPTO_siv128_aad(SIV128_CONTEXT *ctx, const unsigned char *aad,
-                      size_t len);
-int CRYPTO_siv128_encrypt(SIV128_CONTEXT *ctx,
-                          const unsigned char *in, unsigned char *out,
-                          size_t len);
-int CRYPTO_siv128_decrypt(SIV128_CONTEXT *ctx,
-                          const unsigned char *in, unsigned char *out,
-                          size_t len);
-int CRYPTO_siv128_finish(SIV128_CONTEXT *ctx);
-int CRYPTO_siv128_set_tag(SIV128_CONTEXT *ctx, const unsigned char *tag,
-                          size_t len);
-int CRYPTO_siv128_get_tag(SIV128_CONTEXT *ctx, unsigned char *tag, size_t len);
-int CRYPTO_siv128_cleanup(SIV128_CONTEXT *ctx);
-int CRYPTO_siv128_speed(SIV128_CONTEXT *ctx, int arg);
+#define SIV_LEN 16
+
+typedef union siv_block_u {
+    uint64_t word[SIV_LEN/sizeof(uint64_t)];
+    unsigned char byte[SIV_LEN];
+} SIV_BLOCK;
+
+struct siv128_context {
+    /* d stores intermediate results of S2V; it corresponds to D from the
+       pseudocode in section 2.4 of RFC 5297. */
+    SIV_BLOCK d;
+    SIV_BLOCK tag;
+    EVP_CIPHER_CTX *cipher_ctx;
+    EVP_MAC_CTX *mac_ctx_init;
+    int final_ret;
+    int crypto_ok;
+};
 
 #endif /* OPENSSL_NO_SIV */
diff --git a/crypto/include/internal/modes_int.h b/crypto/include/internal/siv_int.h
similarity index 100%
copy from crypto/include/internal/modes_int.h
copy to crypto/include/internal/siv_int.h
diff --git a/crypto/modes/cbc128.c b/crypto/modes/cbc128.c
index c510d96..eb8e06c 100644
--- a/crypto/modes/cbc128.c
+++ b/crypto/modes/cbc128.c
@@ -7,9 +7,9 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;openssl/crypto.h&gt;
-#include &quot;modes_lcl.h&quot;
 #include &lt;string.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/modes_int.h&quot;
 
 #if !defined(STRICT_ALIGNMENT) &amp;&amp; !defined(PEDANTIC)
 # define STRICT_ALIGNMENT 0
diff --git a/crypto/modes/ccm128.c b/crypto/modes/ccm128.c
index bfa2d46..e97158a 100644
--- a/crypto/modes/ccm128.c
+++ b/crypto/modes/ccm128.c
@@ -7,9 +7,9 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;openssl/crypto.h&gt;
-#include &quot;modes_lcl.h&quot;
 #include &lt;string.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/modes_int.h&quot;
 
 /*
  * First you setup M and L parameters and pass the key schedule. This is
diff --git a/crypto/modes/cfb128.c b/crypto/modes/cfb128.c
index 5352240..39644a2 100644
--- a/crypto/modes/cfb128.c
+++ b/crypto/modes/cfb128.c
@@ -7,9 +7,9 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;openssl/crypto.h&gt;
-#include &quot;modes_lcl.h&quot;
 #include &lt;string.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/modes_int.h&quot;
 
 /*
  * The input and output encrypted as though 128bit cfb mode is being used.
diff --git a/crypto/modes/ctr128.c b/crypto/modes/ctr128.c
index 177c955..1755b85 100644
--- a/crypto/modes/ctr128.c
+++ b/crypto/modes/ctr128.c
@@ -7,9 +7,9 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;openssl/crypto.h&gt;
-#include &quot;modes_lcl.h&quot;
 #include &lt;string.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/modes_int.h&quot;
 
 /*
  * NOTE: the IV/counter CTR mode is big-endian.  The code itself is
diff --git a/crypto/modes/cts128.c b/crypto/modes/cts128.c
index aca4ea8..b4f2f37 100644
--- a/crypto/modes/cts128.c
+++ b/crypto/modes/cts128.c
@@ -7,9 +7,9 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;openssl/crypto.h&gt;
-#include &quot;modes_lcl.h&quot;
 #include &lt;string.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/modes_int.h&quot;
 
 /*
  * Trouble with Ciphertext Stealing, CTS, mode is that there is no
diff --git a/crypto/modes/gcm128.c b/crypto/modes/gcm128.c
index b4d7215..371bf76 100644
--- a/crypto/modes/gcm128.c
+++ b/crypto/modes/gcm128.c
@@ -7,9 +7,9 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;openssl/crypto.h&gt;
-#include &quot;modes_lcl.h&quot;
 #include &lt;string.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/modes_int.h&quot;
 
 #if defined(BSWAP4) &amp;&amp; defined(STRICT_ALIGNMENT)
 /* redefine, because alignment is ensured */
diff --git a/crypto/modes/modes_lcl.h b/crypto/modes/modes_lcl.h
deleted file mode 100644
index d4ce462..0000000
--- a/crypto/modes/modes_lcl.h
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Copyright 2010-2018 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#include &lt;openssl/modes.h&gt;
-
-#if (defined(_WIN32) || defined(_WIN64)) &amp;&amp; !defined(__MINGW32__)
-typedef __int64 i64;
-typedef unsigned __int64 u64;
-# define U64(C) C##UI64
-#elif defined(__arch64__)
-typedef long i64;
-typedef unsigned long u64;
-# define U64(C) C##UL
-#else
-typedef long long i64;
-typedef unsigned long long u64;
-# define U64(C) C##ULL
-#endif
-
-typedef unsigned int u32;
-typedef unsigned char u8;
-
-#define STRICT_ALIGNMENT 1
-#ifndef PEDANTIC
-# if defined(__i386)    || defined(__i386__)    || \
-     defined(__x86_64)  || defined(__x86_64__)  || \
-     defined(_M_IX86)   || defined(_M_AMD64)    || defined(_M_X64) || \
-     defined(__aarch64__)                       || \
-     defined(__s390__)  || defined(__s390x__)
-#  undef STRICT_ALIGNMENT
-# endif
-#endif
-
-#if !defined(PEDANTIC) &amp;&amp; !defined(OPENSSL_NO_ASM) &amp;&amp; !defined(OPENSSL_NO_INLINE_ASM)
-# if defined(__GNUC__) &amp;&amp; __GNUC__&gt;=2
-#  if defined(__x86_64) || defined(__x86_64__)
-#   define BSWAP8(x) ({ u64 ret_=(x);                   \
-                        asm (&quot;bswapq %0&quot;                \
-                        : &quot;+r&quot;(ret_));   ret_;          })
-#   define BSWAP4(x) ({ u32 ret_=(x);                   \
-                        asm (&quot;bswapl %0&quot;                \
-                        : &quot;+r&quot;(ret_));   ret_;          })
-#  elif (defined(__i386) || defined(__i386__)) &amp;&amp; !defined(I386_ONLY)
-#   define BSWAP8(x) ({ u32 lo_=(u64)(x)&gt;&gt;32,hi_=(x);   \
-                        asm (&quot;bswapl %0; bswapl %1&quot;     \
-                        : &quot;+r&quot;(hi_),&quot;+r&quot;(lo_));         \
-                        (u64)hi_&lt;&lt;32|lo_;               })
-#   define BSWAP4(x) ({ u32 ret_=(x);                   \
-                        asm (&quot;bswapl %0&quot;                \
-                        : &quot;+r&quot;(ret_));   ret_;          })
-#  elif defined(__aarch64__)
-#   define BSWAP8(x) ({ u64 ret_;                       \
-                        asm (&quot;rev %0,%1&quot;                \
-                        : &quot;=r&quot;(ret_) : &quot;r&quot;(x)); ret_;   })
-#   define BSWAP4(x) ({ u32 ret_;                       \
-                        asm (&quot;rev %w0,%w1&quot;              \
-                        : &quot;=r&quot;(ret_) : &quot;r&quot;(x)); ret_;   })
-#  elif (defined(__arm__) || defined(__arm)) &amp;&amp; !defined(STRICT_ALIGNMENT)
-#   define BSWAP8(x) ({ u32 lo_=(u64)(x)&gt;&gt;32,hi_=(x);   \
-                        asm (&quot;rev %0,%0; rev %1,%1&quot;     \
-                        : &quot;+r&quot;(hi_),&quot;+r&quot;(lo_));         \
-                        (u64)hi_&lt;&lt;32|lo_;               })
-#   define BSWAP4(x) ({ u32 ret_;                       \
-                        asm (&quot;rev %0,%1&quot;                \
-                        : &quot;=r&quot;(ret_) : &quot;r&quot;((u32)(x)));  \
-                        ret_;                           })
-#  endif
-# elif defined(_MSC_VER)
-#  if _MSC_VER&gt;=1300
-#   include &lt;stdlib.h&gt;
-#   pragma intrinsic(_byteswap_uint64,_byteswap_ulong)
-#   define BSWAP8(x)    _byteswap_uint64((u64)(x))
-#   define BSWAP4(x)    _byteswap_ulong((u32)(x))
-#  elif defined(_M_IX86)
-__inline u32 _bswap4(u32 val)
-{
-_asm mov eax, val _asm bswap eax}
-#   define BSWAP4(x)    _bswap4(x)
-#  endif
-# endif
-#endif
-#if defined(BSWAP4) &amp;&amp; !defined(STRICT_ALIGNMENT)
-# define GETU32(p)       BSWAP4(*(const u32 *)(p))
-# define PUTU32(p,v)     *(u32 *)(p) = BSWAP4(v)
-#else
-# define GETU32(p)       ((u32)(p)[0]&lt;&lt;24|(u32)(p)[1]&lt;&lt;16|(u32)(p)[2]&lt;&lt;8|(u32)(p)[3])
-# define PUTU32(p,v)     ((p)[0]=(u8)((v)&gt;&gt;24),(p)[1]=(u8)((v)&gt;&gt;16),(p)[2]=(u8)((v)&gt;&gt;8),(p)[3]=(u8)(v))
-#endif
-/*- GCM definitions */ typedef struct {
-    u64 hi, lo;
-} u128;
-
-#ifdef  TABLE_BITS
-# undef  TABLE_BITS
-#endif
-/*
- * Even though permitted values for TABLE_BITS are 8, 4 and 1, it should
- * never be set to 8 [or 1]. For further information see gcm128.c.
- */
-#define TABLE_BITS 4
-
-struct gcm128_context {
-    /* Following 6 names follow names in GCM specification */
-    union {
-        u64 u[2];
-        u32 d[4];
-        u8 c[16];
-        size_t t[16 / sizeof(size_t)];
-    } Yi, EKi, EK0, len, Xi, H;
-    /*
-     * Relative position of Xi, H and pre-computed Htable is used in some
-     * assembler modules, i.e. don't change the order!
-     */
-#if TABLE_BITS==8
-    u128 Htable[256];
-#else
-    u128 Htable[16];
-    void (*gmult) (u64 Xi[2], const u128 Htable[16]);
-    void (*ghash) (u64 Xi[2], const u128 Htable[16], const u8 *inp,
-                   size_t len);
-#endif
-    unsigned int mres, ares;
-    block128_f block;
-    void *key;
-#if !defined(OPENSSL_SMALL_FOOTPRINT)
-    unsigned char Xn[48];
-#endif
-};
-
-/*
- * The maximum permitted number of cipher blocks per data unit in XTS mode.
- * Reference IEEE Std 1619-2018.
- */
-#define XTS_MAX_BLOCKS_PER_DATA_UNIT            (1&lt;&lt;20)
-
-struct xts128_context {
-    void *key1, *key2;
-    block128_f block1, block2;
-};
-
-struct ccm128_context {
-    union {
-        u64 u[2];
-        u8 c[16];
-    } nonce, cmac;
-    u64 blocks;
-    block128_f block;
-    void *key;
-};
-
-#ifndef OPENSSL_NO_OCB
-
-typedef union {
-    u64 a[2];
-    unsigned char c[16];
-} OCB_BLOCK;
-# define ocb_block16_xor(in1,in2,out) \
-    ( (out)-&gt;a[0]=(in1)-&gt;a[0]^(in2)-&gt;a[0], \
-      (out)-&gt;a[1]=(in1)-&gt;a[1]^(in2)-&gt;a[1] )
-# if STRICT_ALIGNMENT
-#  define ocb_block16_xor_misaligned(in1,in2,out) \
-    ocb_block_xor((in1)-&gt;c,(in2)-&gt;c,16,(out)-&gt;c)
-# else
-#  define ocb_block16_xor_misaligned ocb_block16_xor
-# endif
-
-struct ocb128_context {
-    /* Need both encrypt and decrypt key schedules for decryption */
-    block128_f encrypt;
-    block128_f decrypt;
-    void *keyenc;
-    void *keydec;
-    ocb128_f stream;    /* direction dependent */
-    /* Key dependent variables. Can be reused if key remains the same */
-    size_t l_index;
-    size_t max_l_index;
-    OCB_BLOCK l_star;
-    OCB_BLOCK l_dollar;
-    OCB_BLOCK *l;
-    /* Must be reset for each session */
-    struct {
-        u64 blocks_hashed;
-        u64 blocks_processed;
-        OCB_BLOCK offset_aad;
-        OCB_BLOCK sum;
-        OCB_BLOCK offset;
-        OCB_BLOCK checksum;
-    } sess;
-};
-#endif                          /* OPENSSL_NO_OCB */
-
-#ifndef OPENSSL_NO_SIV
-
-#include &lt;openssl/cmac.h&gt;
-
-#define SIV_LEN 16
-
-typedef union siv_block_u {
-    uint64_t word[SIV_LEN/sizeof(uint64_t)];
-    unsigned char byte[SIV_LEN];
-} SIV_BLOCK;
-
-struct siv128_context {
-    /* d stores intermediate results of S2V; it corresponds to D from the
-       pseudocode in section 2.4 of RFC 5297. */
-    SIV_BLOCK d;
-    SIV_BLOCK tag;
-    EVP_CIPHER_CTX *cipher_ctx;
-    EVP_MAC_CTX *mac_ctx_init;
-    int final_ret;
-    int crypto_ok;
-};
-
-#endif /* OPENSSL_NO_SIV */
diff --git a/crypto/modes/ocb128.c b/crypto/modes/ocb128.c
index 7511101..9e7af60 100644
--- a/crypto/modes/ocb128.c
+++ b/crypto/modes/ocb128.c
@@ -10,7 +10,7 @@
 #include &lt;string.h&gt;
 #include &lt;openssl/crypto.h&gt;
 #include &lt;openssl/err.h&gt;
-#include &quot;modes_lcl.h&quot;
+#include &quot;internal/modes_int.h&quot;
 
 #ifndef OPENSSL_NO_OCB
 
diff --git a/crypto/modes/ofb128.c b/crypto/modes/ofb128.c
index 96b15c7..b894cbb 100644
--- a/crypto/modes/ofb128.c
+++ b/crypto/modes/ofb128.c
@@ -7,9 +7,9 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;openssl/crypto.h&gt;
-#include &quot;modes_lcl.h&quot;
 #include &lt;string.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/modes_int.h&quot;
 
 /*
  * The input and output encrypted as though 128bit ofb mode is being used.
diff --git a/crypto/modes/siv128.c b/crypto/modes/siv128.c
index 4445cf3..359252f 100644
--- a/crypto/modes/siv128.c
+++ b/crypto/modes/siv128.c
@@ -10,8 +10,9 @@
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;openssl/crypto.h&gt;
+#include &lt;openssl/evp.h&gt;
 #include &quot;internal/modes_int.h&quot;
-#include &quot;modes_lcl.h&quot;
+#include &quot;internal/siv_int.h&quot;
 
 #ifndef OPENSSL_NO_SIV
 
diff --git a/crypto/modes/xts128.c b/crypto/modes/xts128.c
index 6c17fdc..03b83aa 100644
--- a/crypto/modes/xts128.c
+++ b/crypto/modes/xts128.c
@@ -7,9 +7,9 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;openssl/crypto.h&gt;
-#include &quot;modes_lcl.h&quot;
 #include &lt;string.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/modes_int.h&quot;
 
 int CRYPTO_xts128_encrypt(const XTS128_CONTEXT *ctx,
                           const unsigned char iv[16],
diff --git a/include/openssl/core_names.h b/include/openssl/core_names.h
index e4dd733..4addcea 100644
--- a/include/openssl/core_names.h
+++ b/include/openssl/core_names.h
@@ -35,16 +35,20 @@ extern &quot;C&quot; {
 #define OSSL_PROV_PARAM_BUILDINFO   &quot;buildinfo&quot;
 
 
-/* Well known cipher parameters */
-
-#define OSSL_CIPHER_PARAM_PADDING   &quot;padding&quot;
-#define OSSL_CIPHER_PARAM_MODE      &quot;mode&quot;
-#define OSSL_CIPHER_PARAM_BLOCK_SIZE &quot;blocksize&quot; /* OSSL_PARAM_INTEGER */
-#define OSSL_CIPHER_PARAM_FLAGS     &quot;flags&quot; /* OSSL_PARAM_UNSIGNED_INTEGER */
-#define OSSL_CIPHER_PARAM_KEYLEN    &quot;keylen&quot; /* OSSL_PARAM_INTEGER */
-#define OSSL_CIPHER_PARAM_IVLEN     &quot;ivlen&quot;  /* OSSL_PARAM_INTEGER */
-#define OSSL_CIPHER_PARAM_IV        &quot;iv&quot;  /* OSSL_PARAM_OCTET_PTR */
-#define OSSL_CIPHER_PARAM_NUM       &quot;num&quot; /* OSSL_PARAM_INTEGER */
+/* cipher parameters */
+#define OSSL_CIPHER_PARAM_PADDING   &quot;padding&quot;    /* int */
+#define OSSL_CIPHER_PARAM_MODE      &quot;mode&quot;       /* int */
+#define OSSL_CIPHER_PARAM_BLOCK_SIZE &quot;blocksize&quot; /* int */
+#define OSSL_CIPHER_PARAM_FLAGS     &quot;flags&quot;      /* ulong */
+#define OSSL_CIPHER_PARAM_KEYLEN    &quot;keylen&quot;     /* int */
+#define OSSL_CIPHER_PARAM_IVLEN     &quot;ivlen&quot;      /* int */
+#define OSSL_CIPHER_PARAM_IV        &quot;iv&quot;         /* octet_string OR octet_ptr */
+#define OSSL_CIPHER_PARAM_NUM       &quot;num&quot;        /* int */
+#define OSSL_CIPHER_PARAM_AEAD_TAG           &quot;tag&quot;        /* octet_string */
+#define OSSL_CIPHER_PARAM_AEAD_TLS1_AAD      &quot;tlsaad&quot;     /* octet_string */
+#define OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD  &quot;tlsaadpad&quot;  /* size_t */
+#define OSSL_CIPHER_PARAM_AEAD_TLS1_IV_FIXED &quot;tlsivfixed&quot; /* octet_string */
+#define OSSL_CIPHER_PARAM_AEAD_IVLEN         &quot;aeadivlen&quot;  /* size_t */
 
 /* digest parameters */
 #define OSSL_DIGEST_PARAM_XOFLEN    &quot;xoflen&quot;
diff --git a/include/openssl/core_numbers.h b/include/openssl/core_numbers.h
index 0542732..37a3170 100644
--- a/include/openssl/core_numbers.h
+++ b/include/openssl/core_numbers.h
@@ -181,6 +181,7 @@ OSSL_CORE_MAKE_FUNC(int, OP_digest_set_params,
                     (void *vctx, const OSSL_PARAM params[]))
 OSSL_CORE_MAKE_FUNC(int, OP_digest_get_params,
                     (void *vctx, OSSL_PARAM params[]))
+OSSL_CORE_MAKE_FUNC(unsigned long, OP_cipher_get_flags, (void))
 
 /* Symmetric Ciphers */
 
diff --git a/providers/common/ciphers/aes_basic.c b/providers/common/ciphers/aes_basic.c
index 619386c..a1ca5a9 100644
--- a/providers/common/ciphers/aes_basic.c
+++ b/providers/common/ciphers/aes_basic.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2001-2018 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2001-2019 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -13,102 +13,19 @@
 #include &lt;string.h&gt;
 #include &lt;assert.h&gt;
 #include &lt;openssl/aes.h&gt;
+#include &quot;internal/modes_int.h&quot;
 #include &quot;internal/evp_int.h&quot;
 #include &lt;openssl/rand.h&gt;
 #include &lt;openssl/cmac.h&gt;
 #include &quot;ciphers_locl.h&quot;
 #include &quot;internal/providercommonerr.h&quot;
+#include &quot;internal/aes_platform.h&quot;
 
 #define MAXBITCHUNK     ((size_t)1 &lt;&lt; (sizeof(size_t) * 8 - 4))
 
-#ifdef VPAES_ASM
-int vpaes_set_encrypt_key(const unsigned char *userKey, int bits,
-                          AES_KEY *key);
-int vpaes_set_decrypt_key(const unsigned char *userKey, int bits,
-                          AES_KEY *key);
-
-void vpaes_encrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-void vpaes_decrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-
-void vpaes_cbc_encrypt(const unsigned char *in,
-                       unsigned char *out,
-                       size_t length,
-                       const AES_KEY *key, unsigned char *ivec, int enc);
-#endif
-#ifdef BSAES_ASM
-void bsaes_cbc_encrypt(const unsigned char *in, unsigned char *out,
-                       size_t length, const AES_KEY *key,
-                       unsigned char ivec[16], int enc);
-void bsaes_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
-                                size_t len, const AES_KEY *key,
-                                const unsigned char ivec[16]);
-#endif
-#ifdef AES_CTR_ASM
-void AES_ctr32_encrypt(const unsigned char *in, unsigned char *out,
-                       size_t blocks, const AES_KEY *key,
-                       const unsigned char ivec[AES_BLOCK_SIZE]);
-#endif
-
-
-#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; (defined(__powerpc__) || defined(__ppc__) || defined(_ARCH_PPC))
-# include &quot;ppc_arch.h&quot;
-# ifdef VPAES_ASM
-#  define VPAES_CAPABLE (OPENSSL_ppccap_P &amp; PPC_ALTIVEC)
-# endif
-# define HWAES_CAPABLE  (OPENSSL_ppccap_P &amp; PPC_CRYPTO207)
-# define HWAES_set_encrypt_key aes_p8_set_encrypt_key
-# define HWAES_set_decrypt_key aes_p8_set_decrypt_key
-# define HWAES_encrypt aes_p8_encrypt
-# define HWAES_decrypt aes_p8_decrypt
-# define HWAES_cbc_encrypt aes_p8_cbc_encrypt
-# define HWAES_ctr32_encrypt_blocks aes_p8_ctr32_encrypt_blocks
-# define HWAES_xts_encrypt aes_p8_xts_encrypt
-# define HWAES_xts_decrypt aes_p8_xts_decrypt
-#endif
-
-#if     defined(AES_ASM) &amp;&amp; !defined(I386_ONLY) &amp;&amp;      (  \
-        ((defined(__i386)       || defined(__i386__)    || \
-          defined(_M_IX86)) &amp;&amp; defined(OPENSSL_IA32_SSE2))|| \
-        defined(__x86_64)       || defined(__x86_64__)  || \
-        defined(_M_AMD64)       || defined(_M_X64)      )
+#if defined(AESNI_CAPABLE)
 
-extern unsigned int OPENSSL_ia32cap_P[];
-
-# ifdef VPAES_ASM
-#  define VPAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
-# endif
-# ifdef BSAES_ASM
-#  define BSAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
-# endif
-/*
- * AES-NI section
- */
-# define AESNI_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(57-32)))
-
-int aesni_set_encrypt_key(const unsigned char *userKey, int bits,
-                          AES_KEY *key);
-int aesni_set_decrypt_key(const unsigned char *userKey, int bits,
-                          AES_KEY *key);
-
-void aesni_encrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-void aesni_decrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-
-void aesni_ecb_encrypt(const unsigned char *in,
-                       unsigned char *out,
-                       size_t length, const AES_KEY *key, int enc);
-void aesni_cbc_encrypt(const unsigned char *in,
-                       unsigned char *out,
-                       size_t length,
-                       const AES_KEY *key, unsigned char *ivec, int enc);
-
-void aesni_ctr32_encrypt_blocks(const unsigned char *in,
-                                unsigned char *out,
-                                size_t blocks,
-                                const void *key, const unsigned char *ivec);
+/* AES-NI section. */
 
 static int aesni_init_key(PROV_AES_KEY *dat, const unsigned char *key,
                           size_t keylen)
@@ -190,69 +107,7 @@ const PROV_AES_CIPHER *PROV_AES_CIPHER_##mode(size_t keylen) \
 { return AESNI_CAPABLE?&amp;aesni_##mode:&amp;aes_##mode; }
 
 
-#elif   defined(AES_ASM) &amp;&amp; (defined(__sparc) || defined(__sparc__))
-
-# include &quot;sparc_arch.h&quot;
-
-extern unsigned int OPENSSL_sparcv9cap_P[];
-
-/*
- * Fujitsu SPARC64 X support
- */
-# define HWAES_CAPABLE           (OPENSSL_sparcv9cap_P[0] &amp; SPARCV9_FJAESX)
-# define HWAES_set_encrypt_key aes_fx_set_encrypt_key
-# define HWAES_set_decrypt_key aes_fx_set_decrypt_key
-# define HWAES_encrypt aes_fx_encrypt
-# define HWAES_decrypt aes_fx_decrypt
-# define HWAES_cbc_encrypt aes_fx_cbc_encrypt
-# define HWAES_ctr32_encrypt_blocks aes_fx_ctr32_encrypt_blocks
-
-# define SPARC_AES_CAPABLE       (OPENSSL_sparcv9cap_P[1] &amp; CFR_AES)
-
-void aes_t4_set_encrypt_key(const unsigned char *key, int bits, AES_KEY *ks);
-void aes_t4_set_decrypt_key(const unsigned char *key, int bits, AES_KEY *ks);
-void aes_t4_encrypt(const unsigned char *in, unsigned char *out,
-                    const AES_KEY *key);
-void aes_t4_decrypt(const unsigned char *in, unsigned char *out,
-                    const AES_KEY *key);
-/*
- * Key-length specific subroutines were chosen for following reason.
- * Each SPARC T4 core can execute up to 8 threads which share core's
- * resources. Loading as much key material to registers allows to
- * minimize references to shared memory interface, as well as amount
- * of instructions in inner loops [much needed on T4]. But then having
- * non-key-length specific routines would require conditional branches
- * either in inner loops or on subroutines' entries. Former is hardly
- * acceptable, while latter means code size increase to size occupied
- * by multiple key-length specific subroutines, so why fight?
- */
-void aes128_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes128_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes192_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes192_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes256_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes256_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
-                           size_t len, const AES_KEY *key,
-                           unsigned char *ivec);
-void aes128_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
-                             size_t blocks, const AES_KEY *key,
-                             unsigned char *ivec);
-void aes192_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
-                             size_t blocks, const AES_KEY *key,
-                             unsigned char *ivec);
-void aes256_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
-                             size_t blocks, const AES_KEY *key,
-                             unsigned char *ivec);
+#elif defined(SPARC_AES_CAPABLE)
 
 static int aes_t4_init_key(PROV_AES_KEY *dat, const unsigned char *key,
                            size_t keylen)
@@ -362,30 +217,15 @@ const PROV_AES_CIPHER *PROV_AES_CIPHER_##mode(size_t keylen) \
 { return SPARC_AES_CAPABLE?&amp;aes_t4_##mode:&amp;aes_##mode; }
 
 
-#elif defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__)
+#elif defined(S390X_aes_128_CAPABLE)
 /*
  * IBM S390X support
  */
 # include &quot;s390x_arch.h&quot;
 
-/* Convert key size to function code: [16,24,32] -&gt; [18,19,20]. */
-# define S390X_AES_FC(keylen)  (S390X_AES_128 + ((((keylen) &lt;&lt; 3) - 128) &gt;&gt; 6))
-
-/* Most modes of operation need km for partial block processing. */
-# define S390X_aes_128_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;	\
-                                S390X_CAPBIT(S390X_AES_128))
-# define S390X_aes_192_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;	\
-                                S390X_CAPBIT(S390X_AES_192))
-# define S390X_aes_256_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;	\
-                                S390X_CAPBIT(S390X_AES_256))
-
 # define s390x_aes_init_key aes_init_key
 static int s390x_aes_init_key(PROV_AES_KEY *dat, const unsigned char *key,
                               size_t keylen);
-
-# define S390X_aes_128_cbc_CAPABLE  1	/* checked by callee */
-# define S390X_aes_192_cbc_CAPABLE  1
-# define S390X_aes_256_cbc_CAPABLE  1
 # define S390X_AES_CBC_CTX          PROV_AES_KEY
 
 # define s390x_aes_cbc_init_key aes_init_key
@@ -394,10 +234,6 @@ static int s390x_aes_init_key(PROV_AES_KEY *dat, const unsigned char *key,
 static int s390x_aes_cbc_cipher(PROV_AES_KEY *dat, unsigned char *out,
                                 const unsigned char *in, size_t len);
 
-# define S390X_aes_128_ecb_CAPABLE  S390X_aes_128_CAPABLE
-# define S390X_aes_192_ecb_CAPABLE  S390X_aes_192_CAPABLE
-# define S390X_aes_256_ecb_CAPABLE  S390X_aes_256_CAPABLE
-
 static int s390x_aes_ecb_init_key(PROV_AES_KEY *dat, const unsigned char *key,
                                   size_t keylen)
 {
@@ -417,16 +253,6 @@ static int s390x_aes_ecb_cipher(PROV_AES_KEY *dat, unsigned char *out,
     return 1;
 }
 
-# define S390X_aes_128_ofb_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;        \
-                                    (OPENSSL_s390xcap_P.kmo[0] &amp;    \
-                                     S390X_CAPBIT(S390X_AES_128)))
-# define S390X_aes_192_ofb_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;        \
-                                    (OPENSSL_s390xcap_P.kmo[0] &amp;    \
-                                     S390X_CAPBIT(S390X_AES_192)))
-# define S390X_aes_256_ofb_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;        \
-                                    (OPENSSL_s390xcap_P.kmo[0] &amp;    \
-                                     S390X_CAPBIT(S390X_AES_256)))
-
 static int s390x_aes_ofb_init_key(PROV_AES_KEY *dat, const unsigned char *key,
                                   size_t keylen)
 {
@@ -477,16 +303,6 @@ static int s390x_aes_ofb_cipher(PROV_AES_KEY *dat, unsigned char *out,
     return 1;
 }
 
-# define S390X_aes_128_cfb_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;        \
-                                    (OPENSSL_s390xcap_P.kmf[0] &amp;    \
-                                     S390X_CAPBIT(S390X_AES_128)))
-# define S390X_aes_192_cfb_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;        \
-                                    (OPENSSL_s390xcap_P.kmf[0] &amp;    \
-                                     S390X_CAPBIT(S390X_AES_192)))
-# define S390X_aes_256_cfb_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;        \
-                                    (OPENSSL_s390xcap_P.kmf[0] &amp;    \
-                                     S390X_CAPBIT(S390X_AES_256)))
-
 static int s390x_aes_cfb_init_key(PROV_AES_KEY *dat, const unsigned char *key,
                                   size_t keylen)
 {
@@ -546,13 +362,6 @@ static int s390x_aes_cfb_cipher(PROV_AES_KEY *dat, unsigned char *out,
     return 1;
 }
 
-# define S390X_aes_128_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;    \
-                                     S390X_CAPBIT(S390X_AES_128))
-# define S390X_aes_192_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;    \
-                                     S390X_CAPBIT(S390X_AES_192))
-# define S390X_aes_256_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;    \
-                                     S390X_CAPBIT(S390X_AES_256))
-
 static int s390x_aes_cfb8_init_key(PROV_AES_KEY *dat, const unsigned char *key,
                                   size_t keylen)
 {
@@ -574,19 +383,11 @@ static int s390x_aes_cfb8_cipher(PROV_AES_KEY *dat, unsigned char *out,
     return 1;
 }
 
-# define S390X_aes_128_cfb1_CAPABLE 0
-# define S390X_aes_192_cfb1_CAPABLE 0
-# define S390X_aes_256_cfb1_CAPABLE 0
-
 # define s390x_aes_cfb1_init_key aes_init_key
 
 # define s390x_aes_cfb1_cipher aes_cfb1_cipher
 static int s390x_aes_cfb1_cipher(PROV_AES_KEY *dat, unsigned char *out,
                                  const unsigned char *in, size_t len);
-
-# define S390X_aes_128_ctr_CAPABLE  1	/* checked by callee */
-# define S390X_aes_192_ctr_CAPABLE  1
-# define S390X_aes_256_ctr_CAPABLE  1
 # define S390X_AES_CTR_CTX          PROV_AES_KEY
 
 # define s390x_aes_ctr_init_key aes_init_key
@@ -615,7 +416,7 @@ const PROV_AES_CIPHER *PROV_AES_CIPHER_##mode(size_t keylen) \
 }
 
 #else
-
+/* The generic case */
 # define BLOCK_CIPHER_generic_prov(mode) \
 static const PROV_AES_CIPHER aes_##mode = { \
         aes_init_key,                   \
@@ -625,42 +426,6 @@ const PROV_AES_CIPHER *PROV_AES_CIPHER_##mode(size_t keylen) \
 
 #endif
 
-#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; (defined(__arm__) || defined(__arm) || defined(__aarch64__))
-# include &quot;arm_arch.h&quot;
-# if __ARM_MAX_ARCH__&gt;=7
-#  if defined(BSAES_ASM)
-#   define BSAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
-#  endif
-#  if defined(VPAES_ASM)
-#   define VPAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
-#  endif
-#  define HWAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV8_AES)
-#  define HWAES_set_encrypt_key aes_v8_set_encrypt_key
-#  define HWAES_set_decrypt_key aes_v8_set_decrypt_key
-#  define HWAES_encrypt aes_v8_encrypt
-#  define HWAES_decrypt aes_v8_decrypt
-#  define HWAES_cbc_encrypt aes_v8_cbc_encrypt
-#  define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks
-# endif
-#endif
-
-#if defined(HWAES_CAPABLE)
-int HWAES_set_encrypt_key(const unsigned char *userKey, const int bits,
-                          AES_KEY *key);
-int HWAES_set_decrypt_key(const unsigned char *userKey, const int bits,
-                          AES_KEY *key);
-void HWAES_encrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-void HWAES_decrypt(const unsigned char *in, unsigned char *out,
-                   const AES_KEY *key);
-void HWAES_cbc_encrypt(const unsigned char *in, unsigned char *out,
-                       size_t length, const AES_KEY *key,
-                       unsigned char *ivec, const int enc);
-void HWAES_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
-                                size_t len, const AES_KEY *key,
-                                const unsigned char ivec[16]);
-#endif
-
 static int aes_init_key(PROV_AES_KEY *dat, const unsigned char *key,
                         size_t keylen)
 {
diff --git a/test/build.info b/test/build.info
index e38f142..6966149 100644
--- a/test/build.info
+++ b/test/build.info
@@ -504,7 +504,7 @@ IF[{- !$disabled{tests} -}]
     DEPEND[asn1_internal_test]=../libcrypto.a libtestutil.a
 
     SOURCE[modes_internal_test]=modes_internal_test.c
-    INCLUDE[modes_internal_test]=.. ../include ../apps/include
+    INCLUDE[modes_internal_test]=.. ../include ../apps/include ../crypto/include
     DEPEND[modes_internal_test]=../libcrypto.a libtestutil.a
 
     SOURCE[x509_internal_test]=x509_internal_test.c
diff --git a/test/modes_internal_test.c b/test/modes_internal_test.c
index 656dfab..02e5c8d 100644
--- a/test/modes_internal_test.c
+++ b/test/modes_internal_test.c
@@ -14,8 +14,8 @@
 
 #include &lt;openssl/aes.h&gt;
 #include &lt;openssl/modes.h&gt;
-#include &quot;../crypto/modes/modes_lcl.h&quot;
 #include &quot;testutil.h&quot;
+#include &quot;internal/modes_int.h&quot;
 #include &quot;internal/nelem.h&quot;
 
 typedef struct {
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023956.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="023963.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23960">[ date ]</a>
              <a href="thread.html#23960">[ thread ]</a>
              <a href="subject.html#23960">[ subject ]</a>
              <a href="author.html#23960">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
