<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-July/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1564574286.570580.4590.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024222.html">
   <LINK REL="Next"  HREF="024228.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>shane.lontis at oracle.com</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1564574286.570580.4590.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">shane.lontis at oracle.com
       </A><BR>
    <I>Wed Jul 31 11:58:06 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="024222.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="024228.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24225">[ date ]</a>
              <a href="thread.html#24225">[ thread ]</a>
              <a href="subject.html#24225">[ subject ]</a>
              <a href="author.html#24225">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  a672a02a6443a29aa368c0d8abeebc809c1a9f28 (commit)
      from  f5b7f99e690b1875e6d047acc435f0029642bfeb (commit)


- Log -----------------------------------------------------------------
commit a672a02a6443a29aa368c0d8abeebc809c1a9f28
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Wed Jul 31 21:55:16 2019 +1000

    Add gcm ciphers (aes and aria) to providers.
    
    The code has been modularized so that it can be shared by algorithms.
    
    A fixed size IV is now used instead of being allocated.
    The IV is not set into the low level struct now until the update (it uses an
    iv_state for this purpose).
    
    Hardware specific methods have been added to a PROV_GCM_HW object.
    
    The S390 code has been changed to just contain methods that can be accessed in
    a modular way. There are equivalent generic methods also for the other
    platforms.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    Reviewed-by: Patrick Steuer &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">patrick.steuer at de.ibm.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9231">https://github.com/openssl/openssl/pull/9231</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/err/openssl.txt                             |   3 +
 crypto/evp/evp_enc.c                               |   8 +-
 crypto/evp/evp_lib.c                               |   8 +-
 crypto/modes/build.info                            |   4 +-
 doc/man3/EVP_EncryptInit.pod                       |   2 +
 providers/common/ciphers/aes.c                     | 107 ++--
 providers/common/ciphers/aes_basic.c               |   8 +-
 providers/common/ciphers/build.info                |   8 +-
 providers/common/ciphers/ciphers_gcm.h             | 120 +++++
 providers/common/ciphers/ciphers_locl.h            |  43 +-
 providers/common/ciphers/gcm.c                     | 580 +++++++++++++++++++++
 providers/common/ciphers/gcm_hw.c                  | 307 +++++++++++
 providers/common/ciphers/gcm_s390x.c               | 303 +++++++++++
 providers/common/include/internal/provider_algs.h  |   8 +
 .../common/include/internal/providercommonerr.h    |   3 +
 providers/common/provider_err.c                    |   3 +
 providers/default/defltprov.c                      |   8 +
 providers/fips/fipsprov.c                          |   3 +
 18 files changed, 1467 insertions(+), 59 deletions(-)
 create mode 100644 providers/common/ciphers/ciphers_gcm.h
 create mode 100644 providers/common/ciphers/gcm.c
 create mode 100644 providers/common/ciphers/gcm_hw.c
 create mode 100644 providers/common/ciphers/gcm_s390x.c

diff --git a/crypto/err/openssl.txt b/crypto/err/openssl.txt
index 6b52193895..caa47324bf 100644
--- a/crypto/err/openssl.txt
+++ b/crypto/err/openssl.txt
@@ -2694,7 +2694,10 @@ PROV_R_BAD_DECRYPT:100:bad decrypt
 PROV_R_CIPHER_OPERATION_FAILED:102:cipher operation failed
 PROV_R_FAILED_TO_GET_PARAMETER:103:failed to get parameter
 PROV_R_FAILED_TO_SET_PARAMETER:104:failed to set parameter
+PROV_R_INVALID_AAD:108:invalid aad
+PROV_R_INVALID_IVLEN:109:invalid ivlen
 PROV_R_INVALID_KEYLEN:105:invalid keylen
+PROV_R_INVALID_TAG:110:invalid tag
 PROV_R_OUTPUT_BUFFER_TOO_SMALL:106:output buffer too small
 PROV_R_WRONG_FINAL_BLOCK_LENGTH:107:wrong final block length
 RAND_R_ADDITIONAL_INPUT_TOO_LONG:102:additional input too long
diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
index 8f5175b525..87c7bb0995 100644
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2018 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -163,6 +163,12 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
         case NID_aes_256_ctr:
         case NID_aes_192_ctr:
         case NID_aes_128_ctr:
+        case NID_aes_256_gcm:
+        case NID_aes_192_gcm:
+        case NID_aes_128_gcm:
+        case NID_aria_256_gcm:
+        case NID_aria_192_gcm:
+        case NID_aria_128_gcm:
             break;
         default:
             goto legacy;
diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
index e6daf684be..d112eaf65a 100644
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -315,7 +315,13 @@ int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher)
 
 int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx)
 {
-    return EVP_CIPHER_iv_length(ctx-&gt;cipher);
+    int ok, v = EVP_CIPHER_iv_length(ctx-&gt;cipher);
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
+
+    params[0] = OSSL_PARAM_construct_int(OSSL_CIPHER_PARAM_IVLEN, &amp;v);
+    ok = evp_do_ciph_ctx_getparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+
+    return ok != 0 ? v : -1;
 }
 
 const unsigned char *EVP_CIPHER_CTX_original_iv(const EVP_CIPHER_CTX *ctx)
diff --git a/crypto/modes/build.info b/crypto/modes/build.info
index 81525a9916..a93586690c 100644
--- a/crypto/modes/build.info
+++ b/crypto/modes/build.info
@@ -48,9 +48,9 @@ IF[{- !$disabled{asm} -}]
   ENDIF
 ENDIF
 
-$COMMON=cbc128.c ctr128.c cfb128.c ofb128.c $MODESASM
+$COMMON=cbc128.c ctr128.c cfb128.c ofb128.c gcm128.c $MODESASM
 SOURCE[../../libcrypto]=$COMMON \
-        cts128.c gcm128.c ccm128.c xts128.c wrap128.c ocb128.c siv128.c
+        cts128.c ccm128.c xts128.c wrap128.c ocb128.c siv128.c
 DEFINE[../../libcrypto]=$MODESDEF
 SOURCE[../../providers/fips]=$COMMON
 DEFINE[../../providers/fips]=$MODESDEF
diff --git a/doc/man3/EVP_EncryptInit.pod b/doc/man3/EVP_EncryptInit.pod
index 083bba7996..e46d401746 100644
--- a/doc/man3/EVP_EncryptInit.pod
+++ b/doc/man3/EVP_EncryptInit.pod
@@ -165,6 +165,8 @@ all parameters to NULL except B&lt;type&gt; in an initial call and supply
 the remaining parameters in subsequent calls, all of which have B&lt;type&gt;
 set to NULL. This is done when the default cipher parameters are not
 appropriate.
+For EVP_CIPH_GCM_MODE the IV will be generated internally if it is not
+specified.
 
 EVP_EncryptUpdate() encrypts B&lt;inl&gt; bytes from the buffer B&lt;in&gt; and
 writes the encrypted version to B&lt;out&gt;. This function can be called
diff --git a/providers/common/ciphers/aes.c b/providers/common/ciphers/aes.c
index a151a8b393..a211694a88 100644
--- a/providers/common/ciphers/aes.c
+++ b/providers/common/ciphers/aes.c
@@ -13,6 +13,7 @@
 #include &lt;openssl/core_names.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/params.h&gt;
+#include &lt;openssl/rand.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;internal/provider_algs.h&quot;
 #include &quot;ciphers_locl.h&quot;
@@ -248,50 +249,63 @@ static int aes_cipher(void *vctx,
     return 1;
 }
 
-#define IMPLEMENT_cipher(lcmode, UCMODE, flags, kbits, blkbits, ivbits) \
-    static OSSL_OP_cipher_get_params_fn aes_##kbits##_##lcmode##_get_params; \
-    static int aes_##kbits##_##lcmode##_get_params(OSSL_PARAM params[]) \
-    { \
-        OSSL_PARAM *p; \
-                                                                \
-        p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_MODE);          \
-        if (p != NULL) {                                                \
-            if (!OSSL_PARAM_set_int(p, EVP_CIPH_##UCMODE##_MODE))           \
-                return 0;                                               \
-        }                                                           \
-        p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_FLAGS); \
-        if (p != NULL) {                                                \
-            if (!OSSL_PARAM_set_ulong(p, (flags)))                          \
-                return 0;                                               \
-        }                                                           \
-        p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_KEYLEN);        \
-        if (p != NULL) {                                                \
-            if (!OSSL_PARAM_set_int(p, (kbits) / 8))                         \
-                return 0;                                               \
-        }                                                           \
-        p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_BLOCK_SIZE);    \
-        if (p != NULL) {                                                \
-            if (!OSSL_PARAM_set_int(p, (blkbits) / 8))                   \
-                return 0;                                               \
-        }                                                               \
-        p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_IVLEN);         \
-        if (p != NULL) {                                                \
-            if (!OSSL_PARAM_set_int(p, (ivbits) / 8))                    \
-                return 0;                                               \
-        }                                                               \
-    \
-        return 1; \
-    } \
-    static OSSL_OP_cipher_newctx_fn aes_##kbits##_##lcmode##_newctx; \
-    static void *aes_##kbits##_##lcmode##_newctx(void *provctx) \
-    { \
-        PROV_AES_KEY *ctx = OPENSSL_zalloc(sizeof(*ctx)); \
-    \
-        ctx-&gt;pad = 1; \
-        ctx-&gt;keylen = ((kbits) / 8);                        \
-        ctx-&gt;ciph = PROV_AES_CIPHER_##lcmode(ctx-&gt;keylen); \
-        ctx-&gt;mode = EVP_CIPH_##UCMODE##_MODE; \
-        return ctx; \
+static void *aes_new_ctx(void *provctx, size_t mode, size_t kbits,
+                         const PROV_AES_CIPHER *ciph)
+{
+    PROV_AES_KEY *ctx = OPENSSL_zalloc(sizeof(*ctx));
+
+    ctx-&gt;pad = 1;
+    ctx-&gt;keylen = kbits / 8;
+    ctx-&gt;ciph = ciph;
+    ctx-&gt;mode = mode;
+    return ctx;
+}
+
+int aes_get_params(OSSL_PARAM params[], int md, unsigned long flags,
+                   int kbits, int blkbits, int ivbits)
+{
+    OSSL_PARAM *p;
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_MODE);
+    if (p != NULL) {
+        if (!OSSL_PARAM_set_int(p, md))
+            return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_FLAGS);
+    if (p != NULL) {
+        if (!OSSL_PARAM_set_ulong(p, flags))
+            return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_KEYLEN);
+    if (p != NULL) {
+        if (!OSSL_PARAM_set_int(p, kbits / 8))
+            return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_BLOCK_SIZE);
+    if (p != NULL) {
+        if (!OSSL_PARAM_set_int(p, blkbits / 8))
+            return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_IVLEN);
+    if (p != NULL) {
+        if (!OSSL_PARAM_set_int(p, ivbits / 8))
+            return 0;
+    }
+    return 1;
+}
+
+#define IMPLEMENT_cipher(lcmode, UCMODE, flags, kbits, blkbits, ivbits)        \
+    static OSSL_OP_cipher_get_params_fn aes_##kbits##_##lcmode##_get_params;   \
+    static int aes_##kbits##_##lcmode##_get_params(OSSL_PARAM params[])        \
+    {                                                                          \
+        return aes_get_params(params, EVP_CIPH_##UCMODE##_MODE, flags, kbits,  \
+                              blkbits, ivbits);                                \
+    }                                                                          \
+    static OSSL_OP_cipher_newctx_fn aes_##kbits##_##lcmode##_newctx;           \
+    static void *aes_##kbits##_##lcmode##_newctx(void *provctx)                \
+    {                                                                          \
+        return aes_new_ctx(provctx, EVP_CIPH_##UCMODE##_MODE, kbits,           \
+                           PROV_AES_CIPHER_##lcmode(kbits / 8));               \
     }
 
 /* ECB */
@@ -351,6 +365,11 @@ static int aes_ctx_get_params(void *vctx, OSSL_PARAM params[])
     PROV_AES_KEY *ctx = (PROV_AES_KEY *)vctx;
     OSSL_PARAM *p;
 
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_IVLEN);
+    if (p != NULL) {
+        if (!OSSL_PARAM_set_int(p, AES_BLOCK_SIZE))
+            return 0;
+    }
     p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_PADDING);
     if (p != NULL &amp;&amp; !OSSL_PARAM_set_int(p, ctx-&gt;pad)) {
         PROVerr(PROV_F_AES_CTX_GET_PARAMS, PROV_R_FAILED_TO_SET_PARAMETER);
diff --git a/providers/common/ciphers/aes_basic.c b/providers/common/ciphers/aes_basic.c
index a1ca5a9be2..f2ba2f3c24 100644
--- a/providers/common/ciphers/aes_basic.c
+++ b/providers/common/ciphers/aes_basic.c
@@ -6,18 +6,16 @@
  * in the file LICENSE in the source distribution or at
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
-
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
 #include &lt;openssl/opensslconf.h&gt;
 #include &lt;openssl/crypto.h&gt;
 #include &lt;openssl/err.h&gt;
-#include &lt;string.h&gt;
-#include &lt;assert.h&gt;
 #include &lt;openssl/aes.h&gt;
-#include &quot;internal/modes_int.h&quot;
-#include &quot;internal/evp_int.h&quot;
 #include &lt;openssl/rand.h&gt;
 #include &lt;openssl/cmac.h&gt;
 #include &quot;ciphers_locl.h&quot;
+#include &quot;internal/evp_int.h&quot;
 #include &quot;internal/providercommonerr.h&quot;
 #include &quot;internal/aes_platform.h&quot;
 
diff --git a/providers/common/ciphers/build.info b/providers/common/ciphers/build.info
index fd49ccb994..8916a22469 100644
--- a/providers/common/ciphers/build.info
+++ b/providers/common/ciphers/build.info
@@ -1,8 +1,8 @@
 LIBS=../../../libcrypto
-SOURCE[../../../libcrypto]=\
-        block.c aes.c aes_basic.c
+$COMMON=block.c aes.c aes_basic.c gcm.c gcm_hw.c
+
+SOURCE[../../../libcrypto]=$COMMON
 INCLUDE[../../../libcrypto]=. ../../../crypto
 
-SOURCE[../../fips]=\
-        block.c aes.c aes_basic.c
+SOURCE[../../fips]=$COMMON
 INCLUDE[../../fips]=. ../../../crypto
diff --git a/providers/common/ciphers/ciphers_gcm.h b/providers/common/ciphers/ciphers_gcm.h
new file mode 100644
index 0000000000..badab28aea
--- /dev/null
+++ b/providers/common/ciphers/ciphers_gcm.h
@@ -0,0 +1,120 @@
+
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/aes.h&gt;
+
+typedef struct prov_gcm_hw_st PROV_GCM_HW;
+
+#define GCM_IV_DEFAULT_SIZE 12/* IV's for AES_GCM should normally be 12 bytes */
+#define GCM_IV_MAX_SIZE     64
+#define GCM_TAG_MAX_SIZE    16
+
+typedef struct prov_gcm_ctx_st {
+    int enc;                /* Set to 1 if we are encrypting or 0 otherwise */
+    int mode;               /* The mode that we are using */
+    size_t keylen;
+    int ivlen;
+    size_t ivlen_min;
+    int taglen;
+    int key_set;            /* Set if key initialised */
+    int iv_state;           /* set to one of IV_STATE_XXX */
+    int iv_gen_rand;        /* No IV was specified, so generate a rand IV */
+    int iv_gen;             /* It is OK to generate IVs */
+    int tls_aad_pad_sz;
+    int tls_aad_len;        /* TLS AAD length */
+    uint64_t tls_enc_records;   /* Number of TLS records encrypted */
+
+    /*
+     * num contains the number of bytes of |iv| which are valid for modes that
+     * manage partial blocks themselves.
+     */
+    size_t num;
+    size_t bufsz;           /* Number of bytes in buf */
+    uint64_t flags;
+
+    unsigned int pad : 1;   /* Whether padding should be used or not */
+
+    unsigned char iv[GCM_IV_MAX_SIZE]; /* Buffer to use for IV's */
+    unsigned char buf[AES_BLOCK_SIZE];     /* Buffer of partial blocks processed via update calls */
+
+    OPENSSL_CTX *libctx;    /* needed for rand calls */
+    const PROV_GCM_HW *hw;  /* hardware specific methods */
+    GCM128_CONTEXT gcm;
+    ctr128_f ctr;
+    const void *ks;
+} PROV_GCM_CTX;
+
+typedef struct prov_aes_gcm_ctx_st {
+    PROV_GCM_CTX base;          /* must be first entry in struct */
+    union {
+        OSSL_UNION_ALIGN;
+        AES_KEY ks;
+    } ks;                       /* AES key schedule to use */
+
+    /* Platform specific data */
+    union {
+        int dummy;
+#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__)
+        struct {
+            union {
+                OSSL_UNION_ALIGN;
+                S390X_KMA_PARAMS kma;
+            } param;
+            unsigned int fc;
+            unsigned char ares[16];
+            unsigned char mres[16];
+            unsigned char kres[16];
+            int areslen;
+            int mreslen;
+            int kreslen;
+            int res;
+        } s390x;
+#endif /* defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__) */
+    } plat;
+} PROV_AES_GCM_CTX;
+
+OSSL_CIPHER_FUNC(int, GCM_setkey, (PROV_GCM_CTX *ctx, const unsigned char *key,
+                                   size_t keylen));
+OSSL_CIPHER_FUNC(int, GCM_setiv, (PROV_GCM_CTX *dat, const unsigned char *iv,
+                                  size_t ivlen));
+OSSL_CIPHER_FUNC(int, GCM_aadupdate, (PROV_GCM_CTX *ctx,
+                                      const unsigned char *aad, size_t aadlen));
+OSSL_CIPHER_FUNC(int, GCM_cipherupdate, (PROV_GCM_CTX *ctx,
+                                         const unsigned char *in, size_t len,
+                                         unsigned char *out));
+OSSL_CIPHER_FUNC(int, GCM_cipherfinal, (PROV_GCM_CTX *ctx, unsigned char *tag));
+OSSL_CIPHER_FUNC(int, GCM_oneshot, (PROV_GCM_CTX *ctx, unsigned char *aad,
+                                    size_t aad_len, const unsigned char *in,
+                                    size_t in_len, unsigned char *out,
+                                    unsigned char *tag, size_t taglen));
+struct prov_gcm_hw_st {
+  OSSL_GCM_setkey_fn setkey;
+  OSSL_GCM_setiv_fn setiv;
+  OSSL_GCM_aadupdate_fn aadupdate;
+  OSSL_GCM_cipherupdate_fn cipherupdate;
+  OSSL_GCM_cipherfinal_fn cipherfinal;
+  OSSL_GCM_oneshot_fn oneshot;
+};
+const PROV_GCM_HW *PROV_AES_HW_gcm(size_t keybits);
+
+#if !defined(OPENSSL_NO_ARIA) &amp;&amp; !defined(FIPS_MODE)
+
+#include &quot;internal/aria.h&quot;
+
+typedef struct prov_aria_gcm_ctx_st {
+    PROV_GCM_CTX base;              /* must be first entry in struct */
+    union {
+        OSSL_UNION_ALIGN;
+        ARIA_KEY ks;
+    } ks;
+} PROV_ARIA_GCM_CTX;
+const PROV_GCM_HW *PROV_ARIA_HW_gcm(size_t keybits);
+
+#endif /* !defined(OPENSSL_NO_ARIA) &amp;&amp; !defined(FIPS_MODE) */
diff --git a/providers/common/ciphers/ciphers_locl.h b/providers/common/ciphers/ciphers_locl.h
index 49248f099c..91033eb262 100644
--- a/providers/common/ciphers/ciphers_locl.h
+++ b/providers/common/ciphers/ciphers_locl.h
@@ -1,4 +1,3 @@
-
 /*
  * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
  *
@@ -8,12 +7,46 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
+#include &lt;openssl/opensslconf.h&gt;
 #include &lt;openssl/aes.h&gt;
-#include &lt;openssl/modes.h&gt;
+#include &lt;openssl/params.h&gt;
 #include &quot;internal/cryptlib.h&quot;
+#include &quot;internal/modes_int.h&quot;
+
+#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__)
+/*-
+ * KMA-GCM-AES parameter block - begin
+ * (see z/Architecture Principles of Operation &gt;= SA22-7832-11)
+ */
+typedef struct S390X_kma_params_st {
+    unsigned char reserved[12];
+    union {
+        unsigned int w;
+        unsigned char b[4];
+    } cv; /* 32 bit counter value */
+    union {
+        unsigned long long g[2];
+        unsigned char b[16];
+    } t; /* tag */
+    unsigned char h[16]; /* hash subkey */
+    unsigned long long taadl; /* total AAD length */
+    unsigned long long tpcl; /* total plaintxt/ciphertxt len */
+    union {
+        unsigned long long g[2];
+        unsigned int w[4];
+    } j0;                   /* initial counter value */
+    unsigned char k[32];    /* key */
+} S390X_KMA_PARAMS;
+
+#endif
 
 typedef struct prov_aes_cipher_st PROV_AES_CIPHER;
 
+#define IV_STATE_UNINITIALISED 0  /* initial state is not initialized */
+#define IV_STATE_BUFFERED      1  /* iv has been copied to the iv buffer */
+#define IV_STATE_COPIED        2  /* iv has been copied from the iv buffer */
+#define IV_STATE_FINISHED      3  /* the iv has been used - so don't reuse it */
+
 typedef struct prov_aes_key_st {
     union {
         OSSL_UNION_ALIGN;
@@ -93,6 +126,10 @@ struct prov_aes_cipher_st {
                 size_t inl);
 };
 
+#define OSSL_CIPHER_FUNC(type, name, args) typedef type (* OSSL_##name##_fn)args
+
+#include &quot;ciphers_gcm.h&quot;
+
 const PROV_AES_CIPHER *PROV_AES_CIPHER_ecb(size_t keylen);
 const PROV_AES_CIPHER *PROV_AES_CIPHER_cbc(size_t keylen);
 const PROV_AES_CIPHER *PROV_AES_CIPHER_ofb(size_t keylen);
@@ -107,3 +144,5 @@ int trailingdata(unsigned char *buf, size_t *buflen, size_t blocksize,
                  const unsigned char **in, size_t *inlen);
 void padblock(unsigned char *buf, size_t *buflen, size_t blocksize);
 int unpadblock(unsigned char *buf, size_t *buflen, size_t blocksize);
+int aes_get_params(OSSL_PARAM params[], int md, unsigned long flags,
+                   int kbits, int blkbits, int ivbits);
diff --git a/providers/common/ciphers/gcm.c b/providers/common/ciphers/gcm.c
new file mode 100644
index 0000000000..235d81a932
--- /dev/null
+++ b/providers/common/ciphers/gcm.c
@@ -0,0 +1,580 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/params.h&gt;
+#include &lt;openssl/core_numbers.h&gt;
+#include &lt;openssl/core_names.h&gt;
+#include &quot;internal/rand_int.h&quot;
+#include &quot;internal/provider_algs.h&quot;
+#include &quot;internal/provider_ctx.h&quot;
+#include &quot;internal/providercommonerr.h&quot;
+#include &quot;ciphers_locl.h&quot;
+
+/* TODO(3.0) Figure out what flags are really needed */
+#define AEAD_GCM_FLAGS (EVP_CIPH_FLAG_AEAD_CIPHER | EVP_CIPH_FLAG_DEFAULT_ASN1 \
+                       | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER      \
+                       | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT        \
+                       | EVP_CIPH_CUSTOM_COPY)
+
+static OSSL_OP_cipher_encrypt_init_fn gcm_einit;
+static OSSL_OP_cipher_decrypt_init_fn gcm_dinit;
+static OSSL_OP_cipher_ctx_get_params_fn gcm_ctx_get_params;
+static OSSL_OP_cipher_ctx_set_params_fn gcm_ctx_set_params;
+static OSSL_OP_cipher_cipher_fn gcm_cipher;
+static OSSL_OP_cipher_update_fn gcm_stream_update;
+static OSSL_OP_cipher_final_fn gcm_stream_final;
+
+static int gcm_tls_init(PROV_GCM_CTX *dat, unsigned char *aad, size_t aad_len);
+static int gcm_tls_iv_set_fixed(PROV_GCM_CTX *ctx, unsigned char *iv,
+                                size_t len);
+static int gcm_tls_cipher(PROV_GCM_CTX *ctx, unsigned char *out, size_t *padlen,
+                          const unsigned char *in, size_t len);
+static int gcm_cipher_internal(PROV_GCM_CTX *ctx, unsigned char *out,
+                               size_t *padlen, const unsigned char *in,
+                               size_t len);
+
+static void gcm_initctx(void *provctx, PROV_GCM_CTX *ctx, size_t keybits,
+                        const PROV_GCM_HW *hw, size_t ivlen_min)
+{
+    ctx-&gt;pad = 1;
+    ctx-&gt;mode = EVP_CIPH_GCM_MODE;
+    ctx-&gt;taglen = -1;
+    ctx-&gt;tls_aad_len = -1;
+    ctx-&gt;ivlen_min = ivlen_min;
+    ctx-&gt;ivlen = (EVP_GCM_TLS_FIXED_IV_LEN + EVP_GCM_TLS_EXPLICIT_IV_LEN);
+    ctx-&gt;keylen = keybits / 8;
+    ctx-&gt;hw = hw;
+    ctx-&gt;libctx = PROV_LIBRARY_CONTEXT_OF(provctx);
+}
+
+static void gcm_deinitctx(PROV_GCM_CTX *ctx)
+{
+    OPENSSL_cleanse(ctx-&gt;iv, sizeof(ctx-&gt;iv));
+}
+
+static int gcm_init(void *vctx, const unsigned char *key, size_t keylen,
+                    const unsigned char *iv, size_t ivlen, int enc)
+{
+    PROV_GCM_CTX *ctx = (PROV_GCM_CTX *)vctx;
+
+    ctx-&gt;enc = enc;
+
+    if (iv != NULL) {
+        if (ivlen &lt; ctx-&gt;ivlen_min || ivlen &gt; sizeof(ctx-&gt;iv)) {
+            PROVerr(0, PROV_R_INVALID_IVLEN);
+            return 0;
+        }
+        ctx-&gt;ivlen = ivlen;
+        memcpy(ctx-&gt;iv, iv, ctx-&gt;ivlen);
+        ctx-&gt;iv_state = IV_STATE_BUFFERED;
+    }
+
+    if (key != NULL) {
+        if (keylen != ctx-&gt;keylen) {
+            PROVerr(0, PROV_R_INVALID_KEYLEN);
+            return 0;
+        }
+        return ctx-&gt;hw-&gt;setkey(ctx, key, ctx-&gt;keylen);
+    }
+    return 1;
+}
+
+static int gcm_einit(void *vctx, const unsigned char *key, size_t keylen,
+                     const unsigned char *iv, size_t ivlen)
+{
+    return gcm_init(vctx, key, keylen, iv, ivlen, 1);
+}
+
+static int gcm_dinit(void *vctx, const unsigned char *key, size_t keylen,
+                     const unsigned char *iv, size_t ivlen)
+{
+    return gcm_init(vctx, key, keylen, iv, ivlen, 0);
+}
+
+static int gcm_ctx_get_params(void *vctx, OSSL_PARAM params[])
+{
+    PROV_GCM_CTX *ctx = (PROV_GCM_CTX *)vctx;
+    OSSL_PARAM *p;
+    size_t sz;
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_IVLEN);
+    if (p != NULL) {
+        if (!OSSL_PARAM_set_int(p, ctx-&gt;ivlen))
+            return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_KEYLEN);
+    if (p != NULL &amp;&amp; !OSSL_PARAM_set_int(p, ctx-&gt;keylen)) {
+        PROVerr(0, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_IV);
+    if (p != NULL) {
+        if (ctx-&gt;iv_gen != 1 &amp;&amp; ctx-&gt;iv_gen_rand != 1)
+            return 0;
+        if (ctx-&gt;ivlen != (int)p-&gt;data_size) {
+            PROVerr(0, PROV_R_INVALID_IVLEN);
+            return 0;
+        }
+        if (!OSSL_PARAM_set_octet_string(p, ctx-&gt;iv, ctx-&gt;ivlen)) {
+            PROVerr(0, PROV_R_FAILED_TO_SET_PARAMETER);
+            return 0;
+        }
+    }
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD);
+    if (p != NULL &amp;&amp; !OSSL_PARAM_set_size_t(p, ctx-&gt;tls_aad_pad_sz)) {
+        PROVerr(0, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_AEAD_TAG);
+    if (p != NULL) {
+        sz = p-&gt;data_size;
+        if (sz == 0 || sz &gt; EVP_GCM_TLS_TAG_LEN || !ctx-&gt;enc || ctx-&gt;taglen &lt; 0) {
+            PROVerr(0, PROV_R_INVALID_TAG);
+            return 0;
+        }
+        if (!OSSL_PARAM_set_octet_string(p, ctx-&gt;buf, sz)) {
+            PROVerr(0, PROV_R_FAILED_TO_SET_PARAMETER);
+            return 0;
+        }
+    }
+    return 1;
+}
+
+static int gcm_ctx_set_params(void *vctx, const OSSL_PARAM params[])
+{
+    PROV_GCM_CTX *ctx = (PROV_GCM_CTX *)vctx;
+    const OSSL_PARAM *p;
+    size_t sz;
+    void *vp;
+
+    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TAG);
+    if (p != NULL) {
+        vp = ctx-&gt;buf;
+        if (!OSSL_PARAM_get_octet_string(p, &amp;vp, EVP_GCM_TLS_TAG_LEN, &amp;sz)) {
+            PROVerr(0, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+        if (sz == 0 || ctx-&gt;enc) {
+            PROVerr(0, PROV_R_INVALID_TAG);
+            return 0;
+        }
+        ctx-&gt;taglen = sz;
+    }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_IVLEN);
+    if (p != NULL) {
+        if (!OSSL_PARAM_get_size_t(p, &amp;sz)) {
+            PROVerr(0, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+        if (sz == 0 || sz &gt; sizeof(ctx-&gt;iv)) {
+            PROVerr(0, PROV_R_INVALID_IVLEN);
+            return 0;
+        }
+        ctx-&gt;ivlen = sz;
+    }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD);
+    if (p != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_OCTET_STRING) {
+            PROVerr(0, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+        sz = gcm_tls_init(ctx, p-&gt;data, p-&gt;data_size);
+        if (sz == 0) {
+            PROVerr(0, PROV_R_INVALID_AAD);
+            return 0;
+        }
+        ctx-&gt;tls_aad_pad_sz = sz;
+    }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TLS1_IV_FIXED);
+    if (p != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_OCTET_STRING) {
+            PROVerr(0, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+        if (gcm_tls_iv_set_fixed(ctx, p-&gt;data, p-&gt;data_size) == 0) {
+            PROVerr(0, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+static int gcm_stream_update(void *vctx, unsigned char *out, size_t *outl,
+                             size_t outsize, const unsigned char *in,
+                             size_t inl)
+{
+    PROV_GCM_CTX *ctx = (PROV_GCM_CTX *)vctx;
+
+    if (outsize &lt; inl) {
+        PROVerr(0, PROV_R_OUTPUT_BUFFER_TOO_SMALL);
+        return -1;
+    }
+
+    if (gcm_cipher_internal(ctx, out, outl, in, inl) &lt;= 0) {
+        PROVerr(0, PROV_R_CIPHER_OPERATION_FAILED);
+        return -1;
+    }
+    return 1;
+}
+
+static int gcm_stream_final(void *vctx, unsigned char *out, size_t *outl,
+                            size_t outsize)
+{
+    PROV_GCM_CTX *ctx = (PROV_GCM_CTX *)vctx;
+    int i;
+
+    i = gcm_cipher_internal(ctx, out, outl, NULL, 0);
+    if (i &lt;= 0)
+        return 0;
+
+    *outl = 0;
+    return 1;
+}
+
+static int gcm_cipher(void *vctx,
+                      unsigned char *out, size_t *outl, size_t outsize,
+                      const unsigned char *in, size_t inl)
+{
+    PROV_GCM_CTX *ctx = (PROV_GCM_CTX *)vctx;
+
+    if (outsize &lt; inl) {
+        PROVerr(0, PROV_R_OUTPUT_BUFFER_TOO_SMALL);
+        return -1;
+    }
+
+    if (gcm_cipher_internal(ctx, out, outl, in, inl) &lt;= 0)
+        return -1;
+
+    *outl = inl;
+    return 1;
+}
+
+/*
+ * See SP800-38D (GCM) Section 8 &quot;Uniqueness requirement on IVS and keys&quot;
+ *
+ * See also 8.2.2 RBG-based construction.
+ * Random construction consists of a free field (which can be NULL) and a
+ * random field which will use a DRBG that can return at least 96 bits of
+ * entropy strength. (The DRBG must be seeded by the FIPS module).
+ */
+static int gcm_iv_generate(PROV_GCM_CTX *ctx, int offset)
+{
+    int sz = ctx-&gt;ivlen - offset;
+
+    /* Must be at least 96 bits */
+    if (sz &lt;= 0 || ctx-&gt;ivlen &lt; GCM_IV_DEFAULT_SIZE)
+        return 0;
+
+    /* Use DRBG to generate random iv */
+    if (rand_bytes_ex(ctx-&gt;libctx, ctx-&gt;iv + offset, sz) &lt;= 0)
+        return 0;
+    ctx-&gt;iv_state = IV_STATE_BUFFERED;
+    ctx-&gt;iv_gen_rand = 1;
+    return 1;
+}
+
+static int gcm_cipher_internal(PROV_GCM_CTX *ctx, unsigned char *out,
+                               size_t *padlen, const unsigned char *in,
+                               size_t len)
+{
+    size_t olen = 0;
+    int rv = 0;
+    const PROV_GCM_HW *hw = ctx-&gt;hw;
+
+    if (ctx-&gt;tls_aad_len &gt;= 0)
+        return gcm_tls_cipher(ctx, out, padlen, in, len);
+
+    if (!ctx-&gt;key_set || ctx-&gt;iv_state == IV_STATE_FINISHED)
+        goto err;
+
+    /*
+     * FIPS requires generation of AES-GCM IV's inside the FIPS module.
+     * The IV can still be set externally (the security policy will state that
+     * this is not FIPS compliant). There are some applications
+     * where setting the IV externally is the only option available.
+     */
+    if (ctx-&gt;iv_state == IV_STATE_UNINITIALISED) {
+        if (!ctx-&gt;enc || !gcm_iv_generate(ctx, 0))
+            goto err;
+    }
+
+    if (ctx-&gt;iv_state == IV_STATE_BUFFERED) {
+        if (!hw-&gt;setiv(ctx, ctx-&gt;iv, ctx-&gt;ivlen))
+            goto err;
+        ctx-&gt;iv_state = IV_STATE_COPIED;
+    }
+
+    if (in != NULL) {
+        /*  The input is AAD if out is NULL */
+        if (out == NULL) {
+            if (!hw-&gt;aadupdate(ctx, in, len))
+                goto err;
+        } else {
+            /* The input is ciphertext OR plaintext */
+            if (!hw-&gt;cipherupdate(ctx, in, len, out))
+                goto err;
+        }
+    } else {
+        /* Finished when in == NULL */
+        if (!hw-&gt;cipherfinal(ctx, ctx-&gt;buf))
+            goto err;
+        ctx-&gt;iv_state = IV_STATE_FINISHED; /* Don't reuse the IV */
+        goto finish;
+    }
+    olen = len;
+finish:
+    rv = 1;
+err:
+    *padlen = olen;
+    return rv;
+}
+
+static int gcm_tls_init(PROV_GCM_CTX *dat, unsigned char *aad, size_t aad_len)
+{
+    unsigned char *buf;
+    size_t len;
+
+    if (aad_len != EVP_AEAD_TLS1_AAD_LEN)
+       return 0;
+
+    /* Save the aad for later use. */
+    buf = dat-&gt;buf;
+    memcpy(buf, aad, aad_len);
+    dat-&gt;tls_aad_len = aad_len;
+    dat-&gt;tls_enc_records = 0;
+
+    len = buf[aad_len - 2] &lt;&lt; 8 | buf[aad_len - 1];
+    /* Correct length for explicit iv. */
+    if (len &lt; EVP_GCM_TLS_EXPLICIT_IV_LEN)
+        return 0;
+    len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
+
+    /* If decrypting correct for tag too. */
+    if (!dat-&gt;enc) {
+        if (len &lt; EVP_GCM_TLS_TAG_LEN)
+            return 0;
+        len -= EVP_GCM_TLS_TAG_LEN;
+    }
+    buf[aad_len - 2] = (unsigned char)(len &gt;&gt; 8);
+    buf[aad_len - 1] = (unsigned char)(len &amp; 0xff);
+    /* Extra padding: tag appended to record. */
+    return EVP_GCM_TLS_TAG_LEN;
+}
+
+static int gcm_tls_iv_set_fixed(PROV_GCM_CTX *ctx, unsigned char *iv,
+                                size_t len)
+{
+    /* Special case: -1 length restores whole IV */
+    if (len == (size_t)-1) {
+        memcpy(ctx-&gt;iv, iv, ctx-&gt;ivlen);
+        ctx-&gt;iv_gen = 1;
+        ctx-&gt;iv_state = IV_STATE_BUFFERED;
+        return 1;
+    }
+    /* Fixed field must be at least 4 bytes and invocation field at least 8 */
+    if ((len &lt; EVP_GCM_TLS_FIXED_IV_LEN)
+        || (ctx-&gt;ivlen - (int)len) &lt; EVP_GCM_TLS_EXPLICIT_IV_LEN)
+            return 0;
+    if (len &gt; 0)
+        memcpy(ctx-&gt;iv, iv, len);
+    if (ctx-&gt;enc
+        &amp;&amp; rand_bytes_ex(ctx-&gt;libctx, ctx-&gt;iv + len, ctx-&gt;ivlen - len) &lt;= 0)
+            return 0;
+    ctx-&gt;iv_gen = 1;
+    ctx-&gt;iv_state = IV_STATE_BUFFERED;
+    return 1;
+}
+
+/* increment counter (64-bit int) by 1 */
+static void ctr64_inc(unsigned char *counter)
+{
+    int n = 8;
+    unsigned char c;
+
+    do {
+        --n;
+        c = counter[n];
+        ++c;
+        counter[n] = c;
+        if (c &gt; 0)
+            return;
+    } while (n &gt; 0);
+}
+
+/*
+ * Handle TLS GCM packet format. This consists of the last portion of the IV
+ * followed by the payload and finally the tag. On encrypt generate IV,
+ * encrypt payload and write the tag. On verify retrieve IV, decrypt payload
+ * and verify tag.
+ */
+static int gcm_tls_cipher(PROV_GCM_CTX *ctx, unsigned char *out, size_t *padlen,
+                          const unsigned char *in, size_t len)
+{
+    int rv = 0, arg = EVP_GCM_TLS_EXPLICIT_IV_LEN;
+    size_t plen = 0;
+    unsigned char *tag = NULL;
+
+    if (!ctx-&gt;key_set)
+        goto err;
+
+    /* Encrypt/decrypt must be performed in place */
+    if (out != in || len &lt; (EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN))
+        goto err;
+
+    /*
+     * Check for too many keys as per FIPS 140-2 IG A.5 &quot;Key/IV Pair Uniqueness
+     * Requirements from SP 800-38D&quot;.  The requirements is for one party to the
+     * communication to fail after 2^64 - 1 keys.  We do this on the encrypting
+     * side only.
+     */
+    if (ctx-&gt;enc &amp;&amp; ++ctx-&gt;tls_enc_records == 0) {
+        PROVerr(0, EVP_R_TOO_MANY_RECORDS);
+        goto err;
+    }
+
+    if (ctx-&gt;iv_gen == 0)
+        goto err;
+    /*
+     * Set IV from start of buffer or generate IV and write to start of
+     * buffer.
+     */
+    if (ctx-&gt;enc) {
+        if (!ctx-&gt;hw-&gt;setiv(ctx, ctx-&gt;iv, ctx-&gt;ivlen))
+            goto err;
+        if (arg &gt; ctx-&gt;ivlen)
+            arg = ctx-&gt;ivlen;
+        memcpy(out, ctx-&gt;iv + ctx-&gt;ivlen - arg, arg);
+        /*
+         * Invocation field will be at least 8 bytes in size and so no need
+         * to check wrap around or increment more than last 8 bytes.
+         */
+        ctr64_inc(ctx-&gt;iv + ctx-&gt;ivlen - 8);
+    } else {
+        memcpy(ctx-&gt;iv + ctx-&gt;ivlen - arg, out, arg);
+        if (!ctx-&gt;hw-&gt;setiv(ctx, ctx-&gt;iv, ctx-&gt;ivlen))
+            goto err;
+    }
+    ctx-&gt;iv_state = IV_STATE_COPIED;
+
+    /* Fix buffer and length to point to payload */
+    in += EVP_GCM_TLS_EXPLICIT_IV_LEN;
+    out += EVP_GCM_TLS_EXPLICIT_IV_LEN;
+    len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;
+
+    tag = ctx-&gt;enc ? out + len : (unsigned char *)in + len;
+    if (!ctx-&gt;hw-&gt;oneshot(ctx, ctx-&gt;buf, ctx-&gt;tls_aad_len, in, len, out, tag,
+                          EVP_GCM_TLS_TAG_LEN)) {
+        if (!ctx-&gt;enc)
+            OPENSSL_cleanse(out, len);
+        goto err;
+    }
+    if (ctx-&gt;enc)
+        plen =  len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;
+    else
+        plen = len;
+
+    rv = 1;
+err:
+    ctx-&gt;iv_state = IV_STATE_FINISHED;
+    ctx-&gt;tls_aad_len = -1;
+    *padlen = plen;
+    return rv;
+}
+
+#define IMPLEMENT_cipher(alg, lcmode, UCMODE, flags, kbits, blkbits, ivbits)   \
+    static OSSL_OP_cipher_get_params_fn alg##_##kbits##_##lcmode##_get_params; \
+    static int alg##_##kbits##_##lcmode##_get_params(OSSL_PARAM params[])      \
+    {                                                                          \
+        return aes_get_params(params, EVP_CIPH_##UCMODE##_MODE, flags,         \
+                               kbits, blkbits, ivbits);                        \
+    }                                                                          \
+    static OSSL_OP_cipher_newctx_fn alg##kbits##gcm_newctx;                    \
+    static void *alg##kbits##gcm_newctx(void *provctx)                         \
+    {                                                                          \
+        return alg##_gcm_newctx(provctx, kbits);                               \
+    }                                                                          \
+    const OSSL_DISPATCH alg##kbits##gcm_functions[] = {                        \
+        { OSSL_FUNC_CIPHER_ENCRYPT_INIT, (void (*)(void))gcm_einit },          \
+        { OSSL_FUNC_CIPHER_DECRYPT_INIT, (void (*)(void))gcm_dinit },          \
+        { OSSL_FUNC_CIPHER_UPDATE, (void (*)(void))gcm_stream_update },        \
+        { OSSL_FUNC_CIPHER_FINAL, (void (*)(void))gcm_stream_final },          \
+        { OSSL_FUNC_CIPHER_CIPHER, (void (*)(void))gcm_cipher },               \
+        { OSSL_FUNC_CIPHER_NEWCTX, (void (*)(void)) alg##kbits##gcm_newctx },  \
+        { OSSL_FUNC_CIPHER_FREECTX, (void (*)(void)) alg##_gcm_freectx },      \
+        { OSSL_FUNC_CIPHER_GET_PARAMS,                                         \
+            (void (*)(void)) alg##_##kbits##_##lcmode##_get_params },          \
+        { OSSL_FUNC_CIPHER_CTX_GET_PARAMS,                                     \
+            (void (*)(void))gcm_ctx_get_params },                              \
+        { OSSL_FUNC_CIPHER_CTX_SET_PARAMS,                                     \
+            (void (*)(void))gcm_ctx_set_params },                              \
+        { 0, NULL }                                                            \
+    }
+
+static void *aes_gcm_newctx(void *provctx, size_t keybits)
+{
+    PROV_AES_GCM_CTX *ctx = OPENSSL_zalloc(sizeof(*ctx));
+
+    if (ctx != NULL)
+        gcm_initctx(provctx, (PROV_GCM_CTX *)ctx, keybits,
+                    PROV_AES_HW_gcm(keybits), 8);
+    return ctx;
+}
+
+static OSSL_OP_cipher_freectx_fn aes_gcm_freectx;
+static void aes_gcm_freectx(void *vctx)
+{
+    PROV_AES_GCM_CTX *ctx = (PROV_AES_GCM_CTX *)vctx;
+
+    gcm_deinitctx((PROV_GCM_CTX *)ctx);
+    OPENSSL_clear_free(ctx,  sizeof(*ctx));
+}
+
+/* aes128gcm_functions */
+IMPLEMENT_cipher(aes, gcm, GCM, AEAD_GCM_FLAGS, 128, 8, 96);
+/* aes192gcm_functions */
+IMPLEMENT_cipher(aes, gcm, GCM, AEAD_GCM_FLAGS, 192, 8, 96);
+/* aes256gcm_functions */
+IMPLEMENT_cipher(aes, gcm, GCM, AEAD_GCM_FLAGS, 256, 8, 96);
+
+#if !defined(OPENSSL_NO_ARIA) &amp;&amp; !defined(FIPS_MODE)
+
+static void *aria_gcm_newctx(void *provctx, size_t keybits)
+{
+    PROV_ARIA_GCM_CTX *ctx = OPENSSL_zalloc(sizeof(*ctx));
+
+    if (ctx != NULL)
+        gcm_initctx(provctx, (PROV_GCM_CTX *)ctx, keybits,
+                    PROV_ARIA_HW_gcm(keybits), 4);
+    return ctx;
+}
+
+static OSSL_OP_cipher_freectx_fn aria_gcm_freectx;
+static void aria_gcm_freectx(void *vctx)
+{
+    PROV_ARIA_GCM_CTX *ctx = (PROV_ARIA_GCM_CTX *)vctx;
+
+    gcm_deinitctx((PROV_GCM_CTX *)ctx);
+    OPENSSL_clear_free(ctx,  sizeof(*ctx));
+}
+
+/* aria128gcm_functions */
+IMPLEMENT_cipher(aria, gcm, GCM, AEAD_GCM_FLAGS, 128, 8, 96);
+/* aria192gcm_functions */
+IMPLEMENT_cipher(aria, gcm, GCM, AEAD_GCM_FLAGS, 192, 8, 96);
+/* aria256gcm_functions */
+IMPLEMENT_cipher(aria, gcm, GCM, AEAD_GCM_FLAGS, 256, 8, 96);
+
+#endif /* !defined(OPENSSL_NO_ARIA) &amp;&amp; !defined(FIPS_MODE) */
diff --git a/providers/common/ciphers/gcm_hw.c b/providers/common/ciphers/gcm_hw.c
new file mode 100644
index 0000000000..e8c5f66e4c
--- /dev/null
+++ b/providers/common/ciphers/gcm_hw.c
@@ -0,0 +1,307 @@
+/*
+ * Copyright 2001-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &quot;ciphers_locl.h&quot;
+#include &quot;internal/aes_platform.h&quot;
+
+static const PROV_GCM_HW aes_gcm;
+
+static int gcm_setiv(PROV_GCM_CTX *ctx, const unsigned char *iv, size_t ivlen);
+static int gcm_aad_update(PROV_GCM_CTX *ctx, const unsigned char *aad,
+                          size_t aad_len);
+static int gcm_cipher_final(PROV_GCM_CTX *ctx, unsigned char *tag);
+static int gcm_one_shot(PROV_GCM_CTX *ctx, unsigned char *aad, size_t aad_len,
+                        const unsigned char *in, size_t in_len,
+                        unsigned char *out, unsigned char *tag, size_t tag_len);
+static int gcm_cipher_update(PROV_GCM_CTX *ctx, const unsigned char *in,
+                             size_t len, unsigned char *out);
+
+#define SET_KEY_CTR_FN(ks, fn_set_enc_key, fn_block, fn_ctr)                   \
+    ctx-&gt;ks = ks;                                                              \
+    fn_set_enc_key(key, keylen * 8, ks);                                       \
+    CRYPTO_gcm128_init(&amp;ctx-&gt;gcm, ks, (block128_f)fn_block);                   \
+    ctx-&gt;ctr = (ctr128_f)fn_ctr;                                               \
+    ctx-&gt;key_set = 1;
+
+#if defined(AESNI_CAPABLE)
+
+/* AES-NI section */
+static int aesni_gcm_init_key(PROV_GCM_CTX *ctx, const unsigned char *key,
+                              size_t keylen)
+{
+    PROV_AES_GCM_CTX *actx = (PROV_AES_GCM_CTX *)ctx;
+    AES_KEY *ks = &amp;actx-&gt;ks.ks;
+
+    SET_KEY_CTR_FN(ks, aesni_set_encrypt_key, aesni_encrypt,
+                   aesni_ctr32_encrypt_blocks);
+    return 1;
+}
+
+static const PROV_GCM_HW aesni_gcm = {
+    aesni_gcm_init_key,
+    gcm_setiv,
+    gcm_aad_update,
+    gcm_cipher_update,
+    gcm_cipher_final,
+    gcm_one_shot
+};
+
+const PROV_GCM_HW *PROV_AES_HW_gcm(size_t keybits)
+{
+    return AESNI_CAPABLE ? &amp;aesni_gcm : &amp;aes_gcm;
+}
+
+#elif defined(AES_ASM) &amp;&amp; (defined(__sparc) || defined(__sparc__))
+
+/* Fujitsu SPARC64 X support */
+
+static int t4_aes_gcm_init_key(PROV_GCM_CTX *ctx, const unsigned char *key,
+                               size_t keylen)
+{
+    ctr128_f ctr;
+    PROV_AES_GCM_CTX *actx = (PROV_AES_GCM_CTX *)ctx;
+    AES_KEY *ks = &amp;actx-&gt;ks.ks;
+
+
+    switch (keylen) {
+    case 16:
+        ctr = (ctr128_f)aes128_t4_ctr32_encrypt;
+        break;
+    case 24:
+        ctr = (ctr128_f)aes192_t4_ctr32_encrypt;
+        break;
+    case 32:
+        ctr = (ctr128_f)aes256_t4_ctr32_encrypt;
+        break;
+    default:
+        return 0;
+    }
+
+    SET_KEY_CTR_FN(ks, aes_t4_set_encrypt_key, aes_t4_encrypt, ctr);
+    return 1;
+}
+
+static const PROV_GCM_HW t4_aes_gcm = {
+    t4_aes_gcm_init_key,
+    gcm_setiv,
+    gcm_aad_update,
+    gcm_cipher_update,
+    gcm_cipher_final,
+    gcm_one_shot
+};
+const PROV_GCM_HW *PROV_AES_HW_gcm(size_t keybits)
+{
+    return SPARC_AES_CAPABLE ? &amp;t4_aes_gcm : &amp;aes_gcm;
+}
+
+#elif defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__)
+# include &quot;gcm_s390x.c&quot;
+#else
+const PROV_GCM_HW *PROV_AES_HW_gcm(size_t keybits)
+{
+    return &amp;aes_gcm;
+}
+#endif
+
+static int generic_aes_gcm_init_key(PROV_GCM_CTX *ctx, const unsigned char *key,
+                                    size_t keylen)
+{
+    PROV_AES_GCM_CTX *actx = (PROV_AES_GCM_CTX *)ctx;
+    AES_KEY *ks = &amp;actx-&gt;ks.ks;
+
+# ifdef HWAES_CAPABLE
+    if (HWAES_CAPABLE) {
+#  ifdef HWAES_ctr32_encrypt_blocks
+        SET_KEY_CTR_FN(ks, HWAES_set_encrypt_key, HWAES_encrypt,
+                       HWAES_ctr32_encrypt_blocks);
+#  else
+        SET_KEY_CTR_FN(ks, HWAES_set_encrypt_key, HWAES_encrypt, NULL);
+#  endif /* HWAES_ctr32_encrypt_blocks */
+    } else
+# endif /* HWAES_CAPABLE */
+
+# ifdef BSAES_CAPABLE
+    if (BSAES_CAPABLE) {
+        SET_KEY_CTR_FN(ks, AES_set_encrypt_key, AES_encrypt,
+                       bsaes_ctr32_encrypt_blocks);
+    } else
+# endif /* BSAES_CAPABLE */
+
+# ifdef VPAES_CAPABLE
+    if (VPAES_CAPABLE) {
+        SET_KEY_CTR_FN(ks, vpaes_set_encrypt_key, vpaes_encrypt, NULL);
+    } else
+# endif /* VPAES_CAPABLE */
+
+    {
+# ifdef AES_CTR_ASM
+        SET_KEY_CTR_FN(ks, AES_set_encrypt_key, AES_encrypt, AES_ctr32_encrypt);
+# else
+        SET_KEY_CTR_FN(ks, AES_set_encrypt_key, AES_encrypt, NULL);
+# endif /* AES_CTR_ASM */
+    }
+    ctx-&gt;key_set = 1;
+    return 1;
+}
+
+static int gcm_setiv(PROV_GCM_CTX *ctx, const unsigned char *iv, size_t ivlen)
+{
+    CRYPTO_gcm128_setiv(&amp;ctx-&gt;gcm, iv, ivlen);
+    return 1;
+}
+
+static int gcm_aad_update(PROV_GCM_CTX *ctx,
+                          const unsigned char *aad, size_t aad_len)
+{
+    return CRYPTO_gcm128_aad(&amp;ctx-&gt;gcm, aad, aad_len) == 0;
+}
+
+static int gcm_cipher_update(PROV_GCM_CTX *ctx, const unsigned char *in,
+                             size_t len, unsigned char *out)
+{
+    if (ctx-&gt;enc) {
+        if (ctx-&gt;ctr != NULL) {
+#if defined(AES_GCM_ASM)
+            size_t bulk = 0;
+
+            if (len &gt;= 32 &amp;&amp; AES_GCM_ASM(ctx)) {
+                size_t res = (16 - ctx-&gt;gcm.mres) % 16;
+
+                if (CRYPTO_gcm128_encrypt(&amp;ctx-&gt;gcm, in, out, res))
+                    return 0;
+                bulk = aesni_gcm_encrypt(in + res, out + res, len - res,
+                                         ctx-&gt;gcm.key,
+                                         ctx-&gt;gcm.Yi.c, ctx-&gt;gcm.Xi.u);
+                ctx-&gt;gcm.len.u[1] += bulk;
+                bulk += res;
+            }
+            if (CRYPTO_gcm128_encrypt_ctr32(&amp;ctx-&gt;gcm, in + bulk, out + bulk,
+                                            len - bulk, ctx-&gt;ctr))
+                return 0;
+#else
+            if (CRYPTO_gcm128_encrypt_ctr32(&amp;ctx-&gt;gcm, in, out, len, ctx-&gt;ctr))
+                return 0;
+#endif /* AES_GCM_ASM */
+        } else {
+            if (CRYPTO_gcm128_encrypt(&amp;ctx-&gt;gcm, in, out, len))
+                return 0;
+        }
+    } else {
+        if (ctx-&gt;ctr != NULL) {
+#if defined(AES_GCM_ASM)
+            size_t bulk = 0;
+
+            if (len &gt;= 16 &amp;&amp; AES_GCM_ASM(ctx)) {
+                size_t res = (16 - ctx-&gt;gcm.mres) % 16;
+
+                if (CRYPTO_gcm128_decrypt(&amp;ctx-&gt;gcm, in, out, res))
+                    return -1;
+
+                bulk = aesni_gcm_decrypt(in + res, out + res, len - res,
+                                         ctx-&gt;gcm.key,
+                                         ctx-&gt;gcm.Yi.c, ctx-&gt;gcm.Xi.u);
+                ctx-&gt;gcm.len.u[1] += bulk;
+                bulk += res;
+            }
+            if (CRYPTO_gcm128_decrypt_ctr32(&amp;ctx-&gt;gcm, in + bulk, out + bulk,
+                                            len - bulk, ctx-&gt;ctr))
+                return 0;
+#else
+            if (CRYPTO_gcm128_decrypt_ctr32(&amp;ctx-&gt;gcm, in, out, len, ctx-&gt;ctr))
+                return 0;
+#endif /* AES_GCM_ASM */
+        } else {
+            if (CRYPTO_gcm128_decrypt(&amp;ctx-&gt;gcm, in, out, len))
+                return 0;
+        }
+    }
+    return 1;
+}
+
+static int gcm_cipher_final(PROV_GCM_CTX *ctx, unsigned char *tag)
+{
+    if (ctx-&gt;enc) {
+        CRYPTO_gcm128_tag(&amp;ctx-&gt;gcm, tag, GCM_TAG_MAX_SIZE);
+        ctx-&gt;taglen = GCM_TAG_MAX_SIZE;
+    } else {
+        if (ctx-&gt;taglen &lt; 0
+            || CRYPTO_gcm128_finish(&amp;ctx-&gt;gcm, tag, ctx-&gt;taglen) != 0)
+            return 0;
+    }
+    return 1;
+}
+
+static int gcm_one_shot(PROV_GCM_CTX *ctx, unsigned char *aad, size_t aad_len,
+                        const unsigned char *in, size_t in_len,
+                        unsigned char *out, unsigned char *tag, size_t tag_len)
+{
+    int ret = 0;
+
+    /* Use saved AAD */
+    if (!ctx-&gt;hw-&gt;aadupdate(ctx, aad, aad_len))
+        goto err;
+    if (!ctx-&gt;hw-&gt;cipherupdate(ctx, in, in_len, out))
+        goto err;
+    ctx-&gt;taglen = GCM_TAG_MAX_SIZE;
+    if (!ctx-&gt;hw-&gt;cipherfinal(ctx, tag))
+        goto err;
+    ret = 1;
+
+err:
+    return ret;
+}
+
+static const PROV_GCM_HW aes_gcm = {
+    generic_aes_gcm_init_key,
+    gcm_setiv,
+    gcm_aad_update,
+    gcm_cipher_update,
+    gcm_cipher_final,
+    gcm_one_shot
+};
+
+#if !defined(OPENSSL_NO_ARIA) &amp;&amp; !defined(FIPS_MODE)
+
+static int aria_gcm_init_key(PROV_GCM_CTX *ctx, const unsigned char *key,
+                             size_t keylen)
+{
+    PROV_ARIA_GCM_CTX *actx = (PROV_ARIA_GCM_CTX *)ctx;
+    ARIA_KEY *ks = &amp;actx-&gt;ks.ks;
+
+    SET_KEY_CTR_FN(ks, aria_set_encrypt_key, aria_encrypt, NULL);
+    return 1;
+}
+
+static int aria_cipher_update(PROV_GCM_CTX *ctx, const unsigned char *in,
+                              size_t len, unsigned char *out)
+{
+    if (ctx-&gt;enc) {
+        if (CRYPTO_gcm128_encrypt(&amp;ctx-&gt;gcm, in, out, len))
+            return 0;
+    } else {
+        if (CRYPTO_gcm128_decrypt(&amp;ctx-&gt;gcm, in, out, len))
+            return 0;
+    }
+    return 1;
+}
+
+static const PROV_GCM_HW aria_gcm = {
+    aria_gcm_init_key,
+    gcm_setiv,
+    gcm_aad_update,
+    aria_cipher_update,
+    gcm_cipher_final,
+    gcm_one_shot
+};
+const PROV_GCM_HW *PROV_ARIA_HW_gcm(size_t keybits)
+{
+    return &amp;aria_gcm;
+}
+
+#endif /* !defined(OPENSSL_NO_ARIA) &amp;&amp; !defined(FIPS_MODE) */
diff --git a/providers/common/ciphers/gcm_s390x.c b/providers/common/ciphers/gcm_s390x.c
new file mode 100644
index 0000000000..0ced60037d
--- /dev/null
+++ b/providers/common/ciphers/gcm_s390x.c
@@ -0,0 +1,303 @@
+/*
+ * Copyright 2001-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+/*
+ * IBM S390X AES GCM support
+ * Note this file is included by aes_gcm_hw.c
+ */
+
+/* iv + padding length for iv lengths != 12 */
+#define S390X_gcm_ivpadlen(i)  ((((i) + 15) &gt;&gt; 4 &lt;&lt; 4) + 16)
+
+static int s390x_aes_gcm_init_key(PROV_GCM_CTX *ctx,
+                                  const unsigned char *key, size_t keylen)
+{
+    PROV_AES_GCM_CTX *actx = (PROV_AES_GCM_CTX *)ctx;
+
+    ctx-&gt;key_set = 1;
+    memcpy(&amp;actx-&gt;plat.s390x.param.kma.k, key, keylen);
+    actx-&gt;plat.s390x.fc = S390X_AES_FC(keylen);
+    if (!ctx-&gt;enc)
+        actx-&gt;plat.s390x.fc |= S390X_DECRYPT;
+    return 1;
+}
+
+static int s390x_aes_gcm_setiv(PROV_GCM_CTX *ctx, const unsigned char *iv,
+                               size_t ivlen)
+{
+    PROV_AES_GCM_CTX *actx = (PROV_AES_GCM_CTX *)ctx;
+    S390X_KMA_PARAMS *kma = &amp;actx-&gt;plat.s390x.param.kma;
+
+    kma-&gt;t.g[0] = 0;
+    kma-&gt;t.g[1] = 0;
+    kma-&gt;tpcl = 0;
+    kma-&gt;taadl = 0;
+    actx-&gt;plat.s390x.mreslen = 0;
+    actx-&gt;plat.s390x.areslen = 0;
+    actx-&gt;plat.s390x.kreslen = 0;
+
+    if (ivlen == AES_GCM_IV_DEFAULT_SIZE) {
+        memcpy(&amp;kma-&gt;j0, iv, ivlen);
+        kma-&gt;j0.w[3] = 1;
+        kma-&gt;cv.w = 1;
+    } else {
+        unsigned long long ivbits = ivlen &lt;&lt; 3;
+        size_t len = S390X_gcm_ivpadlen(ivlen);
+        unsigned char iv_zero_pad[S390X_gcm_ivpadlen(AES_GCM_IV_MAX_SIZE)];
+        /*
+         * The IV length needs to be zero padded to be a multiple of 16 bytes
+         * followed by 8 bytes of zeros and 8 bytes for the IV length.
+         * The GHASH of this value can then be calculated.
+         */
+        memcpy(iv_zero_pad, iv, ivlen);
+        memset(iv_zero_pad + ivlen, 0, len - ivlen);
+        memcpy(iv_zero_pad + len - sizeof(ivbits), &amp;ivbits, sizeof(ivbits));
+        /*
+         * Calculate the ghash of the iv - the result is stored into the tag
+         * param.
+         */
+        s390x_kma(iv_zero_pad, len, NULL, 0, NULL, actx-&gt;plat.s390x.fc, kma);
+        actx-&gt;plat.s390x.fc |= S390X_KMA_HS; /* The hash subkey is set */
+
+        /* Copy the 128 bit GHASH result into J0 and clear the tag */
+        kma-&gt;j0.g[0] = kma-&gt;t.g[0];
+        kma-&gt;j0.g[1] = kma-&gt;t.g[1];
+        kma-&gt;t.g[0] = 0;
+        kma-&gt;t.g[1] = 0;
+        /* Set the 32 bit counter */
+        kma-&gt;cv.w = kma-&gt;j0.w[3];
+    }
+    return 1;
+}
+
+static int s390x_aes_gcm_cipher_final(PROV_GCM_CTX *ctx, unsigned char *tag)
+{
+    PROV_AES_GCM_CTX *actx = (PROV_AES_GCM_CTX *)ctx;
+    S390X_KMA_PARAMS *kma = &amp;actx-&gt;plat.s390x.param.kma;
+    unsigned char out[AES_BLOCK_SIZE];
+    int rc;
+
+    kma-&gt;taadl &lt;&lt;= 3;
+    kma-&gt;tpcl &lt;&lt;= 3;
+    s390x_kma(actx-&gt;plat.s390x.ares, actx-&gt;plat.s390x.areslen,
+              actx-&gt;plat.s390x.mres, actx-&gt;plat.s390x.mreslen, out,
+              actx-&gt;plat.s390x.fc | S390X_KMA_LAAD | S390X_KMA_LPC, kma);
+
+    /* gctx-&gt;mres already returned to the caller */
+    OPENSSL_cleanse(out, actx-&gt;plat.s390x.mreslen);
+
+    if (ctx-&gt;enc) {
+        ctx-&gt;taglen = AES_GCM_TAG_MAX_SIZE;
+        memcpy(tag, kma-&gt;t.b, ctx-&gt;taglen);
+        rc = 1;
+    } else {
+        if (ctx-&gt;taglen &lt; 0)
+            rc = 0;
+        else
+            rc = (CRYPTO_memcmp(tag, kma-&gt;t.b, ctx-&gt;taglen) == 0);
+    }
+    return rc;
+}
+
+static int s390x_aes_gcm_one_shot(PROV_GCM_CTX *ctx,
+                                  unsigned char *aad, size_t aad_len,
+                                  const unsigned char *in, size_t in_len,
+                                  unsigned char *out,
+                                  unsigned char *tag, size_t taglen)
+{
+    PROV_AES_GCM_CTX *actx = (PROV_AES_GCM_CTX *)ctx;
+    S390X_KMA_PARAMS *kma = &amp;actx-&gt;plat.s390x.param.kma;
+    int rc;
+
+    kma-&gt;taadl = aad_len &lt;&lt; 3;
+    kma-&gt;tpcl = in_len &lt;&lt; 3;
+    s390x_kma(aad, aad_len, in, in_len, out,
+              actx-&gt;plat.s390x.fc | S390X_KMA_LAAD | S390X_KMA_LPC, kma);
+
+    if (ctx-&gt;enc) {
+        memcpy(tag, kma-&gt;t.b, taglen);
+        rc = 1;
+    } else {
+        rc = (CRYPTO_memcmp(tag, kma-&gt;t.b, taglen) == 0);
+    }
+    return rc;
+}
+
+/*
+ * Process additional authenticated data. Returns 1 on success. Code is
+ * big-endian.
+ */
+static int s390x_aes_gcm_aad_update(PROV_GCM_CTX *ctx,
+                                    const unsigned char *aad, size_t len)
+{
+    PROV_AES_GCM_CTX *actx = (PROV_AES_GCM_CTX *)ctx;
+    S390X_KMA_PARAMS *kma = &amp;actx-&gt;plat.s390x.param.kma;
+    unsigned long long alen;
+    int n, rem;
+
+    /* If already processed pt/ct then error */
+    if (kma-&gt;tpcl != 0)
+        return 0;
+
+    /* update the total aad length */
+    alen = kma-&gt;taadl + len;
+    if (alen &gt; (U64(1) &lt;&lt; 61) || (sizeof(len) == 8 &amp;&amp; alen &lt; len))
+        return 0;
+    kma-&gt;taadl = alen;
+
+    /* check if there is any existing aad data from a previous add */
+    n = actx-&gt;plat.s390x.areslen;
+    if (n) {
+        /* add additional data to a buffer until it has 16 bytes */
+        while (n &amp;&amp; len) {
+            actx-&gt;plat.s390x.ares[n] = *aad;
+            ++aad;
+            --len;
+            n = (n + 1) &amp; 0xf;
+        }
+        /* ctx-&gt;ares contains a complete block if offset has wrapped around */
+        if (!n) {
+            s390x_kma(actx-&gt;plat.s390x.ares, 16, NULL, 0, NULL,
+                      actx-&gt;plat.s390x.fc, kma);
+            actx-&gt;plat.s390x.fc |= S390X_KMA_HS;
+        }
+        actx-&gt;plat.s390x.areslen = n;
+    }
+
+    /* If there are leftover bytes (&lt; 128 bits) save them for next time */
+    rem = len &amp; 0xf;
+    /* Add any remaining 16 byte blocks (128 bit each) */
+    len &amp;= ~(size_t)0xf;
+    if (len) {
+        s390x_kma(aad, len, NULL, 0, NULL, actx-&gt;plat.s390x.fc, kma);
+        actx-&gt;plat.s390x.fc |= S390X_KMA_HS;
+        aad += len;
+    }
+
+    if (rem) {
+        actx-&gt;plat.s390x.areslen = rem;
+
+        do {
+            --rem;
+            actx-&gt;plat.s390x.ares[rem] = aad[rem];
+        } while (rem);
+    }
+    return 1;
+}
+
+/*-
+ * En/de-crypt plain/cipher-text and authenticate ciphertext. Returns 1 for
+ * success. Code is big-endian.
+ */
+static int s390x_aes_gcm_cipher_update(PROV_GCM_CTX *ctx,
+                                       const unsigned char *in, size_t len,
+                                       unsigned char *out)
+{
+    PROV_AES_GCM_CTX *actx = (PROV_AES_GCM_CTX *)ctx;
+    S390X_KMA_PARAMS *kma = &amp;actx-&gt;plat.s390x.param.kma;
+    const unsigned char *inptr;
+    unsigned long long mlen;
+    union {
+        unsigned int w[4];
+        unsigned char b[16];
+    } buf;
+    size_t inlen;
+    int n, rem, i;
+
+    mlen = kma-&gt;tpcl + len;
+    if (mlen &gt; ((U64(1) &lt;&lt; 36) - 32) || (sizeof(len) == 8 &amp;&amp; mlen &lt; len))
+        return 0;
+    kma-&gt;tpcl = mlen;
+
+    n = actx-&gt;plat.s390x.mreslen;
+    if (n) {
+        inptr = in;
+        inlen = len;
+        while (n &amp;&amp; inlen) {
+            actx-&gt;plat.s390x.mres[n] = *inptr;
+            n = (n + 1) &amp; 0xf;
+            ++inptr;
+            --inlen;
+        }
+        /* ctx-&gt;mres contains a complete block if offset has wrapped around */
+        if (!n) {
+            s390x_kma(actx-&gt;plat.s390x.ares, actx-&gt;plat.s390x.areslen,
+                      actx-&gt;plat.s390x.mres, 16, buf.b,
+                      actx-&gt;plat.s390x.fc | S390X_KMA_LAAD, kma);
+            actx-&gt;plat.s390x.fc |= S390X_KMA_HS;
+            actx-&gt;plat.s390x.areslen = 0;
+
+            /* previous call already encrypted/decrypted its remainder,
+             * see comment below */
+            n = actx-&gt;plat.s390x.mreslen;
+            while (n) {
+                *out = buf.b[n];
+                n = (n + 1) &amp; 0xf;
+                ++out;
+                ++in;
+                --len;
+            }
+            actx-&gt;plat.s390x.mreslen = 0;
+        }
+    }
+
+    rem = len &amp; 0xf;
+
+    len &amp;= ~(size_t)0xf;
+    if (len) {
+        s390x_kma(actx-&gt;plat.s390x.ares, actx-&gt;plat.s390x.areslen, in, len, out,
+                  actx-&gt;plat.s390x.fc | S390X_KMA_LAAD, kma);
+        in += len;
+        out += len;
+        actx-&gt;plat.s390x.fc |= S390X_KMA_HS;
+        actx-&gt;plat.s390x.areslen = 0;
+    }
+
+    /*-
+     * If there is a remainder, it has to be saved such that it can be
+     * processed by kma later. However, we also have to do the for-now
+     * unauthenticated encryption/decryption part here and now...
+     */
+    if (rem) {
+        if (!actx-&gt;plat.s390x.mreslen) {
+            buf.w[0] = kma-&gt;j0.w[0];
+            buf.w[1] = kma-&gt;j0.w[1];
+            buf.w[2] = kma-&gt;j0.w[2];
+            buf.w[3] = kma-&gt;cv.w + 1;
+            s390x_km(buf.b, 16, actx-&gt;plat.s390x.kres,
+                     actx-&gt;plat.s390x.fc &amp; 0x1f, &amp;kma-&gt;k);
+        }
+
+        n = actx-&gt;plat.s390x.mreslen;
+        for (i = 0; i &lt; rem; i++) {
+            actx-&gt;plat.s390x.mres[n + i] = in[i];
+            out[i] = in[i] ^ actx-&gt;plat.s390x.kres[n + i];
+        }
+        actx-&gt;plat.s390x.mreslen += rem;
+    }
+    return 1;
+}
+
+static const PROV_GCM_HW s390x_aes_gcm = {
+    s390x_aes_gcm_init_key,
+    s390x_aes_gcm_setiv,
+    s390x_aes_gcm_aad_update,
+    s390x_aes_gcm_cipher_update,
+    s390x_aes_gcm_cipher_final,
+    s390x_aes_gcm_one_shot
+};
+
+const PROV_GCM_HW *PROV_AES_HW_gcm(size_t keybits)
+{
+    if ((keybits == 128 &amp;&amp; S390X_aes_128_gcm_CAPABLE)
+         || (keybits == 192 &amp;&amp; S390X_aes_192_gcm_CAPABLE)
+         || (keybits == 256 &amp;&amp; S390X_aes_256_gcm_CAPABLE))
+        return &amp;s390x_aes_gcm;
+    return &amp;aes_gcm;
+}
diff --git a/providers/common/include/internal/provider_algs.h b/providers/common/include/internal/provider_algs.h
index 80946ca6e2..741b07b750 100644
--- a/providers/common/include/internal/provider_algs.h
+++ b/providers/common/include/internal/provider_algs.h
@@ -57,6 +57,14 @@ extern const OSSL_DISPATCH aes128cfb8_functions[];
 extern const OSSL_DISPATCH aes256ctr_functions[];
 extern const OSSL_DISPATCH aes192ctr_functions[];
 extern const OSSL_DISPATCH aes128ctr_functions[];
+extern const OSSL_DISPATCH aes256gcm_functions[];
+extern const OSSL_DISPATCH aes192gcm_functions[];
+extern const OSSL_DISPATCH aes128gcm_functions[];
+#ifndef OPENSSL_NO_ARIA
+extern const OSSL_DISPATCH aria256gcm_functions[];
+extern const OSSL_DISPATCH aria192gcm_functions[];
+extern const OSSL_DISPATCH aria128gcm_functions[];
+#endif /* OPENSSL_NO_ARIA */
 
 /* Key management */
 extern const OSSL_DISPATCH dh_keymgmt_functions[];
diff --git a/providers/common/include/internal/providercommonerr.h b/providers/common/include/internal/providercommonerr.h
index d1af68f57b..c52dbd30f8 100644
--- a/providers/common/include/internal/providercommonerr.h
+++ b/providers/common/include/internal/providercommonerr.h
@@ -49,7 +49,10 @@ int ERR_load_PROV_strings(void);
 # define PROV_R_CIPHER_OPERATION_FAILED                   102
 # define PROV_R_FAILED_TO_GET_PARAMETER                   103
 # define PROV_R_FAILED_TO_SET_PARAMETER                   104
+# define PROV_R_INVALID_AAD                               108
+# define PROV_R_INVALID_IVLEN                             109
 # define PROV_R_INVALID_KEYLEN                            105
+# define PROV_R_INVALID_TAG                               110
 # define PROV_R_OUTPUT_BUFFER_TOO_SMALL                   106
 # define PROV_R_WRONG_FINAL_BLOCK_LENGTH                  107
 
diff --git a/providers/common/provider_err.c b/providers/common/provider_err.c
index 320aee8a10..7f07625a59 100644
--- a/providers/common/provider_err.c
+++ b/providers/common/provider_err.c
@@ -23,7 +23,10 @@ static const ERR_STRING_DATA PROV_str_reasons[] = {
     &quot;failed to get parameter&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_FAILED_TO_SET_PARAMETER),
     &quot;failed to set parameter&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_AAD), &quot;invalid aad&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_IVLEN), &quot;invalid ivlen&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_KEYLEN), &quot;invalid keylen&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_TAG), &quot;invalid tag&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_OUTPUT_BUFFER_TOO_SMALL),
     &quot;output buffer too small&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_WRONG_FINAL_BLOCK_LENGTH),
diff --git a/providers/default/defltprov.c b/providers/default/defltprov.c
index 95534b1155..6e4c94c61c 100644
--- a/providers/default/defltprov.c
+++ b/providers/default/defltprov.c
@@ -111,6 +111,14 @@ static const OSSL_ALGORITHM deflt_ciphers[] = {
     { &quot;AES-256-CTR&quot;, &quot;default=yes&quot;, aes256ctr_functions },
     { &quot;AES-192-CTR&quot;, &quot;default=yes&quot;, aes192ctr_functions },
     { &quot;AES-128-CTR&quot;, &quot;default=yes&quot;, aes128ctr_functions },
+    { &quot;id-aes256-GCM&quot;, &quot;default=yes&quot;, aes256gcm_functions },
+    { &quot;id-aes192-GCM&quot;, &quot;default=yes&quot;, aes192gcm_functions },
+    { &quot;id-aes128-GCM&quot;, &quot;default=yes&quot;, aes128gcm_functions },
+#ifndef OPENSSL_NO_ARIA
+    { &quot;ARIA-256-GCM&quot;, &quot;default=yes&quot;, aria256gcm_functions },
+    { &quot;ARIA-192-GCM&quot;, &quot;default=yes&quot;, aria192gcm_functions },
+    { &quot;ARIA-128-GCM&quot;, &quot;default=yes&quot;, aria128gcm_functions },
+#endif /* OPENSSL_NO_ARIA */
     { NULL, NULL, NULL }
 };
 
diff --git a/providers/fips/fipsprov.c b/providers/fips/fipsprov.c
index b62bfeec39..d82074fd20 100644
--- a/providers/fips/fipsprov.c
+++ b/providers/fips/fipsprov.c
@@ -250,6 +250,9 @@ static const OSSL_ALGORITHM fips_ciphers[] = {
     { &quot;AES-256-CTR&quot;, &quot;fips=yes&quot;, aes256ctr_functions },
     { &quot;AES-192-CTR&quot;, &quot;fips=yes&quot;, aes192ctr_functions },
     { &quot;AES-128-CTR&quot;, &quot;fips=yes&quot;, aes128ctr_functions },
+    { &quot;id-aes256-GCM&quot;, &quot;fips=yes&quot;, aes256gcm_functions },
+    { &quot;id-aes192-GCM&quot;, &quot;fips=yes&quot;, aes192gcm_functions },
+    { &quot;id-aes128-GCM&quot;, &quot;fips=yes&quot;, aes128gcm_functions },
     { NULL, NULL, NULL }
 };
 
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024222.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="024228.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24225">[ date ]</a>
              <a href="thread.html#24225">[ thread ]</a>
              <a href="subject.html#24225">[ subject ]</a>
              <a href="author.html#24225">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
