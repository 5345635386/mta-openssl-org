<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  OpenSSL_1_0_2-stable update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2018-August/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20OpenSSL_1_0_2-stable%20update&In-Reply-To=%3C1535477769.939111.12206.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020063.html">
   <LINK REL="Next"  HREF="019919.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  OpenSSL_1_0_2-stable update</H1>
    <B>Andy Polyakov</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20OpenSSL_1_0_2-stable%20update&In-Reply-To=%3C1535477769.939111.12206.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  OpenSSL_1_0_2-stable update">appro at openssl.org
       </A><BR>
    <I>Tue Aug 28 17:36:09 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="020063.html">[openssl-commits] [openssl]  OpenSSL_1_0_2-stable update
</A></li>
        <LI>Next message: <A HREF="019919.html">[openssl-commits] Build failed: openssl OpenSSL_1_1_0-stable.19200
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20065">[ date ]</a>
              <a href="thread.html#20065">[ thread ]</a>
              <a href="subject.html#20065">[ subject ]</a>
              <a href="author.html#20065">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch OpenSSL_1_0_2-stable has been updated
       via  bc251459adc14a1a56d0cbe2d372f3d6ffd20cf8 (commit)
       via  b6f773b8d6c41e86c107b57dabc637c91884150e (commit)
       via  f9381fd323303316282331a8cced6e030e809794 (commit)
       via  387d170b32ceeac450bfa50b81db9db9179dc880 (commit)
      from  19096672b48b3282bb9f11c4adadbcdd545f54a3 (commit)


- Log -----------------------------------------------------------------
commit bc251459adc14a1a56d0cbe2d372f3d6ffd20cf8
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Wed Aug 15 15:46:35 2018 +0200

    bn/bn_lib.c: conceal even memmory access pattern in bn2binpad.
    
    (cherry picked from commit 324b95605225410763fe63f7cff36eb46ca54ee9)
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6942">https://github.com/openssl/openssl/pull/6942</A>)

commit b6f773b8d6c41e86c107b57dabc637c91884150e
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon Aug 13 16:59:08 2018 +0200

    bn/bn_blind.c: use Montgomery multiplication when possible.
    
    (cherry picked from commit e02c519cd32a55e6ad39a0cfbeeda775f9115f28)
    
    Resolved conflicts:
    	crypto/bn/bn_blind.c
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6942">https://github.com/openssl/openssl/pull/6942</A>)

commit f9381fd323303316282331a8cced6e030e809794
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon Aug 13 20:20:28 2018 +0200

    rsa/rsa_eay.c: implement variant of &quot;Smooth CRT-RSA.&quot;
    
    In [most common] case of p and q being of same width, it's possible to
    replace CRT modulo operations with Montgomery reductions. And those are
    even fixed-length Montgomery reductions...
    
    (cherry picked from commit 41bfd5e7c8ac3a0874a94e4d15c006ad5eb48e59)
    
    Resolved conflicts:
    	crypto/rsa/rsa_eay.c
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6942">https://github.com/openssl/openssl/pull/6942</A>)

commit 387d170b32ceeac450bfa50b81db9db9179dc880
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Fri Aug 10 19:31:22 2018 +0200

    crypto/bn: add more fixed-top routines.
    
    Add bn_mul_fixed_top, bn_from_mont_fixed_top, bn_mod_sub_fixed_top.
    Switch to bn_{mul|sqr}_fixed_top in bn_mul_mont_fixed_top and remove
    memset in bn_from_montgomery_word.
    
    (cherry picked from commit fcc4ee09473cac511eca90faa003661c7786e4f9)
    
    Resolved conflicts:
    	crypto/bn/bn_mod.c
    	crypto/bn_int.h
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6942">https://github.com/openssl/openssl/pull/6942</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/bn/bn_blind.c |  63 ++++++++++++++++++++++----------
 crypto/bn/bn_lib.c   |  34 ++++++++++++-----
 crypto/bn/bn_mod.c   |  67 +++++++++++++++++++++++++++++++++-
 crypto/bn/bn_mont.c  |  29 ++++++++++-----
 crypto/bn/bn_mul.c   |  12 +++++-
 crypto/bn/bn_sqr.c   |  12 +++++-
 crypto/bn_int.h      |   6 +++
 crypto/rsa/rsa_eay.c | 101 ++++++++++++++++++++++++++++++++++++++++++---------
 8 files changed, 264 insertions(+), 60 deletions(-)

diff --git a/crypto/bn/bn_blind.c b/crypto/bn/bn_blind.c
index d448daa..40e1bb6 100644
--- a/crypto/bn/bn_blind.c
+++ b/crypto/bn/bn_blind.c
@@ -206,10 +206,15 @@ int BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx)
         if (!BN_BLINDING_create_param(b, NULL, NULL, ctx, NULL, NULL))
             goto err;
     } else if (!(b-&gt;flags &amp; BN_BLINDING_NO_UPDATE)) {
-        if (!BN_mod_mul(b-&gt;A, b-&gt;A, b-&gt;A, b-&gt;mod, ctx))
-            goto err;
-        if (!BN_mod_mul(b-&gt;Ai, b-&gt;Ai, b-&gt;Ai, b-&gt;mod, ctx))
-            goto err;
+        if (b-&gt;m_ctx != NULL) {
+            if (!bn_mul_mont_fixed_top(b-&gt;Ai, b-&gt;Ai, b-&gt;Ai, b-&gt;m_ctx, ctx)
+                || !bn_mul_mont_fixed_top(b-&gt;A, b-&gt;A, b-&gt;A, b-&gt;m_ctx, ctx))
+                goto err;
+        } else {
+            if (!BN_mod_mul(b-&gt;Ai, b-&gt;Ai, b-&gt;Ai, b-&gt;mod, ctx)
+                || !BN_mod_mul(b-&gt;A, b-&gt;A, b-&gt;A, b-&gt;mod, ctx))
+                goto err;
+        }
     }
 
     ret = 1;
@@ -241,13 +246,13 @@ int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *ctx)
     else if (!BN_BLINDING_update(b, ctx))
         return (0);
 
-    if (r != NULL) {
-        if (!BN_copy(r, b-&gt;Ai))
-            ret = 0;
-    }
+    if (r != NULL &amp;&amp; (BN_copy(r, b-&gt;Ai) == NULL))
+        return 0;
 
-    if (!BN_mod_mul(n, n, b-&gt;A, b-&gt;mod, ctx))
-        ret = 0;
+    if (b-&gt;m_ctx != NULL)
+        ret = BN_mod_mul_montgomery(n, n, b-&gt;A, b-&gt;m_ctx, ctx);
+    else
+        ret = BN_mod_mul(n, n, b-&gt;A, b-&gt;mod, ctx);
 
     return ret;
 }
@@ -264,14 +269,29 @@ int BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b,
 
     bn_check_top(n);
 
-    if (r != NULL)
-        ret = BN_mod_mul(n, n, r, b-&gt;mod, ctx);
-    else {
-        if (b-&gt;Ai == NULL) {
-            BNerr(BN_F_BN_BLINDING_INVERT_EX, BN_R_NOT_INITIALIZED);
-            return (0);
+    if (r == NULL &amp;&amp; (r = b-&gt;Ai) == NULL) {
+        BNerr(BN_F_BN_BLINDING_INVERT_EX, BN_R_NOT_INITIALIZED);
+        return 0;
+    }
+
+    if (b-&gt;m_ctx != NULL) {
+        /* ensure that BN_mod_mul_montgomery takes pre-defined path */
+        if (n-&gt;dmax &gt;= r-&gt;top) {
+            size_t i, rtop = r-&gt;top, ntop = n-&gt;top;
+            BN_ULONG mask;
+
+            for (i = 0; i &lt; rtop; i++) {
+                mask = (BN_ULONG)0 - ((i - ntop) &gt;&gt; (8 * sizeof(i) - 1));
+                n-&gt;d[i] &amp;= mask;
+            }
+            mask = (BN_ULONG)0 - ((rtop - ntop) &gt;&gt; (8 * sizeof(ntop) - 1));
+            /* always true, if (rtop &gt;= ntop) n-&gt;top = r-&gt;top; */
+            n-&gt;top = (int)(rtop &amp; ~mask) | (ntop &amp; mask);
+            n-&gt;flags |= (BN_FLG_FIXED_TOP &amp; ~mask);
         }
-        ret = BN_mod_mul(n, n, b-&gt;Ai, b-&gt;mod, ctx);
+        ret = BN_mod_mul_montgomery(n, n, r, b-&gt;m_ctx, ctx);
+    } else {
+        ret = BN_mod_mul(n, n, r, b-&gt;mod, ctx);
     }
 
     bn_check_top(n);
@@ -366,14 +386,19 @@ BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,
     } while (1);
 
     if (ret-&gt;bn_mod_exp != NULL &amp;&amp; ret-&gt;m_ctx != NULL) {
-        if (!ret-&gt;bn_mod_exp
-            (ret-&gt;A, ret-&gt;A, ret-&gt;e, ret-&gt;mod, ctx, ret-&gt;m_ctx))
+        if (!ret-&gt;bn_mod_exp(ret-&gt;A, ret-&gt;A, ret-&gt;e, ret-&gt;mod, ctx, ret-&gt;m_ctx))
             goto err;
     } else {
         if (!BN_mod_exp(ret-&gt;A, ret-&gt;A, ret-&gt;e, ret-&gt;mod, ctx))
             goto err;
     }
 
+    if (ret-&gt;m_ctx != NULL) {
+        if (!bn_to_mont_fixed_top(ret-&gt;Ai, ret-&gt;Ai, ret-&gt;m_ctx, ctx)
+            || !bn_to_mont_fixed_top(ret-&gt;A, ret-&gt;A, ret-&gt;m_ctx, ctx))
+            goto err;
+    }
+
     return ret;
  err:
     if (b == NULL &amp;&amp; ret != NULL) {
diff --git a/crypto/bn/bn_lib.c b/crypto/bn/bn_lib.c
index 03bd8cd..8f1042b 100644
--- a/crypto/bn/bn_lib.c
+++ b/crypto/bn/bn_lib.c
@@ -617,26 +617,40 @@ BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)
 static int bn2binpad(const BIGNUM *a, unsigned char *to, int tolen)
 {
     int n;
-    size_t i, inc, lasti, j;
+    size_t i, lasti, j, atop, mask;
     BN_ULONG l;
 
+    /*
+     * In case |a| is fixed-top, BN_num_bytes can return bogus length,
+     * but it's assumed that fixed-top inputs ought to be &quot;nominated&quot;
+     * even for padded output, so it works out...
+     */
     n = BN_num_bytes(a);
-    if (tolen == -1)
+    if (tolen == -1) {
         tolen = n;
-    else if (tolen &lt; n)
-        return -1;
+    } else if (tolen &lt; n) {     /* uncommon/unlike case */
+        BIGNUM temp = *a;
 
-    if (n == 0) {
+        bn_correct_top(&amp;temp);
+        n = BN_num_bytes(&amp;temp);
+        if (tolen &lt; n)
+            return -1;
+    }
+
+    /* Swipe through whole available data and don't give away padded zero. */
+    atop = a-&gt;dmax * BN_BYTES;
+    if (atop == 0) {
         OPENSSL_cleanse(to, tolen);
         return tolen;
     }
 
-    lasti = n - 1;
-    for (i = 0, inc = 1, j = tolen; j &gt; 0;) {
+    lasti = atop - 1;
+    atop = a-&gt;top * BN_BYTES;
+    for (i = 0, j = 0, to += tolen; j &lt; (size_t)tolen; j++) {
         l = a-&gt;d[i / BN_BYTES];
-        to[--j] = (unsigned char)(l &gt;&gt; (8 * (i % BN_BYTES)) &amp; (0 - inc));
-        inc = (i - lasti) &gt;&gt; (8 * sizeof(i) - 1);
-        i += inc; /* stay on top limb */
+        mask = 0 - ((j - atop) &gt;&gt; (8 * sizeof(i) - 1));
+        *--to = (unsigned char)(l &gt;&gt; (8 * (i % BN_BYTES)) &amp; mask);
+        i += (i - lasti) &gt;&gt; (8 * sizeof(i) - 1); /* stay on last limb */
     }
 
     return tolen;
diff --git a/crypto/bn/bn_mod.c b/crypto/bn/bn_mod.c
index 43da462..255e6e4 100644
--- a/crypto/bn/bn_mod.c
+++ b/crypto/bn/bn_mod.c
@@ -172,7 +172,7 @@ int bn_mod_add_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
 
     if (mtop &gt; sizeof(storage) / sizeof(storage[0])
         &amp;&amp; (tp = OPENSSL_malloc(mtop * sizeof(BN_ULONG))) == NULL)
-	return 0;
+        return 0;
 
     ap = a-&gt;d != NULL ? a-&gt;d : tp;
     bp = b-&gt;d != NULL ? b-&gt;d : tp;
@@ -197,6 +197,7 @@ int bn_mod_add_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
         ((volatile BN_ULONG *)tp)[i] = 0;
     }
     r-&gt;top = mtop;
+    r-&gt;flags |= BN_FLG_FIXED_TOP;
     r-&gt;neg = 0;
 
     if (tp != storage)
@@ -225,6 +226,70 @@ int BN_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,
 }
 
 /*
+ * BN_mod_sub variant that may be used if both a and b are non-negative,
+ * a is less than m, while b is of same bit width as m. It's implemented
+ * as subtraction followed by two conditional additions.
+ *
+ * 0 &lt;= a &lt; m
+ * 0 &lt;= b &lt; 2^w &lt; 2*m
+ *
+ * after subtraction
+ *
+ * -2*m &lt; r = a - b &lt; m
+ *
+ * Thus it takes up to two conditional additions to make |r| positive.
+ */
+int bn_mod_sub_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
+                         const BIGNUM *m)
+{
+    size_t i, ai, bi, mtop = m-&gt;top;
+    BN_ULONG borrow, carry, ta, tb, mask, *rp;
+    const BN_ULONG *ap, *bp;
+
+    if (bn_wexpand(r, m-&gt;top) == NULL)
+        return 0;
+
+    rp = r-&gt;d;
+    ap = a-&gt;d != NULL ? a-&gt;d : rp;
+    bp = b-&gt;d != NULL ? b-&gt;d : rp;
+
+    for (i = 0, ai = 0, bi = 0, borrow = 0; i &lt; mtop;) {
+        mask = (BN_ULONG)0 - ((i - a-&gt;top) &gt;&gt; (8 * sizeof(i) - 1));
+        ta = ap[ai] &amp; mask;
+
+        mask = (BN_ULONG)0 - ((i - b-&gt;top) &gt;&gt; (8 * sizeof(i) - 1));
+        tb = bp[bi] &amp; mask;
+        rp[i] = ta - tb - borrow;
+        if (ta != tb)
+            borrow = (ta &lt; tb);
+
+        i++;
+        ai += (i - a-&gt;dmax) &gt;&gt; (8 * sizeof(i) - 1);
+        bi += (i - b-&gt;dmax) &gt;&gt; (8 * sizeof(i) - 1);
+    }
+    ap = m-&gt;d;
+    for (i = 0, mask = 0 - borrow, carry = 0; i &lt; mtop; i++) {
+        ta = ((ap[i] &amp; mask) + carry) &amp; BN_MASK2;
+        carry = (ta &lt; carry);
+        rp[i] = (rp[i] + ta) &amp; BN_MASK2;
+        carry += (rp[i] &lt; ta);
+    }
+    borrow -= carry;
+    for (i = 0, mask = 0 - borrow, carry = 0; i &lt; mtop; i++) {
+        ta = ((ap[i] &amp; mask) + carry) &amp; BN_MASK2;
+        carry = (ta &lt; carry);
+        rp[i] = (rp[i] + ta) &amp; BN_MASK2;
+        carry += (rp[i] &lt; ta);
+    }
+
+    r-&gt;top = mtop;
+    r-&gt;flags |= BN_FLG_FIXED_TOP;
+    r-&gt;neg = 0;
+
+    return 1;
+}
+
+/*
  * BN_mod_sub variant that may be used if both a and b are non-negative and
  * less than m
  */
diff --git a/crypto/bn/bn_mont.c b/crypto/bn/bn_mont.c
index d41434a..76eca50 100644
--- a/crypto/bn/bn_mont.c
+++ b/crypto/bn/bn_mont.c
@@ -164,10 +164,10 @@ int bn_mul_mont_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
 
     bn_check_top(tmp);
     if (a == b) {
-        if (!BN_sqr(tmp, a, ctx))
+        if (!bn_sqr_fixed_top(tmp, a, ctx))
             goto err;
     } else {
-        if (!BN_mul(tmp, a, b, ctx))
+        if (!bn_mul_fixed_top(tmp, a, b, ctx))
             goto err;
     }
     /* reduce from aRR to aR */
@@ -190,6 +190,7 @@ static int bn_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont)
     BIGNUM *n;
     BN_ULONG *ap, *np, *rp, n0, v, carry;
     int nl, max, i;
+    unsigned int rtop;
 
     n = &amp;(mont-&gt;N);
     nl = n-&gt;top;
@@ -207,12 +208,10 @@ static int bn_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont)
     rp = r-&gt;d;
 
     /* clear the top words of T */
-# if 1
-    for (i = r-&gt;top; i &lt; max; i++) /* memset? XXX */
-        rp[i] = 0;
-# else
-    memset(&amp;(rp[r-&gt;top]), 0, (max - r-&gt;top) * sizeof(BN_ULONG));
-# endif
+    for (rtop = r-&gt;top, i = 0; i &lt; max; i++) {
+        v = (BN_ULONG)0 - ((i - rtop) &gt;&gt; (8 * sizeof(rtop) - 1));
+        rp[i] &amp;= v;
+    }
 
     r-&gt;top = max;
     r-&gt;flags |= BN_FLG_FIXED_TOP;
@@ -263,6 +262,18 @@ static int bn_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont)
 int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
                        BN_CTX *ctx)
 {
+    int retn;
+
+    retn = bn_from_mont_fixed_top(ret, a, mont, ctx);
+    bn_correct_top(ret);
+    bn_check_top(ret);
+
+    return retn;
+}
+
+int bn_from_mont_fixed_top(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
+                           BN_CTX *ctx)
+{
     int retn = 0;
 #ifdef MONT_WORD
     BIGNUM *t;
@@ -270,8 +281,6 @@ int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,
     BN_CTX_start(ctx);
     if ((t = BN_CTX_get(ctx)) &amp;&amp; BN_copy(t, a)) {
         retn = bn_from_montgomery_word(ret, t, mont);
-        bn_correct_top(ret);
-        bn_check_top(ret);
     }
     BN_CTX_end(ctx);
 #else                           /* !MONT_WORD */
diff --git a/crypto/bn/bn_mul.c b/crypto/bn/bn_mul.c
index 6b455a7..f44e5e5 100644
--- a/crypto/bn/bn_mul.c
+++ b/crypto/bn/bn_mul.c
@@ -936,6 +936,16 @@ void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l, int n2,
 
 int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
 {
+    int ret = bn_mul_fixed_top(r, a, b, ctx);
+
+    bn_correct_top(r);
+    bn_check_top(r);
+
+    return ret;
+}
+
+int bn_mul_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
+{
     int ret = 0;
     int top, al, bl;
     BIGNUM *rr;
@@ -1042,7 +1052,7 @@ int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
 #if defined(BN_MUL_COMBA) || defined(BN_RECURSION)
  end:
 #endif
-    bn_correct_top(rr);
+    rr-&gt;flags |= BN_FLG_FIXED_TOP;
     if (r != rr &amp;&amp; BN_copy(r, rr) == NULL)
         goto err;
 
diff --git a/crypto/bn/bn_sqr.c b/crypto/bn/bn_sqr.c
index 5e69297..44bc554 100644
--- a/crypto/bn/bn_sqr.c
+++ b/crypto/bn/bn_sqr.c
@@ -66,6 +66,16 @@
  */
 int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)
 {
+    int ret = bn_sqr_fixed_top(r, a, ctx);
+
+    bn_correct_top(r);
+    bn_check_top(r);
+
+    return ret;
+}
+
+int bn_sqr_fixed_top(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)
+{
     int max, al;
     int ret = 0;
     BIGNUM *tmp, *rr;
@@ -136,7 +146,7 @@ int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)
 
     rr-&gt;neg = 0;
     rr-&gt;top = max;
-    bn_correct_top(rr);
+    rr-&gt;flags |= BN_FLG_FIXED_TOP;
     if (r != rr &amp;&amp; BN_copy(r, rr) == NULL)
         goto err;
 
diff --git a/crypto/bn_int.h b/crypto/bn_int.h
index 9c42d6f..a552cc2 100644
--- a/crypto/bn_int.h
+++ b/crypto/bn_int.h
@@ -7,9 +7,15 @@
  */
 int bn_mul_mont_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                           BN_MONT_CTX *mont, BN_CTX *ctx);
+int bn_from_mont_fixed_top(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont,
+                           BN_CTX *ctx);
 int bn_to_mont_fixed_top(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont,
                          BN_CTX *ctx);
 int bn_mod_add_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                          const BIGNUM *m);
+int bn_mod_sub_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
+                         const BIGNUM *m);
+int bn_mul_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
+int bn_sqr_fixed_top(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx);
 
 int bn_bn2binpad(const BIGNUM *a, unsigned char *to, int tolen);
diff --git a/crypto/rsa/rsa_eay.c b/crypto/rsa/rsa_eay.c
index 7ba24e3..1bb121f 100644
--- a/crypto/rsa/rsa_eay.c
+++ b/crypto/rsa/rsa_eay.c
@@ -224,8 +224,8 @@ static int RSA_eay_public_encrypt(int flen, const unsigned char *from,
     }
 
     if (rsa-&gt;flags &amp; RSA_FLAG_CACHE_PUBLIC)
-        if (!BN_MONT_CTX_set_locked
-            (&amp;rsa-&gt;_method_mod_n, CRYPTO_LOCK_RSA, rsa-&gt;n, ctx))
+        if (!BN_MONT_CTX_set_locked(&amp;rsa-&gt;_method_mod_n, CRYPTO_LOCK_RSA,
+                                    rsa-&gt;n, ctx))
             goto err;
 
     if (!rsa-&gt;meth-&gt;bn_mod_exp(ret, f, rsa-&gt;e, rsa-&gt;n, ctx,
@@ -432,8 +432,8 @@ static int RSA_eay_private_encrypt(int flen, const unsigned char *from,
             d = rsa-&gt;d;
 
         if (rsa-&gt;flags &amp; RSA_FLAG_CACHE_PUBLIC)
-            if (!BN_MONT_CTX_set_locked
-                (&amp;rsa-&gt;_method_mod_n, CRYPTO_LOCK_RSA, rsa-&gt;n, ctx))
+            if (!BN_MONT_CTX_set_locked(&amp;rsa-&gt;_method_mod_n, CRYPTO_LOCK_RSA,
+                                        rsa-&gt;n, ctx))
                 goto err;
 
         if (!rsa-&gt;meth-&gt;bn_mod_exp(ret, f, d, rsa-&gt;n, ctx,
@@ -554,8 +554,8 @@ static int RSA_eay_private_decrypt(int flen, const unsigned char *from,
             d = rsa-&gt;d;
 
         if (rsa-&gt;flags &amp; RSA_FLAG_CACHE_PUBLIC)
-            if (!BN_MONT_CTX_set_locked
-                (&amp;rsa-&gt;_method_mod_n, CRYPTO_LOCK_RSA, rsa-&gt;n, ctx))
+            if (!BN_MONT_CTX_set_locked(&amp;rsa-&gt;_method_mod_n, CRYPTO_LOCK_RSA,
+                                        rsa-&gt;n, ctx))
                 goto err;
         if (!rsa-&gt;meth-&gt;bn_mod_exp(ret, f, d, rsa-&gt;n, ctx,
                                    rsa-&gt;_method_mod_n))
@@ -660,8 +660,8 @@ static int RSA_eay_public_decrypt(int flen, const unsigned char *from,
     }
 
     if (rsa-&gt;flags &amp; RSA_FLAG_CACHE_PUBLIC)
-        if (!BN_MONT_CTX_set_locked
-            (&amp;rsa-&gt;_method_mod_n, CRYPTO_LOCK_RSA, rsa-&gt;n, ctx))
+        if (!BN_MONT_CTX_set_locked(&amp;rsa-&gt;_method_mod_n, CRYPTO_LOCK_RSA,
+                                    rsa-&gt;n, ctx))
             goto err;
 
     if (!rsa-&gt;meth-&gt;bn_mod_exp(ret, f, rsa-&gt;e, rsa-&gt;n, ctx,
@@ -708,7 +708,7 @@ static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
     BIGNUM *r1, *m1, *vrfy;
     BIGNUM local_dmp1, local_dmq1, local_c, local_r1;
     BIGNUM *dmp1, *dmq1, *c, *pr1;
-    int ret = 0;
+    int ret = 0, smooth = 0;
 
     BN_CTX_start(ctx);
     r1 = BN_CTX_get(ctx);
@@ -737,20 +737,63 @@ static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
         }
 
         if (rsa-&gt;flags &amp; RSA_FLAG_CACHE_PRIVATE) {
-            if (!BN_MONT_CTX_set_locked
-                (&amp;rsa-&gt;_method_mod_p, CRYPTO_LOCK_RSA, p, ctx))
+            if (!BN_MONT_CTX_set_locked(&amp;rsa-&gt;_method_mod_p, CRYPTO_LOCK_RSA,
+                                        p, ctx))
                 goto err;
-            if (!BN_MONT_CTX_set_locked
-                (&amp;rsa-&gt;_method_mod_q, CRYPTO_LOCK_RSA, q, ctx))
+            if (!BN_MONT_CTX_set_locked(&amp;rsa-&gt;_method_mod_q, CRYPTO_LOCK_RSA,
+                                        q, ctx))
                 goto err;
+
+            smooth = (rsa-&gt;meth-&gt;bn_mod_exp == BN_mod_exp_mont)
+                     &amp;&amp; (BN_num_bits(q) == BN_num_bits(p));
         }
     }
 
     if (rsa-&gt;flags &amp; RSA_FLAG_CACHE_PUBLIC)
-        if (!BN_MONT_CTX_set_locked
-            (&amp;rsa-&gt;_method_mod_n, CRYPTO_LOCK_RSA, rsa-&gt;n, ctx))
+        if (!BN_MONT_CTX_set_locked(&amp;rsa-&gt;_method_mod_n, CRYPTO_LOCK_RSA,
+                                    rsa-&gt;n, ctx))
+            goto err;
+
+    if (smooth) {
+        /*
+         * Conversion from Montgomery domain, a.k.a. Montgomery reduction,
+         * accepts values in [0-m*2^w) range. w is m's bit width rounded up
+         * to limb width. So that at the very least if |I| is fully reduced,
+         * i.e. less than p*q, we can count on from-to round to perform
+         * below modulo operations on |I|. Unlike BN_mod it's constant time.
+         */
+        if (/* m1 = I moq q */
+            !bn_from_mont_fixed_top(m1, I, rsa-&gt;_method_mod_q, ctx)
+            || !bn_to_mont_fixed_top(m1, m1, rsa-&gt;_method_mod_q, ctx)
+            /* m1 = m1^dmq1 mod q */
+            || !BN_mod_exp_mont_consttime(m1, m1, rsa-&gt;dmq1, rsa-&gt;q, ctx,
+                                          rsa-&gt;_method_mod_q)
+            /* r1 = I mod p */
+            || !bn_from_mont_fixed_top(r1, I, rsa-&gt;_method_mod_p, ctx)
+            || !bn_to_mont_fixed_top(r1, r1, rsa-&gt;_method_mod_p, ctx)
+            /* r1 = r1^dmp1 mod p */
+            || !BN_mod_exp_mont_consttime(r1, r1, rsa-&gt;dmp1, rsa-&gt;p, ctx,
+                                          rsa-&gt;_method_mod_p)
+            /* r1 = (r1 - m1) mod p */
+            /*
+             * bn_mod_sub_fixed_top is not regular modular subtraction,
+             * it can tolerate subtrahend to be larger than modulus, but
+             * not bit-wise wider. This makes up for uncommon q&gt;p case,
+             * when |m1| can be larger than |rsa-&gt;p|.
+             */
+            || !bn_mod_sub_fixed_top(r1, r1, m1, rsa-&gt;p)
+
+            /* r0 = r0 * iqmp mod p */
+            || !bn_to_mont_fixed_top(r1, r1, rsa-&gt;_method_mod_p, ctx)
+            || !bn_mul_mont_fixed_top(r1, r1, rsa-&gt;iqmp, rsa-&gt;_method_mod_p,
+                                      ctx)
+            || !bn_mul_fixed_top(r0, r1, rsa-&gt;q, ctx)
+            || !bn_mod_add_fixed_top(r0, r0, m1, rsa-&gt;n))
             goto err;
 
+        goto tail;
+    }
+
     /* compute I mod q */
     if (!(rsa-&gt;flags &amp; RSA_FLAG_NO_CONSTTIME)) {
         c = &amp;local_c;
@@ -828,10 +871,18 @@ static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
     if (!BN_add(r0, r1, m1))
         goto err;
 
+ tail:
     if (rsa-&gt;e &amp;&amp; rsa-&gt;n) {
-        if (!rsa-&gt;meth-&gt;bn_mod_exp(vrfy, r0, rsa-&gt;e, rsa-&gt;n, ctx,
-                                   rsa-&gt;_method_mod_n))
-            goto err;
+        if (rsa-&gt;meth-&gt;bn_mod_exp == BN_mod_exp_mont) {
+            if (!BN_mod_exp_mont(vrfy, r0, rsa-&gt;e, rsa-&gt;n, ctx,
+                                 rsa-&gt;_method_mod_n))
+                goto err;
+        } else {
+            bn_correct_top(r0);
+            if (!rsa-&gt;meth-&gt;bn_mod_exp(vrfy, r0, rsa-&gt;e, rsa-&gt;n, ctx,
+                                       rsa-&gt;_method_mod_n))
+                goto err;
+        }
         /*
          * If 'I' was greater than (or equal to) rsa-&gt;n, the operation will
          * be equivalent to using 'I mod n'. However, the result of the
@@ -840,6 +891,11 @@ static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
          */
         if (!BN_sub(vrfy, vrfy, I))
             goto err;
+        if (BN_is_zero(vrfy)) {
+            bn_correct_top(r0);
+            ret = 1;
+            goto err;   /* not actually error */
+        }
         if (!BN_mod(vrfy, vrfy, rsa-&gt;n, ctx))
             goto err;
         if (BN_is_negative(vrfy))
@@ -865,6 +921,15 @@ static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
                 goto err;
         }
     }
+    /*
+     * It's unfortunate that we have to bn_correct_top(r0). What hopefully
+     * saves the day is that correction is highly unlike, and private key
+     * operations are customarily performed on blinded message. Which means
+     * that attacker won't observe correlation with chosen plaintext.
+     * Secondly, remaining code would still handle it in same computational
+     * time and even conceal memory access pattern around corrected top.
+     */
+    bn_correct_top(r0);
     ret = 1;
  err:
     BN_CTX_end(ctx);
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020063.html">[openssl-commits] [openssl]  OpenSSL_1_0_2-stable update
</A></li>
	<LI>Next message: <A HREF="019919.html">[openssl-commits] Build failed: openssl OpenSSL_1_1_0-stable.19200
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20065">[ date ]</a>
              <a href="thread.html#20065">[ thread ]</a>
              <a href="subject.html#20065">[ subject ]</a>
              <a href="author.html#20065">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
