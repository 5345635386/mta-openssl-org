<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-August/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1597928612.539380.24649.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030232.html">
   <LINK REL="Next"  HREF="030238.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>dev at ddvo.net</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1597928612.539380.24649.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">dev at ddvo.net
       </A><BR>
    <I>Thu Aug 20 13:03:32 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="030232.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="030238.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30234">[ date ]</a>
              <a href="thread.html#30234">[ thread ]</a>
              <a href="subject.html#30234">[ subject ]</a>
              <a href="author.html#30234">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  2a33470b4f23bcf1cd66bbf645c855142efa0ed9 (commit)
       via  b3c5aadf4ce3dc2207cc605726bf370a55b531c9 (commit)
      from  ed4faae00cdab23244704660c099e41ec64f5dc0 (commit)


- Log -----------------------------------------------------------------
commit 2a33470b4f23bcf1cd66bbf645c855142efa0ed9
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Sun Aug 16 15:25:27 2020 +0200

    Make better use of new load_cert_pass() variant of load_cert() in apps/
    
    allows loading password-protected PKCS#12 files in x509, ca, s_client, s_server
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12647">https://github.com/openssl/openssl/pull/12647</A>)

commit b3c5aadf4ce3dc2207cc605726bf370a55b531c9
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Fri Aug 14 21:58:34 2020 +0200

    apps: make use of OSSL_STORE for generalized certs and CRLs loading
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12647">https://github.com/openssl/openssl/pull/12647</A>)

-----------------------------------------------------------------------

Summary of changes:
 apps/ca.c                        |  46 ++++-----
 apps/cmp.c                       | 144 +++------------------------
 apps/cms.c                       |   3 +-
 apps/include/apps.h              |  11 ++-
 apps/lib/apps.c                  | 203 ++++++++++++++-------------------------
 apps/lib/s_cb.c                  |   3 +-
 apps/ocsp.c                      |  11 +--
 apps/pkcs12.c                    |  21 +++-
 apps/s_client.c                  |  15 ++-
 apps/s_server.c                  |  22 ++---
 apps/smime.c                     |   3 +-
 apps/verify.c                    |   8 +-
 apps/x509.c                      |   8 +-
 doc/man1/openssl-ca.pod.in       |  10 +-
 doc/man1/openssl-cmp.pod.in      |  12 +--
 doc/man1/openssl-cms.pod.in      |   1 +
 doc/man1/openssl-ocsp.pod.in     |  12 ++-
 doc/man1/openssl-pkcs12.pod.in   |  23 +++--
 doc/man1/openssl-s_client.pod.in |   8 +-
 doc/man1/openssl-s_server.pod.in |  10 +-
 doc/man1/openssl-smime.pod.in    |   1 +
 doc/man1/openssl-verify.pod.in   |   7 +-
 doc/man1/openssl-x509.pod.in     |   3 +-
 test/certs/v3-certs-RC2.p12      | Bin 0 -&gt; 1568 bytes
 test/certs/v3-certs-TDES.p12     | Bin 0 -&gt; 1568 bytes
 test/recipes/25-test_x509.t      |  13 ++-
 test/recipes/80-test_pkcs12.t    |  25 ++++-
 27 files changed, 258 insertions(+), 365 deletions(-)
 create mode 100644 test/certs/v3-certs-RC2.p12
 create mode 100644 test/certs/v3-certs-TDES.p12

diff --git a/apps/ca.c b/apps/ca.c
index fef0b82c39..8a5104f488 100644
--- a/apps/ca.c
+++ b/apps/ca.c
@@ -106,7 +106,7 @@ static int certify(X509 **xret, const char *infile, int informat,
                    int verbose, unsigned long certopt, unsigned long nameopt,
                    int default_op, int ext_copy, int selfsign);
 static int certify_cert(X509 **xret, const char *infile, int informat,
-                        EVP_PKEY *pkey, X509 *x509,
+                        const char *passin, EVP_PKEY *pkey, X509 *x509,
                         const EVP_MD *dgst,
                         STACK_OF(OPENSSL_STRING) *sigopts,
                         STACK_OF(OPENSSL_STRING) *vfyopts,
@@ -214,17 +214,17 @@ const OPTIONS ca_options[] = {
 
     OPT_SECTION(&quot;Signing&quot;),
     {&quot;md&quot;, OPT_MD, 's', &quot;md to use; one of md2, md5, sha or sha1&quot;},
-    {&quot;keyfile&quot;, OPT_KEYFILE, 's', &quot;Private key&quot;},
+    {&quot;keyfile&quot;, OPT_KEYFILE, 's', &quot;The CA private key&quot;},
     {&quot;keyform&quot;, OPT_KEYFORM, 'f', &quot;Private key file format (ENGINE, other values ignored)&quot;},
-    {&quot;passin&quot;, OPT_PASSIN, 's', &quot;Input file pass phrase source&quot;},
-    {&quot;key&quot;, OPT_KEY, 's', &quot;Key to decode the private key if it is encrypted&quot;},
+    {&quot;passin&quot;, OPT_PASSIN, 's', &quot;Key and cert input file pass phrase source&quot;},
+    {&quot;key&quot;, OPT_KEY, 's', &quot;Key to decrypt key or cert files. Better use -passin&quot;},
     {&quot;cert&quot;, OPT_CERT, '&lt;', &quot;The CA cert&quot;},
     {&quot;certform&quot;, OPT_CERTFORM, 'F',
-     &quot;certificate input format (DER/PEM/P12); has no effect&quot;},
+     &quot;Certificate input format (DER/PEM/P12); has no effect&quot;},
     {&quot;selfsign&quot;, OPT_SELFSIGN, '-',
      &quot;Sign a cert with the key associated with it&quot;},
     {&quot;sigopt&quot;, OPT_SIGOPT, 's', &quot;Signature parameter in n:v form&quot;},
-    {&quot;vfyopt&quot;, OPT_SIGOPT, 's', &quot;Verification parameter in n:v form&quot;},
+    {&quot;vfyopt&quot;, OPT_VFYOPT, 's', &quot;Verification parameter in n:v form&quot;},
 
     OPT_SECTION(&quot;Revocation&quot;),
     {&quot;gencrl&quot;, OPT_GENCRL, '-', &quot;Generate a new CRL&quot;},
@@ -272,10 +272,11 @@ int ca_main(int argc, char **argv)
     const EVP_MD *dgst = NULL;
     char *configfile = default_config_file, *section = NULL;
     char *md = NULL, *policy = NULL, *keyfile = NULL;
-    char *certfile = NULL, *crl_ext = NULL, *crlnumberfile = NULL, *key = NULL;
+    char *certfile = NULL, *crl_ext = NULL, *crlnumberfile = NULL;
     int certformat = FORMAT_PEM, informat = FORMAT_PEM;
     const char *infile = NULL, *spkac_file = NULL, *ss_cert_file = NULL;
     const char *extensions = NULL, *extfile = NULL, *passinarg = NULL;
+    char *passin = NULL;
     char *outdir = NULL, *outfile = NULL, *rev_arg = NULL, *ser_status = NULL;
     const char *serialfile = NULL, *subj = NULL;
     char *prog, *startdate = NULL, *enddate = NULL;
@@ -285,7 +286,7 @@ int ca_main(int argc, char **argv)
     char *const *pp;
     const char *p;
     size_t outdirlen = 0;
-    int create_ser = 0, free_key = 0, total = 0, total_done = 0;
+    int create_ser = 0, free_passin = 0, total = 0, total_done = 0;
     int batch = 0, default_op = 1, doupdatedb = 0, ext_copy = EXT_COPY_NONE;
     int keyformat = FORMAT_PEM, multirdn = 0, notext = 0, output_der = 0;
     int ret = 1, email_dn = 1, req = 0, verbose = 0, gencrl = 0, dorevoke = 0;
@@ -379,7 +380,7 @@ opthelp:
                 goto end;
             break;
         case OPT_KEY:
-            key = opt_arg();
+            passin = opt_arg();
             break;
         case OPT_CERT:
             certfile = opt_arg();
@@ -565,15 +566,14 @@ end_of_options:
         &amp;&amp; (keyfile = lookup_conf(conf, section, ENV_PRIVATE_KEY)) == NULL)
         goto end;
 
-    if (key == NULL) {
-        free_key = 1;
-        if (!app_passwd(passinarg, NULL, &amp;key, NULL)) {
+    if (passin == NULL) {
+        free_passin = 1;
+        if (!app_passwd(passinarg, NULL, &amp;passin, NULL)) {
             BIO_printf(bio_err, &quot;Error getting password\n&quot;);
             goto end;
         }
     }
-    pkey = load_key(keyfile, keyformat, 0, key, e, &quot;CA private key&quot;);
-    cleanse(key);
+    pkey = load_key(keyfile, keyformat, 0, passin, e, &quot;CA private key&quot;);
     if (pkey == NULL)
         /* load_key() has already printed an appropriate message */
         goto end;
@@ -585,7 +585,7 @@ end_of_options:
             &amp;&amp; (certfile = lookup_conf(conf, section, ENV_CERTIFICATE)) == NULL)
             goto end;
 
-        x509 = load_cert(certfile, certformat, &quot;CA certificate&quot;);
+        x509 = load_cert_pass(certfile, certformat, passin, &quot;CA certificate&quot;);
         if (x509 == NULL)
             goto end;
 
@@ -940,8 +940,8 @@ end_of_options:
         }
         if (ss_cert_file != NULL) {
             total++;
-            j = certify_cert(&amp;x, ss_cert_file, certformat, pkey, x509, dgst,
-                             sigopts, vfyopts, attribs,
+            j = certify_cert(&amp;x, ss_cert_file, certformat, passin, pkey,
+                             x509, dgst, sigopts, vfyopts, attribs,
                              db, serial, subj, chtype, multirdn, email_dn,
                              startdate, enddate, days, batch, extensions,
                              conf, verbose, certopt, get_nameopt(), default_op,
@@ -1262,7 +1262,8 @@ end_of_options:
             goto end;
         } else {
             X509 *revcert;
-            revcert = load_cert(infile, certformat, infile);
+
+            revcert = load_cert_pass(infile, certformat, passin, infile);
             if (revcert == NULL)
                 goto end;
             if (dorevoke == 2)
@@ -1291,8 +1292,9 @@ end_of_options:
     BIO_free_all(in);
     sk_X509_pop_free(cert_sk, X509_free);
 
-    if (free_key)
-        OPENSSL_free(key);
+    cleanse(passin);
+    if (free_passin)
+        OPENSSL_free(passin);
     BN_free(serial);
     BN_free(crlnumber);
     free_index(db);
@@ -1379,7 +1381,7 @@ static int certify(X509 **xret, const char *infile, int informat,
 }
 
 static int certify_cert(X509 **xret, const char *infile, int certformat,
-                        EVP_PKEY *pkey, X509 *x509,
+                        const char *passin, EVP_PKEY *pkey, X509 *x509,
                         const EVP_MD *dgst,
                         STACK_OF(OPENSSL_STRING) *sigopts,
                         STACK_OF(OPENSSL_STRING) *vfyopts,
@@ -1395,7 +1397,7 @@ static int certify_cert(X509 **xret, const char *infile, int certformat,
     EVP_PKEY *pktmp = NULL;
     int ok = -1, i;
 
-    if ((req = load_cert(infile, certformat, infile)) == NULL)
+    if ((req = load_cert_pass(infile, certformat, passin, infile)) == NULL)
         goto end;
     if (verbose)
         X509_print(bio_err, req);
diff --git a/apps/cmp.c b/apps/cmp.c
index b2afbf64e8..350aa22628 100644
--- a/apps/cmp.c
+++ b/apps/cmp.c
@@ -138,8 +138,6 @@ static char *opt_certform_s = &quot;PEM&quot;;
 static int opt_certform = FORMAT_PEM;
 static char *opt_keyform_s = &quot;PEM&quot;;
 static int opt_keyform = FORMAT_PEM;
-static char *opt_certsform_s = &quot;PEM&quot;;
-static int opt_certsform = FORMAT_PEM;
 static char *opt_otherpass = NULL;
 static char *opt_engine = NULL;
 
@@ -222,7 +220,7 @@ typedef enum OPTION_choice {
     OPT_DIGEST, OPT_MAC, OPT_EXTRACERTS,
     OPT_UNPROTECTED_REQUESTS,
 
-    OPT_CERTFORM, OPT_KEYFORM, OPT_CERTSFORM,
+    OPT_CERTFORM, OPT_KEYFORM,
     OPT_OTHERPASS,
 #ifndef OPENSSL_NO_ENGINE
     OPT_ENGINE,
@@ -394,12 +392,8 @@ const OPTIONS cmp_options[] = {
     OPT_SECTION(&quot;Credentials format&quot;),
     {&quot;certform&quot;, OPT_CERTFORM, 's',
      &quot;Format (PEM or DER) to use when saving a certificate to a file. Default PEM&quot;},
-    {OPT_MORE_STR, 0, 0,
-     &quot;This also determines format to use for writing (not supported for P12)&quot;},
     {&quot;keyform&quot;, OPT_KEYFORM, 's',
-     &quot;Format to assume when reading key files. Default PEM&quot;},
-    {&quot;certsform&quot;, OPT_CERTSFORM, 's',
-     &quot;Format (PEM/DER/P12) to try first reading multiple certs. Default PEM&quot;},
+     &quot;Format of the key input (ENGINE, other values ignored)&quot;},
     {&quot;otherpass&quot;, OPT_OTHERPASS, 's',
      &quot;Pass phrase source potentially needed for loading certificates of others&quot;},
 #ifndef OPENSSL_NO_ENGINE
@@ -540,7 +534,7 @@ static varref cmp_vars[] = { /* must be in same order as enumerated above! */
     {&amp;opt_digest}, {&amp;opt_mac}, {&amp;opt_extracerts},
     {(char **)&amp;opt_unprotected_requests},
 
-    {&amp;opt_certform_s}, {&amp;opt_keyform_s}, {&amp;opt_certsform_s},
+    {&amp;opt_certform_s}, {&amp;opt_keyform_s},
     {&amp;opt_otherpass},
 #ifndef OPENSSL_NO_ENGINE
     {&amp;opt_engine},
@@ -642,51 +636,6 @@ static X509 *load_cert_pwd(const char *uri, const char *pass, const char *desc)
     return cert;
 }
 
-/* TODO remove when PR #4930 is merged */
-static int load_pkcs12(BIO *in, const char *desc,
-                       pem_password_cb *pem_cb, void *cb_data,
-                       EVP_PKEY **pkey, X509 **cert, STACK_OF(X509) **ca)
-{
-    const char *pass;
-    char tpass[PEM_BUFSIZE];
-    int len;
-    int ret = 0;
-    PKCS12 *p12 = d2i_PKCS12_bio(in, NULL);
-
-    if (desc == NULL)
-        desc = &quot;PKCS12 input&quot;;
-    if (p12 == NULL) {
-        BIO_printf(bio_err, &quot;error loading PKCS12 file for %s\n&quot;, desc);
-        goto die;
-    }
-
-    /* See if an empty password will do */
-    if (PKCS12_verify_mac(p12, &quot;&quot;, 0) || PKCS12_verify_mac(p12, NULL, 0)) {
-        pass = &quot;&quot;;
-    } else {
-        if (pem_cb == NULL)
-            pem_cb = wrap_password_callback;
-        len = pem_cb(tpass, PEM_BUFSIZE, 0, cb_data);
-        if (len &lt; 0) {
-            BIO_printf(bio_err, &quot;passphrase callback error for %s\n&quot;, desc);
-            goto die;
-        }
-        if (len &lt; PEM_BUFSIZE)
-            tpass[len] = 0;
-        if (!PKCS12_verify_mac(p12, tpass, len)) {
-            BIO_printf(bio_err,
-                       &quot;mac verify error (wrong password?) in PKCS12 file for %s\n&quot;,
-                       desc);
-            goto die;
-        }
-        pass = tpass;
-    }
-    ret = PKCS12_parse(p12, pass, pkey, cert, ca);
- die:
-    PKCS12_free(p12);
-    return ret;
-}
-
 /* TODO potentially move this and related functions to apps/lib/apps.c */
 static int adjust_format(const char **infile, int format, int engine_ok)
 {
@@ -752,47 +701,6 @@ static X509_REQ *load_csr_autofmt(const char *infile, const char *desc)
     return csr;
 }
 
-/* TODO replace by calling generalized load_certs() when PR #4930 is merged */
-static int load_certs_preliminary(const char *file, STACK_OF(X509) **certs,
-                                  int format, const char *pass,
-                                  const char *desc)
-{
-    X509 *cert = NULL;
-    int ret = 0;
-
-    if (format == FORMAT_PKCS12) {
-        BIO *bio = bio_open_default(file, 'r', format);
-
-        if (bio != NULL) {
-            EVP_PKEY *pkey = NULL; /* pkey is needed until PR #4930 is merged */
-            PW_CB_DATA cb_data;
-
-            cb_data.password = pass;
-            cb_data.prompt_info = file;
-            ret = load_pkcs12(bio, desc, wrap_password_callback,
-                              &amp;cb_data, &amp;pkey, &amp;cert, certs);
-            EVP_PKEY_free(pkey);
-            BIO_free(bio);
-        }
-    } else if (format == FORMAT_ASN1) { /* load only one cert in this case */
-        CMP_warn1(&quot;can load only one certificate in DER format from %s&quot;, file);
-        cert = load_cert_pass(file, 0, pass, desc);
-    }
-    if (format == FORMAT_PKCS12 || format == FORMAT_ASN1) {
-        if (cert) {
-            if (*certs == NULL)
-                *certs = sk_X509_new_null();
-            if (*certs != NULL)
-                ret = sk_X509_insert(*certs, cert, 0);
-            else
-                X509_free(cert);
-        }
-    } else {
-        ret = load_certs(file, certs, format, pass, desc);
-    }
-    return ret;
-}
-
 static void warn_certs_expired(const char *file, STACK_OF(X509) **certs)
 {
     int i, res;
@@ -812,34 +720,20 @@ static void warn_certs_expired(const char *file, STACK_OF(X509) **certs)
     }
 }
 
-/*
- * TODO potentially move this and related functions to apps/lib/
- * or even better extend OSSL_STORE with type OSSL_STORE_INFO_CERTS
- */
-static int load_certs_autofmt(const char *infile, STACK_OF(X509) **certs,
-                              int exclude_http, const char *pass,
-                              const char *desc)
+static int load_certs_pwd(const char *infile, STACK_OF(X509) **certs,
+                          int exclude_http, const char *pass,
+                          const char *desc)
 {
     int ret = 0;
     char *pass_string;
-    BIO *bio_bak = bio_err;
-    int format = adjust_format(&amp;infile, opt_certsform, 0);
+    int format = adjust_format(&amp;infile, FORMAT_PEM, 0);
 
     if (exclude_http &amp;&amp; format == FORMAT_HTTP) {
         BIO_printf(bio_err, &quot;error: HTTP retrieval not allowed for %s\n&quot;, desc);
         return ret;
     }
     pass_string = get_passwd(pass, desc);
-    if (format != FORMAT_HTTP)
-        bio_err = NULL; /* do not show errors on more than one try */
-    ret = load_certs_preliminary(infile, certs, format, pass_string, desc);
-    bio_err = bio_bak;
-    if (!ret &amp;&amp; format != FORMAT_HTTP) {
-        int format2 = format == FORMAT_PEM ? FORMAT_ASN1 : FORMAT_PEM;
-
-        ERR_clear_error();
-        ret = load_certs_preliminary(infile, certs, format2, pass_string, desc);
-    }
+    ret = load_certs(infile, certs, pass_string, desc);
     clear_free(pass_string);
 
     if (ret)
@@ -1129,7 +1023,7 @@ static X509_STORE *load_certstore(char *input, const char *desc)
     while (input != NULL) {
         char *next = next_item(input);           \
 
-        if (!load_certs_autofmt(input, &amp;certs, 1, opt_otherpass, desc)
+        if (!load_certs_pwd(input, &amp;certs, 1, opt_otherpass, desc)
                 || !(store = sk_X509_to_store(store, certs))) {
             /* CMP_err(&quot;out of memory&quot;); */
             X509_STORE_free(store);
@@ -1160,7 +1054,7 @@ static STACK_OF(X509) *load_certs_multifile(char *files,
     while (files != NULL) {
         char *next = next_item(files);
 
-        if (!load_certs_autofmt(files, &amp;certs, 0, pass, desc))
+        if (!load_certs_pwd(files, &amp;certs, 0, pass, desc))
             goto err;
         if (!X509_add_certs(result, certs,
                             X509_ADD_FLAG_UP_REF | X509_ADD_FLAG_NO_DUP))
@@ -1256,13 +1150,6 @@ static int transform_opts(void)
         return 0;
     }
 
-    if (opt_certsform_s != NULL
-            &amp;&amp; !opt_format(opt_certsform_s, OPT_FMT_PEMDER | OPT_FMT_PKCS12,
-                           &amp;opt_certsform)) {
-        CMP_err(&quot;unknown option given for certificate list loading format&quot;);
-        return 0;
-    }
-
     return 1;
 }
 
@@ -1554,8 +1441,8 @@ static SSL_CTX *setup_ssl_ctx(OSSL_CMP_CTX *ctx, ENGINE *engine)
         X509 *cert;
         STACK_OF(X509) *certs = NULL;
 
-        if (!load_certs_autofmt(opt_tls_cert, &amp;certs, 0, opt_tls_keypass,
-                                &quot;TLS client certificate (optionally with chain)&quot;))
+        if (!load_certs_pwd(opt_tls_cert, &amp;certs, 0, opt_tls_keypass,
+                            &quot;TLS client certificate (optionally with chain)&quot;))
             /*
              * opt_tls_keypass is needed in case opt_tls_cert is an encrypted
              * PKCS#12 file
@@ -1722,8 +1609,8 @@ static int setup_protection_ctx(OSSL_CMP_CTX *ctx, ENGINE *engine)
         STACK_OF(X509) *certs = NULL;
         int ok;
 
-        if (!load_certs_autofmt(opt_cert, &amp;certs, 0, opt_keypass,
-                                &quot;CMP client certificate (and optionally extra certs)&quot;))
+        if (!load_certs_pwd(opt_cert, &amp;certs, 0, opt_keypass,
+                            &quot;CMP client certificate (and optionally extra certs)&quot;))
             /* opt_keypass is needed if opt_cert is an encrypted PKCS#12 file */
             goto err;
 
@@ -2666,9 +2553,6 @@ static int get_opts(int argc, char **argv)
         case OPT_KEYFORM:
             opt_keyform_s = opt_str(&quot;keyform&quot;);
             break;
-        case OPT_CERTSFORM:
-            opt_certsform_s = opt_str(&quot;certsform&quot;);
-            break;
         case OPT_OTHERPASS:
             opt_otherpass = opt_str(&quot;otherpass&quot;);
             break;
diff --git a/apps/cms.c b/apps/cms.c
index 7e48cc1c82..bcf2f44ce5 100644
--- a/apps/cms.c
+++ b/apps/cms.c
@@ -822,8 +822,7 @@ int cms_main(int argc, char **argv)
     }
 
     if (certfile != NULL) {
-        if (!load_certs(certfile, &amp;other, FORMAT_PEM, NULL,
-                        &quot;certificate file&quot;)) {
+        if (!load_certs(certfile, &amp;other, NULL, &quot;certificate file&quot;)) {
             ERR_print_errors(bio_err);
             goto end;
         }
diff --git a/apps/include/apps.h b/apps/include/apps.h
index 0e734a528e..8d1eb7c280 100644
--- a/apps/include/apps.h
+++ b/apps/include/apps.h
@@ -105,7 +105,7 @@ X509_REQ *load_csr(const char *file, int format, const char *desc);
 X509 *load_cert_pass(const char *uri, int maybe_stdin,
                      const char *pass, const char *desc);
 /* the format parameter is meanwhile not needed anymore and thus ignored */
-X509 *load_cert(const char *uri, int format, const char *desc);
+#define load_cert(uri, format, desc) load_cert_pass(uri, 0, NULL, desc)
 X509_CRL *load_crl(const char *uri, int format, const char *desc);
 void cleanse(char *str);
 void clear_free(char *str);
@@ -113,10 +113,15 @@ EVP_PKEY *load_key(const char *uri, int format, int maybe_stdin,
                    const char *pass, ENGINE *e, const char *desc);
 EVP_PKEY *load_pubkey(const char *uri, int format, int maybe_stdin,
                       const char *pass, ENGINE *e, const char *desc);
-int load_certs(const char *file, STACK_OF(X509) **certs, int format,
+int load_certs(const char *uri, STACK_OF(X509) **certs,
                const char *pass, const char *desc);
-int load_crls(const char *file, STACK_OF(X509_CRL) **crls, int format,
+int load_crls(const char *uri, STACK_OF(X509_CRL) **crls,
               const char *pass, const char *desc);
+int load_key_certs_crls(const char *uri, int maybe_stdin,
+                        const char *pass, const char *desc,
+                        EVP_PKEY **ppkey, EVP_PKEY **ppubkey,
+                        X509 **pcert, STACK_OF(X509) **pcerts,
+                        X509_CRL **pcrl, STACK_OF(X509_CRL) **pcrls);
 int load_key_cert_crl(const char *uri, int maybe_stdin,
                       const char *pass, const char *desc,
                       EVP_PKEY **ppkey, EVP_PKEY **ppubkey,
diff --git a/apps/lib/apps.c b/apps/lib/apps.c
index d19fdc2126..150df997b8 100644
--- a/apps/lib/apps.c
+++ b/apps/lib/apps.c
@@ -491,8 +491,8 @@ X509 *load_cert_pass(const char *uri, int maybe_stdin,
 
     if (desc == NULL)
         desc = &quot;certificate&quot;;
-    (void)load_key_cert_crl(uri, maybe_stdin, pass, desc,
-                            NULL, NULL, &amp;cert, NULL);
+    (void)load_key_certs_crls(uri, maybe_stdin, pass, desc,
+                              NULL, NULL, &amp;cert, NULL, NULL, NULL);
     if (cert == NULL) {
         BIO_printf(bio_err, &quot;Unable to load %s\n&quot;, desc);
         ERR_print_errors(bio_err);
@@ -500,12 +500,6 @@ X509 *load_cert_pass(const char *uri, int maybe_stdin,
     return cert;
 }
 
-/* the format parameter is meanwhile not needed anymore and thus ignored */
-X509 *load_cert(const char *uri, int format, const char *desc)
-{
-    return load_cert_pass(uri, 1, NULL, desc);
-}
-
 /* the format parameter is meanwhile not needed anymore and thus ignored */
 X509_CRL *load_crl(const char *uri, int format, const char *desc)
 {
@@ -513,8 +507,8 @@ X509_CRL *load_crl(const char *uri, int format, const char *desc)
 
     if (desc == NULL)
         desc = &quot;CRL&quot;;
-    (void)load_key_cert_crl(uri, 0, NULL, desc,
-                            NULL, NULL, NULL, &amp;crl);
+    (void)load_key_certs_crls(uri, 0, NULL, desc,
+                              NULL,  NULL, NULL, NULL, &amp;crl, NULL);
     if (crl == NULL) {
         BIO_printf(bio_err, &quot;Unable to load %s\n&quot;, desc);
         ERR_print_errors(bio_err);
@@ -593,8 +587,8 @@ EVP_PKEY *load_key(const char *uri, int format, int may_stdin,
 #endif
         }
     } else {
-        (void)load_key_cert_crl(uri, may_stdin, pass, desc,
-                                &amp;pkey, NULL, NULL, NULL);
+        (void)load_key_certs_crls(uri, may_stdin, pass, desc,
+                                  &amp;pkey, NULL, NULL, NULL, NULL, NULL);
     }
 
     if (pkey == NULL) {
@@ -632,8 +626,8 @@ EVP_PKEY *load_pubkey(const char *uri, int format, int maybe_stdin,
 #endif
         }
     } else {
-        (void)load_key_cert_crl(uri, maybe_stdin, pass, desc,
-                                NULL, &amp;pkey, NULL, NULL);
+        (void)load_key_certs_crls(uri, maybe_stdin, pass, desc,
+                                  NULL, &amp;pkey, NULL, NULL, NULL, NULL);
     }
     if (pkey == NULL) {
         BIO_printf(bio_err, &quot;Unable to load %s\n&quot;, desc);
@@ -642,89 +636,6 @@ EVP_PKEY *load_pubkey(const char *uri, int format, int maybe_stdin,
     return pkey;
 }
 
-static int load_certs_crls(const char *file, int format,
-                           const char *pass, const char *desc,
-                           STACK_OF(X509) **pcerts,
-                           STACK_OF(X509_CRL) **pcrls)
-{
-    int i;
-    BIO *bio;
-    STACK_OF(X509_INFO) *xis = NULL;
-    X509_INFO *xi;
-    PW_CB_DATA cb_data;
-    int rv = 0;
-
-    cb_data.password = pass;
-    cb_data.prompt_info = file;
-
-    if (format != FORMAT_PEM) {
-        BIO_printf(bio_err, &quot;Bad input format specified for %s\n&quot;, desc);
-        return 0;
-    }
-
-    bio = bio_open_default(file, 'r', FORMAT_PEM);
-    if (bio == NULL)
-        return 0;
-
-    xis = PEM_X509_INFO_read_bio_with_libctx(bio, NULL,
-                                             (pem_password_cb *)password_callback,
-                                             &amp;cb_data,
-                                             app_get0_libctx(),
-                                             app_get0_propq());
-
-    BIO_free(bio);
-
-    if (pcerts != NULL &amp;&amp; *pcerts == NULL) {
-        *pcerts = sk_X509_new_null();
-        if (*pcerts == NULL)
-            goto end;
-    }
-
-    if (pcrls != NULL &amp;&amp; *pcrls == NULL) {
-        *pcrls = sk_X509_CRL_new_null();
-        if (*pcrls == NULL)
-            goto end;
-    }
-
-    for (i = 0; i &lt; sk_X509_INFO_num(xis); i++) {
-        xi = sk_X509_INFO_value(xis, i);
-        if (xi-&gt;x509 != NULL &amp;&amp; pcerts != NULL) {
-            if (!sk_X509_push(*pcerts, xi-&gt;x509))
-                goto end;
-            xi-&gt;x509 = NULL;
-        }
-        if (xi-&gt;crl != NULL &amp;&amp; pcrls != NULL) {
-            if (!sk_X509_CRL_push(*pcrls, xi-&gt;crl))
-                goto end;
-            xi-&gt;crl = NULL;
-        }
-    }
-
-    if (pcerts != NULL &amp;&amp; sk_X509_num(*pcerts) &gt; 0)
-        rv = 1;
-
-    if (pcrls != NULL &amp;&amp; sk_X509_CRL_num(*pcrls) &gt; 0)
-        rv = 1;
-
- end:
-
-    sk_X509_INFO_pop_free(xis, X509_INFO_free);
-
-    if (rv == 0) {
-        if (pcerts != NULL) {
-            sk_X509_pop_free(*pcerts, X509_free);
-            *pcerts = NULL;
-        }
-        if (pcrls != NULL) {
-            sk_X509_CRL_pop_free(*pcrls, X509_CRL_free);
-            *pcrls = NULL;
-        }
-        BIO_printf(bio_err, &quot;Unable to load %s\n&quot;, desc != NULL ? desc :
-                   pcerts != NULL ? &quot;certificates&quot; : &quot;CRLs&quot;);
-    }
-    return rv;
-}
-
 void app_bail_out(char *fmt, ...)
 {
     va_list args;
@@ -749,37 +660,49 @@ void* app_malloc(int sz, const char *what)
 /*
  * Initialize or extend, if *certs != NULL, a certificate stack.
  */
-int load_certs(const char *file, STACK_OF(X509) **certs, int format,
+int load_certs(const char *uri, STACK_OF(X509) **certs,
                const char *pass, const char *desc)
 {
-    return load_certs_crls(file, format, pass, desc, certs, NULL);
+    return load_key_certs_crls(uri, 0, pass, desc, NULL, NULL,
+                               NULL, certs, NULL, NULL);
 }
 
 /*
  * Initialize or extend, if *crls != NULL, a certificate stack.
  */
-int load_crls(const char *file, STACK_OF(X509_CRL) **crls, int format,
+int load_crls(const char *uri, STACK_OF(X509_CRL) **crls,
               const char *pass, const char *desc)
 {
-    return load_certs_crls(file, format, pass, desc, NULL, crls);
+    return load_key_certs_crls(uri, 0, pass, desc, NULL, NULL,
+                               NULL, NULL, NULL, crls);
 }
 
 /*
  * Load those types of credentials for which the result pointer is not NULL.
  * Reads from stdio if uri is NULL and maybe_stdin is nonzero.
- * For each type the first credential found in the store is loaded.
- * May yield partial result even if rv == 0.
+ * For non-NULL ppkey, pcert, and pcrl the first suitable value found is loaded.
+ * If pcerts is non-NULL and *pcerts == NULL then a new cert list is allocated.
+ * If pcerts is non-NULL then all available certificates are appended to *pcerts
+ * except any certificate assigned to *pcert.
+ * If pcrls is non-NULL and *pcrls == NULL then a new list of CRLs is allocated.
+ * If pcrls is non-NULL then all available CRLs are appended to *pcerts
+ * except any CRL assigned to *pcrl.
+ * In any case (also on error) the caller is responsible for freeing all members
+ * of *pcerts and *pcrls (as far as they are not NULL).
  */
-int load_key_cert_crl(const char *uri, int maybe_stdin,
-                      const char *pass, const char *desc,
-                      EVP_PKEY **ppkey, EVP_PKEY **ppubkey,
-                      X509 **pcert, X509_CRL **pcrl)
+int load_key_certs_crls(const char *uri, int maybe_stdin,
+                        const char *pass, const char *desc,
+                        EVP_PKEY **ppkey, EVP_PKEY **ppubkey,
+                        X509 **pcert, STACK_OF(X509) **pcerts,
+                        X509_CRL **pcrl, STACK_OF(X509_CRL) **pcrls)
 {
     PW_CB_DATA uidata;
     OSSL_STORE_CTX *ctx = NULL;
     OPENSSL_CTX *libctx = app_get0_libctx();
     const char *propq = app_get0_propq();
-    int ret = 0;
+    int ncerts = 0;
+    int ncrls = 0;
+    const char *failed = NULL;
     /* TODO make use of the engine reference 'eng' when loading pkeys */
 
     if (ppkey != NULL)
@@ -788,8 +711,18 @@ int load_key_cert_crl(const char *uri, int maybe_stdin,
         *ppubkey = NULL;
     if (pcert != NULL)
         *pcert = NULL;
+    if (pcerts != NULL &amp;&amp; *pcerts == NULL
+            &amp;&amp; (*pcerts = sk_X509_new_null()) == NULL) {
+        BIO_printf(bio_err, &quot;Out of memory&quot;);
+        return 0;
+    }
     if (pcrl != NULL)
         *pcrl = NULL;
+    if (pcrls != NULL &amp;&amp; *pcrls == NULL
+            &amp;&amp; (*pcrls = sk_X509_CRL_new_null()) == NULL) {
+        BIO_printf(bio_err, &quot;Out of memory&quot;);
+        return 0;
+    }
 
     if (desc == NULL)
         desc = &quot;key/certificate/CRL&quot;;
@@ -799,6 +732,7 @@ int load_key_cert_crl(const char *uri, int maybe_stdin,
     if (uri == NULL) {
         BIO *bio;
 
+        uri = &quot;&lt;stdin&gt;&quot;;
         if (!maybe_stdin) {
             BIO_printf(bio_err, &quot;No filename or uri specified for loading %s\n&quot;,
                        desc);
@@ -809,7 +743,6 @@ int load_key_cert_crl(const char *uri, int maybe_stdin,
         if (bio != NULL)
             ctx = OSSL_STORE_attach(bio, &quot;file&quot;, libctx, propq,
                                     get_ui_method(), &amp;uidata, NULL, NULL);
-        uri = &quot;&lt;stdin&gt;&quot;;
     } else {
         ctx = OSSL_STORE_open_with_libctx(uri, libctx, propq, get_ui_method(),
                                           &amp;uidata, NULL, NULL);
@@ -820,61 +753,71 @@ int load_key_cert_crl(const char *uri, int maybe_stdin,
         goto end;
     }
 
-    for (;;) {
+    while (!OSSL_STORE_eof(ctx)) {
         OSSL_STORE_INFO *info = OSSL_STORE_load(ctx);
         int type = info == NULL ? 0 : OSSL_STORE_INFO_get_type(info);
-        const char *infostr =
-            info == NULL ? NULL : OSSL_STORE_INFO_type_string(type);
-        int err = 0;
-
-        if (info == NULL) {
-            if (OSSL_STORE_eof(ctx))
-                ret = 1;
-            break;
-        }
+        int ok = 1;
 
         switch (type) {
         case OSSL_STORE_INFO_PKEY:
             if (ppkey != NULL &amp;&amp; *ppkey == NULL)
-                err = ((*ppkey = OSSL_STORE_INFO_get1_PKEY(info)) == NULL);
+                ok = (*ppkey = OSSL_STORE_INFO_get1_PKEY(info)) != NULL;
 
             /*
              * An EVP_PKEY with private parts also holds the public parts,
              * so if the caller asked for a public key, and we got a private
              * key, we can still pass it back.
              */
-            if (ppubkey != NULL &amp;&amp; *ppubkey == NULL)
-                err = ((*ppubkey = OSSL_STORE_INFO_get1_PKEY(info)) == NULL);
+            if (ok &amp;&amp; ppubkey != NULL &amp;&amp; *ppubkey == NULL)
+                ok = ((*ppubkey = OSSL_STORE_INFO_get1_PKEY(info)) != NULL);
             break;
         case OSSL_STORE_INFO_PUBKEY:
             if (ppubkey != NULL &amp;&amp; *ppubkey == NULL)
-                err = ((*ppubkey = OSSL_STORE_INFO_get1_PUBKEY(info)) == NULL);
+                ok = ((*ppubkey = OSSL_STORE_INFO_get1_PUBKEY(info)) != NULL);
             break;
         case OSSL_STORE_INFO_CERT:
             if (pcert != NULL &amp;&amp; *pcert == NULL)
-                err = ((*pcert = OSSL_STORE_INFO_get1_CERT(info)) == NULL);
+                ok = (*pcert = OSSL_STORE_INFO_get1_CERT(info)) != NULL;
+            else if (pcerts != NULL)
+                ok = X509_add_cert(*pcerts,
+                                   OSSL_STORE_INFO_get1_CERT(info),
+                                   X509_ADD_FLAG_DEFAULT);
+            ncerts += ok;
             break;
         case OSSL_STORE_INFO_CRL:
             if (pcrl != NULL &amp;&amp; *pcrl == NULL)
-                err = ((*pcrl = OSSL_STORE_INFO_get1_CRL(info)) == NULL);
+                ok = (*pcrl = OSSL_STORE_INFO_get1_CRL(info)) != NULL;
+            else if (pcrls != NULL)
+                ok = sk_X509_CRL_push(*pcrls, OSSL_STORE_INFO_get1_CRL(info));
+            ncrls += ok;
             break;
         default:
             /* skip any other type */
             break;
         }
         OSSL_STORE_INFO_free(info);
-        if (err) {
-            BIO_printf(bio_err, &quot;Could not read %s of %s from %s\n&quot;,
-                       infostr, desc, uri);
+        if (!ok) {
+            failed = info == NULL ? NULL : OSSL_STORE_INFO_type_string(type);
+            BIO_printf(bio_err, &quot;Error reading %s of %s from %s\n&quot;,
+                       failed, desc, uri);
             break;
         }
     }
 
  end:
     OSSL_STORE_close(ctx);
-    if (!ret)
+    if (ppkey != NULL &amp;&amp; *ppkey == NULL)
+        failed = &quot;key&quot;;
+    else if ((pcert != NULL || pcerts != NULL) &amp;&amp; ncerts == 0)
+        failed = &quot;cert&quot;;
+    else if ((pcrl != NULL || pcrls != NULL) &amp;&amp; ncrls == 0)
+        failed = &quot;CRL&quot;;
+    if (failed != NULL) {
+        BIO_printf(bio_err, &quot;Could not read any %s of %s from %s\n&quot;,
+                   failed, desc, uri);
         ERR_print_errors(bio_err);
-    return ret;
+    }
+    return failed == NULL;
 }
 
 
diff --git a/apps/lib/s_cb.c b/apps/lib/s_cb.c
index ba9ef12afb..c58f634609 100644
--- a/apps/lib/s_cb.c
+++ b/apps/lib/s_cb.c
@@ -1040,8 +1040,7 @@ int load_excert(SSL_EXCERT **pexc)
         if (exc-&gt;key == NULL)
             return 0;
         if (exc-&gt;chainfile != NULL) {
-            if (!load_certs(exc-&gt;chainfile, &amp;exc-&gt;chain, FORMAT_PEM, NULL,
-                            &quot;Server Chain&quot;))
+            if (!load_certs(exc-&gt;chainfile, &amp;exc-&gt;chain, NULL, &quot;Server Chain&quot;))
                 return 0;
         }
     }
diff --git a/apps/ocsp.c b/apps/ocsp.c
index 4660a7fe5a..8fb605e6fe 100644
--- a/apps/ocsp.c
+++ b/apps/ocsp.c
@@ -567,11 +567,10 @@ int ocsp_main(int argc, char **argv)
             BIO_printf(bio_err, &quot;Error loading responder certificate\n&quot;);
             goto end;
         }
-        if (!load_certs(rca_filename, &amp;rca_cert, FORMAT_PEM,
-                        NULL, &quot;CA certificate&quot;))
+        if (!load_certs(rca_filename, &amp;rca_cert, NULL, &quot;CA certificates&quot;))
             goto end;
         if (rcertfile != NULL) {
-            if (!load_certs(rcertfile, &amp;rother, FORMAT_PEM, NULL,
+            if (!load_certs(rcertfile, &amp;rother, NULL,
                             &quot;responder other certificates&quot;))
                 goto end;
         }
@@ -665,7 +664,7 @@ redo_accept:
             goto end;
         }
         if (sign_certfile != NULL) {
-            if (!load_certs(sign_certfile, &amp;sign_other, FORMAT_PEM, NULL,
+            if (!load_certs(sign_certfile, &amp;sign_other, NULL,
                             &quot;signer certificates&quot;))
                 goto end;
         }
@@ -774,8 +773,8 @@ redo_accept:
     if (vpmtouched)
         X509_STORE_set1_param(store, vpm);
     if (verify_certfile != NULL) {
-        if (!load_certs(verify_certfile, &amp;verify_other, FORMAT_PEM, NULL,
-                        &quot;validator certificate&quot;))
+        if (!load_certs(verify_certfile, &amp;verify_other, NULL,
+                        &quot;validator certificates&quot;))
             goto end;
     }
 
diff --git a/apps/pkcs12.c b/apps/pkcs12.c
index 46340c0d25..60ede2e1a1 100644
--- a/apps/pkcs12.c
+++ b/apps/pkcs12.c
@@ -59,7 +59,7 @@ typedef enum OPTION_choice {
     OPT_CACERTS, OPT_NOOUT, OPT_INFO, OPT_CHAIN, OPT_TWOPASS, OPT_NOMACVER,
     OPT_DESCERT, OPT_EXPORT, OPT_ITER, OPT_NOITER, OPT_MACITER, OPT_NOMACITER,
     OPT_NOMAC, OPT_LMK, OPT_NODES, OPT_NOENC, OPT_MACALG, OPT_CERTPBE, OPT_KEYPBE,
-    OPT_INKEY, OPT_CERTFILE, OPT_NAME, OPT_CSP, OPT_CANAME,
+    OPT_INKEY, OPT_CERTFILE, OPT_PASSCERTS, OPT_NAME, OPT_CSP, OPT_CANAME,
     OPT_IN, OPT_OUT, OPT_PASSIN, OPT_PASSOUT, OPT_PASSWORD, OPT_CAPATH,
     OPT_CAFILE, OPT_CASTORE, OPT_NOCAPATH, OPT_NOCAFILE, OPT_NOCASTORE, OPT_ENGINE,
     OPT_R_ENUM, OPT_PROV_ENUM, OPT_LEGACY_ALG
@@ -87,6 +87,7 @@ const OPTIONS pkcs12_options[] = {
     OPT_SECTION(&quot;Input&quot;),
     {&quot;inkey&quot;, OPT_INKEY, 's', &quot;Private key if not infile&quot;},
     {&quot;certfile&quot;, OPT_CERTFILE, '&lt;', &quot;Load certs from file&quot;},
+    {&quot;passcerts&quot;, OPT_PASSCERTS, 's', &quot;Certificate file pass phrase source&quot;},
     {&quot;name&quot;, OPT_NAME, 's', &quot;Use name as friendly name&quot;},
     {&quot;CSP&quot;, OPT_CSP, 's', &quot;Microsoft CSP name&quot;},
     {&quot;caname&quot;, OPT_CANAME, 's',
@@ -143,6 +144,7 @@ const OPTIONS pkcs12_options[] = {
 int pkcs12_main(int argc, char **argv)
 {
     char *infile = NULL, *outfile = NULL, *keyname = NULL, *certfile = NULL;
+    char *passcertsarg = NULL, *passcerts = NULL;
     char *name = NULL, *csp_name = NULL;
     char pass[PASSWD_BUF_SIZE] = &quot;&quot;, macpass[PASSWD_BUF_SIZE] = &quot;&quot;;
     int export_cert = 0, options = 0, chain = 0, twopass = 0, keytype = 0, use_legacy = 0;
@@ -260,6 +262,9 @@ int pkcs12_main(int argc, char **argv)
         case OPT_CERTFILE:
             certfile = opt_arg();
             break;
+        case OPT_PASSCERTS:
+            passcertsarg = opt_arg();
+            break;
         case OPT_NAME:
             name = opt_arg();
             break;
@@ -322,6 +327,9 @@ int pkcs12_main(int argc, char **argv)
     }
     argc = opt_num_rest();
 
+    if (!export_cert &amp;&amp; passcertsarg != NULL)
+        BIO_printf(bio_err,
+                   &quot;Warning: -passcerts option ignored without -export\n&quot;);
     if (use_legacy) {
         /* load the legacy provider if not loaded already*/
         if (!OSSL_PROVIDER_available(app_get0_libctx(), &quot;legacy&quot;)) {
@@ -349,6 +357,11 @@ int pkcs12_main(int argc, char **argv)
 
     private = 1;
 
+    if (!app_passwd(passcertsarg, NULL, &amp;passcerts, NULL)) {
+        BIO_printf(bio_err, &quot;Error getting certificate file password\n&quot;);
+        goto end;
+    }
+
     if (passarg != NULL) {
         if (export_cert)
             passoutarg = passarg;
@@ -424,8 +437,7 @@ int pkcs12_main(int argc, char **argv)
 
         /* Load in all certs in input file */
         if (!(options &amp; NOCERTS)) {
-            if (!load_certs(infile, &amp;certs, FORMAT_PEM, NULL,
-                            &quot;certificates&quot;))
+            if (!load_certs(infile, &amp;certs, passin, &quot;input certificates&quot;))
                 goto export_end;
 
             if (key != NULL) {
@@ -453,7 +465,7 @@ int pkcs12_main(int argc, char **argv)
 
         /* Add any more certificates asked for */
         if (certfile != NULL) {
-            if (!load_certs(certfile, &amp;certs, FORMAT_PEM, NULL,
+            if (!load_certs(certfile, &amp;certs, passcerts,
                             &quot;certificates from certfile&quot;))
                 goto export_end;
         }
@@ -652,6 +664,7 @@ int pkcs12_main(int argc, char **argv)
     BIO_free_all(out);
     sk_OPENSSL_STRING_free(canames);
     OPENSSL_free(badpass);
+    OPENSSL_free(passcerts);
     OPENSSL_free(passin);
     OPENSSL_free(passout);
     return ret;
diff --git a/apps/s_client.c b/apps/s_client.c
index a1b80f4c5f..2a58589ce2 100644
--- a/apps/s_client.c
+++ b/apps/s_client.c
@@ -612,7 +612,7 @@ const OPTIONS s_client_options[] = {
     {&quot;host&quot;, OPT_HOST, 's', &quot;Use -connect instead&quot;},
     {&quot;port&quot;, OPT_PORT, 'p', &quot;Use -connect instead&quot;},
     {&quot;connect&quot;, OPT_CONNECT, 's',
-     &quot;TCP/IP where to connect (default is :&quot; PORT &quot;)&quot;},
+     &quot;TCP/IP where to connect; default: &quot; PORT &quot;)&quot;},
     {&quot;bind&quot;, OPT_BIND, 's', &quot;bind local address for connection&quot;},
     {&quot;proxy&quot;, OPT_PROXY, 's',
      &quot;Connect to via specified proxy to the real server&quot;},
@@ -643,9 +643,9 @@ const OPTIONS s_client_options[] = {
     {&quot;cert_chain&quot;, OPT_CERT_CHAIN, '&lt;',
      &quot;Client certificate chain file (in PEM format)&quot;},
     {&quot;build_chain&quot;, OPT_BUILD_CHAIN, '-', &quot;Build client certificate chain&quot;},
-    {&quot;key&quot;, OPT_KEY, 's', &quot;Private key file to use; default is: -cert file&quot;},
+    {&quot;key&quot;, OPT_KEY, 's', &quot;Private key file to use; default: -cert file&quot;},
     {&quot;keyform&quot;, OPT_KEYFORM, 'E', &quot;Key format (ENGINE, other values ignored)&quot;},
-    {&quot;pass&quot;, OPT_PASS, 's', &quot;Private key file pass phrase source&quot;},
+    {&quot;pass&quot;, OPT_PASS, 's', &quot;Private key and cert file pass phrase source&quot;},
     {&quot;verify&quot;, OPT_VERIFY, 'p', &quot;Turn on peer certificate verification&quot;},
     {&quot;nameopt&quot;, OPT_NAMEOPT, 's', &quot;Certificate subject/issuer name printing options&quot;},
     {&quot;CApath&quot;, OPT_CAPATH, '/', &quot;PEM format directory of CA's&quot;},
@@ -702,7 +702,7 @@ const OPTIONS s_client_options[] = {
     {&quot;keymatexport&quot;, OPT_KEYMATEXPORT, 's',
      &quot;Export keying material using label&quot;},
     {&quot;keymatexportlen&quot;, OPT_KEYMATEXPORTLEN, 'p',
-     &quot;Export len bytes of keying material (default 20)&quot;},
+     &quot;Export len bytes of keying material; default 20&quot;},
     {&quot;security_debug&quot;, OPT_SECURITY_DEBUG, '-',
      &quot;Enable security debug messages&quot;},
     {&quot;security_debug_verbose&quot;, OPT_SECURITY_DEBUG_VERBOSE, '-',
@@ -790,7 +790,7 @@ const OPTIONS s_client_options[] = {
     OPT_V_OPTIONS,
     {&quot;CRL&quot;, OPT_CRL, '&lt;', &quot;CRL file to use&quot;},
     {&quot;crl_download&quot;, OPT_CRL_DOWNLOAD, '-', &quot;Download CRL from distribution points&quot;},
-    {&quot;CRLform&quot;, OPT_CRLFORM, 'F', &quot;CRL format (PEM or DER) PEM is default&quot;},
+    {&quot;CRLform&quot;, OPT_CRLFORM, 'F', &quot;CRL format (PEM or DER); default PEM&quot;},
     {&quot;verify_return_error&quot;, OPT_VERIFY_RET_ERROR, '-',
      &quot;Close connection on verification error&quot;},
     {&quot;verify_quiet&quot;, OPT_VERIFY_QUIET, '-', &quot;Restrict verify output to errors&quot;},
@@ -1740,14 +1740,13 @@ int s_client_main(int argc, char **argv)
     }
 
     if (cert_file != NULL) {
-        cert = load_cert(cert_file, cert_format, &quot;client certificate file&quot;);
+        cert = load_cert_pass(cert_file, cert_format, pass, &quot;client certificate file&quot;);
         if (cert == NULL)
             goto end;
     }
 
     if (chain_file != NULL) {
-        if (!load_certs(chain_file, &amp;chain, FORMAT_PEM, NULL,
-                        &quot;client certificate chain&quot;))
+        if (!load_certs(chain_file, &amp;chain, pass, &quot;client certificate chain&quot;))
             goto end;
     }
 
diff --git a/apps/s_server.c b/apps/s_server.c
index 5f16dcdea4..b936ff4226 100644
--- a/apps/s_server.c
+++ b/apps/s_server.c
@@ -809,9 +809,9 @@ const OPTIONS s_server_options[] = {
     {&quot;Verify&quot;, OPT_UPPER_V_VERIFY, 'n',
      &quot;Turn on peer certificate verification, must have a cert&quot;},
     {&quot;nameopt&quot;, OPT_NAMEOPT, 's', &quot;Certificate subject/issuer name printing options&quot;},
-    {&quot;cert&quot;, OPT_CERT, '&lt;', &quot;Server certificate file to use; default is &quot; TEST_CERT},
+    {&quot;cert&quot;, OPT_CERT, '&lt;', &quot;Server certificate file to use; default &quot; TEST_CERT},
     {&quot;cert2&quot;, OPT_CERT2, '&lt;',
-     &quot;Certificate file to use for servername; default is&quot; TEST_CERT2},
+     &quot;Certificate file to use for servername; default &quot; TEST_CERT2},
     {&quot;certform&quot;, OPT_CERTFORM, 'F',
      &quot;Server certificate file format (PEM/DER/P12); has no effect&quot;},
     {&quot;cert_chain&quot;, OPT_CERT_CHAIN, '&lt;',
@@ -824,7 +824,7 @@ const OPTIONS s_server_options[] = {
     {&quot;key2&quot;, OPT_KEY2, '&lt;',
      &quot;-Private Key file to use for servername if not in -cert2&quot;},
     {&quot;keyform&quot;, OPT_KEYFORM, 'f', &quot;Key format (ENGINE, other values ignored)&quot;},
-    {&quot;pass&quot;, OPT_PASS, 's', &quot;Private key file pass phrase source&quot;},
+    {&quot;pass&quot;, OPT_PASS, 's', &quot;Private key and cert file pass phrase source&quot;},
     {&quot;dcert&quot;, OPT_DCERT, '&lt;',
      &quot;Second server certificate file to use (usually for DSA)&quot;},
     {&quot;dcertform&quot;, OPT_DCERTFORM, 'F',
@@ -835,16 +835,14 @@ const OPTIONS s_server_options[] = {
      &quot;Second private key file to use (usually for DSA)&quot;},
     {&quot;dkeyform&quot;, OPT_DKEYFORM, 'F',
      &quot;Second key file format (ENGINE, other values ignored)&quot;},
-    {&quot;dpass&quot;, OPT_DPASS, 's', &quot;Second private key file pass phrase source&quot;},
+    {&quot;dpass&quot;, OPT_DPASS, 's', &quot;Second private key and cert file pass phrase source&quot;},
     {&quot;dhparam&quot;, OPT_DHPARAM, '&lt;', &quot;DH parameters file to use&quot;},
     {&quot;servername&quot;, OPT_SERVERNAME, 's',
      &quot;Servername for HostName TLS extension&quot;},
     {&quot;servername_fatal&quot;, OPT_SERVERNAME_FATAL, '-',
      &quot;mismatch send fatal alert (default warning alert)&quot;},
-
     {&quot;nbio_test&quot;, OPT_NBIO_TEST, '-', &quot;Test with the non-blocking test bio&quot;},
     {&quot;crlf&quot;, OPT_CRLF, '-', &quot;Convert LF from terminal into CRLF&quot;},
-
     {&quot;quiet&quot;, OPT_QUIET, '-', &quot;No server output&quot;},
     {&quot;no_resume_ephemeral&quot;, OPT_NO_RESUME_EPHEMERAL, '-',
      &quot;Disable caching and tickets if ephemeral (EC)DH is used&quot;},
@@ -860,7 +858,7 @@ const OPTIONS s_server_options[] = {
     {&quot;keymatexport&quot;, OPT_KEYMATEXPORT, 's',
      &quot;Export keying material using label&quot;},
     {&quot;keymatexportlen&quot;, OPT_KEYMATEXPORTLEN, 'p',
-     &quot;Export len bytes of keying material (default 20)&quot;},
+     &quot;Export len bytes of keying material; default 20&quot;},
     {&quot;CRL&quot;, OPT_CRL, '&lt;', &quot;CRL file to use&quot;},
     {&quot;CRLform&quot;, OPT_CRLFORM, 'F', &quot;CRL file format (PEM or DER); default PEM&quot;},
     {&quot;crl_download&quot;, OPT_CRL_DOWNLOAD, '-',
@@ -1752,13 +1750,13 @@ int s_server_main(int argc, char *argv[])
         if (s_key == NULL)
             goto end;
 
-        s_cert = load_cert(s_cert_file, s_cert_format,
+        s_cert = load_cert_pass(s_cert_file, s_cert_format, pass,
                            &quot;server certificate file&quot;);
 
         if (s_cert == NULL)
             goto end;
         if (s_chain_file != NULL) {
-            if (!load_certs(s_chain_file, &amp;s_chain, FORMAT_PEM, NULL,
+            if (!load_certs(s_chain_file, &amp;s_chain, NULL,
                             &quot;server certificate chain&quot;))
                 goto end;
         }
@@ -1769,7 +1767,7 @@ int s_server_main(int argc, char *argv[])
             if (s_key2 == NULL)
                 goto end;
 
-            s_cert2 = load_cert(s_cert_file2, s_cert_format,
+            s_cert2 = load_cert_pass(s_cert_file2, s_cert_format, pass,
                                 &quot;second server certificate file&quot;);
 
             if (s_cert2 == NULL)
@@ -1814,7 +1812,7 @@ int s_server_main(int argc, char *argv[])
         if (s_dkey == NULL)
             goto end;
 
-        s_dcert = load_cert(s_dcert_file, s_dcert_format,
+        s_dcert = load_cert_pass(s_dcert_file, s_dcert_format, dpass,
                             &quot;second server certificate file&quot;);
 
         if (s_dcert == NULL) {
@@ -1822,7 +1820,7 @@ int s_server_main(int argc, char *argv[])
             goto end;
         }
         if (s_dchain_file != NULL) {
-            if (!load_certs(s_dchain_file, &amp;s_dchain, FORMAT_PEM, NULL,
+            if (!load_certs(s_dchain_file, &amp;s_dchain, NULL,
                             &quot;second server certificate chain&quot;))
                 goto end;
         }
diff --git a/apps/smime.c b/apps/smime.c
index 4dfc80d440..5ecdc019d2 100644
--- a/apps/smime.c
+++ b/apps/smime.c
@@ -449,8 +449,7 @@ int smime_main(int argc, char **argv)
     }
 
     if (certfile != NULL) {
-        if (!load_certs(certfile, &amp;other, FORMAT_PEM, NULL,
-                        &quot;certificate file&quot;)) {
+        if (!load_certs(certfile, &amp;other, NULL, &quot;certificates&quot;)) {
             ERR_print_errors(bio_err);
             goto end;
         }
diff --git a/apps/verify.c b/apps/verify.c
index c28f44571a..ed20b69b17 100644
--- a/apps/verify.c
+++ b/apps/verify.c
@@ -149,7 +149,7 @@ int verify_main(int argc, char **argv)
             break;
         case OPT_UNTRUSTED:
             /* Zero or more times */
-            if (!load_certs(opt_arg(), &amp;untrusted, FORMAT_PEM, NULL,
+            if (!load_certs(opt_arg(), &amp;untrusted, NULL,
                             &quot;untrusted certificates&quot;))
                 goto end;
             break;
@@ -158,14 +158,12 @@ int verify_main(int argc, char **argv)
             noCAfile = 1;
             noCApath = 1;
             noCAstore = 1;
-            if (!load_certs(opt_arg(), &amp;trusted, FORMAT_PEM, NULL,
-                            &quot;trusted certificates&quot;))
+            if (!load_certs(opt_arg(), &amp;trusted, NULL, &quot;trusted certificates&quot;))
                 goto end;
             break;
         case OPT_CRLFILE:
             /* Zero or more times */
-            if (!load_crls(opt_arg(), &amp;crls, FORMAT_PEM, NULL,
-                           &quot;other CRLs&quot;))
+            if (!load_crls(opt_arg(), &amp;crls, NULL, &quot;other CRLs&quot;))
                 goto end;
             break;
         case OPT_CRL_DOWNLOAD:
diff --git a/apps/x509.c b/apps/x509.c
index fbe4b8cefe..64a1cadc97 100644
--- a/apps/x509.c
+++ b/apps/x509.c
@@ -80,7 +80,7 @@ const OPTIONS x509_options[] = {
     {&quot;inform&quot;, OPT_INFORM, 'f',
      &quot;CSR input format (DER or PEM) - default PEM&quot;},
     {&quot;in&quot;, OPT_IN, '&lt;', &quot;Input file - default stdin&quot;},
-    {&quot;passin&quot;, OPT_PASSIN, 's', &quot;Private key password/pass-phrase source&quot;},
+    {&quot;passin&quot;, OPT_PASSIN, 's', &quot;Private key and cert file pass-phrase source&quot;},
     {&quot;outform&quot;, OPT_OUTFORM, 'f',
      &quot;Output format (DER or PEM) - default PEM&quot;},
     {&quot;out&quot;, OPT_OUT, '&gt;', &quot;Output file - default stdout&quot;},
@@ -633,7 +633,7 @@ int x509_main(int argc, char **argv)
         if (!X509_set_pubkey(x, fkey != NULL ? fkey : X509_REQ_get0_pubkey(req)))
             goto end;
     } else {
-        x = load_cert(infile, FORMAT_UNDEF, &quot;Certificate&quot;);
+        x = load_cert_pass(infile, FORMAT_UNDEF, passin, &quot;Certificate&quot;);
         if (x == NULL)
             goto end;
         if (fkey != NULL &amp;&amp; !X509_set_pubkey(x, fkey))
@@ -643,7 +643,7 @@ int x509_main(int argc, char **argv)
     }
 
     if (CA_flag) {
-        xca = load_cert(CAfile, CAformat, &quot;CA Certificate&quot;);
+        xca = load_cert_pass(CAfile, CAformat, passin, &quot;CA Certificate&quot;);
         if (xca == NULL)
             goto end;
     }
@@ -963,7 +963,7 @@ int x509_main(int argc, char **argv)
     sk_ASN1_OBJECT_pop_free(reject, ASN1_OBJECT_free);
     ASN1_OBJECT_free(objtmp);
     release_engine(e);
-    OPENSSL_free(passin);
+    clear_free(passin);
     return ret;
 }
 
diff --git a/doc/man1/openssl-ca.pod.in b/doc/man1/openssl-ca.pod.in
index 5f7dc2d16f..7d7f0752f3 100644
--- a/doc/man1/openssl-ca.pod.in
+++ b/doc/man1/openssl-ca.pod.in
@@ -138,9 +138,9 @@ The directory to output certificates to. The certificate will be
 written to a filename consisting of the serial number in hex with
 F&lt;.pem&gt; appended.
 
-=item B&lt;-cert&gt;
+=item B&lt;-cert&gt; I&lt;filename&gt;
 
-The CA certificate file.
+The CA certificate, which must match with B&lt;-keyfile&gt;.
 
 =item B&lt;-certform&gt; B&lt;DER&gt;|B&lt;PEM&gt;|B&lt;P12&gt;
 
@@ -149,7 +149,7 @@ This option has no effect and is retained for backward compatibility only.
 
 =item B&lt;-keyfile&gt; I&lt;filename&gt;
 
-The private key to sign requests with.
+The CA private key to sign requests with. This must match with B&lt;-cert&gt;.
 
 =item B&lt;-keyform&gt; B&lt;DER&gt;|B&lt;PEM&gt;|B&lt;P12&gt;|B&lt;ENGINE&gt;
 
@@ -179,6 +179,7 @@ The password used to encrypt the private key. Since on some
 systems the command line arguments are visible (e.g., when using
 L&lt;ps(1)&gt; on Unix),
 this option should be used with caution.
+Better use B&lt;-passin&gt;.
 
 =item B&lt;-selfsign&gt;
 
@@ -196,7 +197,8 @@ self-signed certificate.
 
 =item B&lt;-passin&gt; I&lt;arg&gt;
 
-The key password source. For more information about the format of B&lt;arg&gt;
+The key and certificate password source.
+For more information about the format of B&lt;arg&gt;
 see L&lt;openssl(1)/Pass Phrase Options&gt;.
 
 =item B&lt;-notext&gt;
diff --git a/doc/man1/openssl-cmp.pod.in b/doc/man1/openssl-cmp.pod.in
index 8d3e686b55..a6a769af9d 100644
--- a/doc/man1/openssl-cmp.pod.in
+++ b/doc/man1/openssl-cmp.pod.in
@@ -69,7 +69,6 @@ B&lt;openssl&gt; B&lt;cmp&gt;
 
 [B&lt;-certform&gt; I&lt;PEM|DER&gt;]
 [B&lt;-keyform&gt; I&lt;PEM|DER|P12|ENGINE&gt;]
-[B&lt;-certsform&gt; I&lt;PEM|DER|P12&gt;]
 [B&lt;-otherpass&gt; I&lt;arg&gt;]
 {- $OpenSSL::safe::opt_engine_synopsis -}
 {- $OpenSSL::safe::opt_provider_synopsis -}
@@ -681,15 +680,10 @@ Send messages without CMP-level protection.
 File format to use when saving a certificate to a file.
 Default value is PEM.
 
-=item B&lt;-keyform&gt; I&lt;PEM|DER|P12&gt;
+=item B&lt;-keyform&gt; I&lt;PEM|DER|P12|ENGINE&gt;
 
-Format to assume when reading key files.
-Default value is PEM.
-
-=item B&lt;-certsform&gt; I&lt;PEM|DER|P12&gt;
-
-Format to try first when reading multiple certificates from file(s).
-Default value is PEM.
+The format of the key input.
+The only value with effect is B&lt;ENGINE&gt;.
 
 =item B&lt;-otherpass&gt; I&lt;arg&gt;
 
diff --git a/doc/man1/openssl-cms.pod.in b/doc/man1/openssl-cms.pod.in
index a72b4c9fa0..def9766b3c 100644
--- a/doc/man1/openssl-cms.pod.in
+++ b/doc/man1/openssl-cms.pod.in
@@ -380,6 +380,7 @@ the MIME type multipart/signed is used.
 Allows additional certificates to be specified. When signing these will
 be included with the message. When verifying these will be searched for
 the signers certificates.
+The input can be in PEM, DER, or PKCS#12 format.
 
 =item B&lt;-certsout&gt; I&lt;file&gt;
 
diff --git a/doc/man1/openssl-ocsp.pod.in b/doc/man1/openssl-ocsp.pod.in
index a738ddbdd7..614a4dae83 100644
--- a/doc/man1/openssl-ocsp.pod.in
+++ b/doc/man1/openssl-ocsp.pod.in
@@ -130,6 +130,7 @@ the OCSP request is not signed.
 =item B&lt;-sign_other&gt; I&lt;filename&gt;
 
 Additional certificates to include in the signed request.
+The input can be in PEM, DER, or PKCS#12 format.
 
 =item B&lt;-nonce&gt;, B&lt;-no_nonce&gt;
 
@@ -180,10 +181,12 @@ the complete request is received.
 
 =item B&lt;-verify_other&gt; I&lt;file&gt;
 
-File containing additional certificates to search when attempting to locate
+File or URI containing additional certificates to search
+when attempting to locate
 the OCSP response signing certificate. Some responders omit the actual signer's
 certificate from the response: this option can be used to supply the necessary
 certificate in such cases.
+The input can be in PEM, DER, or PKCS#12 format.
 
 =item B&lt;-trust_other&gt;
 
@@ -194,8 +197,9 @@ root CA is not appropriate.
 
 =item B&lt;-VAfile&gt; I&lt;file&gt;
 
-File containing explicitly trusted responder certificates. Equivalent to the
-B&lt;-verify_other&gt; and B&lt;-trust_other&gt; options.
+File or URI containing explicitly trusted responder certificates.
+Equivalent to the B&lt;-verify_other&gt; and B&lt;-trust_other&gt; options.
+The input can be in PEM, DER, or PKCS#12 format.
 
 =item B&lt;-noverify&gt;
 
@@ -296,6 +300,7 @@ must also be present.
 
 CA certificate corresponding to the revocation information in the index
 file given with B&lt;-index&gt;.
+The input can be in PEM, DER, or PKCS#12 format.
 
 =item B&lt;-rsigner&gt; I&lt;file&gt;
 
@@ -314,6 +319,7 @@ see L&lt;openssl(1)/Pass Phrase Options&gt;.
 =item B&lt;-rother&gt; I&lt;file&gt;
 
 Additional certificates to include in the OCSP response.
+The input can be in PEM, DER, or PKCS#12 format.
 
 =item B&lt;-rsigopt&gt; I&lt;nm&gt;:I&lt;v&gt;
 
diff --git a/doc/man1/openssl-pkcs12.pod.in b/doc/man1/openssl-pkcs12.pod.in
index 90d8a7e19e..e148d229b0 100644
--- a/doc/man1/openssl-pkcs12.pod.in
+++ b/doc/man1/openssl-pkcs12.pod.in
@@ -13,6 +13,7 @@ B&lt;openssl&gt; B&lt;pkcs12&gt;
 [B&lt;-chain&gt;]
 [B&lt;-inkey&gt; I&lt;file_or_id&gt;]
 [B&lt;-certfile&gt; I&lt;filename&gt;]
+[B&lt;-passcerts&gt; I&lt;arg&gt;]
 [B&lt;-name&gt; I&lt;name&gt;]
 [B&lt;-caname&gt; I&lt;name&gt;]
 [B&lt;-in&gt; I&lt;filename&gt;]
@@ -85,8 +86,10 @@ Print out a usage message.
 
 =item B&lt;-in&gt; I&lt;filename&gt;
 
-This specifies filename of the PKCS#12 file to be parsed. Standard input is used
-by default.
+This specifies filename or URI of the PKCS#12 file to be parsed.
+With B&lt;-export&gt;, this refers to the the certificate and/or key input,
+which can be in PEM, DER, or PKCS#12 format.
+Standard input is used by default.
 
 =item B&lt;-out&gt; I&lt;filename&gt;
 
@@ -195,9 +198,10 @@ by default.
 
 =item B&lt;-in&gt; I&lt;filename&gt;
 
-The filename to read certificates and private keys from, standard input by
-default.  They must all be in PEM format. The order doesn't matter but one
-private key and its corresponding certificate should be present. If additional
+The filename or URI to read certificates and private keys from, standard input
+by default. They can be in PEM, DER, or PKCS#12 format.
+The order doesn't matter but one private key and
+its corresponding certificate should be present. If additional
 certificates are present they will also be included in the PKCS#12 file.
 
 =item B&lt;-inkey&gt; I&lt;file_or_id&gt;
@@ -214,7 +218,14 @@ name is typically displayed in list boxes by software importing the file.
 
 =item B&lt;-certfile&gt; I&lt;filename&gt;
 
-A filename to read additional certificates from.
+A filename or URI to read additional certificates from.
+The file can be in PEM, DER, or PKCS#12 format.
+
+=item B&lt;-passcerts&gt; I&lt;arg&gt;
+
+The password source for certificate input such as B&lt;-certfile&gt;.
+For more information about the format of B&lt;arg&gt;
+see the B&lt;PASS PHRASE ARGUMENTS&gt; section in L&lt;openssl(1)&gt;.
 
 =item B&lt;-caname&gt; I&lt;friendlyname&gt;
 
diff --git a/doc/man1/openssl-s_client.pod.in b/doc/man1/openssl-s_client.pod.in
index 6d8cb5a397..594d26f9bd 100644
--- a/doc/man1/openssl-s_client.pod.in
+++ b/doc/man1/openssl-s_client.pod.in
@@ -234,7 +234,7 @@ Suppresses sending of the SNI (Server Name Indication) extension in the
 ClientHello message. Cannot be used in conjunction with the B&lt;-servername&gt; or
 &lt;-dane_tlsa_domain&gt; options.
 
-=item B&lt;-cert&gt; I&lt;certname&gt;
+=item B&lt;-cert&gt; I&lt;filename&gt;
 
 The client certificate to use, if one is requested by the server.
 The default is not to use a certificate.
@@ -248,8 +248,9 @@ This option has no effect and is retained for backward compatibility only.
 
 =item B&lt;-cert_chain&gt;
 
-A file containing untrusted certificates to use when attempting to build the
+A file or URI of untrusted certificates to use when attempting to build the
 certificate chain related to the certificate specified via the B&lt;-cert&gt; option.
+The input can be in PEM, DER, or PKCS#12 format.
 
 =item B&lt;-build_chain&gt;
 
@@ -282,7 +283,8 @@ See L&lt;openssl(1)/Format Options&gt; for details.
 
 =item B&lt;-pass&gt; I&lt;arg&gt;
 
-the private key password source. For more information about the format of I&lt;arg&gt;
+the private key and certifiate file password source.
+For more information about the format of I&lt;arg&gt;
 see L&lt;openssl(1)/Pass phrase options&gt;.
 
 =item B&lt;-verify&gt; I&lt;depth&gt;
diff --git a/doc/man1/openssl-s_server.pod.in b/doc/man1/openssl-s_server.pod.in
index 47515af42a..b074485a63 100644
--- a/doc/man1/openssl-s_server.pod.in
+++ b/doc/man1/openssl-s_server.pod.in
@@ -228,8 +228,9 @@ This option has no effect and is retained for backward compatibility only.
 
 =item B&lt;-cert_chain&gt;
 
-A file containing untrusted certificates to use when attempting to build the
+A file or URI of untrusted certificates to use when attempting to build the
 certificate chain related to the certificate specified via the B&lt;-cert&gt; option.
+The input can be in PEM, DER, or PKCS#12 format.
 
 =item B&lt;-build_chain&gt;
 
@@ -257,7 +258,7 @@ See L&lt;openssl(1)/Format Options&gt; for details.
 
 =item B&lt;-pass&gt; I&lt;val&gt;
 
-The private key password source.
+The private key and certificate file password source.
 For more information about the format of I&lt;val&gt;,
 see L&lt;openssl(1)/Pass Phrase Options&gt;.
 
@@ -274,9 +275,10 @@ by using an appropriate certificate.
 
 =item B&lt;-dcert_chain&gt;
 
-A file containing untrusted certificates to use when attempting to build the
+A file or URI of untrusted certificates to use when attempting to build the
 server certificate chain when a certificate specified via the B&lt;-dcert&gt; option
 is in use.
+The input can be in PEM, DER, or PKCS#12 format.
 
 =item B&lt;-dcertform&gt; B&lt;DER&gt;|B&lt;PEM&gt;|B&lt;P12&gt;
 
@@ -291,7 +293,7 @@ See L&lt;openssl(1)/Format Options&gt;.
 
 =item B&lt;-dpass&gt; I&lt;val&gt;
 
-The passphrase for the additional private key.
+The passphrase for the additional private key and certificate.
 For more information about the format of I&lt;val&gt;,
 see L&lt;openssl(1)/Pass Phrase Options&gt;.
 
diff --git a/doc/man1/openssl-smime.pod.in b/doc/man1/openssl-smime.pod.in
index 9f42c0c1fe..3aa0dc49d2 100644
--- a/doc/man1/openssl-smime.pod.in
+++ b/doc/man1/openssl-smime.pod.in
@@ -238,6 +238,7 @@ option is present B&lt;CRLF&gt; is used instead.
 Allows additional certificates to be specified. When signing these will
 be included with the message. When verifying these will be searched for
 the signers certificates.
+The input can be in PEM, DER, or PKCS#12 format.
 
 =item B&lt;-signer&gt; I&lt;file&gt;
 
diff --git a/doc/man1/openssl-verify.pod.in b/doc/man1/openssl-verify.pod.in
index ff4d88f577..e9c2ca922c 100644
--- a/doc/man1/openssl-verify.pod.in
+++ b/doc/man1/openssl-verify.pod.in
@@ -40,7 +40,7 @@ Print out a usage message.
 
 =item B&lt;-CRLfile&gt; I&lt;file&gt;
 
-The I&lt;file&gt; should contain one or more CRLs in PEM format.
+The file or URI should contain one or more CRLs in PEM or DER format.
 This option can be specified more than once to include CRLs from multiple
 I&lt;file&gt;s.
 
@@ -60,13 +60,14 @@ Print extra information about the operations being performed.
 
 =item B&lt;-trusted&gt; I&lt;file&gt;
 
-A file of trusted certificates in PEM format.
+A file or URI of trusted certificates in PEM, DER, or PKCS#12 format.
 This option can be specified more than once to load certificates from multiple
 I&lt;file&gt;s.
 
 =item B&lt;-untrusted&gt; I&lt;file&gt;
 
-A file of untrusted certificates in PEM format to use for chain building.
+A file or URI of untrusted certificates in PEM, DER, or PKCS#12 format
+to use for chain building.
 This option can be specified more than once to load certificates from multiple
 I&lt;file&gt;s.
 
diff --git a/doc/man1/openssl-x509.pod.in b/doc/man1/openssl-x509.pod.in
index 33e24ac6e9..8eb35e537e 100644
--- a/doc/man1/openssl-x509.pod.in
+++ b/doc/man1/openssl-x509.pod.in
@@ -386,7 +386,8 @@ Names and values of these options are algorithm-specific.
 
 =item B&lt;-passin&gt; I&lt;arg&gt;
 
-The key password source. For more information about the format of I&lt;arg&gt;
+The key and certificate file password source.
+For more information about the format of I&lt;arg&gt;
 see L&lt;openssl(1)/Pass Phrase Options&gt;.
 
 =item B&lt;-clrext&gt;
diff --git a/test/certs/v3-certs-RC2.p12 b/test/certs/v3-certs-RC2.p12
new file mode 100644
index 0000000000..0cdbcc1f26
Binary files /dev/null and b/test/certs/v3-certs-RC2.p12 differ
diff --git a/test/certs/v3-certs-TDES.p12 b/test/certs/v3-certs-TDES.p12
new file mode 100644
index 0000000000..d203dc2986
Binary files /dev/null and b/test/certs/v3-certs-TDES.p12 differ
diff --git a/test/recipes/25-test_x509.t b/test/recipes/25-test_x509.t
index 250738487a..3cfcb2290c 100644
--- a/test/recipes/25-test_x509.t
+++ b/test/recipes/25-test_x509.t
@@ -16,7 +16,7 @@ use OpenSSL::Test qw/:DEFAULT srctop_file/;
 
 setup(&quot;test_x509&quot;);
 
-plan tests =&gt; 11;
+plan tests =&gt; 12;
 
 require_ok(srctop_file('test','recipes','tconversion.pl'));
 
@@ -35,6 +35,17 @@ ok(run(app([&quot;openssl&quot;, &quot;x509&quot;, &quot;-text&quot;, &quot;-in&quot;, $pem, &quot;-out&quot;, $out_utf8,
 is(cmp_text($out_utf8, srctop_file(&quot;test/certs&quot;, &quot;cyrillic.utf8&quot;)),
    0, 'Comparing utf8 output');
 
+ SKIP: {
+    skip &quot;DES disabled&quot;, 1 if disabled(&quot;des&quot;);
+
+    my $p12 = srctop_file(&quot;test&quot;, &quot;shibboleth.pfx&quot;);
+    my $p12pass = &quot;&#963;&#973;&#957;&#952;&#951;&#956;&#945; &#947;&#957;&#974;&#961;&#953;&#963;&#956;&#945;&quot;;
+    my $out_pem = &quot;out.pem&quot;;
+    ok(run(app([&quot;openssl&quot;, &quot;x509&quot;, &quot;-text&quot;, &quot;-in&quot;, $p12, &quot;-out&quot;, $out_pem,
+                &quot;-passin&quot;, &quot;pass:$p12pass&quot;])));
+    unlink $out_pem;
+}
+
 SKIP: {
     skip &quot;EC disabled&quot;, 1 if disabled(&quot;ec&quot;);
 
diff --git a/test/recipes/80-test_pkcs12.t b/test/recipes/80-test_pkcs12.t
index fa95649212..24247b8c25 100644
--- a/test/recipes/80-test_pkcs12.t
+++ b/test/recipes/80-test_pkcs12.t
@@ -57,7 +57,7 @@ if (eval { require Win32::API; 1; }) {
 }
 $ENV{OPENSSL_WIN32_UTF8}=1;
 
-plan tests =&gt; 2;
+plan tests =&gt; 4;
 
 # Test different PKCS#12 formats
 ok(run(test([&quot;pkcs12_format_test&quot;])), &quot;test pkcs12 formats&quot;);
@@ -68,4 +68,27 @@ ok(run(app([&quot;openssl&quot;, &quot;pkcs12&quot;, &quot;-noout&quot;,
             &quot;-in&quot;, srctop_file(&quot;test&quot;, &quot;shibboleth.pfx&quot;)])),
    &quot;test_pkcs12&quot;);
 
+my @path = qw(test certs);
+my $tmpfile = &quot;tmp.p12&quot;;
+
+# Test the -passcerts option
+ok(run(app([&quot;openssl&quot;, &quot;pkcs12&quot;, &quot;-export&quot;,
+            &quot;-in&quot;, srctop_file(@path, &quot;ee-cert.pem&quot;),
+            &quot;-certfile&quot;, srctop_file(@path, &quot;v3-certs-TDES.p12&quot;),
+            &quot;-passcerts&quot;, &quot;pass:v3-certs&quot;,
+            &quot;-nokeys&quot;, &quot;-passout&quot;, &quot;pass:v3-certs&quot;, &quot;-descert&quot;,
+            &quot;-out&quot;, $tmpfile])),
+   &quot;test_pkcs12_passcert&quot;);
+unlink $tmpfile;
+
+# Test reading legacy PKCS#12 file
+ok(run(app([&quot;openssl&quot;, &quot;pkcs12&quot;, &quot;-export&quot;,
+            &quot;-in&quot;, srctop_file(@path, &quot;v3-certs-RC2.p12&quot;),
+            &quot;-passin&quot;, &quot;pass:v3-certs&quot;,
+            &quot;-provider&quot;, &quot;default&quot;, &quot;-provider&quot;, &quot;legacy&quot;,
+            &quot;-nokeys&quot;, &quot;-passout&quot;, &quot;pass:v3-certs&quot;, &quot;-descert&quot;,
+            &quot;-out&quot;, $tmpfile])),
+   &quot;test_pkcs12_passcert&quot;);
+unlink $tmpfile;
+
 SetConsoleOutputCP($savedcp) if (defined($savedcp));
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030232.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="030238.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30234">[ date ]</a>
              <a href="thread.html#30234">[ thread ]</a>
              <a href="subject.html#30234">[ subject ]</a>
              <a href="author.html#30234">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
