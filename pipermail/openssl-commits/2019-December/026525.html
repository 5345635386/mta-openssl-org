<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-December/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1575881647.378359.9487.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026514.html">
   <LINK REL="Next"  HREF="026530.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>tmraz at fedoraproject.org</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1575881647.378359.9487.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">tmraz at fedoraproject.org
       </A><BR>
    <I>Mon Dec  9 08:54:07 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="026514.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="026530.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26525">[ date ]</a>
              <a href="thread.html#26525">[ thread ]</a>
              <a href="subject.html#26525">[ subject ]</a>
              <a href="author.html#26525">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  1352e0ff490d758cfd74e179e8a9614833fd88a9 (commit)
       via  d63d89ea0fe43c9d690b058e23a297f37d20f75d (commit)
       via  001d5e2c64f9fedc639ab91a075241e6089bbb4a (commit)
       via  f607f6eadd15fefcd0d9b5e03510a91702af5a3d (commit)
       via  0609658f9b11c787ad2e78e2ecf2aa9bc2771a86 (commit)
       via  d02b7e09317d6d1bd9626727fbc58c4981881360 (commit)
       via  2cc076530fa1cf10d42836027e35ec67271b55b2 (commit)
       via  af0857f0e7ae46b7c3df2eca496cfcb71f1ff904 (commit)
      from  32745fccdb65c24049a09c93f7170b0236e9893b (commit)


- Log -----------------------------------------------------------------
commit 1352e0ff490d758cfd74e179e8a9614833fd88a9
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Wed May 9 22:27:27 2018 +0200

    apps/speed: replace list of #define by enums declarations.
    it simplifies some pieces of code.
    Improve internal assertions
    Tag a few #endif with OPENSSL_NO_EC to mark its ending.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10078">https://github.com/openssl/openssl/pull/10078</A>)

commit d63d89ea0fe43c9d690b058e23a297f37d20f75d
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Tue Oct 15 23:33:02 2019 +0200

    apps/speed: factorize ec test curves declarations
    remove 'test' prefix from variable names.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10078">https://github.com/openssl/openssl/pull/10078</A>)

commit 001d5e2c64f9fedc639ab91a075241e6089bbb4a
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Sat Oct 19 17:55:36 2019 +0200

    apps/speed: improve sm2 failure code.
    attach the new objects sooner, so error handling is simplified.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10078">https://github.com/openssl/openssl/pull/10078</A>)

commit f607f6eadd15fefcd0d9b5e03510a91702af5a3d
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Tue Jun 5 19:56:06 2018 +0200

    apps/speed: simplify 'doit' action flag management code.
    Optimize algorithm selection code.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10078">https://github.com/openssl/openssl/pull/10078</A>)

commit 0609658f9b11c787ad2e78e2ecf2aa9bc2771a86
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Tue Jun 5 19:44:42 2018 +0200

    apps/speed: initialize key material only when its algo is selected.
    Remove some duplicate key data declarations.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10078">https://github.com/openssl/openssl/pull/10078</A>)

commit d02b7e09317d6d1bd9626727fbc58c4981881360
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Sat Oct 19 19:37:01 2019 +0200

    apps/speed: remove a shared global variable
    replace |save_count| by the right c[D_EVP(_xxx)] variable.
    this may shared a value between various algorithm.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10078">https://github.com/openssl/openssl/pull/10078</A>)

commit 2cc076530fa1cf10d42836027e35ec67271b55b2
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Sat Oct 19 17:58:07 2019 +0200

    apps/speed: discard useless protoypes as these methods are defines before being used.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10078">https://github.com/openssl/openssl/pull/10078</A>)

commit af0857f0e7ae46b7c3df2eca496cfcb71f1ff904
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Sat Oct 19 16:38:21 2019 +0200

    apps/speed: allow to continue tests after any init failure handling.
    previouly the exit(1) call was aborting the whole execution.
    Improve error message.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10078">https://github.com/openssl/openssl/pull/10078</A>)

-----------------------------------------------------------------------

Summary of changes:
 apps/speed.c | 869 ++++++++++++++++++++++++-----------------------------------
 1 file changed, 349 insertions(+), 520 deletions(-)

diff --git a/apps/speed.c b/apps/speed.c
index e4b104e9c3..d8d6f0a1ef 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -136,72 +136,9 @@ typedef struct openssl_speed_sec_st {
 
 static volatile int run = 0;
 
-static int mr = 0;
+static int mr = 0;  /* machine-readeable output format to merge fork results */
 static int usertime = 1;
 
-#ifndef OPENSSL_NO_MD2
-static int EVP_Digest_MD2_loop(void *args);
-#endif
-
-#ifndef OPENSSL_NO_MDC2
-static int EVP_Digest_MDC2_loop(void *args);
-#endif
-#ifndef OPENSSL_NO_MD4
-static int EVP_Digest_MD4_loop(void *args);
-#endif
-#ifndef OPENSSL_NO_MD5
-static int MD5_loop(void *args);
-static int HMAC_loop(void *args);
-#endif
-static int SHA1_loop(void *args);
-static int SHA256_loop(void *args);
-static int SHA512_loop(void *args);
-#ifndef OPENSSL_NO_WHIRLPOOL
-static int WHIRLPOOL_loop(void *args);
-#endif
-#ifndef OPENSSL_NO_RMD160
-static int EVP_Digest_RMD160_loop(void *args);
-#endif
-#ifndef OPENSSL_NO_RC4
-static int RC4_loop(void *args);
-#endif
-#ifndef OPENSSL_NO_DES
-static int DES_ncbc_encrypt_loop(void *args);
-static int DES_ede3_cbc_encrypt_loop(void *args);
-#endif
-static int AES_cbc_128_encrypt_loop(void *args);
-static int AES_cbc_192_encrypt_loop(void *args);
-static int AES_cbc_256_encrypt_loop(void *args);
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-static int AES_ige_128_encrypt_loop(void *args);
-static int AES_ige_192_encrypt_loop(void *args);
-static int AES_ige_256_encrypt_loop(void *args);
-#endif
-static int CRYPTO_gcm128_aad_loop(void *args);
-static int RAND_bytes_loop(void *args);
-static int EVP_Update_loop(void *args);
-static int EVP_Update_loop_ccm(void *args);
-static int EVP_Update_loop_aead(void *args);
-static int EVP_Digest_loop(void *args);
-#ifndef OPENSSL_NO_RSA
-static int RSA_sign_loop(void *args);
-static int RSA_verify_loop(void *args);
-#endif
-#ifndef OPENSSL_NO_DSA
-static int DSA_sign_loop(void *args);
-static int DSA_verify_loop(void *args);
-#endif
-#ifndef OPENSSL_NO_EC
-static int ECDSA_sign_loop(void *args);
-static int ECDSA_verify_loop(void *args);
-static int EdDSA_sign_loop(void *args);
-static int EdDSA_verify_loop(void *args);
-# ifndef OPENSSL_NO_SM2
-static int SM2_sign_loop(void *args);
-static int SM2_verify_loop(void *args);
-# endif
-#endif
-
 static double Time_F(int s);
 static void print_message(const char *s, long num, int length, int tm);
 static void pkey_print_message(const char *str, const char *str2,
@@ -214,6 +151,7 @@ static int do_multi(int multi, int size_num);
 static const int lengths_list[] = {
     16, 64, 256, 1024, 8 * 1024, 16 * 1024
 };
+#define SIZE_NUM         OSSL_NELEM(lengths_list)
 static const int *lengths = lengths_list;
 
 static const int aead_lengths_list[] = {
@@ -295,8 +233,6 @@ static double Time_F(int s)
 static void multiblock_speed(const EVP_CIPHER *evp_cipher, int lengths_single,
                              const openssl_speed_sec_t *seconds);
 
-#define found(value, pairs, result)\
-    opt_found(value, result, pairs, OSSL_NELEM(pairs))
 static int opt_found(const char *name, unsigned int *result,
                      const OPT_PAIR pairs[], unsigned int nbelem)
 {
@@ -309,6 +245,8 @@ static int opt_found(const char *name, unsigned int *result,
         }
     return 0;
 }
+#define opt_found(value, pairs, result)\
+    opt_found(value, result, pairs, OSSL_NELEM(pairs))
 
 typedef enum OPTION_choice {
     OPT_ERR = -1, OPT_EOF = 0, OPT_HELP,
@@ -365,42 +303,18 @@ const OPTIONS speed_options[] = {
     {NULL}
 };
 
-#define D_MD2           0
-#define D_MDC2          1
-#define D_MD4           2
-#define D_MD5           3
-#define D_HMAC          4
-#define D_SHA1          5
-#define D_RMD160        6
-#define D_RC4           7
-#define D_CBC_DES       8
-#define D_EDE3_DES      9
-#define D_CBC_IDEA      10
-#define D_CBC_SEED      11
-#define D_CBC_RC2       12
-#define D_CBC_RC5       13
-#define D_CBC_BF        14
-#define D_CBC_CAST      15
-#define D_CBC_128_AES   16
-#define D_CBC_192_AES   17
-#define D_CBC_256_AES   18
-#define D_CBC_128_CML   19
-#define D_CBC_192_CML   20
-#define D_CBC_256_CML   21
-#define D_EVP           22
-#define D_SHA256        23
-#define D_SHA512        24
-#define D_WHIRLPOOL     25
-#define D_IGE_128_AES   26
-#define D_IGE_192_AES   27
-#define D_IGE_256_AES   28
-#define D_GHASH         29
-#define D_RAND          30
-#define D_EVP_HMAC      31
-#define D_EVP_CMAC      32
-
-/* name of algorithms to test */
-static const char *names[] = {
+enum {
+    D_MD2, D_MDC2, D_MD4, D_MD5 , D_HMAC, D_SHA1, D_RMD160, D_RC4,
+    D_CBC_DES, D_EDE3_DES, D_CBC_IDEA, D_CBC_SEED,
+    D_CBC_RC2, D_CBC_RC5, D_CBC_BF, D_CBC_CAST,
+    D_CBC_128_AES, D_CBC_192_AES, D_CBC_256_AES,
+    D_CBC_128_CML, D_CBC_192_CML, D_CBC_256_CML,
+    D_EVP, D_SHA256, D_SHA512, D_WHIRLPOOL,
+    D_IGE_128_AES, D_IGE_192_AES, D_IGE_256_AES,
+    D_GHASH, D_RAND, D_EVP_HMAC, D_EVP_CMAC, ALGOR_NUM 
+};
+/* name of algorithms to test. MUST BE KEEP IN SYNC with above enum ! */
+static const char *names[ALGOR_NUM] = {
     &quot;md2&quot;, &quot;mdc2&quot;, &quot;md4&quot;, &quot;md5&quot;, &quot;hmac(md5)&quot;, &quot;sha1&quot;, &quot;rmd160&quot;, &quot;rc4&quot;,
     &quot;des cbc&quot;, &quot;des ede3&quot;, &quot;idea cbc&quot;, &quot;seed cbc&quot;,
     &quot;rc2 cbc&quot;, &quot;rc5-32/12 cbc&quot;, &quot;blowfish cbc&quot;, &quot;cast cbc&quot;,
@@ -410,9 +324,8 @@ static const char *names[] = {
     &quot;aes-128 ige&quot;, &quot;aes-192 ige&quot;, &quot;aes-256 ige&quot;, &quot;ghash&quot;,
     &quot;rand&quot;, &quot;hmac&quot;, &quot;cmac&quot;
 };
-#define ALGOR_NUM       OSSL_NELEM(names)
 
-/* list of configured algorithm (remaining) */
+/* list of configured algorithm (remaining), with some few alias */
 static const OPT_PAIR doit_choices[] = {
 #ifndef OPENSSL_NO_MD2
     {&quot;md2&quot;, D_MD2},
@@ -483,31 +396,24 @@ static const OPT_PAIR doit_choices[] = {
     {&quot;rand&quot;, D_RAND}
 };
 
-static double results[ALGOR_NUM][OSSL_NELEM(lengths_list)];
+static double results[ALGOR_NUM][SIZE_NUM];
 
 #ifndef OPENSSL_NO_DSA
-# define R_DSA_512       0
-# define R_DSA_1024      1
-# define R_DSA_2048      2
-static const OPT_PAIR dsa_choices[] = {
+enum { R_DSA_512, R_DSA_1024, R_DSA_2048, DSA_NUM };
+static const OPT_PAIR dsa_choices[DSA_NUM] = {
     {&quot;dsa512&quot;, R_DSA_512},
     {&quot;dsa1024&quot;, R_DSA_1024},
     {&quot;dsa2048&quot;, R_DSA_2048}
 };
-# define DSA_NUM         OSSL_NELEM(dsa_choices)
-
 static double dsa_results[DSA_NUM][2];  /* 2 ops: sign then verify */
 #endif  /* OPENSSL_NO_DSA */
 
-#define R_RSA_512       0
-#define R_RSA_1024      1
-#define R_RSA_2048      2
-#define R_RSA_3072      3
-#define R_RSA_4096      4
-#define R_RSA_7680      5
-#define R_RSA_15360     6
 #ifndef OPENSSL_NO_RSA
-static const OPT_PAIR rsa_choices[] = {
+enum {
+    R_RSA_512, R_RSA_1024, R_RSA_2048, R_RSA_3072, R_RSA_4096, R_RSA_7680,
+    R_RSA_15360, RSA_NUM
+};
+static const OPT_PAIR rsa_choices[RSA_NUM] = {
     {&quot;rsa512&quot;, R_RSA_512},
     {&quot;rsa1024&quot;, R_RSA_1024},
     {&quot;rsa2048&quot;, R_RSA_2048},
@@ -516,42 +422,22 @@ static const OPT_PAIR rsa_choices[] = {
     {&quot;rsa7680&quot;, R_RSA_7680},
     {&quot;rsa15360&quot;, R_RSA_15360}
 };
-# define RSA_NUM OSSL_NELEM(rsa_choices)
 
 static double rsa_results[RSA_NUM][2];  /* 2 ops: sign then verify */
 #endif /* OPENSSL_NO_RSA */
 
-enum {
-    R_EC_P160,
-    R_EC_P192,
-    R_EC_P224,
-    R_EC_P256,
-    R_EC_P384,
-    R_EC_P521,
-#ifndef OPENSSL_NO_EC2M
-    R_EC_K163,
-    R_EC_K233,
-    R_EC_K283,
-    R_EC_K409,
-    R_EC_K571,
-    R_EC_B163,
-    R_EC_B233,
-    R_EC_B283,
-    R_EC_B409,
-    R_EC_B571,
-#endif
-    R_EC_BRP256R1,
-    R_EC_BRP256T1,
-    R_EC_BRP384R1,
-    R_EC_BRP384T1,
-    R_EC_BRP512R1,
-    R_EC_BRP512T1,
-    R_EC_X25519,
-    R_EC_X448
-};
-
 #ifndef OPENSSL_NO_EC
-static OPT_PAIR ecdsa_choices[] = {
+enum ec_curves_t {
+    R_EC_P160, R_EC_P192, R_EC_P224, R_EC_P256, R_EC_P384, R_EC_P521,
+# ifndef OPENSSL_NO_EC2M
+    R_EC_K163, R_EC_K233, R_EC_K283, R_EC_K409, R_EC_K571,
+    R_EC_B163, R_EC_B233, R_EC_B283, R_EC_B409, R_EC_B571,
+# endif
+    R_EC_BRP256R1, R_EC_BRP256T1, R_EC_BRP384R1, R_EC_BRP384T1,
+    R_EC_BRP512R1, R_EC_BRP512T1, ECDSA_NUM
+};
+/* list of ecdsa curves */
+static const OPT_PAIR ecdsa_choices[ECDSA_NUM] = {
     {&quot;ecdsap160&quot;, R_EC_P160},
     {&quot;ecdsap192&quot;, R_EC_P192},
     {&quot;ecdsap224&quot;, R_EC_P224},
@@ -577,11 +463,9 @@ static OPT_PAIR ecdsa_choices[] = {
     {&quot;ecdsabrp512r1&quot;, R_EC_BRP512R1},
     {&quot;ecdsabrp512t1&quot;, R_EC_BRP512T1}
 };
-# define ECDSA_NUM       OSSL_NELEM(ecdsa_choices)
-
-static double ecdsa_results[ECDSA_NUM][2];    /* 2 ops: sign then verify */
-
-static const OPT_PAIR ecdh_choices[] = {
+enum { R_EC_X25519 = ECDSA_NUM, R_EC_X448, EC_NUM };
+/* list of ecdh curves, extension of |ecdsa_choices| list above */
+static const OPT_PAIR ecdh_choices[EC_NUM] = {
     {&quot;ecdhp160&quot;, R_EC_P160},
     {&quot;ecdhp192&quot;, R_EC_P192},
     {&quot;ecdhp224&quot;, R_EC_P224},
@@ -609,29 +493,25 @@ static const OPT_PAIR ecdh_choices[] = {
     {&quot;ecdhx25519&quot;, R_EC_X25519},
     {&quot;ecdhx448&quot;, R_EC_X448}
 };
-# define EC_NUM       OSSL_NELEM(ecdh_choices)
 
-static double ecdh_results[EC_NUM][1];  /* 1 op: derivation */
+static double ecdh_results[EC_NUM][1];      /* 1 op: derivation */
+static double ecdsa_results[ECDSA_NUM][2];  /* 2 ops: sign then verify */
 
-#define R_EC_Ed25519    0
-#define R_EC_Ed448      1
-static OPT_PAIR eddsa_choices[] = {
+enum { R_EC_Ed25519, R_EC_Ed448, EdDSA_NUM };
+static const OPT_PAIR eddsa_choices[EdDSA_NUM] = {
     {&quot;ed25519&quot;, R_EC_Ed25519},
     {&quot;ed448&quot;, R_EC_Ed448}
-};
-# define EdDSA_NUM       OSSL_NELEM(eddsa_choices)
 
+};
 static double eddsa_results[EdDSA_NUM][2];    /* 2 ops: sign then verify */
 
 # ifndef OPENSSL_NO_SM2
-#  define R_EC_CURVESM2        0
-static OPT_PAIR sm2_choices[] = {
+enum { R_EC_CURVESM2, SM2_NUM };
+static const OPT_PAIR sm2_choices[SM2_NUM] = {
     {&quot;curveSM2&quot;, R_EC_CURVESM2}
 };
 #  define SM2_ID        &quot;TLSv1.3+GM+Cipher+Suite&quot;
 #  define SM2_ID_LEN    sizeof(&quot;TLSv1.3+GM+Cipher+Suite&quot;) - 1
-#  define SM2_NUM       OSSL_NELEM(sm2_choices)
-
 static double sm2_results[SM2_NUM][2];    /* 2 ops: sign then verify */
 # endif /* OPENSSL_NO_SM2 */
 #endif /* OPENSSL_NO_EC */
@@ -686,7 +566,7 @@ static int run_benchmark(int async_jobs, int (*loop_function) (void *),
 static unsigned int testnum;
 
 /* Nb of iterations to do per algorithm and key-size */
-static long c[ALGOR_NUM][OSSL_NELEM(lengths_list)];
+static long c[ALGOR_NUM][SIZE_NUM];
 
 #ifndef OPENSSL_NO_MD2
 static int EVP_Digest_MD2_loop(void *args)
@@ -845,16 +725,14 @@ static int RC4_loop(void *args)
 
 #ifndef OPENSSL_NO_DES
 static unsigned char DES_iv[8];
-static DES_key_schedule sch;
-static DES_key_schedule sch2;
-static DES_key_schedule sch3;
+static DES_key_schedule sch[3];
 static int DES_ncbc_encrypt_loop(void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     int count;
     for (count = 0; COND(c[D_CBC_DES][testnum]); count++)
-        DES_ncbc_encrypt(buf, buf, lengths[testnum], &amp;sch,
+        DES_ncbc_encrypt(buf, buf, lengths[testnum], &amp;sch[0],
                          &amp;DES_iv, DES_ENCRYPT);
     return count;
 }
@@ -866,7 +744,7 @@ static int DES_ede3_cbc_encrypt_loop(void *args)
     int count;
     for (count = 0; COND(c[D_EDE3_DES][testnum]); count++)
         DES_ede3_cbc_encrypt(buf, buf, lengths[testnum],
-                             &amp;sch, &amp;sch2, &amp;sch3, &amp;DES_iv, DES_ENCRYPT);
+                             &amp;sch[0], &amp;sch[1], &amp;sch[2], &amp;DES_iv, DES_ENCRYPT);
     return count;
 }
 #endif
@@ -968,7 +846,6 @@ static int RAND_bytes_loop(void *args)
     return count;
 }
 
-static long save_count = 0;
 static int decrypt = 0;
 static int EVP_Update_loop(void *args)
 {
@@ -976,11 +853,9 @@ static int EVP_Update_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     EVP_CIPHER_CTX *ctx = tempargs-&gt;ctx;
     int outl, count, rc;
-#ifndef SIGALRM
-    int nb_iter = save_count * 4 * lengths[0] / lengths[testnum];
-#endif
+
     if (decrypt) {
-        for (count = 0; COND(nb_iter); count++) {
+        for (count = 0; COND(c[D_EVP][testnum]); count++) {
             rc = EVP_DecryptUpdate(ctx, buf, &amp;outl, buf, lengths[testnum]);
             if (rc != 1) {
                 /* reset iv in case of counter overflow */
@@ -988,7 +863,7 @@ static int EVP_Update_loop(void *args)
             }
         }
     } else {
-        for (count = 0; COND(nb_iter); count++) {
+        for (count = 0; COND(c[D_EVP][testnum]); count++) {
             rc = EVP_EncryptUpdate(ctx, buf, &amp;outl, buf, lengths[testnum]);
             if (rc != 1) {
                 /* reset iv in case of counter overflow */
@@ -1015,11 +890,9 @@ static int EVP_Update_loop_ccm(void *args)
     EVP_CIPHER_CTX *ctx = tempargs-&gt;ctx;
     int outl, count;
     unsigned char tag[12];
-#ifndef SIGALRM
-    int nb_iter = save_count * 4 * lengths[0] / lengths[testnum];
-#endif
+
     if (decrypt) {
-        for (count = 0; COND(nb_iter); count++) {
+        for (count = 0; COND(c[D_EVP][testnum]); count++) {
             EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, sizeof(tag), tag);
             /* reset iv */
             EVP_DecryptInit_ex(ctx, NULL, NULL, NULL, iv);
@@ -1027,7 +900,7 @@ static int EVP_Update_loop_ccm(void *args)
             EVP_DecryptUpdate(ctx, buf, &amp;outl, buf, lengths[testnum]);
         }
     } else {
-        for (count = 0; COND(nb_iter); count++) {
+        for (count = 0; COND(c[D_EVP][testnum]); count++) {
             /* restore iv length field */
             EVP_EncryptUpdate(ctx, NULL, &amp;outl, NULL, lengths[testnum]);
             /* counter is reset on every update */
@@ -1054,11 +927,9 @@ static int EVP_Update_loop_aead(void *args)
     int outl, count;
     unsigned char aad[13] = { 0xcc };
     unsigned char faketag[16] = { 0xcc };
-#ifndef SIGALRM
-    int nb_iter = save_count * 4 * lengths[0] / lengths[testnum];
-#endif
+
     if (decrypt) {
-        for (count = 0; COND(nb_iter); count++) {
+        for (count = 0; COND(c[D_EVP][testnum]); count++) {
             EVP_DecryptInit_ex(ctx, NULL, NULL, NULL, iv);
             EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,
                                 sizeof(faketag), faketag);
@@ -1067,7 +938,7 @@ static int EVP_Update_loop_aead(void *args)
             EVP_DecryptFinal_ex(ctx, buf + outl, &amp;outl);
         }
     } else {
-        for (count = 0; COND(nb_iter); count++) {
+        for (count = 0; COND(c[D_EVP][testnum]); count++) {
             EVP_EncryptInit_ex(ctx, NULL, NULL, NULL, iv);
             EVP_EncryptUpdate(ctx, NULL, &amp;outl, aad, sizeof(aad));
             EVP_EncryptUpdate(ctx, buf, &amp;outl, buf, lengths[testnum]);
@@ -1084,11 +955,8 @@ static int EVP_Digest_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char md[EVP_MAX_MD_SIZE];
     int count;
-#ifndef SIGALRM
-    int nb_iter = save_count * 4 * lengths[0] / lengths[testnum];
-#endif
 
-    for (count = 0; COND(nb_iter); count++) {
+    for (count = 0; COND(c[D_EVP][testnum]); count++) {
         if (!EVP_Digest(buf, lengths[testnum], md, NULL, evp_md, NULL))
             return -1;
     }
@@ -1103,11 +971,8 @@ static int EVP_HMAC_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char no_key[32];
     int count;
-#ifndef SIGALRM
-    int nb_iter = save_count * 4 * lengths[0] / lengths[testnum];
-#endif
 
-    for (count = 0; COND(nb_iter); count++) {
+    for (count = 0; COND(c[D_EVP_HMAC][testnum]); count++) {
         if (HMAC(evp_hmac_md, no_key, sizeof(no_key), buf, lengths[testnum],
                  NULL, NULL) == NULL)
             return -1;
@@ -1128,11 +993,8 @@ static int EVP_CMAC_loop(void *args)
     unsigned char mac[16];
     size_t len = sizeof(mac);
     int count;
-#ifndef SIGALRM
-    int nb_iter = save_count * 4 * lengths[0] / lengths[testnum];
-#endif
 
-    for (count = 0; COND(nb_iter); count++) {
+    for (count = 0; COND(c[D_EVP_CMAC][testnum]); count++) {
         if (!CMAC_Init(cmac_ctx, key, sizeof(key), evp_cmac_cipher, NULL)
                 || !CMAC_Update(cmac_ctx, buf, lengths[testnum])
                 || !CMAC_Final(cmac_ctx, mac, &amp;len))
@@ -1554,6 +1416,9 @@ static int run_benchmark(int async_jobs,
     return error ? -1 : total_op_count;
 }
 
+#define stop_it(do_it, test_num)\
+    memset(do_it + test_num, 0, OSSL_NELEM(do_it) - test_num);
+
 int speed_main(int argc, char **argv)
 {
     ENGINE *e = NULL;
@@ -1564,11 +1429,11 @@ int speed_main(int argc, char **argv)
     double d = 0.0;
     OPTION_CHOICE o;
     int async_init = 0, multiblock = 0, pr_header = 0;
-    int doit[ALGOR_NUM] = { 0 };
+    uint8_t doit[ALGOR_NUM] = { 0 };
     int ret = 1, misalign = 0, lengths_single = 0, aead = 0;
     long count = 0;
-    unsigned int size_num = OSSL_NELEM(lengths_list);
-    unsigned int i, k, loop, loopargs_len = 0, async_jobs = 0;
+    unsigned int size_num = SIZE_NUM;
+    unsigned int i, k, loopargs_len = 0, async_jobs = 0;
     int keylen;
     int buflen;
 #ifndef NO_FORK
@@ -1617,61 +1482,43 @@ int speed_main(int argc, char **argv)
         0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56
     };
 #ifndef OPENSSL_NO_CAMELLIA
-    static const unsigned char ckey24[24] = {
-        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
-        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
-        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34
-    };
-    static const unsigned char ckey32[32] = {
-        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
-        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
-        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
-        0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56
-    };
-    CAMELLIA_KEY camellia_ks1, camellia_ks2, camellia_ks3;
-#endif
-#ifndef OPENSSL_NO_DES
-    static DES_cblock key = {
-        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0
-    };
-    static DES_cblock key2 = {
-        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12
-    };
-    static DES_cblock key3 = {
-        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34
-    };
+    CAMELLIA_KEY camellia_ks[3];
 #endif
 #ifndef OPENSSL_NO_RSA
-    static const unsigned int rsa_bits[RSA_NUM] = {
-        512, 1024, 2048, 3072, 4096, 7680, 15360
-    };
-    static const unsigned char *rsa_data[RSA_NUM] = {
-        test512, test1024, test2048, test3072, test4096, test7680, test15360
-    };
-    static const int rsa_data_length[RSA_NUM] = {
-        sizeof(test512), sizeof(test1024),
-        sizeof(test2048), sizeof(test3072),
-        sizeof(test4096), sizeof(test7680),
-        sizeof(test15360)
+    static const struct {
+        const unsigned char *data;
+        unsigned int length;
+        unsigned int bits;
+    } rsa_keys[] = {
+        {   test512,   sizeof(test512),   512 },
+        {  test1024,  sizeof(test1024),  1024 },
+        {  test2048,  sizeof(test2048),  2048 },
+        {  test3072,  sizeof(test3072),  3072 },
+        {  test4096,  sizeof(test4096),  4092 },
+        {  test7680,  sizeof(test7680),  7680 },
+        { test15360, sizeof(test15360), 15360 }
     };
-    int rsa_doit[RSA_NUM] = { 0 };
+    uint8_t rsa_doit[RSA_NUM] = { 0 };
     int primes = RSA_DEFAULT_PRIME_NUM;
 #endif
 #ifndef OPENSSL_NO_DSA
     static const unsigned int dsa_bits[DSA_NUM] = { 512, 1024, 2048 };
-    int dsa_doit[DSA_NUM] = { 0 };
+    uint8_t dsa_doit[DSA_NUM] = { 0 };
 #endif
 #ifndef OPENSSL_NO_EC
+    typedef struct ec_curve_st {
+        const char *name;
+        unsigned int nid;
+        unsigned int bits;
+        size_t sigsize; /* only used for EdDSA curves */
+    } EC_CURVE;
     /*
      * We only test over the following curves as they are representative, To
      * add tests over more curves, simply add the curve NID and curve name to
-     * the following arrays and increase the |ecdh_choices| list accordingly.
+     * the following arrays and increase the |ecdh_choices| and |ecdsa_choices|
+     * lists accordingly.
      */
-    static const struct {
-        const char *name;
-        unsigned int nid;
-        unsigned int bits;
-    } test_curves[] = {
+    static const EC_CURVE ec_curves[EC_NUM] = {
         /* Prime Curves */
         {&quot;secp160r1&quot;, NID_secp160r1, 160},
         {&quot;nistp192&quot;, NID_X9_62_prime192v1, 192},
@@ -1702,36 +1549,35 @@ int speed_main(int argc, char **argv)
         {&quot;X25519&quot;, NID_X25519, 253},
         {&quot;X448&quot;, NID_X448, 448}
     };
-    static const struct {
-        const char *name;
-        unsigned int nid;
-        unsigned int bits;
-        size_t sigsize;
-    } test_ed_curves[] = {
+    static const EC_CURVE ed_curves[EdDSA_NUM] = {
         /* EdDSA */
         {&quot;Ed25519&quot;, NID_ED25519, 253, 64},
         {&quot;Ed448&quot;, NID_ED448, 456, 114}
     };
 # ifndef OPENSSL_NO_SM2
-    static const struct {
-        const char *name;
-        unsigned int nid;
-        unsigned int bits;
-    } test_sm2_curves[] = {
+    static const EC_CURVE sm2_curves[SM2_NUM] = {
         /* SM2 */
         {&quot;CurveSM2&quot;, NID_sm2, 256}
     };
+    uint8_t sm2_doit[SM2_NUM] = { 0 };
 # endif
-    int ecdsa_doit[ECDSA_NUM] = { 0 };
-    int ecdh_doit[EC_NUM] = { 0 };
-    int eddsa_doit[EdDSA_NUM] = { 0 };
-# ifndef OPENSSL_NO_SM2
-    int sm2_doit[SM2_NUM] = { 0 };
-# endif
-    OPENSSL_assert(OSSL_NELEM(test_curves) &gt;= EC_NUM);
-    OPENSSL_assert(OSSL_NELEM(test_ed_curves) &gt;= EdDSA_NUM);
+    uint8_t ecdsa_doit[ECDSA_NUM] = { 0 };
+    uint8_t ecdh_doit[EC_NUM] = { 0 };
+    uint8_t eddsa_doit[EdDSA_NUM] = { 0 };
+
+    /* checks declarated curves against choices list. */
+    OPENSSL_assert(ed_curves[EdDSA_NUM - 1].nid == NID_ED448);
+    OPENSSL_assert(strcmp(eddsa_choices[EdDSA_NUM - 1].name, &quot;ed448&quot;) == 0);
+
+    OPENSSL_assert(ec_curves[EC_NUM - 1].nid == NID_X448);
+    OPENSSL_assert(strcmp(ecdh_choices[EC_NUM - 1].name, &quot;ecdhx448&quot;) == 0);
+
+    OPENSSL_assert(ec_curves[ECDSA_NUM - 1].nid == NID_brainpoolP512t1);
+    OPENSSL_assert(strcmp(ecdsa_choices[ECDSA_NUM - 1].name, &quot;ecdsabrp512t1&quot;) == 0);
+
 # ifndef OPENSSL_NO_SM2
-    OPENSSL_assert(OSSL_NELEM(test_sm2_curves) &gt;= SM2_NUM);
+    OPENSSL_assert(sm2_curves[SM2_NUM - 1].nid == NID_sm2);
+    OPENSSL_assert(strcmp(sm2_choices[SM2_NUM - 1].name, &quot;curveSM2&quot;) == 0);
 # endif
 #endif                          /* ndef OPENSSL_NO_EC */
 
@@ -1863,95 +1709,99 @@ int speed_main(int argc, char **argv)
 
     /* Remaining arguments are algorithms. */
     for (; *argv; argv++) {
-        if (found(*argv, doit_choices, &amp;i)) {
+        const char *algo = *argv;
+
+        if (opt_found(algo, doit_choices, &amp;i)) {
             doit[i] = 1;
             continue;
         }
 #ifndef OPENSSL_NO_DES
-        if (strcmp(*argv, &quot;des&quot;) == 0) {
+        if (strcmp(algo, &quot;des&quot;) == 0) {
             doit[D_CBC_DES] = doit[D_EDE3_DES] = 1;
             continue;
         }
 #endif
-        if (strcmp(*argv, &quot;sha&quot;) == 0) {
+        if (strcmp(algo, &quot;sha&quot;) == 0) {
             doit[D_SHA1] = doit[D_SHA256] = doit[D_SHA512] = 1;
             continue;
         }
 #ifndef OPENSSL_NO_RSA
-        if (strcmp(*argv, &quot;openssl&quot;) == 0)
-            continue;
-        if (strcmp(*argv, &quot;rsa&quot;) == 0) {
-            for (loop = 0; loop &lt; OSSL_NELEM(rsa_doit); loop++)
-                rsa_doit[loop] = 1;
-            continue;
-        }
-        if (found(*argv, rsa_choices, &amp;i)) {
-            rsa_doit[i] = 1;
+        if (strcmp(algo, &quot;openssl&quot;) == 0) /* just for compatibility */
             continue;
+        if (strncmp(algo, &quot;rsa&quot;, 3) == 0) {
+            if (algo[3] == '\0') {
+                memset(rsa_doit, 1, sizeof(rsa_doit));
+                continue;
+            }
+            if (opt_found(algo, rsa_choices, &amp;i)) {
+                rsa_doit[i] = 1;
+                continue;
+            }
         }
 #endif
 #ifndef OPENSSL_NO_DSA
-        if (strcmp(*argv, &quot;dsa&quot;) == 0) {
-            dsa_doit[R_DSA_512] = dsa_doit[R_DSA_1024] =
-                dsa_doit[R_DSA_2048] = 1;
-            continue;
-        }
-        if (found(*argv, dsa_choices, &amp;i)) {
-            dsa_doit[i] = 2;
-            continue;
+        if (strncmp(algo, &quot;dsa&quot;, 3) == 0) {
+            if (algo[3] == '\0') {
+                memset(dsa_doit, 1, sizeof(dsa_doit));
+                continue;
+            }
+            if (opt_found(algo, dsa_choices, &amp;i)) {
+                dsa_doit[i] = 2;
+                continue;
+            }
         }
 #endif
-        if (strcmp(*argv, &quot;aes&quot;) == 0) {
+        if (strcmp(algo, &quot;aes&quot;) == 0) {
             doit[D_CBC_128_AES] = doit[D_CBC_192_AES] = doit[D_CBC_256_AES] = 1;
             continue;
         }
 #ifndef OPENSSL_NO_CAMELLIA
-        if (strcmp(*argv, &quot;camellia&quot;) == 0) {
+        if (strcmp(algo, &quot;camellia&quot;) == 0) {
             doit[D_CBC_128_CML] = doit[D_CBC_192_CML] = doit[D_CBC_256_CML] = 1;
             continue;
         }
 #endif
 #ifndef OPENSSL_NO_EC
-        if (strcmp(*argv, &quot;ecdsa&quot;) == 0) {
-            for (loop = 0; loop &lt; OSSL_NELEM(ecdsa_doit); loop++)
-                ecdsa_doit[loop] = 1;
-            continue;
-        }
-        if (found(*argv, ecdsa_choices, &amp;i)) {
-            ecdsa_doit[i] = 2;
-            continue;
-        }
-        if (strcmp(*argv, &quot;ecdh&quot;) == 0) {
-            for (loop = 0; loop &lt; OSSL_NELEM(ecdh_doit); loop++)
-                ecdh_doit[loop] = 1;
-            continue;
+        if (strncmp(algo, &quot;ecdsa&quot;, 5) == 0) {
+            if (algo[5] == '\0') {
+                memset(ecdsa_doit, 1, sizeof(ecdsa_doit));
+                continue;
+            }
+            if (opt_found(algo, ecdsa_choices, &amp;i)) {
+                ecdsa_doit[i] = 2;
+                continue;
+            }
         }
-        if (found(*argv, ecdh_choices, &amp;i)) {
-            ecdh_doit[i] = 2;
-            continue;
+        if (strncmp(algo, &quot;ecdh&quot;, 4) == 0) {
+            if (algo[4] == '\0') {
+                memset(ecdh_doit, 1, sizeof(ecdh_doit));
+                continue;
+            }
+            if (opt_found(algo, ecdh_choices, &amp;i)) {
+                ecdh_doit[i] = 2;
+                continue;
+            }
         }
-        if (strcmp(*argv, &quot;eddsa&quot;) == 0) {
-            for (loop = 0; loop &lt; OSSL_NELEM(eddsa_doit); loop++)
-                eddsa_doit[loop] = 1;
+        if (strcmp(algo, &quot;eddsa&quot;) == 0) {
+            memset(eddsa_doit, 1, sizeof(eddsa_doit));
             continue;
         }
-        if (found(*argv, eddsa_choices, &amp;i)) {
+        if (opt_found(algo, eddsa_choices, &amp;i)) {
             eddsa_doit[i] = 2;
             continue;
         }
 # ifndef OPENSSL_NO_SM2
-        if (strcmp(*argv, &quot;sm2&quot;) == 0) {
-            for (loop = 0; loop &lt; OSSL_NELEM(sm2_doit); loop++)
-                sm2_doit[loop] = 1;
+        if (strcmp(algo, &quot;sm2&quot;) == 0) {
+            memset(sm2_doit, 1, sizeof(sm2_doit));
             continue;
         }
-        if (found(*argv, sm2_choices, &amp;i)) {
+        if (opt_found(algo, sm2_choices, &amp;i)) {
             sm2_doit[i] = 2;
             continue;
         }
 # endif
-#endif
-        BIO_printf(bio_err, &quot;%s: Unknown algorithm %s\n&quot;, prog, *argv);
+#endif  /* OPENSSL_NO_EC */
+        BIO_printf(bio_err, &quot;%s: Unknown algorithm %s\n&quot;, prog, algo);
         goto end;
     }
 
@@ -2034,27 +1884,20 @@ int speed_main(int argc, char **argv)
 
     /* No parameters; turn on everything. */
     if (argc == 0 &amp;&amp; !doit[D_EVP] &amp;&amp; !doit[D_EVP_HMAC] &amp;&amp; !doit[D_EVP_CMAC]) {
-        for (i = 0; i &lt; ALGOR_NUM; i++)
-            if (i != D_EVP &amp;&amp; i != D_EVP_HMAC &amp;&amp; i != D_EVP_CMAC)
-                doit[i] = 1;
+        memset(doit, 1, sizeof(doit));
+        doit[D_EVP] = doit[D_EVP_HMAC] = doit[D_EVP_CMAC] = 0;
 #ifndef OPENSSL_NO_RSA
-        for (i = 0; i &lt; RSA_NUM; i++)
-            rsa_doit[i] = 1;
+        memset(rsa_doit, 1, sizeof(rsa_doit));
 #endif
 #ifndef OPENSSL_NO_DSA
-        for (i = 0; i &lt; DSA_NUM; i++)
-            dsa_doit[i] = 1;
+        memset(dsa_doit, 1, sizeof(dsa_doit));
 #endif
 #ifndef OPENSSL_NO_EC
-        for (loop = 0; loop &lt; OSSL_NELEM(ecdsa_doit); loop++)
-            ecdsa_doit[loop] = 1;
-        for (loop = 0; loop &lt; OSSL_NELEM(ecdh_doit); loop++)
-            ecdh_doit[loop] = 1;
-        for (loop = 0; loop &lt; OSSL_NELEM(eddsa_doit); loop++)
-            eddsa_doit[loop] = 1;
+        memset(ecdsa_doit, 1, sizeof(ecdsa_doit));
+        memset(ecdh_doit, 1, sizeof(ecdh_doit));
+        memset(eddsa_doit, 1, sizeof(eddsa_doit));
 # ifndef OPENSSL_NO_SM2
-        for (loop = 0; loop &lt; OSSL_NELEM(sm2_doit); loop++)
-            sm2_doit[loop] = 1;
+        memset(sm2_doit, 1, sizeof(sm2_doit));
 # endif
 #endif
     }
@@ -2074,11 +1917,10 @@ int speed_main(int argc, char **argv)
             break;
         }
         for (k = 0; k &lt; RSA_NUM; k++) {
-            const unsigned char *p;
+            const unsigned char *p = rsa_keys[k].data;
 
-            p = rsa_data[k];
             loopargs[i].rsa_key[k] =
-                d2i_RSAPrivateKey(NULL, &amp;p, rsa_data_length[k]);
+                d2i_RSAPrivateKey(NULL, &amp;p, rsa_keys[k].length);
             if (loopargs[i].rsa_key[k] == NULL) {
                 BIO_printf(bio_err,
                            &quot;internal error loading RSA key number %d\n&quot;, k);
@@ -2095,41 +1937,57 @@ int speed_main(int argc, char **argv)
     }
 #endif
 #ifndef OPENSSL_NO_DES
-    DES_set_key_unchecked(&amp;key, &amp;sch);
-    DES_set_key_unchecked(&amp;key2, &amp;sch2);
-    DES_set_key_unchecked(&amp;key3, &amp;sch3);
+    if (doit[D_CBC_DES] || doit[D_EDE3_DES]) {
+        static DES_cblock keys[] = {
+            { 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0 }, /* keys[0] */
+            { 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12 }, /* keys[1] */
+            { 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34 }  /* keys[3] */
+        };
+        DES_set_key_unchecked(&amp;keys[0], &amp;sch[0]);
+        DES_set_key_unchecked(&amp;keys[1], &amp;sch[1]);
+        DES_set_key_unchecked(&amp;keys[2], &amp;sch[2]);
+    }
 #endif
     AES_set_encrypt_key(key16, 128, &amp;aes_ks1);
     AES_set_encrypt_key(key24, 192, &amp;aes_ks2);
     AES_set_encrypt_key(key32, 256, &amp;aes_ks3);
 #ifndef OPENSSL_NO_CAMELLIA
-    Camellia_set_key(key16, 128, &amp;camellia_ks1);
-    Camellia_set_key(ckey24, 192, &amp;camellia_ks2);
-    Camellia_set_key(ckey32, 256, &amp;camellia_ks3);
+    if (doit[D_CBC_128_CML] || doit[D_CBC_192_CML] || doit[D_CBC_256_CML]) {
+        Camellia_set_key(key16, 128, &amp;camellia_ks[0]);
+        Camellia_set_key(key24, 192, &amp;camellia_ks[1]);
+        Camellia_set_key(key32, 256, &amp;camellia_ks[2]);
+    }
 #endif
 #ifndef OPENSSL_NO_IDEA
-    IDEA_set_encrypt_key(key16, &amp;idea_ks);
+    if (doit[D_CBC_IDEA])
+        IDEA_set_encrypt_key(key16, &amp;idea_ks);
 #endif
 #ifndef OPENSSL_NO_SEED
-    SEED_set_key(key16, &amp;seed_ks);
+    if (doit[D_CBC_SEED])
+        SEED_set_key(key16, &amp;seed_ks);
 #endif
 #ifndef OPENSSL_NO_RC4
-    RC4_set_key(&amp;rc4_ks, 16, key16);
+    if (doit[D_RC4])
+        RC4_set_key(&amp;rc4_ks, 16, key16);
 #endif
 #ifndef OPENSSL_NO_RC2
-    RC2_set_key(&amp;rc2_ks, 16, key16, 128);
+    if (doit[D_CBC_RC2])
+        RC2_set_key(&amp;rc2_ks, 16, key16, 128);
 #endif
 #ifndef OPENSSL_NO_RC5
-    if (!RC5_32_set_key(&amp;rc5_ks, 16, key16, 12)) {
-        BIO_printf(bio_err, &quot;Failed setting RC5 key\n&quot;);
-        goto end;
-    }
+    if (doit[D_CBC_RC5])
+        if (!RC5_32_set_key(&amp;rc5_ks, 16, key16, 12)) {
+            BIO_printf(bio_err, &quot;Failed setting RC5 key\n&quot;);
+            goto end;
+        }
 #endif
 #ifndef OPENSSL_NO_BF
-    BF_set_key(&amp;bf_ks, 16, key16);
+    if (doit[D_CBC_BF])
+        BF_set_key(&amp;bf_ks, 16, key16);
 #endif
 #ifndef OPENSSL_NO_CAST
-    CAST_set_key(&amp;cast_ks, 16, key16);
+    if (doit[D_CBC_CAST]) 
+        CAST_set_key(&amp;cast_ks, 16, key16);
 #endif
 #ifndef SIGALRM
 # ifndef OPENSSL_NO_DES
@@ -2144,7 +2002,6 @@ int speed_main(int argc, char **argv)
                             (DES_cblock *)loopargs[0].buf, &amp;sch, DES_ENCRYPT);
         d = Time_F(STOP);
     } while (d &lt; 3);
-    save_count = count;
     c[D_MD2][0] = count / 10;
     c[D_MDC2][0] = count / 10;
     c[D_MD4][0] = count;
@@ -2167,6 +2024,7 @@ int speed_main(int argc, char **argv)
     c[D_CBC_128_CML][0] = count;
     c[D_CBC_192_CML][0] = count;
     c[D_CBC_256_CML][0] = count;
+    c[D_EVP][0] = count;
     c[D_SHA256][0] = count;
     c[D_SHA512][0] = count;
     c[D_WHIRLPOOL][0] = count;
@@ -2175,12 +2033,12 @@ int speed_main(int argc, char **argv)
     c[D_IGE_256_AES][0] = count;
     c[D_GHASH][0] = count;
     c[D_RAND][0] = count;
+    c[D_EVP_HMAC][0] = count;
+    c[D_EVP_CMAC][0] = count;
 
     for (i = 1; i &lt; size_num; i++) {
-        long l0, l1;
-
-        l0 = (long)lengths[0];
-        l1 = (long)lengths[i];
+        long l0 = (long)lengths[0];
+        long l1 = (long)lengths[i];
 
         c[D_MD2][i] = c[D_MD2][0] * 4 * l0 / l1;
         c[D_MDC2][i] = c[D_MDC2][0] * 4 * l0 / l1;
@@ -2189,11 +2047,14 @@ int speed_main(int argc, char **argv)
         c[D_HMAC][i] = c[D_HMAC][0] * 4 * l0 / l1;
         c[D_SHA1][i] = c[D_SHA1][0] * 4 * l0 / l1;
         c[D_RMD160][i] = c[D_RMD160][0] * 4 * l0 / l1;
+        c[D_EVP][i] = = c[D_EVP][0] * 4 * l0 / l1;
         c[D_SHA256][i] = c[D_SHA256][0] * 4 * l0 / l1;
         c[D_SHA512][i] = c[D_SHA512][0] * 4 * l0 / l1;
         c[D_WHIRLPOOL][i] = c[D_WHIRLPOOL][0] * 4 * l0 / l1;
         c[D_GHASH][i] = c[D_GHASH][0] * 4 * l0 / l1;
         c[D_RAND][i] = c[D_RAND][0] * 4 * l0 / l1;
+        c[D_EVP_HMAC][i] = = c[D_EVP_HMAC][0] * 4 * l0 / l1;
+        c[D_EVP_CMAC][i] = = c[D_EVP_CMAC][0] * 4 * l0 / l1;
 
         l0 = (long)lengths[i - 1];
 
@@ -2365,7 +2226,7 @@ int speed_main(int argc, char **argv)
 #   ifndef OPENSSL_NO_SM2
     sm2_c[R_EC_SM2P256][0] = count / 1800;
 #   endif
-#  endif
+#  endif                          /* OPENSSL_NO_EC */
 
 # else
 /* not worth fixing */
@@ -2396,6 +2257,8 @@ int speed_main(int argc, char **argv)
             count = run_benchmark(async_jobs, EVP_Digest_MDC2_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_MDC2, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
     }
 #endif
@@ -2409,6 +2272,8 @@ int speed_main(int argc, char **argv)
             count = run_benchmark(async_jobs, EVP_Digest_MD4_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_MD4, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
     }
 #endif
@@ -2446,9 +2311,8 @@ int speed_main(int argc, char **argv)
             d = Time_F(STOP);
             print_result(D_HMAC, testnum, count, d);
         }
-        for (i = 0; i &lt; loopargs_len; i++) {
+        for (i = 0; i &lt; loopargs_len; i++)
             HMAC_CTX_free(loopargs[i].hctx);
-        }
     }
 #endif
     if (doit[D_SHA1]) {
@@ -2503,6 +2367,8 @@ int speed_main(int argc, char **argv)
             count = run_benchmark(async_jobs, EVP_Digest_RMD160_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_RMD160, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
     }
 #endif
@@ -2644,7 +2510,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_128_CML][testnum]); count++)
                 Camellia_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                     (size_t)lengths[testnum], &amp;camellia_ks1,
+                                     (size_t)lengths[testnum], &amp;camellia_ks[0],
                                      iv, CAMELLIA_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_128_CML, testnum, count, d);
@@ -2666,7 +2532,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_192_CML][testnum]); count++)
                 Camellia_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                     (size_t)lengths[testnum], &amp;camellia_ks2,
+                                     (size_t)lengths[testnum], &amp;camellia_ks[1],
                                      iv, CAMELLIA_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_192_CML, testnum, count, d);
@@ -2684,7 +2550,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_256_CML][testnum]); count++)
                 Camellia_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                     (size_t)lengths[testnum], &amp;camellia_ks3,
+                                     (size_t)lengths[testnum], &amp;camellia_ks[2],
                                      iv, CAMELLIA_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_256_CML, testnum, count, d);
@@ -2831,7 +2697,7 @@ int speed_main(int argc, char **argv)
 
     if (doit[D_EVP]) {
         if (evp_cipher != NULL) {
-            int (*loopfunc)(void *args) = EVP_Update_loop;
+            int (*loopfunc) (void *) = EVP_Update_loop;
 
             if (multiblock &amp;&amp; (EVP_CIPHER_flags(evp_cipher) &amp;
                                EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) {
@@ -2854,7 +2720,7 @@ int speed_main(int argc, char **argv)
             }
 
             for (testnum = 0; testnum &lt; size_num; testnum++) {
-                print_message(names[D_EVP], save_count, lengths[testnum],
+                print_message(names[D_EVP], c[D_EVP][testnum], lengths[testnum],
                               seconds.sym);
 
                 for (k = 0; k &lt; loopargs_len; k++) {
@@ -2900,7 +2766,7 @@ int speed_main(int argc, char **argv)
             names[D_EVP] = OBJ_nid2ln(EVP_MD_type(evp_md));
 
             for (testnum = 0; testnum &lt; size_num; testnum++) {
-                print_message(names[D_EVP], save_count, lengths[testnum],
+                print_message(names[D_EVP], c[D_EVP][testnum], lengths[testnum],
                               seconds.sym);
                 Time_F(START);
                 count = run_benchmark(async_jobs, EVP_Digest_loop, loopargs);
@@ -2910,52 +2776,50 @@ int speed_main(int argc, char **argv)
         }
     }
 
-    if (doit[D_EVP_HMAC]) {
-        if (evp_hmac_md != NULL) {
-            const char *md_name = OBJ_nid2ln(EVP_MD_type(evp_hmac_md));
-            evp_hmac_name = app_malloc(sizeof(&quot;HMAC()&quot;) + strlen(md_name),
-                                       &quot;HMAC name&quot;);
-            sprintf(evp_hmac_name, &quot;HMAC(%s)&quot;, md_name);
-            names[D_EVP_HMAC] = evp_hmac_name;
+    if (doit[D_EVP_HMAC] &amp;&amp; evp_hmac_md != NULL) {
+        const char *md_name = OBJ_nid2ln(EVP_MD_type(evp_hmac_md));
 
-            for (testnum = 0; testnum &lt; size_num; testnum++) {
-                print_message(names[D_EVP_HMAC], save_count, lengths[testnum],
-                              seconds.sym);
-                Time_F(START);
-                count = run_benchmark(async_jobs, EVP_HMAC_loop, loopargs);
-                d = Time_F(STOP);
-                print_result(D_EVP_HMAC, testnum, count, d);
-            }
+        evp_hmac_name = app_malloc(sizeof(&quot;HMAC()&quot;) + strlen(md_name),
+                                   &quot;HMAC name&quot;);
+        sprintf(evp_hmac_name, &quot;HMAC(%s)&quot;, md_name);
+        names[D_EVP_HMAC] = evp_hmac_name;
+
+        for (testnum = 0; testnum &lt; size_num; testnum++) {
+            print_message(names[D_EVP_HMAC], c[D_EVP_HMAC][testnum], lengths[testnum],
+                          seconds.sym);
+            Time_F(START);
+            count = run_benchmark(async_jobs, EVP_HMAC_loop, loopargs);
+            d = Time_F(STOP);
+            print_result(D_EVP_HMAC, testnum, count, d);
         }
     }
 
 #ifndef OPENSSL_NO_CMAC
-    if (doit[D_EVP_CMAC]) {
-        if (evp_cmac_cipher != NULL) {
-            const char *cipher_name = OBJ_nid2ln(EVP_CIPHER_type(evp_cmac_cipher));
-            evp_cmac_name = app_malloc(sizeof(&quot;CMAC()&quot;) + strlen(cipher_name),
-                                       &quot;CMAC name&quot;);
-            sprintf(evp_cmac_name, &quot;CMAC(%s)&quot;, cipher_name);
-            names[D_EVP_CMAC] = evp_cmac_name;
+    if (doit[D_EVP_CMAC] &amp;&amp; evp_cmac_cipher != NULL) {
+        const char *cipher_name = OBJ_nid2ln(EVP_CIPHER_type(evp_cmac_cipher));
 
-            for (i = 0; i &lt; loopargs_len; i++) {
-                loopargs[i].cmac_ctx = CMAC_CTX_new();
-                if (loopargs[i].cmac_ctx == NULL) {
-                    BIO_printf(bio_err, &quot;CMAC malloc failure, exiting...&quot;);
-                    exit(1);
-                }
-            }
-            for (testnum = 0; testnum &lt; size_num; testnum++) {
-                print_message(names[D_EVP_CMAC], save_count, lengths[testnum],
-                              seconds.sym);
-                Time_F(START);
-                count = run_benchmark(async_jobs, EVP_CMAC_loop, loopargs);
-                d = Time_F(STOP);
-                print_result(D_EVP_CMAC, testnum, count, d);
+        evp_cmac_name = app_malloc(sizeof(&quot;CMAC()&quot;) + strlen(cipher_name),
+                                   &quot;CMAC name&quot;);
+        sprintf(evp_cmac_name, &quot;CMAC(%s)&quot;, cipher_name);
+        names[D_EVP_CMAC] = evp_cmac_name;
+
+        for (i = 0; i &lt; loopargs_len; i++) {
+            loopargs[i].cmac_ctx = CMAC_CTX_new();
+            if (loopargs[i].cmac_ctx == NULL) {
+                BIO_printf(bio_err, &quot;CMAC malloc failure, exiting...&quot;);
+                exit(1);
             }
-            for (i = 0; i &lt; loopargs_len; i++)
-                CMAC_CTX_free(loopargs[i].cmac_ctx);
         }
+        for (testnum = 0; testnum &lt; size_num; testnum++) {
+            print_message(names[D_EVP_CMAC], c[D_EVP_CMAC][testnum], lengths[testnum],
+                          seconds.sym);
+            Time_F(START);
+            count = run_benchmark(async_jobs, EVP_CMAC_loop, loopargs);
+            d = Time_F(STOP);
+            print_result(D_EVP_CMAC, testnum, count, d);
+        }
+        for (i = 0; i &lt; loopargs_len; i++)
+            CMAC_CTX_free(loopargs[i].cmac_ctx);
     }
 #endif
 
@@ -2969,7 +2833,7 @@ int speed_main(int argc, char **argv)
         if (!rsa_doit[testnum])
             continue;
         for (i = 0; i &lt; loopargs_len; i++) {
-            if (primes &gt; 2) {
+            if (primes &gt; RSA_DEFAULT_PRIME_NUM) {
                 /* we haven't set keys yet,  generate multi-prime RSA keys */
                 BIGNUM *bn = BN_new();
 
@@ -2990,7 +2854,7 @@ int speed_main(int argc, char **argv)
                 }
 
                 if (!RSA_generate_multi_prime_key(loopargs[i].rsa_key[testnum],
-                                                  rsa_bits[testnum],
+                                                  rsa_keys[testnum].bits,
                                                   primes, bn, NULL)) {
                     BN_free(bn);
                     goto end;
@@ -3009,7 +2873,7 @@ int speed_main(int argc, char **argv)
             rsa_count = 1;
         } else {
             pkey_print_message(&quot;private&quot;, &quot;rsa&quot;,
-                               rsa_c[testnum][0], rsa_bits[testnum],
+                               rsa_c[testnum][0], rsa_keys[testnum].bits,
                                seconds.rsa);
             /* RSA_blinding_on(rsa_key[testnum],NULL); */
             Time_F(START);
@@ -3018,7 +2882,7 @@ int speed_main(int argc, char **argv)
             BIO_printf(bio_err,
                        mr ? &quot;+R1:%ld:%d:%.2f\n&quot;
                        : &quot;%ld %u bits private RSA's in %.2fs\n&quot;,
-                       count, rsa_bits[testnum], d);
+                       count, rsa_keys[testnum].bits, d);
             rsa_results[testnum][0] = (double)count / d;
             rsa_count = count;
         }
@@ -3036,7 +2900,7 @@ int speed_main(int argc, char **argv)
             rsa_doit[testnum] = 0;
         } else {
             pkey_print_message(&quot;public&quot;, &quot;rsa&quot;,
-                               rsa_c[testnum][1], rsa_bits[testnum],
+                               rsa_c[testnum][1], rsa_keys[testnum].bits,
                                seconds.rsa);
             Time_F(START);
             count = run_benchmark(async_jobs, RSA_verify_loop, loopargs);
@@ -3044,14 +2908,13 @@ int speed_main(int argc, char **argv)
             BIO_printf(bio_err,
                        mr ? &quot;+R2:%ld:%d:%.2f\n&quot;
                        : &quot;%ld %u bits public RSA's in %.2fs\n&quot;,
-                       count, rsa_bits[testnum], d);
+                       count, rsa_keys[testnum].bits, d);
             rsa_results[testnum][1] = (double)count / d;
         }
 
         if (rsa_count &lt;= 1) {
             /* if longer than 10s, don't do any more */
-            for (testnum++; testnum &lt; RSA_NUM; testnum++)
-                rsa_doit[testnum] = 0;
+            stop_it(rsa_doit, testnum);
         }
     }
 #endif                          /* OPENSSL_NO_RSA */
@@ -3121,8 +2984,7 @@ int speed_main(int argc, char **argv)
 
         if (rsa_count &lt;= 1) {
             /* if longer than 10s, don't do any more */
-            for (testnum++; testnum &lt; DSA_NUM; testnum++)
-                dsa_doit[testnum] = 0;
+            stop_it(dsa_doit, testnum);
         }
     }
 #endif                          /* OPENSSL_NO_DSA */
@@ -3135,7 +2997,7 @@ int speed_main(int argc, char **argv)
             continue;           /* Ignore Curve */
         for (i = 0; i &lt; loopargs_len; i++) {
             loopargs[i].ecdsa[testnum] =
-                EC_KEY_new_by_curve_name(test_curves[testnum].nid);
+                EC_KEY_new_by_curve_name(ec_curves[testnum].nid);
             if (loopargs[i].ecdsa[testnum] == NULL) {
                 st = 0;
                 break;
@@ -3164,7 +3026,7 @@ int speed_main(int argc, char **argv)
             } else {
                 pkey_print_message(&quot;sign&quot;, &quot;ecdsa&quot;,
                                    ecdsa_c[testnum][0],
-                                   test_curves[testnum].bits, seconds.ecdsa);
+                                   ec_curves[testnum].bits, seconds.ecdsa);
                 Time_F(START);
                 count = run_benchmark(async_jobs, ECDSA_sign_loop, loopargs);
                 d = Time_F(STOP);
@@ -3172,7 +3034,7 @@ int speed_main(int argc, char **argv)
                 BIO_printf(bio_err,
                            mr ? &quot;+R5:%ld:%u:%.2f\n&quot; :
                            &quot;%ld %u bits ECDSA signs in %.2fs \n&quot;,
-                           count, test_curves[testnum].bits, d);
+                           count, ec_curves[testnum].bits, d);
                 ecdsa_results[testnum][0] = (double)count / d;
                 rsa_count = count;
             }
@@ -3193,21 +3055,20 @@ int speed_main(int argc, char **argv)
             } else {
                 pkey_print_message(&quot;verify&quot;, &quot;ecdsa&quot;,
                                    ecdsa_c[testnum][1],
-                                   test_curves[testnum].bits, seconds.ecdsa);
+                                   ec_curves[testnum].bits, seconds.ecdsa);
                 Time_F(START);
                 count = run_benchmark(async_jobs, ECDSA_verify_loop, loopargs);
                 d = Time_F(STOP);
                 BIO_printf(bio_err,
                            mr ? &quot;+R6:%ld:%u:%.2f\n&quot;
                            : &quot;%ld %u bits ECDSA verify in %.2fs\n&quot;,
-                           count, test_curves[testnum].bits, d);
+                           count, ec_curves[testnum].bits, d);
                 ecdsa_results[testnum][1] = (double)count / d;
             }
 
             if (rsa_count &lt;= 1) {
                 /* if longer than 10s, don't do any more */
-                for (testnum++; testnum &lt; ECDSA_NUM; testnum++)
-                    ecdsa_doit[testnum] = 0;
+                stop_it(ecdsa_doit, testnum);
             }
         }
     }
@@ -3240,7 +3101,7 @@ int speed_main(int argc, char **argv)
              * If this fails we try creating a EVP_PKEY_EC generic param ctx,
              * then we set the curve by NID before deriving the actual keygen
              * ctx for that specific curve. */
-            kctx = EVP_PKEY_CTX_new_id(test_curves[testnum].nid, NULL); /* keygen ctx from NID */
+            kctx = EVP_PKEY_CTX_new_id(ec_curves[testnum].nid, NULL); /* keygen ctx from NID */
             if (!kctx) {
                 EVP_PKEY_CTX *pctx = NULL;
                 EVP_PKEY *params = NULL;
@@ -3263,13 +3124,13 @@ int speed_main(int argc, char **argv)
                     break;
                 }
 
-                if (            /* Create the context for parameter generation */
-                       !(pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL)) ||
+                /* Create the context for parameter generation */
+                if (!(pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL)) ||
                        /* Initialise the parameter generation */
                        !EVP_PKEY_paramgen_init(pctx) ||
                        /* Set the curve by NID */
                        !EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx,
-                                                               test_curves
+                                                               ec_curves
                                                                [testnum].nid) ||
                        /* Create the parameter object params */
                        !EVP_PKEY_paramgen(pctx, &amp;params)) {
@@ -3352,7 +3213,7 @@ int speed_main(int argc, char **argv)
         if (ecdh_checks != 0) {
             pkey_print_message(&quot;&quot;, &quot;ecdh&quot;,
                                ecdh_c[testnum][0],
-                               test_curves[testnum].bits, seconds.ecdh);
+                               ec_curves[testnum].bits, seconds.ecdh);
             Time_F(START);
             count =
                 run_benchmark(async_jobs, ECDH_EVP_derive_key_loop, loopargs);
@@ -3360,15 +3221,14 @@ int speed_main(int argc, char **argv)
             BIO_printf(bio_err,
                        mr ? &quot;+R7:%ld:%d:%.2f\n&quot; :
                        &quot;%ld %u-bits ECDH ops in %.2fs\n&quot;, count,
-                       test_curves[testnum].bits, d);
+                       ec_curves[testnum].bits, d);
             ecdh_results[testnum][0] = (double)count / d;
             rsa_count = count;
         }
 
         if (rsa_count &lt;= 1) {
             /* if longer than 10s, don't do any more */
-            for (testnum++; testnum &lt; OSSL_NELEM(ecdh_doit); testnum++)
-                ecdh_doit[testnum] = 0;
+            stop_it(ecdh_doit, testnum);
         }
     }
 
@@ -3386,7 +3246,7 @@ int speed_main(int argc, char **argv)
                 break;
             }
 
-            if ((ed_pctx = EVP_PKEY_CTX_new_id(test_ed_curves[testnum].nid, NULL))
+            if ((ed_pctx = EVP_PKEY_CTX_new_id(ed_curves[testnum].nid, NULL))
                     == NULL
                 || EVP_PKEY_keygen_init(ed_pctx) &lt;= 0
                 || EVP_PKEY_keygen(ed_pctx, &amp;ed_pkey) &lt;= 0) {
@@ -3411,7 +3271,7 @@ int speed_main(int argc, char **argv)
         } else {
             for (i = 0; i &lt; loopargs_len; i++) {
                 /* Perform EdDSA signature test */
-                loopargs[i].sigsize = test_ed_curves[testnum].sigsize;
+                loopargs[i].sigsize = ed_curves[testnum].sigsize;
                 st = EVP_DigestSign(loopargs[i].eddsa_ctx[testnum],
                                     loopargs[i].buf2, &amp;loopargs[i].sigsize,
                                     loopargs[i].buf, 20);
@@ -3424,9 +3284,9 @@ int speed_main(int argc, char **argv)
                 ERR_print_errors(bio_err);
                 rsa_count = 1;
             } else {
-                pkey_print_message(&quot;sign&quot;, test_ed_curves[testnum].name,
+                pkey_print_message(&quot;sign&quot;, ed_curves[testnum].name,
                                    eddsa_c[testnum][0],
-                                   test_ed_curves[testnum].bits, seconds.eddsa);
+                                   ed_curves[testnum].bits, seconds.eddsa);
                 Time_F(START);
                 count = run_benchmark(async_jobs, EdDSA_sign_loop, loopargs);
                 d = Time_F(STOP);
@@ -3434,8 +3294,8 @@ int speed_main(int argc, char **argv)
                 BIO_printf(bio_err,
                            mr ? &quot;+R8:%ld:%u:%s:%.2f\n&quot; :
                            &quot;%ld %u bits %s signs in %.2fs \n&quot;,
-                           count, test_ed_curves[testnum].bits,
-                           test_ed_curves[testnum].name, d);
+                           count, ed_curves[testnum].bits,
+                           ed_curves[testnum].name, d);
                 eddsa_results[testnum][0] = (double)count / d;
                 rsa_count = count;
             }
@@ -3454,24 +3314,23 @@ int speed_main(int argc, char **argv)
                 ERR_print_errors(bio_err);
                 eddsa_doit[testnum] = 0;
             } else {
-                pkey_print_message(&quot;verify&quot;, test_ed_curves[testnum].name,
+                pkey_print_message(&quot;verify&quot;, ed_curves[testnum].name,
                                    eddsa_c[testnum][1],
-                                   test_ed_curves[testnum].bits, seconds.eddsa);
+                                   ed_curves[testnum].bits, seconds.eddsa);
                 Time_F(START);
                 count = run_benchmark(async_jobs, EdDSA_verify_loop, loopargs);
                 d = Time_F(STOP);
                 BIO_printf(bio_err,
                            mr ? &quot;+R9:%ld:%u:%s:%.2f\n&quot;
                            : &quot;%ld %u bits %s verify in %.2fs\n&quot;,
-                           count, test_ed_curves[testnum].bits,
-                           test_ed_curves[testnum].name, d);
+                           count, ed_curves[testnum].bits,
+                           ed_curves[testnum].name, d);
                 eddsa_results[testnum][1] = (double)count / d;
             }
 
             if (rsa_count &lt;= 1) {
                 /* if longer than 10s, don't do any more */
-                for (testnum++; testnum &lt; EdDSA_NUM; testnum++)
-                    eddsa_doit[testnum] = 0;
+                stop_it(eddsa_doit, testnum);
             }
         }
     }
@@ -3480,105 +3339,73 @@ int speed_main(int argc, char **argv)
     for (testnum = 0; testnum &lt; SM2_NUM; testnum++) {
         int st = 1;
         EVP_PKEY *sm2_pkey = NULL;
-        EVP_PKEY_CTX *pctx = NULL;
-        EVP_PKEY_CTX *sm2_pctx = NULL;
-        EVP_PKEY_CTX *sm2_vfy_pctx = NULL;
-        size_t sm2_sigsize = 0;
 
         if (!sm2_doit[testnum])
             continue;           /* Ignore Curve */
         /* Init signing and verification */
         for (i = 0; i &lt; loopargs_len; i++) {
+            EVP_PKEY_CTX *sm2_pctx = NULL;
+            EVP_PKEY_CTX *sm2_vfy_pctx = NULL;
+            EVP_PKEY_CTX *pctx = NULL;
+            st = 0;
+
             loopargs[i].sm2_ctx[testnum] = EVP_MD_CTX_new();
-            if (loopargs[i].sm2_ctx[testnum] == NULL) {
-                st = 0;
-                break;
-            }
             loopargs[i].sm2_vfy_ctx[testnum] = EVP_MD_CTX_new();
-            if (loopargs[i].sm2_vfy_ctx[testnum] == NULL) {
-                st = 0;
+            if (loopargs[i].sm2_ctx[testnum] == NULL
+                    || loopargs[i].sm2_vfy_ctx[testnum] == NULL)
                 break;
-            }
 
             /* SM2 keys are generated as normal EC keys with a special curve */
-            if ((pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL)) == NULL
+            st = !((pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL)) == NULL
                 || EVP_PKEY_keygen_init(pctx) &lt;= 0
                 || EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx,
-                    test_sm2_curves[testnum].nid) &lt;= 0
-                || EVP_PKEY_keygen(pctx, &amp;sm2_pkey) &lt;= 0) {
-                st = 0;
-                EVP_PKEY_CTX_free(pctx);
-                break;
-            }
-            /* free previous one and alloc a new one */
+                    sm2_curves[testnum].nid) &lt;= 0
+                || EVP_PKEY_keygen(pctx, &amp;sm2_pkey) &lt;= 0);
             EVP_PKEY_CTX_free(pctx);
+            if (st == 0)
+                break;
 
-            loopargs[i].sigsize = sm2_sigsize
-                = ECDSA_size(EVP_PKEY_get0_EC_KEY(sm2_pkey));
-
-            if (!EVP_PKEY_set_alias_type(sm2_pkey, EVP_PKEY_SM2)) {
-                st = 0;
-                EVP_PKEY_free(sm2_pkey);
+            st = 0; /* set back to zero */
+            /* attach it sooner to rely on main final cleanup */
+            loopargs[i].sm2_pkey[testnum] = sm2_pkey;
+            loopargs[i].sigsize = ECDSA_size(EVP_PKEY_get0_EC_KEY(sm2_pkey));
+            if (!EVP_PKEY_set_alias_type(sm2_pkey, EVP_PKEY_SM2))
                 break;
-            }
 
             sm2_pctx = EVP_PKEY_CTX_new(sm2_pkey, NULL);
-            if (sm2_pctx == NULL) {
-                st = 0;
-                EVP_PKEY_free(sm2_pkey);
-                break;
-            }
             sm2_vfy_pctx = EVP_PKEY_CTX_new(sm2_pkey, NULL);
-            if (sm2_vfy_pctx == NULL) {
-                st = 0;
-                EVP_PKEY_CTX_free(sm2_pctx);
-                EVP_PKEY_free(sm2_pkey);
+            if (sm2_pctx == NULL || sm2_vfy_pctx == NULL) {
+                EVP_PKEY_CTX_free(sm2_vfy_pctx);
                 break;
             }
+            /* attach them directly to respective ctx */
+            EVP_MD_CTX_set_pkey_ctx(loopargs[i].sm2_ctx[testnum], sm2_pctx);
+            EVP_MD_CTX_set_pkey_ctx(loopargs[i].sm2_vfy_ctx[testnum], sm2_vfy_pctx);
+
             /*
              * No need to allow user to set an explicit ID here, just use
              * the one defined in the 'draft-yang-tls-tl13-sm-suites' I-D.
              */
-            if (EVP_PKEY_CTX_set1_id(sm2_pctx, SM2_ID, SM2_ID_LEN) != 1) {
-                st = 0;
-                EVP_PKEY_CTX_free(sm2_pctx);
-                EVP_PKEY_CTX_free(sm2_vfy_pctx);
-                EVP_PKEY_free(sm2_pkey);
+            if (EVP_PKEY_CTX_set1_id(sm2_pctx, SM2_ID, SM2_ID_LEN) != 1
+                || EVP_PKEY_CTX_set1_id(sm2_vfy_pctx, SM2_ID, SM2_ID_LEN) != 1)
                 break;
-            }
-
-            if (EVP_PKEY_CTX_set1_id(sm2_vfy_pctx, SM2_ID, SM2_ID_LEN) != 1) {
-                st = 0;
-                EVP_PKEY_CTX_free(sm2_pctx);
-                EVP_PKEY_CTX_free(sm2_vfy_pctx);
-                EVP_PKEY_free(sm2_pkey);
-                break;
-            }
-
-            EVP_MD_CTX_set_pkey_ctx(loopargs[i].sm2_ctx[testnum], sm2_pctx);
-            EVP_MD_CTX_set_pkey_ctx(loopargs[i].sm2_vfy_ctx[testnum], sm2_vfy_pctx);
 
             if (!EVP_DigestSignInit(loopargs[i].sm2_ctx[testnum], NULL,
-                                    EVP_sm3(), NULL, sm2_pkey)) {
-                st = 0;
-                EVP_PKEY_free(sm2_pkey);
+                                    EVP_sm3(), NULL, sm2_pkey))
                 break;
-            }
             if (!EVP_DigestVerifyInit(loopargs[i].sm2_vfy_ctx[testnum], NULL,
-                                      EVP_sm3(), NULL, sm2_pkey)) {
-                st = 0;
-                EVP_PKEY_free(sm2_pkey);
+                                      EVP_sm3(), NULL, sm2_pkey))
                 break;
-            }
-            loopargs[i].sm2_pkey[testnum] = sm2_pkey;
+            st = 1;         /* mark loop as succeeded */
         }
         if (st == 0) {
-            BIO_printf(bio_err, &quot;SM2 failure.\n&quot;);
+            BIO_printf(bio_err, &quot;SM2 init failure.\n&quot;);
             ERR_print_errors(bio_err);
             rsa_count = 1;
         } else {
             for (i = 0; i &lt; loopargs_len; i++) {
-                sm2_sigsize = loopargs[i].sigsize;
+                size_t sm2_sigsize = loopargs[i].sigsize;
+
                 /* Perform SM2 signature test */
                 st = EVP_DigestSign(loopargs[i].sm2_ctx[testnum],
                                     loopargs[i].buf2, &amp;sm2_sigsize,
@@ -3592,9 +3419,9 @@ int speed_main(int argc, char **argv)
                 ERR_print_errors(bio_err);
                 rsa_count = 1;
             } else {
-                pkey_print_message(&quot;sign&quot;, test_sm2_curves[testnum].name,
+                pkey_print_message(&quot;sign&quot;, sm2_curves[testnum].name,
                                    sm2_c[testnum][0],
-                                   test_sm2_curves[testnum].bits, seconds.sm2);
+                                   sm2_curves[testnum].bits, seconds.sm2);
                 Time_F(START);
                 count = run_benchmark(async_jobs, SM2_sign_loop, loopargs);
                 d = Time_F(STOP);
@@ -3602,8 +3429,8 @@ int speed_main(int argc, char **argv)
                 BIO_printf(bio_err,
                            mr ? &quot;+R8:%ld:%u:%s:%.2f\n&quot; :
                            &quot;%ld %u bits %s signs in %.2fs \n&quot;,
-                           count, test_sm2_curves[testnum].bits,
-                           test_sm2_curves[testnum].name, d);
+                           count, sm2_curves[testnum].bits,
+                           sm2_curves[testnum].name, d);
                 sm2_results[testnum][0] = (double)count / d;
                 rsa_count = count;
             }
@@ -3622,17 +3449,17 @@ int speed_main(int argc, char **argv)
                 ERR_print_errors(bio_err);
                 sm2_doit[testnum] = 0;
             } else {
-                pkey_print_message(&quot;verify&quot;, test_sm2_curves[testnum].name,
+                pkey_print_message(&quot;verify&quot;, sm2_curves[testnum].name,
                                    sm2_c[testnum][1],
-                                   test_sm2_curves[testnum].bits, seconds.sm2);
+                                   sm2_curves[testnum].bits, seconds.sm2);
                 Time_F(START);
                 count = run_benchmark(async_jobs, SM2_verify_loop, loopargs);
                 d = Time_F(STOP);
                 BIO_printf(bio_err,
                            mr ? &quot;+R9:%ld:%u:%s:%.2f\n&quot;
                            : &quot;%ld %u bits %s verify in %.2fs\n&quot;,
-                           count, test_sm2_curves[testnum].bits,
-                           test_sm2_curves[testnum].name, d);
+                           count, sm2_curves[testnum].bits,
+                           sm2_curves[testnum].name, d);
                 sm2_results[testnum][1] = (double)count / d;
             }
 
@@ -3713,10 +3540,10 @@ int speed_main(int argc, char **argv)
         }
         if (mr)
             printf(&quot;+F2:%u:%u:%f:%f\n&quot;,
-                   k, rsa_bits[k], rsa_results[k][0], rsa_results[k][1]);
+                   k, rsa_keys[k].bits, rsa_results[k][0], rsa_results[k][1]);
         else
             printf(&quot;rsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\n&quot;,
-                   rsa_bits[k], 1.0 / rsa_results[k][0], 1.0 / rsa_results[k][1],
+                   rsa_keys[k].bits, 1.0 / rsa_results[k][0], 1.0 / rsa_results[k][1],
                    rsa_results[k][0], rsa_results[k][1]);
     }
 #endif
@@ -3750,11 +3577,11 @@ int speed_main(int argc, char **argv)
 
         if (mr)
             printf(&quot;+F4:%u:%u:%f:%f\n&quot;,
-                   k, test_curves[k].bits,
+                   k, ec_curves[k].bits,
                    ecdsa_results[k][0], ecdsa_results[k][1]);
         else
             printf(&quot;%4u bits ecdsa (%s) %8.4fs %8.4fs %8.1f %8.1f\n&quot;,
-                   test_curves[k].bits, test_curves[k].name,
+                   ec_curves[k].bits, ec_curves[k].name,
                    1.0 / ecdsa_results[k][0], 1.0 / ecdsa_results[k][1],
                    ecdsa_results[k][0], ecdsa_results[k][1]);
     }
@@ -3769,12 +3596,12 @@ int speed_main(int argc, char **argv)
         }
         if (mr)
             printf(&quot;+F5:%u:%u:%f:%f\n&quot;,
-                   k, test_curves[k].bits,
+                   k, ec_curves[k].bits,
                    ecdh_results[k][0], 1.0 / ecdh_results[k][0]);
 
         else
             printf(&quot;%4u bits ecdh (%s) %8.4fs %8.1f\n&quot;,
-                   test_curves[k].bits, test_curves[k].name,
+                   ec_curves[k].bits, ec_curves[k].name,
                    1.0 / ecdh_results[k][0], ecdh_results[k][0]);
     }
 
@@ -3789,11 +3616,11 @@ int speed_main(int argc, char **argv)
 
         if (mr)
             printf(&quot;+F6:%u:%u:%s:%f:%f\n&quot;,
-                   k, test_ed_curves[k].bits, test_ed_curves[k].name,
+                   k, ed_curves[k].bits, ed_curves[k].name,
                    eddsa_results[k][0], eddsa_results[k][1]);
         else
             printf(&quot;%4u bits EdDSA (%s) %8.4fs %8.4fs %8.1f %8.1f\n&quot;,
-                   test_ed_curves[k].bits, test_ed_curves[k].name,
+                   ed_curves[k].bits, ed_curves[k].name,
                    1.0 / eddsa_results[k][0], 1.0 / eddsa_results[k][1],
                    eddsa_results[k][0], eddsa_results[k][1]);
     }
@@ -3810,16 +3637,16 @@ int speed_main(int argc, char **argv)
 
         if (mr)
             printf(&quot;+F6:%u:%u:%s:%f:%f\n&quot;,
-                   k, test_sm2_curves[k].bits, test_sm2_curves[k].name,
+                   k, sm2_curves[k].bits, sm2_curves[k].name,
                    sm2_results[k][0], sm2_results[k][1]);
         else
             printf(&quot;%4u bits SM2 (%s) %8.4fs %8.4fs %8.1f %8.1f\n&quot;,
-                   test_sm2_curves[k].bits, test_sm2_curves[k].name,
+                   sm2_curves[k].bits, sm2_curves[k].name,
                    1.0 / sm2_results[k][0], 1.0 / sm2_results[k][1],
                    sm2_results[k][0], sm2_results[k][1]);
     }
 # endif
-#endif
+#endif                          /* OPENSSL_NO_EC */
 
     ret = 0;
 
@@ -3920,8 +3747,10 @@ static void pkey_print_message(const char *str, const char *str2, long num,
 static void print_result(int alg, int run_no, int count, double time_used)
 {
     if (count == -1) {
-        BIO_puts(bio_err, &quot;EVP error!\n&quot;);
-        exit(1);
+        BIO_printf(bio_err, &quot;%s error!\n&quot;, names[alg]);
+        ERR_print_errors(bio_err);
+        /* exit(1);  disable exit until default provider enabled */
+        return;
     }
     BIO_printf(bio_err,
                mr ? &quot;+R:%d:%s:%f\n&quot;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026514.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="026530.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26525">[ date ]</a>
              <a href="thread.html#26525">[ thread ]</a>
              <a href="subject.html#26525">[ subject ]</a>
              <a href="author.html#26525">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
