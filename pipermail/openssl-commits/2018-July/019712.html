<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2018-July/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1530540683.851738.18205.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019710.html">
   <LINK REL="Next"  HREF="019715.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1530540683.851738.18205.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Mon Jul  2 14:11:23 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="019710.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="019715.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19712">[ date ]</a>
              <a href="thread.html#19712">[ thread ]</a>
              <a href="subject.html#19712">[ subject ]</a>
              <a href="author.html#19712">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  3bb5e5b09e32defefda2b61087c113203005ffa0 (commit)
       via  5a42141565a4074167b006e7a28a822176b40f86 (commit)
       via  dc7a3543e0244bfdb9cbca1408fb7a6aa5da34b5 (commit)
       via  c9598459b6c797bd316e44834f5129bdf28add2b (commit)
       via  5d263fb78b51f96753056f21abc4d992d0219df2 (commit)
      from  b6ff436fcb597663ffcfe6d724d207cf120e7250 (commit)


- Log -----------------------------------------------------------------
commit 3bb5e5b09e32defefda2b61087c113203005ffa0
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Jun 15 14:55:06 2018 +0100

    Add the ability to configure anti-replay via SSL_CONF
    
    This also adds the ability to control this through s_server
    
    Reviewed-by: Viktor Dukhovni &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">viktor at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6469">https://github.com/openssl/openssl/pull/6469</A>)

commit 5a42141565a4074167b006e7a28a822176b40f86
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Jun 8 10:03:19 2018 +0100

    Add a test for the new early data callback
    
    Reviewed-by: Viktor Dukhovni &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">viktor at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6469">https://github.com/openssl/openssl/pull/6469</A>)

commit dc7a3543e0244bfdb9cbca1408fb7a6aa5da34b5
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Jun 7 16:32:19 2018 +0100

    Document the new early data callback and option
    
    Document SSL_OP_NO_ANTI_REPLAY and SSL_CTX_set_allow_early_data_cb()
    
    Reviewed-by: Viktor Dukhovni &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">viktor at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6469">https://github.com/openssl/openssl/pull/6469</A>)

commit c9598459b6c797bd316e44834f5129bdf28add2b
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Jun 7 15:14:36 2018 +0100

    Add setters to set the early_data callback
    
    Reviewed-by: Viktor Dukhovni &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">viktor at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6469">https://github.com/openssl/openssl/pull/6469</A>)

commit 5d263fb78b51f96753056f21abc4d992d0219df2
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Jun 7 09:11:05 2018 +0100

    Make the anti-replay feature optional
    
    Fixes #6389
    
    Reviewed-by: Viktor Dukhovni &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">viktor at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6469">https://github.com/openssl/openssl/pull/6469</A>)

-----------------------------------------------------------------------

Summary of changes:
 apps/s_server.c                  |   5 ++
 doc/man1/s_server.pod            |  11 ++++
 doc/man3/SSL_CONF_cmd.pod        |  21 +++++++
 doc/man3/SSL_CTX_set_options.pod |  11 ++++
 doc/man3/SSL_read_early_data.pod |  35 ++++++++++-
 include/openssl/ssl.h            |  16 ++++-
 ssl/ssl_conf.c                   |  11 +++-
 ssl/ssl_lib.c                    |  22 ++++++-
 ssl/ssl_locl.h                   |   9 +++
 ssl/statem/extensions.c          |   5 +-
 ssl/statem/extensions_srvr.c     |   4 +-
 ssl/statem/statem_srvr.c         |   6 +-
 test/sslapitest.c                | 131 ++++++++++++++++++++++++++++++++++-----
 util/libssl.num                  |   2 +
 util/private.num                 |   2 +
 15 files changed, 267 insertions(+), 24 deletions(-)

diff --git a/apps/s_server.c b/apps/s_server.c
index df2bf02..b050200 100644
--- a/apps/s_server.c
+++ b/apps/s_server.c
@@ -749,6 +749,7 @@ typedef enum OPTION_choice {
     OPT_CERT2, OPT_KEY2, OPT_NEXTPROTONEG, OPT_ALPN,
     OPT_SRTP_PROFILES, OPT_KEYMATEXPORT, OPT_KEYMATEXPORTLEN,
     OPT_KEYLOG_FILE, OPT_MAX_EARLY, OPT_EARLY_DATA, OPT_S_NUM_TICKETS,
+    OPT_ANTI_REPLAY, OPT_NO_ANTI_REPLAY,
     OPT_R_ENUM,
     OPT_S_ENUM,
     OPT_V_ENUM,
@@ -958,6 +959,8 @@ const OPTIONS s_server_options[] = {
     {&quot;early_data&quot;, OPT_EARLY_DATA, '-', &quot;Attempt to read early data&quot;},
     {&quot;num_tickets&quot;, OPT_S_NUM_TICKETS, 'n',
      &quot;The number of TLSv1.3 session tickets that a server will automatically  issue&quot; },
+    {&quot;anti_replay&quot;, OPT_ANTI_REPLAY, '-', &quot;Switch on anti-replay protection (default)&quot;},
+    {&quot;no_anti_replay&quot;, OPT_NO_ANTI_REPLAY, '-', &quot;Switch off anti-replay protection&quot;},
     {NULL, OPT_EOF, 0, NULL}
 };
 
@@ -1258,6 +1261,8 @@ int s_server_main(int argc, char *argv[])
             break;
         case OPT_S_CASES:
         case OPT_S_NUM_TICKETS:
+        case OPT_ANTI_REPLAY:
+        case OPT_NO_ANTI_REPLAY:
             if (ssl_args == NULL)
                 ssl_args = sk_OPENSSL_STRING_new_null();
             if (ssl_args == NULL
diff --git a/doc/man1/s_server.pod b/doc/man1/s_server.pod
index 2b7db63..f601794 100644
--- a/doc/man1/s_server.pod
+++ b/doc/man1/s_server.pod
@@ -180,6 +180,8 @@ B&lt;openssl&gt; B&lt;s_server&gt;
 [B&lt;-keylogfile outfile&gt;]
 [B&lt;-max_early_data int&gt;]
 [B&lt;-early_data&gt;]
+[B&lt;-anti_replay&gt;]
+[B&lt;-no_anti_replay&gt;]
 
 =head1 DESCRIPTION
 
@@ -709,6 +711,15 @@ greater than or equal to 0.
 
 Accept early data where possible.
 
+=item B&lt;-anti_replay&gt;, B&lt;-no_anti_replay&gt;
+
+Switches replay protection on or off, respectively. Replay protection is on by
+default unless overridden by a configuration file. When it is on, OpenSSL will
+automatically detect if a session ticket has been used more than once, TLSv1.3
+has been negotiated, and early data is enabled on the server. A full handshake
+is forced if a session ticket is used a second or subsequent time. Any early
+data that was sent will be rejected.
+
 =back
 
 =head1 CONNECTED COMMANDS
diff --git a/doc/man3/SSL_CONF_cmd.pod b/doc/man3/SSL_CONF_cmd.pod
index 4d3e9c2..4edd49c 100644
--- a/doc/man3/SSL_CONF_cmd.pod
+++ b/doc/man3/SSL_CONF_cmd.pod
@@ -211,6 +211,18 @@ that there will be no forward secrecy for the resumed session.
 enables strict mode protocol handling. Equivalent to setting
 B&lt;SSL_CERT_FLAG_TLS_STRICT&gt;.
 
+=item B&lt;-anti_replay&gt;, B&lt;-no_anti_replay&gt;
+
+Switches replay protection, on or off respectively. With replay protection on,
+OpenSSL will automatically detect if a session ticket has been used more than
+once, TLSv1.3 has been negotiated, and early data is enabled on the server. A
+full handshake is forced if a session ticket is used a second or subsequent
+time. Anti-Replay is on by default unless overridden by a configuration file and
+is only used by servers. Anti-replay measures are required for compliance with
+the TLSv1.3 specification. Some applications may be able to mitigate the replay
+risks in other ways and in such cases the built-in OpenSSL functionality is not
+required. Switching off anti-replay is equivalent to B&lt;SSL_OP_NO_ANTI_REPLAY&gt;.
+
 =back
 
 =head1 SUPPORTED CONFIGURATION FILE COMMANDS
@@ -441,6 +453,15 @@ middleboxes that do not understand TLSv1.3 will not drop the connection. This
 option is set by default. A future version of OpenSSL may not set this by
 default. Equivalent to B&lt;SSL_OP_ENABLE_MIDDLEBOX_COMPAT&gt;.
 
+B&lt;AntiReplay&gt;: If set then OpenSSL will automatically detect if a session ticket
+has been used more than once, TLSv1.3 has been negotiated, and early data is
+enabled on the server. A full handshake is forced if a session ticket is used a
+second or subsequent time. This option is set by default and is only used by
+servers. Anti-replay measures are required to comply with the TLSv1.3
+specification. Some applications may be able to mitigate the replay risks in
+other ways and in such cases the built-in OpenSSL functionality is not required.
+Disabling anti-replay is equivalent to setting B&lt;SSL_OP_NO_ANTI_REPLAY&gt;.
+
 =item B&lt;VerifyMode&gt;
 
 The B&lt;value&gt; argument is a comma separated list of flags to set.
diff --git a/doc/man3/SSL_CTX_set_options.pod b/doc/man3/SSL_CTX_set_options.pod
index f04de32..ae5ca1b 100644
--- a/doc/man3/SSL_CTX_set_options.pod
+++ b/doc/man3/SSL_CTX_set_options.pod
@@ -226,6 +226,17 @@ this option is set or not CCS messages received from the peer will always be
 ignored in TLSv1.3. This option is set by default. To switch it off use
 SSL_clear_options(). A future version of OpenSSL may not set this by default.
 
+=item SSL_OP_NO_ANTI_REPLAY
+
+By default, when a server is configured for early data (i.e., max_early_data &gt; 0),
+OpenSSL will switch on replay protection. See L&lt;SSL_read_early_data(3)&gt; for a
+description of the replay protection feature. Anti-replay measures are required
+to comply with the TLSv1.3 specification. Some applications may be able to
+mitigate the replay risks in other ways and in such cases the built in OpenSSL
+functionality is not required. Those applications can turn this feature off by
+setting this option. This is a server-side opton only. It is ignored by
+clients.
+
 =back
 
 The following options no longer have any effect but their identifiers are
diff --git a/doc/man3/SSL_read_early_data.pod b/doc/man3/SSL_read_early_data.pod
index 6a76ec2..cf6f757 100644
--- a/doc/man3/SSL_read_early_data.pod
+++ b/doc/man3/SSL_read_early_data.pod
@@ -10,7 +10,10 @@ SSL_SESSION_get_max_early_data,
 SSL_SESSION_set_max_early_data,
 SSL_write_early_data,
 SSL_read_early_data,
-SSL_get_early_data_status
+SSL_get_early_data_status,
+SSL_allow_early_data_cb_fn,
+SSL_CTX_set_allow_early_data_cb,
+SSL_set_allow_early_data_cb
 - functions for sending and receiving early data
 
 =head1 SYNOPSIS
@@ -30,6 +33,16 @@ SSL_get_early_data_status
 
  int SSL_get_early_data_status(const SSL *s);
 
+
+ typedef int (*SSL_allow_early_data_cb_fn)(SSL *s, void *arg);
+
+ void SSL_CTX_set_allow_early_data_cb(SSL_CTX *ctx,
+                                      SSL_allow_early_data_cb_fn cb,
+                                      void *arg);
+ void SSL_set_allow_early_data_cb(SSL *s,
+                                  SSL_allow_early_data_cb_fn cb,
+                                  void *arg);
+
 =head1 DESCRIPTION
 
 These functions are used to send and receive early data where TLSv1.3 has been
@@ -186,6 +199,20 @@ In the event that the current maximum early data setting for the server is
 different to that originally specified in a session that a client is resuming
 with then the lower of the two values will apply.
 
+Some server applications may wish to have more control over whether early data
+is accepted or not, for example to mitigate replay risks (see L&lt;/REPLAY PROTECTION&gt;
+below) or to decline early_data when the server is heavily loaded. The functions
+SSL_CTX_set_allow_early_data_cb() and SSL_set_allow_early_data_cb() set a
+callback which is called at a point in the handshake immediately before a
+decision is made to accept or reject early data. The callback is provided with a
+pointer to the user data argument that was provided when the callback was first
+set. Returning 1 from the callback will allow early data and returning 0 will
+reject it. Note that the OpenSSL library may reject early data for other reasons
+in which case this callback will not get called. Notably, the built-in replay
+protection feature will still be used even if a callback is present unless it
+has been explicitly disabled using the SSL_OP_NO_ANTI_REPLAY option. See
+L&lt;/REPLAY PROTECTION&gt; below.
+
 =head1 NOTES
 
 The whole purpose of early data is to enable a client to start sending data to
@@ -252,6 +279,12 @@ The OpenSSL replay protection does not apply to external Pre Shared Keys (PSKs)
 (e.g. see SSL_CTX_set_psk_find_session_callback(3)). Therefore extreme caution
 should be applied when combining external PSKs with early data.
 
+Some applications may mitigate the replay risks in other ways. For those
+applications it is possible to turn off the built-in replay protection feature
+using the B&lt;SSL_OP_NO_ANTI_REPLAY&gt; option. See L&lt;SSL_CTX_set_options(3)&gt; for
+details. Applications can also set a callback to make decisions about accepting
+early data or not. See SSL_CTX_set_allow_early_data_cb() above for details.
+
 =head1 RETURN VALUES
 
 SSL_write_early_data() returns 1 for success or 0 for failure. In the event of a
diff --git a/include/openssl/ssl.h b/include/openssl/ssl.h
index 943a8d6..bbcfb3c 100644
--- a/include/openssl/ssl.h
+++ b/include/openssl/ssl.h
@@ -368,6 +368,12 @@ typedef int (*SSL_verify_cb)(int preverify_ok, X509_STORE_CTX *x509_ctx);
  */
 # define SSL_OP_TLS_ROLLBACK_BUG                         0x00800000U
 
+/*
+ * Switches off automatic TLSv1.3 anti-replay protection for early data. This
+ * is a server-side option only (no effect on the client).
+ */
+# define SSL_OP_NO_ANTI_REPLAY                           0x01000000U
+
 # define SSL_OP_NO_SSLv3                                 0x02000000U
 # define SSL_OP_NO_TLSv1                                 0x04000000U
 # define SSL_OP_NO_TLSv1_2                               0x08000000U
@@ -2383,13 +2389,19 @@ int SSL_SESSION_get0_ticket_appdata(SSL_SESSION *ss, void **data, size_t *len);
 
 extern const char SSL_version_str[];
 
-
-
 typedef unsigned int (*DTLS_timer_cb)(SSL *s, unsigned int timer_us);
 
 void DTLS_set_timer_cb(SSL *s, DTLS_timer_cb cb);
 
 
+typedef int (*SSL_allow_early_data_cb_fn)(SSL *s, void *arg);
+void SSL_CTX_set_allow_early_data_cb(SSL_CTX *ctx,
+                                     SSL_allow_early_data_cb_fn cb,
+                                     void *arg);
+void SSL_set_allow_early_data_cb(SSL *s,
+                                 SSL_allow_early_data_cb_fn cb,
+                                 void *arg);
+
 # ifdef  __cplusplus
 }
 # endif
diff --git a/ssl/ssl_conf.c b/ssl/ssl_conf.c
index 758f012..9c20270 100644
--- a/ssl/ssl_conf.c
+++ b/ssl/ssl_conf.c
@@ -383,7 +383,8 @@ static int cmd_Options(SSL_CONF_CTX *cctx, const char *value)
         SSL_FLAG_TBL(&quot;NoRenegotiation&quot;, SSL_OP_NO_RENEGOTIATION),
         SSL_FLAG_TBL(&quot;AllowNoDHEKEX&quot;, SSL_OP_ALLOW_NO_DHE_KEX),
         SSL_FLAG_TBL(&quot;PrioritizeChaCha&quot;, SSL_OP_PRIORITIZE_CHACHA),
-        SSL_FLAG_TBL(&quot;MiddleboxCompat&quot;, SSL_OP_ENABLE_MIDDLEBOX_COMPAT)
+        SSL_FLAG_TBL(&quot;MiddleboxCompat&quot;, SSL_OP_ENABLE_MIDDLEBOX_COMPAT),
+        SSL_FLAG_TBL_INV(&quot;AntiReplay&quot;, SSL_OP_NO_ANTI_REPLAY)
     };
     if (value == NULL)
         return -3;
@@ -626,6 +627,8 @@ static const ssl_conf_cmd_tbl ssl_conf_cmds[] = {
     SSL_CONF_CMD_SWITCH(&quot;prioritize_chacha&quot;, SSL_CONF_FLAG_SERVER),
     SSL_CONF_CMD_SWITCH(&quot;strict&quot;, 0),
     SSL_CONF_CMD_SWITCH(&quot;no_middlebox&quot;, 0),
+    SSL_CONF_CMD_SWITCH(&quot;anti_replay&quot;, SSL_CONF_FLAG_SERVER),
+    SSL_CONF_CMD_SWITCH(&quot;no_anti_replay&quot;, SSL_CONF_FLAG_SERVER),
     SSL_CONF_CMD_STRING(SignatureAlgorithms, &quot;sigalgs&quot;, 0),
     SSL_CONF_CMD_STRING(ClientSignatureAlgorithms, &quot;client_sigalgs&quot;, 0),
     SSL_CONF_CMD_STRING(Curves, &quot;curves&quot;, 0),
@@ -671,7 +674,7 @@ static const ssl_conf_cmd_tbl ssl_conf_cmds[] = {
                  SSL_CONF_TYPE_FILE),
 #endif
     SSL_CONF_CMD_STRING(RecordPadding, &quot;record_padding&quot;, 0),
-    SSL_CONF_CMD_STRING(NumTickets, &quot;num_tickets&quot;, SSL_CONF_FLAG_SERVER)
+    SSL_CONF_CMD_STRING(NumTickets, &quot;num_tickets&quot;, SSL_CONF_FLAG_SERVER),
 };
 
 /* Supported switches: must match order of switches in ssl_conf_cmds */
@@ -704,6 +707,10 @@ static const ssl_switch_tbl ssl_cmd_switches[] = {
     {SSL_CERT_FLAG_TLS_STRICT, SSL_TFLAG_CERT}, /* strict */
     /* no_middlebox */
     {SSL_OP_ENABLE_MIDDLEBOX_COMPAT, SSL_TFLAG_INV},
+    /* anti_replay */
+    {SSL_OP_NO_ANTI_REPLAY, SSL_TFLAG_INV},
+    /* no_anti_replay */
+    {SSL_OP_NO_ANTI_REPLAY, 0},
 };
 
 static int ssl_conf_cmd_skip_prefix(SSL_CONF_CTX *cctx, const char **pcmd)
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index 6ced147..1387067 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -805,6 +805,9 @@ SSL *SSL_new(SSL_CTX *ctx)
 
     s-&gt;key_update = SSL_KEY_UPDATE_NONE;
 
+    s-&gt;allow_early_data_cb = ctx-&gt;allow_early_data_cb;
+    s-&gt;allow_early_data_cb_data = ctx-&gt;allow_early_data_cb_data;
+
     if (!s-&gt;method-&gt;ssl_new(s))
         goto err;
 
@@ -3381,7 +3384,8 @@ void ssl_update_cache(SSL *s, int mode)
         if ((i &amp; SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0
                 &amp;&amp; (!SSL_IS_TLS13(s)
                     || !s-&gt;server
-                    || s-&gt;max_early_data &gt; 0
+                    || (s-&gt;max_early_data &gt; 0
+                        &amp;&amp; (s-&gt;options &amp; SSL_OP_NO_ANTI_REPLAY) == 0)
                     || s-&gt;session_ctx-&gt;remove_session_cb != NULL
                     || (s-&gt;options &amp; SSL_OP_NO_TICKET) != 0))
             SSL_CTX_add_session(s-&gt;session_ctx, s-&gt;session);
@@ -5482,3 +5486,19 @@ int SSL_CTX_set_session_ticket_cb(SSL_CTX *ctx,
     ctx-&gt;ticket_cb_data = arg;
     return 1;
 }
+
+void SSL_CTX_set_allow_early_data_cb(SSL_CTX *ctx,
+                                     SSL_allow_early_data_cb_fn cb,
+                                     void *arg)
+{
+    ctx-&gt;allow_early_data_cb = cb;
+    ctx-&gt;allow_early_data_cb_data = arg;
+}
+
+void SSL_set_allow_early_data_cb(SSL *s,
+                                 SSL_allow_early_data_cb_fn cb,
+                                 void *arg)
+{
+    s-&gt;allow_early_data_cb = cb;
+    s-&gt;allow_early_data_cb_data = arg;
+}
diff --git a/ssl/ssl_locl.h b/ssl/ssl_locl.h
index a4d1376..6a2edeb 100644
--- a/ssl/ssl_locl.h
+++ b/ssl/ssl_locl.h
@@ -1047,6 +1047,10 @@ struct ssl_ctx_st {
 
     /* The number of TLS1.3 tickets to automatically send */
     size_t num_tickets;
+
+    /* Callback to determine if early_data is acceptable or not */
+    SSL_allow_early_data_cb_fn allow_early_data_cb;
+    void *allow_early_data_cb_data;
 };
 
 struct ssl_st {
@@ -1205,6 +1209,7 @@ struct ssl_st {
 # endif
     SSL_psk_find_session_cb_func psk_find_session_cb;
     SSL_psk_use_session_cb_func psk_use_session_cb;
+
     SSL_CTX *ctx;
     /* Verified chain of peer */
     STACK_OF(X509) *verified_chain;
@@ -1424,6 +1429,10 @@ struct ssl_st {
     size_t sent_tickets;
     /* The next nonce value to use when we send a ticket on this connection */
     uint64_t next_ticket_nonce;
+
+    /* Callback to determine if early_data is acceptable or not */
+    SSL_allow_early_data_cb_fn allow_early_data_cb;
+    void *allow_early_data_cb_data;
 };
 
 /*
diff --git a/ssl/statem/extensions.c b/ssl/statem/extensions.c
index 496039e..5309b12 100644
--- a/ssl/statem/extensions.c
+++ b/ssl/statem/extensions.c
@@ -1622,7 +1622,10 @@ static int final_early_data(SSL *s, unsigned int context, int sent)
             || s-&gt;session-&gt;ext.tick_identity != 0
             || s-&gt;early_data_state != SSL_EARLY_DATA_ACCEPTING
             || !s-&gt;ext.early_data_ok
-            || s-&gt;hello_retry_request != SSL_HRR_NONE) {
+            || s-&gt;hello_retry_request != SSL_HRR_NONE
+            || (s-&gt;ctx-&gt;allow_early_data_cb != NULL
+                &amp;&amp; !s-&gt;ctx-&gt;allow_early_data_cb(s,
+                                         s-&gt;ctx-&gt;allow_early_data_cb_data))) {
         s-&gt;ext.early_data = SSL_EARLY_DATA_REJECTED;
     } else {
         s-&gt;ext.early_data = SSL_EARLY_DATA_ACCEPTED;
diff --git a/ssl/statem/extensions_srvr.c b/ssl/statem/extensions_srvr.c
index f58ed0b..ab38a4f 100644
--- a/ssl/statem/extensions_srvr.c
+++ b/ssl/statem/extensions_srvr.c
@@ -1165,7 +1165,8 @@ int tls_parse_ctos_psk(SSL *s, PACKET *pkt, unsigned int context, X509 *x,
              * is no point in using full stateless tickets.
              */
             if ((s-&gt;options &amp; SSL_OP_NO_TICKET) != 0
-                    || s-&gt;max_early_data &gt; 0)
+                    || (s-&gt;max_early_data &gt; 0
+                        &amp;&amp; (s-&gt;options &amp; SSL_OP_NO_ANTI_REPLAY) == 0))
                 ret = tls_get_stateful_ticket(s, &amp;identity, &amp;sess);
             else
                 ret = tls_decrypt_ticket(s, PACKET_data(&amp;identity),
@@ -1189,6 +1190,7 @@ int tls_parse_ctos_psk(SSL *s, PACKET *pkt, unsigned int context, X509 *x,
 
             /* Check for replay */
             if (s-&gt;max_early_data &gt; 0
+                    &amp;&amp; (s-&gt;options &amp; SSL_OP_NO_ANTI_REPLAY) == 0
                     &amp;&amp; !SSL_CTX_remove_session(s-&gt;session_ctx, sess)) {
                 SSL_SESSION_free(sess);
                 sess = NULL;
diff --git a/ssl/statem/statem_srvr.c b/ssl/statem/statem_srvr.c
index 26cd850..5c59eb8 100644
--- a/ssl/statem/statem_srvr.c
+++ b/ssl/statem/statem_srvr.c
@@ -4086,8 +4086,10 @@ int tls_construct_new_session_ticket(SSL *s, WPACKET *pkt)
      * SSL_OP_NO_TICKET is set - we are caching tickets anyway so there
      * is no point in using full stateless tickets.
      */
-    if (((s-&gt;options &amp; SSL_OP_NO_TICKET) != 0 || s-&gt;max_early_data &gt; 0)
-            &amp;&amp; SSL_IS_TLS13(s)) {
+    if (SSL_IS_TLS13(s)
+            &amp;&amp; ((s-&gt;options &amp; SSL_OP_NO_TICKET) != 0
+                || (s-&gt;max_early_data &gt; 0
+                    &amp;&amp; (s-&gt;options &amp; SSL_OP_NO_ANTI_REPLAY) == 0))) {
         if (!construct_stateful_ticket(s, pkt, age_add_u.age_add, tick_nonce)) {
             /* SSLfatal() already called */
             goto err;
diff --git a/test/sslapitest.c b/test/sslapitest.c
index baf0881..6e08795 100644
--- a/test/sslapitest.c
+++ b/test/sslapitest.c
@@ -1847,11 +1847,14 @@ static unsigned int psk_server_cb(SSL *ssl, const char *identity,
 static int setupearly_data_test(SSL_CTX **cctx, SSL_CTX **sctx, SSL **clientssl,
                                 SSL **serverssl, SSL_SESSION **sess, int idx)
 {
-    if (!TEST_true(create_ssl_ctx_pair(TLS_server_method(), TLS_client_method(),
-                                       TLS1_VERSION, TLS_MAX_VERSION,
-                                       sctx, cctx, cert, privkey))
-        || !TEST_true(SSL_CTX_set_max_early_data(*sctx,
-                                                 SSL3_RT_MAX_PLAIN_LENGTH)))
+    if (*sctx == NULL
+            &amp;&amp; !TEST_true(create_ssl_ctx_pair(TLS_server_method(),
+                                              TLS_client_method(),
+                                              TLS1_VERSION, TLS_MAX_VERSION,
+                                              sctx, cctx, cert, privkey)))
+        return 0;
+
+    if (!TEST_true(SSL_CTX_set_max_early_data(*sctx, SSL3_RT_MAX_PLAIN_LENGTH)))
         return 0;
 
     if (idx == 1) {
@@ -2156,12 +2159,65 @@ static int test_early_data_read_write(int idx)
     return testresult;
 }
 
-static int test_early_data_replay(int idx)
+static int allow_ed_cb_called = 0;
+
+static int allow_early_data_cb(SSL *s, void *arg)
+{
+    int *usecb = (int *)arg;
+
+    allow_ed_cb_called++;
+
+    if (*usecb == 1)
+        return 0;
+
+    return 1;
+}
+
+/*
+ * idx == 0: Standard early_data setup
+ * idx == 1: early_data setup using read_ahead
+ * usecb == 0: Don't use a custom early data callback
+ * usecb == 1: Use a custom early data callback and reject the early data
+ * usecb == 2: Use a custom early data callback and accept the early data
+ * confopt == 0: Configure anti-replay directly
+ * confopt == 1: Configure anti-replay using SSL_CONF
+ */
+static int test_early_data_replay_int(int idx, int usecb, int confopt)
 {
     SSL_CTX *cctx = NULL, *sctx = NULL;
     SSL *clientssl = NULL, *serverssl = NULL;
     int testresult = 0;
     SSL_SESSION *sess = NULL;
+    size_t readbytes, written;
+    unsigned char buf[20];
+
+    allow_ed_cb_called = 0;
+
+    if (!TEST_true(create_ssl_ctx_pair(TLS_server_method(), TLS_client_method(),
+                                       TLS1_VERSION, TLS_MAX_VERSION, &amp;sctx,
+                                       &amp;cctx, cert, privkey)))
+        return 0;
+
+    if (usecb &gt; 0) {
+        if (confopt == 0) {
+            SSL_CTX_set_options(sctx, SSL_OP_NO_ANTI_REPLAY);
+        } else {
+            SSL_CONF_CTX *confctx = SSL_CONF_CTX_new();
+
+            if (!TEST_ptr(confctx))
+                goto end;
+            SSL_CONF_CTX_set_flags(confctx, SSL_CONF_FLAG_FILE
+                                            | SSL_CONF_FLAG_SERVER);
+            SSL_CONF_CTX_set_ssl_ctx(confctx, sctx);
+            if (!TEST_int_eq(SSL_CONF_cmd(confctx, &quot;Options&quot;, &quot;-AntiReplay&quot;),
+                             2)) {
+                SSL_CONF_CTX_free(confctx);
+                goto end;
+            }
+            SSL_CONF_CTX_free(confctx);
+        }
+        SSL_CTX_set_allow_early_data_cb(sctx, allow_early_data_cb, &amp;usecb);
+    }
 
     if (!TEST_true(setupearly_data_test(&amp;cctx, &amp;sctx, &amp;clientssl,
                                         &amp;serverssl, &amp;sess, idx)))
@@ -2183,14 +2239,49 @@ static int test_early_data_replay(int idx)
 
     if (!TEST_true(create_ssl_objects(sctx, cctx, &amp;serverssl,
                                       &amp;clientssl, NULL, NULL))
-            || !TEST_true(SSL_set_session(clientssl, sess))
-            || !TEST_true(create_ssl_connection(serverssl, clientssl,
-                          SSL_ERROR_NONE))
-               /*
-                * This time we should not have resumed the session because we
-                * already used it once.
-                */
-            || !TEST_false(SSL_session_reused(clientssl)))
+            || !TEST_true(SSL_set_session(clientssl, sess)))
+        goto end;
+
+    /* Write and read some early data */
+    if (!TEST_true(SSL_write_early_data(clientssl, MSG1, strlen(MSG1),
+                                        &amp;written))
+            || !TEST_size_t_eq(written, strlen(MSG1)))
+        goto end;
+
+    if (usecb &lt;= 1) {
+        if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
+                                             &amp;readbytes),
+                         SSL_READ_EARLY_DATA_FINISH)
+                   /*
+                    * The ticket was reused, so the we should have rejected the
+                    * early data
+                    */
+                || !TEST_int_eq(SSL_get_early_data_status(serverssl),
+                                SSL_EARLY_DATA_REJECTED))
+            goto end;
+    } else {
+        /* In this case the callback decides to accept the early data */
+        if (!TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
+                                             &amp;readbytes),
+                         SSL_READ_EARLY_DATA_SUCCESS)
+                || !TEST_mem_eq(MSG1, strlen(MSG1), buf, readbytes)
+                   /*
+                    * Server will have sent its flight so client can now send
+                    * end of early data and complete its half of the handshake
+                    */
+                || !TEST_int_gt(SSL_connect(clientssl), 0)
+                || !TEST_int_eq(SSL_read_early_data(serverssl, buf, sizeof(buf),
+                                             &amp;readbytes),
+                                SSL_READ_EARLY_DATA_FINISH)
+                || !TEST_int_eq(SSL_get_early_data_status(serverssl),
+                                SSL_EARLY_DATA_ACCEPTED))
+            goto end;
+    }
+
+    /* Complete the connection */
+    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE))
+            || !TEST_int_eq(SSL_session_reused(clientssl), (usecb &gt; 0) ? 1 : 0)
+            || !TEST_int_eq(allow_ed_cb_called, usecb &gt; 0 ? 1 : 0))
         goto end;
 
     testresult = 1;
@@ -2207,6 +2298,18 @@ static int test_early_data_replay(int idx)
     return testresult;
 }
 
+static int test_early_data_replay(int idx)
+{
+    int ret = 1, usecb, confopt;
+
+    for (usecb = 0; usecb &lt; 3; usecb++) {
+        for (confopt = 0; confopt &lt; 2; confopt++)
+            ret &amp;= test_early_data_replay_int(idx, usecb, confopt);
+    }
+
+    return ret;
+}
+
 /*
  * Helper function to test that a server attempting to read early data can
  * handle a connection from a client where the early data should be skipped.
diff --git a/util/libssl.num b/util/libssl.num
index 3495903..df6a71e 100644
--- a/util/libssl.num
+++ b/util/libssl.num
@@ -490,3 +490,5 @@ SSL_set_num_tickets                     490	1_1_1	EXIST::FUNCTION:
 SSL_CTX_get_num_tickets                 491	1_1_1	EXIST::FUNCTION:
 SSL_get_num_tickets                     492	1_1_1	EXIST::FUNCTION:
 SSL_CTX_set_num_tickets                 493	1_1_1	EXIST::FUNCTION:
+SSL_CTX_set_allow_early_data_cb         494	1_1_1	EXIST::FUNCTION:
+SSL_set_allow_early_data_cb             495	1_1_1	EXIST::FUNCTION:
diff --git a/util/private.num b/util/private.num
index ac536a5..b90e33d 100644
--- a/util/private.num
+++ b/util/private.num
@@ -48,7 +48,9 @@ RAND_DRBG_cleanup_nonce_fn              datatype
 RAND_DRBG_get_entropy_fn                datatype
 RAND_DRBG_get_nonce_fn                  datatype
 RAND_poll_cb                            datatype
+SSL_CTX_allow_early_data_cb_fn          datatype
 SSL_CTX_keylog_cb_func                  datatype
+SSL_allow_early_data_cb_fn              datatype
 SSL_client_hello_cb_fn                  datatype
 SSL_psk_client_cb_func                  datatype
 SSL_psk_find_session_cb_func            datatype
</PRE>










<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019710.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="019715.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19712">[ date ]</a>
              <a href="thread.html#19712">[ thread ]</a>
              <a href="subject.html#19712">[ subject ]</a>
              <a href="author.html#19712">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
