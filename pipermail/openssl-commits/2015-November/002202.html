<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2015-November/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1448392956.069265.14930.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002195.html">
   <LINK REL="Next"  HREF="002204.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Dr. Stephen Henson</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1448392956.069265.14930.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">steve at openssl.org
       </A><BR>
    <I>Tue Nov 24 19:22:36 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002195.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="002204.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2202">[ date ]</a>
              <a href="thread.html#2202">[ thread ]</a>
              <a href="subject.html#2202">[ subject ]</a>
              <a href="author.html#2202">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  00f5263b78910da233ed0258bf8ea8fd1758abbc (commit)
       via  9cc6fa1ce83ce7857660ee11c3285651ceff0f43 (commit)
       via  28f4580c1e510ccf4278a20975c9bc3306f758d6 (commit)
       via  a0f63828e3e542ba71b166b3d0cac05833591065 (commit)
       via  396d5fd091f68729f0a038a283fe3cca3eb670dd (commit)
       via  93972b8c72d5c074278654b3380a8215d741ea1f (commit)
       via  e3e11e99cebd2f0cbf0b46cc4200a094a9c4b4eb (commit)
       via  192e4bbbf93d258c94075ad329404212f62337f3 (commit)
       via  d18d31a16f91dc5042344e207390322170458025 (commit)
       via  2f142ada2c1f04c96c0c3db3ee3b6425934ad83b (commit)
      from  63eb10a07ee29a312e50a227f5b3a290b1ad22b4 (commit)


- Log -----------------------------------------------------------------
commit 00f5263b78910da233ed0258bf8ea8fd1758abbc
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Tue Nov 24 14:20:58 2015 +0000

    Add ctrl for SHA1 and SSLv3
    
    Add SSLv3 ctrl to EVP_sha1() this is only needed if SSLv3 client
    authentication is used with DSA/ECDSA.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

commit 9cc6fa1ce83ce7857660ee11c3285651ceff0f43
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Tue Nov 24 02:29:57 2015 +0000

    make update
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

commit 28f4580c1e510ccf4278a20975c9bc3306f758d6
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Tue Nov 24 00:47:11 2015 +0000

    Use EVP_md5_sha1() to process client verify
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

commit a0f63828e3e542ba71b166b3d0cac05833591065
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Tue Nov 24 00:08:35 2015 +0000

    Use EVP_md5_sha1() to generate client verify
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

commit 396d5fd091f68729f0a038a283fe3cca3eb670dd
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Mon Nov 23 16:07:46 2015 +0000

    Add EVP_MD_CTX_ctrl function.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

commit 93972b8c72d5c074278654b3380a8215d741ea1f
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Mon Nov 23 16:05:20 2015 +0000

    Add ssl3 ctrl to EVP_md5_sha1().
    
    Add a ctrl to EVP_md5_sha1() to handle the additional operations needed
    to handle SSL v3 client authentication and finished message.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

commit e3e11e99cebd2f0cbf0b46cc4200a094a9c4b4eb
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Sat Nov 21 04:03:48 2015 +0000

    Remove RSA exception when generating server key exchange.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

commit 192e4bbbf93d258c94075ad329404212f62337f3
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Sat Nov 21 03:56:52 2015 +0000

    Remove RSA exception when processing server key exchange.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

commit d18d31a16f91dc5042344e207390322170458025
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Sat Aug 29 22:11:05 2015 +0100

    Use MD5+SHA1 for default digest if appropriate.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

commit 2f142ada2c1f04c96c0c3db3ee3b6425934ad83b
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Thu Nov 20 13:28:48 2014 +0000

    Add MD5+SHA1
    
    Add digest combining MD5 and SHA1. This is used by RSA signatures for
    TLS 1.1 and earlier.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 crypto/evp/Makefile      |  19 +++-
 crypto/evp/c_alld.c      |   1 +
 crypto/evp/digest.c      |  11 ++
 crypto/evp/m_md5_sha1.c  | 184 +++++++++++++++++++++++++++++++++
 crypto/evp/m_sha1.c      |  55 ++++++++++
 include/openssl/evp.h    |   4 +
 ssl/ssl_locl.h           |   1 +
 ssl/statem/statem_clnt.c | 263 ++++++++++-------------------------------------
 ssl/statem/statem_srvr.c | 211 ++++++++-----------------------------
 ssl/t1_lib.c             |   9 +-
 util/libeay.num          |   2 +
 11 files changed, 382 insertions(+), 378 deletions(-)
 create mode 100644 crypto/evp/m_md5_sha1.c

diff --git a/crypto/evp/Makefile b/crypto/evp/Makefile
index 1a65b46..c672296 100644
--- a/crypto/evp/Makefile
+++ b/crypto/evp/Makefile
@@ -20,7 +20,7 @@ LIBSRC= encode.c digest.c evp_enc.c evp_key.c evp_acnf.c evp_cnf.c \
 	e_rc4.c e_aes.c names.c e_seed.c \
 	e_xcbc_d.c e_rc2.c e_cast.c e_rc5.c \
 	m_null.c m_md2.c m_md4.c m_md5.c m_sha1.c m_wp.c \
-	m_dss1.c m_mdc2.c m_ripemd.c m_ecdsa.c\
+	m_md5_sha1.c m_dss1.c m_mdc2.c m_ripemd.c m_ecdsa.c\
 	p_open.c p_seal.c p_sign.c p_verify.c p_lib.c p_enc.c p_dec.c \
 	bio_md.c bio_b64.c bio_enc.c evp_err.c e_null.c \
 	c_all.c c_allc.c c_alld.c evp_lib.c bio_ok.c \
@@ -33,7 +33,7 @@ LIBOBJ=	encode.o digest.o evp_enc.o evp_key.o evp_acnf.o evp_cnf.o \
 	e_rc4.o e_aes.o names.o e_seed.o \
 	e_xcbc_d.o e_rc2.o e_cast.o e_rc5.o \
 	m_null.o m_md2.o m_md4.o m_md5.o m_sha1.o m_wp.o \
-	m_dss1.o m_mdc2.o m_ripemd.o m_ecdsa.o\
+	m_md5_sha1.o m_dss1.o m_mdc2.o m_ripemd.o m_ecdsa.o\
 	p_open.o p_seal.o p_sign.o p_verify.o p_lib.o p_enc.o p_dec.o \
 	bio_md.o bio_b64.o bio_enc.o evp_err.o e_null.o \
 	c_all.o c_allc.o c_alld.o evp_lib.o bio_ok.o \
@@ -516,6 +516,21 @@ m_md5.o: ../../include/openssl/sha.h ../../include/openssl/stack.h
 m_md5.o: ../../include/openssl/symhacks.h ../../include/openssl/x509.h
 m_md5.o: ../../include/openssl/x509_vfy.h ../include/internal/cryptlib.h
 m_md5.o: m_md5.c
+m_md5_sha1.o: ../../e_os.h ../../include/openssl/asn1.h
+m_md5_sha1.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
+m_md5_sha1.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+m_md5_sha1.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
+m_md5_sha1.o: ../../include/openssl/ecdsa.h ../../include/openssl/err.h
+m_md5_sha1.o: ../../include/openssl/evp.h ../../include/openssl/lhash.h
+m_md5_sha1.o: ../../include/openssl/md5.h ../../include/openssl/obj_mac.h
+m_md5_sha1.o: ../../include/openssl/objects.h
+m_md5_sha1.o: ../../include/openssl/opensslconf.h
+m_md5_sha1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+m_md5_sha1.o: ../../include/openssl/pkcs7.h ../../include/openssl/rsa.h
+m_md5_sha1.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
+m_md5_sha1.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
+m_md5_sha1.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
+m_md5_sha1.o: ../include/internal/cryptlib.h m_md5_sha1.c
 m_mdc2.o: ../../e_os.h ../../include/openssl/asn1.h ../../include/openssl/bio.h
 m_mdc2.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
 m_mdc2.o: ../../include/openssl/des.h ../../include/openssl/e_os2.h
diff --git a/crypto/evp/c_alld.c b/crypto/evp/c_alld.c
index e89173a..0c68bad 100644
--- a/crypto/evp/c_alld.c
+++ b/crypto/evp/c_alld.c
@@ -70,6 +70,7 @@ void OpenSSL_add_all_digests(void)
 #ifndef OPENSSL_NO_MD5
     EVP_add_digest(EVP_md5());
     EVP_add_digest_alias(SN_md5, &quot;ssl3-md5&quot;);
+    EVP_add_digest(EVP_md5_sha1());
 #endif
     EVP_add_digest(EVP_sha1());
     EVP_add_digest_alias(SN_sha1, &quot;ssl3-sha1&quot;);
diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
index 607f0a1..32a87f6 100644
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -364,3 +364,14 @@ int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx)
 
     return 1;
 }
+
+int EVP_MD_CTX_ctrl(EVP_MD_CTX *ctx, int cmd, int p1, void *p2)
+{
+    if (ctx-&gt;digest &amp;&amp; ctx-&gt;digest-&gt;md_ctrl) {
+        int ret = ctx-&gt;digest-&gt;md_ctrl(ctx, cmd, p1, p2);
+        if (ret &lt;= 0)
+            return 0;
+        return 1;
+    }
+    return 0;
+}
diff --git a/crypto/evp/m_md5_sha1.c b/crypto/evp/m_md5_sha1.c
new file mode 100644
index 0000000..2504e95
--- /dev/null
+++ b/crypto/evp/m_md5_sha1.c
@@ -0,0 +1,184 @@
+/* crypto/evp/m_md5_sha1.c */
+/*
+ * Written by Dr Stephen N Henson (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL
+ * project.
+ */
+/* ====================================================================
+ * Copyright (c) 2015 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
+ *
+ * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    <A HREF="../../../mailman/listinfo/openssl-commits.html">licensing at OpenSSL.org.</A>
+ *
+ * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+ *    nor may &quot;OpenSSL&quot; appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+#if !defined(OPENSSL_NO_MD5) &amp;&amp; !defined(OPENSSL_NO_SHA1)
+
+# include &lt;openssl/evp.h&gt;
+# include &lt;openssl/objects.h&gt;
+# include &lt;openssl/x509.h&gt;
+# include &lt;openssl/md5.h&gt;
+# include &lt;openssl/sha.h&gt;
+# include &quot;internal/cryptlib.h&quot;
+# ifndef OPENSSL_NO_RSA
+#  include &lt;openssl/rsa.h&gt;
+# endif
+
+struct md5_sha1_ctx {
+    MD5_CTX md5;
+    SHA_CTX sha1;
+};
+
+static int init(EVP_MD_CTX *ctx)
+{
+    struct md5_sha1_ctx *mctx = ctx-&gt;md_data;
+    if (!MD5_Init(&amp;mctx-&gt;md5))
+        return 0;
+    return SHA1_Init(&amp;mctx-&gt;sha1);
+}
+
+static int update(EVP_MD_CTX *ctx, const void *data, size_t count)
+{
+    struct md5_sha1_ctx *mctx = ctx-&gt;md_data;
+    if (!MD5_Update(&amp;mctx-&gt;md5, data, count))
+        return 0;
+    return SHA1_Update(&amp;mctx-&gt;sha1, data, count);
+}
+
+static int final(EVP_MD_CTX *ctx, unsigned char *md)
+{
+    struct md5_sha1_ctx *mctx = ctx-&gt;md_data;
+    if (!MD5_Final(md, &amp;mctx-&gt;md5))
+        return 0;
+    return SHA1_Final(md + MD5_DIGEST_LENGTH, &amp;mctx-&gt;sha1);
+}
+
+static int ctrl(EVP_MD_CTX *ctx, int cmd, int mslen, void *ms)
+{
+    unsigned char padtmp[48];
+    unsigned char md5tmp[MD5_DIGEST_LENGTH];
+    unsigned char sha1tmp[SHA_DIGEST_LENGTH];
+    struct md5_sha1_ctx *mctx = ctx-&gt;md_data;
+
+    if (cmd != EVP_CTRL_SSL3_MASTER_SECRET)
+        return 0;
+
+    /* SSLv3 client auth handling: see RFC-6101 5.6.8 */
+    if (mslen != 48)
+        return 0;
+
+    /* At this point hash contains all handshake messages, update
+     * with master secret and pad_1.
+     */
+
+    if (update(ctx, ms, mslen) &lt;= 0)
+        return 0;
+
+    /* Set padtmp to pad_1 value */
+    memset(padtmp, 0x36, sizeof(padtmp));
+
+    if (!MD5_Update(&amp;mctx-&gt;md5, padtmp, sizeof(padtmp)))
+        return 0;
+
+    if (!MD5_Final(md5tmp, &amp;mctx-&gt;md5))
+        return 0;
+
+    if (!SHA1_Update(&amp;mctx-&gt;sha1, padtmp, 40))
+        return 0;
+
+    if (!SHA1_Final(sha1tmp, &amp;mctx-&gt;sha1))
+        return 0;
+
+    /* Reinitialise context */
+
+    if (!init(ctx))
+        return 0;
+
+    if (update(ctx, ms, mslen) &lt;= 0)
+        return 0;
+
+    /* Set padtmp to pad_2 value */
+    memset(padtmp, 0x5c, sizeof(padtmp));
+
+    if (!MD5_Update(&amp;mctx-&gt;md5, padtmp, sizeof(padtmp)))
+        return 0;
+
+    if (!MD5_Update(&amp;mctx-&gt;md5, md5tmp, sizeof(md5tmp)))
+        return 0;
+
+    if (!SHA1_Update(&amp;mctx-&gt;sha1, padtmp, 40))
+        return 0;
+
+    if (!SHA1_Update(&amp;mctx-&gt;sha1, sha1tmp, sizeof(sha1tmp)))
+        return 0;
+
+    /* Now when ctx is finalised it will return the SSL v3 hash value */
+
+    OPENSSL_cleanse(md5tmp, sizeof(md5tmp));
+    OPENSSL_cleanse(sha1tmp, sizeof(sha1tmp));
+
+    return 1;
+
+}
+
+static const EVP_MD md5_sha1_md = {
+    NID_md5_sha1,
+    NID_md5_sha1,
+    MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH,
+    0,
+    init,
+    update,
+    final,
+    NULL,
+    NULL,
+    EVP_PKEY_RSA_method,
+    MD5_CBLOCK,
+    sizeof(EVP_MD *) + sizeof(struct md5_sha1_ctx),
+    ctrl
+};
+
+const EVP_MD *EVP_md5_sha1(void)
+{
+    return &amp;md5_sha1_md;
+}
+#endif
diff --git a/crypto/evp/m_sha1.c b/crypto/evp/m_sha1.c
index 7deed91..42e986d 100644
--- a/crypto/evp/m_sha1.c
+++ b/crypto/evp/m_sha1.c
@@ -81,6 +81,60 @@ static int final(EVP_MD_CTX *ctx, unsigned char *md)
     return SHA1_Final(md, ctx-&gt;md_data);
 }
 
+static int ctrl(EVP_MD_CTX *ctx, int cmd, int mslen, void *ms)
+{
+    unsigned char padtmp[40];
+    unsigned char sha1tmp[SHA_DIGEST_LENGTH];
+
+    SHA_CTX *sha1 = ctx-&gt;md_data;
+
+    if (cmd != EVP_CTRL_SSL3_MASTER_SECRET)
+        return 0;
+
+    /* SSLv3 client auth handling: see RFC-6101 5.6.8 */
+    if (mslen != 48)
+        return 0;
+
+    /* At this point hash contains all handshake messages, update
+     * with master secret and pad_1.
+     */
+
+    if (SHA1_Update(sha1, ms, mslen) &lt;= 0)
+        return 0;
+
+    /* Set padtmp to pad_1 value */
+    memset(padtmp, 0x36, sizeof(padtmp));
+
+    if (!SHA1_Update(sha1, padtmp, sizeof(padtmp)))
+        return 0;
+
+    if (!SHA1_Final(sha1tmp, sha1))
+        return 0;
+
+    /* Reinitialise context */
+
+    if (!SHA1_Init(sha1))
+        return 0;
+
+    if (SHA1_Update(sha1, ms, mslen) &lt;= 0)
+        return 0;
+
+    /* Set padtmp to pad_2 value */
+    memset(padtmp, 0x5c, sizeof(padtmp));
+
+    if (!SHA1_Update(sha1, padtmp, sizeof(padtmp)))
+        return 0;
+
+    if (!SHA1_Update(sha1, sha1tmp, sizeof(sha1tmp)))
+        return 0;
+
+    /* Now when ctx is finalised it will return the SSL v3 hash value */
+    OPENSSL_cleanse(sha1tmp, sizeof(sha1tmp));
+
+    return 1;
+
+}
+
 static const EVP_MD sha1_md = {
     NID_sha1,
     NID_sha1WithRSAEncryption,
@@ -94,6 +148,7 @@ static const EVP_MD sha1_md = {
     EVP_PKEY_NULL_method,
     SHA_CBLOCK,
     sizeof(EVP_MD *) + sizeof(SHA_CTX),
+    ctrl
 };
 
 const EVP_MD *EVP_sha1(void)
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 15796c0..c9659b3 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -427,6 +427,8 @@ struct evp_cipher_st {
 # define         EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT      0x1b
 # define         EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE  0x1c
 
+# define         EVP_CTRL_SSL3_MASTER_SECRET             0x1d
+
 /* RFC 5246 defines additional data to be 13 bytes in length */
 # define         EVP_AEAD_TLS1_AAD_LEN           13
 
@@ -624,6 +626,7 @@ void BIO_set_md(BIO *, const EVP_MD *md);
 
 void EVP_MD_CTX_init(EVP_MD_CTX *ctx);
 int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);
+int EVP_MD_CTX_ctrl(EVP_MD_CTX *ctx, int cmd, int p1, void *p2);
 EVP_MD_CTX *EVP_MD_CTX_create(void);
 void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);
 /*__owur*/ int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in);
@@ -766,6 +769,7 @@ const EVP_MD *EVP_md4(void);
 # endif
 # ifndef OPENSSL_NO_MD5
 const EVP_MD *EVP_md5(void);
+const EVP_MD *EVP_md5_sha1(void);
 # endif
 const EVP_MD *EVP_sha1(void);
 const EVP_MD *EVP_dss1(void);
diff --git a/ssl/ssl_locl.h b/ssl/ssl_locl.h
index 95a9c62..3cec5c3 100644
--- a/ssl/ssl_locl.h
+++ b/ssl/ssl_locl.h
@@ -2069,6 +2069,7 @@ __owur unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,
 __owur unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,
                                           unsigned char *limit, int *al);
 __owur int ssl_parse_clienthello_tlsext(SSL *s, PACKET *pkt);
+void ssl_set_default_md(SSL *s);
 __owur int tls1_set_server_sigalgs(SSL *s);
 __owur int ssl_check_clienthello_tlsext_late(SSL *s);
 __owur int ssl_parse_serverhello_tlsext(SSL *s, PACKET *pkt);
diff --git a/ssl/statem/statem_clnt.c b/ssl/statem/statem_clnt.c
index 9b1846b..c6bc86f 100644
--- a/ssl/statem/statem_clnt.c
+++ b/ssl/statem/statem_clnt.c
@@ -1361,15 +1361,6 @@ MSG_PROCESS_RETURN tls_process_server_hello(SSL *s, PACKET *pkt)
         goto f_err;
     }
     s-&gt;s3-&gt;tmp.new_cipher = c;
-    /*
-     * Don't digest cached records if no sigalgs: we may need them for client
-     * authentication.
-     */
-    if (!(SSL_USE_SIGALGS(s)
-            || (s-&gt;s3-&gt;tmp.new_cipher-&gt;algorithm_auth
-                &amp; (SSL_aGOST12|SSL_aGOST01)))
-            &amp;&amp; !ssl3_digest_cached_records(s, 0))
-        goto f_err;
     /* lets get the compression algorithm */
     /* COMPRESSION */
     if (!PACKET_get_1(pkt, &amp;compression)) {
@@ -1593,11 +1584,8 @@ MSG_PROCESS_RETURN tls_process_server_certificate(SSL *s, PACKET *pkt)
 
 MSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)
 {
-#ifndef OPENSSL_NO_RSA
-    unsigned char *q, md_buf[EVP_MAX_MD_SIZE * 2];
-#endif
     EVP_MD_CTX md_ctx;
-    int al, j, verify_ret;
+    int al, j;
     long alg_k, alg_a;
     EVP_PKEY *pkey = NULL;
     const EVP_MD *md = NULL;
@@ -1935,6 +1923,8 @@ MSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)
 #ifdef SSL_DEBUG
             fprintf(stderr, &quot;USING TLSv1.2 HASH %s\n&quot;, EVP_MD_name(md));
 #endif
+        } else if (pkey-&gt;type == EVP_PKEY_RSA) {
+            md = EVP_md5_sha1();
         } else {
             md = EVP_sha1();
         }
@@ -1958,68 +1948,23 @@ MSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)
             SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_WRONG_SIGNATURE_LENGTH);
             goto f_err;
         }
-#ifndef OPENSSL_NO_RSA
-        if (pkey-&gt;type == EVP_PKEY_RSA &amp;&amp; !SSL_USE_SIGALGS(s)) {
-            int num;
-            unsigned int size;
-
-            j = 0;
-            q = md_buf;
-            for (num = 2; num &gt; 0; num--) {
-                EVP_MD_CTX_set_flags(&amp;md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
-                if (EVP_DigestInit_ex(&amp;md_ctx,
-                                      (num == 2) ? s-&gt;ctx-&gt;md5 : s-&gt;ctx-&gt;sha1,
-                                      NULL) &lt;= 0
-                        || EVP_DigestUpdate(&amp;md_ctx, &amp;(s-&gt;s3-&gt;client_random[0]),
-                                            SSL3_RANDOM_SIZE) &lt;= 0
-                        || EVP_DigestUpdate(&amp;md_ctx, &amp;(s-&gt;s3-&gt;server_random[0]),
-                                            SSL3_RANDOM_SIZE) &lt;= 0
-                        || EVP_DigestUpdate(&amp;md_ctx, PACKET_data(&amp;params),
-                                            PACKET_remaining(&amp;params)) &lt;= 0
-                        || EVP_DigestFinal_ex(&amp;md_ctx, q, &amp;size) &lt;= 0) {
-                    SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE,
-                           ERR_R_INTERNAL_ERROR);
-                    al = SSL_AD_INTERNAL_ERROR;
-                    goto f_err;
-                }
-                q += size;
-                j += size;
-            }
-            verify_ret =
-                RSA_verify(NID_md5_sha1, md_buf, j, PACKET_data(&amp;signature),
-                           PACKET_remaining(&amp;signature), pkey-&gt;pkey.rsa);
-            if (verify_ret &lt; 0) {
-                al = SSL_AD_DECRYPT_ERROR;
-                SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_BAD_RSA_DECRYPT);
-                goto f_err;
-            }
-            if (verify_ret == 0) {
-                /* bad signature */
-                al = SSL_AD_DECRYPT_ERROR;
-                SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);
-                goto f_err;
-            }
-        } else
-#endif
-        {
-            if (EVP_VerifyInit_ex(&amp;md_ctx, md, NULL) &lt;= 0
-                    || EVP_VerifyUpdate(&amp;md_ctx, &amp;(s-&gt;s3-&gt;client_random[0]),
-                                        SSL3_RANDOM_SIZE) &lt;= 0
-                    || EVP_VerifyUpdate(&amp;md_ctx, &amp;(s-&gt;s3-&gt;server_random[0]),
-                                        SSL3_RANDOM_SIZE) &lt;= 0
-                    || EVP_VerifyUpdate(&amp;md_ctx, PACKET_data(&amp;params),
-                                        PACKET_remaining(&amp;params)) &lt;= 0) {
-                al = SSL_AD_INTERNAL_ERROR;
-                SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_EVP_LIB);
-                goto f_err;
-            }
-            if (EVP_VerifyFinal(&amp;md_ctx, PACKET_data(&amp;signature),
-                                PACKET_remaining(&amp;signature), pkey) &lt;= 0) {
-                /* bad signature */
-                al = SSL_AD_DECRYPT_ERROR;
-                SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);
-                goto f_err;
-            }
+        if (EVP_VerifyInit_ex(&amp;md_ctx, md, NULL) &lt;= 0
+                || EVP_VerifyUpdate(&amp;md_ctx, &amp;(s-&gt;s3-&gt;client_random[0]),
+                                    SSL3_RANDOM_SIZE) &lt;= 0
+                || EVP_VerifyUpdate(&amp;md_ctx, &amp;(s-&gt;s3-&gt;server_random[0]),
+                                    SSL3_RANDOM_SIZE) &lt;= 0
+                || EVP_VerifyUpdate(&amp;md_ctx, PACKET_data(&amp;params),
+                                    PACKET_remaining(&amp;params)) &lt;= 0) {
+            al = SSL_AD_INTERNAL_ERROR;
+            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, ERR_R_EVP_LIB);
+            goto f_err;
+        }
+        if (EVP_VerifyFinal(&amp;md_ctx, PACKET_data(&amp;signature),
+                            PACKET_remaining(&amp;signature), pkey) &lt;= 0) {
+            /* bad signature */
+            al = SSL_AD_DECRYPT_ERROR;
+            SSLerr(SSL_F_TLS_PROCESS_KEY_EXCHANGE, SSL_R_BAD_SIGNATURE);
+            goto f_err;
         }
     } else {
         /* aNULL, aSRP or PSK do not need public keys */
@@ -2121,6 +2066,8 @@ MSG_PROCESS_RETURN tls_process_certificate_request(SSL *s, PACKET *pkt)
             SSLerr(SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST, ERR_R_MALLOC_FAILURE);
             goto err;
         }
+    } else {
+        ssl_set_default_md(s);
     }
 
     /* get the CA RDNs */
@@ -3013,167 +2960,71 @@ int tls_client_key_exchange_post_work(SSL *s)
 int tls_construct_client_verify(SSL *s)
 {
     unsigned char *p;
-    unsigned char data[EVP_MAX_MD_SIZE]; /* GOST R 34.11-2012-256*/
     EVP_PKEY *pkey;
-    EVP_PKEY_CTX *pctx = NULL;
+    const EVP_MD *md = s-&gt;s3-&gt;tmp.md[s-&gt;cert-&gt;key - s-&gt;cert-&gt;pkeys];
     EVP_MD_CTX mctx;
     unsigned u = 0;
     unsigned long n;
-    int j;
+    long hdatalen = 0;
+    void *hdata;
 
     EVP_MD_CTX_init(&amp;mctx);
 
     p = ssl_handshake_start(s);
     pkey = s-&gt;cert-&gt;key-&gt;privatekey;
-    /* Create context from key and test if sha1 is allowed as digest */
-    pctx = EVP_PKEY_CTX_new(pkey, NULL);
-    if (pctx == NULL) {
-        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_MALLOC_FAILURE);
-        goto err;
-    }
-    if (EVP_PKEY_sign_init(pctx) &lt;= 0) {
+
+    hdatalen = BIO_get_mem_data(s-&gt;s3-&gt;handshake_buffer, &amp;hdata);
+    if (hdatalen &lt;= 0) {
         SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
         goto err;
     }
-    if (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1()) &gt; 0) {
-        if (!SSL_USE_SIGALGS(s))
-            s-&gt;method-&gt;ssl3_enc-&gt;cert_verify_mac(s,
-                                                 NID_sha1,
-                                                 &amp;(data
-                                                   [MD5_DIGEST_LENGTH]));
-    } else {
-        ERR_clear_error();
-    }
-
-    /*
-     * For TLS v1.2 send signature algorithm and signature using agreed
-     * digest and cached handshake records.
-     */
-    if (SSL_USE_SIGALGS(s) || pkey-&gt;type == NID_id_GostR3410_2001
-                || pkey-&gt;type == NID_id_GostR3410_2012_256
-                || pkey-&gt;type == NID_id_GostR3410_2012_512) {
-        long hdatalen = 0;
-        void *hdata;
-        const EVP_MD *md = s-&gt;s3-&gt;tmp.md[s-&gt;cert-&gt;key - s-&gt;cert-&gt;pkeys];
-        hdatalen = BIO_get_mem_data(s-&gt;s3-&gt;handshake_buffer, &amp;hdata);
-        if (!SSL_USE_SIGALGS(s)) {
-                int dgst_nid;
-                if (EVP_PKEY_get_default_digest_nid(pkey, &amp;dgst_nid) &lt;= 0
-                                || (md = EVP_get_digestbynid(dgst_nid)) == NULL) {
-                        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
-                        goto err;
-                }
-        }
-        if (hdatalen &lt;= 0 || !tls12_get_sigandhash(p, pkey, md)) {
+    if (SSL_USE_SIGALGS(s)) {
+        if (!tls12_get_sigandhash(p, pkey, md)) {
             SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
             goto err;
         }
-        if (SSL_USE_SIGALGS(s) ) {
-            p += 2;
-        }
+        p += 2;
+    }
 #ifdef SSL_DEBUG
-        fprintf(stderr, &quot;Using TLS 1.2 with client alg %s\n&quot;,
-                EVP_MD_name(md));
-#endif
-        if (!EVP_SignInit_ex(&amp;mctx, md, NULL)
-            || !EVP_SignUpdate(&amp;mctx, hdata, hdatalen)
-            || !EVP_SignFinal(&amp;mctx, p + 2, &amp;u, pkey)) {
-            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_EVP_LIB);
-            goto err;
-        }
-        if (pkey-&gt;type == NID_id_GostR3410_2001
-                || pkey-&gt;type == NID_id_GostR3410_2012_256
-                || pkey-&gt;type == NID_id_GostR3410_2012_512) {
-            unsigned int i, k;
-            for (i = u - 1, k = 0; k &lt; u/2; k++, i--) {
-                char c = p[2 + k];
-                p[2 + k] = p[2 + i];
-                p[2 + i] = c;
-            }
-        }
-        s2n(u, p);
-        n = u + 2;
-        if (SSL_USE_SIGALGS(s))
-            n += 2;
-        /* Digest cached records and discard handshake buffer */
-        if (!ssl3_digest_cached_records(s, 0))
-            goto err;
-    } else
-#ifndef OPENSSL_NO_RSA
-    if (pkey-&gt;type == EVP_PKEY_RSA) {
-        s-&gt;method-&gt;ssl3_enc-&gt;cert_verify_mac(s, NID_md5, &amp;(data[0]));
-        if (RSA_sign(NID_md5_sha1, data,
-                     MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH,
-                     &amp;(p[2]), &amp;u, pkey-&gt;pkey.rsa) &lt;= 0) {
-            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_RSA_LIB);
-            goto err;
-        }
-        s2n(u, p);
-        n = u + 2;
-    } else
-#endif
-#ifndef OPENSSL_NO_DSA
-    if (pkey-&gt;type == EVP_PKEY_DSA) {
-        if (!DSA_sign(pkey-&gt;save_type,
-                      &amp;(data[MD5_DIGEST_LENGTH]),
-                      SHA_DIGEST_LENGTH, &amp;(p[2]),
-                      (unsigned int *)&amp;j, pkey-&gt;pkey.dsa)) {
-            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_DSA_LIB);
-            goto err;
-        }
-        s2n(j, p);
-        n = j + 2;
-    } else
-#endif
-#ifndef OPENSSL_NO_EC
-    if (pkey-&gt;type == EVP_PKEY_EC) {
-        if (!ECDSA_sign(pkey-&gt;save_type,
-                        &amp;(data[MD5_DIGEST_LENGTH]),
-                        SHA_DIGEST_LENGTH, &amp;(p[2]),
-                        (unsigned int *)&amp;j, pkey-&gt;pkey.ec)) {
-            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_ECDSA_LIB);
-            goto err;
-        }
-        s2n(j, p);
-        n = j + 2;
-    } else
-#endif
+    fprintf(stderr, &quot;Using client alg %s\n&quot;, EVP_MD_name(md));
+#endif
+    if (!EVP_SignInit_ex(&amp;mctx, md, NULL)
+        || !EVP_SignUpdate(&amp;mctx, hdata, hdatalen)
+        || (s-&gt;version == SSL3_VERSION
+            &amp;&amp; !EVP_MD_CTX_ctrl(&amp;mctx, EVP_CTRL_SSL3_MASTER_SECRET,
+                                s-&gt;session-&gt;master_key_length,
+                                s-&gt;session-&gt;master_key))
+        || !EVP_SignFinal(&amp;mctx, p + 2, &amp;u, pkey)) {
+        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_EVP_LIB);
+        goto err;
+    }
     if (pkey-&gt;type == NID_id_GostR3410_2001
             || pkey-&gt;type == NID_id_GostR3410_2012_256
             || pkey-&gt;type == NID_id_GostR3410_2012_512) {
-        unsigned char signbuf[128];
-        int i;
-        size_t sigsize =
-            (pkey-&gt;type == NID_id_GostR3410_2012_512) ? 128 : 64;
-        int dgst_nid = NID_undef;
-
-        EVP_PKEY_get_default_digest_nid(pkey, &amp;dgst_nid);
-        s-&gt;method-&gt;ssl3_enc-&gt;cert_verify_mac(s, dgst_nid, data);
-        if (EVP_PKEY_sign(pctx, signbuf, &amp;sigsize, data,
-                          EVP_MD_size(EVP_get_digestbynid(dgst_nid))) &lt;= 0) {
-            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
-            goto err;
+        unsigned int i, k;
+        for (i = u - 1, k = 0; k &lt; u/2; k++, i--) {
+            char c = p[2 + k];
+            p[2 + k] = p[2 + i];
+            p[2 + i] = c;
         }
-        for (i = sigsize - 1, j = 0; i &gt;= 0; j++, i--) {
-            p[2 + j] = signbuf[i];
-        }
-        s2n(j, p);
-        n = j + 2;
-    } else {
-        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
-        goto err;
     }
+
+    s2n(u, p);
+    n = u + 2;
+    if (SSL_USE_SIGALGS(s))
+        n += 2;
+    /* Digest cached records and discard handshake buffer */
+    if (!ssl3_digest_cached_records(s, 0))
+        goto err;
     if (!ssl_set_handshake_header(s, SSL3_MT_CERTIFICATE_VERIFY, n)) {
         SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR);
         goto err;
     }
 
     EVP_MD_CTX_cleanup(&amp;mctx);
-    EVP_PKEY_CTX_free(pctx);
     return 1;
  err:
     EVP_MD_CTX_cleanup(&amp;mctx);
-    EVP_PKEY_CTX_free(pctx);
     return 0;
 }
 
diff --git a/ssl/statem/statem_srvr.c b/ssl/statem/statem_srvr.c
index ab9b163..d114621 100644
--- a/ssl/statem/statem_srvr.c
+++ b/ssl/statem/statem_srvr.c
@@ -1550,8 +1550,7 @@ WORK_STATE tls_post_process_client_hello(SSL *s, WORK_STATE wst)
             s-&gt;s3-&gt;tmp.new_cipher = s-&gt;session-&gt;cipher;
         }
 
-        if (!(SSL_USE_SIGALGS(s) || (s-&gt;s3-&gt;tmp.new_cipher-&gt;algorithm_auth &amp; (SSL_aGOST12|SSL_aGOST01)) )
-                || !(s-&gt;verify_mode &amp; SSL_VERIFY_PEER)) {
+        if (!(s-&gt;verify_mode &amp; SSL_VERIFY_PEER)) {
             if (!ssl3_digest_cached_records(s, 0)) {
                 al = SSL_AD_INTERNAL_ERROR;
                 goto f_err;
@@ -1725,11 +1724,7 @@ int tls_construct_server_done(SSL *s)
 int tls_construct_server_key_exchange(SSL *s)
 {
 #ifndef OPENSSL_NO_RSA
-    unsigned char *q;
-    int j, num;
     RSA *rsa;
-    unsigned char md_buf[MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH];
-    unsigned int u;
 #endif
 #ifndef OPENSSL_NO_DH
     DH *dh = NULL, *dhp;
@@ -2103,39 +2098,6 @@ int tls_construct_server_key_exchange(SSL *s)
          * n is the length of the params, they start at &amp;(d[4]) and p
          * points to the space at the end.
          */
-#ifndef OPENSSL_NO_RSA
-        if (pkey-&gt;type == EVP_PKEY_RSA &amp;&amp; !SSL_USE_SIGALGS(s)) {
-            q = md_buf;
-            j = 0;
-            for (num = 2; num &gt; 0; num--) {
-                EVP_MD_CTX_set_flags(&amp;md_ctx,
-                                     EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);
-                if (EVP_DigestInit_ex(&amp;md_ctx, (num == 2)
-                                      ? s-&gt;ctx-&gt;md5 : s-&gt;ctx-&gt;sha1, NULL) &lt;= 0
-                        || EVP_DigestUpdate(&amp;md_ctx, &amp;(s-&gt;s3-&gt;client_random[0]),
-                                            SSL3_RANDOM_SIZE) &lt;= 0
-                        || EVP_DigestUpdate(&amp;md_ctx, &amp;(s-&gt;s3-&gt;server_random[0]),
-                                            SSL3_RANDOM_SIZE) &lt;= 0
-                        || EVP_DigestUpdate(&amp;md_ctx, d, n) &lt;= 0
-                        || EVP_DigestFinal_ex(&amp;md_ctx, q,
-                                              (unsigned int *)&amp;i) &lt;= 0) {
-                    SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE,
-                           ERR_LIB_EVP);
-                    al = SSL_AD_INTERNAL_ERROR;
-                    goto f_err;
-                }
-                q += i;
-                j += i;
-            }
-            if (RSA_sign(NID_md5_sha1, md_buf, j,
-                         &amp;(p[2]), &amp;u, pkey-&gt;pkey.rsa) &lt;= 0) {
-                SSLerr(SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE, ERR_LIB_RSA);
-                goto err;
-            }
-            s2n(u, p);
-            n += u + 2;
-        } else
-#endif
         if (md) {
             /* send signature algorithm */
             if (SSL_USE_SIGALGS(s)) {
@@ -2970,8 +2932,7 @@ WORK_STATE tls_post_process_client_key_exchange(SSL *s, WORK_STATE wst)
         BIO_free(s-&gt;s3-&gt;handshake_buffer);
         s-&gt;s3-&gt;handshake_buffer = NULL;
         return WORK_FINISHED_CONTINUE;
-    } else if (SSL_USE_SIGALGS(s) || (s-&gt;s3-&gt;tmp.new_cipher-&gt;algorithm_auth
-                        &amp; (SSL_aGOST12|SSL_aGOST01) )) {
+    } else {
         if (!s-&gt;session-&gt;peer) {
             /* No peer certificate so we no longer need the handshake_buffer */
             BIO_free(s-&gt;s3-&gt;handshake_buffer);
@@ -2991,41 +2952,6 @@ WORK_STATE tls_post_process_client_key_exchange(SSL *s, WORK_STATE wst)
             ossl_statem_set_error(s);
             return WORK_ERROR;
         }
-    } else {
-        int offset = 0;
-        int dgst_num;
-
-        /*
-         * We need to get hashes here so if there is a client cert,
-         * it can be verified FIXME - digest processing for
-         * CertificateVerify should be generalized. But it is next
-         * step
-         */
-        if (!ssl3_digest_cached_records(s, 0)) {
-            ossl_statem_set_error(s);
-            return WORK_ERROR;
-        }
-        for (dgst_num = 0; dgst_num &lt; SSL_MAX_DIGEST; dgst_num++) {
-            if (s-&gt;s3-&gt;handshake_dgst[dgst_num]) {
-                int dgst_size;
-
-                s-&gt;method-&gt;ssl3_enc-&gt;cert_verify_mac(s,
-                                                     EVP_MD_CTX_type
-                                                     (s-&gt;
-                                                      s3-&gt;handshake_dgst
-                                                      [dgst_num]),
-                                                     &amp;(s-&gt;s3-&gt;
-                                                       tmp.cert_verify_md
-                                                       [offset]));
-                dgst_size =
-                    EVP_MD_CTX_size(s-&gt;s3-&gt;handshake_dgst[dgst_num]);
-                if (dgst_size &lt; 0) {
-                    ossl_statem_set_error(s);
-                return WORK_ERROR;
-                }
-                offset += dgst_size;
-            }
-        }
     }
 
     return WORK_FINISHED_CONTINUE;
@@ -3036,10 +2962,13 @@ MSG_PROCESS_RETURN tls_process_cert_verify(SSL *s, PACKET *pkt)
     EVP_PKEY *pkey = NULL;
     unsigned char *sig, *data;
     int al, ret = MSG_PROCESS_ERROR;
-    int type = 0, i, j;
+    int type = 0, j;
     unsigned int len;
     X509 *peer;
     const EVP_MD *md = NULL;
+    long hdatalen = 0;
+    void *hdata;
+
     EVP_MD_CTX mctx;
     EVP_MD_CTX_init(&amp;mctx);
 
@@ -3080,6 +3009,10 @@ MSG_PROCESS_RETURN tls_process_cert_verify(SSL *s, PACKET *pkt)
 #ifdef SSL_DEBUG
             fprintf(stderr, &quot;USING TLSv1.2 HASH %s\n&quot;, EVP_MD_name(md));
 #endif
+        } else if (pkey-&gt;type == EVP_PKEY_RSA) {
+            md = EVP_md5_sha1();
+        } else {
+            md = EVP_sha1();
         }
         if (!PACKET_get_net_2(pkt, &amp;len)) {
             SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, SSL_R_LENGTH_MISMATCH);
@@ -3100,101 +3033,45 @@ MSG_PROCESS_RETURN tls_process_cert_verify(SSL *s, PACKET *pkt)
         goto f_err;
     }
 
-    if (SSL_USE_SIGALGS(s)
-            || pkey-&gt;type == NID_id_GostR3410_2001
-            || pkey-&gt;type == NID_id_GostR3410_2012_256
-            || pkey-&gt;type == NID_id_GostR3410_2012_512) {
-        long hdatalen = 0;
-        void *hdata;
-        hdatalen = BIO_get_mem_data(s-&gt;s3-&gt;handshake_buffer, &amp;hdata);
-        if (hdatalen &lt;= 0) {
-            SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
-            al = SSL_AD_INTERNAL_ERROR;
-            goto f_err;
-        }
+    hdatalen = BIO_get_mem_data(s-&gt;s3-&gt;handshake_buffer, &amp;hdata);
+    if (hdatalen &lt;= 0) {
+        SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
+        al = SSL_AD_INTERNAL_ERROR;
+        goto f_err;
+    }
 #ifdef SSL_DEBUG
-        fprintf(stderr, &quot;Using TLS 1.2 with client verify alg %s\n&quot;,
-                EVP_MD_name(md));
+    fprintf(stderr, &quot;Using client verify alg %s\n&quot;, EVP_MD_name(md));
 #endif
-        if (!SSL_USE_SIGALGS(s)) {
-            int dgst_nid;
-            if (EVP_PKEY_get_default_digest_nid(pkey, &amp;dgst_nid) &lt;= 0
-                || (md = EVP_get_digestbynid(dgst_nid)) == NULL) {
-                SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
-                al = SSL_AD_INTERNAL_ERROR;
-                goto f_err;
-            }
-        }
-        if (!EVP_VerifyInit_ex(&amp;mctx, md, NULL)
-            || !EVP_VerifyUpdate(&amp;mctx, hdata, hdatalen)) {
-            SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, ERR_R_EVP_LIB);
-            al = SSL_AD_INTERNAL_ERROR;
-            goto f_err;
-        }
+    if (!EVP_VerifyInit_ex(&amp;mctx, md, NULL)
+        || !EVP_VerifyUpdate(&amp;mctx, hdata, hdatalen)) {
+        SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, ERR_R_EVP_LIB);
+        al = SSL_AD_INTERNAL_ERROR;
+        goto f_err;
+    }
 
-        if (pkey-&gt;type == NID_id_GostR3410_2001
-                || pkey-&gt;type == NID_id_GostR3410_2012_256
-                || pkey-&gt;type == NID_id_GostR3410_2012_512) {
-            unsigned int j1, j2;
-            for (j1 = len - 1, j2 = 0; j2 &lt; len/2; j2++, j1--) {
-                char c = data[j2];
-                data[j2] = data[j1];
-                data[j1] = c;
-            }
+    if (pkey-&gt;type == NID_id_GostR3410_2001
+            || pkey-&gt;type == NID_id_GostR3410_2012_256
+            || pkey-&gt;type == NID_id_GostR3410_2012_512) {
+        unsigned int j1, j2;
+        for (j1 = len - 1, j2 = 0; j2 &lt; len/2; j2++, j1--) {
+            char c = data[j2];
+            data[j2] = data[j1];
+            data[j1] = c;
         }
+    }
 
-        if (EVP_VerifyFinal(&amp;mctx, data, len, pkey) &lt;= 0) {
-            al = SSL_AD_DECRYPT_ERROR;
-            SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, SSL_R_BAD_SIGNATURE);
-            goto f_err;
-        }
-    } else
-#ifndef OPENSSL_NO_RSA
-    if (pkey-&gt;type == EVP_PKEY_RSA) {
-        i = RSA_verify(NID_md5_sha1, s-&gt;s3-&gt;tmp.cert_verify_md,
-                       MD5_DIGEST_LENGTH + SHA_DIGEST_LENGTH, data, len,
-                       pkey-&gt;pkey.rsa);
-        if (i &lt; 0) {
-            al = SSL_AD_DECRYPT_ERROR;
-            SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, SSL_R_BAD_RSA_DECRYPT);
-            goto f_err;
-        }
-        if (i == 0) {
-            al = SSL_AD_DECRYPT_ERROR;
-            SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, SSL_R_BAD_RSA_SIGNATURE);
-            goto f_err;
-        }
-    } else
-#endif
-#ifndef OPENSSL_NO_DSA
-    if (pkey-&gt;type == EVP_PKEY_DSA) {
-        j = DSA_verify(pkey-&gt;save_type,
-                       &amp;(s-&gt;s3-&gt;tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
-                       SHA_DIGEST_LENGTH, data, len, pkey-&gt;pkey.dsa);
-        if (j &lt;= 0) {
-            /* bad signature */
-            al = SSL_AD_DECRYPT_ERROR;
-            SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, SSL_R_BAD_DSA_SIGNATURE);
-            goto f_err;
-        }
-    } else
-#endif
-#ifndef OPENSSL_NO_EC
-    if (pkey-&gt;type == EVP_PKEY_EC) {
-        j = ECDSA_verify(pkey-&gt;save_type,
-                         &amp;(s-&gt;s3-&gt;tmp.cert_verify_md[MD5_DIGEST_LENGTH]),
-                         SHA_DIGEST_LENGTH, data, len, pkey-&gt;pkey.ec);
-        if (j &lt;= 0) {
-            /* bad signature */
-            al = SSL_AD_DECRYPT_ERROR;
-            SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, SSL_R_BAD_ECDSA_SIGNATURE);
-            goto f_err;
-        }
-    } else
-#endif
-    {
-        SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, ERR_R_INTERNAL_ERROR);
-        al = SSL_AD_UNSUPPORTED_CERTIFICATE;
+    if (s-&gt;version == SSL3_VERSION
+        &amp;&amp; !EVP_MD_CTX_ctrl(&amp;mctx, EVP_CTRL_SSL3_MASTER_SECRET,
+                            s-&gt;session-&gt;master_key_length,
+                            s-&gt;session-&gt;master_key)) {
+        SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, ERR_R_EVP_LIB);
+        al = SSL_AD_INTERNAL_ERROR;
+        goto f_err;
+    }
+
+    if (EVP_VerifyFinal(&amp;mctx, data, len, pkey) &lt;= 0) {
+        al = SSL_AD_DECRYPT_ERROR;
+        SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, SSL_R_BAD_SIGNATURE);
         goto f_err;
     }
 
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index 2ba76e3..999859e 100644
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -2705,15 +2705,18 @@ static int ssl_check_clienthello_tlsext_early(SSL *s)
     }
 }
 /* Initialise digests to default values */
-static void ssl_set_default_md(SSL *s)
+void ssl_set_default_md(SSL *s)
 {
     const EVP_MD **pmd = s-&gt;s3-&gt;tmp.md;
 #ifndef OPENSSL_NO_DSA
     pmd[SSL_PKEY_DSA_SIGN] = EVP_sha1();
 #endif
 #ifndef OPENSSL_NO_RSA
-    pmd[SSL_PKEY_RSA_SIGN] = EVP_sha1();
-    pmd[SSL_PKEY_RSA_ENC] = EVP_sha1();
+    if (SSL_USE_SIGALGS(s))
+        pmd[SSL_PKEY_RSA_SIGN] = EVP_sha1();
+    else
+        pmd[SSL_PKEY_RSA_SIGN] = EVP_md5_sha1();
+    pmd[SSL_PKEY_RSA_ENC] = pmd[SSL_PKEY_RSA_SIGN];
 #endif
 #ifndef OPENSSL_NO_EC
     pmd[SSL_PKEY_ECC] = EVP_sha1();
diff --git a/util/libeay.num b/util/libeay.num
index 0ff302c..5119769 100755
--- a/util/libeay.num
+++ b/util/libeay.num
@@ -4663,3 +4663,5 @@ ASYNC_unblock_pause                     5022	EXIST::FUNCTION:
 ASYNC_block_pause                       5023	EXIST::FUNCTION:
 ASYNC_cleanup                           5024	EXIST::FUNCTION:
 ASYNC_init                              5025	EXIST::FUNCTION:
+EVP_MD_CTX_ctrl                         5026	EXIST::FUNCTION:
+EVP_md5_sha1                            5027	EXIST::FUNCTION:MD5
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002195.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="002204.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2202">[ date ]</a>
              <a href="thread.html#2202">[ thread ]</a>
              <a href="subject.html#2202">[ subject ]</a>
              <a href="author.html#2202">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
