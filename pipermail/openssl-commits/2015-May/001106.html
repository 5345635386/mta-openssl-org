<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2015-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1431971102.691433.24125.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001105.html">
   <LINK REL="Next"  HREF="001107.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Dr. Stephen Henson</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1431971102.691433.24125.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">steve at openssl.org
       </A><BR>
    <I>Mon May 18 17:45:02 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="001105.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="001107.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1106">[ date ]</a>
              <a href="thread.html#1106">[ thread ]</a>
              <a href="subject.html#1106">[ subject ]</a>
              <a href="author.html#1106">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  6c5b6cb035666d46495ccbe4a4f3d5e3a659cd40 (commit)
       via  978327bcadb738b7bc7a52f74c7b4c5f56bda4a6 (commit)
      from  b2ce0337e8430f7d4d1e692415efc89ed02a8ea3 (commit)


- Log -----------------------------------------------------------------
commit 6c5b6cb035666d46495ccbe4a4f3d5e3a659cd40
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Fri May 15 00:00:41 2015 +0100

    ASN1 INTEGER refactor.
    
    Rewrite and tidy ASN1_INTEGER and ASN1_ENUMERATED handling.
    
    Remove code duplication.
    
    New functions to convert between int64_t and ASN.1 types without the
    quirks of the old long conversion functions.
    
    Add documentation.
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 978327bcadb738b7bc7a52f74c7b4c5f56bda4a6
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Sun May 17 15:09:46 2015 +0100

    Add types to indent.pro
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 crypto/asn1/Makefile                  |  24 +-
 crypto/asn1/a_enum.c                  | 179 -----------
 crypto/asn1/a_int.c                   | 540 ++++++++++++++++++++++------------
 crypto/asn1/asn1_err.c                |  15 +-
 crypto/asn1/f_enum.c                  | 193 ------------
 crypto/asn1/f_int.c                   |  13 +
 doc/crypto/ASN1_INTEGER_get_int64.pod | 112 +++++++
 include/openssl/asn1.h                |  23 +-
 util/indent.pro                       |   8 +
 9 files changed, 529 insertions(+), 578 deletions(-)
 delete mode 100644 crypto/asn1/a_enum.c
 delete mode 100644 crypto/asn1/f_enum.c
 create mode 100644 doc/crypto/ASN1_INTEGER_get_int64.pod

diff --git a/crypto/asn1/Makefile b/crypto/asn1/Makefile
index 4283145..20b7948 100644
--- a/crypto/asn1/Makefile
+++ b/crypto/asn1/Makefile
@@ -17,7 +17,7 @@ GENERAL=Makefile README
 LIB=$(TOP)/libcrypto.a
 LIBSRC=	a_object.c a_bitstr.c a_utctm.c a_gentm.c a_time.c a_int.c a_octet.c \
 	a_print.c a_type.c a_dup.c a_d2i_fp.c a_i2d_fp.c \
-	a_enum.c a_utf8.c a_sign.c a_digest.c a_verify.c a_mbstr.c a_strex.c \
+	a_utf8.c a_sign.c a_digest.c a_verify.c a_mbstr.c a_strex.c \
 	x_algor.c x_val.c x_pubkey.c x_sig.c x_req.c x_bignum.c \
 	x_long.c x_x509.c x_x509a.c x_crl.c x_info.c x_spki.c nsseq.c \
 	x_nx509.c d2i_pu.c d2i_pr.c i2d_pu.c i2d_pr.c\
@@ -25,13 +25,13 @@ LIBSRC=	a_object.c a_bitstr.c a_utctm.c a_gentm.c a_time.c a_int.c a_octet.c \
 	tasn_new.c tasn_fre.c tasn_enc.c tasn_dec.c tasn_utl.c tasn_typ.c \
 	tasn_prn.c tasn_scn.c ameth_lib.c \
 	f_int.c f_string.c n_pkey.c \
-	f_enum.c x_pkey.c bio_asn1.c bio_ndef.c asn_mime.c \
+	x_pkey.c bio_asn1.c bio_ndef.c asn_mime.c \
 	asn1_gen.c asn1_par.c asn1_lib.c asn1_err.c a_strnid.c \
 	evp_asn1.c asn_pack.c p5_pbe.c p5_pbev2.c p8_pkey.c asn_moid.c \
 	asn_mstbl.c
 LIBOBJ= a_object.o a_bitstr.o a_utctm.o a_gentm.o a_time.o a_int.o a_octet.o \
 	a_print.o a_type.o a_dup.o a_d2i_fp.o a_i2d_fp.o \
-	a_enum.o a_utf8.o a_sign.o a_digest.o a_verify.o a_mbstr.o a_strex.o \
+	a_utf8.o a_sign.o a_digest.o a_verify.o a_mbstr.o a_strex.o \
 	x_algor.o x_val.o x_pubkey.o x_sig.o x_req.o x_bignum.o \
 	x_long.o x_x509.o x_x509a.o x_crl.o x_info.o x_spki.o nsseq.o \
 	x_nx509.o d2i_pu.o d2i_pr.o i2d_pu.o i2d_pr.o \
@@ -39,7 +39,7 @@ LIBOBJ= a_object.o a_bitstr.o a_utctm.o a_gentm.o a_time.o a_int.o a_octet.o \
 	tasn_new.o tasn_fre.o tasn_enc.o tasn_dec.o tasn_utl.o tasn_typ.o \
 	tasn_prn.o tasn_scn.o ameth_lib.o \
 	f_int.o f_string.o n_pkey.o \
-	f_enum.o x_pkey.o bio_asn1.o bio_ndef.o asn_mime.o \
+	x_pkey.o bio_asn1.o bio_ndef.o asn_mime.o \
 	asn1_gen.o asn1_par.o asn1_lib.o asn1_err.o a_strnid.o \
 	evp_asn1.o asn_pack.o p5_pbe.o p5_pbev2.o p8_pkey.o asn_moid.o \
 	asn_mstbl.o
@@ -133,14 +133,6 @@ a_dup.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
 a_dup.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
 a_dup.o: ../../include/openssl/symhacks.h ../include/internal/cryptlib.h
 a_dup.o: a_dup.c
-a_enum.o: ../../e_os.h ../../include/openssl/asn1.h ../../include/openssl/bio.h
-a_enum.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
-a_enum.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
-a_enum.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
-a_enum.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
-a_enum.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
-a_enum.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-a_enum.o: ../include/internal/cryptlib.h a_enum.c
 a_gentm.o: ../../e_os.h ../../include/openssl/asn1.h
 a_gentm.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
 a_gentm.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
@@ -441,14 +433,6 @@ evp_asn1.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
 evp_asn1.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
 evp_asn1.o: ../../include/openssl/symhacks.h ../include/internal/cryptlib.h
 evp_asn1.o: evp_asn1.c
-f_enum.o: ../../e_os.h ../../include/openssl/asn1.h ../../include/openssl/bio.h
-f_enum.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
-f_enum.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-f_enum.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
-f_enum.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-f_enum.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-f_enum.o: ../../include/openssl/symhacks.h ../include/internal/cryptlib.h
-f_enum.o: f_enum.c
 f_int.o: ../../e_os.h ../../include/openssl/asn1.h ../../include/openssl/bio.h
 f_int.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
 f_int.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
diff --git a/crypto/asn1/a_enum.c b/crypto/asn1/a_enum.c
deleted file mode 100644
index 81c0f3a..0000000
--- a/crypto/asn1/a_enum.c
+++ /dev/null
@@ -1,179 +0,0 @@
-/* crypto/asn1/a_enum.c */
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include &lt;stdio.h&gt;
-#include &quot;internal/cryptlib.h&quot;
-#include &lt;openssl/asn1.h&gt;
-#include &lt;openssl/bn.h&gt;
-
-/*
- * Code for ENUMERATED type: identical to INTEGER apart from a different tag.
- * for comments on encoding see a_int.c
- */
-
-int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v)
-{
-    int j, k;
-    unsigned int i;
-    unsigned char buf[sizeof(long) + 1];
-    long d;
-
-    a-&gt;type = V_ASN1_ENUMERATED;
-    if (a-&gt;length &lt; (int)(sizeof(long) + 1)) {
-        OPENSSL_free(a-&gt;data);
-        if ((a-&gt;data = OPENSSL_malloc(sizeof(long) + 1)) != NULL)
-            memset(a-&gt;data, 0, sizeof(long) + 1);
-    }
-    if (a-&gt;data == NULL) {
-        ASN1err(ASN1_F_ASN1_ENUMERATED_SET, ERR_R_MALLOC_FAILURE);
-        return (0);
-    }
-    d = v;
-    if (d &lt; 0) {
-        d = -d;
-        a-&gt;type = V_ASN1_NEG_ENUMERATED;
-    }
-
-    for (i = 0; i &lt; sizeof(long); i++) {
-        if (d == 0)
-            break;
-        buf[i] = (int)d &amp; 0xff;
-        d &gt;&gt;= 8;
-    }
-    j = 0;
-    for (k = i - 1; k &gt;= 0; k--)
-        a-&gt;data[j++] = buf[k];
-    a-&gt;length = j;
-    return (1);
-}
-
-long ASN1_ENUMERATED_get(ASN1_ENUMERATED *a)
-{
-    int neg = 0, i;
-    long r = 0;
-
-    if (a == NULL)
-        return (0L);
-    i = a-&gt;type;
-    if (i == V_ASN1_NEG_ENUMERATED)
-        neg = 1;
-    else if (i != V_ASN1_ENUMERATED)
-        return -1;
-
-    if (a-&gt;length &gt; (int)sizeof(long)) {
-        /* hmm... a bit ugly */
-        return (0xffffffffL);
-    }
-    if (a-&gt;data == NULL)
-        return 0;
-
-    for (i = 0; i &lt; a-&gt;length; i++) {
-        r &lt;&lt;= 8;
-        r |= (unsigned char)a-&gt;data[i];
-    }
-    if (neg)
-        r = -r;
-    return (r);
-}
-
-ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai)
-{
-    ASN1_ENUMERATED *ret;
-    int len, j;
-
-    if (ai == NULL)
-        ret = ASN1_ENUMERATED_new();
-    else
-        ret = ai;
-    if (ret == NULL) {
-        ASN1err(ASN1_F_BN_TO_ASN1_ENUMERATED, ERR_R_NESTED_ASN1_ERROR);
-        goto err;
-    }
-    if (BN_is_negative(bn))
-        ret-&gt;type = V_ASN1_NEG_ENUMERATED;
-    else
-        ret-&gt;type = V_ASN1_ENUMERATED;
-    j = BN_num_bits(bn);
-    len = ((j == 0) ? 0 : ((j / 8) + 1));
-    if (ret-&gt;length &lt; len + 4) {
-        unsigned char *new_data = OPENSSL_realloc(ret-&gt;data, len + 4);
-        if (!new_data) {
-            ASN1err(ASN1_F_BN_TO_ASN1_ENUMERATED, ERR_R_MALLOC_FAILURE);
-            goto err;
-        }
-        ret-&gt;data = new_data;
-    }
-
-    ret-&gt;length = BN_bn2bin(bn, ret-&gt;data);
-    return (ret);
- err:
-    if (ret != ai)
-        ASN1_ENUMERATED_free(ret);
-    return (NULL);
-}
-
-BIGNUM *ASN1_ENUMERATED_to_BN(ASN1_ENUMERATED *ai, BIGNUM *bn)
-{
-    BIGNUM *ret;
-
-    if ((ret = BN_bin2bn(ai-&gt;data, ai-&gt;length, bn)) == NULL)
-        ASN1err(ASN1_F_ASN1_ENUMERATED_TO_BN, ASN1_R_BN_LIB);
-    else if (ai-&gt;type == V_ASN1_NEG_ENUMERATED)
-        BN_set_negative(ret, 1);
-    return (ret);
-}
diff --git a/crypto/asn1/a_int.c b/crypto/asn1/a_int.c
index 56a72fb..f3a7e6a 100644
--- a/crypto/asn1/a_int.c
+++ b/crypto/asn1/a_int.c
@@ -58,6 +58,7 @@
 
 #include &lt;stdio.h&gt;
 #include &quot;internal/cryptlib.h&quot;
+#include &lt;limits.h&gt;
 #include &lt;openssl/asn1.h&gt;
 #include &lt;openssl/bn.h&gt;
 #include &quot;asn1_locl.h&quot;
@@ -88,10 +89,11 @@ int ASN1_INTEGER_cmp(const ASN1_INTEGER *x, const ASN1_INTEGER *y)
 }
 
 /*-
- * This converts an ASN1 INTEGER into its content encoding.
+ * This converts a big endian buffer and sign into its content encoding.
+ * This is used for INTEGER and ENUMERATED types.
  * The internal representation is an ASN1_STRING whose data is a big endian
  * representation of the value, ignoring the sign. The sign is determined by
- * the type: V_ASN1_INTEGER for positive and V_ASN1_NEG_INTEGER for negative.
+ * the type: if type &amp; V_ASN1_NEG is true it is negative, otherwise positive.
  *
  * Positive integers are no problem: they are almost the same as the DER
  * encoding, except if the first byte is &gt;= 0x80 we need to add a zero pad.
@@ -112,19 +114,19 @@ int ASN1_INTEGER_cmp(const ASN1_INTEGER *x, const ASN1_INTEGER *y)
  * followed by optional zeros isn't padded.
  */
 
-int i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp)
+static size_t i2c_ibuf(const unsigned char *b, size_t blen, int neg,
+                       unsigned char **pp)
 {
-    int pad = 0, ret, i, neg;
-    unsigned char *p, *n, pb = 0;
+    int pad = 0;
+    size_t ret, i;
+    unsigned char *p, pb = 0;
+    const unsigned char *n;
 
-    if (a == NULL)
-        return (0);
-    neg = a-&gt;type &amp; V_ASN1_NEG;
-    if (a-&gt;length == 0)
+    if (b == NULL || blen == 0)
         ret = 1;
     else {
-        ret = a-&gt;length;
-        i = a-&gt;data[0];
+        ret = blen;
+        i = b[0];
         if (ret == 1 &amp;&amp; i == 0)
             neg = 0;
         if (!neg &amp;&amp; (i &gt; 127)) {
@@ -139,8 +141,8 @@ int i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp)
                  * Special case: if any other bytes non zero we pad:
                  * otherwise we don't.
                  */
-                for (i = 1; i &lt; a-&gt;length; i++)
-                    if (a-&gt;data[i]) {
+                for (i = 1; i &lt; blen; i++)
+                    if (b[i]) {
                         pad = 1;
                         pb = 0xFF;
                         break;
@@ -150,20 +152,20 @@ int i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp)
         ret += pad;
     }
     if (pp == NULL)
-        return (ret);
+        return ret;
     p = *pp;
 
     if (pad)
         *(p++) = pb;
-    if (a-&gt;length == 0)
+    if (blen == 0)
         *(p++) = 0;
     else if (!neg)
-        memcpy(p, a-&gt;data, (unsigned int)a-&gt;length);
+        memcpy(p, b, blen);
     else {
         /* Begin at the end of the encoding */
-        n = a-&gt;data + a-&gt;length - 1;
-        p += a-&gt;length - 1;
-        i = a-&gt;length;
+        n = b + blen - 1;
+        p += blen - 1;
+        i = blen;
         /* Copy zeros to destination as long as source is zero */
         while (!*n &amp;&amp; i &gt; 1) {
             *(p--) = 0;
@@ -179,97 +181,241 @@ int i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp)
     }
 
     *pp += ret;
-    return (ret);
+    return ret;
 }
 
-/* Convert just ASN1 INTEGER content octets to ASN1_INTEGER structure */
+/*
+ * convert content octets into a big endian buffer. Returns the length
+ * of buffer or 0 on error: for malformed INTEGER. If output bufer is
+ * NULL just return length.
+ */
 
-ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,
-                               long len)
+static size_t c2i_ibuf(unsigned char *b, int *pneg,
+                       const unsigned char *p, size_t plen)
 {
-    ASN1_INTEGER *ret = NULL;
-    const unsigned char *p, *pend;
-    unsigned char *to, *s;
-    int i;
+    size_t i;
+    int neg, pad;
+    /* Zero content length is illegal */
+    if (plen == 0) {
+        ASN1err(ASN1_F_C2I_IBUF, ASN1_R_ILLEGAL_ZERO_CONTENT);
+        return 0;
+    }
+    neg = p[0] &amp; 0x80;
+    if (pneg)
+        *pneg = neg;
+    /* Handle common case where length is 1 octet separately */
+    if (plen == 1) {
+        if (b) {
+            if (neg)
+                b[0] = (p[0] ^ 0xFF) + 1;
+            else
+                b[0] = p[0];
+        }
+        return 1;
+    }
+    if (p[0] == 0 || p[0] == 0xFF)
+        pad = 1;
+    else
+        pad = 0;
+    /* reject illegal padding: first two octets MSB can't match */
+    if (pad &amp;&amp; (neg == (p[1] &amp; 0x80))) {
+        ASN1err(ASN1_F_C2I_IBUF, ASN1_R_ILLEGAL_PADDING);
+        return 0;
+    }
+    /* If positive just copy across */
+    if (neg == 0) {
+        if (b)
+            memcpy(b, p + pad, plen - pad);
+        return plen - pad;
+    }
 
-    if ((a == NULL) || ((*a) == NULL)) {
-        if ((ret = ASN1_INTEGER_new()) == NULL)
-            return (NULL);
-        ret-&gt;type = V_ASN1_INTEGER;
-    } else
-        ret = (*a);
+    if (neg &amp;&amp; pad) {
+        /* check is any following octets are non zero */
+        for (i = 1; i &lt; plen; i++) {
+            if (p[i] != 0)
+                break;
+        }
+        /* if all bytes are zero handle as special case */
+        if (i == plen) {
+            if (b) {
+                b[0] = 1;
+                memset(b + 1, 0, plen - 1);
+            }
+            return plen;
+        }
+    }
 
-    p = *pp;
-    pend = p + len;
+    plen -= pad;
+    /* Must be negative: calculate twos complement */
+    if (b) {
+        const unsigned char *from = p + plen - 1 + pad;
+        unsigned char *to = b + plen - 1;
+        i = plen;
+        while (*from == 0 &amp;&amp; i) {
+            *to-- = 0;
+            i--;
+            from--;
+        }
+        *to-- = (*from-- ^ 0xff) + 1;
+        OPENSSL_assert(i != 0);
+        i--;
+        for (; i &gt; 0; i--)
+            *to-- = *from-- ^ 0xff;
+    }
+    return plen;
+}
 
-    /*
-     * We must OPENSSL_malloc stuff, even for 0 bytes otherwise it signifies
-     * a missing NULL parameter.
-     */
-    s = OPENSSL_malloc((int)len + 1);
-    if (s == NULL) {
-        i = ERR_R_MALLOC_FAILURE;
-        goto err;
+int i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp)
+{
+    return i2c_ibuf(a-&gt;data, a-&gt;length, a-&gt;type &amp; V_ASN1_NEG, pp);
+}
+
+/* Convert big endian buffer into uint64_t, return 0 on error */
+static int asn1_get_uint64(uint64_t *pr, const unsigned char *b, size_t blen)
+{
+    size_t i;
+    if (blen &gt; sizeof(*pr)) {
+        ASN1err(ASN1_F_ASN1_GET_UINT64, ASN1_R_TOO_LARGE);
+        return 0;
     }
-    to = s;
-    if (!len) {
-        /*
-         * Strictly speaking this is an illegal INTEGER but we tolerate it.
-         */
-        ret-&gt;type = V_ASN1_INTEGER;
-    } else if (*p &amp; 0x80) {     /* a negative number */
-        ret-&gt;type = V_ASN1_NEG_INTEGER;
-        if ((*p == 0xff) &amp;&amp; (len != 1)) {
-            p++;
-            len--;
-        }
-        i = len;
-        p += i - 1;
-        to += i - 1;
-        while ((!*p) &amp;&amp; i) {
-            *(to--) = 0;
-            i--;
-            p--;
+    *pr = 0;
+    if (b == NULL)
+        return 0;
+    for (i = 0; i &lt; blen; i++) {
+        *pr &lt;&lt;= 8;
+        *pr |= b[i];
+    }
+    return 1;
+}
+
+static size_t asn1_put_uint64(unsigned char *b, uint64_t r)
+{
+    if (r &gt;= 0x100) {
+        unsigned char *p;
+        uint64_t rtmp = r;
+        size_t i = 0;
+
+        /* Work out how many bytes we need */
+        while (rtmp) {
+            rtmp &gt;&gt;= 8;
+            i++;
         }
-        /*
-         * Special case: if all zeros then the number will be of the form FF
-         * followed by n zero bytes: this corresponds to 1 followed by n zero
-         * bytes. We've already written n zeros so we just append an extra
-         * one and set the first byte to a 1. This is treated separately
-         * because it is the only case where the number of bytes is larger
-         * than len.
-         */
-        if (!i) {
-            *s = 1;
-            s[len] = 0;
-            len++;
-        } else {
-            *(to--) = (*(p--) ^ 0xff) + 1;
-            i--;
-            for (; i &gt; 0; i--)
-                *(to--) = *(p--) ^ 0xff;
+
+        /* Copy from end to beginning */
+        p = b + i - 1;
+
+        do {
+            *p-- = r &amp; 0xFF;
+            r &gt;&gt;= 8;
+        } while (p &gt;= b);
+
+        return i;
+    }
+
+    b[0] = (unsigned char)r;
+    return 1;
+
+}
+
+/*
+ * Absolute value of INT64_MIN: we can't just use -INT64_MIN as it produces
+ * overflow warnings.
+ */
+
+#define ABS_INT64_MIN \
+    ((uint64_t)INT64_MAX + (uint64_t)(-(INT64_MIN + INT64_MAX)))
+
+/* signed version of asn1_get_uint64 */
+static int asn1_get_int64(int64_t *pr, const unsigned char *b, size_t blen,
+                          int neg)
+{
+    uint64_t r;
+    if (asn1_get_uint64(&amp;r, b, blen) == 0)
+        return 0;
+    if (neg) {
+        if (r &gt; ABS_INT64_MIN) {
+            ASN1err(ASN1_F_ASN1_GET_INT64, ASN1_R_TOO_SMALL);
+            return 0;
         }
+        *pr = (int64_t)-r;
     } else {
-        ret-&gt;type = V_ASN1_INTEGER;
-        if ((*p == 0) &amp;&amp; (len != 1)) {
-            p++;
-            len--;
+        if (r &gt; INT64_MAX) {
+            ASN1err(ASN1_F_ASN1_GET_INT64, ASN1_R_TOO_LARGE);
+            return 0;
         }
-        memcpy(s, p, (int)len);
+        *pr = (int64_t)r;
     }
+    return 1;
+}
 
-    OPENSSL_free(ret-&gt;data);
-    ret-&gt;data = s;
-    ret-&gt;length = (int)len;
+/* Convert ASN1 INTEGER content octets to ASN1_INTEGER structure */
+ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,
+                               long len)
+{
+    ASN1_INTEGER *ret = NULL;
+    size_t r;
+    int neg;
+
+    r = c2i_ibuf(NULL, NULL, *pp, len);
+
+    if (r == 0)
+        return NULL;
+
+    if ((a == NULL) || ((*a) == NULL)) {
+        ret = ASN1_INTEGER_new();
+        if (ret == NULL)
+            return NULL;
+        ret-&gt;type = V_ASN1_INTEGER;
+    } else
+        ret = *a;
+
+    if (ASN1_STRING_set(ret, NULL, r) == 0)
+        goto err;
+
+    c2i_ibuf(ret-&gt;data, &amp;neg, *pp, len);
+
+    if (neg)
+        ret-&gt;type |= V_ASN1_NEG;
+
+    *pp += len;
     if (a != NULL)
         (*a) = ret;
-    *pp = pend;
-    return (ret);
+    return ret;
  err:
-    ASN1err(ASN1_F_C2I_ASN1_INTEGER, i);
+    ASN1err(ASN1_F_C2I_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);
     if ((a == NULL) || (*a != ret))
         ASN1_INTEGER_free(ret);
-    return (NULL);
+    return NULL;
+}
+
+static int asn1_string_get_int64(int64_t *pr, const ASN1_STRING *a, int itype)
+{
+    if (a == NULL) {
+        ASN1err(ASN1_F_ASN1_STRING_GET_INT64, ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+    if ((a-&gt;type &amp; ~V_ASN1_NEG) != itype) {
+        ASN1err(ASN1_F_ASN1_STRING_GET_INT64, ASN1_R_WRONG_INTEGER_TYPE);
+        return 0;
+    }
+    return asn1_get_int64(pr, a-&gt;data, a-&gt;length, a-&gt;type &amp; V_ASN1_NEG);
+}
+
+static int asn1_string_set_int64(ASN1_STRING *a, int64_t r, int itype)
+{
+    unsigned char tbuf[sizeof(r)];
+    size_t l;
+    a-&gt;type = itype;
+    if (r &lt; 0) {
+        l = asn1_put_uint64(tbuf, -r);
+        a-&gt;type |= V_ASN1_NEG;
+    } else {
+        l = asn1_put_uint64(tbuf, r);
+        a-&gt;type &amp;= ~V_ASN1_NEG;
+    }
+    if (l == 0)
+        return 0;
+    return ASN1_STRING_set(a, tbuf, l);
 }
 
 /*
@@ -340,116 +486,148 @@ ASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned char **pp,
     return (NULL);
 }
 
-int ASN1_INTEGER_set(ASN1_INTEGER *a, long v)
+static ASN1_STRING *bn_to_asn1_string(const BIGNUM *bn, ASN1_STRING *ai,
+                                      int atype)
 {
-    int j, k;
-    unsigned int i;
-    unsigned char buf[sizeof(long) + 1];
-
-    if (a-&gt;length &lt; (int)(sizeof(long) + 1)) {
-        OPENSSL_free(a-&gt;data);
-        if ((a-&gt;data = OPENSSL_malloc(sizeof(long) + 1)) != NULL)
-            memset(a-&gt;data, 0, sizeof(long) + 1);
-    }
-    if (a-&gt;data == NULL) {
-        ASN1err(ASN1_F_ASN1_INTEGER_SET, ERR_R_MALLOC_FAILURE);
-        return (0);
-    }
-    if (v &lt; 0) {
-        v = -v;
-        a-&gt;type = V_ASN1_NEG_INTEGER;
-    } else
-        a-&gt;type = V_ASN1_INTEGER;
+    ASN1_INTEGER *ret;
+    int len;
 
-    for (i = 0; i &lt; sizeof(long); i++) {
-        if (v == 0)
-            break;
-        buf[i] = (int)v &amp; 0xff;
-        v &gt;&gt;= 8;
+    if (ai == NULL) {
+        ret = ASN1_STRING_type_new(atype);
+    } else {
+        ret = ai;
+        ret-&gt;type = atype;
     }
-    j = 0;
-    for (k = i - 1; k &gt;= 0; k--)
-        a-&gt;data[j++] = buf[k];
-    a-&gt;length = j;
-    return (1);
-}
-
-long ASN1_INTEGER_get(const ASN1_INTEGER *a)
-{
-    int neg = 0, i;
-    long r = 0;
 
-    if (a == NULL)
-        return (0L);
-    i = a-&gt;type;
-    if (i == V_ASN1_NEG_INTEGER)
-        neg = 1;
-    else if (i != V_ASN1_INTEGER)
-        return -1;
-
-    if (a-&gt;length &gt; (int)sizeof(long)) {
-        /* hmm... a bit ugly, return all ones */
-        return -1;
+    if (ret == NULL) {
+        ASN1err(ASN1_F_BN_TO_ASN1_STRING, ERR_R_NESTED_ASN1_ERROR);
+        goto err;
     }
-    if (a-&gt;data == NULL)
-        return 0;
 
-    for (i = 0; i &lt; a-&gt;length; i++) {
-        r &lt;&lt;= 8;
-        r |= (unsigned char)a-&gt;data[i];
-    }
-    if (neg)
-        r = -r;
-    return (r);
-}
+    if (BN_is_negative(bn) &amp;&amp; !BN_is_zero(bn))
+        ret-&gt;type |= V_ASN1_NEG_INTEGER;
 
-ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai)
-{
-    ASN1_INTEGER *ret;
-    int len, j;
+    len = BN_num_bytes(bn);
 
-    if (ai == NULL)
-        ret = ASN1_INTEGER_new();
-    else
-        ret = ai;
-    if (ret == NULL) {
-        ASN1err(ASN1_F_BN_TO_ASN1_INTEGER, ERR_R_NESTED_ASN1_ERROR);
+    if (len == 0)
+        len = 1;
+
+    if (ASN1_STRING_set(ret, NULL, len) == 0) {
+        ASN1err(ASN1_F_BN_TO_ASN1_STRING, ERR_R_MALLOC_FAILURE);
         goto err;
     }
-    if (BN_is_negative(bn) &amp;&amp; !BN_is_zero(bn))
-        ret-&gt;type = V_ASN1_NEG_INTEGER;
-    else
-        ret-&gt;type = V_ASN1_INTEGER;
-    j = BN_num_bits(bn);
-    len = ((j == 0) ? 0 : ((j / 8) + 1));
-    if (ret-&gt;length &lt; len + 4) {
-        unsigned char *new_data = OPENSSL_realloc(ret-&gt;data, len + 4);
-        if (!new_data) {
-            ASN1err(ASN1_F_BN_TO_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);
-            goto err;
-        }
-        ret-&gt;data = new_data;
-    }
-    ret-&gt;length = BN_bn2bin(bn, ret-&gt;data);
+
     /* Correct zero case */
-    if (!ret-&gt;length) {
+    if (BN_is_zero(bn))
         ret-&gt;data[0] = 0;
-        ret-&gt;length = 1;
-    }
-    return (ret);
+    else
+        len = BN_bn2bin(bn, ret-&gt;data);
+    ret-&gt;length = len;
+    return ret;
  err:
     if (ret != ai)
         ASN1_INTEGER_free(ret);
     return (NULL);
 }
 
-BIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn)
+static BIGNUM *asn1_string_to_bn(const ASN1_INTEGER *ai, BIGNUM *bn,
+                                 int itype)
 {
     BIGNUM *ret;
 
-    if ((ret = BN_bin2bn(ai-&gt;data, ai-&gt;length, bn)) == NULL)
-        ASN1err(ASN1_F_ASN1_INTEGER_TO_BN, ASN1_R_BN_LIB);
-    else if (ai-&gt;type == V_ASN1_NEG_INTEGER)
+    if ((ai-&gt;type &amp; ~V_ASN1_NEG) != itype) {
+        ASN1err(ASN1_F_ASN1_STRING_TO_BN, ASN1_R_WRONG_INTEGER_TYPE);
+        return NULL;
+    }
+
+    ret = BN_bin2bn(ai-&gt;data, ai-&gt;length, bn);
+    if (ret == 0) {
+        ASN1err(ASN1_F_ASN1_STRING_TO_BN, ASN1_R_BN_LIB);
+        return NULL;
+    }
+    if (ai-&gt;type &amp; V_ASN1_NEG)
         BN_set_negative(ret, 1);
-    return (ret);
+    return ret;
+}
+
+int ASN1_INTEGER_get_int64(int64_t *pr, const ASN1_INTEGER *a)
+{
+    return asn1_string_get_int64(pr, a, V_ASN1_INTEGER);
+}
+
+int ASN1_INTEGER_set_int64(ASN1_INTEGER *a, int64_t r)
+{
+    return asn1_string_set_int64(a, r, V_ASN1_INTEGER);
+}
+
+int ASN1_INTEGER_set(ASN1_INTEGER *a, long v)
+{
+    return ASN1_INTEGER_set_int64(a, v);
+}
+
+long ASN1_INTEGER_get(const ASN1_INTEGER *a)
+{
+    int i;
+    int64_t r;
+    if (a == NULL)
+        return 0;
+    i = ASN1_INTEGER_get_int64(&amp;r, a);
+    if (i == 0)
+        return -1;
+    if (r &gt; LONG_MAX || r &lt; LONG_MIN)
+        return -1;
+    return (long)r;
+}
+
+ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai)
+{
+    return bn_to_asn1_string(bn, ai, V_ASN1_INTEGER);
+}
+
+BIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn)
+{
+    return asn1_string_to_bn(ai, bn, V_ASN1_INTEGER);
+}
+
+int ASN1_ENUMERATED_get_int64(int64_t *pr, const ASN1_ENUMERATED *a)
+{
+    return asn1_string_get_int64(pr, a, V_ASN1_ENUMERATED);
+}
+
+int ASN1_ENUMERATED_set_int64(ASN1_ENUMERATED *a, int64_t r)
+{
+    return asn1_string_set_int64(a, r, V_ASN1_ENUMERATED);
+}
+
+int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v)
+{
+    return ASN1_ENUMERATED_set_int64(a, v);
+}
+
+long ASN1_ENUMERATED_get(ASN1_ENUMERATED *a)
+{
+    int i;
+    int64_t r;
+    if (a == NULL)
+        return 0;
+    if ((a-&gt;type &amp; ~V_ASN1_NEG) != V_ASN1_ENUMERATED)
+        return -1;
+    if (a-&gt;length &gt; (int)sizeof(long))
+        return 0xffffffffL;
+    i = ASN1_ENUMERATED_get_int64(&amp;r, a);
+    if (i == 0)
+        return -1;
+    if (r &gt; LONG_MAX || r &lt; LONG_MIN)
+        return -1;
+    return (long)r;
+}
+
+ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(const BIGNUM *bn, ASN1_ENUMERATED *ai)
+{
+    return bn_to_asn1_string(bn, ai, V_ASN1_ENUMERATED);
+}
+
+BIGNUM *ASN1_ENUMERATED_to_BN(const ASN1_ENUMERATED *ai, BIGNUM *bn)
+{
+    return asn1_string_to_bn(ai, bn, V_ASN1_ENUMERATED);
 }
diff --git a/crypto/asn1/asn1_err.c b/crypto/asn1/asn1_err.c
index b70ddb7..4151dc7 100644
--- a/crypto/asn1/asn1_err.c
+++ b/crypto/asn1/asn1_err.c
@@ -1,6 +1,6 @@
 /* crypto/asn1/asn1_err.c */
 /* ====================================================================
- * Copyright (c) 1999-2014 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1999-2015 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -93,7 +93,9 @@ static ERR_STRING_DATA ASN1_str_functs[] = {
     {ERR_FUNC(ASN1_F_ASN1_GENERALIZEDTIME_ADJ), &quot;ASN1_GENERALIZEDTIME_adj&quot;},
     {ERR_FUNC(ASN1_F_ASN1_GENERALIZEDTIME_SET), &quot;ASN1_GENERALIZEDTIME_set&quot;},
     {ERR_FUNC(ASN1_F_ASN1_GENERATE_V3), &quot;ASN1_generate_v3&quot;},
+    {ERR_FUNC(ASN1_F_ASN1_GET_INT64), &quot;ASN1_GET_INT64&quot;},
     {ERR_FUNC(ASN1_F_ASN1_GET_OBJECT), &quot;ASN1_get_object&quot;},
+    {ERR_FUNC(ASN1_F_ASN1_GET_UINT64), &quot;ASN1_GET_UINT64&quot;},
     {ERR_FUNC(ASN1_F_ASN1_HEADER_NEW), &quot;ASN1_HEADER_NEW&quot;},
     {ERR_FUNC(ASN1_F_ASN1_I2D_BIO), &quot;ASN1_i2d_bio&quot;},
     {ERR_FUNC(ASN1_F_ASN1_I2D_FP), &quot;ASN1_i2d_fp&quot;},
@@ -101,8 +103,8 @@ static ERR_STRING_DATA ASN1_str_functs[] = {
     {ERR_FUNC(ASN1_F_ASN1_INTEGER_TO_BN), &quot;ASN1_INTEGER_to_BN&quot;},
     {ERR_FUNC(ASN1_F_ASN1_ITEM_D2I_FP), &quot;ASN1_item_d2i_fp&quot;},
     {ERR_FUNC(ASN1_F_ASN1_ITEM_DUP), &quot;ASN1_item_dup&quot;},
-    {ERR_FUNC(ASN1_F_ASN1_ITEM_EX_NEW), &quot;ASN1_ITEM_EX_NEW&quot;},
     {ERR_FUNC(ASN1_F_ASN1_ITEM_EX_D2I), &quot;ASN1_ITEM_EX_D2I&quot;},
+    {ERR_FUNC(ASN1_F_ASN1_ITEM_EX_NEW), &quot;ASN1_ITEM_EX_NEW&quot;},
     {ERR_FUNC(ASN1_F_ASN1_ITEM_I2D_BIO), &quot;ASN1_item_i2d_bio&quot;},
     {ERR_FUNC(ASN1_F_ASN1_ITEM_I2D_FP), &quot;ASN1_item_i2d_fp&quot;},
     {ERR_FUNC(ASN1_F_ASN1_ITEM_PACK), &quot;ASN1_item_pack&quot;},
@@ -121,8 +123,10 @@ static ERR_STRING_DATA ASN1_str_functs[] = {
     {ERR_FUNC(ASN1_F_ASN1_SEQ_UNPACK), &quot;ASN1_seq_unpack&quot;},
     {ERR_FUNC(ASN1_F_ASN1_SIGN), &quot;ASN1_sign&quot;},
     {ERR_FUNC(ASN1_F_ASN1_STR2TYPE), &quot;ASN1_STR2TYPE&quot;},
+    {ERR_FUNC(ASN1_F_ASN1_STRING_GET_INT64), &quot;ASN1_STRING_GET_INT64&quot;},
     {ERR_FUNC(ASN1_F_ASN1_STRING_SET), &quot;ASN1_STRING_set&quot;},
     {ERR_FUNC(ASN1_F_ASN1_STRING_TABLE_ADD), &quot;ASN1_STRING_TABLE_add&quot;},
+    {ERR_FUNC(ASN1_F_ASN1_STRING_TO_BN), &quot;ASN1_STRING_TO_BN&quot;},
     {ERR_FUNC(ASN1_F_ASN1_STRING_TYPE_NEW), &quot;ASN1_STRING_type_new&quot;},
     {ERR_FUNC(ASN1_F_ASN1_TEMPLATE_EX_D2I), &quot;ASN1_TEMPLATE_EX_D2I&quot;},
     {ERR_FUNC(ASN1_F_ASN1_TEMPLATE_NEW), &quot;ASN1_TEMPLATE_NEW&quot;},
@@ -142,9 +146,11 @@ static ERR_STRING_DATA ASN1_str_functs[] = {
     {ERR_FUNC(ASN1_F_BITSTR_CB), &quot;BITSTR_CB&quot;},
     {ERR_FUNC(ASN1_F_BN_TO_ASN1_ENUMERATED), &quot;BN_to_ASN1_ENUMERATED&quot;},
     {ERR_FUNC(ASN1_F_BN_TO_ASN1_INTEGER), &quot;BN_to_ASN1_INTEGER&quot;},
+    {ERR_FUNC(ASN1_F_BN_TO_ASN1_STRING), &quot;BN_TO_ASN1_STRING&quot;},
     {ERR_FUNC(ASN1_F_C2I_ASN1_BIT_STRING), &quot;c2i_ASN1_BIT_STRING&quot;},
     {ERR_FUNC(ASN1_F_C2I_ASN1_INTEGER), &quot;c2i_ASN1_INTEGER&quot;},
     {ERR_FUNC(ASN1_F_C2I_ASN1_OBJECT), &quot;c2i_ASN1_OBJECT&quot;},
+    {ERR_FUNC(ASN1_F_C2I_IBUF), &quot;C2I_IBUF&quot;},
     {ERR_FUNC(ASN1_F_COLLECT_DATA), &quot;COLLECT_DATA&quot;},
     {ERR_FUNC(ASN1_F_D2I_ASN1_BIT_STRING), &quot;D2I_ASN1_BIT_STRING&quot;},
     {ERR_FUNC(ASN1_F_D2I_ASN1_BOOLEAN), &quot;d2i_ASN1_BOOLEAN&quot;},
@@ -252,8 +258,10 @@ static ERR_STRING_DATA ASN1_str_reasons[] = {
     {ERR_REASON(ASN1_R_ILLEGAL_OPTIONAL_ANY), &quot;illegal optional any&quot;},
     {ERR_REASON(ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE),
      &quot;illegal options on item template&quot;},
+    {ERR_REASON(ASN1_R_ILLEGAL_PADDING), &quot;illegal padding&quot;},
     {ERR_REASON(ASN1_R_ILLEGAL_TAGGED_ANY), &quot;illegal tagged any&quot;},
     {ERR_REASON(ASN1_R_ILLEGAL_TIME_VALUE), &quot;illegal time value&quot;},
+    {ERR_REASON(ASN1_R_ILLEGAL_ZERO_CONTENT), &quot;illegal zero content&quot;},
     {ERR_REASON(ASN1_R_INTEGER_NOT_ASCII_FORMAT), &quot;integer not ascii format&quot;},
     {ERR_REASON(ASN1_R_INTEGER_TOO_LARGE_FOR_LONG),
      &quot;integer too large for long&quot;},
@@ -314,7 +322,9 @@ static ERR_STRING_DATA ASN1_str_reasons[] = {
     {ERR_REASON(ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD),
      &quot;the asn1 object identifier is not known for this md&quot;},
     {ERR_REASON(ASN1_R_TIME_NOT_ASCII_FORMAT), &quot;time not ascii format&quot;},
+    {ERR_REASON(ASN1_R_TOO_LARGE), &quot;too large&quot;},
     {ERR_REASON(ASN1_R_TOO_LONG), &quot;too long&quot;},
+    {ERR_REASON(ASN1_R_TOO_SMALL), &quot;too small&quot;},
     {ERR_REASON(ASN1_R_TYPE_NOT_CONSTRUCTED), &quot;type not constructed&quot;},
     {ERR_REASON(ASN1_R_TYPE_NOT_PRIMITIVE), &quot;type not primitive&quot;},
     {ERR_REASON(ASN1_R_UNABLE_TO_DECODE_RSA_KEY), &quot;unable to decode rsa key&quot;},
@@ -339,6 +349,7 @@ static ERR_STRING_DATA ASN1_str_reasons[] = {
     {ERR_REASON(ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE),
      &quot;unsupported public key type&quot;},
     {ERR_REASON(ASN1_R_UNSUPPORTED_TYPE), &quot;unsupported type&quot;},
+    {ERR_REASON(ASN1_R_WRONG_INTEGER_TYPE), &quot;wrong integer type&quot;},
     {ERR_REASON(ASN1_R_WRONG_PUBLIC_KEY_TYPE), &quot;wrong public key type&quot;},
     {ERR_REASON(ASN1_R_WRONG_TAG), &quot;wrong tag&quot;},
     {ERR_REASON(ASN1_R_WRONG_TYPE), &quot;wrong type&quot;},
diff --git a/crypto/asn1/f_enum.c b/crypto/asn1/f_enum.c
deleted file mode 100644
index 4b85be9..0000000
--- a/crypto/asn1/f_enum.c
+++ /dev/null
@@ -1,193 +0,0 @@
-/* crypto/asn1/f_enum.c */
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include &lt;stdio.h&gt;
-#include &quot;internal/cryptlib.h&quot;
-#include &lt;openssl/buffer.h&gt;
-#include &lt;openssl/asn1.h&gt;
-
-/* Based on a_int.c: equivalent ENUMERATED functions */
-
-int i2a_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *a)
-{
-    int i, n = 0;
-    static const char *h = &quot;0123456789ABCDEF&quot;;
-    char buf[2];
-
-    if (a == NULL)
-        return (0);
-
-    if (a-&gt;length == 0) {
-        if (BIO_write(bp, &quot;00&quot;, 2) != 2)
-            goto err;
-        n = 2;
-    } else {
-        for (i = 0; i &lt; a-&gt;length; i++) {
-            if ((i != 0) &amp;&amp; (i % 35 == 0)) {
-                if (BIO_write(bp, &quot;\\\n&quot;, 2) != 2)
-                    goto err;
-                n += 2;
-            }
-            buf[0] = h[((unsigned char)a-&gt;data[i] &gt;&gt; 4) &amp; 0x0f];
-            buf[1] = h[((unsigned char)a-&gt;data[i]) &amp; 0x0f];
-            if (BIO_write(bp, buf, 2) != 2)
-                goto err;
-            n += 2;
-        }
-    }
-    return (n);
- err:
-    return (-1);
-}
-
-int a2i_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *bs, char *buf, int size)
-{
-    int i, j, k, m, n, again, bufsize;
-    unsigned char *s = NULL, *sp;
-    unsigned char *bufp;
-    int num = 0, slen = 0, first = 1;
-
-    bs-&gt;type = V_ASN1_ENUMERATED;
-
-    bufsize = BIO_gets(bp, buf, size);
-    for (;;) {
-        if (bufsize &lt; 1)
-            goto err;
-        i = bufsize;
-        if (buf[i - 1] == '\n')
-            buf[--i] = '\0';
-        if (i == 0)
-            goto err;
-        if (buf[i - 1] == '\r')
-            buf[--i] = '\0';
-        if (i == 0)
-            goto err;
-        again = (buf[i - 1] == '\\');
-
-        for (j = 0; j &lt; i; j++) {
-            if (!(((buf[j] &gt;= '0') &amp;&amp; (buf[j] &lt;= '9')) ||
-                  ((buf[j] &gt;= 'a') &amp;&amp; (buf[j] &lt;= 'f')) ||
-                  ((buf[j] &gt;= 'A') &amp;&amp; (buf[j] &lt;= 'F')))) {
-                i = j;
-                break;
-            }
-        }
-        buf[i] = '\0';
-        /*
-         * We have now cleared all the crap off the end of the line
-         */
-        if (i &lt; 2)
-            goto err;
-
-        bufp = (unsigned char *)buf;
-        if (first) {
-            first = 0;
-            if ((bufp[0] == '0') &amp;&amp; (buf[1] == '0')) {
-                bufp += 2;
-                i -= 2;
-            }
-        }
-        k = 0;
-        i -= again;
-        if (i % 2 != 0) {
-            ASN1err(ASN1_F_A2I_ASN1_ENUMERATED, ASN1_R_ODD_NUMBER_OF_CHARS);
-            return 0;
-        }
-        i /= 2;
-        if (num + i &gt; slen) {
-            sp = OPENSSL_realloc(s, (unsigned int)num + i * 2);
-            if (sp == NULL) {
-                ASN1err(ASN1_F_A2I_ASN1_ENUMERATED, ERR_R_MALLOC_FAILURE);
-                OPENSSL_free(s);
-                return 0;
-            }
-            s = sp;
-            slen = num + i * 2;
-        }
-        for (j = 0; j &lt; i; j++, k += 2) {
-            for (n = 0; n &lt; 2; n++) {
-                m = bufp[k + n];
-                if ((m &gt;= '0') &amp;&amp; (m &lt;= '9'))
-                    m -= '0';
-                else if ((m &gt;= 'a') &amp;&amp; (m &lt;= 'f'))
-                    m = m - 'a' + 10;
-                else if ((m &gt;= 'A') &amp;&amp; (m &lt;= 'F'))
-                    m = m - 'A' + 10;
-                else {
-                    ASN1err(ASN1_F_A2I_ASN1_ENUMERATED,
-                            ASN1_R_NON_HEX_CHARACTERS);
-                    return 0;
-                }
-                s[num + j] &lt;&lt;= 4;
-                s[num + j] |= m;
-            }
-        }
-        num += i;
-        if (again)
-            bufsize = BIO_gets(bp, buf, size);
-        else
-            break;
-    }
-    bs-&gt;length = num;
-    bs-&gt;data = s;
-    return 1;
-
- err:
-    ASN1err(ASN1_F_A2I_ASN1_ENUMERATED, ASN1_R_SHORT_LINE);
-    return 0;
-}
diff --git a/crypto/asn1/f_int.c b/crypto/asn1/f_int.c
index 61029fa..9a0928e 100644
--- a/crypto/asn1/f_int.c
+++ b/crypto/asn1/f_int.c
@@ -204,3 +204,16 @@ int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size)
     ASN1err(ASN1_F_A2I_ASN1_INTEGER, ASN1_R_SHORT_LINE);
     return 0;
 }
+
+int i2a_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *a)
+{
+    return i2a_ASN1_INTEGER(bp, a);
+}
+
+int a2i_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *bs, char *buf, int size)
+{
+    int rv = a2i_ASN1_INTEGER(bp, bs, buf, size);
+    if (rv == 1)
+        bs-&gt;type = V_ASN1_INTEGER | (bs-&gt;type &amp; V_ASN1_NEG);
+    return rv;
+}
diff --git a/doc/crypto/ASN1_INTEGER_get_int64.pod b/doc/crypto/ASN1_INTEGER_get_int64.pod
new file mode 100644
index 0000000..98944b8
--- /dev/null
+++ b/doc/crypto/ASN1_INTEGER_get_int64.pod
@@ -0,0 +1,112 @@
+=pod
+
+=head1 NAME
+
+ASN1_INTEGER_get_int64, ASN1_INTEGER_get, ASN1_INTEGER_set_int64, ASN1_INTEGER_set, BN_to_ASN1_INTEGER, ASN1_INTEGER_to_BN, ASN1_ENUMERATED_get_int64, ASN1_ENUMERATED_get, ASN1_ENUMERATED_set_int64, ASN1_ENUMERATED_set, BN_to_ASN1_ENUMERATED, ASN1_ENUMERATED_to_BN, - ASN.1 INTEGER and ENUMERATED utilities
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/asn1.h&gt;
+
+ int ASN1_INTEGER_get_int64(int64_t *pr, const ASN1_INTEGER *a);
+ int ASN1_INTEGER_get(ASN1_INTEGER *a, long v);
+
+ int ASN1_INTEGER_set_int64(ASN1_INTEGER *a, int64_t r);
+ long ASN1_INTEGER_set(const ASN1_INTEGER *a);
+
+ ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai);
+ BIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn);
+
+ int ASN1_ENUMERATED_get_int64(int64_t *pr, const ASN1_INTEGER *a);
+ long ASN1_ENUMERATED_get(ASN1_ENUMERATED *a);
+
+ int ASN1_ENUMERATED_set_int64(ASN1_INTEGER *a, int64_t r);
+ int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v);
+
+ ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai);
+ BIGNUM *ASN1_ENUMERATED_to_BN(ASN1_ENUMERATED *ai, BIGNUM *bn);
+
+=head1 DESCRIPTION
+
+These functions convert to and from B&lt;ASN1_INTEGER&gt; and B&lt;ASN1_ENUMERATED&gt;
+structures.
+
+ASN1_INTEGER_get_int64() converts an B&lt;ASN1_INTEGER&gt; into an B&lt;int64_t&gt; type
+If successful it returns 1 and sets B&lt;*pr&gt; to the value of B&lt;a&gt;. If it fails
+(due to invalid type or the value being too big to fit into an B&lt;int64_t&gt; type)
+it returns 0.
+
+ASN1_INTEGER_get() also returns the value of B&lt;a&gt; but it returns 0 if B&lt;a&gt; is
+NULL and -1 on error (which is ambiguous because -1 is a legitimate value for
+an B&lt;ASN1_INTEGER&gt;). New applications should use ASN1_INTEGER_get_int64()
+instead.
+
+ASN1_INTEGER_set_int64() sets the value of B&lt;ASN1_INTEGER&gt; B&lt;a&gt; to the
+B&lt;int64_t&gt; value B&lt;r&gt;.
+
+ASN1_INTEGER_set() sets the value of B&lt;ASN1_INTEGER&gt; B&lt;a&gt; to the B&lt;long&gt; value
+B&lt;v&gt;.
+
+BN_to_ASN1_INTEGER() converts B&lt;BIGNUM&gt; B&lt;bn&gt; to an B&lt;ASN1_INTEGER&gt;. If B&lt;ai&gt;
+is NULL a new B&lt;ASN1_INTEGER&gt; structure is returned. If B&lt;ai&gt; is not NULL then
+the existing structure will be used instead.
+
+ASN1_INTEGER_to_BN() converts ASN1_INTEGER B&lt;ai&gt; into a B&lt;BIGNUM&gt;. If B&lt;bn&gt; is
+NULL a new B&lt;BIGNUM&gt; structure is returned. If B&lt;bn&gt; is not NULL then the
+existing structure will be used instead.
+
+ASN1_ENUMERATED_get_int64(), ASN1_ENUMERATED_set_int64(),
+ASN1_ENUMERATED_set(), BN_to_ASN1_ENUMERATED() and ASN1_ENUMERATED_to_BN()
+behave in an identical way to their ASN1_INTEGER counterparts except they
+operate on an B&lt;ASN1_ENUMERATED&gt; value.
+
+ASN1_ENUMERATED_get() returns the value of B&lt;a&gt; in a similar way to
+ASN1_INTEGER_get() but it returns B&lt;0xffffffffL&gt; if the value of B&lt;a&gt; will not
+fit in a long type. New applications should use ASN1_ENUMERATED_get_int64()
+instead.
+
+=head1 NOTES
+
+In general an B&lt;ASN1_INTEGER&gt; or B&lt;ASN1_ENUMERATED&gt; type can contain an
+integer of almost arbitrary size and so cannot always be represented by a C
+B&lt;int64_t&gt; type. However in many cases (for example version numbers) they
+represent small integers which can be more easily manipulated if converted to
+an appropriate C integer type.
+
+=head1 BUGS
+
+The ambigious return values of ASN1_INTEGER_get() and ASN1_ENUMERATED_get()
+mean these functions should be avoided if possible. They are retained for
+compatibility. Normally the ambigious return values are not legitimate
+values for the fields they represent.
+
+=head1 RETURN VALUES
+
+ASN1_INTEGER_set_int64(), ASN1_INTEGER_set(), ASN1_ENUMERATED_set_int64() and
+ASN1_ENUMERATED_set() return 1 for success and 0 for failure. They will only
+fail if a memory allocation error occurs.
+
+ASN1_INTEGER_get_int64() and ASN1_ENUMERATED_get_int64() return 1 for success
+and 0 for failure. They will fail if the passed type is incorrect (this will
+only happen if there is a programming error) or if the value exceeds the range
+of an B&lt;int64_t&gt; type.
+
+BN_to_ASN1_INTEGER() and BN_to_ASN1_ENUMERATED() return an B&lt;ASN1_INTEGER&gt; or
+B&lt;ASN1_ENUMERATED&gt; structure respectively or NULL if an error occurs. They will
+only fail due to a memory allocation error.
+
+ASN1_INTEGER_to_BN() and ASN1_ENUMERATED_to_BN() return a B&lt;BIGNUM&gt; structure
+of NULL if an error occurs. They can fail if the pased type is incorrect
+(due to programming error) or due to a memory allocation failure.
+
+=head1 SEE ALSO
+
+L&lt;ERR_get_error(3)|ERR_get_error(3)&gt;
+
+=head1 HISTORY
+
+ASN1_INTEGER_set_int64(), ASN1_INTEGER_get_int64(),
+ASN1_ENUMERATED_set_int64() and ASN1_ENUMERATED_get_int64()
+were added to OpenSSL 1.1.0.
+
+=cut
diff --git a/include/openssl/asn1.h b/include/openssl/asn1.h
index b1bcef7..26d31b7 100644
--- a/include/openssl/asn1.h
+++ b/include/openssl/asn1.h
@@ -677,15 +677,21 @@ int a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num);
 ASN1_OBJECT *ASN1_OBJECT_create(int nid, unsigned char *data, int len,
                                 const char *sn, const char *ln);
 
+int ASN1_INTEGER_get_int64(int64_t *pr, const ASN1_INTEGER *a);
+int ASN1_INTEGER_set_int64(ASN1_INTEGER *a, int64_t r);
 int ASN1_INTEGER_set(ASN1_INTEGER *a, long v);
 long ASN1_INTEGER_get(const ASN1_INTEGER *a);
 ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai);
 BIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn);
 
+int ASN1_ENUMERATED_get_int64(int64_t *pr, const ASN1_ENUMERATED *a);
+int ASN1_ENUMERATED_set_int64(ASN1_ENUMERATED *a, int64_t r);
+
+
 int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v);
 long ASN1_ENUMERATED_get(ASN1_ENUMERATED *a);
-ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai);
-BIGNUM *ASN1_ENUMERATED_to_BN(ASN1_ENUMERATED *ai, BIGNUM *bn);
+ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(const BIGNUM *bn, ASN1_ENUMERATED *ai);
+BIGNUM *ASN1_ENUMERATED_to_BN(const ASN1_ENUMERATED *ai, BIGNUM *bn);
 
 /* General */
 /* given a string, return the correct type, max is the maximum length */
@@ -930,7 +936,9 @@ void ERR_load_ASN1_strings(void);
 # define ASN1_F_ASN1_GENERALIZEDTIME_ADJ                  216
 # define ASN1_F_ASN1_GENERALIZEDTIME_SET                  185
 # define ASN1_F_ASN1_GENERATE_V3                          178
+# define ASN1_F_ASN1_GET_INT64                            224
 # define ASN1_F_ASN1_GET_OBJECT                           114
+# define ASN1_F_ASN1_GET_UINT64                           225
 # define ASN1_F_ASN1_HEADER_NEW                           115
 # define ASN1_F_ASN1_I2D_BIO                              116
 # define ASN1_F_ASN1_I2D_FP                               117
@@ -938,8 +946,8 @@ void ERR_load_ASN1_strings(void);
 # define ASN1_F_ASN1_INTEGER_TO_BN                        119
 # define ASN1_F_ASN1_ITEM_D2I_FP                          206
 # define ASN1_F_ASN1_ITEM_DUP                             191
-# define ASN1_F_ASN1_ITEM_EX_NEW                          121
 # define ASN1_F_ASN1_ITEM_EX_D2I                          120
+# define ASN1_F_ASN1_ITEM_EX_NEW                          121
 # define ASN1_F_ASN1_ITEM_I2D_BIO                         192
 # define ASN1_F_ASN1_ITEM_I2D_FP                          193
 # define ASN1_F_ASN1_ITEM_PACK                            198
@@ -958,8 +966,10 @@ void ERR_load_ASN1_strings(void);
 # define ASN1_F_ASN1_SEQ_UNPACK                           127
 # define ASN1_F_ASN1_SIGN                                 128
 # define ASN1_F_ASN1_STR2TYPE                             179
+# define ASN1_F_ASN1_STRING_GET_INT64                     227
 # define ASN1_F_ASN1_STRING_SET                           186
 # define ASN1_F_ASN1_STRING_TABLE_ADD                     129
+# define ASN1_F_ASN1_STRING_TO_BN                         228
 # define ASN1_F_ASN1_STRING_TYPE_NEW                      130
 # define ASN1_F_ASN1_TEMPLATE_EX_D2I                      132
 # define ASN1_F_ASN1_TEMPLATE_NEW                         133
@@ -978,9 +988,11 @@ void ERR_load_ASN1_strings(void);
 # define ASN1_F_BITSTR_CB                                 180
 # define ASN1_F_BN_TO_ASN1_ENUMERATED                     138
 # define ASN1_F_BN_TO_ASN1_INTEGER                        139
+# define ASN1_F_BN_TO_ASN1_STRING                         229
 # define ASN1_F_C2I_ASN1_BIT_STRING                       189
 # define ASN1_F_C2I_ASN1_INTEGER                          194
 # define ASN1_F_C2I_ASN1_OBJECT                           196
+# define ASN1_F_C2I_IBUF                                  226
 # define ASN1_F_COLLECT_DATA                              140
 # define ASN1_F_D2I_ASN1_BIT_STRING                       141
 # define ASN1_F_D2I_ASN1_BOOLEAN                          142
@@ -1079,8 +1091,10 @@ void ERR_load_ASN1_strings(void);
 # define ASN1_R_ILLEGAL_OBJECT                            183
 # define ASN1_R_ILLEGAL_OPTIONAL_ANY                      126
 # define ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE          170
+# define ASN1_R_ILLEGAL_PADDING                           221
 # define ASN1_R_ILLEGAL_TAGGED_ANY                        127
 # define ASN1_R_ILLEGAL_TIME_VALUE                        184
+# define ASN1_R_ILLEGAL_ZERO_CONTENT                      222
 # define ASN1_R_INTEGER_NOT_ASCII_FORMAT                  185
 # define ASN1_R_INTEGER_TOO_LARGE_FOR_LONG                128
 # define ASN1_R_INVALID_BIT_STRING_BITS_LEFT              220
@@ -1133,7 +1147,9 @@ void ERR_load_ASN1_strings(void);
 # define ASN1_R_TAG_VALUE_TOO_HIGH                        153
 # define ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD 154
 # define ASN1_R_TIME_NOT_ASCII_FORMAT                     193
+# define ASN1_R_TOO_LARGE                                 223
 # define ASN1_R_TOO_LONG                                  155
+# define ASN1_R_TOO_SMALL                                 224
 # define ASN1_R_TYPE_NOT_CONSTRUCTED                      156
 # define ASN1_R_TYPE_NOT_PRIMITIVE                        195
 # define ASN1_R_UNABLE_TO_DECODE_RSA_KEY                  157
@@ -1151,6 +1167,7 @@ void ERR_load_ASN1_strings(void);
 # define ASN1_R_UNSUPPORTED_ENCRYPTION_ALGORITHM          166
 # define ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE               167
 # define ASN1_R_UNSUPPORTED_TYPE                          196
+# define ASN1_R_WRONG_INTEGER_TYPE                        225
 # define ASN1_R_WRONG_PUBLIC_KEY_TYPE                     200
 # define ASN1_R_WRONG_TAG                                 168
 # define ASN1_R_WRONG_TYPE                                169
diff --git a/util/indent.pro b/util/indent.pro
index 5a6d452..2a51225 100644
--- a/util/indent.pro
+++ b/util/indent.pro
@@ -717,3 +717,11 @@
 -T tls12_lookup
 -T OPTIONS
 -T OPT_PAIR
+-T uint64_t
+-T int64_t
+-T uint32_t
+-T int32_t
+-T uint16_t
+-T int16_t
+-T uint8_t
+-T int8_t
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001105.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="001107.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1106">[ date ]</a>
              <a href="thread.html#1106">[ thread ]</a>
              <a href="subject.html#1106">[ subject ]</a>
              <a href="author.html#1106">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
