<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  OpenSSL-fips-2_0-dev update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2015-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20OpenSSL-fips-2_0-dev%20update&In-Reply-To=%3C1431533150.528693.4972.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001075.html">
   <LINK REL="Next"  HREF="001114.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  OpenSSL-fips-2_0-dev update</H1>
    <B>Andy Polyakov</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20OpenSSL-fips-2_0-dev%20update&In-Reply-To=%3C1431533150.528693.4972.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  OpenSSL-fips-2_0-dev update">appro at openssl.org
       </A><BR>
    <I>Wed May 13 16:05:50 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="001075.html">[openssl-commits] [openssl]  OpenSSL-fips-2_0-stable update
</A></li>
        <LI>Next message: <A HREF="001114.html">[openssl-commits] [openssl]  OpenSSL-fips-2_0-dev update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1081">[ date ]</a>
              <a href="thread.html#1081">[ thread ]</a>
              <a href="subject.html#1081">[ subject ]</a>
              <a href="author.html#1081">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch OpenSSL-fips-2_0-dev has been updated
       via  8a09500d9cc1bafcbafb4d18c1bf2238bf354171 (commit)
       via  0ae16722876a9e424a1abc2c5285268476d99c35 (commit)
       via  292c1f34ec27f95fdc3c9dfa5c2df93dde7861e0 (commit)
       via  f447329da7bf1e95691c8019af3e846002ba554d (commit)
       via  80b1e89bbc901a8f4a5e11945e367e0e0def11ec (commit)
       via  bb98f6bef66dc423a3736cc9c5e5602933f58c64 (commit)
       via  728b53058ee6f89fa95c0ed3feaa410a85db7323 (commit)
       via  3b3114770a2ab3df863701b2b8518b5c01fa0cae (commit)
       via  9b5db104eca33372b3acb7c7029c211c16b68b5e (commit)
      from  788715cecf22fac32fa87b812609b6e1ad227a3a (commit)


- Log -----------------------------------------------------------------
commit 8a09500d9cc1bafcbafb4d18c1bf2238bf354171
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon May 11 12:16:01 2015 +0200

    util/incore update that allows FINGERPRINT_premain-free build.
    
    As for complementary fips.c modification. Goal is to ensure that
    FIPS_signature does not end up in .bss segment, one guaranteed to
    be zeroed upon program start-up. One would expect explicitly
    initialized values to end up in .data segment, but it turned out
    that values explicitly initialized with zeros can end up in .bss.
    The modification does not affect program flow, because first byte
    was the only one of significance [to FINGERPRINT_premain].
    
    Reviewed-by: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (cherry picked from commit 34f39b062c76fbd3082521b26edee7f53afc061d)

commit 0ae16722876a9e424a1abc2c5285268476d99c35
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon May 11 12:04:12 2015 +0200

    Add support for Android 5, both 32- and 64-bit cases.
    
    Special note about additional -pie flag in android-armv7. The initial
    reason for adding it is that Android 5 refuses to execute non-PIE
    binaries. But what about older systems and previously validated
    platforms? It should be noted that flag is not used when compiling
    object code, fipscanister.o in this context, only when linking
    applications, *supplementary* fips_algvs used during validation
    procedure.
    
    Reviewed-by: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (cherry picked from commit 6db8e3bdc9ef83d83b83f3eec9722c96daa91f82)
    
    Resolved conflicts:
    	test/fips_algvs.c

commit 292c1f34ec27f95fdc3c9dfa5c2df93dde7861e0
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon May 11 11:56:30 2015 +0200

    Additional vxWorks target.
    
    Reviewed-by: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (cherry picked from commit 50e2a0ea4615124aa159e8f43317dedcf0cfcaa2)

commit f447329da7bf1e95691c8019af3e846002ba554d
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon May 11 11:53:41 2015 +0200

    Configure: add ios-cross target with ARM assembly support.
    
    Reviewed-by: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (cherry picked from commit 97fbb0c88c2f601f98e25e57b9f6f9679d14f3a8)
    
    Resolved conflicts:
    	Configure
    	config

commit 80b1e89bbc901a8f4a5e11945e367e0e0def11ec
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon May 11 11:50:29 2015 +0200

    Add iOS-specific armv4cpud.S module.
    
    Normally it would be generated from a perlasm module, but doing so
    would affect existing armv4cpuid.S, which in turn would formally void
    previously validated platforms. Hense separate module is generated.
    
    Reviewed-by: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (cherry picked from commit 5837e90f08ffcf5ad84933793bc285630018ce26)

commit bb98f6bef66dc423a3736cc9c5e5602933f58c64
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon May 11 11:43:55 2015 +0200

    Adapt ARM assembly pack for iOS.
    
    This is achieved by filtering perlasm output through arm-xlate.pl. But note
    that it's done only if &quot;flavour&quot; argument is not 'void'. As 'void' is
    default value for other ARM targets, permasm output is not actually
    filtered on previously validated platforms.
    
    Reviewed-by: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (cherry picked from commit 874faf2ffb22187ad5483d9691a3a2eb7112f161)

commit 728b53058ee6f89fa95c0ed3feaa410a85db7323
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon May 11 11:36:48 2015 +0200

    Configure: engage ARMv8 assembly pack in ios64-cross target.
    
    Reviewed-by: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (cherry picked from commit c6d109051d1c2b9a453427a2a53ad3d40acc9276)
    
    Resolved Conflicts:
    	Configure

commit 3b3114770a2ab3df863701b2b8518b5c01fa0cae
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon May 11 11:34:56 2015 +0200

    Engage ARMv8 assembly pack.
    
    Reviewed-by: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (cherry picked from commit 083ed53defb42ab4d3488bc7f80d9170d22293e7)

commit 9b5db104eca33372b3acb7c7029c211c16b68b5e
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon May 11 11:18:04 2015 +0200

    Add ARMv8 assembly pack.
    
    Reviewed-by: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (cherry picked from commit b84813ec017cb03b8dd0b85bce2bb3e021c45685)

-----------------------------------------------------------------------

Summary of changes:
 Configure                          |  12 +-
 config                             |  10 +-
 crypto/Makefile                    |   1 +
 crypto/aes/Makefile                |   4 +
 crypto/aes/asm/aes-armv4.pl        |  31 +-
 crypto/aes/asm/aesv8-armx.pl       | 968 +++++++++++++++++++++++++++++++++++++
 crypto/arm64cpuid.pl               |  68 +++
 crypto/arm_arch.h                  |  17 +-
 crypto/armcap.c                    |  26 +
 crypto/armv4cpuid_ios.S            | 210 ++++++++
 crypto/bn/asm/armv4-gf2m.pl        |  23 +-
 crypto/bn/asm/armv4-mont.pl        |  16 +-
 crypto/evp/e_aes.c                 | 113 +++++
 crypto/modes/Makefile              |   3 +
 crypto/modes/asm/ghash-armv4.pl    |  33 +-
 crypto/modes/asm/ghashv8-armx.pl   | 376 ++++++++++++++
 crypto/modes/gcm128.c              |  27 +-
 crypto/perlasm/arm-xlate.pl        | 165 +++++++
 crypto/sha/Makefile                |   3 +
 crypto/sha/asm/sha1-armv4-large.pl |  16 +-
 crypto/sha/asm/sha1-armv8.pl       | 343 +++++++++++++
 crypto/sha/asm/sha256-armv4.pl     |  16 +-
 crypto/sha/asm/sha512-armv4.pl     |  22 +-
 crypto/sha/asm/sha512-armv8.pl     | 428 ++++++++++++++++
 fips/fips.c                        |   2 +-
 fips/fips_canister.c               |   1 +
 fips/fips_test_suite.c             |   6 +
 fips/fipssyms.h                    |  44 ++
 test/fips_algvs.c                  |  71 +++
 util/incore                        |   7 +-
 30 files changed, 3027 insertions(+), 35 deletions(-)
 create mode 100644 crypto/aes/asm/aesv8-armx.pl
 create mode 100644 crypto/arm64cpuid.pl
 create mode 100644 crypto/armv4cpuid_ios.S
 create mode 100644 crypto/modes/asm/ghashv8-armx.pl
 create mode 100644 crypto/perlasm/arm-xlate.pl
 create mode 100644 crypto/sha/asm/sha1-armv8.pl
 create mode 100644 crypto/sha/asm/sha512-armv8.pl

diff --git a/Configure b/Configure
index 34856e2..6bb8f10 100755
--- a/Configure
+++ b/Configure
@@ -136,6 +136,7 @@ my $mips32_asm=&quot;:bn-mips.o::aes_cbc.o aes-mips.o:::sha1-mips.o sha256-mips.o::::
 my $mips64_asm=&quot;:bn-mips.o mips-mont.o::aes_cbc.o aes-mips.o:::sha1-mips.o sha256-mips.o sha512-mips.o::::::::&quot;;
 my $s390x_asm=&quot;s390xcap.o s390xcpuid.o:bn-s390x.o s390x-mont.o s390x-gf2m.o::aes_ctr.o aes-s390x.o:::sha1-s390x.o sha256-s390x.o sha512-s390x.o::rc4-s390x.o:::::ghash-s390x.o:&quot;;
 my $armv4_asm=&quot;armcap.o armv4cpuid.o:bn_asm.o armv4-mont.o armv4-gf2m.o::aes_cbc.o aes-armv4.o:::sha1-armv4-large.o sha256-armv4.o sha512-armv4.o:::::::ghash-armv4.o::void&quot;;
+my $aarch64_asm=&quot;armcap.o arm64cpuid.o mem_clr.o:::aes_core.o aes_cbc.o aesv8-armx.o:::sha1-armv8.o sha256-armv8.o sha512-armv8.o:::::::ghashv8-armx.o:&quot;;
 my $parisc11_asm=&quot;pariscid.o:bn_asm.o parisc-mont.o::aes_core.o aes_cbc.o aes-parisc.o:::sha1-parisc.o sha256-parisc.o sha512-parisc.o::rc4-parisc.o:::::ghash-parisc.o::32&quot;;
 my $parisc20_asm=&quot;pariscid.o:pa-risc2W.o parisc-mont.o::aes_core.o aes_cbc.o aes-parisc.o:::sha1-parisc.o sha256-parisc.o sha512-parisc.o::rc4-parisc.o:::::ghash-parisc.o::64&quot;;
 my $ppc32_asm=&quot;ppccpuid.o ppccap.o:bn-ppc.o ppc-mont.o ppc64-mont.o::aes_core.o aes_cbc.o aes-ppc.o:::sha1-ppc.o sha256-ppc.o::::::::&quot;;
@@ -401,7 +402,8 @@ my %table=(
 # Android: linux-* but without -DTERMIO and pointers to headers and libs.
 &quot;android&quot;,&quot;gcc:-mandroid -I\$(ANDROID_DEV)/include -B\$(ANDROID_DEV)/lib -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)&quot;,
 &quot;android-x86&quot;,&quot;gcc:-mandroid -I\$(ANDROID_DEV)/include -B\$(ANDROID_DEV)/lib -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:&quot;.eval{my $asm=${x86_elf_asm};$asm=~s/:elf/:android/;$asm}.&quot;:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)&quot;,
-&quot;android-armv7&quot;,&quot;gcc:-march=armv7-a -mandroid -I\$(ANDROID_DEV)/include -B\$(ANDROID_DEV)/lib -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${armv4_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)&quot;,
+&quot;android-armv7&quot;,&quot;gcc:-march=armv7-a -mandroid -I\$(ANDROID_DEV)/include -B\$(ANDROID_DEV)/lib -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-pie%-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${armv4_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)&quot;,
+&quot;android64-aarch64&quot;,&quot;gcc:-mandroid -fPIC -I\$(ANDROID_DEV)/include -B\$(ANDROID_DEV)/lib -O3 -Wall::-D_REENTRANT::-pie%-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${aarch64_asm}:linux64:dlfcn:linux-shared:::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)&quot;,
 
 #### *BSD [do see comment about ${BSDthreads} above!]
 &quot;BSD-generic32&quot;,&quot;gcc:-DTERMIOS -O3 -fomit-frame-pointer -Wall::${BSDthreads}:::BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)&quot;,
@@ -596,7 +598,8 @@ my %table=(
 # CROSS_SDK=iPhoneOS7.0.sdk
 #
 &quot;iphoneos-cross&quot;,&quot;cc:-O3 -isysroot \$(CROSS_TOP)/SDKs/\$(CROSS_SDK) -fomit-frame-pointer -fno-common::-D_REENTRANT:iOS:-Wl,-search_paths_first%:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${no_asm}:dlfcn:darwin-shared:-fPIC -fno-common:-dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib&quot;,
-&quot;ios64-cross&quot;,&quot;cc:-O3 -arch arm64 -mios-version-min=7.0.0 -isysroot \$(CROSS_TOP)/SDKs/\$(CROSS_SDK) -fno-common::-D_REENTRANT:iOS:-Wl,-search_paths_first%:SIXTY_FOUR_BIT_LONG RC4_CHAR -RC4_CHUNK DES_INT DES_UNROLL -BF_PTR:${no_asm}:dlfcn:darwin-shared:-fPIC -fno-common:-dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib&quot;,
+&quot;ios-cross&quot;,&quot;cc:-O3 -arch armv7 -mios-version-min=7.0.0 -isysroot \$(CROSS_TOP)/SDKs/\$(CROSS_SDK) -fno-common::-D_REENTRANT:iOS:-Wl,-search_paths_first%:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:armcap.o armv4cpuid_ios.o:bn_asm.o armv4-mont.o armv4-gf2m.o::aes_cbc.o aes-armv4.o:::sha1-armv4-large.o sha256-armv4.o sha512-armv4.o:::::::ghash-armv4.o::ios32:dlfcn:darwin-shared:-fPIC -fno-common:-dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib&quot;,
+&quot;ios64-cross&quot;,&quot;cc:-O3 -arch arm64 -mios-version-min=7.0.0 -isysroot \$(CROSS_TOP)/SDKs/\$(CROSS_SDK) -fno-common::-D_REENTRANT:iOS:-Wl,-search_paths_first%:SIXTY_FOUR_BIT_LONG RC4_CHAR -RC4_CHUNK DES_INT DES_UNROLL -BF_PTR:${aarch64_asm}:ios64:dlfcn:darwin-shared:-fPIC -fno-common:-dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib&quot;,
 
 ##### A/UX
 &quot;aux3-gcc&quot;,&quot;gcc:-O2 -DTERMIO::(unknown):AUX:-lbsd:RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:::&quot;,
@@ -613,6 +616,7 @@ my %table=(
 ##### VxWorks for various targets
 &quot;vxworks-ppc60x&quot;,&quot;ccppc:-D_REENTRANT -mrtp -mhard-float -mstrict-align -fno-implicit-fp -DPPC32_fp60x -O2 -fstrength-reduce -fno-builtin -fno-strict-aliasing -Wall -DCPU=PPC32 -DTOOL_FAMILY=gnu -DTOOL=gnu -I\$(WIND_BASE)/target/usr/h -I\$(WIND_BASE)/target/usr/h/wrn/coreip:::VXWORKS:-Wl,--defsym,__wrs_rtp_base=0xe0000000 -L \$(WIND_BASE)/target/usr/lib/ppc/PPC32/common:::::&quot;,
 &quot;vxworks-ppcgen&quot;,&quot;ccppc:-D_REENTRANT -mrtp -msoft-float -mstrict-align -O1 -fno-builtin -fno-strict-aliasing -Wall -DCPU=PPC32 -DTOOL_FAMILY=gnu -DTOOL=gnu -I\$(WIND_BASE)/target/usr/h -I\$(WIND_BASE)/target/usr/h/wrn/coreip:::VXWORKS:-Wl,--defsym,__wrs_rtp_base=0xe0000000 -L \$(WIND_BASE)/target/usr/lib/ppc/PPC32/sfcommon:::::&quot;,
+&quot;vxworks-ppcgen-kernel&quot;,&quot;ccppc:-D_REENTRANT -msoft-float -mstrict-align -O1 -fno-builtin -fno-strict-aliasing -Wall -DCPU=PPC32 -DTOOL_FAMILY=gnu -DTOOL=gnu -I\$(WIND_BASE)/target/h -I\$(WIND_BASE)/target/h/wrn/coreip:::VXWORKS::::::&quot;,
 &quot;vxworks-ppc405&quot;,&quot;ccppc:-g -msoft-float -mlongcall -DCPU=PPC405 -I\$(WIND_BASE)/target/h:::VXWORKS:-r:::::&quot;,
 &quot;vxworks-ppc750&quot;,&quot;ccppc:-ansi -nostdinc -DPPC750 -D_REENTRANT -fvolatile -fno-builtin -fno-for-scope -fsigned-char -Wall -msoft-float -mlongcall -DCPU=PPC604 -I\$(WIND_BASE)/target/h \$(DEBUG_FLAG):::VXWORKS:-r:::::&quot;,
 &quot;vxworks-ppc750-debug&quot;,&quot;ccppc:-ansi -nostdinc -DPPC750 -D_REENTRANT -fvolatile -fno-builtin -fno-for-scope -fsigned-char -Wall -msoft-float -mlongcall -DCPU=PPC604 -I\$(WIND_BASE)/target/h -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DPEDANTIC -DDEBUG_SAFESTACK -DDEBUG -g:::VXWORKS:-r:::::&quot;,
@@ -1575,7 +1579,7 @@ if ($rmd160_obj =~ /\.o$/)
 	}
 if ($aes_obj =~ /\.o$/)
 	{
-	$cflags.=&quot; -DAES_ASM&quot;;
+	 $cflags.=&quot; -DAES_ASM&quot; if ($aes_obj =~ m/\baes\-/);
 	# aes_ctr.o is not a real file, only indication that assembler
 	# module implements AES_ctr32_encrypt...
 	$cflags.=&quot; -DAES_CTR_ASM&quot; if ($aes_obj =~ s/\s*aes_ctr\.o//);
@@ -1596,7 +1600,7 @@ else	{
 	$wp_obj=&quot;wp_block.o&quot;;
 	}
 $cmll_obj=$cmll_enc	unless ($cmll_obj =~ /.o$/);
-if ($modes_obj =~ /ghash/)
+if ($modes_obj =~ /ghash\-/)
 	{
 	$cflags.=&quot; -DGHASH_ASM&quot;;
 	}
diff --git a/config b/config
index fc78a30..4003e2f 100755
--- a/config
+++ b/config
@@ -375,6 +375,10 @@ case &quot;${SYSTEM}:${RELEASE}:${VERSION}:${MACHINE}&quot; in
        echo &quot;nsr-tandem-nsk&quot;; exit 0;
        ;;
 
+    vxworks:kernel*)
+       echo &quot;${MACHINE}-kernel-vxworks&quot;; exit 0;
+       ;;
+
     vxworks*)
        echo &quot;${MACHINE}-whatever-vxworks&quot;; exit 0;
        ;;
@@ -576,7 +580,9 @@ case &quot;$GUESSOS&quot; in
   *-*-iphoneos)
 	options=&quot;$options -arch%20${MACHINE}&quot;
 	OUT=&quot;iphoneos-cross&quot; ;;
-  arm64-*-iphoneos|*-*-ios64)
+  armv7-*-ios)
+	OUT=&quot;ios-cross&quot; ;;
+  arm64-*-ios*)
 	OUT=&quot;ios64-cross&quot; ;;
   alpha-*-linux2)
         ISA=`awk '/cpu model/{print$4;exit(0);}' /proc/cpuinfo`
@@ -603,6 +609,7 @@ case &quot;$GUESSOS&quot; in
 	;;
   ppc-*-linux2) OUT=&quot;linux-ppc&quot; ;;
   ppc60x-*-vxworks*) OUT=&quot;vxworks-ppc60x&quot; ;;
+  ppcgen-kernel-vxworks*) OUT=&quot;vxworks-ppcgen-kernel&quot; ;;
   ppcgen-*-vxworks*) OUT=&quot;vxworks-ppcgen&quot; ;;
   pentium-*-vxworks*) OUT=&quot;vxworks-pentium&quot; ;;
   simlinux-*-vxworks*) OUT=&quot;vxworks-simlinux&quot; ;;
@@ -854,6 +861,7 @@ case &quot;$GUESSOS&quot; in
   *-*-qnx6) OUT=&quot;QNX6&quot; ;;
   x86-*-android|i?86-*-android) OUT=&quot;android-x86&quot; ;;
   armv[7-9]*-*-android) OUT=&quot;android-armv7&quot; ;;
+  aarch64-*-android) OUT=&quot;android64-aarch64&quot; ;;
   *) OUT=`echo $GUESSOS | awk -F- '{print $3}'`;;
 esac
 
diff --git a/crypto/Makefile b/crypto/Makefile
index 22cb2a5..7304684 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -87,6 +87,7 @@ ppccpuid.s:	ppccpuid.pl;	$(PERL) ppccpuid.pl $(PERLASM_SCHEME) $@
 pariscid.s:	pariscid.pl;	$(PERL) pariscid.pl $(PERLASM_SCHEME) $@
 alphacpuid.s:	alphacpuid.pl
 	$(PERL) $&lt; | $(CC) -E - | tee $@ &gt; /dev/null
+arm64cpuid.S:	arm64cpuid.pl;	$(PERL) arm64cpuid.pl $(PERLASM_SCHEME) &gt; $@
 
 subdirs:
 	@target=all; $(RECURSIVE_MAKE)
diff --git a/crypto/aes/Makefile b/crypto/aes/Makefile
index 8edd358..1d9e82a 100644
--- a/crypto/aes/Makefile
+++ b/crypto/aes/Makefile
@@ -78,6 +78,10 @@ aes-parisc.s:	asm/aes-parisc.pl
 aes-mips.S:	asm/aes-mips.pl
 	$(PERL) asm/aes-mips.pl $(PERLASM_SCHEME) $@
 
+aesv8-armx.S:	asm/aesv8-armx.pl
+	$(PERL) asm/aesv8-armx.pl $(PERLASM_SCHEME) $@
+aesv8-armx.o:	aesv8-armx.S
+
 # GNU make &quot;catch all&quot;
 aes-%.S:	asm/aes-%.pl;	$(PERL) $&lt; $(PERLASM_SCHEME) $@
 aes-armv4.o:	aes-armv4.S
diff --git a/crypto/aes/asm/aes-armv4.pl b/crypto/aes/asm/aes-armv4.pl
index 55b6e04..ed51258 100644
--- a/crypto/aes/asm/aes-armv4.pl
+++ b/crypto/aes/asm/aes-armv4.pl
@@ -32,8 +32,20 @@
 # Profiler-assisted and platform-specific optimization resulted in 16%
 # improvement on Cortex A8 core and ~21.5 cycles per byte.
 
-while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {}
-open STDOUT,&quot;&gt;$output&quot;;
+$flavour = shift;
+if ($flavour=~/^\w[\w\-]*\.\w+$/) { $output=$flavour; undef $flavour; }
+else { while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {} }
+
+if ($flavour &amp;&amp; $flavour ne &quot;void&quot;) {
+    $0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+    ( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+    ( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+    die &quot;can't locate arm-xlate.pl&quot;;
+
+    open STDOUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+} else {
+    open STDOUT,&quot;&gt;$output&quot;;
+}
 
 $s0=&quot;r0&quot;;
 $s1=&quot;r1&quot;;
@@ -171,7 +183,12 @@ AES_encrypt:
 	stmdb   sp!,{r1,r4-r12,lr}
 	mov	$rounds,r0		@ inp
 	mov	$key,r2
+#ifdef	__APPLE__
+	mov	$tbl,#AES_encrypt-AES_Te
+	sub	$tbl,r3,$tbl			@ Te
+#else
 	sub	$tbl,r3,#AES_encrypt-AES_Te	@ Te
+#endif
 #if __ARM_ARCH__&lt;7
 	ldrb	$s0,[$rounds,#3]	@ load input data in endian-neutral
 	ldrb	$t1,[$rounds,#2]	@ manner...
@@ -425,7 +442,12 @@ AES_set_encrypt_key:
 	bne	.Labrt
 
 .Lok:	stmdb   sp!,{r4-r12,lr}
+#ifdef	__APPLE__
+	mov	$tbl,#AES_set_encrypt_key-AES_Te-1024
+	sub	$tbl,r3,$tbl					@ Te4
+#else
 	sub	$tbl,r3,#AES_set_encrypt_key-AES_Te-1024	@ Te4
+#endif
 
 	mov	$rounds,r0		@ inp
 	mov	lr,r1			@ bits
@@ -886,7 +908,12 @@ AES_decrypt:
 	stmdb   sp!,{r1,r4-r12,lr}
 	mov	$rounds,r0		@ inp
 	mov	$key,r2
+#ifdef	__APPLE__
+	mov	$tbl,#AES_decrypt-AES_Td
+	sub	$tbl,r3,$tbl				@ Td
+#else
 	sub	$tbl,r3,#AES_decrypt-AES_Td		@ Td
+#endif
 #if __ARM_ARCH__&lt;7
 	ldrb	$s0,[$rounds,#3]	@ load input data in endian-neutral
 	ldrb	$t1,[$rounds,#2]	@ manner...
diff --git a/crypto/aes/asm/aesv8-armx.pl b/crypto/aes/asm/aesv8-armx.pl
new file mode 100644
index 0000000..104f417
--- /dev/null
+++ b/crypto/aes/asm/aesv8-armx.pl
@@ -0,0 +1,968 @@
+#!/usr/bin/env perl
+#
+# ====================================================================
+# Written by Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt; for the OpenSSL
+# project. The module is, however, dual licensed under OpenSSL and
+# CRYPTOGAMS licenses depending on where you obtain it. For further
+# details see <A HREF="http://www.openssl.org/~appro/cryptogams/.">http://www.openssl.org/~appro/cryptogams/.</A>
+# ====================================================================
+#
+# This module implements support for ARMv8 AES instructions. The
+# module is endian-agnostic in sense that it supports both big- and
+# little-endian cases. As does it support both 32- and 64-bit modes
+# of operation. Latter is achieved by limiting amount of utilized
+# registers to 16, which implies additional NEON load and integer
+# instructions. This has no effect on mighty Apple A7, where results
+# are literally equal to the theoretical estimates based on AES
+# instruction latencies and issue rates. On Cortex-A53, an in-order
+# execution core, this costs up to 10-15%, which is partially
+# compensated by implementing dedicated code path for 128-bit
+# CBC encrypt case. On Cortex-A57 parallelizable mode performance
+# seems to be limited by sheer amount of NEON instructions...
+#
+# Performance in cycles per byte processed with 128-bit key:
+#
+#		CBC enc		CBC dec		CTR
+# Apple A7	2.39		1.20		1.20
+# Cortex-A53	2.45		1.87		1.94
+# Cortex-A57	3.64		1.34		1.32
+
+$flavour = shift;
+$output  = shift;
+
+$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+die &quot;can't locate arm-xlate.pl&quot;;
+
+open OUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+*STDOUT=*OUT;
+
+$prefix=&quot;aes_v8&quot;;
+
+$code=&lt;&lt;___;
+#include &quot;arm_arch.h&quot;
+
+#if __ARM_ARCH__&gt;=7
+.text
+___
+$code.=&quot;.arch	armv8-a+crypto\n&quot;	if ($flavour =~ /64/);
+$code.=&quot;.fpu	neon\n.code	32\n&quot;	if ($flavour !~ /64/);
+
+# Assembler mnemonics are an eclectic mix of 32- and 64-bit syntax,
+# NEON is mostly 32-bit mnemonics, integer - mostly 64. Goal is to
+# maintain both 32- and 64-bit codes within single module and
+# transliterate common code to either flavour with regex vodoo.
+#
+{{{
+my ($inp,$bits,$out,$ptr,$rounds)=(&quot;x0&quot;,&quot;w1&quot;,&quot;x2&quot;,&quot;x3&quot;,&quot;w12&quot;);
+my ($zero,$rcon,$mask,$in0,$in1,$tmp,$key)=
+	$flavour=~/64/? map(&quot;q$_&quot;,(0..6)) : map(&quot;q$_&quot;,(0..3,8..10));
+
+
+$code.=&lt;&lt;___;
+.align	5
+.Lrcon:
+.long	0x01,0x01,0x01,0x01
+.long	0x0c0f0e0d,0x0c0f0e0d,0x0c0f0e0d,0x0c0f0e0d	// rotate-n-splat
+.long	0x1b,0x1b,0x1b,0x1b
+
+.globl	${prefix}_set_encrypt_key
+.type	${prefix}_set_encrypt_key,%function
+.align	5
+${prefix}_set_encrypt_key:
+.Lenc_key:
+___
+$code.=&lt;&lt;___	if ($flavour =~ /64/);
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+___
+$code.=&lt;&lt;___;
+	mov	$ptr,#-1
+	cmp	$inp,#0
+	b.eq	.Lenc_key_abort
+	cmp	$out,#0
+	b.eq	.Lenc_key_abort
+	mov	$ptr,#-2
+	cmp	$bits,#128
+	b.lt	.Lenc_key_abort
+	cmp	$bits,#256
+	b.gt	.Lenc_key_abort
+	tst	$bits,#0x3f
+	b.ne	.Lenc_key_abort
+
+	adr	$ptr,.Lrcon
+	cmp	$bits,#192
+
+	veor	$zero,$zero,$zero
+	vld1.8	{$in0},[$inp],#16
+	mov	$bits,#8		// reuse $bits
+	vld1.32	{$rcon,$mask},[$ptr],#32
+
+	b.lt	.Loop128
+	b.eq	.L192
+	b	.L256
+
+.align	4
+.Loop128:
+	vtbl.8	$key,{$in0},$mask
+	vext.8	$tmp,$zero,$in0,#12
+	vst1.32	{$in0},[$out],#16
+	aese	$key,$zero
+	subs	$bits,$bits,#1
+
+	veor	$in0,$in0,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	veor	$in0,$in0,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	 veor	$key,$key,$rcon
+	veor	$in0,$in0,$tmp
+	vshl.u8	$rcon,$rcon,#1
+	veor	$in0,$in0,$key
+	b.ne	.Loop128
+
+	vld1.32	{$rcon},[$ptr]
+
+	vtbl.8	$key,{$in0},$mask
+	vext.8	$tmp,$zero,$in0,#12
+	vst1.32	{$in0},[$out],#16
+	aese	$key,$zero
+
+	veor	$in0,$in0,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	veor	$in0,$in0,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	 veor	$key,$key,$rcon
+	veor	$in0,$in0,$tmp
+	vshl.u8	$rcon,$rcon,#1
+	veor	$in0,$in0,$key
+
+	vtbl.8	$key,{$in0},$mask
+	vext.8	$tmp,$zero,$in0,#12
+	vst1.32	{$in0},[$out],#16
+	aese	$key,$zero
+
+	veor	$in0,$in0,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	veor	$in0,$in0,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	 veor	$key,$key,$rcon
+	veor	$in0,$in0,$tmp
+	veor	$in0,$in0,$key
+	vst1.32	{$in0},[$out]
+	add	$out,$out,#0x50
+
+	mov	$rounds,#10
+	b	.Ldone
+
+.align	4
+.L192:
+	vld1.8	{$in1},[$inp],#8
+	vmov.i8	$key,#8			// borrow $key
+	vst1.32	{$in0},[$out],#16
+	vsub.i8	$mask,$mask,$key	// adjust the mask
+
+.Loop192:
+	vtbl.8	$key,{$in1},$mask
+	vext.8	$tmp,$zero,$in0,#12
+	vst1.32	{$in1},[$out],#8
+	aese	$key,$zero
+	subs	$bits,$bits,#1
+
+	veor	$in0,$in0,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	veor	$in0,$in0,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	veor	$in0,$in0,$tmp
+
+	vdup.32	$tmp,${in0}[3]
+	veor	$tmp,$tmp,$in1
+	 veor	$key,$key,$rcon
+	vext.8	$in1,$zero,$in1,#12
+	vshl.u8	$rcon,$rcon,#1
+	veor	$in1,$in1,$tmp
+	veor	$in0,$in0,$key
+	veor	$in1,$in1,$key
+	vst1.32	{$in0},[$out],#16
+	b.ne	.Loop192
+
+	mov	$rounds,#12
+	add	$out,$out,#0x20
+	b	.Ldone
+
+.align	4
+.L256:
+	vld1.8	{$in1},[$inp]
+	mov	$bits,#7
+	mov	$rounds,#14
+	vst1.32	{$in0},[$out],#16
+
+.Loop256:
+	vtbl.8	$key,{$in1},$mask
+	vext.8	$tmp,$zero,$in0,#12
+	vst1.32	{$in1},[$out],#16
+	aese	$key,$zero
+	subs	$bits,$bits,#1
+
+	veor	$in0,$in0,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	veor	$in0,$in0,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	 veor	$key,$key,$rcon
+	veor	$in0,$in0,$tmp
+	vshl.u8	$rcon,$rcon,#1
+	veor	$in0,$in0,$key
+	vst1.32	{$in0},[$out],#16
+	b.eq	.Ldone
+
+	vdup.32	$key,${in0}[3]		// just splat
+	vext.8	$tmp,$zero,$in1,#12
+	aese	$key,$zero
+
+	veor	$in1,$in1,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	veor	$in1,$in1,$tmp
+	vext.8	$tmp,$zero,$tmp,#12
+	veor	$in1,$in1,$tmp
+
+	veor	$in1,$in1,$key
+	b	.Loop256
+
+.Ldone:
+	str	$rounds,[$out]
+	mov	$ptr,#0
+
+.Lenc_key_abort:
+	mov	x0,$ptr			// return value
+	`&quot;ldr	x29,[sp],#16&quot;		if ($flavour =~ /64/)`
+	ret
+.size	${prefix}_set_encrypt_key,.-${prefix}_set_encrypt_key
+
+.globl	${prefix}_set_decrypt_key
+.type	${prefix}_set_decrypt_key,%function
+.align	5
+${prefix}_set_decrypt_key:
+___
+$code.=&lt;&lt;___	if ($flavour =~ /64/);
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+___
+$code.=&lt;&lt;___	if ($flavour !~ /64/);
+	stmdb	sp!,{r4,lr}
+___
+$code.=&lt;&lt;___;
+	bl	.Lenc_key
+
+	cmp	x0,#0
+	b.ne	.Ldec_key_abort
+
+	sub	$out,$out,#240		// restore original $out
+	mov	x4,#-16
+	add	$inp,$out,x12,lsl#4	// end of key schedule
+
+	vld1.32	{v0.16b},[$out]
+	vld1.32	{v1.16b},[$inp]
+	vst1.32	{v0.16b},[$inp],x4
+	vst1.32	{v1.16b},[$out],#16
+
+.Loop_imc:
+	vld1.32	{v0.16b},[$out]
+	vld1.32	{v1.16b},[$inp]
+	aesimc	v0.16b,v0.16b
+	aesimc	v1.16b,v1.16b
+	vst1.32	{v0.16b},[$inp],x4
+	vst1.32	{v1.16b},[$out],#16
+	cmp	$inp,$out
+	b.hi	.Loop_imc
+
+	vld1.32	{v0.16b},[$out]
+	aesimc	v0.16b,v0.16b
+	vst1.32	{v0.16b},[$inp]
+
+	eor	x0,x0,x0		// return value
+.Ldec_key_abort:
+___
+$code.=&lt;&lt;___	if ($flavour !~ /64/);
+	ldmia	sp!,{r4,pc}
+___
+$code.=&lt;&lt;___	if ($flavour =~ /64/);
+	ldp	x29,x30,[sp],#16
+	ret
+___
+$code.=&lt;&lt;___;
+.size	${prefix}_set_decrypt_key,.-${prefix}_set_decrypt_key
+___
+}}}
+{{{
+sub gen_block () {
+my $dir = shift;
+my ($e,$mc) = $dir eq &quot;en&quot; ? (&quot;e&quot;,&quot;mc&quot;) : (&quot;d&quot;,&quot;imc&quot;);
+my ($inp,$out,$key)=map(&quot;x$_&quot;,(0..2));
+my $rounds=&quot;w3&quot;;
+my ($rndkey0,$rndkey1,$inout)=map(&quot;q$_&quot;,(0..3));
+
+$code.=&lt;&lt;___;
+.globl	${prefix}_${dir}crypt
+.type	${prefix}_${dir}crypt,%function
+.align	5
+${prefix}_${dir}crypt:
+	ldr	$rounds,[$key,#240]
+	vld1.32	{$rndkey0},[$key],#16
+	vld1.8	{$inout},[$inp]
+	sub	$rounds,$rounds,#2
+	vld1.32	{$rndkey1},[$key],#16
+
+.Loop_${dir}c:
+	aes$e	$inout,$rndkey0
+	vld1.32	{$rndkey0},[$key],#16
+	aes$mc	$inout,$inout
+	subs	$rounds,$rounds,#2
+	aes$e	$inout,$rndkey1
+	vld1.32	{$rndkey1},[$key],#16
+	aes$mc	$inout,$inout
+	b.gt	.Loop_${dir}c
+
+	aes$e	$inout,$rndkey0
+	vld1.32	{$rndkey0},[$key]
+	aes$mc	$inout,$inout
+	aes$e	$inout,$rndkey1
+	veor	$inout,$inout,$rndkey0
+
+	vst1.8	{$inout},[$out]
+	ret
+.size	${prefix}_${dir}crypt,.-${prefix}_${dir}crypt
+___
+}
+&amp;gen_block(&quot;en&quot;);
+&amp;gen_block(&quot;de&quot;);
+}}}
+{{{
+my ($inp,$out,$len,$key,$ivp)=map(&quot;x$_&quot;,(0..4)); my $enc=&quot;w5&quot;;
+my ($rounds,$cnt,$key_,$step,$step1)=($enc,&quot;w6&quot;,&quot;x7&quot;,&quot;x8&quot;,&quot;x12&quot;);
+my ($dat0,$dat1,$in0,$in1,$tmp0,$tmp1,$ivec,$rndlast)=map(&quot;q$_&quot;,(0..7));
+
+my ($dat,$tmp,$rndzero_n_last)=($dat0,$tmp0,$tmp1);
+
+### q8-q15	preloaded key schedule
+
+$code.=&lt;&lt;___;
+.globl	${prefix}_cbc_encrypt
+.type	${prefix}_cbc_encrypt,%function
+.align	5
+${prefix}_cbc_encrypt:
+___
+$code.=&lt;&lt;___	if ($flavour =~ /64/);
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+___
+$code.=&lt;&lt;___	if ($flavour !~ /64/);
+	mov	ip,sp
+	stmdb	sp!,{r4-r8,lr}
+	vstmdb	sp!,{d8-d15}            @ ABI specification says so
+	ldmia	ip,{r4-r5}		@ load remaining args
+___
+$code.=&lt;&lt;___;
+	subs	$len,$len,#16
+	mov	$step,#16
+	b.lo	.Lcbc_abort
+	cclr	$step,eq
+
+	cmp	$enc,#0			// en- or decrypting?
+	ldr	$rounds,[$key,#240]
+	and	$len,$len,#-16
+	vld1.8	{$ivec},[$ivp]
+	vld1.8	{$dat},[$inp],$step
+
+	vld1.32	{q8-q9},[$key]		// load key schedule...
+	sub	$rounds,$rounds,#6
+	add	$key_,$key,x5,lsl#4	// pointer to last 7 round keys
+	sub	$rounds,$rounds,#2
+	vld1.32	{q10-q11},[$key_],#32
+	vld1.32	{q12-q13},[$key_],#32
+	vld1.32	{q14-q15},[$key_],#32
+	vld1.32	{$rndlast},[$key_]
+
+	add	$key_,$key,#32
+	mov	$cnt,$rounds
+	b.eq	.Lcbc_dec
+
+	cmp	$rounds,#2
+	veor	$dat,$dat,$ivec
+	veor	$rndzero_n_last,q8,$rndlast
+	b.eq	.Lcbc_enc128
+
+.Loop_cbc_enc:
+	aese	$dat,q8
+	vld1.32	{q8},[$key_],#16
+	aesmc	$dat,$dat
+	subs	$cnt,$cnt,#2
+	aese	$dat,q9
+	vld1.32	{q9},[$key_],#16
+	aesmc	$dat,$dat
+	b.gt	.Loop_cbc_enc
+
+	aese	$dat,q8
+	aesmc	$dat,$dat
+	 subs	$len,$len,#16
+	aese	$dat,q9
+	aesmc	$dat,$dat
+	 cclr	$step,eq
+	aese	$dat,q10
+	aesmc	$dat,$dat
+	 add	$key_,$key,#16
+	aese	$dat,q11
+	aesmc	$dat,$dat
+	 vld1.8	{q8},[$inp],$step
+	aese	$dat,q12
+	aesmc	$dat,$dat
+	 veor	q8,q8,$rndzero_n_last
+	aese	$dat,q13
+	aesmc	$dat,$dat
+	 vld1.32 {q9},[$key_],#16	// re-pre-load rndkey[1]
+	aese	$dat,q14
+	aesmc	$dat,$dat
+	aese	$dat,q15
+
+	 mov	$cnt,$rounds
+	veor	$ivec,$dat,$rndlast
+	vst1.8	{$ivec},[$out],#16
+	b.hs	.Loop_cbc_enc
+
+	b	.Lcbc_done
+
+.align	5
+.Lcbc_enc128:
+	vld1.32	{$in0-$in1},[$key_]
+	aese	$dat,q8
+	aesmc	$dat,$dat
+	b	.Lenter_cbc_enc128
+.Loop_cbc_enc128:
+	aese	$dat,q8
+	aesmc	$dat,$dat
+	 vst1.8	{$ivec},[$out],#16
+.Lenter_cbc_enc128:
+	aese	$dat,q9
+	aesmc	$dat,$dat
+	 subs	$len,$len,#16
+	aese	$dat,$in0
+	aesmc	$dat,$dat
+	 cclr	$step,eq
+	aese	$dat,$in1
+	aesmc	$dat,$dat
+	aese	$dat,q10
+	aesmc	$dat,$dat
+	aese	$dat,q11
+	aesmc	$dat,$dat
+	 vld1.8	{q8},[$inp],$step
+	aese	$dat,q12
+	aesmc	$dat,$dat
+	aese	$dat,q13
+	aesmc	$dat,$dat
+	aese	$dat,q14
+	aesmc	$dat,$dat
+	 veor	q8,q8,$rndzero_n_last
+	aese	$dat,q15
+	veor	$ivec,$dat,$rndlast
+	b.hs	.Loop_cbc_enc128
+
+	vst1.8	{$ivec},[$out],#16
+	b	.Lcbc_done
+___
+{
+my ($dat2,$in2,$tmp2)=map(&quot;q$_&quot;,(10,11,9));
+$code.=&lt;&lt;___;
+.align	5
+.Lcbc_dec:
+	vld1.8	{$dat2},[$inp],#16
+	subs	$len,$len,#32		// bias
+	add	$cnt,$rounds,#2
+	vorr	$in1,$dat,$dat
+	vorr	$dat1,$dat,$dat
+	vorr	$in2,$dat2,$dat2
+	b.lo	.Lcbc_dec_tail
+
+	vorr	$dat1,$dat2,$dat2
+	vld1.8	{$dat2},[$inp],#16
+	vorr	$in0,$dat,$dat
+	vorr	$in1,$dat1,$dat1
+	vorr	$in2,$dat2,$dat2
+
+.Loop3x_cbc_dec:
+	aesd	$dat0,q8
+	aesd	$dat1,q8
+	aesd	$dat2,q8
+	vld1.32	{q8},[$key_],#16
+	aesimc	$dat0,$dat0
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	subs	$cnt,$cnt,#2
+	aesd	$dat0,q9
+	aesd	$dat1,q9
+	aesd	$dat2,q9
+	vld1.32	{q9},[$key_],#16
+	aesimc	$dat0,$dat0
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	b.gt	.Loop3x_cbc_dec
+
+	aesd	$dat0,q8
+	aesd	$dat1,q8
+	aesd	$dat2,q8
+	 veor	$tmp0,$ivec,$rndlast
+	aesimc	$dat0,$dat0
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	 veor	$tmp1,$in0,$rndlast
+	aesd	$dat0,q9
+	aesd	$dat1,q9
+	aesd	$dat2,q9
+	 veor	$tmp2,$in1,$rndlast
+	 subs	$len,$len,#0x30
+	aesimc	$dat0,$dat0
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	 vorr	$ivec,$in2,$in2
+	 mov.lo	x6,$len			// x6, $cnt, is zero at this point
+	aesd	$dat0,q12
+	aesd	$dat1,q12
+	aesd	$dat2,q12
+	 add	$inp,$inp,x6		// $inp is adjusted in such way that
+					// at exit from the loop $dat1-$dat2
+					// are loaded with last &quot;words&quot;
+	aesimc	$dat0,$dat0
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	 mov	$key_,$key
+	aesd	$dat0,q13
+	aesd	$dat1,q13
+	aesd	$dat2,q13
+	 vld1.8	{$in0},[$inp],#16
+	aesimc	$dat0,$dat0
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	 vld1.8	{$in1},[$inp],#16
+	aesd	$dat0,q14
+	aesd	$dat1,q14
+	aesd	$dat2,q14
+	 vld1.8	{$in2},[$inp],#16
+	aesimc	$dat0,$dat0
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	 vld1.32 {q8},[$key_],#16	// re-pre-load rndkey[0]
+	aesd	$dat0,q15
+	aesd	$dat1,q15
+	aesd	$dat2,q15
+
+	 add	$cnt,$rounds,#2
+	veor	$tmp0,$tmp0,$dat0
+	veor	$tmp1,$tmp1,$dat1
+	veor	$dat2,$dat2,$tmp2
+	 vld1.32 {q9},[$key_],#16	// re-pre-load rndkey[1]
+	 vorr	$dat0,$in0,$in0
+	vst1.8	{$tmp0},[$out],#16
+	 vorr	$dat1,$in1,$in1
+	vst1.8	{$tmp1},[$out],#16
+	vst1.8	{$dat2},[$out],#16
+	 vorr	$dat2,$in2,$in2
+	b.hs	.Loop3x_cbc_dec
+
+	cmn	$len,#0x30
+	b.eq	.Lcbc_done
+	nop
+
+.Lcbc_dec_tail:
+	aesd	$dat1,q8
+	aesd	$dat2,q8
+	vld1.32	{q8},[$key_],#16
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	subs	$cnt,$cnt,#2
+	aesd	$dat1,q9
+	aesd	$dat2,q9
+	vld1.32	{q9},[$key_],#16
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	b.gt	.Lcbc_dec_tail
+
+	aesd	$dat1,q8
+	aesd	$dat2,q8
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	aesd	$dat1,q9
+	aesd	$dat2,q9
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	aesd	$dat1,q12
+	aesd	$dat2,q12
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	 cmn	$len,#0x20
+	aesd	$dat1,q13
+	aesd	$dat2,q13
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	 veor	$tmp1,$ivec,$rndlast
+	aesd	$dat1,q14
+	aesd	$dat2,q14
+	aesimc	$dat1,$dat1
+	aesimc	$dat2,$dat2
+	 veor	$tmp2,$in1,$rndlast
+	aesd	$dat1,q15
+	aesd	$dat2,q15
+	b.eq	.Lcbc_dec_one
+	veor	$tmp1,$tmp1,$dat1
+	veor	$tmp2,$tmp2,$dat2
+	 vorr	$ivec,$in2,$in2
+	vst1.8	{$tmp1},[$out],#16
+	vst1.8	{$tmp2},[$out],#16
+	b	.Lcbc_done
+
+.Lcbc_dec_one:
+	veor	$tmp1,$tmp1,$dat2
+	 vorr	$ivec,$in2,$in2
+	vst1.8	{$tmp1},[$out],#16
+
+.Lcbc_done:
+	vst1.8	{$ivec},[$ivp]
+.Lcbc_abort:
+___
+}
+$code.=&lt;&lt;___	if ($flavour !~ /64/);
+	vldmia	sp!,{d8-d15}
+	ldmia	sp!,{r4-r8,pc}
+___
+$code.=&lt;&lt;___	if ($flavour =~ /64/);
+	ldr	x29,[sp],#16
+	ret
+___
+$code.=&lt;&lt;___;
+.size	${prefix}_cbc_encrypt,.-${prefix}_cbc_encrypt
+___
+}}}
+{{{
+my ($inp,$out,$len,$key,$ivp)=map(&quot;x$_&quot;,(0..4));
+my ($rounds,$cnt,$key_)=(&quot;w5&quot;,&quot;w6&quot;,&quot;x7&quot;);
+my ($ctr,$tctr0,$tctr1,$tctr2)=map(&quot;w$_&quot;,(8..10,12));
+my $step=&quot;x12&quot;;		# aliases with $tctr2
+
+my ($dat0,$dat1,$in0,$in1,$tmp0,$tmp1,$ivec,$rndlast)=map(&quot;q$_&quot;,(0..7));
+my ($dat2,$in2,$tmp2)=map(&quot;q$_&quot;,(10,11,9));
+
+my ($dat,$tmp)=($dat0,$tmp0);
+
+### q8-q15	preloaded key schedule
+
+$code.=&lt;&lt;___;
+.globl	${prefix}_ctr32_encrypt_blocks
+.type	${prefix}_ctr32_encrypt_blocks,%function
+.align	5
+${prefix}_ctr32_encrypt_blocks:
+___
+$code.=&lt;&lt;___	if ($flavour =~ /64/);
+	stp		x29,x30,[sp,#-16]!
+	add		x29,sp,#0
+___
+$code.=&lt;&lt;___	if ($flavour !~ /64/);
+	mov		ip,sp
+	stmdb		sp!,{r4-r10,lr}
+	vstmdb		sp!,{d8-d15}            @ ABI specification says so
+	ldr		r4, [ip]		@ load remaining arg
+___
+$code.=&lt;&lt;___;
+	ldr		$rounds,[$key,#240]
+
+	ldr		$ctr, [$ivp, #12]
+	vld1.32		{$dat0},[$ivp]
+
+	vld1.32		{q8-q9},[$key]		// load key schedule...
+	sub		$rounds,$rounds,#4
+	mov		$step,#16
+	cmp		$len,#2
+	add		$key_,$key,x5,lsl#4	// pointer to last 5 round keys
+	sub		$rounds,$rounds,#2
+	vld1.32		{q12-q13},[$key_],#32
+	vld1.32		{q14-q15},[$key_],#32
+	vld1.32		{$rndlast},[$key_]
+	add		$key_,$key,#32
+	mov		$cnt,$rounds
+	cclr		$step,lo
+#ifndef __ARMEB__
+	rev		$ctr, $ctr
+#endif
+	vorr		$dat1,$dat0,$dat0
+	add		$tctr1, $ctr, #1
+	vorr		$dat2,$dat0,$dat0
+	add		$ctr, $ctr, #2
+	vorr		$ivec,$dat0,$dat0
+	rev		$tctr1, $tctr1
+	vmov.32		${dat1}[3],$tctr1
+	b.ls		.Lctr32_tail
+	rev		$tctr2, $ctr
+	sub		$len,$len,#3		// bias
+	vmov.32		${dat2}[3],$tctr2
+	b		.Loop3x_ctr32
+
+.align	4
+.Loop3x_ctr32:
+	aese		$dat0,q8
+	aese		$dat1,q8
+	aese		$dat2,q8
+	vld1.32		{q8},[$key_],#16
+	aesmc		$dat0,$dat0
+	aesmc		$dat1,$dat1
+	aesmc		$dat2,$dat2
+	subs		$cnt,$cnt,#2
+	aese		$dat0,q9
+	aese		$dat1,q9
+	aese		$dat2,q9
+	vld1.32		{q9},[$key_],#16
+	aesmc		$dat0,$dat0
+	aesmc		$dat1,$dat1
+	aesmc		$dat2,$dat2
+	b.gt		.Loop3x_ctr32
+
+	aese		$dat0,q8
+	aese		$dat1,q8
+	aese		$dat2,q8
+	 mov		$key_,$key
+	aesmc		$tmp0,$dat0
+	 vld1.8		{$in0},[$inp],#16
+	aesmc		$tmp1,$dat1
+	aesmc		$dat2,$dat2
+	 vorr		$dat0,$ivec,$ivec
+	aese		$tmp0,q9
+	 vld1.8		{$in1},[$inp],#16
+	aese		$tmp1,q9
+	aese		$dat2,q9
+	 vorr		$dat1,$ivec,$ivec
+	aesmc		$tmp0,$tmp0
+	 vld1.8		{$in2},[$inp],#16
+	aesmc		$tmp1,$tmp1
+	aesmc		$tmp2,$dat2
+	 vorr		$dat2,$ivec,$ivec
+	 add		$tctr0,$ctr,#1
+	aese		$tmp0,q12
+	aese		$tmp1,q12
+	aese		$tmp2,q12
+	 veor		$in0,$in0,$rndlast
+	 add		$tctr1,$ctr,#2
+	aesmc		$tmp0,$tmp0
+	aesmc		$tmp1,$tmp1
+	aesmc		$tmp2,$tmp2
+	 veor		$in1,$in1,$rndlast
+	 add		$ctr,$ctr,#3
+	aese		$tmp0,q13
+	aese		$tmp1,q13
+	aese		$tmp2,q13
+	 veor		$in2,$in2,$rndlast
+	 rev		$tctr0,$tctr0
+	aesmc		$tmp0,$tmp0
+	 vld1.32	 {q8},[$key_],#16	// re-pre-load rndkey[0]
+	aesmc		$tmp1,$tmp1
+	aesmc		$tmp2,$tmp2
+	 vmov.32	${dat0}[3], $tctr0
+	 rev		$tctr1,$tctr1
+	aese		$tmp0,q14
+	aese		$tmp1,q14
+	aese		$tmp2,q14
+	 vmov.32	${dat1}[3], $tctr1
+	 rev		$tctr2,$ctr
+	aesmc		$tmp0,$tmp0
+	aesmc		$tmp1,$tmp1
+	aesmc		$tmp2,$tmp2
+	 vmov.32	${dat2}[3], $tctr2
+	 subs		$len,$len,#3
+	aese		$tmp0,q15
+	aese		$tmp1,q15
+	aese		$tmp2,q15
+
+	 mov		$cnt,$rounds
+	veor		$in0,$in0,$tmp0
+	veor		$in1,$in1,$tmp1
+	veor		$in2,$in2,$tmp2
+	 vld1.32	 {q9},[$key_],#16	// re-pre-load rndkey[1]
+	vst1.8		{$in0},[$out],#16
+	vst1.8		{$in1},[$out],#16
+	vst1.8		{$in2},[$out],#16
+	b.hs		.Loop3x_ctr32
+
+	adds		$len,$len,#3
+	b.eq		.Lctr32_done
+	cmp		$len,#1
+	mov		$step,#16
+	cclr		$step,eq
+
+.Lctr32_tail:
+	aese		$dat0,q8
+	aese		$dat1,q8
+	vld1.32		{q8},[$key_],#16
+	aesmc		$dat0,$dat0
+	aesmc		$dat1,$dat1
+	subs		$cnt,$cnt,#2
+	aese		$dat0,q9
+	aese		$dat1,q9
+	vld1.32		{q9},[$key_],#16
+	aesmc		$dat0,$dat0
+	aesmc		$dat1,$dat1
+	b.gt		.Lctr32_tail
+
+	aese		$dat0,q8
+	aese		$dat1,q8
+	aesmc		$dat0,$dat0
+	aesmc		$dat1,$dat1
+	aese		$dat0,q9
+	aese		$dat1,q9
+	aesmc		$dat0,$dat0
+	aesmc		$dat1,$dat1
+	 vld1.8		{$in0},[$inp],$step
+	aese		$dat0,q12
+	aese		$dat1,q12
+	 vld1.8		{$in1},[$inp]
+	aesmc		$dat0,$dat0
+	aesmc		$dat1,$dat1
+	aese		$dat0,q13
+	aese		$dat1,q13
+	aesmc		$dat0,$dat0
+	aesmc		$dat1,$dat1
+	aese		$dat0,q14
+	aese		$dat1,q14
+	 veor		$in0,$in0,$rndlast
+	aesmc		$dat0,$dat0
+	aesmc		$dat1,$dat1
+	 veor		$in1,$in1,$rndlast
+	aese		$dat0,q15
+	aese		$dat1,q15
+
+	cmp		$len,#1
+	veor		$in0,$in0,$dat0
+	veor		$in1,$in1,$dat1
+	vst1.8		{$in0},[$out],#16
+	b.eq		.Lctr32_done
+	vst1.8		{$in1},[$out]
+
+.Lctr32_done:
+___
+$code.=&lt;&lt;___	if ($flavour !~ /64/);
+	vldmia		sp!,{d8-d15}
+	ldmia		sp!,{r4-r10,pc}
+___
+$code.=&lt;&lt;___	if ($flavour =~ /64/);
+	ldr		x29,[sp],#16
+	ret
+___
+$code.=&lt;&lt;___;
+.size	${prefix}_ctr32_encrypt_blocks,.-${prefix}_ctr32_encrypt_blocks
+___
+}}}
+$code.=&lt;&lt;___;
+#endif
+___
+########################################
+if ($flavour =~ /64/) {			######## 64-bit code
+    my %opcode = (
+	&quot;aesd&quot;	=&gt;	0x4e285800,	&quot;aese&quot;	=&gt;	0x4e284800,
+	&quot;aesimc&quot;=&gt;	0x4e287800,	&quot;aesmc&quot;	=&gt;	0x4e286800	);
+
+    local *unaes = sub {
+	my ($mnemonic,$arg)=@_;
+
+	$arg =~ m/[qv]([0-9]+)[^,]*,\s*[qv]([0-9]+)/o	&amp;&amp;
+	sprintf &quot;.inst\t0x%08x\t//%s %s&quot;,
+			$opcode{$mnemonic}|$1|($2&lt;&lt;5),
+			$mnemonic,$arg;
+    };
+
+    foreach(split(&quot;\n&quot;,$code)) {
+	s/\`([^\`]*)\`/eval($1)/geo;
+
+	s/\bq([0-9]+)\b/&quot;v&quot;.($1&lt;8?$1:$1+8).&quot;.16b&quot;/geo;	# old-&gt;new registers
+	s/@\s/\/\//o;			# old-&gt;new style commentary
+
+	#s/[v]?(aes\w+)\s+([qv].*)/unaes($1,$2)/geo	or
+	s/cclr\s+([wx])([^,]+),\s*([a-z]+)/csel	$1$2,$1zr,$1$2,$3/o	or
+	s/mov\.([a-z]+)\s+([wx][0-9]+),\s*([wx][0-9]+)/csel	$2,$3,$2,$1/o	or
+	s/vmov\.i8/movi/o	or	# fix up legacy mnemonics
+	s/vext\.8/ext/o		or
+	s/vrev32\.8/rev32/o	or
+	s/vtst\.8/cmtst/o	or
+	s/vshr/ushr/o		or
+	s/^(\s+)v/$1/o		or	# strip off v prefix
+	s/\bbx\s+lr\b/ret/o;
+
+	# fix up remainig legacy suffixes
+	s/\.[ui]?8//o;
+	m/\],#8/o and s/\.16b/\.8b/go;
+	s/\.[ui]?32//o and s/\.16b/\.4s/go;
+	s/\.[ui]?64//o and s/\.16b/\.2d/go;
+	s/\.[42]([sd])\[([0-3])\]/\.$1\[$2\]/o;
+
+	print $_,&quot;\n&quot;;
+    }
+} else {				######## 32-bit code
+    my %opcode = (
+	&quot;aesd&quot;	=&gt;	0xf3b00340,	&quot;aese&quot;	=&gt;	0xf3b00300,
+	&quot;aesimc&quot;=&gt;	0xf3b003c0,	&quot;aesmc&quot;	=&gt;	0xf3b00380	);
+
+    local *unaes = sub {
+	my ($mnemonic,$arg)=@_;
+
+	if ($arg =~ m/[qv]([0-9]+)[^,]*,\s*[qv]([0-9]+)/o) {
+	    my $word = $opcode{$mnemonic}|(($1&amp;7)&lt;&lt;13)|(($1&amp;8)&lt;&lt;19)
+					 |(($2&amp;7)&lt;&lt;1) |(($2&amp;8)&lt;&lt;2);
+	    # since ARMv7 instructions are always encoded little-endian.
+	    # correct solution is to use .inst directive, but older
+	    # assemblers don't implement it:-(
+	    sprintf &quot;.byte\t0x%02x,0x%02x,0x%02x,0x%02x\t@ %s %s&quot;,
+			$word&amp;0xff,($word&gt;&gt;8)&amp;0xff,
+			($word&gt;&gt;16)&amp;0xff,($word&gt;&gt;24)&amp;0xff,
+			$mnemonic,$arg;
+	}
+    };
+
+    sub unvtbl {
+	my $arg=shift;
+
+	$arg =~ m/q([0-9]+),\s*\{q([0-9]+)\},\s*q([0-9]+)/o &amp;&amp;
+	sprintf	&quot;vtbl.8	d%d,{q%d},d%d\n\t&quot;.
+		&quot;vtbl.8	d%d,{q%d},d%d&quot;, 2*$1,$2,2*$3, 2*$1+1,$2,2*$3+1;	
+    }
+
+    sub unvdup32 {
+	my $arg=shift;
+
+	$arg =~ m/q([0-9]+),\s*q([0-9]+)\[([0-3])\]/o &amp;&amp;
+	sprintf	&quot;vdup.32	q%d,d%d[%d]&quot;,$1,2*$2+($3&gt;&gt;1),$3&amp;1;	
+    }
+
+    sub unvmov32 {
+	my $arg=shift;
+
+	$arg =~ m/q([0-9]+)\[([0-3])\],(.*)/o &amp;&amp;
+	sprintf	&quot;vmov.32	d%d[%d],%s&quot;,2*$1+($2&gt;&gt;1),$2&amp;1,$3;	
+    }
+
+    foreach(split(&quot;\n&quot;,$code)) {
+	s/\`([^\`]*)\`/eval($1)/geo;
+
+	s/\b[wx]([0-9]+)\b/r$1/go;		# new-&gt;old registers
+	s/\bv([0-9])\.[12468]+[bsd]\b/q$1/go;	# new-&gt;old registers
+	s/\/\/\s?/@ /o;				# new-&gt;old style commentary
+
+	# fix up remainig new-style suffixes
+	s/\{q([0-9]+)\},\s*\[(.+)\],#8/sprintf &quot;{d%d},[$2]!&quot;,2*$1/eo	or
+	s/\],#[0-9]+/]!/o;
+
+	s/[v]?(aes\w+)\s+([qv].*)/unaes($1,$2)/geo	or
+	s/cclr\s+([^,]+),\s*([a-z]+)/mov$2	$1,#0/o	or
+	s/vtbl\.8\s+(.*)/unvtbl($1)/geo			or
+	s/vdup\.32\s+(.*)/unvdup32($1)/geo		or
+	s/vmov\.32\s+(.*)/unvmov32($1)/geo		or
+	s/^(\s+)b\./$1b/o				or
+	s/^(\s+)mov\./$1mov/o				or
+	s/^(\s+)ret/$1bx\tlr/o;
+
+	print $_,&quot;\n&quot;;
+    }
+}
+
+close STDOUT;
diff --git a/crypto/arm64cpuid.pl b/crypto/arm64cpuid.pl
new file mode 100644
index 0000000..bfec664
--- /dev/null
+++ b/crypto/arm64cpuid.pl
@@ -0,0 +1,68 @@
+#!/usr/bin/env perl
+
+$flavour = shift;
+$output  = shift;
+
+$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+( $xlate=&quot;${dir}perlasm/arm-xlate.pl&quot; and -f $xlate) or
+die &quot;can't locate arm-xlate.pl&quot;;
+
+open OUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+*STDOUT=*OUT;
+
+$code.=&lt;&lt;___;
+#include &quot;arm_arch.h&quot;
+
+.text
+.arch	armv8-a+crypto
+
+.align	5
+.globl	_armv7_neon_probe
+.type	_armv7_neon_probe,%function
+_armv7_neon_probe:
+	orr	v15.16b, v15.16b, v15.16b
+	ret
+.size	_armv7_neon_probe,.-_armv7_neon_probe
+
+.globl	_armv7_tick
+.type	_armv7_tick,%function
+_armv7_tick:
+#ifdef	__APPLE__
+	mrs	x0, CNTPCT_EL0
+#else
+	mrs	x0, CNTVCT_EL0
+#endif
+	ret
+.size	_armv7_tick,.-_armv7_tick
+
+.globl	_armv8_aes_probe
+.type	_armv8_aes_probe,%function
+_armv8_aes_probe:
+	aese	v0.16b, v0.16b
+	ret
+.size	_armv8_aes_probe,.-_armv8_aes_probe
+
+.globl	_armv8_sha1_probe
+.type	_armv8_sha1_probe,%function
+_armv8_sha1_probe:
+	sha1h	s0, s0
+	ret
+.size	_armv8_sha1_probe,.-_armv8_sha1_probe
+
+.globl	_armv8_sha256_probe
+.type	_armv8_sha256_probe,%function
+_armv8_sha256_probe:
+	sha256su0	v0.4s, v0.4s
+	ret
+.size	_armv8_sha256_probe,.-_armv8_sha256_probe
+.globl	_armv8_pmull_probe
+.type	_armv8_pmull_probe,%function
+_armv8_pmull_probe:
+	pmull	v0.1q, v0.1d, v0.1d
+	ret
+.size	_armv8_pmull_probe,.-_armv8_pmull_probe
+___
+
+print $code;
+close STDOUT;
diff --git a/crypto/arm_arch.h b/crypto/arm_arch.h
index a50c366..7a37775 100644
--- a/crypto/arm_arch.h
+++ b/crypto/arm_arch.h
@@ -10,13 +10,22 @@
 #   define __ARMEL__
 #  endif
 # elif defined(__GNUC__)
+#  if  defined(__aarch64__)
+#   define __ARM_ARCH__ 8
+#   if __BYTE_ORDER__==__ORDER_BIG_ENDIAN__
+#    define __ARMEB__
+#   else
+#    define __ARMEL__
+#   endif
   /*
    * Why doesn't gcc define __ARM_ARCH__? Instead it defines
    * bunch of below macros. See all_architectires[] table in
    * gcc/config/arm/arm.c. On a side note it defines
    * __ARMEL__/__ARMEB__ for little-/big-endian.
    */
-#  if	defined(__ARM_ARCH_7__)	|| defined(__ARM_ARCH_7A__)	|| \
+#  elif defined(__ARM_ARCH_8A__)
+#    define __ARM_ARCH__ 8
+#  elif	defined(__ARM_ARCH_7__)	|| defined(__ARM_ARCH_7A__)	|| \
 	defined(__ARM_ARCH_7R__)|| defined(__ARM_ARCH_7M__)	|| \
 	defined(__ARM_ARCH_7EM__)
 #   define __ARM_ARCH__ 7
@@ -42,10 +51,14 @@
 
 #if !__ASSEMBLER__
 extern unsigned int OPENSSL_armcap_P;
+#endif
                                      
 #define ARMV7_NEON      (1&lt;&lt;0)
 #define ARMV7_TICK      (1&lt;&lt;1)
-#endif
+#define ARMV8_AES       (1&lt;&lt;2)
+#define ARMV8_SHA1      (1&lt;&lt;3)
+#define ARMV8_SHA256    (1&lt;&lt;4)
+#define ARMV8_PMULL     (1&lt;&lt;5)
 
 #endif
 #endif
diff --git a/crypto/armcap.c b/crypto/armcap.c
index 5258d2f..2579389 100644
--- a/crypto/armcap.c
+++ b/crypto/armcap.c
@@ -20,6 +20,10 @@ static void ill_handler (int sig) { siglongjmp(ill_jmp,sig); }
  */
 void _armv7_neon_probe(void);
 unsigned int _armv7_tick(void);
+void _armv8_aes_probe(void);
+void _armv8_sha1_probe(void);
+void _armv8_sha256_probe(void);
+void _armv8_pmull_probe(void);
 
 unsigned int OPENSSL_rdtsc(void)
 	{
@@ -68,6 +72,28 @@ void OPENSSL_cpuid_setup(void)
 		{
 		_armv7_neon_probe();
 		OPENSSL_armcap_P |= ARMV7_NEON;
+#ifdef __aarch64__
+		if (sigsetjmp(ill_jmp,1) == 0)
+			{
+			_armv8_pmull_probe();
+			OPENSSL_armcap_P |= ARMV8_PMULL|ARMV8_AES;
+			}
+		else if (sigsetjmp(ill_jmp,1) == 0)
+			{
+			_armv8_aes_probe();
+			OPENSSL_armcap_P |= ARMV8_AES;
+			}
+		if (sigsetjmp(ill_jmp,1) == 0)
+			{
+			_armv8_sha1_probe();
+			OPENSSL_armcap_P |= ARMV8_SHA1;
+			}
+		if (sigsetjmp(ill_jmp,1) == 0)
+			{
+			_armv8_sha256_probe();
+			OPENSSL_armcap_P |= ARMV8_SHA256;
+			}
+#endif
 		}
 	if (sigsetjmp(ill_jmp,1) == 0)
 		{
diff --git a/crypto/armv4cpuid_ios.S b/crypto/armv4cpuid_ios.S
new file mode 100644
index 0000000..cce9a79
--- /dev/null
+++ b/crypto/armv4cpuid_ios.S
@@ -0,0 +1,210 @@
+#include &quot;arm_arch.h&quot;
+
+.text
+.code	32
+
+.align	5
+.globl	_OPENSSL_atomic_add
+
+_OPENSSL_atomic_add:
+#if __ARM_ARCH__&gt;=6
+Ladd:	ldrex	r2,[r0]
+	add	r3,r2,r1
+	strex	r2,r3,[r0]
+	cmp	r2,#0
+	bne	Ladd
+	mov	r0,r3
+	bx	lr
+#else
+	stmdb	sp!,{r4,r5,r6,lr}
+	ldr	r2,Lspinlock
+	adr	r3,Lspinlock
+	mov	r4,r0
+	mov	r5,r1
+	add	r6,r3,r2	@ &amp;spinlock
+	b	.+8
+Lspin:	bl	sched_yield
+	mov	r0,#-1
+	swp	r0,r0,[r6]
+	cmp	r0,#0
+	bne	Lspin
+
+	ldr	r2,[r4]
+	add	r2,r2,r5
+	str	r2,[r4]
+	str	r0,[r6]		@ release spinlock
+	ldmia	sp!,{r4,r5,r6,lr}
+	tst	lr,#1
+	moveq	pc,lr
+.word	0xe12fff1e	@ bx	lr
+#endif
+
+
+.globl	_OPENSSL_cleanse
+
+_OPENSSL_cleanse:
+	eor	ip,ip,ip
+	cmp	r1,#7
+	subhs	r1,r1,#4
+	bhs	Lot
+	cmp	r1,#0
+	beq	Lcleanse_done
+Little:
+	strb	ip,[r0],#1
+	subs	r1,r1,#1
+	bhi	Little
+	b	Lcleanse_done
+
+Lot:	tst	r0,#3
+	beq	Laligned
+	strb	ip,[r0],#1
+	sub	r1,r1,#1
+	b	Lot
+Laligned:
+	str	ip,[r0],#4
+	subs	r1,r1,#4
+	bhs	Laligned
+	adds	r1,r1,#4
+	bne	Little
+Lcleanse_done:
+#if __ARM_ARCH__&gt;=5
+	bx	lr
+#else
+	tst	lr,#1
+	moveq	pc,lr
+.word	0xe12fff1e	@ bx	lr
+#endif
+
+
+
+
+.align	5
+.globl	__armv7_neon_probe
+
+__armv7_neon_probe:
+	vorr	q0,q0,q0
+	bx	lr
+
+
+.globl	__armv7_tick
+
+__armv7_tick:
+#ifdef	__APPLE__
+	mrrc	p15,0,r0,r1,c14		@ CNTPCT
+#else
+	mrrc	p15,1,r0,r1,c14		@ CNTVCT
+#endif
+	bx	lr
+
+
+.globl	__armv8_aes_probe
+
+__armv8_aes_probe:
+.byte	0x00,0x03,0xb0,0xf3	@ aese.8	q0,q0
+	bx	lr
+
+
+.globl	__armv8_sha1_probe
+
+__armv8_sha1_probe:
+.byte	0x40,0x0c,0x00,0xf2	@ sha1c.32	q0,q0,q0
+	bx	lr
+
+
+.globl	__armv8_sha256_probe
+
+__armv8_sha256_probe:
+.byte	0x40,0x0c,0x00,0xf3	@ sha256h.32	q0,q0,q0
+	bx	lr
+
+.globl	__armv8_pmull_probe
+
+__armv8_pmull_probe:
+.byte	0x00,0x0e,0xa0,0xf2	@ vmull.p64	q0,d0,d0
+	bx	lr
+
+.globl	_OPENSSL_wipe_cpu
+
+_OPENSSL_wipe_cpu:
+	ldr	r0,LOPENSSL_armcap
+	adr	r1,LOPENSSL_armcap
+	ldr	r0,[r1,r0]
+#ifdef	__APPLE__
+	ldr	r0,[r0]
+#endif
+	eor	r2,r2,r2
+	eor	r3,r3,r3
+	eor	ip,ip,ip
+	tst	r0,#1
+	beq	Lwipe_done
+	veor	q0, q0, q0
+	veor	q1, q1, q1
+	veor	q2, q2, q2
+	veor	q3, q3, q3
+	veor	q8, q8, q8
+	veor	q9, q9, q9
+	veor	q10, q10, q10
+	veor	q11, q11, q11
+	veor	q12, q12, q12
+	veor	q13, q13, q13
+	veor	q14, q14, q14
+	veor	q15, q15, q15
+Lwipe_done:
+	mov	r0,sp
+#if __ARM_ARCH__&gt;=5
+	bx	lr
+#else
+	tst	lr,#1
+	moveq	pc,lr
+.word	0xe12fff1e	@ bx	lr
+#endif
+
+
+.globl	_OPENSSL_instrument_bus
+
+_OPENSSL_instrument_bus:
+	eor	r0,r0,r0
+#if __ARM_ARCH__&gt;=5
+	bx	lr
+#else
+	tst	lr,#1
+	moveq	pc,lr
+.word	0xe12fff1e	@ bx	lr
+#endif
+
+
+.globl	_OPENSSL_instrument_bus2
+
+_OPENSSL_instrument_bus2:
+	eor	r0,r0,r0
+#if __ARM_ARCH__&gt;=5
+	bx	lr
+#else
+	tst	lr,#1
+	moveq	pc,lr
+.word	0xe12fff1e	@ bx	lr
+#endif
+
+
+.align	5
+LOPENSSL_armcap:
+.word	OPENSSL_armcap_P-.
+#if __ARM_ARCH__&gt;=6
+.align	5
+#else
+Lspinlock:
+.word	atomic_add_spinlock-Lspinlock
+.align	5
+
+.data
+.align	2
+atomic_add_spinlock:
+.word
+#endif
+
+.comm	_OPENSSL_armcap_P,4
+.non_lazy_symbol_pointer
+OPENSSL_armcap_P:
+.indirect_symbol	_OPENSSL_armcap_P
+.long	0
+.private_extern	_OPENSSL_armcap_P
diff --git a/crypto/bn/asm/armv4-gf2m.pl b/crypto/bn/asm/armv4-gf2m.pl
index c52e0b7..737659f 100644
--- a/crypto/bn/asm/armv4-gf2m.pl
+++ b/crypto/bn/asm/armv4-gf2m.pl
@@ -21,8 +21,20 @@
 # runs in even less cycles, ~30, improvement is measurable only on
 # longer keys. One has to optimize code elsewhere to get NEON glow...
 
-while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {}
-open STDOUT,&quot;&gt;$output&quot;;
+$flavour = shift;
+if ($flavour=~/^\w[\w\-]*\.\w+$/) { $output=$flavour; undef $flavour; }
+else { while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {} }
+
+if ($flavour &amp;&amp; $flavour ne &quot;void&quot;) {
+    $0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+    ( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+    ( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+    die &quot;can't locate arm-xlate.pl&quot;;
+
+    open STDOUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+} else {
+    open STDOUT,&quot;&gt;$output&quot;;
+}
 
 sub Dlo()   { shift=~m|q([1]?[0-9])|?&quot;d&quot;.($1*2):&quot;&quot;;     }
 sub Dhi()   { shift=~m|q([1]?[0-9])|?&quot;d&quot;.($1*2+1):&quot;&quot;;   }
@@ -170,11 +182,18 @@ bn_GF2m_mul_2x2:
 #if __ARM_ARCH__&gt;=7
 	ldr	r12,.LOPENSSL_armcap
 .Lpic:	ldr	r12,[pc,r12]
+#ifdef	__APPLE__
+	ldr	r12,[r12]
+#endif
 	tst	r12,#1
 	beq	.Lialu
 
 	veor	$A1,$A1
+#ifdef	__APPLE__
+	vmov	$B1,r3,r3		@ two copies of b1
+#else
 	vmov.32	$B1,r3,r3		@ two copies of b1
+#endif
 	vmov.32	${A1}[0],r1		@ a1
 
 	veor	$A0,$A0
diff --git a/crypto/bn/asm/armv4-mont.pl b/crypto/bn/asm/armv4-mont.pl
index f78a8b5..aa00f38 100644
--- a/crypto/bn/asm/armv4-mont.pl
+++ b/crypto/bn/asm/armv4-mont.pl
@@ -23,8 +23,20 @@
 # than 1/2KB. Windows CE port would be trivial, as it's exclusively
 # about decorations, ABI and instruction syntax are identical.
 
-while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {}
-open STDOUT,&quot;&gt;$output&quot;;
+$flavour = shift;
+if ($flavour=~/^\w[\w\-]*\.\w+$/) { $output=$flavour; undef $flavour; }
+else { while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {} }
+
+if ($flavour &amp;&amp; $flavour ne &quot;void&quot;) {
+    $0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+    ( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+    ( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+    die &quot;can't locate arm-xlate.pl&quot;;
+
+    open STDOUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+} else {
+    open STDOUT,&quot;&gt;$output&quot;;
+}
 
 $num=&quot;r0&quot;;	# starts as num argument, but holds &amp;tp[num-1]
 $ap=&quot;r1&quot;;
diff --git a/crypto/evp/e_aes.c b/crypto/evp/e_aes.c
index 56e5fff..9a2de16 100644
--- a/crypto/evp/e_aes.c
+++ b/crypto/evp/e_aes.c
@@ -471,6 +471,35 @@ const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 { return &amp;aes_##keylen##_##mode; }
 #endif
 
+#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__aarch64__)
+#include &quot;arm_arch.h&quot;
+#if __ARM_ARCH__&gt;=7
+# define HWAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV8_AES)
+# define HWAES_set_encrypt_key aes_v8_set_encrypt_key
+# define HWAES_set_decrypt_key aes_v8_set_decrypt_key
+# define HWAES_encrypt aes_v8_encrypt
+# define HWAES_decrypt aes_v8_decrypt
+# define HWAES_cbc_encrypt aes_v8_cbc_encrypt
+# define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks
+#endif
+#endif
+
+#if defined(HWAES_CAPABLE)
+int HWAES_set_encrypt_key(const unsigned char *userKey, const int bits,
+	AES_KEY *key);
+int HWAES_set_decrypt_key(const unsigned char *userKey, const int bits,
+	AES_KEY *key);
+void HWAES_encrypt(const unsigned char *in, unsigned char *out,
+	const AES_KEY *key);
+void HWAES_decrypt(const unsigned char *in, unsigned char *out,
+	const AES_KEY *key);
+void HWAES_cbc_encrypt(const unsigned char *in, unsigned char *out,
+	size_t length, const AES_KEY *key,
+	unsigned char *ivec, const int enc);
+void HWAES_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
+	size_t len, const AES_KEY *key, const unsigned char ivec[16]);
+#endif
+
 #define BLOCK_CIPHER_generic_pack(nid,keylen,flags)		\
 	BLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)	\
 	BLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)	\
@@ -489,6 +518,19 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 	mode = ctx-&gt;cipher-&gt;flags &amp; EVP_CIPH_MODE;
 	if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)
 	    &amp;&amp; !enc)
+#ifdef HWAES_CAPABLE
+	    if (HWAES_CAPABLE)
+		{
+		ret = HWAES_set_decrypt_key(key,ctx-&gt;key_len*8,&amp;dat-&gt;ks);
+		dat-&gt;block      = (block128_f)HWAES_decrypt;
+		dat-&gt;stream.cbc = NULL;
+#ifdef HWAES_cbc_encrypt
+		if (mode==EVP_CIPH_CBC_MODE)
+		    dat-&gt;stream.cbc = (cbc128_f)HWAES_cbc_encrypt;
+#endif
+		}
+	    else
+#endif
 #ifdef BSAES_CAPABLE
 	    if (BSAES_CAPABLE &amp;&amp; mode==EVP_CIPH_CBC_MODE)
 		{
@@ -517,6 +559,26 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 					NULL;
 		}
 	else
+#ifdef HWAES_CAPABLE
+	    if (HWAES_CAPABLE)
+		{
+		ret = HWAES_set_encrypt_key(key,ctx-&gt;key_len*8,&amp;dat-&gt;ks);
+		dat-&gt;block      = (block128_f)HWAES_encrypt;
+		dat-&gt;stream.cbc = NULL;
+#ifdef HWAES_cbc_encrypt
+		if (mode==EVP_CIPH_CBC_MODE)
+		    dat-&gt;stream.cbc = (cbc128_f)HWAES_cbc_encrypt;
+		else
+#endif
+#ifdef HWAES_ctr32_encrypt_blocks
+		if (mode==EVP_CIPH_CTR_MODE)
+		    dat-&gt;stream.ctr = (ctr128_f)HWAES_ctr32_encrypt_blocks;
+		else
+#endif
+		(void)0;	/* terminate potentially open 'else' */
+		}
+	    else
+#endif
 #ifdef BSAES_CAPABLE
 	    if (BSAES_CAPABLE &amp;&amp; mode==EVP_CIPH_CTR_MODE)
 		{
@@ -831,6 +893,21 @@ static int aes_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 		return 1;
 	if (key)
 		{ do {
+#ifdef HWAES_CAPABLE
+		if (HWAES_CAPABLE)
+			{
+			HWAES_set_encrypt_key(key,ctx-&gt;key_len*8,&amp;gctx-&gt;ks);
+			CRYPTO_gcm128_init(&amp;gctx-&gt;gcm,&amp;gctx-&gt;ks,
+					(block128_f)HWAES_encrypt);
+#ifdef HWAES_ctr32_encrypt_blocks
+			gctx-&gt;ctr = (ctr128_f)HWAES_ctr32_encrypt_blocks;
+#else
+			gctx-&gt;ctr = NULL;
+#endif
+			break;
+			}
+		else
+#endif
 #ifdef BSAES_CAPABLE
 		if (BSAES_CAPABLE)
 			{
@@ -1088,6 +1165,29 @@ static int aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 		{
 		xctx-&gt;stream = NULL;
 		/* key_len is two AES keys */
+#ifdef HWAES_CAPABLE
+		if (HWAES_CAPABLE)
+			{
+			if (enc)
+			    {
+			    HWAES_set_encrypt_key(key, ctx-&gt;key_len * 4, &amp;xctx-&gt;ks1);
+			    xctx-&gt;xts.block1 = (block128_f)HWAES_encrypt;
+			    }
+			else
+			    {
+			    HWAES_set_decrypt_key(key, ctx-&gt;key_len * 4, &amp;xctx-&gt;ks1);
+			    xctx-&gt;xts.block1 = (block128_f)HWAES_decrypt;
+			    }
+
+			HWAES_set_encrypt_key(key + ctx-&gt;key_len/2,
+						    ctx-&gt;key_len * 4, &amp;xctx-&gt;ks2);
+			xctx-&gt;xts.block2 = (block128_f)HWAES_encrypt;
+
+			xctx-&gt;xts.key1 = &amp;xctx-&gt;ks1;
+			break;
+			}
+		else
+#endif
 #ifdef VPAES_CAPABLE
 		if (VPAES_CAPABLE)
 		    {
@@ -1244,6 +1344,19 @@ static int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 		return 1;
 	if (key) do
 		{
+#ifdef HWAES_CAPABLE
+		if (HWAES_CAPABLE)
+			{
+			HWAES_set_encrypt_key(key,ctx-&gt;key_len*8,&amp;cctx-&gt;ks);
+
+			CRYPTO_ccm128_init(&amp;cctx-&gt;ccm, cctx-&gt;M, cctx-&gt;L,
+					&amp;cctx-&gt;ks, (block128_f)HWAES_encrypt);
+			cctx-&gt;str = NULL;
+			cctx-&gt;key_set = 1;
+			break;
+			}
+		else
+#endif
 #ifdef VPAES_CAPABLE
 		if (VPAES_CAPABLE)
 			{
diff --git a/crypto/modes/Makefile b/crypto/modes/Makefile
index 8119693..f4930c6 100644
--- a/crypto/modes/Makefile
+++ b/crypto/modes/Makefile
@@ -56,11 +56,14 @@ ghash-alpha.s:	asm/ghash-alpha.pl
 	$(PERL) $&lt; | $(CC) -E - | tee $@ &gt; /dev/null
 ghash-parisc.s:	asm/ghash-parisc.pl
 	$(PERL) asm/ghash-parisc.pl $(PERLASM_SCHEME) $@
+ghashv8-armx.S:	asm/ghashv8-armx.pl
+	$(PERL) asm/ghashv8-armx.pl $(PERLASM_SCHEME) $@
 
 # GNU make &quot;catch all&quot;
 ghash-%.S:	asm/ghash-%.pl;	$(PERL) $&lt; $(PERLASM_SCHEME) $@
 
 ghash-armv4.o:	ghash-armv4.S
+ghashv8-armx.o:	ghashv8-armx.S
 
 files:
 	$(PERL) $(TOP)/util/files.pl Makefile &gt;&gt; $(TOP)/MINFO
diff --git a/crypto/modes/asm/ghash-armv4.pl b/crypto/modes/asm/ghash-armv4.pl
index d91586e..3799b2b 100644
--- a/crypto/modes/asm/ghash-armv4.pl
+++ b/crypto/modes/asm/ghash-armv4.pl
@@ -57,8 +57,20 @@
 # *native* byte order on current platform. See gcm128.c for working
 # example...
 
-while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {}
-open STDOUT,&quot;&gt;$output&quot;;
+$flavour = shift;
+if ($flavour=~/^\w[\w\-]*\.\w+$/) { $output=$flavour; undef $flavour; }
+else { while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {} }
+
+if ($flavour &amp;&amp; $flavour ne &quot;void&quot;) {
+    $0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+    ( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+    ( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+    die &quot;can't locate arm-xlate.pl&quot;;
+
+    open STDOUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+} else {
+    open STDOUT,&quot;&gt;$output&quot;;
+}
 
 $Xi=&quot;r0&quot;;	# argument block
 $Htbl=&quot;r1&quot;;
@@ -112,6 +124,11 @@ $code=&lt;&lt;___;
 .text
 .code	32
 
+#ifdef  __APPLE__
+#define ldrplb	ldrbpl
+#define ldrneb	ldrbne
+#endif
+
 .type	rem_4bit,%object
 .align	5
 rem_4bit:
@@ -326,9 +343,9 @@ $code.=&lt;&lt;___;
 .align	4
 gcm_gmult_neon:
 	sub		$Htbl,#16		@ point at H in GCM128_CTX
-	vld1.64		`&amp;Dhi(&quot;$IN&quot;)`,[$Xi,:64]!@ load Xi
+	vld1.64		`&amp;Dhi(&quot;$IN&quot;)`,[$Xi]!	@ load Xi
 	vmov.i32	$mod,#0xe1		@ our irreducible polynomial
-	vld1.64		`&amp;Dlo(&quot;$IN&quot;)`,[$Xi,:64]!
+	vld1.64		`&amp;Dlo(&quot;$IN&quot;)`,[$Xi]!
 	vshr.u64	$mod,#32
 	vldmia		$Htbl,{$Hhi-$Hlo}	@ load H
 	veor		$zero,$zero
@@ -349,9 +366,9 @@ gcm_gmult_neon:
 .type	gcm_ghash_neon,%function
 .align	4
 gcm_ghash_neon:
-	vld1.64		`&amp;Dhi(&quot;$Z&quot;)`,[$Xi,:64]!	@ load Xi
+	vld1.64		`&amp;Dhi(&quot;$Z&quot;)`,[$Xi]!	@ load Xi
 	vmov.i32	$mod,#0xe1		@ our irreducible polynomial
-	vld1.64		`&amp;Dlo(&quot;$Z&quot;)`,[$Xi,:64]!
+	vld1.64		`&amp;Dlo(&quot;$Z&quot;)`,[$Xi]!
 	vshr.u64	$mod,#32
 	vldmia		$Xi,{$Hhi-$Hlo}		@ load H
 	veor		$zero,$zero
@@ -410,8 +427,8 @@ gcm_ghash_neon:
 	vrev64.8	$Z,$Z
 #endif
 	sub		$Xi,#16	
-	vst1.64		`&amp;Dhi(&quot;$Z&quot;)`,[$Xi,:64]!	@ write out Xi
-	vst1.64		`&amp;Dlo(&quot;$Z&quot;)`,[$Xi,:64]
+	vst1.64		`&amp;Dhi(&quot;$Z&quot;)`,[$Xi]!	@ write out Xi
+	vst1.64		`&amp;Dlo(&quot;$Z&quot;)`,[$Xi]
 
 	bx	lr
 .size	gcm_ghash_neon,.-gcm_ghash_neon
diff --git a/crypto/modes/asm/ghashv8-armx.pl b/crypto/modes/asm/ghashv8-armx.pl
new file mode 100644
index 0000000..300e8d5
--- /dev/null
+++ b/crypto/modes/asm/ghashv8-armx.pl
@@ -0,0 +1,376 @@
+#!/usr/bin/env perl
+#
+# ====================================================================
+# Written by Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt; for the OpenSSL
+# project. The module is, however, dual licensed under OpenSSL and
+# CRYPTOGAMS licenses depending on where you obtain it. For further
+# details see <A HREF="http://www.openssl.org/~appro/cryptogams/.">http://www.openssl.org/~appro/cryptogams/.</A>
+# ====================================================================
+#
+# GHASH for ARMv8 Crypto Extension, 64-bit polynomial multiplication.
+#
+# June 2014
+#
+# Initial version was developed in tight cooperation with Ard
+# Biesheuvel &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">ard.biesheuvel at linaro.org</A>&gt; from bits-n-pieces from
+# other assembly modules. Just like aesv8-armx.pl this module
+# supports both AArch32 and AArch64 execution modes.
+#
+# July 2014
+#
+# Implement 2x aggregated reduction [see ghash-x86.pl for background
+# information].
+#
+# Current performance in cycles per processed byte:
+#
+#		PMULL[2]	32-bit NEON(*)
+# Apple A7	0.92		5.62
+# Cortex-A53	1.01		8.39
+# Cortex-A57	1.17		7.61
+#
+# (*)	presented for reference/comparison purposes;
+
+$flavour = shift;
+$output  = shift;
+
+$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+die &quot;can't locate arm-xlate.pl&quot;;
+
+open OUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+*STDOUT=*OUT;
+
+$Xi=&quot;x0&quot;;	# argument block
+$Htbl=&quot;x1&quot;;
+$inp=&quot;x2&quot;;
+$len=&quot;x3&quot;;
+
+$inc=&quot;x12&quot;;
+
+{
+my ($Xl,$Xm,$Xh,$IN)=map(&quot;q$_&quot;,(0..3));
+my ($t0,$t1,$t2,$xC2,$H,$Hhl,$H2)=map(&quot;q$_&quot;,(8..14));
+
+$code=&lt;&lt;___;
+#include &quot;arm_arch.h&quot;
+
+.text
+___
+$code.=&quot;.arch	armv8-a+crypto\n&quot;	if ($flavour =~ /64/);
+$code.=&quot;.fpu	neon\n.code	32\n&quot;	if ($flavour !~ /64/);
+
+$code.=&lt;&lt;___;
+.global	gcm_init_v8
+.type	gcm_init_v8,%function
+.align	4
+gcm_init_v8:
+	vld1.64		{$t1},[x1]		@ load H
+	vmov.i8		$xC2,#0xe1
+	vshl.i64	$xC2,$xC2,#57		@ 0xc2.0
+	vext.8		$IN,$t1,$t1,#8
+	vshr.u64	$t2,$xC2,#63
+	vdup.32		$t1,${t1}[1]
+	vext.8		$t0,$t2,$xC2,#8		@ t0=0xc2....01
+	vshr.u64	$t2,$IN,#63
+	vshr.s32	$t1,$t1,#31		@ broadcast carry bit
+	vand		$t2,$t2,$t0
+	vshl.i64	$IN,$IN,#1
+	vext.8		$t2,$t2,$t2,#8
+	vand		$t0,$t0,$t1
+	vorr		$IN,$IN,$t2		@ H&lt;&lt;&lt;=1
+	veor		$H,$IN,$t0		@ twisted H
+	vst1.64		{$H},[x0],#16
+
+	@ calculate H^2
+	vext.8		$t0,$H,$H,#8		@ Karatsuba pre-processing
+	vpmull.p64	$Xl,$H,$H
+	veor		$t0,$t0,$H
+	vpmull2.p64	$Xh,$H,$H
+	vpmull.p64	$Xm,$t0,$t0
+
+	vext.8		$t1,$Xl,$Xh,#8		@ Karatsuba post-processing
+	veor		$t2,$Xl,$Xh
+	veor		$Xm,$Xm,$t1
+	veor		$Xm,$Xm,$t2
+	vpmull.p64	$t2,$Xl,$xC2		@ 1st phase
+
+	vmov		$Xh#lo,$Xm#hi		@ Xh|Xm - 256-bit result
+	vmov		$Xm#hi,$Xl#lo		@ Xm is rotated Xl
+	veor		$Xl,$Xm,$t2
+
+	vext.8		$t2,$Xl,$Xl,#8		@ 2nd phase
+	vpmull.p64	$Xl,$Xl,$xC2
+	veor		$t2,$t2,$Xh
+	veor		$H2,$Xl,$t2
+
+	vext.8		$t1,$H2,$H2,#8		@ Karatsuba pre-processing
+	veor		$t1,$t1,$H2
+	vext.8		$Hhl,$t0,$t1,#8		@ pack Karatsuba pre-processed
+	vst1.64		{$Hhl-$H2},[x0]
+
+	ret
+.size	gcm_init_v8,.-gcm_init_v8
+
+.global	gcm_gmult_v8
+.type	gcm_gmult_v8,%function
+.align	4
+gcm_gmult_v8:
+	vld1.64		{$t1},[$Xi]		@ load Xi
+	vmov.i8		$xC2,#0xe1
+	vld1.64		{$H-$Hhl},[$Htbl]	@ load twisted H, ...
+	vshl.u64	$xC2,$xC2,#57
+#ifndef __ARMEB__
+	vrev64.8	$t1,$t1
+#endif
+	vext.8		$IN,$t1,$t1,#8
+
+	vpmull.p64	$Xl,$H,$IN		@ H.lo&#183;Xi.lo
+	veor		$t1,$t1,$IN		@ Karatsuba pre-processing
+	vpmull2.p64	$Xh,$H,$IN		@ H.hi&#183;Xi.hi
+	vpmull.p64	$Xm,$Hhl,$t1		@ (H.lo+H.hi)&#183;(Xi.lo+Xi.hi)
+
+	vext.8		$t1,$Xl,$Xh,#8		@ Karatsuba post-processing
+	veor		$t2,$Xl,$Xh
+	veor		$Xm,$Xm,$t1
+	veor		$Xm,$Xm,$t2
+	vpmull.p64	$t2,$Xl,$xC2		@ 1st phase
+
+	vmov		$Xh#lo,$Xm#hi		@ Xh|Xm - 256-bit result
+	vmov		$Xm#hi,$Xl#lo		@ Xm is rotated Xl
+	veor		$Xl,$Xm,$t2
+
+	vext.8		$t2,$Xl,$Xl,#8		@ 2nd phase
+	vpmull.p64	$Xl,$Xl,$xC2
+	veor		$t2,$t2,$Xh
+	veor		$Xl,$Xl,$t2
+
+#ifndef __ARMEB__
+	vrev64.8	$Xl,$Xl
+#endif
+	vext.8		$Xl,$Xl,$Xl,#8
+	vst1.64		{$Xl},[$Xi]		@ write out Xi
+
+	ret
+.size	gcm_gmult_v8,.-gcm_gmult_v8
+
+.global	gcm_ghash_v8
+.type	gcm_ghash_v8,%function
+.align	4
+gcm_ghash_v8:
+___
+$code.=&lt;&lt;___		if ($flavour !~ /64/);
+	vstmdb		sp!,{d8-d15}
+___
+$code.=&lt;&lt;___;
+	vld1.64		{$Xl},[$Xi]		@ load [rotated] Xi
+	subs		$len,$len,#32
+	vmov.i8		$xC2,#0xe1
+	mov		$inc,#16
+	vld1.64		{$H-$Hhl},[$Htbl],#32	@ load twisted H, ..., H^2
+	vld1.64		{$H2},[$Htbl]
+	cclr		$inc,eq
+	vext.8		$Xl,$Xl,$Xl,#8
+	vld1.64		{$t0},[$inp],#16	@ load [rotated] I[0]
+	vshl.u64	$xC2,$xC2,#57		@ 0xc2.0
+#ifndef __ARMEB__
+	vrev64.8	$t0,$t0
+	vrev64.8	$Xl,$Xl
+#endif
+	vext.8		$IN,$t0,$t0,#8
+	b.lo		.Lodd_tail_v8
+___
+{ my ($Xln,$Xmn,$Xhn,$In) = map(&quot;q$_&quot;,(4..7));
+	#######
+	# Xi+2 =[H*(Ii+1 + Xi+1)] mod P =
+	#	[(H*Ii+1) + (H*Xi+1)] mod P =
+	#	[(H*Ii+1) + H^2*(Ii+Xi)] mod P
+	#
+$code.=&lt;&lt;___;
+	vld1.64		{$t1},[$inp],$inc	@ load [rotated] I[1]
+#ifndef __ARMEB__
+	vrev64.8	$t1,$t1
+#endif
+	vext.8		$In,$t1,$t1,#8
+	veor		$IN,$IN,$Xl		@ I[i]^=Xi
+	vpmull.p64	$Xln,$H,$In		@ H&#183;Ii+1
+	veor		$t1,$t1,$In		@ Karatsuba pre-processing
+	vpmull2.p64	$Xhn,$H,$In
+	b		.Loop_mod2x_v8
+
+.align	4
+.Loop_mod2x_v8:
+	vext.8		$t2,$IN,$IN,#8
+	subs		$len,$len,#32
+	vpmull.p64	$Xl,$H2,$IN		@ H^2.lo&#183;Xi.lo
+	cclr		$inc,lo
+
+	 vpmull.p64	$Xmn,$Hhl,$t1
+	veor		$t2,$t2,$IN		@ Karatsuba pre-processing
+	vpmull2.p64	$Xh,$H2,$IN		@ H^2.hi&#183;Xi.hi
+	veor		$Xl,$Xl,$Xln		@ accumulate
+	vpmull2.p64	$Xm,$Hhl,$t2		@ (H^2.lo+H^2.hi)&#183;(Xi.lo+Xi.hi)
+	 vld1.64	{$t0},[$inp],$inc	@ load [rotated] I[i]
+
+	veor		$Xh,$Xh,$Xhn
+	 cclr		$inc,eq
+	veor		$Xm,$Xm,$Xmn
+
+	vext.8		$t1,$Xl,$Xh,#8		@ Karatsuba post-processing
+	veor		$t2,$Xl,$Xh
+	veor		$Xm,$Xm,$t1
+	 vld1.64	{$t1},[$inp],$inc	@ load [rotated] I[i+1]
+#ifndef __ARMEB__
+	 vrev64.8	$t0,$t0
+#endif
+	veor		$Xm,$Xm,$t2
+	vpmull.p64	$t2,$Xl,$xC2		@ 1st phase
+
+#ifndef __ARMEB__
+	 vrev64.8	$t1,$t1
+#endif
+	vmov		$Xh#lo,$Xm#hi		@ Xh|Xm - 256-bit result
+	vmov		$Xm#hi,$Xl#lo		@ Xm is rotated Xl
+	 vext.8		$In,$t1,$t1,#8
+	 vext.8		$IN,$t0,$t0,#8
+	veor		$Xl,$Xm,$t2
+	 vpmull.p64	$Xln,$H,$In		@ H&#183;Ii+1
+	veor		$IN,$IN,$Xh		@ accumulate $IN early
+
+	vext.8		$t2,$Xl,$Xl,#8		@ 2nd phase
+	vpmull.p64	$Xl,$Xl,$xC2
+	veor		$IN,$IN,$t2
+	 veor		$t1,$t1,$In		@ Karatsuba pre-processing
+	veor		$IN,$IN,$Xl
+	 vpmull2.p64	$Xhn,$H,$In
+	b.hs		.Loop_mod2x_v8
+
+	veor		$Xh,$Xh,$t2
+	vext.8		$IN,$t0,$t0,#8		@ re-construct $IN
+	adds		$len,$len,#32
+	veor		$Xl,$Xl,$Xh		@ re-construct $Xl
+	b.eq		.Ldone_v8
+___
+}
+$code.=&lt;&lt;___;
+.Lodd_tail_v8:
+	vext.8		$t2,$Xl,$Xl,#8
+	veor		$IN,$IN,$Xl		@ inp^=Xi
+	veor		$t1,$t0,$t2		@ $t1 is rotated inp^Xi
+
+	vpmull.p64	$Xl,$H,$IN		@ H.lo&#183;Xi.lo
+	veor		$t1,$t1,$IN		@ Karatsuba pre-processing
+	vpmull2.p64	$Xh,$H,$IN		@ H.hi&#183;Xi.hi
+	vpmull.p64	$Xm,$Hhl,$t1		@ (H.lo+H.hi)&#183;(Xi.lo+Xi.hi)
+
+	vext.8		$t1,$Xl,$Xh,#8		@ Karatsuba post-processing
+	veor		$t2,$Xl,$Xh
+	veor		$Xm,$Xm,$t1
+	veor		$Xm,$Xm,$t2
+	vpmull.p64	$t2,$Xl,$xC2		@ 1st phase
+
+	vmov		$Xh#lo,$Xm#hi		@ Xh|Xm - 256-bit result
+	vmov		$Xm#hi,$Xl#lo		@ Xm is rotated Xl
+	veor		$Xl,$Xm,$t2
+
+	vext.8		$t2,$Xl,$Xl,#8		@ 2nd phase
+	vpmull.p64	$Xl,$Xl,$xC2
+	veor		$t2,$t2,$Xh
+	veor		$Xl,$Xl,$t2
+
+.Ldone_v8:
+#ifndef __ARMEB__
+	vrev64.8	$Xl,$Xl
+#endif
+	vext.8		$Xl,$Xl,$Xl,#8
+	vst1.64		{$Xl},[$Xi]		@ write out Xi
+
+___
+$code.=&lt;&lt;___		if ($flavour !~ /64/);
+	vldmia		sp!,{d8-d15}
+___
+$code.=&lt;&lt;___;
+	ret
+.size	gcm_ghash_v8,.-gcm_ghash_v8
+___
+}
+$code.=&lt;&lt;___;
+.asciz  &quot;GHASH for ARMv8, CRYPTOGAMS by &lt;appro\@openssl.org&gt;&quot;
+.align  2
+___
+
+if ($flavour =~ /64/) {			######## 64-bit code
+    sub unvmov {
+	my $arg=shift;
+
+	$arg =~ m/q([0-9]+)#(lo|hi),\s*q([0-9]+)#(lo|hi)/o &amp;&amp;
+	sprintf	&quot;ins	v%d.d[%d],v%d.d[%d]&quot;,$1,($2 eq &quot;lo&quot;)?0:1,$3,($4 eq &quot;lo&quot;)?0:1;
+    }
+    foreach(split(&quot;\n&quot;,$code)) {
+	s/cclr\s+([wx])([^,]+),\s*([a-z]+)/csel	$1$2,$1zr,$1$2,$3/o	or
+	s/vmov\.i8/movi/o		or	# fix up legacy mnemonics
+	s/vmov\s+(.*)/unvmov($1)/geo	or
+	s/vext\.8/ext/o			or
+	s/vshr\.s/sshr\.s/o		or
+	s/vshr/ushr/o			or
+	s/^(\s+)v/$1/o			or	# strip off v prefix
+	s/\bbx\s+lr\b/ret/o;
+
+	s/\bq([0-9]+)\b/&quot;v&quot;.($1&lt;8?$1:$1+8).&quot;.16b&quot;/geo;	# old-&gt;new registers
+	s/@\s/\/\//o;				# old-&gt;new style commentary
+
+	# fix up remainig legacy suffixes
+	s/\.[ui]?8(\s)/$1/o;
+	s/\.[uis]?32//o and s/\.16b/\.4s/go;
+	m/\.p64/o and s/\.16b/\.1q/o;		# 1st pmull argument
+	m/l\.p64/o and s/\.16b/\.1d/go;		# 2nd and 3rd pmull arguments
+	s/\.[uisp]?64//o and s/\.16b/\.2d/go;
+	s/\.[42]([sd])\[([0-3])\]/\.$1\[$2\]/o;
+
+	print $_,&quot;\n&quot;;
+    }
+} else {				######## 32-bit code
+    sub unvdup32 {
+	my $arg=shift;
+
+	$arg =~ m/q([0-9]+),\s*q([0-9]+)\[([0-3])\]/o &amp;&amp;
+	sprintf	&quot;vdup.32	q%d,d%d[%d]&quot;,$1,2*$2+($3&gt;&gt;1),$3&amp;1;
+    }
+    sub unvpmullp64 {
+	my ($mnemonic,$arg)=@_;
+
+	if ($arg =~ m/q([0-9]+),\s*q([0-9]+),\s*q([0-9]+)/o) {
+	    my $word = 0xf2a00e00|(($1&amp;7)&lt;&lt;13)|(($1&amp;8)&lt;&lt;19)
+				 |(($2&amp;7)&lt;&lt;17)|(($2&amp;8)&lt;&lt;4)
+				 |(($3&amp;7)&lt;&lt;1) |(($3&amp;8)&lt;&lt;2);
+	    $word |= 0x00010001	 if ($mnemonic =~ &quot;2&quot;);
+	    # since ARMv7 instructions are always encoded little-endian.
+	    # correct solution is to use .inst directive, but older
+	    # assemblers don't implement it:-(
+	    sprintf &quot;.byte\t0x%02x,0x%02x,0x%02x,0x%02x\t@ %s %s&quot;,
+			$word&amp;0xff,($word&gt;&gt;8)&amp;0xff,
+			($word&gt;&gt;16)&amp;0xff,($word&gt;&gt;24)&amp;0xff,
+			$mnemonic,$arg;
+	}
+    }
+
+    foreach(split(&quot;\n&quot;,$code)) {
+	s/\b[wx]([0-9]+)\b/r$1/go;		# new-&gt;old registers
+	s/\bv([0-9])\.[12468]+[bsd]\b/q$1/go;	# new-&gt;old registers
+	s/\/\/\s?/@ /o;				# new-&gt;old style commentary
+
+	# fix up remainig new-style suffixes
+	s/\],#[0-9]+/]!/o;
+
+	s/cclr\s+([^,]+),\s*([a-z]+)/mov$2	$1,#0/o			or
+	s/vdup\.32\s+(.*)/unvdup32($1)/geo				or
+	s/v?(pmull2?)\.p64\s+(.*)/unvpmullp64($1,$2)/geo		or
+	s/\bq([0-9]+)#(lo|hi)/sprintf &quot;d%d&quot;,2*$1+($2 eq &quot;hi&quot;)/geo	or
+	s/^(\s+)b\./$1b/o						or
+	s/^(\s+)ret/$1bx\tlr/o;
+
+	print $_,&quot;\n&quot;;
+    }
+}
+
+close STDOUT; # enforce flush
diff --git a/crypto/modes/gcm128.c b/crypto/modes/gcm128.c
index a52ffb1..2b4df39 100644
--- a/crypto/modes/gcm128.c
+++ b/crypto/modes/gcm128.c
@@ -645,7 +645,7 @@ static void gcm_gmult_1bit(u64 Xi[2],const u64 H[2])
 
 #endif
 
-#if	TABLE_BITS==4 &amp;&amp; defined(GHASH_ASM)
+#if	TABLE_BITS==4 &amp;&amp; (defined(GHASH_ASM) || defined(OPENSSL_CPUID_OBJ))
 # if	!defined(I386_ONLY) &amp;&amp; \
 	(defined(__i386)	|| defined(__i386__)	|| \
 	 defined(__x86_64)	|| defined(__x86_64__)	|| \
@@ -666,13 +666,22 @@ void gcm_ghash_4bit_mmx(u64 Xi[2],const u128 Htable[16],const u8 *inp,size_t len
 void gcm_gmult_4bit_x86(u64 Xi[2],const u128 Htable[16]);
 void gcm_ghash_4bit_x86(u64 Xi[2],const u128 Htable[16],const u8 *inp,size_t len);
 #  endif
-# elif defined(__arm__) || defined(__arm)
+# elif defined(__arm__) || defined(__arm) || defined(__aarch64__)
 #  include &quot;arm_arch.h&quot;
 #  if __ARM_ARCH__&gt;=7
 #   define GHASH_ASM_ARM
 #   define GCM_FUNCREF_4BIT
+#   if defined(__aarch64__)
+#    define PMULL_CAPABLE	(OPENSSL_armcap_P &amp; ARMV8_PMULL)
+#   endif
+#   if defined(__arm__) || defined(__arm)
+#    define NEON_CAPABLE	(OPENSSL_armcap_P &amp; ARMV7_NEON)
+#   endif
 void gcm_gmult_neon(u64 Xi[2],const u128 Htable[16]);
 void gcm_ghash_neon(u64 Xi[2],const u128 Htable[16],const u8 *inp,size_t len);
+void gcm_init_v8(u128 Htable[16],const u64 Xi[2]);
+void gcm_gmult_v8(u64 Xi[2],const u128 Htable[16]);
+void gcm_ghash_v8(u64 Xi[2],const u128 Htable[16],const u8 *inp,size_t len);
 #  endif
 # elif defined(_TMS320C6400_PLUS)
 #   define GHASH_ASM_C64Xplus
@@ -740,10 +749,20 @@ void CRYPTO_gcm128_init(GCM128_CONTEXT *ctx,void *key,block128_f block)
 	ctx-&gt;ghash = gcm_ghash_4bit;
 #  endif
 # elif	defined(GHASH_ASM_ARM)
-	if (OPENSSL_armcap_P &amp; ARMV7_NEON) {
+#  ifdef PMULL_CAPABLE
+	if (PMULL_CAPABLE) {
+		gcm_init_v8(ctx-&gt;Htable,ctx-&gt;H.u);
+		ctx-&gt;gmult = gcm_gmult_v8;
+		ctx-&gt;ghash = gcm_ghash_v8;
+	} else
+#  endif
+#  ifdef NEON_CAPABLE
+	if (NEON_CAPABLE) {
 		ctx-&gt;gmult = gcm_gmult_neon;
 		ctx-&gt;ghash = gcm_ghash_neon;
-	} else {
+	} else
+#  endif
+	{
 		gcm_init_4bit(ctx-&gt;Htable,ctx-&gt;H.u);
 		ctx-&gt;gmult = gcm_gmult_4bit;
 		ctx-&gt;ghash = gcm_ghash_4bit;
diff --git a/crypto/perlasm/arm-xlate.pl b/crypto/perlasm/arm-xlate.pl
new file mode 100644
index 0000000..22dc7e4
--- /dev/null
+++ b/crypto/perlasm/arm-xlate.pl
@@ -0,0 +1,165 @@
+#!/usr/bin/env perl
+
+# ARM assembler distiller by &lt;appro&gt;.
+
+my $flavour = shift;
+my $output = shift;
+open STDOUT,&quot;&gt;$output&quot; || die &quot;can't open $output: $!&quot;;
+
+$flavour = &quot;linux32&quot; if (!$flavour or $flavour eq &quot;void&quot;);
+
+my %GLOBALS;
+my $dotinlocallabels=($flavour=~/linux/)?1:0;
+
+################################################################
+# directives which need special treatment on different platforms
+################################################################
+my $arch = sub {
+    if ($flavour =~ /linux/)	{ &quot;.arch\t&quot;.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at _</A>); }
+    else			{ &quot;&quot;; }
+};
+my $fpu = sub {
+    if ($flavour =~ /linux/)	{ &quot;.fpu\t&quot;.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at _</A>); }
+    else			{ &quot;&quot;; }
+};
+my $hidden = sub {
+    if ($flavour =~ /ios/)	{ &quot;.private_extern\t&quot;.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at _</A>); }
+    else			{ &quot;.hidden\t&quot;.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at _</A>); }
+};
+my $comm = sub {
+    my @args = split(/,\s*/,shift);
+    my $name = @args[0];
+    my $global = \$GLOBALS{$name};
+    my $ret;
+
+    if ($flavour =~ /ios32/)	{
+	$ret = &quot;.comm\t_$<A HREF="../../../mailman/listinfo/openssl-commits.html">name, at args</A>[1]\n&quot;;
+	$ret .= &quot;.non_lazy_symbol_pointer\n&quot;;
+	$ret .= &quot;$name:\n&quot;;
+	$ret .= &quot;.indirect_symbol\t_$name\n&quot;;
+	$ret .= &quot;.long\t0&quot;;
+	$name = &quot;_$name&quot;;
+    } else			{ $ret = &quot;.comm\t&quot;.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at args</A>); }
+
+    $$global = $name;
+    $ret;
+};
+my $globl = sub {
+    my $name = shift;
+    my $global = \$GLOBALS{$name};
+    my $ret;
+
+    SWITCH: for ($flavour) {
+	/ios/		&amp;&amp; do { $name = &quot;_$name&quot;;
+				last;
+			      };
+    }
+
+    $ret = &quot;.globl	$name&quot; if (!$ret);
+    $$global = $name;
+    $ret;
+};
+my $global = $globl;
+my $extern = sub {
+    &amp;$globl(@_);
+    return;	# return nothing
+};
+my $type = sub {
+    if ($flavour =~ /linux/)	{ &quot;.type\t&quot;.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at _</A>); }
+    else			{ &quot;&quot;; }
+};
+my $size = sub {
+    if ($flavour =~ /linux/)	{ &quot;.size\t&quot;.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at _</A>); }
+    else			{ &quot;&quot;; }
+};
+my $inst = sub {
+    if ($flavour =~ /linux/)    { &quot;.inst\t&quot;.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at _</A>); }
+    else                        { &quot;.long\t&quot;.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at _</A>); }
+};
+my $asciz = sub {
+    my $line = join(&quot;,&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at _</A>);
+    if ($line =~ /^&quot;(.*)&quot;$/)
+    {	&quot;.byte	&quot; . join(&quot;,&quot;,unpack(&quot;C*&quot;,$1),0) . &quot;\n.align	2&quot;;	}
+    else
+    {	&quot;&quot;;	}
+};
+
+sub range {
+  my ($r,$sfx,$start,$end) = @_;
+
+    join(&quot;,&quot;,map(&quot;$r$_$sfx&quot;,($start..$end)));
+}
+
+sub expand_line {
+  my $line = shift;
+  my @ret = ();
+
+    pos($line)=0;
+
+    while ($line =~ m/\G[^@\/\{\&quot;]*/g) {
+	if ($line =~ m/\G(@|\/\/|$)/gc) {
+	    last;
+	}
+	elsif ($line =~ m/\G\{/gc) {
+	    my $saved_pos = pos($line);
+	    $line =~ s/\G([rdqv])([0-9]+)([^\-]*)\-\1([0-9]+)\3/range($1,$3,$2,$4)/e;
+	    pos($line) = $saved_pos;
+	    $line =~ m/\G[^\}]*\}/g;
+	}
+	elsif ($line =~ m/\G\&quot;/gc) {
+	    $line =~ m/\G[^\&quot;]*\&quot;/g;
+	}
+    }
+
+    $line =~ s/\b(\w+)/$GLOBALS{$1} or $1/ge;
+
+    return $line;
+}
+
+while($line=&lt;&gt;) {
+
+    if ($line =~ m/^\s*(#|@|\/\/)/)	{ print $line; next; }
+
+    $line =~ s|/\*.*\*/||;	# get rid of C-style comments...
+    $line =~ s|^\s+||;		# ... and skip white spaces in beginning...
+    $line =~ s|\s+$||;		# ... and at the end
+
+    {
+	$line =~ s|[\b\.]L(\w{2,})|L$1|g;	# common denominator for Locallabel
+	$line =~ s|\bL(\w{2,})|\.L$1|g	if ($dotinlocallabels);
+    }
+
+    {
+	$line =~ s|(^[\.\w]+)\:\s*||;
+	my $label = $1;
+	if ($label) {
+	    printf &quot;%s:&quot;,($GLOBALS{$label} or $label);
+	}
+    }
+
+    if ($line !~ m/^[#@]/) {
+	$line =~ s|^\s*(\.?)(\S+)\s*||;
+	my $c = $1; $c = &quot;\t&quot; if ($c eq &quot;&quot;);
+	my $mnemonic = $2;
+	my $opcode;
+	if ($mnemonic =~ m/([^\.]+)\.([^\.]+)/) {
+	    $opcode = eval(&quot;\$$1_$2&quot;);
+	} else {
+	    $opcode = eval(&quot;\$$mnemonic&quot;);
+	}
+
+	my $arg=expand_line($line);
+
+	if (ref($opcode) eq 'CODE') {
+		$line = &amp;$opcode($arg);
+	} elsif ($mnemonic)         {
+		$line = $c.$mnemonic;
+		$line.= &quot;\t$arg&quot; if ($arg);
+	}
+    }
+
+    print $line if ($line);
+    print &quot;\n&quot;;
+}
+
+close STDOUT;
diff --git a/crypto/sha/Makefile b/crypto/sha/Makefile
index b1582f2..63e1171 100644
--- a/crypto/sha/Makefile
+++ b/crypto/sha/Makefile
@@ -90,6 +90,9 @@ sha512-%.S:	asm/sha512-%.pl;	$(PERL) $&lt; $(PERLASM_SCHEME) $@
 sha1-armv4-large.o:	sha1-armv4-large.S
 sha256-armv4.o:		sha256-armv4.S
 sha512-armv4.o:		sha512-armv4.S
+sha1-armv8.o:		sha1-armv8.S
+sha256-armv8.o:		sha256-armv8.S
+sha512-armv8.o:		sha512-armv8.S
 
 files:
 	$(PERL) $(TOP)/util/files.pl Makefile &gt;&gt; $(TOP)/MINFO
diff --git a/crypto/sha/asm/sha1-armv4-large.pl b/crypto/sha/asm/sha1-armv4-large.pl
index 33da3e0..6c0adb9 100644
--- a/crypto/sha/asm/sha1-armv4-large.pl
+++ b/crypto/sha/asm/sha1-armv4-large.pl
@@ -52,8 +52,20 @@
 # Profiler-assisted and platform-specific optimization resulted in 10%
 # improvement on Cortex A8 core and 12.2 cycles per byte.
 
-while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {}
-open STDOUT,&quot;&gt;$output&quot;;
+$flavour = shift;
+if ($flavour=~/^\w[\w\-]*\.\w+$/) { $output=$flavour; undef $flavour; }
+else { while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {} }
+
+if ($flavour &amp;&amp; $flavour ne &quot;void&quot;) {
+    $0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+    ( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+    ( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+    die &quot;can't locate arm-xlate.pl&quot;;
+
+    open STDOUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+} else {
+    open STDOUT,&quot;&gt;$output&quot;;
+}
 
 $ctx=&quot;r0&quot;;
 $inp=&quot;r1&quot;;
diff --git a/crypto/sha/asm/sha1-armv8.pl b/crypto/sha/asm/sha1-armv8.pl
new file mode 100644
index 0000000..6be8624
--- /dev/null
+++ b/crypto/sha/asm/sha1-armv8.pl
@@ -0,0 +1,343 @@
+#!/usr/bin/env perl
+#
+# ====================================================================
+# Written by Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt; for the OpenSSL
+# project. The module is, however, dual licensed under OpenSSL and
+# CRYPTOGAMS licenses depending on where you obtain it. For further
+# details see <A HREF="http://www.openssl.org/~appro/cryptogams/.">http://www.openssl.org/~appro/cryptogams/.</A>
+# ====================================================================
+#
+# SHA1 for ARMv8.
+#
+# Performance in cycles per processed byte and improvement coefficient
+# over code generated with &quot;default&quot; compiler:
+#
+#		hardware-assisted	software(*)
+# Apple A7	2.31			4.13 (+14%)
+# Cortex-A53	2.19			8.73 (+108%)
+# Cortex-A57	2.35			7.88 (+74%)
+#
+# (*)	Software results are presented mostly for reference purposes.
+
+$flavour = shift;
+$output  = shift;
+
+$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+die &quot;can't locate arm-xlate.pl&quot;;
+
+open OUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+*STDOUT=*OUT;
+
+($ctx,$inp,$num)=(&quot;x0&quot;,&quot;x1&quot;,&quot;x2&quot;);
<A HREF="../../../mailman/listinfo/openssl-commits.html">+ at Xw</A>=map(&quot;w$_&quot;,(3..17,19));
<A HREF="../../../mailman/listinfo/openssl-commits.html">+ at Xx</A>=map(&quot;x$_&quot;,(3..17,19));
<A HREF="../../../mailman/listinfo/openssl-commits.html">+ at V</A>=($A,$B,$C,$D,$E)=map(&quot;w$_&quot;,(20..24));
+($t0,$t1,$t2,$K)=map(&quot;w$_&quot;,(25..28));
+
+
+sub BODY_00_19 {
+my ($i,$a,$b,$c,$d,$e)=@_;
+my $j=($i+2)&amp;15;
+
+$code.=&lt;&lt;___ if ($i&lt;15 &amp;&amp; !($i&amp;1));
+	lsr	@Xx[$i+1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xx</A>[$i],#32
+___
+$code.=&lt;&lt;___ if ($i&lt;14 &amp;&amp; !($i&amp;1));
+	ldr	@Xx[$i+2],[$inp,#`($i+2)*4-64`]
+___
+$code.=&lt;&lt;___ if ($i&lt;14 &amp;&amp; ($i&amp;1));
+#ifdef	__ARMEB__
+	ror	@Xx[$i+1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xx</A>[$i+1],#32
+#else
+	rev32	@Xx[$i+1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xx</A>[$i+1]
+#endif
+___
+$code.=&lt;&lt;___ if ($i&lt;14);
+	bic	$t0,$d,$b
+	and	$t1,$c,$b
+	ror	$t2,$a,#27
+	add	$d,$d,$K		// future e+=K
+	orr	$t0,$t0,$t1
+	add	$e,$e,$t2		// e+=rot(a,5)
+	ror	$b,$b,#2
+	add	$d,$<A HREF="../../../mailman/listinfo/openssl-commits.html">d, at Xw</A>[($i+1)&amp;15]	// future e+=X[i]
+	add	$e,$e,$t0		// e+=F(b,c,d)
+___
+$code.=&lt;&lt;___ if ($i==19);
+	movz	$K,#0xeba1
+	movk	$K,#0x6ed9,lsl#16
+___
+$code.=&lt;&lt;___ if ($i&gt;=14);
+	 eor	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[($j+2)&amp;15]
+	bic	$t0,$d,$b
+	and	$t1,$c,$b
+	ror	$t2,$a,#27
+	 eor	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[($j+8)&amp;15]
+	add	$d,$d,$K		// future e+=K
+	orr	$t0,$t0,$t1
+	add	$e,$e,$t2		// e+=rot(a,5)
+	 eor	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[($j+13)&amp;15]
+	ror	$b,$b,#2
+	add	$d,$<A HREF="../../../mailman/listinfo/openssl-commits.html">d, at Xw</A>[($i+1)&amp;15]	// future e+=X[i]
+	add	$e,$e,$t0		// e+=F(b,c,d)
+	 ror	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j],#31
+___
+}
+
+sub BODY_40_59 {
+my ($i,$a,$b,$c,$d,$e)=@_;
+my $j=($i+2)&amp;15;
+
+$code.=&lt;&lt;___ if ($i==59);
+	movz	$K,#0xc1d6
+	movk	$K,#0xca62,lsl#16
+___
+$code.=&lt;&lt;___;
+	orr	$t0,$b,$c
+	and	$t1,$b,$c
+	 eor	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[($j+2)&amp;15]
+	ror	$t2,$a,#27
+	and	$t0,$t0,$d
+	add	$d,$d,$K		// future e+=K
+	 eor	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[($j+8)&amp;15]
+	add	$e,$e,$t2		// e+=rot(a,5)
+	orr	$t0,$t0,$t1
+	ror	$b,$b,#2
+	 eor	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[($j+13)&amp;15]
+	add	$d,$<A HREF="../../../mailman/listinfo/openssl-commits.html">d, at Xw</A>[($i+1)&amp;15]	// future e+=X[i]
+	add	$e,$e,$t0		// e+=F(b,c,d)
+	 ror	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j],#31
+___
+}
+
+sub BODY_20_39 {
+my ($i,$a,$b,$c,$d,$e)=@_;
+my $j=($i+2)&amp;15;
+
+$code.=&lt;&lt;___ if ($i==39);
+	movz	$K,#0xbcdc
+	movk	$K,#0x8f1b,lsl#16
+___
+$code.=&lt;&lt;___ if ($i&lt;78);
+	 eor	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[($j+2)&amp;15]
+	eor	$t0,$d,$b
+	ror	$t2,$a,#27
+	add	$d,$d,$K		// future e+=K
+	 eor	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[($j+8)&amp;15]
+	eor	$t0,$t0,$c
+	add	$e,$e,$t2		// e+=rot(a,5)
+	ror	$b,$b,#2
+	 eor	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[($j+13)&amp;15]
+	add	$d,$<A HREF="../../../mailman/listinfo/openssl-commits.html">d, at Xw</A>[($i+1)&amp;15]	// future e+=X[i]
+	add	$e,$e,$t0		// e+=F(b,c,d)
+	 ror	@Xw[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[$j],#31
+___
+$code.=&lt;&lt;___ if ($i==78);
+	ldp	@Xw[1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[2],[$ctx]
+	eor	$t0,$d,$b
+	ror	$t2,$a,#27
+	add	$d,$d,$K		// future e+=K
+	eor	$t0,$t0,$c
+	add	$e,$e,$t2		// e+=rot(a,5)
+	ror	$b,$b,#2
+	add	$d,$<A HREF="../../../mailman/listinfo/openssl-commits.html">d, at Xw</A>[($i+1)&amp;15]	// future e+=X[i]
+	add	$e,$e,$t0		// e+=F(b,c,d)
+___
+$code.=&lt;&lt;___ if ($i==79);
+	ldp	@Xw[3]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xw</A>[4],[$ctx,#8]
+	eor	$t0,$d,$b
+	ror	$t2,$a,#27
+	eor	$t0,$t0,$c
+	add	$e,$e,$t2		// e+=rot(a,5)
+	ror	$b,$b,#2
+	ldr	@Xw[5],[$ctx,#16]
+	add	$e,$e,$t0		// e+=F(b,c,d)
+___
+}
+
+$code.=&lt;&lt;___;
+#include &quot;arm_arch.h&quot;
+
+.text
+
+.extern	OPENSSL_armcap_P
+.globl	sha1_block_data_order
+.type	sha1_block_data_order,%function
+.align	6
+sha1_block_data_order:
+	ldr	x16,.LOPENSSL_armcap_P
+	adr	x17,.LOPENSSL_armcap_P
+	add	x16,x16,x17
+	ldr	w16,[x16]
+	tst	w16,#ARMV8_SHA1
+	b.ne	.Lv8_entry
+
+	stp	x29,x30,[sp,#-96]!
+	add	x29,sp,#0
+	stp	x19,x20,[sp,#16]
+	stp	x21,x22,[sp,#32]
+	stp	x23,x24,[sp,#48]
+	stp	x25,x26,[sp,#64]
+	stp	x27,x28,[sp,#80]
+
+	ldp	$A,$B,[$ctx]
+	ldp	$C,$D,[$ctx,#8]
+	ldr	$E,[$ctx,#16]
+
+.Loop:
+	ldr	@Xx[0],[$inp],#64
+	movz	$K,#0x7999
+	sub	$num,$num,#1
+	movk	$K,#0x5a82,lsl#16
+#ifdef	__ARMEB__
+	ror	$Xx[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xx</A>[0],#32
+#else
+	rev32	@Xx[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at Xx</A>[0]
+#endif
+	add	$E,$E,$K		// warm it up
+	add	$E,$<A HREF="../../../mailman/listinfo/openssl-commits.html">E, at Xw</A>[0]
+___
+for($i=0;$i&lt;20;$i++)	{ &amp;BODY_00_19($<A HREF="../../../mailman/listinfo/openssl-commits.html">i, at V</A>); unshift(@V,pop(@V)); }
+for(;$i&lt;40;$i++)	{ &amp;BODY_20_39($<A HREF="../../../mailman/listinfo/openssl-commits.html">i, at V</A>); unshift(@V,pop(@V)); }
+for(;$i&lt;60;$i++)	{ &amp;BODY_40_59($<A HREF="../../../mailman/listinfo/openssl-commits.html">i, at V</A>); unshift(@V,pop(@V)); }
+for(;$i&lt;80;$i++)	{ &amp;BODY_20_39($<A HREF="../../../mailman/listinfo/openssl-commits.html">i, at V</A>); unshift(@V,pop(@V)); }
+$code.=&lt;&lt;___;
+	add	$B,$<A HREF="../../../mailman/listinfo/openssl-commits.html">B, at Xw</A>[2]
+	add	$C,$<A HREF="../../../mailman/listinfo/openssl-commits.html">C, at Xw</A>[3]
+	add	$A,$<A HREF="../../../mailman/listinfo/openssl-commits.html">A, at Xw</A>[1]
+	add	$D,$<A HREF="../../../mailman/listinfo/openssl-commits.html">D, at Xw</A>[4]
+	add	$E,$<A HREF="../../../mailman/listinfo/openssl-commits.html">E, at Xw</A>[5]
+	stp	$A,$B,[$ctx]
+	stp	$C,$D,[$ctx,#8]
+	str	$E,[$ctx,#16]
+	cbnz	$num,.Loop
+
+	ldp	x19,x20,[sp,#16]
+	ldp	x21,x22,[sp,#32]
+	ldp	x23,x24,[sp,#48]
+	ldp	x25,x26,[sp,#64]
+	ldp	x27,x28,[sp,#80]
+	ldr	x29,[sp],#96
+	ret
+.size	sha1_block_data_order,.-sha1_block_data_order
+___
+{{{
+my ($ABCD,$E,$E0,$E1)=map(&quot;v$_.16b&quot;,(0..3));
+my @MSG=map(&quot;v$_.16b&quot;,(4..7));
+my @Kxx=map(&quot;v$_.4s&quot;,(16..19));
+my ($W0,$W1)=(&quot;v20.4s&quot;,&quot;v21.4s&quot;);
+my $ABCD_SAVE=&quot;v22.16b&quot;;
+
+$code.=&lt;&lt;___;
+.type	sha1_block_armv8,%function
+.align	6
+sha1_block_armv8:
+.Lv8_entry:
+	stp	x29,x30,[sp,#-16]!
+	add	x29,sp,#0
+
+	adr	x4,.Lconst
+	eor	$E,$E,$E
+	ld1.32	{$ABCD},[$ctx],#16
+	ld1.32	{$E}[0],[$ctx]
+	sub	$ctx,$ctx,#16
+	ld1.32	{@Kxx[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">- at Kxx</A>[3]},[x4]
+
+.Loop_hw:
+	ld1	{@MSG[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">- at MSG</A>[3]},[$inp],#64
+	sub	$num,$num,#1
+	rev32	@MSG[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[0]
+	rev32	@MSG[1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[1]
+
+	add.i32	$<A HREF="../../../mailman/listinfo/openssl-commits.html">W0, at Kxx</A>[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[0]
+	rev32	@MSG[2]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[2]
+	orr	$ABCD_SAVE,$ABCD,$ABCD	// offload
+
+	add.i32	$<A HREF="../../../mailman/listinfo/openssl-commits.html">W1, at Kxx</A>[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[1]
+	rev32	@MSG[3]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[3]
+	sha1h	$E1,$ABCD
+	sha1c	$ABCD,$E,$W0		// 0
+	add.i32	$<A HREF="../../../mailman/listinfo/openssl-commits.html">W0, at Kxx</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[2]
+	sha1su0	@MSG[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[2]
+___
+for ($j=0,$i=1;$i&lt;20-3;$i++) {
+my $f=(&quot;c&quot;,&quot;p&quot;,&quot;m&quot;,&quot;p&quot;)[$i/5];
+$code.=&lt;&lt;___;
+	sha1h	$E0,$ABCD		// $i
+	sha1$f	$ABCD,$E1,$W1
+	add.i32	$<A HREF="../../../mailman/listinfo/openssl-commits.html">W1, at Kxx</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[3]
+	sha1su1	@MSG[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[3]
+___
+$code.=&lt;&lt;___ if ($i&lt;20-4);
+	sha1su0	@MSG[1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[2]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[3]
+___
+	($E0,$E1)=($E1,$E0);		($W0,$W1)=($W1,$W0);
+	push(@MSG,shift(@MSG));		$j++ if ((($i+3)%5)==0);
+}
+$code.=&lt;&lt;___;
+	sha1h	$E0,$ABCD		// $i
+	sha1p	$ABCD,$E1,$W1
+	add.i32	$<A HREF="../../../mailman/listinfo/openssl-commits.html">W1, at Kxx</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[3]
+
+	sha1h	$E1,$ABCD		// 18
+	sha1p	$ABCD,$E0,$W0
+
+	sha1h	$E0,$ABCD		// 19
+	sha1p	$ABCD,$E1,$W1
+
+	add.i32	$E,$E,$E0
+	add.i32	$ABCD,$ABCD,$ABCD_SAVE
+
+	cbnz	$num,.Loop_hw
+
+	st1.32	{$ABCD},[$ctx],#16
+	st1.32	{$E}[0],[$ctx]
+
+	ldr	x29,[sp],#16
+	ret
+.size	sha1_block_armv8,.-sha1_block_armv8
+.align	6
+.Lconst:
+.long	0x5a827999,0x5a827999,0x5a827999,0x5a827999	//K_00_19
+.long	0x6ed9eba1,0x6ed9eba1,0x6ed9eba1,0x6ed9eba1	//K_20_39
+.long	0x8f1bbcdc,0x8f1bbcdc,0x8f1bbcdc,0x8f1bbcdc	//K_40_59
+.long	0xca62c1d6,0xca62c1d6,0xca62c1d6,0xca62c1d6	//K_60_79
+.LOPENSSL_armcap_P:
+.quad	OPENSSL_armcap_P-.
+.asciz	&quot;SHA1 block transform for ARMv8, CRYPTOGAMS by &lt;appro\@openssl.org&gt;&quot;
+.align	2
+.comm	OPENSSL_armcap_P,4,4
+___
+}}}
+
+{   my	%opcode = (
+	&quot;sha1c&quot;		=&gt; 0x5e000000,	&quot;sha1p&quot;		=&gt; 0x5e001000,
+	&quot;sha1m&quot;		=&gt; 0x5e002000,	&quot;sha1su0&quot;	=&gt; 0x5e003000,
+	&quot;sha1h&quot;		=&gt; 0x5e280800,	&quot;sha1su1&quot;	=&gt; 0x5e281800	);
+
+    sub unsha1 {
+	my ($mnemonic,$arg)=@_;
+
+	$arg =~ m/[qv]([0-9]+)[^,]*,\s*[qv]([0-9]+)[^,]*(?:,\s*[qv]([0-9]+))?/o
+	&amp;&amp;
+	sprintf &quot;.inst\t0x%08x\t//%s %s&quot;,
+			$opcode{$mnemonic}|$1|($2&lt;&lt;5)|($3&lt;&lt;16),
+			$mnemonic,$arg;
+    }
+}
+
+foreach(split(&quot;\n&quot;,$code)) {
+
+	s/\`([^\`]*)\`/eval($1)/geo;
+
+	s/\b(sha1\w+)\s+([qv].*)/unsha1($1,$2)/geo;
+
+	s/\.\w?32\b//o		and s/\.16b/\.4s/go;
+	m/(ld|st)1[^\[]+\[0\]/o	and s/\.4s/\.s/go;
+
+	print $_,&quot;\n&quot;;
+}
+
+close STDOUT;
diff --git a/crypto/sha/asm/sha256-armv4.pl b/crypto/sha/asm/sha256-armv4.pl
index 9c84e8d..252a583 100644
--- a/crypto/sha/asm/sha256-armv4.pl
+++ b/crypto/sha/asm/sha256-armv4.pl
@@ -23,8 +23,20 @@
 # Profiler-assisted and platform-specific optimization resulted in 16%
 # improvement on Cortex A8 core and ~17 cycles per processed byte.
 
-while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {}
-open STDOUT,&quot;&gt;$output&quot;;
+$flavour = shift;
+if ($flavour=~/^\w[\w\-]*\.\w+$/) { $output=$flavour; undef $flavour; }
+else { while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {} }
+
+if ($flavour &amp;&amp; $flavour ne &quot;void&quot;) {
+    $0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+    ( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+    ( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+    die &quot;can't locate arm-xlate.pl&quot;;
+
+    open STDOUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+} else {
+    open STDOUT,&quot;&gt;$output&quot;;
+}
 
 $ctx=&quot;r0&quot;;	$t0=&quot;r0&quot;;
 $inp=&quot;r1&quot;;	$t3=&quot;r1&quot;;
diff --git a/crypto/sha/asm/sha512-armv4.pl b/crypto/sha/asm/sha512-armv4.pl
index 7faf37b..c032afd 100644
--- a/crypto/sha/asm/sha512-armv4.pl
+++ b/crypto/sha/asm/sha512-armv4.pl
@@ -38,8 +38,20 @@ $hi=&quot;HI&quot;;
 $lo=&quot;LO&quot;;
 # ====================================================================
 
-while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {}
-open STDOUT,&quot;&gt;$output&quot;;
+$flavour = shift;
+if ($flavour=~/^\w[\w\-]*\.\w+$/) { $output=$flavour; undef $flavour; }
+else { while (($output=shift) &amp;&amp; ($output!~/^\w[\w\-]*\.\w+$/)) {} }
+
+if ($flavour &amp;&amp; $flavour ne &quot;void&quot;) {
+    $0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+    ( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+    ( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+    die &quot;can't locate arm-xlate.pl&quot;;
+
+    open STDOUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+} else {
+    open STDOUT,&quot;&gt;$output&quot;;
+}
 
 $ctx=&quot;r0&quot;;	# parameter block
 $inp=&quot;r1&quot;;
@@ -221,17 +233,21 @@ WORD64(0x4cc5d4be,0xcb3e42b6, 0x597f299c,0xfc657e2a)
 WORD64(0x5fcb6fab,0x3ad6faec, 0x6c44198c,0x4a475817)
 .size	K512,.-K512
 .LOPENSSL_armcap:
-.word	OPENSSL_armcap_P-sha512_block_data_order
+.word	OPENSSL_armcap_P-.Lsha512_block_data_order
 .skip	32-4
 
 .global	sha512_block_data_order
 .type	sha512_block_data_order,%function
 sha512_block_data_order:
+.Lsha512_block_data_order:
 	sub	r3,pc,#8		@ sha512_block_data_order
 	add	$len,$inp,$len,lsl#7	@ len to point at the end of inp
 #if __ARM_ARCH__&gt;=7
 	ldr	r12,.LOPENSSL_armcap
 	ldr	r12,[r3,r12]		@ OPENSSL_armcap_P
+#ifdef	__APPLE__
+	ldr	r12,[r12]
+#endif
 	tst	r12,#1
 	bne	.LNEON
 #endif
diff --git a/crypto/sha/asm/sha512-armv8.pl b/crypto/sha/asm/sha512-armv8.pl
new file mode 100644
index 0000000..45eb719
--- /dev/null
+++ b/crypto/sha/asm/sha512-armv8.pl
@@ -0,0 +1,428 @@
+#!/usr/bin/env perl
+#
+# ====================================================================
+# Written by Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt; for the OpenSSL
+# project. The module is, however, dual licensed under OpenSSL and
+# CRYPTOGAMS licenses depending on where you obtain it. For further
+# details see <A HREF="http://www.openssl.org/~appro/cryptogams/.">http://www.openssl.org/~appro/cryptogams/.</A>
+# ====================================================================
+#
+# SHA256/512 for ARMv8.
+#
+# Performance in cycles per processed byte and improvement coefficient
+# over code generated with &quot;default&quot; compiler:
+#
+#		SHA256-hw	SHA256(*)	SHA512
+# Apple A7	1.97		10.5 (+33%)	6.73 (-1%(**))
+# Cortex-A53	2.38		15.6 (+110%)	10.1 (+190%(***))
+# Cortex-A57	2.31		11.6 (+86%)	7.51 (+260%(***))
+# 
+# (*)	Software SHA256 results are of lesser relevance, presented
+#	mostly for informational purposes.
+# (**)	The result is a trade-off: it's possible to improve it by
+#	10% (or by 1 cycle per round), but at the cost of 20% loss
+#	on Cortex-A53 (or by 4 cycles per round).
+# (***)	Super-impressive coefficients over gcc-generated code are
+#	indication of some compiler &quot;pathology&quot;, most notably code
+#	generated with -mgeneral-regs-only is significanty faster
+#	and lags behind assembly only by 50-90%.
+
+$flavour=shift;
+$output=shift;
+
+$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+( $xlate=&quot;${dir}arm-xlate.pl&quot; and -f $xlate ) or
+( $xlate=&quot;${dir}../../perlasm/arm-xlate.pl&quot; and -f $xlate) or
+die &quot;can't locate arm-xlate.pl&quot;;
+
+open OUT,&quot;| \&quot;$^X\&quot; $xlate $flavour $output&quot;;
+*STDOUT=*OUT;
+
+if ($output =~ /512/) {
+	$BITS=512;
+	$SZ=8;
+	@Sigma0=(28,34,39);
+	@Sigma1=(14,18,41);
+	@sigma0=(1,  8, 7);
+	@sigma1=(19,61, 6);
+	$rounds=80;
+	$reg_t=&quot;x&quot;;
+} else {
+	$BITS=256;
+	$SZ=4;
+	@Sigma0=( 2,13,22);
+	@Sigma1=( 6,11,25);
+	@sigma0=( 7,18, 3);
+	@sigma1=(17,19,10);
+	$rounds=64;
+	$reg_t=&quot;w&quot;;
+}
+
+$func=&quot;sha${BITS}_block_data_order&quot;;
+
+($ctx,$inp,$num,$Ktbl)=map(&quot;x$_&quot;,(0..2,30));
+
<A HREF="../../../mailman/listinfo/openssl-commits.html">+ at X</A>=map(&quot;$reg_t$_&quot;,(3..15,0..2));
<A HREF="../../../mailman/listinfo/openssl-commits.html">+ at V</A>=($A,$B,$C,$D,$E,$F,$G,$H)=map(&quot;$reg_t$_&quot;,(20..27));
+($t0,$t1,$t2,$t3)=map(&quot;$reg_t$_&quot;,(16,17,19,28));
+
+sub BODY_00_xx {
+my ($i,$a,$b,$c,$d,$e,$f,$g,$h)=@_;
+my $j=($i+1)&amp;15;
+my ($T0,$T1,$T2)=(@X[($i-8)&amp;15]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[($i-9)&amp;15]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[($i-10)&amp;15]);
+   $T0=@X[$i+3] if ($i&lt;11);
+
+$code.=&lt;&lt;___	if ($i&lt;16);
+#ifndef	__ARMEB__
+	rev	@X[$i]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[$i]			// $i
+#endif
+___
+$code.=&lt;&lt;___	if ($i&lt;13 &amp;&amp; ($i&amp;1));
+	ldp	@X[$i+1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[$i+2],[$inp],#2*$SZ
+___
+$code.=&lt;&lt;___	if ($i==13);
+	ldp	@X[14]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[15],[$inp]
+___
+$code.=&lt;&lt;___	if ($i&gt;=14);
+	ldr	@X[($i-11)&amp;15],[sp,#`$SZ*(($i-11)%4)`]
+___
+$code.=&lt;&lt;___	if ($i&gt;0 &amp;&amp; $i&lt;16);
+	add	$a,$a,$t1			// h+=Sigma0(a)
+___
+$code.=&lt;&lt;___	if ($i&gt;=11);
+	str	@X[($i-8)&amp;15],[sp,#`$SZ*(($i-8)%4)`]
+___
+# While ARMv8 specifies merged rotate-n-logical operation such as
+# 'eor x,y,z,ror#n', it was found to negatively affect performance
+# on Apple A7. The reason seems to be that it requires even 'y' to
+# be available earlier. This means that such merged instruction is
+# not necessarily best choice on critical path... On the other hand
+# Cortex-A5x handles merged instructions much better than disjoint
+# rotate and logical... See (**) footnote above.
+$code.=&lt;&lt;___	if ($i&lt;15);
+	ror	$t0,$e,#$Sigma1[0]
+	add	$h,$h,$t2			// h+=K[i]
+	eor	$T0,$e,$e,ror#`$Sigma1[2]-$Sigma1[1]`
+	and	$t1,$f,$e
+	bic	$t2,$g,$e
+	add	$h,$<A HREF="../../../mailman/listinfo/openssl-commits.html">h, at X</A>[$i&amp;15]			// h+=X[i]
+	orr	$t1,$t1,$t2			// Ch(e,f,g)
+	eor	$t2,$a,$b			// a^b, b^c in next round
+	eor	$t0,$t0,$T0,ror#$Sigma1[1]	// Sigma1(e)
+	ror	$T0,$a,#$Sigma0[0]
+	add	$h,$h,$t1			// h+=Ch(e,f,g)
+	eor	$t1,$a,$a,ror#`$Sigma0[2]-$Sigma0[1]`
+	add	$h,$h,$t0			// h+=Sigma1(e)
+	and	$t3,$t3,$t2			// (b^c)&amp;=(a^b)
+	add	$d,$d,$h			// d+=h
+	eor	$t3,$t3,$b			// Maj(a,b,c)
+	eor	$t1,$T0,$t1,ror#$Sigma0[1]	// Sigma0(a)
+	add	$h,$h,$t3			// h+=Maj(a,b,c)
+	ldr	$t3,[$Ktbl],#$SZ		// *K++, $t2 in next round
+	//add	$h,$h,$t1			// h+=Sigma0(a)
+___
+$code.=&lt;&lt;___	if ($i&gt;=15);
+	ror	$t0,$e,#$Sigma1[0]
+	add	$h,$h,$t2			// h+=K[i]
+	ror	$<A HREF="../../../mailman/listinfo/openssl-commits.html">T1, at X</A>[($j+1)&amp;15],#$sigma0[0]
+	and	$t1,$f,$e
+	ror	$<A HREF="../../../mailman/listinfo/openssl-commits.html">T2, at X</A>[($j+14)&amp;15],#$sigma1[0]
+	bic	$t2,$g,$e
+	ror	$T0,$a,#$Sigma0[0]
+	add	$h,$<A HREF="../../../mailman/listinfo/openssl-commits.html">h, at X</A>[$i&amp;15]			// h+=X[i]
+	eor	$t0,$t0,$e,ror#$Sigma1[1]
+	eor	$T1,$<A HREF="../../../mailman/listinfo/openssl-commits.html">T1, at X</A>[($j+1)&amp;15],ror#$sigma0[1]
+	orr	$t1,$t1,$t2			// Ch(e,f,g)
+	eor	$t2,$a,$b			// a^b, b^c in next round
+	eor	$t0,$t0,$e,ror#$Sigma1[2]	// Sigma1(e)
+	eor	$T0,$T0,$a,ror#$Sigma0[1]
+	add	$h,$h,$t1			// h+=Ch(e,f,g)
+	and	$t3,$t3,$t2			// (b^c)&amp;=(a^b)
+	eor	$T2,$<A HREF="../../../mailman/listinfo/openssl-commits.html">T2, at X</A>[($j+14)&amp;15],ror#$sigma1[1]
+	eor	$T1,$<A HREF="../../../mailman/listinfo/openssl-commits.html">T1, at X</A>[($j+1)&amp;15],lsr#$sigma0[2]	// sigma0(X[i+1])
+	add	$h,$h,$t0			// h+=Sigma1(e)
+	eor	$t3,$t3,$b			// Maj(a,b,c)
+	eor	$t1,$T0,$a,ror#$Sigma0[2]	// Sigma0(a)
+	eor	$T2,$<A HREF="../../../mailman/listinfo/openssl-commits.html">T2, at X</A>[($j+14)&amp;15],lsr#$sigma1[2]	// sigma1(X[i+14])
+	add	@X[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[($j+9)&amp;15]
+	add	$d,$d,$h			// d+=h
+	add	$h,$h,$t3			// h+=Maj(a,b,c)
+	ldr	$t3,[$Ktbl],#$SZ		// *K++, $t2 in next round
+	add	@X[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[$j],$T1
+	add	$h,$h,$t1			// h+=Sigma0(a)
+	add	@X[$j]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[$j],$T2
+___
+	($t2,$t3)=($t3,$t2);
+}
+
+$code.=&lt;&lt;___;
+#include &quot;arm_arch.h&quot;
+
+.text
+
+.extern	OPENSSL_armcap_P
+.globl	$func
+.type	$func,%function
+.align	6
+$func:
+___
+$code.=&lt;&lt;___	if ($SZ==4);
+	ldr	x16,.LOPENSSL_armcap_P
+	adr	x17,.LOPENSSL_armcap_P
+	add	x16,x16,x17
+	ldr	w16,[x16]
+	tst	w16,#ARMV8_SHA256
+	b.ne	.Lv8_entry
+___
+$code.=&lt;&lt;___;
+	stp	x29,x30,[sp,#-128]!
+	add	x29,sp,#0
+
+	stp	x19,x20,[sp,#16]
+	stp	x21,x22,[sp,#32]
+	stp	x23,x24,[sp,#48]
+	stp	x25,x26,[sp,#64]
+	stp	x27,x28,[sp,#80]
+	sub	sp,sp,#4*$SZ
+
+	ldp	$A,$B,[$ctx]				// load context
+	ldp	$C,$D,[$ctx,#2*$SZ]
+	ldp	$E,$F,[$ctx,#4*$SZ]
+	add	$num,$inp,$num,lsl#`log(16*$SZ)/log(2)`	// end of input
+	ldp	$G,$H,[$ctx,#6*$SZ]
+	adr	$Ktbl,.LK$BITS
+	stp	$ctx,$num,[x29,#96]
+
+.Loop:
+	ldp	@X[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[1],[$inp],#2*$SZ
+	ldr	$t2,[$Ktbl],#$SZ			// *K++
+	eor	$t3,$B,$C				// magic seed
+	str	$inp,[x29,#112]
+___
+for ($i=0;$i&lt;16;$i++)	{ &amp;BODY_00_xx($<A HREF="../../../mailman/listinfo/openssl-commits.html">i, at V</A>); unshift(@V,pop(@V)); }
+$code.=&quot;.Loop_16_xx:\n&quot;;
+for (;$i&lt;32;$i++)	{ &amp;BODY_00_xx($<A HREF="../../../mailman/listinfo/openssl-commits.html">i, at V</A>); unshift(@V,pop(@V)); }
+$code.=&lt;&lt;___;
+	cbnz	$t2,.Loop_16_xx
+
+	ldp	$ctx,$num,[x29,#96]
+	ldr	$inp,[x29,#112]
+	sub	$Ktbl,$Ktbl,#`$SZ*($rounds+1)`		// rewind
+
+	ldp	@X[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[1],[$ctx]
+	ldp	@X[2]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[3],[$ctx,#2*$SZ]
+	add	$inp,$inp,#14*$SZ			// advance input pointer
+	ldp	@X[4]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[5],[$ctx,#4*$SZ]
+	add	$A,$<A HREF="../../../mailman/listinfo/openssl-commits.html">A, at X</A>[0]
+	ldp	@X[6]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at X</A>[7],[$ctx,#6*$SZ]
+	add	$B,$<A HREF="../../../mailman/listinfo/openssl-commits.html">B, at X</A>[1]
+	add	$C,$<A HREF="../../../mailman/listinfo/openssl-commits.html">C, at X</A>[2]
+	add	$D,$<A HREF="../../../mailman/listinfo/openssl-commits.html">D, at X</A>[3]
+	stp	$A,$B,[$ctx]
+	add	$E,$<A HREF="../../../mailman/listinfo/openssl-commits.html">E, at X</A>[4]
+	add	$F,$<A HREF="../../../mailman/listinfo/openssl-commits.html">F, at X</A>[5]
+	stp	$C,$D,[$ctx,#2*$SZ]
+	add	$G,$<A HREF="../../../mailman/listinfo/openssl-commits.html">G, at X</A>[6]
+	add	$H,$<A HREF="../../../mailman/listinfo/openssl-commits.html">H, at X</A>[7]
+	cmp	$inp,$num
+	stp	$E,$F,[$ctx,#4*$SZ]
+	stp	$G,$H,[$ctx,#6*$SZ]
+	b.ne	.Loop
+
+	ldp	x19,x20,[x29,#16]
+	add	sp,sp,#4*$SZ
+	ldp	x21,x22,[x29,#32]
+	ldp	x23,x24,[x29,#48]
+	ldp	x25,x26,[x29,#64]
+	ldp	x27,x28,[x29,#80]
+	ldp	x29,x30,[sp],#128
+	ret
+.size	$func,.-$func
+
+.align	6
+.type	.LK$BITS,%object
+.LK$BITS:
+___
+$code.=&lt;&lt;___ if ($SZ==8);
+	.quad	0x428a2f98d728ae22,0x7137449123ef65cd
+	.quad	0xb5c0fbcfec4d3b2f,0xe9b5dba58189dbbc
+	.quad	0x3956c25bf348b538,0x59f111f1b605d019
+	.quad	0x923f82a4af194f9b,0xab1c5ed5da6d8118
+	.quad	0xd807aa98a3030242,0x12835b0145706fbe
+	.quad	0x243185be4ee4b28c,0x550c7dc3d5ffb4e2
+	.quad	0x72be5d74f27b896f,0x80deb1fe3b1696b1
+	.quad	0x9bdc06a725c71235,0xc19bf174cf692694
+	.quad	0xe49b69c19ef14ad2,0xefbe4786384f25e3
+	.quad	0x0fc19dc68b8cd5b5,0x240ca1cc77ac9c65
+	.quad	0x2de92c6f592b0275,0x4a7484aa6ea6e483
+	.quad	0x5cb0a9dcbd41fbd4,0x76f988da831153b5
+	.quad	0x983e5152ee66dfab,0xa831c66d2db43210
+	.quad	0xb00327c898fb213f,0xbf597fc7beef0ee4
+	.quad	0xc6e00bf33da88fc2,0xd5a79147930aa725
+	.quad	0x06ca6351e003826f,0x142929670a0e6e70
+	.quad	0x27b70a8546d22ffc,0x2e1b21385c26c926
+	.quad	0x4d2c6dfc5ac42aed,0x53380d139d95b3df
+	.quad	0x650a73548baf63de,0x766a0abb3c77b2a8
+	.quad	0x81c2c92e47edaee6,0x92722c851482353b
+	.quad	0xa2bfe8a14cf10364,0xa81a664bbc423001
+	.quad	0xc24b8b70d0f89791,0xc76c51a30654be30
+	.quad	0xd192e819d6ef5218,0xd69906245565a910
+	.quad	0xf40e35855771202a,0x106aa07032bbd1b8
+	.quad	0x19a4c116b8d2d0c8,0x1e376c085141ab53
+	.quad	0x2748774cdf8eeb99,0x34b0bcb5e19b48a8
+	.quad	0x391c0cb3c5c95a63,0x4ed8aa4ae3418acb
+	.quad	0x5b9cca4f7763e373,0x682e6ff3d6b2b8a3
+	.quad	0x748f82ee5defb2fc,0x78a5636f43172f60
+	.quad	0x84c87814a1f0ab72,0x8cc702081a6439ec
+	.quad	0x90befffa23631e28,0xa4506cebde82bde9
+	.quad	0xbef9a3f7b2c67915,0xc67178f2e372532b
+	.quad	0xca273eceea26619c,0xd186b8c721c0c207
+	.quad	0xeada7dd6cde0eb1e,0xf57d4f7fee6ed178
+	.quad	0x06f067aa72176fba,0x0a637dc5a2c898a6
+	.quad	0x113f9804bef90dae,0x1b710b35131c471b
+	.quad	0x28db77f523047d84,0x32caab7b40c72493
+	.quad	0x3c9ebe0a15c9bebc,0x431d67c49c100d4c
+	.quad	0x4cc5d4becb3e42b6,0x597f299cfc657e2a
+	.quad	0x5fcb6fab3ad6faec,0x6c44198c4a475817
+	.quad	0	// terminator
+___
+$code.=&lt;&lt;___ if ($SZ==4);
+	.long	0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5
+	.long	0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5
+	.long	0xd807aa98,0x12835b01,0x243185be,0x550c7dc3
+	.long	0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174
+	.long	0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc
+	.long	0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da
+	.long	0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7
+	.long	0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967
+	.long	0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13
+	.long	0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85
+	.long	0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3
+	.long	0xd192e819,0xd6990624,0xf40e3585,0x106aa070
+	.long	0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5
+	.long	0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3
+	.long	0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208
+	.long	0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
+	.long	0	//terminator
+___
+$code.=&lt;&lt;___;
+.size	.LK$BITS,.-.LK$BITS
+.align	3
+.LOPENSSL_armcap_P:
+	.quad	OPENSSL_armcap_P-.
+.asciz	&quot;SHA$BITS block transform for ARMv8, CRYPTOGAMS by &lt;appro\@openssl.org&gt;&quot;
+.align	2
+___
+
+if ($SZ==4) {
+my $Ktbl=&quot;x3&quot;;
+
+my ($ABCD,$EFGH,$abcd)=map(&quot;v$_.16b&quot;,(0..2));
+my @MSG=map(&quot;v$_.16b&quot;,(4..7));
+my ($W0,$W1)=(&quot;v16.4s&quot;,&quot;v17.4s&quot;);
+my ($ABCD_SAVE,$EFGH_SAVE)=(&quot;v18.16b&quot;,&quot;v19.16b&quot;);
+
+$code.=&lt;&lt;___;
+.type	sha256_block_armv8,%function
+.align	6
+sha256_block_armv8:
+.Lv8_entry:
+	stp		x29,x30,[sp,#-16]!
+	add		x29,sp,#0
+
+	ld1.32		{$ABCD,$EFGH},[$ctx]
+	adr		$Ktbl,.LK256
+
+.Loop_hw:
+	ld1		{@MSG[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">- at MSG</A>[3]},[$inp],#64
+	sub		$num,$num,#1
+	ld1.32		{$W0},[$Ktbl],#16
+	rev32		@MSG[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[0]
+	rev32		@MSG[1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[1]
+	rev32		@MSG[2]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[2]
+	rev32		@MSG[3]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[3]
+	orr		$ABCD_SAVE,$ABCD,$ABCD		// offload
+	orr		$EFGH_SAVE,$EFGH,$EFGH
+___
+for($i=0;$i&lt;12;$i++) {
+$code.=&lt;&lt;___;
+	ld1.32		{$W1},[$Ktbl],#16
+	add.i32		$W0,$<A HREF="../../../mailman/listinfo/openssl-commits.html">W0, at MSG</A>[0]
+	sha256su0	@MSG[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[1]
+	orr		$abcd,$ABCD,$ABCD
+	sha256h		$ABCD,$EFGH,$W0
+	sha256h2	$EFGH,$abcd,$W0
+	sha256su1	@MSG[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[2]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at MSG</A>[3]
+___
+	($W0,$W1)=($W1,$W0);	push(@MSG,shift(@MSG));
+}
+$code.=&lt;&lt;___;
+	ld1.32		{$W1},[$Ktbl],#16
+	add.i32		$W0,$<A HREF="../../../mailman/listinfo/openssl-commits.html">W0, at MSG</A>[0]
+	orr		$abcd,$ABCD,$ABCD
+	sha256h		$ABCD,$EFGH,$W0
+	sha256h2	$EFGH,$abcd,$W0
+
+	ld1.32		{$W0},[$Ktbl],#16
+	add.i32		$W1,$<A HREF="../../../mailman/listinfo/openssl-commits.html">W1, at MSG</A>[1]
+	orr		$abcd,$ABCD,$ABCD
+	sha256h		$ABCD,$EFGH,$W1
+	sha256h2	$EFGH,$abcd,$W1
+
+	ld1.32		{$W1},[$Ktbl]
+	add.i32		$W0,$<A HREF="../../../mailman/listinfo/openssl-commits.html">W0, at MSG</A>[2]
+	sub		$Ktbl,$Ktbl,#$rounds*$SZ-16	// rewind
+	orr		$abcd,$ABCD,$ABCD
+	sha256h		$ABCD,$EFGH,$W0
+	sha256h2	$EFGH,$abcd,$W0
+
+	add.i32		$W1,$<A HREF="../../../mailman/listinfo/openssl-commits.html">W1, at MSG</A>[3]
+	orr		$abcd,$ABCD,$ABCD
+	sha256h		$ABCD,$EFGH,$W1
+	sha256h2	$EFGH,$abcd,$W1
+
+	add.i32		$ABCD,$ABCD,$ABCD_SAVE
+	add.i32		$EFGH,$EFGH,$EFGH_SAVE
+
+	cbnz		$num,.Loop_hw
+
+	st1.32		{$ABCD,$EFGH},[$ctx]
+
+	ldr		x29,[sp],#16
+	ret
+.size	sha256_block_armv8,.-sha256_block_armv8
+___
+}
+
+$code.=&lt;&lt;___;
+.comm	OPENSSL_armcap_P,4,4
+___
+
+{   my  %opcode = (
+	&quot;sha256h&quot;	=&gt; 0x5e004000,	&quot;sha256h2&quot;	=&gt; 0x5e005000,
+	&quot;sha256su0&quot;	=&gt; 0x5e282800,	&quot;sha256su1&quot;	=&gt; 0x5e006000	);
+
+    sub unsha256 {
+	my ($mnemonic,$arg)=@_;
+
+	$arg =~ m/[qv]([0-9]+)[^,]*,\s*[qv]([0-9]+)[^,]*(?:,\s*[qv]([0-9]+))?/o
+	&amp;&amp;
+	sprintf &quot;.inst\t0x%08x\t//%s %s&quot;,
+			$opcode{$mnemonic}|$1|($2&lt;&lt;5)|($3&lt;&lt;16),
+			$mnemonic,$arg;
+    }
+}
+
+foreach(split(&quot;\n&quot;,$code)) {
+
+	s/\`([^\`]*)\`/eval($1)/geo;
+
+	s/\b(sha256\w+)\s+([qv].*)/unsha256($1,$2)/geo;
+
+	s/\.\w?32\b//o		and s/\.16b/\.4s/go;
+	m/(ld|st)1[^\[]+\[0\]/o	and s/\.4s/\.s/go;
+
+	print $_,&quot;\n&quot;;
+}
+
+close STDOUT;
diff --git a/fips/fips.c b/fips/fips.c
index 8c9e187..0269609 100644
--- a/fips/fips.c
+++ b/fips/fips.c
@@ -151,7 +151,7 @@ extern const unsigned char FIPS_rodata_start[], FIPS_rodata_end[];
 #ifdef _TMS320C6X
 const
 #endif
-unsigned char              FIPS_signature [20] = { 0 };
+unsigned char              FIPS_signature [20] = { 0, 0xff };
 __fips_constseg
 static const char          FIPS_hmac_key[]=&quot;etaonrishdlcupfm&quot;;
 
diff --git a/fips/fips_canister.c b/fips/fips_canister.c
index 016d94c..daf53cb 100644
--- a/fips/fips_canister.c
+++ b/fips/fips_canister.c
@@ -29,6 +29,7 @@ const void         *FIPS_text_end(void);
 
 #if !defined(FIPS_REF_POINT_IS_CROSS_COMPILER_AWARE)
 # if	(defined(__ANDROID__) &amp;&amp; (defined(__arm__) || defined(__arm)	|| \
+				  defined(__aarch64__)			|| \
 				  defined(__i386__)|| defined(__i386)))	|| \
 	(defined(__vxworks)   &amp;&amp; (defined(__ppc__) || defined(__ppc)	|| \
 				  defined(__mips__)|| defined(__mips)))	|| \
diff --git a/fips/fips_test_suite.c b/fips/fips_test_suite.c
index c7054db..cd4aafb 100644
--- a/fips/fips_test_suite.c
+++ b/fips/fips_test_suite.c
@@ -1611,6 +1611,12 @@ int main(int argc, char **argv)
 
     FIPS_post_set_callback(post_cb);
 
+#if (defined(__arm__) || defined(__aarch64__))
+    extern unsigned int OPENSSL_armcap_P;
+    if (0 == OPENSSL_armcap_P)
+	fprintf(stderr, &quot;Optimizations disabled\n&quot;);
+#endif
+
     printf(&quot;\tFIPS-mode test application\n&quot;);
 
     printf(&quot;\t%s\n\n&quot;, FIPS_module_version_text());
diff --git a/fips/fipssyms.h b/fips/fipssyms.h
index 5719aea..76db619 100644
--- a/fips/fipssyms.h
+++ b/fips/fipssyms.h
@@ -668,6 +668,50 @@
 #define bn_mul_mont_gather5 fips_bn_mul_mont_gather5
 #define bn_scatter5 fips_bn_scatter5
 #define bn_gather5 fips_bn_gather5
+#define _armv8_aes_probe _fips_armv8_aes_probe
+#define _armv8_pmull_probe _fips_armv8_pmull_probe
+#define _armv8_sha1_probe _fips_armv8_sha1_probe
+#define _armv8_sha256_probe _fips_armv8_sha256_probe
+#define aes_v8_encrypt fips_aes_v8_encrypt
+#define aes_v8_decrypt fips_aes_v8_decrypt
+#define aes_v8_set_encrypt_key fips_aes_v8_set_encrypt_key
+#define aes_v8_set_decrypt_key fips_aes_v8_set_decrypt_key
+#define aes_v8_cbc_encrypt fips_aes_v8_cbc_encrypt
+#define aes_v8_ctr32_encrypt_blocks fips_aes_v8_ctr32_encrypt_blocks
+#define gcm_init_v8 fips_gcm_init_v8
+#define gcm_gmult_v8 fips_gcm_gmult_v8
+#define gcm_ghash_v8 fips_gcm_ghash_v8
+#if defined(__APPLE__) &amp;&amp; __ASSEMBLER__
+#define _OPENSSL_armcap_P _fips_openssl_armcap_P
+#define __armv7_neon_probe __fips_armv7_neon_probe
+#define __armv7_tick __fips_armv7_tick
+#define __armv8_aes_probe __fips_armv8_aes_probe
+#define __armv8_pmull_probe __fips_armv8_pmull_probe
+#define __armv8_sha1_probe __fips_armv8_sha1_probe
+#define __armv8_sha256_probe __fips_armv8_sha256_probe
+#define _aes_v8_encrypt _fips_aes_v8_encrypt
+#define _aes_v8_decrypt _fips_aes_v8_decrypt
+#define _aes_v8_set_encrypt_key _fips_aes_v8_set_encrypt_key
+#define _aes_v8_set_decrypt_key _fips_aes_v8_set_decrypt_key
+#define _aes_v8_cbc_encrypt _fips_aes_v8_cbc_encrypt
+#define _aes_v8_ctr32_encrypt_blocks _fips_aes_v8_ctr32_encrypt_blocks
+#define _gcm_init_v8 _fips_gcm_init_v8
+#define _gcm_gmult_v8 _fips_gcm_gmult_v8
+#define _gcm_ghash_v8 _fips_gcm_ghash_v8
+#define _sha1_block_data_order _fips_sha1_block_data_order
+#define _sha256_block_data_order _fips_sha256_block_data_order
+#define _sha512_block_data_order _fips_sha512_block_data_order
+#define _AES_decrypt _fips_aes_decrypt
+#define _AES_encrypt _fips_aes_encrypt
+#define _AES_set_decrypt_key _fips_aes_set_decrypt_key
+#define _AES_set_encrypt_key _fips_aes_set_encrypt_key
+#define _gcm_gmult_4bit _fips_gcm_gmult_4bit
+#define _gcm_ghash_4bit _fips_gcm_ghash_4bit
+#define _gcm_gmult_neon _fips_gcm_gmult_neon
+#define _gcm_ghash_neon _fips_gcm_ghash_neon
+#define _bn_GF2m_mul_2x2 _fips_bn_GF2m_mul_2x2
+#define _OPENSSL_cleanse _FIPS_openssl_cleanse
+#endif
 
 #if defined(_MSC_VER)
 # pragma const_seg(&quot;fipsro$b&quot;)
diff --git a/test/fips_algvs.c b/test/fips_algvs.c
index ed03507..8ff75dc 100644
--- a/test/fips_algvs.c
+++ b/test/fips_algvs.c
@@ -70,6 +70,67 @@ int main(int argc, char **argv)
 }
 #else
 
+#if defined(__vxworks)
+
+#include &lt;taskLibCommon.h&gt;
+#include &lt;string.h&gt;
+
+int fips_algvs_main(int argc, char **argv);
+#define main fips_algvs_main
+
+static int fips_algvs_argv(char *a0)
+{
+	char *argv[32] = { &quot;fips_algvs&quot; };
+	int argc = 1;
+	int main_ret;
+
+	if (a0) {
+		char *scan = a0, *arg = a0;
+
+		while (*scan) {
+			if (*scan++ == ' ') {
+				scan[-1] = '\0';
+				argv[argc++] = arg;
+				if (argc == (sizeof(argv)/sizeof(argv[0])-1))
+					break;
+
+				while (*scan == ' ') scan++;
+				arg = scan;
+			}
+		}
+		if (*scan == '\0') argv[argc++] = arg;
+	}
+
+	argv[argc] = NULL;
+
+	main_ret = fips_algvs_main(argc, argv);
+
+	if (a0) free(a0);
+
+	return main_ret;
+}
+
+int fips_algvs(int a0)
+{
+	return taskSpawn(&quot;fips_algvs&quot;, 100, (VX_FP_TASK | VX_SPE_TASK), 100000,
+			(FUNCPTR)fips_algvs_argv,
+			a0 ? strdup(a0) : 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
+}
+
+static FILE *fips_fopen(const char *path, const char *mode)
+{
+	char fips_path [256];
+
+	if (path[0] != '/' &amp;&amp; strlen(path) &lt; (sizeof(fips_path)-8)) {
+		strcpy(fips_path,&quot;/fips0/&quot;);
+		strcat(fips_path,path);
+		return fopen(fips_path,mode);
+	}
+	return fopen(path,mode);
+}
+#define fopen fips_fopen
+#endif
+
 #define FIPS_ALGVS
 
 extern int fips_aesavs_main(int argc, char **argv);
@@ -265,6 +326,16 @@ int main(int argc, char **argv)
 	SysInit();
 #endif
 
+#if (defined(__arm__) || defined(__aarch64__))
+	if (*args &amp;&amp; !strcmp(*args, &quot;-noaccel&quot;))
+		{
+		extern unsigned int OPENSSL_armcap_P;
+
+		OPENSSL_armcap_P=0;
+		args++;
+		argc--;
+		}
+#endif
 	if (*args &amp;&amp; *args[0] != '-')
 		{
 		rv = run_prg(argc - 1, args);
diff --git a/util/incore b/util/incore
index e6e6ecf..bb765b1 100755
--- a/util/incore
+++ b/util/incore
@@ -382,7 +382,7 @@ if (!$legacy_mode) {
     }
 
     $FINGERPRINT_ascii_value
-			= $exe-&gt;Lookup(&quot;FINGERPRINT_ascii_value&quot;)	or die;
+			= $exe-&gt;Lookup(&quot;FINGERPRINT_ascii_value&quot;);
 
 }
 if ($FIPS_text_startX &amp;&amp; $FIPS_text_endX) {
@@ -439,9 +439,12 @@ $fingerprint = FIPS_incore_fingerprint();
 
 if ($legacy_mode) {
     print unpack(&quot;H*&quot;,$fingerprint);
-} else {
+} elsif (defined($FINGERPRINT_ascii_value)) {
     seek(FD,$FINGERPRINT_ascii_value-&gt;{st_offset},0)	or die &quot;$!&quot;;
     print FD unpack(&quot;H*&quot;,$fingerprint)			or die &quot;$!&quot;;
+} else {
+    seek(FD,$FIPS_signature-&gt;{st_offset},0)		or die &quot;$!&quot;;
+    print FD $fingerprint				or die &quot;$!&quot;;
 }
 
 close (FD);
</PRE>






























































































































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001075.html">[openssl-commits] [openssl]  OpenSSL-fips-2_0-stable update
</A></li>
	<LI>Next message: <A HREF="001114.html">[openssl-commits] [openssl]  OpenSSL-fips-2_0-dev update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1081">[ date ]</a>
              <a href="thread.html#1081">[ thread ]</a>
              <a href="subject.html#1081">[ subject ]</a>
              <a href="author.html#1081">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
