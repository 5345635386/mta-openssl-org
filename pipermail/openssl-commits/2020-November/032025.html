<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-November/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1605256629.227585.16149.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="032024.html">
   <LINK REL="Next"  HREF="032029.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1605256629.227585.16149.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Fri Nov 13 08:37:09 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="032024.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="032029.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32025">[ date ]</a>
              <a href="thread.html#32025">[ thread ]</a>
              <a href="subject.html#32025">[ subject ]</a>
              <a href="author.html#32025">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  256d41d4371720ccfe1a4fead6bd28ed5071bcdd (commit)
       via  105d01f1eb0e48ea24b430a0ac9636906a24cdbb (commit)
       via  a150f8e1fcc38752fef4d7c75d765d8efc7d46d6 (commit)
       via  9311d0c471ca2eaa259e8c1bbbeb7c46394c7ba2 (commit)
      from  31a6b52f6db009c639c67387a707dd235f29a430 (commit)


- Log -----------------------------------------------------------------
commit 256d41d4371720ccfe1a4fead6bd28ed5071bcdd
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Nov 10 10:45:07 2020 +0100

    BIO: Undefine UNICODE in b_addr.c to get POSIX declaration of gai_strerror()
    
    When UNICODE is defined, Windows headers push for WCHAR implementations,
    which aren't compatible with POSIX declarations.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/13318">https://github.com/openssl/openssl/pull/13318</A>)

commit 105d01f1eb0e48ea24b430a0ac9636906a24cdbb
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Nov 10 10:28:16 2020 +0100

    crypto/provider_core.c: fix a couple of faulty ERR_raise_data() calls
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/13318">https://github.com/openssl/openssl/pull/13318</A>)

commit a150f8e1fcc38752fef4d7c75d765d8efc7d46d6
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Nov 4 16:14:00 2020 +0100

    CRYPTO: refactor ERR_raise()+ERR_add_error_data() to ERR_raise_data()
    
    This is not done absolutely everywhere, as there are places where
    the use of ERR_add_error_data() is quite complex, but at least the
    simple cases are done.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/13318">https://github.com/openssl/openssl/pull/13318</A>)

commit 9311d0c471ca2eaa259e8c1bbbeb7c46394c7ba2
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Nov 4 12:23:19 2020 +0100

    Convert all {NAME}err() in crypto/ to their corresponding ERR_raise() call
    
    This includes error reporting for libcrypto sub-libraries in surprising
    places.
    
    This was done using util/err-to-raise
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/13318">https://github.com/openssl/openssl/pull/13318</A>)

-----------------------------------------------------------------------

Summary of changes:
 apps/cmp_mock_srv.c              |  44 +++++-----
 apps/lib/apps.c                  |   6 +-
 crypto/asn1/a_bitstr.c           |   4 +-
 crypto/asn1/a_d2i_fp.c           |  25 +++---
 crypto/asn1/a_digest.c           |   4 +-
 crypto/asn1/a_dup.c              |   4 +-
 crypto/asn1/a_i2d_fp.c           |   8 +-
 crypto/asn1/a_int.c              |  34 ++++----
 crypto/asn1/a_mbstr.c            |  29 +++----
 crypto/asn1/a_object.c           |  27 +++---
 crypto/asn1/a_sign.c             |  42 +++++----
 crypto/asn1/a_strex.c            |   6 +-
 crypto/asn1/a_strnid.c           |   4 +-
 crypto/asn1/a_time.c             |   2 +-
 crypto/asn1/a_verify.c           |  36 ++++----
 crypto/asn1/ameth_lib.c          |   6 +-
 crypto/asn1/asn1_gen.c           |  68 +++++++--------
 crypto/asn1/asn1_lib.c           |  10 +--
 crypto/asn1/asn_mime.c           |  42 ++++-----
 crypto/asn1/asn_moid.c           |   6 +-
 crypto/asn1/asn_mstbl.c          |  14 +--
 crypto/asn1/asn_pack.c           |   8 +-
 crypto/asn1/bio_asn1.c           |   2 +-
 crypto/asn1/bio_ndef.c           |   6 +-
 crypto/asn1/d2i_param.c          |   2 +-
 crypto/asn1/d2i_pr.c             |   8 +-
 crypto/asn1/d2i_pu.c             |  12 +--
 crypto/asn1/evp_asn1.c           |   6 +-
 crypto/asn1/f_int.c              |   9 +-
 crypto/asn1/f_string.c           |   9 +-
 crypto/asn1/p5_pbe.c             |  10 +--
 crypto/asn1/p5_pbev2.c           |   9 +-
 crypto/asn1/p5_scrypt.c          |  27 +++---
 crypto/asn1/tasn_dec.c           | 117 ++++++++++++-------------
 crypto/asn1/tasn_enc.c           |   2 +-
 crypto/asn1/tasn_new.c           |   8 +-
 crypto/asn1/tasn_prn.c           |   2 +-
 crypto/asn1/tasn_scn.c           |   2 +-
 crypto/asn1/tasn_utl.c           |   8 +-
 crypto/asn1/x_algor.c            |   2 +-
 crypto/asn1/x_info.c             |   2 +-
 crypto/asn1/x_int64.c            |  14 +--
 crypto/asn1/x_long.c             |   8 +-
 crypto/asn1/x_pkey.c             |   2 +-
 crypto/async/async.c             |  25 +++---
 crypto/async/async_wait.c        |   2 +-
 crypto/bio/b_addr.c              |  46 +++++-----
 crypto/bio/b_print.c             |   2 +-
 crypto/bio/b_sock.c              |  22 +++--
 crypto/bio/b_sock2.c             |  30 +++----
 crypto/bio/bf_buff.c             |   2 +-
 crypto/bio/bf_lbuf.c             |   6 +-
 crypto/bio/bf_nbio.c             |   2 +-
 crypto/bio/bio_lib.c             |  42 ++++-----
 crypto/bio/bio_meth.c            |   4 +-
 crypto/bio/bss_acpt.c            |  18 ++--
 crypto/bio/bss_bio.c             |  22 ++---
 crypto/bio/bss_conn.c            |  22 ++---
 crypto/bio/bss_dgram.c           |  21 +++--
 crypto/bio/bss_file.c            |  12 +--
 crypto/bio/bss_log.c             |   2 +-
 crypto/bio/bss_mem.c             |   6 +-
 crypto/bn/bn_add.c               |   2 +-
 crypto/bn/bn_blind.c             |  12 +--
 crypto/bn/bn_conv.c              |   4 +-
 crypto/bn/bn_ctx.c               |  10 +--
 crypto/bn/bn_div.c               |   6 +-
 crypto/bn/bn_exp.c               |  14 +--
 crypto/bn/bn_exp2.c              |   2 +-
 crypto/bn/bn_gcd.c               |   4 +-
 crypto/bn/bn_gf2m.c              |  16 ++--
 crypto/bn/bn_intern.c            |  18 ++--
 crypto/bn/bn_lib.c               |  10 +--
 crypto/bn/bn_mod.c               |   2 +-
 crypto/bn/bn_mont.c              |   2 +-
 crypto/bn/bn_mpi.c               |   4 +-
 crypto/bn/bn_prime.c             |   4 +-
 crypto/bn/bn_rand.c              |  14 +--
 crypto/bn/bn_recp.c              |   4 +-
 crypto/bn/bn_shift.c             |   4 +-
 crypto/bn/bn_sqrt.c              |  12 +--
 crypto/buffer/buffer.c           |  10 +--
 crypto/cmac/cmac.c               |   2 +-
 crypto/cmp/cmp_asn.c             |   8 +-
 crypto/cmp/cmp_client.c          |  79 ++++++++---------
 crypto/cmp/cmp_ctx.c             | 106 +++++++++++------------
 crypto/cmp/cmp_hdr.c             |   6 +-
 crypto/cmp/cmp_http.c            |   2 +-
 crypto/cmp/cmp_msg.c             |  74 ++++++++--------
 crypto/cmp/cmp_protect.c         |  26 +++---
 crypto/cmp/cmp_server.c          |  62 +++++++-------
 crypto/cmp/cmp_status.c          |  16 ++--
 crypto/cmp/cmp_util.c            |  12 +--
 crypto/cmp/cmp_vfy.c             |  44 +++++-----
 crypto/cms/cms_att.c             |   2 +-
 crypto/cms/cms_cd.c              |   9 +-
 crypto/cms/cms_dd.c              |   8 +-
 crypto/cms/cms_dh.c              |   8 +-
 crypto/cms/cms_ec.c              |  12 +--
 crypto/cms/cms_enc.c             |  32 +++----
 crypto/cms/cms_env.c             | 116 ++++++++++++-------------
 crypto/cms/cms_ess.c             |  49 +++++------
 crypto/cms/cms_io.c              |   2 +-
 crypto/cms/cms_kari.c            |  14 ++-
 crypto/cms/cms_lib.c             |  37 ++++----
 crypto/cms/cms_pwri.c            |  41 ++++-----
 crypto/cms/cms_rsa.c             |  14 +--
 crypto/cms/cms_sd.c              |  69 +++++++--------
 crypto/cms/cms_smime.c           |  76 ++++++++---------
 crypto/comp/c_zlib.c             |  20 ++---
 crypto/comp/comp_lib.c           |   2 +-
 crypto/conf/conf_def.c           |  61 ++++++-------
 crypto/conf/conf_lib.c           |  33 ++++----
 crypto/conf/conf_mod.c           |  32 +++----
 crypto/conf/conf_ssl.c           |  25 +++---
 crypto/crmf/crmf_lib.c           |  82 ++++++++----------
 crypto/crmf/crmf_pbm.c           |  20 ++---
 crypto/ct/ct_b64.c               |  20 ++---
 crypto/ct/ct_log.c               |  30 +++----
 crypto/ct/ct_oct.c               |  38 ++++-----
 crypto/ct/ct_policy.c            |   4 +-
 crypto/ct/ct_sct.c               |  18 ++--
 crypto/ct/ct_sct_ctx.c           |   4 +-
 crypto/ct/ct_vfy.c               |  10 +--
 crypto/dh/dh_ameth.c             |  28 +++---
 crypto/dh/dh_check.c             |  32 +++----
 crypto/dh/dh_gen.c               |   8 +-
 crypto/dh/dh_group_params.c      |   2 +-
 crypto/dh/dh_key.c               |  24 +++---
 crypto/dh/dh_lib.c               |  10 +--
 crypto/dh/dh_meth.c              |   6 +-
 crypto/dh/dh_pmeth.c             |   8 +-
 crypto/dh/dh_prn.c               |   2 +-
 crypto/dsa/dsa_ameth.c           |  38 ++++-----
 crypto/dsa/dsa_lib.c             |  10 +--
 crypto/dsa/dsa_meth.c            |   6 +-
 crypto/dsa/dsa_ossl.c            |  18 ++--
 crypto/dsa/dsa_pmeth.c           |  11 ++-
 crypto/dsa/dsa_prn.c             |   4 +-
 crypto/dsa/dsa_sign.c            |   2 +-
 crypto/dso/dso_dl.c              |  40 +++++----
 crypto/dso/dso_dlfcn.c           |  33 ++++----
 crypto/dso/dso_lib.c             |  56 ++++++------
 crypto/dso/dso_vms.c             |  43 +++++-----
 crypto/dso/dso_win32.c           |  63 +++++++-------
 crypto/ec/ec2_oct.c              |  36 ++++----
 crypto/ec/ec2_smpl.c             |  26 +++---
 crypto/ec/ec_ameth.c             |  34 ++++----
 crypto/ec/ec_asn1.c              | 179 +++++++++++++++++++--------------------
 crypto/ec/ec_backend.c           |  26 +++---
 crypto/ec/ec_check.c             |  18 ++--
 crypto/ec/ec_curve.c             |  28 +++---
 crypto/ec/ec_key.c               |  54 ++++++------
 crypto/ec/ec_kmeth.c             |  16 ++--
 crypto/ec/ec_lib.c               | 167 +++++++++++++++++-------------------
 crypto/ec/ec_mult.c              |  74 ++++++++--------
 crypto/ec/ec_oct.c               |  23 +++--
 crypto/ec/ec_pmeth.c             |  22 ++---
 crypto/ec/ec_print.c             |   2 +-
 crypto/ec/ecdh_ossl.c            |  20 ++---
 crypto/ec/ecdsa_ossl.c           |  90 ++++++++++----------
 crypto/ec/ecdsa_sign.c           |   6 +-
 crypto/ec/ecdsa_vrf.c            |   4 +-
 crypto/ec/eck_prn.c              |   8 +-
 crypto/ec/ecp_mont.c             |  14 +--
 crypto/ec/ecp_nist.c             |   6 +-
 crypto/ec/ecp_nistp224.c         |  32 +++----
 crypto/ec/ecp_nistp256.c         |  32 +++----
 crypto/ec/ecp_nistp521.c         |  32 +++----
 crypto/ec/ecp_nistz256.c         |  40 +++++----
 crypto/ec/ecp_oct.c              |  45 +++++-----
 crypto/ec/ecp_s390x_nistp.c      |  31 +++----
 crypto/ec/ecp_smpl.c             |  22 ++---
 crypto/ec/ecx_backend.c          |   4 +-
 crypto/ec/ecx_meth.c             |  56 ++++++------
 crypto/engine/eng_cnf.c          |  21 ++---
 crypto/engine/eng_ctrl.c         |  45 +++++-----
 crypto/engine/eng_dyn.c          |  34 ++++----
 crypto/engine/eng_fat.c          |   5 +-
 crypto/engine/eng_init.c         |   8 +-
 crypto/engine/eng_lib.c          |   8 +-
 crypto/engine/eng_list.c         |  40 +++++----
 crypto/engine/eng_openssl.c      |   2 +-
 crypto/engine/eng_pkey.c         |  30 +++----
 crypto/engine/eng_table.c        |   3 +-
 crypto/engine/tb_asnmth.c        |   5 +-
 crypto/engine/tb_cipher.c        |   2 +-
 crypto/engine/tb_digest.c        |   2 +-
 crypto/engine/tb_pkmeth.c        |   3 +-
 crypto/ess/ess_lib.c             |  16 ++--
 crypto/evp/asymcipher.c          |  28 +++---
 crypto/evp/bio_b64.c             |   2 +-
 crypto/evp/bio_enc.c             |   2 +-
 crypto/evp/bio_ok.c              |   2 +-
 crypto/evp/digest.c              |  48 +++++------
 crypto/evp/e_aes.c               |  30 +++----
 crypto/evp/e_aria.c              |  10 +--
 crypto/evp/e_camellia.c          |   4 +-
 crypto/evp/e_chacha20_poly1305.c |   4 +-
 crypto/evp/e_des3.c              |   2 +-
 crypto/evp/e_rc2.c               |   2 +-
 crypto/evp/e_rc5.c               |   4 +-
 crypto/evp/evp_cnf.c             |  13 ++-
 crypto/evp/evp_enc.c             | 105 +++++++++++------------
 crypto/evp/evp_fetch.c           |   8 +-
 crypto/evp/evp_lib.c             |  12 +--
 crypto/evp/evp_pbe.c             |  12 +--
 crypto/evp/evp_pkey.c            |  20 ++---
 crypto/evp/evp_rand.c            |  18 ++--
 crypto/evp/evp_utils.c           |   4 +-
 crypto/evp/exchange.c            |  35 +++-----
 crypto/evp/kdf_lib.c             |   6 +-
 crypto/evp/kdf_meth.c            |   2 +-
 crypto/evp/kem.c                 |   8 +-
 crypto/evp/keymgmt_meth.c        |   4 +-
 crypto/evp/m_sigver.c            |   6 +-
 crypto/evp/mac_lib.c             |   6 +-
 crypto/evp/mac_meth.c            |   2 +-
 crypto/evp/p5_crpt.c             |  10 +--
 crypto/evp/p5_crpt2.c            |  23 +++--
 crypto/evp/p_dec.c               |   2 +-
 crypto/evp/p_enc.c               |   2 +-
 crypto/evp/p_lib.c               |  67 ++++++++-------
 crypto/evp/p_sign.c              |   2 +-
 crypto/evp/p_verify.c            |   2 +-
 crypto/evp/pbe_scrypt.c          |   2 +-
 crypto/evp/pmeth_check.c         |  20 ++---
 crypto/evp/pmeth_lib.c           |  34 ++++----
 crypto/evp/signature.c           |  34 ++++----
 crypto/ex_data.c                 |  18 ++--
 crypto/ffc/ffc_params_generate.c |   8 +-
 crypto/http/http_client.c        | 128 +++++++++++++---------------
 crypto/http/http_lib.c           |  10 +--
 crypto/init.c                    |   4 +-
 crypto/lhash/lhash.c             |   2 +-
 crypto/modes/ocb128.c            |   4 +-
 crypto/o_fopen.c                 |   2 +-
 crypto/o_str.c                   |  14 +--
 crypto/objects/o_names.c         |   4 +-
 crypto/objects/obj_dat.c         |  22 ++---
 crypto/objects/obj_lib.c         |   4 +-
 crypto/objects/obj_xref.c        |   2 +-
 crypto/ocsp/ocsp_cl.c            |  21 +++--
 crypto/ocsp/ocsp_lib.c           |   4 +-
 crypto/ocsp/ocsp_srv.c           |   7 +-
 crypto/ocsp/ocsp_vfy.c           |  41 ++++-----
 crypto/ocsp/v3_ocsp.c            |   2 +-
 crypto/packet.c                  |   4 +-
 crypto/param_build.c             |  25 +++---
 crypto/params_from_text.c        |   6 +-
 crypto/pem/pem_all.c             |   4 +-
 crypto/pem/pem_info.c            |  15 ++--
 crypto/pem/pem_lib.c             |  66 +++++++--------
 crypto/pem/pem_oth.c             |   2 +-
 crypto/pem/pem_pk8.c             |  10 +--
 crypto/pem/pem_pkey.c            |   6 +-
 crypto/pem/pem_sign.c            |   2 +-
 crypto/pem/pvkfmt.c              |  62 +++++++-------
 crypto/pkcs12/p12_add.c          |  27 +++---
 crypto/pkcs12/p12_crpt.c         |   6 +-
 crypto/pkcs12/p12_crt.c          |   2 +-
 crypto/pkcs12/p12_decr.c         |  26 +++---
 crypto/pkcs12/p12_init.c         |   6 +-
 crypto/pkcs12/p12_key.c          |   4 +-
 crypto/pkcs12/p12_kiss.c         |  11 ++-
 crypto/pkcs12/p12_mutl.c         |  26 +++---
 crypto/pkcs12/p12_npas.c         |   7 +-
 crypto/pkcs12/p12_p8e.c          |   6 +-
 crypto/pkcs12/p12_sbag.c         |  16 ++--
 crypto/pkcs12/p12_utl.c          |   8 +-
 crypto/pkcs7/pk7_attr.c          |   9 +-
 crypto/pkcs7/pk7_doit.c          | 120 ++++++++++++--------------
 crypto/pkcs7/pk7_lib.c           |  59 ++++++-------
 crypto/pkcs7/pk7_smime.c         |  83 +++++++++---------
 crypto/provider.c                |   3 +-
 crypto/provider_conf.c           |   7 +-
 crypto/provider_core.c           |  18 ++--
 crypto/rand/rand_lib.c           |  23 ++---
 crypto/rand/randfile.c           |  19 ++---
 crypto/rsa/rsa_ameth.c           |  18 ++--
 crypto/rsa/rsa_chk.c             |  32 +++----
 crypto/rsa/rsa_crpt.c            |   8 +-
 crypto/rsa/rsa_gen.c             |   8 +-
 crypto/rsa/rsa_lib.c             |  10 +--
 crypto/rsa/rsa_meth.c            |   6 +-
 crypto/rsa/rsa_mp.c              |   2 +-
 crypto/rsa/rsa_none.c            |   6 +-
 crypto/rsa/rsa_oaep.c            |  21 ++---
 crypto/rsa/rsa_ossl.c            |  65 +++++++-------
 crypto/rsa/rsa_pk1.c             |  29 +++----
 crypto/rsa/rsa_pmeth.c           |  58 ++++++-------
 crypto/rsa/rsa_prn.c             |   2 +-
 crypto/rsa/rsa_pss.c             |  29 +++----
 crypto/rsa/rsa_saos.c            |  12 ++-
 crypto/rsa/rsa_sign.c            |  30 +++----
 crypto/rsa/rsa_sp800_56b_check.c |  22 ++---
 crypto/rsa/rsa_sp800_56b_gen.c   |  10 +--
 crypto/rsa/rsa_ssl.c             |   8 +-
 crypto/rsa/rsa_x931.c            |  10 +--
 crypto/sm2/sm2_crypt.c           |  58 ++++++-------
 crypto/sm2/sm2_sign.c            |  74 ++++++++--------
 crypto/srp/srp_vfy.c             |   2 +-
 crypto/stack/stack.c             |   6 +-
 crypto/store/store_lib.c         |   2 +-
 crypto/store/store_result.c      |   3 +-
 crypto/ts/ts_asn1.c              |  15 ++--
 crypto/ts/ts_conf.c              |  19 ++---
 crypto/ts/ts_req_utils.c         |   8 +-
 crypto/ts/ts_rsp_sign.c          |  55 ++++++------
 crypto/ts/ts_rsp_utils.c         |  22 ++---
 crypto/ts/ts_rsp_verify.c        |  51 ++++++-----
 crypto/ts/ts_verify_ctx.c        |   2 +-
 crypto/ui/ui_lib.c               |  99 ++++++++++------------
 crypto/ui/ui_openssl.c           |  47 +++-------
 crypto/x509/by_dir.c             |  26 +++---
 crypto/x509/by_file.c            |  30 +++----
 crypto/x509/pcy_cache.c          |   8 +-
 crypto/x509/pcy_data.c           |   4 +-
 crypto/x509/pcy_node.c           |  10 +--
 crypto/x509/pcy_tree.c           |   4 +-
 crypto/x509/t_crl.c              |   2 +-
 crypto/x509/t_req.c              |   6 +-
 crypto/x509/t_x509.c             |   4 +-
 crypto/x509/v3_addr.c            |  40 ++++-----
 crypto/x509/v3_akey.c            |  15 ++--
 crypto/x509/v3_alt.c             |  48 +++++------
 crypto/x509/v3_asid.c            |  46 ++++------
 crypto/x509/v3_bcons.c           |   4 +-
 crypto/x509/v3_bitst.c           |  10 +--
 crypto/x509/v3_conf.c            |  47 +++++-----
 crypto/x509/v3_cpols.c           |  52 ++++++------
 crypto/x509/v3_crld.c            |  17 ++--
 crypto/x509/v3_extku.c           |   7 +-
 crypto/x509/v3_ia5.c             |   7 +-
 crypto/x509/v3_info.c            |  30 ++-----
 crypto/x509/v3_ist.c             |  14 +--
 crypto/x509/v3_lib.c             |  15 ++--
 crypto/x509/v3_ncons.c           |   4 +-
 crypto/x509/v3_pci.c             |  40 ++++-----
 crypto/x509/v3_pcons.c           |   9 +-
 crypto/x509/v3_pmaps.c           |  14 ++-
 crypto/x509/v3_purp.c            |  18 ++--
 crypto/x509/v3_skey.c            |  10 +--
 crypto/x509/v3_sxnet.c           |  17 ++--
 crypto/x509/v3_tlsf.c            |   6 +-
 crypto/x509/v3_utf8.c            |  10 +--
 crypto/x509/v3_utl.c             |  36 ++++----
 crypto/x509/x509_att.c           |  20 ++---
 crypto/x509/x509_cmp.c           |  12 +--
 crypto/x509/x509_lu.c            |  26 +++---
 crypto/x509/x509_meth.c          |   2 +-
 crypto/x509/x509_obj.c           |   6 +-
 crypto/x509/x509_r2x.c           |   2 +-
 crypto/x509/x509_req.c           |  14 ++-
 crypto/x509/x509_set.c           |   6 +-
 crypto/x509/x509_trs.c           |  10 +--
 crypto/x509/x509_v3.c            |   9 +-
 crypto/x509/x509_vfy.c           |  77 ++++++++---------
 crypto/x509/x509_vpm.c           |   2 +-
 crypto/x509/x509name.c           |  12 ++-
 crypto/x509/x509spki.c           |   6 +-
 crypto/x509/x_all.c              |   6 +-
 crypto/x509/x_crl.c              |   4 +-
 crypto/x509/x_name.c             |  20 ++---
 crypto/x509/x_pubkey.c           |  27 +++---
 crypto/x509/x_x509.c             |   2 +-
 fuzz/cmp.c                       |  12 +--
 test/cmp_ctx_test.c              |  10 +--
 test/cmp_server_test.c           |   2 +-
 test/errtest.c                   |   2 +-
 370 files changed, 3609 insertions(+), 3997 deletions(-)

diff --git a/apps/cmp_mock_srv.c b/apps/cmp_mock_srv.c
index 78d6a98e15..9acbcdf60a 100644
--- a/apps/cmp_mock_srv.c
+++ b/apps/cmp_mock_srv.c
@@ -67,7 +67,7 @@ int ossl_cmp_mock_srv_set1_certOut(OSSL_CMP_SRV_CTX *srv_ctx, X509 *cert)
     mock_srv_ctx *ctx = OSSL_CMP_SRV_CTX_get0_custom_ctx(srv_ctx);
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (cert == NULL || X509_up_ref(cert)) {
@@ -85,7 +85,7 @@ int ossl_cmp_mock_srv_set1_chainOut(OSSL_CMP_SRV_CTX *srv_ctx,
     STACK_OF(X509) *chain_copy = NULL;
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (chain != NULL &amp;&amp; (chain_copy = X509_chain_up_ref(chain)) == NULL)
@@ -102,7 +102,7 @@ int ossl_cmp_mock_srv_set1_caPubsOut(OSSL_CMP_SRV_CTX *srv_ctx,
     STACK_OF(X509) *caPubs_copy = NULL;
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (caPubs != NULL &amp;&amp; (caPubs_copy = X509_chain_up_ref(caPubs)) == NULL)
@@ -119,7 +119,7 @@ int ossl_cmp_mock_srv_set_statusInfo(OSSL_CMP_SRV_CTX *srv_ctx, int status,
     OSSL_CMP_PKISI *si;
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if ((si = OSSL_CMP_STATUSINFO_new(status, fail_info, text)) == NULL)
@@ -134,7 +134,7 @@ int ossl_cmp_mock_srv_set_send_error(OSSL_CMP_SRV_CTX *srv_ctx, int val)
     mock_srv_ctx *ctx = OSSL_CMP_SRV_CTX_get0_custom_ctx(srv_ctx);
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx-&gt;sendError = val != 0;
@@ -146,11 +146,11 @@ int ossl_cmp_mock_srv_set_pollCount(OSSL_CMP_SRV_CTX *srv_ctx, int count)
     mock_srv_ctx *ctx = OSSL_CMP_SRV_CTX_get0_custom_ctx(srv_ctx);
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (count &lt; 0) {
-        CMPerr(0, CMP_R_INVALID_ARGS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
         return 0;
     }
     ctx-&gt;pollCount = count;
@@ -162,7 +162,7 @@ int ossl_cmp_mock_srv_set_checkAfterTime(OSSL_CMP_SRV_CTX *srv_ctx, int sec)
     mock_srv_ctx *ctx = OSSL_CMP_SRV_CTX_get0_custom_ctx(srv_ctx);
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx-&gt;checkAfterTime = sec;
@@ -183,11 +183,11 @@ static OSSL_CMP_PKISI *process_cert_request(OSSL_CMP_SRV_CTX *srv_ctx,
 
     if (ctx == NULL || cert_req == NULL
             || certOut == NULL || chainOut == NULL || caPubs == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     if (ctx-&gt;sendError) {
-        CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
         return NULL;
     }
 
@@ -235,11 +235,11 @@ static OSSL_CMP_PKISI *process_rr(OSSL_CMP_SRV_CTX *srv_ctx,
     mock_srv_ctx *ctx = OSSL_CMP_SRV_CTX_get0_custom_ctx(srv_ctx);
 
     if (ctx == NULL || rr == NULL || issuer == NULL || serial == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     if (ctx-&gt;sendError || ctx-&gt;certOut == NULL) {
-        CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
         return NULL;
     }
 
@@ -247,7 +247,7 @@ static OSSL_CMP_PKISI *process_rr(OSSL_CMP_SRV_CTX *srv_ctx,
     if (X509_NAME_cmp(issuer, X509_get_issuer_name(ctx-&gt;certOut)) != 0
             || ASN1_INTEGER_cmp(serial,
                                 X509_get0_serialNumber(ctx-&gt;certOut)) != 0) {
-        CMPerr(0, CMP_R_REQUEST_NOT_ACCEPTED);
+        ERR_raise(ERR_LIB_CMP, CMP_R_REQUEST_NOT_ACCEPTED);
         return NULL;
     }
     return OSSL_CMP_PKISI_dup(ctx-&gt;statusOut);
@@ -261,11 +261,11 @@ static int process_genm(OSSL_CMP_SRV_CTX *srv_ctx,
     mock_srv_ctx *ctx = OSSL_CMP_SRV_CTX_get0_custom_ctx(srv_ctx);
 
     if (ctx == NULL || genm == NULL || in == NULL || out == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (ctx-&gt;sendError) {
-        CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
         return 0;
     }
 
@@ -285,7 +285,7 @@ static void process_error(OSSL_CMP_SRV_CTX *srv_ctx, const OSSL_CMP_MSG *error,
     int i;
 
     if (ctx == NULL || error == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return;
     }
 
@@ -330,17 +330,17 @@ static int process_certConf(OSSL_CMP_SRV_CTX *srv_ctx,
     ASN1_OCTET_STRING *digest;
 
     if (ctx == NULL || certConf == NULL || certHash == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (ctx-&gt;sendError || ctx-&gt;certOut == NULL) {
-        CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
         return 0;
     }
 
     if (certReqId != ctx-&gt;certReqId) {
         /* in case of error, invalid reqId -1 */
-        CMPerr(0, CMP_R_BAD_REQUEST_ID);
+        ERR_raise(ERR_LIB_CMP, CMP_R_BAD_REQUEST_ID);
         return 0;
     }
 
@@ -348,7 +348,7 @@ static int process_certConf(OSSL_CMP_SRV_CTX *srv_ctx,
         return 0;
     if (ASN1_OCTET_STRING_cmp(certHash, digest) != 0) {
         ASN1_OCTET_STRING_free(digest);
-        CMPerr(0, CMP_R_CERTHASH_UNMATCHED);
+        ERR_raise(ERR_LIB_CMP, CMP_R_CERTHASH_UNMATCHED);
         return 0;
     }
     ASN1_OCTET_STRING_free(digest);
@@ -363,12 +363,12 @@ static int process_pollReq(OSSL_CMP_SRV_CTX *srv_ctx,
 
     if (ctx == NULL || pollReq == NULL
             || certReq == NULL || check_after == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (ctx-&gt;sendError || ctx-&gt;certReq == NULL) {
         *certReq = NULL;
-        CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
         return 0;
     }
 
diff --git a/apps/lib/apps.c b/apps/lib/apps.c
index b790f60992..ab76ed8e7a 100644
--- a/apps/lib/apps.c
+++ b/apps/lib/apps.c
@@ -2036,15 +2036,15 @@ ASN1_VALUE *app_http_get_asn1(const char *url, const char *proxy,
     ASN1_VALUE *resp = NULL;
 
     if (url == NULL || it == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
 
     if (!OSSL_HTTP_parse_url(url, &amp;server, &amp;port, NULL, NULL, &amp;use_ssl))
         return NULL;
     if (use_ssl &amp;&amp; ssl_ctx == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
-        ERR_add_error_data(1, &quot;missing SSL_CTX&quot;);
+        ERR_raise_data(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER,
+                       &quot;missing SSL_CTX&quot;);
         goto end;
     }
 
diff --git a/crypto/asn1/a_bitstr.c b/crypto/asn1/a_bitstr.c
index a1a82f2d5d..d8c621e99d 100644
--- a/crypto/asn1/a_bitstr.c
+++ b/crypto/asn1/a_bitstr.c
@@ -134,7 +134,7 @@ ASN1_BIT_STRING *c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a,
     *pp = p;
     return ret;
  err:
-    ASN1err(ASN1_F_C2I_ASN1_BIT_STRING, i);
+    ERR_raise(ERR_LIB_ASN1, i);
     if ((a == NULL) || (*a != ret))
         ASN1_BIT_STRING_free(ret);
     return NULL;
@@ -164,7 +164,7 @@ int ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value)
             return 1;         /* Don't need to set */
         c = OPENSSL_clear_realloc(a-&gt;data, a-&gt;length, w + 1);
         if (c == NULL) {
-            ASN1err(ASN1_F_ASN1_BIT_STRING_SET_BIT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         if (w + 1 - a-&gt;length &gt; 0)
diff --git a/crypto/asn1/a_d2i_fp.c b/crypto/asn1/a_d2i_fp.c
index 9da166f9f3..4151a96561 100644
--- a/crypto/asn1/a_d2i_fp.c
+++ b/crypto/asn1/a_d2i_fp.c
@@ -25,7 +25,7 @@ void *ASN1_d2i_fp(void *(*xnew) (void), d2i_of_void *d2i, FILE *in, void **x)
     void *ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        ASN1err(ASN1_F_ASN1_D2I_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_BUF_LIB);
         return NULL;
     }
     BIO_set_fp(b, in, BIO_NOCLOSE);
@@ -80,7 +80,7 @@ void *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x)
     char *ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        ASN1err(ASN1_F_ASN1_ITEM_D2I_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_BUF_LIB);
         return NULL;
     }
     BIO_set_fp(b, in, BIO_NOCLOSE);
@@ -108,7 +108,7 @@ int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
 
     b = BUF_MEM_new();
     if (b == NULL) {
-        ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
@@ -118,17 +118,17 @@ int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
             want -= (len - off);
 
             if (len + want &lt; len || !BUF_MEM_grow_clean(b, len + want)) {
-                ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             i = BIO_read(in, &amp;(b-&gt;data[len]), want);
             if ((i &lt; 0) &amp;&amp; ((len - off) == 0)) {
-                ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_NOT_ENOUGH_DATA);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_NOT_ENOUGH_DATA);
                 goto err;
             }
             if (i &gt; 0) {
                 if (len + i &lt; len) {
-                    ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);
+                    ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LONG);
                     goto err;
                 }
                 len += i;
@@ -154,7 +154,7 @@ int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
         if (inf &amp; 1) {
             /* no data body so go round again */
             if (eos == UINT32_MAX) {
-                ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_HEADER_TOO_LONG);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_HEADER_TOO_LONG);
                 goto err;
             }
             eos++;
@@ -175,7 +175,7 @@ int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
                 want -= (len - off);
                 if (want &gt; INT_MAX /* BIO_read takes an int length */  ||
                     len + want &lt; len) {
-                    ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);
+                    ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LONG);
                     goto err;
                 }
                 while (want &gt; 0) {
@@ -188,15 +188,14 @@ int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
                     size_t chunk = want &gt; chunk_max ? chunk_max : want;
 
                     if (!BUF_MEM_grow_clean(b, len + chunk)) {
-                        ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);
+                        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
                         goto err;
                     }
                     want -= chunk;
                     while (chunk &gt; 0) {
                         i = BIO_read(in, &amp;(b-&gt;data[len]), chunk);
                         if (i &lt;= 0) {
-                            ASN1err(ASN1_F_ASN1_D2I_READ_BIO,
-                                    ASN1_R_NOT_ENOUGH_DATA);
+                            ERR_raise(ERR_LIB_ASN1, ASN1_R_NOT_ENOUGH_DATA);
                             goto err;
                         }
                     /*
@@ -211,7 +210,7 @@ int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
                 }
             }
             if (off + slen &lt; off) {
-                ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LONG);
                 goto err;
             }
             off += slen;
@@ -223,7 +222,7 @@ int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
     }
 
     if (off &gt; INT_MAX) {
-        ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LONG);
         goto err;
     }
 
diff --git a/crypto/asn1/a_digest.c b/crypto/asn1/a_digest.c
index a9709e9bc1..0fd1e6e0b8 100644
--- a/crypto/asn1/a_digest.c
+++ b/crypto/asn1/a_digest.c
@@ -33,11 +33,11 @@ int ASN1_digest(i2d_of_void *i2d, const EVP_MD *type, char *data,
 
     inl = i2d(data, NULL);
     if (inl &lt;= 0) {
-        ASN1err(ASN1_F_ASN1_DIGEST, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_INTERNAL_ERROR);
         return 0;
     }
     if ((str = OPENSSL_malloc(inl)) == NULL) {
-        ASN1err(ASN1_F_ASN1_DIGEST, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     p = str;
diff --git a/crypto/asn1/a_dup.c b/crypto/asn1/a_dup.c
index b5df08e3e2..e8adbdd97b 100644
--- a/crypto/asn1/a_dup.c
+++ b/crypto/asn1/a_dup.c
@@ -26,7 +26,7 @@ void *ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, const void *x)
     i = i2d(x, NULL);
     b = OPENSSL_malloc(i + 10);
     if (b == NULL) {
-        ASN1err(ASN1_F_ASN1_DUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     p = b;
@@ -58,7 +58,7 @@ void *ASN1_item_dup(const ASN1_ITEM *it, const void *x)
 
     i = ASN1_item_i2d(x, &amp;b, it);
     if (b == NULL) {
-        ASN1err(ASN1_F_ASN1_ITEM_DUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     p = b;
diff --git a/crypto/asn1/a_i2d_fp.c b/crypto/asn1/a_i2d_fp.c
index e718bf4cb1..111bbb80e5 100644
--- a/crypto/asn1/a_i2d_fp.c
+++ b/crypto/asn1/a_i2d_fp.c
@@ -21,7 +21,7 @@ int ASN1_i2d_fp(i2d_of_void *i2d, FILE *out, const void *x)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        ASN1err(ASN1_F_ASN1_I2D_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, out, BIO_NOCLOSE);
@@ -43,7 +43,7 @@ int ASN1_i2d_bio(i2d_of_void *i2d, BIO *out, const void *x)
 
     b = OPENSSL_malloc(n);
     if (b == NULL) {
-        ASN1err(ASN1_F_ASN1_I2D_BIO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -74,7 +74,7 @@ int ASN1_item_i2d_fp(const ASN1_ITEM *it, FILE *out, const void *x)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        ASN1err(ASN1_F_ASN1_ITEM_I2D_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, out, BIO_NOCLOSE);
@@ -91,7 +91,7 @@ int ASN1_item_i2d_bio(const ASN1_ITEM *it, BIO *out, const void *x)
 
     n = ASN1_item_i2d(x, &amp;b, it);
     if (b == NULL) {
-        ASN1err(ASN1_F_ASN1_ITEM_I2D_BIO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/asn1/a_int.c b/crypto/asn1/a_int.c
index 5676952bb6..a977b138f0 100644
--- a/crypto/asn1/a_int.c
+++ b/crypto/asn1/a_int.c
@@ -151,7 +151,7 @@ static size_t c2i_ibuf(unsigned char *b, int *pneg,
     int neg, pad;
     /* Zero content length is illegal */
     if (plen == 0) {
-        ASN1err(ASN1_F_C2I_IBUF, ASN1_R_ILLEGAL_ZERO_CONTENT);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_ZERO_CONTENT);
         return 0;
     }
     neg = p[0] &amp; 0x80;
@@ -184,7 +184,7 @@ static size_t c2i_ibuf(unsigned char *b, int *pneg,
     }
     /* reject illegal padding: first two octets MSB can't match */
     if (pad &amp;&amp; (neg == (p[1] &amp; 0x80))) {
-        ASN1err(ASN1_F_C2I_IBUF, ASN1_R_ILLEGAL_PADDING);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_PADDING);
         return 0;
     }
 
@@ -210,7 +210,7 @@ static int asn1_get_uint64(uint64_t *pr, const unsigned char *b, size_t blen)
     uint64_t r;
 
     if (blen &gt; sizeof(*pr)) {
-        ASN1err(ASN1_F_ASN1_GET_UINT64, ASN1_R_TOO_LARGE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LARGE);
         return 0;
     }
     if (b == NULL)
@@ -262,14 +262,14 @@ static int asn1_get_int64(int64_t *pr, const unsigned char *b, size_t blen,
              * on ones'-complement system. */
             *pr = (int64_t)(0 - r);
         } else {
-            ASN1err(ASN1_F_ASN1_GET_INT64, ASN1_R_TOO_SMALL);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_SMALL);
             return 0;
         }
     } else {
         if (r &lt;= INT64_MAX) {
             *pr = (int64_t)r;
         } else {
-            ASN1err(ASN1_F_ASN1_GET_INT64, ASN1_R_TOO_LARGE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LARGE);
             return 0;
         }
     }
@@ -310,7 +310,7 @@ ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,
         (*a) = ret;
     return ret;
  err:
-    ASN1err(ASN1_F_C2I_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
     if ((a == NULL) || (*a != ret))
         ASN1_INTEGER_free(ret);
     return NULL;
@@ -319,11 +319,11 @@ ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,
 static int asn1_string_get_int64(int64_t *pr, const ASN1_STRING *a, int itype)
 {
     if (a == NULL) {
-        ASN1err(ASN1_F_ASN1_STRING_GET_INT64, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if ((a-&gt;type &amp; ~V_ASN1_NEG) != itype) {
-        ASN1err(ASN1_F_ASN1_STRING_GET_INT64, ASN1_R_WRONG_INTEGER_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_WRONG_INTEGER_TYPE);
         return 0;
     }
     return asn1_get_int64(pr, a-&gt;data, a-&gt;length, a-&gt;type &amp; V_ASN1_NEG);
@@ -354,15 +354,15 @@ static int asn1_string_get_uint64(uint64_t *pr, const ASN1_STRING *a,
                                   int itype)
 {
     if (a == NULL) {
-        ASN1err(ASN1_F_ASN1_STRING_GET_UINT64, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if ((a-&gt;type &amp; ~V_ASN1_NEG) != itype) {
-        ASN1err(ASN1_F_ASN1_STRING_GET_UINT64, ASN1_R_WRONG_INTEGER_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_WRONG_INTEGER_TYPE);
         return 0;
     }
     if (a-&gt;type &amp; V_ASN1_NEG) {
-        ASN1err(ASN1_F_ASN1_STRING_GET_UINT64, ASN1_R_ILLEGAL_NEGATIVE_VALUE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_NEGATIVE_VALUE);
         return 0;
     }
     return asn1_get_uint64(pr, a-&gt;data, a-&gt;length);
@@ -440,7 +440,7 @@ ASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned char **pp,
     *pp = p;
     return ret;
  err:
-    ASN1err(ASN1_F_D2I_ASN1_UINTEGER, i);
+    ERR_raise(ERR_LIB_ASN1, i);
     if ((a == NULL) || (*a != ret))
         ASN1_INTEGER_free(ret);
     return NULL;
@@ -460,7 +460,7 @@ static ASN1_STRING *bn_to_asn1_string(const BIGNUM *bn, ASN1_STRING *ai,
     }
 
     if (ret == NULL) {
-        ASN1err(ASN1_F_BN_TO_ASN1_STRING, ERR_R_NESTED_ASN1_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
         goto err;
     }
 
@@ -473,7 +473,7 @@ static ASN1_STRING *bn_to_asn1_string(const BIGNUM *bn, ASN1_STRING *ai,
         len = 1;
 
     if (ASN1_STRING_set(ret, NULL, len) == 0) {
-        ASN1err(ASN1_F_BN_TO_ASN1_STRING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -496,13 +496,13 @@ static BIGNUM *asn1_string_to_bn(const ASN1_INTEGER *ai, BIGNUM *bn,
     BIGNUM *ret;
 
     if ((ai-&gt;type &amp; ~V_ASN1_NEG) != itype) {
-        ASN1err(ASN1_F_ASN1_STRING_TO_BN, ASN1_R_WRONG_INTEGER_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_WRONG_INTEGER_TYPE);
         return NULL;
     }
 
     ret = BN_bin2bn(ai-&gt;data, ai-&gt;length, bn);
     if (ret == NULL) {
-        ASN1err(ASN1_F_ASN1_STRING_TO_BN, ASN1_R_BN_LIB);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_BN_LIB);
         return NULL;
     }
     if (ai-&gt;type &amp; V_ASN1_NEG)
@@ -612,7 +612,7 @@ int c2i_uint64_int(uint64_t *ret, int *neg, const unsigned char **pp, long len)
     if (buflen == 0)
         return 0;
     if (buflen &gt; sizeof(uint64_t)) {
-        ASN1err(ASN1_F_C2I_UINT64_INT, ASN1_R_TOO_LARGE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LARGE);
         return 0;
     }
     (void)c2i_ibuf(buf, neg, *pp, len);
diff --git a/crypto/asn1/a_mbstr.c b/crypto/asn1/a_mbstr.c
index 122cafd02c..7279133c2a 100644
--- a/crypto/asn1/a_mbstr.c
+++ b/crypto/asn1/a_mbstr.c
@@ -49,7 +49,6 @@ int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
     ASN1_STRING *dest;
     unsigned char *p;
     int nchar;
-    char strbuf[32];
     int (*cpyfunc) (unsigned long, void *) = NULL;
     if (len == -1)
         len = strlen((const char *)in);
@@ -61,8 +60,7 @@ int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
 
     case MBSTRING_BMP:
         if (len &amp; 1) {
-            ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
-                    ASN1_R_INVALID_BMPSTRING_LENGTH);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_BMPSTRING_LENGTH);
             return -1;
         }
         nchar = len &gt;&gt; 1;
@@ -70,8 +68,7 @@ int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
 
     case MBSTRING_UNIV:
         if (len &amp; 3) {
-            ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
-                    ASN1_R_INVALID_UNIVERSALSTRING_LENGTH);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_UNIVERSALSTRING_LENGTH);
             return -1;
         }
         nchar = len &gt;&gt; 2;
@@ -82,7 +79,7 @@ int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
         /* This counts the characters and does utf8 syntax checking */
         ret = traverse_string(in, len, MBSTRING_UTF8, in_utf8, &amp;nchar);
         if (ret &lt; 0) {
-            ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_INVALID_UTF8STRING);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_UTF8STRING);
             return -1;
         }
         break;
@@ -92,27 +89,25 @@ int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
         break;
 
     default:
-        ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_UNKNOWN_FORMAT);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_FORMAT);
         return -1;
     }
 
     if ((minsize &gt; 0) &amp;&amp; (nchar &lt; minsize)) {
-        ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_SHORT);
-        BIO_snprintf(strbuf, sizeof(strbuf), &quot;%ld&quot;, minsize);
-        ERR_add_error_data(2, &quot;minsize=&quot;, strbuf);
+        ERR_raise_data(ERR_LIB_ASN1, ASN1_R_STRING_TOO_SHORT,
+                       &quot;minsize=%ld&quot;, minsize);
         return -1;
     }
 
     if ((maxsize &gt; 0) &amp;&amp; (nchar &gt; maxsize)) {
-        ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_LONG);
-        BIO_snprintf(strbuf, sizeof(strbuf), &quot;%ld&quot;, maxsize);
-        ERR_add_error_data(2, &quot;maxsize=&quot;, strbuf);
+        ERR_raise_data(ERR_LIB_ASN1, ASN1_R_STRING_TOO_LONG,
+                       &quot;maxsize=%ld&quot;, maxsize);
         return -1;
     }
 
     /* Now work out minimal type (if any) */
     if (traverse_string(in, len, inform, type_str, &amp;mask) &lt; 0) {
-        ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_ILLEGAL_CHARACTERS);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_CHARACTERS);
         return -1;
     }
 
@@ -149,7 +144,7 @@ int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
         free_out = 1;
         dest = ASN1_STRING_type_new(str_type);
         if (dest == NULL) {
-            ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return -1;
         }
         *out = dest;
@@ -157,7 +152,7 @@ int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
     /* If both the same type just copy across */
     if (inform == outform) {
         if (!ASN1_STRING_set(dest, in, len)) {
-            ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return -1;
         }
         return str_type;
@@ -189,7 +184,7 @@ int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
     if ((p = OPENSSL_malloc(outlen + 1)) == NULL) {
         if (free_out)
             ASN1_STRING_free(dest);
-        ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return -1;
     }
     dest-&gt;length = outlen;
diff --git a/crypto/asn1/a_object.c b/crypto/asn1/a_object.c
index 123f93000b..57219bf952 100644
--- a/crypto/asn1/a_object.c
+++ b/crypto/asn1/a_object.c
@@ -32,7 +32,7 @@ int i2d_ASN1_OBJECT(const ASN1_OBJECT *a, unsigned char **pp)
 
     if (*pp == NULL) {
         if ((p = allocated = OPENSSL_malloc(objsize)) == NULL) {
-            ASN1err(ASN1_F_I2D_ASN1_OBJECT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     } else {
@@ -70,12 +70,12 @@ int a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num)
     if ((c &gt;= '0') &amp;&amp; (c &lt;= '2')) {
         first = c - '0';
     } else {
-        ASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_FIRST_NUM_TOO_LARGE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_FIRST_NUM_TOO_LARGE);
         goto err;
     }
 
     if (num &lt;= 0) {
-        ASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_MISSING_SECOND_NUMBER);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_SECOND_NUMBER);
         goto err;
     }
     c = *(p++);
@@ -84,7 +84,7 @@ int a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num)
         if (num &lt;= 0)
             break;
         if ((c != '.') &amp;&amp; (c != ' ')) {
-            ASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_INVALID_SEPARATOR);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_SEPARATOR);
             goto err;
         }
         l = 0;
@@ -97,7 +97,7 @@ int a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num)
             if ((c == ' ') || (c == '.'))
                 break;
             if (!ossl_isdigit(c)) {
-                ASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_INVALID_DIGIT);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_DIGIT);
                 goto err;
             }
             if (!use_bn &amp;&amp; l &gt;= ((ULONG_MAX - 80) / 10L)) {
@@ -116,8 +116,7 @@ int a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num)
         }
         if (len == 0) {
             if ((first &lt; 2) &amp;&amp; (l &gt;= 40)) {
-                ASN1err(ASN1_F_A2D_ASN1_OBJECT,
-                        ASN1_R_SECOND_NUMBER_TOO_LARGE);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_SECOND_NUMBER_TOO_LARGE);
                 goto err;
             }
             if (use_bn) {
@@ -157,7 +156,7 @@ int a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num)
         }
         if (out != NULL) {
             if (len + i &gt; olen) {
-                ASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_BUFFER_TOO_SMALL);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_BUFFER_TOO_SMALL);
                 goto err;
             }
             while (--i &gt; 0)
@@ -192,7 +191,7 @@ int i2a_ASN1_OBJECT(BIO *bp, const ASN1_OBJECT *a)
     i = i2t_ASN1_OBJECT(buf, sizeof(buf), a);
     if (i &gt; (int)(sizeof(buf) - 1)) {
         if ((p = OPENSSL_malloc(i + 1)) == NULL) {
-            ASN1err(ASN1_F_I2A_ASN1_OBJECT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return -1;
         }
         i2t_ASN1_OBJECT(p, i + 1, a);
@@ -232,7 +231,7 @@ ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,
         *pp = p;
     return ret;
  err:
-    ASN1err(ASN1_F_D2I_ASN1_OBJECT, i);
+    ERR_raise(ERR_LIB_ASN1, i);
     return NULL;
 }
 
@@ -251,7 +250,7 @@ ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,
      */
     if (len &lt;= 0 || len &gt; INT_MAX || pp == NULL || (p = *pp) == NULL ||
         p[len - 1] &amp; 0x80) {
-        ASN1err(ASN1_F_C2I_ASN1_OBJECT, ASN1_R_INVALID_OBJECT_ENCODING);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_OBJECT_ENCODING);
         return NULL;
     }
     /* Now 0 &lt; len &lt;= INT_MAX, so the cast is safe. */
@@ -281,7 +280,7 @@ ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,
     }
     for (i = 0; i &lt; length; i++, p++) {
         if (*p == 0x80 &amp;&amp; (!i || !(p[-1] &amp; 0x80))) {
-            ASN1err(ASN1_F_C2I_ASN1_OBJECT, ASN1_R_INVALID_OBJECT_ENCODING);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_OBJECT_ENCODING);
             return NULL;
         }
     }
@@ -326,7 +325,7 @@ ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,
     *pp = p;
     return ret;
  err:
-    ASN1err(ASN1_F_C2I_ASN1_OBJECT, i);
+    ERR_raise(ERR_LIB_ASN1, i);
     if ((a == NULL) || (*a != ret))
         ASN1_OBJECT_free(ret);
     return NULL;
@@ -338,7 +337,7 @@ ASN1_OBJECT *ASN1_OBJECT_new(void)
 
     ret = OPENSSL_zalloc(sizeof(*ret));
     if (ret == NULL) {
-        ASN1err(ASN1_F_ASN1_OBJECT_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;flags = ASN1_OBJECT_FLAG_DYNAMIC;
diff --git a/crypto/asn1/a_sign.c b/crypto/asn1/a_sign.c
index c4b7b63dd5..911d61453a 100644
--- a/crypto/asn1/a_sign.c
+++ b/crypto/asn1/a_sign.c
@@ -35,7 +35,7 @@ int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1, X509_ALGOR *algor2,
     X509_ALGOR *a;
 
     if (ctx == NULL) {
-        ASN1err(ASN1_F_ASN1_SIGN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     for (i = 0; i &lt; 2; i++) {
@@ -62,18 +62,18 @@ int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1, X509_ALGOR *algor2,
         ASN1_OBJECT_free(a-&gt;algorithm);
         a-&gt;algorithm = OBJ_nid2obj(type-&gt;pkey_type);
         if (a-&gt;algorithm == NULL) {
-            ASN1err(ASN1_F_ASN1_SIGN, ASN1_R_UNKNOWN_OBJECT_TYPE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_OBJECT_TYPE);
             goto err;
         }
         if (a-&gt;algorithm-&gt;length == 0) {
-            ASN1err(ASN1_F_ASN1_SIGN,
-                    ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);
+            ERR_raise(ERR_LIB_ASN1,
+                      ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);
             goto err;
         }
     }
     inl = i2d(data, NULL);
     if (inl &lt;= 0) {
-        ASN1err(ASN1_F_ASN1_SIGN, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_INTERNAL_ERROR);
         goto err;
     }
     inll = (size_t)inl;
@@ -82,7 +82,7 @@ int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1, X509_ALGOR *algor2,
     buf_out = OPENSSL_malloc(outll);
     if (buf_in == NULL || buf_out == NULL) {
         outl = 0;
-        ASN1err(ASN1_F_ASN1_SIGN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     p = buf_in;
@@ -93,7 +93,7 @@ int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1, X509_ALGOR *algor2,
         || !EVP_SignFinal(ctx, (unsigned char *)buf_out,
                           (unsigned int *)&amp;outl, pkey)) {
         outl = 0;
-        ASN1err(ASN1_F_ASN1_SIGN, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         goto err;
     }
     OPENSSL_free(signature-&gt;data);
@@ -133,7 +133,7 @@ int ASN1_item_sign_ex(const ASN1_ITEM *it, X509_ALGOR *algor1,
     EVP_MD_CTX *ctx = evp_md_ctx_new_ex(pkey, id, libctx, propq);
 
     if (ctx == NULL) {
-        ASN1err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     if (!EVP_DigestSignInit(ctx, NULL, md, NULL, pkey))
@@ -162,7 +162,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
     pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_pkey_ctx(ctx));
 
     if (pkey == NULL) {
-        ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ASN1_R_CONTEXT_NOT_INITIALISED);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_CONTEXT_NOT_INITIALISED);
         goto err;
     }
 
@@ -174,7 +174,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
 
         if (pctx == NULL
             || !EVP_PKEY_CTX_IS_SIGNATURE_OP(pctx)) {
-            ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ASN1_R_CONTEXT_NOT_INITIALISED);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_CONTEXT_NOT_INITIALISED);
             goto err;
         }
 
@@ -187,8 +187,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
             goto err;
 
         if ((aid_len = params[0].return_size) == 0) {
-            ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX,
-                    ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED);
             goto err;
         }
 
@@ -196,7 +195,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
             const unsigned char *pp = aid;
 
             if (d2i_X509_ALGOR(&amp;algor1, &amp;pp, aid_len) == NULL) {
-                ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_ASN1, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
         }
@@ -205,7 +204,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
             const unsigned char *pp = aid;
 
             if (d2i_X509_ALGOR(&amp;algor2, &amp;pp, aid_len) == NULL) {
-                ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_ASN1, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
         }
@@ -223,7 +222,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
          *   3: ASN1 method sets algorithm identifiers: just sign.
          */
         if (rv &lt;= 0)
-            ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_EVP_LIB);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         if (rv &lt;= 1)
             goto err;
     } else {
@@ -232,7 +231,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
 
     if (rv == 2) {
         if (md == NULL) {
-            ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ASN1_R_CONTEXT_NOT_INITIALISED);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_CONTEXT_NOT_INITIALISED);
             goto err;
         }
 
@@ -243,8 +242,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
             pkey-&gt;ameth-&gt;pkey_id;
 
         if (!OBJ_find_sigid_by_algs(&amp;signid, EVP_MD_nid(md), pkey_id)) {
-            ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX,
-                    ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED);
             goto err;
         }
 
@@ -263,26 +261,26 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
     buf_len = ASN1_item_i2d(data, &amp;buf_in, it);
     if (buf_len &lt;= 0) {
         outl = 0;
-        ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_INTERNAL_ERROR);
         goto err;
     }
     inl = buf_len;
     if (!EVP_DigestSign(ctx, NULL, &amp;outll, buf_in, inl)) {
         outl = 0;
-        ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         goto err;
     }
     outl = outll;
     buf_out = OPENSSL_malloc(outll);
     if (buf_in == NULL || buf_out == NULL) {
         outl = 0;
-        ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (!EVP_DigestSign(ctx, buf_out, &amp;outl, buf_in, inl)) {
         outl = 0;
-        ASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         goto err;
     }
     OPENSSL_free(signature-&gt;data);
diff --git a/crypto/asn1/a_strex.c b/crypto/asn1/a_strex.c
index 91d78c6634..d314621520 100644
--- a/crypto/asn1/a_strex.c
+++ b/crypto/asn1/a_strex.c
@@ -152,13 +152,13 @@ static int do_buf(unsigned char *buf, int buflen,
     switch (charwidth) {
     case 4:
         if (buflen &amp; 3) {
-            ASN1err(ASN1_F_DO_BUF, ASN1_R_INVALID_UNIVERSALSTRING_LENGTH);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_UNIVERSALSTRING_LENGTH);
             return -1;
         }
         break;
     case 2:
         if (buflen &amp; 1) {
-            ASN1err(ASN1_F_DO_BUF, ASN1_R_INVALID_BMPSTRING_LENGTH);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_BMPSTRING_LENGTH);
             return -1;
         }
         break;
@@ -281,7 +281,7 @@ static int do_dump(unsigned long lflags, char_io *io_ch, void *arg,
     t.value.ptr = (char *)str;
     der_len = i2d_ASN1_TYPE(&amp;t, NULL);
     if ((der_buf = OPENSSL_malloc(der_len)) == NULL) {
-        ASN1err(ASN1_F_DO_DUMP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return -1;
     }
     p = der_buf;
diff --git a/crypto/asn1/a_strnid.c b/crypto/asn1/a_strnid.c
index 5fab787f38..9e54db9292 100644
--- a/crypto/asn1/a_strnid.c
+++ b/crypto/asn1/a_strnid.c
@@ -160,7 +160,7 @@ static ASN1_STRING_TABLE *stable_get(int nid)
     if (tmp != NULL &amp;&amp; tmp-&gt;flags &amp; STABLE_FLAGS_MALLOC)
         return tmp;
     if ((rv = OPENSSL_zalloc(sizeof(*rv))) == NULL) {
-        ASN1err(ASN1_F_STABLE_GET, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     if (!sk_ASN1_STRING_TABLE_push(stable, rv)) {
@@ -190,7 +190,7 @@ int ASN1_STRING_TABLE_add(int nid,
 
     tmp = stable_get(nid);
     if (tmp == NULL) {
-        ASN1err(ASN1_F_ASN1_STRING_TABLE_ADD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     if (minsize &gt;= 0)
diff --git a/crypto/asn1/a_time.c b/crypto/asn1/a_time.c
index 24fed45331..c34b028eaf 100644
--- a/crypto/asn1/a_time.c
+++ b/crypto/asn1/a_time.c
@@ -328,7 +328,7 @@ ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t,
 
     ts = OPENSSL_gmtime(&amp;t, &amp;data);
     if (ts == NULL) {
-        ASN1err(ASN1_F_ASN1_TIME_ADJ, ASN1_R_ERROR_GETTING_TIME);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ERROR_GETTING_TIME);
         return NULL;
     }
     if (offset_day || offset_sec) {
diff --git a/crypto/asn1/a_verify.c b/crypto/asn1/a_verify.c
index 834c3ab198..b7eed914b0 100644
--- a/crypto/asn1/a_verify.c
+++ b/crypto/asn1/a_verify.c
@@ -32,29 +32,29 @@ int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,
     int ret = -1, i, inl;
 
     if (ctx == NULL) {
-        ASN1err(ASN1_F_ASN1_VERIFY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     i = OBJ_obj2nid(a-&gt;algorithm);
     type = EVP_get_digestbyname(OBJ_nid2sn(i));
     if (type == NULL) {
-        ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
         goto err;
     }
 
     if (signature-&gt;type == V_ASN1_BIT_STRING &amp;&amp; signature-&gt;flags &amp; 0x7) {
-        ASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
         goto err;
     }
 
     inl = i2d(data, NULL);
     if (inl &lt;= 0) {
-        ASN1err(ASN1_F_ASN1_VERIFY, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_INTERNAL_ERROR);
         goto err;
     }
     buf_in = OPENSSL_malloc((unsigned int)inl);
     if (buf_in == NULL) {
-        ASN1err(ASN1_F_ASN1_VERIFY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     p = buf_in;
@@ -66,14 +66,14 @@ int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,
     OPENSSL_clear_free(buf_in, (unsigned int)inl);
 
     if (!ret) {
-        ASN1err(ASN1_F_ASN1_VERIFY, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         goto err;
     }
     ret = -1;
 
     if (EVP_VerifyFinal(ctx, (unsigned char *)signature-&gt;data,
                         (unsigned int)signature-&gt;length, pkey) &lt;= 0) {
-        ASN1err(ASN1_F_ASN1_VERIFY, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         ret = 0;
         goto err;
     }
@@ -121,24 +121,24 @@ int ASN1_item_verify_ctx(const ASN1_ITEM *it, const X509_ALGOR *alg,
     pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_pkey_ctx(ctx));
 
     if (pkey == NULL) {
-        ASN1err(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_PASSED_NULL_PARAMETER);
         return -1;
     }
 
     if (signature-&gt;type == V_ASN1_BIT_STRING &amp;&amp; signature-&gt;flags &amp; 0x7) {
-        ASN1err(0, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
         return -1;
     }
 
     /* Convert signature OID into digest and public key OIDs */
     if (!OBJ_find_sigid_algs(OBJ_obj2nid(alg-&gt;algorithm), &amp;mdnid, &amp;pknid)) {
-        ASN1err(0, ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
         goto err;
     }
 
     if (mdnid == NID_undef) {
         if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;item_verify == NULL) {
-            ASN1err(0, ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
             goto err;
         }
         ret = pkey-&gt;ameth-&gt;item_verify(ctx, it, data, alg, signature, pkey);
@@ -149,25 +149,25 @@ int ASN1_item_verify_ctx(const ASN1_ITEM *it, const X509_ALGOR *alg,
          *   2: carry on as normal, method has called EVP_DigestVerifyInit()
          */
         if (ret &lt;= 0)
-            ASN1err(0, ERR_R_EVP_LIB);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         if (ret &lt;= 1)
             goto err;
     } else {
         const EVP_MD *type = EVP_get_digestbynid(mdnid);
 
         if (type == NULL) {
-            ASN1err(0, ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
             goto err;
         }
 
         /* Check public key OID matches public key type */
         if (!EVP_PKEY_is_a(pkey, OBJ_nid2sn(pknid))) {
-            ASN1err(0, ASN1_R_WRONG_PUBLIC_KEY_TYPE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_WRONG_PUBLIC_KEY_TYPE);
             goto err;
         }
 
         if (!EVP_DigestVerifyInit(ctx, NULL, type, NULL, pkey)) {
-            ASN1err(0, ERR_R_EVP_LIB);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
             ret = 0;
             goto err;
         }
@@ -175,11 +175,11 @@ int ASN1_item_verify_ctx(const ASN1_ITEM *it, const X509_ALGOR *alg,
 
     inl = ASN1_item_i2d(data, &amp;buf_in, it);
     if (inl &lt;= 0) {
-        ASN1err(0, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_INTERNAL_ERROR);
         goto err;
     }
     if (buf_in == NULL) {
-        ASN1err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     inll = inl;
@@ -187,7 +187,7 @@ int ASN1_item_verify_ctx(const ASN1_ITEM *it, const X509_ALGOR *alg,
     ret = EVP_DigestVerify(ctx, signature-&gt;data, (size_t)signature-&gt;length,
                            buf_in, inl);
     if (ret &lt;= 0) {
-        ASN1err(0, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         goto err;
     }
     ret = 1;
diff --git a/crypto/asn1/ameth_lib.c b/crypto/asn1/ameth_lib.c
index e473112d0b..8614610333 100644
--- a/crypto/asn1/ameth_lib.c
+++ b/crypto/asn1/ameth_lib.c
@@ -156,7 +156,7 @@ int EVP_PKEY_asn1_add0(const EVP_PKEY_ASN1_METHOD *ameth)
            &amp;&amp; (ameth-&gt;pkey_flags &amp; ASN1_PKEY_ALIAS) != 0)
           || (ameth-&gt;pem_str != NULL
               &amp;&amp; (ameth-&gt;pkey_flags &amp; ASN1_PKEY_ALIAS) == 0))) {
-        EVPerr(EVP_F_EVP_PKEY_ASN1_ADD0, ERR_R_PASSED_INVALID_ARGUMENT);
+        ERR_raise(ERR_LIB_EVP, ERR_R_PASSED_INVALID_ARGUMENT);
         return 0;
     }
 
@@ -168,8 +168,8 @@ int EVP_PKEY_asn1_add0(const EVP_PKEY_ASN1_METHOD *ameth)
 
     tmp.pkey_id = ameth-&gt;pkey_id;
     if (sk_EVP_PKEY_ASN1_METHOD_find(app_methods, &amp;tmp) &gt;= 0) {
-        EVPerr(EVP_F_EVP_PKEY_ASN1_ADD0,
-               EVP_R_PKEY_APPLICATION_ASN1_METHOD_ALREADY_REGISTERED);
+        ERR_raise(ERR_LIB_EVP,
+                  EVP_R_PKEY_APPLICATION_ASN1_METHOD_ALREADY_REGISTERED);
         return 0;
     }
 
diff --git a/crypto/asn1/asn1_gen.c b/crypto/asn1/asn1_gen.c
index 896fc89c46..3c003ee103 100644
--- a/crypto/asn1/asn1_gen.c
+++ b/crypto/asn1/asn1_gen.c
@@ -91,7 +91,7 @@ ASN1_TYPE *ASN1_generate_v3(const char *str, X509V3_CTX *cnf)
     int err = 0;
     ASN1_TYPE *ret = generate_v3(str, cnf, 0, &amp;err);
     if (err)
-        ASN1err(ASN1_F_ASN1_GENERATE_V3, err);
+        ERR_raise(ERR_LIB_ASN1, err);
     return ret;
 }
 
@@ -263,8 +263,7 @@ static int asn1_cb(const char *elem, int len, void *bitstr)
     utype = asn1_str2tag(elem, len);
 
     if (utype == -1) {
-        ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG);
-        ERR_add_error_data(2, &quot;tag=&quot;, elem);
+        ERR_raise_data(ERR_LIB_ASN1, ASN1_R_UNKNOWN_TAG, &quot;tag=%s&quot;, elem);
         return -1;
     }
 
@@ -274,7 +273,7 @@ static int asn1_cb(const char *elem, int len, void *bitstr)
         arg-&gt;str = vstart;
         /* If no value and not end of string, error */
         if (!vstart &amp;&amp; elem[len]) {
-            ASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_VALUE);
             return -1;
         }
         return 0;
@@ -285,7 +284,7 @@ static int asn1_cb(const char *elem, int len, void *bitstr)
     case ASN1_GEN_FLAG_IMP:
         /* Check for illegal multiple IMPLICIT tagging */
         if (arg-&gt;imp_tag != -1) {
-            ASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_NESTED_TAGGING);
             return -1;
         }
         if (!parse_tagging(vstart, vlen, &amp;arg-&gt;imp_tag, &amp;arg-&gt;imp_class))
@@ -322,7 +321,7 @@ static int asn1_cb(const char *elem, int len, void *bitstr)
 
     case ASN1_GEN_FLAG_FORMAT:
         if (!vstart) {
-            ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_FORMAT);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_FORMAT);
             return -1;
         }
         if (strncmp(vstart, &quot;ASCII&quot;, 5) == 0)
@@ -334,7 +333,7 @@ static int asn1_cb(const char *elem, int len, void *bitstr)
         else if (strncmp(vstart, &quot;BITLIST&quot;, 7) == 0)
             arg-&gt;format = ASN1_GEN_FORMAT_BITLIST;
         else {
-            ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_FORMAT);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_FORMAT);
             return -1;
         }
         break;
@@ -347,7 +346,6 @@ static int asn1_cb(const char *elem, int len, void *bitstr)
 
 static int parse_tagging(const char *vstart, int vlen, int *ptag, int *pclass)
 {
-    char erch[2];
     long tag_num;
     char *eptr;
     if (!vstart)
@@ -357,7 +355,7 @@ static int parse_tagging(const char *vstart, int vlen, int *ptag, int *pclass)
     if (eptr &amp;&amp; *eptr &amp;&amp; (eptr &gt; vstart + vlen))
         return 0;
     if (tag_num &lt; 0) {
-        ASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_NUMBER);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_NUMBER);
         return 0;
     }
     *ptag = tag_num;
@@ -386,10 +384,8 @@ static int parse_tagging(const char *vstart, int vlen, int *ptag, int *pclass)
             break;
 
         default:
-            erch[0] = *eptr;
-            erch[1] = 0;
-            ASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_MODIFIER);
-            ERR_add_error_data(2, &quot;Char=&quot;, erch);
+            ERR_raise_data(ERR_LIB_ASN1, ASN1_R_INVALID_MODIFIER,
+                           &quot;Char=%c&quot;, *eptr);
             return 0;
 
         }
@@ -469,12 +465,12 @@ static int append_exp(tag_exp_arg *arg, int exp_tag, int exp_class,
     tag_exp_type *exp_tmp;
     /* Can only have IMPLICIT if permitted */
     if ((arg-&gt;imp_tag != -1) &amp;&amp; !imp_ok) {
-        ASN1err(ASN1_F_APPEND_EXP, ASN1_R_ILLEGAL_IMPLICIT_TAG);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_IMPLICIT_TAG);
         return 0;
     }
 
     if (arg-&gt;exp_count == ASN1_FLAG_EXP_MAX) {
-        ASN1err(ASN1_F_APPEND_EXP, ASN1_R_DEPTH_EXCEEDED);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_DEPTH_EXCEEDED);
         return 0;
     }
 
@@ -584,7 +580,7 @@ static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)
     int no_unused = 1;
 
     if ((atmp = ASN1_TYPE_new()) == NULL) {
-        ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -595,21 +591,21 @@ static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)
 
     case V_ASN1_NULL:
         if (str &amp;&amp; *str) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_NULL_VALUE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_NULL_VALUE);
             goto bad_form;
         }
         break;
 
     case V_ASN1_BOOLEAN:
         if (format != ASN1_GEN_FORMAT_ASCII) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_NOT_ASCII_FORMAT);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_NOT_ASCII_FORMAT);
             goto bad_form;
         }
         vtmp.name = NULL;
         vtmp.section = NULL;
         vtmp.value = (char *)str;
         if (!X509V3_get_value_bool(&amp;vtmp, &amp;atmp-&gt;value.boolean)) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BOOLEAN);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_BOOLEAN);
             goto bad_str;
         }
         break;
@@ -617,23 +613,23 @@ static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)
     case V_ASN1_INTEGER:
     case V_ASN1_ENUMERATED:
         if (format != ASN1_GEN_FORMAT_ASCII) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_INTEGER_NOT_ASCII_FORMAT);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_INTEGER_NOT_ASCII_FORMAT);
             goto bad_form;
         }
         if ((atmp-&gt;value.integer
                     = s2i_ASN1_INTEGER(NULL, str)) == NULL) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_INTEGER);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_INTEGER);
             goto bad_str;
         }
         break;
 
     case V_ASN1_OBJECT:
         if (format != ASN1_GEN_FORMAT_ASCII) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_OBJECT_NOT_ASCII_FORMAT);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_OBJECT_NOT_ASCII_FORMAT);
             goto bad_form;
         }
         if ((atmp-&gt;value.object = OBJ_txt2obj(str, 0)) == NULL) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_OBJECT);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_OBJECT);
             goto bad_str;
         }
         break;
@@ -641,20 +637,20 @@ static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)
     case V_ASN1_UTCTIME:
     case V_ASN1_GENERALIZEDTIME:
         if (format != ASN1_GEN_FORMAT_ASCII) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_TIME_NOT_ASCII_FORMAT);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_TIME_NOT_ASCII_FORMAT);
             goto bad_form;
         }
         if ((atmp-&gt;value.asn1_string = ASN1_STRING_new()) == NULL) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             goto bad_str;
         }
         if (!ASN1_STRING_set(atmp-&gt;value.asn1_string, str, -1)) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             goto bad_str;
         }
         atmp-&gt;value.asn1_string-&gt;type = utype;
         if (!ASN1_TIME_check(atmp-&gt;value.asn1_string)) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_TIME_VALUE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_TIME_VALUE);
             goto bad_str;
         }
 
@@ -674,13 +670,13 @@ static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)
         else if (format == ASN1_GEN_FORMAT_UTF8)
             format = MBSTRING_UTF8;
         else {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_FORMAT);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_FORMAT);
             goto bad_form;
         }
 
         if (ASN1_mbstring_copy(&amp;atmp-&gt;value.asn1_string, (unsigned char *)str,
                                -1, format, ASN1_tag2bit(utype)) &lt;= 0) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             goto bad_str;
         }
 
@@ -689,13 +685,13 @@ static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)
     case V_ASN1_BIT_STRING:
     case V_ASN1_OCTET_STRING:
         if ((atmp-&gt;value.asn1_string = ASN1_STRING_new()) == NULL) {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             goto bad_form;
         }
 
         if (format == ASN1_GEN_FORMAT_HEX) {
             if ((rdata = OPENSSL_hexstr2buf(str, &amp;rdlen)) == NULL) {
-                ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_HEX);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_HEX);
                 goto bad_str;
             }
             atmp-&gt;value.asn1_string-&gt;data = rdata;
@@ -707,13 +703,13 @@ static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)
                  &amp;&amp; (utype == V_ASN1_BIT_STRING)) {
             if (!CONF_parse_list
                 (str, ',', 1, bitstr_cb, atmp-&gt;value.bit_string)) {
-                ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_LIST_ERROR);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_LIST_ERROR);
                 goto bad_str;
             }
             no_unused = 0;
 
         } else {
-            ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BITSTRING_FORMAT);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_BITSTRING_FORMAT);
             goto bad_form;
         }
 
@@ -726,7 +722,7 @@ static ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)
         break;
 
     default:
-        ASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_UNSUPPORTED_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNSUPPORTED_TYPE);
         goto bad_str;
     }
 
@@ -752,11 +748,11 @@ static int bitstr_cb(const char *elem, int len, void *bitstr)
     if (eptr &amp;&amp; *eptr &amp;&amp; (eptr != elem + len))
         return 0;
     if (bitnum &lt; 0) {
-        ASN1err(ASN1_F_BITSTR_CB, ASN1_R_INVALID_NUMBER);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_NUMBER);
         return 0;
     }
     if (!ASN1_BIT_STRING_set_bit(bitstr, bitnum, 1)) {
-        ASN1err(ASN1_F_BITSTR_CB, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return 1;
diff --git a/crypto/asn1/asn1_lib.c b/crypto/asn1/asn1_lib.c
index d6160ac979..97b016ae18 100644
--- a/crypto/asn1/asn1_lib.c
+++ b/crypto/asn1/asn1_lib.c
@@ -90,7 +90,7 @@ int ASN1_get_object(const unsigned char **pp, long *plength, int *ptag,
         goto err;
 
     if (*plength &gt; (omax - (p - *pp))) {
-        ASN1err(ASN1_F_ASN1_GET_OBJECT, ASN1_R_TOO_LONG);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LONG);
         /*
          * Set this so that even if things are not long enough the values are
          * set correctly
@@ -100,7 +100,7 @@ int ASN1_get_object(const unsigned char **pp, long *plength, int *ptag,
     *pp = p;
     return ret | inf;
  err:
-    ASN1err(ASN1_F_ASN1_GET_OBJECT, ASN1_R_HEADER_TOO_LONG);
+    ERR_raise(ERR_LIB_ASN1, ASN1_R_HEADER_TOO_LONG);
     return 0x80;
 }
 
@@ -294,14 +294,14 @@ int ASN1_STRING_set(ASN1_STRING *str, const void *_data, int len_in)
      * '\0' terminator even though this isn't strictly necessary.
      */
     if (len &gt; INT_MAX - 1) {
-        ASN1err(0, ASN1_R_TOO_LARGE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LARGE);
         return 0;
     }
     if ((size_t)str-&gt;length &lt;= len || str-&gt;data == NULL) {
         c = str-&gt;data;
         str-&gt;data = OPENSSL_realloc(c, len + 1);
         if (str-&gt;data == NULL) {
-            ASN1err(ASN1_F_ASN1_STRING_SET, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             str-&gt;data = c;
             return 0;
         }
@@ -333,7 +333,7 @@ ASN1_STRING *ASN1_STRING_type_new(int type)
 
     ret = OPENSSL_zalloc(sizeof(*ret));
     if (ret == NULL) {
-        ASN1err(ASN1_F_ASN1_STRING_TYPE_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;type = type;
diff --git a/crypto/asn1/asn_mime.c b/crypto/asn1/asn_mime.c
index ba9b1f30a4..8ee0970dc6 100644
--- a/crypto/asn1/asn_mime.c
+++ b/crypto/asn1/asn_mime.c
@@ -74,7 +74,7 @@ int i2d_ASN1_bio_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
         BIO *bio, *tbio;
         bio = BIO_new_NDEF(out, val, it);
         if (!bio) {
-            ASN1err(ASN1_F_I2D_ASN1_BIO_STREAM, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         SMIME_crlf_copy(in, bio, flags);
@@ -104,7 +104,7 @@ static int B64_write_ASN1(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
     int r;
     b64 = BIO_new(BIO_f_base64());
     if (b64 == NULL) {
-        ASN1err(ASN1_F_B64_WRITE_ASN1, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     /*
@@ -136,13 +136,13 @@ static ASN1_VALUE *b64_read_asn1(BIO *bio, const ASN1_ITEM *it, ASN1_VALUE **x)
     ASN1_VALUE *val;
 
     if ((b64 = BIO_new(BIO_f_base64())) == NULL) {
-        ASN1err(ASN1_F_B64_READ_ASN1, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     bio = BIO_push(b64, bio);
     val = ASN1_item_d2i_bio(it, bio, x);
     if (!val)
-        ASN1err(ASN1_F_B64_READ_ASN1, ASN1_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_DECODE_ERROR);
     (void)BIO_flush(bio);
     BIO_pop(bio);
     BIO_free(b64);
@@ -350,7 +350,7 @@ static int asn1_output_data(BIO *out, BIO *data, ASN1_VALUE *val, int flags,
     }
 
     if (!aux || !aux-&gt;asn1_cb) {
-        ASN1err(ASN1_F_ASN1_OUTPUT_DATA, ASN1_R_STREAMING_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_STREAMING_NOT_SUPPORTED);
         return 0;
     }
 
@@ -403,14 +403,14 @@ ASN1_VALUE *SMIME_read_ASN1_ex(BIO *bio, BIO **bcont, const ASN1_ITEM *it,
         *bcont = NULL;
 
     if ((headers = mime_parse_hdr(bio)) == NULL) {
-        ASN1err(0, ASN1_R_MIME_PARSE_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_MIME_PARSE_ERROR);
         return NULL;
     }
 
     if ((hdr = mime_hdr_find(headers, &quot;content-type&quot;)) == NULL
         || hdr-&gt;value == NULL) {
         sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
-        ASN1err(0, ASN1_R_NO_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_NO_CONTENT_TYPE);
         return NULL;
     }
 
@@ -421,13 +421,13 @@ ASN1_VALUE *SMIME_read_ASN1_ex(BIO *bio, BIO **bcont, const ASN1_ITEM *it,
         prm = mime_param_find(hdr, &quot;boundary&quot;);
         if (prm == NULL || prm-&gt;param_value == NULL) {
             sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
-            ASN1err(0, ASN1_R_NO_MULTIPART_BOUNDARY);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_NO_MULTIPART_BOUNDARY);
             return NULL;
         }
         ret = multi_split(bio, prm-&gt;param_value, &amp;parts);
         sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
         if (!ret || (sk_BIO_num(parts) != 2)) {
-            ASN1err(0, ASN1_R_NO_MULTIPART_BODY_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_NO_MULTIPART_BODY_FAILURE);
             sk_BIO_pop_free(parts, BIO_vfree);
             return NULL;
         }
@@ -436,7 +436,7 @@ ASN1_VALUE *SMIME_read_ASN1_ex(BIO *bio, BIO **bcont, const ASN1_ITEM *it,
         asnin = sk_BIO_value(parts, 1);
 
         if ((headers = mime_parse_hdr(asnin)) == NULL) {
-            ASN1err(0, ASN1_R_MIME_SIG_PARSE_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_MIME_SIG_PARSE_ERROR);
             sk_BIO_pop_free(parts, BIO_vfree);
             return NULL;
         }
@@ -446,15 +446,15 @@ ASN1_VALUE *SMIME_read_ASN1_ex(BIO *bio, BIO **bcont, const ASN1_ITEM *it,
         if ((hdr = mime_hdr_find(headers, &quot;content-type&quot;)) == NULL
             || hdr-&gt;value == NULL) {
             sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
-            ASN1err(0, ASN1_R_NO_SIG_CONTENT_TYPE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_NO_SIG_CONTENT_TYPE);
             sk_BIO_pop_free(parts, BIO_vfree);
             return NULL;
         }
 
         if (strcmp(hdr-&gt;value, &quot;application/x-pkcs7-signature&quot;) &amp;&amp;
             strcmp(hdr-&gt;value, &quot;application/pkcs7-signature&quot;)) {
-            ASN1err(0, ASN1_R_SIG_INVALID_MIME_TYPE);
-            ERR_add_error_data(2, &quot;type: &quot;, hdr-&gt;value);
+            ERR_raise_data(ERR_LIB_ASN1, ASN1_R_SIG_INVALID_MIME_TYPE,
+                           &quot;type: %s&quot;, hdr-&gt;value);
             sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
             sk_BIO_pop_free(parts, BIO_vfree);
             return NULL;
@@ -462,7 +462,7 @@ ASN1_VALUE *SMIME_read_ASN1_ex(BIO *bio, BIO **bcont, const ASN1_ITEM *it,
         sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
         /* Read in ASN1 */
         if ((val = b64_read_asn1(asnin, it, x)) == NULL) {
-            ASN1err(0, ASN1_R_ASN1_SIG_PARSE_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ASN1_SIG_PARSE_ERROR);
             sk_BIO_pop_free(parts, BIO_vfree);
             return NULL;
         }
@@ -480,8 +480,8 @@ ASN1_VALUE *SMIME_read_ASN1_ex(BIO *bio, BIO **bcont, const ASN1_ITEM *it,
 
     if (strcmp(hdr-&gt;value, &quot;application/x-pkcs7-mime&quot;) &amp;&amp;
         strcmp(hdr-&gt;value, &quot;application/pkcs7-mime&quot;)) {
-        ASN1err(0, ASN1_R_INVALID_MIME_TYPE);
-        ERR_add_error_data(2, &quot;type: &quot;, hdr-&gt;value);
+        ERR_raise_data(ERR_LIB_ASN1, ASN1_R_INVALID_MIME_TYPE,
+                       &quot;type: %s&quot;, hdr-&gt;value);
         sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
         return NULL;
     }
@@ -489,7 +489,7 @@ ASN1_VALUE *SMIME_read_ASN1_ex(BIO *bio, BIO **bcont, const ASN1_ITEM *it,
     sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
 
     if ((val = b64_read_asn1(bio, it, x)) == NULL) {
-        ASN1err(0, ASN1_R_ASN1_PARSE_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ASN1_PARSE_ERROR);
         return NULL;
     }
     return val;
@@ -556,18 +556,18 @@ int SMIME_text(BIO *in, BIO *out)
     MIME_HEADER *hdr;
 
     if ((headers = mime_parse_hdr(in)) == NULL) {
-        ASN1err(ASN1_F_SMIME_TEXT, ASN1_R_MIME_PARSE_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_MIME_PARSE_ERROR);
         return 0;
     }
     if ((hdr = mime_hdr_find(headers, &quot;content-type&quot;)) == NULL
         || hdr-&gt;value == NULL) {
-        ASN1err(ASN1_F_SMIME_TEXT, ASN1_R_MIME_NO_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_MIME_NO_CONTENT_TYPE);
         sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
         return 0;
     }
     if (strcmp(hdr-&gt;value, &quot;text/plain&quot;)) {
-        ASN1err(ASN1_F_SMIME_TEXT, ASN1_R_INVALID_MIME_TYPE);
-        ERR_add_error_data(2, &quot;type: &quot;, hdr-&gt;value);
+        ERR_raise_data(ERR_LIB_ASN1, ASN1_R_INVALID_MIME_TYPE,
+                       &quot;type: %s&quot;, hdr-&gt;value);
         sk_MIME_HEADER_pop_free(headers, mime_hdr_free);
         return 0;
     }
diff --git a/crypto/asn1/asn_moid.c b/crypto/asn1/asn_moid.c
index 549f8f7cb1..526219c1a7 100644
--- a/crypto/asn1/asn_moid.c
+++ b/crypto/asn1/asn_moid.c
@@ -29,13 +29,13 @@ static int oid_module_init(CONF_IMODULE *md, const CONF *cnf)
 
     oid_section = CONF_imodule_get_value(md);
     if ((sktmp = NCONF_get_section(cnf, oid_section)) == NULL) {
-        ASN1err(ASN1_F_OID_MODULE_INIT, ASN1_R_ERROR_LOADING_SECTION);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ERROR_LOADING_SECTION);
         return 0;
     }
     for (i = 0; i &lt; sk_CONF_VALUE_num(sktmp); i++) {
         oval = sk_CONF_VALUE_value(sktmp, i);
         if (!do_create(oval-&gt;value, oval-&gt;name)) {
-            ASN1err(ASN1_F_OID_MODULE_INIT, ASN1_R_ADDING_OBJECT);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ADDING_OBJECT);
             return 0;
         }
     }
@@ -84,7 +84,7 @@ static int do_create(const char *value, const char *name)
         }
         p++;
         if ((lntmp = OPENSSL_malloc((p - ln) + 1)) == NULL) {
-            ASN1err(ASN1_F_DO_CREATE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         memcpy(lntmp, ln, p - ln);
diff --git a/crypto/asn1/asn_mstbl.c b/crypto/asn1/asn_mstbl.c
index ec08ecb3d8..3543cd2256 100644
--- a/crypto/asn1/asn_mstbl.c
+++ b/crypto/asn1/asn_mstbl.c
@@ -26,13 +26,13 @@ static int stbl_module_init(CONF_IMODULE *md, const CONF *cnf)
 
     stbl_section = CONF_imodule_get_value(md);
     if ((sktmp = NCONF_get_section(cnf, stbl_section)) == NULL) {
-        ASN1err(ASN1_F_STBL_MODULE_INIT, ASN1_R_ERROR_LOADING_SECTION);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ERROR_LOADING_SECTION);
         return 0;
     }
     for (i = 0; i &lt; sk_CONF_VALUE_num(sktmp); i++) {
         mval = sk_CONF_VALUE_value(sktmp, i);
         if (!do_tcreate(mval-&gt;value, mval-&gt;name)) {
-            ASN1err(ASN1_F_STBL_MODULE_INIT, ASN1_R_INVALID_VALUE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_VALUE);
             return 0;
         }
     }
@@ -96,17 +96,17 @@ static int do_tcreate(const char *value, const char *name)
     rv = 1;
  err:
     if (rv == 0) {
-        ASN1err(ASN1_F_DO_TCREATE, ASN1_R_INVALID_STRING_TABLE_VALUE);
         if (cnf)
-            ERR_add_error_data(4, &quot;field=&quot;, cnf-&gt;name,
-                               &quot;, value=&quot;, cnf-&gt;value);
+            ERR_raise_data(ERR_LIB_ASN1, ASN1_R_INVALID_STRING_TABLE_VALUE,
+                           &quot;field=%s, value=%s&quot;, cnf-&gt;name, cnf-&gt;value);
         else
-            ERR_add_error_data(4, &quot;name=&quot;, name, &quot;, value=&quot;, value);
+            ERR_raise_data(ERR_LIB_ASN1, ASN1_R_INVALID_STRING_TABLE_VALUE,
+                           &quot;name=%s, value=%s&quot;, name, value);
     } else {
         rv = ASN1_STRING_TABLE_add(nid, tbl_min, tbl_max,
                                    tbl_mask, tbl_flags);
         if (!rv)
-            ASN1err(ASN1_F_DO_TCREATE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
     }
     sk_CONF_VALUE_pop_free(lst, X509V3_conf_free);
     return rv;
diff --git a/crypto/asn1/asn_pack.c b/crypto/asn1/asn_pack.c
index 6f320de70a..dc131a303b 100644
--- a/crypto/asn1/asn_pack.c
+++ b/crypto/asn1/asn_pack.c
@@ -19,7 +19,7 @@ ASN1_STRING *ASN1_item_pack(void *obj, const ASN1_ITEM *it, ASN1_STRING **oct)
 
      if (oct == NULL || *oct == NULL) {
         if ((octmp = ASN1_STRING_new()) == NULL) {
-            ASN1err(ASN1_F_ASN1_ITEM_PACK, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     } else {
@@ -30,11 +30,11 @@ ASN1_STRING *ASN1_item_pack(void *obj, const ASN1_ITEM *it, ASN1_STRING **oct)
     octmp-&gt;data = NULL;
 
     if ((octmp-&gt;length = ASN1_item_i2d(obj, &amp;octmp-&gt;data, it)) == 0) {
-        ASN1err(ASN1_F_ASN1_ITEM_PACK, ASN1_R_ENCODE_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ENCODE_ERROR);
         goto err;
     }
     if (octmp-&gt;data == NULL) {
-        ASN1err(ASN1_F_ASN1_ITEM_PACK, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -57,6 +57,6 @@ void *ASN1_item_unpack(const ASN1_STRING *oct, const ASN1_ITEM *it)
 
     p = oct-&gt;data;
     if ((ret = ASN1_item_d2i(NULL, &amp;p, oct-&gt;length, it)) == NULL)
-        ASN1err(ASN1_F_ASN1_ITEM_UNPACK, ASN1_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_DECODE_ERROR);
     return ret;
 }
diff --git a/crypto/asn1/bio_asn1.c b/crypto/asn1/bio_asn1.c
index f802af18d6..a144fd5cbe 100644
--- a/crypto/asn1/bio_asn1.c
+++ b/crypto/asn1/bio_asn1.c
@@ -117,7 +117,7 @@ static int asn1_bio_new(BIO *b)
 static int asn1_bio_init(BIO_ASN1_BUF_CTX *ctx, int size)
 {
     if ((ctx-&gt;buf = OPENSSL_malloc(size)) == NULL) {
-        ASN1err(ASN1_F_ASN1_BIO_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ctx-&gt;bufsize = size;
diff --git a/crypto/asn1/bio_ndef.c b/crypto/asn1/bio_ndef.c
index bc7b4499d0..629a6721c5 100644
--- a/crypto/asn1/bio_ndef.c
+++ b/crypto/asn1/bio_ndef.c
@@ -58,7 +58,7 @@ BIO *BIO_new_NDEF(BIO *out, ASN1_VALUE *val, const ASN1_ITEM *it)
     ASN1_STREAM_ARG sarg;
 
     if (!aux || !aux-&gt;asn1_cb) {
-        ASN1err(ASN1_F_BIO_NEW_NDEF, ASN1_R_STREAMING_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_STREAMING_NOT_SUPPORTED);
         return NULL;
     }
     ndef_aux = OPENSSL_zalloc(sizeof(*ndef_aux));
@@ -115,7 +115,7 @@ static int ndef_prefix(BIO *b, unsigned char **pbuf, int *plen, void *parg)
 
     derlen = ASN1_item_ndef_i2d(ndef_aux-&gt;val, NULL, ndef_aux-&gt;it);
     if ((p = OPENSSL_malloc(derlen)) == NULL) {
-        ASN1err(ASN1_F_NDEF_PREFIX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -187,7 +187,7 @@ static int ndef_suffix(BIO *b, unsigned char **pbuf, int *plen, void *parg)
     if (derlen &lt; 0)
         return 0;
     if ((p = OPENSSL_malloc(derlen)) == NULL) {
-        ASN1err(ASN1_F_NDEF_SUFFIX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/asn1/d2i_param.c b/crypto/asn1/d2i_param.c
index e755eedea2..adb394d04c 100644
--- a/crypto/asn1/d2i_param.c
+++ b/crypto/asn1/d2i_param.c
@@ -30,7 +30,7 @@ EVP_PKEY *d2i_KeyParams(int type, EVP_PKEY **a, const unsigned char **pp,
         goto err;
 
     if (ret-&gt;ameth == NULL || ret-&gt;ameth-&gt;param_decode == NULL) {
-        ASN1err(ASN1_F_D2I_KEYPARAMS, ASN1_R_UNSUPPORTED_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNSUPPORTED_TYPE);
         goto err;
     }
 
diff --git a/crypto/asn1/d2i_pr.c b/crypto/asn1/d2i_pr.c
index 9da8d8e4c0..dfe770cb7f 100644
--- a/crypto/asn1/d2i_pr.c
+++ b/crypto/asn1/d2i_pr.c
@@ -30,7 +30,7 @@ EVP_PKEY *d2i_PrivateKey_ex(int type, EVP_PKEY **a, const unsigned char **pp,
 
     if ((a == NULL) || (*a == NULL)) {
         if ((ret = EVP_PKEY_new()) == NULL) {
-            ASN1err(0, ERR_R_EVP_LIB);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
             return NULL;
         }
     } else {
@@ -42,7 +42,7 @@ EVP_PKEY *d2i_PrivateKey_ex(int type, EVP_PKEY **a, const unsigned char **pp,
     }
 
     if (!EVP_PKEY_set_type(ret, type)) {
-        ASN1err(0, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);
         goto err;
     }
 
@@ -71,7 +71,7 @@ EVP_PKEY *d2i_PrivateKey_ex(int type, EVP_PKEY **a, const unsigned char **pp,
                 goto err;
         } else {
             ERR_clear_last_mark();
-            ASN1err(0, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_ASN1_LIB);
             goto err;
         }
     } else {
@@ -128,7 +128,7 @@ EVP_PKEY *d2i_AutoPrivateKey_ex(EVP_PKEY **a, const unsigned char **pp,
 
         sk_ASN1_TYPE_pop_free(inkey, ASN1_TYPE_free);
         if (p8 == NULL) {
-            ASN1err(0, ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
             return NULL;
         }
         ret = EVP_PKCS82PKEY_ex(p8, libctx, propq);
diff --git a/crypto/asn1/d2i_pu.c b/crypto/asn1/d2i_pu.c
index 3779a8208d..6b3506e314 100644
--- a/crypto/asn1/d2i_pu.c
+++ b/crypto/asn1/d2i_pu.c
@@ -32,14 +32,14 @@ EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
 
     if ((a == NULL) || (*a == NULL)) {
         if ((ret = EVP_PKEY_new()) == NULL) {
-            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_EVP_LIB);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
             return NULL;
         }
     } else
         ret = *a;
 
     if (type != EVP_PKEY_id(ret) &amp;&amp; !EVP_PKEY_set_type(ret, type)) {
-        ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         goto err;
     }
 
@@ -47,7 +47,7 @@ EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
 #ifndef OPENSSL_NO_RSA
     case EVP_PKEY_RSA:
         if ((ret-&gt;pkey.rsa = d2i_RSAPublicKey(NULL, pp, length)) == NULL) {
-            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_ASN1_LIB);
             goto err;
         }
         break;
@@ -56,7 +56,7 @@ EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
     case EVP_PKEY_DSA:
         /* TMP UGLY CAST */
         if (!d2i_DSAPublicKey(&amp;ret-&gt;pkey.dsa, pp, length)) {
-            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_ASN1_LIB);
             goto err;
         }
         break;
@@ -64,13 +64,13 @@ EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
 #ifndef OPENSSL_NO_EC
     case EVP_PKEY_EC:
         if (!o2i_ECPublicKey(&amp;ret-&gt;pkey.ec, pp, length)) {
-            ASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_ASN1_LIB);
             goto err;
         }
         break;
 #endif
     default:
-        ASN1err(ASN1_F_D2I_PUBLICKEY, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);
         goto err;
     }
     if (a != NULL)
diff --git a/crypto/asn1/evp_asn1.c b/crypto/asn1/evp_asn1.c
index 844aabe603..3129fdf2df 100644
--- a/crypto/asn1/evp_asn1.c
+++ b/crypto/asn1/evp_asn1.c
@@ -34,7 +34,7 @@ int ASN1_TYPE_get_octetstring(const ASN1_TYPE *a, unsigned char *data, int max_l
     const unsigned char *p;
 
     if ((a-&gt;type != V_ASN1_OCTET_STRING) || (a-&gt;value.octet_string == NULL)) {
-        ASN1err(ASN1_F_ASN1_TYPE_GET_OCTETSTRING, ASN1_R_DATA_IS_WRONG);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_DATA_IS_WRONG);
         return -1;
     }
     p = ASN1_STRING_get0_data(a-&gt;value.octet_string);
@@ -121,7 +121,7 @@ int ASN1_TYPE_get_int_octetstring(const ASN1_TYPE *a, long *num,
 
     if (ret == -1) {
  err:
-        ASN1err(ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING, ASN1_R_DATA_IS_WRONG);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_DATA_IS_WRONG);
     }
     M_ASN1_free_of(atmp, asn1_int_oct);
     return ret;
@@ -176,7 +176,7 @@ int asn1_type_get_octetstring_int(const ASN1_TYPE *a, long *num,
 
     if (ret == -1) {
  err:
-        ASN1err(ASN1_F_ASN1_TYPE_GET_OCTETSTRING_INT, ASN1_R_DATA_IS_WRONG);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_DATA_IS_WRONG);
     }
     M_ASN1_free_of(atmp, asn1_oct_int);
     return ret;
diff --git a/crypto/asn1/f_int.c b/crypto/asn1/f_int.c
index 295ecb6fc5..04afbdf9e1 100644
--- a/crypto/asn1/f_int.c
+++ b/crypto/asn1/f_int.c
@@ -100,7 +100,7 @@ int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size)
         k = 0;
         i -= again;
         if (i % 2 != 0) {
-            ASN1err(ASN1_F_A2I_ASN1_INTEGER, ASN1_R_ODD_NUMBER_OF_CHARS);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ODD_NUMBER_OF_CHARS);
             OPENSSL_free(s);
             return 0;
         }
@@ -108,7 +108,7 @@ int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size)
         if (num + i &gt; slen) {
             sp = OPENSSL_clear_realloc(s, slen, num + i * 2);
             if (sp == NULL) {
-                ASN1err(ASN1_F_A2I_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
                 OPENSSL_free(s);
                 return 0;
             }
@@ -119,8 +119,7 @@ int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size)
             for (n = 0; n &lt; 2; n++) {
                 m = OPENSSL_hexchar2int(bufp[k + n]);
                 if (m &lt; 0) {
-                    ASN1err(ASN1_F_A2I_ASN1_INTEGER,
-                            ASN1_R_NON_HEX_CHARACTERS);
+                    ERR_raise(ERR_LIB_ASN1, ASN1_R_NON_HEX_CHARACTERS);
                     goto err;
                 }
                 s[num + j] &lt;&lt;= 4;
@@ -137,7 +136,7 @@ int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size)
     bs-&gt;data = s;
     return 1;
  err:
-    ASN1err(ASN1_F_A2I_ASN1_INTEGER, ASN1_R_SHORT_LINE);
+    ERR_raise(ERR_LIB_ASN1, ASN1_R_SHORT_LINE);
     OPENSSL_free(s);
     return 0;
 }
diff --git a/crypto/asn1/f_string.c b/crypto/asn1/f_string.c
index 0b930dfd0a..2607a56233 100644
--- a/crypto/asn1/f_string.c
+++ b/crypto/asn1/f_string.c
@@ -91,7 +91,7 @@ int a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size)
         k = 0;
         i -= again;
         if (i % 2 != 0) {
-            ASN1err(ASN1_F_A2I_ASN1_STRING, ASN1_R_ODD_NUMBER_OF_CHARS);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ODD_NUMBER_OF_CHARS);
             OPENSSL_free(s);
             return 0;
         }
@@ -99,7 +99,7 @@ int a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size)
         if (num + i &gt; slen) {
             sp = OPENSSL_realloc(s, (unsigned int)num + i * 2);
             if (sp == NULL) {
-                ASN1err(ASN1_F_A2I_ASN1_STRING, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
                 OPENSSL_free(s);
                 return 0;
             }
@@ -110,8 +110,7 @@ int a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size)
             for (n = 0; n &lt; 2; n++) {
                 m = OPENSSL_hexchar2int(bufp[k + n]);
                 if (m &lt; 0) {
-                    ASN1err(ASN1_F_A2I_ASN1_STRING,
-                            ASN1_R_NON_HEX_CHARACTERS);
+                    ERR_raise(ERR_LIB_ASN1, ASN1_R_NON_HEX_CHARACTERS);
                     OPENSSL_free(s);
                     return 0;
                 }
@@ -130,7 +129,7 @@ int a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size)
     return 1;
 
  err:
-    ASN1err(ASN1_F_A2I_ASN1_STRING, ASN1_R_SHORT_LINE);
+    ERR_raise(ERR_LIB_ASN1, ASN1_R_SHORT_LINE);
     OPENSSL_free(s);
     return 0;
 }
diff --git a/crypto/asn1/p5_pbe.c b/crypto/asn1/p5_pbe.c
index cf46cc2409..e4627a5cc1 100644
--- a/crypto/asn1/p5_pbe.c
+++ b/crypto/asn1/p5_pbe.c
@@ -33,13 +33,13 @@ int PKCS5_pbe_set0_algor(X509_ALGOR *algor, int alg, int iter,
 
     pbe = PBEPARAM_new();
     if (pbe == NULL) {
-        ASN1err(ASN1_F_PKCS5_PBE_SET0_ALGOR, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (iter &lt;= 0)
         iter = PKCS5_DEFAULT_ITER;
     if (!ASN1_INTEGER_set(pbe-&gt;iter, iter)) {
-        ASN1err(ASN1_F_PKCS5_PBE_SET0_ALGOR, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (!saltlen)
@@ -47,7 +47,7 @@ int PKCS5_pbe_set0_algor(X509_ALGOR *algor, int alg, int iter,
 
     sstr = OPENSSL_malloc(saltlen);
     if (sstr == NULL) {
-        ASN1err(ASN1_F_PKCS5_PBE_SET0_ALGOR, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (salt)
@@ -59,7 +59,7 @@ int PKCS5_pbe_set0_algor(X509_ALGOR *algor, int alg, int iter,
     sstr = NULL;
 
     if (!ASN1_item_pack(pbe, ASN1_ITEM_rptr(PBEPARAM), &amp;pbe_str)) {
-        ASN1err(ASN1_F_PKCS5_PBE_SET0_ALGOR, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -84,7 +84,7 @@ X509_ALGOR *PKCS5_pbe_set(int alg, int iter,
     X509_ALGOR *ret;
     ret = X509_ALGOR_new();
     if (ret == NULL) {
-        ASN1err(ASN1_F_PKCS5_PBE_SET, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/asn1/p5_pbev2.c b/crypto/asn1/p5_pbev2.c
index f7f5f4655a..61196ad6e9 100644
--- a/crypto/asn1/p5_pbev2.c
+++ b/crypto/asn1/p5_pbev2.c
@@ -49,8 +49,7 @@ X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *cipher, int iter,
 
     alg_nid = EVP_CIPHER_type(cipher);
     if (alg_nid == NID_undef) {
-        ASN1err(ASN1_F_PKCS5_PBE2_SET_IV,
-                ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
         goto err;
     }
 
@@ -79,7 +78,7 @@ X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *cipher, int iter,
     if (!EVP_CipherInit_ex(ctx, cipher, NULL, NULL, iv, 0))
         goto err;
     if (EVP_CIPHER_param_to_asn1(ctx, scheme-&gt;parameter) &lt;= 0) {
-        ASN1err(ASN1_F_PKCS5_PBE2_SET_IV, ASN1_R_ERROR_SETTING_CIPHER_PARAMS);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ERROR_SETTING_CIPHER_PARAMS);
         goto err;
     }
     /*
@@ -129,7 +128,7 @@ X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *cipher, int iter,
     return ret;
 
  merr:
-    ASN1err(ASN1_F_PKCS5_PBE2_SET_IV, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
 
  err:
     EVP_CIPHER_CTX_free(ctx);
@@ -214,7 +213,7 @@ X509_ALGOR *PKCS5_pbkdf2_set(int iter, unsigned char *salt, int saltlen,
     return keyfunc;
 
  merr:
-    ASN1err(ASN1_F_PKCS5_PBKDF2_SET, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
     PBKDF2PARAM_free(kdf);
     X509_ALGOR_free(keyfunc);
     return NULL;
diff --git a/crypto/asn1/p5_scrypt.c b/crypto/asn1/p5_scrypt.c
index d6f38e8579..0166b87e15 100644
--- a/crypto/asn1/p5_scrypt.c
+++ b/crypto/asn1/p5_scrypt.c
@@ -49,20 +49,18 @@ X509_ALGOR *PKCS5_pbe2_set_scrypt(const EVP_CIPHER *cipher,
     PBE2PARAM *pbe2 = NULL;
 
     if (!cipher) {
-        ASN1err(ASN1_F_PKCS5_PBE2_SET_SCRYPT, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_PASSED_NULL_PARAMETER);
         goto err;
     }
 
     if (EVP_PBE_scrypt(NULL, 0, NULL, 0, N, r, p, 0, NULL, 0) == 0) {
-        ASN1err(ASN1_F_PKCS5_PBE2_SET_SCRYPT,
-                ASN1_R_INVALID_SCRYPT_PARAMETERS);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_INVALID_SCRYPT_PARAMETERS);
         goto err;
     }
 
     alg_nid = EVP_CIPHER_type(cipher);
     if (alg_nid == NID_undef) {
-        ASN1err(ASN1_F_PKCS5_PBE2_SET_SCRYPT,
-                ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
         goto err;
     }
 
@@ -94,8 +92,7 @@ X509_ALGOR *PKCS5_pbe2_set_scrypt(const EVP_CIPHER *cipher,
     if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, iv, 0) == 0)
         goto err;
     if (EVP_CIPHER_param_to_asn1(ctx, scheme-&gt;parameter) &lt;= 0) {
-        ASN1err(ASN1_F_PKCS5_PBE2_SET_SCRYPT,
-                ASN1_R_ERROR_SETTING_CIPHER_PARAMS);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ERROR_SETTING_CIPHER_PARAMS);
         goto err;
     }
     EVP_CIPHER_CTX_free(ctx);
@@ -135,7 +132,7 @@ X509_ALGOR *PKCS5_pbe2_set_scrypt(const EVP_CIPHER *cipher,
     return ret;
 
  merr:
-    ASN1err(ASN1_F_PKCS5_PBE2_SET_SCRYPT, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
 
  err:
     PBE2PARAM_free(pbe2);
@@ -202,7 +199,7 @@ static X509_ALGOR *pkcs5_scrypt_set(const unsigned char *salt, size_t saltlen,
     return keyfunc;
 
  merr:
-    ASN1err(ASN1_F_PKCS5_SCRYPT_SET, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
  err:
     SCRYPT_PARAMS_free(sparam);
     X509_ALGOR_free(keyfunc);
@@ -221,7 +218,7 @@ int PKCS5_v2_scrypt_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,
     SCRYPT_PARAMS *sparam = NULL;
 
     if (EVP_CIPHER_CTX_cipher(ctx) == NULL) {
-        EVPerr(EVP_F_PKCS5_V2_SCRYPT_KEYIVGEN, EVP_R_NO_CIPHER_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_CIPHER_SET);
         goto err;
     }
 
@@ -230,13 +227,13 @@ int PKCS5_v2_scrypt_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,
     sparam = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(SCRYPT_PARAMS), param);
 
     if (sparam == NULL) {
-        EVPerr(EVP_F_PKCS5_V2_SCRYPT_KEYIVGEN, EVP_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_DECODE_ERROR);
         goto err;
     }
 
     t = EVP_CIPHER_CTX_key_length(ctx);
     if (t &lt; 0) {
-        EVPerr(EVP_F_PKCS5_V2_SCRYPT_KEYIVGEN, EVP_R_INVALID_KEY_LENGTH);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_KEY_LENGTH);
         goto err;
     }
     keylen = t;
@@ -247,8 +244,7 @@ int PKCS5_v2_scrypt_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,
         uint64_t spkeylen;
         if ((ASN1_INTEGER_get_uint64(&amp;spkeylen, sparam-&gt;keyLength) == 0)
             || (spkeylen != keylen)) {
-            EVPerr(EVP_F_PKCS5_V2_SCRYPT_KEYIVGEN,
-                   EVP_R_UNSUPPORTED_KEYLENGTH);
+            ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_KEYLENGTH);
             goto err;
         }
     }
@@ -257,8 +253,7 @@ int PKCS5_v2_scrypt_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,
         || ASN1_INTEGER_get_uint64(&amp;r, sparam-&gt;blockSize) == 0
         || ASN1_INTEGER_get_uint64(&amp;p, sparam-&gt;parallelizationParameter) == 0
         || EVP_PBE_scrypt(NULL, 0, NULL, 0, N, r, p, 0, NULL, 0) == 0) {
-        EVPerr(EVP_F_PKCS5_V2_SCRYPT_KEYIVGEN,
-               EVP_R_ILLEGAL_SCRYPT_PARAMETERS);
+        ERR_raise(ERR_LIB_EVP, EVP_R_ILLEGAL_SCRYPT_PARAMETERS);
         goto err;
     }
 
diff --git a/crypto/asn1/tasn_dec.c b/crypto/asn1/tasn_dec.c
index 740707f853..3fbf168558 100644
--- a/crypto/asn1/tasn_dec.c
+++ b/crypto/asn1/tasn_dec.c
@@ -158,7 +158,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
         asn1_cb = 0;
 
     if (++depth &gt; ASN1_MAX_CONSTRUCTED_NEST) {
-        ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_NESTED_TOO_DEEP);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_NESTED_TOO_DEEP);
         goto err;
     }
 
@@ -172,8 +172,8 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
              * template in the template itself.
              */
             if ((tag != -1) || opt) {
-                ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I,
-                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
+                ERR_raise(ERR_LIB_ASN1,
+                          ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
                 goto err;
             }
             return asn1_template_ex_d2i(pval, in, len,
@@ -188,7 +188,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
         ret = asn1_check_tlen(NULL, &amp;otag, &amp;oclass, NULL, NULL,
                               &amp;p, len, -1, 0, 1, ctx);
         if (!ret) {
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
 
@@ -197,7 +197,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
             /* If OPTIONAL, assume this is OK */
             if (opt)
                 return -1;
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_MSTRING_NOT_UNIVERSAL);
             goto err;
         }
         /* Check tag matches bit map */
@@ -205,7 +205,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
             /* If OPTIONAL, assume this is OK */
             if (opt)
                 return -1;
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_MSTRING_WRONG_TAG);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_MSTRING_WRONG_TAG);
             goto err;
         }
         return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);
@@ -228,7 +228,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
                 asn1_set_choice_selector(pval, -1, it);
             }
         } else if (!ASN1_item_ex_new(pval, it)) {
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
         /* CHOICE type, try each possibility in turn */
@@ -251,7 +251,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
              */
             asn1_template_free(pchptr, tt);
             errtt = tt;
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
 
@@ -263,7 +263,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
                 ASN1_item_ex_free(pval, it);
                 return -1;
             }
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_NO_MATCHING_CHOICE_TYPE);
             goto err;
         }
 
@@ -288,7 +288,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
         ret = asn1_check_tlen(&amp;len, NULL, NULL, &amp;seq_eoc, &amp;cst,
                               &amp;p, len, tag, aclass, opt, ctx);
         if (!ret) {
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         } else if (ret == -1)
             return -1;
@@ -300,12 +300,12 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
         else
             seq_nolen = seq_eoc;
         if (!cst) {
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
             goto err;
         }
 
         if (*pval == NULL &amp;&amp; !ASN1_item_ex_new(pval, it)) {
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
 
@@ -339,7 +339,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
             q = p;
             if (asn1_check_eoc(&amp;p, len)) {
                 if (!seq_eoc) {
-                    ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_UNEXPECTED_EOC);
+                    ERR_raise(ERR_LIB_ASN1, ASN1_R_UNEXPECTED_EOC);
                     goto err;
                 }
                 len -= p - q;
@@ -379,12 +379,12 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
 
         /* Check for EOC if expecting one */
         if (seq_eoc &amp;&amp; !asn1_check_eoc(&amp;p, len)) {
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_MISSING_EOC);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);
             goto err;
         }
         /* Check all data read */
         if (!seq_nolen &amp;&amp; len) {
-            ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
             goto err;
         }
 
@@ -404,7 +404,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
                 asn1_template_free(pseqval, seqtt);
             } else {
                 errtt = seqtt;
-                ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_FIELD_MISSING);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_FIELD_MISSING);
                 goto err;
             }
         }
@@ -420,7 +420,7 @@ static int asn1_item_embed_d2i(ASN1_VALUE **pval, const unsigned char **in,
         return 0;
     }
  auxerr:
-    ASN1err(ASN1_F_ASN1_ITEM_EMBED_D2I, ASN1_R_AUX_ERROR);
+    ERR_raise(ERR_LIB_ASN1, ASN1_R_AUX_ERROR);
  err:
     if (errtt)
         ERR_add_error_data(4, &quot;Field=&quot;, errtt-&gt;field_name,
@@ -463,19 +463,18 @@ static int asn1_template_ex_d2i(ASN1_VALUE **val,
                               &amp;p, inlen, tt-&gt;tag, aclass, opt, ctx);
         q = p;
         if (!ret) {
-            ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             return 0;
         } else if (ret == -1)
             return -1;
         if (!cst) {
-            ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
-                    ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
             return 0;
         }
         /* We've found the field so it can't be OPTIONAL now */
         ret = asn1_template_noexp_d2i(val, &amp;p, len, tt, 0, ctx, depth);
         if (!ret) {
-            ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             return 0;
         }
         /* We read the field in OK so update length */
@@ -483,7 +482,7 @@ static int asn1_template_ex_d2i(ASN1_VALUE **val,
         if (exp_eoc) {
             /* If NDEF we must have an EOC here */
             if (!asn1_check_eoc(&amp;p, len)) {
-                ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ASN1_R_MISSING_EOC);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);
                 goto err;
             }
         } else {
@@ -491,8 +490,7 @@ static int asn1_template_ex_d2i(ASN1_VALUE **val,
              * Otherwise we must hit the EXPLICIT tag end or its an error
              */
             if (len) {
-                ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
-                        ASN1_R_EXPLICIT_LENGTH_MISMATCH);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_EXPLICIT_LENGTH_MISMATCH);
                 goto err;
             }
         }
@@ -551,7 +549,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
         ret = asn1_check_tlen(&amp;len, NULL, NULL, &amp;sk_eoc, NULL,
                               &amp;p, len, sktag, skaclass, opt, ctx);
         if (!ret) {
-            ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             return 0;
         } else if (ret == -1)
             return -1;
@@ -570,7 +568,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
         }
 
         if (*val == NULL) {
-            ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
@@ -581,8 +579,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
             /* See if EOC found */
             if (asn1_check_eoc(&amp;p, len)) {
                 if (!sk_eoc) {
-                    ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
-                            ASN1_R_UNEXPECTED_EOC);
+                    ERR_raise(ERR_LIB_ASN1, ASN1_R_UNEXPECTED_EOC);
                     goto err;
                 }
                 len -= p - q;
@@ -593,21 +590,20 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
             if (!asn1_item_embed_d2i(&amp;skfield, &amp;p, len,
                                      ASN1_ITEM_ptr(tt-&gt;item), -1, 0, 0, ctx,
                                      depth)) {
-                ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
-                        ERR_R_NESTED_ASN1_ERROR);
+                ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
                 /* |skfield| may be partially allocated despite failure. */
                 ASN1_item_free(skfield, ASN1_ITEM_ptr(tt-&gt;item));
                 goto err;
             }
             len -= p - q;
             if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) {
-                ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
                 ASN1_item_free(skfield, ASN1_ITEM_ptr(tt-&gt;item));
                 goto err;
             }
         }
         if (sk_eoc) {
-            ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ASN1_R_MISSING_EOC);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);
             goto err;
         }
     } else if (flags &amp; ASN1_TFLG_IMPTAG) {
@@ -616,7 +612,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
                                   ASN1_ITEM_ptr(tt-&gt;item), tt-&gt;tag, aclass, opt,
                                   ctx, depth);
         if (!ret) {
-            ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         } else if (ret == -1)
             return -1;
@@ -625,7 +621,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
         ret = asn1_item_embed_d2i(val, &amp;p, len, ASN1_ITEM_ptr(tt-&gt;item),
                                   -1, 0, opt, ctx, depth);
         if (!ret) {
-            ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         } else if (ret == -1)
             return -1;
@@ -652,7 +648,7 @@ static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
     long len;
 
     if (pval == NULL) {
-        ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_NULL);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_NULL);
         return 0;               /* Should never happen */
     }
 
@@ -666,19 +662,18 @@ static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
         /* If type is ANY need to figure out type from tag */
         unsigned char oclass;
         if (tag &gt;= 0) {
-            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_TAGGED_ANY);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_TAGGED_ANY);
             return 0;
         }
         if (opt) {
-            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
-                    ASN1_R_ILLEGAL_OPTIONAL_ANY);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_OPTIONAL_ANY);
             return 0;
         }
         p = *in;
         ret = asn1_check_tlen(NULL, &amp;utype, &amp;oclass, NULL, NULL,
                               &amp;p, inlen, -1, 0, 0, ctx);
         if (!ret) {
-            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             return 0;
         }
         if (oclass != V_ASN1_UNIVERSAL)
@@ -693,7 +688,7 @@ static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
     ret = asn1_check_tlen(&amp;plen, NULL, NULL, &amp;inf, &amp;cst,
                           &amp;p, inlen, tag, aclass, opt, ctx);
     if (!ret) {
-        ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_NESTED_ASN1_ERROR);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
         return 0;
     } else if (ret == -1)
         return -1;
@@ -710,8 +705,7 @@ static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
         }
         /* SEQUENCE and SET must be constructed */
         else if (!cst) {
-            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
-                    ASN1_R_TYPE_NOT_CONSTRUCTED);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_TYPE_NOT_CONSTRUCTED);
             return 0;
         }
 
@@ -729,7 +723,7 @@ static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
         if (utype == V_ASN1_NULL || utype == V_ASN1_BOOLEAN
             || utype == V_ASN1_OBJECT || utype == V_ASN1_INTEGER
             || utype == V_ASN1_ENUMERATED) {
-            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_TYPE_NOT_PRIMITIVE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_TYPE_NOT_PRIMITIVE);
             return 0;
         }
 
@@ -747,7 +741,7 @@ static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,
         len = buf.length;
         /* Append a final null to string */
         if (!BUF_MEM_grow_clean(&amp;buf, len + 1)) {
-            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         buf.data[len] = 0;
@@ -809,7 +803,7 @@ static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
 
     case V_ASN1_NULL:
         if (len) {
-            ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_NULL_IS_WRONG_LENGTH);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_NULL_IS_WRONG_LENGTH);
             goto err;
         }
         *pval = (ASN1_VALUE *)1;
@@ -817,7 +811,7 @@ static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
 
     case V_ASN1_BOOLEAN:
         if (len != 1) {
-            ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
             goto err;
         } else {
             ASN1_BOOLEAN *tbool;
@@ -859,19 +853,18 @@ static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
     case V_ASN1_SEQUENCE:
     default:
         if (utype == V_ASN1_BMPSTRING &amp;&amp; (len &amp; 1)) {
-            ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
             goto err;
         }
         if (utype == V_ASN1_UNIVERSALSTRING &amp;&amp; (len &amp; 3)) {
-            ASN1err(ASN1_F_ASN1_EX_C2I,
-                    ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
             goto err;
         }
         /* All based on ASN1_STRING and handled the same */
         if (*pval == NULL) {
             stmp = ASN1_STRING_type_new(utype);
             if (stmp == NULL) {
-                ASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             *pval = (ASN1_VALUE *)stmp;
@@ -887,7 +880,7 @@ static int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
             *free_cont = 0;
         } else {
             if (!ASN1_STRING_set(stmp, cont, len)) {
-                ASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
                 ASN1_STRING_free(stmp);
                 *pval = NULL;
                 goto err;
@@ -945,12 +938,12 @@ static int asn1_find_end(const unsigned char **in, long len, char inf)
         /* Just read in a header: only care about the length */
         if (!asn1_check_tlen(&amp;plen, NULL, NULL, &amp;inf, NULL, &amp;p, len,
                              -1, 0, 0, NULL)) {
-            ASN1err(ASN1_F_ASN1_FIND_END, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             return 0;
         }
         if (inf) {
             if (expected_eoc == UINT32_MAX) {
-                ASN1err(ASN1_F_ASN1_FIND_END, ERR_R_NESTED_ASN1_ERROR);
+                ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
                 return 0;
             }
             expected_eoc++;
@@ -960,7 +953,7 @@ static int asn1_find_end(const unsigned char **in, long len, char inf)
         len -= p - q;
     }
     if (expected_eoc) {
-        ASN1err(ASN1_F_ASN1_FIND_END, ASN1_R_MISSING_EOC);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);
         return 0;
     }
     *in = p;
@@ -1007,7 +1000,7 @@ static int asn1_collect(BUF_MEM *buf, const unsigned char **in, long len,
              * EOC is illegal outside indefinite length constructed form
              */
             if (!inf) {
-                ASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_UNEXPECTED_EOC);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_UNEXPECTED_EOC);
                 return 0;
             }
             inf = 0;
@@ -1016,14 +1009,14 @@ static int asn1_collect(BUF_MEM *buf, const unsigned char **in, long len,
 
         if (!asn1_check_tlen(&amp;plen, NULL, NULL, &amp;ininf, &amp;cst, &amp;p,
                              len, tag, aclass, 0, NULL)) {
-            ASN1err(ASN1_F_ASN1_COLLECT, ERR_R_NESTED_ASN1_ERROR);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
             return 0;
         }
 
         /* If indefinite length constructed update max length */
         if (cst) {
             if (depth &gt;= ASN1_MAX_STRING_NEST) {
-                ASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_NESTED_ASN1_STRING);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_NESTED_ASN1_STRING);
                 return 0;
             }
             if (!asn1_collect(buf, &amp;p, plen, ininf, tag, aclass, depth + 1))
@@ -1033,7 +1026,7 @@ static int asn1_collect(BUF_MEM *buf, const unsigned char **in, long len,
         len -= p - q;
     }
     if (inf) {
-        ASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_MISSING_EOC);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_MISSING_EOC);
         return 0;
     }
     *in = p;
@@ -1046,7 +1039,7 @@ static int collect_data(BUF_MEM *buf, const unsigned char **p, long plen)
     if (buf) {
         len = buf-&gt;length;
         if (!BUF_MEM_grow_clean(buf, len + plen)) {
-            ASN1err(ASN1_F_COLLECT_DATA, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         memcpy(buf-&gt;data + len, *p, plen);
@@ -1110,7 +1103,7 @@ static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
              * total amount of data available.
              */
             if (!(i &amp; 0x81) &amp;&amp; ((plen + ctx-&gt;hdrlen) &gt; len)) {
-                ASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_TOO_LONG);
+                ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LONG);
                 asn1_tlc_clear(ctx);
                 return 0;
             }
@@ -1118,7 +1111,7 @@ static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
     }
 
     if (i &amp; 0x80) {
-        ASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_BAD_OBJECT_HEADER);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_BAD_OBJECT_HEADER);
         asn1_tlc_clear(ctx);
         return 0;
     }
@@ -1130,7 +1123,7 @@ static int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,
             if (opt)
                 return -1;
             asn1_tlc_clear(ctx);
-            ASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_WRONG_TAG);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_WRONG_TAG);
             return 0;
         }
         /*
diff --git a/crypto/asn1/tasn_enc.c b/crypto/asn1/tasn_enc.c
index d8abd81698..6a47ad6a78 100644
--- a/crypto/asn1/tasn_enc.c
+++ b/crypto/asn1/tasn_enc.c
@@ -63,7 +63,7 @@ static int asn1_item_flags_i2d(const ASN1_VALUE *val, unsigned char **out,
         if (len &lt;= 0)
             return len;
         if ((buf = OPENSSL_malloc(len)) == NULL) {
-            ASN1err(ASN1_F_ASN1_ITEM_FLAGS_I2D, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return -1;
         }
         p = buf;
diff --git a/crypto/asn1/tasn_new.c b/crypto/asn1/tasn_new.c
index 5bdcf461a5..06fc558457 100644
--- a/crypto/asn1/tasn_new.c
+++ b/crypto/asn1/tasn_new.c
@@ -136,13 +136,13 @@ int asn1_item_embed_new(ASN1_VALUE **pval, const ASN1_ITEM *it, int embed)
  memerr2:
     asn1_item_embed_free(pval, it, embed);
  memerr:
-    ASN1err(ASN1_F_ASN1_ITEM_EMBED_NEW, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
     return 0;
 
  auxerr2:
     asn1_item_embed_free(pval, it, embed);
  auxerr:
-    ASN1err(ASN1_F_ASN1_ITEM_EMBED_NEW, ASN1_R_AUX_ERROR);
+    ERR_raise(ERR_LIB_ASN1, ASN1_R_AUX_ERROR);
     return 0;
 
 }
@@ -205,7 +205,7 @@ static int asn1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)
         STACK_OF(ASN1_VALUE) *skval;
         skval = sk_ASN1_VALUE_new_null();
         if (!skval) {
-            ASN1err(ASN1_F_ASN1_TEMPLATE_NEW, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             ret = 0;
             goto done;
         }
@@ -274,7 +274,7 @@ static int asn1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it,
 
     case V_ASN1_ANY:
         if ((typ = OPENSSL_malloc(sizeof(*typ))) == NULL) {
-            ASN1err(ASN1_F_ASN1_PRIMITIVE_NEW, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         typ-&gt;value.ptr = NULL;
diff --git a/crypto/asn1/tasn_prn.c b/crypto/asn1/tasn_prn.c
index ff86400d66..23ae7b4f08 100644
--- a/crypto/asn1/tasn_prn.c
+++ b/crypto/asn1/tasn_prn.c
@@ -38,7 +38,7 @@ ASN1_PCTX *ASN1_PCTX_new(void)
 
     ret = OPENSSL_zalloc(sizeof(*ret));
     if (ret == NULL) {
-        ASN1err(ASN1_F_ASN1_PCTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     return ret;
diff --git a/crypto/asn1/tasn_scn.c b/crypto/asn1/tasn_scn.c
index a8401c9d21..402695cf8c 100644
--- a/crypto/asn1/tasn_scn.c
+++ b/crypto/asn1/tasn_scn.c
@@ -27,7 +27,7 @@ ASN1_SCTX *ASN1_SCTX_new(int (*scan_cb) (ASN1_SCTX *ctx))
     ASN1_SCTX *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        ASN1err(ASN1_F_ASN1_SCTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;scan_cb = scan_cb;
diff --git a/crypto/asn1/tasn_utl.c b/crypto/asn1/tasn_utl.c
index a31c7c275f..f7c988ede4 100644
--- a/crypto/asn1/tasn_utl.c
+++ b/crypto/asn1/tasn_utl.c
@@ -85,7 +85,7 @@ int asn1_do_lock(ASN1_VALUE **pval, int op, const ASN1_ITEM *it)
         *lck = ret = 1;
         *lock = CRYPTO_THREAD_lock_new();
         if (*lock == NULL) {
-            ASN1err(ASN1_F_ASN1_DO_LOCK, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
             return -1;
         }
         break;
@@ -168,7 +168,7 @@ int asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,
 
     OPENSSL_free(enc-&gt;enc);
     if ((enc-&gt;enc = OPENSSL_malloc(inlen)) == NULL) {
-        ASN1err(ASN1_F_ASN1_ENC_SAVE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     memcpy(enc-&gt;enc, in, inlen);
@@ -255,7 +255,7 @@ const ASN1_TEMPLATE *asn1_do_adb(const ASN1_VALUE *val,
 
     /* Let application callback translate value */
     if (adb-&gt;adb_cb != NULL &amp;&amp; adb-&gt;adb_cb(&amp;selector) == 0) {
-        ASN1err(ASN1_F_ASN1_DO_ADB, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
         return NULL;
     }
 
@@ -280,6 +280,6 @@ const ASN1_TEMPLATE *asn1_do_adb(const ASN1_VALUE *val,
  err:
     /* FIXME: should log the value or OID of unsupported type */
     if (nullerr)
-        ASN1err(ASN1_F_ASN1_DO_ADB, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
     return NULL;
 }
diff --git a/crypto/asn1/x_algor.c b/crypto/asn1/x_algor.c
index 7e198a558c..9a313170f0 100644
--- a/crypto/asn1/x_algor.c
+++ b/crypto/asn1/x_algor.c
@@ -150,7 +150,7 @@ const EVP_MD *x509_algor_get_md(X509_ALGOR *alg)
         return EVP_sha1();
     md = EVP_get_digestbyobj(alg-&gt;algorithm);
     if (md == NULL)
-        ASN1err(0, ASN1_R_UNKNOWN_DIGEST);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_UNKNOWN_DIGEST);
     return md;
 }
 
diff --git a/crypto/asn1/x_info.c b/crypto/asn1/x_info.c
index 78a9c58914..9231f06e4a 100644
--- a/crypto/asn1/x_info.c
+++ b/crypto/asn1/x_info.c
@@ -19,7 +19,7 @@ X509_INFO *X509_INFO_new(void)
 
     ret = OPENSSL_zalloc(sizeof(*ret));
     if (ret == NULL) {
-        ASN1err(ASN1_F_X509_INFO_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/asn1/x_int64.c b/crypto/asn1/x_int64.c
index 211cdc4e67..baa5385541 100644
--- a/crypto/asn1/x_int64.c
+++ b/crypto/asn1/x_int64.c
@@ -29,7 +29,7 @@
 static int uint64_new(ASN1_VALUE **pval, const ASN1_ITEM *it)
 {
     if ((*pval = (ASN1_VALUE *)OPENSSL_zalloc(sizeof(uint64_t))) == NULL) {
-        ASN1err(ASN1_F_UINT64_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return 1;
@@ -94,12 +94,12 @@ static int uint64_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
     if (!c2i_uint64_int(&amp;utmp, &amp;neg, &amp;cont, len))
         return 0;
     if ((it-&gt;size &amp; INTxx_FLAG_SIGNED) == 0 &amp;&amp; neg) {
-        ASN1err(ASN1_F_UINT64_C2I, ASN1_R_ILLEGAL_NEGATIVE_VALUE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_NEGATIVE_VALUE);
         return 0;
     }
     if ((it-&gt;size &amp; INTxx_FLAG_SIGNED) == INTxx_FLAG_SIGNED
             &amp;&amp; !neg &amp;&amp; utmp &gt; INT64_MAX) {
-        ASN1err(ASN1_F_UINT64_C2I, ASN1_R_TOO_LARGE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LARGE);
         return 0;
     }
     if (neg)
@@ -124,7 +124,7 @@ static int uint64_print(BIO *out, const ASN1_VALUE **pval, const ASN1_ITEM *it,
 static int uint32_new(ASN1_VALUE **pval, const ASN1_ITEM *it)
 {
     if ((*pval = (ASN1_VALUE *)OPENSSL_zalloc(sizeof(uint32_t))) == NULL) {
-        ASN1err(ASN1_F_UINT32_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return 1;
@@ -197,19 +197,19 @@ static int uint32_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
     if (!c2i_uint64_int(&amp;utmp, &amp;neg, &amp;cont, len))
         return 0;
     if ((it-&gt;size &amp; INTxx_FLAG_SIGNED) == 0 &amp;&amp; neg) {
-        ASN1err(ASN1_F_UINT32_C2I, ASN1_R_ILLEGAL_NEGATIVE_VALUE);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_NEGATIVE_VALUE);
         return 0;
     }
     if (neg) {
         if (utmp &gt; ABS_INT32_MIN) {
-            ASN1err(ASN1_F_UINT32_C2I, ASN1_R_TOO_SMALL);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_SMALL);
             return 0;
         }
         utmp = 0 - utmp;
     } else {
         if (((it-&gt;size &amp; INTxx_FLAG_SIGNED) != 0 &amp;&amp; utmp &gt; INT32_MAX)
             || ((it-&gt;size &amp; INTxx_FLAG_SIGNED) == 0 &amp;&amp; utmp &gt; UINT32_MAX)) {
-            ASN1err(ASN1_F_UINT32_C2I, ASN1_R_TOO_LARGE);
+            ERR_raise(ERR_LIB_ASN1, ASN1_R_TOO_LARGE);
             return 0;
         }
     }
diff --git a/crypto/asn1/x_long.c b/crypto/asn1/x_long.c
index ffdd376eae..0685780f08 100644
--- a/crypto/asn1/x_long.c
+++ b/crypto/asn1/x_long.c
@@ -152,7 +152,7 @@ static int long_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
         }
     }
     if (len &gt; (int)sizeof(long)) {
-        ASN1err(ASN1_F_LONG_C2I, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);
         return 0;
     }
 
@@ -163,7 +163,7 @@ static int long_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
         else
             sign = 0;
     } else if (((sign ^ cont[0]) &amp; 0x80) == 0) { /* same sign bit? */
-        ASN1err(ASN1_F_LONG_C2I, ASN1_R_ILLEGAL_PADDING);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_ILLEGAL_PADDING);
         return 0;
     }
     utmp = 0;
@@ -173,13 +173,13 @@ static int long_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,
     }
     ltmp = (long)utmp;
     if (ltmp &lt; 0) {
-        ASN1err(ASN1_F_LONG_C2I, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);
         return 0;
     }
     if (sign)
         ltmp = -ltmp - 1;
     if (ltmp == it-&gt;size) {
-        ASN1err(ASN1_F_LONG_C2I, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);
+        ERR_raise(ERR_LIB_ASN1, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);
         return 0;
     }
     memcpy(pval, &amp;ltmp, COPY_SIZE(*pval, ltmp));
diff --git a/crypto/asn1/x_pkey.c b/crypto/asn1/x_pkey.c
index 9d36d1a07c..967239b668 100644
--- a/crypto/asn1/x_pkey.c
+++ b/crypto/asn1/x_pkey.c
@@ -29,7 +29,7 @@ X509_PKEY *X509_PKEY_new(void)
     return ret;
 err:
     X509_PKEY_free(ret);
-    ASN1err(ASN1_F_X509_PKEY_NEW, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
diff --git a/crypto/async/async.c b/crypto/async/async.c
index 8eedad97ea..9546458e9a 100644
--- a/crypto/async/async.c
+++ b/crypto/async/async.c
@@ -41,7 +41,7 @@ static async_ctx *async_ctx_new(void)
 
     nctx = OPENSSL_malloc(sizeof(*nctx));
     if (nctx == NULL) {
-        ASYNCerr(ASYNC_F_ASYNC_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASYNC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -83,7 +83,7 @@ static ASYNC_JOB *async_job_new(void)
 
     job = OPENSSL_zalloc(sizeof(*job));
     if (job == NULL) {
-        ASYNCerr(ASYNC_F_ASYNC_JOB_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASYNC, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -161,7 +161,7 @@ void async_start_func(void)
              * Should not happen. Getting here will close the thread...can't do
              * much about it
              */
-            ASYNCerr(ASYNC_F_ASYNC_START_FUNC, ASYNC_R_FAILED_TO_SWAP_CONTEXT);
+            ERR_raise(ERR_LIB_ASYNC, ASYNC_R_FAILED_TO_SWAP_CONTEXT);
         }
     }
 }
@@ -212,8 +212,7 @@ int ASYNC_start_job(ASYNC_JOB **job, ASYNC_WAIT_CTX *wctx, int *ret,
                 /* Resume previous job */
                 if (!async_fibre_swapcontext(&amp;ctx-&gt;dispatcher,
                         &amp;ctx-&gt;currjob-&gt;fibrectx, 1)) {
-                    ASYNCerr(ASYNC_F_ASYNC_START_JOB,
-                             ASYNC_R_FAILED_TO_SWAP_CONTEXT);
+                    ERR_raise(ERR_LIB_ASYNC, ASYNC_R_FAILED_TO_SWAP_CONTEXT);
                     goto err;
                 }
                 /*
@@ -226,7 +225,7 @@ int ASYNC_start_job(ASYNC_JOB **job, ASYNC_WAIT_CTX *wctx, int *ret,
             }
 
             /* Should not happen */
-            ASYNCerr(ASYNC_F_ASYNC_START_JOB, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_ASYNC, ERR_R_INTERNAL_ERROR);
             async_release_job(ctx-&gt;currjob);
             ctx-&gt;currjob = NULL;
             *job = NULL;
@@ -240,7 +239,7 @@ int ASYNC_start_job(ASYNC_JOB **job, ASYNC_WAIT_CTX *wctx, int *ret,
         if (args != NULL) {
             ctx-&gt;currjob-&gt;funcargs = OPENSSL_malloc(size);
             if (ctx-&gt;currjob-&gt;funcargs == NULL) {
-                ASYNCerr(ASYNC_F_ASYNC_START_JOB, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_ASYNC, ERR_R_MALLOC_FAILURE);
                 async_release_job(ctx-&gt;currjob);
                 ctx-&gt;currjob = NULL;
                 return ASYNC_ERR;
@@ -255,7 +254,7 @@ int ASYNC_start_job(ASYNC_JOB **job, ASYNC_WAIT_CTX *wctx, int *ret,
         libctx = ossl_lib_ctx_get_concrete(NULL);
         if (!async_fibre_swapcontext(&amp;ctx-&gt;dispatcher,
                 &amp;ctx-&gt;currjob-&gt;fibrectx, 1)) {
-            ASYNCerr(ASYNC_F_ASYNC_START_JOB, ASYNC_R_FAILED_TO_SWAP_CONTEXT);
+            ERR_raise(ERR_LIB_ASYNC, ASYNC_R_FAILED_TO_SWAP_CONTEXT);
             goto err;
         }
         /*
@@ -292,7 +291,7 @@ int ASYNC_pause_job(void)
 
     if (!async_fibre_swapcontext(&amp;job-&gt;fibrectx,
                                  &amp;ctx-&gt;dispatcher, 1)) {
-        ASYNCerr(ASYNC_F_ASYNC_PAUSE_JOB, ASYNC_R_FAILED_TO_SWAP_CONTEXT);
+        ERR_raise(ERR_LIB_ASYNC, ASYNC_R_FAILED_TO_SWAP_CONTEXT);
         return 0;
     }
     /* Reset counts of added and deleted fds */
@@ -339,7 +338,7 @@ int ASYNC_init_thread(size_t max_size, size_t init_size)
     size_t curr_size = 0;
 
     if (init_size &gt; max_size) {
-        ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ASYNC_R_INVALID_POOL_SIZE);
+        ERR_raise(ERR_LIB_ASYNC, ASYNC_R_INVALID_POOL_SIZE);
         return 0;
     }
 
@@ -351,13 +350,13 @@ int ASYNC_init_thread(size_t max_size, size_t init_size)
 
     pool = OPENSSL_zalloc(sizeof(*pool));
     if (pool == NULL) {
-        ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASYNC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
     pool-&gt;jobs = sk_ASYNC_JOB_new_reserve(NULL, init_size);
     if (pool-&gt;jobs == NULL) {
-        ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASYNC, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(pool);
         return 0;
     }
@@ -382,7 +381,7 @@ int ASYNC_init_thread(size_t max_size, size_t init_size)
     }
     pool-&gt;curr_size = curr_size;
     if (!CRYPTO_THREAD_set_local(&amp;poolkey, pool)) {
-        ASYNCerr(ASYNC_F_ASYNC_INIT_THREAD, ASYNC_R_FAILED_TO_SET_POOL);
+        ERR_raise(ERR_LIB_ASYNC, ASYNC_R_FAILED_TO_SET_POOL);
         goto err;
     }
 
diff --git a/crypto/async/async_wait.c b/crypto/async/async_wait.c
index 87e480d949..20d8d436f7 100644
--- a/crypto/async/async_wait.c
+++ b/crypto/async/async_wait.c
@@ -48,7 +48,7 @@ int ASYNC_WAIT_CTX_set_wait_fd(ASYNC_WAIT_CTX *ctx, const void *key,
     struct fd_lookup_st *fdlookup;
 
     if ((fdlookup = OPENSSL_zalloc(sizeof(*fdlookup))) == NULL) {
-        ASYNCerr(ASYNC_F_ASYNC_WAIT_CTX_SET_WAIT_FD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASYNC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/bio/b_addr.c b/crypto/bio/b_addr.c
index 4a367ec54c..841cc58100 100644
--- a/crypto/bio/b_addr.c
+++ b/crypto/bio/b_addr.c
@@ -11,6 +11,16 @@
 # define _GNU_SOURCE
 #endif
 
+/*
+ * VC configurations may define UNICODE, to indicate to the C RTL that
+ * WCHAR functions are preferred.
+ * This affects functions like gai_strerror(), which is implemented as
+ * an alias macro for gai_strerrorA() (which returns a const char *) or
+ * gai_strerrorW() (which returns a const WCHAR *).  This source file
+ * assumes POSIX declarations, so prefer the non-UNICODE definitions.
+ */
+#undef UNICODE
+
 #include &lt;assert.h&gt;
 #include &lt;string.h&gt;
 
@@ -44,7 +54,7 @@ BIO_ADDR *BIO_ADDR_new(void)
     BIO_ADDR *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        BIOerr(BIO_F_BIO_ADDR_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -213,12 +223,10 @@ static int addr_strings(const BIO_ADDR *ap, int numeric,
             if (ret == EAI_SYSTEM) {
                 ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                                &quot;calling getnameinfo()&quot;);
-                BIOerr(BIO_F_ADDR_STRINGS, ERR_R_SYS_LIB);
             } else
 # endif
             {
-                BIOerr(BIO_F_ADDR_STRINGS, ERR_R_SYS_LIB);
-                ERR_add_error_data(1, gai_strerror(ret));
+                ERR_raise_data(ERR_LIB_BIO, ERR_R_SYS_LIB, gai_strerror(ret));
             }
             return 0;
         }
@@ -259,7 +267,7 @@ static int addr_strings(const BIO_ADDR *ap, int numeric,
             OPENSSL_free(*service);
             *service = NULL;
         }
-        BIOerr(BIO_F_ADDR_STRINGS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -546,13 +554,13 @@ int BIO_parse_hostserv(const char *hostserv, char **host, char **service,
 
     return 1;
  amb_err:
-    BIOerr(BIO_F_BIO_PARSE_HOSTSERV, BIO_R_AMBIGUOUS_HOST_OR_SERVICE);
+    ERR_raise(ERR_LIB_BIO, BIO_R_AMBIGUOUS_HOST_OR_SERVICE);
     return 0;
  spec_err:
-    BIOerr(BIO_F_BIO_PARSE_HOSTSERV, BIO_R_MALFORMED_HOST_OR_SERVICE);
+    ERR_raise(ERR_LIB_BIO, BIO_R_MALFORMED_HOST_OR_SERVICE);
     return 0;
  memerr:
-    BIOerr(BIO_F_BIO_PARSE_HOSTSERV, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
@@ -571,7 +579,7 @@ static int addrinfo_wrap(int family, int socktype,
                          BIO_ADDRINFO **bai)
 {
     if ((*bai = OPENSSL_zalloc(sizeof(**bai))) == NULL) {
-        BIOerr(BIO_F_ADDRINFO_WRAP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -661,7 +669,7 @@ int BIO_lookup_ex(const char *host, const char *service, int lookup_type,
 #endif
         break;
     default:
-        BIOerr(BIO_F_BIO_LOOKUP_EX, BIO_R_UNSUPPORTED_PROTOCOL_FAMILY);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNSUPPORTED_PROTOCOL_FAMILY);
         return 0;
     }
 
@@ -670,7 +678,7 @@ int BIO_lookup_ex(const char *host, const char *service, int lookup_type,
         if (addrinfo_wrap(family, socktype, host, strlen(host), 0, res))
             return 1;
         else
-            BIOerr(BIO_F_BIO_LOOKUP_EX, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 #endif
@@ -709,12 +717,12 @@ int BIO_lookup_ex(const char *host, const char *service, int lookup_type,
         case EAI_SYSTEM:
             ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                            &quot;calling getaddrinfo()&quot;);
-            BIOerr(BIO_F_BIO_LOOKUP_EX, ERR_R_SYS_LIB);
+            ERR_raise(ERR_LIB_BIO, ERR_R_SYS_LIB);
             break;
 # endif
 # ifdef EAI_MEMORY
         case EAI_MEMORY:
-            BIOerr(BIO_F_BIO_LOOKUP_EX, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
             break;
 # endif
         case 0:
@@ -729,8 +737,8 @@ int BIO_lookup_ex(const char *host, const char *service, int lookup_type,
                 goto retry;
             }
 # endif
-            BIOerr(BIO_F_BIO_LOOKUP_EX, ERR_R_SYS_LIB);
-            ERR_add_error_data(1, gai_strerror(old_ret ? old_ret : gai_ret));
+            ERR_raise_data(ERR_LIB_BIO, ERR_R_SYS_LIB,
+                           gai_strerror(old_ret ? old_ret : gai_ret));
             break;
         }
     } else {
@@ -771,7 +779,7 @@ int BIO_lookup_ex(const char *host, const char *service, int lookup_type,
 #endif
 
         if (!RUN_ONCE(&amp;bio_lookup_init, do_bio_lookup_init)) {
-            BIOerr(BIO_F_BIO_LOOKUP_EX, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
             ret = 0;
             goto err;
         }
@@ -790,7 +798,7 @@ int BIO_lookup_ex(const char *host, const char *service, int lookup_type,
             default:
                 /* We forgot to handle a lookup type! */
                 assert(&quot;We forgot to handle a lookup type!&quot; == NULL);
-                BIOerr(BIO_F_BIO_LOOKUP_EX, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_BIO, ERR_R_INTERNAL_ERROR);
                 ret = 0;
                 goto err;
             }
@@ -871,7 +879,7 @@ int BIO_lookup_ex(const char *host, const char *service, int lookup_type,
                     goto err;
                 }
             } else {
-                BIOerr(BIO_F_BIO_LOOKUP_EX, BIO_R_MALFORMED_HOST_OR_SERVICE);
+                ERR_raise(ERR_LIB_BIO, BIO_R_MALFORMED_HOST_OR_SERVICE);
                 goto err;
             }
         }
@@ -913,7 +921,7 @@ int BIO_lookup_ex(const char *host, const char *service, int lookup_type,
              addrinfo_malloc_err:
                 BIO_ADDRINFO_free(*res);
                 *res = NULL;
-                BIOerr(BIO_F_BIO_LOOKUP_EX, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
                 ret = 0;
                 goto err;
             }
diff --git a/crypto/bio/b_print.c b/crypto/bio/b_print.c
index 853f094a8a..8192534ef2 100644
--- a/crypto/bio/b_print.c
+++ b/crypto/bio/b_print.c
@@ -824,7 +824,7 @@ doapr_outch(char **sbuffer,
         *maxlen += BUFFER_INC;
         if (*buffer == NULL) {
             if ((*buffer = OPENSSL_malloc(*maxlen)) == NULL) {
-                BIOerr(BIO_F_DOAPR_OUTCH, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
             if (*currlen &gt; 0) {
diff --git a/crypto/bio/b_sock.c b/crypto/bio/b_sock.c
index 61dbf474f9..d0cdae7b3d 100644
--- a/crypto/bio/b_sock.c
+++ b/crypto/bio/b_sock.c
@@ -49,8 +49,7 @@ int BIO_get_host_ip(const char *str, unsigned char *ip)
         size_t l;
 
         if (BIO_ADDRINFO_family(res) != AF_INET) {
-            BIOerr(BIO_F_BIO_GET_HOST_IP,
-                   BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);
+            ERR_raise(ERR_LIB_BIO, BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);
         } else if (BIO_ADDR_rawaddress(BIO_ADDRINFO_address(res), NULL, &amp;l)) {
             /*
              * Because only AF_INET addresses will reach this far, we can assert
@@ -73,7 +72,7 @@ int BIO_get_port(const char *str, unsigned short *port_ptr)
     int ret = 0;
 
     if (str == NULL) {
-        BIOerr(BIO_F_BIO_GET_PORT, BIO_R_NO_PORT_DEFINED);
+        ERR_raise(ERR_LIB_BIO, BIO_R_NO_PORT_DEFINED);
         return 0;
     }
 
@@ -82,8 +81,7 @@ int BIO_get_port(const char *str, unsigned short *port_ptr)
 
     if (BIO_lookup(NULL, str, BIO_LOOKUP_CLIENT, AF_INET, SOCK_STREAM, &amp;res)) {
         if (BIO_ADDRINFO_family(res) != AF_INET) {
-            BIOerr(BIO_F_BIO_GET_PORT,
-                   BIO_R_ADDRINFO_ADDR_IS_NOT_AF_INET);
+            ERR_raise(ERR_LIB_BIO, BIO_R_ADDRINFO_ADDR_IS_NOT_AF_INET);
         } else {
             *port_ptr = ntohs(BIO_ADDR_rawport(BIO_ADDRINFO_address(res)));
             ret = 1;
@@ -143,7 +141,7 @@ int BIO_sock_init(void)
         if (WSAStartup(0x0202, &amp;wsa_state) != 0) {
             ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                            &quot;calling wsastartup()&quot;);
-            BIOerr(BIO_F_BIO_SOCK_INIT, BIO_R_WSASTARTUP);
+            ERR_raise(ERR_LIB_BIO, BIO_R_WSASTARTUP);
             return -1;
         }
     }
@@ -256,7 +254,7 @@ int BIO_accept(int sock, char **ip_port)
         }
         ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                        &quot;calling accept()&quot;);
-        BIOerr(BIO_F_BIO_ACCEPT, BIO_R_ACCEPT_ERROR);
+        ERR_raise(ERR_LIB_BIO, BIO_R_ACCEPT_ERROR);
         goto end;
     }
 
@@ -269,7 +267,7 @@ int BIO_accept(int sock, char **ip_port)
             *ip_port = NULL;
 
         if (*ip_port == NULL) {
-            BIOerr(BIO_F_BIO_ACCEPT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
             BIO_closesocket(ret);
             ret = (int)INVALID_SOCKET;
         } else {
@@ -345,7 +343,7 @@ int BIO_socket_nbio(int s, int mode)
     }
 # else
     /* make sure this call always pushes an error level; BIO_socket_ioctl() does so, so we do too. */
-    BIOerr(BIO_F_BIO_SOCKET_NBIO, ERR_R_PASSED_INVALID_ARGUMENT);
+    ERR_raise(ERR_LIB_BIO, ERR_R_PASSED_INVALID_ARGUMENT);
 # endif
 
     return (ret == 0);
@@ -365,17 +363,17 @@ int BIO_sock_info(int sock,
             if (ret == -1) {
                 ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                                &quot;calling getsockname()&quot;);
-                BIOerr(BIO_F_BIO_SOCK_INFO, BIO_R_GETSOCKNAME_ERROR);
+                ERR_raise(ERR_LIB_BIO, BIO_R_GETSOCKNAME_ERROR);
                 return 0;
             }
             if ((size_t)addr_len &gt; sizeof(*info-&gt;addr)) {
-                BIOerr(BIO_F_BIO_SOCK_INFO, BIO_R_GETSOCKNAME_TRUNCATED_ADDRESS);
+                ERR_raise(ERR_LIB_BIO, BIO_R_GETSOCKNAME_TRUNCATED_ADDRESS);
                 return 0;
             }
         }
         break;
     default:
-        BIOerr(BIO_F_BIO_SOCK_INFO, BIO_R_UNKNOWN_INFO_TYPE);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNKNOWN_INFO_TYPE);
         return 0;
     }
     return 1;
diff --git a/crypto/bio/b_sock2.c b/crypto/bio/b_sock2.c
index 42e2475373..c9f7c2cfe5 100644
--- a/crypto/bio/b_sock2.c
+++ b/crypto/bio/b_sock2.c
@@ -49,7 +49,7 @@ int BIO_socket(int domain, int socktype, int protocol, int options)
     if (sock == -1) {
         ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                        &quot;calling socket()&quot;);
-        BIOerr(BIO_F_BIO_SOCKET, BIO_R_UNABLE_TO_CREATE_SOCKET);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_CREATE_SOCKET);
         return INVALID_SOCKET;
     }
 # ifndef OPENSSL_NO_KTLS
@@ -92,7 +92,7 @@ int BIO_connect(int sock, const BIO_ADDR *addr, int options)
     const int on = 1;
 
     if (sock == -1) {
-        BIOerr(BIO_F_BIO_CONNECT, BIO_R_INVALID_SOCKET);
+        ERR_raise(ERR_LIB_BIO, BIO_R_INVALID_SOCKET);
         return 0;
     }
 
@@ -104,7 +104,7 @@ int BIO_connect(int sock, const BIO_ADDR *addr, int options)
                        (const void *)&amp;on, sizeof(on)) != 0) {
             ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                            &quot;calling setsockopt()&quot;);
-            BIOerr(BIO_F_BIO_CONNECT, BIO_R_UNABLE_TO_KEEPALIVE);
+            ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_KEEPALIVE);
             return 0;
         }
     }
@@ -114,7 +114,7 @@ int BIO_connect(int sock, const BIO_ADDR *addr, int options)
                        (const void *)&amp;on, sizeof(on)) != 0) {
             ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                            &quot;calling setsockopt()&quot;);
-            BIOerr(BIO_F_BIO_CONNECT, BIO_R_UNABLE_TO_NODELAY);
+            ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_NODELAY);
             return 0;
         }
     }
@@ -124,7 +124,7 @@ int BIO_connect(int sock, const BIO_ADDR *addr, int options)
         if (!BIO_sock_should_retry(-1)) {
             ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                            &quot;calling connect()&quot;);
-            BIOerr(BIO_F_BIO_CONNECT, BIO_R_CONNECT_ERROR);
+            ERR_raise(ERR_LIB_BIO, BIO_R_CONNECT_ERROR);
         }
         return 0;
     }
@@ -154,7 +154,7 @@ int BIO_bind(int sock, const BIO_ADDR *addr, int options)
 # endif
 
     if (sock == -1) {
-        BIOerr(BIO_F_BIO_BIND, BIO_R_INVALID_SOCKET);
+        ERR_raise(ERR_LIB_BIO, BIO_R_INVALID_SOCKET);
         return 0;
     }
 
@@ -168,7 +168,7 @@ int BIO_bind(int sock, const BIO_ADDR *addr, int options)
                        (const void *)&amp;on, sizeof(on)) != 0) {
             ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                            &quot;calling setsockopt()&quot;);
-            BIOerr(BIO_F_BIO_BIND, BIO_R_UNABLE_TO_REUSEADDR);
+            ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_REUSEADDR);
             return 0;
         }
     }
@@ -177,7 +177,7 @@ int BIO_bind(int sock, const BIO_ADDR *addr, int options)
     if (bind(sock, BIO_ADDR_sockaddr(addr), BIO_ADDR_sockaddr_size(addr)) != 0) {
         ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                        &quot;calling bind()&quot;);
-        BIOerr(BIO_F_BIO_BIND, BIO_R_UNABLE_TO_BIND_SOCKET);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_BIND_SOCKET);
         return 0;
     }
 
@@ -228,7 +228,7 @@ int BIO_listen(int sock, const BIO_ADDR *addr, int options)
     socklen_t socktype_len = sizeof(socktype);
 
     if (sock == -1) {
-        BIOerr(BIO_F_BIO_LISTEN, BIO_R_INVALID_SOCKET);
+        ERR_raise(ERR_LIB_BIO, BIO_R_INVALID_SOCKET);
         return 0;
     }
 
@@ -237,7 +237,7 @@ int BIO_listen(int sock, const BIO_ADDR *addr, int options)
         || socktype_len != sizeof(socktype)) {
         ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                        &quot;calling getsockopt()&quot;);
-        BIOerr(BIO_F_BIO_LISTEN, BIO_R_GETTING_SOCKTYPE);
+        ERR_raise(ERR_LIB_BIO, BIO_R_GETTING_SOCKTYPE);
         return 0;
     }
 
@@ -249,7 +249,7 @@ int BIO_listen(int sock, const BIO_ADDR *addr, int options)
                        (const void *)&amp;on, sizeof(on)) != 0) {
             ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                            &quot;calling setsockopt()&quot;);
-            BIOerr(BIO_F_BIO_LISTEN, BIO_R_UNABLE_TO_KEEPALIVE);
+            ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_KEEPALIVE);
             return 0;
         }
     }
@@ -259,7 +259,7 @@ int BIO_listen(int sock, const BIO_ADDR *addr, int options)
                        (const void *)&amp;on, sizeof(on)) != 0) {
             ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                            &quot;calling setsockopt()&quot;);
-            BIOerr(BIO_F_BIO_LISTEN, BIO_R_UNABLE_TO_NODELAY);
+            ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_NODELAY);
             return 0;
         }
     }
@@ -275,7 +275,7 @@ int BIO_listen(int sock, const BIO_ADDR *addr, int options)
                        (const void *)&amp;on, sizeof(on)) != 0) {
             ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                            &quot;calling setsockopt()&quot;);
-            BIOerr(BIO_F_BIO_LISTEN, BIO_R_LISTEN_V6_ONLY);
+            ERR_raise(ERR_LIB_BIO, BIO_R_LISTEN_V6_ONLY);
             return 0;
         }
     }
@@ -287,7 +287,7 @@ int BIO_listen(int sock, const BIO_ADDR *addr, int options)
     if (socktype != SOCK_DGRAM &amp;&amp; listen(sock, MAX_LISTEN) == -1) {
         ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                        &quot;calling listen()&quot;);
-        BIOerr(BIO_F_BIO_LISTEN, BIO_R_UNABLE_TO_LISTEN_SOCKET);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_LISTEN_SOCKET);
         return 0;
     }
 
@@ -315,7 +315,7 @@ int BIO_accept_ex(int accept_sock, BIO_ADDR *addr_, int options)
         if (!BIO_sock_should_retry(accepted_sock)) {
             ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                            &quot;calling accept()&quot;);
-            BIOerr(BIO_F_BIO_ACCEPT_EX, BIO_R_ACCEPT_ERROR);
+            ERR_raise(ERR_LIB_BIO, BIO_R_ACCEPT_ERROR);
         }
         return INVALID_SOCKET;
     }
diff --git a/crypto/bio/bf_buff.c b/crypto/bio/bf_buff.c
index 10ee89f78f..46eff55447 100644
--- a/crypto/bio/bf_buff.c
+++ b/crypto/bio/bf_buff.c
@@ -404,7 +404,7 @@ static long buffer_ctrl(BIO *b, int cmd, long num, void *ptr)
     }
     return ret;
  malloc_error:
-    BIOerr(BIO_F_BUFFER_CTRL, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
diff --git a/crypto/bio/bf_lbuf.c b/crypto/bio/bf_lbuf.c
index 0f46c1e905..b1f8d68658 100644
--- a/crypto/bio/bf_lbuf.c
+++ b/crypto/bio/bf_lbuf.c
@@ -60,12 +60,12 @@ static int linebuffer_new(BIO *bi)
     BIO_LINEBUFFER_CTX *ctx;
 
     if ((ctx = OPENSSL_malloc(sizeof(*ctx))) == NULL) {
-        BIOerr(BIO_F_LINEBUFFER_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ctx-&gt;obuf = OPENSSL_malloc(DEFAULT_LINEBUFFER_SIZE);
     if (ctx-&gt;obuf == NULL) {
-        BIOerr(BIO_F_LINEBUFFER_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ctx);
         return 0;
     }
@@ -295,7 +295,7 @@ static long linebuffer_ctrl(BIO *b, int cmd, long num, void *ptr)
     }
     return ret;
  malloc_error:
-    BIOerr(BIO_F_LINEBUFFER_CTRL, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
diff --git a/crypto/bio/bf_nbio.c b/crypto/bio/bf_nbio.c
index ffb0ffe94a..f5b83a89f9 100644
--- a/crypto/bio/bf_nbio.c
+++ b/crypto/bio/bf_nbio.c
@@ -58,7 +58,7 @@ static int nbiof_new(BIO *bi)
     NBIO_TEST *nt;
 
     if ((nt = OPENSSL_zalloc(sizeof(*nt))) == NULL) {
-        BIOerr(BIO_F_NBIOF_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     nt-&gt;lrn = -1;
diff --git a/crypto/bio/bio_lib.c b/crypto/bio/bio_lib.c
index c3c798d4b4..940ab085d7 100644
--- a/crypto/bio/bio_lib.c
+++ b/crypto/bio/bio_lib.c
@@ -73,7 +73,7 @@ BIO *BIO_new(const BIO_METHOD *method)
     BIO *bio = OPENSSL_zalloc(sizeof(*bio));
 
     if (bio == NULL) {
-        BIOerr(BIO_F_BIO_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -86,13 +86,13 @@ BIO *BIO_new(const BIO_METHOD *method)
 
     bio-&gt;lock = CRYPTO_THREAD_lock_new();
     if (bio-&gt;lock == NULL) {
-        BIOerr(BIO_F_BIO_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &amp;bio-&gt;ex_data);
         goto err;
     }
 
     if (method-&gt;create != NULL &amp;&amp; !method-&gt;create(bio)) {
-        BIOerr(BIO_F_BIO_NEW, ERR_R_INIT_FAIL);
+        ERR_raise(ERR_LIB_BIO, ERR_R_INIT_FAIL);
         CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &amp;bio-&gt;ex_data);
         CRYPTO_THREAD_lock_free(bio-&gt;lock);
         goto err;
@@ -253,7 +253,7 @@ static int bio_read_intern(BIO *b, void *data, size_t dlen, size_t *readbytes)
     int ret;
 
     if ((b == NULL) || (b-&gt;method == NULL) || (b-&gt;method-&gt;bread == NULL)) {
-        BIOerr(BIO_F_BIO_READ_INTERN, BIO_R_UNSUPPORTED_METHOD);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNSUPPORTED_METHOD);
         return -2;
     }
 
@@ -263,7 +263,7 @@ static int bio_read_intern(BIO *b, void *data, size_t dlen, size_t *readbytes)
         return ret;
 
     if (!b-&gt;init) {
-        BIOerr(BIO_F_BIO_READ_INTERN, BIO_R_UNINITIALIZED);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNINITIALIZED);
         return -2;
     }
 
@@ -278,7 +278,7 @@ static int bio_read_intern(BIO *b, void *data, size_t dlen, size_t *readbytes)
 
     /* Shouldn't happen */
     if (ret &gt; 0 &amp;&amp; *readbytes &gt; dlen) {
-        BIOerr(BIO_F_BIO_READ_INTERN, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_BIO, ERR_R_INTERNAL_ERROR);
         return -1;
     }
 
@@ -326,7 +326,7 @@ static int bio_write_intern(BIO *b, const void *data, size_t dlen,
         return 0;
 
     if ((b-&gt;method == NULL) || (b-&gt;method-&gt;bwrite == NULL)) {
-        BIOerr(BIO_F_BIO_WRITE_INTERN, BIO_R_UNSUPPORTED_METHOD);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNSUPPORTED_METHOD);
         return -2;
     }
 
@@ -336,7 +336,7 @@ static int bio_write_intern(BIO *b, const void *data, size_t dlen,
         return ret;
 
     if (!b-&gt;init) {
-        BIOerr(BIO_F_BIO_WRITE_INTERN, BIO_R_UNINITIALIZED);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNINITIALIZED);
         return -2;
     }
 
@@ -390,7 +390,7 @@ int BIO_puts(BIO *b, const char *buf)
     size_t written = 0;
 
     if ((b == NULL) || (b-&gt;method == NULL) || (b-&gt;method-&gt;bputs == NULL)) {
-        BIOerr(BIO_F_BIO_PUTS, BIO_R_UNSUPPORTED_METHOD);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNSUPPORTED_METHOD);
         return -2;
     }
 
@@ -401,7 +401,7 @@ int BIO_puts(BIO *b, const char *buf)
     }
 
     if (!b-&gt;init) {
-        BIOerr(BIO_F_BIO_PUTS, BIO_R_UNINITIALIZED);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNINITIALIZED);
         return -2;
     }
 
@@ -419,7 +419,7 @@ int BIO_puts(BIO *b, const char *buf)
 
     if (ret &gt; 0) {
         if (written &gt; INT_MAX) {
-            BIOerr(BIO_F_BIO_PUTS, BIO_R_LENGTH_TOO_LONG);
+            ERR_raise(ERR_LIB_BIO, BIO_R_LENGTH_TOO_LONG);
             ret = -1;
         } else {
             ret = (int)written;
@@ -435,12 +435,12 @@ int BIO_gets(BIO *b, char *buf, int size)
     size_t readbytes = 0;
 
     if ((b == NULL) || (b-&gt;method == NULL) || (b-&gt;method-&gt;bgets == NULL)) {
-        BIOerr(BIO_F_BIO_GETS, BIO_R_UNSUPPORTED_METHOD);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNSUPPORTED_METHOD);
         return -2;
     }
 
     if (size &lt; 0) {
-        BIOerr(BIO_F_BIO_GETS, BIO_R_INVALID_ARGUMENT);
+        ERR_raise(ERR_LIB_BIO, BIO_R_INVALID_ARGUMENT);
         return 0;
     }
 
@@ -451,7 +451,7 @@ int BIO_gets(BIO *b, char *buf, int size)
     }
 
     if (!b-&gt;init) {
-        BIOerr(BIO_F_BIO_GETS, BIO_R_UNINITIALIZED);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNINITIALIZED);
         return -2;
     }
 
@@ -515,7 +515,7 @@ long BIO_ctrl(BIO *b, int cmd, long larg, void *parg)
         return 0;
 
     if ((b-&gt;method == NULL) || (b-&gt;method-&gt;ctrl == NULL)) {
-        BIOerr(BIO_F_BIO_CTRL, BIO_R_UNSUPPORTED_METHOD);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNSUPPORTED_METHOD);
         return -2;
     }
 
@@ -543,7 +543,7 @@ long BIO_callback_ctrl(BIO *b, int cmd, BIO_info_cb *fp)
 
     if ((b-&gt;method == NULL) || (b-&gt;method-&gt;callback_ctrl == NULL)
             || (cmd != BIO_CTRL_SET_CALLBACK)) {
-        BIOerr(BIO_F_BIO_CALLBACK_CTRL, BIO_R_UNSUPPORTED_METHOD);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNSUPPORTED_METHOD);
         return -2;
     }
 
@@ -831,7 +831,8 @@ int BIO_wait(BIO *bio, time_t max_time, unsigned int nap_milliseconds)
     int rv = bio_wait(bio, max_time, nap_milliseconds);
 
     if (rv &lt;= 0)
-        BIOerr(0, rv == 0 ? BIO_R_TRANSFER_TIMEOUT : BIO_R_TRANSFER_ERROR);
+        ERR_raise(ERR_LIB_BIO,
+                  rv == 0 ? BIO_R_TRANSFER_TIMEOUT : BIO_R_TRANSFER_ERROR);
     return rv;
 }
 
@@ -850,7 +851,7 @@ int BIO_do_connect_retry(BIO *bio, int timeout, int nap_milliseconds)
     int rv;
 
     if (bio == NULL) {
-        BIOerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_BIO, ERR_R_PASSED_NULL_PARAMETER);
         return -1;
     }
 
@@ -891,11 +892,12 @@ int BIO_do_connect_retry(BIO *bio, int timeout, int nap_milliseconds)
             rv = bio_wait(bio, max_time, nap_milliseconds);
             if (rv &gt; 0)
                 goto retry;
-            BIOerr(0, rv == 0 ? BIO_R_CONNECT_TIMEOUT : BIO_R_CONNECT_ERROR);
+            ERR_raise(ERR_LIB_BIO,
+                      rv == 0 ? BIO_R_CONNECT_TIMEOUT : BIO_R_CONNECT_ERROR);
         } else {
             rv = -1;
             if (err == 0) /* missing error queue entry */
-                BIOerr(0, BIO_R_CONNECT_ERROR); /* workaround: general error */
+                ERR_raise(ERR_LIB_BIO, BIO_R_CONNECT_ERROR); /* workaround: general error */
         }
     }
 
diff --git a/crypto/bio/bio_meth.c b/crypto/bio/bio_meth.c
index d32aeadf42..51a763d8d5 100644
--- a/crypto/bio/bio_meth.c
+++ b/crypto/bio/bio_meth.c
@@ -25,7 +25,7 @@ int BIO_get_new_index(void)
     int newval;
 
     if (!RUN_ONCE(&amp;bio_type_init, do_bio_type_init)) {
-        BIOerr(BIO_F_BIO_GET_NEW_INDEX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return -1;
     }
     if (!CRYPTO_UP_REF(&amp;bio_count, &amp;newval, bio_type_lock))
@@ -40,7 +40,7 @@ BIO_METHOD *BIO_meth_new(int type, const char *name)
     if (biom == NULL
             || (biom-&gt;name = OPENSSL_strdup(name)) == NULL) {
         OPENSSL_free(biom);
-        BIOerr(BIO_F_BIO_METH_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     biom-&gt;type = type;
diff --git a/crypto/bio/bss_acpt.c b/crypto/bio/bss_acpt.c
index 7f1af71e0f..5b776224d6 100644
--- a/crypto/bio/bss_acpt.c
+++ b/crypto/bio/bss_acpt.c
@@ -93,7 +93,7 @@ static BIO_ACCEPT *BIO_ACCEPT_new(void)
     BIO_ACCEPT *ret;
 
     if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {
-        BIOerr(BIO_F_BIO_ACCEPT_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;accept_family = BIO_FAMILY_IPANY;
@@ -156,10 +156,10 @@ static int acpt_state(BIO *b, BIO_ACCEPT *c)
         switch (c-&gt;state) {
         case ACPT_S_BEFORE:
             if (c-&gt;param_addr == NULL &amp;&amp; c-&gt;param_serv == NULL) {
-                BIOerr(BIO_F_ACPT_STATE, BIO_R_NO_ACCEPT_ADDR_OR_SERVICE_SPECIFIED);
-                ERR_add_error_data(4,
-                                   &quot;hostname=&quot;, c-&gt;param_addr,
-                                   &quot; service=&quot;, c-&gt;param_serv);
+                ERR_raise_data(ERR_LIB_BIO,
+                               BIO_R_NO_ACCEPT_ADDR_OR_SERVICE_SPECIFIED,
+                               &quot;hostname=%s, service=%s&quot;,
+                               c-&gt;param_addr, c-&gt;param_serv);
                 goto exit_loop;
             }
 
@@ -192,7 +192,7 @@ static int acpt_state(BIO *b, BIO_ACCEPT *c)
                         family = AF_INET6;
                     } else {
 #endif
-                        BIOerr(BIO_F_ACPT_STATE, BIO_R_UNAVAILABLE_IP_FAMILY);
+                        ERR_raise(ERR_LIB_BIO, BIO_R_UNAVAILABLE_IP_FAMILY);
                         goto exit_loop;
                     }
                     break;
@@ -203,7 +203,7 @@ static int acpt_state(BIO *b, BIO_ACCEPT *c)
                     family = AF_UNSPEC;
                     break;
                 default:
-                    BIOerr(BIO_F_ACPT_STATE, BIO_R_UNSUPPORTED_IP_FAMILY);
+                    ERR_raise(ERR_LIB_BIO, BIO_R_UNSUPPORTED_IP_FAMILY);
                     goto exit_loop;
                 }
                 if (BIO_lookup(c-&gt;param_addr, c-&gt;param_serv, BIO_LOOKUP_SERVER,
@@ -211,7 +211,7 @@ static int acpt_state(BIO *b, BIO_ACCEPT *c)
                     goto exit_loop;
             }
             if (c-&gt;addr_first == NULL) {
-                BIOerr(BIO_F_ACPT_STATE, BIO_R_LOOKUP_RETURNED_NOTHING);
+                ERR_raise(ERR_LIB_BIO, BIO_R_LOOKUP_RETURNED_NOTHING);
                 goto exit_loop;
             }
             /* We're currently not iterating, but set this as preparation
@@ -229,7 +229,7 @@ static int acpt_state(BIO *b, BIO_ACCEPT *c)
                 ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                                &quot;calling socket(%s, %s)&quot;,
                                 c-&gt;param_addr, c-&gt;param_serv);
-                BIOerr(BIO_F_ACPT_STATE, BIO_R_UNABLE_TO_CREATE_SOCKET);
+                ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_CREATE_SOCKET);
                 goto exit_loop;
             }
             c-&gt;accept_sock = s;
diff --git a/crypto/bio/bss_bio.c b/crypto/bio/bss_bio.c
index 268f010fe8..d7e5bed5fd 100644
--- a/crypto/bio/bss_bio.c
+++ b/crypto/bio/bss_bio.c
@@ -286,7 +286,7 @@ static int bio_write(BIO *bio, const char *buf, int num_)
     b-&gt;request = 0;
     if (b-&gt;closed) {
         /* we already closed */
-        BIOerr(BIO_F_BIO_WRITE, BIO_R_BROKEN_PIPE);
+        ERR_raise(ERR_LIB_BIO, BIO_R_BROKEN_PIPE);
         return -1;
     }
 
@@ -362,7 +362,7 @@ static ossl_ssize_t bio_nwrite0(BIO *bio, char **buf)
 
     b-&gt;request = 0;
     if (b-&gt;closed) {
-        BIOerr(BIO_F_BIO_NWRITE0, BIO_R_BROKEN_PIPE);
+        ERR_raise(ERR_LIB_BIO, BIO_R_BROKEN_PIPE);
         return -1;
     }
 
@@ -427,10 +427,10 @@ static long bio_ctrl(BIO *bio, int cmd, long num, void *ptr)
 
     case BIO_C_SET_WRITE_BUF_SIZE:
         if (b-&gt;peer) {
-            BIOerr(BIO_F_BIO_CTRL, BIO_R_IN_USE);
+            ERR_raise(ERR_LIB_BIO, BIO_R_IN_USE);
             ret = 0;
         } else if (num == 0) {
-            BIOerr(BIO_F_BIO_CTRL, BIO_R_INVALID_ARGUMENT);
+            ERR_raise(ERR_LIB_BIO, BIO_R_INVALID_ARGUMENT);
             ret = 0;
         } else {
             size_t new_size = num;
@@ -616,14 +616,14 @@ static int bio_make_pair(BIO *bio1, BIO *bio2)
     b2 = bio2-&gt;ptr;
 
     if (b1-&gt;peer != NULL || b2-&gt;peer != NULL) {
-        BIOerr(BIO_F_BIO_MAKE_PAIR, BIO_R_IN_USE);
+        ERR_raise(ERR_LIB_BIO, BIO_R_IN_USE);
         return 0;
     }
 
     if (b1-&gt;buf == NULL) {
         b1-&gt;buf = OPENSSL_malloc(b1-&gt;size);
         if (b1-&gt;buf == NULL) {
-            BIOerr(BIO_F_BIO_MAKE_PAIR, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         b1-&gt;len = 0;
@@ -633,7 +633,7 @@ static int bio_make_pair(BIO *bio1, BIO *bio2)
     if (b2-&gt;buf == NULL) {
         b2-&gt;buf = OPENSSL_malloc(b2-&gt;size);
         if (b2-&gt;buf == NULL) {
-            BIOerr(BIO_F_BIO_MAKE_PAIR, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         b2-&gt;len = 0;
@@ -750,7 +750,7 @@ int BIO_nread0(BIO *bio, char **buf)
     long ret;
 
     if (!bio-&gt;init) {
-        BIOerr(BIO_F_BIO_NREAD0, BIO_R_UNINITIALIZED);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNINITIALIZED);
         return -2;
     }
 
@@ -766,7 +766,7 @@ int BIO_nread(BIO *bio, char **buf, int num)
     int ret;
 
     if (!bio-&gt;init) {
-        BIOerr(BIO_F_BIO_NREAD, BIO_R_UNINITIALIZED);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNINITIALIZED);
         return -2;
     }
 
@@ -781,7 +781,7 @@ int BIO_nwrite0(BIO *bio, char **buf)
     long ret;
 
     if (!bio-&gt;init) {
-        BIOerr(BIO_F_BIO_NWRITE0, BIO_R_UNINITIALIZED);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNINITIALIZED);
         return -2;
     }
 
@@ -797,7 +797,7 @@ int BIO_nwrite(BIO *bio, char **buf, int num)
     int ret;
 
     if (!bio-&gt;init) {
-        BIOerr(BIO_F_BIO_NWRITE, BIO_R_UNINITIALIZED);
+        ERR_raise(ERR_LIB_BIO, BIO_R_UNINITIALIZED);
         return -2;
     }
 
diff --git a/crypto/bio/bss_conn.c b/crypto/bio/bss_conn.c
index e6972efd8d..c7bd0a329f 100644
--- a/crypto/bio/bss_conn.c
+++ b/crypto/bio/bss_conn.c
@@ -89,10 +89,10 @@ static int conn_state(BIO *b, BIO_CONNECT *c)
         switch (c-&gt;state) {
         case BIO_CONN_S_BEFORE:
             if (c-&gt;param_hostname == NULL &amp;&amp; c-&gt;param_service == NULL) {
-                BIOerr(BIO_F_CONN_STATE, BIO_R_NO_HOSTNAME_OR_SERVICE_SPECIFIED);
-                ERR_add_error_data(4,
-                                   &quot;hostname=&quot;, c-&gt;param_hostname,
-                                   &quot; service=&quot;, c-&gt;param_service);
+                ERR_raise_data(ERR_LIB_BIO,
+                               BIO_R_NO_HOSTNAME_OR_SERVICE_SPECIFIED,
+                               &quot;hostname=%s service=%s&quot;,
+                               c-&gt;param_hostname, c-&gt;param_service);
                 goto exit_loop;
             }
             c-&gt;state = BIO_CONN_S_GET_ADDR;
@@ -111,7 +111,7 @@ static int conn_state(BIO *b, BIO_CONNECT *c)
                         family = AF_INET6;
                     } else {
 #endif
-                        BIOerr(BIO_F_CONN_STATE, BIO_R_UNAVAILABLE_IP_FAMILY);
+                        ERR_raise(ERR_LIB_BIO, BIO_R_UNAVAILABLE_IP_FAMILY);
                         goto exit_loop;
                     }
                     break;
@@ -122,7 +122,7 @@ static int conn_state(BIO *b, BIO_CONNECT *c)
                     family = AF_UNSPEC;
                     break;
                 default:
-                    BIOerr(BIO_F_CONN_STATE, BIO_R_UNSUPPORTED_IP_FAMILY);
+                    ERR_raise(ERR_LIB_BIO, BIO_R_UNSUPPORTED_IP_FAMILY);
                     goto exit_loop;
                 }
                 if (BIO_lookup(c-&gt;param_hostname, c-&gt;param_service,
@@ -131,7 +131,7 @@ static int conn_state(BIO *b, BIO_CONNECT *c)
                     goto exit_loop;
             }
             if (c-&gt;addr_first == NULL) {
-                BIOerr(BIO_F_CONN_STATE, BIO_R_LOOKUP_RETURNED_NOTHING);
+                ERR_raise(ERR_LIB_BIO, BIO_R_LOOKUP_RETURNED_NOTHING);
                 goto exit_loop;
             }
             c-&gt;addr_iter = c-&gt;addr_first;
@@ -146,7 +146,7 @@ static int conn_state(BIO *b, BIO_CONNECT *c)
                 ERR_raise_data(ERR_LIB_SYS, get_last_socket_error(),
                                &quot;calling socket(%s, %s)&quot;,
                                c-&gt;param_hostname, c-&gt;param_service);
-                BIOerr(BIO_F_CONN_STATE, BIO_R_UNABLE_TO_CREATE_SOCKET);
+                ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_CREATE_SOCKET);
                 goto exit_loop;
             }
             b-&gt;num = ret;
@@ -202,7 +202,7 @@ static int conn_state(BIO *b, BIO_CONNECT *c)
                 ERR_raise_data(ERR_LIB_SYS, i,
                                &quot;calling connect(%s, %s)&quot;,
                                 c-&gt;param_hostname, c-&gt;param_service);
-                BIOerr(BIO_F_CONN_STATE, BIO_R_NBIO_CONNECT_ERROR);
+                ERR_raise(ERR_LIB_BIO, BIO_R_NBIO_CONNECT_ERROR);
                 ret = 0;
                 goto exit_loop;
             } else
@@ -210,7 +210,7 @@ static int conn_state(BIO *b, BIO_CONNECT *c)
             break;
 
         case BIO_CONN_S_CONNECT_ERROR:
-            BIOerr(BIO_F_CONN_STATE, BIO_R_CONNECT_ERROR);
+            ERR_raise(ERR_LIB_BIO, BIO_R_CONNECT_ERROR);
             ret = 0;
             goto exit_loop;
 
@@ -241,7 +241,7 @@ BIO_CONNECT *BIO_CONNECT_new(void)
     BIO_CONNECT *ret;
 
     if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {
-        BIOerr(BIO_F_BIO_CONNECT_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;state = BIO_CONN_S_BEFORE;
diff --git a/crypto/bio/bss_dgram.c b/crypto/bio/bss_dgram.c
index fc17c9ed4d..45981ab27b 100644
--- a/crypto/bio/bss_dgram.c
+++ b/crypto/bio/bss_dgram.c
@@ -843,8 +843,8 @@ BIO *BIO_new_dgram_sctp(int fd, int close_flag)
                    sizeof(struct sctp_authchunk));
     if (ret &lt; 0) {
         BIO_vfree(bio);
-        BIOerr(BIO_F_BIO_NEW_DGRAM_SCTP, ERR_R_SYS_LIB);
-        ERR_add_error_data(1, &quot;Ensure SCTP AUTH chunks are enabled in kernel&quot;);
+        ERR_raise_data(ERR_LIB_BIO, ERR_R_SYS_LIB,
+                       &quot;Ensure SCTP AUTH chunks are enabled in kernel&quot;);
         return NULL;
     }
     auth.sauth_chunk = OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE;
@@ -853,8 +853,8 @@ BIO *BIO_new_dgram_sctp(int fd, int close_flag)
                    sizeof(struct sctp_authchunk));
     if (ret &lt; 0) {
         BIO_vfree(bio);
-        BIOerr(BIO_F_BIO_NEW_DGRAM_SCTP, ERR_R_SYS_LIB);
-        ERR_add_error_data(1, &quot;Ensure SCTP AUTH chunks are enabled in kernel&quot;);
+        ERR_raise_data(ERR_LIB_BIO, ERR_R_SYS_LIB,
+                       &quot;Ensure SCTP AUTH chunks are enabled in kernel&quot;);
         return NULL;
     }
 
@@ -891,10 +891,9 @@ BIO *BIO_new_dgram_sctp(int fd, int close_flag)
 
     if (!auth_data || !auth_forward) {
         BIO_vfree(bio);
-        BIOerr(BIO_F_BIO_NEW_DGRAM_SCTP, ERR_R_SYS_LIB);
-        ERR_add_error_data(1,
-                           &quot;Ensure SCTP AUTH chunks are enabled on the &quot;
-                           &quot;underlying socket&quot;);
+        ERR_raise_data(ERR_LIB_BIO, ERR_R_SYS_LIB,
+                       &quot;Ensure SCTP AUTH chunks are enabled on the &quot;
+                       &quot;underlying socket&quot;);
         return NULL;
     }
 
@@ -958,7 +957,7 @@ static int dgram_sctp_new(BIO *bi)
     bi-&gt;init = 0;
     bi-&gt;num = 0;
     if ((data = OPENSSL_zalloc(sizeof(*data))) == NULL) {
-        BIOerr(BIO_F_DGRAM_SCTP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 #  ifdef SCTP_PR_SCTP_NONE
@@ -1196,7 +1195,7 @@ static int dgram_sctp_read(BIO *b, char *out, int outl)
                 (socklen_t) (sizeof(sctp_assoc_t) + 256 * sizeof(uint8_t));
             authchunks = OPENSSL_malloc(optlen);
             if (authchunks == NULL) {
-                BIOerr(BIO_F_DGRAM_SCTP_READ, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
                 return -1;
             }
             memset(authchunks, 0, optlen);
@@ -1216,7 +1215,7 @@ static int dgram_sctp_read(BIO *b, char *out, int outl)
             OPENSSL_free(authchunks);
 
             if (!auth_data || !auth_forward) {
-                BIOerr(BIO_F_DGRAM_SCTP_READ, BIO_R_CONNECT_ERROR);
+                ERR_raise(ERR_LIB_BIO, BIO_R_CONNECT_ERROR);
                 return -1;
             }
 
diff --git a/crypto/bio/bss_file.c b/crypto/bio/bss_file.c
index fa21a814b4..981a5e7b59 100644
--- a/crypto/bio/bss_file.c
+++ b/crypto/bio/bss_file.c
@@ -74,9 +74,9 @@ BIO *BIO_new_file(const char *filename, const char *mode)
             || errno == ENXIO
 #endif
             )
-            BIOerr(BIO_F_BIO_NEW_FILE, BIO_R_NO_SUCH_FILE);
+            ERR_raise(ERR_LIB_BIO, BIO_R_NO_SUCH_FILE);
         else
-            BIOerr(BIO_F_BIO_NEW_FILE, ERR_R_SYS_LIB);
+            ERR_raise(ERR_LIB_BIO, ERR_R_SYS_LIB);
         return NULL;
     }
     if ((ret = BIO_new(BIO_s_file())) == NULL) {
@@ -149,7 +149,7 @@ static int file_read(BIO *b, char *out, int outl)
                 ? UP_ferror((FILE *)b-&gt;ptr) : ferror((FILE *)b-&gt;ptr))) {
             ERR_raise_data(ERR_LIB_SYS, get_last_sys_error(),
                            &quot;calling fread()&quot;);
-            BIOerr(BIO_F_FILE_READ, ERR_R_SYS_LIB);
+            ERR_raise(ERR_LIB_BIO, ERR_R_SYS_LIB);
             ret = -1;
         }
     }
@@ -281,7 +281,7 @@ static long file_ctrl(BIO *b, int cmd, long num, void *ptr)
         else if (num &amp; BIO_FP_READ)
             OPENSSL_strlcpy(p, &quot;r&quot;, sizeof(p));
         else {
-            BIOerr(BIO_F_FILE_CTRL, BIO_R_BAD_FOPEN_MODE);
+            ERR_raise(ERR_LIB_BIO, BIO_R_BAD_FOPEN_MODE);
             ret = 0;
             break;
         }
@@ -299,7 +299,7 @@ static long file_ctrl(BIO *b, int cmd, long num, void *ptr)
             ERR_raise_data(ERR_LIB_SYS, get_last_sys_error(),
                            &quot;calling fopen(%s, %s)&quot;,
                            ptr, p);
-            BIOerr(BIO_F_FILE_CTRL, ERR_R_SYS_LIB);
+            ERR_raise(ERR_LIB_BIO, ERR_R_SYS_LIB);
             ret = 0;
             break;
         }
@@ -327,7 +327,7 @@ static long file_ctrl(BIO *b, int cmd, long num, void *ptr)
         if (st == EOF) {
             ERR_raise_data(ERR_LIB_SYS, get_last_sys_error(),
                            &quot;calling fflush()&quot;);
-            BIOerr(BIO_F_FILE_CTRL, ERR_R_SYS_LIB);
+            ERR_raise(ERR_LIB_BIO, ERR_R_SYS_LIB);
             ret = 0;
         }
         break;
diff --git a/crypto/bio/bss_log.c b/crypto/bio/bss_log.c
index 274e52317d..73b5d2f3dc 100644
--- a/crypto/bio/bss_log.c
+++ b/crypto/bio/bss_log.c
@@ -197,7 +197,7 @@ static int slg_write(BIO *b, const char *in, int inl)
     };
 
     if ((buf = OPENSSL_malloc(inl + 1)) == NULL) {
-        BIOerr(BIO_F_SLG_WRITE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BIO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     memcpy(buf, in, inl);
diff --git a/crypto/bio/bss_mem.c b/crypto/bio/bss_mem.c
index 57b7a7449e..656c44b7af 100644
--- a/crypto/bio/bss_mem.c
+++ b/crypto/bio/bss_mem.c
@@ -91,7 +91,7 @@ BIO *BIO_new_mem_buf(const void *buf, int len)
     size_t sz;
 
     if (buf == NULL) {
-        BIOerr(BIO_F_BIO_NEW_MEM_BUF, BIO_R_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_BIO, BIO_R_NULL_PARAMETER);
         return NULL;
     }
     sz = (len &lt; 0) ? strlen(buf) : (size_t)len;
@@ -222,11 +222,11 @@ static int mem_write(BIO *b, const char *in, int inl)
     BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)b-&gt;ptr;
 
     if (in == NULL) {
-        BIOerr(BIO_F_MEM_WRITE, BIO_R_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_BIO, BIO_R_NULL_PARAMETER);
         goto end;
     }
     if (b-&gt;flags &amp; BIO_FLAGS_MEM_RDONLY) {
-        BIOerr(BIO_F_MEM_WRITE, BIO_R_WRITE_TO_READ_ONLY_BIO);
+        ERR_raise(ERR_LIB_BIO, BIO_R_WRITE_TO_READ_ONLY_BIO);
         goto end;
     }
     BIO_clear_retry_flags(b);
diff --git a/crypto/bn/bn_add.c b/crypto/bn/bn_add.c
index 545e1038ba..c148f576d5 100644
--- a/crypto/bn/bn_add.c
+++ b/crypto/bn/bn_add.c
@@ -136,7 +136,7 @@ int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
     dif = max - min;
 
     if (dif &lt; 0) {              /* hmm... should not be happening */
-        BNerr(BN_F_BN_USUB, BN_R_ARG2_LT_ARG3);
+        ERR_raise(ERR_LIB_BN, BN_R_ARG2_LT_ARG3);
         return 0;
     }
 
diff --git a/crypto/bn/bn_blind.c b/crypto/bn/bn_blind.c
index c078d8dce7..20b6d482c1 100644
--- a/crypto/bn/bn_blind.c
+++ b/crypto/bn/bn_blind.c
@@ -34,13 +34,13 @@ BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod)
     bn_check_top(mod);
 
     if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {
-        BNerr(BN_F_BN_BLINDING_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        BNerr(BN_F_BN_BLINDING_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -95,7 +95,7 @@ int BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx)
     int ret = 0;
 
     if ((b-&gt;A == NULL) || (b-&gt;Ai == NULL)) {
-        BNerr(BN_F_BN_BLINDING_UPDATE, BN_R_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_BN, BN_R_NOT_INITIALIZED);
         goto err;
     }
 
@@ -138,7 +138,7 @@ int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *ctx)
     bn_check_top(n);
 
     if ((b-&gt;A == NULL) || (b-&gt;Ai == NULL)) {
-        BNerr(BN_F_BN_BLINDING_CONVERT_EX, BN_R_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_BN, BN_R_NOT_INITIALIZED);
         return 0;
     }
 
@@ -172,7 +172,7 @@ int BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b,
     bn_check_top(n);
 
     if (r == NULL &amp;&amp; (r = b-&gt;Ai) == NULL) {
-        BNerr(BN_F_BN_BLINDING_INVERT_EX, BN_R_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_BN, BN_R_NOT_INITIALIZED);
         return 0;
     }
 
@@ -282,7 +282,7 @@ BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,
             goto err;
 
         if (retry_counter-- == 0) {
-            BNerr(BN_F_BN_BLINDING_CREATE_PARAM, BN_R_TOO_MANY_ITERATIONS);
+            ERR_raise(ERR_LIB_BN, BN_R_TOO_MANY_ITERATIONS);
             goto err;
         }
     } while (1);
diff --git a/crypto/bn/bn_conv.c b/crypto/bn/bn_conv.c
index 15f94079c7..4af546a25b 100644
--- a/crypto/bn/bn_conv.c
+++ b/crypto/bn/bn_conv.c
@@ -24,7 +24,7 @@ char *BN_bn2hex(const BIGNUM *a)
         return OPENSSL_strdup(&quot;0&quot;);
     buf = OPENSSL_malloc(a-&gt;top * BN_BYTES * 2 + 2);
     if (buf == NULL) {
-        BNerr(BN_F_BN_BN2HEX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     p = buf;
@@ -71,7 +71,7 @@ char *BN_bn2dec(const BIGNUM *a)
     bn_data = OPENSSL_malloc(bn_data_num * sizeof(BN_ULONG));
     buf = OPENSSL_malloc(tbytes);
     if (buf == NULL || bn_data == NULL) {
-        BNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if ((t = BN_dup(a)) == NULL)
diff --git a/crypto/bn/bn_ctx.c b/crypto/bn/bn_ctx.c
index 05b266b090..6234c51435 100644
--- a/crypto/bn/bn_ctx.c
+++ b/crypto/bn/bn_ctx.c
@@ -133,7 +133,7 @@ BN_CTX *BN_CTX_new_ex(OSSL_LIB_CTX *ctx)
     BN_CTX *ret;
 
     if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {
-        BNerr(BN_F_BN_CTX_NEW_EX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     /* Initialise the structure */
@@ -199,7 +199,7 @@ void BN_CTX_start(BN_CTX *ctx)
         ctx-&gt;err_stack++;
     /* (Try to) get a new frame pointer */
     else if (!BN_STACK_push(&amp;ctx-&gt;stack, ctx-&gt;used)) {
-        BNerr(BN_F_BN_CTX_START, BN_R_TOO_MANY_TEMPORARY_VARIABLES);
+        ERR_raise(ERR_LIB_BN, BN_R_TOO_MANY_TEMPORARY_VARIABLES);
         ctx-&gt;err_stack++;
     }
     CTXDBG(&quot;LEAVE BN_CTX_start()&quot;, ctx);
@@ -237,7 +237,7 @@ BIGNUM *BN_CTX_get(BN_CTX *ctx)
          * the error stack.
          */
         ctx-&gt;too_many = 1;
-        BNerr(BN_F_BN_CTX_GET, BN_R_TOO_MANY_TEMPORARY_VARIABLES);
+        ERR_raise(ERR_LIB_BN, BN_R_TOO_MANY_TEMPORARY_VARIABLES);
         return NULL;
     }
     /* OK, make sure the returned bignum is &quot;zero&quot; */
@@ -282,7 +282,7 @@ static int BN_STACK_push(BN_STACK *st, unsigned int idx)
         unsigned int *newitems;
 
         if ((newitems = OPENSSL_malloc(sizeof(*newitems) * newsize)) == NULL) {
-            BNerr(BN_F_BN_STACK_PUSH, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         if (st-&gt;depth)
@@ -336,7 +336,7 @@ static BIGNUM *BN_POOL_get(BN_POOL *p, int flag)
         BN_POOL_ITEM *item;
 
         if ((item = OPENSSL_malloc(sizeof(*item))) == NULL) {
-            BNerr(BN_F_BN_POOL_GET, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
         for (loop = 0, bn = item-&gt;vals; loop++ &lt; BN_CTX_POOL_SIZE; bn++) {
diff --git a/crypto/bn/bn_div.c b/crypto/bn/bn_div.c
index 42459706a3..2f96e7fdc2 100644
--- a/crypto/bn/bn_div.c
+++ b/crypto/bn/bn_div.c
@@ -24,7 +24,7 @@ int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d,
     bn_check_top(m);
     bn_check_top(d);
     if (BN_is_zero(d)) {
-        BNerr(BN_F_BN_DIV, BN_R_DIV_BY_ZERO);
+        ERR_raise(ERR_LIB_BN, BN_R_DIV_BY_ZERO);
         return 0;
     }
 
@@ -212,7 +212,7 @@ int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
     int ret;
 
     if (BN_is_zero(divisor)) {
-        BNerr(BN_F_BN_DIV, BN_R_DIV_BY_ZERO);
+        ERR_raise(ERR_LIB_BN, BN_R_DIV_BY_ZERO);
         return 0;
     }
 
@@ -222,7 +222,7 @@ int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
      * BN_DEBUG builds)
      */
     if (divisor-&gt;d[divisor-&gt;top - 1] == 0) {
-        BNerr(BN_F_BN_DIV, BN_R_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_BN, BN_R_NOT_INITIALIZED);
         return 0;
     }
 
diff --git a/crypto/bn/bn_exp.c b/crypto/bn/bn_exp.c
index 50190b058f..300257d543 100644
--- a/crypto/bn/bn_exp.c
+++ b/crypto/bn/bn_exp.c
@@ -46,7 +46,7 @@ int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
     if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
             || BN_get_flags(a, BN_FLG_CONSTTIME) != 0) {
         /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
-        BNerr(BN_F_BN_EXP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_BN, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
 
@@ -172,7 +172,7 @@ int BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
             || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
             || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
         /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
-        BNerr(BN_F_BN_MOD_EXP_RECP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_BN, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
 
@@ -315,7 +315,7 @@ int BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
     bn_check_top(m);
 
     if (!BN_is_odd(m)) {
-        BNerr(BN_F_BN_MOD_EXP_MONT, BN_R_CALLED_WITH_EVEN_MODULUS);
+        ERR_raise(ERR_LIB_BN, BN_R_CALLED_WITH_EVEN_MODULUS);
         return 0;
     }
     bits = BN_num_bits(p);
@@ -611,7 +611,7 @@ int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
     bn_check_top(m);
 
     if (!BN_is_odd(m)) {
-        BNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);
+        ERR_raise(ERR_LIB_BN, BN_R_CALLED_WITH_EVEN_MODULUS);
         return 0;
     }
 
@@ -1155,7 +1155,7 @@ int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,
     if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0
             || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
         /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
-        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_BN, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
 
@@ -1163,7 +1163,7 @@ int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,
     bn_check_top(m);
 
     if (!BN_is_odd(m)) {
-        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);
+        ERR_raise(ERR_LIB_BN, BN_R_CALLED_WITH_EVEN_MODULUS);
         return 0;
     }
     if (m-&gt;top == 1)
@@ -1287,7 +1287,7 @@ int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
             || BN_get_flags(a, BN_FLG_CONSTTIME) != 0
             || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {
         /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */
-        BNerr(BN_F_BN_MOD_EXP_SIMPLE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_BN, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
 
diff --git a/crypto/bn/bn_exp2.c b/crypto/bn/bn_exp2.c
index 99f843b98c..2e361abced 100644
--- a/crypto/bn/bn_exp2.c
+++ b/crypto/bn/bn_exp2.c
@@ -33,7 +33,7 @@ int BN_mod_exp2_mont(BIGNUM *rr, const BIGNUM *a1, const BIGNUM *p1,
     bn_check_top(m);
 
     if (!(m-&gt;d[0] &amp; 1)) {
-        BNerr(BN_F_BN_MOD_EXP2_MONT, BN_R_CALLED_WITH_EVEN_MODULUS);
+        ERR_raise(ERR_LIB_BN, BN_R_CALLED_WITH_EVEN_MODULUS);
         return 0;
     }
     bits1 = BN_num_bits(p1);
diff --git a/crypto/bn/bn_gcd.c b/crypto/bn/bn_gcd.c
index 78231904e1..6d709811ac 100644
--- a/crypto/bn/bn_gcd.c
+++ b/crypto/bn/bn_gcd.c
@@ -520,14 +520,14 @@ BIGNUM *BN_mod_inverse(BIGNUM *in,
     if (ctx == NULL) {
         ctx = new_ctx = BN_CTX_new_ex(NULL);
         if (ctx == NULL) {
-            BNerr(BN_F_BN_MOD_INVERSE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     }
 
     rv = int_bn_mod_inverse(in, a, n, ctx, &amp;noinv);
     if (noinv)
-        BNerr(BN_F_BN_MOD_INVERSE, BN_R_NO_INVERSE);
+        ERR_raise(ERR_LIB_BN, BN_R_NO_INVERSE);
     BN_CTX_free(new_ctx);
     return rv;
 }
diff --git a/crypto/bn/bn_gf2m.c b/crypto/bn/bn_gf2m.c
index 7a56745fe2..0a7d0d0ccf 100644
--- a/crypto/bn/bn_gf2m.c
+++ b/crypto/bn/bn_gf2m.c
@@ -395,7 +395,7 @@ int BN_GF2m_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *p)
     bn_check_top(p);
     ret = BN_GF2m_poly2arr(p, arr, OSSL_NELEM(arr));
     if (!ret || ret &gt; (int)OSSL_NELEM(arr)) {
-        BNerr(BN_F_BN_GF2M_MOD, BN_R_INVALID_LENGTH);
+        ERR_raise(ERR_LIB_BN, BN_R_INVALID_LENGTH);
         return 0;
     }
     ret = BN_GF2m_mod_arr(r, a, arr);
@@ -475,7 +475,7 @@ int BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
         goto err;
     ret = BN_GF2m_poly2arr(p, arr, max);
     if (!ret || ret &gt; max) {
-        BNerr(BN_F_BN_GF2M_MOD_MUL, BN_R_INVALID_LENGTH);
+        ERR_raise(ERR_LIB_BN, BN_R_INVALID_LENGTH);
         goto err;
     }
     ret = BN_GF2m_mod_mul_arr(r, a, b, arr, ctx);
@@ -533,7 +533,7 @@ int BN_GF2m_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
         goto err;
     ret = BN_GF2m_poly2arr(p, arr, max);
     if (!ret || ret &gt; max) {
-        BNerr(BN_F_BN_GF2M_MOD_SQR, BN_R_INVALID_LENGTH);
+        ERR_raise(ERR_LIB_BN, BN_R_INVALID_LENGTH);
         goto err;
     }
     ret = BN_GF2m_mod_sqr_arr(r, a, arr, ctx);
@@ -907,7 +907,7 @@ int BN_GF2m_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
         goto err;
     ret = BN_GF2m_poly2arr(p, arr, max);
     if (!ret || ret &gt; max) {
-        BNerr(BN_F_BN_GF2M_MOD_EXP, BN_R_INVALID_LENGTH);
+        ERR_raise(ERR_LIB_BN, BN_R_INVALID_LENGTH);
         goto err;
     }
     ret = BN_GF2m_mod_exp_arr(r, a, b, arr, ctx);
@@ -966,7 +966,7 @@ int BN_GF2m_mod_sqrt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
         goto err;
     ret = BN_GF2m_poly2arr(p, arr, max);
     if (!ret || ret &gt; max) {
-        BNerr(BN_F_BN_GF2M_MOD_SQRT, BN_R_INVALID_LENGTH);
+        ERR_raise(ERR_LIB_BN, BN_R_INVALID_LENGTH);
         goto err;
     }
     ret = BN_GF2m_mod_sqrt_arr(r, a, arr, ctx);
@@ -1054,7 +1054,7 @@ int BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a_, const int p[],
             count++;
         } while (BN_is_zero(w) &amp;&amp; (count &lt; MAX_ITERATIONS));
         if (BN_is_zero(w)) {
-            BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR, BN_R_TOO_MANY_ITERATIONS);
+            ERR_raise(ERR_LIB_BN, BN_R_TOO_MANY_ITERATIONS);
             goto err;
         }
     }
@@ -1064,7 +1064,7 @@ int BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a_, const int p[],
     if (!BN_GF2m_add(w, z, w))
         goto err;
     if (BN_GF2m_cmp(w, a)) {
-        BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR, BN_R_NO_SOLUTION);
+        ERR_raise(ERR_LIB_BN, BN_R_NO_SOLUTION);
         goto err;
     }
 
@@ -1097,7 +1097,7 @@ int BN_GF2m_mod_solve_quad(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
         goto err;
     ret = BN_GF2m_poly2arr(p, arr, max);
     if (!ret || ret &gt; max) {
-        BNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD, BN_R_INVALID_LENGTH);
+        ERR_raise(ERR_LIB_BN, BN_R_INVALID_LENGTH);
         goto err;
     }
     ret = BN_GF2m_mod_solve_quad_arr(r, a, arr, ctx);
diff --git a/crypto/bn/bn_intern.c b/crypto/bn/bn_intern.c
index d92403608b..614ad5c9cd 100644
--- a/crypto/bn/bn_intern.c
+++ b/crypto/bn/bn_intern.c
@@ -30,7 +30,7 @@ signed char *bn_compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)
     if (BN_is_zero(scalar)) {
         r = OPENSSL_malloc(1);
         if (r == NULL) {
-            BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         r[0] = 0;
@@ -40,7 +40,7 @@ signed char *bn_compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)
 
     if (w &lt;= 0 || w &gt; 7) {      /* 'signed char' can represent integers with
                                  * absolute values less than 2^7 */
-        BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_BN, ERR_R_INTERNAL_ERROR);
         goto err;
     }
     bit = 1 &lt;&lt; w;               /* at most 128 */
@@ -52,7 +52,7 @@ signed char *bn_compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)
     }
 
     if (scalar-&gt;d == NULL || scalar-&gt;top == 0) {
-        BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_BN, ERR_R_INTERNAL_ERROR);
         goto err;
     }
 
@@ -63,7 +63,7 @@ signed char *bn_compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)
                                   * BN_num_bits(scalar) + 1)
                                   */
     if (r == NULL) {
-        BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     window_val = scalar-&gt;d[0] &amp; mask;
@@ -98,7 +98,7 @@ signed char *bn_compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)
             }
 
             if (digit &lt;= -bit || digit &gt;= bit || !(digit &amp; 1)) {
-                BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_BN, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
 
@@ -110,7 +110,7 @@ signed char *bn_compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)
              */
             if (window_val != 0 &amp;&amp; window_val != next_bit
                 &amp;&amp; window_val != bit) {
-                BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_BN, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
         }
@@ -121,13 +121,13 @@ signed char *bn_compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)
         window_val += bit * BN_is_bit_set(scalar, j + w);
 
         if (window_val &gt; next_bit) {
-            BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_BN, ERR_R_INTERNAL_ERROR);
             goto err;
         }
     }
 
     if (j &gt; len + 1) {
-        BNerr(BN_F_BN_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_BN, ERR_R_INTERNAL_ERROR);
         goto err;
     }
     *ret_len = j;
@@ -188,7 +188,7 @@ void bn_set_static_words(BIGNUM *a, const BN_ULONG *words, int size)
 int bn_set_words(BIGNUM *a, const BN_ULONG *words, int num_words)
 {
     if (bn_wexpand(a, num_words) == NULL) {
-        BNerr(BN_F_BN_SET_WORDS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/bn/bn_lib.c b/crypto/bn/bn_lib.c
index 13a52ccb29..28a3e91679 100644
--- a/crypto/bn/bn_lib.c
+++ b/crypto/bn/bn_lib.c
@@ -245,7 +245,7 @@ BIGNUM *BN_new(void)
     BIGNUM *ret;
 
     if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {
-        BNerr(BN_F_BN_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;flags = BN_FLG_MALLOCED;
@@ -268,11 +268,11 @@ static BN_ULONG *bn_expand_internal(const BIGNUM *b, int words)
     BN_ULONG *a = NULL;
 
     if (words &gt; (INT_MAX / (4 * BN_BITS2))) {
-        BNerr(BN_F_BN_EXPAND_INTERNAL, BN_R_BIGNUM_TOO_LONG);
+        ERR_raise(ERR_LIB_BN, BN_R_BIGNUM_TOO_LONG);
         return NULL;
     }
     if (BN_get_flags(b, BN_FLG_STATIC_DATA)) {
-        BNerr(BN_F_BN_EXPAND_INTERNAL, BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
+        ERR_raise(ERR_LIB_BN, BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);
         return NULL;
     }
     if (BN_get_flags(b, BN_FLG_SECURE))
@@ -280,7 +280,7 @@ static BN_ULONG *bn_expand_internal(const BIGNUM *b, int words)
     else
         a = OPENSSL_zalloc(words * sizeof(*a));
     if (a == NULL) {
-        BNerr(BN_F_BN_EXPAND_INTERNAL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -966,7 +966,7 @@ BN_GENCB *BN_GENCB_new(void)
     BN_GENCB *ret;
 
     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) {
-        BNerr(BN_F_BN_GENCB_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/bn/bn_mod.c b/crypto/bn/bn_mod.c
index 18933d0ebe..d3e84fd99d 100644
--- a/crypto/bn/bn_mod.c
+++ b/crypto/bn/bn_mod.c
@@ -291,7 +291,7 @@ int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m)
         /* max_shift &gt;= 0 */
 
         if (max_shift &lt; 0) {
-            BNerr(BN_F_BN_MOD_LSHIFT_QUICK, BN_R_INPUT_NOT_REDUCED);
+            ERR_raise(ERR_LIB_BN, BN_R_INPUT_NOT_REDUCED);
             return 0;
         }
 
diff --git a/crypto/bn/bn_mont.c b/crypto/bn/bn_mont.c
index 6294a4f86a..934c55850a 100644
--- a/crypto/bn/bn_mont.c
+++ b/crypto/bn/bn_mont.c
@@ -230,7 +230,7 @@ BN_MONT_CTX *BN_MONT_CTX_new(void)
     BN_MONT_CTX *ret;
 
     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) {
-        BNerr(BN_F_BN_MONT_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/bn/bn_mpi.c b/crypto/bn/bn_mpi.c
index b8e92e1263..4eba0ae570 100644
--- a/crypto/bn/bn_mpi.c
+++ b/crypto/bn/bn_mpi.c
@@ -46,13 +46,13 @@ BIGNUM *BN_mpi2bn(const unsigned char *d, int n, BIGNUM *ain)
     BIGNUM *a = NULL;
 
     if (n &lt; 4 || (d[0] &amp; 0x80) != 0) {
-        BNerr(BN_F_BN_MPI2BN, BN_R_INVALID_LENGTH);
+        ERR_raise(ERR_LIB_BN, BN_R_INVALID_LENGTH);
         return NULL;
     }
     len = ((long)d[0] &lt;&lt; 24) | ((long)d[1] &lt;&lt; 16) | ((int)d[2] &lt;&lt; 8) | (int)
         d[3];
     if ((len + 4) != n) {
-        BNerr(BN_F_BN_MPI2BN, BN_R_ENCODING_ERROR);
+        ERR_raise(ERR_LIB_BN, BN_R_ENCODING_ERROR);
         return NULL;
     }
 
diff --git a/crypto/bn/bn_prime.c b/crypto/bn/bn_prime.c
index 579a386fbf..a344d7df02 100644
--- a/crypto/bn/bn_prime.c
+++ b/crypto/bn/bn_prime.c
@@ -132,7 +132,7 @@ int BN_generate_prime_ex2(BIGNUM *ret, int bits, int safe,
 
     if (bits &lt; 2) {
         /* There are no prime numbers this small. */
-        BNerr(BN_F_BN_GENERATE_PRIME_EX2, BN_R_BITS_TOO_SMALL);
+        ERR_raise(ERR_LIB_BN, BN_R_BITS_TOO_SMALL);
         return 0;
     } else if (add == NULL &amp;&amp; safe &amp;&amp; bits &lt; 6 &amp;&amp; bits != 3) {
         /*
@@ -140,7 +140,7 @@ int BN_generate_prime_ex2(BIGNUM *ret, int bits, int safe,
          * But the following two safe primes with less than 6 bits (11, 23)
          * are unreachable for BN_rand with BN_RAND_TOP_TWO.
          */
-        BNerr(BN_F_BN_GENERATE_PRIME_EX2, BN_R_BITS_TOO_SMALL);
+        ERR_raise(ERR_LIB_BN, BN_R_BITS_TOO_SMALL);
         return 0;
     }
 
diff --git a/crypto/bn/bn_rand.c b/crypto/bn/bn_rand.c
index cf0d802679..c6dd6e8814 100644
--- a/crypto/bn/bn_rand.c
+++ b/crypto/bn/bn_rand.c
@@ -42,7 +42,7 @@ static int bnrand(BNRAND_FLAG flag, BIGNUM *rnd, int bits, int top, int bottom,
 
     buf = OPENSSL_malloc(bytes);
     if (buf == NULL) {
-        BNerr(BN_F_BNRAND, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -95,7 +95,7 @@ static int bnrand(BNRAND_FLAG flag, BIGNUM *rnd, int bits, int top, int bottom,
     return ret;
 
 toosmall:
-    BNerr(BN_F_BNRAND, BN_R_BITS_TOO_SMALL);
+    ERR_raise(ERR_LIB_BN, BN_R_BITS_TOO_SMALL);
     return 0;
 }
 
@@ -135,7 +135,7 @@ static int bnrand_range(BNRAND_FLAG flag, BIGNUM *r, const BIGNUM *range,
     int count = 100;
 
     if (range-&gt;neg || BN_is_zero(range)) {
-        BNerr(BN_F_BNRAND_RANGE, BN_R_INVALID_RANGE);
+        ERR_raise(ERR_LIB_BN, BN_R_INVALID_RANGE);
         return 0;
     }
 
@@ -170,7 +170,7 @@ static int bnrand_range(BNRAND_FLAG flag, BIGNUM *r, const BIGNUM *range,
             }
 
             if (!--count) {
-                BNerr(BN_F_BNRAND_RANGE, BN_R_TOO_MANY_ITERATIONS);
+                ERR_raise(ERR_LIB_BN, BN_R_TOO_MANY_ITERATIONS);
                 return 0;
             }
 
@@ -183,7 +183,7 @@ static int bnrand_range(BNRAND_FLAG flag, BIGNUM *r, const BIGNUM *range,
                 return 0;
 
             if (!--count) {
-                BNerr(BN_F_BNRAND_RANGE, BN_R_TOO_MANY_ITERATIONS);
+                ERR_raise(ERR_LIB_BN, BN_R_TOO_MANY_ITERATIONS);
                 return 0;
             }
         }
@@ -270,13 +270,13 @@ int BN_generate_dsa_nonce(BIGNUM *out, const BIGNUM *range,
          * large and we don't handle this case in order to avoid leaking the
          * length of the private key.
          */
-        BNerr(BN_F_BN_GENERATE_DSA_NONCE, BN_R_PRIVATE_KEY_TOO_LARGE);
+        ERR_raise(ERR_LIB_BN, BN_R_PRIVATE_KEY_TOO_LARGE);
         goto err;
     }
 
     md = EVP_MD_fetch(libctx, &quot;SHA512&quot;, NULL);
     if (md == NULL) {
-        BNerr(BN_F_BN_GENERATE_DSA_NONCE, BN_R_NO_SUITABLE_DIGEST);
+        ERR_raise(ERR_LIB_BN, BN_R_NO_SUITABLE_DIGEST);
         goto err;
     }
     for (done = 0; done &lt; num_k_bytes;) {
diff --git a/crypto/bn/bn_recp.c b/crypto/bn/bn_recp.c
index 2cfe3156b9..7342885dd9 100644
--- a/crypto/bn/bn_recp.c
+++ b/crypto/bn/bn_recp.c
@@ -22,7 +22,7 @@ BN_RECP_CTX *BN_RECP_CTX_new(void)
     BN_RECP_CTX *ret;
 
     if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {
-        BNerr(BN_F_BN_RECP_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BN, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -146,7 +146,7 @@ int BN_div_recp(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m,
     j = 0;
     while (BN_ucmp(r, &amp;(recp-&gt;N)) &gt;= 0) {
         if (j++ &gt; 2) {
-            BNerr(BN_F_BN_DIV_RECP, BN_R_BAD_RECIPROCAL);
+            ERR_raise(ERR_LIB_BN, BN_R_BAD_RECIPROCAL);
             goto err;
         }
         if (!BN_usub(r, r, &amp;(recp-&gt;N)))
diff --git a/crypto/bn/bn_shift.c b/crypto/bn/bn_shift.c
index 5481609d0f..776b311426 100644
--- a/crypto/bn/bn_shift.c
+++ b/crypto/bn/bn_shift.c
@@ -83,7 +83,7 @@ int BN_lshift(BIGNUM *r, const BIGNUM *a, int n)
     int ret;
 
     if (n &lt; 0) {
-        BNerr(BN_F_BN_LSHIFT, BN_R_INVALID_SHIFT);
+        ERR_raise(ERR_LIB_BN, BN_R_INVALID_SHIFT);
         return 0;
     }
 
@@ -152,7 +152,7 @@ int BN_rshift(BIGNUM *r, const BIGNUM *a, int n)
     int ret = 0;
 
     if (n &lt; 0) {
-        BNerr(BN_F_BN_RSHIFT, BN_R_INVALID_SHIFT);
+        ERR_raise(ERR_LIB_BN, BN_R_INVALID_SHIFT);
         return 0;
     }
 
diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c
index d39f65f53b..2dbd180aba 100644
--- a/crypto/bn/bn_sqrt.c
+++ b/crypto/bn/bn_sqrt.c
@@ -38,7 +38,7 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
             return ret;
         }
 
-        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);
+        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);
         return NULL;
     }
 
@@ -197,7 +197,7 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
             goto end;
         if (r == 0) {
             /* m divides p */
-            BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);
+            ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);
             goto end;
         }
     }
@@ -209,7 +209,7 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
          * than just bad luck. Even if p is not prime, we should have found
          * some y such that r == -1.
          */
-        BNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);
+        ERR_raise(ERR_LIB_BN, BN_R_TOO_MANY_ITERATIONS);
         goto end;
     }
 
@@ -224,7 +224,7 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
     if (!BN_mod_exp(y, y, q, p, ctx))
         goto end;
     if (BN_is_one(y)) {
-        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);
+        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);
         goto end;
     }
 
@@ -308,7 +308,7 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
         while (!BN_is_one(t)) {
             i++;
             if (i == e) {
-                BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);
+                ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);
                 goto end;
             }
             if (!BN_mod_mul(t, t, t, p, ctx))
@@ -342,7 +342,7 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
             err = 1;
 
         if (!err &amp;&amp; 0 != BN_cmp(x, A)) {
-            BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);
+            ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);
             err = 1;
         }
     }
diff --git a/crypto/buffer/buffer.c b/crypto/buffer/buffer.c
index 6589a079b5..286984f69a 100644
--- a/crypto/buffer/buffer.c
+++ b/crypto/buffer/buffer.c
@@ -34,7 +34,7 @@ BUF_MEM *BUF_MEM_new(void)
 
     ret = OPENSSL_zalloc(sizeof(*ret));
     if (ret == NULL) {
-        BUFerr(BUF_F_BUF_MEM_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BUF, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     return ret;
@@ -87,7 +87,7 @@ size_t BUF_MEM_grow(BUF_MEM *str, size_t len)
     }
     /* This limit is sufficient to ensure (len+3)/3*4 &lt; 2**31 */
     if (len &gt; LIMIT_BEFORE_EXPANSION) {
-        BUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BUF, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     n = (len + 3) / 3 * 4;
@@ -96,7 +96,7 @@ size_t BUF_MEM_grow(BUF_MEM *str, size_t len)
     else
         ret = OPENSSL_realloc(str-&gt;data, n);
     if (ret == NULL) {
-        BUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BUF, ERR_R_MALLOC_FAILURE);
         len = 0;
     } else {
         str-&gt;data = ret;
@@ -125,7 +125,7 @@ size_t BUF_MEM_grow_clean(BUF_MEM *str, size_t len)
     }
     /* This limit is sufficient to ensure (len+3)/3*4 &lt; 2**31 */
     if (len &gt; LIMIT_BEFORE_EXPANSION) {
-        BUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BUF, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     n = (len + 3) / 3 * 4;
@@ -134,7 +134,7 @@ size_t BUF_MEM_grow_clean(BUF_MEM *str, size_t len)
     else
         ret = OPENSSL_clear_realloc(str-&gt;data, str-&gt;max, n);
     if (ret == NULL) {
-        BUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_BUF, ERR_R_MALLOC_FAILURE);
         len = 0;
     } else {
         str-&gt;data = ret;
diff --git a/crypto/cmac/cmac.c b/crypto/cmac/cmac.c
index 81a6490384..12445c4a24 100644
--- a/crypto/cmac/cmac.c
+++ b/crypto/cmac/cmac.c
@@ -54,7 +54,7 @@ CMAC_CTX *CMAC_CTX_new(void)
     CMAC_CTX *ctx;
 
     if ((ctx = OPENSSL_malloc(sizeof(*ctx))) == NULL) {
-        CRYPTOerr(CRYPTO_F_CMAC_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ctx-&gt;cctx = EVP_CIPHER_CTX_new();
diff --git a/crypto/cmp/cmp_asn.c b/crypto/cmp/cmp_asn.c
index d9013911a0..e2f7169dda 100644
--- a/crypto/cmp/cmp_asn.c
+++ b/crypto/cmp/cmp_asn.c
@@ -167,7 +167,7 @@ int OSSL_CMP_ITAV_push0_stack_item(STACK_OF(OSSL_CMP_ITAV) **itav_sk_p,
     int created = 0;
 
     if (itav_sk_p == NULL || itav == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         goto err;
     }
 
@@ -194,15 +194,15 @@ int ossl_cmp_asn1_get_int(const ASN1_INTEGER *a)
     int64_t res;
 
     if (!ASN1_INTEGER_get_int64(&amp;res, a)) {
-        CMPerr(0, ASN1_R_INVALID_NUMBER);
+        ERR_raise(ERR_LIB_CMP, ASN1_R_INVALID_NUMBER);
         return -1;
     }
     if (res &lt; INT_MIN) {
-        CMPerr(0, ASN1_R_TOO_SMALL);
+        ERR_raise(ERR_LIB_CMP, ASN1_R_TOO_SMALL);
         return -1;
     }
     if (res &gt; INT_MAX) {
-        CMPerr(0, ASN1_R_TOO_LARGE);
+        ERR_raise(ERR_LIB_CMP, ASN1_R_TOO_LARGE);
         return -1;
     }
     return (int)res;
diff --git a/crypto/cmp/cmp_client.c b/crypto/cmp/cmp_client.c
index ef256e6c72..c19eea818f 100644
--- a/crypto/cmp/cmp_client.c
+++ b/crypto/cmp/cmp_client.c
@@ -147,12 +147,12 @@ static int send_receive_check(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *req,
     if ((IS_CREP(expected_type) || expected_type == OSSL_CMP_PKIBODY_POLLREP)
             &amp;&amp; ctx-&gt;total_timeout &gt; 0 /* timeout is not infinite */) {
         if (now &gt;= ctx-&gt;end_time) {
-            CMPerr(0, CMP_R_TOTAL_TIMEOUT);
+            ERR_raise(ERR_LIB_CMP, CMP_R_TOTAL_TIMEOUT);
             return 0;
         }
         if (!ossl_assert(ctx-&gt;end_time - time(NULL) &lt; INT_MAX)) {
             /* cannot really happen due to the assignment in do_certreq_seq() */
-            CMPerr(0, CMP_R_INVALID_ARGS);
+            ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
             return 0;
         }
         time_left = (int)(ctx-&gt;end_time - now);
@@ -169,9 +169,9 @@ static int send_receive_check(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *req,
     ctx-&gt;msg_timeout = msg_timeout; /* restore original value */
 
     if (*rep == NULL) {
-        CMPerr(0, CMP_R_TRANSFER_ERROR); /* or receiving response */
-        ERR_add_error_data(2, &quot;request sent: &quot;, req_type_str);
-        ERR_add_error_data(2, &quot;, expected response: &quot;, expected_type_str);
+        ERR_raise_data(ERR_LIB_CMP, CMP_R_TRANSFER_ERROR, /* or receiving response */
+                       &quot;request sent: %s, expected response: %s&quot;,
+                       req_type_str, expected_type_str);
         return 0;
     }
 
@@ -198,7 +198,7 @@ static int send_receive_check(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *req,
         return 1;
 
     /* received message type is not one of the expected ones (e.g., error) */
-    CMPerr(0, bt == OSSL_CMP_PKIBODY_ERROR ? CMP_R_RECEIVED_ERROR :
+    ERR_raise(ERR_LIB_CMP, bt == OSSL_CMP_PKIBODY_ERROR ? CMP_R_RECEIVED_ERROR :
            CMP_R_UNEXPECTED_PKIBODY); /* in next line for mkerr.pl */
 
     if (bt != OSSL_CMP_PKIBODY_ERROR) {
@@ -226,7 +226,7 @@ static int send_receive_check(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *req,
             OPENSSL_free(text);
         }
         if (ctx-&gt;status != OSSL_CMP_PKISTATUS_rejection) {
-            CMPerr(0, CMP_R_UNEXPECTED_PKISTATUS);
+            ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKISTATUS);
             if (ctx-&gt;status == OSSL_CMP_PKISTATUS_waiting)
                 ctx-&gt;status = OSSL_CMP_PKISTATUS_rejection;
         }
@@ -276,7 +276,7 @@ static int poll_for_response(OSSL_CMP_CTX *ctx, int sleep, int rid,
 
             /* TODO: handle potentially multiple elements in pollRep */
             if (sk_OSSL_CMP_POLLREP_num(prc) &gt; 1) {
-                CMPerr(0, CMP_R_MULTIPLE_RESPONSES_NOT_SUPPORTED);
+                ERR_raise(ERR_LIB_CMP, CMP_R_MULTIPLE_RESPONSES_NOT_SUPPORTED);
                 goto err;
             }
             pollRep = ossl_cmp_pollrepcontent_get0_pollrep(prc, rid);
@@ -284,12 +284,12 @@ static int poll_for_response(OSSL_CMP_CTX *ctx, int sleep, int rid,
                 goto err;
 
             if (!ASN1_INTEGER_get_int64(&amp;check_after, pollRep-&gt;checkAfter)) {
-                CMPerr(0, CMP_R_BAD_CHECKAFTER_IN_POLLREP);
+                ERR_raise(ERR_LIB_CMP, CMP_R_BAD_CHECKAFTER_IN_POLLREP);
                 goto err;
             }
             if (check_after &lt; 0 || (uint64_t)check_after
                 &gt; (sleep ? ULONG_MAX / 1000 : INT_MAX)) {
-                CMPerr(0, CMP_R_CHECKAFTER_OUT_OF_RANGE);
+                ERR_raise(ERR_LIB_CMP, CMP_R_CHECKAFTER_OUT_OF_RANGE);
                 if (BIO_snprintf(str, OSSL_CMP_PKISI_BUFLEN, &quot;value = %jd&quot;,
                                  check_after) &gt;= 0)
                     ERR_add_error_data(1, str);
@@ -300,7 +300,7 @@ static int poll_for_response(OSSL_CMP_CTX *ctx, int sleep, int rid,
                 int64_t time_left = (int64_t)(ctx-&gt;end_time - exp - time(NULL));
 
                 if (time_left &lt;= 0) {
-                    CMPerr(0, CMP_R_TOTAL_TIMEOUT);
+                    ERR_raise(ERR_LIB_CMP, CMP_R_TOTAL_TIMEOUT);
                     goto err;
                 }
                 if (time_left &lt; check_after)
@@ -420,7 +420,7 @@ static X509 *get1_cert_status(OSSL_CMP_CTX *ctx, int bodytype,
     case OSSL_CMP_PKISTATUS_waiting:
         ossl_cmp_err(ctx,
                      &quot;received \&quot;waiting\&quot; status for cert when actually aiming to extract cert&quot;);
-        CMPerr(0, CMP_R_ENCOUNTERED_WAITING);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ENCOUNTERED_WAITING);
         goto err;
     case OSSL_CMP_PKISTATUS_grantedWithMods:
         ossl_cmp_warn(ctx, &quot;received \&quot;grantedWithMods\&quot; for certificate&quot;);
@@ -430,7 +430,7 @@ static X509 *get1_cert_status(OSSL_CMP_CTX *ctx, int bodytype,
         /* get all information in case of a rejection before going to error */
     case OSSL_CMP_PKISTATUS_rejection:
         ossl_cmp_err(ctx, &quot;received \&quot;rejection\&quot; status rather than cert&quot;);
-        CMPerr(0, CMP_R_REQUEST_REJECTED_BY_SERVER);
+        ERR_raise(ERR_LIB_CMP, CMP_R_REQUEST_REJECTED_BY_SERVER);
         goto err;
     case OSSL_CMP_PKISTATUS_revocationWarning:
         ossl_cmp_warn(ctx,
@@ -442,7 +442,7 @@ static X509 *get1_cert_status(OSSL_CMP_CTX *ctx, int bodytype,
         break;
     case OSSL_CMP_PKISTATUS_keyUpdateWarning:
         if (bodytype != OSSL_CMP_PKIBODY_KUR) {
-            CMPerr(0, CMP_R_ENCOUNTERED_KEYUPDATEWARNING);
+            ERR_raise(ERR_LIB_CMP, CMP_R_ENCOUNTERED_KEYUPDATEWARNING);
             goto err;
         }
         break;
@@ -450,12 +450,12 @@ static X509 *get1_cert_status(OSSL_CMP_CTX *ctx, int bodytype,
         ossl_cmp_log1(ERROR, ctx,
                       &quot;received unsupported PKIStatus %d for certificate&quot;,
                       ctx-&gt;status);
-        CMPerr(0, CMP_R_UNKNOWN_PKISTATUS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNKNOWN_PKISTATUS);
         goto err;
     }
     crt = ossl_cmp_certresponse_get1_cert(crep, ctx, privkey);
     if (crt == NULL) /* according to PKIStatus, we can expect a cert */
-        CMPerr(0, CMP_R_CERTIFICATE_NOT_FOUND);
+        ERR_raise(ERR_LIB_CMP, CMP_R_CERTIFICATE_NOT_FOUND);
 
     return crt;
 
@@ -546,7 +546,7 @@ static int cert_response(OSSL_CMP_CTX *ctx, int sleep, int rid,
  retry:
     crepmsg = (*resp)-&gt;body-&gt;value.ip; /* same for cp and kup */
     if (sk_OSSL_CMP_CERTRESPONSE_num(crepmsg-&gt;response) &gt; 1) {
-        CMPerr(0, CMP_R_MULTIPLE_RESPONSES_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_CMP, CMP_R_MULTIPLE_RESPONSES_NOT_SUPPORTED);
         return 0;
     }
     /* TODO: handle potentially multiple CertResponses in CertRepMsg */
@@ -559,7 +559,7 @@ static int cert_response(OSSL_CMP_CTX *ctx, int sleep, int rid,
         /* for OSSL_CMP_PKIBODY_P10CR learn CertReqId from response */
         rid = ossl_cmp_asn1_get_int(crep-&gt;certReqId);
         if (rid == -1) {
-            CMPerr(0, CMP_R_BAD_REQUEST_ID);
+            ERR_raise(ERR_LIB_CMP, CMP_R_BAD_REQUEST_ID);
             return 0;
         }
     }
@@ -572,7 +572,7 @@ static int cert_response(OSSL_CMP_CTX *ctx, int sleep, int rid,
                 return ret; /* waiting */
             goto retry; /* got ip/cp/kup, which may still indicate 'waiting' */
         } else {
-            CMPerr(0, CMP_R_POLLING_FAILED);
+            ERR_raise(ERR_LIB_CMP, CMP_R_POLLING_FAILED);
             return 0;
         }
     }
@@ -633,11 +633,14 @@ static int cert_response(OSSL_CMP_CTX *ctx, int sleep, int rid,
 
     /* not throwing failure earlier as transfer_cb may call ERR_clear_error() */
     if (fail_info != 0) {
-        CMPerr(0, CMP_R_CERTIFICATE_NOT_ACCEPTED);
-        ERR_add_error_data(2, &quot;rejecting newly enrolled cert with subject: &quot;,
+        if (txt == NULL)
+            ERR_raise_data(ERR_LIB_CMP, CMP_R_CERTIFICATE_NOT_ACCEPTED,
+                           &quot;rejecting newly enrolled cert with subject: %s&quot;,
                            subj);
-        if (txt != NULL)
-            ERR_add_error_txt(&quot;; &quot;, txt);
+        else
+            ERR_raise_data(ERR_LIB_CMP, CMP_R_CERTIFICATE_NOT_ACCEPTED,
+                           &quot;rejecting newly enrolled cert with subject: %s; %s&quot;,
+                           subj, txt);
         ret = 0;
     }
     OPENSSL_free(subj);
@@ -655,7 +658,7 @@ int OSSL_CMP_try_certreq(OSSL_CMP_CTX *ctx, int req_type,
     int res = 0;
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -712,11 +715,11 @@ X509 *OSSL_CMP_exec_certreq(OSSL_CMP_CTX *ctx, int req_type,
     X509 *result = NULL;
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     if (is_p10 &amp;&amp; crm != NULL) {
-        CMPerr(0, CMP_R_INVALID_ARGS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
         return NULL;
     }
 
@@ -757,11 +760,11 @@ X509 *OSSL_CMP_exec_RR_ses(OSSL_CMP_CTX *ctx)
     X509 *result = NULL;
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_INVALID_ARGS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
         return 0;
     }
     if (ctx-&gt;oldCert == NULL) {
-        CMPerr(0, CMP_R_MISSING_REFERENCE_CERT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_REFERENCE_CERT);
         return 0;
     }
     ctx-&gt;status = -1;
@@ -776,12 +779,12 @@ X509 *OSSL_CMP_exec_RR_ses(OSSL_CMP_CTX *ctx)
     rrep = rp-&gt;body-&gt;value.rp;
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
     if (sk_OSSL_CMP_PKISI_num(rrep-&gt;status) != num_RevDetails) {
-        CMPerr(0, CMP_R_WRONG_RP_COMPONENT_COUNT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_WRONG_RP_COMPONENT_COUNT);
         goto end;
     }
 #else
     if (sk_OSSL_CMP_PKISI_num(rrep-&gt;status) &lt; 1) {
-        CMPerr(0, CMP_R_WRONG_RP_COMPONENT_COUNT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_WRONG_RP_COMPONENT_COUNT);
         goto end;
     }
 #endif
@@ -800,7 +803,7 @@ X509 *OSSL_CMP_exec_RR_ses(OSSL_CMP_CTX *ctx)
         result = ctx-&gt;oldCert;
         break;
     case OSSL_CMP_PKISTATUS_rejection:
-        CMPerr(0, CMP_R_REQUEST_REJECTED_BY_SERVER);
+        ERR_raise(ERR_LIB_CMP, CMP_R_REQUEST_REJECTED_BY_SERVER);
         goto err;
     case OSSL_CMP_PKISTATUS_revocationWarning:
         ossl_cmp_info(ctx, &quot;revocation accepted (PKIStatus=revocationWarning)&quot;);
@@ -814,10 +817,10 @@ X509 *OSSL_CMP_exec_RR_ses(OSSL_CMP_CTX *ctx)
         break;
     case OSSL_CMP_PKISTATUS_waiting:
     case OSSL_CMP_PKISTATUS_keyUpdateWarning:
-        CMPerr(0, CMP_R_UNEXPECTED_PKISTATUS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKISTATUS);
         goto err;
     default:
-        CMPerr(0, CMP_R_UNKNOWN_PKISTATUS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNKNOWN_PKISTATUS);
         goto err;
     }
 
@@ -830,7 +833,7 @@ X509 *OSSL_CMP_exec_RR_ses(OSSL_CMP_CTX *ctx)
         ASN1_INTEGER *serial = OSSL_CRMF_CERTTEMPLATE_get0_serialNumber(tmpl);
 
         if (sk_OSSL_CRMF_CERTID_num(rrep-&gt;revCerts) != num_RevDetails) {
-            CMPerr(0, CMP_R_WRONG_RP_COMPONENT_COUNT);
+            ERR_raise(ERR_LIB_CMP, CMP_R_WRONG_RP_COMPONENT_COUNT);
             result = NULL;
             goto err;
         }
@@ -840,7 +843,7 @@ X509 *OSSL_CMP_exec_RR_ses(OSSL_CMP_CTX *ctx)
         }
         if (X509_NAME_cmp(issuer, OSSL_CRMF_CERTID_get0_issuer(cid)) != 0) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-            CMPerr(0, CMP_R_WRONG_CERTID_IN_RP);
+            ERR_raise(ERR_LIB_CMP, CMP_R_WRONG_CERTID_IN_RP);
             result = NULL;
             goto err;
 #endif
@@ -848,7 +851,7 @@ X509 *OSSL_CMP_exec_RR_ses(OSSL_CMP_CTX *ctx)
         if (ASN1_INTEGER_cmp(serial,
                              OSSL_CRMF_CERTID_get0_serialNumber(cid)) != 0) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-            CMPerr(0, CMP_R_WRONG_SERIAL_IN_RP);
+            ERR_raise(ERR_LIB_CMP, CMP_R_WRONG_SERIAL_IN_RP);
             result = NULL;
             goto err;
 #endif
@@ -857,7 +860,7 @@ X509 *OSSL_CMP_exec_RR_ses(OSSL_CMP_CTX *ctx)
 
     /* check number of any optionally present crls */
     if (rrep-&gt;crls != NULL &amp;&amp; sk_X509_CRL_num(rrep-&gt;crls) != num_RevDetails) {
-        CMPerr(0, CMP_R_WRONG_RP_COMPONENT_COUNT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_WRONG_RP_COMPONENT_COUNT);
         result = NULL;
         goto err;
     }
@@ -880,7 +883,7 @@ STACK_OF(OSSL_CMP_ITAV) *OSSL_CMP_exec_GENM_ses(OSSL_CMP_CTX *ctx)
     STACK_OF(OSSL_CMP_ITAV) *rcvd_itavs = NULL;
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_INVALID_ARGS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
         return 0;
     }
 
diff --git a/crypto/cmp/cmp_ctx.c b/crypto/cmp/cmp_ctx.c
index 97d76f0223..e1b4e50ea9 100644
--- a/crypto/cmp/cmp_ctx.c
+++ b/crypto/cmp/cmp_ctx.c
@@ -27,7 +27,7 @@
 X509_STORE *OSSL_CMP_CTX_get0_trustedStore(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return ctx-&gt;trusted;
@@ -41,7 +41,7 @@ X509_STORE *OSSL_CMP_CTX_get0_trustedStore(const OSSL_CMP_CTX *ctx)
 int OSSL_CMP_CTX_set0_trustedStore(OSSL_CMP_CTX *ctx, X509_STORE *store)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     X509_STORE_free(ctx-&gt;trusted);
@@ -53,7 +53,7 @@ int OSSL_CMP_CTX_set0_trustedStore(OSSL_CMP_CTX *ctx, X509_STORE *store)
 STACK_OF(X509) *OSSL_CMP_CTX_get0_untrusted(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return ctx-&gt;untrusted;
@@ -67,7 +67,7 @@ int OSSL_CMP_CTX_set1_untrusted(OSSL_CMP_CTX *ctx, STACK_OF(X509) *certs)
 {
     STACK_OF(X509) *untrusted;
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if ((untrusted = sk_X509_new_null()) == NULL)
@@ -89,7 +89,7 @@ static int cmp_ctx_set_md(OSSL_CMP_CTX *ctx, EVP_MD **pmd, int nid)
     /* fetching in advance to be able to throw error early if unsupported */
 
     if (md == NULL) {
-        CMPerr(0, CMP_R_UNSUPPORTED_ALGORITHM);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNSUPPORTED_ALGORITHM);
         return 0;
     }
     EVP_MD_free(*pmd);
@@ -138,7 +138,7 @@ OSSL_CMP_CTX *OSSL_CMP_CTX_new(OSSL_LIB_CTX *libctx, const char *propq)
 
  err:
     OSSL_CMP_CTX_free(ctx);
-    X509err(0, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -146,7 +146,7 @@ OSSL_CMP_CTX *OSSL_CMP_CTX_new(OSSL_LIB_CTX *libctx, const char *propq)
 int OSSL_CMP_CTX_reinit(OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -233,7 +233,7 @@ int ossl_cmp_ctx_set_status(OSSL_CMP_CTX *ctx, int status)
 int OSSL_CMP_CTX_get_status(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return -1;
     }
     return ctx-&gt;status;
@@ -246,7 +246,7 @@ int OSSL_CMP_CTX_get_status(const OSSL_CMP_CTX *ctx)
 OSSL_CMP_PKIFREETEXT *OSSL_CMP_CTX_get0_statusString(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return ctx-&gt;statusString;
@@ -275,7 +275,7 @@ int ossl_cmp_ctx_set0_validatedSrvCert(OSSL_CMP_CTX *ctx, X509 *cert)
 int OSSL_CMP_CTX_set_certConf_cb(OSSL_CMP_CTX *ctx, OSSL_CMP_certConf_cb_t cb)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx-&gt;certConf_cb = cb;
@@ -289,7 +289,7 @@ int OSSL_CMP_CTX_set_certConf_cb(OSSL_CMP_CTX *ctx, OSSL_CMP_certConf_cb_t cb)
 int OSSL_CMP_CTX_set_certConf_cb_arg(OSSL_CMP_CTX *ctx, void *arg)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx-&gt;certConf_cb_arg = arg;
@@ -304,7 +304,7 @@ int OSSL_CMP_CTX_set_certConf_cb_arg(OSSL_CMP_CTX *ctx, void *arg)
 void *OSSL_CMP_CTX_get_certConf_cb_arg(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return ctx-&gt;certConf_cb_arg;
@@ -398,7 +398,7 @@ int ossl_cmp_print_log(OSSL_CMP_severity level, const OSSL_CMP_CTX *ctx,
 int OSSL_CMP_CTX_set_log_cb(OSSL_CMP_CTX *ctx, OSSL_CMP_log_cb_t cb)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx-&gt;log_cb = cb;
@@ -429,7 +429,7 @@ int OSSL_CMP_CTX_set1_referenceValue(OSSL_CMP_CTX *ctx,
                                      const unsigned char *ref, int len)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     return ossl_cmp_asn1_octet_string_set1_bytes(&amp;ctx-&gt;referenceValue, ref,
@@ -442,7 +442,7 @@ int OSSL_CMP_CTX_set1_secretValue(OSSL_CMP_CTX *ctx, const unsigned char *sec,
 {
     ASN1_OCTET_STRING *secretValue = NULL;
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (ossl_cmp_asn1_octet_string_set1_bytes(&amp;secretValue, sec, len) != 1)
@@ -459,7 +459,7 @@ int OSSL_CMP_CTX_set1_secretValue(OSSL_CMP_CTX *ctx, const unsigned char *sec,
 STACK_OF(X509) *OSSL_CMP_CTX_get1_newChain(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     if (ctx-&gt;newChain == NULL)
@@ -487,7 +487,7 @@ int ossl_cmp_ctx_set1_newChain(OSSL_CMP_CTX *ctx, STACK_OF(X509) *newChain)
 STACK_OF(X509) *OSSL_CMP_CTX_get1_extraCertsIn(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     if (ctx-&gt;extraCertsIn == NULL)
@@ -520,7 +520,7 @@ int OSSL_CMP_CTX_set1_extraCertsOut(OSSL_CMP_CTX *ctx,
                                     STACK_OF(X509) *extraCertsOut)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -538,7 +538,7 @@ int OSSL_CMP_CTX_set1_extraCertsOut(OSSL_CMP_CTX *ctx,
 int OSSL_CMP_CTX_push0_policy(OSSL_CMP_CTX *ctx, POLICYINFO *pinfo)
 {
     if (ctx == NULL || pinfo == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -553,7 +553,7 @@ int OSSL_CMP_CTX_push0_policy(OSSL_CMP_CTX *ctx, POLICYINFO *pinfo)
 int OSSL_CMP_CTX_push0_geninfo_ITAV(OSSL_CMP_CTX *ctx, OSSL_CMP_ITAV *itav)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     return OSSL_CMP_ITAV_push0_stack_item(&amp;ctx-&gt;geninfo_ITAVs, itav);
@@ -563,7 +563,7 @@ int OSSL_CMP_CTX_push0_geninfo_ITAV(OSSL_CMP_CTX *ctx, OSSL_CMP_ITAV *itav)
 int OSSL_CMP_CTX_push0_genm_ITAV(OSSL_CMP_CTX *ctx, OSSL_CMP_ITAV *itav)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     return OSSL_CMP_ITAV_push0_stack_item(&amp;ctx-&gt;genm_ITAVs, itav);
@@ -577,7 +577,7 @@ int OSSL_CMP_CTX_push0_genm_ITAV(OSSL_CMP_CTX *ctx, OSSL_CMP_ITAV *itav)
 STACK_OF(X509) *OSSL_CMP_CTX_get1_caPubs(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     if (ctx-&gt;caPubs == NULL)
@@ -609,7 +609,7 @@ int OSSL_CMP_CTX_set1_##FIELD(OSSL_CMP_CTX *ctx, const TYPE *val) \
     TYPE *val_dup = NULL; \
     \
     if (ctx == NULL) { \
-        CMPerr(0, CMP_R_NULL_ARGUMENT); \
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT); \
         return 0; \
     } \
     \
@@ -626,13 +626,13 @@ int OSSL_CMP_CTX_set1_##FIELD(OSSL_CMP_CTX *ctx, const TYPE *val) \
 int OSSL_CMP_CTX_set1_##FIELD(OSSL_CMP_CTX *ctx, TYPE *val) \
 { \
     if (ctx == NULL) { \
-        CMPerr(0, CMP_R_NULL_ARGUMENT); \
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT); \
         return 0; \
     } \
     \
     /* prevent misleading error later on malformed cert or provider issue */ \
     if (val != NULL &amp;&amp; TYPE##_invalid(val)) { \
-        CMPerr(0, CMP_R_POTENTIALLY_INVALID_CERTIFICATE); \
+        ERR_raise(ERR_LIB_CMP, CMP_R_POTENTIALLY_INVALID_CERTIFICATE); \
         return 0; \
     } \
     if (val != NULL &amp;&amp; !TYPE##_up_ref(val)) \
@@ -668,13 +668,13 @@ DEFINE_OSSL_CMP_CTX_set1(subjectName, X509_NAME)
 int OSSL_CMP_CTX_set0_reqExtensions(OSSL_CMP_CTX *ctx, X509_EXTENSIONS *exts)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
     if (sk_GENERAL_NAME_num(ctx-&gt;subjectAltNames) &gt; 0 &amp;&amp; exts != NULL
             &amp;&amp; X509v3_get_ext_by_NID(exts, NID_subject_alt_name, -1) &gt;= 0) {
-        CMPerr(0, CMP_R_MULTIPLE_SAN_SOURCES);
+        ERR_raise(ERR_LIB_CMP, CMP_R_MULTIPLE_SAN_SOURCES);
         return 0;
     }
     sk_X509_EXTENSION_pop_free(ctx-&gt;reqExtensions, X509_EXTENSION_free);
@@ -686,7 +686,7 @@ int OSSL_CMP_CTX_set0_reqExtensions(OSSL_CMP_CTX *ctx, X509_EXTENSIONS *exts)
 int OSSL_CMP_CTX_reqExtensions_have_SAN(OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return -1;
     }
     /* if one of the following conditions 'fail' this is not an error */
@@ -705,12 +705,12 @@ int OSSL_CMP_CTX_push1_subjectAltName(OSSL_CMP_CTX *ctx,
     GENERAL_NAME *name_dup;
 
     if (ctx == NULL || name == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
     if (OSSL_CMP_CTX_reqExtensions_have_SAN(ctx) == 1) {
-        CMPerr(0, CMP_R_MULTIPLE_SAN_SOURCES);
+        ERR_raise(ERR_LIB_CMP, CMP_R_MULTIPLE_SAN_SOURCES);
         return 0;
     }
 
@@ -738,7 +738,7 @@ int OSSL_CMP_CTX_build_cert_chain(OSSL_CMP_CTX *ctx, X509_STORE *own_trusted,
     STACK_OF(X509) *chain;
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -752,7 +752,7 @@ int OSSL_CMP_CTX_build_cert_chain(OSSL_CMP_CTX *ctx, X509_STORE *own_trusted,
     chain = ossl_cmp_build_cert_chain(ctx-&gt;libctx, ctx-&gt;propq, own_trusted,
                                       ctx-&gt;untrusted, ctx-&gt;cert);
     if (chain == NULL) {
-        CMPerr(0, CMP_R_FAILED_BUILDING_OWN_CHAIN);
+        ERR_raise(ERR_LIB_CMP, CMP_R_FAILED_BUILDING_OWN_CHAIN);
         return 0;
     }
     ossl_cmp_debug(ctx, &quot;success building chain for own CMP signer cert&quot;);
@@ -792,7 +792,7 @@ int ossl_cmp_ctx_set0_newCert(OSSL_CMP_CTX *ctx, X509 *cert)
 X509 *OSSL_CMP_CTX_get0_newCert(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return ctx-&gt;newCert;
@@ -805,7 +805,7 @@ DEFINE_OSSL_CMP_CTX_set1_up_ref(pkey, EVP_PKEY)
 int OSSL_CMP_CTX_set0_newPkey(OSSL_CMP_CTX *ctx, int priv, EVP_PKEY *pkey)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -819,7 +819,7 @@ int OSSL_CMP_CTX_set0_newPkey(OSSL_CMP_CTX *ctx, int priv, EVP_PKEY *pkey)
 EVP_PKEY *OSSL_CMP_CTX_get0_newPkey(const OSSL_CMP_CTX *ctx, int priv)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
 
@@ -835,7 +835,7 @@ int OSSL_CMP_CTX_set1_transactionID(OSSL_CMP_CTX *ctx,
                                     const ASN1_OCTET_STRING *id)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     return ossl_cmp_asn1_octet_string_set1(&amp;ctx-&gt;transactionID, id);
@@ -855,7 +855,7 @@ int OSSL_CMP_CTX_set1_senderNonce(OSSL_CMP_CTX *ctx,
                                   const ASN1_OCTET_STRING *nonce)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     return ossl_cmp_asn1_octet_string_set1(&amp;ctx-&gt;senderNonce, nonce);
@@ -874,7 +874,7 @@ DEFINE_OSSL_CMP_CTX_set1(no_proxy, char)
 int OSSL_CMP_CTX_set_http_cb(OSSL_CMP_CTX *ctx, OSSL_HTTP_bio_cb_t cb)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx-&gt;http_cb = cb;
@@ -885,7 +885,7 @@ int OSSL_CMP_CTX_set_http_cb(OSSL_CMP_CTX *ctx, OSSL_HTTP_bio_cb_t cb)
 int OSSL_CMP_CTX_set_http_cb_arg(OSSL_CMP_CTX *ctx, void *arg)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx-&gt;http_cb_arg = arg;
@@ -899,7 +899,7 @@ int OSSL_CMP_CTX_set_http_cb_arg(OSSL_CMP_CTX *ctx, void *arg)
 void *OSSL_CMP_CTX_get_http_cb_arg(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return ctx-&gt;http_cb_arg;
@@ -909,7 +909,7 @@ void *OSSL_CMP_CTX_get_http_cb_arg(const OSSL_CMP_CTX *ctx)
 int OSSL_CMP_CTX_set_transfer_cb(OSSL_CMP_CTX *ctx, OSSL_CMP_transfer_cb_t cb)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx-&gt;transfer_cb = cb;
@@ -920,7 +920,7 @@ int OSSL_CMP_CTX_set_transfer_cb(OSSL_CMP_CTX *ctx, OSSL_CMP_transfer_cb_t cb)
 int OSSL_CMP_CTX_set_transfer_cb_arg(OSSL_CMP_CTX *ctx, void *arg)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx-&gt;transfer_cb_arg = arg;
@@ -934,7 +934,7 @@ int OSSL_CMP_CTX_set_transfer_cb_arg(OSSL_CMP_CTX *ctx, void *arg)
 void *OSSL_CMP_CTX_get_transfer_cb_arg(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return ctx-&gt;transfer_cb_arg;
@@ -944,7 +944,7 @@ void *OSSL_CMP_CTX_get_transfer_cb_arg(const OSSL_CMP_CTX *ctx)
 int OSSL_CMP_CTX_set_serverPort(OSSL_CMP_CTX *ctx, int port)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx-&gt;serverPort = port;
@@ -970,7 +970,7 @@ int ossl_cmp_ctx_set_failInfoCode(OSSL_CMP_CTX *ctx, int fail_info)
 int OSSL_CMP_CTX_get_failInfoCode(const OSSL_CMP_CTX *ctx)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return -1;
     }
     return ctx-&gt;failInfoCode;
@@ -982,7 +982,7 @@ int OSSL_CMP_CTX_set_option(OSSL_CMP_CTX *ctx, int opt, int val)
     int min_val;
 
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -998,14 +998,14 @@ int OSSL_CMP_CTX_set_option(OSSL_CMP_CTX *ctx, int opt, int val)
         break;
     }
     if (val &lt; min_val) {
-        CMPerr(0, CMP_R_VALUE_TOO_SMALL);
+        ERR_raise(ERR_LIB_CMP, CMP_R_VALUE_TOO_SMALL);
         return 0;
     }
 
     switch (opt) {
     case OSSL_CMP_OPT_LOG_VERBOSITY:
         if (val &gt; OSSL_CMP_LOG_MAX) {
-            CMPerr(0, CMP_R_VALUE_TOO_LARGE);
+            ERR_raise(ERR_LIB_CMP, CMP_R_VALUE_TOO_LARGE);
             return 0;
         }
         ctx-&gt;log_verbosity = val;
@@ -1039,7 +1039,7 @@ int OSSL_CMP_CTX_set_option(OSSL_CMP_CTX *ctx, int opt, int val)
         break;
     case OSSL_CMP_OPT_POPO_METHOD:
         if (val &gt; OSSL_CRMF_POPO_KEYAGREE) {
-            CMPerr(0, CMP_R_VALUE_TOO_LARGE);
+            ERR_raise(ERR_LIB_CMP, CMP_R_VALUE_TOO_LARGE);
             return 0;
         }
         ctx-&gt;popoMethod = val;
@@ -1066,13 +1066,13 @@ int OSSL_CMP_CTX_set_option(OSSL_CMP_CTX *ctx, int opt, int val)
         break;
     case OSSL_CMP_OPT_REVOCATION_REASON:
         if (val &gt; OCSP_REVOKED_STATUS_AACOMPROMISE) {
-            CMPerr(0, CMP_R_VALUE_TOO_LARGE);
+            ERR_raise(ERR_LIB_CMP, CMP_R_VALUE_TOO_LARGE);
             return 0;
         }
         ctx-&gt;revocationReason = val;
         break;
     default:
-        CMPerr(0, CMP_R_INVALID_OPTION);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_OPTION);
         return 0;
     }
 
@@ -1086,7 +1086,7 @@ int OSSL_CMP_CTX_set_option(OSSL_CMP_CTX *ctx, int opt, int val)
 int OSSL_CMP_CTX_get_option(const OSSL_CMP_CTX *ctx, int opt)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return -1;
     }
 
@@ -1128,7 +1128,7 @@ int OSSL_CMP_CTX_get_option(const OSSL_CMP_CTX *ctx, int opt)
     case OSSL_CMP_OPT_REVOCATION_REASON:
         return ctx-&gt;revocationReason;
     default:
-        CMPerr(0, CMP_R_INVALID_OPTION);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_OPTION);
         return -1;
     }
 }
diff --git a/crypto/cmp/cmp_hdr.c b/crypto/cmp/cmp_hdr.c
index 947f984505..5882d9c9de 100644
--- a/crypto/cmp/cmp_hdr.c
+++ b/crypto/cmp/cmp_hdr.c
@@ -50,7 +50,7 @@ ASN1_OCTET_STRING *OSSL_CMP_HDR_get0_transactionID(const
                                                    OSSL_CMP_PKIHEADER *hdr)
 {
     if (hdr == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return hdr-&gt;transactionID;
@@ -66,7 +66,7 @@ ASN1_OCTET_STRING *ossl_cmp_hdr_get0_senderNonce(const OSSL_CMP_PKIHEADER *hdr)
 ASN1_OCTET_STRING *OSSL_CMP_HDR_get0_recipNonce(const OSSL_CMP_PKIHEADER *hdr)
 {
     if (hdr == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return hdr-&gt;recipNonce;
@@ -147,7 +147,7 @@ static int set_random(ASN1_OCTET_STRING **tgt, OSSL_CMP_CTX *ctx, size_t len)
     int res = 0;
 
     if (bytes == NULL || RAND_bytes_ex(ctx-&gt;libctx, bytes, len) &lt;= 0)
-        CMPerr(0, CMP_R_FAILURE_OBTAINING_RANDOM);
+        ERR_raise(ERR_LIB_CMP, CMP_R_FAILURE_OBTAINING_RANDOM);
     else
         res = ossl_cmp_asn1_octet_string_set1_bytes(tgt, bytes, len);
     OPENSSL_free(bytes);
diff --git a/crypto/cmp/cmp_http.c b/crypto/cmp/cmp_http.c
index 33b5f6af7a..215c47c7c5 100644
--- a/crypto/cmp/cmp_http.c
+++ b/crypto/cmp/cmp_http.c
@@ -42,7 +42,7 @@ OSSL_CMP_MSG *OSSL_CMP_MSG_http_perform(OSSL_CMP_CTX *ctx,
     OSSL_CMP_MSG *res;
 
     if (ctx == NULL || req == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
 
diff --git a/crypto/cmp/cmp_msg.c b/crypto/cmp/cmp_msg.c
index 2333b0bc2b..1a4a873168 100644
--- a/crypto/cmp/cmp_msg.c
+++ b/crypto/cmp/cmp_msg.c
@@ -24,7 +24,7 @@
 OSSL_CMP_PKIHEADER *OSSL_CMP_MSG_get0_header(const OSSL_CMP_MSG *msg)
 {
     if (msg == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return msg-&gt;header;
@@ -118,7 +118,7 @@ OSSL_CMP_MSG *ossl_cmp_msg_create(OSSL_CMP_CTX *ctx, int bodytype)
 
     case OSSL_CMP_PKIBODY_P10CR:
         if (ctx-&gt;p10CSR == NULL) {
-            CMPerr(0, CMP_R_MISSING_P10CSR);
+            ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_P10CSR);
             goto err;
         }
         if ((msg-&gt;body-&gt;value.p10cr = X509_REQ_dup(ctx-&gt;p10CSR)) == NULL)
@@ -173,7 +173,7 @@ OSSL_CMP_MSG *ossl_cmp_msg_create(OSSL_CMP_CTX *ctx, int bodytype)
         return msg;
 
     default:
-        CMPerr(0, CMP_R_UNEXPECTED_PKIBODY);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKIBODY);
         goto err;
     }
 
@@ -219,12 +219,12 @@ OSSL_CRMF_MSG *OSSL_CMP_CTX_setup_CRM(OSSL_CMP_CTX *ctx, int for_KUR, int rid)
         rkey = ctx-&gt;pkey; /* default is independent of ctx-&gt;oldCert */
     if (rkey == NULL) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
 #endif
     }
     if (for_KUR &amp;&amp; refcert == NULL) {
-        CMPerr(0, CMP_R_MISSING_REFERENCE_CERT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_REFERENCE_CERT);
         return NULL;
     }
     if ((crm = OSSL_CRMF_MSG_new()) == NULL)
@@ -318,7 +318,7 @@ OSSL_CMP_MSG *ossl_cmp_certreq_new(OSSL_CMP_CTX *ctx, int type,
 
     if (type != OSSL_CMP_PKIBODY_IR &amp;&amp; type != OSSL_CMP_PKIBODY_CR
             &amp;&amp; type != OSSL_CMP_PKIBODY_KUR &amp;&amp; type != OSSL_CMP_PKIBODY_P10CR) {
-        CMPerr(0, CMP_R_INVALID_ARGS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
         return NULL;
     }
 
@@ -337,7 +337,7 @@ OSSL_CMP_MSG *ossl_cmp_certreq_new(OSSL_CMP_CTX *ctx, int type,
         if (privkey == NULL)
             privkey = ctx-&gt;pkey; /* default is independent of ctx-&gt;oldCert */
         if (ctx-&gt;popoMethod == OSSL_CRMF_POPO_SIGNATURE &amp;&amp; privkey == NULL) {
-            CMPerr(0, CMP_R_MISSING_PRIVATE_KEY);
+            ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_PRIVATE_KEY);
             goto err;
         }
         if (crm == NULL) {
@@ -367,7 +367,7 @@ OSSL_CMP_MSG *ossl_cmp_certreq_new(OSSL_CMP_CTX *ctx, int type,
     return msg;
 
  err:
-    CMPerr(0, CMP_R_ERROR_CREATING_CERTREQ);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_CERTREQ);
     OSSL_CRMF_MSG_free(local_crm);
     OSSL_CMP_MSG_free(msg);
     return NULL;
@@ -407,7 +407,7 @@ OSSL_CMP_MSG *ossl_cmp_certrep_new(OSSL_CMP_CTX *ctx, int bodytype,
     if (status != OSSL_CMP_PKISTATUS_rejection
             &amp;&amp; status != OSSL_CMP_PKISTATUS_waiting &amp;&amp; cert != NULL) {
         if (encrypted) {
-            CMPerr(0, CMP_R_INVALID_ARGS);
+            ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
             goto err;
         }
 
@@ -445,7 +445,7 @@ OSSL_CMP_MSG *ossl_cmp_certrep_new(OSSL_CMP_CTX *ctx, int bodytype,
     return msg;
 
  err:
-    CMPerr(0, CMP_R_ERROR_CREATING_CERTREP);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_CERTREP);
     OSSL_CMP_CERTRESPONSE_free(resp);
     OSSL_CMP_MSG_free(msg);
     return NULL;
@@ -494,7 +494,7 @@ OSSL_CMP_MSG *ossl_cmp_rr_new(OSSL_CMP_CTX *ctx)
     return msg;
 
  err:
-    CMPerr(0, CMP_R_ERROR_CREATING_RR);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_RR);
     OSSL_CMP_MSG_free(msg);
     OSSL_CMP_REVDETAILS_free(rd);
     return NULL;
@@ -540,7 +540,7 @@ OSSL_CMP_MSG *ossl_cmp_rp_new(OSSL_CMP_CTX *ctx, OSSL_CMP_PKISI *si,
     return msg;
 
  err:
-    CMPerr(0, CMP_R_ERROR_CREATING_RP);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_RP);
     OSSL_CMP_MSG_free(msg);
     return NULL;
 }
@@ -558,7 +558,7 @@ OSSL_CMP_MSG *ossl_cmp_pkiconf_new(OSSL_CMP_CTX *ctx)
         return msg;
 
  err:
-    CMPerr(0, CMP_R_ERROR_CREATING_PKICONF);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_PKICONF);
     OSSL_CMP_MSG_free(msg);
     return NULL;
 }
@@ -573,7 +573,7 @@ int ossl_cmp_msg_gen_push0_ITAV(OSSL_CMP_MSG *msg, OSSL_CMP_ITAV *itav)
     bodytype = ossl_cmp_msg_get_bodytype(msg);
     if (bodytype != OSSL_CMP_PKIBODY_GENM
             &amp;&amp; bodytype != OSSL_CMP_PKIBODY_GENP) {
-        CMPerr(0, CMP_R_INVALID_ARGS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
         return 0;
     }
 
@@ -627,7 +627,7 @@ static OSSL_CMP_MSG *gen_new(OSSL_CMP_CTX *ctx,
     return msg;
 
  err:
-    CMPerr(0, err_code);
+    ERR_raise(ERR_LIB_CMP, err_code);
     OSSL_CMP_MSG_free(msg);
     return NULL;
 }
@@ -681,7 +681,7 @@ OSSL_CMP_MSG *ossl_cmp_error_new(OSSL_CMP_CTX *ctx, OSSL_CMP_PKISI *si,
     return msg;
 
  err:
-    CMPerr(0, CMP_R_ERROR_CREATING_ERROR);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_ERROR);
     OSSL_CMP_MSG_free(msg);
     return NULL;
 }
@@ -717,7 +717,7 @@ OSSL_CMP_MSG *ossl_cmp_certConf_new(OSSL_CMP_CTX *ctx, int fail_info,
         return NULL;
 
     if ((unsigned)fail_info &gt; OSSL_CMP_PKIFAILUREINFO_MAX_BIT_PATTERN) {
-        CMPerr(0, CMP_R_FAIL_INFO_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_FAIL_INFO_OUT_OF_RANGE);
         return NULL;
     }
 
@@ -762,7 +762,7 @@ OSSL_CMP_MSG *ossl_cmp_certConf_new(OSSL_CMP_CTX *ctx, int fail_info,
     return msg;
 
  err:
-    CMPerr(0, CMP_R_ERROR_CREATING_CERTCONF);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_CERTCONF);
     OSSL_CMP_MSG_free(msg);
     ASN1_OCTET_STRING_free(certHash);
     return NULL;
@@ -792,7 +792,7 @@ OSSL_CMP_MSG *ossl_cmp_pollReq_new(OSSL_CMP_CTX *ctx, int crid)
     return msg;
 
  err:
-    CMPerr(0, CMP_R_ERROR_CREATING_POLLREQ);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_POLLREQ);
     OSSL_CMP_POLLREQ_free(preq);
     OSSL_CMP_MSG_free(msg);
     return NULL;
@@ -823,7 +823,7 @@ OSSL_CMP_MSG *ossl_cmp_pollRep_new(OSSL_CMP_CTX *ctx, int crid,
     return msg;
 
  err:
-    CMPerr(0, CMP_R_ERROR_CREATING_POLLREP);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_POLLREP);
     OSSL_CMP_MSG_free(msg);
     return NULL;
 }
@@ -846,7 +846,7 @@ ossl_cmp_revrepcontent_get_pkisi(OSSL_CMP_REVREPCONTENT *rrep, int rsid)
     if ((status = sk_OSSL_CMP_PKISI_value(rrep-&gt;status, rsid)) != NULL)
         return status;
 
-    CMPerr(0, CMP_R_PKISTATUSINFO_NOT_FOUND);
+    ERR_raise(ERR_LIB_CMP, CMP_R_PKISTATUSINFO_NOT_FOUND);
     return NULL;
 }
 
@@ -868,7 +868,7 @@ ossl_cmp_revrepcontent_get_CertId(OSSL_CMP_REVREPCONTENT *rrep, int rsid)
     if ((cid = sk_OSSL_CRMF_CERTID_value(rrep-&gt;revCerts, rsid)) != NULL)
         return cid;
 
-    CMPerr(0, CMP_R_CERTID_NOT_FOUND);
+    ERR_raise(ERR_LIB_CMP, CMP_R_CERTID_NOT_FOUND);
     return NULL;
 }
 
@@ -882,20 +882,12 @@ static int suitable_rid(const ASN1_INTEGER *certReqId, int rid)
     trid = ossl_cmp_asn1_get_int(certReqId);
 
     if (trid == -1) {
-        CMPerr(0, CMP_R_BAD_REQUEST_ID);
+        ERR_raise(ERR_LIB_CMP, CMP_R_BAD_REQUEST_ID);
         return 0;
     }
     return rid == trid;
 }
 
-static void add_expected_rid(int rid)
-{
-    char str[DECIMAL_SIZE(rid) + 1];
-
-    BIO_snprintf(str, sizeof(str), &quot;%d&quot;, rid);
-    ERR_add_error_data(2, &quot;expected certReqId = &quot;, str);
-}
-
 /*
  * returns a pointer to the PollResponse with the given CertReqId
  * (or the first one in case -1) inside a PollRepContent
@@ -917,8 +909,8 @@ ossl_cmp_pollrepcontent_get0_pollrep(const OSSL_CMP_POLLREPCONTENT *prc,
             return pollRep;
     }
 
-    CMPerr(0, CMP_R_CERTRESPONSE_NOT_FOUND);
-    add_expected_rid(rid);
+    ERR_raise_data(ERR_LIB_CMP, CMP_R_CERTRESPONSE_NOT_FOUND,
+                   &quot;expected certReqId = %d&quot;, rid);
     return NULL;
 }
 
@@ -943,8 +935,8 @@ ossl_cmp_certrepmessage_get0_certresponse(const OSSL_CMP_CERTREPMESSAGE *crm,
             return crep;
     }
 
-    CMPerr(0, CMP_R_CERTRESPONSE_NOT_FOUND);
-    add_expected_rid(rid);
+    ERR_raise_data(ERR_LIB_CMP, CMP_R_CERTRESPONSE_NOT_FOUND,
+                   &quot;expected certReqId = %d&quot;, rid);
     return NULL;
 }
 
@@ -971,7 +963,7 @@ X509 *ossl_cmp_certresponse_get1_cert(const OSSL_CMP_CERTRESPONSE *crep,
         case OSSL_CMP_CERTORENCCERT_ENCRYPTEDCERT:
             /* cert encrypted for indirect PoP; RFC 4210, 5.2.8.2 */
             if (pkey == NULL) {
-                CMPerr(0, CMP_R_MISSING_PRIVATE_KEY);
+                ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_PRIVATE_KEY);
                 return NULL;
             }
             crt =
@@ -980,12 +972,12 @@ X509 *ossl_cmp_certresponse_get1_cert(const OSSL_CMP_CERTRESPONSE *crep,
                                                       pkey);
             break;
         default:
-            CMPerr(0, CMP_R_UNKNOWN_CERT_TYPE);
+            ERR_raise(ERR_LIB_CMP, CMP_R_UNKNOWN_CERT_TYPE);
             return NULL;
         }
     }
     if (crt == NULL)
-        CMPerr(0, CMP_R_CERTIFICATE_NOT_FOUND);
+        ERR_raise(ERR_LIB_CMP, CMP_R_CERTIFICATE_NOT_FOUND);
     else
         (void)x509_set0_libctx(crt, ctx-&gt;libctx, ctx-&gt;propq);
     return crt;
@@ -994,7 +986,7 @@ X509 *ossl_cmp_certresponse_get1_cert(const OSSL_CMP_CERTRESPONSE *crep,
 int OSSL_CMP_MSG_update_transactionID(OSSL_CMP_CTX *ctx, OSSL_CMP_MSG *msg)
 {
     if (ctx == NULL || msg == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (!ossl_cmp_hdr_set_transactionID(ctx, msg-&gt;header))
@@ -1009,7 +1001,7 @@ OSSL_CMP_MSG *OSSL_CMP_MSG_read(const char *file)
     BIO *bio = NULL;
 
     if (file == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
 
@@ -1026,7 +1018,7 @@ int OSSL_CMP_MSG_write(const char *file, const OSSL_CMP_MSG *msg)
     int res;
 
     if (file == NULL || msg == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return -1;
     }
 
diff --git a/crypto/cmp/cmp_protect.c b/crypto/cmp/cmp_protect.c
index 9b28f1b09b..fce2ebc468 100644
--- a/crypto/cmp/cmp_protect.c
+++ b/crypto/cmp/cmp_protect.c
@@ -44,7 +44,7 @@ ASN1_BIT_STRING *ossl_cmp_calc_protection(const OSSL_CMP_CTX *ctx,
     prot_part.body = msg-&gt;body;
 
     if (msg-&gt;header-&gt;protectionAlg == NULL) {
-        CMPerr(0, CMP_R_UNKNOWN_ALGORITHM_ID);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNKNOWN_ALGORITHM_ID);
         return NULL;
     }
     X509_ALGOR_get0(&amp;algorOID, &amp;pptype, &amp;ppval, msg-&gt;header-&gt;protectionAlg);
@@ -60,17 +60,17 @@ ASN1_BIT_STRING *ossl_cmp_calc_protection(const OSSL_CMP_CTX *ctx,
         const unsigned char *pbm_str_uc = NULL;
 
         if (ctx-&gt;secretValue == NULL) {
-            CMPerr(0, CMP_R_MISSING_PBM_SECRET);
+            ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_PBM_SECRET);
             return NULL;
         }
         if (ppval == NULL) {
-            CMPerr(0, CMP_R_ERROR_CALCULATING_PROTECTION);
+            ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CALCULATING_PROTECTION);
             return NULL;
         }
 
         len = i2d_OSSL_CMP_PROTECTEDPART(&amp;prot_part, &amp;prot_part_der);
         if (len &lt; 0 || prot_part_der == NULL) {
-            CMPerr(0, CMP_R_ERROR_CALCULATING_PROTECTION);
+            ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CALCULATING_PROTECTION);
             goto end;
         }
         prot_part_der_len = (size_t)len;
@@ -79,7 +79,7 @@ ASN1_BIT_STRING *ossl_cmp_calc_protection(const OSSL_CMP_CTX *ctx,
         pbm_str_uc = pbm_str-&gt;data;
         pbm = d2i_OSSL_CRMF_PBMPARAMETER(NULL, &amp;pbm_str_uc, pbm_str-&gt;length);
         if (pbm == NULL) {
-            CMPerr(0, CMP_R_WRONG_ALGORITHM_OID);
+            ERR_raise(ERR_LIB_CMP, CMP_R_WRONG_ALGORITHM_OID);
             goto end;
         }
 
@@ -108,12 +108,13 @@ ASN1_BIT_STRING *ossl_cmp_calc_protection(const OSSL_CMP_CTX *ctx,
         const EVP_MD *md = NULL;
 
         if (ctx-&gt;pkey == NULL) {
-            CMPerr(0, CMP_R_MISSING_KEY_INPUT_FOR_CREATING_PROTECTION);
+            ERR_raise(ERR_LIB_CMP,
+                      CMP_R_MISSING_KEY_INPUT_FOR_CREATING_PROTECTION);
             return NULL;
         }
         if (!OBJ_find_sigid_algs(OBJ_obj2nid(algorOID), &amp;md_nid, NULL)
                 || (md = EVP_get_digestbynid(md_nid)) == NULL) {
-            CMPerr(0, CMP_R_UNKNOWN_ALGORITHM_ID);
+            ERR_raise(ERR_LIB_CMP, CMP_R_UNKNOWN_ALGORITHM_ID);
             return NULL;
         }
 
@@ -234,7 +235,7 @@ static int set_sig_algor(const OSSL_CMP_CTX *ctx, X509_ALGOR **alg)
 
     if (!OBJ_find_sigid_by_algs(&amp;nid, EVP_MD_type(ctx-&gt;digest),
                                 EVP_PKEY_id(ctx-&gt;pkey))) {
-        CMPerr(0, CMP_R_UNSUPPORTED_KEY_TYPE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNSUPPORTED_KEY_TYPE);
         return 0;
     }
     if ((algo = OBJ_nid2obj(nid)) == NULL)
@@ -290,7 +291,7 @@ int ossl_cmp_msg_protect(OSSL_CMP_CTX *ctx, OSSL_CMP_MSG *msg)
 
         /* make sure that key and certificate match */
         if (!X509_check_private_key(ctx-&gt;cert, ctx-&gt;pkey)) {
-            CMPerr(0, CMP_R_CERT_AND_KEY_DO_NOT_MATCH);
+            ERR_raise(ERR_LIB_CMP, CMP_R_CERT_AND_KEY_DO_NOT_MATCH);
             goto err;
         }
 
@@ -305,7 +306,8 @@ int ossl_cmp_msg_protect(OSSL_CMP_CTX *ctx, OSSL_CMP_MSG *msg)
          * from ctx-&gt;untrusted, and then ctx-&gt;extraCertsOut
          */
     } else {
-        CMPerr(0, CMP_R_MISSING_KEY_INPUT_FOR_CREATING_PROTECTION);
+        ERR_raise(ERR_LIB_CMP,
+                  CMP_R_MISSING_KEY_INPUT_FOR_CREATING_PROTECTION);
         goto err;
     }
     if (!ctx-&gt;unprotectedSend
@@ -329,9 +331,9 @@ int ossl_cmp_msg_protect(OSSL_CMP_CTX *ctx, OSSL_CMP_MSG *msg)
     if (!(ossl_cmp_general_name_is_NULL_DN(msg-&gt;header-&gt;sender)
           &amp;&amp; msg-&gt;header-&gt;senderKID == NULL))
         return 1;
-    CMPerr(0, CMP_R_MISSING_SENDER_IDENTIFICATION);
+    ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_SENDER_IDENTIFICATION);
 
  err:
-    CMPerr(0, CMP_R_ERROR_PROTECTING_MESSAGE);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROTECTING_MESSAGE);
     return 0;
 }
diff --git a/crypto/cmp/cmp_server.c b/crypto/cmp/cmp_server.c
index 102fe232f2..73e996af4e 100644
--- a/crypto/cmp/cmp_server.c
+++ b/crypto/cmp/cmp_server.c
@@ -74,7 +74,7 @@ int OSSL_CMP_SRV_CTX_init(OSSL_CMP_SRV_CTX *srv_ctx, void *custom_ctx,
                           OSSL_CMP_SRV_pollReq_cb_t process_pollReq)
 {
     if (srv_ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     srv_ctx-&gt;custom_ctx = custom_ctx;
@@ -90,7 +90,7 @@ int OSSL_CMP_SRV_CTX_init(OSSL_CMP_SRV_CTX *srv_ctx, void *custom_ctx,
 OSSL_CMP_CTX *OSSL_CMP_SRV_CTX_get0_cmp_ctx(const OSSL_CMP_SRV_CTX *srv_ctx)
 {
     if (srv_ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return srv_ctx-&gt;ctx;
@@ -99,7 +99,7 @@ OSSL_CMP_CTX *OSSL_CMP_SRV_CTX_get0_cmp_ctx(const OSSL_CMP_SRV_CTX *srv_ctx)
 void *OSSL_CMP_SRV_CTX_get0_custom_ctx(const OSSL_CMP_SRV_CTX *srv_ctx)
 {
     if (srv_ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
     return srv_ctx-&gt;custom_ctx;
@@ -109,7 +109,7 @@ int OSSL_CMP_SRV_CTX_set_send_unprotected_errors(OSSL_CMP_SRV_CTX *srv_ctx,
                                                  int val)
 {
     if (srv_ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     srv_ctx-&gt;sendUnprotectedErrors = val != 0;
@@ -119,7 +119,7 @@ int OSSL_CMP_SRV_CTX_set_send_unprotected_errors(OSSL_CMP_SRV_CTX *srv_ctx,
 int OSSL_CMP_SRV_CTX_set_accept_unprotected(OSSL_CMP_SRV_CTX *srv_ctx, int val)
 {
     if (srv_ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     srv_ctx-&gt;acceptUnprotected = val != 0;
@@ -129,7 +129,7 @@ int OSSL_CMP_SRV_CTX_set_accept_unprotected(OSSL_CMP_SRV_CTX *srv_ctx, int val)
 int OSSL_CMP_SRV_CTX_set_accept_raverified(OSSL_CMP_SRV_CTX *srv_ctx, int val)
 {
     if (srv_ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     srv_ctx-&gt;acceptRAVerified = val != 0;
@@ -140,7 +140,7 @@ int OSSL_CMP_SRV_CTX_set_grant_implicit_confirm(OSSL_CMP_SRV_CTX *srv_ctx,
                                                 int val)
 {
     if (srv_ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     srv_ctx-&gt;grantImplicitConfirm = val != 0;
@@ -179,7 +179,7 @@ static OSSL_CMP_MSG *process_cert_request(OSSL_CMP_SRV_CTX *srv_ctx,
         bodytype = OSSL_CMP_PKIBODY_KUP;
         break;
     default:
-        CMPerr(0, CMP_R_UNEXPECTED_PKIBODY);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKIBODY);
         return NULL;
     }
 
@@ -190,12 +190,12 @@ static OSSL_CMP_MSG *process_cert_request(OSSL_CMP_SRV_CTX *srv_ctx,
         OSSL_CRMF_MSGS *reqs = req-&gt;body-&gt;value.ir; /* same for cr and kur */
 
         if (sk_OSSL_CRMF_MSG_num(reqs) != 1) { /* TODO: handle case &gt; 1 */
-            CMPerr(0, CMP_R_MULTIPLE_REQUESTS_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_CMP, CMP_R_MULTIPLE_REQUESTS_NOT_SUPPORTED);
             return NULL;
         }
 
         if ((crm = sk_OSSL_CRMF_MSG_value(reqs, OSSL_CMP_CERTREQID)) == NULL) {
-            CMPerr(0, CMP_R_CERTREQMSG_NOT_FOUND);
+            ERR_raise(ERR_LIB_CMP, CMP_R_CERTREQMSG_NOT_FOUND);
             return NULL;
         }
         certReqId = OSSL_CRMF_MSG_get_certReqId(crm);
@@ -233,7 +233,7 @@ static OSSL_CMP_MSG *process_cert_request(OSSL_CMP_SRV_CTX *srv_ctx,
      * in case OSSL_CRMF_POPO_KEYENC, set encrypted
      */
     if (msg == NULL)
-        CMPerr(0, CMP_R_ERROR_CREATING_CERTREP);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_CERTREP);
 
  err:
     OSSL_CMP_PKISI_free(si);
@@ -259,13 +259,13 @@ static OSSL_CMP_MSG *process_rr(OSSL_CMP_SRV_CTX *srv_ctx,
 
     if (sk_OSSL_CMP_REVDETAILS_num(req-&gt;body-&gt;value.rr) != 1) {
         /* TODO: handle multiple elements if multiple requests have been sent */
-        CMPerr(0, CMP_R_MULTIPLE_REQUESTS_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_CMP, CMP_R_MULTIPLE_REQUESTS_NOT_SUPPORTED);
         return NULL;
     }
 
     if ((details = sk_OSSL_CMP_REVDETAILS_value(req-&gt;body-&gt;value.rr,
                                                 OSSL_CMP_REVREQSID)) == NULL) {
-        CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
         return NULL;
     }
 
@@ -280,7 +280,7 @@ static OSSL_CMP_MSG *process_rr(OSSL_CMP_SRV_CTX *srv_ctx,
 
     if ((msg = ossl_cmp_rp_new(srv_ctx-&gt;ctx, si, certId,
                                srv_ctx-&gt;sendUnprotectedErrors)) == NULL)
-        CMPerr(0, CMP_R_ERROR_CREATING_RR);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_RR);
 
  err:
     OSSL_CRMF_CERTID_free(certId);
@@ -322,7 +322,7 @@ static OSSL_CMP_MSG *process_error(OSSL_CMP_SRV_CTX *srv_ctx,
                            errorContent-&gt;errorCode, errorContent-&gt;errorDetails);
 
     if ((msg = ossl_cmp_pkiconf_new(srv_ctx-&gt;ctx)) == NULL)
-        CMPerr(0, CMP_R_ERROR_CREATING_PKICONF);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_PKICONF);
     return msg;
 }
 
@@ -343,7 +343,7 @@ static OSSL_CMP_MSG *process_certConf(OSSL_CMP_SRV_CTX *srv_ctx,
     num = sk_OSSL_CMP_CERTSTATUS_num(ccc);
 
     if (OSSL_CMP_CTX_get_option(ctx, OSSL_CMP_OPT_IMPLICIT_CONFIRM) == 1) {
-        CMPerr(0, CMP_R_ERROR_UNEXPECTED_CERTCONF);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_UNEXPECTED_CERTCONF);
         return NULL;
     }
 
@@ -375,7 +375,7 @@ static OSSL_CMP_MSG *process_certConf(OSSL_CMP_SRV_CTX *srv_ctx,
     }
 
     if ((msg = ossl_cmp_pkiconf_new(ctx)) == NULL)
-        CMPerr(0, CMP_R_ERROR_CREATING_PKICONF);
+        ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_PKICONF);
     return msg;
 }
 
@@ -394,7 +394,7 @@ static OSSL_CMP_MSG *process_pollReq(OSSL_CMP_SRV_CTX *srv_ctx,
 
     prc = req-&gt;body-&gt;value.pollReq;
     if (sk_OSSL_CMP_POLLREQ_num(prc) != 1) { /* TODO: handle case &gt; 1 */
-        CMPerr(0, CMP_R_MULTIPLE_REQUESTS_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_CMP, CMP_R_MULTIPLE_REQUESTS_NOT_SUPPORTED);
         return NULL;
     }
 
@@ -410,7 +410,7 @@ static OSSL_CMP_MSG *process_pollReq(OSSL_CMP_SRV_CTX *srv_ctx,
     } else {
         if ((msg = ossl_cmp_pollRep_new(srv_ctx-&gt;ctx, certReqId,
                                         check_after)) == NULL)
-            CMPerr(0, CMP_R_ERROR_CREATING_POLLREP);
+            ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_CREATING_POLLREP);
     }
     return msg;
 }
@@ -456,7 +456,7 @@ OSSL_CMP_MSG *OSSL_CMP_SRV_process_request(OSSL_CMP_SRV_CTX *srv_ctx,
     if (srv_ctx == NULL || srv_ctx-&gt;ctx == NULL
             || req == NULL || req-&gt;body == NULL
             || (hdr = OSSL_CMP_MSG_get0_header(req)) == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     ctx = srv_ctx-&gt;ctx;
@@ -467,7 +467,7 @@ OSSL_CMP_MSG *OSSL_CMP_SRV_process_request(OSSL_CMP_SRV_CTX *srv_ctx,
      * order to be able to send an error message as far as needed and possible.
      */
     if (hdr-&gt;sender-&gt;type != GEN_DIRNAME) {
-        CMPerr(0, CMP_R_SENDER_GENERALNAME_TYPE_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_CMP, CMP_R_SENDER_GENERALNAME_TYPE_NOT_SUPPORTED);
         goto err;
     }
     if (!OSSL_CMP_CTX_set1_recipient(ctx, hdr-&gt;sender-&gt;d.directoryName))
@@ -502,7 +502,7 @@ OSSL_CMP_MSG *OSSL_CMP_SRV_process_request(OSSL_CMP_SRV_CTX *srv_ctx,
         /* transactionID should be already initialized */
         if (ctx-&gt;transactionID == NULL) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-            CMPerr(0, CMP_R_UNEXPECTED_PKIBODY);
+            ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKIBODY);
             goto err;
 #endif
         }
@@ -522,43 +522,43 @@ OSSL_CMP_MSG *OSSL_CMP_SRV_process_request(OSSL_CMP_SRV_CTX *srv_ctx,
     case OSSL_CMP_PKIBODY_P10CR:
     case OSSL_CMP_PKIBODY_KUR:
         if (srv_ctx-&gt;process_cert_request == NULL)
-            CMPerr(0, CMP_R_UNEXPECTED_PKIBODY);
+            ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKIBODY);
         else
             rsp = process_cert_request(srv_ctx, req);
         break;
     case OSSL_CMP_PKIBODY_RR:
         if (srv_ctx-&gt;process_rr == NULL)
-            CMPerr(0, CMP_R_UNEXPECTED_PKIBODY);
+            ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKIBODY);
         else
             rsp = process_rr(srv_ctx, req);
         break;
     case OSSL_CMP_PKIBODY_GENM:
         if (srv_ctx-&gt;process_genm == NULL)
-            CMPerr(0, CMP_R_UNEXPECTED_PKIBODY);
+            ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKIBODY);
         else
             rsp = process_genm(srv_ctx, req);
         break;
     case OSSL_CMP_PKIBODY_ERROR:
         if (srv_ctx-&gt;process_error == NULL)
-            CMPerr(0, CMP_R_UNEXPECTED_PKIBODY);
+            ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKIBODY);
         else
             rsp = process_error(srv_ctx, req);
         break;
     case OSSL_CMP_PKIBODY_CERTCONF:
         if (srv_ctx-&gt;process_certConf == NULL)
-            CMPerr(0, CMP_R_UNEXPECTED_PKIBODY);
+            ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKIBODY);
         else
             rsp = process_certConf(srv_ctx, req);
         break;
     case OSSL_CMP_PKIBODY_POLLREQ:
         if (srv_ctx-&gt;process_pollReq == NULL)
-            CMPerr(0, CMP_R_UNEXPECTED_PKIBODY);
+            ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKIBODY);
         else
             rsp = process_pollReq(srv_ctx, req);
         break;
     default:
         /* TODO possibly support further request message types */
-        CMPerr(0, CMP_R_UNEXPECTED_PKIBODY);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PKIBODY);
         break;
     }
 
@@ -628,12 +628,12 @@ OSSL_CMP_MSG * OSSL_CMP_CTX_server_perform(OSSL_CMP_CTX *client_ctx,
     OSSL_CMP_SRV_CTX *srv_ctx = NULL;
 
     if (client_ctx == NULL || req == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
     if ((srv_ctx = OSSL_CMP_CTX_get_transfer_cb_arg(client_ctx)) == NULL) {
-        CMPerr(0, CMP_R_TRANSFER_ERROR);
+        ERR_raise(ERR_LIB_CMP, CMP_R_TRANSFER_ERROR);
         return 0;
     }
 
diff --git a/crypto/cmp/cmp_status.c b/crypto/cmp/cmp_status.c
index c9809c5a3a..dc14f754de 100644
--- a/crypto/cmp/cmp_status.c
+++ b/crypto/cmp/cmp_status.c
@@ -53,13 +53,9 @@ const char *ossl_cmp_PKIStatus_to_string(int status)
     case OSSL_CMP_PKISTATUS_keyUpdateWarning:
         return &quot;PKIStatus: key update warning - update already done for the cert&quot;;
     default:
-        {
-            char buf[40];
-            BIO_snprintf(buf, sizeof(buf), &quot;PKIStatus: invalid=%d&quot;, status);
-            CMPerr(0, CMP_R_ERROR_PARSING_PKISTATUS);
-            ERR_add_error_data(1, buf);
-            return NULL;
-        }
+        ERR_raise_data(ERR_LIB_CMP, CMP_R_ERROR_PARSING_PKISTATUS,
+                       &quot;PKIStatus: invalid=%d&quot;, status);
+        return NULL;
     }
 }
 
@@ -154,7 +150,7 @@ int ossl_cmp_pkisi_check_pkifailureinfo(const OSSL_CMP_PKISI *si, int bit_index)
     if (!ossl_assert(si != NULL &amp;&amp; si-&gt;failInfo != NULL))
         return -1;
     if (bit_index &lt; 0 || bit_index &gt; OSSL_CMP_PKIFAILUREINFO_MAX) {
-        CMPerr(0, CMP_R_INVALID_ARGS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
         return -1;
     }
 
@@ -240,7 +236,7 @@ char *OSSL_CMP_snprint_PKIStatusInfo(const OSSL_CMP_PKISI *statusInfo,
     int failure_info;
 
     if (statusInfo == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
 
@@ -255,7 +251,7 @@ char *OSSL_CMP_CTX_snprint_PKIStatus(const OSSL_CMP_CTX *ctx, char *buf,
                                      size_t bufsize)
 {
     if (ctx == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return NULL;
     }
 
diff --git a/crypto/cmp/cmp_util.c b/crypto/cmp/cmp_util.c
index 9a2eecd998..4f9714a64a 100644
--- a/crypto/cmp/cmp_util.c
+++ b/crypto/cmp/cmp_util.c
@@ -29,7 +29,7 @@ int OSSL_CMP_log_open(void) /* is designed to be idempotent */
         return 1;
     BIO_free(bio);
 #endif
-    CMPerr(0, CMP_R_NO_STDIO);
+    ERR_raise(ERR_LIB_CMP, CMP_R_NO_STDIO);
     return 0;
 }
 
@@ -171,7 +171,7 @@ void OSSL_CMP_print_errors_cb(OSSL_CMP_log_cb_t log_fn)
                 BIO_free(bio);
             }
 #else
-            /* CMPerr(0, CMP_R_NO_STDIO) makes no sense during error printing */
+            /* ERR_raise(ERR_LIB_CMP, CMP_R_NO_STDIO) makes no sense during error printing */
 #endif
         } else {
             if (log_fn(component, file, line, OSSL_CMP_LOG_ERR, msg) &lt;= 0)
@@ -186,7 +186,7 @@ int ossl_cmp_X509_STORE_add1_certs(X509_STORE *store, STACK_OF(X509) *certs,
     int i;
 
     if (store == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (certs == NULL)
@@ -226,7 +226,7 @@ STACK_OF(X509)
     X509_STORE_CTX *csc = NULL;
 
     if (ts == NULL || cert == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         goto err;
     }
 
@@ -289,7 +289,7 @@ int ossl_cmp_asn1_octet_string_set1(ASN1_OCTET_STRING **tgt,
 {
     ASN1_OCTET_STRING *new;
     if (tgt == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (*tgt == src) /* self-assignment */
@@ -313,7 +313,7 @@ int ossl_cmp_asn1_octet_string_set1_bytes(ASN1_OCTET_STRING **tgt,
     ASN1_OCTET_STRING *new = NULL;
 
     if (tgt == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
     if (bytes != NULL) {
diff --git a/crypto/cmp/cmp_vfy.c b/crypto/cmp/cmp_vfy.c
index f9981c2330..8b6e856d1a 100644
--- a/crypto/cmp/cmp_vfy.c
+++ b/crypto/cmp/cmp_vfy.c
@@ -37,13 +37,13 @@ static int verify_signature(const OSSL_CMP_CTX *cmp_ctx,
     /* verify that keyUsage, if present, contains digitalSignature */
     if (!cmp_ctx-&gt;ignore_keyusage
             &amp;&amp; (X509_get_key_usage(cert) &amp; X509v3_KU_DIGITAL_SIGNATURE) == 0) {
-        CMPerr(0, CMP_R_MISSING_KEY_USAGE_DIGITALSIGNATURE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_KEY_USAGE_DIGITALSIGNATURE);
         goto sig_err;
     }
 
     pubkey = X509_get_pubkey(cert);
     if (pubkey == NULL) {
-        CMPerr(0, CMP_R_FAILED_EXTRACTING_PUBKEY);
+        ERR_raise(ERR_LIB_CMP, CMP_R_FAILED_EXTRACTING_PUBKEY);
         goto sig_err;
     }
 
@@ -60,7 +60,7 @@ static int verify_signature(const OSSL_CMP_CTX *cmp_ctx,
 
  sig_err:
     res = x509_print_ex_brief(bio, cert, X509_FLAG_NO_EXTENSIONS);
-    CMPerr(0, CMP_R_ERROR_VALIDATING_SIGNATURE);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_VALIDATING_SIGNATURE);
     if (res)
         ERR_add_error_mem_bio(&quot;\n&quot;, bio);
     res = 0;
@@ -89,7 +89,7 @@ static int verify_PBMAC(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg)
                              protection-&gt;length) == 0;
     ASN1_BIT_STRING_free(protection);
     if (!valid)
-        CMPerr(0, CMP_R_WRONG_PBM_VALUE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_WRONG_PBM_VALUE);
 
     return valid;
 }
@@ -109,12 +109,12 @@ int OSSL_CMP_validate_cert_path(const OSSL_CMP_CTX *ctx,
     int err;
 
     if (ctx == NULL || cert == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
     if (trusted_store == NULL) {
-        CMPerr(0, CMP_R_MISSING_TRUST_STORE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_TRUST_STORE);
         return 0;
     }
 
@@ -128,7 +128,7 @@ int OSSL_CMP_validate_cert_path(const OSSL_CMP_CTX *ctx,
     /* make sure suitable error is queued even if callback did not do */
     err = ERR_peek_last_error();
     if (!valid &amp;&amp; ERR_GET_REASON(err) != CMP_R_POTENTIALLY_INVALID_CERTIFICATE)
-        CMPerr(0, CMP_R_POTENTIALLY_INVALID_CERTIFICATE);
+        ERR_raise(ERR_LIB_CMP, CMP_R_POTENTIALLY_INVALID_CERTIFICATE);
 
  err:
     /* directly output any fresh errors, needed for check_msg_find_cert() */
@@ -458,7 +458,7 @@ static int check_msg_find_cert(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg)
     if (sender == NULL || msg-&gt;body == NULL)
         return 0; /* other NULL cases already have been checked */
     if (sender-&gt;type != GEN_DIRNAME) {
-        CMPerr(0, CMP_R_SENDER_GENERALNAME_TYPE_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_CMP, CMP_R_SENDER_GENERALNAME_TYPE_NOT_SUPPORTED);
         return 0;
     }
 
@@ -514,7 +514,7 @@ static int check_msg_find_cert(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg)
         (void)check_msg_all_certs(ctx, msg, 1 /* 3gpp */);
     }
 
-    CMPerr(0, CMP_R_NO_SUITABLE_SENDER_CERT);
+    ERR_raise(ERR_LIB_CMP, CMP_R_NO_SUITABLE_SENDER_CERT);
     if (sname != NULL) {
         ERR_add_error_txt(NULL, &quot;for msg sender name = &quot;);
         ERR_add_error_txt(NULL, sname);
@@ -553,13 +553,13 @@ int OSSL_CMP_validate_msg(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg)
     ossl_cmp_debug(ctx, &quot;validating CMP message&quot;);
     if (ctx == NULL || msg == NULL
             || msg-&gt;header == NULL || msg-&gt;body == NULL) {
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         return 0;
     }
 
     if (msg-&gt;header-&gt;protectionAlg == NULL /* unprotected message */
             || msg-&gt;protection == NULL || msg-&gt;protection-&gt;data == NULL) {
-        CMPerr(0, CMP_R_MISSING_PROTECTION);
+        ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_PROTECTION);
         return 0;
     }
 
@@ -608,7 +608,7 @@ int OSSL_CMP_validate_msg(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg)
          * Not yet supported
          */
     case NID_id_DHBasedMac:
-        CMPerr(0, CMP_R_UNSUPPORTED_PROTECTION_ALG_DHBASEDMAC);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNSUPPORTED_PROTECTION_ALG_DHBASEDMAC);
         break;
 
         /*
@@ -632,7 +632,7 @@ int OSSL_CMP_validate_msg(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg)
                 return 1;
             }
             ossl_cmp_warn(ctx, &quot;CMP message signature verification failed&quot;);
-            CMPerr(0, CMP_R_SRVCERT_DOES_NOT_VALIDATE_MSG);
+            ERR_raise(ERR_LIB_CMP, CMP_R_SRVCERT_DOES_NOT_VALIDATE_MSG);
         }
         break;
     }
@@ -672,7 +672,7 @@ int ossl_cmp_msg_check_update(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg,
 
     /* validate sender name of received msg */
     if (hdr-&gt;sender-&gt;type != GEN_DIRNAME) {
-        CMPerr(0, CMP_R_SENDER_GENERALNAME_TYPE_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_CMP, CMP_R_SENDER_GENERALNAME_TYPE_NOT_SUPPORTED);
         return 0; /* TODO FR#42: support for more than X509_NAME */
     }
     /*
@@ -711,7 +711,7 @@ int ossl_cmp_msg_check_update(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg,
         if (!OSSL_CMP_validate_msg(ctx, msg)
                 &amp;&amp; (cb == NULL || (*cb)(ctx, msg, 1, cb_arg) &lt;= 0)) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-            CMPerr(0, CMP_R_ERROR_VALIDATING_PROTECTION);
+            ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_VALIDATING_PROTECTION);
             return 0;
 #endif
         }
@@ -719,7 +719,7 @@ int ossl_cmp_msg_check_update(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg,
         /* detect explicitly permitted exceptions for missing protection */
         if (cb == NULL || (*cb)(ctx, msg, 0, cb_arg) &lt;= 0) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-            CMPerr(0, CMP_R_MISSING_PROTECTION);
+            ERR_raise(ERR_LIB_CMP, CMP_R_MISSING_PROTECTION);
             return 0;
 #endif
         }
@@ -728,14 +728,14 @@ int ossl_cmp_msg_check_update(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg,
     /* check CMP version number in header */
     if (ossl_cmp_hdr_get_pvno(hdr) != OSSL_CMP_PVNO) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-        CMPerr(0, CMP_R_UNEXPECTED_PVNO);
+        ERR_raise(ERR_LIB_CMP, CMP_R_UNEXPECTED_PVNO);
         return 0;
 #endif
     }
 
     if (ossl_cmp_msg_get_bodytype(msg) &lt; 0) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-        CMPerr(0, CMP_R_PKIBODY_ERROR);
+        ERR_raise(ERR_LIB_CMP, CMP_R_PKIBODY_ERROR);
         return 0;
 #endif
     }
@@ -746,7 +746,7 @@ int ossl_cmp_msg_check_update(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg,
                 || ASN1_OCTET_STRING_cmp(ctx-&gt;transactionID,
                                          hdr-&gt;transactionID) != 0)) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-        CMPerr(0, CMP_R_TRANSACTIONID_UNMATCHED);
+        ERR_raise(ERR_LIB_CMP, CMP_R_TRANSACTIONID_UNMATCHED);
         return 0;
 #endif
     }
@@ -757,7 +757,7 @@ int ossl_cmp_msg_check_update(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *msg,
                 || ASN1_OCTET_STRING_cmp(ctx-&gt;senderNonce,
                                          hdr-&gt;recipNonce) != 0)) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-        CMPerr(0, CMP_R_RECIPNONCE_UNMATCHED);
+        ERR_raise(ERR_LIB_CMP, CMP_R_RECIPNONCE_UNMATCHED);
         return 0;
 #endif
     }
@@ -828,7 +828,7 @@ int ossl_cmp_verify_popo(const OSSL_CMP_CTX *ctx,
             if (X509_REQ_verify_ex(req, X509_REQ_get0_pubkey(req), ctx-&gt;libctx,
                                    ctx-&gt;propq) &lt;= 0) {
 #ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-                CMPerr(0, CMP_R_REQUEST_NOT_ACCEPTED);
+                ERR_raise(ERR_LIB_CMP, CMP_R_REQUEST_NOT_ACCEPTED);
                 return 0;
 #endif
             }
@@ -846,7 +846,7 @@ int ossl_cmp_verify_popo(const OSSL_CMP_CTX *ctx,
         }
         break;
     default:
-        CMPerr(0, CMP_R_PKIBODY_ERROR);
+        ERR_raise(ERR_LIB_CMP, CMP_R_PKIBODY_ERROR);
         return 0;
     }
     return 1;
diff --git a/crypto/cms/cms_att.c b/crypto/cms/cms_att.c
index 2c8138f13e..91e8f75db7 100644
--- a/crypto/cms/cms_att.c
+++ b/crypto/cms/cms_att.c
@@ -276,7 +276,7 @@ int CMS_si_check_attributes(const CMS_SignerInfo *si)
                                  si-&gt;signedAttrs, have_signed_attrs)
             || !cms_check_attribute(nid, flags, CMS_ATTR_F_UNSIGNED,
                                     si-&gt;unsignedAttrs, have_unsigned_attrs)) {
-            CMSerr(CMS_F_CMS_SI_CHECK_ATTRIBUTES, CMS_R_ATTRIBUTE_ERROR);
+            ERR_raise(ERR_LIB_CMS, CMS_R_ATTRIBUTE_ERROR);
             return 0;
         }
     }
diff --git a/crypto/cms/cms_cd.c b/crypto/cms/cms_cd.c
index c806a472d5..c781268659 100644
--- a/crypto/cms/cms_cd.c
+++ b/crypto/cms/cms_cd.c
@@ -32,8 +32,7 @@ CMS_ContentInfo *cms_CompressedData_create(int comp_nid, OSSL_LIB_CTX *libctx,
      * compression algorithm or parameters have some meaning...
      */
     if (comp_nid != NID_zlib_compression) {
-        CMSerr(CMS_F_CMS_COMPRESSEDDATA_CREATE,
-               CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
         return NULL;
     }
     cms = CMS_ContentInfo_new_ex(libctx, propq);
@@ -68,15 +67,13 @@ BIO *cms_CompressedData_init_bio(const CMS_ContentInfo *cms)
     const ASN1_OBJECT *compoid;
 
     if (OBJ_obj2nid(cms-&gt;contentType) != NID_id_smime_ct_compressedData) {
-        CMSerr(CMS_F_CMS_COMPRESSEDDATA_INIT_BIO,
-               CMS_R_CONTENT_TYPE_NOT_COMPRESSED_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CONTENT_TYPE_NOT_COMPRESSED_DATA);
         return NULL;
     }
     cd = cms-&gt;d.compressedData;
     X509_ALGOR_get0(&amp;compoid, NULL, NULL, cd-&gt;compressionAlgorithm);
     if (OBJ_obj2nid(compoid) != NID_zlib_compression) {
-        CMSerr(CMS_F_CMS_COMPRESSEDDATA_INIT_BIO,
-               CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
         return NULL;
     }
     return BIO_new(BIO_f_zlib());
diff --git a/crypto/cms/cms_dd.c b/crypto/cms/cms_dd.c
index 0353c2276f..4eba827d62 100644
--- a/crypto/cms/cms_dd.c
+++ b/crypto/cms/cms_dd.c
@@ -64,7 +64,7 @@ int cms_DigestedData_do_final(const CMS_ContentInfo *cms, BIO *chain, int verify
     CMS_DigestedData *dd;
 
     if (mctx == NULL) {
-        CMSerr(CMS_F_CMS_DIGESTEDDATA_DO_FINAL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -78,14 +78,12 @@ int cms_DigestedData_do_final(const CMS_ContentInfo *cms, BIO *chain, int verify
 
     if (verify) {
         if (mdlen != (unsigned int)dd-&gt;digest-&gt;length) {
-            CMSerr(CMS_F_CMS_DIGESTEDDATA_DO_FINAL,
-                   CMS_R_MESSAGEDIGEST_WRONG_LENGTH);
+            ERR_raise(ERR_LIB_CMS, CMS_R_MESSAGEDIGEST_WRONG_LENGTH);
             goto err;
         }
 
         if (memcmp(md, dd-&gt;digest-&gt;data, mdlen))
-            CMSerr(CMS_F_CMS_DIGESTEDDATA_DO_FINAL,
-                   CMS_R_VERIFICATION_FAILURE);
+            ERR_raise(ERR_LIB_CMS, CMS_R_VERIFICATION_FAILURE);
         else
             r = 1;
     } else {
diff --git a/crypto/cms/cms_dh.c b/crypto/cms/cms_dh.c
index 2c64f50259..90b439dd35 100644
--- a/crypto/cms/cms_dh.c
+++ b/crypto/cms/cms_dh.c
@@ -77,7 +77,7 @@ static int dh_cms_set_shared_info(EVP_PKEY_CTX *pctx, CMS_RecipientInfo *ri)
      * we will need something cleverer.
      */
     if (OBJ_obj2nid(alg-&gt;algorithm) != NID_id_smime_alg_ESDH) {
-        CMSerr(0, CMS_R_KDF_PARAMETER_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_KDF_PARAMETER_ERROR);
         goto err;
     }
 
@@ -148,13 +148,13 @@ static int dh_cms_decrypt(CMS_RecipientInfo *ri)
         if (alg ==  NULL || pubkey == NULL)
             return 0;
         if (!dh_cms_set_peerkey(pctx, alg, pubkey)) {
-            DHerr(DH_F_DH_CMS_DECRYPT, DH_R_PEER_KEY_ERROR);
+            ERR_raise(ERR_LIB_DH, DH_R_PEER_KEY_ERROR);
             return 0;
         }
     }
     /* Set DH derivation parameters and initialise unwrap context */
     if (!dh_cms_set_shared_info(pctx, ri)) {
-        DHerr(DH_F_DH_CMS_DECRYPT, DH_R_SHARED_INFO_ERROR);
+        ERR_raise(ERR_LIB_DH, DH_R_SHARED_INFO_ERROR);
         return 0;
     }
     return 1;
@@ -311,6 +311,6 @@ int cms_dh_envelope(CMS_RecipientInfo *ri, int decrypt)
     if (decrypt == 0)
         return dh_cms_encrypt(ri);
 
-    CMSerr(0, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+    ERR_raise(ERR_LIB_CMS, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
     return 0;
 }
diff --git a/crypto/cms/cms_ec.c b/crypto/cms/cms_ec.c
index 5dac7f0683..8cb41dfdef 100644
--- a/crypto/cms/cms_ec.c
+++ b/crypto/cms/cms_ec.c
@@ -46,13 +46,13 @@ static EVP_PKEY *pkey_type2param(int ptype, const void *pval,
         groupname = OBJ_nid2sn(OBJ_obj2nid(poid));
         if (groupname == NULL
                 || !EVP_PKEY_CTX_set_group_name(pctx, groupname)) {
-            CMSerr(0, CMS_R_DECODE_ERROR);
+            ERR_raise(ERR_LIB_CMS, CMS_R_DECODE_ERROR);
             goto err;
         }
         if (EVP_PKEY_paramgen(pctx, &amp;pkey) &lt;= 0)
             goto err;
     } else {
-        CMSerr(0, CMS_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_DECODE_ERROR);
         goto err;
     }
 
@@ -166,7 +166,7 @@ static int ecdh_cms_set_shared_info(EVP_PKEY_CTX *pctx, CMS_RecipientInfo *ri)
         return 0;
 
     if (!ecdh_cms_set_kdf_param(pctx, OBJ_obj2nid(alg-&gt;algorithm))) {
-        CMSerr(0, CMS_R_KDF_PARAMETER_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_KDF_PARAMETER_ERROR);
         return 0;
     }
 
@@ -229,13 +229,13 @@ static int ecdh_cms_decrypt(CMS_RecipientInfo *ri)
         if (alg == NULL || pubkey == NULL)
             return 0;
         if (!ecdh_cms_set_peerkey(pctx, alg, pubkey)) {
-            CMSerr(0, CMS_R_PEER_KEY_ERROR);
+            ERR_raise(ERR_LIB_CMS, CMS_R_PEER_KEY_ERROR);
             return 0;
         }
     }
     /* Set ECDH derivation parameters and initialise unwrap context */
     if (!ecdh_cms_set_shared_info(pctx, ri)) {
-        CMSerr(0, CMS_R_SHARED_INFO_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_SHARED_INFO_ERROR);
         return 0;
     }
     return 1;
@@ -381,7 +381,7 @@ int cms_ecdh_envelope(CMS_RecipientInfo *ri, int decrypt)
     if (decrypt == 0)
         return ecdh_cms_encrypt(ri);
 
-    CMSerr(0, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+    ERR_raise(ERR_LIB_CMS, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
     return 0;
 }
 #endif
diff --git a/crypto/cms/cms_enc.c b/crypto/cms/cms_enc.c
index ef87fac8ef..0069bde939 100644
--- a/crypto/cms/cms_enc.c
+++ b/crypto/cms/cms_enc.c
@@ -42,7 +42,7 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
 
     b = BIO_new(BIO_f_cipher());
     if (b == NULL) {
-        CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -67,14 +67,13 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
     }
     if (cipher == NULL) {
         (void)ERR_clear_last_mark();
-        CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO, CMS_R_UNKNOWN_CIPHER);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNKNOWN_CIPHER);
         goto err;
     }
     (void)ERR_pop_to_mark();
 
     if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, enc) &lt;= 0) {
-        CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
-               CMS_R_CIPHER_INITIALISATION_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CIPHER_INITIALISATION_ERROR);
         goto err;
     }
 
@@ -89,7 +88,7 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
         }
     } else {
         if (evp_cipher_asn1_to_param_ex(ctx, calg-&gt;parameter, &amp;aparams) &lt;= 0) {
-            CMSerr(0, CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
+            ERR_raise(ERR_LIB_CMS, CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
             goto err;
         }
         if ((EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)) {
@@ -97,7 +96,7 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
             if (ec-&gt;taglen &gt; 0
                     &amp;&amp; EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,
                                            ec-&gt;taglen, ec-&gt;tag) &lt;= 0) {
-                CMSerr(0, CMS_R_CIPHER_AEAD_SET_TAG_ERROR);
+                ERR_raise(ERR_LIB_CMS, CMS_R_CIPHER_AEAD_SET_TAG_ERROR);
                 goto err;
             }
         }
@@ -111,7 +110,7 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
     if (!enc || !ec-&gt;key) {
         tkey = OPENSSL_malloc(tkeylen);
         if (tkey == NULL) {
-            CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (EVP_CIPHER_CTX_rand_key(ctx, tkey) &lt;= 0)
@@ -137,8 +136,7 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
              * which may be useful in MMA.
              */
             if (enc || ec-&gt;debug) {
-                CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
-                       CMS_R_INVALID_KEY_LENGTH);
+                ERR_raise(ERR_LIB_CMS, CMS_R_INVALID_KEY_LENGTH);
                 goto err;
             } else {
                 /* Use random key */
@@ -152,14 +150,13 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
     }
 
     if (EVP_CipherInit_ex(ctx, NULL, NULL, ec-&gt;key, piv, enc) &lt;= 0) {
-        CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
-               CMS_R_CIPHER_INITIALISATION_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CIPHER_INITIALISATION_ERROR);
         goto err;
     }
     if (enc) {
         calg-&gt;parameter = ASN1_TYPE_new();
         if (calg-&gt;parameter == NULL) {
-            CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if ((EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)) {
@@ -171,8 +168,7 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
         }
 
         if (evp_cipher_param_to_asn1_ex(ctx, calg-&gt;parameter, &amp;aparams) &lt;= 0) {
-            CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
-                   CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
+            ERR_raise(ERR_LIB_CMS, CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
             goto err;
         }
         /* If parameter type not set omit parameter */
@@ -204,7 +200,7 @@ int cms_EncryptedContent_init(CMS_EncryptedContentInfo *ec,
     ec-&gt;cipher = cipher;
     if (key) {
         if ((ec-&gt;key = OPENSSL_malloc(keylen)) == NULL) {
-            CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         memcpy(ec-&gt;key, key, keylen);
@@ -221,19 +217,19 @@ int CMS_EncryptedData_set1_key(CMS_ContentInfo *cms, const EVP_CIPHER *ciph,
     CMS_EncryptedContentInfo *ec;
 
     if (!key || !keylen) {
-        CMSerr(CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY, CMS_R_NO_KEY);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_KEY);
         return 0;
     }
     if (ciph) {
         cms-&gt;d.encryptedData = M_ASN1_new_of(CMS_EncryptedData);
         if (!cms-&gt;d.encryptedData) {
-            CMSerr(CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         cms-&gt;contentType = OBJ_nid2obj(NID_pkcs7_encrypted);
         cms-&gt;d.encryptedData-&gt;version = 0;
     } else if (OBJ_obj2nid(cms-&gt;contentType) != NID_pkcs7_encrypted) {
-        CMSerr(CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY, CMS_R_NOT_ENCRYPTED_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_ENCRYPTED_DATA);
         return 0;
     }
     ec = cms-&gt;d.encryptedData-&gt;encryptedContentInfo;
diff --git a/crypto/cms/cms_env.c b/crypto/cms/cms_env.c
index 83826beb51..cedabe1f3c 100644
--- a/crypto/cms/cms_env.c
+++ b/crypto/cms/cms_env.c
@@ -37,7 +37,7 @@ static int cms_get_enveloped_type(const CMS_ContentInfo *cms)
         return CMS_ENVELOPED_AUTH;
 
     default:
-        CMSerr(0, CMS_R_CONTENT_TYPE_NOT_ENVELOPED_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CONTENT_TYPE_NOT_ENVELOPED_DATA);
         return 0;
     }
 }
@@ -45,8 +45,7 @@ static int cms_get_enveloped_type(const CMS_ContentInfo *cms)
 CMS_EnvelopedData *cms_get0_enveloped(CMS_ContentInfo *cms)
 {
     if (OBJ_obj2nid(cms-&gt;contentType) != NID_pkcs7_enveloped) {
-        CMSerr(CMS_F_CMS_GET0_ENVELOPED,
-               CMS_R_CONTENT_TYPE_NOT_ENVELOPED_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CONTENT_TYPE_NOT_ENVELOPED_DATA);
         return NULL;
     }
     return cms-&gt;d.envelopedData;
@@ -55,7 +54,7 @@ CMS_EnvelopedData *cms_get0_enveloped(CMS_ContentInfo *cms)
 CMS_AuthEnvelopedData *cms_get0_auth_enveloped(CMS_ContentInfo *cms)
 {
     if (OBJ_obj2nid(cms-&gt;contentType) != NID_id_smime_ct_authEnvelopedData) {
-        CMSerr(0, CMS_R_CONTENT_TYPE_NOT_ENVELOPED_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CONTENT_TYPE_NOT_ENVELOPED_DATA);
         return NULL;
     }
     return cms-&gt;d.authEnvelopedData;
@@ -66,7 +65,7 @@ static CMS_EnvelopedData *cms_enveloped_data_init(CMS_ContentInfo *cms)
     if (cms-&gt;d.other == NULL) {
         cms-&gt;d.envelopedData = M_ASN1_new_of(CMS_EnvelopedData);
         if (cms-&gt;d.envelopedData == NULL) {
-            CMSerr(CMS_F_CMS_ENVELOPED_DATA_INIT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
         cms-&gt;d.envelopedData-&gt;version = 0;
@@ -85,7 +84,7 @@ cms_auth_enveloped_data_init(CMS_ContentInfo *cms)
     if (cms-&gt;d.other == NULL) {
         cms-&gt;d.authEnvelopedData = M_ASN1_new_of(CMS_AuthEnvelopedData);
         if (cms-&gt;d.authEnvelopedData == NULL) {
-            CMSerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
         /* Defined in RFC 5083 - Section 2.1. &quot;AuthEnvelopedData Type&quot; */
@@ -134,12 +133,11 @@ int cms_env_asn1_ctrl(CMS_RecipientInfo *ri, int cmd)
         return 1;
     i = pkey-&gt;ameth-&gt;pkey_ctrl(pkey, ASN1_PKEY_CTRL_CMS_ENVELOPE, cmd, ri);
     if (i == -2) {
-        CMSerr(CMS_F_CMS_ENV_ASN1_CTRL,
-               CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
         return 0;
     }
     if (i &lt;= 0) {
-        CMSerr(CMS_F_CMS_ENV_ASN1_CTRL, CMS_R_CTRL_FAILURE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CTRL_FAILURE);
         return 0;
     }
     return 1;
@@ -238,7 +236,7 @@ CMS_ContentInfo *CMS_EnvelopedData_create_ex(const EVP_CIPHER *cipher,
     return cms;
  merr:
     CMS_ContentInfo_free(cms);
-    CMSerr(0, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -266,7 +264,7 @@ CMS_AuthEnvelopedData_create_ex(const EVP_CIPHER *cipher, OSSL_LIB_CTX *libctx,
     return cms;
  merr:
     CMS_ContentInfo_free(cms);
-    CMSerr(0, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -353,7 +351,7 @@ CMS_RecipientInfo *CMS_add1_recipient(CMS_ContentInfo *cms, X509 *recip,
 
     pk = X509_get0_pubkey(recip);
     if (pk == NULL) {
-        CMSerr(CMS_F_CMS_ADD1_RECIPIENT, CMS_R_ERROR_GETTING_PUBLIC_KEY);
+        ERR_raise(ERR_LIB_CMS, CMS_R_ERROR_GETTING_PUBLIC_KEY);
         goto err;
     }
 
@@ -371,8 +369,7 @@ CMS_RecipientInfo *CMS_add1_recipient(CMS_ContentInfo *cms, X509 *recip,
         break;
 
     default:
-        CMSerr(CMS_F_CMS_ADD1_RECIPIENT,
-               CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
         goto err;
 
     }
@@ -383,7 +380,7 @@ CMS_RecipientInfo *CMS_add1_recipient(CMS_ContentInfo *cms, X509 *recip,
     return ri;
 
  merr:
-    CMSerr(CMS_F_CMS_ADD1_RECIPIENT, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
  err:
     M_ASN1_free_of(ri, CMS_RecipientInfo);
     return NULL;
@@ -402,8 +399,7 @@ int CMS_RecipientInfo_ktri_get0_algs(CMS_RecipientInfo *ri,
 {
     CMS_KeyTransRecipientInfo *ktri;
     if (ri-&gt;type != CMS_RECIPINFO_TRANS) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_ALGS,
-               CMS_R_NOT_KEY_TRANSPORT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_TRANSPORT);
         return 0;
     }
 
@@ -425,8 +421,7 @@ int CMS_RecipientInfo_ktri_get0_signer_id(CMS_RecipientInfo *ri,
 {
     CMS_KeyTransRecipientInfo *ktri;
     if (ri-&gt;type != CMS_RECIPINFO_TRANS) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_SIGNER_ID,
-               CMS_R_NOT_KEY_TRANSPORT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_TRANSPORT);
         return 0;
     }
     ktri = ri-&gt;d.ktri;
@@ -437,8 +432,7 @@ int CMS_RecipientInfo_ktri_get0_signer_id(CMS_RecipientInfo *ri,
 int CMS_RecipientInfo_ktri_cert_cmp(CMS_RecipientInfo *ri, X509 *cert)
 {
     if (ri-&gt;type != CMS_RECIPINFO_TRANS) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_CERT_CMP,
-               CMS_R_NOT_KEY_TRANSPORT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_TRANSPORT);
         return -2;
     }
     return cms_SignerIdentifier_cert_cmp(ri-&gt;d.ktri-&gt;rid, cert);
@@ -447,7 +441,7 @@ int CMS_RecipientInfo_ktri_cert_cmp(CMS_RecipientInfo *ri, X509 *cert)
 int CMS_RecipientInfo_set0_pkey(CMS_RecipientInfo *ri, EVP_PKEY *pkey)
 {
     if (ri-&gt;type != CMS_RECIPINFO_TRANS) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_SET0_PKEY, CMS_R_NOT_KEY_TRANSPORT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_TRANSPORT);
         return 0;
     }
     EVP_PKEY_free(ri-&gt;d.ktri-&gt;pkey);
@@ -470,7 +464,7 @@ static int cms_RecipientInfo_ktri_encrypt(const CMS_ContentInfo *cms,
     int ret = 0;
 
     if (ri-&gt;type != CMS_RECIPINFO_TRANS) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_ENCRYPT, CMS_R_NOT_KEY_TRANSPORT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_TRANSPORT);
         return 0;
     }
     ktri = ri-&gt;d.ktri;
@@ -492,7 +486,7 @@ static int cms_RecipientInfo_ktri_encrypt(const CMS_ContentInfo *cms,
 
     if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_ENCRYPT,
                           EVP_PKEY_CTRL_CMS_ENCRYPT, 0, ri) &lt;= 0) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_ENCRYPT, CMS_R_CTRL_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CTRL_ERROR);
         goto err;
     }
 
@@ -502,7 +496,7 @@ static int cms_RecipientInfo_ktri_encrypt(const CMS_ContentInfo *cms,
     ek = OPENSSL_malloc(eklen);
 
     if (ek == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -540,7 +534,7 @@ static int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,
     ec = cms_get0_env_enc_content(cms);
 
     if (ktri-&gt;pkey == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_NO_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_PRIVATE_KEY);
         return 0;
     }
 
@@ -558,7 +552,7 @@ static int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,
             cipher = EVP_get_cipherbyobj(calg-&gt;algorithm);
         if (cipher == NULL) {
             (void)ERR_clear_last_mark();
-            CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_UNKNOWN_CIPHER);
+            ERR_raise(ERR_LIB_CMS, CMS_R_UNKNOWN_CIPHER);
             return 0;
         }
         (void)ERR_pop_to_mark();
@@ -579,7 +573,7 @@ static int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,
 
     if (EVP_PKEY_CTX_ctrl(ktri-&gt;pctx, -1, EVP_PKEY_OP_DECRYPT,
                           EVP_PKEY_CTRL_CMS_DECRYPT, 0, ri) &lt;= 0) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CTRL_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CTRL_ERROR);
         goto err;
     }
 
@@ -590,7 +584,7 @@ static int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,
 
     ek = OPENSSL_malloc(eklen);
     if (ek == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -599,7 +593,7 @@ static int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,
                          ktri-&gt;encryptedKey-&gt;length) &lt;= 0
             || eklen == 0
             || (fixlen != 0 &amp;&amp; eklen != fixlen)) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CMS_LIB);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CMS_LIB);
         goto err;
     }
 
@@ -626,7 +620,7 @@ int CMS_RecipientInfo_kekri_id_cmp(CMS_RecipientInfo *ri,
     ASN1_OCTET_STRING tmp_os;
     CMS_KEKRecipientInfo *kekri;
     if (ri-&gt;type != CMS_RECIPINFO_KEK) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ID_CMP, CMS_R_NOT_KEK);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEK);
         return -2;
     }
     kekri = ri-&gt;d.kekri;
@@ -685,7 +679,7 @@ CMS_RecipientInfo *CMS_add0_recipient_key(CMS_ContentInfo *cms, int nid,
             break;
 
         default:
-            CMSerr(CMS_F_CMS_ADD0_RECIPIENT_KEY, CMS_R_INVALID_KEY_LENGTH);
+            ERR_raise(ERR_LIB_CMS, CMS_R_INVALID_KEY_LENGTH);
             goto err;
         }
 
@@ -694,13 +688,12 @@ CMS_RecipientInfo *CMS_add0_recipient_key(CMS_ContentInfo *cms, int nid,
         size_t exp_keylen = aes_wrap_keylen(nid);
 
         if (!exp_keylen) {
-            CMSerr(CMS_F_CMS_ADD0_RECIPIENT_KEY,
-                   CMS_R_UNSUPPORTED_KEK_ALGORITHM);
+            ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_KEK_ALGORITHM);
             goto err;
         }
 
         if (keylen != exp_keylen) {
-            CMSerr(CMS_F_CMS_ADD0_RECIPIENT_KEY, CMS_R_INVALID_KEY_LENGTH);
+            ERR_raise(ERR_LIB_CMS, CMS_R_INVALID_KEY_LENGTH);
             goto err;
         }
 
@@ -749,7 +742,7 @@ CMS_RecipientInfo *CMS_add0_recipient_key(CMS_ContentInfo *cms, int nid,
     return ri;
 
  merr:
-    CMSerr(CMS_F_CMS_ADD0_RECIPIENT_KEY, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
  err:
     M_ASN1_free_of(ri, CMS_RecipientInfo);
     return NULL;
@@ -764,7 +757,7 @@ int CMS_RecipientInfo_kekri_get0_id(CMS_RecipientInfo *ri,
 {
     CMS_KEKIdentifier *rkid;
     if (ri-&gt;type != CMS_RECIPINFO_KEK) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_GET0_ID, CMS_R_NOT_KEK);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEK);
         return 0;
     }
     rkid = ri-&gt;d.kekri-&gt;kekid;
@@ -794,7 +787,7 @@ int CMS_RecipientInfo_set0_key(CMS_RecipientInfo *ri,
 {
     CMS_KEKRecipientInfo *kekri;
     if (ri-&gt;type != CMS_RECIPINFO_KEK) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_SET0_KEY, CMS_R_NOT_KEK);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEK);
         return 0;
     }
 
@@ -847,26 +840,26 @@ static int cms_RecipientInfo_kekri_encrypt(const CMS_ContentInfo *cms,
     kekri = ri-&gt;d.kekri;
 
     if (kekri-&gt;key == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT, CMS_R_NO_KEY);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_KEY);
         return 0;
     }
 
     cipher = cms_get_key_wrap_cipher(kekri-&gt;keylen, cms_ctx);
     if (cipher == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT, CMS_R_INVALID_KEY_LENGTH);
+        ERR_raise(ERR_LIB_CMS, CMS_R_INVALID_KEY_LENGTH);
         goto err;
     }
 
     /* 8 byte prefix for AES wrap ciphers */
     wkey = OPENSSL_malloc(ec-&gt;keylen + 8);
     if (wkey == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     ctx = EVP_CIPHER_CTX_new();
     if (ctx == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -874,12 +867,12 @@ static int cms_RecipientInfo_kekri_encrypt(const CMS_ContentInfo *cms,
     if (!EVP_EncryptInit_ex(ctx, cipher, NULL, kekri-&gt;key, NULL)
             || !EVP_EncryptUpdate(ctx, wkey, &amp;wkeylen, ec-&gt;key, ec-&gt;keylen)
             || !EVP_EncryptFinal_ex(ctx, wkey + wkeylen, &amp;outlen)) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT, CMS_R_WRAP_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_WRAP_ERROR);
         goto err;
     }
     wkeylen += outlen;
     if (!ossl_assert((size_t)wkeylen == ec-&gt;keylen + 8)) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT, CMS_R_WRAP_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_WRAP_ERROR);
         goto err;
     }
 
@@ -918,40 +911,38 @@ static int cms_RecipientInfo_kekri_decrypt(CMS_ContentInfo *cms,
     kekri = ri-&gt;d.kekri;
 
     if (!kekri-&gt;key) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT, CMS_R_NO_KEY);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_KEY);
         return 0;
     }
 
     wrap_nid = OBJ_obj2nid(kekri-&gt;keyEncryptionAlgorithm-&gt;algorithm);
     if (aes_wrap_keylen(wrap_nid) != kekri-&gt;keylen) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT,
-               CMS_R_INVALID_KEY_LENGTH);
+        ERR_raise(ERR_LIB_CMS, CMS_R_INVALID_KEY_LENGTH);
         return 0;
     }
 
     /* If encrypted key length is invalid don't bother */
 
     if (kekri-&gt;encryptedKey-&gt;length &lt; 16) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT,
-               CMS_R_INVALID_ENCRYPTED_KEY_LENGTH);
+        ERR_raise(ERR_LIB_CMS, CMS_R_INVALID_ENCRYPTED_KEY_LENGTH);
         goto err;
     }
 
     cipher = cms_get_key_wrap_cipher(kekri-&gt;keylen, cms_ctx);
     if (cipher == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT, CMS_R_INVALID_KEY_LENGTH);
+        ERR_raise(ERR_LIB_CMS, CMS_R_INVALID_KEY_LENGTH);
         goto err;
     }
 
     ukey = OPENSSL_malloc(kekri-&gt;encryptedKey-&gt;length - 8);
     if (ukey == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     ctx = EVP_CIPHER_CTX_new();
     if (ctx == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -960,7 +951,7 @@ static int cms_RecipientInfo_kekri_decrypt(CMS_ContentInfo *cms,
                                   kekri-&gt;encryptedKey-&gt;data,
                                   kekri-&gt;encryptedKey-&gt;length)
             || !EVP_DecryptFinal_ex(ctx, ukey + ukeylen, &amp;outlen)) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT, CMS_R_UNWRAP_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNWRAP_ERROR);
         goto err;
     }
     ukeylen += outlen;
@@ -992,8 +983,7 @@ int CMS_RecipientInfo_decrypt(CMS_ContentInfo *cms, CMS_RecipientInfo *ri)
         return cms_RecipientInfo_pwri_crypt(cms, ri, 0);
 
     default:
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_DECRYPT,
-               CMS_R_UNSUPPORTED_RECIPIENTINFO_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_RECIPIENTINFO_TYPE);
         return 0;
     }
 }
@@ -1014,8 +1004,7 @@ int CMS_RecipientInfo_encrypt(const CMS_ContentInfo *cms, CMS_RecipientInfo *ri)
         return cms_RecipientInfo_pwri_crypt(cms, ri, 1);
 
     default:
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_ENCRYPT,
-               CMS_R_UNSUPPORTED_RECIPIENT_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_RECIPIENT_TYPE);
         return 0;
     }
 }
@@ -1152,8 +1141,7 @@ static BIO *cms_EnvelopedData_Encryption_init_bio(CMS_ContentInfo *cms)
     /* Now encrypt content key according to each RecipientInfo type */
     rinfos = env-&gt;recipientInfos;
     if (cms_env_encrypt_content_key(cms, rinfos) &lt; 0) {
-        CMSerr(CMS_F_CMS_ENVELOPEDDATA_ENCRYPTION_INIT_BIO,
-               CMS_R_ERROR_SETTING_RECIPIENTINFO);
+        ERR_raise(ERR_LIB_CMS, CMS_R_ERROR_SETTING_RECIPIENTINFO);
         goto err;
     }
 
@@ -1205,7 +1193,7 @@ BIO *cms_AuthEnvelopedData_init_bio(CMS_ContentInfo *cms)
     /* Now encrypt content key according to each RecipientInfo type */
     rinfos = aenv-&gt;recipientInfos;
     if (cms_env_encrypt_content_key(cms, rinfos) &lt; 0) {
-        CMSerr(0, CMS_R_ERROR_SETTING_RECIPIENTINFO);
+        ERR_raise(ERR_LIB_CMS, CMS_R_ERROR_SETTING_RECIPIENTINFO);
         goto err;
     }
 
@@ -1233,7 +1221,7 @@ int cms_EnvelopedData_final(CMS_ContentInfo *cms, BIO *chain)
         return 0;
 
     if (mbio == NULL) {
-        CMSerr(CMS_F_CMS_ENVELOPEDDATA_FINAL, CMS_R_CONTENT_NOT_FOUND);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CONTENT_NOT_FOUND);
         return 0;
     }
 
@@ -1248,13 +1236,13 @@ int cms_EnvelopedData_final(CMS_ContentInfo *cms, BIO *chain)
             env-&gt;unprotectedAttrs = sk_X509_ATTRIBUTE_new_null();
 
         if (env-&gt;unprotectedAttrs == NULL) {
-            CMSerr(CMS_F_CMS_ENVELOPEDDATA_FINAL, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             return 0;
         }
 
         if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_PROCESS_UNPROTECTED,
                                 1, env-&gt;unprotectedAttrs) &lt;= 0) {
-            CMSerr(CMS_F_CMS_ENVELOPEDDATA_FINAL, CMS_R_CTRL_FAILURE);
+            ERR_raise(ERR_LIB_CMS, CMS_R_CTRL_FAILURE);
             return 0;
         }
     }
@@ -1283,7 +1271,7 @@ int cms_AuthEnvelopedData_final(CMS_ContentInfo *cms, BIO *cmsbio)
             || (tag = OPENSSL_malloc(taglen)) == NULL
             || EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen,
                                    tag) &lt;= 0) {
-        CMSerr(0, CMS_R_CIPHER_GET_TAG);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CIPHER_GET_TAG);
         goto err;
     }
 
diff --git a/crypto/cms/cms_ess.c b/crypto/cms/cms_ess.c
index 287bcf86c0..ba05d4695c 100644
--- a/crypto/cms/cms_ess.c
+++ b/crypto/cms/cms_ess.c
@@ -99,15 +99,13 @@ int ess_check_signing_certs(CMS_SignerInfo *si, STACK_OF(X509) *chain)
             }
         }
     } else {
-        CMSerr(CMS_F_ESS_CHECK_SIGNING_CERTS,
-               CMS_R_ESS_NO_SIGNING_CERTID_ATTRIBUTE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_ESS_NO_SIGNING_CERTID_ATTRIBUTE);
         return 0;
     }
     ret = 1;
  err:
     if (!ret)
-        CMSerr(CMS_F_ESS_CHECK_SIGNING_CERTS,
-               CMS_R_ESS_SIGNING_CERTID_MISMATCH_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_ESS_SIGNING_CERTID_MISMATCH_ERROR);
 
     ESS_SIGNING_CERT_free(ss);
     ESS_SIGNING_CERT_V2_free(ssv2);
@@ -147,7 +145,7 @@ CMS_ReceiptRequest *CMS_ReceiptRequest_create0_ex(
     return rr;
 
  merr:
-    CMSerr(0, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
 
  err:
     CMS_ReceiptRequest_free(rr);
@@ -180,7 +178,7 @@ int CMS_add1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest *rr)
 
  merr:
     if (!r)
-        CMSerr(CMS_F_CMS_ADD1_RECEIPTREQUEST, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
 
     OPENSSL_free(rrder);
 
@@ -235,12 +233,12 @@ int cms_msgSigDigest_add1(CMS_SignerInfo *dest, CMS_SignerInfo *src)
     unsigned int diglen;
 
     if (!cms_msgSigDigest(src, dig, &amp;diglen)) {
-        CMSerr(CMS_F_CMS_MSGSIGDIGEST_ADD1, CMS_R_MSGSIGDIGEST_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_MSGSIGDIGEST_ERROR);
         return 0;
     }
     if (!CMS_signed_add1_attr_by_NID(dest, NID_id_smime_aa_msgSigDigest,
                                      V_ASN1_OCTET_STRING, dig, diglen)) {
-        CMSerr(CMS_F_CMS_MSGSIGDIGEST_ADD1, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return 1;
@@ -267,27 +265,27 @@ int cms_Receipt_verify(CMS_ContentInfo *cms, CMS_ContentInfo *req_cms)
         goto err;
 
     if (sk_CMS_SignerInfo_num(sis) != 1) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NEED_ONE_SIGNER);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NEED_ONE_SIGNER);
         goto err;
     }
 
     /* Check receipt content type */
     if (OBJ_obj2nid(CMS_get0_eContentType(cms)) != NID_id_smime_ct_receipt) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NOT_A_SIGNED_RECEIPT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_A_SIGNED_RECEIPT);
         goto err;
     }
 
     /* Extract and decode receipt content */
     pcont = CMS_get0_content(cms);
     if (pcont == NULL || *pcont == NULL) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_CONTENT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_CONTENT);
         goto err;
     }
 
     rct = ASN1_item_unpack(*pcont, ASN1_ITEM_rptr(CMS_Receipt));
 
     if (!rct) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_RECEIPT_DECODE_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_RECEIPT_DECODE_ERROR);
         goto err;
     }
 
@@ -300,7 +298,7 @@ int cms_Receipt_verify(CMS_ContentInfo *cms, CMS_ContentInfo *req_cms)
     }
 
     if (i == sk_CMS_SignerInfo_num(osis)) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_MATCHING_SIGNATURE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_MATCHING_SIGNATURE);
         goto err;
     }
 
@@ -314,23 +312,22 @@ int cms_Receipt_verify(CMS_ContentInfo *cms, CMS_ContentInfo *req_cms)
                                        V_ASN1_OCTET_STRING);
 
     if (!msig) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_MSGSIGDIGEST);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_MSGSIGDIGEST);
         goto err;
     }
 
     if (!cms_msgSigDigest(osi, dig, &amp;diglen)) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_MSGSIGDIGEST_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_MSGSIGDIGEST_ERROR);
         goto err;
     }
 
     if (diglen != (unsigned int)msig-&gt;length) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_MSGSIGDIGEST_WRONG_LENGTH);
+        ERR_raise(ERR_LIB_CMS, CMS_R_MSGSIGDIGEST_WRONG_LENGTH);
         goto err;
     }
 
     if (memcmp(dig, msig-&gt;data, diglen)) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY,
-               CMS_R_MSGSIGDIGEST_VERIFICATION_FAILURE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_MSGSIGDIGEST_VERIFICATION_FAILURE);
         goto err;
     }
 
@@ -340,27 +337,27 @@ int cms_Receipt_verify(CMS_ContentInfo *cms, CMS_ContentInfo *req_cms)
                                          OBJ_nid2obj(NID_pkcs9_contentType),
                                          -3, V_ASN1_OBJECT);
     if (!octype) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_CONTENT_TYPE);
         goto err;
     }
 
     /* Compare details in receipt request */
 
     if (OBJ_cmp(octype, rct-&gt;contentType)) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_CONTENT_TYPE_MISMATCH);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CONTENT_TYPE_MISMATCH);
         goto err;
     }
 
     /* Get original receipt request details */
 
     if (CMS_get1_ReceiptRequest(osi, &amp;rr) &lt;= 0) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_RECEIPT_REQUEST);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_RECEIPT_REQUEST);
         goto err;
     }
 
     if (ASN1_STRING_cmp(rr-&gt;signedContentIdentifier,
                         rct-&gt;signedContentIdentifier)) {
-        CMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_CONTENTIDENTIFIER_MISMATCH);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CONTENTIDENTIFIER_MISMATCH);
         goto err;
     }
 
@@ -390,7 +387,7 @@ ASN1_OCTET_STRING *cms_encode_Receipt(CMS_SignerInfo *si)
     /* Get original receipt request details */
 
     if (CMS_get1_ReceiptRequest(si, &amp;rr) &lt;= 0) {
-        CMSerr(CMS_F_CMS_ENCODE_RECEIPT, CMS_R_NO_RECEIPT_REQUEST);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_RECEIPT_REQUEST);
         goto err;
     }
 
@@ -400,7 +397,7 @@ ASN1_OCTET_STRING *cms_encode_Receipt(CMS_SignerInfo *si)
                                         OBJ_nid2obj(NID_pkcs9_contentType),
                                         -3, V_ASN1_OBJECT);
     if (!ctype) {
-        CMSerr(CMS_F_CMS_ENCODE_RECEIPT, CMS_R_NO_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_CONTENT_TYPE);
         goto err;
     }
 
@@ -442,7 +439,7 @@ int cms_add1_signing_cert_v2(CMS_SignerInfo *si, ESS_SIGNING_CERT_V2 *sc)
     ASN1_STRING_free(seq);
     return 1;
  err:
-    CMSerr(CMS_F_CMS_ADD1_SIGNING_CERT_V2, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
     ASN1_STRING_free(seq);
     OPENSSL_free(pp);
     return 0;
@@ -474,7 +471,7 @@ int cms_add1_signing_cert(CMS_SignerInfo *si, ESS_SIGNING_CERT *sc)
     ASN1_STRING_free(seq);
     return 1;
  err:
-    CMSerr(CMS_F_CMS_ADD1_SIGNING_CERT, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
     ASN1_STRING_free(seq);
     OPENSSL_free(pp);
     return 0;
diff --git a/crypto/cms/cms_io.c b/crypto/cms/cms_io.c
index 9b62e4874f..a12ac0d0f4 100644
--- a/crypto/cms/cms_io.c
+++ b/crypto/cms/cms_io.c
@@ -29,7 +29,7 @@ int CMS_stream(unsigned char ***boundary, CMS_ContentInfo *cms)
         *boundary = &amp;(*pos)-&gt;data;
         return 1;
     }
-    CMSerr(CMS_F_CMS_STREAM, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
diff --git a/crypto/cms/cms_kari.c b/crypto/cms/cms_kari.c
index 13f7e78d37..a9a35b4300 100644
--- a/crypto/cms/cms_kari.c
+++ b/crypto/cms/cms_kari.c
@@ -30,8 +30,7 @@ int CMS_RecipientInfo_kari_get0_alg(CMS_RecipientInfo *ri,
                                     ASN1_OCTET_STRING **pukm)
 {
     if (ri-&gt;type != CMS_RECIPINFO_AGREE) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ALG,
-               CMS_R_NOT_KEY_AGREEMENT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_AGREEMENT);
         return 0;
     }
     if (palg)
@@ -47,8 +46,7 @@ STACK_OF(CMS_RecipientEncryptedKey)
 *CMS_RecipientInfo_kari_get0_reks(CMS_RecipientInfo *ri)
 {
     if (ri-&gt;type != CMS_RECIPINFO_AGREE) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KARI_GET0_REKS,
-               CMS_R_NOT_KEY_AGREEMENT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_AGREEMENT);
         return NULL;
     }
     return ri-&gt;d.kari-&gt;recipientEncryptedKeys;
@@ -64,8 +62,7 @@ int CMS_RecipientInfo_kari_get0_orig_id(CMS_RecipientInfo *ri,
     CMS_OriginatorIdentifierOrKey *oik;
 
     if (ri-&gt;type != CMS_RECIPINFO_AGREE) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ORIG_ID,
-               CMS_R_NOT_KEY_AGREEMENT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_AGREEMENT);
         return 0;
     }
     oik = ri-&gt;d.kari-&gt;originator;
@@ -102,8 +99,7 @@ int CMS_RecipientInfo_kari_orig_id_cmp(CMS_RecipientInfo *ri, X509 *cert)
     CMS_OriginatorIdentifierOrKey *oik;
 
     if (ri-&gt;type != CMS_RECIPINFO_AGREE) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KARI_ORIG_ID_CMP,
-               CMS_R_NOT_KEY_AGREEMENT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_AGREEMENT);
         return -2;
     }
     oik = ri-&gt;d.kari-&gt;originator;
@@ -480,7 +476,7 @@ int cms_RecipientInfo_kari_encrypt(const CMS_ContentInfo *cms,
     int i;
 
     if (ri-&gt;type != CMS_RECIPINFO_AGREE) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_KARI_ENCRYPT, CMS_R_NOT_KEY_AGREEMENT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_KEY_AGREEMENT);
         return 0;
     }
     kari = ri-&gt;d.kari;
diff --git a/crypto/cms/cms_lib.c b/crypto/cms/cms_lib.c
index 6713c8674a..427f62c56c 100644
--- a/crypto/cms/cms_lib.c
+++ b/crypto/cms/cms_lib.c
@@ -155,7 +155,7 @@ BIO *CMS_dataInit(CMS_ContentInfo *cms, BIO *icont)
     else
         cont = cms_content_bio(cms);
     if (!cont) {
-        CMSerr(CMS_F_CMS_DATAINIT, CMS_R_NO_CONTENT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_CONTENT);
         return NULL;
     }
     switch (OBJ_obj2nid(cms-&gt;contentType)) {
@@ -189,7 +189,7 @@ BIO *CMS_dataInit(CMS_ContentInfo *cms, BIO *icont)
         break;
 
     default:
-        CMSerr(CMS_F_CMS_DATAINIT, CMS_R_UNSUPPORTED_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_TYPE);
         goto err;
     }
 
@@ -216,7 +216,7 @@ int CMS_dataFinal(CMS_ContentInfo *cms, BIO *cmsbio)
         long contlen;
         mbio = BIO_find_type(cmsbio, BIO_TYPE_MEM);
         if (!mbio) {
-            CMSerr(CMS_F_CMS_DATAFINAL, CMS_R_CONTENT_NOT_FOUND);
+            ERR_raise(ERR_LIB_CMS, CMS_R_CONTENT_NOT_FOUND);
             return 0;
         }
         contlen = BIO_get_mem_data(mbio, &amp;cont);
@@ -248,7 +248,7 @@ int CMS_dataFinal(CMS_ContentInfo *cms, BIO *cmsbio)
         return cms_DigestedData_do_final(cms, cmsbio, 0);
 
     default:
-        CMSerr(CMS_F_CMS_DATAFINAL, CMS_R_UNSUPPORTED_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_TYPE);
         return 0;
     }
 }
@@ -290,7 +290,7 @@ ASN1_OCTET_STRING **CMS_get0_content(CMS_ContentInfo *cms)
     default:
         if (cms-&gt;d.other-&gt;type == V_ASN1_OCTET_STRING)
             return &amp;cms-&gt;d.other-&gt;value.octet_string;
-        CMSerr(CMS_F_CMS_GET0_CONTENT, CMS_R_UNSUPPORTED_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_CONTENT_TYPE);
         return NULL;
 
     }
@@ -327,7 +327,7 @@ static ASN1_OBJECT **cms_get0_econtent_type(CMS_ContentInfo *cms)
         return &amp;cms-&gt;d.compressedData-&gt;encapContentInfo-&gt;eContentType;
 
     default:
-        CMSerr(CMS_F_CMS_GET0_ECONTENT_TYPE, CMS_R_UNSUPPORTED_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_CONTENT_TYPE);
         return NULL;
 
     }
@@ -392,7 +392,7 @@ int CMS_set_detached(CMS_ContentInfo *cms, int detached)
         (*pos)-&gt;flags |= ASN1_STRING_FLAG_CONT;
         return 1;
     }
-    CMSerr(CMS_F_CMS_SET_DETACHED, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
@@ -419,15 +419,14 @@ BIO *cms_DigestAlgorithm_init_bio(X509_ALGOR *digestAlgorithm,
         digest = EVP_get_digestbyobj(digestoid);
     if (digest == NULL) {
         (void)ERR_clear_last_mark();
-        CMSerr(CMS_F_CMS_DIGESTALGORITHM_INIT_BIO,
-               CMS_R_UNKNOWN_DIGEST_ALGORITHM);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNKNOWN_DIGEST_ALGORITHM);
         goto err;
     }
     (void)ERR_pop_to_mark();
 
     mdbio = BIO_new(BIO_f_md());
     if (mdbio == NULL || !BIO_set_md(mdbio, digest)) {
-        CMSerr(CMS_F_CMS_DIGESTALGORITHM_INIT_BIO, CMS_R_MD_BIO_INIT_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_MD_BIO_INIT_ERROR);
         goto err;
     }
     EVP_MD_free(fetched_digest);
@@ -452,8 +451,7 @@ int cms_DigestAlgorithm_find_ctx(EVP_MD_CTX *mctx, BIO *chain,
         EVP_MD_CTX *mtmp;
         chain = BIO_find_type(chain, BIO_TYPE_MD);
         if (chain == NULL) {
-            CMSerr(CMS_F_CMS_DIGESTALGORITHM_FIND_CTX,
-                   CMS_R_NO_MATCHING_DIGEST);
+            ERR_raise(ERR_LIB_CMS, CMS_R_NO_MATCHING_DIGEST);
             return 0;
         }
         BIO_get_md_ctx(chain, &amp;mtmp);
@@ -487,8 +485,7 @@ static STACK_OF(CMS_CertificateChoices)
         return &amp;cms-&gt;d.authEnvelopedData-&gt;originatorInfo-&gt;certificates;
 
     default:
-        CMSerr(CMS_F_CMS_GET0_CERTIFICATE_CHOICES,
-               CMS_R_UNSUPPORTED_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_CONTENT_TYPE);
         return NULL;
 
     }
@@ -529,8 +526,7 @@ int CMS_add0_cert(CMS_ContentInfo *cms, X509 *cert)
         cch = sk_CMS_CertificateChoices_value(*pcerts, i);
         if (cch-&gt;type == CMS_CERTCHOICE_CERT) {
             if (!X509_cmp(cch-&gt;d.certificate, cert)) {
-                CMSerr(CMS_F_CMS_ADD0_CERT,
-                       CMS_R_CERTIFICATE_ALREADY_PRESENT);
+                ERR_raise(ERR_LIB_CMS, CMS_R_CERTIFICATE_ALREADY_PRESENT);
                 return 0;
             }
         }
@@ -571,8 +567,7 @@ static STACK_OF(CMS_RevocationInfoChoice)
         return &amp;cms-&gt;d.authEnvelopedData-&gt;originatorInfo-&gt;crls;
 
     default:
-        CMSerr(CMS_F_CMS_GET0_REVOCATION_CHOICES,
-               CMS_R_UNSUPPORTED_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_CONTENT_TYPE);
         return NULL;
 
     }
@@ -705,7 +700,7 @@ int cms_set1_ias(CMS_IssuerAndSerialNumber **pias, X509 *cert)
     return 1;
  err:
     M_ASN1_free_of(ias, CMS_IssuerAndSerialNumber);
-    CMSerr(CMS_F_CMS_SET1_IAS, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
@@ -715,12 +710,12 @@ int cms_set1_keyid(ASN1_OCTET_STRING **pkeyid, X509 *cert)
     const ASN1_OCTET_STRING *cert_keyid;
     cert_keyid = X509_get0_subject_key_id(cert);
     if (cert_keyid == NULL) {
-        CMSerr(CMS_F_CMS_SET1_KEYID, CMS_R_CERTIFICATE_HAS_NO_KEYID);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CERTIFICATE_HAS_NO_KEYID);
         return 0;
     }
     keyid = ASN1_STRING_dup(cert_keyid);
     if (!keyid) {
-        CMSerr(CMS_F_CMS_SET1_KEYID, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ASN1_OCTET_STRING_free(*pkeyid);
diff --git a/crypto/cms/cms_pwri.c b/crypto/cms/cms_pwri.c
index 0393608fdb..8b55f7d0a8 100644
--- a/crypto/cms/cms_pwri.c
+++ b/crypto/cms/cms_pwri.c
@@ -23,7 +23,7 @@ int CMS_RecipientInfo_set0_password(CMS_RecipientInfo *ri,
 {
     CMS_PasswordRecipientInfo *pwri;
     if (ri-&gt;type != CMS_RECIPINFO_PASS) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_SET0_PASSWORD, CMS_R_NOT_PWRI);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_PWRI);
         return 0;
     }
 
@@ -70,12 +70,11 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
         kekciph = ec-&gt;cipher;
 
     if (kekciph == NULL) {
-        CMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, CMS_R_NO_CIPHER);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_CIPHER);
         return NULL;
     }
     if (wrap_nid != NID_id_alg_PWRI_KEK) {
-        CMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD,
-               CMS_R_UNSUPPORTED_KEY_ENCRYPTION_ALGORITHM);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_KEY_ENCRYPTION_ALGORITHM);
         return NULL;
     }
 
@@ -87,7 +86,7 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
     ctx = EVP_CIPHER_CTX_new();
 
     if (EVP_EncryptInit_ex(ctx, kekciph, NULL, NULL, NULL) &lt;= 0) {
-        CMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_CMS, ERR_R_EVP_LIB);
         goto err;
     }
 
@@ -97,17 +96,16 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
         if (RAND_bytes_ex(cms_ctx-&gt;libctx, iv, ivlen) &lt;= 0)
             goto err;
         if (EVP_EncryptInit_ex(ctx, NULL, NULL, NULL, iv) &lt;= 0) {
-            CMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, ERR_R_EVP_LIB);
+            ERR_raise(ERR_LIB_CMS, ERR_R_EVP_LIB);
             goto err;
         }
         encalg-&gt;parameter = ASN1_TYPE_new();
         if (!encalg-&gt;parameter) {
-            CMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (EVP_CIPHER_param_to_asn1(ctx, encalg-&gt;parameter) &lt;= 0) {
-            CMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD,
-                   CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
+            ERR_raise(ERR_LIB_CMS, CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
             goto err;
         }
     }
@@ -164,7 +162,7 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
     return ri;
 
  merr:
-    CMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
  err:
     EVP_CIPHER_CTX_free(ctx);
     if (ri)
@@ -195,7 +193,7 @@ static int kek_unwrap_key(unsigned char *out, size_t *outlen,
         return 0;
     }
     if ((tmp = OPENSSL_malloc(inlen)) == NULL) {
-        CMSerr(CMS_F_KEK_UNWRAP_KEY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     /* setup IV by decrypting last two blocks */
@@ -299,14 +297,13 @@ int cms_RecipientInfo_pwri_crypt(const CMS_ContentInfo *cms,
     pwri = ri-&gt;d.pwri;
 
     if (pwri-&gt;pass == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, CMS_R_NO_PASSWORD);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_PASSWORD);
         return 0;
     }
     algtmp = pwri-&gt;keyEncryptionAlgorithm;
 
     if (!algtmp || OBJ_obj2nid(algtmp-&gt;algorithm) != NID_id_alg_PWRI_KEK) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT,
-               CMS_R_UNSUPPORTED_KEY_ENCRYPTION_ALGORITHM);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_KEY_ENCRYPTION_ALGORITHM);
         return 0;
     }
 
@@ -314,8 +311,7 @@ int cms_RecipientInfo_pwri_crypt(const CMS_ContentInfo *cms,
                                        algtmp-&gt;parameter);
 
     if (kekalg == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT,
-               CMS_R_INVALID_KEY_ENCRYPTION_PARAMETER);
+        ERR_raise(ERR_LIB_CMS, CMS_R_INVALID_KEY_ENCRYPTION_PARAMETER);
         return 0;
     }
 
@@ -323,13 +319,13 @@ int cms_RecipientInfo_pwri_crypt(const CMS_ContentInfo *cms,
     kekcipher = EVP_CIPHER_fetch(cms_ctx-&gt;libctx, name, cms_ctx-&gt;propq);
 
     if (kekcipher == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, CMS_R_UNKNOWN_CIPHER);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNKNOWN_CIPHER);
         goto err;
     }
 
     kekctx = EVP_CIPHER_CTX_new();
     if (kekctx == NULL) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     /* Fixup cipher based on AlgorithmIdentifier to set IV etc */
@@ -337,8 +333,7 @@ int cms_RecipientInfo_pwri_crypt(const CMS_ContentInfo *cms,
         goto err;
     EVP_CIPHER_CTX_set_padding(kekctx, 0);
     if (EVP_CIPHER_asn1_to_param(kekctx, kekalg-&gt;parameter) &lt;= 0) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT,
-               CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
         goto err;
     }
 
@@ -349,7 +344,7 @@ int cms_RecipientInfo_pwri_crypt(const CMS_ContentInfo *cms,
     if (EVP_PBE_CipherInit(algtmp-&gt;algorithm,
                            (char *)pwri-&gt;pass, pwri-&gt;passlen,
                            algtmp-&gt;parameter, kekctx, en_de) &lt; 0) {
-        CMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_CMS, ERR_R_EVP_LIB);
         goto err;
     }
 
@@ -373,13 +368,13 @@ int cms_RecipientInfo_pwri_crypt(const CMS_ContentInfo *cms,
         key = OPENSSL_malloc(pwri-&gt;encryptedKey-&gt;length);
 
         if (key == NULL) {
-            CMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (!kek_unwrap_key(key, &amp;keylen,
                             pwri-&gt;encryptedKey-&gt;data,
                             pwri-&gt;encryptedKey-&gt;length, kekctx)) {
-            CMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, CMS_R_UNWRAP_FAILURE);
+            ERR_raise(ERR_LIB_CMS, CMS_R_UNWRAP_FAILURE);
             goto err;
         }
 
diff --git a/crypto/cms/cms_rsa.c b/crypto/cms/cms_rsa.c
index 88201d7b44..92619fcdd1 100644
--- a/crypto/cms/cms_rsa.c
+++ b/crypto/cms/cms_rsa.c
@@ -54,14 +54,14 @@ static int rsa_cms_decrypt(CMS_RecipientInfo *ri)
     if (nid == NID_rsaEncryption)
         return 1;
     if (nid != NID_rsaesOaep) {
-        CMSerr(0, CMS_R_UNSUPPORTED_ENCRYPTION_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_ENCRYPTION_TYPE);
         return -1;
     }
     /* Decode OAEP parameters */
     oaep = rsa_oaep_decode(cmsalg);
 
     if (oaep == NULL) {
-        CMSerr(0, CMS_R_INVALID_OAEP_PARAMETERS);
+        ERR_raise(ERR_LIB_CMS, CMS_R_INVALID_OAEP_PARAMETERS);
         goto err;
     }
 
@@ -76,11 +76,11 @@ static int rsa_cms_decrypt(CMS_RecipientInfo *ri)
         X509_ALGOR *plab = oaep-&gt;pSourceFunc;
 
         if (OBJ_obj2nid(plab-&gt;algorithm) != NID_pSpecified) {
-            CMSerr(0, CMS_R_UNSUPPORTED_LABEL_SOURCE);
+            ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_LABEL_SOURCE);
             goto err;
         }
         if (plab-&gt;parameter-&gt;type != V_ASN1_OCTET_STRING) {
-            CMSerr(0, CMS_R_INVALID_LABEL);
+            ERR_raise(ERR_LIB_CMS, CMS_R_INVALID_LABEL);
             goto err;
         }
 
@@ -182,7 +182,7 @@ int cms_rsa_envelope(CMS_RecipientInfo *ri, int decrypt)
     if (decrypt == 0)
         return rsa_cms_encrypt(ri);
 
-    CMSerr(0, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+    ERR_raise(ERR_LIB_CMS, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
     return 0;
 }
 
@@ -225,7 +225,7 @@ static int rsa_cms_verify(CMS_SignerInfo *si)
         return ossl_rsa_pss_to_ctx(NULL, pkctx, alg, NULL);
     /* Only PSS allowed for PSS keys */
     if (EVP_PKEY_is_a(pkey, &quot;RSA-PSS&quot;)) {
-        RSAerr(RSA_F_RSA_CMS_VERIFY, RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE);
         return 0;
     }
     if (nid == NID_rsaEncryption)
@@ -248,6 +248,6 @@ int cms_rsa_sign(CMS_SignerInfo *si, int verify)
     if (verify == 0)
         return rsa_cms_sign(si);
 
-    CMSerr(0, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+    ERR_raise(ERR_LIB_CMS, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
     return 0;
 }
diff --git a/crypto/cms/cms_sd.c b/crypto/cms/cms_sd.c
index 377fac5917..1020227c54 100644
--- a/crypto/cms/cms_sd.c
+++ b/crypto/cms/cms_sd.c
@@ -27,7 +27,7 @@
 static CMS_SignedData *cms_get0_signed(CMS_ContentInfo *cms)
 {
     if (OBJ_obj2nid(cms-&gt;contentType) != NID_pkcs7_signed) {
-        CMSerr(CMS_F_CMS_GET0_SIGNED, CMS_R_CONTENT_TYPE_NOT_SIGNED_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CONTENT_TYPE_NOT_SIGNED_DATA);
         return NULL;
     }
     return cms-&gt;d.signedData;
@@ -38,7 +38,7 @@ static CMS_SignedData *cms_signed_data_init(CMS_ContentInfo *cms)
     if (cms-&gt;d.other == NULL) {
         cms-&gt;d.signedData = M_ASN1_new_of(CMS_SignedData);
         if (!cms-&gt;d.signedData) {
-            CMSerr(CMS_F_CMS_SIGNED_DATA_INIT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
         cms-&gt;d.signedData-&gt;version = 1;
@@ -160,8 +160,7 @@ static int cms_copy_messageDigest(CMS_ContentInfo *cms, CMS_SignerInfo *si)
                                                     (NID_pkcs9_messageDigest),
                                                     -3, V_ASN1_OCTET_STRING);
         if (!messageDigest) {
-            CMSerr(CMS_F_CMS_COPY_MESSAGEDIGEST,
-                   CMS_R_ERROR_READING_MESSAGEDIGEST_ATTRIBUTE);
+            ERR_raise(ERR_LIB_CMS, CMS_R_ERROR_READING_MESSAGEDIGEST_ATTRIBUTE);
             return 0;
         }
 
@@ -172,7 +171,7 @@ static int cms_copy_messageDigest(CMS_ContentInfo *cms, CMS_SignerInfo *si)
         else
             return 0;
     }
-    CMSerr(CMS_F_CMS_COPY_MESSAGEDIGEST, CMS_R_NO_MATCHING_DIGEST);
+    ERR_raise(ERR_LIB_CMS, CMS_R_NO_MATCHING_DIGEST);
     return 0;
 }
 
@@ -191,7 +190,7 @@ int cms_set1_SignerIdentifier(CMS_SignerIdentifier *sid, X509 *cert, int type,
         break;
 
     default:
-        CMSerr(CMS_F_CMS_SET1_SIGNERIDENTIFIER, CMS_R_UNKNOWN_ID);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNKNOWN_ID);
         return 0;
     }
 
@@ -246,11 +245,11 @@ static int cms_sd_asn1_ctrl(CMS_SignerInfo *si, int cmd)
         return 1;
     i = pkey-&gt;ameth-&gt;pkey_ctrl(pkey, ASN1_PKEY_CTRL_CMS_SIGN, cmd, si);
     if (i == -2) {
-        CMSerr(CMS_F_CMS_SD_ASN1_CTRL, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
         return 0;
     }
     if (i &lt;= 0) {
-        CMSerr(CMS_F_CMS_SD_ASN1_CTRL, CMS_R_CTRL_FAILURE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CTRL_FAILURE);
         return 0;
     }
     return 1;
@@ -267,8 +266,7 @@ CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,
     const CMS_CTX *ctx = cms_get0_cmsctx(cms);
 
     if (!X509_check_private_key(signer, pk)) {
-        CMSerr(CMS_F_CMS_ADD1_SIGNER,
-               CMS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
         return NULL;
     }
     sd = cms_signed_data_init(cms);
@@ -290,7 +288,7 @@ CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,
     si-&gt;pctx = NULL;
 
     if (si-&gt;mctx == NULL) {
-        CMSerr(CMS_F_CMS_ADD1_SIGNER, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -313,18 +311,18 @@ CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,
             goto err;
         md = EVP_get_digestbynid(def_nid);
         if (md == NULL) {
-            CMSerr(CMS_F_CMS_ADD1_SIGNER, CMS_R_NO_DEFAULT_DIGEST);
+            ERR_raise(ERR_LIB_CMS, CMS_R_NO_DEFAULT_DIGEST);
             goto err;
         }
     }
 
     if (!md) {
-        CMSerr(CMS_F_CMS_ADD1_SIGNER, CMS_R_NO_DIGEST_SET);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_DIGEST_SET);
         goto err;
     }
 
     if (md == NULL) {
-        CMSerr(CMS_F_CMS_ADD1_SIGNER, CMS_R_NO_DIGEST_SET);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_DIGEST_SET);
         goto err;
     }
 
@@ -434,7 +432,7 @@ CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,
     return si;
 
  merr:
-    CMSerr(CMS_F_CMS_ADD1_SIGNER, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
  err:
     M_ASN1_free_of(si, CMS_SignerInfo);
     return NULL;
@@ -478,7 +476,7 @@ static int cms_add1_signingTime(CMS_SignerInfo *si, ASN1_TIME *t)
         ASN1_TIME_free(tt);
 
     if (!r)
-        CMSerr(CMS_F_CMS_ADD1_SIGNINGTIME, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
 
     return r;
 
@@ -620,12 +618,12 @@ static int cms_SignerInfo_content_sign(CMS_ContentInfo *cms,
     const CMS_CTX *ctx = cms_get0_cmsctx(cms);
 
     if (mctx == NULL) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
     if (si-&gt;pkey == NULL) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, CMS_R_NO_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_PRIVATE_KEY);
         goto err;
     }
 
@@ -666,7 +664,7 @@ static int cms_SignerInfo_content_sign(CMS_ContentInfo *cms,
         siglen = EVP_PKEY_size(si-&gt;pkey);
         sig = OPENSSL_malloc(siglen);
         if (sig == NULL) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (EVP_PKEY_sign(pctx, sig, &amp;siglen, md, mdlen) &lt;= 0) {
@@ -680,12 +678,12 @@ static int cms_SignerInfo_content_sign(CMS_ContentInfo *cms,
 
         sig = OPENSSL_malloc(EVP_PKEY_size(si-&gt;pkey));
         if (sig == NULL) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (!EVP_SignFinal_ex(mctx, sig, &amp;siglen, si-&gt;pkey, ctx-&gt;libctx,
                               ctx-&gt;propq)) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, CMS_R_SIGNFINAL_ERROR);
+            ERR_raise(ERR_LIB_CMS, CMS_R_SIGNFINAL_ERROR);
             OPENSSL_free(sig);
             goto err;
         }
@@ -761,7 +759,7 @@ int CMS_SignerInfo_sign(CMS_SignerInfo *si)
 #if 0
     if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
                           EVP_PKEY_CTRL_CMS_SIGN, 0, si) &lt;= 0) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_SIGN, CMS_R_CTRL_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CTRL_ERROR);
         goto err;
     }
 #endif
@@ -794,7 +792,7 @@ int CMS_SignerInfo_sign(CMS_SignerInfo *si)
 #if 0
     if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
                           EVP_PKEY_CTRL_CMS_SIGN, 1, si) &lt;= 0) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_SIGN, CMS_R_CTRL_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CTRL_ERROR);
         goto err;
     }
 #endif
@@ -822,7 +820,7 @@ int CMS_SignerInfo_verify(CMS_SignerInfo *si)
     const CMS_CTX *ctx = si-&gt;cms_ctx;
 
     if (si-&gt;pkey == NULL) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY, CMS_R_NO_PUBLIC_KEY);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_PUBLIC_KEY);
         return -1;
     }
 
@@ -840,13 +838,13 @@ int CMS_SignerInfo_verify(CMS_SignerInfo *si)
         md = EVP_get_digestbyobj(si-&gt;digestAlgorithm-&gt;algorithm);
     if (md == NULL) {
         (void)ERR_clear_last_mark();
-        CMSerr(0, CMS_R_UNKNOWN_DIGEST_ALGORITHM);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNKNOWN_DIGEST_ALGORITHM);
         return -1;
     }
     (void)ERR_pop_to_mark();
 
     if (si-&gt;mctx == NULL &amp;&amp; (si-&gt;mctx = EVP_MD_CTX_new()) == NULL) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     mctx = si-&gt;mctx;
@@ -870,7 +868,7 @@ int CMS_SignerInfo_verify(CMS_SignerInfo *si)
     r = EVP_DigestVerifyFinal(mctx,
                               si-&gt;signature-&gt;data, si-&gt;signature-&gt;length);
     if (r &lt;= 0)
-        CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY, CMS_R_VERIFICATION_FAILURE);
+        ERR_raise(ERR_LIB_CMS, CMS_R_VERIFICATION_FAILURE);
  err:
     EVP_MD_free(fetched_md);
     EVP_MD_CTX_reset(mctx);
@@ -919,7 +917,7 @@ int CMS_SignerInfo_verify_content(CMS_SignerInfo *si, BIO *chain)
     unsigned int mlen;
 
     if (mctx == NULL) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     /* If we have any signed attributes look for messageDigest value */
@@ -928,8 +926,7 @@ int CMS_SignerInfo_verify_content(CMS_SignerInfo *si, BIO *chain)
                                          OBJ_nid2obj(NID_pkcs9_messageDigest),
                                          -3, V_ASN1_OCTET_STRING);
         if (os == NULL) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
-                   CMS_R_ERROR_READING_MESSAGEDIGEST_ATTRIBUTE);
+            ERR_raise(ERR_LIB_CMS, CMS_R_ERROR_READING_MESSAGEDIGEST_ATTRIBUTE);
             goto err;
         }
     }
@@ -938,8 +935,7 @@ int CMS_SignerInfo_verify_content(CMS_SignerInfo *si, BIO *chain)
         goto err;
 
     if (EVP_DigestFinal_ex(mctx, mval, &amp;mlen) &lt;= 0) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
-               CMS_R_UNABLE_TO_FINALIZE_CONTEXT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_UNABLE_TO_FINALIZE_CONTEXT);
         goto err;
     }
 
@@ -947,14 +943,12 @@ int CMS_SignerInfo_verify_content(CMS_SignerInfo *si, BIO *chain)
 
     if (os != NULL) {
         if (mlen != (unsigned int)os-&gt;length) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
-                   CMS_R_MESSAGEDIGEST_ATTRIBUTE_WRONG_LENGTH);
+            ERR_raise(ERR_LIB_CMS, CMS_R_MESSAGEDIGEST_ATTRIBUTE_WRONG_LENGTH);
             goto err;
         }
 
         if (memcmp(mval, os-&gt;data, mlen)) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
-                   CMS_R_VERIFICATION_FAILURE);
+            ERR_raise(ERR_LIB_CMS, CMS_R_VERIFICATION_FAILURE);
             r = 0;
         } else
             r = 1;
@@ -975,8 +969,7 @@ int CMS_SignerInfo_verify_content(CMS_SignerInfo *si, BIO *chain)
         r = EVP_PKEY_verify(pkctx, si-&gt;signature-&gt;data,
                             si-&gt;signature-&gt;length, mval, mlen);
         if (r &lt;= 0) {
-            CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,
-                   CMS_R_VERIFICATION_FAILURE);
+            ERR_raise(ERR_LIB_CMS, CMS_R_VERIFICATION_FAILURE);
             r = 0;
         }
     }
diff --git a/crypto/cms/cms_smime.c b/crypto/cms/cms_smime.c
index f8ae342551..5c903f204b 100644
--- a/crypto/cms/cms_smime.c
+++ b/crypto/cms/cms_smime.c
@@ -39,7 +39,7 @@ static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)
     tmpout = cms_get_text_bio(out, flags);
 
     if (tmpout == NULL) {
-        CMSerr(CMS_F_CMS_COPY_CONTENT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -62,7 +62,7 @@ static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)
 
     if (flags &amp; CMS_TEXT) {
         if (!SMIME_text(tmpout, out)) {
-            CMSerr(CMS_F_CMS_COPY_CONTENT, CMS_R_SMIME_TEXT_ERROR);
+            ERR_raise(ERR_LIB_CMS, CMS_R_SMIME_TEXT_ERROR);
             goto err;
         }
     }
@@ -80,7 +80,7 @@ static int check_content(CMS_ContentInfo *cms)
     ASN1_OCTET_STRING **pos = CMS_get0_content(cms);
 
     if (pos == NULL || *pos == NULL) {
-        CMSerr(CMS_F_CHECK_CONTENT, CMS_R_NO_CONTENT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_CONTENT);
         return 0;
     }
     return 1;
@@ -107,7 +107,7 @@ int CMS_data(CMS_ContentInfo *cms, BIO *out, unsigned int flags)
     int r;
 
     if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_data) {
-        CMSerr(CMS_F_CMS_DATA, CMS_R_TYPE_NOT_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_TYPE_NOT_DATA);
         return 0;
     }
     cont = CMS_dataInit(cms, NULL);
@@ -145,7 +145,7 @@ int CMS_digest_verify(CMS_ContentInfo *cms, BIO *dcont, BIO *out,
     int r;
 
     if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_digest) {
-        CMSerr(CMS_F_CMS_DIGEST_VERIFY, CMS_R_TYPE_NOT_DIGESTED_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_TYPE_NOT_DIGESTED_DATA);
         return 0;
     }
 
@@ -199,8 +199,7 @@ int CMS_EncryptedData_decrypt(CMS_ContentInfo *cms,
     int r;
 
     if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_encrypted) {
-        CMSerr(CMS_F_CMS_ENCRYPTEDDATA_DECRYPT,
-               CMS_R_TYPE_NOT_ENCRYPTED_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_TYPE_NOT_ENCRYPTED_DATA);
         return 0;
     }
 
@@ -226,7 +225,7 @@ CMS_ContentInfo *CMS_EncryptedData_encrypt_ex(BIO *in, const EVP_CIPHER *cipher,
     CMS_ContentInfo *cms;
 
     if (cipher == NULL) {
-        CMSerr(0, CMS_R_NO_CIPHER);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_CIPHER);
         return NULL;
     }
     cms = CMS_ContentInfo_new_ex(libctx, propq);
@@ -267,12 +266,12 @@ static int cms_signerinfo_verify_cert(CMS_SignerInfo *si,
 
     ctx = X509_STORE_CTX_new_ex(cms_ctx-&gt;libctx, cms_ctx-&gt;propq);
     if (ctx == NULL) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     CMS_SignerInfo_get0_algs(si, NULL, &amp;signer, NULL, NULL);
     if (!X509_STORE_CTX_init(ctx, store, signer, certs)) {
-        CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CERT, CMS_R_STORE_INIT_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_STORE_INIT_ERROR);
         goto err;
     }
     X509_STORE_CTX_set_default(ctx, &quot;smime_sign&quot;);
@@ -282,10 +281,8 @@ static int cms_signerinfo_verify_cert(CMS_SignerInfo *si,
     i = X509_verify_cert(ctx);
     if (i &lt;= 0) {
         j = X509_STORE_CTX_get_error(ctx);
-        CMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CERT,
-               CMS_R_CERTIFICATE_VERIFY_ERROR);
-        ERR_add_error_data(2, &quot;Verify error:&quot;,
-                           X509_verify_cert_error_string(j));
+        ERR_raise_data(ERR_LIB_CMS, CMS_R_CERTIFICATE_VERIFY_ERROR,
+                       &quot;Verify error: %s&quot;, X509_verify_cert_error_string(j));
         goto err;
     }
     r = 1;
@@ -327,7 +324,7 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
     sinfos = CMS_get0_SignerInfos(cms);
 
     if (sk_CMS_SignerInfo_num(sinfos) &lt;= 0) {
-        CMSerr(CMS_F_CMS_VERIFY, CMS_R_NO_SIGNERS);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_SIGNERS);
         goto err;
     }
 
@@ -342,7 +339,7 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
         scount += CMS_set1_signers_certs(cms, certs, flags);
 
     if (scount != sk_CMS_SignerInfo_num(sinfos)) {
-        CMSerr(CMS_F_CMS_VERIFY, CMS_R_SIGNER_CERTIFICATE_NOT_FOUND);
+        ERR_raise(ERR_LIB_CMS, CMS_R_SIGNER_CERTIFICATE_NOT_FOUND);
         goto err;
     }
 
@@ -354,7 +351,7 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
             /* Certificate trust chain is required to check CAdES signature */
             si_chains = OPENSSL_zalloc(scount * sizeof(si_chains[0]));
             if (si_chains == NULL) {
-                CMSerr(CMS_F_CMS_VERIFY, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
         }
@@ -403,7 +400,7 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
         len = BIO_get_mem_data(dcont, &amp;ptr);
         tmpin = (len == 0) ? dcont : BIO_new_mem_buf(ptr, len);
         if (tmpin == NULL) {
-            CMSerr(CMS_F_CMS_VERIFY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             goto err2;
         }
     } else {
@@ -420,7 +417,7 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
          */
         tmpout = cms_get_text_bio(out, flags);
         if (tmpout == NULL) {
-            CMSerr(CMS_F_CMS_VERIFY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         cmsbio = CMS_dataInit(cms, tmpout);
@@ -434,7 +431,7 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
 
         if (flags &amp; CMS_TEXT) {
             if (!SMIME_text(tmpout, out)) {
-                CMSerr(CMS_F_CMS_VERIFY, CMS_R_SMIME_TEXT_ERROR);
+                ERR_raise(ERR_LIB_CMS, CMS_R_SMIME_TEXT_ERROR);
                 goto err;
             }
         }
@@ -451,7 +448,7 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,
         for (i = 0; i &lt; sk_CMS_SignerInfo_num(sinfos); i++) {
             si = sk_CMS_SignerInfo_value(sinfos, i);
             if (CMS_SignerInfo_verify_content(si, cmsbio) &lt;= 0) {
-                CMSerr(CMS_F_CMS_VERIFY, CMS_R_CONTENT_VERIFY_ERROR);
+                ERR_raise(ERR_LIB_CMS, CMS_R_CONTENT_VERIFY_ERROR);
                 goto err;
             }
         }
@@ -515,7 +512,7 @@ CMS_ContentInfo *CMS_sign_ex(X509 *signcert, EVP_PKEY *pkey,
         goto err;
 
     if (pkey != NULL &amp;&amp; !CMS_add1_signer(cms, signcert, pkey, NULL, flags)) {
-        CMSerr(0, CMS_R_ADD_SIGNER_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_ADD_SIGNER_ERROR);
         goto err;
     }
 
@@ -536,7 +533,7 @@ CMS_ContentInfo *CMS_sign_ex(X509 *signcert, EVP_PKEY *pkey,
         goto err;
 
  merr:
-    CMSerr(0, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
 
  err:
     CMS_ContentInfo_free(cms);
@@ -564,7 +561,7 @@ CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si,
     /* Not really detached but avoids content being allocated */
     flags |= CMS_PARTIAL | CMS_BINARY | CMS_DETACHED;
     if (pkey == NULL || signcert == NULL) {
-        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_NO_KEY_OR_CERT);
+        ERR_raise(ERR_LIB_CMS, CMS_R_NO_KEY_OR_CERT);
         return NULL;
     }
 
@@ -580,7 +577,7 @@ CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si,
 
     rct_si = CMS_add1_signer(cms, signcert, pkey, NULL, flags);
     if (!rct_si) {
-        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_ADD_SIGNER_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_ADD_SIGNER_ERROR);
         goto err;
     }
 
@@ -634,7 +631,7 @@ CMS_ContentInfo *CMS_encrypt_ex(STACK_OF(X509) *certs, BIO *data,
     for (i = 0; i &lt; sk_X509_num(certs); i++) {
         recip = sk_X509_value(certs, i);
         if (!CMS_add1_recipient_cert(cms, recip, flags)) {
-            CMSerr(0, CMS_R_RECIPIENT_ERROR);
+            ERR_raise(ERR_LIB_CMS, CMS_R_RECIPIENT_ERROR);
             goto err;
         }
     }
@@ -649,7 +646,7 @@ CMS_ContentInfo *CMS_encrypt_ex(STACK_OF(X509) *certs, BIO *data,
         goto err;
 
  merr:
-    CMSerr(0, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
  err:
     CMS_ContentInfo_free(cms);
     return NULL;
@@ -705,8 +702,7 @@ int CMS_decrypt_set1_pkey_and_peer(CMS_ContentInfo *cms, EVP_PKEY *pk,
 
     cms_pkey_ri_type = cms_pkey_get_ri_type(pk);
     if (cms_pkey_ri_type == CMS_RECIPINFO_NONE) {
-         CMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY_AND_PEER,
-              CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+         ERR_raise(ERR_LIB_CMS, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
          return 0;
     }
 
@@ -745,7 +741,7 @@ int CMS_decrypt_set1_pkey_and_peer(CMS_ContentInfo *cms, EVP_PKEY *pk,
                 }
                 if (r &gt; 0)
                     return 1;
-                CMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY_AND_PEER, CMS_R_DECRYPT_ERROR);
+                ERR_raise(ERR_LIB_CMS, CMS_R_DECRYPT_ERROR);
                 return 0;
             }
             /*
@@ -766,7 +762,7 @@ int CMS_decrypt_set1_pkey_and_peer(CMS_ContentInfo *cms, EVP_PKEY *pk,
         return 1;
     }
 
-    CMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY_AND_PEER, CMS_R_NO_MATCHING_RECIPIENT);
+    ERR_raise(ERR_LIB_CMS, CMS_R_NO_MATCHING_RECIPIENT);
     return 0;
 
 }
@@ -796,14 +792,14 @@ int CMS_decrypt_set1_key(CMS_ContentInfo *cms,
             if (r &gt; 0)
                 return 1;
             if (id != NULL) {
-                CMSerr(CMS_F_CMS_DECRYPT_SET1_KEY, CMS_R_DECRYPT_ERROR);
+                ERR_raise(ERR_LIB_CMS, CMS_R_DECRYPT_ERROR);
                 return 0;
             }
             ERR_clear_error();
         }
     }
 
-    CMSerr(CMS_F_CMS_DECRYPT_SET1_KEY, CMS_R_NO_MATCHING_RECIPIENT);
+    ERR_raise(ERR_LIB_CMS, CMS_R_NO_MATCHING_RECIPIENT);
     return 0;
 
 }
@@ -827,7 +823,7 @@ int CMS_decrypt_set1_password(CMS_ContentInfo *cms,
             return 1;
     }
 
-    CMSerr(CMS_F_CMS_DECRYPT_SET1_PASSWORD, CMS_R_NO_MATCHING_RECIPIENT);
+    ERR_raise(ERR_LIB_CMS, CMS_R_NO_MATCHING_RECIPIENT);
     return 0;
 
 }
@@ -842,7 +838,7 @@ int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,
 
     if (nid != NID_pkcs7_enveloped
             &amp;&amp; nid != NID_id_smime_ct_authEnvelopedData) {
-        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_TYPE_NOT_ENVELOPED_DATA);
         return 0;
     }
     if (dcont == NULL &amp;&amp; !check_content(cms))
@@ -873,7 +869,7 @@ int CMS_final(CMS_ContentInfo *cms, BIO *data, BIO *dcont, unsigned int flags)
     int ret = 0;
 
     if ((cmsbio = CMS_dataInit(cms, dcont)) == NULL) {
-        CMSerr(CMS_F_CMS_FINAL, CMS_R_CMS_LIB);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CMS_LIB);
         return 0;
     }
 
@@ -882,7 +878,7 @@ int CMS_final(CMS_ContentInfo *cms, BIO *data, BIO *dcont, unsigned int flags)
     (void)BIO_flush(cmsbio);
 
     if (!CMS_dataFinal(cms, cmsbio)) {
-        CMSerr(CMS_F_CMS_FINAL, CMS_R_CMS_DATAFINAL_ERROR);
+        ERR_raise(ERR_LIB_CMS, CMS_R_CMS_DATAFINAL_ERROR);
         goto err;
     }
 err:
@@ -901,7 +897,7 @@ int CMS_uncompress(CMS_ContentInfo *cms, BIO *dcont, BIO *out,
     int r;
 
     if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_id_smime_ct_compressedData) {
-        CMSerr(CMS_F_CMS_UNCOMPRESS, CMS_R_TYPE_NOT_COMPRESSED_DATA);
+        ERR_raise(ERR_LIB_CMS, CMS_R_TYPE_NOT_COMPRESSED_DATA);
         return 0;
     }
 
@@ -941,13 +937,13 @@ CMS_ContentInfo *CMS_compress(BIO *in, int comp_nid, unsigned int flags)
 int CMS_uncompress(CMS_ContentInfo *cms, BIO *dcont, BIO *out,
                    unsigned int flags)
 {
-    CMSerr(CMS_F_CMS_UNCOMPRESS, CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
+    ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
     return 0;
 }
 
 CMS_ContentInfo *CMS_compress(BIO *in, int comp_nid, unsigned int flags)
 {
-    CMSerr(CMS_F_CMS_COMPRESS, CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
+    ERR_raise(ERR_LIB_CMS, CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
     return NULL;
 }
 
diff --git a/crypto/comp/c_zlib.c b/crypto/comp/c_zlib.c
index 0d84a52726..5d69dc96d2 100644
--- a/crypto/comp/c_zlib.c
+++ b/crypto/comp/c_zlib.c
@@ -321,13 +321,13 @@ static int bio_zlib_new(BIO *bi)
 # ifdef ZLIB_SHARED
     (void)COMP_zlib();
     if (!zlib_loaded) {
-        COMPerr(COMP_F_BIO_ZLIB_NEW, COMP_R_ZLIB_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_COMP, COMP_R_ZLIB_NOT_SUPPORTED);
         return 0;
     }
 # endif
     ctx = OPENSSL_zalloc(sizeof(*ctx));
     if (ctx == NULL) {
-        COMPerr(COMP_F_BIO_ZLIB_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_COMP, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ctx-&gt;ibufsize = ZLIB_DEFAULT_BUFSIZE;
@@ -381,7 +381,7 @@ static int bio_zlib_read(BIO *b, char *out, int outl)
     if (!ctx-&gt;ibuf) {
         ctx-&gt;ibuf = OPENSSL_malloc(ctx-&gt;ibufsize);
         if (ctx-&gt;ibuf == NULL) {
-            COMPerr(COMP_F_BIO_ZLIB_READ, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_COMP, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         inflateInit(zin);
@@ -397,8 +397,8 @@ static int bio_zlib_read(BIO *b, char *out, int outl)
         while (zin-&gt;avail_in) {
             ret = inflate(zin, 0);
             if ((ret != Z_OK) &amp;&amp; (ret != Z_STREAM_END)) {
-                COMPerr(COMP_F_BIO_ZLIB_READ, COMP_R_ZLIB_INFLATE_ERROR);
-                ERR_add_error_data(2, &quot;zlib error:&quot;, zError(ret));
+                ERR_raise_data(ERR_LIB_COMP, COMP_R_ZLIB_INFLATE_ERROR,
+                               &quot;zlib error: %s&quot;, zError(ret));
                 return 0;
             }
             /* If EOF or we've read everything then return */
@@ -442,7 +442,7 @@ static int bio_zlib_write(BIO *b, const char *in, int inl)
         ctx-&gt;obuf = OPENSSL_malloc(ctx-&gt;obufsize);
         /* Need error here */
         if (ctx-&gt;obuf == NULL) {
-            COMPerr(COMP_F_BIO_ZLIB_WRITE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_COMP, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         ctx-&gt;optr = ctx-&gt;obuf;
@@ -483,8 +483,8 @@ static int bio_zlib_write(BIO *b, const char *in, int inl)
         /* Compress some more */
         ret = deflate(zout, 0);
         if (ret != Z_OK) {
-            COMPerr(COMP_F_BIO_ZLIB_WRITE, COMP_R_ZLIB_DEFLATE_ERROR);
-            ERR_add_error_data(2, &quot;zlib error:&quot;, zError(ret));
+            ERR_raise_data(ERR_LIB_COMP, COMP_R_ZLIB_DEFLATE_ERROR,
+                           &quot;zlib error: %s&quot;, zError(ret));
             return 0;
         }
         ctx-&gt;ocount = ctx-&gt;obufsize - zout-&gt;avail_out;
@@ -532,8 +532,8 @@ static int bio_zlib_flush(BIO *b)
         if (ret == Z_STREAM_END)
             ctx-&gt;odone = 1;
         else if (ret != Z_OK) {
-            COMPerr(COMP_F_BIO_ZLIB_FLUSH, COMP_R_ZLIB_DEFLATE_ERROR);
-            ERR_add_error_data(2, &quot;zlib error:&quot;, zError(ret));
+            ERR_raise_data(ERR_LIB_COMP, COMP_R_ZLIB_DEFLATE_ERROR,
+                           &quot;zlib error: %s&quot;, zError(ret));
             return 0;
         }
         ctx-&gt;ocount = ctx-&gt;obufsize - zout-&gt;avail_out;
diff --git a/crypto/comp/comp_lib.c b/crypto/comp/comp_lib.c
index 49195de3d2..e921709c0f 100644
--- a/crypto/comp/comp_lib.c
+++ b/crypto/comp/comp_lib.c
@@ -20,7 +20,7 @@ COMP_CTX *COMP_CTX_new(COMP_METHOD *meth)
     COMP_CTX *ret;
 
     if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {
-        COMPerr(COMP_F_COMP_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_COMP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;meth = meth;
diff --git a/crypto/conf/conf_def.c b/crypto/conf/conf_def.c
index dd2d16647a..2637e17fd8 100644
--- a/crypto/conf/conf_def.c
+++ b/crypto/conf/conf_def.c
@@ -174,9 +174,9 @@ static int def_load(CONF *conf, const char *name, long *line)
 #endif
     if (in == NULL) {
         if (ERR_GET_REASON(ERR_peek_last_error()) == BIO_R_NO_SUCH_FILE)
-            CONFerr(CONF_F_DEF_LOAD, CONF_R_NO_SUCH_FILE);
+            ERR_raise(ERR_LIB_CONF, CONF_R_NO_SUCH_FILE);
         else
-            CONFerr(CONF_F_DEF_LOAD, ERR_R_SYS_LIB);
+            ERR_raise(ERR_LIB_CONF, ERR_R_SYS_LIB);
         return 0;
     }
 
@@ -208,24 +208,24 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
 #endif
 
     if ((buff = BUF_MEM_new()) == NULL) {
-        CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_CONF, ERR_R_BUF_LIB);
         goto err;
     }
 
     section = OPENSSL_strdup(&quot;default&quot;);
     if (section == NULL) {
-        CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (_CONF_new_data(conf) == 0) {
-        CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     sv = _CONF_new_section(conf, section);
     if (sv == NULL) {
-        CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION);
+        ERR_raise(ERR_LIB_CONF, CONF_R_UNABLE_TO_CREATE_NEW_SECTION);
         goto err;
     }
 
@@ -233,7 +233,7 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
     again = 0;
     for (;;) {
         if (!BUF_MEM_grow(buff, bufnum + CONFBUFSIZE)) {
-            CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB);
+            ERR_raise(ERR_LIB_CONF, ERR_R_BUF_LIB);
             goto err;
         }
         p = &amp;(buff-&gt;data[bufnum]);
@@ -329,8 +329,7 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                     ss = p;
                     goto again;
                 }
-                CONFerr(CONF_F_DEF_LOAD_BIO,
-                        CONF_R_MISSING_CLOSE_SQUARE_BRACKET);
+                ERR_raise(ERR_LIB_CONF, CONF_R_MISSING_CLOSE_SQUARE_BRACKET);
                 goto err;
             }
             *end = '\0';
@@ -339,8 +338,7 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
             if ((sv = _CONF_get_section(conf, section)) == NULL)
                 sv = _CONF_new_section(conf, section);
             if (sv == NULL) {
-                CONFerr(CONF_F_DEF_LOAD_BIO,
-                        CONF_R_UNABLE_TO_CREATE_NEW_SECTION);
+                ERR_raise(ERR_LIB_CONF, CONF_R_UNABLE_TO_CREATE_NEW_SECTION);
                 goto err;
             }
             continue;
@@ -370,7 +368,7 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                 /* Pragma values take the form keyword:value */
                 pval = strchr(p, ':');
                 if (pval == NULL || pval == p || pval[1] == '\0') {
-                    CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_INVALID_PRAGMA);
+                    ERR_raise(ERR_LIB_CONF, CONF_R_INVALID_PRAGMA);
                     goto err;
                 }
 
@@ -391,7 +389,7 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                                || strcmp(pval, &quot;false&quot;) == 0) {
                         conf-&gt;flag_dollarid = 0;
                     } else {
-                        CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_INVALID_PRAGMA);
+                        ERR_raise(ERR_LIB_CONF, CONF_R_INVALID_PRAGMA);
                         goto err;
                     }
                 }
@@ -449,13 +447,13 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                     /* push the currently processing BIO onto stack */
                     if (biosk == NULL) {
                         if ((biosk = sk_BIO_new_null()) == NULL) {
-                            CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);
+                            ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
                             BIO_free(next);
                             goto err;
                         }
                     }
                     if (!sk_BIO_push(biosk, in)) {
-                        CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);
+                        ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
                         BIO_free(next);
                         goto err;
                     }
@@ -464,8 +462,8 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                 }
                 continue;
             } else if (*p != '=') {
-                CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_MISSING_EQUAL_SIGN);
-                ERR_add_error_data(2, &quot;HERE--&gt;&quot;, p);
+                ERR_raise_data(ERR_LIB_CONF, CONF_R_MISSING_EQUAL_SIGN,
+                               &quot;HERE--&gt;%s&quot;, p);
                 goto err;
             }
             *end = '\0';
@@ -474,13 +472,13 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
             trim_ws(conf, start);
 
             if ((v = OPENSSL_malloc(sizeof(*v))) == NULL) {
-                CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             v-&gt;name = OPENSSL_strdup(pname);
             v-&gt;value = NULL;
             if (v-&gt;name == NULL) {
-                CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             if (!str_copy(conf, psection, &amp;(v-&gt;value), start))
@@ -491,14 +489,14 @@ static int def_load_bio(CONF *conf, BIO *in, long *line)
                     == NULL)
                     tv = _CONF_new_section(conf, psection);
                 if (tv == NULL) {
-                    CONFerr(CONF_F_DEF_LOAD_BIO,
-                            CONF_R_UNABLE_TO_CREATE_NEW_SECTION);
+                    ERR_raise(ERR_LIB_CONF,
+                              CONF_R_UNABLE_TO_CREATE_NEW_SECTION);
                     goto err;
                 }
             } else
                 tv = sv;
             if (_CONF_add_string(conf, tv, v) == 0) {
-                CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             v = NULL;
@@ -681,7 +679,7 @@ static int str_copy(CONF *conf, char *section, char **pto, char *from)
             rp = e;
             if (q) {
                 if (r != q) {
-                    CONFerr(CONF_F_STR_COPY, CONF_R_NO_CLOSE_BRACE);
+                    ERR_raise(ERR_LIB_CONF, CONF_R_NO_CLOSE_BRACE);
                     goto err;
                 }
                 e++;
@@ -701,16 +699,16 @@ static int str_copy(CONF *conf, char *section, char **pto, char *from)
                 *rrp = rr;
             *rp = r;
             if (p == NULL) {
-                CONFerr(CONF_F_STR_COPY, CONF_R_VARIABLE_HAS_NO_VALUE);
+                ERR_raise(ERR_LIB_CONF, CONF_R_VARIABLE_HAS_NO_VALUE);
                 goto err;
             }
             newsize = strlen(p) + buf-&gt;length - (e - from);
             if (newsize &gt; MAX_CONF_VALUE_LENGTH) {
-                CONFerr(CONF_F_STR_COPY, CONF_R_VARIABLE_EXPANSION_TOO_LONG);
+                ERR_raise(ERR_LIB_CONF, CONF_R_VARIABLE_EXPANSION_TOO_LONG);
                 goto err;
             }
             if (!BUF_MEM_grow_clean(buf, newsize)) {
-                CONFerr(CONF_F_STR_COPY, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             while (*p)
@@ -755,18 +753,15 @@ static BIO *process_include(char *include, OPENSSL_DIR_CTX **dirctx,
     BIO *next;
 
     if (stat(include, &amp;st) &lt; 0) {
-        ERR_raise_data(ERR_LIB_SYS, errno,
-                       &quot;calling stat(%s)&quot;,
-                       include);
+        ERR_raise_data(ERR_LIB_SYS, errno, &quot;calling stat(%s)&quot;, include);
         /* missing include file is not fatal error */
         return NULL;
     }
 
     if (S_ISDIR(st.st_mode)) {
         if (*dirctx != NULL) {
-            CONFerr(CONF_F_PROCESS_INCLUDE,
-                    CONF_R_RECURSIVE_DIRECTORY_INCLUDE);
-            ERR_add_error_data(1, include);
+            ERR_raise_data(ERR_LIB_CONF, CONF_R_RECURSIVE_DIRECTORY_INCLUDE,
+                           &quot;%s&quot;, include);
             return NULL;
         }
         /* a directory, load its contents */
@@ -804,7 +799,7 @@ static BIO *get_next_file(const char *path, OPENSSL_DIR_CTX **dirctx)
             newlen = pathlen + namelen + 2;
             newpath = OPENSSL_zalloc(newlen);
             if (newpath == NULL) {
-                CONFerr(CONF_F_GET_NEXT_FILE, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
                 break;
             }
 #ifdef OPENSSL_SYS_VMS
diff --git a/crypto/conf/conf_lib.c b/crypto/conf/conf_lib.c
index 7a3ab72247..1f106d8c07 100644
--- a/crypto/conf/conf_lib.c
+++ b/crypto/conf/conf_lib.c
@@ -54,7 +54,7 @@ LHASH_OF(CONF_VALUE) *CONF_load(LHASH_OF(CONF_VALUE) *conf, const char *file,
     in = BIO_new_file(file, &quot;rb&quot;);
 #endif
     if (in == NULL) {
-        CONFerr(CONF_F_CONF_LOAD, ERR_R_SYS_LIB);
+        ERR_raise(ERR_LIB_CONF, ERR_R_SYS_LIB);
         return NULL;
     }
 
@@ -71,7 +71,7 @@ LHASH_OF(CONF_VALUE) *CONF_load_fp(LHASH_OF(CONF_VALUE) *conf, FILE *fp,
     BIO *btmp;
     LHASH_OF(CONF_VALUE) *ltmp;
     if ((btmp = BIO_new_fp(fp, BIO_NOCLOSE)) == NULL) {
-        CONFerr(CONF_F_CONF_LOAD_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_CONF, ERR_R_BUF_LIB);
         return NULL;
     }
     ltmp = CONF_load_bio(conf, btmp, eline);
@@ -153,7 +153,7 @@ int CONF_dump_fp(LHASH_OF(CONF_VALUE) *conf, FILE *out)
     int ret;
 
     if ((btmp = BIO_new_fp(out, BIO_NOCLOSE)) == NULL) {
-        CONFerr(CONF_F_CONF_DUMP_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_CONF, ERR_R_BUF_LIB);
         return 0;
     }
     ret = CONF_dump_bio(conf, btmp);
@@ -187,7 +187,7 @@ CONF *NCONF_new_ex(OSSL_LIB_CTX *libctx, CONF_METHOD *meth)
 
     ret = meth-&gt;create(meth);
     if (ret == NULL) {
-        CONFerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;libctx = libctx;
@@ -217,7 +217,7 @@ void NCONF_free_data(CONF *conf)
 int NCONF_load(CONF *conf, const char *file, long *eline)
 {
     if (conf == NULL) {
-        CONFerr(CONF_F_NCONF_LOAD, CONF_R_NO_CONF);
+        ERR_raise(ERR_LIB_CONF, CONF_R_NO_CONF);
         return 0;
     }
 
@@ -230,7 +230,7 @@ int NCONF_load_fp(CONF *conf, FILE *fp, long *eline)
     BIO *btmp;
     int ret;
     if ((btmp = BIO_new_fp(fp, BIO_NOCLOSE)) == NULL) {
-        CONFerr(CONF_F_NCONF_LOAD_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_CONF, ERR_R_BUF_LIB);
         return 0;
     }
     ret = NCONF_load_bio(conf, btmp, eline);
@@ -242,7 +242,7 @@ int NCONF_load_fp(CONF *conf, FILE *fp, long *eline)
 int NCONF_load_bio(CONF *conf, BIO *bp, long *eline)
 {
     if (conf == NULL) {
-        CONFerr(CONF_F_NCONF_LOAD_BIO, CONF_R_NO_CONF);
+        ERR_raise(ERR_LIB_CONF, CONF_R_NO_CONF);
         return 0;
     }
 
@@ -252,12 +252,12 @@ int NCONF_load_bio(CONF *conf, BIO *bp, long *eline)
 STACK_OF(CONF_VALUE) *NCONF_get_section(const CONF *conf, const char *section)
 {
     if (conf == NULL) {
-        CONFerr(CONF_F_NCONF_GET_SECTION, CONF_R_NO_CONF);
+        ERR_raise(ERR_LIB_CONF, CONF_R_NO_CONF);
         return NULL;
     }
 
     if (section == NULL) {
-        CONFerr(CONF_F_NCONF_GET_SECTION, CONF_R_NO_SECTION);
+        ERR_raise(ERR_LIB_CONF, CONF_R_NO_SECTION);
         return NULL;
     }
 
@@ -276,12 +276,11 @@ char *NCONF_get_string(const CONF *conf, const char *group, const char *name)
         return s;
 
     if (conf == NULL) {
-        CONFerr(CONF_F_NCONF_GET_STRING,
-                CONF_R_NO_CONF_OR_ENVIRONMENT_VARIABLE);
+        ERR_raise(ERR_LIB_CONF, CONF_R_NO_CONF_OR_ENVIRONMENT_VARIABLE);
         return NULL;
     }
-    CONFerr(CONF_F_NCONF_GET_STRING, CONF_R_NO_VALUE);
-    ERR_add_error_data(4, &quot;group=&quot;, group, &quot; name=&quot;, name);
+    ERR_raise_data(ERR_LIB_CONF, CONF_R_NO_VALUE,
+                   &quot;group=%s name=%s&quot;, group, name);
     return NULL;
 }
 
@@ -304,7 +303,7 @@ int NCONF_get_number_e(const CONF *conf, const char *group, const char *name,
     int (*to_int)(const CONF *, char) = &amp;default_to_int;
 
     if (result == NULL) {
-        CONFerr(CONF_F_NCONF_GET_NUMBER_E, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_CONF, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -323,7 +322,7 @@ int NCONF_get_number_e(const CONF *conf, const char *group, const char *name,
         const int d = to_int(conf, *str);
 
         if (res &gt; (LONG_MAX - d) / 10L) {
-            CONFerr(CONF_F_NCONF_GET_NUMBER_E, CONF_R_NUMBER_TOO_LARGE);
+            ERR_raise(ERR_LIB_CONF, CONF_R_NUMBER_TOO_LARGE);
             return 0;
         }
         res = res * 10 + d;
@@ -351,7 +350,7 @@ int NCONF_dump_fp(const CONF *conf, FILE *out)
     BIO *btmp;
     int ret;
     if ((btmp = BIO_new_fp(out, BIO_NOCLOSE)) == NULL) {
-        CONFerr(CONF_F_NCONF_DUMP_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_CONF, ERR_R_BUF_LIB);
         return 0;
     }
     ret = NCONF_dump_bio(conf, btmp);
@@ -363,7 +362,7 @@ int NCONF_dump_fp(const CONF *conf, FILE *out)
 int NCONF_dump_bio(const CONF *conf, BIO *out)
 {
     if (conf == NULL) {
-        CONFerr(CONF_F_NCONF_DUMP_BIO, CONF_R_NO_CONF);
+        ERR_raise(ERR_LIB_CONF, CONF_R_NO_CONF);
         return 0;
     }
 
diff --git a/crypto/conf/conf_mod.c b/crypto/conf/conf_mod.c
index f287cb28eb..cb1bf7cd3c 100644
--- a/crypto/conf/conf_mod.c
+++ b/crypto/conf/conf_mod.c
@@ -121,8 +121,9 @@ int CONF_modules_load(const CONF *cnf, const char *appname,
     if (values == NULL) {
         if (!(flags &amp; CONF_MFLAGS_SILENT)) {
             ERR_clear_last_mark();
-            CONFerr(0, CONF_R_OPENSSL_CONF_REFERENCES_MISSING_SECTION);
-            ERR_add_error_data(2, &quot;openssl_conf=&quot;, vsection);
+            ERR_raise_data(ERR_LIB_CONF,
+                           CONF_R_OPENSSL_CONF_REFERENCES_MISSING_SECTION,
+                           &quot;openssl_conf=%s&quot;, vsection);
         } else {
             ERR_pop_to_mark();
         }
@@ -228,8 +229,8 @@ static int module_run(const CONF *cnf, const char *name, const char *value,
 
     if (!md) {
         if (!(flags &amp; CONF_MFLAGS_SILENT)) {
-            CONFerr(CONF_F_MODULE_RUN, CONF_R_UNKNOWN_MODULE_NAME);
-            ERR_add_error_data(2, &quot;module=&quot;, name);
+            ERR_raise_data(ERR_LIB_CONF, CONF_R_UNKNOWN_MODULE_NAME,
+                           &quot;module=%s&quot;, name);
         }
         return -1;
     }
@@ -237,14 +238,10 @@ static int module_run(const CONF *cnf, const char *name, const char *value,
     ret = module_init(md, name, value, cnf);
 
     if (ret &lt;= 0) {
-        if (!(flags &amp; CONF_MFLAGS_SILENT)) {
-            char rcode[DECIMAL_SIZE(ret) + 1];
-
-            CONFerr(CONF_F_MODULE_RUN, CONF_R_MODULE_INITIALIZATION_ERROR);
-            BIO_snprintf(rcode, sizeof(rcode), &quot;%-8d&quot;, ret);
-            ERR_add_error_data(6, &quot;module=&quot;, name, &quot;, value=&quot;, value,
-                               &quot;, retcode=&quot;, rcode);
-        }
+        if (!(flags &amp; CONF_MFLAGS_SILENT))
+            ERR_raise_data(ERR_LIB_CONF, CONF_R_MODULE_INITIALIZATION_ERROR,
+                           &quot;module=%s, value=%s retcode=%-8d&quot;,
+                           name, value, ret);
     }
 
     return ret;
@@ -287,8 +284,7 @@ static CONF_MODULE *module_load_dso(const CONF *cnf,
 
  err:
     DSO_free(dso);
-    CONFerr(CONF_F_MODULE_LOAD_DSO, errcode);
-    ERR_add_error_data(4, &quot;module=&quot;, name, &quot;, path=&quot;, path);
+    ERR_raise_data(ERR_LIB_CONF, errcode, &quot;module=%s, path=%s&quot;, name, path);
     return NULL;
 }
 
@@ -302,7 +298,7 @@ static CONF_MODULE *module_add(DSO *dso, const char *name,
     if (supported_modules == NULL)
         return NULL;
     if ((tmod = OPENSSL_zalloc(sizeof(*tmod))) == NULL) {
-        CONFerr(CONF_F_MODULE_ADD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -385,13 +381,13 @@ static int module_init(CONF_MODULE *pmod, const char *name, const char *value,
     if (initialized_modules == NULL) {
         initialized_modules = sk_CONF_IMODULE_new_null();
         if (!initialized_modules) {
-            CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
 
     if (!sk_CONF_IMODULE_push(initialized_modules, imod)) {
-        CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -582,7 +578,7 @@ int CONF_parse_list(const char *list_, int sep, int nospc,
     const char *lstart, *tmpend, *p;
 
     if (list_ == NULL) {
-        CONFerr(CONF_F_CONF_PARSE_LIST, CONF_R_LIST_CANNOT_BE_NULL);
+        ERR_raise(ERR_LIB_CONF, CONF_R_LIST_CANNOT_BE_NULL);
         return 0;
     }
 
diff --git a/crypto/conf/conf_ssl.c b/crypto/conf/conf_ssl.c
index 5b949be616..a4b35bab99 100644
--- a/crypto/conf/conf_ssl.c
+++ b/crypto/conf/conf_ssl.c
@@ -68,11 +68,12 @@ static int ssl_module_init(CONF_IMODULE *md, const CONF *cnf)
     ssl_conf_section = CONF_imodule_get_value(md);
     cmd_lists = NCONF_get_section(cnf, ssl_conf_section);
     if (sk_CONF_VALUE_num(cmd_lists) &lt;= 0) {
-        if (cmd_lists == NULL)
-            CONFerr(CONF_F_SSL_MODULE_INIT, CONF_R_SSL_SECTION_NOT_FOUND);
-        else
-            CONFerr(CONF_F_SSL_MODULE_INIT, CONF_R_SSL_SECTION_EMPTY);
-        ERR_add_error_data(2, &quot;section=&quot;, ssl_conf_section);
+        int rcode =
+            cmd_lists == NULL
+            ? CONF_R_SSL_SECTION_NOT_FOUND
+            : CONF_R_SSL_SECTION_EMPTY;
+
+        ERR_raise_data(ERR_LIB_CONF, rcode, &quot;section=%s&quot;, ssl_conf_section);
         goto err;
     }
     cnt = sk_CONF_VALUE_num(cmd_lists);
@@ -87,13 +88,13 @@ static int ssl_module_init(CONF_IMODULE *md, const CONF *cnf)
         STACK_OF(CONF_VALUE) *cmds = NCONF_get_section(cnf, sect-&gt;value);
 
         if (sk_CONF_VALUE_num(cmds) &lt;= 0) {
-            if (cmds == NULL)
-                CONFerr(CONF_F_SSL_MODULE_INIT,
-                        CONF_R_SSL_COMMAND_SECTION_NOT_FOUND);
-            else
-                CONFerr(CONF_F_SSL_MODULE_INIT,
-                        CONF_R_SSL_COMMAND_SECTION_EMPTY);
-            ERR_add_error_data(4, &quot;name=&quot;, sect-&gt;name, &quot;, value=&quot;, sect-&gt;value);
+            int rcode =
+                cmds == NULL
+                ? CONF_R_SSL_COMMAND_SECTION_NOT_FOUND
+                : CONF_R_SSL_COMMAND_SECTION_EMPTY;
+
+            ERR_raise_data(ERR_LIB_CONF, rcode,
+                           &quot;name=%s, value=%s&quot;, sect-&gt;name, sect-&gt;value);
             goto err;
         }
         ssl_name-&gt;name = OPENSSL_strdup(sect-&gt;name);
diff --git a/crypto/crmf/crmf_lib.c b/crypto/crmf/crmf_lib.c
index 9b80c526b5..cb443ff850 100644
--- a/crypto/crmf/crmf_lib.c
+++ b/crypto/crmf/crmf_lib.c
@@ -75,7 +75,7 @@ static int OSSL_CRMF_MSG_push0_regCtrl(OSSL_CRMF_MSG *crm,
     int new = 0;
 
     if (crm == NULL || crm-&gt;certReq == NULL || ctrl == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_PUSH0_REGCTRL, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -110,8 +110,7 @@ int OSSL_CRMF_MSG_set0_SinglePubInfo(OSSL_CRMF_SINGLEPUBINFO *spi,
     if (spi == NULL
             || method &lt; OSSL_CRMF_PUB_METHOD_DONTCARE
             || method &gt; OSSL_CRMF_PUB_METHOD_LDAP) {
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_SET0_SINGLEPUBINFO,
-                ERR_R_PASSED_INVALID_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, ERR_R_PASSED_INVALID_ARGUMENT);
         return 0;
     }
 
@@ -127,8 +126,7 @@ OSSL_CRMF_MSG_PKIPublicationInfo_push0_SinglePubInfo(OSSL_CRMF_PKIPUBLICATIONINF
                                                      OSSL_CRMF_SINGLEPUBINFO *spi)
 {
     if (pi == NULL || spi == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_PKIPUBLICATIONINFO_PUSH0_SINGLEPUBINFO,
-                CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
     if (pi-&gt;pubInfos == NULL)
@@ -145,8 +143,7 @@ int OSSL_CRMF_MSG_set_PKIPublicationInfo_action(OSSL_CRMF_PKIPUBLICATIONINFO *pi
     if (pi == NULL
             || action &lt; OSSL_CRMF_PUB_ACTION_DONTPUBLISH
             || action &gt; OSSL_CRMF_PUB_ACTION_PLEASEPUBLISH) {
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_SET_PKIPUBLICATIONINFO_ACTION,
-                ERR_R_PASSED_INVALID_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, ERR_R_PASSED_INVALID_ARGUMENT);
         return 0;
     }
 
@@ -166,7 +163,7 @@ OSSL_CRMF_CERTID *OSSL_CRMF_CERTID_gen(const X509_NAME *issuer,
     OSSL_CRMF_CERTID *cid = NULL;
 
     if (issuer == NULL || serial == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_CERTID_GEN, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return NULL;
     }
 
@@ -204,7 +201,7 @@ static int OSSL_CRMF_MSG_push0_regInfo(OSSL_CRMF_MSG *crm,
     STACK_OF(OSSL_CRMF_ATTRIBUTETYPEANDVALUE) *info = NULL;
 
     if (crm == NULL || ri == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_PUSH0_REGINFO, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -234,7 +231,7 @@ IMPLEMENT_CRMF_CTRL_FUNC(certReq, OSSL_CRMF_CERTREQUEST, regInfo)
 OSSL_CRMF_CERTTEMPLATE *OSSL_CRMF_MSG_get0_tmpl(const OSSL_CRMF_MSG *crm)
 {
     if (crm == NULL || crm-&gt;certReq == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_GET0_TMPL, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return NULL;
     }
     return crm-&gt;certReq-&gt;certTemplate;
@@ -248,7 +245,7 @@ int OSSL_CRMF_MSG_set0_validity(OSSL_CRMF_MSG *crm,
     OSSL_CRMF_CERTTEMPLATE *tmpl = OSSL_CRMF_MSG_get0_tmpl(crm);
 
     if (tmpl == NULL) { /* also crm == NULL implies this */
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_SET0_VALIDITY, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -264,7 +261,7 @@ int OSSL_CRMF_MSG_set0_validity(OSSL_CRMF_MSG *crm,
 int OSSL_CRMF_MSG_set_certReqId(OSSL_CRMF_MSG *crm, int rid)
 {
     if (crm == NULL || crm-&gt;certReq == NULL || crm-&gt;certReq-&gt;certReqId == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_SET_CERTREQID, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -277,15 +274,15 @@ static int crmf_asn1_get_int(const ASN1_INTEGER *a)
     int64_t res;
 
     if (!ASN1_INTEGER_get_int64(&amp;res, a)) {
-        CRMFerr(0, ASN1_R_INVALID_NUMBER);
+        ERR_raise(ERR_LIB_CRMF, ASN1_R_INVALID_NUMBER);
         return -1;
     }
     if (res &lt; INT_MIN) {
-        CRMFerr(0, ASN1_R_TOO_SMALL);
+        ERR_raise(ERR_LIB_CRMF, ASN1_R_TOO_SMALL);
         return -1;
     }
     if (res &gt; INT_MAX) {
-        CRMFerr(0, ASN1_R_TOO_LARGE);
+        ERR_raise(ERR_LIB_CRMF, ASN1_R_TOO_LARGE);
         return -1;
     }
     return (int)res;
@@ -294,7 +291,7 @@ static int crmf_asn1_get_int(const ASN1_INTEGER *a)
 int OSSL_CRMF_MSG_get_certReqId(const OSSL_CRMF_MSG *crm)
 {
     if (crm == NULL || /* not really needed: */ crm-&gt;certReq == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_GET_CERTREQID, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return -1;
     }
     return crmf_asn1_get_int(crm-&gt;certReq-&gt;certReqId);
@@ -307,7 +304,7 @@ int OSSL_CRMF_MSG_set0_extensions(OSSL_CRMF_MSG *crm,
     OSSL_CRMF_CERTTEMPLATE *tmpl = OSSL_CRMF_MSG_get0_tmpl(crm);
 
     if (tmpl == NULL) { /* also crm == NULL implies this */
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_SET0_EXTENSIONS, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -329,7 +326,7 @@ int OSSL_CRMF_MSG_push0_extension(OSSL_CRMF_MSG *crm,
     OSSL_CRMF_CERTTEMPLATE *tmpl = OSSL_CRMF_MSG_get0_tmpl(crm);
 
     if (tmpl == NULL || ext == NULL) { /* also crm == NULL implies this */
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_PUSH0_EXTENSION, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -356,12 +353,12 @@ static int create_popo_signature(OSSL_CRMF_POPOSIGNINGKEY *ps,
                                  OSSL_LIB_CTX *libctx, const char *propq)
 {
     if (ps == NULL || cr == NULL || pkey == NULL) {
-        CRMFerr(0, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
     if (ps-&gt;poposkInput != NULL) {
         /* TODO: support cases 1+2 defined in RFC 4211, section 4.1 */
-        CRMFerr(0, CRMF_R_POPOSKINPUT_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_POPOSKINPUT_NOT_SUPPORTED);
         return 0;
     }
 
@@ -379,7 +376,7 @@ int OSSL_CRMF_MSG_create_popo(int meth, OSSL_CRMF_MSG *crm,
     ASN1_INTEGER *tag = NULL;
 
     if (crm == NULL || (meth == OSSL_CRMF_POPO_SIGNATURE &amp;&amp; pkey == NULL)) {
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_CREATE_POPO, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
 
@@ -423,8 +420,7 @@ int OSSL_CRMF_MSG_create_popo(int meth, OSSL_CRMF_MSG *crm,
         break;
 
     default:
-        CRMFerr(CRMF_F_OSSL_CRMF_MSG_CREATE_POPO,
-                CRMF_R_UNSUPPORTED_METHOD_FOR_CREATING_POPO);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_UNSUPPORTED_METHOD_FOR_CREATING_POPO);
         goto err;
     }
 
@@ -450,26 +446,26 @@ int OSSL_CRMF_MSGS_verify_popo(const OSSL_CRMF_MSGS *reqs,
     void *asn;
 
     if (reqs == NULL || (req = sk_OSSL_CRMF_MSG_value(reqs, rid)) == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_MSGS_VERIFY_POPO, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
 
     if (req-&gt;popo == NULL) {
-        CRMFerr(0, CRMF_R_POPO_MISSING);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_POPO_MISSING);
         return 0;
     }
 
     switch (req-&gt;popo-&gt;type) {
     case OSSL_CRMF_POPO_RAVERIFIED:
         if (!acceptRAVerified) {
-            CRMFerr(0, CRMF_R_POPO_RAVERIFIED_NOT_ACCEPTED);
+            ERR_raise(ERR_LIB_CRMF, CRMF_R_POPO_RAVERIFIED_NOT_ACCEPTED);
             return 0;
         }
         break;
     case OSSL_CRMF_POPO_SIGNATURE:
         pubkey = req-&gt;certReq-&gt;certTemplate-&gt;publicKey;
         if (pubkey == NULL) {
-            CRMFerr(0, CRMF_R_POPO_MISSING_PUBLIC_KEY);
+            ERR_raise(ERR_LIB_CRMF, CRMF_R_POPO_MISSING_PUBLIC_KEY);
             return 0;
         }
         sig = req-&gt;popo-&gt;value.signature;
@@ -480,11 +476,11 @@ int OSSL_CRMF_MSGS_verify_popo(const OSSL_CRMF_MSGS *reqs,
              * exactly the same value as contained in the certificate template.
              */
             if (sig-&gt;poposkInput-&gt;publicKey == NULL) {
-                CRMFerr(0, CRMF_R_POPO_MISSING_PUBLIC_KEY);
+                ERR_raise(ERR_LIB_CRMF, CRMF_R_POPO_MISSING_PUBLIC_KEY);
                 return 0;
             }
             if (X509_PUBKEY_eq(pubkey, sig-&gt;poposkInput-&gt;publicKey) != 1) {
-                CRMFerr(0, CRMF_R_POPO_INCONSISTENT_PUBLIC_KEY);
+                ERR_raise(ERR_LIB_CRMF, CRMF_R_POPO_INCONSISTENT_PUBLIC_KEY);
                 return 0;
             }
             /*
@@ -495,7 +491,7 @@ int OSSL_CRMF_MSGS_verify_popo(const OSSL_CRMF_MSGS *reqs,
             asn = sig-&gt;poposkInput;
         } else {
             if (req-&gt;certReq-&gt;certTemplate-&gt;subject == NULL) {
-                CRMFerr(0, CRMF_R_POPO_MISSING_SUBJECT);
+                ERR_raise(ERR_LIB_CRMF, CRMF_R_POPO_MISSING_SUBJECT);
                 return 0;
             }
             it = ASN1_ITEM_rptr(OSSL_CRMF_CERTREQUEST);
@@ -515,8 +511,7 @@ int OSSL_CRMF_MSGS_verify_popo(const OSSL_CRMF_MSGS *reqs,
          */
     case OSSL_CRMF_POPO_KEYAGREE:
     default:
-        CRMFerr(CRMF_F_OSSL_CRMF_MSGS_VERIFY_POPO,
-                CRMF_R_UNSUPPORTED_POPO_METHOD);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_UNSUPPORTED_POPO_METHOD);
         return 0;
     }
     return 1;
@@ -560,7 +555,7 @@ int OSSL_CRMF_CERTTEMPLATE_fill(OSSL_CRMF_CERTTEMPLATE *tmpl,
                                 const ASN1_INTEGER *serial)
 {
     if (tmpl == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_CERTTEMPLATE_FILL, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
     }
     if (subject != NULL &amp;&amp; !X509_NAME_set((X509_NAME **)&amp;tmpl-&gt;subject, subject))
@@ -605,19 +600,16 @@ X509
 
     if (ecert == NULL || ecert-&gt;symmAlg == NULL || ecert-&gt;encSymmKey == NULL
             || ecert-&gt;encValue == NULL || pkey == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_ENCRYPTEDVALUE_GET1_ENCCERT,
-                CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return NULL;
     }
     if ((symmAlg = OBJ_obj2nid(ecert-&gt;symmAlg-&gt;algorithm)) == 0) {
-        CRMFerr(CRMF_F_OSSL_CRMF_ENCRYPTEDVALUE_GET1_ENCCERT,
-                CRMF_R_UNSUPPORTED_CIPHER);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_UNSUPPORTED_CIPHER);
         return NULL;
     }
     /* select symmetric cipher based on algorithm given in message */
     if ((cipher = EVP_get_cipherbynid(symmAlg)) == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_ENCRYPTEDVALUE_GET1_ENCCERT,
-                CRMF_R_UNSUPPORTED_CIPHER);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_UNSUPPORTED_CIPHER);
         goto end;
     }
     cikeysize = EVP_CIPHER_key_length(cipher);
@@ -639,8 +631,7 @@ X509
                                            | constant_time_is_zero(retval));
         failure |= ~constant_time_eq_s(eksize, (size_t)cikeysize);
         if (failure) {
-            CRMFerr(CRMF_F_OSSL_CRMF_ENCRYPTEDVALUE_GET1_ENCCERT,
-                    CRMF_R_ERROR_DECRYPTING_SYMMETRIC_KEY);
+            ERR_raise(ERR_LIB_CRMF, CRMF_R_ERROR_DECRYPTING_SYMMETRIC_KEY);
             goto end;
         }
     } else {
@@ -651,8 +642,7 @@ X509
     if (ASN1_TYPE_get_octetstring(ecert-&gt;symmAlg-&gt;parameter, iv,
                                   EVP_CIPHER_iv_length(cipher))
         != EVP_CIPHER_iv_length(cipher)) {
-        CRMFerr(CRMF_F_OSSL_CRMF_ENCRYPTEDVALUE_GET1_ENCCERT,
-                CRMF_R_MALFORMED_IV);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_MALFORMED_IV);
         goto end;
     }
 
@@ -671,8 +661,7 @@ X509
                                   ecert-&gt;encValue-&gt;data,
                                   ecert-&gt;encValue-&gt;length)
             || !EVP_DecryptFinal(evp_ctx, outbuf + outlen, &amp;n)) {
-        CRMFerr(CRMF_F_OSSL_CRMF_ENCRYPTEDVALUE_GET1_ENCCERT,
-                CRMF_R_ERROR_DECRYPTING_CERTIFICATE);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_ERROR_DECRYPTING_CERTIFICATE);
         goto end;
     }
     outlen += n;
@@ -681,8 +670,7 @@ X509
     if ((cert = X509_new_ex(libctx, propq)) == NULL)
         goto end;
     if (d2i_X509(&amp;cert, &amp;p, outlen) == NULL)
-        CRMFerr(CRMF_F_OSSL_CRMF_ENCRYPTEDVALUE_GET1_ENCCERT,
-                CRMF_R_ERROR_DECODING_CERTIFICATE);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_ERROR_DECODING_CERTIFICATE);
  end:
     EVP_PKEY_CTX_free(pkctx);
     OPENSSL_free(outbuf);
diff --git a/crypto/crmf/crmf_pbm.c b/crypto/crmf/crmf_pbm.c
index 9ad6ec149c..ffa94667ee 100644
--- a/crypto/crmf/crmf_pbm.c
+++ b/crypto/crmf/crmf_pbm.c
@@ -53,7 +53,7 @@ OSSL_CRMF_PBMPARAMETER *OSSL_CRMF_pbmp_new(OSSL_LIB_CTX *libctx, size_t slen,
     if ((salt = OPENSSL_malloc(slen)) == NULL)
         goto err;
     if (RAND_bytes_ex(libctx, salt, (int)slen) &lt;= 0) {
-        CRMFerr(CRMF_F_OSSL_CRMF_PBMP_NEW, CRMF_R_FAILURE_OBTAINING_RANDOM);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_FAILURE_OBTAINING_RANDOM);
         goto err;
     }
     if (!ASN1_OCTET_STRING_set(pbm-&gt;salt, salt, (int)slen))
@@ -65,7 +65,7 @@ OSSL_CRMF_PBMPARAMETER *OSSL_CRMF_pbmp_new(OSSL_LIB_CTX *libctx, size_t slen,
      * support SHA-1.
      */
     if (!X509_ALGOR_set0(pbm-&gt;owf, OBJ_nid2obj(owfnid), V_ASN1_UNDEF, NULL)) {
-        CRMFerr(CRMF_F_OSSL_CRMF_PBMP_NEW, CRMF_R_SETTING_OWF_ALGOR_FAILURE);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_SETTING_OWF_ALGOR_FAILURE);
         goto err;
     }
 
@@ -80,16 +80,16 @@ OSSL_CRMF_PBMPARAMETER *OSSL_CRMF_pbmp_new(OSSL_LIB_CTX *libctx, size_t slen,
      * this may not be true with all hash functions in the future.
      */
     if (itercnt &lt; 100) {
-        CRMFerr(CRMF_F_OSSL_CRMF_PBMP_NEW, CRMF_R_ITERATIONCOUNT_BELOW_100);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_ITERATIONCOUNT_BELOW_100);
         goto err;
     }
     if (itercnt &gt; OSSL_CRMF_PBM_MAX_ITERATION_COUNT) {
-        CRMFerr(CRMF_F_OSSL_CRMF_PBMP_NEW, CRMF_R_BAD_PBM_ITERATIONCOUNT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_BAD_PBM_ITERATIONCOUNT);
         goto err;
     }
 
     if (!ASN1_INTEGER_set(pbm-&gt;iterationCount, itercnt)) {
-        CRMFerr(CRMF_F_OSSL_CRMF_PBMP_NEW, CRMF_R_CRMFERROR);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_CRMFERROR);
         goto err;
     }
 
@@ -99,7 +99,7 @@ OSSL_CRMF_PBMPARAMETER *OSSL_CRMF_pbmp_new(OSSL_LIB_CTX *libctx, size_t slen,
      * All implementations SHOULD support DES-MAC and Triple-DES-MAC [PKCS11].
      */
     if (!X509_ALGOR_set0(pbm-&gt;mac, OBJ_nid2obj(macnid), V_ASN1_UNDEF, NULL)) {
-        CRMFerr(CRMF_F_OSSL_CRMF_PBMP_NEW, CRMF_R_SETTING_MAC_ALGOR_FAILURE);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_SETTING_MAC_ALGOR_FAILURE);
         goto err;
     }
 
@@ -144,7 +144,7 @@ int OSSL_CRMF_pbm_new(OSSL_LIB_CTX *libctx, const char *propq,
 
     if (out == NULL || pbmp == NULL || pbmp-&gt;mac == NULL
             || pbmp-&gt;mac-&gt;algorithm == NULL || msg == NULL || sec == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_PBM_NEW, CRMF_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         goto err;
     }
     if ((mac_res = OPENSSL_malloc(EVP_MAX_MD_SIZE)) == NULL)
@@ -157,7 +157,7 @@ int OSSL_CRMF_pbm_new(OSSL_LIB_CTX *libctx, const char *propq,
      */
     mdname = OBJ_nid2sn(OBJ_obj2nid(pbmp-&gt;owf-&gt;algorithm));
     if ((owf = EVP_MD_fetch(libctx, mdname, propq)) == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_PBM_NEW, CRMF_R_UNSUPPORTED_ALGORITHM);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_UNSUPPORTED_ALGORITHM);
         goto err;
     }
 
@@ -178,7 +178,7 @@ int OSSL_CRMF_pbm_new(OSSL_LIB_CTX *libctx, const char *propq,
     if (!ASN1_INTEGER_get_int64(&amp;iterations, pbmp-&gt;iterationCount)
             || iterations &lt; 100 /* min from RFC */
             || iterations &gt; OSSL_CRMF_PBM_MAX_ITERATION_COUNT) {
-        CRMFerr(CRMF_F_OSSL_CRMF_PBM_NEW, CRMF_R_BAD_PBM_ITERATIONCOUNT);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_BAD_PBM_ITERATIONCOUNT);
         goto err;
     }
 
@@ -201,7 +201,7 @@ int OSSL_CRMF_pbm_new(OSSL_LIB_CTX *libctx, const char *propq,
 
     if (!EVP_PBE_find(EVP_PBE_TYPE_PRF, mac_nid, NULL, &amp;hmac_md_nid, NULL)
             || (mdname = OBJ_nid2sn(hmac_md_nid)) == NULL) {
-        CRMFerr(CRMF_F_OSSL_CRMF_PBM_NEW, CRMF_R_UNSUPPORTED_ALGORITHM);
+        ERR_raise(ERR_LIB_CRMF, CRMF_R_UNSUPPORTED_ALGORITHM);
         goto err;
     }
 
diff --git a/crypto/ct/ct_b64.c b/crypto/ct/ct_b64.c
index 5e80e4e44b..8dd137096c 100644
--- a/crypto/ct/ct_b64.c
+++ b/crypto/ct/ct_b64.c
@@ -35,13 +35,13 @@ static int ct_base64_decode(const char *in, unsigned char **out)
     outlen = (inlen / 4) * 3;
     outbuf = OPENSSL_malloc(outlen);
     if (outbuf == NULL) {
-        CTerr(CT_F_CT_BASE64_DECODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     outlen = EVP_DecodeBlock(outbuf, (unsigned char *)in, inlen);
     if (outlen &lt; 0) {
-        CTerr(CT_F_CT_BASE64_DECODE, CT_R_BASE64_DECODE_ERROR);
+        ERR_raise(ERR_LIB_CT, CT_R_BASE64_DECODE_ERROR);
         goto err;
     }
 
@@ -71,7 +71,7 @@ SCT *SCT_new_from_base64(unsigned char version, const char *logid_base64,
     int declen;
 
     if (sct == NULL) {
-        CTerr(CT_F_SCT_NEW_FROM_BASE64, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -80,13 +80,13 @@ SCT *SCT_new_from_base64(unsigned char version, const char *logid_base64,
      * can only construct SCT versions that have been defined.
      */
     if (!SCT_set_version(sct, version)) {
-        CTerr(CT_F_SCT_NEW_FROM_BASE64, CT_R_SCT_UNSUPPORTED_VERSION);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_UNSUPPORTED_VERSION);
         goto err;
     }
 
     declen = ct_base64_decode(logid_base64, &amp;dec);
     if (declen &lt; 0) {
-        CTerr(CT_F_SCT_NEW_FROM_BASE64, X509_R_BASE64_DECODE_ERROR);
+        ERR_raise(ERR_LIB_CT, X509_R_BASE64_DECODE_ERROR);
         goto err;
     }
     if (!SCT_set0_log_id(sct, dec, declen))
@@ -95,7 +95,7 @@ SCT *SCT_new_from_base64(unsigned char version, const char *logid_base64,
 
     declen = ct_base64_decode(extensions_base64, &amp;dec);
     if (declen &lt; 0) {
-        CTerr(CT_F_SCT_NEW_FROM_BASE64, X509_R_BASE64_DECODE_ERROR);
+        ERR_raise(ERR_LIB_CT, X509_R_BASE64_DECODE_ERROR);
         goto err;
     }
     SCT_set0_extensions(sct, dec, declen);
@@ -103,7 +103,7 @@ SCT *SCT_new_from_base64(unsigned char version, const char *logid_base64,
 
     declen = ct_base64_decode(signature_base64, &amp;dec);
     if (declen &lt; 0) {
-        CTerr(CT_F_SCT_NEW_FROM_BASE64, X509_R_BASE64_DECODE_ERROR);
+        ERR_raise(ERR_LIB_CT, X509_R_BASE64_DECODE_ERROR);
         goto err;
     }
 
@@ -142,13 +142,13 @@ int CTLOG_new_from_base64_ex(CTLOG **ct_log, const char *pkey_base64,
     EVP_PKEY *pkey = NULL;
 
     if (ct_log == NULL) {
-        CTerr(0, ERR_R_PASSED_INVALID_ARGUMENT);
+        ERR_raise(ERR_LIB_CT, ERR_R_PASSED_INVALID_ARGUMENT);
         return 0;
     }
 
     pkey_der_len = ct_base64_decode(pkey_base64, &amp;pkey_der);
     if (pkey_der_len &lt; 0) {
-        CTerr(0, CT_R_LOG_CONF_INVALID_KEY);
+        ERR_raise(ERR_LIB_CT, CT_R_LOG_CONF_INVALID_KEY);
         return 0;
     }
 
@@ -156,7 +156,7 @@ int CTLOG_new_from_base64_ex(CTLOG **ct_log, const char *pkey_base64,
     pkey = d2i_PUBKEY(NULL, &amp;p, pkey_der_len);
     OPENSSL_free(pkey_der);
     if (pkey == NULL) {
-        CTerr(0, CT_R_LOG_CONF_INVALID_KEY);
+        ERR_raise(ERR_LIB_CT, CT_R_LOG_CONF_INVALID_KEY);
         return 0;
     }
 
diff --git a/crypto/ct/ct_log.c b/crypto/ct/ct_log.c
index 11fc9d4367..d41039e5b4 100644
--- a/crypto/ct/ct_log.c
+++ b/crypto/ct/ct_log.c
@@ -63,7 +63,7 @@ static CTLOG_STORE_LOAD_CTX *ctlog_store_load_ctx_new(void)
     CTLOG_STORE_LOAD_CTX *ctx = OPENSSL_zalloc(sizeof(*ctx));
 
     if (ctx == NULL)
-        CTerr(CT_F_CTLOG_STORE_LOAD_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
 
     return ctx;
 }
@@ -83,12 +83,12 @@ static int ct_v1_log_id_from_pkey(CTLOG *log, EVP_PKEY *pkey)
     EVP_MD *sha256 = NULL;
 
     if (pkey_der_len &lt;= 0) {
-        CTerr(CT_F_CT_V1_LOG_ID_FROM_PKEY, CT_R_LOG_KEY_INVALID);
+        ERR_raise(ERR_LIB_CT, CT_R_LOG_KEY_INVALID);
         goto err;
     }
     sha256 = EVP_MD_fetch(log-&gt;libctx, &quot;SHA2-256&quot;, log-&gt;propq);
     if (sha256 == NULL) {
-        CTerr(CT_F_CT_V1_LOG_ID_FROM_PKEY, ERR_LIB_EVP);
+        ERR_raise(ERR_LIB_CT, ERR_LIB_EVP);
         goto err;
     }
 
@@ -105,7 +105,7 @@ CTLOG_STORE *CTLOG_STORE_new_ex(OSSL_LIB_CTX *libctx, const char *propq)
     CTLOG_STORE *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        CTerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -113,14 +113,14 @@ CTLOG_STORE *CTLOG_STORE_new_ex(OSSL_LIB_CTX *libctx, const char *propq)
     if (propq != NULL) {
         ret-&gt;propq = OPENSSL_strdup(propq);
         if (ret-&gt;propq == NULL) {
-            CTerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
 
     ret-&gt;logs = sk_CTLOG_new_null();
     if (ret-&gt;logs == NULL) {
-        CTerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -151,13 +151,13 @@ static int ctlog_new_from_conf(CTLOG_STORE *store, CTLOG **ct_log,
     char *pkey_base64;
 
     if (description == NULL) {
-        CTerr(CT_F_CTLOG_NEW_FROM_CONF, CT_R_LOG_CONF_MISSING_DESCRIPTION);
+        ERR_raise(ERR_LIB_CT, CT_R_LOG_CONF_MISSING_DESCRIPTION);
         return 0;
     }
 
     pkey_base64 = NCONF_get_string(conf, section, &quot;key&quot;);
     if (pkey_base64 == NULL) {
-        CTerr(CT_F_CTLOG_NEW_FROM_CONF, CT_R_LOG_CONF_MISSING_KEY);
+        ERR_raise(ERR_LIB_CT, CT_R_LOG_CONF_MISSING_KEY);
         return 0;
     }
 
@@ -218,7 +218,7 @@ static int ctlog_store_load_log(const char *log_name, int log_name_len,
 
 mem_err:
     CTLOG_free(ct_log);
-    CTerr(CT_F_CTLOG_STORE_LOAD_LOG, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
     return -1;
 }
 
@@ -236,19 +236,19 @@ int CTLOG_STORE_load_file(CTLOG_STORE *store, const char *file)
         goto end;
 
     if (NCONF_load(load_ctx-&gt;conf, file, NULL) &lt;= 0) {
-        CTerr(CT_F_CTLOG_STORE_LOAD_FILE, CT_R_LOG_CONF_INVALID);
+        ERR_raise(ERR_LIB_CT, CT_R_LOG_CONF_INVALID);
         goto end;
     }
 
     enabled_logs = NCONF_get_string(load_ctx-&gt;conf, NULL, &quot;enabled_logs&quot;);
     if (enabled_logs == NULL) {
-        CTerr(CT_F_CTLOG_STORE_LOAD_FILE, CT_R_LOG_CONF_INVALID);
+        ERR_raise(ERR_LIB_CT, CT_R_LOG_CONF_INVALID);
         goto end;
     }
 
     if (!CONF_parse_list(enabled_logs, ',', 1, ctlog_store_load_log, load_ctx) ||
         load_ctx-&gt;invalid_log_entries &gt; 0) {
-        CTerr(CT_F_CTLOG_STORE_LOAD_FILE, CT_R_LOG_CONF_INVALID);
+        ERR_raise(ERR_LIB_CT, CT_R_LOG_CONF_INVALID);
         goto end;
     }
 
@@ -270,7 +270,7 @@ CTLOG *CTLOG_new_ex(EVP_PKEY *public_key, const char *name, OSSL_LIB_CTX *libctx
     CTLOG *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        CTerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -278,14 +278,14 @@ CTLOG *CTLOG_new_ex(EVP_PKEY *public_key, const char *name, OSSL_LIB_CTX *libctx
     if (propq != NULL) {
         ret-&gt;name = OPENSSL_strdup(propq);
         if (ret-&gt;propq == NULL) {
-            CTerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
 
     ret-&gt;name = OPENSSL_strdup(name);
     if (ret-&gt;name == NULL) {
-        CTerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
diff --git a/crypto/ct/ct_oct.c b/crypto/ct/ct_oct.c
index 712fc563c4..72a4337479 100644
--- a/crypto/ct/ct_oct.c
+++ b/crypto/ct/ct_oct.c
@@ -28,7 +28,7 @@ int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len)
     const unsigned char *p;
 
     if (sct-&gt;version != SCT_VERSION_V1) {
-        CTerr(CT_F_O2I_SCT_SIGNATURE, CT_R_UNSUPPORTED_VERSION);
+        ERR_raise(ERR_LIB_CT, CT_R_UNSUPPORTED_VERSION);
         return -1;
     }
     /*
@@ -39,7 +39,7 @@ int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len)
      * all supported algorithms.
      */
     if (len &lt;= 4) {
-        CTerr(CT_F_O2I_SCT_SIGNATURE, CT_R_SCT_INVALID_SIGNATURE);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_INVALID_SIGNATURE);
         return -1;
     }
 
@@ -48,14 +48,14 @@ int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len)
     sct-&gt;hash_alg = *p++;
     sct-&gt;sig_alg = *p++;
     if (SCT_get_signature_nid(sct) == NID_undef) {
-        CTerr(CT_F_O2I_SCT_SIGNATURE, CT_R_SCT_INVALID_SIGNATURE);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_INVALID_SIGNATURE);
         return -1;
     }
     /* Retrieve signature and check it is consistent with the buffer length */
     n2s(p, siglen);
     len_remaining -= (p - *in);
     if (siglen &gt; len_remaining) {
-        CTerr(CT_F_O2I_SCT_SIGNATURE, CT_R_SCT_INVALID_SIGNATURE);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_INVALID_SIGNATURE);
         return -1;
     }
 
@@ -73,7 +73,7 @@ SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len)
     const unsigned char *p;
 
     if (len == 0 || len &gt; MAX_SCT_SIZE) {
-        CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_INVALID);
         goto err;
     }
 
@@ -96,7 +96,7 @@ SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len)
          *   }
          */
         if (len &lt; 43) {
-            CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);
+            ERR_raise(ERR_LIB_CT, CT_R_SCT_INVALID);
             goto err;
         }
         len -= 43;
@@ -111,7 +111,7 @@ SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len)
 
         n2s(p, len2);
         if (len &lt; len2) {
-            CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);
+            ERR_raise(ERR_LIB_CT, CT_R_SCT_INVALID);
             goto err;
         }
         if (len2 &gt; 0) {
@@ -125,7 +125,7 @@ SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len)
 
         sig_len = o2i_SCT_signature(sct, &amp;p, len);
         if (sig_len &lt;= 0) {
-            CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);
+            ERR_raise(ERR_LIB_CT, CT_R_SCT_INVALID);
             goto err;
         }
         len -= sig_len;
@@ -156,12 +156,12 @@ int i2o_SCT_signature(const SCT *sct, unsigned char **out)
     unsigned char *p = NULL, *pstart = NULL;
 
     if (!SCT_signature_is_complete(sct)) {
-        CTerr(CT_F_I2O_SCT_SIGNATURE, CT_R_SCT_INVALID_SIGNATURE);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_INVALID_SIGNATURE);
         goto err;
     }
 
     if (sct-&gt;version != SCT_VERSION_V1) {
-        CTerr(CT_F_I2O_SCT_SIGNATURE, CT_R_UNSUPPORTED_VERSION);
+        ERR_raise(ERR_LIB_CT, CT_R_UNSUPPORTED_VERSION);
         goto err;
     }
 
@@ -179,7 +179,7 @@ int i2o_SCT_signature(const SCT *sct, unsigned char **out)
         } else {
             pstart = p = OPENSSL_malloc(len);
             if (p == NULL) {
-                CTerr(CT_F_I2O_SCT_SIGNATURE, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             *out = p;
@@ -203,7 +203,7 @@ int i2o_SCT(const SCT *sct, unsigned char **out)
     unsigned char *p = NULL, *pstart = NULL;
 
     if (!SCT_is_complete(sct)) {
-        CTerr(CT_F_I2O_SCT, CT_R_SCT_NOT_SET);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_NOT_SET);
         goto err;
     }
     /*
@@ -226,7 +226,7 @@ int i2o_SCT(const SCT *sct, unsigned char **out)
     } else {
         pstart = p = OPENSSL_malloc(len);
         if (p == NULL) {
-            CTerr(CT_F_I2O_SCT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         *out = p;
@@ -261,13 +261,13 @@ STACK_OF(SCT) *o2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,
     size_t list_len, sct_len;
 
     if (len &lt; 2 || len &gt; MAX_SCT_LIST_SIZE) {
-        CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_LIST_INVALID);
         return NULL;
     }
 
     n2s(*pp, list_len);
     if (list_len != len - 2) {
-        CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_LIST_INVALID);
         return NULL;
     }
 
@@ -288,14 +288,14 @@ STACK_OF(SCT) *o2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,
         SCT *sct;
 
         if (list_len &lt; 2) {
-            CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);
+            ERR_raise(ERR_LIB_CT, CT_R_SCT_LIST_INVALID);
             goto err;
         }
         n2s(*pp, sct_len);
         list_len -= 2;
 
         if (sct_len == 0 || sct_len &gt; list_len) {
-            CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);
+            ERR_raise(ERR_LIB_CT, CT_R_SCT_LIST_INVALID);
             goto err;
         }
         list_len -= sct_len;
@@ -327,11 +327,11 @@ int i2o_SCT_LIST(const STACK_OF(SCT) *a, unsigned char **pp)
     if (pp != NULL) {
         if (*pp == NULL) {
             if ((len = i2o_SCT_LIST(a, NULL)) == -1) {
-                CTerr(CT_F_I2O_SCT_LIST, CT_R_SCT_LIST_INVALID);
+                ERR_raise(ERR_LIB_CT, CT_R_SCT_LIST_INVALID);
                 return -1;
             }
             if ((*pp = OPENSSL_malloc(len)) == NULL) {
-                CTerr(CT_F_I2O_SCT_LIST, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
                 return -1;
             }
             is_pp_new = 1;
diff --git a/crypto/ct/ct_policy.c b/crypto/ct/ct_policy.c
index a33c618cf5..80a8baabe1 100644
--- a/crypto/ct/ct_policy.c
+++ b/crypto/ct/ct_policy.c
@@ -31,7 +31,7 @@ CT_POLICY_EVAL_CTX *CT_POLICY_EVAL_CTX_new_ex(OSSL_LIB_CTX *libctx,
     CT_POLICY_EVAL_CTX *ctx = OPENSSL_zalloc(sizeof(CT_POLICY_EVAL_CTX));
 
     if (ctx == NULL) {
-        CTerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -39,7 +39,7 @@ CT_POLICY_EVAL_CTX *CT_POLICY_EVAL_CTX_new_ex(OSSL_LIB_CTX *libctx,
     if (propq != NULL) {
         ctx-&gt;propq = OPENSSL_strdup(propq);
         if (ctx-&gt;propq == NULL) {
-            CTerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
             OPENSSL_free(ctx);
             return NULL;
         }
diff --git a/crypto/ct/ct_sct.c b/crypto/ct/ct_sct.c
index 1b8e1dc61e..ab22ecafad 100644
--- a/crypto/ct/ct_sct.c
+++ b/crypto/ct/ct_sct.c
@@ -24,7 +24,7 @@ SCT *SCT_new(void)
     SCT *sct = OPENSSL_zalloc(sizeof(*sct));
 
     if (sct == NULL) {
-        CTerr(CT_F_SCT_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -53,7 +53,7 @@ void SCT_LIST_free(STACK_OF(SCT) *a)
 int SCT_set_version(SCT *sct, sct_version_t version)
 {
     if (version != SCT_VERSION_V1) {
-        CTerr(CT_F_SCT_SET_VERSION, CT_R_UNSUPPORTED_VERSION);
+        ERR_raise(ERR_LIB_CT, CT_R_UNSUPPORTED_VERSION);
         return 0;
     }
     sct-&gt;version = version;
@@ -73,14 +73,14 @@ int SCT_set_log_entry_type(SCT *sct, ct_log_entry_type_t entry_type)
     case CT_LOG_ENTRY_TYPE_NOT_SET:
         break;
     }
-    CTerr(CT_F_SCT_SET_LOG_ENTRY_TYPE, CT_R_UNSUPPORTED_ENTRY_TYPE);
+    ERR_raise(ERR_LIB_CT, CT_R_UNSUPPORTED_ENTRY_TYPE);
     return 0;
 }
 
 int SCT_set0_log_id(SCT *sct, unsigned char *log_id, size_t log_id_len)
 {
     if (sct-&gt;version == SCT_VERSION_V1 &amp;&amp; log_id_len != CT_V1_HASHLEN) {
-        CTerr(CT_F_SCT_SET0_LOG_ID, CT_R_INVALID_LOG_ID_LENGTH);
+        ERR_raise(ERR_LIB_CT, CT_R_INVALID_LOG_ID_LENGTH);
         return 0;
     }
 
@@ -94,7 +94,7 @@ int SCT_set0_log_id(SCT *sct, unsigned char *log_id, size_t log_id_len)
 int SCT_set1_log_id(SCT *sct, const unsigned char *log_id, size_t log_id_len)
 {
     if (sct-&gt;version == SCT_VERSION_V1 &amp;&amp; log_id_len != CT_V1_HASHLEN) {
-        CTerr(CT_F_SCT_SET1_LOG_ID, CT_R_INVALID_LOG_ID_LENGTH);
+        ERR_raise(ERR_LIB_CT, CT_R_INVALID_LOG_ID_LENGTH);
         return 0;
     }
 
@@ -106,7 +106,7 @@ int SCT_set1_log_id(SCT *sct, const unsigned char *log_id, size_t log_id_len)
     if (log_id != NULL &amp;&amp; log_id_len &gt; 0) {
         sct-&gt;log_id = OPENSSL_memdup(log_id, log_id_len);
         if (sct-&gt;log_id == NULL) {
-            CTerr(CT_F_SCT_SET1_LOG_ID, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         sct-&gt;log_id_len = log_id_len;
@@ -135,7 +135,7 @@ int SCT_set_signature_nid(SCT *sct, int nid)
         sct-&gt;validation_status = SCT_VALIDATION_STATUS_NOT_SET;
         return 1;
     default:
-        CTerr(CT_F_SCT_SET_SIGNATURE_NID, CT_R_UNRECOGNIZED_SIGNATURE_NID);
+        ERR_raise(ERR_LIB_CT, CT_R_UNRECOGNIZED_SIGNATURE_NID);
         return 0;
     }
 }
@@ -158,7 +158,7 @@ int SCT_set1_extensions(SCT *sct, const unsigned char *ext, size_t ext_len)
     if (ext != NULL &amp;&amp; ext_len &gt; 0) {
         sct-&gt;ext = OPENSSL_memdup(ext, ext_len);
         if (sct-&gt;ext == NULL) {
-            CTerr(CT_F_SCT_SET1_EXTENSIONS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         sct-&gt;ext_len = ext_len;
@@ -184,7 +184,7 @@ int SCT_set1_signature(SCT *sct, const unsigned char *sig, size_t sig_len)
     if (sig != NULL &amp;&amp; sig_len &gt; 0) {
         sct-&gt;sig = OPENSSL_memdup(sig, sig_len);
         if (sct-&gt;sig == NULL) {
-            CTerr(CT_F_SCT_SET1_SIGNATURE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         sct-&gt;sig_len = sig_len;
diff --git a/crypto/ct/ct_sct_ctx.c b/crypto/ct/ct_sct_ctx.c
index 8e4dfd2377..a84c476caf 100644
--- a/crypto/ct/ct_sct_ctx.c
+++ b/crypto/ct/ct_sct_ctx.c
@@ -25,7 +25,7 @@ SCT_CTX *SCT_CTX_new(OSSL_LIB_CTX *libctx, const char *propq)
     SCT_CTX *sctx = OPENSSL_zalloc(sizeof(*sctx));
 
     if (sctx == NULL) {
-        CTerr(CT_F_SCT_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -33,7 +33,7 @@ SCT_CTX *SCT_CTX_new(OSSL_LIB_CTX *libctx, const char *propq)
     if (propq != NULL) {
         sctx-&gt;propq = OPENSSL_strdup(propq);
         if (sctx-&gt;propq == NULL) {
-            CTerr(CT_F_SCT_CTX_NEW, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
             OPENSSL_free(sctx);
             return NULL;
         }
diff --git a/crypto/ct/ct_vfy.c b/crypto/ct/ct_vfy.c
index db0a3d83bd..2ffca19400 100644
--- a/crypto/ct/ct_vfy.c
+++ b/crypto/ct/ct_vfy.c
@@ -101,20 +101,20 @@ int SCT_CTX_verify(const SCT_CTX *sctx, const SCT *sct)
     if (!SCT_is_complete(sct) || sctx-&gt;pkey == NULL ||
         sct-&gt;entry_type == CT_LOG_ENTRY_TYPE_NOT_SET ||
         (sct-&gt;entry_type == CT_LOG_ENTRY_TYPE_PRECERT &amp;&amp; sctx-&gt;ihash == NULL)) {
-        CTerr(CT_F_SCT_CTX_VERIFY, CT_R_SCT_NOT_SET);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_NOT_SET);
         return 0;
     }
     if (sct-&gt;version != SCT_VERSION_V1) {
-        CTerr(CT_F_SCT_CTX_VERIFY, CT_R_SCT_UNSUPPORTED_VERSION);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_UNSUPPORTED_VERSION);
         return 0;
     }
     if (sct-&gt;log_id_len != sctx-&gt;pkeyhashlen ||
         memcmp(sct-&gt;log_id, sctx-&gt;pkeyhash, sctx-&gt;pkeyhashlen) != 0) {
-        CTerr(CT_F_SCT_CTX_VERIFY, CT_R_SCT_LOG_ID_MISMATCH);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_LOG_ID_MISMATCH);
         return 0;
     }
     if (sct-&gt;timestamp &gt; sctx-&gt;epoch_time_in_ms) {
-        CTerr(CT_F_SCT_CTX_VERIFY, CT_R_SCT_FUTURE_TIMESTAMP);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_FUTURE_TIMESTAMP);
         return 0;
     }
 
@@ -133,7 +133,7 @@ int SCT_CTX_verify(const SCT_CTX *sctx, const SCT *sct)
     ret = EVP_DigestVerifyFinal(ctx, sct-&gt;sig, sct-&gt;sig_len);
     /* If ret &lt; 0 some other error: fall through without setting error */
     if (ret == 0)
-        CTerr(CT_F_SCT_CTX_VERIFY, CT_R_SCT_INVALID_SIGNATURE);
+        ERR_raise(ERR_LIB_CT, CT_R_SCT_INVALID_SIGNATURE);
 
 end:
     EVP_MD_CTX_free(ctx);
diff --git a/crypto/dh/dh_ameth.c b/crypto/dh/dh_ameth.c
index 1efbb403cb..1cf692ee13 100644
--- a/crypto/dh/dh_ameth.c
+++ b/crypto/dh/dh_ameth.c
@@ -74,7 +74,7 @@ static int dh_pub_decode(EVP_PKEY *pkey, const X509_PUBKEY *pubkey)
     X509_ALGOR_get0(NULL, &amp;ptype, &amp;pval, palg);
 
     if (ptype != V_ASN1_SEQUENCE) {
-        DHerr(DH_F_DH_PUB_DECODE, DH_R_PARAMETER_ENCODING_ERROR);
+        ERR_raise(ERR_LIB_DH, DH_R_PARAMETER_ENCODING_ERROR);
         goto err;
     }
 
@@ -83,18 +83,18 @@ static int dh_pub_decode(EVP_PKEY *pkey, const X509_PUBKEY *pubkey)
     pmlen = pstr-&gt;length;
 
     if ((dh = d2i_dhp(pkey, &amp;pm, pmlen)) == NULL) {
-        DHerr(DH_F_DH_PUB_DECODE, DH_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_DH, DH_R_DECODE_ERROR);
         goto err;
     }
 
     if ((public_key = d2i_ASN1_INTEGER(NULL, &amp;p, pklen)) == NULL) {
-        DHerr(DH_F_DH_PUB_DECODE, DH_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_DH, DH_R_DECODE_ERROR);
         goto err;
     }
 
     /* We have parameters now set public key */
     if ((dh-&gt;pub_key = ASN1_INTEGER_to_BN(public_key, NULL)) == NULL) {
-        DHerr(DH_F_DH_PUB_DECODE, DH_R_BN_DECODE_ERROR);
+        ERR_raise(ERR_LIB_DH, DH_R_BN_DECODE_ERROR);
         goto err;
     }
 
@@ -121,12 +121,12 @@ static int dh_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
 
     str = ASN1_STRING_new();
     if (str == NULL) {
-        DHerr(DH_F_DH_PUB_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     str-&gt;length = i2d_dhp(pkey, dh, &amp;str-&gt;data);
     if (str-&gt;length &lt;= 0) {
-        DHerr(DH_F_DH_PUB_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     ptype = V_ASN1_SEQUENCE;
@@ -140,7 +140,7 @@ static int dh_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
     ASN1_INTEGER_free(pub_key);
 
     if (penclen &lt;= 0) {
-        DHerr(DH_F_DH_PUB_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -191,7 +191,7 @@ static int dh_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)
     /* We have parameters now set private key */
     if ((dh-&gt;priv_key = BN_secure_new()) == NULL
         || !ASN1_INTEGER_to_BN(privkey, dh-&gt;priv_key)) {
-        DHerr(DH_F_DH_PRIV_DECODE, DH_R_BN_ERROR);
+        ERR_raise(ERR_LIB_DH, DH_R_BN_ERROR);
         goto dherr;
     }
     /* Calculate public key, increments dirty_cnt */
@@ -205,7 +205,7 @@ static int dh_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)
     return 1;
 
  decerr:
-    DHerr(DH_F_DH_PRIV_DECODE, EVP_R_DECODE_ERROR);
+    ERR_raise(ERR_LIB_DH, EVP_R_DECODE_ERROR);
  dherr:
     DH_free(dh);
     ASN1_STRING_clear_free(privkey);
@@ -222,13 +222,13 @@ static int dh_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
     params = ASN1_STRING_new();
 
     if (params == NULL) {
-        DHerr(DH_F_DH_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     params-&gt;length = i2d_dhp(pkey, pkey-&gt;pkey.dh, &amp;params-&gt;data);
     if (params-&gt;length &lt;= 0) {
-        DHerr(DH_F_DH_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     params-&gt;type = V_ASN1_SEQUENCE;
@@ -237,7 +237,7 @@ static int dh_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
     prkey = BN_to_ASN1_INTEGER(pkey-&gt;pkey.dh-&gt;priv_key, NULL);
 
     if (prkey == NULL) {
-        DHerr(DH_F_DH_PRIV_ENCODE, DH_R_BN_ERROR);
+        ERR_raise(ERR_LIB_DH, DH_R_BN_ERROR);
         goto err;
     }
 
@@ -328,7 +328,7 @@ static int do_dh_print(BIO *bp, const DH *x, int indent, int ptype)
     return 1;
 
  err:
-    DHerr(DH_F_DO_DH_PRINT, reason);
+    ERR_raise(ERR_LIB_DH, reason);
     return 0;
 }
 
@@ -455,7 +455,7 @@ static int dh_pkey_public_check(const EVP_PKEY *pkey)
     DH *dh = pkey-&gt;pkey.dh;
 
     if (dh-&gt;pub_key == NULL) {
-        DHerr(DH_F_DH_PKEY_PUBLIC_CHECK, DH_R_MISSING_PUBKEY);
+        ERR_raise(ERR_LIB_DH, DH_R_MISSING_PUBKEY);
         return 0;
     }
 
diff --git a/crypto/dh/dh_check.c b/crypto/dh/dh_check.c
index 8fa9a43637..5cbbdbf8c5 100644
--- a/crypto/dh/dh_check.c
+++ b/crypto/dh/dh_check.c
@@ -33,13 +33,13 @@ int DH_check_params_ex(const DH *dh)
         return 0;
 
     if ((errflags &amp; DH_CHECK_P_NOT_PRIME) != 0)
-        DHerr(DH_F_DH_CHECK_PARAMS_EX, DH_R_CHECK_P_NOT_PRIME);
+        ERR_raise(ERR_LIB_DH, DH_R_CHECK_P_NOT_PRIME);
     if ((errflags &amp; DH_NOT_SUITABLE_GENERATOR) != 0)
-        DHerr(DH_F_DH_CHECK_PARAMS_EX, DH_R_NOT_SUITABLE_GENERATOR);
+        ERR_raise(ERR_LIB_DH, DH_R_NOT_SUITABLE_GENERATOR);
     if ((errflags &amp; DH_MODULUS_TOO_SMALL) != 0)
-        DHerr(DH_F_DH_CHECK_PARAMS_EX, DH_R_MODULUS_TOO_SMALL);
+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);
     if ((errflags &amp; DH_MODULUS_TOO_LARGE) != 0)
-        DHerr(DH_F_DH_CHECK_PARAMS_EX, DH_R_MODULUS_TOO_LARGE);
+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);
 
     return errflags == 0;
 }
@@ -116,23 +116,23 @@ int DH_check_ex(const DH *dh)
         return 0;
 
     if ((errflags &amp; DH_NOT_SUITABLE_GENERATOR) != 0)
-        DHerr(DH_F_DH_CHECK_EX, DH_R_NOT_SUITABLE_GENERATOR);
+        ERR_raise(ERR_LIB_DH, DH_R_NOT_SUITABLE_GENERATOR);
     if ((errflags &amp; DH_CHECK_Q_NOT_PRIME) != 0)
-        DHerr(DH_F_DH_CHECK_EX, DH_R_CHECK_Q_NOT_PRIME);
+        ERR_raise(ERR_LIB_DH, DH_R_CHECK_Q_NOT_PRIME);
     if ((errflags &amp; DH_CHECK_INVALID_Q_VALUE) != 0)
-        DHerr(DH_F_DH_CHECK_EX, DH_R_CHECK_INVALID_Q_VALUE);
+        ERR_raise(ERR_LIB_DH, DH_R_CHECK_INVALID_Q_VALUE);
     if ((errflags &amp; DH_CHECK_INVALID_J_VALUE) != 0)
-        DHerr(DH_F_DH_CHECK_EX, DH_R_CHECK_INVALID_J_VALUE);
+        ERR_raise(ERR_LIB_DH, DH_R_CHECK_INVALID_J_VALUE);
     if ((errflags &amp; DH_UNABLE_TO_CHECK_GENERATOR) != 0)
-        DHerr(DH_F_DH_CHECK_EX, DH_R_UNABLE_TO_CHECK_GENERATOR);
+        ERR_raise(ERR_LIB_DH, DH_R_UNABLE_TO_CHECK_GENERATOR);
     if ((errflags &amp; DH_CHECK_P_NOT_PRIME) != 0)
-        DHerr(DH_F_DH_CHECK_EX, DH_R_CHECK_P_NOT_PRIME);
+        ERR_raise(ERR_LIB_DH, DH_R_CHECK_P_NOT_PRIME);
     if ((errflags &amp; DH_CHECK_P_NOT_SAFE_PRIME) != 0)
-        DHerr(DH_F_DH_CHECK_EX, DH_R_CHECK_P_NOT_SAFE_PRIME);
+        ERR_raise(ERR_LIB_DH, DH_R_CHECK_P_NOT_SAFE_PRIME);
     if ((errflags &amp; DH_MODULUS_TOO_SMALL) != 0)
-        DHerr(DH_F_DH_CHECK_EX, DH_R_MODULUS_TOO_SMALL);
+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);
     if ((errflags &amp; DH_MODULUS_TOO_LARGE) != 0)
-        DHerr(DH_F_DH_CHECK_EX, DH_R_MODULUS_TOO_LARGE);
+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);
 
     return errflags == 0;
 }
@@ -221,11 +221,11 @@ int DH_check_pub_key_ex(const DH *dh, const BIGNUM *pub_key)
         return 0;
 
     if ((errflags &amp; DH_CHECK_PUBKEY_TOO_SMALL) != 0)
-        DHerr(DH_F_DH_CHECK_PUB_KEY_EX, DH_R_CHECK_PUBKEY_TOO_SMALL);
+        ERR_raise(ERR_LIB_DH, DH_R_CHECK_PUBKEY_TOO_SMALL);
     if ((errflags &amp; DH_CHECK_PUBKEY_TOO_LARGE) != 0)
-        DHerr(DH_F_DH_CHECK_PUB_KEY_EX, DH_R_CHECK_PUBKEY_TOO_LARGE);
+        ERR_raise(ERR_LIB_DH, DH_R_CHECK_PUBKEY_TOO_LARGE);
     if ((errflags &amp; DH_CHECK_PUBKEY_INVALID) != 0)
-        DHerr(DH_F_DH_CHECK_PUB_KEY_EX, DH_R_CHECK_PUBKEY_INVALID);
+        ERR_raise(ERR_LIB_DH, DH_R_CHECK_PUBKEY_INVALID);
 
     return errflags == 0;
 }
diff --git a/crypto/dh/dh_gen.c b/crypto/dh/dh_gen.c
index 8ed7120653..bdc0dc79b8 100644
--- a/crypto/dh/dh_gen.c
+++ b/crypto/dh/dh_gen.c
@@ -160,12 +160,12 @@ static int dh_builtin_genparams(DH *ret, int prime_len, int generator,
     BN_CTX *ctx = NULL;
 
     if (prime_len &gt; OPENSSL_DH_MAX_MODULUS_BITS) {
-        DHerr(DH_F_DH_BUILTIN_GENPARAMS, DH_R_MODULUS_TOO_LARGE);
+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);
         return 0;
     }
 
     if (prime_len &lt; DH_MIN_MODULUS_BITS) {
-        DHerr(DH_F_DH_BUILTIN_GENPARAMS, DH_R_MODULUS_TOO_SMALL);
+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);
         return 0;
     }
 
@@ -185,7 +185,7 @@ static int dh_builtin_genparams(DH *ret, int prime_len, int generator,
         goto err;
 
     if (generator &lt;= 1) {
-        DHerr(DH_F_DH_BUILTIN_GENPARAMS, DH_R_BAD_GENERATOR);
+        ERR_raise(ERR_LIB_DH, DH_R_BAD_GENERATOR);
         goto err;
     }
     if (generator == DH_GENERATOR_2) {
@@ -223,7 +223,7 @@ static int dh_builtin_genparams(DH *ret, int prime_len, int generator,
     ok = 1;
  err:
     if (ok == -1) {
-        DHerr(DH_F_DH_BUILTIN_GENPARAMS, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);
         ok = 0;
     }
 
diff --git a/crypto/dh/dh_group_params.c b/crypto/dh/dh_group_params.c
index d0b53a2f8b..e03693f687 100644
--- a/crypto/dh/dh_group_params.c
+++ b/crypto/dh/dh_group_params.c
@@ -132,7 +132,7 @@ static DH *dh_new_by_group_name(OSSL_LIB_CTX *libctx, const char *name)
                                  dh_named_groups[i].g);
         }
     }
-    DHerr(0, DH_R_INVALID_PARAMETER_NID);
+    ERR_raise(ERR_LIB_DH, DH_R_INVALID_PARAMETER_NID);
     return NULL;
 }
 
diff --git a/crypto/dh/dh_key.c b/crypto/dh/dh_key.c
index 930b33a33b..2e61ccbaa2 100644
--- a/crypto/dh/dh_key.c
+++ b/crypto/dh/dh_key.c
@@ -44,12 +44,12 @@ static int compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
 #endif
 
     if (BN_num_bits(dh-&gt;params.p) &gt; OPENSSL_DH_MAX_MODULUS_BITS) {
-        DHerr(0, DH_R_MODULUS_TOO_LARGE);
+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);
         goto err;
     }
 
     if (BN_num_bits(dh-&gt;params.p) &lt; DH_MIN_MODULUS_BITS) {
-        DHerr(0, DH_R_MODULUS_TOO_SMALL);
+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);
         return 0;
     }
 
@@ -62,7 +62,7 @@ static int compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
         goto err;
 
     if (dh-&gt;priv_key == NULL) {
-        DHerr(0, DH_R_NO_PRIVATE_VALUE);
+        ERR_raise(ERR_LIB_DH, DH_R_NO_PRIVATE_VALUE);
         goto err;
     }
 
@@ -76,13 +76,13 @@ static int compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)
 /* TODO(3.0) : Solve in a PR related to Key validation for DH */
 #ifndef FIPS_MODULE
     if (!DH_check_pub_key(dh, pub_key, &amp;check_result) || check_result) {
-        DHerr(0, DH_R_INVALID_PUBKEY);
+        ERR_raise(ERR_LIB_DH, DH_R_INVALID_PUBKEY);
         goto err;
     }
 #endif
     if (!dh-&gt;meth-&gt;bn_mod_exp(dh, tmp, pub_key, dh-&gt;priv_key, dh-&gt;params.p, ctx,
                               mont)) {
-        DHerr(0, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);
         goto err;
     }
 
@@ -229,12 +229,12 @@ static int generate_key(DH *dh)
     BIGNUM *pub_key = NULL, *priv_key = NULL;
 
     if (BN_num_bits(dh-&gt;params.p) &gt; OPENSSL_DH_MAX_MODULUS_BITS) {
-        DHerr(0, DH_R_MODULUS_TOO_LARGE);
+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE);
         return 0;
     }
 
     if (BN_num_bits(dh-&gt;params.p) &lt; DH_MIN_MODULUS_BITS) {
-        DHerr(0, DH_R_MODULUS_TOO_SMALL);
+        ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_SMALL);
         return 0;
     }
 
@@ -325,7 +325,7 @@ static int generate_key(DH *dh)
     ok = 1;
  err:
     if (ok != 1)
-        DHerr(0, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_DH, ERR_R_BN_LIB);
 
     if (pub_key != dh-&gt;pub_key)
         BN_free(pub_key);
@@ -361,7 +361,7 @@ int dh_buf2key(DH *dh, const unsigned char *buf, size_t len)
         goto err;
     return 1;
 err:
-    DHerr(DH_F_DH_BUF2KEY, err_reason);
+    ERR_raise(ERR_LIB_DH, err_reason);
     BN_free(pubkey);
     return 0;
 }
@@ -378,7 +378,7 @@ size_t dh_key2buf(const DH *dh, unsigned char **pbuf_out, size_t size, int alloc
     if (p == NULL || pubkey == NULL
             || (p_size = BN_num_bytes(p)) == 0
             || BN_num_bytes(pubkey) == 0) {
-        DHerr(DH_F_DH_KEY2BUF, DH_R_INVALID_PUBKEY);
+        ERR_raise(ERR_LIB_DH, DH_R_INVALID_PUBKEY);
         return 0;
     }
     if (pbuf_out != NULL &amp;&amp; (alloc || *pbuf_out != NULL)) {
@@ -390,7 +390,7 @@ size_t dh_key2buf(const DH *dh, unsigned char **pbuf_out, size_t size, int alloc
         }
 
         if (pbuf == NULL) {
-            DHerr(DH_F_DH_KEY2BUF, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         /*
@@ -400,7 +400,7 @@ size_t dh_key2buf(const DH *dh, unsigned char **pbuf_out, size_t size, int alloc
         if (BN_bn2binpad(pubkey, pbuf, p_size) &lt; 0) {
             if (alloc)
                 OPENSSL_free(pbuf);
-            DHerr(DH_F_DH_KEY2BUF, DH_R_BN_ERROR);
+            ERR_raise(ERR_LIB_DH, DH_R_BN_ERROR);
             return 0;
         }
         *pbuf_out = pbuf;
diff --git a/crypto/dh/dh_lib.c b/crypto/dh/dh_lib.c
index 207e7b06c6..e3bbe95ff4 100644
--- a/crypto/dh/dh_lib.c
+++ b/crypto/dh/dh_lib.c
@@ -73,14 +73,14 @@ static DH *dh_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
     DH *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        DHerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     ret-&gt;references = 1;
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        DHerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -91,7 +91,7 @@ static DH *dh_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
     ret-&gt;flags = ret-&gt;meth-&gt;flags;  /* early default init */
     if (engine) {
         if (!ENGINE_init(engine)) {
-            DHerr(0, ERR_R_ENGINE_LIB);
+            ERR_raise(ERR_LIB_DH, ERR_R_ENGINE_LIB);
             goto err;
         }
         ret-&gt;engine = engine;
@@ -100,7 +100,7 @@ static DH *dh_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
     if (ret-&gt;engine) {
         ret-&gt;meth = ENGINE_get_DH(ret-&gt;engine);
         if (ret-&gt;meth == NULL) {
-            DHerr(0, ERR_R_ENGINE_LIB);
+            ERR_raise(ERR_LIB_DH, ERR_R_ENGINE_LIB);
             goto err;
         }
     }
@@ -114,7 +114,7 @@ static DH *dh_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
 #endif /* FIPS_MODULE */
 
     if ((ret-&gt;meth-&gt;init != NULL) &amp;&amp; !ret-&gt;meth-&gt;init(ret)) {
-        DHerr(0, ERR_R_INIT_FAIL);
+        ERR_raise(ERR_LIB_DH, ERR_R_INIT_FAIL);
         goto err;
     }
 
diff --git a/crypto/dh/dh_meth.c b/crypto/dh/dh_meth.c
index 753af11834..5c15cd2b8c 100644
--- a/crypto/dh/dh_meth.c
+++ b/crypto/dh/dh_meth.c
@@ -31,7 +31,7 @@ DH_METHOD *DH_meth_new(const char *name, int flags)
         OPENSSL_free(dhm);
     }
 
-    DHerr(DH_F_DH_METH_NEW, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -57,7 +57,7 @@ DH_METHOD *DH_meth_dup(const DH_METHOD *dhm)
         OPENSSL_free(ret);
     }
 
-    DHerr(DH_F_DH_METH_DUP, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -71,7 +71,7 @@ int DH_meth_set1_name(DH_METHOD *dhm, const char *name)
     char *tmpname = OPENSSL_strdup(name);
 
     if (tmpname == NULL) {
-        DHerr(DH_F_DH_METH_SET1_NAME, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/dh/dh_pmeth.c b/crypto/dh/dh_pmeth.c
index d0e1c55002..11f30ce702 100644
--- a/crypto/dh/dh_pmeth.c
+++ b/crypto/dh/dh_pmeth.c
@@ -57,7 +57,7 @@ static int pkey_dh_init(EVP_PKEY_CTX *ctx)
     DH_PKEY_CTX *dctx;
 
     if ((dctx = OPENSSL_zalloc(sizeof(*dctx))) == NULL) {
-        DHerr(DH_F_PKEY_DH_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     dctx-&gt;prime_len = 2048;
@@ -245,7 +245,7 @@ static int pkey_dh_ctrl_str(EVP_PKEY_CTX *ctx,
         int nid = OBJ_sn2nid(value);
 
         if (nid == NID_undef) {
-            DHerr(DH_F_PKEY_DH_CTRL_STR, DH_R_INVALID_PARAMETER_NAME);
+            ERR_raise(ERR_LIB_DH, DH_R_INVALID_PARAMETER_NAME);
             return -2;
         }
         dctx-&gt;param_nid = nid;
@@ -400,7 +400,7 @@ static int pkey_dh_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     DH *dh = NULL;
 
     if (ctx-&gt;pkey == NULL &amp;&amp; dctx-&gt;param_nid == NID_undef) {
-        DHerr(DH_F_PKEY_DH_KEYGEN, DH_R_NO_PARAMETERS_SET);
+        ERR_raise(ERR_LIB_DH, DH_R_NO_PARAMETERS_SET);
         return 0;
     }
     if (dctx-&gt;param_nid != NID_undef)
@@ -424,7 +424,7 @@ static int pkey_dh_derive(EVP_PKEY_CTX *ctx, unsigned char *key,
     DH_PKEY_CTX *dctx = ctx-&gt;data;
     BIGNUM *dhpub;
     if (!ctx-&gt;pkey || !ctx-&gt;peerkey) {
-        DHerr(DH_F_PKEY_DH_DERIVE, DH_R_KEYS_NOT_SET);
+        ERR_raise(ERR_LIB_DH, DH_R_KEYS_NOT_SET);
         return 0;
     }
     dh = ctx-&gt;pkey-&gt;pkey.dh;
diff --git a/crypto/dh/dh_prn.c b/crypto/dh/dh_prn.c
index 35cd1e9231..5d31254dcb 100644
--- a/crypto/dh/dh_prn.c
+++ b/crypto/dh/dh_prn.c
@@ -25,7 +25,7 @@ int DHparams_print_fp(FILE *fp, const DH *x)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        DHerr(DH_F_DHPARAMS_PRINT_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_DH, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
diff --git a/crypto/dsa/dsa_ameth.c b/crypto/dsa/dsa_ameth.c
index d3e22abc35..ff4904952d 100644
--- a/crypto/dsa/dsa_ameth.c
+++ b/crypto/dsa/dsa_ameth.c
@@ -48,27 +48,27 @@ static int dsa_pub_decode(EVP_PKEY *pkey, const X509_PUBKEY *pubkey)
         pmlen = pstr-&gt;length;
 
         if ((dsa = d2i_DSAparams(NULL, &amp;pm, pmlen)) == NULL) {
-            DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);
+            ERR_raise(ERR_LIB_DSA, DSA_R_DECODE_ERROR);
             goto err;
         }
 
     } else if ((ptype == V_ASN1_NULL) || (ptype == V_ASN1_UNDEF)) {
         if ((dsa = DSA_new()) == NULL) {
-            DSAerr(DSA_F_DSA_PUB_DECODE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     } else {
-        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_PARAMETER_ENCODING_ERROR);
+        ERR_raise(ERR_LIB_DSA, DSA_R_PARAMETER_ENCODING_ERROR);
         goto err;
     }
 
     if ((public_key = d2i_ASN1_INTEGER(NULL, &amp;p, pklen)) == NULL) {
-        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_DSA, DSA_R_DECODE_ERROR);
         goto err;
     }
 
     if ((dsa-&gt;pub_key = ASN1_INTEGER_to_BN(public_key, NULL)) == NULL) {
-        DSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_BN_DECODE_ERROR);
+        ERR_raise(ERR_LIB_DSA, DSA_R_BN_DECODE_ERROR);
         goto err;
     }
 
@@ -101,12 +101,12 @@ static int dsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
         &amp;&amp; dsa-&gt;params.g != NULL) {
         str = ASN1_STRING_new();
         if (str == NULL) {
-            DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         str-&gt;length = i2d_DSAparams(dsa, &amp;str-&gt;data);
         if (str-&gt;length &lt;= 0) {
-            DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         ptype = V_ASN1_SEQUENCE;
@@ -116,7 +116,7 @@ static int dsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
     pubint = BN_to_ASN1_INTEGER(dsa-&gt;pub_key, NULL);
 
     if (pubint == NULL) {
-        DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -124,7 +124,7 @@ static int dsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
     ASN1_INTEGER_free(pubint);
 
     if (penclen &lt;= 0) {
-        DSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -179,23 +179,23 @@ static int dsa_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)
     /* We have parameters now set private key */
     if ((dsa-&gt;priv_key = BN_secure_new()) == NULL
         || !ASN1_INTEGER_to_BN(privkey, dsa-&gt;priv_key)) {
-        DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);
+        ERR_raise(ERR_LIB_DSA, DSA_R_BN_ERROR);
         goto dsaerr;
     }
     /* Calculate public key */
     if ((dsa-&gt;pub_key = BN_new()) == NULL) {
-        DSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
         goto dsaerr;
     }
     if ((ctx = BN_CTX_new()) == NULL) {
-        DSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
         goto dsaerr;
     }
 
     BN_set_flags(dsa-&gt;priv_key, BN_FLG_CONSTTIME);
     if (!BN_mod_exp(dsa-&gt;pub_key, dsa-&gt;params.g, dsa-&gt;priv_key, dsa-&gt;params.p,
                     ctx)) {
-        DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);
+        ERR_raise(ERR_LIB_DSA, DSA_R_BN_ERROR);
         goto dsaerr;
     }
 
@@ -206,7 +206,7 @@ static int dsa_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)
     goto done;
 
  decerr:
-    DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_DECODE_ERROR);
+    ERR_raise(ERR_LIB_DSA, DSA_R_DECODE_ERROR);
  dsaerr:
     DSA_free(dsa);
  done:
@@ -223,20 +223,20 @@ static int dsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
     int dplen;
 
     if (pkey-&gt;pkey.dsa  == NULL|| pkey-&gt;pkey.dsa-&gt;priv_key == NULL) {
-        DSAerr(DSA_F_DSA_PRIV_ENCODE, DSA_R_MISSING_PARAMETERS);
+        ERR_raise(ERR_LIB_DSA, DSA_R_MISSING_PARAMETERS);
         goto err;
     }
 
     params = ASN1_STRING_new();
 
     if (params == NULL) {
-        DSAerr(DSA_F_DSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     params-&gt;length = i2d_DSAparams(pkey-&gt;pkey.dsa, &amp;params-&gt;data);
     if (params-&gt;length &lt;= 0) {
-        DSAerr(DSA_F_DSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     params-&gt;type = V_ASN1_SEQUENCE;
@@ -245,7 +245,7 @@ static int dsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
     prkey = BN_to_ASN1_INTEGER(pkey-&gt;pkey.dsa-&gt;priv_key, NULL);
 
     if (prkey == NULL) {
-        DSAerr(DSA_F_DSA_PRIV_ENCODE, DSA_R_BN_ERROR);
+        ERR_raise(ERR_LIB_DSA, DSA_R_BN_ERROR);
         goto err;
     }
 
@@ -411,7 +411,7 @@ static int old_dsa_priv_decode(EVP_PKEY *pkey,
     DSA *dsa;
 
     if ((dsa = d2i_DSAPrivateKey(NULL, pder, derlen)) == NULL) {
-        DSAerr(DSA_F_OLD_DSA_PRIV_DECODE, ERR_R_DSA_LIB);
+        ERR_raise(ERR_LIB_DSA, ERR_R_DSA_LIB);
         return 0;
     }
     dsa-&gt;dirty_cnt++;
diff --git a/crypto/dsa/dsa_lib.c b/crypto/dsa/dsa_lib.c
index 9df2818ecd..2c3569a2c3 100644
--- a/crypto/dsa/dsa_lib.c
+++ b/crypto/dsa/dsa_lib.c
@@ -137,14 +137,14 @@ static DSA *dsa_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
     DSA *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        DSAerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     ret-&gt;references = 1;
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        DSAerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -155,7 +155,7 @@ static DSA *dsa_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
     ret-&gt;flags = ret-&gt;meth-&gt;flags &amp; ~DSA_FLAG_NON_FIPS_ALLOW; /* early default init */
     if (engine) {
         if (!ENGINE_init(engine)) {
-            DSAerr(0, ERR_R_ENGINE_LIB);
+            ERR_raise(ERR_LIB_DSA, ERR_R_ENGINE_LIB);
             goto err;
         }
         ret-&gt;engine = engine;
@@ -164,7 +164,7 @@ static DSA *dsa_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
     if (ret-&gt;engine) {
         ret-&gt;meth = ENGINE_get_DSA(ret-&gt;engine);
         if (ret-&gt;meth == NULL) {
-            DSAerr(0, ERR_R_ENGINE_LIB);
+            ERR_raise(ERR_LIB_DSA, ERR_R_ENGINE_LIB);
             goto err;
         }
     }
@@ -178,7 +178,7 @@ static DSA *dsa_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
 #endif
 
     if ((ret-&gt;meth-&gt;init != NULL) &amp;&amp; !ret-&gt;meth-&gt;init(ret)) {
-        DSAerr(0, ERR_R_INIT_FAIL);
+        ERR_raise(ERR_LIB_DSA, ERR_R_INIT_FAIL);
         goto err;
     }
 
diff --git a/crypto/dsa/dsa_meth.c b/crypto/dsa/dsa_meth.c
index de236f80a4..b811bf2c33 100644
--- a/crypto/dsa/dsa_meth.c
+++ b/crypto/dsa/dsa_meth.c
@@ -34,7 +34,7 @@ DSA_METHOD *DSA_meth_new(const char *name, int flags)
         OPENSSL_free(dsam);
     }
 
-    DSAerr(DSA_F_DSA_METH_NEW, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -60,7 +60,7 @@ DSA_METHOD *DSA_meth_dup(const DSA_METHOD *dsam)
         OPENSSL_free(ret);
     }
 
-    DSAerr(DSA_F_DSA_METH_DUP, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -74,7 +74,7 @@ int DSA_meth_set1_name(DSA_METHOD *dsam, const char *name)
     char *tmpname = OPENSSL_strdup(name);
 
     if (tmpname == NULL) {
-        DSAerr(DSA_F_DSA_METH_SET1_NAME, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/dsa/dsa_ossl.c b/crypto/dsa/dsa_ossl.c
index 547b0283fa..bd51a2c716 100644
--- a/crypto/dsa/dsa_ossl.c
+++ b/crypto/dsa/dsa_ossl.c
@@ -174,7 +174,7 @@ DSA_SIG *dsa_do_sign_int(const unsigned char *dgst, int dlen, DSA *dsa)
 
  err:
     if (rv == 0) {
-        DSAerr(0, reason);
+        ERR_raise(ERR_LIB_DSA, reason);
         DSA_SIG_free(ret);
         ret = NULL;
     }
@@ -205,7 +205,7 @@ static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in,
     int q_bits, q_words;
 
     if (!dsa-&gt;params.p || !dsa-&gt;params.q || !dsa-&gt;params.g) {
-        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);
+        ERR_raise(ERR_LIB_DSA, DSA_R_MISSING_PARAMETERS);
         return 0;
     }
 
@@ -213,11 +213,11 @@ static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in,
     if (BN_is_zero(dsa-&gt;params.p)
         || BN_is_zero(dsa-&gt;params.q)
         || BN_is_zero(dsa-&gt;params.g)) {
-        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_INVALID_PARAMETERS);
+        ERR_raise(ERR_LIB_DSA, DSA_R_INVALID_PARAMETERS);
         return 0;
     }
     if (dsa-&gt;priv_key == NULL) {
-        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_DSA, DSA_R_MISSING_PRIVATE_KEY);
         return 0;
     }
 
@@ -307,7 +307,7 @@ static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in,
     ret = 1;
  err:
     if (!ret)
-        DSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_DSA, ERR_R_BN_LIB);
     if (ctx != ctx_in)
         BN_CTX_free(ctx);
     BN_clear_free(k);
@@ -327,19 +327,19 @@ static int dsa_do_verify(const unsigned char *dgst, int dgst_len,
     if (dsa-&gt;params.p == NULL
         || dsa-&gt;params.q == NULL
         || dsa-&gt;params.g == NULL) {
-        DSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_MISSING_PARAMETERS);
+        ERR_raise(ERR_LIB_DSA, DSA_R_MISSING_PARAMETERS);
         return -1;
     }
 
     i = BN_num_bits(dsa-&gt;params.q);
     /* fips 186-3 allows only different sizes for q */
     if (i != 160 &amp;&amp; i != 224 &amp;&amp; i != 256) {
-        DSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_BAD_Q_VALUE);
+        ERR_raise(ERR_LIB_DSA, DSA_R_BAD_Q_VALUE);
         return -1;
     }
 
     if (BN_num_bits(dsa-&gt;params.p) &gt; OPENSSL_DSA_MAX_MODULUS_BITS) {
-        DSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_MODULUS_TOO_LARGE);
+        ERR_raise(ERR_LIB_DSA, DSA_R_MODULUS_TOO_LARGE);
         return -1;
     }
     u1 = BN_new();
@@ -415,7 +415,7 @@ static int dsa_do_verify(const unsigned char *dgst, int dgst_len,
 
  err:
     if (ret &lt; 0)
-        DSAerr(DSA_F_DSA_DO_VERIFY, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_DSA, ERR_R_BN_LIB);
     BN_CTX_free(ctx);
     BN_free(u1);
     BN_free(u2);
diff --git a/crypto/dsa/dsa_pmeth.c b/crypto/dsa/dsa_pmeth.c
index 0f5a6157ae..909be63867 100644
--- a/crypto/dsa/dsa_pmeth.c
+++ b/crypto/dsa/dsa_pmeth.c
@@ -131,7 +131,7 @@ static int pkey_dsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
         if (EVP_MD_type((const EVP_MD *)p2) != NID_sha1 &amp;&amp;
             EVP_MD_type((const EVP_MD *)p2) != NID_sha224 &amp;&amp;
             EVP_MD_type((const EVP_MD *)p2) != NID_sha256) {
-            DSAerr(DSA_F_PKEY_DSA_CTRL, DSA_R_INVALID_DIGEST_TYPE);
+            ERR_raise(ERR_LIB_DSA, DSA_R_INVALID_DIGEST_TYPE);
             return 0;
         }
         dctx-&gt;pmd = p2;
@@ -149,7 +149,7 @@ static int pkey_dsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
             EVP_MD_type((const EVP_MD *)p2) != NID_sha3_256 &amp;&amp;
             EVP_MD_type((const EVP_MD *)p2) != NID_sha3_384 &amp;&amp;
             EVP_MD_type((const EVP_MD *)p2) != NID_sha3_512) {
-            DSAerr(DSA_F_PKEY_DSA_CTRL, DSA_R_INVALID_DIGEST_TYPE);
+            ERR_raise(ERR_LIB_DSA, DSA_R_INVALID_DIGEST_TYPE);
             return 0;
         }
         dctx-&gt;md = p2;
@@ -165,8 +165,7 @@ static int pkey_dsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
         return 1;
 
     case EVP_PKEY_CTRL_PEER_KEY:
-        DSAerr(DSA_F_PKEY_DSA_CTRL,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_DSA, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     default:
         return -2;
@@ -190,7 +189,7 @@ static int pkey_dsa_ctrl_str(EVP_PKEY_CTX *ctx,
         const EVP_MD *md = EVP_get_digestbyname(value);
 
         if (md == NULL) {
-            DSAerr(DSA_F_PKEY_DSA_CTRL_STR, DSA_R_INVALID_DIGEST_TYPE);
+            ERR_raise(ERR_LIB_DSA, DSA_R_INVALID_DIGEST_TYPE);
             return 0;
         }
         return EVP_PKEY_CTX_set_dsa_paramgen_md(ctx, md);
@@ -236,7 +235,7 @@ static int pkey_dsa_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     DSA *dsa = NULL;
 
     if (ctx-&gt;pkey == NULL) {
-        DSAerr(DSA_F_PKEY_DSA_KEYGEN, DSA_R_NO_PARAMETERS_SET);
+        ERR_raise(ERR_LIB_DSA, DSA_R_NO_PARAMETERS_SET);
         return 0;
     }
     dsa = DSA_new();
diff --git a/crypto/dsa/dsa_prn.c b/crypto/dsa/dsa_prn.c
index be0b3038cb..c5ec7d5dfe 100644
--- a/crypto/dsa/dsa_prn.c
+++ b/crypto/dsa/dsa_prn.c
@@ -25,7 +25,7 @@ int DSA_print_fp(FILE *fp, const DSA *x, int off)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        DSAerr(DSA_F_DSA_PRINT_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_DSA, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -40,7 +40,7 @@ int DSAparams_print_fp(FILE *fp, const DSA *x)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        DSAerr(DSA_F_DSAPARAMS_PRINT_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_DSA, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
diff --git a/crypto/dsa/dsa_sign.c b/crypto/dsa/dsa_sign.c
index 6a887d8190..58e53e5c35 100644
--- a/crypto/dsa/dsa_sign.c
+++ b/crypto/dsa/dsa_sign.c
@@ -35,7 +35,7 @@ DSA_SIG *DSA_SIG_new(void)
 {
     DSA_SIG *sig = OPENSSL_zalloc(sizeof(*sig));
     if (sig == NULL)
-        DSAerr(DSA_F_DSA_SIG_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
     return sig;
 }
 
diff --git a/crypto/dso/dso_dl.c b/crypto/dso/dso_dl.c
index 5469789345..36dcf1d73d 100644
--- a/crypto/dso/dso_dl.c
+++ b/crypto/dso/dso_dl.c
@@ -61,7 +61,7 @@ static int dl_load(DSO *dso)
     char *filename = DSO_convert_filename(dso, NULL);
 
     if (filename == NULL) {
-        DSOerr(DSO_F_DL_LOAD, DSO_R_NO_FILENAME);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NO_FILENAME);
         goto err;
     }
     ptr = shl_load(filename, BIND_IMMEDIATE |
@@ -69,13 +69,17 @@ static int dl_load(DSO *dso)
                     DYNAMIC_PATH), 0L);
     if (ptr == NULL) {
         char errbuf[160];
-        DSOerr(DSO_F_DL_LOAD, DSO_R_LOAD_FAILED);
+
         if (openssl_strerror_r(errno, errbuf, sizeof(errbuf)))
-            ERR_add_error_data(4, &quot;filename(&quot;, filename, &quot;): &quot;, errbuf);
+            ERR_raise_data(ERR_LIB_DSO, DSO_R_LOAD_FAILED,
+                           &quot;filename(%s): %s&quot;, filename, errbuf);
+        else
+            ERR_raise_data(ERR_LIB_DSO, DSO_R_LOAD_FAILED,
+                           &quot;filename(%s): errno %d&quot;, filename, errno);
         goto err;
     }
     if (!sk_push(dso-&gt;meth_data, (char *)ptr)) {
-        DSOerr(DSO_F_DL_LOAD, DSO_R_STACK_ERROR);
+        ERR_raise(ERR_LIB_DSO, DSO_R_STACK_ERROR);
         goto err;
     }
     /*
@@ -96,7 +100,7 @@ static int dl_unload(DSO *dso)
 {
     shl_t ptr;
     if (dso == NULL) {
-        DSOerr(DSO_F_DL_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if (sk_num(dso-&gt;meth_data) &lt; 1)
@@ -104,7 +108,7 @@ static int dl_unload(DSO *dso)
     /* Is this statement legal? */
     ptr = (shl_t) sk_pop(dso-&gt;meth_data);
     if (ptr == NULL) {
-        DSOerr(DSO_F_DL_UNLOAD, DSO_R_NULL_HANDLE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NULL_HANDLE);
         /*
          * Should push the value back onto the stack in case of a retry.
          */
@@ -121,23 +125,27 @@ static DSO_FUNC_TYPE dl_bind_func(DSO *dso, const char *symname)
     void *sym;
 
     if ((dso == NULL) || (symname == NULL)) {
-        DSOerr(DSO_F_DL_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if (sk_num(dso-&gt;meth_data) &lt; 1) {
-        DSOerr(DSO_F_DL_BIND_FUNC, DSO_R_STACK_ERROR);
+        ERR_raise(ERR_LIB_DSO, DSO_R_STACK_ERROR);
         return NULL;
     }
     ptr = (shl_t) sk_value(dso-&gt;meth_data, sk_num(dso-&gt;meth_data) - 1);
     if (ptr == NULL) {
-        DSOerr(DSO_F_DL_BIND_FUNC, DSO_R_NULL_HANDLE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NULL_HANDLE);
         return NULL;
     }
     if (shl_findsym(&amp;ptr, symname, TYPE_UNDEFINED, &amp;sym) &lt; 0) {
         char errbuf[160];
-        DSOerr(DSO_F_DL_BIND_FUNC, DSO_R_SYM_FAILURE);
+
         if (openssl_strerror_r(errno, errbuf, sizeof(errbuf)))
-            ERR_add_error_data(4, &quot;symname(&quot;, symname, &quot;): &quot;, errbuf);
+            ERR_raise_data(ERR_LIB_DSO, DSO_R_SYM_FAILURE,
+                           &quot;symname(%s): %s&quot;, symname, errbuf);
+        else
+            ERR_raise_data(ERR_LIB_DSO, DSO_R_SYM_FAILURE,
+                           &quot;symname(%s): errno %d&quot;, symname, errno);
         return NULL;
     }
     return (DSO_FUNC_TYPE)sym;
@@ -148,7 +156,7 @@ static char *dl_merger(DSO *dso, const char *filespec1, const char *filespec2)
     char *merged;
 
     if (!filespec1 &amp;&amp; !filespec2) {
-        DSOerr(DSO_F_DL_MERGER, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     /*
@@ -158,7 +166,7 @@ static char *dl_merger(DSO *dso, const char *filespec1, const char *filespec2)
     if (!filespec2 || filespec1[0] == '/') {
         merged = OPENSSL_strdup(filespec1);
         if (merged == NULL) {
-            DSOerr(DSO_F_DL_MERGER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     }
@@ -168,7 +176,7 @@ static char *dl_merger(DSO *dso, const char *filespec1, const char *filespec2)
     else if (!filespec1) {
         merged = OPENSSL_strdup(filespec2);
         if (merged == NULL) {
-            DSOerr(DSO_F_DL_MERGER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     } else
@@ -191,7 +199,7 @@ static char *dl_merger(DSO *dso, const char *filespec1, const char *filespec2)
         }
         merged = OPENSSL_malloc(len + 2);
         if (merged == NULL) {
-            DSOerr(DSO_F_DL_MERGER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
         strcpy(merged, filespec2);
@@ -224,7 +232,7 @@ static char *dl_name_converter(DSO *dso, const char *filename)
     }
     translated = OPENSSL_malloc(rsize);
     if (translated == NULL) {
-        DSOerr(DSO_F_DL_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NAME_TRANSLATION_FAILED);
         return NULL;
     }
     if (transform) {
diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c
index b34984b919..76bc6055bc 100644
--- a/crypto/dso/dso_dlfcn.c
+++ b/crypto/dso/dso_dlfcn.c
@@ -102,7 +102,7 @@ static int dlfcn_load(DSO *dso)
     int saveerrno = get_last_sys_error();
 
     if (filename == NULL) {
-        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NO_FILENAME);
         goto err;
     }
 # ifdef RTLD_GLOBAL
@@ -115,8 +115,8 @@ static int dlfcn_load(DSO *dso)
 # endif
     ptr = dlopen(filename, flags);
     if (ptr == NULL) {
-        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);
-        ERR_add_error_data(4, &quot;filename(&quot;, filename, &quot;): &quot;, dlerror());
+        ERR_raise_data(ERR_LIB_DSO, DSO_R_LOAD_FAILED,
+                       &quot;filename(%s): %s&quot;, filename, dlerror());
         goto err;
     }
     /*
@@ -125,7 +125,7 @@ static int dlfcn_load(DSO *dso)
      */
     set_sys_error(saveerrno);
     if (!sk_void_push(dso-&gt;meth_data, (char *)ptr)) {
-        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);
+        ERR_raise(ERR_LIB_DSO, DSO_R_STACK_ERROR);
         goto err;
     }
     /* Success */
@@ -143,14 +143,14 @@ static int dlfcn_unload(DSO *dso)
 {
     void *ptr;
     if (dso == NULL) {
-        DSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if (sk_void_num(dso-&gt;meth_data) &lt; 1)
         return 1;
     ptr = sk_void_pop(dso-&gt;meth_data);
     if (ptr == NULL) {
-        DSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NULL_HANDLE);
         /*
          * Should push the value back onto the stack in case of a retry.
          */
@@ -171,22 +171,22 @@ static DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)
     } u;
 
     if ((dso == NULL) || (symname == NULL)) {
-        DSOerr(DSO_F_DLFCN_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if (sk_void_num(dso-&gt;meth_data) &lt; 1) {
-        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_STACK_ERROR);
+        ERR_raise(ERR_LIB_DSO, DSO_R_STACK_ERROR);
         return NULL;
     }
     ptr = sk_void_value(dso-&gt;meth_data, sk_void_num(dso-&gt;meth_data) - 1);
     if (ptr == NULL) {
-        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_NULL_HANDLE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NULL_HANDLE);
         return NULL;
     }
     u.dlret = dlsym(ptr, symname);
     if (u.dlret == NULL) {
-        DSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_SYM_FAILURE);
-        ERR_add_error_data(4, &quot;symname(&quot;, symname, &quot;): &quot;, dlerror());
+        ERR_raise_data(ERR_LIB_DSO, DSO_R_SYM_FAILURE,
+                       &quot;symname(%s): %s&quot;, symname, dlerror());
         return NULL;
     }
     return u.sym;
@@ -198,7 +198,7 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1,
     char *merged;
 
     if (!filespec1 &amp;&amp; !filespec2) {
-        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     /*
@@ -208,7 +208,7 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1,
     if (!filespec2 || (filespec1 != NULL &amp;&amp; filespec1[0] == '/')) {
         merged = OPENSSL_strdup(filespec1);
         if (merged == NULL) {
-            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     }
@@ -218,7 +218,7 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1,
     else if (!filespec1) {
         merged = OPENSSL_strdup(filespec2);
         if (merged == NULL) {
-            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     } else {
@@ -240,7 +240,7 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1,
         }
         merged = OPENSSL_malloc(len + 2);
         if (merged == NULL) {
-            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
         strcpy(merged, filespec2);
@@ -266,7 +266,7 @@ static char *dlfcn_name_converter(DSO *dso, const char *filename)
     }
     translated = OPENSSL_malloc(rsize);
     if (translated == NULL) {
-        DSOerr(DSO_F_DLFCN_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NAME_TRANSLATION_FAILED);
         return NULL;
     }
     if (transform) {
@@ -437,6 +437,7 @@ static int dlfcn_pathbyaddr(void *addr, char *path, int sz)
         return len;
     }
 
+    /* TODO: what error report does this attach to? */
     ERR_add_error_data(2, &quot;dlfcn_pathbyaddr(): &quot;, dlerror());
 # endif
     return -1;
diff --git a/crypto/dso/dso_lib.c b/crypto/dso/dso_lib.c
index 6e2b8d944d..4850e96a4b 100644
--- a/crypto/dso/dso_lib.c
+++ b/crypto/dso/dso_lib.c
@@ -26,13 +26,13 @@ static DSO *DSO_new_method(DSO_METHOD *meth)
     }
     ret = OPENSSL_zalloc(sizeof(*ret));
     if (ret == NULL) {
-        DSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;meth_data = sk_void_new_null();
     if (ret-&gt;meth_data == NULL) {
         /* sk_new doesn't generate any errors so we do */
-        DSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -40,7 +40,7 @@ static DSO *DSO_new_method(DSO_METHOD *meth)
     ret-&gt;references = 1;
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        DSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
         sk_void_free(ret-&gt;meth_data);
         OPENSSL_free(ret);
         return NULL;
@@ -76,13 +76,13 @@ int DSO_free(DSO *dso)
 
     if ((dso-&gt;flags &amp; DSO_FLAG_NO_UNLOAD_ON_FREE) == 0) {
         if ((dso-&gt;meth-&gt;dso_unload != NULL) &amp;&amp; !dso-&gt;meth-&gt;dso_unload(dso)) {
-            DSOerr(DSO_F_DSO_FREE, DSO_R_UNLOAD_FAILED);
+            ERR_raise(ERR_LIB_DSO, DSO_R_UNLOAD_FAILED);
             return 0;
         }
     }
 
     if ((dso-&gt;meth-&gt;finish != NULL) &amp;&amp; !dso-&gt;meth-&gt;finish(dso)) {
-        DSOerr(DSO_F_DSO_FREE, DSO_R_FINISH_FAILED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_FINISH_FAILED);
         return 0;
     }
 
@@ -104,7 +104,7 @@ int DSO_up_ref(DSO *dso)
     int i;
 
     if (dso == NULL) {
-        DSOerr(DSO_F_DSO_UP_REF, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -124,20 +124,20 @@ DSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags)
     if (dso == NULL) {
         ret = DSO_new_method(meth);
         if (ret == NULL) {
-            DSOerr(DSO_F_DSO_LOAD, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         allocated = 1;
         /* Pass the provided flags to the new DSO object */
         if (DSO_ctrl(ret, DSO_CTRL_SET_FLAGS, flags, NULL) &lt; 0) {
-            DSOerr(DSO_F_DSO_LOAD, DSO_R_CTRL_FAILED);
+            ERR_raise(ERR_LIB_DSO, DSO_R_CTRL_FAILED);
             goto err;
         }
     } else
         ret = dso;
     /* Don't load if we're currently already loaded */
     if (ret-&gt;filename != NULL) {
-        DSOerr(DSO_F_DSO_LOAD, DSO_R_DSO_ALREADY_LOADED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_DSO_ALREADY_LOADED);
         goto err;
     }
     /*
@@ -146,20 +146,20 @@ DSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags)
      */
     if (filename != NULL)
         if (!DSO_set_filename(ret, filename)) {
-            DSOerr(DSO_F_DSO_LOAD, DSO_R_SET_FILENAME_FAILED);
+            ERR_raise(ERR_LIB_DSO, DSO_R_SET_FILENAME_FAILED);
             goto err;
         }
     filename = ret-&gt;filename;
     if (filename == NULL) {
-        DSOerr(DSO_F_DSO_LOAD, DSO_R_NO_FILENAME);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NO_FILENAME);
         goto err;
     }
     if (ret-&gt;meth-&gt;dso_load == NULL) {
-        DSOerr(DSO_F_DSO_LOAD, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         goto err;
     }
     if (!ret-&gt;meth-&gt;dso_load(ret)) {
-        DSOerr(DSO_F_DSO_LOAD, DSO_R_LOAD_FAILED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_LOAD_FAILED);
         goto err;
     }
     /* Load succeeded */
@@ -175,15 +175,15 @@ DSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname)
     DSO_FUNC_TYPE ret = NULL;
 
     if ((dso == NULL) || (symname == NULL)) {
-        DSOerr(DSO_F_DSO_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if (dso-&gt;meth-&gt;dso_bind_func == NULL) {
-        DSOerr(DSO_F_DSO_BIND_FUNC, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         return NULL;
     }
     if ((ret = dso-&gt;meth-&gt;dso_bind_func(dso, symname)) == NULL) {
-        DSOerr(DSO_F_DSO_BIND_FUNC, DSO_R_SYM_FAILURE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_SYM_FAILURE);
         return NULL;
     }
     /* Success */
@@ -202,7 +202,7 @@ DSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname)
 long DSO_ctrl(DSO *dso, int cmd, long larg, void *parg)
 {
     if (dso == NULL) {
-        DSOerr(DSO_F_DSO_CTRL, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return -1;
     }
     /*
@@ -222,7 +222,7 @@ long DSO_ctrl(DSO *dso, int cmd, long larg, void *parg)
         break;
     }
     if ((dso-&gt;meth == NULL) || (dso-&gt;meth-&gt;dso_ctrl == NULL)) {
-        DSOerr(DSO_F_DSO_CTRL, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         return -1;
     }
     return dso-&gt;meth-&gt;dso_ctrl(dso, cmd, larg, parg);
@@ -231,7 +231,7 @@ long DSO_ctrl(DSO *dso, int cmd, long larg, void *parg)
 const char *DSO_get_filename(DSO *dso)
 {
     if (dso == NULL) {
-        DSOerr(DSO_F_DSO_GET_FILENAME, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     return dso-&gt;filename;
@@ -242,17 +242,17 @@ int DSO_set_filename(DSO *dso, const char *filename)
     char *copied;
 
     if ((dso == NULL) || (filename == NULL)) {
-        DSOerr(DSO_F_DSO_SET_FILENAME, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if (dso-&gt;loaded_filename) {
-        DSOerr(DSO_F_DSO_SET_FILENAME, DSO_R_DSO_ALREADY_LOADED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_DSO_ALREADY_LOADED);
         return 0;
     }
     /* We'll duplicate filename */
     copied = OPENSSL_strdup(filename);
     if (copied == NULL) {
-        DSOerr(DSO_F_DSO_SET_FILENAME, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     OPENSSL_free(dso-&gt;filename);
@@ -265,7 +265,7 @@ char *DSO_merge(DSO *dso, const char *filespec1, const char *filespec2)
     char *result = NULL;
 
     if (dso == NULL || filespec1 == NULL) {
-        DSOerr(DSO_F_DSO_MERGE, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if ((dso-&gt;flags &amp; DSO_FLAG_NO_NAME_TRANSLATION) == 0) {
@@ -282,13 +282,13 @@ char *DSO_convert_filename(DSO *dso, const char *filename)
     char *result = NULL;
 
     if (dso == NULL) {
-        DSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if (filename == NULL)
         filename = dso-&gt;filename;
     if (filename == NULL) {
-        DSOerr(DSO_F_DSO_CONVERT_FILENAME, DSO_R_NO_FILENAME);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NO_FILENAME);
         return NULL;
     }
     if ((dso-&gt;flags &amp; DSO_FLAG_NO_NAME_TRANSLATION) == 0) {
@@ -300,7 +300,7 @@ char *DSO_convert_filename(DSO *dso, const char *filename)
     if (result == NULL) {
         result = OPENSSL_strdup(filename);
         if (result == NULL) {
-            DSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     }
@@ -313,7 +313,7 @@ int DSO_pathbyaddr(void *addr, char *path, int sz)
     if (meth == NULL)
         meth = DSO_METHOD_openssl();
     if (meth-&gt;pathbyaddr == NULL) {
-        DSOerr(DSO_F_DSO_PATHBYADDR, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         return -1;
     }
     return (*meth-&gt;pathbyaddr) (addr, path, sz);
@@ -343,7 +343,7 @@ void *DSO_global_lookup(const char *name)
     if (meth == NULL)
         meth = DSO_METHOD_openssl();
     if (meth-&gt;globallookup == NULL) {
-        DSOerr(DSO_F_DSO_GLOBAL_LOOKUP, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         return NULL;
     }
     return (*meth-&gt;globallookup) (name);
diff --git a/crypto/dso/dso_vms.c b/crypto/dso/dso_vms.c
index d1993ceb4a..03abcc0d73 100644
--- a/crypto/dso/dso_vms.c
+++ b/crypto/dso/dso_vms.c
@@ -106,7 +106,7 @@ static int vms_load(DSO *dso)
     const char *ext = NULL;     /* possible extension to add */
 
     if (filename == NULL) {
-        DSOerr(DSO_F_VMS_LOAD, DSO_R_NO_FILENAME);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NO_FILENAME);
         goto err;
     }
 
@@ -169,13 +169,13 @@ static int vms_load(DSO *dso)
     /* Check that we won't get buffer overflows */
     if (sp2 - sp1 &gt; FILENAME_MAX
         || (sp1 - filename) + strlen(sp2) &gt; FILENAME_MAX) {
-        DSOerr(DSO_F_VMS_LOAD, DSO_R_FILENAME_TOO_BIG);
+        ERR_raise(ERR_LIB_DSO, DSO_R_FILENAME_TOO_BIG);
         goto err;
     }
 
     p = DSO_MALLOC(sizeof(*p));
     if (p == NULL) {
-        DSOerr(DSO_F_VMS_LOAD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -201,7 +201,7 @@ static int vms_load(DSO *dso)
     p-&gt;imagename_dsc.dsc$a_pointer = p-&gt;imagename;
 
     if (!sk_void_push(dso-&gt;meth_data, (char *)p)) {
-        DSOerr(DSO_F_VMS_LOAD, DSO_R_STACK_ERROR);
+        ERR_raise(ERR_LIB_DSO, DSO_R_STACK_ERROR);
         goto err;
     }
 
@@ -224,14 +224,14 @@ static int vms_unload(DSO *dso)
 {
     DSO_VMS_INTERNAL *p;
     if (dso == NULL) {
-        DSOerr(DSO_F_VMS_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if (sk_void_num(dso-&gt;meth_data) &lt; 1)
         return 1;
     p = (DSO_VMS_INTERNAL *)sk_void_pop(dso-&gt;meth_data);
     if (p == NULL) {
-        DSOerr(DSO_F_VMS_UNLOAD, DSO_R_NULL_HANDLE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NULL_HANDLE);
         return 0;
     }
     /* Cleanup */
@@ -287,7 +287,7 @@ void vms_bind_sym(DSO *dso, const char *symname, void **sym)
     *sym = NULL;
 
     if ((dso == NULL) || (symname == NULL)) {
-        DSOerr(DSO_F_VMS_BIND_SYM, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return;
     }
 # if __INITIAL_POINTER_SIZE == 64
@@ -302,13 +302,13 @@ void vms_bind_sym(DSO *dso, const char *symname, void **sym)
     symname_dsc.dsc$a_pointer = SYMNAME;
 
     if (sk_void_num(dso-&gt;meth_data) &lt; 1) {
-        DSOerr(DSO_F_VMS_BIND_SYM, DSO_R_STACK_ERROR);
+        ERR_raise(ERR_LIB_DSO, DSO_R_STACK_ERROR);
         return;
     }
     ptr = (DSO_VMS_INTERNAL *)sk_void_value(dso-&gt;meth_data,
                                             sk_void_num(dso-&gt;meth_data) - 1);
     if (ptr == NULL) {
-        DSOerr(DSO_F_VMS_BIND_SYM, DSO_R_NULL_HANDLE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NULL_HANDLE);
         return;
     }
 
@@ -336,17 +336,15 @@ void vms_bind_sym(DSO *dso, const char *symname, void **sym)
         else {
             errstring[length] = '\0';
 
-            DSOerr(DSO_F_VMS_BIND_SYM, DSO_R_SYM_FAILURE);
             if (ptr-&gt;imagename_dsc.dsc$w_length)
-                ERR_add_error_data(9,
-                                   &quot;Symbol &quot;, symname,
-                                   &quot; in &quot;, ptr-&gt;filename,
-                                   &quot; (&quot;, ptr-&gt;imagename, &quot;)&quot;,
-                                   &quot;: &quot;, errstring);
+                ERR_raise_data(ERR_LIB_DSO, DSO_R_SYM_FAILURE,
+                               &quot;Symbol %s in %s (%s): %s&quot;,
+                               symname, ptr-&gt;filename, ptr-&gt;imagename,
+                               errstring);
             else
-                ERR_add_error_data(6,
-                                   &quot;Symbol &quot;, symname,
-                                   &quot; in &quot;, ptr-&gt;filename, &quot;: &quot;, errstring);
+                ERR_raise_data(ERR_LIB_DSO, DSO_R_SYM_FAILURE,
+                               &quot;Symbol %s in %s: %s&quot;,
+                               symname, ptr-&gt;filename, errstring);
         }
         return;
     }
@@ -436,10 +434,9 @@ static char *vms_merger(DSO *dso, const char *filespec1,
         else {
             errstring[length] = '\0';
 
-            DSOerr(DSO_F_VMS_MERGER, DSO_R_FAILURE);
-            ERR_add_error_data(7,
-                               &quot;filespec \&quot;&quot;, filespec1, &quot;\&quot;, &quot;,
-                               &quot;defaults \&quot;&quot;, filespec2, &quot;\&quot;: &quot;, errstring);
+            ERR_raise_data(ERR_LIB_DSO, DSO_R_FAILURE,
+                           &quot;filespec \&quot;%s\&quot;, default \&quot;%s\&quot;: %s&quot;,
+                           filespec1, filespec2, errstring);
         }
         return NULL;
     }
@@ -451,7 +448,7 @@ static char *vms_merger(DSO *dso, const char *filespec1,
     merged[nam.NAMX_ESL] = '\0';
     return merged;
  malloc_err:
-    DSOerr(DSO_F_VMS_MERGER, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
 }
 
 static char *vms_name_converter(DSO *dso, const char *filename)
diff --git a/crypto/dso/dso_win32.c b/crypto/dso/dso_win32.c
index 7248fc2878..4d3059d438 100644
--- a/crypto/dso/dso_win32.c
+++ b/crypto/dso/dso_win32.c
@@ -100,23 +100,23 @@ static int win32_load(DSO *dso)
     char *filename = DSO_convert_filename(dso, NULL);
 
     if (filename == NULL) {
-        DSOerr(DSO_F_WIN32_LOAD, DSO_R_NO_FILENAME);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NO_FILENAME);
         goto err;
     }
     h = LoadLibraryA(filename);
     if (h == NULL) {
-        DSOerr(DSO_F_WIN32_LOAD, DSO_R_LOAD_FAILED);
-        ERR_add_error_data(3, &quot;filename(&quot;, filename, &quot;)&quot;);
+        ERR_raise_data(ERR_LIB_DSO, DSO_R_LOAD_FAILED,
+                       &quot;filename(%s)&quot;, filename);
         goto err;
     }
     p = OPENSSL_malloc(sizeof(*p));
     if (p == NULL) {
-        DSOerr(DSO_F_WIN32_LOAD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     *p = h;
     if (!sk_void_push(dso-&gt;meth_data, p)) {
-        DSOerr(DSO_F_WIN32_LOAD, DSO_R_STACK_ERROR);
+        ERR_raise(ERR_LIB_DSO, DSO_R_STACK_ERROR);
         goto err;
     }
     /* Success */
@@ -135,18 +135,18 @@ static int win32_unload(DSO *dso)
 {
     HINSTANCE *p;
     if (dso == NULL) {
-        DSOerr(DSO_F_WIN32_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if (sk_void_num(dso-&gt;meth_data) &lt; 1)
         return 1;
     p = sk_void_pop(dso-&gt;meth_data);
     if (p == NULL) {
-        DSOerr(DSO_F_WIN32_UNLOAD, DSO_R_NULL_HANDLE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NULL_HANDLE);
         return 0;
     }
     if (!FreeLibrary(*p)) {
-        DSOerr(DSO_F_WIN32_UNLOAD, DSO_R_UNLOAD_FAILED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNLOAD_FAILED);
         /*
          * We should push the value back onto the stack in case of a retry.
          */
@@ -167,22 +167,21 @@ static DSO_FUNC_TYPE win32_bind_func(DSO *dso, const char *symname)
     } sym;
 
     if ((dso == NULL) || (symname == NULL)) {
-        DSOerr(DSO_F_WIN32_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if (sk_void_num(dso-&gt;meth_data) &lt; 1) {
-        DSOerr(DSO_F_WIN32_BIND_FUNC, DSO_R_STACK_ERROR);
+        ERR_raise(ERR_LIB_DSO, DSO_R_STACK_ERROR);
         return NULL;
     }
     ptr = sk_void_value(dso-&gt;meth_data, sk_void_num(dso-&gt;meth_data) - 1);
     if (ptr == NULL) {
-        DSOerr(DSO_F_WIN32_BIND_FUNC, DSO_R_NULL_HANDLE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NULL_HANDLE);
         return NULL;
     }
     sym.f = GetProcAddress(*ptr, symname);
     if (sym.p == NULL) {
-        DSOerr(DSO_F_WIN32_BIND_FUNC, DSO_R_SYM_FAILURE);
-        ERR_add_error_data(3, &quot;symname(&quot;, symname, &quot;)&quot;);
+        ERR_raise_data(ERR_LIB_DSO, DSO_R_SYM_FAILURE, &quot;symname(%s)&quot;, symname);
         return NULL;
     }
     return (DSO_FUNC_TYPE)sym.f;
@@ -210,13 +209,13 @@ static struct file_st *win32_splitter(DSO *dso, const char *filename,
     char last;
 
     if (!filename) {
-        DSOerr(DSO_F_WIN32_SPLITTER, DSO_R_NO_FILENAME);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NO_FILENAME);
         return NULL;
     }
 
     result = OPENSSL_zalloc(sizeof(*result));
     if (result == NULL) {
-        DSOerr(DSO_F_WIN32_SPLITTER, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -235,7 +234,7 @@ static struct file_st *win32_splitter(DSO *dso, const char *filename,
         switch (last) {
         case ':':
             if (position != IN_DEVICE) {
-                DSOerr(DSO_F_WIN32_SPLITTER, DSO_R_INCORRECT_FILE_SYNTAX);
+                ERR_raise(ERR_LIB_DSO, DSO_R_INCORRECT_FILE_SYNTAX);
                 OPENSSL_free(result);
                 return NULL;
             }
@@ -308,7 +307,7 @@ static char *win32_joiner(DSO *dso, const struct file_st *file_split)
     const char *start;
 
     if (!file_split) {
-        DSOerr(DSO_F_WIN32_JOINER, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if (file_split-&gt;node) {
@@ -329,13 +328,13 @@ static char *win32_joiner(DSO *dso, const struct file_st *file_split)
     len += file_split-&gt;filelen;
 
     if (!len) {
-        DSOerr(DSO_F_WIN32_JOINER, DSO_R_EMPTY_FILE_STRUCTURE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_EMPTY_FILE_STRUCTURE);
         return NULL;
     }
 
     result = OPENSSL_malloc(len + 1);
     if (result == NULL) {
-        DSOerr(DSO_F_WIN32_JOINER, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -395,30 +394,30 @@ static char *win32_merger(DSO *dso, const char *filespec1,
     struct file_st *filespec2_split = NULL;
 
     if (!filespec1 &amp;&amp; !filespec2) {
-        DSOerr(DSO_F_WIN32_MERGER, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if (!filespec2) {
         merged = OPENSSL_strdup(filespec1);
         if (merged == NULL) {
-            DSOerr(DSO_F_WIN32_MERGER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     } else if (!filespec1) {
         merged = OPENSSL_strdup(filespec2);
         if (merged == NULL) {
-            DSOerr(DSO_F_WIN32_MERGER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     } else {
         filespec1_split = win32_splitter(dso, filespec1, 0);
         if (!filespec1_split) {
-            DSOerr(DSO_F_WIN32_MERGER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
         filespec2_split = win32_splitter(dso, filespec2, 1);
         if (!filespec2_split) {
-            DSOerr(DSO_F_WIN32_MERGER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);
             OPENSSL_free(filespec1_split);
             return NULL;
         }
@@ -466,7 +465,7 @@ static char *win32_name_converter(DSO *dso, const char *filename)
         /* We will simply duplicate filename */
         translated = OPENSSL_malloc(len + 1);
     if (translated == NULL) {
-        DSOerr(DSO_F_WIN32_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_NAME_TRANSLATION_FAILED);
         return NULL;
     }
     if (transform)
@@ -522,7 +521,7 @@ static int win32_pathbyaddr(void *addr, char *path, int sz)
 
     dll = LoadLibrary(TEXT(DLLNAME));
     if (dll == NULL) {
-        DSOerr(DSO_F_WIN32_PATHBYADDR, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         return -1;
     }
 
@@ -530,7 +529,7 @@ static int win32_pathbyaddr(void *addr, char *path, int sz)
         GetProcAddress(dll, &quot;CreateToolhelp32Snapshot&quot;);
     if (create_snap == NULL) {
         FreeLibrary(dll);
-        DSOerr(DSO_F_WIN32_PATHBYADDR, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         return -1;
     }
     /* We take the rest for granted... */
@@ -550,7 +549,7 @@ static int win32_pathbyaddr(void *addr, char *path, int sz)
     hModuleSnap = (*create_snap) (TH32CS_SNAPMODULE, 0);
     if (hModuleSnap == INVALID_HANDLE_VALUE) {
         FreeLibrary(dll);
-        DSOerr(DSO_F_WIN32_PATHBYADDR, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         return -1;
     }
 
@@ -559,7 +558,7 @@ static int win32_pathbyaddr(void *addr, char *path, int sz)
     if (!(*module_first) (hModuleSnap, &amp;me32)) {
         (*close_snap) (hModuleSnap);
         FreeLibrary(dll);
-        DSOerr(DSO_F_WIN32_PATHBYADDR, DSO_R_FAILURE);
+        ERR_raise(ERR_LIB_DSO, DSO_R_FAILURE);
         return -1;
     }
 
@@ -621,7 +620,7 @@ static void *win32_globallookup(const char *name)
 
     dll = LoadLibrary(TEXT(DLLNAME));
     if (dll == NULL) {
-        DSOerr(DSO_F_WIN32_GLOBALLOOKUP, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         return NULL;
     }
 
@@ -629,7 +628,7 @@ static void *win32_globallookup(const char *name)
         GetProcAddress(dll, &quot;CreateToolhelp32Snapshot&quot;);
     if (create_snap == NULL) {
         FreeLibrary(dll);
-        DSOerr(DSO_F_WIN32_GLOBALLOOKUP, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         return NULL;
     }
     /* We take the rest for granted... */
@@ -645,7 +644,7 @@ static void *win32_globallookup(const char *name)
     hModuleSnap = (*create_snap) (TH32CS_SNAPMODULE, 0);
     if (hModuleSnap == INVALID_HANDLE_VALUE) {
         FreeLibrary(dll);
-        DSOerr(DSO_F_WIN32_GLOBALLOOKUP, DSO_R_UNSUPPORTED);
+        ERR_raise(ERR_LIB_DSO, DSO_R_UNSUPPORTED);
         return NULL;
     }
 
diff --git a/crypto/ec/ec2_oct.c b/crypto/ec/ec2_oct.c
index 78eea869a3..5cfe28325c 100644
--- a/crypto/ec/ec2_oct.c
+++ b/crypto/ec/ec2_oct.c
@@ -87,13 +87,11 @@ int ec_GF2m_simple_set_compressed_coordinates(const EC_GROUP *group,
             if (ERR_GET_LIB(err) == ERR_LIB_BN
                 &amp;&amp; ERR_GET_REASON(err) == BN_R_NO_SOLUTION) {
                 ERR_clear_error();
-                ECerr(EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES,
-                      EC_R_INVALID_COMPRESSED_POINT);
+                ERR_raise(ERR_LIB_EC, EC_R_INVALID_COMPRESSED_POINT);
             } else
 #endif
             {
-                ECerr(EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES,
-                      ERR_R_BN_LIB);
+                ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             }
             goto err;
         }
@@ -139,7 +137,7 @@ size_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
     if ((form != POINT_CONVERSION_COMPRESSED)
         &amp;&amp; (form != POINT_CONVERSION_UNCOMPRESSED)
         &amp;&amp; (form != POINT_CONVERSION_HYBRID)) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_INVALID_FORM);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_FORM);
         goto err;
     }
 
@@ -147,7 +145,7 @@ size_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
         /* encodes to a single 0 octet */
         if (buf != NULL) {
             if (len &lt; 1) {
-                ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);
+                ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
                 return 0;
             }
             buf[0] = 0;
@@ -164,7 +162,7 @@ size_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
     /* if 'buf' is NULL, just return required length */
     if (buf != NULL) {
         if (len &lt; ret) {
-            ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);
+            ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
             goto err;
         }
 
@@ -199,7 +197,7 @@ size_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
 
         skip = field_len - BN_num_bytes(x);
         if (skip &gt; field_len) {
-            ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
             goto err;
         }
         while (skip &gt; 0) {
@@ -209,7 +207,7 @@ size_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
         skip = BN_bn2bin(x, buf + i);
         i += skip;
         if (i != 1 + field_len) {
-            ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
             goto err;
         }
 
@@ -217,7 +215,7 @@ size_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
             || form == POINT_CONVERSION_HYBRID) {
             skip = field_len - BN_num_bytes(y);
             if (skip &gt; field_len) {
-                ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
             while (skip &gt; 0) {
@@ -229,7 +227,7 @@ size_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
         }
 
         if (i != ret) {
-            ECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
             goto err;
         }
     }
@@ -268,7 +266,7 @@ int ec_GF2m_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
 #endif
 
     if (len == 0) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_BUFFER_TOO_SMALL);
+        ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
         return 0;
     }
     form = buf[0];
@@ -277,17 +275,17 @@ int ec_GF2m_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
     if ((form != 0) &amp;&amp; (form != POINT_CONVERSION_COMPRESSED)
         &amp;&amp; (form != POINT_CONVERSION_UNCOMPRESSED)
         &amp;&amp; (form != POINT_CONVERSION_HYBRID)) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         return 0;
     }
     if ((form == 0 || form == POINT_CONVERSION_UNCOMPRESSED) &amp;&amp; y_bit) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         return 0;
     }
 
     if (form == 0) {
         if (len != 1) {
-            ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
             return 0;
         }
 
@@ -301,7 +299,7 @@ int ec_GF2m_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
          POINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2 * field_len;
 
     if (len != enc_len) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         return 0;
     }
 
@@ -323,7 +321,7 @@ int ec_GF2m_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
     if (!BN_bin2bn(buf + 1, field_len, x))
         goto err;
     if (BN_num_bits(x) &gt; m) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         goto err;
     }
 
@@ -334,14 +332,14 @@ int ec_GF2m_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
         if (!BN_bin2bn(buf + 1 + field_len, field_len, y))
             goto err;
         if (BN_num_bits(y) &gt; m) {
-            ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
             goto err;
         }
         if (form == POINT_CONVERSION_HYBRID) {
             if (!group-&gt;meth-&gt;field_div(group, yxi, y, x, ctx))
                 goto err;
             if (y_bit != BN_is_odd(yxi)) {
-                ECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+                ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
                 goto err;
             }
         }
diff --git a/crypto/ec/ec2_smpl.c b/crypto/ec/ec2_smpl.c
index 95097c67ec..abac2a5cae 100644
--- a/crypto/ec/ec2_smpl.c
+++ b/crypto/ec/ec2_smpl.c
@@ -109,7 +109,7 @@ int ec_GF2m_simple_group_set_curve(EC_GROUP *group,
         goto err;
     i = BN_GF2m_poly2arr(group-&gt;field, group-&gt;poly, 6) - 1;
     if ((i != 5) &amp;&amp; (i != 3)) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE, EC_R_UNSUPPORTED_FIELD);
+        ERR_raise(ERR_LIB_EC, EC_R_UNSUPPORTED_FIELD);
         goto err;
     }
 
@@ -188,8 +188,7 @@ int ec_GF2m_simple_group_check_discriminant(const EC_GROUP *group,
     if (ctx == NULL) {
         ctx = new_ctx = BN_CTX_new();
         if (ctx == NULL) {
-            ECerr(EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT,
-                  ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -293,8 +292,7 @@ int ec_GF2m_simple_point_set_affine_coordinates(const EC_GROUP *group,
 {
     int ret = 0;
     if (x == NULL || y == NULL) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES,
-              ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -326,14 +324,12 @@ int ec_GF2m_simple_point_get_affine_coordinates(const EC_GROUP *group,
     int ret = 0;
 
     if (EC_POINT_is_at_infinity(group, point)) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES,
-              EC_R_POINT_AT_INFINITY);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_AT_INFINITY);
         return 0;
     }
 
     if (BN_cmp(point-&gt;Z, BN_value_one())) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (x != NULL) {
@@ -733,7 +729,7 @@ int ec_GF2m_simple_ladder_pre(const EC_GROUP *group,
     do {
         if (!BN_priv_rand_ex(s-&gt;Z, BN_num_bits(group-&gt;field) - 1,
                              BN_RAND_TOP_ANY, BN_RAND_BOTTOM_ANY, ctx)) {
-            ECerr(EC_F_EC_GF2M_SIMPLE_LADDER_PRE, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             return 0;
         }
     } while (BN_is_zero(s-&gt;Z));
@@ -748,7 +744,7 @@ int ec_GF2m_simple_ladder_pre(const EC_GROUP *group,
     do {
         if (!BN_priv_rand_ex(r-&gt;Y, BN_num_bits(group-&gt;field) - 1,
                              BN_RAND_TOP_ANY, BN_RAND_BOTTOM_ANY, ctx)) {
-            ECerr(EC_F_EC_GF2M_SIMPLE_LADDER_PRE, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             return 0;
         }
     } while (BN_is_zero(r-&gt;Y));
@@ -817,7 +813,7 @@ int ec_GF2m_simple_ladder_post(const EC_GROUP *group,
     if (BN_is_zero(s-&gt;Z)) {
         if (!EC_POINT_copy(r, p)
             || !EC_POINT_invert(group, r, ctx)) {
-            ECerr(EC_F_EC_GF2M_SIMPLE_LADDER_POST, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             return 0;
         }
         return 1;
@@ -828,7 +824,7 @@ int ec_GF2m_simple_ladder_post(const EC_GROUP *group,
     t1 = BN_CTX_get(ctx);
     t2 = BN_CTX_get(ctx);
     if (t2 == NULL) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_LADDER_POST, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -907,7 +903,7 @@ int ec_GF2m_simple_points_mul(const EC_GROUP *group, EC_POINT *r,
      */
 
     if ((t = EC_POINT_new(group)) == NULL) {
-        ECerr(EC_F_EC_GF2M_SIMPLE_POINTS_MUL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -934,7 +930,7 @@ static int ec_GF2m_simple_field_inv(const EC_GROUP *group, BIGNUM *r,
     int ret;
 
     if (!(ret = BN_GF2m_mod_inv(r, a, group-&gt;field, ctx)))
-        ECerr(EC_F_EC_GF2M_SIMPLE_FIELD_INV, EC_R_CANNOT_INVERT);
+        ERR_raise(ERR_LIB_EC, EC_R_CANNOT_INVERT);
     return ret;
 }
 
diff --git a/crypto/ec/ec_ameth.c b/crypto/ec/ec_ameth.c
index 8857d3e388..c137a72614 100644
--- a/crypto/ec/ec_ameth.c
+++ b/crypto/ec/ec_ameth.c
@@ -32,7 +32,7 @@ static int eckey_param2type(int *pptype, void **ppval, const EC_KEY *ec_key)
     int nid;
 
     if (ec_key == NULL || (group = EC_KEY_get0_group(ec_key)) == NULL) {
-        ECerr(EC_F_ECKEY_PARAM2TYPE, EC_R_MISSING_PARAMETERS);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PARAMETERS);
         return 0;
     }
     if (EC_GROUP_get_asn1_flag(group)
@@ -43,7 +43,7 @@ static int eckey_param2type(int *pptype, void **ppval, const EC_KEY *ec_key)
 
         if (asn1obj == NULL || OBJ_length(asn1obj) == 0) {
             ASN1_OBJECT_free(asn1obj);
-            ECerr(EC_F_ECKEY_PARAM2TYPE, EC_R_MISSING_OID);
+            ERR_raise(ERR_LIB_EC, EC_R_MISSING_OID);
             return 0;
         }
         *ppval = asn1obj;
@@ -57,7 +57,7 @@ static int eckey_param2type(int *pptype, void **ppval, const EC_KEY *ec_key)
         pstr-&gt;length = i2d_ECParameters(ec_key, &amp;pstr-&gt;data);
         if (pstr-&gt;length &lt;= 0) {
             ASN1_STRING_free(pstr);
-            ECerr(EC_F_ECKEY_PARAM2TYPE, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             return 0;
         }
         *ppval = pstr;
@@ -75,7 +75,7 @@ static int eckey_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
     int penclen;
 
     if (!eckey_param2type(&amp;ptype, &amp;pval, ec_key)) {
-        ECerr(EC_F_ECKEY_PUB_ENCODE, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         return 0;
     }
     penclen = i2o_ECPublicKey(ec_key, NULL);
@@ -107,7 +107,7 @@ static EC_KEY *eckey_type2param(int ptype, const void *pval,
     EC_GROUP *group = NULL;
 
     if ((eckey = EC_KEY_new_ex(libctx, propq)) == NULL) {
-        ECerr(EC_F_ECKEY_TYPE2PARAM, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto ecerr;
     }
 
@@ -118,7 +118,7 @@ static EC_KEY *eckey_type2param(int ptype, const void *pval,
 
 
         if (d2i_ECParameters(&amp;eckey, &amp;pm, pmlen) == NULL) {
-            ECerr(EC_F_ECKEY_TYPE2PARAM, EC_R_DECODE_ERROR);
+            ERR_raise(ERR_LIB_EC, EC_R_DECODE_ERROR);
             goto ecerr;
         }
     } else if (ptype == V_ASN1_OBJECT) {
@@ -136,7 +136,7 @@ static EC_KEY *eckey_type2param(int ptype, const void *pval,
             goto ecerr;
         EC_GROUP_free(group);
     } else {
-        ECerr(EC_F_ECKEY_TYPE2PARAM, EC_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_EC, EC_R_DECODE_ERROR);
         goto ecerr;
     }
 
@@ -170,7 +170,7 @@ static int eckey_pub_decode(EVP_PKEY *pkey, const X509_PUBKEY *pubkey)
 
     /* We have parameters now set public key */
     if (!o2i_ECPublicKey(&amp;eckey, &amp;p, pklen)) {
-        ECerr(EC_F_ECKEY_PUB_DECODE, EC_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_EC, EC_R_DECODE_ERROR);
         goto ecerr;
     }
 
@@ -218,7 +218,7 @@ static int eckey_priv_decode_ex(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8,
 
     /* We have parameters now set private key */
     if (!d2i_ECPrivateKey(&amp;eckey, &amp;p, pklen)) {
-        ECerr(0, EC_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_EC, EC_R_DECODE_ERROR);
         goto err;
     }
 
@@ -239,7 +239,7 @@ static int eckey_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
     unsigned int old_flags;
 
     if (!eckey_param2type(&amp;ptype, &amp;pval, &amp;ec_key)) {
-        ECerr(EC_F_ECKEY_PRIV_ENCODE, EC_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_EC, EC_R_DECODE_ERROR);
         return 0;
     }
 
@@ -254,18 +254,18 @@ static int eckey_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
 
     eplen = i2d_ECPrivateKey(&amp;ec_key, NULL);
     if (!eplen) {
-        ECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         return 0;
     }
     ep = OPENSSL_malloc(eplen);
     if (ep == NULL) {
-        ECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     p = ep;
     if (!i2d_ECPrivateKey(&amp;ec_key, &amp;p)) {
         OPENSSL_free(ep);
-        ECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         return 0;
     }
 
@@ -365,7 +365,7 @@ static int do_EC_KEY_print(BIO *bp, const EC_KEY *x, int off, ec_print_t ktype)
     const EC_GROUP *group;
 
     if (x == NULL || (group = EC_KEY_get0_group(x)) == NULL) {
-        ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -413,7 +413,7 @@ static int do_EC_KEY_print(BIO *bp, const EC_KEY *x, int off, ec_print_t ktype)
     ret = 1;
  err:
     if (!ret)
-        ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
     OPENSSL_clear_free(priv, privlen);
     OPENSSL_free(pub);
     return ret;
@@ -518,7 +518,7 @@ static int ec_pkey_check(const EVP_PKEY *pkey)
 
     /* stay consistent to what EVP_PKEY_check demands */
     if (eckey-&gt;priv_key == NULL) {
-        ECerr(EC_F_EC_PKEY_CHECK, EC_R_MISSING_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PRIVATE_KEY);
         return 0;
     }
 
@@ -547,7 +547,7 @@ static int ec_pkey_param_check(const EVP_PKEY *pkey)
 
     /* stay consistent to what EVP_PKEY_check demands */
     if (eckey-&gt;group == NULL) {
-        ECerr(EC_F_EC_PKEY_PARAM_CHECK, EC_R_MISSING_PARAMETERS);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PARAMETERS);
         return 0;
     }
 
diff --git a/crypto/ec/ec_asn1.c b/crypto/ec/ec_asn1.c
index e95cffd42c..cd38ab6b04 100644
--- a/crypto/ec/ec_asn1.c
+++ b/crypto/ec/ec_asn1.c
@@ -199,30 +199,30 @@ static int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)
     nid = EC_GROUP_get_field_type(group);
     /* set OID for the field */
     if ((field-&gt;fieldType = OBJ_nid2obj(nid)) == NULL) {
-        ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_OBJ_LIB);
         goto err;
     }
 
     if (nid == NID_X9_62_prime_field) {
         if ((tmp = BN_new()) == NULL) {
-            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         /* the parameters are specified by the prime number p */
         if (!EC_GROUP_get_curve(group, tmp, NULL, NULL, NULL)) {
-            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
         /* set the prime number */
         field-&gt;p.prime = BN_to_ASN1_INTEGER(tmp, NULL);
         if (field-&gt;p.prime == NULL) {
-            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
             goto err;
         }
     } else if (nid == NID_X9_62_characteristic_two_field)
 #ifdef OPENSSL_NO_EC2M
     {
-        ECerr(EC_F_EC_ASN1_GROUP2FIELDID, EC_R_GF2M_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_EC, EC_R_GF2M_NOT_SUPPORTED);
         goto err;
     }
 #else
@@ -234,7 +234,7 @@ static int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)
         char_two = field-&gt;p.char_two;
 
         if (char_two == NULL) {
-            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
@@ -243,12 +243,12 @@ static int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)
         field_type = EC_GROUP_get_basis_type(group);
 
         if (field_type == 0) {
-            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
         /* set base type OID */
         if ((char_two-&gt;type = OBJ_nid2obj(field_type)) == NULL) {
-            ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_OBJ_LIB);
             goto err;
         }
 
@@ -260,11 +260,11 @@ static int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)
 
             char_two-&gt;p.tpBasis = ASN1_INTEGER_new();
             if (char_two-&gt;p.tpBasis == NULL) {
-                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             if (!ASN1_INTEGER_set(char_two-&gt;p.tpBasis, (long)k)) {
-                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_ASN1_LIB);
+                ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
                 goto err;
             }
         } else if (field_type == NID_X9_62_ppBasis) {
@@ -275,7 +275,7 @@ static int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)
 
             char_two-&gt;p.ppBasis = X9_62_PENTANOMIAL_new();
             if (char_two-&gt;p.ppBasis == NULL) {
-                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
 
@@ -288,14 +288,14 @@ static int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)
             /* for ONB the parameters are (asn1) NULL */
             char_two-&gt;p.onBasis = ASN1_NULL_new();
             if (char_two-&gt;p.onBasis == NULL) {
-                ECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
         }
     }
 #endif
     else {
-        ECerr(EC_F_EC_ASN1_GROUP2FIELDID, EC_R_UNSUPPORTED_FIELD);
+        ERR_raise(ERR_LIB_EC, EC_R_UNSUPPORTED_FIELD);
         goto err;
     }
 
@@ -317,13 +317,13 @@ static int ec_asn1_group2curve(const EC_GROUP *group, X9_62_CURVE *curve)
         return 0;
 
     if ((tmp_1 = BN_new()) == NULL || (tmp_2 = BN_new()) == NULL) {
-        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     /* get a and b */
     if (!EC_GROUP_get_curve(group, NULL, tmp_1, tmp_2, NULL)) {
-        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
@@ -335,19 +335,19 @@ static int ec_asn1_group2curve(const EC_GROUP *group, X9_62_CURVE *curve)
     len = ((size_t)EC_GROUP_get_degree(group) + 7) / 8;
     if ((a_buf = OPENSSL_malloc(len)) == NULL
         || (b_buf = OPENSSL_malloc(len)) == NULL) {
-        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (BN_bn2binpad(tmp_1, a_buf, len) &lt; 0
         || BN_bn2binpad(tmp_2, b_buf, len) &lt; 0) {
-        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
     /* set a and b */
     if (!ASN1_OCTET_STRING_set(curve-&gt;a, a_buf, len)
         || !ASN1_OCTET_STRING_set(curve-&gt;b, b_buf, len)) {
-        ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
         goto err;
     }
 
@@ -355,14 +355,14 @@ static int ec_asn1_group2curve(const EC_GROUP *group, X9_62_CURVE *curve)
     if (group-&gt;seed) {
         if (!curve-&gt;seed)
             if ((curve-&gt;seed = ASN1_BIT_STRING_new()) == NULL) {
-                ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
         curve-&gt;seed-&gt;flags &amp;= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
         curve-&gt;seed-&gt;flags |= ASN1_STRING_FLAG_BITS_LEFT;
         if (!ASN1_BIT_STRING_set(curve-&gt;seed, group-&gt;seed,
                                  (int)group-&gt;seed_len)) {
-            ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
             goto err;
         }
     } else {
@@ -393,7 +393,7 @@ ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
 
     if (params == NULL) {
         if ((ret = ECPARAMETERS_new()) == NULL) {
-            ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     } else
@@ -404,19 +404,19 @@ ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
 
     /* set the fieldID */
     if (!ec_asn1_group2fieldid(group, ret-&gt;fieldID)) {
-        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
     /* set the curve */
     if (!ec_asn1_group2curve(group, ret-&gt;curve)) {
-        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
     /* set the base point */
     if ((point = EC_GROUP_get0_generator(group)) == NULL) {
-        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, EC_R_UNDEFINED_GENERATOR);
+        ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);
         goto err;
     }
 
@@ -424,12 +424,12 @@ ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
 
     len = EC_POINT_point2buf(group, point, form, &amp;buffer, NULL);
     if (len == 0) {
-        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
     if (ret-&gt;base == NULL &amp;&amp; (ret-&gt;base = ASN1_OCTET_STRING_new()) == NULL) {
         OPENSSL_free(buffer);
-        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     ASN1_STRING_set0(ret-&gt;base, buffer, len);
@@ -437,13 +437,13 @@ ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
     /* set the order */
     tmp = EC_GROUP_get0_order(group);
     if (tmp == NULL) {
-        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
     ret-&gt;order = BN_to_ASN1_INTEGER(tmp, orig = ret-&gt;order);
     if (ret-&gt;order == NULL) {
         ret-&gt;order = orig;
-        ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_ASN1_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
         goto err;
     }
 
@@ -453,7 +453,7 @@ ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
         ret-&gt;cofactor = BN_to_ASN1_INTEGER(tmp, orig = ret-&gt;cofactor);
         if (ret-&gt;cofactor == NULL) {
             ret-&gt;cofactor = orig;
-            ECerr(EC_F_EC_GROUP_GET_ECPARAMETERS, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
             goto err;
         }
     }
@@ -474,7 +474,7 @@ ECPKPARAMETERS *EC_GROUP_get_ecpkparameters(const EC_GROUP *group,
 
     if (ret == NULL) {
         if ((ret = ECPKPARAMETERS_new()) == NULL) {
-            ECerr(EC_F_EC_GROUP_GET_ECPKPARAMETERS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     } else {
@@ -495,7 +495,7 @@ ECPKPARAMETERS *EC_GROUP_get_ecpkparameters(const EC_GROUP *group,
 
             if (asn1obj == NULL || OBJ_length(asn1obj) == 0) {
                 ASN1_OBJECT_free(asn1obj);
-                ECerr(EC_F_EC_GROUP_GET_ECPKPARAMETERS, EC_R_MISSING_OID);
+                ERR_raise(ERR_LIB_EC, EC_R_MISSING_OID);
                 ok = 0;
             } else {
                 ret-&gt;type = ECPKPARAMETERS_TYPE_NAMED;
@@ -532,7 +532,7 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
     if (params-&gt;fieldID == NULL
             || params-&gt;fieldID-&gt;fieldType == NULL
             || params-&gt;fieldID-&gt;p.ptr == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
+        ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);
         goto err;
     }
 
@@ -545,17 +545,17 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
     if (params-&gt;curve == NULL
             || params-&gt;curve-&gt;a == NULL || params-&gt;curve-&gt;a-&gt;data == NULL
             || params-&gt;curve-&gt;b == NULL || params-&gt;curve-&gt;b-&gt;data == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
+        ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);
         goto err;
     }
     a = BN_bin2bn(params-&gt;curve-&gt;a-&gt;data, params-&gt;curve-&gt;a-&gt;length, NULL);
     if (a == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     b = BN_bin2bn(params-&gt;curve-&gt;b-&gt;data, params-&gt;curve-&gt;b-&gt;length, NULL);
     if (b == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
@@ -564,7 +564,7 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
     if (tmp == NID_X9_62_characteristic_two_field)
 #ifdef OPENSSL_NO_EC2M
     {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_EC, EC_R_GF2M_NOT_SUPPORTED);
         goto err;
     }
 #else
@@ -575,12 +575,12 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
 
         field_bits = char_two-&gt;m;
         if (field_bits &gt; OPENSSL_ECC_MAX_FIELD_BITS) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
+            ERR_raise(ERR_LIB_EC, EC_R_FIELD_TOO_LARGE);
             goto err;
         }
 
         if ((p = BN_new()) == NULL) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
@@ -591,15 +591,14 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
             long tmp_long;
 
             if (!char_two-&gt;p.tpBasis) {
-                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
+                ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);
                 goto err;
             }
 
             tmp_long = ASN1_INTEGER_get(char_two-&gt;p.tpBasis);
 
             if (!(char_two-&gt;m &gt; tmp_long &amp;&amp; tmp_long &gt; 0)) {
-                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
-                      EC_R_INVALID_TRINOMIAL_BASIS);
+                ERR_raise(ERR_LIB_EC, EC_R_INVALID_TRINOMIAL_BASIS);
                 goto err;
             }
 
@@ -615,15 +614,14 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
 
             penta = char_two-&gt;p.ppBasis;
             if (penta == NULL) {
-                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
+                ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);
                 goto err;
             }
 
             if (!
                 (char_two-&gt;m &gt; penta-&gt;k3 &amp;&amp; penta-&gt;k3 &gt; penta-&gt;k2
                  &amp;&amp; penta-&gt;k2 &gt; penta-&gt;k1 &amp;&amp; penta-&gt;k1 &gt; 0)) {
-                ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
-                      EC_R_INVALID_PENTANOMIAL_BASIS);
+                ERR_raise(ERR_LIB_EC, EC_R_INVALID_PENTANOMIAL_BASIS);
                 goto err;
             }
 
@@ -639,11 +637,11 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
             if (!BN_set_bit(p, 0))
                 goto err;
         } else if (tmp == NID_X9_62_onBasis) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);
+            ERR_raise(ERR_LIB_EC, EC_R_NOT_IMPLEMENTED);
             goto err;
         } else {                /* error */
 
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
+            ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);
             goto err;
         }
 
@@ -655,35 +653,35 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
         /* we have a curve over a prime field */
         /* extract the prime number */
         if (params-&gt;fieldID-&gt;p.prime == NULL) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
+            ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);
             goto err;
         }
         p = ASN1_INTEGER_to_BN(params-&gt;fieldID-&gt;p.prime, NULL);
         if (p == NULL) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
             goto err;
         }
 
         if (BN_is_negative(p) || BN_is_zero(p)) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_FIELD);
             goto err;
         }
 
         field_bits = BN_num_bits(p);
         if (field_bits &gt; OPENSSL_ECC_MAX_FIELD_BITS) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
+            ERR_raise(ERR_LIB_EC, EC_R_FIELD_TOO_LARGE);
             goto err;
         }
 
         /* create the EC_GROUP structure */
         ret = EC_GROUP_new_curve_GFp(p, a, b, NULL);
     } else {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_FIELD);
         goto err;
     }
 
     if (ret == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
@@ -691,7 +689,7 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
     if (params-&gt;curve-&gt;seed != NULL) {
         OPENSSL_free(ret-&gt;seed);
         if ((ret-&gt;seed = OPENSSL_malloc(params-&gt;curve-&gt;seed-&gt;length)) == NULL) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         memcpy(ret-&gt;seed, params-&gt;curve-&gt;seed-&gt;data,
@@ -702,7 +700,7 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
     if (params-&gt;order == NULL
             || params-&gt;base == NULL
             || params-&gt;base-&gt;data == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
+        ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);
         goto err;
     }
 
@@ -716,21 +714,21 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
     /* extract the ec point */
     if (!EC_POINT_oct2point(ret, point, params-&gt;base-&gt;data,
                             params-&gt;base-&gt;length, NULL)) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
     /* extract the order */
     if ((a = ASN1_INTEGER_to_BN(params-&gt;order, a)) == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
         goto err;
     }
     if (BN_is_negative(a) || BN_is_zero(a)) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_GROUP_ORDER);
         goto err;
     }
     if (BN_num_bits(a) &gt; (int)field_bits + 1) { /* Hasse bound */
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_GROUP_ORDER);
         goto err;
     }
 
@@ -739,12 +737,12 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
         BN_free(b);
         b = NULL;
     } else if ((b = ASN1_INTEGER_to_BN(params-&gt;cofactor, b)) == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_ASN1_LIB);
         goto err;
     }
     /* set the generator, order and cofactor (if present) */
     if (!EC_GROUP_set_generator(ret, point, a, b)) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
@@ -761,13 +759,13 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
      * mathematically wrong anyway and should not be used.
      */
     if ((ctx = BN_CTX_new()) == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     if ((dup = EC_GROUP_dup(ret)) == NULL
             || EC_GROUP_set_seed(dup, NULL, 0) != 1
             || !EC_GROUP_set_generator(dup, point, a, NULL)) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
     if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {
@@ -792,7 +790,7 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
 #endif /* !def(OPENSSL_NO_EC_NISTP_64_GCC_128) */
 
         if ((named_group = EC_GROUP_new_by_curve_name(curve_name)) == NULL) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
         EC_GROUP_free(ret);
@@ -844,7 +842,7 @@ EC_GROUP *EC_GROUP_new_from_ecpkparameters(const ECPKPARAMETERS *params)
     int tmp = 0;
 
     if (params == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS, EC_R_MISSING_PARAMETERS);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PARAMETERS);
         return NULL;
     }
 
@@ -852,8 +850,7 @@ EC_GROUP *EC_GROUP_new_from_ecpkparameters(const ECPKPARAMETERS *params)
         /* the curve is given by an OID */
         tmp = OBJ_obj2nid(params-&gt;value.named_curve);
         if ((ret = EC_GROUP_new_by_curve_name(tmp)) == NULL) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS,
-                  EC_R_EC_GROUP_NEW_BY_NAME_FAILURE);
+            ERR_raise(ERR_LIB_EC, EC_R_EC_GROUP_NEW_BY_NAME_FAILURE);
             return NULL;
         }
         EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_NAMED_CURVE);
@@ -861,7 +858,7 @@ EC_GROUP *EC_GROUP_new_from_ecpkparameters(const ECPKPARAMETERS *params)
         /* the parameters are given by an ECPARAMETERS structure */
         ret = EC_GROUP_new_from_ecparameters(params-&gt;value.parameters);
         if (!ret) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             return NULL;
         }
         EC_GROUP_set_asn1_flag(ret, OPENSSL_EC_EXPLICIT_CURVE);
@@ -869,7 +866,7 @@ EC_GROUP *EC_GROUP_new_from_ecpkparameters(const ECPKPARAMETERS *params)
         /* implicit parameters inherited from CA - unsupported */
         return NULL;
     } else {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS, EC_R_ASN1_ERROR);
+        ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);
         return NULL;
     }
 
@@ -912,11 +909,11 @@ int i2d_ECPKParameters(const EC_GROUP *a, unsigned char **out)
     int ret = 0;
     ECPKPARAMETERS *tmp = EC_GROUP_get_ecpkparameters(a, NULL);
     if (tmp == NULL) {
-        ECerr(EC_F_I2D_ECPKPARAMETERS, EC_R_GROUP2PKPARAMETERS_FAILURE);
+        ERR_raise(ERR_LIB_EC, EC_R_GROUP2PKPARAMETERS_FAILURE);
         return 0;
     }
     if ((ret = i2d_ECPKPARAMETERS(tmp, out)) == 0) {
-        ECerr(EC_F_I2D_ECPKPARAMETERS, EC_R_I2D_ECPKPARAMETERS_FAILURE);
+        ERR_raise(ERR_LIB_EC, EC_R_I2D_ECPKPARAMETERS_FAILURE);
         ECPKPARAMETERS_free(tmp);
         return 0;
     }
@@ -937,7 +934,7 @@ EC_KEY *d2i_ECPrivateKey(EC_KEY **a, const unsigned char **in, long len)
 
     if (a == NULL || *a == NULL) {
         if ((ret = EC_KEY_new()) == NULL) {
-            ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     } else
@@ -952,7 +949,7 @@ EC_KEY *d2i_ECPrivateKey(EC_KEY **a, const unsigned char **in, long len)
     }
 
     if (ret-&gt;group == NULL) {
-        ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
@@ -964,14 +961,14 @@ EC_KEY *d2i_ECPrivateKey(EC_KEY **a, const unsigned char **in, long len)
                             ASN1_STRING_length(pkey)) == 0)
             goto err;
     } else {
-        ECerr(EC_F_D2I_ECPRIVATEKEY, EC_R_MISSING_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PRIVATE_KEY);
         goto err;
     }
 
     EC_POINT_clear_free(ret-&gt;pub_key);
     ret-&gt;pub_key = EC_POINT_new(ret-&gt;group);
     if (ret-&gt;pub_key == NULL) {
-        ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
@@ -982,7 +979,7 @@ EC_KEY *d2i_ECPrivateKey(EC_KEY **a, const unsigned char **in, long len)
         pub_oct = ASN1_STRING_get0_data(priv_key-&gt;publicKey);
         pub_oct_len = ASN1_STRING_length(priv_key-&gt;publicKey);
         if (!EC_KEY_oct2key(ret, pub_oct, pub_oct_len, NULL)) {
-            ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
     } else {
@@ -1017,12 +1014,12 @@ int i2d_ECPrivateKey(const EC_KEY *a, unsigned char **out)
 
     if (a == NULL || a-&gt;group == NULL ||
         (!(a-&gt;enc_flag &amp; EC_PKEY_NO_PUBKEY) &amp;&amp; a-&gt;pub_key == NULL)) {
-        ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         goto err;
     }
 
     if ((priv_key = EC_PRIVATEKEY_new()) == NULL) {
-        ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -1031,7 +1028,7 @@ int i2d_ECPrivateKey(const EC_KEY *a, unsigned char **out)
     privlen = EC_KEY_priv2buf(a, &amp;priv);
 
     if (privlen == 0) {
-        ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
@@ -1042,7 +1039,7 @@ int i2d_ECPrivateKey(const EC_KEY *a, unsigned char **out)
         if ((priv_key-&gt;parameters =
              EC_GROUP_get_ecpkparameters(a-&gt;group,
                                         priv_key-&gt;parameters)) == NULL) {
-            ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
     }
@@ -1050,14 +1047,14 @@ int i2d_ECPrivateKey(const EC_KEY *a, unsigned char **out)
     if (!(a-&gt;enc_flag &amp; EC_PKEY_NO_PUBKEY)) {
         priv_key-&gt;publicKey = ASN1_BIT_STRING_new();
         if (priv_key-&gt;publicKey == NULL) {
-            ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
         publen = EC_KEY_key2buf(a, a-&gt;conv_form, &amp;pub, NULL);
 
         if (publen == 0) {
-            ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
 
@@ -1068,7 +1065,7 @@ int i2d_ECPrivateKey(const EC_KEY *a, unsigned char **out)
     }
 
     if ((ret = i2d_EC_PRIVATEKEY(priv_key, out)) == 0) {
-        ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
     ok = 1;
@@ -1082,7 +1079,7 @@ int i2d_ECPrivateKey(const EC_KEY *a, unsigned char **out)
 int i2d_ECParameters(const EC_KEY *a, unsigned char **out)
 {
     if (a == NULL) {
-        ECerr(EC_F_I2D_ECPARAMETERS, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     return i2d_ECPKParameters(a-&gt;group, out);
@@ -1093,13 +1090,13 @@ EC_KEY *d2i_ECParameters(EC_KEY **a, const unsigned char **in, long len)
     EC_KEY *ret;
 
     if (in == NULL || *in == NULL) {
-        ECerr(EC_F_D2I_ECPARAMETERS, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
 
     if (a == NULL || *a == NULL) {
         if ((ret = EC_KEY_new()) == NULL) {
-            ECerr(EC_F_D2I_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     } else
@@ -1128,13 +1125,13 @@ EC_KEY *o2i_ECPublicKey(EC_KEY **a, const unsigned char **in, long len)
         /*
          * sorry, but a EC_GROUP-structure is necessary to set the public key
          */
-        ECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     ret = *a;
     /* EC_KEY_opt2key updates dirty_cnt */
     if (!EC_KEY_oct2key(ret, *in, len, NULL)) {
-        ECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         return 0;
     }
     *in += len;
@@ -1147,7 +1144,7 @@ int i2o_ECPublicKey(const EC_KEY *a, unsigned char **out)
     int new_buffer = 0;
 
     if (a == NULL) {
-        ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -1160,14 +1157,14 @@ int i2o_ECPublicKey(const EC_KEY *a, unsigned char **out)
 
     if (*out == NULL) {
         if ((*out = OPENSSL_malloc(buf_len)) == NULL) {
-            ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         new_buffer = 1;
     }
     if (!EC_POINT_point2oct(a-&gt;group, a-&gt;pub_key, a-&gt;conv_form,
                             *out, buf_len, NULL)) {
-        ECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         if (new_buffer) {
             OPENSSL_free(*out);
             *out = NULL;
@@ -1188,7 +1185,7 @@ ECDSA_SIG *ECDSA_SIG_new(void)
 {
     ECDSA_SIG *sig = OPENSSL_zalloc(sizeof(*sig));
     if (sig == NULL)
-        ECerr(EC_F_ECDSA_SIG_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
     return sig;
 }
 
diff --git a/crypto/ec/ec_backend.c b/crypto/ec/ec_backend.c
index f4a6d976aa..dccf6a15b9 100644
--- a/crypto/ec/ec_backend.c
+++ b/crypto/ec/ec_backend.c
@@ -64,7 +64,7 @@ int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
     size_t genbuf_len, seed_len;
 
     if (group == NULL) {
-        ECerr(0,EC_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC,EC_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -74,7 +74,7 @@ int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
         || !ossl_param_build_set_utf8_string(tmpl, params,
                                              OSSL_PKEY_PARAM_EC_ENCODING,
                                              encoding_name)) {
-        ECerr(0, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         return 0;
     }
 
@@ -88,7 +88,7 @@ int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
         } else if (fid == NID_X9_62_characteristic_two_field) {
             field_type = SN_X9_62_characteristic_two_field;
         } else {
-            ECerr(0, EC_R_INVALID_FIELD);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_FIELD);
             return 0;
         }
 
@@ -96,29 +96,29 @@ int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
         a = BN_CTX_get(bnctx);
         b = BN_CTX_get(bnctx);
         if (b == NULL) {
-            ECerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
         if (!EC_GROUP_get_curve(group, p, a, b, bnctx)) {
-            ECerr(0, EC_R_INVALID_CURVE);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_CURVE);
             goto err;
         }
 
         order = EC_GROUP_get0_order(group);
         if (order == NULL) {
-            ECerr(0, EC_R_INVALID_GROUP_ORDER);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_GROUP_ORDER);
             goto err;
         }
         genpt = EC_GROUP_get0_generator(group);
         if (genpt == NULL) {
-            ECerr(0, EC_R_INVALID_GENERATOR);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_GENERATOR);
             goto err;
         }
         genform = EC_GROUP_get_point_conversion_form(group);
         genbuf_len = EC_POINT_point2buf(group, genpt, genform, genbuf, bnctx);
         if (genbuf_len == 0) {
-            ECerr(0, EC_R_INVALID_GENERATOR);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_GENERATOR);
             goto err;
         }
 
@@ -133,7 +133,7 @@ int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
             || !ossl_param_build_set_octet_string(tmpl, params,
                                                   OSSL_PKEY_PARAM_EC_GENERATOR,
                                                   *genbuf, genbuf_len)) {
-            ECerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
@@ -141,7 +141,7 @@ int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
         if (cofactor != NULL
             &amp;&amp; !ossl_param_build_set_bn(tmpl, params,
                                         OSSL_PKEY_PARAM_EC_COFACTOR, cofactor)) {
-            ECerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
@@ -152,12 +152,12 @@ int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
             &amp;&amp; !ossl_param_build_set_octet_string(tmpl, params,
                                                   OSSL_PKEY_PARAM_EC_SEED,
                                                   seed, seed_len)) {
-            ECerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 #ifdef OPENSSL_NO_EC2M
         if (fid == NID_X9_62_characteristic_two_field) {
-            ECerr(0, EC_R_GF2M_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_EC, EC_R_GF2M_NOT_SUPPORTED);
             goto err;
         }
 #endif
@@ -169,7 +169,7 @@ int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
             || !ossl_param_build_set_utf8_string(tmpl, params,
                                                  OSSL_PKEY_PARAM_GROUP_NAME,
                                                  curve_name)) {
-            ECerr(0, EC_R_INVALID_CURVE);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_CURVE);
             goto err;
         }
     }
diff --git a/crypto/ec/ec_check.c b/crypto/ec/ec_check.c
index a29519cc4d..6af002c0a8 100644
--- a/crypto/ec/ec_check.c
+++ b/crypto/ec/ec_check.c
@@ -23,14 +23,14 @@ int EC_GROUP_check_named_curve(const EC_GROUP *group, int nist_only,
     BN_CTX *new_ctx = NULL;
 
     if (group == NULL) {
-        ECerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return NID_undef;
     }
 
     if (ctx == NULL) {
         ctx = new_ctx = BN_CTX_new_ex(NULL);
         if (ctx == NULL) {
-            ECerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             return NID_undef;
         }
     }
@@ -58,7 +58,7 @@ int EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx)
     EC_POINT *point = NULL;
 
     if (group == NULL || group-&gt;meth == NULL) {
-        ECerr(EC_F_EC_GROUP_CHECK, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -69,24 +69,24 @@ int EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx)
     if (ctx == NULL) {
         ctx = new_ctx = BN_CTX_new();
         if (ctx == NULL) {
-            ECerr(EC_F_EC_GROUP_CHECK, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
 
     /* check the discriminant */
     if (!EC_GROUP_check_discriminant(group, ctx)) {
-        ECerr(EC_F_EC_GROUP_CHECK, EC_R_DISCRIMINANT_IS_ZERO);
+        ERR_raise(ERR_LIB_EC, EC_R_DISCRIMINANT_IS_ZERO);
         goto err;
     }
 
     /* check the generator */
     if (group-&gt;generator == NULL) {
-        ECerr(EC_F_EC_GROUP_CHECK, EC_R_UNDEFINED_GENERATOR);
+        ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);
         goto err;
     }
     if (EC_POINT_is_on_curve(group, group-&gt;generator, ctx) &lt;= 0) {
-        ECerr(EC_F_EC_GROUP_CHECK, EC_R_POINT_IS_NOT_ON_CURVE);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_IS_NOT_ON_CURVE);
         goto err;
     }
 
@@ -97,14 +97,14 @@ int EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx)
     if (order == NULL)
         goto err;
     if (BN_is_zero(order)) {
-        ECerr(EC_F_EC_GROUP_CHECK, EC_R_UNDEFINED_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_ORDER);
         goto err;
     }
 
     if (!EC_POINT_mul(group, point, order, NULL, NULL, ctx))
         goto err;
     if (!EC_POINT_is_at_infinity(group, point)) {
-        ECerr(EC_F_EC_GROUP_CHECK, EC_R_INVALID_GROUP_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_GROUP_ORDER);
         goto err;
     }
 
diff --git a/crypto/ec/ec_curve.c b/crypto/ec/ec_curve.c
index 687860ea92..051d3fe181 100644
--- a/crypto/ec/ec_curve.c
+++ b/crypto/ec/ec_curve.c
@@ -3201,7 +3201,7 @@ static EC_GROUP *ec_group_new_from_data(OSSL_LIB_CTX *libctx,
                                curve.meth != NULL ? curve.meth() : NULL);
 
     if ((ctx = BN_CTX_new_ex(libctx)) == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -3214,7 +3214,7 @@ static EC_GROUP *ec_group_new_from_data(OSSL_LIB_CTX *libctx,
     if ((p = BN_bin2bn(params + 0 * param_len, param_len, NULL)) == NULL
         || (a = BN_bin2bn(params + 1 * param_len, param_len, NULL)) == NULL
         || (b = BN_bin2bn(params + 2 * param_len, param_len, NULL)) == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
@@ -3222,12 +3222,12 @@ static EC_GROUP *ec_group_new_from_data(OSSL_LIB_CTX *libctx,
         meth = curve.meth();
         if (((group = ec_group_new_ex(libctx, propq, meth)) == NULL) ||
             (!(group-&gt;meth-&gt;group_set_curve(group, p, a, b, ctx)))) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
     } else if (data-&gt;field_type == NID_X9_62_prime_field) {
         if ((group = EC_GROUP_new_curve_GFp(p, a, b, ctx)) == NULL) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
     }
@@ -3236,7 +3236,7 @@ static EC_GROUP *ec_group_new_from_data(OSSL_LIB_CTX *libctx,
                                  * NID_X9_62_characteristic_two_field */
 
         if ((group = EC_GROUP_new_curve_GF2m(p, a, b, ctx)) == NULL) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
     }
@@ -3245,31 +3245,31 @@ static EC_GROUP *ec_group_new_from_data(OSSL_LIB_CTX *libctx,
     EC_GROUP_set_curve_name(group, curve.nid);
 
     if ((P = EC_POINT_new(group)) == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
     if ((x = BN_bin2bn(params + 3 * param_len, param_len, NULL)) == NULL
         || (y = BN_bin2bn(params + 4 * param_len, param_len, NULL)) == NULL) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     if (!EC_POINT_set_affine_coordinates(group, P, x, y, ctx)) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
     if ((order = BN_bin2bn(params + 5 * param_len, param_len, NULL)) == NULL
         || !BN_set_word(x, (BN_ULONG)data-&gt;cofactor)) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     if (!EC_GROUP_set_generator(group, P, order, x)) {
-        ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
     if (seed_len) {
         if (!EC_GROUP_set_seed(group, params - seed_len, seed_len)) {
-            ECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
     }
@@ -3298,9 +3298,11 @@ EC_GROUP *EC_GROUP_new_by_curve_name_ex(OSSL_LIB_CTX *libctx, const char *propq,
 
     if ((curve = ec_curve_nid2curve(nid)) == NULL
         || (ret = ec_group_new_from_data(libctx, propq, *curve)) == NULL) {
-        ECerr(0, EC_R_UNKNOWN_GROUP);
 #ifndef FIPS_MODULE
-        ERR_add_error_data(2, &quot;name=&quot;, OBJ_nid2sn(nid));
+        ERR_raise_data(ERR_LIB_EC, EC_R_UNKNOWN_GROUP,
+                       &quot;name=%s&quot;, OBJ_nid2sn(nid));
+#else
+        ERR_raise(ERR_LIB_EC, EC_R_UNKNOWN_GROUP);
 #endif
         return NULL;
     }
diff --git a/crypto/ec/ec_key.c b/crypto/ec/ec_key.c
index 63001203ae..da3d6f04a2 100644
--- a/crypto/ec/ec_key.c
+++ b/crypto/ec/ec_key.c
@@ -103,7 +103,7 @@ void EC_KEY_free(EC_KEY *r)
 EC_KEY *EC_KEY_copy(EC_KEY *dest, const EC_KEY *src)
 {
     if (dest == NULL || src == NULL) {
-        ECerr(EC_F_EC_KEY_COPY, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if (src-&gt;meth != dest-&gt;meth) {
@@ -216,7 +216,7 @@ ENGINE *EC_KEY_get0_engine(const EC_KEY *eckey)
 int EC_KEY_generate_key(EC_KEY *eckey)
 {
     if (eckey == NULL || eckey-&gt;group == NULL) {
-        ECerr(EC_F_EC_KEY_GENERATE_KEY, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if (eckey-&gt;meth-&gt;keygen != NULL) {
@@ -228,7 +228,7 @@ int EC_KEY_generate_key(EC_KEY *eckey)
 
         return ret;
     }
-    ECerr(EC_F_EC_KEY_GENERATE_KEY, EC_R_OPERATION_NOT_SUPPORTED);
+    ERR_raise(ERR_LIB_EC, EC_R_OPERATION_NOT_SUPPORTED);
     return 0;
 }
 
@@ -387,12 +387,12 @@ int ec_key_simple_generate_public_key(EC_KEY *eckey)
 int EC_KEY_check_key(const EC_KEY *eckey)
 {
     if (eckey == NULL || eckey-&gt;group == NULL || eckey-&gt;pub_key == NULL) {
-        ECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
     if (eckey-&gt;group-&gt;meth-&gt;keycheck == NULL) {
-        ECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
 
@@ -452,13 +452,13 @@ int ec_key_public_check(const EC_KEY *eckey, BN_CTX *ctx)
     const BIGNUM *order = NULL;
 
     if (eckey == NULL || eckey-&gt;group == NULL || eckey-&gt;pub_key == NULL) {
-        ECerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
     /* 5.6.2.3.3 (Step 1): Q != infinity */
     if (EC_POINT_is_at_infinity(eckey-&gt;group, eckey-&gt;pub_key)) {
-        ECerr(0, EC_R_POINT_AT_INFINITY);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_AT_INFINITY);
         return 0;
     }
 
@@ -468,28 +468,28 @@ int ec_key_public_check(const EC_KEY *eckey, BN_CTX *ctx)
 
     /* 5.6.2.3.3 (Step 2) Test if the public key is in range */
     if (!ec_key_public_range_check(ctx, eckey)) {
-        ECerr(0, EC_R_COORDINATES_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);
         goto err;
     }
 
     /* 5.6.2.3.3 (Step 3) is the pub_key on the elliptic curve */
     if (EC_POINT_is_on_curve(eckey-&gt;group, eckey-&gt;pub_key, ctx) &lt;= 0) {
-        ECerr(0, EC_R_POINT_IS_NOT_ON_CURVE);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_IS_NOT_ON_CURVE);
         goto err;
     }
 
     order = eckey-&gt;group-&gt;order;
     if (BN_is_zero(order)) {
-        ECerr(0, EC_R_INVALID_GROUP_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_GROUP_ORDER);
         goto err;
     }
     /* 5.6.2.3.3 (Step 4) : pub_key * order is the point at infinity. */
     if (!EC_POINT_mul(eckey-&gt;group, point, NULL, eckey-&gt;pub_key, order, ctx)) {
-        ECerr(0, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
     if (!EC_POINT_is_at_infinity(eckey-&gt;group, point)) {
-        ECerr(0, EC_R_WRONG_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_WRONG_ORDER);
         goto err;
     }
     ret = 1;
@@ -506,12 +506,12 @@ err:
 int ec_key_private_check(const EC_KEY *eckey)
 {
     if (eckey == NULL || eckey-&gt;group == NULL || eckey-&gt;priv_key == NULL) {
-        ECerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if (BN_cmp(eckey-&gt;priv_key, BN_value_one()) &lt; 0
         || BN_cmp(eckey-&gt;priv_key, eckey-&gt;group-&gt;order) &gt;= 0) {
-        ECerr(0, EC_R_INVALID_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_PRIVATE_KEY);
         return 0;
     }
     return 1;
@@ -531,7 +531,7 @@ int ec_key_pairwise_check(const EC_KEY *eckey, BN_CTX *ctx)
        || eckey-&gt;group == NULL
        || eckey-&gt;pub_key == NULL
        || eckey-&gt;priv_key == NULL) {
-        ECerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -541,11 +541,11 @@ int ec_key_pairwise_check(const EC_KEY *eckey, BN_CTX *ctx)
 
 
     if (!EC_POINT_mul(eckey-&gt;group, point, eckey-&gt;priv_key, NULL, NULL, ctx)) {
-        ECerr(0, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
     if (EC_POINT_cmp(eckey-&gt;group, point, eckey-&gt;pub_key, ctx) != 0) {
-        ECerr(0, EC_R_INVALID_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_PRIVATE_KEY);
         goto err;
     }
     ret = 1;
@@ -571,7 +571,7 @@ int ec_key_simple_check_key(const EC_KEY *eckey)
     BN_CTX *ctx = NULL;
 
     if (eckey == NULL) {
-        ECerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if ((ctx = BN_CTX_new_ex(eckey-&gt;libctx)) == NULL)
@@ -600,8 +600,7 @@ int EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,
     int ok = 0;
 
     if (key == NULL || key-&gt;group == NULL || x == NULL || y == NULL) {
-        ECerr(EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES,
-              ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     ctx = BN_CTX_new_ex(key-&gt;libctx);
@@ -629,8 +628,7 @@ int EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,
      * inside EC_KEY_check_key().
      */
     if (BN_cmp(x, tx) || BN_cmp(y, ty)) {
-        ECerr(EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES,
-              EC_R_COORDINATES_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);
         goto err;
     }
 
@@ -881,7 +879,7 @@ size_t EC_KEY_priv2oct(const EC_KEY *eckey,
     if (eckey-&gt;group == NULL || eckey-&gt;group-&gt;meth == NULL)
         return 0;
     if (eckey-&gt;group-&gt;meth-&gt;priv2oct == NULL) {
-        ECerr(EC_F_EC_KEY_PRIV2OCT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
 
@@ -904,7 +902,7 @@ size_t ec_key_simple_priv2oct(const EC_KEY *eckey,
     /* Octetstring may need leading zeros if BN is to short */
 
     if (BN_bn2binpad(eckey-&gt;priv_key, buf, buf_len) == -1) {
-        ECerr(EC_F_EC_KEY_SIMPLE_PRIV2OCT, EC_R_BUFFER_TOO_SMALL);
+        ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
         return 0;
     }
 
@@ -918,7 +916,7 @@ int EC_KEY_oct2priv(EC_KEY *eckey, const unsigned char *buf, size_t len)
     if (eckey-&gt;group == NULL || eckey-&gt;group-&gt;meth == NULL)
         return 0;
     if (eckey-&gt;group-&gt;meth-&gt;oct2priv == NULL) {
-        ECerr(EC_F_EC_KEY_OCT2PRIV, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     ret = eckey-&gt;group-&gt;meth-&gt;oct2priv(eckey, buf, len);
@@ -932,12 +930,12 @@ int ec_key_simple_oct2priv(EC_KEY *eckey, const unsigned char *buf, size_t len)
     if (eckey-&gt;priv_key == NULL)
         eckey-&gt;priv_key = BN_secure_new();
     if (eckey-&gt;priv_key == NULL) {
-        ECerr(EC_F_EC_KEY_SIMPLE_OCT2PRIV, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     eckey-&gt;priv_key = BN_bin2bn(buf, len, eckey-&gt;priv_key);
     if (eckey-&gt;priv_key == NULL) {
-        ECerr(EC_F_EC_KEY_SIMPLE_OCT2PRIV, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         return 0;
     }
     eckey-&gt;dirty_cnt++;
@@ -953,7 +951,7 @@ size_t EC_KEY_priv2buf(const EC_KEY *eckey, unsigned char **pbuf)
     if (len == 0)
         return 0;
     if ((buf = OPENSSL_malloc(len)) == NULL) {
-        ECerr(EC_F_EC_KEY_PRIV2BUF, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     len = EC_KEY_priv2oct(eckey, buf, len);
diff --git a/crypto/ec/ec_kmeth.c b/crypto/ec/ec_kmeth.c
index d01b96f654..ea3a077ad2 100644
--- a/crypto/ec/ec_kmeth.c
+++ b/crypto/ec/ec_kmeth.c
@@ -82,7 +82,7 @@ EC_KEY *ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
     EC_KEY *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        ECerr(EC_F_EC_KEY_NEW_METHOD_INT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -90,7 +90,7 @@ EC_KEY *ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
     if (propq != NULL) {
         ret-&gt;propq = OPENSSL_strdup(propq);
         if (ret-&gt;propq == NULL) {
-            ECerr(EC_F_EC_KEY_NEW_METHOD_INT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -98,7 +98,7 @@ EC_KEY *ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
     ret-&gt;references = 1;
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        ECerr(EC_F_EC_KEY_NEW_METHOD_INT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -106,7 +106,7 @@ EC_KEY *ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
 #if !defined(OPENSSL_NO_ENGINE) &amp;&amp; !defined(FIPS_MODULE)
     if (engine != NULL) {
         if (!ENGINE_init(engine)) {
-            ECerr(EC_F_EC_KEY_NEW_METHOD_INT, ERR_R_ENGINE_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_ENGINE_LIB);
             goto err;
         }
         ret-&gt;engine = engine;
@@ -115,7 +115,7 @@ EC_KEY *ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
     if (ret-&gt;engine != NULL) {
         ret-&gt;meth = ENGINE_get_EC(ret-&gt;engine);
         if (ret-&gt;meth == NULL) {
-            ECerr(EC_F_EC_KEY_NEW_METHOD_INT, ERR_R_ENGINE_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_ENGINE_LIB);
             goto err;
         }
     }
@@ -132,7 +132,7 @@ EC_KEY *ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
 #endif
 
     if (ret-&gt;meth-&gt;init != NULL &amp;&amp; ret-&gt;meth-&gt;init(ret) == 0) {
-        ECerr(EC_F_EC_KEY_NEW_METHOD_INT, ERR_R_INIT_FAIL);
+        ERR_raise(ERR_LIB_EC, ERR_R_INIT_FAIL);
         goto err;
     }
     return ret;
@@ -157,11 +157,11 @@ int ECDH_compute_key(void *out, size_t outlen, const EC_POINT *pub_key,
     unsigned char *sec = NULL;
     size_t seclen;
     if (eckey-&gt;meth-&gt;compute_key == NULL) {
-        ECerr(EC_F_ECDH_COMPUTE_KEY, EC_R_OPERATION_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_EC, EC_R_OPERATION_NOT_SUPPORTED);
         return 0;
     }
     if (outlen &gt; INT_MAX) {
-        ECerr(EC_F_ECDH_COMPUTE_KEY, EC_R_INVALID_OUTPUT_LENGTH);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_OUTPUT_LENGTH);
         return 0;
     }
     if (!eckey-&gt;meth-&gt;compute_key(&amp;sec, &amp;seclen, pub_key, eckey))
diff --git a/crypto/ec/ec_lib.c b/crypto/ec/ec_lib.c
index d1d403e175..678b77047d 100644
--- a/crypto/ec/ec_lib.c
+++ b/crypto/ec/ec_lib.c
@@ -32,17 +32,17 @@ EC_GROUP *ec_group_new_ex(OSSL_LIB_CTX *libctx, const char *propq,
     EC_GROUP *ret;
 
     if (meth == NULL) {
-        ECerr(0, EC_R_SLOT_FULL);
+        ERR_raise(ERR_LIB_EC, EC_R_SLOT_FULL);
         return NULL;
     }
     if (meth-&gt;group_init == 0) {
-        ECerr(0, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return NULL;
     }
 
     ret = OPENSSL_zalloc(sizeof(*ret));
     if (ret == NULL) {
-        ECerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -50,7 +50,7 @@ EC_GROUP *ec_group_new_ex(OSSL_LIB_CTX *libctx, const char *propq,
     if (propq != NULL) {
         ret-&gt;propq = OPENSSL_strdup(propq);
         if (ret-&gt;propq == NULL) {
-            ECerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -161,11 +161,11 @@ void EC_GROUP_clear_free(EC_GROUP *group)
 int EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src)
 {
     if (dest-&gt;meth-&gt;group_copy == 0) {
-        ECerr(EC_F_EC_GROUP_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (dest-&gt;meth != src-&gt;meth) {
-        ECerr(EC_F_EC_GROUP_COPY, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     if (dest == src)
@@ -248,7 +248,7 @@ int EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src)
     if (src-&gt;seed) {
         OPENSSL_free(dest-&gt;seed);
         if ((dest-&gt;seed = OPENSSL_malloc(src-&gt;seed_len)) == NULL) {
-            ECerr(EC_F_EC_GROUP_COPY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         if (!memcpy(dest-&gt;seed, src-&gt;seed, src-&gt;seed_len))
@@ -365,14 +365,14 @@ int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,
                            const BIGNUM *order, const BIGNUM *cofactor)
 {
     if (generator == NULL) {
-        ECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
     /* require group-&gt;field &gt;= 1 */
     if (group-&gt;field == NULL || BN_is_zero(group-&gt;field)
         || BN_is_negative(group-&gt;field)) {
-        ECerr(EC_F_EC_GROUP_SET_GENERATOR, EC_R_INVALID_FIELD);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_FIELD);
         return 0;
     }
 
@@ -383,7 +383,7 @@ int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,
      */
     if (order == NULL || BN_is_zero(order) || BN_is_negative(order)
         || BN_num_bits(order) &gt; BN_num_bits(group-&gt;field) + 1) {
-        ECerr(EC_F_EC_GROUP_SET_GENERATOR, EC_R_INVALID_GROUP_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_GROUP_ORDER);
         return 0;
     }
 
@@ -393,7 +393,7 @@ int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,
      * So accept cofactor == NULL or cofactor &gt;= 0.
      */
     if (cofactor != NULL &amp;&amp; BN_is_negative(cofactor)) {
-        ECerr(EC_F_EC_GROUP_SET_GENERATOR, EC_R_UNKNOWN_COFACTOR);
+        ERR_raise(ERR_LIB_EC, EC_R_UNKNOWN_COFACTOR);
         return 0;
     }
 
@@ -530,7 +530,7 @@ size_t EC_GROUP_set_seed(EC_GROUP *group, const unsigned char *p, size_t len)
         return 1;
 
     if ((group-&gt;seed = OPENSSL_malloc(len)) == NULL) {
-        ECerr(EC_F_EC_GROUP_SET_SEED, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     memcpy(group-&gt;seed, p, len);
@@ -553,7 +553,7 @@ int EC_GROUP_set_curve(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a,
                        const BIGNUM *b, BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;group_set_curve == 0) {
-        ECerr(EC_F_EC_GROUP_SET_CURVE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     return group-&gt;meth-&gt;group_set_curve(group, p, a, b, ctx);
@@ -563,7 +563,7 @@ int EC_GROUP_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b,
                        BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;group_get_curve == NULL) {
-        ECerr(EC_F_EC_GROUP_GET_CURVE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     return group-&gt;meth-&gt;group_get_curve(group, p, a, b, ctx);
@@ -600,7 +600,7 @@ int EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p, BIGNUM *a,
 int EC_GROUP_get_degree(const EC_GROUP *group)
 {
     if (group-&gt;meth-&gt;group_get_degree == 0) {
-        ECerr(EC_F_EC_GROUP_GET_DEGREE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     return group-&gt;meth-&gt;group_get_degree(group);
@@ -609,8 +609,7 @@ int EC_GROUP_get_degree(const EC_GROUP *group)
 int EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;group_check_discriminant == 0) {
-        ECerr(EC_F_EC_GROUP_CHECK_DISCRIMINANT,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     return group-&gt;meth-&gt;group_check_discriminant(group, ctx);
@@ -715,17 +714,17 @@ EC_POINT *EC_POINT_new(const EC_GROUP *group)
     EC_POINT *ret;
 
     if (group == NULL) {
-        ECerr(EC_F_EC_POINT_NEW, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if (group-&gt;meth-&gt;point_init == NULL) {
-        ECerr(EC_F_EC_POINT_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return NULL;
     }
 
     ret = OPENSSL_zalloc(sizeof(*ret));
     if (ret == NULL) {
-        ECerr(EC_F_EC_POINT_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -765,14 +764,14 @@ void EC_POINT_clear_free(EC_POINT *point)
 int EC_POINT_copy(EC_POINT *dest, const EC_POINT *src)
 {
     if (dest-&gt;meth-&gt;point_copy == 0) {
-        ECerr(EC_F_EC_POINT_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (dest-&gt;meth != src-&gt;meth
             || (dest-&gt;curve_name != src-&gt;curve_name
                  &amp;&amp; dest-&gt;curve_name != 0
                  &amp;&amp; src-&gt;curve_name != 0)) {
-        ECerr(EC_F_EC_POINT_COPY, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     if (dest == src)
@@ -809,12 +808,11 @@ const EC_METHOD *EC_POINT_method_of(const EC_POINT *point)
 int EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point)
 {
     if (group-&gt;meth-&gt;point_set_to_infinity == 0) {
-        ECerr(EC_F_EC_POINT_SET_TO_INFINITY,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (group-&gt;meth != point-&gt;meth) {
-        ECerr(EC_F_EC_POINT_SET_TO_INFINITY, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     return group-&gt;meth-&gt;point_set_to_infinity(group, point);
@@ -827,13 +825,11 @@ int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                              BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;field_type != NID_X9_62_prime_field) {
-        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(point, group)) {
-        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
-              EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     return ec_GFp_simple_set_Jprojective_coordinates_GFp(group, point, x, y, z, ctx);
@@ -845,13 +841,11 @@ int EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                              BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;field_type != NID_X9_62_prime_field) {
-        ECerr(EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(point, group)) {
-        ECerr(EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP,
-              EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     return ec_GFp_simple_get_Jprojective_coordinates_GFp(group, point, x, y, z, ctx);
@@ -863,19 +857,18 @@ int EC_POINT_set_affine_coordinates(const EC_GROUP *group, EC_POINT *point,
                                     BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;point_set_affine_coordinates == NULL) {
-        ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(point, group)) {
-        ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     if (!group-&gt;meth-&gt;point_set_affine_coordinates(group, point, x, y, ctx))
         return 0;
 
     if (EC_POINT_is_on_curve(group, point, ctx) &lt;= 0) {
-        ECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES, EC_R_POINT_IS_NOT_ON_CURVE);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_IS_NOT_ON_CURVE);
         return 0;
     }
     return 1;
@@ -904,16 +897,15 @@ int EC_POINT_get_affine_coordinates(const EC_GROUP *group,
                                     BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;point_get_affine_coordinates == NULL) {
-        ECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(point, group)) {
-        ECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     if (EC_POINT_is_at_infinity(group, point)) {
-        ECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES, EC_R_POINT_AT_INFINITY);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_AT_INFINITY);
         return 0;
     }
     return group-&gt;meth-&gt;point_get_affine_coordinates(group, point, x, y, ctx);
@@ -941,12 +933,12 @@ int EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
                  const EC_POINT *b, BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;add == 0) {
-        ECerr(EC_F_EC_POINT_ADD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(r, group) || !ec_point_is_compat(a, group)
         || !ec_point_is_compat(b, group)) {
-        ECerr(EC_F_EC_POINT_ADD, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     return group-&gt;meth-&gt;add(group, r, a, b, ctx);
@@ -956,11 +948,11 @@ int EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
                  BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;dbl == 0) {
-        ECerr(EC_F_EC_POINT_DBL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(r, group) || !ec_point_is_compat(a, group)) {
-        ECerr(EC_F_EC_POINT_DBL, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     return group-&gt;meth-&gt;dbl(group, r, a, ctx);
@@ -969,11 +961,11 @@ int EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
 int EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;invert == 0) {
-        ECerr(EC_F_EC_POINT_INVERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(a, group)) {
-        ECerr(EC_F_EC_POINT_INVERT, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     return group-&gt;meth-&gt;invert(group, a, ctx);
@@ -982,12 +974,11 @@ int EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx)
 int EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)
 {
     if (group-&gt;meth-&gt;is_at_infinity == 0) {
-        ECerr(EC_F_EC_POINT_IS_AT_INFINITY,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(point, group)) {
-        ECerr(EC_F_EC_POINT_IS_AT_INFINITY, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     return group-&gt;meth-&gt;is_at_infinity(group, point);
@@ -1004,11 +995,11 @@ int EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point,
                          BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;is_on_curve == 0) {
-        ECerr(EC_F_EC_POINT_IS_ON_CURVE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(point, group)) {
-        ECerr(EC_F_EC_POINT_IS_ON_CURVE, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     return group-&gt;meth-&gt;is_on_curve(group, point, ctx);
@@ -1018,11 +1009,11 @@ int EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b,
                  BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;point_cmp == 0) {
-        ECerr(EC_F_EC_POINT_CMP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return -1;
     }
     if (!ec_point_is_compat(a, group) || !ec_point_is_compat(b, group)) {
-        ECerr(EC_F_EC_POINT_CMP, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return -1;
     }
     return group-&gt;meth-&gt;point_cmp(group, a, b, ctx);
@@ -1032,11 +1023,11 @@ int EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b,
 int EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;make_affine == 0) {
-        ECerr(EC_F_EC_POINT_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(point, group)) {
-        ECerr(EC_F_EC_POINT_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     return group-&gt;meth-&gt;make_affine(group, point, ctx);
@@ -1048,12 +1039,12 @@ int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
     size_t i;
 
     if (group-&gt;meth-&gt;points_make_affine == 0) {
-        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     for (i = 0; i &lt; num; i++) {
         if (!ec_point_is_compat(points[i], group)) {
-            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
+            ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
             return 0;
         }
     }
@@ -1079,7 +1070,7 @@ int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
 #endif
 
     if (!ec_point_is_compat(r, group)) {
-        ECerr(EC_F_EC_POINTS_MUL, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
 
@@ -1088,7 +1079,7 @@ int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
 
     for (i = 0; i &lt; num; i++) {
         if (!ec_point_is_compat(points[i], group)) {
-            ECerr(EC_F_EC_POINTS_MUL, EC_R_INCOMPATIBLE_OBJECTS);
+            ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
             return 0;
         }
     }
@@ -1098,7 +1089,7 @@ int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
         ctx = new_ctx = BN_CTX_secure_new();
 #endif
     if (ctx == NULL) {
-        ECerr(EC_F_EC_POINTS_MUL, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
         return 0;
     }
 
@@ -1126,7 +1117,7 @@ int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
 
     if (!ec_point_is_compat(r, group)
         || (point != NULL &amp;&amp; !ec_point_is_compat(point, group))) {
-        ECerr(EC_F_EC_POINT_MUL, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
 
@@ -1138,7 +1129,7 @@ int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
         ctx = new_ctx = BN_CTX_secure_new();
 #endif
     if (ctx == NULL) {
-        ECerr(EC_F_EC_POINT_MUL, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
         return 0;
     }
 
@@ -1354,8 +1345,7 @@ int EC_GROUP_get_trinomial_basis(const EC_GROUP *group, unsigned int *k)
     if (EC_GROUP_get_field_type(group) != NID_X9_62_characteristic_two_field
         || !((group-&gt;poly[0] != 0) &amp;&amp; (group-&gt;poly[1] != 0)
              &amp;&amp; (group-&gt;poly[2] == 0))) {
-        ECerr(EC_F_EC_GROUP_GET_TRINOMIAL_BASIS,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
 
@@ -1375,8 +1365,7 @@ int EC_GROUP_get_pentanomial_basis(const EC_GROUP *group, unsigned int *k1,
         || !((group-&gt;poly[0] != 0) &amp;&amp; (group-&gt;poly[1] != 0)
              &amp;&amp; (group-&gt;poly[2] != 0) &amp;&amp; (group-&gt;poly[3] != 0)
              &amp;&amp; (group-&gt;poly[4] == 0))) {
-        ECerr(EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
 
@@ -1518,7 +1507,7 @@ static EC_GROUP *group_new_from_name(const OSSL_PARAM *p,
     if (ok) {
         nid = ec_curve_name2nid(curve_name);
         if (nid == NID_undef) {
-            ECerr(0, EC_R_INVALID_CURVE);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_CURVE);
             return NULL;
         } else {
             return EC_GROUP_new_by_curve_name_ex(libctx, propq, nid);
@@ -1543,7 +1532,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
 
     ptmp = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_ENCODING);
     if (ptmp != NULL &amp;&amp; !ec_encoding_param2id(ptmp, &amp;encoding_flag)) {
-        ECerr(0, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         return 0;
     }
 
@@ -1556,7 +1545,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
     }
     bnctx = BN_CTX_new_ex(libctx);
     if (bnctx == NULL) {
-        ECerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     BN_CTX_start(bnctx);
@@ -1566,13 +1555,13 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
     b = BN_CTX_get(bnctx);
     order = BN_CTX_get(bnctx);
     if (order == NULL) {
-        ECerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     ptmp = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_FIELD_TYPE);
     if (ptmp == NULL || ptmp-&gt;data_type != OSSL_PARAM_UTF8_STRING) {
-        ECerr(0, EC_R_INVALID_FIELD);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_FIELD);
         goto err;
     }
     if (strcasecmp(ptmp-&gt;data, SN_X9_62_prime_field) == 0) {
@@ -1581,36 +1570,36 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
         is_prime_field = 0;
     } else {
         /* Invalid field */
-        ECerr(0, EC_R_UNSUPPORTED_FIELD);
+        ERR_raise(ERR_LIB_EC, EC_R_UNSUPPORTED_FIELD);
         goto err;
     }
 
     pa = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_A);
     if (!OSSL_PARAM_get_BN(pa, &amp;a)) {
-        ECerr(0, EC_R_INVALID_A);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_A);
         goto err;
     }
     pb = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_B);
     if (!OSSL_PARAM_get_BN(pb, &amp;b)) {
-        ECerr(0, EC_R_INVALID_B);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_B);
         goto err;
     }
 
     /* extract the prime number or irreducible polynomial */
     ptmp = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_P);
     if (!OSSL_PARAM_get_BN(ptmp, &amp;p)) {
-        ECerr(0, EC_R_INVALID_P);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_P);
         goto err;
     }
 
     if (is_prime_field) {
         if (BN_is_negative(p) || BN_is_zero(p)) {
-            ECerr(0, EC_R_INVALID_P);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_P);
             goto err;
         }
         field_bits = BN_num_bits(p);
         if (field_bits &gt; OPENSSL_ECC_MAX_FIELD_BITS) {
-            ECerr(0, EC_R_FIELD_TOO_LARGE);
+            ERR_raise(ERR_LIB_EC, EC_R_FIELD_TOO_LARGE);
             goto err;
         }
 
@@ -1618,7 +1607,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
         group = EC_GROUP_new_curve_GFp(p, a, b, bnctx);
     } else {
 #ifdef OPENSSL_NO_EC2M
-        ECerr(0, EC_R_GF2M_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_EC, EC_R_GF2M_NOT_SUPPORTED);
         goto err;
 #else
         /* create the EC_GROUP structure */
@@ -1626,7 +1615,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
         if (group != NULL) {
             field_bits = EC_GROUP_get_degree(group);
             if (field_bits &gt; OPENSSL_ECC_MAX_FIELD_BITS) {
-                ECerr(0, EC_R_FIELD_TOO_LARGE);
+                ERR_raise(ERR_LIB_EC, EC_R_FIELD_TOO_LARGE);
                 goto err;
             }
         }
@@ -1634,7 +1623,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
     }
 
     if (group == NULL) {
-        ECerr(0, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
@@ -1642,7 +1631,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
     ptmp = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_SEED);
     if (ptmp != NULL) {
         if (ptmp-&gt;data_type != OSSL_PARAM_OCTET_STRING) {
-            ECerr(0, EC_R_INVALID_SEED);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_SEED);
             goto err;
         }
         if (!EC_GROUP_set_seed(group, ptmp-&gt;data, ptmp-&gt;data_size))
@@ -1653,7 +1642,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
     ptmp = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_GENERATOR);
     if (ptmp == NULL
         || ptmp-&gt;data_type != OSSL_PARAM_OCTET_STRING) {
-        ECerr(0, EC_R_INVALID_GENERATOR);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_GENERATOR);
         goto err;
     }
     buf = (const unsigned char *)(ptmp-&gt;data);
@@ -1662,7 +1651,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
     EC_GROUP_set_point_conversion_form(group,
                                        (point_conversion_form_t)buf[0] &amp; ~0x01);
     if (!EC_POINT_oct2point(group, point, buf, ptmp-&gt;data_size, bnctx)) {
-        ECerr(0, EC_R_INVALID_GENERATOR);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_GENERATOR);
         goto err;
     }
 
@@ -1671,7 +1660,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
     if (!OSSL_PARAM_get_BN(ptmp, &amp;order)
         || (BN_is_negative(order) || BN_is_zero(order))
         || (BN_num_bits(order) &gt; (int)field_bits + 1)) { /* Hasse bound */
-        ECerr(0, EC_R_INVALID_GROUP_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_GROUP_ORDER);
         goto err;
     }
 
@@ -1680,20 +1669,20 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
     if (ptmp != NULL) {
         cofactor = BN_CTX_get(bnctx);
         if (cofactor == NULL || !OSSL_PARAM_get_BN(ptmp, &amp;cofactor)) {
-            ECerr(0, EC_R_INVALID_COFACTOR);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_COFACTOR);
             goto err;
         }
     }
 
     /* set the generator, order and cofactor (if present) */
     if (!EC_GROUP_set_generator(group, point, order, cofactor)) {
-        ECerr(0, EC_R_INVALID_GENERATOR);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_GENERATOR);
         goto err;
     }
 
     named_group = ec_group_explicit_to_named(group, libctx, propq, bnctx);
     if (named_group == NULL) {
-        ECerr(0, EC_R_INVALID_NAMED_GROUP_CONVERSION);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_NAMED_GROUP_CONVERSION);
         goto err;
     }
     if (named_group == group) {
@@ -1702,7 +1691,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
          * if it was specified
          */
         if (encoding_flag == OPENSSL_EC_NAMED_CURVE) {
-            ECerr(0, EC_R_INVALID_ENCODING);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
             goto err;
         }
         EC_GROUP_set_asn1_flag(group, OPENSSL_EC_EXPLICIT_CURVE);
diff --git a/crypto/ec/ec_mult.c b/crypto/ec/ec_mult.c
index aea2afd580..87b9eab604 100644
--- a/crypto/ec/ec_mult.c
+++ b/crypto/ec/ec_mult.c
@@ -57,7 +57,7 @@ static EC_PRE_COMP *ec_pre_comp_new(const EC_GROUP *group)
 
     ret = OPENSSL_zalloc(sizeof(*ret));
     if (ret == NULL) {
-        ECerr(EC_F_EC_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return ret;
     }
 
@@ -68,7 +68,7 @@ static EC_PRE_COMP *ec_pre_comp_new(const EC_GROUP *group)
 
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        ECerr(EC_F_EC_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -159,11 +159,11 @@ int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
         return EC_POINT_set_to_infinity(group, r);
 
     if (BN_is_zero(group-&gt;order)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_UNKNOWN_ORDER);
         return 0;
     }
     if (BN_is_zero(group-&gt;cofactor)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_COFACTOR);
+        ERR_raise(ERR_LIB_EC, EC_R_UNKNOWN_COFACTOR);
         return 0;
     }
 
@@ -171,18 +171,18 @@ int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
 
     if (((p = EC_POINT_new(group)) == NULL)
         || ((s = EC_POINT_new(group)) == NULL)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (point == NULL) {
         if (!EC_POINT_copy(p, group-&gt;generator)) {
-            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
     } else {
         if (!EC_POINT_copy(p, point)) {
-            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
     }
@@ -195,12 +195,12 @@ int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
     lambda = BN_CTX_get(ctx);
     k = BN_CTX_get(ctx);
     if (k == NULL) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (!BN_mul(cardinality, group-&gt;order, group-&gt;cofactor, ctx)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
@@ -214,12 +214,12 @@ int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
     group_top = bn_get_top(cardinality);
     if ((bn_wexpand(k, group_top + 2) == NULL)
         || (bn_wexpand(lambda, group_top + 2) == NULL)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
     if (!BN_copy(k, scalar)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
@@ -231,18 +231,18 @@ int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
          * constant-timeness
          */
         if (!BN_nnmod(k, k, cardinality, ctx)) {
-            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
     }
 
     if (!BN_add(lambda, k, cardinality)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     BN_set_flags(lambda, BN_FLG_CONSTTIME);
     if (!BN_add(k, lambda, cardinality)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     /*
@@ -262,20 +262,20 @@ int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
         || (bn_wexpand(p-&gt;X, group_top) == NULL)
         || (bn_wexpand(p-&gt;Y, group_top) == NULL)
         || (bn_wexpand(p-&gt;Z, group_top) == NULL)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
     /* ensure input point is in affine coords for ladder step efficiency */
     if (!p-&gt;Z_is_one &amp;&amp; (group-&gt;meth-&gt;make_affine == NULL
                          || !group-&gt;meth-&gt;make_affine(group, p, ctx))) {
-            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
     }
 
     /* Initialize the Montgomery ladder */
     if (!ec_point_ladder_pre(group, r, s, p, ctx)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_PRE_FAILURE);
+        ERR_raise(ERR_LIB_EC, EC_R_LADDER_PRE_FAILURE);
         goto err;
     }
 
@@ -355,7 +355,7 @@ int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
 
         /* Perform a single step of the Montgomery ladder */
         if (!ec_point_ladder_step(group, r, s, p, ctx)) {
-            ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_STEP_FAILURE);
+            ERR_raise(ERR_LIB_EC, EC_R_LADDER_STEP_FAILURE);
             goto err;
         }
         /*
@@ -370,7 +370,7 @@ int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
 
     /* Finalize ladder (and recover full point coordinates) */
     if (!ec_point_ladder_post(group, r, s, p, ctx)) {
-        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_POST_FAILURE);
+        ERR_raise(ERR_LIB_EC, EC_R_LADDER_POST_FAILURE);
         goto err;
     }
 
@@ -467,7 +467,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
     if (scalar != NULL) {
         generator = EC_GROUP_get0_generator(group);
         if (generator == NULL) {
-            ECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);
+            ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);
             goto err;
         }
 
@@ -495,7 +495,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
 
             /* check that pre_comp looks sane */
             if (pre_comp-&gt;num != (pre_comp-&gt;numblocks * pre_points_per_block)) {
-                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
         } else {
@@ -520,7 +520,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
         wNAF[0] = NULL;         /* preliminary pivot */
 
     if (wsize == NULL || wNAF_len == NULL || wNAF == NULL || val_sub == NULL) {
-        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -550,7 +550,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
 
         if (pre_comp == NULL) {
             if (num_scalar != 1) {
-                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
             /* we have already generated a wNAF for 'scalar' */
@@ -559,7 +559,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
             size_t tmp_len = 0;
 
             if (num_scalar != 0) {
-                ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
 
@@ -602,7 +602,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
                      */
                     numblocks = (tmp_len + blocksize - 1) / blocksize;
                     if (numblocks &gt; pre_comp-&gt;numblocks) {
-                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
+                        ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
                         OPENSSL_free(tmp_wNAF);
                         goto err;
                     }
@@ -617,7 +617,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
                     if (i &lt; totalnum - 1) {
                         wNAF_len[i] = blocksize;
                         if (tmp_len &lt; blocksize) {
-                            ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
+                            ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
                             OPENSSL_free(tmp_wNAF);
                             goto err;
                         }
@@ -632,7 +632,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
                     wNAF[i + 1] = NULL;
                     wNAF[i] = OPENSSL_malloc(wNAF_len[i]);
                     if (wNAF[i] == NULL) {
-                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);
+                        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
                         OPENSSL_free(tmp_wNAF);
                         goto err;
                     }
@@ -641,7 +641,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
                         max_len = wNAF_len[i];
 
                     if (*tmp_points == NULL) {
-                        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
+                        ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
                         OPENSSL_free(tmp_wNAF);
                         goto err;
                     }
@@ -661,7 +661,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
      */
     val = OPENSSL_malloc((num_val + 1) * sizeof(val[0]));
     if (val == NULL) {
-        ECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     val[num_val] = NULL;        /* pivot element */
@@ -678,7 +678,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
         }
     }
     if (!(v == val + num_val)) {
-        ECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
         goto err;
     }
 
@@ -758,7 +758,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
                          * group.
                          */
                         if (!ec_point_blind_coordinates(group, r, ctx)) {
-                            ECerr(EC_F_EC_WNAF_MUL, EC_R_POINT_COORDINATES_BLIND_FAILURE);
+                            ERR_raise(ERR_LIB_EC, EC_R_POINT_COORDINATES_BLIND_FAILURE);
                             goto err;
                         }
 
@@ -846,7 +846,7 @@ int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
 
     generator = EC_GROUP_get0_generator(group);
     if (generator == NULL) {
-        ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, EC_R_UNDEFINED_GENERATOR);
+        ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);
         goto err;
     }
 
@@ -863,7 +863,7 @@ int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
     if (order == NULL)
         goto err;
     if (BN_is_zero(order)) {
-        ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, EC_R_UNKNOWN_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_UNKNOWN_ORDER);
         goto err;
     }
 
@@ -891,7 +891,7 @@ int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
 
     points = OPENSSL_malloc(sizeof(*points) * (num + 1));
     if (points == NULL) {
-        ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -899,14 +899,14 @@ int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
     var[num] = NULL;            /* pivot */
     for (i = 0; i &lt; num; i++) {
         if ((var[i] = EC_POINT_new(group)) == NULL) {
-            ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
 
     if ((tmp_point = EC_POINT_new(group)) == NULL
         || (base = EC_POINT_new(group)) == NULL) {
-        ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -938,7 +938,7 @@ int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
             size_t k;
 
             if (blocksize &lt;= 2) {
-                ECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
 
diff --git a/crypto/ec/ec_oct.c b/crypto/ec/ec_oct.c
index 1b8ef49d3f..0dbe299c41 100644
--- a/crypto/ec/ec_oct.c
+++ b/crypto/ec/ec_oct.c
@@ -26,13 +26,11 @@ int EC_POINT_set_compressed_coordinates(const EC_GROUP *group, EC_POINT *point,
 {
     if (group-&gt;meth-&gt;point_set_compressed_coordinates == NULL
         &amp;&amp; !(group-&gt;meth-&gt;flags &amp; EC_FLAGS_DEFAULT_OCT)) {
-        ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES,
-              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(point, group)) {
-        ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES,
-              EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     if (group-&gt;meth-&gt;flags &amp; EC_FLAGS_DEFAULT_OCT) {
@@ -42,8 +40,7 @@ int EC_POINT_set_compressed_coordinates(const EC_GROUP *group, EC_POINT *point,
         else
 #ifdef OPENSSL_NO_EC2M
         {
-            ECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES,
-                  EC_R_GF2M_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_EC, EC_R_GF2M_NOT_SUPPORTED);
             return 0;
         }
 #else
@@ -79,11 +76,11 @@ size_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *point,
 {
     if (group-&gt;meth-&gt;point2oct == 0
         &amp;&amp; !(group-&gt;meth-&gt;flags &amp; EC_FLAGS_DEFAULT_OCT)) {
-        ECerr(EC_F_EC_POINT_POINT2OCT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(point, group)) {
-        ECerr(EC_F_EC_POINT_POINT2OCT, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     if (group-&gt;meth-&gt;flags &amp; EC_FLAGS_DEFAULT_OCT) {
@@ -92,7 +89,7 @@ size_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *point,
         else
 #ifdef OPENSSL_NO_EC2M
         {
-            ECerr(EC_F_EC_POINT_POINT2OCT, EC_R_GF2M_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_EC, EC_R_GF2M_NOT_SUPPORTED);
             return 0;
         }
 #else
@@ -109,11 +106,11 @@ int EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *point,
 {
     if (group-&gt;meth-&gt;oct2point == 0
         &amp;&amp; !(group-&gt;meth-&gt;flags &amp; EC_FLAGS_DEFAULT_OCT)) {
-        ECerr(EC_F_EC_POINT_OCT2POINT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_EC, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         return 0;
     }
     if (!ec_point_is_compat(point, group)) {
-        ECerr(EC_F_EC_POINT_OCT2POINT, EC_R_INCOMPATIBLE_OBJECTS);
+        ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
     if (group-&gt;meth-&gt;flags &amp; EC_FLAGS_DEFAULT_OCT) {
@@ -122,7 +119,7 @@ int EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *point,
         else
 #ifdef OPENSSL_NO_EC2M
         {
-            ECerr(EC_F_EC_POINT_OCT2POINT, EC_R_GF2M_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_EC, EC_R_GF2M_NOT_SUPPORTED);
             return 0;
         }
 #else
@@ -143,7 +140,7 @@ size_t EC_POINT_point2buf(const EC_GROUP *group, const EC_POINT *point,
     if (len == 0)
         return 0;
     if ((buf = OPENSSL_malloc(len)) == NULL) {
-        ECerr(EC_F_EC_POINT_POINT2BUF, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     len = EC_POINT_point2oct(group, point, form, buf, len, ctx);
diff --git a/crypto/ec/ec_pmeth.c b/crypto/ec/ec_pmeth.c
index 0758d9be4a..cd1632dc9a 100644
--- a/crypto/ec/ec_pmeth.c
+++ b/crypto/ec/ec_pmeth.c
@@ -49,7 +49,7 @@ static int pkey_ec_init(EVP_PKEY_CTX *ctx)
     EC_PKEY_CTX *dctx;
 
     if ((dctx = OPENSSL_zalloc(sizeof(*dctx))) == NULL) {
-        ECerr(EC_F_PKEY_EC_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -122,7 +122,7 @@ static int pkey_ec_sign(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
     }
 
     if (*siglen &lt; (size_t)sig_sz) {
-        ECerr(EC_F_PKEY_EC_SIGN, EC_R_BUFFER_TOO_SMALL);
+        ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
         return 0;
     }
 
@@ -163,7 +163,7 @@ static int pkey_ec_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen)
     EC_KEY *eckey;
     EC_PKEY_CTX *dctx = ctx-&gt;data;
     if (!ctx-&gt;pkey || !ctx-&gt;peerkey) {
-        ECerr(EC_F_PKEY_EC_DERIVE, EC_R_KEYS_NOT_SET);
+        ERR_raise(ERR_LIB_EC, EC_R_KEYS_NOT_SET);
         return 0;
     }
 
@@ -209,7 +209,7 @@ static int pkey_ec_kdf_derive(EVP_PKEY_CTX *ctx,
     if (!pkey_ec_derive(ctx, NULL, &amp;ktmplen))
         return 0;
     if ((ktmp = OPENSSL_malloc(ktmplen)) == NULL) {
-        ECerr(EC_F_PKEY_EC_KDF_DERIVE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     if (!pkey_ec_derive(ctx, ktmp, &amp;ktmplen))
@@ -235,7 +235,7 @@ static int pkey_ec_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
     case EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID:
         group = EC_GROUP_new_by_curve_name(p1);
         if (group == NULL) {
-            ECerr(EC_F_PKEY_EC_CTRL, EC_R_INVALID_CURVE);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_CURVE);
             return 0;
         }
         EC_GROUP_free(dctx-&gt;gen_group);
@@ -244,7 +244,7 @@ static int pkey_ec_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
 
     case EVP_PKEY_CTRL_EC_PARAM_ENC:
         if (!dctx-&gt;gen_group) {
-            ECerr(EC_F_PKEY_EC_CTRL, EC_R_NO_PARAMETERS_SET);
+            ERR_raise(ERR_LIB_EC, EC_R_NO_PARAMETERS_SET);
             return 0;
         }
         EC_GROUP_set_asn1_flag(dctx-&gt;gen_group, p1);
@@ -336,7 +336,7 @@ static int pkey_ec_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
             EVP_MD_type((const EVP_MD *)p2) != NID_sha3_384 &amp;&amp;
             EVP_MD_type((const EVP_MD *)p2) != NID_sha3_512 &amp;&amp;
             EVP_MD_type((const EVP_MD *)p2) != NID_sm3) {
-            ECerr(EC_F_PKEY_EC_CTRL, EC_R_INVALID_DIGEST_TYPE);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_DIGEST_TYPE);
             return 0;
         }
         dctx-&gt;md = p2;
@@ -370,7 +370,7 @@ static int pkey_ec_ctrl_str(EVP_PKEY_CTX *ctx,
         if (nid == NID_undef)
             nid = OBJ_ln2nid(value);
         if (nid == NID_undef) {
-            ECerr(EC_F_PKEY_EC_CTRL_STR, EC_R_INVALID_CURVE);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_CURVE);
             return 0;
         }
         return EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, nid);
@@ -386,7 +386,7 @@ static int pkey_ec_ctrl_str(EVP_PKEY_CTX *ctx,
     } else if (strcmp(type, &quot;ecdh_kdf_md&quot;) == 0) {
         const EVP_MD *md;
         if ((md = EVP_get_digestbyname(value)) == NULL) {
-            ECerr(EC_F_PKEY_EC_CTRL_STR, EC_R_INVALID_DIGEST);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_DIGEST);
             return 0;
         }
         return EVP_PKEY_CTX_set_ecdh_kdf_md(ctx, md);
@@ -406,7 +406,7 @@ static int pkey_ec_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     int ret;
 
     if (dctx-&gt;gen_group == NULL) {
-        ECerr(EC_F_PKEY_EC_PARAMGEN, EC_R_NO_PARAMETERS_SET);
+        ERR_raise(ERR_LIB_EC, EC_R_NO_PARAMETERS_SET);
         return 0;
     }
     ec = EC_KEY_new();
@@ -425,7 +425,7 @@ static int pkey_ec_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     int ret;
 
     if (ctx-&gt;pkey == NULL &amp;&amp; dctx-&gt;gen_group == NULL) {
-        ECerr(EC_F_PKEY_EC_KEYGEN, EC_R_NO_PARAMETERS_SET);
+        ERR_raise(ERR_LIB_EC, EC_R_NO_PARAMETERS_SET);
         return 0;
     }
     ec = EC_KEY_new();
diff --git a/crypto/ec/ec_print.c b/crypto/ec/ec_print.c
index 9c28fe3fac..4fb76fe74e 100644
--- a/crypto/ec/ec_print.c
+++ b/crypto/ec/ec_print.c
@@ -47,7 +47,7 @@ EC_POINT *EC_POINT_bn2point(const EC_GROUP *group,
     if ((buf_len = BN_num_bytes(bn)) == 0)
         buf_len = 1;
     if ((buf = OPENSSL_malloc(buf_len)) == NULL) {
-        ECerr(EC_F_EC_POINT_BN2POINT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/ec/ecdh_ossl.c b/crypto/ec/ecdh_ossl.c
index 4217417806..a42fb55ddc 100644
--- a/crypto/ec/ecdh_ossl.c
+++ b/crypto/ec/ecdh_ossl.c
@@ -29,7 +29,7 @@ int ossl_ecdh_compute_key(unsigned char **psec, size_t *pseclen,
                           const EC_POINT *pub_key, const EC_KEY *ecdh)
 {
     if (ecdh-&gt;group-&gt;meth-&gt;ecdh_compute_key == NULL) {
-        ECerr(EC_F_OSSL_ECDH_COMPUTE_KEY, EC_R_CURVE_DOES_NOT_SUPPORT_ECDH);
+        ERR_raise(ERR_LIB_EC, EC_R_CURVE_DOES_NOT_SUPPORT_ECDH);
         return 0;
     }
 
@@ -63,13 +63,13 @@ int ecdh_simple_compute_key(unsigned char **pout, size_t *poutlen,
     BN_CTX_start(ctx);
     x = BN_CTX_get(ctx);
     if (x == NULL) {
-        ECerr(EC_F_ECDH_SIMPLE_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     priv_key = EC_KEY_get0_private_key(ecdh);
     if (priv_key == NULL) {
-        ECerr(EC_F_ECDH_SIMPLE_COMPUTE_KEY, EC_R_MISSING_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PRIVATE_KEY);
         goto err;
     }
 
@@ -82,19 +82,19 @@ int ecdh_simple_compute_key(unsigned char **pout, size_t *poutlen,
     if (EC_KEY_get_flags(ecdh) &amp; EC_FLAG_COFACTOR_ECDH) {
         if (!EC_GROUP_get_cofactor(group, x, NULL) ||
             !BN_mul(x, x, priv_key, ctx)) {
-            ECerr(EC_F_ECDH_SIMPLE_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         priv_key = x;
     }
 
     if ((tmp = EC_POINT_new(group)) == NULL) {
-        ECerr(EC_F_ECDH_SIMPLE_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (!EC_POINT_mul(group, tmp, NULL, pub_key, priv_key, ctx)) {
-        ECerr(EC_F_ECDH_SIMPLE_COMPUTE_KEY, EC_R_POINT_ARITHMETIC_FAILURE);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_ARITHMETIC_FAILURE);
         goto err;
     }
 
@@ -104,7 +104,7 @@ int ecdh_simple_compute_key(unsigned char **pout, size_t *poutlen,
      * Step(3a) : Get x-coordinate of point x = tmp.x
      */
     if (!EC_POINT_get_affine_coordinates(group, tmp, x, NULL, ctx)) {
-        ECerr(EC_F_ECDH_SIMPLE_COMPUTE_KEY, EC_R_POINT_ARITHMETIC_FAILURE);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_ARITHMETIC_FAILURE);
         goto err;
     }
 
@@ -115,17 +115,17 @@ int ecdh_simple_compute_key(unsigned char **pout, size_t *poutlen,
     buflen = (EC_GROUP_get_degree(group) + 7) / 8;
     len = BN_num_bytes(x);
     if (len &gt; buflen) {
-        ECerr(EC_F_ECDH_SIMPLE_COMPUTE_KEY, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
         goto err;
     }
     if ((buf = OPENSSL_malloc(buflen)) == NULL) {
-        ECerr(EC_F_ECDH_SIMPLE_COMPUTE_KEY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     memset(buf, 0, buflen - len);
     if (len != (size_t)BN_bn2bin(x, buf + buflen - len)) {
-        ECerr(EC_F_ECDH_SIMPLE_COMPUTE_KEY, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
diff --git a/crypto/ec/ecdsa_ossl.c b/crypto/ec/ecdsa_ossl.c
index d37b67c73b..c697199cce 100644
--- a/crypto/ec/ecdsa_ossl.c
+++ b/crypto/ec/ecdsa_ossl.c
@@ -24,7 +24,7 @@ int ossl_ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp,
                           BIGNUM **rp)
 {
     if (eckey-&gt;group-&gt;meth-&gt;ecdsa_sign_setup == NULL) {
-        ECerr(EC_F_OSSL_ECDSA_SIGN_SETUP, EC_R_CURVE_DOES_NOT_SUPPORT_ECDSA);
+        ERR_raise(ERR_LIB_EC, EC_R_CURVE_DOES_NOT_SUPPORT_ECDSA);
         return 0;
     }
 
@@ -36,7 +36,7 @@ ECDSA_SIG *ossl_ecdsa_sign_sig(const unsigned char *dgst, int dgst_len,
                                EC_KEY *eckey)
 {
     if (eckey-&gt;group-&gt;meth-&gt;ecdsa_sign_sig == NULL) {
-        ECerr(EC_F_OSSL_ECDSA_SIGN_SIG, EC_R_CURVE_DOES_NOT_SUPPORT_ECDSA);
+        ERR_raise(ERR_LIB_EC, EC_R_CURVE_DOES_NOT_SUPPORT_ECDSA);
         return NULL;
     }
 
@@ -48,7 +48,7 @@ int ossl_ecdsa_verify_sig(const unsigned char *dgst, int dgst_len,
                           const ECDSA_SIG *sig, EC_KEY *eckey)
 {
     if (eckey-&gt;group-&gt;meth-&gt;ecdsa_verify_sig == NULL) {
-        ECerr(EC_F_OSSL_ECDSA_VERIFY_SIG, EC_R_CURVE_DOES_NOT_SUPPORT_ECDSA);
+        ERR_raise(ERR_LIB_EC, EC_R_CURVE_DOES_NOT_SUPPORT_ECDSA);
         return 0;
     }
 
@@ -85,22 +85,22 @@ static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,
     const BIGNUM *priv_key;
 
     if (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL) {
-        ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if ((priv_key = EC_KEY_get0_private_key(eckey)) == NULL) {
-        ECerr(EC_F_ECDSA_SIGN_SETUP, EC_R_MISSING_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PRIVATE_KEY);
         return 0;
     }
 
     if (!EC_KEY_can_sign(eckey)) {
-        ECerr(EC_F_ECDSA_SIGN_SETUP, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);
+        ERR_raise(ERR_LIB_EC, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);
         return 0;
     }
 
     if ((ctx = ctx_in) == NULL) {
         if ((ctx = BN_CTX_new_ex(eckey-&gt;libctx)) == NULL) {
-            ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     }
@@ -109,11 +109,11 @@ static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,
     r = BN_new();               /* this value is later returned in *rp */
     X = BN_new();
     if (k == NULL || r == NULL || X == NULL) {
-        ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if ((tmp_point = EC_POINT_new(group)) == NULL) {
-        ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
     order = EC_GROUP_get0_order(group);
@@ -131,14 +131,12 @@ static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,
             if (dgst != NULL) {
                 if (!BN_generate_dsa_nonce(k, order, priv_key,
                                            dgst, dlen, ctx)) {
-                    ECerr(EC_F_ECDSA_SIGN_SETUP,
-                          EC_R_RANDOM_NUMBER_GENERATION_FAILED);
+                    ERR_raise(ERR_LIB_EC, EC_R_RANDOM_NUMBER_GENERATION_FAILED);
                     goto err;
                 }
             } else {
                 if (!BN_priv_rand_range_ex(k, order, ctx)) {
-                    ECerr(EC_F_ECDSA_SIGN_SETUP,
-                          EC_R_RANDOM_NUMBER_GENERATION_FAILED);
+                    ERR_raise(ERR_LIB_EC, EC_R_RANDOM_NUMBER_GENERATION_FAILED);
                     goto err;
                 }
             }
@@ -146,24 +144,24 @@ static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,
 
         /* compute r the x-coordinate of generator * k */
         if (!EC_POINT_mul(group, tmp_point, k, NULL, NULL, ctx)) {
-            ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
 
         if (!EC_POINT_get_affine_coordinates(group, tmp_point, X, NULL, ctx)) {
-            ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
         }
 
         if (!BN_nnmod(r, X, order, ctx)) {
-            ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
     } while (BN_is_zero(r));
 
     /* compute the inverse of k */
     if (!ec_group_do_inverse_ord(group, k, k, ctx)) {
-        ECerr(EC_F_ECDSA_SIGN_SETUP, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
@@ -208,35 +206,35 @@ ECDSA_SIG *ecdsa_simple_sign_sig(const unsigned char *dgst, int dgst_len,
     priv_key = EC_KEY_get0_private_key(eckey);
 
     if (group == NULL) {
-        ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if (priv_key == NULL) {
-        ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, EC_R_MISSING_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PRIVATE_KEY);
         return NULL;
     }
 
     if (!EC_KEY_can_sign(eckey)) {
-        ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);
+        ERR_raise(ERR_LIB_EC, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);
         return NULL;
     }
 
     ret = ECDSA_SIG_new();
     if (ret == NULL) {
-        ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;r = BN_new();
     ret-&gt;s = BN_new();
     if (ret-&gt;r == NULL || ret-&gt;s == NULL) {
-        ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     s = ret-&gt;s;
 
     if ((ctx = BN_CTX_new_ex(eckey-&gt;libctx)) == NULL
         || (m = BN_new()) == NULL) {
-        ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -248,25 +246,25 @@ ECDSA_SIG *ecdsa_simple_sign_sig(const unsigned char *dgst, int dgst_len,
     if (8 * dgst_len &gt; i)
         dgst_len = (i + 7) / 8;
     if (!BN_bin2bn(dgst, dgst_len, m)) {
-        ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     /* If still too long, truncate remaining bits with a shift */
     if ((8 * dgst_len &gt; i) &amp;&amp; !BN_rshift(m, m, 8 - (i &amp; 0x7))) {
-        ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     do {
         if (in_kinv == NULL || in_r == NULL) {
             if (!ecdsa_sign_setup(eckey, ctx, &amp;kinv, &amp;ret-&gt;r, dgst, dgst_len)) {
-                ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_ECDSA_LIB);
+                ERR_raise(ERR_LIB_EC, ERR_R_ECDSA_LIB);
                 goto err;
             }
             ckinv = kinv;
         } else {
             ckinv = in_kinv;
             if (BN_copy(ret-&gt;r, in_r) == NULL) {
-                ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
         }
@@ -280,11 +278,11 @@ ECDSA_SIG *ecdsa_simple_sign_sig(const unsigned char *dgst, int dgst_len,
          */
         if (!bn_to_mont_fixed_top(s, ret-&gt;r, group-&gt;mont_data, ctx)
             || !bn_mul_mont_fixed_top(s, s, priv_key, group-&gt;mont_data, ctx)) {
-            ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
         if (!bn_mod_add_fixed_top(s, s, m, order)) {
-            ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
         /*
@@ -293,7 +291,7 @@ ECDSA_SIG *ecdsa_simple_sign_sig(const unsigned char *dgst, int dgst_len,
          */
         if (!bn_to_mont_fixed_top(s, s, group-&gt;mont_data, ctx)
             || !BN_mod_mul_montgomery(s, s, ckinv, group-&gt;mont_data, ctx)) {
-            ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
 
@@ -303,7 +301,7 @@ ECDSA_SIG *ecdsa_simple_sign_sig(const unsigned char *dgst, int dgst_len,
              * generate new kinv and r values
              */
             if (in_kinv != NULL &amp;&amp; in_r != NULL) {
-                ECerr(EC_F_ECDSA_SIMPLE_SIGN_SIG, EC_R_NEED_NEW_SETUP_VALUES);
+                ERR_raise(ERR_LIB_EC, EC_R_NEED_NEW_SETUP_VALUES);
                 goto err;
             }
         } else {
@@ -369,18 +367,18 @@ int ecdsa_simple_verify_sig(const unsigned char *dgst, int dgst_len,
     /* check input values */
     if (eckey == NULL || (group = EC_KEY_get0_group(eckey)) == NULL ||
         (pub_key = EC_KEY_get0_public_key(eckey)) == NULL || sig == NULL) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, EC_R_MISSING_PARAMETERS);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PARAMETERS);
         return -1;
     }
 
     if (!EC_KEY_can_sign(eckey)) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);
+        ERR_raise(ERR_LIB_EC, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);
         return -1;
     }
 
     ctx = BN_CTX_new_ex(eckey-&gt;libctx);
     if (ctx == NULL) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return -1;
     }
     BN_CTX_start(ctx);
@@ -389,26 +387,26 @@ int ecdsa_simple_verify_sig(const unsigned char *dgst, int dgst_len,
     m = BN_CTX_get(ctx);
     X = BN_CTX_get(ctx);
     if (X == NULL) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
     order = EC_GROUP_get0_order(group);
     if (order == NULL) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
     if (BN_is_zero(sig-&gt;r) || BN_is_negative(sig-&gt;r) ||
         BN_ucmp(sig-&gt;r, order) &gt;= 0 || BN_is_zero(sig-&gt;s) ||
         BN_is_negative(sig-&gt;s) || BN_ucmp(sig-&gt;s, order) &gt;= 0) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, EC_R_BAD_SIGNATURE);
+        ERR_raise(ERR_LIB_EC, EC_R_BAD_SIGNATURE);
         ret = 0;                /* signature is invalid */
         goto err;
     }
     /* calculate tmp1 = inv(S) mod order */
     if (!ec_group_do_inverse_ord(group, u2, sig-&gt;s, ctx)) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     /* digest -&gt; m */
@@ -419,41 +417,41 @@ int ecdsa_simple_verify_sig(const unsigned char *dgst, int dgst_len,
     if (8 * dgst_len &gt; i)
         dgst_len = (i + 7) / 8;
     if (!BN_bin2bn(dgst, dgst_len, m)) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     /* If still too long truncate remaining bits with a shift */
     if ((8 * dgst_len &gt; i) &amp;&amp; !BN_rshift(m, m, 8 - (i &amp; 0x7))) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     /* u1 = m * tmp mod order */
     if (!BN_mod_mul(u1, m, u2, order, ctx)) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     /* u2 = r * w mod q */
     if (!BN_mod_mul(u2, sig-&gt;r, u2, order, ctx)) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
     if ((point = EC_POINT_new(group)) == NULL) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (!EC_POINT_mul(group, point, u1, pub_key, u2, ctx)) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
     if (!EC_POINT_get_affine_coordinates(group, point, X, NULL, ctx)) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
 
     if (!BN_nnmod(u1, X, order, ctx)) {
-        ECerr(EC_F_ECDSA_SIMPLE_VERIFY_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     /*  if the signature is correct u1 is equal to sig-&gt;r */
diff --git a/crypto/ec/ecdsa_sign.c b/crypto/ec/ecdsa_sign.c
index 6e56ef7ed5..0c0748c84f 100644
--- a/crypto/ec/ecdsa_sign.c
+++ b/crypto/ec/ecdsa_sign.c
@@ -28,7 +28,7 @@ ECDSA_SIG *ECDSA_do_sign_ex(const unsigned char *dgst, int dlen,
 {
     if (eckey-&gt;meth-&gt;sign_sig != NULL)
         return eckey-&gt;meth-&gt;sign_sig(dgst, dlen, kinv, rp, eckey);
-    ECerr(EC_F_ECDSA_DO_SIGN_EX, EC_R_OPERATION_NOT_SUPPORTED);
+    ERR_raise(ERR_LIB_EC, EC_R_OPERATION_NOT_SUPPORTED);
     return NULL;
 }
 
@@ -44,7 +44,7 @@ int ECDSA_sign_ex(int type, const unsigned char *dgst, int dlen,
 {
     if (eckey-&gt;meth-&gt;sign != NULL)
         return eckey-&gt;meth-&gt;sign(type, dgst, dlen, sig, siglen, kinv, r, eckey);
-    ECerr(EC_F_ECDSA_SIGN_EX, EC_R_OPERATION_NOT_SUPPORTED);
+    ERR_raise(ERR_LIB_EC, EC_R_OPERATION_NOT_SUPPORTED);
     return 0;
 }
 
@@ -53,6 +53,6 @@ int ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp,
 {
     if (eckey-&gt;meth-&gt;sign_setup != NULL)
         return eckey-&gt;meth-&gt;sign_setup(eckey, ctx_in, kinvp, rp);
-    ECerr(EC_F_ECDSA_SIGN_SETUP, EC_R_OPERATION_NOT_SUPPORTED);
+    ERR_raise(ERR_LIB_EC, EC_R_OPERATION_NOT_SUPPORTED);
     return 0;
 }
diff --git a/crypto/ec/ecdsa_vrf.c b/crypto/ec/ecdsa_vrf.c
index 5b90fbfb92..c148ecdb7c 100644
--- a/crypto/ec/ecdsa_vrf.c
+++ b/crypto/ec/ecdsa_vrf.c
@@ -28,7 +28,7 @@ int ECDSA_do_verify(const unsigned char *dgst, int dgst_len,
 {
     if (eckey-&gt;meth-&gt;verify_sig != NULL)
         return eckey-&gt;meth-&gt;verify_sig(dgst, dgst_len, sig, eckey);
-    ECerr(EC_F_ECDSA_DO_VERIFY, EC_R_OPERATION_NOT_SUPPORTED);
+    ERR_raise(ERR_LIB_EC, EC_R_OPERATION_NOT_SUPPORTED);
     return -1;
 }
 
@@ -44,6 +44,6 @@ int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,
     if (eckey-&gt;meth-&gt;verify != NULL)
         return eckey-&gt;meth-&gt;verify(type, dgst, dgst_len, sigbuf, sig_len,
                                    eckey);
-    ECerr(EC_F_ECDSA_VERIFY, EC_R_OPERATION_NOT_SUPPORTED);
+    ERR_raise(ERR_LIB_EC, EC_R_OPERATION_NOT_SUPPORTED);
     return -1;
 }
diff --git a/crypto/ec/eck_prn.c b/crypto/ec/eck_prn.c
index 894219fba6..7b892ae403 100644
--- a/crypto/ec/eck_prn.c
+++ b/crypto/ec/eck_prn.c
@@ -21,7 +21,7 @@ int ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        ECerr(EC_F_ECPKPARAMETERS_PRINT_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -36,7 +36,7 @@ int EC_KEY_print_fp(FILE *fp, const EC_KEY *x, int off)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        ECerr(EC_F_EC_KEY_PRINT_FP, ERR_R_BIO_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BIO_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -51,7 +51,7 @@ int ECParameters_print_fp(FILE *fp, const EC_KEY *x)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        ECerr(EC_F_ECPARAMETERS_PRINT_FP, ERR_R_BIO_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BIO_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -211,7 +211,7 @@ int ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off)
     ret = 1;
  err:
     if (!ret)
-        ECerr(EC_F_ECPKPARAMETERS_PRINT, reason);
+        ERR_raise(ERR_LIB_EC, reason);
     BN_free(p);
     BN_free(a);
     BN_free(b);
diff --git a/crypto/ec/ecp_mont.c b/crypto/ec/ecp_mont.c
index f4bcbd2793..def39368e4 100644
--- a/crypto/ec/ecp_mont.c
+++ b/crypto/ec/ecp_mont.c
@@ -162,7 +162,7 @@ int ec_GFp_mont_group_set_curve(EC_GROUP *group, const BIGNUM *p,
     if (mont == NULL)
         goto err;
     if (!BN_MONT_CTX_set(mont, p, ctx)) {
-        ECerr(EC_F_EC_GFP_MONT_GROUP_SET_CURVE, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     one = BN_new();
@@ -196,7 +196,7 @@ int ec_GFp_mont_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
                           const BIGNUM *b, BN_CTX *ctx)
 {
     if (group-&gt;field_data1 == NULL) {
-        ECerr(EC_F_EC_GFP_MONT_FIELD_MUL, EC_R_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EC, EC_R_NOT_INITIALIZED);
         return 0;
     }
 
@@ -207,7 +207,7 @@ int ec_GFp_mont_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
                           BN_CTX *ctx)
 {
     if (group-&gt;field_data1 == NULL) {
-        ECerr(EC_F_EC_GFP_MONT_FIELD_SQR, EC_R_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EC, EC_R_NOT_INITIALIZED);
         return 0;
     }
 
@@ -251,7 +251,7 @@ int ec_GFp_mont_field_inv(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
 
     /* throw an error on zero */
     if (BN_is_zero(r)) {
-        ECerr(EC_F_EC_GFP_MONT_FIELD_INV, EC_R_CANNOT_INVERT);
+        ERR_raise(ERR_LIB_EC, EC_R_CANNOT_INVERT);
         goto err;
     }
 
@@ -267,7 +267,7 @@ int ec_GFp_mont_field_encode(const EC_GROUP *group, BIGNUM *r,
                              const BIGNUM *a, BN_CTX *ctx)
 {
     if (group-&gt;field_data1 == NULL) {
-        ECerr(EC_F_EC_GFP_MONT_FIELD_ENCODE, EC_R_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EC, EC_R_NOT_INITIALIZED);
         return 0;
     }
 
@@ -278,7 +278,7 @@ int ec_GFp_mont_field_decode(const EC_GROUP *group, BIGNUM *r,
                              const BIGNUM *a, BN_CTX *ctx)
 {
     if (group-&gt;field_data1 == NULL) {
-        ECerr(EC_F_EC_GFP_MONT_FIELD_DECODE, EC_R_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EC, EC_R_NOT_INITIALIZED);
         return 0;
     }
 
@@ -289,7 +289,7 @@ int ec_GFp_mont_field_set_to_one(const EC_GROUP *group, BIGNUM *r,
                                  BN_CTX *ctx)
 {
     if (group-&gt;field_data2 == NULL) {
-        ECerr(EC_F_EC_GFP_MONT_FIELD_SET_TO_ONE, EC_R_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EC, EC_R_NOT_INITIALIZED);
         return 0;
     }
 
diff --git a/crypto/ec/ecp_nist.c b/crypto/ec/ecp_nist.c
index fe5a7223d9..2809043dac 100644
--- a/crypto/ec/ecp_nist.c
+++ b/crypto/ec/ecp_nist.c
@@ -112,7 +112,7 @@ int ec_GFp_nist_group_set_curve(EC_GROUP *group, const BIGNUM *p,
     else if (BN_ucmp(BN_get0_nist_prime_521(), p) == 0)
         group-&gt;field_mod_func = BN_nist_mod_521;
     else {
-        ECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_NIST_PRIME);
+        ERR_raise(ERR_LIB_EC, EC_R_NOT_A_NIST_PRIME);
         goto err;
     }
 
@@ -131,7 +131,7 @@ int ec_GFp_nist_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
     BN_CTX *ctx_new = NULL;
 
     if (!group || !r || !a || !b) {
-        ECerr(EC_F_EC_GFP_NIST_FIELD_MUL, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         goto err;
     }
     if (!ctx)
@@ -156,7 +156,7 @@ int ec_GFp_nist_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
     BN_CTX *ctx_new = NULL;
 
     if (!group || !r || !a) {
-        ECerr(EC_F_EC_GFP_NIST_FIELD_SQR, EC_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, EC_R_PASSED_NULL_PARAMETER);
         goto err;
     }
     if (!ctx)
diff --git a/crypto/ec/ecp_nistp224.c b/crypto/ec/ecp_nistp224.c
index 2b665842c7..40a9582921 100644
--- a/crypto/ec/ecp_nistp224.c
+++ b/crypto/ec/ecp_nistp224.c
@@ -336,12 +336,12 @@ static int BN_to_felem(felem out, const BIGNUM *bn)
     int num_bytes;
 
     if (BN_is_negative(bn)) {
-        ECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_EC, EC_R_BIGNUM_OUT_OF_RANGE);
         return 0;
     }
     num_bytes = BN_bn2lebinpad(bn, b_out, sizeof(b_out));
     if (num_bytes &lt; 0) {
-        ECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_EC, EC_R_BIGNUM_OUT_OF_RANGE);
         return 0;
     }
     bin28_to_felem(out, b_out);
@@ -1241,7 +1241,7 @@ static NISTP224_PRE_COMP *nistp224_pre_comp_new(void)
     NISTP224_PRE_COMP *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (!ret) {
-        ECerr(EC_F_NISTP224_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return ret;
     }
 
@@ -1249,7 +1249,7 @@ static NISTP224_PRE_COMP *nistp224_pre_comp_new(void)
 
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        ECerr(EC_F_NISTP224_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -1319,8 +1319,7 @@ int ec_GFp_nistp224_group_set_curve(EC_GROUP *group, const BIGNUM *p,
     BN_bin2bn(nistp224_curve_params[1], sizeof(felem_bytearray), curve_a);
     BN_bin2bn(nistp224_curve_params[2], sizeof(felem_bytearray), curve_b);
     if ((BN_cmp(curve_p, p)) || (BN_cmp(curve_a, a)) || (BN_cmp(curve_b, b))) {
-        ECerr(EC_F_EC_GFP_NISTP224_GROUP_SET_CURVE,
-              EC_R_WRONG_CURVE_PARAMETERS);
+        ERR_raise(ERR_LIB_EC, EC_R_WRONG_CURVE_PARAMETERS);
         goto err;
     }
     group-&gt;field_mod_func = BN_nist_mod_224;
@@ -1346,8 +1345,7 @@ int ec_GFp_nistp224_point_get_affine_coordinates(const EC_GROUP *group,
     widefelem tmp;
 
     if (EC_POINT_is_at_infinity(group, point)) {
-        ECerr(EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES,
-              EC_R_POINT_AT_INFINITY);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_AT_INFINITY);
         return 0;
     }
     if ((!BN_to_felem(x_in, point-&gt;X)) || (!BN_to_felem(y_in, point-&gt;Y)) ||
@@ -1361,8 +1359,7 @@ int ec_GFp_nistp224_point_get_affine_coordinates(const EC_GROUP *group,
     felem_contract(x_out, x_in);
     if (x != NULL) {
         if (!felem_to_BN(x, x_out)) {
-            ECerr(EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES,
-                  ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             return 0;
         }
     }
@@ -1373,8 +1370,7 @@ int ec_GFp_nistp224_point_get_affine_coordinates(const EC_GROUP *group,
     felem_contract(y_out, y_in);
     if (y != NULL) {
         if (!felem_to_BN(y, y_out)) {
-            ECerr(EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES,
-                  ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             return 0;
         }
     }
@@ -1461,7 +1457,7 @@ int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
         if (!felem_to_BN(x, g_pre_comp[0][1][0]) ||
             !felem_to_BN(y, g_pre_comp[0][1][1]) ||
             !felem_to_BN(z, g_pre_comp[0][1][2])) {
-            ECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
         if (!ec_GFp_simple_set_Jprojective_coordinates_GFp(group, generator, x,
@@ -1493,7 +1489,7 @@ int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
                 OPENSSL_malloc(sizeof(felem) * (num_points * 17 + 1));
         if ((secrets == NULL) || (pre_comp == NULL)
             || (mixed &amp;&amp; (tmp_felems == NULL))) {
-            ECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
@@ -1520,7 +1516,7 @@ int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
                      * constant-timeness
                      */
                     if (!BN_nnmod(tmp_scalar, p_scalar, group-&gt;order, ctx)) {
-                        ECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_BN_LIB);
+                        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                         goto err;
                     }
                     num_bytes = BN_bn2lebinpad(tmp_scalar,
@@ -1530,7 +1526,7 @@ int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
                                                secrets[i], sizeof(secrets[i]));
                 }
                 if (num_bytes &lt; 0) {
-                    ECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_BN_LIB);
+                    ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                     goto err;
                 }
                 /* precompute multiples */
@@ -1572,7 +1568,7 @@ int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
              * constant-timeness
              */
             if (!BN_nnmod(tmp_scalar, scalar, group-&gt;order, ctx)) {
-                ECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_BN_LIB);
+                ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                 goto err;
             }
             num_bytes = BN_bn2lebinpad(tmp_scalar, g_secret, sizeof(g_secret));
@@ -1596,7 +1592,7 @@ int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
     felem_contract(z_in, z_out);
     if ((!felem_to_BN(x, x_in)) || (!felem_to_BN(y, y_in)) ||
         (!felem_to_BN(z, z_in))) {
-        ECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     ret = ec_GFp_simple_set_Jprojective_coordinates_GFp(group, r, x, y, z, ctx);
diff --git a/crypto/ec/ecp_nistp256.c b/crypto/ec/ecp_nistp256.c
index 8bf25e389e..f81481f0d3 100644
--- a/crypto/ec/ecp_nistp256.c
+++ b/crypto/ec/ecp_nistp256.c
@@ -156,12 +156,12 @@ static int BN_to_felem(felem out, const BIGNUM *bn)
     int num_bytes;
 
     if (BN_is_negative(bn)) {
-        ECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_EC, EC_R_BIGNUM_OUT_OF_RANGE);
         return 0;
     }
     num_bytes = BN_bn2lebinpad(bn, b_out, sizeof(b_out));
     if (num_bytes &lt; 0) {
-        ECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_EC, EC_R_BIGNUM_OUT_OF_RANGE);
         return 0;
     }
     bin32_to_felem(out, b_out);
@@ -1853,7 +1853,7 @@ static NISTP256_PRE_COMP *nistp256_pre_comp_new(void)
     NISTP256_PRE_COMP *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        ECerr(EC_F_NISTP256_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return ret;
     }
 
@@ -1861,7 +1861,7 @@ static NISTP256_PRE_COMP *nistp256_pre_comp_new(void)
 
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        ECerr(EC_F_NISTP256_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -1931,8 +1931,7 @@ int ec_GFp_nistp256_group_set_curve(EC_GROUP *group, const BIGNUM *p,
     BN_bin2bn(nistp256_curve_params[1], sizeof(felem_bytearray), curve_a);
     BN_bin2bn(nistp256_curve_params[2], sizeof(felem_bytearray), curve_b);
     if ((BN_cmp(curve_p, p)) || (BN_cmp(curve_a, a)) || (BN_cmp(curve_b, b))) {
-        ECerr(EC_F_EC_GFP_NISTP256_GROUP_SET_CURVE,
-              EC_R_WRONG_CURVE_PARAMETERS);
+        ERR_raise(ERR_LIB_EC, EC_R_WRONG_CURVE_PARAMETERS);
         goto err;
     }
     group-&gt;field_mod_func = BN_nist_mod_256;
@@ -1959,8 +1958,7 @@ int ec_GFp_nistp256_point_get_affine_coordinates(const EC_GROUP *group,
     longfelem tmp;
 
     if (EC_POINT_is_at_infinity(group, point)) {
-        ECerr(EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES,
-              EC_R_POINT_AT_INFINITY);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_AT_INFINITY);
         return 0;
     }
     if ((!BN_to_felem(x_in, point-&gt;X)) || (!BN_to_felem(y_in, point-&gt;Y)) ||
@@ -1974,8 +1972,7 @@ int ec_GFp_nistp256_point_get_affine_coordinates(const EC_GROUP *group,
     felem_contract(x_out, x_in);
     if (x != NULL) {
         if (!smallfelem_to_BN(x, x_out)) {
-            ECerr(EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES,
-                  ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             return 0;
         }
     }
@@ -1986,8 +1983,7 @@ int ec_GFp_nistp256_point_get_affine_coordinates(const EC_GROUP *group,
     felem_contract(y_out, y_in);
     if (y != NULL) {
         if (!smallfelem_to_BN(y, y_out)) {
-            ECerr(EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES,
-                  ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             return 0;
         }
     }
@@ -2075,7 +2071,7 @@ int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
         if (!smallfelem_to_BN(x, g_pre_comp[0][1][0]) ||
             !smallfelem_to_BN(y, g_pre_comp[0][1][1]) ||
             !smallfelem_to_BN(z, g_pre_comp[0][1][2])) {
-            ECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
         if (!ec_GFp_simple_set_Jprojective_coordinates_GFp(group, generator, x,
@@ -2106,7 +2102,7 @@ int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
               OPENSSL_malloc(sizeof(*tmp_smallfelems) * (num_points * 17 + 1));
         if ((secrets == NULL) || (pre_comp == NULL)
             || (mixed &amp;&amp; (tmp_smallfelems == NULL))) {
-            ECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
@@ -2138,7 +2134,7 @@ int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
                      * constant-timeness
                      */
                     if (!BN_nnmod(tmp_scalar, p_scalar, group-&gt;order, ctx)) {
-                        ECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_BN_LIB);
+                        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                         goto err;
                     }
                     num_bytes = BN_bn2lebinpad(tmp_scalar,
@@ -2148,7 +2144,7 @@ int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
                                                secrets[i], sizeof(secrets[i]));
                 }
                 if (num_bytes &lt; 0) {
-                    ECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_BN_LIB);
+                    ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                     goto err;
                 }
                 /* precompute multiples */
@@ -2192,7 +2188,7 @@ int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
              * constant-timeness
              */
             if (!BN_nnmod(tmp_scalar, scalar, group-&gt;order, ctx)) {
-                ECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_BN_LIB);
+                ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                 goto err;
             }
             num_bytes = BN_bn2lebinpad(tmp_scalar, g_secret, sizeof(g_secret));
@@ -2216,7 +2212,7 @@ int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
     felem_contract(z_in, z_out);
     if ((!smallfelem_to_BN(x, x_in)) || (!smallfelem_to_BN(y, y_in)) ||
         (!smallfelem_to_BN(z, z_in))) {
-        ECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     ret = ec_GFp_simple_set_Jprojective_coordinates_GFp(group, r, x, y, z, ctx);
diff --git a/crypto/ec/ecp_nistp521.c b/crypto/ec/ecp_nistp521.c
index 455885aa09..dc9312b957 100644
--- a/crypto/ec/ecp_nistp521.c
+++ b/crypto/ec/ecp_nistp521.c
@@ -180,12 +180,12 @@ static int BN_to_felem(felem out, const BIGNUM *bn)
     int num_bytes;
 
     if (BN_is_negative(bn)) {
-        ECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_EC, EC_R_BIGNUM_OUT_OF_RANGE);
         return 0;
     }
     num_bytes = BN_bn2lebinpad(bn, b_out, sizeof(b_out));
     if (num_bytes &lt; 0) {
-        ECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_EC, EC_R_BIGNUM_OUT_OF_RANGE);
         return 0;
     }
     bin66_to_felem(out, b_out);
@@ -1694,7 +1694,7 @@ static NISTP521_PRE_COMP *nistp521_pre_comp_new(void)
     NISTP521_PRE_COMP *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        ECerr(EC_F_NISTP521_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return ret;
     }
 
@@ -1702,7 +1702,7 @@ static NISTP521_PRE_COMP *nistp521_pre_comp_new(void)
 
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        ECerr(EC_F_NISTP521_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -1772,8 +1772,7 @@ int ec_GFp_nistp521_group_set_curve(EC_GROUP *group, const BIGNUM *p,
     BN_bin2bn(nistp521_curve_params[1], sizeof(felem_bytearray), curve_a);
     BN_bin2bn(nistp521_curve_params[2], sizeof(felem_bytearray), curve_b);
     if ((BN_cmp(curve_p, p)) || (BN_cmp(curve_a, a)) || (BN_cmp(curve_b, b))) {
-        ECerr(EC_F_EC_GFP_NISTP521_GROUP_SET_CURVE,
-              EC_R_WRONG_CURVE_PARAMETERS);
+        ERR_raise(ERR_LIB_EC, EC_R_WRONG_CURVE_PARAMETERS);
         goto err;
     }
     group-&gt;field_mod_func = BN_nist_mod_521;
@@ -1799,8 +1798,7 @@ int ec_GFp_nistp521_point_get_affine_coordinates(const EC_GROUP *group,
     largefelem tmp;
 
     if (EC_POINT_is_at_infinity(group, point)) {
-        ECerr(EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES,
-              EC_R_POINT_AT_INFINITY);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_AT_INFINITY);
         return 0;
     }
     if ((!BN_to_felem(x_in, point-&gt;X)) || (!BN_to_felem(y_in, point-&gt;Y)) ||
@@ -1814,8 +1812,7 @@ int ec_GFp_nistp521_point_get_affine_coordinates(const EC_GROUP *group,
     felem_contract(x_out, x_in);
     if (x != NULL) {
         if (!felem_to_BN(x, x_out)) {
-            ECerr(EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES,
-                  ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             return 0;
         }
     }
@@ -1826,8 +1823,7 @@ int ec_GFp_nistp521_point_get_affine_coordinates(const EC_GROUP *group,
     felem_contract(y_out, y_in);
     if (y != NULL) {
         if (!felem_to_BN(y, y_out)) {
-            ECerr(EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES,
-                  ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             return 0;
         }
     }
@@ -1915,7 +1911,7 @@ int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
         if (!felem_to_BN(x, g_pre_comp[1][0]) ||
             !felem_to_BN(y, g_pre_comp[1][1]) ||
             !felem_to_BN(z, g_pre_comp[1][2])) {
-            ECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
         if (!ec_GFp_simple_set_Jprojective_coordinates_GFp(group, generator, x,
@@ -1947,7 +1943,7 @@ int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
                 OPENSSL_malloc(sizeof(*tmp_felems) * (num_points * 17 + 1));
         if ((secrets == NULL) || (pre_comp == NULL)
             || (mixed &amp;&amp; (tmp_felems == NULL))) {
-            ECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
@@ -1977,7 +1973,7 @@ int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
                      * constant-timeness
                      */
                     if (!BN_nnmod(tmp_scalar, p_scalar, group-&gt;order, ctx)) {
-                        ECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_BN_LIB);
+                        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                         goto err;
                     }
                     num_bytes = BN_bn2lebinpad(tmp_scalar,
@@ -1987,7 +1983,7 @@ int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
                                                secrets[i], sizeof(secrets[i]));
                 }
                 if (num_bytes &lt; 0) {
-                    ECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_BN_LIB);
+                    ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                     goto err;
                 }
                 /* precompute multiples */
@@ -2029,7 +2025,7 @@ int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
              * constant-timeness
              */
             if (!BN_nnmod(tmp_scalar, scalar, group-&gt;order, ctx)) {
-                ECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_BN_LIB);
+                ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                 goto err;
             }
             num_bytes = BN_bn2lebinpad(tmp_scalar, g_secret, sizeof(g_secret));
@@ -2054,7 +2050,7 @@ int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
     felem_contract(z_in, z_out);
     if ((!felem_to_BN(x, x_in)) || (!felem_to_BN(y, y_in)) ||
         (!felem_to_BN(z, z_in))) {
-        ECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     ret = ec_GFp_simple_set_Jprojective_coordinates_GFp(group, r, x, y, z, ctx);
diff --git a/crypto/ec/ecp_nistz256.c b/crypto/ec/ecp_nistz256.c
index 0f1170dbad..64970d53bf 100644
--- a/crypto/ec/ecp_nistz256.c
+++ b/crypto/ec/ecp_nistz256.c
@@ -637,7 +637,7 @@ __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,
         || (p_str =
             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL
         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL) {
-        ECerr(EC_F_ECP_NISTZ256_WINDOWED_MUL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -654,7 +654,7 @@ __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,
             if ((mod = BN_CTX_get(ctx)) == NULL)
                 goto err;
             if (!BN_nnmod(mod, scalar[i], group-&gt;order, ctx)) {
-                ECerr(EC_F_ECP_NISTZ256_WINDOWED_MUL, ERR_R_BN_LIB);
+                ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                 goto err;
             }
             scalars[i] = mod;
@@ -682,8 +682,7 @@ __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,
         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]-&gt;X)
             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]-&gt;Y)
             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]-&gt;Z)) {
-            ECerr(EC_F_ECP_NISTZ256_WINDOWED_MUL,
-                  EC_R_COORDINATES_OUT_OF_RANGE);
+            ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);
             goto err;
         }
 
@@ -834,7 +833,7 @@ __owur static int ecp_nistz256_mult_precompute(EC_GROUP *group, BN_CTX *ctx)
     EC_pre_comp_free(group);
     generator = EC_GROUP_get0_generator(group);
     if (generator == NULL) {
-        ECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE, EC_R_UNDEFINED_GENERATOR);
+        ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);
         return 0;
     }
 
@@ -862,7 +861,7 @@ __owur static int ecp_nistz256_mult_precompute(EC_GROUP *group, BN_CTX *ctx)
         goto err;
 
     if (BN_is_zero(order)) {
-        ECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE, EC_R_UNKNOWN_ORDER);
+        ERR_raise(ERR_LIB_EC, EC_R_UNKNOWN_ORDER);
         goto err;
     }
 
@@ -870,7 +869,7 @@ __owur static int ecp_nistz256_mult_precompute(EC_GROUP *group, BN_CTX *ctx)
 
     if ((precomp_storage =
          OPENSSL_malloc(37 * 64 * sizeof(P256_POINT_AFFINE) + 64)) == NULL) {
-        ECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -902,8 +901,7 @@ __owur static int ecp_nistz256_mult_precompute(EC_GROUP *group, BN_CTX *ctx)
                 goto err;
             if (!ecp_nistz256_bignum_to_field_elem(temp.X, P-&gt;X) ||
                 !ecp_nistz256_bignum_to_field_elem(temp.Y, P-&gt;Y)) {
-                ECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE,
-                      EC_R_COORDINATES_OUT_OF_RANGE);
+                ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);
                 goto err;
             }
             ecp_nistz256_scatter_w7(preComputedTable[j], &amp;temp, k);
@@ -976,7 +974,7 @@ __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,
     BIGNUM *tmp_scalar;
 
     if ((num + 1) == 0 || (num + 1) &gt; OPENSSL_MALLOC_MAX_NELEMS(void *)) {
-        ECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -985,7 +983,7 @@ __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,
     if (scalar) {
         generator = EC_GROUP_get0_generator(group);
         if (generator == NULL) {
-            ECerr(EC_F_ECP_NISTZ256_POINTS_MUL, EC_R_UNDEFINED_GENERATOR);
+            ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);
             goto err;
         }
 
@@ -1033,7 +1031,7 @@ __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,
                     goto err;
 
                 if (!BN_nnmod(tmp_scalar, scalar, group-&gt;order, ctx)) {
-                    ECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_BN_LIB);
+                    ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
                     goto err;
                 }
                 scalar = tmp_scalar;
@@ -1125,13 +1123,13 @@ __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,
          */
         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));
         if (new_scalars == NULL) {
-            ECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));
         if (new_points == NULL) {
-            ECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
@@ -1186,14 +1184,14 @@ __owur static int ecp_nistz256_get_affine(const EC_GROUP *group,
     BN_ULONG x_ret[P256_LIMBS], y_ret[P256_LIMBS];
 
     if (EC_POINT_is_at_infinity(group, point)) {
-        ECerr(EC_F_ECP_NISTZ256_GET_AFFINE, EC_R_POINT_AT_INFINITY);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_AT_INFINITY);
         return 0;
     }
 
     if (!ecp_nistz256_bignum_to_field_elem(point_x, point-&gt;X) ||
         !ecp_nistz256_bignum_to_field_elem(point_y, point-&gt;Y) ||
         !ecp_nistz256_bignum_to_field_elem(point_z, point-&gt;Z)) {
-        ECerr(EC_F_ECP_NISTZ256_GET_AFFINE, EC_R_COORDINATES_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);
         return 0;
     }
 
@@ -1228,7 +1226,7 @@ static NISTZ256_PRE_COMP *ecp_nistz256_pre_comp_new(const EC_GROUP *group)
     ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        ECerr(EC_F_ECP_NISTZ256_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return ret;
     }
 
@@ -1238,7 +1236,7 @@ static NISTZ256_PRE_COMP *ecp_nistz256_pre_comp_new(const EC_GROUP *group)
 
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        ECerr(EC_F_ECP_NISTZ256_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -1327,7 +1325,7 @@ static int ecp_nistz256_inv_mod_ord(const EC_GROUP *group, BIGNUM *r,
      * Catch allocation failure early.
      */
     if (bn_wexpand(r, P256_LIMBS) == NULL) {
-        ECerr(EC_F_ECP_NISTZ256_INV_MOD_ORD, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
 
@@ -1336,14 +1334,14 @@ static int ecp_nistz256_inv_mod_ord(const EC_GROUP *group, BIGNUM *r,
 
         if ((tmp = BN_CTX_get(ctx)) == NULL
             || !BN_nnmod(tmp, x, group-&gt;order, ctx)) {
-            ECerr(EC_F_ECP_NISTZ256_INV_MOD_ORD, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
         x = tmp;
     }
 
     if (!ecp_nistz256_bignum_to_field_elem(t, x)) {
-        ECerr(EC_F_ECP_NISTZ256_INV_MOD_ORD, EC_R_COORDINATES_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);
         goto err;
     }
 
diff --git a/crypto/ec/ecp_oct.c b/crypto/ec/ecp_oct.c
index 38d661e13f..b1c8e3ed8a 100644
--- a/crypto/ec/ecp_oct.c
+++ b/crypto/ec/ecp_oct.c
@@ -113,13 +113,11 @@ int ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *group,
         if (ERR_GET_LIB(err) == ERR_LIB_BN
             &amp;&amp; ERR_GET_REASON(err) == BN_R_NOT_A_SQUARE) {
             ERR_clear_error();
-            ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES,
-                  EC_R_INVALID_COMPRESSED_POINT);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_COMPRESSED_POINT);
         } else
 #endif
         {
-            ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES,
-                  ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         }
         goto err;
     }
@@ -133,22 +131,19 @@ int ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *group,
                 goto err;
 
             if (kron == 1)
-                ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES,
-                      EC_R_INVALID_COMPRESSION_BIT);
+                ERR_raise(ERR_LIB_EC, EC_R_INVALID_COMPRESSION_BIT);
             else
                 /*
                  * BN_mod_sqrt() should have caught this error (not a square)
                  */
-                ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES,
-                      EC_R_INVALID_COMPRESSED_POINT);
+                ERR_raise(ERR_LIB_EC, EC_R_INVALID_COMPRESSED_POINT);
             goto err;
         }
         if (!BN_usub(y, group-&gt;field, y))
             goto err;
     }
     if (y_bit != BN_is_odd(y)) {
-        ECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES,
-              ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
         goto err;
     }
 
@@ -176,7 +171,7 @@ size_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
     if ((form != POINT_CONVERSION_COMPRESSED)
         &amp;&amp; (form != POINT_CONVERSION_UNCOMPRESSED)
         &amp;&amp; (form != POINT_CONVERSION_HYBRID)) {
-        ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_INVALID_FORM);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_FORM);
         goto err;
     }
 
@@ -184,7 +179,7 @@ size_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
         /* encodes to a single 0 octet */
         if (buf != NULL) {
             if (len &lt; 1) {
-                ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);
+                ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
                 return 0;
             }
             buf[0] = 0;
@@ -201,7 +196,7 @@ size_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
     /* if 'buf' is NULL, just return required length */
     if (buf != NULL) {
         if (len &lt; ret) {
-            ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);
+            ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
             goto err;
         }
 
@@ -231,7 +226,7 @@ size_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
 
         skip = field_len - BN_num_bytes(x);
         if (skip &gt; field_len) {
-            ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
             goto err;
         }
         while (skip &gt; 0) {
@@ -241,7 +236,7 @@ size_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
         skip = BN_bn2bin(x, buf + i);
         i += skip;
         if (i != 1 + field_len) {
-            ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
             goto err;
         }
 
@@ -249,7 +244,7 @@ size_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
             || form == POINT_CONVERSION_HYBRID) {
             skip = field_len - BN_num_bytes(y);
             if (skip &gt; field_len) {
-                ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
             while (skip &gt; 0) {
@@ -261,7 +256,7 @@ size_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
         }
 
         if (i != ret) {
-            ECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
             goto err;
         }
     }
@@ -289,7 +284,7 @@ int ec_GFp_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
     int ret = 0;
 
     if (len == 0) {
-        ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_BUFFER_TOO_SMALL);
+        ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
         return 0;
     }
     form = buf[0];
@@ -298,17 +293,17 @@ int ec_GFp_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
     if ((form != 0) &amp;&amp; (form != POINT_CONVERSION_COMPRESSED)
         &amp;&amp; (form != POINT_CONVERSION_UNCOMPRESSED)
         &amp;&amp; (form != POINT_CONVERSION_HYBRID)) {
-        ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         return 0;
     }
     if ((form == 0 || form == POINT_CONVERSION_UNCOMPRESSED) &amp;&amp; y_bit) {
-        ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         return 0;
     }
 
     if (form == 0) {
         if (len != 1) {
-            ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
             return 0;
         }
 
@@ -321,7 +316,7 @@ int ec_GFp_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
          POINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2 * field_len;
 
     if (len != enc_len) {
-        ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         return 0;
     }
 
@@ -340,7 +335,7 @@ int ec_GFp_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
     if (!BN_bin2bn(buf + 1, field_len, x))
         goto err;
     if (BN_ucmp(x, group-&gt;field) &gt;= 0) {
-        ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         goto err;
     }
 
@@ -351,12 +346,12 @@ int ec_GFp_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
         if (!BN_bin2bn(buf + 1 + field_len, field_len, y))
             goto err;
         if (BN_ucmp(y, group-&gt;field) &gt;= 0) {
-            ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
             goto err;
         }
         if (form == POINT_CONVERSION_HYBRID) {
             if (y_bit != BN_is_odd(y)) {
-                ECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);
+                ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
                 goto err;
             }
         }
diff --git a/crypto/ec/ecp_s390x_nistp.c b/crypto/ec/ecp_s390x_nistp.c
index edbad15cdd..c4b490e3be 100644
--- a/crypto/ec/ecp_s390x_nistp.c
+++ b/crypto/ec/ecp_s390x_nistp.c
@@ -140,27 +140,26 @@ static ECDSA_SIG *ecdsa_s390x_nistp_sign_sig(const unsigned char *dgst,
     group = EC_KEY_get0_group(eckey);
     privkey = EC_KEY_get0_private_key(eckey);
     if (group == NULL || privkey == NULL) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_SIGN_SIG, EC_R_MISSING_PARAMETERS);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PARAMETERS);
         return NULL;
     }
 
     if (!EC_KEY_can_sign(eckey)) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_SIGN_SIG,
-              EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);
+        ERR_raise(ERR_LIB_EC, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);
         return NULL;
     }
 
     k = BN_secure_new();
     sig = ECDSA_SIG_new();
     if (k == NULL || sig == NULL) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_SIGN_SIG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto ret;
     }
 
     sig-&gt;r = BN_new();
     sig-&gt;s = BN_new();
     if (sig-&gt;r == NULL || sig-&gt;s == NULL) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_SIGN_SIG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto ret;
     }
 
@@ -169,7 +168,7 @@ static ECDSA_SIG *ecdsa_s390x_nistp_sign_sig(const unsigned char *dgst,
     memcpy(param + S390X_OFF_H(len) + off, dgst, len - off);
 
     if (BN_bn2binpad(privkey, param + S390X_OFF_K(len), len) == -1) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_SIGN_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto ret;
     }
 
@@ -182,15 +181,14 @@ static ECDSA_SIG *ecdsa_s390x_nistp_sign_sig(const unsigned char *dgst,
          */
          if (RAND_priv_bytes_ex(eckey-&gt;libctx, param + S390X_OFF_RN(len),
                                 len) != 1) {
-             ECerr(EC_F_ECDSA_S390X_NISTP_SIGN_SIG,
-                   EC_R_RANDOM_NUMBER_GENERATION_FAILED);
+             ERR_raise(ERR_LIB_EC, EC_R_RANDOM_NUMBER_GENERATION_FAILED);
              goto ret;
          }
     } else {
         /* Reconstruct k = (k^-1)^-1. */
         if (ec_group_do_inverse_ord(group, k, kinv, NULL) == 0
             || BN_bn2binpad(k, param + S390X_OFF_RN(len), len) == -1) {
-            ECerr(EC_F_ECDSA_S390X_NISTP_SIGN_SIG, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto ret;
         }
         /* Turns KDSA internal nonce-generation off. */
@@ -198,13 +196,13 @@ static ECDSA_SIG *ecdsa_s390x_nistp_sign_sig(const unsigned char *dgst,
     }
 
     if (s390x_kdsa(fc, param, NULL, 0) != 0) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_SIGN_SIG, ERR_R_ECDSA_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_ECDSA_LIB);
         goto ret;
     }
 
     if (BN_bin2bn(param + S390X_OFF_R(len), len, sig-&gt;r) == NULL
         || BN_bin2bn(param + S390X_OFF_S(len), len, sig-&gt;s) == NULL) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_SIGN_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto ret;
     }
 
@@ -234,19 +232,18 @@ static int ecdsa_s390x_nistp_verify_sig(const unsigned char *dgst, int dgstlen,
     group = EC_KEY_get0_group(eckey);
     pubkey = EC_KEY_get0_public_key(eckey);
     if (eckey == NULL || group == NULL || pubkey == NULL || sig == NULL) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_VERIFY_SIG, EC_R_MISSING_PARAMETERS);
+        ERR_raise(ERR_LIB_EC, EC_R_MISSING_PARAMETERS);
         return -1;
     }
 
     if (!EC_KEY_can_sign(eckey)) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_VERIFY_SIG,
-              EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);
+        ERR_raise(ERR_LIB_EC, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING);
         return -1;
     }
 
     ctx = BN_CTX_new_ex(group-&gt;libctx);
     if (ctx == NULL) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_VERIFY_SIG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
@@ -255,7 +252,7 @@ static int ecdsa_s390x_nistp_verify_sig(const unsigned char *dgst, int dgstlen,
     x = BN_CTX_get(ctx);
     y = BN_CTX_get(ctx);
     if (x == NULL || y == NULL) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_VERIFY_SIG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto ret;
     }
 
@@ -269,7 +266,7 @@ static int ecdsa_s390x_nistp_verify_sig(const unsigned char *dgst, int dgstlen,
         || BN_bn2binpad(sig-&gt;s, param + S390X_OFF_S(len), len) == -1
         || BN_bn2binpad(x, param + S390X_OFF_X(len), len) == -1
         || BN_bn2binpad(y, param + S390X_OFF_Y(len), len) == -1) {
-        ECerr(EC_F_ECDSA_S390X_NISTP_VERIFY_SIG, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto ret;
     }
 
diff --git a/crypto/ec/ecp_smpl.c b/crypto/ec/ecp_smpl.c
index e942782be5..94b819829f 100644
--- a/crypto/ec/ecp_smpl.c
+++ b/crypto/ec/ecp_smpl.c
@@ -148,7 +148,7 @@ int ec_GFp_simple_group_set_curve(EC_GROUP *group,
 
     /* p must be a prime &gt; 3 */
     if (BN_num_bits(p) &lt;= 2 || !BN_is_odd(p)) {
-        ECerr(EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE, EC_R_INVALID_FIELD);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_FIELD);
         return 0;
     }
 
@@ -257,8 +257,7 @@ int ec_GFp_simple_group_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)
     if (ctx == NULL) {
         ctx = new_ctx = BN_CTX_new_ex(group-&gt;libctx);
         if (ctx == NULL) {
-            ECerr(EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT,
-                  ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -490,8 +489,7 @@ int ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *group,
         /*
          * unlike for projective coordinates, we do not tolerate this
          */
-        ECerr(EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES,
-              ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -510,8 +508,7 @@ int ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *group,
     int ret = 0;
 
     if (EC_POINT_is_at_infinity(group, point)) {
-        ECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES,
-              EC_R_POINT_AT_INFINITY);
+        ERR_raise(ERR_LIB_EC, EC_R_POINT_AT_INFINITY);
         return 0;
     }
 
@@ -561,8 +558,7 @@ int ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *group,
         }
     } else {
         if (!group-&gt;meth-&gt;field_inv(group, Z_1, Z_, ctx)) {
-            ECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES,
-                  ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
 
@@ -1192,7 +1188,7 @@ int ec_GFp_simple_make_affine(const EC_GROUP *group, EC_POINT *point,
     if (!EC_POINT_set_affine_coordinates(group, point, x, y, ctx))
         goto err;
     if (!point-&gt;Z_is_one) {
-        ECerr(EC_F_EC_GFP_SIMPLE_MAKE_AFFINE, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_EC, ERR_R_INTERNAL_ERROR);
         goto err;
     }
 
@@ -1273,7 +1269,7 @@ int ec_GFp_simple_points_make_affine(const EC_GROUP *group, size_t num,
      */
 
     if (!group-&gt;meth-&gt;field_inv(group, tmp, prod_Z[num - 1], ctx)) {
-        ECerr(EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
     if (group-&gt;meth-&gt;field_encode != 0) {
@@ -1406,7 +1402,7 @@ int ec_GFp_simple_field_inv(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
         goto err;
     /* r := 1/(a * e) */
     if (!BN_mod_inverse(r, r, group-&gt;field, ctx)) {
-        ECerr(EC_F_EC_GFP_SIMPLE_FIELD_INV, EC_R_CANNOT_INVERT);
+        ERR_raise(ERR_LIB_EC, EC_R_CANNOT_INVERT);
         goto err;
     }
     /* r := e/(a * e) = 1/a */
@@ -1439,7 +1435,7 @@ int ec_GFp_simple_blind_coordinates(const EC_GROUP *group, EC_POINT *p,
     lambda = BN_CTX_get(ctx);
     temp = BN_CTX_get(ctx);
     if (temp == NULL) {
-        ECerr(EC_F_EC_GFP_SIMPLE_BLIND_COORDINATES, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto end;
     }
 
diff --git a/crypto/ec/ecx_backend.c b/crypto/ec/ecx_backend.c
index d1e652ae4f..8bd96474bd 100644
--- a/crypto/ec/ecx_backend.c
+++ b/crypto/ec/ecx_backend.c
@@ -29,7 +29,7 @@ int ecx_public_from_private(ECX_KEY *key)
     case ECX_KEY_TYPE_ED25519:
         if (!ED25519_public_from_private(key-&gt;libctx, key-&gt;pubkey, key-&gt;privkey,
                                          key-&gt;propq)) {
-            ECerr(0, EC_R_FAILED_MAKING_PUBLIC_KEY);
+            ERR_raise(ERR_LIB_EC, EC_R_FAILED_MAKING_PUBLIC_KEY);
             return 0;
         }
         break;
@@ -39,7 +39,7 @@ int ecx_public_from_private(ECX_KEY *key)
     case ECX_KEY_TYPE_ED448:
         if (!ED448_public_from_private(key-&gt;libctx, key-&gt;pubkey, key-&gt;privkey,
                                        key-&gt;propq)) {
-            ECerr(0, EC_R_FAILED_MAKING_PUBLIC_KEY);
+            ERR_raise(ERR_LIB_EC, EC_R_FAILED_MAKING_PUBLIC_KEY);
             return 0;
         }
         break;
diff --git a/crypto/ec/ecx_meth.c b/crypto/ec/ecx_meth.c
index 5405164783..3178cc2d31 100644
--- a/crypto/ec/ecx_meth.c
+++ b/crypto/ec/ecx_meth.c
@@ -48,20 +48,20 @@ static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
             /* Algorithm parameters must be absent */
             X509_ALGOR_get0(NULL, &amp;ptype, NULL, palg);
             if (ptype != V_ASN1_UNDEF) {
-                ECerr(EC_F_ECX_KEY_OP, EC_R_INVALID_ENCODING);
+                ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
                 return 0;
             }
         }
 
         if (p == NULL || plen != KEYLENID(id)) {
-            ECerr(EC_F_ECX_KEY_OP, EC_R_INVALID_ENCODING);
+            ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
             return 0;
         }
     }
 
     key = ecx_key_new(libctx, KEYNID2TYPE(id), 1, propq);
     if (key == NULL) {
-        ECerr(EC_F_ECX_KEY_OP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     pubkey = key-&gt;pubkey;
@@ -71,7 +71,7 @@ static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
     } else {
         privkey = ecx_key_allocate_privkey(key);
         if (privkey == NULL) {
-            ECerr(EC_F_ECX_KEY_OP, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (op == KEY_OP_KEYGEN) {
@@ -89,7 +89,7 @@ static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
             memcpy(privkey, p, KEYLENID(id));
         }
         if (!ecx_public_from_private(key)) {
-            ECerr(EC_F_ECX_KEY_OP, EC_R_FAILED_MAKING_PUBLIC_KEY);
+            ERR_raise(ERR_LIB_EC, EC_R_FAILED_MAKING_PUBLIC_KEY);
             goto err;
         }
     }
@@ -107,20 +107,20 @@ static int ecx_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
     unsigned char *penc;
 
     if (ecxkey == NULL) {
-        ECerr(EC_F_ECX_PUB_ENCODE, EC_R_INVALID_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_KEY);
         return 0;
     }
 
     penc = OPENSSL_memdup(ecxkey-&gt;pubkey, KEYLEN(pkey));
     if (penc == NULL) {
-        ECerr(EC_F_ECX_PUB_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
     if (!X509_PUBKEY_set0_param(pk, OBJ_nid2obj(pkey-&gt;ameth-&gt;pkey_id),
                                 V_ASN1_UNDEF, NULL, penc, KEYLEN(pkey))) {
         OPENSSL_free(penc);
-        ECerr(EC_F_ECX_PUB_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return 1;
@@ -184,7 +184,7 @@ static int ecx_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
     int penclen;
 
     if (ecxkey == NULL || ecxkey-&gt;privkey == NULL) {
-        ECerr(EC_F_ECX_PRIV_ENCODE, EC_R_INVALID_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_PRIVATE_KEY);
         return 0;
     }
 
@@ -194,14 +194,14 @@ static int ecx_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
 
     penclen = i2d_ASN1_OCTET_STRING(&amp;oct, &amp;penc);
     if (penclen &lt; 0) {
-        ECerr(EC_F_ECX_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
     if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(pkey-&gt;ameth-&gt;pkey_id), 0,
                          V_ASN1_UNDEF, NULL, penc, penclen)) {
         OPENSSL_clear_free(penc, penclen);
-        ECerr(EC_F_ECX_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -582,7 +582,7 @@ static int ecd_item_verify(EVP_MD_CTX *ctx, const ASN1_ITEM *it,
     X509_ALGOR_get0(&amp;obj, &amp;ptype, NULL, sigalg);
     nid = OBJ_obj2nid(obj);
     if ((nid != NID_ED25519 &amp;&amp; nid != NID_ED448) || ptype != V_ASN1_UNDEF) {
-        ECerr(EC_F_ECD_ITEM_VERIFY, EC_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_ENCODING);
         return 0;
     }
 
@@ -752,17 +752,17 @@ static int validate_ecx_derive(EVP_PKEY_CTX *ctx, unsigned char *key,
     const ECX_KEY *ecxkey, *peerkey;
 
     if (ctx-&gt;pkey == NULL || ctx-&gt;peerkey == NULL) {
-        ECerr(EC_F_VALIDATE_ECX_DERIVE, EC_R_KEYS_NOT_SET);
+        ERR_raise(ERR_LIB_EC, EC_R_KEYS_NOT_SET);
         return 0;
     }
     ecxkey = ctx-&gt;pkey-&gt;pkey.ecx;
     peerkey = ctx-&gt;peerkey-&gt;pkey.ecx;
     if (ecxkey == NULL || ecxkey-&gt;privkey == NULL) {
-        ECerr(EC_F_VALIDATE_ECX_DERIVE, EC_R_INVALID_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_PRIVATE_KEY);
         return 0;
     }
     if (peerkey == NULL) {
-        ECerr(EC_F_VALIDATE_ECX_DERIVE, EC_R_INVALID_PEER_KEY);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_PEER_KEY);
         return 0;
     }
     *privkey = ecxkey-&gt;privkey;
@@ -836,7 +836,7 @@ static int pkey_ecd_digestsign25519(EVP_MD_CTX *ctx, unsigned char *sig,
         return 1;
     }
     if (*siglen &lt; ED25519_SIGSIZE) {
-        ECerr(EC_F_PKEY_ECD_DIGESTSIGN25519, EC_R_BUFFER_TOO_SMALL);
+        ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
         return 0;
     }
 
@@ -858,7 +858,7 @@ static int pkey_ecd_digestsign448(EVP_MD_CTX *ctx, unsigned char *sig,
         return 1;
     }
     if (*siglen &lt; ED448_SIGSIZE) {
-        ECerr(EC_F_PKEY_ECD_DIGESTSIGN448, EC_R_BUFFER_TOO_SMALL);
+        ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
         return 0;
     }
 
@@ -902,7 +902,7 @@ static int pkey_ecd_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
         /* Only NULL allowed as digest */
         if (p2 == NULL || (const EVP_MD *)p2 == EVP_md_null())
             return 1;
-        ECerr(EC_F_PKEY_ECD_CTRL, EC_R_INVALID_DIGEST_TYPE);
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_DIGEST_TYPE);
         return 0;
 
     case EVP_PKEY_CTRL_DIGESTINIT:
@@ -948,7 +948,7 @@ static int s390x_pkey_ecx_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     unsigned char *privkey = NULL, *pubkey;
 
     if (key == NULL) {
-        ECerr(EC_F_S390X_PKEY_ECX_KEYGEN25519, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -956,7 +956,7 @@ static int s390x_pkey_ecx_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 
     privkey = ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
-        ECerr(EC_F_S390X_PKEY_ECX_KEYGEN25519, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -991,7 +991,7 @@ static int s390x_pkey_ecx_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     unsigned char *privkey = NULL, *pubkey;
 
     if (key == NULL) {
-        ECerr(EC_F_S390X_PKEY_ECX_KEYGEN448, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -999,7 +999,7 @@ static int s390x_pkey_ecx_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 
     privkey = ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
-        ECerr(EC_F_S390X_PKEY_ECX_KEYGEN448, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -1038,7 +1038,7 @@ static int s390x_pkey_ecd_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     unsigned int sz;
 
     if (key == NULL) {
-        ECerr(EC_F_S390X_PKEY_ECD_KEYGEN25519, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -1046,7 +1046,7 @@ static int s390x_pkey_ecd_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 
     privkey = ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
-        ECerr(EC_F_S390X_PKEY_ECD_KEYGEN25519, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -1096,7 +1096,7 @@ static int s390x_pkey_ecd_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     EVP_MD_CTX *hashctx = NULL;
 
     if (key == NULL) {
-        ECerr(EC_F_S390X_PKEY_ECD_KEYGEN448, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -1104,7 +1104,7 @@ static int s390x_pkey_ecd_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 
     privkey = ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
-        ECerr(EC_F_S390X_PKEY_ECD_KEYGEN448, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -1191,7 +1191,7 @@ static int s390x_pkey_ecd_digestsign25519(EVP_MD_CTX *ctx,
     }
 
     if (*siglen &lt; ED25519_SIGSIZE) {
-        ECerr(EC_F_S390X_PKEY_ECD_DIGESTSIGN25519, EC_R_BUFFER_TOO_SMALL);
+        ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
         return 0;
     }
 
@@ -1231,7 +1231,7 @@ static int s390x_pkey_ecd_digestsign448(EVP_MD_CTX *ctx,
     }
 
     if (*siglen &lt; ED448_SIGSIZE) {
-        ECerr(EC_F_S390X_PKEY_ECD_DIGESTSIGN448, EC_R_BUFFER_TOO_SMALL);
+        ERR_raise(ERR_LIB_EC, EC_R_BUFFER_TOO_SMALL);
         return 0;
     }
 
diff --git a/crypto/engine/eng_cnf.c b/crypto/engine/eng_cnf.c
index 0fb576c847..14744bb7f5 100644
--- a/crypto/engine/eng_cnf.c
+++ b/crypto/engine/eng_cnf.c
@@ -57,8 +57,7 @@ static int int_engine_configure(const char *name, const char *value, const CONF
     ecmds = NCONF_get_section(cnf, value);
 
     if (!ecmds) {
-        ENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE,
-                  ENGINE_R_ENGINE_SECTION_ERROR);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_ENGINE_SECTION_ERROR);
         return 0;
     }
 
@@ -116,8 +115,7 @@ static int int_engine_configure(const char *name, const char *value, const CONF
                     if (!int_engine_init(e))
                         goto err;
                 } else if (do_init != 0) {
-                    ENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE,
-                              ENGINE_R_INVALID_INIT_VALUE);
+                    ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_INIT_VALUE);
                     goto err;
                 }
             } else if (strcmp(ctrlname, &quot;default_algorithms&quot;) == 0) {
@@ -135,12 +133,12 @@ static int int_engine_configure(const char *name, const char *value, const CONF
     ret = 1;
  err:
     if (ret != 1) {
-        ENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE,
-                  ENGINE_R_ENGINE_CONFIGURATION_ERROR);
-        if (ecmd)
-            ERR_add_error_data(6, &quot;section=&quot;, ecmd-&gt;section,
-                               &quot;, name=&quot;, ecmd-&gt;name,
-                               &quot;, value=&quot;, ecmd-&gt;value);
+        if (ecmd == NULL)
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_ENGINE_CONFIGURATION_ERROR);
+        else
+            ERR_raise_data(ERR_LIB_ENGINE, ENGINE_R_ENGINE_CONFIGURATION_ERROR,
+                           &quot;section=%s, name=%s, value=%s&quot;,
+                           ecmd-&gt;section, ecmd-&gt;name, ecmd-&gt;value);
     }
     ENGINE_free(e);
     return ret;
@@ -157,8 +155,7 @@ static int int_engine_module_init(CONF_IMODULE *md, const CONF *cnf)
     elist = NCONF_get_section(cnf, CONF_imodule_get_value(md));
 
     if (!elist) {
-        ENGINEerr(ENGINE_F_INT_ENGINE_MODULE_INIT,
-                  ENGINE_R_ENGINES_SECTION_ERROR);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_ENGINES_SECTION_ERROR);
         return 0;
     }
 
diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c
index 0701c4c92a..ac770bdeb3 100644
--- a/crypto/engine/eng_ctrl.c
+++ b/crypto/engine/eng_ctrl.c
@@ -79,7 +79,7 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,
         (cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||
         (cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {
         if (s == NULL) {
-            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);
+            ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
             return -1;
         }
     }
@@ -87,7 +87,7 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,
     if (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {
         if ((e-&gt;cmd_defns == NULL)
             || ((idx = int_ctrl_cmd_by_name(e-&gt;cmd_defns, s)) &lt; 0)) {
-            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NAME);
             return -1;
         }
         return e-&gt;cmd_defns[idx].cmd_num;
@@ -98,7 +98,7 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,
      */
     if ((e-&gt;cmd_defns == NULL)
         || ((idx = int_ctrl_cmd_by_num(e-&gt;cmd_defns, (unsigned int)i)) &lt; 0)) {
-        ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NUMBER);
         return -1;
     }
     /* Now the logic splits depending on command type */
@@ -121,7 +121,7 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,
         return cdp-&gt;cmd_flags;
     }
     /* Shouldn't really be here ... */
-    ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INTERNAL_LIST_ERROR);
+    ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INTERNAL_LIST_ERROR);
     return -1;
 }
 
@@ -129,7 +129,7 @@ int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
 {
     int ctrl_exists, ref_exists;
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_CTRL, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     CRYPTO_THREAD_write_lock(global_engine_lock);
@@ -137,7 +137,7 @@ int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
     CRYPTO_THREAD_unlock(global_engine_lock);
     ctrl_exists = ((e-&gt;ctrl == NULL) ? 0 : 1);
     if (!ref_exists) {
-        ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_REFERENCE);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NO_REFERENCE);
         return 0;
     }
     /*
@@ -158,7 +158,7 @@ int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
         if (ctrl_exists &amp;&amp; !(e-&gt;flags &amp; ENGINE_FLAGS_MANUAL_CMD_CTRL))
             return int_ctrl_helper(e, cmd, i, p, f);
         if (!ctrl_exists) {
-            ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION);
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NO_CONTROL_FUNCTION);
             /*
              * For these cmd-related functions, failure is indicated by a -1
              * return value (because 0 is used as a valid return in some
@@ -171,7 +171,7 @@ int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
     }
     /* Anything else requires a ctrl() handler to exist. */
     if (!ctrl_exists) {
-        ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NO_CONTROL_FUNCTION);
         return 0;
     }
     return e-&gt;ctrl(e, cmd, i, p, f);
@@ -182,8 +182,7 @@ int ENGINE_cmd_is_executable(ENGINE *e, int cmd)
     int flags;
     if ((flags =
          ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, cmd, NULL, NULL)) &lt; 0) {
-        ENGINEerr(ENGINE_F_ENGINE_CMD_IS_EXECUTABLE,
-                  ENGINE_R_INVALID_CMD_NUMBER);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NUMBER);
         return 0;
     }
     if (!(flags &amp; ENGINE_CMD_FLAG_NO_INPUT) &amp;&amp;
@@ -199,7 +198,7 @@ int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,
     int num;
 
     if (e == NULL || cmd_name == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if (e-&gt;ctrl == NULL
@@ -217,7 +216,7 @@ int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,
             ERR_clear_error();
             return 1;
         }
-        ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD, ENGINE_R_INVALID_CMD_NAME);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NAME);
         return 0;
     }
     /*
@@ -237,7 +236,7 @@ int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,
     char *ptr;
 
     if (e == NULL || cmd_name == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if (e-&gt;ctrl == NULL
@@ -255,12 +254,11 @@ int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,
             ERR_clear_error();
             return 1;
         }
-        ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INVALID_CMD_NAME);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NAME);
         return 0;
     }
     if (!ENGINE_cmd_is_executable(e, num)) {
-        ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,
-                  ENGINE_R_CMD_NOT_EXECUTABLE);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_CMD_NOT_EXECUTABLE);
         return 0;
     }
 
@@ -270,8 +268,7 @@ int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,
          * Shouldn't happen, given that ENGINE_cmd_is_executable() returned
          * success.
          */
-        ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,
-                  ENGINE_R_INTERNAL_LIST_ERROR);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INTERNAL_LIST_ERROR);
         return 0;
     }
     /*
@@ -279,8 +276,7 @@ int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,
      */
     if (flags &amp; ENGINE_CMD_FLAG_NO_INPUT) {
         if (arg != NULL) {
-            ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,
-                      ENGINE_R_COMMAND_TAKES_NO_INPUT);
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_COMMAND_TAKES_NO_INPUT);
             return 0;
         }
         /*
@@ -295,8 +291,7 @@ int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,
     }
     /* So, we require input */
     if (arg == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,
-                  ENGINE_R_COMMAND_TAKES_INPUT);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_COMMAND_TAKES_INPUT);
         return 0;
     }
     /* If it takes string input, that's easy */
@@ -313,14 +308,12 @@ int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,
      * used.
      */
     if (!(flags &amp; ENGINE_CMD_FLAG_NUMERIC)) {
-        ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,
-                  ENGINE_R_INTERNAL_LIST_ERROR);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INTERNAL_LIST_ERROR);
         return 0;
     }
     l = strtol(arg, &amp;ptr, 10);
     if ((arg == ptr) || (*ptr != '\0')) {
-        ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,
-                  ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER);
         return 0;
     }
     /*
diff --git a/crypto/engine/eng_dyn.c b/crypto/engine/eng_dyn.c
index 3b0d8eb91f..0ce8146f16 100644
--- a/crypto/engine/eng_dyn.c
+++ b/crypto/engine/eng_dyn.c
@@ -160,12 +160,12 @@ static int dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx)
     int ret = 1;
 
     if (c == NULL) {
-        ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     c-&gt;dirs = sk_OPENSSL_STRING_new_null();
     if (c-&gt;dirs == NULL) {
-        ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(c);
         return 0;
     }
@@ -210,7 +210,7 @@ static dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e)
         int new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL,
                                               dynamic_data_ctx_free_func);
         if (new_idx == -1) {
-            ENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX, ENGINE_R_NO_INDEX);
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NO_INDEX);
             return NULL;
         }
         CRYPTO_THREAD_write_lock(global_engine_lock);
@@ -297,13 +297,13 @@ static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
     int initialised;
 
     if (!ctx) {
-        ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_NOT_LOADED);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NOT_LOADED);
         return 0;
     }
     initialised = ((ctx-&gt;dynamic_dso == NULL) ? 0 : 1);
     /* All our control commands require the ENGINE to be uninitialised */
     if (initialised) {
-        ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_ALREADY_LOADED);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_ALREADY_LOADED);
         return 0;
     }
     switch (cmd) {
@@ -332,7 +332,7 @@ static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
         return (ctx-&gt;engine_id ? 1 : 0);
     case DYNAMIC_CMD_LIST_ADD:
         if ((i &lt; 0) || (i &gt; 2)) {
-            ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT);
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_ARGUMENT);
             return 0;
         }
         ctx-&gt;list_add_value = (int)i;
@@ -341,7 +341,7 @@ static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
         return dynamic_load(e, ctx);
     case DYNAMIC_CMD_DIR_LOAD:
         if ((i &lt; 0) || (i &gt; 2)) {
-            ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT);
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_ARGUMENT);
             return 0;
         }
         ctx-&gt;dir_load = (int)i;
@@ -349,18 +349,18 @@ static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
     case DYNAMIC_CMD_DIR_ADD:
         /* a NULL 'p' or a string of zero-length is the same thing */
         if (p == NULL || (strlen((const char *)p) &lt; 1)) {
-            ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT);
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_ARGUMENT);
             return 0;
         }
         {
             char *tmp_str = OPENSSL_strdup(p);
             if (tmp_str == NULL) {
-                ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
             if (!sk_OPENSSL_STRING_push(ctx-&gt;dirs, tmp_str)) {
                 OPENSSL_free(tmp_str);
-                ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
         }
@@ -368,7 +368,7 @@ static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))
     default:
         break;
     }
-    ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);
+    ERR_raise(ERR_LIB_ENGINE, ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);
     return 0;
 }
 
@@ -416,7 +416,7 @@ static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)
             DSO_convert_filename(ctx-&gt;dynamic_dso, ctx-&gt;engine_id);
     }
     if (!int_load(ctx)) {
-        ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_NOT_FOUND);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_DSO_NOT_FOUND);
         DSO_free(ctx-&gt;dynamic_dso);
         ctx-&gt;dynamic_dso = NULL;
         return 0;
@@ -429,7 +429,7 @@ static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)
         ctx-&gt;bind_engine = NULL;
         DSO_free(ctx-&gt;dynamic_dso);
         ctx-&gt;dynamic_dso = NULL;
-        ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_DSO_FAILURE);
         return 0;
     }
     /* Do we perform version checking? */
@@ -455,8 +455,7 @@ static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)
             ctx-&gt;v_check = NULL;
             DSO_free(ctx-&gt;dynamic_dso);
             ctx-&gt;dynamic_dso = NULL;
-            ENGINEerr(ENGINE_F_DYNAMIC_LOAD,
-                      ENGINE_R_VERSION_INCOMPATIBILITY);
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_VERSION_INCOMPATIBILITY);
             return 0;
         }
     }
@@ -487,7 +486,7 @@ static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)
         ctx-&gt;v_check = NULL;
         DSO_free(ctx-&gt;dynamic_dso);
         ctx-&gt;dynamic_dso = NULL;
-        ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_INIT_FAILED);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INIT_FAILED);
         /* Copy the original ENGINE structure back */
         memcpy(e, &amp;cpy, sizeof(ENGINE));
         return 0;
@@ -503,8 +502,7 @@ static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)
                  * created leaks. We just have to fail where we are, after
                  * the ENGINE has changed.
                  */
-                ENGINEerr(ENGINE_F_DYNAMIC_LOAD,
-                          ENGINE_R_CONFLICTING_ENGINE_ID);
+                ERR_raise(ERR_LIB_ENGINE, ENGINE_R_CONFLICTING_ENGINE_ID);
                 return 0;
             }
             /* Tolerate */
diff --git a/crypto/engine/eng_fat.c b/crypto/engine/eng_fat.c
index 1e98a340cd..78537057b7 100644
--- a/crypto/engine/eng_fat.c
+++ b/crypto/engine/eng_fat.c
@@ -85,9 +85,8 @@ int ENGINE_set_default_string(ENGINE *e, const char *def_list)
 {
     unsigned int flags = 0;
     if (!CONF_parse_list(def_list, ',', 1, int_def_cb, &amp;flags)) {
-        ENGINEerr(ENGINE_F_ENGINE_SET_DEFAULT_STRING,
-                  ENGINE_R_INVALID_STRING);
-        ERR_add_error_data(2, &quot;str=&quot;, def_list);
+        ERR_raise_data(ERR_LIB_ENGINE, ENGINE_R_INVALID_STRING,
+                       &quot;str=%s&quot;, def_list);
         return 0;
     }
     return ENGINE_set_default(e, flags);
diff --git a/crypto/engine/eng_init.c b/crypto/engine/eng_init.c
index 22376a96fe..6c9a58fb7a 100644
--- a/crypto/engine/eng_init.c
+++ b/crypto/engine/eng_init.c
@@ -70,7 +70,7 @@ int engine_unlocked_finish(ENGINE *e, int unlock_for_handlers)
     REF_ASSERT_ISNT(e-&gt;funct_ref &lt; 0);
     /* Release the structural reference too */
     if (!engine_free_util(e, 0)) {
-        ENGINEerr(ENGINE_F_ENGINE_UNLOCKED_FINISH, ENGINE_R_FINISH_FAILED);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_FINISH_FAILED);
         return 0;
     }
     return to_return;
@@ -81,11 +81,11 @@ int ENGINE_init(ENGINE *e)
 {
     int ret;
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_INIT, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if (!RUN_ONCE(&amp;engine_lock_init, do_engine_lock_init)) {
-        ENGINEerr(ENGINE_F_ENGINE_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     CRYPTO_THREAD_write_lock(global_engine_lock);
@@ -105,7 +105,7 @@ int ENGINE_finish(ENGINE *e)
     to_return = engine_unlocked_finish(e, 1);
     CRYPTO_THREAD_unlock(global_engine_lock);
     if (!to_return) {
-        ENGINEerr(ENGINE_F_ENGINE_FINISH, ENGINE_R_FINISH_FAILED);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_FINISH_FAILED);
         return 0;
     }
     return to_return;
diff --git a/crypto/engine/eng_lib.c b/crypto/engine/eng_lib.c
index 702b61b23f..72e463a899 100644
--- a/crypto/engine/eng_lib.c
+++ b/crypto/engine/eng_lib.c
@@ -32,7 +32,7 @@ ENGINE *ENGINE_new(void)
 
     if (!RUN_ONCE(&amp;engine_lock_init, do_engine_lock_init)
         || (ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;struct_ref = 1;
@@ -126,7 +126,7 @@ static ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)
     ENGINE_CLEANUP_ITEM *item;
 
     if ((item = OPENSSL_malloc(sizeof(*item))) == NULL) {
-        ENGINEerr(ENGINE_F_INT_CLEANUP_ITEM, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     item-&gt;cb = cb;
@@ -194,7 +194,7 @@ void *ENGINE_get_ex_data(const ENGINE *e, int idx)
 int ENGINE_set_id(ENGINE *e, const char *id)
 {
     if (id == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_SET_ID, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     e-&gt;id = id;
@@ -204,7 +204,7 @@ int ENGINE_set_id(ENGINE *e, const char *id)
 int ENGINE_set_name(ENGINE *e, const char *name)
 {
     if (name == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_SET_NAME, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     e-&gt;name = name;
diff --git a/crypto/engine/eng_list.c b/crypto/engine/eng_list.c
index cb9ad78838..de3475fe22 100644
--- a/crypto/engine/eng_list.c
+++ b/crypto/engine/eng_list.c
@@ -54,7 +54,7 @@ static int engine_list_add(ENGINE *e)
     ENGINE *iterator = NULL;
 
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     iterator = engine_list_head;
@@ -63,13 +63,13 @@ static int engine_list_add(ENGINE *e)
         iterator = iterator-&gt;next;
     }
     if (conflict) {
-        ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_CONFLICTING_ENGINE_ID);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_CONFLICTING_ENGINE_ID);
         return 0;
     }
     if (engine_list_head == NULL) {
         /* We are adding to an empty list. */
         if (engine_list_tail) {
-            ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR);
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INTERNAL_LIST_ERROR);
             return 0;
         }
         engine_list_head = e;
@@ -81,7 +81,7 @@ static int engine_list_add(ENGINE *e)
     } else {
         /* We are adding to the tail of an existing list. */
         if ((engine_list_tail == NULL) || (engine_list_tail-&gt;next != NULL)) {
-            ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR);
+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INTERNAL_LIST_ERROR);
             return 0;
         }
         engine_list_tail-&gt;next = e;
@@ -103,7 +103,7 @@ static int engine_list_remove(ENGINE *e)
     ENGINE *iterator;
 
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_LIST_REMOVE, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     /* We need to check that e is in our linked list! */
@@ -111,8 +111,7 @@ static int engine_list_remove(ENGINE *e)
     while (iterator &amp;&amp; (iterator != e))
         iterator = iterator-&gt;next;
     if (iterator == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_LIST_REMOVE,
-                  ENGINE_R_ENGINE_IS_NOT_IN_LIST);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_ENGINE_IS_NOT_IN_LIST);
         return 0;
     }
     /* un-link e from the chain. */
@@ -135,7 +134,7 @@ ENGINE *ENGINE_get_first(void)
     ENGINE *ret;
 
     if (!RUN_ONCE(&amp;engine_lock_init, do_engine_lock_init)) {
-        ENGINEerr(ENGINE_F_ENGINE_GET_FIRST, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -154,7 +153,7 @@ ENGINE *ENGINE_get_last(void)
     ENGINE *ret;
 
     if (!RUN_ONCE(&amp;engine_lock_init, do_engine_lock_init)) {
-        ENGINEerr(ENGINE_F_ENGINE_GET_LAST, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -173,7 +172,7 @@ ENGINE *ENGINE_get_next(ENGINE *e)
 {
     ENGINE *ret = NULL;
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_GET_NEXT, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     CRYPTO_THREAD_write_lock(global_engine_lock);
@@ -193,7 +192,7 @@ ENGINE *ENGINE_get_prev(ENGINE *e)
 {
     ENGINE *ret = NULL;
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_GET_PREV, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     CRYPTO_THREAD_write_lock(global_engine_lock);
@@ -214,16 +213,16 @@ int ENGINE_add(ENGINE *e)
 {
     int to_return = 1;
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_ADD, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if ((e-&gt;id == NULL) || (e-&gt;name == NULL)) {
-        ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_ID_OR_NAME_MISSING);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_ID_OR_NAME_MISSING);
         return 0;
     }
     CRYPTO_THREAD_write_lock(global_engine_lock);
     if (!engine_list_add(e)) {
-        ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_INTERNAL_LIST_ERROR);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INTERNAL_LIST_ERROR);
         to_return = 0;
     }
     CRYPTO_THREAD_unlock(global_engine_lock);
@@ -235,12 +234,12 @@ int ENGINE_remove(ENGINE *e)
 {
     int to_return = 1;
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_REMOVE, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     CRYPTO_THREAD_write_lock(global_engine_lock);
     if (!engine_list_remove(e)) {
-        ENGINEerr(ENGINE_F_ENGINE_REMOVE, ENGINE_R_INTERNAL_LIST_ERROR);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INTERNAL_LIST_ERROR);
         to_return = 0;
     }
     CRYPTO_THREAD_unlock(global_engine_lock);
@@ -282,13 +281,13 @@ ENGINE *ENGINE_by_id(const char *id)
     ENGINE *iterator;
     char *load_dir = NULL;
     if (id == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_BY_ID, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     ENGINE_load_builtin_engines();
 
     if (!RUN_ONCE(&amp;engine_lock_init, do_engine_lock_init)) {
-        ENGINEerr(ENGINE_F_ENGINE_BY_ID, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -336,8 +335,7 @@ ENGINE *ENGINE_by_id(const char *id)
     }
  notfound:
     ENGINE_free(iterator);
-    ENGINEerr(ENGINE_F_ENGINE_BY_ID, ENGINE_R_NO_SUCH_ENGINE);
-    ERR_add_error_data(2, &quot;id=&quot;, id);
+    ERR_raise_data(ERR_LIB_ENGINE, ENGINE_R_NO_SUCH_ENGINE, &quot;id=%s&quot;, id);
     return NULL;
     /* EEK! Experimental code ends */
 }
@@ -346,7 +344,7 @@ int ENGINE_up_ref(ENGINE *e)
 {
     int i;
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_UP_REF, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     CRYPTO_UP_REF(&amp;e-&gt;struct_ref, &amp;i, global_engine_lock);
diff --git a/crypto/engine/eng_openssl.c b/crypto/engine/eng_openssl.c
index a51ccf129f..4214ebdfda 100644
--- a/crypto/engine/eng_openssl.c
+++ b/crypto/engine/eng_openssl.c
@@ -453,7 +453,7 @@ static int ossl_hmac_init(EVP_PKEY_CTX *ctx)
     OSSL_HMAC_PKEY_CTX *hctx;
 
     if ((hctx = OPENSSL_zalloc(sizeof(*hctx))) == NULL) {
-        ENGINEerr(ENGINE_F_OSSL_HMAC_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     hctx-&gt;ktmp.type = V_ASN1_OCTET_STRING;
diff --git a/crypto/engine/eng_pkey.c b/crypto/engine/eng_pkey.c
index c94c2eacb3..9feb52d83b 100644
--- a/crypto/engine/eng_pkey.c
+++ b/crypto/engine/eng_pkey.c
@@ -59,26 +59,23 @@ EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,
     EVP_PKEY *pkey;
 
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,
-                  ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     CRYPTO_THREAD_write_lock(global_engine_lock);
     if (e-&gt;funct_ref == 0) {
         CRYPTO_THREAD_unlock(global_engine_lock);
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY, ENGINE_R_NOT_INITIALISED);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NOT_INITIALISED);
         return 0;
     }
     CRYPTO_THREAD_unlock(global_engine_lock);
     if (!e-&gt;load_privkey) {
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,
-                  ENGINE_R_NO_LOAD_FUNCTION);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NO_LOAD_FUNCTION);
         return 0;
     }
     pkey = e-&gt;load_privkey(e, key_id, ui_method, callback_data);
     if (pkey == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,
-                  ENGINE_R_FAILED_LOADING_PRIVATE_KEY);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_FAILED_LOADING_PRIVATE_KEY);
         return 0;
     }
     return pkey;
@@ -90,25 +87,23 @@ EVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,
     EVP_PKEY *pkey;
 
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY,
-                  ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     CRYPTO_THREAD_write_lock(global_engine_lock);
     if (e-&gt;funct_ref == 0) {
         CRYPTO_THREAD_unlock(global_engine_lock);
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY, ENGINE_R_NOT_INITIALISED);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NOT_INITIALISED);
         return 0;
     }
     CRYPTO_THREAD_unlock(global_engine_lock);
     if (!e-&gt;load_pubkey) {
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY, ENGINE_R_NO_LOAD_FUNCTION);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NO_LOAD_FUNCTION);
         return 0;
     }
     pkey = e-&gt;load_pubkey(e, key_id, ui_method, callback_data);
     if (pkey == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY,
-                  ENGINE_R_FAILED_LOADING_PUBLIC_KEY);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_FAILED_LOADING_PUBLIC_KEY);
         return 0;
     }
     return pkey;
@@ -121,21 +116,18 @@ int ENGINE_load_ssl_client_cert(ENGINE *e, SSL *s,
 {
 
     if (e == NULL) {
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT,
-                  ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     CRYPTO_THREAD_write_lock(global_engine_lock);
     if (e-&gt;funct_ref == 0) {
         CRYPTO_THREAD_unlock(global_engine_lock);
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT,
-                  ENGINE_R_NOT_INITIALISED);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NOT_INITIALISED);
         return 0;
     }
     CRYPTO_THREAD_unlock(global_engine_lock);
     if (!e-&gt;load_ssl_client_cert) {
-        ENGINEerr(ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT,
-                  ENGINE_R_NO_LOAD_FUNCTION);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_NO_LOAD_FUNCTION);
         return 0;
     }
     return e-&gt;load_ssl_client_cert(e, s, ca_dn, pcert, ppkey, pother,
diff --git a/crypto/engine/eng_table.c b/crypto/engine/eng_table.c
index dc85cdf526..ebaac35470 100644
--- a/crypto/engine/eng_table.c
+++ b/crypto/engine/eng_table.c
@@ -127,8 +127,7 @@ int engine_table_register(ENGINE_TABLE **table, ENGINE_CLEANUP_CB *cleanup,
         fnd-&gt;uptodate = 0;
         if (setdefault) {
             if (!engine_unlocked_init(e)) {
-                ENGINEerr(ENGINE_F_ENGINE_TABLE_REGISTER,
-                          ENGINE_R_INIT_FAILED);
+                ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INIT_FAILED);
                 goto end;
             }
             if (fnd-&gt;funct)
diff --git a/crypto/engine/tb_asnmth.c b/crypto/engine/tb_asnmth.c
index 018b331647..d1465227b9 100644
--- a/crypto/engine/tb_asnmth.c
+++ b/crypto/engine/tb_asnmth.c
@@ -88,8 +88,7 @@ const EVP_PKEY_ASN1_METHOD *ENGINE_get_pkey_asn1_meth(ENGINE *e, int nid)
     EVP_PKEY_ASN1_METHOD *ret;
     ENGINE_PKEY_ASN1_METHS_PTR fn = ENGINE_get_pkey_asn1_meths(e);
     if (!fn || !fn(e, &amp;ret, NULL, nid)) {
-        ENGINEerr(ENGINE_F_ENGINE_GET_PKEY_ASN1_METH,
-                  ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD);
         return NULL;
     }
     return ret;
@@ -196,7 +195,7 @@ const EVP_PKEY_ASN1_METHOD *ENGINE_pkey_asn1_find_str(ENGINE **pe,
     fstr.len = len;
 
     if (!RUN_ONCE(&amp;engine_lock_init, do_engine_lock_init)) {
-        ENGINEerr(ENGINE_F_ENGINE_PKEY_ASN1_FIND_STR, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ENGINE, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/engine/tb_cipher.c b/crypto/engine/tb_cipher.c
index 3940978d82..cb17508ac8 100644
--- a/crypto/engine/tb_cipher.c
+++ b/crypto/engine/tb_cipher.c
@@ -74,7 +74,7 @@ const EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid)
     const EVP_CIPHER *ret;
     ENGINE_CIPHERS_PTR fn = ENGINE_get_ciphers(e);
     if (!fn || !fn(e, &amp;ret, NULL, nid)) {
-        ENGINEerr(ENGINE_F_ENGINE_GET_CIPHER, ENGINE_R_UNIMPLEMENTED_CIPHER);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_UNIMPLEMENTED_CIPHER);
         return NULL;
     }
     return ret;
diff --git a/crypto/engine/tb_digest.c b/crypto/engine/tb_digest.c
index 63fe055bbd..6b1cc05ab4 100644
--- a/crypto/engine/tb_digest.c
+++ b/crypto/engine/tb_digest.c
@@ -74,7 +74,7 @@ const EVP_MD *ENGINE_get_digest(ENGINE *e, int nid)
     const EVP_MD *ret;
     ENGINE_DIGESTS_PTR fn = ENGINE_get_digests(e);
     if (!fn || !fn(e, &amp;ret, NULL, nid)) {
-        ENGINEerr(ENGINE_F_ENGINE_GET_DIGEST, ENGINE_R_UNIMPLEMENTED_DIGEST);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_UNIMPLEMENTED_DIGEST);
         return NULL;
     }
     return ret;
diff --git a/crypto/engine/tb_pkmeth.c b/crypto/engine/tb_pkmeth.c
index 267640ae9b..ad7f2d764f 100644
--- a/crypto/engine/tb_pkmeth.c
+++ b/crypto/engine/tb_pkmeth.c
@@ -75,8 +75,7 @@ const EVP_PKEY_METHOD *ENGINE_get_pkey_meth(ENGINE *e, int nid)
     EVP_PKEY_METHOD *ret;
     ENGINE_PKEY_METHS_PTR fn = ENGINE_get_pkey_meths(e);
     if (!fn || !fn(e, &amp;ret, NULL, nid)) {
-        ENGINEerr(ENGINE_F_ENGINE_GET_PKEY_METH,
-                  ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD);
+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD);
         return NULL;
     }
     return ret;
diff --git a/crypto/ess/ess_lib.c b/crypto/ess/ess_lib.c
index 325acddb95..1301c9ed85 100644
--- a/crypto/ess/ess_lib.c
+++ b/crypto/ess/ess_lib.c
@@ -46,7 +46,7 @@ ESS_SIGNING_CERT *ESS_SIGNING_CERT_new_init(X509 *signcert,
  err:
     ESS_SIGNING_CERT_free(sc);
     ESS_CERT_ID_free(cid);
-    ESSerr(ESS_F_ESS_SIGNING_CERT_NEW_INIT, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ESS, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -92,7 +92,7 @@ static ESS_CERT_ID *ESS_CERT_ID_new_init(X509 *cert, int issuer_needed)
  err:
     GENERAL_NAME_free(name);
     ESS_CERT_ID_free(cid);
-    ESSerr(ESS_F_ESS_CERT_ID_NEW_INIT, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ESS, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -127,7 +127,7 @@ ESS_SIGNING_CERT_V2 *ESS_SIGNING_CERT_V2_new_init(const EVP_MD *hash_alg,
  err:
     ESS_SIGNING_CERT_V2_free(sc);
     ESS_CERT_ID_V2_free(cid);
-    ESSerr(ESS_F_ESS_SIGNING_CERT_V2_NEW_INIT, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ESS, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -188,7 +188,7 @@ static ESS_CERT_ID_V2 *ESS_CERT_ID_V2_new_init(const EVP_MD *hash_alg,
     X509_ALGOR_free(alg);
     GENERAL_NAME_free(name);
     ESS_CERT_ID_V2_free(cid);
-    ESSerr(ESS_F_ESS_CERT_ID_V2_NEW_INIT, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ESS, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -224,13 +224,13 @@ int ESS_SIGNING_CERT_add(PKCS7_SIGNER_INFO *si, ESS_SIGNING_CERT *sc)
 
     len = i2d_ESS_SIGNING_CERT(sc, NULL);
     if ((pp = OPENSSL_malloc(len)) == NULL) {
-        ESSerr(ESS_F_ESS_SIGNING_CERT_ADD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ESS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     p = pp;
     i2d_ESS_SIGNING_CERT(sc, &amp;p);
     if ((seq = ASN1_STRING_new()) == NULL || !ASN1_STRING_set(seq, pp, len)) {
-        ESSerr(ESS_F_ESS_SIGNING_CERT_ADD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ESS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     OPENSSL_free(pp);
@@ -253,14 +253,14 @@ int ESS_SIGNING_CERT_V2_add(PKCS7_SIGNER_INFO *si,
     int len = i2d_ESS_SIGNING_CERT_V2(sc, NULL);
 
     if ((pp = OPENSSL_malloc(len)) == NULL) {
-        ESSerr(ESS_F_ESS_SIGNING_CERT_V2_ADD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ESS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     p = pp;
     i2d_ESS_SIGNING_CERT_V2(sc, &amp;p);
     if ((seq = ASN1_STRING_new()) == NULL || !ASN1_STRING_set(seq, pp, len)) {
-        ESSerr(ESS_F_ESS_SIGNING_CERT_V2_ADD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ESS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
diff --git a/crypto/evp/asymcipher.c b/crypto/evp/asymcipher.c
index 0c767179e6..6ff49a0526 100644
--- a/crypto/evp/asymcipher.c
+++ b/crypto/evp/asymcipher.c
@@ -25,7 +25,7 @@ static int evp_pkey_asym_cipher_init(EVP_PKEY_CTX *ctx, int operation)
     const char *supported_ciph = NULL;
 
     if (ctx == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
@@ -100,14 +100,14 @@ static int evp_pkey_asym_cipher_init(EVP_PKEY_CTX *ctx, int operation)
     ctx-&gt;op.ciph.ciphprovctx = cipher-&gt;newctx(ossl_provider_ctx(cipher-&gt;prov));
     if (ctx-&gt;op.ciph.ciphprovctx == NULL) {
         /* The provider key can stay in the cache */
-        EVPerr(0, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         goto err;
     }
 
     switch (operation) {
     case EVP_PKEY_OP_ENCRYPT:
         if (cipher-&gt;encrypt_init == NULL) {
-            EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+            ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             ret = -2;
             goto err;
         }
@@ -115,14 +115,14 @@ static int evp_pkey_asym_cipher_init(EVP_PKEY_CTX *ctx, int operation)
         break;
     case EVP_PKEY_OP_DECRYPT:
         if (cipher-&gt;decrypt_init == NULL) {
-            EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+            ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             ret = -2;
             goto err;
         }
         ret = cipher-&gt;decrypt_init(ctx-&gt;op.ciph.ciphprovctx, provkey);
         break;
     default:
-        EVPerr(0, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         goto err;
     }
 
@@ -139,7 +139,7 @@ static int evp_pkey_asym_cipher_init(EVP_PKEY_CTX *ctx, int operation)
     ERR_pop_to_mark();
 
     if (ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;encrypt == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
     switch(ctx-&gt;operation) {
@@ -154,7 +154,7 @@ static int evp_pkey_asym_cipher_init(EVP_PKEY_CTX *ctx, int operation)
         ret = ctx-&gt;pmeth-&gt;decrypt_init(ctx);
         break;
     default:
-        EVPerr(0, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         ret = -1;
     }
 
@@ -178,12 +178,12 @@ int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,
     int ret;
 
     if (ctx == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
     if (ctx-&gt;operation != EVP_PKEY_OP_ENCRYPT) {
-        EVPerr(0, EVP_R_OPERATON_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
         return -1;
     }
 
@@ -196,8 +196,7 @@ int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,
 
  legacy:
     if (ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;encrypt == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_ENCRYPT,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
     M_check_autoarg(ctx, out, outlen, EVP_F_EVP_PKEY_ENCRYPT)
@@ -216,12 +215,12 @@ int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,
     int ret;
 
     if (ctx == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
     if (ctx-&gt;operation != EVP_PKEY_OP_DECRYPT) {
-        EVPerr(0, EVP_R_OPERATON_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
         return -1;
     }
 
@@ -234,8 +233,7 @@ int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,
 
  legacy:
     if (ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;decrypt == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_DECRYPT,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
     M_check_autoarg(ctx, out, outlen, EVP_F_EVP_PKEY_DECRYPT)
diff --git a/crypto/evp/bio_b64.c b/crypto/evp/bio_b64.c
index e13d119623..e21661d5a4 100644
--- a/crypto/evp/bio_b64.c
+++ b/crypto/evp/bio_b64.c
@@ -71,7 +71,7 @@ static int b64_new(BIO *bi)
     BIO_B64_CTX *ctx;
 
     if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL) {
-        EVPerr(EVP_F_B64_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/evp/bio_enc.c b/crypto/evp/bio_enc.c
index 046e5c0ca8..df669245f3 100644
--- a/crypto/evp/bio_enc.c
+++ b/crypto/evp/bio_enc.c
@@ -66,7 +66,7 @@ static int enc_new(BIO *bi)
     BIO_ENC_CTX *ctx;
 
     if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL) {
-        EVPerr(EVP_F_ENC_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/evp/bio_ok.c b/crypto/evp/bio_ok.c
index b6f85a1b92..f2d66ab129 100644
--- a/crypto/evp/bio_ok.c
+++ b/crypto/evp/bio_ok.c
@@ -135,7 +135,7 @@ static int ok_new(BIO *bi)
     BIO_OK_CTX *ctx;
 
     if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL) {
-        EVPerr(EVP_F_OK_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
index 281749558d..3872bb68fb 100644
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -90,13 +90,13 @@ EVP_MD_CTX *evp_md_ctx_new_ex(EVP_PKEY *pkey, const ASN1_OCTET_STRING *id,
 
     if ((ctx = EVP_MD_CTX_new()) == NULL
         || (pctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq)) == NULL) {
-        ASN1err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
 # ifndef OPENSSL_NO_EC
     if (id != NULL &amp;&amp; EVP_PKEY_CTX_set1_id(pctx, id-&gt;data, id-&gt;length) &lt;= 0) {
-        ASN1err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 # endif
@@ -153,7 +153,7 @@ int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
             return EVP_DigestSignInit(ctx, NULL, type, impl, NULL);
         if (ctx-&gt;pctx-&gt;operation == EVP_PKEY_OP_VERIFYCTX)
             return EVP_DigestVerifyInit(ctx, NULL, type, impl, NULL);
-        EVPerr(0, EVP_R_UPDATE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UPDATE_ERROR);
         return 0;
     }
 #endif
@@ -162,7 +162,7 @@ int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
 
     if (ctx-&gt;provctx != NULL) {
         if (!ossl_assert(ctx-&gt;digest != NULL)) {
-            EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
             return 0;
         }
         if (ctx-&gt;digest-&gt;freectx != NULL)
@@ -226,7 +226,7 @@ int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
     if (type-&gt;prov == NULL) {
 #ifdef FIPS_MODULE
         /* We only do explicit fetches inside the FIPS module */
-        EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         return 0;
 #else
         EVP_MD *provmd = EVP_MD_fetch(NULL, OBJ_nid2sn(type-&gt;type), &quot;&quot;);
@@ -248,13 +248,13 @@ int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
     if (ctx-&gt;provctx == NULL) {
         ctx-&gt;provctx = ctx-&gt;digest-&gt;newctx(ossl_provider_ctx(type-&gt;prov));
         if (ctx-&gt;provctx == NULL) {
-            EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
             return 0;
         }
     }
 
     if (ctx-&gt;digest-&gt;dinit == NULL) {
-        EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         return 0;
     }
 
@@ -267,7 +267,7 @@ int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
     if (type) {
         if (impl != NULL) {
             if (!ENGINE_init(impl)) {
-                EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);
+                ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
                 return 0;
             }
         } else {
@@ -279,7 +279,7 @@ int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
             const EVP_MD *d = ENGINE_get_digest(impl, type-&gt;type);
 
             if (d == NULL) {
-                EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);
+                ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
                 ENGINE_finish(impl);
                 return 0;
             }
@@ -294,7 +294,7 @@ int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
             ctx-&gt;engine = NULL;
     } else {
         if (!ctx-&gt;digest) {
-            EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_NO_DIGEST_SET);
+            ERR_raise(ERR_LIB_EVP, EVP_R_NO_DIGEST_SET);
             return 0;
         }
         type = ctx-&gt;digest;
@@ -310,7 +310,7 @@ int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
             ctx-&gt;update = type-&gt;update;
             ctx-&gt;md_data = OPENSSL_zalloc(type-&gt;ctx_size);
             if (ctx-&gt;md_data == NULL) {
-                EVPerr(EVP_F_EVP_DIGESTINIT_EX, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
         }
@@ -358,7 +358,7 @@ int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *data, size_t count)
             return EVP_DigestSignUpdate(ctx, data, count);
         if (ctx-&gt;pctx-&gt;operation == EVP_PKEY_OP_VERIFYCTX)
             return EVP_DigestVerifyUpdate(ctx, data, count);
-        EVPerr(EVP_F_EVP_DIGESTUPDATE, EVP_R_UPDATE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UPDATE_ERROR);
         return 0;
     }
 
@@ -368,7 +368,7 @@ int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *data, size_t count)
         goto legacy;
 
     if (ctx-&gt;digest-&gt;dupdate == NULL) {
-        EVPerr(EVP_F_EVP_DIGESTUPDATE, EVP_R_UPDATE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UPDATE_ERROR);
         return 0;
     }
     return ctx-&gt;digest-&gt;dupdate(ctx-&gt;provctx, data, count);
@@ -405,7 +405,7 @@ int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *isize)
         goto legacy;
 
     if (ctx-&gt;digest-&gt;dfinal == NULL) {
-        EVPerr(EVP_F_EVP_DIGESTFINAL_EX, EVP_R_FINAL_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_FINAL_ERROR);
         return 0;
     }
 
@@ -415,7 +415,7 @@ int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *isize)
         if (size &lt;= UINT_MAX) {
             *isize = (int)size;
         } else {
-            EVPerr(EVP_F_EVP_DIGESTFINAL_EX, EVP_R_FINAL_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_FINAL_ERROR);
             ret = 0;
         }
     }
@@ -446,7 +446,7 @@ int EVP_DigestFinalXOF(EVP_MD_CTX *ctx, unsigned char *md, size_t size)
         goto legacy;
 
     if (ctx-&gt;digest-&gt;dfinal == NULL) {
-        EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_FINAL_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_FINAL_ERROR);
         return 0;
     }
 
@@ -469,7 +469,7 @@ legacy:
         }
         OPENSSL_cleanse(ctx-&gt;md_data, ctx-&gt;digest-&gt;ctx_size);
     } else {
-        EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
     }
 
     return ret;
@@ -486,7 +486,7 @@ int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
     unsigned char *tmp_buf;
 
     if (in == NULL || in-&gt;digest == NULL) {
-        EVPerr(EVP_F_EVP_MD_CTX_COPY_EX, EVP_R_INPUT_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INPUT_NOT_INITIALIZED);
         return 0;
     }
 
@@ -495,7 +495,7 @@ int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
         goto legacy;
 
     if (in-&gt;digest-&gt;dupctx == NULL) {
-        EVPerr(EVP_F_EVP_MD_CTX_COPY_EX, EVP_R_NOT_ABLE_TO_COPY_CTX);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NOT_ABLE_TO_COPY_CTX);
         return 0;
     }
 
@@ -513,7 +513,7 @@ int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
     if (in-&gt;provctx != NULL) {
         out-&gt;provctx = in-&gt;digest-&gt;dupctx(in-&gt;provctx);
         if (out-&gt;provctx == NULL) {
-            EVPerr(EVP_F_EVP_MD_CTX_COPY_EX, EVP_R_NOT_ABLE_TO_COPY_CTX);
+            ERR_raise(ERR_LIB_EVP, EVP_R_NOT_ABLE_TO_COPY_CTX);
             return 0;
         }
     }
@@ -525,7 +525,7 @@ int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
     if (in-&gt;pctx != NULL) {
         out-&gt;pctx = EVP_PKEY_CTX_dup(in-&gt;pctx);
         if (out-&gt;pctx == NULL) {
-            EVPerr(EVP_F_EVP_MD_CTX_COPY_EX, EVP_R_NOT_ABLE_TO_COPY_CTX);
+            ERR_raise(ERR_LIB_EVP, EVP_R_NOT_ABLE_TO_COPY_CTX);
             EVP_MD_CTX_reset(out);
             return 0;
         }
@@ -539,7 +539,7 @@ int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
 #if !defined(OPENSSL_NO_ENGINE) &amp;&amp; !defined(FIPS_MODULE)
     /* Make sure it's safe to copy a digest context using an ENGINE */
     if (in-&gt;engine &amp;&amp; !ENGINE_init(in-&gt;engine)) {
-        EVPerr(EVP_F_EVP_MD_CTX_COPY_EX, ERR_R_ENGINE_LIB);
+        ERR_raise(ERR_LIB_EVP, ERR_R_ENGINE_LIB);
         return 0;
     }
 #endif
@@ -568,7 +568,7 @@ int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
         else {
             out-&gt;md_data = OPENSSL_malloc(out-&gt;digest-&gt;ctx_size);
             if (out-&gt;md_data == NULL) {
-                EVPerr(EVP_F_EVP_MD_CTX_COPY_EX, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
         }
@@ -839,7 +839,7 @@ static void *evp_md_from_dispatch(int name_id,
 
     /* EVP_MD_fetch() will set the legacy NID if available */
     if ((md = evp_md_new()) == NULL) {
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/evp/e_aes.c b/crypto/evp/e_aes.c
index 96ee5d1403..d812b2ade8 100644
--- a/crypto/evp/e_aes.c
+++ b/crypto/evp/e_aes.c
@@ -168,7 +168,7 @@ static int aesni_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     }
 
     if (ret &lt; 0) {
-        EVPerr(EVP_F_AESNI_INIT_KEY, EVP_R_AES_KEY_SETUP_FAILED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_AES_KEY_SETUP_FAILED);
         return 0;
     }
 
@@ -276,7 +276,7 @@ static int aesni_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
          */
         if ((!allow_insecure_decrypt || enc)
                 &amp;&amp; CRYPTO_memcmp(key, key + bytes, bytes) == 0) {
-            EVPerr(EVP_F_AESNI_XTS_INIT_KEY, EVP_R_XTS_DUPLICATED_KEYS);
+            ERR_raise(ERR_LIB_EVP, EVP_R_XTS_DUPLICATED_KEYS);
             return 0;
         }
 
@@ -502,7 +502,7 @@ static int aes_t4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     }
 
     if (ret &lt; 0) {
-        EVPerr(EVP_F_AES_T4_INIT_KEY, EVP_R_AES_KEY_SETUP_FAILED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_AES_KEY_SETUP_FAILED);
         return 0;
     }
 
@@ -608,7 +608,7 @@ static int aes_t4_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
          */
         if ((!allow_insecure_decrypt || enc)
                 &amp;&amp; CRYPTO_memcmp(key, key + bytes, bytes) == 0) {
-            EVPerr(EVP_F_AES_T4_XTS_INIT_KEY, EVP_R_XTS_DUPLICATED_KEYS);
+            ERR_raise(ERR_LIB_EVP, EVP_R_XTS_DUPLICATED_KEYS);
             return 0;
         }
 
@@ -1364,7 +1364,7 @@ static int s390x_aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
                     OPENSSL_free(gctx-&gt;iv);
 
                 if ((gctx-&gt;iv = OPENSSL_malloc(len)) == NULL) {
-                    EVPerr(EVP_F_S390X_AES_GCM_CTRL, ERR_R_MALLOC_FAILURE);
+                    ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
                     return 0;
                 }
             }
@@ -1483,7 +1483,7 @@ static int s390x_aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
             len = S390X_gcm_ivpadlen(gctx-&gt;ivlen);
 
             if ((gctx_out-&gt;iv = OPENSSL_malloc(len)) == NULL) {
-                EVPerr(EVP_F_S390X_AES_GCM_CTRL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
 
@@ -1559,7 +1559,7 @@ static int s390x_aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
      * side only.
      */
     if (ctx-&gt;encrypt &amp;&amp; ++gctx-&gt;tls_enc_records == 0) {
-        EVPerr(EVP_F_S390X_AES_GCM_TLS_CIPHER, EVP_R_TOO_MANY_RECORDS);
+        ERR_raise(ERR_LIB_EVP, EVP_R_TOO_MANY_RECORDS);
         goto err;
     }
 
@@ -2380,7 +2380,7 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     }
 
     if (ret &lt; 0) {
-        EVPerr(EVP_F_AES_INIT_KEY, EVP_R_AES_KEY_SETUP_FAILED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_AES_KEY_SETUP_FAILED);
         return 0;
     }
 
@@ -2555,7 +2555,7 @@ static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
             if (gctx-&gt;iv != c-&gt;iv)
                 OPENSSL_free(gctx-&gt;iv);
             if ((gctx-&gt;iv = OPENSSL_malloc(arg)) == NULL) {
-                EVPerr(EVP_F_AES_GCM_CTRL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
         }
@@ -2657,7 +2657,7 @@ static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
                 gctx_out-&gt;iv = out-&gt;iv;
             else {
                 if ((gctx_out-&gt;iv = OPENSSL_malloc(gctx-&gt;ivlen)) == NULL) {
-                    EVPerr(EVP_F_AES_GCM_CTRL, ERR_R_MALLOC_FAILURE);
+                    ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
                     return 0;
                 }
                 memcpy(gctx_out-&gt;iv, gctx-&gt;iv, gctx-&gt;ivlen);
@@ -2768,7 +2768,7 @@ static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
      * side only.
      */
     if (ctx-&gt;encrypt &amp;&amp; ++gctx-&gt;tls_enc_records == 0) {
-        EVPerr(EVP_F_AES_GCM_TLS_CIPHER, EVP_R_TOO_MANY_RECORDS);
+        ERR_raise(ERR_LIB_EVP, EVP_R_TOO_MANY_RECORDS);
         goto err;
     }
 
@@ -3119,7 +3119,7 @@ static int aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
              */
             if ((!allow_insecure_decrypt || enc)
                     &amp;&amp; CRYPTO_memcmp(key, key + bytes, bytes) == 0) {
-                EVPerr(EVP_F_AES_XTS_INIT_KEY, EVP_R_XTS_DUPLICATED_KEYS);
+                ERR_raise(ERR_LIB_EVP, EVP_R_XTS_DUPLICATED_KEYS);
                 return 0;
             }
 
@@ -3218,7 +3218,7 @@ static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
      * NIST SP 800-38E mandates the same limit.
      */
     if (len &gt; XTS_MAX_BLOCKS_PER_DATA_UNIT * AES_BLOCK_SIZE) {
-        EVPerr(EVP_F_AES_XTS_CIPHER, EVP_R_XTS_DATA_UNIT_IS_TOO_LARGE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_XTS_DATA_UNIT_IS_TOO_LARGE);
         return 0;
     }
 
@@ -3568,7 +3568,7 @@ static int aes_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     if (!pad &amp;&amp; inlen &amp; 0x7)
         return -1;
     if (is_partially_overlapping(out, in, inlen)) {
-        EVPerr(EVP_F_AES_WRAP_CIPHER, EVP_R_PARTIALLY_OVERLAPPING);
+        ERR_raise(ERR_LIB_EVP, EVP_R_PARTIALLY_OVERLAPPING);
         return 0;
     }
     if (!out) {
@@ -3872,7 +3872,7 @@ static int aes_ocb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             buf_len = &amp;(octx-&gt;data_buf_len);
 
             if (is_partially_overlapping(out + *buf_len, in, len)) {
-                EVPerr(EVP_F_AES_OCB_CIPHER, EVP_R_PARTIALLY_OVERLAPPING);
+                ERR_raise(ERR_LIB_EVP, EVP_R_PARTIALLY_OVERLAPPING);
                 return 0;
             }
         }
diff --git a/crypto/evp/e_aria.c b/crypto/evp/e_aria.c
index 9f3a909122..7f937d98d8 100644
--- a/crypto/evp/e_aria.c
+++ b/crypto/evp/e_aria.c
@@ -69,7 +69,7 @@ static int aria_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         ret = aria_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                         EVP_CIPHER_CTX_get_cipher_data(ctx));
     if (ret &lt; 0) {
-        EVPerr(EVP_F_ARIA_INIT_KEY,EVP_R_ARIA_KEY_SETUP_FAILED);
+        ERR_raise(ERR_LIB_EVP,EVP_R_ARIA_KEY_SETUP_FAILED);
         return 0;
     }
     return 1;
@@ -216,7 +216,7 @@ static int aria_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         CRYPTO_gcm128_init(&amp;gctx-&gt;gcm, &amp;gctx-&gt;ks,
                            (block128_f) aria_encrypt);
         if (ret &lt; 0) {
-            EVPerr(EVP_F_ARIA_GCM_INIT_KEY,EVP_R_ARIA_KEY_SETUP_FAILED);
+            ERR_raise(ERR_LIB_EVP,EVP_R_ARIA_KEY_SETUP_FAILED);
             return 0;
         }
 
@@ -269,7 +269,7 @@ static int aria_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
             if (gctx-&gt;iv != c-&gt;iv)
                 OPENSSL_free(gctx-&gt;iv);
             if ((gctx-&gt;iv = OPENSSL_malloc(arg)) == NULL) {
-                EVPerr(EVP_F_ARIA_GCM_CTRL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
         }
@@ -374,7 +374,7 @@ static int aria_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
                 gctx_out-&gt;iv = out-&gt;iv;
             else {
                 if ((gctx_out-&gt;iv = OPENSSL_malloc(gctx-&gt;ivlen)) == NULL) {
-                    EVPerr(EVP_F_ARIA_GCM_CTRL, ERR_R_MALLOC_FAILURE);
+                    ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
                     return 0;
                 }
                 memcpy(gctx_out-&gt;iv, gctx-&gt;iv, gctx-&gt;ivlen);
@@ -513,7 +513,7 @@ static int aria_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         CRYPTO_ccm128_init(&amp;cctx-&gt;ccm, cctx-&gt;M, cctx-&gt;L,
                            &amp;cctx-&gt;ks, (block128_f) aria_encrypt);
         if (ret &lt; 0) {
-            EVPerr(EVP_F_ARIA_CCM_INIT_KEY,EVP_R_ARIA_KEY_SETUP_FAILED);
+            ERR_raise(ERR_LIB_EVP,EVP_R_ARIA_KEY_SETUP_FAILED);
             return 0;
         }
         cctx-&gt;str = NULL;
diff --git a/crypto/evp/e_camellia.c b/crypto/evp/e_camellia.c
index 79ac163e3a..0d338b8b2f 100644
--- a/crypto/evp/e_camellia.c
+++ b/crypto/evp/e_camellia.c
@@ -105,7 +105,7 @@ static int cmll_t4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     }
 
     if (ret &lt; 0) {
-        EVPerr(EVP_F_CMLL_T4_INIT_KEY, EVP_R_CAMELLIA_KEY_SETUP_FAILED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_CAMELLIA_KEY_SETUP_FAILED);
         return 0;
     }
 
@@ -195,7 +195,7 @@ static int camellia_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 
     ret = Camellia_set_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &amp;dat-&gt;ks);
     if (ret &lt; 0) {
-        EVPerr(EVP_F_CAMELLIA_INIT_KEY, EVP_R_CAMELLIA_KEY_SETUP_FAILED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_CAMELLIA_KEY_SETUP_FAILED);
         return 0;
     }
 
diff --git a/crypto/evp/e_chacha20_poly1305.c b/crypto/evp/e_chacha20_poly1305.c
index 0c7c7dbe40..8c69b3a736 100644
--- a/crypto/evp/e_chacha20_poly1305.c
+++ b/crypto/evp/e_chacha20_poly1305.c
@@ -503,7 +503,7 @@ static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
             actx = ctx-&gt;cipher_data
                  = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());
         if (actx == NULL) {
-            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
             return 0;
         }
         actx-&gt;len.aad = 0;
@@ -523,7 +523,7 @@ static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
             dst-&gt;cipher_data =
                    OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());
             if (dst-&gt;cipher_data == NULL) {
-                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);
+                ERR_raise(ERR_LIB_EVP, EVP_R_COPY_ERROR);
                 return 0;
             }
         }
diff --git a/crypto/evp/e_des3.c b/crypto/evp/e_des3.c
index be4030895a..9d143d3bd5 100644
--- a/crypto/evp/e_des3.c
+++ b/crypto/evp/e_des3.c
@@ -398,7 +398,7 @@ static int des_ede3_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         return -1;
 
     if (is_partially_overlapping(out, in, inl)) {
-        EVPerr(EVP_F_DES_EDE3_WRAP_CIPHER, EVP_R_PARTIALLY_OVERLAPPING);
+        ERR_raise(ERR_LIB_EVP, EVP_R_PARTIALLY_OVERLAPPING);
         return 0;
     }
 
diff --git a/crypto/evp/e_rc2.c b/crypto/evp/e_rc2.c
index a8fb18e72d..790b816345 100644
--- a/crypto/evp/e_rc2.c
+++ b/crypto/evp/e_rc2.c
@@ -120,7 +120,7 @@ static int rc2_magic_to_meth(int i)
     else if (i == RC2_40_MAGIC)
         return 40;
     else {
-        EVPerr(EVP_F_RC2_MAGIC_TO_METH, EVP_R_UNSUPPORTED_KEY_SIZE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_KEY_SIZE);
         return 0;
     }
 }
diff --git a/crypto/evp/e_rc5.c b/crypto/evp/e_rc5.c
index 40691d425c..aa5e9020de 100644
--- a/crypto/evp/e_rc5.c
+++ b/crypto/evp/e_rc5.c
@@ -60,7 +60,7 @@ static int rc5_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
             return 1;
 
         default:
-            EVPerr(EVP_F_RC5_CTRL, EVP_R_UNSUPPORTED_NUMBER_OF_ROUNDS);
+            ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_NUMBER_OF_ROUNDS);
             return 0;
         }
 
@@ -73,7 +73,7 @@ static int r_32_12_16_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                                const unsigned char *iv, int enc)
 {
     if (EVP_CIPHER_CTX_key_length(ctx) &gt; 255) {
-        EVPerr(EVP_F_R_32_12_16_INIT_KEY, EVP_R_BAD_KEY_LENGTH);
+        ERR_raise(ERR_LIB_EVP, EVP_R_BAD_KEY_LENGTH);
         return 0;
     }
     return RC5_32_set_key(&amp;data(ctx)-&gt;ks, EVP_CIPHER_CTX_key_length(ctx),
diff --git a/crypto/evp/evp_cnf.c b/crypto/evp/evp_cnf.c
index b6f33795a1..7c2301d26c 100644
--- a/crypto/evp/evp_cnf.c
+++ b/crypto/evp/evp_cnf.c
@@ -30,7 +30,7 @@ static int alg_module_init(CONF_IMODULE *md, const CONF *cnf)
 
     oid_section = CONF_imodule_get_value(md);
     if ((sktmp = NCONF_get_section(cnf, oid_section)) == NULL) {
-        EVPerr(EVP_F_ALG_MODULE_INIT, EVP_R_ERROR_LOADING_SECTION);
+        ERR_raise(ERR_LIB_EVP, EVP_R_ERROR_LOADING_SECTION);
         return 0;
     }
     for (i = 0; i &lt; sk_CONF_VALUE_num(sktmp); i++) {
@@ -39,7 +39,7 @@ static int alg_module_init(CONF_IMODULE *md, const CONF *cnf)
             int m;
 
             if (!X509V3_get_value_bool(oval, &amp;m)) {
-                EVPerr(EVP_F_ALG_MODULE_INIT, EVP_R_INVALID_FIPS_MODE);
+                ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_FIPS_MODE);
                 return 0;
             }
             /*
@@ -47,18 +47,17 @@ static int alg_module_init(CONF_IMODULE *md, const CONF *cnf)
              * configurations.
              */
             if (!EVP_default_properties_enable_fips(cnf-&gt;libctx, m &gt; 0)) {
-                EVPerr(EVP_F_ALG_MODULE_INIT, EVP_R_SET_DEFAULT_PROPERTY_FAILURE);
+                ERR_raise(ERR_LIB_EVP, EVP_R_SET_DEFAULT_PROPERTY_FAILURE);
                 return 0;
             }
         } else if (strcmp(oval-&gt;name, &quot;default_properties&quot;) == 0) {
             if (!evp_set_default_properties_int(cnf-&gt;libctx, oval-&gt;value, 0)) {
-                EVPerr(EVP_F_ALG_MODULE_INIT, EVP_R_SET_DEFAULT_PROPERTY_FAILURE);
+                ERR_raise(ERR_LIB_EVP, EVP_R_SET_DEFAULT_PROPERTY_FAILURE);
                 return 0;
             }
         } else {
-            EVPerr(EVP_F_ALG_MODULE_INIT, EVP_R_UNKNOWN_OPTION);
-            ERR_add_error_data(4, &quot;name=&quot;, oval-&gt;name,
-                               &quot;, value=&quot;, oval-&gt;value);
+            ERR_raise_data(ERR_LIB_EVP, EVP_R_UNKNOWN_OPTION,
+                           &quot;name=%s, value=%s&quot;, oval-&gt;name, oval-&gt;value);
             return 0;
         }
 
diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
index d8fc3ab7ad..f439e8d61d 100644
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -100,7 +100,7 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
     }
 
     if (cipher == NULL &amp;&amp; ctx-&gt;cipher == NULL) {
-        EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_NO_CIPHER_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_CIPHER_SET);
         return 0;
     }
 
@@ -165,7 +165,7 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
     if (cipher-&gt;prov == NULL) {
 #ifdef FIPS_MODULE
         /* We only do explicit fetches inside the FIPS module */
-        EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         return 0;
 #else
         EVP_CIPHER *provciph =
@@ -186,7 +186,7 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
     if (ctx-&gt;provctx == NULL) {
         ctx-&gt;provctx = ctx-&gt;cipher-&gt;newctx(ossl_provider_ctx(cipher-&gt;prov));
         if (ctx-&gt;provctx == NULL) {
-            EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
             return 0;
         }
     }
@@ -202,7 +202,7 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
 
     if (enc) {
         if (ctx-&gt;cipher-&gt;einit == NULL) {
-            EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
             return 0;
         }
 
@@ -216,7 +216,7 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
     }
 
     if (ctx-&gt;cipher-&gt;dinit == NULL) {
-        EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         return 0;
     }
 
@@ -247,7 +247,7 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
 #if !defined(OPENSSL_NO_ENGINE) &amp;&amp; !defined(FIPS_MODULE)
         if (impl != NULL) {
             if (!ENGINE_init(impl)) {
-                EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+                ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
                 return 0;
             }
         } else {
@@ -263,7 +263,7 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                  * is that we should at least be able to avoid using US
                  * misspellings of &quot;initialisation&quot;?
                  */
-                EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+                ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
                 return 0;
             }
             /* We'll use the ENGINE's private cipher definition */
@@ -283,7 +283,7 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
             ctx-&gt;cipher_data = OPENSSL_zalloc(ctx-&gt;cipher-&gt;ctx_size);
             if (ctx-&gt;cipher_data == NULL) {
                 ctx-&gt;cipher = NULL;
-                EVPerr(EVP_F_EVP_CIPHERINIT_EX, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
         } else {
@@ -295,7 +295,7 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
         if (ctx-&gt;cipher-&gt;flags &amp; EVP_CIPH_CTRL_INIT) {
             if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL)) {
                 ctx-&gt;cipher = NULL;
-                EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+                ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
                 return 0;
             }
         }
@@ -313,7 +313,7 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
 
     if (!(ctx-&gt;flags &amp; EVP_CIPHER_CTX_FLAG_WRAP_ALLOW)
         &amp;&amp; EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_WRAP_MODE) {
-        EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_WRAP_MODE_NOT_ALLOWED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_WRAP_MODE_NOT_ALLOWED);
         return 0;
     }
 
@@ -463,7 +463,7 @@ static int evp_EncryptDecryptUpdate(EVP_CIPHER_CTX *ctx,
     if (ctx-&gt;cipher-&gt;flags &amp; EVP_CIPH_FLAG_CUSTOM_CIPHER) {
         /* If block size &gt; 1 then the cipher will have to do this check */
         if (bl == 1 &amp;&amp; is_partially_overlapping(out, in, cmpl)) {
-            EVPerr(EVP_F_EVP_ENCRYPTDECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);
+            ERR_raise(ERR_LIB_EVP, EVP_R_PARTIALLY_OVERLAPPING);
             return 0;
         }
 
@@ -480,7 +480,7 @@ static int evp_EncryptDecryptUpdate(EVP_CIPHER_CTX *ctx,
         return inl == 0;
     }
     if (is_partially_overlapping(out + ctx-&gt;buf_len, in, cmpl)) {
-        EVPerr(EVP_F_EVP_ENCRYPTDECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);
+        ERR_raise(ERR_LIB_EVP, EVP_R_PARTIALLY_OVERLAPPING);
         return 0;
     }
 
@@ -538,18 +538,18 @@ int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
     if (outl != NULL) {
         *outl = 0;
     } else {
-        EVPerr(EVP_F_EVP_ENCRYPTUPDATE, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EVP, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
     /* Prevent accidental use of decryption context when encrypting */
     if (!ctx-&gt;encrypt) {
-        EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_INVALID_OPERATION);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_OPERATION);
         return 0;
     }
 
     if (ctx-&gt;cipher == NULL) {
-        EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_NO_CIPHER_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_CIPHER_SET);
         return 0;
     }
 
@@ -559,7 +559,7 @@ int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
     blocksize = EVP_CIPHER_CTX_block_size(ctx);
 
     if (ctx-&gt;cipher-&gt;cupdate == NULL  || blocksize &lt; 1) {
-        EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_UPDATE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UPDATE_ERROR);
         return 0;
     }
     ret = ctx-&gt;cipher-&gt;cupdate(ctx-&gt;provctx, out, &amp;soutl,
@@ -568,7 +568,7 @@ int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
 
     if (ret) {
         if (soutl &gt; INT_MAX) {
-            EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_UPDATE_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_UPDATE_ERROR);
             return 0;
         }
         *outl = soutl;
@@ -599,18 +599,18 @@ int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
     if (outl != NULL) {
         *outl = 0;
     } else {
-        EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EVP, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
     /* Prevent accidental use of decryption context when encrypting */
     if (!ctx-&gt;encrypt) {
-        EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, EVP_R_INVALID_OPERATION);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_OPERATION);
         return 0;
     }
 
     if (ctx-&gt;cipher == NULL) {
-        EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, EVP_R_NO_CIPHER_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_CIPHER_SET);
         return 0;
     }
     if (ctx-&gt;cipher-&gt;prov == NULL)
@@ -619,7 +619,7 @@ int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
     blocksize = EVP_CIPHER_CTX_block_size(ctx);
 
     if (blocksize &lt; 1 || ctx-&gt;cipher-&gt;cfinal == NULL) {
-        EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, EVP_R_FINAL_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_FINAL_ERROR);
         return 0;
     }
 
@@ -628,7 +628,7 @@ int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
 
     if (ret) {
         if (soutl &gt; INT_MAX) {
-            EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, EVP_R_FINAL_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_FINAL_ERROR);
             return 0;
         }
         *outl = soutl;
@@ -657,8 +657,7 @@ int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
     bl = ctx-&gt;buf_len;
     if (ctx-&gt;flags &amp; EVP_CIPH_NO_PADDING) {
         if (bl) {
-            EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX,
-                   EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
+            ERR_raise(ERR_LIB_EVP, EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
             return 0;
         }
         *outl = 0;
@@ -687,18 +686,18 @@ int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
     if (outl != NULL) {
         *outl = 0;
     } else {
-        EVPerr(EVP_F_EVP_DECRYPTUPDATE, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EVP, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
     /* Prevent accidental use of encryption context when decrypting */
     if (ctx-&gt;encrypt) {
-        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_INVALID_OPERATION);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_OPERATION);
         return 0;
     }
 
     if (ctx-&gt;cipher == NULL) {
-        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_NO_CIPHER_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_CIPHER_SET);
         return 0;
     }
     if (ctx-&gt;cipher-&gt;prov == NULL)
@@ -707,7 +706,7 @@ int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
     blocksize = EVP_CIPHER_CTX_block_size(ctx);
 
     if (ctx-&gt;cipher-&gt;cupdate == NULL || blocksize &lt; 1) {
-        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_UPDATE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UPDATE_ERROR);
         return 0;
     }
     ret = ctx-&gt;cipher-&gt;cupdate(ctx-&gt;provctx, out, &amp;soutl,
@@ -716,7 +715,7 @@ int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
 
     if (ret) {
         if (soutl &gt; INT_MAX) {
-            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_UPDATE_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_UPDATE_ERROR);
             return 0;
         }
         *outl = soutl;
@@ -734,7 +733,7 @@ int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
 
     if (ctx-&gt;cipher-&gt;flags &amp; EVP_CIPH_FLAG_CUSTOM_CIPHER) {
         if (b == 1 &amp;&amp; is_partially_overlapping(out, in, cmpl)) {
-            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);
+            ERR_raise(ERR_LIB_EVP, EVP_R_PARTIALLY_OVERLAPPING);
             return 0;
         }
 
@@ -761,7 +760,7 @@ int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
         /* see comment about PTRDIFF_T comparison above */
         if (((PTRDIFF_T)out == (PTRDIFF_T)in)
             || is_partially_overlapping(out, in, b)) {
-            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);
+            ERR_raise(ERR_LIB_EVP, EVP_R_PARTIALLY_OVERLAPPING);
             return 0;
         }
         memcpy(out, ctx-&gt;final, b);
@@ -808,18 +807,18 @@ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
     if (outl != NULL) {
         *outl = 0;
     } else {
-        EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_EVP, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
     /* Prevent accidental use of encryption context when decrypting */
     if (ctx-&gt;encrypt) {
-        EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_INVALID_OPERATION);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_OPERATION);
         return 0;
     }
 
     if (ctx-&gt;cipher == NULL) {
-        EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_NO_CIPHER_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_CIPHER_SET);
         return 0;
     }
 
@@ -829,7 +828,7 @@ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
     blocksize = EVP_CIPHER_CTX_block_size(ctx);
 
     if (blocksize &lt; 1 || ctx-&gt;cipher-&gt;cfinal == NULL) {
-        EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_FINAL_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_FINAL_ERROR);
         return 0;
     }
 
@@ -838,7 +837,7 @@ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
 
     if (ret) {
         if (soutl &gt; INT_MAX) {
-            EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_FINAL_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_FINAL_ERROR);
             return 0;
         }
         *outl = soutl;
@@ -862,8 +861,7 @@ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
     b = ctx-&gt;cipher-&gt;block_size;
     if (ctx-&gt;flags &amp; EVP_CIPH_NO_PADDING) {
         if (ctx-&gt;buf_len) {
-            EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,
-                   EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
+            ERR_raise(ERR_LIB_EVP, EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
             return 0;
         }
         *outl = 0;
@@ -871,7 +869,7 @@ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
     }
     if (b &gt; 1) {
         if (ctx-&gt;buf_len || !ctx-&gt;final_used) {
-            EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_WRONG_FINAL_BLOCK_LENGTH);
+            ERR_raise(ERR_LIB_EVP, EVP_R_WRONG_FINAL_BLOCK_LENGTH);
             return 0;
         }
         OPENSSL_assert(b &lt;= sizeof(ctx-&gt;final));
@@ -882,12 +880,12 @@ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
          */
         n = ctx-&gt;final[b - 1];
         if (n == 0 || n &gt; (int)b) {
-            EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_BAD_DECRYPT);
+            ERR_raise(ERR_LIB_EVP, EVP_R_BAD_DECRYPT);
             return 0;
         }
         for (i = 0; i &lt; n; i++) {
             if (ctx-&gt;final[--b] != n) {
-                EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_BAD_DECRYPT);
+                ERR_raise(ERR_LIB_EVP, EVP_R_BAD_DECRYPT);
                 return 0;
             }
         }
@@ -935,7 +933,7 @@ int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)
         c-&gt;key_len = keylen;
         return 1;
     }
-    EVPerr(EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH, EVP_R_INVALID_KEY_LENGTH);
+    ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_KEY_LENGTH);
     return 0;
 }
 
@@ -967,7 +965,7 @@ int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
     };
 
     if (ctx == NULL || ctx-&gt;cipher == NULL) {
-        EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_NO_CIPHER_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_CIPHER_SET);
         return 0;
     }
 
@@ -1141,7 +1139,7 @@ int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
 /* TODO(3.0): Remove legacy code below */
 legacy:
     if (ctx-&gt;cipher-&gt;ctrl == NULL) {
-        EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_NOT_IMPLEMENTED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_CTRL_NOT_IMPLEMENTED);
         return 0;
     }
 
@@ -1149,8 +1147,7 @@ legacy:
 
  end:
     if (ret == EVP_CTRL_RET_UNSUPPORTED) {
-        EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL,
-               EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED);
         return 0;
     }
     return ret;
@@ -1238,7 +1235,7 @@ int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key)
 int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
 {
     if ((in == NULL) || (in-&gt;cipher == NULL)) {
-        EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_INPUT_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INPUT_NOT_INITIALIZED);
         return 0;
     }
 
@@ -1246,7 +1243,7 @@ int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
         goto legacy;
 
     if (in-&gt;cipher-&gt;dupctx == NULL) {
-        EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_NOT_ABLE_TO_COPY_CTX);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NOT_ABLE_TO_COPY_CTX);
         return 0;
     }
 
@@ -1262,7 +1259,7 @@ int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
 
     out-&gt;provctx = in-&gt;cipher-&gt;dupctx(in-&gt;provctx);
     if (out-&gt;provctx == NULL) {
-        EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_NOT_ABLE_TO_COPY_CTX);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NOT_ABLE_TO_COPY_CTX);
         return 0;
     }
 
@@ -1274,7 +1271,7 @@ int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
 #if !defined(OPENSSL_NO_ENGINE) &amp;&amp; !defined(FIPS_MODULE)
     /* Make sure it's safe to copy a cipher context using an ENGINE */
     if (in-&gt;engine &amp;&amp; !ENGINE_init(in-&gt;engine)) {
-        EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, ERR_R_ENGINE_LIB);
+        ERR_raise(ERR_LIB_EVP, ERR_R_ENGINE_LIB);
         return 0;
     }
 #endif
@@ -1286,7 +1283,7 @@ int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
         out-&gt;cipher_data = OPENSSL_malloc(in-&gt;cipher-&gt;ctx_size);
         if (out-&gt;cipher_data == NULL) {
             out-&gt;cipher = NULL;
-            EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         memcpy(out-&gt;cipher_data, in-&gt;cipher_data, in-&gt;cipher-&gt;ctx_size);
@@ -1295,7 +1292,7 @@ int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
     if (in-&gt;cipher-&gt;flags &amp; EVP_CIPH_CUSTOM_COPY)
         if (!in-&gt;cipher-&gt;ctrl((EVP_CIPHER_CTX *)in, EVP_CTRL_COPY, 0, out)) {
             out-&gt;cipher = NULL;
-            EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_INITIALIZATION_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
             return 0;
         }
     return 1;
@@ -1355,7 +1352,7 @@ static void *evp_cipher_from_dispatch(const int name_id,
     int fnciphcnt = 0, fnctxcnt = 0;
 
     if ((cipher = evp_cipher_new()) == NULL) {
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -1464,7 +1461,7 @@ static void *evp_cipher_from_dispatch(const int name_id,
          * the &quot;newctx&quot; and &quot;freectx&quot; functions.
          */
         EVP_CIPHER_free(cipher);
-        EVPerr(EVP_F_EVP_CIPHER_FROM_DISPATCH, EVP_R_INVALID_PROVIDER_FUNCTIONS);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     cipher-&gt;prov = prov;
diff --git a/crypto/evp/evp_fetch.c b/crypto/evp/evp_fetch.c
index e8d1336aa3..7a0a3fcda7 100644
--- a/crypto/evp/evp_fetch.c
+++ b/crypto/evp/evp_fetch.c
@@ -408,7 +408,7 @@ static int evp_set_parsed_default_properties(OSSL_LIB_CTX *libctx,
             ossl_method_store_flush_cache(store, 0);
         return 1;
     }
-    EVPerr(0, ERR_R_INTERNAL_ERROR);
+    ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
     return 0;
 }
 
@@ -418,7 +418,7 @@ int evp_set_default_properties_int(OSSL_LIB_CTX *libctx, const char *propq,
     OSSL_PROPERTY_LIST *pl = NULL;
 
     if (propq != NULL &amp;&amp; (pl = ossl_parse_query(libctx, propq)) == NULL) {
-        EVPerr(0, EVP_R_DEFAULT_QUERY_PARSE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_DEFAULT_QUERY_PARSE_ERROR);
         return 0;
     }
     return evp_set_parsed_default_properties(libctx, pl, loadconfig);
@@ -439,13 +439,13 @@ static int evp_default_properties_merge(OSSL_LIB_CTX *libctx, const char *propq)
     if (plp == NULL || *plp == NULL)
         return EVP_set_default_properties(libctx, propq);
     if ((pl1 = ossl_parse_query(libctx, propq)) == NULL) {
-        EVPerr(0, EVP_R_DEFAULT_QUERY_PARSE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_DEFAULT_QUERY_PARSE_ERROR);
         return 0;
     }
     pl2 = ossl_property_merge(pl1, *plp);
     ossl_property_free(pl1);
     if (pl2 == NULL) {
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return evp_set_parsed_default_properties(libctx, pl2, 0);
diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
index 8da5b2290b..7947d05907 100644
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -155,9 +155,9 @@ int evp_cipher_param_to_asn1_ex(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
 
  err:
     if (ret == -2)
-        EVPerr(0, EVP_R_UNSUPPORTED_CIPHER);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_CIPHER);
     else if (ret &lt;= 0)
-        EVPerr(0, EVP_R_CIPHER_PARAMETER_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_CIPHER_PARAMETER_ERROR);
     if (ret &lt; -1)
         ret = -1;
     return ret;
@@ -225,9 +225,9 @@ int evp_cipher_asn1_to_param_ex(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
     }
 
     if (ret == -2)
-        EVPerr(0, EVP_R_UNSUPPORTED_CIPHER);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_CIPHER);
     else if (ret &lt;= 0)
-        EVPerr(0, EVP_R_CIPHER_PARAMETER_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_CIPHER_PARAMETER_ERROR);
     if (ret &lt; -1)
         ret = -1;
     return ret;
@@ -693,7 +693,7 @@ int EVP_MD_block_size(const EVP_MD *md)
     OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
     if (md == NULL) {
-        EVPerr(EVP_F_EVP_MD_BLOCK_SIZE, EVP_R_MESSAGE_DIGEST_IS_NULL);
+        ERR_raise(ERR_LIB_EVP, EVP_R_MESSAGE_DIGEST_IS_NULL);
         return -1;
     }
     v = md-&gt;block_size;
@@ -720,7 +720,7 @@ int EVP_MD_size(const EVP_MD *md)
     OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
     if (md == NULL) {
-        EVPerr(EVP_F_EVP_MD_SIZE, EVP_R_MESSAGE_DIGEST_IS_NULL);
+        ERR_raise(ERR_LIB_EVP, EVP_R_MESSAGE_DIGEST_IS_NULL);
         return -1;
     }
     v = md-&gt;md_size;
diff --git a/crypto/evp/evp_pbe.c b/crypto/evp/evp_pbe.c
index b283b0a684..d9d51e0d78 100644
--- a/crypto/evp/evp_pbe.c
+++ b/crypto/evp/evp_pbe.c
@@ -94,12 +94,12 @@ int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,
                       &amp;cipher_nid, &amp;md_nid, &amp;keygen)) {
         char obj_tmp[80];
 
-        EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM);
         if (pbe_obj == NULL)
             OPENSSL_strlcpy(obj_tmp, &quot;NULL&quot;, sizeof(obj_tmp));
         else
             i2t_ASN1_OBJECT(obj_tmp, sizeof(obj_tmp), pbe_obj);
-        ERR_add_error_data(2, &quot;TYPE=&quot;, obj_tmp);
+        ERR_raise_data(ERR_LIB_EVP, EVP_R_UNKNOWN_PBE_ALGORITHM,
+                       &quot;TYPE=%s&quot;, obj_tmp);
         return 0;
     }
 
@@ -113,8 +113,8 @@ int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,
     else {
         cipher = EVP_get_cipherbynid(cipher_nid);
         if (!cipher) {
-            EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_CIPHER);
-            ERR_add_error_data(1, OBJ_nid2sn(cipher_nid));
+            ERR_raise_data(ERR_LIB_EVP, EVP_R_UNKNOWN_CIPHER,
+                           OBJ_nid2sn(cipher_nid));
             return 0;
         }
     }
@@ -124,7 +124,7 @@ int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,
     else {
         md = EVP_get_digestbynid(md_nid);
         if (!md) {
-            EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_DIGEST);
+            ERR_raise(ERR_LIB_EVP, EVP_R_UNKNOWN_DIGEST);
             return 0;
         }
     }
@@ -183,7 +183,7 @@ int EVP_PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid,
     return 1;
 
  err:
-    EVPerr(EVP_F_EVP_PBE_ALG_ADD_TYPE, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
diff --git a/crypto/evp/evp_pkey.c b/crypto/evp/evp_pkey.c
index 766dfb46ec..b049420d0b 100644
--- a/crypto/evp/evp_pkey.c
+++ b/crypto/evp/evp_pkey.c
@@ -31,14 +31,14 @@ EVP_PKEY *EVP_PKCS82PKEY_ex(const PKCS8_PRIV_KEY_INFO *p8, OSSL_LIB_CTX *libctx,
         return NULL;
 
     if ((pkey = EVP_PKEY_new()) == NULL) {
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     if (!EVP_PKEY_set_type(pkey, OBJ_obj2nid(algoid))) {
-        EVPerr(0, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
         i2t_ASN1_OBJECT(obj_tmp, 80, algoid);
-        ERR_add_error_data(2, &quot;TYPE=&quot;, obj_tmp);
+        ERR_raise_data(ERR_LIB_EVP, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM,
+                       &quot;TYPE=%s&quot;, obj_tmp);
         goto error;
     }
 
@@ -47,11 +47,11 @@ EVP_PKEY *EVP_PKCS82PKEY_ex(const PKCS8_PRIV_KEY_INFO *p8, OSSL_LIB_CTX *libctx,
             goto error;
     } else if (pkey-&gt;ameth-&gt;priv_decode != NULL) {
         if (!pkey-&gt;ameth-&gt;priv_decode(pkey, p8)) {
-            EVPerr(0, EVP_R_PRIVATE_KEY_DECODE_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_PRIVATE_KEY_DECODE_ERROR);
             goto error;
         }
     } else {
-        EVPerr(0, EVP_R_METHOD_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_METHOD_NOT_SUPPORTED);
         goto error;
     }
 
@@ -101,24 +101,22 @@ PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(const EVP_PKEY *pkey)
     } else {
         p8 = PKCS8_PRIV_KEY_INFO_new();
         if (p8  == NULL) {
-            EVPerr(EVP_F_EVP_PKEY2PKCS8, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
 
         if (pkey-&gt;ameth != NULL) {
             if (pkey-&gt;ameth-&gt;priv_encode != NULL) {
                 if (!pkey-&gt;ameth-&gt;priv_encode(p8, pkey)) {
-                    EVPerr(EVP_F_EVP_PKEY2PKCS8,
-                           EVP_R_PRIVATE_KEY_ENCODE_ERROR);
+                    ERR_raise(ERR_LIB_EVP, EVP_R_PRIVATE_KEY_ENCODE_ERROR);
                     goto error;
                 }
             } else {
-                EVPerr(EVP_F_EVP_PKEY2PKCS8, EVP_R_METHOD_NOT_SUPPORTED);
+                ERR_raise(ERR_LIB_EVP, EVP_R_METHOD_NOT_SUPPORTED);
                 goto error;
             }
         } else {
-            EVPerr(EVP_F_EVP_PKEY2PKCS8,
-                   EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
+            ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
             goto error;
         }
     }
diff --git a/crypto/evp/evp_rand.c b/crypto/evp/evp_rand.c
index 44b648705c..07d1ad9db2 100644
--- a/crypto/evp/evp_rand.c
+++ b/crypto/evp/evp_rand.c
@@ -93,7 +93,7 @@ int EVP_RAND_enable_locking(EVP_RAND_CTX *rand)
 {
     if (rand-&gt;meth-&gt;enable_locking != NULL)
         return rand-&gt;meth-&gt;enable_locking(rand-&gt;data);
-    EVPerr(0, EVP_R_LOCKING_NOT_SUPPORTED);
+    ERR_raise(ERR_LIB_EVP, EVP_R_LOCKING_NOT_SUPPORTED);
     return 0;
 }
 
@@ -123,7 +123,7 @@ static void *evp_rand_from_dispatch(int name_id,
 #endif
 
     if ((rand = evp_rand_new()) == NULL) {
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     rand-&gt;name_id = name_id;
@@ -322,25 +322,25 @@ EVP_RAND_CTX *EVP_RAND_CTX_new(EVP_RAND *rand, EVP_RAND_CTX *parent)
     const OSSL_DISPATCH *parent_dispatch = NULL;
 
     if (rand == NULL) {
-        EVPerr(0, EVP_R_INVALID_NULL_ALGORITHM);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_NULL_ALGORITHM);
         return NULL;
     }
 
     ctx = OPENSSL_zalloc(sizeof(*ctx));
     if (ctx == NULL || (ctx-&gt;refcnt_lock = CRYPTO_THREAD_lock_new()) == NULL) {
         OPENSSL_free(ctx);
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     if (parent != NULL) {
         if (!EVP_RAND_enable_locking(parent)) {
-            EVPerr(0, EVP_R_UNABLE_TO_ENABLE_PARENT_LOCKING);
+            ERR_raise(ERR_LIB_EVP, EVP_R_UNABLE_TO_ENABLE_PARENT_LOCKING);
             CRYPTO_THREAD_lock_free(ctx-&gt;refcnt_lock);
             OPENSSL_free(ctx);
             return NULL;
         }
         if (!evp_rand_ctx_up_ref(parent)) {
-            EVPerr(0, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
             CRYPTO_THREAD_lock_free(ctx-&gt;refcnt_lock);
             OPENSSL_free(ctx);
             return NULL;
@@ -351,7 +351,7 @@ EVP_RAND_CTX *EVP_RAND_CTX_new(EVP_RAND *rand, EVP_RAND_CTX *parent)
     if ((ctx-&gt;data = rand-&gt;newctx(ossl_provider_ctx(rand-&gt;prov), parent_ctx,
                                   parent_dispatch)) == NULL
             || !EVP_RAND_up_ref(rand)) {
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         rand-&gt;freectx(ctx-&gt;data);
         CRYPTO_THREAD_lock_free(ctx-&gt;refcnt_lock);
         OPENSSL_free(ctx);
@@ -515,14 +515,14 @@ static int evp_rand_generate_locked(EVP_RAND_CTX *ctx, unsigned char *out,
                                             &amp;max_request);
     if (!evp_rand_get_ctx_params_locked(ctx, params)
             || max_request == 0) {
-        EVPerr(0, EVP_R_UNABLE_TO_GET_MAXIMUM_REQUEST_SIZE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNABLE_TO_GET_MAXIMUM_REQUEST_SIZE);
         return 0;
     }
     for (; outlen &gt; 0; outlen -= chunk, out += chunk) {
         chunk = outlen &gt; max_request ? max_request : outlen;
         if (!ctx-&gt;meth-&gt;generate(ctx-&gt;data, out, chunk, strength,
                                  prediction_resistance, addin, addin_len)) {
-            EVPerr(0, EVP_R_GENERATE_ERROR);
+            ERR_raise(ERR_LIB_EVP, EVP_R_GENERATE_ERROR);
             return 0;
         }
         /*
diff --git a/crypto/evp/evp_utils.c b/crypto/evp/evp_utils.c
index 77622616b3..e5892789ff 100644
--- a/crypto/evp/evp_utils.c
+++ b/crypto/evp/evp_utils.c
@@ -62,12 +62,12 @@ int name (const type *obj, void *provctx, OSSL_PARAM params[])                 \
  */
 static void geterr(void)
 {
-    EVPerr(0, EVP_R_CANNOT_GET_PARAMETERS);
+    ERR_raise(ERR_LIB_EVP, EVP_R_CANNOT_GET_PARAMETERS);
 }
 
 static void seterr(void)
 {
-    EVPerr(0, EVP_R_CANNOT_SET_PARAMETERS);
+    ERR_raise(ERR_LIB_EVP, EVP_R_CANNOT_SET_PARAMETERS);
 }
 
 PARAM_FUNCTIONS(EVP_CIPHER,
diff --git a/crypto/evp/exchange.c b/crypto/evp/exchange.c
index 485ff28041..501645fa0c 100644
--- a/crypto/evp/exchange.c
+++ b/crypto/evp/exchange.c
@@ -127,8 +127,7 @@ static void *evp_keyexch_from_dispatch(int name_id,
          * be present. Same goes for get_ctx_params and gettable_ctx_params.
          * The dupctx and set_peer functions are optional.
          */
-        EVPerr(EVP_F_EVP_KEYEXCH_FROM_DISPATCH,
-               EVP_R_INVALID_PROVIDER_FUNCTIONS);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         goto err;
     }
 
@@ -184,7 +183,7 @@ int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx)
     const char *supported_exch = NULL;
 
     if (ctx == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
@@ -277,7 +276,7 @@ int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx)
     ctx-&gt;op.kex.exchprovctx = exchange-&gt;newctx(ossl_provider_ctx(exchange-&gt;prov));
     if (ctx-&gt;op.kex.exchprovctx == NULL) {
         /* The provider key can stay in the cache */
-        EVPerr(0, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         goto err;
     }
     ret = exchange-&gt;init(ctx-&gt;op.kex.exchprovctx, provkey);
@@ -300,7 +299,7 @@ int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx)
     return 0;
 #else
     if (ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;derive == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
@@ -319,8 +318,7 @@ int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer)
     void *provkey = NULL;
 
     if (ctx == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
@@ -328,8 +326,7 @@ int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer)
         goto legacy;
 
     if (ctx-&gt;op.kex.exchange-&gt;set_peer == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
@@ -356,15 +353,13 @@ int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer)
              || ctx-&gt;pmeth-&gt;encrypt != NULL
              || ctx-&gt;pmeth-&gt;decrypt != NULL)
         || ctx-&gt;pmeth-&gt;ctrl == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
     if (ctx-&gt;operation != EVP_PKEY_OP_DERIVE
         &amp;&amp; ctx-&gt;operation != EVP_PKEY_OP_ENCRYPT
         &amp;&amp; ctx-&gt;operation != EVP_PKEY_OP_DECRYPT) {
-        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,
-               EVP_R_OPERATON_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
         return -1;
     }
 
@@ -377,12 +372,12 @@ int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer)
         return 1;
 
     if (ctx-&gt;pkey == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER, EVP_R_NO_KEY_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEY_SET);
         return -1;
     }
 
     if (ctx-&gt;pkey-&gt;type != peer-&gt;type) {
-        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER, EVP_R_DIFFERENT_KEY_TYPES);
+        ERR_raise(ERR_LIB_EVP, EVP_R_DIFFERENT_KEY_TYPES);
         return -1;
     }
 
@@ -395,7 +390,7 @@ int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer)
      */
     if (!EVP_PKEY_missing_parameters(peer) &amp;&amp;
         !EVP_PKEY_parameters_eq(ctx-&gt;pkey, peer)) {
-        EVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER, EVP_R_DIFFERENT_PARAMETERS);
+        ERR_raise(ERR_LIB_EVP, EVP_R_DIFFERENT_PARAMETERS);
         return -1;
     }
 
@@ -419,13 +414,12 @@ int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *pkeylen)
     int ret;
 
     if (ctx == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_DERIVE,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
     if (!EVP_PKEY_CTX_IS_DERIVE_OP(ctx)) {
-        EVPerr(EVP_F_EVP_PKEY_DERIVE, EVP_R_OPERATON_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
         return -1;
     }
 
@@ -438,8 +432,7 @@ int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *pkeylen)
     return ret;
  legacy:
     if (ctx ==  NULL || ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;derive == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_DERIVE,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
diff --git a/crypto/evp/kdf_lib.c b/crypto/evp/kdf_lib.c
index 7a3e9d681c..a8565ed25b 100644
--- a/crypto/evp/kdf_lib.c
+++ b/crypto/evp/kdf_lib.c
@@ -34,7 +34,7 @@ EVP_KDF_CTX *EVP_KDF_CTX_new(EVP_KDF *kdf)
     if (ctx == NULL
         || (ctx-&gt;data = kdf-&gt;newctx(ossl_provider_ctx(kdf-&gt;prov))) == NULL
         || !EVP_KDF_up_ref(kdf)) {
-        EVPerr(EVP_F_EVP_KDF_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         if (ctx != NULL)
             kdf-&gt;freectx(ctx-&gt;data);
         OPENSSL_free(ctx);
@@ -64,13 +64,13 @@ EVP_KDF_CTX *EVP_KDF_CTX_dup(const EVP_KDF_CTX *src)
 
     dst = OPENSSL_malloc(sizeof(*dst));
     if (dst == NULL) {
-        EVPerr(EVP_F_EVP_KDF_CTX_DUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     memcpy(dst, src, sizeof(*dst));
     if (!EVP_KDF_up_ref(dst-&gt;meth)) {
-        EVPerr(EVP_F_EVP_KDF_CTX_DUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(dst);
         return NULL;
     }
diff --git a/crypto/evp/kdf_meth.c b/crypto/evp/kdf_meth.c
index a89a8e9836..40e71e8cd8 100644
--- a/crypto/evp/kdf_meth.c
+++ b/crypto/evp/kdf_meth.c
@@ -60,7 +60,7 @@ static void *evp_kdf_from_dispatch(int name_id,
     int fnkdfcnt = 0, fnctxcnt = 0;
 
     if ((kdf = evp_kdf_new()) == NULL) {
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     kdf-&gt;name_id = name_id;
diff --git a/crypto/evp/kem.c b/crypto/evp/kem.c
index 2e61d2061e..989ffa2414 100644
--- a/crypto/evp/kem.c
+++ b/crypto/evp/kem.c
@@ -117,12 +117,12 @@ int EVP_PKEY_encapsulate(EVP_PKEY_CTX *ctx,
         return 0;
 
     if (ctx-&gt;operation != EVP_PKEY_OP_ENCAPSULATE) {
-        EVPerr(0, EVP_R_OPERATON_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
         return -1;
     }
 
     if (ctx-&gt;op.encap.kemprovctx == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
@@ -148,12 +148,12 @@ int EVP_PKEY_decapsulate(EVP_PKEY_CTX *ctx,
         return 0;
 
     if (ctx-&gt;operation != EVP_PKEY_OP_DECAPSULATE) {
-        EVPerr(0, EVP_R_OPERATON_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
         return -1;
     }
 
     if (ctx-&gt;op.encap.kemprovctx == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
     return ctx-&gt;op.encap.kem-&gt;decapsulate(ctx-&gt;op.encap.kemprovctx,
diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
index 66cef52144..7ef2d703f8 100644
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -23,7 +23,7 @@ static void *keymgmt_new(void)
     if ((keymgmt = OPENSSL_zalloc(sizeof(*keymgmt))) == NULL
         || (keymgmt-&gt;lock = CRYPTO_THREAD_lock_new()) == NULL) {
         EVP_KEYMGMT_free(keymgmt);
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -187,7 +187,7 @@ static void *keymgmt_from_dispatch(int name_id,
             &amp;&amp; (keymgmt-&gt;gen_init == NULL
                 || keymgmt-&gt;gen_cleanup == NULL))) {
         EVP_KEYMGMT_free(keymgmt);
-        EVPerr(0, EVP_R_INVALID_PROVIDER_FUNCTIONS);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
     }
     keymgmt-&gt;prov = prov;
diff --git a/crypto/evp/m_sigver.c b/crypto/evp/m_sigver.c
index c1bddcb946..bdcac90078 100644
--- a/crypto/evp/m_sigver.c
+++ b/crypto/evp/m_sigver.c
@@ -20,7 +20,7 @@
 
 static int update(EVP_MD_CTX *ctx, const void *data, size_t datalen)
 {
-    EVPerr(EVP_F_UPDATE, EVP_R_ONLY_ONESHOT_SUPPORTED);
+    ERR_raise(ERR_LIB_EVP, EVP_R_ONLY_ONESHOT_SUPPORTED);
     return 0;
 }
 
@@ -242,7 +242,7 @@ static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
         type = evp_get_digestbyname_ex(locpctx-&gt;libctx, mdname);
 
     if (ctx-&gt;pctx-&gt;pmeth == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return 0;
     }
 
@@ -255,7 +255,7 @@ static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
         }
 
         if (type == NULL) {
-            EVPerr(EVP_F_DO_SIGVER_INIT, EVP_R_NO_DEFAULT_DIGEST);
+            ERR_raise(ERR_LIB_EVP, EVP_R_NO_DEFAULT_DIGEST);
             return 0;
         }
     }
diff --git a/crypto/evp/mac_lib.c b/crypto/evp/mac_lib.c
index ac8bfb150c..c5c12598d3 100644
--- a/crypto/evp/mac_lib.c
+++ b/crypto/evp/mac_lib.c
@@ -26,7 +26,7 @@ EVP_MAC_CTX *EVP_MAC_CTX_new(EVP_MAC *mac)
     if (ctx == NULL
         || (ctx-&gt;data = mac-&gt;newctx(ossl_provider_ctx(mac-&gt;prov))) == NULL
         || !EVP_MAC_up_ref(mac)) {
-        EVPerr(EVP_F_EVP_MAC_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         if (ctx != NULL)
             mac-&gt;freectx(ctx-&gt;data);
         OPENSSL_free(ctx);
@@ -57,13 +57,13 @@ EVP_MAC_CTX *EVP_MAC_CTX_dup(const EVP_MAC_CTX *src)
 
     dst = OPENSSL_malloc(sizeof(*dst));
     if (dst == NULL) {
-        EVPerr(EVP_F_EVP_MAC_CTX_DUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     *dst = *src;
     if (!EVP_MAC_up_ref(dst-&gt;meth)) {
-        EVPerr(EVP_F_EVP_MAC_CTX_DUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(dst);
         return NULL;
     }
diff --git a/crypto/evp/mac_meth.c b/crypto/evp/mac_meth.c
index c2b7c5c613..edf08389e9 100644
--- a/crypto/evp/mac_meth.c
+++ b/crypto/evp/mac_meth.c
@@ -54,7 +54,7 @@ static void *evp_mac_from_dispatch(int name_id,
     int fnmaccnt = 0, fnctxcnt = 0;
 
     if ((mac = evp_mac_new()) == NULL) {
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     mac-&gt;name_id = name_id;
diff --git a/crypto/evp/p5_crpt.c b/crypto/evp/p5_crpt.c
index 7e9a80e5c0..4d9e894f0f 100644
--- a/crypto/evp/p5_crpt.c
+++ b/crypto/evp/p5_crpt.c
@@ -38,25 +38,25 @@ int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *cctx, const char *pass, int passlen,
     /* Extract useful info from parameter */
     if (param == NULL || param-&gt;type != V_ASN1_SEQUENCE ||
         param-&gt;value.sequence == NULL) {
-        EVPerr(EVP_F_PKCS5_PBE_KEYIVGEN, EVP_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_DECODE_ERROR);
         return 0;
     }
 
     pbe = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(PBEPARAM), param);
     if (pbe == NULL) {
-        EVPerr(EVP_F_PKCS5_PBE_KEYIVGEN, EVP_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_DECODE_ERROR);
         return 0;
     }
 
     ivl = EVP_CIPHER_iv_length(cipher);
     if (ivl &lt; 0 || ivl &gt; 16) {
-        EVPerr(EVP_F_PKCS5_PBE_KEYIVGEN, EVP_R_INVALID_IV_LENGTH);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_IV_LENGTH);
         PBEPARAM_free(pbe);
         return 0;
     }
     kl = EVP_CIPHER_key_length(cipher);
     if (kl &lt; 0 || kl &gt; (int)sizeof(md_tmp)) {
-        EVPerr(EVP_F_PKCS5_PBE_KEYIVGEN, EVP_R_INVALID_KEY_LENGTH);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_KEY_LENGTH);
         PBEPARAM_free(pbe);
         return 0;
     }
@@ -75,7 +75,7 @@ int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *cctx, const char *pass, int passlen,
 
     ctx = EVP_MD_CTX_new();
     if (ctx == NULL) {
-        EVPerr(EVP_F_PKCS5_PBE_KEYIVGEN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
diff --git a/crypto/evp/p5_crpt2.c b/crypto/evp/p5_crpt2.c
index 830a97dde2..c097210bd4 100644
--- a/crypto/evp/p5_crpt2.c
+++ b/crypto/evp/p5_crpt2.c
@@ -114,15 +114,14 @@ int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
 
     pbe2 = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(PBE2PARAM), param);
     if (pbe2 == NULL) {
-        EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_DECODE_ERROR);
         goto err;
     }
 
     /* See if we recognise the key derivation function */
     if (!EVP_PBE_find(EVP_PBE_TYPE_KDF, OBJ_obj2nid(pbe2-&gt;keyfunc-&gt;algorithm),
                         NULL, NULL, &amp;kdf)) {
-        EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,
-               EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION);
         goto err;
     }
 
@@ -133,7 +132,7 @@ int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
     cipher = EVP_get_cipherbyobj(pbe2-&gt;encryption-&gt;algorithm);
 
     if (!cipher) {
-        EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_UNSUPPORTED_CIPHER);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_CIPHER);
         goto err;
     }
 
@@ -141,7 +140,7 @@ int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
     if (!EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, en_de))
         goto err;
     if (EVP_CIPHER_asn1_to_param(ctx, pbe2-&gt;encryption-&gt;parameter) &lt; 0) {
-        EVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_CIPHER_PARAMETER_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_CIPHER_PARAMETER_ERROR);
         goto err;
     }
     rv = kdf(ctx, pass, passlen, pbe2-&gt;keyfunc-&gt;parameter, NULL, NULL, en_de);
@@ -163,7 +162,7 @@ int PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,
     const EVP_MD *prfmd;
 
     if (EVP_CIPHER_CTX_cipher(ctx) == NULL) {
-        EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_NO_CIPHER_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_CIPHER_SET);
         goto err;
     }
     keylen = EVP_CIPHER_CTX_key_length(ctx);
@@ -174,13 +173,13 @@ int PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,
     kdf = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(PBKDF2PARAM), param);
 
     if (kdf == NULL) {
-        EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_DECODE_ERROR);
         goto err;
     }
 
     t = EVP_CIPHER_CTX_key_length(ctx);
     if (t &lt; 0) {
-        EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_INVALID_KEY_LENGTH);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_KEY_LENGTH);
         goto err;
     }
     keylen = t;
@@ -188,7 +187,7 @@ int PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,
     /* Now check the parameters of the kdf */
 
     if (kdf-&gt;keylength &amp;&amp; (ASN1_INTEGER_get(kdf-&gt;keylength) != (int)keylen)) {
-        EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_KEYLENGTH);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_KEYLENGTH);
         goto err;
     }
 
@@ -198,18 +197,18 @@ int PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,
         prf_nid = NID_hmacWithSHA1;
 
     if (!EVP_PBE_find(EVP_PBE_TYPE_PRF, prf_nid, NULL, &amp;hmac_md_nid, 0)) {
-        EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_PRF);
         goto err;
     }
 
     prfmd = EVP_get_digestbynid(hmac_md_nid);
     if (prfmd == NULL) {
-        EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_PRF);
         goto err;
     }
 
     if (kdf-&gt;salt-&gt;type != V_ASN1_OCTET_STRING) {
-        EVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_SALT_TYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_SALT_TYPE);
         goto err;
     }
 
diff --git a/crypto/evp/p_dec.c b/crypto/evp/p_dec.c
index 0410bb6aa9..ef0e715d65 100644
--- a/crypto/evp/p_dec.c
+++ b/crypto/evp/p_dec.c
@@ -28,7 +28,7 @@ int EVP_PKEY_decrypt_old(unsigned char *key, const unsigned char *ek, int ekl,
 #ifndef OPENSSL_NO_RSA
     if (EVP_PKEY_id(priv) != EVP_PKEY_RSA) {
 #endif
-        EVPerr(EVP_F_EVP_PKEY_DECRYPT_OLD, EVP_R_PUBLIC_KEY_NOT_RSA);
+        ERR_raise(ERR_LIB_EVP, EVP_R_PUBLIC_KEY_NOT_RSA);
 #ifndef OPENSSL_NO_RSA
         goto err;
     }
diff --git a/crypto/evp/p_enc.c b/crypto/evp/p_enc.c
index e510095abf..b149c7bbcf 100644
--- a/crypto/evp/p_enc.c
+++ b/crypto/evp/p_enc.c
@@ -28,7 +28,7 @@ int EVP_PKEY_encrypt_old(unsigned char *ek, const unsigned char *key,
 #ifndef OPENSSL_NO_RSA
     if (EVP_PKEY_id(pubk) != EVP_PKEY_RSA) {
 #endif
-        EVPerr(EVP_F_EVP_PKEY_ENCRYPT_OLD, EVP_R_PUBLIC_KEY_NOT_RSA);
+        ERR_raise(ERR_LIB_EVP, EVP_R_PUBLIC_KEY_NOT_RSA);
 #ifndef OPENSSL_NO_RSA
         goto err;
     }
diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
index 4b096ac17d..7a258fa31b 100644
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -145,20 +145,20 @@ int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)
         }
     } else if (evp_pkey_is_legacy(to)) {
         if (to-&gt;type != from-&gt;type) {
-            EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS, EVP_R_DIFFERENT_KEY_TYPES);
+            ERR_raise(ERR_LIB_EVP, EVP_R_DIFFERENT_KEY_TYPES);
             goto err;
         }
     }
 
     if (EVP_PKEY_missing_parameters(from)) {
-        EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS, EVP_R_MISSING_PARAMETERS);
+        ERR_raise(ERR_LIB_EVP, EVP_R_MISSING_PARAMETERS);
         goto err;
     }
 
     if (!EVP_PKEY_missing_parameters(to)) {
         if (EVP_PKEY_parameters_eq(to, from) == 1)
             return 1;
-        EVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS, EVP_R_DIFFERENT_PARAMETERS);
+        ERR_raise(ERR_LIB_EVP, EVP_R_DIFFERENT_PARAMETERS);
         return 0;
     }
 
@@ -390,7 +390,7 @@ static EVP_PKEY *new_raw_key_int(OSSL_LIB_CTX *libctx,
                             (void *)key, len);
 
             if (EVP_PKEY_fromdata(ctx, &amp;pkey, params) != 1) {
-                EVPerr(0, EVP_R_KEY_SETUP_FAILED);
+                ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
                 goto err;
             }
 
@@ -406,7 +406,7 @@ static EVP_PKEY *new_raw_key_int(OSSL_LIB_CTX *libctx,
 
     pkey = EVP_PKEY_new();
     if (pkey == NULL) {
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -420,22 +420,22 @@ static EVP_PKEY *new_raw_key_int(OSSL_LIB_CTX *libctx,
 
     if (key_is_priv) {
         if (pkey-&gt;ameth-&gt;set_priv_key == NULL) {
-            EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+            ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             goto err;
         }
 
         if (!pkey-&gt;ameth-&gt;set_priv_key(pkey, key, len)) {
-            EVPerr(0, EVP_R_KEY_SETUP_FAILED);
+            ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
             goto err;
         }
     } else {
         if (pkey-&gt;ameth-&gt;set_pub_key == NULL) {
-            EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+            ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             goto err;
         }
 
         if (!pkey-&gt;ameth-&gt;set_pub_key(pkey, key, len)) {
-            EVPerr(0, EVP_R_KEY_SETUP_FAILED);
+            ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
             goto err;
         }
     }
@@ -524,17 +524,17 @@ int EVP_PKEY_get_raw_private_key(const EVP_PKEY *pkey, unsigned char *priv,
     }
 
     if (pkey-&gt;ameth == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return 0;
     }
 
     if (pkey-&gt;ameth-&gt;get_priv_key == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return 0;
     }
 
     if (!pkey-&gt;ameth-&gt;get_priv_key(pkey, priv, len)) {
-        EVPerr(0, EVP_R_GET_RAW_KEY_FAILED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_GET_RAW_KEY_FAILED);
         return 0;
     }
 
@@ -556,18 +556,17 @@ int EVP_PKEY_get_raw_public_key(const EVP_PKEY *pkey, unsigned char *pub,
     }
 
     if (pkey-&gt;ameth == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return 0;
     }
 
      if (pkey-&gt;ameth-&gt;get_pub_key == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_GET_RAW_PUBLIC_KEY,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return 0;
     }
 
     if (!pkey-&gt;ameth-&gt;get_pub_key(pkey, pub, len)) {
-        EVPerr(EVP_F_EVP_PKEY_GET_RAW_PUBLIC_KEY, EVP_R_GET_RAW_KEY_FAILED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_GET_RAW_KEY_FAILED);
         return 0;
     }
 
@@ -592,7 +591,7 @@ static EVP_PKEY *new_cmac_key_int(const unsigned char *priv, size_t len,
         cipher_name = EVP_CIPHER_name(cipher);
 
     if (cipher_name == NULL) {
-        EVPerr(0, EVP_R_KEY_SETUP_FAILED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
         return NULL;
     }
 
@@ -601,7 +600,7 @@ static EVP_PKEY *new_cmac_key_int(const unsigned char *priv, size_t len,
         goto err;
 
     if (!EVP_PKEY_key_fromdata_init(ctx)) {
-        EVPerr(0, EVP_R_KEY_SETUP_FAILED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
         goto err;
     }
 
@@ -620,7 +619,7 @@ static EVP_PKEY *new_cmac_key_int(const unsigned char *priv, size_t len,
     *p = OSSL_PARAM_construct_end();
 
     if (!EVP_PKEY_fromdata(ctx, &amp;pkey, params)) {
-        EVPerr(0, EVP_R_KEY_SETUP_FAILED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
         goto err;
     }
 
@@ -629,7 +628,7 @@ static EVP_PKEY *new_cmac_key_int(const unsigned char *priv, size_t len,
 
     return pkey;
 # else
-    EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     return NULL;
 # endif
 }
@@ -679,7 +678,7 @@ int EVP_PKEY_set_alias_type(EVP_PKEY *pkey, int type)
      * but not one that resolves to the base type.
      */
     if (EVP_PKEY_type(type) != EVP_PKEY_base_id(pkey)) {
-        EVPerr(EVP_F_EVP_PKEY_SET_ALIAS_TYPE, EVP_R_UNSUPPORTED_ALGORITHM);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_ALGORITHM);
         return 0;
     }
 
@@ -693,12 +692,12 @@ int EVP_PKEY_set1_engine(EVP_PKEY *pkey, ENGINE *e)
 {
     if (e != NULL) {
         if (!ENGINE_init(e)) {
-            EVPerr(EVP_F_EVP_PKEY_SET1_ENGINE, ERR_R_ENGINE_LIB);
+            ERR_raise(ERR_LIB_EVP, ERR_R_ENGINE_LIB);
             return 0;
         }
         if (ENGINE_get_pkey_meth(e, pkey-&gt;type) == NULL) {
             ENGINE_finish(e);
-            EVPerr(EVP_F_EVP_PKEY_SET1_ENGINE, EVP_R_UNSUPPORTED_ALGORITHM);
+            ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_ALGORITHM);
             return 0;
         }
     }
@@ -748,7 +747,7 @@ const unsigned char *EVP_PKEY_get0_hmac(const EVP_PKEY *pkey, size_t *len)
 {
     ASN1_OCTET_STRING *os = NULL;
     if (pkey-&gt;type != EVP_PKEY_HMAC) {
-        EVPerr(EVP_F_EVP_PKEY_GET0_HMAC, EVP_R_EXPECTING_AN_HMAC_KEY);
+        ERR_raise(ERR_LIB_EVP, EVP_R_EXPECTING_AN_HMAC_KEY);
         return NULL;
     }
     os = EVP_PKEY_get0(pkey);
@@ -761,7 +760,7 @@ const unsigned char *EVP_PKEY_get0_poly1305(const EVP_PKEY *pkey, size_t *len)
 {
     ASN1_OCTET_STRING *os = NULL;
     if (pkey-&gt;type != EVP_PKEY_POLY1305) {
-        EVPerr(EVP_F_EVP_PKEY_GET0_POLY1305, EVP_R_EXPECTING_A_POLY1305_KEY);
+        ERR_raise(ERR_LIB_EVP, EVP_R_EXPECTING_A_POLY1305_KEY);
         return NULL;
     }
     os = EVP_PKEY_get0(pkey);
@@ -776,7 +775,7 @@ const unsigned char *EVP_PKEY_get0_siphash(const EVP_PKEY *pkey, size_t *len)
     ASN1_OCTET_STRING *os = NULL;
 
     if (pkey-&gt;type != EVP_PKEY_SIPHASH) {
-        EVPerr(EVP_F_EVP_PKEY_GET0_SIPHASH, EVP_R_EXPECTING_A_SIPHASH_KEY);
+        ERR_raise(ERR_LIB_EVP, EVP_R_EXPECTING_A_SIPHASH_KEY);
         return NULL;
     }
     os = EVP_PKEY_get0(pkey);
@@ -801,7 +800,7 @@ RSA *EVP_PKEY_get0_RSA(const EVP_PKEY *pkey)
         return NULL;
     }
     if (pkey-&gt;type != EVP_PKEY_RSA &amp;&amp; pkey-&gt;type != EVP_PKEY_RSA_PSS) {
-        EVPerr(EVP_F_EVP_PKEY_GET0_RSA, EVP_R_EXPECTING_AN_RSA_KEY);
+        ERR_raise(ERR_LIB_EVP, EVP_R_EXPECTING_AN_RSA_KEY);
         return NULL;
     }
     return pkey-&gt;pkey.rsa;
@@ -824,7 +823,7 @@ DSA *EVP_PKEY_get0_DSA(const EVP_PKEY *pkey)
         return NULL;
     }
     if (pkey-&gt;type != EVP_PKEY_DSA) {
-        EVPerr(EVP_F_EVP_PKEY_GET0_DSA, EVP_R_EXPECTING_A_DSA_KEY);
+        ERR_raise(ERR_LIB_EVP, EVP_R_EXPECTING_A_DSA_KEY);
         return NULL;
     }
     return pkey-&gt;pkey.dsa;
@@ -864,7 +863,7 @@ EC_KEY *EVP_PKEY_get0_EC_KEY(const EVP_PKEY *pkey)
         return NULL;
     }
     if (EVP_PKEY_base_id(pkey) != EVP_PKEY_EC) {
-        EVPerr(EVP_F_EVP_PKEY_GET0_EC_KEY, EVP_R_EXPECTING_A_EC_KEY);
+        ERR_raise(ERR_LIB_EVP, EVP_R_EXPECTING_A_EC_KEY);
         return NULL;
     }
     return pkey-&gt;pkey.ec;
@@ -930,7 +929,7 @@ DH *EVP_PKEY_get0_DH(const EVP_PKEY *pkey)
         return NULL;
     }
     if (pkey-&gt;type != EVP_PKEY_DH &amp;&amp; pkey-&gt;type != EVP_PKEY_DHX) {
-        EVPerr(EVP_F_EVP_PKEY_GET0_DH, EVP_R_EXPECTING_A_DH_KEY);
+        ERR_raise(ERR_LIB_EVP, EVP_R_EXPECTING_A_DH_KEY);
         return NULL;
     }
     return pkey-&gt;pkey.dh;
@@ -1394,7 +1393,7 @@ static int evp_pkey_reset_unlocked(EVP_PKEY *pk)
 
     pk-&gt;lock = CRYPTO_THREAD_lock_new();
     if (pk-&gt;lock == NULL) {
-        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return 1;
@@ -1405,7 +1404,7 @@ EVP_PKEY *EVP_PKEY_new(void)
     EVP_PKEY *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -1414,7 +1413,7 @@ EVP_PKEY *EVP_PKEY_new(void)
 
 #ifndef FIPS_MODULE
     if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_EVP_PKEY, ret, &amp;ret-&gt;ex_data)) {
-        EVPerr(EVP_F_EVP_PKEY_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 #endif
@@ -1504,7 +1503,7 @@ static int pkey_set_type(EVP_PKEY *pkey, ENGINE *e, int type, const char *str,
 #endif
         check = check &amp;&amp; keymgmt == NULL;
         if (check) {
-            EVPerr(EVP_F_PKEY_SET_TYPE, EVP_R_UNSUPPORTED_ALGORITHM);
+            ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_ALGORITHM);
             return 0;
         }
     }
diff --git a/crypto/evp/p_sign.c b/crypto/evp/p_sign.c
index 7d7fcbfdfd..c4badb5ffe 100644
--- a/crypto/evp/p_sign.c
+++ b/crypto/evp/p_sign.c
@@ -33,7 +33,7 @@ int EVP_SignFinal_ex(EVP_MD_CTX *ctx, unsigned char *sigret,
         EVP_MD_CTX *tmp_ctx = EVP_MD_CTX_new();
 
         if (tmp_ctx == NULL) {
-            EVPerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         rv = EVP_MD_CTX_copy_ex(tmp_ctx, ctx);
diff --git a/crypto/evp/p_verify.c b/crypto/evp/p_verify.c
index f4026d8a10..016a5f2e8c 100644
--- a/crypto/evp/p_verify.c
+++ b/crypto/evp/p_verify.c
@@ -31,7 +31,7 @@ int EVP_VerifyFinal_ex(EVP_MD_CTX *ctx, const unsigned char *sigbuf,
         EVP_MD_CTX *tmp_ctx = EVP_MD_CTX_new();
 
         if (tmp_ctx == NULL) {
-            EVPerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         rv = EVP_MD_CTX_copy_ex(tmp_ctx, ctx);
diff --git a/crypto/evp/pbe_scrypt.c b/crypto/evp/pbe_scrypt.c
index 450e085943..f7656324f6 100644
--- a/crypto/evp/pbe_scrypt.c
+++ b/crypto/evp/pbe_scrypt.c
@@ -46,7 +46,7 @@ int EVP_PBE_scrypt(const char *pass, size_t passlen,
     OSSL_PARAM params[7], *z = params;
 
     if (r &gt; UINT32_MAX || p &gt; UINT32_MAX) {
-        EVPerr(0, EVP_R_PARAMETER_TOO_LARGE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_PARAMETER_TOO_LARGE);
         return 0;
     }
 
diff --git a/crypto/evp/pmeth_check.c b/crypto/evp/pmeth_check.c
index 449ff88095..c9a5a7bc65 100644
--- a/crypto/evp/pmeth_check.c
+++ b/crypto/evp/pmeth_check.c
@@ -48,7 +48,7 @@ int EVP_PKEY_public_check(EVP_PKEY_CTX *ctx)
     int ok;
 
     if (pkey == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_PUBLIC_CHECK, EVP_R_NO_KEY_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEY_SET);
         return 0;
     }
 
@@ -71,7 +71,7 @@ int EVP_PKEY_public_check(EVP_PKEY_CTX *ctx)
     return pkey-&gt;ameth-&gt;pkey_public_check(pkey);
 #endif
  not_supported:
-    EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     return -2;
 }
 
@@ -81,7 +81,7 @@ int EVP_PKEY_param_check(EVP_PKEY_CTX *ctx)
     int ok;
 
     if (pkey == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_PARAM_CHECK, EVP_R_NO_KEY_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEY_SET);
         return 0;
     }
 
@@ -105,7 +105,7 @@ int EVP_PKEY_param_check(EVP_PKEY_CTX *ctx)
     return pkey-&gt;ameth-&gt;pkey_param_check(pkey);
 #endif
  not_supported:
-    EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     return -2;
 }
 
@@ -115,7 +115,7 @@ int EVP_PKEY_private_check(EVP_PKEY_CTX *ctx)
     int ok;
 
     if (pkey == NULL) {
-        EVPerr(0, EVP_R_NO_KEY_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEY_SET);
         return 0;
     }
 
@@ -123,7 +123,7 @@ int EVP_PKEY_private_check(EVP_PKEY_CTX *ctx)
         return ok;
 
     /* not supported for legacy keys */
-    EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     return -2;
 }
 
@@ -133,7 +133,7 @@ int EVP_PKEY_pairwise_check(EVP_PKEY_CTX *ctx)
     int ok;
 
     if (pkey == NULL) {
-        EVPerr(0, EVP_R_NO_KEY_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEY_SET);
         return 0;
     }
 
@@ -141,7 +141,7 @@ int EVP_PKEY_pairwise_check(EVP_PKEY_CTX *ctx)
         return ok;
 
     /* not supported for legacy keys */
-    EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     return -2;
 }
 
@@ -151,7 +151,7 @@ int EVP_PKEY_check(EVP_PKEY_CTX *ctx)
     int ok;
 
     if (pkey == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_CHECK, EVP_R_NO_KEY_SET);
+        ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEY_SET);
         return 0;
     }
 
@@ -174,7 +174,7 @@ int EVP_PKEY_check(EVP_PKEY_CTX *ctx)
     return pkey-&gt;ameth-&gt;pkey_check(pkey);
 #endif
  not_supported:
-    EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
     return -2;
 }
 
diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index 17a0a4704b..903e30acf0 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -119,7 +119,7 @@ EVP_PKEY_METHOD *EVP_PKEY_meth_new(int id, int flags)
 
     pmeth = OPENSSL_zalloc(sizeof(*pmeth));
     if (pmeth == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_METH_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -234,7 +234,7 @@ static EVP_PKEY_CTX *int_ctx_new(OSSL_LIB_CTX *libctx,
     /* Try to find an ENGINE which implements this method */
     if (e) {
         if (!ENGINE_init(e)) {
-            EVPerr(EVP_F_INT_CTX_NEW, ERR_R_ENGINE_LIB);
+            ERR_raise(ERR_LIB_EVP, ERR_R_ENGINE_LIB);
             return NULL;
         }
     } else {
@@ -285,7 +285,7 @@ static EVP_PKEY_CTX *int_ctx_new(OSSL_LIB_CTX *libctx,
                      * something is very wrong.
                      */
                     if (!ossl_assert(id == tmp_id)) {
-                        EVPerr(EVP_F_INT_CTX_NEW, ERR_R_INTERNAL_ERROR);
+                        ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
                         EVP_KEYMGMT_free(keymgmt);
                         return NULL;
                     }
@@ -296,11 +296,11 @@ static EVP_PKEY_CTX *int_ctx_new(OSSL_LIB_CTX *libctx,
     }
 
     if (pmeth == NULL &amp;&amp; keymgmt == NULL) {
-        EVPerr(EVP_F_INT_CTX_NEW, EVP_R_UNSUPPORTED_ALGORITHM);
+        ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_ALGORITHM);
     } else {
         ret = OPENSSL_zalloc(sizeof(*ret));
         if (ret == NULL)
-            EVPerr(EVP_F_INT_CTX_NEW, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
     }
 
 #if !defined(OPENSSL_NO_ENGINE) &amp;&amp; !defined(FIPS_MODULE)
@@ -458,13 +458,13 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
 # ifndef OPENSSL_NO_ENGINE
     /* Make sure it's safe to copy a pkey context using an ENGINE */
     if (pctx-&gt;engine &amp;&amp; !ENGINE_init(pctx-&gt;engine)) {
-        EVPerr(EVP_F_EVP_PKEY_CTX_DUP, ERR_R_ENGINE_LIB);
+        ERR_raise(ERR_LIB_EVP, ERR_R_ENGINE_LIB);
         return 0;
     }
 # endif
     rctx = OPENSSL_zalloc(sizeof(*rctx));
     if (rctx == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_CTX_DUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -581,12 +581,12 @@ int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth)
     if (app_pkey_methods == NULL) {
         app_pkey_methods = sk_EVP_PKEY_METHOD_new(pmeth_cmp);
         if (app_pkey_methods == NULL){
-            EVPerr(EVP_F_EVP_PKEY_METH_ADD0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     }
     if (!sk_EVP_PKEY_METHOD_push(app_pkey_methods, pmeth)) {
-        EVPerr(EVP_F_EVP_PKEY_METH_ADD0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     sk_EVP_PKEY_METHOD_sort(app_pkey_methods);
@@ -1455,12 +1455,12 @@ static int evp_pkey_ctx_ctrl_int(EVP_PKEY_CTX *ctx, int keytype, int optype,
      */
     if (ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;digest_custom == NULL) {
         if (ctx-&gt;operation == EVP_PKEY_OP_UNDEFINED) {
-            EVPerr(0, EVP_R_NO_OPERATION_SET);
+            ERR_raise(ERR_LIB_EVP, EVP_R_NO_OPERATION_SET);
             return -1;
         }
 
         if ((optype != -1) &amp;&amp; !(ctx-&gt;operation &amp; optype)) {
-            EVPerr(0, EVP_R_INVALID_OPERATION);
+            ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_OPERATION);
             return -1;
         }
     }
@@ -1471,7 +1471,7 @@ static int evp_pkey_ctx_ctrl_int(EVP_PKEY_CTX *ctx, int keytype, int optype,
     case EVP_PKEY_STATE_UNKNOWN:
     case EVP_PKEY_STATE_LEGACY:
         if (ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;ctrl == NULL) {
-            EVPerr(0, EVP_R_COMMAND_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_EVP, EVP_R_COMMAND_NOT_SUPPORTED);
             return -2;
         }
         if ((keytype != -1) &amp;&amp; (ctx-&gt;pmeth-&gt;pkey_id != keytype))
@@ -1480,7 +1480,7 @@ static int evp_pkey_ctx_ctrl_int(EVP_PKEY_CTX *ctx, int keytype, int optype,
         ret = ctx-&gt;pmeth-&gt;ctrl(ctx, cmd, p1, p2);
 
         if (ret == -2)
-            EVPerr(0, EVP_R_COMMAND_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_EVP, EVP_R_COMMAND_NOT_SUPPORTED);
         break;
     }
     return ret;
@@ -1492,7 +1492,7 @@ int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
     int ret = 0;
 
     if (ctx == NULL) {
-        EVPerr(0, EVP_R_COMMAND_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_COMMAND_NOT_SUPPORTED);
         return -2;
     }
     /* If unsupported, we don't want that reported here */
@@ -1619,7 +1619,7 @@ static int evp_pkey_ctx_ctrl_str_int(EVP_PKEY_CTX *ctx,
     int ret = 0;
 
     if (ctx == NULL) {
-        EVPerr(0, EVP_R_COMMAND_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_COMMAND_NOT_SUPPORTED);
         return -2;
     }
 
@@ -1629,7 +1629,7 @@ static int evp_pkey_ctx_ctrl_str_int(EVP_PKEY_CTX *ctx,
     case EVP_PKEY_STATE_UNKNOWN:
     case EVP_PKEY_STATE_LEGACY:
         if (ctx == NULL || ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;ctrl_str == NULL) {
-            EVPerr(0, EVP_R_COMMAND_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_EVP, EVP_R_COMMAND_NOT_SUPPORTED);
             return -2;
         }
         if (strcmp(name, &quot;digest&quot;) == 0)
@@ -1805,7 +1805,7 @@ int EVP_PKEY_CTX_md(EVP_PKEY_CTX *ctx, int optype, int cmd, const char *md)
     const EVP_MD *m;
 
     if (md == NULL || (m = EVP_get_digestbyname(md)) == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_CTX_MD, EVP_R_INVALID_DIGEST);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_DIGEST);
         return 0;
     }
     return EVP_PKEY_CTX_ctrl(ctx, -1, optype, cmd, 0, (void *)m);
diff --git a/crypto/evp/signature.c b/crypto/evp/signature.c
index 0ea8934689..89dc7e465f 100644
--- a/crypto/evp/signature.c
+++ b/crypto/evp/signature.c
@@ -368,7 +368,7 @@ static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, int operation)
     const char *supported_sig = NULL;
 
     if (ctx == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
@@ -443,14 +443,14 @@ static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, int operation)
         signature-&gt;newctx(ossl_provider_ctx(signature-&gt;prov), ctx-&gt;propquery);
     if (ctx-&gt;op.sig.sigprovctx == NULL) {
         /* The provider key can stay in the cache */
-        EVPerr(0, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         goto err;
     }
 
     switch (operation) {
     case EVP_PKEY_OP_SIGN:
         if (signature-&gt;sign_init == NULL) {
-            EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+            ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             ret = -2;
             goto err;
         }
@@ -458,7 +458,7 @@ static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, int operation)
         break;
     case EVP_PKEY_OP_VERIFY:
         if (signature-&gt;verify_init == NULL) {
-            EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+            ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             ret = -2;
             goto err;
         }
@@ -466,14 +466,14 @@ static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, int operation)
         break;
     case EVP_PKEY_OP_VERIFYRECOVER:
         if (signature-&gt;verify_recover_init == NULL) {
-            EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+            ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             ret = -2;
             goto err;
         }
         ret = signature-&gt;verify_recover_init(ctx-&gt;op.sig.sigprovctx, provkey);
         break;
     default:
-        EVPerr(0, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         goto err;
     }
 
@@ -497,7 +497,7 @@ static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, int operation)
             || (operation == EVP_PKEY_OP_VERIFY &amp;&amp; ctx-&gt;pmeth-&gt;verify == NULL)
             || (operation == EVP_PKEY_OP_VERIFYRECOVER
                 &amp;&amp; ctx-&gt;pmeth-&gt;verify_recover == NULL)) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
@@ -518,7 +518,7 @@ static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, int operation)
         ret = ctx-&gt;pmeth-&gt;verify_recover_init(ctx);
         break;
     default:
-        EVPerr(0, EVP_R_INITIALIZATION_ERROR);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         goto err;
     }
     if (ret &lt;= 0)
@@ -548,12 +548,12 @@ int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
     int ret;
 
     if (ctx == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
     if (ctx-&gt;operation != EVP_PKEY_OP_SIGN) {
-        EVPerr(0, EVP_R_OPERATON_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
         return -1;
     }
 
@@ -567,7 +567,7 @@ int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
  legacy:
 
     if (ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;sign == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
@@ -587,12 +587,12 @@ int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
     int ret;
 
     if (ctx == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
     if (ctx-&gt;operation != EVP_PKEY_OP_VERIFY) {
-        EVPerr(0, EVP_R_OPERATON_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
         return -1;
     }
 
@@ -605,7 +605,7 @@ int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
     return ret;
  legacy:
     if (ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;verify == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
@@ -624,12 +624,12 @@ int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
     int ret;
 
     if (ctx == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
 
     if (ctx-&gt;operation != EVP_PKEY_OP_VERIFYRECOVER) {
-        EVPerr(0, EVP_R_OPERATON_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
         return -1;
     }
 
@@ -643,7 +643,7 @@ int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
     return ret;
  legacy:
     if (ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;verify_recover == NULL) {
-        EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
     }
     M_check_autoarg(ctx, rout, routlen, EVP_F_EVP_PKEY_VERIFY_RECOVER)
diff --git a/crypto/ex_data.c b/crypto/ex_data.c
index 3b06c0b90e..5de99b4735 100644
--- a/crypto/ex_data.c
+++ b/crypto/ex_data.c
@@ -31,7 +31,7 @@ static EX_CALLBACKS *get_and_lock(OSSL_EX_DATA_GLOBAL *global, int class_index)
     EX_CALLBACKS *ip;
 
     if (class_index &lt; 0 || class_index &gt;= CRYPTO_EX_INDEX__COUNT) {
-        CRYPTOerr(CRYPTO_F_GET_AND_LOCK, ERR_R_PASSED_INVALID_ARGUMENT);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_PASSED_INVALID_ARGUMENT);
         return NULL;
     }
 
@@ -159,14 +159,14 @@ int crypto_get_ex_new_index_ex(OSSL_LIB_CTX *ctx, int class_index, long argl,
          * &quot;app_data&quot; routines use ex_data index zero.  See RT 3710. */
         if (ip-&gt;meth == NULL
             || !sk_EX_CALLBACK_push(ip-&gt;meth, NULL)) {
-            CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX_EX, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
 
     a = (EX_CALLBACK *)OPENSSL_malloc(sizeof(*a));
     if (a == NULL) {
-        CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX_EX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     a-&gt;argl = argl;
@@ -176,7 +176,7 @@ int crypto_get_ex_new_index_ex(OSSL_LIB_CTX *ctx, int class_index, long argl,
     a-&gt;free_func = free_func;
 
     if (!sk_EX_CALLBACK_push(ip-&gt;meth, NULL)) {
-        CRYPTOerr(CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX_EX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(a);
         goto err;
     }
@@ -235,7 +235,7 @@ int crypto_new_ex_data_ex(OSSL_LIB_CTX *ctx, int class_index, void *obj,
     CRYPTO_THREAD_unlock(global-&gt;ex_data_lock);
 
     if (mx &gt; 0 &amp;&amp; storage == NULL) {
-        CRYPTOerr(CRYPTO_F_CRYPTO_NEW_EX_DATA_EX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     for (i = 0; i &lt; mx; i++) {
@@ -301,7 +301,7 @@ int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
     if (mx == 0)
         return 1;
     if (storage == NULL) {
-        CRYPTOerr(CRYPTO_F_CRYPTO_DUP_EX_DATA, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     /*
@@ -434,20 +434,20 @@ int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)
 
     if (ad-&gt;sk == NULL) {
         if ((ad-&gt;sk = sk_void_new_null()) == NULL) {
-            CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     }
 
     for (i = sk_void_num(ad-&gt;sk); i &lt;= idx; ++i) {
         if (!sk_void_push(ad-&gt;sk, NULL)) {
-            CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     }
     if (sk_void_set(ad-&gt;sk, idx, val) != val) {
         /* Probably the index is out of bounds */
-        CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_PASSED_INVALID_ARGUMENT);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_PASSED_INVALID_ARGUMENT);
         return 0;
     }
     return 1;
diff --git a/crypto/ffc/ffc_params_generate.c b/crypto/ffc/ffc_params_generate.c
index 815b38efbf..9285f93c05 100644
--- a/crypto/ffc/ffc_params_generate.c
+++ b/crypto/ffc/ffc_params_generate.c
@@ -46,7 +46,7 @@ static int ffc_validate_LN(size_t L, size_t N, int type, int verify)
         if (L == 2048 &amp;&amp; (N == 224 || N == 256))
             return 112;
 # ifndef OPENSSL_NO_DH
-        DHerr(0, DH_R_BAD_FFC_PARAMETERS);
+        ERR_raise(ERR_LIB_DH, DH_R_BAD_FFC_PARAMETERS);
 # endif
     } else if (type == FFC_PARAM_TYPE_DSA) {
         /* Valid DSA L,N parameters from FIPS 186-4 Section 4.2 */
@@ -58,7 +58,7 @@ static int ffc_validate_LN(size_t L, size_t N, int type, int verify)
         if (L == 3072 &amp;&amp; N == 256)
             return 128;
 # ifndef OPENSSL_NO_DSA
-        DSAerr(0, DSA_R_BAD_FFC_PARAMETERS);
+        ERR_raise(ERR_LIB_DSA, DSA_R_BAD_FFC_PARAMETERS);
 # endif
     }
     return 0;
@@ -74,7 +74,7 @@ static int ffc_validate_LN(size_t L, size_t N, int type, int verify)
         if (L == 2048 &amp;&amp; (N == 224 || N == 256))
             return 112;
 # ifndef OPENSSL_NO_DH
-        DHerr(0, DH_R_BAD_FFC_PARAMETERS);
+        ERR_raise(ERR_LIB_DH, DH_R_BAD_FFC_PARAMETERS);
 # endif
     } else if (type == FFC_PARAM_TYPE_DSA) {
         if (L == 1024 &amp;&amp; N == 160)
@@ -84,7 +84,7 @@ static int ffc_validate_LN(size_t L, size_t N, int type, int verify)
         if (L == 3072 &amp;&amp; N == 256)
             return 128;
 # ifndef OPENSSL_NO_DSA
-        DSAerr(0, DSA_R_BAD_FFC_PARAMETERS);
+        ERR_raise(ERR_LIB_DSA, DSA_R_BAD_FFC_PARAMETERS);
 # endif
     }
     return 0;
diff --git a/crypto/http/http_client.c b/crypto/http/http_client.c
index 1a68228548..d8a6bdec31 100644
--- a/crypto/http/http_client.c
+++ b/crypto/http/http_client.c
@@ -84,7 +84,7 @@ OSSL_HTTP_REQ_CTX *OSSL_HTTP_REQ_CTX_new(BIO *wbio, BIO *rbio,
     OSSL_HTTP_REQ_CTX *rctx;
 
     if (wbio == NULL || rbio == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
 
@@ -121,7 +121,7 @@ void OSSL_HTTP_REQ_CTX_free(OSSL_HTTP_REQ_CTX *rctx)
 BIO *OSSL_HTTP_REQ_CTX_get0_mem_bio(OSSL_HTTP_REQ_CTX *rctx)
 {
     if (rctx == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     return rctx-&gt;mem;
@@ -131,7 +131,7 @@ void OSSL_HTTP_REQ_CTX_set_max_response_length(OSSL_HTTP_REQ_CTX *rctx,
                                                unsigned long len)
 {
     if (rctx == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return;
     }
     rctx-&gt;max_resp_len = len != 0 ? len : HTTP_DEFAULT_MAX_RESP_LEN;
@@ -145,7 +145,7 @@ int OSSL_HTTP_REQ_CTX_header(OSSL_HTTP_REQ_CTX *rctx, const char *server,
                              const char *port, const char *path)
 {
     if (rctx == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -179,7 +179,7 @@ int OSSL_HTTP_REQ_CTX_add1_header(OSSL_HTTP_REQ_CTX *rctx,
                                   const char *name, const char *value)
 {
     if (rctx == NULL || name == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -204,7 +204,7 @@ static int OSSL_HTTP_REQ_CTX_content(OSSL_HTTP_REQ_CTX *rctx,
     long req_len;
 
     if (rctx == NULL || req_mem == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -225,7 +225,7 @@ BIO *HTTP_asn1_item2bio(const ASN1_ITEM *it, const ASN1_VALUE *val)
     BIO *res;
 
     if (it == NULL || val == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
 
@@ -245,7 +245,7 @@ int OSSL_HTTP_REQ_CTX_i2d(OSSL_HTTP_REQ_CTX *rctx, const char *content_type,
     int res;
 
     if (rctx == NULL || it == NULL || req == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -294,7 +294,7 @@ OSSL_HTTP_REQ_CTX *HTTP_REQ_CTX_new(BIO *wbio, BIO *rbio, int use_http_proxy,
     OSSL_HTTP_REQ_CTX *rctx;
 
     if (use_http_proxy &amp;&amp; (server == NULL || port == NULL)) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     /* remaining parameters are checked indirectly by the functions called */
@@ -330,7 +330,7 @@ static int parse_http_line1(char *line)
     for (code = line; *code != '\0' &amp;&amp; !ossl_isspace(*code); code++)
         continue;
     if (*code == '\0') {
-        HTTPerr(0, HTTP_R_RESPONSE_PARSE_ERROR);
+        ERR_raise(ERR_LIB_HTTP, HTTP_R_RESPONSE_PARSE_ERROR);
         return 0;
     }
 
@@ -339,7 +339,7 @@ static int parse_http_line1(char *line)
         code++;
 
     if (*code == '\0') {
-        HTTPerr(0, HTTP_R_RESPONSE_PARSE_ERROR);
+        ERR_raise(ERR_LIB_HTTP, HTTP_R_RESPONSE_PARSE_ERROR);
         return 0;
     }
 
@@ -348,7 +348,7 @@ static int parse_http_line1(char *line)
         continue;
 
     if (*reason == '\0') {
-        HTTPerr(0, HTTP_R_RESPONSE_PARSE_ERROR);
+        ERR_raise(ERR_LIB_HTTP, HTTP_R_RESPONSE_PARSE_ERROR);
         return 0;
     }
 
@@ -383,41 +383,26 @@ static int parse_http_line1(char *line)
         return retcode;
     default:
         if (retcode &lt; 400)
-            HTTPerr(0, HTTP_R_STATUS_CODE_UNSUPPORTED);
+            retcode = HTTP_R_STATUS_CODE_UNSUPPORTED;
         else
-            HTTPerr(0, HTTP_R_RECEIVED_ERROR);
+            retcode = HTTP_R_RECEIVED_ERROR;
         if (*reason == '\0')
-            ERR_add_error_data(2, &quot;Code=&quot;, code);
+            ERR_raise_data(ERR_LIB_HTTP, retcode, &quot;Code=%s&quot;, code);
         else
-            ERR_add_error_data(4, &quot;Code=&quot;, code, &quot;,Reason=&quot;, reason);
+            ERR_raise_data(ERR_LIB_HTTP, retcode,
+                           &quot;Code=%s, Reason=%s&quot;, code, reason);
         return 0;
     }
 }
 
 static int check_set_resp_len(OSSL_HTTP_REQ_CTX *rctx, unsigned long len)
 {
-    const char *tag = NULL;
-    unsigned long val = 0;
-
-    if (len &gt; rctx-&gt;max_resp_len) {
-        HTTPerr(0, HTTP_R_MAX_RESP_LEN_EXCEEDED);
-        tag = &quot;,max=&quot;;
-        val = rctx-&gt;max_resp_len;
-    }
-    if (rctx-&gt;resp_len != 0 &amp;&amp; rctx-&gt;resp_len != len) {
-        HTTPerr(0, HTTP_R_INCONSISTENT_CONTENT_LENGTH);
-        tag = &quot;,before=&quot;;
-        val = rctx-&gt;resp_len;
-    }
-    if (tag != NULL) {
-        char len_str[32];
-        char str[32];
-
-        BIO_snprintf(len_str, sizeof(len_str), &quot;%lu&quot;, len);
-        BIO_snprintf(str, sizeof(str), &quot;%lu&quot;, val);
-        ERR_add_error_data(4, &quot;length=&quot;, len_str, tag, str);
-        return 0;
-    }
+    if (len &gt; rctx-&gt;max_resp_len)
+        ERR_raise_data(ERR_LIB_HTTP, HTTP_R_MAX_RESP_LEN_EXCEEDED,
+                       &quot;length=%lu, max=%lu&quot;, len, rctx-&gt;max_resp_len);
+    if (rctx-&gt;resp_len != 0 &amp;&amp; rctx-&gt;resp_len != len)
+        ERR_raise_data(ERR_LIB_HTTP, HTTP_R_INCONSISTENT_CONTENT_LENGTH,
+                       &quot;length=%lu, before=%lu&quot;, len, rctx-&gt;resp_len);
     rctx-&gt;resp_len = len;
     return 1;
 }
@@ -435,7 +420,7 @@ int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx)
     char *key, *value, *line_end = NULL;
 
     if (rctx == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -539,7 +524,7 @@ int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx)
 
         /* Don't allow excessive lines */
         if (n == rctx-&gt;iobuflen) {
-            HTTPerr(0, HTTP_R_RESPONSE_LINE_TOO_LONG);
+            ERR_raise(ERR_LIB_HTTP, HTTP_R_RESPONSE_LINE_TOO_LONG);
             rctx-&gt;state = OHS_ERROR;
             return 0;
         }
@@ -556,7 +541,7 @@ int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx)
                     rctx-&gt;state = OHS_REDIRECT;
                     goto next_line;
                 }
-                HTTPerr(0, HTTP_R_REDIRECTION_NOT_ENABLED);
+                ERR_raise(ERR_LIB_HTTP, HTTP_R_REDIRECTION_NOT_ENABLED);
                 /* redirection is not supported/recommended for POST */
                 /* fall through */
             default:
@@ -585,9 +570,9 @@ int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx)
             if (rctx-&gt;expected_ct != NULL
                     &amp;&amp; strcasecmp(key, &quot;Content-Type&quot;) == 0) {
                 if (strcasecmp(rctx-&gt;expected_ct, value) != 0) {
-                    HTTPerr(0, HTTP_R_UNEXPECTED_CONTENT_TYPE);
-                    ERR_add_error_data(4, &quot;expected=&quot;, rctx-&gt;expected_ct,
-                                       &quot;,actual=&quot;, value);
+                    ERR_raise_data(ERR_LIB_HTTP, HTTP_R_UNEXPECTED_CONTENT_TYPE,
+                                   &quot;expected=%s, actual=%s&quot;,
+                                   rctx-&gt;expected_ct, value);
                     return 0;
                 }
                 rctx-&gt;expected_ct = NULL; /* content-type has been found */
@@ -595,8 +580,9 @@ int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx)
             if (strcasecmp(key, &quot;Content-Length&quot;) == 0) {
                 resp_len = strtoul(value, &amp;line_end, 10);
                 if (line_end == value || *line_end != '\0') {
-                    HTTPerr(0, HTTP_R_ERROR_PARSING_CONTENT_LENGTH);
-                    ERR_add_error_data(2, &quot;input=&quot;, value);
+                    ERR_raise_data(ERR_LIB_HTTP,
+                                   HTTP_R_ERROR_PARSING_CONTENT_LENGTH,
+                                   &quot;input=%s&quot;, value);
                     return 0;
                 }
                 if (!check_set_resp_len(rctx, resp_len))
@@ -613,13 +599,13 @@ int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx)
             goto next_line;
 
         if (rctx-&gt;expected_ct != NULL) {
-            HTTPerr(0, HTTP_R_MISSING_CONTENT_TYPE);
-            ERR_add_error_data(2, &quot;expected=&quot;, rctx-&gt;expected_ct);
+            ERR_raise_data(ERR_LIB_HTTP, HTTP_R_MISSING_CONTENT_TYPE,
+                           &quot;expected=%s&quot;, rctx-&gt;expected_ct);
             return 0;
         }
         if (rctx-&gt;state == OHS_REDIRECT) {
             /* http status code indicated redirect but there was no Location */
-            HTTPerr(0, HTTP_R_MISSING_REDIRECT_LOCATION);
+            ERR_raise(ERR_LIB_HTTP, HTTP_R_MISSING_REDIRECT_LOCATION);
             return 0;
         }
 
@@ -643,7 +629,7 @@ int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx)
 
         /* Check it is an ASN1 SEQUENCE */
         if (*p++ != (V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED)) {
-            HTTPerr(0, HTTP_R_MISSING_ASN1_ENCODING);
+            ERR_raise(ERR_LIB_HTTP, HTTP_R_MISSING_ASN1_ENCODING);
             return 0;
         }
 
@@ -658,7 +644,7 @@ int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx)
             n = *p &amp; 0x7F;
             /* Not NDEF or excessive length */
             if (n == 0 || (n &gt; 4)) {
-                HTTPerr(0, HTTP_R_ERROR_PARSING_ASN1_LENGTH);
+                ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_PARSING_ASN1_LENGTH);
                 return 0;
             }
             p++;
@@ -739,7 +725,7 @@ static ASN1_VALUE *BIO_mem_d2i(BIO *mem, const ASN1_ITEM *it)
     ASN1_VALUE *resp = ASN1_item_d2i(NULL, &amp;p, len, it);
 
     if (resp == NULL)
-        HTTPerr(0, HTTP_R_RESPONSE_PARSE_ERROR);
+        ERR_raise(ERR_LIB_HTTP, HTTP_R_RESPONSE_PARSE_ERROR);
     return resp;
 }
 
@@ -749,7 +735,7 @@ static BIO *OSSL_HTTP_REQ_CTX_transfer(OSSL_HTTP_REQ_CTX *rctx)
     int rv;
 
     if (rctx == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
 
@@ -767,9 +753,9 @@ static BIO *OSSL_HTTP_REQ_CTX_transfer(OSSL_HTTP_REQ_CTX *rctx)
     if (rv == 0) {
         if (rctx-&gt;redirection_url == NULL) { /* an error occurred */
             if (sending &amp;&amp; (rctx-&gt;state &amp; OHS_NOREAD) != 0)
-                HTTPerr(0, HTTP_R_ERROR_SENDING);
+                ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_SENDING);
             else
-                HTTPerr(0, HTTP_R_ERROR_RECEIVING);
+                ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_RECEIVING);
         }
         return NULL;
     }
@@ -783,7 +769,7 @@ ASN1_VALUE *OSSL_HTTP_REQ_CTX_sendreq_d2i(OSSL_HTTP_REQ_CTX *rctx,
                                           const ASN1_ITEM *it)
 {
     if (rctx == NULL || it == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     return BIO_mem_d2i(OSSL_HTTP_REQ_CTX_transfer(rctx), it);
@@ -845,11 +831,11 @@ BIO *OSSL_HTTP_transfer(const char *server, const char *port, const char *path,
         *redirection_url = NULL; /* do this beforehand to prevent dbl free */
 
     if (use_ssl &amp;&amp; bio_update_fn == NULL) {
-        HTTPerr(0, HTTP_R_TLS_NOT_ENABLED);
+        ERR_raise(ERR_LIB_HTTP, HTTP_R_TLS_NOT_ENABLED);
         return NULL;
     }
     if (rbio != NULL &amp;&amp; (bio == NULL || bio_update_fn != NULL)) {
-        HTTPerr(0, ERR_R_PASSED_INVALID_ARGUMENT);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_INVALID_ARGUMENT);
         return NULL;
     }
 
@@ -858,7 +844,7 @@ BIO *OSSL_HTTP_transfer(const char *server, const char *port, const char *path,
     } else {
 #ifndef OPENSSL_NO_SOCK
         if (server == NULL) {
-            HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+            ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
             return NULL;
         }
         if (*port == '\0')
@@ -869,7 +855,7 @@ BIO *OSSL_HTTP_transfer(const char *server, const char *port, const char *path,
         if ((cbio = HTTP_new_bio(server, port, proxy)) == NULL)
             return NULL;
 #else
-        HTTPerr(0, HTTP_R_SOCK_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_HTTP, HTTP_R_SOCK_NOT_SUPPORTED);
         return NULL;
 #endif
     }
@@ -902,7 +888,7 @@ BIO *OSSL_HTTP_transfer(const char *server, const char *port, const char *path,
     if (resp == NULL) {
         if (rctx-&gt;redirection_url != NULL) {
             if (redirection_url == NULL)
-                HTTPerr(0, HTTP_R_REDIRECTION_NOT_ENABLED);
+                ERR_raise(ERR_LIB_HTTP, HTTP_R_REDIRECTION_NOT_ENABLED);
             else
                 /* may be NULL if out of memory: */
                 *redirection_url = OPENSSL_strdup(rctx-&gt;redirection_url);
@@ -965,14 +951,14 @@ static int redirection_ok(int n_redir, const char *old_url, const char *new_url)
     size_t https_len = strlen(OSSL_HTTPS_NAME&quot;:&quot;);
 
     if (n_redir &gt;= HTTP_VERSION_MAX_REDIRECTIONS) {
-        HTTPerr(0, HTTP_R_TOO_MANY_REDIRECTIONS);
+        ERR_raise(ERR_LIB_HTTP, HTTP_R_TOO_MANY_REDIRECTIONS);
         return 0;
     }
     if (*new_url == '/') /* redirection to same server =&gt; same protocol */
         return 1;
     if (strncmp(old_url, OSSL_HTTPS_NAME&quot;:&quot;, https_len) == 0 &amp;&amp;
         strncmp(new_url, OSSL_HTTPS_NAME&quot;:&quot;, https_len) != 0) {
-        HTTPerr(0, HTTP_R_REDIRECTION_FROM_HTTPS_TO_HTTP);
+        ERR_raise(ERR_LIB_HTTP, HTTP_R_REDIRECTION_FROM_HTTPS_TO_HTTP);
         return 0;
     }
     return 1;
@@ -996,7 +982,7 @@ BIO *OSSL_HTTP_get(const char *url, const char *proxy, const char *no_proxy,
     BIO *resp = NULL;
 
     if (url == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if ((current_url = OPENSSL_strdup(url)) == NULL)
@@ -1053,7 +1039,7 @@ ASN1_VALUE *OSSL_HTTP_get_asn1(const char *url,
     ASN1_VALUE *resp = NULL;
 
     if (url == NULL || it == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if ((mem = OSSL_HTTP_get(url, proxy, no_proxy, bio, rbio, bio_update_fn,
@@ -1083,7 +1069,7 @@ ASN1_VALUE *OSSL_HTTP_post_asn1(const char *server, const char *port,
     ASN1_VALUE *resp = NULL;
 
     if (req == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     /* remaining parameters are checked indirectly */
@@ -1147,7 +1133,7 @@ int OSSL_HTTP_proxy_connect(BIO *bio, const char *server, const char *port,
 
     if (bio == NULL || server == NULL
             || (bio_err != NULL &amp;&amp; prog == NULL)) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         goto end;
     }
     if (port == NULL || *port == '\0')
@@ -1223,7 +1209,7 @@ int OSSL_HTTP_proxy_connect(BIO *bio, const char *server, const char *port,
 
         /* RFC 7231 4.3.6: any 2xx status code is valid */
         if (strncmp(mbuf, HTTP_PREFIX, strlen(HTTP_PREFIX)) != 0) {
-            HTTPerr(0, HTTP_R_RESPONSE_PARSE_ERROR);
+            ERR_raise(ERR_LIB_HTTP, HTTP_R_RESPONSE_PARSE_ERROR);
             BIO_printf(bio_err, &quot;%s: HTTP CONNECT failed, non-HTTP response\n&quot;,
                        prog);
             /* Wrong protocol, not even HTTP, so stop reading headers */
@@ -1231,7 +1217,7 @@ int OSSL_HTTP_proxy_connect(BIO *bio, const char *server, const char *port,
         }
         mbufp = mbuf + strlen(HTTP_PREFIX);
         if (strncmp(mbufp, HTTP_VERSION_PATT, strlen(HTTP_VERSION_PATT)) != 0) {
-            HTTPerr(0, HTTP_R_RECEIVED_WRONG_HTTP_VERSION);
+            ERR_raise(ERR_LIB_HTTP, HTTP_R_RECEIVED_WRONG_HTTP_VERSION);
             BIO_printf(bio_err,
                        &quot;%s: HTTP CONNECT failed, bad HTTP version %.*s\n&quot;,
                        prog, HTTP_VERSION_STR_LEN, mbufp);
@@ -1244,8 +1230,8 @@ int OSSL_HTTP_proxy_connect(BIO *bio, const char *server, const char *port,
             while (read_len &gt; 0 &amp;&amp; ossl_isspace(mbuf[read_len - 1]))
                 read_len--;
             mbuf[read_len] = '\0';
-            HTTPerr(0, HTTP_R_CONNECT_FAILURE);
-            ERR_add_error_data(2, &quot;Reason=&quot;, mbufp);
+            ERR_raise_data(ERR_LIB_HTTP, HTTP_R_CONNECT_FAILURE,
+                           &quot;Reason=%s&quot;, mbufp);
             BIO_printf(bio_err, &quot;%s: HTTP CONNECT failed, Reason=%s\n&quot;,
                        prog, mbufp);
             goto end;
diff --git a/crypto/http/http_lib.c b/crypto/http/http_lib.c
index be790bda90..028ef12383 100644
--- a/crypto/http/http_lib.c
+++ b/crypto/http/http_lib.c
@@ -38,7 +38,7 @@ int OSSL_HTTP_parse_url(const char *url, char **phost, char **pport,
         *pssl = 0;
 
     if (url == NULL) {
-        HTTPerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
@@ -58,7 +58,7 @@ int OSSL_HTTP_parse_url(const char *url, char **phost, char **pport,
             port = OSSL_HTTPS_PORT;
             portnum = 443;
         } else if (strcmp(buf, OSSL_HTTP_NAME) != 0) {
-            HTTPerr(0, HTTP_R_INVALID_URL_PREFIX);
+            ERR_raise(ERR_LIB_HTTP, HTTP_R_INVALID_URL_PREFIX);
             goto err;
         }
         p += 3;
@@ -95,7 +95,7 @@ int OSSL_HTTP_parse_url(const char *url, char **phost, char **pport,
             if (p == port || (*p != '\0' &amp;&amp; *p != '/'))
                 goto parse_err;
             if (portnum &lt;= 0 || portnum &gt;= 65536) {
-                HTTPerr(0, HTTP_R_INVALID_PORT_NUMBER);
+                ERR_raise(ERR_LIB_HTTP, HTTP_R_INVALID_PORT_NUMBER);
                 goto err;
             }
         }
@@ -109,7 +109,7 @@ int OSSL_HTTP_parse_url(const char *url, char **phost, char **pport,
     if (*path == '\0') {
         path = &quot;/&quot;;
     } else if (*path != '/') {
-        HTTPerr(0, HTTP_R_INVALID_URL_PATH);
+        ERR_raise(ERR_LIB_HTTP, HTTP_R_INVALID_URL_PATH);
         goto parse_err;
     }
 
@@ -126,7 +126,7 @@ int OSSL_HTTP_parse_url(const char *url, char **phost, char **pport,
     return 1;
 
  parse_err:
-    HTTPerr(0, HTTP_R_ERROR_PARSING_URL);
+    ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_PARSING_URL);
 
  err:
     if (ppath != NULL) {
diff --git a/crypto/init.c b/crypto/init.c
index f7c7d59f55..ba8706655b 100644
--- a/crypto/init.c
+++ b/crypto/init.c
@@ -463,7 +463,7 @@ int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings)
 
     if (stopped) {
         if (!(opts &amp; OPENSSL_INIT_BASE_ONLY))
-            CRYPTOerr(CRYPTO_F_OPENSSL_INIT_CRYPTO, ERR_R_INIT_FAIL);
+            ERR_raise(ERR_LIB_CRYPTO, ERR_R_INIT_FAIL);
         return 0;
     }
 
@@ -655,7 +655,7 @@ int OPENSSL_atexit(void (*handler)(void))
 #endif
 
     if ((newhand = OPENSSL_malloc(sizeof(*newhand))) == NULL) {
-        CRYPTOerr(CRYPTO_F_OPENSSL_ATEXIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/lhash/lhash.c b/crypto/lhash/lhash.c
index 76379a93f6..e1cf6329a4 100644
--- a/crypto/lhash/lhash.c
+++ b/crypto/lhash/lhash.c
@@ -52,7 +52,7 @@ OPENSSL_LHASH *OPENSSL_LH_new(OPENSSL_LH_HASHFUNC h, OPENSSL_LH_COMPFUNC c)
         /*
          * Do not set the error code, because the ERR code uses LHASH
          * and we want to avoid possible endless error loop.
-         * CRYPTOerr(CRYPTO_F_OPENSSL_LH_NEW, ERR_R_MALLOC_FAILURE);
+         * ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
          */
         return NULL;
     }
diff --git a/crypto/modes/ocb128.c b/crypto/modes/ocb128.c
index 7886700533..106437137a 100644
--- a/crypto/modes/ocb128.c
+++ b/crypto/modes/ocb128.c
@@ -156,7 +156,7 @@ int CRYPTO_ocb128_init(OCB128_CONTEXT *ctx, void *keyenc, void *keydec,
     ctx-&gt;l_index = 0;
     ctx-&gt;max_l_index = 5;
     if ((ctx-&gt;l = OPENSSL_malloc(ctx-&gt;max_l_index * 16)) == NULL) {
-        CRYPTOerr(CRYPTO_F_CRYPTO_OCB128_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -203,7 +203,7 @@ int CRYPTO_ocb128_copy_ctx(OCB128_CONTEXT *dest, OCB128_CONTEXT *src,
         dest-&gt;keydec = keydec;
     if (src-&gt;l) {
         if ((dest-&gt;l = OPENSSL_malloc(src-&gt;max_l_index * 16)) == NULL) {
-            CRYPTOerr(CRYPTO_F_CRYPTO_OCB128_COPY_CTX, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         memcpy(dest-&gt;l, src-&gt;l, (src-&gt;l_index + 1) * 16);
diff --git a/crypto/o_fopen.c b/crypto/o_fopen.c
index b2eeeac712..9e06afc4e1 100644
--- a/crypto/o_fopen.c
+++ b/crypto/o_fopen.c
@@ -88,7 +88,7 @@ FILE *openssl_fopen(const char *filename, const char *mode)
             char lastchar;
 
             if ((newname = OPENSSL_malloc(strlen(filename) + 1)) == NULL) {
-                CRYPTOerr(CRYPTO_F_OPENSSL_FOPEN, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
                 return NULL;
             }
 
diff --git a/crypto/o_str.c b/crypto/o_str.c
index cfc401427d..933133a05c 100644
--- a/crypto/o_str.c
+++ b/crypto/o_str.c
@@ -54,7 +54,7 @@ void *CRYPTO_memdup(const void *data, size_t siz, const char* file, int line)
 
     ret = CRYPTO_malloc(siz, file, line);
     if (ret == NULL) {
-        CRYPTOerr(CRYPTO_F_CRYPTO_MEMDUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     return memcpy(ret, data, siz);
@@ -148,19 +148,19 @@ static int hexstr2buf_sep(unsigned char *buf, size_t buf_n, size_t *buflen,
             continue;
         cl = *p++;
         if (!cl) {
-            CRYPTOerr(0, CRYPTO_R_ODD_NUMBER_OF_DIGITS);
+            ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_ODD_NUMBER_OF_DIGITS);
             return 0;
         }
         cli = OPENSSL_hexchar2int(cl);
         chi = OPENSSL_hexchar2int(ch);
         if (cli &lt; 0 || chi &lt; 0) {
-            CRYPTOerr(0, CRYPTO_R_ILLEGAL_HEX_DIGIT);
+            ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_ILLEGAL_HEX_DIGIT);
             return 0;
         }
         cnt++;
         if (q != NULL) {
             if (cnt &gt; buf_n) {
-                CRYPTOerr(0, CRYPTO_R_TOO_SMALL_BUFFER);
+                ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_TOO_SMALL_BUFFER);
                 return 0;
             }
             *q++ = (unsigned char)((chi &lt;&lt; 4) | cli);
@@ -189,7 +189,7 @@ unsigned char *openssl_hexstr2buf_sep(const char *str, long *buflen,
 
     buf_n = strlen(str) &gt;&gt; 1;
     if ((buf = OPENSSL_malloc(buf_n)) == NULL) {
-        CRYPTOerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -227,7 +227,7 @@ static int buf2hexstr_sep(char *str, size_t str_n, size_t *strlen,
         return 1;
 
     if (str_n &lt; (unsigned long)len) {
-        CRYPTOerr(0, CRYPTO_R_TOO_SMALL_BUFFER);
+        ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_TOO_SMALL_BUFFER);
         return 0;
     }
 
@@ -264,7 +264,7 @@ char *openssl_buf2hexstr_sep(const unsigned char *buf, long buflen, char sep)
 
     tmp_n = (sep != CH_ZERO) ? buflen * 3 : 1 + buflen * 2;
     if ((tmp = OPENSSL_malloc(tmp_n)) == NULL) {
-        CRYPTOerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/objects/o_names.c b/crypto/objects/o_names.c
index 5835ab6f50..f26b4020d4 100644
--- a/crypto/objects/o_names.c
+++ b/crypto/objects/o_names.c
@@ -99,7 +99,7 @@ int OBJ_NAME_new_index(unsigned long (*hash_func) (const char *),
     for (i = sk_NAME_FUNCS_num(name_funcs_stack); i &lt; names_type_num; i++) {
         name_funcs = OPENSSL_zalloc(sizeof(*name_funcs));
         if (name_funcs == NULL) {
-            OBJerr(OBJ_F_OBJ_NAME_NEW_INDEX, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_OBJ, ERR_R_MALLOC_FAILURE);
             ret = 0;
             goto out;
         }
@@ -108,7 +108,7 @@ int OBJ_NAME_new_index(unsigned long (*hash_func) (const char *),
         push = sk_NAME_FUNCS_push(name_funcs_stack, name_funcs);
 
         if (!push) {
-            OBJerr(OBJ_F_OBJ_NAME_NEW_INDEX, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_OBJ, ERR_R_MALLOC_FAILURE);
             OPENSSL_free(name_funcs);
             ret = 0;
             goto out;
diff --git a/crypto/objects/obj_dat.c b/crypto/objects/obj_dat.c
index 010cfa89bb..a3cb874728 100644
--- a/crypto/objects/obj_dat.c
+++ b/crypto/objects/obj_dat.c
@@ -209,7 +209,7 @@ int OBJ_add_object(const ASN1_OBJECT *obj)
 
     return o-&gt;nid;
  err2:
-    OBJerr(OBJ_F_OBJ_ADD_OBJECT, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_OBJ, ERR_R_MALLOC_FAILURE);
  err:
     for (i = ADDED_DATA; i &lt;= ADDED_NID; i++)
         OPENSSL_free(ao[i]);
@@ -224,7 +224,7 @@ ASN1_OBJECT *OBJ_nid2obj(int n)
 
     if ((n &gt;= 0) &amp;&amp; (n &lt; NUM_NID)) {
         if ((n != NID_undef) &amp;&amp; (nid_objs[n].nid == NID_undef)) {
-            OBJerr(OBJ_F_OBJ_NID2OBJ, OBJ_R_UNKNOWN_NID);
+            ERR_raise(ERR_LIB_OBJ, OBJ_R_UNKNOWN_NID);
             return NULL;
         }
         return (ASN1_OBJECT *)&amp;(nid_objs[n]);
@@ -243,7 +243,7 @@ ASN1_OBJECT *OBJ_nid2obj(int n)
     if (adp != NULL)
         return adp-&gt;obj;
 
-    OBJerr(OBJ_F_OBJ_NID2OBJ, OBJ_R_UNKNOWN_NID);
+    ERR_raise(ERR_LIB_OBJ, OBJ_R_UNKNOWN_NID);
     return NULL;
 }
 
@@ -254,7 +254,7 @@ const char *OBJ_nid2sn(int n)
 
     if ((n &gt;= 0) &amp;&amp; (n &lt; NUM_NID)) {
         if ((n != NID_undef) &amp;&amp; (nid_objs[n].nid == NID_undef)) {
-            OBJerr(OBJ_F_OBJ_NID2SN, OBJ_R_UNKNOWN_NID);
+            ERR_raise(ERR_LIB_OBJ, OBJ_R_UNKNOWN_NID);
             return NULL;
         }
         return nid_objs[n].sn;
@@ -273,7 +273,7 @@ const char *OBJ_nid2sn(int n)
     if (adp != NULL)
         return adp-&gt;obj-&gt;sn;
 
-    OBJerr(OBJ_F_OBJ_NID2SN, OBJ_R_UNKNOWN_NID);
+    ERR_raise(ERR_LIB_OBJ, OBJ_R_UNKNOWN_NID);
     return NULL;
 }
 
@@ -284,7 +284,7 @@ const char *OBJ_nid2ln(int n)
 
     if ((n &gt;= 0) &amp;&amp; (n &lt; NUM_NID)) {
         if ((n != NID_undef) &amp;&amp; (nid_objs[n].nid == NID_undef)) {
-            OBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);
+            ERR_raise(ERR_LIB_OBJ, OBJ_R_UNKNOWN_NID);
             return NULL;
         }
         return nid_objs[n].ln;
@@ -303,7 +303,7 @@ const char *OBJ_nid2ln(int n)
     if (adp != NULL)
         return adp-&gt;obj-&gt;ln;
 
-    OBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);
+    ERR_raise(ERR_LIB_OBJ, OBJ_R_UNKNOWN_NID);
     return NULL;
 }
 
@@ -373,7 +373,7 @@ ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)
             ((nid = OBJ_ln2nid(s)) != NID_undef))
             return OBJ_nid2obj(nid);
         if (!ossl_isdigit(*s)) {
-            OBJerr(OBJ_F_OBJ_TXT2OBJ, OBJ_R_UNKNOWN_OBJECT_NAME);
+            ERR_raise(ERR_LIB_OBJ, OBJ_R_UNKNOWN_OBJECT_NAME);
             return NULL;
         }
     }
@@ -393,7 +393,7 @@ ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)
         return NULL;
 
     if ((buf = OPENSSL_malloc(j)) == NULL) {
-        OBJerr(OBJ_F_OBJ_TXT2OBJ, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_OBJ, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -697,7 +697,7 @@ int OBJ_create(const char *oid, const char *sn, const char *ln)
     /* Check to see if short or long name already present */
     if ((sn != NULL &amp;&amp; OBJ_sn2nid(sn) != NID_undef)
             || (ln != NULL &amp;&amp; OBJ_ln2nid(ln) != NID_undef)) {
-        OBJerr(OBJ_F_OBJ_CREATE, OBJ_R_OID_EXISTS);
+        ERR_raise(ERR_LIB_OBJ, OBJ_R_OID_EXISTS);
         return 0;
     }
 
@@ -708,7 +708,7 @@ int OBJ_create(const char *oid, const char *sn, const char *ln)
 
     /* If NID is not NID_undef then object already exists */
     if (OBJ_obj2nid(tmpoid) != NID_undef) {
-        OBJerr(OBJ_F_OBJ_CREATE, OBJ_R_OID_EXISTS);
+        ERR_raise(ERR_LIB_OBJ, OBJ_R_OID_EXISTS);
         goto err;
     }
 
diff --git a/crypto/objects/obj_lib.c b/crypto/objects/obj_lib.c
index 08266141e2..1afe148d52 100644
--- a/crypto/objects/obj_lib.c
+++ b/crypto/objects/obj_lib.c
@@ -25,7 +25,7 @@ ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o)
 
     r = ASN1_OBJECT_new();
     if (r == NULL) {
-        OBJerr(OBJ_F_OBJ_DUP, ERR_R_ASN1_LIB);
+        ERR_raise(ERR_LIB_OBJ, ERR_R_ASN1_LIB);
         return NULL;
     }
 
@@ -50,7 +50,7 @@ ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o)
     return r;
  err:
     ASN1_OBJECT_free(r);
-    OBJerr(OBJ_F_OBJ_DUP, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_OBJ, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
diff --git a/crypto/objects/obj_xref.c b/crypto/objects/obj_xref.c
index d779402891..352594c6b6 100644
--- a/crypto/objects/obj_xref.c
+++ b/crypto/objects/obj_xref.c
@@ -104,7 +104,7 @@ int OBJ_add_sigid(int signid, int dig_id, int pkey_id)
     if (sigx_app == NULL)
         return 0;
     if ((ntr = OPENSSL_malloc(sizeof(*ntr))) == NULL) {
-        OBJerr(OBJ_F_OBJ_ADD_SIGID, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_OBJ, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ntr-&gt;sign_id = signid;
diff --git a/crypto/ocsp/ocsp_cl.c b/crypto/ocsp/ocsp_cl.c
index 33d77af426..2d4bd036ad 100644
--- a/crypto/ocsp/ocsp_cl.c
+++ b/crypto/ocsp/ocsp_cl.c
@@ -102,8 +102,8 @@ int OCSP_request_sign(OCSP_REQUEST *req,
         goto err;
     if (key) {
         if (!X509_check_private_key(signer, key)) {
-            OCSPerr(OCSP_F_OCSP_REQUEST_SIGN,
-                    OCSP_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
+            ERR_raise(ERR_LIB_OCSP,
+                      OCSP_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
             goto err;
         }
         if (!OCSP_REQUEST_sign(req, key, dgst))
@@ -144,11 +144,11 @@ OCSP_BASICRESP *OCSP_response_get1_basic(OCSP_RESPONSE *resp)
     OCSP_RESPBYTES *rb;
     rb = resp-&gt;responseBytes;
     if (!rb) {
-        OCSPerr(OCSP_F_OCSP_RESPONSE_GET1_BASIC, OCSP_R_NO_RESPONSE_DATA);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_NO_RESPONSE_DATA);
         return NULL;
     }
     if (OBJ_obj2nid(rb-&gt;responseType) != NID_id_pkix_OCSP_basic) {
-        OCSPerr(OCSP_F_OCSP_RESPONSE_GET1_BASIC, OCSP_R_NOT_BASIC_RESPONSE);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_NOT_BASIC_RESPONSE);
         return NULL;
     }
 
@@ -336,12 +336,12 @@ int OCSP_check_validity(ASN1_GENERALIZEDTIME *thisupd,
     time(&amp;t_now);
     /* Check thisUpdate is valid and not more than nsec in the future */
     if (!ASN1_GENERALIZEDTIME_check(thisupd)) {
-        OCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_ERROR_IN_THISUPDATE_FIELD);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_ERROR_IN_THISUPDATE_FIELD);
         ret = 0;
     } else {
         t_tmp = t_now + nsec;
         if (X509_cmp_time(thisupd, &amp;t_tmp) &gt; 0) {
-            OCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_STATUS_NOT_YET_VALID);
+            ERR_raise(ERR_LIB_OCSP, OCSP_R_STATUS_NOT_YET_VALID);
             ret = 0;
         }
 
@@ -352,7 +352,7 @@ int OCSP_check_validity(ASN1_GENERALIZEDTIME *thisupd,
         if (maxsec &gt;= 0) {
             t_tmp = t_now - maxsec;
             if (X509_cmp_time(thisupd, &amp;t_tmp) &lt; 0) {
-                OCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_STATUS_TOO_OLD);
+                ERR_raise(ERR_LIB_OCSP, OCSP_R_STATUS_TOO_OLD);
                 ret = 0;
             }
         }
@@ -363,20 +363,19 @@ int OCSP_check_validity(ASN1_GENERALIZEDTIME *thisupd,
 
     /* Check nextUpdate is valid and not more than nsec in the past */
     if (!ASN1_GENERALIZEDTIME_check(nextupd)) {
-        OCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_ERROR_IN_NEXTUPDATE_FIELD);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_ERROR_IN_NEXTUPDATE_FIELD);
         ret = 0;
     } else {
         t_tmp = t_now - nsec;
         if (X509_cmp_time(nextupd, &amp;t_tmp) &lt; 0) {
-            OCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_STATUS_EXPIRED);
+            ERR_raise(ERR_LIB_OCSP, OCSP_R_STATUS_EXPIRED);
             ret = 0;
         }
     }
 
     /* Also don't allow nextUpdate to precede thisUpdate */
     if (ASN1_STRING_cmp(nextupd, thisupd) &lt; 0) {
-        OCSPerr(OCSP_F_OCSP_CHECK_VALIDITY,
-                OCSP_R_NEXTUPDATE_BEFORE_THISUPDATE);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_NEXTUPDATE_BEFORE_THISUPDATE);
         ret = 0;
     }
 
diff --git a/crypto/ocsp/ocsp_lib.c b/crypto/ocsp/ocsp_lib.c
index 2701789c8a..c7b7a0a620 100644
--- a/crypto/ocsp/ocsp_lib.c
+++ b/crypto/ocsp/ocsp_lib.c
@@ -55,7 +55,7 @@ OCSP_CERTID *OCSP_cert_id_new(const EVP_MD *dgst,
     alg = &amp;cid-&gt;hashAlgorithm;
     ASN1_OBJECT_free(alg-&gt;algorithm);
     if ((nid = EVP_MD_type(dgst)) == NID_undef) {
-        OCSPerr(OCSP_F_OCSP_CERT_ID_NEW, OCSP_R_UNKNOWN_NID);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_UNKNOWN_NID);
         goto err;
     }
     if ((alg-&gt;algorithm = OBJ_nid2obj(nid)) == NULL)
@@ -82,7 +82,7 @@ OCSP_CERTID *OCSP_cert_id_new(const EVP_MD *dgst,
     }
     return cid;
  digerr:
-    OCSPerr(OCSP_F_OCSP_CERT_ID_NEW, OCSP_R_DIGEST_ERR);
+    ERR_raise(ERR_LIB_OCSP, OCSP_R_DIGEST_ERR);
  err:
     OCSP_CERTID_free(cid);
     return NULL;
diff --git a/crypto/ocsp/ocsp_srv.c b/crypto/ocsp/ocsp_srv.c
index 22f637548d..2c8b38f723 100644
--- a/crypto/ocsp/ocsp_srv.c
+++ b/crypto/ocsp/ocsp_srv.c
@@ -117,7 +117,7 @@ OCSP_SINGLERESP *OCSP_basic_add1_status(OCSP_BASICRESP *rsp,
     switch (cs-&gt;type = status) {
     case V_OCSP_CERTSTATUS_REVOKED:
         if (!revtime) {
-            OCSPerr(OCSP_F_OCSP_BASIC_ADD1_STATUS, OCSP_R_NO_REVOKED_TIME);
+            ERR_raise(ERR_LIB_OCSP, OCSP_R_NO_REVOKED_TIME);
             goto err;
         }
         if ((cs-&gt;value.revoked = ri = OCSP_REVOKEDINFO_new()) == NULL)
@@ -176,14 +176,13 @@ int OCSP_basic_sign_ctx(OCSP_BASICRESP *brsp,
     EVP_PKEY *pkey;
 
     if (ctx == NULL || EVP_MD_CTX_pkey_ctx(ctx) == NULL) {
-        OCSPerr(OCSP_F_OCSP_BASIC_SIGN_CTX, OCSP_R_NO_SIGNER_KEY);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_NO_SIGNER_KEY);
         goto err;
     }
 
     pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_pkey_ctx(ctx));
     if (pkey == NULL || !X509_check_private_key(signer, pkey)) {
-        OCSPerr(OCSP_F_OCSP_BASIC_SIGN_CTX,
-                OCSP_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
         goto err;
     }
 
diff --git a/crypto/ocsp/ocsp_vfy.c b/crypto/ocsp/ocsp_vfy.c
index 0cd59f9221..f49f651007 100644
--- a/crypto/ocsp/ocsp_vfy.c
+++ b/crypto/ocsp/ocsp_vfy.c
@@ -35,11 +35,11 @@ static int ocsp_verify_signer(X509 *signer, int response,
     int ret = -1;
 
     if (ctx == NULL) {
-        OCSPerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_OCSP, ERR_R_MALLOC_FAILURE);
         goto end;
     }
     if (!X509_STORE_CTX_init(ctx, st, signer, untrusted)) {
-        OCSPerr(0, ERR_R_X509_LIB);
+        ERR_raise(ERR_LIB_OCSP, ERR_R_X509_LIB);
         goto end;
     }
     if ((vp = X509_STORE_CTX_get0_param(ctx)) == NULL)
@@ -60,9 +60,8 @@ static int ocsp_verify_signer(X509 *signer, int response,
     ret = X509_verify_cert(ctx);
     if (ret &lt;= 0) {
         ret = X509_STORE_CTX_get_error(ctx);
-        OCSPerr(0, OCSP_R_CERTIFICATE_VERIFY_ERROR);
-        ERR_add_error_data(2, &quot;Verify error:&quot;,
-                           X509_verify_cert_error_string(ret));
+        ERR_raise_data(ERR_LIB_OCSP, OCSP_R_CERTIFICATE_VERIFY_ERROR,
+                       &quot;Verify error: %s&quot;, X509_verify_cert_error_string(ret));
         goto end;
     }
     if (chain != NULL)
@@ -81,7 +80,7 @@ static int ocsp_verify(OCSP_REQUEST *req, OCSP_BASICRESP *bs,
 
     if ((flags &amp; OCSP_NOSIGS) == 0) {
         if ((skey = X509_get0_pubkey(signer)) == NULL) {
-            OCSPerr(0, OCSP_R_NO_SIGNER_KEY);
+            ERR_raise(ERR_LIB_OCSP, OCSP_R_NO_SIGNER_KEY);
             return -1;
         }
         if (req != NULL)
@@ -89,7 +88,7 @@ static int ocsp_verify(OCSP_REQUEST *req, OCSP_BASICRESP *bs,
         else
             ret = OCSP_BASICRESP_verify(bs, skey);
         if (ret &lt;= 0)
-            OCSPerr(0, OCSP_R_SIGNATURE_FAILURE);
+            ERR_raise(ERR_LIB_OCSP, OCSP_R_SIGNATURE_FAILURE);
     }
     return ret;
 }
@@ -104,8 +103,7 @@ int OCSP_basic_verify(OCSP_BASICRESP *bs, STACK_OF(X509) *certs,
     int ret = ocsp_find_signer(&amp;signer, bs, certs, flags);
 
     if (ret == 0) {
-        OCSPerr(OCSP_F_OCSP_BASIC_VERIFY,
-                OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);
         goto end;
     }
     if ((ret == 2) &amp;&amp; (flags &amp; OCSP_TRUSTOTHER) != 0)
@@ -152,7 +150,7 @@ int OCSP_basic_verify(OCSP_BASICRESP *bs, STACK_OF(X509) *certs,
 
         x = sk_X509_value(chain, sk_X509_num(chain) - 1);
         if (X509_check_trust(x, NID_OCSP_sign, 0) != X509_TRUST_TRUSTED) {
-            OCSPerr(OCSP_F_OCSP_BASIC_VERIFY, OCSP_R_ROOT_CA_NOT_TRUSTED);
+            ERR_raise(ERR_LIB_OCSP, OCSP_R_ROOT_CA_NOT_TRUSTED);
             ret = 0;
             goto end;
         }
@@ -228,7 +226,7 @@ static int ocsp_check_issuer(OCSP_BASICRESP *bs, STACK_OF(X509) *chain)
     int ret;
 
     if (sk_X509_num(chain) &lt;= 0) {
-        OCSPerr(OCSP_F_OCSP_CHECK_ISSUER, OCSP_R_NO_CERTIFICATES_IN_CHAIN);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_NO_CERTIFICATES_IN_CHAIN);
         return -1;
     }
 
@@ -272,8 +270,7 @@ static int ocsp_check_ids(STACK_OF(OCSP_SINGLERESP) *sresp, OCSP_CERTID **ret)
 
     idcount = sk_OCSP_SINGLERESP_num(sresp);
     if (idcount &lt;= 0) {
-        OCSPerr(OCSP_F_OCSP_CHECK_IDS,
-                OCSP_R_RESPONSE_CONTAINS_NO_REVOCATION_DATA);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_RESPONSE_CONTAINS_NO_REVOCATION_DATA);
         return -1;
     }
 
@@ -313,13 +310,13 @@ static int ocsp_match_issuerid(X509 *cert, OCSP_CERTID *cid,
         unsigned char md[EVP_MAX_MD_SIZE];
 
         if (dgst == NULL) {
-            OCSPerr(0, OCSP_R_UNKNOWN_MESSAGE_DIGEST);
+            ERR_raise(ERR_LIB_OCSP, OCSP_R_UNKNOWN_MESSAGE_DIGEST);
             return -1;
         }
 
         mdlen = EVP_MD_size(dgst);
         if (mdlen &lt; 0) {
-            OCSPerr(0, OCSP_R_DIGEST_SIZE_ERR);
+            ERR_raise(ERR_LIB_OCSP, OCSP_R_DIGEST_SIZE_ERR);
             return -1;
         }
         if (cid-&gt;issuerNameHash.length != mdlen ||
@@ -327,13 +324,13 @@ static int ocsp_match_issuerid(X509 *cert, OCSP_CERTID *cid,
             return 0;
         iname = X509_get_subject_name(cert);
         if (!X509_NAME_digest(iname, dgst, md, NULL)) {
-            OCSPerr(0, OCSP_R_DIGEST_NAME_ERR);
+            ERR_raise(ERR_LIB_OCSP, OCSP_R_DIGEST_NAME_ERR);
             return -1;
         }
         if (memcmp(md, cid-&gt;issuerNameHash.data, mdlen) != 0)
             return 0;
         if (!X509_pubkey_digest(cert, dgst, md, NULL)) {
-            OCSPerr(0, OCSP_R_DIGEST_ERR);
+            ERR_raise(ERR_LIB_OCSP, OCSP_R_DIGEST_ERR);
             return -1;
         }
         if (memcmp(md, cid-&gt;issuerKeyHash.data, mdlen) != 0)
@@ -358,7 +355,7 @@ static int ocsp_check_delegated(X509 *x)
     if ((X509_get_extension_flags(x) &amp; EXFLAG_XKUSAGE)
         &amp;&amp; (X509_get_extended_key_usage(x) &amp; XKU_OCSP_SIGN))
         return 1;
-    OCSPerr(OCSP_F_OCSP_CHECK_DELEGATED, OCSP_R_MISSING_OCSPSIGNING_USAGE);
+    ERR_raise(ERR_LIB_OCSP, OCSP_R_MISSING_OCSPSIGNING_USAGE);
     return 0;
 }
 
@@ -376,20 +373,18 @@ int OCSP_request_verify(OCSP_REQUEST *req, STACK_OF(X509) *certs,
     int ret;
 
     if (!req-&gt;optionalSignature) {
-        OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY, OCSP_R_REQUEST_NOT_SIGNED);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_REQUEST_NOT_SIGNED);
         return 0;
     }
     gen = req-&gt;tbsRequest.requestorName;
     if (!gen || gen-&gt;type != GEN_DIRNAME) {
-        OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY,
-                OCSP_R_UNSUPPORTED_REQUESTORNAME_TYPE);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_UNSUPPORTED_REQUESTORNAME_TYPE);
         return 0; /* not returning -1 here for backward compatibility*/
     }
     nm = gen-&gt;d.directoryName;
     ret = ocsp_req_find_signer(&amp;signer, req, nm, certs, flags);
     if (ret &lt;= 0) {
-        OCSPerr(OCSP_F_OCSP_REQUEST_VERIFY,
-                OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);
+        ERR_raise(ERR_LIB_OCSP, OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND);
         return 0; /* not returning -1 here for backward compatibility*/
     }
     if ((ret == 2) &amp;&amp; (flags &amp; OCSP_TRUSTOTHER) != 0)
diff --git a/crypto/ocsp/v3_ocsp.c b/crypto/ocsp/v3_ocsp.c
index 2f2684b9a4..7d3d730457 100644
--- a/crypto/ocsp/v3_ocsp.c
+++ b/crypto/ocsp/v3_ocsp.c
@@ -203,7 +203,7 @@ static void *d2i_ocsp_nonce(void *a, const unsigned char **pp, long length)
  err:
     if ((pos == NULL) || (*pos != os))
         ASN1_OCTET_STRING_free(os);
-    OCSPerr(OCSP_F_D2I_OCSP_NONCE, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_OCSP, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
diff --git a/crypto/packet.c b/crypto/packet.c
index 6db97a5434..6cd1ed3ed3 100644
--- a/crypto/packet.c
+++ b/crypto/packet.c
@@ -105,7 +105,7 @@ static int wpacket_intern_init_len(WPACKET *pkt, size_t lenbytes)
     pkt-&gt;written = 0;
 
     if ((pkt-&gt;subs = OPENSSL_zalloc(sizeof(*pkt-&gt;subs))) == NULL) {
-        SSLerr(SSL_F_WPACKET_INTERN_INIT_LEN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -352,7 +352,7 @@ int WPACKET_start_sub_packet_len__(WPACKET *pkt, size_t lenbytes)
         return 0;
 
     if ((sub = OPENSSL_zalloc(sizeof(*sub))) == NULL) {
-        SSLerr(SSL_F_WPACKET_START_SUB_PACKET_LEN__, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/param_build.c b/crypto/param_build.c
index de829d354f..ce9eaa1fec 100644
--- a/crypto/param_build.c
+++ b/crypto/param_build.c
@@ -68,7 +68,7 @@ static OSSL_PARAM_BLD_DEF *param_push(OSSL_PARAM_BLD *bld, const char *key,
     OSSL_PARAM_BLD_DEF *pd = OPENSSL_zalloc(sizeof(*pd));
 
     if (pd == NULL) {
-        CRYPTOerr(CRYPTO_F_PARAM_PUSH, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     pd-&gt;key = key;
@@ -94,7 +94,7 @@ static int param_push_num(OSSL_PARAM_BLD *bld, const char *key,
     if (pd == NULL)
         return 0;
     if (size &gt; sizeof(pd-&gt;num)) {
-        CRYPTOerr(CRYPTO_F_PARAM_PUSH_NUM, CRYPTO_R_TOO_MANY_BYTES);
+        ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_TOO_MANY_BYTES);
         return 0;
     }
     memcpy(&amp;pd-&gt;num, num, size);
@@ -219,11 +219,11 @@ int OSSL_PARAM_BLD_push_BN_pad(OSSL_PARAM_BLD *bld, const char *key,
     if (bn != NULL) {
         n = BN_num_bytes(bn);
         if (n &lt; 0) {
-            CRYPTOerr(0, CRYPTO_R_ZERO_LENGTH_NUMBER);
+            ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_ZERO_LENGTH_NUMBER);
             return 0;
         }
         if (sz &lt; (size_t)n) {
-            CRYPTOerr(0, CRYPTO_R_TOO_SMALL_BUFFER);
+            ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_TOO_SMALL_BUFFER);
             return 0;
         }
         if (BN_get_flags(bn, BN_FLG_SECURE) == BN_FLG_SECURE)
@@ -244,8 +244,7 @@ int OSSL_PARAM_BLD_push_utf8_string(OSSL_PARAM_BLD *bld, const char *key,
     if (bsize == 0) {
         bsize = strlen(buf) + 1;
     } else if (bsize &gt; INT_MAX) {
-        CRYPTOerr(CRYPTO_F_OSSL_PARAM_BLD_PUSH_UTF8_STRING,
-                  CRYPTO_R_STRING_TOO_LONG);
+        ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_STRING_TOO_LONG);
         return 0;
     }
     pd = param_push(bld, key, bsize, bsize, OSSL_PARAM_UTF8_STRING, 0);
@@ -263,8 +262,7 @@ int OSSL_PARAM_BLD_push_utf8_ptr(OSSL_PARAM_BLD *bld, const char *key,
     if (bsize == 0) {
         bsize = strlen(buf) + 1;
     } else if (bsize &gt; INT_MAX) {
-        CRYPTOerr(CRYPTO_F_OSSL_PARAM_BLD_PUSH_UTF8_PTR,
-                  CRYPTO_R_STRING_TOO_LONG);
+        ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_STRING_TOO_LONG);
         return 0;
     }
     pd = param_push(bld, key, bsize, sizeof(buf), OSSL_PARAM_UTF8_PTR, 0);
@@ -280,8 +278,7 @@ int OSSL_PARAM_BLD_push_octet_string(OSSL_PARAM_BLD *bld, const char *key,
     OSSL_PARAM_BLD_DEF *pd;
 
     if (bsize &gt; INT_MAX) {
-        CRYPTOerr(CRYPTO_F_OSSL_PARAM_BLD_PUSH_OCTET_STRING,
-                  CRYPTO_R_STRING_TOO_LONG);
+        ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_STRING_TOO_LONG);
         return 0;
     }
     pd = param_push(bld, key, bsize, bsize, OSSL_PARAM_OCTET_STRING, 0);
@@ -297,8 +294,7 @@ int OSSL_PARAM_BLD_push_octet_ptr(OSSL_PARAM_BLD *bld, const char *key,
     OSSL_PARAM_BLD_DEF *pd;
 
     if (bsize &gt; INT_MAX) {
-        CRYPTOerr(CRYPTO_F_OSSL_PARAM_BLD_PUSH_OCTET_PTR,
-                  CRYPTO_R_STRING_TOO_LONG);
+        ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_STRING_TOO_LONG);
         return 0;
     }
     pd = param_push(bld, key, bsize, sizeof(buf), OSSL_PARAM_OCTET_PTR, 0);
@@ -368,14 +364,13 @@ OSSL_PARAM *OSSL_PARAM_BLD_to_param(OSSL_PARAM_BLD *bld)
     if (ss &gt; 0) {
         s = OPENSSL_secure_malloc(ss);
         if (s == NULL) {
-            CRYPTOerr(CRYPTO_F_OSSL_PARAM_BLD_TO_PARAM,
-                      CRYPTO_R_SECURE_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_SECURE_MALLOC_FAILURE);
             return NULL;
         }
     }
     params = OPENSSL_malloc(total);
     if (params == NULL) {
-        CRYPTOerr(CRYPTO_F_OSSL_PARAM_BLD_TO_PARAM, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         OPENSSL_secure_free(s);
         return NULL;
     }
diff --git a/crypto/params_from_text.c b/crypto/params_from_text.c
index 14b64edb6b..9f74dc1075 100644
--- a/crypto/params_from_text.c
+++ b/crypto/params_from_text.c
@@ -75,7 +75,7 @@ static int prepare_from_text(const OSSL_PARAM *paramdefs, const char *key,
          */
         if (p-&gt;data_size &gt; 0) {
             if (*buf_n &gt;= p-&gt;data_size) {
-                CRYPTOerr(0, CRYPTO_R_TOO_SMALL_BUFFER);
+                ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_TOO_SMALL_BUFFER);
                 /* Since this is a different error, we don't break */
                 return 0;
             }
@@ -85,7 +85,7 @@ static int prepare_from_text(const OSSL_PARAM *paramdefs, const char *key,
         break;
     case OSSL_PARAM_UTF8_STRING:
         if (*ishex) {
-            CRYPTOerr(0, ERR_R_PASSED_INVALID_ARGUMENT);
+            ERR_raise(ERR_LIB_CRYPTO, ERR_R_PASSED_INVALID_ARGUMENT);
             return 0;
         }
         *buf_n = strlen(value) + 1;
@@ -182,7 +182,7 @@ int OSSL_PARAM_allocate_from_text(OSSL_PARAM *to,
         return 0;
 
     if ((buf = OPENSSL_zalloc(buf_n &gt; 0 ? buf_n : 1)) == NULL) {
-        CRYPTOerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/pem/pem_all.c b/crypto/pem/pem_all.c
index 01c62d0222..8d5b25156c 100644
--- a/crypto/pem/pem_all.c
+++ b/crypto/pem/pem_all.c
@@ -200,7 +200,7 @@ DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u)
         ret = d2i_DHparams(x, &amp;p, len);
 
     if (ret == NULL)
-        PEMerr(PEM_F_PEM_READ_BIO_DHPARAMS, ERR_R_ASN1_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_ASN1_LIB);
     OPENSSL_free(nm);
     OPENSSL_free(data);
     return ret;
@@ -213,7 +213,7 @@ DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u)
     DH *ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        PEMerr(PEM_F_PEM_READ_DHPARAMS, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
diff --git a/crypto/pem/pem_info.c b/crypto/pem/pem_info.c
index 2284959e91..7537e5a31f 100644
--- a/crypto/pem/pem_info.c
+++ b/crypto/pem/pem_info.c
@@ -32,7 +32,7 @@ STACK_OF(X509_INFO)
     STACK_OF(X509_INFO) *ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        PEMerr(0, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -66,7 +66,7 @@ STACK_OF(X509_INFO)
 
     if (sk == NULL) {
         if ((ret = sk_X509_INFO_new_null()) == NULL) {
-            PEMerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     } else
@@ -210,11 +210,11 @@ STACK_OF(X509_INFO)
                 p = data;
                 if (ptype) {
                     if (!d2i_PrivateKey(ptype, pp, &amp;p, len)) {
-                        PEMerr(0, ERR_R_ASN1_LIB);
+                        ERR_raise(ERR_LIB_PEM, ERR_R_ASN1_LIB);
                         goto err;
                     }
                 } else if (d2i(pp, &amp;p, len) == NULL) {
-                    PEMerr(0, ERR_R_ASN1_LIB);
+                    ERR_raise(ERR_LIB_PEM, ERR_R_ASN1_LIB);
                     goto err;
                 }
             } else {            /* encrypted RSA data */
@@ -290,7 +290,7 @@ int PEM_X509_INFO_write_bio(BIO *bp, const X509_INFO *xi, EVP_CIPHER *enc,
                     */
                 || (strlen(objstr) + 23 + 2 * EVP_CIPHER_iv_length(enc) + 13)
                    &gt; sizeof(buf)) {
-            PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO, PEM_R_UNSUPPORTED_CIPHER);
+            ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_CIPHER);
             goto err;
         }
     }
@@ -303,7 +303,7 @@ int PEM_X509_INFO_write_bio(BIO *bp, const X509_INFO *xi, EVP_CIPHER *enc,
     if (xi-&gt;x_pkey != NULL) {
         if ((xi-&gt;enc_data != NULL) &amp;&amp; (xi-&gt;enc_len &gt; 0)) {
             if (enc == NULL) {
-                PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO, PEM_R_CIPHER_IS_NULL);
+                ERR_raise(ERR_LIB_PEM, PEM_R_CIPHER_IS_NULL);
                 goto err;
             }
 
@@ -319,8 +319,7 @@ int PEM_X509_INFO_write_bio(BIO *bp, const X509_INFO *xi, EVP_CIPHER *enc,
              */
             objstr = OBJ_nid2sn(EVP_CIPHER_nid(xi-&gt;enc_cipher.cipher));
             if (objstr == NULL) {
-                PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,
-                       PEM_R_UNSUPPORTED_CIPHER);
+                ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_CIPHER);
                 goto err;
             }
 
diff --git a/crypto/pem/pem_lib.c b/crypto/pem/pem_lib.c
index 71074b5b16..f1df0a40b1 100644
--- a/crypto/pem/pem_lib.c
+++ b/crypto/pem/pem_lib.c
@@ -59,7 +59,7 @@ int PEM_def_callback(char *buf, int num, int rwflag, void *userdata)
 
     i = EVP_read_pw_string_min(buf, min_len, num, prompt, rwflag);
     if (i != 0) {
-        PEMerr(PEM_F_PEM_DEF_CALLBACK, PEM_R_PROBLEMS_GETTING_PASSWORD);
+        ERR_raise(ERR_LIB_PEM, PEM_R_PROBLEMS_GETTING_PASSWORD);
         memset(buf, 0, (unsigned int)num);
         return -1;
     }
@@ -113,7 +113,7 @@ void *PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
     void *ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        PEMerr(PEM_F_PEM_ASN1_READ, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -299,7 +299,7 @@ int PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        PEMerr(PEM_F_PEM_ASN1_WRITE, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -332,13 +332,13 @@ int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
                     */
                 || (strlen(objstr) + 23 + 2 * EVP_CIPHER_iv_length(enc) + 13)
                    &gt; sizeof(buf)) {
-            PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, PEM_R_UNSUPPORTED_CIPHER);
+            ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_CIPHER);
             goto err;
         }
     }
 
     if ((dsize = i2d(x, NULL)) &lt;= 0) {
-        PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_ASN1_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_ASN1_LIB);
         dsize = 0;
         goto err;
     }
@@ -346,7 +346,7 @@ int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
     /* actually it needs the cipher block size extra... */
     data = OPENSSL_malloc((unsigned int)dsize + 20);
     if (data == NULL) {
-        PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     p = data;
@@ -359,7 +359,7 @@ int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
             else
                 klen = (*callback) (buf, PEM_BUFSIZE, 1, u);
             if (klen &lt;= 0) {
-                PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, PEM_R_READ_KEY);
+                ERR_raise(ERR_LIB_PEM, PEM_R_READ_KEY);
                 goto err;
             }
 #ifdef CHARSET_EBCDIC
@@ -424,7 +424,7 @@ int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
 #if LONG_MAX &gt; INT_MAX
     /* Check that we did not truncate the length */
     if (len &gt; INT_MAX) {
-        PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_HEADER_TOO_LONG);
+        ERR_raise(ERR_LIB_PEM, PEM_R_HEADER_TOO_LONG);
         return 0;
     }
 #endif
@@ -436,7 +436,7 @@ int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
     else
         keylen = callback(buf, PEM_BUFSIZE, 0, u);
     if (keylen &lt; 0) {
-        PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_PASSWORD_READ);
+        ERR_raise(ERR_LIB_PEM, PEM_R_BAD_PASSWORD_READ);
         return 0;
     }
 #ifdef CHARSET_EBCDIC
@@ -463,7 +463,7 @@ int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
     if (ok)
         *plen += ilen;
     else
-        PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_DECRYPT);
+        ERR_raise(ERR_LIB_PEM, PEM_R_BAD_DECRYPT);
 
     EVP_CIPHER_CTX_free(ctx);
     OPENSSL_cleanse((char *)buf, sizeof(buf));
@@ -498,7 +498,7 @@ int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
         return 1;
 
     if (strncmp(header, ProcType, sizeof(ProcType)-1) != 0) {
-        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_PROC_TYPE);
+        ERR_raise(ERR_LIB_PEM, PEM_R_NOT_PROC_TYPE);
         return 0;
     }
     header += sizeof(ProcType)-1;
@@ -511,13 +511,13 @@ int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
     /* We expect &quot;ENCRYPTED&quot; followed by optional white-space + line break */
     if (strncmp(header, ENCRYPTED, sizeof(ENCRYPTED)-1) != 0 ||
         strspn(header+sizeof(ENCRYPTED)-1, &quot; \t\r\n&quot;) == 0) {
-        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_ENCRYPTED);
+        ERR_raise(ERR_LIB_PEM, PEM_R_NOT_ENCRYPTED);
         return 0;
     }
     header += sizeof(ENCRYPTED)-1;
     header += strspn(header, &quot; \t\r&quot;);
     if (*header++ != '\n') {
-        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_SHORT_HEADER);
+        ERR_raise(ERR_LIB_PEM, PEM_R_SHORT_HEADER);
         return 0;
     }
 
@@ -526,7 +526,7 @@ int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
      * We expect &quot;DEK-Info: algo[,hex-parameters]&quot;
      */
     if (strncmp(header, DEKInfo, sizeof(DEKInfo)-1) != 0) {
-        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_DEK_INFO);
+        ERR_raise(ERR_LIB_PEM, PEM_R_NOT_DEK_INFO);
         return 0;
     }
     header += sizeof(DEKInfo)-1;
@@ -545,15 +545,15 @@ int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
     header += strspn(header, &quot; \t&quot;);
 
     if (enc == NULL) {
-        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_UNSUPPORTED_ENCRYPTION);
+        ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_ENCRYPTION);
         return 0;
     }
     ivlen = EVP_CIPHER_iv_length(enc);
     if (ivlen &gt; 0 &amp;&amp; *header++ != ',') {
-        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_MISSING_DEK_IV);
+        ERR_raise(ERR_LIB_PEM, PEM_R_MISSING_DEK_IV);
         return 0;
     } else if (ivlen == 0 &amp;&amp; *header == ',') {
-        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_UNEXPECTED_DEK_IV);
+        ERR_raise(ERR_LIB_PEM, PEM_R_UNEXPECTED_DEK_IV);
         return 0;
     }
 
@@ -575,7 +575,7 @@ static int load_iv(char **fromp, unsigned char *to, int num)
     for (i = 0; i &lt; num; i++) {
         v = OPENSSL_hexchar2int(*from);
         if (v &lt; 0) {
-            PEMerr(PEM_F_LOAD_IV, PEM_R_BAD_IV_CHARS);
+            ERR_raise(ERR_LIB_PEM, PEM_R_BAD_IV_CHARS);
             return 0;
         }
         from++;
@@ -594,7 +594,7 @@ int PEM_write(FILE *fp, const char *name, const char *header,
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        PEMerr(PEM_F_PEM_WRITE, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -660,7 +660,7 @@ int PEM_write_bio(BIO *bp, const char *name, const char *header,
 
  err:
     if (retval == 0)
-        PEMerr(PEM_F_PEM_WRITE_BIO, reason);
+        ERR_raise(ERR_LIB_PEM, reason);
     EVP_ENCODE_CTX_free(ctx);
     OPENSSL_clear_free(buf, PEM_BUFSIZE * 8);
     return retval;
@@ -674,7 +674,7 @@ int PEM_read(FILE *fp, char **name, char **header, unsigned char **data,
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        PEMerr(PEM_F_PEM_READ, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -751,7 +751,7 @@ static int get_name(BIO *bp, char **name, unsigned int flags)
      */
     linebuf = pem_malloc(LINESIZE + 1, flags);
     if (linebuf == NULL) {
-        PEMerr(PEM_F_GET_NAME, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -759,7 +759,7 @@ static int get_name(BIO *bp, char **name, unsigned int flags)
         len = BIO_gets(bp, linebuf, LINESIZE);
 
         if (len &lt;= 0) {
-            PEMerr(PEM_F_GET_NAME, PEM_R_NO_START_LINE);
+            ERR_raise(ERR_LIB_PEM, PEM_R_NO_START_LINE);
             goto err;
         }
 
@@ -775,7 +775,7 @@ static int get_name(BIO *bp, char **name, unsigned int flags)
     len = len - BEGINLEN - TAILLEN + 1;
     *name = pem_malloc(len, flags);
     if (*name == NULL) {
-        PEMerr(PEM_F_GET_NAME, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     memcpy(*name, linebuf + BEGINLEN, len);
@@ -819,7 +819,7 @@ static int get_header_and_data(BIO *bp, BIO **header, BIO **data, char *name,
      * that will be added by sanitize_line() (the extra '1'). */
     linebuf = pem_malloc(LINESIZE + 1, flags);
     if (linebuf == NULL) {
-        PEMerr(PEM_F_GET_HEADER_AND_DATA, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -827,7 +827,7 @@ static int get_header_and_data(BIO *bp, BIO **header, BIO **data, char *name,
         flags_mask = ~0u;
         len = BIO_gets(bp, linebuf, LINESIZE);
         if (len &lt;= 0) {
-            PEMerr(PEM_F_GET_HEADER_AND_DATA, PEM_R_BAD_END_LINE);
+            ERR_raise(ERR_LIB_PEM, PEM_R_BAD_END_LINE);
             goto err;
         }
 
@@ -856,7 +856,7 @@ static int get_header_and_data(BIO *bp, BIO **header, BIO **data, char *name,
             if (!prev_partial_line_read) {
                 if (got_header == POST_HEADER) {
                     /* Another blank line is an error. */
-                    PEMerr(PEM_F_GET_HEADER_AND_DATA, PEM_R_BAD_END_LINE);
+                    ERR_raise(ERR_LIB_PEM, PEM_R_BAD_END_LINE);
                     goto err;
                 }
                 got_header = POST_HEADER;
@@ -871,7 +871,7 @@ static int get_header_and_data(BIO *bp, BIO **header, BIO **data, char *name,
             namelen = strlen(name);
             if (strncmp(p, name, namelen) != 0 ||
                 strncmp(p + namelen, tailstr, TAILLEN) != 0) {
-                PEMerr(PEM_F_GET_HEADER_AND_DATA, PEM_R_BAD_END_LINE);
+                ERR_raise(ERR_LIB_PEM, PEM_R_BAD_END_LINE);
                 goto err;
             }
             if (got_header == MAYBE_HEADER) {
@@ -881,7 +881,7 @@ static int get_header_and_data(BIO *bp, BIO **header, BIO **data, char *name,
             break;
         } else if (end) {
             /* Malformed input; short line not at end of data. */
-            PEMerr(PEM_F_GET_HEADER_AND_DATA, PEM_R_BAD_END_LINE);
+            ERR_raise(ERR_LIB_PEM, PEM_R_BAD_END_LINE);
             goto err;
         }
         /*
@@ -925,7 +925,7 @@ int PEM_read_bio_ex(BIO *bp, char **name_out, char **header,
     BUF_MEM * buf_mem;
 
     if (ctx == NULL) {
-        PEMerr(PEM_F_PEM_READ_BIO_EX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -934,7 +934,7 @@ int PEM_read_bio_ex(BIO *bp, char **name_out, char **header,
     *data = NULL;
     if ((flags &amp; PEM_FLAG_EAY_COMPATIBLE) &amp;&amp; (flags &amp; PEM_FLAG_ONLY_B64)) {
         /* These two are mutually incompatible; bail out. */
-        PEMerr(PEM_F_PEM_READ_BIO_EX, ERR_R_PASSED_INVALID_ARGUMENT);
+        ERR_raise(ERR_LIB_PEM, ERR_R_PASSED_INVALID_ARGUMENT);
         goto end;
     }
     bmeth = (flags &amp; PEM_FLAG_SECURE) ? BIO_s_secmem() : BIO_s_mem();
@@ -942,7 +942,7 @@ int PEM_read_bio_ex(BIO *bp, char **name_out, char **header,
     headerB = BIO_new(bmeth);
     dataB = BIO_new(bmeth);
     if (headerB == NULL || dataB == NULL) {
-        PEMerr(PEM_F_PEM_READ_BIO_EX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
         goto end;
     }
 
@@ -958,7 +958,7 @@ int PEM_read_bio_ex(BIO *bp, char **name_out, char **header,
                          (unsigned char*)buf_mem-&gt;data, len) &lt; 0
             || EVP_DecodeFinal(ctx, (unsigned char*)&amp;(buf_mem-&gt;data[len]),
                                &amp;taillen) &lt; 0) {
-        PEMerr(PEM_F_PEM_READ_BIO_EX, PEM_R_BAD_BASE64_DECODE);
+        ERR_raise(ERR_LIB_PEM, PEM_R_BAD_BASE64_DECODE);
         goto end;
     }
     len += taillen;
diff --git a/crypto/pem/pem_oth.c b/crypto/pem/pem_oth.c
index 81546bcaf1..31fc9cff46 100644
--- a/crypto/pem/pem_oth.c
+++ b/crypto/pem/pem_oth.c
@@ -30,7 +30,7 @@ void *PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,
     p = data;
     ret = d2i(x, &amp;p, len);
     if (ret == NULL)
-        PEMerr(PEM_F_PEM_ASN1_READ_BIO, ERR_R_ASN1_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_ASN1_LIB);
     OPENSSL_free(data);
     return ret;
 }
diff --git a/crypto/pem/pem_pk8.c b/crypto/pem/pem_pk8.c
index 797c9881d8..560754007b 100644
--- a/crypto/pem/pem_pk8.c
+++ b/crypto/pem/pem_pk8.c
@@ -124,14 +124,14 @@ static int do_pk8pkey(BIO *bp, const EVP_PKEY *x, int isder, int nid,
 
         ret = 0;
         if ((p8inf = EVP_PKEY2PKCS8(x)) == NULL) {
-            PEMerr(PEM_F_DO_PK8PKEY, PEM_R_ERROR_CONVERTING_PRIVATE_KEY);
+            ERR_raise(ERR_LIB_PEM, PEM_R_ERROR_CONVERTING_PRIVATE_KEY);
             goto legacy_end;
         }
         if (enc || (nid != -1)) {
             if (kstr == NULL) {
                 klen = cb(buf, PEM_BUFSIZE, 1, u);
                 if (klen &lt;= 0) {
-                    PEMerr(PEM_F_DO_PK8PKEY, PEM_R_READ_KEY);
+                    ERR_raise(ERR_LIB_PEM, PEM_R_READ_KEY);
                     goto legacy_end;
                 }
 
@@ -177,7 +177,7 @@ EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
     else
         klen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
     if (klen &lt; 0) {
-        PEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_BIO, PEM_R_BAD_PASSWORD_READ);
+        ERR_raise(ERR_LIB_PEM, PEM_R_BAD_PASSWORD_READ);
         X509_SIG_free(p8);
         return NULL;
     }
@@ -236,7 +236,7 @@ static int do_pk8pkey_fp(FILE *fp, const EVP_PKEY *x, int isder, int nid,
     int ret;
 
     if ((bp = BIO_new_fp(fp, BIO_NOCLOSE)) == NULL) {
-        PEMerr(PEM_F_DO_PK8PKEY_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return 0;
     }
     ret = do_pk8pkey(bp, x, isder, nid, enc, kstr, klen, cb, u, libctx, propq);
@@ -251,7 +251,7 @@ EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
     EVP_PKEY *ret;
 
     if ((bp = BIO_new_fp(fp, BIO_NOCLOSE)) == NULL) {
-        PEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return NULL;
     }
     ret = d2i_PKCS8PrivateKey_bio(bp, x, cb, u);
diff --git a/crypto/pem/pem_pkey.c b/crypto/pem/pem_pkey.c
index e6c07b8fd6..717fb4ef4d 100644
--- a/crypto/pem/pem_pkey.c
+++ b/crypto/pem/pem_pkey.c
@@ -122,7 +122,7 @@ EVP_PKEY *PEM_read_PUBKEY_ex(FILE *fp, EVP_PKEY **x,
     EVP_PKEY *ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        PEMerr(0, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -234,7 +234,7 @@ EVP_PKEY *PEM_read_PrivateKey_ex(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
     EVP_PKEY *ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        PEMerr(0, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -257,7 +257,7 @@ int PEM_write_PrivateKey(FILE *fp, const EVP_PKEY *x, const EVP_CIPHER *enc,
     int ret;
 
     if ((b = BIO_new_fp(fp, BIO_NOCLOSE)) == NULL) {
-        PEMerr(PEM_F_PEM_WRITE_PRIVATEKEY, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_PEM, ERR_R_BUF_LIB);
         return 0;
     }
     ret = PEM_write_bio_PrivateKey(b, x, enc, kstr, klen, cb, u);
diff --git a/crypto/pem/pem_sign.c b/crypto/pem/pem_sign.c
index c12afd5c3b..eb8faa7a68 100644
--- a/crypto/pem/pem_sign.c
+++ b/crypto/pem/pem_sign.c
@@ -34,7 +34,7 @@ int PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,
 
     m = OPENSSL_malloc(EVP_PKEY_size(pkey));
     if (m == NULL) {
-        PEMerr(PEM_F_PEM_SIGNFINAL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
diff --git a/crypto/pem/pvkfmt.c b/crypto/pem/pvkfmt.c
index bd1d99e338..d10cf7a349 100644
--- a/crypto/pem/pvkfmt.c
+++ b/crypto/pem/pvkfmt.c
@@ -100,13 +100,13 @@ int ossl_do_blob_header(const unsigned char **in, unsigned int length,
     /* bType */
     if (*p == MS_PUBLICKEYBLOB) {
         if (*pispub == 0) {
-            PEMerr(PEM_F_OSSL_DO_BLOB_HEADER, PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
+            ERR_raise(ERR_LIB_PEM, PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
             return 0;
         }
         *pispub = 1;
     } else if (*p == MS_PRIVATEKEYBLOB) {
         if (*pispub == 1) {
-            PEMerr(PEM_F_OSSL_DO_BLOB_HEADER, PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
+            ERR_raise(ERR_LIB_PEM, PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
             return 0;
         }
         *pispub = 0;
@@ -115,7 +115,7 @@ int ossl_do_blob_header(const unsigned char **in, unsigned int length,
     p++;
     /* Version */
     if (*p++ != 0x2) {
-        PEMerr(PEM_F_OSSL_DO_BLOB_HEADER, PEM_R_BAD_VERSION_NUMBER);
+        ERR_raise(ERR_LIB_PEM, PEM_R_BAD_VERSION_NUMBER);
         return 0;
     }
     /* Ignore reserved, aiKeyAlg */
@@ -130,7 +130,7 @@ int ossl_do_blob_header(const unsigned char **in, unsigned int length,
         /* fall thru */
     case MS_RSA1MAGIC:
         if (*pispub == 0) {
-            PEMerr(PEM_F_OSSL_DO_BLOB_HEADER, PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
+            ERR_raise(ERR_LIB_PEM, PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
             return 0;
         }
         break;
@@ -140,13 +140,13 @@ int ossl_do_blob_header(const unsigned char **in, unsigned int length,
         /* fall thru */
     case MS_RSA2MAGIC:
         if (*pispub == 1) {
-            PEMerr(PEM_F_OSSL_DO_BLOB_HEADER, PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
+            ERR_raise(ERR_LIB_PEM, PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
             return 0;
         }
         break;
 
     default:
-        PEMerr(PEM_F_OSSL_DO_BLOB_HEADER, PEM_R_BAD_MAGIC_NUMBER);
+        ERR_raise(ERR_LIB_PEM, PEM_R_BAD_MAGIC_NUMBER);
         return -1;
     }
     *in = p;
@@ -192,12 +192,12 @@ EVP_PKEY *ossl_b2i(const unsigned char **in, unsigned int length, int *ispub)
     unsigned int bitlen, magic;
     int isdss;
     if (ossl_do_blob_header(&amp;p, length, &amp;magic, &amp;bitlen, &amp;isdss, ispub) &lt;= 0) {
-        PEMerr(0, PEM_R_KEYBLOB_HEADER_PARSE_ERROR);
+        ERR_raise(ERR_LIB_PEM, PEM_R_KEYBLOB_HEADER_PARSE_ERROR);
         return NULL;
     }
     length -= 16;
     if (length &lt; blob_length(bitlen, isdss, *ispub)) {
-        PEMerr(0, PEM_R_KEYBLOB_TOO_SHORT);
+        ERR_raise(ERR_LIB_PEM, PEM_R_KEYBLOB_TOO_SHORT);
         return NULL;
     }
     if (isdss)
@@ -214,7 +214,7 @@ EVP_PKEY *ossl_b2i_bio(BIO *in, int *ispub)
     int isdss;
     EVP_PKEY *ret = NULL;
     if (BIO_read(in, hdr_buf, 16) != 16) {
-        PEMerr(0, PEM_R_KEYBLOB_TOO_SHORT);
+        ERR_raise(ERR_LIB_PEM, PEM_R_KEYBLOB_TOO_SHORT);
         return NULL;
     }
     p = hdr_buf;
@@ -223,17 +223,17 @@ EVP_PKEY *ossl_b2i_bio(BIO *in, int *ispub)
 
     length = blob_length(bitlen, isdss, *ispub);
     if (length &gt; BLOB_MAX_LENGTH) {
-        PEMerr(0, PEM_R_HEADER_TOO_LONG);
+        ERR_raise(ERR_LIB_PEM, PEM_R_HEADER_TOO_LONG);
         return NULL;
     }
     buf = OPENSSL_malloc(length);
     if (buf == NULL) {
-        PEMerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     p = buf;
     if (BIO_read(in, buf, length) != (int)length) {
-        PEMerr(0, PEM_R_KEYBLOB_TOO_SHORT);
+        ERR_raise(ERR_LIB_PEM, PEM_R_KEYBLOB_TOO_SHORT);
         goto err;
     }
 
@@ -310,7 +310,7 @@ static EVP_PKEY *b2i_dss(const unsigned char **in,
     return ret;
 
  memerr:
-    PEMerr(PEM_F_B2I_DSS, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
     DSA_free(dsa);
     BN_free(pbn);
     BN_free(qbn);
@@ -374,7 +374,7 @@ static EVP_PKEY *b2i_rsa(const unsigned char **in,
     *in = pin;
     return ret;
  memerr:
-    PEMerr(PEM_F_B2I_RSA, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
     BN_free(e);
     BN_free(n);
     BN_free(p);
@@ -462,7 +462,7 @@ static int do_i2b(unsigned char **out, const EVP_PKEY *pk, int ispub)
         p = *out;
     else {
         if ((p = OPENSSL_malloc(outlen)) == NULL) {
-            PEMerr(PEM_F_DO_I2B, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
             return -1;
         }
         *out = p;
@@ -525,7 +525,7 @@ static int check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *pmagic)
 
     return bitlen;
  badkey:
-    PEMerr(PEM_F_CHECK_BITLEN_DSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
+    ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
     return 0;
 }
 
@@ -565,7 +565,7 @@ static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)
     }
     return bitlen;
  badkey:
-    PEMerr(PEM_F_CHECK_BITLEN_RSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
+    ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
     return 0;
 }
 
@@ -634,17 +634,17 @@ int ossl_do_PVK_header(const unsigned char **in, unsigned int length,
 
     if (skip_magic) {
         if (length &lt; 20) {
-            PEMerr(PEM_F_OSSL_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);
+            ERR_raise(ERR_LIB_PEM, PEM_R_PVK_TOO_SHORT);
             return 0;
         }
     } else {
         if (length &lt; 24) {
-            PEMerr(PEM_F_OSSL_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);
+            ERR_raise(ERR_LIB_PEM, PEM_R_PVK_TOO_SHORT);
             return 0;
         }
         pvk_magic = read_ledword(&amp;p);
         if (pvk_magic != MS_PVKMAGIC) {
-            PEMerr(PEM_F_OSSL_DO_PVK_HEADER, PEM_R_BAD_MAGIC_NUMBER);
+            ERR_raise(ERR_LIB_PEM, PEM_R_BAD_MAGIC_NUMBER);
             return 0;
         }
     }
@@ -661,7 +661,7 @@ int ossl_do_PVK_header(const unsigned char **in, unsigned int length,
         return 0;
 
     if (is_encrypted &amp;&amp; *psaltlen == 0) {
-        PEMerr(PEM_F_OSSL_DO_PVK_HEADER, PEM_R_INCONSISTENT_HEADER);
+        ERR_raise(ERR_LIB_PEM, PEM_R_INCONSISTENT_HEADER);
         return 0;
     }
 
@@ -705,12 +705,12 @@ static EVP_PKEY *do_PVK_body(const unsigned char **in,
         else
             inlen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
         if (inlen &lt; 0) {
-            PEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_PASSWORD_READ);
+            ERR_raise(ERR_LIB_PEM, PEM_R_BAD_PASSWORD_READ);
             goto err;
         }
         enctmp = OPENSSL_malloc(keylen + 8);
         if (enctmp == NULL) {
-            PEMerr(PEM_F_DO_PVK_BODY, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (!derive_pvk_key(keybuf, p, saltlen,
@@ -721,7 +721,7 @@ static EVP_PKEY *do_PVK_body(const unsigned char **in,
         memcpy(enctmp, p, 8);
         p += 8;
         if (keylen &lt; 8) {
-            PEMerr(PEM_F_DO_PVK_BODY, PEM_R_PVK_TOO_SHORT);
+            ERR_raise(ERR_LIB_PEM, PEM_R_PVK_TOO_SHORT);
             goto err;
         }
         inlen = keylen - 8;
@@ -744,7 +744,7 @@ static EVP_PKEY *do_PVK_body(const unsigned char **in,
                 goto err;
             magic = read_ledword((const unsigned char **)&amp;q);
             if (magic != MS_RSA2MAGIC &amp;&amp; magic != MS_DSS2MAGIC) {
-                PEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_DECRYPT);
+                ERR_raise(ERR_LIB_PEM, PEM_R_BAD_DECRYPT);
                 goto err;
             }
         }
@@ -769,7 +769,7 @@ EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u)
     EVP_PKEY *ret = NULL;
     unsigned int saltlen, keylen;
     if (BIO_read(in, pvk_hdr, 24) != 24) {
-        PEMerr(PEM_F_B2I_PVK_BIO, PEM_R_PVK_DATA_TOO_SHORT);
+        ERR_raise(ERR_LIB_PEM, PEM_R_PVK_DATA_TOO_SHORT);
         return NULL;
     }
     p = pvk_hdr;
@@ -779,12 +779,12 @@ EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u)
     buflen = (int)keylen + saltlen;
     buf = OPENSSL_malloc(buflen);
     if (buf == NULL) {
-        PEMerr(PEM_F_B2I_PVK_BIO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     p = buf;
     if (BIO_read(in, buf, buflen) != buflen) {
-        PEMerr(PEM_F_B2I_PVK_BIO, PEM_R_PVK_DATA_TOO_SHORT);
+        ERR_raise(ERR_LIB_PEM, PEM_R_PVK_DATA_TOO_SHORT);
         goto err;
     }
     ret = do_PVK_body(&amp;p, saltlen, keylen, cb, u);
@@ -813,7 +813,7 @@ static int i2b_PVK(unsigned char **out, const EVP_PKEY *pk, int enclevel,
     } else {
         start = p = OPENSSL_malloc(outlen);
         if (p == NULL) {
-            PEMerr(PEM_F_I2B_PVK, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
             return -1;
         }
     }
@@ -847,7 +847,7 @@ static int i2b_PVK(unsigned char **out, const EVP_PKEY *pk, int enclevel,
         else
             inlen = PEM_def_callback(psbuf, PEM_BUFSIZE, 1, u);
         if (inlen &lt;= 0) {
-            PEMerr(PEM_F_I2B_PVK, PEM_R_BAD_PASSWORD_READ);
+            ERR_raise(ERR_LIB_PEM, PEM_R_BAD_PASSWORD_READ);
             goto error;
         }
         if (!derive_pvk_key(keybuf, salt, PVK_SALTLEN,
@@ -892,7 +892,7 @@ int i2b_PVK_bio(BIO *out, const EVP_PKEY *pk, int enclevel,
     if (wrlen == outlen) {
         return outlen;
     }
-    PEMerr(PEM_F_I2B_PVK_BIO, PEM_R_BIO_WRITE_FAILURE);
+    ERR_raise(ERR_LIB_PEM, PEM_R_BIO_WRITE_FAILURE);
     return -1;
 }
 
diff --git a/crypto/pkcs12/p12_add.c b/crypto/pkcs12/p12_add.c
index 06837f537f..f5814744a5 100644
--- a/crypto/pkcs12/p12_add.c
+++ b/crypto/pkcs12/p12_add.c
@@ -21,16 +21,16 @@ PKCS12_SAFEBAG *PKCS12_item_pack_safebag(void *obj, const ASN1_ITEM *it,
     PKCS12_SAFEBAG *safebag;
 
     if ((bag = PKCS12_BAGS_new()) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     bag-&gt;type = OBJ_nid2obj(nid1);
     if (!ASN1_item_pack(obj, it, &amp;bag-&gt;value.octet)) {
-        PKCS12err(PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if ((safebag = PKCS12_SAFEBAG_new()) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     safebag-&gt;value.bag = bag;
@@ -48,17 +48,17 @@ PKCS7 *PKCS12_pack_p7data(STACK_OF(PKCS12_SAFEBAG) *sk)
     PKCS7 *p7;
 
     if ((p7 = PKCS7_new()) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_PACK_P7DATA, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     p7-&gt;type = OBJ_nid2obj(NID_pkcs7_data);
     if ((p7-&gt;d.data = ASN1_OCTET_STRING_new()) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_PACK_P7DATA, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (!ASN1_item_pack(sk, ASN1_ITEM_rptr(PKCS12_SAFEBAGS), &amp;p7-&gt;d.data)) {
-        PKCS12err(PKCS12_F_PKCS12_PACK_P7DATA, PKCS12_R_CANT_PACK_STRUCTURE);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CANT_PACK_STRUCTURE);
         goto err;
     }
     return p7;
@@ -72,8 +72,7 @@ PKCS7 *PKCS12_pack_p7data(STACK_OF(PKCS12_SAFEBAG) *sk)
 STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)
 {
     if (!PKCS7_type_is_data(p7)) {
-        PKCS12err(PKCS12_F_PKCS12_UNPACK_P7DATA,
-                  PKCS12_R_CONTENT_TYPE_NOT_DATA);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);
         return NULL;
     }
     return ASN1_item_unpack(p7-&gt;d.data, ASN1_ITEM_rptr(PKCS12_SAFEBAGS));
@@ -90,12 +89,11 @@ PKCS7 *PKCS12_pack_p7encdata(int pbe_nid, const char *pass, int passlen,
     const EVP_CIPHER *pbe_ciph;
 
     if ((p7 = PKCS7_new()) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     if (!PKCS7_set_type(p7, NID_pkcs7_encrypted)) {
-        PKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA,
-                  PKCS12_R_ERROR_SETTING_ENCRYPTED_DATA_TYPE);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_ERROR_SETTING_ENCRYPTED_DATA_TYPE);
         goto err;
     }
 
@@ -107,7 +105,7 @@ PKCS7 *PKCS12_pack_p7encdata(int pbe_nid, const char *pass, int passlen,
         pbe = PKCS5_pbe_set(pbe_nid, iter, salt, saltlen);
 
     if (pbe == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     X509_ALGOR_free(p7-&gt;d.encrypted-&gt;enc_data-&gt;algorithm);
@@ -116,7 +114,7 @@ PKCS7 *PKCS12_pack_p7encdata(int pbe_nid, const char *pass, int passlen,
     if (!(p7-&gt;d.encrypted-&gt;enc_data-&gt;enc_data =
           PKCS12_item_i2d_encrypt(pbe, ASN1_ITEM_rptr(PKCS12_SAFEBAGS), pass,
                                   passlen, bags, 1))) {
-        PKCS12err(PKCS12_F_PKCS12_PACK_P7ENCDATA, PKCS12_R_ENCRYPT_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_ENCRYPT_ERROR);
         goto err;
     }
 
@@ -155,8 +153,7 @@ int PKCS12_pack_authsafes(PKCS12 *p12, STACK_OF(PKCS7) *safes)
 STACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)
 {
     if (!PKCS7_type_is_data(p12-&gt;authsafes)) {
-        PKCS12err(PKCS12_F_PKCS12_UNPACK_AUTHSAFES,
-                  PKCS12_R_CONTENT_TYPE_NOT_DATA);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);
         return NULL;
     }
     return ASN1_item_unpack(p12-&gt;authsafes-&gt;d.data,
diff --git a/crypto/pkcs12/p12_crpt.c b/crypto/pkcs12/p12_crpt.c
index 937bfea045..cd0adcee8d 100644
--- a/crypto/pkcs12/p12_crpt.c
+++ b/crypto/pkcs12/p12_crpt.c
@@ -40,7 +40,7 @@ int PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
 
     pbe = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(PBEPARAM), param);
     if (pbe == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN, PKCS12_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);
         return 0;
     }
 
@@ -52,13 +52,13 @@ int PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
     saltlen = pbe-&gt;salt-&gt;length;
     if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_KEY_ID,
                            iter, EVP_CIPHER_key_length(cipher), key, md)) {
-        PKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN, PKCS12_R_KEY_GEN_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_KEY_GEN_ERROR);
         PBEPARAM_free(pbe);
         return 0;
     }
     if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_IV_ID,
                            iter, EVP_CIPHER_iv_length(cipher), iv, md)) {
-        PKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN, PKCS12_R_IV_GEN_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_IV_GEN_ERROR);
         PBEPARAM_free(pbe);
         return 0;
     }
diff --git a/crypto/pkcs12/p12_crt.c b/crypto/pkcs12/p12_crt.c
index 88571fd165..9bc53f789b 100644
--- a/crypto/pkcs12/p12_crt.c
+++ b/crypto/pkcs12/p12_crt.c
@@ -55,7 +55,7 @@ PKCS12 *PKCS12_create(const char *pass, const char *name, EVP_PKEY *pkey, X509 *
         mac_iter = 1;
 
     if (pkey == NULL &amp;&amp; cert == NULL &amp;&amp; ca == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_CREATE, PKCS12_R_INVALID_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_INVALID_NULL_ARGUMENT);
         return NULL;
     }
 
diff --git a/crypto/pkcs12/p12_decr.c b/crypto/pkcs12/p12_decr.c
index cabfe07908..3571ac571a 100644
--- a/crypto/pkcs12/p12_decr.c
+++ b/crypto/pkcs12/p12_decr.c
@@ -27,7 +27,7 @@ unsigned char *PKCS12_pbe_crypt(const X509_ALGOR *algor,
     int max_out_len, mac_len = 0;
 
     if (ctx == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -45,7 +45,7 @@ unsigned char *PKCS12_pbe_crypt(const X509_ALGOR *algor,
     max_out_len = inlen + EVP_CIPHER_CTX_block_size(ctx);
     if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_CIPHER_WITH_MAC) {
         if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_TLS1_AAD, 0, &amp;mac_len) &lt; 0) {
-            PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_PKCS12, ERR_R_INTERNAL_ERROR);
             goto err;
         }
 
@@ -53,28 +53,27 @@ unsigned char *PKCS12_pbe_crypt(const X509_ALGOR *algor,
             max_out_len += mac_len;
         } else {
             if (inlen &lt; mac_len) {
-                PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,
-                          PKCS12_R_UNSUPPORTED_PKCS12_MODE);
+                ERR_raise(ERR_LIB_PKCS12, PKCS12_R_UNSUPPORTED_PKCS12_MODE);
                 goto err;
             }
             inlen -= mac_len;
             if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,
                                     (int)mac_len, (unsigned char *)in+inlen) &lt; 0) {
-                PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_PKCS12, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
         }
     }
 
     if ((out = OPENSSL_malloc(max_out_len)) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (!EVP_CipherUpdate(ctx, out, &amp;i, in, inlen)) {
         OPENSSL_free(out);
         out = NULL;
-        PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_EVP_LIB);
         goto err;
     }
 
@@ -82,8 +81,7 @@ unsigned char *PKCS12_pbe_crypt(const X509_ALGOR *algor,
     if (!EVP_CipherFinal_ex(ctx, out + i, &amp;i)) {
         OPENSSL_free(out);
         out = NULL;
-        PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,
-                  PKCS12_R_PKCS12_CIPHERFINAL_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_PKCS12_CIPHERFINAL_ERROR);
         goto err;
     }
     outlen += i;
@@ -91,7 +89,7 @@ unsigned char *PKCS12_pbe_crypt(const X509_ALGOR *algor,
         if (EVP_CIPHER_CTX_encrypting(ctx)) {
             if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG,
                 (int)mac_len, out+outlen) &lt; 0) {
-                PKCS12err(PKCS12_F_PKCS12_PBE_CRYPT, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_PKCS12, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
             outlen += mac_len;
@@ -134,7 +132,7 @@ void *PKCS12_item_decrypt_d2i(const X509_ALGOR *algor, const ASN1_ITEM *it,
     if (zbuf)
         OPENSSL_cleanse(out, outlen);
     if (!ret)
-        PKCS12err(PKCS12_F_PKCS12_ITEM_DECRYPT_D2I, PKCS12_R_DECODE_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);
     OPENSSL_free(out);
     return ret;
 }
@@ -154,17 +152,17 @@ ASN1_OCTET_STRING *PKCS12_item_i2d_encrypt(X509_ALGOR *algor,
     int inlen;
 
     if ((oct = ASN1_OCTET_STRING_new()) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     inlen = ASN1_item_i2d(obj, &amp;in, it);
     if (!in) {
-        PKCS12err(PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT, PKCS12_R_ENCODE_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_ENCODE_ERROR);
         goto err;
     }
     if (!PKCS12_pbe_crypt(algor, pass, passlen, in, inlen, &amp;oct-&gt;data,
                           &amp;oct-&gt;length, 1)) {
-        PKCS12err(PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT, PKCS12_R_ENCRYPT_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_ENCRYPT_ERROR);
         OPENSSL_free(in);
         goto err;
     }
diff --git a/crypto/pkcs12/p12_init.c b/crypto/pkcs12/p12_init.c
index 00c8d4f5d4..30ae5298dd 100644
--- a/crypto/pkcs12/p12_init.c
+++ b/crypto/pkcs12/p12_init.c
@@ -19,7 +19,7 @@ PKCS12 *PKCS12_init(int mode)
     PKCS12 *pkcs12;
 
     if ((pkcs12 = PKCS12_new()) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     if (!ASN1_INTEGER_set(pkcs12-&gt;version, 3))
@@ -28,12 +28,12 @@ PKCS12 *PKCS12_init(int mode)
     switch (mode) {
     case NID_pkcs7_data:
         if ((pkcs12-&gt;authsafes-&gt;d.data = ASN1_OCTET_STRING_new()) == NULL) {
-            PKCS12err(PKCS12_F_PKCS12_INIT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         break;
     default:
-        PKCS12err(PKCS12_F_PKCS12_INIT, PKCS12_R_UNSUPPORTED_PKCS12_MODE);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_UNSUPPORTED_PKCS12_MODE);
         goto err;
     }
     return pkcs12;
diff --git a/crypto/pkcs12/p12_key.c b/crypto/pkcs12/p12_key.c
index 20a29c7d44..7c4056a8f8 100644
--- a/crypto/pkcs12/p12_key.c
+++ b/crypto/pkcs12/p12_key.c
@@ -28,7 +28,7 @@ int PKCS12_key_gen_asc(const char *pass, int passlen, unsigned char *salt,
         unipass = NULL;
         uniplen = 0;
     } else if (!OPENSSL_asc2uni(pass, passlen, &amp;unipass, &amp;uniplen)) {
-        PKCS12err(PKCS12_F_PKCS12_KEY_GEN_ASC, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ret = PKCS12_key_gen_uni(unipass, uniplen, salt, saltlen,
@@ -49,7 +49,7 @@ int PKCS12_key_gen_utf8(const char *pass, int passlen, unsigned char *salt,
         unipass = NULL;
         uniplen = 0;
     } else if (!OPENSSL_utf82uni(pass, passlen, &amp;unipass, &amp;uniplen)) {
-        PKCS12err(PKCS12_F_PKCS12_KEY_GEN_UTF8, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ret = PKCS12_key_gen_uni(unipass, uniplen, salt, saltlen,
diff --git a/crypto/pkcs12/p12_kiss.c b/crypto/pkcs12/p12_kiss.c
index ad1f4ee1ed..894520be39 100644
--- a/crypto/pkcs12/p12_kiss.c
+++ b/crypto/pkcs12/p12_kiss.c
@@ -44,8 +44,7 @@ int PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,
     /* Check for NULL PKCS12 structure */
 
     if (p12 == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_PARSE,
-                  PKCS12_R_INVALID_NULL_PKCS12_POINTER);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_INVALID_NULL_PKCS12_POINTER);
         return 0;
     }
 
@@ -64,18 +63,18 @@ int PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,
         else if (PKCS12_verify_mac(p12, &quot;&quot;, 0))
             pass = &quot;&quot;;
         else {
-            PKCS12err(PKCS12_F_PKCS12_PARSE, PKCS12_R_MAC_VERIFY_FAILURE);
+            ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_VERIFY_FAILURE);
             goto err;
         }
     } else if (!PKCS12_verify_mac(p12, pass, -1)) {
-        PKCS12err(PKCS12_F_PKCS12_PARSE, PKCS12_R_MAC_VERIFY_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_VERIFY_FAILURE);
         goto err;
     }
 
     /* If needed, allocate stack for other certificates */
     if ((cert != NULL || ca != NULL)
             &amp;&amp; (ocerts = sk_X509_new_null()) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_PARSE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -84,7 +83,7 @@ int PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,
 
         if (ERR_GET_LIB(err) != ERR_LIB_EVP
                 &amp;&amp; ERR_GET_REASON(err) != EVP_R_UNSUPPORTED_ALGORITHM)
-            PKCS12err(0, PKCS12_R_PARSE_ERROR);
+            ERR_raise(ERR_LIB_PKCS12, PKCS12_R_PARSE_ERROR);
         goto err;
     }
 
diff --git a/crypto/pkcs12/p12_mutl.c b/crypto/pkcs12/p12_mutl.c
index eb9e6eb477..4873d43e24 100644
--- a/crypto/pkcs12/p12_mutl.c
+++ b/crypto/pkcs12/p12_mutl.c
@@ -95,7 +95,7 @@ static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,
         pkcs12_key_gen = PKCS12_key_gen_utf8;
 
     if (!PKCS7_type_is_data(p12-&gt;authsafes)) {
-        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_CONTENT_TYPE_NOT_DATA);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);
         return 0;
     }
 
@@ -108,7 +108,7 @@ static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,
     X509_SIG_get0(p12-&gt;mac-&gt;dinfo, &amp;macalg, NULL);
     X509_ALGOR_get0(&amp;macoid, NULL, NULL, macalg);
     if ((md_type = EVP_get_digestbyobj(macoid)) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);
         return 0;
     }
     md_size = EVP_MD_size(md_type);
@@ -122,13 +122,13 @@ static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,
         md_size = TK26_MAC_KEY_LEN;
         if (!pkcs12_gen_gost_mac_key(pass, passlen, salt, saltlen, iter,
                                      md_size, key, md_type)) {
-            PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);
+            ERR_raise(ERR_LIB_PKCS12, PKCS12_R_KEY_GEN_ERROR);
             goto err;
         }
     } else
         if (!(*pkcs12_key_gen)(pass, passlen, salt, saltlen, PKCS12_MAC_ID,
                                iter, md_size, key, md_type)) {
-        PKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_KEY_GEN_ERROR);
         goto err;
     }
     if ((hmac = HMAC_CTX_new()) == NULL
@@ -160,12 +160,12 @@ int PKCS12_verify_mac(PKCS12 *p12, const char *pass, int passlen)
     const ASN1_OCTET_STRING *macoct;
 
     if (p12-&gt;mac == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_ABSENT);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_ABSENT);
         return 0;
     }
     if (!pkcs12_gen_mac(p12, pass, passlen, mac, &amp;maclen,
                         PKCS12_key_gen_utf8)) {
-        PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_GENERATION_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_GENERATION_ERROR);
         return 0;
     }
     X509_SIG_get0(p12-&gt;mac-&gt;dinfo, NULL, &amp;macoct);
@@ -189,7 +189,7 @@ int PKCS12_set_mac(PKCS12 *p12, const char *pass, int passlen,
     if (!md_type)
         md_type = EVP_sha1();
     if (PKCS12_setup_mac(p12, iter, salt, saltlen, md_type) == PKCS12_ERROR) {
-        PKCS12err(PKCS12_F_PKCS12_SET_MAC, PKCS12_R_MAC_SETUP_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_SETUP_ERROR);
         return 0;
     }
     /*
@@ -197,12 +197,12 @@ int PKCS12_set_mac(PKCS12 *p12, const char *pass, int passlen,
      */
     if (!pkcs12_gen_mac(p12, pass, passlen, mac, &amp;maclen,
                         PKCS12_key_gen_utf8)) {
-        PKCS12err(PKCS12_F_PKCS12_SET_MAC, PKCS12_R_MAC_GENERATION_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_GENERATION_ERROR);
         return 0;
     }
     X509_SIG_getm(p12-&gt;mac-&gt;dinfo, NULL, &amp;macoct);
     if (!ASN1_OCTET_STRING_set(macoct, mac, maclen)) {
-        PKCS12err(PKCS12_F_PKCS12_SET_MAC, PKCS12_R_MAC_STRING_SET_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_STRING_SET_ERROR);
         return 0;
     }
     return 1;
@@ -221,18 +221,18 @@ int PKCS12_setup_mac(PKCS12 *p12, int iter, unsigned char *salt, int saltlen,
         return PKCS12_ERROR;
     if (iter &gt; 1) {
         if ((p12-&gt;mac-&gt;iter = ASN1_INTEGER_new()) == NULL) {
-            PKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         if (!ASN1_INTEGER_set(p12-&gt;mac-&gt;iter, iter)) {
-            PKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     }
     if (!saltlen)
         saltlen = PKCS12_SALT_LEN;
     if ((p12-&gt;mac-&gt;salt-&gt;data = OPENSSL_malloc(saltlen)) == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     p12-&gt;mac-&gt;salt-&gt;length = saltlen;
@@ -244,7 +244,7 @@ int PKCS12_setup_mac(PKCS12 *p12, int iter, unsigned char *salt, int saltlen,
     X509_SIG_getm(p12-&gt;mac-&gt;dinfo, &amp;macalg, NULL);
     if (!X509_ALGOR_set0(macalg, OBJ_nid2obj(EVP_MD_type(md_type)),
                          V_ASN1_NULL, NULL)) {
-        PKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/pkcs12/p12_npas.c b/crypto/pkcs12/p12_npas.c
index 7f04ce10de..62230bc618 100644
--- a/crypto/pkcs12/p12_npas.c
+++ b/crypto/pkcs12/p12_npas.c
@@ -34,20 +34,19 @@ int PKCS12_newpass(PKCS12 *p12, const char *oldpass, const char *newpass)
     /* Check for NULL PKCS12 structure */
 
     if (p12 == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_NEWPASS,
-                  PKCS12_R_INVALID_NULL_PKCS12_POINTER);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_INVALID_NULL_PKCS12_POINTER);
         return 0;
     }
 
     /* Check the mac */
 
     if (!PKCS12_verify_mac(p12, oldpass, -1)) {
-        PKCS12err(PKCS12_F_PKCS12_NEWPASS, PKCS12_R_MAC_VERIFY_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_MAC_VERIFY_FAILURE);
         return 0;
     }
 
     if (!newpass_p12(p12, oldpass, newpass)) {
-        PKCS12err(PKCS12_F_PKCS12_NEWPASS, PKCS12_R_PARSE_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_PARSE_ERROR);
         return 0;
     }
 
diff --git a/crypto/pkcs12/p12_p8e.c b/crypto/pkcs12/p12_p8e.c
index 14df4fdea4..32a06d7fc3 100644
--- a/crypto/pkcs12/p12_p8e.c
+++ b/crypto/pkcs12/p12_p8e.c
@@ -29,7 +29,7 @@ X509_SIG *PKCS8_encrypt(int pbe_nid, const EVP_CIPHER *cipher,
         pbe = PKCS5_pbe_set(pbe_nid, iter, salt, saltlen);
     }
     if (pbe == NULL) {
-        PKCS12err(PKCS12_F_PKCS8_ENCRYPT, ERR_R_ASN1_LIB);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_ASN1_LIB);
         return NULL;
     }
     p8 = PKCS8_set0_pbe(pass, passlen, p8inf, pbe);
@@ -51,14 +51,14 @@ X509_SIG *PKCS8_set0_pbe(const char *pass, int passlen,
         PKCS12_item_i2d_encrypt(pbe, ASN1_ITEM_rptr(PKCS8_PRIV_KEY_INFO),
                                 pass, passlen, p8inf, 1);
     if (!enckey) {
-        PKCS12err(PKCS12_F_PKCS8_SET0_PBE, PKCS12_R_ENCRYPT_ERROR);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_ENCRYPT_ERROR);
         return NULL;
     }
 
     p8 = OPENSSL_zalloc(sizeof(*p8));
 
     if (p8 == NULL) {
-        PKCS12err(PKCS12_F_PKCS8_SET0_PBE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         ASN1_OCTET_STRING_free(enckey);
         return NULL;
     }
diff --git a/crypto/pkcs12/p12_sbag.c b/crypto/pkcs12/p12_sbag.c
index 3da437f7ea..2387a8db43 100644
--- a/crypto/pkcs12/p12_sbag.c
+++ b/crypto/pkcs12/p12_sbag.c
@@ -119,7 +119,7 @@ PKCS12_SAFEBAG *PKCS12_SAFEBAG_create_secret(int type, int vtype, const unsigned
     PKCS12_SAFEBAG *safebag;
 
     if ((bag = PKCS12_BAGS_new()) == NULL) {
-        PKCS12err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     bag-&gt;type = OBJ_nid2obj(type);
@@ -130,19 +130,19 @@ PKCS12_SAFEBAG *PKCS12_SAFEBAG_create_secret(int type, int vtype, const unsigned
             ASN1_OCTET_STRING *strtmp = ASN1_OCTET_STRING_new();
 
             if (strtmp == NULL) {
-                PKCS12err(0, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             /* Pack data into an octet string */
             if (!ASN1_OCTET_STRING_set(strtmp, value, len)) {
                 ASN1_OCTET_STRING_free(strtmp);
-                PKCS12err(0, PKCS12_R_ENCODE_ERROR);
+                ERR_raise(ERR_LIB_PKCS12, PKCS12_R_ENCODE_ERROR);
                 goto err;
             }
             bag-&gt;value.other = ASN1_TYPE_new();
             if (bag-&gt;value.other == NULL) {
                 ASN1_OCTET_STRING_free(strtmp);
-                PKCS12err(0, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             ASN1_TYPE_set(bag-&gt;value.other, vtype, strtmp);
@@ -150,12 +150,12 @@ PKCS12_SAFEBAG *PKCS12_SAFEBAG_create_secret(int type, int vtype, const unsigned
         break;
 
     default:
-        PKCS12err(0, PKCS12_R_INVALID_TYPE);
+        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_INVALID_TYPE);
         goto err;
     }
 
     if ((safebag = PKCS12_SAFEBAG_new()) == NULL) {
-        PKCS12err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     safebag-&gt;value.bag = bag;
@@ -174,7 +174,7 @@ PKCS12_SAFEBAG *PKCS12_SAFEBAG_create0_p8inf(PKCS8_PRIV_KEY_INFO *p8)
     PKCS12_SAFEBAG *bag = PKCS12_SAFEBAG_new();
 
     if (bag == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_SAFEBAG_CREATE0_P8INF, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     bag-&gt;type = OBJ_nid2obj(NID_keyBag);
@@ -190,7 +190,7 @@ PKCS12_SAFEBAG *PKCS12_SAFEBAG_create0_pkcs8(X509_SIG *p8)
 
     /* Set up the safe bag */
     if (bag == NULL) {
-        PKCS12err(PKCS12_F_PKCS12_SAFEBAG_CREATE0_PKCS8, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     bag-&gt;type = OBJ_nid2obj(NID_pkcs8ShroudedKeyBag);
diff --git a/crypto/pkcs12/p12_utl.c b/crypto/pkcs12/p12_utl.c
index 9e792d427a..d9ace8d1c0 100644
--- a/crypto/pkcs12/p12_utl.c
+++ b/crypto/pkcs12/p12_utl.c
@@ -23,7 +23,7 @@ unsigned char *OPENSSL_asc2uni(const char *asc, int asclen,
         asclen = strlen(asc);
     ulen = asclen * 2 + 2;
     if ((unitmp = OPENSSL_malloc(ulen)) == NULL) {
-        PKCS12err(PKCS12_F_OPENSSL_ASC2UNI, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     for (i = 0; i &lt; ulen - 2; i += 2) {
@@ -53,7 +53,7 @@ char *OPENSSL_uni2asc(const unsigned char *uni, int unilen)
         asclen++;
     uni++;
     if ((asctmp = OPENSSL_malloc(asclen)) == NULL) {
-        PKCS12err(PKCS12_F_OPENSSL_UNI2ASC, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     for (i = 0; i &lt; unilen; i += 2)
@@ -115,7 +115,7 @@ unsigned char *OPENSSL_utf82uni(const char *asc, int asclen,
     ulen += 2;  /* for trailing UTF16 zero */
 
     if ((ret = OPENSSL_malloc(ulen)) == NULL) {
-        PKCS12err(PKCS12_F_OPENSSL_UTF82UNI, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     /* re-run the loop writing down UTF-16 characters in big-endian order */
@@ -200,7 +200,7 @@ char *OPENSSL_uni2utf8(const unsigned char *uni, int unilen)
         asclen++;
 
     if ((asctmp = OPENSSL_malloc(asclen)) == NULL) {
-        PKCS12err(PKCS12_F_OPENSSL_UNI2UTF8, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/pkcs7/pk7_attr.c b/crypto/pkcs7/pk7_attr.c
index 7df05c8084..e9904c5950 100644
--- a/crypto/pkcs7/pk7_attr.c
+++ b/crypto/pkcs7/pk7_attr.c
@@ -23,7 +23,7 @@ int PKCS7_add_attrib_smimecap(PKCS7_SIGNER_INFO *si,
     ASN1_STRING *seq;
 
     if ((seq = ASN1_STRING_new()) == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_ADD_ATTRIB_SMIMECAP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     seq-&gt;length = ASN1_item_i2d((ASN1_VALUE *)cap, &amp;seq-&gt;data,
@@ -53,7 +53,7 @@ int PKCS7_simple_smimecap(STACK_OF(X509_ALGOR) *sk, int nid, int arg)
     X509_ALGOR *alg;
 
     if ((alg = X509_ALGOR_new()) == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_SIMPLE_SMIMECAP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ASN1_OBJECT_free(alg-&gt;algorithm);
@@ -77,7 +77,7 @@ int PKCS7_simple_smimecap(STACK_OF(X509_ALGOR) *sk, int nid, int arg)
     }
     return 1;
 err:
-    PKCS7err(PKCS7_F_PKCS7_SIMPLE_SMIMECAP, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
     ASN1_INTEGER_free(nbit);
     X509_ALGOR_free(alg);
     return 0;
@@ -96,8 +96,7 @@ int PKCS7_add_attrib_content_type(PKCS7_SIGNER_INFO *si, ASN1_OBJECT *coid)
 int PKCS7_add0_attrib_signing_time(PKCS7_SIGNER_INFO *si, ASN1_TIME *t)
 {
     if (t == NULL &amp;&amp; (t = X509_gmtime_adj(NULL, 0)) == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_ADD0_ATTRIB_SIGNING_TIME,
-                 ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return PKCS7_add_signed_attribute(si, NID_pkcs9_signingTime,
diff --git a/crypto/pkcs7/pk7_doit.c b/crypto/pkcs7/pk7_doit.c
index 3598d5f121..111088703d 100644
--- a/crypto/pkcs7/pk7_doit.c
+++ b/crypto/pkcs7/pk7_doit.c
@@ -62,7 +62,7 @@ static int pkcs7_bio_add_digest(BIO **pbio, X509_ALGOR *alg,
     const EVP_MD *md;
 
     if ((btmp = BIO_new(BIO_f_md())) == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, ERR_R_BIO_LIB);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
         goto err;
     }
 
@@ -77,7 +77,7 @@ static int pkcs7_bio_add_digest(BIO **pbio, X509_ALGOR *alg,
 
     if (md == NULL) {
         (void)ERR_clear_last_mark();
-        PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, PKCS7_R_UNKNOWN_DIGEST_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNKNOWN_DIGEST_TYPE);
         goto err;
     }
     (void)ERR_pop_to_mark();
@@ -87,7 +87,7 @@ static int pkcs7_bio_add_digest(BIO **pbio, X509_ALGOR *alg,
     if (*pbio == NULL)
         *pbio = btmp;
     else if (!BIO_push(*pbio, btmp)) {
-        PKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, ERR_R_BIO_LIB);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
         goto err;
     }
     btmp = NULL;
@@ -122,7 +122,7 @@ static int pkcs7_encode_rinfo(PKCS7_RECIP_INFO *ri,
 
     if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_ENCRYPT,
                           EVP_PKEY_CTRL_PKCS7_ENCRYPT, 0, ri) &lt;= 0) {
-        PKCS7err(PKCS7_F_PKCS7_ENCODE_RINFO, PKCS7_R_CTRL_ERROR);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_CTRL_ERROR);
         goto err;
     }
 
@@ -132,7 +132,7 @@ static int pkcs7_encode_rinfo(PKCS7_RECIP_INFO *ri,
     ek = OPENSSL_malloc(eklen);
 
     if (ek == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_ENCODE_RINFO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -170,7 +170,7 @@ static int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,
 
     if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DECRYPT,
                           EVP_PKEY_CTRL_PKCS7_DECRYPT, 0, ri) &lt;= 0) {
-        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, PKCS7_R_CTRL_ERROR);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_CTRL_ERROR);
         goto err;
     }
 
@@ -181,7 +181,7 @@ static int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,
     ek = OPENSSL_malloc(eklen);
 
     if (ek == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -190,7 +190,7 @@ static int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,
             || eklen == 0
             || (fixlen != 0 &amp;&amp; eklen != fixlen)) {
         ret = 0;
-        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_EVP_LIB);
         goto err;
     }
 
@@ -224,7 +224,7 @@ BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)
     const PKCS7_CTX *p7_ctx;
 
     if (p7 == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_INVALID_NULL_POINTER);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_NULL_POINTER);
         return NULL;
     }
     p7_ctx = pkcs7_get0_ctx(p7);
@@ -240,7 +240,7 @@ BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)
      * calling this method, so a NULL p7-&gt;d is always an error.
      */
     if (p7-&gt;d.ptr == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_NO_CONTENT);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_CONTENT);
         return NULL;
     }
 
@@ -258,7 +258,7 @@ BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)
         xalg = p7-&gt;d.signed_and_enveloped-&gt;enc_data-&gt;algorithm;
         evp_cipher = p7-&gt;d.signed_and_enveloped-&gt;enc_data-&gt;cipher;
         if (evp_cipher == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_CIPHER_NOT_INITIALIZED);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_CIPHER_NOT_INITIALIZED);
             goto err;
         }
         break;
@@ -267,7 +267,7 @@ BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)
         xalg = p7-&gt;d.enveloped-&gt;enc_data-&gt;algorithm;
         evp_cipher = p7-&gt;d.enveloped-&gt;enc_data-&gt;cipher;
         if (evp_cipher == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_CIPHER_NOT_INITIALIZED);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_CIPHER_NOT_INITIALIZED);
             goto err;
         }
         break;
@@ -278,7 +278,7 @@ BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)
     case NID_pkcs7_data:
         break;
     default:
-        PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
         goto err;
     }
 
@@ -296,7 +296,7 @@ BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)
         EVP_CIPHER_CTX *ctx;
 
         if ((btmp = BIO_new(BIO_f_cipher())) == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_DATAINIT, ERR_R_BIO_LIB);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
             goto err;
         }
         BIO_get_cipher_ctx(btmp, &amp;ctx);
@@ -413,14 +413,14 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
     const PKCS7_CTX *p7_ctx;
 
     if (p7 == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_NULL_POINTER);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_NULL_POINTER);
         return NULL;
     }
 
     p7_ctx = pkcs7_get0_ctx(p7);
 
     if (p7-&gt;d.ptr == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_CONTENT);
         return NULL;
     }
 
@@ -437,8 +437,7 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
          */
         data_body = PKCS7_get_octet_string(p7-&gt;d.sign-&gt;contents);
         if (!PKCS7_is_detached(p7) &amp;&amp; data_body == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_DATADECODE,
-                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_SIGNED_DATA_TYPE);
             goto err;
         }
         md_sk = p7-&gt;d.sign-&gt;md_algs;
@@ -461,8 +460,7 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
 
         if (cipher == NULL) {
             (void)ERR_clear_last_mark();
-            PKCS7err(PKCS7_F_PKCS7_DATADECODE,
-                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
             goto err;
         }
         (void)ERR_pop_to_mark();
@@ -483,20 +481,19 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
 
         if (cipher == NULL) {
             (void)ERR_clear_last_mark();
-            PKCS7err(PKCS7_F_PKCS7_DATADECODE,
-                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CIPHER_TYPE);
             goto err;
         }
         (void)ERR_pop_to_mark();
         break;
     default:
-        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
         goto err;
     }
 
     /* Detached content must be supplied via in_bio instead. */
     if (data_body == NULL &amp;&amp; in_bio == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_CONTENT);
         goto err;
     }
 
@@ -505,7 +502,7 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
         for (i = 0; i &lt; sk_X509_ALGOR_num(md_sk); i++) {
             xa = sk_X509_ALGOR_value(md_sk, i);
             if ((btmp = BIO_new(BIO_f_md())) == NULL) {
-                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);
+                ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
                 goto err;
             }
 
@@ -520,8 +517,7 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
 
             if (md == NULL) {
                 (void)ERR_clear_last_mark();
-                PKCS7err(PKCS7_F_PKCS7_DATADECODE,
-                         PKCS7_R_UNKNOWN_DIGEST_TYPE);
+                ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNKNOWN_DIGEST_TYPE);
                 goto err;
             }
             (void)ERR_pop_to_mark();
@@ -538,7 +534,7 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
 
     if (cipher != NULL) {
         if ((etmp = BIO_new(BIO_f_cipher())) == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_BIO_LIB);
             goto err;
         }
 
@@ -560,8 +556,8 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
                 ri = NULL;
             }
             if (ri == NULL) {
-                PKCS7err(PKCS7_F_PKCS7_DATADECODE,
-                         PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);
+                ERR_raise(ERR_LIB_PKCS7,
+                          PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);
                 goto err;
             }
         }
@@ -675,13 +671,12 @@ static BIO *PKCS7_find_digest(EVP_MD_CTX **pmd, BIO *bio, int nid)
     for (;;) {
         bio = BIO_find_type(bio, BIO_TYPE_MD);
         if (bio == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,
-                     PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
             return NULL;
         }
         BIO_get_md_ctx(bio, pmd);
         if (*pmd == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_FIND_DIGEST, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_INTERNAL_ERROR);
             return NULL;
         }
         if (EVP_MD_CTX_type(*pmd) == nid)
@@ -699,18 +694,18 @@ static int do_pkcs7_signed_attrib(PKCS7_SIGNER_INFO *si, EVP_MD_CTX *mctx)
     /* Add signing time if not already present */
     if (!PKCS7_get_signed_attribute(si, NID_pkcs9_signingTime)) {
         if (!PKCS7_add0_attrib_signing_time(si, NULL)) {
-            PKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     }
 
     /* Add digest */
     if (!EVP_DigestFinal_ex(mctx, md_data, &amp;md_len)) {
-        PKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_EVP_LIB);
         return 0;
     }
     if (!PKCS7_add1_attrib_digest(si, md_data, md_len)) {
-        PKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -734,20 +729,20 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
     const PKCS7_CTX *p7_ctx;
 
     if (p7 == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_INVALID_NULL_POINTER);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_NULL_POINTER);
         return 0;
     }
 
     p7_ctx = pkcs7_get0_ctx(p7);
 
     if (p7-&gt;d.ptr == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_NO_CONTENT);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_CONTENT);
         return 0;
     }
 
     ctx_tmp = EVP_MD_CTX_new();
     if (ctx_tmp == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -765,7 +760,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
         if (os == NULL) {
             os = ASN1_OCTET_STRING_new();
             if (os == NULL) {
-                PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             p7-&gt;d.signed_and_enveloped-&gt;enc_data-&gt;enc_data = os;
@@ -777,7 +772,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
         if (os == NULL) {
             os = ASN1_OCTET_STRING_new();
             if (os == NULL) {
-                PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             p7-&gt;d.enveloped-&gt;enc_data-&gt;enc_data = os;
@@ -805,7 +800,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
         break;
 
     default:
-        PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
         goto err;
     }
 
@@ -850,7 +845,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
                 if (!EVP_SignFinal_ex(ctx_tmp, abuf, &amp;abuflen, si-&gt;pkey,
                                       p7_ctx-&gt;libctx, p7_ctx-&gt;propq)) {
                     OPENSSL_free(abuf);
-                    PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_EVP_LIB);
+                    ERR_raise(ERR_LIB_PKCS7, ERR_R_EVP_LIB);
                     goto err;
                 }
                 ASN1_STRING_set0(si-&gt;enc_digest, abuf, abuflen);
@@ -880,7 +875,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
             long contlen;
             btmp = BIO_find_type(bio, BIO_TYPE_MEM);
             if (btmp == NULL) {
-                PKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
+                ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNABLE_TO_FIND_MEM_BIO);
                 goto err;
             }
             contlen = BIO_get_mem_data(btmp, &amp;cont);
@@ -915,7 +910,7 @@ int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si)
 
     mctx = EVP_MD_CTX_new();
     if (mctx == NULL) {
-        PKCS7err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -942,7 +937,7 @@ int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si)
 #if 0
     if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
                           EVP_PKEY_CTRL_PKCS7_SIGN, 0, si) &lt;= 0) {
-        PKCS7err(0, PKCS7_R_CTRL_ERROR);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_CTRL_ERROR);
         goto err;
     }
 #endif
@@ -982,7 +977,7 @@ int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si)
 #if 0
     if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,
                           EVP_PKEY_CTRL_PKCS7_SIGN, 1, si) &lt;= 0) {
-        PKCS7err(0, PKCS7_R_CTRL_ERROR);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_CTRL_ERROR);
         goto err;
     }
 #endif
@@ -1008,12 +1003,12 @@ int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,
     X509 *x509;
 
     if (p7 == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_INVALID_NULL_POINTER);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_NULL_POINTER);
         return 0;
     }
 
     if (p7-&gt;d.ptr == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_NO_CONTENT);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_CONTENT);
         return 0;
     }
 
@@ -1022,7 +1017,7 @@ int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,
     } else if (PKCS7_type_is_signedAndEnveloped(p7)) {
         cert = p7-&gt;d.signed_and_enveloped-&gt;cert;
     } else {
-        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_WRONG_PKCS7_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_PKCS7_TYPE);
         goto err;
     }
     /* XXXXXXXXXXXXXXXXXXXXXXX */
@@ -1032,20 +1027,19 @@ int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,
 
     /* were we able to find the cert in passed to us */
     if (x509 == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,
-                 PKCS7_R_UNABLE_TO_FIND_CERTIFICATE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNABLE_TO_FIND_CERTIFICATE);
         goto err;
     }
 
     /* Lets verify */
     if (!X509_STORE_CTX_init(ctx, cert_store, x509, cert)) {
-        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, ERR_R_X509_LIB);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_X509_LIB);
         goto err;
     }
     X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_SMIME_SIGN);
     i = X509_verify_cert(ctx);
     if (i &lt;= 0) {
-        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, ERR_R_X509_LIB);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_X509_LIB);
         X509_STORE_CTX_cleanup(ctx);
         goto err;
     }
@@ -1072,12 +1066,12 @@ int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
 
     mdc_tmp = EVP_MD_CTX_new();
     if (mdc_tmp == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (!PKCS7_type_is_signed(p7) &amp;&amp; !PKCS7_type_is_signedAndEnveloped(p7)) {
-        PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, PKCS7_R_WRONG_PKCS7_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_PKCS7_TYPE);
         goto err;
     }
 
@@ -1087,13 +1081,12 @@ int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
     for (;;) {
         if ((btmp == NULL) ||
             ((btmp = BIO_find_type(btmp, BIO_TYPE_MD)) == NULL)) {
-            PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
-                     PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
             goto err;
         }
         BIO_get_md_ctx(btmp, &amp;mdc);
         if (mdc == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_INTERNAL_ERROR);
             goto err;
         }
         if (EVP_MD_CTX_type(mdc) == md_type)
@@ -1125,13 +1118,12 @@ int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
             goto err;
         message_digest = PKCS7_digest_from_attributes(sk);
         if (!message_digest) {
-            PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,
-                     PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);
             goto err;
         }
         if ((message_digest-&gt;length != (int)md_len) ||
             (memcmp(message_digest-&gt;data, md_dat, md_len))) {
-            PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, PKCS7_R_DIGEST_FAILURE);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_DIGEST_FAILURE);
             ret = -1;
             goto err;
         }
@@ -1153,7 +1145,7 @@ int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
         alen = ASN1_item_i2d((ASN1_VALUE *)sk, &amp;abuf,
                              ASN1_ITEM_rptr(PKCS7_ATTR_VERIFY));
         if (alen &lt;= 0) {
-            PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_ASN1_LIB);
             ret = -1;
             goto err;
         }
@@ -1173,7 +1165,7 @@ int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
     i = EVP_VerifyFinal_ex(mdc_tmp, os-&gt;data, os-&gt;length, pkey, ctx-&gt;libctx,
                            ctx-&gt;propq);
     if (i &lt;= 0) {
-        PKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, PKCS7_R_SIGNATURE_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_SIGNATURE_FAILURE);
         ret = -1;
         goto err;
     }
diff --git a/crypto/pkcs7/pk7_lib.c b/crypto/pkcs7/pk7_lib.c
index da3336982e..1cc233e89d 100644
--- a/crypto/pkcs7/pk7_lib.c
+++ b/crypto/pkcs7/pk7_lib.c
@@ -35,8 +35,8 @@ long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg)
                 p7-&gt;d.sign-&gt;contents-&gt;d.data = NULL;
             }
         } else {
-            PKCS7err(PKCS7_F_PKCS7_CTRL,
-                     PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);
+            ERR_raise(ERR_LIB_PKCS7,
+                      PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);
             ret = 0;
         }
         break;
@@ -49,14 +49,14 @@ long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg)
 
             p7-&gt;detached = ret;
         } else {
-            PKCS7err(PKCS7_F_PKCS7_CTRL,
-                     PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);
+            ERR_raise(ERR_LIB_PKCS7,
+                      PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);
             ret = 0;
         }
 
         break;
     default:
-        PKCS7err(PKCS7_F_PKCS7_CTRL, PKCS7_R_UNKNOWN_OPERATION);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNKNOWN_OPERATION);
         ret = 0;
     }
     return ret;
@@ -98,7 +98,7 @@ int PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data)
     case NID_pkcs7_signedAndEnveloped:
     case NID_pkcs7_encrypted:
     default:
-        PKCS7err(PKCS7_F_PKCS7_SET_CONTENT, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
         goto err;
     }
     return 1;
@@ -169,7 +169,7 @@ int PKCS7_set_type(PKCS7 *p7, int type)
             goto err;
         break;
     default:
-        PKCS7err(PKCS7_F_PKCS7_SET_TYPE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);
         goto err;
     }
     return 1;
@@ -202,7 +202,7 @@ int PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *psi)
         md_sk = p7-&gt;d.signed_and_enveloped-&gt;md_algs;
         break;
     default:
-        PKCS7err(PKCS7_F_PKCS7_ADD_SIGNER, PKCS7_R_WRONG_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_CONTENT_TYPE);
         return 0;
     }
 
@@ -221,7 +221,7 @@ int PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *psi)
         if ((alg = X509_ALGOR_new()) == NULL
             || (alg-&gt;parameter = ASN1_TYPE_new()) == NULL) {
             X509_ALGOR_free(alg);
-            PKCS7err(PKCS7_F_PKCS7_ADD_SIGNER, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         alg-&gt;algorithm = OBJ_nid2obj(nid);
@@ -252,7 +252,7 @@ int PKCS7_add_certificate(PKCS7 *p7, X509 *x509)
         sk = &amp;(p7-&gt;d.signed_and_enveloped-&gt;cert);
         break;
     default:
-        PKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE, PKCS7_R_WRONG_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_CONTENT_TYPE);
         return 0;
     }
 
@@ -273,14 +273,14 @@ int PKCS7_add_crl(PKCS7 *p7, X509_CRL *crl)
         sk = &amp;(p7-&gt;d.signed_and_enveloped-&gt;crl);
         break;
     default:
-        PKCS7err(PKCS7_F_PKCS7_ADD_CRL, PKCS7_R_WRONG_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_CONTENT_TYPE);
         return 0;
     }
 
     if (*sk == NULL)
         *sk = sk_X509_CRL_new_null();
     if (*sk == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_ADD_CRL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -319,8 +319,8 @@ int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,
      * #legacy
      */
     if (!evp_pkey_downgrade(pkey)) {
-        PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SET,
-                 PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+        ERR_raise(ERR_LIB_PKCS7,
+                  PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
         goto err;
     }
 
@@ -338,13 +338,11 @@ int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,
         if (ret &gt; 0)
             return 1;
         if (ret != -2) {
-            PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SET,
-                     PKCS7_R_SIGNING_CTRL_FAILURE);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_SIGNING_CTRL_FAILURE);
             return 0;
         }
     }
-    PKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SET,
-             PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+    ERR_raise(ERR_LIB_PKCS7, PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
  err:
     return 0;
 }
@@ -360,7 +358,7 @@ PKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey,
             goto err;
         dgst = EVP_get_digestbynid(def_nid);
         if (dgst == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_ADD_SIGNATURE, PKCS7_R_NO_DEFAULT_DIGEST);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_DEFAULT_DIGEST);
             goto err;
         }
     }
@@ -445,7 +443,7 @@ int PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md)
 {
     if (PKCS7_type_is_digest(p7)) {
         if ((p7-&gt;d.digest-&gt;md-&gt;parameter = ASN1_TYPE_new()) == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_SET_DIGEST, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         p7-&gt;d.digest-&gt;md-&gt;parameter-&gt;type = V_ASN1_NULL;
@@ -453,7 +451,7 @@ int PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md)
         return 1;
     }
 
-    PKCS7err(PKCS7_F_PKCS7_SET_DIGEST, PKCS7_R_WRONG_CONTENT_TYPE);
+    ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_CONTENT_TYPE);
     return 1;
 }
 
@@ -517,8 +515,7 @@ int PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri)
         sk = p7-&gt;d.enveloped-&gt;recipientinfo;
         break;
     default:
-        PKCS7err(PKCS7_F_PKCS7_ADD_RECIPIENT_INFO,
-                 PKCS7_R_WRONG_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_CONTENT_TYPE);
         return 0;
     }
 
@@ -545,20 +542,19 @@ int PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509)
     pkey = X509_get0_pubkey(x509);
 
     if (!pkey || !pkey-&gt;ameth || !pkey-&gt;ameth-&gt;pkey_ctrl) {
-        PKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,
-                 PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+        ERR_raise(ERR_LIB_PKCS7,
+                  PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
         goto err;
     }
 
     ret = pkey-&gt;ameth-&gt;pkey_ctrl(pkey, ASN1_PKEY_CTRL_PKCS7_ENCRYPT, 0, p7i);
     if (ret == -2) {
-        PKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,
-                 PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
+        ERR_raise(ERR_LIB_PKCS7,
+                  PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);
         goto err;
     }
     if (ret &lt;= 0) {
-        PKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,
-                 PKCS7_R_ENCRYPTION_CTRL_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_ENCRYPTION_CTRL_FAILURE);
         goto err;
     }
 
@@ -596,15 +592,14 @@ int PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher)
         ec = p7-&gt;d.enveloped-&gt;enc_data;
         break;
     default:
-        PKCS7err(PKCS7_F_PKCS7_SET_CIPHER, PKCS7_R_WRONG_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_CONTENT_TYPE);
         return 0;
     }
 
     /* Check cipher OID exists and has data in it */
     i = EVP_CIPHER_type(cipher);
     if (i == NID_undef) {
-        PKCS7err(PKCS7_F_PKCS7_SET_CIPHER,
-                 PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
         return 0;
     }
 
diff --git a/crypto/pkcs7/pk7_smime.c b/crypto/pkcs7/pk7_smime.c
index 8e16e63971..770534d9f6 100644
--- a/crypto/pkcs7/pk7_smime.c
+++ b/crypto/pkcs7/pk7_smime.c
@@ -28,7 +28,7 @@ PKCS7 *PKCS7_sign_ex(X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs,
     int i;
 
     if ((p7 = PKCS7_new_ex(libctx, propq)) == NULL) {
-        PKCS7err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -39,7 +39,7 @@ PKCS7 *PKCS7_sign_ex(X509 *signcert, EVP_PKEY *pkey, STACK_OF(X509) *certs,
         goto err;
 
     if (pkey &amp;&amp; !PKCS7_sign_add_signer(p7, signcert, pkey, NULL, flags)) {
-        PKCS7err(0, PKCS7_R_PKCS7_ADD_SIGNER_ERROR);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_PKCS7_ADD_SIGNER_ERROR);
         goto err;
     }
 
@@ -77,7 +77,7 @@ int PKCS7_final(PKCS7 *p7, BIO *data, int flags)
     int ret = 0;
 
     if ((p7bio = PKCS7_dataInit(p7, NULL)) == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_FINAL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -86,7 +86,7 @@ int PKCS7_final(PKCS7 *p7, BIO *data, int flags)
     (void)BIO_flush(p7bio);
 
     if (!PKCS7_dataFinal(p7, p7bio)) {
-        PKCS7err(PKCS7_F_PKCS7_FINAL, PKCS7_R_PKCS7_DATASIGN);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_PKCS7_DATASIGN);
         goto err;
     }
     ret = 1;
@@ -121,14 +121,13 @@ PKCS7_SIGNER_INFO *PKCS7_sign_add_signer(PKCS7 *p7, X509 *signcert,
     STACK_OF(X509_ALGOR) *smcap = NULL;
 
     if (!X509_check_private_key(signcert, pkey)) {
-        PKCS7err(PKCS7_F_PKCS7_SIGN_ADD_SIGNER,
-                 PKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
+        ERR_raise(ERR_LIB_PKCS7,
+                  PKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
         return NULL;
     }
 
     if ((si = PKCS7_add_signature(p7, signcert, pkey, md)) == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_SIGN_ADD_SIGNER,
-                 PKCS7_R_PKCS7_ADD_SIGNATURE_ERROR);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_PKCS7_ADD_SIGNATURE_ERROR);
         return NULL;
     }
 
@@ -144,7 +143,7 @@ PKCS7_SIGNER_INFO *PKCS7_sign_add_signer(PKCS7 *p7, X509 *signcert,
         /* Add SMIMECapabilities */
         if (!(flags &amp; PKCS7_NOSMIMECAP)) {
             if ((smcap = sk_X509_ALGOR_new_null()) == NULL) {
-                PKCS7err(PKCS7_F_PKCS7_SIGN_ADD_SIGNER, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             if (!add_cipher_smcap(smcap, NID_aes_256_cbc, -1)
@@ -206,8 +205,7 @@ static int pkcs7_copy_existing_digest(PKCS7 *p7, PKCS7_SIGNER_INFO *si)
     if (osdig != NULL)
         return PKCS7_add1_attrib_digest(si, osdig-&gt;data, osdig-&gt;length);
 
-    PKCS7err(PKCS7_F_PKCS7_COPY_EXISTING_DIGEST,
-             PKCS7_R_NO_MATCHING_DIGEST_TYPE_FOUND);
+    ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_MATCHING_DIGEST_TYPE_FOUND);
     return 0;
 }
 
@@ -226,18 +224,18 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
     const PKCS7_CTX *p7_ctx;
 
     if (p7 == NULL) {
-        PKCS7err(0, PKCS7_R_INVALID_NULL_POINTER);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_NULL_POINTER);
         return 0;
     }
 
     if (!PKCS7_type_is_signed(p7)) {
-        PKCS7err(0, PKCS7_R_WRONG_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_CONTENT_TYPE);
         return 0;
     }
 
     /* Check for no data and no content: no data to verify signature */
     if (PKCS7_get_detached(p7) &amp;&amp; !indata) {
-        PKCS7err(0, PKCS7_R_NO_CONTENT);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_CONTENT);
         return 0;
     }
 
@@ -250,7 +248,7 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
          * process is different, but the existing PKCs7 verification works.
          */
         if (!PKCS7_get_detached(p7) &amp;&amp; indata) {
-            PKCS7err(0, PKCS7_R_CONTENT_AND_DATA_PRESENT);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_CONTENT_AND_DATA_PRESENT);
             return 0;
         }
     }
@@ -258,7 +256,7 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
     sinfos = PKCS7_get_signer_info(p7);
 
     if (!sinfos || !sk_PKCS7_SIGNER_INFO_num(sinfos)) {
-        PKCS7err(0, PKCS7_R_NO_SIGNATURES_ON_DATA);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_SIGNATURES_ON_DATA);
         return 0;
     }
 
@@ -277,12 +275,12 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
             if (!(flags &amp; PKCS7_NOCHAIN)) {
                 if (!X509_STORE_CTX_init(cert_ctx, store, signer,
                                          p7-&gt;d.sign-&gt;cert)) {
-                    PKCS7err(0, ERR_R_X509_LIB);
+                    ERR_raise(ERR_LIB_PKCS7, ERR_R_X509_LIB);
                     goto err;
                 }
                 X509_STORE_CTX_set_default(cert_ctx, &quot;smime_sign&quot;);
             } else if (!X509_STORE_CTX_init(cert_ctx, store, signer, NULL)) {
-                PKCS7err(0, ERR_R_X509_LIB);
+                ERR_raise(ERR_LIB_PKCS7, ERR_R_X509_LIB);
                 goto err;
             }
             if (!(flags &amp; PKCS7_NOCRL))
@@ -292,9 +290,9 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
                 j = X509_STORE_CTX_get_error(cert_ctx);
             X509_STORE_CTX_cleanup(cert_ctx);
             if (i &lt;= 0) {
-                PKCS7err(0, PKCS7_R_CERTIFICATE_VERIFY_ERROR);
-                ERR_add_error_data(2, &quot;Verify error:&quot;,
-                                   X509_verify_cert_error_string(j));
+                ERR_raise_data(ERR_LIB_PKCS7, PKCS7_R_CERTIFICATE_VERIFY_ERROR,
+                               &quot;Verify error: %s&quot;,
+                               X509_verify_cert_error_string(j));
                 goto err;
             }
             /* Check for revocation status here */
@@ -313,7 +311,7 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
         len = BIO_get_mem_data(indata, &amp;ptr);
         tmpin = (len == 0) ? indata : BIO_new_mem_buf(ptr, len);
         if (tmpin == NULL) {
-            PKCS7err(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     } else
@@ -324,7 +322,7 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
 
     if (flags &amp; PKCS7_TEXT) {
         if ((tmpout = BIO_new(BIO_s_mem())) == NULL) {
-            PKCS7err(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         BIO_set_mem_eof_return(tmpout, 0);
@@ -333,7 +331,7 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
 
     /* We now have to 'read' from p7bio to calculate digests etc. */
     if ((buf = OPENSSL_malloc(BUFFERSIZE)) == NULL) {
-        PKCS7err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     for (;;) {
@@ -346,7 +344,7 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
 
     if (flags &amp; PKCS7_TEXT) {
         if (!SMIME_text(tmpout, out)) {
-            PKCS7err(0, PKCS7_R_SMIME_TEXT_ERROR);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_SMIME_TEXT_ERROR);
             BIO_free(tmpout);
             goto err;
         }
@@ -360,7 +358,7 @@ int PKCS7_verify(PKCS7 *p7, STACK_OF(X509) *certs, X509_STORE *store,
             signer = sk_X509_value(signers, i);
             j = PKCS7_signatureVerify(p7bio, p7, si, signer);
             if (j &lt;= 0) {
-                PKCS7err(0, PKCS7_R_SIGNATURE_FAILURE);
+                ERR_raise(ERR_LIB_PKCS7, PKCS7_R_SIGNATURE_FAILURE);
                 goto err;
             }
         }
@@ -390,12 +388,12 @@ STACK_OF(X509) *PKCS7_get0_signers(PKCS7 *p7, STACK_OF(X509) *certs,
     int i;
 
     if (p7 == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_GET0_SIGNERS, PKCS7_R_INVALID_NULL_POINTER);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_NULL_POINTER);
         return NULL;
     }
 
     if (!PKCS7_type_is_signed(p7)) {
-        PKCS7err(PKCS7_F_PKCS7_GET0_SIGNERS, PKCS7_R_WRONG_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_CONTENT_TYPE);
         return NULL;
     }
 
@@ -404,12 +402,12 @@ STACK_OF(X509) *PKCS7_get0_signers(PKCS7 *p7, STACK_OF(X509) *certs,
     sinfos = PKCS7_get_signer_info(p7);
 
     if (sk_PKCS7_SIGNER_INFO_num(sinfos) &lt;= 0) {
-        PKCS7err(PKCS7_F_PKCS7_GET0_SIGNERS, PKCS7_R_NO_SIGNERS);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_NO_SIGNERS);
         return 0;
     }
 
     if ((signers = sk_X509_new_null()) == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_GET0_SIGNERS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -427,8 +425,7 @@ STACK_OF(X509) *PKCS7_get0_signers(PKCS7 *p7, STACK_OF(X509) *certs,
                 X509_find_by_issuer_and_serial(p7-&gt;d.sign-&gt;cert,
                                                ias-&gt;issuer, ias-&gt;serial);
         if (!signer) {
-            PKCS7err(PKCS7_F_PKCS7_GET0_SIGNERS,
-                     PKCS7_R_SIGNER_CERTIFICATE_NOT_FOUND);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_SIGNER_CERTIFICATE_NOT_FOUND);
             sk_X509_free(signers);
             return 0;
         }
@@ -453,21 +450,21 @@ PKCS7 *PKCS7_encrypt_ex(STACK_OF(X509) *certs, BIO *in,
     X509 *x509;
 
     if ((p7 = PKCS7_new_ex(libctx, propq)) == NULL) {
-        PKCS7err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     if (!PKCS7_set_type(p7, NID_pkcs7_enveloped))
         goto err;
     if (!PKCS7_set_cipher(p7, cipher)) {
-        PKCS7err(0, PKCS7_R_ERROR_SETTING_CIPHER);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_ERROR_SETTING_CIPHER);
         goto err;
     }
 
     for (i = 0; i &lt; sk_X509_num(certs); i++) {
         x509 = sk_X509_value(certs, i);
         if (!PKCS7_add_recipient(p7, x509)) {
-            PKCS7err(0, PKCS7_R_ERROR_ADDING_RECIPIENT);
+            ERR_raise(ERR_LIB_PKCS7, PKCS7_R_ERROR_ADDING_RECIPIENT);
             goto err;
         }
     }
@@ -500,23 +497,23 @@ int PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data, int flags)
     char *buf = NULL;
 
     if (p7 == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DECRYPT, PKCS7_R_INVALID_NULL_POINTER);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_INVALID_NULL_POINTER);
         return 0;
     }
 
     if (!PKCS7_type_is_enveloped(p7)) {
-        PKCS7err(PKCS7_F_PKCS7_DECRYPT, PKCS7_R_WRONG_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_WRONG_CONTENT_TYPE);
         return 0;
     }
 
     if (cert &amp;&amp; !X509_check_private_key(cert, pkey)) {
-        PKCS7err(PKCS7_F_PKCS7_DECRYPT,
-                 PKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
+        ERR_raise(ERR_LIB_PKCS7,
+                  PKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
         return 0;
     }
 
     if ((tmpmem = PKCS7_dataDecode(p7, pkey, NULL, cert)) == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DECRYPT, PKCS7_R_DECRYPT_ERROR);
+        ERR_raise(ERR_LIB_PKCS7, PKCS7_R_DECRYPT_ERROR);
         return 0;
     }
 
@@ -524,12 +521,12 @@ int PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data, int flags)
         BIO *tmpbuf, *bread;
         /* Encrypt BIOs can't do BIO_gets() so add a buffer BIO */
         if ((tmpbuf = BIO_new(BIO_f_buffer())) == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_DECRYPT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
             BIO_free_all(tmpmem);
             return 0;
         }
         if ((bread = BIO_push(tmpbuf, tmpmem)) == NULL) {
-            PKCS7err(PKCS7_F_PKCS7_DECRYPT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
             BIO_free_all(tmpbuf);
             BIO_free_all(tmpmem);
             return 0;
@@ -543,7 +540,7 @@ int PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data, int flags)
         return ret;
     }
     if ((buf = OPENSSL_malloc(BUFFERSIZE)) == NULL) {
-        PKCS7err(PKCS7_F_PKCS7_DECRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_PKCS7, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     for (;;) {
diff --git a/crypto/provider.c b/crypto/provider.c
index 53db7a6229..0441fb2f2a 100644
--- a/crypto/provider.c
+++ b/crypto/provider.c
@@ -97,8 +97,7 @@ int OSSL_PROVIDER_add_builtin(OSSL_LIB_CTX *libctx, const char *name,
     OSSL_PROVIDER *prov = NULL;
 
     if (name == NULL || init_fn == NULL) {
-        CRYPTOerr(CRYPTO_F_OSSL_PROVIDER_ADD_BUILTIN,
-                  ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
diff --git a/crypto/provider_conf.c b/crypto/provider_conf.c
index f4f88e7100..709e7a1c51 100644
--- a/crypto/provider_conf.c
+++ b/crypto/provider_conf.c
@@ -87,8 +87,8 @@ static int provider_conf_load(OSSL_LIB_CTX *libctx, const char *name,
     ecmds = NCONF_get_section(cnf, value);
 
     if (!ecmds) {
-        CRYPTOerr(CRYPTO_F_PROVIDER_CONF_LOAD, CRYPTO_R_PROVIDER_SECTION_ERROR);
-        ERR_add_error_data(3, &quot;section=&quot;, value, &quot; not found&quot;);
+        ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_SECTION_ERROR,
+                       &quot;section=%s not found&quot;, value);
         return 0;
     }
 
@@ -159,8 +159,7 @@ static int provider_conf_init(CONF_IMODULE *md, const CONF *cnf)
     elist = NCONF_get_section(cnf, CONF_imodule_get_value(md));
 
     if (!elist) {
-        CRYPTOerr(CRYPTO_F_PROVIDER_CONF_INIT,
-                  CRYPTO_R_PROVIDER_SECTION_ERROR);
+        ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_SECTION_ERROR);
         return 0;
     }
 
diff --git a/crypto/provider_core.c b/crypto/provider_core.c
index 52e68641ae..d919a95b40 100644
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -164,7 +164,7 @@ static void *provider_store_new(OSSL_LIB_CTX *ctx)
             || sk_OSSL_PROVIDER_push(store-&gt;providers, prov) == 0) {
             ossl_provider_free(prov);
             provider_store_free(store);
-            CRYPTOerr(CRYPTO_F_PROVIDER_STORE_NEW, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_CRYPTO, ERR_R_INTERNAL_ERROR);
             return NULL;
         }
         prov-&gt;libctx = ctx;
@@ -191,7 +191,7 @@ static struct provider_store_st *get_provider_store(OSSL_LIB_CTX *libctx)
     store = ossl_lib_ctx_get_data(libctx, OSSL_LIB_CTX_PROVIDER_STORE_INDEX,
                                   &amp;provider_store_method);
     if (store == NULL)
-        CRYPTOerr(CRYPTO_F_GET_PROVIDER_STORE, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_INTERNAL_ERROR);
     return store;
 }
 
@@ -254,7 +254,7 @@ static OSSL_PROVIDER *provider_new(const char *name,
         || !ossl_provider_up_ref(prov) /* +1 One reference to be returned */
         || (prov-&gt;name = OPENSSL_strdup(name)) == NULL) {
         ossl_provider_free(prov);
-        CRYPTOerr(CRYPTO_F_PROVIDER_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -284,7 +284,7 @@ OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
     if ((prov = ossl_provider_find(libctx, name,
                                    noconfig)) != NULL) { /* refcount +1 */
         ossl_provider_free(prov); /* refcount -1 */
-        ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS, NULL,
+        ERR_raise_data(ERR_LIB_CRYPTO, CRYPTO_R_PROVIDER_ALREADY_EXISTS,
                        &quot;name=%s&quot;, name);
         return NULL;
     }
@@ -311,7 +311,7 @@ OSSL_PROVIDER *ossl_provider_new(OSSL_LIB_CTX *libctx, const char *name,
     CRYPTO_THREAD_unlock(store-&gt;lock);
 
     if (prov == NULL)
-        CRYPTOerr(CRYPTO_F_OSSL_PROVIDER_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
 
     /*
      * At this point, the provider is only partially &quot;loaded&quot;.  To be
@@ -390,7 +390,7 @@ int ossl_provider_set_module_path(OSSL_PROVIDER *prov, const char *module_path)
         return 1;
     if ((prov-&gt;path = OPENSSL_strdup(module_path)) != NULL)
         return 1;
-    CRYPTOerr(CRYPTO_F_OSSL_PROVIDER_SET_MODULE_PATH, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
@@ -412,7 +412,7 @@ int ossl_provider_add_parameter(OSSL_PROVIDER *prov,
         OPENSSL_free(pair-&gt;value);
         OPENSSL_free(pair);
     }
-    CRYPTOerr(CRYPTO_F_OSSL_PROVIDER_ADD_PARAMETER, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
@@ -439,7 +439,7 @@ int OSSL_PROVIDER_set_default_search_path(OSSL_LIB_CTX *libctx,
     if (path != NULL) {
         p = OPENSSL_strdup(path);
         if (p == NULL) {
-            CRYPTOerr(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     }
@@ -534,7 +534,7 @@ static int provider_activate(OSSL_PROVIDER *prov)
     if (prov-&gt;init_function == NULL
         || !prov-&gt;init_function((OSSL_CORE_HANDLE *)prov, core_dispatch,
                                 &amp;provider_dispatch, &amp;tmp_provctx)) {
-        ERR_raise_data(ERR_LIB_CRYPTO, ERR_R_INIT_FAIL, NULL,
+        ERR_raise_data(ERR_LIB_CRYPTO, ERR_R_INIT_FAIL,
                        &quot;name=%s&quot;, prov-&gt;name);
 #ifndef FIPS_MODULE
         DSO_free(prov-&gt;module);
diff --git a/crypto/rand/rand_lib.c b/crypto/rand/rand_lib.c
index d388d8908a..211f4f3f51 100644
--- a/crypto/rand/rand_lib.c
+++ b/crypto/rand/rand_lib.c
@@ -236,7 +236,7 @@ int RAND_pseudo_bytes(unsigned char *buf, int num)
 
     if (meth != NULL &amp;&amp; meth-&gt;pseudorand != NULL)
         return meth-&gt;pseudorand(buf, num);
-    RANDerr(RAND_F_RAND_PSEUDO_BYTES, RAND_R_FUNC_NOT_IMPLEMENTED);
+    ERR_raise(ERR_LIB_RAND, RAND_R_FUNC_NOT_IMPLEMENTED);
     return -1;
 }
 # endif
@@ -274,7 +274,7 @@ int RAND_priv_bytes_ex(OSSL_LIB_CTX *ctx, unsigned char *buf, int num)
     if (meth != NULL &amp;&amp; meth != RAND_OpenSSL()) {
         if (meth-&gt;bytes != NULL)
             return meth-&gt;bytes(buf, num);
-        RANDerr(RAND_F_RAND_PRIV_BYTES_EX, RAND_R_FUNC_NOT_IMPLEMENTED);
+        ERR_raise(ERR_LIB_RAND, RAND_R_FUNC_NOT_IMPLEMENTED);
         return -1;
     }
 
@@ -298,7 +298,7 @@ int RAND_bytes_ex(OSSL_LIB_CTX *ctx, unsigned char *buf, int num)
     if (meth != NULL &amp;&amp; meth != RAND_OpenSSL()) {
         if (meth-&gt;bytes != NULL)
             return meth-&gt;bytes(buf, num);
-        RANDerr(RAND_F_RAND_BYTES_EX, RAND_R_FUNC_NOT_IMPLEMENTED);
+        ERR_raise(ERR_LIB_RAND, RAND_R_FUNC_NOT_IMPLEMENTED);
         return -1;
     }
 
@@ -465,13 +465,13 @@ static EVP_RAND_CTX *rand_new_drbg(OSSL_LIB_CTX *libctx, EVP_RAND_CTX *parent,
     name = dgbl-&gt;rng_name != NULL ? dgbl-&gt;rng_name : &quot;CTR-DRBG&quot;;
     rand = EVP_RAND_fetch(libctx, name, dgbl-&gt;rng_propq);
     if (rand == NULL) {
-        RANDerr(0, RAND_R_UNABLE_TO_FETCH_DRBG);
+        ERR_raise(ERR_LIB_RAND, RAND_R_UNABLE_TO_FETCH_DRBG);
         return NULL;
     }
     ctx = EVP_RAND_CTX_new(rand, parent);
     EVP_RAND_free(rand);
     if (ctx == NULL) {
-        RANDerr(0, RAND_R_UNABLE_TO_CREATE_DRBG);
+        ERR_raise(ERR_LIB_RAND, RAND_R_UNABLE_TO_CREATE_DRBG);
         return NULL;
     }
 
@@ -495,12 +495,12 @@ static EVP_RAND_CTX *rand_new_drbg(OSSL_LIB_CTX *libctx, EVP_RAND_CTX *parent,
                                        &amp;reseed_time_interval);
     *p = OSSL_PARAM_construct_end();
     if (!EVP_RAND_set_ctx_params(ctx, params)) {
-        RANDerr(0, RAND_R_ERROR_INITIALISING_DRBG);
+        ERR_raise(ERR_LIB_RAND, RAND_R_ERROR_INITIALISING_DRBG);
         EVP_RAND_CTX_free(ctx);
         return NULL;
     }
     if (!EVP_RAND_instantiate(ctx, 0, 0, NULL, 0)) {
-        RANDerr(0, RAND_R_ERROR_INSTANTIATING_DRBG);
+        ERR_raise(ERR_LIB_RAND, RAND_R_ERROR_INSTANTIATING_DRBG);
         EVP_RAND_CTX_free(ctx);
         return NULL;
     }
@@ -602,7 +602,7 @@ static int random_set_string(char **p, const char *s)
     char *d = OPENSSL_strdup(s);
 
     if (d == NULL) {
-        CRYPTOerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     OPENSSL_free(*p);
@@ -626,7 +626,7 @@ static int random_conf_init(CONF_IMODULE *md, const CONF *cnf)
     /* Value is a section containing RANDOM configuration */
     elist = NCONF_get_section(cnf, CONF_imodule_get_value(md));
     if (elist == NULL) {
-        CRYPTOerr(0, CRYPTO_R_RANDOM_SECTION_ERROR);
+        ERR_raise(ERR_LIB_CRYPTO, CRYPTO_R_RANDOM_SECTION_ERROR);
         return 0;
     }
 
@@ -645,8 +645,9 @@ static int random_conf_init(CONF_IMODULE *md, const CONF *cnf)
             if (!random_set_string(&amp;dgbl-&gt;rng_propq, cval-&gt;value))
                 return 0;
         } else {
-            CRYPTOerr(0, CRYPTO_R_UNKNOWN_NAME_IN_RANDOM_SECTION);
-            ERR_add_error_data(4, &quot;name=&quot;, cval-&gt;name, &quot;, value=&quot;, cval-&gt;value);
+            ERR_raise_data(ERR_LIB_CRYPTO,
+                           CRYPTO_R_UNKNOWN_NAME_IN_RANDOM_SECTION,
+                           &quot;name=%s, value=%s&quot;, cval-&gt;name, cval-&gt;value);
             r = 0;
         }
     }
diff --git a/crypto/rand/randfile.c b/crypto/rand/randfile.c
index 2bdd76c078..655dc71b06 100644
--- a/crypto/rand/randfile.c
+++ b/crypto/rand/randfile.c
@@ -94,15 +94,15 @@ int RAND_load_file(const char *file, long bytes)
         return 0;
 
     if ((in = openssl_fopen(file, &quot;rb&quot;)) == NULL) {
-        RANDerr(RAND_F_RAND_LOAD_FILE, RAND_R_CANNOT_OPEN_FILE);
-        ERR_add_error_data(2, &quot;Filename=&quot;, file);
+        ERR_raise_data(ERR_LIB_RAND, RAND_R_CANNOT_OPEN_FILE,
+                       &quot;Filename=%s&quot;, file);
         return -1;
     }
 
 #ifndef OPENSSL_NO_POSIX_IO
     if (fstat(fileno(in), &amp;sb) &lt; 0) {
-        RANDerr(RAND_F_RAND_LOAD_FILE, RAND_R_INTERNAL_ERROR);
-        ERR_add_error_data(2, &quot;Filename=&quot;, file);
+        ERR_raise_data(ERR_LIB_RAND, RAND_R_INTERNAL_ERROR,
+                       &quot;Filename=%s&quot;, file);
         fclose(in);
         return -1;
     }
@@ -162,8 +162,7 @@ int RAND_load_file(const char *file, long bytes)
     OPENSSL_cleanse(buf, sizeof(buf));
     fclose(in);
     if (!RAND_status()) {
-        RANDerr(RAND_F_RAND_LOAD_FILE, RAND_R_RESEED_ERROR);
-        ERR_add_error_data(2, &quot;Filename=&quot;, file);
+        ERR_raise_data(ERR_LIB_RAND, RAND_R_RESEED_ERROR, &quot;Filename=%s&quot;, file);
         return -1;
     }
 
@@ -179,8 +178,8 @@ int RAND_write_file(const char *file)
     struct stat sb;
 
     if (stat(file, &amp;sb) &gt;= 0 &amp;&amp; !S_ISREG(sb.st_mode)) {
-        RANDerr(RAND_F_RAND_WRITE_FILE, RAND_R_NOT_A_REGULAR_FILE);
-        ERR_add_error_data(2, &quot;Filename=&quot;, file);
+        ERR_raise_data(ERR_LIB_RAND, RAND_R_NOT_A_REGULAR_FILE,
+                       &quot;Filename=%s&quot;, file);
         return -1;
     }
 #endif
@@ -229,8 +228,8 @@ int RAND_write_file(const char *file)
     if (out == NULL)
         out = openssl_fopen(file, &quot;wb&quot;);
     if (out == NULL) {
-        RANDerr(RAND_F_RAND_WRITE_FILE, RAND_R_CANNOT_OPEN_FILE);
-        ERR_add_error_data(2, &quot;Filename=&quot;, file);
+        ERR_raise_data(ERR_LIB_RAND, RAND_R_CANNOT_OPEN_FILE,
+                       &quot;Filename=%s&quot;, file);
         return -1;
     }
 
diff --git a/crypto/rsa/rsa_ameth.c b/crypto/rsa/rsa_ameth.c
index d767e4a9f0..3988024082 100644
--- a/crypto/rsa/rsa_ameth.c
+++ b/crypto/rsa/rsa_ameth.c
@@ -65,7 +65,7 @@ static int rsa_param_decode(RSA *rsa, const X509_ALGOR *alg)
     if (algptype == V_ASN1_UNDEF)
         return 1;
     if (algptype != V_ASN1_SEQUENCE) {
-        RSAerr(RSA_F_RSA_PARAM_DECODE, RSA_R_INVALID_PSS_PARAMETERS);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PSS_PARAMETERS);
         return 0;
     }
     rsa-&gt;pss = rsa_pss_decode(alg);
@@ -177,14 +177,14 @@ static int rsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
     rklen = i2d_RSAPrivateKey(pkey-&gt;pkey.rsa, &amp;rk);
 
     if (rklen &lt;= 0) {
-        RSAerr(RSA_F_RSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         ASN1_STRING_free(str);
         return 0;
     }
 
     if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(pkey-&gt;ameth-&gt;pkey_id), 0,
                          strtype, str, rk, rklen)) {
-        RSAerr(RSA_F_RSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         ASN1_STRING_free(str);
         return 0;
     }
@@ -203,7 +203,7 @@ static int rsa_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)
         return 0;
     rsa = d2i_RSAPrivateKey(NULL, &amp;p, pklen);
     if (rsa == NULL) {
-        RSAerr(RSA_F_RSA_PRIV_DECODE, ERR_R_RSA_LIB);
+        ERR_raise(ERR_LIB_RSA, ERR_R_RSA_LIB);
         return 0;
     }
     if (!rsa_param_decode(rsa, alg)) {
@@ -509,7 +509,7 @@ static int rsa_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
         if (pkey-&gt;pkey.rsa-&gt;pss != NULL) {
             if (!rsa_pss_get_param(pkey-&gt;pkey.rsa-&gt;pss, &amp;md, &amp;mgf1md,
                                    &amp;min_saltlen)) {
-                RSAerr(0, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);
                 return 0;
             }
             *(int *)arg2 = EVP_MD_type(md);
@@ -618,14 +618,14 @@ int ossl_rsa_pss_to_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pkctx,
 
     /* Sanity check: make sure it is PSS */
     if (OBJ_obj2nid(sigalg-&gt;algorithm) != EVP_PKEY_RSA_PSS) {
-        RSAerr(0, RSA_R_UNSUPPORTED_SIGNATURE_TYPE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_UNSUPPORTED_SIGNATURE_TYPE);
         return -1;
     }
     /* Decode PSS parameters */
     pss = rsa_pss_decode(sigalg);
 
     if (!rsa_pss_get_param(pss, &amp;md, &amp;mgf1md, &amp;saltlen)) {
-        RSAerr(0, RSA_R_INVALID_PSS_PARAMETERS);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PSS_PARAMETERS);
         goto err;
     }
 
@@ -638,7 +638,7 @@ int ossl_rsa_pss_to_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pkctx,
         if (EVP_PKEY_CTX_get_signature_md(pkctx, &amp;checkmd) &lt;= 0)
             goto err;
         if (EVP_MD_type(md) != EVP_MD_type(checkmd)) {
-            RSAerr(0, RSA_R_DIGEST_DOES_NOT_MATCH);
+            ERR_raise(ERR_LIB_RSA, RSA_R_DIGEST_DOES_NOT_MATCH);
             goto err;
         }
     }
@@ -770,7 +770,7 @@ static int rsa_item_verify(EVP_MD_CTX *ctx, const ASN1_ITEM *it,
 {
     /* Sanity check: make sure it is PSS */
     if (OBJ_obj2nid(sigalg-&gt;algorithm) != EVP_PKEY_RSA_PSS) {
-        RSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNSUPPORTED_SIGNATURE_TYPE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_UNSUPPORTED_SIGNATURE_TYPE);
         return -1;
     }
     if (ossl_rsa_pss_to_ctx(ctx, NULL, sigalg, pkey) &gt; 0) {
diff --git a/crypto/rsa/rsa_chk.c b/crypto/rsa/rsa_chk.c
index 5a0ef7679b..e61a5df089 100644
--- a/crypto/rsa/rsa_chk.c
+++ b/crypto/rsa/rsa_chk.c
@@ -28,7 +28,7 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
 
     if (key-&gt;p == NULL || key-&gt;q == NULL || key-&gt;n == NULL
             || key-&gt;e == NULL || key-&gt;d == NULL) {
-        RSAerr(0, RSA_R_VALUE_MISSING);
+        ERR_raise(ERR_LIB_RSA, RSA_R_VALUE_MISSING);
         return 0;
     }
 
@@ -37,7 +37,7 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
         ex_primes = sk_RSA_PRIME_INFO_num(key-&gt;prime_infos);
         if (ex_primes &lt;= 0
                 || (ex_primes + 2) &gt; rsa_multip_cap(BN_num_bits(key-&gt;n))) {
-            RSAerr(0, RSA_R_INVALID_MULTI_PRIME_KEY);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_MULTI_PRIME_KEY);
             return 0;
         }
     }
@@ -51,29 +51,29 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
     if (i == NULL || j == NULL || k == NULL || l == NULL
             || m == NULL || ctx == NULL) {
         ret = -1;
-        RSAerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (BN_is_one(key-&gt;e)) {
         ret = 0;
-        RSAerr(0, RSA_R_BAD_E_VALUE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_BAD_E_VALUE);
     }
     if (!BN_is_odd(key-&gt;e)) {
         ret = 0;
-        RSAerr(0, RSA_R_BAD_E_VALUE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_BAD_E_VALUE);
     }
 
     /* p prime? */
     if (BN_check_prime(key-&gt;p, NULL, cb) != 1) {
         ret = 0;
-        RSAerr(0, RSA_R_P_NOT_PRIME);
+        ERR_raise(ERR_LIB_RSA, RSA_R_P_NOT_PRIME);
     }
 
     /* q prime? */
     if (BN_check_prime(key-&gt;q, NULL, cb) != 1) {
         ret = 0;
-        RSAerr(0, RSA_R_Q_NOT_PRIME);
+        ERR_raise(ERR_LIB_RSA, RSA_R_Q_NOT_PRIME);
     }
 
     /* r_i prime? */
@@ -81,7 +81,7 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
         pinfo = sk_RSA_PRIME_INFO_value(key-&gt;prime_infos, idx);
         if (BN_check_prime(pinfo-&gt;r, NULL, cb) != 1) {
             ret = 0;
-            RSAerr(0, RSA_R_MP_R_NOT_PRIME);
+            ERR_raise(ERR_LIB_RSA, RSA_R_MP_R_NOT_PRIME);
         }
     }
 
@@ -100,9 +100,9 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
     if (BN_cmp(i, key-&gt;n) != 0) {
         ret = 0;
         if (ex_primes)
-            RSAerr(0, RSA_R_N_DOES_NOT_EQUAL_PRODUCT_OF_PRIMES);
+            ERR_raise(ERR_LIB_RSA, RSA_R_N_DOES_NOT_EQUAL_PRODUCT_OF_PRIMES);
         else
-            RSAerr(0, RSA_R_N_DOES_NOT_EQUAL_P_Q);
+            ERR_raise(ERR_LIB_RSA, RSA_R_N_DOES_NOT_EQUAL_P_Q);
     }
 
     /* d*e = 1  mod \lambda(n)? */
@@ -150,7 +150,7 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
 
     if (!BN_is_one(i)) {
         ret = 0;
-        RSAerr(0, RSA_R_D_E_NOT_CONGRUENT_TO_1);
+        ERR_raise(ERR_LIB_RSA, RSA_R_D_E_NOT_CONGRUENT_TO_1);
     }
 
     if (key-&gt;dmp1 != NULL &amp;&amp; key-&gt;dmq1 != NULL &amp;&amp; key-&gt;iqmp != NULL) {
@@ -165,7 +165,7 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
         }
         if (BN_cmp(j, key-&gt;dmp1) != 0) {
             ret = 0;
-            RSAerr(0, RSA_R_DMP1_NOT_CONGRUENT_TO_D);
+            ERR_raise(ERR_LIB_RSA, RSA_R_DMP1_NOT_CONGRUENT_TO_D);
         }
 
         /* dmq1 = d mod (q-1)? */
@@ -179,7 +179,7 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
         }
         if (BN_cmp(j, key-&gt;dmq1) != 0) {
             ret = 0;
-            RSAerr(0, RSA_R_DMQ1_NOT_CONGRUENT_TO_D);
+            ERR_raise(ERR_LIB_RSA, RSA_R_DMQ1_NOT_CONGRUENT_TO_D);
         }
 
         /* iqmp = q^-1 mod p? */
@@ -189,7 +189,7 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
         }
         if (BN_cmp(i, key-&gt;iqmp) != 0) {
             ret = 0;
-            RSAerr(0, RSA_R_IQMP_NOT_INVERSE_OF_Q);
+            ERR_raise(ERR_LIB_RSA, RSA_R_IQMP_NOT_INVERSE_OF_Q);
         }
     }
 
@@ -206,7 +206,7 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
         }
         if (BN_cmp(j, pinfo-&gt;d) != 0) {
             ret = 0;
-            RSAerr(0, RSA_R_MP_EXPONENT_NOT_CONGRUENT_TO_D);
+            ERR_raise(ERR_LIB_RSA, RSA_R_MP_EXPONENT_NOT_CONGRUENT_TO_D);
         }
         /* t_i = R_i ^ -1 mod r_i ? */
         if (!BN_mod_inverse(i, pinfo-&gt;pp, pinfo-&gt;r, ctx)) {
@@ -215,7 +215,7 @@ static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
         }
         if (BN_cmp(i, pinfo-&gt;t) != 0) {
             ret = 0;
-            RSAerr(0, RSA_R_MP_COEFFICIENT_NOT_INVERSE_OF_R);
+            ERR_raise(ERR_LIB_RSA, RSA_R_MP_COEFFICIENT_NOT_INVERSE_OF_R);
         }
     }
 
diff --git a/crypto/rsa/rsa_crpt.c b/crypto/rsa/rsa_crpt.c
index d6efa205d5..6bc6aafcc8 100644
--- a/crypto/rsa/rsa_crpt.c
+++ b/crypto/rsa/rsa_crpt.c
@@ -129,14 +129,14 @@ BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *in_ctx)
     BN_CTX_start(ctx);
     e = BN_CTX_get(ctx);
     if (e == NULL) {
-        RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (rsa-&gt;e == NULL) {
         e = rsa_get_public_exp(rsa-&gt;d, rsa-&gt;p, rsa-&gt;q, ctx);
         if (e == NULL) {
-            RSAerr(RSA_F_RSA_SETUP_BLINDING, RSA_R_NO_PUBLIC_EXPONENT);
+            ERR_raise(ERR_LIB_RSA, RSA_R_NO_PUBLIC_EXPONENT);
             goto err;
         }
     } else {
@@ -147,7 +147,7 @@ BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *in_ctx)
         BIGNUM *n = BN_new();
 
         if (n == NULL) {
-            RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         BN_with_flags(n, rsa-&gt;n, BN_FLG_CONSTTIME);
@@ -158,7 +158,7 @@ BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *in_ctx)
         BN_free(n);
     }
     if (ret == NULL) {
-        RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_RSA, ERR_R_BN_LIB);
         goto err;
     }
 
diff --git a/crypto/rsa/rsa_gen.c b/crypto/rsa/rsa_gen.c
index 9ee5998829..53545edb71 100644
--- a/crypto/rsa/rsa_gen.c
+++ b/crypto/rsa/rsa_gen.c
@@ -87,19 +87,19 @@ static int rsa_multiprime_keygen(RSA *rsa, int bits, int primes,
 
     if (bits &lt; RSA_MIN_MODULUS_BITS) {
         ok = 0;             /* we set our own err */
-        RSAerr(0, RSA_R_KEY_SIZE_TOO_SMALL);
+        ERR_raise(ERR_LIB_RSA, RSA_R_KEY_SIZE_TOO_SMALL);
         goto err;
     }
 
     /* A bad value for e can cause infinite loops */
     if (e_value != NULL &amp;&amp; !ossl_rsa_check_public_exponent(e_value)) {
-        RSAerr(0, RSA_R_PUB_EXPONENT_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_PUB_EXPONENT_OUT_OF_RANGE);
         return 0;
     }
 
     if (primes &lt; RSA_DEFAULT_PRIME_NUM || primes &gt; rsa_multip_cap(bits)) {
         ok = 0;             /* we set our own err */
-        RSAerr(0, RSA_R_KEY_PRIME_NUM_INVALID);
+        ERR_raise(ERR_LIB_RSA, RSA_R_KEY_PRIME_NUM_INVALID);
         goto err;
     }
 
@@ -410,7 +410,7 @@ static int rsa_multiprime_keygen(RSA *rsa, int bits, int primes,
     ok = 1;
  err:
     if (ok == -1) {
-        RSAerr(0, ERR_LIB_BN);
+        ERR_raise(ERR_LIB_RSA, ERR_LIB_BN);
         ok = 0;
     }
     BN_CTX_end(ctx);
diff --git a/crypto/rsa/rsa_lib.c b/crypto/rsa/rsa_lib.c
index e4315f06cd..8e7ad45608 100644
--- a/crypto/rsa/rsa_lib.c
+++ b/crypto/rsa/rsa_lib.c
@@ -76,14 +76,14 @@ static RSA *rsa_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
     RSA *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        RSAerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     ret-&gt;references = 1;
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        RSAerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -94,7 +94,7 @@ static RSA *rsa_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
     ret-&gt;flags = ret-&gt;meth-&gt;flags &amp; ~RSA_FLAG_NON_FIPS_ALLOW;
     if (engine) {
         if (!ENGINE_init(engine)) {
-            RSAerr(0, ERR_R_ENGINE_LIB);
+            ERR_raise(ERR_LIB_RSA, ERR_R_ENGINE_LIB);
             goto err;
         }
         ret-&gt;engine = engine;
@@ -104,7 +104,7 @@ static RSA *rsa_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
     if (ret-&gt;engine) {
         ret-&gt;meth = ENGINE_get_RSA(ret-&gt;engine);
         if (ret-&gt;meth == NULL) {
-            RSAerr(0, ERR_R_ENGINE_LIB);
+            ERR_raise(ERR_LIB_RSA, ERR_R_ENGINE_LIB);
             goto err;
         }
     }
@@ -118,7 +118,7 @@ static RSA *rsa_new_intern(ENGINE *engine, OSSL_LIB_CTX *libctx)
 #endif
 
     if ((ret-&gt;meth-&gt;init != NULL) &amp;&amp; !ret-&gt;meth-&gt;init(ret)) {
-        RSAerr(0, ERR_R_INIT_FAIL);
+        ERR_raise(ERR_LIB_RSA, ERR_R_INIT_FAIL);
         goto err;
     }
 
diff --git a/crypto/rsa/rsa_meth.c b/crypto/rsa/rsa_meth.c
index 34ccc1f18c..82f13bb359 100644
--- a/crypto/rsa/rsa_meth.c
+++ b/crypto/rsa/rsa_meth.c
@@ -31,7 +31,7 @@ RSA_METHOD *RSA_meth_new(const char *name, int flags)
         OPENSSL_free(meth);
     }
 
-    RSAerr(RSA_F_RSA_METH_NEW, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -57,7 +57,7 @@ RSA_METHOD *RSA_meth_dup(const RSA_METHOD *meth)
         OPENSSL_free(ret);
     }
 
-    RSAerr(RSA_F_RSA_METH_DUP, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
@@ -71,7 +71,7 @@ int RSA_meth_set1_name(RSA_METHOD *meth, const char *name)
     char *tmpname = OPENSSL_strdup(name);
 
     if (tmpname == NULL) {
-        RSAerr(RSA_F_RSA_METH_SET1_NAME, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
diff --git a/crypto/rsa/rsa_mp.c b/crypto/rsa/rsa_mp.c
index 6a16ffd58e..00bf2ce550 100644
--- a/crypto/rsa/rsa_mp.c
+++ b/crypto/rsa/rsa_mp.c
@@ -34,7 +34,7 @@ RSA_PRIME_INFO *rsa_multip_info_new(void)
 
     /* create a RSA_PRIME_INFO structure */
     if ((pinfo = OPENSSL_zalloc(sizeof(RSA_PRIME_INFO))) == NULL) {
-        RSAerr(RSA_F_RSA_MULTIP_INFO_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     if ((pinfo-&gt;r = BN_secure_new()) == NULL)
diff --git a/crypto/rsa/rsa_none.c b/crypto/rsa/rsa_none.c
index 077528b062..df93525fc5 100644
--- a/crypto/rsa/rsa_none.c
+++ b/crypto/rsa/rsa_none.c
@@ -21,12 +21,12 @@ int RSA_padding_add_none(unsigned char *to, int tlen,
                          const unsigned char *from, int flen)
 {
     if (flen &gt; tlen) {
-        RSAerr(RSA_F_RSA_PADDING_ADD_NONE, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
         return 0;
     }
 
     if (flen &lt; tlen) {
-        RSAerr(RSA_F_RSA_PADDING_ADD_NONE, RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE);
         return 0;
     }
 
@@ -39,7 +39,7 @@ int RSA_padding_check_none(unsigned char *to, int tlen,
 {
 
     if (flen &gt; tlen) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_NONE, RSA_R_DATA_TOO_LARGE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE);
         return -1;
     }
 
diff --git a/crypto/rsa/rsa_oaep.c b/crypto/rsa/rsa_oaep.c
index 809e752bee..f47369a1af 100644
--- a/crypto/rsa/rsa_oaep.c
+++ b/crypto/rsa/rsa_oaep.c
@@ -69,7 +69,7 @@ int ossl_rsa_padding_add_PKCS1_OAEP_mgf1_ex(OSSL_LIB_CTX *libctx,
 #ifndef FIPS_MODULE
         md = EVP_sha1();
 #else
-        RSAerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_RSA, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
 #endif
     }
@@ -80,12 +80,12 @@ int ossl_rsa_padding_add_PKCS1_OAEP_mgf1_ex(OSSL_LIB_CTX *libctx,
 
     /* step 2b: check KLen &gt; nLen - 2 HLen - 2 */
     if (flen &gt; emlen - 2 * mdlen - 1) {
-        RSAerr(0, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
         return 0;
     }
 
     if (emlen &lt; 2 * mdlen + 1) {
-        RSAerr(0, RSA_R_KEY_SIZE_TOO_SMALL);
+        ERR_raise(ERR_LIB_RSA, RSA_R_KEY_SIZE_TOO_SMALL);
         return 0;
     }
 
@@ -109,7 +109,7 @@ int ossl_rsa_padding_add_PKCS1_OAEP_mgf1_ex(OSSL_LIB_CTX *libctx,
     dbmask_len = emlen - mdlen;
     dbmask = OPENSSL_malloc(dbmask_len);
     if (dbmask == NULL) {
-        RSAerr(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -172,7 +172,7 @@ int RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,
 #ifndef FIPS_MODULE
         md = EVP_sha1();
 #else
-        RSAerr(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_RSA, ERR_R_PASSED_NULL_PARAMETER);
         return -1;
 #endif
     }
@@ -193,22 +193,20 @@ int RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,
      * This does not leak any side-channel information.
      */
     if (num &lt; flen || num &lt; 2 * mdlen + 2) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1,
-               RSA_R_OAEP_DECODING_ERROR);
+        ERR_raise(ERR_LIB_RSA, RSA_R_OAEP_DECODING_ERROR);
         return -1;
     }
 
     dblen = num - mdlen - 1;
     db = OPENSSL_malloc(dblen);
     if (db == NULL) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto cleanup;
     }
 
     em = OPENSSL_malloc(num);
     if (em == NULL) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1,
-               ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto cleanup;
     }
 
@@ -309,8 +307,7 @@ int RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,
      * the error stack. Instead we opt not to put an error on the stack at all
      * in case of padding failure in the FIPS provider.
      */
-    RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1,
-           RSA_R_OAEP_DECODING_ERROR);
+    ERR_raise(ERR_LIB_RSA, RSA_R_OAEP_DECODING_ERROR);
     err_clear_last_constant_time(1 &amp; good);
 #endif
  cleanup:
diff --git a/crypto/rsa/rsa_ossl.c b/crypto/rsa/rsa_ossl.c
index 139fb16268..7964244ab5 100644
--- a/crypto/rsa/rsa_ossl.c
+++ b/crypto/rsa/rsa_ossl.c
@@ -80,19 +80,19 @@ static int rsa_ossl_public_encrypt(int flen, const unsigned char *from,
     BN_CTX *ctx = NULL;
 
     if (BN_num_bits(rsa-&gt;n) &gt; OPENSSL_RSA_MAX_MODULUS_BITS) {
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_MODULUS_TOO_LARGE);
         return -1;
     }
 
     if (BN_ucmp(rsa-&gt;n, rsa-&gt;e) &lt;= 0) {
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_BAD_E_VALUE);
         return -1;
     }
 
     /* for large moduli, enforce exponent limit */
     if (BN_num_bits(rsa-&gt;n) &gt; OPENSSL_RSA_SMALL_MODULUS_BITS) {
         if (BN_num_bits(rsa-&gt;e) &gt; OPENSSL_RSA_MAX_PUBEXP_BITS) {
-            RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
+            ERR_raise(ERR_LIB_RSA, RSA_R_BAD_E_VALUE);
             return -1;
         }
     }
@@ -105,7 +105,7 @@ static int rsa_ossl_public_encrypt(int flen, const unsigned char *from,
     num = BN_num_bytes(rsa-&gt;n);
     buf = OPENSSL_malloc(num);
     if (ret == NULL || buf == NULL) {
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -128,7 +128,7 @@ static int rsa_ossl_public_encrypt(int flen, const unsigned char *from,
         i = RSA_padding_add_none(buf, num, from, flen);
         break;
     default:
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_UNKNOWN_PADDING_TYPE);
         goto err;
     }
     if (i &lt;= 0)
@@ -139,8 +139,7 @@ static int rsa_ossl_public_encrypt(int flen, const unsigned char *from,
 
     if (BN_ucmp(f, rsa-&gt;n) &gt;= 0) {
         /* usually the padding functions would catch this */
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_ENCRYPT,
-               RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
         goto err;
     }
 
@@ -265,7 +264,7 @@ static int rsa_ossl_private_encrypt(int flen, const unsigned char *from,
     num = BN_num_bytes(rsa-&gt;n);
     buf = OPENSSL_malloc(num);
     if (ret == NULL || buf == NULL) {
-        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -281,7 +280,7 @@ static int rsa_ossl_private_encrypt(int flen, const unsigned char *from,
         break;
     case RSA_SSLV23_PADDING:
     default:
-        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_UNKNOWN_PADDING_TYPE);
         goto err;
     }
     if (i &lt;= 0)
@@ -292,8 +291,7 @@ static int rsa_ossl_private_encrypt(int flen, const unsigned char *from,
 
     if (BN_ucmp(f, rsa-&gt;n) &gt;= 0) {
         /* usually the padding functions would catch this */
-        RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT,
-               RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
         goto err;
     }
 
@@ -305,14 +303,14 @@ static int rsa_ossl_private_encrypt(int flen, const unsigned char *from,
     if (!(rsa-&gt;flags &amp; RSA_FLAG_NO_BLINDING)) {
         blinding = rsa_get_blinding(rsa, &amp;local_blinding, ctx);
         if (blinding == NULL) {
-            RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);
             goto err;
         }
     }
 
     if (blinding != NULL) {
         if (!local_blinding &amp;&amp; ((unblind = BN_CTX_get(ctx)) == NULL)) {
-            RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (!rsa_blinding_convert(blinding, f, unblind, ctx))
@@ -329,11 +327,11 @@ static int rsa_ossl_private_encrypt(int flen, const unsigned char *from,
     } else {
         BIGNUM *d = BN_new();
         if (d == NULL) {
-            RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (rsa-&gt;d == NULL) {
-            RSAerr(RSA_F_RSA_OSSL_PRIVATE_ENCRYPT, RSA_R_MISSING_PRIVATE_KEY);
+            ERR_raise(ERR_LIB_RSA, RSA_R_MISSING_PRIVATE_KEY);
             BN_free(d);
             goto err;
         }
@@ -399,7 +397,7 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,
     num = BN_num_bytes(rsa-&gt;n);
     buf = OPENSSL_malloc(num);
     if (ret == NULL || buf == NULL) {
-        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -408,8 +406,7 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,
      * top '0' bytes
      */
     if (flen &gt; num) {
-        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT,
-               RSA_R_DATA_GREATER_THAN_MOD_LEN);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_GREATER_THAN_MOD_LEN);
         goto err;
     }
 
@@ -418,22 +415,21 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,
         goto err;
 
     if (BN_ucmp(f, rsa-&gt;n) &gt;= 0) {
-        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT,
-               RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
         goto err;
     }
 
     if (!(rsa-&gt;flags &amp; RSA_FLAG_NO_BLINDING)) {
         blinding = rsa_get_blinding(rsa, &amp;local_blinding, ctx);
         if (blinding == NULL) {
-            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);
             goto err;
         }
     }
 
     if (blinding != NULL) {
         if (!local_blinding &amp;&amp; ((unblind = BN_CTX_get(ctx)) == NULL)) {
-            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (!rsa_blinding_convert(blinding, f, unblind, ctx))
@@ -451,11 +447,11 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,
     } else {
         BIGNUM *d = BN_new();
         if (d == NULL) {
-            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (rsa-&gt;d == NULL) {
-            RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_MISSING_PRIVATE_KEY);
+            ERR_raise(ERR_LIB_RSA, RSA_R_MISSING_PRIVATE_KEY);
             BN_free(d);
             goto err;
         }
@@ -500,7 +496,7 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,
         memcpy(to, buf, (r = j));
         break;
     default:
-        RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_UNKNOWN_PADDING_TYPE);
         goto err;
     }
 #ifndef FIPS_MODULE
@@ -509,7 +505,7 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,
      * the error stack. Instead we opt not to put an error on the stack at all
      * in case of padding failure in the FIPS provider.
      */
-    RSAerr(RSA_F_RSA_OSSL_PRIVATE_DECRYPT, RSA_R_PADDING_CHECK_FAILED);
+    ERR_raise(ERR_LIB_RSA, RSA_R_PADDING_CHECK_FAILED);
     err_clear_last_constant_time(1 &amp; ~constant_time_msb(r));
 #endif
 
@@ -530,19 +526,19 @@ static int rsa_ossl_public_decrypt(int flen, const unsigned char *from,
     BN_CTX *ctx = NULL;
 
     if (BN_num_bits(rsa-&gt;n) &gt; OPENSSL_RSA_MAX_MODULUS_BITS) {
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_MODULUS_TOO_LARGE);
         return -1;
     }
 
     if (BN_ucmp(rsa-&gt;n, rsa-&gt;e) &lt;= 0) {
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_BAD_E_VALUE);
         return -1;
     }
 
     /* for large moduli, enforce exponent limit */
     if (BN_num_bits(rsa-&gt;n) &gt; OPENSSL_RSA_SMALL_MODULUS_BITS) {
         if (BN_num_bits(rsa-&gt;e) &gt; OPENSSL_RSA_MAX_PUBEXP_BITS) {
-            RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
+            ERR_raise(ERR_LIB_RSA, RSA_R_BAD_E_VALUE);
             return -1;
         }
     }
@@ -555,7 +551,7 @@ static int rsa_ossl_public_decrypt(int flen, const unsigned char *from,
     num = BN_num_bytes(rsa-&gt;n);
     buf = OPENSSL_malloc(num);
     if (ret == NULL || buf == NULL) {
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -564,7 +560,7 @@ static int rsa_ossl_public_decrypt(int flen, const unsigned char *from,
      * top '0' bytes
      */
     if (flen &gt; num) {
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_DATA_GREATER_THAN_MOD_LEN);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_GREATER_THAN_MOD_LEN);
         goto err;
     }
 
@@ -572,8 +568,7 @@ static int rsa_ossl_public_decrypt(int flen, const unsigned char *from,
         goto err;
 
     if (BN_ucmp(f, rsa-&gt;n) &gt;= 0) {
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT,
-               RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
         goto err;
     }
 
@@ -605,11 +600,11 @@ static int rsa_ossl_public_decrypt(int flen, const unsigned char *from,
         memcpy(to, buf, (r = i));
         break;
     default:
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_UNKNOWN_PADDING_TYPE);
         goto err;
     }
     if (r &lt; 0)
-        RSAerr(RSA_F_RSA_OSSL_PUBLIC_DECRYPT, RSA_R_PADDING_CHECK_FAILED);
+        ERR_raise(ERR_LIB_RSA, RSA_R_PADDING_CHECK_FAILED);
 
  err:
     BN_CTX_end(ctx);
diff --git a/crypto/rsa/rsa_pk1.c b/crypto/rsa/rsa_pk1.c
index daa8297300..01a84fba70 100644
--- a/crypto/rsa/rsa_pk1.c
+++ b/crypto/rsa/rsa_pk1.c
@@ -32,8 +32,7 @@ int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,
     unsigned char *p;
 
     if (flen &gt; (tlen - RSA_PKCS1_PADDING_SIZE)) {
-        RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1,
-               RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
         return 0;
     }
 
@@ -73,16 +72,14 @@ int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
     /* Accept inputs with and without the leading 0-byte. */
     if (num == flen) {
         if ((*p++) != 0x00) {
-            RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,
-                   RSA_R_INVALID_PADDING);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PADDING);
             return -1;
         }
         flen--;
     }
 
     if ((num != (flen + 1)) || (*(p++) != 0x01)) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,
-               RSA_R_BLOCK_TYPE_IS_NOT_01);
+        ERR_raise(ERR_LIB_RSA, RSA_R_BLOCK_TYPE_IS_NOT_01);
         return -1;
     }
 
@@ -94,8 +91,7 @@ int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
                 p++;
                 break;
             } else {
-                RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,
-                       RSA_R_BAD_FIXED_HEADER_DECRYPT);
+                ERR_raise(ERR_LIB_RSA, RSA_R_BAD_FIXED_HEADER_DECRYPT);
                 return -1;
             }
         }
@@ -103,20 +99,18 @@ int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
     }
 
     if (i == j) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,
-               RSA_R_NULL_BEFORE_BLOCK_MISSING);
+        ERR_raise(ERR_LIB_RSA, RSA_R_NULL_BEFORE_BLOCK_MISSING);
         return -1;
     }
 
     if (i &lt; 8) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,
-               RSA_R_BAD_PAD_BYTE_COUNT);
+        ERR_raise(ERR_LIB_RSA, RSA_R_BAD_PAD_BYTE_COUNT);
         return -1;
     }
     i++;                        /* Skip over the '\0' */
     j -= i;
     if (j &gt; tlen) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1, RSA_R_DATA_TOO_LARGE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE);
         return -1;
     }
     memcpy(to, p, (unsigned int)j);
@@ -132,7 +126,7 @@ int ossl_rsa_padding_add_PKCS1_type_2_ex(OSSL_LIB_CTX *libctx, unsigned char *to
     unsigned char *p;
 
     if (flen &gt; (tlen - RSA_PKCS1_PADDING_SIZE)) {
-        RSAerr(0, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
         return 0;
     }
 
@@ -186,14 +180,13 @@ int RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,
      */
 
     if (flen &gt; num || num &lt; RSA_PKCS1_PADDING_SIZE) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,
-               RSA_R_PKCS_DECODING_ERROR);
+        ERR_raise(ERR_LIB_RSA, RSA_R_PKCS_DECODING_ERROR);
         return -1;
     }
 
     em = OPENSSL_malloc(num);
     if (em == NULL) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         return -1;
     }
     /*
@@ -270,7 +263,7 @@ int RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,
      * the error stack. Instead we opt not to put an error on the stack at all
      * in case of padding failure in the FIPS provider.
      */
-    RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2, RSA_R_PKCS_DECODING_ERROR);
+    ERR_raise(ERR_LIB_RSA, RSA_R_PKCS_DECODING_ERROR);
     err_clear_last_constant_time(1 &amp; good);
 #endif
 
diff --git a/crypto/rsa/rsa_pmeth.c b/crypto/rsa/rsa_pmeth.c
index edaa769a6f..fc2799af7c 100644
--- a/crypto/rsa/rsa_pmeth.c
+++ b/crypto/rsa/rsa_pmeth.c
@@ -112,7 +112,7 @@ static int setup_tbuf(RSA_PKEY_CTX *ctx, EVP_PKEY_CTX *pk)
     if (ctx-&gt;tbuf != NULL)
         return 1;
     if ((ctx-&gt;tbuf = OPENSSL_malloc(RSA_size(pk-&gt;pkey-&gt;pkey.rsa))) == NULL) {
-        RSAerr(RSA_F_SETUP_TBUF, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return 1;
@@ -139,7 +139,7 @@ static int pkey_rsa_sign(EVP_PKEY_CTX *ctx, unsigned char *sig,
 
     if (rctx-&gt;md) {
         if (tbslen != (size_t)EVP_MD_size(rctx-&gt;md)) {
-            RSAerr(RSA_F_PKEY_RSA_SIGN, RSA_R_INVALID_DIGEST_LENGTH);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_DIGEST_LENGTH);
             return -1;
         }
 
@@ -155,11 +155,11 @@ static int pkey_rsa_sign(EVP_PKEY_CTX *ctx, unsigned char *sig,
             ret = sltmp;
         } else if (rctx-&gt;pad_mode == RSA_X931_PADDING) {
             if ((size_t)RSA_size(rsa) &lt; tbslen + 1) {
-                RSAerr(RSA_F_PKEY_RSA_SIGN, RSA_R_KEY_SIZE_TOO_SMALL);
+                ERR_raise(ERR_LIB_RSA, RSA_R_KEY_SIZE_TOO_SMALL);
                 return -1;
             }
             if (!setup_tbuf(rctx, ctx)) {
-                RSAerr(RSA_F_PKEY_RSA_SIGN, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
                 return -1;
             }
             memcpy(rctx-&gt;tbuf, tbs, tbslen);
@@ -214,13 +214,11 @@ static int pkey_rsa_verifyrecover(EVP_PKEY_CTX *ctx,
                 return 0;
             ret--;
             if (rctx-&gt;tbuf[ret] != RSA_X931_hash_id(EVP_MD_type(rctx-&gt;md))) {
-                RSAerr(RSA_F_PKEY_RSA_VERIFYRECOVER,
-                       RSA_R_ALGORITHM_MISMATCH);
+                ERR_raise(ERR_LIB_RSA, RSA_R_ALGORITHM_MISMATCH);
                 return 0;
             }
             if (ret != EVP_MD_size(rctx-&gt;md)) {
-                RSAerr(RSA_F_PKEY_RSA_VERIFYRECOVER,
-                       RSA_R_INVALID_DIGEST_LENGTH);
+                ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_DIGEST_LENGTH);
                 return 0;
             }
             if (rout)
@@ -259,7 +257,7 @@ static int pkey_rsa_verify(EVP_PKEY_CTX *ctx,
             return RSA_verify(EVP_MD_type(rctx-&gt;md), tbs, tbslen,
                               sig, siglen, rsa);
         if (tbslen != (size_t)EVP_MD_size(rctx-&gt;md)) {
-            RSAerr(RSA_F_PKEY_RSA_VERIFY, RSA_R_INVALID_DIGEST_LENGTH);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_DIGEST_LENGTH);
             return -1;
         }
         if (rctx-&gt;pad_mode == RSA_X931_PADDING) {
@@ -365,13 +363,13 @@ static int check_padding_md(const EVP_MD *md, int padding)
     mdnid = EVP_MD_type(md);
 
     if (padding == RSA_NO_PADDING) {
-        RSAerr(RSA_F_CHECK_PADDING_MD, RSA_R_INVALID_PADDING_MODE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PADDING_MODE);
         return 0;
     }
 
     if (padding == RSA_X931_PADDING) {
         if (RSA_X931_hash_id(mdnid) == -1) {
-            RSAerr(RSA_F_CHECK_PADDING_MD, RSA_R_INVALID_X931_DIGEST);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_X931_DIGEST);
             return 0;
         }
     } else {
@@ -397,7 +395,7 @@ static int check_padding_md(const EVP_MD *md, int padding)
             return 1;
 
         default:
-            RSAerr(RSA_F_CHECK_PADDING_MD, RSA_R_INVALID_DIGEST);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_DIGEST);
             return 0;
 
         }
@@ -434,8 +432,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
             return 1;
         }
  bad_pad:
-        RSAerr(RSA_F_PKEY_RSA_CTRL,
-               RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE);
         return -2;
 
     case EVP_PKEY_CTRL_GET_RSA_PADDING:
@@ -445,7 +442,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
     case EVP_PKEY_CTRL_RSA_PSS_SALTLEN:
     case EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN:
         if (rctx-&gt;pad_mode != RSA_PKCS1_PSS_PADDING) {
-            RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_PSS_SALTLEN);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PSS_SALTLEN);
             return -2;
         }
         if (type == EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN) {
@@ -456,13 +453,13 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
             if (rsa_pss_restricted(rctx)) {
                 if (p1 == RSA_PSS_SALTLEN_AUTO
                     &amp;&amp; ctx-&gt;operation == EVP_PKEY_OP_VERIFY) {
-                    RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_PSS_SALTLEN);
+                    ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PSS_SALTLEN);
                     return -2;
                 }
                 if ((p1 == RSA_PSS_SALTLEN_DIGEST
                      &amp;&amp; rctx-&gt;min_saltlen &gt; EVP_MD_size(rctx-&gt;md))
                     || (p1 &gt;= 0 &amp;&amp; p1 &lt; rctx-&gt;min_saltlen)) {
-                    RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_PSS_SALTLEN_TOO_SMALL);
+                    ERR_raise(ERR_LIB_RSA, RSA_R_PSS_SALTLEN_TOO_SMALL);
                     return 0;
                 }
             }
@@ -472,7 +469,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
 
     case EVP_PKEY_CTRL_RSA_KEYGEN_BITS:
         if (p1 &lt; RSA_MIN_MODULUS_BITS) {
-            RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_KEY_SIZE_TOO_SMALL);
+            ERR_raise(ERR_LIB_RSA, RSA_R_KEY_SIZE_TOO_SMALL);
             return -2;
         }
         rctx-&gt;nbits = p1;
@@ -480,7 +477,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
 
     case EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP:
         if (p2 == NULL || !BN_is_odd((BIGNUM *)p2) || BN_is_one((BIGNUM *)p2)) {
-            RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_BAD_E_VALUE);
+            ERR_raise(ERR_LIB_RSA, RSA_R_BAD_E_VALUE);
             return -2;
         }
         BN_free(rctx-&gt;pub_exp);
@@ -489,7 +486,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
 
     case EVP_PKEY_CTRL_RSA_KEYGEN_PRIMES:
         if (p1 &lt; RSA_DEFAULT_PRIME_NUM || p1 &gt; RSA_MAX_PRIME_NUM) {
-            RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_KEY_PRIME_NUM_INVALID);
+            ERR_raise(ERR_LIB_RSA, RSA_R_KEY_PRIME_NUM_INVALID);
             return -2;
         }
         rctx-&gt;primes = p1;
@@ -498,7 +495,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
     case EVP_PKEY_CTRL_RSA_OAEP_MD:
     case EVP_PKEY_CTRL_GET_RSA_OAEP_MD:
         if (rctx-&gt;pad_mode != RSA_PKCS1_OAEP_PADDING) {
-            RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_PADDING_MODE);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PADDING_MODE);
             return -2;
         }
         if (type == EVP_PKEY_CTRL_GET_RSA_OAEP_MD)
@@ -513,7 +510,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
         if (rsa_pss_restricted(rctx)) {
             if (EVP_MD_type(rctx-&gt;md) == EVP_MD_type(p2))
                 return 1;
-            RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_DIGEST_NOT_ALLOWED);
+            ERR_raise(ERR_LIB_RSA, RSA_R_DIGEST_NOT_ALLOWED);
             return 0;
         }
         rctx-&gt;md = p2;
@@ -527,7 +524,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
     case EVP_PKEY_CTRL_GET_RSA_MGF1_MD:
         if (rctx-&gt;pad_mode != RSA_PKCS1_PSS_PADDING
             &amp;&amp; rctx-&gt;pad_mode != RSA_PKCS1_OAEP_PADDING) {
-            RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_MGF1_MD);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_MGF1_MD);
             return -2;
         }
         if (type == EVP_PKEY_CTRL_GET_RSA_MGF1_MD) {
@@ -539,7 +536,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
             if (rsa_pss_restricted(rctx)) {
                 if (EVP_MD_type(rctx-&gt;mgf1md) == EVP_MD_type(p2))
                     return 1;
-                RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_MGF1_DIGEST_NOT_ALLOWED);
+                ERR_raise(ERR_LIB_RSA, RSA_R_MGF1_DIGEST_NOT_ALLOWED);
                 return 0;
             }
             rctx-&gt;mgf1md = p2;
@@ -548,7 +545,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
 
     case EVP_PKEY_CTRL_RSA_OAEP_LABEL:
         if (rctx-&gt;pad_mode != RSA_PKCS1_OAEP_PADDING) {
-            RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_PADDING_MODE);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PADDING_MODE);
             return -2;
         }
         OPENSSL_free(rctx-&gt;oaep_label);
@@ -563,7 +560,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
 
     case EVP_PKEY_CTRL_GET_RSA_OAEP_LABEL:
         if (rctx-&gt;pad_mode != RSA_PKCS1_OAEP_PADDING) {
-            RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_PADDING_MODE);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PADDING_MODE);
             return -2;
         }
         *(unsigned char **)p2 = rctx-&gt;oaep_label;
@@ -586,8 +583,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
         return 1;
     /* fall through */
     case EVP_PKEY_CTRL_PEER_KEY:
-        RSAerr(RSA_F_PKEY_RSA_CTRL,
-               RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         return -2;
 
     default:
@@ -600,7 +596,7 @@ static int pkey_rsa_ctrl_str(EVP_PKEY_CTX *ctx,
                              const char *type, const char *value)
 {
     if (value == NULL) {
-        RSAerr(RSA_F_PKEY_RSA_CTRL_STR, RSA_R_VALUE_MISSING);
+        ERR_raise(ERR_LIB_RSA, RSA_R_VALUE_MISSING);
         return 0;
     }
     if (strcmp(type, &quot;rsa_padding_mode&quot;) == 0) {
@@ -621,7 +617,7 @@ static int pkey_rsa_ctrl_str(EVP_PKEY_CTX *ctx,
         } else if (strcmp(value, &quot;pss&quot;) == 0) {
             pm = RSA_PKCS1_PSS_PADDING;
         } else {
-            RSAerr(RSA_F_PKEY_RSA_CTRL_STR, RSA_R_UNKNOWN_PADDING_TYPE);
+            ERR_raise(ERR_LIB_RSA, RSA_R_UNKNOWN_PADDING_TYPE);
             return -2;
         }
         return EVP_PKEY_CTX_set_rsa_padding(ctx, pm);
@@ -832,7 +828,7 @@ static int pkey_pss_init(EVP_PKEY_CTX *ctx)
     if ((RSA_bits(rsa) &amp; 0x7) == 1)
         max_saltlen--;
     if (min_saltlen &gt; max_saltlen) {
-        RSAerr(RSA_F_PKEY_PSS_INIT, RSA_R_INVALID_SALT_LENGTH);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_SALT_LENGTH);
         return 0;
     }
 
diff --git a/crypto/rsa/rsa_prn.c b/crypto/rsa/rsa_prn.c
index edeca81e4f..4a317dadc4 100644
--- a/crypto/rsa/rsa_prn.c
+++ b/crypto/rsa/rsa_prn.c
@@ -25,7 +25,7 @@ int RSA_print_fp(FILE *fp, const RSA *x, int off)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        RSAerr(RSA_F_RSA_PRINT_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_RSA, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
diff --git a/crypto/rsa/rsa_pss.c b/crypto/rsa/rsa_pss.c
index e3a548d2e3..1b73cbb0f6 100644
--- a/crypto/rsa/rsa_pss.c
+++ b/crypto/rsa/rsa_pss.c
@@ -66,14 +66,14 @@ int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
     if (sLen == RSA_PSS_SALTLEN_DIGEST) {
         sLen = hLen;
     } else if (sLen &lt; RSA_PSS_SALTLEN_MAX) {
-        RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_SLEN_CHECK_FAILED);
+        ERR_raise(ERR_LIB_RSA, RSA_R_SLEN_CHECK_FAILED);
         goto err;
     }
 
     MSBits = (BN_num_bits(rsa-&gt;n) - 1) &amp; 0x7;
     emLen = RSA_size(rsa);
     if (EM[0] &amp; (0xFF &lt;&lt; MSBits)) {
-        RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_FIRST_OCTET_INVALID);
+        ERR_raise(ERR_LIB_RSA, RSA_R_FIRST_OCTET_INVALID);
         goto err;
     }
     if (MSBits == 0) {
@@ -81,24 +81,24 @@ int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
         emLen--;
     }
     if (emLen &lt; hLen + 2) {
-        RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_DATA_TOO_LARGE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE);
         goto err;
     }
     if (sLen == RSA_PSS_SALTLEN_MAX) {
         sLen = emLen - hLen - 2;
     } else if (sLen &gt; emLen - hLen - 2) { /* sLen can be small negative */
-        RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_DATA_TOO_LARGE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE);
         goto err;
     }
     if (EM[emLen - 1] != 0xbc) {
-        RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_LAST_OCTET_INVALID);
+        ERR_raise(ERR_LIB_RSA, RSA_R_LAST_OCTET_INVALID);
         goto err;
     }
     maskedDBLen = emLen - hLen - 1;
     H = EM + maskedDBLen;
     DB = OPENSSL_malloc(maskedDBLen);
     if (DB == NULL) {
-        RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (PKCS1_MGF1(DB, maskedDBLen, H, hLen, mgf1Hash) &lt; 0)
@@ -109,11 +109,11 @@ int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
         DB[0] &amp;= 0xFF &gt;&gt; (8 - MSBits);
     for (i = 0; DB[i] == 0 &amp;&amp; i &lt; (maskedDBLen - 1); i++) ;
     if (DB[i++] != 0x1) {
-        RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_SLEN_RECOVERY_FAILED);
+        ERR_raise(ERR_LIB_RSA, RSA_R_SLEN_RECOVERY_FAILED);
         goto err;
     }
     if (sLen != RSA_PSS_SALTLEN_AUTO &amp;&amp; (maskedDBLen - i) != sLen) {
-        RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_SLEN_CHECK_FAILED);
+        ERR_raise(ERR_LIB_RSA, RSA_R_SLEN_CHECK_FAILED);
         goto err;
     }
     if (!EVP_DigestInit_ex(ctx, Hash, NULL)
@@ -127,7 +127,7 @@ int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
     if (!EVP_DigestFinal_ex(ctx, H_, NULL))
         goto err;
     if (memcmp(H_, H, hLen)) {
-        RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_BAD_SIGNATURE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_BAD_SIGNATURE);
         ret = 0;
     } else {
         ret = 1;
@@ -177,7 +177,7 @@ int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,
     } else if (sLen == RSA_PSS_SALTLEN_MAX_SIGN) {
         sLen = RSA_PSS_SALTLEN_MAX;
     } else if (sLen &lt; RSA_PSS_SALTLEN_MAX) {
-        RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1, RSA_R_SLEN_CHECK_FAILED);
+        ERR_raise(ERR_LIB_RSA, RSA_R_SLEN_CHECK_FAILED);
         goto err;
     }
 
@@ -188,22 +188,19 @@ int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,
         emLen--;
     }
     if (emLen &lt; hLen + 2) {
-        RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1,
-               RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
         goto err;
     }
     if (sLen == RSA_PSS_SALTLEN_MAX) {
         sLen = emLen - hLen - 2;
     } else if (sLen &gt; emLen - hLen - 2) {
-        RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1,
-               RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
         goto err;
     }
     if (sLen &gt; 0) {
         salt = OPENSSL_malloc(sLen);
         if (salt == NULL) {
-            RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1,
-                   ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (RAND_bytes_ex(rsa-&gt;libctx, salt, sLen) &lt;= 0)
diff --git a/crypto/rsa/rsa_saos.c b/crypto/rsa/rsa_saos.c
index 7fd6696075..58fa50785b 100644
--- a/crypto/rsa/rsa_saos.c
+++ b/crypto/rsa/rsa_saos.c
@@ -36,13 +36,12 @@ int RSA_sign_ASN1_OCTET_STRING(int type,
     i = i2d_ASN1_OCTET_STRING(&amp;sig, NULL);
     j = RSA_size(rsa);
     if (i &gt; (j - RSA_PKCS1_PADDING_SIZE)) {
-        RSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING,
-               RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
         return 0;
     }
     s = OPENSSL_malloc((unsigned int)j + 1);
     if (s == NULL) {
-        RSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     p = s;
@@ -68,14 +67,13 @@ int RSA_verify_ASN1_OCTET_STRING(int dtype,
     ASN1_OCTET_STRING *sig = NULL;
 
     if (siglen != (unsigned int)RSA_size(rsa)) {
-        RSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,
-               RSA_R_WRONG_SIGNATURE_LENGTH);
+        ERR_raise(ERR_LIB_RSA, RSA_R_WRONG_SIGNATURE_LENGTH);
         return 0;
     }
 
     s = OPENSSL_malloc((unsigned int)siglen);
     if (s == NULL) {
-        RSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     i = RSA_public_decrypt((int)siglen, sigbuf, s, rsa, RSA_PKCS1_PADDING);
@@ -90,7 +88,7 @@ int RSA_verify_ASN1_OCTET_STRING(int dtype,
 
     if (((unsigned int)sig-&gt;length != m_len) ||
         (memcmp(m, sig-&gt;data, m_len) != 0)) {
-        RSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING, RSA_R_BAD_SIGNATURE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_BAD_SIGNATURE);
     } else {
         ret = 1;
     }
diff --git a/crypto/rsa/rsa_sign.c b/crypto/rsa/rsa_sign.c
index bef062d1bd..b277c37789 100644
--- a/crypto/rsa/rsa_sign.c
+++ b/crypto/rsa/rsa_sign.c
@@ -247,19 +247,19 @@ static int encode_pkcs1(unsigned char **out, size_t *out_len, int type,
     unsigned char *dig_info;
 
     if (type == NID_undef) {
-        RSAerr(RSA_F_ENCODE_PKCS1, RSA_R_UNKNOWN_ALGORITHM_TYPE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_UNKNOWN_ALGORITHM_TYPE);
         return 0;
     }
     di_prefix = ossl_rsa_digestinfo_encoding(type, &amp;di_prefix_len);
     if (di_prefix == NULL) {
-        RSAerr(RSA_F_ENCODE_PKCS1,
-               RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);
+        ERR_raise(ERR_LIB_RSA,
+                  RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);
         return 0;
     }
     dig_info_len = di_prefix_len + m_len;
     dig_info = OPENSSL_malloc(dig_info_len);
     if (dig_info == NULL) {
-        RSAerr(RSA_F_ENCODE_PKCS1, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     memcpy(dig_info, di_prefix, di_prefix_len);
@@ -291,7 +291,7 @@ int RSA_sign(int type, const unsigned char *m, unsigned int m_len,
          * RSASSA-PKCS1-v1_5.
          */
         if (m_len != SSL_SIG_LENGTH) {
-            RSAerr(RSA_F_RSA_SIGN, RSA_R_INVALID_MESSAGE_LENGTH);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_MESSAGE_LENGTH);
             return 0;
         }
         encoded_len = SSL_SIG_LENGTH;
@@ -303,7 +303,7 @@ int RSA_sign(int type, const unsigned char *m, unsigned int m_len,
     }
 
     if (encoded_len + RSA_PKCS1_PADDING_SIZE &gt; (size_t)RSA_size(rsa)) {
-        RSAerr(RSA_F_RSA_SIGN, RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
         goto err;
     }
     encrypt_len = RSA_private_encrypt((int)encoded_len, encoded, sigret, rsa,
@@ -337,14 +337,14 @@ int int_rsa_verify(int type, const unsigned char *m, unsigned int m_len,
     unsigned char *decrypt_buf = NULL, *encoded = NULL;
 
     if (siglen != (size_t)RSA_size(rsa)) {
-        RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_WRONG_SIGNATURE_LENGTH);
+        ERR_raise(ERR_LIB_RSA, RSA_R_WRONG_SIGNATURE_LENGTH);
         return 0;
     }
 
     /* Recover the encoded digest. */
     decrypt_buf = OPENSSL_malloc(siglen);
     if (decrypt_buf == NULL) {
-        RSAerr(RSA_F_INT_RSA_VERIFY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -362,7 +362,7 @@ int int_rsa_verify(int type, const unsigned char *m, unsigned int m_len,
          * RSASSA-PKCS1-v1_5.
          */
         if (decrypt_len != SSL_SIG_LENGTH) {
-            RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);
+            ERR_raise(ERR_LIB_RSA, RSA_R_BAD_SIGNATURE);
             goto err;
         }
 
@@ -371,12 +371,12 @@ int int_rsa_verify(int type, const unsigned char *m, unsigned int m_len,
             *prm_len = SSL_SIG_LENGTH;
         } else {
             if (m_len != SSL_SIG_LENGTH) {
-                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);
+                ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_MESSAGE_LENGTH);
                 goto err;
             }
 
             if (memcmp(decrypt_buf, m, SSL_SIG_LENGTH) != 0) {
-                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);
+                ERR_raise(ERR_LIB_RSA, RSA_R_BAD_SIGNATURE);
                 goto err;
             }
         }
@@ -391,12 +391,12 @@ int int_rsa_verify(int type, const unsigned char *m, unsigned int m_len,
             *prm_len = 16;
         } else {
             if (m_len != 16) {
-                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);
+                ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_MESSAGE_LENGTH);
                 goto err;
             }
 
             if (memcmp(m, decrypt_buf + 2, 16) != 0) {
-                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);
+                ERR_raise(ERR_LIB_RSA, RSA_R_BAD_SIGNATURE);
                 goto err;
             }
         }
@@ -415,7 +415,7 @@ int int_rsa_verify(int type, const unsigned char *m, unsigned int m_len,
                 goto err;
             m_len = (unsigned int)len;
             if (m_len &gt; decrypt_len) {
-                RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_DIGEST_LENGTH);
+                ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_DIGEST_LENGTH);
                 goto err;
             }
             m = decrypt_buf + decrypt_len - m_len;
@@ -427,7 +427,7 @@ int int_rsa_verify(int type, const unsigned char *m, unsigned int m_len,
 
         if (encoded_len != decrypt_len
                 || memcmp(encoded, decrypt_buf, encoded_len) != 0) {
-            RSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);
+            ERR_raise(ERR_LIB_RSA, RSA_R_BAD_SIGNATURE);
             goto err;
         }
 
diff --git a/crypto/rsa/rsa_sp800_56b_check.c b/crypto/rsa/rsa_sp800_56b_check.c
index 2cdc2fa5e6..173bc5e253 100644
--- a/crypto/rsa/rsa_sp800_56b_check.c
+++ b/crypto/rsa/rsa_sp800_56b_check.c
@@ -306,17 +306,17 @@ int ossl_rsa_sp800_56b_check_public(const RSA *rsa)
      */
     nbits = BN_num_bits(rsa-&gt;n);
     if (!ossl_rsa_sp800_56b_validate_strength(nbits, -1)) {
-        RSAerr(0, RSA_R_INVALID_KEY_LENGTH);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_KEY_LENGTH);
         return 0;
     }
 #endif
     if (!BN_is_odd(rsa-&gt;n)) {
-        RSAerr(0, RSA_R_INVALID_MODULUS);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_MODULUS);
         return 0;
     }
     /* (Steps b-c): 2^16 &lt; e &lt; 2^256, n and e must be odd */
     if (!ossl_rsa_check_public_exponent(rsa-&gt;e)) {
-        RSAerr(0, RSA_R_PUB_EXPONENT_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_PUB_EXPONENT_OUT_OF_RANGE);
         return 0;
     }
 
@@ -330,13 +330,13 @@ int ossl_rsa_sp800_56b_check_public(const RSA *rsa)
      * The modulus has no factors smaller than 752.
      */
     if (!BN_gcd(gcd, rsa-&gt;n, bn_get0_small_factors(), ctx) || !BN_is_one(gcd)) {
-        RSAerr(0, RSA_R_INVALID_MODULUS);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_MODULUS);
         goto err;
     }
 
     ret = bn_miller_rabin_is_prime(rsa-&gt;n, 0, ctx, NULL, 1, &amp;status);
     if (ret != 1 || status != BN_PRIMETEST_COMPOSITE_NOT_POWER_OF_PRIME) {
-        RSAerr(0, RSA_R_INVALID_MODULUS);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_MODULUS);
         ret = 0;
         goto err;
     }
@@ -381,7 +381,7 @@ int ossl_rsa_sp800_56b_check_keypair(const RSA *rsa, const BIGNUM *efixed,
             || rsa-&gt;e == NULL
             || rsa-&gt;d == NULL
             || rsa-&gt;n == NULL) {
-        RSAerr(0, RSA_R_INVALID_REQUEST);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_REQUEST);
         return 0;
     }
     /* (Step 1): Check Ranges */
@@ -392,19 +392,19 @@ int ossl_rsa_sp800_56b_check_keypair(const RSA *rsa, const BIGNUM *efixed,
     if (efixed != NULL) {
         /* (2): Check fixed exponent matches public exponent. */
         if (BN_cmp(efixed, rsa-&gt;e) != 0) {
-            RSAerr(0, RSA_R_INVALID_REQUEST);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_REQUEST);
             return 0;
         }
     }
     /* (Step 1.c): e is odd integer 65537 &lt;= e &lt; 2^256 */
     if (!ossl_rsa_check_public_exponent(rsa-&gt;e)) {
         /* exponent out of range */
-        RSAerr(0, RSA_R_PUB_EXPONENT_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_PUB_EXPONENT_OUT_OF_RANGE);
         return 0;
     }
     /* (Step 3.b): check the modulus */
     if (nbits != BN_num_bits(rsa-&gt;n)) {
-        RSAerr(0, RSA_R_INVALID_KEYPAIR);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_KEYPAIR);
         return 0;
     }
 
@@ -418,7 +418,7 @@ int ossl_rsa_sp800_56b_check_keypair(const RSA *rsa, const BIGNUM *efixed,
         goto err;
     /* (Step 4.c): Check n = pq */
     if (BN_cmp(rsa-&gt;n, r) != 0) {
-        RSAerr(0, RSA_R_INVALID_REQUEST);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_REQUEST);
         goto err;
     }
 
@@ -431,7 +431,7 @@ int ossl_rsa_sp800_56b_check_keypair(const RSA *rsa, const BIGNUM *efixed,
           /* 6.4.1.2.3 (Step 7): Check the CRT components */
           &amp;&amp; ossl_rsa_check_crt_components(rsa, ctx);
     if (ret != 1)
-        RSAerr(0, RSA_R_INVALID_KEYPAIR);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_KEYPAIR);
 
 err:
     BN_clear(r);
diff --git a/crypto/rsa/rsa_sp800_56b_gen.c b/crypto/rsa/rsa_sp800_56b_gen.c
index e8fdcd8940..3fffb3b80a 100644
--- a/crypto/rsa/rsa_sp800_56b_gen.c
+++ b/crypto/rsa/rsa_sp800_56b_gen.c
@@ -88,12 +88,12 @@ int ossl_rsa_fips186_4_gen_prob_primes(RSA *rsa, RSA_ACVP_TEST *test,
      * Signature Generation and Key Agree/Transport.
      */
     if (nbits &lt; RSA_FIPS1864_MIN_KEYGEN_KEYSIZE) {
-        RSAerr(0, RSA_R_KEY_SIZE_TOO_SMALL);
+        ERR_raise(ERR_LIB_RSA, RSA_R_KEY_SIZE_TOO_SMALL);
         return 0;
     }
 
     if (!ossl_rsa_check_public_exponent(e)) {
-        RSAerr(0, RSA_R_PUB_EXPONENT_OUT_OF_RANGE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_PUB_EXPONENT_OUT_OF_RANGE);
         return 0;
     }
 
@@ -175,12 +175,12 @@ int ossl_rsa_sp800_56b_validate_strength(int nbits, int strength)
 #ifdef FIPS_MODULE
     if (s &lt; RSA_FIPS1864_MIN_KEYGEN_STRENGTH
             || s &gt; RSA_FIPS1864_MAX_KEYGEN_STRENGTH) {
-        RSAerr(0, RSA_R_INVALID_MODULUS);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_MODULUS);
         return 0;
     }
 #endif
     if (strength != -1 &amp;&amp; s != strength) {
-        RSAerr(0, RSA_R_INVALID_STRENGTH);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_STRENGTH);
         return 0;
     }
     return 1;
@@ -406,7 +406,7 @@ int ossl_rsa_sp800_56b_pairwise_test(RSA *rsa, BN_CTX *ctx)
           &amp;&amp; BN_mod_exp(tmp, tmp, rsa-&gt;d, rsa-&gt;n, ctx)
           &amp;&amp; BN_cmp(k, tmp) == 0);
     if (ret == 0)
-        RSAerr(0, RSA_R_PAIRWISE_TEST_FAILURE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_PAIRWISE_TEST_FAILURE);
 err:
     BN_CTX_end(ctx);
     return ret;
diff --git a/crypto/rsa/rsa_ssl.c b/crypto/rsa/rsa_ssl.c
index 7e688aa9bc..0feef0f655 100644
--- a/crypto/rsa/rsa_ssl.c
+++ b/crypto/rsa/rsa_ssl.c
@@ -29,7 +29,7 @@ int ossl_rsa_padding_add_SSLv23_ex(OSSL_LIB_CTX *libctx, unsigned char *to,
     unsigned char *p;
 
     if (flen &gt; (tlen - RSA_PKCS1_PADDING_SIZE)) {
-        RSAerr(0, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
         return 0;
     }
 
@@ -84,13 +84,13 @@ int RSA_padding_check_SSLv23(unsigned char *to, int tlen,
         return -1;
 
     if (flen &gt; num || num &lt; RSA_PKCS1_PADDING_SIZE) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_DATA_TOO_SMALL);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_SMALL);
         return -1;
     }
 
     em = OPENSSL_malloc(num);
     if (em == NULL) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_RSA, ERR_R_MALLOC_FAILURE);
         return -1;
     }
     /*
@@ -176,7 +176,7 @@ int RSA_padding_check_SSLv23(unsigned char *to, int tlen,
     }
 
     OPENSSL_clear_free(em, num);
-    RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, err);
+    ERR_raise(ERR_LIB_RSA, err);
     err_clear_last_constant_time(1 &amp; good);
 
     return constant_time_select_int(good, mlen, -1);
diff --git a/crypto/rsa/rsa_x931.c b/crypto/rsa/rsa_x931.c
index c739260130..9d331ab9a7 100644
--- a/crypto/rsa/rsa_x931.c
+++ b/crypto/rsa/rsa_x931.c
@@ -33,7 +33,7 @@ int RSA_padding_add_X931(unsigned char *to, int tlen,
     j = tlen - flen - 2;
 
     if (j &lt; 0) {
-        RSAerr(RSA_F_RSA_PADDING_ADD_X931, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
+        ERR_raise(ERR_LIB_RSA, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
         return -1;
     }
 
@@ -64,7 +64,7 @@ int RSA_padding_check_X931(unsigned char *to, int tlen,
 
     p = from;
     if ((num != flen) || ((*p != 0x6A) &amp;&amp; (*p != 0x6B))) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_HEADER);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_HEADER);
         return -1;
     }
 
@@ -75,7 +75,7 @@ int RSA_padding_check_X931(unsigned char *to, int tlen,
             if (c == 0xBA)
                 break;
             if (c != 0xBB) {
-                RSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_PADDING);
+                ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PADDING);
                 return -1;
             }
         }
@@ -83,7 +83,7 @@ int RSA_padding_check_X931(unsigned char *to, int tlen,
         j -= i;
 
         if (i == 0) {
-            RSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_PADDING);
+            ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PADDING);
             return -1;
         }
 
@@ -92,7 +92,7 @@ int RSA_padding_check_X931(unsigned char *to, int tlen,
     }
 
     if (p[j] != 0xCC) {
-        RSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_TRAILER);
+        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_TRAILER);
         return -1;
     }
 
diff --git a/crypto/sm2/sm2_crypt.c b/crypto/sm2/sm2_crypt.c
index 6db87f6845..9201d712c1 100644
--- a/crypto/sm2/sm2_crypt.c
+++ b/crypto/sm2/sm2_crypt.c
@@ -75,17 +75,17 @@ int sm2_plaintext_size(const EC_KEY *key, const EVP_MD *digest, size_t msg_len,
     size_t overhead;
 
     if (md_size &lt; 0) {
-        SM2err(SM2_F_SM2_PLAINTEXT_SIZE, SM2_R_INVALID_DIGEST);
+        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_DIGEST);
         return 0;
     }
     if (field_size == 0) {
-        SM2err(SM2_F_SM2_PLAINTEXT_SIZE, SM2_R_INVALID_FIELD);
+        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_FIELD);
         return 0;
     }
 
     overhead = 10 + 2 * field_size + (size_t)md_size;
     if (msg_len &lt;= overhead) {
-        SM2err(SM2_F_SM2_PLAINTEXT_SIZE, SM2_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_ENCODING);
         return 0;
     }
 
@@ -147,13 +147,13 @@ int sm2_encrypt(const EC_KEY *key,
     ctext_struct.C3 = NULL;
 
     if (hash == NULL || C3_size &lt;= 0) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
 
     field_size = ec_field_size(group);
     if (field_size == 0) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
 
@@ -161,7 +161,7 @@ int sm2_encrypt(const EC_KEY *key,
     kP = EC_POINT_new(group);
     ctx = BN_CTX_new_ex(libctx);
     if (kG == NULL || kP == NULL || ctx == NULL) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
@@ -173,7 +173,7 @@ int sm2_encrypt(const EC_KEY *key,
     y2 = BN_CTX_get(ctx);
 
     if (y2 == NULL) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
         goto done;
     }
 
@@ -181,14 +181,14 @@ int sm2_encrypt(const EC_KEY *key,
     C3 = OPENSSL_zalloc(C3_size);
 
     if (x2y2 == NULL || C3 == NULL) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
     memset(ciphertext_buf, 0, *ciphertext_len);
 
     if (!BN_priv_rand_range(k, order)) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
 
@@ -196,26 +196,26 @@ int sm2_encrypt(const EC_KEY *key,
             || !EC_POINT_get_affine_coordinates(group, kG, x1, y1, ctx)
             || !EC_POINT_mul(group, kP, NULL, P, k, ctx)
             || !EC_POINT_get_affine_coordinates(group, kP, x2, y2, ctx)) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
         goto done;
     }
 
     if (BN_bn2binpad(x2, x2y2, field_size) &lt; 0
             || BN_bn2binpad(y2, x2y2 + field_size, field_size) &lt; 0) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
 
     msg_mask = OPENSSL_zalloc(msg_len);
     if (msg_mask == NULL) {
-       SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);
+       ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
        goto done;
    }
 
     /* X9.63 with no salt happens to match the KDF used in SM2 */
     if (!ecdh_KDF_X9_63(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,
                         digest, libctx, propq)) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);
         goto done;
     }
 
@@ -224,7 +224,7 @@ int sm2_encrypt(const EC_KEY *key,
 
     fetched_digest = EVP_MD_fetch(libctx, EVP_MD_name(digest), propq);
     if (fetched_digest == NULL) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
     if (EVP_DigestInit(hash, fetched_digest) == 0
@@ -232,7 +232,7 @@ int sm2_encrypt(const EC_KEY *key,
             || EVP_DigestUpdate(hash, msg, msg_len) == 0
             || EVP_DigestUpdate(hash, x2y2 + field_size, field_size) == 0
             || EVP_DigestFinal(hash, C3, NULL) == 0) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);
         goto done;
     }
 
@@ -242,19 +242,19 @@ int sm2_encrypt(const EC_KEY *key,
     ctext_struct.C2 = ASN1_OCTET_STRING_new();
 
     if (ctext_struct.C3 == NULL || ctext_struct.C2 == NULL) {
-       SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);
+       ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
        goto done;
     }
     if (!ASN1_OCTET_STRING_set(ctext_struct.C3, C3, C3_size)
             || !ASN1_OCTET_STRING_set(ctext_struct.C2, msg_mask, msg_len)) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
 
     ciphertext_leni = i2d_SM2_Ciphertext(&amp;ctext_struct, &amp;ciphertext_buf);
     /* Ensure cast to size_t is safe */
     if (ciphertext_leni &lt; 0) {
-        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
     *ciphertext_len = (size_t)ciphertext_leni;
@@ -308,12 +308,12 @@ int sm2_decrypt(const EC_KEY *key,
     sm2_ctext = d2i_SM2_Ciphertext(NULL, &amp;ciphertext, ciphertext_len);
 
     if (sm2_ctext == NULL) {
-        SM2err(SM2_F_SM2_DECRYPT, SM2_R_ASN1_ERROR);
+        ERR_raise(ERR_LIB_SM2, SM2_R_ASN1_ERROR);
         goto done;
     }
 
     if (sm2_ctext-&gt;C3-&gt;length != hash_size) {
-        SM2err(SM2_F_SM2_DECRYPT, SM2_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_ENCODING);
         goto done;
     }
 
@@ -323,7 +323,7 @@ int sm2_decrypt(const EC_KEY *key,
 
     ctx = BN_CTX_new_ex(libctx);
     if (ctx == NULL) {
-        SM2err(SM2_F_SM2_DECRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
@@ -332,7 +332,7 @@ int sm2_decrypt(const EC_KEY *key,
     y2 = BN_CTX_get(ctx);
 
     if (y2 == NULL) {
-        SM2err(SM2_F_SM2_DECRYPT, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
         goto done;
     }
 
@@ -341,13 +341,13 @@ int sm2_decrypt(const EC_KEY *key,
     computed_C3 = OPENSSL_zalloc(hash_size);
 
     if (msg_mask == NULL || x2y2 == NULL || computed_C3 == NULL) {
-        SM2err(SM2_F_SM2_DECRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
     C1 = EC_POINT_new(group);
     if (C1 == NULL) {
-        SM2err(SM2_F_SM2_DECRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
@@ -356,7 +356,7 @@ int sm2_decrypt(const EC_KEY *key,
             || !EC_POINT_mul(group, C1, NULL, C1, EC_KEY_get0_private_key(key),
                              ctx)
             || !EC_POINT_get_affine_coordinates(group, C1, x2, y2, ctx)) {
-        SM2err(SM2_F_SM2_DECRYPT, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
         goto done;
     }
 
@@ -364,7 +364,7 @@ int sm2_decrypt(const EC_KEY *key,
             || BN_bn2binpad(y2, x2y2 + field_size, field_size) &lt; 0
             || !ecdh_KDF_X9_63(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,
                                digest, libctx, propq)) {
-        SM2err(SM2_F_SM2_DECRYPT, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
 
@@ -373,7 +373,7 @@ int sm2_decrypt(const EC_KEY *key,
 
     hash = EVP_MD_CTX_new();
     if (hash == NULL) {
-        SM2err(SM2_F_SM2_DECRYPT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
@@ -382,12 +382,12 @@ int sm2_decrypt(const EC_KEY *key,
             || !EVP_DigestUpdate(hash, ptext_buf, msg_len)
             || !EVP_DigestUpdate(hash, x2y2 + field_size, field_size)
             || !EVP_DigestFinal(hash, computed_C3, NULL)) {
-        SM2err(SM2_F_SM2_DECRYPT, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);
         goto done;
     }
 
     if (CRYPTO_memcmp(computed_C3, C3, hash_size) != 0) {
-        SM2err(SM2_F_SM2_DECRYPT, SM2_R_INVALID_DIGEST);
+        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_DIGEST);
         goto done;
     }
 
diff --git a/crypto/sm2/sm2_sign.c b/crypto/sm2/sm2_sign.c
index d180a5ace7..94ea3aef96 100644
--- a/crypto/sm2/sm2_sign.c
+++ b/crypto/sm2/sm2_sign.c
@@ -44,7 +44,7 @@ int sm2_compute_z_digest(uint8_t *out,
     hash = EVP_MD_CTX_new();
     ctx = BN_CTX_new_ex(ec_key_get_libctx(key));
     if (hash == NULL || ctx == NULL) {
-        SM2err(SM2_F_SM2_COMPUTE_Z_DIGEST, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
@@ -57,12 +57,12 @@ int sm2_compute_z_digest(uint8_t *out,
     yA = BN_CTX_get(ctx);
 
     if (yA == NULL) {
-        SM2err(SM2_F_SM2_COMPUTE_Z_DIGEST, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
     if (!EVP_DigestInit(hash, digest)) {
-        SM2err(SM2_F_SM2_COMPUTE_Z_DIGEST, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);
         goto done;
     }
 
@@ -70,7 +70,7 @@ int sm2_compute_z_digest(uint8_t *out,
 
     if (id_len &gt;= (UINT16_MAX / 8)) {
         /* too large */
-        SM2err(SM2_F_SM2_COMPUTE_Z_DIGEST, SM2_R_ID_TOO_LARGE);
+        ERR_raise(ERR_LIB_SM2, SM2_R_ID_TOO_LARGE);
         goto done;
     }
 
@@ -78,29 +78,29 @@ int sm2_compute_z_digest(uint8_t *out,
 
     e_byte = entl &gt;&gt; 8;
     if (!EVP_DigestUpdate(hash, &amp;e_byte, 1)) {
-        SM2err(SM2_F_SM2_COMPUTE_Z_DIGEST, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);
         goto done;
     }
     e_byte = entl &amp; 0xFF;
     if (!EVP_DigestUpdate(hash, &amp;e_byte, 1)) {
-        SM2err(SM2_F_SM2_COMPUTE_Z_DIGEST, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);
         goto done;
     }
 
     if (id_len &gt; 0 &amp;&amp; !EVP_DigestUpdate(hash, id, id_len)) {
-        SM2err(SM2_F_SM2_COMPUTE_Z_DIGEST, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);
         goto done;
     }
 
     if (!EC_GROUP_get_curve(group, p, a, b, ctx)) {
-        SM2err(SM2_F_SM2_COMPUTE_Z_DIGEST, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
         goto done;
     }
 
     p_bytes = BN_num_bytes(p);
     buf = OPENSSL_zalloc(p_bytes);
     if (buf == NULL) {
-        SM2err(SM2_F_SM2_COMPUTE_Z_DIGEST, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
@@ -123,7 +123,7 @@ int sm2_compute_z_digest(uint8_t *out,
             || BN_bn2binpad(yA, buf, p_bytes) &lt; 0
             || !EVP_DigestUpdate(hash, buf, p_bytes)
             || !EVP_DigestFinal(hash, out, NULL)) {
-        SM2err(SM2_F_SM2_COMPUTE_Z_DIGEST, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
 
@@ -151,19 +151,19 @@ static BIGNUM *sm2_compute_msg_hash(const EVP_MD *digest,
     const char *propq = ec_key_get0_propq(key);
 
     if (md_size &lt; 0) {
-        SM2err(SM2_F_SM2_COMPUTE_MSG_HASH, SM2_R_INVALID_DIGEST);
+        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_DIGEST);
         goto done;
     }
 
     z = OPENSSL_zalloc(md_size);
     if (hash == NULL || z == NULL) {
-        SM2err(SM2_F_SM2_COMPUTE_MSG_HASH, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
     fetched_digest = EVP_MD_fetch(libctx, EVP_MD_name(digest), propq);
     if (fetched_digest == NULL) {
-        SM2err(SM2_F_SM2_COMPUTE_MSG_HASH, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
 
@@ -177,13 +177,13 @@ static BIGNUM *sm2_compute_msg_hash(const EVP_MD *digest,
             || !EVP_DigestUpdate(hash, msg, msg_len)
                /* reuse z buffer to hold H(Z || M) */
             || !EVP_DigestFinal(hash, z, NULL)) {
-        SM2err(SM2_F_SM2_COMPUTE_MSG_HASH, ERR_R_EVP_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);
         goto done;
     }
 
     e = BN_bin2bn(z, md_size, NULL);
     if (e == NULL)
-        SM2err(SM2_F_SM2_COMPUTE_MSG_HASH, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
 
  done:
     EVP_MD_free(fetched_digest);
@@ -211,7 +211,7 @@ static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)
     kG = EC_POINT_new(group);
     ctx = BN_CTX_new_ex(libctx);
     if (kG == NULL || ctx == NULL) {
-        SM2err(SM2_F_SM2_SIG_GEN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
@@ -221,7 +221,7 @@ static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)
     x1 = BN_CTX_get(ctx);
     tmp = BN_CTX_get(ctx);
     if (tmp == NULL) {
-        SM2err(SM2_F_SM2_SIG_GEN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
@@ -233,13 +233,13 @@ static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)
     s = BN_new();
 
     if (r == NULL || s == NULL) {
-        SM2err(SM2_F_SM2_SIG_GEN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
     for (;;) {
         if (!BN_priv_rand_range_ex(k, order, ctx)) {
-            SM2err(SM2_F_SM2_SIG_GEN, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
             goto done;
         }
 
@@ -247,7 +247,7 @@ static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)
                 || !EC_POINT_get_affine_coordinates(group, kG, x1, NULL,
                                                     ctx)
                 || !BN_mod_add(r, e, x1, order, ctx)) {
-            SM2err(SM2_F_SM2_SIG_GEN, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
             goto done;
         }
 
@@ -256,7 +256,7 @@ static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)
             continue;
 
         if (!BN_add(rk, r, k)) {
-            SM2err(SM2_F_SM2_SIG_GEN, ERR_R_INTERNAL_ERROR);
+            ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
             goto done;
         }
 
@@ -268,13 +268,13 @@ static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)
                 || !BN_mod_mul(tmp, dA, r, order, ctx)
                 || !BN_sub(tmp, k, tmp)
                 || !BN_mod_mul(s, s, tmp, order, ctx)) {
-            SM2err(SM2_F_SM2_SIG_GEN, ERR_R_BN_LIB);
+            ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
             goto done;
         }
 
         sig = ECDSA_SIG_new();
         if (sig == NULL) {
-            SM2err(SM2_F_SM2_SIG_GEN, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
             goto done;
         }
 
@@ -311,7 +311,7 @@ static int sm2_sig_verify(const EC_KEY *key, const ECDSA_SIG *sig,
     ctx = BN_CTX_new_ex(libctx);
     pt = EC_POINT_new(group);
     if (ctx == NULL || pt == NULL) {
-        SM2err(SM2_F_SM2_SIG_VERIFY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
@@ -319,7 +319,7 @@ static int sm2_sig_verify(const EC_KEY *key, const ECDSA_SIG *sig,
     t = BN_CTX_get(ctx);
     x1 = BN_CTX_get(ctx);
     if (x1 == NULL) {
-        SM2err(SM2_F_SM2_SIG_VERIFY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
 
@@ -339,28 +339,28 @@ static int sm2_sig_verify(const EC_KEY *key, const ECDSA_SIG *sig,
             || BN_cmp(s, BN_value_one()) &lt; 0
             || BN_cmp(order, r) &lt;= 0
             || BN_cmp(order, s) &lt;= 0) {
-        SM2err(SM2_F_SM2_SIG_VERIFY, SM2_R_BAD_SIGNATURE);
+        ERR_raise(ERR_LIB_SM2, SM2_R_BAD_SIGNATURE);
         goto done;
     }
 
     if (!BN_mod_add(t, r, s, order, ctx)) {
-        SM2err(SM2_F_SM2_SIG_VERIFY, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
         goto done;
     }
 
     if (BN_is_zero(t)) {
-        SM2err(SM2_F_SM2_SIG_VERIFY, SM2_R_BAD_SIGNATURE);
+        ERR_raise(ERR_LIB_SM2, SM2_R_BAD_SIGNATURE);
         goto done;
     }
 
     if (!EC_POINT_mul(group, pt, s, EC_KEY_get0_public_key(key), t, ctx)
             || !EC_POINT_get_affine_coordinates(group, pt, x1, NULL, ctx)) {
-        SM2err(SM2_F_SM2_SIG_VERIFY, ERR_R_EC_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_EC_LIB);
         goto done;
     }
 
     if (!BN_mod_add(t, e, x1, order, ctx)) {
-        SM2err(SM2_F_SM2_SIG_VERIFY, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
         goto done;
     }
 
@@ -428,19 +428,19 @@ int sm2_internal_sign(const unsigned char *dgst, int dgstlen,
 
     e = BN_bin2bn(dgst, dgstlen, NULL);
     if (e == NULL) {
-       SM2err(0, ERR_R_BN_LIB);
+       ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
        goto done;
     }
 
     s = sm2_sig_gen(eckey, e);
     if (s == NULL) {
-        SM2err(0, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
 
     sigleni = i2d_ECDSA_SIG(s, &amp;sig);
     if (sigleni &lt; 0) {
-       SM2err(0, ERR_R_INTERNAL_ERROR);
+       ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
        goto done;
     }
     *siglen = (unsigned int)sigleni;
@@ -465,23 +465,23 @@ int sm2_internal_verify(const unsigned char *dgst, int dgstlen,
 
     s = ECDSA_SIG_new();
     if (s == NULL) {
-        SM2err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
     }
     if (d2i_ECDSA_SIG(&amp;s, &amp;p, sig_len) == NULL) {
-        SM2err(0, SM2_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_ENCODING);
         goto done;
     }
     /* Ensure signature uses DER and doesn't have trailing garbage */
     derlen = i2d_ECDSA_SIG(s, &amp;der);
     if (derlen != sig_len || memcmp(sig, der, derlen) != 0) {
-        SM2err(0, SM2_R_INVALID_ENCODING);
+        ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_ENCODING);
         goto done;
     }
 
     e = BN_bin2bn(dgst, dgstlen, NULL);
     if (e == NULL) {
-        SM2err(0, ERR_R_BN_LIB);
+        ERR_raise(ERR_LIB_SM2, ERR_R_BN_LIB);
         goto done;
     }
 
diff --git a/crypto/srp/srp_vfy.c b/crypto/srp/srp_vfy.c
index b166e5fb8b..f9053b4c11 100644
--- a/crypto/srp/srp_vfy.c
+++ b/crypto/srp/srp_vfy.c
@@ -189,7 +189,7 @@ SRP_user_pwd *SRP_user_pwd_new(void)
     SRP_user_pwd *ret;
 
     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) {
-        /* SRPerr(SRP_F_SRP_USER_PWD_NEW, ERR_R_MALLOC_FAILURE); */ /*ckerr_ignore*/
+        /* ERR_raise(ERR_LIB_SRP, ERR_R_MALLOC_FAILURE); */ /*ckerr_ignore*/
         return NULL;
     }
     ret-&gt;N = NULL;
diff --git a/crypto/stack/stack.c b/crypto/stack/stack.c
index 450a4e1a0e..72f3333174 100644
--- a/crypto/stack/stack.c
+++ b/crypto/stack/stack.c
@@ -46,7 +46,7 @@ OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *sk)
     OPENSSL_STACK *ret;
 
     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) {
-        CRYPTOerr(CRYPTO_F_OPENSSL_SK_DUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -77,7 +77,7 @@ OPENSSL_STACK *OPENSSL_sk_deep_copy(const OPENSSL_STACK *sk,
     int i;
 
     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) {
-        CRYPTOerr(CRYPTO_F_OPENSSL_SK_DEEP_COPY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -177,7 +177,7 @@ static int sk_reserve(OPENSSL_STACK *st, int n, int exact)
          * so |num_alloc| value is |n| or |min_nodes| if greater than |n|.
          */
         if ((st-&gt;data = OPENSSL_zalloc(sizeof(void *) * num_alloc)) == NULL) {
-            CRYPTOerr(CRYPTO_F_SK_RESERVE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         st-&gt;num_alloc = num_alloc;
diff --git a/crypto/store/store_lib.c b/crypto/store/store_lib.c
index 1ce61ea9da..671852cea2 100644
--- a/crypto/store/store_lib.c
+++ b/crypto/store/store_lib.c
@@ -663,7 +663,7 @@ EVP_PKEY *OSSL_STORE_INFO_get1_PUBKEY(const OSSL_STORE_INFO *info)
         EVP_PKEY_up_ref(info-&gt;_.pubkey);
         return info-&gt;_.pubkey;
     }
-    OSSL_STOREerr(0, OSSL_STORE_R_NOT_A_PUBLIC_KEY);
+    ERR_raise(ERR_LIB_OSSL_STORE, OSSL_STORE_R_NOT_A_PUBLIC_KEY);
     return NULL;
 }
 
diff --git a/crypto/store/store_result.c b/crypto/store/store_result.c
index 872efd56bb..175891d29f 100644
--- a/crypto/store/store_result.c
+++ b/crypto/store/store_result.c
@@ -325,8 +325,7 @@ static EVP_PKEY *try_key_value_legacy(struct extracted_param_data_st *data,
             size_t plen = 0;
 
             if (!cb(pbuf, sizeof(pbuf), &amp;plen, NULL, cbarg)) {
-                ERR_raise(ERR_LIB_OSSL_STORE,
-                          OSSL_STORE_R_BAD_PASSWORD_READ);
+                ERR_raise(ERR_LIB_OSSL_STORE, OSSL_STORE_R_BAD_PASSWORD_READ);
             } else {
                 const X509_ALGOR *alg = NULL;
                 const ASN1_OCTET_STRING *oct = NULL;
diff --git a/crypto/ts/ts_asn1.c b/crypto/ts/ts_asn1.c
index 49f92b22ff..b916aa3dbb 100644
--- a/crypto/ts/ts_asn1.c
+++ b/crypto/ts/ts_asn1.c
@@ -138,18 +138,17 @@ static int ts_resp_set_tst_info(TS_RESP *a)
 
     if (a-&gt;token) {
         if (status != 0 &amp;&amp; status != 1) {
-            TSerr(TS_F_TS_RESP_SET_TST_INFO, TS_R_TOKEN_PRESENT);
+            ERR_raise(ERR_LIB_TS, TS_R_TOKEN_PRESENT);
             return 0;
         }
         TS_TST_INFO_free(a-&gt;tst_info);
         a-&gt;tst_info = PKCS7_to_TS_TST_INFO(a-&gt;token);
         if (!a-&gt;tst_info) {
-            TSerr(TS_F_TS_RESP_SET_TST_INFO,
-                  TS_R_PKCS7_TO_TS_TST_INFO_FAILED);
+            ERR_raise(ERR_LIB_TS, TS_R_PKCS7_TO_TS_TST_INFO_FAILED);
             return 0;
         }
     } else if (status == 0 || status == 1) {
-        TSerr(TS_F_TS_RESP_SET_TST_INFO, TS_R_TOKEN_NOT_PRESENT);
+        ERR_raise(ERR_LIB_TS, TS_R_TOKEN_NOT_PRESENT);
         return 0;
     }
 
@@ -211,22 +210,22 @@ TS_TST_INFO *PKCS7_to_TS_TST_INFO(PKCS7 *token)
     const unsigned char *p;
 
     if (!PKCS7_type_is_signed(token)) {
-        TSerr(TS_F_PKCS7_TO_TS_TST_INFO, TS_R_BAD_PKCS7_TYPE);
+        ERR_raise(ERR_LIB_TS, TS_R_BAD_PKCS7_TYPE);
         return NULL;
     }
     if (PKCS7_get_detached(token)) {
-        TSerr(TS_F_PKCS7_TO_TS_TST_INFO, TS_R_DETACHED_CONTENT);
+        ERR_raise(ERR_LIB_TS, TS_R_DETACHED_CONTENT);
         return NULL;
     }
     pkcs7_signed = token-&gt;d.sign;
     enveloped = pkcs7_signed-&gt;contents;
     if (OBJ_obj2nid(enveloped-&gt;type) != NID_id_smime_ct_TSTInfo) {
-        TSerr(TS_F_PKCS7_TO_TS_TST_INFO, TS_R_BAD_PKCS7_TYPE);
+        ERR_raise(ERR_LIB_TS, TS_R_BAD_PKCS7_TYPE);
         return NULL;
     }
     tst_info_wrapper = enveloped-&gt;d.other;
     if (tst_info_wrapper-&gt;type != V_ASN1_OCTET_STRING) {
-        TSerr(TS_F_PKCS7_TO_TS_TST_INFO, TS_R_BAD_TYPE);
+        ERR_raise(ERR_LIB_TS, TS_R_BAD_TYPE);
         return NULL;
     }
     tst_info_der = tst_info_wrapper-&gt;value.octet_string;
diff --git a/crypto/ts/ts_conf.c b/crypto/ts/ts_conf.c
index 55fae481e1..fd2ad90754 100644
--- a/crypto/ts/ts_conf.c
+++ b/crypto/ts/ts_conf.c
@@ -55,7 +55,7 @@ X509 *TS_CONF_load_cert(const char *file)
     x = PEM_read_bio_X509_AUX(cert, NULL, NULL, NULL);
  end:
     if (x == NULL)
-        TSerr(TS_F_TS_CONF_LOAD_CERT, TS_R_CANNOT_LOAD_CERT);
+        ERR_raise(ERR_LIB_TS, TS_R_CANNOT_LOAD_CERT);
     BIO_free(cert);
     return x;
 }
@@ -87,7 +87,7 @@ STACK_OF(X509) *TS_CONF_load_certs(const char *file)
     }
  end:
     if (othercerts == NULL)
-        TSerr(TS_F_TS_CONF_LOAD_CERTS, TS_R_CANNOT_LOAD_CERT);
+        ERR_raise(ERR_LIB_TS, TS_R_CANNOT_LOAD_CERT);
     sk_X509_INFO_pop_free(allcerts, X509_INFO_free);
     BIO_free(certs);
     return othercerts;
@@ -103,7 +103,7 @@ EVP_PKEY *TS_CONF_load_key(const char *file, const char *pass)
     pkey = PEM_read_bio_PrivateKey(key, NULL, NULL, (char *)pass);
  end:
     if (pkey == NULL)
-        TSerr(TS_F_TS_CONF_LOAD_KEY, TS_R_CANNOT_LOAD_KEY);
+        ERR_raise(ERR_LIB_TS, TS_R_CANNOT_LOAD_KEY);
     BIO_free(key);
     return pkey;
 }
@@ -112,14 +112,12 @@ EVP_PKEY *TS_CONF_load_key(const char *file, const char *pass)
 
 static void ts_CONF_lookup_fail(const char *name, const char *tag)
 {
-    TSerr(TS_F_TS_CONF_LOOKUP_FAIL, TS_R_VAR_LOOKUP_FAILURE);
-    ERR_add_error_data(3, name, &quot;::&quot;, tag);
+    ERR_raise_data(ERR_LIB_TS, TS_R_VAR_LOOKUP_FAILURE, &quot;%s::%s&quot;, name, tag);
 }
 
 static void ts_CONF_invalid(const char *name, const char *tag)
 {
-    TSerr(TS_F_TS_CONF_INVALID, TS_R_VAR_BAD_VALUE);
-    ERR_add_error_data(3, name, &quot;::&quot;, tag);
+    ERR_raise_data(ERR_LIB_TS, TS_R_VAR_BAD_VALUE, &quot;%s::%s&quot;, name, tag);
 }
 
 const char *TS_CONF_get_tsa_section(CONF *conf, const char *section)
@@ -184,10 +182,9 @@ int TS_CONF_set_default_engine(const char *name)
     ret = 1;
 
  err:
-    if (!ret) {
-        TSerr(TS_F_TS_CONF_SET_DEFAULT_ENGINE, TS_R_COULD_NOT_SET_ENGINE);
-        ERR_add_error_data(2, &quot;engine:&quot;, name);
-    }
+    if (!ret)
+        ERR_raise_data(ERR_LIB_TS, TS_R_COULD_NOT_SET_ENGINE,
+                       &quot;engine:%s&quot;, name);
     ENGINE_free(e);
     return ret;
 }
diff --git a/crypto/ts/ts_req_utils.c b/crypto/ts/ts_req_utils.c
index e4b3eee48f..b560fc7b38 100644
--- a/crypto/ts/ts_req_utils.c
+++ b/crypto/ts/ts_req_utils.c
@@ -32,7 +32,7 @@ int TS_REQ_set_msg_imprint(TS_REQ *a, TS_MSG_IMPRINT *msg_imprint)
         return 1;
     new_msg_imprint = TS_MSG_IMPRINT_dup(msg_imprint);
     if (new_msg_imprint == NULL) {
-        TSerr(TS_F_TS_REQ_SET_MSG_IMPRINT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     TS_MSG_IMPRINT_free(a-&gt;msg_imprint);
@@ -53,7 +53,7 @@ int TS_MSG_IMPRINT_set_algo(TS_MSG_IMPRINT *a, X509_ALGOR *alg)
         return 1;
     new_alg = X509_ALGOR_dup(alg);
     if (new_alg == NULL) {
-        TSerr(TS_F_TS_MSG_IMPRINT_SET_ALGO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     X509_ALGOR_free(a-&gt;hash_algo);
@@ -84,7 +84,7 @@ int TS_REQ_set_policy_id(TS_REQ *a, const ASN1_OBJECT *policy)
         return 1;
     new_policy = OBJ_dup(policy);
     if (new_policy == NULL) {
-        TSerr(TS_F_TS_REQ_SET_POLICY_ID, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ASN1_OBJECT_free(a-&gt;policy_id);
@@ -105,7 +105,7 @@ int TS_REQ_set_nonce(TS_REQ *a, const ASN1_INTEGER *nonce)
         return 1;
     new_nonce = ASN1_INTEGER_dup(nonce);
     if (new_nonce == NULL) {
-        TSerr(TS_F_TS_REQ_SET_NONCE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ASN1_INTEGER_free(a-&gt;nonce);
diff --git a/crypto/ts/ts_rsp_sign.c b/crypto/ts/ts_rsp_sign.c
index 0e139be5b9..9ae584ff12 100644
--- a/crypto/ts/ts_rsp_sign.c
+++ b/crypto/ts/ts_rsp_sign.c
@@ -50,7 +50,7 @@ static ASN1_INTEGER *def_serial_cb(struct TS_resp_ctx *ctx, void *data)
     return serial;
 
  err:
-    TSerr(TS_F_DEF_SERIAL_CB, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
     TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
                                 &quot;Error during serial number generation.&quot;);
     ASN1_INTEGER_free(serial);
@@ -64,7 +64,7 @@ static int def_time_cb(struct TS_resp_ctx *ctx, void *data,
 {
     struct timeval tv;
     if (gettimeofday(&amp;tv, NULL) != 0) {
-        TSerr(TS_F_DEF_TIME_CB, TS_R_TIME_SYSCALL_ERROR);
+        ERR_raise(ERR_LIB_TS, TS_R_TIME_SYSCALL_ERROR);
         TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
                                     &quot;Time is not available.&quot;);
         TS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);
@@ -83,7 +83,7 @@ static int def_time_cb(struct TS_resp_ctx *ctx, void *data,
 {
     time_t t;
     if (time(&amp;t) == (time_t)-1) {
-        TSerr(TS_F_DEF_TIME_CB, TS_R_TIME_SYSCALL_ERROR);
+        ERR_raise(ERR_LIB_TS, TS_R_TIME_SYSCALL_ERROR);
         TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
                                     &quot;Time is not available.&quot;);
         TS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);
@@ -113,7 +113,7 @@ TS_RESP_CTX *TS_RESP_CTX_new(void)
     TS_RESP_CTX *ctx;
 
     if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL) {
-        TSerr(TS_F_TS_RESP_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -146,8 +146,7 @@ void TS_RESP_CTX_free(TS_RESP_CTX *ctx)
 int TS_RESP_CTX_set_signer_cert(TS_RESP_CTX *ctx, X509 *signer)
 {
     if (X509_check_purpose(signer, X509_PURPOSE_TIMESTAMP_SIGN, 0) != 1) {
-        TSerr(TS_F_TS_RESP_CTX_SET_SIGNER_CERT,
-              TS_R_INVALID_SIGNER_CERTIFICATE_PURPOSE);
+        ERR_raise(ERR_LIB_TS, TS_R_INVALID_SIGNER_CERTIFICATE_PURPOSE);
         return 0;
     }
     X509_free(ctx-&gt;signer_cert);
@@ -178,7 +177,7 @@ int TS_RESP_CTX_set_def_policy(TS_RESP_CTX *ctx, const ASN1_OBJECT *def_policy)
         goto err;
     return 1;
  err:
-    TSerr(TS_F_TS_RESP_CTX_SET_DEF_POLICY, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
@@ -190,7 +189,7 @@ int TS_RESP_CTX_set_certs(TS_RESP_CTX *ctx, STACK_OF(X509) *certs)
     if (!certs)
         return 1;
     if ((ctx-&gt;certs = X509_chain_up_ref(certs)) == NULL) {
-        TSerr(TS_F_TS_RESP_CTX_SET_CERTS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
@@ -211,7 +210,7 @@ int TS_RESP_CTX_add_policy(TS_RESP_CTX *ctx, const ASN1_OBJECT *policy)
 
     return 1;
  err:
-    TSerr(TS_F_TS_RESP_CTX_ADD_POLICY, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
     ASN1_OBJECT_free(copy);
     return 0;
 }
@@ -226,7 +225,7 @@ int TS_RESP_CTX_add_md(TS_RESP_CTX *ctx, const EVP_MD *md)
 
     return 1;
  err:
-    TSerr(TS_F_TS_RESP_CTX_ADD_MD, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
@@ -259,7 +258,7 @@ int TS_RESP_CTX_set_accuracy(TS_RESP_CTX *ctx,
     return 1;
  err:
     TS_RESP_CTX_accuracy_free(ctx);
-    TSerr(TS_F_TS_RESP_CTX_SET_ACCURACY, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
@@ -314,7 +313,7 @@ int TS_RESP_CTX_set_status_info(TS_RESP_CTX *ctx,
     ret = 1;
  err:
     if (!ret)
-        TSerr(TS_F_TS_RESP_CTX_SET_STATUS_INFO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
     TS_STATUS_INFO_free(si);
     ASN1_UTF8STRING_free(utf8_text);
     return ret;
@@ -342,7 +341,7 @@ int TS_RESP_CTX_add_failure_info(TS_RESP_CTX *ctx, int failure)
         goto err;
     return 1;
  err:
-    TSerr(TS_F_TS_RESP_CTX_ADD_FAILURE_INFO, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
     return 0;
 }
 
@@ -375,7 +374,7 @@ TS_RESP *TS_RESP_create_response(TS_RESP_CTX *ctx, BIO *req_bio)
     ts_RESP_CTX_init(ctx);
 
     if ((ctx-&gt;response = TS_RESP_new()) == NULL) {
-        TSerr(TS_F_TS_RESP_CREATE_RESPONSE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         goto end;
     }
     if ((ctx-&gt;request = d2i_TS_REQ_bio(req_bio, NULL)) == NULL) {
@@ -400,7 +399,7 @@ TS_RESP *TS_RESP_create_response(TS_RESP_CTX *ctx, BIO *req_bio)
 
  end:
     if (!result) {
-        TSerr(TS_F_TS_RESP_CREATE_RESPONSE, TS_R_RESPONSE_SETUP_ERROR);
+        ERR_raise(ERR_LIB_TS, TS_R_RESPONSE_SETUP_ERROR);
         if (ctx-&gt;response != NULL) {
             if (TS_RESP_CTX_set_status_info_cond(ctx,
                                                  TS_STATUS_REJECTION,
@@ -496,7 +495,7 @@ static ASN1_OBJECT *ts_RESP_get_policy(TS_RESP_CTX *ctx)
     int i;
 
     if (ctx-&gt;default_policy == NULL) {
-        TSerr(TS_F_TS_RESP_GET_POLICY, TS_R_INVALID_NULL_POINTER);
+        ERR_raise(ERR_LIB_TS, TS_R_INVALID_NULL_POINTER);
         return NULL;
     }
     if (!requested || !OBJ_cmp(requested, ctx-&gt;default_policy))
@@ -509,7 +508,7 @@ static ASN1_OBJECT *ts_RESP_get_policy(TS_RESP_CTX *ctx)
             policy = current;
     }
     if (policy == NULL) {
-        TSerr(TS_F_TS_RESP_GET_POLICY, TS_R_UNACCEPTABLE_POLICY);
+        ERR_raise(ERR_LIB_TS, TS_R_UNACCEPTABLE_POLICY);
         TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
                                     &quot;Requested policy is not &quot; &quot;supported.&quot;);
         TS_RESP_CTX_add_failure_info(ctx, TS_INFO_UNACCEPTED_POLICY);
@@ -585,7 +584,7 @@ static TS_TST_INFO *ts_RESP_create_tst_info(TS_RESP_CTX *ctx,
     if (!result) {
         TS_TST_INFO_free(tst_info);
         tst_info = NULL;
-        TSerr(TS_F_TS_RESP_CREATE_TST_INFO, TS_R_TST_INFO_SETUP_ERROR);
+        ERR_raise(ERR_LIB_TS, TS_R_TST_INFO_SETUP_ERROR);
         TS_RESP_CTX_set_status_info_cond(ctx, TS_STATUS_REJECTION,
                                          &quot;Error during TSTInfo &quot;
                                          &quot;generation.&quot;);
@@ -633,12 +632,12 @@ static int ts_RESP_sign(TS_RESP_CTX *ctx)
     int i;
 
     if (!X509_check_private_key(ctx-&gt;signer_cert, ctx-&gt;signer_key)) {
-        TSerr(TS_F_TS_RESP_SIGN, TS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
+        ERR_raise(ERR_LIB_TS, TS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
         goto err;
     }
 
     if ((p7 = PKCS7_new()) == NULL) {
-        TSerr(TS_F_TS_RESP_SIGN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (!PKCS7_set_type(p7, NID_pkcs7_signed))
@@ -658,14 +657,14 @@ static int ts_RESP_sign(TS_RESP_CTX *ctx)
 
     if ((si = PKCS7_add_signature(p7, ctx-&gt;signer_cert,
                                   ctx-&gt;signer_key, ctx-&gt;signer_md)) == NULL) {
-        TSerr(TS_F_TS_RESP_SIGN, TS_R_PKCS7_ADD_SIGNATURE_ERROR);
+        ERR_raise(ERR_LIB_TS, TS_R_PKCS7_ADD_SIGNATURE_ERROR);
         goto err;
     }
 
     oid = OBJ_nid2obj(NID_id_smime_ct_TSTInfo);
     if (!PKCS7_add_signed_attribute(si, NID_pkcs9_contentType,
                                     V_ASN1_OBJECT, oid)) {
-        TSerr(TS_F_TS_RESP_SIGN, TS_R_PKCS7_ADD_SIGNED_ATTR_ERROR);
+        ERR_raise(ERR_LIB_TS, TS_R_PKCS7_ADD_SIGNED_ATTR_ERROR);
         goto err;
     }
 
@@ -676,7 +675,7 @@ static int ts_RESP_sign(TS_RESP_CTX *ctx)
             goto err;
 
         if (!ESS_SIGNING_CERT_add(si, sc)) {
-            TSerr(TS_F_TS_RESP_SIGN, TS_R_ESS_ADD_SIGNING_CERT_ERROR);
+            ERR_raise(ERR_LIB_TS, TS_R_ESS_ADD_SIGNING_CERT_ERROR);
             goto err;
         }
     } else {
@@ -686,7 +685,7 @@ static int ts_RESP_sign(TS_RESP_CTX *ctx)
             goto err;
 
         if (!ESS_SIGNING_CERT_V2_add(si, sc2)) {
-            TSerr(TS_F_TS_RESP_SIGN, TS_R_ESS_ADD_SIGNING_CERT_V2_ERROR);
+            ERR_raise(ERR_LIB_TS, TS_R_ESS_ADD_SIGNING_CERT_V2_ERROR);
             goto err;
         }
     }
@@ -694,15 +693,15 @@ static int ts_RESP_sign(TS_RESP_CTX *ctx)
     if (!ts_TST_INFO_content_new(p7))
         goto err;
     if ((p7bio = PKCS7_dataInit(p7, NULL)) == NULL) {
-        TSerr(TS_F_TS_RESP_SIGN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (!i2d_TS_TST_INFO_bio(p7bio, ctx-&gt;tst_info)) {
-        TSerr(TS_F_TS_RESP_SIGN, TS_R_TS_DATASIGN);
+        ERR_raise(ERR_LIB_TS, TS_R_TS_DATASIGN);
         goto err;
     }
     if (!PKCS7_dataFinal(p7, p7bio)) {
-        TSerr(TS_F_TS_RESP_SIGN, TS_R_TS_DATASIGN);
+        ERR_raise(ERR_LIB_TS, TS_R_TS_DATASIGN);
         goto err;
     }
     TS_RESP_set_tst_info(ctx-&gt;response, p7, ctx-&gt;tst_info);
@@ -813,7 +812,7 @@ static ASN1_GENERALIZEDTIME *TS_RESP_set_genTime_with_precision(
     return asn1_time;
 
  err:
-    TSerr(TS_F_TS_RESP_SET_GENTIME_WITH_PRECISION, TS_R_COULD_NOT_SET_TIME);
+    ERR_raise(ERR_LIB_TS, TS_R_COULD_NOT_SET_TIME);
     return NULL;
 }
 
diff --git a/crypto/ts/ts_rsp_utils.c b/crypto/ts/ts_rsp_utils.c
index 92dcb5bff7..cae076f21a 100644
--- a/crypto/ts/ts_rsp_utils.c
+++ b/crypto/ts/ts_rsp_utils.c
@@ -22,7 +22,7 @@ int TS_RESP_set_status_info(TS_RESP *a, TS_STATUS_INFO *status_info)
         return 1;
     new_status_info = TS_STATUS_INFO_dup(status_info);
     if (new_status_info == NULL) {
-        TSerr(TS_F_TS_RESP_SET_STATUS_INFO, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     TS_STATUS_INFO_free(a-&gt;status_info);
@@ -73,7 +73,7 @@ int TS_TST_INFO_set_policy_id(TS_TST_INFO *a, ASN1_OBJECT *policy)
         return 1;
     new_policy = OBJ_dup(policy);
     if (new_policy == NULL) {
-        TSerr(TS_F_TS_TST_INFO_SET_POLICY_ID, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ASN1_OBJECT_free(a-&gt;policy_id);
@@ -94,7 +94,7 @@ int TS_TST_INFO_set_msg_imprint(TS_TST_INFO *a, TS_MSG_IMPRINT *msg_imprint)
         return 1;
     new_msg_imprint = TS_MSG_IMPRINT_dup(msg_imprint);
     if (new_msg_imprint == NULL) {
-        TSerr(TS_F_TS_TST_INFO_SET_MSG_IMPRINT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     TS_MSG_IMPRINT_free(a-&gt;msg_imprint);
@@ -115,7 +115,7 @@ int TS_TST_INFO_set_serial(TS_TST_INFO *a, const ASN1_INTEGER *serial)
         return 1;
     new_serial = ASN1_INTEGER_dup(serial);
     if (new_serial == NULL) {
-        TSerr(TS_F_TS_TST_INFO_SET_SERIAL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ASN1_INTEGER_free(a-&gt;serial);
@@ -136,7 +136,7 @@ int TS_TST_INFO_set_time(TS_TST_INFO *a, const ASN1_GENERALIZEDTIME *gtime)
         return 1;
     new_time = ASN1_STRING_dup(gtime);
     if (new_time == NULL) {
-        TSerr(TS_F_TS_TST_INFO_SET_TIME, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ASN1_GENERALIZEDTIME_free(a-&gt;time);
@@ -157,7 +157,7 @@ int TS_TST_INFO_set_accuracy(TS_TST_INFO *a, TS_ACCURACY *accuracy)
         return 1;
     new_accuracy = TS_ACCURACY_dup(accuracy);
     if (new_accuracy == NULL) {
-        TSerr(TS_F_TS_TST_INFO_SET_ACCURACY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     TS_ACCURACY_free(a-&gt;accuracy);
@@ -178,7 +178,7 @@ int TS_ACCURACY_set_seconds(TS_ACCURACY *a, const ASN1_INTEGER *seconds)
         return 1;
     new_seconds = ASN1_INTEGER_dup(seconds);
     if (new_seconds == NULL) {
-        TSerr(TS_F_TS_ACCURACY_SET_SECONDS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ASN1_INTEGER_free(a-&gt;seconds);
@@ -200,7 +200,7 @@ int TS_ACCURACY_set_millis(TS_ACCURACY *a, const ASN1_INTEGER *millis)
     if (millis != NULL) {
         new_millis = ASN1_INTEGER_dup(millis);
         if (new_millis == NULL) {
-            TSerr(TS_F_TS_ACCURACY_SET_MILLIS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     }
@@ -223,7 +223,7 @@ int TS_ACCURACY_set_micros(TS_ACCURACY *a, const ASN1_INTEGER *micros)
     if (micros != NULL) {
         new_micros = ASN1_INTEGER_dup(micros);
         if (new_micros == NULL) {
-            TSerr(TS_F_TS_ACCURACY_SET_MICROS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     }
@@ -256,7 +256,7 @@ int TS_TST_INFO_set_nonce(TS_TST_INFO *a, const ASN1_INTEGER *nonce)
         return 1;
     new_nonce = ASN1_INTEGER_dup(nonce);
     if (new_nonce == NULL) {
-        TSerr(TS_F_TS_TST_INFO_SET_NONCE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     ASN1_INTEGER_free(a-&gt;nonce);
@@ -277,7 +277,7 @@ int TS_TST_INFO_set_tsa(TS_TST_INFO *a, GENERAL_NAME *tsa)
         return 1;
     new_tsa = GENERAL_NAME_dup(tsa);
     if (new_tsa == NULL) {
-        TSerr(TS_F_TS_TST_INFO_SET_TSA, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     GENERAL_NAME_free(a-&gt;tsa);
diff --git a/crypto/ts/ts_rsp_verify.c b/crypto/ts/ts_rsp_verify.c
index 69ce5dc806..8e097a3336 100644
--- a/crypto/ts/ts_rsp_verify.c
+++ b/crypto/ts/ts_rsp_verify.c
@@ -98,21 +98,21 @@ int TS_RESP_verify_signature(PKCS7 *token, STACK_OF(X509) *certs,
 
     /* Some sanity checks first. */
     if (!token) {
-        TSerr(TS_F_TS_RESP_VERIFY_SIGNATURE, TS_R_INVALID_NULL_POINTER);
+        ERR_raise(ERR_LIB_TS, TS_R_INVALID_NULL_POINTER);
         goto err;
     }
     if (!PKCS7_type_is_signed(token)) {
-        TSerr(TS_F_TS_RESP_VERIFY_SIGNATURE, TS_R_WRONG_CONTENT_TYPE);
+        ERR_raise(ERR_LIB_TS, TS_R_WRONG_CONTENT_TYPE);
         goto err;
     }
     sinfos = PKCS7_get_signer_info(token);
     if (!sinfos || sk_PKCS7_SIGNER_INFO_num(sinfos) != 1) {
-        TSerr(TS_F_TS_RESP_VERIFY_SIGNATURE, TS_R_THERE_MUST_BE_ONE_SIGNER);
+        ERR_raise(ERR_LIB_TS, TS_R_THERE_MUST_BE_ONE_SIGNER);
         goto err;
     }
     si = sk_PKCS7_SIGNER_INFO_value(sinfos, 0);
     if (PKCS7_get_detached(token)) {
-        TSerr(TS_F_TS_RESP_VERIFY_SIGNATURE, TS_R_NO_CONTENT);
+        ERR_raise(ERR_LIB_TS, TS_R_NO_CONTENT);
         goto err;
     }
 
@@ -137,7 +137,7 @@ int TS_RESP_verify_signature(PKCS7 *token, STACK_OF(X509) *certs,
 
     j = PKCS7_signatureVerify(p7bio, token, si, signer);
     if (j &lt;= 0) {
-        TSerr(TS_F_TS_RESP_VERIFY_SIGNATURE, TS_R_SIGNATURE_FAILURE);
+        ERR_raise(ERR_LIB_TS, TS_R_SIGNATURE_FAILURE);
         goto err;
     }
 
@@ -169,7 +169,7 @@ static int ts_verify_cert(X509_STORE *store, STACK_OF(X509) *untrusted,
     *chain = NULL;
     cert_ctx = X509_STORE_CTX_new();
     if (cert_ctx == NULL) {
-        TSerr(TS_F_TS_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (!X509_STORE_CTX_init(cert_ctx, store, signer, untrusted))
@@ -178,9 +178,8 @@ static int ts_verify_cert(X509_STORE *store, STACK_OF(X509) *untrusted,
     i = X509_verify_cert(cert_ctx);
     if (i &lt;= 0) {
         int j = X509_STORE_CTX_get_error(cert_ctx);
-        TSerr(TS_F_TS_VERIFY_CERT, TS_R_CERTIFICATE_VERIFY_ERROR);
-        ERR_add_error_data(2, &quot;Verify error:&quot;,
-                           X509_verify_cert_error_string(j));
+        ERR_raise_data(ERR_LIB_TS, TS_R_CERTIFICATE_VERIFY_ERROR,
+                       &quot;Verify error:%s&quot;, X509_verify_cert_error_string(j));
         goto err;
     }
     *chain = X509_STORE_CTX_get1_chain(cert_ctx);
@@ -247,8 +246,7 @@ static int ts_check_signing_certs(PKCS7_SIGNER_INFO *si,
     ret = 1;
  err:
     if (!ret)
-        TSerr(TS_F_TS_CHECK_SIGNING_CERTS,
-              TS_R_ESS_SIGNING_CERTIFICATE_ERROR);
+        ERR_raise(ERR_LIB_TS, TS_R_ESS_SIGNING_CERTIFICATE_ERROR);
     ESS_SIGNING_CERT_free(ss);
     ESS_SIGNING_CERT_V2_free(ssv2);
     return ret;
@@ -325,7 +323,7 @@ static int int_ts_RESP_verify_token(TS_VERIFY_CTX *ctx,
         goto err;
     if ((flags &amp; TS_VFY_VERSION)
         &amp;&amp; TS_TST_INFO_get_version(tst_info) != 1) {
-        TSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_UNSUPPORTED_VERSION);
+        ERR_raise(ERR_LIB_TS, TS_R_UNSUPPORTED_VERSION);
         goto err;
     }
     if ((flags &amp; TS_VFY_POLICY)
@@ -345,12 +343,12 @@ static int int_ts_RESP_verify_token(TS_VERIFY_CTX *ctx,
         goto err;
     if ((flags &amp; TS_VFY_SIGNER)
         &amp;&amp; tsa_name &amp;&amp; !ts_check_signer_name(tsa_name, signer)) {
-        TSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_TSA_NAME_MISMATCH);
+        ERR_raise(ERR_LIB_TS, TS_R_TSA_NAME_MISMATCH);
         goto err;
     }
     if ((flags &amp; TS_VFY_TSA_NAME)
         &amp;&amp; !ts_check_signer_name(ctx-&gt;tsa_name, signer)) {
-        TSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_TSA_UNTRUSTED);
+        ERR_raise(ERR_LIB_TS, TS_R_TSA_UNTRUSTED);
         goto err;
     }
     ret = 1;
@@ -401,12 +399,11 @@ static int ts_check_status_info(TS_RESP *response)
     if (failure_text[0] == '\0')
         strcpy(failure_text, &quot;unspecified&quot;);
 
-    TSerr(TS_F_TS_CHECK_STATUS_INFO, TS_R_NO_TIME_STAMP_TOKEN);
-    ERR_add_error_data(6,
-                       &quot;status code: &quot;, status_text,
-                       &quot;, status text: &quot;, embedded_status_text ?
-                       embedded_status_text : &quot;unspecified&quot;,
-                       &quot;, failure codes: &quot;, failure_text);
+    ERR_raise_data(ERR_LIB_TS, TS_R_NO_TIME_STAMP_TOKEN,
+                   &quot;status code: %s, status text: %s, failure codes: %s&quot;,
+                   status_text,
+                   embedded_status_text ? embedded_status_text : &quot;unspecified&quot;,
+                   failure_text);
     OPENSSL_free(embedded_status_text);
 
     return 0;
@@ -423,7 +420,7 @@ static int ts_check_policy(const ASN1_OBJECT *req_oid,
     const ASN1_OBJECT *resp_oid = tst_info-&gt;policy_id;
 
     if (OBJ_cmp(req_oid, resp_oid) != 0) {
-        TSerr(TS_F_TS_CHECK_POLICY, TS_R_POLICY_MISMATCH);
+        ERR_raise(ERR_LIB_TS, TS_R_POLICY_MISMATCH);
         return 0;
     }
 
@@ -447,7 +444,7 @@ static int ts_compute_imprint(BIO *data, TS_TST_INFO *tst_info,
     if ((*md_alg = X509_ALGOR_dup(md_alg_resp)) == NULL)
         goto err;
     if ((md = EVP_get_digestbyobj((*md_alg)-&gt;algorithm)) == NULL) {
-        TSerr(TS_F_TS_COMPUTE_IMPRINT, TS_R_UNSUPPORTED_MD_ALGORITHM);
+        ERR_raise(ERR_LIB_TS, TS_R_UNSUPPORTED_MD_ALGORITHM);
         goto err;
     }
     length = EVP_MD_size(md);
@@ -455,13 +452,13 @@ static int ts_compute_imprint(BIO *data, TS_TST_INFO *tst_info,
         goto err;
     *imprint_len = length;
     if ((*imprint = OPENSSL_malloc(*imprint_len)) == NULL) {
-        TSerr(TS_F_TS_COMPUTE_IMPRINT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     md_ctx = EVP_MD_CTX_new();
     if (md_ctx == NULL) {
-        TSerr(TS_F_TS_COMPUTE_IMPRINT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (!EVP_DigestInit(md_ctx, md))
@@ -508,7 +505,7 @@ static int ts_check_imprints(X509_ALGOR *algor_a,
         memcmp(imprint_a, ASN1_STRING_get0_data(b-&gt;hashed_msg), len_a) == 0;
  err:
     if (!ret)
-        TSerr(TS_F_TS_CHECK_IMPRINTS, TS_R_MESSAGE_IMPRINT_MISMATCH);
+        ERR_raise(ERR_LIB_TS, TS_R_MESSAGE_IMPRINT_MISMATCH);
     return ret;
 }
 
@@ -517,13 +514,13 @@ static int ts_check_nonces(const ASN1_INTEGER *a, TS_TST_INFO *tst_info)
     const ASN1_INTEGER *b = tst_info-&gt;nonce;
 
     if (!b) {
-        TSerr(TS_F_TS_CHECK_NONCES, TS_R_NONCE_NOT_RETURNED);
+        ERR_raise(ERR_LIB_TS, TS_R_NONCE_NOT_RETURNED);
         return 0;
     }
 
     /* No error if a nonce is returned without being requested. */
     if (ASN1_INTEGER_cmp(a, b) != 0) {
-        TSerr(TS_F_TS_CHECK_NONCES, TS_R_NONCE_MISMATCH);
+        ERR_raise(ERR_LIB_TS, TS_R_NONCE_MISMATCH);
         return 0;
     }
 
diff --git a/crypto/ts/ts_verify_ctx.c b/crypto/ts/ts_verify_ctx.c
index 776d5cf43e..825d53e4f7 100644
--- a/crypto/ts/ts_verify_ctx.c
+++ b/crypto/ts/ts_verify_ctx.c
@@ -17,7 +17,7 @@ TS_VERIFY_CTX *TS_VERIFY_CTX_new(void)
     TS_VERIFY_CTX *ctx = OPENSSL_zalloc(sizeof(*ctx));
 
     if (ctx == NULL)
-        TSerr(TS_F_TS_VERIFY_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_TS, ERR_R_MALLOC_FAILURE);
     return ctx;
 }
 
diff --git a/crypto/ui/ui_lib.c b/crypto/ui/ui_lib.c
index af6461fb15..fd03dc6cd0 100644
--- a/crypto/ui/ui_lib.c
+++ b/crypto/ui/ui_lib.c
@@ -25,13 +25,13 @@ UI *UI_new_method(const UI_METHOD *method)
     UI *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        UIerr(UI_F_UI_NEW_METHOD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        UIerr(UI_F_UI_NEW_METHOD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(ret);
         return NULL;
     }
@@ -102,10 +102,10 @@ static UI_STRING *general_allocate_prompt(UI *ui, const char *prompt,
     UI_STRING *ret = NULL;
 
     if (prompt == NULL) {
-        UIerr(UI_F_GENERAL_ALLOCATE_PROMPT, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_UI, ERR_R_PASSED_NULL_PARAMETER);
     } else if ((type == UIT_PROMPT || type == UIT_VERIFY
                 || type == UIT_BOOLEAN) &amp;&amp; result_buf == NULL) {
-        UIerr(UI_F_GENERAL_ALLOCATE_PROMPT, UI_R_NO_RESULT_BUFFER);
+        ERR_raise(ERR_LIB_UI, UI_R_NO_RESULT_BUFFER);
     } else if ((ret = OPENSSL_zalloc(sizeof(*ret))) != NULL) {
         ret-&gt;out_string = prompt;
         ret-&gt;flags = prompt_freeable ? OUT_STRING_FREEABLE : 0;
@@ -157,14 +157,13 @@ static int general_allocate_boolean(UI *ui,
     const char *p;
 
     if (ok_chars == NULL) {
-        UIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_UI, ERR_R_PASSED_NULL_PARAMETER);
     } else if (cancel_chars == NULL) {
-        UIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_UI, ERR_R_PASSED_NULL_PARAMETER);
     } else {
         for (p = ok_chars; *p != '\0'; p++) {
             if (strchr(cancel_chars, *p) != NULL) {
-                UIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,
-                      UI_R_COMMON_OK_AND_CANCEL_CHARACTERS);
+                ERR_raise(ERR_LIB_UI, UI_R_COMMON_OK_AND_CANCEL_CHARACTERS);
             }
         }
 
@@ -212,7 +211,7 @@ int UI_dup_input_string(UI *ui, const char *prompt, int flags,
     if (prompt != NULL) {
         prompt_copy = OPENSSL_strdup(prompt);
         if (prompt_copy == NULL) {
-            UIerr(UI_F_UI_DUP_INPUT_STRING, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
             return 0;
         }
     }
@@ -240,7 +239,7 @@ int UI_dup_verify_string(UI *ui, const char *prompt, int flags,
     if (prompt != NULL) {
         prompt_copy = OPENSSL_strdup(prompt);
         if (prompt_copy == NULL) {
-            UIerr(UI_F_UI_DUP_VERIFY_STRING, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
             return -1;
         }
     }
@@ -271,7 +270,7 @@ int UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,
     if (prompt != NULL) {
         prompt_copy = OPENSSL_strdup(prompt);
         if (prompt_copy == NULL) {
-            UIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -279,7 +278,7 @@ int UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,
     if (action_desc != NULL) {
         action_desc_copy = OPENSSL_strdup(action_desc);
         if (action_desc_copy == NULL) {
-            UIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -287,7 +286,7 @@ int UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,
     if (ok_chars != NULL) {
         ok_chars_copy = OPENSSL_strdup(ok_chars);
         if (ok_chars_copy == NULL) {
-            UIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -295,7 +294,7 @@ int UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,
     if (cancel_chars != NULL) {
         cancel_chars_copy = OPENSSL_strdup(cancel_chars);
         if (cancel_chars_copy == NULL) {
-            UIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -324,7 +323,7 @@ int UI_dup_info_string(UI *ui, const char *text)
     if (text != NULL) {
         text_copy = OPENSSL_strdup(text);
         if (text_copy == NULL) {
-            UIerr(UI_F_UI_DUP_INFO_STRING, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
             return -1;
         }
     }
@@ -346,7 +345,7 @@ int UI_dup_error_string(UI *ui, const char *text)
     if (text != NULL) {
         text_copy = OPENSSL_strdup(text);
         if (text_copy == NULL) {
-            UIerr(UI_F_UI_DUP_ERROR_STRING, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
             return -1;
         }
     }
@@ -375,7 +374,7 @@ char *UI_construct_prompt(UI *ui, const char *phrase_desc,
         len += sizeof(prompt3) - 1;
 
         if ((prompt = OPENSSL_malloc(len + 1)) == NULL) {
-            UIerr(UI_F_UI_CONSTRUCT_PROMPT, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
         OPENSSL_strlcpy(prompt, prompt1, len + 1);
@@ -408,13 +407,13 @@ int UI_dup_user_data(UI *ui, void *user_data)
 
     if (ui-&gt;meth-&gt;ui_duplicate_data == NULL
         || ui-&gt;meth-&gt;ui_destroy_data == NULL) {
-        UIerr(UI_F_UI_DUP_USER_DATA, UI_R_USER_DATA_DUPLICATION_UNSUPPORTED);
+        ERR_raise(ERR_LIB_UI, UI_R_USER_DATA_DUPLICATION_UNSUPPORTED);
         return -1;
     }
 
     duplicate = ui-&gt;meth-&gt;ui_duplicate_data(ui, user_data);
     if (duplicate == NULL) {
-        UIerr(UI_F_UI_DUP_USER_DATA, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
@@ -432,11 +431,11 @@ void *UI_get0_user_data(UI *ui)
 const char *UI_get0_result(UI *ui, int i)
 {
     if (i &lt; 0) {
-        UIerr(UI_F_UI_GET0_RESULT, UI_R_INDEX_TOO_SMALL);
+        ERR_raise(ERR_LIB_UI, UI_R_INDEX_TOO_SMALL);
         return NULL;
     }
     if (i &gt;= sk_UI_STRING_num(ui-&gt;strings)) {
-        UIerr(UI_F_UI_GET0_RESULT, UI_R_INDEX_TOO_LARGE);
+        ERR_raise(ERR_LIB_UI, UI_R_INDEX_TOO_LARGE);
         return NULL;
     }
     return UI_get0_result_string(sk_UI_STRING_value(ui-&gt;strings, i));
@@ -445,11 +444,11 @@ const char *UI_get0_result(UI *ui, int i)
 int UI_get_result_length(UI *ui, int i)
 {
     if (i &lt; 0) {
-        UIerr(UI_F_UI_GET_RESULT_LENGTH, UI_R_INDEX_TOO_SMALL);
+        ERR_raise(ERR_LIB_UI, UI_R_INDEX_TOO_SMALL);
         return -1;
     }
     if (i &gt;= sk_UI_STRING_num(ui-&gt;strings)) {
-        UIerr(UI_F_UI_GET_RESULT_LENGTH, UI_R_INDEX_TOO_LARGE);
+        ERR_raise(ERR_LIB_UI, UI_R_INDEX_TOO_LARGE);
         return -1;
     }
     return UI_get_result_string_length(sk_UI_STRING_value(ui-&gt;strings, i));
@@ -541,17 +540,15 @@ int UI_process(UI *ui)
         ok = -1;
     }
 
-    if (ok == -1) {
-        UIerr(UI_F_UI_PROCESS, UI_R_PROCESSING_ERROR);
-        ERR_add_error_data(2, &quot;while &quot;, state);
-    }
+    if (ok == -1)
+        ERR_raise_data(ERR_LIB_UI, UI_R_PROCESSING_ERROR, &quot;while %s&quot;, state);
     return ok;
 }
 
 int UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f) (void))
 {
     if (ui == NULL) {
-        UIerr(UI_F_UI_CTRL, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_UI, ERR_R_PASSED_NULL_PARAMETER);
         return -1;
     }
     switch (cmd) {
@@ -569,7 +566,7 @@ int UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f) (void))
     default:
         break;
     }
-    UIerr(UI_F_UI_CTRL, UI_R_UNKNOWN_CONTROL_COMMAND);
+    ERR_raise(ERR_LIB_UI, UI_R_UNKNOWN_CONTROL_COMMAND);
     return -1;
 }
 
@@ -605,7 +602,7 @@ UI_METHOD *UI_create_method(const char *name)
         if (ui_method)
             OPENSSL_free(ui_method-&gt;name);
         OPENSSL_free(ui_method);
-        UIerr(UI_F_UI_CREATE_METHOD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_UI, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     return ui_method;
@@ -882,33 +879,25 @@ int UI_set_result_ex(UI *ui, UI_STRING *uis, const char *result, int len)
     switch (uis-&gt;type) {
     case UIT_PROMPT:
     case UIT_VERIFY:
-        {
-            char number1[DECIMAL_SIZE(uis-&gt;_.string_data.result_minsize) + 1];
-            char number2[DECIMAL_SIZE(uis-&gt;_.string_data.result_maxsize) + 1];
-
-            BIO_snprintf(number1, sizeof(number1), &quot;%d&quot;,
-                         uis-&gt;_.string_data.result_minsize);
-            BIO_snprintf(number2, sizeof(number2), &quot;%d&quot;,
-                         uis-&gt;_.string_data.result_maxsize);
-
-            if (len &lt; uis-&gt;_.string_data.result_minsize) {
-                ui-&gt;flags |= UI_FLAG_REDOABLE;
-                UIerr(UI_F_UI_SET_RESULT_EX, UI_R_RESULT_TOO_SMALL);
-                ERR_add_error_data(5, &quot;You must type in &quot;,
-                                   number1, &quot; to &quot;, number2, &quot; characters&quot;);
-                return -1;
-            }
-            if (len &gt; uis-&gt;_.string_data.result_maxsize) {
-                ui-&gt;flags |= UI_FLAG_REDOABLE;
-                UIerr(UI_F_UI_SET_RESULT_EX, UI_R_RESULT_TOO_LARGE);
-                ERR_add_error_data(5, &quot;You must type in &quot;,
-                                   number1, &quot; to &quot;, number2, &quot; characters&quot;);
-                return -1;
-            }
+        if (len &lt; uis-&gt;_.string_data.result_minsize) {
+            ui-&gt;flags |= UI_FLAG_REDOABLE;
+            ERR_raise_data(ERR_LIB_UI, UI_R_RESULT_TOO_SMALL,
+                           &quot;You must type in %d to %d characters&quot;,
+                           uis-&gt;_.string_data.result_minsize,
+                           uis-&gt;_.string_data.result_maxsize);
+            return -1;
+        }
+        if (len &gt; uis-&gt;_.string_data.result_maxsize) {
+            ui-&gt;flags |= UI_FLAG_REDOABLE;
+            ERR_raise_data(ERR_LIB_UI, UI_R_RESULT_TOO_LARGE,
+                           &quot;You must type in %d to %d characters&quot;,
+                           uis-&gt;_.string_data.result_minsize,
+                           uis-&gt;_.string_data.result_maxsize);
+            return -1;
         }
 
         if (uis-&gt;result_buf == NULL) {
-            UIerr(UI_F_UI_SET_RESULT_EX, UI_R_NO_RESULT_BUFFER);
+            ERR_raise(ERR_LIB_UI, UI_R_NO_RESULT_BUFFER);
             return -1;
         }
 
@@ -922,7 +911,7 @@ int UI_set_result_ex(UI *ui, UI_STRING *uis, const char *result, int len)
             const char *p;
 
             if (uis-&gt;result_buf == NULL) {
-                UIerr(UI_F_UI_SET_RESULT_EX, UI_R_NO_RESULT_BUFFER);
+                ERR_raise(ERR_LIB_UI, UI_R_NO_RESULT_BUFFER);
                 return -1;
             }
 
diff --git a/crypto/ui/ui_openssl.c b/crypto/ui/ui_openssl.c
index 78b88c07f1..0a38658c72 100644
--- a/crypto/ui/ui_openssl.c
+++ b/crypto/ui/ui_openssl.c
@@ -451,15 +451,12 @@ static int open_console(UI *ui)
              * which seems appropriate.
              */
         if (errno == ENODEV)
-            is_a_tty = 0;
+                is_a_tty = 0;
         else
 #  endif
             {
-                char tmp_num[10];
-                BIO_snprintf(tmp_num, sizeof(tmp_num) - 1, &quot;%d&quot;, errno);
-                UIerr(UI_F_OPEN_CONSOLE, UI_R_UNKNOWN_TTYGET_ERRNO_VALUE);
-                ERR_add_error_data(2, &quot;errno=&quot;, tmp_num);
-
+                ERR_raise_data(ERR_LIB_UI, UI_R_UNKNOWN_TTYGET_ERRNO_VALUE,
+                               &quot;errno=%d&quot;, errno);
                 return 0;
             }
     }
@@ -469,11 +466,8 @@ static int open_console(UI *ui)
 
     /* if there isn't a TT device, something is very wrong */
     if (status != SS$_NORMAL) {
-        char tmp_num[12];
-
-        BIO_snprintf(tmp_num, sizeof(tmp_num) - 1, &quot;%%X%08X&quot;, status);
-        UIerr(UI_F_OPEN_CONSOLE, UI_R_SYSASSIGN_ERROR);
-        ERR_add_error_data(2, &quot;status=&quot;, tmp_num);
+        ERR_raise_data(ERR_LIB_UI, UI_R_SYSASSIGN_ERROR,
+                       &quot;status=%%X%08X&quot;, status);
         return 0;
     }
 
@@ -506,15 +500,9 @@ static int noecho_console(UI *ui)
         status = sys$qiow(0, channel, IO$_SETMODE, &amp;iosb, 0, 0, tty_new, 12,
                           0, 0, 0, 0);
         if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL)) {
-            char tmp_num[2][12];
-
-            BIO_snprintf(tmp_num[0], sizeof(tmp_num[0]) - 1, &quot;%%X%08X&quot;,
-                         status);
-            BIO_snprintf(tmp_num[1], sizeof(tmp_num[1]) - 1, &quot;%%X%08X&quot;,
-                         iosb.iosb$w_value);
-            UIerr(UI_F_NOECHO_CONSOLE, UI_R_SYSQIOW_ERROR);
-            ERR_add_error_data(5, &quot;status=&quot;, tmp_num[0],
-                               &quot;,&quot;, &quot;iosb.iosb$w_value=&quot;, tmp_num[1]);
+            ERR_raise_data(ERR_LIB_UI, UI_R_SYSQIOW_ERROR,
+                           &quot;status=%%X%08X, iosb.iosb$w_value=%%X%08X&quot;,
+                           status, iosb.iosb$w_value);
             return 0;
         }
     }
@@ -544,15 +532,9 @@ static int echo_console(UI *ui)
         status = sys$qiow(0, channel, IO$_SETMODE, &amp;iosb, 0, 0, tty_new, 12,
                           0, 0, 0, 0);
         if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL)) {
-            char tmp_num[2][12];
-
-            BIO_snprintf(tmp_num[0], sizeof(tmp_num[0]) - 1, &quot;%%X%08X&quot;,
-                         status);
-            BIO_snprintf(tmp_num[1], sizeof(tmp_num[1]) - 1, &quot;%%X%08X&quot;,
-                         iosb.iosb$w_value);
-            UIerr(UI_F_ECHO_CONSOLE, UI_R_SYSQIOW_ERROR);
-            ERR_add_error_data(5, &quot;status=&quot;, tmp_num[0],
-                               &quot;,&quot;, &quot;iosb.iosb$w_value=&quot;, tmp_num[1]);
+            ERR_raise_data(ERR_LIB_UI, UI_R_SYSQIOW_ERROR,
+                           &quot;status=%%X%08X, iosb.iosb$w_value=%%X%08X&quot;,
+                           status, iosb.iosb$w_value);
             return 0;
         }
     }
@@ -575,11 +557,8 @@ static int close_console(UI *ui)
 # ifdef OPENSSL_SYS_VMS
     status = sys$dassgn(channel);
     if (status != SS$_NORMAL) {
-        char tmp_num[12];
-
-        BIO_snprintf(tmp_num, sizeof(tmp_num) - 1, &quot;%%X%08X&quot;, status);
-        UIerr(UI_F_CLOSE_CONSOLE, UI_R_SYSDASSGN_ERROR);
-        ERR_add_error_data(2, &quot;status=&quot;, tmp_num);
+        ERR_raise_data(ERR_LIB_UI, UI_R_SYSDASSGN_ERROR,
+                       &quot;status=%%X%08X&quot;, status);
         return 0;
     }
 # endif
diff --git a/crypto/x509/by_dir.c b/crypto/x509/by_dir.c
index b67b6c5648..a13aa82403 100644
--- a/crypto/x509/by_dir.c
+++ b/crypto/x509/by_dir.c
@@ -87,7 +87,7 @@ static int dir_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,
                 ret = add_cert_dir(ld, X509_get_default_cert_dir(),
                                    X509_FILETYPE_PEM);
             if (!ret) {
-                X509err(X509_F_DIR_CTRL, X509_R_LOADING_CERT_DIR);
+                ERR_raise(ERR_LIB_X509, X509_R_LOADING_CERT_DIR);
             }
         } else
             ret = add_cert_dir(ld, argp, (int)argl);
@@ -101,19 +101,19 @@ static int new_dir(X509_LOOKUP *lu)
     BY_DIR *a = OPENSSL_malloc(sizeof(*a));
 
     if (a == NULL) {
-        X509err(X509_F_NEW_DIR, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
     if ((a-&gt;buffer = BUF_MEM_new()) == NULL) {
-        X509err(X509_F_NEW_DIR, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     a-&gt;dirs = NULL;
     a-&gt;lock = CRYPTO_THREAD_lock_new();
     if (a-&gt;lock == NULL) {
         BUF_MEM_free(a-&gt;buffer);
-        X509err(X509_F_NEW_DIR, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     lu-&gt;method_data = a;
@@ -163,7 +163,7 @@ static int add_cert_dir(BY_DIR *ctx, const char *dir, int type)
     const char *s, *ss, *p;
 
     if (dir == NULL || *dir == '\0') {
-        X509err(X509_F_ADD_CERT_DIR, X509_R_INVALID_DIRECTORY);
+        ERR_raise(ERR_LIB_X509, X509_R_INVALID_DIRECTORY);
         return 0;
     }
 
@@ -188,13 +188,13 @@ static int add_cert_dir(BY_DIR *ctx, const char *dir, int type)
             if (ctx-&gt;dirs == NULL) {
                 ctx-&gt;dirs = sk_BY_DIR_ENTRY_new_null();
                 if (!ctx-&gt;dirs) {
-                    X509err(X509_F_ADD_CERT_DIR, ERR_R_MALLOC_FAILURE);
+                    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
                     return 0;
                 }
             }
             ent = OPENSSL_malloc(sizeof(*ent));
             if (ent == NULL) {
-                X509err(X509_F_ADD_CERT_DIR, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
             ent-&gt;dir_type = type;
@@ -206,7 +206,7 @@ static int add_cert_dir(BY_DIR *ctx, const char *dir, int type)
             }
             if (!sk_BY_DIR_ENTRY_push(ctx-&gt;dirs, ent)) {
                 by_dir_entry_free(ent);
-                X509err(X509_F_ADD_CERT_DIR, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
         }
@@ -243,12 +243,12 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
         stmp.data.crl = &amp;data.crl;
         postfix = &quot;r&quot;;
     } else {
-        X509err(0, X509_R_WRONG_LOOKUP_TYPE);
+        ERR_raise(ERR_LIB_X509, X509_R_WRONG_LOOKUP_TYPE);
         goto finish;
     }
 
     if ((b = BUF_MEM_new()) == NULL) {
-        X509err(0, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);
         goto finish;
     }
 
@@ -263,7 +263,7 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
         ent = sk_BY_DIR_ENTRY_value(ctx-&gt;dirs, i);
         j = strlen(ent-&gt;dir) + 1 + 8 + 6 + 1 + 1;
         if (!BUF_MEM_grow(b, j)) {
-            X509err(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             goto finish;
         }
         if (type == X509_LU_CRL &amp;&amp; ent-&gt;hashes) {
@@ -360,7 +360,7 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
                 hent = OPENSSL_malloc(sizeof(*hent));
                 if (hent == NULL) {
                     CRYPTO_THREAD_unlock(ctx-&gt;lock);
-                    X509err(0, ERR_R_MALLOC_FAILURE);
+                    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
                     ok = 0;
                     goto finish;
                 }
@@ -369,7 +369,7 @@ static int get_cert_by_subject_ex(X509_LOOKUP *xl, X509_LOOKUP_TYPE type,
                 if (!sk_BY_DIR_HASH_push(ent-&gt;hashes, hent)) {
                     CRYPTO_THREAD_unlock(ctx-&gt;lock);
                     OPENSSL_free(hent);
-                    X509err(0, ERR_R_MALLOC_FAILURE);
+                    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
                     ok = 0;
                     goto finish;
                 }
diff --git a/crypto/x509/by_file.c b/crypto/x509/by_file.c
index 16d2971731..eed902b649 100644
--- a/crypto/x509/by_file.c
+++ b/crypto/x509/by_file.c
@@ -65,7 +65,7 @@ static int by_file_ctrl_ex(X509_LOOKUP *ctx, int cmd, const char *argp,
                          X509_FILETYPE_PEM, libctx, propq) != 0);
 
             if (!ok) {
-                X509err(0, X509_R_LOADING_DEFAULTS);
+                ERR_raise(ERR_LIB_X509, X509_R_LOADING_DEFAULTS);
             }
         } else {
             if (argl == X509_FILETYPE_PEM)
@@ -97,17 +97,17 @@ int X509_load_cert_file_ex(X509_LOOKUP *ctx, const char *file, int type,
     in = BIO_new(BIO_s_file());
 
     if ((in == NULL) || (BIO_read_filename(in, file) &lt;= 0)) {
-        X509err(0, ERR_R_SYS_LIB);
+        ERR_raise(ERR_LIB_X509, ERR_R_SYS_LIB);
         goto err;
     }
 
     if (type != X509_FILETYPE_PEM &amp;&amp; type != X509_FILETYPE_ASN1) {
-        X509err(0, X509_R_BAD_X509_FILETYPE);
+        ERR_raise(ERR_LIB_X509, X509_R_BAD_X509_FILETYPE);
         goto err;
     }
     x = X509_new_ex(libctx, propq);
     if (x == NULL) {
-        X509err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -119,7 +119,7 @@ int X509_load_cert_file_ex(X509_LOOKUP *ctx, const char *file, int type,
                     ERR_clear_error();
                     break;
                 } else {
-                    X509err(0, ERR_R_PEM_LIB);
+                    ERR_raise(ERR_LIB_X509, ERR_R_PEM_LIB);
                     goto err;
                 }
             }
@@ -133,7 +133,7 @@ int X509_load_cert_file_ex(X509_LOOKUP *ctx, const char *file, int type,
         ret = count;
     } else if (type == X509_FILETYPE_ASN1) {
         if (d2i_X509_bio(in, &amp;x) == NULL) {
-            X509err(0, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_X509, ERR_R_ASN1_LIB);
             goto err;
         }
         i = X509_STORE_add_cert(ctx-&gt;store_ctx, x);
@@ -142,7 +142,7 @@ int X509_load_cert_file_ex(X509_LOOKUP *ctx, const char *file, int type,
         ret = i;
     }
     if (ret == 0)
-        X509err(0, X509_R_NO_CERTIFICATE_FOUND);
+        ERR_raise(ERR_LIB_X509, X509_R_NO_CERTIFICATE_FOUND);
  err:
     X509_free(x);
     BIO_free(in);
@@ -164,7 +164,7 @@ int X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type)
     in = BIO_new(BIO_s_file());
 
     if ((in == NULL) || (BIO_read_filename(in, file) &lt;= 0)) {
-        X509err(X509_F_X509_LOAD_CRL_FILE, ERR_R_SYS_LIB);
+        ERR_raise(ERR_LIB_X509, ERR_R_SYS_LIB);
         goto err;
     }
 
@@ -177,7 +177,7 @@ int X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type)
                     ERR_clear_error();
                     break;
                 } else {
-                    X509err(X509_F_X509_LOAD_CRL_FILE, ERR_R_PEM_LIB);
+                    ERR_raise(ERR_LIB_X509, ERR_R_PEM_LIB);
                     goto err;
                 }
             }
@@ -192,7 +192,7 @@ int X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type)
     } else if (type == X509_FILETYPE_ASN1) {
         x = d2i_X509_CRL_bio(in, NULL);
         if (x == NULL) {
-            X509err(X509_F_X509_LOAD_CRL_FILE, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_X509, ERR_R_ASN1_LIB);
             goto err;
         }
         i = X509_STORE_add_crl(ctx-&gt;store_ctx, x);
@@ -200,11 +200,11 @@ int X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type)
             goto err;
         ret = i;
     } else {
-        X509err(X509_F_X509_LOAD_CRL_FILE, X509_R_BAD_X509_FILETYPE);
+        ERR_raise(ERR_LIB_X509, X509_R_BAD_X509_FILETYPE);
         goto err;
     }
     if (ret == 0)
-        X509err(X509_F_X509_LOAD_CRL_FILE, X509_R_NO_CRL_FOUND);
+        ERR_raise(ERR_LIB_X509, X509_R_NO_CRL_FOUND);
  err:
     X509_CRL_free(x);
     BIO_free(in);
@@ -223,13 +223,13 @@ int X509_load_cert_crl_file_ex(X509_LOOKUP *ctx, const char *file, int type,
         return X509_load_cert_file_ex(ctx, file, type, libctx, propq);
     in = BIO_new_file(file, &quot;r&quot;);
     if (!in) {
-        X509err(0, ERR_R_SYS_LIB);
+        ERR_raise(ERR_LIB_X509, ERR_R_SYS_LIB);
         return 0;
     }
     inf = PEM_X509_INFO_read_bio_ex(in, NULL, NULL, &quot;&quot;, libctx, propq);
     BIO_free(in);
     if (!inf) {
-        X509err(0, ERR_R_PEM_LIB);
+        ERR_raise(ERR_LIB_X509, ERR_R_PEM_LIB);
         return 0;
     }
     for (i = 0; i &lt; sk_X509_INFO_num(inf); i++) {
@@ -246,7 +246,7 @@ int X509_load_cert_crl_file_ex(X509_LOOKUP *ctx, const char *file, int type,
         }
     }
     if (count == 0)
-        X509err(0, X509_R_NO_CERTIFICATE_OR_CRL_FOUND);
+        ERR_raise(ERR_LIB_X509, X509_R_NO_CERTIFICATE_OR_CRL_FOUND);
  err:
     sk_X509_INFO_pop_free(inf, X509_INFO_free);
     return count;
diff --git a/crypto/x509/pcy_cache.c b/crypto/x509/pcy_cache.c
index 608ccfeb1c..cc7aaba1e9 100644
--- a/crypto/x509/pcy_cache.c
+++ b/crypto/x509/pcy_cache.c
@@ -35,14 +35,14 @@ static int policy_cache_create(X509 *x,
         goto bad_policy;
     cache-&gt;data = sk_X509_POLICY_DATA_new(policy_data_cmp);
     if (cache-&gt;data == NULL) {
-        X509V3err(X509V3_F_POLICY_CACHE_CREATE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         goto just_cleanup;
     }
     for (i = 0; i &lt; num; i++) {
         policy = sk_POLICYINFO_value(policies, i);
         data = policy_data_new(policy, NULL, crit);
         if (data == NULL) {
-            X509V3err(X509V3_F_POLICY_CACHE_CREATE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto just_cleanup;
         }
         /*
@@ -58,7 +58,7 @@ static int policy_cache_create(X509 *x,
             ret = -1;
             goto bad_policy;
         } else if (!sk_X509_POLICY_DATA_push(cache-&gt;data, data)) {
-            X509V3err(X509V3_F_POLICY_CACHE_CREATE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto bad_policy;
         }
         data = NULL;
@@ -91,7 +91,7 @@ static int policy_cache_new(X509 *x)
         return 1;
     cache = OPENSSL_malloc(sizeof(*cache));
     if (cache == NULL) {
-        X509V3err(X509V3_F_POLICY_CACHE_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     cache-&gt;anyPolicy = NULL;
diff --git a/crypto/x509/pcy_data.c b/crypto/x509/pcy_data.c
index 9499f94dff..584ac1c2dd 100644
--- a/crypto/x509/pcy_data.c
+++ b/crypto/x509/pcy_data.c
@@ -52,14 +52,14 @@ X509_POLICY_DATA *policy_data_new(POLICYINFO *policy,
     ret = OPENSSL_zalloc(sizeof(*ret));
     if (ret == NULL) {
         ASN1_OBJECT_free(id);
-        X509V3err(X509V3_F_POLICY_DATA_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;expected_policy_set = sk_ASN1_OBJECT_new_null();
     if (ret-&gt;expected_policy_set == NULL) {
         OPENSSL_free(ret);
         ASN1_OBJECT_free(id);
-        X509V3err(X509V3_F_POLICY_DATA_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/x509/pcy_node.c b/crypto/x509/pcy_node.c
index d2b43814bd..75207e0a10 100644
--- a/crypto/x509/pcy_node.c
+++ b/crypto/x509/pcy_node.c
@@ -65,7 +65,7 @@ X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,
 
     node = OPENSSL_zalloc(sizeof(*node));
     if (node == NULL) {
-        X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     node-&gt;data = data;
@@ -80,11 +80,11 @@ X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,
             if (level-&gt;nodes == NULL)
                 level-&gt;nodes = policy_node_cmp_new();
             if (level-&gt;nodes == NULL) {
-                X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 goto node_error;
             }
             if (!sk_X509_POLICY_NODE_push(level-&gt;nodes, node)) {
-                X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 goto node_error;
             }
         }
@@ -94,11 +94,11 @@ X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,
         if (tree-&gt;extra_data == NULL)
             tree-&gt;extra_data = sk_X509_POLICY_DATA_new_null();
         if (tree-&gt;extra_data == NULL){
-            X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto node_error;
         }
         if (!sk_X509_POLICY_DATA_push(tree-&gt;extra_data, data)) {
-            X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto node_error;
         }
     }
diff --git a/crypto/x509/pcy_tree.c b/crypto/x509/pcy_tree.c
index 3ee30745d2..12cfb627fe 100644
--- a/crypto/x509/pcy_tree.c
+++ b/crypto/x509/pcy_tree.c
@@ -159,7 +159,7 @@ static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,
 
     /* If we get this far initialize the tree */
     if ((tree = OPENSSL_zalloc(sizeof(*tree))) == NULL) {
-        X509V3err(X509V3_F_TREE_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return X509_PCY_TREE_INTERNAL;
     }
 
@@ -172,7 +172,7 @@ static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,
      */
     if ((tree-&gt;levels = OPENSSL_zalloc(sizeof(*tree-&gt;levels)*(n+1))) == NULL) {
         OPENSSL_free(tree);
-        X509V3err(X509V3_F_TREE_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return X509_PCY_TREE_INTERNAL;
     }
     tree-&gt;nlevel = n+1;
diff --git a/crypto/x509/t_crl.c b/crypto/x509/t_crl.c
index 44be2f237b..b9bffbb0c6 100644
--- a/crypto/x509/t_crl.c
+++ b/crypto/x509/t_crl.c
@@ -22,7 +22,7 @@ int X509_CRL_print_fp(FILE *fp, X509_CRL *x)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        X509err(X509_F_X509_CRL_PRINT_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
diff --git a/crypto/x509/t_req.c b/crypto/x509/t_req.c
index abcca0a8f5..1f50a0a1e2 100644
--- a/crypto/x509/t_req.c
+++ b/crypto/x509/t_req.c
@@ -24,7 +24,7 @@ int X509_REQ_print_fp(FILE *fp, X509_REQ *x)
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        X509err(X509_F_X509_REQ_PRINT_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -128,7 +128,7 @@ int X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflags,
                     ii = 0;
                     count = X509_ATTRIBUTE_count(a);
                     if (count == 0) {
-                      X509err(X509_F_X509_REQ_PRINT_EX, X509_R_INVALID_ATTRIBUTES);
+                      ERR_raise(ERR_LIB_X509, X509_R_INVALID_ATTRIBUTES);
                       return 0;
                     }
  get_next:
@@ -204,7 +204,7 @@ int X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflags,
 
     return 1;
  err:
-    X509err(X509_F_X509_REQ_PRINT_EX, ERR_R_BUF_LIB);
+    ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);
     return 0;
 }
 
diff --git a/crypto/x509/t_x509.c b/crypto/x509/t_x509.c
index 2d0ccd8a68..9636756b66 100644
--- a/crypto/x509/t_x509.c
+++ b/crypto/x509/t_x509.c
@@ -30,7 +30,7 @@ int X509_print_ex_fp(FILE *fp, X509 *x, unsigned long nmflag,
     int ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        X509err(X509_F_X509_PRINT_EX_FP, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
@@ -509,7 +509,7 @@ int X509_STORE_CTX_print_verify_cb(int ok, X509_STORE_CTX *ctx)
             BIO_printf(bio, &quot;Certs in trust store:\n&quot;);
             print_store_certs(bio, X509_STORE_CTX_get0_store(ctx));
         }
-        X509err(0, X509_R_CERTIFICATE_VERIFICATION_FAILED);
+        ERR_raise(ERR_LIB_X509, X509_R_CERTIFICATE_VERIFICATION_FAILED);
         ERR_add_error_mem_bio(&quot;\n&quot;, bio);
         BIO_free(bio);
     }
diff --git a/crypto/x509/v3_addr.c b/crypto/x509/v3_addr.c
index 7d4e99be5a..b7dd889087 100644
--- a/crypto/x509/v3_addr.c
+++ b/crypto/x509/v3_addr.c
@@ -897,7 +897,7 @@ static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
     int i;
 
     if ((addr = sk_IPAddressFamily_new(IPAddressFamily_cmp)) == NULL) {
-        X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -919,9 +919,8 @@ static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
             afi = IANA_AFI_IPV6;
             safi = &amp;safi_;
         } else {
-            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
-                      X509V3_R_EXTENSION_NAME_ERROR);
-            ERR_add_error_data(1, val-&gt;name);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_EXTENSION_NAME_ERROR,
+                           &quot;%s&quot;, val-&gt;name);
             goto err;
         }
 
@@ -944,7 +943,7 @@ static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
             *safi = strtoul(val-&gt;value, &amp;t, 0);
             t += strspn(t, &quot; \t&quot;);
             if (*safi &gt; 0xFF || *t++ != ':') {
-                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_SAFI);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_SAFI);
                 X509V3_conf_add_error_name_value(val);
                 goto err;
             }
@@ -954,7 +953,7 @@ static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
             s = OPENSSL_strdup(val-&gt;value);
         }
         if (s == NULL) {
-            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
 
@@ -964,8 +963,7 @@ static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
          */
         if (strcmp(s, &quot;inherit&quot;) == 0) {
             if (!X509v3_addr_add_inherit(addr, afi, safi)) {
-                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
-                          X509V3_R_INVALID_INHERITANCE);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_INHERITANCE);
                 X509V3_conf_add_error_name_value(val);
                 goto err;
             }
@@ -980,7 +978,7 @@ static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
         s[i1] = '\0';
 
         if (a2i_ipadd(min, s) != length) {
-            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_IPADDRESS);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_IPADDRESS);
             X509V3_conf_add_error_name_value(val);
             goto err;
         }
@@ -989,13 +987,12 @@ static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
         case '/':
             prefixlen = (int)strtoul(s + i2, &amp;t, 10);
             if (t == s + i2 || *t != '\0') {
-                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
-                          X509V3_R_EXTENSION_VALUE_ERROR);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_EXTENSION_VALUE_ERROR);
                 X509V3_conf_add_error_name_value(val);
                 goto err;
             }
             if (!X509v3_addr_add_prefix(addr, afi, safi, min, prefixlen)) {
-                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             break;
@@ -1003,37 +1000,33 @@ static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,
             i1 = i2 + strspn(s + i2, &quot; \t&quot;);
             i2 = i1 + strspn(s + i1, addr_chars);
             if (i1 == i2 || s[i2] != '\0') {
-                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
-                          X509V3_R_EXTENSION_VALUE_ERROR);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_EXTENSION_VALUE_ERROR);
                 X509V3_conf_add_error_name_value(val);
                 goto err;
             }
             if (a2i_ipadd(max, s + i1) != length) {
-                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
-                          X509V3_R_INVALID_IPADDRESS);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_IPADDRESS);
                 X509V3_conf_add_error_name_value(val);
                 goto err;
             }
             if (memcmp(min, max, length_from_afi(afi)) &gt; 0) {
-                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
-                          X509V3_R_EXTENSION_VALUE_ERROR);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_EXTENSION_VALUE_ERROR);
                 X509V3_conf_add_error_name_value(val);
                 goto err;
             }
             if (!X509v3_addr_add_range(addr, afi, safi, min, max)) {
-                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             break;
         case '\0':
             if (!X509v3_addr_add_prefix(addr, afi, safi, min, length * 8)) {
-                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             break;
         default:
-            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,
-                      X509V3_R_EXTENSION_VALUE_ERROR);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_EXTENSION_VALUE_ERROR);
             X509V3_conf_add_error_name_value(val);
             goto err;
         }
@@ -1210,8 +1203,7 @@ static int addr_validate_path_internal(X509_STORE_CTX *ctx,
         validation_err(X509_V_ERR_INVALID_EXTENSION);
     (void)sk_IPAddressFamily_set_cmp_func(ext, IPAddressFamily_cmp);
     if ((child = sk_IPAddressFamily_dup(ext)) == NULL) {
-        X509V3err(X509V3_F_ADDR_VALIDATE_PATH_INTERNAL,
-                  ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         if (ctx != NULL)
             ctx-&gt;error = X509_V_ERR_OUT_OF_MEM;
         ret = 0;
diff --git a/crypto/x509/v3_akey.c b/crypto/x509/v3_akey.c
index a3061c9a8f..21ea1e4c75 100644
--- a/crypto/x509/v3_akey.c
+++ b/crypto/x509/v3_akey.c
@@ -100,8 +100,8 @@ static AUTHORITY_KEYID *v2i_AUTHORITY_KEYID(X509V3_EXT_METHOD *method,
             if (cnf-&gt;value &amp;&amp; strcmp(cnf-&gt;value, &quot;always&quot;) == 0)
                 issuer = 2;
         } else {
-            X509V3err(X509V3_F_V2I_AUTHORITY_KEYID, X509V3_R_UNKNOWN_OPTION);
-            ERR_add_error_data(2, &quot;name=&quot;, cnf-&gt;name);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_UNKNOWN_OPTION,
+                           &quot;name=%s&quot;, cnf-&gt;name);
             return NULL;
         }
     }
@@ -109,8 +109,7 @@ static AUTHORITY_KEYID *v2i_AUTHORITY_KEYID(X509V3_EXT_METHOD *method,
     if (!ctx || !ctx-&gt;issuer_cert) {
         if (ctx &amp;&amp; (ctx-&gt;flags == CTX_TEST))
             return AUTHORITY_KEYID_new();
-        X509V3err(X509V3_F_V2I_AUTHORITY_KEYID,
-                  X509V3_R_NO_ISSUER_CERTIFICATE);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_NO_ISSUER_CERTIFICATE);
         return NULL;
     }
 
@@ -121,8 +120,7 @@ static AUTHORITY_KEYID *v2i_AUTHORITY_KEYID(X509V3_EXT_METHOD *method,
         if ((i &gt;= 0) &amp;&amp; (ext = X509_get_ext(cert, i)))
             ikeyid = X509V3_EXT_d2i(ext);
         if (keyid == 2 &amp;&amp; !ikeyid) {
-            X509V3err(X509V3_F_V2I_AUTHORITY_KEYID,
-                      X509V3_R_UNABLE_TO_GET_ISSUER_KEYID);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_UNABLE_TO_GET_ISSUER_KEYID);
             return NULL;
         }
     }
@@ -131,8 +129,7 @@ static AUTHORITY_KEYID *v2i_AUTHORITY_KEYID(X509V3_EXT_METHOD *method,
         isname = X509_NAME_dup(X509_get_issuer_name(cert));
         serial = ASN1_INTEGER_dup(X509_get0_serialNumber(cert));
         if (!isname || !serial) {
-            X509V3err(X509V3_F_V2I_AUTHORITY_KEYID,
-                      X509V3_R_UNABLE_TO_GET_ISSUER_DETAILS);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_UNABLE_TO_GET_ISSUER_DETAILS);
             goto err;
         }
     }
@@ -144,7 +141,7 @@ static AUTHORITY_KEYID *v2i_AUTHORITY_KEYID(X509V3_EXT_METHOD *method,
         if ((gens = sk_GENERAL_NAME_new_null()) == NULL
             || (gen = GENERAL_NAME_new()) == NULL
             || !sk_GENERAL_NAME_push(gens, gen)) {
-            X509V3err(X509V3_F_V2I_AUTHORITY_KEYID, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         gen-&gt;type = GEN_DIRNAME;
diff --git a/crypto/x509/v3_alt.c b/crypto/x509/v3_alt.c
index caa2f23220..2344c554fa 100644
--- a/crypto/x509/v3_alt.c
+++ b/crypto/x509/v3_alt.c
@@ -291,7 +291,7 @@ static GENERAL_NAMES *v2i_issuer_alt(X509V3_EXT_METHOD *method,
     int i;
 
     if (gens == NULL) {
-        X509V3err(X509V3_F_V2I_ISSUER_ALT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         sk_GENERAL_NAME_free(gens);
         return NULL;
     }
@@ -328,7 +328,7 @@ static int copy_issuer(X509V3_CTX *ctx, GENERAL_NAMES *gens)
     if (ctx &amp;&amp; (ctx-&gt;flags == CTX_TEST))
         return 1;
     if (!ctx || !ctx-&gt;issuer_cert) {
-        X509V3err(X509V3_F_COPY_ISSUER, X509V3_R_NO_ISSUER_DETAILS);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_NO_ISSUER_DETAILS);
         goto err;
     }
     i = X509_get_ext_by_NID(ctx-&gt;issuer_cert, NID_subject_alt_name, -1);
@@ -336,13 +336,13 @@ static int copy_issuer(X509V3_CTX *ctx, GENERAL_NAMES *gens)
         return 1;
     if ((ext = X509_get_ext(ctx-&gt;issuer_cert, i)) == NULL
         || (ialt = X509V3_EXT_d2i(ext)) == NULL) {
-        X509V3err(X509V3_F_COPY_ISSUER, X509V3_R_ISSUER_DECODE_ERROR);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_ISSUER_DECODE_ERROR);
         goto err;
     }
 
     num = sk_GENERAL_NAME_num(ialt);
     if (!sk_GENERAL_NAME_reserve(gens, num)) {
-        X509V3err(X509V3_F_COPY_ISSUER, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -370,7 +370,7 @@ static GENERAL_NAMES *v2i_subject_alt(X509V3_EXT_METHOD *method,
 
     gens = sk_GENERAL_NAME_new_reserve(NULL, num);
     if (gens == NULL) {
-        X509V3err(X509V3_F_V2I_SUBJECT_ALT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         sk_GENERAL_NAME_free(gens);
         return NULL;
     }
@@ -414,7 +414,7 @@ static int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p)
         return 1;
     if (ctx == NULL
         || (ctx-&gt;subject_cert == NULL &amp;&amp; ctx-&gt;subject_req == NULL)) {
-        X509V3err(X509V3_F_COPY_EMAIL, X509V3_R_NO_SUBJECT_DETAILS);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_NO_SUBJECT_DETAILS);
         goto err;
     }
     /* Find the subject name */
@@ -434,14 +434,14 @@ static int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p)
             i--;
         }
         if (email == NULL || (gen = GENERAL_NAME_new()) == NULL) {
-            X509V3err(X509V3_F_COPY_EMAIL, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         gen-&gt;d.ia5 = email;
         email = NULL;
         gen-&gt;type = GEN_EMAIL;
         if (!sk_GENERAL_NAME_push(gens, gen)) {
-            X509V3err(X509V3_F_COPY_EMAIL, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         gen = NULL;
@@ -467,7 +467,7 @@ GENERAL_NAMES *v2i_GENERAL_NAMES(const X509V3_EXT_METHOD *method,
 
     gens = sk_GENERAL_NAME_new_reserve(NULL, num);
     if (gens == NULL) {
-        X509V3err(X509V3_F_V2I_GENERAL_NAMES, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         sk_GENERAL_NAME_free(gens);
         return NULL;
     }
@@ -499,7 +499,7 @@ GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out,
     GENERAL_NAME *gen = NULL;
 
     if (!value) {
-        X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_MISSING_VALUE);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_MISSING_VALUE);
         return NULL;
     }
 
@@ -508,7 +508,7 @@ GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out,
     else {
         gen = GENERAL_NAME_new();
         if (gen == NULL) {
-            X509V3err(X509V3_F_A2I_GENERAL_NAME, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     }
@@ -524,8 +524,8 @@ GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out,
         {
             ASN1_OBJECT *obj;
             if ((obj = OBJ_txt2obj(value, 0)) == NULL) {
-                X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_BAD_OBJECT);
-                ERR_add_error_data(2, &quot;value=&quot;, value);
+                ERR_raise_data(ERR_LIB_X509V3, X509V3_R_BAD_OBJECT,
+                               &quot;value=%s&quot;, value);
                 goto err;
             }
             gen-&gt;d.rid = obj;
@@ -538,27 +538,27 @@ GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out,
         else
             gen-&gt;d.ip = a2i_IPADDRESS(value);
         if (gen-&gt;d.ip == NULL) {
-            X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_BAD_IP_ADDRESS);
-            ERR_add_error_data(2, &quot;value=&quot;, value);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_BAD_IP_ADDRESS,
+                           &quot;value=%s&quot;, value);
             goto err;
         }
         break;
 
     case GEN_DIRNAME:
         if (!do_dirname(gen, value, ctx)) {
-            X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_DIRNAME_ERROR);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_DIRNAME_ERROR);
             goto err;
         }
         break;
 
     case GEN_OTHERNAME:
         if (!do_othername(gen, value, ctx)) {
-            X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_OTHERNAME_ERROR);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_OTHERNAME_ERROR);
             goto err;
         }
         break;
     default:
-        X509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_UNSUPPORTED_TYPE);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_UNSUPPORTED_TYPE);
         goto err;
     }
 
@@ -566,7 +566,7 @@ GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out,
         if ((gen-&gt;d.ia5 = ASN1_IA5STRING_new()) == NULL ||
             !ASN1_STRING_set(gen-&gt;d.ia5, (unsigned char *)value,
                              strlen(value))) {
-            X509V3err(X509V3_F_A2I_GENERAL_NAME, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -593,7 +593,7 @@ GENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out,
     value = cnf-&gt;value;
 
     if (!value) {
-        X509V3err(X509V3_F_V2I_GENERAL_NAME_EX, X509V3_R_MISSING_VALUE);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_MISSING_VALUE);
         return NULL;
     }
 
@@ -612,8 +612,8 @@ GENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out,
     else if (!v3_name_cmp(name, &quot;otherName&quot;))
         type = GEN_OTHERNAME;
     else {
-        X509V3err(X509V3_F_V2I_GENERAL_NAME_EX, X509V3_R_UNSUPPORTED_OPTION);
-        ERR_add_error_data(2, &quot;name=&quot;, name);
+        ERR_raise_data(ERR_LIB_X509V3, X509V3_R_UNSUPPORTED_OPTION,
+                       &quot;name=%s&quot;, name);
         return NULL;
     }
 
@@ -658,8 +658,8 @@ static int do_dirname(GENERAL_NAME *gen, const char *value, X509V3_CTX *ctx)
         goto err;
     sk = X509V3_get_section(ctx, value);
     if (!sk) {
-        X509V3err(X509V3_F_DO_DIRNAME, X509V3_R_SECTION_NOT_FOUND);
-        ERR_add_error_data(2, &quot;section=&quot;, value);
+        ERR_raise_data(ERR_LIB_X509V3, X509V3_R_SECTION_NOT_FOUND,
+                       &quot;section=%s&quot;, value);
         goto err;
     }
     /* FIXME: should allow other character types... */
diff --git a/crypto/x509/v3_asid.c b/crypto/x509/v3_asid.c
index 93b345a0b8..45840a0073 100644
--- a/crypto/x509/v3_asid.c
+++ b/crypto/x509/v3_asid.c
@@ -301,16 +301,14 @@ static int ASIdentifierChoice_is_canonical(ASIdentifierChoice *choice)
         if ((bn == NULL &amp;&amp; (bn = BN_new()) == NULL) ||
             ASN1_INTEGER_to_BN(a_max, bn) == NULL ||
             !BN_add_word(bn, 1)) {
-            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_IS_CANONICAL,
-                      ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto done;
         }
 
         if ((a_max_plus_one =
                 BN_to_ASN1_INTEGER(bn, orig = a_max_plus_one)) == NULL) {
             a_max_plus_one = orig;
-            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_IS_CANONICAL,
-                      ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto done;
         }
 
@@ -374,8 +372,7 @@ static int ASIdentifierChoice_canonize(ASIdentifierChoice *choice)
      */
     if (choice-&gt;type != ASIdentifierChoice_asIdsOrRanges ||
         sk_ASIdOrRange_num(choice-&gt;u.asIdsOrRanges) == 0) {
-        X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,
-                  X509V3_R_EXTENSION_VALUE_ERROR);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_EXTENSION_VALUE_ERROR);
         return 0;
     }
 
@@ -415,8 +412,7 @@ static int ASIdentifierChoice_canonize(ASIdentifierChoice *choice)
          * Check for overlaps.
          */
         if (ASN1_INTEGER_cmp(a_max, b_min) &gt;= 0) {
-            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,
-                      X509V3_R_EXTENSION_VALUE_ERROR);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_EXTENSION_VALUE_ERROR);
             goto done;
         }
 
@@ -426,16 +422,14 @@ static int ASIdentifierChoice_canonize(ASIdentifierChoice *choice)
         if ((bn == NULL &amp;&amp; (bn = BN_new()) == NULL) ||
             ASN1_INTEGER_to_BN(a_max, bn) == NULL ||
             !BN_add_word(bn, 1)) {
-            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,
-                      ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto done;
         }
 
         if ((a_max_plus_one =
                  BN_to_ASN1_INTEGER(bn, orig = a_max_plus_one)) == NULL) {
             a_max_plus_one = orig;
-            X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,
-                      ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto done;
         }
 
@@ -447,8 +441,7 @@ static int ASIdentifierChoice_canonize(ASIdentifierChoice *choice)
             switch (a-&gt;type) {
             case ASIdOrRange_id:
                 if ((r = OPENSSL_malloc(sizeof(*r))) == NULL) {
-                    X509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,
-                              ERR_R_MALLOC_FAILURE);
+                    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                     goto done;
                 }
                 r-&gt;min = a_min;
@@ -524,7 +517,7 @@ static void *v2i_ASIdentifiers(const struct v3_ext_method *method,
     int i;
 
     if ((asid = ASIdentifiers_new()) == NULL) {
-        X509V3err(X509V3_F_V2I_ASIDENTIFIERS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -540,8 +533,7 @@ static void *v2i_ASIdentifiers(const struct v3_ext_method *method,
         } else if (!v3_name_cmp(val-&gt;name, &quot;RDI&quot;)) {
             which = V3_ASID_RDI;
         } else {
-            X509V3err(X509V3_F_V2I_ASIDENTIFIERS,
-                      X509V3_R_EXTENSION_NAME_ERROR);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_EXTENSION_NAME_ERROR);
             X509V3_conf_add_error_name_value(val);
             goto err;
         }
@@ -552,8 +544,7 @@ static void *v2i_ASIdentifiers(const struct v3_ext_method *method,
         if (strcmp(val-&gt;value, &quot;inherit&quot;) == 0) {
             if (X509v3_asid_add_inherit(asid, which))
                 continue;
-            X509V3err(X509V3_F_V2I_ASIDENTIFIERS,
-                      X509V3_R_INVALID_INHERITANCE);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_INHERITANCE);
             X509V3_conf_add_error_name_value(val);
             goto err;
         }
@@ -568,8 +559,7 @@ static void *v2i_ASIdentifiers(const struct v3_ext_method *method,
             is_range = 1;
             i2 = i1 + strspn(val-&gt;value + i1, &quot; \t&quot;);
             if (val-&gt;value[i2] != '-') {
-                X509V3err(X509V3_F_V2I_ASIDENTIFIERS,
-                          X509V3_R_INVALID_ASNUMBER);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_ASNUMBER);
                 X509V3_conf_add_error_name_value(val);
                 goto err;
             }
@@ -577,8 +567,7 @@ static void *v2i_ASIdentifiers(const struct v3_ext_method *method,
             i2 = i2 + strspn(val-&gt;value + i2, &quot; \t&quot;);
             i3 = i2 + strspn(val-&gt;value + i2, &quot;0123456789&quot;);
             if (val-&gt;value[i3] != '\0') {
-                X509V3err(X509V3_F_V2I_ASIDENTIFIERS,
-                          X509V3_R_INVALID_ASRANGE);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_ASRANGE);
                 X509V3_conf_add_error_name_value(val);
                 goto err;
             }
@@ -589,13 +578,13 @@ static void *v2i_ASIdentifiers(const struct v3_ext_method *method,
          */
         if (!is_range) {
             if (!X509V3_get_value_int(val, &amp;min)) {
-                X509V3err(X509V3_F_V2I_ASIDENTIFIERS, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
         } else {
             char *s = OPENSSL_strdup(val-&gt;value);
             if (s == NULL) {
-                X509V3err(X509V3_F_V2I_ASIDENTIFIERS, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             s[i1] = '\0';
@@ -603,17 +592,16 @@ static void *v2i_ASIdentifiers(const struct v3_ext_method *method,
             max = s2i_ASN1_INTEGER(NULL, s + i2);
             OPENSSL_free(s);
             if (min == NULL || max == NULL) {
-                X509V3err(X509V3_F_V2I_ASIDENTIFIERS, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             if (ASN1_INTEGER_cmp(min, max) &gt; 0) {
-                X509V3err(X509V3_F_V2I_ASIDENTIFIERS,
-                          X509V3_R_EXTENSION_VALUE_ERROR);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_EXTENSION_VALUE_ERROR);
                 goto err;
             }
         }
         if (!X509v3_asid_add_id_or_range(asid, which, min, max)) {
-            X509V3err(X509V3_F_V2I_ASIDENTIFIERS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         min = max = NULL;
diff --git a/crypto/x509/v3_bcons.c b/crypto/x509/v3_bcons.c
index 7a06a9d0ff..27eba96dd6 100644
--- a/crypto/x509/v3_bcons.c
+++ b/crypto/x509/v3_bcons.c
@@ -61,7 +61,7 @@ static BASIC_CONSTRAINTS *v2i_BASIC_CONSTRAINTS(X509V3_EXT_METHOD *method,
     int i;
 
     if ((bcons = BASIC_CONSTRAINTS_new()) == NULL) {
-        X509V3err(X509V3_F_V2I_BASIC_CONSTRAINTS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     for (i = 0; i &lt; sk_CONF_VALUE_num(values); i++) {
@@ -74,7 +74,7 @@ static BASIC_CONSTRAINTS *v2i_BASIC_CONSTRAINTS(X509V3_EXT_METHOD *method,
                 goto err;
             /* TODO add sanity check on int value - at least, must be &gt;= 0 */
         } else {
-            X509V3err(X509V3_F_V2I_BASIC_CONSTRAINTS, X509V3_R_INVALID_NAME);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NAME);
             X509V3_conf_add_error_name_value(val);
             goto err;
         }
diff --git a/crypto/x509/v3_bitst.c b/crypto/x509/v3_bitst.c
index 21511603c2..0caa338ff0 100644
--- a/crypto/x509/v3_bitst.c
+++ b/crypto/x509/v3_bitst.c
@@ -64,7 +64,7 @@ ASN1_BIT_STRING *v2i_ASN1_BIT_STRING(X509V3_EXT_METHOD *method,
     int i;
     BIT_STRING_BITNAME *bnam;
     if ((bs = ASN1_BIT_STRING_new()) == NULL) {
-        X509V3err(X509V3_F_V2I_ASN1_BIT_STRING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     for (i = 0; i &lt; sk_CONF_VALUE_num(nval); i++) {
@@ -73,8 +73,7 @@ ASN1_BIT_STRING *v2i_ASN1_BIT_STRING(X509V3_EXT_METHOD *method,
             if (strcmp(bnam-&gt;sname, val-&gt;name) == 0
                 || strcmp(bnam-&gt;lname, val-&gt;name) == 0) {
                 if (!ASN1_BIT_STRING_set_bit(bs, bnam-&gt;bitnum, 1)) {
-                    X509V3err(X509V3_F_V2I_ASN1_BIT_STRING,
-                              ERR_R_MALLOC_FAILURE);
+                    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                     ASN1_BIT_STRING_free(bs);
                     return NULL;
                 }
@@ -82,9 +81,8 @@ ASN1_BIT_STRING *v2i_ASN1_BIT_STRING(X509V3_EXT_METHOD *method,
             }
         }
         if (!bnam-&gt;lname) {
-            X509V3err(X509V3_F_V2I_ASN1_BIT_STRING,
-                      X509V3_R_UNKNOWN_BIT_STRING_ARGUMENT);
-            ERR_add_error_data(1, val-&gt;name);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_UNKNOWN_BIT_STRING_ARGUMENT,
+                           &quot;%s&quot;, val-&gt;name);
             ASN1_BIT_STRING_free(bs);
             return NULL;
         }
diff --git a/crypto/x509/v3_conf.c b/crypto/x509/v3_conf.c
index 918e96e709..47b626659c 100644
--- a/crypto/x509/v3_conf.c
+++ b/crypto/x509/v3_conf.c
@@ -44,12 +44,13 @@ static X509_EXTENSION *X509V3_EXT_nconf_int(CONF *conf, X509V3_CTX *ctx,
         return v3_generic_extension(name, value, crit, ext_type, ctx);
     ret = do_ext_nconf(conf, ctx, OBJ_sn2nid(name), crit, value);
     if (!ret) {
-        X509V3err(0, X509V3_R_ERROR_IN_EXTENSION);
         if (section != NULL)
-            ERR_add_error_data(6, &quot;section=&quot;, section,
-                               &quot;, name=&quot;, name, &quot;, value=&quot;, value);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_ERROR_IN_EXTENSION,
+                           &quot;section=%s, name=%s, value=%s&quot;,
+                           section, name, value);
         else
-            ERR_add_error_data(4, &quot;name=&quot;, name, &quot;, value=&quot;, value);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_ERROR_IN_EXTENSION,
+                           &quot;name=%s, value=%s&quot;, name, value);
     }
     return ret;
 }
@@ -84,11 +85,11 @@ static X509_EXTENSION *do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid,
     void *ext_struc;
 
     if (ext_nid == NID_undef) {
-        X509V3err(X509V3_F_DO_EXT_NCONF, X509V3_R_UNKNOWN_EXTENSION_NAME);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_UNKNOWN_EXTENSION_NAME);
         return NULL;
     }
     if ((method = X509V3_EXT_get_nid(ext_nid)) == NULL) {
-        X509V3err(X509V3_F_DO_EXT_NCONF, X509V3_R_UNKNOWN_EXTENSION);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_UNKNOWN_EXTENSION);
         return NULL;
     }
     /* Now get internal extension representation based on type */
@@ -98,10 +99,8 @@ static X509_EXTENSION *do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid,
         else
             nval = X509V3_parse_list(value);
         if (nval == NULL || sk_CONF_VALUE_num(nval) &lt;= 0) {
-            X509V3err(X509V3_F_DO_EXT_NCONF,
-                      X509V3_R_INVALID_EXTENSION_STRING);
-            ERR_add_error_data(4, &quot;name=&quot;, OBJ_nid2sn(ext_nid), &quot;,section=&quot;,
-                               value);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_INVALID_EXTENSION_STRING,
+                           &quot;name=%s,section=%s&quot;, OBJ_nid2sn(ext_nid), value);
             if (*value != '@')
                 sk_CONF_VALUE_pop_free(nval, X509V3_conf_free);
             return NULL;
@@ -116,15 +115,14 @@ static X509_EXTENSION *do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid,
             return NULL;
     } else if (method-&gt;r2i) {
         if (!ctx-&gt;db || !ctx-&gt;db_meth) {
-            X509V3err(X509V3_F_DO_EXT_NCONF, X509V3_R_NO_CONFIG_DATABASE);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_NO_CONFIG_DATABASE);
             return NULL;
         }
         if ((ext_struc = method-&gt;r2i(method, ctx, value)) == NULL)
             return NULL;
     } else {
-        X509V3err(X509V3_F_DO_EXT_NCONF,
-                  X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED);
-        ERR_add_error_data(2, &quot;name=&quot;, OBJ_nid2sn(ext_nid));
+        ERR_raise_data(ERR_LIB_X509V3, X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED,
+                       &quot;name=%s&quot;, OBJ_nid2sn(ext_nid));
         return NULL;
     }
 
@@ -175,7 +173,7 @@ static X509_EXTENSION *do_ext_i2d(const X509V3_EXT_METHOD *method,
     return ext;
 
  merr:
-    X509V3err(X509V3_F_DO_EXT_I2D, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
     OPENSSL_free(ext_der);
     ASN1_OCTET_STRING_free(ext_oct);
     return NULL;
@@ -189,7 +187,7 @@ X509_EXTENSION *X509V3_EXT_i2d(int ext_nid, int crit, void *ext_struc)
     const X509V3_EXT_METHOD *method;
 
     if ((method = X509V3_EXT_get_nid(ext_nid)) == NULL) {
-        X509V3err(X509V3_F_X509V3_EXT_I2D, X509V3_R_UNKNOWN_EXTENSION);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_UNKNOWN_EXTENSION);
         return NULL;
     }
     return do_ext_i2d(method, ext_nid, crit, ext_struc);
@@ -242,9 +240,8 @@ static X509_EXTENSION *v3_generic_extension(const char *ext, const char *value,
     X509_EXTENSION *extension = NULL;
 
     if ((obj = OBJ_txt2obj(ext, 0)) == NULL) {
-        X509V3err(X509V3_F_V3_GENERIC_EXTENSION,
-                  X509V3_R_EXTENSION_NAME_ERROR);
-        ERR_add_error_data(2, &quot;name=&quot;, ext);
+        ERR_raise_data(ERR_LIB_X509V3, X509V3_R_EXTENSION_NAME_ERROR,
+                       &quot;name=%s&quot;, ext);
         goto err;
     }
 
@@ -254,14 +251,13 @@ static X509_EXTENSION *v3_generic_extension(const char *ext, const char *value,
         ext_der = generic_asn1(value, ctx, &amp;ext_len);
 
     if (ext_der == NULL) {
-        X509V3err(X509V3_F_V3_GENERIC_EXTENSION,
-                  X509V3_R_EXTENSION_VALUE_ERROR);
-        ERR_add_error_data(2, &quot;value=&quot;, value);
+        ERR_raise_data(ERR_LIB_X509V3, X509V3_R_EXTENSION_VALUE_ERROR,
+                       &quot;value=%s&quot;, value);
         goto err;
     }
 
     if ((oct = ASN1_OCTET_STRING_new()) == NULL) {
-        X509V3err(X509V3_F_V3_GENERIC_EXTENSION, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -387,7 +383,7 @@ int X509V3_EXT_REQ_add_nconf(CONF *conf, X509V3_CTX *ctx, const char *section,
 char *X509V3_get_string(X509V3_CTX *ctx, const char *name, const char *section)
 {
     if (!ctx-&gt;db || !ctx-&gt;db_meth || !ctx-&gt;db_meth-&gt;get_string) {
-        X509V3err(X509V3_F_X509V3_GET_STRING, X509V3_R_OPERATION_NOT_DEFINED);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_OPERATION_NOT_DEFINED);
         return NULL;
     }
     if (ctx-&gt;db_meth-&gt;get_string)
@@ -398,8 +394,7 @@ char *X509V3_get_string(X509V3_CTX *ctx, const char *name, const char *section)
 STACK_OF(CONF_VALUE) *X509V3_get_section(X509V3_CTX *ctx, const char *section)
 {
     if (!ctx-&gt;db || !ctx-&gt;db_meth || !ctx-&gt;db_meth-&gt;get_section) {
-        X509V3err(X509V3_F_X509V3_GET_SECTION,
-                  X509V3_R_OPERATION_NOT_DEFINED);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_OPERATION_NOT_DEFINED);
         return NULL;
     }
     if (ctx-&gt;db_meth-&gt;get_section)
diff --git a/crypto/x509/v3_cpols.c b/crypto/x509/v3_cpols.c
index 9a227e4058..55aa5cac05 100644
--- a/crypto/x509/v3_cpols.c
+++ b/crypto/x509/v3_cpols.c
@@ -99,13 +99,13 @@ static STACK_OF(POLICYINFO) *r2i_certpol(X509V3_EXT_METHOD *method,
     int i, ia5org;
 
     if (vals == NULL) {
-        X509V3err(X509V3_F_R2I_CERTPOL, ERR_R_X509V3_LIB);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_X509V3_LIB);
         return NULL;
     }
 
     pols = sk_POLICYINFO_new_reserve(NULL, num);
     if (pols == NULL) {
-        X509V3err(X509V3_F_R2I_CERTPOL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -113,8 +113,7 @@ static STACK_OF(POLICYINFO) *r2i_certpol(X509V3_EXT_METHOD *method,
     for (i = 0; i &lt; num; i++) {
         cnf = sk_CONF_VALUE_value(vals, i);
         if (cnf-&gt;value != NULL || cnf-&gt;name == NULL) {
-            X509V3err(X509V3_F_R2I_CERTPOL,
-                      X509V3_R_INVALID_POLICY_IDENTIFIER);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_POLICY_IDENTIFIER);
             X509V3_conf_add_error_name_value(cnf);
             goto err;
         }
@@ -127,8 +126,8 @@ static STACK_OF(POLICYINFO) *r2i_certpol(X509V3_EXT_METHOD *method,
 
             polsect = X509V3_get_section(ctx, pstr + 1);
             if (polsect == NULL) {
-                X509V3err(X509V3_F_R2I_CERTPOL, X509V3_R_INVALID_SECTION);
-                ERR_add_error_data(1, cnf-&gt;name);
+                ERR_raise_data(ERR_LIB_X509V3, X509V3_R_INVALID_SECTION,
+                               &quot;%s&quot;, cnf-&gt;name);
                 goto err;
             }
             pol = policy_section(ctx, polsect, ia5org);
@@ -137,22 +136,22 @@ static STACK_OF(POLICYINFO) *r2i_certpol(X509V3_EXT_METHOD *method,
                 goto err;
         } else {
             if ((pobj = OBJ_txt2obj(cnf-&gt;name, 0)) == NULL) {
-                X509V3err(X509V3_F_R2I_CERTPOL,
-                          X509V3_R_INVALID_OBJECT_IDENTIFIER);
-                ERR_add_error_data(1, cnf-&gt;name);
+                ERR_raise_data(ERR_LIB_X509V3,
+                               X509V3_R_INVALID_OBJECT_IDENTIFIER,
+                               &quot;%s&quot;, cnf-&gt;name);
                 goto err;
             }
             pol = POLICYINFO_new();
             if (pol == NULL) {
                 ASN1_OBJECT_free(pobj);
-                X509V3err(X509V3_F_R2I_CERTPOL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             pol-&gt;policyid = pobj;
         }
         if (!sk_POLICYINFO_push(pols, pol)) {
             POLICYINFO_free(pol);
-            X509V3err(X509V3_F_R2I_CERTPOL, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -180,8 +179,7 @@ static POLICYINFO *policy_section(X509V3_CTX *ctx,
             ASN1_OBJECT *pobj;
 
             if ((pobj = OBJ_txt2obj(cnf-&gt;value, 0)) == NULL) {
-                X509V3err(X509V3_F_POLICY_SECTION,
-                          X509V3_R_INVALID_OBJECT_IDENTIFIER);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_OBJECT_IDENTIFIER);
                 X509V3_conf_err(cnf);
                 goto err;
             }
@@ -195,7 +193,7 @@ static POLICYINFO *policy_section(X509V3_CTX *ctx,
             if (!sk_POLICYQUALINFO_push(pol-&gt;qualifiers, qual))
                 goto merr;
             if ((qual-&gt;pqualid = OBJ_nid2obj(NID_id_qt_cps)) == NULL) {
-                X509V3err(X509V3_F_POLICY_SECTION, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
             if ((qual-&gt;d.cpsuri = ASN1_IA5STRING_new()) == NULL)
@@ -206,14 +204,13 @@ static POLICYINFO *policy_section(X509V3_CTX *ctx,
         } else if (!v3_name_cmp(cnf-&gt;name, &quot;userNotice&quot;)) {
             STACK_OF(CONF_VALUE) *unot;
             if (*cnf-&gt;value != '@') {
-                X509V3err(X509V3_F_POLICY_SECTION,
-                          X509V3_R_EXPECTED_A_SECTION_NAME);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_EXPECTED_A_SECTION_NAME);
                 X509V3_conf_err(cnf);
                 goto err;
             }
             unot = X509V3_get_section(ctx, cnf-&gt;value + 1);
             if (!unot) {
-                X509V3err(X509V3_F_POLICY_SECTION, X509V3_R_INVALID_SECTION);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_SECTION);
 
                 X509V3_conf_err(cnf);
                 goto err;
@@ -227,20 +224,20 @@ static POLICYINFO *policy_section(X509V3_CTX *ctx,
             if (!sk_POLICYQUALINFO_push(pol-&gt;qualifiers, qual))
                 goto merr;
         } else {
-            X509V3err(X509V3_F_POLICY_SECTION, X509V3_R_INVALID_OPTION);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_OPTION);
             X509V3_conf_err(cnf);
             goto err;
         }
     }
     if (pol-&gt;policyid == NULL) {
-        X509V3err(X509V3_F_POLICY_SECTION, X509V3_R_NO_POLICY_IDENTIFIER);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_NO_POLICY_IDENTIFIER);
         goto err;
     }
 
     return pol;
 
  merr:
-    X509V3err(X509V3_F_POLICY_SECTION, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
 
  err:
     POLICYINFO_free(pol);
@@ -293,7 +290,7 @@ static POLICYQUALINFO *notice_section(X509V3_CTX *ctx,
     if ((qual = POLICYQUALINFO_new()) == NULL)
         goto merr;
     if ((qual-&gt;pqualid = OBJ_nid2obj(NID_id_qt_unotice)) == NULL) {
-        X509V3err(X509V3_F_NOTICE_SECTION, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_INTERNAL_ERROR);
         goto err;
     }
     if ((not = USERNOTICE_new()) == NULL)
@@ -340,7 +337,7 @@ static POLICYQUALINFO *notice_section(X509V3_CTX *ctx,
                 nref = not-&gt;noticeref;
             nos = X509V3_parse_list(cnf-&gt;value);
             if (!nos || !sk_CONF_VALUE_num(nos)) {
-                X509V3err(X509V3_F_NOTICE_SECTION, X509V3_R_INVALID_NUMBERS);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NUMBERS);
                 X509V3_conf_add_error_name_value(cnf);
                 sk_CONF_VALUE_pop_free(nos, X509V3_conf_free);
                 goto err;
@@ -350,7 +347,7 @@ static POLICYQUALINFO *notice_section(X509V3_CTX *ctx,
             if (!ret)
                 goto err;
         } else {
-            X509V3err(X509V3_F_NOTICE_SECTION, X509V3_R_INVALID_OPTION);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_OPTION);
             X509V3_conf_add_error_name_value(cnf);
             goto err;
         }
@@ -358,15 +355,14 @@ static POLICYQUALINFO *notice_section(X509V3_CTX *ctx,
 
     if (not-&gt;noticeref &amp;&amp;
         (!not-&gt;noticeref-&gt;noticenos || !not-&gt;noticeref-&gt;organization)) {
-        X509V3err(X509V3_F_NOTICE_SECTION,
-                  X509V3_R_NEED_ORGANIZATION_AND_NUMBERS);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_NEED_ORGANIZATION_AND_NUMBERS);
         goto err;
     }
 
     return qual;
 
  merr:
-    X509V3err(X509V3_F_NOTICE_SECTION, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
 
  err:
     POLICYQUALINFO_free(qual);
@@ -383,7 +379,7 @@ static int nref_nos(STACK_OF(ASN1_INTEGER) *nnums, STACK_OF(CONF_VALUE) *nos)
     for (i = 0; i &lt; sk_CONF_VALUE_num(nos); i++) {
         cnf = sk_CONF_VALUE_value(nos, i);
         if ((aint = s2i_ASN1_INTEGER(NULL, cnf-&gt;name)) == NULL) {
-            X509V3err(X509V3_F_NREF_NOS, X509V3_R_INVALID_NUMBER);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NUMBER);
             goto err;
         }
         if (!sk_ASN1_INTEGER_push(nnums, aint))
@@ -393,7 +389,7 @@ static int nref_nos(STACK_OF(ASN1_INTEGER) *nnums, STACK_OF(CONF_VALUE) *nos)
 
  merr:
     ASN1_INTEGER_free(aint);
-    X509V3err(X509V3_F_NREF_NOS, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
 
  err:
     return 0;
diff --git a/crypto/x509/v3_crld.c b/crypto/x509/v3_crld.c
index 81ea31b16f..5a3e4206fd 100644
--- a/crypto/x509/v3_crld.c
+++ b/crypto/x509/v3_crld.c
@@ -53,7 +53,7 @@ static STACK_OF(GENERAL_NAME) *gnames_from_sectname(X509V3_CTX *ctx,
     else
         gnsect = X509V3_parse_list(sect);
     if (!gnsect) {
-        X509V3err(X509V3_F_GNAMES_FROM_SECTNAME, X509V3_R_SECTION_NOT_FOUND);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_SECTION_NOT_FOUND);
         return NULL;
     }
     gens = v2i_GENERAL_NAMES(NULL, ctx, gnsect);
@@ -83,8 +83,7 @@ static int set_dist_point_name(DIST_POINT_NAME **pdp, X509V3_CTX *ctx,
             return -1;
         dnsect = X509V3_get_section(ctx, cnf-&gt;value);
         if (!dnsect) {
-            X509V3err(X509V3_F_SET_DIST_POINT_NAME,
-                      X509V3_R_SECTION_NOT_FOUND);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_SECTION_NOT_FOUND);
             return -1;
         }
         ret = X509V3_NAME_from_section(nm, dnsect, MBSTRING_ASC);
@@ -99,16 +98,14 @@ static int set_dist_point_name(DIST_POINT_NAME **pdp, X509V3_CTX *ctx,
          */
         if (sk_X509_NAME_ENTRY_value(rnm,
                                      sk_X509_NAME_ENTRY_num(rnm) - 1)-&gt;set) {
-            X509V3err(X509V3_F_SET_DIST_POINT_NAME,
-                      X509V3_R_INVALID_MULTIPLE_RDNS);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_MULTIPLE_RDNS);
             goto err;
         }
     } else
         return 0;
 
     if (*pdp) {
-        X509V3err(X509V3_F_SET_DIST_POINT_NAME,
-                  X509V3_R_DISTPOINT_ALREADY_SET);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_DISTPOINT_ALREADY_SET);
         goto err;
     }
 
@@ -283,7 +280,7 @@ static void *v2i_crld(const X509V3_EXT_METHOD *method,
     return crld;
 
  merr:
-    X509V3err(X509V3_F_V2I_CRLD, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
  err:
     GENERAL_NAME_free(gen);
     GENERAL_NAMES_free(gens);
@@ -393,7 +390,7 @@ static void *v2i_idp(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
             if (!set_reasons(&amp;idp-&gt;onlysomereasons, val))
                 goto err;
         } else {
-            X509V3err(X509V3_F_V2I_IDP, X509V3_R_INVALID_NAME);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NAME);
             X509V3_conf_add_error_name_value(cnf);
             goto err;
         }
@@ -401,7 +398,7 @@ static void *v2i_idp(const X509V3_EXT_METHOD *method, X509V3_CTX *ctx,
     return idp;
 
  merr:
-    X509V3err(X509V3_F_V2I_IDP, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
  err:
     ISSUING_DIST_POINT_free(idp);
     return NULL;
diff --git a/crypto/x509/v3_extku.c b/crypto/x509/v3_extku.c
index b9a1447b82..753733323e 100644
--- a/crypto/x509/v3_extku.c
+++ b/crypto/x509/v3_extku.c
@@ -79,7 +79,7 @@ static void *v2i_EXTENDED_KEY_USAGE(const X509V3_EXT_METHOD *method,
 
     extku = sk_ASN1_OBJECT_new_reserve(NULL, num);
     if (extku == NULL) {
-        X509V3err(X509V3_F_V2I_EXTENDED_KEY_USAGE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         sk_ASN1_OBJECT_free(extku);
         return NULL;
     }
@@ -92,9 +92,8 @@ static void *v2i_EXTENDED_KEY_USAGE(const X509V3_EXT_METHOD *method,
             extval = val-&gt;name;
         if ((objtmp = OBJ_txt2obj(extval, 0)) == NULL) {
             sk_ASN1_OBJECT_pop_free(extku, ASN1_OBJECT_free);
-            X509V3err(X509V3_F_V2I_EXTENDED_KEY_USAGE,
-                      X509V3_R_INVALID_OBJECT_IDENTIFIER);
-            ERR_add_error_data(1, extval);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_INVALID_OBJECT_IDENTIFIER,
+                           &quot;%s&quot;, extval);
             return NULL;
         }
         sk_ASN1_OBJECT_push(extku, objtmp);  /* no failure as it was reserved */
diff --git a/crypto/x509/v3_ia5.c b/crypto/x509/v3_ia5.c
index dc35dd83de..89eececd50 100644
--- a/crypto/x509/v3_ia5.c
+++ b/crypto/x509/v3_ia5.c
@@ -32,7 +32,7 @@ char *i2s_ASN1_IA5STRING(X509V3_EXT_METHOD *method, ASN1_IA5STRING *ia5)
     if (ia5 == NULL || ia5-&gt;length == 0)
         return NULL;
     if ((tmp = OPENSSL_malloc(ia5-&gt;length + 1)) == NULL) {
-        X509V3err(X509V3_F_I2S_ASN1_IA5STRING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     memcpy(tmp, ia5-&gt;data, ia5-&gt;length);
@@ -45,8 +45,7 @@ ASN1_IA5STRING *s2i_ASN1_IA5STRING(X509V3_EXT_METHOD *method,
 {
     ASN1_IA5STRING *ia5;
     if (str == NULL) {
-        X509V3err(X509V3_F_S2I_ASN1_IA5STRING,
-                  X509V3_R_INVALID_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NULL_ARGUMENT);
         return NULL;
     }
     if ((ia5 = ASN1_IA5STRING_new()) == NULL)
@@ -60,6 +59,6 @@ ASN1_IA5STRING *s2i_ASN1_IA5STRING(X509V3_EXT_METHOD *method,
 #endif                          /* CHARSET_EBCDIC */
     return ia5;
  err:
-    X509V3err(X509V3_F_S2I_ASN1_IA5STRING, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
diff --git a/crypto/x509/v3_info.c b/crypto/x509/v3_info.c
index 3711b51e18..003f3ce172 100644
--- a/crypto/x509/v3_info.c
+++ b/crypto/x509/v3_info.c
@@ -91,7 +91,7 @@ static STACK_OF(CONF_VALUE) *i2v_AUTHORITY_INFO_ACCESS(
 
     return tret;
  err:
-    X509V3err(X509V3_F_I2V_AUTHORITY_INFO_ACCESS, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
     if (ret == NULL &amp;&amp; tret != NULL)
         sk_CONF_VALUE_pop_free(tret, X509V3_conf_free);
     return NULL;
@@ -106,48 +106,36 @@ static AUTHORITY_INFO_ACCESS *v2i_AUTHORITY_INFO_ACCESS(X509V3_EXT_METHOD
     AUTHORITY_INFO_ACCESS *ainfo = NULL;
     CONF_VALUE *cnf, ctmp;
     ACCESS_DESCRIPTION *acc;
-    int i, objlen;
+    int i;
     const int num = sk_CONF_VALUE_num(nval);
-    char *objtmp, *ptmp;
+    char *ptmp;
 
     if ((ainfo = sk_ACCESS_DESCRIPTION_new_reserve(NULL, num)) == NULL) {
-        X509V3err(X509V3_F_V2I_AUTHORITY_INFO_ACCESS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     for (i = 0; i &lt; num; i++) {
         cnf = sk_CONF_VALUE_value(nval, i);
         if ((acc = ACCESS_DESCRIPTION_new()) == NULL) {
-            X509V3err(X509V3_F_V2I_AUTHORITY_INFO_ACCESS,
-                      ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         sk_ACCESS_DESCRIPTION_push(ainfo, acc); /* Cannot fail due to reserve */
         ptmp = strchr(cnf-&gt;name, ';');
         if (ptmp == NULL) {
-            X509V3err(X509V3_F_V2I_AUTHORITY_INFO_ACCESS,
-                      X509V3_R_INVALID_SYNTAX);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_SYNTAX);
             goto err;
         }
-        objlen = ptmp - cnf-&gt;name;
         ctmp.name = ptmp + 1;
         ctmp.value = cnf-&gt;value;
         if (!v2i_GENERAL_NAME_ex(acc-&gt;location, method, ctx, &amp;ctmp, 0))
             goto err;
-        if ((objtmp = OPENSSL_strndup(cnf-&gt;name, objlen)) == NULL) {
-            X509V3err(X509V3_F_V2I_AUTHORITY_INFO_ACCESS,
-                      ERR_R_MALLOC_FAILURE);
-            goto err;
-        }
-        acc-&gt;method = OBJ_txt2obj(objtmp, 0);
+        acc-&gt;method = OBJ_txt2obj(cnf-&gt;value, 0);
         if (!acc-&gt;method) {
-            X509V3err(X509V3_F_V2I_AUTHORITY_INFO_ACCESS,
-                      X509V3_R_BAD_OBJECT);
-            ERR_add_error_data(2, &quot;value=&quot;, objtmp);
-            OPENSSL_free(objtmp);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_BAD_OBJECT,
+                           &quot;value=%s&quot;, cnf-&gt;value);
             goto err;
         }
-        OPENSSL_free(objtmp);
-
     }
     return ainfo;
  err:
diff --git a/crypto/x509/v3_ist.c b/crypto/x509/v3_ist.c
index 6db4f19913..da9b4f2421 100644
--- a/crypto/x509/v3_ist.c
+++ b/crypto/x509/v3_ist.c
@@ -39,7 +39,7 @@ static ISSUER_SIGN_TOOL *v2i_issuer_sign_tool(X509V3_EXT_METHOD *method, X509V3_
     int i;
 
     if (ist == NULL) {
-        X509V3err(X509V3_F_V2I_ISSUER_SIGN_TOOL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     for (i = 0; i &lt; sk_CONF_VALUE_num(nval); ++i) {
@@ -51,7 +51,7 @@ static ISSUER_SIGN_TOOL *v2i_issuer_sign_tool(X509V3_EXT_METHOD *method, X509V3_
         if (strcmp(cnf-&gt;name, &quot;signTool&quot;) == 0) {
             ist-&gt;signTool = ASN1_UTF8STRING_new();
             if (ist-&gt;signTool == NULL) {
-                X509V3err(X509V3_F_V2I_ISSUER_SIGN_TOOL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 ISSUER_SIGN_TOOL_free(ist);
                 return NULL;
             }
@@ -59,7 +59,7 @@ static ISSUER_SIGN_TOOL *v2i_issuer_sign_tool(X509V3_EXT_METHOD *method, X509V3_
         } else if (strcmp(cnf-&gt;name, &quot;cATool&quot;) == 0) {
             ist-&gt;cATool = ASN1_UTF8STRING_new();
             if (ist-&gt;cATool == NULL) {
-                X509V3err(X509V3_F_V2I_ISSUER_SIGN_TOOL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 ISSUER_SIGN_TOOL_free(ist);
                 return NULL;
             }
@@ -67,7 +67,7 @@ static ISSUER_SIGN_TOOL *v2i_issuer_sign_tool(X509V3_EXT_METHOD *method, X509V3_
         } else if (strcmp(cnf-&gt;name, &quot;signToolCert&quot;) == 0) {
             ist-&gt;signToolCert = ASN1_UTF8STRING_new();
             if (ist-&gt;signToolCert == NULL) {
-                X509V3err(X509V3_F_V2I_ISSUER_SIGN_TOOL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 ISSUER_SIGN_TOOL_free(ist);
                 return NULL;
             }
@@ -75,13 +75,13 @@ static ISSUER_SIGN_TOOL *v2i_issuer_sign_tool(X509V3_EXT_METHOD *method, X509V3_
         } else if (strcmp(cnf-&gt;name, &quot;cAToolCert&quot;) == 0) {
             ist-&gt;cAToolCert = ASN1_UTF8STRING_new();
             if (ist-&gt;cAToolCert == NULL) {
-                X509V3err(X509V3_F_V2I_ISSUER_SIGN_TOOL, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 ISSUER_SIGN_TOOL_free(ist);
                 return NULL;
             }
             ASN1_STRING_set(ist-&gt;cAToolCert, cnf-&gt;value, strlen(cnf-&gt;value));
         } else {
-            X509V3err(X509V3_F_V2I_ISSUER_SIGN_TOOL, ERR_R_PASSED_INVALID_ARGUMENT);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_PASSED_INVALID_ARGUMENT);
             ISSUER_SIGN_TOOL_free(ist);
             return NULL;
         }
@@ -96,7 +96,7 @@ static int i2r_issuer_sign_tool(X509V3_EXT_METHOD *method,
     int new_line = 0;
 
     if (ist == NULL) {
-        X509V3err(X509V3_F_I2R_ISSUER_SIGN_TOOL, ERR_R_PASSED_INVALID_ARGUMENT);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_PASSED_INVALID_ARGUMENT);
         return 0;
     }
     if (ist-&gt;signTool != NULL) {
diff --git a/crypto/x509/v3_lib.c b/crypto/x509/v3_lib.c
index 1069a9f24a..42b6ff1527 100644
--- a/crypto/x509/v3_lib.c
+++ b/crypto/x509/v3_lib.c
@@ -26,11 +26,11 @@ int X509V3_EXT_add(X509V3_EXT_METHOD *ext)
 {
     if (ext_list == NULL
         &amp;&amp; (ext_list = sk_X509V3_EXT_METHOD_new(ext_cmp)) == NULL) {
-        X509V3err(X509V3_F_X509V3_EXT_ADD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     if (!sk_X509V3_EXT_METHOD_push(ext_list, ext)) {
-        X509V3err(X509V3_F_X509V3_EXT_ADD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return 1;
@@ -89,11 +89,11 @@ int X509V3_EXT_add_alias(int nid_to, int nid_from)
     X509V3_EXT_METHOD *tmpext;
 
     if ((ext = X509V3_EXT_get_nid(nid_from)) == NULL) {
-        X509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS, X509V3_R_EXTENSION_NOT_FOUND);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_EXTENSION_NOT_FOUND);
         return 0;
     }
     if ((tmpext = OPENSSL_malloc(sizeof(*tmpext))) == NULL) {
-        X509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     *tmpext = *ext;
@@ -265,8 +265,7 @@ int X509V3_add1_i2d(STACK_OF(X509_EXTENSION) **x, int nid, void *value,
     ext = X509V3_EXT_i2d(nid, crit, value);
 
     if (!ext) {
-        X509V3err(X509V3_F_X509V3_ADD1_I2D,
-                  X509V3_R_ERROR_CREATING_EXTENSION);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_ERROR_CREATING_EXTENSION);
         return 0;
     }
 
@@ -290,7 +289,7 @@ int X509V3_add1_i2d(STACK_OF(X509_EXTENSION) **x, int nid, void *value,
     return 1;
 
  m_fail:
-    /* X509V3err(X509V3_F_X509V3_ADD1_I2D, ERR_R_MALLOC_FAILURE); */
+    /* ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); */
     if (ret != *x)
         sk_X509_EXTENSION_free(ret);
     X509_EXTENSION_free(ext);
@@ -298,6 +297,6 @@ int X509V3_add1_i2d(STACK_OF(X509_EXTENSION) **x, int nid, void *value,
 
  err:
     if (!(flags &amp; X509V3_ADD_SILENT))
-        X509V3err(X509V3_F_X509V3_ADD1_I2D, errcode);
+        ERR_raise(ERR_LIB_X509V3, errcode);
     return 0;
 }
diff --git a/crypto/x509/v3_ncons.c b/crypto/x509/v3_ncons.c
index 6af8edecdb..0eddfd07f6 100644
--- a/crypto/x509/v3_ncons.c
+++ b/crypto/x509/v3_ncons.c
@@ -127,7 +127,7 @@ static void *v2i_NAME_CONSTRAINTS(const X509V3_EXT_METHOD *method,
             ptree = &amp;ncons-&gt;excludedSubtrees;
             tval.name = val-&gt;name + 9;
         } else {
-            X509V3err(X509V3_F_V2I_NAME_CONSTRAINTS, X509V3_R_INVALID_SYNTAX);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_SYNTAX);
             goto err;
         }
         tval.value = val-&gt;value;
@@ -146,7 +146,7 @@ static void *v2i_NAME_CONSTRAINTS(const X509V3_EXT_METHOD *method,
     return ncons;
 
  memerr:
-    X509V3err(X509V3_F_V2I_NAME_CONSTRAINTS, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
  err:
     NAME_CONSTRAINTS_free(ncons);
     GENERAL_SUBTREE_free(sub);
diff --git a/crypto/x509/v3_pci.c b/crypto/x509/v3_pci.c
index febb07f7d4..bb9fc79ccc 100644
--- a/crypto/x509/v3_pci.c
+++ b/crypto/x509/v3_pci.c
@@ -89,27 +89,24 @@ static int process_pci_value(CONF_VALUE *val,
 
     if (strcmp(val-&gt;name, &quot;language&quot;) == 0) {
         if (*language) {
-            X509V3err(X509V3_F_PROCESS_PCI_VALUE,
-                      X509V3_R_POLICY_LANGUAGE_ALREADY_DEFINED);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_POLICY_LANGUAGE_ALREADY_DEFINED);
             X509V3_conf_err(val);
             return 0;
         }
         if ((*language = OBJ_txt2obj(val-&gt;value, 0)) == NULL) {
-            X509V3err(X509V3_F_PROCESS_PCI_VALUE,
-                      X509V3_R_INVALID_OBJECT_IDENTIFIER);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_OBJECT_IDENTIFIER);
             X509V3_conf_err(val);
             return 0;
         }
     } else if (strcmp(val-&gt;name, &quot;pathlen&quot;) == 0) {
         if (*pathlen) {
-            X509V3err(X509V3_F_PROCESS_PCI_VALUE,
+            ERR_raise(ERR_LIB_X509V3,
                       X509V3_R_POLICY_PATH_LENGTH_ALREADY_DEFINED);
             X509V3_conf_err(val);
             return 0;
         }
         if (!X509V3_get_value_int(val, pathlen)) {
-            X509V3err(X509V3_F_PROCESS_PCI_VALUE,
-                      X509V3_R_POLICY_PATH_LENGTH);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_POLICY_PATH_LENGTH);
             X509V3_conf_err(val);
             return 0;
         }
@@ -120,7 +117,7 @@ static int process_pci_value(CONF_VALUE *val,
         if (*policy == NULL) {
             *policy = ASN1_OCTET_STRING_new();
             if (*policy == NULL) {
-                X509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 X509V3_conf_err(val);
                 return 0;
             }
@@ -152,7 +149,7 @@ static int process_pci_value(CONF_VALUE *val,
                 OPENSSL_free((*policy)-&gt;data);
                 (*policy)-&gt;data = NULL;
                 (*policy)-&gt;length = 0;
-                X509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 X509V3_conf_err(val);
                 goto err;
             }
@@ -162,7 +159,7 @@ static int process_pci_value(CONF_VALUE *val,
             int n;
             BIO *b = BIO_new_file(val-&gt;value + 5, &quot;r&quot;);
             if (!b) {
-                X509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_BIO_LIB);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_BIO_LIB);
                 X509V3_conf_err(val);
                 goto err;
             }
@@ -178,8 +175,7 @@ static int process_pci_value(CONF_VALUE *val,
                     OPENSSL_free((*policy)-&gt;data);
                     (*policy)-&gt;data = NULL;
                     (*policy)-&gt;length = 0;
-                    X509V3err(X509V3_F_PROCESS_PCI_VALUE,
-                              ERR_R_MALLOC_FAILURE);
+                    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                     X509V3_conf_err(val);
                     BIO_free_all(b);
                     goto err;
@@ -193,7 +189,7 @@ static int process_pci_value(CONF_VALUE *val,
             BIO_free_all(b);
 
             if (n &lt; 0) {
-                X509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_BIO_LIB);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_BIO_LIB);
                 X509V3_conf_err(val);
                 goto err;
             }
@@ -215,18 +211,17 @@ static int process_pci_value(CONF_VALUE *val,
                 OPENSSL_free((*policy)-&gt;data);
                 (*policy)-&gt;data = NULL;
                 (*policy)-&gt;length = 0;
-                X509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
                 X509V3_conf_err(val);
                 goto err;
             }
         } else {
-            X509V3err(X509V3_F_PROCESS_PCI_VALUE,
-                      X509V3_R_INCORRECT_POLICY_SYNTAX_TAG);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INCORRECT_POLICY_SYNTAX_TAG);
             X509V3_conf_err(val);
             goto err;
         }
         if (!tmp_data) {
-            X509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             X509V3_conf_err(val);
             goto err;
         }
@@ -255,8 +250,7 @@ static PROXY_CERT_INFO_EXTENSION *r2i_pci(X509V3_EXT_METHOD *method,
         CONF_VALUE *cnf = sk_CONF_VALUE_value(vals, i);
 
         if (!cnf-&gt;name || (*cnf-&gt;name != '@' &amp;&amp; !cnf-&gt;value)) {
-            X509V3err(X509V3_F_R2I_PCI,
-                      X509V3_R_INVALID_PROXY_POLICY_SETTING);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_PROXY_POLICY_SETTING);
             X509V3_conf_err(cnf);
             goto err;
         }
@@ -266,7 +260,7 @@ static PROXY_CERT_INFO_EXTENSION *r2i_pci(X509V3_EXT_METHOD *method,
 
             sect = X509V3_get_section(ctx, cnf-&gt;name + 1);
             if (!sect) {
-                X509V3err(X509V3_F_R2I_PCI, X509V3_R_INVALID_SECTION);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_SECTION);
                 X509V3_conf_err(cnf);
                 goto err;
             }
@@ -288,20 +282,20 @@ static PROXY_CERT_INFO_EXTENSION *r2i_pci(X509V3_EXT_METHOD *method,
 
     /* Language is mandatory */
     if (!language) {
-        X509V3err(X509V3_F_R2I_PCI,
+        ERR_raise(ERR_LIB_X509V3,
                   X509V3_R_NO_PROXY_CERT_POLICY_LANGUAGE_DEFINED);
         goto err;
     }
     i = OBJ_obj2nid(language);
     if ((i == NID_Independent || i == NID_id_ppl_inheritAll) &amp;&amp; policy) {
-        X509V3err(X509V3_F_R2I_PCI,
+        ERR_raise(ERR_LIB_X509V3,
                   X509V3_R_POLICY_WHEN_PROXY_LANGUAGE_REQUIRES_NO_POLICY);
         goto err;
     }
 
     pci = PROXY_CERT_INFO_EXTENSION_new();
     if (pci == NULL) {
-        X509V3err(X509V3_F_R2I_PCI, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
diff --git a/crypto/x509/v3_pcons.c b/crypto/x509/v3_pcons.c
index e61a14e254..a8e8ab299f 100644
--- a/crypto/x509/v3_pcons.c
+++ b/crypto/x509/v3_pcons.c
@@ -61,7 +61,7 @@ static void *v2i_POLICY_CONSTRAINTS(const X509V3_EXT_METHOD *method,
     int i;
 
     if ((pcons = POLICY_CONSTRAINTS_new()) == NULL) {
-        X509V3err(X509V3_F_V2I_POLICY_CONSTRAINTS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     for (i = 0; i &lt; sk_CONF_VALUE_num(values); i++) {
@@ -73,15 +73,14 @@ static void *v2i_POLICY_CONSTRAINTS(const X509V3_EXT_METHOD *method,
             if (!X509V3_get_value_int(val, &amp;pcons-&gt;inhibitPolicyMapping))
                 goto err;
         } else {
-            X509V3err(X509V3_F_V2I_POLICY_CONSTRAINTS, X509V3_R_INVALID_NAME);
-            ERR_add_error_data(1, val-&gt;name);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_INVALID_NAME,
+                           &quot;%s&quot;, val-&gt;name);
             goto err;
         }
     }
     if (pcons-&gt;inhibitPolicyMapping == NULL
             &amp;&amp; pcons-&gt;requireExplicitPolicy == NULL) {
-        X509V3err(X509V3_F_V2I_POLICY_CONSTRAINTS,
-                  X509V3_R_ILLEGAL_EMPTY_EXTENSION);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_ILLEGAL_EMPTY_EXTENSION);
         goto err;
     }
 
diff --git a/crypto/x509/v3_pmaps.c b/crypto/x509/v3_pmaps.c
index a2b95c48e4..0a76b2f38d 100644
--- a/crypto/x509/v3_pmaps.c
+++ b/crypto/x509/v3_pmaps.c
@@ -73,29 +73,27 @@ static void *v2i_POLICY_MAPPINGS(const X509V3_EXT_METHOD *method,
     int i;
 
     if ((pmaps = sk_POLICY_MAPPING_new_reserve(NULL, num)) == NULL) {
-        X509V3err(X509V3_F_V2I_POLICY_MAPPINGS, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     for (i = 0; i &lt; num; i++) {
         val = sk_CONF_VALUE_value(nval, i);
         if (!val-&gt;value || !val-&gt;name) {
-            X509V3err(X509V3_F_V2I_POLICY_MAPPINGS,
-                      X509V3_R_INVALID_OBJECT_IDENTIFIER);
-            ERR_add_error_data(1, val-&gt;name);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_INVALID_OBJECT_IDENTIFIER,
+                           &quot;%s&quot;, val-&gt;name);
             goto err;
         }
         obj1 = OBJ_txt2obj(val-&gt;name, 0);
         obj2 = OBJ_txt2obj(val-&gt;value, 0);
         if (!obj1 || !obj2) {
-            X509V3err(X509V3_F_V2I_POLICY_MAPPINGS,
-                      X509V3_R_INVALID_OBJECT_IDENTIFIER);
-            ERR_add_error_data(1, val-&gt;name);
+            ERR_raise_data(ERR_LIB_X509V3, X509V3_R_INVALID_OBJECT_IDENTIFIER,
+                           &quot;%s&quot;, val-&gt;name);
             goto err;
         }
         pmap = POLICY_MAPPING_new();
         if (pmap == NULL) {
-            X509V3err(X509V3_F_V2I_POLICY_MAPPINGS, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         pmap-&gt;issuerDomainPolicy = obj1;
diff --git a/crypto/x509/v3_purp.c b/crypto/x509/v3_purp.c
index fd512419f0..a3673e63fa 100644
--- a/crypto/x509/v3_purp.c
+++ b/crypto/x509/v3_purp.c
@@ -95,7 +95,7 @@ int X509_check_purpose(X509 *x, int id, int ca)
 int X509_PURPOSE_set(int *p, int purpose)
 {
     if (X509_PURPOSE_get_by_id(purpose) == -1) {
-        X509V3err(X509V3_F_X509_PURPOSE_SET, X509V3_R_INVALID_PURPOSE);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_PURPOSE);
         return 0;
     }
     *p = purpose;
@@ -163,7 +163,7 @@ int X509_PURPOSE_add(int id, int trust, int flags,
     /* Need a new entry */
     if (idx == -1) {
         if ((ptmp = OPENSSL_malloc(sizeof(*ptmp))) == NULL) {
-            X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         ptmp-&gt;flags = X509_PURPOSE_DYNAMIC;
@@ -179,7 +179,7 @@ int X509_PURPOSE_add(int id, int trust, int flags,
     ptmp-&gt;name = OPENSSL_strdup(name);
     ptmp-&gt;sname = OPENSSL_strdup(sname);
     if (ptmp-&gt;name == NULL|| ptmp-&gt;sname == NULL) {
-        X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     /* Keep the dynamic flag of existing entry */
@@ -196,11 +196,11 @@ int X509_PURPOSE_add(int id, int trust, int flags,
     if (idx == -1) {
         if (xptable == NULL
             &amp;&amp; (xptable = sk_X509_PURPOSE_new(xp_cmp)) == NULL) {
-            X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (!sk_X509_PURPOSE_push(xptable, ptmp)) {
-            X509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
@@ -308,7 +308,7 @@ static int setup_dp(const X509 *x, DIST_POINT *dp)
     int i;
 
     if (dp-&gt;distpoint == NULL &amp;&amp; sk_GENERAL_NAME_num(dp-&gt;CRLissuer) &lt;= 0) {
-        X509err(0, X509_R_INVALID_DISTPOINT);
+        ERR_raise(ERR_LIB_X509, X509_R_INVALID_DISTPOINT);
         return 0;
     }
     if (dp-&gt;reasons != NULL) {
@@ -436,7 +436,7 @@ int x509v3_cache_extensions(X509 *x)
              * in case ctx-&gt;param-&gt;flags &amp; X509_V_FLAG_X509_STRICT
              */
             if (bs-&gt;pathlen-&gt;type == V_ASN1_NEG_INTEGER) {
-                X509err(0, X509V3_R_NEGATIVE_PATHLEN);
+                ERR_raise(ERR_LIB_X509, X509V3_R_NEGATIVE_PATHLEN);
                 x-&gt;ex_flags |= EXFLAG_INVALID;
             } else {
                 x-&gt;ex_pathlen = ASN1_INTEGER_get(bs-&gt;pathlen);
@@ -477,7 +477,7 @@ int x509v3_cache_extensions(X509 *x)
         ASN1_BIT_STRING_free(usage);
         /* Check for empty key usage according to RFC 5280 section 4.2.1.3 */
         if (x-&gt;ex_kusage == 0) {
-            X509err(0, X509V3_R_EMPTY_KEY_USAGE);
+            ERR_raise(ERR_LIB_X509, X509V3_R_EMPTY_KEY_USAGE);
             x-&gt;ex_flags |= EXFLAG_INVALID;
         }
     } else if (i != -1) {
@@ -629,7 +629,7 @@ int x509v3_cache_extensions(X509 *x)
         CRYPTO_THREAD_unlock(x-&gt;lock);
         return 1;
     }
-    X509err(0, X509V3_R_INVALID_CERTIFICATE);
+    ERR_raise(ERR_LIB_X509, X509V3_R_INVALID_CERTIFICATE);
 
  err:
     x-&gt;ex_flags |= EXFLAG_SET; /* indicate that cert has been processed */
diff --git a/crypto/x509/v3_skey.c b/crypto/x509/v3_skey.c
index c69975f6af..a8e8c890b5 100644
--- a/crypto/x509/v3_skey.c
+++ b/crypto/x509/v3_skey.c
@@ -37,7 +37,7 @@ ASN1_OCTET_STRING *s2i_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method,
     long length;
 
     if ((oct = ASN1_OCTET_STRING_new()) == NULL) {
-        X509V3err(X509V3_F_S2I_ASN1_OCTET_STRING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -66,7 +66,7 @@ static ASN1_OCTET_STRING *s2i_skey_id(X509V3_EXT_METHOD *method,
         return s2i_ASN1_OCTET_STRING(method, ctx, str);
 
     if ((oct = ASN1_OCTET_STRING_new()) == NULL) {
-        X509V3err(X509V3_F_S2I_SKEY_ID, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -74,7 +74,7 @@ static ASN1_OCTET_STRING *s2i_skey_id(X509V3_EXT_METHOD *method,
         return oct;
 
     if (!ctx || (!ctx-&gt;subject_req &amp;&amp; !ctx-&gt;subject_cert)) {
-        X509V3err(X509V3_F_S2I_SKEY_ID, X509V3_R_NO_PUBLIC_KEY);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_NO_PUBLIC_KEY);
         goto err;
     }
 
@@ -84,7 +84,7 @@ static ASN1_OCTET_STRING *s2i_skey_id(X509V3_EXT_METHOD *method,
         pubkey = ctx-&gt;subject_cert-&gt;cert_info.key;
 
     if (pubkey == NULL) {
-        X509V3err(X509V3_F_S2I_SKEY_ID, X509V3_R_NO_PUBLIC_KEY);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_NO_PUBLIC_KEY);
         goto err;
     }
 
@@ -94,7 +94,7 @@ static ASN1_OCTET_STRING *s2i_skey_id(X509V3_EXT_METHOD *method,
         goto err;
 
     if (!ASN1_OCTET_STRING_set(oct, pkey_dig, diglen)) {
-        X509V3err(X509V3_F_S2I_SKEY_ID, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
diff --git a/crypto/x509/v3_sxnet.c b/crypto/x509/v3_sxnet.c
index b7623b1051..76f5eafc73 100644
--- a/crypto/x509/v3_sxnet.c
+++ b/crypto/x509/v3_sxnet.c
@@ -106,7 +106,7 @@ int SXNET_add_id_asc(SXNET **psx, const char *zone, const char *user, int userle
     ASN1_INTEGER *izone;
 
     if ((izone = s2i_ASN1_INTEGER(NULL, zone)) == NULL) {
-        X509V3err(X509V3_F_SXNET_ADD_ID_ASC, X509V3_R_ERROR_CONVERTING_ZONE);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_ERROR_CONVERTING_ZONE);
         return 0;
     }
     return SXNET_add_id_INTEGER(psx, izone, user, userlen);
@@ -121,7 +121,7 @@ int SXNET_add_id_ulong(SXNET **psx, unsigned long lzone, const char *user,
 
     if ((izone = ASN1_INTEGER_new()) == NULL
         || !ASN1_INTEGER_set(izone, lzone)) {
-        X509V3err(X509V3_F_SXNET_ADD_ID_ULONG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         ASN1_INTEGER_free(izone);
         return 0;
     }
@@ -141,14 +141,13 @@ int SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, const char *user,
     SXNETID *id = NULL;
 
     if (psx == NULL || zone == NULL || user == NULL) {
-        X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,
-                  X509V3_R_INVALID_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NULL_ARGUMENT);
         return 0;
     }
     if (userlen == -1)
         userlen = strlen(user);
     if (userlen &gt; 64) {
-        X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, X509V3_R_USER_TOO_LONG);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_USER_TOO_LONG);
         return 0;
     }
     if (*psx == NULL) {
@@ -160,7 +159,7 @@ int SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, const char *user,
     } else
         sx = *psx;
     if (SXNET_get_id_INTEGER(sx, zone)) {
-        X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, X509V3_R_DUPLICATE_ZONE_ID);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_DUPLICATE_ZONE_ID);
         return 0;
     }
 
@@ -177,7 +176,7 @@ int SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, const char *user,
     return 1;
 
  err:
-    X509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
     SXNETID_free(id);
     SXNET_free(sx);
     *psx = NULL;
@@ -190,7 +189,7 @@ ASN1_OCTET_STRING *SXNET_get_id_asc(SXNET *sx, const char *zone)
     ASN1_OCTET_STRING *oct;
 
     if ((izone = s2i_ASN1_INTEGER(NULL, zone)) == NULL) {
-        X509V3err(X509V3_F_SXNET_GET_ID_ASC, X509V3_R_ERROR_CONVERTING_ZONE);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_ERROR_CONVERTING_ZONE);
         return NULL;
     }
     oct = SXNET_get_id_INTEGER(sx, izone);
@@ -205,7 +204,7 @@ ASN1_OCTET_STRING *SXNET_get_id_ulong(SXNET *sx, unsigned long lzone)
 
     if ((izone = ASN1_INTEGER_new()) == NULL
         || !ASN1_INTEGER_set(izone, lzone)) {
-        X509V3err(X509V3_F_SXNET_GET_ID_ULONG, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         ASN1_INTEGER_free(izone);
         return NULL;
     }
diff --git a/crypto/x509/v3_tlsf.c b/crypto/x509/v3_tlsf.c
index bc0a463dec..77904b5a1f 100644
--- a/crypto/x509/v3_tlsf.c
+++ b/crypto/x509/v3_tlsf.c
@@ -96,7 +96,7 @@ static TLS_FEATURE *v2i_TLS_FEATURE(const X509V3_EXT_METHOD *method,
     long tlsextid;
 
     if ((tlsf = sk_ASN1_INTEGER_new_null()) == NULL) {
-        X509V3err(X509V3_F_V2I_TLS_FEATURE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -116,7 +116,7 @@ static TLS_FEATURE *v2i_TLS_FEATURE(const X509V3_EXT_METHOD *method,
             tlsextid = strtol(extval, &amp;endptr, 10);
             if (((*endptr) != '\0') || (extval == endptr) || (tlsextid &lt; 0) ||
                 (tlsextid &gt; 65535)) {
-                X509V3err(X509V3_F_V2I_TLS_FEATURE, X509V3_R_INVALID_SYNTAX);
+                ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_SYNTAX);
                 X509V3_conf_add_error_name_value(val);
                 goto err;
             }
@@ -125,7 +125,7 @@ static TLS_FEATURE *v2i_TLS_FEATURE(const X509V3_EXT_METHOD *method,
         if ((ai = ASN1_INTEGER_new()) == NULL
                 || !ASN1_INTEGER_set(ai, tlsextid)
                 || sk_ASN1_INTEGER_push(tlsf, ai) &lt;= 0) {
-            X509V3err(X509V3_F_V2I_TLS_FEATURE, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         /* So it doesn't get purged if an error occurs next time around */
diff --git a/crypto/x509/v3_utf8.c b/crypto/x509/v3_utf8.c
index b3f87ac51f..d37ac73246 100644
--- a/crypto/x509/v3_utf8.c
+++ b/crypto/x509/v3_utf8.c
@@ -33,11 +33,11 @@ char *i2s_ASN1_UTF8STRING(X509V3_EXT_METHOD *method,
     char *tmp;
 
     if (utf8 == NULL || utf8-&gt;length == 0) {
-        X509V3err(X509V3_F_I2S_ASN1_UTF8STRING, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if ((tmp = OPENSSL_malloc(utf8-&gt;length + 1)) == NULL) {
-        X509V3err(X509V3_F_I2S_ASN1_UTF8STRING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     memcpy(tmp, utf8-&gt;data, utf8-&gt;length);
@@ -50,15 +50,15 @@ ASN1_UTF8STRING *s2i_ASN1_UTF8STRING(X509V3_EXT_METHOD *method,
 {
     ASN1_UTF8STRING *utf8;
     if (str == NULL) {
-        X509V3err(X509V3_F_S2I_ASN1_UTF8STRING, X509V3_R_INVALID_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NULL_ARGUMENT);
         return NULL;
     }
     if ((utf8 = ASN1_UTF8STRING_new()) == NULL) {
-        X509V3err(X509V3_F_S2I_ASN1_UTF8STRING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     if (!ASN1_STRING_set((ASN1_STRING *)utf8, str, strlen(str))) {
-        X509V3err(X509V3_F_S2I_ASN1_UTF8STRING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         ASN1_UTF8STRING_free(utf8);
         return NULL;
     }
diff --git a/crypto/x509/v3_utl.c b/crypto/x509/v3_utl.c
index 001c5f2296..4a8380d362 100644
--- a/crypto/x509/v3_utl.c
+++ b/crypto/x509/v3_utl.c
@@ -58,7 +58,7 @@ int X509V3_add_value(const char *name, const char *value,
         goto err;
     return 1;
  err:
-    X509V3err(X509V3_F_X509V3_ADD_VALUE, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
     if (sk_allocated) {
         sk_CONF_VALUE_free(*extlist);
         *extlist = NULL;
@@ -123,7 +123,7 @@ static char *bignum_to_string(const BIGNUM *bn)
     len = strlen(tmp) + 3;
     ret = OPENSSL_malloc(len);
     if (ret == NULL) {
-        X509V3err(X509V3_F_BIGNUM_TO_STRING, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(tmp);
         return NULL;
     }
@@ -149,7 +149,7 @@ char *i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *method, const ASN1_ENUMERATED *a)
         return NULL;
     if ((bntmp = ASN1_ENUMERATED_to_BN(a, NULL)) == NULL
         || (strtmp = bignum_to_string(bntmp)) == NULL)
-        X509V3err(X509V3_F_I2S_ASN1_ENUMERATED, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
     BN_free(bntmp);
     return strtmp;
 }
@@ -163,7 +163,7 @@ char *i2s_ASN1_INTEGER(X509V3_EXT_METHOD *method, const ASN1_INTEGER *a)
         return NULL;
     if ((bntmp = ASN1_INTEGER_to_BN(a, NULL)) == NULL
         || (strtmp = bignum_to_string(bntmp)) == NULL)
-        X509V3err(X509V3_F_I2S_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
     BN_free(bntmp);
     return strtmp;
 }
@@ -176,12 +176,12 @@ ASN1_INTEGER *s2i_ASN1_INTEGER(X509V3_EXT_METHOD *method, const char *value)
     int ret;
 
     if (value == NULL) {
-        X509V3err(X509V3_F_S2I_ASN1_INTEGER, X509V3_R_INVALID_NULL_VALUE);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NULL_VALUE);
         return NULL;
     }
     bn = BN_new();
     if (bn == NULL) {
-        X509V3err(X509V3_F_S2I_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     if (value[0] == '-') {
@@ -205,7 +205,7 @@ ASN1_INTEGER *s2i_ASN1_INTEGER(X509V3_EXT_METHOD *method, const char *value)
 
     if (!ret || value[ret]) {
         BN_free(bn);
-        X509V3err(X509V3_F_S2I_ASN1_INTEGER, X509V3_R_BN_DEC2BN_ERROR);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_BN_DEC2BN_ERROR);
         return NULL;
     }
 
@@ -215,8 +215,7 @@ ASN1_INTEGER *s2i_ASN1_INTEGER(X509V3_EXT_METHOD *method, const char *value)
     aint = BN_to_ASN1_INTEGER(bn, NULL);
     BN_free(bn);
     if (!aint) {
-        X509V3err(X509V3_F_S2I_ASN1_INTEGER,
-                  X509V3_R_BN_TO_ASN1_INTEGER_ERROR);
+        ERR_raise(ERR_LIB_X509V3, X509V3_R_BN_TO_ASN1_INTEGER_ERROR);
         return NULL;
     }
     if (isneg)
@@ -264,8 +263,7 @@ int X509V3_get_value_bool(const CONF_VALUE *value, int *asn1_bool)
         return 1;
     }
  err:
-    X509V3err(X509V3_F_X509V3_GET_VALUE_BOOL,
-              X509V3_R_INVALID_BOOLEAN_STRING);
+    ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_BOOLEAN_STRING);
     X509V3_conf_add_error_name_value(value);
     return 0;
 }
@@ -300,7 +298,7 @@ STACK_OF(CONF_VALUE) *X509V3_parse_list(const char *line)
     /* We are going to modify the line so copy it first */
     linebuf = OPENSSL_strdup(line);
     if (linebuf == NULL) {
-        X509V3err(X509V3_F_X509V3_PARSE_LIST, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     state = HDR_NAME;
@@ -316,8 +314,7 @@ STACK_OF(CONF_VALUE) *X509V3_parse_list(const char *line)
                 *p = 0;
                 ntmp = strip_spaces(q);
                 if (!ntmp) {
-                    X509V3err(X509V3_F_X509V3_PARSE_LIST,
-                              X509V3_R_INVALID_EMPTY_NAME);
+                    ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_EMPTY_NAME);
                     goto err;
                 }
                 q = p + 1;
@@ -326,8 +323,7 @@ STACK_OF(CONF_VALUE) *X509V3_parse_list(const char *line)
                 ntmp = strip_spaces(q);
                 q = p + 1;
                 if (!ntmp) {
-                    X509V3err(X509V3_F_X509V3_PARSE_LIST,
-                              X509V3_R_INVALID_EMPTY_NAME);
+                    ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_EMPTY_NAME);
                     goto err;
                 }
                 X509V3_add_value(ntmp, NULL, &amp;values);
@@ -340,8 +336,7 @@ STACK_OF(CONF_VALUE) *X509V3_parse_list(const char *line)
                 *p = 0;
                 vtmp = strip_spaces(q);
                 if (!vtmp) {
-                    X509V3err(X509V3_F_X509V3_PARSE_LIST,
-                              X509V3_R_INVALID_NULL_VALUE);
+                    ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NULL_VALUE);
                     goto err;
                 }
                 X509V3_add_value(ntmp, vtmp, &amp;values);
@@ -355,15 +350,14 @@ STACK_OF(CONF_VALUE) *X509V3_parse_list(const char *line)
     if (state == HDR_VALUE) {
         vtmp = strip_spaces(q);
         if (!vtmp) {
-            X509V3err(X509V3_F_X509V3_PARSE_LIST,
-                      X509V3_R_INVALID_NULL_VALUE);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NULL_VALUE);
             goto err;
         }
         X509V3_add_value(ntmp, vtmp, &amp;values);
     } else {
         ntmp = strip_spaces(q);
         if (!ntmp) {
-            X509V3err(X509V3_F_X509V3_PARSE_LIST, X509V3_R_INVALID_EMPTY_NAME);
+            ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_EMPTY_NAME);
             goto err;
         }
         X509V3_add_value(ntmp, NULL, &amp;values);
diff --git a/crypto/x509/x509_att.c b/crypto/x509/x509_att.c
index 6966d12c20..6a949f190e 100644
--- a/crypto/x509/x509_att.c
+++ b/crypto/x509/x509_att.c
@@ -77,7 +77,7 @@ STACK_OF(X509_ATTRIBUTE) *X509at_add1_attr(STACK_OF(X509_ATTRIBUTE) **x,
     STACK_OF(X509_ATTRIBUTE) *sk = NULL;
 
     if (x == NULL) {
-        X509err(X509_F_X509AT_ADD1_ATTR, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_X509, ERR_R_PASSED_NULL_PARAMETER);
         goto err2;
     }
 
@@ -95,7 +95,7 @@ STACK_OF(X509_ATTRIBUTE) *X509at_add1_attr(STACK_OF(X509_ATTRIBUTE) **x,
         *x = sk;
     return sk;
  err:
-    X509err(X509_F_X509AT_ADD1_ATTR, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
  err2:
     X509_ATTRIBUTE_free(new_attr);
     sk_X509_ATTRIBUTE_free(sk);
@@ -174,7 +174,7 @@ X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_NID(X509_ATTRIBUTE **attr, int nid,
 
     obj = OBJ_nid2obj(nid);
     if (obj == NULL) {
-        X509err(X509_F_X509_ATTRIBUTE_CREATE_BY_NID, X509_R_UNKNOWN_NID);
+        ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_NID);
         return NULL;
     }
     ret = X509_ATTRIBUTE_create_by_OBJ(attr, obj, atrtype, data, len);
@@ -192,8 +192,7 @@ X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_OBJ(X509_ATTRIBUTE **attr,
 
     if ((attr == NULL) || (*attr == NULL)) {
         if ((ret = X509_ATTRIBUTE_new()) == NULL) {
-            X509err(X509_F_X509_ATTRIBUTE_CREATE_BY_OBJ,
-                    ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     } else
@@ -223,9 +222,8 @@ X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_txt(X509_ATTRIBUTE **attr,
 
     obj = OBJ_txt2obj(atrname, 0);
     if (obj == NULL) {
-        X509err(X509_F_X509_ATTRIBUTE_CREATE_BY_TXT,
-                X509_R_INVALID_FIELD_NAME);
-        ERR_add_error_data(2, &quot;name=&quot;, atrname);
+        ERR_raise_data(ERR_LIB_X509, X509_R_INVALID_FIELD_NAME,
+                       &quot;name=%s&quot;, atrname);
         return NULL;
     }
     nattr = X509_ATTRIBUTE_create_by_OBJ(attr, obj, type, bytes, len);
@@ -254,7 +252,7 @@ int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype,
         stmp = ASN1_STRING_set_by_NID(NULL, data, len, attrtype,
                                       OBJ_obj2nid(attr-&gt;object));
         if (!stmp) {
-            X509err(X509_F_X509_ATTRIBUTE_SET1_DATA, ERR_R_ASN1_LIB);
+            ERR_raise(ERR_LIB_X509, ERR_R_ASN1_LIB);
             return 0;
         }
         atype = stmp-&gt;type;
@@ -287,7 +285,7 @@ int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype,
         goto err;
     return 1;
  err:
-    X509err(X509_F_X509_ATTRIBUTE_SET1_DATA, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
     ASN1_TYPE_free(ttmp);
     ASN1_STRING_free(stmp);
     return 0;
@@ -317,7 +315,7 @@ void *X509_ATTRIBUTE_get0_data(X509_ATTRIBUTE *attr, int idx,
     if (atrtype == V_ASN1_BOOLEAN
             || atrtype == V_ASN1_NULL
             || atrtype != ASN1_TYPE_get(ttmp)) {
-        X509err(X509_F_X509_ATTRIBUTE_GET0_DATA, X509_R_WRONG_TYPE);
+        ERR_raise(ERR_LIB_X509, X509_R_WRONG_TYPE);
         return NULL;
     }
     return ttmp-&gt;value.ptr;
diff --git a/crypto/x509/x509_cmp.c b/crypto/x509/x509_cmp.c
index e74c842fdc..da451eccce 100644
--- a/crypto/x509/x509_cmp.c
+++ b/crypto/x509/x509_cmp.c
@@ -167,7 +167,7 @@ int X509_add_cert_new(STACK_OF(X509) **sk, X509 *cert, int flags)
 {
     if (*sk == NULL
             &amp;&amp; (*sk = sk_X509_new_null()) == NULL) {
-        X509err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return X509_add_cert(*sk, cert, flags);
@@ -176,7 +176,7 @@ int X509_add_cert_new(STACK_OF(X509) **sk, X509 *cert, int flags)
 int X509_add_cert(STACK_OF(X509) *sk, X509 *cert, int flags)
 {
     if (sk == NULL) {
-        X509err(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_X509, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     if ((flags &amp; X509_ADD_FLAG_NO_DUP) != 0) {
@@ -195,7 +195,7 @@ int X509_add_cert(STACK_OF(X509) *sk, X509 *cert, int flags)
         return 1;
     if (!sk_X509_insert(sk, cert,
                         (flags &amp; X509_ADD_FLAG_PREPEND) != 0 ? 0 : -1)) {
-        X509err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     if ((flags &amp; X509_ADD_FLAG_UP_REF) != 0)
@@ -362,13 +362,13 @@ int X509_check_private_key(const X509 *x, const EVP_PKEY *k)
     case 1:
         break;
     case 0:
-        X509err(X509_F_X509_CHECK_PRIVATE_KEY, X509_R_KEY_VALUES_MISMATCH);
+        ERR_raise(ERR_LIB_X509, X509_R_KEY_VALUES_MISMATCH);
         break;
     case -1:
-        X509err(X509_F_X509_CHECK_PRIVATE_KEY, X509_R_KEY_TYPE_MISMATCH);
+        ERR_raise(ERR_LIB_X509, X509_R_KEY_TYPE_MISMATCH);
         break;
     case -2:
-        X509err(X509_F_X509_CHECK_PRIVATE_KEY, X509_R_UNKNOWN_KEY_TYPE);
+        ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_KEY_TYPE);
     }
     if (ret &gt; 0)
         return 1;
diff --git a/crypto/x509/x509_lu.c b/crypto/x509/x509_lu.c
index e591f16938..eb730bb24d 100644
--- a/crypto/x509/x509_lu.c
+++ b/crypto/x509/x509_lu.c
@@ -20,7 +20,7 @@ X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method)
     X509_LOOKUP *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        X509err(X509_F_X509_LOOKUP_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -182,31 +182,31 @@ X509_STORE *X509_STORE_new(void)
     X509_STORE *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        X509err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     if ((ret-&gt;objs = sk_X509_OBJECT_new(x509_object_cmp)) == NULL) {
-        X509err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     ret-&gt;cache = 1;
     if ((ret-&gt;get_cert_methods = sk_X509_LOOKUP_new_null()) == NULL) {
-        X509err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if ((ret-&gt;param = X509_VERIFY_PARAM_new()) == NULL) {
-        X509err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &amp;ret-&gt;ex_data)) {
-        X509err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     ret-&gt;lock = CRYPTO_THREAD_lock_new();
     if (ret-&gt;lock == NULL) {
-        X509err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     ret-&gt;references = 1;
@@ -277,7 +277,7 @@ X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)
     /* a new one */
     lu = X509_LOOKUP_new(m);
     if (lu == NULL) {
-        X509err(X509_F_X509_STORE_ADD_LOOKUP, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -285,7 +285,7 @@ X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)
     if (sk_X509_LOOKUP_push(v-&gt;get_cert_methods, lu))
         return lu;
     /* malloc failed */
-    X509err(X509_F_X509_STORE_ADD_LOOKUP, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
     X509_LOOKUP_free(lu);
     return NULL;
 }
@@ -389,7 +389,7 @@ static int x509_store_add(X509_STORE *store, void *x, int crl) {
 int X509_STORE_add_cert(X509_STORE *ctx, X509 *x)
 {
     if (!x509_store_add(ctx, x, 0)) {
-        X509err(X509_F_X509_STORE_ADD_CERT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return 1;
@@ -398,7 +398,7 @@ int X509_STORE_add_cert(X509_STORE *ctx, X509 *x)
 int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)
 {
     if (!x509_store_add(ctx, x, 1)) {
-        X509err(X509_F_X509_STORE_ADD_CRL, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     return 1;
@@ -441,7 +441,7 @@ X509_OBJECT *X509_OBJECT_new(void)
     X509_OBJECT *ret = OPENSSL_zalloc(sizeof(*ret));
 
     if (ret == NULL) {
-        X509err(X509_F_X509_OBJECT_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     ret-&gt;type = X509_LU_NONE;
@@ -561,7 +561,7 @@ STACK_OF(X509) *X509_STORE_get1_all_certs(X509_STORE *store)
     int i;
 
     if (store == NULL) {
-        X509err(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_X509, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
     if ((sk = sk_X509_new_null()) == NULL)
diff --git a/crypto/x509/x509_meth.c b/crypto/x509/x509_meth.c
index 05e7f7e29e..0159ee056a 100644
--- a/crypto/x509/x509_meth.c
+++ b/crypto/x509/x509_meth.c
@@ -24,7 +24,7 @@ X509_LOOKUP_METHOD *X509_LOOKUP_meth_new(const char *name)
     if (method != NULL) {
         method-&gt;name = OPENSSL_strdup(name);
         if (method-&gt;name == NULL) {
-            X509err(X509_F_X509_LOOKUP_METH_NEW, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
diff --git a/crypto/x509/x509_obj.c b/crypto/x509/x509_obj.c
index 0acfaa3589..12c6d6f78b 100644
--- a/crypto/x509/x509_obj.c
+++ b/crypto/x509/x509_obj.c
@@ -73,7 +73,7 @@ char *X509_NAME_oneline(const X509_NAME *a, char *buf, int len)
         type = ne-&gt;value-&gt;type;
         num = ne-&gt;value-&gt;length;
         if (num &gt; NAME_ONELINE_MAX) {
-            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);
+            ERR_raise(ERR_LIB_X509, X509_R_NAME_TOO_LONG);
             goto end;
         }
         q = ne-&gt;value-&gt;data;
@@ -119,7 +119,7 @@ char *X509_NAME_oneline(const X509_NAME *a, char *buf, int len)
         lold = l;
         l += 1 + l1 + 1 + l2;
         if (l &gt; NAME_ONELINE_MAX) {
-            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);
+            ERR_raise(ERR_LIB_X509, X509_R_NAME_TOO_LONG);
             goto end;
         }
         if (b != NULL) {
@@ -180,7 +180,7 @@ char *X509_NAME_oneline(const X509_NAME *a, char *buf, int len)
         *p = '\0';
     return p;
  err:
-    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
  end:
     BUF_MEM_free(b);
     return NULL;
diff --git a/crypto/x509/x509_r2x.c b/crypto/x509/x509_r2x.c
index a03ba24926..c7f6181c44 100644
--- a/crypto/x509/x509_r2x.c
+++ b/crypto/x509/x509_r2x.c
@@ -25,7 +25,7 @@ X509 *X509_REQ_to_X509(X509_REQ *r, int days, EVP_PKEY *pkey)
     EVP_PKEY *pubkey = NULL;
 
     if ((ret = X509_new()) == NULL) {
-        X509err(X509_F_X509_REQ_TO_X509, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
diff --git a/crypto/x509/x509_req.c b/crypto/x509/x509_req.c
index fcc07b17dd..3d59026832 100644
--- a/crypto/x509/x509_req.c
+++ b/crypto/x509/x509_req.c
@@ -28,7 +28,7 @@ X509_REQ *X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)
 
     ret = X509_REQ_new();
     if (ret == NULL) {
-        X509err(X509_F_X509_TO_X509_REQ, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -90,28 +90,26 @@ int X509_REQ_check_private_key(X509_REQ *x, EVP_PKEY *k)
         ok = 1;
         break;
     case 0:
-        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,
-                X509_R_KEY_VALUES_MISMATCH);
+        ERR_raise(ERR_LIB_X509, X509_R_KEY_VALUES_MISMATCH);
         break;
     case -1:
-        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_KEY_TYPE_MISMATCH);
+        ERR_raise(ERR_LIB_X509, X509_R_KEY_TYPE_MISMATCH);
         break;
     case -2:
 #ifndef OPENSSL_NO_EC
         if (EVP_PKEY_id(k) == EVP_PKEY_EC) {
-            X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, ERR_R_EC_LIB);
+            ERR_raise(ERR_LIB_X509, ERR_R_EC_LIB);
             break;
         }
 #endif
 #ifndef OPENSSL_NO_DH
         if (EVP_PKEY_id(k) == EVP_PKEY_DH) {
             /* No idea */
-            X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,
-                    X509_R_CANT_CHECK_DH_KEY);
+            ERR_raise(ERR_LIB_X509, X509_R_CANT_CHECK_DH_KEY);
             break;
         }
 #endif
-        X509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_UNKNOWN_KEY_TYPE);
+        ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_KEY_TYPE);
     }
 
     EVP_PKEY_free(xk);
diff --git a/crypto/x509/x509_set.c b/crypto/x509/x509_set.c
index 79e4c03ca3..52b9792d8f 100644
--- a/crypto/x509/x509_set.c
+++ b/crypto/x509/x509_set.c
@@ -206,7 +206,7 @@ static int x509_sig_info_init(X509_SIG_INFO *siginf, const X509_ALGOR *alg,
     siginf-&gt;flags = 0;
     if (!OBJ_find_sigid_algs(OBJ_obj2nid(alg-&gt;algorithm), &amp;mdnid, &amp;pknid)
             || pknid == NID_undef) {
-        X509err(0, X509_R_UNKNOWN_SIGID_ALGS);
+        ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_SIGID_ALGS);
         return 0;
     }
     siginf-&gt;mdnid = mdnid;
@@ -218,7 +218,7 @@ static int x509_sig_info_init(X509_SIG_INFO *siginf, const X509_ALGOR *alg,
         ameth = EVP_PKEY_asn1_find(NULL, pknid);
         if (ameth == NULL || ameth-&gt;siginf_set == NULL
                 || !ameth-&gt;siginf_set(siginf, alg, sig)) {
-            X509err(0, X509_R_ERROR_USING_SIGINF_SET);
+            ERR_raise(ERR_LIB_X509, X509_R_ERROR_USING_SIGINF_SET);
             return 0;
         }
         break;
@@ -252,7 +252,7 @@ static int x509_sig_info_init(X509_SIG_INFO *siginf, const X509_ALGOR *alg,
     default:
         /* Security bits: half number of bits in digest */
         if ((md = EVP_get_digestbynid(mdnid)) == NULL) {
-            X509err(0, X509_R_ERROR_GETTING_MD_BY_NID);
+            ERR_raise(ERR_LIB_X509, X509_R_ERROR_GETTING_MD_BY_NID);
             return 0;
         }
         siginf-&gt;secbits = EVP_MD_size(md) * 4;
diff --git a/crypto/x509/x509_trs.c b/crypto/x509/x509_trs.c
index 10718c347d..dd83dbc52f 100644
--- a/crypto/x509/x509_trs.c
+++ b/crypto/x509/x509_trs.c
@@ -113,7 +113,7 @@ int X509_TRUST_get_by_id(int id)
 int X509_TRUST_set(int *t, int trust)
 {
     if (X509_TRUST_get_by_id(trust) == -1) {
-        X509err(X509_F_X509_TRUST_SET, X509_R_INVALID_TRUST);
+        ERR_raise(ERR_LIB_X509, X509_R_INVALID_TRUST);
         return 0;
     }
     *t = trust;
@@ -136,7 +136,7 @@ int X509_TRUST_add(int id, int flags, int (*ck) (X509_TRUST *, X509 *, int),
     /* Need a new entry */
     if (idx == -1) {
         if ((trtmp = OPENSSL_malloc(sizeof(*trtmp))) == NULL) {
-            X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             return 0;
         }
         trtmp-&gt;flags = X509_TRUST_DYNAMIC;
@@ -148,7 +148,7 @@ int X509_TRUST_add(int id, int flags, int (*ck) (X509_TRUST *, X509 *, int),
         OPENSSL_free(trtmp-&gt;name);
     /* dup supplied name */
     if ((trtmp-&gt;name = OPENSSL_strdup(name)) == NULL) {
-        X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     /* Keep the dynamic flag of existing entry */
@@ -165,11 +165,11 @@ int X509_TRUST_add(int id, int flags, int (*ck) (X509_TRUST *, X509 *, int),
     if (idx == -1) {
         if (trtable == NULL
             &amp;&amp; (trtable = sk_X509_TRUST_new(tr_cmp)) == NULL) {
-            X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             goto err;;
         }
         if (!sk_X509_TRUST_push(trtable, trtmp)) {
-            X509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
diff --git a/crypto/x509/x509_v3.c b/crypto/x509/x509_v3.c
index 96ba940aa4..262061a20f 100644
--- a/crypto/x509/x509_v3.c
+++ b/crypto/x509/x509_v3.c
@@ -101,7 +101,7 @@ STACK_OF(X509_EXTENSION) *X509v3_add_ext(STACK_OF(X509_EXTENSION) **x,
     STACK_OF(X509_EXTENSION) *sk = NULL;
 
     if (x == NULL) {
-        X509err(X509_F_X509V3_ADD_EXT, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_X509, ERR_R_PASSED_NULL_PARAMETER);
         goto err2;
     }
 
@@ -125,7 +125,7 @@ STACK_OF(X509_EXTENSION) *X509v3_add_ext(STACK_OF(X509_EXTENSION) **x,
         *x = sk;
     return sk;
  err:
-    X509err(X509_F_X509V3_ADD_EXT, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
  err2:
     X509_EXTENSION_free(new_ex);
     if (x != NULL &amp;&amp; *x == NULL)
@@ -142,7 +142,7 @@ X509_EXTENSION *X509_EXTENSION_create_by_NID(X509_EXTENSION **ex, int nid,
 
     obj = OBJ_nid2obj(nid);
     if (obj == NULL) {
-        X509err(X509_F_X509_EXTENSION_CREATE_BY_NID, X509_R_UNKNOWN_NID);
+        ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_NID);
         return NULL;
     }
     ret = X509_EXTENSION_create_by_OBJ(ex, obj, crit, data);
@@ -159,8 +159,7 @@ X509_EXTENSION *X509_EXTENSION_create_by_OBJ(X509_EXTENSION **ex,
 
     if ((ex == NULL) || (*ex == NULL)) {
         if ((ret = X509_EXTENSION_new()) == NULL) {
-            X509err(X509_F_X509_EXTENSION_CREATE_BY_OBJ,
-                    ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     } else
diff --git a/crypto/x509/x509_vfy.c b/crypto/x509/x509_vfy.c
index 66e0a51694..1ee688f3b8 100644
--- a/crypto/x509/x509_vfy.c
+++ b/crypto/x509/x509_vfy.c
@@ -117,7 +117,7 @@ int X509_self_signed(X509 *cert, int verify_signature)
     EVP_PKEY *pkey;
 
     if ((pkey = X509_get0_pubkey(cert)) == NULL) { /* handles cert == NULL */
-        X509err(0, X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);
+        ERR_raise(ERR_LIB_X509, X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);
         return -1;
     }
     if (!x509v3_cache_extensions(cert))
@@ -263,7 +263,7 @@ int X509_verify_cert(X509_STORE_CTX *ctx)
     int ret;
 
     if (ctx-&gt;cert == NULL) {
-        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
+        ERR_raise(ERR_LIB_X509, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
         ctx-&gt;error = X509_V_ERR_INVALID_CALL;
         return -1;
     }
@@ -273,7 +273,7 @@ int X509_verify_cert(X509_STORE_CTX *ctx)
          * This X509_STORE_CTX has already been used to verify a cert. We
          * cannot do another one.
          */
-        X509err(X509_F_X509_VERIFY_CERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ERR_raise(ERR_LIB_X509, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
         ctx-&gt;error = X509_V_ERR_INVALID_CALL;
         return -1;
     }
@@ -700,7 +700,7 @@ static int check_name_constraints(X509_STORE_CTX *ctx)
              */
             tmpsubject = X509_NAME_dup(tmpsubject);
             if (tmpsubject == NULL) {
-                X509err(X509_F_CHECK_NAME_CONSTRAINTS, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
                 ctx-&gt;error = X509_V_ERR_OUT_OF_MEM;
                 return 0;
             }
@@ -1658,7 +1658,7 @@ static int check_policy(X509_STORE_CTX *ctx)
      * X509_policy_check() call.
      */
     if (ctx-&gt;bare_ta_signed &amp;&amp; !sk_X509_push(ctx-&gt;chain, NULL)) {
-        X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         ctx-&gt;error = X509_V_ERR_OUT_OF_MEM;
         return 0;
     }
@@ -1668,7 +1668,7 @@ static int check_policy(X509_STORE_CTX *ctx)
         (void)sk_X509_pop(ctx-&gt;chain);
 
     if (ret == X509_PCY_TREE_INTERNAL) {
-        X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         ctx-&gt;error = X509_V_ERR_OUT_OF_MEM;
         return 0;
     }
@@ -1691,7 +1691,7 @@ static int check_policy(X509_STORE_CTX *ctx)
         return ctx-&gt;verify_cb(0, ctx);
     }
     if (ret != X509_PCY_TREE_VALID) {
-        X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
         return 0;
     }
 
@@ -1992,16 +1992,14 @@ int X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)
     for (i = 0; i &lt; sk_X509_num(chain); i++) {
         ktmp = X509_get0_pubkey(sk_X509_value(chain, i));
         if (ktmp == NULL) {
-            X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,
-                    X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);
+            ERR_raise(ERR_LIB_X509, X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);
             return 0;
         }
         if (!EVP_PKEY_missing_parameters(ktmp))
             break;
     }
     if (ktmp == NULL) {
-        X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,
-                X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);
+        ERR_raise(ERR_LIB_X509, X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);
         return 0;
     }
 
@@ -2026,37 +2024,37 @@ X509_CRL *X509_CRL_diff(X509_CRL *base, X509_CRL *newer,
     STACK_OF(X509_REVOKED) *revs = NULL;
     /* CRLs can't be delta already */
     if (base-&gt;base_crl_number || newer-&gt;base_crl_number) {
-        X509err(X509_F_X509_CRL_DIFF, X509_R_CRL_ALREADY_DELTA);
+        ERR_raise(ERR_LIB_X509, X509_R_CRL_ALREADY_DELTA);
         return NULL;
     }
     /* Base and new CRL must have a CRL number */
     if (!base-&gt;crl_number || !newer-&gt;crl_number) {
-        X509err(X509_F_X509_CRL_DIFF, X509_R_NO_CRL_NUMBER);
+        ERR_raise(ERR_LIB_X509, X509_R_NO_CRL_NUMBER);
         return NULL;
     }
     /* Issuer names must match */
     if (X509_NAME_cmp(X509_CRL_get_issuer(base), X509_CRL_get_issuer(newer))) {
-        X509err(X509_F_X509_CRL_DIFF, X509_R_ISSUER_MISMATCH);
+        ERR_raise(ERR_LIB_X509, X509_R_ISSUER_MISMATCH);
         return NULL;
     }
     /* AKID and IDP must match */
     if (!crl_extension_match(base, newer, NID_authority_key_identifier)) {
-        X509err(X509_F_X509_CRL_DIFF, X509_R_AKID_MISMATCH);
+        ERR_raise(ERR_LIB_X509, X509_R_AKID_MISMATCH);
         return NULL;
     }
     if (!crl_extension_match(base, newer, NID_issuing_distribution_point)) {
-        X509err(X509_F_X509_CRL_DIFF, X509_R_IDP_MISMATCH);
+        ERR_raise(ERR_LIB_X509, X509_R_IDP_MISMATCH);
         return NULL;
     }
     /* Newer CRL number must exceed full CRL number */
     if (ASN1_INTEGER_cmp(newer-&gt;crl_number, base-&gt;crl_number) &lt;= 0) {
-        X509err(X509_F_X509_CRL_DIFF, X509_R_NEWER_CRL_NOT_NEWER);
+        ERR_raise(ERR_LIB_X509, X509_R_NEWER_CRL_NOT_NEWER);
         return NULL;
     }
     /* CRLs must verify */
     if (skey &amp;&amp; (X509_CRL_verify(base, skey) &lt;= 0 ||
                  X509_CRL_verify(newer, skey) &lt;= 0)) {
-        X509err(X509_F_X509_CRL_DIFF, X509_R_CRL_VERIFY_FAILURE);
+        ERR_raise(ERR_LIB_X509, X509_R_CRL_VERIFY_FAILURE);
         return NULL;
     }
     /* Create new CRL */
@@ -2118,7 +2116,7 @@ X509_CRL *X509_CRL_diff(X509_CRL *base, X509_CRL *newer,
     return crl;
 
  memerr:
-    X509err(X509_F_X509_CRL_DIFF, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
     X509_CRL_free(crl);
     return NULL;
 }
@@ -2242,8 +2240,7 @@ int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
         X509_PURPOSE *ptmp;
         idx = X509_PURPOSE_get_by_id(purpose);
         if (idx == -1) {
-            X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
-                    X509_R_UNKNOWN_PURPOSE_ID);
+            ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_PURPOSE_ID);
             return 0;
         }
         ptmp = X509_PURPOSE_get0(idx);
@@ -2255,8 +2252,7 @@ int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
              * X509_TRUST_DEFAULT case actually supposed to be handled?
              */
             if (idx == -1) {
-                X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
-                        X509_R_UNKNOWN_PURPOSE_ID);
+                ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_PURPOSE_ID);
                 return 0;
             }
             ptmp = X509_PURPOSE_get0(idx);
@@ -2268,8 +2264,7 @@ int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
     if (trust) {
         idx = X509_TRUST_get_by_id(trust);
         if (idx == -1) {
-            X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
-                    X509_R_UNKNOWN_TRUST_ID);
+            ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_TRUST_ID);
             return 0;
         }
     }
@@ -2286,7 +2281,7 @@ X509_STORE_CTX *X509_STORE_CTX_new_ex(OSSL_LIB_CTX *libctx, const char *propq)
     X509_STORE_CTX *ctx = OPENSSL_zalloc(sizeof(*ctx));
 
     if (ctx == NULL) {
-        X509err(0, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -2295,7 +2290,7 @@ X509_STORE_CTX *X509_STORE_CTX_new_ex(OSSL_LIB_CTX *libctx, const char *propq)
         ctx-&gt;propq = OPENSSL_strdup(propq);
         if (ctx-&gt;propq == NULL) {
             OPENSSL_free(ctx);
-            X509err(0, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
     }
@@ -2413,7 +2408,7 @@ int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
 
     ctx-&gt;param = X509_VERIFY_PARAM_new();
     if (ctx-&gt;param == NULL) {
-        X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -2430,7 +2425,7 @@ int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
                                         X509_VERIFY_PARAM_lookup(&quot;default&quot;));
 
     if (ret == 0) {
-        X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -2449,7 +2444,7 @@ int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
     if (CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx,
                            &amp;ctx-&gt;ex_data))
         return 1;
-    X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
 
  err:
     /*
@@ -2671,12 +2666,12 @@ static unsigned char *dane_i2d(
         len = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(cert), &amp;buf);
         break;
     default:
-        X509err(X509_F_DANE_I2D, X509_R_BAD_SELECTOR);
+        ERR_raise(ERR_LIB_X509, X509_R_BAD_SELECTOR);
         return NULL;
     }
 
     if (len &lt; 0 || buf == NULL) {
-        X509err(X509_F_DANE_I2D, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
@@ -3004,7 +2999,7 @@ static int build_chain(X509_STORE_CTX *ctx)
 
     /* Our chain starts with a single untrusted element. */
     if (!ossl_assert(num == 1 &amp;&amp; ctx-&gt;num_untrusted == num))  {
-        X509err(X509_F_BUILD_CHAIN, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
         ctx-&gt;error = X509_V_ERR_UNSPECIFIED;
         return 0;
     }
@@ -3040,7 +3035,7 @@ static int build_chain(X509_STORE_CTX *ctx)
      * multiple passes over it, while free to remove elements as we go.
      */
     if (ctx-&gt;untrusted &amp;&amp; (sktmp = sk_X509_dup(ctx-&gt;untrusted)) == NULL) {
-        X509err(X509_F_BUILD_CHAIN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         ctx-&gt;error = X509_V_ERR_OUT_OF_MEM;
         return 0;
     }
@@ -3057,7 +3052,7 @@ static int build_chain(X509_STORE_CTX *ctx)
      */
     if (DANETLS_ENABLED(dane) &amp;&amp; dane-&gt;certs != NULL) {
         if (sktmp == NULL &amp;&amp; (sktmp = sk_X509_new_null()) == NULL) {
-            X509err(X509_F_BUILD_CHAIN, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             ctx-&gt;error = X509_V_ERR_OUT_OF_MEM;
             return 0;
         }
@@ -3148,7 +3143,7 @@ static int build_chain(X509_STORE_CTX *ctx)
                  */
                 if ((search &amp; S_DOALTERNATE) != 0) {
                     if (!ossl_assert(num &gt; i &amp;&amp; i &gt; 0 &amp;&amp; !self_signed)) {
-                        X509err(X509_F_BUILD_CHAIN, ERR_R_INTERNAL_ERROR);
+                        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
                         X509_free(xtmp);
                         trust = X509_TRUST_REJECTED;
                         ctx-&gt;error = X509_V_ERR_UNSPECIFIED;
@@ -3178,7 +3173,7 @@ static int build_chain(X509_STORE_CTX *ctx)
                 if (!self_signed) {
                     if (!sk_X509_push(ctx-&gt;chain, x = xtmp)) {
                         X509_free(xtmp);
-                        X509err(X509_F_BUILD_CHAIN, ERR_R_MALLOC_FAILURE);
+                        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
                         trust = X509_TRUST_REJECTED;
                         ctx-&gt;error = X509_V_ERR_OUT_OF_MEM;
                         search = 0;
@@ -3223,7 +3218,7 @@ static int build_chain(X509_STORE_CTX *ctx)
                  */
                 if (ok) {
                     if (!ossl_assert(ctx-&gt;num_untrusted &lt;= num)) {
-                        X509err(X509_F_BUILD_CHAIN, ERR_R_INTERNAL_ERROR);
+                        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
                         trust = X509_TRUST_REJECTED;
                         ctx-&gt;error = X509_V_ERR_UNSPECIFIED;
                         search = 0;
@@ -3268,7 +3263,7 @@ static int build_chain(X509_STORE_CTX *ctx)
         if ((search &amp; S_DOUNTRUSTED) != 0) {
             num = sk_X509_num(ctx-&gt;chain);
             if (!ossl_assert(num == ctx-&gt;num_untrusted)) {
-                X509err(X509_F_BUILD_CHAIN, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
                 trust = X509_TRUST_REJECTED;
                 ctx-&gt;error = X509_V_ERR_UNSPECIFIED;
                 search = 0;
@@ -3293,7 +3288,7 @@ static int build_chain(X509_STORE_CTX *ctx)
             (void) sk_X509_delete_ptr(sktmp, xtmp);
 
             if (!X509_up_ref(xtmp)) {
-                X509err(X509_F_BUILD_CHAIN, ERR_R_INTERNAL_ERROR);
+                ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
                 trust = X509_TRUST_REJECTED;
                 ctx-&gt;error = X509_V_ERR_UNSPECIFIED;
                 search = 0;
@@ -3302,7 +3297,7 @@ static int build_chain(X509_STORE_CTX *ctx)
 
             if (!sk_X509_push(ctx-&gt;chain, xtmp)) {
                 X509_free(xtmp);
-                X509err(X509_F_BUILD_CHAIN, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
                 trust = X509_TRUST_REJECTED;
                 ctx-&gt;error = X509_V_ERR_OUT_OF_MEM;
                 search = 0;
diff --git a/crypto/x509/x509_vpm.c b/crypto/x509/x509_vpm.c
index a429d5a5ae..025232e857 100644
--- a/crypto/x509/x509_vpm.c
+++ b/crypto/x509/x509_vpm.c
@@ -85,7 +85,7 @@ X509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void)
 
     param = OPENSSL_zalloc(sizeof(*param));
     if (param == NULL) {
-        X509err(X509_F_X509_VERIFY_PARAM_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     param-&gt;trust = X509_TRUST_DEFAULT;
diff --git a/crypto/x509/x509name.c b/crypto/x509/x509name.c
index b00e5f5b38..690e2799ff 100644
--- a/crypto/x509/x509name.c
+++ b/crypto/x509/x509name.c
@@ -222,7 +222,7 @@ int X509_NAME_add_entry(X509_NAME *name, const X509_NAME_ENTRY *ne, int loc,
         goto err;
     new_name-&gt;set = set;
     if (!sk_X509_NAME_ENTRY_insert(sk, new_name, loc)) {
-        X509err(X509_F_X509_NAME_ADD_ENTRY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     if (inc) {
@@ -246,9 +246,8 @@ X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne,
 
     obj = OBJ_txt2obj(field, 0);
     if (obj == NULL) {
-        X509err(X509_F_X509_NAME_ENTRY_CREATE_BY_TXT,
-                X509_R_INVALID_FIELD_NAME);
-        ERR_add_error_data(2, &quot;name=&quot;, field);
+        ERR_raise_data(ERR_LIB_X509, X509_R_INVALID_FIELD_NAME,
+                       &quot;name=%s&quot;, field);
         return NULL;
     }
     nentry = X509_NAME_ENTRY_create_by_OBJ(ne, obj, type, bytes, len);
@@ -266,7 +265,7 @@ X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid,
 
     obj = OBJ_nid2obj(nid);
     if (obj == NULL) {
-        X509err(X509_F_X509_NAME_ENTRY_CREATE_BY_NID, X509_R_UNKNOWN_NID);
+        ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_NID);
         return NULL;
     }
     nentry = X509_NAME_ENTRY_create_by_OBJ(ne, obj, type, bytes, len);
@@ -304,8 +303,7 @@ X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne,
 int X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne, const ASN1_OBJECT *obj)
 {
     if ((ne == NULL) || (obj == NULL)) {
-        X509err(X509_F_X509_NAME_ENTRY_SET_OBJECT,
-                ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_X509, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
     ASN1_OBJECT_free(ne-&gt;object);
diff --git a/crypto/x509/x509spki.c b/crypto/x509/x509spki.c
index ef8fe13c08..73609ec5f7 100644
--- a/crypto/x509/x509spki.c
+++ b/crypto/x509/x509spki.c
@@ -36,12 +36,12 @@ NETSCAPE_SPKI *NETSCAPE_SPKI_b64_decode(const char *str, int len)
     if (len &lt;= 0)
         len = strlen(str);
     if ((spki_der = OPENSSL_malloc(len + 1)) == NULL) {
-        X509err(X509_F_NETSCAPE_SPKI_B64_DECODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     spki_len = EVP_DecodeBlock(spki_der, (const unsigned char *)str, len);
     if (spki_len &lt; 0) {
-        X509err(X509_F_NETSCAPE_SPKI_B64_DECODE, X509_R_BASE64_DECODE_ERROR);
+        ERR_raise(ERR_LIB_X509, X509_R_BASE64_DECODE_ERROR);
         OPENSSL_free(spki_der);
         return NULL;
     }
@@ -62,7 +62,7 @@ char *NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *spki)
     der_spki = OPENSSL_malloc(der_len);
     b64_str = OPENSSL_malloc(der_len * 2);
     if (der_spki == NULL || b64_str == NULL) {
-        X509err(X509_F_NETSCAPE_SPKI_B64_ENCODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         OPENSSL_free(der_spki);
         OPENSSL_free(b64_str);
         return NULL;
diff --git a/crypto/x509/x_all.c b/crypto/x509/x_all.c
index 20b048c4a3..96dda91a95 100644
--- a/crypto/x509/x_all.c
+++ b/crypto/x509/x_all.c
@@ -416,13 +416,13 @@ ASN1_OCTET_STRING *X509_digest_sig(const X509 *cert)
     ASN1_OCTET_STRING *new = NULL;
 
     if (cert == NULL) {
-        X509err(0, ERR_R_PASSED_NULL_PARAMETER);
+        ERR_raise(ERR_LIB_X509, ERR_R_PASSED_NULL_PARAMETER);
         return NULL;
     }
 
     if (!OBJ_find_sigid_algs(X509_get_signature_nid(cert), &amp;md_NID, NULL)
             || (md = EVP_get_digestbynid(md_NID)) == NULL) {
-        CMPerr(0, X509_R_UNSUPPORTED_ALGORITHM);
+        ERR_raise(ERR_LIB_CMP, X509_R_UNSUPPORTED_ALGORITHM);
         return NULL;
     }
     if (!X509_digest(cert, md, hash, &amp;len)
@@ -562,7 +562,7 @@ EVP_PKEY *d2i_PrivateKey_ex_fp(FILE *fp, EVP_PKEY **a, OSSL_LIB_CTX *libctx,
     void *ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        X509err(0, ERR_R_BUF_LIB);
+        ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);
         return NULL;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
diff --git a/crypto/x509/x_crl.c b/crypto/x509/x_crl.c
index 17c9305f5c..1ec7925513 100644
--- a/crypto/x509/x_crl.c
+++ b/crypto/x509/x_crl.c
@@ -339,7 +339,7 @@ int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev)
     if (inf-&gt;revoked == NULL)
         inf-&gt;revoked = sk_X509_REVOKED_new(X509_REVOKED_cmp);
     if (inf-&gt;revoked == NULL || !sk_X509_REVOKED_push(inf-&gt;revoked, rev)) {
-        ASN1err(ASN1_F_X509_CRL_ADD0_REVOKED, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return 0;
     }
     inf-&gt;enc.modified = 1;
@@ -462,7 +462,7 @@ X509_CRL_METHOD *X509_CRL_METHOD_new(int (*crl_init) (X509_CRL *crl),
     X509_CRL_METHOD *m = OPENSSL_malloc(sizeof(*m));
 
     if (m == NULL) {
-        X509err(X509_F_X509_CRL_METHOD_NEW, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
     m-&gt;crl_init = crl_init;
diff --git a/crypto/x509/x_name.c b/crypto/x509/x_name.c
index a85b10f1cf..7b59b71ffb 100644
--- a/crypto/x509/x_name.c
+++ b/crypto/x509/x_name.c
@@ -102,7 +102,7 @@ static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it)
     return 1;
 
  memerr:
-    ASN1err(ASN1_F_X509_NAME_EX_NEW, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
     if (ret) {
         sk_X509_NAME_ENTRY_free(ret-&gt;entries);
         OPENSSL_free(ret);
@@ -204,7 +204,7 @@ static int x509_name_ex_d2i(ASN1_VALUE **val,
         X509_NAME_free(nm.x);
     sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname.s,
                                          local_sk_X509_NAME_ENTRY_pop_free);
-    ASN1err(ASN1_F_X509_NAME_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
+    ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);
     return 0;
 }
 
@@ -276,7 +276,7 @@ static int x509_name_encode(X509_NAME *a)
  memerr:
     sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname.s,
                                          local_sk_X509_NAME_ENTRY_free);
-    ASN1err(ASN1_F_X509_NAME_ENCODE, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
     return -1;
 }
 
@@ -317,7 +317,7 @@ static int x509_name_canon(X509_NAME *a)
     }
     intname = sk_STACK_OF_X509_NAME_ENTRY_new_null();
     if (intname == NULL) {
-        X509err(X509_F_X509_NAME_CANON, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
     for (i = 0; i &lt; sk_X509_NAME_ENTRY_num(a-&gt;entries); i++) {
@@ -328,25 +328,25 @@ static int x509_name_canon(X509_NAME *a)
                 goto err;
             if (!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries)) {
                 sk_X509_NAME_ENTRY_free(entries);
-                X509err(X509_F_X509_NAME_CANON, ERR_R_MALLOC_FAILURE);
+                ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
                 goto err;
             }
             set = entry-&gt;set;
         }
         tmpentry = X509_NAME_ENTRY_new();
         if (tmpentry == NULL) {
-            X509err(X509_F_X509_NAME_CANON, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         tmpentry-&gt;object = OBJ_dup(entry-&gt;object);
         if (tmpentry-&gt;object == NULL) {
-            X509err(X509_F_X509_NAME_CANON, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         if (!asn1_string_canon(tmpentry-&gt;value, entry-&gt;value))
             goto err;
         if (!sk_X509_NAME_ENTRY_push(entries, tmpentry)) {
-            X509err(X509_F_X509_NAME_CANON, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             goto err;
         }
         tmpentry = NULL;
@@ -360,7 +360,7 @@ static int x509_name_canon(X509_NAME *a)
 
     p = OPENSSL_malloc(a-&gt;canon_enclen);
     if (p == NULL) {
-        X509err(X509_F_X509_NAME_CANON, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
@@ -537,7 +537,7 @@ int X509_NAME_print(BIO *bp, const X509_NAME *name, int obase)
     OPENSSL_free(b);
     return 1;
  err:
-    X509err(X509_F_X509_NAME_PRINT, ERR_R_BUF_LIB);
+    ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);
     OPENSSL_free(b);
     return 0;
 }
diff --git a/crypto/x509/x_pubkey.c b/crypto/x509/x_pubkey.c
index b24ed8ff46..674b7d48cf 100644
--- a/crypto/x509/x_pubkey.c
+++ b/crypto/x509/x_pubkey.c
@@ -85,17 +85,16 @@ int X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey)
 
     if (pkey-&gt;ameth != NULL) {
         if ((pk = X509_PUBKEY_new()) == NULL) {
-            X509err(X509_F_X509_PUBKEY_SET, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
             goto error;
         }
         if (pkey-&gt;ameth-&gt;pub_encode != NULL) {
             if (!pkey-&gt;ameth-&gt;pub_encode(pk, pkey)) {
-                X509err(X509_F_X509_PUBKEY_SET,
-                        X509_R_PUBLIC_KEY_ENCODE_ERROR);
+                ERR_raise(ERR_LIB_X509, X509_R_PUBLIC_KEY_ENCODE_ERROR);
                 goto error;
             }
         } else {
-            X509err(X509_F_X509_PUBKEY_SET, X509_R_METHOD_NOT_SUPPORTED);
+            ERR_raise(ERR_LIB_X509, X509_R_METHOD_NOT_SUPPORTED);
             goto error;
         }
     } else if (evp_pkey_is_provided(pkey)) {
@@ -123,7 +122,7 @@ int X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey)
 
     X509_PUBKEY_free(*x);
     if (!EVP_PKEY_up_ref(pkey)) {
-        X509err(X509_F_X509_PUBKEY_SET, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
         goto error;
     }
     *x = pk;
@@ -147,7 +146,7 @@ int X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey)
     return 1;
 
  unsupported:
-    X509err(X509_F_X509_PUBKEY_SET, X509_R_UNSUPPORTED_ALGORITHM);
+    ERR_raise(ERR_LIB_X509, X509_R_UNSUPPORTED_ALGORITHM);
 
  error:
     X509_PUBKEY_free(pk);
@@ -166,12 +165,12 @@ static int x509_pubkey_decode(EVP_PKEY **ppkey, const X509_PUBKEY *key)
     EVP_PKEY *pkey = EVP_PKEY_new();
 
     if (pkey == NULL) {
-        X509err(X509_F_X509_PUBKEY_DECODE, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
     if (!EVP_PKEY_set_type(pkey, OBJ_obj2nid(key-&gt;algor-&gt;algorithm))) {
-        X509err(X509_F_X509_PUBKEY_DECODE, X509_R_UNSUPPORTED_ALGORITHM);
+        ERR_raise(ERR_LIB_X509, X509_R_UNSUPPORTED_ALGORITHM);
         goto error;
     }
 
@@ -184,7 +183,7 @@ static int x509_pubkey_decode(EVP_PKEY **ppkey, const X509_PUBKEY *key)
         if (!pkey-&gt;ameth-&gt;pub_decode(pkey, key))
             goto error;
     } else {
-        X509err(X509_F_X509_PUBKEY_DECODE, X509_R_METHOD_NOT_SUPPORTED);
+        ERR_raise(ERR_LIB_X509, X509_R_METHOD_NOT_SUPPORTED);
         goto error;
     }
 
@@ -217,7 +216,7 @@ EVP_PKEY *X509_PUBKEY_get0(const X509_PUBKEY *key)
     x509_pubkey_decode(&amp;ret, key);
     /* If decode doesn't fail something bad happened */
     if (ret != NULL) {
-        X509err(X509_F_X509_PUBKEY_GET0, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
         EVP_PKEY_free(ret);
     }
 
@@ -229,7 +228,7 @@ EVP_PKEY *X509_PUBKEY_get(const X509_PUBKEY *key)
     EVP_PKEY *ret = X509_PUBKEY_get0(key);
 
     if (ret != NULL &amp;&amp; !EVP_PKEY_up_ref(ret)) {
-        X509err(X509_F_X509_PUBKEY_GET, ERR_R_INTERNAL_ERROR);
+        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);
         ret = NULL;
     }
     return ret;
@@ -374,7 +373,7 @@ int i2d_RSA_PUBKEY(const RSA *a, unsigned char **pp)
         return 0;
     pktmp = EVP_PKEY_new();
     if (pktmp == NULL) {
-        ASN1err(ASN1_F_I2D_RSA_PUBKEY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return -1;
     }
     (void)EVP_PKEY_assign_RSA(pktmp, (RSA *)a);
@@ -416,7 +415,7 @@ int i2d_DSA_PUBKEY(const DSA *a, unsigned char **pp)
         return 0;
     pktmp = EVP_PKEY_new();
     if (pktmp == NULL) {
-        ASN1err(ASN1_F_I2D_DSA_PUBKEY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return -1;
     }
     (void)EVP_PKEY_assign_DSA(pktmp, (DSA *)a);
@@ -458,7 +457,7 @@ int i2d_EC_PUBKEY(const EC_KEY *a, unsigned char **pp)
     if (a == NULL)
         return 0;
     if ((pktmp = EVP_PKEY_new()) == NULL) {
-        ASN1err(ASN1_F_I2D_EC_PUBKEY, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_ASN1, ERR_R_MALLOC_FAILURE);
         return -1;
     }
     (void)EVP_PKEY_assign_EC_KEY(pktmp, (EC_KEY *)a);
diff --git a/crypto/x509/x_x509.c b/crypto/x509/x_x509.c
index 13b816fcde..f929fd2ae3 100644
--- a/crypto/x509/x_x509.c
+++ b/crypto/x509/x_x509.c
@@ -255,7 +255,7 @@ int i2d_X509_AUX(const X509 *a, unsigned char **pp)
     /* Allocate requisite combined storage */
     *pp = tmp = OPENSSL_malloc(length);
     if (tmp == NULL) {
-        X509err(X509_F_I2D_X509_AUX, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
diff --git a/fuzz/cmp.c b/fuzz/cmp.c
index a0dc20c619..ae4c1ec753 100644
--- a/fuzz/cmp.c
+++ b/fuzz/cmp.c
@@ -109,7 +109,7 @@ static OSSL_CMP_PKISI *process_cert_request(OSSL_CMP_SRV_CTX *srv_ctx,
                                             STACK_OF(X509) **chainOut,
                                             STACK_OF(X509) **caPubs)
 {
-    CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
     return NULL;
 }
 
@@ -118,7 +118,7 @@ static OSSL_CMP_PKISI *process_rr(OSSL_CMP_SRV_CTX *srv_ctx,
                                   const X509_NAME *issuer,
                                   const ASN1_INTEGER *serial)
 {
-    CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
     return NULL;
 }
 
@@ -127,7 +127,7 @@ static int process_genm(OSSL_CMP_SRV_CTX *srv_ctx,
                         const STACK_OF(OSSL_CMP_ITAV) *in,
                         STACK_OF(OSSL_CMP_ITAV) **out)
 {
-    CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
     return 0;
 }
 
@@ -136,7 +136,7 @@ static void process_error(OSSL_CMP_SRV_CTX *srv_ctx, const OSSL_CMP_MSG *error,
                           const ASN1_INTEGER *errorCode,
                           const OSSL_CMP_PKIFREETEXT *errorDetails)
 {
-    CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
 }
 
 static int process_certConf(OSSL_CMP_SRV_CTX *srv_ctx,
@@ -144,7 +144,7 @@ static int process_certConf(OSSL_CMP_SRV_CTX *srv_ctx,
                             const ASN1_OCTET_STRING *certHash,
                             const OSSL_CMP_PKISI *si)
 {
-    CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
     return 0;
 }
 
@@ -152,7 +152,7 @@ static int process_pollReq(OSSL_CMP_SRV_CTX *srv_ctx,
                            const OSSL_CMP_MSG *pollReq, int certReqId,
                            OSSL_CMP_MSG **certReq, int64_t *check_after)
 {
-    CMPerr(0, CMP_R_ERROR_PROCESSING_MESSAGE);
+    ERR_raise(ERR_LIB_CMP, CMP_R_ERROR_PROCESSING_MESSAGE);
     return 0;
 }
 
diff --git a/test/cmp_ctx_test.c b/test/cmp_ctx_test.c
index 72972fbaca..76c8c4613b 100644
--- a/test/cmp_ctx_test.c
+++ b/test/cmp_ctx_test.c
@@ -143,7 +143,7 @@ static int execute_CTX_print_errors_test(OSSL_CMP_CTX_TEST_FIXTURE *fixture)
         res = 0;
 
 # ifndef OPENSSL_NO_STDIO
-    CMPerr(0, CMP_R_MULTIPLE_SAN_SOURCES);
+    ERR_raise(ERR_LIB_CMP, CMP_R_MULTIPLE_SAN_SOURCES);
     OSSL_CMP_CTX_print_errors(ctx); /* should print above error to STDERR */
 # endif
 
@@ -153,9 +153,9 @@ static int execute_CTX_print_errors_test(OSSL_CMP_CTX_TEST_FIXTURE *fixture)
     if (!TEST_true(ctx-&gt;log_cb == msg_total_size_log_cb)) {
         res = 0;
     } else {
-        CMPerr(0, CMP_R_INVALID_ARGS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
         base_err_msg_size = strlen(&quot;INVALID_ARGS&quot;);
-        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT);
         base_err_msg_size += strlen(&quot;NULL_ARGUMENT&quot;);
         expected_size = base_err_msg_size;
         ossl_cmp_add_error_data(&quot;data1&quot;); /* should prepend separator &quot; : &quot; */
@@ -168,7 +168,7 @@ static int execute_CTX_print_errors_test(OSSL_CMP_CTX_TEST_FIXTURE *fixture)
         if (!TEST_int_eq(msg_total_size, expected_size))
             res = 0;
 
-        CMPerr(0, CMP_R_INVALID_ARGS);
+        ERR_raise(ERR_LIB_CMP, CMP_R_INVALID_ARGS);
         base_err_msg_size = strlen(&quot;INVALID_ARGS&quot;) + strlen(&quot; : &quot;);
         expected_size = base_err_msg_size;
         while (expected_size &lt; 4096) { /* force split */
@@ -498,7 +498,7 @@ static X509_STORE *X509_STORE_new_1(void)
 
 #define RET_IF_NULL_ARG(ctx, ret) \
     if (ctx == NULL) { \
-        CMPerr(0, CMP_R_NULL_ARGUMENT); \
+        ERR_raise(ERR_LIB_CMP, CMP_R_NULL_ARGUMENT); \
         return ret; \
     }
 
diff --git a/test/cmp_server_test.c b/test/cmp_server_test.c
index d2a34695c3..8d0e1de759 100644
--- a/test/cmp_server_test.c
+++ b/test/cmp_server_test.c
@@ -55,7 +55,7 @@ static OSSL_CMP_PKISI *process_cert_request(OSSL_CMP_SRV_CTX *srv_ctx,
                                             STACK_OF(X509) **chainOut,
                                             STACK_OF(X509) **caPubs)
 {
-    CMPerr(0, dummy_errorCode);
+    ERR_raise(ERR_LIB_CMP, dummy_errorCode);
     return NULL;
 }
 
diff --git a/test/errtest.c b/test/errtest.c
index e8c7d44306..443bd0a57d 100644
--- a/test/errtest.c
+++ b/test/errtest.c
@@ -111,7 +111,7 @@ static int vdata_appends(void)
 {
     const char *data;
 
-    CRYPTOerr(0, ERR_R_MALLOC_FAILURE);
+    ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
     ERR_add_error_data(1, &quot;hello &quot;);
     ERR_add_error_data(1, &quot;world&quot;);
     ERR_peek_error_data(&amp;data, NULL);
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="032024.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="032029.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#32025">[ date ]</a>
              <a href="thread.html#32025">[ thread ]</a>
              <a href="subject.html#32025">[ subject ]</a>
              <a href="author.html#32025">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
