<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2021-March/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1616765058.259877.16196.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="033641.html">
   <LINK REL="Next"  HREF="033644.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>tomas at openssl.org</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1616765058.259877.16196.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">tomas at openssl.org
       </A><BR>
    <I>Fri Mar 26 13:24:18 UTC 2021</I>
    <P><UL>
        <LI>Previous message: <A HREF="033641.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="033644.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33642">[ date ]</a>
              <a href="thread.html#33642">[ thread ]</a>
              <a href="subject.html#33642">[ subject ]</a>
              <a href="author.html#33642">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  cede07dc51728edce77336f0fe5fce6d62ed7654 (commit)
      from  6b2e51dd36c2f7f1ec24e84288324a12cfe3549e (commit)


- Log -----------------------------------------------------------------
commit cede07dc51728edce77336f0fe5fce6d62ed7654
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tomas at openssl.org</A>&gt;
Date:   Thu Mar 25 12:46:29 2021 +0100

    Remove the external BoringSSL test
    
    Fixes #14424
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/14682">https://github.com/openssl/openssl/pull/14682</A>)

-----------------------------------------------------------------------

Summary of changes:
 .gitattributes                            |    1 -
 .github/workflows/ci.yml                  |    2 -
 .gitmodules                               |    4 -
 INSTALL.md                                |    2 +-
 boringssl                                 |    1 -
 test/README-external.md                   |   63 --
 test/build.info                           |    2 -
 test/data2.bin                            |  245 ++----
 test/ossl_shim/async_bio.cc               |  183 ----
 test/ossl_shim/async_bio.h                |   39 -
 test/ossl_shim/build.info                 |    6 -
 test/ossl_shim/include/openssl/base.h     |  114 ---
 test/ossl_shim/ossl_config.json           |  301 -------
 test/ossl_shim/ossl_shim.cc               | 1312 -----------------------------
 test/ossl_shim/packeted_bio.cc            |  299 -------
 test/ossl_shim/packeted_bio.h             |   35 -
 test/ossl_shim/test_config.cc             |  195 -----
 test/ossl_shim/test_config.h              |   90 --
 test/recipes/95-test_external_boringssl.t |   30 -
 19 files changed, 60 insertions(+), 2864 deletions(-)
 delete mode 160000 boringssl
 delete mode 100644 test/ossl_shim/async_bio.cc
 delete mode 100644 test/ossl_shim/async_bio.h
 delete mode 100644 test/ossl_shim/build.info
 delete mode 100644 test/ossl_shim/include/openssl/base.h
 delete mode 100644 test/ossl_shim/ossl_config.json
 delete mode 100644 test/ossl_shim/ossl_shim.cc
 delete mode 100644 test/ossl_shim/packeted_bio.cc
 delete mode 100644 test/ossl_shim/packeted_bio.h
 delete mode 100644 test/ossl_shim/test_config.cc
 delete mode 100644 test/ossl_shim/test_config.h
 delete mode 100644 test/recipes/95-test_external_boringssl.t

diff --git a/.gitattributes b/.gitattributes
index 6771355ff7..6bd7389c8a 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -8,7 +8,6 @@ fuzz/corpora/**                         export-ignore
 Configurations/*.norelease.conf         export-ignore
 .*                                      export-ignore
 util/mktar.sh                           export-ignore
-boringssl                               export-ignore
 krb5                                    export-ignore
 pyca-cryptography                       export-ignore
 dev                                     export-ignore
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 7adc2ab746..ad24aaa5b8 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -200,7 +200,5 @@ jobs:
       run: make test TESTS=&quot;test_external_gost_engine&quot;
     - name: test external krb5
       run: make test TESTS=&quot;test_external_krb5&quot;
-#   - name: test external boringssl
-#     run: BORING_RUNNER_DIR=$(pwd)/boringssl/ssl/test/runner make test TESTS=&quot;test_external_boringssl&quot;
 #   - name: test external pyca
 #     run: make test TESTS=&quot;test_external_pyca&quot;
diff --git a/.gitmodules b/.gitmodules
index 637e7ade7e..955140d60d 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,7 +1,3 @@
-[submodule &quot;boringssl&quot;]
-	path = boringssl
-	url = <A HREF="https://boringssl.googlesource.com/boringssl">https://boringssl.googlesource.com/boringssl</A>
-
 [submodule &quot;pyca.cryptography&quot;]
 	path = pyca-cryptography
 	url = <A HREF="https://github.com/pyca/cryptography.git">https://github.com/pyca/cryptography.git</A>
diff --git a/INSTALL.md b/INSTALL.md
index d6ef21d20e..14b6118c36 100644
--- a/INSTALL.md
+++ b/INSTALL.md
@@ -692,7 +692,7 @@ Enable building of integration with external test suites.
 This is a developer option and may not work on all platforms.  The following
 external test suites are currently supported:
 
- - BoringSSL test suite
+ - GOST engine test suite
  - Python PYCA/Cryptography test suite
  - krb5 test suite
 
diff --git a/boringssl b/boringssl
deleted file mode 160000
index 2070f8ad91..0000000000
--- a/boringssl
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 2070f8ad9151dc8f3a73bffaa146b5e6937a583f
diff --git a/test/README-external.md b/test/README-external.md
index b06deaac4f..3e10526b85 100644
--- a/test/README-external.md
+++ b/test/README-external.md
@@ -5,69 +5,6 @@ It is possible to integrate external test suites into OpenSSL's `make test`.
 This capability is considered a developer option and does not work on all
 platforms.
 
-The BoringSSL test suite
-========================
-
-In order to run the BoringSSL tests with OpenSSL, first checkout the BoringSSL
-source code into an appropriate directory. This can be done in two ways:
-
-1) Separately from the OpenSSL checkout using:
-
-    $ git clone <A HREF="https://boringssl.googlesource.com/boringssl">https://boringssl.googlesource.com/boringssl</A> boringssl
-
-  The BoringSSL tests are only confirmed to work at a specific commit in the
-  BoringSSL repository. Later commits may or may not pass the test suite:
-
-    $ cd boringssl
-    $ git checkout 490469f850e
-
-2) Using the already configured submodule settings in OpenSSL:
-
-    $ git submodule update --init
-
-Configure the OpenSSL source code to enable the external tests:
-
-    $ cd ../openssl
-    $ ./config enable-ssl3 enable-ssl3-method enable-weak-ssl-ciphers \
-             enable-external-tests
-
-Note that using other config options than those given above may cause the tests
-to fail.
-
-Run the OpenSSL tests by providing the path to the BoringSSL test runner in the
-`BORING_RUNNER_DIR` environment variable:
-
-    $ BORING_RUNNER_DIR=/path/to/boringssl/ssl/test/runner make test
-
-Note that the test suite may change directory while running so the path provided
-should be absolute and not relative to the current working directory.
-
-To see more detailed output you can run just the BoringSSL tests with the
-verbose option:
-
-    $ VERBOSE=1 BORING_RUNNER_DIR=/path/to/boringssl/ssl/test/runner make \
-        TESTS=&quot;test_external_boringssl&quot; test
-
-Test failures and suppressions
-------------------------------
-
-A large number of the BoringSSL tests are known to fail. A test could fail
-because of many possible reasons. For example:
-
-- A bug in OpenSSL
-- Different interpretations of standards
-- Assumptions about the way BoringSSL works that do not apply to OpenSSL
-- The test uses APIs added to BoringSSL that are not present in OpenSSL
-- etc
-
-In order to provide a &quot;clean&quot; baseline run with all the tests passing a config
-file has been provided that suppresses the running of tests that are known to
-fail. These suppressions are held in the file &quot;test/ossl_shim/ossl_config.json&quot;
-within the OpenSSL source code.
-
-The community is encouraged to contribute patches which reduce the number of
-suppressions that are currently present.
-
 Python PYCA/Cryptography test suite
 ===================================
 
diff --git a/test/build.info b/test/build.info
index 8abb14f634..b31e5dedd5 100644
--- a/test/build.info
+++ b/test/build.info
@@ -1,5 +1,3 @@
-SUBDIRS=ossl_shim
-
 # TODO: use ../apps/libapps.a instead of direct ../apps/lib source.
 # This can't currently be done, because some of its units drag in too many
 # unresolved references that don't apply here.
diff --git a/test/data2.bin b/test/data2.bin
index c4f9691a26..40c1bdad13 100644
--- a/test/data2.bin
+++ b/test/data2.bin
@@ -1,188 +1,61 @@
 TEST DATA2
 
-Running external test suites with OpenSSL
-=========================================
-
-It is possible to integrate external test suites into OpenSSL's &quot;make test&quot;.
-This capability is considered a developer option and does not work on all
-platforms.
-
-
-
-The BoringSSL test suite
-========================
-
-In order to run the BoringSSL tests with OpenSSL, first checkout the BoringSSL
-source code into an appropriate directory. This can be done in two ways:
-
-1) Separately from the OpenSSL checkout using:
-
-  $ git clone <A HREF="https://boringssl.googlesource.com/boringssl">https://boringssl.googlesource.com/boringssl</A> boringssl
-
-  The BoringSSL tests are only confirmed to work at a specific commit in the
-  BoringSSL repository. Later commits may or may not pass the test suite:
-
-  $ cd boringssl
-  $ git checkout 490469f850e
-
-2) Using the already configured submodule settings in OpenSSL:
-
-  $ git submodule update --init
-
-Configure the OpenSSL source code to enable the external tests:
-
-$ cd ../openssl
-$ ./config enable-ssl3 enable-ssl3-method enable-weak-ssl-ciphers \
-  enable-external-tests
-
-Note that using other config options than those given above may cause the tests
-to fail.
-
-Run the OpenSSL tests by providing the path to the BoringSSL test runner in the
-BORING_RUNNER_DIR environment variable:
-
-$ BORING_RUNNER_DIR=/path/to/boringssl/ssl/test/runner make test
-
-Note that the test suite may change directory while running so the path provided
-should be absolute and not relative to the current working directory.
-
-To see more detailed output you can run just the BoringSSL tests with the
-verbose option:
-
-$ VERBOSE=1 BORING_RUNNER_DIR=/path/to/boringssl/ssl/test/runner make \
-  TESTS=&quot;test_external_boringssl&quot; test
-
-
-Test failures and suppressions
-------------------------------
-
-A large number of the BoringSSL tests are known to fail. A test could fail
-because of many possible reasons. For example:
-
-- A bug in OpenSSL
-- Different interpretations of standards
-- Assumptions about the way BoringSSL works that do not apply to OpenSSL
-- The test uses APIs added to BoringSSL that are not present in OpenSSL
-- etc
-
-In order to provide a &quot;clean&quot; baseline run with all the tests passing a config
-file has been provided that suppresses the running of tests that are known to
-fail. These suppressions are held in the file &quot;test/ossl_shim/ossl_config.json&quot;
-within the OpenSSL source code.
-
-The community is encouraged to contribute patches which reduce the number of
-suppressions that are currently present.
-
-
-Python PYCA/Cryptography test suite
-===================================
-
-This python test suite runs cryptographic tests with a local OpenSSL build as
-the implementation.
-
-First checkout the PYCA/Cryptography module into ./pyca-cryptography using:
-
-$ git submodule update --init
-
-Then configure/build OpenSSL compatible with the python module:
-
-$ ./config shared enable-external-tests
-$ make
-
-The tests will run in a python virtual environment which requires virtualenv
-to be installed.
-
-$ make test VERBOSE=1 TESTS=test_external_pyca
-
-Test failures and suppressions
-------------------------------
-
-Some tests target older (&lt;=1.0.2) versions so will not run. Other tests target
-other crypto implementations so are not relevant. Currently no tests fail.
-
-
-krb5 test suite
-===============
-
-Much like the PYCA/Cryptography test suite, this builds and runs the krb5
-tests against the local OpenSSL build.
-
-You will need a git checkout of krb5 at the top level:
-
-$ git clone <A HREF="https://github.com/krb5/krb5">https://github.com/krb5/krb5</A>
-
-krb5's master has to pass this same CI, but a known-good version is
-krb5-1.15.1-final if you want to be sure.
-
-$ cd krb5
-$ git checkout krb5-1.15.1-final
-$ cd ..
-
-OpenSSL must be built with external tests enabled:
-
-$ ./config enable-external-tests
-$ make
-
-krb5's tests will then be run as part of the rest of the suite, or can be
-explicitly run (with more debugging):
-
-$ VERBOSE=1 make TESTS=test_external_krb5 test
-
-Test-failures suppressions
---------------------------
-
-krb5 will automatically adapt its test suite to account for the configuration
-of your system.  Certain tests may require more installed packages to run.  No
-tests are expected to fail.
-
-
-GOST engine test suite
-===============
-
-Much like the PYCA/Cryptography test suite, this builds and runs the GOST engine
-tests against the local OpenSSL build.
-
-You will need a git checkout of gost-engine at the top level:
-
-$ git submodule update --init
-
-Then configure/build OpenSSL enabling external tests:
-
-$ ./config shared enable-external-tests
-$ make
-
-GOST engine requires CMake for the build process.
-
-GOST engine tests will then be run as part of the rest of the suite, or can be
-explicitly run (with more debugging):
-
-$ make test VERBOSE=1 TESTS=test_external_gost_engine
-
-Updating test suites
-====================
-
-To update the commit for any of the above test suites:
-
-- Make sure the submodules are cloned locally:
-
-  $ git submodule update --init --recursive
-
-- Enter subdirectory and pull from the repository (use a specific branch/tag if required):
-
-  $ cd &lt;submodule-dir&gt;
-  $ git pull origin master
-
-- Go to root directory, there should be a new git status:
-
-  $ cd ../
-  $ git status
-  ...
-  #       modified:   &lt;submodule-dir&gt; (new commits)
-  ...
-
-- Add/commit/push the update
-
-  git add &lt;submodule-dir&gt;
-  git commit -m &quot;Updated &lt;submodule&gt; to latest commit&quot;
-  git push
-
+This is just some data that is meant to be different from the contents
+of the data.bin file.
+
+Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
+tempor incididunt ut labore et dolore magna aliqua. Hendrerit dolor magna
+eget est. Integer enim neque volutpat ac tincidunt vitae. Erat imperdiet
+sed euismod nisi porta. Sit amet volutpat consequat mauris nunc.
+Fermentum leo vel orci porta non. Purus viverra accumsan in nisl.
+Volutpat maecenas volutpat blandit aliquam etiam erat velit scelerisque.
+Gravida in fermentum et sollicitudin ac orci phasellus. Ut eu sem integer
+vitae justo eget. Enim tortor at auctor urna nunc id. Laoreet non
+curabitur gravida arcu ac tortor dignissim convallis aenean. A lacus
+vestibulum sed arcu non odio euismod lacinia. In metus vulputate eu
+scelerisque felis imperdiet proin fermentum. Semper quis lectus nulla at
+volutpat diam ut venenatis tellus. Hac habitasse platea dictumst quisque.
+Augue ut lectus arcu bibendum at varius vel pharetra. Nisl nunc mi ipsum
+faucibus vitae aliquet. Nec sagittis aliquam malesuada bibendum arcu
+vitae. Tellus id interdum velit laoreet id donec ultrices.
+
+Eget gravida cum sociis natoque. Nunc vel risus commodo viverra maecenas
+accumsan. Enim lobortis scelerisque fermentum dui faucibus. Quis eleifend
+quam adipiscing vitae. Nec nam aliquam sem et tortor. Pharetra massa
+massa ultricies mi quis hendrerit. Tellus in metus vulputate eu
+scelerisque. Et ultrices neque ornare aenean euismod elementum. Tellus
+mauris a diam maecenas sed enim ut sem viverra. Fermentum leo vel orci
+porta non pulvinar neque. Risus nullam eget felis eget nunc. Sed tempus
+urna et pharetra pharetra massa massa ultricies. Dui sapien eget mi
+proin. Vitae elementum curabitur vitae nunc sed velit dignissim sodales.
+Sed arcu non odio euismod lacinia at. Enim praesent elementum facilisis
+leo vel fringilla. Vel facilisis volutpat est velit egestas dui id ornare
+arcu. Arcu dictum varius duis at. Pretium lectus quam id leo in vitae.
+
+Egestas fringilla phasellus faucibus scelerisque eleifend donec. Ut
+ornare lectus sit amet est placerat in egestas. Viverra ipsum nunc
+aliquet bibendum enim facilisis gravida neque. Commodo ullamcorper a
+lacus vestibulum. Urna molestie at elementum eu. Mi in nulla posuere
+sollicitudin aliquam ultrices sagittis orci a. Orci sagittis eu volutpat
+odio facilisis mauris sit. Volutpat ac tincidunt vitae semper quis.
+Adipiscing elit duis tristique sollicitudin nibh. Dignissim enim sit amet
+venenatis urna cursus. Lacus luctus accumsan tortor posuere ac ut. Eu
+feugiat pretium nibh ipsum consequat nisl. Arcu risus quis varius quam
+quisque id diam. Urna nec tincidunt praesent semper feugiat nibh sed. Sed
+libero enim sed faucibus turpis in eu mi.
+
+Suspendisse faucibus interdum posuere lorem ipsum dolor sit amet. Aliquet
+eget sit amet tellus cras adipiscing enim. Lectus proin nibh nisl
+condimentum id. Et odio pellentesque diam volutpat commodo sed egestas
+egestas. Tempor id eu nisl nunc mi ipsum. Egestas erat imperdiet sed
+euismod nisi porta lorem mollis aliquam. Pretium quam vulputate dignissim
+suspendisse in est. Volutpat commodo sed egestas egestas fringilla. In
+aliquam sem fringilla ut. Viverra accumsan in nisl nisi. Nam at lectus
+urna duis convallis convallis. Tortor posuere ac ut consequat semper.
+Pellentesque habitant morbi tristique senectus et netus et malesuada.
+Aliquet enim tortor at auctor urna nunc id cursus metus. Sit amet luctus
+venenatis lectus magna. A diam maecenas sed enim ut sem viverra aliquet.
+Pellentesque sit amet porttitor eget dolor morbi. Eget lorem dolor sed
+viverra ipsum nunc aliquet bibendum enim. Iaculis urna id volutpat lacus
+laoreet non curabitur. Mattis vulputate enim nulla aliquet porttitor
+lacus luctus accumsan tortor.
diff --git a/test/ossl_shim/async_bio.cc b/test/ossl_shim/async_bio.cc
deleted file mode 100644
index b21e5af51b..0000000000
--- a/test/ossl_shim/async_bio.cc
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#include &quot;async_bio.h&quot;
-
-#include &lt;errno.h&gt;
-#include &lt;string.h&gt;
-
-#include &lt;openssl/bio.h&gt;
-#include &lt;openssl/crypto.h&gt;
-
-
-namespace {
-
-struct AsyncBio {
-  bool datagram;
-  bool enforce_write_quota;
-  size_t read_quota;
-  size_t write_quota;
-};
-
-AsyncBio *GetData(BIO *bio) {
-  return (AsyncBio *)BIO_get_data(bio);
-}
-
-static int AsyncWrite(BIO *bio, const char *in, int inl) {
-  AsyncBio *a = GetData(bio);
-  if (a == NULL || BIO_next(bio) == NULL) {
-    return 0;
-  }
-
-  if (!a-&gt;enforce_write_quota) {
-    return BIO_write(BIO_next(bio), in, inl);
-  }
-
-  BIO_clear_retry_flags(bio);
-
-  if (a-&gt;write_quota == 0) {
-    BIO_set_retry_write(bio);
-    errno = EAGAIN;
-    return -1;
-  }
-
-  if (!a-&gt;datagram &amp;&amp; (size_t)inl &gt; a-&gt;write_quota) {
-    inl = a-&gt;write_quota;
-  }
-  int ret = BIO_write(BIO_next(bio), in, inl);
-  if (ret &lt;= 0) {
-    BIO_copy_next_retry(bio);
-  } else {
-    a-&gt;write_quota -= (a-&gt;datagram ? 1 : ret);
-  }
-  return ret;
-}
-
-static int AsyncRead(BIO *bio, char *out, int outl) {
-  AsyncBio *a = GetData(bio);
-  if (a == NULL || BIO_next(bio) == NULL) {
-    return 0;
-  }
-
-  BIO_clear_retry_flags(bio);
-
-  if (a-&gt;read_quota == 0) {
-    BIO_set_retry_read(bio);
-    errno = EAGAIN;
-    return -1;
-  }
-
-  if (!a-&gt;datagram &amp;&amp; (size_t)outl &gt; a-&gt;read_quota) {
-    outl = a-&gt;read_quota;
-  }
-  int ret = BIO_read(BIO_next(bio), out, outl);
-  if (ret &lt;= 0) {
-    BIO_copy_next_retry(bio);
-  } else {
-    a-&gt;read_quota -= (a-&gt;datagram ? 1 : ret);
-  }
-  return ret;
-}
-
-static long AsyncCtrl(BIO *bio, int cmd, long num, void *ptr) {
-  if (BIO_next(bio) == NULL) {
-    return 0;
-  }
-  BIO_clear_retry_flags(bio);
-  int ret = BIO_ctrl(BIO_next(bio), cmd, num, ptr);
-  BIO_copy_next_retry(bio);
-  return ret;
-}
-
-static int AsyncNew(BIO *bio) {
-  AsyncBio *a = (AsyncBio *)OPENSSL_malloc(sizeof(*a));
-  if (a == NULL) {
-    return 0;
-  }
-  memset(a, 0, sizeof(*a));
-  a-&gt;enforce_write_quota = true;
-  BIO_set_init(bio, 1);
-  BIO_set_data(bio, a);
-  return 1;
-}
-
-static int AsyncFree(BIO *bio) {
-  if (bio == NULL) {
-    return 0;
-  }
-
-  OPENSSL_free(BIO_get_data(bio));
-  BIO_set_data(bio, NULL);
-  BIO_set_init(bio, 0);
-  return 1;
-}
-
-static long AsyncCallbackCtrl(BIO *bio, int cmd, BIO_info_cb fp)
-{
-  if (BIO_next(bio) == NULL)
-    return 0;
-  return BIO_callback_ctrl(BIO_next(bio), cmd, fp);
-}
-
-static BIO_METHOD *g_async_bio_method = NULL;
-
-static const BIO_METHOD *AsyncMethod(void)
-{
-  if (g_async_bio_method == NULL) {
-    g_async_bio_method = BIO_meth_new(BIO_TYPE_FILTER, &quot;async bio&quot;);
-    if (   g_async_bio_method == NULL
-        || !BIO_meth_set_write(g_async_bio_method, AsyncWrite)
-        || !BIO_meth_set_read(g_async_bio_method, AsyncRead)
-        || !BIO_meth_set_ctrl(g_async_bio_method, AsyncCtrl)
-        || !BIO_meth_set_create(g_async_bio_method, AsyncNew)
-        || !BIO_meth_set_destroy(g_async_bio_method, AsyncFree)
-        || !BIO_meth_set_callback_ctrl(g_async_bio_method, AsyncCallbackCtrl))
-    return NULL;
-  }
-  return g_async_bio_method;
-}
-
-}  // namespace
-
-bssl::UniquePtr&lt;BIO&gt; AsyncBioCreate() {
-  return bssl::UniquePtr&lt;BIO&gt;(BIO_new(AsyncMethod()));
-}
-
-bssl::UniquePtr&lt;BIO&gt; AsyncBioCreateDatagram() {
-  bssl::UniquePtr&lt;BIO&gt; ret(BIO_new(AsyncMethod()));
-  if (!ret) {
-    return nullptr;
-  }
-  GetData(ret.get())-&gt;datagram = true;
-  return ret;
-}
-
-void AsyncBioAllowRead(BIO *bio, size_t count) {
-  AsyncBio *a = GetData(bio);
-  if (a == NULL) {
-    return;
-  }
-  a-&gt;read_quota += count;
-}
-
-void AsyncBioAllowWrite(BIO *bio, size_t count) {
-  AsyncBio *a = GetData(bio);
-  if (a == NULL) {
-    return;
-  }
-  a-&gt;write_quota += count;
-}
-
-void AsyncBioEnforceWriteQuota(BIO *bio, bool enforce) {
-  AsyncBio *a = GetData(bio);
-  if (a == NULL) {
-    return;
-  }
-  a-&gt;enforce_write_quota = enforce;
-}
diff --git a/test/ossl_shim/async_bio.h b/test/ossl_shim/async_bio.h
deleted file mode 100644
index 0d3b0ebc6e..0000000000
--- a/test/ossl_shim/async_bio.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#ifndef OSSL_TEST_SHIM_ASYNC_BIO_H
-#define OSSL_TEST_SHIM_ASYNC_BIO_H
-
-#include &lt;openssl/base.h&gt;
-#include &lt;openssl/bio.h&gt;
-
-
-// AsyncBioCreate creates a filter BIO for testing asynchronous state
-// machines which consume a stream socket. Reads and writes will fail
-// and return EAGAIN unless explicitly allowed. Each async BIO has a
-// read quota and a write quota. Initially both are zero. As each is
-// incremented, bytes are allowed to flow through the BIO.
-bssl::UniquePtr&lt;BIO&gt; AsyncBioCreate();
-
-// AsyncBioCreateDatagram creates a filter BIO for testing for
-// asynchronous state machines which consume datagram sockets. The read
-// and write quota count in packets rather than bytes.
-bssl::UniquePtr&lt;BIO&gt; AsyncBioCreateDatagram();
-
-// AsyncBioAllowRead increments |bio|'s read quota by |count|.
-void AsyncBioAllowRead(BIO *bio, size_t count);
-
-// AsyncBioAllowWrite increments |bio|'s write quota by |count|.
-void AsyncBioAllowWrite(BIO *bio, size_t count);
-
-// AsyncBioEnforceWriteQuota configures where |bio| enforces its write quota.
-void AsyncBioEnforceWriteQuota(BIO *bio, bool enforce);
-
-
-#endif  // OSSL_TEST_SHIM_ASYNC_BIO_H
diff --git a/test/ossl_shim/build.info b/test/ossl_shim/build.info
deleted file mode 100644
index d1dd208408..0000000000
--- a/test/ossl_shim/build.info
+++ /dev/null
@@ -1,6 +0,0 @@
-IF[{- defined $target{CXX} &amp;&amp; !$disabled{&quot;external-tests&quot;} -}]
-  PROGRAMS{noinst}=ossl_shim
-  SOURCE[ossl_shim]=ossl_shim.cc async_bio.cc packeted_bio.cc test_config.cc
-  INCLUDE[ossl_shim]=. include ../../include
-  DEPEND[ossl_shim]=../../libssl ../../libcrypto
-ENDIF
diff --git a/test/ossl_shim/include/openssl/base.h b/test/ossl_shim/include/openssl/base.h
deleted file mode 100644
index 9b07292673..0000000000
--- a/test/ossl_shim/include/openssl/base.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright 1998-2021 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#ifndef OSSL_TEST_SHIM_INCLUDE_OPENSSL_BASE_H
-#define OSSL_TEST_SHIM_INCLUDE_OPENSSL_BASE_H
-
-/* Needed for DH functions */
-#include &quot;internal/deprecated.h&quot;
-
-/* Needed for BORINGSSL_MAKE_DELETER */
-# include &lt;openssl/bio.h&gt;
-# include &lt;openssl/evp.h&gt;
-# include &lt;openssl/dh.h&gt;
-# include &lt;openssl/x509.h&gt;
-# include &lt;openssl/ssl.h&gt;
-
-# define OPENSSL_ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
-
-extern &quot;C++&quot; {
-
-#include &lt;memory&gt;
-
-namespace bssl {
-
-namespace internal {
-
-template &lt;typename T&gt;
-struct DeleterImpl {};
-
-template &lt;typename T&gt;
-struct Deleter {
-  void operator()(T *ptr) {
-    // Rather than specialize Deleter for each type, we specialize
-    // DeleterImpl. This allows bssl::UniquePtr&lt;T&gt; to be used while only
-    // including base.h as long as the destructor is not emitted. This matches
-    // std::unique_ptr's behavior on forward-declared types.
-    //
-    // DeleterImpl itself is specialized in the corresponding module's header
-    // and must be included to release an object. If not included, the compiler
-    // will error that DeleterImpl&lt;T&gt; does not have a method Free.
-    DeleterImpl&lt;T&gt;::Free(ptr);
-  }
-};
-
-template &lt;typename T, typename CleanupRet, void (*init)(T *),
-          CleanupRet (*cleanup)(T *)&gt;
-class StackAllocated {
- public:
-  StackAllocated() { init(&amp;ctx_); }
-  ~StackAllocated() { cleanup(&amp;ctx_); }
-
-  StackAllocated(const StackAllocated&lt;T, CleanupRet, init, cleanup&gt; &amp;) = delete;
-  T&amp; operator=(const StackAllocated&lt;T, CleanupRet, init, cleanup&gt; &amp;) = delete;
-
-  T *get() { return &amp;ctx_; }
-  const T *get() const { return &amp;ctx_; }
-
-  void Reset() {
-    cleanup(&amp;ctx_);
-    init(&amp;ctx_);
-  }
-
- private:
-  T ctx_;
-};
-
-}  // namespace internal
-
-#define BORINGSSL_MAKE_DELETER(type, deleter)     \
-  namespace internal {                            \
-  template &lt;&gt;                                     \
-  struct DeleterImpl&lt;type&gt; {                      \
-    static void Free(type *ptr) { deleter(ptr); } \
-  };                                              \
-  }
-
-// This makes a unique_ptr to STACK_OF(type) that owns all elements on the
-// stack, i.e. it uses sk_pop_free() to clean up.
-#define BORINGSSL_MAKE_STACK_DELETER(type, deleter) \
-  namespace internal {                              \
-  template &lt;&gt;                                       \
-  struct DeleterImpl&lt;STACK_OF(type)&gt; {              \
-    static void Free(STACK_OF(type) *ptr) {         \
-      sk_##type##_pop_free(ptr, deleter);           \
-    }                                               \
-  };                                                \
-  }
-
-// Holds ownership of heap-allocated BoringSSL structures. Sample usage:
-//   bssl::UniquePtr&lt;BIO&gt; rsa(RSA_new());
-//   bssl::UniquePtr&lt;BIO&gt; bio(BIO_new(BIO_s_mem()));
-template &lt;typename T&gt;
-using UniquePtr = std::unique_ptr&lt;T, internal::Deleter&lt;T&gt;&gt;;
-
-BORINGSSL_MAKE_DELETER(BIO, BIO_free)
-BORINGSSL_MAKE_DELETER(EVP_PKEY, EVP_PKEY_free)
-BORINGSSL_MAKE_DELETER(DH, DH_free)
-BORINGSSL_MAKE_DELETER(X509, X509_free)
-BORINGSSL_MAKE_DELETER(SSL, SSL_free)
-BORINGSSL_MAKE_DELETER(SSL_CTX, SSL_CTX_free)
-BORINGSSL_MAKE_DELETER(SSL_SESSION, SSL_SESSION_free)
-
-}  // namespace bssl
-
-}  /* extern C++ */
-
-
-#endif  /* OSSL_TEST_SHIM_INCLUDE_OPENSSL_BASE_H */
diff --git a/test/ossl_shim/ossl_config.json b/test/ossl_shim/ossl_config.json
deleted file mode 100644
index 1e57499065..0000000000
--- a/test/ossl_shim/ossl_config.json
+++ /dev/null
@@ -1,301 +0,0 @@
-
-{
-    &quot;DisabledTests&quot; : {
-        &quot;*TLS13*&quot;:&quot;No TLS1.3 support yet&quot;,
-        &quot;FragmentAlert-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;FragmentedClientVersion&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MTU&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;EmptyCertificateList&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;AppDataBeforeHandshake-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;AlertAfterChangeCipherSpec&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;AppDataAfterChangeCipherSpec&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;AppDataAfterChangeCipherSpec-Empty&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;AppDataAfterChangeCipherSpec-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;AppDataBeforeHandshake-DTLS-Empty&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;AlertAfterChangeCipherSpec-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;FragmentMessageLengthMismatch-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SplitFragments-Header-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SplitFragments-Boundary-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SplitFragments-Body-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SendEmptyFragments-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SendInvalidRecordType-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SendInvalidRecordType&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;FragmentMessageTypeMismatch-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SendWarningAlerts-Pass&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SendWarningAlerts-DTLS-Pass&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TooManyKeyUpdates&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Unclean-Shutdown-Alert&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;V2ClientHello-WarningAlertPrefix&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;BadHelloRequest-2&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-SendExtraFinished&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;NoNullCompression-TLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;KeyUpdate-Client&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;KeyUpdate-InvalidRequestMode&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-SendExtraFinished-Reordered&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;LargeMessage-Reject-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;KeyUpdate-Server&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SSL3-ECDHE-PSK-AES128-CBC-SHA-server&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SSL3-ECDHE-PSK-AES256-CBC-SHA-server&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS1-NULL-SHA-server&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS1-NULL-SHA-client&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS12-NULL-SHA-client&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS12-NULL-SHA-server&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;BadECDSA-1-4&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;BadECDSA-3-4&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;BadECDSA-4-1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;BadECDSA-4-4&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;BadECDSA-4-3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SillyDH&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;VersionNegotiationExtension-TLS1-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;NoSupportedVersions-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;VersionTooLow-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;IgnoreClientVersionOrder&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;VersionTooLow&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Server-TLS1-SSL3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Server2-TLS1-SSL3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Client2-TLS1-SSL3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Server2-TLS11-SSL3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Server-TLS11-SSL3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Client2-TLS11-SSL3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Client2-TLS11-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Server2-TLS12-SSL3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Server-TLS12-SSL3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Client2-TLS12-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Client2-TLS12-SSL3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Client2-TLS12-TLS1-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MinimumVersion-Client2-TLS12-TLS11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DuplicateExtensionClient-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DuplicateExtensionServer-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ALPNClient-Mismatch-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;UnsolicitedServerNameAck-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ALPNServer-Decline-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ALPNClient-EmptyProtocolName-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;NegotiateALPNAndNPN-Swapped-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;NegotiateALPNAndNPN-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TicketSessionIDLength-33-TLS1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DuplicateExtensionClient-TLS11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DuplicateExtensionServer-TLS11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;UnsolicitedServerNameAck-TLS11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ALPNServer-Decline-TLS11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ALPNClient-Mismatch-TLS11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ALPNClient-EmptyProtocolName-TLS11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;NegotiateALPNAndNPN-TLS11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;NegotiateALPNAndNPN-Swapped-TLS11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TicketSessionIDLength-33-TLS11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DuplicateExtensionServer-TLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DuplicateExtensionClient-TLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;UnsolicitedServerNameAck-TLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ALPNServer-Decline-TLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ALPNClient-Mismatch-TLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ALPNClient-EmptyProtocolName-TLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;NegotiateALPNAndNPN-TLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;NegotiateALPNAndNPN-Swapped-TLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TicketSessionIDLength-33-TLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ClientHelloPadding&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Resume-Server-UnofferedCipher&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Resume-Client-CipherMismatch&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Resume-Server-ExtraIdentityNoBinder&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Resume-Server-BinderWrongLength&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Resume-Server-ExtraPSKBinder&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Resume-Server-NoPSKBinder&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Resume-Server-PSKBinderFirstExtension&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Resume-Server-InvalidPSKBinder&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ExtendedMasterSecret-NoToYes-Client&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Server-Forbidden&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ExtendedMasterSecret-Renego-NoEMS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-SwitchVersion&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-Upgrade&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-SameClientVersion&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-Downgrade&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-SwitchCiphers2&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-SwitchCiphers&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-Forbidden-1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;StrayHelloRequest&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-Freely-2&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-NoIgnore&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;StrayHelloRequest-Packed&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-Freely-1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiation-CertificateChange&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiation-CertificateChange-2&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-SSL3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ClientAuth-SHA1-Fallback-ECDSA&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ClientAuth-SHA1-Fallback-RSA&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;P224-Server&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;RSA-PSS-Large&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-2&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-1&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-2&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-3&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-4&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-Packed&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-4&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-5&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-6&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-6&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-5&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-7&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-7&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-8&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-9&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-8&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-9&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-10&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-10&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-11&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;CustomExtensions-ParseError-Server&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;CustomExtensions-FailAdd-Server&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;CustomExtensions-FailAdd-Client&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;CustomExtensions-ParseError-Client&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;UnknownExtension-Client&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;UnofferedExtension-Client&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;PointFormat-Client-MissingUncompressed&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;PointFormat-Server-MissingUncompressed&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Client-RenewTicket-Sync&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-Sync&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Shutdown-Shim-Sync&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Client-RenewTicket-Sync-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-Sync-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Shutdown-Shim-Sync-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Client-RenewTicket-Sync-PackHandshakeFlight&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Renegotiate-Client-Sync-PackHandshakeFlight&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Shutdown-Shim-Sync-PackHandshakeFlight&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Client-RenewTicket-DTLS-Sync&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Client-RenewTicket-DTLS-Sync-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Server-Implicit-DTLS-Sync-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ClientAuth-NoCertificate-Server-DTLS-Sync-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ClientAuth-ECDSA-Client-DTLS-Sync-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Server-RSA-DTLS-Sync-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Server-ECDHE-RSA-DTLS-Sync-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Server-ECDHE-ECDSA-DTLS-Sync-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Client-RenewTicket-Async&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Shutdown-Shim-Async&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Client-RenewTicket-Async-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Shutdown-Shim-Async-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Client-RenewTicket-Async-PackHandshakeFlight&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Shutdown-Shim-Async-PackHandshakeFlight&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Client-RenewTicket-DTLS-Async&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Client-RenewTicket-DTLS-Async-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Server-Implicit-DTLS-Async-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ClientAuth-NoCertificate-Server-DTLS-Async-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;ClientAuth-ECDSA-Client-DTLS-Async-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Server-RSA-DTLS-Async-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Server-ECDHE-RSA-DTLS-Async-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Basic-Server-ECDHE-ECDSA-DTLS-Async-SplitHandshakeRecords&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SendUnencryptedFinished-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;PartialEncryptedExtensionsWithServerHello&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;StrayChangeCipherSpec&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;PartialClientFinishedWithClientHello&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ClientHello&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ServerHello&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ServerCertificate&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ServerKeyExchange&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-CertificateRequest&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ServerHelloDone&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ClientKeyExchange&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ClientCertificate&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-CertificateVerify&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-NextProtocol&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-NewSessionTicket&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ClientFinished&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ServerFinished&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-HelloVerifyRequest-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ServerHello-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ServerCertificate-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ServerKeyExchange-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-CertificateRequest-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ServerHelloDone-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ClientCertificate-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-CertificateVerify-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ClientKeyExchange-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ClientFinished-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-NewSessionTicket-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ServerFinished-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MissingKeyShare-Client&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;MissingKeyShare-Server&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DuplicateKeyShares&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipEarlyData&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipEarlyData-OmitEarlyDataExtension&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipEarlyData-TooMuchData&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipEarlyData-Interleaved&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipEarlyData-HRR&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipEarlyData-HRR-Interleaved&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipEarlyData-HRR-TooMuchData&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipEarlyData-HRR-FatalAlert&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipEarlyData-EarlyDataInTLS12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipEarlyData-SecondClientHelloEarlyData&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;EmptyEncryptedExtensions&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;EncryptedExtensionsWithKeyShare&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;UnknownCurve-HelloRetryRequest&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;UnnecessaryHelloRetryRequest&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;HelloRetryRequest-Empty&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SecondHelloRetryRequest&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;HelloRetryRequest-DuplicateCurve&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;HelloRetryRequest-DuplicateCookie&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;HelloRetryRequest-EmptyCookie&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;HelloRetryRequest-Unknown&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SecondClientHelloMissingKeyShare&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SecondClientHelloWrongCurve&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;HelloRetryRequestVersionMismatch&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;HelloRetryRequestCurveMismatch&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SkipHelloRetryRequest&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Peek-Renegotiate&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;Peek-KeyUpdate&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Client-12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Timeout&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Server-12&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Fudge&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;DTLS-Retransmit-Fragmented&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;TrailingMessageData-ClientHello-DTLS&quot;:&quot;Test failure - reason unknown&quot;,
-        &quot;SendFallbackSCSV&quot;:&quot;Current runner version uses old draft TLSv1.3&quot;,
-        &quot;VersionNegotiationExtension-TLS11&quot;:&quot;Current runner version uses old draft TLSv1.3&quot;,
-        &quot;VersionNegotiationExtension-TLS1&quot;:&quot;Current runner version uses old draft TLSv1.3&quot;,
-        &quot;VersionNegotiationExtension-SSL3&quot;:&quot;Current runner version uses old draft TLSv1.3&quot;,
-        &quot;ConflictingVersionNegotiation&quot;:&quot;Current runner version uses old draft TLSv1.3&quot;
-    },
-    &quot;ErrorMap&quot; : {
-        &quot;:UNEXPECTED_MESSAGE:&quot;:&quot;unexpected message&quot;,
-        &quot;:INAPPROPRIATE_FALLBACK:&quot;:&quot;inappropriate fallback&quot;,
-        &quot;:UNEXPECTED_RECORD:&quot;:&quot;unexpected message&quot;,
-        &quot;:TLSV1_ALERT_RECORD_OVERFLOW:&quot;:&quot;tlsv1 alert record overflow&quot;,
-        &quot;:WRONG_SSL_VERSION:&quot;:&quot;no protocols available&quot;,
-        &quot;:BAD_ALERT:&quot;:&quot;invalid alert&quot;,
-        &quot;:HTTP_REQUEST:&quot;:&quot;http request&quot;,
-        &quot;:HTTPS_PROXY_REQUEST:&quot;:&quot;https proxy request&quot;,
-        &quot;:WRONG_CERTIFICATE_TYPE:&quot;:&quot;wrong certificate type&quot;,
-        &quot;:WRONG_VERSION_NUMBER:&quot;:&quot;wrong version number&quot;,
-        &quot;:DECRYPTION_FAILED_OR_BAD_RECORD_MAC:&quot;:&quot;decryption failed or bad record mac&quot;,
-        &quot;:DIGEST_CHECK_FAILED:&quot;:&quot;digest check failed&quot;,
-        &quot;:TOO_MANY_EMPTY_FRAGMENTS:&quot;:&quot;record too small&quot;,
-        &quot;:TOO_MANY_WARNING_ALERTS:&quot;:&quot;too many warn alerts&quot;,
-        &quot;:DATA_LENGTH_TOO_LONG:&quot;:&quot;data length too long&quot;,
-        &quot;:EXCESSIVE_MESSAGE_SIZE:&quot;:&quot;excessive message size&quot;,
-        &quot;:ENCRYPTED_LENGTH_TOO_LONG:&quot;:&quot;packet length too long&quot;,
-        &quot;:INVALID_COMPRESSION_LIST:&quot;:&quot;no compression specified&quot;,
-        &quot;:NO_SHARED_CIPHER:&quot;:&quot;no shared cipher&quot;,
-        &quot;:WRONG_CIPHER_RETURNED:&quot;:&quot;wrong cipher returned&quot;,
-        &quot;:HANDSHAKE_FAILURE_ON_CLIENT_HELLO:&quot;:&quot;sslv3 alert handshake failure&quot;,
-        &quot;:UNKNOWN_CIPHER_RETURNED:&quot;:&quot;unknown cipher returned&quot;,
-        &quot;:BAD_SIGNATURE:&quot;:&quot;bad signature&quot;,
-        &quot;:BAD_DH_P_LENGTH:&quot;:&quot;dh key too small&quot;,
-        &quot;:PEER_DID_NOT_RETURN_A_CERTIFICATE:&quot;:&quot;peer did not return a certificate&quot;,
-        &quot;:UNSUPPORTED_PROTOCOL:&quot;:&quot;unsupported protocol&quot;,
-        &quot;:PARSE_TLSEXT:&quot;:&quot;bad extension&quot;,
-        &quot;:BAD_SRTP_PROTECTION_PROFILE_LIST:&quot;:&quot;bad srtp protection profile list&quot;,
-        &quot;:OLD_SESSION_VERSION_NOT_RETURNED:&quot;:&quot;ssl session version mismatch&quot;,
-        &quot;:RESUMED_EMS_SESSION_WITHOUT_EMS_EXTENSION:&quot;:&quot;inconsistent extms&quot;,
-        &quot;:RENEGOTIATION_EMS_MISMATCH:&quot;:&quot;inconsistent extms&quot;,
-        &quot;:RENEGOTIATION_MISMATCH:&quot;:&quot;renegotiation mismatch&quot;,
-        &quot;:WRONG_SIGNATURE_TYPE:&quot;:&quot;wrong signature type&quot;,
-        &quot;:BAD_ECC_CERT:&quot;:&quot;wrong curve&quot;,
-        &quot;:WRONG_CURVE:&quot;:&quot;wrong curve&quot;,
-        &quot;:INVALID_ENCODING:&quot;:&quot;invalid encoding&quot;,
-        &quot;:CERTIFICATE_VERIFY_FAILED:&quot;:&quot;certificate verify failed&quot;,
-        &quot;:BAD_CHANGE_CIPHER_SPEC:&quot;:&quot;bad change cipher spec&quot;,
-        &quot;:ECC_CERT_NOT_FOR_SIGNING:&quot;:&quot;ecc cert not for signing&quot;,
-        &quot;:OLD_SESSION_CIPHER_NOT_RETURNED:&quot;:&quot;old session cipher not returned&quot;,
-        &quot;:RESUMED_NON_EMS_SESSION_WITH_EMS_EXTENSION:&quot;:&quot;inconsistent extms&quot;
-    }
-}
diff --git a/test/ossl_shim/ossl_shim.cc b/test/ossl_shim/ossl_shim.cc
deleted file mode 100644
index 7ea8050ae7..0000000000
--- a/test/ossl_shim/ossl_shim.cc
+++ /dev/null
@@ -1,1312 +0,0 @@
-/*
- * Copyright 1995-2021 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#if !defined(__STDC_FORMAT_MACROS)
-#define __STDC_FORMAT_MACROS
-#endif
-
-#include &quot;packeted_bio.h&quot;
-#include &lt;openssl/e_os2.h&gt;
-
-#if !defined(OPENSSL_SYS_WINDOWS)
-#include &lt;arpa/inet.h&gt;
-#include &lt;netinet/in.h&gt;
-#include &lt;netinet/tcp.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;unistd.h&gt;
-#else
-#include &lt;io.h&gt;
-OPENSSL_MSVC_PRAGMA(warning(push, 3))
-#include &lt;winsock2.h&gt;
-#include &lt;ws2tcpip.h&gt;
-OPENSSL_MSVC_PRAGMA(warning(pop))
-
-OPENSSL_MSVC_PRAGMA(comment(lib, &quot;Ws2_32.lib&quot;))
-#endif
-
-#include &lt;assert.h&gt;
-#include &lt;inttypes.h&gt;
-#include &lt;string.h&gt;
-
-#include &lt;openssl/bio.h&gt;
-#include &lt;openssl/buffer.h&gt;
-#include &lt;openssl/bn.h&gt;
-#include &lt;openssl/core_names.h&gt;
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/dh.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &lt;openssl/evp.h&gt;
-#include &lt;openssl/hmac.h&gt;
-#include &lt;openssl/objects.h&gt;
-#include &lt;openssl/rand.h&gt;
-#include &lt;openssl/ssl.h&gt;
-#include &lt;openssl/x509.h&gt;
-
-#include &lt;memory&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include &quot;async_bio.h&quot;
-#include &quot;test_config.h&quot;
-
-namespace bssl {
-
-#if !defined(OPENSSL_SYS_WINDOWS)
-static int closesocket(int sock) {
-  return close(sock);
-}
-
-static void PrintSocketError(const char *func) {
-  perror(func);
-}
-#else
-static void PrintSocketError(const char *func) {
-  fprintf(stderr, &quot;%s: %d\n&quot;, func, WSAGetLastError());
-}
-#endif
-
-static int Usage(const char *program) {
-  fprintf(stderr, &quot;Usage: %s [flags...]\n&quot;, program);
-  return 1;
-}
-
-struct TestState {
-  // async_bio is async BIO which pauses reads and writes.
-  BIO *async_bio = nullptr;
-  // packeted_bio is the packeted BIO which simulates read timeouts.
-  BIO *packeted_bio = nullptr;
-  bool cert_ready = false;
-  bool handshake_done = false;
-  // private_key is the underlying private key used when testing custom keys.
-  bssl::UniquePtr&lt;EVP_PKEY&gt; private_key;
-  bool got_new_session = false;
-  bssl::UniquePtr&lt;SSL_SESSION&gt; new_session;
-  bool ticket_decrypt_done = false;
-  bool alpn_select_done = false;
-};
-
-static void TestStateExFree(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
-                            int index, long argl, void *argp) {
-  delete ((TestState *)ptr);
-}
-
-static int g_config_index = 0;
-static int g_state_index = 0;
-
-static bool SetTestConfig(SSL *ssl, const TestConfig *config) {
-  return SSL_set_ex_data(ssl, g_config_index, (void *)config) == 1;
-}
-
-static const TestConfig *GetTestConfig(const SSL *ssl) {
-  return (const TestConfig *)SSL_get_ex_data(ssl, g_config_index);
-}
-
-static bool SetTestState(SSL *ssl, std::unique_ptr&lt;TestState&gt; state) {
-  // |SSL_set_ex_data| takes ownership of |state| only on success.
-  if (SSL_set_ex_data(ssl, g_state_index, state.get()) == 1) {
-    state.release();
-    return true;
-  }
-  return false;
-}
-
-static TestState *GetTestState(const SSL *ssl) {
-  return (TestState *)SSL_get_ex_data(ssl, g_state_index);
-}
-
-static bssl::UniquePtr&lt;X509&gt; LoadCertificate(const std::string &amp;file) {
-  bssl::UniquePtr&lt;BIO&gt; bio(BIO_new(BIO_s_file()));
-  if (!bio || !BIO_read_filename(bio.get(), file.c_str())) {
-    return nullptr;
-  }
-  return bssl::UniquePtr&lt;X509&gt;(PEM_read_bio_X509(bio.get(), NULL, NULL, NULL));
-}
-
-static bssl::UniquePtr&lt;EVP_PKEY&gt; LoadPrivateKey(const std::string &amp;file) {
-  bssl::UniquePtr&lt;BIO&gt; bio(BIO_new(BIO_s_file()));
-  if (!bio || !BIO_read_filename(bio.get(), file.c_str())) {
-    return nullptr;
-  }
-  return bssl::UniquePtr&lt;EVP_PKEY&gt;(
-      PEM_read_bio_PrivateKey(bio.get(), NULL, NULL, NULL));
-}
-
-template&lt;typename T&gt;
-struct Free {
-  void operator()(T *buf) {
-    free(buf);
-  }
-};
-
-static bool GetCertificate(SSL *ssl, bssl::UniquePtr&lt;X509&gt; *out_x509,
-                           bssl::UniquePtr&lt;EVP_PKEY&gt; *out_pkey) {
-  const TestConfig *config = GetTestConfig(ssl);
-
-  if (!config-&gt;key_file.empty()) {
-    *out_pkey = LoadPrivateKey(config-&gt;key_file.c_str());
-    if (!*out_pkey) {
-      return false;
-    }
-  }
-  if (!config-&gt;cert_file.empty()) {
-    *out_x509 = LoadCertificate(config-&gt;cert_file.c_str());
-    if (!*out_x509) {
-      return false;
-    }
-  }
-  return true;
-}
-
-static bool InstallCertificate(SSL *ssl) {
-  bssl::UniquePtr&lt;X509&gt; x509;
-  bssl::UniquePtr&lt;EVP_PKEY&gt; pkey;
-  if (!GetCertificate(ssl, &amp;x509, &amp;pkey)) {
-    return false;
-  }
-
-  if (pkey &amp;&amp; !SSL_use_PrivateKey(ssl, pkey.get())) {
-    return false;
-  }
-
-  if (x509 &amp;&amp; !SSL_use_certificate(ssl, x509.get())) {
-    return false;
-  }
-
-  return true;
-}
-
-static int ClientCertCallback(SSL *ssl, X509 **out_x509, EVP_PKEY **out_pkey) {
-  if (GetTestConfig(ssl)-&gt;async &amp;&amp; !GetTestState(ssl)-&gt;cert_ready) {
-    return -1;
-  }
-
-  bssl::UniquePtr&lt;X509&gt; x509;
-  bssl::UniquePtr&lt;EVP_PKEY&gt; pkey;
-  if (!GetCertificate(ssl, &amp;x509, &amp;pkey)) {
-    return -1;
-  }
-
-  // Return zero for no certificate.
-  if (!x509) {
-    return 0;
-  }
-
-  // Asynchronous private keys are not supported with client_cert_cb.
-  *out_x509 = x509.release();
-  *out_pkey = pkey.release();
-  return 1;
-}
-
-static int VerifySucceed(X509_STORE_CTX *store_ctx, void *arg) {
-  return 1;
-}
-
-static int VerifyFail(X509_STORE_CTX *store_ctx, void *arg) {
-  X509_STORE_CTX_set_error(store_ctx, X509_V_ERR_APPLICATION_VERIFICATION);
-  return 0;
-}
-
-static int NextProtosAdvertisedCallback(SSL *ssl, const uint8_t **out,
-                                        unsigned int *out_len, void *arg) {
-  const TestConfig *config = GetTestConfig(ssl);
-  if (config-&gt;advertise_npn.empty()) {
-    return SSL_TLSEXT_ERR_NOACK;
-  }
-
-  *out = (const uint8_t*)config-&gt;advertise_npn.data();
-  *out_len = config-&gt;advertise_npn.size();
-  return SSL_TLSEXT_ERR_OK;
-}
-
-static int NextProtoSelectCallback(SSL* ssl, uint8_t** out, uint8_t* outlen,
-                                   const uint8_t* in, unsigned inlen, void* arg) {
-  const TestConfig *config = GetTestConfig(ssl);
-  if (config-&gt;select_next_proto.empty()) {
-    return SSL_TLSEXT_ERR_NOACK;
-  }
-
-  *out = (uint8_t*)config-&gt;select_next_proto.data();
-  *outlen = config-&gt;select_next_proto.size();
-  return SSL_TLSEXT_ERR_OK;
-}
-
-static int AlpnSelectCallback(SSL* ssl, const uint8_t** out, uint8_t* outlen,
-                              const uint8_t* in, unsigned inlen, void* arg) {
-  if (GetTestState(ssl)-&gt;alpn_select_done) {
-    fprintf(stderr, &quot;AlpnSelectCallback called after completion.\n&quot;);
-    exit(1);
-  }
-
-  GetTestState(ssl)-&gt;alpn_select_done = true;
-
-  const TestConfig *config = GetTestConfig(ssl);
-  if (config-&gt;decline_alpn) {
-    return SSL_TLSEXT_ERR_NOACK;
-  }
-
-  if (!config-&gt;expected_advertised_alpn.empty() &amp;&amp;
-      (config-&gt;expected_advertised_alpn.size() != inlen ||
-       memcmp(config-&gt;expected_advertised_alpn.data(),
-              in, inlen) != 0)) {
-    fprintf(stderr, &quot;bad ALPN select callback inputs\n&quot;);
-    exit(1);
-  }
-
-  *out = (const uint8_t*)config-&gt;select_alpn.data();
-  *outlen = config-&gt;select_alpn.size();
-  return SSL_TLSEXT_ERR_OK;
-}
-
-static unsigned PskClientCallback(SSL *ssl, const char *hint,
-                                  char *out_identity,
-                                  unsigned max_identity_len,
-                                  uint8_t *out_psk, unsigned max_psk_len) {
-  const TestConfig *config = GetTestConfig(ssl);
-
-  if (config-&gt;psk_identity.empty()) {
-    if (hint != nullptr) {
-      fprintf(stderr, &quot;Server PSK hint was non-null.\n&quot;);
-      return 0;
-    }
-  } else if (hint == nullptr ||
-             strcmp(hint, config-&gt;psk_identity.c_str()) != 0) {
-    fprintf(stderr, &quot;Server PSK hint did not match.\n&quot;);
-    return 0;
-  }
-
-  // Account for the trailing '\0' for the identity.
-  if (config-&gt;psk_identity.size() &gt;= max_identity_len ||
-      config-&gt;psk.size() &gt; max_psk_len) {
-    fprintf(stderr, &quot;PSK buffers too small\n&quot;);
-    return 0;
-  }
-
-  OPENSSL_strlcpy(out_identity, config-&gt;psk_identity.c_str(),
-                  max_identity_len);
-  memcpy(out_psk, config-&gt;psk.data(), config-&gt;psk.size());
-  return config-&gt;psk.size();
-}
-
-static unsigned PskServerCallback(SSL *ssl, const char *identity,
-                                  uint8_t *out_psk, unsigned max_psk_len) {
-  const TestConfig *config = GetTestConfig(ssl);
-
-  if (strcmp(identity, config-&gt;psk_identity.c_str()) != 0) {
-    fprintf(stderr, &quot;Client PSK identity did not match.\n&quot;);
-    return 0;
-  }
-
-  if (config-&gt;psk.size() &gt; max_psk_len) {
-    fprintf(stderr, &quot;PSK buffers too small\n&quot;);
-    return 0;
-  }
-
-  memcpy(out_psk, config-&gt;psk.data(), config-&gt;psk.size());
-  return config-&gt;psk.size();
-}
-
-static int CertCallback(SSL *ssl, void *arg) {
-  const TestConfig *config = GetTestConfig(ssl);
-
-  // Check the CertificateRequest metadata is as expected.
-  //
-  // TODO(davidben): Test |SSL_get_client_CA_list|.
-  if (!SSL_is_server(ssl) &amp;&amp;
-      !config-&gt;expected_certificate_types.empty()) {
-    const uint8_t *certificate_types;
-    size_t certificate_types_len =
-        SSL_get0_certificate_types(ssl, &amp;certificate_types);
-    if (certificate_types_len != config-&gt;expected_certificate_types.size() ||
-        memcmp(certificate_types,
-               config-&gt;expected_certificate_types.data(),
-               certificate_types_len) != 0) {
-      fprintf(stderr, &quot;certificate types mismatch\n&quot;);
-      return 0;
-    }
-  }
-
-  // The certificate will be installed via other means.
-  if (!config-&gt;async ||
-      config-&gt;use_old_client_cert_callback) {
-    return 1;
-  }
-
-  if (!GetTestState(ssl)-&gt;cert_ready) {
-    return -1;
-  }
-  if (!InstallCertificate(ssl)) {
-    return 0;
-  }
-  return 1;
-}
-
-static void InfoCallback(const SSL *ssl, int type, int val) {
-  if (type == SSL_CB_HANDSHAKE_DONE) {
-    if (GetTestConfig(ssl)-&gt;handshake_never_done) {
-      fprintf(stderr, &quot;Handshake unexpectedly completed.\n&quot;);
-      // Abort before any expected error code is printed, to ensure the overall
-      // test fails.
-      abort();
-    }
-    GetTestState(ssl)-&gt;handshake_done = true;
-
-    // Callbacks may be called again on a new handshake.
-    GetTestState(ssl)-&gt;ticket_decrypt_done = false;
-    GetTestState(ssl)-&gt;alpn_select_done = false;
-  }
-}
-
-static int NewSessionCallback(SSL *ssl, SSL_SESSION *session) {
-  GetTestState(ssl)-&gt;got_new_session = true;
-  GetTestState(ssl)-&gt;new_session.reset(session);
-  return 1;
-}
-
-static int TicketKeyCallback(SSL *ssl, uint8_t *key_name, uint8_t *iv,
-                             EVP_CIPHER_CTX *ctx, EVP_MAC_CTX *hmac_ctx,
-                             int encrypt) {
-  OSSL_PARAM params[2], *p = params;
-
-  if (!encrypt) {
-    if (GetTestState(ssl)-&gt;ticket_decrypt_done) {
-      fprintf(stderr, &quot;TicketKeyCallback called after completion.\n&quot;);
-      return -1;
-    }
-
-    GetTestState(ssl)-&gt;ticket_decrypt_done = true;
-  }
-
-  // This is just test code, so use the all-zeros key.
-  static const uint8_t kZeros[16] = {0};
-
-  if (encrypt) {
-    memcpy(key_name, kZeros, sizeof(kZeros));
-    RAND_bytes(iv, 16);
-  } else if (memcmp(key_name, kZeros, 16) != 0) {
-    return 0;
-  }
-
-  *p++ = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,
-                                          const_cast&lt;char *&gt;(&quot;SHA256&quot;), 0);
-  *p = OSSL_PARAM_construct_end();
-
-  if (!EVP_CipherInit_ex(ctx, EVP_aes_128_cbc(), NULL, kZeros, iv, encrypt)
-      || !EVP_MAC_init(hmac_ctx, kZeros, sizeof(kZeros), params)) {
-    return -1;
-  }
-
-  if (!encrypt) {
-    return GetTestConfig(ssl)-&gt;renew_ticket ? 2 : 1;
-  }
-  return 1;
-}
-
-// kCustomExtensionValue is the extension value that the custom extension
-// callbacks will add.
-static const uint16_t kCustomExtensionValue = 1234;
-static void *const kCustomExtensionAddArg =
-    reinterpret_cast&lt;void *&gt;(kCustomExtensionValue);
-static void *const kCustomExtensionParseArg =
-    reinterpret_cast&lt;void *&gt;(kCustomExtensionValue + 1);
-static const char kCustomExtensionContents[] = &quot;custom extension&quot;;
-
-static int CustomExtensionAddCallback(SSL *ssl, unsigned extension_value,
-                                      const uint8_t **out, size_t *out_len,
-                                      int *out_alert_value, void *add_arg) {
-  if (extension_value != kCustomExtensionValue ||
-      add_arg != kCustomExtensionAddArg) {
-    abort();
-  }
-
-  if (GetTestConfig(ssl)-&gt;custom_extension_skip) {
-    return 0;
-  }
-  if (GetTestConfig(ssl)-&gt;custom_extension_fail_add) {
-    return -1;
-  }
-
-  *out = reinterpret_cast&lt;const uint8_t*&gt;(kCustomExtensionContents);
-  *out_len = sizeof(kCustomExtensionContents) - 1;
-
-  return 1;
-}
-
-static void CustomExtensionFreeCallback(SSL *ssl, unsigned extension_value,
-                                        const uint8_t *out, void *add_arg) {
-  if (extension_value != kCustomExtensionValue ||
-      add_arg != kCustomExtensionAddArg ||
-      out != reinterpret_cast&lt;const uint8_t *&gt;(kCustomExtensionContents)) {
-    abort();
-  }
-}
-
-static int CustomExtensionParseCallback(SSL *ssl, unsigned extension_value,
-                                        const uint8_t *contents,
-                                        size_t contents_len,
-                                        int *out_alert_value, void *parse_arg) {
-  if (extension_value != kCustomExtensionValue ||
-      parse_arg != kCustomExtensionParseArg) {
-    abort();
-  }
-
-  if (contents_len != sizeof(kCustomExtensionContents) - 1 ||
-      memcmp(contents, kCustomExtensionContents, contents_len) != 0) {
-    *out_alert_value = SSL_AD_DECODE_ERROR;
-    return 0;
-  }
-
-  return 1;
-}
-
-static int ServerNameCallback(SSL *ssl, int *out_alert, void *arg) {
-  // SNI must be accessible from the SNI callback.
-  const TestConfig *config = GetTestConfig(ssl);
-  const char *server_name = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
-  if (server_name == nullptr ||
-      std::string(server_name) != config-&gt;expected_server_name) {
-    fprintf(stderr, &quot;servername mismatch (got %s; want %s)\n&quot;, server_name,
-            config-&gt;expected_server_name.c_str());
-    return SSL_TLSEXT_ERR_ALERT_FATAL;
-  }
-
-  return SSL_TLSEXT_ERR_OK;
-}
-
-// Connect returns a new socket connected to localhost on |port| or -1 on
-// error.
-static int Connect(uint16_t port) {
-  int sock = socket(AF_INET, SOCK_STREAM, 0);
-  if (sock == -1) {
-    PrintSocketError(&quot;socket&quot;);
-    return -1;
-  }
-  int nodelay = 1;
-  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
-          reinterpret_cast&lt;const char*&gt;(&amp;nodelay), sizeof(nodelay)) != 0) {
-    PrintSocketError(&quot;setsockopt&quot;);
-    closesocket(sock);
-    return -1;
-  }
-  sockaddr_in sin;
-  memset(&amp;sin, 0, sizeof(sin));
-  sin.sin_family = AF_INET;
-  sin.sin_port = htons(port);
-  if (!inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;sin.sin_addr)) {
-    PrintSocketError(&quot;inet_pton&quot;);
-    closesocket(sock);
-    return -1;
-  }
-  if (connect(sock, reinterpret_cast&lt;const sockaddr*&gt;(&amp;sin),
-              sizeof(sin)) != 0) {
-    PrintSocketError(&quot;connect&quot;);
-    closesocket(sock);
-    return -1;
-  }
-  return sock;
-}
-
-class SocketCloser {
- public:
-  explicit SocketCloser(int sock) : sock_(sock) {}
-  ~SocketCloser() {
-    // Half-close and drain the socket before releasing it. This seems to be
-    // necessary for graceful shutdown on Windows. It will also avoid write
-    // failures in the test runner.
-#if defined(OPENSSL_SYS_WINDOWS)
-    shutdown(sock_, SD_SEND);
-#else
-    shutdown(sock_, SHUT_WR);
-#endif
-    while (true) {
-      char buf[1024];
-      if (recv(sock_, buf, sizeof(buf), 0) &lt;= 0) {
-        break;
-      }
-    }
-    closesocket(sock_);
-  }
-
- private:
-  const int sock_;
-};
-
-static bssl::UniquePtr&lt;SSL_CTX&gt; SetupCtx(const TestConfig *config) {
-  const char sess_id_ctx[] = &quot;ossl_shim&quot;;
-  bssl::UniquePtr&lt;SSL_CTX&gt; ssl_ctx(SSL_CTX_new(
-      config-&gt;is_dtls ? DTLS_method() : TLS_method()));
-  if (!ssl_ctx) {
-    return nullptr;
-  }
-
-  SSL_CTX_set_security_level(ssl_ctx.get(), 0);
-#if 0
-  /* Disabled for now until we have some TLS1.3 support */
-  // Enable TLS 1.3 for tests.
-  if (!config-&gt;is_dtls &amp;&amp;
-      !SSL_CTX_set_max_proto_version(ssl_ctx.get(), TLS1_3_VERSION)) {
-    return nullptr;
-  }
-#else
-  /* Ensure we don't negotiate TLSv1.3 until we can handle it */
-  if (!config-&gt;is_dtls &amp;&amp;
-      !SSL_CTX_set_max_proto_version(ssl_ctx.get(), TLS1_2_VERSION)) {
-    return nullptr;
-  }
-#endif
-
-  std::string cipher_list = &quot;ALL&quot;;
-  if (!config-&gt;cipher.empty()) {
-    cipher_list = config-&gt;cipher;
-    SSL_CTX_set_options(ssl_ctx.get(), SSL_OP_CIPHER_SERVER_PREFERENCE);
-  }
-  if (!SSL_CTX_set_cipher_list(ssl_ctx.get(), cipher_list.c_str())) {
-    return nullptr;
-  }
-
-  DH *tmpdh;
-
-  if (config-&gt;use_sparse_dh_prime) {
-    BIGNUM *p, *g;
-    p = BN_new();
-    g = BN_new();
-    tmpdh = DH_new();
-    if (p == NULL || g == NULL || tmpdh == NULL) {
-        BN_free(p);
-        BN_free(g);
-        DH_free(tmpdh);
-        return nullptr;
-    }
-    // This prime number is 2^1024 + 643 &#8211; a value just above a power of two.
-    // Because of its form, values modulo it are essentially certain to be one
-    // byte shorter. This is used to test padding of these values.
-    if (BN_hex2bn(
-            &amp;p,
-            &quot;1000000000000000000000000000000000000000000000000000000000000000&quot;
-            &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
-            &quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
-            &quot;0000000000000000000000000000000000000000000000000000000000000028&quot;
-            &quot;3&quot;) == 0 ||
-        !BN_set_word(g, 2)) {
-      BN_free(p);
-      BN_free(g);
-      DH_free(tmpdh);
-      return nullptr;
-    }
-    DH_set0_pqg(tmpdh, p, NULL, g);
-  } else {
-      tmpdh = DH_get_2048_256();
-  }
-
-  bssl::UniquePtr&lt;DH&gt; dh(tmpdh);
-
-  if (!dh || !SSL_CTX_set_tmp_dh(ssl_ctx.get(), dh.get())) {
-    return nullptr;
-  }
-
-  SSL_CTX_set_session_cache_mode(ssl_ctx.get(), SSL_SESS_CACHE_BOTH);
-
-  if (config-&gt;use_old_client_cert_callback) {
-    SSL_CTX_set_client_cert_cb(ssl_ctx.get(), ClientCertCallback);
-  }
-
-  SSL_CTX_set_npn_advertised_cb(
-      ssl_ctx.get(), NextProtosAdvertisedCallback, NULL);
-  if (!config-&gt;select_next_proto.empty()) {
-    SSL_CTX_set_next_proto_select_cb(ssl_ctx.get(), NextProtoSelectCallback,
-                                     NULL);
-  }
-
-  if (!config-&gt;select_alpn.empty() || config-&gt;decline_alpn) {
-    SSL_CTX_set_alpn_select_cb(ssl_ctx.get(), AlpnSelectCallback, NULL);
-  }
-
-  SSL_CTX_set_info_callback(ssl_ctx.get(), InfoCallback);
-  SSL_CTX_sess_set_new_cb(ssl_ctx.get(), NewSessionCallback);
-
-  if (config-&gt;use_ticket_callback) {
-    SSL_CTX_set_tlsext_ticket_key_evp_cb(ssl_ctx.get(), TicketKeyCallback);
-  }
-
-  if (config-&gt;enable_client_custom_extension &amp;&amp;
-      !SSL_CTX_add_client_custom_ext(
-          ssl_ctx.get(), kCustomExtensionValue, CustomExtensionAddCallback,
-          CustomExtensionFreeCallback, kCustomExtensionAddArg,
-          CustomExtensionParseCallback, kCustomExtensionParseArg)) {
-    return nullptr;
-  }
-
-  if (config-&gt;enable_server_custom_extension &amp;&amp;
-      !SSL_CTX_add_server_custom_ext(
-          ssl_ctx.get(), kCustomExtensionValue, CustomExtensionAddCallback,
-          CustomExtensionFreeCallback, kCustomExtensionAddArg,
-          CustomExtensionParseCallback, kCustomExtensionParseArg)) {
-    return nullptr;
-  }
-
-  if (config-&gt;verify_fail) {
-    SSL_CTX_set_cert_verify_callback(ssl_ctx.get(), VerifyFail, NULL);
-  } else {
-    SSL_CTX_set_cert_verify_callback(ssl_ctx.get(), VerifySucceed, NULL);
-  }
-
-  if (config-&gt;use_null_client_ca_list) {
-    SSL_CTX_set_client_CA_list(ssl_ctx.get(), nullptr);
-  }
-
-  if (!SSL_CTX_set_session_id_context(ssl_ctx.get(),
-                                      (const unsigned char *)sess_id_ctx,
-                                      sizeof(sess_id_ctx) - 1))
-    return nullptr;
-
-  if (!config-&gt;expected_server_name.empty()) {
-    SSL_CTX_set_tlsext_servername_callback(ssl_ctx.get(), ServerNameCallback);
-  }
-
-  return ssl_ctx;
-}
-
-// RetryAsync is called after a failed operation on |ssl| with return code
-// |ret|. If the operation should be retried, it simulates one asynchronous
-// event and returns true. Otherwise it returns false.
-static bool RetryAsync(SSL *ssl, int ret) {
-  // No error; don't retry.
-  if (ret &gt;= 0) {
-    return false;
-  }
-
-  TestState *test_state = GetTestState(ssl);
-  assert(GetTestConfig(ssl)-&gt;async);
-
-  if (test_state-&gt;packeted_bio != nullptr &amp;&amp;
-      PacketedBioAdvanceClock(test_state-&gt;packeted_bio)) {
-    // The DTLS retransmit logic silently ignores write failures. So the test
-    // may progress, allow writes through synchronously.
-    AsyncBioEnforceWriteQuota(test_state-&gt;async_bio, false);
-    int timeout_ret = DTLSv1_handle_timeout(ssl);
-    AsyncBioEnforceWriteQuota(test_state-&gt;async_bio, true);
-
-    if (timeout_ret &lt; 0) {
-      fprintf(stderr, &quot;Error retransmitting.\n&quot;);
-      return false;
-    }
-    return true;
-  }
-
-  // See if we needed to read or write more. If so, allow one byte through on
-  // the appropriate end to maximally stress the state machine.
-  switch (SSL_get_error(ssl, ret)) {
-    case SSL_ERROR_WANT_READ:
-      AsyncBioAllowRead(test_state-&gt;async_bio, 1);
-      return true;
-    case SSL_ERROR_WANT_WRITE:
-      AsyncBioAllowWrite(test_state-&gt;async_bio, 1);
-      return true;
-    case SSL_ERROR_WANT_X509_LOOKUP:
-      test_state-&gt;cert_ready = true;
-      return true;
-    default:
-      return false;
-  }
-}
-
-// DoRead reads from |ssl|, resolving any asynchronous operations. It returns
-// the result value of the final |SSL_read| call.
-static int DoRead(SSL *ssl, uint8_t *out, size_t max_out) {
-  const TestConfig *config = GetTestConfig(ssl);
-  TestState *test_state = GetTestState(ssl);
-  int ret;
-  do {
-    if (config-&gt;async) {
-      // The DTLS retransmit logic silently ignores write failures. So the test
-      // may progress, allow writes through synchronously. |SSL_read| may
-      // trigger a retransmit, so disconnect the write quota.
-      AsyncBioEnforceWriteQuota(test_state-&gt;async_bio, false);
-    }
-    ret = config-&gt;peek_then_read ? SSL_peek(ssl, out, max_out)
-                                 : SSL_read(ssl, out, max_out);
-    if (config-&gt;async) {
-      AsyncBioEnforceWriteQuota(test_state-&gt;async_bio, true);
-    }
-  } while (config-&gt;async &amp;&amp; RetryAsync(ssl, ret));
-
-  if (config-&gt;peek_then_read &amp;&amp; ret &gt; 0) {
-    std::unique_ptr&lt;uint8_t[]&gt; buf(new uint8_t[static_cast&lt;size_t&gt;(ret)]);
-
-    // SSL_peek should synchronously return the same data.
-    int ret2 = SSL_peek(ssl, buf.get(), ret);
-    if (ret2 != ret ||
-        memcmp(buf.get(), out, ret) != 0) {
-      fprintf(stderr, &quot;First and second SSL_peek did not match.\n&quot;);
-      return -1;
-    }
-
-    // SSL_read should synchronously return the same data and consume it.
-    ret2 = SSL_read(ssl, buf.get(), ret);
-    if (ret2 != ret ||
-        memcmp(buf.get(), out, ret) != 0) {
-      fprintf(stderr, &quot;SSL_peek and SSL_read did not match.\n&quot;);
-      return -1;
-    }
-  }
-
-  return ret;
-}
-
-// WriteAll writes |in_len| bytes from |in| to |ssl|, resolving any asynchronous
-// operations. It returns the result of the final |SSL_write| call.
-static int WriteAll(SSL *ssl, const uint8_t *in, size_t in_len) {
-  const TestConfig *config = GetTestConfig(ssl);
-  int ret;
-  do {
-    ret = SSL_write(ssl, in, in_len);
-    if (ret &gt; 0) {
-      in += ret;
-      in_len -= ret;
-    }
-  } while ((config-&gt;async &amp;&amp; RetryAsync(ssl, ret)) || (ret &gt; 0 &amp;&amp; in_len &gt; 0));
-  return ret;
-}
-
-// DoShutdown calls |SSL_shutdown|, resolving any asynchronous operations. It
-// returns the result of the final |SSL_shutdown| call.
-static int DoShutdown(SSL *ssl) {
-  const TestConfig *config = GetTestConfig(ssl);
-  int ret;
-  do {
-    ret = SSL_shutdown(ssl);
-  } while (config-&gt;async &amp;&amp; RetryAsync(ssl, ret));
-  return ret;
-}
-
-static uint16_t GetProtocolVersion(const SSL *ssl) {
-  uint16_t version = SSL_version(ssl);
-  if (!SSL_is_dtls(ssl)) {
-    return version;
-  }
-  return 0x0201 + ~version;
-}
-
-// CheckHandshakeProperties checks, immediately after |ssl| completes its
-// initial handshake (or False Starts), whether all the properties are
-// consistent with the test configuration and invariants.
-static bool CheckHandshakeProperties(SSL *ssl, bool is_resume) {
-  const TestConfig *config = GetTestConfig(ssl);
-
-  if (SSL_get_current_cipher(ssl) == nullptr) {
-    fprintf(stderr, &quot;null cipher after handshake\n&quot;);
-    return false;
-  }
-
-  if (is_resume &amp;&amp;
-      (!!SSL_session_reused(ssl) == config-&gt;expect_session_miss)) {
-    fprintf(stderr, &quot;session was%s reused\n&quot;,
-            SSL_session_reused(ssl) ? &quot;&quot; : &quot; not&quot;);
-    return false;
-  }
-
-  if (!GetTestState(ssl)-&gt;handshake_done) {
-    fprintf(stderr, &quot;handshake was not completed\n&quot;);
-    return false;
-  }
-
-  if (!config-&gt;is_server) {
-    bool expect_new_session =
-        !config-&gt;expect_no_session &amp;&amp;
-        (!SSL_session_reused(ssl) || config-&gt;expect_ticket_renewal) &amp;&amp;
-        // Session tickets are sent post-handshake in TLS 1.3.
-        GetProtocolVersion(ssl) &lt; TLS1_3_VERSION;
-    if (expect_new_session != GetTestState(ssl)-&gt;got_new_session) {
-      fprintf(stderr,
-              &quot;new session was%s cached, but we expected the opposite\n&quot;,
-              GetTestState(ssl)-&gt;got_new_session ? &quot;&quot; : &quot; not&quot;);
-      return false;
-    }
-  }
-
-  if (!config-&gt;expected_server_name.empty()) {
-    const char *server_name =
-        SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
-    if (server_name == nullptr ||
-            std::string(server_name) != config-&gt;expected_server_name) {
-      fprintf(stderr, &quot;servername mismatch (got %s; want %s)\n&quot;,
-              server_name, config-&gt;expected_server_name.c_str());
-      return false;
-    }
-  }
-
-  if (!config-&gt;expected_next_proto.empty()) {
-    const uint8_t *next_proto;
-    unsigned next_proto_len;
-    SSL_get0_next_proto_negotiated(ssl, &amp;next_proto, &amp;next_proto_len);
-    if (next_proto_len != config-&gt;expected_next_proto.size() ||
-        memcmp(next_proto, config-&gt;expected_next_proto.data(),
-               next_proto_len) != 0) {
-      fprintf(stderr, &quot;negotiated next proto mismatch\n&quot;);
-      return false;
-    }
-  }
-
-  if (!config-&gt;expected_alpn.empty()) {
-    const uint8_t *alpn_proto;
-    unsigned alpn_proto_len;
-    SSL_get0_alpn_selected(ssl, &amp;alpn_proto, &amp;alpn_proto_len);
-    if (alpn_proto_len != config-&gt;expected_alpn.size() ||
-        memcmp(alpn_proto, config-&gt;expected_alpn.data(),
-               alpn_proto_len) != 0) {
-      fprintf(stderr, &quot;negotiated alpn proto mismatch\n&quot;);
-      return false;
-    }
-  }
-
-  if (config-&gt;expect_extended_master_secret) {
-    if (!SSL_get_extms_support(ssl)) {
-      fprintf(stderr, &quot;No EMS for connection when expected&quot;);
-      return false;
-    }
-  }
-
-  if (config-&gt;expect_verify_result) {
-    int expected_verify_result = config-&gt;verify_fail ?
-      X509_V_ERR_APPLICATION_VERIFICATION :
-      X509_V_OK;
-
-    if (SSL_get_verify_result(ssl) != expected_verify_result) {
-      fprintf(stderr, &quot;Wrong certificate verification result\n&quot;);
-      return false;
-    }
-  }
-
-  if (!config-&gt;psk.empty()) {
-    if (SSL_get_peer_cert_chain(ssl) != nullptr) {
-      fprintf(stderr, &quot;Received peer certificate on a PSK cipher.\n&quot;);
-      return false;
-    }
-  } else if (!config-&gt;is_server || config-&gt;require_any_client_certificate) {
-    if (SSL_get0_peer_certificate(ssl) == nullptr) {
-      fprintf(stderr, &quot;Received no peer certificate but expected one.\n&quot;);
-      return false;
-    }
-  }
-
-  return true;
-}
-
-// DoExchange runs a test SSL exchange against the peer. On success, it returns
-// true and sets |*out_session| to the negotiated SSL session. If the test is a
-// resumption attempt, |is_resume| is true and |session| is the session from the
-// previous exchange.
-static bool DoExchange(bssl::UniquePtr&lt;SSL_SESSION&gt; *out_session,
-                       SSL_CTX *ssl_ctx, const TestConfig *config,
-                       bool is_resume, SSL_SESSION *session) {
-  bssl::UniquePtr&lt;SSL&gt; ssl(SSL_new(ssl_ctx));
-  if (!ssl) {
-    return false;
-  }
-
-  if (!SetTestConfig(ssl.get(), config) ||
-      !SetTestState(ssl.get(), std::unique_ptr&lt;TestState&gt;(new TestState))) {
-    return false;
-  }
-
-  if (config-&gt;fallback_scsv &amp;&amp;
-      !SSL_set_mode(ssl.get(), SSL_MODE_SEND_FALLBACK_SCSV)) {
-    return false;
-  }
-  // Install the certificate synchronously if nothing else will handle it.
-  if (!config-&gt;use_old_client_cert_callback &amp;&amp;
-      !config-&gt;async &amp;&amp;
-      !InstallCertificate(ssl.get())) {
-    return false;
-  }
-  SSL_set_cert_cb(ssl.get(), CertCallback, nullptr);
-  if (config-&gt;require_any_client_certificate) {
-    SSL_set_verify(ssl.get(), SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
-                   NULL);
-  }
-  if (config-&gt;verify_peer) {
-    SSL_set_verify(ssl.get(), SSL_VERIFY_PEER, NULL);
-  }
-  if (config-&gt;partial_write) {
-    SSL_set_mode(ssl.get(), SSL_MODE_ENABLE_PARTIAL_WRITE);
-  }
-  if (config-&gt;no_tls13) {
-    SSL_set_options(ssl.get(), SSL_OP_NO_TLSv1_3);
-  }
-  if (config-&gt;no_tls12) {
-    SSL_set_options(ssl.get(), SSL_OP_NO_TLSv1_2);
-  }
-  if (config-&gt;no_tls11) {
-    SSL_set_options(ssl.get(), SSL_OP_NO_TLSv1_1);
-  }
-  if (config-&gt;no_tls1) {
-    SSL_set_options(ssl.get(), SSL_OP_NO_TLSv1);
-  }
-  if (config-&gt;no_ssl3) {
-    SSL_set_options(ssl.get(), SSL_OP_NO_SSLv3);
-  }
-  if (!config-&gt;host_name.empty() &amp;&amp;
-      !SSL_set_tlsext_host_name(ssl.get(), config-&gt;host_name.c_str())) {
-    return false;
-  }
-  if (!config-&gt;advertise_alpn.empty() &amp;&amp;
-      SSL_set_alpn_protos(ssl.get(),
-                          (const uint8_t *)config-&gt;advertise_alpn.data(),
-                          config-&gt;advertise_alpn.size()) != 0) {
-    return false;
-  }
-  if (!config-&gt;psk.empty()) {
-    SSL_set_psk_client_callback(ssl.get(), PskClientCallback);
-    SSL_set_psk_server_callback(ssl.get(), PskServerCallback);
-  }
-  if (!config-&gt;psk_identity.empty() &amp;&amp;
-      !SSL_use_psk_identity_hint(ssl.get(), config-&gt;psk_identity.c_str())) {
-    return false;
-  }
-  if (!config-&gt;srtp_profiles.empty() &amp;&amp;
-      SSL_set_tlsext_use_srtp(ssl.get(), config-&gt;srtp_profiles.c_str())) {
-    return false;
-  }
-  if (config-&gt;min_version != 0 &amp;&amp;
-      !SSL_set_min_proto_version(ssl.get(), (uint16_t)config-&gt;min_version)) {
-    return false;
-  }
-  if (config-&gt;max_version != 0 &amp;&amp;
-      !SSL_set_max_proto_version(ssl.get(), (uint16_t)config-&gt;max_version)) {
-    return false;
-  }
-  if (config-&gt;mtu != 0) {
-    SSL_set_options(ssl.get(), SSL_OP_NO_QUERY_MTU);
-    SSL_set_mtu(ssl.get(), config-&gt;mtu);
-  }
-  if (config-&gt;renegotiate_freely) {
-    // This is always on for OpenSSL.
-  }
-  if (!config-&gt;check_close_notify) {
-    SSL_set_quiet_shutdown(ssl.get(), 1);
-  }
-  if (config-&gt;p384_only) {
-    int nid = NID_secp384r1;
-    if (!SSL_set1_curves(ssl.get(), &amp;nid, 1)) {
-      return false;
-    }
-  }
-  if (config-&gt;enable_all_curves) {
-    static const int kAllCurves[] = {
-      NID_X25519, NID_X9_62_prime256v1, NID_X448, NID_secp521r1, NID_secp384r1
-    };
-    if (!SSL_set1_curves(ssl.get(), kAllCurves,
-                         OPENSSL_ARRAY_SIZE(kAllCurves))) {
-      return false;
-    }
-  }
-  if (config-&gt;max_cert_list &gt; 0) {
-    SSL_set_max_cert_list(ssl.get(), config-&gt;max_cert_list);
-  }
-
-  if (!config-&gt;async) {
-    SSL_set_mode(ssl.get(), SSL_MODE_AUTO_RETRY);
-  }
-
-  int sock = Connect(config-&gt;port);
-  if (sock == -1) {
-    return false;
-  }
-  SocketCloser closer(sock);
-
-  bssl::UniquePtr&lt;BIO&gt; bio(BIO_new_socket(sock, BIO_NOCLOSE));
-  if (!bio) {
-    return false;
-  }
-  if (config-&gt;is_dtls) {
-    bssl::UniquePtr&lt;BIO&gt; packeted = PacketedBioCreate(!config-&gt;async);
-    if (!packeted) {
-      return false;
-    }
-    GetTestState(ssl.get())-&gt;packeted_bio = packeted.get();
-    BIO_push(packeted.get(), bio.release());
-    bio = std::move(packeted);
-  }
-  if (config-&gt;async) {
-    bssl::UniquePtr&lt;BIO&gt; async_scoped =
-        config-&gt;is_dtls ? AsyncBioCreateDatagram() : AsyncBioCreate();
-    if (!async_scoped) {
-      return false;
-    }
-    BIO_push(async_scoped.get(), bio.release());
-    GetTestState(ssl.get())-&gt;async_bio = async_scoped.get();
-    bio = std::move(async_scoped);
-  }
-  SSL_set_bio(ssl.get(), bio.get(), bio.get());
-  bio.release();  // SSL_set_bio takes ownership.
-
-  if (session != NULL) {
-    if (!config-&gt;is_server) {
-      if (SSL_set_session(ssl.get(), session) != 1) {
-        return false;
-      }
-    }
-  }
-
-#if 0
-  // KNOWN BUG: OpenSSL's SSL_get_current_cipher behaves incorrectly when
-  // offering resumption.
-  if (SSL_get_current_cipher(ssl.get()) != nullptr) {
-    fprintf(stderr, &quot;non-null cipher before handshake\n&quot;);
-    return false;
-  }
-#endif
-
-  int ret;
-  if (config-&gt;implicit_handshake) {
-    if (config-&gt;is_server) {
-      SSL_set_accept_state(ssl.get());
-    } else {
-      SSL_set_connect_state(ssl.get());
-    }
-  } else {
-    do {
-      if (config-&gt;is_server) {
-        ret = SSL_accept(ssl.get());
-      } else {
-        ret = SSL_connect(ssl.get());
-      }
-    } while (config-&gt;async &amp;&amp; RetryAsync(ssl.get(), ret));
-    if (ret != 1 ||
-        !CheckHandshakeProperties(ssl.get(), is_resume)) {
-      fprintf(stderr, &quot;resumption check failed\n&quot;);
-      return false;
-    }
-
-    // Reset the state to assert later that the callback isn't called in
-    // renegotiations.
-    GetTestState(ssl.get())-&gt;got_new_session = false;
-  }
-
-  if (config-&gt;export_keying_material &gt; 0) {
-    std::vector&lt;uint8_t&gt; result(
-        static_cast&lt;size_t&gt;(config-&gt;export_keying_material));
-    if (SSL_export_keying_material(
-            ssl.get(), result.data(), result.size(),
-            config-&gt;export_label.data(), config-&gt;export_label.size(),
-            reinterpret_cast&lt;const uint8_t*&gt;(config-&gt;export_context.data()),
-            config-&gt;export_context.size(), config-&gt;use_export_context) != 1) {
-      fprintf(stderr, &quot;failed to export keying material\n&quot;);
-      return false;
-    }
-    if (WriteAll(ssl.get(), result.data(), result.size()) &lt; 0) {
-      fprintf(stderr, &quot;writing exported key material failed\n&quot;);
-      return false;
-    }
-  }
-
-  if (config-&gt;write_different_record_sizes) {
-    if (config-&gt;is_dtls) {
-      fprintf(stderr, &quot;write_different_record_sizes not supported for DTLS\n&quot;);
-      return false;
-    }
-    // This mode writes a number of different record sizes in an attempt to
-    // trip up the CBC record splitting code.
-    static const size_t kBufLen = 32769;
-    std::unique_ptr&lt;uint8_t[]&gt; buf(new uint8_t[kBufLen]);
-    memset(buf.get(), 0x42, kBufLen);
-    static const size_t kRecordSizes[] = {
-        0, 1, 255, 256, 257, 16383, 16384, 16385, 32767, 32768, 32769};
-    for (size_t i = 0; i &lt; OPENSSL_ARRAY_SIZE(kRecordSizes); i++) {
-      const size_t len = kRecordSizes[i];
-      if (len &gt; kBufLen) {
-        fprintf(stderr, &quot;Bad kRecordSizes value.\n&quot;);
-        return false;
-      }
-      if (WriteAll(ssl.get(), buf.get(), len) &lt; 0) {
-        return false;
-      }
-    }
-  } else {
-    if (config-&gt;shim_writes_first) {
-      if (WriteAll(ssl.get(), reinterpret_cast&lt;const uint8_t *&gt;(&quot;hello&quot;),
-                   5) &lt; 0) {
-        fprintf(stderr, &quot;shim_writes_first write failed\n&quot;);
-        return false;
-      }
-    }
-    if (!config-&gt;shim_shuts_down) {
-      for (;;) {
-        static const size_t kBufLen = 16384;
-        std::unique_ptr&lt;uint8_t[]&gt; buf(new uint8_t[kBufLen]);
-
-        // Read only 512 bytes at a time in TLS to ensure records may be
-        // returned in multiple reads.
-        int n = DoRead(ssl.get(), buf.get(), config-&gt;is_dtls ? kBufLen : 512);
-        int err = SSL_get_error(ssl.get(), n);
-        if (err == SSL_ERROR_ZERO_RETURN ||
-            (n == 0 &amp;&amp; err == SSL_ERROR_SYSCALL)) {
-          if (n != 0) {
-            fprintf(stderr, &quot;Invalid SSL_get_error output\n&quot;);
-            return false;
-          }
-          // Stop on either clean or unclean shutdown.
-          break;
-        } else if (err != SSL_ERROR_NONE) {
-          if (n &gt; 0) {
-            fprintf(stderr, &quot;Invalid SSL_get_error output\n&quot;);
-            return false;
-          }
-          fprintf(stderr, &quot;Unexpected entry in error queue\n&quot;);
-          return false;
-        }
-        // Successfully read data.
-        if (n &lt;= 0) {
-          fprintf(stderr, &quot;Invalid SSL_get_error output\n&quot;);
-          return false;
-        }
-
-        // After a successful read, with or without False Start, the handshake
-        // must be complete.
-        if (!GetTestState(ssl.get())-&gt;handshake_done) {
-          fprintf(stderr, &quot;handshake was not completed after SSL_read\n&quot;);
-          return false;
-        }
-
-        for (int i = 0; i &lt; n; i++) {
-          buf[i] ^= 0xff;
-        }
-        if (WriteAll(ssl.get(), buf.get(), n) &lt; 0) {
-          fprintf(stderr, &quot;write of inverted bitstream failed\n&quot;);
-          return false;
-        }
-      }
-    }
-  }
-
-  if (!config-&gt;is_server &amp;&amp;
-      !config-&gt;implicit_handshake &amp;&amp;
-      // Session tickets are sent post-handshake in TLS 1.3.
-      GetProtocolVersion(ssl.get()) &lt; TLS1_3_VERSION &amp;&amp;
-      GetTestState(ssl.get())-&gt;got_new_session) {
-    fprintf(stderr, &quot;new session was established after the handshake\n&quot;);
-    return false;
-  }
-
-  if (GetProtocolVersion(ssl.get()) &gt;= TLS1_3_VERSION &amp;&amp; !config-&gt;is_server) {
-    bool expect_new_session =
-        !config-&gt;expect_no_session &amp;&amp; !config-&gt;shim_shuts_down;
-    if (expect_new_session != GetTestState(ssl.get())-&gt;got_new_session) {
-      fprintf(stderr,
-              &quot;new session was%s cached, but we expected the opposite\n&quot;,
-              GetTestState(ssl.get())-&gt;got_new_session ? &quot;&quot; : &quot; not&quot;);
-      return false;
-    }
-  }
-
-  if (out_session) {
-    *out_session = std::move(GetTestState(ssl.get())-&gt;new_session);
-  }
-
-  ret = DoShutdown(ssl.get());
-
-  if (config-&gt;shim_shuts_down &amp;&amp; config-&gt;check_close_notify) {
-    // We initiate shutdown, so |SSL_shutdown| will return in two stages. First
-    // it returns zero when our close_notify is sent, then one when the peer's
-    // is received.
-    if (ret != 0) {
-      fprintf(stderr, &quot;Unexpected SSL_shutdown result: %d != 0\n&quot;, ret);
-      return false;
-    }
-    ret = DoShutdown(ssl.get());
-  }
-
-  if (ret != 1) {
-    fprintf(stderr, &quot;Unexpected SSL_shutdown result: %d != 1\n&quot;, ret);
-    return false;
-  }
-
-  if (SSL_total_renegotiations(ssl.get()) !=
-      config-&gt;expect_total_renegotiations) {
-    fprintf(stderr, &quot;Expected %d renegotiations, got %ld\n&quot;,
-            config-&gt;expect_total_renegotiations,
-            SSL_total_renegotiations(ssl.get()));
-    return false;
-  }
-
-  return true;
-}
-
-class StderrDelimiter {
- public:
-  ~StderrDelimiter() { fprintf(stderr, &quot;--- DONE ---\n&quot;); }
-};
-
-static int Main(int argc, char **argv) {
-  // To distinguish ASan's output from ours, add a trailing message to stderr.
-  // Anything following this line will be considered an error.
-  StderrDelimiter delimiter;
-
-#if defined(OPENSSL_SYS_WINDOWS)
-  /* Initialize Winsock. */
-  WORD wsa_version = MAKEWORD(2, 2);
-  WSADATA wsa_data;
-  int wsa_err = WSAStartup(wsa_version, &amp;wsa_data);
-  if (wsa_err != 0) {
-    fprintf(stderr, &quot;WSAStartup failed: %d\n&quot;, wsa_err);
-    return 1;
-  }
-  if (wsa_data.wVersion != wsa_version) {
-    fprintf(stderr, &quot;Didn't get expected version: %x\n&quot;, wsa_data.wVersion);
-    return 1;
-  }
-#else
-  signal(SIGPIPE, SIG_IGN);
-#endif
-
-  OPENSSL_init_crypto(0, NULL);
-  OPENSSL_init_ssl(0, NULL);
-  g_config_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);
-  g_state_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, TestStateExFree);
-  if (g_config_index &lt; 0 || g_state_index &lt; 0) {
-    return 1;
-  }
-
-  TestConfig config;
-  if (!ParseConfig(argc - 1, argv + 1, &amp;config)) {
-    return Usage(argv[0]);
-  }
-
-  bssl::UniquePtr&lt;SSL_CTX&gt; ssl_ctx = SetupCtx(&amp;config);
-  if (!ssl_ctx) {
-    ERR_print_errors_fp(stderr);
-    return 1;
-  }
-
-  bssl::UniquePtr&lt;SSL_SESSION&gt; session;
-  for (int i = 0; i &lt; config.resume_count + 1; i++) {
-    bool is_resume = i &gt; 0;
-    if (is_resume &amp;&amp; !config.is_server &amp;&amp; !session) {
-      fprintf(stderr, &quot;No session to offer.\n&quot;);
-      return 1;
-    }
-
-    bssl::UniquePtr&lt;SSL_SESSION&gt; offer_session = std::move(session);
-    if (!DoExchange(&amp;session, ssl_ctx.get(), &amp;config, is_resume,
-                    offer_session.get())) {
-      fprintf(stderr, &quot;Connection %d failed.\n&quot;, i + 1);
-      ERR_print_errors_fp(stderr);
-      return 1;
-    }
-  }
-
-  return 0;
-}
-
-}  // namespace bssl
-
-int main(int argc, char **argv) {
-  return bssl::Main(argc, argv);
-}
diff --git a/test/ossl_shim/packeted_bio.cc b/test/ossl_shim/packeted_bio.cc
deleted file mode 100644
index b5286d3e7c..0000000000
--- a/test/ossl_shim/packeted_bio.cc
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#include &quot;packeted_bio.h&quot;
-
-#include &lt;assert.h&gt;
-#include &lt;limits.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-
-#include &lt;openssl/crypto.h&gt;
-
-
-namespace {
-
-const uint8_t kOpcodePacket = 'P';
-const uint8_t kOpcodeTimeout = 'T';
-const uint8_t kOpcodeTimeoutAck = 't';
-
-struct PacketedBio {
-  explicit PacketedBio(bool advance_clock_arg)
-      : advance_clock(advance_clock_arg) {
-    memset(&amp;timeout, 0, sizeof(timeout));
-    memset(&amp;clock, 0, sizeof(clock));
-    memset(&amp;read_deadline, 0, sizeof(read_deadline));
-  }
-
-  bool HasTimeout() const {
-    return timeout.tv_sec != 0 || timeout.tv_usec != 0;
-  }
-
-  bool CanRead() const {
-    if (read_deadline.tv_sec == 0 &amp;&amp; read_deadline.tv_usec == 0) {
-      return true;
-    }
-
-    if (clock.tv_sec == read_deadline.tv_sec) {
-      return clock.tv_usec &lt; read_deadline.tv_usec;
-    }
-    return clock.tv_sec &lt; read_deadline.tv_sec;
-  }
-
-  timeval timeout;
-  timeval clock;
-  timeval read_deadline;
-  bool advance_clock;
-};
-
-PacketedBio *GetData(BIO *bio) {
-  return (PacketedBio *)BIO_get_data(bio);
-}
-
-const PacketedBio *GetData(const BIO *bio) {
-  return GetData(const_cast&lt;BIO*&gt;(bio));
-}
-
-// ReadAll reads |len| bytes from |bio| into |out|. It returns 1 on success and
-// 0 or -1 on error.
-static int ReadAll(BIO *bio, uint8_t *out, size_t len) {
-  while (len &gt; 0) {
-    int chunk_len = INT_MAX;
-    if (len &lt;= INT_MAX) {
-      chunk_len = (int)len;
-    }
-    int ret = BIO_read(bio, out, chunk_len);
-    if (ret &lt;= 0) {
-      return ret;
-    }
-    out += ret;
-    len -= ret;
-  }
-  return 1;
-}
-
-static int PacketedWrite(BIO *bio, const char *in, int inl) {
-  if (BIO_next(bio) == NULL) {
-    return 0;
-  }
-
-  BIO_clear_retry_flags(bio);
-
-  // Write the header.
-  uint8_t header[5];
-  header[0] = kOpcodePacket;
-  header[1] = (inl &gt;&gt; 24) &amp; 0xff;
-  header[2] = (inl &gt;&gt; 16) &amp; 0xff;
-  header[3] = (inl &gt;&gt; 8) &amp; 0xff;
-  header[4] = inl &amp; 0xff;
-  int ret = BIO_write(BIO_next(bio), header, sizeof(header));
-  if (ret &lt;= 0) {
-    BIO_copy_next_retry(bio);
-    return ret;
-  }
-
-  // Write the buffer.
-  ret = BIO_write(BIO_next(bio), in, inl);
-  if (ret &lt; 0 || (inl &gt; 0 &amp;&amp; ret == 0)) {
-    BIO_copy_next_retry(bio);
-    return ret;
-  }
-  assert(ret == inl);
-  return ret;
-}
-
-static int PacketedRead(BIO *bio, char *out, int outl) {
-  PacketedBio *data = GetData(bio);
-  if (BIO_next(bio) == NULL) {
-    return 0;
-  }
-
-  BIO_clear_retry_flags(bio);
-
-  for (;;) {
-    // Check if the read deadline has passed.
-    if (!data-&gt;CanRead()) {
-      BIO_set_retry_read(bio);
-      return -1;
-    }
-
-    // Read the opcode.
-    uint8_t opcode;
-    int ret = ReadAll(BIO_next(bio), &amp;opcode, sizeof(opcode));
-    if (ret &lt;= 0) {
-      BIO_copy_next_retry(bio);
-      return ret;
-    }
-
-    if (opcode == kOpcodeTimeout) {
-      // The caller is required to advance any pending timeouts before
-      // continuing.
-      if (data-&gt;HasTimeout()) {
-        fprintf(stderr, &quot;Unprocessed timeout!\n&quot;);
-        return -1;
-      }
-
-      // Process the timeout.
-      uint8_t buf[8];
-      ret = ReadAll(BIO_next(bio), buf, sizeof(buf));
-      if (ret &lt;= 0) {
-        BIO_copy_next_retry(bio);
-        return ret;
-      }
-      uint64_t timeout = (static_cast&lt;uint64_t&gt;(buf[0]) &lt;&lt; 56) |
-          (static_cast&lt;uint64_t&gt;(buf[1]) &lt;&lt; 48) |
-          (static_cast&lt;uint64_t&gt;(buf[2]) &lt;&lt; 40) |
-          (static_cast&lt;uint64_t&gt;(buf[3]) &lt;&lt; 32) |
-          (static_cast&lt;uint64_t&gt;(buf[4]) &lt;&lt; 24) |
-          (static_cast&lt;uint64_t&gt;(buf[5]) &lt;&lt; 16) |
-          (static_cast&lt;uint64_t&gt;(buf[6]) &lt;&lt; 8) |
-          static_cast&lt;uint64_t&gt;(buf[7]);
-      timeout /= 1000;  // Convert nanoseconds to microseconds.
-
-      data-&gt;timeout.tv_usec = timeout % 1000000;
-      data-&gt;timeout.tv_sec = timeout / 1000000;
-
-      // Send an ACK to the peer.
-      ret = BIO_write(BIO_next(bio), &amp;kOpcodeTimeoutAck, 1);
-      if (ret &lt;= 0) {
-        return ret;
-      }
-      assert(ret == 1);
-
-      if (!data-&gt;advance_clock) {
-        // Signal to the caller to retry the read, after advancing the clock.
-        BIO_set_retry_read(bio);
-        return -1;
-      }
-
-      PacketedBioAdvanceClock(bio);
-      continue;
-    }
-
-    if (opcode != kOpcodePacket) {
-      fprintf(stderr, &quot;Unknown opcode, %u\n&quot;, opcode);
-      return -1;
-    }
-
-    // Read the length prefix.
-    uint8_t len_bytes[4];
-    ret = ReadAll(BIO_next(bio), len_bytes, sizeof(len_bytes));
-    if (ret &lt;= 0) {
-      BIO_copy_next_retry(bio);
-      return ret;
-    }
-
-    uint32_t len = (len_bytes[0] &lt;&lt; 24) | (len_bytes[1] &lt;&lt; 16) |
-        (len_bytes[2] &lt;&lt; 8) | len_bytes[3];
-    uint8_t *buf = (uint8_t *)OPENSSL_malloc(len);
-    if (buf == NULL) {
-      return -1;
-    }
-    ret = ReadAll(BIO_next(bio), buf, len);
-    if (ret &lt;= 0) {
-      fprintf(stderr, &quot;Packeted BIO was truncated\n&quot;);
-      return -1;
-    }
-
-    if (outl &gt; (int)len) {
-      outl = len;
-    }
-    memcpy(out, buf, outl);
-    OPENSSL_free(buf);
-    return outl;
-  }
-}
-
-static long PacketedCtrl(BIO *bio, int cmd, long num, void *ptr) {
-  if (cmd == BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT) {
-    memcpy(&amp;GetData(bio)-&gt;read_deadline, ptr, sizeof(timeval));
-    return 1;
-  }
-
-  if (BIO_next(bio) == NULL) {
-    return 0;
-  }
-  BIO_clear_retry_flags(bio);
-  int ret = BIO_ctrl(BIO_next(bio), cmd, num, ptr);
-  BIO_copy_next_retry(bio);
-  return ret;
-}
-
-static int PacketedNew(BIO *bio) {
-  BIO_set_init(bio, 1);
-  return 1;
-}
-
-static int PacketedFree(BIO *bio) {
-  if (bio == NULL) {
-    return 0;
-  }
-
-  delete GetData(bio);
-  BIO_set_init(bio, 0);
-  return 1;
-}
-
-static long PacketedCallbackCtrl(BIO *bio, int cmd, BIO_info_cb fp)
-{
-  if (BIO_next(bio) == NULL)
-    return 0;
-  return BIO_callback_ctrl(BIO_next(bio), cmd, fp);
-}
-
-static BIO_METHOD *g_packeted_bio_method = NULL;
-
-static const BIO_METHOD *PacketedMethod(void)
-{
-  if (g_packeted_bio_method == NULL) {
-    g_packeted_bio_method = BIO_meth_new(BIO_TYPE_FILTER, &quot;packeted bio&quot;);
-    if (   g_packeted_bio_method == NULL
-        || !BIO_meth_set_write(g_packeted_bio_method, PacketedWrite)
-        || !BIO_meth_set_read(g_packeted_bio_method, PacketedRead)
-        || !BIO_meth_set_ctrl(g_packeted_bio_method, PacketedCtrl)
-        || !BIO_meth_set_create(g_packeted_bio_method, PacketedNew)
-        || !BIO_meth_set_destroy(g_packeted_bio_method, PacketedFree)
-        || !BIO_meth_set_callback_ctrl(g_packeted_bio_method,
-                                       PacketedCallbackCtrl))
-    return NULL;
-  }
-  return g_packeted_bio_method;
-}
-}  // namespace
-
-bssl::UniquePtr&lt;BIO&gt; PacketedBioCreate(bool advance_clock) {
-  bssl::UniquePtr&lt;BIO&gt; bio(BIO_new(PacketedMethod()));
-  if (!bio) {
-    return nullptr;
-  }
-  BIO_set_data(bio.get(), new PacketedBio(advance_clock));
-  return bio;
-}
-
-timeval PacketedBioGetClock(const BIO *bio) {
-  return GetData(bio)-&gt;clock;
-}
-
-bool PacketedBioAdvanceClock(BIO *bio) {
-  PacketedBio *data = GetData(bio);
-  if (data == nullptr) {
-    return false;
-  }
-
-  if (!data-&gt;HasTimeout()) {
-    return false;
-  }
-
-  data-&gt;clock.tv_usec += data-&gt;timeout.tv_usec;
-  data-&gt;clock.tv_sec += data-&gt;clock.tv_usec / 1000000;
-  data-&gt;clock.tv_usec %= 1000000;
-  data-&gt;clock.tv_sec += data-&gt;timeout.tv_sec;
-  memset(&amp;data-&gt;timeout, 0, sizeof(data-&gt;timeout));
-  return true;
-}
diff --git a/test/ossl_shim/packeted_bio.h b/test/ossl_shim/packeted_bio.h
deleted file mode 100644
index 27678bd7e6..0000000000
--- a/test/ossl_shim/packeted_bio.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 1995-2018 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#ifndef OSSL_TEST_SHIM_PACKETED_BIO_H
-#define OSSL_TEST_SHIM_PACKETED_BIO_H
-
-#include &lt;openssl/base.h&gt;
-#include &lt;openssl/bio.h&gt;
-
-// PacketedBioCreate creates a filter BIO which implements a reliable in-order
-// blocking datagram socket. It internally maintains a clock and honors
-// |BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT| based on it.
-//
-// During a |BIO_read|, the peer may signal the filter BIO to simulate a
-// timeout. If |advance_clock| is true, it automatically advances the clock and
-// continues reading, subject to the read deadline. Otherwise, it fails
-// immediately. The caller must then call |PacketedBioAdvanceClock| before
-// retrying |BIO_read|.
-bssl::UniquePtr&lt;BIO&gt; PacketedBioCreate(bool advance_clock);
-
-// PacketedBioGetClock returns the current time for |bio|.
-timeval PacketedBioGetClock(const BIO *bio);
-
-// PacketedBioAdvanceClock advances |bio|'s internal clock and returns true if
-// there is a pending timeout. Otherwise, it returns false.
-bool PacketedBioAdvanceClock(BIO *bio);
-
-
-#endif  // OSSL_TEST_SHIM_PACKETED_BIO_H
diff --git a/test/ossl_shim/test_config.cc b/test/ossl_shim/test_config.cc
deleted file mode 100644
index a37d010d7a..0000000000
--- a/test/ossl_shim/test_config.cc
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#include &quot;test_config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &lt;memory&gt;
-
-#include &lt;openssl/evp.h&gt;
-
-namespace {
-
-template &lt;typename T&gt;
-struct Flag {
-  const char *flag;
-  T TestConfig::*member;
-};
-
-// FindField looks for the flag in |flags| that matches |flag|. If one is found,
-// it returns a pointer to the corresponding field in |config|. Otherwise, it
-// returns NULL.
-template&lt;typename T, size_t N&gt;
-T *FindField(TestConfig *config, const Flag&lt;T&gt; (&amp;flags)[N], const char *flag) {
-  for (size_t i = 0; i &lt; N; i++) {
-    if (strcmp(flag, flags[i].flag) == 0) {
-      return &amp;(config-&gt;*(flags[i].member));
-    }
-  }
-  return NULL;
-}
-
-const Flag&lt;bool&gt; kBoolFlags[] = {
-  { &quot;-server&quot;, &amp;TestConfig::is_server },
-  { &quot;-dtls&quot;, &amp;TestConfig::is_dtls },
-  { &quot;-fallback-scsv&quot;, &amp;TestConfig::fallback_scsv },
-  { &quot;-require-any-client-certificate&quot;,
-    &amp;TestConfig::require_any_client_certificate },
-  { &quot;-async&quot;, &amp;TestConfig::async },
-  { &quot;-write-different-record-sizes&quot;,
-    &amp;TestConfig::write_different_record_sizes },
-  { &quot;-partial-write&quot;, &amp;TestConfig::partial_write },
-  { &quot;-no-tls13&quot;, &amp;TestConfig::no_tls13 },
-  { &quot;-no-tls12&quot;, &amp;TestConfig::no_tls12 },
-  { &quot;-no-tls11&quot;, &amp;TestConfig::no_tls11 },
-  { &quot;-no-tls1&quot;, &amp;TestConfig::no_tls1 },
-  { &quot;-no-ssl3&quot;, &amp;TestConfig::no_ssl3 },
-  { &quot;-shim-writes-first&quot;, &amp;TestConfig::shim_writes_first },
-  { &quot;-expect-session-miss&quot;, &amp;TestConfig::expect_session_miss },
-  { &quot;-decline-alpn&quot;, &amp;TestConfig::decline_alpn },
-  { &quot;-expect-extended-master-secret&quot;,
-    &amp;TestConfig::expect_extended_master_secret },
-  { &quot;-implicit-handshake&quot;, &amp;TestConfig::implicit_handshake },
-  { &quot;-handshake-never-done&quot;, &amp;TestConfig::handshake_never_done },
-  { &quot;-use-export-context&quot;, &amp;TestConfig::use_export_context },
-  { &quot;-expect-ticket-renewal&quot;, &amp;TestConfig::expect_ticket_renewal },
-  { &quot;-expect-no-session&quot;, &amp;TestConfig::expect_no_session },
-  { &quot;-use-ticket-callback&quot;, &amp;TestConfig::use_ticket_callback },
-  { &quot;-renew-ticket&quot;, &amp;TestConfig::renew_ticket },
-  { &quot;-enable-client-custom-extension&quot;,
-    &amp;TestConfig::enable_client_custom_extension },
-  { &quot;-enable-server-custom-extension&quot;,
-    &amp;TestConfig::enable_server_custom_extension },
-  { &quot;-custom-extension-skip&quot;, &amp;TestConfig::custom_extension_skip },
-  { &quot;-custom-extension-fail-add&quot;, &amp;TestConfig::custom_extension_fail_add },
-  { &quot;-check-close-notify&quot;, &amp;TestConfig::check_close_notify },
-  { &quot;-shim-shuts-down&quot;, &amp;TestConfig::shim_shuts_down },
-  { &quot;-verify-fail&quot;, &amp;TestConfig::verify_fail },
-  { &quot;-verify-peer&quot;, &amp;TestConfig::verify_peer },
-  { &quot;-expect-verify-result&quot;, &amp;TestConfig::expect_verify_result },
-  { &quot;-renegotiate-freely&quot;, &amp;TestConfig::renegotiate_freely },
-  { &quot;-p384-only&quot;, &amp;TestConfig::p384_only },
-  { &quot;-enable-all-curves&quot;, &amp;TestConfig::enable_all_curves },
-  { &quot;-use-sparse-dh-prime&quot;, &amp;TestConfig::use_sparse_dh_prime },
-  { &quot;-use-old-client-cert-callback&quot;,
-    &amp;TestConfig::use_old_client_cert_callback },
-  { &quot;-use-null-client-ca-list&quot;, &amp;TestConfig::use_null_client_ca_list },
-  { &quot;-peek-then-read&quot;, &amp;TestConfig::peek_then_read },
-};
-
-const Flag&lt;std::string&gt; kStringFlags[] = {
-  { &quot;-key-file&quot;, &amp;TestConfig::key_file },
-  { &quot;-cert-file&quot;, &amp;TestConfig::cert_file },
-  { &quot;-expect-server-name&quot;, &amp;TestConfig::expected_server_name },
-  { &quot;-advertise-npn&quot;, &amp;TestConfig::advertise_npn },
-  { &quot;-expect-next-proto&quot;, &amp;TestConfig::expected_next_proto },
-  { &quot;-select-next-proto&quot;, &amp;TestConfig::select_next_proto },
-  { &quot;-host-name&quot;, &amp;TestConfig::host_name },
-  { &quot;-advertise-alpn&quot;, &amp;TestConfig::advertise_alpn },
-  { &quot;-expect-alpn&quot;, &amp;TestConfig::expected_alpn },
-  { &quot;-expect-advertised-alpn&quot;, &amp;TestConfig::expected_advertised_alpn },
-  { &quot;-select-alpn&quot;, &amp;TestConfig::select_alpn },
-  { &quot;-psk&quot;, &amp;TestConfig::psk },
-  { &quot;-psk-identity&quot;, &amp;TestConfig::psk_identity },
-  { &quot;-srtp-profiles&quot;, &amp;TestConfig::srtp_profiles },
-  { &quot;-cipher&quot;, &amp;TestConfig::cipher },
-  { &quot;-export-label&quot;, &amp;TestConfig::export_label },
-  { &quot;-export-context&quot;, &amp;TestConfig::export_context },
-};
-
-const Flag&lt;std::string&gt; kBase64Flags[] = {
-  { &quot;-expect-certificate-types&quot;, &amp;TestConfig::expected_certificate_types },
-};
-
-const Flag&lt;int&gt; kIntFlags[] = {
-  { &quot;-port&quot;, &amp;TestConfig::port },
-  { &quot;-resume-count&quot;, &amp;TestConfig::resume_count },
-  { &quot;-min-version&quot;, &amp;TestConfig::min_version },
-  { &quot;-max-version&quot;, &amp;TestConfig::max_version },
-  { &quot;-mtu&quot;, &amp;TestConfig::mtu },
-  { &quot;-export-keying-material&quot;, &amp;TestConfig::export_keying_material },
-  { &quot;-expect-total-renegotiations&quot;, &amp;TestConfig::expect_total_renegotiations },
-  { &quot;-max-cert-list&quot;, &amp;TestConfig::max_cert_list },
-};
-
-}  // namespace
-
-bool ParseConfig(int argc, char **argv, TestConfig *out_config) {
-  for (int i = 0; i &lt; argc; i++) {
-    bool *bool_field = FindField(out_config, kBoolFlags, argv[i]);
-    if (bool_field != NULL) {
-      *bool_field = true;
-      continue;
-    }
-
-    std::string *string_field = FindField(out_config, kStringFlags, argv[i]);
-    if (string_field != NULL) {
-      const char *val;
-
-      i++;
-      if (i &gt;= argc) {
-        fprintf(stderr, &quot;Missing parameter\n&quot;);
-        return false;
-      }
-
-      /*
-       * Fix up the -cipher argument. runner uses &quot;DEFAULT:NULL-SHA&quot; to enable
-       * the NULL-SHA cipher. However in OpenSSL &quot;DEFAULT&quot; permanently switches
-       * off NULL ciphers, so we use &quot;ALL:NULL-SHA&quot; instead.
-       */
-      if (strcmp(argv[i - 1], &quot;-cipher&quot;) == 0
-          &amp;&amp; strcmp(argv[i], &quot;DEFAULT:NULL-SHA&quot;) == 0)
-        val = &quot;ALL:NULL-SHA&quot;;
-      else
-        val = argv[i];
-
-      string_field-&gt;assign(val);
-      continue;
-    }
-
-    std::string *base64_field = FindField(out_config, kBase64Flags, argv[i]);
-    if (base64_field != NULL) {
-      i++;
-      if (i &gt;= argc) {
-        fprintf(stderr, &quot;Missing parameter\n&quot;);
-        return false;
-      }
-      std::unique_ptr&lt;uint8_t[]&gt; decoded(new uint8_t[strlen(argv[i])]);
-      int len = EVP_DecodeBlock(decoded.get(),
-                                reinterpret_cast&lt;const uint8_t *&gt;(argv[i]),
-                                strlen(argv[i]));
-      if (len &lt; 0) {
-        fprintf(stderr, &quot;Invalid base64: %s\n&quot;, argv[i]);
-        return false;
-      }
-      base64_field-&gt;assign(reinterpret_cast&lt;const char *&gt;(decoded.get()), len);
-      continue;
-    }
-
-    int *int_field = FindField(out_config, kIntFlags, argv[i]);
-    if (int_field) {
-      i++;
-      if (i &gt;= argc) {
-        fprintf(stderr, &quot;Missing parameter\n&quot;);
-        return false;
-      }
-      *int_field = atoi(argv[i]);
-      continue;
-    }
-
-    fprintf(stderr, &quot;Unknown argument: %s\n&quot;, argv[i]);
-    exit(89);
-    return false;
-  }
-
-  return true;
-}
diff --git a/test/ossl_shim/test_config.h b/test/ossl_shim/test_config.h
deleted file mode 100644
index 6dc7319485..0000000000
--- a/test/ossl_shim/test_config.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright 1995-2020 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#ifndef OSSL_TEST_SHIM_TEST_CONFIG_H
-#define OSSL_TEST_SHIM_TEST_CONFIG_H
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-
-#include &lt;openssl/configuration.h&gt;
-
-
-struct TestConfig {
-  int port = 0;
-  bool is_server = false;
-  bool is_dtls = false;
-  int resume_count = 0;
-  bool fallback_scsv = false;
-  std::string key_file;
-  std::string cert_file;
-  std::string expected_server_name;
-  std::string expected_certificate_types;
-  bool require_any_client_certificate = false;
-  std::string advertise_npn;
-  std::string expected_next_proto;
-  std::string select_next_proto;
-  bool async = false;
-  bool write_different_record_sizes = false;
-  bool partial_write = false;
-  bool no_tls13 = false;
-  bool no_tls12 = false;
-  bool no_tls11 = false;
-  bool no_tls1 = false;
-  bool no_ssl3 = false;
-  bool shim_writes_first = false;
-  std::string host_name;
-  std::string advertise_alpn;
-  std::string expected_alpn;
-  std::string expected_advertised_alpn;
-  std::string select_alpn;
-  bool decline_alpn = false;
-  bool expect_session_miss = false;
-  bool expect_extended_master_secret = false;
-  std::string psk;
-  std::string psk_identity;
-  std::string srtp_profiles;
-  int min_version = 0;
-  int max_version = 0;
-  int mtu = 0;
-  bool implicit_handshake = false;
-  std::string cipher;
-  bool handshake_never_done = false;
-  int export_keying_material = 0;
-  std::string export_label;
-  std::string export_context;
-  bool use_export_context = false;
-  bool expect_ticket_renewal = false;
-  bool expect_no_session = false;
-  bool use_ticket_callback = false;
-  bool renew_ticket = false;
-  bool enable_client_custom_extension = false;
-  bool enable_server_custom_extension = false;
-  bool custom_extension_skip = false;
-  bool custom_extension_fail_add = false;
-  bool check_close_notify = false;
-  bool shim_shuts_down = false;
-  bool verify_fail = false;
-  bool verify_peer = false;
-  bool expect_verify_result = false;
-  int expect_total_renegotiations = 0;
-  bool renegotiate_freely = false;
-  bool p384_only = false;
-  bool enable_all_curves = false;
-  bool use_sparse_dh_prime = false;
-  bool use_old_client_cert_callback = false;
-  bool use_null_client_ca_list = false;
-  bool peek_then_read = false;
-  int max_cert_list = 0;
-};
-
-bool ParseConfig(int argc, char **argv, TestConfig *out_config);
-
-
-#endif  // OSSL_TEST_SHIM_TEST_CONFIG_H
diff --git a/test/recipes/95-test_external_boringssl.t b/test/recipes/95-test_external_boringssl.t
deleted file mode 100644
index ea607935aa..0000000000
--- a/test/recipes/95-test_external_boringssl.t
+++ /dev/null
@@ -1,30 +0,0 @@
-#! /usr/bin/env perl
-# Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
-
-
-use OpenSSL::Test;
-use OpenSSL::Test::Utils;
-use OpenSSL::Test qw/:DEFAULT bldtop_file srctop_file cmdstr/;
-
-setup(&quot;test_external_boringssl&quot;);
-
-plan skip_all =&gt; &quot;No external tests in this configuration&quot;
-    if disabled(&quot;external-tests&quot;);
-plan skip_all =&gt; &quot;BoringSSL runner not detected&quot;
-    if !$ENV{BORING_RUNNER_DIR};
-
-plan tests =&gt; 1;
-
-indir $ENV{BORING_RUNNER_DIR} =&gt; sub {
-    ok(run(cmd([&quot;go&quot;, &quot;test&quot;, &quot;-shim-path&quot;,
-                bldtop_file(&quot;test&quot;, &quot;ossl_shim&quot;, &quot;ossl_shim&quot;),
-                &quot;-shim-config&quot;,
-                srctop_file(&quot;test&quot;, &quot;ossl_shim&quot;, &quot;ossl_config.json&quot;),
-                &quot;-pipe&quot;, &quot;-allow-unimplemented&quot;]), prefix =&gt; &quot;go test: &quot;),
-       &quot;running BoringSSL tests&quot;);
-}, create =&gt; 0, cleanup =&gt; 0;
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="033641.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="033644.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33642">[ date ]</a>
              <a href="thread.html#33642">[ thread ]</a>
              <a href="subject.html#33642">[ subject ]</a>
              <a href="author.html#33642">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
