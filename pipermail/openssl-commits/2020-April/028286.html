<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-April/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1586946646.652858.10012.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="028283.html">
   <LINK REL="Next"  HREF="028287.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1586946646.652858.10012.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Wed Apr 15 10:30:46 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="028283.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="028287.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28286">[ date ]</a>
              <a href="thread.html#28286">[ thread ]</a>
              <a href="subject.html#28286">[ subject ]</a>
              <a href="author.html#28286">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  137b274aee0cd96d64fd68cd393717d6a69ec005 (commit)
       via  d6a2bdf7f1585587c607abb2e5ae281d12dd8230 (commit)
       via  1531241c54b36be74967753cdea78c16831f7aa5 (commit)
       via  8755b085244c792bc8a78b38984b0f4061bc9f91 (commit)
       via  f13fdeb321f0f6bf67e2c93209bba70c8c4fcbec (commit)
       via  472a88b79e779342adc3b85b5bea318de038ae14 (commit)
      from  ca59b00bbd701b9e5e7ce213f44a4d7577d6d2db (commit)


- Log -----------------------------------------------------------------
commit 137b274aee0cd96d64fd68cd393717d6a69ec005
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 8 11:54:53 2020 +0100

    Document the new libctx aware private key functions
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11494">https://github.com/openssl/openssl/pull/11494</A>)

commit d6a2bdf7f1585587c607abb2e5ae281d12dd8230
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Apr 6 18:24:05 2020 +0100

    Make sure we use the libctx in libssl when loading PrivateKeys
    
    Since loading a private key might require algorithm fetches we should
    make sure the correct libctx is used.
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11494">https://github.com/openssl/openssl/pull/11494</A>)

commit 1531241c54b36be74967753cdea78c16831f7aa5
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Apr 6 18:21:50 2020 +0100

    Teach PEM_read_bio_PrivateKey about libctx
    
    Now that d2i_PrivateKey_ex() and other similar functions exist we should
    use it when loading a PEM PrivateKey.
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11494">https://github.com/openssl/openssl/pull/11494</A>)

commit 8755b085244c792bc8a78b38984b0f4061bc9f91
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Apr 6 18:23:25 2020 +0100

    Teach the OSSL_STORE code about libctx
    
    We restrict this to just the PrivateKey loading code at the moment.
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11494">https://github.com/openssl/openssl/pull/11494</A>)

commit f13fdeb321f0f6bf67e2c93209bba70c8c4fcbec
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Apr 6 18:19:30 2020 +0100

    Use the libctx in Ed448 private key decoding
    
    The Ed448 private key deconding needs to use a library ctx. So we
    implement a priv_decode_with_libctx function for it.
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11494">https://github.com/openssl/openssl/pull/11494</A>)

commit 472a88b79e779342adc3b85b5bea318de038ae14
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Apr 6 18:18:18 2020 +0100

    Teach d2i_PrivateKey et al about libctx
    
    The Ed448 private key decoding makes algorithm fetches. Therefore we teach
    d2i_PrivateKey et al about libctx and make sure it is passed through the
    layers.
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11494">https://github.com/openssl/openssl/pull/11494</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/asn1/ameth_lib.c              | 47 ++++++--------------
 crypto/asn1/d2i_pr.c                 | 48 +++++++++++++--------
 crypto/ec/ecx_meth.c                 | 52 +++++++++++++---------
 crypto/evp/evp_pkey.c                | 23 +++++++---
 crypto/pem/pem_pkey.c                | 33 ++++++++++----
 crypto/store/loader_file.c           | 62 ++++++++++++++++++++------
 crypto/store/store_lib.c             |  6 ++-
 crypto/store/store_local.h           |  4 +-
 crypto/x509/x_all.c                  | 36 ++++++++++++++++
 doc/man3/PEM_read_bio_PrivateKey.pod | 21 ++++++++-
 doc/man3/d2i_PrivateKey.pod          | 84 +++++++++++++++++++++++++++---------
 include/crypto/asn1.h                |  5 +++
 include/crypto/evp.h                 |  3 ++
 include/crypto/store.h               |  3 +-
 include/openssl/evp.h                |  6 +++
 include/openssl/pem.h                |  8 ++++
 include/openssl/x509.h               |  4 ++
 ssl/ssl_rsa.c                        | 24 +++++++----
 util/libcrypto.num                   |  6 +++
 util/missingcrypto.txt               |  2 -
 20 files changed, 340 insertions(+), 137 deletions(-)

diff --git a/crypto/asn1/ameth_lib.c b/crypto/asn1/ameth_lib.c
index 9ea5b665ba..013e1d69e1 100644
--- a/crypto/asn1/ameth_lib.c
+++ b/crypto/asn1/ameth_lib.c
@@ -250,39 +250,20 @@ EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_new(int id, int flags,
 void EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst,
                         const EVP_PKEY_ASN1_METHOD *src)
 {
-
-    dst-&gt;pub_decode = src-&gt;pub_decode;
-    dst-&gt;pub_encode = src-&gt;pub_encode;
-    dst-&gt;pub_cmp = src-&gt;pub_cmp;
-    dst-&gt;pub_print = src-&gt;pub_print;
-
-    dst-&gt;priv_decode = src-&gt;priv_decode;
-    dst-&gt;priv_encode = src-&gt;priv_encode;
-    dst-&gt;priv_print = src-&gt;priv_print;
-
-    dst-&gt;old_priv_encode = src-&gt;old_priv_encode;
-    dst-&gt;old_priv_decode = src-&gt;old_priv_decode;
-
-    dst-&gt;pkey_size = src-&gt;pkey_size;
-    dst-&gt;pkey_bits = src-&gt;pkey_bits;
-
-    dst-&gt;param_decode = src-&gt;param_decode;
-    dst-&gt;param_encode = src-&gt;param_encode;
-    dst-&gt;param_missing = src-&gt;param_missing;
-    dst-&gt;param_copy = src-&gt;param_copy;
-    dst-&gt;param_cmp = src-&gt;param_cmp;
-    dst-&gt;param_print = src-&gt;param_print;
-
-    dst-&gt;pkey_free = src-&gt;pkey_free;
-    dst-&gt;pkey_ctrl = src-&gt;pkey_ctrl;
-
-    dst-&gt;item_sign = src-&gt;item_sign;
-    dst-&gt;item_verify = src-&gt;item_verify;
-
-    dst-&gt;siginf_set = src-&gt;siginf_set;
-
-    dst-&gt;pkey_check = src-&gt;pkey_check;
-
+    int pkey_id = dst-&gt;pkey_id;
+    int pkey_base_id = dst-&gt;pkey_base_id;
+    unsigned long pkey_flags = dst-&gt;pkey_flags;
+    char *pem_str = dst-&gt;pem_str;
+    char *info = dst-&gt;info;
+
+    *dst = *src;
+
+    /* We only copy the function pointers so restore the other values */
+    dst-&gt;pkey_id = pkey_id;
+    dst-&gt;pkey_base_id = pkey_base_id;
+    dst-&gt;pkey_flags = pkey_flags;
+    dst-&gt;pem_str = pem_str;
+    dst-&gt;info = info;
 }
 
 void EVP_PKEY_asn1_free(EVP_PKEY_ASN1_METHOD *ameth)
diff --git a/crypto/asn1/d2i_pr.c b/crypto/asn1/d2i_pr.c
index 08101a826b..a1f8b570bc 100644
--- a/crypto/asn1/d2i_pr.c
+++ b/crypto/asn1/d2i_pr.c
@@ -18,15 +18,15 @@
 #include &quot;crypto/asn1.h&quot;
 #include &quot;crypto/evp.h&quot;
 
-EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
-                         long length)
+EVP_PKEY *d2i_PrivateKey_ex(int type, EVP_PKEY **a, const unsigned char **pp,
+                            long length, OPENSSL_CTX *libctx, const char *propq)
 {
     EVP_PKEY *ret;
     const unsigned char *p = *pp;
 
     if ((a == NULL) || (*a == NULL)) {
         if ((ret = EVP_PKEY_new()) == NULL) {
-            ASN1err(ASN1_F_D2I_PRIVATEKEY, ERR_R_EVP_LIB);
+            ASN1err(0, ERR_R_EVP_LIB);
             return NULL;
         }
     } else {
@@ -38,26 +38,27 @@ EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
     }
 
     if (!EVP_PKEY_set_type(ret, type)) {
-        ASN1err(ASN1_F_D2I_PRIVATEKEY, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);
+        ASN1err(0, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);
         goto err;
     }
 
     if (!ret-&gt;ameth-&gt;old_priv_decode ||
         !ret-&gt;ameth-&gt;old_priv_decode(ret, &amp;p, length)) {
-        if (ret-&gt;ameth-&gt;priv_decode) {
+        if (ret-&gt;ameth-&gt;priv_decode != NULL
+                || ret-&gt;ameth-&gt;priv_decode_with_libctx != NULL) {
             EVP_PKEY *tmp;
             PKCS8_PRIV_KEY_INFO *p8 = NULL;
             p8 = d2i_PKCS8_PRIV_KEY_INFO(NULL, &amp;p, length);
             if (p8 == NULL)
                 goto err;
-            tmp = EVP_PKCS82PKEY(p8);
+            tmp = evp_pkcs82pkey_int(p8, libctx, propq);
             PKCS8_PRIV_KEY_INFO_free(p8);
             if (tmp == NULL)
                 goto err;
             EVP_PKEY_free(ret);
             ret = tmp;
         } else {
-            ASN1err(ASN1_F_D2I_PRIVATEKEY, ERR_R_ASN1_LIB);
+            ASN1err(0, ERR_R_ASN1_LIB);
             goto err;
         }
     }
@@ -71,13 +72,20 @@ EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
     return NULL;
 }
 
+EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
+                         long length)
+{
+    return d2i_PrivateKey_ex(type, a, pp, length, NULL, NULL);
+}
+
 /*
  * This works like d2i_PrivateKey() except it automatically works out the
  * type
  */
 
-EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
-                             long length)
+EVP_PKEY *d2i_AutoPrivateKey_ex(EVP_PKEY **a, const unsigned char **pp,
+                                long length, OPENSSL_CTX *libctx,
+                                const char *propq)
 {
     STACK_OF(ASN1_TYPE) *inkey;
     const unsigned char *p;
@@ -94,22 +102,21 @@ EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
      * Since we only need to discern &quot;traditional format&quot; RSA and DSA keys we
      * can just count the elements.
      */
-    if (sk_ASN1_TYPE_num(inkey) == 6)
+    if (sk_ASN1_TYPE_num(inkey) == 6) {
         keytype = EVP_PKEY_DSA;
-    else if (sk_ASN1_TYPE_num(inkey) == 4)
+    } else if (sk_ASN1_TYPE_num(inkey) == 4) {
         keytype = EVP_PKEY_EC;
-    else if (sk_ASN1_TYPE_num(inkey) == 3) { /* This seems to be PKCS8, not
+    } else if (sk_ASN1_TYPE_num(inkey) == 3) { /* This seems to be PKCS8, not
                                               * traditional format */
         PKCS8_PRIV_KEY_INFO *p8 = d2i_PKCS8_PRIV_KEY_INFO(NULL, &amp;p, length);
         EVP_PKEY *ret;
 
         sk_ASN1_TYPE_pop_free(inkey, ASN1_TYPE_free);
         if (p8 == NULL) {
-            ASN1err(ASN1_F_D2I_AUTOPRIVATEKEY,
-                    ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
+            ASN1err(0, ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);
             return NULL;
         }
-        ret = EVP_PKCS82PKEY(p8);
+        ret = evp_pkcs82pkey_int(p8, libctx, propq);
         PKCS8_PRIV_KEY_INFO_free(p8);
         if (ret == NULL)
             return NULL;
@@ -118,8 +125,15 @@ EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
             *a = ret;
         }
         return ret;
-    } else
+    } else {
         keytype = EVP_PKEY_RSA;
+    }
     sk_ASN1_TYPE_pop_free(inkey, ASN1_TYPE_free);
-    return d2i_PrivateKey(keytype, a, pp, length);
+    return d2i_PrivateKey_ex(keytype, a, pp, length, libctx, propq);
+}
+
+EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
+                             long length)
+{
+    return d2i_AutoPrivateKey_ex(a, pp, length, NULL, NULL);
 }
diff --git a/crypto/ec/ecx_meth.c b/crypto/ec/ecx_meth.c
index 03d6a7af83..62a73f9b08 100644
--- a/crypto/ec/ecx_meth.c
+++ b/crypto/ec/ecx_meth.c
@@ -35,7 +35,8 @@ typedef enum {
 
 /* Setup EVP_PKEY using public, private or generation */
 static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
-                      const unsigned char *p, int plen, ecx_key_op_t op)
+                      const unsigned char *p, int plen, ecx_key_op_t op,
+                      OPENSSL_CTX *libctx, const char *propq)
 {
     ECX_KEY *key = NULL;
     unsigned char *privkey, *pubkey;
@@ -98,11 +99,7 @@ static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
             X448_public_from_private(pubkey, privkey);
             break;
         case EVP_PKEY_ED448:
-            /*
-             * TODO(3.0): We set the library context to NULL for now. This will
-             * need to change.
-             */
-            ED448_public_from_private(NULL, pubkey, privkey);
+            ED448_public_from_private(libctx, pubkey, privkey);
             break;
         }
     }
@@ -148,7 +145,7 @@ static int ecx_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)
     if (!X509_PUBKEY_get0_param(NULL, &amp;p, &amp;pklen, &amp;palg, pubkey))
         return 0;
     return ecx_key_op(pkey, pkey-&gt;ameth-&gt;pkey_id, palg, p, pklen,
-                      KEY_OP_PUBLIC);
+                      KEY_OP_PUBLIC, NULL, NULL);
 }
 
 static int ecx_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
@@ -162,7 +159,9 @@ static int ecx_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
     return CRYPTO_memcmp(akey-&gt;pubkey, bkey-&gt;pubkey, KEYLEN(a)) == 0;
 }
 
-static int ecx_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)
+static int ecx_priv_decode_with_libctx(EVP_PKEY *pkey,
+                                       const PKCS8_PRIV_KEY_INFO *p8,
+                                       OPENSSL_CTX *libctx, const char *propq)
 {
     const unsigned char *p;
     int plen;
@@ -182,7 +181,8 @@ static int ecx_priv_decode(EVP_PKEY *pkey, const PKCS8_PRIV_KEY_INFO *p8)
         plen = ASN1_STRING_length(oct);
     }
 
-    rv = ecx_key_op(pkey, pkey-&gt;ameth-&gt;pkey_id, palg, p, plen, KEY_OP_PRIVATE);
+    rv = ecx_key_op(pkey, pkey-&gt;ameth-&gt;pkey_id, palg, p, plen, KEY_OP_PRIVATE,
+                    libctx, propq);
     ASN1_STRING_clear_free(oct);
     return rv;
 }
@@ -310,7 +310,7 @@ static int ecx_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
 
     case ASN1_PKEY_CTRL_SET1_TLS_ENCPT:
         return ecx_key_op(pkey, pkey-&gt;ameth-&gt;pkey_id, NULL, arg2, arg1,
-                          KEY_OP_PUBLIC);
+                          KEY_OP_PUBLIC, NULL, NULL);
 
     case ASN1_PKEY_CTRL_GET1_TLS_ENCPT:
         if (pkey-&gt;pkey.ecx != NULL) {
@@ -345,14 +345,15 @@ static int ecd_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
 static int ecx_set_priv_key(EVP_PKEY *pkey, const unsigned char *priv,
                             size_t len)
 {
+    /* TODO(3.0): We should pass a libctx here */
     return ecx_key_op(pkey, pkey-&gt;ameth-&gt;pkey_id, NULL, priv, len,
-                       KEY_OP_PRIVATE);
+                       KEY_OP_PRIVATE, NULL, NULL);
 }
 
 static int ecx_set_pub_key(EVP_PKEY *pkey, const unsigned char *pub, size_t len)
 {
     return ecx_key_op(pkey, pkey-&gt;ameth-&gt;pkey_id, NULL, pub, len,
-                      KEY_OP_PUBLIC);
+                      KEY_OP_PUBLIC, NULL, NULL);
 }
 
 static int ecx_get_priv_key(const EVP_PKEY *pkey, unsigned char *priv,
@@ -479,7 +480,7 @@ const EVP_PKEY_ASN1_METHOD ecx25519_asn1_meth = {
     ecx_pub_cmp,
     ecx_pub_print,
 
-    ecx_priv_decode,
+    NULL,
     ecx_priv_encode,
     ecx_priv_print,
 
@@ -510,7 +511,9 @@ const EVP_PKEY_ASN1_METHOD ecx25519_asn1_meth = {
     ecx_get_pub_key,
     ecx_pkey_dirty_cnt,
     ecx_pkey_export_to,
-    x25519_import_from
+    x25519_import_from,
+
+    ecx_priv_decode_with_libctx
 };
 
 static int x448_import_from(const OSSL_PARAM params[], void *key)
@@ -530,7 +533,7 @@ const EVP_PKEY_ASN1_METHOD ecx448_asn1_meth = {
     ecx_pub_cmp,
     ecx_pub_print,
 
-    ecx_priv_decode,
+    NULL,
     ecx_priv_encode,
     ecx_priv_print,
 
@@ -561,7 +564,9 @@ const EVP_PKEY_ASN1_METHOD ecx448_asn1_meth = {
     ecx_get_pub_key,
     ecx_pkey_dirty_cnt,
     ecx_pkey_export_to,
-    x448_import_from
+    x448_import_from,
+
+    ecx_priv_decode_with_libctx
 };
 
 static int ecd_size25519(const EVP_PKEY *pkey)
@@ -653,7 +658,7 @@ const EVP_PKEY_ASN1_METHOD ed25519_asn1_meth = {
     ecx_pub_cmp,
     ecx_pub_print,
 
-    ecx_priv_decode,
+    NULL,
     ecx_priv_encode,
     ecx_priv_print,
 
@@ -683,7 +688,9 @@ const EVP_PKEY_ASN1_METHOD ed25519_asn1_meth = {
     ecx_get_pub_key,
     ecx_pkey_dirty_cnt,
     ecx_pkey_export_to,
-    ed25519_import_from
+    ed25519_import_from,
+
+    ecx_priv_decode_with_libctx
 };
 
 static int ed448_import_from(const OSSL_PARAM params[], void *key)
@@ -703,7 +710,7 @@ const EVP_PKEY_ASN1_METHOD ed448_asn1_meth = {
     ecx_pub_cmp,
     ecx_pub_print,
 
-    ecx_priv_decode,
+    NULL,
     ecx_priv_encode,
     ecx_priv_print,
 
@@ -733,12 +740,15 @@ const EVP_PKEY_ASN1_METHOD ed448_asn1_meth = {
     ecx_get_pub_key,
     ecx_pkey_dirty_cnt,
     ecx_pkey_export_to,
-    ed448_import_from
+    ed448_import_from,
+
+    ecx_priv_decode_with_libctx
 };
 
 static int pkey_ecx_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 {
-    return ecx_key_op(pkey, ctx-&gt;pmeth-&gt;pkey_id, NULL, NULL, 0, KEY_OP_KEYGEN);
+    return ecx_key_op(pkey, ctx-&gt;pmeth-&gt;pkey_id, NULL, NULL, 0, KEY_OP_KEYGEN,
+                      NULL, NULL);
 }
 
 static int validate_ecx_derive(EVP_PKEY_CTX *ctx, unsigned char *key,
diff --git a/crypto/evp/evp_pkey.c b/crypto/evp/evp_pkey.c
index a11b856c03..6a40f4b456 100644
--- a/crypto/evp/evp_pkey.c
+++ b/crypto/evp/evp_pkey.c
@@ -18,7 +18,8 @@
 
 /* Extract a private key from a PKCS8 structure */
 
-EVP_PKEY *EVP_PKCS82PKEY(const PKCS8_PRIV_KEY_INFO *p8)
+EVP_PKEY *evp_pkcs82pkey_int(const PKCS8_PRIV_KEY_INFO *p8, OPENSSL_CTX *libctx,
+                             const char *propq)
 {
     EVP_PKEY *pkey = NULL;
     const ASN1_OBJECT *algoid;
@@ -28,24 +29,29 @@ EVP_PKEY *EVP_PKCS82PKEY(const PKCS8_PRIV_KEY_INFO *p8)
         return NULL;
 
     if ((pkey = EVP_PKEY_new()) == NULL) {
-        EVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_MALLOC_FAILURE);
+        EVPerr(0, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     if (!EVP_PKEY_set_type(pkey, OBJ_obj2nid(algoid))) {
-        EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
+        EVPerr(0, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);
         i2t_ASN1_OBJECT(obj_tmp, 80, algoid);
         ERR_add_error_data(2, &quot;TYPE=&quot;, obj_tmp);
         goto error;
     }
 
-    if (pkey-&gt;ameth-&gt;priv_decode) {
+    if (pkey-&gt;ameth-&gt;priv_decode_with_libctx != NULL) {
+        if (!pkey-&gt;ameth-&gt;priv_decode_with_libctx(pkey, p8, libctx, propq)) {
+            EVPerr(0, EVP_R_PRIVATE_KEY_DECODE_ERROR);
+            goto error;
+        }
+    } else if (pkey-&gt;ameth-&gt;priv_decode != NULL) {
         if (!pkey-&gt;ameth-&gt;priv_decode(pkey, p8)) {
-            EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_PRIVATE_KEY_DECODE_ERROR);
+            EVPerr(0, EVP_R_PRIVATE_KEY_DECODE_ERROR);
             goto error;
         }
     } else {
-        EVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_METHOD_NOT_SUPPORTED);
+        EVPerr(0, EVP_R_METHOD_NOT_SUPPORTED);
         goto error;
     }
 
@@ -56,6 +62,11 @@ EVP_PKEY *EVP_PKCS82PKEY(const PKCS8_PRIV_KEY_INFO *p8)
     return NULL;
 }
 
+EVP_PKEY *EVP_PKCS82PKEY(const PKCS8_PRIV_KEY_INFO *p8)
+{
+    return evp_pkcs82pkey_int(p8, NULL, NULL);
+}
+
 /* Turn a private key into a PKCS8 structure */
 
 PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(const EVP_PKEY *pkey)
diff --git a/crypto/pem/pem_pkey.c b/crypto/pem/pem_pkey.c
index c619cc11b4..beecf62e15 100644
--- a/crypto/pem/pem_pkey.c
+++ b/crypto/pem/pem_pkey.c
@@ -27,8 +27,9 @@
 
 int pem_check_suffix(const char *pem_str, const char *suffix);
 
-EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
-                                  void *u)
+EVP_PKEY *PEM_read_bio_PrivateKey_ex(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+                                     void *u, OPENSSL_CTX *libctx,
+                                     const char *propq)
 {
     EVP_PKEY *ret = NULL;
     OSSL_STORE_CTX *ctx = NULL;
@@ -38,7 +39,8 @@ EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
     if ((ui_method = UI_UTIL_wrap_read_pem_callback(cb, 0)) == NULL)
         return NULL;
 
-    if ((ctx = ossl_store_attach_pem_bio(bp, ui_method, u)) == NULL)
+    if ((ctx = ossl_store_attach_pem_bio(bp, ui_method, u, libctx,
+                                         propq)) == NULL)
         goto err;
 #ifndef OPENSSL_NO_SECURE_HEAP
     {
@@ -66,6 +68,12 @@ EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
     return ret;
 }
 
+EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+                                  void *u)
+{
+    return PEM_read_bio_PrivateKey_ex(bp, x, cb, u, NULL, NULL);
+}
+
 PEM_write_cb_fnsig(PrivateKey, EVP_PKEY, BIO, write_bio)
 {
     IMPLEMENT_PEM_provided_write_body_vars(EVP_PKEY, PrivateKey);
@@ -97,7 +105,7 @@ EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x)
     OSSL_STORE_CTX *ctx = NULL;
     OSSL_STORE_INFO *info = NULL;
 
-    if ((ctx = ossl_store_attach_pem_bio(bp, UI_null(), NULL)) == NULL)
+    if ((ctx = ossl_store_attach_pem_bio(bp, UI_null(), NULL, NULL, NULL)) == NULL)
         goto err;
 
     while (!OSSL_STORE_eof(ctx) &amp;&amp; (info = OSSL_STORE_load(ctx)) != NULL) {
@@ -134,22 +142,29 @@ PEM_write_fnsig(Parameters, EVP_PKEY, BIO, write_bio)
 }
 
 #ifndef OPENSSL_NO_STDIO
-EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
-                              void *u)
+EVP_PKEY *PEM_read_PrivateKey_ex(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
+                                 void *u, OPENSSL_CTX *libctx,
+                                 const char *propq)
 {
     BIO *b;
     EVP_PKEY *ret;
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
-        PEMerr(PEM_F_PEM_READ_PRIVATEKEY, ERR_R_BUF_LIB);
+        PEMerr(0, ERR_R_BUF_LIB);
         return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
-    ret = PEM_read_bio_PrivateKey(b, x, cb, u);
+    ret = PEM_read_bio_PrivateKey_ex(b, x, cb, u, libctx, propq);
     BIO_free(b);
     return ret;
 }
 
+EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
+                              void *u)
+{
+    return PEM_read_PrivateKey_ex(fp, x, cb, u, NULL, NULL);
+}
+
 int PEM_write_PrivateKey(FILE *fp, const EVP_PKEY *x, const EVP_CIPHER *enc,
                          const unsigned char *kstr, int klen,
                          pem_password_cb *cb, void *u)
@@ -183,7 +198,7 @@ DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u)
     if ((ui_method = UI_UTIL_wrap_read_pem_callback(cb, 0)) == NULL)
         return NULL;
 
-    if ((ctx = ossl_store_attach_pem_bio(bp, ui_method, u)) == NULL)
+    if ((ctx = ossl_store_attach_pem_bio(bp, ui_method, u, NULL, NULL)) == NULL)
         goto err;
 
     while (!OSSL_STORE_eof(ctx) &amp;&amp; (info = OSSL_STORE_load(ctx)) != NULL) {
diff --git a/crypto/store/loader_file.c b/crypto/store/loader_file.c
index cf9951f0fd..f253c06e5d 100644
--- a/crypto/store/loader_file.c
+++ b/crypto/store/loader_file.c
@@ -29,6 +29,7 @@
 #include &quot;internal/o_dir.h&quot;
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;crypto/store.h&quot;
+#include &quot;crypto/evp.h&quot;
 #include &quot;store_local.h&quot;
 
 #ifdef _WIN32
@@ -154,6 +155,8 @@ static int file_get_pem_pass(char *buf, int num, int w, void *data)
  *                  or any other interactive data.
  *    ui_data:      Application data to be passed to ui_method when
  *                  it's called.
+ *    libctx:       The library context to be used if applicable
+ *    propq:        The property query string for any algorithm fetches
  * Output:
  *    a OSSL_STORE_INFO
  */
@@ -163,7 +166,9 @@ typedef OSSL_STORE_INFO *(*file_try_decode_fn)(const char *pem_name,
                                                size_t len, void **handler_ctx,
                                                int *matchcount,
                                                const UI_METHOD *ui_method,
-                                               void *ui_data);
+                                               void *ui_data,
+                                               OPENSSL_CTX *libctx,
+                                               const char *propq);
 /*
  * The eof function should return 1 if there's no more data to be found
  * with the handler_ctx, otherwise 0.  This is only used when the handler is
@@ -198,7 +203,8 @@ static OSSL_STORE_INFO *try_decode_PKCS12(const char *pem_name,
                                           size_t len, void **pctx,
                                           int *matchcount,
                                           const UI_METHOD *ui_method,
-                                          void *ui_data)
+                                          void *ui_data, OPENSSL_CTX *libctx,
+                                          const char *propq)
 {
     OSSL_STORE_INFO *store_info = NULL;
     STACK_OF(OSSL_STORE_INFO) *ctx = *pctx;
@@ -326,7 +332,9 @@ static OSSL_STORE_INFO *try_decode_PKCS8Encrypted(const char *pem_name,
                                                   size_t len, void **pctx,
                                                   int *matchcount,
                                                   const UI_METHOD *ui_method,
-                                                  void *ui_data)
+                                                  void *ui_data,
+                                                  OPENSSL_CTX *libctx,
+                                                  const char *propq)
 {
     X509_SIG *p8 = NULL;
     char kbuf[PEM_BUFSIZE];
@@ -402,7 +410,8 @@ static OSSL_STORE_INFO *try_decode_PrivateKey(const char *pem_name,
                                               size_t len, void **pctx,
                                               int *matchcount,
                                               const UI_METHOD *ui_method,
-                                              void *ui_data)
+                                              void *ui_data, OPENSSL_CTX *libctx,
+                                              const char *propq)
 {
     OSSL_STORE_INFO *store_info = NULL;
     EVP_PKEY *pkey = NULL;
@@ -415,7 +424,7 @@ static OSSL_STORE_INFO *try_decode_PrivateKey(const char *pem_name,
 
             *matchcount = 1;
             if (p8inf != NULL)
-                pkey = EVP_PKCS82PKEY(p8inf);
+                pkey = evp_pkcs82pkey_int(p8inf, libctx, propq);
             PKCS8_PRIV_KEY_INFO_free(p8inf);
         } else {
             int slen;
@@ -424,7 +433,8 @@ static OSSL_STORE_INFO *try_decode_PrivateKey(const char *pem_name,
                 &amp;&amp; (ameth = EVP_PKEY_asn1_find_str(NULL, pem_name,
                                                    slen)) != NULL) {
                 *matchcount = 1;
-                pkey = d2i_PrivateKey(ameth-&gt;pkey_id, NULL, &amp;blob, len);
+                pkey = d2i_PrivateKey_ex(ameth-&gt;pkey_id, NULL, &amp;blob, len,
+                                         libctx, propq);
             }
         }
     } else {
@@ -438,7 +448,8 @@ static OSSL_STORE_INFO *try_decode_PrivateKey(const char *pem_name,
             if (ameth-&gt;pkey_flags &amp; ASN1_PKEY_ALIAS)
                 continue;
 
-            tmp_pkey = d2i_PrivateKey(ameth-&gt;pkey_id, NULL, &amp;tmp_blob, len);
+            tmp_pkey = d2i_PrivateKey_ex(ameth-&gt;pkey_id, NULL, &amp;tmp_blob, len,
+                                         libctx, propq);
             if (tmp_pkey != NULL) {
                 if (pkey != NULL)
                     EVP_PKEY_free(tmp_pkey);
@@ -478,7 +489,8 @@ static OSSL_STORE_INFO *try_decode_PUBKEY(const char *pem_name,
                                           size_t len, void **pctx,
                                           int *matchcount,
                                           const UI_METHOD *ui_method,
-                                          void *ui_data)
+                                          void *ui_data, OPENSSL_CTX *libctx,
+                                          const char *propq)
 {
     OSSL_STORE_INFO *store_info = NULL;
     EVP_PKEY *pkey = NULL;
@@ -512,7 +524,8 @@ static OSSL_STORE_INFO *try_decode_params(const char *pem_name,
                                           size_t len, void **pctx,
                                           int *matchcount,
                                           const UI_METHOD *ui_method,
-                                          void *ui_data)
+                                          void *ui_data, OPENSSL_CTX *libctx,
+                                          const char *propq)
 {
     OSSL_STORE_INFO *store_info = NULL;
     int slen = 0;
@@ -595,7 +608,9 @@ static OSSL_STORE_INFO *try_decode_X509Certificate(const char *pem_name,
                                                    size_t len, void **pctx,
                                                    int *matchcount,
                                                    const UI_METHOD *ui_method,
-                                                   void *ui_data)
+                                                   void *ui_data,
+                                                   OPENSSL_CTX *libctx,
+                                                   const char *propq)
 {
     OSSL_STORE_INFO *store_info = NULL;
     X509 *cert = NULL;
@@ -645,7 +660,8 @@ static OSSL_STORE_INFO *try_decode_X509CRL(const char *pem_name,
                                            size_t len, void **pctx,
                                            int *matchcount,
                                            const UI_METHOD *ui_method,
-                                           void *ui_data)
+                                           void *ui_data, OPENSSL_CTX *libctx,
+                                           const char *propq)
 {
     OSSL_STORE_INFO *store_info = NULL;
     X509_CRL *crl = NULL;
@@ -736,6 +752,9 @@ struct ossl_store_loader_ctx_st {
 
     /* Expected object type.  May be unspecified */
     int expected_type;
+
+    OPENSSL_CTX *libctx;
+    char *propq;
 };
 
 static void OSSL_STORE_LOADER_CTX_free(OSSL_STORE_LOADER_CTX *ctx)
@@ -749,6 +768,7 @@ static void OSSL_STORE_LOADER_CTX_free(OSSL_STORE_LOADER_CTX *ctx)
             ctx-&gt;_.file.last_handler = NULL;
         }
     }
+    OPENSSL_free(ctx-&gt;propq);
     OPENSSL_free(ctx);
 }
 
@@ -963,7 +983,9 @@ static int file_find(OSSL_STORE_LOADER_CTX *ctx,
 }
 
 /* Internal function to decode an already opened PEM file */
-OSSL_STORE_LOADER_CTX *ossl_store_file_attach_pem_bio_int(BIO *bp)
+OSSL_STORE_LOADER_CTX *ossl_store_file_attach_pem_bio_int(BIO *bp,
+                                                          OPENSSL_CTX *libctx,
+                                                          const char *propq)
 {
     OSSL_STORE_LOADER_CTX *ctx = OPENSSL_zalloc(sizeof(*ctx));
 
@@ -976,6 +998,17 @@ OSSL_STORE_LOADER_CTX *ossl_store_file_attach_pem_bio_int(BIO *bp)
     ctx-&gt;_.file.file = bp;
     ctx-&gt;type = is_pem;
 
+    ctx-&gt;libctx = libctx;
+    if (propq != NULL) {
+        ctx-&gt;propq = OPENSSL_strdup(propq);
+        if (ctx-&gt;propq == NULL) {
+            OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_FILE_ATTACH_PEM_BIO_INT,
+                          ERR_R_MALLOC_FAILURE);
+            OPENSSL_free(ctx);
+            return NULL;
+        }
+    }
+
     return ctx;
 }
 
@@ -1013,7 +1046,7 @@ static OSSL_STORE_INFO *file_load_try_decode(OSSL_STORE_LOADER_CTX *ctx,
             OSSL_STORE_INFO *tmp_result =
                 handler-&gt;try_decode(pem_name, pem_header, data, len,
                                     &amp;tmp_handler_ctx, &amp;try_matchcount,
-                                    ui_method, ui_data);
+                                    ui_method, ui_data, ctx-&gt;libctx, ctx-&gt;propq);
 
             if (try_matchcount &gt; 0) {
 
@@ -1080,7 +1113,8 @@ static OSSL_STORE_INFO *file_load_try_repeat(OSSL_STORE_LOADER_CTX *ctx,
             ctx-&gt;_.file.last_handler-&gt;try_decode(NULL, NULL, NULL, 0,
                                                  &amp;ctx-&gt;_.file.last_handler_ctx,
                                                  &amp;try_matchcount,
-                                                 ui_method, ui_data);
+                                                 ui_method, ui_data,
+                                                 ctx-&gt;libctx, ctx-&gt;propq);
 
         if (result == NULL) {
             ctx-&gt;_.file.last_handler-&gt;destroy_ctx(&amp;ctx-&gt;_.file.last_handler_ctx);
diff --git a/crypto/store/store_lib.c b/crypto/store/store_lib.c
index eaf666a80b..7dbc24e870 100644
--- a/crypto/store/store_lib.c
+++ b/crypto/store/store_lib.c
@@ -652,14 +652,16 @@ char *ossl_store_info_get0_EMBEDDED_pem_name(OSSL_STORE_INFO *info)
 }
 
 OSSL_STORE_CTX *ossl_store_attach_pem_bio(BIO *bp, const UI_METHOD *ui_method,
-                                          void *ui_data)
+                                          void *ui_data, OPENSSL_CTX *libctx,
+                                          const char *propq)
 {
     OSSL_STORE_CTX *ctx = NULL;
     const OSSL_STORE_LOADER *loader = NULL;
     OSSL_STORE_LOADER_CTX *loader_ctx = NULL;
 
     if ((loader = ossl_store_get0_loader_int(&quot;file&quot;)) == NULL
-        || ((loader_ctx = ossl_store_file_attach_pem_bio_int(bp)) == NULL))
+        || ((loader_ctx = ossl_store_file_attach_pem_bio_int(bp, libctx,
+                                                             propq)) == NULL))
         goto done;
     if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL) {
         OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_ATTACH_PEM_BIO,
diff --git a/crypto/store/store_local.h b/crypto/store/store_local.h
index 7c4d65b961..9401fd0774 100644
--- a/crypto/store/store_local.h
+++ b/crypto/store/store_local.h
@@ -128,5 +128,7 @@ int ossl_store_file_loader_init(void);
  *  -------------------
  */
 
-OSSL_STORE_LOADER_CTX *ossl_store_file_attach_pem_bio_int(BIO *bp);
+OSSL_STORE_LOADER_CTX *ossl_store_file_attach_pem_bio_int(BIO *bp,
+                                                          OPENSSL_CTX *libctx,
+                                                          const char *propq);
 int ossl_store_file_detach_pem_bio_int(OSSL_STORE_LOADER_CTX *ctx);
diff --git a/crypto/x509/x_all.c b/crypto/x509/x_all.c
index ce8c23b654..0f31c5155f 100644
--- a/crypto/x509/x_all.c
+++ b/crypto/x509/x_all.c
@@ -24,6 +24,7 @@
 #include &lt;openssl/rsa.h&gt;
 #include &lt;openssl/dsa.h&gt;
 #include &lt;openssl/x509v3.h&gt;
+#include &quot;crypto/asn1.h&quot;
 
 static void clean_id_ctx(EVP_MD_CTX *ctx)
 {
@@ -594,6 +595,22 @@ EVP_PKEY *d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a)
     return ASN1_d2i_fp_of(EVP_PKEY, EVP_PKEY_new, d2i_AutoPrivateKey, fp, a);
 }
 
+EVP_PKEY *d2i_PrivateKey_ex_fp(FILE *fp, EVP_PKEY **a, OPENSSL_CTX *libctx,
+                               const char *propq)
+{
+    BIO *b;
+    void *ret;
+
+    if ((b = BIO_new(BIO_s_file())) == NULL) {
+        X509err(0, ERR_R_BUF_LIB);
+        return NULL;
+    }
+    BIO_set_fp(b, fp, BIO_NOCLOSE);
+    ret = d2i_PrivateKey_ex_bio(b, a, libctx, propq);
+    BIO_free(b);
+    return ret;
+}
+
 int i2d_PUBKEY_fp(FILE *fp, const EVP_PKEY *pkey)
 {
     return ASN1_i2d_fp_of(EVP_PKEY, i2d_PUBKEY, fp, pkey);
@@ -642,6 +659,25 @@ EVP_PKEY *d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a)
     return ASN1_d2i_bio_of(EVP_PKEY, EVP_PKEY_new, d2i_AutoPrivateKey, bp, a);
 }
 
+EVP_PKEY *d2i_PrivateKey_ex_bio(BIO *bp, EVP_PKEY **a, OPENSSL_CTX *libctx,
+                                const char *propq)
+{
+    BUF_MEM *b = NULL;
+    const unsigned char *p;
+    void *ret = NULL;
+    int len;
+
+    len = asn1_d2i_read_bio(bp, &amp;b);
+    if (len &lt; 0)
+        goto err;
+
+    p = (unsigned char *)b-&gt;data;
+    ret = d2i_AutoPrivateKey_ex(a, &amp;p, len, libctx, propq);
+ err:
+    BUF_MEM_free(b);
+    return ret;
+}
+
 int i2d_PUBKEY_bio(BIO *bp, const EVP_PKEY *pkey)
 {
     return ASN1_i2d_bio_of(EVP_PKEY, i2d_PUBKEY, bp, pkey);
diff --git a/doc/man3/PEM_read_bio_PrivateKey.pod b/doc/man3/PEM_read_bio_PrivateKey.pod
index 0650b52e07..b1dfe465e7 100644
--- a/doc/man3/PEM_read_bio_PrivateKey.pod
+++ b/doc/man3/PEM_read_bio_PrivateKey.pod
@@ -3,7 +3,8 @@
 =head1 NAME
 
 pem_password_cb,
-PEM_read_bio_PrivateKey, PEM_read_PrivateKey, PEM_write_bio_PrivateKey,
+PEM_read_bio_PrivateKey_ex, PEM_read_bio_PrivateKey, PEM_read_PrivateKey_ex,
+PEM_read_PrivateKey, PEM_write_bio_PrivateKey,
 PEM_write_bio_PrivateKey_traditional, PEM_write_PrivateKey,
 PEM_write_bio_PKCS8PrivateKey, PEM_write_PKCS8PrivateKey,
 PEM_write_bio_PKCS8PrivateKey_nid, PEM_write_PKCS8PrivateKey_nid,
@@ -33,8 +34,14 @@ PEM_write_bio_PKCS7, PEM_write_PKCS7 - PEM routines
 
  typedef int pem_password_cb(char *buf, int size, int rwflag, void *u);
 
+ EVP_PKEY *PEM_read_bio_PrivateKey_ex(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+                                      void *u, OPENSSL_CTX *libctx,
+                                      const char *propq);
  EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,
                                    pem_password_cb *cb, void *u);
+ EVP_PKEY *PEM_read_PrivateKey_ex(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
+                                  void *u, OPENSSL_CTX *libctx,
+                                  const char *propq);
  EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x,
                                pem_password_cb *cb, void *u);
  int PEM_write_bio_PrivateKey(BIO *bp, const EVP_PKEY *x, const EVP_CIPHER *enc,
@@ -168,6 +175,9 @@ brevity the term &quot;B&lt;I&lt;TYPE&gt;&gt; functions&quot; will be used below to collectively
 refer to the B&lt;PEM_read_bio_I&lt;TYPE&gt;&gt;(), B&lt;PEM_read_I&lt;TYPE&gt;&gt;(),
 B&lt;PEM_write_bio_I&lt;TYPE&gt;&gt;(), and B&lt;PEM_write_I&lt;TYPE&gt;&gt;() functions.
 
+Some operations have additional variants that take a library context I&lt;libctx&gt;
+and a property query string I&lt;propq&gt;.
+
 The B&lt;PrivateKey&gt; functions read or write a private key in PEM format using an
 EVP_PKEY structure. The write routines use PKCS#8 private key format and are
 equivalent to PEM_write_bio_PKCS8PrivateKey().The read functions transparently
@@ -307,6 +317,12 @@ arbitrary data to be passed to the callback by the application
 I&lt;must&gt; return the number of characters in the passphrase or -1 if
 an error occurred.
 
+Some implementations may need to use cryptographic algorithms during their
+operation. If this is the case and I&lt;libctx&gt; and I&lt;propq&gt; parameters have been
+passed then any algorithm fetches will use that library context and property
+query string. Otherwise the default library context and property query string
+will be used.
+
 =head1 NOTES
 
 The old B&lt;PrivateKey&gt; write routines are retained for compatibility.
@@ -480,6 +496,9 @@ The old Netscape certificate sequences were no longer documented
 in OpenSSL 1.1.0; applications should use the PKCS7 standard instead
 as they will be formally deprecated in a future releases.
 
+PEM_read_bio_PrivateKey_ex() and PEM_read_PrivateKey_ex() were introduced in
+OpenSSL 3.0.
+
 =head1 COPYRIGHT
 
 Copyright 2001-2019 The OpenSSL Project Authors. All Rights Reserved.
diff --git a/doc/man3/d2i_PrivateKey.pod b/doc/man3/d2i_PrivateKey.pod
index 4b7a326c0d..ca4876cfd9 100644
--- a/doc/man3/d2i_PrivateKey.pod
+++ b/doc/man3/d2i_PrivateKey.pod
@@ -2,21 +2,29 @@
 
 =head1 NAME
 
-d2i_PrivateKey, d2i_PublicKey, d2i_KeyParams, d2i_AutoPrivateKey,
-i2d_PrivateKey, i2d_PublicKey, i2d_KeyParams, i2d_KeyParams_bio,
-d2i_PrivateKey_bio, d2i_PrivateKey_fp, d2i_KeyParams_bio
+d2i_PrivateKey_ex, d2i_PrivateKey, d2i_PublicKey, d2i_KeyParams,
+d2i_AutoPrivateKey_ex,  d2i_AutoPrivateKey, i2d_PrivateKey, i2d_PublicKey,
+i2d_KeyParams, i2d_KeyParams_bio, d2i_PrivateKey_ex_bio, d2i_PrivateKey_bio,
+d2i_PrivateKey_ex_fp, d2i_PrivateKey_fp, d2i_KeyParams_bio, i2d_PrivateKey_bio,
+i2d_PrivateKey_fp
 - decode and encode functions for reading and saving EVP_PKEY structures
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/evp.h&gt;
 
+ EVP_PKEY *d2i_PrivateKey_ex(int type, EVP_PKEY **a, const unsigned char **pp,
+                             long length, OPENSSL_CTX *libctx,
+                             const char *propq);
  EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
                           long length);
  EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
                          long length);
  EVP_PKEY *d2i_KeyParams(int type, EVP_PKEY **a, const unsigned char **pp,
                          long length);
+ EVP_PKEY *d2i_AutoPrivateKey_ex(EVP_PKEY **a, const unsigned char **pp,
+                                 long length, OPENSSL_CTX *libctx,
+                                 const char *propq);
  EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
                               long length);
 
@@ -24,28 +32,54 @@ d2i_PrivateKey_bio, d2i_PrivateKey_fp, d2i_KeyParams_bio
  int i2d_PublicKey(const EVP_PKEY *a, unsigned char **pp);
  int i2d_KeyParams(const EVP_PKEY *a, unsigned char **pp);
  int i2d_KeyParams_bio(BIO *bp, const EVP_PKEY *pkey);
+ EVP_PKEY *d2i_KeyParams_bio(int type, EVP_PKEY **a, BIO *in);
+
 
+ #include &lt;openssl/x509.h&gt;
+
+ EVP_PKEY *d2i_PrivateKey_ex_bio(BIO *bp, EVP_PKEY **a, OPENSSL_CTX *libctx,
+                                 const char *propq);
  EVP_PKEY *d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a);
+ EVP_PKEY *d2i_PrivateKey_ex_fp(FILE *fp, EVP_PKEY **a, OPENSSL_CTX *libctx,
+                                const char *propq);
  EVP_PKEY *d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a)
- EVP_PKEY *d2i_KeyParams_bio(int type, EVP_PKEY **a, BIO *in);
+
+ int i2d_PrivateKey_bio(BIO *bp, const EVP_PKEY *pkey);
+ int i2d_PrivateKey_fp(FILE *fp, const EVP_PKEY *pkey);
 
 =head1 DESCRIPTION
 
-d2i_PrivateKey() decodes a private key using algorithm B&lt;type&gt;. It attempts to
-use any key specific format or PKCS#8 unencrypted PrivateKeyInfo format. The
-B&lt;type&gt; parameter should be a public key algorithm constant such as
-B&lt;EVP_PKEY_RSA&gt;. An error occurs if the decoded key does not match B&lt;type&gt;.
+d2i_PrivateKey_ex() decodes a private key using algorithm I&lt;type&gt;. It attempts
+to use any key specific format or PKCS#8 unencrypted PrivateKeyInfo format. The
+I&lt;type&gt; parameter should be a public key algorithm constant such as
+B&lt;EVP_PKEY_RSA&gt;. An error occurs if the decoded key does not match I&lt;type&gt;. Some
+private key decoding implementations may use cryptographic algorithms (for
+example to automatically derive the public key if it is not explicitly
+included in the encoding). In this case the supplied library context I&lt;libctx&gt;
+and property query string I&lt;propq&gt; are used.
+d2i_PrivateKey() does the same as d2i_PrivateKey_ex() except that the default
+library context and property query string are used.
 d2i_PublicKey() does the same for public keys.
 d2i_KeyParams() does the same for key parameters.
 
-d2i_AutoPrivateKey() is similar to d2i_PrivateKey() except it attempts to
-automatically detect the private key format.
+The d2i_PrivateKey_ex_bio() and d2i_PrivateKey_bio() functions are similar to
+d2i_PrivateKey_ex() and d2i_PrivateKey() respectively except that they decode
+the data read from the given BIO. The d2i_PrivateKey_ex_fp() and
+d2i_PrivateKey_fp() functions are the same except that they read the data from
+the given FILE.
+
+d2i_AutoPrivateKey_ex() and d2i_AutoPrivateKey() are similar to
+d2i_PrivateKey_ex() and d2i_PrivateKey() respectively except that they attempt
+to automatically detect the private key format.
 
-i2d_PrivateKey() encodes B&lt;key&gt;. It uses a key specific format or, if none is
+i2d_PrivateKey() encodes I&lt;a&gt;. It uses a key specific format or, if none is
 defined for that key type, PKCS#8 unencrypted PrivateKeyInfo format.
 i2d_PublicKey() does the same for public keys.
 i2d_KeyParams() does the same for key parameters.
 These functions are similar to the d2i_X509() functions; see L&lt;d2i_X509(3)&gt;.
+i2d_PrivateKey_bio() and i2d_PrivateKey_fp() do the same thing except that they
+encode to a B&lt;BIO&gt; or B&lt;FILE&gt; respectrively. Again, these work similarly to the
+functions described in L&lt;d2i_X509(3)&gt;.
 
 =head1 NOTES
 
@@ -53,30 +87,38 @@ All these functions use DER format and unencrypted keys. Applications wishing
 to encrypt or decrypt private keys should use other functions such as
 d2i_PKCS8PrivateKey() instead.
 
-If the B&lt;*a&gt; is not NULL when calling d2i_PrivateKey() or d2i_AutoPrivateKey()
+If the I&lt;*a&gt; is not NULL when calling d2i_PrivateKey() or d2i_AutoPrivateKey()
 (i.e. an existing structure is being reused) and the key format is PKCS#8
-then B&lt;*a&gt; will be freed and replaced on a successful call.
+then I&lt;*a&gt; will be freed and replaced on a successful call.
 
-To decode a key with type B&lt;EVP_PKEY_EC&gt;, d2i_PublicKey() requires B&lt;*a&gt; to be
+To decode a key with type B&lt;EVP_PKEY_EC&gt;, d2i_PublicKey() requires I&lt;*a&gt; to be
 a non-NULL EVP_PKEY structure assigned an EC_KEY structure referencing the proper
 EC_GROUP.
 
 =head1 RETURN VALUES
 
-The d2i_PrivateKey(), d2i_AutoPrivateKey(), d2i_PrivateKey_bio(), d2i_PrivateKey_fp(),
-d2i_PublicKey(), d2i_KeyParams() and d2i_KeyParams_bio() functions return a valid
-B&lt;EVP_KEY&gt; structure or B&lt;NULL&gt; if an error occurs. The error code can be
-obtained by calling L&lt;ERR_get_error(3)&gt;.
+The d2i_PrivateKey_ex(), d2i_PrivateKey(), d2i_AutoPrivateKey_ex(),
+d2i_AutoPrivateKey(), d2i_PrivateKey_ex_bio(), d2i_PrivateKey_bio(),
+d2i_PrivateKey_ex_fp(), d2i_PrivateKey_fp(), d2i_PublicKey(), d2i_KeyParams()
+and d2i_KeyParams_bio() functions return a valid B&lt;EVP_KEY&gt; structure or B&lt;NULL&gt;
+if an error occurs. The error code can be obtained by calling
+L&lt;ERR_get_error(3)&gt;.
 
-i2d_PrivateKey(), i2d_PublicKey(), i2d_KeyParams() i2d_KeyParams_bio() return
-the number of bytes successfully encoded or a negative value if an error occurs.
-The error code can be obtained by calling L&lt;ERR_get_error(3)&gt;.
+i2d_PrivateKey(), i2d_PrivateKey_bio(), i2d_PrivateKey_fp(), i2d_PublicKey(),
+i2d_KeyParams() i2d_KeyParams_bio() return the number of bytes successfully
+encoded or a negative value if an error occurs. The error code can be obtained
+by calling L&lt;ERR_get_error(3)&gt;.
 
 =head1 SEE ALSO
 
 L&lt;crypto(7)&gt;,
 L&lt;d2i_PKCS8PrivateKey_bio(3)&gt;
 
+=head1 HISTORY
+
+d2i_PrivateKey_ex(), d2i_PrivateKey_ex_bio(), d2i_PrivateKey_ex_fp(), and
+d2i_AutoPrivateKey_ex() were added in OpenSSL 3.0.
+
 =head1 COPYRIGHT
 
 Copyright 2017-2019 The OpenSSL Project Authors. All Rights Reserved.
diff --git a/include/crypto/asn1.h b/include/crypto/asn1.h
index 84e6e7f544..737c715e33 100644
--- a/include/crypto/asn1.h
+++ b/include/crypto/asn1.h
@@ -76,6 +76,11 @@ struct evp_pkey_asn1_method_st {
                       EVP_KEYMGMT *to_keymgmt, OPENSSL_CTX *libctx,
                       const char *propq);
     OSSL_CALLBACK *import_from;
+
+    int (*priv_decode_with_libctx) (EVP_PKEY *pk,
+                                    const PKCS8_PRIV_KEY_INFO *p8inf,
+                                    OPENSSL_CTX *libctx,
+                                    const char *propq);
 } /* EVP_PKEY_ASN1_METHOD */ ;
 
 DEFINE_STACK_OF_CONST(EVP_PKEY_ASN1_METHOD)
diff --git a/include/crypto/evp.h b/include/crypto/evp.h
index 38adbd0c82..3f9cc9c683 100644
--- a/include/crypto/evp.h
+++ b/include/crypto/evp.h
@@ -736,4 +736,7 @@ const EVP_MD *evp_get_digestbyname_ex(OPENSSL_CTX *libctx, const char *name);
  */
 int evp_pkey_ctx_set_params_strict(EVP_PKEY_CTX *ctx, OSSL_PARAM *params);
 int evp_pkey_ctx_get_params_strict(EVP_PKEY_CTX *ctx, OSSL_PARAM *params);
+
+EVP_PKEY *evp_pkcs82pkey_int(const PKCS8_PRIV_KEY_INFO *p8, OPENSSL_CTX *libctx,
+                             const char *propq);
 #endif /* !defined(FIPS_MODE) */
diff --git a/include/crypto/store.h b/include/crypto/store.h
index 8f4757d9c2..ea207d83df 100644
--- a/include/crypto/store.h
+++ b/include/crypto/store.h
@@ -20,7 +20,8 @@
  * as usual with OSSLSTORE_load() and OSSLSTORE_eof().
  */
 OSSL_STORE_CTX *ossl_store_attach_pem_bio(BIO *bp, const UI_METHOD *ui_method,
-                                          void *ui_data);
+                                          void *ui_data, OPENSSL_CTX *libctx,
+                                          const char *propq);
 int ossl_store_detach_pem_bio(OSSL_STORE_CTX *ctx);
 
 void ossl_store_cleanup_int(void);
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 3945e43fac..b1e2bb0dff 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -1163,8 +1163,14 @@ EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
                         long length);
 int i2d_PublicKey(const EVP_PKEY *a, unsigned char **pp);
 
+
+EVP_PKEY *d2i_PrivateKey_ex(int type, EVP_PKEY **a, const unsigned char **pp,
+                            long length, OPENSSL_CTX *libctx, const char *propq);
 EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
                          long length);
+EVP_PKEY *d2i_AutoPrivateKey_ex(EVP_PKEY **a, const unsigned char **pp,
+                                long length, OPENSSL_CTX *libctx,
+                                const char *propq);
 EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
                              long length);
 int i2d_PrivateKey(const EVP_PKEY *a, unsigned char **pp);
diff --git a/include/openssl/pem.h b/include/openssl/pem.h
index e48d247087..b811d5ea91 100644
--- a/include/openssl/pem.h
+++ b/include/openssl/pem.h
@@ -347,6 +347,14 @@ DECLARE_PEM_rw(DHparams, DH)
 DECLARE_PEM_write(DHxparams, DH)
 # endif
 DECLARE_PEM_rw_cb(PrivateKey, EVP_PKEY)
+EVP_PKEY *PEM_read_bio_PrivateKey_ex(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+                                     void *u, OPENSSL_CTX *libctx,
+                                     const char *propq);
+# ifndef OPENSSL_NO_STDIO
+EVP_PKEY *PEM_read_PrivateKey_ex(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
+                                 void *u, OPENSSL_CTX *libctx,
+                                 const char *propq);
+# endif
 DECLARE_PEM_rw(PUBKEY, EVP_PKEY)
 
 int PEM_write_bio_PrivateKey_traditional(BIO *bp, const EVP_PKEY *x,
diff --git a/include/openssl/x509.h b/include/openssl/x509.h
index 8952e392a8..64156d495b 100644
--- a/include/openssl/x509.h
+++ b/include/openssl/x509.h
@@ -435,6 +435,8 @@ PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,
 int i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp, const PKCS8_PRIV_KEY_INFO *p8inf);
 int i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, const EVP_PKEY *key);
 int i2d_PrivateKey_fp(FILE *fp, const EVP_PKEY *pkey);
+EVP_PKEY *d2i_PrivateKey_ex_fp(FILE *fp, EVP_PKEY **a, OPENSSL_CTX *libctx,
+                               const char *propq);
 EVP_PKEY *d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a);
 int i2d_PUBKEY_fp(FILE *fp, const EVP_PKEY *pkey);
 EVP_PKEY *d2i_PUBKEY_fp(FILE *fp, EVP_PKEY **a);
@@ -475,6 +477,8 @@ PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,
 int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, const PKCS8_PRIV_KEY_INFO *p8inf);
 int i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, const EVP_PKEY *key);
 int i2d_PrivateKey_bio(BIO *bp, const EVP_PKEY *pkey);
+EVP_PKEY *d2i_PrivateKey_ex_bio(BIO *bp, EVP_PKEY **a, OPENSSL_CTX *libctx,
+                                const char *propq);
 EVP_PKEY *d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a);
 int i2d_PUBKEY_bio(BIO *bp, const EVP_PKEY *pkey);
 EVP_PKEY *d2i_PUBKEY_bio(BIO *bp, EVP_PKEY **a);
diff --git a/ssl/ssl_rsa.c b/ssl/ssl_rsa.c
index 09b965fc19..58f0833f22 100644
--- a/ssl/ssl_rsa.c
+++ b/ssl/ssl_rsa.c
@@ -264,12 +264,15 @@ int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type)
     }
     if (type == SSL_FILETYPE_PEM) {
         j = ERR_R_PEM_LIB;
-        pkey = PEM_read_bio_PrivateKey(in, NULL,
-                                       ssl-&gt;default_passwd_callback,
-                                       ssl-&gt;default_passwd_callback_userdata);
+        pkey = PEM_read_bio_PrivateKey_ex(in, NULL,
+                                          ssl-&gt;default_passwd_callback,
+                                          ssl-&gt;default_passwd_callback_userdata,
+                                          ssl-&gt;ctx-&gt;libctx,
+                                          ssl-&gt;ctx-&gt;propq);
     } else if (type == SSL_FILETYPE_ASN1) {
         j = ERR_R_ASN1_LIB;
-        pkey = d2i_PrivateKey_bio(in, NULL);
+        pkey = d2i_PrivateKey_ex_bio(in, NULL, ssl-&gt;ctx-&gt;libctx,
+                                     ssl-&gt;ctx-&gt;propq);
     } else {
         SSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);
         goto end;
@@ -293,7 +296,8 @@ int SSL_use_PrivateKey_ASN1(int type, SSL *ssl, const unsigned char *d,
     EVP_PKEY *pkey;
 
     p = d;
-    if ((pkey = d2i_PrivateKey(type, NULL, &amp;p, (long)len)) == NULL) {
+    if ((pkey = d2i_PrivateKey_ex(type, NULL, &amp;p, (long)len, ssl-&gt;ctx-&gt;libctx,
+                                  ssl-&gt;ctx-&gt;propq)) == NULL) {
         SSLerr(SSL_F_SSL_USE_PRIVATEKEY_ASN1, ERR_R_ASN1_LIB);
         return 0;
     }
@@ -551,12 +555,13 @@ int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)
     }
     if (type == SSL_FILETYPE_PEM) {
         j = ERR_R_PEM_LIB;
-        pkey = PEM_read_bio_PrivateKey(in, NULL,
+        pkey = PEM_read_bio_PrivateKey_ex(in, NULL,
                                        ctx-&gt;default_passwd_callback,
-                                       ctx-&gt;default_passwd_callback_userdata);
+                                       ctx-&gt;default_passwd_callback_userdata,
+                                       ctx-&gt;libctx, ctx-&gt;propq);
     } else if (type == SSL_FILETYPE_ASN1) {
         j = ERR_R_ASN1_LIB;
-        pkey = d2i_PrivateKey_bio(in, NULL);
+        pkey = d2i_PrivateKey_ex_bio(in, NULL, ctx-&gt;libctx, ctx-&gt;propq);
     } else {
         SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);
         goto end;
@@ -580,7 +585,8 @@ int SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx,
     EVP_PKEY *pkey;
 
     p = d;
-    if ((pkey = d2i_PrivateKey(type, NULL, &amp;p, (long)len)) == NULL) {
+    if ((pkey = d2i_PrivateKey_ex(type, NULL, &amp;p, (long)len, ctx-&gt;libctx,
+                                  ctx-&gt;propq)) == NULL) {
         SSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1, ERR_R_ASN1_LIB);
         return 0;
     }
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 60202b9008..dd3ddef833 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -5050,3 +5050,9 @@ EVP_PKEY_get_ex_data                    ?	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_set_ec_paramgen_curve_name ?	3_0_0	EXIST::FUNCTION:EC
 EVP_PKEY_CTX_get_ec_paramgen_curve_name ?	3_0_0	EXIST::FUNCTION:EC
 EVP_PKEY_CTX_set_ec_paramgen_curve_nid  ?	3_0_0	EXIST::FUNCTION:EC
+d2i_PrivateKey_ex                       ?	3_0_0	EXIST::FUNCTION:
+d2i_AutoPrivateKey_ex                   ?	3_0_0	EXIST::FUNCTION:
+d2i_PrivateKey_ex_fp                    ?	3_0_0	EXIST::FUNCTION:STDIO
+d2i_PrivateKey_ex_bio                   ?	3_0_0	EXIST::FUNCTION:
+PEM_read_bio_PrivateKey_ex              ?	3_0_0	EXIST::FUNCTION:
+PEM_read_PrivateKey_ex                  ?	3_0_0	EXIST::FUNCTION:STDIO
diff --git a/util/missingcrypto.txt b/util/missingcrypto.txt
index 6ce32388a2..cb8049b832 100644
--- a/util/missingcrypto.txt
+++ b/util/missingcrypto.txt
@@ -1564,8 +1564,6 @@ i2a_ASN1_STRING(3)
 i2b_PVK_bio(3)
 i2b_PrivateKey_bio(3)
 i2b_PublicKey_bio(3)
-i2d_PrivateKey_bio(3)
-i2d_PrivateKey_fp(3)
 i2d_X509_bio(3)
 i2d_X509_fp(3)
 i2o_ECPublicKey(3)
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="028283.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="028287.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28286">[ date ]</a>
              <a href="thread.html#28286">[ thread ]</a>
              <a href="subject.html#28286">[ subject ]</a>
              <a href="author.html#28286">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
