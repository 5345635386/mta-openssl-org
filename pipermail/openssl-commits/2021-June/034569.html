<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2021-June/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1622544271.951983.22010.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="034568.html">
   <LINK REL="Next"  HREF="034572.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>tomas at openssl.org</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1622544271.951983.22010.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">tomas at openssl.org
       </A><BR>
    <I>Tue Jun  1 10:44:31 UTC 2021</I>
    <P><UL>
        <LI>Previous message: <A HREF="034568.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="034572.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34569">[ date ]</a>
              <a href="thread.html#34569">[ thread ]</a>
              <a href="subject.html#34569">[ subject ]</a>
              <a href="author.html#34569">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  31b7f23d2f958491d46c8a8e61c2b77b1b546f3e (commit)
       via  c4e91674371404accba3891cbe9d7f976926a337 (commit)
       via  ed576acdf591d4164905ab98e89ca5a3b99d90ab (commit)
      from  5e2d22d53ed322a7124e26a4fbd116a8210eb77a (commit)


- Log -----------------------------------------------------------------
commit 31b7f23d2f958491d46c8a8e61c2b77b1b546f3e
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tomas at openssl.org</A>&gt;
Date:   Fri May 28 17:36:16 2021 +0200

    Add documentation of the old names kept as alias macros
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15405">https://github.com/openssl/openssl/pull/15405</A>)

commit c4e91674371404accba3891cbe9d7f976926a337
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tomas at openssl.org</A>&gt;
Date:   Fri May 28 16:57:22 2021 +0200

    Rename also the OSSL_PROVIDER_name() function
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15405">https://github.com/openssl/openssl/pull/15405</A>)

commit ed576acdf591d4164905ab98e89ca5a3b99d90ab
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tomas at openssl.org</A>&gt;
Date:   Fri May 21 16:58:08 2021 +0200

    Rename all getters to use get/get0 in name
    
    For functions that exist in 1.1.1 provide a simple aliases via #define.
    
    Fixes #15236
    
    Functions with OSSL_DECODER_, OSSL_ENCODER_, OSSL_STORE_LOADER_,
    EVP_KEYEXCH_, EVP_KEM_, EVP_ASYM_CIPHER_, EVP_SIGNATURE_,
    EVP_KEYMGMT_, EVP_RAND_, EVP_MAC_, EVP_KDF_, EVP_PKEY_,
    EVP_MD_, and EVP_CIPHER_ prefixes are renamed.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/15405">https://github.com/openssl/openssl/pull/15405</A>)

-----------------------------------------------------------------------

Summary of changes:
 CHANGES.md                                         |  11 +-
 apps/cms.c                                         |   2 +-
 apps/crl.c                                         |   3 +-
 apps/dgst.c                                        |   8 +-
 apps/dsa.c                                         |   2 +-
 apps/ec.c                                          |   2 +-
 apps/enc.c                                         |  32 +--
 apps/gendsa.c                                      |   4 +-
 apps/genpkey.c                                     |   2 +-
 apps/lib/s_cb.c                                    |  14 +-
 apps/list.c                                        | 161 +++++++-------
 apps/pkeyutl.c                                     |   6 +-
 apps/rehash.c                                      |   2 +-
 apps/req.c                                         |   2 +-
 apps/rsa.c                                         |   2 +-
 apps/rsautl.c                                      |   2 +-
 apps/s_client.c                                    |   6 +-
 apps/speed.c                                       |  34 +--
 apps/ts.c                                          |   6 +-
 crypto/asn1/a_digest.c                             |   6 +-
 crypto/asn1/a_sign.c                               |  10 +-
 crypto/asn1/a_verify.c                             |   4 +-
 crypto/asn1/d2i_param.c                            |   2 +-
 crypto/asn1/d2i_pr.c                               |   2 +-
 crypto/asn1/d2i_pu.c                               |   4 +-
 crypto/asn1/i2d_evp.c                              |   2 +-
 crypto/asn1/p5_pbev2.c                             |   6 +-
 crypto/asn1/p5_scrypt.c                            |  12 +-
 crypto/asn1/x_algor.c                              |   2 +-
 crypto/cmac/cmac.c                                 |  10 +-
 crypto/cmp/cmp_ctx.c                               |   4 +-
 crypto/cmp/cmp_protect.c                           |   6 +-
 crypto/cms/cms_dh.c                                |  15 +-
 crypto/cms/cms_ec.c                                |  12 +-
 crypto/cms/cms_enc.c                               |  15 +-
 crypto/cms/cms_env.c                               |  10 +-
 crypto/cms/cms_kari.c                              |  14 +-
 crypto/cms/cms_lib.c                               |   4 +-
 crypto/cms/cms_pwri.c                              |   8 +-
 crypto/cms/cms_sd.c                                |   9 +-
 crypto/cms/cms_smime.c                             |   2 +-
 crypto/core_namemap.c                              |   4 +-
 crypto/crmf/crmf_lib.c                             |  10 +-
 crypto/dh/dh_kdf.c                                 |   4 +-
 crypto/dh/dh_pmeth.c                               |   2 +-
 crypto/dsa/dsa_pmeth.c                             |  34 +--
 crypto/ec/ec_ameth.c                               |   2 +-
 crypto/ec/ec_pmeth.c                               |  26 +--
 crypto/ec/ecdh_kdf.c                               |   2 +-
 crypto/ec/ecx_meth.c                               |  20 +-
 crypto/encode_decode/decoder_lib.c                 |   2 +-
 crypto/encode_decode/decoder_meth.c                |  14 +-
 crypto/encode_decode/decoder_pkey.c                |   6 +-
 crypto/encode_decode/encoder_lib.c                 |   2 +-
 crypto/encode_decode/encoder_meth.c                |  14 +-
 crypto/encode_decode/encoder_pkey.c                |  10 +-
 crypto/engine/eng_openssl.c                        |  18 +-
 crypto/evp/asymcipher.c                            |  16 +-
 crypto/evp/bio_enc.c                               |   4 +-
 crypto/evp/bio_md.c                                |   2 +-
 crypto/evp/bio_ok.c                                |  12 +-
 crypto/evp/ctrl_params_translate.c                 |  28 +--
 crypto/evp/digest.c                                |  12 +-
 crypto/evp/e_aes.c                                 | 214 +++++++++---------
 crypto/evp/e_aes_cbc_hmac_sha1.c                   |  10 +-
 crypto/evp/e_aes_cbc_hmac_sha256.c                 |  10 +-
 crypto/evp/e_aria.c                                |  53 +++--
 crypto/evp/e_bf.c                                  |   2 +-
 crypto/evp/e_camellia.c                            |  47 ++--
 crypto/evp/e_cast.c                                |   2 +-
 crypto/evp/e_des.c                                 |  26 +--
 crypto/evp/e_des3.c                                |  32 +--
 crypto/evp/e_idea.c                                |   4 +-
 crypto/evp/e_rc2.c                                 |   8 +-
 crypto/evp/e_rc4.c                                 |   2 +-
 crypto/evp/e_rc4_hmac_md5.c                        |   6 +-
 crypto/evp/e_rc5.c                                 |   4 +-
 crypto/evp/e_sm4.c                                 |   2 +-
 crypto/evp/e_xcbc_d.c                              |   4 +-
 crypto/evp/evp_enc.c                               |  48 ++--
 crypto/evp/evp_key.c                               |   6 +-
 crypto/evp/evp_lib.c                               |  90 ++++----
 crypto/evp/evp_local.h                             |   2 +-
 crypto/evp/evp_pbe.c                               |   4 +-
 crypto/evp/evp_pkey.c                              |   2 +-
 crypto/evp/evp_rand.c                              |  24 +-
 crypto/evp/exchange.c                              |  16 +-
 crypto/evp/kdf_lib.c                               |   8 +-
 crypto/evp/kdf_meth.c                              |  10 +-
 crypto/evp/kem.c                                   |  14 +-
 crypto/evp/keymgmt_lib.c                           |   4 +-
 crypto/evp/keymgmt_meth.c                          |  18 +-
 crypto/evp/legacy_md5_sha1.c                       |   2 +-
 crypto/evp/legacy_meth.h                           |  12 +-
 crypto/evp/legacy_sha.c                            |  10 +-
 crypto/evp/m_sigver.c                              |   8 +-
 crypto/evp/mac_lib.c                               |   8 +-
 crypto/evp/mac_meth.c                              |  12 +-
 crypto/evp/p5_crpt.c                               |   6 +-
 crypto/evp/p5_crpt2.c                              |   6 +-
 crypto/evp/p_dec.c                                 |   2 +-
 crypto/evp/p_enc.c                                 |   2 +-
 crypto/evp/p_legacy.c                              |   2 +-
 crypto/evp/p_lib.c                                 |  26 +--
 crypto/evp/p_seal.c                                |   6 +-
 crypto/evp/p_sign.c                                |   2 +-
 crypto/evp/pmeth_lib.c                             |  24 +-
 crypto/evp/signature.c                             |  16 +-
 crypto/ffc/ffc_params_generate.c                   |  10 +-
 crypto/hmac/hmac.c                                 |  16 +-
 crypto/modes/siv128.c                              |   2 +-
 crypto/ocsp/ocsp_lib.c                             |   2 +-
 crypto/ocsp/ocsp_srv.c                             |   6 +-
 crypto/ocsp/ocsp_vfy.c                             |   2 +-
 crypto/pem/pem_info.c                              |  18 +-
 crypto/pem/pem_lib.c                               |  17 +-
 crypto/pem/pem_local.h                             |   2 +-
 crypto/pem/pem_pk8.c                               |   3 +-
 crypto/pem/pem_sign.c                              |   2 +-
 crypto/pem/pvkfmt.c                                |   2 +-
 crypto/pkcs12/p12_crpt.c                           |   8 +-
 crypto/pkcs12/p12_decr.c                           |  10 +-
 crypto/pkcs12/p12_key.c                            |   3 +-
 crypto/pkcs12/p12_mutl.c                           |   6 +-
 crypto/pkcs7/pk7_doit.c                            |  24 +-
 crypto/pkcs7/pk7_lib.c                             |   6 +-
 crypto/provider.c                                  |   2 +-
 crypto/provider_core.c                             |   2 +-
 crypto/rand/rand_lib.c                             |   2 +-
 crypto/rand/rand_meth.c                            |   2 +-
 crypto/rsa/rsa_ameth.c                             |  23 +-
 crypto/rsa/rsa_backend.c                           |   4 +-
 crypto/rsa/rsa_oaep.c                              |   6 +-
 crypto/rsa/rsa_pmeth.c                             |  28 +--
 crypto/rsa/rsa_pss.c                               |   4 +-
 crypto/rsa/rsa_sp800_56b_gen.c                     |   2 +-
 crypto/sm2/sm2_crypt.c                             |  10 +-
 crypto/sm2/sm2_sign.c                              |   4 +-
 crypto/store/store_lib.c                           |  13 +-
 crypto/store/store_meth.c                          |   8 +-
 crypto/store/store_result.c                        |   4 +-
 crypto/ts/ts_rsp_sign.c                            |   6 +-
 crypto/ts/ts_rsp_verify.c                          |   2 +-
 crypto/x509/x509_set.c                             |   2 +-
 crypto/x509/x509_vfy.c                             |   4 +-
 crypto/x509/x509type.c                             |   2 +-
 crypto/x509/x_pubkey.c                             |  12 +-
 demos/digest/BIO_f_md.c                            |   2 +-
 demos/digest/EVP_MD_demo.c                         |   4 +-
 demos/digest/EVP_MD_stdin.c                        |   4 +-
 doc/build.info                                     |  12 +-
 doc/man3/BIO_f_md.pod                              |   2 +-
 doc/man3/DH_size.pod                               |   6 +-
 doc/man3/DSA_size.pod                              |  10 +-
 doc/man3/EVP_ASYM_CIPHER_free.pod                  |  25 ++-
 doc/man3/EVP_CIPHER_CTX_get_original_iv.pod        |  11 +-
 doc/man3/EVP_DigestInit.pod                        | 120 ++++++----
 doc/man3/EVP_DigestSignInit.pod                    |   4 +-
 doc/man3/EVP_EncryptInit.pod                       | 247 ++++++++++++++-------
 doc/man3/EVP_KDF.pod                               |  31 +--
 doc/man3/EVP_KEM_free.pod                          |  24 +-
 doc/man3/EVP_KEYEXCH_free.pod                      |  31 +--
 doc/man3/EVP_KEYMGMT.pod                           |  44 ++--
 doc/man3/EVP_MAC.pod                               |  35 +--
 doc/man3/EVP_MD_meth_new.pod                       |   4 +-
 doc/man3/EVP_PKEY_ASN1_METHOD.pod                  |   4 +-
 doc/man3/EVP_PKEY_CTX_set_hkdf_md.pod              |   8 +-
 .../{EVP_PKEY_size.pod =&gt; EVP_PKEY_get_size.pod}   |  37 +--
 doc/man3/EVP_PKEY_new.pod                          |  10 +-
 doc/man3/EVP_PKEY_set1_RSA.pod                     |  35 +--
 doc/man3/EVP_PKEY_set_type.pod                     |   6 +-
 doc/man3/EVP_RAND.pod                              |  55 ++---
 doc/man3/EVP_SIGNATURE_free.pod                    |  27 +--
 doc/man3/EVP_SealInit.pod                          |   4 +-
 doc/man3/EVP_SignInit.pod                          |  11 +-
 doc/man3/OSSL_DECODER.pod                          |  42 ++--
 doc/man3/OSSL_ENCODER.pod                          |  40 ++--
 doc/man3/OSSL_PROVIDER.pod                         |   6 +-
 doc/man3/OSSL_STORE_LOADER.pod                     |  38 ++--
 doc/man3/PEM_read_bio_PrivateKey.pod               |   4 +-
 doc/man3/RSA_size.pod                              |   4 +-
 doc/man7/EVP_MD-common.pod                         |   6 +-
 doc/man7/crypto.pod                                |   2 +-
 doc/man7/fips_module.pod                           |   6 +-
 doc/man7/migration_guide.pod                       |  11 +-
 engines/e_afalg.c                                  |  14 +-
 engines/e_dasync.c                                 |   4 +-
 engines/e_devcrypto.c                              |  28 +--
 engines/e_ossltest.c                               |  14 +-
 engines/e_padlock.c                                |  14 +-
 include/crypto/evp.h                               |  14 +-
 include/internal/packet.h                          |   2 +-
 include/openssl/decoder.h                          |  10 +-
 include/openssl/encoder.h                          |  10 +-
 include/openssl/evp.h                              | 198 ++++++++++-------
 include/openssl/kdf.h                              |  11 +-
 include/openssl/provider.h                         |   2 +-
 include/openssl/store.h                            |   8 +-
 providers/fips/self_test_kats.c                    |   2 +-
 providers/implementations/asymciphers/rsa_enc.c    |   4 +-
 providers/implementations/asymciphers/sm2_enc.c    |   2 +-
 providers/implementations/exchange/dh_exch.c       |   2 +-
 providers/implementations/exchange/ecdh_exch.c     |   2 +-
 providers/implementations/kdfs/hkdf.c              |  12 +-
 providers/implementations/kdfs/kbkdf.c             |   4 +-
 providers/implementations/kdfs/krb5kdf.c           |  10 +-
 providers/implementations/kdfs/pbkdf2.c            |   2 +-
 providers/implementations/kdfs/pkcs12kdf.c         |   4 +-
 providers/implementations/kdfs/sskdf.c             |   8 +-
 providers/implementations/kdfs/x942kdf.c           |   4 +-
 .../implementations/keymgmt/mac_legacy_kmgmt.c     |   4 +-
 providers/implementations/macs/cmac_prov.c         |   2 +-
 providers/implementations/macs/gmac_prov.c         |   4 +-
 providers/implementations/macs/kmac_prov.c         |   6 +-
 providers/implementations/rands/drbg_ctr.c         |   5 +-
 providers/implementations/rands/drbg_hash.c        |   6 +-
 providers/implementations/rands/drbg_hmac.c        |   8 +-
 providers/implementations/signature/dsa_sig.c      |   2 +-
 providers/implementations/signature/ecdsa_sig.c    |   4 +-
 .../implementations/signature/mac_legacy_sig.c     |   2 +-
 providers/implementations/signature/rsa_sig.c      |  20 +-
 providers/implementations/signature/sm2_sig.c      |   6 +-
 ssl/ktls.c                                         |  23 +-
 ssl/record/rec_layer_d1.c                          |   6 +-
 ssl/record/rec_layer_s3.c                          |  10 +-
 ssl/record/ssl3_record.c                           |  60 ++---
 ssl/record/ssl3_record_tls13.c                     |   2 +-
 ssl/s3_enc.c                                       |  16 +-
 ssl/ssl_ciph.c                                     |  15 +-
 ssl/ssl_lib.c                                      |  16 +-
 ssl/statem/extensions.c                            |   4 +-
 ssl/statem/extensions_clnt.c                       |   6 +-
 ssl/statem/extensions_srvr.c                       |   5 +-
 ssl/statem/statem_clnt.c                           |  11 +-
 ssl/statem/statem_dtls.c                           |   8 +-
 ssl/statem/statem_lib.c                            |  17 +-
 ssl/statem/statem_srvr.c                           |  10 +-
 ssl/t1_enc.c                                       |  32 +--
 ssl/t1_lib.c                                       |  26 +--
 ssl/tls13_enc.c                                    |  26 +--
 test/acvp_test.c                                   |   2 +-
 test/aesgcmtest.c                                  |   4 +-
 test/bad_dtls_test.c                               |   2 +-
 test/defltfips_test.c                              |   3 +-
 test/drbgtest.c                                    |   2 +-
 test/ecdsatest.c                                   |   2 +-
 test/endecoder_legacy_test.c                       |   2 +-
 test/enginetest.c                                  |   2 +-
 test/evp_extra_test.c                              |  14 +-
 test/evp_extra_test2.c                             |   2 +-
 test/evp_fetch_prov_test.c                         |   4 +-
 test/evp_kdf_test.c                                |   4 +-
 test/evp_libctx_test.c                             |  18 +-
 test/evp_pkey_provided_test.c                      |  36 +--
 test/evp_test.c                                    |  41 ++--
 test/helpers/handshake.c                           |   2 +-
 test/provider_fallback_test.c                      |   4 +-
 test/provider_internal_test.c                      |   2 +-
 test/ssl_old_test.c                                |   6 +-
 test/sslapitest.c                                  |   2 +-
 test/tls13encryptiontest.c                         |   2 +-
 test/tls13secretstest.c                            |   2 +-
 util/libcrypto.num                                 | 174 +++++++--------
 util/missingcrypto.txt                             |   2 -
 util/other.syms                                    |  43 +++-
 265 files changed, 2082 insertions(+), 1815 deletions(-)
 rename doc/man3/{EVP_PKEY_size.pod =&gt; EVP_PKEY_get_size.pod} (62%)

diff --git a/CHANGES.md b/CHANGES.md
index 203deac7f2..0eb7f14289 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -104,6 +104,13 @@ breaking changes, and mappings for the large list of deprecated functions.
 
    *Shane Lontis*
 
+ * Many functions in the EVP_ namespace that are getters of values from
+   implementations or contexts were renamed to include get or get0 in their
+   names. Old names are provided as macro aliases for compatibility and
+   are not deprecated.
+
+   *Tom&#225;&#353; Mr&#225;z*
+
  * The EVP_PKEY_CTRL_PKCS7_ENCRYPT, EVP_PKEY_CTRL_PKCS7_DECRYPT,
    EVP_PKEY_CTRL_PKCS7_SIGN, EVP_PKEY_CTRL_CMS_ENCRYPT,
    EVP_PKEY_CTRL_CMS_DECRYPT, and EVP_PKEY_CTRL_CMS_SIGN control operations
@@ -641,8 +648,8 @@ breaking changes, and mappings for the large list of deprecated functions.
 
    *Richard Levitte*
 
- * Enhanced the documentation of EVP_PKEY_size(), EVP_PKEY_bits()
-   and EVP_PKEY_security_bits().  Especially EVP_PKEY_size() needed
+ * Enhanced the documentation of EVP_PKEY_get_size(), EVP_PKEY_get_bits()
+   and EVP_PKEY_get_security_bits().  Especially EVP_PKEY_get_size() needed
    a new formulation to include all the things it can be used for,
    as well as words of caution.
 
diff --git a/apps/cms.c b/apps/cms.c
index da00ece93b..81112c5a38 100644
--- a/apps/cms.c
+++ b/apps/cms.c
@@ -1013,7 +1013,7 @@ int cms_main(int argc, char **argv)
 
             res = EVP_PKEY_CTX_ctrl(pctx, -1, -1,
                                     EVP_PKEY_CTRL_CIPHER,
-                                    EVP_CIPHER_nid(cipher), NULL);
+                                    EVP_CIPHER_get_nid(cipher), NULL);
             if (res &lt;= 0 &amp;&amp; res != -2)
                 goto end;
 
diff --git a/apps/crl.c b/apps/crl.c
index 8904cc08c7..ff7c314717 100644
--- a/apps/crl.c
+++ b/apps/crl.c
@@ -347,7 +347,8 @@ int crl_main(int argc, char **argv)
                     BIO_printf(bio_err, &quot;out of memory\n&quot;);
                     goto end;
                 }
-                BIO_printf(bio_out, &quot;%s Fingerprint=&quot;, EVP_MD_name(digest));
+                BIO_printf(bio_out, &quot;%s Fingerprint=&quot;,
+                           EVP_MD_get0_name(digest));
                 for (j = 0; j &lt; (int)n; j++) {
                     BIO_printf(bio_out, &quot;%02X%c&quot;, md[j], (j + 1 == (int)n)
                                ? '\n' : ':');
diff --git a/apps/dgst.c b/apps/dgst.c
index e39d645cb8..36a8c6fb08 100644
--- a/apps/dgst.c
+++ b/apps/dgst.c
@@ -287,7 +287,7 @@ int dgst_main(int argc, char **argv)
              */
             goto end;
         }
-        type = EVP_PKEY_id(sigkey);
+        type = EVP_PKEY_get_id(sigkey);
         if (type == EVP_PKEY_ED25519 || type == EVP_PKEY_ED448) {
             /*
              * We implement PureEdDSA for these which doesn't have a separate
@@ -381,7 +381,7 @@ int dgst_main(int argc, char **argv)
             BIO_printf(bio_err, &quot;Error opening signature file %s\n&quot;, sigfile);
             goto end;
         }
-        siglen = EVP_PKEY_size(sigkey);
+        siglen = EVP_PKEY_get_size(sigkey);
         sigbuf = app_malloc(siglen, &quot;signature buffer&quot;);
         siglen = BIO_read(sigbio, sigbuf, siglen);
         BIO_free(sigbio);
@@ -399,10 +399,10 @@ int dgst_main(int argc, char **argv)
         md = EVP_MD_CTX_get1_md(tctx);
     }
     if (md != NULL)
-        md_name = EVP_MD_name(md);
+        md_name = EVP_MD_get0_name(md);
 
     if (xoflen &gt; 0) {
-        if (!(EVP_MD_flags(md) &amp; EVP_MD_FLAG_XOF)) {
+        if (!(EVP_MD_get_flags(md) &amp; EVP_MD_FLAG_XOF)) {
             BIO_printf(bio_err, &quot;Length can only be specified for XOF\n&quot;);
             goto end;
         }
diff --git a/apps/dsa.c b/apps/dsa.c
index abb422132a..51c0284353 100644
--- a/apps/dsa.c
+++ b/apps/dsa.c
@@ -269,7 +269,7 @@ int dsa_main(int argc, char **argv)
 
     /* Passphrase setup */
     if (enc != NULL)
-        OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_name(enc), NULL);
+        OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_get0_name(enc), NULL);
 
     /* Default passphrase prompter */
     if (enc != NULL || outformat == FORMAT_PVK) {
diff --git a/apps/ec.c b/apps/ec.c
index 3a7f505474..dcbef104ee 100644
--- a/apps/ec.c
+++ b/apps/ec.c
@@ -260,7 +260,7 @@ int ec_main(int argc, char **argv)
                                              output_type, output_structure,
                                              NULL);
         if (enc != NULL) {
-            OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_name(enc), NULL);
+            OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_get0_name(enc), NULL);
             /* Default passphrase prompter */
             OSSL_ENCODER_CTX_set_passphrase_ui(ectx, get_ui_method(), NULL);
             if (passout != NULL)
diff --git a/apps/enc.c b/apps/enc.c
index cda0022ebb..f136c3f8df 100644
--- a/apps/enc.c
+++ b/apps/enc.c
@@ -300,11 +300,11 @@ int enc_main(int argc, char **argv)
         if (!opt_cipher(ciphername, &amp;cipher))
             goto opthelp;
     }
-    if (cipher &amp;&amp; EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) {
+    if (cipher &amp;&amp; EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) {
         BIO_printf(bio_err, &quot;%s: AEAD ciphers not supported\n&quot;, prog);
         goto end;
     }
-    if (cipher &amp;&amp; (EVP_CIPHER_mode(cipher) == EVP_CIPH_XTS_MODE)) {
+    if (cipher &amp;&amp; (EVP_CIPHER_get_mode(cipher) == EVP_CIPH_XTS_MODE)) {
         BIO_printf(bio_err, &quot;%s XTS ciphers not supported\n&quot;, prog);
         goto end;
     }
@@ -360,7 +360,7 @@ int enc_main(int argc, char **argv)
                 char prompt[200];
 
                 BIO_snprintf(prompt, sizeof(prompt), &quot;enter %s %s password:&quot;,
-                        EVP_CIPHER_name(cipher),
+                        EVP_CIPHER_get0_name(cipher),
                         (enc) ? &quot;encryption&quot; : &quot;decryption&quot;);
                 strbuf[0] = '\0';
                 i = EVP_read_pw_string((char *)strbuf, SIZE, prompt, enc);
@@ -492,8 +492,8 @@ int enc_main(int argc, char **argv)
                 * concatenated into a temporary buffer
                 */
                 unsigned char tmpkeyiv[EVP_MAX_KEY_LENGTH + EVP_MAX_IV_LENGTH];
-                int iklen = EVP_CIPHER_key_length(cipher);
-                int ivlen = EVP_CIPHER_iv_length(cipher);
+                int iklen = EVP_CIPHER_get_key_length(cipher);
+                int ivlen = EVP_CIPHER_get_iv_length(cipher);
                 /* not needed if HASH_UPDATE() is fixed : */
                 int islen = (sptr != NULL ? sizeof(salt) : 0);
                 if (!PKCS5_PBKDF2_HMAC(str, str_len, sptr, islen,
@@ -525,7 +525,7 @@ int enc_main(int argc, char **argv)
                 OPENSSL_cleanse(str, str_len);
         }
         if (hiv != NULL) {
-            int siz = EVP_CIPHER_iv_length(cipher);
+            int siz = EVP_CIPHER_get_iv_length(cipher);
             if (siz == 0) {
                 BIO_printf(bio_err, &quot;warning: iv not used by this cipher\n&quot;);
             } else if (!set_hex(hiv, iv, siz)) {
@@ -534,7 +534,7 @@ int enc_main(int argc, char **argv)
             }
         }
         if ((hiv == NULL) &amp;&amp; (str == NULL)
-            &amp;&amp; EVP_CIPHER_iv_length(cipher) != 0) {
+            &amp;&amp; EVP_CIPHER_get_iv_length(cipher) != 0) {
             /*
              * No IV was explicitly set and no IV was generated.
              * Hence the IV is undefined, making correct decryption impossible.
@@ -543,7 +543,7 @@ int enc_main(int argc, char **argv)
             goto end;
         }
         if (hkey != NULL) {
-            if (!set_hex(hkey, key, EVP_CIPHER_key_length(cipher))) {
+            if (!set_hex(hkey, key, EVP_CIPHER_get_key_length(cipher))) {
                 BIO_printf(bio_err, &quot;invalid hex key value\n&quot;);
                 goto end;
             }
@@ -563,7 +563,7 @@ int enc_main(int argc, char **argv)
 
         if (!EVP_CipherInit_ex(ctx, cipher, e, NULL, NULL, enc)) {
             BIO_printf(bio_err, &quot;Error setting cipher %s\n&quot;,
-                       EVP_CIPHER_name(cipher));
+                       EVP_CIPHER_get0_name(cipher));
             ERR_print_errors(bio_err);
             goto end;
         }
@@ -573,7 +573,7 @@ int enc_main(int argc, char **argv)
 
         if (!EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, enc)) {
             BIO_printf(bio_err, &quot;Error setting cipher %s\n&quot;,
-                       EVP_CIPHER_name(cipher));
+                       EVP_CIPHER_get0_name(cipher));
             ERR_print_errors(bio_err);
             goto end;
         }
@@ -590,15 +590,15 @@ int enc_main(int argc, char **argv)
                     printf(&quot;%02X&quot;, salt[i]);
                 printf(&quot;\n&quot;);
             }
-            if (EVP_CIPHER_key_length(cipher) &gt; 0) {
+            if (EVP_CIPHER_get_key_length(cipher) &gt; 0) {
                 printf(&quot;key=&quot;);
-                for (i = 0; i &lt; EVP_CIPHER_key_length(cipher); i++)
+                for (i = 0; i &lt; EVP_CIPHER_get_key_length(cipher); i++)
                     printf(&quot;%02X&quot;, key[i]);
                 printf(&quot;\n&quot;);
             }
-            if (EVP_CIPHER_iv_length(cipher) &gt; 0) {
+            if (EVP_CIPHER_get_iv_length(cipher) &gt; 0) {
                 printf(&quot;iv =&quot;);
-                for (i = 0; i &lt; EVP_CIPHER_iv_length(cipher); i++)
+                for (i = 0; i &lt; EVP_CIPHER_get_iv_length(cipher); i++)
                     printf(&quot;%02X&quot;, iv[i]);
                 printf(&quot;\n&quot;);
             }
@@ -661,8 +661,8 @@ static void show_ciphers(const OBJ_NAME *name, void *arg)
     /* Filter out ciphers that we cannot use */
     cipher = EVP_get_cipherbyname(name-&gt;name);
     if (cipher == NULL ||
-            (EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) != 0 ||
-            EVP_CIPHER_mode(cipher) == EVP_CIPH_XTS_MODE)
+            (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) != 0 ||
+            EVP_CIPHER_get_mode(cipher) == EVP_CIPH_XTS_MODE)
         return;
 
     BIO_printf(dec-&gt;bio, &quot;-%-25s&quot;, name-&gt;name);
diff --git a/apps/gendsa.c b/apps/gendsa.c
index a7857c478c..e5c9bc22ad 100644
--- a/apps/gendsa.c
+++ b/apps/gendsa.c
@@ -127,12 +127,12 @@ int gendsa_main(int argc, char **argv)
     if (out == NULL)
         goto end2;
 
-    nbits = EVP_PKEY_bits(pkey);
+    nbits = EVP_PKEY_get_bits(pkey);
     if (nbits &gt; OPENSSL_DSA_MAX_MODULUS_BITS)
         BIO_printf(bio_err,
                    &quot;Warning: It is not recommended to use more than %d bit for DSA keys.\n&quot;
                    &quot;         Your key size is %d! Larger key size may behave not as expected.\n&quot;,
-                   OPENSSL_DSA_MAX_MODULUS_BITS, EVP_PKEY_bits(pkey));
+                   OPENSSL_DSA_MAX_MODULUS_BITS, EVP_PKEY_get_bits(pkey));
 
     ctx = EVP_PKEY_CTX_new(pkey, NULL);
     if (ctx == NULL) {
diff --git a/apps/genpkey.c b/apps/genpkey.c
index 38b1100658..5cde41b98b 100644
--- a/apps/genpkey.c
+++ b/apps/genpkey.c
@@ -166,7 +166,7 @@ int genpkey_main(int argc, char **argv)
     if (ciphername != NULL) {
         if (!opt_cipher(ciphername, &amp;cipher) || do_param == 1)
             goto opthelp;
-        m = EVP_CIPHER_mode(cipher);
+        m = EVP_CIPHER_get_mode(cipher);
         if (m == EVP_CIPH_GCM_MODE || m == EVP_CIPH_CCM_MODE
                 || m == EVP_CIPH_XTS_MODE || m == EVP_CIPH_OCB_MODE) {
             BIO_printf(bio_err, &quot;%s: cipher mode not supported\n&quot;, prog);
diff --git a/apps/lib/s_cb.c b/apps/lib/s_cb.c
index ba883996ba..ef431c98ea 100644
--- a/apps/lib/s_cb.c
+++ b/apps/lib/s_cb.c
@@ -386,13 +386,13 @@ int ssl_print_tmp_key(BIO *out, SSL *s)
     if (!SSL_get_peer_tmp_key(s, &amp;key))
         return 1;
     BIO_puts(out, &quot;Server Temp Key: &quot;);
-    switch (EVP_PKEY_id(key)) {
+    switch (EVP_PKEY_get_id(key)) {
     case EVP_PKEY_RSA:
-        BIO_printf(out, &quot;RSA, %d bits\n&quot;, EVP_PKEY_bits(key));
+        BIO_printf(out, &quot;RSA, %d bits\n&quot;, EVP_PKEY_get_bits(key));
         break;
 
     case EVP_PKEY_DH:
-        BIO_printf(out, &quot;DH, %d bits\n&quot;, EVP_PKEY_bits(key));
+        BIO_printf(out, &quot;DH, %d bits\n&quot;, EVP_PKEY_get_bits(key));
         break;
 #ifndef OPENSSL_NO_EC
     case EVP_PKEY_EC:
@@ -403,13 +403,13 @@ int ssl_print_tmp_key(BIO *out, SSL *s)
             if (!EVP_PKEY_get_utf8_string_param(key, OSSL_PKEY_PARAM_GROUP_NAME,
                                                 name, sizeof(name), &amp;name_len))
                 strcpy(name, &quot;?&quot;);
-            BIO_printf(out, &quot;ECDH, %s, %d bits\n&quot;, name, EVP_PKEY_bits(key));
+            BIO_printf(out, &quot;ECDH, %s, %d bits\n&quot;, name, EVP_PKEY_get_bits(key));
         }
     break;
 #endif
     default:
-        BIO_printf(out, &quot;%s, %d bits\n&quot;, OBJ_nid2sn(EVP_PKEY_id(key)),
-                   EVP_PKEY_bits(key));
+        BIO_printf(out, &quot;%s, %d bits\n&quot;, OBJ_nid2sn(EVP_PKEY_get_id(key)),
+                   EVP_PKEY_get_bits(key));
     }
     EVP_PKEY_free(key);
     return 1;
@@ -1426,7 +1426,7 @@ static int security_callback_debug(const SSL *s, const SSL_CTX *ctx,
                 EVP_PKEY_asn1_get0_info(NULL, NULL, NULL, NULL,
                                         &amp;algname, EVP_PKEY_get0_asn1(pkey));
                 BIO_printf(sdb-&gt;out, &quot;%s, bits=%d&quot;,
-                           algname, EVP_PKEY_bits(pkey));
+                           algname, EVP_PKEY_get_bits(pkey));
             }
             break;
         }
diff --git a/apps/list.c b/apps/list.c
index 6ffc36b9e2..2b2676b2cd 100644
--- a/apps/list.c
+++ b/apps/list.c
@@ -36,7 +36,7 @@ static const char *select_name = NULL;
     {                                                           \
         TYPE *impl;                                             \
         const char *propq = app_get0_propq();                   \
-        const char *name = TYPE ## _name(alg);                  \
+        const char *name = TYPE ## _get0_name(alg);             \
                                                                 \
         ERR_set_mark();                                         \
         impl = TYPE ## _fetch(NULL, name, propq);               \
@@ -70,10 +70,10 @@ static void legacy_cipher_fn(const EVP_CIPHER *c,
 {
     if (select_name != NULL
         &amp;&amp; (c == NULL
-            || strcasecmp(select_name,  EVP_CIPHER_name(c)) != 0))
+            || strcasecmp(select_name,  EVP_CIPHER_get0_name(c)) != 0))
         return;
     if (c != NULL) {
-        BIO_printf(arg, &quot;  %s\n&quot;, EVP_CIPHER_name(c));
+        BIO_printf(arg, &quot;  %s\n&quot;, EVP_CIPHER_get0_name(c));
     } else {
         if (from == NULL)
             from = &quot;&lt;undefined&gt;&quot;;
@@ -88,11 +88,11 @@ DEFINE_STACK_OF(EVP_CIPHER)
 static int cipher_cmp(const EVP_CIPHER * const *a,
                       const EVP_CIPHER * const *b)
 {
-    int ret = EVP_CIPHER_number(*a) - EVP_CIPHER_number(*b);
+    int ret = EVP_CIPHER_get_number(*a) - EVP_CIPHER_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(EVP_CIPHER_provider(*a)),
-                     OSSL_PROVIDER_name(EVP_CIPHER_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(EVP_CIPHER_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(EVP_CIPHER_get0_provider(*b)));
 
     return ret;
 }
@@ -138,10 +138,10 @@ static void list_ciphers(void)
             print_names(bio_out, names);
 
             BIO_printf(bio_out, &quot; @ %s\n&quot;,
-                       OSSL_PROVIDER_name(EVP_CIPHER_provider(c)));
+                       OSSL_PROVIDER_get0_name(EVP_CIPHER_get0_provider(c)));
 
             if (verbose) {
-                const char *desc = EVP_CIPHER_description(c);
+                const char *desc = EVP_CIPHER_get0_description(c);
 
                 if (desc != NULL)
                     BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -163,7 +163,7 @@ static void legacy_md_fn(const EVP_MD *m,
                        const char *from, const char *to, void *arg)
 {
     if (m != NULL) {
-        BIO_printf(arg, &quot;  %s\n&quot;, EVP_MD_name(m));
+        BIO_printf(arg, &quot;  %s\n&quot;, EVP_MD_get0_name(m));
     } else {
         if (from == NULL)
             from = &quot;&lt;undefined&gt;&quot;;
@@ -177,11 +177,11 @@ static void legacy_md_fn(const EVP_MD *m,
 DEFINE_STACK_OF(EVP_MD)
 static int md_cmp(const EVP_MD * const *a, const EVP_MD * const *b)
 {
-    int ret = EVP_MD_number(*a) - EVP_MD_number(*b);
+    int ret = EVP_MD_get_number(*a) - EVP_MD_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(EVP_MD_provider(*a)),
-                     OSSL_PROVIDER_name(EVP_MD_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(EVP_MD_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(EVP_MD_get0_provider(*b)));
 
     return ret;
 }
@@ -226,10 +226,11 @@ static void list_digests(void)
             BIO_printf(bio_out, &quot;  &quot;);
             print_names(bio_out, names);
 
-            BIO_printf(bio_out, &quot; @ %s\n&quot;, OSSL_PROVIDER_name(EVP_MD_provider(m)));
+            BIO_printf(bio_out, &quot; @ %s\n&quot;,
+                       OSSL_PROVIDER_get0_name(EVP_MD_get0_provider(m)));
 
             if (verbose) {
-                const char *desc = EVP_MD_description(m);
+                const char *desc = EVP_MD_get0_description(m);
 
                 if (desc != NULL)
                     BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -249,11 +250,11 @@ static void list_digests(void)
 DEFINE_STACK_OF(EVP_MAC)
 static int mac_cmp(const EVP_MAC * const *a, const EVP_MAC * const *b)
 {
-    int ret = EVP_MAC_number(*a) - EVP_MAC_number(*b);
+    int ret = EVP_MAC_get_number(*a) - EVP_MAC_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(EVP_MAC_provider(*a)),
-                     OSSL_PROVIDER_name(EVP_MAC_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(EVP_MAC_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(EVP_MAC_get0_provider(*b)));
 
     return ret;
 }
@@ -291,10 +292,11 @@ static void list_macs(void)
             BIO_printf(bio_out, &quot;  &quot;);
             print_names(bio_out, names);
 
-            BIO_printf(bio_out, &quot; @ %s\n&quot;, OSSL_PROVIDER_name(EVP_MAC_provider(m)));
+            BIO_printf(bio_out, &quot; @ %s\n&quot;,
+                       OSSL_PROVIDER_get0_name(EVP_MAC_get0_provider(m)));
 
             if (verbose) {
-                const char *desc = EVP_MAC_description(m);
+                const char *desc = EVP_MAC_get0_description(m);
 
                 if (desc != NULL)
                     BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -317,11 +319,11 @@ static void list_macs(void)
 DEFINE_STACK_OF(EVP_KDF)
 static int kdf_cmp(const EVP_KDF * const *a, const EVP_KDF * const *b)
 {
-    int ret = EVP_KDF_number(*a) - EVP_KDF_number(*b);
+    int ret = EVP_KDF_get_number(*a) - EVP_KDF_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(EVP_KDF_provider(*a)),
-                     OSSL_PROVIDER_name(EVP_KDF_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(EVP_KDF_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(EVP_KDF_get0_provider(*b)));
 
     return ret;
 }
@@ -359,10 +361,11 @@ static void list_kdfs(void)
             BIO_printf(bio_out, &quot;  &quot;);
             print_names(bio_out, names);
 
-            BIO_printf(bio_out, &quot; @ %s\n&quot;, OSSL_PROVIDER_name(EVP_KDF_provider(k)));
+            BIO_printf(bio_out, &quot; @ %s\n&quot;,
+                       OSSL_PROVIDER_get0_name(EVP_KDF_get0_provider(k)));
 
             if (verbose) {
-                const char *desc = EVP_KDF_description(k);
+                const char *desc = EVP_KDF_get0_description(k);
 
                 if (desc != NULL)
                     BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -386,11 +389,11 @@ DEFINE_STACK_OF(EVP_RAND)
 
 static int rand_cmp(const EVP_RAND * const *a, const EVP_RAND * const *b)
 {
-    int ret = strcasecmp(EVP_RAND_name(*a), EVP_RAND_name(*b));
+    int ret = strcasecmp(EVP_RAND_get0_name(*a), EVP_RAND_get0_name(*b));
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(EVP_RAND_provider(*a)),
-                     OSSL_PROVIDER_name(EVP_RAND_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(EVP_RAND_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(EVP_RAND_get0_provider(*b)));
 
     return ret;
 }
@@ -420,13 +423,14 @@ static void list_random_generators(void)
         const EVP_RAND *m = sk_EVP_RAND_value(rands, i);
 
         if (select_name != NULL
-            &amp;&amp; strcasecmp(EVP_RAND_name(m), select_name) != 0)
+            &amp;&amp; strcasecmp(EVP_RAND_get0_name(m), select_name) != 0)
             continue;
-        BIO_printf(bio_out, &quot;  %s&quot;, EVP_RAND_name(m));
-        BIO_printf(bio_out, &quot; @ %s\n&quot;, OSSL_PROVIDER_name(EVP_RAND_provider(m)));
+        BIO_printf(bio_out, &quot;  %s&quot;, EVP_RAND_get0_name(m));
+        BIO_printf(bio_out, &quot; @ %s\n&quot;,
+                   OSSL_PROVIDER_get0_name(EVP_RAND_get0_provider(m)));
 
         if (verbose) {
-            const char *desc = EVP_RAND_description(m);
+            const char *desc = EVP_RAND_get0_description(m);
 
             if (desc != NULL)
                 BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -452,13 +456,13 @@ static void display_random(const char *name, EVP_RAND_CTX *drbg)
 
     BIO_printf(bio_out, &quot;%s:\n&quot;, name);
     if (drbg != NULL) {
-        rand = EVP_RAND_CTX_rand(drbg);
+        rand = EVP_RAND_CTX_get0_rand(drbg);
 
-        BIO_printf(bio_out, &quot;  %s&quot;, EVP_RAND_name(rand));
+        BIO_printf(bio_out, &quot;  %s&quot;, EVP_RAND_get0_name(rand));
         BIO_printf(bio_out, &quot; @ %s\n&quot;,
-                   OSSL_PROVIDER_name(EVP_RAND_provider(rand)));
+                   OSSL_PROVIDER_get0_name(EVP_RAND_get0_provider(rand)));
 
-        switch (EVP_RAND_state(drbg)) {
+        switch (EVP_RAND_get_state(drbg)) {
         case EVP_RAND_STATE_UNINITIALISED:
             p = &quot;uninitialised&quot;;
             break;
@@ -516,11 +520,11 @@ DEFINE_STACK_OF(OSSL_ENCODER)
 static int encoder_cmp(const OSSL_ENCODER * const *a,
                        const OSSL_ENCODER * const *b)
 {
-    int ret = OSSL_ENCODER_number(*a) - OSSL_ENCODER_number(*b);
+    int ret = OSSL_ENCODER_get_number(*a) - OSSL_ENCODER_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(OSSL_ENCODER_provider(*a)),
-                     OSSL_PROVIDER_name(OSSL_ENCODER_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(OSSL_ENCODER_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(OSSL_ENCODER_get0_provider(*b)));
     return ret;
 }
 
@@ -560,11 +564,11 @@ static void list_encoders(void)
             print_names(bio_out, names);
 
             BIO_printf(bio_out, &quot; @ %s (%s)\n&quot;,
-                    OSSL_PROVIDER_name(OSSL_ENCODER_provider(k)),
-                    OSSL_ENCODER_properties(k));
+                    OSSL_PROVIDER_get0_name(OSSL_ENCODER_get0_provider(k)),
+                    OSSL_ENCODER_get0_properties(k));
 
             if (verbose) {
-                const char *desc = OSSL_ENCODER_description(k);
+                const char *desc = OSSL_ENCODER_get0_description(k);
 
                 if (desc != NULL)
                     BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -584,11 +588,11 @@ DEFINE_STACK_OF(OSSL_DECODER)
 static int decoder_cmp(const OSSL_DECODER * const *a,
                        const OSSL_DECODER * const *b)
 {
-    int ret = OSSL_DECODER_number(*a) - OSSL_DECODER_number(*b);
+    int ret = OSSL_DECODER_get_number(*a) - OSSL_DECODER_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(OSSL_DECODER_provider(*a)),
-                     OSSL_PROVIDER_name(OSSL_DECODER_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(OSSL_DECODER_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(OSSL_DECODER_get0_provider(*b)));
     return ret;
 }
 
@@ -629,11 +633,11 @@ static void list_decoders(void)
             print_names(bio_out, names);
 
             BIO_printf(bio_out, &quot; @ %s (%s)\n&quot;,
-                    OSSL_PROVIDER_name(OSSL_DECODER_provider(k)),
-                    OSSL_DECODER_properties(k));
+                       OSSL_PROVIDER_get0_name(OSSL_DECODER_get0_provider(k)),
+                       OSSL_DECODER_get0_properties(k));
 
             if (verbose) {
-                const char *desc = OSSL_DECODER_description(k);
+                const char *desc = OSSL_DECODER_get0_description(k);
 
                 if (desc != NULL)
                     BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -650,11 +654,11 @@ DEFINE_STACK_OF(EVP_KEYMGMT)
 static int keymanager_cmp(const EVP_KEYMGMT * const *a,
                           const EVP_KEYMGMT * const *b)
 {
-    int ret = EVP_KEYMGMT_number(*a) - EVP_KEYMGMT_number(*b);
+    int ret = EVP_KEYMGMT_get_number(*a) - EVP_KEYMGMT_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(EVP_KEYMGMT_provider(*a)),
-                     OSSL_PROVIDER_name(EVP_KEYMGMT_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(EVP_KEYMGMT_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(EVP_KEYMGMT_get0_provider(*b)));
     return ret;
 }
 
@@ -684,7 +688,7 @@ static void list_keymanagers(void)
 
         names = sk_OPENSSL_CSTRING_new(name_cmp);
         if (names != NULL &amp;&amp; EVP_KEYMGMT_names_do_all(k, collect_names, names)) {
-            const char *desc = EVP_KEYMGMT_description(k);
+            const char *desc = EVP_KEYMGMT_get0_description(k);
 
             BIO_printf(bio_out, &quot;  Name: &quot;);
             if (desc != NULL)
@@ -696,7 +700,7 @@ static void list_keymanagers(void)
             BIO_printf(bio_out, &quot;    IDs: &quot;);
             print_names(bio_out, names);
             BIO_printf(bio_out, &quot; @ %s\n&quot;,
-                    OSSL_PROVIDER_name(EVP_KEYMGMT_provider(k)));
+                    OSSL_PROVIDER_get0_name(EVP_KEYMGMT_get0_provider(k)));
 
             if (verbose) {
                 print_param_types(&quot;settable key generation parameters&quot;,
@@ -716,11 +720,11 @@ DEFINE_STACK_OF(EVP_SIGNATURE)
 static int signature_cmp(const EVP_SIGNATURE * const *a,
                          const EVP_SIGNATURE * const *b)
 {
-    int ret = EVP_SIGNATURE_number(*a) - EVP_SIGNATURE_number(*b);
+    int ret = EVP_SIGNATURE_get_number(*a) - EVP_SIGNATURE_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(EVP_SIGNATURE_provider(*a)),
-                     OSSL_PROVIDER_name(EVP_SIGNATURE_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(EVP_SIGNATURE_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(EVP_SIGNATURE_get0_provider(*b)));
     return ret;
 }
 
@@ -755,10 +759,10 @@ static void list_signatures(void)
             print_names(bio_out, names);
 
             BIO_printf(bio_out, &quot; @ %s\n&quot;,
-                    OSSL_PROVIDER_name(EVP_SIGNATURE_provider(k)));
+                    OSSL_PROVIDER_get0_name(EVP_SIGNATURE_get0_provider(k)));
 
             if (verbose) {
-                const char *desc = EVP_SIGNATURE_description(k);
+                const char *desc = EVP_SIGNATURE_get0_description(k);
 
                 if (desc != NULL)
                     BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -779,11 +783,11 @@ DEFINE_STACK_OF(EVP_KEM)
 static int kem_cmp(const EVP_KEM * const *a,
                    const EVP_KEM * const *b)
 {
-    int ret = EVP_KEM_number(*a) - EVP_KEM_number(*b);
+    int ret = EVP_KEM_get_number(*a) - EVP_KEM_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(EVP_KEM_provider(*a)),
-                     OSSL_PROVIDER_name(EVP_KEM_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(EVP_KEM_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(EVP_KEM_get0_provider(*b)));
     return ret;
 }
 
@@ -817,10 +821,11 @@ static void list_kems(void)
             BIO_printf(bio_out, &quot;  &quot;);
             print_names(bio_out, names);
 
-            BIO_printf(bio_out, &quot; @ %s\n&quot;, OSSL_PROVIDER_name(EVP_KEM_provider(k)));
+            BIO_printf(bio_out, &quot; @ %s\n&quot;,
+                       OSSL_PROVIDER_get0_name(EVP_KEM_get0_provider(k)));
 
             if (verbose) {
-                const char *desc = EVP_KEM_description(k);
+                const char *desc = EVP_KEM_get0_description(k);
 
                 if (desc != NULL)
                     BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -841,11 +846,11 @@ DEFINE_STACK_OF(EVP_ASYM_CIPHER)
 static int asymcipher_cmp(const EVP_ASYM_CIPHER * const *a,
                           const EVP_ASYM_CIPHER * const *b)
 {
-    int ret = EVP_ASYM_CIPHER_number(*a) - EVP_ASYM_CIPHER_number(*b);
+    int ret = EVP_ASYM_CIPHER_get_number(*a) - EVP_ASYM_CIPHER_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(EVP_ASYM_CIPHER_provider(*a)),
-                     OSSL_PROVIDER_name(EVP_ASYM_CIPHER_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(EVP_ASYM_CIPHER_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(EVP_ASYM_CIPHER_get0_provider(*b)));
     return ret;
 }
 
@@ -882,10 +887,10 @@ static void list_asymciphers(void)
             print_names(bio_out, names);
 
             BIO_printf(bio_out, &quot; @ %s\n&quot;,
-                    OSSL_PROVIDER_name(EVP_ASYM_CIPHER_provider(k)));
+                    OSSL_PROVIDER_get0_name(EVP_ASYM_CIPHER_get0_provider(k)));
 
             if (verbose) {
-                const char *desc = EVP_ASYM_CIPHER_description(k);
+                const char *desc = EVP_ASYM_CIPHER_get0_description(k);
 
                 if (desc != NULL)
                     BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -906,11 +911,11 @@ DEFINE_STACK_OF(EVP_KEYEXCH)
 static int kex_cmp(const EVP_KEYEXCH * const *a,
                    const EVP_KEYEXCH * const *b)
 {
-    int ret = EVP_KEYEXCH_number(*a) - EVP_KEYEXCH_number(*b);
+    int ret = EVP_KEYEXCH_get_number(*a) - EVP_KEYEXCH_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(EVP_KEYEXCH_provider(*a)),
-                     OSSL_PROVIDER_name(EVP_KEYEXCH_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(EVP_KEYEXCH_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(EVP_KEYEXCH_get0_provider(*b)));
     return ret;
 }
 
@@ -945,10 +950,10 @@ static void list_keyexchanges(void)
             print_names(bio_out, names);
 
             BIO_printf(bio_out, &quot; @ %s\n&quot;,
-                    OSSL_PROVIDER_name(EVP_KEYEXCH_provider(k)));
+                    OSSL_PROVIDER_get0_name(EVP_KEYEXCH_get0_provider(k)));
 
             if (verbose) {
-                const char *desc = EVP_KEYEXCH_description(k);
+                const char *desc = EVP_KEYEXCH_get0_description(k);
 
                 if (desc != NULL)
                     BIO_printf(bio_out, &quot;    description: %s\n&quot;, desc);
@@ -1191,11 +1196,11 @@ DEFINE_STACK_OF(OSSL_STORE_LOADER)
 static int store_cmp(const OSSL_STORE_LOADER * const *a,
                      const OSSL_STORE_LOADER * const *b)
 {
-    int ret = OSSL_STORE_LOADER_number(*a) - OSSL_STORE_LOADER_number(*b);
+    int ret = OSSL_STORE_LOADER_get_number(*a) - OSSL_STORE_LOADER_get_number(*b);
 
     if (ret == 0)
-        ret = strcmp(OSSL_PROVIDER_name(OSSL_STORE_LOADER_provider(*a)),
-                     OSSL_PROVIDER_name(OSSL_STORE_LOADER_provider(*b)));
+        ret = strcmp(OSSL_PROVIDER_get0_name(OSSL_STORE_LOADER_get0_provider(*a)),
+                     OSSL_PROVIDER_get0_name(OSSL_STORE_LOADER_get0_provider(*b)));
 
     return ret;
 }
@@ -1234,7 +1239,7 @@ static void list_store_loaders(void)
             print_names(bio_out, names);
 
             BIO_printf(bio_out, &quot; @ %s\n&quot;,
-                       OSSL_PROVIDER_name(OSSL_STORE_LOADER_provider(m)));
+                       OSSL_PROVIDER_get0_name(OSSL_STORE_LOADER_get0_provider(m)));
         }
         sk_OPENSSL_CSTRING_free(names);
     }
@@ -1245,7 +1250,7 @@ DEFINE_STACK_OF(OSSL_PROVIDER)
 static int provider_cmp(const OSSL_PROVIDER * const *a,
                         const OSSL_PROVIDER * const *b)
 {
-    return strcmp(OSSL_PROVIDER_name(*a), OSSL_PROVIDER_name(*b));
+    return strcmp(OSSL_PROVIDER_get0_name(*a), OSSL_PROVIDER_get0_name(*b));
 }
 
 static int collect_providers(OSSL_PROVIDER *provider, void *stack)
@@ -1290,7 +1295,7 @@ static void list_provider_info(void)
         }
 
         /* Print out the provider information, the params order matches above */
-        BIO_printf(bio_out, &quot;  %s\n&quot;, OSSL_PROVIDER_name(prov));
+        BIO_printf(bio_out, &quot;  %s\n&quot;, OSSL_PROVIDER_get0_name(prov));
         if (OSSL_PARAM_modified(params))
             BIO_printf(bio_out, &quot;    name: %s\n&quot;, name);
         if (OSSL_PARAM_modified(params + 1))
diff --git a/apps/pkeyutl.c b/apps/pkeyutl.c
index 0424e556c1..bf9db2fa5a 100644
--- a/apps/pkeyutl.c
+++ b/apps/pkeyutl.c
@@ -592,7 +592,7 @@ static EVP_PKEY_CTX *init_ctx(const char *kdfalg, int *pkeysize,
         if (pkey == NULL)
             goto end;
 
-        *pkeysize = EVP_PKEY_size(pkey);
+        *pkeysize = EVP_PKEY_get_size(pkey);
         if (impl != NULL)
             ctx = EVP_PKEY_CTX_new(pkey, impl);
         else
@@ -726,8 +726,8 @@ static int do_raw_keyop(int pkey_op, EVP_MD_CTX *mctx,
     int buf_len = 0;
 
     /* Some algorithms only support oneshot digests */
-    if (EVP_PKEY_id(pkey) == EVP_PKEY_ED25519
-            || EVP_PKEY_id(pkey) == EVP_PKEY_ED448) {
+    if (EVP_PKEY_get_id(pkey) == EVP_PKEY_ED25519
+            || EVP_PKEY_get_id(pkey) == EVP_PKEY_ED448) {
         if (filesize &lt; 0) {
             BIO_printf(bio_err,
                        &quot;Error: unable to determine file size for oneshot operation\n&quot;);
diff --git a/apps/rehash.c b/apps/rehash.c
index 65ccacc0a8..7fe01de11c 100644
--- a/apps/rehash.c
+++ b/apps/rehash.c
@@ -534,7 +534,7 @@ int rehash_main(int argc, char **argv)
     argv = opt_rest();
 
     evpmd = EVP_sha1();
-    evpmdsize = EVP_MD_size(evpmd);
+    evpmdsize = EVP_MD_get_size(evpmd);
 
     if (*argv != NULL) {
         while (*argv != NULL)
diff --git a/apps/req.c b/apps/req.c
index 3b0545fd6e..284d03f40d 100644
--- a/apps/req.c
+++ b/apps/req.c
@@ -1601,7 +1601,7 @@ static EVP_PKEY_CTX *set_keygen_ctx(const char *gstr,
         else
             gctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),
                                               param, app_get0_propq());
-        *pkeylen = EVP_PKEY_bits(param);
+        *pkeylen = EVP_PKEY_get_bits(param);
         EVP_PKEY_free(param);
     } else {
         if (keygen_engine != NULL) {
diff --git a/apps/rsa.c b/apps/rsa.c
index 83fd8350df..5710893c7a 100644
--- a/apps/rsa.c
+++ b/apps/rsa.c
@@ -337,7 +337,7 @@ int rsa_main(int argc, char **argv)
 
     /* Passphrase setup */
     if (enc != NULL)
-        OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_name(enc), NULL);
+        OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_get0_name(enc), NULL);
 
     /* Default passphrase prompter */
     if (enc != NULL || outformat == FORMAT_PVK) {
diff --git a/apps/rsautl.c b/apps/rsautl.c
index c2bc1af89b..ae0206014d 100644
--- a/apps/rsautl.c
+++ b/apps/rsautl.c
@@ -214,7 +214,7 @@ int rsautl_main(int argc, char **argv)
     if (out == NULL)
         goto end;
 
-    keysize = EVP_PKEY_size(pkey);
+    keysize = EVP_PKEY_get_size(pkey);
 
     rsa_in = app_malloc(keysize * 2, &quot;hold rsa key&quot;);
     rsa_out = app_malloc(keysize, &quot;output rsa key&quot;);
diff --git a/apps/s_client.c b/apps/s_client.c
index 85789eed23..2b8f274433 100644
--- a/apps/s_client.c
+++ b/apps/s_client.c
@@ -3099,8 +3099,8 @@ static void print_stuff(BIO *bio, SSL *s, int full)
                 public_key = X509_get_pubkey(sk_X509_value(sk, i));
                 if (public_key != NULL) {
                     BIO_printf(bio, &quot;   a:PKEY: %s, %d (bit); sigalg: %s\n&quot;,
-                               OBJ_nid2sn(EVP_PKEY_base_id(public_key)),
-                               EVP_PKEY_bits(public_key),
+                               OBJ_nid2sn(EVP_PKEY_get_base_id(public_key)),
+                               EVP_PKEY_get_bits(public_key),
                                OBJ_nid2sn(X509_get_signature_nid(sk_X509_value(sk, i))));
                     EVP_PKEY_free(public_key);
                 }
@@ -3180,7 +3180,7 @@ static void print_stuff(BIO *bio, SSL *s, int full)
 
         pktmp = X509_get0_pubkey(peer);
         BIO_printf(bio, &quot;Server public key is %d bit\n&quot;,
-                   EVP_PKEY_bits(pktmp));
+                   EVP_PKEY_get_bits(pktmp));
     }
     BIO_printf(bio, &quot;Secure Renegotiation IS%s supported\n&quot;,
                SSL_get_secure_renegotiation_support(s) ? &quot;&quot; : &quot; NOT&quot;);
diff --git a/apps/speed.c b/apps/speed.c
index 0892b60369..6822b83db6 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -1038,7 +1038,7 @@ static int SM2_sign_loop(void *args)
     size_t sm2sigsize;
     int ret, count;
     EVP_PKEY **sm2_pkey = tempargs-&gt;sm2_pkey;
-    const size_t max_size = EVP_PKEY_size(sm2_pkey[testnum]);
+    const size_t max_size = EVP_PKEY_get_size(sm2_pkey[testnum]);
 
     for (count = 0; COND(sm2_c[testnum][0]); count++) {
         sm2sigsize = max_size;
@@ -1715,10 +1715,10 @@ int speed_main(int argc, char **argv)
         if (evp_cipher == NULL) {
             BIO_printf(bio_err, &quot;-aead can be used only with an AEAD cipher\n&quot;);
             goto end;
-        } else if (!(EVP_CIPHER_flags(evp_cipher) &amp;
+        } else if (!(EVP_CIPHER_get_flags(evp_cipher) &amp;
                      EVP_CIPH_FLAG_AEAD_CIPHER)) {
             BIO_printf(bio_err, &quot;%s is not an AEAD cipher\n&quot;,
-                       EVP_CIPHER_name(evp_cipher));
+                       EVP_CIPHER_get0_name(evp_cipher));
             goto end;
         }
     }
@@ -1727,10 +1727,10 @@ int speed_main(int argc, char **argv)
             BIO_printf(bio_err, &quot;-mb can be used only with a multi-block&quot;
                                 &quot; capable cipher\n&quot;);
             goto end;
-        } else if (!(EVP_CIPHER_flags(evp_cipher) &amp;
+        } else if (!(EVP_CIPHER_get_flags(evp_cipher) &amp;
                      EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) {
             BIO_printf(bio_err, &quot;%s is not a multi-block capable\n&quot;,
-                       EVP_CIPHER_name(evp_cipher));
+                       EVP_CIPHER_get0_name(evp_cipher));
             goto end;
         } else if (async_jobs &gt; 0) {
             BIO_printf(bio_err, &quot;Async mode is not supported with -mb&quot;);
@@ -2172,18 +2172,18 @@ int speed_main(int argc, char **argv)
         if (evp_cipher != NULL) {
             int (*loopfunc) (void *) = EVP_Update_loop;
 
-            if (multiblock &amp;&amp; (EVP_CIPHER_flags(evp_cipher) &amp;
+            if (multiblock &amp;&amp; (EVP_CIPHER_get_flags(evp_cipher) &amp;
                                EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) {
                 multiblock_speed(evp_cipher, lengths_single, &amp;seconds);
                 ret = 0;
                 goto end;
             }
 
-            names[D_EVP] = EVP_CIPHER_name(evp_cipher);
+            names[D_EVP] = EVP_CIPHER_get0_name(evp_cipher);
 
-            if (EVP_CIPHER_mode(evp_cipher) == EVP_CIPH_CCM_MODE) {
+            if (EVP_CIPHER_get_mode(evp_cipher) == EVP_CIPH_CCM_MODE) {
                 loopfunc = EVP_Update_loop_ccm;
-            } else if (aead &amp;&amp; (EVP_CIPHER_flags(evp_cipher) &amp;
+            } else if (aead &amp;&amp; (EVP_CIPHER_get_flags(evp_cipher) &amp;
                                 EVP_CIPH_FLAG_AEAD_CIPHER)) {
                 loopfunc = EVP_Update_loop_aead;
                 if (lengths == lengths_list) {
@@ -2211,7 +2211,7 @@ int speed_main(int argc, char **argv)
 
                     EVP_CIPHER_CTX_set_padding(loopargs[k].ctx, 0);
 
-                    keylen = EVP_CIPHER_CTX_key_length(loopargs[k].ctx);
+                    keylen = EVP_CIPHER_CTX_get_key_length(loopargs[k].ctx);
                     loopargs[k].key = app_malloc(keylen, &quot;evp_cipher key&quot;);
                     EVP_CIPHER_CTX_rand_key(loopargs[k].ctx, loopargs[k].key);
                     if (!EVP_CipherInit_ex(loopargs[k].ctx, NULL, NULL,
@@ -2223,7 +2223,7 @@ int speed_main(int argc, char **argv)
                     OPENSSL_clear_free(loopargs[k].key, keylen);
 
                     /* SIV mode only allows for a single Update operation */
-                    if (EVP_CIPHER_mode(evp_cipher) == EVP_CIPH_SIV_MODE)
+                    if (EVP_CIPHER_get_mode(evp_cipher) == EVP_CIPH_SIV_MODE)
                         EVP_CIPHER_CTX_ctrl(loopargs[k].ctx, EVP_CTRL_SET_SPEED,
                                             1, NULL);
                 }
@@ -2261,7 +2261,7 @@ int speed_main(int argc, char **argv)
         if (!opt_cipher(evp_mac_ciphername, &amp;cipher))
             goto end;
 
-        keylen = EVP_CIPHER_key_length(cipher);
+        keylen = EVP_CIPHER_get_key_length(cipher);
         EVP_CIPHER_free(cipher);
         if (keylen &lt;= 0 || keylen &gt; (int)sizeof(key32)) {
             BIO_printf(bio_err, &quot;\nRequested CMAC cipher with unsupported key length.\n&quot;);
@@ -2795,7 +2795,7 @@ int speed_main(int argc, char **argv)
             st = 0; /* set back to zero */
             /* attach it sooner to rely on main final cleanup */
             loopargs[i].sm2_pkey[testnum] = sm2_pkey;
-            loopargs[i].sigsize = EVP_PKEY_size(sm2_pkey);
+            loopargs[i].sigsize = EVP_PKEY_get_size(sm2_pkey);
 
             sm2_pctx = EVP_PKEY_CTX_new(sm2_pkey, NULL);
             sm2_vfy_pctx = EVP_PKEY_CTX_new(sm2_pkey, NULL);
@@ -3290,12 +3290,12 @@ int speed_main(int argc, char **argv)
 
             /* free signing ctx */
             if (loopargs[i].sm2_ctx[k] != NULL
-                    &amp;&amp; (pctx = EVP_MD_CTX_pkey_ctx(loopargs[i].sm2_ctx[k])) != NULL)
+                &amp;&amp; (pctx = EVP_MD_CTX_get_pkey_ctx(loopargs[i].sm2_ctx[k])) != NULL)
                 EVP_PKEY_CTX_free(pctx);
             EVP_MD_CTX_free(loopargs[i].sm2_ctx[k]);
             /* free verification ctx */
             if (loopargs[i].sm2_vfy_ctx[k] != NULL
-                    &amp;&amp; (pctx = EVP_MD_CTX_pkey_ctx(loopargs[i].sm2_vfy_ctx[k])) != NULL)
+                &amp;&amp; (pctx = EVP_MD_CTX_get_pkey_ctx(loopargs[i].sm2_vfy_ctx[k])) != NULL)
                 EVP_PKEY_CTX_free(pctx);
             EVP_MD_CTX_free(loopargs[i].sm2_vfy_ctx[k]);
             /* free pkey */
@@ -3575,7 +3575,7 @@ static void multiblock_speed(const EVP_CIPHER *evp_cipher, int lengths_single,
     if (!EVP_EncryptInit_ex(ctx, evp_cipher, NULL, NULL, no_iv))
         app_bail_out(&quot;failed to initialise cipher context\n&quot;);
 
-    if ((keylen = EVP_CIPHER_CTX_key_length(ctx)) &lt; 0) {
+    if ((keylen = EVP_CIPHER_CTX_get_key_length(ctx)) &lt; 0) {
         BIO_printf(bio_err, &quot;Impossible negative key length: %d\n&quot;, keylen);
         goto err;
     }
@@ -3589,7 +3589,7 @@ static void multiblock_speed(const EVP_CIPHER *evp_cipher, int lengths_single,
     if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_MAC_KEY,
                              sizeof(no_key), no_key))
         app_bail_out(&quot;failed to set AEAD key\n&quot;);
-    if ((alg_name = EVP_CIPHER_name(evp_cipher)) == NULL)
+    if ((alg_name = EVP_CIPHER_get0_name(evp_cipher)) == NULL)
         app_bail_out(&quot;failed to get cipher name\n&quot;);
 
     for (j = 0; j &lt; num; j++) {
diff --git a/apps/ts.c b/apps/ts.c
index db5ecb32c2..e65d223348 100644
--- a/apps/ts.c
+++ b/apps/ts.c
@@ -460,7 +460,7 @@ static TS_REQ *create_query(BIO *data_bio, const char *digest, const EVP_MD *md,
         goto err;
     if ((algo = X509_ALGOR_new()) == NULL)
         goto err;
-    if ((algo-&gt;algorithm = OBJ_nid2obj(EVP_MD_type(md))) == NULL)
+    if ((algo-&gt;algorithm = OBJ_nid2obj(EVP_MD_get_type(md))) == NULL)
         goto err;
     if ((algo-&gt;parameter = ASN1_TYPE_new()) == NULL)
         goto err;
@@ -509,7 +509,7 @@ static int create_digest(BIO *input, const char *digest, const EVP_MD *md,
     int rv = 0;
     EVP_MD_CTX *md_ctx = NULL;
 
-    md_value_len = EVP_MD_size(md);
+    md_value_len = EVP_MD_get_size(md);
     if (md_value_len &lt; 0)
         return 0;
 
@@ -529,7 +529,7 @@ static int create_digest(BIO *input, const char *digest, const EVP_MD *md,
         }
         if (!EVP_DigestFinal(md_ctx, *md_value, NULL))
             goto err;
-        md_value_len = EVP_MD_size(md);
+        md_value_len = EVP_MD_get_size(md);
     } else {
         long digest_len;
 
diff --git a/crypto/asn1/a_digest.c b/crypto/asn1/a_digest.c
index 9d7efcdb70..72cc880779 100644
--- a/crypto/asn1/a_digest.c
+++ b/crypto/asn1/a_digest.c
@@ -65,15 +65,15 @@ int ossl_asn1_item_digest_ex(const ASN1_ITEM *it, const EVP_MD *md, void *asn,
     if (i &lt; 0 || str == NULL)
         return 0;
 
-    if (EVP_MD_provider(md) == NULL) {
+    if (EVP_MD_get0_provider(md) == NULL) {
 #if !defined(OPENSSL_NO_ENGINE)
-        ENGINE *tmpeng = ENGINE_get_digest_engine(EVP_MD_type(md));
+        ENGINE *tmpeng = ENGINE_get_digest_engine(EVP_MD_get_type(md));
 
         if (tmpeng != NULL)
             ENGINE_finish(tmpeng);
         else
 #endif
-            fetched_md = EVP_MD_fetch(libctx, EVP_MD_name(md), propq);
+            fetched_md = EVP_MD_fetch(libctx, EVP_MD_get0_name(md), propq);
     }
     if (fetched_md == NULL)
         goto err;
diff --git a/crypto/asn1/a_sign.c b/crypto/asn1/a_sign.c
index 6ead2e2aca..302045cfcd 100644
--- a/crypto/asn1/a_sign.c
+++ b/crypto/asn1/a_sign.c
@@ -78,7 +78,7 @@ int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1, X509_ALGOR *algor2,
     }
     inll = (size_t)inl;
     buf_in = OPENSSL_malloc(inll);
-    outll = outl = EVP_PKEY_size(pkey);
+    outll = outl = EVP_PKEY_get_size(pkey);
     buf_out = OPENSSL_malloc(outll);
     if (buf_in == NULL || buf_out == NULL) {
         outl = 0;
@@ -143,7 +143,7 @@ int ASN1_item_sign_ex(const ASN1_ITEM *it, X509_ALGOR *algor1,
     rv = ASN1_item_sign_ctx(it, algor1, algor2, signature, data, ctx);
 
  err:
-    EVP_PKEY_CTX_free(EVP_MD_CTX_pkey_ctx(ctx));
+    EVP_PKEY_CTX_free(EVP_MD_CTX_get_pkey_ctx(ctx));
     EVP_MD_CTX_free(ctx);
     return rv;
 }
@@ -160,7 +160,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
     int rv, pkey_id;
 
     md = EVP_MD_CTX_get0_md(ctx);
-    pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_pkey_ctx(ctx));
+    pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_get_pkey_ctx(ctx));
 
     if (pkey == NULL) {
         ERR_raise(ERR_LIB_ASN1, ASN1_R_CONTEXT_NOT_INITIALISED);
@@ -168,7 +168,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
     }
 
     if (pkey-&gt;ameth == NULL) {
-        EVP_PKEY_CTX *pctx = EVP_MD_CTX_pkey_ctx(ctx);
+        EVP_PKEY_CTX *pctx = EVP_MD_CTX_get_pkey_ctx(ctx);
         OSSL_PARAM params[2];
         unsigned char aid[128];
         size_t aid_len = 0;
@@ -238,7 +238,7 @@ int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
 
         pkey_id =
 #ifndef OPENSSL_NO_SM2
-            EVP_PKEY_id(pkey) == NID_sm2 ? NID_sm2 :
+            EVP_PKEY_get_id(pkey) == NID_sm2 ? NID_sm2 :
 #endif
             pkey-&gt;ameth-&gt;pkey_id;
 
diff --git a/crypto/asn1/a_verify.c b/crypto/asn1/a_verify.c
index b7eed914b0..b1adaf7a8f 100644
--- a/crypto/asn1/a_verify.c
+++ b/crypto/asn1/a_verify.c
@@ -102,7 +102,7 @@ int ASN1_item_verify_ex(const ASN1_ITEM *it, const X509_ALGOR *alg,
 
     if ((ctx = evp_md_ctx_new_ex(pkey, id, libctx, propq)) != NULL) {
         rv = ASN1_item_verify_ctx(it, alg, signature, data, ctx);
-        EVP_PKEY_CTX_free(EVP_MD_CTX_pkey_ctx(ctx));
+        EVP_PKEY_CTX_free(EVP_MD_CTX_get_pkey_ctx(ctx));
         EVP_MD_CTX_free(ctx);
     }
     return rv;
@@ -118,7 +118,7 @@ int ASN1_item_verify_ctx(const ASN1_ITEM *it, const X509_ALGOR *alg,
     int mdnid, pknid;
     size_t inll = 0;
 
-    pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_pkey_ctx(ctx));
+    pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_get_pkey_ctx(ctx));
 
     if (pkey == NULL) {
         ERR_raise(ERR_LIB_ASN1, ERR_R_PASSED_NULL_PARAMETER);
diff --git a/crypto/asn1/d2i_param.c b/crypto/asn1/d2i_param.c
index adb394d04c..97f1022339 100644
--- a/crypto/asn1/d2i_param.c
+++ b/crypto/asn1/d2i_param.c
@@ -26,7 +26,7 @@ EVP_PKEY *d2i_KeyParams(int type, EVP_PKEY **a, const unsigned char **pp,
     } else
         ret = *a;
 
-    if (type != EVP_PKEY_id(ret) &amp;&amp; !EVP_PKEY_set_type(ret, type))
+    if (type != EVP_PKEY_get_id(ret) &amp;&amp; !EVP_PKEY_set_type(ret, type))
         goto err;
 
     if (ret-&gt;ameth == NULL || ret-&gt;ameth-&gt;param_decode == NULL) {
diff --git a/crypto/asn1/d2i_pr.c b/crypto/asn1/d2i_pr.c
index 94bd341d58..58b7646227 100644
--- a/crypto/asn1/d2i_pr.c
+++ b/crypto/asn1/d2i_pr.c
@@ -120,7 +120,7 @@ d2i_PrivateKey_legacy(int keytype, EVP_PKEY **a, const unsigned char **pp,
             EVP_PKEY_free(ret);
             ret = tmp;
             ERR_pop_to_mark();
-            if (EVP_PKEY_type(keytype) != EVP_PKEY_base_id(ret))
+            if (EVP_PKEY_type(keytype) != EVP_PKEY_get_base_id(ret))
                 goto err;
         } else {
             ERR_clear_last_mark();
diff --git a/crypto/asn1/d2i_pu.c b/crypto/asn1/d2i_pu.c
index b6c7da772c..5f39ab0775 100644
--- a/crypto/asn1/d2i_pu.c
+++ b/crypto/asn1/d2i_pu.c
@@ -38,12 +38,12 @@ EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
     } else
         ret = *a;
 
-    if (type != EVP_PKEY_id(ret) &amp;&amp; !EVP_PKEY_set_type(ret, type)) {
+    if (type != EVP_PKEY_get_id(ret) &amp;&amp; !EVP_PKEY_set_type(ret, type)) {
         ERR_raise(ERR_LIB_ASN1, ERR_R_EVP_LIB);
         goto err;
     }
 
-    switch (EVP_PKEY_id(ret)) {
+    switch (EVP_PKEY_get_id(ret)) {
     case EVP_PKEY_RSA:
         if ((ret-&gt;pkey.rsa = d2i_RSAPublicKey(NULL, pp, length)) == NULL) {
             ERR_raise(ERR_LIB_ASN1, ERR_R_ASN1_LIB);
diff --git a/crypto/asn1/i2d_evp.c b/crypto/asn1/i2d_evp.c
index f03dcb2666..e1d5b7c7c4 100644
--- a/crypto/asn1/i2d_evp.c
+++ b/crypto/asn1/i2d_evp.c
@@ -131,7 +131,7 @@ int i2d_PublicKey(const EVP_PKEY *a, unsigned char **pp)
 
         return i2d_provided(a, EVP_PKEY_PUBLIC_KEY, output_info, pp);
     }
-    switch (EVP_PKEY_id(a)) {
+    switch (EVP_PKEY_get_id(a)) {
     case EVP_PKEY_RSA:
         return i2d_RSAPublicKey(EVP_PKEY_get0_RSA(a), pp);
 #ifndef OPENSSL_NO_DSA
diff --git a/crypto/asn1/p5_pbev2.c b/crypto/asn1/p5_pbev2.c
index 162e31d7ba..711743a77b 100644
--- a/crypto/asn1/p5_pbev2.c
+++ b/crypto/asn1/p5_pbev2.c
@@ -50,7 +50,7 @@ X509_ALGOR *PKCS5_pbe2_set_iv_ex(const EVP_CIPHER *cipher, int iter,
     unsigned char iv[EVP_MAX_IV_LENGTH];
     PBE2PARAM *pbe2 = NULL;
 
-    alg_nid = EVP_CIPHER_type(cipher);
+    alg_nid = EVP_CIPHER_get_type(cipher);
     if (alg_nid == NID_undef) {
         ERR_raise(ERR_LIB_ASN1, ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
         goto err;
@@ -66,7 +66,7 @@ X509_ALGOR *PKCS5_pbe2_set_iv_ex(const EVP_CIPHER *cipher, int iter,
         goto merr;
 
     /* Create random IV */
-    ivlen = EVP_CIPHER_iv_length(cipher);
+    ivlen = EVP_CIPHER_get_iv_length(cipher);
     if (ivlen &gt; 0) {
         if (aiv)
             memcpy(iv, aiv, ivlen);
@@ -101,7 +101,7 @@ X509_ALGOR *PKCS5_pbe2_set_iv_ex(const EVP_CIPHER *cipher, int iter,
     /* If its RC2 then we'd better setup the key length */
 
     if (alg_nid == NID_rc2_cbc)
-        keylen = EVP_CIPHER_key_length(cipher);
+        keylen = EVP_CIPHER_get_key_length(cipher);
     else
         keylen = -1;
 
diff --git a/crypto/asn1/p5_scrypt.c b/crypto/asn1/p5_scrypt.c
index e5a1ed59bc..a02190d0dc 100644
--- a/crypto/asn1/p5_scrypt.c
+++ b/crypto/asn1/p5_scrypt.c
@@ -60,7 +60,7 @@ X509_ALGOR *PKCS5_pbe2_set_scrypt(const EVP_CIPHER *cipher,
         goto err;
     }
 
-    alg_nid = EVP_CIPHER_type(cipher);
+    alg_nid = EVP_CIPHER_get_type(cipher);
     if (alg_nid == NID_undef) {
         ERR_raise(ERR_LIB_ASN1, ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
         goto err;
@@ -79,10 +79,10 @@ X509_ALGOR *PKCS5_pbe2_set_scrypt(const EVP_CIPHER *cipher,
         goto merr;
 
     /* Create random IV */
-    if (EVP_CIPHER_iv_length(cipher)) {
+    if (EVP_CIPHER_get_iv_length(cipher)) {
         if (aiv)
-            memcpy(iv, aiv, EVP_CIPHER_iv_length(cipher));
-        else if (RAND_bytes(iv, EVP_CIPHER_iv_length(cipher)) &lt;= 0)
+            memcpy(iv, aiv, EVP_CIPHER_get_iv_length(cipher));
+        else if (RAND_bytes(iv, EVP_CIPHER_get_iv_length(cipher)) &lt;= 0)
             goto err;
     }
 
@@ -103,7 +103,7 @@ X509_ALGOR *PKCS5_pbe2_set_scrypt(const EVP_CIPHER *cipher,
     /* If its RC2 then we'd better setup the key length */
 
     if (alg_nid == NID_rc2_cbc)
-        keylen = EVP_CIPHER_key_length(cipher);
+        keylen = EVP_CIPHER_get_key_length(cipher);
 
     /* Setup keyfunc */
 
@@ -234,7 +234,7 @@ int PKCS5_v2_scrypt_keyivgen_ex(EVP_CIPHER_CTX *ctx, const char *pass,
         goto err;
     }
 
-    t = EVP_CIPHER_CTX_key_length(ctx);
+    t = EVP_CIPHER_CTX_get_key_length(ctx);
     if (t &lt; 0) {
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_KEY_LENGTH);
         goto err;
diff --git a/crypto/asn1/x_algor.c b/crypto/asn1/x_algor.c
index 7e7fd7301a..ff83ce4fef 100644
--- a/crypto/asn1/x_algor.c
+++ b/crypto/asn1/x_algor.c
@@ -80,7 +80,7 @@ void X509_ALGOR_set_md(X509_ALGOR *alg, const EVP_MD *md)
     else
         param_type = V_ASN1_NULL;
 
-    X509_ALGOR_set0(alg, OBJ_nid2obj(EVP_MD_type(md)), param_type, NULL);
+    X509_ALGOR_set0(alg, OBJ_nid2obj(EVP_MD_get_type(md)), param_type, NULL);
 
 }
 
diff --git a/crypto/cmac/cmac.c b/crypto/cmac/cmac.c
index 729d5a47c3..18c7fea3dd 100644
--- a/crypto/cmac/cmac.c
+++ b/crypto/cmac/cmac.c
@@ -96,7 +96,7 @@ int CMAC_CTX_copy(CMAC_CTX *out, const CMAC_CTX *in)
 
     if (in-&gt;nlast_block == -1)
         return 0;
-    if ((bl = EVP_CIPHER_CTX_block_size(in-&gt;cctx)) &lt; 0)
+    if ((bl = EVP_CIPHER_CTX_get_block_size(in-&gt;cctx)) &lt; 0)
         return 0;
     if (!EVP_CIPHER_CTX_copy(out-&gt;cctx, in-&gt;cctx))
         return 0;
@@ -120,7 +120,7 @@ int CMAC_Init(CMAC_CTX *ctx, const void *key, size_t keylen,
             return 0;
         if (!EVP_EncryptInit_ex(ctx-&gt;cctx, NULL, NULL, NULL, zero_iv))
             return 0;
-        memset(ctx-&gt;tbl, 0, EVP_CIPHER_CTX_block_size(ctx-&gt;cctx));
+        memset(ctx-&gt;tbl, 0, EVP_CIPHER_CTX_get_block_size(ctx-&gt;cctx));
         ctx-&gt;nlast_block = 0;
         return 1;
     }
@@ -143,7 +143,7 @@ int CMAC_Init(CMAC_CTX *ctx, const void *key, size_t keylen,
             return 0;
         if (!EVP_EncryptInit_ex(ctx-&gt;cctx, NULL, NULL, key, zero_iv))
             return 0;
-        if ((bl = EVP_CIPHER_CTX_block_size(ctx-&gt;cctx)) &lt; 0)
+        if ((bl = EVP_CIPHER_CTX_get_block_size(ctx-&gt;cctx)) &lt; 0)
             return 0;
         if (EVP_Cipher(ctx-&gt;cctx, ctx-&gt;tbl, zero_iv, bl) &lt;= 0)
             return 0;
@@ -169,7 +169,7 @@ int CMAC_Update(CMAC_CTX *ctx, const void *in, size_t dlen)
         return 0;
     if (dlen == 0)
         return 1;
-    if ((bl = EVP_CIPHER_CTX_block_size(ctx-&gt;cctx)) &lt; 0)
+    if ((bl = EVP_CIPHER_CTX_get_block_size(ctx-&gt;cctx)) &lt; 0)
         return 0;
     /* Copy into partial block if we need to */
     if (ctx-&gt;nlast_block &gt; 0) {
@@ -209,7 +209,7 @@ int CMAC_Final(CMAC_CTX *ctx, unsigned char *out, size_t *poutlen)
 
     if (ctx-&gt;nlast_block == -1)
         return 0;
-    if ((bl = EVP_CIPHER_CTX_block_size(ctx-&gt;cctx)) &lt; 0)
+    if ((bl = EVP_CIPHER_CTX_get_block_size(ctx-&gt;cctx)) &lt; 0)
         return 0;
     if (poutlen != NULL)
         *poutlen = (size_t)bl;
diff --git a/crypto/cmp/cmp_ctx.c b/crypto/cmp/cmp_ctx.c
index d1f8f27e13..b0f676201e 100644
--- a/crypto/cmp/cmp_ctx.c
+++ b/crypto/cmp/cmp_ctx.c
@@ -1114,9 +1114,9 @@ int OSSL_CMP_CTX_get_option(const OSSL_CMP_CTX *ctx, int opt)
     case OSSL_CMP_OPT_POPO_METHOD:
         return ctx-&gt;popoMethod;
     case OSSL_CMP_OPT_DIGEST_ALGNID:
-        return EVP_MD_type(ctx-&gt;digest);
+        return EVP_MD_get_type(ctx-&gt;digest);
     case OSSL_CMP_OPT_OWF_ALGNID:
-        return EVP_MD_type(ctx-&gt;pbm_owf);
+        return EVP_MD_get_type(ctx-&gt;pbm_owf);
     case OSSL_CMP_OPT_MAC_ALGNID:
         return ctx-&gt;pbm_mac;
     case OSSL_CMP_OPT_KEEP_ALIVE:
diff --git a/crypto/cmp/cmp_protect.c b/crypto/cmp/cmp_protect.c
index 36a6597145..91a66f5d6e 100644
--- a/crypto/cmp/cmp_protect.c
+++ b/crypto/cmp/cmp_protect.c
@@ -195,7 +195,7 @@ static int set_pbmac_algor(const OSSL_CMP_CTX *ctx, X509_ALGOR **alg)
         return 0;
 
     pbm = OSSL_CRMF_pbmp_new(ctx-&gt;libctx, ctx-&gt;pbm_slen,
-                             EVP_MD_type(ctx-&gt;pbm_owf), ctx-&gt;pbm_itercnt,
+                             EVP_MD_get_type(ctx-&gt;pbm_owf), ctx-&gt;pbm_itercnt,
                              ctx-&gt;pbm_mac);
     pbm_str = ASN1_STRING_new();
     if (pbm == NULL || pbm_str == NULL)
@@ -227,8 +227,8 @@ static int set_sig_algor(const OSSL_CMP_CTX *ctx, X509_ALGOR **alg)
     int nid = 0;
     ASN1_OBJECT *algo = NULL;
 
-    if (!OBJ_find_sigid_by_algs(&amp;nid, EVP_MD_type(ctx-&gt;digest),
-                                EVP_PKEY_id(ctx-&gt;pkey))) {
+    if (!OBJ_find_sigid_by_algs(&amp;nid, EVP_MD_get_type(ctx-&gt;digest),
+                                EVP_PKEY_get_id(ctx-&gt;pkey))) {
         ERR_raise(ERR_LIB_CMP, CMP_R_UNSUPPORTED_KEY_TYPE);
         return 0;
     }
diff --git a/crypto/cms/cms_dh.c b/crypto/cms/cms_dh.c
index 36714766d2..fe6289b205 100644
--- a/crypto/cms/cms_dh.c
+++ b/crypto/cms/cms_dh.c
@@ -53,7 +53,7 @@ static int dh_cms_set_peerkey(EVP_PKEY_CTX *pctx,
      * Pad to full p parameter size as that is checked by
      * EVP_PKEY_set1_encoded_public_key()
      */
-    plen = EVP_PKEY_size(pk);
+    plen = EVP_PKEY_get_size(pk);
     if ((bnpub = ASN1_INTEGER_to_BN(public_key, NULL)) == NULL)
         goto err;
     if ((buf = OPENSSL_malloc(plen)) == NULL)
@@ -122,19 +122,20 @@ static int dh_cms_set_shared_info(EVP_PKEY_CTX *pctx, CMS_RecipientInfo *ri)
         goto err;
 
     kekcipher = EVP_CIPHER_fetch(pctx-&gt;libctx, name, pctx-&gt;propquery);
-    if (kekcipher == NULL || EVP_CIPHER_mode(kekcipher) != EVP_CIPH_WRAP_MODE)
+    if (kekcipher == NULL 
+        || EVP_CIPHER_get_mode(kekcipher) != EVP_CIPH_WRAP_MODE)
         goto err;
     if (!EVP_EncryptInit_ex(kekctx, kekcipher, NULL, NULL, NULL))
         goto err;
     if (EVP_CIPHER_asn1_to_param(kekctx, kekalg-&gt;parameter) &lt;= 0)
         goto err;
 
-    keylen = EVP_CIPHER_CTX_key_length(kekctx);
+    keylen = EVP_CIPHER_CTX_get_key_length(kekctx);
     if (EVP_PKEY_CTX_set_dh_kdf_outlen(pctx, keylen) &lt;= 0)
         goto err;
     /* Use OBJ_nid2obj to ensure we use built in OID that isn't freed */
     if (EVP_PKEY_CTX_set0_dh_kdf_oid(pctx,
-                                     OBJ_nid2obj(EVP_CIPHER_type(kekcipher)))
+                                     OBJ_nid2obj(EVP_CIPHER_get_type(kekcipher)))
         &lt;= 0)
         goto err;
 
@@ -258,7 +259,7 @@ static int dh_cms_encrypt(CMS_RecipientInfo *ri)
         kdf_md = EVP_sha1();
         if (EVP_PKEY_CTX_set_dh_kdf_md(pctx, kdf_md) &lt;= 0)
             goto err;
-    } else if (EVP_MD_type(kdf_md) != NID_sha1)
+    } else if (EVP_MD_get_type(kdf_md) != NID_sha1)
         /* Unsupported digest */
         goto err;
 
@@ -267,10 +268,10 @@ static int dh_cms_encrypt(CMS_RecipientInfo *ri)
 
     /* Get wrap NID */
     ctx = CMS_RecipientInfo_kari_get0_ctx(ri);
-    wrap_nid = EVP_CIPHER_CTX_type(ctx);
+    wrap_nid = EVP_CIPHER_CTX_get_type(ctx);
     if (EVP_PKEY_CTX_set0_dh_kdf_oid(pctx, OBJ_nid2obj(wrap_nid)) &lt;= 0)
         goto err;
-    keylen = EVP_CIPHER_CTX_key_length(ctx);
+    keylen = EVP_CIPHER_CTX_get_key_length(ctx);
 
     /* Package wrap algorithm in an AlgorithmIdentifier */
 
diff --git a/crypto/cms/cms_ec.c b/crypto/cms/cms_ec.c
index 4994260af8..4cf208f5f2 100644
--- a/crypto/cms/cms_ec.c
+++ b/crypto/cms/cms_ec.c
@@ -182,14 +182,14 @@ static int ecdh_cms_set_shared_info(EVP_PKEY_CTX *pctx, CMS_RecipientInfo *ri)
         goto err;
     OBJ_obj2txt(name, sizeof(name), kekalg-&gt;algorithm, 0);
     kekcipher = EVP_CIPHER_fetch(pctx-&gt;libctx, name, pctx-&gt;propquery);
-    if (kekcipher == NULL || EVP_CIPHER_mode(kekcipher) != EVP_CIPH_WRAP_MODE)
+    if (kekcipher == NULL || EVP_CIPHER_get_mode(kekcipher) != EVP_CIPH_WRAP_MODE)
         goto err;
     if (!EVP_EncryptInit_ex(kekctx, kekcipher, NULL, NULL, NULL))
         goto err;
     if (EVP_CIPHER_asn1_to_param(kekctx, kekalg-&gt;parameter) &lt;= 0)
         goto err;
 
-    keylen = EVP_CIPHER_CTX_key_length(kekctx);
+    keylen = EVP_CIPHER_CTX_get_key_length(kekctx);
     if (EVP_PKEY_CTX_set_ecdh_kdf_outlen(pctx, keylen) &lt;= 0)
         goto err;
 
@@ -313,12 +313,12 @@ static int ecdh_cms_encrypt(CMS_RecipientInfo *ri)
 
     /* Lookup NID for KDF+cofactor+digest */
 
-    if (!OBJ_find_sigid_by_algs(&amp;kdf_nid, EVP_MD_type(kdf_md), ecdh_nid))
+    if (!OBJ_find_sigid_by_algs(&amp;kdf_nid, EVP_MD_get_type(kdf_md), ecdh_nid))
         goto err;
     /* Get wrap NID */
     ctx = CMS_RecipientInfo_kari_get0_ctx(ri);
-    wrap_nid = EVP_CIPHER_CTX_type(ctx);
-    keylen = EVP_CIPHER_CTX_key_length(ctx);
+    wrap_nid = EVP_CIPHER_CTX_get_type(ctx);
+    keylen = EVP_CIPHER_CTX_get_key_length(ctx);
 
     /* Package wrap algorithm in an AlgorithmIdentifier */
 
@@ -400,7 +400,7 @@ int ossl_cms_ecdsa_dsa_sign(CMS_SignerInfo *si, int verify)
         hnid = OBJ_obj2nid(alg1-&gt;algorithm);
         if (hnid == NID_undef)
             return -1;
-        if (!OBJ_find_sigid_by_algs(&amp;snid, hnid, EVP_PKEY_id(pkey)))
+        if (!OBJ_find_sigid_by_algs(&amp;snid, hnid, EVP_PKEY_get_id(pkey)))
             return -1;
         X509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);
     }
diff --git a/crypto/cms/cms_enc.c b/crypto/cms/cms_enc.c
index 09dbb21275..a896148dd8 100644
--- a/crypto/cms/cms_enc.c
+++ b/crypto/cms/cms_enc.c
@@ -62,7 +62,8 @@ BIO *ossl_cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
         cipher = EVP_get_cipherbyobj(calg-&gt;algorithm);
     }
     if (cipher != NULL) {
-        fetched_ciph = EVP_CIPHER_fetch(libctx, EVP_CIPHER_name(cipher), propq);
+        fetched_ciph = EVP_CIPHER_fetch(libctx, EVP_CIPHER_get0_name(cipher),
+                                        propq);
         if (fetched_ciph != NULL)
             cipher = fetched_ciph;
     }
@@ -79,9 +80,9 @@ BIO *ossl_cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
     }
 
     if (enc) {
-        calg-&gt;algorithm = OBJ_nid2obj(EVP_CIPHER_CTX_type(ctx));
+        calg-&gt;algorithm = OBJ_nid2obj(EVP_CIPHER_CTX_get_type(ctx));
         /* Generate a random IV if we need one */
-        ivlen = EVP_CIPHER_CTX_iv_length(ctx);
+        ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);
         if (ivlen &gt; 0) {
             if (RAND_bytes_ex(libctx, iv, ivlen, 0) &lt;= 0)
                 goto err;
@@ -92,7 +93,7 @@ BIO *ossl_cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
             ERR_raise(ERR_LIB_CMS, CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
             goto err;
         }
-        if ((EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)) {
+        if ((EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)) {
             piv = aparams.iv;
             if (ec-&gt;taglen &gt; 0
                     &amp;&amp; EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,
@@ -102,7 +103,7 @@ BIO *ossl_cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
             }
         }
     }
-    len = EVP_CIPHER_CTX_key_length(ctx);
+    len = EVP_CIPHER_CTX_get_key_length(ctx);
     if (len &lt;= 0)
         goto err;
     tkeylen = (size_t)len;
@@ -160,10 +161,10 @@ BIO *ossl_cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
             ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             goto err;
         }
-        if ((EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)) {
+        if ((EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)) {
             memcpy(aparams.iv, piv, ivlen);
             aparams.iv_len = ivlen;
-            aparams.tag_len = EVP_CIPHER_CTX_tag_length(ctx);
+            aparams.tag_len = EVP_CIPHER_CTX_get_tag_length(ctx);
             if (aparams.tag_len &lt;= 0)
                 goto err;
         }
diff --git a/crypto/cms/cms_env.c b/crypto/cms/cms_env.c
index 29bbd0c36d..673880f6d9 100644
--- a/crypto/cms/cms_env.c
+++ b/crypto/cms/cms_env.c
@@ -557,7 +557,7 @@ static int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,
         }
         (void)ERR_pop_to_mark();
 
-        fixlen = EVP_CIPHER_key_length(cipher);
+        fixlen = EVP_CIPHER_get_key_length(cipher);
         EVP_CIPHER_free(fetched_cipher);
     }
 
@@ -1108,7 +1108,7 @@ static BIO *cms_EnvelopedData_Decryption_init_bio(CMS_ContentInfo *cms)
      * If the selected cipher supports unprotected attributes,
      * deal with it using special ctrl function
      */
-    if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(ctx))
+    if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ctx))
                 &amp; EVP_CIPH_FLAG_CIPHER_WITH_MAC) != 0
          &amp;&amp; EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_PROCESS_UNPROTECTED, 0,
                                 cms-&gt;d.envelopedData-&gt;unprotectedAttrs) &lt;= 0) {
@@ -1228,7 +1228,7 @@ int ossl_cms_EnvelopedData_final(CMS_ContentInfo *cms, BIO *chain)
      * If the selected cipher supports unprotected attributes,
      * deal with it using special ctrl function
      */
-    if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(ctx))
+    if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ctx))
             &amp; EVP_CIPH_FLAG_CIPHER_WITH_MAC) != 0) {
         if (env-&gt;unprotectedAttrs == NULL)
             env-&gt;unprotectedAttrs = sk_X509_ATTRIBUTE_new_null();
@@ -1261,10 +1261,10 @@ int ossl_cms_AuthEnvelopedData_final(CMS_ContentInfo *cms, BIO *cmsbio)
      * The tag is set only for encryption. There is nothing to do for
      * decryption.
      */
-    if (!EVP_CIPHER_CTX_encrypting(ctx))
+    if (!EVP_CIPHER_CTX_is_encrypting(ctx))
         return 1;
 
-    taglen = EVP_CIPHER_CTX_tag_length(ctx);
+    taglen = EVP_CIPHER_CTX_get_tag_length(ctx);
     if (taglen &lt;= 0
             || (tag = OPENSSL_malloc(taglen)) == NULL
             || EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen,
diff --git a/crypto/cms/cms_kari.c b/crypto/cms/cms_kari.c
index 2fee4784da..47132fcbe8 100644
--- a/crypto/cms/cms_kari.c
+++ b/crypto/cms/cms_kari.c
@@ -218,7 +218,7 @@ static int cms_kek_cipher(unsigned char **pout, size_t *poutlen,
     unsigned char *out = NULL;
     int outlen;
 
-    keklen = EVP_CIPHER_CTX_key_length(kari-&gt;ctx);
+    keklen = EVP_CIPHER_CTX_get_key_length(kari-&gt;ctx);
     if (keklen &gt; EVP_MAX_KEY_LENGTH)
         return 0;
     /* Derive KEK */
@@ -424,14 +424,14 @@ static int cms_wrap_init(CMS_KeyAgreeRecipientInfo *kari,
     /* If a suitable wrap algorithm is already set nothing to do */
     kekcipher = EVP_CIPHER_CTX_get0_cipher(ctx);
     if (kekcipher != NULL) {
-        if (EVP_CIPHER_CTX_mode(ctx) != EVP_CIPH_WRAP_MODE)
+        if (EVP_CIPHER_CTX_get_mode(ctx) != EVP_CIPH_WRAP_MODE)
             return 0;
         return 1;
     }
     if (cipher == NULL)
         return 0;
-    keylen = EVP_CIPHER_key_length(cipher);
-    if ((EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_GET_WRAP_CIPHER) != 0) {
+    keylen = EVP_CIPHER_get_key_length(cipher);
+    if ((EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_GET_WRAP_CIPHER) != 0) {
         /* TODO: make this not get a method we can call directly */
         ret = EVP_CIPHER_meth_get_ctrl(cipher)(NULL, EVP_CTRL_GET_WRAP_CIPHER,
                                                0, &amp;kekcipher);
@@ -439,9 +439,9 @@ static int cms_wrap_init(CMS_KeyAgreeRecipientInfo *kari,
              return 0;
 
         if (kekcipher != NULL) {
-             if (EVP_CIPHER_mode(kekcipher) != EVP_CIPH_WRAP_MODE)
+             if (EVP_CIPHER_get_mode(kekcipher) != EVP_CIPH_WRAP_MODE)
                  return 0;
-             kekcipher_name = EVP_CIPHER_name(kekcipher);
+             kekcipher_name = EVP_CIPHER_get0_name(kekcipher);
              goto enc;
         }
     }
@@ -451,7 +451,7 @@ static int cms_wrap_init(CMS_KeyAgreeRecipientInfo *kari,
      * DES3 wrap otherwise use AES wrap similar to key size.
      */
 #ifndef OPENSSL_NO_DES
-    if (EVP_CIPHER_type(cipher) == NID_des_ede3_cbc)
+    if (EVP_CIPHER_get_type(cipher) == NID_des_ede3_cbc)
         kekcipher_name = SN_id_smime_alg_CMS3DESwrap;
     else
 #endif
diff --git a/crypto/cms/cms_lib.c b/crypto/cms/cms_lib.c
index cfde2215bd..673a1f7ad5 100644
--- a/crypto/cms/cms_lib.c
+++ b/crypto/cms/cms_lib.c
@@ -455,12 +455,12 @@ int ossl_cms_DigestAlgorithm_find_ctx(EVP_MD_CTX *mctx, BIO *chain,
             return 0;
         }
         BIO_get_md_ctx(chain, &amp;mtmp);
-        if (EVP_MD_CTX_type(mtmp) == nid
+        if (EVP_MD_CTX_get_type(mtmp) == nid
             /*
              * Workaround for broken implementations that use signature
              * algorithm OID instead of digest.
              */
-            || EVP_MD_pkey_type(EVP_MD_CTX_get0_md(mtmp)) == nid)
+            || EVP_MD_get_pkey_type(EVP_MD_CTX_get0_md(mtmp)) == nid)
             return EVP_MD_CTX_copy_ex(mctx, mtmp);
         chain = BIO_next(chain);
     }
diff --git a/crypto/cms/cms_pwri.c b/crypto/cms/cms_pwri.c
index d521f8cc47..bc2b5179b7 100644
--- a/crypto/cms/cms_pwri.c
+++ b/crypto/cms/cms_pwri.c
@@ -91,7 +91,7 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
         goto err;
     }
 
-    ivlen = EVP_CIPHER_CTX_iv_length(ctx);
+    ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);
 
     if (ivlen &gt; 0) {
         if (RAND_bytes_ex(ossl_cms_ctx_get0_libctx(cms_ctx), iv, ivlen, 0) &lt;= 0)
@@ -111,7 +111,7 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
         }
     }
 
-    encalg-&gt;algorithm = OBJ_nid2obj(EVP_CIPHER_CTX_type(ctx));
+    encalg-&gt;algorithm = OBJ_nid2obj(EVP_CIPHER_CTX_get_type(ctx));
 
     EVP_CIPHER_CTX_free(ctx);
     ctx = NULL;
@@ -182,7 +182,7 @@ static int kek_unwrap_key(unsigned char *out, size_t *outlen,
                           const unsigned char *in, size_t inlen,
                           EVP_CIPHER_CTX *ctx)
 {
-    size_t blocklen = EVP_CIPHER_CTX_block_size(ctx);
+    size_t blocklen = EVP_CIPHER_CTX_get_block_size(ctx);
     unsigned char *tmp;
     int outl, rv = 0;
     if (inlen &lt; 2 * blocklen) {
@@ -237,7 +237,7 @@ static int kek_wrap_key(unsigned char *out, size_t *outlen,
                         const unsigned char *in, size_t inlen,
                         EVP_CIPHER_CTX *ctx, const CMS_CTX *cms_ctx)
 {
-    size_t blocklen = EVP_CIPHER_CTX_block_size(ctx);
+    size_t blocklen = EVP_CIPHER_CTX_get_block_size(ctx);
     size_t olen;
     int dummy;
     /*
diff --git a/crypto/cms/cms_sd.c b/crypto/cms/cms_sd.c
index c0235b6962..4fbe09ca5f 100644
--- a/crypto/cms/cms_sd.c
+++ b/crypto/cms/cms_sd.c
@@ -469,7 +469,8 @@ CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,
                 goto err;
             if (EVP_PKEY_CTX_set_signature_md(si-&gt;pctx, md) &lt;= 0)
                 goto err;
-        } else if (EVP_DigestSignInit_ex(si-&gt;mctx, &amp;si-&gt;pctx, EVP_MD_name(md),
+        } else if (EVP_DigestSignInit_ex(si-&gt;mctx, &amp;si-&gt;pctx,
+                                         EVP_MD_get0_name(md),
                                          ossl_cms_ctx_get0_libctx(ctx),
                                          ossl_cms_ctx_get0_propq(ctx),
                                          pk, NULL) &lt;= 0) {
@@ -718,7 +719,7 @@ static int cms_SignerInfo_content_sign(CMS_ContentInfo *cms,
         pctx = si-&gt;pctx;
         if (!EVP_DigestFinal_ex(mctx, md, &amp;mdlen))
             goto err;
-        siglen = EVP_PKEY_size(si-&gt;pkey);
+        siglen = EVP_PKEY_get_size(si-&gt;pkey);
         sig = OPENSSL_malloc(siglen);
         if (sig == NULL) {
             ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
@@ -733,7 +734,7 @@ static int cms_SignerInfo_content_sign(CMS_ContentInfo *cms,
         unsigned char *sig;
         unsigned int siglen;
 
-        sig = OPENSSL_malloc(EVP_PKEY_size(si-&gt;pkey));
+        sig = OPENSSL_malloc(EVP_PKEY_get_size(si-&gt;pkey));
         if (sig == NULL) {
             ERR_raise(ERR_LIB_CMS, ERR_R_MALLOC_FAILURE);
             goto err;
@@ -875,7 +876,7 @@ int CMS_SignerInfo_verify(CMS_SignerInfo *si)
         goto err;
     }
     mctx = si-&gt;mctx;
-    if (EVP_DigestVerifyInit_ex(mctx, &amp;si-&gt;pctx, EVP_MD_name(md), libctx,
+    if (EVP_DigestVerifyInit_ex(mctx, &amp;si-&gt;pctx, EVP_MD_get0_name(md), libctx,
                                 propq, si-&gt;pkey, NULL) &lt;= 0)
         goto err;
 
diff --git a/crypto/cms/cms_smime.c b/crypto/cms/cms_smime.c
index d48bbcb6c7..0c3bbd03c3 100644
--- a/crypto/cms/cms_smime.c
+++ b/crypto/cms/cms_smime.c
@@ -630,7 +630,7 @@ CMS_ContentInfo *CMS_encrypt_ex(STACK_OF(X509) *certs, BIO *data,
     X509 *recip;
 
 
-    cms = (EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)
+    cms = (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)
           ? CMS_AuthEnvelopedData_create_ex(cipher, libctx, propq)
           : CMS_EnvelopedData_create_ex(cipher, libctx, propq);
     if (cms == NULL)
diff --git a/crypto/core_namemap.c b/crypto/core_namemap.c
index 5bb0f09ec7..415df3d839 100644
--- a/crypto/core_namemap.c
+++ b/crypto/core_namemap.c
@@ -409,14 +409,14 @@ static void get_legacy_cipher_names(const OBJ_NAME *on, void *arg)
 {
     const EVP_CIPHER *cipher = (void *)OBJ_NAME_get(on-&gt;name, on-&gt;type);
 
-    get_legacy_evp_names(NID_undef, EVP_CIPHER_type(cipher), NULL, arg);
+    get_legacy_evp_names(NID_undef, EVP_CIPHER_get_type(cipher), NULL, arg);
 }
 
 static void get_legacy_md_names(const OBJ_NAME *on, void *arg)
 {
     const EVP_MD *md = (void *)OBJ_NAME_get(on-&gt;name, on-&gt;type);
 
-    get_legacy_evp_names(0, EVP_MD_type(md), NULL, arg);
+    get_legacy_evp_names(0, EVP_MD_get_type(md), NULL, arg);
 }
 
 static void get_legacy_pkey_meth_names(const EVP_PKEY_ASN1_METHOD *ameth,
diff --git a/crypto/crmf/crmf_lib.c b/crypto/crmf/crmf_lib.c
index e26637d0a4..f402086823 100644
--- a/crypto/crmf/crmf_lib.c
+++ b/crypto/crmf/crmf_lib.c
@@ -621,7 +621,7 @@ X509
     }
     (void)ERR_pop_to_mark();
 
-    cikeysize = EVP_CIPHER_key_length(cipher);
+    cikeysize = EVP_CIPHER_get_key_length(cipher);
     /* first the symmetric key needs to be decrypted */
     pkctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq);
     if (pkctx != NULL &amp;&amp; EVP_PKEY_decrypt_init(pkctx)) {
@@ -646,11 +646,11 @@ X509
     } else {
         goto end;
     }
-    if ((iv = OPENSSL_malloc(EVP_CIPHER_iv_length(cipher))) == NULL)
+    if ((iv = OPENSSL_malloc(EVP_CIPHER_get_iv_length(cipher))) == NULL)
         goto end;
     if (ASN1_TYPE_get_octetstring(ecert-&gt;symmAlg-&gt;parameter, iv,
-                                  EVP_CIPHER_iv_length(cipher))
-        != EVP_CIPHER_iv_length(cipher)) {
+                                  EVP_CIPHER_get_iv_length(cipher))
+        != EVP_CIPHER_get_iv_length(cipher)) {
         ERR_raise(ERR_LIB_CRMF, CRMF_R_MALFORMED_IV);
         goto end;
     }
@@ -660,7 +660,7 @@ X509
      * keep the original pointer in outbuf so the memory can be freed later
      */
     if ((p = outbuf = OPENSSL_malloc(ecert-&gt;encValue-&gt;length +
-                                     EVP_CIPHER_block_size(cipher))) == NULL
+                                     EVP_CIPHER_get_block_size(cipher))) == NULL
             || (evp_ctx = EVP_CIPHER_CTX_new()) == NULL)
         goto end;
     EVP_CIPHER_CTX_set_padding(evp_ctx, 0);
diff --git a/crypto/dh/dh_kdf.c b/crypto/dh/dh_kdf.c
index ecc37fa92a..7a234b8fb1 100644
--- a/crypto/dh/dh_kdf.c
+++ b/crypto/dh/dh_kdf.c
@@ -36,7 +36,7 @@ int ossl_dh_kdf_X9_42_asn1(unsigned char *out, size_t outlen,
     EVP_KDF_CTX *kctx = NULL;
     EVP_KDF *kdf = NULL;
     OSSL_PARAM params[5], *p = params;
-    const char *mdname = EVP_MD_name(md);
+    const char *mdname = EVP_MD_get0_name(md);
 
     kdf = EVP_KDF_fetch(libctx, OSSL_KDF_NAME_X942KDF_ASN1, propq);
     kctx = EVP_KDF_CTX_new(kdf);
@@ -67,7 +67,7 @@ int DH_KDF_X9_42(unsigned char *out, size_t outlen,
                  const unsigned char *ukm, size_t ukmlen, const EVP_MD *md)
 {
     char key_alg[OSSL_MAX_NAME_SIZE];
-    const OSSL_PROVIDER *prov = EVP_MD_provider(md);
+    const OSSL_PROVIDER *prov = EVP_MD_get0_provider(md);
     OSSL_LIB_CTX *libctx = ossl_provider_libctx(prov);
 
     if (!OBJ_obj2txt(key_alg, sizeof(key_alg), key_oid, 0))
diff --git a/crypto/dh/dh_pmeth.c b/crypto/dh/dh_pmeth.c
index 78d46aba22..f742bf75cf 100644
--- a/crypto/dh/dh_pmeth.c
+++ b/crypto/dh/dh_pmeth.c
@@ -296,7 +296,7 @@ static DH *ffc_params_generate(OSSL_LIB_CTX *libctx, DH_PKEY_CTX *dctx,
     }
 
     if (dctx-&gt;md != NULL)
-        ossl_ffc_set_digest(&amp;ret-&gt;params, EVP_MD_name(dctx-&gt;md), NULL);
+        ossl_ffc_set_digest(&amp;ret-&gt;params, EVP_MD_get0_name(dctx-&gt;md), NULL);
 
 # ifndef FIPS_MODULE
     if (dctx-&gt;paramgen_type == DH_PARAMGEN_TYPE_FIPS_186_2)
diff --git a/crypto/dsa/dsa_pmeth.c b/crypto/dsa/dsa_pmeth.c
index d9fdc90d25..ffb19da580 100644
--- a/crypto/dsa/dsa_pmeth.c
+++ b/crypto/dsa/dsa_pmeth.c
@@ -83,7 +83,7 @@ static int pkey_dsa_sign(EVP_PKEY_CTX *ctx, unsigned char *sig,
     DSA_PKEY_CTX *dctx = ctx-&gt;data;
     DSA *dsa = ctx-&gt;pkey-&gt;pkey.dsa;
 
-    if (dctx-&gt;md != NULL &amp;&amp; tbslen != (size_t)EVP_MD_size(dctx-&gt;md))
+    if (dctx-&gt;md != NULL &amp;&amp; tbslen != (size_t)EVP_MD_get_size(dctx-&gt;md))
         return 0;
 
     ret = DSA_sign(0, tbs, tbslen, sig, &amp;sltmp, dsa);
@@ -102,7 +102,7 @@ static int pkey_dsa_verify(EVP_PKEY_CTX *ctx,
     DSA_PKEY_CTX *dctx = ctx-&gt;data;
     DSA *dsa = ctx-&gt;pkey-&gt;pkey.dsa;
 
-    if (dctx-&gt;md != NULL &amp;&amp; tbslen != (size_t)EVP_MD_size(dctx-&gt;md))
+    if (dctx-&gt;md != NULL &amp;&amp; tbslen != (size_t)EVP_MD_get_size(dctx-&gt;md))
         return 0;
 
     ret = DSA_verify(0, tbs, tbslen, sig, siglen, dsa);
@@ -128,9 +128,9 @@ static int pkey_dsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
         return 1;
 
     case EVP_PKEY_CTRL_DSA_PARAMGEN_MD:
-        if (EVP_MD_type((const EVP_MD *)p2) != NID_sha1 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha224 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha256) {
+        if (EVP_MD_get_type((const EVP_MD *)p2) != NID_sha1 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha224 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha256) {
             ERR_raise(ERR_LIB_DSA, DSA_R_INVALID_DIGEST_TYPE);
             return 0;
         }
@@ -138,17 +138,17 @@ static int pkey_dsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
         return 1;
 
     case EVP_PKEY_CTRL_MD:
-        if (EVP_MD_type((const EVP_MD *)p2) != NID_sha1 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_dsa &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_dsaWithSHA &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha224 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha256 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha384 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha512 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha3_224 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha3_256 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha3_384 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha3_512) {
+        if (EVP_MD_get_type((const EVP_MD *)p2) != NID_sha1 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_dsa &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_dsaWithSHA &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha224 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha256 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha384 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha512 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha3_224 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha3_256 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha3_384 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha3_512) {
             ERR_raise(ERR_LIB_DSA, DSA_R_INVALID_DIGEST_TYPE);
             return 0;
         }
@@ -217,7 +217,7 @@ static int pkey_dsa_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         return 0;
     }
     if (dctx-&gt;md != NULL)
-        ossl_ffc_set_digest(&amp;dsa-&gt;params, EVP_MD_name(dctx-&gt;md), NULL);
+        ossl_ffc_set_digest(&amp;dsa-&gt;params, EVP_MD_get0_name(dctx-&gt;md), NULL);
 
     ret = ossl_ffc_params_FIPS186_4_generate(NULL, &amp;dsa-&gt;params,
                                              FFC_PARAM_TYPE_DSA, dctx-&gt;nbits,
diff --git a/crypto/ec/ec_ameth.c b/crypto/ec/ec_ameth.c
index 574ad51581..c7fbaeab5e 100644
--- a/crypto/ec/ec_ameth.c
+++ b/crypto/ec/ec_ameth.c
@@ -405,7 +405,7 @@ static int ec_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
 {
     switch (op) {
     case ASN1_PKEY_CTRL_DEFAULT_MD_NID:
-        if (EVP_PKEY_id(pkey) == EVP_PKEY_SM2) {
+        if (EVP_PKEY_get_id(pkey) == EVP_PKEY_SM2) {
             /* For SM2, the only valid digest-alg is SM3 */
             *(int *)arg2 = NID_sm3;
             return 2;            /* Make it mandatory */
diff --git a/crypto/ec/ec_pmeth.c b/crypto/ec/ec_pmeth.c
index e4f3549d30..ce658e14ca 100644
--- a/crypto/ec/ec_pmeth.c
+++ b/crypto/ec/ec_pmeth.c
@@ -126,7 +126,7 @@ static int pkey_ec_sign(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
         return 0;
     }
 
-    type = (dctx-&gt;md != NULL) ? EVP_MD_type(dctx-&gt;md) : NID_sha1;
+    type = (dctx-&gt;md != NULL) ? EVP_MD_get_type(dctx-&gt;md) : NID_sha1;
 
     ret = ECDSA_sign(type, tbs, tbslen, sig, &amp;sltmp, ec);
 
@@ -145,7 +145,7 @@ static int pkey_ec_verify(EVP_PKEY_CTX *ctx,
     EC_KEY *ec = ctx-&gt;pkey-&gt;pkey.ec;
 
     if (dctx-&gt;md)
-        type = EVP_MD_type(dctx-&gt;md);
+        type = EVP_MD_get_type(dctx-&gt;md);
     else
         type = NID_sha1;
 
@@ -335,17 +335,17 @@ static int pkey_ec_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
         return dctx-&gt;kdf_ukmlen;
 
     case EVP_PKEY_CTRL_MD:
-        if (EVP_MD_type((const EVP_MD *)p2) != NID_sha1 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_ecdsa_with_SHA1 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha224 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha256 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha384 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha512 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha3_224 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha3_256 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha3_384 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sha3_512 &amp;&amp;
-            EVP_MD_type((const EVP_MD *)p2) != NID_sm3) {
+        if (EVP_MD_get_type((const EVP_MD *)p2) != NID_sha1 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_ecdsa_with_SHA1 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha224 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha256 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha384 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha512 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha3_224 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha3_256 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha3_384 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sha3_512 &amp;&amp;
+            EVP_MD_get_type((const EVP_MD *)p2) != NID_sm3) {
             ERR_raise(ERR_LIB_EC, EC_R_INVALID_DIGEST_TYPE);
             return 0;
         }
diff --git a/crypto/ec/ecdh_kdf.c b/crypto/ec/ecdh_kdf.c
index b8858cb3ef..de63bf8500 100644
--- a/crypto/ec/ecdh_kdf.c
+++ b/crypto/ec/ecdh_kdf.c
@@ -30,7 +30,7 @@ int ossl_ecdh_kdf_X9_63(unsigned char *out, size_t outlen,
     int ret = 0;
     EVP_KDF_CTX *kctx = NULL;
     OSSL_PARAM params[4], *p = params;
-    const char *mdname = EVP_MD_name(md);
+    const char *mdname = EVP_MD_get0_name(md);
     EVP_KDF *kdf = EVP_KDF_fetch(libctx, OSSL_KDF_NAME_X963KDF, propq);
 
     if ((kctx = EVP_KDF_CTX_new(kdf)) != NULL) {
diff --git a/crypto/ec/ecx_meth.c b/crypto/ec/ecx_meth.c
index 9dd347d670..c4bbb0a535 100644
--- a/crypto/ec/ecx_meth.c
+++ b/crypto/ec/ecx_meth.c
@@ -265,7 +265,7 @@ static int ecx_set_priv_key(EVP_PKEY *pkey, const unsigned char *priv,
     ECX_KEY *ecx = NULL;
 
     if (pkey-&gt;keymgmt != NULL)
-        libctx = ossl_provider_libctx(EVP_KEYMGMT_provider(pkey-&gt;keymgmt));
+        libctx = ossl_provider_libctx(EVP_KEYMGMT_get0_provider(pkey-&gt;keymgmt));
 
     ecx = ossl_ecx_key_op(NULL, priv, len, pkey-&gt;ameth-&gt;pkey_id,
                           KEY_OP_PRIVATE, libctx, NULL);
@@ -283,7 +283,7 @@ static int ecx_set_pub_key(EVP_PKEY *pkey, const unsigned char *pub, size_t len)
     ECX_KEY *ecx = NULL;
 
     if (pkey-&gt;keymgmt != NULL)
-        libctx = ossl_provider_libctx(EVP_KEYMGMT_provider(pkey-&gt;keymgmt));
+        libctx = ossl_provider_libctx(EVP_KEYMGMT_get0_provider(pkey-&gt;keymgmt));
 
     ecx = ossl_ecx_key_op(NULL, pub, len, pkey-&gt;ameth-&gt;pkey_id,
                           KEY_OP_PUBLIC, libctx, NULL);
@@ -806,7 +806,7 @@ static int pkey_ecd_digestsign25519(EVP_MD_CTX *ctx, unsigned char *sig,
                                     size_t *siglen, const unsigned char *tbs,
                                     size_t tbslen)
 {
-    const ECX_KEY *edkey = EVP_MD_CTX_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
+    const ECX_KEY *edkey = EVP_MD_CTX_get_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
 
     if (sig == NULL) {
         *siglen = ED25519_SIGSIZE;
@@ -828,7 +828,7 @@ static int pkey_ecd_digestsign448(EVP_MD_CTX *ctx, unsigned char *sig,
                                   size_t *siglen, const unsigned char *tbs,
                                   size_t tbslen)
 {
-    const ECX_KEY *edkey = EVP_MD_CTX_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
+    const ECX_KEY *edkey = EVP_MD_CTX_get_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
 
     if (sig == NULL) {
         *siglen = ED448_SIGSIZE;
@@ -850,7 +850,7 @@ static int pkey_ecd_digestverify25519(EVP_MD_CTX *ctx, const unsigned char *sig,
                                       size_t siglen, const unsigned char *tbs,
                                       size_t tbslen)
 {
-    const ECX_KEY *edkey = EVP_MD_CTX_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
+    const ECX_KEY *edkey = EVP_MD_CTX_get_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
 
     if (siglen != ED25519_SIGSIZE)
         return 0;
@@ -863,7 +863,7 @@ static int pkey_ecd_digestverify448(EVP_MD_CTX *ctx, const unsigned char *sig,
                                     size_t siglen, const unsigned char *tbs,
                                     size_t tbslen)
 {
-    const ECX_KEY *edkey = EVP_MD_CTX_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
+    const ECX_KEY *edkey = EVP_MD_CTX_get_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
 
     if (siglen != ED448_SIGSIZE)
         return 0;
@@ -1177,7 +1177,7 @@ static int s390x_pkey_ecd_digestsign25519(EVP_MD_CTX *ctx,
         } ed25519;
         unsigned long long buff[512];
     } param;
-    const ECX_KEY *edkey = EVP_MD_CTX_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
+    const ECX_KEY *edkey = EVP_MD_CTX_get_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
     int rc;
 
     if (sig == NULL) {
@@ -1217,7 +1217,7 @@ static int s390x_pkey_ecd_digestsign448(EVP_MD_CTX *ctx,
         } ed448;
         unsigned long long buff[512];
     } param;
-    const ECX_KEY *edkey = EVP_MD_CTX_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
+    const ECX_KEY *edkey = EVP_MD_CTX_get_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
     int rc;
 
     if (sig == NULL) {
@@ -1260,7 +1260,7 @@ static int s390x_pkey_ecd_digestverify25519(EVP_MD_CTX *ctx,
         } ed25519;
         unsigned long long buff[512];
     } param;
-    const ECX_KEY *edkey = EVP_MD_CTX_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
+    const ECX_KEY *edkey = EVP_MD_CTX_get_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
 
     if (siglen != ED25519_SIGSIZE)
         return 0;
@@ -1287,7 +1287,7 @@ static int s390x_pkey_ecd_digestverify448(EVP_MD_CTX *ctx,
         } ed448;
         unsigned long long buff[512];
     } param;
-    const ECX_KEY *edkey = EVP_MD_CTX_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
+    const ECX_KEY *edkey = EVP_MD_CTX_get_pkey_ctx(ctx)-&gt;pkey-&gt;pkey.ecx;
 
     if (siglen != ED448_SIGSIZE)
         return 0;
diff --git a/crypto/encode_decode/decoder_lib.c b/crypto/encode_decode/decoder_lib.c
index 022c1d56e2..ddfd90aae5 100644
--- a/crypto/encode_decode/decoder_lib.c
+++ b/crypto/encode_decode/decoder_lib.c
@@ -300,7 +300,7 @@ int OSSL_DECODER_CTX_add_decoder(OSSL_DECODER_CTX *ctx, OSSL_DECODER *decoder)
         return 0;
     }
 
-    prov = OSSL_DECODER_provider(decoder);
+    prov = OSSL_DECODER_get0_provider(decoder);
     provctx = OSSL_PROVIDER_get0_provider_ctx(prov);
 
     if ((decoderctx = decoder-&gt;newctx(provctx)) == NULL
diff --git a/crypto/encode_decode/decoder_meth.c b/crypto/encode_decode/decoder_meth.c
index 48a52c9612..708b319314 100644
--- a/crypto/encode_decode/decoder_meth.c
+++ b/crypto/encode_decode/decoder_meth.c
@@ -401,7 +401,7 @@ OSSL_DECODER *ossl_decoder_fetch_by_number(OSSL_LIB_CTX *libctx, int id,
  * Library of basic method functions
  */
 
-const OSSL_PROVIDER *OSSL_DECODER_provider(const OSSL_DECODER *decoder)
+const OSSL_PROVIDER *OSSL_DECODER_get0_provider(const OSSL_DECODER *decoder)
 {
     if (!ossl_assert(decoder != NULL)) {
         ERR_raise(ERR_LIB_OSSL_DECODER, ERR_R_PASSED_NULL_PARAMETER);
@@ -411,7 +411,7 @@ const OSSL_PROVIDER *OSSL_DECODER_provider(const OSSL_DECODER *decoder)
     return decoder-&gt;base.prov;
 }
 
-const char *OSSL_DECODER_properties(const OSSL_DECODER *decoder)
+const char *OSSL_DECODER_get0_properties(const OSSL_DECODER *decoder)
 {
     if (!ossl_assert(decoder != NULL)) {
         ERR_raise(ERR_LIB_OSSL_DECODER, ERR_R_PASSED_NULL_PARAMETER);
@@ -421,7 +421,7 @@ const char *OSSL_DECODER_properties(const OSSL_DECODER *decoder)
     return decoder-&gt;base.propdef;
 }
 
-int OSSL_DECODER_number(const OSSL_DECODER *decoder)
+int OSSL_DECODER_get_number(const OSSL_DECODER *decoder)
 {
     if (!ossl_assert(decoder != NULL)) {
         ERR_raise(ERR_LIB_OSSL_DECODER, ERR_R_PASSED_NULL_PARAMETER);
@@ -431,12 +431,12 @@ int OSSL_DECODER_number(const OSSL_DECODER *decoder)
     return decoder-&gt;base.id;
 }
 
-const char *OSSL_DECODER_name(const OSSL_DECODER *decoder)
+const char *OSSL_DECODER_get0_name(const OSSL_DECODER *decoder)
 {
     return decoder-&gt;base.name;
 }
 
-const char *OSSL_DECODER_description(const OSSL_DECODER *decoder)
+const char *OSSL_DECODER_get0_description(const OSSL_DECODER *decoder)
 {
     return decoder-&gt;base.description;
 }
@@ -511,7 +511,7 @@ const OSSL_PARAM *
 OSSL_DECODER_gettable_params(OSSL_DECODER *decoder)
 {
     if (decoder != NULL &amp;&amp; decoder-&gt;gettable_params != NULL) {
-        void *provctx = ossl_provider_ctx(OSSL_DECODER_provider(decoder));
+        void *provctx = ossl_provider_ctx(OSSL_DECODER_get0_provider(decoder));
 
         return decoder-&gt;gettable_params(provctx);
     }
@@ -529,7 +529,7 @@ const OSSL_PARAM *
 OSSL_DECODER_settable_ctx_params(OSSL_DECODER *decoder)
 {
     if (decoder != NULL &amp;&amp; decoder-&gt;settable_ctx_params != NULL) {
-        void *provctx = ossl_provider_ctx(OSSL_DECODER_provider(decoder));
+        void *provctx = ossl_provider_ctx(OSSL_DECODER_get0_provider(decoder));
 
         return decoder-&gt;settable_ctx_params(provctx);
     }
diff --git a/crypto/encode_decode/decoder_pkey.c b/crypto/encode_decode/decoder_pkey.c
index 0bb068ae68..c9ccb2200a 100644
--- a/crypto/encode_decode/decoder_pkey.c
+++ b/crypto/encode_decode/decoder_pkey.c
@@ -108,8 +108,8 @@ static int decoder_construct_pkey(OSSL_DECODER_INSTANCE *decoder_inst,
     if (keymgmt != NULL) {
         EVP_PKEY *pkey = NULL;
         void *keydata = NULL;
-        const OSSL_PROVIDER *keymgmt_prov = EVP_KEYMGMT_provider(keymgmt);
-        const OSSL_PROVIDER *decoder_prov = OSSL_DECODER_provider(decoder);
+        const OSSL_PROVIDER *keymgmt_prov = EVP_KEYMGMT_get0_provider(keymgmt);
+        const OSSL_PROVIDER *decoder_prov = OSSL_DECODER_get0_provider(decoder);
 
         /*
          * If the EVP_KEYMGMT and the OSSL_DECODER are from the
@@ -226,7 +226,7 @@ static void collect_decoder(OSSL_DECODER *decoder, void *arg)
 {
     struct collect_decoder_data_st *data = arg;
     size_t i, end_i;
-    const OSSL_PROVIDER *prov = OSSL_DECODER_provider(decoder);
+    const OSSL_PROVIDER *prov = OSSL_DECODER_get0_provider(decoder);
     void *provctx = OSSL_PROVIDER_get0_provider_ctx(prov);
 
     if (data-&gt;error_occurred)
diff --git a/crypto/encode_decode/encoder_lib.c b/crypto/encode_decode/encoder_lib.c
index f074c9fb60..4481773610 100644
--- a/crypto/encode_decode/encoder_lib.c
+++ b/crypto/encode_decode/encoder_lib.c
@@ -279,7 +279,7 @@ int OSSL_ENCODER_CTX_add_encoder(OSSL_ENCODER_CTX *ctx, OSSL_ENCODER *encoder)
         return 0;
     }
 
-    prov = OSSL_ENCODER_provider(encoder);
+    prov = OSSL_ENCODER_get0_provider(encoder);
     provctx = OSSL_PROVIDER_get0_provider_ctx(prov);
 
     if ((encoderctx = encoder-&gt;newctx(provctx)) == NULL
diff --git a/crypto/encode_decode/encoder_meth.c b/crypto/encode_decode/encoder_meth.c
index 3b2bc2d83e..33655c12a6 100644
--- a/crypto/encode_decode/encoder_meth.c
+++ b/crypto/encode_decode/encoder_meth.c
@@ -413,7 +413,7 @@ OSSL_ENCODER *ossl_encoder_fetch_by_number(OSSL_LIB_CTX *libctx, int id,
  * Library of basic method functions
  */
 
-const OSSL_PROVIDER *OSSL_ENCODER_provider(const OSSL_ENCODER *encoder)
+const OSSL_PROVIDER *OSSL_ENCODER_get0_provider(const OSSL_ENCODER *encoder)
 {
     if (!ossl_assert(encoder != NULL)) {
         ERR_raise(ERR_LIB_OSSL_ENCODER, ERR_R_PASSED_NULL_PARAMETER);
@@ -423,7 +423,7 @@ const OSSL_PROVIDER *OSSL_ENCODER_provider(const OSSL_ENCODER *encoder)
     return encoder-&gt;base.prov;
 }
 
-const char *OSSL_ENCODER_properties(const OSSL_ENCODER *encoder)
+const char *OSSL_ENCODER_get0_properties(const OSSL_ENCODER *encoder)
 {
     if (!ossl_assert(encoder != NULL)) {
         ERR_raise(ERR_LIB_OSSL_ENCODER, ERR_R_PASSED_NULL_PARAMETER);
@@ -433,7 +433,7 @@ const char *OSSL_ENCODER_properties(const OSSL_ENCODER *encoder)
     return encoder-&gt;base.propdef;
 }
 
-int OSSL_ENCODER_number(const OSSL_ENCODER *encoder)
+int OSSL_ENCODER_get_number(const OSSL_ENCODER *encoder)
 {
     if (!ossl_assert(encoder != NULL)) {
         ERR_raise(ERR_LIB_OSSL_ENCODER, ERR_R_PASSED_NULL_PARAMETER);
@@ -443,12 +443,12 @@ int OSSL_ENCODER_number(const OSSL_ENCODER *encoder)
     return encoder-&gt;base.id;
 }
 
-const char *OSSL_ENCODER_name(const OSSL_ENCODER *encoder)
+const char *OSSL_ENCODER_get0_name(const OSSL_ENCODER *encoder)
 {
     return encoder-&gt;base.name;
 }
 
-const char *OSSL_ENCODER_description(const OSSL_ENCODER *encoder)
+const char *OSSL_ENCODER_get0_description(const OSSL_ENCODER *encoder)
 {
     return encoder-&gt;base.description;
 }
@@ -528,7 +528,7 @@ const OSSL_PARAM *
 OSSL_ENCODER_gettable_params(OSSL_ENCODER *encoder)
 {
     if (encoder != NULL &amp;&amp; encoder-&gt;gettable_params != NULL) {
-        void *provctx = ossl_provider_ctx(OSSL_ENCODER_provider(encoder));
+        void *provctx = ossl_provider_ctx(OSSL_ENCODER_get0_provider(encoder));
 
         return encoder-&gt;gettable_params(provctx);
     }
@@ -545,7 +545,7 @@ int OSSL_ENCODER_get_params(OSSL_ENCODER *encoder, OSSL_PARAM params[])
 const OSSL_PARAM *OSSL_ENCODER_settable_ctx_params(OSSL_ENCODER *encoder)
 {
     if (encoder != NULL &amp;&amp; encoder-&gt;settable_ctx_params != NULL) {
-        void *provctx = ossl_provider_ctx(OSSL_ENCODER_provider(encoder));
+        void *provctx = ossl_provider_ctx(OSSL_ENCODER_get0_provider(encoder));
 
         return encoder-&gt;settable_ctx_params(provctx);
     }
diff --git a/crypto/encode_decode/encoder_pkey.c b/crypto/encode_decode/encoder_pkey.c
index 3bb0702e43..4a1ffb3b3e 100644
--- a/crypto/encode_decode/encoder_pkey.c
+++ b/crypto/encode_decode/encoder_pkey.c
@@ -98,7 +98,7 @@ static void collect_encoder(OSSL_ENCODER *encoder, void *arg)
     end_i = sk_OPENSSL_CSTRING_num(data-&gt;names);
     for (i = 0; i &lt; end_i; i++) {
         const char *name = sk_OPENSSL_CSTRING_value(data-&gt;names, i);
-        const OSSL_PROVIDER *prov = OSSL_ENCODER_provider(encoder);
+        const OSSL_PROVIDER *prov = OSSL_ENCODER_get0_provider(encoder);
         void *provctx = OSSL_PROVIDER_get0_provider_ctx(prov);
 
         if (!OSSL_ENCODER_is_a(encoder, name)
@@ -173,8 +173,8 @@ encoder_construct_pkey(OSSL_ENCODER_INSTANCE *encoder_inst, void *arg)
         OSSL_ENCODER *encoder =
             OSSL_ENCODER_INSTANCE_get_encoder(encoder_inst);
         const EVP_PKEY *pk = data-&gt;pk;
-        const OSSL_PROVIDER *k_prov = EVP_KEYMGMT_provider(pk-&gt;keymgmt);
-        const OSSL_PROVIDER *e_prov = OSSL_ENCODER_provider(encoder);
+        const OSSL_PROVIDER *k_prov = EVP_KEYMGMT_get0_provider(pk-&gt;keymgmt);
+        const OSSL_PROVIDER *e_prov = OSSL_ENCODER_get0_provider(encoder);
 
         if (k_prov != e_prov) {
             data-&gt;encoder_inst = encoder_inst;
@@ -226,7 +226,7 @@ static int ossl_encoder_ctx_setup_for_pkey(OSSL_ENCODER_CTX *ctx,
     }
 
     if (evp_pkey_is_provided(pkey)) {
-        prov = EVP_KEYMGMT_provider(pkey-&gt;keymgmt);
+        prov = EVP_KEYMGMT_get0_provider(pkey-&gt;keymgmt);
         libctx = ossl_provider_libctx(prov);
     }
 
@@ -312,7 +312,7 @@ OSSL_ENCODER_CTX *OSSL_ENCODER_CTX_new_for_pkey(const EVP_PKEY *pkey,
     }
 
     if (evp_pkey_is_provided(pkey)) {
-        const OSSL_PROVIDER *prov = EVP_KEYMGMT_provider(pkey-&gt;keymgmt);
+        const OSSL_PROVIDER *prov = EVP_KEYMGMT_get0_provider(pkey-&gt;keymgmt);
 
         libctx = ossl_provider_libctx(prov);
     }
diff --git a/crypto/engine/eng_openssl.c b/crypto/engine/eng_openssl.c
index 3ca95abc13..648d333dbc 100644
--- a/crypto/engine/eng_openssl.c
+++ b/crypto/engine/eng_openssl.c
@@ -205,7 +205,7 @@ typedef struct {
 static int test_rc4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                              const unsigned char *iv, int enc)
 {
-    const int n = EVP_CIPHER_CTX_key_length(ctx);
+    const int n = EVP_CIPHER_CTX_get_key_length(ctx);
 
 # ifdef TEST_ENG_OPENSSL_RC4_P_INIT
     fprintf(stderr, &quot;(TEST_ENG_OPENSSL_RC4) test_init_key() called\n&quot;);
@@ -285,9 +285,9 @@ static int test_cipher_nids(const int **nids)
     if (!init) {
         const EVP_CIPHER *cipher;
         if ((cipher = test_r4_cipher()) != NULL)
-            cipher_nids[pos++] = EVP_CIPHER_nid(cipher);
+            cipher_nids[pos++] = EVP_CIPHER_get_nid(cipher);
         if ((cipher = test_r4_40_cipher()) != NULL)
-            cipher_nids[pos++] = EVP_CIPHER_nid(cipher);
+            cipher_nids[pos++] = EVP_CIPHER_get_nid(cipher);
         cipher_nids[pos] = 0;
         init = 1;
     }
@@ -328,7 +328,7 @@ static int test_sha1_init(EVP_MD_CTX *ctx)
 # ifdef TEST_ENG_OPENSSL_SHA_P_INIT
     fprintf(stderr, &quot;(TEST_ENG_OPENSSL_SHA) test_sha1_init() called\n&quot;);
 # endif
-    return SHA1_Init(EVP_MD_CTX_md_data(ctx));
+    return SHA1_Init(EVP_MD_CTX_get0_md_data(ctx));
 }
 
 static int test_sha1_update(EVP_MD_CTX *ctx, const void *data, size_t count)
@@ -336,7 +336,7 @@ static int test_sha1_update(EVP_MD_CTX *ctx, const void *data, size_t count)
 # ifdef TEST_ENG_OPENSSL_SHA_P_UPDATE
     fprintf(stderr, &quot;(TEST_ENG_OPENSSL_SHA) test_sha1_update() called\n&quot;);
 # endif
-    return SHA1_Update(EVP_MD_CTX_md_data(ctx), data, count);
+    return SHA1_Update(EVP_MD_CTX_get0_md_data(ctx), data, count);
 }
 
 static int test_sha1_final(EVP_MD_CTX *ctx, unsigned char *md)
@@ -344,7 +344,7 @@ static int test_sha1_final(EVP_MD_CTX *ctx, unsigned char *md)
 # ifdef TEST_ENG_OPENSSL_SHA_P_FINAL
     fprintf(stderr, &quot;(TEST_ENG_OPENSSL_SHA) test_sha1_final() called\n&quot;);
 # endif
-    return SHA1_Final(md, EVP_MD_CTX_md_data(ctx));
+    return SHA1_Final(md, EVP_MD_CTX_get0_md_data(ctx));
 }
 
 static EVP_MD *sha1_md = NULL;
@@ -383,7 +383,7 @@ static int test_digest_nids(const int **nids)
     if (!init) {
         const EVP_MD *md;
         if ((md = test_sha_md()) != NULL)
-            digest_nids[pos++] = EVP_MD_type(md);
+            digest_nids[pos++] = EVP_MD_get_type(md);
         digest_nids[pos] = 0;
         init = 1;
     }
@@ -522,7 +522,7 @@ static int ossl_hmac_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 
 static int ossl_int_update(EVP_MD_CTX *ctx, const void *data, size_t count)
 {
-    OSSL_HMAC_PKEY_CTX *hctx = EVP_PKEY_CTX_get_data(EVP_MD_CTX_pkey_ctx(ctx));
+    OSSL_HMAC_PKEY_CTX *hctx = EVP_PKEY_CTX_get_data(EVP_MD_CTX_get_pkey_ctx(ctx));
     if (!HMAC_Update(hctx-&gt;ctx, data, count))
         return 0;
     return 1;
@@ -540,7 +540,7 @@ static int ossl_hmac_signctx(EVP_PKEY_CTX *ctx, unsigned char *sig,
 {
     unsigned int hlen;
     OSSL_HMAC_PKEY_CTX *hctx = EVP_PKEY_CTX_get_data(ctx);
-    int l = EVP_MD_CTX_size(mctx);
+    int l = EVP_MD_CTX_get_size(mctx);
 
     if (l &lt; 0)
         return 0;
diff --git a/crypto/evp/asymcipher.c b/crypto/evp/asymcipher.c
index 513cb7e654..52be1c2d7c 100644
--- a/crypto/evp/asymcipher.c
+++ b/crypto/evp/asymcipher.c
@@ -79,8 +79,8 @@ static int evp_pkey_asym_cipher_init(EVP_PKEY_CTX *ctx, int operation,
         EVP_ASYM_CIPHER_fetch(ctx-&gt;libctx, supported_ciph, ctx-&gt;propquery);
 
     if (cipher == NULL
-        || (EVP_KEYMGMT_provider(ctx-&gt;keymgmt)
-            != EVP_ASYM_CIPHER_provider(cipher))) {
+        || (EVP_KEYMGMT_get0_provider(ctx-&gt;keymgmt)
+            != EVP_ASYM_CIPHER_get0_provider(cipher))) {
         /*
          * We don't need to free ctx-&gt;keymgmt here, as it's not necessarily
          * tied to this operation.  It will be freed by EVP_PKEY_CTX_free().
@@ -415,7 +415,7 @@ int EVP_ASYM_CIPHER_up_ref(EVP_ASYM_CIPHER *cipher)
     return 1;
 }
 
-OSSL_PROVIDER *EVP_ASYM_CIPHER_provider(const EVP_ASYM_CIPHER *cipher)
+OSSL_PROVIDER *EVP_ASYM_CIPHER_get0_provider(const EVP_ASYM_CIPHER *cipher)
 {
     return cipher-&gt;prov;
 }
@@ -434,17 +434,17 @@ int EVP_ASYM_CIPHER_is_a(const EVP_ASYM_CIPHER *cipher, const char *name)
     return evp_is_a(cipher-&gt;prov, cipher-&gt;name_id, NULL, name);
 }
 
-int EVP_ASYM_CIPHER_number(const EVP_ASYM_CIPHER *cipher)
+int EVP_ASYM_CIPHER_get_number(const EVP_ASYM_CIPHER *cipher)
 {
     return cipher-&gt;name_id;
 }
 
-const char *EVP_ASYM_CIPHER_name(const EVP_ASYM_CIPHER *cipher)
+const char *EVP_ASYM_CIPHER_get0_name(const EVP_ASYM_CIPHER *cipher)
 {
     return cipher-&gt;type_name;
 }
 
-const char *EVP_ASYM_CIPHER_description(const EVP_ASYM_CIPHER *cipher)
+const char *EVP_ASYM_CIPHER_get0_description(const EVP_ASYM_CIPHER *cipher)
 {
     return cipher-&gt;description;
 }
@@ -478,7 +478,7 @@ const OSSL_PARAM *EVP_ASYM_CIPHER_gettable_ctx_params(const EVP_ASYM_CIPHER *cip
     if (cip == NULL || cip-&gt;gettable_ctx_params == NULL)
         return NULL;
 
-    provctx = ossl_provider_ctx(EVP_ASYM_CIPHER_provider(cip));
+    provctx = ossl_provider_ctx(EVP_ASYM_CIPHER_get0_provider(cip));
     return cip-&gt;gettable_ctx_params(NULL, provctx);
 }
 
@@ -489,6 +489,6 @@ const OSSL_PARAM *EVP_ASYM_CIPHER_settable_ctx_params(const EVP_ASYM_CIPHER *cip
     if (cip == NULL || cip-&gt;settable_ctx_params == NULL)
         return NULL;
 
-    provctx = ossl_provider_ctx(EVP_ASYM_CIPHER_provider(cip));
+    provctx = ossl_provider_ctx(EVP_ASYM_CIPHER_get0_provider(cip));
     return cip-&gt;settable_ctx_params(NULL, provctx);
 }
diff --git a/crypto/evp/bio_enc.c b/crypto/evp/bio_enc.c
index 9d7a9eafef..0483c726d2 100644
--- a/crypto/evp/bio_enc.c
+++ b/crypto/evp/bio_enc.c
@@ -135,7 +135,7 @@ static int enc_read(BIO *b, char *out, int outl)
         }
     }
 
-    blocksize = EVP_CIPHER_CTX_block_size(ctx-&gt;cipher);
+    blocksize = EVP_CIPHER_CTX_get_block_size(ctx-&gt;cipher);
     if (blocksize == 1)
         blocksize = 0;
 
@@ -312,7 +312,7 @@ static long enc_ctrl(BIO *b, int cmd, long num, void *ptr)
         ctx-&gt;ok = 1;
         ctx-&gt;finished = 0;
         if (!EVP_CipherInit_ex(ctx-&gt;cipher, NULL, NULL, NULL, NULL,
-                               EVP_CIPHER_CTX_encrypting(ctx-&gt;cipher)))
+                               EVP_CIPHER_CTX_is_encrypting(ctx-&gt;cipher)))
             return 0;
         ret = BIO_ctrl(next, cmd, num, ptr);
         break;
diff --git a/crypto/evp/bio_md.c b/crypto/evp/bio_md.c
index 8e5b3e6446..26a30c698b 100644
--- a/crypto/evp/bio_md.c
+++ b/crypto/evp/bio_md.c
@@ -214,7 +214,7 @@ static int md_gets(BIO *bp, char *buf, int size)
 
     ctx = BIO_get_data(bp);
 
-    if (size &lt; EVP_MD_CTX_size(ctx))
+    if (size &lt; EVP_MD_CTX_get_size(ctx))
         return 0;
 
     if (EVP_DigestFinal_ex(ctx, (unsigned char *)buf, &amp;ret) &lt;= 0)
diff --git a/crypto/evp/bio_ok.c b/crypto/evp/bio_ok.c
index c1256c7cbb..7e3d23f2dc 100644
--- a/crypto/evp/bio_ok.c
+++ b/crypto/evp/bio_ok.c
@@ -443,8 +443,8 @@ static int sig_out(BIO *b)
     ctx = BIO_get_data(b);
     md = ctx-&gt;md;
     digest = EVP_MD_CTX_get0_md(md);
-    md_size = EVP_MD_size(digest);
-    md_data = EVP_MD_CTX_md_data(md);
+    md_size = EVP_MD_get_size(digest);
+    md_data = EVP_MD_CTX_get0_md_data(md);
 
     if (ctx-&gt;buf_len + 2 * md_size &gt; OK_BLOCK_SIZE)
         return 1;
@@ -487,8 +487,8 @@ static int sig_in(BIO *b)
     ctx = BIO_get_data(b);
     md = ctx-&gt;md;
     digest = EVP_MD_CTX_get0_md(md);
-    md_size = EVP_MD_size(digest);
-    md_data = EVP_MD_CTX_md_data(md);
+    md_size = EVP_MD_get_size(digest);
+    md_data = EVP_MD_CTX_get0_md_data(md);
 
     if ((int)(ctx-&gt;buf_len - ctx-&gt;buf_off) &lt; 2 * md_size)
         return 1;
@@ -533,7 +533,7 @@ static int block_out(BIO *b)
     ctx = BIO_get_data(b);
     md = ctx-&gt;md;
     digest = EVP_MD_CTX_get0_md(md);
-    md_size = EVP_MD_size(digest);
+    md_size = EVP_MD_get_size(digest);
 
     tl = ctx-&gt;buf_len - OK_BLOCK_BLOCK;
     ctx-&gt;buf[0] = (unsigned char)(tl &gt;&gt; 24);
@@ -563,7 +563,7 @@ static int block_in(BIO *b)
 
     ctx = BIO_get_data(b);
     md = ctx-&gt;md;
-    md_size = EVP_MD_size(EVP_MD_CTX_get0_md(md));
+    md_size = EVP_MD_get_size(EVP_MD_CTX_get0_md(md));
 
     assert(sizeof(tl) &gt;= OK_BLOCK_BLOCK); /* always true */
     tl = ctx-&gt;buf[0];
diff --git a/crypto/evp/ctrl_params_translate.c b/crypto/evp/ctrl_params_translate.c
index 7e550f81a1..e289c7df7b 100644
--- a/crypto/evp/ctrl_params_translate.c
+++ b/crypto/evp/ctrl_params_translate.c
@@ -710,12 +710,12 @@ cleanup_translation_ctx(enum state state,
  */
 static const char *get_cipher_name(void *cipher)
 {
-    return EVP_CIPHER_name(cipher);
+    return EVP_CIPHER_get0_name(cipher);
 }
 
 static const char *get_md_name(void *md)
 {
-    return EVP_MD_name(md);
+    return EVP_MD_get0_name(md);
 }
 
 static const void *get_cipher_by_name(OSSL_LIB_CTX *libctx, const char *name)
@@ -1456,7 +1456,7 @@ static int get_payload_group_name(enum state state,
     EVP_PKEY *pkey = ctx-&gt;p2;
 
     ctx-&gt;p2 = NULL;
-    switch (EVP_PKEY_base_id(pkey)) {
+    switch (EVP_PKEY_get_base_id(pkey)) {
 #ifndef OPENSSL_NO_DH
     case EVP_PKEY_DH:
         {
@@ -1512,7 +1512,7 @@ static int get_payload_private_key(enum state state,
     if (ctx-&gt;params-&gt;data_type != OSSL_PARAM_UNSIGNED_INTEGER)
         return 0;
 
-    switch (EVP_PKEY_base_id(pkey)) {
+    switch (EVP_PKEY_get_base_id(pkey)) {
 #ifndef OPENSSL_NO_DH
     case EVP_PKEY_DH:
         {
@@ -1548,7 +1548,7 @@ static int get_payload_public_key(enum state state,
     int ret;
 
     ctx-&gt;p2 = NULL;
-    switch (EVP_PKEY_base_id(pkey)) {
+    switch (EVP_PKEY_get_base_id(pkey)) {
 #ifndef OPENSSL_NO_DH
     case EVP_PKEY_DH:
         switch (ctx-&gt;params-&gt;data_type) {
@@ -1618,7 +1618,7 @@ static int get_dh_dsa_payload_p(enum state state,
     const BIGNUM *bn = NULL;
     EVP_PKEY *pkey = ctx-&gt;p2;
 
-    switch (EVP_PKEY_base_id(pkey)) {
+    switch (EVP_PKEY_get_base_id(pkey)) {
 #ifndef OPENSSL_NO_DH
     case EVP_PKEY_DH:
         bn = DH_get0_p(EVP_PKEY_get0_DH(pkey));
@@ -1642,7 +1642,7 @@ static int get_dh_dsa_payload_q(enum state state,
 {
     const BIGNUM *bn = NULL;
 
-    switch (EVP_PKEY_base_id(ctx-&gt;p2)) {
+    switch (EVP_PKEY_get_base_id(ctx-&gt;p2)) {
 #ifndef OPENSSL_NO_DH
     case EVP_PKEY_DH:
         bn = DH_get0_q(EVP_PKEY_get0_DH(ctx-&gt;p2));
@@ -1664,7 +1664,7 @@ static int get_dh_dsa_payload_g(enum state state,
 {
     const BIGNUM *bn = NULL;
 
-    switch (EVP_PKEY_base_id(ctx-&gt;p2)) {
+    switch (EVP_PKEY_get_base_id(ctx-&gt;p2)) {
 #ifndef OPENSSL_NO_DH
     case EVP_PKEY_DH:
         bn = DH_get0_g(EVP_PKEY_get0_DH(ctx-&gt;p2));
@@ -1720,7 +1720,7 @@ static int get_rsa_payload_n(enum state state,
 {
     const BIGNUM *bn = NULL;
 
-    if (EVP_PKEY_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)
+    if (EVP_PKEY_get_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)
         return 0;
     bn = RSA_get0_n(EVP_PKEY_get0_RSA(ctx-&gt;p2));
 
@@ -1733,7 +1733,7 @@ static int get_rsa_payload_e(enum state state,
 {
     const BIGNUM *bn = NULL;
 
-    if (EVP_PKEY_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)
+    if (EVP_PKEY_get_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)
         return 0;
     bn = RSA_get0_e(EVP_PKEY_get0_RSA(ctx-&gt;p2));
 
@@ -1746,7 +1746,7 @@ static int get_rsa_payload_d(enum state state,
 {
     const BIGNUM *bn = NULL;
 
-    if (EVP_PKEY_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)
+    if (EVP_PKEY_get_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)
         return 0;
     bn = RSA_get0_d(EVP_PKEY_get0_RSA(ctx-&gt;p2));
 
@@ -1846,7 +1846,7 @@ static int get_rsa_payload_coefficient(enum state state,
                          const struct translation_st *translation,      \
                          struct translation_ctx_st *ctx)                \
     {                                                                   \
-        if (EVP_PKEY_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)                  \
+        if (EVP_PKEY_get_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)              \
             return 0;                                                   \
         return get_rsa_payload_factor(state, translation, ctx, n - 1);  \
     }
@@ -1857,7 +1857,7 @@ static int get_rsa_payload_coefficient(enum state state,
                          const struct translation_st *translation,      \
                          struct translation_ctx_st *ctx)                \
     {                                                                   \
-        if (EVP_PKEY_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)                  \
+        if (EVP_PKEY_get_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)              \
             return 0;                                                   \
         return get_rsa_payload_exponent(state, translation, ctx,        \
                                         n - 1);                         \
@@ -1869,7 +1869,7 @@ static int get_rsa_payload_coefficient(enum state state,
                          const struct translation_st *translation,      \
                          struct translation_ctx_st *ctx)                \
     {                                                                   \
-        if (EVP_PKEY_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)                  \
+        if (EVP_PKEY_get_base_id(ctx-&gt;p2) != EVP_PKEY_RSA)              \
             return 0;                                                   \
         return get_rsa_payload_coefficient(state, translation, ctx,     \
                                            n - 1);                      \
diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
index b202d466e4..00806ae201 100644
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -411,7 +411,7 @@ int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *isize)
     if (ctx-&gt;digest == NULL)
         return 0;
 
-    sz = EVP_MD_size(ctx-&gt;digest);
+    sz = EVP_MD_get_size(ctx-&gt;digest);
     if (sz &lt; 0)
         return 0;
     mdsize = sz;
@@ -654,7 +654,7 @@ const OSSL_PARAM *EVP_MD_gettable_params(const EVP_MD *digest)
 {
     if (digest != NULL &amp;&amp; digest-&gt;gettable_params != NULL)
         return digest-&gt;gettable_params(
-                           ossl_provider_ctx(EVP_MD_provider(digest)));
+                           ossl_provider_ctx(EVP_MD_get0_provider(digest)));
     return NULL;
 }
 
@@ -682,7 +682,7 @@ const OSSL_PARAM *EVP_MD_settable_ctx_params(const EVP_MD *md)
     void *provctx;
 
     if (md != NULL &amp;&amp; md-&gt;settable_ctx_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_MD_provider(md));
+        provctx = ossl_provider_ctx(EVP_MD_get0_provider(md));
         return md-&gt;settable_ctx_params(NULL, provctx);
     }
     return NULL;
@@ -707,7 +707,7 @@ const OSSL_PARAM *EVP_MD_CTX_settable_params(EVP_MD_CTX *ctx)
                    pctx-&gt;op.sig.algctx);
 
     if (ctx-&gt;digest != NULL &amp;&amp; ctx-&gt;digest-&gt;settable_ctx_params != NULL) {
-        alg = ossl_provider_ctx(EVP_MD_provider(ctx-&gt;digest));
+        alg = ossl_provider_ctx(EVP_MD_get0_provider(ctx-&gt;digest));
         return ctx-&gt;digest-&gt;settable_ctx_params(ctx-&gt;algctx, alg);
     }
 
@@ -738,7 +738,7 @@ const OSSL_PARAM *EVP_MD_gettable_ctx_params(const EVP_MD *md)
     void *provctx;
 
     if (md != NULL &amp;&amp; md-&gt;gettable_ctx_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_MD_provider(md));
+        provctx = ossl_provider_ctx(EVP_MD_get0_provider(md));
         return md-&gt;gettable_ctx_params(NULL, provctx);
     }
     return NULL;
@@ -763,7 +763,7 @@ const OSSL_PARAM *EVP_MD_CTX_gettable_params(EVP_MD_CTX *ctx)
                     pctx-&gt;op.sig.algctx);
 
     if (ctx-&gt;digest != NULL &amp;&amp; ctx-&gt;digest-&gt;gettable_ctx_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_MD_provider(ctx-&gt;digest));
+        provctx = ossl_provider_ctx(EVP_MD_get0_provider(ctx-&gt;digest));
         return ctx-&gt;digest-&gt;gettable_ctx_params(ctx-&gt;algctx, provctx);
     }
     return NULL;
diff --git a/crypto/evp/e_aes.c b/crypto/evp/e_aes.c
index 7e8f8ece72..2c2a4ba90c 100644
--- a/crypto/evp/e_aes.c
+++ b/crypto/evp/e_aes.c
@@ -147,16 +147,18 @@ static int aesni_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     int ret, mode;
     EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);
 
-    mode = EVP_CIPHER_CTX_mode(ctx);
+    mode = EVP_CIPHER_CTX_get_mode(ctx);
     if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)
         &amp;&amp; !enc) {
-        ret = aesni_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        ret = aesni_set_decrypt_key(key,
+                                    EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                     &amp;dat-&gt;ks.ks);
         dat-&gt;block = (block128_f) aesni_decrypt;
         dat-&gt;stream.cbc = mode == EVP_CIPH_CBC_MODE ?
             (cbc128_f) aesni_cbc_encrypt : NULL;
     } else {
-        ret = aesni_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        ret = aesni_set_encrypt_key(key,
+                                    EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                     &amp;dat-&gt;ks.ks);
         dat-&gt;block = (block128_f) aesni_encrypt;
         if (mode == EVP_CIPH_CBC_MODE)
@@ -179,7 +181,7 @@ static int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t len)
 {
     aesni_cbc_encrypt(in, out, len, &amp;EVP_C_DATA(EVP_AES_KEY,ctx)-&gt;ks.ks,
-                      ctx-&gt;iv, EVP_CIPHER_CTX_encrypting(ctx));
+                      ctx-&gt;iv, EVP_CIPHER_CTX_is_encrypting(ctx));
 
     return 1;
 }
@@ -187,13 +189,13 @@ static int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 static int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t len)
 {
-    size_t bl = EVP_CIPHER_CTX_block_size(ctx);
+    size_t bl = EVP_CIPHER_CTX_get_block_size(ctx);
 
     if (len &lt; bl)
         return 1;
 
     aesni_ecb_encrypt(in, out, len, &amp;EVP_C_DATA(EVP_AES_KEY,ctx)-&gt;ks.ks,
-                      EVP_CIPHER_CTX_encrypting(ctx));
+                      EVP_CIPHER_CTX_is_encrypting(ctx));
 
     return 1;
 }
@@ -225,7 +227,7 @@ static int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     if (!iv &amp;&amp; !key)
         return 1;
     if (key) {
-        aesni_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        aesni_set_encrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                               &amp;gctx-&gt;ks.ks);
         CRYPTO_gcm128_init(&amp;gctx-&gt;gcm, &amp;gctx-&gt;ks, (block128_f) aesni_encrypt);
         gctx-&gt;ctr = (ctr128_f) aesni_ctr32_encrypt_blocks;
@@ -265,7 +267,7 @@ static int aesni_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 
     if (key) {
         /* The key is two half length keys in reality */
-        const int bytes = EVP_CIPHER_CTX_key_length(ctx) / 2;
+        const int bytes = EVP_CIPHER_CTX_get_key_length(ctx) / 2;
         const int bits = bytes * 8;
 
         /*
@@ -316,7 +318,7 @@ static int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     if (!iv &amp;&amp; !key)
         return 1;
     if (key) {
-        aesni_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        aesni_set_encrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                               &amp;cctx-&gt;ks.ks);
         CRYPTO_ccm128_init(&amp;cctx-&gt;ccm, cctx-&gt;M, cctx-&gt;L,
                            &amp;cctx-&gt;ks, (block128_f) aesni_encrypt);
@@ -349,9 +351,9 @@ static int aesni_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
              * needs both. We could possibly optimise to remove setting the
              * decrypt for an encryption operation.
              */
-            aesni_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+            aesni_set_encrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                   &amp;octx-&gt;ksenc.ks);
-            aesni_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+            aesni_set_decrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                   &amp;octx-&gt;ksdec.ks);
             if (!CRYPTO_ocb128_init(&amp;octx-&gt;ocb,
                                     &amp;octx-&gt;ksenc.ks, &amp;octx-&gt;ksdec.ks,
@@ -448,8 +450,8 @@ static int aes_t4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     int ret, mode, bits;
     EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);
 
-    mode = EVP_CIPHER_CTX_mode(ctx);
-    bits = EVP_CIPHER_CTX_key_length(ctx) * 8;
+    mode = EVP_CIPHER_CTX_get_mode(ctx);
+    bits = EVP_CIPHER_CTX_get_key_length(ctx) * 8;
     if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)
         &amp;&amp; !enc) {
         ret = 0;
@@ -548,7 +550,7 @@ static int aes_t4_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     if (!iv &amp;&amp; !key)
         return 1;
     if (key) {
-        int bits = EVP_CIPHER_CTX_key_length(ctx) * 8;
+        int bits = EVP_CIPHER_CTX_get_key_length(ctx) * 8;
         aes_t4_set_encrypt_key(key, bits, &amp;gctx-&gt;ks.ks);
         CRYPTO_gcm128_init(&amp;gctx-&gt;gcm, &amp;gctx-&gt;ks,
                            (block128_f) aes_t4_encrypt);
@@ -601,7 +603,7 @@ static int aes_t4_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 
     if (key) {
         /* The key is two half length keys in reality */
-        const int bytes = EVP_CIPHER_CTX_key_length(ctx) / 2;
+        const int bytes = EVP_CIPHER_CTX_get_key_length(ctx) / 2;
         const int bits = bytes * 8;
 
         /*
@@ -671,7 +673,7 @@ static int aes_t4_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     if (!iv &amp;&amp; !key)
         return 1;
     if (key) {
-        int bits = EVP_CIPHER_CTX_key_length(ctx) * 8;
+        int bits = EVP_CIPHER_CTX_get_key_length(ctx) * 8;
         aes_t4_set_encrypt_key(key, bits, &amp;cctx-&gt;ks.ks);
         CRYPTO_ccm128_init(&amp;cctx-&gt;ccm, cctx-&gt;M, cctx-&gt;L,
                            &amp;cctx-&gt;ks, (block128_f) aes_t4_encrypt);
@@ -703,9 +705,9 @@ static int aes_t4_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
              * needs both. We could possibly optimise to remove setting the
              * decrypt for an encryption operation.
              */
-            aes_t4_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+            aes_t4_set_encrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                    &amp;octx-&gt;ksenc.ks);
-            aes_t4_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+            aes_t4_set_decrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                    &amp;octx-&gt;ksdec.ks);
             if (!CRYPTO_ocb128_init(&amp;octx-&gt;ocb,
                                     &amp;octx-&gt;ksenc.ks, &amp;octx-&gt;ksdec.ks,
@@ -969,7 +971,7 @@ static int s390x_aes_ecb_init_key(EVP_CIPHER_CTX *ctx,
                                   const unsigned char *iv, int enc)
 {
     S390X_AES_ECB_CTX *cctx = EVP_C_DATA(S390X_AES_ECB_CTX, ctx);
-    const int keylen = EVP_CIPHER_CTX_key_length(ctx);
+    const int keylen = EVP_CIPHER_CTX_get_key_length(ctx);
 
     cctx-&gt;fc = S390X_AES_FC(keylen);
     if (!enc)
@@ -994,8 +996,8 @@ static int s390x_aes_ofb_init_key(EVP_CIPHER_CTX *ctx,
 {
     S390X_AES_OFB_CTX *cctx = EVP_C_DATA(S390X_AES_OFB_CTX, ctx);
     const unsigned char *iv = ctx-&gt;oiv;
-    const int keylen = EVP_CIPHER_CTX_key_length(ctx);
-    const int ivlen = EVP_CIPHER_CTX_iv_length(ctx);
+    const int keylen = EVP_CIPHER_CTX_get_key_length(ctx);
+    const int ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);
 
     memcpy(cctx-&gt;kmo.param.cv, iv, ivlen);
     memcpy(cctx-&gt;kmo.param.k, key, keylen);
@@ -1049,8 +1051,8 @@ static int s390x_aes_cfb_init_key(EVP_CIPHER_CTX *ctx,
 {
     S390X_AES_CFB_CTX *cctx = EVP_C_DATA(S390X_AES_CFB_CTX, ctx);
     const unsigned char *iv = ctx-&gt;oiv;
-    const int keylen = EVP_CIPHER_CTX_key_length(ctx);
-    const int ivlen = EVP_CIPHER_CTX_iv_length(ctx);
+    const int keylen = EVP_CIPHER_CTX_get_key_length(ctx);
+    const int ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);
 
     cctx-&gt;fc = S390X_AES_FC(keylen);
     cctx-&gt;fc |= 16 &lt;&lt; 24;   /* 16 bytes cipher feedback */
@@ -1067,8 +1069,8 @@ static int s390x_aes_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                 const unsigned char *in, size_t len)
 {
     S390X_AES_CFB_CTX *cctx = EVP_C_DATA(S390X_AES_CFB_CTX, ctx);
-    const int keylen = EVP_CIPHER_CTX_key_length(ctx);
-    const int enc = EVP_CIPHER_CTX_encrypting(ctx);
+    const int keylen = EVP_CIPHER_CTX_get_key_length(ctx);
+    const int enc = EVP_CIPHER_CTX_is_encrypting(ctx);
     int n = cctx-&gt;res;
     int rem;
     unsigned char tmp;
@@ -1115,8 +1117,8 @@ static int s390x_aes_cfb8_init_key(EVP_CIPHER_CTX *ctx,
 {
     S390X_AES_CFB_CTX *cctx = EVP_C_DATA(S390X_AES_CFB_CTX, ctx);
     const unsigned char *iv = ctx-&gt;oiv;
-    const int keylen = EVP_CIPHER_CTX_key_length(ctx);
-    const int ivlen = EVP_CIPHER_CTX_iv_length(ctx);
+    const int keylen = EVP_CIPHER_CTX_get_key_length(ctx);
+    const int ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);
 
     cctx-&gt;fc = S390X_AES_FC(keylen);
     cctx-&gt;fc |= 1 &lt;&lt; 24;   /* 1 byte cipher feedback */
@@ -1345,7 +1347,7 @@ static int s390x_aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
 
     switch (type) {
     case EVP_CTRL_INIT:
-        ivlen = EVP_CIPHER_iv_length(c-&gt;cipher);
+        ivlen = EVP_CIPHER_get_iv_length(c-&gt;cipher);
         gctx-&gt;key_set = 0;
         gctx-&gt;iv_set = 0;
         gctx-&gt;ivlen = ivlen;
@@ -1385,7 +1387,7 @@ static int s390x_aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
 
     case EVP_CTRL_AEAD_SET_TAG:
         buf = EVP_CIPHER_CTX_buf_noconst(c);
-        enc = EVP_CIPHER_CTX_encrypting(c);
+        enc = EVP_CIPHER_CTX_is_encrypting(c);
         if (arg &lt;= 0 || arg &gt; 16 || enc)
             return 0;
 
@@ -1394,7 +1396,7 @@ static int s390x_aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         return 1;
 
     case EVP_CTRL_AEAD_GET_TAG:
-        enc = EVP_CIPHER_CTX_encrypting(c);
+        enc = EVP_CIPHER_CTX_is_encrypting(c);
         if (arg &lt;= 0 || arg &gt; 16 || !enc || gctx-&gt;taglen &lt; 0)
             return 0;
 
@@ -1418,7 +1420,7 @@ static int s390x_aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         if (arg)
             memcpy(gctx-&gt;iv, ptr, arg);
 
-        enc = EVP_CIPHER_CTX_encrypting(c);
+        enc = EVP_CIPHER_CTX_is_encrypting(c);
         if (enc &amp;&amp; RAND_bytes(gctx-&gt;iv + arg, gctx-&gt;ivlen - arg) &lt;= 0)
             return 0;
 
@@ -1444,7 +1446,7 @@ static int s390x_aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         return 1;
 
     case EVP_CTRL_GCM_SET_IV_INV:
-        enc = EVP_CIPHER_CTX_encrypting(c);
+        enc = EVP_CIPHER_CTX_is_encrypting(c);
         if (gctx-&gt;iv_gen == 0 || gctx-&gt;key_set == 0 || enc)
             return 0;
 
@@ -1470,7 +1472,7 @@ static int s390x_aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
 
         /* If decrypting correct for tag too. */
-        enc = EVP_CIPHER_CTX_encrypting(c);
+        enc = EVP_CIPHER_CTX_is_encrypting(c);
         if (!enc) {
             if (len &lt; EVP_GCM_TLS_TAG_LEN)
                 return 0;
@@ -1518,7 +1520,7 @@ static int s390x_aes_gcm_init_key(EVP_CIPHER_CTX *ctx,
         return 1;
 
     if (key != NULL) {
-        keylen = EVP_CIPHER_CTX_key_length(ctx);
+        keylen = EVP_CIPHER_CTX_get_key_length(ctx);
         memcpy(&amp;gctx-&gt;kma.param.k, key, keylen);
 
         gctx-&gt;fc = S390X_AES_FC(keylen);
@@ -1554,7 +1556,7 @@ static int s390x_aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 {
     S390X_AES_GCM_CTX *gctx = EVP_C_DATA(S390X_AES_GCM_CTX, ctx);
     const unsigned char *buf = EVP_CIPHER_CTX_buf_noconst(ctx);
-    const int enc = EVP_CIPHER_CTX_encrypting(ctx);
+    const int enc = EVP_CIPHER_CTX_is_encrypting(ctx);
     int rv = -1;
 
     if (out != in || len &lt; (EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN))
@@ -1643,7 +1645,7 @@ static int s390x_aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         OPENSSL_cleanse(tmp, gctx-&gt;mreslen);
         gctx-&gt;iv_set = 0;
 
-        enc = EVP_CIPHER_CTX_encrypting(ctx);
+        enc = EVP_CIPHER_CTX_is_encrypting(ctx);
         if (enc) {
             gctx-&gt;taglen = 16;
         } else {
@@ -1866,7 +1868,7 @@ static int s390x_aes_ccm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     S390X_AES_CCM_CTX *cctx = EVP_C_DATA(S390X_AES_CCM_CTX, ctx);
     unsigned char *ivec = ctx-&gt;iv;
     unsigned char *buf = EVP_CIPHER_CTX_buf_noconst(ctx);
-    const int enc = EVP_CIPHER_CTX_encrypting(ctx);
+    const int enc = EVP_CIPHER_CTX_is_encrypting(ctx);
 
     if (out != in
             || len &lt; (EVP_CCM_TLS_EXPLICIT_IV_LEN + (size_t)cctx-&gt;aes.ccm.m))
@@ -1924,7 +1926,7 @@ static int s390x_aes_ccm_init_key(EVP_CIPHER_CTX *ctx,
         return 1;
 
     if (key != NULL) {
-        keylen = EVP_CIPHER_CTX_key_length(ctx);
+        keylen = EVP_CIPHER_CTX_get_key_length(ctx);
         cctx-&gt;aes.ccm.fc = S390X_AES_FC(keylen);
         memcpy(cctx-&gt;aes.ccm.kmac_param.k, key, keylen);
 
@@ -1957,7 +1959,7 @@ static int s390x_aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                 const unsigned char *in, size_t len)
 {
     S390X_AES_CCM_CTX *cctx = EVP_C_DATA(S390X_AES_CCM_CTX, ctx);
-    const int enc = EVP_CIPHER_CTX_encrypting(ctx);
+    const int enc = EVP_CIPHER_CTX_is_encrypting(ctx);
     int rv;
     unsigned char *buf;
 
@@ -2079,7 +2081,7 @@ static int s390x_aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         /* Correct length for explicit iv. */
         len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;
 
-        enc = EVP_CIPHER_CTX_encrypting(c);
+        enc = EVP_CIPHER_CTX_is_encrypting(c);
         if (!enc) {
             if (len &lt; cctx-&gt;aes.ccm.m)
                 return 0;
@@ -2117,7 +2119,7 @@ static int s390x_aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         if ((arg &amp; 1) || arg &lt; 4 || arg &gt; 16)
             return 0;
 
-        enc = EVP_CIPHER_CTX_encrypting(c);
+        enc = EVP_CIPHER_CTX_is_encrypting(c);
         if (enc &amp;&amp; ptr)
             return 0;
 
@@ -2131,7 +2133,7 @@ static int s390x_aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         return 1;
 
     case EVP_CTRL_AEAD_GET_TAG:
-        enc = EVP_CIPHER_CTX_encrypting(c);
+        enc = EVP_CIPHER_CTX_is_encrypting(c);
         if (!enc || !cctx-&gt;aes.ccm.tag_set)
             return 0;
 
@@ -2302,13 +2304,13 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     int ret, mode;
     EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);
 
-    mode = EVP_CIPHER_CTX_mode(ctx);
+    mode = EVP_CIPHER_CTX_get_mode(ctx);
     if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)
         &amp;&amp; !enc) {
 #ifdef HWAES_CAPABLE
         if (HWAES_CAPABLE) {
             ret = HWAES_set_decrypt_key(key,
-                                        EVP_CIPHER_CTX_key_length(ctx) * 8,
+                                        EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                         &amp;dat-&gt;ks.ks);
             dat-&gt;block = (block128_f) HWAES_decrypt;
             dat-&gt;stream.cbc = NULL;
@@ -2320,7 +2322,8 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 #endif
 #ifdef BSAES_CAPABLE
         if (BSAES_CAPABLE &amp;&amp; mode == EVP_CIPH_CBC_MODE) {
-            ret = AES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+            ret = AES_set_decrypt_key(key,
+                                      EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                       &amp;dat-&gt;ks.ks);
             dat-&gt;block = (block128_f) AES_decrypt;
             dat-&gt;stream.cbc = (cbc128_f) ossl_bsaes_cbc_encrypt;
@@ -2329,7 +2332,7 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 #ifdef VPAES_CAPABLE
         if (VPAES_CAPABLE) {
             ret = vpaes_set_decrypt_key(key,
-                                        EVP_CIPHER_CTX_key_length(ctx) * 8,
+                                        EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                         &amp;dat-&gt;ks.ks);
             dat-&gt;block = (block128_f) vpaes_decrypt;
             dat-&gt;stream.cbc = mode == EVP_CIPH_CBC_MODE ?
@@ -2338,7 +2341,7 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 #endif
         {
             ret = AES_set_decrypt_key(key,
-                                      EVP_CIPHER_CTX_key_length(ctx) * 8,
+                                      EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                       &amp;dat-&gt;ks.ks);
             dat-&gt;block = (block128_f) AES_decrypt;
             dat-&gt;stream.cbc = mode == EVP_CIPH_CBC_MODE ?
@@ -2347,7 +2350,8 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     } else
 #ifdef HWAES_CAPABLE
     if (HWAES_CAPABLE) {
-        ret = HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        ret = HWAES_set_encrypt_key(key,
+                                    EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                     &amp;dat-&gt;ks.ks);
         dat-&gt;block = (block128_f) HWAES_encrypt;
         dat-&gt;stream.cbc = NULL;
@@ -2366,7 +2370,7 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 #endif
 #ifdef BSAES_CAPABLE
     if (BSAES_CAPABLE &amp;&amp; mode == EVP_CIPH_CTR_MODE) {
-        ret = AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        ret = AES_set_encrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                   &amp;dat-&gt;ks.ks);
         dat-&gt;block = (block128_f) AES_encrypt;
         dat-&gt;stream.ctr = (ctr128_f) ossl_bsaes_ctr32_encrypt_blocks;
@@ -2374,7 +2378,8 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 #endif
 #ifdef VPAES_CAPABLE
     if (VPAES_CAPABLE) {
-        ret = vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        ret = vpaes_set_encrypt_key(key,
+                                    EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                     &amp;dat-&gt;ks.ks);
         dat-&gt;block = (block128_f) vpaes_encrypt;
         dat-&gt;stream.cbc = mode == EVP_CIPH_CBC_MODE ?
@@ -2382,7 +2387,7 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     } else
 #endif
     {
-        ret = AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        ret = AES_set_encrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                   &amp;dat-&gt;ks.ks);
         dat-&gt;block = (block128_f) AES_encrypt;
         dat-&gt;stream.cbc = mode == EVP_CIPH_CBC_MODE ?
@@ -2408,8 +2413,8 @@ static int aes_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 
     if (dat-&gt;stream.cbc)
         (*dat-&gt;stream.cbc) (in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv,
-                            EVP_CIPHER_CTX_encrypting(ctx));
-    else if (EVP_CIPHER_CTX_encrypting(ctx))
+                            EVP_CIPHER_CTX_is_encrypting(ctx));
+    else if (EVP_CIPHER_CTX_is_encrypting(ctx))
         CRYPTO_cbc128_encrypt(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv,
                               dat-&gt;block);
     else
@@ -2422,7 +2427,7 @@ static int aes_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 static int aes_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                           const unsigned char *in, size_t len)
 {
-    size_t bl = EVP_CIPHER_CTX_block_size(ctx);
+    size_t bl = EVP_CIPHER_CTX_get_block_size(ctx);
     size_t i;
     EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);
 
@@ -2440,7 +2445,7 @@ static int aes_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 {
     EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);
 
-    int num = EVP_CIPHER_CTX_num(ctx);
+    int num = EVP_CIPHER_CTX_get_num(ctx);
     CRYPTO_ofb128_encrypt(in, out, len, &amp;dat-&gt;ks,
                           ctx-&gt;iv, &amp;num, dat-&gt;block);
     EVP_CIPHER_CTX_set_num(ctx, num);
@@ -2452,10 +2457,10 @@ static int aes_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 {
     EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);
 
-    int num = EVP_CIPHER_CTX_num(ctx);
+    int num = EVP_CIPHER_CTX_get_num(ctx);
     CRYPTO_cfb128_encrypt(in, out, len, &amp;dat-&gt;ks,
                           ctx-&gt;iv, &amp;num,
-                          EVP_CIPHER_CTX_encrypting(ctx), dat-&gt;block);
+                          EVP_CIPHER_CTX_is_encrypting(ctx), dat-&gt;block);
     EVP_CIPHER_CTX_set_num(ctx, num);
     return 1;
 }
@@ -2465,10 +2470,10 @@ static int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 {
     EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);
 
-    int num = EVP_CIPHER_CTX_num(ctx);
+    int num = EVP_CIPHER_CTX_get_num(ctx);
     CRYPTO_cfb128_8_encrypt(in, out, len, &amp;dat-&gt;ks,
                             ctx-&gt;iv, &amp;num,
-                            EVP_CIPHER_CTX_encrypting(ctx), dat-&gt;block);
+                            EVP_CIPHER_CTX_is_encrypting(ctx), dat-&gt;block);
     EVP_CIPHER_CTX_set_num(ctx, num);
     return 1;
 }
@@ -2479,29 +2484,29 @@ static int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);
 
     if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS)) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         CRYPTO_cfb128_1_encrypt(in, out, len, &amp;dat-&gt;ks,
                                 ctx-&gt;iv, &amp;num,
-                                EVP_CIPHER_CTX_encrypting(ctx), dat-&gt;block);
+                                EVP_CIPHER_CTX_is_encrypting(ctx), dat-&gt;block);
         EVP_CIPHER_CTX_set_num(ctx, num);
         return 1;
     }
 
     while (len &gt;= MAXBITCHUNK) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         CRYPTO_cfb128_1_encrypt(in, out, MAXBITCHUNK * 8, &amp;dat-&gt;ks,
                                 ctx-&gt;iv, &amp;num,
-                                EVP_CIPHER_CTX_encrypting(ctx), dat-&gt;block);
+                                EVP_CIPHER_CTX_is_encrypting(ctx), dat-&gt;block);
         EVP_CIPHER_CTX_set_num(ctx, num);
         len -= MAXBITCHUNK;
         out += MAXBITCHUNK;
         in  += MAXBITCHUNK;
     }
     if (len) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         CRYPTO_cfb128_1_encrypt(in, out, len * 8, &amp;dat-&gt;ks,
                                 ctx-&gt;iv, &amp;num,
-                                EVP_CIPHER_CTX_encrypting(ctx), dat-&gt;block);
+                                EVP_CIPHER_CTX_is_encrypting(ctx), dat-&gt;block);
         EVP_CIPHER_CTX_set_num(ctx, num);
     }
 
@@ -2511,7 +2516,7 @@ static int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 static int aes_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                           const unsigned char *in, size_t len)
 {
-    unsigned int num = EVP_CIPHER_CTX_num(ctx);
+    unsigned int num = EVP_CIPHER_CTX_get_num(ctx);
     EVP_AES_KEY *dat = EVP_C_DATA(EVP_AES_KEY,ctx);
 
     if (dat-&gt;stream.ctr)
@@ -2550,7 +2555,7 @@ static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
     case EVP_CTRL_INIT:
         gctx-&gt;key_set = 0;
         gctx-&gt;iv_set = 0;
-        gctx-&gt;ivlen = EVP_CIPHER_iv_length(c-&gt;cipher);
+        gctx-&gt;ivlen = EVP_CIPHER_get_iv_length(c-&gt;cipher);
         gctx-&gt;iv = c-&gt;iv;
         gctx-&gt;taglen = -1;
         gctx-&gt;iv_gen = 0;
@@ -3112,7 +3117,7 @@ static int aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     if (key) {
         do {
             /* The key is two half length keys in reality */
-            const int bytes = EVP_CIPHER_CTX_key_length(ctx) / 2;
+            const int bytes = EVP_CIPHER_CTX_get_key_length(ctx) / 2;
             const int bits = bytes * 8;
 
             /*
@@ -3241,7 +3246,7 @@ static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          xctx-&gt;xts.key1, xctx-&gt;xts.key2,
                          ctx-&gt;iv);
     else if (CRYPTO_xts128_encrypt(&amp;xctx-&gt;xts, ctx-&gt;iv, in, out, len,
-                                   EVP_CIPHER_CTX_encrypting(ctx)))
+                                   EVP_CIPHER_CTX_is_encrypting(ctx)))
         return 0;
     return 1;
 }
@@ -3288,7 +3293,7 @@ static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
                 return 0;
             len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;
             /* If decrypting correct for tag too */
-            if (!EVP_CIPHER_CTX_encrypting(c)) {
+            if (!EVP_CIPHER_CTX_is_encrypting(c)) {
                 if (len &lt; cctx-&gt;M)
                     return 0;
                 len -= cctx-&gt;M;
@@ -3319,7 +3324,7 @@ static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
     case EVP_CTRL_AEAD_SET_TAG:
         if ((arg &amp; 1) || arg &lt; 4 || arg &gt; 16)
             return 0;
-        if (EVP_CIPHER_CTX_encrypting(c) &amp;&amp; ptr)
+        if (EVP_CIPHER_CTX_is_encrypting(c) &amp;&amp; ptr)
             return 0;
         if (ptr) {
             cctx-&gt;tag_set = 1;
@@ -3329,7 +3334,7 @@ static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         return 1;
 
     case EVP_CTRL_AEAD_GET_TAG:
-        if (!EVP_CIPHER_CTX_encrypting(c) || !cctx-&gt;tag_set)
+        if (!EVP_CIPHER_CTX_is_encrypting(c) || !cctx-&gt;tag_set)
             return 0;
         if (!CRYPTO_ccm128_tag(&amp;cctx-&gt;ccm, ptr, (size_t)arg))
             return 0;
@@ -3366,7 +3371,8 @@ static int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         do {
 #ifdef HWAES_CAPABLE
             if (HWAES_CAPABLE) {
-                HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+                HWAES_set_encrypt_key(key,
+                                      EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                       &amp;cctx-&gt;ks.ks);
 
                 CRYPTO_ccm128_init(&amp;cctx-&gt;ccm, cctx-&gt;M, cctx-&gt;L,
@@ -3378,7 +3384,8 @@ static int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 #endif
 #ifdef VPAES_CAPABLE
             if (VPAES_CAPABLE) {
-                vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+                vpaes_set_encrypt_key(key,
+                                      EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                       &amp;cctx-&gt;ks.ks);
                 CRYPTO_ccm128_init(&amp;cctx-&gt;ccm, cctx-&gt;M, cctx-&gt;L,
                                    &amp;cctx-&gt;ks, (block128_f) vpaes_encrypt);
@@ -3387,7 +3394,7 @@ static int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                 break;
             }
 #endif
-            AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+            AES_set_encrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                 &amp;cctx-&gt;ks.ks);
             CRYPTO_ccm128_init(&amp;cctx-&gt;ccm, cctx-&gt;M, cctx-&gt;L,
                                &amp;cctx-&gt;ks, (block128_f) AES_encrypt);
@@ -3410,7 +3417,7 @@ static int aes_ccm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     if (out != in || len &lt; (EVP_CCM_TLS_EXPLICIT_IV_LEN + (size_t)cctx-&gt;M))
         return -1;
     /* If encrypting set explicit IV from sequence number (start of AAD) */
-    if (EVP_CIPHER_CTX_encrypting(ctx))
+    if (EVP_CIPHER_CTX_is_encrypting(ctx))
         memcpy(out, EVP_CIPHER_CTX_buf_noconst(ctx),
                EVP_CCM_TLS_EXPLICIT_IV_LEN);
     /* Get rest of IV from explicit IV */
@@ -3422,11 +3429,12 @@ static int aes_ccm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             len))
             return -1;
     /* Use saved AAD */
-    CRYPTO_ccm128_aad(ccm, EVP_CIPHER_CTX_buf_noconst(ctx), cctx-&gt;tls_aad_len);
+    CRYPTO_ccm128_aad(ccm, EVP_CIPHER_CTX_buf_noconst(ctx),
+                      cctx-&gt;tls_aad_len);
     /* Fix buffer to point to payload */
     in += EVP_CCM_TLS_EXPLICIT_IV_LEN;
     out += EVP_CCM_TLS_EXPLICIT_IV_LEN;
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
+    if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
         if (cctx-&gt;str ? CRYPTO_ccm128_encrypt_ccm64(ccm, in, out, len,
                                                     cctx-&gt;str) :
             CRYPTO_ccm128_encrypt(ccm, in, out, len))
@@ -3484,7 +3492,7 @@ static int aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     }
 
     /* The tag must be set before actually decrypting data */
-    if (!EVP_CIPHER_CTX_encrypting(ctx) &amp;&amp; !cctx-&gt;tag_set)
+    if (!EVP_CIPHER_CTX_is_encrypting(ctx) &amp;&amp; !cctx-&gt;tag_set)
         return -1;
 
     /* If not set length yet do it */
@@ -3493,7 +3501,7 @@ static int aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             return -1;
         cctx-&gt;len_set = 1;
     }
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
+    if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
         if (cctx-&gt;str ? CRYPTO_ccm128_encrypt_ccm64(ccm, in, out, len,
                                                     cctx-&gt;str) :
             CRYPTO_ccm128_encrypt(ccm, in, out, len))
@@ -3546,17 +3554,17 @@ static int aes_wrap_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     if (!iv &amp;&amp; !key)
         return 1;
     if (key) {
-        if (EVP_CIPHER_CTX_encrypting(ctx))
-            AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        if (EVP_CIPHER_CTX_is_encrypting(ctx))
+            AES_set_encrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                 &amp;wctx-&gt;ks.ks);
         else
-            AES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+            AES_set_decrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                 &amp;wctx-&gt;ks.ks);
         if (!iv)
             wctx-&gt;iv = NULL;
     }
     if (iv) {
-        memcpy(ctx-&gt;iv, iv, EVP_CIPHER_CTX_iv_length(ctx));
+        memcpy(ctx-&gt;iv, iv, EVP_CIPHER_CTX_get_iv_length(ctx));
         wctx-&gt;iv = ctx-&gt;iv;
     }
     return 1;
@@ -3568,7 +3576,7 @@ static int aes_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     EVP_AES_WRAP_CTX *wctx = EVP_C_DATA(EVP_AES_WRAP_CTX,ctx);
     size_t rv;
     /* AES wrap with padding has IV length of 4, without padding 8 */
-    int pad = EVP_CIPHER_CTX_iv_length(ctx) == 4;
+    int pad = EVP_CIPHER_CTX_get_iv_length(ctx) == 4;
     /* No final operation so always return zero length */
     if (!in)
         return 0;
@@ -3576,7 +3584,7 @@ static int aes_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     if (!inlen)
         return -1;
     /* If decrypting need at least 16 bytes and multiple of 8 */
-    if (!EVP_CIPHER_CTX_encrypting(ctx) &amp;&amp; (inlen &lt; 16 || inlen &amp; 0x7))
+    if (!EVP_CIPHER_CTX_is_encrypting(ctx) &amp;&amp; (inlen &lt; 16 || inlen &amp; 0x7))
         return -1;
     /* If not padding input must be multiple of 8 */
     if (!pad &amp;&amp; inlen &amp; 0x7)
@@ -3586,7 +3594,7 @@ static int aes_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         return 0;
     }
     if (!out) {
-        if (EVP_CIPHER_CTX_encrypting(ctx)) {
+        if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
             /* If padding round up to multiple of 8 */
             if (pad)
                 inlen = (inlen + 7) / 8 * 8;
@@ -3602,7 +3610,7 @@ static int aes_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         }
     }
     if (pad) {
-        if (EVP_CIPHER_CTX_encrypting(ctx))
+        if (EVP_CIPHER_CTX_is_encrypting(ctx))
             rv = CRYPTO_128_wrap_pad(&amp;wctx-&gt;ks.ks, wctx-&gt;iv,
                                      out, in, inlen,
                                      (block128_f) AES_encrypt);
@@ -3611,7 +3619,7 @@ static int aes_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                        out, in, inlen,
                                        (block128_f) AES_decrypt);
     } else {
-        if (EVP_CIPHER_CTX_encrypting(ctx))
+        if (EVP_CIPHER_CTX_is_encrypting(ctx))
             rv = CRYPTO_128_wrap(&amp;wctx-&gt;ks.ks, wctx-&gt;iv,
                                  out, in, inlen, (block128_f) AES_encrypt);
         else
@@ -3720,7 +3728,7 @@ static int aes_ocb_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
     case EVP_CTRL_INIT:
         octx-&gt;key_set = 0;
         octx-&gt;iv_set = 0;
-        octx-&gt;ivlen = EVP_CIPHER_iv_length(c-&gt;cipher);
+        octx-&gt;ivlen = EVP_CIPHER_get_iv_length(c-&gt;cipher);
         octx-&gt;iv = c-&gt;iv;
         octx-&gt;taglen = 16;
         octx-&gt;data_buf_len = 0;
@@ -3748,13 +3756,13 @@ static int aes_ocb_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
             octx-&gt;taglen = arg;
             return 1;
         }
-        if (arg != octx-&gt;taglen || EVP_CIPHER_CTX_encrypting(c))
+        if (arg != octx-&gt;taglen || EVP_CIPHER_CTX_is_encrypting(c))
             return 0;
         memcpy(octx-&gt;tag, ptr, arg);
         return 1;
 
     case EVP_CTRL_AEAD_GET_TAG:
-        if (arg != octx-&gt;taglen || !EVP_CIPHER_CTX_encrypting(c))
+        if (arg != octx-&gt;taglen || !EVP_CIPHER_CTX_is_encrypting(c))
             return 0;
 
         memcpy(ptr, octx-&gt;tag, arg);
@@ -3788,9 +3796,9 @@ static int aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
              */
 # ifdef HWAES_CAPABLE
             if (HWAES_CAPABLE) {
-                HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+                HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                       &amp;octx-&gt;ksenc.ks);
-                HWAES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+                HWAES_set_decrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                       &amp;octx-&gt;ksdec.ks);
                 if (!CRYPTO_ocb128_init(&amp;octx-&gt;ocb,
                                         &amp;octx-&gt;ksenc.ks, &amp;octx-&gt;ksdec.ks,
@@ -3804,9 +3812,11 @@ static int aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 # endif
 # ifdef VPAES_CAPABLE
             if (VPAES_CAPABLE) {
-                vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+                vpaes_set_encrypt_key(key,
+                                      EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                       &amp;octx-&gt;ksenc.ks);
-                vpaes_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+                vpaes_set_decrypt_key(key,
+                                      EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                       &amp;octx-&gt;ksdec.ks);
                 if (!CRYPTO_ocb128_init(&amp;octx-&gt;ocb,
                                         &amp;octx-&gt;ksenc.ks, &amp;octx-&gt;ksdec.ks,
@@ -3817,9 +3827,9 @@ static int aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                 break;
             }
 # endif
-            AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+            AES_set_encrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                 &amp;octx-&gt;ksenc.ks);
-            AES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+            AES_set_decrypt_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                 &amp;octx-&gt;ksdec.ks);
             if (!CRYPTO_ocb128_init(&amp;octx-&gt;ocb,
                                     &amp;octx-&gt;ksenc.ks, &amp;octx-&gt;ksdec.ks,
@@ -3914,7 +3924,7 @@ static int aes_ocb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             if (out == NULL) {
                 if (!CRYPTO_ocb128_aad(&amp;octx-&gt;ocb, buf, AES_BLOCK_SIZE))
                     return -1;
-            } else if (EVP_CIPHER_CTX_encrypting(ctx)) {
+            } else if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
                 if (!CRYPTO_ocb128_encrypt(&amp;octx-&gt;ocb, buf, out,
                                            AES_BLOCK_SIZE))
                     return -1;
@@ -3939,7 +3949,7 @@ static int aes_ocb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             if (out == NULL) {
                 if (!CRYPTO_ocb128_aad(&amp;octx-&gt;ocb, in, len - trailing_len))
                     return -1;
-            } else if (EVP_CIPHER_CTX_encrypting(ctx)) {
+            } else if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
                 if (!CRYPTO_ocb128_encrypt
                     (&amp;octx-&gt;ocb, in, out, len - trailing_len))
                     return -1;
@@ -3965,7 +3975,7 @@ static int aes_ocb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
          * have been provided - both for data and AAD
          */
         if (octx-&gt;data_buf_len &gt; 0) {
-            if (EVP_CIPHER_CTX_encrypting(ctx)) {
+            if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
                 if (!CRYPTO_ocb128_encrypt(&amp;octx-&gt;ocb, octx-&gt;data_buf, out,
                                            octx-&gt;data_buf_len))
                     return -1;
@@ -3984,7 +3994,7 @@ static int aes_ocb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             octx-&gt;aad_buf_len = 0;
         }
         /* If decrypting then verify */
-        if (!EVP_CIPHER_CTX_encrypting(ctx)) {
+        if (!EVP_CIPHER_CTX_is_encrypting(ctx)) {
             if (octx-&gt;taglen &lt; 0)
                 return -1;
             if (CRYPTO_ocb128_finish(&amp;octx-&gt;ocb,
diff --git a/crypto/evp/e_aes_cbc_hmac_sha1.c b/crypto/evp/e_aes_cbc_hmac_sha1.c
index 91357f8b1a..4941f98e64 100644
--- a/crypto/evp/e_aes_cbc_hmac_sha1.c
+++ b/crypto/evp/e_aes_cbc_hmac_sha1.c
@@ -75,11 +75,11 @@ static int aesni_cbc_hmac_sha1_init_key(EVP_CIPHER_CTX *ctx,
 
     if (enc)
         ret = aesni_set_encrypt_key(inkey,
-                                    EVP_CIPHER_CTX_key_length(ctx) * 8,
+                                    EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                     &amp;key-&gt;ks);
     else
         ret = aesni_set_decrypt_key(inkey,
-                                    EVP_CIPHER_CTX_key_length(ctx) * 8,
+                                    EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                     &amp;key-&gt;ks);
 
     SHA1_Init(&amp;key-&gt;head);      /* handy when benchmarking */
@@ -424,7 +424,7 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     if (len % AES_BLOCK_SIZE)
         return 0;
 
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
+    if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
         if (plen == NO_PAYLOAD_LENGTH)
             plen = len;
         else if (len !=
@@ -813,7 +813,7 @@ static int aesni_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
 
             len = p[arg - 2] &lt;&lt; 8 | p[arg - 1];
 
-            if (EVP_CIPHER_CTX_encrypting(ctx)) {
+            if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
                 key-&gt;payload_length = len;
                 if ((key-&gt;aux.tls_ver =
                      p[arg - 4] &lt;&lt; 8 | p[arg - 3]) &gt;= TLS1_1_VERSION) {
@@ -851,7 +851,7 @@ static int aesni_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
 
             inp_len = param-&gt;inp[11] &lt;&lt; 8 | param-&gt;inp[12];
 
-            if (EVP_CIPHER_CTX_encrypting(ctx)) {
+            if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
                 if ((param-&gt;inp[9] &lt;&lt; 8 | param-&gt;inp[10]) &lt; TLS1_1_VERSION)
                     return -1;
 
diff --git a/crypto/evp/e_aes_cbc_hmac_sha256.c b/crypto/evp/e_aes_cbc_hmac_sha256.c
index 82613cbff2..3a5f757dbf 100644
--- a/crypto/evp/e_aes_cbc_hmac_sha256.c
+++ b/crypto/evp/e_aes_cbc_hmac_sha256.c
@@ -71,11 +71,11 @@ static int aesni_cbc_hmac_sha256_init_key(EVP_CIPHER_CTX *ctx,
 
     if (enc)
         ret = aesni_set_encrypt_key(inkey,
-                                    EVP_CIPHER_CTX_key_length(ctx) * 8,
+                                    EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                     &amp;key-&gt;ks);
     else
         ret = aesni_set_decrypt_key(inkey,
-                                    EVP_CIPHER_CTX_key_length(ctx) * 8,
+                                    EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                     &amp;key-&gt;ks);
 
     SHA256_Init(&amp;key-&gt;head);    /* handy when benchmarking */
@@ -439,7 +439,7 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
     if (len % AES_BLOCK_SIZE)
         return 0;
 
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
+    if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
         if (plen == NO_PAYLOAD_LENGTH)
             plen = len;
         else if (len !=
@@ -794,7 +794,7 @@ static int aesni_cbc_hmac_sha256_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
 
             len = p[arg - 2] &lt;&lt; 8 | p[arg - 1];
 
-            if (EVP_CIPHER_CTX_encrypting(ctx)) {
+            if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
                 key-&gt;payload_length = len;
                 if ((key-&gt;aux.tls_ver =
                      p[arg - 4] &lt;&lt; 8 | p[arg - 3]) &gt;= TLS1_1_VERSION) {
@@ -835,7 +835,7 @@ static int aesni_cbc_hmac_sha256_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
 
             inp_len = param-&gt;inp[11] &lt;&lt; 8 | param-&gt;inp[12];
 
-            if (EVP_CIPHER_CTX_encrypting(ctx)) {
+            if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
                 if ((param-&gt;inp[9] &lt;&lt; 8 | param-&gt;inp[10]) &lt; TLS1_1_VERSION)
                     return -1;
 
diff --git a/crypto/evp/e_aria.c b/crypto/evp/e_aria.c
index e7ba2df78f..b57661db58 100644
--- a/crypto/evp/e_aria.c
+++ b/crypto/evp/e_aria.c
@@ -60,13 +60,15 @@ static int aria_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                             const unsigned char *iv, int enc)
 {
     int ret;
-    int mode = EVP_CIPHER_CTX_mode(ctx);
+    int mode = EVP_CIPHER_CTX_get_mode(ctx);
 
     if (enc || (mode != EVP_CIPH_ECB_MODE &amp;&amp; mode != EVP_CIPH_CBC_MODE))
-        ret = ossl_aria_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        ret = ossl_aria_set_encrypt_key(key,
+                                        EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                         EVP_CIPHER_CTX_get_cipher_data(ctx));
     else
-        ret = ossl_aria_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        ret = ossl_aria_set_decrypt_key(key,
+                                        EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                         EVP_CIPHER_CTX_get_cipher_data(ctx));
     if (ret &lt; 0) {
         ERR_raise(ERR_LIB_EVP,EVP_R_ARIA_KEY_SETUP_FAILED);
@@ -171,7 +173,7 @@ const EVP_CIPHER *EVP_aria_##keylen##_##mode(void) \
 static int aria_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                const unsigned char *in, size_t len)
 {
-    unsigned int num = EVP_CIPHER_CTX_num(ctx);
+    unsigned int num = EVP_CIPHER_CTX_get_num(ctx);
     EVP_ARIA_KEY *dat = EVP_C_DATA(EVP_ARIA_KEY, ctx);
 
     CRYPTO_ctr128_encrypt(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv,
@@ -212,7 +214,8 @@ static int aria_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     if (!iv &amp;&amp; !key)
         return 1;
     if (key) {
-        ret = ossl_aria_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        ret = ossl_aria_set_encrypt_key(key,
+                                        EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                         &amp;gctx-&gt;ks.ks);
         CRYPTO_gcm128_init(&amp;gctx-&gt;gcm, &amp;gctx-&gt;ks,
                            (block128_f) ossl_aria_encrypt);
@@ -251,7 +254,7 @@ static int aria_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
     case EVP_CTRL_INIT:
         gctx-&gt;key_set = 0;
         gctx-&gt;iv_set = 0;
-        gctx-&gt;ivlen = EVP_CIPHER_iv_length(c-&gt;cipher);
+        gctx-&gt;ivlen = EVP_CIPHER_get_iv_length(c-&gt;cipher);
         gctx-&gt;iv = c-&gt;iv;
         gctx-&gt;taglen = -1;
         gctx-&gt;iv_gen = 0;
@@ -278,14 +281,14 @@ static int aria_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         return 1;
 
     case EVP_CTRL_AEAD_SET_TAG:
-        if (arg &lt;= 0 || arg &gt; 16 || EVP_CIPHER_CTX_encrypting(c))
+        if (arg &lt;= 0 || arg &gt; 16 || EVP_CIPHER_CTX_is_encrypting(c))
             return 0;
         memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg);
         gctx-&gt;taglen = arg;
         return 1;
 
     case EVP_CTRL_AEAD_GET_TAG:
-        if (arg &lt;= 0 || arg &gt; 16 || !EVP_CIPHER_CTX_encrypting(c)
+        if (arg &lt;= 0 || arg &gt; 16 || !EVP_CIPHER_CTX_is_encrypting(c)
             || gctx-&gt;taglen &lt; 0)
             return 0;
         memcpy(ptr, EVP_CIPHER_CTX_buf_noconst(c), arg);
@@ -306,7 +309,7 @@ static int aria_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
             return 0;
         if (arg)
             memcpy(gctx-&gt;iv, ptr, arg);
-        if (EVP_CIPHER_CTX_encrypting(c)
+        if (EVP_CIPHER_CTX_is_encrypting(c)
             &amp;&amp; RAND_bytes(gctx-&gt;iv + arg, gctx-&gt;ivlen - arg) &lt;= 0)
             return 0;
         gctx-&gt;iv_gen = 1;
@@ -329,7 +332,7 @@ static int aria_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
 
     case EVP_CTRL_GCM_SET_IV_INV:
         if (gctx-&gt;iv_gen == 0 || gctx-&gt;key_set == 0
-            || EVP_CIPHER_CTX_encrypting(c))
+            || EVP_CIPHER_CTX_is_encrypting(c))
             return 0;
         memcpy(gctx-&gt;iv + gctx-&gt;ivlen - arg, ptr, arg);
         CRYPTO_gcm128_setiv(&amp;gctx-&gt;gcm, gctx-&gt;iv, gctx-&gt;ivlen);
@@ -351,7 +354,7 @@ static int aria_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
                 return 0;
             len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
             /* If decrypting correct for tag too */
-            if (!EVP_CIPHER_CTX_encrypting(c)) {
+            if (!EVP_CIPHER_CTX_is_encrypting(c)) {
                 if (len &lt; EVP_GCM_TLS_TAG_LEN)
                     return 0;
                 len -= EVP_GCM_TLS_TAG_LEN;
@@ -403,7 +406,7 @@ static int aria_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
      * Set IV from start of buffer or generate IV and write to start of
      * buffer.
      */
-    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CIPHER_CTX_encrypting(ctx) ?
+    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CIPHER_CTX_is_encrypting(ctx) ?
                             EVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV,
                             EVP_GCM_TLS_EXPLICIT_IV_LEN, out) &lt;= 0)
         goto err;
@@ -415,7 +418,7 @@ static int aria_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     in += EVP_GCM_TLS_EXPLICIT_IV_LEN;
     out += EVP_GCM_TLS_EXPLICIT_IV_LEN;
     len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
+    if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
         /* Encrypt payload */
         if (CRYPTO_gcm128_encrypt(&amp;gctx-&gt;gcm, in, out, len))
             goto err;
@@ -463,7 +466,7 @@ static int aria_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         if (out == NULL) {
             if (CRYPTO_gcm128_aad(&amp;gctx-&gt;gcm, in, len))
                 return -1;
-        } else if (EVP_CIPHER_CTX_encrypting(ctx)) {
+        } else if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
             if (CRYPTO_gcm128_encrypt(&amp;gctx-&gt;gcm, in, out, len))
                 return -1;
         } else {
@@ -472,7 +475,7 @@ static int aria_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         }
         return len;
     }
-    if (!EVP_CIPHER_CTX_encrypting(ctx)) {
+    if (!EVP_CIPHER_CTX_is_encrypting(ctx)) {
         if (gctx-&gt;taglen &lt; 0)
             return -1;
         if (CRYPTO_gcm128_finish(&amp;gctx-&gt;gcm,
@@ -509,7 +512,8 @@ static int aria_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         return 1;
 
     if (key) {
-        ret = ossl_aria_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
+        ret = ossl_aria_set_encrypt_key(key,
+                                        EVP_CIPHER_CTX_get_key_length(ctx) * 8,
                                         &amp;cctx-&gt;ks.ks);
         CRYPTO_ccm128_init(&amp;cctx-&gt;ccm, cctx-&gt;M, cctx-&gt;L,
                            &amp;cctx-&gt;ks, (block128_f) ossl_aria_encrypt);
@@ -561,7 +565,7 @@ static int aria_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
                 return 0;
             len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;
             /* If decrypting correct for tag too */
-            if (!EVP_CIPHER_CTX_encrypting(c)) {
+            if (!EVP_CIPHER_CTX_is_encrypting(c)) {
                 if (len &lt; cctx-&gt;M)
                     return 0;
                 len -= cctx-&gt;M;
@@ -591,7 +595,7 @@ static int aria_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
     case EVP_CTRL_AEAD_SET_TAG:
         if ((arg &amp; 1) || arg &lt; 4 || arg &gt; 16)
             return 0;
-        if (EVP_CIPHER_CTX_encrypting(c) &amp;&amp; ptr)
+        if (EVP_CIPHER_CTX_is_encrypting(c) &amp;&amp; ptr)
             return 0;
         if (ptr) {
             cctx-&gt;tag_set = 1;
@@ -601,7 +605,7 @@ static int aria_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
         return 1;
 
     case EVP_CTRL_AEAD_GET_TAG:
-        if (!EVP_CIPHER_CTX_encrypting(c) || !cctx-&gt;tag_set)
+        if (!EVP_CIPHER_CTX_is_encrypting(c) || !cctx-&gt;tag_set)
             return 0;
         if (!CRYPTO_ccm128_tag(&amp;cctx-&gt;ccm, ptr, (size_t)arg))
             return 0;
@@ -637,7 +641,7 @@ static int aria_ccm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     if (out != in || len &lt; (EVP_CCM_TLS_EXPLICIT_IV_LEN + (size_t)cctx-&gt;M))
         return -1;
     /* If encrypting set explicit IV from sequence number (start of AAD) */
-    if (EVP_CIPHER_CTX_encrypting(ctx))
+    if (EVP_CIPHER_CTX_is_encrypting(ctx))
         memcpy(out, EVP_CIPHER_CTX_buf_noconst(ctx),
                EVP_CCM_TLS_EXPLICIT_IV_LEN);
     /* Get rest of IV from explicit IV */
@@ -649,11 +653,12 @@ static int aria_ccm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             len))
             return -1;
     /* Use saved AAD */
-    CRYPTO_ccm128_aad(ccm, EVP_CIPHER_CTX_buf_noconst(ctx), cctx-&gt;tls_aad_len);
+    CRYPTO_ccm128_aad(ccm, EVP_CIPHER_CTX_buf_noconst(ctx),
+                      cctx-&gt;tls_aad_len);
     /* Fix buffer to point to payload */
     in += EVP_CCM_TLS_EXPLICIT_IV_LEN;
     out += EVP_CCM_TLS_EXPLICIT_IV_LEN;
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
+    if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
         if (cctx-&gt;str ? CRYPTO_ccm128_encrypt_ccm64(ccm, in, out, len, cctx-&gt;str)
                       : CRYPTO_ccm128_encrypt(ccm, in, out, len))
             return -1;
@@ -709,7 +714,7 @@ static int aria_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     }
 
     /* The tag must be set before actually decrypting data */
-    if (!EVP_CIPHER_CTX_encrypting(ctx) &amp;&amp; !cctx-&gt;tag_set)
+    if (!EVP_CIPHER_CTX_is_encrypting(ctx) &amp;&amp; !cctx-&gt;tag_set)
         return -1;
 
     /* If not set length yet do it */
@@ -718,7 +723,7 @@ static int aria_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             return -1;
         cctx-&gt;len_set = 1;
     }
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
+    if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
         if (cctx-&gt;str ? CRYPTO_ccm128_encrypt_ccm64(ccm, in, out, len, cctx-&gt;str)
                       : CRYPTO_ccm128_encrypt(ccm, in, out, len))
             return -1;
diff --git a/crypto/evp/e_bf.c b/crypto/evp/e_bf.c
index 9e240d1124..734e77f0a9 100644
--- a/crypto/evp/e_bf.c
+++ b/crypto/evp/e_bf.c
@@ -38,7 +38,7 @@ IMPLEMENT_BLOCK_CIPHER(bf, ks, BF, EVP_BF_KEY, NID_bf, 8, 16, 8, 64,
 static int bf_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                        const unsigned char *iv, int enc)
 {
-    BF_set_key(&amp;data(ctx)-&gt;ks, EVP_CIPHER_CTX_key_length(ctx), key);
+    BF_set_key(&amp;data(ctx)-&gt;ks, EVP_CIPHER_CTX_get_key_length(ctx), key);
     return 1;
 }
 
diff --git a/crypto/evp/e_camellia.c b/crypto/evp/e_camellia.c
index db2057a660..b2f59847d4 100644
--- a/crypto/evp/e_camellia.c
+++ b/crypto/evp/e_camellia.c
@@ -56,8 +56,8 @@ static int cmll_t4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     EVP_CAMELLIA_KEY *dat =
         (EVP_CAMELLIA_KEY *)EVP_CIPHER_CTX_get_cipher_data(ctx);
 
-    mode = EVP_CIPHER_CTX_mode(ctx);
-    bits = EVP_CIPHER_CTX_key_length(ctx) * 8;
+    mode = EVP_CIPHER_CTX_get_mode(ctx);
+    bits = EVP_CIPHER_CTX_get_key_length(ctx) * 8;
 
     cmll_t4_set_key(key, bits, &amp;dat-&gt;ks);
 
@@ -196,13 +196,14 @@ static int camellia_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     int ret, mode;
     EVP_CAMELLIA_KEY *dat = EVP_C_DATA(EVP_CAMELLIA_KEY,ctx);
 
-    ret = Camellia_set_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8, &amp;dat-&gt;ks);
+    ret = Camellia_set_key(key, EVP_CIPHER_CTX_get_key_length(ctx) * 8,
+                           &amp;dat-&gt;ks);
     if (ret &lt; 0) {
         ERR_raise(ERR_LIB_EVP, EVP_R_CAMELLIA_KEY_SETUP_FAILED);
         return 0;
     }
 
-    mode = EVP_CIPHER_CTX_mode(ctx);
+    mode = EVP_CIPHER_CTX_get_mode(ctx);
     if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)
         &amp;&amp; !enc) {
         dat-&gt;block = (block128_f) Camellia_decrypt;
@@ -224,8 +225,8 @@ static int camellia_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 
     if (dat-&gt;stream.cbc)
         (*dat-&gt;stream.cbc) (in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv,
-                            EVP_CIPHER_CTX_encrypting(ctx));
-    else if (EVP_CIPHER_CTX_encrypting(ctx))
+                            EVP_CIPHER_CTX_is_encrypting(ctx));
+    else if (EVP_CIPHER_CTX_is_encrypting(ctx))
         CRYPTO_cbc128_encrypt(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv, dat-&gt;block);
     else
         CRYPTO_cbc128_decrypt(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv, dat-&gt;block);
@@ -236,7 +237,7 @@ static int camellia_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 static int camellia_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                const unsigned char *in, size_t len)
 {
-    size_t bl = EVP_CIPHER_CTX_block_size(ctx);
+    size_t bl = EVP_CIPHER_CTX_get_block_size(ctx);
     size_t i;
     EVP_CAMELLIA_KEY *dat = EVP_C_DATA(EVP_CAMELLIA_KEY,ctx);
 
@@ -254,7 +255,7 @@ static int camellia_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 {
     EVP_CAMELLIA_KEY *dat = EVP_C_DATA(EVP_CAMELLIA_KEY,ctx);
 
-    int num = EVP_CIPHER_CTX_num(ctx);
+    int num = EVP_CIPHER_CTX_get_num(ctx);
     CRYPTO_ofb128_encrypt(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv, &amp;num, dat-&gt;block);
     EVP_CIPHER_CTX_set_num(ctx, num);
     return 1;
@@ -265,9 +266,9 @@ static int camellia_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 {
     EVP_CAMELLIA_KEY *dat = EVP_C_DATA(EVP_CAMELLIA_KEY,ctx);
 
-    int num = EVP_CIPHER_CTX_num(ctx);
+    int num = EVP_CIPHER_CTX_get_num(ctx);
     CRYPTO_cfb128_encrypt(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv, &amp;num,
-                          EVP_CIPHER_CTX_encrypting(ctx), dat-&gt;block);
+                          EVP_CIPHER_CTX_is_encrypting(ctx), dat-&gt;block);
     EVP_CIPHER_CTX_set_num(ctx, num);
     return 1;
 }
@@ -277,9 +278,9 @@ static int camellia_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 {
     EVP_CAMELLIA_KEY *dat = EVP_C_DATA(EVP_CAMELLIA_KEY,ctx);
 
-    int num = EVP_CIPHER_CTX_num(ctx);
+    int num = EVP_CIPHER_CTX_get_num(ctx);
     CRYPTO_cfb128_8_encrypt(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv, &amp;num,
-                            EVP_CIPHER_CTX_encrypting(ctx), dat-&gt;block);
+                            EVP_CIPHER_CTX_is_encrypting(ctx), dat-&gt;block);
     EVP_CIPHER_CTX_set_num(ctx, num);
     return 1;
 }
@@ -290,26 +291,31 @@ static int camellia_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     EVP_CAMELLIA_KEY *dat = EVP_C_DATA(EVP_CAMELLIA_KEY,ctx);
 
     if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS)) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         CRYPTO_cfb128_1_encrypt(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv, &amp;num,
-                                EVP_CIPHER_CTX_encrypting(ctx), dat-&gt;block);
+                                EVP_CIPHER_CTX_is_encrypting(ctx),
+                                dat-&gt;block);
         EVP_CIPHER_CTX_set_num(ctx, num);
         return 1;
     }
 
     while (len &gt;= MAXBITCHUNK) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         CRYPTO_cfb128_1_encrypt(in, out, MAXBITCHUNK * 8, &amp;dat-&gt;ks,
-                                ctx-&gt;iv, &amp;num, EVP_CIPHER_CTX_encrypting(ctx), dat-&gt;block);
+                                ctx-&gt;iv, &amp;num,
+                                EVP_CIPHER_CTX_is_encrypting(ctx),
+                                dat-&gt;block);
         EVP_CIPHER_CTX_set_num(ctx, num);
         len -= MAXBITCHUNK;
         out += MAXBITCHUNK;
         in  += MAXBITCHUNK;
     }
     if (len) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         CRYPTO_cfb128_1_encrypt(in, out, len * 8, &amp;dat-&gt;ks,
-                                ctx-&gt;iv, &amp;num, EVP_CIPHER_CTX_encrypting(ctx), dat-&gt;block);
+                                ctx-&gt;iv, &amp;num,
+                                EVP_CIPHER_CTX_is_encrypting(ctx),
+                                dat-&gt;block);
         EVP_CIPHER_CTX_set_num(ctx, num);
     }
 
@@ -319,7 +325,7 @@ static int camellia_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 static int camellia_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                const unsigned char *in, size_t len)
 {
-    int snum = EVP_CIPHER_CTX_num(ctx);
+    int snum = EVP_CIPHER_CTX_get_num(ctx);
     unsigned int num;
     EVP_CAMELLIA_KEY *dat = EVP_C_DATA(EVP_CAMELLIA_KEY,ctx);
 
@@ -328,7 +334,8 @@ static int camellia_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     num = snum;
     if (dat-&gt;stream.ctr)
         CRYPTO_ctr128_encrypt_ctr32(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv,
-                                    EVP_CIPHER_CTX_buf_noconst(ctx), &amp;num,
+                                    EVP_CIPHER_CTX_buf_noconst(ctx),
+                                    &amp;num,
                                     dat-&gt;stream.ctr);
     else
         CRYPTO_ctr128_encrypt(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv,
diff --git a/crypto/evp/e_cast.c b/crypto/evp/e_cast.c
index fd9dd0dc75..5e9be2dc7d 100644
--- a/crypto/evp/e_cast.c
+++ b/crypto/evp/e_cast.c
@@ -40,7 +40,7 @@ IMPLEMENT_BLOCK_CIPHER(cast5, ks, CAST, EVP_CAST_KEY,
 static int cast_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                          const unsigned char *iv, int enc)
 {
-    int keylen = EVP_CIPHER_CTX_key_length(ctx);
+    int keylen = EVP_CIPHER_CTX_get_key_length(ctx);
 
     if (keylen &lt;= 0)
         return 0;
diff --git a/crypto/evp/e_des.c b/crypto/evp/e_des.c
index d3b2206bb7..491d4511d8 100644
--- a/crypto/evp/e_des.c
+++ b/crypto/evp/e_des.c
@@ -65,7 +65,7 @@ static int des_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     BLOCK_CIPHER_ecb_loop()
         DES_ecb_encrypt((DES_cblock *)(in + i), (DES_cblock *)(out + i),
                         EVP_CIPHER_CTX_get_cipher_data(ctx),
-                        EVP_CIPHER_CTX_encrypting(ctx));
+                        EVP_CIPHER_CTX_is_encrypting(ctx));
     return 1;
 }
 
@@ -73,7 +73,7 @@ static int des_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                           const unsigned char *in, size_t inl)
 {
     while (inl &gt;= EVP_MAXCHUNK) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         DES_ofb64_encrypt(in, out, (long)EVP_MAXCHUNK,
                           EVP_CIPHER_CTX_get_cipher_data(ctx),
                           (DES_cblock *)ctx-&gt;iv, &amp;num);
@@ -83,7 +83,7 @@ static int des_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         out += EVP_MAXCHUNK;
     }
     if (inl) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         DES_ofb64_encrypt(in, out, (long)inl,
                           EVP_CIPHER_CTX_get_cipher_data(ctx),
                           (DES_cblock *)ctx-&gt;iv, &amp;num);
@@ -105,7 +105,7 @@ static int des_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_ncbc_encrypt(in, out, (long)EVP_MAXCHUNK,
                          EVP_CIPHER_CTX_get_cipher_data(ctx),
                          (DES_cblock *)ctx-&gt;iv,
-                         EVP_CIPHER_CTX_encrypting(ctx));
+                         EVP_CIPHER_CTX_is_encrypting(ctx));
         inl -= EVP_MAXCHUNK;
         in += EVP_MAXCHUNK;
         out += EVP_MAXCHUNK;
@@ -114,7 +114,7 @@ static int des_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_ncbc_encrypt(in, out, (long)inl,
                          EVP_CIPHER_CTX_get_cipher_data(ctx),
                          (DES_cblock *)ctx-&gt;iv,
-                         EVP_CIPHER_CTX_encrypting(ctx));
+                         EVP_CIPHER_CTX_is_encrypting(ctx));
     return 1;
 }
 
@@ -122,22 +122,22 @@ static int des_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t inl)
 {
     while (inl &gt;= EVP_MAXCHUNK) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         DES_cfb64_encrypt(in, out, (long)EVP_MAXCHUNK,
                           EVP_CIPHER_CTX_get_cipher_data(ctx),
                           (DES_cblock *)ctx-&gt;iv, &amp;num,
-                          EVP_CIPHER_CTX_encrypting(ctx));
+                          EVP_CIPHER_CTX_is_encrypting(ctx));
         EVP_CIPHER_CTX_set_num(ctx, num);
         inl -= EVP_MAXCHUNK;
         in += EVP_MAXCHUNK;
         out += EVP_MAXCHUNK;
     }
     if (inl) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         DES_cfb64_encrypt(in, out, (long)inl,
                           EVP_CIPHER_CTX_get_cipher_data(ctx),
                           (DES_cblock *)ctx-&gt;iv, &amp;num,
-                          EVP_CIPHER_CTX_encrypting(ctx));
+                          EVP_CIPHER_CTX_is_encrypting(ctx));
         EVP_CIPHER_CTX_set_num(ctx, num);
     }
     return 1;
@@ -161,7 +161,7 @@ static int des_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             c[0] = (in[n / 8] &amp; (1 &lt;&lt; (7 - n % 8))) ? 0x80 : 0;
             DES_cfb_encrypt(c, d, 1, 1, EVP_CIPHER_CTX_get_cipher_data(ctx),
                             (DES_cblock *)ctx-&gt;iv,
-                            EVP_CIPHER_CTX_encrypting(ctx));
+                            EVP_CIPHER_CTX_is_encrypting(ctx));
             out[n / 8] =
                 (out[n / 8] &amp; ~(0x80 &gt;&gt; (unsigned int)(n % 8))) |
                 ((d[0] &amp; 0x80) &gt;&gt; (unsigned int)(n % 8));
@@ -183,7 +183,7 @@ static int des_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_cfb_encrypt(in, out, 8, (long)EVP_MAXCHUNK,
                         EVP_CIPHER_CTX_get_cipher_data(ctx),
                         (DES_cblock *)ctx-&gt;iv,
-                        EVP_CIPHER_CTX_encrypting(ctx));
+                        EVP_CIPHER_CTX_is_encrypting(ctx));
         inl -= EVP_MAXCHUNK;
         in += EVP_MAXCHUNK;
         out += EVP_MAXCHUNK;
@@ -192,7 +192,7 @@ static int des_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_cfb_encrypt(in, out, 8, (long)inl,
                         EVP_CIPHER_CTX_get_cipher_data(ctx),
                         (DES_cblock *)ctx-&gt;iv,
-                        EVP_CIPHER_CTX_encrypting(ctx));
+                        EVP_CIPHER_CTX_is_encrypting(ctx));
     return 1;
 }
 
@@ -217,7 +217,7 @@ static int des_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     dat-&gt;stream.cbc = NULL;
 # if defined(SPARC_DES_CAPABLE)
     if (SPARC_DES_CAPABLE) {
-        int mode = EVP_CIPHER_CTX_mode(ctx);
+        int mode = EVP_CIPHER_CTX_get_mode(ctx);
 
         if (mode == EVP_CIPH_CBC_MODE) {
             des_t4_key_expand(key, &amp;dat-&gt;ks.ks);
diff --git a/crypto/evp/e_des3.c b/crypto/evp/e_des3.c
index 9043f3fb1b..746709fa41 100644
--- a/crypto/evp/e_des3.c
+++ b/crypto/evp/e_des3.c
@@ -75,7 +75,7 @@ static int des_ede_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_ecb3_encrypt((const_DES_cblock *)(in + i),
                          (DES_cblock *)(out + i),
                          &amp;data(ctx)-&gt;ks1, &amp;data(ctx)-&gt;ks2,
-                         &amp;data(ctx)-&gt;ks3, EVP_CIPHER_CTX_encrypting(ctx));
+                         &amp;data(ctx)-&gt;ks3, EVP_CIPHER_CTX_is_encrypting(ctx));
     return 1;
 }
 
@@ -83,7 +83,7 @@ static int des_ede_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                               const unsigned char *in, size_t inl)
 {
     while (inl &gt;= EVP_MAXCHUNK) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         DES_ede3_ofb64_encrypt(in, out, (long)EVP_MAXCHUNK,
                                &amp;data(ctx)-&gt;ks1, &amp;data(ctx)-&gt;ks2,
                                &amp;data(ctx)-&gt;ks3,
@@ -95,7 +95,7 @@ static int des_ede_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         out += EVP_MAXCHUNK;
     }
     if (inl) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         DES_ede3_ofb64_encrypt(in, out, (long)inl,
                                &amp;data(ctx)-&gt;ks1, &amp;data(ctx)-&gt;ks2,
                                &amp;data(ctx)-&gt;ks3,
@@ -121,7 +121,7 @@ static int des_ede_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_ede3_cbc_encrypt(in, out, (long)EVP_MAXCHUNK,
                              &amp;dat-&gt;ks1, &amp;dat-&gt;ks2, &amp;dat-&gt;ks3,
                              (DES_cblock *)ctx-&gt;iv,
-                             EVP_CIPHER_CTX_encrypting(ctx));
+                             EVP_CIPHER_CTX_is_encrypting(ctx));
         inl -= EVP_MAXCHUNK;
         in += EVP_MAXCHUNK;
         out += EVP_MAXCHUNK;
@@ -130,7 +130,7 @@ static int des_ede_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_ede3_cbc_encrypt(in, out, (long)inl,
                              &amp;dat-&gt;ks1, &amp;dat-&gt;ks2, &amp;dat-&gt;ks3,
                              (DES_cblock *)ctx-&gt;iv,
-                             EVP_CIPHER_CTX_encrypting(ctx));
+                             EVP_CIPHER_CTX_is_encrypting(ctx));
     return 1;
 }
 
@@ -138,22 +138,22 @@ static int des_ede_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                 const unsigned char *in, size_t inl)
 {
     while (inl &gt;= EVP_MAXCHUNK) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         DES_ede3_cfb64_encrypt(in, out, (long)EVP_MAXCHUNK,
                                &amp;data(ctx)-&gt;ks1, &amp;data(ctx)-&gt;ks2,
                                &amp;data(ctx)-&gt;ks3, (DES_cblock *)ctx-&gt;iv,
-                               &amp;num, EVP_CIPHER_CTX_encrypting(ctx));
+                               &amp;num, EVP_CIPHER_CTX_is_encrypting(ctx));
         EVP_CIPHER_CTX_set_num(ctx, num);
         inl -= EVP_MAXCHUNK;
         in += EVP_MAXCHUNK;
         out += EVP_MAXCHUNK;
     }
     if (inl) {
-        int num = EVP_CIPHER_CTX_num(ctx);
+        int num = EVP_CIPHER_CTX_get_num(ctx);
         DES_ede3_cfb64_encrypt(in, out, (long)inl,
                                &amp;data(ctx)-&gt;ks1, &amp;data(ctx)-&gt;ks2,
                                &amp;data(ctx)-&gt;ks3, (DES_cblock *)ctx-&gt;iv,
-                               &amp;num, EVP_CIPHER_CTX_encrypting(ctx));
+                               &amp;num, EVP_CIPHER_CTX_is_encrypting(ctx));
         EVP_CIPHER_CTX_set_num(ctx, num);
     }
     return 1;
@@ -176,7 +176,7 @@ static int des_ede3_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_ede3_cfb_encrypt(c, d, 1, 1,
                              &amp;data(ctx)-&gt;ks1, &amp;data(ctx)-&gt;ks2,
                              &amp;data(ctx)-&gt;ks3, (DES_cblock *)ctx-&gt;iv,
-                             EVP_CIPHER_CTX_encrypting(ctx));
+                             EVP_CIPHER_CTX_is_encrypting(ctx));
         out[n / 8] = (out[n / 8] &amp; ~(0x80 &gt;&gt; (unsigned int)(n % 8)))
             | ((d[0] &amp; 0x80) &gt;&gt; (unsigned int)(n % 8));
     }
@@ -191,7 +191,7 @@ static int des_ede3_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_ede3_cfb_encrypt(in, out, 8, (long)EVP_MAXCHUNK,
                              &amp;data(ctx)-&gt;ks1, &amp;data(ctx)-&gt;ks2,
                              &amp;data(ctx)-&gt;ks3, (DES_cblock *)ctx-&gt;iv,
-                             EVP_CIPHER_CTX_encrypting(ctx));
+                             EVP_CIPHER_CTX_is_encrypting(ctx));
         inl -= EVP_MAXCHUNK;
         in += EVP_MAXCHUNK;
         out += EVP_MAXCHUNK;
@@ -200,7 +200,7 @@ static int des_ede3_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_ede3_cfb_encrypt(in, out, 8, (long)inl,
                              &amp;data(ctx)-&gt;ks1, &amp;data(ctx)-&gt;ks2,
                              &amp;data(ctx)-&gt;ks3, (DES_cblock *)ctx-&gt;iv,
-                             EVP_CIPHER_CTX_encrypting(ctx));
+                             EVP_CIPHER_CTX_is_encrypting(ctx));
     return 1;
 }
 
@@ -232,7 +232,7 @@ static int des_ede_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     dat-&gt;stream.cbc = NULL;
 # if defined(SPARC_DES_CAPABLE)
     if (SPARC_DES_CAPABLE) {
-        int mode = EVP_CIPHER_CTX_mode(ctx);
+        int mode = EVP_CIPHER_CTX_get_mode(ctx);
 
         if (mode == EVP_CIPH_CBC_MODE) {
             des_t4_key_expand(&amp;deskey[0], &amp;dat-&gt;ks1);
@@ -259,7 +259,7 @@ static int des_ede3_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     dat-&gt;stream.cbc = NULL;
 # if defined(SPARC_DES_CAPABLE)
     if (SPARC_DES_CAPABLE) {
-        int mode = EVP_CIPHER_CTX_mode(ctx);
+        int mode = EVP_CIPHER_CTX_get_mode(ctx);
 
         if (mode == EVP_CIPH_CBC_MODE) {
             des_t4_key_expand(&amp;deskey[0], &amp;dat-&gt;ks1);
@@ -285,7 +285,7 @@ static int des3_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
 
     switch (type) {
     case EVP_CTRL_RAND_KEY:
-        kl = EVP_CIPHER_CTX_key_length(ctx);
+        kl = EVP_CIPHER_CTX_get_key_length(ctx);
         if (kl &lt; 0 || RAND_priv_bytes(ptr, kl) &lt;= 0)
             return 0;
         DES_set_odd_parity(deskey);
@@ -401,7 +401,7 @@ static int des_ede3_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         return 0;
     }
 
-    if (EVP_CIPHER_CTX_encrypting(ctx))
+    if (EVP_CIPHER_CTX_is_encrypting(ctx))
         return des_ede3_wrap(ctx, out, in, inl);
     else
         return des_ede3_unwrap(ctx, out, in, inl);
diff --git a/crypto/evp/e_idea.c b/crypto/evp/e_idea.c
index a4778a2c05..cf8746d357 100644
--- a/crypto/evp/e_idea.c
+++ b/crypto/evp/e_idea.c
@@ -58,9 +58,9 @@ static int idea_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                          const unsigned char *iv, int enc)
 {
     if (!enc) {
-        if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_OFB_MODE)
+        if (EVP_CIPHER_CTX_get_mode(ctx) == EVP_CIPH_OFB_MODE)
             enc = 1;
-        else if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_CFB_MODE)
+        else if (EVP_CIPHER_CTX_get_mode(ctx) == EVP_CIPH_CFB_MODE)
             enc = 1;
     }
     if (enc)
diff --git a/crypto/evp/e_rc2.c b/crypto/evp/e_rc2.c
index c935a49bbd..ffeb17fb1e 100644
--- a/crypto/evp/e_rc2.c
+++ b/crypto/evp/e_rc2.c
@@ -92,7 +92,7 @@ const EVP_CIPHER *EVP_rc2_40_cbc(void)
 static int rc2_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                         const unsigned char *iv, int enc)
 {
-    RC2_set_key(&amp;data(ctx)-&gt;ks, EVP_CIPHER_CTX_key_length(ctx),
+    RC2_set_key(&amp;data(ctx)-&gt;ks, EVP_CIPHER_CTX_get_key_length(ctx),
                 key, data(ctx)-&gt;key_bits);
     return 1;
 }
@@ -136,7 +136,7 @@ static int rc2_get_asn1_type_and_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
     unsigned char iv[EVP_MAX_IV_LENGTH];
 
     if (type != NULL) {
-        l = EVP_CIPHER_CTX_iv_length(c);
+        l = EVP_CIPHER_CTX_get_iv_length(c);
         OPENSSL_assert(l &lt;= sizeof(iv));
         i = ASN1_TYPE_get_int_octetstring(type, &amp;num, iv, l);
         if (i != (int)l)
@@ -161,7 +161,7 @@ static int rc2_set_asn1_type_and_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
 
     if (type != NULL) {
         num = rc2_meth_to_magic(c);
-        j = EVP_CIPHER_CTX_iv_length(c);
+        j = EVP_CIPHER_CTX_get_iv_length(c);
         i = ASN1_TYPE_set_int_octetstring(type, num, c-&gt;oiv, j);
     }
     return i;
@@ -171,7 +171,7 @@ static int rc2_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
 {
     switch (type) {
     case EVP_CTRL_INIT:
-        data(c)-&gt;key_bits = EVP_CIPHER_CTX_key_length(c) * 8;
+        data(c)-&gt;key_bits = EVP_CIPHER_CTX_get_key_length(c) * 8;
         return 1;
 
     case EVP_CTRL_GET_RC2_KEY_BITS:
diff --git a/crypto/evp/e_rc4.c b/crypto/evp/e_rc4.c
index ec07f028c5..e22e81d467 100644
--- a/crypto/evp/e_rc4.c
+++ b/crypto/evp/e_rc4.c
@@ -79,7 +79,7 @@ static int rc4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 {
     int keylen;
 
-    if ((keylen = EVP_CIPHER_CTX_key_length(ctx)) &lt;= 0)
+    if ((keylen = EVP_CIPHER_CTX_get_key_length(ctx)) &lt;= 0)
         return 0;
     RC4_set_key(&amp;data(ctx)-&gt;ks, keylen, key);
     return 1;
diff --git a/crypto/evp/e_rc4_hmac_md5.c b/crypto/evp/e_rc4_hmac_md5.c
index c8b6da246f..183ecefcec 100644
--- a/crypto/evp/e_rc4_hmac_md5.c
+++ b/crypto/evp/e_rc4_hmac_md5.c
@@ -46,7 +46,7 @@ static int rc4_hmac_md5_init_key(EVP_CIPHER_CTX *ctx,
                                  const unsigned char *iv, int enc)
 {
     EVP_RC4_HMAC_MD5 *key = data(ctx);
-    const int keylen = EVP_CIPHER_CTX_key_length(ctx);
+    const int keylen = EVP_CIPHER_CTX_get_key_length(ctx);
 
     if (keylen &lt;= 0)
         return 0;
@@ -88,7 +88,7 @@ static int rc4_hmac_md5_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     if (plen != NO_PAYLOAD_LENGTH &amp;&amp; len != (plen + MD5_DIGEST_LENGTH))
         return 0;
 
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
+    if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
         if (plen == NO_PAYLOAD_LENGTH)
             plen = len;
 # if defined(STITCHED_CALL)
@@ -228,7 +228,7 @@ static int rc4_hmac_md5_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
 
             len = p[arg - 2] &lt;&lt; 8 | p[arg - 1];
 
-            if (!EVP_CIPHER_CTX_encrypting(ctx)) {
+            if (!EVP_CIPHER_CTX_is_encrypting(ctx)) {
                 if (len &lt; MD5_DIGEST_LENGTH)
                     return -1;
                 len -= MD5_DIGEST_LENGTH;
diff --git a/crypto/evp/e_rc5.c b/crypto/evp/e_rc5.c
index aa5e9020de..20098a9225 100644
--- a/crypto/evp/e_rc5.c
+++ b/crypto/evp/e_rc5.c
@@ -72,11 +72,11 @@ static int rc5_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
 static int r_32_12_16_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                                const unsigned char *iv, int enc)
 {
-    if (EVP_CIPHER_CTX_key_length(ctx) &gt; 255) {
+    if (EVP_CIPHER_CTX_get_key_length(ctx) &gt; 255) {
         ERR_raise(ERR_LIB_EVP, EVP_R_BAD_KEY_LENGTH);
         return 0;
     }
-    return RC5_32_set_key(&amp;data(ctx)-&gt;ks, EVP_CIPHER_CTX_key_length(ctx),
+    return RC5_32_set_key(&amp;data(ctx)-&gt;ks, EVP_CIPHER_CTX_get_key_length(ctx),
                           key, data(ctx)-&gt;rounds);
 }
 
diff --git a/crypto/evp/e_sm4.c b/crypto/evp/e_sm4.c
index a3767573ce..a3ccc49f7e 100644
--- a/crypto/evp/e_sm4.c
+++ b/crypto/evp/e_sm4.c
@@ -72,7 +72,7 @@ IMPLEMENT_BLOCK_CIPHER(sm4, ks, sm4, EVP_SM4_KEY, NID_sm4,
 static int sm4_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                           const unsigned char *in, size_t len)
 {
-    unsigned int num = EVP_CIPHER_CTX_num(ctx);
+    unsigned int num = EVP_CIPHER_CTX_get_num(ctx);
     EVP_SM4_KEY *dat = EVP_C_DATA(EVP_SM4_KEY, ctx);
 
     CRYPTO_ctr128_encrypt(in, out, len, &amp;dat-&gt;ks, ctx-&gt;iv,
diff --git a/crypto/evp/e_xcbc_d.c b/crypto/evp/e_xcbc_d.c
index b1e6c2a168..f930941887 100644
--- a/crypto/evp/e_xcbc_d.c
+++ b/crypto/evp/e_xcbc_d.c
@@ -76,7 +76,7 @@ static int desx_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_xcbc_encrypt(in, out, (long)EVP_MAXCHUNK, &amp;data(ctx)-&gt;ks,
                          (DES_cblock *)ctx-&gt;iv,
                          &amp;data(ctx)-&gt;inw, &amp;data(ctx)-&gt;outw,
-                         EVP_CIPHER_CTX_encrypting(ctx));
+                         EVP_CIPHER_CTX_is_encrypting(ctx));
         inl -= EVP_MAXCHUNK;
         in += EVP_MAXCHUNK;
         out += EVP_MAXCHUNK;
@@ -85,7 +85,7 @@ static int desx_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         DES_xcbc_encrypt(in, out, (long)inl, &amp;data(ctx)-&gt;ks,
                          (DES_cblock *)ctx-&gt;iv,
                          &amp;data(ctx)-&gt;inw, &amp;data(ctx)-&gt;outw,
-                         EVP_CIPHER_CTX_encrypting(ctx));
+                         EVP_CIPHER_CTX_is_encrypting(ctx));
     return 1;
 }
 #endif
diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
index 356951014b..f39e9b8c90 100644
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -216,10 +216,10 @@ static int evp_cipher_init_internal(EVP_CIPHER_CTX *ctx,
         return ctx-&gt;cipher-&gt;einit(ctx-&gt;algctx,
                                   key,
                                   key == NULL ? 0
-                                              : EVP_CIPHER_CTX_key_length(ctx),
+                                              : EVP_CIPHER_CTX_get_key_length(ctx),
                                   iv,
                                   iv == NULL ? 0
-                                             : EVP_CIPHER_CTX_iv_length(ctx),
+                                             : EVP_CIPHER_CTX_get_iv_length(ctx),
                                   params);
     }
 
@@ -231,10 +231,10 @@ static int evp_cipher_init_internal(EVP_CIPHER_CTX *ctx,
     return ctx-&gt;cipher-&gt;dinit(ctx-&gt;algctx,
                               key,
                               key == NULL ? 0
-                                          : EVP_CIPHER_CTX_key_length(ctx),
+                                          : EVP_CIPHER_CTX_get_key_length(ctx),
                               iv,
                               iv == NULL ? 0
-                                         : EVP_CIPHER_CTX_iv_length(ctx),
+                                         : EVP_CIPHER_CTX_get_iv_length(ctx),
                                   params);
 
     /* Code below to be removed when legacy support is dropped. */
@@ -321,14 +321,14 @@ static int evp_cipher_init_internal(EVP_CIPHER_CTX *ctx,
                    || ctx-&gt;cipher-&gt;block_size == 16);
 
     if (!(ctx-&gt;flags &amp; EVP_CIPHER_CTX_FLAG_WRAP_ALLOW)
-        &amp;&amp; EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_WRAP_MODE) {
+        &amp;&amp; EVP_CIPHER_CTX_get_mode(ctx) == EVP_CIPH_WRAP_MODE) {
         ERR_raise(ERR_LIB_EVP, EVP_R_WRAP_MODE_NOT_ALLOWED);
         return 0;
     }
 
-    if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(ctx))
+    if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ctx))
                 &amp; EVP_CIPH_CUSTOM_IV) == 0) {
-        switch (EVP_CIPHER_CTX_mode(ctx)) {
+        switch (EVP_CIPHER_CTX_get_mode(ctx)) {
 
         case EVP_CIPH_STREAM_CIPHER:
         case EVP_CIPH_ECB_MODE:
@@ -341,19 +341,19 @@ static int evp_cipher_init_internal(EVP_CIPHER_CTX *ctx,
             /* fall-through */
 
         case EVP_CIPH_CBC_MODE:
-            n = EVP_CIPHER_CTX_iv_length(ctx);
+            n = EVP_CIPHER_CTX_get_iv_length(ctx);
             if (!ossl_assert(n &gt;= 0 &amp;&amp; n &lt;= (int)sizeof(ctx-&gt;iv)))
                     return 0;
             if (iv)
-                memcpy(ctx-&gt;oiv, iv, EVP_CIPHER_CTX_iv_length(ctx));
-            memcpy(ctx-&gt;iv, ctx-&gt;oiv, EVP_CIPHER_CTX_iv_length(ctx));
+                memcpy(ctx-&gt;oiv, iv, EVP_CIPHER_CTX_get_iv_length(ctx));
+            memcpy(ctx-&gt;iv, ctx-&gt;oiv, EVP_CIPHER_CTX_get_iv_length(ctx));
             break;
 
         case EVP_CIPH_CTR_MODE:
             ctx-&gt;num = 0;
             /* Don't reuse IV for CTR mode */
             if (iv)
-                memcpy(ctx-&gt;iv, iv, EVP_CIPHER_CTX_iv_length(ctx));
+                memcpy(ctx-&gt;iv, iv, EVP_CIPHER_CTX_get_iv_length(ctx));
             break;
 
         default:
@@ -674,7 +674,7 @@ int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
     if (ctx-&gt;cipher-&gt;prov == NULL)
         goto legacy;
 
-    blocksize = EVP_CIPHER_CTX_block_size(ctx);
+    blocksize = EVP_CIPHER_CTX_get_block_size(ctx);
 
     if (blocksize &lt; 1 || ctx-&gt;cipher-&gt;cfinal == NULL) {
         ERR_raise(ERR_LIB_EVP, EVP_R_FINAL_ERROR);
@@ -761,7 +761,7 @@ int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
     if (ctx-&gt;cipher-&gt;prov == NULL)
         goto legacy;
 
-    blocksize = EVP_CIPHER_CTX_block_size(ctx);
+    blocksize = EVP_CIPHER_CTX_get_block_size(ctx);
 
     if (ctx-&gt;cipher-&gt;cupdate == NULL || blocksize &lt; 1) {
         ERR_raise(ERR_LIB_EVP, EVP_R_UPDATE_ERROR);
@@ -896,7 +896,7 @@ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
     if (ctx-&gt;cipher-&gt;prov == NULL)
         goto legacy;
 
-    blocksize = EVP_CIPHER_CTX_block_size(ctx);
+    blocksize = EVP_CIPHER_CTX_get_block_size(ctx);
 
     if (blocksize &lt; 1 || ctx-&gt;cipher-&gt;cfinal == NULL) {
         ERR_raise(ERR_LIB_EVP, EVP_R_FINAL_ERROR);
@@ -976,7 +976,7 @@ int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)
         OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
         size_t len = keylen;
 
-        if (EVP_CIPHER_CTX_key_length(c) == keylen)
+        if (EVP_CIPHER_CTX_get_key_length(c) == keylen)
             return 1;
 
         /* Check the cipher actually understands this parameter */
@@ -998,7 +998,7 @@ int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)
      */
     if (c-&gt;cipher-&gt;flags &amp; EVP_CIPH_CUSTOM_KEY_LENGTH)
         return EVP_CIPHER_CTX_ctrl(c, EVP_CTRL_SET_KEY_LENGTH, keylen, NULL);
-    if (EVP_CIPHER_CTX_key_length(c) == keylen)
+    if (EVP_CIPHER_CTX_get_key_length(c) == keylen)
         return 1;
     if ((keylen &gt; 0) &amp;&amp; (c-&gt;cipher-&gt;flags &amp; EVP_CIPH_VARIABLE_LENGTH)) {
         c-&gt;key_len = keylen;
@@ -1257,7 +1257,7 @@ const OSSL_PARAM *EVP_CIPHER_gettable_params(const EVP_CIPHER *cipher)
 {
     if (cipher != NULL &amp;&amp; cipher-&gt;gettable_params != NULL)
         return cipher-&gt;gettable_params(
-                   ossl_provider_ctx(EVP_CIPHER_provider(cipher)));
+                   ossl_provider_ctx(EVP_CIPHER_get0_provider(cipher)));
     return NULL;
 }
 
@@ -1266,7 +1266,7 @@ const OSSL_PARAM *EVP_CIPHER_settable_ctx_params(const EVP_CIPHER *cipher)
     void *provctx;
 
     if (cipher != NULL &amp;&amp; cipher-&gt;settable_ctx_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_CIPHER_provider(cipher));
+        provctx = ossl_provider_ctx(EVP_CIPHER_get0_provider(cipher));
         return cipher-&gt;settable_ctx_params(NULL, provctx);
     }
     return NULL;
@@ -1277,7 +1277,7 @@ const OSSL_PARAM *EVP_CIPHER_gettable_ctx_params(const EVP_CIPHER *cipher)
     void *provctx;
 
     if (cipher != NULL &amp;&amp; cipher-&gt;gettable_ctx_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_CIPHER_provider(cipher));
+        provctx = ossl_provider_ctx(EVP_CIPHER_get0_provider(cipher));
         return cipher-&gt;gettable_ctx_params(NULL, provctx);
     }
     return NULL;
@@ -1288,7 +1288,7 @@ const OSSL_PARAM *EVP_CIPHER_CTX_settable_params(EVP_CIPHER_CTX *cctx)
     void *alg;
 
     if (cctx != NULL &amp;&amp; cctx-&gt;cipher-&gt;settable_ctx_params != NULL) {
-        alg = ossl_provider_ctx(EVP_CIPHER_provider(cctx-&gt;cipher));
+        alg = ossl_provider_ctx(EVP_CIPHER_get0_provider(cctx-&gt;cipher));
         return cctx-&gt;cipher-&gt;settable_ctx_params(cctx-&gt;algctx, alg);
     }
     return NULL;
@@ -1299,7 +1299,7 @@ const OSSL_PARAM *EVP_CIPHER_CTX_gettable_params(EVP_CIPHER_CTX *cctx)
     void *provctx;
 
     if (cctx != NULL &amp;&amp; cctx-&gt;cipher-&gt;gettable_ctx_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_CIPHER_provider(cctx-&gt;cipher));
+        provctx = ossl_provider_ctx(EVP_CIPHER_get0_provider(cctx-&gt;cipher));
         return cctx-&gt;cipher-&gt;gettable_ctx_params(cctx-&gt;algctx, provctx);
     }
     return NULL;
@@ -1314,7 +1314,7 @@ static OSSL_LIB_CTX *EVP_CIPHER_CTX_get_libctx(EVP_CIPHER_CTX *ctx)
     if (cipher == NULL)
         return NULL;
 
-    prov = EVP_CIPHER_provider(cipher);
+    prov = EVP_CIPHER_get0_provider(cipher);
     return ossl_provider_libctx(prov);
 }
 #endif
@@ -1331,7 +1331,7 @@ int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key)
         int kl;
         OSSL_LIB_CTX *libctx = EVP_CIPHER_CTX_get_libctx(ctx);
 
-        kl = EVP_CIPHER_CTX_key_length(ctx);
+        kl = EVP_CIPHER_CTX_get_key_length(ctx);
         if (kl &lt;= 0 || RAND_priv_bytes_ex(libctx, key, kl, 0) &lt;= 0)
             return 0;
         return 1;
@@ -1442,7 +1442,7 @@ static void set_legacy_nid(const char *name, void *vlegacy_nid)
         return;
     if (legacy_method == NULL)
         return;
-    nid = EVP_CIPHER_nid(legacy_method);
+    nid = EVP_CIPHER_get_nid(legacy_method);
     if (*legacy_nid != NID_undef &amp;&amp; *legacy_nid != nid) {
         *legacy_nid = -1;
         return;
diff --git a/crypto/evp/evp_key.c b/crypto/evp/evp_key.c
index 3aa49aa47e..acbe92dac1 100644
--- a/crypto/evp/evp_key.c
+++ b/crypto/evp/evp_key.c
@@ -85,8 +85,8 @@ int EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,
     int niv, nkey, addmd = 0;
     unsigned int mds = 0, i;
     int rv = 0;
-    nkey = EVP_CIPHER_key_length(type);
-    niv = EVP_CIPHER_iv_length(type);
+    nkey = EVP_CIPHER_get_key_length(type);
+    niv = EVP_CIPHER_get_iv_length(type);
     OPENSSL_assert(nkey &lt;= EVP_MAX_KEY_LENGTH);
     OPENSSL_assert(niv &lt;= EVP_MAX_IV_LENGTH);
 
@@ -146,7 +146,7 @@ int EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,
         if ((nkey == 0) &amp;&amp; (niv == 0))
             break;
     }
-    rv = EVP_CIPHER_key_length(type);
+    rv = EVP_CIPHER_get_key_length(type);
  err:
     EVP_MD_CTX_free(c);
     OPENSSL_cleanse(md_buf, sizeof(md_buf));
diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
index bc872c0e79..8a03c4490b 100644
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -49,7 +49,7 @@ int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *ctx, ASN1_TYPE *type)
     if (type != NULL) {
         unsigned char iv[EVP_MAX_IV_LENGTH];
 
-        l = EVP_CIPHER_CTX_iv_length(ctx);
+        l = EVP_CIPHER_CTX_get_iv_length(ctx);
         if (!ossl_assert(l &lt;= sizeof(iv)))
             return -1;
         i = ASN1_TYPE_get_octetstring(type, iv, l);
@@ -70,7 +70,7 @@ int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
 
     if (type != NULL) {
         oiv = (unsigned char *)EVP_CIPHER_CTX_original_iv(c);
-        j = EVP_CIPHER_CTX_iv_length(c);
+        j = EVP_CIPHER_CTX_get_iv_length(c);
         OPENSSL_assert(j &lt;= sizeof(c-&gt;iv));
         i = ASN1_TYPE_set_octetstring(type, oiv, j);
     }
@@ -101,8 +101,8 @@ int evp_cipher_param_to_asn1_ex(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
      */
     if (cipher-&gt;set_asn1_parameters != NULL) {
         ret = cipher-&gt;set_asn1_parameters(c, type);
-    } else if ((EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_CUSTOM_ASN1) == 0) {
-        switch (EVP_CIPHER_mode(cipher)) {
+    } else if ((EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_CUSTOM_ASN1) == 0) {
+        switch (EVP_CIPHER_get_mode(cipher)) {
         case EVP_CIPH_WRAP_MODE:
             if (EVP_CIPHER_is_a(cipher, SN_id_smime_alg_CMS3DESwrap))
                 ASN1_TYPE_set(type, V_ASN1_NULL, NULL);
@@ -192,8 +192,8 @@ int evp_cipher_asn1_to_param_ex(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
      */
     if (cipher-&gt;get_asn1_parameters != NULL) {
         ret = cipher-&gt;get_asn1_parameters(c, type);
-    } else if ((EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_CUSTOM_ASN1) == 0) {
-        switch (EVP_CIPHER_mode(cipher)) {
+    } else if ((EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_CUSTOM_ASN1) == 0) {
+        switch (EVP_CIPHER_get_mode(cipher)) {
         case EVP_CIPH_WRAP_MODE:
             ret = 1;
             break;
@@ -273,10 +273,10 @@ int evp_cipher_set_asn1_aead_params(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
 #endif /* !defined(FIPS_MODULE) */
 
 /* Convert the various cipher NIDs and dummies to a proper OID NID */
-int EVP_CIPHER_type(const EVP_CIPHER *cipher)
+int EVP_CIPHER_get_type(const EVP_CIPHER *cipher)
 {
     int nid;
-    nid = EVP_CIPHER_nid(cipher);
+    nid = EVP_CIPHER_get_nid(cipher);
 
     switch (nid) {
 
@@ -381,14 +381,14 @@ int evp_cipher_cache_constants(EVP_CIPHER *cipher)
     return ok;
 }
 
-int EVP_CIPHER_block_size(const EVP_CIPHER *cipher)
+int EVP_CIPHER_get_block_size(const EVP_CIPHER *cipher)
 {
     return cipher-&gt;block_size;
 }
 
-int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx)
+int EVP_CIPHER_CTX_get_block_size(const EVP_CIPHER_CTX *ctx)
 {
-    return EVP_CIPHER_block_size(ctx-&gt;cipher);
+    return EVP_CIPHER_get_block_size(ctx-&gt;cipher);
 }
 
 int EVP_CIPHER_impl_ctx_size(const EVP_CIPHER *e)
@@ -409,7 +409,7 @@ int EVP_Cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
          */
         int ret = -1;
         size_t outl = 0;
-        size_t blocksize = EVP_CIPHER_CTX_block_size(ctx);
+        size_t blocksize = EVP_CIPHER_CTX_get_block_size(ctx);
 
         if (ctx-&gt;cipher-&gt;ccipher != NULL)
             ret =  ctx-&gt;cipher-&gt;ccipher(ctx-&gt;algctx, out, &amp;outl,
@@ -458,12 +458,12 @@ EVP_CIPHER *EVP_CIPHER_CTX_get1_cipher(EVP_CIPHER_CTX *ctx)
     return cipher;
 }
 
-int EVP_CIPHER_CTX_encrypting(const EVP_CIPHER_CTX *ctx)
+int EVP_CIPHER_CTX_is_encrypting(const EVP_CIPHER_CTX *ctx)
 {
     return ctx-&gt;encrypt;
 }
 
-unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher)
+unsigned long EVP_CIPHER_get_flags(const EVP_CIPHER *cipher)
 {
     return cipher-&gt;flags;
 }
@@ -493,14 +493,14 @@ void *EVP_CIPHER_CTX_set_cipher_data(EVP_CIPHER_CTX *ctx, void *cipher_data)
     return old_cipher_data;
 }
 
-int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher)
+int EVP_CIPHER_get_iv_length(const EVP_CIPHER *cipher)
 {
     return cipher-&gt;iv_len;
 }
 
-int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx)
+int EVP_CIPHER_CTX_get_iv_length(const EVP_CIPHER_CTX *ctx)
 {
-    int rv, len = EVP_CIPHER_iv_length(ctx-&gt;cipher);
+    int rv, len = EVP_CIPHER_get_iv_length(ctx-&gt;cipher);
     size_t v = len;
     OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
@@ -511,7 +511,7 @@ int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx)
     return rv != 0 ? (int)v : -1;
     /* Code below to be removed when legacy support is dropped. */
 legacy:
-    if ((EVP_CIPHER_flags(ctx-&gt;cipher) &amp; EVP_CIPH_CUSTOM_IV_LENGTH) != 0) {
+    if ((EVP_CIPHER_get_flags(ctx-&gt;cipher) &amp; EVP_CIPH_CUSTOM_IV_LENGTH) != 0) {
         rv = EVP_CIPHER_CTX_ctrl((EVP_CIPHER_CTX *)ctx, EVP_CTRL_GET_IVLEN,
                                  0, &amp;len);
         return (rv == 1) ? len : -1;
@@ -519,7 +519,7 @@ legacy:
     return len;
 }
 
-int EVP_CIPHER_CTX_tag_length(const EVP_CIPHER_CTX *ctx)
+int EVP_CIPHER_CTX_get_tag_length(const EVP_CIPHER_CTX *ctx)
 {
     int ret;
     size_t v = 0;
@@ -600,7 +600,7 @@ unsigned char *EVP_CIPHER_CTX_buf_noconst(EVP_CIPHER_CTX *ctx)
     return ctx-&gt;buf;
 }
 
-int EVP_CIPHER_CTX_num(const EVP_CIPHER_CTX *ctx)
+int EVP_CIPHER_CTX_get_num(const EVP_CIPHER_CTX *ctx)
 {
     int ok;
     unsigned int v = (unsigned int)ctx-&gt;num;
@@ -626,12 +626,12 @@ int EVP_CIPHER_CTX_set_num(EVP_CIPHER_CTX *ctx, int num)
     return ok != 0;
 }
 
-int EVP_CIPHER_key_length(const EVP_CIPHER *cipher)
+int EVP_CIPHER_get_key_length(const EVP_CIPHER *cipher)
 {
     return cipher-&gt;key_len;
 }
 
-int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx)
+int EVP_CIPHER_CTX_get_key_length(const EVP_CIPHER_CTX *ctx)
 {
     int ok;
     size_t v = ctx-&gt;key_len;
@@ -643,12 +643,12 @@ int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx)
     return ok != 0 ? (int)v : EVP_CTRL_RET_UNSUPPORTED;
 }
 
-int EVP_CIPHER_nid(const EVP_CIPHER *cipher)
+int EVP_CIPHER_get_nid(const EVP_CIPHER *cipher)
 {
     return cipher-&gt;nid;
 }
 
-int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx)
+int EVP_CIPHER_CTX_get_nid(const EVP_CIPHER_CTX *ctx)
 {
     return ctx-&gt;cipher-&gt;nid;
 }
@@ -657,31 +657,31 @@ int EVP_CIPHER_is_a(const EVP_CIPHER *cipher, const char *name)
 {
     if (cipher-&gt;prov != NULL)
         return evp_is_a(cipher-&gt;prov, cipher-&gt;name_id, NULL, name);
-    return evp_is_a(NULL, 0, EVP_CIPHER_name(cipher), name);
+    return evp_is_a(NULL, 0, EVP_CIPHER_get0_name(cipher), name);
 }
 
-int EVP_CIPHER_number(const EVP_CIPHER *cipher)
+int EVP_CIPHER_get_number(const EVP_CIPHER *cipher)
 {
     return cipher-&gt;name_id;
 }
 
-const char *EVP_CIPHER_name(const EVP_CIPHER *cipher)
+const char *EVP_CIPHER_get0_name(const EVP_CIPHER *cipher)
 {
     if (cipher-&gt;type_name != NULL)
         return cipher-&gt;type_name;
 #ifndef FIPS_MODULE
-    return OBJ_nid2sn(EVP_CIPHER_nid(cipher));
+    return OBJ_nid2sn(EVP_CIPHER_get_nid(cipher));
 #else
     return NULL;
 #endif
 }
 
-const char *EVP_CIPHER_description(const EVP_CIPHER *cipher)
+const char *EVP_CIPHER_get0_description(const EVP_CIPHER *cipher)
 {
     if (cipher-&gt;description != NULL)
         return cipher-&gt;description;
 #ifndef FIPS_MODULE
-    return OBJ_nid2ln(EVP_CIPHER_nid(cipher));
+    return OBJ_nid2ln(EVP_CIPHER_get_nid(cipher));
 #else
     return NULL;
 #endif
@@ -697,29 +697,29 @@ int EVP_CIPHER_names_do_all(const EVP_CIPHER *cipher,
     return 1;
 }
 
-const OSSL_PROVIDER *EVP_CIPHER_provider(const EVP_CIPHER *cipher)
+const OSSL_PROVIDER *EVP_CIPHER_get0_provider(const EVP_CIPHER *cipher)
 {
     return cipher-&gt;prov;
 }
 
-int EVP_CIPHER_mode(const EVP_CIPHER *cipher)
+int EVP_CIPHER_get_mode(const EVP_CIPHER *cipher)
 {
-    return EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_MODE;
+    return EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_MODE;
 }
 
 int EVP_MD_is_a(const EVP_MD *md, const char *name)
 {
     if (md-&gt;prov != NULL)
         return evp_is_a(md-&gt;prov, md-&gt;name_id, NULL, name);
-    return evp_is_a(NULL, 0, EVP_MD_name(md), name);
+    return evp_is_a(NULL, 0, EVP_MD_get0_name(md), name);
 }
 
-int EVP_MD_number(const EVP_MD *md)
+int EVP_MD_get_number(const EVP_MD *md)
 {
     return md-&gt;name_id;
 }
 
-const char *EVP_MD_description(const EVP_MD *md)
+const char *EVP_MD_get0_description(const EVP_MD *md)
 {
     if (md-&gt;description != NULL)
         return md-&gt;description;
@@ -730,7 +730,7 @@ const char *EVP_MD_description(const EVP_MD *md)
 #endif
 }
 
-const char *EVP_MD_name(const EVP_MD *md)
+const char *EVP_MD_get0_name(const EVP_MD *md)
 {
     if (md == NULL)
         return NULL;
@@ -753,22 +753,22 @@ int EVP_MD_names_do_all(const EVP_MD *md,
     return 1;
 }
 
-const OSSL_PROVIDER *EVP_MD_provider(const EVP_MD *md)
+const OSSL_PROVIDER *EVP_MD_get0_provider(const EVP_MD *md)
 {
     return md-&gt;prov;
 }
 
-int EVP_MD_type(const EVP_MD *md)
+int EVP_MD_get_type(const EVP_MD *md)
 {
     return md-&gt;type;
 }
 
-int EVP_MD_pkey_type(const EVP_MD *md)
+int EVP_MD_get_pkey_type(const EVP_MD *md)
 {
     return md-&gt;pkey_type;
 }
 
-int EVP_MD_block_size(const EVP_MD *md)
+int EVP_MD_get_block_size(const EVP_MD *md)
 {
     if (md == NULL) {
         ERR_raise(ERR_LIB_EVP, EVP_R_MESSAGE_DIGEST_IS_NULL);
@@ -777,7 +777,7 @@ int EVP_MD_block_size(const EVP_MD *md)
     return md-&gt;block_size;
 }
 
-int EVP_MD_size(const EVP_MD *md)
+int EVP_MD_get_size(const EVP_MD *md)
 {
     if (md == NULL) {
         ERR_raise(ERR_LIB_EVP, EVP_R_MESSAGE_DIGEST_IS_NULL);
@@ -786,7 +786,7 @@ int EVP_MD_size(const EVP_MD *md)
     return md-&gt;md_size;
 }
 
-unsigned long EVP_MD_flags(const EVP_MD *md)
+unsigned long EVP_MD_get_flags(const EVP_MD *md)
 {
     return md-&gt;flags;
 }
@@ -999,7 +999,7 @@ EVP_MD *EVP_MD_CTX_get1_md(EVP_MD_CTX *ctx)
     return md;
 }
 
-EVP_PKEY_CTX *EVP_MD_CTX_pkey_ctx(const EVP_MD_CTX *ctx)
+EVP_PKEY_CTX *EVP_MD_CTX_get_pkey_ctx(const EVP_MD_CTX *ctx)
 {
     return ctx-&gt;pctx;
 }
@@ -1025,7 +1025,7 @@ void EVP_MD_CTX_set_pkey_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pctx)
 }
 #endif /* !defined(FIPS_MODULE) */
 
-void *EVP_MD_CTX_md_data(const EVP_MD_CTX *ctx)
+void *EVP_MD_CTX_get0_md_data(const EVP_MD_CTX *ctx)
 {
     return ctx-&gt;md_data;
 }
diff --git a/crypto/evp/evp_local.h b/crypto/evp/evp_local.h
index a0f363805c..137e458f5a 100644
--- a/crypto/evp/evp_local.h
+++ b/crypto/evp/evp_local.h
@@ -325,7 +325,7 @@ OSSL_PARAM *evp_pkey_to_param(EVP_PKEY *pkey, size_t *sz);
 
 #define M_check_autoarg(ctx, arg, arglen, err) \
     if (ctx-&gt;pmeth-&gt;flags &amp; EVP_PKEY_FLAG_AUTOARGLEN) {           \
-        size_t pksize = (size_t)EVP_PKEY_size(ctx-&gt;pkey);         \
+        size_t pksize = (size_t)EVP_PKEY_get_size(ctx-&gt;pkey);         \
                                                                   \
         if (pksize == 0) {                                        \
             ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_KEY); /*ckerr_ignore*/ \
diff --git a/crypto/evp/evp_pbe.c b/crypto/evp/evp_pbe.c
index 129888f2f7..e19b781645 100644
--- a/crypto/evp/evp_pbe.c
+++ b/crypto/evp/evp_pbe.c
@@ -226,11 +226,11 @@ int EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md,
     int cipher_nid, md_nid;
 
     if (cipher)
-        cipher_nid = EVP_CIPHER_nid(cipher);
+        cipher_nid = EVP_CIPHER_get_nid(cipher);
     else
         cipher_nid = -1;
     if (md)
-        md_nid = EVP_MD_type(md);
+        md_nid = EVP_MD_get_type(md);
     else
         md_nid = -1;
 
diff --git a/crypto/evp/evp_pkey.c b/crypto/evp/evp_pkey.c
index f82d6f8081..420b69399a 100644
--- a/crypto/evp/evp_pkey.c
+++ b/crypto/evp/evp_pkey.c
@@ -225,7 +225,7 @@ const char *EVP_PKEY_get0_type_name(const EVP_PKEY *key)
     const char *name = NULL;
 
     if (key-&gt;keymgmt != NULL)
-        return EVP_KEYMGMT_name(key-&gt;keymgmt);
+        return EVP_KEYMGMT_get0_name(key-&gt;keymgmt);
 
     /* Otherwise fallback to legacy */
     ameth = EVP_PKEY_get0_asn1(key);
diff --git a/crypto/evp/evp_rand.c b/crypto/evp/evp_rand.c
index c886d9a563..1e41fe0765 100644
--- a/crypto/evp/evp_rand.c
+++ b/crypto/evp/evp_rand.c
@@ -293,17 +293,17 @@ void EVP_RAND_free(EVP_RAND *rand)
     evp_rand_free(rand);
 }
 
-int EVP_RAND_number(const EVP_RAND *rand)
+int EVP_RAND_get_number(const EVP_RAND *rand)
 {
     return rand-&gt;name_id;
 }
 
-const char *EVP_RAND_name(const EVP_RAND *rand)
+const char *EVP_RAND_get0_name(const EVP_RAND *rand)
 {
     return rand-&gt;type_name;
 }
 
-const char *EVP_RAND_description(const EVP_RAND *rand)
+const char *EVP_RAND_get0_description(const EVP_RAND *rand)
 {
     return rand-&gt;description;
 }
@@ -313,7 +313,7 @@ int EVP_RAND_is_a(const EVP_RAND *rand, const char *name)
     return evp_is_a(rand-&gt;prov, rand-&gt;name_id, NULL, name);
 }
 
-const OSSL_PROVIDER *EVP_RAND_provider(const EVP_RAND *rand)
+const OSSL_PROVIDER *EVP_RAND_get0_provider(const EVP_RAND *rand)
 {
     return rand-&gt;prov;
 }
@@ -395,7 +395,7 @@ void EVP_RAND_CTX_free(EVP_RAND_CTX *ctx)
     EVP_RAND_CTX_free(parent);
 }
 
-EVP_RAND *EVP_RAND_CTX_rand(EVP_RAND_CTX *ctx)
+EVP_RAND *EVP_RAND_CTX_get0_rand(EVP_RAND_CTX *ctx)
 {
     return ctx-&gt;meth;
 }
@@ -440,7 +440,7 @@ const OSSL_PARAM *EVP_RAND_gettable_params(const EVP_RAND *rand)
 {
     if (rand-&gt;gettable_params == NULL)
         return NULL;
-    return rand-&gt;gettable_params(ossl_provider_ctx(EVP_RAND_provider(rand)));
+    return rand-&gt;gettable_params(ossl_provider_ctx(EVP_RAND_get0_provider(rand)));
 }
 
 const OSSL_PARAM *EVP_RAND_gettable_ctx_params(const EVP_RAND *rand)
@@ -449,7 +449,7 @@ const OSSL_PARAM *EVP_RAND_gettable_ctx_params(const EVP_RAND *rand)
 
     if (rand-&gt;gettable_ctx_params == NULL)
         return NULL;
-    provctx = ossl_provider_ctx(EVP_RAND_provider(rand));
+    provctx = ossl_provider_ctx(EVP_RAND_get0_provider(rand));
     return rand-&gt;gettable_ctx_params(NULL, provctx);
 }
 
@@ -459,7 +459,7 @@ const OSSL_PARAM *EVP_RAND_settable_ctx_params(const EVP_RAND *rand)
 
     if (rand-&gt;settable_ctx_params == NULL)
         return NULL;
-    provctx = ossl_provider_ctx(EVP_RAND_provider(rand));
+    provctx = ossl_provider_ctx(EVP_RAND_get0_provider(rand));
     return rand-&gt;settable_ctx_params(NULL, provctx);
 }
 
@@ -469,7 +469,7 @@ const OSSL_PARAM *EVP_RAND_CTX_gettable_params(EVP_RAND_CTX *ctx)
 
     if (ctx-&gt;meth-&gt;gettable_ctx_params == NULL)
         return NULL;
-    provctx = ossl_provider_ctx(EVP_RAND_provider(ctx-&gt;meth));
+    provctx = ossl_provider_ctx(EVP_RAND_get0_provider(ctx-&gt;meth));
     return ctx-&gt;meth-&gt;gettable_ctx_params(ctx-&gt;algctx, provctx);
 }
 
@@ -479,7 +479,7 @@ const OSSL_PARAM *EVP_RAND_CTX_settable_params(EVP_RAND_CTX *ctx)
 
     if (ctx-&gt;meth-&gt;settable_ctx_params == NULL)
         return NULL;
-    provctx = ossl_provider_ctx(EVP_RAND_provider(ctx-&gt;meth));
+    provctx = ossl_provider_ctx(EVP_RAND_get0_provider(ctx-&gt;meth));
     return ctx-&gt;meth-&gt;settable_ctx_params(ctx-&gt;algctx, provctx);
 }
 
@@ -622,7 +622,7 @@ static unsigned int evp_rand_strength_locked(EVP_RAND_CTX *ctx)
     return strength;
 }
 
-unsigned int EVP_RAND_strength(EVP_RAND_CTX *ctx)
+unsigned int EVP_RAND_get_strength(EVP_RAND_CTX *ctx)
 {
     unsigned int res;
 
@@ -656,7 +656,7 @@ int EVP_RAND_nonce(EVP_RAND_CTX *ctx, unsigned char *out, size_t outlen)
     return res;
 }
 
-int EVP_RAND_state(EVP_RAND_CTX *ctx)
+int EVP_RAND_get_state(EVP_RAND_CTX *ctx)
 {
     OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
     int state;
diff --git a/crypto/evp/exchange.c b/crypto/evp/exchange.c
index fb5521681a..2a066082d7 100644
--- a/crypto/evp/exchange.c
+++ b/crypto/evp/exchange.c
@@ -166,7 +166,7 @@ int EVP_KEYEXCH_up_ref(EVP_KEYEXCH *exchange)
     return 1;
 }
 
-OSSL_PROVIDER *EVP_KEYEXCH_provider(const EVP_KEYEXCH *exchange)
+OSSL_PROVIDER *EVP_KEYEXCH_get0_provider(const EVP_KEYEXCH *exchange)
 {
     return exchange-&gt;prov;
 }
@@ -264,8 +264,8 @@ int EVP_PKEY_derive_init_ex(EVP_PKEY_CTX *ctx, const OSSL_PARAM params[])
     exchange = EVP_KEYEXCH_fetch(ctx-&gt;libctx, supported_exch, ctx-&gt;propquery);
 
     if (exchange == NULL
-        || (EVP_KEYMGMT_provider(ctx-&gt;keymgmt)
-            != EVP_KEYEXCH_provider(exchange))) {
+        || (EVP_KEYMGMT_get0_provider(ctx-&gt;keymgmt)
+            != EVP_KEYEXCH_get0_provider(exchange))) {
         /*
          * We don't need to free ctx-&gt;keymgmt here, as it's not necessarily
          * tied to this operation.  It will be freed by EVP_PKEY_CTX_free().
@@ -464,17 +464,17 @@ int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *pkeylen)
         return ctx-&gt;pmeth-&gt;derive(ctx, key, pkeylen);
 }
 
-int EVP_KEYEXCH_number(const EVP_KEYEXCH *keyexch)
+int EVP_KEYEXCH_get_number(const EVP_KEYEXCH *keyexch)
 {
     return keyexch-&gt;name_id;
 }
 
-const char *EVP_KEYEXCH_name(const EVP_KEYEXCH *keyexch)
+const char *EVP_KEYEXCH_get0_name(const EVP_KEYEXCH *keyexch)
 {
     return keyexch-&gt;type_name;
 }
 
-const char *EVP_KEYEXCH_description(const EVP_KEYEXCH *keyexch)
+const char *EVP_KEYEXCH_get0_description(const EVP_KEYEXCH *keyexch)
 {
     return keyexch-&gt;description;
 }
@@ -511,7 +511,7 @@ const OSSL_PARAM *EVP_KEYEXCH_gettable_ctx_params(const EVP_KEYEXCH *keyexch)
     if (keyexch == NULL || keyexch-&gt;gettable_ctx_params == NULL)
         return NULL;
 
-    provctx = ossl_provider_ctx(EVP_KEYEXCH_provider(keyexch));
+    provctx = ossl_provider_ctx(EVP_KEYEXCH_get0_provider(keyexch));
     return keyexch-&gt;gettable_ctx_params(NULL, provctx);
 }
 
@@ -521,6 +521,6 @@ const OSSL_PARAM *EVP_KEYEXCH_settable_ctx_params(const EVP_KEYEXCH *keyexch)
 
     if (keyexch == NULL || keyexch-&gt;settable_ctx_params == NULL)
         return NULL;
-    provctx = ossl_provider_ctx(EVP_KEYEXCH_provider(keyexch));
+    provctx = ossl_provider_ctx(EVP_KEYEXCH_get0_provider(keyexch));
     return keyexch-&gt;settable_ctx_params(NULL, provctx);
 }
diff --git a/crypto/evp/kdf_lib.c b/crypto/evp/kdf_lib.c
index 55f5c50ab5..65b1617b81 100644
--- a/crypto/evp/kdf_lib.c
+++ b/crypto/evp/kdf_lib.c
@@ -83,17 +83,17 @@ EVP_KDF_CTX *EVP_KDF_CTX_dup(const EVP_KDF_CTX *src)
     return dst;
 }
 
-int EVP_KDF_number(const EVP_KDF *kdf)
+int EVP_KDF_get_number(const EVP_KDF *kdf)
 {
     return kdf-&gt;name_id;
 }
 
-const char *EVP_KDF_name(const EVP_KDF *kdf)
+const char *EVP_KDF_get0_name(const EVP_KDF *kdf)
 {
     return kdf-&gt;type_name;
 }
 
-const char *EVP_KDF_description(const EVP_KDF *kdf)
+const char *EVP_KDF_get0_description(const EVP_KDF *kdf)
 {
     return kdf-&gt;description;
 }
@@ -103,7 +103,7 @@ int EVP_KDF_is_a(const EVP_KDF *kdf, const char *name)
     return evp_is_a(kdf-&gt;prov, kdf-&gt;name_id, NULL, name);
 }
 
-const OSSL_PROVIDER *EVP_KDF_provider(const EVP_KDF *kdf)
+const OSSL_PROVIDER *EVP_KDF_get0_provider(const EVP_KDF *kdf)
 {
     return kdf-&gt;prov;
 }
diff --git a/crypto/evp/kdf_meth.c b/crypto/evp/kdf_meth.c
index 9cf0ca125b..8759021afc 100644
--- a/crypto/evp/kdf_meth.c
+++ b/crypto/evp/kdf_meth.c
@@ -179,7 +179,7 @@ const OSSL_PARAM *EVP_KDF_gettable_params(const EVP_KDF *kdf)
 {
     if (kdf-&gt;gettable_params == NULL)
         return NULL;
-    return kdf-&gt;gettable_params(ossl_provider_ctx(EVP_KDF_provider(kdf)));
+    return kdf-&gt;gettable_params(ossl_provider_ctx(EVP_KDF_get0_provider(kdf)));
 }
 
 const OSSL_PARAM *EVP_KDF_gettable_ctx_params(const EVP_KDF *kdf)
@@ -188,7 +188,7 @@ const OSSL_PARAM *EVP_KDF_gettable_ctx_params(const EVP_KDF *kdf)
 
     if (kdf-&gt;gettable_ctx_params == NULL)
         return NULL;
-    alg = ossl_provider_ctx(EVP_KDF_provider(kdf));
+    alg = ossl_provider_ctx(EVP_KDF_get0_provider(kdf));
     return kdf-&gt;gettable_ctx_params(NULL, alg);
 }
 
@@ -198,7 +198,7 @@ const OSSL_PARAM *EVP_KDF_settable_ctx_params(const EVP_KDF *kdf)
 
     if (kdf-&gt;settable_ctx_params == NULL)
         return NULL;
-    alg = ossl_provider_ctx(EVP_KDF_provider(kdf));
+    alg = ossl_provider_ctx(EVP_KDF_get0_provider(kdf));
     return kdf-&gt;settable_ctx_params(NULL, alg);
 }
 
@@ -208,7 +208,7 @@ const OSSL_PARAM *EVP_KDF_CTX_gettable_params(EVP_KDF_CTX *ctx)
 
     if (ctx-&gt;meth-&gt;gettable_ctx_params == NULL)
         return NULL;
-    alg = ossl_provider_ctx(EVP_KDF_provider(ctx-&gt;meth));
+    alg = ossl_provider_ctx(EVP_KDF_get0_provider(ctx-&gt;meth));
     return ctx-&gt;meth-&gt;gettable_ctx_params(ctx-&gt;algctx, alg);
 }
 
@@ -218,7 +218,7 @@ const OSSL_PARAM *EVP_KDF_CTX_settable_params(EVP_KDF_CTX *ctx)
 
     if (ctx-&gt;meth-&gt;settable_ctx_params == NULL)
         return NULL;
-    alg = ossl_provider_ctx(EVP_KDF_provider(ctx-&gt;meth));
+    alg = ossl_provider_ctx(EVP_KDF_get0_provider(ctx-&gt;meth));
     return ctx-&gt;meth-&gt;settable_ctx_params(ctx-&gt;algctx, alg);
 }
 
diff --git a/crypto/evp/kem.c b/crypto/evp/kem.c
index 493eabf97b..594633cf92 100644
--- a/crypto/evp/kem.c
+++ b/crypto/evp/kem.c
@@ -60,7 +60,7 @@ static int evp_kem_init(EVP_PKEY_CTX *ctx, int operation,
 
     kem = EVP_KEM_fetch(ctx-&gt;libctx, supported_kem, ctx-&gt;propquery);
     if (kem == NULL
-        || (EVP_KEYMGMT_provider(ctx-&gt;keymgmt) != EVP_KEM_provider(kem))) {
+        || (EVP_KEYMGMT_get0_provider(ctx-&gt;keymgmt) != EVP_KEM_get0_provider(kem))) {
         ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
         ret = -2;
         goto err;
@@ -324,7 +324,7 @@ int EVP_KEM_up_ref(EVP_KEM *kem)
     return 1;
 }
 
-OSSL_PROVIDER *EVP_KEM_provider(const EVP_KEM *kem)
+OSSL_PROVIDER *EVP_KEM_get0_provider(const EVP_KEM *kem)
 {
     return kem-&gt;prov;
 }
@@ -343,17 +343,17 @@ int EVP_KEM_is_a(const EVP_KEM *kem, const char *name)
     return evp_is_a(kem-&gt;prov, kem-&gt;name_id, NULL, name);
 }
 
-int EVP_KEM_number(const EVP_KEM *kem)
+int EVP_KEM_get_number(const EVP_KEM *kem)
 {
     return kem-&gt;name_id;
 }
 
-const char *EVP_KEM_name(const EVP_KEM *kem)
+const char *EVP_KEM_get0_name(const EVP_KEM *kem)
 {
     return kem-&gt;type_name;
 }
 
-const char *EVP_KEM_description(const EVP_KEM *kem)
+const char *EVP_KEM_get0_description(const EVP_KEM *kem)
 {
     return kem-&gt;description;
 }
@@ -384,7 +384,7 @@ const OSSL_PARAM *EVP_KEM_gettable_ctx_params(const EVP_KEM *kem)
     if (kem == NULL || kem-&gt;gettable_ctx_params == NULL)
         return NULL;
 
-    provctx = ossl_provider_ctx(EVP_KEM_provider(kem));
+    provctx = ossl_provider_ctx(EVP_KEM_get0_provider(kem));
     return kem-&gt;gettable_ctx_params(NULL, provctx);
 }
 
@@ -395,6 +395,6 @@ const OSSL_PARAM *EVP_KEM_settable_ctx_params(const EVP_KEM *kem)
     if (kem == NULL || kem-&gt;settable_ctx_params == NULL)
         return NULL;
 
-    provctx = ossl_provider_ctx(EVP_KEM_provider(kem));
+    provctx = ossl_provider_ctx(EVP_KEM_get0_provider(kem));
     return kem-&gt;settable_ctx_params(NULL, provctx);
 }
diff --git a/crypto/evp/keymgmt_lib.c b/crypto/evp/keymgmt_lib.c
index d2d60fa953..bbca3ddef5 100644
--- a/crypto/evp/keymgmt_lib.c
+++ b/crypto/evp/keymgmt_lib.c
@@ -22,7 +22,7 @@
  */
 static int match_type(const EVP_KEYMGMT *keymgmt1, const EVP_KEYMGMT *keymgmt2)
 {
-    const char *name2 = EVP_KEYMGMT_name(keymgmt2);
+    const char *name2 = EVP_KEYMGMT_get0_name(keymgmt2);
 
     return EVP_KEYMGMT_is_a(keymgmt1, name2);
 }
@@ -278,7 +278,7 @@ void evp_keymgmt_util_cache_keyinfo(EVP_PKEY *pk)
     /*
      * Cache information about the provider &quot;origin&quot; key.
      *
-     * This services functions like EVP_PKEY_size, EVP_PKEY_bits, etc
+     * This services functions like EVP_PKEY_get_size, EVP_PKEY_get_bits, etc
      */
     if (pk-&gt;keydata != NULL) {
         int bits = 0;
diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
index 94f0133860..841eae1df8 100644
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -246,22 +246,22 @@ void EVP_KEYMGMT_free(EVP_KEYMGMT *keymgmt)
     OPENSSL_free(keymgmt);
 }
 
-const OSSL_PROVIDER *EVP_KEYMGMT_provider(const EVP_KEYMGMT *keymgmt)
+const OSSL_PROVIDER *EVP_KEYMGMT_get0_provider(const EVP_KEYMGMT *keymgmt)
 {
     return keymgmt-&gt;prov;
 }
 
-int EVP_KEYMGMT_number(const EVP_KEYMGMT *keymgmt)
+int EVP_KEYMGMT_get_number(const EVP_KEYMGMT *keymgmt)
 {
     return keymgmt-&gt;name_id;
 }
 
-const char *EVP_KEYMGMT_description(const EVP_KEYMGMT *keymgmt)
+const char *EVP_KEYMGMT_get0_description(const EVP_KEYMGMT *keymgmt)
 {
     return keymgmt-&gt;description;
 }
 
-const char *EVP_KEYMGMT_name(const EVP_KEYMGMT *keymgmt)
+const char *EVP_KEYMGMT_get0_name(const EVP_KEYMGMT *keymgmt)
 {
     return keymgmt-&gt;type_name;
 }
@@ -296,7 +296,7 @@ int EVP_KEYMGMT_names_do_all(const EVP_KEYMGMT *keymgmt,
  */
 void *evp_keymgmt_newdata(const EVP_KEYMGMT *keymgmt)
 {
-    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_provider(keymgmt));
+    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_get0_provider(keymgmt));
 
     /*
      * 'new' is currently mandatory on its own, but when new
@@ -317,7 +317,7 @@ void evp_keymgmt_freedata(const EVP_KEYMGMT *keymgmt, void *keydata)
 void *evp_keymgmt_gen_init(const EVP_KEYMGMT *keymgmt, int selection,
                            const OSSL_PARAM params[])
 {
-    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_provider(keymgmt));
+    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_get0_provider(keymgmt));
 
     if (keymgmt-&gt;gen_init == NULL)
         return NULL;
@@ -348,7 +348,7 @@ int evp_keymgmt_gen_set_params(const EVP_KEYMGMT *keymgmt, void *genctx,
 
 const OSSL_PARAM *EVP_KEYMGMT_gen_settable_params(const EVP_KEYMGMT *keymgmt)
 {
-    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_provider(keymgmt));
+    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_get0_provider(keymgmt));
 
     if (keymgmt-&gt;gen_settable_params == NULL)
         return NULL;
@@ -387,7 +387,7 @@ int evp_keymgmt_get_params(const EVP_KEYMGMT *keymgmt, void *keydata,
 
 const OSSL_PARAM *EVP_KEYMGMT_gettable_params(const EVP_KEYMGMT *keymgmt)
 {
-    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_provider(keymgmt));
+    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_get0_provider(keymgmt));
 
     if (keymgmt-&gt;gettable_params == NULL)
         return NULL;
@@ -404,7 +404,7 @@ int evp_keymgmt_set_params(const EVP_KEYMGMT *keymgmt, void *keydata,
 
 const OSSL_PARAM *EVP_KEYMGMT_settable_params(const EVP_KEYMGMT *keymgmt)
 {
-    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_provider(keymgmt));
+    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_get0_provider(keymgmt));
 
     if (keymgmt-&gt;settable_params == NULL)
         return NULL;
diff --git a/crypto/evp/legacy_md5_sha1.c b/crypto/evp/legacy_md5_sha1.c
index f2d4c0ba22..b84bf3deaa 100644
--- a/crypto/evp/legacy_md5_sha1.c
+++ b/crypto/evp/legacy_md5_sha1.c
@@ -21,7 +21,7 @@
 IMPLEMENT_LEGACY_EVP_MD_METH_LC(md5_sha1_int, ossl_md5_sha1)
 static int md5_sha1_int_ctrl(EVP_MD_CTX *ctx, int cmd, int mslen, void *ms)
 {
-    return ossl_md5_sha1_ctrl(EVP_MD_CTX_md_data(ctx), cmd, mslen, ms);
+    return ossl_md5_sha1_ctrl(EVP_MD_CTX_get0_md_data(ctx), cmd, mslen, ms);
 }
 
 static const EVP_MD md5_sha1_md = {
diff --git a/crypto/evp/legacy_meth.h b/crypto/evp/legacy_meth.h
index 0a23efd05a..d32f20aad3 100644
--- a/crypto/evp/legacy_meth.h
+++ b/crypto/evp/legacy_meth.h
@@ -10,29 +10,29 @@
 #define IMPLEMENT_LEGACY_EVP_MD_METH(nm, fn)                                   \
 static int nm##_init(EVP_MD_CTX *ctx)                                          \
 {                                                                              \
-    return fn##_Init(EVP_MD_CTX_md_data(ctx));                                 \
+    return fn##_Init(EVP_MD_CTX_get0_md_data(ctx));                            \
 }                                                                              \
 static int nm##_update(EVP_MD_CTX *ctx, const void *data, size_t count)        \
 {                                                                              \
-    return fn##_Update(EVP_MD_CTX_md_data(ctx), data, count);                  \
+    return fn##_Update(EVP_MD_CTX_get0_md_data(ctx), data, count);             \
 }                                                                              \
 static int nm##_final(EVP_MD_CTX *ctx, unsigned char *md)                      \
 {                                                                              \
-    return fn##_Final(md, EVP_MD_CTX_md_data(ctx));                            \
+    return fn##_Final(md, EVP_MD_CTX_get0_md_data(ctx));                       \
 }
 
 #define IMPLEMENT_LEGACY_EVP_MD_METH_LC(nm, fn)                                \
 static int nm##_init(EVP_MD_CTX *ctx)                                          \
 {                                                                              \
-    return fn##_init(EVP_MD_CTX_md_data(ctx));                                 \
+    return fn##_init(EVP_MD_CTX_get0_md_data(ctx));                            \
 }                                                                              \
 static int nm##_update(EVP_MD_CTX *ctx, const void *data, size_t count)        \
 {                                                                              \
-    return fn##_update(EVP_MD_CTX_md_data(ctx), data, count);                  \
+    return fn##_update(EVP_MD_CTX_get0_md_data(ctx), data, count);             \
 }                                                                              \
 static int nm##_final(EVP_MD_CTX *ctx, unsigned char *md)                      \
 {                                                                              \
-    return fn##_final(md, EVP_MD_CTX_md_data(ctx));                            \
+    return fn##_final(md, EVP_MD_CTX_get0_md_data(ctx));                       \
 }
 
 
diff --git a/crypto/evp/legacy_sha.c b/crypto/evp/legacy_sha.c
index 9ab839e7aa..3859286eeb 100644
--- a/crypto/evp/legacy_sha.c
+++ b/crypto/evp/legacy_sha.c
@@ -29,20 +29,20 @@
 #define IMPLEMENT_LEGACY_EVP_MD_METH_SHA3(nm, fn, tag)                         \
 static int nm##_init(EVP_MD_CTX *ctx)                                          \
 {                                                                              \
-    return fn##_init(EVP_MD_CTX_md_data(ctx), tag, ctx-&gt;digest-&gt;md_size * 8);  \
+    return fn##_init(EVP_MD_CTX_get0_md_data(ctx), tag, ctx-&gt;digest-&gt;md_size * 8); \
 }                                                                              \
 static int nm##_update(EVP_MD_CTX *ctx, const void *data, size_t count)        \
 {                                                                              \
-    return fn##_update(EVP_MD_CTX_md_data(ctx), data, count);                  \
+    return fn##_update(EVP_MD_CTX_get0_md_data(ctx), data, count);             \
 }                                                                              \
 static int nm##_final(EVP_MD_CTX *ctx, unsigned char *md)                      \
 {                                                                              \
-    return fn##_final(md, EVP_MD_CTX_md_data(ctx));                            \
+    return fn##_final(md, EVP_MD_CTX_get0_md_data(ctx));                       \
 }
 #define IMPLEMENT_LEGACY_EVP_MD_METH_SHAKE(nm, fn, tag)                        \
 static int nm##_init(EVP_MD_CTX *ctx)                                          \
 {                                                                              \
-    return fn##_init(EVP_MD_CTX_md_data(ctx), tag, ctx-&gt;digest-&gt;md_size * 8);  \
+    return fn##_init(EVP_MD_CTX_get0_md_data(ctx), tag, ctx-&gt;digest-&gt;md_size * 8); \
 }                                                                              \
 
 #define sha512_224_Init    sha512_224_init
@@ -65,7 +65,7 @@ IMPLEMENT_LEGACY_EVP_MD_METH_SHAKE(shake, ossl_sha3, '\x1f')
 
 static int sha1_int_ctrl(EVP_MD_CTX *ctx, int cmd, int p1, void *p2)
 {
-    return ossl_sha1_ctrl(ctx != NULL ? EVP_MD_CTX_md_data(ctx) : NULL,
+    return ossl_sha1_ctrl(ctx != NULL ? EVP_MD_CTX_get0_md_data(ctx) : NULL,
                           cmd, p1, p2);
 }
 
diff --git a/crypto/evp/m_sigver.c b/crypto/evp/m_sigver.c
index 296269a88e..dba549503d 100644
--- a/crypto/evp/m_sigver.c
+++ b/crypto/evp/m_sigver.c
@@ -122,8 +122,8 @@ static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                                     locpctx-&gt;propquery);
 
     if (signature == NULL
-        || (EVP_KEYMGMT_provider(locpctx-&gt;keymgmt)
-            != EVP_SIGNATURE_provider(signature))) {
+        || (EVP_KEYMGMT_get0_provider(locpctx-&gt;keymgmt)
+            != EVP_SIGNATURE_get0_provider(signature))) {
         /*
          * We don't need to free ctx-&gt;keymgmt here, as it's not necessarily
          * tied to this operation.  It will be freed by EVP_PKEY_CTX_free().
@@ -156,7 +156,7 @@ static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
     if (type != NULL) {
         ctx-&gt;reqdigest = type;
         if (mdname == NULL)
-            mdname = canon_mdname(EVP_MD_name(type));
+            mdname = canon_mdname(EVP_MD_get0_name(type));
     } else {
         if (mdname == NULL) {
             if (evp_keymgmt_util_get_deflt_digest_name(tmp_keymgmt, provkey,
@@ -475,7 +475,7 @@ int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,
             if (pctx-&gt;pmeth-&gt;signctx(pctx, sigret, siglen, ctx) &lt;= 0)
                 return 0;
         } else {
-            int s = EVP_MD_size(ctx-&gt;digest);
+            int s = EVP_MD_get_size(ctx-&gt;digest);
 
             if (s &lt; 0 || EVP_PKEY_sign(pctx, sigret, siglen, NULL, s) &lt;= 0)
                 return 0;
diff --git a/crypto/evp/mac_lib.c b/crypto/evp/mac_lib.c
index 9356595efd..bd8543b2c4 100644
--- a/crypto/evp/mac_lib.c
+++ b/crypto/evp/mac_lib.c
@@ -77,7 +77,7 @@ EVP_MAC_CTX *EVP_MAC_CTX_dup(const EVP_MAC_CTX *src)
     return dst;
 }
 
-EVP_MAC *EVP_MAC_CTX_mac(EVP_MAC_CTX *ctx)
+EVP_MAC *EVP_MAC_CTX_get0_mac(EVP_MAC_CTX *ctx)
 {
     return ctx-&gt;meth;
 }
@@ -203,17 +203,17 @@ int EVP_MAC_CTX_set_params(EVP_MAC_CTX *ctx, const OSSL_PARAM params[])
     return 1;
 }
 
-int EVP_MAC_number(const EVP_MAC *mac)
+int EVP_MAC_get_number(const EVP_MAC *mac)
 {
     return mac-&gt;name_id;
 }
 
-const char *EVP_MAC_name(const EVP_MAC *mac)
+const char *EVP_MAC_get0_name(const EVP_MAC *mac)
 {
     return mac-&gt;type_name;
 }
 
-const char *EVP_MAC_description(const EVP_MAC *mac)
+const char *EVP_MAC_get0_description(const EVP_MAC *mac)
 {
     return mac-&gt;description;
 }
diff --git a/crypto/evp/mac_meth.c b/crypto/evp/mac_meth.c
index 6396eb38fd..74cfecbcdf 100644
--- a/crypto/evp/mac_meth.c
+++ b/crypto/evp/mac_meth.c
@@ -175,7 +175,7 @@ void EVP_MAC_free(EVP_MAC *mac)
     evp_mac_free(mac);
 }
 
-const OSSL_PROVIDER *EVP_MAC_provider(const EVP_MAC *mac)
+const OSSL_PROVIDER *EVP_MAC_get0_provider(const EVP_MAC *mac)
 {
     return mac-&gt;prov;
 }
@@ -184,7 +184,7 @@ const OSSL_PARAM *EVP_MAC_gettable_params(const EVP_MAC *mac)
 {
     if (mac-&gt;gettable_params == NULL)
         return NULL;
-    return mac-&gt;gettable_params(ossl_provider_ctx(EVP_MAC_provider(mac)));
+    return mac-&gt;gettable_params(ossl_provider_ctx(EVP_MAC_get0_provider(mac)));
 }
 
 const OSSL_PARAM *EVP_MAC_gettable_ctx_params(const EVP_MAC *mac)
@@ -193,7 +193,7 @@ const OSSL_PARAM *EVP_MAC_gettable_ctx_params(const EVP_MAC *mac)
 
     if (mac-&gt;gettable_ctx_params == NULL)
         return NULL;
-    alg = ossl_provider_ctx(EVP_MAC_provider(mac));
+    alg = ossl_provider_ctx(EVP_MAC_get0_provider(mac));
     return mac-&gt;gettable_ctx_params(NULL, alg);
 }
 
@@ -203,7 +203,7 @@ const OSSL_PARAM *EVP_MAC_settable_ctx_params(const EVP_MAC *mac)
 
     if (mac-&gt;settable_ctx_params == NULL)
         return NULL;
-    alg = ossl_provider_ctx(EVP_MAC_provider(mac));
+    alg = ossl_provider_ctx(EVP_MAC_get0_provider(mac));
     return mac-&gt;settable_ctx_params(NULL, alg);
 }
 
@@ -213,7 +213,7 @@ const OSSL_PARAM *EVP_MAC_CTX_gettable_params(EVP_MAC_CTX *ctx)
 
     if (ctx-&gt;meth-&gt;gettable_ctx_params == NULL)
         return NULL;
-    alg = ossl_provider_ctx(EVP_MAC_provider(ctx-&gt;meth));
+    alg = ossl_provider_ctx(EVP_MAC_get0_provider(ctx-&gt;meth));
     return ctx-&gt;meth-&gt;gettable_ctx_params(ctx-&gt;algctx, alg);
 }
 
@@ -223,7 +223,7 @@ const OSSL_PARAM *EVP_MAC_CTX_settable_params(EVP_MAC_CTX *ctx)
 
     if (ctx-&gt;meth-&gt;settable_ctx_params == NULL)
         return NULL;
-    alg = ossl_provider_ctx(EVP_MAC_provider(ctx-&gt;meth));
+    alg = ossl_provider_ctx(EVP_MAC_get0_provider(ctx-&gt;meth));
     return ctx-&gt;meth-&gt;settable_ctx_params(ctx-&gt;algctx, alg);
 }
 
diff --git a/crypto/evp/p5_crpt.c b/crypto/evp/p5_crpt.c
index abf153cb43..d8442a8d90 100644
--- a/crypto/evp/p5_crpt.c
+++ b/crypto/evp/p5_crpt.c
@@ -54,12 +54,12 @@ int PKCS5_PBE_keyivgen_ex(EVP_CIPHER_CTX *cctx, const char *pass, int passlen,
         return 0;
     }
 
-    ivl = EVP_CIPHER_iv_length(cipher);
+    ivl = EVP_CIPHER_get_iv_length(cipher);
     if (ivl &lt; 0 || ivl &gt; 16) {
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_IV_LENGTH);
         goto err;
     }
-    kl = EVP_CIPHER_key_length(cipher);
+    kl = EVP_CIPHER_get_key_length(cipher);
     if (kl &lt; 0 || kl &gt; (int)sizeof(md_tmp)) {
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_KEY_LENGTH);
         goto err;
@@ -77,7 +77,7 @@ int PKCS5_PBE_keyivgen_ex(EVP_CIPHER_CTX *cctx, const char *pass, int passlen,
     else if (passlen == -1)
         passlen = strlen(pass);
 
-    mdsize = EVP_MD_size(md);
+    mdsize = EVP_MD_get_size(md);
     if (mdsize &lt; 0)
         goto err;
 
diff --git a/crypto/evp/p5_crpt2.c b/crypto/evp/p5_crpt2.c
index 54773304fd..7088875fe1 100644
--- a/crypto/evp/p5_crpt2.c
+++ b/crypto/evp/p5_crpt2.c
@@ -28,7 +28,7 @@ int ossl_pkcs5_pbkdf2_hmac_ex(const char *pass, int passlen,
     int rv = 1, mode = 1;
     EVP_KDF *kdf;
     EVP_KDF_CTX *kctx;
-    const char *mdname = EVP_MD_name(digest);
+    const char *mdname = EVP_MD_get0_name(digest);
     OSSL_PARAM params[6], *p = params;
 
     /* Keep documented behaviour. */
@@ -193,7 +193,7 @@ int PKCS5_v2_PBKDF2_keyivgen_ex(EVP_CIPHER_CTX *ctx, const char *pass,
         ERR_raise(ERR_LIB_EVP, EVP_R_NO_CIPHER_SET);
         goto err;
     }
-    keylen = EVP_CIPHER_CTX_key_length(ctx);
+    keylen = EVP_CIPHER_CTX_get_key_length(ctx);
     OPENSSL_assert(keylen &lt;= sizeof(key));
 
     /* Decode parameter */
@@ -205,7 +205,7 @@ int PKCS5_v2_PBKDF2_keyivgen_ex(EVP_CIPHER_CTX *ctx, const char *pass,
         goto err;
     }
 
-    t = EVP_CIPHER_CTX_key_length(ctx);
+    t = EVP_CIPHER_CTX_get_key_length(ctx);
     if (t &lt; 0) {
         ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_KEY_LENGTH);
         goto err;
diff --git a/crypto/evp/p_dec.c b/crypto/evp/p_dec.c
index 822c214e6b..7b33edecd5 100644
--- a/crypto/evp/p_dec.c
+++ b/crypto/evp/p_dec.c
@@ -23,7 +23,7 @@ int EVP_PKEY_decrypt_old(unsigned char *key, const unsigned char *ek, int ekl,
 {
     int ret = -1;
 
-    if (EVP_PKEY_id(priv) != EVP_PKEY_RSA) {
+    if (EVP_PKEY_get_id(priv) != EVP_PKEY_RSA) {
         ERR_raise(ERR_LIB_EVP, EVP_R_PUBLIC_KEY_NOT_RSA);
         goto err;
     }
diff --git a/crypto/evp/p_enc.c b/crypto/evp/p_enc.c
index f1a7a839f6..d4db595164 100644
--- a/crypto/evp/p_enc.c
+++ b/crypto/evp/p_enc.c
@@ -23,7 +23,7 @@ int EVP_PKEY_encrypt_old(unsigned char *ek, const unsigned char *key,
 {
     int ret = 0;
 
-    if (EVP_PKEY_id(pubk) != EVP_PKEY_RSA) {
+    if (EVP_PKEY_get_id(pubk) != EVP_PKEY_RSA) {
         ERR_raise(ERR_LIB_EVP, EVP_R_PUBLIC_KEY_NOT_RSA);
         goto err;
     }
diff --git a/crypto/evp/p_legacy.c b/crypto/evp/p_legacy.c
index c1d813f047..6c65e7e194 100644
--- a/crypto/evp/p_legacy.c
+++ b/crypto/evp/p_legacy.c
@@ -68,7 +68,7 @@ int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, EC_KEY *key)
 
 EC_KEY *evp_pkey_get0_EC_KEY_int(const EVP_PKEY *pkey)
 {
-    if (EVP_PKEY_base_id(pkey) != EVP_PKEY_EC) {
+    if (EVP_PKEY_get_base_id(pkey) != EVP_PKEY_EC) {
         ERR_raise(ERR_LIB_EVP, EVP_R_EXPECTING_A_EC_KEY);
         return NULL;
     }
diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
index d2c871179e..07be8884fe 100644
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -58,7 +58,7 @@ static void evp_pkey_free_it(EVP_PKEY *key);
 /* The type of parameters selected in key parameter functions */
 # define SELECT_PARAMETERS OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS
 
-int EVP_PKEY_bits(const EVP_PKEY *pkey)
+int EVP_PKEY_get_bits(const EVP_PKEY *pkey)
 {
     int size = 0;
 
@@ -70,7 +70,7 @@ int EVP_PKEY_bits(const EVP_PKEY *pkey)
     return size &lt; 0 ? 0 : size;
 }
 
-int EVP_PKEY_security_bits(const EVP_PKEY *pkey)
+int EVP_PKEY_get_security_bits(const EVP_PKEY *pkey)
 {
     int size = 0;
 
@@ -616,7 +616,7 @@ static EVP_PKEY *new_cmac_key_int(const unsigned char *priv, size_t len,
     EVP_PKEY_CTX *ctx;
 
     if (cipher != NULL)
-        cipher_name = EVP_CIPHER_name(cipher);
+        cipher_name = EVP_CIPHER_get0_name(cipher);
 
     if (cipher_name == NULL) {
         ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);
@@ -865,7 +865,7 @@ DSA *EVP_PKEY_get1_DSA(EVP_PKEY *pkey)
 # ifndef OPENSSL_NO_EC
 static const ECX_KEY *evp_pkey_get0_ECX_KEY(const EVP_PKEY *pkey, int type)
 {
-    if (EVP_PKEY_base_id(pkey) != type) {
+    if (EVP_PKEY_get_base_id(pkey) != type) {
         ERR_raise(ERR_LIB_EVP, EVP_R_EXPECTING_A_ECX_KEY);
         return NULL;
     }
@@ -970,12 +970,12 @@ int EVP_PKEY_type(int type)
     return ret;
 }
 
-int EVP_PKEY_id(const EVP_PKEY *pkey)
+int EVP_PKEY_get_id(const EVP_PKEY *pkey)
 {
     return pkey-&gt;type;
 }
 
-int EVP_PKEY_base_id(const EVP_PKEY *pkey)
+int EVP_PKEY_get_base_id(const EVP_PKEY *pkey)
 {
     return EVP_PKEY_type(pkey-&gt;type);
 }
@@ -1052,7 +1052,7 @@ int EVP_PKEY_type_names_do_all(const EVP_PKEY *pkey,
         return 0;
 
     if (!evp_pkey_is_provided(pkey)) {
-        const char *name = OBJ_nid2sn(EVP_PKEY_id(pkey));
+        const char *name = OBJ_nid2sn(EVP_PKEY_get_id(pkey));
 
         fn(name, data);
         return 1;
@@ -1063,7 +1063,7 @@ int EVP_PKEY_type_names_do_all(const EVP_PKEY *pkey,
 int EVP_PKEY_can_sign(const EVP_PKEY *pkey)
 {
     if (pkey-&gt;keymgmt == NULL) {
-        switch (EVP_PKEY_base_id(pkey)) {
+        switch (EVP_PKEY_get_base_id(pkey)) {
         case EVP_PKEY_RSA:
             return 1;
 # ifndef OPENSSL_NO_DSA
@@ -1081,12 +1081,12 @@ int EVP_PKEY_can_sign(const EVP_PKEY *pkey)
             break;
         }
     } else {
-        const OSSL_PROVIDER *prov = EVP_KEYMGMT_provider(pkey-&gt;keymgmt);
+        const OSSL_PROVIDER *prov = EVP_KEYMGMT_get0_provider(pkey-&gt;keymgmt);
         OSSL_LIB_CTX *libctx = ossl_provider_libctx(prov);
         const char *supported_sig =
             pkey-&gt;keymgmt-&gt;query_operation_name != NULL
             ? pkey-&gt;keymgmt-&gt;query_operation_name(OSSL_OP_SIGNATURE)
-            : EVP_KEYMGMT_name(pkey-&gt;keymgmt);
+            : EVP_KEYMGMT_get0_name(pkey-&gt;keymgmt);
         EVP_SIGNATURE *signature = NULL;
 
         signature = EVP_SIGNATURE_fetch(libctx, supported_sig, NULL);
@@ -1767,7 +1767,7 @@ void EVP_PKEY_free(EVP_PKEY *x)
     OPENSSL_free(x);
 }
 
-int EVP_PKEY_size(const EVP_PKEY *pkey)
+int EVP_PKEY_get_size(const EVP_PKEY *pkey)
 {
     int size = 0;
 
@@ -1781,7 +1781,7 @@ int EVP_PKEY_size(const EVP_PKEY *pkey)
     return size &lt; 0 ? 0 : size;
 }
 
-const char *EVP_PKEY_description(const EVP_PKEY *pkey)
+const char *EVP_PKEY_get0_description(const EVP_PKEY *pkey)
 {
     if (!evp_pkey_is_assigned(pkey))
         return NULL;
@@ -1971,7 +1971,7 @@ int evp_pkey_copy_downgraded(EVP_PKEY **dest, const EVP_PKEY *src)
         int type = src-&gt;type;
         const char *keytype = NULL;
 
-        keytype = EVP_KEYMGMT_name(keymgmt);
+        keytype = EVP_KEYMGMT_get0_name(keymgmt);
 
         /*
          * If the type is EVP_PKEY_NONE, then we have a problem somewhere
diff --git a/crypto/evp/p_seal.c b/crypto/evp/p_seal.c
index bafafd6244..475082d431 100644
--- a/crypto/evp/p_seal.c
+++ b/crypto/evp/p_seal.c
@@ -35,7 +35,7 @@ int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
             return 0;
     }
     if ((cipher = EVP_CIPHER_CTX_get0_cipher(ctx)) != NULL
-            &amp;&amp; (prov = EVP_CIPHER_provider(cipher)) != NULL)
+            &amp;&amp; (prov = EVP_CIPHER_get0_provider(cipher)) != NULL)
         libctx = ossl_provider_libctx(prov);
     if ((npubk &lt;= 0) || !pubk)
         return 1;
@@ -43,11 +43,11 @@ int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
     if (EVP_CIPHER_CTX_rand_key(ctx, key) &lt;= 0)
         return 0;
 
-    len = EVP_CIPHER_CTX_iv_length(ctx);
+    len = EVP_CIPHER_CTX_get_iv_length(ctx);
     if (len &lt; 0 || RAND_priv_bytes_ex(libctx, iv, len, 0) &lt;= 0)
         goto err;
 
-    len = EVP_CIPHER_CTX_key_length(ctx);
+    len = EVP_CIPHER_CTX_get_key_length(ctx);
     if (len &lt; 0)
         goto err;
 
diff --git a/crypto/evp/p_sign.c b/crypto/evp/p_sign.c
index fed9471311..8e430f4704 100644
--- a/crypto/evp/p_sign.c
+++ b/crypto/evp/p_sign.c
@@ -44,7 +44,7 @@ int EVP_SignFinal_ex(EVP_MD_CTX *ctx, unsigned char *sigret,
             return 0;
     }
 
-    sltmp = (size_t)EVP_PKEY_size(pkey);
+    sltmp = (size_t)EVP_PKEY_get_size(pkey);
     i = 0;
     pkctx = EVP_PKEY_CTX_new_from_pkey(libctx, pkey, propq);
     if (pkctx == NULL)
diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index 47062c02c1..bcc601ee59 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -192,7 +192,7 @@ static EVP_PKEY_CTX *int_ctx_new(OSSL_LIB_CTX *libctx,
         /* If we have an engine, something went wrong somewhere... */
         if (!ossl_assert(e == NULL))
             return NULL;
-        keytype = EVP_KEYMGMT_name(pkey-&gt;keymgmt);
+        keytype = EVP_KEYMGMT_get0_name(pkey-&gt;keymgmt);
         goto common;
     }
 
@@ -742,7 +742,7 @@ const OSSL_PARAM *EVP_PKEY_CTX_gettable_params(const EVP_PKEY_CTX *ctx)
     if (EVP_PKEY_CTX_IS_DERIVE_OP(ctx)
             &amp;&amp; ctx-&gt;op.kex.exchange != NULL
             &amp;&amp; ctx-&gt;op.kex.exchange-&gt;gettable_ctx_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_KEYEXCH_provider(ctx-&gt;op.kex.exchange));
+        provctx = ossl_provider_ctx(EVP_KEYEXCH_get0_provider(ctx-&gt;op.kex.exchange));
         return ctx-&gt;op.kex.exchange-&gt;gettable_ctx_params(ctx-&gt;op.kex.algctx,
                                                          provctx);
     }
@@ -750,7 +750,7 @@ const OSSL_PARAM *EVP_PKEY_CTX_gettable_params(const EVP_PKEY_CTX *ctx)
             &amp;&amp; ctx-&gt;op.sig.signature != NULL
             &amp;&amp; ctx-&gt;op.sig.signature-&gt;gettable_ctx_params != NULL) {
         provctx = ossl_provider_ctx(
-                      EVP_SIGNATURE_provider(ctx-&gt;op.sig.signature));
+                      EVP_SIGNATURE_get0_provider(ctx-&gt;op.sig.signature));
         return ctx-&gt;op.sig.signature-&gt;gettable_ctx_params(ctx-&gt;op.sig.algctx,
                                                           provctx);
     }
@@ -758,14 +758,14 @@ const OSSL_PARAM *EVP_PKEY_CTX_gettable_params(const EVP_PKEY_CTX *ctx)
             &amp;&amp; ctx-&gt;op.ciph.cipher != NULL
             &amp;&amp; ctx-&gt;op.ciph.cipher-&gt;gettable_ctx_params != NULL) {
         provctx = ossl_provider_ctx(
-                      EVP_ASYM_CIPHER_provider(ctx-&gt;op.ciph.cipher));
+                      EVP_ASYM_CIPHER_get0_provider(ctx-&gt;op.ciph.cipher));
         return ctx-&gt;op.ciph.cipher-&gt;gettable_ctx_params(ctx-&gt;op.ciph.algctx,
                                                         provctx);
     }
     if (EVP_PKEY_CTX_IS_KEM_OP(ctx)
         &amp;&amp; ctx-&gt;op.encap.kem != NULL
         &amp;&amp; ctx-&gt;op.encap.kem-&gt;gettable_ctx_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_KEM_provider(ctx-&gt;op.encap.kem));
+        provctx = ossl_provider_ctx(EVP_KEM_get0_provider(ctx-&gt;op.encap.kem));
         return ctx-&gt;op.encap.kem-&gt;gettable_ctx_params(ctx-&gt;op.encap.algctx,
                                                       provctx);
     }
@@ -779,7 +779,7 @@ const OSSL_PARAM *EVP_PKEY_CTX_settable_params(const EVP_PKEY_CTX *ctx)
     if (EVP_PKEY_CTX_IS_DERIVE_OP(ctx)
             &amp;&amp; ctx-&gt;op.kex.exchange != NULL
             &amp;&amp; ctx-&gt;op.kex.exchange-&gt;settable_ctx_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_KEYEXCH_provider(ctx-&gt;op.kex.exchange));
+        provctx = ossl_provider_ctx(EVP_KEYEXCH_get0_provider(ctx-&gt;op.kex.exchange));
         return ctx-&gt;op.kex.exchange-&gt;settable_ctx_params(ctx-&gt;op.kex.algctx,
                                                          provctx);
     }
@@ -787,7 +787,7 @@ const OSSL_PARAM *EVP_PKEY_CTX_settable_params(const EVP_PKEY_CTX *ctx)
             &amp;&amp; ctx-&gt;op.sig.signature != NULL
             &amp;&amp; ctx-&gt;op.sig.signature-&gt;settable_ctx_params != NULL) {
         provctx = ossl_provider_ctx(
-                      EVP_SIGNATURE_provider(ctx-&gt;op.sig.signature));
+                      EVP_SIGNATURE_get0_provider(ctx-&gt;op.sig.signature));
         return ctx-&gt;op.sig.signature-&gt;settable_ctx_params(ctx-&gt;op.sig.algctx,
                                                           provctx);
     }
@@ -795,21 +795,21 @@ const OSSL_PARAM *EVP_PKEY_CTX_settable_params(const EVP_PKEY_CTX *ctx)
             &amp;&amp; ctx-&gt;op.ciph.cipher != NULL
             &amp;&amp; ctx-&gt;op.ciph.cipher-&gt;settable_ctx_params != NULL) {
         provctx = ossl_provider_ctx(
-                      EVP_ASYM_CIPHER_provider(ctx-&gt;op.ciph.cipher));
+                      EVP_ASYM_CIPHER_get0_provider(ctx-&gt;op.ciph.cipher));
         return ctx-&gt;op.ciph.cipher-&gt;settable_ctx_params(ctx-&gt;op.ciph.algctx,
                                                         provctx);
     }
     if (EVP_PKEY_CTX_IS_GEN_OP(ctx)
             &amp;&amp; ctx-&gt;keymgmt != NULL
             &amp;&amp; ctx-&gt;keymgmt-&gt;gen_settable_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_KEYMGMT_provider(ctx-&gt;keymgmt));
+        provctx = ossl_provider_ctx(EVP_KEYMGMT_get0_provider(ctx-&gt;keymgmt));
         return ctx-&gt;keymgmt-&gt;gen_settable_params(ctx-&gt;op.keymgmt.genctx,
                                                  provctx);
     }
     if (EVP_PKEY_CTX_IS_KEM_OP(ctx)
         &amp;&amp; ctx-&gt;op.encap.kem != NULL
         &amp;&amp; ctx-&gt;op.encap.kem-&gt;settable_ctx_params != NULL) {
-        provctx = ossl_provider_ctx(EVP_KEM_provider(ctx-&gt;op.encap.kem));
+        provctx = ossl_provider_ctx(EVP_KEM_get0_provider(ctx-&gt;op.encap.kem));
         return ctx-&gt;op.encap.kem-&gt;settable_ctx_params(ctx-&gt;op.encap.algctx,
                                                       provctx);
     }
@@ -931,7 +931,7 @@ static int evp_pkey_ctx_set_md(EVP_PKEY_CTX *ctx, const EVP_MD *md,
     if (md == NULL) {
         name = &quot;&quot;;
     } else {
-        name = EVP_MD_name(md);
+        name = EVP_MD_get0_name(md);
     }
 
     *p++ = OSSL_PARAM_construct_utf8_string(param,
@@ -1051,7 +1051,7 @@ int EVP_PKEY_CTX_add1_hkdf_info(EVP_PKEY_CTX *ctx,
                                           info, infolen);
 }
 
-int EVP_PKEY_CTX_hkdf_mode(EVP_PKEY_CTX *ctx, int mode)
+int EVP_PKEY_CTX_set_hkdf_mode(EVP_PKEY_CTX *ctx, int mode)
 {
     OSSL_PARAM int_params[2], *p = int_params;
 
diff --git a/crypto/evp/signature.c b/crypto/evp/signature.c
index b4e0ff2527..698adff088 100644
--- a/crypto/evp/signature.c
+++ b/crypto/evp/signature.c
@@ -300,7 +300,7 @@ int EVP_SIGNATURE_up_ref(EVP_SIGNATURE *signature)
     return 1;
 }
 
-OSSL_PROVIDER *EVP_SIGNATURE_provider(const EVP_SIGNATURE *signature)
+OSSL_PROVIDER *EVP_SIGNATURE_get0_provider(const EVP_SIGNATURE *signature)
 {
     return signature-&gt;prov;
 }
@@ -319,17 +319,17 @@ int EVP_SIGNATURE_is_a(const EVP_SIGNATURE *signature, const char *name)
     return evp_is_a(signature-&gt;prov, signature-&gt;name_id, NULL, name);
 }
 
-int EVP_SIGNATURE_number(const EVP_SIGNATURE *signature)
+int EVP_SIGNATURE_get_number(const EVP_SIGNATURE *signature)
 {
     return signature-&gt;name_id;
 }
 
-const char *EVP_SIGNATURE_name(const EVP_SIGNATURE *signature)
+const char *EVP_SIGNATURE_get0_name(const EVP_SIGNATURE *signature)
 {
     return signature-&gt;type_name;
 }
 
-const char *EVP_SIGNATURE_description(const EVP_SIGNATURE *signature)
+const char *EVP_SIGNATURE_get0_description(const EVP_SIGNATURE *signature)
 {
     return signature-&gt;description;
 }
@@ -363,7 +363,7 @@ const OSSL_PARAM *EVP_SIGNATURE_gettable_ctx_params(const EVP_SIGNATURE *sig)
     if (sig == NULL || sig-&gt;gettable_ctx_params == NULL)
         return NULL;
 
-    provctx = ossl_provider_ctx(EVP_SIGNATURE_provider(sig));
+    provctx = ossl_provider_ctx(EVP_SIGNATURE_get0_provider(sig));
     return sig-&gt;gettable_ctx_params(NULL, provctx);
 }
 
@@ -374,7 +374,7 @@ const OSSL_PARAM *EVP_SIGNATURE_settable_ctx_params(const EVP_SIGNATURE *sig)
     if (sig == NULL || sig-&gt;settable_ctx_params == NULL)
         return NULL;
 
-    provctx = ossl_provider_ctx(EVP_SIGNATURE_provider(sig));
+    provctx = ossl_provider_ctx(EVP_SIGNATURE_get0_provider(sig));
     return sig-&gt;settable_ctx_params(NULL, provctx);
 }
 
@@ -439,8 +439,8 @@ static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, int operation,
         EVP_SIGNATURE_fetch(ctx-&gt;libctx, supported_sig, ctx-&gt;propquery);
 
     if (signature == NULL
-        || (EVP_KEYMGMT_provider(ctx-&gt;keymgmt)
-            != EVP_SIGNATURE_provider(signature))) {
+        || (EVP_KEYMGMT_get0_provider(ctx-&gt;keymgmt)
+            != EVP_SIGNATURE_get0_provider(signature))) {
         /*
          * We don't need to free ctx-&gt;keymgmt here, as it's not necessarily
          * tied to this operation.  It will be freed by EVP_PKEY_CTX_free().
diff --git a/crypto/ffc/ffc_params_generate.c b/crypto/ffc/ffc_params_generate.c
index 85ae524015..36b5a873a7 100644
--- a/crypto/ffc/ffc_params_generate.c
+++ b/crypto/ffc/ffc_params_generate.c
@@ -140,7 +140,7 @@ static int generate_canonical_g(BN_CTX *ctx, BN_MONT_CTX *mont,
     EVP_MD_CTX *mctx = NULL;
     int mdsize;
 
-    mdsize = EVP_MD_size(evpmd);
+    mdsize = EVP_MD_get_size(evpmd);
     if (mdsize &lt;= 0)
         return 0;
 
@@ -211,7 +211,7 @@ static int generate_p(BN_CTX *ctx, const EVP_MD *evpmd, int max_counter, int n,
     if (!BN_lshift(test, BN_value_one(), L - 1))
         goto err;
 
-    mdsize = EVP_MD_size(evpmd);
+    mdsize = EVP_MD_get_size(evpmd);
     if (mdsize &lt;= 0)
         goto err;
 
@@ -318,7 +318,7 @@ static int generate_q_fips186_4(BN_CTX *ctx, BIGNUM *q, const EVP_MD *evpmd,
     int ret = 0, r;
     int m = *retm;
     unsigned char md[EVP_MAX_MD_SIZE];
-    int mdsize = EVP_MD_size(evpmd);
+    int mdsize = EVP_MD_get_size(evpmd);
     unsigned char *pmd;
     OSSL_LIB_CTX *libctx = ossl_bn_get_libctx(ctx);
 
@@ -547,7 +547,7 @@ int ossl_ffc_params_FIPS186_4_gen_verify(OSSL_LIB_CTX *libctx,
     }
     if (md == NULL)
         goto err;
-    mdsize = EVP_MD_size(md);
+    mdsize = EVP_MD_get_size(md);
     if (mdsize &lt;= 0)
         goto err;
 
@@ -843,7 +843,7 @@ int ossl_ffc_params_FIPS186_2_gen_verify(OSSL_LIB_CTX *libctx,
     if (md == NULL)
         goto err;
     if (N == 0)
-        N = EVP_MD_size(md) * 8;
+        N = EVP_MD_get_size(md) * 8;
     qsize = N &gt;&gt; 3;
 
     /*
diff --git a/crypto/hmac/hmac.c b/crypto/hmac/hmac.c
index 86cdb7bde5..618b0a6196 100644
--- a/crypto/hmac/hmac.c
+++ b/crypto/hmac/hmac.c
@@ -46,13 +46,13 @@ int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,
      * The HMAC construction is not allowed to be used with the
      * extendable-output functions (XOF) shake128 and shake256.
      */
-    if ((EVP_MD_flags(md) &amp; EVP_MD_FLAG_XOF) != 0)
+    if ((EVP_MD_get_flags(md) &amp; EVP_MD_FLAG_XOF) != 0)
         return 0;
 
     if (key != NULL) {
         reset = 1;
 
-        j = EVP_MD_block_size(md);
+        j = EVP_MD_get_block_size(md);
         if (!ossl_assert(j &lt;= (int)sizeof(keytmp)))
             return 0;
         if (j &lt; 0)
@@ -76,13 +76,15 @@ int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,
         for (i = 0; i &lt; HMAC_MAX_MD_CBLOCK_SIZE; i++)
             pad[i] = 0x36 ^ keytmp[i];
         if (!EVP_DigestInit_ex(ctx-&gt;i_ctx, md, impl)
-                || !EVP_DigestUpdate(ctx-&gt;i_ctx, pad, EVP_MD_block_size(md)))
+                || !EVP_DigestUpdate(ctx-&gt;i_ctx, pad,
+                                     EVP_MD_get_block_size(md)))
             goto err;
 
         for (i = 0; i &lt; HMAC_MAX_MD_CBLOCK_SIZE; i++)
             pad[i] = 0x5c ^ keytmp[i];
         if (!EVP_DigestInit_ex(ctx-&gt;o_ctx, md, impl)
-                || !EVP_DigestUpdate(ctx-&gt;o_ctx, pad, EVP_MD_block_size(md)))
+                || !EVP_DigestUpdate(ctx-&gt;o_ctx, pad,
+                                     EVP_MD_get_block_size(md)))
             goto err;
     }
     if (!EVP_MD_CTX_copy_ex(ctx-&gt;md_ctx, ctx-&gt;i_ctx))
@@ -135,7 +137,7 @@ int HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len)
 
 size_t HMAC_size(const HMAC_CTX *ctx)
 {
-    int size = EVP_MD_size((ctx)-&gt;md);
+    int size = EVP_MD_get_size((ctx)-&gt;md);
 
     return (size &lt; 0) ? 0 : size;
 }
@@ -221,11 +223,11 @@ unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,
                     unsigned char *md, unsigned int *md_len)
 {
     static unsigned char static_md[EVP_MAX_MD_SIZE];
-    int size = EVP_MD_size(evp_md);
+    int size = EVP_MD_get_size(evp_md);
 
     if (size &lt; 0)
         return NULL;
-    return EVP_Q_mac(NULL, &quot;HMAC&quot;, NULL, EVP_MD_name(evp_md), NULL,
+    return EVP_Q_mac(NULL, &quot;HMAC&quot;, NULL, EVP_MD_get0_name(evp_md), NULL,
                      key, key_len, data, data_len,
                      md == NULL ? static_md : md, size, md_len);
 }
diff --git a/crypto/modes/siv128.c b/crypto/modes/siv128.c
index 07c3f4ac27..e6348a8d37 100644
--- a/crypto/modes/siv128.c
+++ b/crypto/modes/siv128.c
@@ -184,7 +184,7 @@ int ossl_siv128_init(SIV128_CONTEXT *ctx, const unsigned char *key, int klen,
     if (key == NULL || cbc == NULL || ctr == NULL)
         return 0;
 
-    cbc_name = EVP_CIPHER_name(cbc);
+    cbc_name = EVP_CIPHER_get0_name(cbc);
     params[0] = OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_CIPHER,
                                                  (char *)cbc_name, 0);
     params[1] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,
diff --git a/crypto/ocsp/ocsp_lib.c b/crypto/ocsp/ocsp_lib.c
index 336372f063..285634dec3 100644
--- a/crypto/ocsp/ocsp_lib.c
+++ b/crypto/ocsp/ocsp_lib.c
@@ -55,7 +55,7 @@ OCSP_CERTID *OCSP_cert_id_new(const EVP_MD *dgst,
 
     alg = &amp;cid-&gt;hashAlgorithm;
     ASN1_OBJECT_free(alg-&gt;algorithm);
-    if ((nid = EVP_MD_type(dgst)) == NID_undef) {
+    if ((nid = EVP_MD_get_type(dgst)) == NID_undef) {
         ERR_raise(ERR_LIB_OCSP, OCSP_R_UNKNOWN_NID);
         goto err;
     }
diff --git a/crypto/ocsp/ocsp_srv.c b/crypto/ocsp/ocsp_srv.c
index 1475bb0f7e..dbb6e760b2 100644
--- a/crypto/ocsp/ocsp_srv.c
+++ b/crypto/ocsp/ocsp_srv.c
@@ -171,12 +171,12 @@ int OCSP_basic_sign_ctx(OCSP_BASICRESP *brsp,
     OCSP_RESPID *rid;
     EVP_PKEY *pkey;
 
-    if (ctx == NULL || EVP_MD_CTX_pkey_ctx(ctx) == NULL) {
+    if (ctx == NULL || EVP_MD_CTX_get_pkey_ctx(ctx) == NULL) {
         ERR_raise(ERR_LIB_OCSP, OCSP_R_NO_SIGNER_KEY);
         goto err;
     }
 
-    pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_pkey_ctx(ctx));
+    pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_get_pkey_ctx(ctx));
     if (pkey == NULL || !X509_check_private_key(signer, pkey)) {
         ERR_raise(ERR_LIB_OCSP, OCSP_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);
         goto err;
@@ -223,7 +223,7 @@ int OCSP_basic_sign(OCSP_BASICRESP *brsp,
     if (ctx == NULL)
         return 0;
 
-    if (!EVP_DigestSignInit_ex(ctx, &amp;pkctx, EVP_MD_name(dgst),
+    if (!EVP_DigestSignInit_ex(ctx, &amp;pkctx, EVP_MD_get0_name(dgst),
                                signer-&gt;libctx, signer-&gt;propq, key, NULL)) {
         EVP_MD_CTX_free(ctx);
         return 0;
diff --git a/crypto/ocsp/ocsp_vfy.c b/crypto/ocsp/ocsp_vfy.c
index 4231c3f2b2..5e829fa972 100644
--- a/crypto/ocsp/ocsp_vfy.c
+++ b/crypto/ocsp/ocsp_vfy.c
@@ -327,7 +327,7 @@ static int ocsp_match_issuerid(X509 *cert, OCSP_CERTID *cid,
         }
         (void)ERR_pop_to_mark();
 
-        mdlen = EVP_MD_size(dgst);
+        mdlen = EVP_MD_get_size(dgst);
         if (mdlen &lt; 0) {
             ERR_raise(ERR_LIB_OCSP, OCSP_R_DIGEST_SIZE_ERR);
             goto end;
diff --git a/crypto/pem/pem_info.c b/crypto/pem/pem_info.c
index cd75a95e2a..061c9b9f68 100644
--- a/crypto/pem/pem_info.c
+++ b/crypto/pem/pem_info.c
@@ -232,14 +232,14 @@ int PEM_X509_INFO_write_bio(BIO *bp, const X509_INFO *xi, EVP_CIPHER *enc,
     const unsigned char *iv = NULL;
 
     if (enc != NULL) {
-        objstr = EVP_CIPHER_name(enc);
+        objstr = EVP_CIPHER_get0_name(enc);
         if (objstr == NULL
-                   /*
-                    * Check &quot;Proc-Type: 4,Encrypted\nDEK-Info: objstr,hex-iv\n&quot;
-                    * fits into buf
-                    */
-                || (strlen(objstr) + 23 + 2 * EVP_CIPHER_iv_length(enc) + 13)
-                   &gt; sizeof(buf)) {
+               /*
+                * Check &quot;Proc-Type: 4,Encrypted\nDEK-Info: objstr,hex-iv\n&quot;
+                * fits into buf
+                */
+            || strlen(objstr) + 23 + 2 * EVP_CIPHER_get_iv_length(enc) + 13
+               &gt; sizeof(buf)) {
             ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_CIPHER);
             goto err;
         }
@@ -267,7 +267,7 @@ int PEM_X509_INFO_write_bio(BIO *bp, const X509_INFO *xi, EVP_CIPHER *enc,
              * than what the user has passed us ... as we have to match
              * exactly for some strange reason
              */
-            objstr = EVP_CIPHER_name(xi-&gt;enc_cipher.cipher);
+            objstr = EVP_CIPHER_get0_name(xi-&gt;enc_cipher.cipher);
             if (objstr == NULL) {
                 ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_CIPHER);
                 goto err;
@@ -276,7 +276,7 @@ int PEM_X509_INFO_write_bio(BIO *bp, const X509_INFO *xi, EVP_CIPHER *enc,
             /* Create the right magic header stuff */
             buf[0] = '\0';
             PEM_proc_type(buf, PEM_TYPE_ENCRYPTED);
-            PEM_dek_info(buf, objstr, EVP_CIPHER_iv_length(enc),
+            PEM_dek_info(buf, objstr, EVP_CIPHER_get_iv_length(enc),
                          (const char *)iv);
 
             /* use the normal code to write things out */
diff --git a/crypto/pem/pem_lib.c b/crypto/pem/pem_lib.c
index d0516bc3fe..3948021702 100644
--- a/crypto/pem/pem_lib.c
+++ b/crypto/pem/pem_lib.c
@@ -323,14 +323,14 @@ int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
     unsigned char iv[EVP_MAX_IV_LENGTH];
 
     if (enc != NULL) {
-        objstr = EVP_CIPHER_name(enc);
-        if (objstr == NULL || EVP_CIPHER_iv_length(enc) == 0
-                || EVP_CIPHER_iv_length(enc) &gt; (int)sizeof(iv)
+        objstr = EVP_CIPHER_get0_name(enc);
+        if (objstr == NULL || EVP_CIPHER_get_iv_length(enc) == 0
+                || EVP_CIPHER_get_iv_length(enc) &gt; (int)sizeof(iv)
                    /*
                     * Check &quot;Proc-Type: 4,Encrypted\nDEK-Info: objstr,hex-iv\n&quot;
                     * fits into buf
                     */
-                || (strlen(objstr) + 23 + 2 * EVP_CIPHER_iv_length(enc) + 13)
+                || strlen(objstr) + 23 + 2 * EVP_CIPHER_get_iv_length(enc) + 13
                    &gt; sizeof(buf)) {
             ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_CIPHER);
             goto err;
@@ -368,7 +368,8 @@ int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
 #endif
             kstr = (unsigned char *)buf;
         }
-        if (RAND_bytes(iv, EVP_CIPHER_iv_length(enc)) &lt;= 0) /* Generate a salt */
+        /* Generate a salt */
+        if (RAND_bytes(iv, EVP_CIPHER_get_iv_length(enc)) &lt;= 0)
             goto err;
         /*
          * The 'iv' is used as the iv and as a salt.  It is NOT taken from
@@ -382,7 +383,7 @@ int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
 
         buf[0] = '\0';
         PEM_proc_type(buf, PEM_TYPE_ENCRYPTED);
-        PEM_dek_info(buf, objstr, EVP_CIPHER_iv_length(enc), (char *)iv);
+        PEM_dek_info(buf, objstr, EVP_CIPHER_get_iv_length(enc), (char *)iv);
         /* k=strlen(buf); */
 
         ret = 1;
@@ -548,7 +549,7 @@ int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
         ERR_raise(ERR_LIB_PEM, PEM_R_UNSUPPORTED_ENCRYPTION);
         return 0;
     }
-    ivlen = EVP_CIPHER_iv_length(enc);
+    ivlen = EVP_CIPHER_get_iv_length(enc);
     if (ivlen &gt; 0 &amp;&amp; *header++ != ',') {
         ERR_raise(ERR_LIB_PEM, PEM_R_MISSING_DEK_IV);
         return 0;
@@ -557,7 +558,7 @@ int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
         return 0;
     }
 
-    if (!load_iv(&amp;header, cipher-&gt;iv, EVP_CIPHER_iv_length(enc)))
+    if (!load_iv(&amp;header, cipher-&gt;iv, EVP_CIPHER_get_iv_length(enc)))
         return 0;
 
     return 1;
diff --git a/crypto/pem/pem_local.h b/crypto/pem/pem_local.h
index 628a66912d..a84ca80be1 100644
--- a/crypto/pem/pem_local.h
+++ b/crypto/pem/pem_local.h
@@ -62,7 +62,7 @@
     }                                                                   \
     if (enc != NULL) {                                                  \
         ret = 0;                                                        \
-        if (OSSL_ENCODER_CTX_set_cipher(ctx, EVP_CIPHER_name(enc),      \
+        if (OSSL_ENCODER_CTX_set_cipher(ctx, EVP_CIPHER_get0_name(enc), \
                                         NULL)) {                        \
             ret = 1;                                                    \
             if (kstr != NULL                                            \
diff --git a/crypto/pem/pem_pk8.c b/crypto/pem/pem_pk8.c
index 5e28907be3..ab86448db9 100644
--- a/crypto/pem/pem_pk8.c
+++ b/crypto/pem/pem_pk8.c
@@ -103,7 +103,8 @@ static int do_pk8pkey(BIO *bp, const EVP_PKEY *x, int isder, int nid,
         ret = 1;
         if (enc != NULL) {
             ret = 0;
-            if (OSSL_ENCODER_CTX_set_cipher(ctx, EVP_CIPHER_name(enc), NULL)) {
+            if (OSSL_ENCODER_CTX_set_cipher(ctx, EVP_CIPHER_get0_name(enc),
+                                            NULL)) {
                 const unsigned char *ukstr = (const unsigned char *)kstr;
 
                 /*
diff --git a/crypto/pem/pem_sign.c b/crypto/pem/pem_sign.c
index b52764e0ac..8a147dbfc0 100644
--- a/crypto/pem/pem_sign.c
+++ b/crypto/pem/pem_sign.c
@@ -32,7 +32,7 @@ int PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,
     int i, ret = 0;
     unsigned int m_len;
 
-    m = OPENSSL_malloc(EVP_PKEY_size(pkey));
+    m = OPENSSL_malloc(EVP_PKEY_get_size(pkey));
     if (m == NULL) {
         ERR_raise(ERR_LIB_PEM, ERR_R_MALLOC_FAILURE);
         goto err;
diff --git a/crypto/pem/pvkfmt.c b/crypto/pem/pvkfmt.c
index 1ff68e2158..11ac0a7c40 100644
--- a/crypto/pem/pvkfmt.c
+++ b/crypto/pem/pvkfmt.c
@@ -1027,7 +1027,7 @@ static int i2b_PVK(unsigned char **out, const EVP_PKEY *pk, int enclevel,
 
     write_ledword(&amp;p, MS_PVKMAGIC);
     write_ledword(&amp;p, 0);
-    if (EVP_PKEY_id(pk) == EVP_PKEY_RSA)
+    if (EVP_PKEY_get_id(pk) == EVP_PKEY_RSA)
         write_ledword(&amp;p, MS_KEYTYPE_KEYX);
 #ifndef OPENSSL_NO_DSA
     else
diff --git a/crypto/pkcs12/p12_crpt.c b/crypto/pkcs12/p12_crpt.c
index 777bc93ac3..57d1caecfc 100644
--- a/crypto/pkcs12/p12_crpt.c
+++ b/crypto/pkcs12/p12_crpt.c
@@ -49,15 +49,17 @@ int PKCS12_PBE_keyivgen_ex(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
     salt = pbe-&gt;salt-&gt;data;
     saltlen = pbe-&gt;salt-&gt;length;
     if (!PKCS12_key_gen_utf8_ex(pass, passlen, salt, saltlen, PKCS12_KEY_ID,
-                                iter, EVP_CIPHER_key_length(cipher), key, md,
+                                iter, EVP_CIPHER_get_key_length(cipher),
+                                key, md,
                                 libctx, propq)) {
         ERR_raise(ERR_LIB_PKCS12, PKCS12_R_KEY_GEN_ERROR);
         PBEPARAM_free(pbe);
         return 0;
     }
-    if (EVP_CIPHER_iv_length(cipher) &gt; 0) {
+    if (EVP_CIPHER_get_iv_length(cipher) &gt; 0) {
         if (!PKCS12_key_gen_utf8_ex(pass, passlen, salt, saltlen, PKCS12_IV_ID,
-                                    iter, EVP_CIPHER_iv_length(cipher), iv, md,
+                                    iter, EVP_CIPHER_get_iv_length(cipher),
+                                    iv, md,
                                     libctx, propq)) {
             ERR_raise(ERR_LIB_PKCS12, PKCS12_R_IV_GEN_ERROR);
             PBEPARAM_free(pbe);
diff --git a/crypto/pkcs12/p12_decr.c b/crypto/pkcs12/p12_decr.c
index ef316d044b..87232e7737 100644
--- a/crypto/pkcs12/p12_decr.c
+++ b/crypto/pkcs12/p12_decr.c
@@ -43,15 +43,15 @@ unsigned char *PKCS12_pbe_crypt_ex(const X509_ALGOR *algor,
      * It's appended to encrypted text on encrypting
      * MAC should be processed on decrypting separately from plain text
      */
-    max_out_len = inlen + EVP_CIPHER_CTX_block_size(ctx);
-    if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(ctx))
+    max_out_len = inlen + EVP_CIPHER_CTX_get_block_size(ctx);
+    if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ctx))
                 &amp; EVP_CIPH_FLAG_CIPHER_WITH_MAC) != 0) {
         if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_TLS1_AAD, 0, &amp;mac_len) &lt; 0) {
             ERR_raise(ERR_LIB_PKCS12, ERR_R_INTERNAL_ERROR);
             goto err;
         }
 
-        if (EVP_CIPHER_CTX_encrypting(ctx)) {
+        if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
             max_out_len += mac_len;
         } else {
             if (inlen &lt; mac_len) {
@@ -89,9 +89,9 @@ unsigned char *PKCS12_pbe_crypt_ex(const X509_ALGOR *algor,
         goto err;
     }
     outlen += i;
-    if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(ctx))
+    if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ctx))
                 &amp; EVP_CIPH_FLAG_CIPHER_WITH_MAC) != 0) {
-        if (EVP_CIPHER_CTX_encrypting(ctx)) {
+        if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
             if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG,
                 (int)mac_len, out+outlen) &lt; 0) {
                 ERR_raise(ERR_LIB_PKCS12, ERR_R_INTERNAL_ERROR);
diff --git a/crypto/pkcs12/p12_key.c b/crypto/pkcs12/p12_key.c
index a4ed0e516c..41a2d7293e 100644
--- a/crypto/pkcs12/p12_key.c
+++ b/crypto/pkcs12/p12_key.c
@@ -98,7 +98,8 @@ int PKCS12_key_gen_uni_ex(unsigned char *pass, int passlen, unsigned char *salt,
         return 0;
 
     *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
-                                            (char *)EVP_MD_name(md_type), 0);
+                                            (char *)EVP_MD_get0_name(md_type),
+                                            0);
     *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_PASSWORD,
                                              pass, passlen);
     *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
diff --git a/crypto/pkcs12/p12_mutl.c b/crypto/pkcs12/p12_mutl.c
index be4ed16ab7..88655651a0 100644
--- a/crypto/pkcs12/p12_mutl.c
+++ b/crypto/pkcs12/p12_mutl.c
@@ -117,8 +117,8 @@ static int pkcs12_gen_mac(PKCS12 *p12, const char *pass, int passlen,
         ERR_raise(ERR_LIB_PKCS12, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);
         return 0;
     }
-    md_size = EVP_MD_size(md);
-    md_nid = EVP_MD_type(md);
+    md_size = EVP_MD_get_size(md);
+    md_nid = EVP_MD_get_type(md);
     if (md_size &lt; 0)
         goto err;
     if ((md_nid == NID_id_GostR3411_94
@@ -267,7 +267,7 @@ int PKCS12_setup_mac(PKCS12 *p12, int iter, unsigned char *salt, int saltlen,
     } else
         memcpy(p12-&gt;mac-&gt;salt-&gt;data, salt, saltlen);
     X509_SIG_getm(p12-&gt;mac-&gt;dinfo, &amp;macalg, NULL);
-    if (!X509_ALGOR_set0(macalg, OBJ_nid2obj(EVP_MD_type(md_type)),
+    if (!X509_ALGOR_set0(macalg, OBJ_nid2obj(EVP_MD_get_type(md_type)),
                          V_ASN1_NULL, NULL)) {
         ERR_raise(ERR_LIB_PKCS12, ERR_R_MALLOC_FAILURE);
         return 0;
diff --git a/crypto/pkcs7/pk7_doit.c b/crypto/pkcs7/pk7_doit.c
index 8d4e95a3b4..441bf78bba 100644
--- a/crypto/pkcs7/pk7_doit.c
+++ b/crypto/pkcs7/pk7_doit.c
@@ -296,16 +296,16 @@ BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)
             goto err;
         }
         BIO_get_cipher_ctx(btmp, &amp;ctx);
-        keylen = EVP_CIPHER_key_length(evp_cipher);
-        ivlen = EVP_CIPHER_iv_length(evp_cipher);
-        xalg-&gt;algorithm = OBJ_nid2obj(EVP_CIPHER_type(evp_cipher));
+        keylen = EVP_CIPHER_get_key_length(evp_cipher);
+        ivlen = EVP_CIPHER_get_iv_length(evp_cipher);
+        xalg-&gt;algorithm = OBJ_nid2obj(EVP_CIPHER_get_type(evp_cipher));
         if (ivlen &gt; 0)
             if (RAND_bytes_ex(libctx, iv, ivlen, 0) &lt;= 0)
                 goto err;
 
         (void)ERR_set_mark();
         fetched_cipher = EVP_CIPHER_fetch(libctx,
-                                          EVP_CIPHER_name(evp_cipher),
+                                          EVP_CIPHER_get0_name(evp_cipher),
                                           propq);
         (void)ERR_pop_to_mark();
         if (fetched_cipher != NULL)
@@ -572,7 +572,7 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
                 ri = sk_PKCS7_RECIP_INFO_value(rsk, i);
                 ri-&gt;ctx = p7_ctx;
                 if (pkcs7_decrypt_rinfo(&amp;ek, &amp;eklen, ri, pkey,
-                        EVP_CIPHER_key_length(cipher)) &lt; 0)
+                        EVP_CIPHER_get_key_length(cipher)) &lt; 0)
                     goto err;
                 ERR_clear_error();
             }
@@ -591,7 +591,7 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
         if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg-&gt;parameter) &lt; 0)
             goto err;
         /* Generate random key as MMA defence */
-        len = EVP_CIPHER_CTX_key_length(evp_ctx);
+        len = EVP_CIPHER_CTX_get_key_length(evp_ctx);
         if (len &lt;= 0)
             goto err;
         tkeylen = (size_t)len;
@@ -606,7 +606,7 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
             tkey = NULL;
         }
 
-        if (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) {
+        if (eklen != EVP_CIPHER_CTX_get_key_length(evp_ctx)) {
             /*
              * Some S/MIME clients don't use the same key and effective key
              * length. The key length is determined by the size of the
@@ -679,7 +679,7 @@ static BIO *PKCS7_find_digest(EVP_MD_CTX **pmd, BIO *bio, int nid)
             ERR_raise(ERR_LIB_PKCS7, ERR_R_INTERNAL_ERROR);
             return NULL;
         }
-        if (EVP_MD_CTX_type(*pmd) == nid)
+        if (EVP_MD_CTX_get_type(*pmd) == nid)
             return bio;
         bio = BIO_next(bio);
     }
@@ -837,7 +837,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
             } else {
                 unsigned char *abuf = NULL;
                 unsigned int abuflen;
-                abuflen = EVP_PKEY_size(si-&gt;pkey);
+                abuflen = EVP_PKEY_get_size(si-&gt;pkey);
                 abuf = OPENSSL_malloc(abuflen);
                 if (abuf == NULL)
                     goto err;
@@ -915,7 +915,7 @@ int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si)
         goto err;
     }
 
-    if (EVP_DigestSignInit_ex(mctx, &amp;pctx, EVP_MD_name(md),
+    if (EVP_DigestSignInit_ex(mctx, &amp;pctx, EVP_MD_get0_name(md),
                               ossl_pkcs7_ctx_get0_libctx(ctx),
                               ossl_pkcs7_ctx_get0_propq(ctx), si-&gt;pkey,
                               NULL) &lt;= 0)
@@ -1044,13 +1044,13 @@ int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
             ERR_raise(ERR_LIB_PKCS7, ERR_R_INTERNAL_ERROR);
             goto err;
         }
-        if (EVP_MD_CTX_type(mdc) == md_type)
+        if (EVP_MD_CTX_get_type(mdc) == md_type)
             break;
         /*
          * Workaround for some broken clients that put the signature OID
          * instead of the digest OID in digest_alg-&gt;algorithm
          */
-        if (EVP_MD_pkey_type(EVP_MD_CTX_get0_md(mdc)) == md_type)
+        if (EVP_MD_get_pkey_type(EVP_MD_CTX_get0_md(mdc)) == md_type)
             break;
         btmp = BIO_next(btmp);
     }
diff --git a/crypto/pkcs7/pk7_lib.c b/crypto/pkcs7/pk7_lib.c
index a4b62f40dd..c32a666626 100644
--- a/crypto/pkcs7/pk7_lib.c
+++ b/crypto/pkcs7/pk7_lib.c
@@ -316,7 +316,7 @@ static int pkcs7_ecdsa_or_dsa_sign_verify_setup(PKCS7_SIGNER_INFO *si,
         hnid = OBJ_obj2nid(alg1-&gt;algorithm);
         if (hnid == NID_undef)
             return -1;
-        if (!OBJ_find_sigid_by_algs(&amp;snid, hnid, EVP_PKEY_id(pkey)))
+        if (!OBJ_find_sigid_by_algs(&amp;snid, hnid, EVP_PKEY_get_id(pkey)))
             return -1;
         X509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);
     }
@@ -362,7 +362,7 @@ int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,
 
     /* Set the algorithms */
 
-    X509_ALGOR_set0(p7i-&gt;digest_alg, OBJ_nid2obj(EVP_MD_type(dgst)),
+    X509_ALGOR_set0(p7i-&gt;digest_alg, OBJ_nid2obj(EVP_MD_get_type(dgst)),
                     V_ASN1_NULL, NULL);
 
     if (EVP_PKEY_is_a(pkey, &quot;EC&quot;) || EVP_PKEY_is_a(pkey, &quot;DSA&quot;))
@@ -689,7 +689,7 @@ int PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher)
     }
 
     /* Check cipher OID exists and has data in it */
-    i = EVP_CIPHER_type(cipher);
+    i = EVP_CIPHER_get_type(cipher);
     if (i == NID_undef) {
         ERR_raise(ERR_LIB_PKCS7, PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);
         return 0;
diff --git a/crypto/provider.c b/crypto/provider.c
index 766086a47b..52647b2e77 100644
--- a/crypto/provider.c
+++ b/crypto/provider.c
@@ -129,7 +129,7 @@ int OSSL_PROVIDER_add_builtin(OSSL_LIB_CTX *libctx, const char *name,
     return 1;
 }
 
-const char *OSSL_PROVIDER_name(const OSSL_PROVIDER *prov)
+const char *OSSL_PROVIDER_get0_name(const OSSL_PROVIDER *prov)
 {
     return ossl_provider_name(prov);
 }
diff --git a/crypto/provider_core.c b/crypto/provider_core.c
index ca2bfdb8fa..eac5b58946 100644
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -1729,7 +1729,7 @@ static const OSSL_DISPATCH core_dispatch_[] = {
     { OSSL_FUNC_PROVIDER_DEREGISTER_CHILD_CB,
         (void (*)(void))ossl_provider_deregister_child_cb },
     { OSSL_FUNC_PROVIDER_NAME,
-        (void (*)(void))OSSL_PROVIDER_name },
+        (void (*)(void))OSSL_PROVIDER_get0_name },
     { OSSL_FUNC_PROVIDER_GET0_PROVIDER_CTX,
         (void (*)(void))OSSL_PROVIDER_get0_provider_ctx },
     { OSSL_FUNC_PROVIDER_GET0_DISPATCH,
diff --git a/crypto/rand/rand_lib.c b/crypto/rand/rand_lib.c
index 56e615f6b9..a7a8c70523 100644
--- a/crypto/rand/rand_lib.c
+++ b/crypto/rand/rand_lib.c
@@ -298,7 +298,7 @@ int RAND_status(void)
 
     if ((rand = RAND_get0_primary(NULL)) == NULL)
         return 0;
-    return EVP_RAND_state(rand) == EVP_RAND_STATE_READY;
+    return EVP_RAND_get_state(rand) == EVP_RAND_STATE_READY;
 }
 # else  /* !FIPS_MODULE */
 
diff --git a/crypto/rand/rand_meth.c b/crypto/rand/rand_meth.c
index c0484823a2..49bf0acdf5 100644
--- a/crypto/rand/rand_meth.c
+++ b/crypto/rand/rand_meth.c
@@ -36,7 +36,7 @@ static int drbg_status(void)
     if (drbg == NULL)
         return 0;
 
-    return  EVP_RAND_state(drbg) == EVP_RAND_STATE_READY ? 1 : 0;
+    return  EVP_RAND_get_state(drbg) == EVP_RAND_STATE_READY ? 1 : 0;
 }
 
 /* Implements the default OpenSSL RAND_bytes() method */
diff --git a/crypto/rsa/rsa_ameth.c b/crypto/rsa/rsa_ameth.c
index f2283d81bd..1d3b8685bd 100644
--- a/crypto/rsa/rsa_ameth.c
+++ b/crypto/rsa/rsa_ameth.c
@@ -427,7 +427,7 @@ static int rsa_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
                 ERR_raise(ERR_LIB_RSA, ERR_R_INTERNAL_ERROR);
                 return 0;
             }
-            *(int *)arg2 = EVP_MD_type(md);
+            *(int *)arg2 = EVP_MD_get_type(md);
             /* Return of 2 indicates this MD is mandatory */
             return 2;
         }
@@ -457,10 +457,10 @@ static RSA_PSS_PARAMS *rsa_ctx_to_pss(EVP_PKEY_CTX *pkctx)
     if (!EVP_PKEY_CTX_get_rsa_pss_saltlen(pkctx, &amp;saltlen))
         return NULL;
     if (saltlen == -1) {
-        saltlen = EVP_MD_size(sigmd);
+        saltlen = EVP_MD_get_size(sigmd);
     } else if (saltlen == -2 || saltlen == -3) {
-        saltlen = EVP_PKEY_size(pk) - EVP_MD_size(sigmd) - 2;
-        if ((EVP_PKEY_bits(pk) &amp; 0x7) == 1)
+        saltlen = EVP_PKEY_get_size(pk) - EVP_MD_get_size(sigmd) - 2;
+        if ((EVP_PKEY_get_bits(pk) &amp; 0x7) == 1)
             saltlen--;
         if (saltlen &lt; 0)
             return NULL;
@@ -545,7 +545,7 @@ int ossl_rsa_pss_to_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pkctx,
         const EVP_MD *checkmd;
         if (EVP_PKEY_CTX_get_signature_md(pkctx, &amp;checkmd) &lt;= 0)
             goto err;
-        if (EVP_MD_type(md) != EVP_MD_type(checkmd)) {
+        if (EVP_MD_get_type(md) != EVP_MD_get_type(checkmd)) {
             ERR_raise(ERR_LIB_RSA, RSA_R_DIGEST_DOES_NOT_MATCH);
             goto err;
         }
@@ -629,7 +629,7 @@ static int rsa_item_sign(EVP_MD_CTX *ctx, const ASN1_ITEM *it, const void *asn,
                          ASN1_BIT_STRING *sig)
 {
     int pad_mode;
-    EVP_PKEY_CTX *pkctx = EVP_MD_CTX_pkey_ctx(ctx);
+    EVP_PKEY_CTX *pkctx = EVP_MD_CTX_get_pkey_ctx(ctx);
 
     if (EVP_PKEY_CTX_get_rsa_padding(pkctx, &amp;pad_mode) &lt;= 0)
         return 0;
@@ -674,18 +674,19 @@ static int rsa_sig_info_set(X509_SIG_INFO *siginf, const X509_ALGOR *sigalg,
     pss = ossl_rsa_pss_decode(sigalg);
     if (!ossl_rsa_pss_get_param(pss, &amp;md, &amp;mgf1md, &amp;saltlen))
         goto err;
-    mdnid = EVP_MD_type(md);
+    mdnid = EVP_MD_get_type(md);
     /*
      * For TLS need SHA256, SHA384 or SHA512, digest and MGF1 digest must
      * match and salt length must equal digest size
      */
     if ((mdnid == NID_sha256 || mdnid == NID_sha384 || mdnid == NID_sha512)
-            &amp;&amp; mdnid == EVP_MD_type(mgf1md) &amp;&amp; saltlen == EVP_MD_size(md))
+            &amp;&amp; mdnid == EVP_MD_get_type(mgf1md)
+            &amp;&amp; saltlen == EVP_MD_get_size(md))
         flags = X509_SIG_INFO_TLS;
     else
         flags = 0;
     /* Note: security bits half number of digest bits */
-    secbits = EVP_MD_size(md) * 4;
+    secbits = EVP_MD_get_size(md) * 4;
     /*
      * SHA1 and MD5 are known to be broken. Reduce security bits so that
      * they're no longer accepted at security level 1. The real values don't
@@ -763,8 +764,8 @@ static int rsa_int_export_to(const EVP_PKEY *from, int rsa_type,
         if (!ossl_rsa_pss_get_param_unverified(rsa-&gt;pss, &amp;md, &amp;mgf1md,
                                                &amp;saltlen, &amp;trailerfield))
             goto err;
-        md_nid = EVP_MD_type(md);
-        mgf1md_nid = EVP_MD_type(mgf1md);
+        md_nid = EVP_MD_get_type(md);
+        mgf1md_nid = EVP_MD_get_type(mgf1md);
         if (!ossl_rsa_pss_params_30_set_defaults(&amp;pss_params)
             || !ossl_rsa_pss_params_30_set_hashalg(&amp;pss_params, md_nid)
             || !ossl_rsa_pss_params_30_set_maskgenhashalg(&amp;pss_params,
diff --git a/crypto/rsa/rsa_backend.c b/crypto/rsa/rsa_backend.c
index 4a0ad2856b..5b7d60d6e1 100644
--- a/crypto/rsa/rsa_backend.c
+++ b/crypto/rsa/rsa_backend.c
@@ -480,8 +480,8 @@ static int ossl_rsa_sync_to_pss_params_30(RSA *rsa)
         if (!ossl_rsa_pss_get_param_unverified(legacy_pss, &amp;md, &amp;mgf1md,
                                                &amp;saltlen, &amp;trailerField))
             return 0;
-        md_nid = EVP_MD_type(md);
-        mgf1md_nid = EVP_MD_type(mgf1md);
+        md_nid = EVP_MD_get_type(md);
+        mgf1md_nid = EVP_MD_get_type(mgf1md);
         if (!ossl_rsa_pss_params_30_set_defaults(&amp;pss_params)
             || !ossl_rsa_pss_params_30_set_hashalg(&amp;pss_params, md_nid)
             || !ossl_rsa_pss_params_30_set_maskgenhashalg(&amp;pss_params,
diff --git a/crypto/rsa/rsa_oaep.c b/crypto/rsa/rsa_oaep.c
index 00646648c7..d9be1a4f98 100644
--- a/crypto/rsa/rsa_oaep.c
+++ b/crypto/rsa/rsa_oaep.c
@@ -76,7 +76,7 @@ int ossl_rsa_padding_add_PKCS1_OAEP_mgf1_ex(OSSL_LIB_CTX *libctx,
     if (mgf1md == NULL)
         mgf1md = md;
 
-    mdlen = EVP_MD_size(md);
+    mdlen = EVP_MD_get_size(md);
     if (mdlen &lt;= 0) {
         ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_LENGTH);
         return 0;
@@ -184,7 +184,7 @@ int RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,
     if (mgf1md == NULL)
         mgf1md = md;
 
-    mdlen = EVP_MD_size(md);
+    mdlen = EVP_MD_get_size(md);
 
     if (tlen &lt;= 0 || flen &lt;= 0)
         return -1;
@@ -341,7 +341,7 @@ int PKCS1_MGF1(unsigned char *mask, long len,
 
     if (c == NULL)
         goto err;
-    mdlen = EVP_MD_size(dgst);
+    mdlen = EVP_MD_get_size(dgst);
     if (mdlen &lt; 0)
         goto err;
     /* step 4 */
diff --git a/crypto/rsa/rsa_pmeth.c b/crypto/rsa/rsa_pmeth.c
index 6e7e7a27e1..110d998ebd 100644
--- a/crypto/rsa/rsa_pmeth.c
+++ b/crypto/rsa/rsa_pmeth.c
@@ -138,12 +138,12 @@ static int pkey_rsa_sign(EVP_PKEY_CTX *ctx, unsigned char *sig,
     RSA *rsa = ctx-&gt;pkey-&gt;pkey.rsa;
 
     if (rctx-&gt;md) {
-        if (tbslen != (size_t)EVP_MD_size(rctx-&gt;md)) {
+        if (tbslen != (size_t)EVP_MD_get_size(rctx-&gt;md)) {
             ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_DIGEST_LENGTH);
             return -1;
         }
 
-        if (EVP_MD_type(rctx-&gt;md) == NID_mdc2) {
+        if (EVP_MD_get_type(rctx-&gt;md) == NID_mdc2) {
             unsigned int sltmp;
             if (rctx-&gt;pad_mode != RSA_PKCS1_PADDING)
                 return -1;
@@ -163,12 +163,12 @@ static int pkey_rsa_sign(EVP_PKEY_CTX *ctx, unsigned char *sig,
                 return -1;
             }
             memcpy(rctx-&gt;tbuf, tbs, tbslen);
-            rctx-&gt;tbuf[tbslen] = RSA_X931_hash_id(EVP_MD_type(rctx-&gt;md));
+            rctx-&gt;tbuf[tbslen] = RSA_X931_hash_id(EVP_MD_get_type(rctx-&gt;md));
             ret = RSA_private_encrypt(tbslen + 1, rctx-&gt;tbuf,
                                       sig, rsa, RSA_X931_PADDING);
         } else if (rctx-&gt;pad_mode == RSA_PKCS1_PADDING) {
             unsigned int sltmp;
-            ret = RSA_sign(EVP_MD_type(rctx-&gt;md),
+            ret = RSA_sign(EVP_MD_get_type(rctx-&gt;md),
                            tbs, tbslen, sig, &amp;sltmp, rsa);
             if (ret &lt;= 0)
                 return ret;
@@ -213,11 +213,11 @@ static int pkey_rsa_verifyrecover(EVP_PKEY_CTX *ctx,
             if (ret &lt; 1)
                 return 0;
             ret--;
-            if (rctx-&gt;tbuf[ret] != RSA_X931_hash_id(EVP_MD_type(rctx-&gt;md))) {
+            if (rctx-&gt;tbuf[ret] != RSA_X931_hash_id(EVP_MD_get_type(rctx-&gt;md))) {
                 ERR_raise(ERR_LIB_RSA, RSA_R_ALGORITHM_MISMATCH);
                 return 0;
             }
-            if (ret != EVP_MD_size(rctx-&gt;md)) {
+            if (ret != EVP_MD_get_size(rctx-&gt;md)) {
                 ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_DIGEST_LENGTH);
                 return 0;
             }
@@ -225,7 +225,7 @@ static int pkey_rsa_verifyrecover(EVP_PKEY_CTX *ctx,
                 memcpy(rout, rctx-&gt;tbuf, ret);
         } else if (rctx-&gt;pad_mode == RSA_PKCS1_PADDING) {
             size_t sltmp;
-            ret = ossl_rsa_verify(EVP_MD_type(rctx-&gt;md),
+            ret = ossl_rsa_verify(EVP_MD_get_type(rctx-&gt;md),
                                   NULL, 0, rout, &amp;sltmp,
                                   sig, siglen, ctx-&gt;pkey-&gt;pkey.rsa);
             if (ret &lt;= 0)
@@ -254,9 +254,9 @@ static int pkey_rsa_verify(EVP_PKEY_CTX *ctx,
 
     if (rctx-&gt;md) {
         if (rctx-&gt;pad_mode == RSA_PKCS1_PADDING)
-            return RSA_verify(EVP_MD_type(rctx-&gt;md), tbs, tbslen,
+            return RSA_verify(EVP_MD_get_type(rctx-&gt;md), tbs, tbslen,
                               sig, siglen, rsa);
-        if (tbslen != (size_t)EVP_MD_size(rctx-&gt;md)) {
+        if (tbslen != (size_t)EVP_MD_get_size(rctx-&gt;md)) {
             ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_DIGEST_LENGTH);
             return -1;
         }
@@ -360,7 +360,7 @@ static int check_padding_md(const EVP_MD *md, int padding)
     if (!md)
         return 1;
 
-    mdnid = EVP_MD_type(md);
+    mdnid = EVP_MD_get_type(md);
 
     if (padding == RSA_NO_PADDING) {
         ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_PADDING_MODE);
@@ -457,7 +457,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
                     return -2;
                 }
                 if ((p1 == RSA_PSS_SALTLEN_DIGEST
-                     &amp;&amp; rctx-&gt;min_saltlen &gt; EVP_MD_size(rctx-&gt;md))
+                     &amp;&amp; rctx-&gt;min_saltlen &gt; EVP_MD_get_size(rctx-&gt;md))
                     || (p1 &gt;= 0 &amp;&amp; p1 &lt; rctx-&gt;min_saltlen)) {
                     ERR_raise(ERR_LIB_RSA, RSA_R_PSS_SALTLEN_TOO_SMALL);
                     return 0;
@@ -508,7 +508,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
         if (!check_padding_md(p2, rctx-&gt;pad_mode))
             return 0;
         if (rsa_pss_restricted(rctx)) {
-            if (EVP_MD_type(rctx-&gt;md) == EVP_MD_type(p2))
+            if (EVP_MD_get_type(rctx-&gt;md) == EVP_MD_get_type(p2))
                 return 1;
             ERR_raise(ERR_LIB_RSA, RSA_R_DIGEST_NOT_ALLOWED);
             return 0;
@@ -534,7 +534,7 @@ static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
                 *(const EVP_MD **)p2 = rctx-&gt;md;
         } else {
             if (rsa_pss_restricted(rctx)) {
-                if (EVP_MD_type(rctx-&gt;mgf1md) == EVP_MD_type(p2))
+                if (EVP_MD_get_type(rctx-&gt;mgf1md) == EVP_MD_get_type(p2))
                     return 1;
                 ERR_raise(ERR_LIB_RSA, RSA_R_MGF1_DIGEST_NOT_ALLOWED);
                 return 0;
@@ -823,7 +823,7 @@ static int pkey_pss_init(EVP_PKEY_CTX *ctx)
         return 0;
 
     /* See if minimum salt length exceeds maximum possible */
-    max_saltlen = RSA_size(rsa) - EVP_MD_size(md);
+    max_saltlen = RSA_size(rsa) - EVP_MD_get_size(md);
     if ((RSA_bits(rsa) &amp; 0x7) == 1)
         max_saltlen--;
     if (min_saltlen &gt; max_saltlen) {
diff --git a/crypto/rsa/rsa_pss.c b/crypto/rsa/rsa_pss.c
index bca208340e..33874bfef8 100644
--- a/crypto/rsa/rsa_pss.c
+++ b/crypto/rsa/rsa_pss.c
@@ -53,7 +53,7 @@ int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
     if (mgf1Hash == NULL)
         mgf1Hash = Hash;
 
-    hLen = EVP_MD_size(Hash);
+    hLen = EVP_MD_get_size(Hash);
     if (hLen &lt; 0)
         goto err;
     /*-
@@ -164,7 +164,7 @@ int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,
     if (mgf1Hash == NULL)
         mgf1Hash = Hash;
 
-    hLen = EVP_MD_size(Hash);
+    hLen = EVP_MD_get_size(Hash);
     if (hLen &lt; 0)
         goto err;
     /*-
diff --git a/crypto/rsa/rsa_sp800_56b_gen.c b/crypto/rsa/rsa_sp800_56b_gen.c
index d2052c5796..82b87cc5af 100644
--- a/crypto/rsa/rsa_sp800_56b_gen.c
+++ b/crypto/rsa/rsa_sp800_56b_gen.c
@@ -195,7 +195,7 @@ static int rsa_validate_rng_strength(EVP_RAND_CTX *rng, int nbits)
 {
     if (rng == NULL)
         return 0;
-    if (EVP_RAND_strength(rng) &lt; ossl_ifc_ffc_compute_security_bits(nbits)) {
+    if (EVP_RAND_get_strength(rng) &lt; ossl_ifc_ffc_compute_security_bits(nbits)) {
         ERR_raise(ERR_LIB_RSA,
                   RSA_R_RANDOMNESS_SOURCE_STRENGTH_INSUFFICIENT);
         return 0;
diff --git a/crypto/sm2/sm2_crypt.c b/crypto/sm2/sm2_crypt.c
index f2771dbe73..105dd4ce70 100644
--- a/crypto/sm2/sm2_crypt.c
+++ b/crypto/sm2/sm2_crypt.c
@@ -71,7 +71,7 @@ int ossl_sm2_plaintext_size(const EC_KEY *key, const EVP_MD *digest,
                             size_t msg_len, size_t *pt_size)
 {
     const size_t field_size = ec_field_size(EC_KEY_get0_group(key));
-    const int md_size = EVP_MD_size(digest);
+    const int md_size = EVP_MD_get_size(digest);
     size_t overhead;
 
     if (md_size &lt; 0) {
@@ -97,7 +97,7 @@ int ossl_sm2_ciphertext_size(const EC_KEY *key, const EVP_MD *digest,
                              size_t msg_len, size_t *ct_size)
 {
     const size_t field_size = ec_field_size(EC_KEY_get0_group(key));
-    const int md_size = EVP_MD_size(digest);
+    const int md_size = EVP_MD_get_size(digest);
     size_t sz;
 
     if (field_size == 0 || md_size &lt; 0)
@@ -137,7 +137,7 @@ int ossl_sm2_encrypt(const EC_KEY *key,
     uint8_t *x2y2 = NULL;
     uint8_t *C3 = NULL;
     size_t field_size;
-    const int C3_size = EVP_MD_size(digest);
+    const int C3_size = EVP_MD_get_size(digest);
     EVP_MD *fetched_digest = NULL;
     OSSL_LIB_CTX *libctx = ossl_ec_key_get_libctx(key);
     const char *propq = ossl_ec_key_get0_propq(key);
@@ -222,7 +222,7 @@ int ossl_sm2_encrypt(const EC_KEY *key,
     for (i = 0; i != msg_len; ++i)
         msg_mask[i] ^= msg[i];
 
-    fetched_digest = EVP_MD_fetch(libctx, EVP_MD_name(digest), propq);
+    fetched_digest = EVP_MD_fetch(libctx, EVP_MD_get0_name(digest), propq);
     if (fetched_digest == NULL) {
         ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
@@ -291,7 +291,7 @@ int ossl_sm2_decrypt(const EC_KEY *key,
     uint8_t *x2y2 = NULL;
     uint8_t *computed_C3 = NULL;
     const size_t field_size = ec_field_size(group);
-    const int hash_size = EVP_MD_size(digest);
+    const int hash_size = EVP_MD_get_size(digest);
     uint8_t *msg_mask = NULL;
     const uint8_t *C2 = NULL;
     const uint8_t *C3 = NULL;
diff --git a/crypto/sm2/sm2_sign.c b/crypto/sm2/sm2_sign.c
index 907d6585ea..72be1c00b4 100644
--- a/crypto/sm2/sm2_sign.c
+++ b/crypto/sm2/sm2_sign.c
@@ -145,7 +145,7 @@ static BIGNUM *sm2_compute_msg_hash(const EVP_MD *digest,
                                     const uint8_t *msg, size_t msg_len)
 {
     EVP_MD_CTX *hash = EVP_MD_CTX_new();
-    const int md_size = EVP_MD_size(digest);
+    const int md_size = EVP_MD_get_size(digest);
     uint8_t *z = NULL;
     BIGNUM *e = NULL;
     EVP_MD *fetched_digest = NULL;
@@ -163,7 +163,7 @@ static BIGNUM *sm2_compute_msg_hash(const EVP_MD *digest,
         goto done;
     }
 
-    fetched_digest = EVP_MD_fetch(libctx, EVP_MD_name(digest), propq);
+    fetched_digest = EVP_MD_fetch(libctx, EVP_MD_get0_name(digest), propq);
     if (fetched_digest == NULL) {
         ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
diff --git a/crypto/store/store_lib.c b/crypto/store/store_lib.c
index 1409f3aef4..f7939ea0dd 100644
--- a/crypto/store/store_lib.c
+++ b/crypto/store/store_lib.c
@@ -124,7 +124,7 @@ OSSL_STORE_open_ex(const char *uri, OSSL_LIB_CTX *libctx, const char *propq,
             &amp;&amp; (fetched_loader =
                 OSSL_STORE_LOADER_fetch(schemes[i], libctx, propq)) != NULL) {
             const OSSL_PROVIDER *provider =
-                OSSL_STORE_LOADER_provider(fetched_loader);
+                OSSL_STORE_LOADER_get0_provider(fetched_loader);
             void *provctx = OSSL_PROVIDER_get0_provider_ctx(provider);
 
             loader_ctx = fetched_loader-&gt;p_open(provctx, uri);
@@ -351,7 +351,8 @@ int OSSL_STORE_find(OSSL_STORE_CTX *ctx, const OSSL_STORE_SEARCH *search)
             break;
         case OSSL_STORE_SEARCH_BY_KEY_FINGERPRINT:
             if (OSSL_PARAM_BLD_push_utf8_string(bld, OSSL_STORE_PARAM_DIGEST,
-                                                EVP_MD_name(search-&gt;digest), 0)
+                                                EVP_MD_get0_name(search-&gt;digest),
+                                                0)
                 &amp;&amp; OSSL_PARAM_BLD_push_octet_string(bld,
                                                     OSSL_STORE_PARAM_FINGERPRINT,
                                                     search-&gt;string,
@@ -790,7 +791,7 @@ int OSSL_STORE_supports_search(OSSL_STORE_CTX *ctx, int search_type)
 
     if (ctx-&gt;fetched_loader != NULL) {
         void *provctx =
-            ossl_provider_ctx(OSSL_STORE_LOADER_provider(ctx-&gt;fetched_loader));
+            ossl_provider_ctx(OSSL_STORE_LOADER_get0_provider(ctx-&gt;fetched_loader));
         const OSSL_PARAM *params;
         const OSSL_PARAM *p_subject = NULL;
         const OSSL_PARAM *p_issuer = NULL;
@@ -879,11 +880,11 @@ OSSL_STORE_SEARCH *OSSL_STORE_SEARCH_by_key_fingerprint(const EVP_MD *digest,
         return NULL;
     }
 
-    if (digest != NULL &amp;&amp; len != (size_t)EVP_MD_size(digest)) {
+    if (digest != NULL &amp;&amp; len != (size_t)EVP_MD_get_size(digest)) {
         ERR_raise_data(ERR_LIB_OSSL_STORE,
                        OSSL_STORE_R_FINGERPRINT_SIZE_DOES_NOT_MATCH_DIGEST,
                        &quot;%s size is %d, fingerprint size is %zu&quot;,
-                       EVP_MD_name(digest), EVP_MD_size(digest), len);
+                       EVP_MD_get0_name(digest), EVP_MD_get_size(digest), len);
         OPENSSL_free(search);
         return NULL;
     }
@@ -976,7 +977,7 @@ OSSL_STORE_CTX *OSSL_STORE_attach(BIO *bp, const char *scheme,
         &amp;&amp; (fetched_loader =
             OSSL_STORE_LOADER_fetch(scheme, libctx, propq)) != NULL) {
         const OSSL_PROVIDER *provider =
-            OSSL_STORE_LOADER_provider(fetched_loader);
+            OSSL_STORE_LOADER_get0_provider(fetched_loader);
         void *provctx = OSSL_PROVIDER_get0_provider_ctx(provider);
         OSSL_CORE_BIO *cbio = ossl_core_bio_new_from_bio(bp);
 
diff --git a/crypto/store/store_meth.c b/crypto/store/store_meth.c
index 7bf0a329ce..7f11d4fbea 100644
--- a/crypto/store/store_meth.c
+++ b/crypto/store/store_meth.c
@@ -373,7 +373,7 @@ OSSL_STORE_LOADER *ossl_store_loader_fetch_by_number(OSSL_LIB_CTX *libctx,
  * Library of basic method functions
  */
 
-const OSSL_PROVIDER *OSSL_STORE_LOADER_provider(const OSSL_STORE_LOADER *loader)
+const OSSL_PROVIDER *OSSL_STORE_LOADER_get0_provider(const OSSL_STORE_LOADER *loader)
 {
     if (!ossl_assert(loader != NULL)) {
         ERR_raise(ERR_LIB_OSSL_STORE, ERR_R_PASSED_NULL_PARAMETER);
@@ -383,7 +383,7 @@ const OSSL_PROVIDER *OSSL_STORE_LOADER_provider(const OSSL_STORE_LOADER *loader)
     return loader-&gt;prov;
 }
 
-const char *OSSL_STORE_LOADER_properties(const OSSL_STORE_LOADER *loader)
+const char *OSSL_STORE_LOADER_get0_properties(const OSSL_STORE_LOADER *loader)
 {
     if (!ossl_assert(loader != NULL)) {
         ERR_raise(ERR_LIB_OSSL_STORE, ERR_R_PASSED_NULL_PARAMETER);
@@ -393,7 +393,7 @@ const char *OSSL_STORE_LOADER_properties(const OSSL_STORE_LOADER *loader)
     return loader-&gt;propdef;
 }
 
-int OSSL_STORE_LOADER_number(const OSSL_STORE_LOADER *loader)
+int OSSL_STORE_LOADER_get_number(const OSSL_STORE_LOADER *loader)
 {
     if (!ossl_assert(loader != NULL)) {
         ERR_raise(ERR_LIB_OSSL_STORE, ERR_R_PASSED_NULL_PARAMETER);
@@ -403,7 +403,7 @@ int OSSL_STORE_LOADER_number(const OSSL_STORE_LOADER *loader)
     return loader-&gt;scheme_id;
 }
 
-const char *OSSL_STORE_LOADER_description(const OSSL_STORE_LOADER *loader)
+const char *OSSL_STORE_LOADER_get0_description(const OSSL_STORE_LOADER *loader)
 {
     return loader-&gt;description;
 }
diff --git a/crypto/store/store_result.c b/crypto/store/store_result.c
index 7c48d182a8..c78d96d532 100644
--- a/crypto/store/store_result.c
+++ b/crypto/store/store_result.c
@@ -88,7 +88,7 @@ int ossl_store_handle_load_result(const OSSL_PARAM params[], void *arg)
     OSSL_STORE_INFO **v = &amp;cbdata-&gt;v;
     OSSL_STORE_CTX *ctx = cbdata-&gt;ctx;
     const OSSL_PROVIDER *provider =
-        OSSL_STORE_LOADER_provider(ctx-&gt;fetched_loader);
+        OSSL_STORE_LOADER_get0_provider(ctx-&gt;fetched_loader);
     OSSL_LIB_CTX *libctx = ossl_provider_libctx(provider);
     const char *propq = ctx-&gt;properties;
     const OSSL_PARAM *p;
@@ -206,7 +206,7 @@ static EVP_PKEY *try_key_ref(struct extracted_param_data_st *data,
          * 2.  The keymgmt is from another provider, then we must
          *     do the export/import dance.
          */
-        if (EVP_KEYMGMT_provider(keymgmt) == provider) {
+        if (EVP_KEYMGMT_get0_provider(keymgmt) == provider) {
             keydata = evp_keymgmt_load(keymgmt, data-&gt;ref, data-&gt;ref_size);
         } else {
             struct evp_keymgmt_util_try_import_data_st import_data;
diff --git a/crypto/ts/ts_rsp_sign.c b/crypto/ts/ts_rsp_sign.c
index 172d444d09..8937bb2d66 100644
--- a/crypto/ts/ts_rsp_sign.c
+++ b/crypto/ts/ts_rsp_sign.c
@@ -484,7 +484,7 @@ static int ts_RESP_check_request(TS_RESP_CTX *ctx)
         return 0;
     }
     digest = msg_imprint-&gt;hashed_msg;
-    if (digest-&gt;length != EVP_MD_size(md)) {
+    if (digest-&gt;length != EVP_MD_get_size(md)) {
         TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,
                                     &quot;Bad message digest.&quot;);
         TS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_DATA_FORMAT);
@@ -711,8 +711,8 @@ static int ts_RESP_sign(TS_RESP_CTX *ctx)
 
     if (ctx-&gt;signer_md == NULL)
         signer_md = EVP_MD_fetch(ctx-&gt;libctx, &quot;SHA256&quot;, ctx-&gt;propq);
-    else if (EVP_MD_provider(ctx-&gt;signer_md) == NULL)
-        signer_md = EVP_MD_fetch(ctx-&gt;libctx, EVP_MD_name(ctx-&gt;signer_md),
+    else if (EVP_MD_get0_provider(ctx-&gt;signer_md) == NULL)
+        signer_md = EVP_MD_fetch(ctx-&gt;libctx, EVP_MD_get0_name(ctx-&gt;signer_md),
                                  ctx-&gt;propq);
     else
         signer_md = (EVP_MD *)ctx-&gt;signer_md;
diff --git a/crypto/ts/ts_rsp_verify.c b/crypto/ts/ts_rsp_verify.c
index 03e7312843..792a27ce57 100644
--- a/crypto/ts/ts_rsp_verify.c
+++ b/crypto/ts/ts_rsp_verify.c
@@ -447,7 +447,7 @@ static int ts_compute_imprint(BIO *data, TS_TST_INFO *tst_info,
     }
     (void)ERR_pop_to_mark();
 
-    length = EVP_MD_size(md);
+    length = EVP_MD_get_size(md);
     if (length &lt; 0)
         goto err;
     *imprint_len = length;
diff --git a/crypto/x509/x509_set.c b/crypto/x509/x509_set.c
index 8b2d8cc91d..d8ddde8aaa 100644
--- a/crypto/x509/x509_set.c
+++ b/crypto/x509/x509_set.c
@@ -255,7 +255,7 @@ static int x509_sig_info_init(X509_SIG_INFO *siginf, const X509_ALGOR *alg,
             ERR_raise(ERR_LIB_X509, X509_R_ERROR_GETTING_MD_BY_NID);
             return 0;
         }
-        siginf-&gt;secbits = EVP_MD_size(md) * 4;
+        siginf-&gt;secbits = EVP_MD_get_size(md) * 4;
         break;
     }
     switch (mdnid) {
diff --git a/crypto/x509/x509_vfy.c b/crypto/x509/x509_vfy.c
index edf3c51095..278b8b6765 100644
--- a/crypto/x509/x509_vfy.c
+++ b/crypto/x509/x509_vfy.c
@@ -3389,7 +3389,7 @@ static int check_key_level(X509_STORE_CTX *ctx, X509 *cert)
     if (level &gt; NUM_AUTH_LEVELS)
         level = NUM_AUTH_LEVELS;
 
-    return EVP_PKEY_security_bits(pkey) &gt;= minbits_table[level - 1];
+    return EVP_PKEY_get_security_bits(pkey) &gt;= minbits_table[level - 1];
 }
 
 /*-
@@ -3406,7 +3406,7 @@ static int check_curve(X509 *cert)
     if (pkey == NULL)
         return -1;
 
-    if (EVP_PKEY_id(pkey) == EVP_PKEY_EC) {
+    if (EVP_PKEY_get_id(pkey) == EVP_PKEY_EC) {
         int ret, val;
 
         ret = EVP_PKEY_get_int_param(pkey,
diff --git a/crypto/x509/x509type.c b/crypto/x509/x509type.c
index ca4310de1e..b0ed93cfbf 100644
--- a/crypto/x509/x509type.c
+++ b/crypto/x509/x509type.c
@@ -29,7 +29,7 @@ int X509_certificate_type(const X509 *x, const EVP_PKEY *pkey)
     if (pk == NULL)
         return 0;
 
-    switch (EVP_PKEY_id(pk)) {
+    switch (EVP_PKEY_get_id(pk)) {
     case EVP_PKEY_RSA:
         ret = EVP_PK_RSA | EVP_PKT_SIGN;
 /*              if (!sign only extension) */
diff --git a/crypto/x509/x_pubkey.c b/crypto/x509/x_pubkey.c
index 966a1a534b..7ae35f21fd 100644
--- a/crypto/x509/x_pubkey.c
+++ b/crypto/x509/x_pubkey.c
@@ -557,7 +557,7 @@ DH *ossl_d2i_DH_PUBKEY(DH **a, const unsigned char **pp, long length)
     pkey = d2i_PUBKEY_legacy(NULL, &amp;q, length);
     if (pkey == NULL)
         return NULL;
-    if (EVP_PKEY_id(pkey) == EVP_PKEY_DH)
+    if (EVP_PKEY_get_id(pkey) == EVP_PKEY_DH)
         key = EVP_PKEY_get1_DH(pkey);
     EVP_PKEY_free(pkey);
     if (key == NULL)
@@ -598,7 +598,7 @@ DH *ossl_d2i_DHx_PUBKEY(DH **a, const unsigned char **pp, long length)
     pkey = d2i_PUBKEY_legacy(NULL, &amp;q, length);
     if (pkey == NULL)
         return NULL;
-    if (EVP_PKEY_id(pkey) == EVP_PKEY_DHX)
+    if (EVP_PKEY_get_id(pkey) == EVP_PKEY_DHX)
         key = EVP_PKEY_get1_DH(pkey);
     EVP_PKEY_free(pkey);
     if (key == NULL)
@@ -684,7 +684,7 @@ EC_KEY *d2i_EC_PUBKEY(EC_KEY **a, const unsigned char **pp, long length)
     pkey = d2i_PUBKEY_legacy(NULL, &amp;q, length);
     if (pkey == NULL)
         return NULL;
-    type = EVP_PKEY_id(pkey);
+    type = EVP_PKEY_get_id(pkey);
     if (type == EVP_PKEY_EC || type == EVP_PKEY_SM2)
         key = EVP_PKEY_get1_EC_KEY(pkey);
     EVP_PKEY_free(pkey);
@@ -768,7 +768,7 @@ ECX_KEY *ossl_d2i_ED448_PUBKEY(ECX_KEY **a,
     pkey = d2i_PUBKEY_legacy(NULL, &amp;q, length);
     if (pkey == NULL)
         return NULL;
-    if (EVP_PKEY_id(pkey) == EVP_PKEY_ED448)
+    if (EVP_PKEY_get_id(pkey) == EVP_PKEY_ED448)
         key = ossl_evp_pkey_get1_ED448(pkey);
     EVP_PKEY_free(pkey);
     if (key == NULL)
@@ -810,7 +810,7 @@ ECX_KEY *ossl_d2i_X25519_PUBKEY(ECX_KEY **a,
     pkey = d2i_PUBKEY_legacy(NULL, &amp;q, length);
     if (pkey == NULL)
         return NULL;
-    if (EVP_PKEY_id(pkey) == EVP_PKEY_X25519)
+    if (EVP_PKEY_get_id(pkey) == EVP_PKEY_X25519)
         key = ossl_evp_pkey_get1_X25519(pkey);
     EVP_PKEY_free(pkey);
     if (key == NULL)
@@ -852,7 +852,7 @@ ECX_KEY *ossl_d2i_X448_PUBKEY(ECX_KEY **a,
     pkey = d2i_PUBKEY_legacy(NULL, &amp;q, length);
     if (pkey == NULL)
         return NULL;
-    if (EVP_PKEY_id(pkey) == EVP_PKEY_X448)
+    if (EVP_PKEY_get_id(pkey) == EVP_PKEY_X448)
         key = ossl_evp_pkey_get1_X448(pkey);
     EVP_PKEY_free(pkey);
     if (key == NULL)
diff --git a/demos/digest/BIO_f_md.c b/demos/digest/BIO_f_md.c
index ce1dfcc34a..2ecc53e137 100755
--- a/demos/digest/BIO_f_md.c
+++ b/demos/digest/BIO_f_md.c
@@ -68,7 +68,7 @@ int main(int argc, char * argv[])
         fprintf(stderr, &quot;EVP_MD_fetch did not find SHA3-512.\n&quot;);
         goto cleanup;
     }
-    digest_size = EVP_MD_size(md);
+    digest_size = EVP_MD_get_size(md);
     digest_value = OPENSSL_malloc(digest_size);
     if (digest_value == NULL) {
         fprintf(stderr, &quot;Can't allocate %lu bytes for the digest value.\n&quot;, (unsigned long)digest_size);
diff --git a/demos/digest/EVP_MD_demo.c b/demos/digest/EVP_MD_demo.c
index 77146e3f00..99589bd344 100644
--- a/demos/digest/EVP_MD_demo.c
+++ b/demos/digest/EVP_MD_demo.c
@@ -105,9 +105,9 @@ int demonstrate_digest(void)
         goto cleanup;
     }
     /* Determine the length of the fetched digest type */
-    digest_length = EVP_MD_size(message_digest);
+    digest_length = EVP_MD_get_size(message_digest);
     if (digest_length &lt;= 0) {
-        fprintf(stderr, &quot;EVP_MD_size returned invalid size.\n&quot;);
+        fprintf(stderr, &quot;EVP_MD_get_size returned invalid size.\n&quot;);
         goto cleanup;
     }
 
diff --git a/demos/digest/EVP_MD_stdin.c b/demos/digest/EVP_MD_stdin.c
index 3e24f342cb..71a3d325a3 100755
--- a/demos/digest/EVP_MD_stdin.c
+++ b/demos/digest/EVP_MD_stdin.c
@@ -63,9 +63,9 @@ int demonstrate_digest(BIO *input)
         return 0;
     }
     /* Determine the length of the fetched digest type */
-    digest_length = EVP_MD_size(message_digest);
+    digest_length = EVP_MD_get_size(message_digest);
     if (digest_length &lt;= 0) {
-        fprintf(stderr, &quot;EVP_MD_size returned invalid size.\n&quot;);
+        fprintf(stderr, &quot;EVP_MD_get_size returned invalid size.\n&quot;);
         goto cleanup;
     }
 
diff --git a/doc/build.info b/doc/build.info
index 42c1804d6c..b77dac210c 100644
--- a/doc/build.info
+++ b/doc/build.info
@@ -1227,6 +1227,10 @@ DEPEND[html/man3/EVP_PKEY_get_group_name.html]=man3/EVP_PKEY_get_group_name.pod
 GENERATE[html/man3/EVP_PKEY_get_group_name.html]=man3/EVP_PKEY_get_group_name.pod
 DEPEND[man/man3/EVP_PKEY_get_group_name.3]=man3/EVP_PKEY_get_group_name.pod
 GENERATE[man/man3/EVP_PKEY_get_group_name.3]=man3/EVP_PKEY_get_group_name.pod
+DEPEND[html/man3/EVP_PKEY_get_size.html]=man3/EVP_PKEY_get_size.pod
+GENERATE[html/man3/EVP_PKEY_get_size.html]=man3/EVP_PKEY_get_size.pod
+DEPEND[man/man3/EVP_PKEY_get_size.3]=man3/EVP_PKEY_get_size.pod
+GENERATE[man/man3/EVP_PKEY_get_size.3]=man3/EVP_PKEY_get_size.pod
 DEPEND[html/man3/EVP_PKEY_gettable_params.html]=man3/EVP_PKEY_gettable_params.pod
 GENERATE[html/man3/EVP_PKEY_gettable_params.html]=man3/EVP_PKEY_gettable_params.pod
 DEPEND[man/man3/EVP_PKEY_gettable_params.3]=man3/EVP_PKEY_gettable_params.pod
@@ -1275,10 +1279,6 @@ DEPEND[html/man3/EVP_PKEY_sign.html]=man3/EVP_PKEY_sign.pod
 GENERATE[html/man3/EVP_PKEY_sign.html]=man3/EVP_PKEY_sign.pod
 DEPEND[man/man3/EVP_PKEY_sign.3]=man3/EVP_PKEY_sign.pod
 GENERATE[man/man3/EVP_PKEY_sign.3]=man3/EVP_PKEY_sign.pod
-DEPEND[html/man3/EVP_PKEY_size.html]=man3/EVP_PKEY_size.pod
-GENERATE[html/man3/EVP_PKEY_size.html]=man3/EVP_PKEY_size.pod
-DEPEND[man/man3/EVP_PKEY_size.3]=man3/EVP_PKEY_size.pod
-GENERATE[man/man3/EVP_PKEY_size.3]=man3/EVP_PKEY_size.pod
 DEPEND[html/man3/EVP_PKEY_todata.html]=man3/EVP_PKEY_todata.pod
 GENERATE[html/man3/EVP_PKEY_todata.html]=man3/EVP_PKEY_todata.pod
 DEPEND[man/man3/EVP_PKEY_todata.3]=man3/EVP_PKEY_todata.pod
@@ -3014,6 +3014,7 @@ html/man3/EVP_PKEY_fromdata.html \
 html/man3/EVP_PKEY_get_default_digest_nid.html \
 html/man3/EVP_PKEY_get_field_type.html \
 html/man3/EVP_PKEY_get_group_name.html \
+html/man3/EVP_PKEY_get_size.html \
 html/man3/EVP_PKEY_gettable_params.html \
 html/man3/EVP_PKEY_is_a.html \
 html/man3/EVP_PKEY_keygen.html \
@@ -3026,7 +3027,6 @@ html/man3/EVP_PKEY_set1_encoded_public_key.html \
 html/man3/EVP_PKEY_set_type.html \
 html/man3/EVP_PKEY_settable_params.html \
 html/man3/EVP_PKEY_sign.html \
-html/man3/EVP_PKEY_size.html \
 html/man3/EVP_PKEY_todata.html \
 html/man3/EVP_PKEY_verify.html \
 html/man3/EVP_PKEY_verify_recover.html \
@@ -3603,6 +3603,7 @@ man/man3/EVP_PKEY_fromdata.3 \
 man/man3/EVP_PKEY_get_default_digest_nid.3 \
 man/man3/EVP_PKEY_get_field_type.3 \
 man/man3/EVP_PKEY_get_group_name.3 \
+man/man3/EVP_PKEY_get_size.3 \
 man/man3/EVP_PKEY_gettable_params.3 \
 man/man3/EVP_PKEY_is_a.3 \
 man/man3/EVP_PKEY_keygen.3 \
@@ -3615,7 +3616,6 @@ man/man3/EVP_PKEY_set1_encoded_public_key.3 \
 man/man3/EVP_PKEY_set_type.3 \
 man/man3/EVP_PKEY_settable_params.3 \
 man/man3/EVP_PKEY_sign.3 \
-man/man3/EVP_PKEY_size.3 \
 man/man3/EVP_PKEY_todata.3 \
 man/man3/EVP_PKEY_verify.3 \
 man/man3/EVP_PKEY_verify_recover.3 \
diff --git a/doc/man3/BIO_f_md.pod b/doc/man3/BIO_f_md.pod
index 8ad694853f..aa60ff4eb8 100644
--- a/doc/man3/BIO_f_md.pod
+++ b/doc/man3/BIO_f_md.pod
@@ -128,7 +128,7 @@ outputs them. This could be used with the examples above.
      if (!mdtmp)
          break;
      BIO_get_md(mdtmp, &amp;md);
-     printf(&quot;%s digest&quot;, OBJ_nid2sn(EVP_MD_type(md)));
+     printf(&quot;%s digest&quot;, OBJ_nid2sn(EVP_MD_get_type(md)));
      mdlen = BIO_gets(mdtmp, mdbuf, EVP_MAX_MD_SIZE);
      for (i = 0; i &lt; mdlen; i++) printf(&quot;:%02X&quot;, mdbuf[i]);
      printf(&quot;\n&quot;);
diff --git a/doc/man3/DH_size.pod b/doc/man3/DH_size.pod
index e4b7e429a0..75cdc9744c 100644
--- a/doc/man3/DH_size.pod
+++ b/doc/man3/DH_size.pod
@@ -22,8 +22,8 @@ L&lt;openssl_user_macros(7)&gt;:
 =head1 DESCRIPTION
 
 The functions described on this page are deprecated.
-Applications should instead use L&lt;EVP_PKEY_bits(3)&gt;,
-L&lt;EVP_PKEY_security_bits(3)&gt; and L&lt;EVP_PKEY_size(3)&gt;.
+Applications should instead use L&lt;EVP_PKEY_get_bits(3)&gt;,
+L&lt;EVP_PKEY_get_security_bits(3)&gt; and L&lt;EVP_PKEY_get_size(3)&gt;.
 
 DH_bits() returns the number of significant bits.
 
@@ -49,7 +49,7 @@ B&lt;dh&gt; doesn't hold any key parameters.
 
 =head1 SEE ALSO
 
-L&lt;EVP_PKEY_bits(3)&gt;,
+L&lt;EVP_PKEY_get_bits(3)&gt;,
 L&lt;DH_new(3)&gt;, L&lt;DH_generate_key(3)&gt;,
 L&lt;BN_num_bits(3)&gt;
 
diff --git a/doc/man3/DSA_size.pod b/doc/man3/DSA_size.pod
index b904845447..0d0d1e5994 100644
--- a/doc/man3/DSA_size.pod
+++ b/doc/man3/DSA_size.pod
@@ -21,8 +21,8 @@ L&lt;openssl_user_macros(7)&gt;:
 =head1 DESCRIPTION
 
 All of the functions described on this page are deprecated.
-Applications should instead use L&lt;EVP_PKEY_bits(3)&gt;,
-L&lt;EVP_PKEY_security_bits(3)&gt; and L&lt;EVP_PKEY_size(3)&gt;.
+Applications should instead use L&lt;EVP_PKEY_get_bits(3)&gt;,
+L&lt;EVP_PKEY_get_security_bits(3)&gt; and L&lt;EVP_PKEY_get_size(3)&gt;.
 
 DSA_bits() returns the number of bits in key I&lt;dsa&gt;: this is the number
 of bits in the I&lt;p&gt; parameter.
@@ -47,9 +47,9 @@ hold any key parameters.
 
 =head1 SEE ALSO
 
-L&lt;EVP_PKEY_bits(3)&gt;,
-L&lt;EVP_PKEY_security_bits(3)&gt;,
-L&lt;EVP_PKEY_size(3)&gt;,
+L&lt;EVP_PKEY_get_bits(3)&gt;,
+L&lt;EVP_PKEY_get_security_bits(3)&gt;,
+L&lt;EVP_PKEY_get_size(3)&gt;,
 L&lt;DSA_new(3)&gt;, L&lt;DSA_sign(3)&gt;
 
 =head1 HISTORY
diff --git a/doc/man3/EVP_ASYM_CIPHER_free.pod b/doc/man3/EVP_ASYM_CIPHER_free.pod
index 93df44ec8f..2b34eb4469 100644
--- a/doc/man3/EVP_ASYM_CIPHER_free.pod
+++ b/doc/man3/EVP_ASYM_CIPHER_free.pod
@@ -3,9 +3,9 @@
 =head1 NAME
 
 EVP_ASYM_CIPHER_fetch, EVP_ASYM_CIPHER_free, EVP_ASYM_CIPHER_up_ref,
-EVP_ASYM_CIPHER_number, EVP_ASYM_CIPHER_is_a, EVP_ASYM_CIPHER_provider,
+EVP_ASYM_CIPHER_get_number, EVP_ASYM_CIPHER_is_a, EVP_ASYM_CIPHER_get0_provider,
 EVP_ASYM_CIPHER_do_all_provided, EVP_ASYM_CIPHER_names_do_all,
-EVP_ASYM_CIPHER_name, EVP_ASYM_CIPHER_description,
+EVP_ASYM_CIPHER_get0_name, EVP_ASYM_CIPHER_get0_description,
 EVP_ASYM_CIPHER_gettable_ctx_params, EVP_ASYM_CIPHER_settable_ctx_params
 - Functions to manage EVP_ASYM_CIPHER algorithm objects
 
@@ -17,10 +17,10 @@ EVP_ASYM_CIPHER_gettable_ctx_params, EVP_ASYM_CIPHER_settable_ctx_params
                                         const char *properties);
  void EVP_ASYM_CIPHER_free(EVP_ASYM_CIPHER *cipher);
  int EVP_ASYM_CIPHER_up_ref(EVP_ASYM_CIPHER *cipher);
- int EVP_ASYM_CIPHER_number(const EVP_ASYM_CIPHER *cipher);
- const char *EVP_ASYM_CIPHER_name(const EVP_ASYM_CIPHER *cipher);
+ int EVP_ASYM_CIPHER_get_number(const EVP_ASYM_CIPHER *cipher);
+ const char *EVP_ASYM_CIPHER_get0_name(const EVP_ASYM_CIPHER *cipher);
  int EVP_ASYM_CIPHER_is_a(const EVP_ASYM_CIPHER *cipher, const char *name);
- OSSL_PROVIDER *EVP_ASYM_CIPHER_provider(const EVP_ASYM_CIPHER *cipher);
+ OSSL_PROVIDER *EVP_ASYM_CIPHER_get0_provider(const EVP_ASYM_CIPHER *cipher);
  void EVP_ASYM_CIPHER_do_all_provided(OSSL_LIB_CTX *libctx,
                                       void (*fn)(EVP_ASYM_CIPHER *cipher,
                                                  void *arg),
@@ -28,7 +28,7 @@ EVP_ASYM_CIPHER_gettable_ctx_params, EVP_ASYM_CIPHER_settable_ctx_params
  int EVP_ASYM_CIPHER_names_do_all(const EVP_ASYM_CIPHER *cipher,
                                   void (*fn)(const char *name, void *data),
                                   void *data);
- const char *EVP_ASYM_CIPHER_description(const EVP_ASYM_CIPHER *cipher);
+ const char *EVP_ASYM_CIPHER_get0_description(const EVP_ASYM_CIPHER *cipher);
  const OSSL_PARAM *EVP_ASYM_CIPHER_gettable_ctx_params(const EVP_ASYM_CIPHER *cip);
  const OSSL_PARAM *EVP_ASYM_CIPHER_settable_ctx_params(const EVP_ASYM_CIPHER *cip);
 
@@ -54,17 +54,18 @@ B&lt;EVP_ASYM_CIPHER&gt; structure.
 EVP_ASYM_CIPHER_is_a() returns 1 if I&lt;cipher&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;, otherwise 0.
 
-EVP_ASYM_CIPHER_provider() returns the provider that I&lt;cipher&gt; was fetched from.
+EVP_ASYM_CIPHER_get0_provider() returns the provider that I&lt;cipher&gt; was
+fetched from.
 
 EVP_ASYM_CIPHER_do_all_provided() traverses all EVP_ASYM_CIPHERs implemented by
 all activated providers in the given library context I&lt;libctx&gt;, and for each of
 the implementations, calls the given function I&lt;fn&gt; with the implementation
 method and the given I&lt;arg&gt; as argument.
 
-EVP_ASYM_CIPHER_number() returns the internal dynamic number assigned to
+EVP_ASYM_CIPHER_get_number() returns the internal dynamic number assigned to
 I&lt;cipher&gt;.
 
-EVP_ASYM_CIPHER_name() returns the algorithm name from the provided
+EVP_ASYM_CIPHER_get0_name() returns the algorithm name from the provided
 implementation for the given I&lt;cipher&gt;. Note that the I&lt;cipher&gt; may have
 multiple synonyms associated with it. In this case the first name from the
 algorithm definition is returned. Ownership of the returned string is retained
@@ -73,9 +74,9 @@ by the I&lt;cipher&gt; object and should not be freed by the caller.
 EVP_ASYM_CIPHER_names_do_all() traverses all names for I&lt;cipher&gt;, and calls
 I&lt;fn&gt; with each name and I&lt;data&gt;.
 
-EVP_ASYM_CIPHER_description() returns a description of the I&lt;cipher&gt;, meant
-for display and human consumption.  The description is at the discretion of
-the I&lt;cipher&gt; implementation.
+EVP_ASYM_CIPHER_get0_description() returns a description of the I&lt;cipher&gt;,
+meant for display and human consumption.  The description is at the
+discretion of the I&lt;cipher&gt; implementation.
 
 EVP_ASYM_CIPHER_gettable_ctx_params() and EVP_ASYM_CIPHER_settable_ctx_params()
 return a constant B&lt;OSSL_PARAM&gt; array that describes the names and types of key
diff --git a/doc/man3/EVP_CIPHER_CTX_get_original_iv.pod b/doc/man3/EVP_CIPHER_CTX_get_original_iv.pod
index c5995a584d..f5021b8728 100644
--- a/doc/man3/EVP_CIPHER_CTX_get_original_iv.pod
+++ b/doc/man3/EVP_CIPHER_CTX_get_original_iv.pod
@@ -25,11 +25,12 @@ L&lt;openssl_user_macros(7)&gt;:
 
 EVP_CIPHER_CTX_get_original_iv() and EVP_CIPHER_CTX_get_updated_iv() copy
 initialization vector (IV) information from the B&lt;EVP_CIPHER_CTX&gt; into the
-caller-supplied buffer. L&lt;EVP_CIPHER_CTX_iv_length(3)&gt; can be used to determine
-an appropriate buffer size, and if the supplied buffer is too small, an error
-will be returned (and no data copied).  EVP_CIPHER_CTX_get_original_iv()
-accesses the (&quot;original&quot;) IV that was supplied when the B&lt;EVP_CIPHER_CTX&gt; was
-initialized, and EVP_CIPHER_CTX_get_updated_iv() accesses the current &quot;IV state&quot;
+caller-supplied buffer. L&lt;EVP_CIPHER_CTX_get_iv_length(3)&gt; can be used to
+determine an appropriate buffer size, and if the supplied buffer is too small,
+an error will be returned (and no data copied).
+EVP_CIPHER_CTX_get_original_iv() accesses the (&quot;original&quot;) IV that was
+supplied when the B&lt;EVP_CIPHER_CTX&gt; was initialized, and
+EVP_CIPHER_CTX_get_updated_iv() accesses the current &quot;IV state&quot;
 of the cipher, which is updated during cipher operation for certain cipher modes
 (e.g., CBC and OFB).
 
diff --git a/doc/man3/EVP_DigestInit.pod b/doc/man3/EVP_DigestInit.pod
index 4b6aaeeb1c..b1d83c1b89 100644
--- a/doc/man3/EVP_DigestInit.pod
+++ b/doc/man3/EVP_DigestInit.pod
@@ -12,17 +12,19 @@ EVP_MD_CTX_settable_params, EVP_MD_CTX_gettable_params,
 EVP_MD_CTX_set_flags, EVP_MD_CTX_clear_flags, EVP_MD_CTX_test_flags,
 EVP_Q_digest, EVP_Digest, EVP_DigestInit_ex2, EVP_DigestInit_ex, EVP_DigestInit,
 EVP_DigestUpdate, EVP_DigestFinal_ex, EVP_DigestFinalXOF, EVP_DigestFinal,
-EVP_MD_is_a, EVP_MD_name, EVP_MD_description, EVP_MD_number,
-EVP_MD_names_do_all, EVP_MD_provider,
-EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size, EVP_MD_block_size, EVP_MD_flags,
-EVP_MD_CTX_name,
-EVP_MD_CTX_md, EVP_MD_CTX_get0_md, EVP_MD_CTX_get1_md,
-EVP_MD_CTX_type, EVP_MD_CTX_size, EVP_MD_CTX_block_size,
-EVP_MD_CTX_md_data, EVP_MD_CTX_update_fn, EVP_MD_CTX_set_update_fn,
+EVP_MD_is_a, EVP_MD_get0_name, EVP_MD_get0_description, EVP_MD_get_number,
+EVP_MD_names_do_all, EVP_MD_get0_provider, EVP_MD_get_type,
+EVP_MD_get_pkey_type, EVP_MD_get_size, EVP_MD_get_block_size, EVP_MD_get_flags,
+EVP_MD_CTX_get0_name, EVP_MD_CTX_md, EVP_MD_CTX_get0_md, EVP_MD_CTX_get1_md,
+EVP_MD_CTX_get_type, EVP_MD_CTX_get_size, EVP_MD_CTX_get_block_size,
+EVP_MD_CTX_get0_md_data, EVP_MD_CTX_update_fn, EVP_MD_CTX_set_update_fn,
 EVP_md_null,
 EVP_get_digestbyname, EVP_get_digestbynid, EVP_get_digestbyobj,
-EVP_MD_CTX_pkey_ctx, EVP_MD_CTX_set_pkey_ctx,
-EVP_MD_do_all_provided
+EVP_MD_CTX_get_pkey_ctx, EVP_MD_CTX_set_pkey_ctx,
+EVP_MD_do_all_provided,
+EVP_MD_type, EVP_MD_nid, EVP_MD_name, EVP_MD_pkey_type, EVP_MD_size,
+EVP_MD_block_size, EVP_MD_flags, EVP_MD_CTX_size, EVP_MD_CTX_block_size,
+EVP_MD_CTX_type, EVP_MD_CTX_pkey_ctx, EVP_MD_CTX_md_data
 - EVP digest routines
 
 =head1 SYNOPSIS
@@ -68,27 +70,27 @@ EVP_MD_do_all_provided
 
  int EVP_MD_CTX_copy(EVP_MD_CTX *out, EVP_MD_CTX *in);
 
- const char *EVP_MD_name(const EVP_MD *md);
- const char *EVP_MD_description(const EVP_MD *md);
- int EVP_MD_number(const EVP_MD *md);
+ const char *EVP_MD_get0_name(const EVP_MD *md);
+ const char *EVP_MD_get0_description(const EVP_MD *md);
+ int EVP_MD_get_number(const EVP_MD *md);
  int EVP_MD_is_a(const EVP_MD *md, const char *name);
  int EVP_MD_names_do_all(const EVP_MD *md,
                          void (*fn)(const char *name, void *data),
                          void *data);
- const OSSL_PROVIDER *EVP_MD_provider(const EVP_MD *md);
- int EVP_MD_type(const EVP_MD *md);
- int EVP_MD_pkey_type(const EVP_MD *md);
- int EVP_MD_size(const EVP_MD *md);
- int EVP_MD_block_size(const EVP_MD *md);
- unsigned long EVP_MD_flags(const EVP_MD *md);
+ const OSSL_PROVIDER *EVP_MD_get0_provider(const EVP_MD *md);
+ int EVP_MD_get_type(const EVP_MD *md);
+ int EVP_MD_get_pkey_type(const EVP_MD *md);
+ int EVP_MD_get_size(const EVP_MD *md);
+ int EVP_MD_get_block_size(const EVP_MD *md);
+ unsigned long EVP_MD_get_flags(const EVP_MD *md);
 
  const EVP_MD *EVP_MD_CTX_get0_md(const EVP_MD_CTX *ctx);
  EVP_MD *EVP_MD_CTX_get1_md(EVP_MD_CTX *ctx);
- const char *EVP_MD_CTX_name(const EVP_MD_CTX *ctx);
- int EVP_MD_CTX_size(const EVP_MD_CTX *ctx);
- int EVP_MD_CTX_block_size(const EVP_MD_CTX *ctx);
- int EVP_MD_CTX_type(const EVP_MD_CTX *ctx);
- void *EVP_MD_CTX_md_data(const EVP_MD_CTX *ctx);
+ const char *EVP_MD_CTX_get0_name(const EVP_MD_CTX *ctx);
+ int EVP_MD_CTX_get_size(const EVP_MD_CTX *ctx);
+ int EVP_MD_CTX_get_block_size(const EVP_MD_CTX *ctx);
+ int EVP_MD_CTX_get_type(const EVP_MD_CTX *ctx);
+ void *EVP_MD_CTX_get0_md_data(const EVP_MD_CTX *ctx);
 
  const EVP_MD *EVP_md_null(void);
 
@@ -96,13 +98,26 @@ EVP_MD_do_all_provided
  const EVP_MD *EVP_get_digestbynid(int type);
  const EVP_MD *EVP_get_digestbyobj(const ASN1_OBJECT *o);
 
- EVP_PKEY_CTX *EVP_MD_CTX_pkey_ctx(const EVP_MD_CTX *ctx);
+ EVP_PKEY_CTX *EVP_MD_CTX_get_pkey_ctx(const EVP_MD_CTX *ctx);
  void EVP_MD_CTX_set_pkey_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pctx);
 
  void EVP_MD_do_all_provided(OSSL_LIB_CTX *libctx,
                              void (*fn)(EVP_MD *mac, void *arg),
                              void *arg);
 
+ #define EVP_MD_type EVP_MD_get_type
+ #define EVP_MD_nid EVP_MD_get_type
+ #define EVP_MD_name EVP_MD_get0_name
+ #define EVP_MD_pkey_type EVP_MD_get_pkey_type
+ #define EVP_MD_size EVP_MD_get_size
+ #define EVP_MD_block_size EVP_MD_get_block_size
+ #define EVP_MD_flags EVP_MD_get_flags
+ #define EVP_MD_CTX_size EVP_MD_CTX_get_size
+ #define EVP_MD_CTX_block_size EVP_MD_CTX_get_block_size
+ #define EVP_MD_CTX_type EVP_MD_CTX_get_type
+ #define EVP_MD_CTX_pkey_ctx EVP_MD_CTX_get_pkey_ctx
+ #define EVP_MD_CTX_md_data EVP_MD_CTX_get0_md_data
+
 Deprecated since OpenSSL 3.0, can be hidden entirely by defining
 B&lt;OPENSSL_API_COMPAT&gt; with a suitable version value, see
 L&lt;openssl_user_macros(7)&gt;:
@@ -312,13 +327,13 @@ EVP_sha256() rather than the result of an EVP_MD_fetch()), only cipher
 names registered with the default library context (see
 L&lt;OSSL_LIB_CTX(3)&gt;) will be considered.
 
-=item EVP_MD_number()
+=item EVP_MD_get_number()
 
 Returns the internal dynamic number assigned to the I&lt;md&gt;.  This is
 only useful with fetched B&lt;EVP_MD&gt;s.
 
-=item EVP_MD_name(),
-EVP_MD_CTX_name()
+=item EVP_MD_get0_name(),
+EVP_MD_CTX_get0_name()
 
 Return the name of the given message digest.  For fetched message
 digests with multiple names, only one of them is returned; it's
@@ -329,36 +344,36 @@ recommended to use EVP_MD_names_do_all() instead.
 Traverses all names for the I&lt;md&gt;, and calls I&lt;fn&gt; with each name and
 I&lt;data&gt;.  This is only useful with fetched B&lt;EVP_MD&gt;s.
 
-=item EVP_MD_description()
+=item EVP_MD_get0_description()
 
 Returns a description of the digest, meant for display and human consumption.
 The description is at the discretion of the digest implementation.
 
-=item EVP_MD_provider()
+=item EVP_MD_get0_provider()
 
 Returns an B&lt;OSSL_PROVIDER&gt; pointer to the provider that implements the given
 B&lt;EVP_MD&gt;.
 
-=item EVP_MD_size(),
-EVP_MD_CTX_size()
+=item EVP_MD_get_size(),
+EVP_MD_CTX_get_size()
 
 Return the size of the message digest when passed an B&lt;EVP_MD&gt; or an
 B&lt;EVP_MD_CTX&gt; structure, i.e. the size of the hash.
 
-=item EVP_MD_block_size(),
-EVP_MD_CTX_block_size()
+=item EVP_MD_get_block_size(),
+EVP_MD_CTX_get_block_size()
 
 Return the block size of the message digest when passed an B&lt;EVP_MD&gt; or an
 B&lt;EVP_MD_CTX&gt; structure.
 
-=item EVP_MD_type(),
-EVP_MD_CTX_type()
+=item EVP_MD_get_type(),
+EVP_MD_CTX_get_type()
 
 Return the NID of the OBJECT IDENTIFIER representing the given message digest
-when passed an B&lt;EVP_MD&gt; structure.  For example, C&lt;EVP_MD_type(EVP_sha1())&gt;
+when passed an B&lt;EVP_MD&gt; structure.  For example, C&lt;EVP_MD_get_type(EVP_sha1())&gt;
 returns B&lt;NID_sha1&gt;. This function is normally used when setting ASN1 OIDs.
 
-=item EVP_MD_CTX_md_data()
+=item EVP_MD_CTX_get0_md_data()
 
 Return the digest method private data for the passed B&lt;EVP_MD_CTX&gt;.
 The space is allocated by OpenSSL and has the size originally set with
@@ -386,12 +401,12 @@ update function from the B&lt;EVP_MD&gt; type specified at initialization is used.
 
 Returns the update function for I&lt;ctx&gt;.
 
-=item EVP_MD_flags()
+=item EVP_MD_get_flags()
 
 Returns the I&lt;md&gt; flags. Note that these are different from the B&lt;EVP_MD_CTX&gt;
 ones. See L&lt;EVP_MD_meth_set_flags(3)&gt; for more information.
 
-=item EVP_MD_pkey_type()
+=item EVP_MD_get_pkey_type()
 
 Returns the NID of the public key signing algorithm associated with this
 digest. For example EVP_sha1() is associated with RSA so this will return
@@ -410,7 +425,7 @@ EVP_get_digestbyobj()
 Returns an B&lt;EVP_MD&gt; structure when passed a digest name, a digest B&lt;NID&gt; or an
 B&lt;ASN1_OBJECT&gt; structure respectively.
 
-=item EVP_MD_CTX_pkey_ctx()
+=item EVP_MD_CTX_get_pkey_ctx()
 
 Returns the B&lt;EVP_PKEY_CTX&gt; assigned to I&lt;ctx&gt;. The returned pointer should not
 be freed by the caller.
@@ -568,16 +583,16 @@ to get.
 
 Returns 1 if successful or 0 for failure.
 
-=item EVP_MD_type(),
-EVP_MD_pkey_type()
+=item EVP_MD_get_type(),
+EVP_MD_get_pkey_type()
 
 Returns the NID of the corresponding OBJECT IDENTIFIER or NID_undef if none
 exists.
 
-=item EVP_MD_size(),
-EVP_MD_block_size(),
-EVP_MD_CTX_size(),
-EVP_MD_CTX_block_size()
+=item EVP_MD_get_size(),
+EVP_MD_get_block_size(),
+EVP_MD_CTX_get_size(),
+EVP_MD_CTX_get_block_size()
 
 Returns the digest or block size in bytes.
 
@@ -625,9 +640,9 @@ implementations of digests to be specified.
 If digest contexts are not cleaned up after use,
 memory leaks will occur.
 
-EVP_MD_CTX_name(), EVP_MD_CTX_size(), EVP_MD_CTX_block_size(),
-EVP_MD_CTX_type(), EVP_get_digestbynid() and EVP_get_digestbyobj() are defined
-as macros.
+EVP_MD_CTX_get0_name(), EVP_MD_CTX_get_size(), EVP_MD_CTX_get_block_size(),
+EVP_MD_CTX_get_type(), EVP_get_digestbynid() and EVP_get_digestbyobj() are
+defined as macros.
 
 EVP_MD_CTX_ctrl() sends commands to message digests for additional configuration
 or control.
@@ -718,6 +733,13 @@ EVP_MD_gettable_params(), EVP_MD_gettable_ctx_params(),
 EVP_MD_settable_ctx_params(), EVP_MD_CTX_settable_params() and
 EVP_MD_CTX_gettable_params() functions were added in OpenSSL 3.0.
 
+The EVP_MD_type(), EVP_MD_nid(), EVP_MD_name(), EVP_MD_pkey_type(),
+EVP_MD_size(), EVP_MD_block_size(), EVP_MD_flags(), EVP_MD_CTX_size(),
+EVP_MD_CTX_block_size(), EVP_MD_CTX_type(), and EVP_MD_CTX_md_data()
+functions were renamed to include C&lt;get&gt; or C&lt;get0&gt; in their names in
+OpenSSL 3.0, respectively. The old names are kept as non-deprecated
+alias macros.
+
 The EVP_MD_CTX_md() function was deprecated in OpenSSL 3.0; use
 EVP_MD_CTX_get0_md() instead.
 EVP_MD_CTX_update_fn() and EVP_MD_CTX_set_update_fn() were deprecated
diff --git a/doc/man3/EVP_DigestSignInit.pod b/doc/man3/EVP_DigestSignInit.pod
index a24db53949..86d4270ed4 100644
--- a/doc/man3/EVP_DigestSignInit.pod
+++ b/doc/man3/EVP_DigestSignInit.pod
@@ -165,9 +165,9 @@ Since only a copy of the digest context is ever finalized, the context must
 be cleaned up after use by calling EVP_MD_CTX_free() or a memory leak
 will occur.
 
-The use of EVP_PKEY_size() with these functions is discouraged because some
+The use of EVP_PKEY_get_size() with these functions is discouraged because some
 signature operations may have a signature length which depends on the
-parameters set. As a result EVP_PKEY_size() would have to return a value
+parameters set. As a result EVP_PKEY_get_size() would have to return a value
 which indicates the maximum possible signature for any set of parameters.
 
 =head1 SEE ALSO
diff --git a/doc/man3/EVP_EncryptInit.pod b/doc/man3/EVP_EncryptInit.pod
index 0fc7b1e82c..cd4b8b5c56 100644
--- a/doc/man3/EVP_EncryptInit.pod
+++ b/doc/man3/EVP_EncryptInit.pod
@@ -33,48 +33,68 @@ EVP_get_cipherbyname,
 EVP_get_cipherbynid,
 EVP_get_cipherbyobj,
 EVP_CIPHER_is_a,
-EVP_CIPHER_name,
-EVP_CIPHER_description,
-EVP_CIPHER_number,
+EVP_CIPHER_get0_name,
+EVP_CIPHER_get0_description,
+EVP_CIPHER_get_number,
 EVP_CIPHER_names_do_all,
-EVP_CIPHER_provider,
-EVP_CIPHER_nid,
+EVP_CIPHER_get0_provider,
+EVP_CIPHER_get_nid,
 EVP_CIPHER_get_params,
 EVP_CIPHER_gettable_params,
-EVP_CIPHER_block_size,
-EVP_CIPHER_key_length,
-EVP_CIPHER_iv_length,
-EVP_CIPHER_flags,
-EVP_CIPHER_mode,
-EVP_CIPHER_type,
+EVP_CIPHER_get_block_size,
+EVP_CIPHER_get_key_length,
+EVP_CIPHER_get_iv_length,
+EVP_CIPHER_get_flags,
+EVP_CIPHER_get_mode,
+EVP_CIPHER_get_type,
 EVP_CIPHER_CTX_cipher,
 EVP_CIPHER_CTX_get0_cipher,
 EVP_CIPHER_CTX_get1_cipher,
-EVP_CIPHER_CTX_name,
-EVP_CIPHER_CTX_nid,
+EVP_CIPHER_CTX_get0_name,
+EVP_CIPHER_CTX_get_nid,
 EVP_CIPHER_CTX_get_params,
 EVP_CIPHER_gettable_ctx_params,
 EVP_CIPHER_CTX_gettable_params,
 EVP_CIPHER_CTX_set_params,
 EVP_CIPHER_settable_ctx_params,
 EVP_CIPHER_CTX_settable_params,
-EVP_CIPHER_CTX_block_size,
-EVP_CIPHER_CTX_key_length,
-EVP_CIPHER_CTX_iv_length,
-EVP_CIPHER_CTX_tag_length,
+EVP_CIPHER_CTX_get_block_size,
+EVP_CIPHER_CTX_get_key_length,
+EVP_CIPHER_CTX_get_iv_length,
+EVP_CIPHER_CTX_get_tag_length,
 EVP_CIPHER_CTX_get_app_data,
 EVP_CIPHER_CTX_set_app_data,
-EVP_CIPHER_CTX_type,
 EVP_CIPHER_CTX_flags,
 EVP_CIPHER_CTX_set_flags,
 EVP_CIPHER_CTX_clear_flags,
 EVP_CIPHER_CTX_test_flags,
-EVP_CIPHER_CTX_mode,
+EVP_CIPHER_CTX_get_type,
+EVP_CIPHER_CTX_get_mode,
+EVP_CIPHER_CTX_get_num,
+EVP_CIPHER_CTX_set_num,
+EVP_CIPHER_CTX_is_encrypting,
 EVP_CIPHER_param_to_asn1,
 EVP_CIPHER_asn1_to_param,
 EVP_CIPHER_CTX_set_padding,
 EVP_enc_null,
-EVP_CIPHER_do_all_provided
+EVP_CIPHER_do_all_provided,
+EVP_CIPHER_nid,
+EVP_CIPHER_name,
+EVP_CIPHER_block_size,
+EVP_CIPHER_key_length,
+EVP_CIPHER_iv_length,
+EVP_CIPHER_flags,
+EVP_CIPHER_mode,
+EVP_CIPHER_type,
+EVP_CIPHER_CTX_encrypting,
+EVP_CIPHER_CTX_nid,
+EVP_CIPHER_CTX_block_size,
+EVP_CIPHER_CTX_key_length,
+EVP_CIPHER_CTX_iv_length,
+EVP_CIPHER_CTX_tag_length,
+EVP_CIPHER_CTX_num,
+EVP_CIPHER_CTX_type,
+EVP_CIPHER_CTX_mode
 - EVP cipher routines
 
 =head1 SYNOPSIS
@@ -145,26 +165,26 @@ EVP_CIPHER_do_all_provided
  const EVP_CIPHER *EVP_get_cipherbynid(int nid);
  const EVP_CIPHER *EVP_get_cipherbyobj(const ASN1_OBJECT *a);
 
- int EVP_CIPHER_nid(const EVP_CIPHER *e);
- int EVP_CIPHER_number(const EVP_CIPHER *e);
+ int EVP_CIPHER_get_nid(const EVP_CIPHER *e);
+ int EVP_CIPHER_get_number(const EVP_CIPHER *e);
  int EVP_CIPHER_is_a(const EVP_CIPHER *cipher, const char *name);
  int EVP_CIPHER_names_do_all(const EVP_CIPHER *cipher,
                              void (*fn)(const char *name, void *data),
                              void *data);
- const char *EVP_CIPHER_name(const EVP_CIPHER *cipher);
- const char *EVP_CIPHER_description(const EVP_CIPHER *cipher);
- const OSSL_PROVIDER *EVP_CIPHER_provider(const EVP_CIPHER *cipher);
- int EVP_CIPHER_block_size(const EVP_CIPHER *e);
- int EVP_CIPHER_key_length(const EVP_CIPHER *e);
- int EVP_CIPHER_iv_length(const EVP_CIPHER *e);
- unsigned long EVP_CIPHER_flags(const EVP_CIPHER *e);
- unsigned long EVP_CIPHER_mode(const EVP_CIPHER *e);
- int EVP_CIPHER_type(const EVP_CIPHER *cipher);
+ const char *EVP_CIPHER_get0_name(const EVP_CIPHER *cipher);
+ const char *EVP_CIPHER_get0_description(const EVP_CIPHER *cipher);
+ const OSSL_PROVIDER *EVP_CIPHER_get0_provider(const EVP_CIPHER *cipher);
+ int EVP_CIPHER_get_block_size(const EVP_CIPHER *e);
+ int EVP_CIPHER_get_key_length(const EVP_CIPHER *e);
+ int EVP_CIPHER_get_iv_length(const EVP_CIPHER *e);
+ unsigned long EVP_CIPHER_get_flags(const EVP_CIPHER *e);
+ unsigned long EVP_CIPHER_get_mode(const EVP_CIPHER *e);
+ int EVP_CIPHER_get_type(const EVP_CIPHER *cipher);
 
  const EVP_CIPHER *EVP_CIPHER_CTX_get0_cipher(const EVP_CIPHER_CTX *ctx);
  EVP_CIPHER *EVP_CIPHER_CTX_get1_cipher(const EVP_CIPHER_CTX *ctx);
- int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);
- const char *EVP_CIPHER_CTX_name(const EVP_CIPHER_CTX *ctx);
+ int EVP_CIPHER_CTX_get_nid(const EVP_CIPHER_CTX *ctx);
+ const char *EVP_CIPHER_CTX_get0_name(const EVP_CIPHER_CTX *ctx);
 
  int EVP_CIPHER_get_params(EVP_CIPHER *cipher, OSSL_PARAM params[]);
  int EVP_CIPHER_CTX_set_params(EVP_CIPHER_CTX *ctx, const OSSL_PARAM params[]);
@@ -174,14 +194,17 @@ EVP_CIPHER_do_all_provided
  const OSSL_PARAM *EVP_CIPHER_gettable_ctx_params(const EVP_CIPHER *cipher);
  const OSSL_PARAM *EVP_CIPHER_CTX_settable_params(EVP_CIPHER_CTX *ctx);
  const OSSL_PARAM *EVP_CIPHER_CTX_gettable_params(EVP_CIPHER_CTX *ctx);
- int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);
- int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);
- int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);
- int EVP_CIPHER_CTX_tag_length(const EVP_CIPHER_CTX *ctx);
+ int EVP_CIPHER_CTX_get_block_size(const EVP_CIPHER_CTX *ctx);
+ int EVP_CIPHER_CTX_get_key_length(const EVP_CIPHER_CTX *ctx);
+ int EVP_CIPHER_CTX_get_iv_length(const EVP_CIPHER_CTX *ctx);
+ int EVP_CIPHER_CTX_get_tag_length(const EVP_CIPHER_CTX *ctx);
  void *EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);
  void EVP_CIPHER_CTX_set_app_data(const EVP_CIPHER_CTX *ctx, void *data);
- int EVP_CIPHER_CTX_type(const EVP_CIPHER_CTX *ctx);
- int EVP_CIPHER_CTX_mode(const EVP_CIPHER_CTX *ctx);
+ int EVP_CIPHER_CTX_get_type(const EVP_CIPHER_CTX *ctx);
+ int EVP_CIPHER_CTX_get_mode(const EVP_CIPHER_CTX *ctx);
+ int EVP_CIPHER_CTX_get_num(const EVP_CIPHER_CTX *ctx);
+ int EVP_CIPHER_CTX_set_num(EVP_CIPHER_CTX *ctx, int num);
+ int EVP_CIPHER_CTX_is_encrypting(const EVP_CIPHER_CTX *ctx);
 
  int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
  int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
@@ -190,12 +213,36 @@ EVP_CIPHER_do_all_provided
                                  void (*fn)(EVP_CIPHER *cipher, void *arg),
                                  void *arg);
 
+ #define EVP_CIPHER_nid EVP_CIPHER_get_nid
+ #define EVP_CIPHER_name EVP_CIPHER_get0_name
+ #define EVP_CIPHER_block_size EVP_CIPHER_get_block_size
+ #define EVP_CIPHER_key_length EVP_CIPHER_get_key_length
+ #define EVP_CIPHER_iv_length EVP_CIPHER_get_iv_length
+ #define EVP_CIPHER_flags EVP_CIPHER_get_flags
+ #define EVP_CIPHER_mode EVP_CIPHER_get_mode
+ #define EVP_CIPHER_type EVP_CIPHER_get_type
+ #define EVP_CIPHER_CTX_encrypting EVP_CIPHER_CTX_is_encrypting
+ #define EVP_CIPHER_CTX_nid EVP_CIPHER_CTX_get_nid
+ #define EVP_CIPHER_CTX_block_size EVP_CIPHER_CTX_get_block_size
+ #define EVP_CIPHER_CTX_key_length EVP_CIPHER_CTX_get_key_length
+ #define EVP_CIPHER_CTX_iv_length EVP_CIPHER_CTX_get_iv_length
+ #define EVP_CIPHER_CTX_tag_length EVP_CIPHER_CTX_get_tag_length
+ #define EVP_CIPHER_CTX_num EVP_CIPHER_CTX_get_num
+ #define EVP_CIPHER_CTX_type EVP_CIPHER_CTX_get_type
+ #define EVP_CIPHER_CTX_mode EVP_CIPHER_CTX_get_mode
+
 Deprecated since OpenSSL 3.0, can be hidden entirely by defining
 B&lt;OPENSSL_API_COMPAT&gt; with a suitable version value, see
 L&lt;openssl_user_macros(7)&gt;:
 
  const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
 
+Deprecated since OpenSSL 1.1.0, can be hidden entirely by defining
+B&lt;OPENSSL_API_COMPAT&gt; with a suitable version value, see
+L&lt;openssl_user_macros(7)&gt;:
+
+ int EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx);
+
 =head1 DESCRIPTION
 
 The EVP cipher routines are a high-level interface to certain
@@ -390,7 +437,7 @@ result in I&lt;out&gt;.
 
 For legacy ciphers - If the cipher doesn't have the flag
 B&lt;EVP_CIPH_FLAG_CUSTOM_CIPHER&gt; set, then I&lt;inl&gt; must be a multiple of
-EVP_CIPHER_block_size().  If it isn't, the result is undefined.  If the cipher
+EVP_CIPHER_get_block_size().  If it isn't, the result is undefined.  If the cipher
 has that flag set, then I&lt;inl&gt; can be any size.
 
 Due to the constraints of the API contract of this function it shouldn't be used
@@ -402,7 +449,7 @@ EVP_CipherFinal_ex() instead.
 Return an EVP_CIPHER structure when passed a cipher name, a NID or an
 ASN1_OBJECT structure.
 
-=item EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid()
+=item EVP_CIPHER_get_nid() and EVP_CIPHER_CTX_get_nid()
 
 Return the NID of a cipher when passed an B&lt;EVP_CIPHER&gt; or B&lt;EVP_CIPHER_CTX&gt;
 structure.  The actual NID value is an internal value which may not have a
@@ -426,12 +473,12 @@ when decrypting. If the I&lt;pad&gt; parameter is zero then no padding is
 performed, the total amount of data encrypted or decrypted must then
 be a multiple of the block size or an error will occur.
 
-=item EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length()
+=item EVP_CIPHER_get_key_length() and EVP_CIPHER_CTX_get_key_length()
 
 Return the key length of a cipher when passed an B&lt;EVP_CIPHER&gt; or
 B&lt;EVP_CIPHER_CTX&gt; structure. The constant B&lt;EVP_MAX_KEY_LENGTH&gt; is the maximum
-key length for all ciphers. Note: although EVP_CIPHER_key_length() is fixed for
-a given cipher, the value of EVP_CIPHER_CTX_key_length() may be different for
+key length for all ciphers. Note: although EVP_CIPHER_get_key_length() is fixed for
+a given cipher, the value of EVP_CIPHER_CTX_get_key_length() may be different for
 variable key length ciphers.
 
 =item EVP_CIPHER_CTX_set_key_length()
@@ -440,25 +487,25 @@ Sets the key length of the cipher context.
 If the cipher is a fixed length cipher then attempting to set the key
 length to any value other than the fixed value is an error.
 
-=item EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length()
+=item EVP_CIPHER_get_iv_length() and EVP_CIPHER_CTX_get_iv_length()
 
 Return the IV length of a cipher when passed an B&lt;EVP_CIPHER&gt; or
 B&lt;EVP_CIPHER_CTX&gt;. It will return zero if the cipher does not use an IV.
 The constant B&lt;EVP_MAX_IV_LENGTH&gt; is the maximum IV length for all ciphers.
 
-=item EVP_CIPHER_CTX_tag_length()
+=item EVP_CIPHER_CTX_get_tag_length()
 
 Returns the tag length of an AEAD cipher when passed a B&lt;EVP_CIPHER_CTX&gt;. It will
 return zero if the cipher does not support a tag. It returns a default value if
 the tag length has not been set.
 
-=item EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size()
+=item EVP_CIPHER_get_block_size() and EVP_CIPHER_CTX_get_block_size()
 
 Return the block size of a cipher when passed an B&lt;EVP_CIPHER&gt; or
 B&lt;EVP_CIPHER_CTX&gt; structure. The constant B&lt;EVP_MAX_BLOCK_LENGTH&gt; is also the
 maximum block length for all ciphers.
 
-=item EVP_CIPHER_type() and EVP_CIPHER_CTX_type()
+=item EVP_CIPHER_get_type() and EVP_CIPHER_CTX_get_type()
 
 Return the type of the passed cipher or context. This &quot;type&quot; is the actual NID
 of the cipher OBJECT IDENTIFIER and as such it ignores the cipher parameters
@@ -474,12 +521,12 @@ value from the likes of EVP_aes128() rather than the result of an
 EVP_CIPHER_fetch()), only cipher names registered with the default library
 context (see L&lt;OSSL_LIB_CTX(3)&gt;) will be considered.
 
-=item EVP_CIPHER_number()
+=item EVP_CIPHER_get_number()
 
 Returns the internal dynamic number assigned to the I&lt;cipher&gt;.  This is only
 useful with fetched B&lt;EVP_CIPHER&gt;s.
 
-=item EVP_CIPHER_name() and EVP_CIPHER_CTX_name()
+=item EVP_CIPHER_get0_name() and EVP_CIPHER_CTX_get0_name()
 
 Return the name of the passed cipher or context.  For fetched ciphers with
 multiple names, only one of them is returned. See also EVP_CIPHER_names_do_all().
@@ -489,12 +536,12 @@ multiple names, only one of them is returned. See also EVP_CIPHER_names_do_all()
 Traverses all names for the I&lt;cipher&gt;, and calls I&lt;fn&gt; with each name and
 I&lt;data&gt;.  This is only useful with fetched B&lt;EVP_CIPHER&gt;s.
 
-=item EVP_CIPHER_description()
+=item EVP_CIPHER_get0_description()
 
 Returns a description of the cipher, meant for display and human consumption.
 The description is at the discretion of the cipher implementation.
 
-=item EVP_CIPHER_provider()
+=item EVP_CIPHER_get0_provider()
 
 Returns an B&lt;OSSL_PROVIDER&gt; pointer to the provider that implements the given
 B&lt;EVP_CIPHER&gt;.
@@ -505,7 +552,7 @@ Returns the B&lt;EVP_CIPHER&gt; structure when passed an B&lt;EVP_CIPHER_CTX&gt; structure.
 EVP_CIPHER_CTX_get1_cipher() is the same except the ownership is passed to
 the caller.
 
-=item EVP_CIPHER_mode() and EVP_CIPHER_CTX_mode()
+=item EVP_CIPHER_get_mode() and EVP_CIPHER_CTX_get_mode()
 
 Return the block cipher mode:
 EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE, EVP_CIPH_OFB_MODE,
@@ -513,11 +560,26 @@ EVP_CIPH_CTR_MODE, EVP_CIPH_GCM_MODE, EVP_CIPH_CCM_MODE, EVP_CIPH_XTS_MODE,
 EVP_CIPH_WRAP_MODE, EVP_CIPH_OCB_MODE or EVP_CIPH_SIV_MODE.
 If the cipher is a stream cipher then EVP_CIPH_STREAM_CIPHER is returned.
 
-=item EVP_CIPHER_flags()
+=item EVP_CIPHER_get_flags()
 
 Returns any flags associated with the cipher. See L&lt;/FLAGS&gt;
 for a list of currently defined flags.
 
+=item EVP_CIPHER_CTX_get_num() and EVP_CIPHER_CTX_set_num()
+
+Gets or sets the cipher specific &quot;num&quot; parameter for the associated I&lt;ctx&gt;.
+Built-in ciphers typically use this to track how much of the current underlying block
+has been &quot;used&quot; already.
+
+=item EVP_CIPHER_CTX_is_encrypting()
+
+Reports whether the I&lt;ctx&gt; is being used for encryption or decryption.
+
+=item EVP_CIPHER_CTX_flags()
+
+A deprecated macro calling C&lt;EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ctx))&gt;.
+Do not use.
+
 =item EVP_CIPHER_param_to_asn1()
 
 Sets the AlgorithmIdentifier &quot;parameter&quot; based on the passed cipher. This will
@@ -544,7 +606,7 @@ is not supported.
 Generates a random key of the appropriate length based on the cipher context.
 The B&lt;EVP_CIPHER&gt; can provide its own random key generation routine to support
 keys of a specific form. I&lt;key&gt; must point to a buffer at least as big as the
-value returned by EVP_CIPHER_CTX_key_length().
+value returned by EVP_CIPHER_CTX_get_key_length().
 
 =item EVP_CIPHER_do_all_provided()
 
@@ -570,18 +632,18 @@ EVP_CIPHER_get_params() can be used with the following B&lt;OSSL_PARAM&gt; keys:
 =item &quot;mode&quot; (B&lt;OSSL_CIPHER_PARAM_MODE&gt;) &lt;unsigned integer&gt;
 
 Gets the mode for the associated cipher algorithm I&lt;cipher&gt;.
-See L&lt;/EVP_CIPHER_mode() and EVP_CIPHER_CTX_mode()&gt; for a list of valid modes.
-Use EVP_CIPHER_mode() to retrieve the cached value.
+See L&lt;/EVP_CIPHER_get_mode() and EVP_CIPHER_CTX_get_mode()&gt; for a list of valid modes.
+Use EVP_CIPHER_get_mode() to retrieve the cached value.
 
 =item &quot;keylen&quot; (B&lt;OSSL_CIPHER_PARAM_KEYLEN&gt;) &lt;unsigned integer&gt;
 
 Gets the key length for the associated cipher algorithm I&lt;cipher&gt;.
-Use EVP_CIPHER_key_length() to retrieve the cached value.
+Use EVP_CIPHER_get_key_length() to retrieve the cached value.
 
 =item &quot;ivlen&quot; (B&lt;OSSL_CIPHER_PARAM_IVLEN&gt;) &lt;unsigned integer&gt;
 
 Gets the IV length for the associated cipher algorithm I&lt;cipher&gt;.
-Use EVP_CIPHER_iv_length() to retrieve the cached value.
+Use EVP_CIPHER_get_iv_length() to retrieve the cached value.
 
 =item &quot;blocksize&quot; (B&lt;OSSL_CIPHER_PARAM_BLOCK_SIZE&gt;) &lt;unsigned integer&gt;
 
@@ -591,12 +653,12 @@ Note that the block size for a cipher may be different to the block size for
 the underlying encryption/decryption primitive.
 For example AES in CTR mode has a block size of 1 (because it operates like a
 stream cipher), even though AES has a block size of 16.
-Use EVP_CIPHER_block_size() to retreive the cached value.
+Use EVP_CIPHER_get_block_size() to retreive the cached value.
 
 =item &quot;aead&quot; (B&lt;OSSL_CIPHER_PARAM_AEAD&gt;) &lt;integer&gt;
 
 Gets 1 if this is an AEAD cipher algorithm, otherwise it gets 0.
-Use (EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) to retrieve the
+Use (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) to retrieve the
 cached value.
 
 =item &quot;custom-iv&quot; (B&lt;OSSL_CIPHER_PARAM_CUSTOM_IV&gt;) &lt;integer&gt;
@@ -604,7 +666,7 @@ cached value.
 Gets 1 if the cipher algorithm I&lt;cipher&gt; has a custom IV, otherwise it gets 0.
 Storing and initializing the IV is left entirely to the implementation, if a
 custom IV is used.
-Use (EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_CUSTOM_IV) to retrieve the
+Use (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_CUSTOM_IV) to retrieve the
 cached value.
 
 =item &quot;cts&quot; (B&lt;OSSL_CIPHER_PARAM_CTS&gt;) &lt;integer&gt;
@@ -613,7 +675,7 @@ Gets 1 if the cipher algorithm I&lt;cipher&gt; uses ciphertext stealing,
 otherwise it gets 0.
 This is currently used to indicate that the cipher is a one shot that only
 allows a single call to EVP_CipherUpdate().
-Use (EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_CTS) to retrieve the
+Use (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_CTS) to retrieve the
 cached value.
 
 =item &quot;tls-multi&quot; (B&lt;OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK&gt;) &lt;integer&gt;
@@ -621,7 +683,7 @@ cached value.
 Gets 1 if the cipher algorithm I&lt;cipher&gt; supports interleaving of crypto blocks,
 otherwise it gets 0. The interleaving is an optimization only applicable to certain
 TLS ciphers.
-Use (EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) to retrieve the
+Use (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) to retrieve the
 cached value.
 
 =back
@@ -644,13 +706,13 @@ See also EVP_CIPHER_CTX_set_padding().
 Gets or sets the cipher specific &quot;num&quot; parameter for the cipher context I&lt;ctx&gt;.
 Built-in ciphers typically use this to track how much of the current underlying
 block has been &quot;used&quot; already.
-See also EVP_CIPHER_CTX_num() and EVP_CIPHER_CTX_set_num().
+See also EVP_CIPHER_CTX_get_num() and EVP_CIPHER_CTX_set_num().
 
 =item &quot;keylen&quot; (B&lt;OSSL_CIPHER_PARAM_KEYLEN&gt;) &lt;unsigned integer&gt;
 
 Gets or sets the key length for the cipher context I&lt;ctx&gt;.
 The length of the &quot;keylen&quot; parameter should not exceed that of a B&lt;size_t&gt;.
-See also EVP_CIPHER_CTX_key_length() and EVP_CIPHER_CTX_set_key_length().
+See also EVP_CIPHER_CTX_get_key_length() and EVP_CIPHER_CTX_set_key_length().
 
 =item &quot;tag&quot; (B&lt;OSSL_CIPHER_PARAM_AEAD_TAG&gt;) &lt;octet string&gt;
 
@@ -723,7 +785,7 @@ The following B&lt;OSSL_PARAM&gt; keys can be used with EVP_CIPHER_CTX_get_params():
 
 Gets the IV length for the cipher context I&lt;ctx&gt;.
 The length of the &quot;ivlen&quot; parameter should not exceed that of a B&lt;size_t&gt;.
-See also EVP_CIPHER_CTX_iv_length().
+See also EVP_CIPHER_CTX_get_iv_length().
 
 =item &quot;iv&quot; (B&lt;OSSL_CIPHER_PARAM_IV&gt;) &lt;octet string OR octet ptr&gt;
 
@@ -749,7 +811,7 @@ the key to odd parity).
 Gets the tag length to be used for an AEAD cipher for the associated cipher
 context I&lt;ctx&gt;. It gets a default value if it has not been set.
 The length of the &quot;taglen&quot; parameter should not exceed that of a B&lt;size_t&gt;.
-See also EVP_CIPHER_CTX_tag_length().
+See also EVP_CIPHER_CTX_get_tag_length().
 
 =item &quot;tlsaadpad&quot; (B&lt;OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD&gt;) &lt;unsigned integer&gt;
 
@@ -1116,27 +1178,38 @@ EVP_CIPHER_CTX_reset() returns 1 for success and 0 for failure.
 EVP_get_cipherbyname(), EVP_get_cipherbynid() and EVP_get_cipherbyobj()
 return an B&lt;EVP_CIPHER&gt; structure or NULL on error.
 
-EVP_CIPHER_nid() and EVP_CIPHER_CTX_nid() return a NID.
+EVP_CIPHER_get_nid() and EVP_CIPHER_CTX_get_nid() return a NID.
 
-EVP_CIPHER_block_size() and EVP_CIPHER_CTX_block_size() return the block
-size.
+EVP_CIPHER_get_block_size() and EVP_CIPHER_CTX_get_block_size() return the
+block size.
 
-EVP_CIPHER_key_length() and EVP_CIPHER_CTX_key_length() return the key
+EVP_CIPHER_get_key_length() and EVP_CIPHER_CTX_get_key_length() return the key
 length.
 
 EVP_CIPHER_CTX_set_padding() always returns 1.
 
-EVP_CIPHER_iv_length() and EVP_CIPHER_CTX_iv_length() return the IV
+EVP_CIPHER_get_iv_length() and EVP_CIPHER_CTX_get_iv_length() return the IV
 length or zero if the cipher does not use an IV.
 
-EVP_CIPHER_CTX_tag_length() return the tag length or zero if the cipher does not
-use a tag.
+EVP_CIPHER_CTX_get_tag_length() return the tag length or zero if the cipher
+does not use a tag.
 
-EVP_CIPHER_type() and EVP_CIPHER_CTX_type() return the NID of the cipher's
-OBJECT IDENTIFIER or NID_undef if it has no defined OBJECT IDENTIFIER.
+EVP_CIPHER_get_type() and EVP_CIPHER_CTX_get_type() return the NID of the
+cipher's OBJECT IDENTIFIER or NID_undef if it has no defined
+OBJECT IDENTIFIER.
 
 EVP_CIPHER_CTX_cipher() returns an B&lt;EVP_CIPHER&gt; structure.
 
+EVP_CIPHER_CTX_get_num() returns a nonnegative num value or
+B&lt;EVP_CTRL_RET_UNSUPPORTED&gt; if the implementation does not support the call
+or on any other error.
+
+EVP_CIPHER_CTX_set_num() returns 1 on success and 0 if the implementation
+does not support the call or on any other error.
+
+EVP_CIPHER_CTX_is_encrypting() returns 1 if the I&lt;ctx&gt; is set up for encryption
+0 otherwise.
+
 EVP_CIPHER_param_to_asn1() and EVP_CIPHER_asn1_to_param() return greater
 than zero for success and zero or a negative number on failure.
 
@@ -1463,8 +1536,8 @@ with a 128-bit key:
      ctx = EVP_CIPHER_CTX_new();
      EVP_CipherInit_ex2(ctx, EVP_aes_128_cbc(), NULL, NULL,
                         do_encrypt, NULL);
-     OPENSSL_assert(EVP_CIPHER_CTX_key_length(ctx) == 16);
-     OPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) == 16);
+     OPENSSL_assert(EVP_CIPHER_CTX_get_key_length(ctx) == 16);
+     OPENSSL_assert(EVP_CIPHER_CTX_get_iv_length(ctx) == 16);
 
      /* Now we can set key and IV */
      EVP_CipherInit_ex2(ctx, NULL, key, iv, do_encrypt, NULL);
@@ -1577,6 +1650,22 @@ EVP_CIPHER_settable_ctx_params(), EVP_CIPHER_gettable_ctx_params(),
 EVP_CIPHER_CTX_settable_params() and EVP_CIPHER_CTX_gettable_params()
 functions were added in 3.0.
 
+The EVP_CIPHER_nid(), EVP_CIPHER_name(), EVP_CIPHER_block_size(),
+EVP_CIPHER_key_length(), EVP_CIPHER_iv_length(), EVP_CIPHER_flags(),
+EVP_CIPHER_mode(), EVP_CIPHER_type(), EVP_CIPHER_CTX_nid(),
+EVP_CIPHER_CTX_block_size(), EVP_CIPHER_CTX_key_length(),
+EVP_CIPHER_CTX_iv_length(), EVP_CIPHER_CTX_tag_length(),
+EVP_CIPHER_CTX_num(), EVP_CIPHER_CTX_type(), and EVP_CIPHER_CTX_mode()
+functions were renamed to include C&lt;get&gt; or C&lt;get0&gt; in their names in
+OpenSSL 3.0, respectively. The old names are kept as non-deprecated
+alias macros.
+
+The EVP_CIPHER_CTX_encrypting() function was renamed to
+EVP_CIPHER_CTX_is_encrypting() in OpenSSL 3.0. The old name is kept as
+non-deprecated alias macro.
+
+The EVP_CIPHER_CTX_flags() macro was deprecated in OpenSSL 1.1.0.
+
 =head1 COPYRIGHT
 
 Copyright 2000-2021 The OpenSSL Project Authors. All Rights Reserved.
diff --git a/doc/man3/EVP_KDF.pod b/doc/man3/EVP_KDF.pod
index 08b15f08ab..2fd6651c2b 100644
--- a/doc/man3/EVP_KDF.pod
+++ b/doc/man3/EVP_KDF.pod
@@ -5,8 +5,9 @@
 EVP_KDF, EVP_KDF_fetch, EVP_KDF_free, EVP_KDF_up_ref,
 EVP_KDF_CTX, EVP_KDF_CTX_new, EVP_KDF_CTX_free, EVP_KDF_CTX_dup,
 EVP_KDF_CTX_reset, EVP_KDF_derive,
-EVP_KDF_CTX_get_kdf_size, EVP_KDF_provider, EVP_KDF_CTX_kdf, EVP_KDF_is_a,
-EVP_KDF_number, EVP_KDF_name, EVP_KDF_names_do_all, EVP_KDF_description,
+EVP_KDF_CTX_get_kdf_size,
+EVP_KDF_get0_provider, EVP_KDF_CTX_kdf, EVP_KDF_is_a, EVP_KDF_get_number,
+EVP_KDF_get0_name, EVP_KDF_names_do_all, EVP_KDF_get0_description,
 EVP_KDF_CTX_get_params, EVP_KDF_CTX_set_params, EVP_KDF_do_all_provided,
 EVP_KDF_get_params, EVP_KDF_gettable_params,
 EVP_KDF_gettable_ctx_params, EVP_KDF_settable_ctx_params,
@@ -31,11 +32,11 @@ EVP_KDF_CTX_gettable_params, EVP_KDF_CTX_settable_params - EVP KDF routines
  void EVP_KDF_free(EVP_KDF *kdf);
  EVP_KDF *EVP_KDF_fetch(OSSL_LIB_CTX *libctx, const char *algorithm,
                         const char *properties);
- int EVP_KDF_number(const EVP_KDF *kdf);
+ int EVP_KDF_get_number(const EVP_KDF *kdf);
  int EVP_KDF_is_a(const EVP_KDF *kdf, const char *name);
- const char *EVP_KDF_name(const EVP_KDF *kdf);
- const char *EVP_KDF_description(const EVP_KDF *kdf);
- const OSSL_PROVIDER *EVP_KDF_provider(const EVP_KDF *kdf);
+ const char *EVP_KDF_get0_name(const EVP_KDF *kdf);
+ const char *EVP_KDF_get0_description(const EVP_KDF *kdf);
+ const OSSL_PROVIDER *EVP_KDF_get0_provider(const EVP_KDF *kdf);
  void EVP_KDF_do_all_provided(OSSL_LIB_CTX *libctx,
                               void (*fn)(EVP_KDF *kdf, void *arg),
                               void *arg);
@@ -50,7 +51,7 @@ EVP_KDF_CTX_gettable_params, EVP_KDF_CTX_settable_params - EVP KDF routines
  const OSSL_PARAM *EVP_KDF_settable_ctx_params(const EVP_KDF *kdf);
  const OSSL_PARAM *EVP_KDF_CTX_gettable_params(const EVP_KDF *kdf);
  const OSSL_PARAM *EVP_KDF_CTX_settable_params(const EVP_KDF *kdf);
- const OSSL_PROVIDER *EVP_KDF_provider(const EVP_KDF *kdf);
+ const OSSL_PROVIDER *EVP_KDF_get0_provider(const EVP_KDF *kdf);
 
 =head1 DESCRIPTION
 
@@ -162,7 +163,7 @@ calculate a fixed output size have not yet been supplied.
 EVP_KDF_is_a() returns 1 if I&lt;kdf&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;, otherwise 0.
 
-EVP_KDF_provider() returns the provider that holds the implementation
+EVP_KDF_get0_provider() returns the provider that holds the implementation
 of the given I&lt;kdf&gt;.
 
 EVP_KDF_do_all_provided() traverses all KDF implemented by all activated
@@ -170,19 +171,19 @@ providers in the given library context I&lt;libctx&gt;, and for each of the
 implementations, calls the given function I&lt;fn&gt; with the implementation method
 and the given I&lt;arg&gt; as argument.
 
-EVP_KDF_number() returns the internal dynamic number assigned to
+EVP_KDF_get_number() returns the internal dynamic number assigned to
 I&lt;kdf&gt;.
 
-EVP_KDF_name() return the name of the given KDF.  For fetched KDFs
+EVP_KDF_get0_name() return the name of the given KDF.  For fetched KDFs
 with multiple names, only one of them is returned; it's
 recommended to use EVP_KDF_names_do_all() instead.
 
 EVP_KDF_names_do_all() traverses all names for I&lt;kdf&gt;, and calls
 I&lt;fn&gt; with each name and I&lt;data&gt;.
 
-EVP_KDF_description() returns a description of the I&lt;kdf&gt;, meant for display
-and human consumption.  The description is at the discretion of the I&lt;kdf&gt;
-implementation.
+EVP_KDF_get0_description() returns a description of the I&lt;kdf&gt;, meant for
+display and human consumption.  The description is at the discretion of
+the I&lt;kdf&gt; implementation.
 
 =head1 PARAMETERS
 
@@ -262,7 +263,7 @@ The memory size must never exceed what can be given with a B&lt;size_t&gt;.
 EVP_KDF_fetch() returns a pointer to a newly fetched B&lt;EVP_KDF&gt;, or
 NULL if allocation failed.
 
-EVP_KDF_provider() returns a pointer to the provider for the KDF, or
+EVP_KDF_get0_provider() returns a pointer to the provider for the KDF, or
 NULL on error.
 
 EVP_KDF_up_ref() returns 1 on success, 0 on error.
@@ -275,7 +276,7 @@ EVP_KDF_CTX_free() and EVP_KDF_CTX_reset() do not return a value.
 EVP_KDF_CTX_get_kdf_size() returns the output size.  B&lt;SIZE_MAX&gt; is returned to indicate
 that the algorithm produces a variable amount of output; 0 to indicate failure.
 
-EVP_KDF_name() returns the name of the KDF, or NULL on error.
+EVP_KDF_get0_name() returns the name of the KDF, or NULL on error.
 
 EVP_KDF_names_do_all() returns 1 if the callback was called for all names. A
 return value of 0 means that the callback was not called for any names.
diff --git a/doc/man3/EVP_KEM_free.pod b/doc/man3/EVP_KEM_free.pod
index 13600c521c..766825859b 100644
--- a/doc/man3/EVP_KEM_free.pod
+++ b/doc/man3/EVP_KEM_free.pod
@@ -3,8 +3,8 @@
 =head1 NAME
 
 EVP_KEM_fetch, EVP_KEM_free, EVP_KEM_up_ref,
-EVP_KEM_number, EVP_KEM_name, EVP_KEM_is_a, EVP_KEM_provider,
-EVP_KEM_do_all_provided, EVP_KEM_names_do_all, EVP_KEM_description,
+EVP_KEM_get_number, EVP_KEM_get0_name, EVP_KEM_is_a, EVP_KEM_get0_provider,
+EVP_KEM_do_all_provided, EVP_KEM_names_do_all, EVP_KEM_get0_description,
 EVP_KEM_gettable_ctx_params, EVP_KEM_settable_ctx_params
 - Functions to manage EVP_KEM algorithm objects
 
@@ -16,15 +16,15 @@ EVP_KEM_gettable_ctx_params, EVP_KEM_settable_ctx_params
                         const char *properties);
  void EVP_KEM_free(EVP_KEM *kem);
  int EVP_KEM_up_ref(EVP_KEM *kem);
- int EVP_KEM_number(const EVP_KEM *kem);
- const char *EVP_KEM_name(const EVP_KEM *kem);
+ int EVP_KEM_get_number(const EVP_KEM *kem);
+ const char *EVP_KEM_get0_name(const EVP_KEM *kem);
  int EVP_KEM_is_a(const EVP_KEM *kem, const char *name);
- OSSL_PROVIDER *EVP_KEM_provider(const EVP_KEM *kem);
+ OSSL_PROVIDER *EVP_KEM_get0_provider(const EVP_KEM *kem);
  void EVP_KEM_do_all_provided(OSSL_LIB_CTX *libctx,
                               void (*fn)(EVP_KEM *kem, void *arg), void *arg);
  int EVP_KEM_names_do_all(const EVP_KEM *kem,
                           void (*fn)(const char *name, void *data), void *data);
- const char *EVP_KEM_description(const EVP_KEM *kem);
+ const char *EVP_KEM_get0_description(const EVP_KEM *kem);
  const OSSL_PARAM *EVP_KEM_gettable_ctx_params(const EVP_KEM *kem);
  const OSSL_PARAM *EVP_KEM_settable_ctx_params(const EVP_KEM *kem);
 
@@ -48,16 +48,16 @@ EVP_KEM_up_ref() increments the reference count for an B&lt;EVP_KEM&gt; structure.
 EVP_KEM_is_a() returns 1 if I&lt;kem&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;, otherwise 0.
 
-EVP_KEM_provider() returns the provider that I&lt;kem&gt; was fetched from.
+EVP_KEM_get0_provider() returns the provider that I&lt;kem&gt; was fetched from.
 
 EVP_KEM_do_all_provided() traverses all EVP_KEMs implemented by all activated
 providers in the given library context I&lt;libctx&gt;, and for each of the
 implementations, calls the given function I&lt;fn&gt; with the implementation method
 and the given I&lt;arg&gt; as argument.
 
-EVP_KEM_number() returns the internal dynamic number assigned to I&lt;kem&gt;.
+EVP_KEM_get_number() returns the internal dynamic number assigned to I&lt;kem&gt;.
 
-EVP_KEM_name() returns the algorithm name from the provided
+EVP_KEM_get0_name() returns the algorithm name from the provided
 implementation for the given I&lt;kem&gt;. Note that the I&lt;kem&gt; may have
 multiple synonyms associated with it. In this case the first name from the
 algorithm definition is returned. Ownership of the returned string is retained
@@ -66,9 +66,9 @@ by the I&lt;kem&gt; object and should not be freed by the caller.
 EVP_KEM_names_do_all() traverses all names for I&lt;kem&gt;, and calls I&lt;fn&gt; with
 each name and I&lt;data&gt;.
 
-EVP_KEM_description() returns a description of the I&lt;kem&gt;, meant for display
-and human consumption.  The description is at the discretion of the I&lt;kem&gt;
-implementation.
+EVP_KEM_get0_description() returns a description of the I&lt;kem&gt;, meant for
+display and human consumption.  The description is at the discretion of
+the I&lt;kem&gt; implementation.
 
 EVP_KEM_gettable_ctx_params() and EVP_KEM_settable_ctx_params() return
 a constant B&lt;OSSL_PARAM&gt; array that describes the names and types of key
diff --git a/doc/man3/EVP_KEYEXCH_free.pod b/doc/man3/EVP_KEYEXCH_free.pod
index d0a0b6ef06..28eaf523f8 100644
--- a/doc/man3/EVP_KEYEXCH_free.pod
+++ b/doc/man3/EVP_KEYEXCH_free.pod
@@ -2,10 +2,10 @@
 
 =head1 NAME
 
-EVP_KEYEXCH_fetch, EVP_KEYEXCH_free, EVP_KEYEXCH_up_ref, EVP_KEYEXCH_provider,
-EVP_KEYEXCH_is_a, EVP_KEYEXCH_do_all_provided,
-EVP_KEYEXCH_number, EVP_KEYEXCH_names_do_all,
-EVP_KEYEXCH_name, EVP_KEYEXCH_description,
+EVP_KEYEXCH_fetch, EVP_KEYEXCH_free, EVP_KEYEXCH_up_ref,
+EVP_KEYEXCH_get0_provider, EVP_KEYEXCH_is_a, EVP_KEYEXCH_do_all_provided,
+EVP_KEYEXCH_get_number, EVP_KEYEXCH_names_do_all,
+EVP_KEYEXCH_get0_name, EVP_KEYEXCH_get0_description,
 EVP_KEYEXCH_gettable_ctx_params, EVP_KEYEXCH_settable_ctx_params
 - Functions to manage EVP_KEYEXCH algorithm objects
 
@@ -17,17 +17,17 @@ EVP_KEYEXCH_gettable_ctx_params, EVP_KEYEXCH_settable_ctx_params
                                 const char *properties);
  void EVP_KEYEXCH_free(EVP_KEYEXCH *exchange);
  int EVP_KEYEXCH_up_ref(EVP_KEYEXCH *exchange);
- OSSL_PROVIDER *EVP_KEYEXCH_provider(const EVP_KEYEXCH *exchange);
+ OSSL_PROVIDER *EVP_KEYEXCH_get0_provider(const EVP_KEYEXCH *exchange);
  int EVP_KEYEXCH_is_a(const EVP_KEYEXCH *exchange, const char *name);
- int EVP_KEYEXCH_number(const EVP_KEYEXCH *exchange);
- const char *EVP_KEYEXCH_name(const EVP_KEYEXCH *exchange);
+ int EVP_KEYEXCH_get_number(const EVP_KEYEXCH *exchange);
+ const char *EVP_KEYEXCH_get0_name(const EVP_KEYEXCH *exchange);
  void EVP_KEYEXCH_do_all_provided(OSSL_LIB_CTX *libctx,
                                   void (*fn)(EVP_KEYEXCH *exchange, void *arg),
                                   void *arg);
  int EVP_KEYEXCH_names_do_all(const EVP_KEYEXCH *exchange,
                               void (*fn)(const char *name, void *data),
                               void *data);
- const char *EVP_KEYEXCH_description(const EVP_KEYEXCH *keyexch);
+ const char *EVP_KEYEXCH_get0_description(const EVP_KEYEXCH *keyexch);
  const OSSL_PARAM *EVP_KEYEXCH_gettable_ctx_params(const EVP_KEYEXCH *keyexch);
  const OSSL_PARAM *EVP_KEYEXCH_settable_ctx_params(const EVP_KEYEXCH *keyexch);
 
@@ -48,15 +48,16 @@ structure is freed.
 EVP_KEYEXCH_up_ref() increments the reference count for an B&lt;EVP_KEYEXCH&gt;
 structure.
 
-EVP_KEYEXCH_provider() returns the provider that I&lt;exchange&gt; was fetched from.
+EVP_KEYEXCH_get0_provider() returns the provider that I&lt;exchange&gt; was
+fetched from.
 
 EVP_KEYEXCH_is_a() checks if I&lt;exchange&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;.
 
-EVP_KEYEXCH_number() returns the internal dynamic number assigned to
+EVP_KEYEXCH_get_number() returns the internal dynamic number assigned to
 the I&lt;exchange&gt;.
 
-EVP_KEYEXCH_name() returns the algorithm name from the provided
+EVP_KEYEXCH_get0_name() returns the algorithm name from the provided
 implementation for the given I&lt;exchange&gt;. Note that the I&lt;exchange&gt; may have
 multiple synonyms associated with it. In this case the first name from the
 algorithm definition is returned. Ownership of the returned string is retained
@@ -65,9 +66,9 @@ by the I&lt;exchange&gt; object and should not be freed by the caller.
 EVP_KEYEXCH_names_do_all() traverses all names for the I&lt;exchange&gt;, and
 calls I&lt;fn&gt; with each name and I&lt;data&gt;.
 
-EVP_KEYEXCH_description() returns a description of the I&lt;keyexch&gt;, meant for
-display and human consumption.  The description is at the discretion of the
-I&lt;keyexch&gt; implementation.
+EVP_KEYEXCH_get0_description() returns a description of the I&lt;keyexch&gt;, meant
+for display and human consumption.  The description is at the discretion of
+the I&lt;keyexch&gt; implementation.
 
 EVP_KEYEXCH_do_all_provided() traverses all key exchange implementations by
 all activated providers in the library context I&lt;libctx&gt;, and for each
@@ -92,7 +93,7 @@ names. A return value of 0 means that the callback was not called for any names.
 EVP_KEYEXCH_is_a() returns 1 of I&lt;exchange&gt; was identifiable,
 otherwise 0.
 
-EVP_KEYEXCH_number() returns an integer.
+EVP_KEYEXCH_get_number() returns an integer.
 
 EVP_KEYEXCH_gettable_ctx_params() and EVP_KEYEXCH_settable_ctx_params() return
 a constant B&lt;OSSL_PARAM&gt; array or NULL on error.
diff --git a/doc/man3/EVP_KEYMGMT.pod b/doc/man3/EVP_KEYMGMT.pod
index 9f143cd6ed..de5a9256a0 100644
--- a/doc/man3/EVP_KEYMGMT.pod
+++ b/doc/man3/EVP_KEYMGMT.pod
@@ -6,11 +6,11 @@ EVP_KEYMGMT,
 EVP_KEYMGMT_fetch,
 EVP_KEYMGMT_up_ref,
 EVP_KEYMGMT_free,
-EVP_KEYMGMT_provider,
+EVP_KEYMGMT_get0_provider,
 EVP_KEYMGMT_is_a,
-EVP_KEYMGMT_number,
-EVP_KEYMGMT_description,
-EVP_KEYMGMT_name,
+EVP_KEYMGMT_get_number,
+EVP_KEYMGMT_get0_description,
+EVP_KEYMGMT_get0_name,
 EVP_KEYMGMT_do_all_provided,
 EVP_KEYMGMT_names_do_all,
 EVP_KEYMGMT_gettable_params,
@@ -28,11 +28,11 @@ EVP_KEYMGMT_gen_settable_params
                                 const char *properties);
  int EVP_KEYMGMT_up_ref(EVP_KEYMGMT *keymgmt);
  void EVP_KEYMGMT_free(EVP_KEYMGMT *keymgmt);
- const OSSL_PROVIDER *EVP_KEYMGMT_provider(const EVP_KEYMGMT *keymgmt);
+ const OSSL_PROVIDER *EVP_KEYMGMT_get0_provider(const EVP_KEYMGMT *keymgmt);
  int EVP_KEYMGMT_is_a(const EVP_KEYMGMT *keymgmt, const char *name);
- int EVP_KEYMGMT_number(const EVP_KEYMGMT *keymgmt);
- const char *EVP_KEYMGMT_name(const EVP_KEYMGMT *keymgmt);
- const char *EVP_KEYMGMT_description(const EVP_KEYMGMT *keymgmt);
+ int EVP_KEYMGMT_get_number(const EVP_KEYMGMT *keymgmt);
+ const char *EVP_KEYMGMT_get0_name(const EVP_KEYMGMT *keymgmt);
+ const char *EVP_KEYMGMT_get0_description(const EVP_KEYMGMT *keymgmt);
 
  void EVP_KEYMGMT_do_all_provided(OSSL_LIB_CTX *libctx,
                                   void (*fn)(EVP_KEYMGMT *keymgmt, void *arg),
@@ -65,27 +65,27 @@ B&lt;EVP_KEYMGMT&gt; I&lt;keymgmt&gt;.
 EVP_KEYMGMT_free() decrements the reference count for the given
 B&lt;EVP_KEYMGMT&gt; I&lt;keymgmt&gt;, and when the count reaches zero, frees it.
 
-EVP_KEYMGMT_provider() returns the provider that has this particular
+EVP_KEYMGMT_get0_provider() returns the provider that has this particular
 implementation.
 
 EVP_KEYMGMT_is_a() checks if I&lt;keymgmt&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;.
 
-EVP_KEYMGMT_number() returns the internal dynamic number assigned to
+EVP_KEYMGMT_get_number() returns the internal dynamic number assigned to
 the I&lt;keymgmt&gt;.
 
-EVP_KEYMGMT_name() returns the algorithm name from the provided implementation
-for the given I&lt;keymgmt&gt;. Note that the I&lt;keymgmt&gt; may have multiple synonyms
-associated with it. In this case the first name from the algorithm
-definition is returned. Ownership of the returned string is retained by the
-I&lt;keymgmt&gt; object and should not be freed by the caller.
+EVP_KEYMGMT_get0_name() returns the algorithm name from the provided
+implementation for the given I&lt;keymgmt&gt;. Note that the I&lt;keymgmt&gt; may have
+multiple synonyms associated with it. In this case the first name from the
+algorithm definition is returned. Ownership of the returned string is
+retained by the I&lt;keymgmt&gt; object and should not be freed by the caller.
 
 EVP_KEYMGMT_names_do_all() traverses all names for the I&lt;keymgmt&gt;, and
 calls I&lt;fn&gt; with each name and I&lt;data&gt;.
 
-EVP_KEYMGMT_description() returns a description of the I&lt;keymgmt&gt;, meant for
-display and human consumption.  The description is at the discretion of the
-I&lt;keymgmt&gt; implementation.
+EVP_KEYMGMT_get0_description() returns a description of the I&lt;keymgmt&gt;, meant
+for display and human consumption.  The description is at the discretion
+of the I&lt;keymgmt&gt; implementation.
 
 EVP_KEYMGMT_do_all_provided() traverses all key keymgmt implementations by
 all activated providers in the library context I&lt;libctx&gt;, and for each
@@ -121,17 +121,17 @@ names. A return value of 0 means that the callback was not called for any names.
 
 EVP_KEYMGMT_free() doesn't return any value.
 
-EVP_KEYMGMT_provider() returns a pointer to a provider object, or NULL
+EVP_KEYMGMT_get0_provider() returns a pointer to a provider object, or NULL
 on error.
 
 EVP_KEYMGMT_is_a() returns 1 of I&lt;keymgmt&gt; was identifiable,
 otherwise 0.
 
-EVP_KEYMGMT_number() returns an integer.
+EVP_KEYMGMT_get_number() returns an integer.
 
-EVP_KEYMGMT_name() returns the algorithm name, or NULL on error.
+EVP_KEYMGMT_get0_name() returns the algorithm name, or NULL on error.
 
-EVP_KEYMGMT_description() returns a pointer to a decription, or NULL if
+EVP_KEYMGMT_get0_description() returns a pointer to a decription, or NULL if
 there isn't one.
 
 EVP_KEYMGMT_gettable_params(), EVP_KEYMGMT_settable_params() and
diff --git a/doc/man3/EVP_MAC.pod b/doc/man3/EVP_MAC.pod
index 0fc34009ec..6468e22a02 100644
--- a/doc/man3/EVP_MAC.pod
+++ b/doc/man3/EVP_MAC.pod
@@ -3,10 +3,11 @@
 =head1 NAME
 
 EVP_MAC, EVP_MAC_fetch, EVP_MAC_up_ref, EVP_MAC_free, EVP_MAC_is_a,
-EVP_MAC_number, EVP_MAC_name, EVP_MAC_names_do_all, EVP_MAC_description,
-EVP_MAC_provider, EVP_MAC_get_params, EVP_MAC_gettable_params,
+EVP_MAC_get_number, EVP_MAC_get0_name, EVP_MAC_names_do_all,
+EVP_MAC_get0_description,
+EVP_MAC_get0_provider, EVP_MAC_get_params, EVP_MAC_gettable_params,
 EVP_MAC_CTX, EVP_MAC_CTX_new, EVP_MAC_CTX_free, EVP_MAC_CTX_dup,
-EVP_MAC_CTX_mac, EVP_MAC_CTX_get_params, EVP_MAC_CTX_set_params,
+EVP_MAC_CTX_get0_mac, EVP_MAC_CTX_get_params, EVP_MAC_CTX_set_params,
 EVP_MAC_CTX_get_mac_size, EVP_MAC_CTX_get_block_size, EVP_Q_mac,
 EVP_MAC_init, EVP_MAC_update, EVP_MAC_final, EVP_MAC_finalXOF,
 EVP_MAC_gettable_ctx_params, EVP_MAC_settable_ctx_params,
@@ -25,19 +26,19 @@ EVP_MAC_do_all_provided - EVP MAC routines
  int EVP_MAC_up_ref(EVP_MAC *mac);
  void EVP_MAC_free(EVP_MAC *mac);
  int EVP_MAC_is_a(const EVP_MAC *mac, const char *name);
- int EVP_MAC_number(const EVP_MAC *mac);
- const char *EVP_MAC_name(const EVP_MAC *mac);
+ int EVP_MAC_get_number(const EVP_MAC *mac);
+ const char *EVP_MAC_get0_name(const EVP_MAC *mac);
  int EVP_MAC_names_do_all(const EVP_MAC *mac,
                           void (*fn)(const char *name, void *data),
                           void *data);
- const char *EVP_MAC_description(const EVP_MAC *mac);
- const OSSL_PROVIDER *EVP_MAC_provider(const EVP_MAC *mac);
+ const char *EVP_MAC_get0_description(const EVP_MAC *mac);
+ const OSSL_PROVIDER *EVP_MAC_get0_provider(const EVP_MAC *mac);
  int EVP_MAC_get_params(EVP_MAC *mac, OSSL_PARAM params[]);
 
  EVP_MAC_CTX *EVP_MAC_CTX_new(EVP_MAC *mac);
  void EVP_MAC_CTX_free(EVP_MAC_CTX *ctx);
  EVP_MAC_CTX *EVP_MAC_CTX_dup(const EVP_MAC_CTX *src);
- EVP_MAC *EVP_MAC_CTX_mac(EVP_MAC_CTX *ctx);
+ EVP_MAC *EVP_MAC_CTX_get0_mac(EVP_MAC_CTX *ctx);
  int EVP_MAC_CTX_get_params(EVP_MAC_CTX *ctx, OSSL_PARAM params[]);
  int EVP_MAC_CTX_set_params(EVP_MAC_CTX *ctx, const OSSL_PARAM params[]);
 
@@ -121,7 +122,7 @@ NULL is a valid parameter, for which this function is a no-op.
 EVP_MAC_CTX_dup() duplicates the I&lt;src&gt; context and returns a newly allocated
 context.
 
-EVP_MAC_CTX_mac() returns the B&lt;EVP_MAC&gt; associated with the context
+EVP_MAC_CTX_get0_mac() returns the B&lt;EVP_MAC&gt; associated with the context
 I&lt;ctx&gt;.
 
 =head2 Computing functions
@@ -219,7 +220,7 @@ Not all MAC algorithms support this.
 EVP_MAC_is_a() checks if the given I&lt;mac&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;.
 
-EVP_MAC_provider() returns the provider that holds the implementation
+EVP_MAC_get0_provider() returns the provider that holds the implementation
 of the given I&lt;mac&gt;.
 
 EVP_MAC_do_all_provided() traverses all MAC implemented by all activated
@@ -227,19 +228,19 @@ providers in the given library context I&lt;libctx&gt;, and for each of the
 implementations, calls the given function I&lt;fn&gt; with the implementation method
 and the given I&lt;arg&gt; as argument.
 
-EVP_MAC_number() returns the internal dynamic number assigned to
+EVP_MAC_get_number() returns the internal dynamic number assigned to
 I&lt;mac&gt;.
 
-EVP_MAC_name() return the name of the given MAC.  For fetched MACs
+EVP_MAC_get0_name() return the name of the given MAC.  For fetched MACs
 with multiple names, only one of them is returned; it's
 recommended to use EVP_MAC_names_do_all() instead.
 
 EVP_MAC_names_do_all() traverses all names for I&lt;mac&gt;, and calls
 I&lt;fn&gt; with each name and I&lt;data&gt;.
 
-EVP_MAC_description() returns a description of the I&lt;mac&gt;, meant for display
-and human consumption.  The description is at the discretion of the mac
-implementation.
+EVP_MAC_get0_description() returns a description of the I&lt;mac&gt;, meant
+for display and human consumption.  The description is at the discretion
+of the mac implementation.
 
 =head1 PARAMETERS
 
@@ -364,9 +365,9 @@ EVP_MAC_free() returns nothing at all.
 EVP_MAC_is_a() returns 1 if the given method can be identified with
 the given name, otherwise 0.
 
-EVP_MAC_name() returns a name of the MAC, or NULL on error.
+EVP_MAC_get0_name() returns a name of the MAC, or NULL on error.
 
-EVP_MAC_provider() returns a pointer to the provider for the MAC, or
+EVP_MAC_get0_provider() returns a pointer to the provider for the MAC, or
 NULL on error.
 
 EVP_MAC_CTX_new() and EVP_MAC_CTX_dup() return a pointer to a newly
diff --git a/doc/man3/EVP_MD_meth_new.pod b/doc/man3/EVP_MD_meth_new.pod
index e2db3fc52a..698216ac26 100644
--- a/doc/man3/EVP_MD_meth_new.pod
+++ b/doc/man3/EVP_MD_meth_new.pod
@@ -144,7 +144,7 @@ computations after the method's private data structure has been copied
 from one B&lt;EVP_MD_CTX&gt; to another.  If all that's needed is to copy
 the data, there is no need for this copy function.
 Note that the copy function is passed two B&lt;EVP_MD_CTX *&gt;, the private
-data structure is then available with EVP_MD_CTX_md_data().
+data structure is then available with EVP_MD_CTX_get0_md_data().
 This copy function is called by EVP_MD_CTX_copy() and
 EVP_MD_CTX_copy_ex().
 
@@ -152,7 +152,7 @@ EVP_MD_meth_set_cleanup() sets the function for B&lt;md&gt; to do extra
 cleanup before the method's private data structure is cleaned out and
 freed.
 Note that the cleanup function is passed a B&lt;EVP_MD_CTX *&gt;, the
-private data structure is then available with EVP_MD_CTX_md_data().
+private data structure is then available with EVP_MD_CTX_get0_md_data().
 This cleanup function is called by EVP_MD_CTX_reset() and
 EVP_MD_CTX_free().
 
diff --git a/doc/man3/EVP_PKEY_ASN1_METHOD.pod b/doc/man3/EVP_PKEY_ASN1_METHOD.pod
index 4a515590cc..cc50d363da 100644
--- a/doc/man3/EVP_PKEY_ASN1_METHOD.pod
+++ b/doc/man3/EVP_PKEY_ASN1_METHOD.pod
@@ -197,10 +197,10 @@ It's called by L&lt;EVP_PKEY_print_private(3)&gt;.
  int (*pkey_security_bits) (const EVP_PKEY *pk);
 
 The pkey_size() method returns the key size in bytes.
-It's called by L&lt;EVP_PKEY_size(3)&gt;.
+It's called by L&lt;EVP_PKEY_get_size(3)&gt;.
 
 The pkey_bits() method returns the key size in bits.
-It's called by L&lt;EVP_PKEY_bits(3)&gt;.
+It's called by L&lt;EVP_PKEY_get_bits(3)&gt;.
 
  int (*param_decode) (EVP_PKEY *pkey,
                       const unsigned char **pder, int derlen);
diff --git a/doc/man3/EVP_PKEY_CTX_set_hkdf_md.pod b/doc/man3/EVP_PKEY_CTX_set_hkdf_md.pod
index aae31710d7..f16963640d 100644
--- a/doc/man3/EVP_PKEY_CTX_set_hkdf_md.pod
+++ b/doc/man3/EVP_PKEY_CTX_set_hkdf_md.pod
@@ -4,14 +4,14 @@
 
 EVP_PKEY_CTX_set_hkdf_md, EVP_PKEY_CTX_set1_hkdf_salt,
 EVP_PKEY_CTX_set1_hkdf_key, EVP_PKEY_CTX_add1_hkdf_info,
-EVP_PKEY_CTX_hkdf_mode -
+EVP_PKEY_CTX_set_hkdf_mode -
 HMAC-based Extract-and-Expand key derivation algorithm
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/kdf.h&gt;
 
- int EVP_PKEY_CTX_hkdf_mode(EVP_PKEY_CTX *pctx, int mode);
+ int EVP_PKEY_CTX_set_hkdf_mode(EVP_PKEY_CTX *pctx, int mode);
 
  int EVP_PKEY_CTX_set_hkdf_md(EVP_PKEY_CTX *pctx, const EVP_MD *md);
 
@@ -33,8 +33,8 @@ and &quot;extracts&quot; from it a fixed-length pseudorandom key K. The second stage
 &quot;expands&quot; the key K into several additional pseudorandom keys (the output
 of the KDF).
 
-EVP_PKEY_CTX_hkdf_mode() sets the mode for the HKDF operation. There are three
-modes that are currently defined:
+EVP_PKEY_CTX_set_hkdf_mode() sets the mode for the HKDF operation. There
+are three modes that are currently defined:
 
 =over 4
 
diff --git a/doc/man3/EVP_PKEY_size.pod b/doc/man3/EVP_PKEY_get_size.pod
similarity index 62%
rename from doc/man3/EVP_PKEY_size.pod
rename to doc/man3/EVP_PKEY_get_size.pod
index 786c503914..b663e27f64 100644
--- a/doc/man3/EVP_PKEY_size.pod
+++ b/doc/man3/EVP_PKEY_get_size.pod
@@ -2,20 +2,25 @@
 
 =head1 NAME
 
-EVP_PKEY_size, EVP_PKEY_bits, EVP_PKEY_security_bits
+EVP_PKEY_get_size, EVP_PKEY_get_bits, EVP_PKEY_get_security_bits,
+EVP_PKEY_bits, EVP_PKEY_security_bits, EVP_PKEY_size
 - EVP_PKEY information functions
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/evp.h&gt;
 
- int EVP_PKEY_size(const EVP_PKEY *pkey);
- int EVP_PKEY_bits(const EVP_PKEY *pkey);
- int EVP_PKEY_security_bits(const EVP_PKEY *pkey);
+ int EVP_PKEY_get_size(const EVP_PKEY *pkey);
+ int EVP_PKEY_get_bits(const EVP_PKEY *pkey);
+ int EVP_PKEY_get_security_bits(const EVP_PKEY *pkey);
+
+ #define EVP_PKEY_bits EVP_PKEY_get_bits
+ #define EVP_PKEY_security_bits EVP_PKEY_get_security_bits
+ #define EVP_PKEY_size EVP_PKEY_get_size
 
 =head1 DESCRIPTION
 
-EVP_PKEY_size() returns the maximum suitable size for the output
+EVP_PKEY_get_size() returns the maximum suitable size for the output
 buffers for almost all operations that can be done with I&lt;pkey&gt;.
 The primary documented use is with L&lt;EVP_SignFinal(3)&gt; and
 L&lt;EVP_SealInit(3)&gt;, but it isn't limited there.  The returned size is
@@ -24,38 +29,38 @@ L&lt;EVP_PKEY_encrypt(3)&gt;, L&lt;EVP_PKEY_decrypt(3)&gt;, L&lt;EVP_PKEY_derive(3)&gt;.
 
 It must be stressed that, unless the documentation for the operation
 that's being performed says otherwise, the size returned by
-EVP_PKEY_size() is only preliminary and not exact, so the final
+EVP_PKEY_get_size() is only preliminary and not exact, so the final
 contents of the target buffer may be smaller.  It is therefore crucial
 to take note of the size given back by the function that performs the
 operation, such as L&lt;EVP_PKEY_sign(3)&gt; (the I&lt;siglen&gt; argument will
 receive that length), to avoid bugs.
 
-EVP_PKEY_bits() returns the cryptographic length of the cryptosystem
+EVP_PKEY_get_bits() returns the cryptographic length of the cryptosystem
 to which the key in I&lt;pkey&gt; belongs, in bits.  Note that the definition
 of cryptographic length is specific to the key cryptosystem.
 
-EVP_PKEY_security_bits() returns the number of security bits of the given
+EVP_PKEY_get_security_bits() returns the number of security bits of the given
 I&lt;pkey&gt;, bits of security is defined in NIST SP800-57.
 
 =head1 RETURN VALUES
 
-EVP_PKEY_size(), EVP_PKEY_bits() and EVP_PKEY_security_bits() return a
-positive number, or 0 if this size isn't available.
+EVP_PKEY_get_size(), EVP_PKEY_get_bits() and EVP_PKEY_get_security_bits()
+return a positive number, or 0 if this size isn't available.
 
 =head1 NOTES
 
 Most functions that have an output buffer and are mentioned with
-EVP_PKEY_size() have a functionality where you can pass NULL for the
+EVP_PKEY_get_size() have a functionality where you can pass NULL for the
 buffer and still pass a pointer to an integer and get the exact size
 that this function call delivers in the context that it's called in.
 This allows those functions to be called twice, once to find out the
 exact buffer size, then allocate the buffer in between, and call that
 function again actually output the data.  For those functions, it
-isn't strictly necessary to call EVP_PKEY_size() to find out the
+isn't strictly necessary to call EVP_PKEY_get_size() to find out the
 buffer size, but may be useful in cases where it's desirable to know
 the upper limit in advance.
 
-It should also be especially noted that EVP_PKEY_size() shouldn't be
+It should also be especially noted that EVP_PKEY_get_size() shouldn't be
 used to get the output size for EVP_DigestSignFinal(), according to
 L&lt;EVP_DigestSignFinal(3)/NOTES&gt;.
 
@@ -68,6 +73,12 @@ L&lt;EVP_PKEY_encrypt(3)&gt;,
 L&lt;EVP_PKEY_decrypt(3)&gt;,
 L&lt;EVP_PKEY_derive(3)&gt;
 
+=head1 HISTORY
+
+The EVP_PKEY_bits(), EVP_PKEY_security_bits(), and EVP_PKEY_size() functions
+were renamed to include C&lt;get&gt; in their names in OpenSSL 3.0, respectively.
+The old names are kept as non-deprecated alias macros.
+
 =head1 COPYRIGHT
 
 Copyright 2020 The OpenSSL Project Authors. All Rights Reserved.
diff --git a/doc/man3/EVP_PKEY_new.pod b/doc/man3/EVP_PKEY_new.pod
index d98d7c240e..89b93c9bac 100644
--- a/doc/man3/EVP_PKEY_new.pod
+++ b/doc/man3/EVP_PKEY_new.pod
@@ -7,7 +7,7 @@ EVP_PKEY_new,
 EVP_PKEY_up_ref,
 EVP_PKEY_dup,
 EVP_PKEY_free,
-EVP_PKEY_description,
+EVP_PKEY_get0_description,
 EVP_PKEY_new_raw_private_key_ex,
 EVP_PKEY_new_raw_private_key,
 EVP_PKEY_new_raw_public_key_ex,
@@ -28,7 +28,7 @@ EVP_PKEY_get_raw_public_key
  int EVP_PKEY_up_ref(EVP_PKEY *key);
  EVP_PKEY *EVP_PKEY_dup(EVP_PKEY *key);
  void EVP_PKEY_free(EVP_PKEY *key);
- const char *EVP_PKEY_description(const EVP_PKEY *key);
+ const char *EVP_PKEY_get0_description(const EVP_PKEY *key);
 
  EVP_PKEY *EVP_PKEY_new_raw_private_key_ex(OSSL_LIB_CTX *libctx,
                                            const char *keytype,
@@ -92,9 +92,9 @@ a raw key, otherwise the duplication will fail.
 EVP_PKEY_free() decrements the reference count of I&lt;key&gt; and, if the reference
 count is zero, frees it up. If I&lt;key&gt; is NULL, nothing is done.
 
-EVP_PKEY_description() returns a description of the type of B&lt;EVP_PKEY&gt;, meant
-for display and human consumption.  The description is at the discretion of the
-key type implementation.
+EVP_PKEY_get0_description() returns a description of the type of B&lt;EVP_PKEY&gt;,
+meant for display and human consumption.  The description is at the
+discretion of the key type implementation.
 
 EVP_PKEY_new_raw_private_key_ex() allocates a new B&lt;EVP_PKEY&gt;. Unless an
 engine should be used for the key type, a provider for the key is found using
diff --git a/doc/man3/EVP_PKEY_set1_RSA.pod b/doc/man3/EVP_PKEY_set1_RSA.pod
index e905024199..59ea093d59 100644
--- a/doc/man3/EVP_PKEY_set1_RSA.pod
+++ b/doc/man3/EVP_PKEY_set1_RSA.pod
@@ -8,18 +8,22 @@ EVP_PKEY_get0_RSA, EVP_PKEY_get0_DSA, EVP_PKEY_get0_DH, EVP_PKEY_get0_EC_KEY,
 EVP_PKEY_assign_RSA, EVP_PKEY_assign_DSA, EVP_PKEY_assign_DH,
 EVP_PKEY_assign_EC_KEY, EVP_PKEY_assign_POLY1305, EVP_PKEY_assign_SIPHASH,
 EVP_PKEY_get0_hmac, EVP_PKEY_get0_poly1305, EVP_PKEY_get0_siphash,
-EVP_PKEY_get0, EVP_PKEY_type, EVP_PKEY_id, EVP_PKEY_base_id,
-EVP_PKEY_set1_engine, EVP_PKEY_get0_engine -
+EVP_PKEY_get0, EVP_PKEY_type, EVP_PKEY_get_id, EVP_PKEY_get_base_id,
+EVP_PKEY_set1_engine, EVP_PKEY_get0_engine,
+EVP_PKEY_id, EVP_PKEY_base_id -
 EVP_PKEY assignment functions
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/evp.h&gt;
 
- int EVP_PKEY_id(const EVP_PKEY *pkey);
- int EVP_PKEY_base_id(const EVP_PKEY *pkey);
+ int EVP_PKEY_get_id(const EVP_PKEY *pkey);
+ int EVP_PKEY_get_base_id(const EVP_PKEY *pkey);
  int EVP_PKEY_type(int type);
 
+ #define EVP_PKEY_id EVP_PKEY_get_id
+ #define EVP_PKEY_base_id EVP_PKEY_get_base_id
+
 Deprecated since OpenSSL 3.0, can be hidden entirely by defining
 B&lt;OPENSSL_API_COMPAT&gt; with a suitable version value, see
 L&lt;openssl_user_macros(7)&gt;:
@@ -55,13 +59,14 @@ L&lt;openssl_user_macros(7)&gt;:
 
 =head1 DESCRIPTION
 
-EVP_PKEY_base_id() returns the type of I&lt;pkey&gt;. For example
+EVP_PKEY_get_base_id() returns the type of I&lt;pkey&gt;. For example
 an RSA key will return B&lt;EVP_PKEY_RSA&gt;.
 
-EVP_PKEY_id() returns the actual OID associated with I&lt;pkey&gt;. Historically keys
-using the same algorithm could use different OIDs. For example an RSA key could
-use the OIDs corresponding to the NIDs B&lt;NID_rsaEncryption&gt; (equivalent to
-B&lt;EVP_PKEY_RSA&gt;) or B&lt;NID_rsa&gt; (equivalent to B&lt;EVP_PKEY_RSA2&gt;). The use of
+EVP_PKEY_get_id() returns the actual OID associated with I&lt;pkey&gt;.
+Historically keys using the same algorithm could use different OIDs.
+For example an RSA key could use the OIDs corresponding to
+the NIDs B&lt;NID_rsaEncryption&gt; (equivalent to B&lt;EVP_PKEY_RSA&gt;) or
+B&lt;NID_rsa&gt; (equivalent to B&lt;EVP_PKEY_RSA2&gt;). The use of
 alternative non-standard OIDs is now rare so B&lt;EVP_PKEY_RSA2&gt; et al are not
 often seen in practice.
 
@@ -133,7 +138,7 @@ instead of engines (see L&lt;provider(7)&gt; for details).
 The following functions are only reliable with B&lt;EVP_PKEY&gt;s that have
 been assigned an internal key with EVP_PKEY_assign_*():
 
-EVP_PKEY_id(), EVP_PKEY_base_id(), EVP_PKEY_type()
+EVP_PKEY_get_id(), EVP_PKEY_get_base_id(), EVP_PKEY_type()
 
 For EVP_PKEY key type checking purposes, L&lt;EVP_PKEY_is_a(3)&gt; is more generic.
 
@@ -163,12 +168,12 @@ the passed B&lt;EC_KEY&gt; is an L&lt;SM2(7)&gt; key, and will set the B&lt;EVP_PKEY&gt;
 type to B&lt;EVP_PKEY_SM2&gt; in that case, instead of B&lt;EVP_PKEY_EC&gt;.
 
 Most applications wishing to know a key type will simply call
-EVP_PKEY_base_id() and will not care about the actual type:
+EVP_PKEY_get_base_id() and will not care about the actual type:
 which will be identical in almost all cases.
 
 Previous versions of this document suggested using EVP_PKEY_type(pkey-&gt;type)
 to determine the type of a key. Since B&lt;EVP_PKEY&gt; is now opaque this
-is no longer possible: the equivalent is EVP_PKEY_base_id(pkey).
+is no longer possible: the equivalent is EVP_PKEY_get_base_id(pkey).
 
 EVP_PKEY_set1_engine() is typically used by an ENGINE returning an HSM
 key as part of its routine to load a private key.
@@ -186,7 +191,7 @@ EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH(),
 EVP_PKEY_assign_EC_KEY(), EVP_PKEY_assign_POLY1305()
 and EVP_PKEY_assign_SIPHASH() return 1 for success and 0 for failure.
 
-EVP_PKEY_base_id(), EVP_PKEY_id() and EVP_PKEY_type() return a key
+EVP_PKEY_get_base_id(), EVP_PKEY_get_id() and EVP_PKEY_type() return a key
 type or B&lt;NID_undef&gt; (equivalently B&lt;EVP_PKEY_NONE&gt;) on error.
 
 EVP_PKEY_set1_engine() returns 1 for success and 0 for failure.
@@ -197,6 +202,10 @@ L&lt;EVP_PKEY_new(3)&gt;, L&lt;SM2(7)&gt;
 
 =head1 HISTORY
 
+The EVP_PKEY_id() and EVP_PKEY_base_id() functions were renamed to
+include C&lt;get&gt; in their names in OpenSSL 3.0, respectively. The old names
+are kept as non-deprecated alias macros.
+
 EVP_PKEY_set1_RSA, EVP_PKEY_set1_DSA, EVP_PKEY_set1_DH, EVP_PKEY_set1_EC_KEY,
 EVP_PKEY_get1_RSA, EVP_PKEY_get1_DSA, EVP_PKEY_get1_DH, EVP_PKEY_get1_EC_KEY,
 EVP_PKEY_get0_RSA, EVP_PKEY_get0_DSA, EVP_PKEY_get0_DH, EVP_PKEY_get0_EC_KEY,
diff --git a/doc/man3/EVP_PKEY_set_type.pod b/doc/man3/EVP_PKEY_set_type.pod
index e5111a555b..9ba460c5c0 100644
--- a/doc/man3/EVP_PKEY_set_type.pod
+++ b/doc/man3/EVP_PKEY_set_type.pod
@@ -35,7 +35,7 @@ It is an error if no L&lt;EVP_PKEY_ASN1_METHOD(3)&gt; could be found for
 I&lt;type&gt;.
 
 For both EVP_PKEY_set_type() and EVP_PKEY_set_type_str(), I&lt;pkey&gt; gets
-a numeric type, which can be retrieved with L&lt;EVP_PKEY_id(3)&gt;.  This
+a numeric type, which can be retrieved with L&lt;EVP_PKEY_get_id(3)&gt;.  This
 numeric type is taken from the L&lt;EVP_PKEY_ASN1_METHOD(3)&gt; that was
 found, and is equal to or closely related to I&lt;type&gt; in the case of
 EVP_PKEY_set_type(), or related to I&lt;str&gt; in the case of
@@ -44,7 +44,7 @@ EVP_PKEY_set_type_str().
 EVP_PKEY_set_type_by_keymgmt() initialises I&lt;pkey&gt; to contain an
 internal provider side key.  When doing this, it associates I&lt;pkey&gt;
 with I&lt;keymgmt&gt;.  For keys initialised like this, the numeric type
-retrieved with L&lt;EVP_PKEY_id(3)&gt; will always be B&lt;EVP_PKEY_NONE&gt;.
+retrieved with L&lt;EVP_PKEY_get_id(3)&gt; will always be B&lt;EVP_PKEY_NONE&gt;.
 
 =head1 RETURN VALUES
 
@@ -52,7 +52,7 @@ All functions described here return 1 if successful, or 0 on error.
 
 =head1 SEE ALSO
 
-L&lt;EVP_PKEY_assign(3)&gt;, L&lt;EVP_PKEY_id(3)&gt;, L&lt;EVP_PKEY_get0_RSA(3)&gt;,
+L&lt;EVP_PKEY_assign(3)&gt;, L&lt;EVP_PKEY_get_id(3)&gt;, L&lt;EVP_PKEY_get0_RSA(3)&gt;,
 L&lt;EVP_PKEY_copy_parameters(3)&gt;, L&lt;EVP_PKEY_ASN1_METHOD(3)&gt;,
 L&lt;EVP_KEYMGMT(3)&gt;
 
diff --git a/doc/man3/EVP_RAND.pod b/doc/man3/EVP_RAND.pod
index b2d1e18417..bcee801c4e 100644
--- a/doc/man3/EVP_RAND.pod
+++ b/doc/man3/EVP_RAND.pod
@@ -5,10 +5,11 @@
 EVP_RAND, EVP_RAND_fetch, EVP_RAND_free, EVP_RAND_up_ref, EVP_RAND_CTX,
 EVP_RAND_CTX_new, EVP_RAND_CTX_free, EVP_RAND_instantiate,
 EVP_RAND_uninstantiate, EVP_RAND_generate, EVP_RAND_reseed, EVP_RAND_nonce,
-EVP_RAND_enable_locking, EVP_RAND_verify_zeroization, EVP_RAND_strength,
-EVP_RAND_state,
-EVP_RAND_provider, EVP_RAND_CTX_rand, EVP_RAND_is_a, EVP_RAND_number,
-EVP_RAND_name, EVP_RAND_names_do_all, EVP_RAND_description,
+EVP_RAND_enable_locking, EVP_RAND_verify_zeroization, EVP_RAND_get_strength,
+EVP_RAND_get_state,
+EVP_RAND_get0_provider, EVP_RAND_CTX_get0_rand, EVP_RAND_is_a,
+EVP_RAND_get_number, EVP_RAND_get0_name, EVP_RAND_names_do_all,
+EVP_RAND_get0_description,
 EVP_RAND_CTX_get_params,
 EVP_RAND_CTX_set_params, EVP_RAND_do_all_provided, EVP_RAND_get_params,
 EVP_RAND_gettable_ctx_params, EVP_RAND_settable_ctx_params,
@@ -29,7 +30,7 @@ EVP_RAND_STATE_ERROR - EVP RAND routines
  void EVP_RAND_free(EVP_RAND *rand);
  EVP_RAND_CTX *EVP_RAND_CTX_new(EVP_RAND *rand, EVP_RAND_CTX *parent);
  void EVP_RAND_CTX_free(EVP_RAND_CTX *ctx);
- EVP_RAND *EVP_RAND_CTX_rand(EVP_RAND_CTX *ctx);
+ EVP_RAND *EVP_RAND_CTX_get0_rand(EVP_RAND_CTX *ctx);
  int EVP_RAND_get_params(EVP_RAND *rand, OSSL_PARAM params[]);
  int EVP_RAND_CTX_get_params(EVP_RAND_CTX *ctx, OSSL_PARAM params[]);
  int EVP_RAND_CTX_set_params(EVP_RAND_CTX *ctx, const OSSL_PARAM params[]);
@@ -38,11 +39,11 @@ EVP_RAND_STATE_ERROR - EVP RAND routines
  const OSSL_PARAM *EVP_RAND_settable_ctx_params(const EVP_RAND *rand);
  const OSSL_PARAM *EVP_RAND_CTX_gettable_params(EVP_RAND_CTX *ctx);
  const OSSL_PARAM *EVP_RAND_CTX_settable_params(EVP_RAND_CTX *ctx);
- int EVP_RAND_number(const EVP_RAND *rand);
- const char *EVP_RAND_name(const EVP_RAND *rand);
- const char *EVP_RAND_description(const EVP_RAND *rand);
+ int EVP_RAND_get_number(const EVP_RAND *rand);
+ const char *EVP_RAND_get0_name(const EVP_RAND *rand);
+ const char *EVP_RAND_get0_description(const EVP_RAND *rand);
  int EVP_RAND_is_a(const EVP_RAND *rand, const char *name);
- const OSSL_PROVIDER *EVP_RAND_provider(const EVP_RAND *rand);
+ const OSSL_PROVIDER *EVP_RAND_get0_provider(const EVP_RAND *rand);
  void EVP_RAND_do_all_provided(OSSL_LIB_CTX *libctx,
                                void (*fn)(EVP_RAND *rand, void *arg),
                                void *arg);
@@ -64,8 +65,8 @@ EVP_RAND_STATE_ERROR - EVP RAND routines
  int EVP_RAND_nonce(EVP_RAND_CTX *ctx, unsigned char *out, size_t outlen);
  int EVP_RAND_enable_locking(EVP_RAND_CTX *ctx);
  int EVP_RAND_verify_zeroization(EVP_RAND_CTX *ctx);
- unsigned int EVP_RAND_strength(EVP_RAND_CTX *ctx);
- int EVP_RAND_state(EVP_RAND_CTX *ctx);
+ unsigned int EVP_RAND_get_strength(EVP_RAND_CTX *ctx);
+ int EVP_RAND_get_state(EVP_RAND_CTX *ctx);
 
  #define EVP_RAND_STATE_UNINITIALISED    0
  #define EVP_RAND_STATE_READY            1
@@ -121,7 +122,7 @@ rely on the operating system for their randomness because this is often scarce.
 EVP_RAND_CTX_free() frees up the context I&lt;ctx&gt;.  If I&lt;ctx&gt; is NULL, nothing
 is done.
 
-EVP_RAND_CTX_rand() returns the B&lt;EVP_RAND&gt; associated with the context
+EVP_RAND_CTX_get0_rand() returns the B&lt;EVP_RAND&gt; associated with the context
 I&lt;ctx&gt;.
 
 =head2 Random Number Generator Functions
@@ -209,9 +210,9 @@ B&lt;OSSL_PARAM&gt; as a parameter descriptor.
 
 =head2 Information functions
 
-EVP_RAND_strength() returns the security strength of the RAND I&lt;ctx&gt;.
+EVP_RAND_get_strength() returns the security strength of the RAND I&lt;ctx&gt;.
 
-EVP_RAND_state() returns the current state of the RAND I&lt;ctx&gt;.
+EVP_RAND_get_state() returns the current state of the RAND I&lt;ctx&gt;.
 States defined by the OpenSSL RNGs are:
 
 =over 4
@@ -234,7 +235,7 @@ EVP_RAND_STATE_ERROR: this RNG is in an error state.
 EVP_RAND_is_a() returns 1 if I&lt;rand&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;, otherwise 0.
 
-EVP_RAND_provider() returns the provider that holds the implementation
+EVP_RAND_get0_provider() returns the provider that holds the implementation
 of the given I&lt;rand&gt;.
 
 EVP_RAND_do_all_provided() traverses all RAND implemented by all activated
@@ -242,17 +243,17 @@ providers in the given library context I&lt;libctx&gt;, and for each of the
 implementations, calls the given function I&lt;fn&gt; with the implementation method
 and the given I&lt;arg&gt; as argument.
 
-EVP_RAND_number() returns the internal dynamic number assigned to
+EVP_RAND_get_number() returns the internal dynamic number assigned to
 I&lt;rand&gt;.
 
-EVP_RAND_name() returns the canonical name of I&lt;rand&gt;.
+EVP_RAND_get0_name() returns the canonical name of I&lt;rand&gt;.
 
 EVP_RAND_names_do_all() traverses all names for I&lt;rand&gt;, and calls
 I&lt;fn&gt; with each name and I&lt;data&gt;.
 
-EVP_RAND_description() returns a description of the rand, meant for display
-and human consumption.  The description is at the discretion of the rand
-implementation.
+EVP_RAND_get0_description() returns a description of the rand, meant for
+display and human consumption.  The description is at the discretion of
+the rand implementation.
 
 EVP_RAND_verify_zeroization() confirms if the internal DRBG state is
 currently zeroed.  This is used by the FIPS provider to support the mandatory
@@ -351,15 +352,16 @@ not be considered a breaking change to the API.
 EVP_RAND_fetch() returns a pointer to a newly fetched B&lt;EVP_RAND&gt;, or
 NULL if allocation failed.
 
-EVP_RAND_provider() returns a pointer to the provider for the RAND, or
+EVP_RAND_get0_provider() returns a pointer to the provider for the RAND, or
 NULL on error.
 
-EVP_RAND_CTX_rand() returns a pointer to the B&lt;EVP_RAND&gt; associated with the
-context.
+EVP_RAND_CTX_get0_rand() returns a pointer to the B&lt;EVP_RAND&gt; associated
+with the context.
 
-EVP_RAND_name() returns the name of the random number generation algorithm.
+EVP_RAND_get0_name() returns the name of the random number generation
+algorithm.
 
-EVP_RAND_number() returns the provider specific identification number
+EVP_RAND_get_number() returns the provider specific identification number
 for the specified algorithm.
 
 EVP_RAND_up_ref() returns 1 on success, 0 on error.
@@ -374,7 +376,8 @@ EVP_RAND_CTX_free() does not return a value.
 
 EVP_RAND_nonce() returns the length of the nonce.
 
-EVP_RAND_strength() returns the strength of the random number generator in bits.
+EVP_RAND_get_strength() returns the strength of the random number generator
+in bits.
 
 EVP_RAND_gettable_params(), EVP_RAND_gettable_ctx_params() and
 EVP_RAND_settable_ctx_params() return an array of OSSL_PARAMs.
diff --git a/doc/man3/EVP_SIGNATURE_free.pod b/doc/man3/EVP_SIGNATURE_free.pod
index a1897bbdb0..5c506dc67c 100644
--- a/doc/man3/EVP_SIGNATURE_free.pod
+++ b/doc/man3/EVP_SIGNATURE_free.pod
@@ -3,9 +3,9 @@
 =head1 NAME
 
 EVP_SIGNATURE_fetch, EVP_SIGNATURE_free, EVP_SIGNATURE_up_ref,
-EVP_SIGNATURE_number, EVP_SIGNATURE_is_a, EVP_SIGNATURE_provider,
+EVP_SIGNATURE_get_number, EVP_SIGNATURE_is_a, EVP_SIGNATURE_get0_provider,
 EVP_SIGNATURE_do_all_provided, EVP_SIGNATURE_names_do_all,
-EVP_SIGNATURE_name, EVP_SIGNATURE_description,
+EVP_SIGNATURE_get0_name, EVP_SIGNATURE_get0_description,
 EVP_SIGNATURE_gettable_ctx_params, EVP_SIGNATURE_settable_ctx_params
 - Functions to manage EVP_SIGNATURE algorithm objects
 
@@ -17,10 +17,10 @@ EVP_SIGNATURE_gettable_ctx_params, EVP_SIGNATURE_settable_ctx_params
                                     const char *properties);
  void EVP_SIGNATURE_free(EVP_SIGNATURE *signature);
  int EVP_SIGNATURE_up_ref(EVP_SIGNATURE *signature);
- int EVP_SIGNATURE_number(const EVP_SIGNATURE *signature);
- const char *EVP_SIGNATURE_name(const EVP_SIGNATURE *signature);
+ int EVP_SIGNATURE_get_number(const EVP_SIGNATURE *signature);
+ const char *EVP_SIGNATURE_get0_name(const EVP_SIGNATURE *signature);
  int EVP_SIGNATURE_is_a(const EVP_SIGNATURE *signature, const char *name);
- OSSL_PROVIDER *EVP_SIGNATURE_provider(const EVP_SIGNATURE *signature);
+ OSSL_PROVIDER *EVP_SIGNATURE_get0_provider(const EVP_SIGNATURE *signature);
  void EVP_SIGNATURE_do_all_provided(OSSL_LIB_CTX *libctx,
                                     void (*fn)(EVP_SIGNATURE *signature,
                                                void *arg),
@@ -28,8 +28,8 @@ EVP_SIGNATURE_gettable_ctx_params, EVP_SIGNATURE_settable_ctx_params
  int EVP_SIGNATURE_names_do_all(const EVP_SIGNATURE *signature,
                                 void (*fn)(const char *name, void *data),
                                 void *data);
- const char *EVP_SIGNATURE_name(const EVP_SIGNATURE *signature);
- const char *EVP_SIGNATURE_description(const EVP_SIGNATURE *signature);
+ const char *EVP_SIGNATURE_get0_name(const EVP_SIGNATURE *signature);
+ const char *EVP_SIGNATURE_get0_description(const EVP_SIGNATURE *signature);
  const OSSL_PARAM *EVP_SIGNATURE_gettable_ctx_params(const EVP_SIGNATURE *sig);
  const OSSL_PARAM *EVP_SIGNATURE_settable_ctx_params(const EVP_SIGNATURE *sig);
 
@@ -55,17 +55,18 @@ structure.
 EVP_SIGNATURE_is_a() returns 1 if I&lt;signature&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;, otherwise 0.
 
-EVP_SIGNATURE_provider() returns the provider that I&lt;signature&gt; was fetched from.
+EVP_SIGNATURE_get0_provider() returns the provider that I&lt;signature&gt; was
+fetched from.
 
 EVP_SIGNATURE_do_all_provided() traverses all SIGNATURE implemented by all
 activated roviders in the given library context I&lt;libctx&gt;, and for each of the
 implementations, calls the given function I&lt;fn&gt; with the implementation method
 and the given I&lt;arg&gt; as argument.
 
-EVP_SIGNATURE_number() returns the internal dynamic number assigned to
+EVP_SIGNATURE_get_number() returns the internal dynamic number assigned to
 I&lt;signature&gt;.
 
-EVP_SIGNATURE_name() returns the algorithm name from the provided
+EVP_SIGNATURE_get0_name() returns the algorithm name from the provided
 implementation for the given I&lt;signature&gt;. Note that the I&lt;signature&gt; may have
 multiple synonyms associated with it. In this case the first name from the
 algorithm definition is returned. Ownership of the returned string is retained
@@ -74,9 +75,9 @@ by the I&lt;signature&gt; object and should not be freed by the caller.
 EVP_SIGNATURE_names_do_all() traverses all names for I&lt;signature&gt;, and calls
 I&lt;fn&gt; with each name and I&lt;data&gt;.
 
-EVP_SIGNATURE_description() returns a description of the I&lt;signature&gt;, meant
-for display and human consumption.  The description is at the discretion of
-the I&lt;signature&gt; implementation.
+EVP_SIGNATURE_get0_description() returns a description of the I&lt;signature&gt;,
+meant for display and human consumption.  The description is at the
+discretion of the I&lt;signature&gt; implementation.
 
 EVP_SIGNATURE_gettable_ctx_params() and EVP_SIGNATURE_settable_ctx_params()
 return a constant B&lt;OSSL_PARAM&gt; array that describes the names and types of key
diff --git a/doc/man3/EVP_SealInit.pod b/doc/man3/EVP_SealInit.pod
index d2652f5cf9..8427fcc659 100644
--- a/doc/man3/EVP_SealInit.pod
+++ b/doc/man3/EVP_SealInit.pod
@@ -29,13 +29,13 @@ using one or more public keys, this allows the same encrypted data to be
 decrypted using any of the corresponding private keys. B&lt;ek&gt; is an array of
 buffers where the public key encrypted secret key will be written, each buffer
 must contain enough room for the corresponding encrypted key: that is
-B&lt;ek[i]&gt; must have room for B&lt;EVP_PKEY_size(pubk[i])&gt; bytes. The actual
+B&lt;ek[i]&gt; must have room for B&lt;EVP_PKEY_get_size(pubk[i])&gt; bytes. The actual
 size of each encrypted secret key is written to the array B&lt;ekl&gt;. B&lt;pubk&gt; is
 an array of B&lt;npubk&gt; public keys.
 
 The B&lt;iv&gt; parameter is a buffer where the generated IV is written to. It must
 contain enough room for the corresponding cipher's IV, as determined by (for
-example) EVP_CIPHER_iv_length(type).
+example) EVP_CIPHER_get_iv_length(type).
 
 If the cipher does not require an IV then the B&lt;iv&gt; parameter is ignored
 and can be B&lt;NULL&gt;.
diff --git a/doc/man3/EVP_SignInit.pod b/doc/man3/EVP_SignInit.pod
index e98d1faf46..cf0663cf8e 100644
--- a/doc/man3/EVP_SignInit.pod
+++ b/doc/man3/EVP_SignInit.pod
@@ -35,11 +35,11 @@ same I&lt;ctx&gt; to include additional data.
 EVP_SignFinal_ex() signs the data in I&lt;ctx&gt; using the private key
 I&lt;pkey&gt; and places the signature in I&lt;sig&gt;. The library context I&lt;libctx&gt; and
 property query I&lt;propq&gt; are used when creating a context to use with the key
-I&lt;pkey&gt;. I&lt;sig&gt; must be at least C&lt;EVP_PKEY_size(pkey)&gt; bytes in size. I&lt;s&gt; is
-an OUT parameter, and not used as an IN parameter.
+I&lt;pkey&gt;. I&lt;sig&gt; must be at least C&lt;EVP_PKEY_get_size(pkey)&gt; bytes in size.
+I&lt;s&gt; is an OUT parameter, and not used as an IN parameter.
 The number of bytes of data written (i.e. the length of the signature)
-will be written to the integer at I&lt;s&gt;, at most C&lt;EVP_PKEY_size(pkey)&gt; bytes
-will be written.
+will be written to the integer at I&lt;s&gt;, at most C&lt;EVP_PKEY_get_size(pkey)&gt;
+bytes will be written.
 
 EVP_SignFinal() is similar to EVP_SignFinal_ex() but uses default
 values of NULL for the library context I&lt;libctx&gt; and the property query I&lt;propq&gt;.
@@ -89,7 +89,8 @@ The previous two bugs are fixed in the newer EVP_SignDigest*() function.
 
 =head1 SEE ALSO
 
-L&lt;EVP_PKEY_size(3)&gt;, L&lt;EVP_PKEY_bits(3)&gt;, L&lt;EVP_PKEY_security_bits(3)&gt;,
+L&lt;EVP_PKEY_get_size(3)&gt;, L&lt;EVP_PKEY_get_bits(3)&gt;,
+L&lt;EVP_PKEY_get_security_bits(3)&gt;,
 L&lt;EVP_VerifyInit(3)&gt;,
 L&lt;EVP_DigestInit(3)&gt;,
 L&lt;evp(7)&gt;, L&lt;HMAC(3)&gt;, L&lt;MD2(3)&gt;,
diff --git a/doc/man3/OSSL_DECODER.pod b/doc/man3/OSSL_DECODER.pod
index fed0da27f8..10917ed462 100644
--- a/doc/man3/OSSL_DECODER.pod
+++ b/doc/man3/OSSL_DECODER.pod
@@ -6,12 +6,12 @@ OSSL_DECODER,
 OSSL_DECODER_fetch,
 OSSL_DECODER_up_ref,
 OSSL_DECODER_free,
-OSSL_DECODER_provider,
-OSSL_DECODER_properties,
+OSSL_DECODER_get0_provider,
+OSSL_DECODER_get0_properties,
 OSSL_DECODER_is_a,
-OSSL_DECODER_number,
-OSSL_DECODER_name,
-OSSL_DECODER_description,
+OSSL_DECODER_get_number,
+OSSL_DECODER_get0_name,
+OSSL_DECODER_get0_description,
 OSSL_DECODER_do_all_provided,
 OSSL_DECODER_names_do_all,
 OSSL_DECODER_gettable_params,
@@ -28,12 +28,12 @@ OSSL_DECODER_get_params
                                   const char *properties);
  int OSSL_DECODER_up_ref(OSSL_DECODER *decoder);
  void OSSL_DECODER_free(OSSL_DECODER *decoder);
- const OSSL_PROVIDER *OSSL_DECODER_provider(const OSSL_DECODER *decoder);
- const char *OSSL_DECODER_properties(const OSSL_DECODER *decoder);
+ const OSSL_PROVIDER *OSSL_DECODER_get0_provider(const OSSL_DECODER *decoder);
+ const char *OSSL_DECODER_get0_properties(const OSSL_DECODER *decoder);
  int OSSL_DECODER_is_a(const OSSL_DECODER *decoder, const char *name);
- int OSSL_DECODER_number(const OSSL_DECODER *decoder);
- const char *OSSL_DECODER_name(const OSSL_DECODER *decoder);
- const char *OSSL_DECODER_description(const OSSL_DECODER *decoder);
+ int OSSL_DECODER_get_number(const OSSL_DECODER *decoder);
+ const char *OSSL_DECODER_get0_name(const OSSL_DECODER *decoder);
+ const char *OSSL_DECODER_get0_description(const OSSL_DECODER *decoder);
  void OSSL_DECODER_do_all_provided(OSSL_LIB_CTX *libctx,
                                    void (*fn)(OSSL_DECODER *decoder, void *arg),
                                    void *arg);
@@ -64,21 +64,21 @@ I&lt;decoder&gt;.
 OSSL_DECODER_free() decrements the reference count for the given
 I&lt;decoder&gt;, and when the count reaches zero, frees it.
 
-OSSL_DECODER_provider() returns the provider of the given
+OSSL_DECODER_get0_provider() returns the provider of the given
 I&lt;decoder&gt;.
 
-OSSL_DECODER_properties() returns the property definition associated
+OSSL_DECODER_get0_properties() returns the property definition associated
 with the given I&lt;decoder&gt;.
 
 OSSL_DECODER_is_a() checks if I&lt;decoder&gt; is an implementation
 of an algorithm that's identifiable with I&lt;name&gt;.
 
-OSSL_DECODER_number() returns the internal dynamic number assigned
+OSSL_DECODER_get_number() returns the internal dynamic number assigned
 to the given I&lt;decoder&gt;.
 
-OSSL_DECODER_number() returns the name used to fetch the given I&lt;decoder&gt;.
+OSSL_DECODER_get_number() returns the name used to fetch the given I&lt;decoder&gt;.
 
-OSSL_DECODER_description() returns a description of the I&lt;decoder&gt;, meant
+OSSL_DECODER_get0_description() returns a description of the I&lt;decoder&gt;, meant
 for display and human consumption.  The description is at the discretion
 of the I&lt;decoder&gt; implementation.
 
@@ -106,24 +106,24 @@ OSSL_DECODER_up_ref() returns 1 on success, or 0 on error.
 
 OSSL_DECODER_free() doesn't return any value.
 
-OSSL_DECODER_provider() returns a pointer to a provider object, or
+OSSL_DECODER_get0_provider() returns a pointer to a provider object, or
 NULL on error.
 
-OSSL_DECODER_properties() returns a pointer to a property
+OSSL_DECODER_get0_properties() returns a pointer to a property
 definition string, or NULL on error.
 
 OSSL_DECODER_is_a() returns 1 if I&lt;decoder&gt; was identifiable,
 otherwise 0.
 
-OSSL_DECODER_number() returns an integer.
+OSSL_DECODER_get_number() returns an integer.
 
-OSSL_DECODER_name() returns the algorithm name from the provided
+OSSL_DECODER_get0_name() returns the algorithm name from the provided
 implementation for the given I&lt;decoder&gt;. Note that the I&lt;decoder&gt; may have
 multiple synonyms associated with it. In this case the first name from the
 algorithm definition is returned. Ownership of the returned string is retained
 by the I&lt;decoder&gt; object and should not be freed by the caller.
 
-OSSL_DECODER_description() returns a pointer to a decription, or NULL if
+OSSL_DECODER_get0_description() returns a pointer to a decription, or NULL if
 there isn't one.
 
 OSSL_DECODER_names_do_all() returns 1 if the callback was called for all
@@ -167,7 +167,7 @@ To list all decoders in a provider to a bio_out:
  for (i = 0; i &lt; sk_OSSL_DECODER_num(decoders); i++) {
      OSSL_DECODER *decoder = sk_OSSL_DECODER_value(decoders, i);
 
-     if (strcmp(OSSL_PROVIDER_name(OSSL_DECODER_provider(decoder)),
+     if (strcmp(OSSL_PROVIDER_get0_name(OSSL_DECODER_get0_provider(decoder)),
                 provider) != 0)
          continue;
 
diff --git a/doc/man3/OSSL_ENCODER.pod b/doc/man3/OSSL_ENCODER.pod
index 9ad335653e..0ff37a3b82 100644
--- a/doc/man3/OSSL_ENCODER.pod
+++ b/doc/man3/OSSL_ENCODER.pod
@@ -6,12 +6,12 @@ OSSL_ENCODER,
 OSSL_ENCODER_fetch,
 OSSL_ENCODER_up_ref,
 OSSL_ENCODER_free,
-OSSL_ENCODER_provider,
-OSSL_ENCODER_properties,
+OSSL_ENCODER_get0_provider,
+OSSL_ENCODER_get0_properties,
 OSSL_ENCODER_is_a,
-OSSL_ENCODER_number,
-OSSL_ENCODER_name,
-OSSL_ENCODER_description,
+OSSL_ENCODER_get_number,
+OSSL_ENCODER_get0_name,
+OSSL_ENCODER_get0_description,
 OSSL_ENCODER_do_all_provided,
 OSSL_ENCODER_names_do_all,
 OSSL_ENCODER_gettable_params,
@@ -28,12 +28,12 @@ OSSL_ENCODER_get_params
                                   const char *properties);
  int OSSL_ENCODER_up_ref(OSSL_ENCODER *encoder);
  void OSSL_ENCODER_free(OSSL_ENCODER *encoder);
- const OSSL_PROVIDER *OSSL_ENCODER_provider(const OSSL_ENCODER *encoder);
- const char *OSSL_ENCODER_properties(const OSSL_ENCODER *encoder);
+ const OSSL_PROVIDER *OSSL_ENCODER_get0_provider(const OSSL_ENCODER *encoder);
+ const char *OSSL_ENCODER_get0_properties(const OSSL_ENCODER *encoder);
  int OSSL_ENCODER_is_a(const OSSL_ENCODER *encoder, const char *name);
- int OSSL_ENCODER_number(const OSSL_ENCODER *encoder);
- const char *OSSL_ENCODER_name(const OSSL_ENCODER *encoder);
- const char *OSSL_ENCODER_description(const OSSL_ENCODER *encoder);
+ int OSSL_ENCODER_get_number(const OSSL_ENCODER *encoder);
+ const char *OSSL_ENCODER_get0_name(const OSSL_ENCODER *encoder);
+ const char *OSSL_ENCODER_get0_description(const OSSL_ENCODER *encoder);
  void OSSL_ENCODER_do_all_provided(OSSL_LIB_CTX *libctx,
                                    void (*fn)(OSSL_ENCODER *encoder, void *arg),
                                    void *arg);
@@ -64,21 +64,21 @@ I&lt;encoder&gt;.
 OSSL_ENCODER_free() decrements the reference count for the given
 I&lt;encoder&gt;, and when the count reaches zero, frees it.
 
-OSSL_ENCODER_provider() returns the provider of the given
+OSSL_ENCODER_get0_provider() returns the provider of the given
 I&lt;encoder&gt;.
 
-OSSL_ENCODER_properties() returns the property definition associated
+OSSL_ENCODER_get0_properties() returns the property definition associated
 with the given I&lt;encoder&gt;.
 
 OSSL_ENCODER_is_a() checks if I&lt;encoder&gt; is an implementation of an
 algorithm that's identifiable with I&lt;name&gt;.
 
-OSSL_ENCODER_number() returns the internal dynamic number assigned to
+OSSL_ENCODER_get_number() returns the internal dynamic number assigned to
 the given I&lt;encoder&gt;.
 
-OSSL_ENCODER_number() returns the name used to fetch the given I&lt;encoder&gt;.
+OSSL_ENCODER_get_number() returns the name used to fetch the given I&lt;encoder&gt;.
 
-OSSL_ENCODER_description() returns a description of the I&lt;loader&gt;, meant
+OSSL_ENCODER_get0_description() returns a description of the I&lt;loader&gt;, meant
 for display and human consumption.  The description is at the discretion of the
 I&lt;loader&gt; implementation.
 
@@ -107,24 +107,24 @@ OSSL_ENCODER_up_ref() returns 1 on success, or 0 on error.
 
 OSSL_ENCODER_free() doesn't return any value.
 
-OSSL_ENCODER_provider() returns a pointer to a provider object, or
+OSSL_ENCODER_get0_provider() returns a pointer to a provider object, or
 NULL on error.
 
-OSSL_ENCODER_properties() returns a pointer to a property
+OSSL_ENCODER_get0_properties() returns a pointer to a property
 definition string, or NULL on error.
 
 OSSL_ENCODER_is_a() returns 1 of I&lt;encoder&gt; was identifiable,
 otherwise 0.
 
-OSSL_ENCODER_number() returns an integer.
+OSSL_ENCODER_get_number() returns an integer.
 
-OSSL_ENCODER_name() returns the algorithm name from the provided
+OSSL_ENCODER_get0_name() returns the algorithm name from the provided
 implementation for the given I&lt;encoder&gt;. Note that the I&lt;encoder&gt; may have
 multiple synonyms associated with it. In this case the first name from the
 algorithm definition is returned. Ownership of the returned string is retained
 by the I&lt;encoder&gt; object and should not be freed by the caller.
 
-OSSL_ENCODER_description() returns a pointer to a decription, or NULL if
+OSSL_ENCODER_get0_description() returns a pointer to a decription, or NULL if
 there isn't one.
 
 OSSL_ENCODER_names_do_all() returns 1 if the callback was called for all
diff --git a/doc/man3/OSSL_PROVIDER.pod b/doc/man3/OSSL_PROVIDER.pod
index 391084e68e..2b014c4671 100644
--- a/doc/man3/OSSL_PROVIDER.pod
+++ b/doc/man3/OSSL_PROVIDER.pod
@@ -8,7 +8,7 @@ OSSL_PROVIDER_available, OSSL_PROVIDER_do_all,
 OSSL_PROVIDER_gettable_params, OSSL_PROVIDER_get_params,
 OSSL_PROVIDER_query_operation, OSSL_PROVIDER_unquery_operation,
 OSSL_PROVIDER_get0_provider_ctx, OSSL_PROVIDER_get0_dispatch,
-OSSL_PROVIDER_add_builtin, OSSL_PROVIDER_name, OSSL_PROVIDER_get_capabilities,
+OSSL_PROVIDER_add_builtin, OSSL_PROVIDER_get0_name, OSSL_PROVIDER_get_capabilities,
 OSSL_PROVIDER_self_test
 - provider routines
 
@@ -45,7 +45,7 @@ OSSL_PROVIDER_self_test
  int OSSL_PROVIDER_add_builtin(OSSL_LIB_CTX *libctx, const char *name,
                                ossl_provider_init_fn *init_fn);
 
- const char *OSSL_PROVIDER_name(const OSSL_PROVIDER *prov);
+ const char *OSSL_PROVIDER_get0_name(const OSSL_PROVIDER *prov);
 
  int OSSL_PROVIDER_get_capabilities(const OSSL_PROVIDER *prov,
                                     const char *capability,
@@ -140,7 +140,7 @@ If it is permissible to cache references to this array then I&lt;*no_store&gt; is set
 to 0 or 1 otherwise. If the array is not cacheable then it is assumed to
 have a short lifetime.
 
-OSSL_PROVIDER_name() returns the name of the given provider.
+OSSL_PROVIDER_get0_name() returns the name of the given provider.
 
 OSSL_PROVIDER_get_capabilities() provides information about the capabilities
 supported by the provider specified in I&lt;prov&gt; with the capability name
diff --git a/doc/man3/OSSL_STORE_LOADER.pod b/doc/man3/OSSL_STORE_LOADER.pod
index 7413104079..1d790fa6d7 100644
--- a/doc/man3/OSSL_STORE_LOADER.pod
+++ b/doc/man3/OSSL_STORE_LOADER.pod
@@ -6,11 +6,11 @@ OSSL_STORE_LOADER,
 OSSL_STORE_LOADER_fetch,
 OSSL_STORE_LOADER_up_ref,
 OSSL_STORE_LOADER_free,
-OSSL_STORE_LOADER_provider,
-OSSL_STORE_LOADER_properties,
+OSSL_STORE_LOADER_get0_provider,
+OSSL_STORE_LOADER_get0_properties,
 OSSL_STORE_LOADER_is_a,
-OSSL_STORE_LOADER_number,
-OSSL_STORE_LOADER_description,
+OSSL_STORE_LOADER_get_number,
+OSSL_STORE_LOADER_get0_description,
 OSSL_STORE_LOADER_do_all_provided,
 OSSL_STORE_LOADER_names_do_all,
 OSSL_STORE_LOADER_CTX, OSSL_STORE_LOADER_new,
@@ -39,11 +39,11 @@ unregister STORE loaders for different URI schemes
                                             const char *properties);
  int OSSL_STORE_LOADER_up_ref(OSSL_STORE_LOADER *loader);
  void OSSL_STORE_LOADER_free(OSSL_STORE_LOADER *loader);
- const OSSL_PROVIDER *OSSL_STORE_LOADER_provider(const OSSL_STORE_LOADER *
+ const OSSL_PROVIDER *OSSL_STORE_LOADER_get0_provider(const OSSL_STORE_LOADER *
                                                  loader);
- const char *OSSL_STORE_LOADER_properties(const OSSL_STORE_LOADER *loader);
- int OSSL_STORE_LOADER_number(const OSSL_STORE_LOADER *loader);
- const char *OSSL_STORE_LOADER_description(const OSSL_STORE_LOADER *loader);
+ const char *OSSL_STORE_LOADER_get0_properties(const OSSL_STORE_LOADER *loader);
+ int OSSL_STORE_LOADER_get_number(const OSSL_STORE_LOADER *loader);
+ const char *OSSL_STORE_LOADER_get0_description(const OSSL_STORE_LOADER *loader);
  int OSSL_STORE_LOADER_is_a(const OSSL_STORE_LOADER *loader,
                             const char *scheme);
  void OSSL_STORE_LOADER_do_all_provided(OSSL_LIB_CTX *libctx,
@@ -129,19 +129,19 @@ I&lt;loader&gt;.
 OSSL_STORE_LOADER_free() decrements the reference count for the given
 I&lt;loader&gt;, and when the count reaches zero, frees it.
 
-OSSL_STORE_LOADER_provider() returns the provider of the given
+OSSL_STORE_LOADER_get0_provider() returns the provider of the given
 I&lt;loader&gt;.
 
-OSSL_STORE_LOADER_properties() returns the property definition associated
+OSSL_STORE_LOADER_get0_properties() returns the property definition associated
 with the given I&lt;loader&gt;.
 
 OSSL_STORE_LOADER_is_a() checks if I&lt;loader&gt; is an implementation
 of an algorithm that's identifiable with I&lt;scheme&gt;.
 
-OSSL_STORE_LOADER_number() returns the internal dynamic number assigned
+OSSL_STORE_LOADER_get_number() returns the internal dynamic number assigned
 to the given I&lt;loader&gt;.
 
-OSSL_STORE_LOADER_description() returns a description of the I&lt;loader&gt;, meant
+OSSL_STORE_LOADER_get0_description() returns a description of the I&lt;loader&gt;, meant
 for display and human consumption.  The description is at the discretion of the
 I&lt;loader&gt; implementation.
 
@@ -323,18 +323,18 @@ names. A return value of 0 means that the callback was not called for any names.
 
 OSSL_STORE_LOADER_free() doesn't return any value.
 
-OSSL_STORE_LOADER_provider() returns a pointer to a provider object, or
+OSSL_STORE_LOADER_get0_provider() returns a pointer to a provider object, or
 NULL on error.
 
-OSSL_STORE_LOADER_properties() returns a pointer to a property
+OSSL_STORE_LOADER_get0_properties() returns a pointer to a property
 definition string, or NULL on error.
 
 OSSL_STORE_LOADER_is_a() returns 1 if I&lt;loader&gt; was identifiable,
 otherwise 0.
 
-OSSL_STORE_LOADER_number() returns an integer.
+OSSL_STORE_LOADER_get_number() returns an integer.
 
-OSSL_STORE_LOADER_description() returns a pointer to a decription, or NULL if
+OSSL_STORE_LOADER_get0_description() returns a pointer to a decription, or NULL if
 there isn't one.
 
 The functions with the types B&lt;OSSL_STORE_open_fn&gt;,
@@ -365,9 +365,9 @@ L&lt;provider-storemgmt(7)&gt;
 =head1 HISTORY
 
 OSSL_STORE_LOADER_fetch(), OSSL_STORE_LOADER_up_ref(),
-OSSL_STORE_LOADER_free(), OSSL_STORE_LOADER_provider(),
-OSSL_STORE_LOADER_properties(), OSSL_STORE_LOADER_is_a(),
-OSSL_STORE_LOADER_number(), OSSL_STORE_LOADER_do_all_provided() and
+OSSL_STORE_LOADER_free(), OSSL_STORE_LOADER_get0_provider(),
+OSSL_STORE_LOADER_get0_properties(), OSSL_STORE_LOADER_is_a(),
+OSSL_STORE_LOADER_get_number(), OSSL_STORE_LOADER_do_all_provided() and
 OSSL_STORE_LOADER_names_do_all() were added in OpenSSL 3.0.
 
 OSSL_STORE_open_ex_fn() was added in OpenSSL 3.0.
diff --git a/doc/man3/PEM_read_bio_PrivateKey.pod b/doc/man3/PEM_read_bio_PrivateKey.pod
index c053d03a21..9df61892fd 100644
--- a/doc/man3/PEM_read_bio_PrivateKey.pod
+++ b/doc/man3/PEM_read_bio_PrivateKey.pod
@@ -420,8 +420,8 @@ The pseudo code to derive the key would look similar to:
  EVP_CIPHER* cipher = EVP_des_ede3_cbc();
  EVP_MD* md = EVP_md5();
 
- unsigned int nkey = EVP_CIPHER_key_length(cipher);
- unsigned int niv = EVP_CIPHER_iv_length(cipher);
+ unsigned int nkey = EVP_CIPHER_get_key_length(cipher);
+ unsigned int niv = EVP_CIPHER_get_iv_length(cipher);
  unsigned char key[nkey];
  unsigned char iv[niv];
 
diff --git a/doc/man3/RSA_size.pod b/doc/man3/RSA_size.pod
index 6e3451f22c..bed88106e2 100644
--- a/doc/man3/RSA_size.pod
+++ b/doc/man3/RSA_size.pod
@@ -25,8 +25,8 @@ RSA_bits() returns the number of significant bits.
 B&lt;rsa&gt; and B&lt;rsa-E&lt;gt&gt;n&gt; must not be B&lt;NULL&gt;.
 
 The remaining functions described on this page are deprecated.
-Applications should instead use L&lt;EVP_PKEY_size(3)&gt;, L&lt;EVP_PKEY_bits(3)&gt;
-and L&lt;EVP_PKEY_security_bits(3)&gt;.
+Applications should instead use L&lt;EVP_PKEY_get_size(3)&gt;, L&lt;EVP_PKEY_get_bits(3)&gt;
+and L&lt;EVP_PKEY_get_security_bits(3)&gt;.
 
 RSA_size() returns the RSA modulus size in bytes. It can be used to
 determine how much memory must be allocated for an RSA encrypted
diff --git a/doc/man7/EVP_MD-common.pod b/doc/man7/EVP_MD-common.pod
index 58d8ed5641..4e0dbb6cd4 100644
--- a/doc/man7/EVP_MD-common.pod
+++ b/doc/man7/EVP_MD-common.pod
@@ -18,14 +18,14 @@ The digest block size.
 The length of the &quot;blocksize&quot; parameter should not exceed that of a
 B&lt;size_t&gt;.
 
-This value can also be retrieved with L&lt;EVP_MD_block_size(3)&gt;.
+This value can also be retrieved with L&lt;EVP_MD_get_block_size(3)&gt;.
 
 =item &quot;size&quot; (B&lt;OSSL_DIGEST_PARAM_SIZE&gt;) &lt;unsigned integer&gt;
 
 The digest output size.
 The length of the &quot;size&quot; parameter should not exceed that of a B&lt;size_t&gt;.
 
-This value can also be retrieved with L&lt;EVP_MD_size(3)&gt;.
+This value can also be retrieved with L&lt;EVP_MD_get_size(3)&gt;.
 
 =item &quot;flags&quot; (B&lt;OSSL_DIGEST_PARAM_FLAGS&gt;) &lt;unsigned integer&gt;
 
@@ -42,7 +42,7 @@ EVP_MD_FLAG_FIPS isn't relevant any more.
 
 =end comment
 
-This value can also be retrieved with L&lt;EVP_MD_flags(3)&gt;.
+This value can also be retrieved with L&lt;EVP_MD_get_flags(3)&gt;.
 
 =back
 
diff --git a/doc/man7/crypto.pod b/doc/man7/crypto.pod
index b45404cce0..78fb8f8f37 100644
--- a/doc/man7/crypto.pod
+++ b/doc/man7/crypto.pod
@@ -390,7 +390,7 @@ encryption/decryption, signatures, message authentication codes, etc.
          goto err;
 
      /* Allocate the output buffer */
-     outdigest = OPENSSL_malloc(EVP_MD_size(sha256));
+     outdigest = OPENSSL_malloc(EVP_MD_get_size(sha256));
      if (outdigest == NULL)
          goto err;
 
diff --git a/doc/man7/fips_module.pod b/doc/man7/fips_module.pod
index 3fdbfc0386..8133f01eaf 100644
--- a/doc/man7/fips_module.pod
+++ b/doc/man7/fips_module.pod
@@ -445,8 +445,10 @@ provider that implements it. The process is similar for all algorithms. Here the
 example of a digest is used.
 
 To go from an B&lt;EVP_MD_CTX&gt; to an B&lt;EVP_MD&gt;, use L&lt;EVP_MD_CTX_md(3)&gt; .
-To go from the B&lt;EVP_MD&gt; to its B&lt;OSSL_PROVIDER&gt;, use L&lt;EVP_MD_provider(3)&gt;.
-To extract the name from the B&lt;OSSL_PROVIDER&gt;, use L&lt;OSSL_PROVIDER_name(3)&gt;.
+To go from the B&lt;EVP_MD&gt; to its B&lt;OSSL_PROVIDER&gt;,
+use L&lt;EVP_MD_get0_provider(3)&gt;.
+To extract the name from the B&lt;OSSL_PROVIDER&gt;, use
+L&lt;OSSL_PROVIDER_get0_name(3)&gt;.
 
 =head1 SEE ALSO
 
diff --git a/doc/man7/migration_guide.pod b/doc/man7/migration_guide.pod
index b230eb7839..e2d21a9540 100644
--- a/doc/man7/migration_guide.pod
+++ b/doc/man7/migration_guide.pod
@@ -1203,7 +1203,8 @@ Algorithms for &quot;DESX-CBC&quot;, &quot;DES-ECB&quot;, &quot;DES-CBC&quot;, &quot;DES-OFB&quot;, &quot;DES-CFB&quot;,
 
 DH_bits(), DH_security_bits(), DH_size()
 
-Use L&lt;EVP_PKEY_bits(3)&gt;, L&lt;EVP_PKEY_security_bits(3)&gt; and L&lt;EVP_PKEY_size(3)&gt;.
+Use L&lt;EVP_PKEY_get_bits(3)&gt;, L&lt;EVP_PKEY_get_security_bits(3)&gt; and
+L&lt;EVP_PKEY_get_size(3)&gt;.
 
 =item -
 
@@ -1284,7 +1285,8 @@ See L&lt;/Deprecated low-level key parameter setters&gt;
 
 DSA_bits(), DSA_security_bits(), DSA_size()
 
-Use L&lt;EVP_PKEY_bits(3)&gt;, L&lt;EVP_PKEY_security_bits(3)&gt; and L&lt;EVP_PKEY_size(3)&gt;.
+Use L&lt;EVP_PKEY_get_bits(3)&gt;, L&lt;EVP_PKEY_get_security_bits(3)&gt; and
+L&lt;EVP_PKEY_get_size(3)&gt;.
 
 =item -
 
@@ -1376,7 +1378,7 @@ See L&lt;/Deprecated low-level signing functions&gt;.
 
 ECDSA_size()
 
-Applications should use L&lt;EVP_PKEY_size(3)&gt;.
+Applications should use L&lt;EVP_PKEY_get_size(3)&gt;.
 
 =item -
 
@@ -1900,7 +1902,8 @@ The RIPE algorithm has been moved to the L&lt;Legacy Provider|/Legacy Algorithms&gt;.
 
 RSA_bits(), RSA_security_bits(), RSA_size()
 
-Use L&lt;EVP_PKEY_bits(3)&gt;, L&lt;EVP_PKEY_security_bits(3)&gt; and L&lt;EVP_PKEY_size(3)&gt;.
+Use L&lt;EVP_PKEY_get_bits(3)&gt;, L&lt;EVP_PKEY_get_security_bits(3)&gt; and
+L&lt;EVP_PKEY_get_size(3)&gt;.
 
 =item -
 
diff --git a/engines/e_afalg.c b/engines/e_afalg.c
index db73873911..93b3b3f02e 100644
--- a/engines/e_afalg.c
+++ b/engines/e_afalg.c
@@ -564,7 +564,7 @@ static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         return 0;
     }
 
-    ciphertype = EVP_CIPHER_CTX_nid(ctx);
+    ciphertype = EVP_CIPHER_CTX_get_nid(ctx);
     switch (ciphertype) {
     case NID_aes_128_cbc:
     case NID_aes_192_cbc:
@@ -577,9 +577,9 @@ static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         return 0;
     }
 
-    if (ALG_AES_IV_LEN != EVP_CIPHER_CTX_iv_length(ctx)) {
+    if (ALG_AES_IV_LEN != EVP_CIPHER_CTX_get_iv_length(ctx)) {
         ALG_WARN(&quot;%s(%d): Unsupported IV length :%d\n&quot;, __FILE__, __LINE__,
-                 EVP_CIPHER_CTX_iv_length(ctx));
+                 EVP_CIPHER_CTX_get_iv_length(ctx));
         return 0;
     }
 
@@ -589,7 +589,7 @@ static int afalg_cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         return 0;
 
 
-    ret = afalg_set_key(actx, key, EVP_CIPHER_CTX_key_length(ctx));
+    ret = afalg_set_key(actx, key, EVP_CIPHER_CTX_get_key_length(ctx));
     if (ret &lt; 1)
         goto err;
 
@@ -635,14 +635,14 @@ static int afalg_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
      * set iv now for decrypt operation as the input buffer can be
      * overwritten for inplace operation where in = out.
      */
-    if (EVP_CIPHER_CTX_encrypting(ctx) == 0) {
+    if (EVP_CIPHER_CTX_is_encrypting(ctx) == 0) {
         memcpy(nxtiv, in + (inl - ALG_AES_IV_LEN), ALG_AES_IV_LEN);
     }
 
     /* Send input data to kernel space */
     ret = afalg_start_cipher_sk(actx, (unsigned char *)in, inl,
                                 EVP_CIPHER_CTX_iv(ctx),
-                                EVP_CIPHER_CTX_encrypting(ctx));
+                                EVP_CIPHER_CTX_is_encrypting(ctx));
     if (ret &lt; 1) {
         return 0;
     }
@@ -652,7 +652,7 @@ static int afalg_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     if (ret &lt; 1)
         return 0;
 
-    if (EVP_CIPHER_CTX_encrypting(ctx)) {
+    if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
         memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), out + (inl - ALG_AES_IV_LEN),
                ALG_AES_IV_LEN);
     } else {
diff --git a/engines/e_dasync.c b/engines/e_dasync.c
index 4eb50d055c..9866459103 100644
--- a/engines/e_dasync.c
+++ b/engines/e_dasync.c
@@ -96,7 +96,7 @@ static int dasync_digest_nids(const int **nids)
     if (!init) {
         const EVP_MD *md;
         if ((md = dasync_sha1()) != NULL)
-            digest_nids[pos++] = EVP_MD_type(md);
+            digest_nids[pos++] = EVP_MD_get_type(md);
         digest_nids[pos] = 0;
         init = 1;
     }
@@ -627,7 +627,7 @@ static int dasync_cipher_ctrl_helper(EVP_CIPHER_CTX *ctx, int type, int arg,
 
             len = p[arg - 2] &lt;&lt; 8 | p[arg - 1];
 
-            if (EVP_CIPHER_CTX_encrypting(ctx)) {
+            if (EVP_CIPHER_CTX_is_encrypting(ctx)) {
                 if ((p[arg - 4] &lt;&lt; 8 | p[arg - 3]) &gt;= TLS1_1_VERSION) {
                     if (len &lt; AES_BLOCK_SIZE)
                         return 0;
diff --git a/engines/e_devcrypto.c b/engines/e_devcrypto.c
index d279b601f5..fa01317db5 100644
--- a/engines/e_devcrypto.c
+++ b/engines/e_devcrypto.c
@@ -207,7 +207,7 @@ static int cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     struct cipher_ctx *cipher_ctx =
         (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
     const struct cipher_data_st *cipher_d =
-        get_cipher_data(EVP_CIPHER_CTX_nid(ctx));
+        get_cipher_data(EVP_CIPHER_CTX_get_nid(ctx));
     int ret;
 
     /* cleanup a previous session */
@@ -260,12 +260,12 @@ static int cipher_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 #if !defined(COP_FLAG_WRITE_IV)
     cryp.flags = 0;
 
-    ivlen = EVP_CIPHER_CTX_iv_length(ctx);
+    ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);
     if (ivlen &gt; 0)
         switch (cipher_ctx-&gt;mode) {
         case EVP_CIPH_CBC_MODE:
             assert(inl &gt;= ivlen);
-            if (!EVP_CIPHER_CTX_encrypting(ctx)) {
+            if (!EVP_CIPHER_CTX_is_encrypting(ctx)) {
                 ivptr = in + inl - ivlen;
                 memcpy(saved_iv, ivptr, ivlen);
             }
@@ -291,7 +291,7 @@ static int cipher_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         switch (cipher_ctx-&gt;mode) {
         case EVP_CIPH_CBC_MODE:
             assert(inl &gt;= ivlen);
-            if (EVP_CIPHER_CTX_encrypting(ctx))
+            if (EVP_CIPHER_CTX_is_encrypting(ctx))
                 ivptr = out + inl - ivlen;
             else
                 ivptr = saved_iv;
@@ -610,7 +610,7 @@ static int cryptodev_select_cipher_cb(const char *str, int len, void *usr)
     EVP = EVP_get_cipherbyname(name);
     if (EVP == NULL)
         fprintf(stderr, &quot;devcrypto: unknown cipher %s\n&quot;, name);
-    else if ((i = find_cipher_data_index(EVP_CIPHER_nid(EVP))) != (size_t)-1)
+    else if ((i = find_cipher_data_index(EVP_CIPHER_get_nid(EVP))) != (size_t)-1)
         cipher_list[i] = 1;
     else
         fprintf(stderr, &quot;devcrypto: cipher %s not available\n&quot;, name);
@@ -746,9 +746,9 @@ static const struct digest_data_st *get_digest_data(int nid)
 static int digest_init(EVP_MD_CTX *ctx)
 {
     struct digest_ctx *digest_ctx =
-        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+        (struct digest_ctx *)EVP_MD_CTX_get0_md_data(ctx);
     const struct digest_data_st *digest_d =
-        get_digest_data(EVP_MD_CTX_type(ctx));
+        get_digest_data(EVP_MD_CTX_get_type(ctx));
 
     digest_ctx-&gt;init_called = 1;
 
@@ -779,7 +779,7 @@ static int digest_op(struct digest_ctx *ctx, const void *src, size_t srclen,
 static int digest_update(EVP_MD_CTX *ctx, const void *data, size_t count)
 {
     struct digest_ctx *digest_ctx =
-        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+        (struct digest_ctx *)EVP_MD_CTX_get0_md_data(ctx);
 
     if (count == 0)
         return 1;
@@ -801,13 +801,13 @@ static int digest_update(EVP_MD_CTX *ctx, const void *data, size_t count)
 static int digest_final(EVP_MD_CTX *ctx, unsigned char *md)
 {
     struct digest_ctx *digest_ctx =
-        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+        (struct digest_ctx *)EVP_MD_CTX_get0_md_data(ctx);
 
     if (md == NULL || digest_ctx == NULL)
         return 0;
 
     if (EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_ONESHOT)) {
-        memcpy(md, digest_ctx-&gt;digest_res, EVP_MD_CTX_size(ctx));
+        memcpy(md, digest_ctx-&gt;digest_res, EVP_MD_CTX_get_size(ctx));
     } else if (digest_op(digest_ctx, NULL, 0, md, COP_FLAG_FINAL) &lt; 0) {
         ERR_raise_data(ERR_LIB_SYS, errno, &quot;calling ioctl()&quot;);
         return 0;
@@ -819,9 +819,9 @@ static int digest_final(EVP_MD_CTX *ctx, unsigned char *md)
 static int digest_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from)
 {
     struct digest_ctx *digest_from =
-        (struct digest_ctx *)EVP_MD_CTX_md_data(from);
+        (struct digest_ctx *)EVP_MD_CTX_get0_md_data(from);
     struct digest_ctx *digest_to =
-        (struct digest_ctx *)EVP_MD_CTX_md_data(to);
+        (struct digest_ctx *)EVP_MD_CTX_get0_md_data(to);
     struct cphash_op cphash;
 
     if (digest_from == NULL || digest_from-&gt;init_called != 1)
@@ -844,7 +844,7 @@ static int digest_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from)
 static int digest_cleanup(EVP_MD_CTX *ctx)
 {
     struct digest_ctx *digest_ctx =
-        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+        (struct digest_ctx *)EVP_MD_CTX_get0_md_data(ctx);
 
     if (digest_ctx == NULL)
         return 1;
@@ -1040,7 +1040,7 @@ static int cryptodev_select_digest_cb(const char *str, int len, void *usr)
     EVP = EVP_get_digestbyname(name);
     if (EVP == NULL)
         fprintf(stderr, &quot;devcrypto: unknown digest %s\n&quot;, name);
-    else if ((i = find_digest_data_index(EVP_MD_type(EVP))) != (size_t)-1)
+    else if ((i = find_digest_data_index(EVP_MD_get_type(EVP))) != (size_t)-1)
         digest_list[i] = 1;
     else
         fprintf(stderr, &quot;devcrypto: digest %s not available\n&quot;, name);
diff --git a/engines/e_ossltest.c b/engines/e_ossltest.c
index 15a7d75f1e..57dfb13ba1 100644
--- a/engines/e_ossltest.c
+++ b/engines/e_ossltest.c
@@ -226,15 +226,15 @@ static int ossltest_digest_nids(const int **nids)
     if (!init) {
         const EVP_MD *md;
         if ((md = digest_md5()) != NULL)
-            digest_nids[pos++] = EVP_MD_type(md);
+            digest_nids[pos++] = EVP_MD_get_type(md);
         if ((md = digest_sha1()) != NULL)
-            digest_nids[pos++] = EVP_MD_type(md);
+            digest_nids[pos++] = EVP_MD_get_type(md);
         if ((md = digest_sha256()) != NULL)
-            digest_nids[pos++] = EVP_MD_type(md);
+            digest_nids[pos++] = EVP_MD_get_type(md);
         if ((md = digest_sha384()) != NULL)
-            digest_nids[pos++] = EVP_MD_type(md);
+            digest_nids[pos++] = EVP_MD_get_type(md);
         if ((md = digest_sha512()) != NULL)
-            digest_nids[pos++] = EVP_MD_type(md);
+            digest_nids[pos++] = EVP_MD_get_type(md);
         digest_nids[pos] = 0;
         init = 1;
     }
@@ -279,7 +279,7 @@ static const EVP_CIPHER *ossltest_aes_128_cbc(void)
             || !EVP_CIPHER_meth_set_do_cipher(_hidden_aes_128_cbc,
                                               ossltest_aes128_cbc_cipher)
             || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_128_cbc,
-                                                  EVP_CIPHER_impl_ctx_size(EVP_aes_128_cbc())))) {
+                    EVP_CIPHER_impl_ctx_size(EVP_aes_128_cbc())))) {
         EVP_CIPHER_meth_free(_hidden_aes_128_cbc);
         _hidden_aes_128_cbc = NULL;
     }
@@ -308,7 +308,7 @@ static const EVP_CIPHER *ossltest_aes_128_gcm(void)
             || !EVP_CIPHER_meth_set_ctrl(_hidden_aes_128_gcm,
                                               ossltest_aes128_gcm_ctrl)
             || !EVP_CIPHER_meth_set_impl_ctx_size(_hidden_aes_128_gcm,
-                              EVP_CIPHER_impl_ctx_size(EVP_aes_128_gcm())))) {
+                    EVP_CIPHER_impl_ctx_size(EVP_aes_128_gcm())))) {
         EVP_CIPHER_meth_free(_hidden_aes_128_gcm);
         _hidden_aes_128_gcm = NULL;
     }
diff --git a/engines/e_padlock.c b/engines/e_padlock.c
index 572ff90935..a22fc476e6 100644
--- a/engines/e_padlock.c
+++ b/engines/e_padlock.c
@@ -324,13 +324,13 @@ padlock_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out_arg,
     struct padlock_cipher_data *cdata = ALIGNED_CIPHER_DATA(ctx);
     size_t chunk;
 
-    if ((chunk = EVP_CIPHER_CTX_num(ctx))) {   /* borrow chunk variable */
+    if ((chunk = EVP_CIPHER_CTX_get_num(ctx))) {   /* borrow chunk variable */
         unsigned char *ivp = EVP_CIPHER_CTX_iv_noconst(ctx);
 
         if (chunk &gt;= AES_BLOCK_SIZE)
             return 0;           /* bogus value */
 
-        if (EVP_CIPHER_CTX_encrypting(ctx))
+        if (EVP_CIPHER_CTX_is_encrypting(ctx))
             while (chunk &lt; AES_BLOCK_SIZE &amp;&amp; nbytes != 0) {
                 ivp[chunk] = *(out_arg++) = *(in_arg++) ^ ivp[chunk];
                 chunk++, nbytes--;
@@ -398,7 +398,7 @@ padlock_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out_arg,
     /*
      * ctx-&gt;num is maintained in byte-oriented modes, such as CFB and OFB...
      */
-    if ((chunk = EVP_CIPHER_CTX_num(ctx))) {   /* borrow chunk variable */
+    if ((chunk = EVP_CIPHER_CTX_get_num(ctx))) {   /* borrow chunk variable */
         unsigned char *ivp = EVP_CIPHER_CTX_iv_noconst(ctx);
 
         if (chunk &gt;= AES_BLOCK_SIZE)
@@ -457,7 +457,7 @@ padlock_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out_arg,
                    const unsigned char *in_arg, size_t nbytes)
 {
     struct padlock_cipher_data *cdata = ALIGNED_CIPHER_DATA(ctx);
-    unsigned int num = EVP_CIPHER_CTX_num(ctx);
+    unsigned int num = EVP_CIPHER_CTX_get_num(ctx);
 
     CRYPTO_ctr128_encrypt_ctr32(in_arg, out_arg, nbytes,
                                 cdata, EVP_CIPHER_CTX_iv_noconst(ctx),
@@ -600,8 +600,8 @@ padlock_aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                      const unsigned char *iv, int enc)
 {
     struct padlock_cipher_data *cdata;
-    int key_len = EVP_CIPHER_CTX_key_length(ctx) * 8;
-    unsigned long mode = EVP_CIPHER_CTX_mode(ctx);
+    int key_len = EVP_CIPHER_CTX_get_key_length(ctx) * 8;
+    unsigned long mode = EVP_CIPHER_CTX_get_mode(ctx);
 
     if (key == NULL)
         return 0;               /* ERROR */
@@ -613,7 +613,7 @@ padlock_aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     if (mode == EVP_CIPH_OFB_MODE || mode == EVP_CIPH_CTR_MODE)
         cdata-&gt;cword.b.encdec = 0;
     else
-        cdata-&gt;cword.b.encdec = (EVP_CIPHER_CTX_encrypting(ctx) == 0);
+        cdata-&gt;cword.b.encdec = (EVP_CIPHER_CTX_is_encrypting(ctx) == 0);
     cdata-&gt;cword.b.rounds = 10 + (key_len - 128) / 32;
     cdata-&gt;cword.b.ksize = (key_len - 128) / 64;
 
diff --git a/include/crypto/evp.h b/include/crypto/evp.h
index ea61b83469..ce772dbec1 100644
--- a/include/crypto/evp.h
+++ b/include/crypto/evp.h
@@ -371,7 +371,7 @@ struct evp_cipher_st {
 static int cname##_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) \
 {\
         BLOCK_CIPHER_ecb_loop() \
-            cprefix##_ecb_encrypt(in + i, out + i, &amp;EVP_C_DATA(kstruct,ctx)-&gt;ksched, EVP_CIPHER_CTX_encrypting(ctx)); \
+            cprefix##_ecb_encrypt(in + i, out + i, &amp;EVP_C_DATA(kstruct,ctx)-&gt;ksched, EVP_CIPHER_CTX_is_encrypting(ctx)); \
         return 1;\
 }
 
@@ -381,7 +381,7 @@ static int cname##_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const uns
     static int cname##_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, size_t inl) \
 {\
         while(inl&gt;=EVP_MAXCHUNK) {\
-            int num = EVP_CIPHER_CTX_num(ctx);\
+            int num = EVP_CIPHER_CTX_get_num(ctx);\
             cprefix##_ofb##cbits##_encrypt(in, out, (long)EVP_MAXCHUNK, &amp;EVP_C_DATA(kstruct,ctx)-&gt;ksched, ctx-&gt;iv, &amp;num); \
             EVP_CIPHER_CTX_set_num(ctx, num);\
             inl-=EVP_MAXCHUNK;\
@@ -389,7 +389,7 @@ static int cname##_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const uns
             out+=EVP_MAXCHUNK;\
         }\
         if (inl) {\
-            int num = EVP_CIPHER_CTX_num(ctx);\
+            int num = EVP_CIPHER_CTX_get_num(ctx);\
             cprefix##_ofb##cbits##_encrypt(in, out, (long)inl, &amp;EVP_C_DATA(kstruct,ctx)-&gt;ksched, ctx-&gt;iv, &amp;num); \
             EVP_CIPHER_CTX_set_num(ctx, num);\
         }\
@@ -401,13 +401,13 @@ static int cname##_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out, const uns
 {\
         while(inl&gt;=EVP_MAXCHUNK) \
             {\
-            cprefix##_cbc_encrypt(in, out, (long)EVP_MAXCHUNK, &amp;EVP_C_DATA(kstruct,ctx)-&gt;ksched, ctx-&gt;iv, EVP_CIPHER_CTX_encrypting(ctx));\
+            cprefix##_cbc_encrypt(in, out, (long)EVP_MAXCHUNK, &amp;EVP_C_DATA(kstruct,ctx)-&gt;ksched, ctx-&gt;iv, EVP_CIPHER_CTX_is_encrypting(ctx));\
             inl-=EVP_MAXCHUNK;\
             in +=EVP_MAXCHUNK;\
             out+=EVP_MAXCHUNK;\
             }\
         if (inl)\
-            cprefix##_cbc_encrypt(in, out, (long)inl, &amp;EVP_C_DATA(kstruct,ctx)-&gt;ksched, ctx-&gt;iv, EVP_CIPHER_CTX_encrypting(ctx));\
+            cprefix##_cbc_encrypt(in, out, (long)inl, &amp;EVP_C_DATA(kstruct,ctx)-&gt;ksched, ctx-&gt;iv, EVP_CIPHER_CTX_is_encrypting(ctx));\
         return 1;\
 }
 
@@ -419,13 +419,13 @@ static int cname##_cfb##cbits##_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     if (inl &lt; chunk) chunk = inl;\
     while (inl &amp;&amp; inl &gt;= chunk)\
     {\
-        int num = EVP_CIPHER_CTX_num(ctx);\
+        int num = EVP_CIPHER_CTX_get_num(ctx);\
         cprefix##_cfb##cbits##_encrypt(in, out, (long) \
             ((cbits == 1) \
                 &amp;&amp; !EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS) \
                 ? chunk*8 : chunk), \
             &amp;EVP_C_DATA(kstruct, ctx)-&gt;ksched, ctx-&gt;iv,\
-            &amp;num, EVP_CIPHER_CTX_encrypting(ctx));\
+            &amp;num, EVP_CIPHER_CTX_is_encrypting(ctx));\
         EVP_CIPHER_CTX_set_num(ctx, num);\
         inl -= chunk;\
         in += chunk;\
diff --git a/include/internal/packet.h b/include/internal/packet.h
index 108c65aad0..170997db60 100644
--- a/include/internal/packet.h
+++ b/include/internal/packet.h
@@ -800,7 +800,7 @@ int WPACKET_sub_allocate_bytes__(WPACKET *pkt, size_t len,
  * signature may not be known in advance. We can use WPACKET_reserve_bytes() to
  * handle this:
  *
- *  if (!WPACKET_sub_reserve_bytes_u16(&amp;pkt, EVP_PKEY_size(pkey), &amp;sigbytes1)
+ *  if (!WPACKET_sub_reserve_bytes_u16(&amp;pkt, EVP_PKEY_get_size(pkey), &amp;sigbytes1)
  *          || EVP_SignFinal(md_ctx, sigbytes1, &amp;siglen, pkey) &lt;= 0
  *          || !WPACKET_sub_allocate_bytes_u16(&amp;pkt, siglen, &amp;sigbytes2)
  *          || sigbytes1 != sigbytes2)
diff --git a/include/openssl/decoder.h b/include/openssl/decoder.h
index afe4988fdb..a939d0dcb1 100644
--- a/include/openssl/decoder.h
+++ b/include/openssl/decoder.h
@@ -31,11 +31,11 @@ OSSL_DECODER *OSSL_DECODER_fetch(OSSL_LIB_CTX *libctx, const char *name,
 int OSSL_DECODER_up_ref(OSSL_DECODER *encoder);
 void OSSL_DECODER_free(OSSL_DECODER *encoder);
 
-const OSSL_PROVIDER *OSSL_DECODER_provider(const OSSL_DECODER *encoder);
-const char *OSSL_DECODER_properties(const OSSL_DECODER *encoder);
-int OSSL_DECODER_number(const OSSL_DECODER *encoder);
-const char *OSSL_DECODER_name(const OSSL_DECODER *decoder);
-const char *OSSL_DECODER_description(const OSSL_DECODER *decoder);
+const OSSL_PROVIDER *OSSL_DECODER_get0_provider(const OSSL_DECODER *encoder);
+const char *OSSL_DECODER_get0_properties(const OSSL_DECODER *encoder);
+int OSSL_DECODER_get_number(const OSSL_DECODER *encoder);
+const char *OSSL_DECODER_get0_name(const OSSL_DECODER *decoder);
+const char *OSSL_DECODER_get0_description(const OSSL_DECODER *decoder);
 int OSSL_DECODER_is_a(const OSSL_DECODER *encoder, const char *name);
 
 void OSSL_DECODER_do_all_provided(OSSL_LIB_CTX *libctx,
diff --git a/include/openssl/encoder.h b/include/openssl/encoder.h
index 4e2c5fe23c..62560ba3c2 100644
--- a/include/openssl/encoder.h
+++ b/include/openssl/encoder.h
@@ -31,11 +31,11 @@ OSSL_ENCODER *OSSL_ENCODER_fetch(OSSL_LIB_CTX *libctx, const char *name,
 int OSSL_ENCODER_up_ref(OSSL_ENCODER *encoder);
 void OSSL_ENCODER_free(OSSL_ENCODER *encoder);
 
-const OSSL_PROVIDER *OSSL_ENCODER_provider(const OSSL_ENCODER *encoder);
-const char *OSSL_ENCODER_properties(const OSSL_ENCODER *encoder);
-int OSSL_ENCODER_number(const OSSL_ENCODER *encoder);
-const char *OSSL_ENCODER_name(const OSSL_ENCODER *kdf);
-const char *OSSL_ENCODER_description(const OSSL_ENCODER *kdf);
+const OSSL_PROVIDER *OSSL_ENCODER_get0_provider(const OSSL_ENCODER *encoder);
+const char *OSSL_ENCODER_get0_properties(const OSSL_ENCODER *encoder);
+int OSSL_ENCODER_get_number(const OSSL_ENCODER *encoder);
+const char *OSSL_ENCODER_get0_name(const OSSL_ENCODER *kdf);
+const char *OSSL_ENCODER_get0_description(const OSSL_ENCODER *kdf);
 int OSSL_ENCODER_is_a(const OSSL_ENCODER *encoder, const char *name);
 
 void OSSL_ENCODER_do_all_provided(OSSL_LIB_CTX *libctx,
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index ee918104a8..3f5693824c 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -528,20 +528,26 @@ typedef int (EVP_PBE_KEYGEN_EX) (EVP_CIPHER_CTX *ctx, const char *pass,
 # define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))
 # define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))
 
-int EVP_MD_type(const EVP_MD *md);
-# define EVP_MD_nid(e)                   EVP_MD_type(e)
-const char *EVP_MD_name(const EVP_MD *md);
-const char *EVP_MD_description(const EVP_MD *md);
-int EVP_MD_number(const EVP_MD *md);
+int EVP_MD_get_type(const EVP_MD *md);
+# define EVP_MD_type EVP_MD_get_type
+# define EVP_MD_nid EVP_MD_get_type
+const char *EVP_MD_get0_name(const EVP_MD *md);
+# define EVP_MD_name EVP_MD_get0_name
+const char *EVP_MD_get0_description(const EVP_MD *md);
+int EVP_MD_get_number(const EVP_MD *md);
 int EVP_MD_is_a(const EVP_MD *md, const char *name);
 int EVP_MD_names_do_all(const EVP_MD *md,
                         void (*fn)(const char *name, void *data),
                         void *data);
-const OSSL_PROVIDER *EVP_MD_provider(const EVP_MD *md);
-int EVP_MD_pkey_type(const EVP_MD *md);
-int EVP_MD_size(const EVP_MD *md);
-int EVP_MD_block_size(const EVP_MD *md);
-unsigned long EVP_MD_flags(const EVP_MD *md);
+const OSSL_PROVIDER *EVP_MD_get0_provider(const EVP_MD *md);
+int EVP_MD_get_pkey_type(const EVP_MD *md);
+# define EVP_MD_pkey_type EVP_MD_get_pkey_type
+int EVP_MD_get_size(const EVP_MD *md);
+# define EVP_MD_size EVP_MD_get_size
+int EVP_MD_get_block_size(const EVP_MD *md);
+# define EVP_MD_block_size EVP_MD_get_block_size
+unsigned long EVP_MD_get_flags(const EVP_MD *md);
+# define EVP_MD_flags EVP_MD_get_flags
 
 const EVP_MD *EVP_MD_CTX_get0_md(const EVP_MD_CTX *ctx);
 EVP_MD *EVP_MD_CTX_get1_md(EVP_MD_CTX *ctx);
@@ -556,29 +562,43 @@ void EVP_MD_CTX_set_update_fn(EVP_MD_CTX *ctx,
                               int (*update) (EVP_MD_CTX *ctx,
                                              const void *data, size_t count));
 # endif
-# define EVP_MD_CTX_name(e)            EVP_MD_name(EVP_MD_CTX_get0_md(e))
-# define EVP_MD_CTX_size(e)            EVP_MD_size(EVP_MD_CTX_get0_md(e))
-# define EVP_MD_CTX_block_size(e)      EVP_MD_block_size(EVP_MD_CTX_get0_md(e))
-# define EVP_MD_CTX_type(e)            EVP_MD_type(EVP_MD_CTX_get0_md(e))
-EVP_PKEY_CTX *EVP_MD_CTX_pkey_ctx(const EVP_MD_CTX *ctx);
+# define EVP_MD_CTX_get0_name(e)       EVP_MD_get0_name(EVP_MD_CTX_get0_md(e))
+# define EVP_MD_CTX_get_size(e)        EVP_MD_get_size(EVP_MD_CTX_get0_md(e))
+# define EVP_MD_CTX_size               EVP_MD_CTX_get_size
+# define EVP_MD_CTX_get_block_size(e)  EVP_MD_get_block_size(EVP_MD_CTX_get0_md(e))
+# define EVP_MD_CTX_block_size EVP_MD_CTX_get_block_size
+# define EVP_MD_CTX_get_type(e)            EVP_MD_get_type(EVP_MD_CTX_get0_md(e))
+# define EVP_MD_CTX_type EVP_MD_CTX_get_type
+EVP_PKEY_CTX *EVP_MD_CTX_get_pkey_ctx(const EVP_MD_CTX *ctx);
+# define EVP_MD_CTX_pkey_ctx EVP_MD_CTX_get_pkey_ctx
 void EVP_MD_CTX_set_pkey_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pctx);
-void *EVP_MD_CTX_md_data(const EVP_MD_CTX *ctx);
-
-int EVP_CIPHER_nid(const EVP_CIPHER *cipher);
-const char *EVP_CIPHER_name(const EVP_CIPHER *cipher);
-const char *EVP_CIPHER_description(const EVP_CIPHER *cipher);
-int EVP_CIPHER_number(const EVP_CIPHER *cipher);
+void *EVP_MD_CTX_get0_md_data(const EVP_MD_CTX *ctx);
+# define EVP_MD_CTX_md_data EVP_MD_CTX_get0_md_data
+
+int EVP_CIPHER_get_nid(const EVP_CIPHER *cipher);
+# define EVP_CIPHER_nid EVP_CIPHER_get_nid
+const char *EVP_CIPHER_get0_name(const EVP_CIPHER *cipher);
+# define EVP_CIPHER_name EVP_CIPHER_get0_name
+const char *EVP_CIPHER_get0_description(const EVP_CIPHER *cipher);
+int EVP_CIPHER_get_number(const EVP_CIPHER *cipher);
 int EVP_CIPHER_is_a(const EVP_CIPHER *cipher, const char *name);
 int EVP_CIPHER_names_do_all(const EVP_CIPHER *cipher,
                             void (*fn)(const char *name, void *data),
                             void *data);
-const OSSL_PROVIDER *EVP_CIPHER_provider(const EVP_CIPHER *cipher);
-int EVP_CIPHER_block_size(const EVP_CIPHER *cipher);
+const OSSL_PROVIDER *EVP_CIPHER_get0_provider(const EVP_CIPHER *cipher);
+int EVP_CIPHER_get_block_size(const EVP_CIPHER *cipher);
+# define EVP_CIPHER_block_size EVP_CIPHER_get_block_size
 int EVP_CIPHER_impl_ctx_size(const EVP_CIPHER *cipher);
-int EVP_CIPHER_key_length(const EVP_CIPHER *cipher);
-int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher);
-unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher);
-int EVP_CIPHER_mode(const EVP_CIPHER *cipher);
+int EVP_CIPHER_get_key_length(const EVP_CIPHER *cipher);
+# define EVP_CIPHER_key_length EVP_CIPHER_get_key_length
+int EVP_CIPHER_get_iv_length(const EVP_CIPHER *cipher);
+# define EVP_CIPHER_iv_length EVP_CIPHER_get_iv_length
+unsigned long EVP_CIPHER_get_flags(const EVP_CIPHER *cipher);
+# define EVP_CIPHER_flags EVP_CIPHER_get_flags
+int EVP_CIPHER_get_mode(const EVP_CIPHER *cipher);
+# define EVP_CIPHER_mode EVP_CIPHER_get_mode
+int EVP_CIPHER_get_type(const EVP_CIPHER *cipher);
+# define EVP_CIPHER_type EVP_CIPHER_get_type
 EVP_CIPHER *EVP_CIPHER_fetch(OSSL_LIB_CTX *ctx, const char *algorithm,
                              const char *properties);
 int EVP_CIPHER_up_ref(EVP_CIPHER *cipher);
@@ -586,12 +606,18 @@ void EVP_CIPHER_free(EVP_CIPHER *cipher);
 
 const EVP_CIPHER *EVP_CIPHER_CTX_get0_cipher(const EVP_CIPHER_CTX *ctx);
 EVP_CIPHER *EVP_CIPHER_CTX_get1_cipher(EVP_CIPHER_CTX *ctx);
-int EVP_CIPHER_CTX_encrypting(const EVP_CIPHER_CTX *ctx);
-int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);
-int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);
-int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);
-int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);
-int EVP_CIPHER_CTX_tag_length(const EVP_CIPHER_CTX *ctx);
+int EVP_CIPHER_CTX_is_encrypting(const EVP_CIPHER_CTX *ctx);
+# define EVP_CIPHER_CTX_encrypting EVP_CIPHER_CTX_is_encrypting
+int EVP_CIPHER_CTX_get_nid(const EVP_CIPHER_CTX *ctx);
+# define EVP_CIPHER_CTX_nid EVP_CIPHER_CTX_get_nid
+int EVP_CIPHER_CTX_get_block_size(const EVP_CIPHER_CTX *ctx);
+# define EVP_CIPHER_CTX_block_size EVP_CIPHER_CTX_get_block_size
+int EVP_CIPHER_CTX_get_key_length(const EVP_CIPHER_CTX *ctx);
+# define EVP_CIPHER_CTX_key_length EVP_CIPHER_CTX_get_key_length
+int EVP_CIPHER_CTX_get_iv_length(const EVP_CIPHER_CTX *ctx);
+# define EVP_CIPHER_CTX_iv_length EVP_CIPHER_CTX_get_iv_length
+int EVP_CIPHER_CTX_get_tag_length(const EVP_CIPHER_CTX *ctx);
+# define EVP_CIPHER_CTX_tag_length EVP_CIPHER_CTX_get_tag_length
 # ifndef OPENSSL_NO_DEPRECATED_3_0
 const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
 OSSL_DEPRECATEDIN_3_0 const unsigned char *EVP_CIPHER_CTX_iv(const EVP_CIPHER_CTX *ctx);
@@ -601,19 +627,22 @@ OSSL_DEPRECATEDIN_3_0 unsigned char *EVP_CIPHER_CTX_iv_noconst(EVP_CIPHER_CTX *c
 int EVP_CIPHER_CTX_get_updated_iv(EVP_CIPHER_CTX *ctx, void *buf, size_t len);
 int EVP_CIPHER_CTX_get_original_iv(EVP_CIPHER_CTX *ctx, void *buf, size_t len);
 unsigned char *EVP_CIPHER_CTX_buf_noconst(EVP_CIPHER_CTX *ctx);
-int EVP_CIPHER_CTX_num(const EVP_CIPHER_CTX *ctx);
+int EVP_CIPHER_CTX_get_num(const EVP_CIPHER_CTX *ctx);
+# define EVP_CIPHER_CTX_num EVP_CIPHER_CTX_get_num
 int EVP_CIPHER_CTX_set_num(EVP_CIPHER_CTX *ctx, int num);
 int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in);
 void *EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);
 void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data);
 void *EVP_CIPHER_CTX_get_cipher_data(const EVP_CIPHER_CTX *ctx);
 void *EVP_CIPHER_CTX_set_cipher_data(EVP_CIPHER_CTX *ctx, void *cipher_data);
-# define EVP_CIPHER_CTX_name(c)         EVP_CIPHER_name(EVP_CIPHER_CTX_get0_cipher(c))
-# define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_get0_cipher(c))
+# define EVP_CIPHER_CTX_get0_name(c) EVP_CIPHER_get0_name(EVP_CIPHER_CTX_get0_cipher(c))
+# define EVP_CIPHER_CTX_get_type(c)  EVP_CIPHER_get_type(EVP_CIPHER_CTX_get0_cipher(c))
+# define EVP_CIPHER_CTX_type         EVP_CIPHER_CTX_get_type
 # ifndef OPENSSL_NO_DEPRECATED_1_1_0
-#  define EVP_CIPHER_CTX_flags(c)       EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(c))
+#  define EVP_CIPHER_CTX_flags(c)    EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(c))
 # endif
-# define EVP_CIPHER_CTX_mode(c)         EVP_CIPHER_mode(EVP_CIPHER_CTX_get0_cipher(c))
+# define EVP_CIPHER_CTX_get_mode(c)  EVP_CIPHER_get_mode(EVP_CIPHER_CTX_get0_cipher(c))
+# define EVP_CIPHER_CTX_mode         EVP_CIPHER_CTX_get_mode
 
 # define EVP_ENCODE_LENGTH(l)    ((((l)+2)/3*4)+((l)/48+1)*2+80)
 # define EVP_DECODE_LENGTH(l)    (((l)+3)/4*3+80)
@@ -1164,17 +1193,17 @@ EVP_MAC *EVP_MAC_fetch(OSSL_LIB_CTX *libctx, const char *algorithm,
                        const char *properties);
 int EVP_MAC_up_ref(EVP_MAC *mac);
 void EVP_MAC_free(EVP_MAC *mac);
-int EVP_MAC_number(const EVP_MAC *mac);
-const char *EVP_MAC_name(const EVP_MAC *mac);
-const char *EVP_MAC_description(const EVP_MAC *mac);
+int EVP_MAC_get_number(const EVP_MAC *mac);
+const char *EVP_MAC_get0_name(const EVP_MAC *mac);
+const char *EVP_MAC_get0_description(const EVP_MAC *mac);
 int EVP_MAC_is_a(const EVP_MAC *mac, const char *name);
-const OSSL_PROVIDER *EVP_MAC_provider(const EVP_MAC *mac);
+const OSSL_PROVIDER *EVP_MAC_get0_provider(const EVP_MAC *mac);
 int EVP_MAC_get_params(EVP_MAC *mac, OSSL_PARAM params[]);
 
 EVP_MAC_CTX *EVP_MAC_CTX_new(EVP_MAC *mac);
 void EVP_MAC_CTX_free(EVP_MAC_CTX *ctx);
 EVP_MAC_CTX *EVP_MAC_CTX_dup(const EVP_MAC_CTX *src);
-EVP_MAC *EVP_MAC_CTX_mac(EVP_MAC_CTX *ctx);
+EVP_MAC *EVP_MAC_CTX_get0_mac(EVP_MAC_CTX *ctx);
 int EVP_MAC_CTX_get_params(EVP_MAC_CTX *ctx, OSSL_PARAM params[]);
 int EVP_MAC_CTX_set_params(EVP_MAC_CTX *ctx, const OSSL_PARAM params[]);
 
@@ -1209,16 +1238,16 @@ EVP_RAND *EVP_RAND_fetch(OSSL_LIB_CTX *libctx, const char *algorithm,
                          const char *properties);
 int EVP_RAND_up_ref(EVP_RAND *rand);
 void EVP_RAND_free(EVP_RAND *rand);
-int EVP_RAND_number(const EVP_RAND *rand);
-const char *EVP_RAND_name(const EVP_RAND *rand);
-const char *EVP_RAND_description(const EVP_RAND *md);
+int EVP_RAND_get_number(const EVP_RAND *rand);
+const char *EVP_RAND_get0_name(const EVP_RAND *rand);
+const char *EVP_RAND_get0_description(const EVP_RAND *md);
 int EVP_RAND_is_a(const EVP_RAND *rand, const char *name);
-const OSSL_PROVIDER *EVP_RAND_provider(const EVP_RAND *rand);
+const OSSL_PROVIDER *EVP_RAND_get0_provider(const EVP_RAND *rand);
 int EVP_RAND_get_params(EVP_RAND *rand, OSSL_PARAM params[]);
 
 EVP_RAND_CTX *EVP_RAND_CTX_new(EVP_RAND *rand, EVP_RAND_CTX *parent);
 void EVP_RAND_CTX_free(EVP_RAND_CTX *ctx);
-EVP_RAND *EVP_RAND_CTX_rand(EVP_RAND_CTX *ctx);
+EVP_RAND *EVP_RAND_CTX_get0_rand(EVP_RAND_CTX *ctx);
 int EVP_RAND_CTX_get_params(EVP_RAND_CTX *ctx, OSSL_PARAM params[]);
 int EVP_RAND_CTX_set_params(EVP_RAND_CTX *ctx, const OSSL_PARAM params[]);
 const OSSL_PARAM *EVP_RAND_gettable_params(const EVP_RAND *rand);
@@ -1250,15 +1279,15 @@ __owur int EVP_RAND_nonce(EVP_RAND_CTX *ctx, unsigned char *out, size_t outlen);
 __owur int EVP_RAND_enable_locking(EVP_RAND_CTX *ctx);
 
 int EVP_RAND_verify_zeroization(EVP_RAND_CTX *ctx);
-unsigned int EVP_RAND_strength(EVP_RAND_CTX *ctx);
-int EVP_RAND_state(EVP_RAND_CTX *ctx);
+unsigned int EVP_RAND_get_strength(EVP_RAND_CTX *ctx);
+int EVP_RAND_get_state(EVP_RAND_CTX *ctx);
 
-#define EVP_RAND_STATE_UNINITIALISED    0
-#define EVP_RAND_STATE_READY            1
-#define EVP_RAND_STATE_ERROR            2
+# define EVP_RAND_STATE_UNINITIALISED    0
+# define EVP_RAND_STATE_READY            1
+# define EVP_RAND_STATE_ERROR            2
 
 /* PKEY stuff */
-#ifndef OPENSSL_NO_DEPRECATED_3_0
+# ifndef OPENSSL_NO_DEPRECATED_3_0
 OSSL_DEPRECATEDIN_3_0 int EVP_PKEY_decrypt_old(unsigned char *dec_key,
                                           const unsigned char *enc_key,
                                           int enc_key_len,
@@ -1266,17 +1295,22 @@ OSSL_DEPRECATEDIN_3_0 int EVP_PKEY_decrypt_old(unsigned char *dec_key,
 OSSL_DEPRECATEDIN_3_0 int EVP_PKEY_encrypt_old(unsigned char *enc_key,
                                           const unsigned char *key,
                                           int key_len, EVP_PKEY *pub_key);
-#endif
+# endif
 int EVP_PKEY_is_a(const EVP_PKEY *pkey, const char *name);
 int EVP_PKEY_type_names_do_all(const EVP_PKEY *pkey,
                                void (*fn)(const char *name, void *data),
                                void *data);
 int EVP_PKEY_type(int type);
-int EVP_PKEY_id(const EVP_PKEY *pkey);
-int EVP_PKEY_base_id(const EVP_PKEY *pkey);
-int EVP_PKEY_bits(const EVP_PKEY *pkey);
-int EVP_PKEY_security_bits(const EVP_PKEY *pkey);
-int EVP_PKEY_size(const EVP_PKEY *pkey);
+int EVP_PKEY_get_id(const EVP_PKEY *pkey);
+# define EVP_PKEY_id EVP_PKEY_get_id
+int EVP_PKEY_get_base_id(const EVP_PKEY *pkey);
+# define EVP_PKEY_base_id EVP_PKEY_get_base_id
+int EVP_PKEY_get_bits(const EVP_PKEY *pkey);
+# define EVP_PKEY_bits EVP_PKEY_get_bits
+int EVP_PKEY_get_security_bits(const EVP_PKEY *pkey);
+# define EVP_PKEY_security_bits EVP_PKEY_get_security_bits
+int EVP_PKEY_get_size(const EVP_PKEY *pkey);
+# define EVP_PKEY_size EVP_PKEY_get_size
 int EVP_PKEY_can_sign(const EVP_PKEY *pkey);
 int EVP_PKEY_set_type(EVP_PKEY *pkey, int type);
 int EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len);
@@ -1343,7 +1377,7 @@ EVP_PKEY *EVP_PKEY_new(void);
 int EVP_PKEY_up_ref(EVP_PKEY *pkey);
 EVP_PKEY *EVP_PKEY_dup(EVP_PKEY *pkey);
 void EVP_PKEY_free(EVP_PKEY *pkey);
-const char *EVP_PKEY_description(const EVP_PKEY *pkey);
+const char *EVP_PKEY_get0_description(const EVP_PKEY *pkey);
 
 EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
                         long length);
@@ -1425,8 +1459,6 @@ int EVP_PKEY_set1_encoded_public_key(EVP_PKEY *pkey,
 
 size_t EVP_PKEY_get1_encoded_public_key(EVP_PKEY *pkey, unsigned char **ppub);
 
-int EVP_CIPHER_type(const EVP_CIPHER *cipher);
-
 /* calls methods */
 int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
 int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
@@ -1722,10 +1754,10 @@ EVP_KEYMGMT *EVP_KEYMGMT_fetch(OSSL_LIB_CTX *ctx, const char *algorithm,
                                const char *properties);
 int EVP_KEYMGMT_up_ref(EVP_KEYMGMT *keymgmt);
 void EVP_KEYMGMT_free(EVP_KEYMGMT *keymgmt);
-const OSSL_PROVIDER *EVP_KEYMGMT_provider(const EVP_KEYMGMT *keymgmt);
-const char *EVP_KEYMGMT_name(const EVP_KEYMGMT *keymgmt);
-const char *EVP_KEYMGMT_description(const EVP_KEYMGMT *keymgmt);
-int EVP_KEYMGMT_number(const EVP_KEYMGMT *keymgmt);
+const OSSL_PROVIDER *EVP_KEYMGMT_get0_provider(const EVP_KEYMGMT *keymgmt);
+const char *EVP_KEYMGMT_get0_name(const EVP_KEYMGMT *keymgmt);
+const char *EVP_KEYMGMT_get0_description(const EVP_KEYMGMT *keymgmt);
+int EVP_KEYMGMT_get_number(const EVP_KEYMGMT *keymgmt);
 int EVP_KEYMGMT_is_a(const EVP_KEYMGMT *keymgmt, const char *name);
 void EVP_KEYMGMT_do_all_provided(OSSL_LIB_CTX *libctx,
                                  void (*fn)(EVP_KEYMGMT *keymgmt, void *arg),
@@ -1804,13 +1836,13 @@ void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);
 
 void EVP_SIGNATURE_free(EVP_SIGNATURE *signature);
 int EVP_SIGNATURE_up_ref(EVP_SIGNATURE *signature);
-OSSL_PROVIDER *EVP_SIGNATURE_provider(const EVP_SIGNATURE *signature);
+OSSL_PROVIDER *EVP_SIGNATURE_get0_provider(const EVP_SIGNATURE *signature);
 EVP_SIGNATURE *EVP_SIGNATURE_fetch(OSSL_LIB_CTX *ctx, const char *algorithm,
                                    const char *properties);
 int EVP_SIGNATURE_is_a(const EVP_SIGNATURE *signature, const char *name);
-int EVP_SIGNATURE_number(const EVP_SIGNATURE *signature);
-const char *EVP_SIGNATURE_name(const EVP_SIGNATURE *signature);
-const char *EVP_SIGNATURE_description(const EVP_SIGNATURE *signature);
+int EVP_SIGNATURE_get_number(const EVP_SIGNATURE *signature);
+const char *EVP_SIGNATURE_get0_name(const EVP_SIGNATURE *signature);
+const char *EVP_SIGNATURE_get0_description(const EVP_SIGNATURE *signature);
 void EVP_SIGNATURE_do_all_provided(OSSL_LIB_CTX *libctx,
                                    void (*fn)(EVP_SIGNATURE *signature,
                                               void *data),
@@ -1823,13 +1855,13 @@ const OSSL_PARAM *EVP_SIGNATURE_settable_ctx_params(const EVP_SIGNATURE *sig);
 
 void EVP_ASYM_CIPHER_free(EVP_ASYM_CIPHER *cipher);
 int EVP_ASYM_CIPHER_up_ref(EVP_ASYM_CIPHER *cipher);
-OSSL_PROVIDER *EVP_ASYM_CIPHER_provider(const EVP_ASYM_CIPHER *cipher);
+OSSL_PROVIDER *EVP_ASYM_CIPHER_get0_provider(const EVP_ASYM_CIPHER *cipher);
 EVP_ASYM_CIPHER *EVP_ASYM_CIPHER_fetch(OSSL_LIB_CTX *ctx, const char *algorithm,
                                        const char *properties);
 int EVP_ASYM_CIPHER_is_a(const EVP_ASYM_CIPHER *cipher, const char *name);
-int EVP_ASYM_CIPHER_number(const EVP_ASYM_CIPHER *cipher);
-const char *EVP_ASYM_CIPHER_name(const EVP_ASYM_CIPHER *cipher);
-const char *EVP_ASYM_CIPHER_description(const EVP_ASYM_CIPHER *cipher);
+int EVP_ASYM_CIPHER_get_number(const EVP_ASYM_CIPHER *cipher);
+const char *EVP_ASYM_CIPHER_get0_name(const EVP_ASYM_CIPHER *cipher);
+const char *EVP_ASYM_CIPHER_get0_description(const EVP_ASYM_CIPHER *cipher);
 void EVP_ASYM_CIPHER_do_all_provided(OSSL_LIB_CTX *libctx,
                                      void (*fn)(EVP_ASYM_CIPHER *cipher,
                                                 void *arg),
@@ -1842,13 +1874,13 @@ const OSSL_PARAM *EVP_ASYM_CIPHER_settable_ctx_params(const EVP_ASYM_CIPHER *cip
 
 void EVP_KEM_free(EVP_KEM *wrap);
 int EVP_KEM_up_ref(EVP_KEM *wrap);
-OSSL_PROVIDER *EVP_KEM_provider(const EVP_KEM *wrap);
+OSSL_PROVIDER *EVP_KEM_get0_provider(const EVP_KEM *wrap);
 EVP_KEM *EVP_KEM_fetch(OSSL_LIB_CTX *ctx, const char *algorithm,
                        const char *properties);
 int EVP_KEM_is_a(const EVP_KEM *wrap, const char *name);
-int EVP_KEM_number(const EVP_KEM *wrap);
-const char *EVP_KEM_name(const EVP_KEM *wrap);
-const char *EVP_KEM_description(const EVP_KEM *wrap);
+int EVP_KEM_get_number(const EVP_KEM *wrap);
+const char *EVP_KEM_get0_name(const EVP_KEM *wrap);
+const char *EVP_KEM_get0_description(const EVP_KEM *wrap);
 void EVP_KEM_do_all_provided(OSSL_LIB_CTX *libctx,
                              void (*fn)(EVP_KEM *wrap, void *arg), void *arg);
 int EVP_KEM_names_do_all(const EVP_KEM *wrap,
@@ -2109,11 +2141,11 @@ void EVP_KEYEXCH_free(EVP_KEYEXCH *exchange);
 int EVP_KEYEXCH_up_ref(EVP_KEYEXCH *exchange);
 EVP_KEYEXCH *EVP_KEYEXCH_fetch(OSSL_LIB_CTX *ctx, const char *algorithm,
                                const char *properties);
-OSSL_PROVIDER *EVP_KEYEXCH_provider(const EVP_KEYEXCH *exchange);
+OSSL_PROVIDER *EVP_KEYEXCH_get0_provider(const EVP_KEYEXCH *exchange);
 int EVP_KEYEXCH_is_a(const EVP_KEYEXCH *keyexch, const char *name);
-int EVP_KEYEXCH_number(const EVP_KEYEXCH *keyexch);
-const char *EVP_KEYEXCH_name(const EVP_KEYEXCH *keyexch);
-const char *EVP_KEYEXCH_description(const EVP_KEYEXCH *keyexch);
+int EVP_KEYEXCH_get_number(const EVP_KEYEXCH *keyexch);
+const char *EVP_KEYEXCH_get0_name(const EVP_KEYEXCH *keyexch);
+const char *EVP_KEYEXCH_get0_description(const EVP_KEYEXCH *keyexch);
 void EVP_KEYEXCH_do_all_provided(OSSL_LIB_CTX *libctx,
                                  void (*fn)(EVP_KEYEXCH *keyexch, void *data),
                                  void *data);
diff --git a/include/openssl/kdf.h b/include/openssl/kdf.h
index 96a25ff7c1..2cc4fc4ad2 100644
--- a/include/openssl/kdf.h
+++ b/include/openssl/kdf.h
@@ -33,11 +33,11 @@ EVP_KDF *EVP_KDF_fetch(OSSL_LIB_CTX *libctx, const char *algorithm,
 EVP_KDF_CTX *EVP_KDF_CTX_new(EVP_KDF *kdf);
 void EVP_KDF_CTX_free(EVP_KDF_CTX *ctx);
 EVP_KDF_CTX *EVP_KDF_CTX_dup(const EVP_KDF_CTX *src);
-int EVP_KDF_number(const EVP_KDF *kdf);
-const char *EVP_KDF_description(const EVP_KDF *kdf);
+int EVP_KDF_get_number(const EVP_KDF *kdf);
+const char *EVP_KDF_get0_description(const EVP_KDF *kdf);
 int EVP_KDF_is_a(const EVP_KDF *kdf, const char *name);
-const char *EVP_KDF_name(const EVP_KDF *kdf);
-const OSSL_PROVIDER *EVP_KDF_provider(const EVP_KDF *kdf);
+const char *EVP_KDF_get0_name(const EVP_KDF *kdf);
+const OSSL_PROVIDER *EVP_KDF_get0_provider(const EVP_KDF *kdf);
 const EVP_KDF *EVP_KDF_CTX_kdf(EVP_KDF_CTX *ctx);
 
 void EVP_KDF_CTX_reset(EVP_KDF_CTX *ctx);
@@ -114,7 +114,8 @@ int EVP_PKEY_CTX_set1_hkdf_key(EVP_PKEY_CTX *ctx,
 int EVP_PKEY_CTX_add1_hkdf_info(EVP_PKEY_CTX *ctx,
                                 const unsigned char *info, int infolen);
 
-int EVP_PKEY_CTX_hkdf_mode(EVP_PKEY_CTX *ctx, int mode);
+int EVP_PKEY_CTX_set_hkdf_mode(EVP_PKEY_CTX *ctx, int mode);
+# define EVP_PKEY_CTX_hkdf_mode EVP_PKEY_CTX_set_hkdf_mode
 
 int EVP_PKEY_CTX_set1_pbe_pass(EVP_PKEY_CTX *ctx, const char *pass,
                                int passlen);
diff --git a/include/openssl/provider.h b/include/openssl/provider.h
index e66d5324af..dc86ff5878 100644
--- a/include/openssl/provider.h
+++ b/include/openssl/provider.h
@@ -51,7 +51,7 @@ int OSSL_PROVIDER_add_builtin(OSSL_LIB_CTX *, const char *name,
                               OSSL_provider_init_fn *init_fn);
 
 /* Information */
-const char *OSSL_PROVIDER_name(const OSSL_PROVIDER *prov);
+const char *OSSL_PROVIDER_get0_name(const OSSL_PROVIDER *prov);
 
 # ifdef __cplusplus
 }
diff --git a/include/openssl/store.h b/include/openssl/store.h
index d5703d5040..746bb0321e 100644
--- a/include/openssl/store.h
+++ b/include/openssl/store.h
@@ -258,11 +258,11 @@ OSSL_STORE_LOADER *OSSL_STORE_LOADER_fetch(const char *scheme,
                                            const char *properties);
 int OSSL_STORE_LOADER_up_ref(OSSL_STORE_LOADER *loader);
 void OSSL_STORE_LOADER_free(OSSL_STORE_LOADER *loader);
-const OSSL_PROVIDER *OSSL_STORE_LOADER_provider(const OSSL_STORE_LOADER *
+const OSSL_PROVIDER *OSSL_STORE_LOADER_get0_provider(const OSSL_STORE_LOADER *
                                                 loader);
-const char *OSSL_STORE_LOADER_properties(const OSSL_STORE_LOADER *loader);
-int OSSL_STORE_LOADER_number(const OSSL_STORE_LOADER *loader);
-const char *OSSL_STORE_LOADER_description(const OSSL_STORE_LOADER *loader);
+const char *OSSL_STORE_LOADER_get0_properties(const OSSL_STORE_LOADER *loader);
+int OSSL_STORE_LOADER_get_number(const OSSL_STORE_LOADER *loader);
+const char *OSSL_STORE_LOADER_get0_description(const OSSL_STORE_LOADER *loader);
 int OSSL_STORE_LOADER_is_a(const OSSL_STORE_LOADER *loader,
                            const char *scheme);
 void OSSL_STORE_LOADER_do_all_provided(OSSL_LIB_CTX *libctx,
diff --git a/providers/fips/self_test_kats.c b/providers/fips/self_test_kats.c
index 1b89cc82ae..d411767205 100644
--- a/providers/fips/self_test_kats.c
+++ b/providers/fips/self_test_kats.c
@@ -285,7 +285,7 @@ static int self_test_drbg(const ST_KAT_DRBG *t, OSSL_SELF_TEST *st,
     if (drbg == NULL)
         goto err;
 
-    strength = EVP_RAND_strength(drbg);
+    strength = EVP_RAND_get_strength(drbg);
 
     drbg_params[0] = OSSL_PARAM_construct_utf8_string(t-&gt;param_name,
                                                       t-&gt;param_value, 0);
diff --git a/providers/implementations/asymciphers/rsa_enc.c b/providers/implementations/asymciphers/rsa_enc.c
index 354c234939..7b534e76ed 100644
--- a/providers/implementations/asymciphers/rsa_enc.c
+++ b/providers/implementations/asymciphers/rsa_enc.c
@@ -371,7 +371,7 @@ static int rsa_get_ctx_params(void *vprsactx, OSSL_PARAM *params)
     p = OSSL_PARAM_locate(params, OSSL_ASYM_CIPHER_PARAM_OAEP_DIGEST);
     if (p != NULL &amp;&amp; !OSSL_PARAM_set_utf8_string(p, prsactx-&gt;oaep_md == NULL
                                                     ? &quot;&quot;
-                                                    : EVP_MD_name(prsactx-&gt;oaep_md)))
+                                                    : EVP_MD_get0_name(prsactx-&gt;oaep_md)))
         return 0;
 
     p = OSSL_PARAM_locate(params, OSSL_ASYM_CIPHER_PARAM_MGF1_DIGEST);
@@ -381,7 +381,7 @@ static int rsa_get_ctx_params(void *vprsactx, OSSL_PARAM *params)
 
         if (!OSSL_PARAM_set_utf8_string(p, mgf1_md == NULL
                                            ? &quot;&quot;
-                                           : EVP_MD_name(mgf1_md)))
+                                           : EVP_MD_get0_name(mgf1_md)))
         return 0;
     }
 
diff --git a/providers/implementations/asymciphers/sm2_enc.c b/providers/implementations/asymciphers/sm2_enc.c
index a855a36d20..c9dba32ffb 100644
--- a/providers/implementations/asymciphers/sm2_enc.c
+++ b/providers/implementations/asymciphers/sm2_enc.c
@@ -164,7 +164,7 @@ static int sm2_get_ctx_params(void *vpsm2ctx, OSSL_PARAM *params)
         const EVP_MD *md = ossl_prov_digest_md(&amp;psm2ctx-&gt;md);
 
         if (!OSSL_PARAM_set_utf8_string(p, md == NULL ? &quot;&quot;
-                                                      : EVP_MD_name(md)))
+                                                      : EVP_MD_get0_name(md)))
             return 0;
     }
 
diff --git a/providers/implementations/exchange/dh_exch.c b/providers/implementations/exchange/dh_exch.c
index 67a73d36ef..1dffc8d112 100644
--- a/providers/implementations/exchange/dh_exch.c
+++ b/providers/implementations/exchange/dh_exch.c
@@ -461,7 +461,7 @@ static int dh_get_ctx_params(void *vpdhctx, OSSL_PARAM params[])
     if (p != NULL
             &amp;&amp; !OSSL_PARAM_set_utf8_string(p, pdhctx-&gt;kdf_md == NULL
                                            ? &quot;&quot;
-                                           : EVP_MD_name(pdhctx-&gt;kdf_md))){
+                                           : EVP_MD_get0_name(pdhctx-&gt;kdf_md))){
         return 0;
     }
 
diff --git a/providers/implementations/exchange/ecdh_exch.c b/providers/implementations/exchange/ecdh_exch.c
index 7748340248..35d665fb91 100644
--- a/providers/implementations/exchange/ecdh_exch.c
+++ b/providers/implementations/exchange/ecdh_exch.c
@@ -377,7 +377,7 @@ int ecdh_get_ctx_params(void *vpecdhctx, OSSL_PARAM params[])
     if (p != NULL
             &amp;&amp; !OSSL_PARAM_set_utf8_string(p, pectx-&gt;kdf_md == NULL
                                            ? &quot;&quot;
-                                           : EVP_MD_name(pectx-&gt;kdf_md))){
+                                           : EVP_MD_get0_name(pectx-&gt;kdf_md))){
         return 0;
     }
 
diff --git a/providers/implementations/kdfs/hkdf.c b/providers/implementations/kdfs/hkdf.c
index ce0c81c1d2..83d9d1ecce 100644
--- a/providers/implementations/kdfs/hkdf.c
+++ b/providers/implementations/kdfs/hkdf.c
@@ -116,7 +116,7 @@ static size_t kdf_hkdf_size(KDF_HKDF *ctx)
         ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
         return 0;
     }
-    sz = EVP_MD_size(md);
+    sz = EVP_MD_get_size(md);
     if (sz &lt; 0)
         return 0;
 
@@ -326,7 +326,7 @@ static int HKDF(OSSL_LIB_CTX *libctx, const EVP_MD *evp_md,
     int ret, sz;
     size_t prk_len;
 
-    sz = EVP_MD_size(evp_md);
+    sz = EVP_MD_get_size(evp_md);
     if (sz &lt; 0)
         return 0;
     prk_len = (size_t)sz;
@@ -372,7 +372,7 @@ static int HKDF_Extract(OSSL_LIB_CTX *libctx, const EVP_MD *evp_md,
                         const unsigned char *ikm, size_t ikm_len,
                         unsigned char *prk, size_t prk_len)
 {
-    int sz = EVP_MD_size(evp_md);
+    int sz = EVP_MD_get_size(evp_md);
 
     if (sz &lt; 0)
         return 0;
@@ -382,8 +382,8 @@ static int HKDF_Extract(OSSL_LIB_CTX *libctx, const EVP_MD *evp_md,
     }
     /* calc: PRK = HMAC-Hash(salt, IKM) */
     return
-        EVP_Q_mac(libctx, &quot;HMAC&quot;, NULL, EVP_MD_name(evp_md), NULL, salt,
-                  salt_len, ikm, ikm_len, prk, EVP_MD_size(evp_md), NULL)
+        EVP_Q_mac(libctx, &quot;HMAC&quot;, NULL, EVP_MD_get0_name(evp_md), NULL, salt,
+                  salt_len, ikm, ikm_len, prk, EVP_MD_get_size(evp_md), NULL)
         != NULL;
 }
 
@@ -437,7 +437,7 @@ static int HKDF_Expand(const EVP_MD *evp_md,
     unsigned char prev[EVP_MAX_MD_SIZE];
     size_t done_len = 0, dig_len, n;
 
-    sz = EVP_MD_size(evp_md);
+    sz = EVP_MD_get_size(evp_md);
     if (sz &lt;= 0)
         return 0;
     dig_len = (size_t)sz;
diff --git a/providers/implementations/kdfs/kbkdf.c b/providers/implementations/kdfs/kbkdf.c
index e22d54171f..01f7f0d4fd 100644
--- a/providers/implementations/kdfs/kbkdf.c
+++ b/providers/implementations/kdfs/kbkdf.c
@@ -289,9 +289,9 @@ static int kbkdf_set_ctx_params(void *vctx, const OSSL_PARAM params[])
                                            NULL, NULL, libctx))
         return 0;
     else if (ctx-&gt;ctx_init != NULL
-             &amp;&amp; !EVP_MAC_is_a(EVP_MAC_CTX_mac(ctx-&gt;ctx_init),
+             &amp;&amp; !EVP_MAC_is_a(EVP_MAC_CTX_get0_mac(ctx-&gt;ctx_init),
                               OSSL_MAC_NAME_HMAC)
-             &amp;&amp; !EVP_MAC_is_a(EVP_MAC_CTX_mac(ctx-&gt;ctx_init),
+             &amp;&amp; !EVP_MAC_is_a(EVP_MAC_CTX_get0_mac(ctx-&gt;ctx_init),
                               OSSL_MAC_NAME_CMAC)) {
         ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_MAC);
         return 0;
diff --git a/providers/implementations/kdfs/krb5kdf.c b/providers/implementations/kdfs/krb5kdf.c
index 4bf9ce7294..f8d4baa568 100644
--- a/providers/implementations/kdfs/krb5kdf.c
+++ b/providers/implementations/kdfs/krb5kdf.c
@@ -176,7 +176,7 @@ static int krb5kdf_get_ctx_params(void *vctx, OSSL_PARAM params[])
 
     cipher = ossl_prov_cipher_cipher(&amp;ctx-&gt;cipher);
     if (cipher)
-        len = EVP_CIPHER_key_length(cipher);
+        len = EVP_CIPHER_get_key_length(cipher);
     else
         len = EVP_MAX_KEY_LENGTH;
 
@@ -332,7 +332,7 @@ static int cipher_init(EVP_CIPHER_CTX *ctx,
     if (!ret)
         goto out;
     /* set the key len for the odd variable key len cipher */
-    klen = EVP_CIPHER_CTX_key_length(ctx);
+    klen = EVP_CIPHER_CTX_get_key_length(ctx);
     if (key_len != (size_t)klen) {
         ret = EVP_CIPHER_CTX_set_key_length(ctx, key_len);
         if (!ret)
@@ -369,7 +369,7 @@ static int KRB5KDF(const EVP_CIPHER *cipher, ENGINE *engine,
 #ifndef OPENSSL_NO_DES
         /* special case for 3des, where the caller may be requesting
          * the random raw key, instead of the fixed up key  */
-        if (EVP_CIPHER_nid(cipher) == NID_des_ede3_cbc &amp;&amp;
+        if (EVP_CIPHER_get_nid(cipher) == NID_des_ede3_cbc &amp;&amp;
             key_len == 24 &amp;&amp; okey_len == 21) {
                 des3_no_fixup = 1;
         } else {
@@ -390,7 +390,7 @@ static int KRB5KDF(const EVP_CIPHER *cipher, ENGINE *engine,
         goto out;
 
     /* Initialize input block */
-    blocksize = EVP_CIPHER_CTX_block_size(ctx);
+    blocksize = EVP_CIPHER_CTX_get_block_size(ctx);
 
     if (constant_len &gt; blocksize) {
         ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_CONSTANT_LENGTH);
@@ -445,7 +445,7 @@ static int KRB5KDF(const EVP_CIPHER *cipher, ENGINE *engine,
     }
 
 #ifndef OPENSSL_NO_DES
-    if (EVP_CIPHER_nid(cipher) == NID_des_ede3_cbc &amp;&amp; !des3_no_fixup) {
+    if (EVP_CIPHER_get_nid(cipher) == NID_des_ede3_cbc &amp;&amp; !des3_no_fixup) {
         ret = fixup_des3_key(okey);
         if (!ret) {
             ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GENERATE_KEY);
diff --git a/providers/implementations/kdfs/pbkdf2.c b/providers/implementations/kdfs/pbkdf2.c
index 14c78b518c..fe247028ea 100644
--- a/providers/implementations/kdfs/pbkdf2.c
+++ b/providers/implementations/kdfs/pbkdf2.c
@@ -281,7 +281,7 @@ static int pbkdf2_derive(const char *pass, size_t passlen,
     unsigned long i = 1;
     HMAC_CTX *hctx_tpl = NULL, *hctx = NULL;
 
-    mdlen = EVP_MD_size(digest);
+    mdlen = EVP_MD_get_size(digest);
     if (mdlen &lt;= 0)
         return 0;
 
diff --git a/providers/implementations/kdfs/pkcs12kdf.c b/providers/implementations/kdfs/pkcs12kdf.c
index d0036441a3..0ca83dd243 100644
--- a/providers/implementations/kdfs/pkcs12kdf.c
+++ b/providers/implementations/kdfs/pkcs12kdf.c
@@ -62,8 +62,8 @@ static int pkcs12kdf_derive(const unsigned char *pass, size_t passlen,
         ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
         goto end;
     }
-    vi = EVP_MD_block_size(md_type);
-    ui = EVP_MD_size(md_type);
+    vi = EVP_MD_get_block_size(md_type);
+    ui = EVP_MD_get_size(md_type);
     if (ui &lt; 0 || vi &lt;= 0) {
         ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DIGEST_SIZE);
         goto end;
diff --git a/providers/implementations/kdfs/sskdf.c b/providers/implementations/kdfs/sskdf.c
index c281997a25..56ac1e6334 100644
--- a/providers/implementations/kdfs/sskdf.c
+++ b/providers/implementations/kdfs/sskdf.c
@@ -108,7 +108,7 @@ static int SSKDF_hash_kdm(const EVP_MD *kdf_md,
             || derived_key_len == 0)
         return 0;
 
-    hlen = EVP_MD_size(kdf_md);
+    hlen = EVP_MD_get_size(kdf_md);
     if (hlen &lt;= 0)
         return 0;
     out_len = (size_t)hlen;
@@ -338,7 +338,7 @@ static size_t sskdf_size(KDF_SSKDF *ctx)
         ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
         return 0;
     }
-    len = EVP_MD_size(md);
+    len = EVP_MD_get_size(md);
     return (len &lt;= 0) ? 0 : (size_t)len;
 }
 
@@ -362,7 +362,7 @@ static int sskdf_derive(void *vctx, unsigned char *key, size_t keylen,
         const unsigned char *custom = NULL;
         size_t custom_len = 0;
         int default_salt_len;
-        EVP_MAC *mac = EVP_MAC_CTX_mac(ctx-&gt;macctx);
+        EVP_MAC *mac = EVP_MAC_CTX_get0_mac(ctx-&gt;macctx);
 
         if (EVP_MAC_is_a(mac, OSSL_MAC_NAME_HMAC)) {
             /* H(x) = HMAC(x, salt, hash) */
@@ -370,7 +370,7 @@ static int sskdf_derive(void *vctx, unsigned char *key, size_t keylen,
                 ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
                 return 0;
             }
-            default_salt_len = EVP_MD_size(md);
+            default_salt_len = EVP_MD_get_size(md);
             if (default_salt_len &lt;= 0)
                 return 0;
         } else if (EVP_MAC_is_a(mac, OSSL_MAC_NAME_KMAC128)
diff --git a/providers/implementations/kdfs/x942kdf.c b/providers/implementations/kdfs/x942kdf.c
index c469d48439..c2cc94a192 100644
--- a/providers/implementations/kdfs/x942kdf.c
+++ b/providers/implementations/kdfs/x942kdf.c
@@ -281,7 +281,7 @@ static int x942kdf_hash_kdm(const EVP_MD *kdf_md,
         return 0;
     }
 
-    hlen = EVP_MD_size(kdf_md);
+    hlen = EVP_MD_get_size(kdf_md);
     if (hlen &lt;= 0)
         return 0;
     out_len = (size_t)hlen;
@@ -388,7 +388,7 @@ static size_t x942kdf_size(KDF_X942 *ctx)
         ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
         return 0;
     }
-    len = EVP_MD_size(md);
+    len = EVP_MD_get_size(md);
     return (len &lt;= 0) ? 0 : (size_t)len;
 }
 
diff --git a/providers/implementations/keymgmt/mac_legacy_kmgmt.c b/providers/implementations/keymgmt/mac_legacy_kmgmt.c
index f11bcc560c..3b378d38ff 100644
--- a/providers/implementations/keymgmt/mac_legacy_kmgmt.c
+++ b/providers/implementations/keymgmt/mac_legacy_kmgmt.c
@@ -174,7 +174,7 @@ static int mac_match(const void *keydata1, const void *keydata2, int selection)
                                          key1-&gt;priv_key_len) == 0);
         if (key1-&gt;cipher.cipher != NULL)
             ok = ok &amp;&amp; EVP_CIPHER_is_a(key1-&gt;cipher.cipher,
-                                       EVP_CIPHER_name(key2-&gt;cipher.cipher));
+                                       EVP_CIPHER_get0_name(key2-&gt;cipher.cipher));
     }
     return ok;
 }
@@ -253,7 +253,7 @@ static int key_to_params(MAC_KEY *key, OSSL_PARAM_BLD *tmpl,
     if (key-&gt;cipher.cipher != NULL
         &amp;&amp; !ossl_param_build_set_utf8_string(tmpl, params,
                                              OSSL_PKEY_PARAM_CIPHER,
-                                             EVP_CIPHER_name(key-&gt;cipher.cipher)))
+                                             EVP_CIPHER_get0_name(key-&gt;cipher.cipher)))
         return 0;
 
 #if !defined(OPENSSL_NO_ENGINE) &amp;&amp; !defined(FIPS_MODULE)
diff --git a/providers/implementations/macs/cmac_prov.c b/providers/implementations/macs/cmac_prov.c
index 85625c8681..4f8450475c 100644
--- a/providers/implementations/macs/cmac_prov.c
+++ b/providers/implementations/macs/cmac_prov.c
@@ -99,7 +99,7 @@ static size_t cmac_size(void *vmacctx)
 {
     struct cmac_data_st *macctx = vmacctx;
 
-    return EVP_CIPHER_CTX_block_size(CMAC_CTX_get0_cipher_ctx(macctx-&gt;ctx));
+    return EVP_CIPHER_CTX_get_block_size(CMAC_CTX_get0_cipher_ctx(macctx-&gt;ctx));
 }
 
 static int cmac_setkey(struct cmac_data_st *macctx,
diff --git a/providers/implementations/macs/gmac_prov.c b/providers/implementations/macs/gmac_prov.c
index 1f4047ccd3..29fb9f87df 100644
--- a/providers/implementations/macs/gmac_prov.c
+++ b/providers/implementations/macs/gmac_prov.c
@@ -103,7 +103,7 @@ static int gmac_setkey(struct gmac_data_st *macctx,
 {
     EVP_CIPHER_CTX *ctx = macctx-&gt;ctx;
 
-    if (keylen != (size_t)EVP_CIPHER_CTX_key_length(ctx)) {
+    if (keylen != (size_t)EVP_CIPHER_CTX_get_key_length(ctx)) {
         ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_KEY_LENGTH);
         return 0;
     }
@@ -214,7 +214,7 @@ static int gmac_set_ctx_params(void *vmacctx, const OSSL_PARAM params[])
         || !ossl_prov_cipher_load_from_params(&amp;macctx-&gt;cipher, params, provctx))
         return 0;
 
-    if (EVP_CIPHER_mode(ossl_prov_cipher_cipher(&amp;macctx-&gt;cipher))
+    if (EVP_CIPHER_get_mode(ossl_prov_cipher_cipher(&amp;macctx-&gt;cipher))
         != EVP_CIPH_GCM_MODE) {
         ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_MODE);
         return 0;
diff --git a/providers/implementations/macs/kmac_prov.c b/providers/implementations/macs/kmac_prov.c
index 4ee57ca1c2..123c40f54f 100644
--- a/providers/implementations/macs/kmac_prov.c
+++ b/providers/implementations/macs/kmac_prov.c
@@ -187,7 +187,7 @@ static void *kmac_fetch_new(void *provctx, const OSSL_PARAM *params)
         return 0;
     }
 
-    kctx-&gt;out_len = EVP_MD_size(ossl_prov_digest_md(&amp;kctx-&gt;digest));
+    kctx-&gt;out_len = EVP_MD_get_size(ossl_prov_digest_md(&amp;kctx-&gt;digest));
     return kctx;
 }
 
@@ -243,7 +243,7 @@ static int kmac_setkey(struct kmac_data_st *kctx, const unsigned char *key,
                        size_t keylen)
 {
     const EVP_MD *digest = ossl_prov_digest_md(&amp;kctx-&gt;digest);
-    int w = EVP_MD_block_size(digest);
+    int w = EVP_MD_get_block_size(digest);
 
     if (keylen &lt; KMAC_MIN_KEY || keylen &gt; KMAC_MAX_KEY) {
         ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_KEY_LENGTH);
@@ -288,7 +288,7 @@ static int kmac_init(void *vmacctx, const unsigned char *key,
                            NULL))
         return 0;
 
-    t = EVP_MD_block_size(ossl_prov_digest_md(&amp;kctx-&gt;digest));
+    t = EVP_MD_get_block_size(ossl_prov_digest_md(&amp;kctx-&gt;digest));
     if (t &lt; 0) {
         ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DIGEST_LENGTH);
         return 0;
diff --git a/providers/implementations/rands/drbg_ctr.c b/providers/implementations/rands/drbg_ctr.c
index 48e8677ec8..458feca6a5 100644
--- a/providers/implementations/rands/drbg_ctr.c
+++ b/providers/implementations/rands/drbg_ctr.c
@@ -540,7 +540,7 @@ static int drbg_ctr_init(PROV_DRBG *drbg)
         ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_CIPHER);
         return 0;
     }
-    ctr-&gt;keylen = keylen = EVP_CIPHER_key_length(ctr-&gt;cipher_ctr);
+    ctr-&gt;keylen = keylen = EVP_CIPHER_get_key_length(ctr-&gt;cipher_ctr);
     if (ctr-&gt;ctx_ecb == NULL)
         ctr-&gt;ctx_ecb = EVP_CIPHER_CTX_new();
     if (ctr-&gt;ctx_ctr == NULL)
@@ -645,7 +645,8 @@ static int drbg_ctr_get_ctx_params(void *vdrbg, OSSL_PARAM params[])
     p = OSSL_PARAM_locate(params, OSSL_DRBG_PARAM_CIPHER);
     if (p != NULL) {
         if (ctr-&gt;cipher_ctr == NULL
-            || !OSSL_PARAM_set_utf8_string(p, EVP_CIPHER_name(ctr-&gt;cipher_ctr)))
+            || !OSSL_PARAM_set_utf8_string(p,
+                                           EVP_CIPHER_get0_name(ctr-&gt;cipher_ctr)))
             return 0;
     }
 
diff --git a/providers/implementations/rands/drbg_hash.c b/providers/implementations/rands/drbg_hash.c
index 4db104c773..6deb0a2925 100644
--- a/providers/implementations/rands/drbg_hash.c
+++ b/providers/implementations/rands/drbg_hash.c
@@ -438,7 +438,7 @@ static int drbg_hash_get_ctx_params(void *vdrbg, OSSL_PARAM params[])
     p = OSSL_PARAM_locate(params, OSSL_DRBG_PARAM_DIGEST);
     if (p != NULL) {
         md = ossl_prov_digest_md(&amp;hash-&gt;digest);
-        if (md == NULL || !OSSL_PARAM_set_utf8_string(p, EVP_MD_name(md)))
+        if (md == NULL || !OSSL_PARAM_set_utf8_string(p, EVP_MD_get0_name(md)))
             return 0;
     }
 
@@ -468,13 +468,13 @@ static int drbg_hash_set_ctx_params(void *vctx, const OSSL_PARAM params[])
 
     md = ossl_prov_digest_md(&amp;hash-&gt;digest);
     if (md != NULL) {
-        if ((EVP_MD_flags(md) &amp; EVP_MD_FLAG_XOF) != 0) {
+        if ((EVP_MD_get_flags(md) &amp; EVP_MD_FLAG_XOF) != 0) {
             ERR_raise(ERR_LIB_PROV, PROV_R_XOF_DIGESTS_NOT_ALLOWED);
             return 0;
         }
 
         /* These are taken from SP 800-90 10.1 Table 2 */
-        hash-&gt;blocklen = EVP_MD_size(md);
+        hash-&gt;blocklen = EVP_MD_get_size(md);
         /* See SP800-57 Part1 Rev4 5.6.1 Table 3 */
         ctx-&gt;strength = 64 * (hash-&gt;blocklen &gt;&gt; 3);
         if (ctx-&gt;strength &gt; 256)
diff --git a/providers/implementations/rands/drbg_hmac.c b/providers/implementations/rands/drbg_hmac.c
index 67c0339801..e68465a78c 100644
--- a/providers/implementations/rands/drbg_hmac.c
+++ b/providers/implementations/rands/drbg_hmac.c
@@ -326,7 +326,7 @@ static int drbg_hmac_get_ctx_params(void *vdrbg, OSSL_PARAM params[])
     if (p != NULL) {
         if (hmac-&gt;ctx == NULL)
             return 0;
-        name = EVP_MAC_name(EVP_MAC_CTX_mac(hmac-&gt;ctx));
+        name = EVP_MAC_get0_name(EVP_MAC_CTX_get0_mac(hmac-&gt;ctx));
         if (!OSSL_PARAM_set_utf8_string(p, name))
             return 0;
     }
@@ -334,7 +334,7 @@ static int drbg_hmac_get_ctx_params(void *vdrbg, OSSL_PARAM params[])
     p = OSSL_PARAM_locate(params, OSSL_DRBG_PARAM_DIGEST);
     if (p != NULL) {
         md = ossl_prov_digest_md(&amp;hmac-&gt;digest);
-        if (md == NULL || !OSSL_PARAM_set_utf8_string(p, EVP_MD_name(md)))
+        if (md == NULL || !OSSL_PARAM_set_utf8_string(p, EVP_MD_get0_name(md)))
             return 0;
     }
 
@@ -369,7 +369,7 @@ static int drbg_hmac_set_ctx_params(void *vctx, const OSSL_PARAM params[])
      * digests.
      */
     md = ossl_prov_digest_md(&amp;hmac-&gt;digest);
-    if (md != NULL &amp;&amp; (EVP_MD_flags(md) &amp; EVP_MD_FLAG_XOF) != 0) {
+    if (md != NULL &amp;&amp; (EVP_MD_get_flags(md) &amp; EVP_MD_FLAG_XOF) != 0) {
         ERR_raise(ERR_LIB_PROV, PROV_R_XOF_DIGESTS_NOT_ALLOWED);
         return 0;
     }
@@ -380,7 +380,7 @@ static int drbg_hmac_set_ctx_params(void *vctx, const OSSL_PARAM params[])
 
     if (hmac-&gt;ctx != NULL) {
         /* These are taken from SP 800-90 10.1 Table 2 */
-        hmac-&gt;blocklen = EVP_MD_size(md);
+        hmac-&gt;blocklen = EVP_MD_get_size(md);
         /* See SP800-57 Part1 Rev4 5.6.1 Table 3 */
         ctx-&gt;strength = 64 * (int)(hmac-&gt;blocklen &gt;&gt; 3);
         if (ctx-&gt;strength &gt; 256)
diff --git a/providers/implementations/signature/dsa_sig.c b/providers/implementations/signature/dsa_sig.c
index 23e000db4c..138fbce5e9 100644
--- a/providers/implementations/signature/dsa_sig.c
+++ b/providers/implementations/signature/dsa_sig.c
@@ -92,7 +92,7 @@ typedef struct {
 static size_t dsa_get_md_size(const PROV_DSA_CTX *pdsactx)
 {
     if (pdsactx-&gt;md != NULL)
-        return EVP_MD_size(pdsactx-&gt;md);
+        return EVP_MD_get_size(pdsactx-&gt;md);
     return 0;
 }
 
diff --git a/providers/implementations/signature/ecdsa_sig.c b/providers/implementations/signature/ecdsa_sig.c
index a4297d1903..c32641f1eb 100644
--- a/providers/implementations/signature/ecdsa_sig.c
+++ b/providers/implementations/signature/ecdsa_sig.c
@@ -248,7 +248,7 @@ static int ecdsa_setup_md(PROV_ECDSA_CTX *ctx, const char *mdname,
     WPACKET_cleanup(&amp;pkt);
     ctx-&gt;mdctx = NULL;
     ctx-&gt;md = md;
-    ctx-&gt;mdsize = EVP_MD_size(ctx-&gt;md);
+    ctx-&gt;mdsize = EVP_MD_get_size(ctx-&gt;md);
     OPENSSL_strlcpy(ctx-&gt;mdname, mdname, sizeof(ctx-&gt;mdname));
 
     return 1;
@@ -429,7 +429,7 @@ static int ecdsa_get_ctx_params(void *vctx, OSSL_PARAM *params)
     p = OSSL_PARAM_locate(params, OSSL_SIGNATURE_PARAM_DIGEST);
     if (p != NULL &amp;&amp; !OSSL_PARAM_set_utf8_string(p, ctx-&gt;md == NULL
                                                     ? ctx-&gt;mdname
-                                                    : EVP_MD_name(ctx-&gt;md)))
+                                                    : EVP_MD_get0_name(ctx-&gt;md)))
         return 0;
 
     return 1;
diff --git a/providers/implementations/signature/mac_legacy_sig.c b/providers/implementations/signature/mac_legacy_sig.c
index a8cc67b410..d9fd105289 100644
--- a/providers/implementations/signature/mac_legacy_sig.c
+++ b/providers/implementations/signature/mac_legacy_sig.c
@@ -107,7 +107,7 @@ static int mac_digest_sign_init(void *vpmacctx, const char *mdname, void *vkey,
     pmacctx-&gt;key = vkey;
 
     if (pmacctx-&gt;key-&gt;cipher.cipher != NULL)
-        ciphername = (char *)EVP_CIPHER_name(pmacctx-&gt;key-&gt;cipher.cipher);
+        ciphername = (char *)EVP_CIPHER_get0_name(pmacctx-&gt;key-&gt;cipher.cipher);
 #if !defined(OPENSSL_NO_ENGINE) &amp;&amp; !defined(FIPS_MODULE)
     if (pmacctx-&gt;key-&gt;cipher.engine != NULL)
         engine = (char *)ENGINE_get_id(pmacctx-&gt;key-&gt;cipher.engine);
diff --git a/providers/implementations/signature/rsa_sig.c b/providers/implementations/signature/rsa_sig.c
index abd3b1a77b..30fd43e0e5 100644
--- a/providers/implementations/signature/rsa_sig.c
+++ b/providers/implementations/signature/rsa_sig.c
@@ -116,7 +116,7 @@ typedef struct {
 static size_t rsa_get_md_size(const PROV_RSA_CTX *prsactx)
 {
     if (prsactx-&gt;md != NULL)
-        return EVP_MD_size(prsactx-&gt;md);
+        return EVP_MD_get_size(prsactx-&gt;md);
     return 0;
 }
 
@@ -156,7 +156,7 @@ static int rsa_check_parameters(PROV_RSA_CTX *prsactx, int min_saltlen)
         int max_saltlen;
 
         /* See if minimum salt length exceeds maximum possible */
-        max_saltlen = RSA_size(prsactx-&gt;rsa) - EVP_MD_size(prsactx-&gt;md);
+        max_saltlen = RSA_size(prsactx-&gt;rsa) - EVP_MD_get_size(prsactx-&gt;md);
         if ((RSA_bits(prsactx-&gt;rsa) &amp; 0x7) == 1)
             max_saltlen--;
         if (min_saltlen &lt; 0 || min_saltlen &gt; max_saltlen) {
@@ -195,9 +195,9 @@ static int rsa_pss_compute_saltlen(PROV_RSA_CTX *ctx)
     int saltlen = ctx-&gt;saltlen;
  
     if (saltlen == RSA_PSS_SALTLEN_DIGEST) {
-        saltlen = EVP_MD_size(ctx-&gt;md);
+        saltlen = EVP_MD_get_size(ctx-&gt;md);
     } else if (saltlen == RSA_PSS_SALTLEN_AUTO || saltlen == RSA_PSS_SALTLEN_MAX) {
-        saltlen = RSA_size(ctx-&gt;rsa) - EVP_MD_size(ctx-&gt;md) - 2;
+        saltlen = RSA_size(ctx-&gt;rsa) - EVP_MD_get_size(ctx-&gt;md) - 2;
         if ((RSA_bits(ctx-&gt;rsa) &amp; 0x7) == 1)
             saltlen--;
     }
@@ -575,13 +575,13 @@ static int rsa_sign(void *vprsactx, unsigned char *sig, size_t *siglen,
             if (rsa_pss_restricted(prsactx)) {
                 switch (prsactx-&gt;saltlen) {
                 case RSA_PSS_SALTLEN_DIGEST:
-                    if (prsactx-&gt;min_saltlen &gt; EVP_MD_size(prsactx-&gt;md)) {
+                    if (prsactx-&gt;min_saltlen &gt; EVP_MD_get_size(prsactx-&gt;md)) {
                         ERR_raise_data(ERR_LIB_PROV,
                                        PROV_R_PSS_SALTLEN_TOO_SMALL,
                                        &quot;minimum salt length set to %d, &quot;
                                        &quot;but the digest only gives %d&quot;,
                                        prsactx-&gt;min_saltlen,
-                                       EVP_MD_size(prsactx-&gt;md));
+                                       EVP_MD_get_size(prsactx-&gt;md));
                         return 0;
                     }
                     /* FALLTHRU */
@@ -678,10 +678,10 @@ static int rsa_verify_recover(void *vprsactx,
                 ERR_raise(ERR_LIB_PROV, PROV_R_ALGORITHM_MISMATCH);
                 return 0;
             }
-            if (ret != EVP_MD_size(prsactx-&gt;md)) {
+            if (ret != EVP_MD_get_size(prsactx-&gt;md)) {
                 ERR_raise_data(ERR_LIB_PROV, PROV_R_INVALID_DIGEST_LENGTH,
                                &quot;Should be %d, but got %d&quot;,
-                               EVP_MD_size(prsactx-&gt;md), ret);
+                               EVP_MD_get_size(prsactx-&gt;md), ret);
                 return 0;
             }
 
@@ -1279,13 +1279,13 @@ static int rsa_set_ctx_params(void *vprsactx, const OSSL_PARAM params[])
                 }
                 break;
             case RSA_PSS_SALTLEN_DIGEST:
-                if (prsactx-&gt;min_saltlen &gt; EVP_MD_size(prsactx-&gt;md)) {
+                if (prsactx-&gt;min_saltlen &gt; EVP_MD_get_size(prsactx-&gt;md)) {
                     ERR_raise_data(ERR_LIB_PROV,
                                    PROV_R_PSS_SALTLEN_TOO_SMALL,
                                    &quot;Should be more than %d, but would be &quot;
                                    &quot;set to match digest size (%d)&quot;,
                                    prsactx-&gt;min_saltlen,
-                                   EVP_MD_size(prsactx-&gt;md));
+                                   EVP_MD_get_size(prsactx-&gt;md));
                     return 0;
                 }
                 break;
diff --git a/providers/implementations/signature/sm2_sig.c b/providers/implementations/signature/sm2_sig.c
index 8607a8b911..719e7a2eb2 100644
--- a/providers/implementations/signature/sm2_sig.c
+++ b/providers/implementations/signature/sm2_sig.c
@@ -198,7 +198,7 @@ static int sm2sig_digest_signverify_init(void *vpsm2ctx, const char *mdname,
     if (ctx-&gt;mdctx == NULL)
         goto error;
 
-    md_nid = EVP_MD_type(ctx-&gt;md);
+    md_nid = EVP_MD_get_type(ctx-&gt;md);
 
     /*
      * We do not care about DER writing errors.
@@ -295,7 +295,7 @@ int sm2sig_digest_verify_final(void *vpsm2ctx, const unsigned char *sig,
 
     if (psm2ctx == NULL
         || psm2ctx-&gt;mdctx == NULL
-        || EVP_MD_size(psm2ctx-&gt;md) &gt; (int)sizeof(digest))
+        || EVP_MD_get_size(psm2ctx-&gt;md) &gt; (int)sizeof(digest))
         return 0;
 
     if (!(sm2sig_compute_z_digest(psm2ctx)
@@ -378,7 +378,7 @@ static int sm2sig_get_ctx_params(void *vpsm2ctx, OSSL_PARAM *params)
     p = OSSL_PARAM_locate(params, OSSL_SIGNATURE_PARAM_DIGEST);
     if (p != NULL &amp;&amp; !OSSL_PARAM_set_utf8_string(p, psm2ctx-&gt;md == NULL
                                                     ? psm2ctx-&gt;mdname
-                                                    : EVP_MD_name(psm2ctx-&gt;md)))
+                                                    : EVP_MD_get0_name(psm2ctx-&gt;md)))
         return 0;
 
     return 1;
diff --git a/ssl/ktls.c b/ssl/ktls.c
index 4aece2e7b7..a5de8bd720 100644
--- a/ssl/ktls.c
+++ b/ssl/ktls.c
@@ -67,7 +67,7 @@ int ktls_configure_crypto(const SSL *s, const EVP_CIPHER *c, EVP_CIPHER_CTX *dd,
     case SSL_AES256GCM:
         crypto_info-&gt;cipher_algorithm = CRYPTO_AES_NIST_GCM_16;
         if (s-&gt;version == TLS1_3_VERSION)
-            crypto_info-&gt;iv_len = EVP_CIPHER_CTX_iv_length(dd);
+            crypto_info-&gt;iv_len = EVP_CIPHER_CTX_get_iv_length(dd);
         else
             crypto_info-&gt;iv_len = EVP_GCM_TLS_FIXED_IV_LEN;
         break;
@@ -87,7 +87,7 @@ int ktls_configure_crypto(const SSL *s, const EVP_CIPHER *c, EVP_CIPHER_CTX *dd,
             return 0;
         }
         crypto_info-&gt;cipher_algorithm = CRYPTO_AES_CBC;
-        crypto_info-&gt;iv_len = EVP_CIPHER_iv_length(c);
+        crypto_info-&gt;iv_len = EVP_CIPHER_get_iv_length(c);
         crypto_info-&gt;auth_key = mac_key;
         crypto_info-&gt;auth_key_len = mac_secret_size;
         break;
@@ -95,7 +95,7 @@ int ktls_configure_crypto(const SSL *s, const EVP_CIPHER *c, EVP_CIPHER_CTX *dd,
         return 0;
     }
     crypto_info-&gt;cipher_key = key;
-    crypto_info-&gt;cipher_key_len = EVP_CIPHER_key_length(c);
+    crypto_info-&gt;cipher_key_len = EVP_CIPHER_get_key_length(c);
     crypto_info-&gt;iv = iv;
     crypto_info-&gt;tls_vmajor = (s-&gt;version &gt;&gt; 8) &amp; 0x000000ff;
     crypto_info-&gt;tls_vminor = (s-&gt;version &amp; 0x000000ff);
@@ -129,11 +129,11 @@ int ktls_check_supported_cipher(const SSL *s, const EVP_CIPHER *c,
     /* check that cipher is AES_GCM_128, AES_GCM_256, AES_CCM_128 
      * or Chacha20-Poly1305
      */
-    switch (EVP_CIPHER_nid(c))
+    switch (EVP_CIPHER_get_nid(c))
     {
 # ifdef OPENSSL_KTLS_AES_CCM_128
     case NID_aes_128_ccm:
-        if (EVP_CIPHER_CTX_tag_length(dd) != EVP_CCM_TLS_TAG_LEN)
+        if (EVP_CIPHER_CTX_get_tag_length(dd) != EVP_CCM_TLS_TAG_LEN)
           return 0;
 # endif
 # ifdef OPENSSL_KTLS_AES_GCM_128
@@ -163,7 +163,7 @@ int ktls_configure_crypto(const SSL *s, const EVP_CIPHER *c, EVP_CIPHER_CTX *dd,
     unsigned char *iiv = iv;
 
     if (s-&gt;version == TLS1_2_VERSION &amp;&amp;
-        EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) {
+        EVP_CIPHER_get_mode(c) == EVP_CIPH_GCM_MODE) {
         if (!EVP_CIPHER_CTX_get_updated_iv(dd, geniv,
                                            EVP_GCM_TLS_FIXED_IV_LEN
                                            + EVP_GCM_TLS_EXPLICIT_IV_LEN))
@@ -172,7 +172,7 @@ int ktls_configure_crypto(const SSL *s, const EVP_CIPHER *c, EVP_CIPHER_CTX *dd,
     }
 
     memset(crypto_info, 0, sizeof(*crypto_info));
-    switch (EVP_CIPHER_nid(c))
+    switch (EVP_CIPHER_get_nid(c))
     {
 # ifdef OPENSSL_KTLS_AES_GCM_128
     case NID_aes_128_gcm:
@@ -182,7 +182,7 @@ int ktls_configure_crypto(const SSL *s, const EVP_CIPHER *c, EVP_CIPHER_CTX *dd,
         memcpy(crypto_info-&gt;gcm128.iv, iiv + EVP_GCM_TLS_FIXED_IV_LEN,
                 TLS_CIPHER_AES_GCM_128_IV_SIZE);
         memcpy(crypto_info-&gt;gcm128.salt, iiv, TLS_CIPHER_AES_GCM_128_SALT_SIZE);
-        memcpy(crypto_info-&gt;gcm128.key, key, EVP_CIPHER_key_length(c));
+        memcpy(crypto_info-&gt;gcm128.key, key, EVP_CIPHER_get_key_length(c));
         memcpy(crypto_info-&gt;gcm128.rec_seq, rl_sequence,
                 TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE);
         if (rec_seq != NULL)
@@ -197,7 +197,7 @@ int ktls_configure_crypto(const SSL *s, const EVP_CIPHER *c, EVP_CIPHER_CTX *dd,
         memcpy(crypto_info-&gt;gcm256.iv, iiv + EVP_GCM_TLS_FIXED_IV_LEN,
                 TLS_CIPHER_AES_GCM_256_IV_SIZE);
         memcpy(crypto_info-&gt;gcm256.salt, iiv, TLS_CIPHER_AES_GCM_256_SALT_SIZE);
-        memcpy(crypto_info-&gt;gcm256.key, key, EVP_CIPHER_key_length(c));
+        memcpy(crypto_info-&gt;gcm256.key, key, EVP_CIPHER_get_key_length(c));
         memcpy(crypto_info-&gt;gcm256.rec_seq, rl_sequence,
                 TLS_CIPHER_AES_GCM_256_REC_SEQ_SIZE);
         if (rec_seq != NULL)
@@ -212,7 +212,7 @@ int ktls_configure_crypto(const SSL *s, const EVP_CIPHER *c, EVP_CIPHER_CTX *dd,
         memcpy(crypto_info-&gt;ccm128.iv, iiv + EVP_CCM_TLS_FIXED_IV_LEN,
                 TLS_CIPHER_AES_CCM_128_IV_SIZE);
         memcpy(crypto_info-&gt;ccm128.salt, iiv, TLS_CIPHER_AES_CCM_128_SALT_SIZE);
-        memcpy(crypto_info-&gt;ccm128.key, key, EVP_CIPHER_key_length(c));
+        memcpy(crypto_info-&gt;ccm128.key, key, EVP_CIPHER_get_key_length(c));
         memcpy(crypto_info-&gt;ccm128.rec_seq, rl_sequence,
                 TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);
         if (rec_seq != NULL)
@@ -226,7 +226,8 @@ int ktls_configure_crypto(const SSL *s, const EVP_CIPHER *c, EVP_CIPHER_CTX *dd,
         crypto_info-&gt;tls_crypto_info_len = sizeof(crypto_info-&gt;chacha20poly1305);
         memcpy(crypto_info-&gt;chacha20poly1305.iv, iiv,
 		TLS_CIPHER_CHACHA20_POLY1305_IV_SIZE);
-        memcpy(crypto_info-&gt;chacha20poly1305.key, key, EVP_CIPHER_key_length(c));
+        memcpy(crypto_info-&gt;chacha20poly1305.key, key,
+               EVP_CIPHER_get_key_length(c));
         memcpy(crypto_info-&gt;chacha20poly1305.rec_seq, rl_sequence,
                 TLS_CIPHER_CHACHA20_POLY1305_REC_SEQ_SIZE);
         if (rec_seq != NULL)
diff --git a/ssl/record/rec_layer_d1.c b/ssl/record/rec_layer_d1.c
index 6713ff72f5..336ebc8b79 100644
--- a/ssl/record/rec_layer_d1.c
+++ b/ssl/record/rec_layer_d1.c
@@ -837,7 +837,7 @@ int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
     if (clear)
         mac_size = 0;
     else {
-        mac_size = EVP_MD_CTX_size(s-&gt;write_hash);
+        mac_size = EVP_MD_CTX_get_size(s-&gt;write_hash);
         if (mac_size &lt; 0) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR,
                      SSL_R_EXCEEDS_MAX_FRAGMENT_SIZE);
@@ -871,9 +871,9 @@ int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
 
     /* Explicit IV length, block ciphers appropriate version flag */
     if (s-&gt;enc_write_ctx) {
-        int mode = EVP_CIPHER_CTX_mode(s-&gt;enc_write_ctx);
+        int mode = EVP_CIPHER_CTX_get_mode(s-&gt;enc_write_ctx);
         if (mode == EVP_CIPH_CBC_MODE) {
-            eivlen = EVP_CIPHER_CTX_iv_length(s-&gt;enc_write_ctx);
+            eivlen = EVP_CIPHER_CTX_get_iv_length(s-&gt;enc_write_ctx);
             if (eivlen &lt;= 1)
                 eivlen = 0;
         }
diff --git a/ssl/record/rec_layer_s3.c b/ssl/record/rec_layer_s3.c
index 8cd102ecae..a217db772a 100644
--- a/ssl/record/rec_layer_s3.c
+++ b/ssl/record/rec_layer_s3.c
@@ -439,7 +439,7 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, size_t len,
             &amp;&amp; !SSL_WRITE_ETM(s)
             &amp;&amp; SSL_USE_EXPLICIT_IV(s)
             &amp;&amp; BIO_get_ktls_send(s-&gt;wbio) == 0
-            &amp;&amp; (EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(s-&gt;enc_write_ctx))
+            &amp;&amp; (EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(s-&gt;enc_write_ctx))
                 &amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) != 0) {
         unsigned char aad[13];
         EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param;
@@ -588,7 +588,7 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, size_t len,
     }
     if (maxpipes == 0
         || s-&gt;enc_write_ctx == NULL
-        || (EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(s-&gt;enc_write_ctx))
+        || (EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(s-&gt;enc_write_ctx))
             &amp; EVP_CIPH_FLAG_PIPELINE) == 0
         || !SSL_USE_EXPLICIT_IV(s))
         maxpipes = 1;
@@ -723,7 +723,7 @@ int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
         mac_size = 0;
     } else {
         /* TODO(siz_t): Convert me */
-        mac_size = EVP_MD_CTX_size(s-&gt;write_hash);
+        mac_size = EVP_MD_CTX_get_size(s-&gt;write_hash);
         if (mac_size &lt; 0) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
             goto err;
@@ -831,10 +831,10 @@ int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
 
     /* Explicit IV length, block ciphers appropriate version flag */
     if (s-&gt;enc_write_ctx &amp;&amp; SSL_USE_EXPLICIT_IV(s) &amp;&amp; !SSL_TREAT_AS_TLS13(s)) {
-        int mode = EVP_CIPHER_CTX_mode(s-&gt;enc_write_ctx);
+        int mode = EVP_CIPHER_CTX_get_mode(s-&gt;enc_write_ctx);
         if (mode == EVP_CIPH_CBC_MODE) {
             /* TODO(size_t): Convert me */
-            eivlen = EVP_CIPHER_CTX_iv_length(s-&gt;enc_write_ctx);
+            eivlen = EVP_CIPHER_CTX_get_iv_length(s-&gt;enc_write_ctx);
             if (eivlen &lt;= 1)
                 eivlen = 0;
         } else if (mode == EVP_CIPH_GCM_MODE) {
diff --git a/ssl/record/ssl3_record.c b/ssl/record/ssl3_record.c
index 8788d49e4c..8c4ff01dd1 100644
--- a/ssl/record/ssl3_record.c
+++ b/ssl/record/ssl3_record.c
@@ -480,7 +480,7 @@ int ssl3_get_record(SSL *s)
              &amp;&amp; thisrr-&gt;type == SSL3_RT_APPLICATION_DATA
              &amp;&amp; SSL_USE_EXPLICIT_IV(s)
              &amp;&amp; s-&gt;enc_read_ctx != NULL
-             &amp;&amp; (EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(s-&gt;enc_read_ctx))
+             &amp;&amp; (EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(s-&gt;enc_read_ctx))
                  &amp; EVP_CIPH_FLAG_PIPELINE) != 0
              &amp;&amp; ssl3_record_app_data_waiting(s));
 
@@ -526,7 +526,7 @@ int ssl3_get_record(SSL *s)
         const EVP_MD *tmpmd = EVP_MD_CTX_get0_md(s-&gt;read_hash);
 
         if (tmpmd != NULL) {
-            imac_size = EVP_MD_size(tmpmd);
+            imac_size = EVP_MD_get_size(tmpmd);
             if (!ossl_assert(imac_size &gt;= 0 &amp;&amp; imac_size &lt;= EVP_MAX_MD_SIZE)) {
                     SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
                     return -1;
@@ -855,11 +855,11 @@ int ssl3_enc(SSL *s, SSL3_RECORD *inrecs, size_t n_recs, int sending,
         memmove(rec-&gt;data, rec-&gt;input, rec-&gt;length);
         rec-&gt;input = rec-&gt;data;
     } else {
-        int provided = (EVP_CIPHER_provider(enc) != NULL);
+        int provided = (EVP_CIPHER_get0_provider(enc) != NULL);
 
         l = rec-&gt;length;
         /* TODO(size_t): Convert this call */
-        bs = EVP_CIPHER_CTX_block_size(ds);
+        bs = EVP_CIPHER_CTX_get_block_size(ds);
 
         /* COMPRESS */
 
@@ -889,7 +889,7 @@ int ssl3_enc(SSL *s, SSL3_RECORD *inrecs, size_t n_recs, int sending,
             /* otherwise, rec-&gt;length &gt;= bs */
         }
 
-        if (EVP_CIPHER_provider(enc) != NULL) {
+        if (EVP_CIPHER_get0_provider(enc) != NULL) {
             int outlen;
 
             if (!EVP_CipherUpdate(ds, rec-&gt;data, &amp;outlen, rec-&gt;input,
@@ -968,7 +968,7 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
 
     if (sending) {
         if (EVP_MD_CTX_get0_md(s-&gt;write_hash)) {
-            int n = EVP_MD_CTX_size(s-&gt;write_hash);
+            int n = EVP_MD_CTX_get_size(s-&gt;write_hash);
             if (!ossl_assert(n &gt;= 0)) {
                 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
                 return 0;
@@ -983,8 +983,8 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
             enc = EVP_CIPHER_CTX_get0_cipher(s-&gt;enc_write_ctx);
             /* For TLSv1.1 and later explicit IV */
             if (SSL_USE_EXPLICIT_IV(s)
-                &amp;&amp; EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)
-                ivlen = EVP_CIPHER_iv_length(enc);
+                &amp;&amp; EVP_CIPHER_get_mode(enc) == EVP_CIPH_CBC_MODE)
+                ivlen = EVP_CIPHER_get_iv_length(enc);
             else
                 ivlen = 0;
             if (ivlen &gt; 1) {
@@ -1006,7 +1006,7 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
         }
     } else {
         if (EVP_MD_CTX_get0_md(s-&gt;read_hash)) {
-            int n = EVP_MD_CTX_size(s-&gt;read_hash);
+            int n = EVP_MD_CTX_get_size(s-&gt;read_hash);
             if (!ossl_assert(n &gt;= 0)) {
                 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
                 return 0;
@@ -1025,12 +1025,12 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
             recs[ctr].input = recs[ctr].data;
         }
     } else {
-        int provided = (EVP_CIPHER_provider(enc) != NULL);
+        int provided = (EVP_CIPHER_get0_provider(enc) != NULL);
 
-        bs = EVP_CIPHER_block_size(EVP_CIPHER_CTX_get0_cipher(ds));
+        bs = EVP_CIPHER_get_block_size(EVP_CIPHER_CTX_get0_cipher(ds));
 
         if (n_recs &gt; 1) {
-            if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(ds))
+            if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ds))
                   &amp; EVP_CIPH_FLAG_PIPELINE) == 0) {
                 /*
                  * We shouldn't have been called with pipeline data if the
@@ -1043,7 +1043,7 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
         for (ctr = 0; ctr &lt; n_recs; ctr++) {
             reclen[ctr] = recs[ctr].length;
 
-            if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(ds))
+            if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ds))
                         &amp; EVP_CIPH_FLAG_AEAD_CIPHER) != 0) {
                 unsigned char *seq;
 
@@ -1177,10 +1177,10 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
              * any explicit IV
              */
             if (!sending) {
-                if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE) {
+                if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_GCM_MODE) {
                         recs[0].data += EVP_GCM_TLS_EXPLICIT_IV_LEN;
                         recs[0].input += EVP_GCM_TLS_EXPLICIT_IV_LEN;
-                } else if (EVP_CIPHER_mode(enc) == EVP_CIPH_CCM_MODE) {
+                } else if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_CCM_MODE) {
                         recs[0].data += EVP_CCM_TLS_EXPLICIT_IV_LEN;
                         recs[0].input += EVP_CCM_TLS_EXPLICIT_IV_LEN;
                 } else if (bs != 1 &amp;&amp; SSL_USE_EXPLICIT_IV(s)) {
@@ -1215,7 +1215,7 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
             /* TODO(size_t): Convert this call */
             tmpr = EVP_Cipher(ds, recs[0].data, recs[0].input,
                               (unsigned int)reclen[0]);
-            if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(ds))
+            if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ds))
                  &amp; EVP_CIPH_FLAG_CUSTOM_CIPHER) != 0
                 ? (tmpr &lt; 0)
                 : (tmpr == 0)) {
@@ -1225,13 +1225,13 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
 
             if (!sending) {
                 /* Adjust the record to remove the explicit IV/MAC/Tag */
-                if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE) {
+                if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_GCM_MODE) {
                     for (ctr = 0; ctr &lt; n_recs; ctr++) {
                         recs[ctr].data += EVP_GCM_TLS_EXPLICIT_IV_LEN;
                         recs[ctr].input += EVP_GCM_TLS_EXPLICIT_IV_LEN;
                         recs[ctr].length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
                     }
-                } else if (EVP_CIPHER_mode(enc) == EVP_CIPH_CCM_MODE) {
+                } else if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_CCM_MODE) {
                     for (ctr = 0; ctr &lt; n_recs; ctr++) {
                         recs[ctr].data += EVP_CCM_TLS_EXPLICIT_IV_LEN;
                         recs[ctr].input += EVP_CCM_TLS_EXPLICIT_IV_LEN;
@@ -1261,7 +1261,7 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
                                                         : NULL,
                                          bs,
                                          macsize,
-                                         (EVP_CIPHER_flags(enc)
+                                         (EVP_CIPHER_get_flags(enc)
                                          &amp; EVP_CIPH_FLAG_AEAD_CIPHER) != 0,
                                          s-&gt;ctx-&gt;libctx))
                         return 0;
@@ -1283,7 +1283,7 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
  */
 char ssl3_cbc_record_digest_supported(const EVP_MD_CTX *ctx)
 {
-    switch (EVP_MD_CTX_type(ctx)) {
+    switch (EVP_MD_CTX_get_type(ctx)) {
     case NID_md5:
     case NID_sha1:
     case NID_sha224:
@@ -1315,15 +1315,15 @@ int n_ssl3_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int sending)
         hash = ssl-&gt;read_hash;
     }
 
-    t = EVP_MD_CTX_size(hash);
+    t = EVP_MD_CTX_get_size(hash);
     if (t &lt; 0)
         return 0;
     md_size = t;
     npad = (48 / md_size) * md_size;
 
-    if (!sending &amp;&amp;
-        EVP_CIPHER_CTX_mode(ssl-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE &amp;&amp;
-        ssl3_cbc_record_digest_supported(hash)) {
+    if (!sending
+        &amp;&amp; EVP_CIPHER_CTX_get_mode(ssl-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE
+        &amp;&amp; ssl3_cbc_record_digest_supported(hash)) {
 #ifdef OPENSSL_NO_DEPRECATED_3_0
         return 0;
 #else
@@ -1418,7 +1418,7 @@ int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int sending)
         hash = ssl-&gt;read_hash;
     }
 
-    t = EVP_MD_CTX_size(hash);
+    t = EVP_MD_CTX_get_size(hash);
     if (!ossl_assert(t &gt;= 0))
         return 0;
     md_size = t;
@@ -1457,16 +1457,16 @@ int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int sending)
     header[11] = (unsigned char)(rec-&gt;length &gt;&gt; 8);
     header[12] = (unsigned char)(rec-&gt;length &amp; 0xff);
 
-    if (!sending &amp;&amp; !SSL_READ_ETM(ssl) &amp;&amp;
-            EVP_CIPHER_CTX_mode(ssl-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE &amp;&amp;
-            ssl3_cbc_record_digest_supported(mac_ctx)) {
+    if (!sending &amp;&amp; !SSL_READ_ETM(ssl)
+        &amp;&amp; EVP_CIPHER_CTX_get_mode(ssl-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE
+        &amp;&amp; ssl3_cbc_record_digest_supported(mac_ctx)) {
         OSSL_PARAM tls_hmac_params[2], *p = tls_hmac_params;
 
         *p++ = OSSL_PARAM_construct_size_t(OSSL_MAC_PARAM_TLS_DATA_SIZE,
                                            &amp;rec-&gt;orig_len);
         *p++ = OSSL_PARAM_construct_end();
 
-        if (!EVP_PKEY_CTX_set_params(EVP_MD_CTX_pkey_ctx(mac_ctx),
+        if (!EVP_PKEY_CTX_set_params(EVP_MD_CTX_get_pkey_ctx(mac_ctx),
                                      tls_hmac_params))
             return 0;
     }
@@ -1551,7 +1551,7 @@ int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)
         const EVP_MD *tmpmd = EVP_MD_CTX_get0_md(s-&gt;read_hash);
 
         if (tmpmd != NULL) {
-            imac_size = EVP_MD_size(tmpmd);
+            imac_size = EVP_MD_get_size(tmpmd);
             if (!ossl_assert(imac_size &gt;= 0 &amp;&amp; imac_size &lt;= EVP_MAX_MD_SIZE)) {
                     SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
                     return -1;
diff --git a/ssl/record/ssl3_record_tls13.c b/ssl/record/ssl3_record_tls13.c
index 0e4b310148..13c007ae23 100644
--- a/ssl/record/ssl3_record_tls13.c
+++ b/ssl/record/ssl3_record_tls13.c
@@ -62,7 +62,7 @@ int tls13_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending,
         return 1;
     }
 
-    ivlen = EVP_CIPHER_CTX_iv_length(ctx);
+    ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);
 
     if (s-&gt;early_data_state == SSL_EARLY_DATA_WRITING
             || s-&gt;early_data_state == SSL_EARLY_DATA_WRITE_RETRY) {
diff --git a/ssl/s3_enc.c b/ssl/s3_enc.c
index 88ac6e4205..64b246eb65 100644
--- a/ssl/s3_enc.c
+++ b/ssl/s3_enc.c
@@ -186,15 +186,15 @@ int ssl3_change_cipher_state(SSL *s, int which)
         EVP_CIPHER_CTX_reset(dd);
 
     p = s-&gt;s3.tmp.key_block;
-    mdi = EVP_MD_size(m);
+    mdi = EVP_MD_get_size(m);
     if (mdi &lt; 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         goto err;
     }
     i = mdi;
-    cl = EVP_CIPHER_key_length(c);
+    cl = EVP_CIPHER_get_key_length(c);
     j = cl;
-    k = EVP_CIPHER_iv_length(c);
+    k = EVP_CIPHER_get_iv_length(c);
     if ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
         (which == SSL3_CHANGE_CIPHER_SERVER_READ)) {
         ms = &amp;(p[0]);
@@ -225,7 +225,7 @@ int ssl3_change_cipher_state(SSL *s, int which)
         goto err;
     }
 
-    if (EVP_CIPHER_provider(c) != NULL
+    if (EVP_CIPHER_get0_provider(c) != NULL
             &amp;&amp; !tls_provider_set_tls_params(s, dd, c, m)) {
         /* SSLfatal already called */
         goto err;
@@ -266,11 +266,11 @@ int ssl3_setup_key_block(SSL *s)
     s-&gt;s3.tmp.new_compression = comp;
 #endif
 
-    num = EVP_MD_size(hash);
+    num = EVP_MD_get_size(hash);
     if (num &lt; 0)
         return 0;
 
-    num = EVP_CIPHER_key_length(c) + num + EVP_CIPHER_iv_length(c);
+    num = EVP_CIPHER_get_key_length(c) + num + EVP_CIPHER_get_iv_length(c);
     num *= 2;
 
     ssl3_cleanup_key_block(s);
@@ -424,7 +424,7 @@ size_t ssl3_final_finish_mac(SSL *s, const char *sender, size_t len,
         return 0;
     }
 
-    if (EVP_MD_CTX_type(s-&gt;s3.handshake_dgst) != NID_md5_sha1) {
+    if (EVP_MD_CTX_get_type(s-&gt;s3.handshake_dgst) != NID_md5_sha1) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_NO_REQUIRED_DIGEST);
         return 0;
     }
@@ -440,7 +440,7 @@ size_t ssl3_final_finish_mac(SSL *s, const char *sender, size_t len,
         goto err;
     }
 
-    ret = EVP_MD_CTX_size(ctx);
+    ret = EVP_MD_CTX_get_size(ctx);
     if (ret &lt; 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         ret = 0;
diff --git a/ssl/ssl_ciph.c b/ssl/ssl_ciph.c
index 582124aa1f..d7c19feedf 100644
--- a/ssl/ssl_ciph.c
+++ b/ssl/ssl_ciph.c
@@ -346,7 +346,7 @@ int ssl_load_ciphers(SSL_CTX *ctx)
         if (md == NULL) {
             ctx-&gt;disabled_mac_mask |= t-&gt;mask;
         } else {
-            int tmpsize = EVP_MD_size(md);
+            int tmpsize = EVP_MD_get_size(md);
             if (!ossl_assert(tmpsize &gt;= 0))
                 return 0;
             ctx-&gt;ssl_mac_secret_size[i] = tmpsize;
@@ -566,8 +566,9 @@ int ssl_cipher_get_evp(SSL_CTX *ctx, const SSL_SESSION *s,
             *mac_secret_size = ctx-&gt;ssl_mac_secret_size[i];
     }
 
-    if ((*enc != NULL) &amp;&amp;
-        (*md != NULL || (EVP_CIPHER_flags(*enc) &amp; EVP_CIPH_FLAG_AEAD_CIPHER))
+    if ((*enc != NULL)
+        &amp;&amp; (*md != NULL 
+            || (EVP_CIPHER_get_flags(*enc) &amp; EVP_CIPH_FLAG_AEAD_CIPHER))
         &amp;&amp; (!mac_pkey_type || *mac_pkey_type != NID_undef)) {
         const EVP_CIPHER *evp = NULL;
 
@@ -2172,7 +2173,7 @@ int ssl_cipher_get_overhead(const SSL_CIPHER *c, size_t *mac_overhead,
         if (e_md == NULL)
             return 0;
 
-        mac = EVP_MD_size(e_md);
+        mac = EVP_MD_get_size(e_md);
         if (c-&gt;algorithm_enc != SSL_eNULL) {
             int cipher_nid = SSL_CIPHER_get_cipher_nid(c);
             const EVP_CIPHER *e_ciph = EVP_get_cipherbynid(cipher_nid);
@@ -2180,12 +2181,12 @@ int ssl_cipher_get_overhead(const SSL_CIPHER *c, size_t *mac_overhead,
             /* If it wasn't AEAD or SSL_eNULL, we expect it to be a
                known CBC cipher. */
             if (e_ciph == NULL ||
-                EVP_CIPHER_mode(e_ciph) != EVP_CIPH_CBC_MODE)
+                EVP_CIPHER_get_mode(e_ciph) != EVP_CIPH_CBC_MODE)
                 return 0;
 
             in = 1; /* padding length byte */
-            out = EVP_CIPHER_iv_length(e_ciph);
-            blk = EVP_CIPHER_block_size(e_ciph);
+            out = EVP_CIPHER_get_iv_length(e_ciph);
+            blk = EVP_CIPHER_get_block_size(e_ciph);
         }
     }
 
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index af95f2e056..c8ab4a66a0 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -305,7 +305,7 @@ static int dane_tlsa_add(SSL_DANE *dane,
         }
     }
 
-    if (md != NULL &amp;&amp; dlen != (size_t)EVP_MD_size(md)) {
+    if (md != NULL &amp;&amp; dlen != (size_t)EVP_MD_get_size(md)) {
         ERR_raise(ERR_LIB_SSL, SSL_R_DANE_TLSA_BAD_DIGEST_LENGTH);
         return 0;
     }
@@ -4764,7 +4764,7 @@ int ssl_handshake_hash(SSL *s, unsigned char *out, size_t outlen,
 {
     EVP_MD_CTX *ctx = NULL;
     EVP_MD_CTX *hdgst = s-&gt;s3.handshake_dgst;
-    int hashleni = EVP_MD_CTX_size(hdgst);
+    int hashleni = EVP_MD_CTX_get_size(hdgst);
     int ret = 0;
 
     if (hashleni &lt; 0 || (size_t)hashleni &gt; outlen) {
@@ -5898,7 +5898,7 @@ const EVP_CIPHER *ssl_evp_cipher_fetch(OSSL_LIB_CTX *libctx,
 int ssl_evp_cipher_up_ref(const EVP_CIPHER *cipher)
 {
     /* Don't up-ref an implicit EVP_CIPHER */
-    if (EVP_CIPHER_provider(cipher) == NULL)
+    if (EVP_CIPHER_get0_provider(cipher) == NULL)
         return 1;
 
     /*
@@ -5913,7 +5913,7 @@ void ssl_evp_cipher_free(const EVP_CIPHER *cipher)
     if (cipher == NULL)
         return;
 
-    if (EVP_CIPHER_provider(cipher) != NULL) {
+    if (EVP_CIPHER_get0_provider(cipher) != NULL) {
         /*
          * The cipher was explicitly fetched and therefore it is safe to cast
          * away the const
@@ -5942,7 +5942,7 @@ const EVP_MD *ssl_evp_md_fetch(OSSL_LIB_CTX *libctx,
 int ssl_evp_md_up_ref(const EVP_MD *md)
 {
     /* Don't up-ref an implicit EVP_MD */
-    if (EVP_MD_provider(md) == NULL)
+    if (EVP_MD_get0_provider(md) == NULL)
         return 1;
 
     /*
@@ -5957,7 +5957,7 @@ void ssl_evp_md_free(const EVP_MD *md)
     if (md == NULL)
         return;
 
-    if (EVP_MD_provider(md) != NULL) {
+    if (EVP_MD_get0_provider(md) != NULL) {
         /*
          * The digest was explicitly fetched and therefore it is safe to cast
          * away the const
@@ -5969,7 +5969,7 @@ void ssl_evp_md_free(const EVP_MD *md)
 int SSL_set0_tmp_dh_pkey(SSL *s, EVP_PKEY *dhpkey)
 {
     if (!ssl_security(s, SSL_SECOP_TMP_DH,
-                      EVP_PKEY_security_bits(dhpkey), 0, dhpkey)) {
+                      EVP_PKEY_get_security_bits(dhpkey), 0, dhpkey)) {
         ERR_raise(ERR_LIB_SSL, SSL_R_DH_KEY_TOO_SMALL);
         EVP_PKEY_free(dhpkey);
         return 0;
@@ -5982,7 +5982,7 @@ int SSL_set0_tmp_dh_pkey(SSL *s, EVP_PKEY *dhpkey)
 int SSL_CTX_set0_tmp_dh_pkey(SSL_CTX *ctx, EVP_PKEY *dhpkey)
 {
     if (!ssl_ctx_security(ctx, SSL_SECOP_TMP_DH,
-                          EVP_PKEY_security_bits(dhpkey), 0, dhpkey)) {
+                          EVP_PKEY_get_security_bits(dhpkey), 0, dhpkey)) {
         ERR_raise(ERR_LIB_SSL, SSL_R_DH_KEY_TOO_SMALL);
         EVP_PKEY_free(dhpkey);
         return 0;
diff --git a/ssl/statem/extensions.c b/ssl/statem/extensions.c
index 42d591e11e..d12e940704 100644
--- a/ssl/statem/extensions.c
+++ b/ssl/statem/extensions.c
@@ -1453,7 +1453,7 @@ int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart,
 #endif
     const unsigned char *label;
     size_t bindersize, labelsize, hashsize;
-    int hashsizei = EVP_MD_size(md);
+    int hashsizei = EVP_MD_get_size(md);
     int ret = -1;
     int usepskfored = 0;
 
@@ -1587,7 +1587,7 @@ int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart,
         binderout = tmpbinder;
 
     bindersize = hashsize;
-    if (EVP_DigestSignInit_ex(mctx, NULL, EVP_MD_name(md), s-&gt;ctx-&gt;libctx,
+    if (EVP_DigestSignInit_ex(mctx, NULL, EVP_MD_get0_name(md), s-&gt;ctx-&gt;libctx,
                               s-&gt;ctx-&gt;propq, mackey, NULL) &lt;= 0
             || EVP_DigestSignUpdate(mctx, hash, hashsize) &lt;= 0
             || EVP_DigestSignFinal(mctx, binderout, &amp;bindersize) &lt;= 0
diff --git a/ssl/statem/extensions_clnt.c b/ssl/statem/extensions_clnt.c
index fe9f8a9de6..545b2d034f 100644
--- a/ssl/statem/extensions_clnt.c
+++ b/ssl/statem/extensions_clnt.c
@@ -937,7 +937,7 @@ EXT_RETURN tls_construct_ctos_padding(SSL *s, WPACKET *pkt,
              * length.
              */
             hlen +=  PSK_PRE_BINDER_OVERHEAD + s-&gt;session-&gt;ext.ticklen
-                     + EVP_MD_size(md);
+                     + EVP_MD_get_size(md);
         }
     }
 
@@ -1068,7 +1068,7 @@ EXT_RETURN tls_construct_ctos_psk(SSL *s, WPACKET *pkt, unsigned int context,
          */
         agems += s-&gt;session-&gt;ext.tick_age_add;
 
-        reshashsize = EVP_MD_size(mdres);
+        reshashsize = EVP_MD_get_size(mdres);
         s-&gt;ext.tick_identity++;
         dores = 1;
     }
@@ -1097,7 +1097,7 @@ EXT_RETURN tls_construct_ctos_psk(SSL *s, WPACKET *pkt, unsigned int context,
             return EXT_RETURN_FAIL;
         }
 
-        pskhashsize = EVP_MD_size(mdpsk);
+        pskhashsize = EVP_MD_get_size(mdpsk);
     }
 
     /* Create the extension, but skip over the binder for now */
diff --git a/ssl/statem/extensions_srvr.c b/ssl/statem/extensions_srvr.c
index 6b3b33e239..51c3251635 100644
--- a/ssl/statem/extensions_srvr.c
+++ b/ssl/statem/extensions_srvr.c
@@ -1164,7 +1164,8 @@ int tls_parse_ctos_psk(SSL *s, PACKET *pkt, unsigned int context, X509 *x,
 
         md = ssl_md(s-&gt;ctx, sess-&gt;cipher-&gt;algorithm2);
         if (!EVP_MD_is_a(md,
-                EVP_MD_name(ssl_md(s-&gt;ctx, s-&gt;s3.tmp.new_cipher-&gt;algorithm2)))) {
+                EVP_MD_get0_name(ssl_md(s-&gt;ctx,
+                                        s-&gt;s3.tmp.new_cipher-&gt;algorithm2)))) {
             /* The ciphersuite is not compatible with this session. */
             SSL_SESSION_free(sess);
             sess = NULL;
@@ -1179,7 +1180,7 @@ int tls_parse_ctos_psk(SSL *s, PACKET *pkt, unsigned int context, X509 *x,
         return 1;
 
     binderoffset = PACKET_data(pkt) - (const unsigned char *)s-&gt;init_buf-&gt;data;
-    hashsize = EVP_MD_size(md);
+    hashsize = EVP_MD_get_size(md);
 
     if (!PACKET_get_length_prefixed_2(pkt, &amp;binders)) {
         SSLfatal(s, SSL_AD_DECODE_ERROR, SSL_R_BAD_EXTENSION);
diff --git a/ssl/statem/statem_clnt.c b/ssl/statem/statem_clnt.c
index 82bb013865..88b34c6ad1 100644
--- a/ssl/statem/statem_clnt.c
+++ b/ssl/statem/statem_clnt.c
@@ -2083,7 +2083,8 @@ static int tls_process_ske_dhe(SSL *s, PACKET *pkt, EVP_PKEY **pkey)
         goto err;
     }
 
-    if (!ssl_security(s, SSL_SECOP_TMP_DH, EVP_PKEY_security_bits(peer_tmp),
+    if (!ssl_security(s, SSL_SECOP_TMP_DH,
+                      EVP_PKEY_get_security_bits(peer_tmp),
                       0, peer_tmp)) {
         SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_DH_KEY_TOO_SMALL);
         goto err;
@@ -2258,7 +2259,7 @@ MSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)
         }
         if (SSL_USE_SIGALGS(s))
             OSSL_TRACE1(TLS, &quot;USING TLSv1.2 HASH %s\n&quot;,
-                        md == NULL ? &quot;n/a&quot; : EVP_MD_name(md));
+                        md == NULL ? &quot;n/a&quot; : EVP_MD_get0_name(md));
 
         if (!PACKET_get_length_prefixed_2(pkt, &amp;signature)
             || PACKET_remaining(pkt) != 0) {
@@ -2273,7 +2274,7 @@ MSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)
         }
 
         if (EVP_DigestVerifyInit_ex(md_ctx, &amp;pctx,
-                                    md == NULL ? NULL : EVP_MD_name(md),
+                                    md == NULL ? NULL : EVP_MD_get0_name(md),
                                     s-&gt;ctx-&gt;libctx, s-&gt;ctx-&gt;propq, pkey,
                                     NULL) &lt;= 0) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
@@ -2589,7 +2590,7 @@ MSG_PROCESS_RETURN tls_process_new_session_ticket(SSL *s, PACKET *pkt)
     /* This is a standalone message in TLSv1.3, so there is no more to read */
     if (SSL_IS_TLS13(s)) {
         const EVP_MD *md = ssl_handshake_md(s);
-        int hashleni = EVP_MD_size(md);
+        int hashleni = EVP_MD_get_size(md);
         size_t hashlen;
         static const unsigned char nonce_label[] = &quot;resumption&quot;;
 
@@ -2942,7 +2943,7 @@ static int tls_construct_cke_dhe(SSL *s, WPACKET *pkt)
      * stack, we need to zero pad the DHE pub key to the same length
      * as the prime.
      */
-    prime_len = EVP_PKEY_size(ckey);
+    prime_len = EVP_PKEY_get_size(ckey);
     pad_len = prime_len - encoded_pub_len;
     if (pad_len &gt; 0) {
         if (!WPACKET_sub_allocate_bytes_u16(pkt, pad_len, &amp;keybytes)) {
diff --git a/ssl/statem/statem_dtls.c b/ssl/statem/statem_dtls.c
index 1fcd064ea6..8c588fd590 100644
--- a/ssl/statem/statem_dtls.c
+++ b/ssl/statem/statem_dtls.c
@@ -132,17 +132,17 @@ int dtls1_do_write(SSL *s, int type)
 
     if (s-&gt;write_hash) {
         if (s-&gt;enc_write_ctx
-            &amp;&amp; (EVP_CIPHER_flags(EVP_CIPHER_CTX_get0_cipher(s-&gt;enc_write_ctx)) &amp;
+            &amp;&amp; (EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(s-&gt;enc_write_ctx)) &amp;
                 EVP_CIPH_FLAG_AEAD_CIPHER) != 0)
             mac_size = 0;
         else
-            mac_size = EVP_MD_CTX_size(s-&gt;write_hash);
+            mac_size = EVP_MD_CTX_get_size(s-&gt;write_hash);
     } else
         mac_size = 0;
 
     if (s-&gt;enc_write_ctx &amp;&amp;
-        (EVP_CIPHER_CTX_mode(s-&gt;enc_write_ctx) == EVP_CIPH_CBC_MODE))
-        blocksize = 2 * EVP_CIPHER_CTX_block_size(s-&gt;enc_write_ctx);
+        (EVP_CIPHER_CTX_get_mode(s-&gt;enc_write_ctx) == EVP_CIPH_CBC_MODE))
+        blocksize = 2 * EVP_CIPHER_CTX_get_block_size(s-&gt;enc_write_ctx);
     else
         blocksize = 0;
 
diff --git a/ssl/statem/statem_lib.c b/ssl/statem/statem_lib.c
index 800a957ab2..eef2fe4367 100644
--- a/ssl/statem/statem_lib.c
+++ b/ssl/statem/statem_lib.c
@@ -309,7 +309,8 @@ int tls_construct_cert_verify(SSL *s, WPACKET *pkt)
         goto err;
     }
 
-    if (EVP_DigestSignInit_ex(mctx, &amp;pctx, md == NULL ? NULL : EVP_MD_name(md),
+    if (EVP_DigestSignInit_ex(mctx, &amp;pctx,
+                              md == NULL ? NULL : EVP_MD_get0_name(md),
                               s-&gt;ctx-&gt;libctx, s-&gt;ctx-&gt;propq, pkey,
                               NULL) &lt;= 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
@@ -451,7 +452,7 @@ MSG_PROCESS_RETURN tls_process_cert_verify(SSL *s, PACKET *pkt)
 
     if (SSL_USE_SIGALGS(s))
         OSSL_TRACE1(TLS, &quot;USING TLSv1.2 HASH %s\n&quot;,
-                    md == NULL ? &quot;n/a&quot; : EVP_MD_name(md));
+                    md == NULL ? &quot;n/a&quot; : EVP_MD_get0_name(md));
 
     /* Check for broken implementations of GOST ciphersuites */
     /*
@@ -461,10 +462,10 @@ MSG_PROCESS_RETURN tls_process_cert_verify(SSL *s, PACKET *pkt)
 #ifndef OPENSSL_NO_GOST
     if (!SSL_USE_SIGALGS(s)
         &amp;&amp; ((PACKET_remaining(pkt) == 64
-             &amp;&amp; (EVP_PKEY_id(pkey) == NID_id_GostR3410_2001
-                 || EVP_PKEY_id(pkey) == NID_id_GostR3410_2012_256))
+             &amp;&amp; (EVP_PKEY_get_id(pkey) == NID_id_GostR3410_2001
+                 || EVP_PKEY_get_id(pkey) == NID_id_GostR3410_2012_256))
             || (PACKET_remaining(pkt) == 128
-                &amp;&amp; EVP_PKEY_id(pkey) == NID_id_GostR3410_2012_512))) {
+                &amp;&amp; EVP_PKEY_get_id(pkey) == NID_id_GostR3410_2012_512))) {
         len = PACKET_remaining(pkt);
     } else
 #endif
@@ -484,10 +485,10 @@ MSG_PROCESS_RETURN tls_process_cert_verify(SSL *s, PACKET *pkt)
     }
 
     OSSL_TRACE1(TLS, &quot;Using client verify alg %s\n&quot;,
-                md == NULL ? &quot;n/a&quot; : EVP_MD_name(md));
+                md == NULL ? &quot;n/a&quot; : EVP_MD_get0_name(md));
 
     if (EVP_DigestVerifyInit_ex(mctx, &amp;pctx,
-                                md == NULL ? NULL : EVP_MD_name(md),
+                                md == NULL ? NULL : EVP_MD_get0_name(md),
                                 s-&gt;ctx-&gt;libctx, s-&gt;ctx-&gt;propq, pkey,
                                 NULL) &lt;= 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
@@ -495,7 +496,7 @@ MSG_PROCESS_RETURN tls_process_cert_verify(SSL *s, PACKET *pkt)
     }
 #ifndef OPENSSL_NO_GOST
     {
-        int pktype = EVP_PKEY_id(pkey);
+        int pktype = EVP_PKEY_get_id(pkey);
         if (pktype == NID_id_GostR3410_2001
             || pktype == NID_id_GostR3410_2012_256
             || pktype == NID_id_GostR3410_2012_512) {
diff --git a/ssl/statem/statem_srvr.c b/ssl/statem/statem_srvr.c
index 15bcdae387..a954097a39 100644
--- a/ssl/statem/statem_srvr.c
+++ b/ssl/statem/statem_srvr.c
@@ -2480,7 +2480,7 @@ int tls_construct_server_key_exchange(SSL *s, WPACKET *pkt)
             goto err;
         }
         if (!ssl_security(s, SSL_SECOP_TMP_DH,
-                          EVP_PKEY_security_bits(pkdhp), 0, pkdhp)) {
+                          EVP_PKEY_get_security_bits(pkdhp), 0, pkdhp)) {
             SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_DH_KEY_TOO_SMALL);
             goto err;
         }
@@ -2678,7 +2678,7 @@ int tls_construct_server_key_exchange(SSL *s, WPACKET *pkt)
         }
 
         if (EVP_DigestSignInit_ex(md_ctx, &amp;pctx,
-                                  md == NULL ? NULL : EVP_MD_name(md),
+                                  md == NULL ? NULL : EVP_MD_get0_name(md),
                                   s-&gt;ctx-&gt;libctx, s-&gt;ctx-&gt;propq, pkey,
                                   NULL) &lt;= 0) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
@@ -3766,7 +3766,7 @@ static int construct_stateless_ticket(SSL *s, WPACKET *pkt, uint32_t age_add,
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_CALLBACK_FAILED);
             goto err;
         }
-        iv_len = EVP_CIPHER_CTX_iv_length(ctx);
+        iv_len = EVP_CIPHER_CTX_get_iv_length(ctx);
     } else {
         EVP_CIPHER *cipher = EVP_CIPHER_fetch(s-&gt;ctx-&gt;libctx, &quot;AES-256-CBC&quot;,
                                               s-&gt;ctx-&gt;propq);
@@ -3777,7 +3777,7 @@ static int construct_stateless_ticket(SSL *s, WPACKET *pkt, uint32_t age_add,
             goto err;
         }
 
-        iv_len = EVP_CIPHER_iv_length(cipher);
+        iv_len = EVP_CIPHER_get_iv_length(cipher);
         if (iv_len &lt; 0
                 || RAND_bytes_ex(s-&gt;ctx-&gt;libctx, iv, iv_len, 0) &lt;= 0
                 || !EVP_EncryptInit_ex(ctx, cipher, NULL,
@@ -3875,7 +3875,7 @@ int tls_construct_new_session_ticket(SSL *s, WPACKET *pkt)
         uint64_t nonce;
         static const unsigned char nonce_label[] = &quot;resumption&quot;;
         const EVP_MD *md = ssl_handshake_md(s);
-        int hashleni = EVP_MD_size(md);
+        int hashleni = EVP_MD_get_size(md);
 
         /* Ensure cast to size_t is safe */
         if (!ossl_assert(hashleni &gt;= 0)) {
diff --git a/ssl/t1_enc.c b/ssl/t1_enc.c
index 886709bf4a..03a83ee9a0 100644
--- a/ssl/t1_enc.c
+++ b/ssl/t1_enc.c
@@ -52,7 +52,7 @@ static int tls1_PRF(SSL *s,
     EVP_KDF_free(kdf);
     if (kctx == NULL)
         goto err;
-    mdname = EVP_MD_name(md);
+    mdname = EVP_MD_get0_name(md);
     *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
                                             (char *)mdname, 0);
     *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SECRET,
@@ -146,14 +146,14 @@ int tls_provider_set_tls_params(SSL *s, EVP_CIPHER_CTX *ctx,
     size_t macsize = 0;
     int imacsize = -1;
 
-    if ((EVP_CIPHER_flags(ciph) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) == 0
+    if ((EVP_CIPHER_get_flags(ciph) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) == 0
                /*
                 * We look at s-&gt;ext.use_etm instead of SSL_READ_ETM() or
                 * SSL_WRITE_ETM() because this test applies to both reading
                 * and writing.
                 */
             &amp;&amp; !s-&gt;ext.use_etm)
-        imacsize = EVP_MD_size(md);
+        imacsize = EVP_MD_get_size(md);
     if (imacsize &gt;= 0)
         macsize = (size_t)imacsize;
 
@@ -175,12 +175,12 @@ int tls_provider_set_tls_params(SSL *s, EVP_CIPHER_CTX *ctx,
 static int tls_iv_length_within_key_block(const EVP_CIPHER *c)
 {
     /* If GCM/CCM mode only part of IV comes from PRF */
-    if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
+    if (EVP_CIPHER_get_mode(c) == EVP_CIPH_GCM_MODE)
         return EVP_GCM_TLS_FIXED_IV_LEN;
-    else if (EVP_CIPHER_mode(c) == EVP_CIPH_CCM_MODE)
+    else if (EVP_CIPHER_get_mode(c) == EVP_CIPH_CCM_MODE)
         return EVP_CCM_TLS_FIXED_IV_LEN;
     else
-        return EVP_CIPHER_iv_length(c);
+        return EVP_CIPHER_get_iv_length(c);
 }
 
 int tls1_change_cipher_state(SSL *s, int which)
@@ -334,7 +334,7 @@ int tls1_change_cipher_state(SSL *s, int which)
     i = *mac_secret_size = s-&gt;s3.tmp.new_mac_secret_size;
 
     /* TODO(size_t): convert me */
-    cl = EVP_CIPHER_key_length(c);
+    cl = EVP_CIPHER_get_key_length(c);
     j = cl;
     k = tls_iv_length_within_key_block(c);
     if ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
@@ -362,7 +362,7 @@ int tls1_change_cipher_state(SSL *s, int which)
 
     memcpy(mac_secret, ms, i);
 
-    if (!(EVP_CIPHER_flags(c) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)) {
+    if (!(EVP_CIPHER_get_flags(c) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)) {
         if (mac_type == EVP_PKEY_HMAC) {
             mac_key = EVP_PKEY_new_raw_private_key_ex(s-&gt;ctx-&gt;libctx, &quot;HMAC&quot;,
                                                       s-&gt;ctx-&gt;propq, mac_secret,
@@ -377,7 +377,7 @@ int tls1_change_cipher_state(SSL *s, int which)
                                            (int)*mac_secret_size);
         }
         if (mac_key == NULL
-            || EVP_DigestSignInit_ex(mac_ctx, NULL, EVP_MD_name(m),
+            || EVP_DigestSignInit_ex(mac_ctx, NULL, EVP_MD_get0_name(m),
                                      s-&gt;ctx-&gt;libctx, s-&gt;ctx-&gt;propq, mac_key,
                                      NULL) &lt;= 0) {
             EVP_PKEY_free(mac_key);
@@ -392,14 +392,14 @@ int tls1_change_cipher_state(SSL *s, int which)
         BIO_dump_indent(trc_out, ms, i, 4);
     } OSSL_TRACE_END(TLS);
 
-    if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) {
+    if (EVP_CIPHER_get_mode(c) == EVP_CIPH_GCM_MODE) {
         if (!EVP_CipherInit_ex(dd, c, NULL, key, NULL, (which &amp; SSL3_CC_WRITE))
             || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, (int)k,
                                     iv)) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
             goto err;
         }
-    } else if (EVP_CIPHER_mode(c) == EVP_CIPH_CCM_MODE) {
+    } else if (EVP_CIPHER_get_mode(c) == EVP_CIPH_CCM_MODE) {
         int taglen;
         if (s-&gt;s3.tmp.
             new_cipher-&gt;algorithm_enc &amp; (SSL_AES128CCM8 | SSL_AES256CCM8))
@@ -421,13 +421,14 @@ int tls1_change_cipher_state(SSL *s, int which)
         }
     }
     /* Needed for &quot;composite&quot; AEADs, such as RC4-HMAC-MD5 */
-    if ((EVP_CIPHER_flags(c) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) &amp;&amp; *mac_secret_size
+    if ((EVP_CIPHER_get_flags(c) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)
+        &amp;&amp; *mac_secret_size
         &amp;&amp; !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_MAC_KEY,
                                 (int)*mac_secret_size, mac_secret)) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         goto err;
     }
-    if (EVP_CIPHER_provider(c) != NULL
+    if (EVP_CIPHER_get0_provider(c) != NULL
             &amp;&amp; !tls_provider_set_tls_params(s, dd, c, m)) {
         /* SSLfatal already called */
         goto err;
@@ -510,7 +511,7 @@ int tls1_change_cipher_state(SSL *s, int which)
 
     OSSL_TRACE_BEGIN(TLS) {
         BIO_printf(trc_out, &quot;which = %04X, key:\n&quot;, which);
-        BIO_dump_indent(trc_out, key, EVP_CIPHER_key_length(c), 4);
+        BIO_dump_indent(trc_out, key, EVP_CIPHER_get_key_length(c), 4);
         BIO_printf(trc_out, &quot;iv:\n&quot;);
         BIO_dump_indent(trc_out, iv, k, 4);
     } OSSL_TRACE_END(TLS);
@@ -546,7 +547,8 @@ int tls1_setup_key_block(SSL *s)
     s-&gt;s3.tmp.new_hash = hash;
     s-&gt;s3.tmp.new_mac_pkey_type = mac_type;
     s-&gt;s3.tmp.new_mac_secret_size = mac_secret_size;
-    num = mac_secret_size + EVP_CIPHER_key_length(c) + tls_iv_length_within_key_block(c);
+    num = mac_secret_size + EVP_CIPHER_get_key_length(c)
+          + tls_iv_length_within_key_block(c);
     num *= 2;
 
     ssl3_cleanup_key_block(s);
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index 1dc57af43a..d22a794d37 100644
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -357,7 +357,7 @@ static int add_provider_groups(const OSSL_PARAM params[], void *data)
          * assumption to make (in which case perhaps we should document this
          * behaviour)?
          */
-        if (EVP_KEYMGMT_provider(keymgmt) == provider) {
+        if (EVP_KEYMGMT_get0_provider(keymgmt) == provider) {
             /* We have a match - so we will use this group */
             ctx-&gt;group_list_len++;
             ginf = NULL;
@@ -1235,7 +1235,7 @@ int tls1_lookup_md(SSL_CTX *ctx, const SIGALG_LOOKUP *lu, const EVP_MD **pmd)
  * SHA512 has a hash length of 64 bytes, which is incompatible
  * with a 128 byte (1024 bit) key.
  */
-#define RSA_PSS_MINIMUM_KEY_SIZE(md) (2 * EVP_MD_size(md) + 2)
+#define RSA_PSS_MINIMUM_KEY_SIZE(md) (2 * EVP_MD_get_size(md) + 2)
 static int rsa_pss_check_min_key_size(SSL_CTX *ctx, const EVP_PKEY *pkey,
                                       const SIGALG_LOOKUP *lu)
 {
@@ -1245,7 +1245,7 @@ static int rsa_pss_check_min_key_size(SSL_CTX *ctx, const EVP_PKEY *pkey,
         return 0;
     if (!tls1_lookup_md(ctx, lu, &amp;md) || md == NULL)
         return 0;
-    if (EVP_PKEY_size(pkey) &lt; RSA_PSS_MINIMUM_KEY_SIZE(md))
+    if (EVP_PKEY_get_size(pkey) &lt; RSA_PSS_MINIMUM_KEY_SIZE(md))
         return 0;
     return 1;
 }
@@ -1418,10 +1418,10 @@ static int sigalg_security_bits(SSL_CTX *ctx, const SIGALG_LOOKUP *lu)
         return 0;
     if (md != NULL)
     {
-        int md_type = EVP_MD_type(md);
+        int md_type = EVP_MD_get_type(md);
 
         /* Security bits: half digest bits */
-        secbits = EVP_MD_size(md) * 4;
+        secbits = EVP_MD_get_size(md) * 4;
         /*
          * SHA1 and MD5 are known to be broken. Reduce security bits so that
          * they're no longer accepted at security level 1. The real values don't
@@ -1463,7 +1463,7 @@ int tls12_check_peer_sigalg(SSL *s, uint16_t sig, EVP_PKEY *pkey)
     const SIGALG_LOOKUP *lu;
     int secbits = 0;
 
-    pkeyid = EVP_PKEY_id(pkey);
+    pkeyid = EVP_PKEY_get_id(pkey);
     /* Should never happen */
     if (pkeyid == -1)
         return -1;
@@ -1490,7 +1490,7 @@ int tls12_check_peer_sigalg(SSL *s, uint16_t sig, EVP_PKEY *pkey)
         return 0;
     }
     /* Check the sigalg is consistent with the key OID */
-    if (!ssl_cert_lookup_by_nid(EVP_PKEY_id(pkey), &amp;cidx)
+    if (!ssl_cert_lookup_by_nid(EVP_PKEY_get_id(pkey), &amp;cidx)
             || lu-&gt;sig_idx != (int)cidx) {
         SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_SIGNATURE_TYPE);
         return 0;
@@ -1560,7 +1560,7 @@ int tls12_check_peer_sigalg(SSL *s, uint16_t sig, EVP_PKEY *pkey)
     secbits = sigalg_security_bits(s-&gt;ctx, lu);
     if (secbits == 0 ||
         !ssl_security(s, SSL_SECOP_SIGALG_CHECK, secbits,
-                      md != NULL ? EVP_MD_type(md) : NID_undef,
+                      md != NULL ? EVP_MD_get_type(md) : NID_undef,
                       (void *)sigalgstr)) {
         SSLfatal(s, SSL_AD_HANDSHAKE_FAILURE, SSL_R_WRONG_SIGNATURE_TYPE);
         return 0;
@@ -1893,7 +1893,7 @@ SSL_TICKET_STATUS tls_decrypt_ticket(SSL *s, const unsigned char *etick,
 
     /* Sanity check ticket length: must exceed keyname + IV + HMAC */
     if (eticklen &lt;=
-        TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx) + mlen) {
+        TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_get_iv_length(ctx) + mlen) {
         ret = SSL_TICKET_NO_DECRYPT;
         goto end;
     }
@@ -1911,8 +1911,8 @@ SSL_TICKET_STATUS tls_decrypt_ticket(SSL *s, const unsigned char *etick,
     }
     /* Attempt to decrypt session data */
     /* Move p after IV to start of encrypted ticket, update length */
-    p = etick + TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx);
-    eticklen -= TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx);
+    p = etick + TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_get_iv_length(ctx);
+    eticklen -= TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_get_iv_length(ctx);
     sdec = OPENSSL_malloc(eticklen);
     if (sdec == NULL || EVP_DecryptUpdate(ctx, sdec, &amp;slen, p,
                                           (int)eticklen) &lt;= 0) {
@@ -2898,7 +2898,7 @@ EVP_PKEY *ssl_get_auto_dh(SSL *s)
         } else {
             if (s-&gt;s3.tmp.cert == NULL)
                 return NULL;
-            dh_secbits = EVP_PKEY_security_bits(s-&gt;s3.tmp.cert-&gt;privatekey);
+            dh_secbits = EVP_PKEY_get_security_bits(s-&gt;s3.tmp.cert-&gt;privatekey);
         }
     }
 
@@ -2950,7 +2950,7 @@ static int ssl_security_cert_key(SSL *s, SSL_CTX *ctx, X509 *x, int op)
          * reject keys which omit parameters but this only affects DSA and
          * omission of parameters is never (?) done in practice.
          */
-        secbits = EVP_PKEY_security_bits(pkey);
+        secbits = EVP_PKEY_get_security_bits(pkey);
     }
     if (s)
         return ssl_security(s, op, secbits, 0, x);
diff --git a/ssl/tls13_enc.c b/ssl/tls13_enc.c
index dba1e5fb8c..53aeea446b 100644
--- a/ssl/tls13_enc.c
+++ b/ssl/tls13_enc.c
@@ -43,7 +43,7 @@ int tls13_hkdf_expand(SSL *s, const EVP_MD *md, const unsigned char *secret,
     EVP_KDF_CTX *kctx;
     OSSL_PARAM params[5], *p = params;
     int mode = EVP_PKEY_HKDEF_MODE_EXPAND_ONLY;
-    const char *mdname = EVP_MD_name(md);
+    const char *mdname = EVP_MD_get0_name(md);
     int ret;
     size_t hkdflabellen;
     size_t hashlen;
@@ -76,7 +76,7 @@ int tls13_hkdf_expand(SSL *s, const EVP_MD *md, const unsigned char *secret,
         return 0;
     }
 
-    hashlen = EVP_MD_size(md);
+    hashlen = EVP_MD_get_size(md);
 
     if (!WPACKET_init_static_len(&amp;pkt, hkdflabel, sizeof(hkdflabel), 0)
             || !WPACKET_put_bytes_u16(&amp;pkt, outlen)
@@ -185,7 +185,7 @@ int tls13_generate_secret(SSL *s, const EVP_MD *md,
     EVP_KDF_CTX *kctx;
     OSSL_PARAM params[5], *p = params;
     int mode = EVP_PKEY_HKDEF_MODE_EXTRACT_ONLY;
-    const char *mdname = EVP_MD_name(md);
+    const char *mdname = EVP_MD_get0_name(md);
 #ifdef CHARSET_EBCDIC
     static const char derived_secret_label[] = { 0x64, 0x65, 0x72, 0x69, 0x76, 0x65, 0x64, 0x00 };
 #else
@@ -201,7 +201,7 @@ int tls13_generate_secret(SSL *s, const EVP_MD *md,
         return 0;
     }
 
-    mdleni = EVP_MD_size(md);
+    mdleni = EVP_MD_get_size(md);
     /* Ensure cast to size_t is safe */
     if (!ossl_assert(mdleni &gt;= 0)) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
@@ -293,7 +293,7 @@ int tls13_generate_master_secret(SSL *s, unsigned char *out,
 {
     const EVP_MD *md = ssl_handshake_md(s);
 
-    *secret_size = EVP_MD_size(md);
+    *secret_size = EVP_MD_get_size(md);
     /* Calls SSLfatal() if required */
     return tls13_generate_secret(s, md, prev, NULL, 0, out);
 }
@@ -305,7 +305,7 @@ int tls13_generate_master_secret(SSL *s, unsigned char *out,
 size_t tls13_final_finish_mac(SSL *s, const char *str, size_t slen,
                              unsigned char *out)
 {
-    const char *mdname = EVP_MD_name(ssl_handshake_md(s));
+    const char *mdname = EVP_MD_get0_name(ssl_handshake_md(s));
     unsigned char hash[EVP_MAX_MD_SIZE];
     unsigned char finsecret[EVP_MAX_MD_SIZE];
     unsigned char *key = NULL;
@@ -386,7 +386,7 @@ static int derive_secret_key_and_iv(SSL *s, int sending, const EVP_MD *md,
                                     EVP_CIPHER_CTX *ciph_ctx)
 {
     size_t ivlen, keylen, taglen;
-    int hashleni = EVP_MD_size(md);
+    int hashleni = EVP_MD_get_size(md);
     size_t hashlen;
 
     /* Ensure cast to size_t is safe */
@@ -403,8 +403,8 @@ static int derive_secret_key_and_iv(SSL *s, int sending, const EVP_MD *md,
     }
 
     /* TODO(size_t): convert me */
-    keylen = EVP_CIPHER_key_length(ciph);
-    if (EVP_CIPHER_mode(ciph) == EVP_CIPH_CCM_MODE) {
+    keylen = EVP_CIPHER_get_key_length(ciph);
+    if (EVP_CIPHER_get_mode(ciph) == EVP_CIPH_CCM_MODE) {
         uint32_t algenc;
 
         ivlen = EVP_CCM_TLS_IV_LEN;
@@ -425,7 +425,7 @@ static int derive_secret_key_and_iv(SSL *s, int sending, const EVP_MD *md,
          else
             taglen = EVP_CCM_TLS_TAG_LEN;
     } else {
-        ivlen = EVP_CIPHER_iv_length(ciph);
+        ivlen = EVP_CIPHER_get_iv_length(ciph);
         taglen = 0;
     }
 
@@ -611,7 +611,7 @@ int tls13_change_cipher_state(SSL *s, int which)
         } else if (which &amp; SSL3_CC_HANDSHAKE) {
             insecret = s-&gt;handshake_secret;
             finsecret = s-&gt;client_finished_secret;
-            finsecretlen = EVP_MD_size(ssl_handshake_md(s));
+            finsecretlen = EVP_MD_get_size(ssl_handshake_md(s));
             label = client_handshake_traffic;
             labellen = sizeof(client_handshake_traffic) - 1;
             log_label = CLIENT_HANDSHAKE_LABEL;
@@ -643,7 +643,7 @@ int tls13_change_cipher_state(SSL *s, int which)
         if (which &amp; SSL3_CC_HANDSHAKE) {
             insecret = s-&gt;handshake_secret;
             finsecret = s-&gt;server_finished_secret;
-            finsecretlen = EVP_MD_size(ssl_handshake_md(s));
+            finsecretlen = EVP_MD_get_size(ssl_handshake_md(s));
             label = server_handshake_traffic;
             labellen = sizeof(server_handshake_traffic) - 1;
             log_label = SERVER_HANDSHAKE_LABEL;
@@ -798,7 +798,7 @@ int tls13_update_key(SSL *s, int sending)
   static const unsigned char application_traffic[] = &quot;traffic upd&quot;;
 #endif
     const EVP_MD *md = ssl_handshake_md(s);
-    size_t hashlen = EVP_MD_size(md);
+    size_t hashlen = EVP_MD_get_size(md);
     unsigned char key[EVP_MAX_KEY_LENGTH];
     unsigned char *insecret, *iv;
     unsigned char secret[EVP_MAX_MD_SIZE];
diff --git a/test/acvp_test.c b/test/acvp_test.c
index 84009193c2..05a328a6ad 100644
--- a/test/acvp_test.c
+++ b/test/acvp_test.c
@@ -92,7 +92,7 @@ static int sig_gen(EVP_PKEY *pkey, OSSL_PARAM *params, const char *digest_name,
     EVP_MD_CTX *md_ctx = NULL;
     unsigned char *sig = NULL;
     size_t sig_len;
-    size_t sz = EVP_PKEY_size(pkey);
+    size_t sz = EVP_PKEY_get_size(pkey);
 
     if (!TEST_ptr(sig = OPENSSL_malloc(sz))
         || !TEST_ptr(md_ctx = EVP_MD_CTX_new())
diff --git a/test/aesgcmtest.c b/test/aesgcmtest.c
index 1dc3aa86be..c371f4754e 100644
--- a/test/aesgcmtest.c
+++ b/test/aesgcmtest.c
@@ -54,7 +54,7 @@ static int do_encrypt(unsigned char *iv_gen, unsigned char *ct, int *ct_len,
           &amp;&amp; TEST_true(EVP_EncryptUpdate(ctx, ct, ct_len, gcm_pt,
                                          sizeof(gcm_pt)) &gt; 0)
           &amp;&amp; TEST_true(EVP_EncryptFinal_ex(ctx, outbuf, &amp;outlen) &gt; 0)
-          &amp;&amp; TEST_int_eq(EVP_CIPHER_CTX_tag_length(ctx), 16)
+          &amp;&amp; TEST_int_eq(EVP_CIPHER_CTX_get_tag_length(ctx), 16)
           &amp;&amp; TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, 16,
                                            tag) &gt; 0)
           &amp;&amp; TEST_true(iv_gen == NULL
@@ -76,7 +76,7 @@ static int do_decrypt(const unsigned char *iv, const unsigned char *ct,
               &amp;&amp; TEST_true(EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL,
                                               NULL, NULL) &gt; 0)
               &amp;&amp; TEST_true(EVP_DecryptInit_ex(ctx, NULL, NULL, gcm_key, iv) &gt; 0)
-              &amp;&amp; TEST_int_eq(EVP_CIPHER_CTX_tag_length(ctx), 16)
+              &amp;&amp; TEST_int_eq(EVP_CIPHER_CTX_get_tag_length(ctx), 16)
               &amp;&amp; TEST_true(EVP_DecryptUpdate(ctx, NULL, &amp;outlen, gcm_aad,
                                              sizeof(gcm_aad)) &gt; 0)
               &amp;&amp; TEST_true(EVP_DecryptUpdate(ctx, pt, &amp;ptlen, ct,
diff --git a/test/bad_dtls_test.c b/test/bad_dtls_test.c
index a67db1737e..f8c6b142d8 100644
--- a/test/bad_dtls_test.c
+++ b/test/bad_dtls_test.c
@@ -382,7 +382,7 @@ static int send_finished(SSL *s, BIO *rbio)
         return 0;
 
     do_PRF(TLS_MD_SERVER_FINISH_CONST, TLS_MD_SERVER_FINISH_CONST_SIZE,
-           handshake_hash, EVP_MD_CTX_size(handshake_md),
+           handshake_hash, EVP_MD_CTX_get_size(handshake_md),
            NULL, 0,
            finished_msg + DTLS1_HM_HEADER_LENGTH, TLS1_FINISH_MAC_LENGTH);
 
diff --git a/test/defltfips_test.c b/test/defltfips_test.c
index a8349211b6..21c5e1524d 100644
--- a/test/defltfips_test.c
+++ b/test/defltfips_test.c
@@ -36,7 +36,8 @@ static int test_is_fips_enabled(void)
     if (!TEST_ptr(sha256))
         return 0;
     if (is_fips
-            &amp;&amp; !TEST_str_eq(OSSL_PROVIDER_name(EVP_MD_provider(sha256)), &quot;fips&quot;)) {
+        &amp;&amp; !TEST_str_eq(OSSL_PROVIDER_get0_name(EVP_MD_get0_provider(sha256)),
+                        &quot;fips&quot;)) {
         EVP_MD_free(sha256);
         return 0;
     }
diff --git a/test/drbgtest.c b/test/drbgtest.c
index ad5266ce3e..a6fd46595a 100644
--- a/test/drbgtest.c
+++ b/test/drbgtest.c
@@ -81,7 +81,7 @@ static int rand_priv_bytes(unsigned char *buf, int num)
  */
 static int state(EVP_RAND_CTX *drbg)
 {
-    return EVP_RAND_state(drbg);
+    return EVP_RAND_get_state(drbg);
 }
 
 static unsigned int query_rand_uint(EVP_RAND_CTX *drbg, const char *name)
diff --git a/test/ecdsatest.c b/test/ecdsatest.c
index 66ab2bc930..c94d7d8dab 100644
--- a/test/ecdsatest.c
+++ b/test/ecdsatest.c
@@ -179,7 +179,7 @@ static int set_sm2_id(EVP_MD_CTX *mctx, EVP_PKEY *pkey)
     static const char sm2_id[] = { 1, 2, 3, 4, 'l', 'e', 't', 't', 'e', 'r' };
     EVP_PKEY_CTX *pctx;
 
-    if (!TEST_ptr(pctx = EVP_MD_CTX_pkey_ctx(mctx))
+    if (!TEST_ptr(pctx = EVP_MD_CTX_get_pkey_ctx(mctx))
         || !TEST_int_gt(EVP_PKEY_CTX_set1_id(pctx, sm2_id, sizeof(sm2_id)), 0))
         return 0;
     return 1;
diff --git a/test/endecoder_legacy_test.c b/test/endecoder_legacy_test.c
index b3bd4f5872..121e2de3d4 100644
--- a/test/endecoder_legacy_test.c
+++ b/test/endecoder_legacy_test.c
@@ -518,7 +518,7 @@ static int test_key(int idx)
     if (!TEST_ptr(pkey = key-&gt;key)
         || !TEST_true(evp_pkey_copy_downgraded(&amp;downgraded_pkey, pkey))
         || !TEST_ptr(downgraded_pkey)
-        || !TEST_int_eq(EVP_PKEY_id(downgraded_pkey), key-&gt;evp_type)
+        || !TEST_int_eq(EVP_PKEY_get_id(downgraded_pkey), key-&gt;evp_type)
         || !TEST_ptr(legacy_obj = EVP_PKEY_get0(downgraded_pkey)))
         goto end;
 
diff --git a/test/enginetest.c b/test/enginetest.c
index 67e4941cdf..64d31acadb 100644
--- a/test/enginetest.c
+++ b/test/enginetest.c
@@ -260,7 +260,7 @@ static int test_redirect(void)
     if (!TEST_ptr(pkey = get_test_pkey()))
         goto err;
 
-    len = EVP_PKEY_size(pkey);
+    len = EVP_PKEY_get_size(pkey);
     if (!TEST_ptr(tmp = OPENSSL_malloc(len)))
         goto err;
 
diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c
index 10ab4bfc9e..f91784b3a9 100644
--- a/test/evp_extra_test.c
+++ b/test/evp_extra_test.c
@@ -844,7 +844,7 @@ static int test_EVP_Enveloped(int n)
         goto err;
 
     if (!TEST_ptr(keypair = load_example_rsa_key())
-            || !TEST_ptr(kek = OPENSSL_zalloc(EVP_PKEY_size(keypair)))
+            || !TEST_ptr(kek = OPENSSL_zalloc(EVP_PKEY_get_size(keypair)))
             || !TEST_ptr(ctx = EVP_CIPHER_CTX_new())
             || !TEST_true(EVP_SealInit(ctx, type, &amp;kek, &amp;kek_len, iv,
                                        &amp;keypair, 1))
@@ -1088,7 +1088,7 @@ static int test_d2i_AutoPrivateKey(int i)
     p = input;
     if (!TEST_ptr(pkey = d2i_AutoPrivateKey(NULL, &amp;p, input_len))
             || !TEST_ptr_eq(p, input + input_len)
-            || !TEST_int_eq(EVP_PKEY_id(pkey), expected_id))
+            || !TEST_int_eq(EVP_PKEY_get_id(pkey), expected_id))
         goto done;
 
     ret = 1;
@@ -1734,7 +1734,7 @@ static int test_EVP_PKEY_check(int i)
     if (!TEST_ptr(pkey = load_example_key(ak-&gt;keytype, input, input_len)))
         goto done;
     if (type == 0
-        &amp;&amp; !TEST_int_eq(EVP_PKEY_id(pkey), expected_id))
+        &amp;&amp; !TEST_int_eq(EVP_PKEY_get_id(pkey), expected_id))
         goto done;
 
     if (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_pkey(testctx, pkey, testpropq)))
@@ -2334,11 +2334,11 @@ static int test_EVP_PKEY_set1_DH(void)
         goto err;
 
     if(!TEST_true(EVP_PKEY_set1_DH(pkey1, x942dh))
-            || !TEST_int_eq(EVP_PKEY_id(pkey1), EVP_PKEY_DHX))
+            || !TEST_int_eq(EVP_PKEY_get_id(pkey1), EVP_PKEY_DHX))
         goto err;
 
     if(!TEST_true(EVP_PKEY_set1_DH(pkey2, noqdh))
-            || !TEST_int_eq(EVP_PKEY_id(pkey2), EVP_PKEY_DH))
+            || !TEST_int_eq(EVP_PKEY_get_id(pkey2), EVP_PKEY_DH))
         goto err;
 
     ret = 1;
@@ -2616,7 +2616,7 @@ static int test_evp_iv_aes(int idx)
             || !TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, iv, sizeof(iv)))
             || !TEST_true(EVP_EncryptFinal_ex(ctx, ciphertext, &amp;len)))
         goto err;
-    ivlen = EVP_CIPHER_CTX_iv_length(ctx);
+    ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);
     if (!TEST_mem_eq(init_iv, ivlen, oiv, ivlen)
             || !TEST_mem_eq(ref_iv, ref_len, iv, ivlen))
         goto err;
@@ -2727,7 +2727,7 @@ static int test_evp_iv_des(int idx)
             || !TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, iv, sizeof(iv)))
             || !TEST_true(EVP_EncryptFinal_ex(ctx, ciphertext, &amp;len)))
         goto err;
-    ivlen = EVP_CIPHER_CTX_iv_length(ctx);
+    ivlen = EVP_CIPHER_CTX_get_iv_length(ctx);
     if (!TEST_mem_eq(init_iv, ivlen, oiv, ivlen)
             || !TEST_mem_eq(ref_iv, ref_len, iv, ivlen))
         goto err;
diff --git a/test/evp_extra_test2.c b/test/evp_extra_test2.c
index e480ae9555..d932b73dd7 100644
--- a/test/evp_extra_test2.c
+++ b/test/evp_extra_test2.c
@@ -275,7 +275,7 @@ static int test_d2i_AutoPrivateKey_ex(int i)
     if (!TEST_ptr(pkey = d2i_AutoPrivateKey_ex(NULL, &amp;p, input_len, mainctx,
                                                NULL))
             || !TEST_ptr_eq(p, input + input_len)
-            || !TEST_int_eq(EVP_PKEY_id(pkey), expected_id))
+            || !TEST_int_eq(EVP_PKEY_get_id(pkey), expected_id))
         goto done;
 
     if (ak-&gt;evptype == EVP_PKEY_RSA) {
diff --git a/test/evp_fetch_prov_test.c b/test/evp_fetch_prov_test.c
index 07cf79d8ae..fc10bdad57 100644
--- a/test/evp_fetch_prov_test.c
+++ b/test/evp_fetch_prov_test.c
@@ -149,8 +149,8 @@ static int test_md(const EVP_MD *md)
     return TEST_ptr(md)
         &amp;&amp; TEST_true(EVP_MD_is_a(md, &quot;SHA256&quot;))
         &amp;&amp; TEST_true(calculate_digest(md, testmsg, sizeof(testmsg), exptd))
-        &amp;&amp; TEST_int_eq(EVP_MD_size(md), SHA256_DIGEST_LENGTH)
-        &amp;&amp; TEST_int_eq(EVP_MD_block_size(md), SHA256_CBLOCK);
+        &amp;&amp; TEST_int_eq(EVP_MD_get_size(md), SHA256_DIGEST_LENGTH)
+        &amp;&amp; TEST_int_eq(EVP_MD_get_block_size(md), SHA256_CBLOCK);
 }
 
 static int test_implicit_EVP_MD_fetch(void)
diff --git a/test/evp_kdf_test.c b/test/evp_kdf_test.c
index ed7407255a..94d2b0ac58 100644
--- a/test/evp_kdf_test.c
+++ b/test/evp_kdf_test.c
@@ -1352,8 +1352,8 @@ static int test_kdfs_same( EVP_KDF *kdf1, EVP_KDF *kdf2)
      * because without the algorithm in the cache, fetching it a second time
      * will result in a different pointer.
      */
-    return TEST_ptr_eq(EVP_KDF_provider(kdf1), EVP_KDF_provider(kdf2))
-           &amp;&amp; TEST_str_eq(EVP_KDF_name(kdf1), EVP_KDF_name(kdf2));
+    return TEST_ptr_eq(EVP_KDF_get0_provider(kdf1), EVP_KDF_get0_provider(kdf2))
+           &amp;&amp; TEST_str_eq(EVP_KDF_get0_name(kdf1), EVP_KDF_get0_name(kdf2));
 }
 
 static int test_kdf_get_kdf(void)
diff --git a/test/evp_libctx_test.c b/test/evp_libctx_test.c
index f51de88c55..b9794b6b7d 100644
--- a/test/evp_libctx_test.c
+++ b/test/evp_libctx_test.c
@@ -349,10 +349,10 @@ static int test_cipher_reinit(int test_id)
         goto err;
 
     /* ccm fails on the second update - this matches OpenSSL 1_1_1 behaviour */
-    ccm = (EVP_CIPHER_mode(cipher) == EVP_CIPH_CCM_MODE);
+    ccm = (EVP_CIPHER_get_mode(cipher) == EVP_CIPH_CCM_MODE);
 
     /* siv cannot be called with NULL key as the iv is irrelevant */
-    siv = (EVP_CIPHER_mode(cipher) == EVP_CIPH_SIV_MODE);
+    siv = (EVP_CIPHER_get_mode(cipher) == EVP_CIPH_SIV_MODE);
 
     /*
      * Skip init call with a null key for RC4 as the stream cipher does not
@@ -439,14 +439,14 @@ static int test_cipher_reinit_partialupdate(int test_id)
     if (!TEST_ptr(cipher = EVP_CIPHER_fetch(libctx, name, NULL)))
         goto err;
 
-    in_len = EVP_CIPHER_block_size(cipher) / 2;
+    in_len = EVP_CIPHER_get_block_size(cipher) / 2;
 
     /* skip any ciphers that don't allow partial updates */
-    if (((EVP_CIPHER_flags(cipher)
+    if (((EVP_CIPHER_get_flags(cipher)
           &amp; (EVP_CIPH_FLAG_CTS | EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) != 0)
-        || EVP_CIPHER_mode(cipher) == EVP_CIPH_CCM_MODE
-        || EVP_CIPHER_mode(cipher) == EVP_CIPH_XTS_MODE
-        || EVP_CIPHER_mode(cipher) == EVP_CIPH_WRAP_MODE) {
+        || EVP_CIPHER_get_mode(cipher) == EVP_CIPH_CCM_MODE
+        || EVP_CIPHER_get_mode(cipher) == EVP_CIPH_XTS_MODE
+        || EVP_CIPHER_get_mode(cipher) == EVP_CIPH_WRAP_MODE) {
         ret = 1;
         goto err;
     }
@@ -460,7 +460,7 @@ static int test_cipher_reinit_partialupdate(int test_id)
     if (!TEST_mem_eq(out1, out1_len, out2, out2_len))
         goto err;
 
-    if (EVP_CIPHER_mode(cipher) != EVP_CIPH_SIV_MODE) {
+    if (EVP_CIPHER_get_mode(cipher) != EVP_CIPH_SIV_MODE) {
         if (!TEST_true(EVP_EncryptInit_ex(ctx, NULL, NULL, NULL, iv))
             || !TEST_true(EVP_EncryptUpdate(ctx, out3, &amp;out3_len, in, in_len)))
             goto err;
@@ -484,7 +484,7 @@ static int name_cmp(const char * const *a, const char * const *b)
 static void collect_cipher_names(EVP_CIPHER *cipher, void *cipher_names_list)
 {
     STACK_OF(OPENSSL_STRING) *names = cipher_names_list;
-    const char *name = EVP_CIPHER_name(cipher);
+    const char *name = EVP_CIPHER_get0_name(cipher);
     char *namedup = NULL;
 
     assert(name != NULL);
diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c
index 681a8e5846..92b3614f6e 100644
--- a/test/evp_pkey_provided_test.c
+++ b/test/evp_pkey_provided_test.c
@@ -346,9 +346,9 @@ static int test_fromdata_rsa(void)
 
     while (dup_pk == NULL) {
         ret = 0;
-        if (!TEST_int_eq(EVP_PKEY_bits(pk), 32)
-            || !TEST_int_eq(EVP_PKEY_security_bits(pk), 8)
-            || !TEST_int_eq(EVP_PKEY_size(pk), 4)
+        if (!TEST_int_eq(EVP_PKEY_get_bits(pk), 32)
+            || !TEST_int_eq(EVP_PKEY_get_security_bits(pk), 8)
+            || !TEST_int_eq(EVP_PKEY_get_size(pk), 4)
             || !TEST_false(EVP_PKEY_missing_parameters(pk)))
             goto err;
 
@@ -528,9 +528,9 @@ static int test_fromdata_dh_named_group(void)
 
     while (dup_pk == NULL) {
         ret = 0;
-        if (!TEST_int_eq(EVP_PKEY_bits(pk), 2048)
-            || !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)
-            || !TEST_int_eq(EVP_PKEY_size(pk), 256)
+        if (!TEST_int_eq(EVP_PKEY_get_bits(pk), 2048)
+            || !TEST_int_eq(EVP_PKEY_get_security_bits(pk), 112)
+            || !TEST_int_eq(EVP_PKEY_get_size(pk), 256)
             || !TEST_false(EVP_PKEY_missing_parameters(pk)))
             goto err;
 
@@ -709,9 +709,9 @@ static int test_fromdata_dh_fips186_4(void)
 
     while (dup_pk == NULL) {
         ret = 0;
-        if (!TEST_int_eq(EVP_PKEY_bits(pk), 2048)
-            || !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)
-            || !TEST_int_eq(EVP_PKEY_size(pk), 256)
+        if (!TEST_int_eq(EVP_PKEY_get_bits(pk), 2048)
+            || !TEST_int_eq(EVP_PKEY_get_security_bits(pk), 112)
+            || !TEST_int_eq(EVP_PKEY_get_size(pk), 256)
             || !TEST_false(EVP_PKEY_missing_parameters(pk)))
             goto err;
 
@@ -1016,9 +1016,9 @@ static int test_fromdata_ecx(int tst)
 
     while (dup_pk == NULL) {
         ret = 0;
-        if (!TEST_int_eq(EVP_PKEY_bits(pk), bits)
-            || !TEST_int_eq(EVP_PKEY_security_bits(pk), security_bits)
-            || !TEST_int_eq(EVP_PKEY_size(pk), size)
+        if (!TEST_int_eq(EVP_PKEY_get_bits(pk), bits)
+            || !TEST_int_eq(EVP_PKEY_get_security_bits(pk), security_bits)
+            || !TEST_int_eq(EVP_PKEY_get_size(pk), size)
             || !TEST_false(EVP_PKEY_missing_parameters(pk)))
             goto err;
 
@@ -1154,9 +1154,9 @@ static int test_fromdata_ec(void)
 
     while (dup_pk == NULL) {
         ret = 0;
-        if (!TEST_int_eq(EVP_PKEY_bits(pk), 256)
-            || !TEST_int_eq(EVP_PKEY_security_bits(pk), 128)
-            || !TEST_int_eq(EVP_PKEY_size(pk), 2 + 35 * 2)
+        if (!TEST_int_eq(EVP_PKEY_get_bits(pk), 256)
+            || !TEST_int_eq(EVP_PKEY_get_security_bits(pk), 128)
+            || !TEST_int_eq(EVP_PKEY_get_size(pk), 2 + 35 * 2)
             || !TEST_false(EVP_PKEY_missing_parameters(pk)))
             goto err;
 
@@ -1459,9 +1459,9 @@ static int test_fromdata_dsa_fips186_4(void)
 
     while (dup_pk == NULL) {
         ret = 0;
-        if (!TEST_int_eq(EVP_PKEY_bits(pk), 2048)
-            || !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)
-            || !TEST_int_eq(EVP_PKEY_size(pk), 2 + 2 * (3 + sizeof(q_data)))
+        if (!TEST_int_eq(EVP_PKEY_get_bits(pk), 2048)
+            || !TEST_int_eq(EVP_PKEY_get_security_bits(pk), 112)
+            || !TEST_int_eq(EVP_PKEY_get_size(pk), 2 + 2 * (3 + sizeof(q_data)))
             || !TEST_false(EVP_PKEY_missing_parameters(pk)))
             goto err;
 
diff --git a/test/evp_test.c b/test/evp_test.c
index bf4777eb56..059de1251f 100644
--- a/test/evp_test.c
+++ b/test/evp_test.c
@@ -431,7 +431,7 @@ static int digest_test_run(EVP_TEST *t)
         goto err;
     }
 
-    if (EVP_MD_flags(expected-&gt;digest) &amp; EVP_MD_FLAG_XOF) {
+    if (EVP_MD_get_flags(expected-&gt;digest) &amp; EVP_MD_FLAG_XOF) {
         EVP_MD_CTX *mctx_cpy;
         char dont[] = &quot;touch&quot;;
 
@@ -541,13 +541,13 @@ static int cipher_test_init(EVP_TEST *t, const char *alg)
     cdat-&gt;cipher = cipher;
     cdat-&gt;fetched_cipher = fetched_cipher;
     cdat-&gt;enc = -1;
-    m = EVP_CIPHER_mode(cipher);
+    m = EVP_CIPHER_get_mode(cipher);
     if (m == EVP_CIPH_GCM_MODE
             || m == EVP_CIPH_OCB_MODE
             || m == EVP_CIPH_SIV_MODE
             || m == EVP_CIPH_CCM_MODE)
         cdat-&gt;aead = m;
-    else if (EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)
+    else if (EVP_CIPHER_get_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)
         cdat-&gt;aead = -1;
     else
         cdat-&gt;aead = 0;
@@ -714,7 +714,7 @@ static int cipher_test_enc(EVP_TEST *t, int enc,
                 t-&gt;err = &quot;INVALID_IV_LENGTH&quot;;
                 goto err;
             }
-        } else if (expected-&gt;iv_len != (size_t)EVP_CIPHER_CTX_iv_length(ctx_base)) {
+        } else if (expected-&gt;iv_len != (size_t)EVP_CIPHER_CTX_get_iv_length(ctx_base)) {
             t-&gt;err = &quot;INVALID_IV_LENGTH&quot;;
             goto err;
         }
@@ -770,9 +770,9 @@ static int cipher_test_enc(EVP_TEST *t, int enc,
         /* Some (e.g., GCM) tests use IVs longer than EVP_MAX_IV_LENGTH. */
         unsigned char iv[128];
         if (!TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx_base, iv, sizeof(iv)))
-                || ((EVP_CIPHER_flags(expected-&gt;cipher) &amp; EVP_CIPH_CUSTOM_IV) == 0
-                    &amp;&amp; !TEST_mem_eq(expected-&gt;iv, expected-&gt;iv_len, iv,
-                                    expected-&gt;iv_len))) {
+            || ((EVP_CIPHER_get_flags(expected-&gt;cipher) &amp; EVP_CIPH_CUSTOM_IV) == 0
+                &amp;&amp; !TEST_mem_eq(expected-&gt;iv, expected-&gt;iv_len, iv,
+                                expected-&gt;iv_len))) {
             t-&gt;err = &quot;INVALID_IV&quot;;
             goto err;
         }
@@ -894,9 +894,9 @@ static int cipher_test_enc(EVP_TEST *t, int enc,
         /* Some (e.g., GCM) tests use IVs longer than EVP_MAX_IV_LENGTH. */
         unsigned char iv[128];
         if (!TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, iv, sizeof(iv)))
-                || ((EVP_CIPHER_flags(expected-&gt;cipher) &amp; EVP_CIPH_CUSTOM_IV) == 0
-                    &amp;&amp; !TEST_mem_eq(expected-&gt;next_iv, expected-&gt;iv_len, iv,
-                                    expected-&gt;iv_len))) {
+            || ((EVP_CIPHER_get_flags(expected-&gt;cipher) &amp; EVP_CIPH_CUSTOM_IV) == 0
+                &amp;&amp; !TEST_mem_eq(expected-&gt;next_iv, expected-&gt;iv_len, iv,
+                                expected-&gt;iv_len))) {
             t-&gt;err = &quot;INVALID_NEXT_IV&quot;;
             goto err;
         }
@@ -922,9 +922,9 @@ static int cipher_test_run(EVP_TEST *t)
         t-&gt;err = &quot;NO_KEY&quot;;
         return 0;
     }
-    if (!cdat-&gt;iv &amp;&amp; EVP_CIPHER_iv_length(cdat-&gt;cipher)) {
+    if (!cdat-&gt;iv &amp;&amp; EVP_CIPHER_get_iv_length(cdat-&gt;cipher)) {
         /* IV is optional and usually omitted in wrap mode */
-        if (EVP_CIPHER_mode(cdat-&gt;cipher) != EVP_CIPH_WRAP_MODE) {
+        if (EVP_CIPHER_get_mode(cdat-&gt;cipher) != EVP_CIPH_WRAP_MODE) {
             t-&gt;err = &quot;NO_IV&quot;;
             return 0;
         }
@@ -976,10 +976,10 @@ static int cipher_test_run(EVP_TEST *t)
              * lengths so we don't fragment for those
              */
             if (cdat-&gt;aead == EVP_CIPH_CCM_MODE
-                    || ((EVP_CIPHER_flags(cdat-&gt;cipher) &amp; EVP_CIPH_FLAG_CTS) != 0)
-                    || EVP_CIPHER_mode(cdat-&gt;cipher) == EVP_CIPH_SIV_MODE
-                    || EVP_CIPHER_mode(cdat-&gt;cipher) == EVP_CIPH_XTS_MODE
-                    || EVP_CIPHER_mode(cdat-&gt;cipher) == EVP_CIPH_WRAP_MODE)
+                || ((EVP_CIPHER_get_flags(cdat-&gt;cipher) &amp; EVP_CIPH_FLAG_CTS) != 0)
+                || EVP_CIPHER_get_mode(cdat-&gt;cipher) == EVP_CIPH_SIV_MODE
+                || EVP_CIPHER_get_mode(cdat-&gt;cipher) == EVP_CIPH_XTS_MODE
+                || EVP_CIPHER_get_mode(cdat-&gt;cipher) == EVP_CIPH_WRAP_MODE)
                 break;
             out_misalign = 0;
             frag++;
@@ -1959,7 +1959,8 @@ static int pbe_test_run(EVP_TEST *t)
         }
 #endif
     } else if (expected-&gt;pbe_type == PBE_TYPE_PKCS12) {
-        fetched_digest = EVP_MD_fetch(libctx, EVP_MD_name(expected-&gt;md), NULL);
+        fetched_digest = EVP_MD_fetch(libctx, EVP_MD_get0_name(expected-&gt;md),
+                                      NULL);
         if (fetched_digest == NULL) {
             t-&gt;err = &quot;PKCS12_ERROR&quot;;
             goto err;
@@ -2332,7 +2333,7 @@ static int rand_test_run(EVP_TEST *t)
     if (!TEST_true(EVP_RAND_CTX_set_params(expected-&gt;ctx, params)))
         goto err;
 
-    strength = EVP_RAND_strength(expected-&gt;ctx);
+    strength = EVP_RAND_get_strength(expected-&gt;ctx);
     for (i = 0; i &lt;= expected-&gt;n; i++) {
         item = expected-&gt;data + i;
 
@@ -2401,7 +2402,7 @@ static int rand_test_run(EVP_TEST *t)
         if (!TEST_true(EVP_RAND_uninstantiate(expected-&gt;ctx))
                 || !TEST_true(EVP_RAND_uninstantiate(expected-&gt;parent))
                 || !TEST_true(EVP_RAND_verify_zeroization(expected-&gt;ctx))
-                || !TEST_int_eq(EVP_RAND_state(expected-&gt;ctx),
+                || !TEST_int_eq(EVP_RAND_get_state(expected-&gt;ctx),
                                 EVP_RAND_STATE_UNINITIALISED))
             goto err;
     }
@@ -2971,7 +2972,7 @@ static int digestsigver_test_parse(EVP_TEST *t,
     if (strcmp(keyword, &quot;Key&quot;) == 0) {
         EVP_PKEY *pkey = NULL;
         int rv = 0;
-        const char *name = mdata-&gt;md == NULL ? NULL : EVP_MD_name(mdata-&gt;md);
+        const char *name = mdata-&gt;md == NULL ? NULL : EVP_MD_get0_name(mdata-&gt;md);
 
         if (mdata-&gt;is_verify)
             rv = find_key(&amp;pkey, value, public_keys);
diff --git a/test/helpers/handshake.c b/test/helpers/handshake.c
index bba78f6d79..97255306da 100644
--- a/test/helpers/handshake.c
+++ b/test/helpers/handshake.c
@@ -1240,7 +1240,7 @@ static int pkey_type(EVP_PKEY *pkey)
             return NID_undef;
         return OBJ_txt2nid(name);
     }
-    return EVP_PKEY_id(pkey);
+    return EVP_PKEY_get_id(pkey);
 }
 
 static int peer_pkey_type(SSL *s)
diff --git a/test/provider_fallback_test.c b/test/provider_fallback_test.c
index 79765d9b65..116a2f4965 100644
--- a/test/provider_fallback_test.c
+++ b/test/provider_fallback_test.c
@@ -20,8 +20,8 @@ static int test_provider(OSSL_LIB_CTX *ctx)
 
     ok = TEST_true(OSSL_PROVIDER_available(ctx, &quot;default&quot;))
         &amp;&amp; TEST_ptr(rsameth = EVP_KEYMGMT_fetch(ctx, &quot;RSA&quot;, NULL))
-        &amp;&amp; TEST_ptr(prov = EVP_KEYMGMT_provider(rsameth))
-        &amp;&amp; TEST_str_eq(OSSL_PROVIDER_name(prov), &quot;default&quot;);
+        &amp;&amp; TEST_ptr(prov = EVP_KEYMGMT_get0_provider(rsameth))
+        &amp;&amp; TEST_str_eq(OSSL_PROVIDER_get0_name(prov), &quot;default&quot;);
 
     EVP_KEYMGMT_free(rsameth);
     return ok;
diff --git a/test/provider_internal_test.c b/test/provider_internal_test.c
index 6c295451c1..7a37ef8c24 100644
--- a/test/provider_internal_test.c
+++ b/test/provider_internal_test.c
@@ -118,7 +118,7 @@ static int test_cache_flushes(void)
         goto err;
 
     if (!TEST_ptr_null(md = EVP_MD_fetch(ctx, &quot;SHA256&quot;, NULL))) {
-        const char *provname = OSSL_PROVIDER_name(EVP_MD_provider(md));
+        const char *provname = OSSL_PROVIDER_get0_name(EVP_MD_get0_provider(md));
 
         if (OSSL_PROVIDER_available(NULL, provname))
             TEST_info(&quot;%s provider is available\n&quot;, provname);
diff --git a/test/ssl_old_test.c b/test/ssl_old_test.c
index ad9a4a256c..c779b72371 100644
--- a/test/ssl_old_test.c
+++ b/test/ssl_old_test.c
@@ -717,7 +717,7 @@ static void sv_usage(void)
 
 static void print_key_details(BIO *out, EVP_PKEY *key)
 {
-    int keyid = EVP_PKEY_id(key);
+    int keyid = EVP_PKEY_get_id(key);
 
 #ifndef OPENSSL_NO_EC
     if (keyid == EVP_PKEY_EC) {
@@ -726,7 +726,7 @@ static void print_key_details(BIO *out, EVP_PKEY *key)
 
         if (!EVP_PKEY_get_group_name(key, group, sizeof(group), &amp;size))
             strcpy(group, &quot;unknown group&quot;);
-        BIO_printf(out, &quot;%d bits EC (%s)&quot;, EVP_PKEY_bits(key), group);
+        BIO_printf(out, &quot;%d bits EC (%s)&quot;, EVP_PKEY_get_bits(key), group);
     } else
 #endif
     {
@@ -745,7 +745,7 @@ static void print_key_details(BIO *out, EVP_PKEY *key)
             algname = OBJ_nid2sn(keyid);
             break;
         }
-        BIO_printf(out, &quot;%d bits %s&quot;, EVP_PKEY_bits(key), algname);
+        BIO_printf(out, &quot;%d bits %s&quot;, EVP_PKEY_get_bits(key), algname);
     }
 }
 
diff --git a/test/sslapitest.c b/test/sslapitest.c
index b687ab9e22..7275d6f9c6 100644
--- a/test/sslapitest.c
+++ b/test/sslapitest.c
@@ -8850,7 +8850,7 @@ static int test_dh_auto(int idx)
 
     if (!TEST_int_gt(SSL_get_tmp_key(serverssl, &amp;tmpkey), 0))
         goto end;
-    if (!TEST_size_t_eq(EVP_PKEY_bits(tmpkey), expdhsize))
+    if (!TEST_size_t_eq(EVP_PKEY_get_bits(tmpkey), expdhsize))
         goto end;
 
     if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
diff --git a/test/tls13encryptiontest.c b/test/tls13encryptiontest.c
index 3bb189f0b5..f83da872e8 100644
--- a/test/tls13encryptiontest.c
+++ b/test/tls13encryptiontest.c
@@ -347,7 +347,7 @@ static int test_tls13_encryption(void)
 
     for (ctr = 0; ctr &lt; OSSL_NELEM(refdata); ctr++) {
         /* Load the record */
-        ivlen = EVP_CIPHER_iv_length(ciph);
+        ivlen = EVP_CIPHER_get_iv_length(ciph);
         if (!load_record(&amp;rec, &amp;refdata[ctr], &amp;key, s-&gt;read_iv, ivlen,
                          RECORD_LAYER_get_read_sequence(&amp;s-&gt;rlayer))) {
             TEST_error(&quot;Failed loading key into EVP_CIPHER_CTX&quot;);
diff --git a/test/tls13secretstest.c b/test/tls13secretstest.c
index 5a16f306f7..bf214d3d5b 100644
--- a/test/tls13secretstest.c
+++ b/test/tls13secretstest.c
@@ -314,7 +314,7 @@ static int test_handshake_secrets(void)
                      handshake_secret, sizeof(handshake_secret)))
         goto err;
 
-    hashsize = EVP_MD_size(ssl_handshake_md(s));
+    hashsize = EVP_MD_get_size(ssl_handshake_md(s));
     if (!TEST_size_t_eq(sizeof(client_hts), hashsize))
         goto err;
     if (!TEST_size_t_eq(sizeof(client_hts_key), KEYLEN))
diff --git a/util/libcrypto.num b/util/libcrypto.num
index c7d89421a2..3d44181f22 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -163,7 +163,7 @@ CT_POLICY_EVAL_CTX_free                 165	3_0_0	EXIST::FUNCTION:CT
 CMS_RecipientInfo_kari_get0_ctx         166	3_0_0	EXIST::FUNCTION:CMS
 PKCS7_set_attributes                    167	3_0_0	EXIST::FUNCTION:
 d2i_POLICYQUALINFO                      168	3_0_0	EXIST::FUNCTION:
-EVP_MD_type                             170	3_0_0	EXIST::FUNCTION:
+EVP_MD_get_type                         170	3_0_0	EXIST::FUNCTION:
 EVP_PKCS82PKEY                          171	3_0_0	EXIST::FUNCTION:
 BN_generate_prime_ex                    172	3_0_0	EXIST::FUNCTION:
 EVP_EncryptInit                         173	3_0_0	EXIST::FUNCTION:
@@ -172,7 +172,7 @@ BN_uadd                                 175	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_derive_init                    176	3_0_0	EXIST::FUNCTION:
 PEM_write_bio_ASN1_stream               177	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_delete_attr                    178	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_CTX_key_length               179	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_CTX_get_key_length           179	3_0_0	EXIST::FUNCTION:
 BIO_clear_flags                         180	3_0_0	EXIST::FUNCTION:
 i2d_DISPLAYTEXT                         181	3_0_0	EXIST::FUNCTION:
 OCSP_response_status                    182	3_0_0	EXIST::FUNCTION:OCSP
@@ -197,7 +197,7 @@ BN_nist_mod_256                         200	3_0_0	EXIST::FUNCTION:
 OCSP_request_add0_id                    201	3_0_0	EXIST::FUNCTION:OCSP
 EVP_seed_cfb128                         202	3_0_0	EXIST::FUNCTION:SEED
 BASIC_CONSTRAINTS_free                  203	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_flags                        204	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get_flags                    204	3_0_0	EXIST::FUNCTION:
 PEM_write_bio_ECPKParameters            205	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,EC
 SCT_set_version                         206	3_0_0	EXIST::FUNCTION:CT
 CMS_add1_ReceiptRequest                 207	3_0_0	EXIST::FUNCTION:CMS
@@ -422,7 +422,7 @@ X509_REVOKED_get_ext                    429	3_0_0	EXIST::FUNCTION:
 d2i_RSA_PSS_PARAMS                      430	3_0_0	EXIST::FUNCTION:
 USERNOTICE_free                         431	3_0_0	EXIST::FUNCTION:
 MD4_Transform                           432	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,MD4
-EVP_CIPHER_block_size                   433	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get_block_size               433	3_0_0	EXIST::FUNCTION:
 CERTIFICATEPOLICIES_new                 434	3_0_0	EXIST::FUNCTION:
 BIO_dump_fp                             435	3_0_0	EXIST::FUNCTION:STDIO
 BIO_set_flags                           436	3_0_0	EXIST::FUNCTION:
@@ -734,7 +734,7 @@ X509_STORE_CTX_new                      753	3_0_0	EXIST::FUNCTION:
 CTLOG_STORE_new                         754	3_0_0	EXIST::FUNCTION:CT
 EVP_CIPHER_meth_set_cleanup             755	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0
 d2i_PKCS12_SAFEBAG                      756	3_0_0	EXIST::FUNCTION:
-EVP_MD_pkey_type                        757	3_0_0	EXIST::FUNCTION:
+EVP_MD_get_pkey_type                    757	3_0_0	EXIST::FUNCTION:
 X509_policy_node_get0_qualifiers        758	3_0_0	EXIST::FUNCTION:
 OCSP_cert_status_str                    759	3_0_0	EXIST::FUNCTION:OCSP
 EVP_MD_meth_get_flags                   760	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0
@@ -781,7 +781,7 @@ RC4_options                             801	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3
 BIO_f_null                              802	3_0_0	EXIST::FUNCTION:
 EC_GROUP_set_curve_name                 803	3_0_0	EXIST::FUNCTION:EC
 d2i_PBE2PARAM                           804	3_0_0	EXIST::FUNCTION:
-EVP_PKEY_security_bits                  805	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_get_security_bits              805	3_0_0	EXIST::FUNCTION:
 PKCS12_unpack_p7encdata                 806	3_0_0	EXIST::FUNCTION:
 X509V3_EXT_i2d                          807	3_0_0	EXIST::FUNCTION:
 X509V3_get_value_bool                   808	3_0_0	EXIST::FUNCTION:
@@ -1507,7 +1507,7 @@ SRP_Verify_B_mod_N                      1541	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_
 SXNET_free                              1542	3_0_0	EXIST::FUNCTION:
 CMS_get0_content                        1543	3_0_0	EXIST::FUNCTION:CMS
 BN_is_word                              1544	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_key_length                   1545	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get_key_length               1545	3_0_0	EXIST::FUNCTION:
 EVP_CIPHER_asn1_to_param                1546	3_0_0	EXIST::FUNCTION:
 OCSP_request_onereq_get0                1547	3_0_0	EXIST::FUNCTION:OCSP
 ERR_load_PKCS7_strings                  1548	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0
@@ -1518,7 +1518,7 @@ EVP_PKEY_get_attr_by_NID                1552	3_0_0	EXIST::FUNCTION:
 BIO_get_accept_socket                   1553	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_1_1_0,SOCK
 CMS_SignerInfo_sign                     1554	3_0_0	EXIST::FUNCTION:CMS
 ASN1_item_i2d_bio                       1555	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_CTX_block_size               1556	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_CTX_get_block_size           1556	3_0_0	EXIST::FUNCTION:
 DIRECTORYSTRING_free                    1557	3_0_0	EXIST::FUNCTION:
 TS_CONF_set_default_engine              1558	3_0_0	EXIST::FUNCTION:ENGINE,TS
 BN_set_bit                              1559	3_0_0	EXIST::FUNCTION:
@@ -1528,7 +1528,7 @@ TS_TST_INFO_get_tsa                     1562	3_0_0	EXIST::FUNCTION:TS
 EC_GROUP_check                          1563	3_0_0	EXIST::FUNCTION:EC
 OPENSSL_sk_delete                       1564	3_0_0	EXIST::FUNCTION:
 TS_RESP_CTX_set_extension_cb            1565	3_0_0	EXIST::FUNCTION:TS
-EVP_CIPHER_CTX_nid                      1566	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_CTX_get_nid                  1566	3_0_0	EXIST::FUNCTION:
 TS_RESP_CTX_add_md                      1567	3_0_0	EXIST::FUNCTION:TS
 DES_set_key                             1568	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,DES
 X509V3_extensions_print                 1569	3_0_0	EXIST::FUNCTION:
@@ -2037,7 +2037,7 @@ d2i_RSAPublicKey                        2084	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_
 i2d_ASN1_GENERALSTRING                  2085	3_0_0	EXIST::FUNCTION:
 POLICYQUALINFO_new                      2086	3_0_0	EXIST::FUNCTION:
 PKCS7_RECIP_INFO_get0_alg               2087	3_0_0	EXIST::FUNCTION:
-EVP_PKEY_base_id                        2088	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_get_base_id                    2088	3_0_0	EXIST::FUNCTION:
 UI_method_set_opener                    2089	3_0_0	EXIST::FUNCTION:
 X509v3_get_ext_by_NID                   2090	3_0_0	EXIST::FUNCTION:
 TS_CONF_set_policies                    2091	3_0_0	EXIST::FUNCTION:TS
@@ -2111,7 +2111,7 @@ X509_add1_trust_object                  2157	3_0_0	EXIST::FUNCTION:
 PEM_write_X509                          2158	3_0_0	EXIST::FUNCTION:STDIO
 BN_CTX_free                             2159	3_0_0	EXIST::FUNCTION:
 EC_GROUP_get_curve_GF2m                 2160	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,EC,EC2M
-EVP_MD_flags                            2161	3_0_0	EXIST::FUNCTION:
+EVP_MD_get_flags                        2161	3_0_0	EXIST::FUNCTION:
 OPENSSL_sk_set                          2162	3_0_0	EXIST::FUNCTION:
 OCSP_request_sign                       2163	3_0_0	EXIST::FUNCTION:OCSP
 BN_GF2m_mod_solve_quad                  2164	3_0_0	EXIST::FUNCTION:EC2M
@@ -2168,7 +2168,7 @@ TS_RESP_CTX_set_clock_precision_digits  2216	3_0_0	EXIST::FUNCTION:TS
 SCT_LIST_validate                       2217	3_0_0	EXIST::FUNCTION:CT
 X509_PURPOSE_get_id                     2218	3_0_0	EXIST::FUNCTION:
 EC_KEY_get_ex_data                      2219	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,EC
-EVP_MD_size                             2220	3_0_0	EXIST::FUNCTION:
+EVP_MD_get_size                         2220	3_0_0	EXIST::FUNCTION:
 CRYPTO_malloc                           2221	3_0_0	EXIST::FUNCTION:
 ERR_load_ASN1_strings                   2222	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0
 X509_REQ_get_extension_nids             2223	3_0_0	EXIST::FUNCTION:
@@ -2222,7 +2222,7 @@ BN_mod_add_quick                        2270	3_0_0	EXIST::FUNCTION:
 NCONF_free                              2271	3_0_0	EXIST::FUNCTION:
 NETSCAPE_SPKI_b64_decode                2272	3_0_0	EXIST::FUNCTION:
 BIO_f_md                                2273	3_0_0	EXIST::FUNCTION:
-EVP_MD_CTX_pkey_ctx                     2274	3_0_0	EXIST::FUNCTION:
+EVP_MD_CTX_get_pkey_ctx                 2274	3_0_0	EXIST::FUNCTION:
 ENGINE_set_default_EC                   2275	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,ENGINE
 CMS_ReceiptRequest_free                 2276	3_0_0	EXIST::FUNCTION:CMS
 TS_STATUS_INFO_get0_text                2277	3_0_0	EXIST::FUNCTION:TS
@@ -2301,7 +2301,7 @@ BIO_s_fd                                2350	3_0_0	EXIST::FUNCTION:
 i2d_CMS_bio                             2351	3_0_0	EXIST::FUNCTION:CMS
 CRYPTO_gcm128_decrypt                   2352	3_0_0	EXIST::FUNCTION:
 EVP_aes_256_ctr                         2353	3_0_0	EXIST::FUNCTION:
-EVP_PKEY_bits                           2354	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_get_bits                       2354	3_0_0	EXIST::FUNCTION:
 BN_BLINDING_new                         2355	3_0_0	EXIST::FUNCTION:
 ASN1_GENERALIZEDTIME_check              2356	3_0_0	EXIST::FUNCTION:
 BN_clear_bit                            2357	3_0_0	EXIST::FUNCTION:
@@ -2358,7 +2358,7 @@ TS_CONF_set_crypto_device               2408	3_0_0	EXIST::FUNCTION:ENGINE,TS
 COMP_CTX_get_method                     2409	3_0_0	EXIST::FUNCTION:COMP
 EC_GROUP_get_cofactor                   2410	3_0_0	EXIST::FUNCTION:EC
 EVP_rc5_32_12_16_ofb                    2411	3_0_0	EXIST::FUNCTION:RC5
-EVP_MD_CTX_md_data                      2412	3_0_0	EXIST::FUNCTION:
+EVP_MD_CTX_get0_md_data                 2412	3_0_0	EXIST::FUNCTION:
 ASN1_PCTX_set_nm_flags                  2413	3_0_0	EXIST::FUNCTION:
 BIO_ctrl                                2414	3_0_0	EXIST::FUNCTION:
 X509_CRL_set_default_method             2415	3_0_0	EXIST::FUNCTION:
@@ -2476,7 +2476,7 @@ RAND_egd                                2528	3_0_0	EXIST::FUNCTION:EGD
 ASN1_d2i_bio                            2529	3_0_0	EXIST::FUNCTION:
 X509_REQ_digest                         2531	3_0_0	EXIST::FUNCTION:
 X509_set1_notAfter                      2532	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_type                         2533	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get_type                     2533	3_0_0	EXIST::FUNCTION:
 ASN1_TYPE_set_octetstring               2534	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_asn1_set_free                  2535	3_0_0	EXIST::FUNCTION:
 CMS_signed_get0_data_by_OBJ             2536	3_0_0	EXIST::FUNCTION:CMS
@@ -2665,7 +2665,7 @@ SEED_decrypt                            2723	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_
 PEM_write_PKCS8PrivateKey               2724	3_0_0	EXIST::FUNCTION:STDIO
 ENGINE_new                              2725	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,ENGINE
 X509_check_issued                       2726	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_CTX_iv_length                2727	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_CTX_get_iv_length            2727	3_0_0	EXIST::FUNCTION:
 DES_string_to_2keys                     2728	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,DES
 EVP_PKEY_copy_parameters                2729	3_0_0	EXIST::FUNCTION:
 CMS_ContentInfo_print_ctx               2730	3_0_0	EXIST::FUNCTION:CMS
@@ -3143,7 +3143,7 @@ BN_rand_range                           3210	3_0_0	EXIST::FUNCTION:
 SMIME_write_ASN1                        3211	3_0_0	EXIST::FUNCTION:
 EVP_CIPHER_CTX_new                      3212	3_0_0	EXIST::FUNCTION:
 MD4_Final                               3213	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,MD4
-EVP_PKEY_id                             3214	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_get_id                         3214	3_0_0	EXIST::FUNCTION:
 CMS_RecipientInfo_get0_pkey_ctx         3215	3_0_0	EXIST::FUNCTION:CMS
 OCSP_REQINFO_free                       3216	3_0_0	EXIST::FUNCTION:OCSP
 AUTHORITY_KEYID_new                     3217	3_0_0	EXIST::FUNCTION:
@@ -3443,7 +3443,7 @@ ENGINE_get_first                        3516	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_
 CERTIFICATEPOLICIES_it                  3517	3_0_0	EXIST::FUNCTION:
 EVP_MD_CTX_ctrl                         3518	3_0_0	EXIST::FUNCTION:
 PKCS7_final                             3519	3_0_0	EXIST::FUNCTION:
-EVP_PKEY_size                           3520	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_get_size                       3520	3_0_0	EXIST::FUNCTION:
 EVP_DecryptFinal_ex                     3521	3_0_0	EXIST::FUNCTION:
 SCT_get_signature_nid                   3522	3_0_0	EXIST::FUNCTION:CT
 PROXY_CERT_INFO_EXTENSION_new           3523	3_0_0	EXIST::FUNCTION:
@@ -3580,7 +3580,7 @@ PEM_write_bio_DSAPrivateKey             3661	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_
 CMS_encrypt                             3662	3_0_0	EXIST::FUNCTION:CMS
 CRYPTO_nistcts128_decrypt               3663	3_0_0	EXIST::FUNCTION:
 ERR_load_DH_strings                     3664	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,DH
-EVP_MD_block_size                       3665	3_0_0	EXIST::FUNCTION:
+EVP_MD_get_block_size                   3665	3_0_0	EXIST::FUNCTION:
 TS_X509_ALGOR_print_bio                 3666	3_0_0	EXIST::FUNCTION:TS
 d2i_PKCS7_ENVELOPE                      3667	3_0_0	EXIST::FUNCTION:
 ESS_CERT_ID_new                         3669	3_0_0	EXIST::FUNCTION:
@@ -3608,7 +3608,7 @@ ASN1_UTCTIME_cmp_time_t                 3690	3_0_0	EXIST::FUNCTION:
 X509_VERIFY_PARAM_set1_ip               3691	3_0_0	EXIST::FUNCTION:
 OTHERNAME_free                          3692	3_0_0	EXIST::FUNCTION:
 OCSP_REVOKEDINFO_free                   3693	3_0_0	EXIST::FUNCTION:OCSP
-EVP_CIPHER_CTX_encrypting               3694	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_CTX_is_encrypting            3694	3_0_0	EXIST::FUNCTION:
 EC_KEY_can_sign                         3695	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,EC
 PEM_write_bio_RSAPublicKey              3696	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0
 X509_CRL_set1_lastUpdate                3697	3_0_0	EXIST::FUNCTION:
@@ -3715,7 +3715,7 @@ X509_REQ_get_subject_name               3798	3_0_0	EXIST::FUNCTION:
 BN_div_word                             3799	3_0_0	EXIST::FUNCTION:
 TS_CONF_set_signer_key                  3800	3_0_0	EXIST::FUNCTION:TS
 BN_GF2m_mod_sqrt                        3801	3_0_0	EXIST::FUNCTION:EC2M
-EVP_CIPHER_nid                          3802	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get_nid                      3802	3_0_0	EXIST::FUNCTION:
 OBJ_txt2obj                             3803	3_0_0	EXIST::FUNCTION:
 CMS_RecipientInfo_kari_get0_orig_id     3804	3_0_0	EXIST::FUNCTION:CMS
 EVP_bf_ecb                              3805	3_0_0	EXIST::FUNCTION:BF
@@ -3758,7 +3758,7 @@ PKCS7_add_signed_attribute              3842	3_0_0	EXIST::FUNCTION:
 i2d_PrivateKey_bio                      3843	3_0_0	EXIST::FUNCTION:
 RSA_padding_add_PKCS1_type_1            3844	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0
 i2d_re_X509_tbs                         3845	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_iv_length                    3846	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get_iv_length                3846	3_0_0	EXIST::FUNCTION:
 OSSL_HTTP_REQ_CTX_get0_mem_bio          3847	3_0_0	EXIST::FUNCTION:
 i2d_PKCS8PrivateKeyInfo_bio             3848	3_0_0	EXIST::FUNCTION:
 d2i_OCSP_CERTID                         3849	3_0_0	EXIST::FUNCTION:OCSP
@@ -3811,7 +3811,7 @@ ASN1_ENUMERATED_set_int64               3897	3_0_0	EXIST::FUNCTION:
 o2i_SCT                                 3898	3_0_0	EXIST::FUNCTION:CT
 CRL_DIST_POINTS_free                    3899	3_0_0	EXIST::FUNCTION:
 d2i_OCSP_SINGLERESP                     3900	3_0_0	EXIST::FUNCTION:OCSP
-EVP_CIPHER_CTX_num                      3901	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_CTX_get_num                  3901	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_verify_recover_init            3902	3_0_0	EXIST::FUNCTION:
 SHA512_Init                             3903	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0
 TS_MSG_IMPRINT_set_msg                  3904	3_0_0	EXIST::FUNCTION:TS
@@ -4406,7 +4406,7 @@ EVP_PKEY_meth_get_digest_custom         4533	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_
 EVP_MAC_CTX_new                         4534	3_0_0	EXIST::FUNCTION:
 EVP_MAC_CTX_free                        4535	3_0_0	EXIST::FUNCTION:
 EVP_MAC_CTX_dup                         4536	3_0_0	EXIST::FUNCTION:
-EVP_MAC_CTX_mac                         4537	3_0_0	EXIST::FUNCTION:
+EVP_MAC_CTX_get0_mac                    4537	3_0_0	EXIST::FUNCTION:
 EVP_MAC_CTX_get_mac_size                4538	3_0_0	EXIST::FUNCTION:
 EVP_Q_mac                               4539	3_0_0	EXIST::FUNCTION:
 EVP_MAC_init                            4540	3_0_0	EXIST::FUNCTION:
@@ -4435,7 +4435,7 @@ EVP_KDF_CTX_free                        4562	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_reset                       4563	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_get_kdf_size                4564	3_0_0	EXIST::FUNCTION:
 EVP_KDF_derive                          4565	3_0_0	EXIST::FUNCTION:
-EVP_KDF_name                            4566	3_0_0	EXIST::FUNCTION:
+EVP_KDF_get0_name                       4566	3_0_0	EXIST::FUNCTION:
 EC_GROUP_get0_field                     4567	3_0_0	EXIST::FUNCTION:EC
 CRYPTO_alloc_ex_data                    4568	3_0_0	EXIST::FUNCTION:
 OSSL_LIB_CTX_new                        4569	3_0_0	EXIST::FUNCTION:
@@ -4581,7 +4581,7 @@ OSSL_PARAM_construct_end                4708	3_0_0	EXIST::FUNCTION:
 EC_GROUP_check_named_curve              4709	3_0_0	EXIST::FUNCTION:EC
 EVP_CIPHER_up_ref                       4710	3_0_0	EXIST::FUNCTION:
 EVP_CIPHER_fetch                        4711	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_mode                         4712	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get_mode                     4712	3_0_0	EXIST::FUNCTION:
 OPENSSL_info                            4713	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_new                         4714	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_kdf                         4715	3_0_0	EXIST::FUNCTION:
@@ -4626,16 +4626,16 @@ EVP_PKEY_CTX_set_params                 4753	3_0_0	EXIST::FUNCTION:
 EVP_KEYMGMT_fetch                       4754	3_0_0	EXIST::FUNCTION:
 EVP_KEYMGMT_up_ref                      4755	3_0_0	EXIST::FUNCTION:
 EVP_KEYMGMT_free                        4756	3_0_0	EXIST::FUNCTION:
-EVP_KEYMGMT_provider                    4757	3_0_0	EXIST::FUNCTION:
+EVP_KEYMGMT_get0_provider               4757	3_0_0	EXIST::FUNCTION:
 X509_PUBKEY_dup                         4758	3_0_0	EXIST::FUNCTION:
-EVP_MD_name                             4759	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_name                         4760	3_0_0	EXIST::FUNCTION:
-EVP_MD_provider                         4761	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_provider                     4762	3_0_0	EXIST::FUNCTION:
-OSSL_PROVIDER_name                      4763	3_0_0	EXIST::FUNCTION:
+EVP_MD_get0_name                        4759	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get0_name                    4760	3_0_0	EXIST::FUNCTION:
+EVP_MD_get0_provider                    4761	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get0_provider                4762	3_0_0	EXIST::FUNCTION:
+OSSL_PROVIDER_get0_name                 4763	3_0_0	EXIST::FUNCTION:
 EVP_CIPHER_do_all_provided              4764	3_0_0	EXIST::FUNCTION:
 EVP_MD_do_all_provided                  4765	3_0_0	EXIST::FUNCTION:
-EVP_KEYEXCH_provider                    4766	3_0_0	EXIST::FUNCTION:
+EVP_KEYEXCH_get0_provider               4766	3_0_0	EXIST::FUNCTION:
 OSSL_PROVIDER_available                 4767	3_0_0	EXIST::FUNCTION:
 ERR_new                                 4768	3_0_0	EXIST::FUNCTION:
 ERR_set_debug                           4769	3_0_0	EXIST::FUNCTION:
@@ -4666,16 +4666,16 @@ EVP_MAC_free                            4793	3_0_0	EXIST::FUNCTION:
 EVP_MAC_up_ref                          4794	3_0_0	EXIST::FUNCTION:
 EVP_MAC_get_params                      4795	3_0_0	EXIST::FUNCTION:
 EVP_MAC_gettable_params                 4796	3_0_0	EXIST::FUNCTION:
-EVP_MAC_provider                        4797	3_0_0	EXIST::FUNCTION:
+EVP_MAC_get0_provider                   4797	3_0_0	EXIST::FUNCTION:
 EVP_MAC_do_all_provided                 4798	3_0_0	EXIST::FUNCTION:
-EVP_MAC_name                            4799	3_0_0	EXIST::FUNCTION:
+EVP_MAC_get0_name                       4799	3_0_0	EXIST::FUNCTION:
 EVP_MD_free                             4800	3_0_0	EXIST::FUNCTION:
 EVP_CIPHER_free                         4801	3_0_0	EXIST::FUNCTION:
 EVP_KDF_up_ref                          4802	3_0_0	EXIST::FUNCTION:
 EVP_KDF_free                            4803	3_0_0	EXIST::FUNCTION:
 EVP_KDF_fetch                           4804	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_dup                         4805	3_0_0	EXIST::FUNCTION:
-EVP_KDF_provider                        4806	3_0_0	EXIST::FUNCTION:
+EVP_KDF_get0_provider                   4806	3_0_0	EXIST::FUNCTION:
 EVP_KDF_get_params                      4807	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_get_params                  4808	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_set_params                  4809	3_0_0	EXIST::FUNCTION:
@@ -4685,14 +4685,14 @@ EVP_KDF_settable_ctx_params             4812	3_0_0	EXIST::FUNCTION:
 EVP_KDF_do_all_provided                 4813	3_0_0	EXIST::FUNCTION:
 EVP_SIGNATURE_free                      4814	3_0_0	EXIST::FUNCTION:
 EVP_SIGNATURE_up_ref                    4815	3_0_0	EXIST::FUNCTION:
-EVP_SIGNATURE_provider                  4816	3_0_0	EXIST::FUNCTION:
+EVP_SIGNATURE_get0_provider             4816	3_0_0	EXIST::FUNCTION:
 EVP_SIGNATURE_fetch                     4817	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_set_signature_md           4818	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_get_signature_md           4819	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_get_params                 4820	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_gettable_params            4821	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_settable_params            4822	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_CTX_tag_length               4823	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_CTX_get_tag_length           4823	3_0_0	EXIST::FUNCTION:
 ERR_get_error_all                       4824	3_0_0	EXIST::FUNCTION:
 ERR_peek_error_func                     4825	3_0_0	EXIST::FUNCTION:
 ERR_peek_error_data                     4826	3_0_0	EXIST::FUNCTION:
@@ -4783,13 +4783,13 @@ EVP_KEYMGMT_names_do_all                4910	3_0_0	EXIST::FUNCTION:
 EVP_KEYEXCH_names_do_all                4911	3_0_0	EXIST::FUNCTION:
 EVP_KDF_names_do_all                    4912	3_0_0	EXIST::FUNCTION:
 EVP_SIGNATURE_names_do_all              4913	3_0_0	EXIST::FUNCTION:
-EVP_MD_number                           4914	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_number                       4915	3_0_0	EXIST::FUNCTION:
-EVP_MAC_number                          4916	3_0_0	EXIST::FUNCTION:
-EVP_KEYMGMT_number                      4917	3_0_0	EXIST::FUNCTION:
-EVP_KEYEXCH_number                      4918	3_0_0	EXIST::FUNCTION:
-EVP_KDF_number                          4919	3_0_0	EXIST::FUNCTION:
-EVP_SIGNATURE_number                    4920	3_0_0	EXIST::FUNCTION:
+EVP_MD_get_number                       4914	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get_number                   4915	3_0_0	EXIST::FUNCTION:
+EVP_MAC_get_number                      4916	3_0_0	EXIST::FUNCTION:
+EVP_KEYMGMT_get_number                  4917	3_0_0	EXIST::FUNCTION:
+EVP_KEYEXCH_get_number                  4918	3_0_0	EXIST::FUNCTION:
+EVP_KDF_get_number                      4919	3_0_0	EXIST::FUNCTION:
+EVP_SIGNATURE_get_number                4920	3_0_0	EXIST::FUNCTION:
 OSSL_CMP_CTX_snprint_PKIStatus          4921	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_HDR_get0_transactionID         4922	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_HDR_get0_recipNonce            4923	3_0_0	EXIST::FUNCTION:CMP
@@ -4802,10 +4802,10 @@ X509_STORE_load_store                   4929	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_fromdata                       4930	3_0_0	EXIST::FUNCTION:
 EVP_ASYM_CIPHER_free                    4931	3_0_0	EXIST::FUNCTION:
 EVP_ASYM_CIPHER_up_ref                  4932	3_0_0	EXIST::FUNCTION:
-EVP_ASYM_CIPHER_provider                4933	3_0_0	EXIST::FUNCTION:
+EVP_ASYM_CIPHER_get0_provider           4933	3_0_0	EXIST::FUNCTION:
 EVP_ASYM_CIPHER_fetch                   4934	3_0_0	EXIST::FUNCTION:
 EVP_ASYM_CIPHER_is_a                    4935	3_0_0	EXIST::FUNCTION:
-EVP_ASYM_CIPHER_number                  4936	3_0_0	EXIST::FUNCTION:
+EVP_ASYM_CIPHER_get_number              4936	3_0_0	EXIST::FUNCTION:
 EVP_ASYM_CIPHER_do_all_provided         4937	3_0_0	EXIST::FUNCTION:
 EVP_ASYM_CIPHER_names_do_all            4938	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_set_rsa_padding            4939	3_0_0	EXIST::FUNCTION:
@@ -4827,16 +4827,16 @@ EVP_PKEY_meth_get_digestverify          4954	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_
 OSSL_ENCODER_up_ref                     4955	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_free                       4956	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_fetch                      4957	3_0_0	EXIST::FUNCTION:
-OSSL_ENCODER_number                     4958	3_0_0	EXIST::FUNCTION:
+OSSL_ENCODER_get_number                 4958	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_is_a                       4959	3_0_0	EXIST::FUNCTION:
-OSSL_ENCODER_provider                   4960	3_0_0	EXIST::FUNCTION:
+OSSL_ENCODER_get0_provider              4960	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_do_all_provided            4961	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_names_do_all               4962	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_settable_ctx_params        4963	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_CTX_new                    4964	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_CTX_set_params             4965	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_CTX_free                   4966	3_0_0	EXIST::FUNCTION:
-OSSL_ENCODER_properties                 4967	3_0_0	EXIST::FUNCTION:
+OSSL_ENCODER_get0_properties            4967	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_to_bio                     4968	3_0_0	EXIST::FUNCTION:
 OSSL_ENCODER_to_fp                      4969	3_0_0	EXIST::FUNCTION:STDIO
 OSSL_ENCODER_CTX_new_for_pkey           4970	3_0_0	EXIST::FUNCTION:
@@ -5043,14 +5043,14 @@ OSSL_PARAM_set_all_unmodified           5170	3_0_0	EXIST::FUNCTION:
 EVP_RAND_fetch                          5171	3_0_0	EXIST::FUNCTION:
 EVP_RAND_up_ref                         5172	3_0_0	EXIST::FUNCTION:
 EVP_RAND_free                           5173	3_0_0	EXIST::FUNCTION:
-EVP_RAND_number                         5174	3_0_0	EXIST::FUNCTION:
-EVP_RAND_name                           5175	3_0_0	EXIST::FUNCTION:
+EVP_RAND_get_number                     5174	3_0_0	EXIST::FUNCTION:
+EVP_RAND_get0_name                      5175	3_0_0	EXIST::FUNCTION:
 EVP_RAND_is_a                           5176	3_0_0	EXIST::FUNCTION:
-EVP_RAND_provider                       5177	3_0_0	EXIST::FUNCTION:
+EVP_RAND_get0_provider                  5177	3_0_0	EXIST::FUNCTION:
 EVP_RAND_get_params                     5178	3_0_0	EXIST::FUNCTION:
 EVP_RAND_CTX_new                        5179	3_0_0	EXIST::FUNCTION:
 EVP_RAND_CTX_free                       5180	3_0_0	EXIST::FUNCTION:
-EVP_RAND_CTX_rand                       5181	3_0_0	EXIST::FUNCTION:
+EVP_RAND_CTX_get0_rand                  5181	3_0_0	EXIST::FUNCTION:
 EVP_RAND_CTX_get_params                 5182	3_0_0	EXIST::FUNCTION:
 EVP_RAND_CTX_set_params                 5183	3_0_0	EXIST::FUNCTION:
 EVP_RAND_gettable_params                5184	3_0_0	EXIST::FUNCTION:
@@ -5065,8 +5065,8 @@ EVP_RAND_reseed                         5192	3_0_0	EXIST::FUNCTION:
 EVP_RAND_nonce                          5193	3_0_0	EXIST::FUNCTION:
 EVP_RAND_enable_locking                 5194	3_0_0	EXIST::FUNCTION:
 EVP_RAND_verify_zeroization             5195	3_0_0	EXIST::FUNCTION:
-EVP_RAND_strength                       5196	3_0_0	EXIST::FUNCTION:
-EVP_RAND_state                          5197	3_0_0	EXIST::FUNCTION:
+EVP_RAND_get_strength                   5196	3_0_0	EXIST::FUNCTION:
+EVP_RAND_get_state                      5197	3_0_0	EXIST::FUNCTION:
 EVP_default_properties_is_fips_enabled  5198	3_0_0	EXIST::FUNCTION:
 EVP_default_properties_enable_fips      5199	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_new_raw_private_key_ex         5200	3_0_0	EXIST::FUNCTION:
@@ -5113,9 +5113,9 @@ OSSL_STORE_open_ex                      5240	3_0_0	EXIST::FUNCTION:
 OSSL_DECODER_fetch                      5241	3_0_0	EXIST::FUNCTION:
 OSSL_DECODER_up_ref                     5242	3_0_0	EXIST::FUNCTION:
 OSSL_DECODER_free                       5243	3_0_0	EXIST::FUNCTION:
-OSSL_DECODER_provider                   5244	3_0_0	EXIST::FUNCTION:
-OSSL_DECODER_properties                 5245	3_0_0	EXIST::FUNCTION:
-OSSL_DECODER_number                     5246	3_0_0	EXIST::FUNCTION:
+OSSL_DECODER_get0_provider              5244	3_0_0	EXIST::FUNCTION:
+OSSL_DECODER_get0_properties            5245	3_0_0	EXIST::FUNCTION:
+OSSL_DECODER_get_number                 5246	3_0_0	EXIST::FUNCTION:
 OSSL_DECODER_is_a                       5247	3_0_0	EXIST::FUNCTION:
 OSSL_DECODER_do_all_provided            5248	3_0_0	EXIST::FUNCTION:
 OSSL_DECODER_names_do_all               5249	3_0_0	EXIST::FUNCTION:
@@ -5180,7 +5180,7 @@ EVP_PKEY_CTX_set_hkdf_md                5307	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_set1_hkdf_salt             5308	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_set1_hkdf_key              5309	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_add1_hkdf_info             5310	3_0_0	EXIST::FUNCTION:
-EVP_PKEY_CTX_hkdf_mode                  5311	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_CTX_set_hkdf_mode              5311	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_set1_pbe_pass              5312	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_set1_scrypt_salt           5313	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_set_scrypt_N               5314	3_0_0	EXIST::FUNCTION:
@@ -5217,9 +5217,9 @@ EC_GROUP_new_from_params                5344	3_0_0	EXIST::FUNCTION:EC
 OSSL_STORE_LOADER_set_open_ex           5345	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0
 OSSL_STORE_LOADER_fetch                 5346	3_0_0	EXIST::FUNCTION:
 OSSL_STORE_LOADER_up_ref                5347	3_0_0	EXIST::FUNCTION:
-OSSL_STORE_LOADER_provider              5348	3_0_0	EXIST::FUNCTION:
-OSSL_STORE_LOADER_properties            5349	3_0_0	EXIST::FUNCTION:
-OSSL_STORE_LOADER_number                5350	3_0_0	EXIST::FUNCTION:
+OSSL_STORE_LOADER_get0_provider         5348	3_0_0	EXIST::FUNCTION:
+OSSL_STORE_LOADER_get0_properties       5349	3_0_0	EXIST::FUNCTION:
+OSSL_STORE_LOADER_get_number            5350	3_0_0	EXIST::FUNCTION:
 OSSL_STORE_LOADER_is_a                  5351	3_0_0	EXIST::FUNCTION:
 OSSL_STORE_LOADER_do_all_provided       5352	3_0_0	EXIST::FUNCTION:
 OSSL_STORE_LOADER_names_do_all          5353	3_0_0	EXIST::FUNCTION:
@@ -5238,14 +5238,14 @@ CMS_AuthEnvelopedData_create            5365	3_0_0	EXIST::FUNCTION:CMS
 CMS_AuthEnvelopedData_create_ex         5366	3_0_0	EXIST::FUNCTION:CMS
 EVP_PKEY_CTX_set_ec_param_enc           5367	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_get0_type_name                 5368	3_0_0	EXIST::FUNCTION:
-EVP_KEYMGMT_name                        5369	3_0_0	EXIST::FUNCTION:
+EVP_KEYMGMT_get0_name                   5369	3_0_0	EXIST::FUNCTION:
 EC_KEY_decoded_from_explicit_params     5370	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,EC
 EVP_KEM_free                            5371	3_0_0	EXIST::FUNCTION:
 EVP_KEM_up_ref                          5372	3_0_0	EXIST::FUNCTION:
-EVP_KEM_provider                        5373	3_0_0	EXIST::FUNCTION:
+EVP_KEM_get0_provider                   5373	3_0_0	EXIST::FUNCTION:
 EVP_KEM_fetch                           5374	3_0_0	EXIST::FUNCTION:
 EVP_KEM_is_a                            5375	3_0_0	EXIST::FUNCTION:
-EVP_KEM_number                          5376	3_0_0	EXIST::FUNCTION:
+EVP_KEM_get_number                      5376	3_0_0	EXIST::FUNCTION:
 EVP_KEM_do_all_provided                 5377	3_0_0	EXIST::FUNCTION:
 EVP_KEM_names_do_all                    5378	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_encapsulate_init               5379	3_0_0	EXIST::FUNCTION:
@@ -5347,22 +5347,22 @@ X509_REQ_new_ex                         5474	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_dup                            5475	3_0_0	EXIST::FUNCTION:
 RSA_PSS_PARAMS_dup                      5476	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_derive_set_peer_ex             5477	3_0_0	EXIST::FUNCTION:
-OSSL_DECODER_name                       5478	3_0_0	EXIST::FUNCTION:
-OSSL_ENCODER_name                       5479	3_0_0	EXIST::FUNCTION:
-OSSL_DECODER_description                5480	3_0_0	EXIST::FUNCTION:
-OSSL_ENCODER_description                5481	3_0_0	EXIST::FUNCTION:
-OSSL_STORE_LOADER_description           5482	3_0_0	EXIST::FUNCTION:
-EVP_MD_description                      5483	3_0_0	EXIST::FUNCTION:
-EVP_CIPHER_description                  5484	3_0_0	EXIST::FUNCTION:
-EVP_MAC_description                     5485	3_0_0	EXIST::FUNCTION:
-EVP_RAND_description                    5486	3_0_0	EXIST::FUNCTION:
-EVP_PKEY_description                    5487	3_0_0	EXIST::FUNCTION:
-EVP_KEYMGMT_description                 5488	3_0_0	EXIST::FUNCTION:
-EVP_SIGNATURE_description               5489	3_0_0	EXIST::FUNCTION:
-EVP_ASYM_CIPHER_description             5490	3_0_0	EXIST::FUNCTION:
-EVP_KEM_description                     5491	3_0_0	EXIST::FUNCTION:
-EVP_KEYEXCH_description                 5492	3_0_0	EXIST::FUNCTION:
-EVP_KDF_description                     5493	3_0_0	EXIST::FUNCTION:
+OSSL_DECODER_get0_name                  5478	3_0_0	EXIST::FUNCTION:
+OSSL_ENCODER_get0_name                  5479	3_0_0	EXIST::FUNCTION:
+OSSL_DECODER_get0_description           5480	3_0_0	EXIST::FUNCTION:
+OSSL_ENCODER_get0_description           5481	3_0_0	EXIST::FUNCTION:
+OSSL_STORE_LOADER_get0_description      5482	3_0_0	EXIST::FUNCTION:
+EVP_MD_get0_description                 5483	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_get0_description             5484	3_0_0	EXIST::FUNCTION:
+EVP_MAC_get0_description                5485	3_0_0	EXIST::FUNCTION:
+EVP_RAND_get0_description               5486	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_get0_description               5487	3_0_0	EXIST::FUNCTION:
+EVP_KEYMGMT_get0_description            5488	3_0_0	EXIST::FUNCTION:
+EVP_SIGNATURE_get0_description          5489	3_0_0	EXIST::FUNCTION:
+EVP_ASYM_CIPHER_get0_description        5490	3_0_0	EXIST::FUNCTION:
+EVP_KEM_get0_description                5491	3_0_0	EXIST::FUNCTION:
+EVP_KEYEXCH_get0_description            5492	3_0_0	EXIST::FUNCTION:
+EVP_KDF_get0_description                5493	3_0_0	EXIST::FUNCTION:
 OPENSSL_sk_find_all                     5494	3_0_0	EXIST::FUNCTION:
 X509_CRL_new_ex                         5495	3_0_0	EXIST::FUNCTION:
 OSSL_PARAM_dup                          5496	3_0_0	EXIST::FUNCTION:
@@ -5375,10 +5375,10 @@ EVP_MD_CTX_get1_md                      5502	3_0_0	EXIST::FUNCTION:
 EVP_CIPHER_CTX_get0_cipher              5503	3_0_0	EXIST::FUNCTION:
 EVP_CIPHER_CTX_get1_cipher              5504	3_0_0	EXIST::FUNCTION:
 OSSL_LIB_CTX_get0_global_default        5505	3_0_0	EXIST::FUNCTION:
-EVP_SIGNATURE_name                      5506	3_0_0	EXIST::FUNCTION:
-EVP_ASYM_CIPHER_name                    5507	3_0_0	EXIST::FUNCTION:
-EVP_KEM_name                            5508	3_0_0	EXIST::FUNCTION:
-EVP_KEYEXCH_name                        5509	3_0_0	EXIST::FUNCTION:
+EVP_SIGNATURE_get0_name                 5506	3_0_0	EXIST::FUNCTION:
+EVP_ASYM_CIPHER_get0_name               5507	3_0_0	EXIST::FUNCTION:
+EVP_KEM_get0_name                       5508	3_0_0	EXIST::FUNCTION:
+EVP_KEYEXCH_get0_name                   5509	3_0_0	EXIST::FUNCTION:
 PKCS5_v2_PBE_keyivgen_ex                5510	3_0_0	EXIST::FUNCTION:
 EVP_PBE_scrypt_ex                       5511	3_0_0	EXIST::FUNCTION:SCRYPT
 PKCS5_v2_scrypt_keyivgen_ex             5512	3_0_0	EXIST::FUNCTION:SCRYPT
diff --git a/util/missingcrypto.txt b/util/missingcrypto.txt
index df71963deb..cd81ba7e09 100644
--- a/util/missingcrypto.txt
+++ b/util/missingcrypto.txt
@@ -631,8 +631,6 @@ ERR_set_error_data(3)
 ERR_unload_strings(3)
 EVP_CIPHER_CTX_buf_noconst(3)
 EVP_CIPHER_CTX_copy(3)
-EVP_CIPHER_CTX_encrypting(3)
-EVP_CIPHER_CTX_num(3)
 EVP_CIPHER_CTX_rand_key(3)
 EVP_CIPHER_CTX_set_num(3)
 EVP_CIPHER_do_all(3)
diff --git a/util/other.syms b/util/other.syms
index 706ad7f5da..05c70df44f 100644
--- a/util/other.syms
+++ b/util/other.syms
@@ -232,10 +232,10 @@ ERR_raise                               define
 ERR_raise_data                          define
 EVP_DigestSignUpdate                    define
 EVP_DigestVerifyUpdate                  define
-EVP_MD_CTX_block_size                   define
-EVP_MD_CTX_name                         define
-EVP_MD_CTX_size                         define
-EVP_MD_CTX_type                         define
+EVP_MD_CTX_get_block_size               define
+EVP_MD_CTX_get0_name                    define
+EVP_MD_CTX_get_size                     define
+EVP_MD_CTX_get_type                     define
 EVP_OpenUpdate                          define
 EVP_PKEY_CTX_add1_hkdf_info             define
 EVP_PKEY_CTX_add1_tls1_prf_seed         define
@@ -255,7 +255,6 @@ EVP_PKEY_CTX_get_rsa_oaep_md            define
 EVP_PKEY_CTX_get_rsa_padding            define
 EVP_PKEY_CTX_get_rsa_pss_saltlen        define
 EVP_PKEY_CTX_get_signature_md           define
-EVP_PKEY_CTX_hkdf_mode                  define
 EVP_PKEY_CTX_set0_dh_kdf_oid            define
 EVP_PKEY_CTX_set0_dh_kdf_ukm            define
 EVP_PKEY_CTX_set0_ecdh_kdf_ukm          define
@@ -627,3 +626,37 @@ OSSL_TRACE9                             define
 TS_VERIFY_CTS_set_certs                 define deprecated 3.0.0
 EVP_PKEY_get1_tls_encodedpoint          define deprecated 3.0.0
 EVP_PKEY_set1_tls_encodedpoint          define deprecated 3.0.0
+EVP_MD_type                             define
+EVP_MD_nid                              define
+EVP_MD_name                             define
+EVP_MD_pkey_type                        define
+EVP_MD_size                             define
+EVP_MD_block_size                       define
+EVP_MD_flags                            define
+EVP_MD_CTX_size                         define
+EVP_MD_CTX_block_size                   define
+EVP_MD_CTX_type                         define
+EVP_MD_CTX_pkey_ctx                     define
+EVP_MD_CTX_md_data                      define
+EVP_CIPHER_nid                          define
+EVP_CIPHER_name                         define
+EVP_CIPHER_block_size                   define
+EVP_CIPHER_key_length                   define
+EVP_CIPHER_iv_length                    define
+EVP_CIPHER_flags                        define
+EVP_CIPHER_mode                         define
+EVP_CIPHER_type                         define
+EVP_CIPHER_CTX_encrypting               define
+EVP_CIPHER_CTX_nid                      define
+EVP_CIPHER_CTX_block_size               define
+EVP_CIPHER_CTX_key_length               define
+EVP_CIPHER_CTX_iv_length                define
+EVP_CIPHER_CTX_tag_length               define
+EVP_CIPHER_CTX_num                      define
+EVP_CIPHER_CTX_type                     define
+EVP_CIPHER_CTX_mode                     define
+EVP_PKEY_bits                           define
+EVP_PKEY_security_bits                  define
+EVP_PKEY_size                           define
+EVP_PKEY_id                             define
+EVP_PKEY_base_id                        define
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="034568.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="034572.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#34569">[ date ]</a>
              <a href="thread.html#34569">[ thread ]</a>
              <a href="subject.html#34569">[ subject ]</a>
              <a href="author.html#34569">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
