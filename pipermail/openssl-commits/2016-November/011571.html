<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-November/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1479361480.855382.355.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011568.html">
   <LINK REL="Next"  HREF="011576.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1479361480.855382.355.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Thu Nov 17 05:44:40 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="011568.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="011576.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11571">[ date ]</a>
              <a href="thread.html#11571">[ thread ]</a>
              <a href="subject.html#11571">[ subject ]</a>
              <a href="author.html#11571">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  86ff6cc6b2f2718fadbdc2a2c7add51949bcd4a4 (commit)
       via  b756d694b6edb97a2827d97591e486f4096f0cd3 (commit)
       via  79438087fe48a72f8b62a77956436fd0c4c3d8e4 (commit)
       via  9bffdebc38495f051b6e77ae7f6beda0da7635cb (commit)
       via  f7d984ddd4c69b286979eae19a4a3a52ea5cf380 (commit)
       via  db1dd9368a153d6eac2256f86936207f9d777b32 (commit)
       via  2e4c3b5caa3596d4649dfdb8cb072a44e559d96b (commit)
       via  29dd15b18d9ed968a9035a69bbd913847b9c2646 (commit)
       via  cc98e63938c6710fa3c79679adcffa754390ecaa (commit)
       via  dfdd45f72c03d19ba815a127cab1338eff8084e9 (commit)
       via  c29c7aadb95a8ad647314bfe1bf45b2f7423e51d (commit)
       via  ed7377dba90365c81a9bcdcbac69f9758dde57dd (commit)
      from  d922634d0c63cee01c89869d79306cd2df628855 (commit)


- Log -----------------------------------------------------------------
commit 86ff6cc6b2f2718fadbdc2a2c7add51949bcd4a4
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Fri Oct 7 17:23:17 2016 +0300

    Handle &quot;int_ctx_new:unsupported algorithm&quot; error
    
    Calling EVP_PKEY_CTX_new_id(curve_NID, NULL) causes an error for most
    curves that are implemented through the EC low-level API, and in the
    last commit we call it for every curve to avoid treating X25519 as a
    special case.
    
    Last commit code already handles correctly this failure, but does not
    remove these events from the thread error queue, thus some
    false-positive warnings are printed at the end of execution.
    
    This commit ensures that the error queue is clean, without flushing
    other errors.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit b756d694b6edb97a2827d97591e486f4096f0cd3
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Fri Oct 7 16:24:22 2016 +0300

    Do not handle R_EC_X25519 as a special case
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit 79438087fe48a72f8b62a77956436fd0c4c3d8e4
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Fri Oct 7 14:59:32 2016 +0300

    Remove leftover KDF pointer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit 9bffdebc38495f051b6e77ae7f6beda0da7635cb
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Thu Oct 6 13:17:00 2016 +0300

    Use CRYPTO_memcmp for comparing derived secrets
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit f7d984ddd4c69b286979eae19a4a3a52ea5cf380
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Tue Oct 4 16:40:47 2016 +0300

    Reintroduce preliminary sanity check in ECDH speed and remove further checks in the benchmark loop.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit db1dd9368a153d6eac2256f86936207f9d777b32
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Tue Oct 4 15:56:49 2016 +0300

    Remove ECDH_EVP_derive_key wrapper function
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit 2e4c3b5caa3596d4649dfdb8cb072a44e559d96b
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Tue Oct 4 15:50:11 2016 +0300

    More coding style fixes
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit 29dd15b18d9ed968a9035a69bbd913847b9c2646
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Tue Oct 4 09:20:49 2016 +0300

    Run util/openssl-format-source against apps/speed.c
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit cc98e63938c6710fa3c79679adcffa754390ecaa
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Tue Oct 4 09:17:11 2016 +0300

    bugfix: calculate outlen for each curve
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit dfdd45f72c03d19ba815a127cab1338eff8084e9
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Tue Oct 4 01:30:54 2016 +0300

    Handle EVP_PKEY_derive errors and fix coding style issues
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit c29c7aadb95a8ad647314bfe1bf45b2f7423e51d
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Mon Oct 3 22:16:07 2016 +0300

    Fix coding style and remove some stale code/comments
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

commit ed7377dba90365c81a9bcdcbac69f9758dde57dd
Author: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
Date:   Mon Oct 3 20:28:32 2016 +0300

    Use EVP interface for ECDH in apps/speed.c
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1658">https://github.com/openssl/openssl/pull/1658</A>)

-----------------------------------------------------------------------

Summary of changes:
 apps/speed.c | 526 ++++++++++++++++++++++++++++++++++-------------------------
 1 file changed, 300 insertions(+), 226 deletions(-)

diff --git a/apps/speed.c b/apps/speed.c
index 0e4d224..10b7f97 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -144,9 +144,6 @@ static volatile int run = 0;
 static int mr = 0;
 static int usertime = 1;
 
-typedef void *(*kdf_fn) (
-        const void *in, size_t inlen, void *out, size_t *xoutlen);
-
 typedef struct loopargs_st {
     ASYNC_JOB *inprogress_job;
     ASYNC_WAIT_CTX *wait_ctx;
@@ -163,12 +160,10 @@ typedef struct loopargs_st {
 #endif
 #ifndef OPENSSL_NO_EC
     EC_KEY *ecdsa[EC_NUM];
-    EC_KEY *ecdh_a[EC_NUM];
-    EC_KEY *ecdh_b[EC_NUM];
+    EVP_PKEY_CTX *ecdh_ctx[EC_NUM];
     unsigned char *secret_a;
     unsigned char *secret_b;
-    size_t      outlen;
-    kdf_fn      kdf;
+    size_t outlen[EC_NUM];
 #endif
     EVP_CIPHER_CTX *ctx;
     HMAC_CTX *hctx;
@@ -225,9 +220,9 @@ static int DSA_verify_loop(void *args);
 #ifndef OPENSSL_NO_EC
 static int ECDSA_sign_loop(void *args);
 static int ECDSA_verify_loop(void *args);
-static int ECDH_compute_key_loop(void *args);
 #endif
-static int run_benchmark(int async_jobs, int (*loop_function)(void *), loopargs_t *loopargs);
+static int run_benchmark(int async_jobs, int (*loop_function) (void *),
+                         loopargs_t * loopargs);
 
 static double Time_F(int s);
 static void print_message(const char *s, long num, int length);
@@ -583,7 +578,7 @@ static OPT_PAIR ecdh_choices[] = {
 #else
 # define COND(unused_cond) (run &amp;&amp; count&lt;0x7fffffff)
 # define COUNT(d) (count)
-#endif                         /* SIGALRM */
+#endif                          /* SIGALRM */
 
 static int testnum;
 
@@ -593,14 +588,14 @@ static long c[ALGOR_NUM][SIZE_NUM];
 #ifndef OPENSSL_NO_MD2
 static int EVP_Digest_MD2_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char md2[MD2_DIGEST_LENGTH];
     int count;
 
     for (count = 0; COND(c[D_MD2][testnum]); count++) {
         if (!EVP_Digest(buf, (size_t)lengths[testnum], md2, NULL, EVP_md2(),
-                NULL))
+                        NULL))
             return -1;
     }
     return count;
@@ -610,14 +605,14 @@ static int EVP_Digest_MD2_loop(void *args)
 #ifndef OPENSSL_NO_MDC2
 static int EVP_Digest_MDC2_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char mdc2[MDC2_DIGEST_LENGTH];
     int count;
 
     for (count = 0; COND(c[D_MDC2][testnum]); count++) {
         if (!EVP_Digest(buf, (size_t)lengths[testnum], mdc2, NULL, EVP_mdc2(),
-                NULL))
+                        NULL))
             return -1;
     }
     return count;
@@ -627,14 +622,14 @@ static int EVP_Digest_MDC2_loop(void *args)
 #ifndef OPENSSL_NO_MD4
 static int EVP_Digest_MD4_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char md4[MD4_DIGEST_LENGTH];
     int count;
 
     for (count = 0; COND(c[D_MD4][testnum]); count++) {
         if (!EVP_Digest(buf, (size_t)lengths[testnum], md4, NULL, EVP_md4(),
-                NULL))
+                        NULL))
             return -1;
     }
     return count;
@@ -644,7 +639,7 @@ static int EVP_Digest_MD4_loop(void *args)
 #ifndef OPENSSL_NO_MD5
 static int MD5_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char md5[MD5_DIGEST_LENGTH];
     int count;
@@ -655,7 +650,7 @@ static int MD5_loop(void *args)
 
 static int HMAC_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     HMAC_CTX *hctx = tempargs-&gt;hctx;
     unsigned char hmac[MD5_DIGEST_LENGTH];
@@ -672,7 +667,7 @@ static int HMAC_loop(void *args)
 
 static int SHA1_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char sha[SHA_DIGEST_LENGTH];
     int count;
@@ -683,7 +678,7 @@ static int SHA1_loop(void *args)
 
 static int SHA256_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char sha256[SHA256_DIGEST_LENGTH];
     int count;
@@ -694,7 +689,7 @@ static int SHA256_loop(void *args)
 
 static int SHA512_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char sha512[SHA512_DIGEST_LENGTH];
     int count;
@@ -706,7 +701,7 @@ static int SHA512_loop(void *args)
 #ifndef OPENSSL_NO_WHIRLPOOL
 static int WHIRLPOOL_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char whirlpool[WHIRLPOOL_DIGEST_LENGTH];
     int count;
@@ -719,13 +714,13 @@ static int WHIRLPOOL_loop(void *args)
 #ifndef OPENSSL_NO_RMD160
 static int EVP_Digest_RMD160_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char rmd160[RIPEMD160_DIGEST_LENGTH];
     int count;
     for (count = 0; COND(c[D_RMD160][testnum]); count++) {
         if (!EVP_Digest(buf, (size_t)lengths[testnum], &amp;(rmd160[0]),
-                NULL, EVP_ripemd160(), NULL))
+                        NULL, EVP_ripemd160(), NULL))
             return -1;
     }
     return count;
@@ -736,7 +731,7 @@ static int EVP_Digest_RMD160_loop(void *args)
 static RC4_KEY rc4_ks;
 static int RC4_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     int count;
     for (count = 0; COND(c[D_RC4][testnum]); count++)
@@ -752,24 +747,23 @@ static DES_key_schedule sch2;
 static DES_key_schedule sch3;
 static int DES_ncbc_encrypt_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     int count;
     for (count = 0; COND(c[D_CBC_DES][testnum]); count++)
         DES_ncbc_encrypt(buf, buf, lengths[testnum], &amp;sch,
-                &amp;DES_iv, DES_ENCRYPT);
+                         &amp;DES_iv, DES_ENCRYPT);
     return count;
 }
 
 static int DES_ede3_cbc_encrypt_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     int count;
     for (count = 0; COND(c[D_EDE3_DES][testnum]); count++)
         DES_ede3_cbc_encrypt(buf, buf, lengths[testnum],
-                &amp;sch, &amp;sch2, &amp;sch3,
-                &amp;DES_iv, DES_ENCRYPT);
+                             &amp;sch, &amp;sch2, &amp;sch3, &amp;DES_iv, DES_ENCRYPT);
     return count;
 }
 #endif
@@ -780,82 +774,76 @@ static unsigned char iv[2 * MAX_BLOCK_SIZE / 8];
 static AES_KEY aes_ks1, aes_ks2, aes_ks3;
 static int AES_cbc_128_encrypt_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     int count;
     for (count = 0; COND(c[D_CBC_128_AES][testnum]); count++)
         AES_cbc_encrypt(buf, buf,
-                (size_t)lengths[testnum], &amp;aes_ks1,
-                iv, AES_ENCRYPT);
+                        (size_t)lengths[testnum], &amp;aes_ks1, iv, AES_ENCRYPT);
     return count;
 }
 
 static int AES_cbc_192_encrypt_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     int count;
     for (count = 0; COND(c[D_CBC_192_AES][testnum]); count++)
         AES_cbc_encrypt(buf, buf,
-                (size_t)lengths[testnum], &amp;aes_ks2,
-                iv, AES_ENCRYPT);
+                        (size_t)lengths[testnum], &amp;aes_ks2, iv, AES_ENCRYPT);
     return count;
 }
 
 static int AES_cbc_256_encrypt_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     int count;
     for (count = 0; COND(c[D_CBC_256_AES][testnum]); count++)
         AES_cbc_encrypt(buf, buf,
-                (size_t)lengths[testnum], &amp;aes_ks3,
-                iv, AES_ENCRYPT);
+                        (size_t)lengths[testnum], &amp;aes_ks3, iv, AES_ENCRYPT);
     return count;
 }
 
 static int AES_ige_128_encrypt_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
     int count;
     for (count = 0; COND(c[D_IGE_128_AES][testnum]); count++)
         AES_ige_encrypt(buf, buf2,
-                (size_t)lengths[testnum], &amp;aes_ks1,
-                iv, AES_ENCRYPT);
+                        (size_t)lengths[testnum], &amp;aes_ks1, iv, AES_ENCRYPT);
     return count;
 }
 
 static int AES_ige_192_encrypt_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
     int count;
     for (count = 0; COND(c[D_IGE_192_AES][testnum]); count++)
         AES_ige_encrypt(buf, buf2,
-                (size_t)lengths[testnum], &amp;aes_ks2,
-                iv, AES_ENCRYPT);
+                        (size_t)lengths[testnum], &amp;aes_ks2, iv, AES_ENCRYPT);
     return count;
 }
 
 static int AES_ige_256_encrypt_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
     int count;
     for (count = 0; COND(c[D_IGE_256_AES][testnum]); count++)
         AES_ige_encrypt(buf, buf2,
-                (size_t)lengths[testnum], &amp;aes_ks3,
-                iv, AES_ENCRYPT);
+                        (size_t)lengths[testnum], &amp;aes_ks3, iv, AES_ENCRYPT);
     return count;
 }
 
 static int CRYPTO_gcm128_aad_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     GCM128_CONTEXT *gcm_ctx = tempargs-&gt;gcm_ctx;
     int count;
@@ -868,7 +856,7 @@ static long save_count = 0;
 static int decrypt = 0;
 static int EVP_Update_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     EVP_CIPHER_CTX *ctx = tempargs-&gt;ctx;
     int outl, count;
@@ -891,7 +879,7 @@ static int EVP_Update_loop(void *args)
 static const EVP_MD *evp_md = NULL;
 static int EVP_Digest_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char md[EVP_MAX_MD_SIZE];
     int count;
@@ -911,7 +899,7 @@ static long rsa_c[RSA_NUM][2];  /* # RSA iteration test */
 
 static int RSA_sign_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
     unsigned int *rsa_num = &amp;tempargs-&gt;siglen;
@@ -931,14 +919,15 @@ static int RSA_sign_loop(void *args)
 
 static int RSA_verify_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
     unsigned int rsa_num = tempargs-&gt;siglen;
     RSA **rsa_key = tempargs-&gt;rsa_key;
     int ret, count;
     for (count = 0; COND(rsa_c[testnum][1]); count++) {
-        ret = RSA_verify(NID_md5_sha1, buf, 36, buf2, rsa_num, rsa_key[testnum]);
+        ret =
+            RSA_verify(NID_md5_sha1, buf, 36, buf2, rsa_num, rsa_key[testnum]);
         if (ret &lt;= 0) {
             BIO_printf(bio_err, &quot;RSA verify failure\n&quot;);
             ERR_print_errors(bio_err);
@@ -954,7 +943,7 @@ static int RSA_verify_loop(void *args)
 static long dsa_c[DSA_NUM][2];
 static int DSA_sign_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
     DSA **dsa_key = tempargs-&gt;dsa_key;
@@ -974,7 +963,7 @@ static int DSA_sign_loop(void *args)
 
 static int DSA_verify_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
     DSA **dsa_key = tempargs-&gt;dsa_key;
@@ -997,15 +986,14 @@ static int DSA_verify_loop(void *args)
 static long ecdsa_c[EC_NUM][2];
 static int ECDSA_sign_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     EC_KEY **ecdsa = tempargs-&gt;ecdsa;
     unsigned char *ecdsasig = tempargs-&gt;buf2;
     unsigned int *ecdsasiglen = &amp;tempargs-&gt;siglen;
     int ret, count;
     for (count = 0; COND(ecdsa_c[testnum][0]); count++) {
-        ret = ECDSA_sign(0, buf, 20,
-                ecdsasig, ecdsasiglen, ecdsa[testnum]);
+        ret = ECDSA_sign(0, buf, 20, ecdsasig, ecdsasiglen, ecdsa[testnum]);
         if (ret == 0) {
             BIO_printf(bio_err, &quot;ECDSA sign failure\n&quot;);
             ERR_print_errors(bio_err);
@@ -1018,15 +1006,14 @@ static int ECDSA_sign_loop(void *args)
 
 static int ECDSA_verify_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
+    loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     EC_KEY **ecdsa = tempargs-&gt;ecdsa;
     unsigned char *ecdsasig = tempargs-&gt;buf2;
     unsigned int ecdsasiglen = tempargs-&gt;siglen;
     int ret, count;
     for (count = 0; COND(ecdsa_c[testnum][1]); count++) {
-        ret = ECDSA_verify(0, buf, 20, ecdsasig, ecdsasiglen,
-                ecdsa[testnum]);
+        ret = ECDSA_verify(0, buf, 20, ecdsasig, ecdsasiglen, ecdsa[testnum]);
         if (ret != 1) {
             BIO_printf(bio_err, &quot;ECDSA verify failure\n&quot;);
             ERR_print_errors(bio_err);
@@ -1040,37 +1027,24 @@ static int ECDSA_verify_loop(void *args)
 /* ******************************************************************** */
 static long ecdh_c[EC_NUM][1];
 
-static int ECDH_compute_key_loop(void *args)
+static int ECDH_EVP_derive_key_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **)args;
-    EC_KEY **ecdh_a = tempargs-&gt;ecdh_a;
-    EC_KEY **ecdh_b = tempargs-&gt;ecdh_b;
-    unsigned char *secret_a = tempargs-&gt;secret_a;
+    loopargs_t *tempargs = *(loopargs_t **) args;
+    EVP_PKEY_CTX *ctx = tempargs-&gt;ecdh_ctx[testnum];
+    unsigned char *derived_secret = tempargs-&gt;secret_a;
     int count;
-    size_t outlen = tempargs-&gt;outlen;
-    kdf_fn kdf = tempargs-&gt;kdf;
+    size_t *outlen = &amp;(tempargs-&gt;outlen[testnum]);
+
+    for (count = 0; COND(ecdh_c[testnum][0]); count++)
+        EVP_PKEY_derive(ctx, derived_secret, outlen);
 
-    for (count = 0; COND(ecdh_c[testnum][0]); count++) {
-        ECDH_compute_key(secret_a, outlen,
-                EC_KEY_get0_public_key(ecdh_b[testnum]),
-                ecdh_a[testnum], kdf);
-    }
     return count;
 }
 
-static const size_t KDF1_SHA1_len = 20;
-static void *KDF1_SHA1(const void *in, size_t inlen, void *out,
-                       size_t *outlen)
-{
-    if (*outlen &lt; SHA_DIGEST_LENGTH)
-        return NULL;
-    *outlen = SHA_DIGEST_LENGTH;
-    return SHA1(in, inlen, out);
-}
 #endif                          /* OPENSSL_NO_EC */
 
 static int run_benchmark(int async_jobs,
-                         int (*loop_function)(void *), loopargs_t *loopargs)
+                         int (*loop_function) (void *), loopargs_t * loopargs)
 {
     int job_op_count = 0;
     int total_op_count = 0;
@@ -1126,14 +1100,16 @@ static int run_benchmark(int async_jobs,
             if (loopargs[i].inprogress_job == NULL)
                 continue;
 
-            if (!ASYNC_WAIT_CTX_get_all_fds(loopargs[i].wait_ctx, NULL, &amp;num_job_fds)
-                    || num_job_fds &gt; 1) {
+            if (!ASYNC_WAIT_CTX_get_all_fds
+                (loopargs[i].wait_ctx, NULL, &amp;num_job_fds)
+                || num_job_fds &gt; 1) {
                 BIO_printf(bio_err, &quot;Too many fds in ASYNC_WAIT_CTX\n&quot;);
                 ERR_print_errors(bio_err);
                 error = 1;
                 break;
             }
-            ASYNC_WAIT_CTX_get_all_fds(loopargs[i].wait_ctx, &amp;job_fd, &amp;num_job_fds);
+            ASYNC_WAIT_CTX_get_all_fds(loopargs[i].wait_ctx, &amp;job_fd,
+                                       &amp;num_job_fds);
             FD_SET(job_fd, &amp;waitfdset);
             if (job_fd &gt; max_fd)
                 max_fd = job_fd;
@@ -1141,9 +1117,9 @@ static int run_benchmark(int async_jobs,
 
         if (max_fd &gt;= (OSSL_ASYNC_FD)FD_SETSIZE) {
             BIO_printf(bio_err,
-                    &quot;Error: max_fd (%d) must be smaller than FD_SETSIZE (%d). &quot;
-                    &quot;Decrease the value of async_jobs\n&quot;,
-                    max_fd, FD_SETSIZE);
+                       &quot;Error: max_fd (%d) must be smaller than FD_SETSIZE (%d). &quot;
+                       &quot;Decrease the value of async_jobs\n&quot;,
+                       max_fd, FD_SETSIZE);
             ERR_print_errors(bio_err);
             error = 1;
             break;
@@ -1168,14 +1144,16 @@ static int run_benchmark(int async_jobs,
             if (loopargs[i].inprogress_job == NULL)
                 continue;
 
-            if (!ASYNC_WAIT_CTX_get_all_fds(loopargs[i].wait_ctx, NULL, &amp;num_job_fds)
-                    || num_job_fds &gt; 1) {
+            if (!ASYNC_WAIT_CTX_get_all_fds
+                (loopargs[i].wait_ctx, NULL, &amp;num_job_fds)
+                || num_job_fds &gt; 1) {
                 BIO_printf(bio_err, &quot;Too many fds in ASYNC_WAIT_CTX\n&quot;);
                 ERR_print_errors(bio_err);
                 error = 1;
                 break;
             }
-            ASYNC_WAIT_CTX_get_all_fds(loopargs[i].wait_ctx, &amp;job_fd, &amp;num_job_fds);
+            ASYNC_WAIT_CTX_get_all_fds(loopargs[i].wait_ctx, &amp;job_fd,
+                                       &amp;num_job_fds);
 
 #if defined(OPENSSL_SYS_UNIX)
             if (num_job_fds == 1 &amp;&amp; !FD_ISSET(job_fd, &amp;waitfdset))
@@ -1188,8 +1166,9 @@ static int run_benchmark(int async_jobs,
 #endif
 
             ret = ASYNC_start_job(&amp;loopargs[i].inprogress_job,
-                    loopargs[i].wait_ctx, &amp;job_op_count, loop_function,
-                    (void *)(loopargs + i), sizeof(loopargs_t));
+                                  loopargs[i].wait_ctx, &amp;job_op_count,
+                                  loop_function, (void *)(loopargs + i),
+                                  sizeof(loopargs_t));
             switch (ret) {
             case ASYNC_PAUSE:
                 break;
@@ -1355,7 +1334,7 @@ int speed_main(int argc, char **argv)
         163, 233, 283,
         409, 571, 163,
         233, 283, 409,
-        571, 253 /* X25519 */
+        571, 253                /* X25519 */
     };
 
     int ecdsa_doit[EC_NUM] = { 0 };
@@ -1443,7 +1422,7 @@ int speed_main(int argc, char **argv)
     argv = opt_rest();
 
     /* Remaining arguments are algorithms. */
-    for ( ; *argv; argv++) {
+    for (; *argv; argv++) {
         if (found(*argv, doit_choices, &amp;i)) {
             doit[i] = 1;
             continue;
@@ -1489,14 +1468,12 @@ int speed_main(int argc, char **argv)
         }
 #endif
         if (strcmp(*argv, &quot;aes&quot;) == 0) {
-            doit[D_CBC_128_AES] = doit[D_CBC_192_AES] =
-                doit[D_CBC_256_AES] = 1;
+            doit[D_CBC_128_AES] = doit[D_CBC_192_AES] = doit[D_CBC_256_AES] = 1;
             continue;
         }
 #ifndef OPENSSL_NO_CAMELLIA
         if (strcmp(*argv, &quot;camellia&quot;) == 0) {
-            doit[D_CBC_128_CML] = doit[D_CBC_192_CML] =
-                doit[D_CBC_256_CML] = 1;
+            doit[D_CBC_128_CML] = doit[D_CBC_192_CML] = doit[D_CBC_256_CML] = 1;
             continue;
         }
 #endif
@@ -1534,7 +1511,8 @@ int speed_main(int argc, char **argv)
     }
 
     loopargs_len = (async_jobs == 0 ? 1 : async_jobs);
-    loopargs = app_malloc(loopargs_len * sizeof(loopargs_t), &quot;array of loopargs&quot;);
+    loopargs =
+        app_malloc(loopargs_len * sizeof(loopargs_t), &quot;array of loopargs&quot;);
     memset(loopargs, 0, loopargs_len * sizeof(loopargs_t));
 
     for (i = 0; i &lt; loopargs_len; i++) {
@@ -1546,8 +1524,10 @@ int speed_main(int argc, char **argv)
             }
         }
 
-        loopargs[i].buf_malloc = app_malloc((int)BUFSIZE + MAX_MISALIGNMENT + 1, &quot;input buffer&quot;);
-        loopargs[i].buf2_malloc = app_malloc((int)BUFSIZE + MAX_MISALIGNMENT + 1, &quot;input buffer&quot;);
+        loopargs[i].buf_malloc =
+            app_malloc((int)BUFSIZE + MAX_MISALIGNMENT + 1, &quot;input buffer&quot;);
+        loopargs[i].buf2_malloc =
+            app_malloc((int)BUFSIZE + MAX_MISALIGNMENT + 1, &quot;input buffer&quot;);
         /* Align the start of buffers on a 64 byte boundary */
         loopargs[i].buf = loopargs[i].buf_malloc + misalign;
         loopargs[i].buf2 = loopargs[i].buf2_malloc + misalign;
@@ -1600,10 +1580,11 @@ int speed_main(int argc, char **argv)
             const unsigned char *p;
 
             p = rsa_data[k];
-            loopargs[i].rsa_key[k] = d2i_RSAPrivateKey(NULL, &amp;p, rsa_data_length[k]);
+            loopargs[i].rsa_key[k] =
+                d2i_RSAPrivateKey(NULL, &amp;p, rsa_data_length[k]);
             if (loopargs[i].rsa_key[k] == NULL) {
-                BIO_printf(bio_err, &quot;internal error loading RSA key number %d\n&quot;,
-                        k);
+                BIO_printf(bio_err,
+                           &quot;internal error loading RSA key number %d\n&quot;, k);
                 goto end;
             }
         }
@@ -1744,7 +1725,7 @@ int speed_main(int argc, char **argv)
             rsa_doit[i] = 0;
         else {
             if (rsa_c[i][0] == 0) {
-                rsa_c[i][0] = 1;            /* Set minimum iteration Nb to 1. */
+                rsa_c[i][0] = 1; /* Set minimum iteration Nb to 1. */
                 rsa_c[i][1] = 20;
             }
         }
@@ -1761,7 +1742,7 @@ int speed_main(int argc, char **argv)
             dsa_doit[i] = 0;
         else {
             if (dsa_c[i][0] == 0) {
-                dsa_c[i][0] = 1;            /* Set minimum iteration Nb to 1. */
+                dsa_c[i][0] = 1; /* Set minimum iteration Nb to 1. */
                 dsa_c[i][1] = 1;
             }
         }
@@ -1850,12 +1831,12 @@ int speed_main(int argc, char **argv)
 # else
 /* not worth fixing */
 #  error &quot;You cannot disable DES on systems without SIGALRM.&quot;
-# endif                        /* OPENSSL_NO_DES */
+# endif                         /* OPENSSL_NO_DES */
 #else
 # ifndef _WIN32
     signal(SIGALRM, sig_done);
 # endif
-#endif                         /* SIGALRM */
+#endif                          /* SIGALRM */
 
 #ifndef OPENSSL_NO_MD2
     if (doit[D_MD2]) {
@@ -1939,7 +1920,8 @@ int speed_main(int argc, char **argv)
     }
     if (doit[D_SHA256]) {
         for (testnum = 0; testnum &lt; SIZE_NUM; testnum++) {
-            print_message(names[D_SHA256], c[D_SHA256][testnum], lengths[testnum]);
+            print_message(names[D_SHA256], c[D_SHA256][testnum],
+                          lengths[testnum]);
             Time_F(START);
             count = run_benchmark(async_jobs, SHA256_loop, loopargs);
             d = Time_F(STOP);
@@ -1948,18 +1930,19 @@ int speed_main(int argc, char **argv)
     }
     if (doit[D_SHA512]) {
         for (testnum = 0; testnum &lt; SIZE_NUM; testnum++) {
-            print_message(names[D_SHA512], c[D_SHA512][testnum], lengths[testnum]);
+            print_message(names[D_SHA512], c[D_SHA512][testnum],
+                          lengths[testnum]);
             Time_F(START);
             count = run_benchmark(async_jobs, SHA512_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_SHA512, testnum, count, d);
         }
     }
-
 #ifndef OPENSSL_NO_WHIRLPOOL
     if (doit[D_WHIRLPOOL]) {
         for (testnum = 0; testnum &lt; SIZE_NUM; testnum++) {
-            print_message(names[D_WHIRLPOOL], c[D_WHIRLPOOL][testnum], lengths[testnum]);
+            print_message(names[D_WHIRLPOOL], c[D_WHIRLPOOL][testnum],
+                          lengths[testnum]);
             Time_F(START);
             count = run_benchmark(async_jobs, WHIRLPOOL_loop, loopargs);
             d = Time_F(STOP);
@@ -1971,7 +1954,8 @@ int speed_main(int argc, char **argv)
 #ifndef OPENSSL_NO_RMD160
     if (doit[D_RMD160]) {
         for (testnum = 0; testnum &lt; SIZE_NUM; testnum++) {
-            print_message(names[D_RMD160], c[D_RMD160][testnum], lengths[testnum]);
+            print_message(names[D_RMD160], c[D_RMD160][testnum],
+                          lengths[testnum]);
             Time_F(START);
             count = run_benchmark(async_jobs, EVP_Digest_RMD160_loop, loopargs);
             d = Time_F(STOP);
@@ -1993,7 +1977,8 @@ int speed_main(int argc, char **argv)
 #ifndef OPENSSL_NO_DES
     if (doit[D_CBC_DES]) {
         for (testnum = 0; testnum &lt; SIZE_NUM; testnum++) {
-            print_message(names[D_CBC_DES], c[D_CBC_DES][testnum], lengths[testnum]);
+            print_message(names[D_CBC_DES], c[D_CBC_DES][testnum],
+                          lengths[testnum]);
             Time_F(START);
             count = run_benchmark(async_jobs, DES_ncbc_encrypt_loop, loopargs);
             d = Time_F(STOP);
@@ -2003,9 +1988,11 @@ int speed_main(int argc, char **argv)
 
     if (doit[D_EDE3_DES]) {
         for (testnum = 0; testnum &lt; SIZE_NUM; testnum++) {
-            print_message(names[D_EDE3_DES], c[D_EDE3_DES][testnum], lengths[testnum]);
+            print_message(names[D_EDE3_DES], c[D_EDE3_DES][testnum],
+                          lengths[testnum]);
             Time_F(START);
-            count = run_benchmark(async_jobs, DES_ede3_cbc_encrypt_loop, loopargs);
+            count =
+                run_benchmark(async_jobs, DES_ede3_cbc_encrypt_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_EDE3_DES, testnum, count, d);
         }
@@ -2017,7 +2004,8 @@ int speed_main(int argc, char **argv)
             print_message(names[D_CBC_128_AES], c[D_CBC_128_AES][testnum],
                           lengths[testnum]);
             Time_F(START);
-            count = run_benchmark(async_jobs, AES_cbc_128_encrypt_loop, loopargs);
+            count =
+                run_benchmark(async_jobs, AES_cbc_128_encrypt_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_CBC_128_AES, testnum, count, d);
         }
@@ -2027,7 +2015,8 @@ int speed_main(int argc, char **argv)
             print_message(names[D_CBC_192_AES], c[D_CBC_192_AES][testnum],
                           lengths[testnum]);
             Time_F(START);
-            count = run_benchmark(async_jobs, AES_cbc_192_encrypt_loop, loopargs);
+            count =
+                run_benchmark(async_jobs, AES_cbc_192_encrypt_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_CBC_192_AES, testnum, count, d);
         }
@@ -2037,7 +2026,8 @@ int speed_main(int argc, char **argv)
             print_message(names[D_CBC_256_AES], c[D_CBC_256_AES][testnum],
                           lengths[testnum]);
             Time_F(START);
-            count = run_benchmark(async_jobs, AES_cbc_256_encrypt_loop, loopargs);
+            count =
+                run_benchmark(async_jobs, AES_cbc_256_encrypt_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_CBC_256_AES, testnum, count, d);
         }
@@ -2048,7 +2038,8 @@ int speed_main(int argc, char **argv)
             print_message(names[D_IGE_128_AES], c[D_IGE_128_AES][testnum],
                           lengths[testnum]);
             Time_F(START);
-            count = run_benchmark(async_jobs, AES_ige_128_encrypt_loop, loopargs);
+            count =
+                run_benchmark(async_jobs, AES_ige_128_encrypt_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_IGE_128_AES, testnum, count, d);
         }
@@ -2058,7 +2049,8 @@ int speed_main(int argc, char **argv)
             print_message(names[D_IGE_192_AES], c[D_IGE_192_AES][testnum],
                           lengths[testnum]);
             Time_F(START);
-            count = run_benchmark(async_jobs, AES_ige_192_encrypt_loop, loopargs);
+            count =
+                run_benchmark(async_jobs, AES_ige_192_encrypt_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_IGE_192_AES, testnum, count, d);
         }
@@ -2068,19 +2060,23 @@ int speed_main(int argc, char **argv)
             print_message(names[D_IGE_256_AES], c[D_IGE_256_AES][testnum],
                           lengths[testnum]);
             Time_F(START);
-            count = run_benchmark(async_jobs, AES_ige_256_encrypt_loop, loopargs);
+            count =
+                run_benchmark(async_jobs, AES_ige_256_encrypt_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_IGE_256_AES, testnum, count, d);
         }
     }
     if (doit[D_GHASH]) {
         for (i = 0; i &lt; loopargs_len; i++) {
-            loopargs[i].gcm_ctx = CRYPTO_gcm128_new(&amp;aes_ks1, (block128_f) AES_encrypt);
-            CRYPTO_gcm128_setiv(loopargs[i].gcm_ctx, (unsigned char *)&quot;0123456789ab&quot;, 12);
+            loopargs[i].gcm_ctx =
+                CRYPTO_gcm128_new(&amp;aes_ks1, (block128_f) AES_encrypt);
+            CRYPTO_gcm128_setiv(loopargs[i].gcm_ctx,
+                                (unsigned char *)&quot;0123456789ab&quot;, 12);
         }
 
         for (testnum = 0; testnum &lt; SIZE_NUM; testnum++) {
-            print_message(names[D_GHASH], c[D_GHASH][testnum], lengths[testnum]);
+            print_message(names[D_GHASH], c[D_GHASH][testnum],
+                          lengths[testnum]);
             Time_F(START);
             count = run_benchmark(async_jobs, CRYPTO_gcm128_aad_loop, loopargs);
             d = Time_F(STOP);
@@ -2089,7 +2085,6 @@ int speed_main(int argc, char **argv)
         for (i = 0; i &lt; loopargs_len; i++)
             CRYPTO_gcm128_release(loopargs[i].gcm_ctx);
     }
-
 #ifndef OPENSSL_NO_CAMELLIA
     if (doit[D_CBC_128_CML]) {
         if (async_jobs &gt; 0) {
@@ -2158,7 +2153,8 @@ int speed_main(int argc, char **argv)
             doit[D_CBC_IDEA] = 0;
         }
         for (testnum = 0; testnum &lt; SIZE_NUM &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_IDEA], c[D_CBC_IDEA][testnum], lengths[testnum]);
+            print_message(names[D_CBC_IDEA], c[D_CBC_IDEA][testnum],
+                          lengths[testnum]);
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_IDEA][testnum]); count++)
                 IDEA_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
@@ -2177,7 +2173,8 @@ int speed_main(int argc, char **argv)
             doit[D_CBC_SEED] = 0;
         }
         for (testnum = 0; testnum &lt; SIZE_NUM &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_SEED], c[D_CBC_SEED][testnum], lengths[testnum]);
+            print_message(names[D_CBC_SEED], c[D_CBC_SEED][testnum],
+                          lengths[testnum]);
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_SEED][testnum]); count++)
                 SEED_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
@@ -2195,7 +2192,8 @@ int speed_main(int argc, char **argv)
             doit[D_CBC_RC2] = 0;
         }
         for (testnum = 0; testnum &lt; SIZE_NUM &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_RC2], c[D_CBC_RC2][testnum], lengths[testnum]);
+            print_message(names[D_CBC_RC2], c[D_CBC_RC2][testnum],
+                          lengths[testnum]);
             if (async_jobs &gt; 0) {
                 BIO_printf(bio_err, &quot;Async mode is not supported, exiting...&quot;);
                 exit(1);
@@ -2218,7 +2216,8 @@ int speed_main(int argc, char **argv)
             doit[D_CBC_RC5] = 0;
         }
         for (testnum = 0; testnum &lt; SIZE_NUM &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_RC5], c[D_CBC_RC5][testnum], lengths[testnum]);
+            print_message(names[D_CBC_RC5], c[D_CBC_RC5][testnum],
+                          lengths[testnum]);
             if (async_jobs &gt; 0) {
                 BIO_printf(bio_err, &quot;Async mode is not supported, exiting...&quot;);
                 exit(1);
@@ -2241,7 +2240,8 @@ int speed_main(int argc, char **argv)
             doit[D_CBC_BF] = 0;
         }
         for (testnum = 0; testnum &lt; SIZE_NUM &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_BF], c[D_CBC_BF][testnum], lengths[testnum]);
+            print_message(names[D_CBC_BF], c[D_CBC_BF][testnum],
+                          lengths[testnum]);
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_BF][testnum]); count++)
                 BF_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
@@ -2260,7 +2260,8 @@ int speed_main(int argc, char **argv)
             doit[D_CBC_CAST] = 0;
         }
         for (testnum = 0; testnum &lt; SIZE_NUM &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_CAST], c[D_CBC_CAST][testnum], lengths[testnum]);
+            print_message(names[D_CBC_CAST], c[D_CBC_CAST][testnum],
+                          lengths[testnum]);
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_CAST][testnum]); count++)
                 CAST_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
@@ -2304,9 +2305,11 @@ int speed_main(int argc, char **argv)
                 for (k = 0; k &lt; loopargs_len; k++) {
                     loopargs[k].ctx = EVP_CIPHER_CTX_new();
                     if (decrypt)
-                        EVP_DecryptInit_ex(loopargs[k].ctx, evp_cipher, NULL, key16, iv);
+                        EVP_DecryptInit_ex(loopargs[k].ctx, evp_cipher, NULL,
+                                           key16, iv);
                     else
-                        EVP_EncryptInit_ex(loopargs[k].ctx, evp_cipher, NULL, key16, iv);
+                        EVP_EncryptInit_ex(loopargs[k].ctx, evp_cipher, NULL,
+                                           key16, iv);
                     EVP_CIPHER_CTX_set_padding(loopargs[k].ctx, 0);
                 }
 
@@ -2349,7 +2352,8 @@ int speed_main(int argc, char **argv)
             rsa_count = 1;
         } else {
             pkey_print_message(&quot;private&quot;, &quot;rsa&quot;,
-                               rsa_c[testnum][0], rsa_bits[testnum], RSA_SECONDS);
+                               rsa_c[testnum][0], rsa_bits[testnum],
+                               RSA_SECONDS);
             /* RSA_blinding_on(rsa_key[testnum],NULL); */
             Time_F(START);
             count = run_benchmark(async_jobs, RSA_sign_loop, loopargs);
@@ -2375,7 +2379,8 @@ int speed_main(int argc, char **argv)
             rsa_doit[testnum] = 0;
         } else {
             pkey_print_message(&quot;public&quot;, &quot;rsa&quot;,
-                               rsa_c[testnum][1], rsa_bits[testnum], RSA_SECONDS);
+                               rsa_c[testnum][1], rsa_bits[testnum],
+                               RSA_SECONDS);
             Time_F(START);
             count = run_benchmark(async_jobs, RSA_verify_loop, loopargs);
             d = Time_F(STOP);
@@ -2421,7 +2426,8 @@ int speed_main(int argc, char **argv)
             rsa_count = 1;
         } else {
             pkey_print_message(&quot;sign&quot;, &quot;dsa&quot;,
-                               dsa_c[testnum][0], dsa_bits[testnum], DSA_SECONDS);
+                               dsa_c[testnum][0], dsa_bits[testnum],
+                               DSA_SECONDS);
             Time_F(START);
             count = run_benchmark(async_jobs, DSA_sign_loop, loopargs);
             d = Time_F(STOP);
@@ -2446,7 +2452,8 @@ int speed_main(int argc, char **argv)
             dsa_doit[testnum] = 0;
         } else {
             pkey_print_message(&quot;verify&quot;, &quot;dsa&quot;,
-                               dsa_c[testnum][1], dsa_bits[testnum], DSA_SECONDS);
+                               dsa_c[testnum][1], dsa_bits[testnum],
+                               DSA_SECONDS);
             Time_F(START);
             count = run_benchmark(async_jobs, DSA_verify_loop, loopargs);
             d = Time_F(STOP);
@@ -2475,7 +2482,8 @@ int speed_main(int argc, char **argv)
         if (!ecdsa_doit[testnum])
             continue;           /* Ignore Curve */
         for (i = 0; i &lt; loopargs_len; i++) {
-            loopargs[i].ecdsa[testnum] = EC_KEY_new_by_curve_name(test_curves[testnum]);
+            loopargs[i].ecdsa[testnum] =
+                EC_KEY_new_by_curve_name(test_curves[testnum]);
             if (loopargs[i].ecdsa[testnum] == NULL) {
                 st = 0;
                 break;
@@ -2491,7 +2499,8 @@ int speed_main(int argc, char **argv)
                 /* Perform ECDSA signature test */
                 EC_KEY_generate_key(loopargs[i].ecdsa[testnum]);
                 st = ECDSA_sign(0, loopargs[i].buf, 20, loopargs[i].buf2,
-                                &amp;loopargs[i].siglen, loopargs[i].ecdsa[testnum]);
+                                &amp;loopargs[i].siglen,
+                                loopargs[i].ecdsa[testnum]);
                 if (st == 0)
                     break;
             }
@@ -2519,7 +2528,8 @@ int speed_main(int argc, char **argv)
             /* Perform ECDSA verification test */
             for (i = 0; i &lt; loopargs_len; i++) {
                 st = ECDSA_verify(0, loopargs[i].buf, 20, loopargs[i].buf2,
-                                  loopargs[i].siglen, loopargs[i].ecdsa[testnum]);
+                                  loopargs[i].siglen,
+                                  loopargs[i].ecdsa[testnum]);
                 if (st != 1)
                     break;
             }
@@ -2558,85 +2568,151 @@ int speed_main(int argc, char **argv)
 
         if (!ecdh_doit[testnum])
             continue;
+
         for (i = 0; i &lt; loopargs_len; i++) {
-            loopargs[i].ecdh_a[testnum] = EC_KEY_new_by_curve_name(test_curves[testnum]);
-            loopargs[i].ecdh_b[testnum] = EC_KEY_new_by_curve_name(test_curves[testnum]);
-            if (loopargs[i].ecdh_a[testnum] == NULL ||
-                loopargs[i].ecdh_b[testnum] == NULL) {
-                ecdh_checks = 0;
-                break;
+            EVP_PKEY_CTX *kctx = NULL;
+            EVP_PKEY_CTX *test_ctx = NULL;
+            EVP_PKEY_CTX *ctx = NULL;
+            EVP_PKEY *key_A = NULL;
+            EVP_PKEY *key_B = NULL;
+            size_t outlen;
+            size_t test_outlen;
+
+            /* Ensure that the error queue is empty */
+            if (ERR_peek_error()) {
+                BIO_printf(bio_err,
+                           &quot;WARNING: the error queue contains previous unhandled errors.\n&quot;);
+                ERR_print_errors(bio_err);
             }
-        }
-        if (ecdh_checks == 0) {
-            BIO_printf(bio_err, &quot;ECDH failure.\n&quot;);
-            ERR_print_errors(bio_err);
-            rsa_count = 1;
-        } else {
-            for (i = 0; i &lt; loopargs_len; i++) {
-                /* generate two ECDH key pairs */
-                if (!EC_KEY_generate_key(loopargs[i].ecdh_a[testnum]) ||
-                        !EC_KEY_generate_key(loopargs[i].ecdh_b[testnum])) {
-                    BIO_printf(bio_err, &quot;ECDH key generation failure.\n&quot;);
+
+            /* Let's try to create a ctx directly from the NID: this works for
+             * curves like Curve25519 that are not implemented through the low
+             * level EC interface.
+             * If this fails we try creating a EVP_PKEY_EC generic param ctx,
+             * then we set the curve by NID before deriving the actual keygen
+             * ctx for that specific curve. */
+            kctx = EVP_PKEY_CTX_new_id(test_curves[testnum], NULL); /* keygen ctx from NID */
+            if (!kctx) {
+                EVP_PKEY_CTX *pctx = NULL;
+                EVP_PKEY *params = NULL;
+
+                /* If we reach this code EVP_PKEY_CTX_new_id() failed and a
+                 * &quot;int_ctx_new:unsupported algorithm&quot; error was added to the
+                 * error queue.
+                 * We remove it from the error queue as we are handling it. */
+                unsigned long error = ERR_peek_error(); /* peek the latest error in the queue */
+                if (error == ERR_peek_last_error() &amp;&amp; /* oldest and latest errors match */
+                    /* check that the error origin matches */
+                    ERR_GET_LIB(error) == ERR_LIB_EVP &amp;&amp;
+                    ERR_GET_FUNC(error) == EVP_F_INT_CTX_NEW &amp;&amp;
+                    ERR_GET_REASON(error) == EVP_R_UNSUPPORTED_ALGORITHM)
+                    ERR_get_error(); /* pop error from queue */
+                if (ERR_peek_error()) {
+                    BIO_printf(bio_err,
+                               &quot;Unhandled error in the error queue during ECDH init.\n&quot;);
                     ERR_print_errors(bio_err);
+                    rsa_count = 1;
+                    break;
+                }
+
+                if (            /* Create the context for parameter generation */
+                       !(pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL)) ||
+                       /* Initialise the parameter generation */
+                       !EVP_PKEY_paramgen_init(pctx) ||
+                       /* Set the curve by NID */
+                       !EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx,
+                                                               test_curves
+                                                               [testnum]) ||
+                       /* Create the parameter object params */
+                       !EVP_PKEY_paramgen(pctx, &amp;params)) {
                     ecdh_checks = 0;
+                    BIO_printf(bio_err, &quot;ECDH EC params init failure.\n&quot;);
+                    ERR_print_errors(bio_err);
                     rsa_count = 1;
-                } else {
-                    int secret_size_a, secret_size_b;
-                    /*
-                     * If field size is not more than 24 octets, then use SHA-1
-                     * hash of result; otherwise, use result (see section 4.8 of
-                     * draft-ietf-tls-ecc-03.txt).
-                     */
-                    int field_size = EC_GROUP_get_degree(
-                            EC_KEY_get0_group(loopargs[i].ecdh_a[testnum]));
-
-                    if (field_size &lt;= 24 * 8) {                 /* 192 bits */
-                        loopargs[i].outlen = KDF1_SHA1_len;
-                        loopargs[i].kdf = KDF1_SHA1;
-                    } else {
-                        loopargs[i].outlen = (field_size + 7) / 8;
-                        loopargs[i].kdf = NULL;
-                    }
-                    secret_size_a =
-                        ECDH_compute_key(loopargs[i].secret_a, loopargs[i].outlen,
-                                EC_KEY_get0_public_key(loopargs[i].ecdh_b[testnum]),
-                                loopargs[i].ecdh_a[testnum], loopargs[i].kdf);
-                    secret_size_b =
-                        ECDH_compute_key(loopargs[i].secret_b, loopargs[i].outlen,
-                                EC_KEY_get0_public_key(loopargs[i].ecdh_a[testnum]),
-                                loopargs[i].ecdh_b[testnum], loopargs[i].kdf);
-                    if (secret_size_a != secret_size_b)
-                        ecdh_checks = 0;
-                    else
-                        ecdh_checks = 1;
-
-                    for (k = 0; k &lt; secret_size_a &amp;&amp; ecdh_checks == 1; k++) {
-                        if (loopargs[i].secret_a[k] != loopargs[i].secret_b[k])
-                            ecdh_checks = 0;
-                    }
-
-                    if (ecdh_checks == 0) {
-                        BIO_printf(bio_err, &quot;ECDH computations don't match.\n&quot;);
-                        ERR_print_errors(bio_err);
-                        rsa_count = 1;
-                        break;
-                    }
+                    break;
                 }
+                /* Create the context for the key generation */
+                kctx = EVP_PKEY_CTX_new(params, NULL);
+
+                EVP_PKEY_free(params);
+                params = NULL;
+                EVP_PKEY_CTX_free(pctx);
+                pctx = NULL;
             }
-            if (ecdh_checks != 0) {
-                pkey_print_message(&quot;&quot;, &quot;ecdh&quot;,
-                        ecdh_c[testnum][0],
-                        test_curves_bits[testnum], ECDH_SECONDS);
-                Time_F(START);
-                count = run_benchmark(async_jobs, ECDH_compute_key_loop, loopargs);
-                d = Time_F(STOP);
-                BIO_printf(bio_err,
-                        mr ? &quot;+R7:%ld:%d:%.2f\n&quot; :
-                        &quot;%ld %d-bit ECDH ops in %.2fs\n&quot;, count,
-                        test_curves_bits[testnum], d);
-                ecdh_results[testnum][0] = d / (double)count;
-                rsa_count = count;
+            if (!kctx ||        /* keygen ctx is not null */
+                !EVP_PKEY_keygen_init(kctx) /* init keygen ctx */ ) {
+                ecdh_checks = 0;
+                BIO_printf(bio_err, &quot;ECDH keygen failure.\n&quot;);
+                ERR_print_errors(bio_err);
+                rsa_count = 1;
+                break;
+            }
+
+            if (!EVP_PKEY_keygen(kctx, &amp;key_A) || /* generate secret key A */
+                !EVP_PKEY_keygen(kctx, &amp;key_B) || /* generate secret key B */
+                !(ctx = EVP_PKEY_CTX_new(key_A, NULL)) || /* derivation ctx from skeyA */
+                !EVP_PKEY_derive_init(ctx) || /* init derivation ctx */
+                !EVP_PKEY_derive_set_peer(ctx, key_B) || /* set peer pubkey in ctx */
+                !EVP_PKEY_derive(ctx, NULL, &amp;outlen) || /* determine max length */
+                outlen == 0 ||  /* ensure outlen is a valid size */
+                outlen &gt; MAX_ECDH_SIZE /* avoid buffer overflow */ ) {
+                ecdh_checks = 0;
+                BIO_printf(bio_err, &quot;ECDH key generation failure.\n&quot;);
+                ERR_print_errors(bio_err);
+                rsa_count = 1;
+                break;
+            }
+
+            /* Here we perform a test run, comparing the output of a*B and b*A;
+             * we try this here and assume that further EVP_PKEY_derive calls
+             * never fail, so we can skip checks in the actually benchmarked
+             * code, for maximum performance. */
+            if (!(test_ctx = EVP_PKEY_CTX_new(key_B, NULL)) || /* test ctx from skeyB */
+                !EVP_PKEY_derive_init(test_ctx) || /* init derivation test_ctx */
+                !EVP_PKEY_derive_set_peer(test_ctx, key_A) || /* set peer pubkey in test_ctx */
+                !EVP_PKEY_derive(test_ctx, NULL, &amp;test_outlen) || /* determine max length */
+                !EVP_PKEY_derive(ctx, loopargs[i].secret_a, &amp;outlen) || /* compute a*B */
+                !EVP_PKEY_derive(test_ctx, loopargs[i].secret_b, &amp;test_outlen) || /* compute b*A */
+                test_outlen != outlen /* compare output length */ ) {
+                ecdh_checks = 0;
+                BIO_printf(bio_err, &quot;ECDH computation failure.\n&quot;);
+                ERR_print_errors(bio_err);
+                rsa_count = 1;
+                break;
             }
+
+            /* Compare the computation results: CRYPTO_memcmp() returns 0 if equal */
+            if (CRYPTO_memcmp(loopargs[i].secret_a,
+                              loopargs[i].secret_b, outlen)) {
+                ecdh_checks = 0;
+                BIO_printf(bio_err, &quot;ECDH computations don't match.\n&quot;);
+                ERR_print_errors(bio_err);
+                rsa_count = 1;
+                break;
+            }
+
+            loopargs[i].ecdh_ctx[testnum] = ctx;
+            loopargs[i].outlen[testnum] = outlen;
+
+            EVP_PKEY_CTX_free(kctx);
+            kctx = NULL;
+            EVP_PKEY_CTX_free(test_ctx);
+            test_ctx = NULL;
+        }
+        if (ecdh_checks != 0) {
+            pkey_print_message(&quot;&quot;, &quot;ecdh&quot;,
+                               ecdh_c[testnum][0],
+                               test_curves_bits[testnum], ECDH_SECONDS);
+            Time_F(START);
+            count =
+                run_benchmark(async_jobs, ECDH_EVP_derive_key_loop, loopargs);
+            d = Time_F(STOP);
+            BIO_printf(bio_err,
+                       mr ? &quot;+R7:%ld:%d:%.2f\n&quot; :
+                       &quot;%ld %d-bit ECDH ops in %.2fs\n&quot;, count,
+                       test_curves_bits[testnum], d);
+            ecdh_results[testnum][0] = d / (double)count;
+            rsa_count = count;
         }
 
         if (rsa_count &lt;= 1) {
@@ -2799,8 +2875,7 @@ int speed_main(int argc, char **argv)
 #ifndef OPENSSL_NO_EC
         for (k = 0; k &lt; EC_NUM; k++) {
             EC_KEY_free(loopargs[i].ecdsa[k]);
-            EC_KEY_free(loopargs[i].ecdh_a[k]);
-            EC_KEY_free(loopargs[i].ecdh_b[k]);
+            EVP_PKEY_CTX_free(loopargs[i].ecdh_ctx[k]);
         }
         OPENSSL_free(loopargs[i].secret_a);
         OPENSSL_free(loopargs[i].secret_b);
@@ -2940,8 +3015,9 @@ static int do_multi(int multi)
             if (p)
                 *p = '\0';
             if (buf[0] != '+') {
-                BIO_printf(bio_err, &quot;Don't understand line '%s' from child %d\n&quot;,
-                        buf, n);
+                BIO_printf(bio_err,
+                           &quot;Don't understand line '%s' from child %d\n&quot;, buf,
+                           n);
                 continue;
             }
             printf(&quot;Got: %s from %d\n&quot;, buf, n);
@@ -3007,15 +3083,13 @@ static int do_multi(int multi)
 
                 d = atof(sstrsep(&amp;p, sep));
                 if (n)
-                    ecdsa_results[k][0] =
-                        1 / (1 / ecdsa_results[k][0] + 1 / d);
+                    ecdsa_results[k][0] = 1 / (1 / ecdsa_results[k][0] + 1 / d);
                 else
                     ecdsa_results[k][0] = d;
 
                 d = atof(sstrsep(&amp;p, sep));
                 if (n)
-                    ecdsa_results[k][1] =
-                        1 / (1 / ecdsa_results[k][1] + 1 / d);
+                    ecdsa_results[k][1] = 1 / (1 / ecdsa_results[k][1] + 1 / d);
                 else
                     ecdsa_results[k][1] = d;
             } else if (strncmp(buf, &quot;+F5:&quot;, 4) == 0) {
@@ -3038,7 +3112,8 @@ static int do_multi(int multi)
             else if (strncmp(buf, &quot;+H:&quot;, 3) == 0) {
                 ;
             } else
-                BIO_printf(bio_err, &quot;Unknown type '%s' from child %d\n&quot;, buf, n);
+                BIO_printf(bio_err, &quot;Unknown type '%s' from child %d\n&quot;, buf,
+                           n);
         }
 
         fclose(f);
@@ -3062,8 +3137,7 @@ static void multiblock_speed(const EVP_CIPHER *evp_cipher)
     out = app_malloc(mblengths[num - 1] + 1024, &quot;multiblock output buffer&quot;);
     ctx = EVP_CIPHER_CTX_new();
     EVP_EncryptInit_ex(ctx, evp_cipher, NULL, no_key, no_iv);
-    EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_MAC_KEY, sizeof(no_key),
-                        no_key);
+    EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_MAC_KEY, sizeof(no_key), no_key);
     alg_name = OBJ_nid2ln(EVP_CIPHER_nid(evp_cipher));
 
     for (j = 0; j &lt; num; j++) {
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011568.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="011576.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11571">[ date ]</a>
              <a href="thread.html#11571">[ thread ]</a>
              <a href="subject.html#11571">[ subject ]</a>
              <a href="author.html#11571">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
