<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2018-October/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1538650173.163536.5038.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020352.html">
   <LINK REL="Next"  HREF="020361.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1538650173.163536.5038.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Thu Oct  4 10:49:33 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="020352.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="020361.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20360">[ date ]</a>
              <a href="thread.html#20360">[ thread ]</a>
              <a href="subject.html#20360">[ subject ]</a>
              <a href="author.html#20360">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  30699aa1943b10b265c52334d9f582c04c4eccba (commit)
       via  15ba109631254b98d3ef2611a1765e75442314a6 (commit)
       via  d73c44404d470424aa58e85fe38b97351f112bc1 (commit)
       via  ab1e5495e45708f43f71e1f9e8872066dc8177c0 (commit)
       via  8effd8fa67689e1d4318cfda21604eef428a37cf (commit)
       via  91a99748d328164ab043cf7bc3da8e45ec0de497 (commit)
      from  18958cefd82449daf3c589b74a074f0c88159d47 (commit)


- Log -----------------------------------------------------------------
commit 30699aa1943b10b265c52334d9f582c04c4eccba
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Sep 14 15:28:39 2018 +0200

    Refactor util/mknum.pl for clearer separation of functionality
    
    Rewrite util/mknum.pl to become cleaner, and to use the separate
    generic C header parsing module, as well as the separate ordinals
    manipulation module.
    Adapt the build files.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7191">https://github.com/openssl/openssl/pull/7191</A>)

commit 15ba109631254b98d3ef2611a1765e75442314a6
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Oct 3 17:44:59 2018 +0200

    Add code to manipulate the items in OpenSSL::Ordinals
    
    This means adding the capability to add new items, to invalidate and
    revalidate all the items, and to update the file it came from, as well
    as the possibility to create new items from other data than a line
    from said file.
    
    While we're at it, we throw in a couple of useful filters.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7191">https://github.com/openssl/openssl/pull/7191</A>)

commit d73c44404d470424aa58e85fe38b97351f112bc1
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Oct 3 17:43:48 2018 +0200

    A perl module to parse through C headers
    
    OpenSSL::ParseC is a module that parses through a C header file and
    returns a list with information on what it found.  Currently, the
    information it returns covers function and variable declarations,
    macro definitions, struct declarations/definitions and typedef
    definitions.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7191">https://github.com/openssl/openssl/pull/7191</A>)

commit ab1e5495e45708f43f71e1f9e8872066dc8177c0
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Sep 14 15:19:37 2018 +0200

    Move ZLIB from 'platforms' to 'features'
    
    Having it as a 'platform' was conceptually wrong from from the
    beginning, and makes decoding more complicated than necessary.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7191">https://github.com/openssl/openssl/pull/7191</A>)

commit 8effd8fa67689e1d4318cfda21604eef428a37cf
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Sep 14 14:59:40 2018 +0200

    Refactor util/mkdef.pl for clearer separation of functionality
    
    Move the .num updating functionality to util/mknum.pl.
    Rewrite util/mkdef.pl to create .def / .map / .opt files exclusively,
    using the separate ordinals reading module.
    Adapt the build files.
    Adapt the symbol presence test.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7191">https://github.com/openssl/openssl/pull/7191</A>)

commit 91a99748d328164ab043cf7bc3da8e45ec0de497
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Sep 14 14:58:11 2018 +0200

    Add a perl module that deals with ordinals files
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7191">https://github.com/openssl/openssl/pull/7191</A>)

-----------------------------------------------------------------------

Summary of changes:
 Configurations/descrip.mms.tmpl        |    2 +-
 Configurations/unix-Makefile.tmpl      |   44 +-
 Configurations/windows-makefile.tmpl   |    2 +-
 build.info                             |    6 +-
 test/recipes/01-test_symbol_presence.t |    5 +-
 util/libcrypto.num                     |    2 +-
 util/mkdef.pl                          | 1824 +++++---------------------------
 util/mknum.pl                          |  125 +++
 util/perl/OpenSSL/Ordinals.pm          |  946 +++++++++++++++++
 util/perl/OpenSSL/ParseC.pm            | 1129 ++++++++++++++++++++
 10 files changed, 2540 insertions(+), 1545 deletions(-)
 create mode 100644 util/mknum.pl
 create mode 100644 util/perl/OpenSSL/Ordinals.pm
 create mode 100644 util/perl/OpenSSL/ParseC.pm

diff --git a/Configurations/descrip.mms.tmpl b/Configurations/descrip.mms.tmpl
index 7393e22..c5dee22 100644
--- a/Configurations/descrip.mms.tmpl
+++ b/Configurations/descrip.mms.tmpl
@@ -760,7 +760,7 @@ reconfigure reconf :
           my $mkdef = sourcefile('util', 'mkdef.pl');
           return &lt;&lt;&quot;EOF&quot;;
 $target : $args{generator}-&gt;[0] $deps
-	\$(PERL) $mkdef $args{generator}-&gt;[1] &quot;VMS&quot; &gt; $target
+	\$(PERL) $mkdef --ordinals $args{generator}-&gt;[0] --name $args{generator}-&gt;[1] &quot;--OS&quot; &quot;VMS&quot; &gt; $target
 EOF
       } elsif ($target !~ /\.[sS]$/) {
           my $target = $args{src};
diff --git a/Configurations/unix-Makefile.tmpl b/Configurations/unix-Makefile.tmpl
index f67eae5..662fb05 100644
--- a/Configurations/unix-Makefile.tmpl
+++ b/Configurations/unix-Makefile.tmpl
@@ -809,9 +809,47 @@ errors:
                 -conf $$E `basename $$E .ec`.c ; \
           done )
 
+{- use File::Basename;
+
+   our @sslheaders =
+       qw( include/openssl/ssl.h
+           include/openssl/ssl2.h
+           include/openssl/ssl3.h
+           include/openssl/sslerr.h
+           include/openssl/tls1.h
+           include/openssl/dtls1.h
+           include/openssl/srtp.h );
+   our @cryptoheaders =
+       qw( include/internal/dso.h
+           include/internal/o_dir.h
+           include/internal/o_str.h
+           include/internal/err.h
+           include/internal/sslconf.h );
+   our @cryptoskipheaders = ( @sslheaders, 
+       qw( include/openssl/conf_api.h
+           include/openssl/ebcdic.h
+           include/openssl/opensslconf.h
+           include/openssl/symhacks.h ) );
+   foreach my $f ( glob(catfile($config{sourcedir},
+                                'include','openssl','*.h')) ) {
+       my $fn = &quot;include/openssl/&quot; . basename($f);
+       push @cryptoheaders, $fn unless grep { $_ eq $fn } @cryptoskipheaders;
+   }
+   &quot;&quot;;
+-}
+CRYPTOHEADERS={- join(&quot; \\\n\t&quot;, sort @cryptoheaders) -}
+SSLHEADERS={- join(&quot; \\\n\t&quot;, sort @sslheaders) -}
 ordinals:
-	( b=`pwd`; cd $(SRCDIR); $(PERL) -I$$b util/mkdef.pl crypto update )
-	( b=`pwd`; cd $(SRCDIR); $(PERL) -I$$b util/mkdef.pl ssl update )
+	( cd $(SRCDIR); \
+          $(PERL) util/mknum.pl --version $(VERSION) --no-warnings \
+                  --ordinals util/libcrypto.num \
+                  --symhacks include/openssl/symhacks.h \
+                  $(CRYPTOHEADERS) )
+	( cd $(SRCDIR); \
+          $(PERL) util/mknum.pl --version $(VERSION) --no-warnings \
+                  --ordinals util/libssl.num \
+                  --symhacks include/openssl/symhacks.h \
+                  $(SSLHEADERS))
 
 test_ordinals:
 	( cd test; \
@@ -965,7 +1003,7 @@ reconfigure reconf:
           (my $mkdef_os = $target{shared_target}) =~ s|-shared$||;
           return &lt;&lt;&quot;EOF&quot;;
 $target: $args{generator}-&gt;[0] $deps
-	\$(PERL) \$(SRCDIR)/util/mkdef.pl $args{generator}-&gt;[1] $mkdef_os &gt; $target
+	\$(PERL) \$(SRCDIR)/util/mkdef.pl --ordinals $args{generator}-&gt;[0] --name $args{generator}-&gt;[1] --OS $mkdef_os &gt; $target
 EOF
       } elsif ($args{src} !~ /\.[sS]$/) {
           if ($args{generator}-&gt;[0] =~ m|^.*\.in$|) {
diff --git a/Configurations/windows-makefile.tmpl b/Configurations/windows-makefile.tmpl
index fb7ddca..46f564d 100644
--- a/Configurations/windows-makefile.tmpl
+++ b/Configurations/windows-makefile.tmpl
@@ -514,7 +514,7 @@ reconfigure reconf:
                               rel2abs($config{builddir}));
           return &lt;&lt;&quot;EOF&quot;;
 $target: $args{generator}-&gt;[0] $deps
-	\$(PERL) $mkdef $args{generator}-&gt;[1] 32 &gt; $target
+	\$(PERL) $mkdef --ordinals $args{generator}-&gt;[0] --name $args{generator}-&gt;[1] --OS windows &gt; $target
 EOF
       } elsif ($args{src} !~ /\.[sS]$/) {
           my $target = $args{src};
diff --git a/build.info b/build.info
index 16e587e..ceb250f 100644
--- a/build.info
+++ b/build.info
@@ -1,4 +1,6 @@
 {-
+     use File::Spec::Functions;
+
      our $sover = $config{shlib_version_number};
      our $sover_filename = $sover;
      $sover_filename =~ s|\.|_|g
@@ -28,8 +30,8 @@ IF[{- defined $target{shared_defflag} -}]
   SHARED_SOURCE[libcrypto]=libcrypto.ld
   SHARED_SOURCE[libssl]=libssl.ld
 
-  GENERATE[libcrypto.ld]=util/libcrypto.num crypto
-  GENERATE[libssl.ld]=util/libssl.num ssl
+  GENERATE[libcrypto.ld]=util/libcrypto.num libcrypto
+  GENERATE[libssl.ld]=util/libssl.num libssl
 ENDIF
 
 IF[{- $config{target} =~ /^(?:Cygwin|mingw|VC-)/ -}]
diff --git a/test/recipes/01-test_symbol_presence.t b/test/recipes/01-test_symbol_presence.t
index 7f2a2d7..015dee9 100644
--- a/test/recipes/01-test_symbol_presence.t
+++ b/test/recipes/01-test_symbol_presence.t
@@ -49,8 +49,9 @@ foreach my $libname (@libnames) {
         my @def_lines;
         indir $bldtop =&gt; sub {
             my $mkdefpath = srctop_file(&quot;util&quot;, &quot;mkdef.pl&quot;);
-            @def_lines = map { s|\R$||; $_ } `$^X $mkdefpath $libname linux 2&gt; /dev/null`;
-            ok($? == 0, &quot;running 'cd $bldtop; $^X $mkdefpath $libname linux' =&gt; $?&quot;);
+            my $libnumpath = srctop_file(&quot;util&quot;, &quot;lib$libname.num&quot;);
+            @def_lines = map { s|\R$||; $_ } `$^X $mkdefpath --ordinals $libnumpath --name $libname --OS linux 2&gt; /dev/null`;
+            ok($? == 0, &quot;running 'cd $bldtop; $^X $mkdefpath --ordinals $libnumpath --name $libname --OS linux' =&gt; $?&quot;);
         }, create =&gt; 0, cleanup =&gt; 0;
 
         note &quot;Number of lines in \@nm_lines before massaging: &quot;, scalar @nm_lines;
diff --git a/util/libcrypto.num b/util/libcrypto.num
index bad3a38..ecece38 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -2529,7 +2529,7 @@ ASN1_STRING_type_new                    2494	1_1_0	EXIST::FUNCTION:
 TS_STATUS_INFO_free                     2495	1_1_0	EXIST::FUNCTION:TS
 BN_mod_mul                              2496	1_1_0	EXIST::FUNCTION:
 CMS_add0_recipient_key                  2497	1_1_0	EXIST::FUNCTION:CMS
-BIO_f_zlib                              2498	1_1_0	EXIST:ZLIB:FUNCTION:COMP
+BIO_f_zlib                              2498	1_1_0	EXIST::FUNCTION:COMP,ZLIB
 AES_cfb128_encrypt                      2499	1_1_0	EXIST::FUNCTION:
 ENGINE_set_EC                           2500	1_1_0	EXIST::FUNCTION:ENGINE
 d2i_ECPKParameters                      2501	1_1_0	EXIST::FUNCTION:EC
diff --git a/util/mkdef.pl b/util/mkdef.pl
index 6523a05..959a13d 100755
--- a/util/mkdef.pl
+++ b/util/mkdef.pl
@@ -1,57 +1,41 @@
 #! /usr/bin/env perl
-# Copyright 1995-2018 The OpenSSL Project Authors. All Rights Reserved.
+# Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
 #
 # Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
 # this file except in compliance with the License.  You can obtain a copy
 # in the file LICENSE in the source distribution or at
 # <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
 
-#
-# generate a .def file
-#
-# It does this by parsing the header files and looking for the
-# prototyped functions: it then prunes the output.
-#
-# Intermediary files are created, call libcrypto.num and libssl.num,
-# The format of these files is:
-#
-#	routine-name	nnnn	vers	info
-#
-# The &quot;nnnn&quot; and &quot;vers&quot; fields are the numeric id and version for the symbol
-# respectively. The &quot;info&quot; part is actually a colon-separated string of fields
-# with the following meaning:
-#
-#	existence:platform:kind:algorithms
-#
-# - &quot;existence&quot; can be &quot;EXIST&quot; or &quot;NOEXIST&quot; depending on if the symbol is
-#   found somewhere in the source,
-# - &quot;platforms&quot; is empty if it exists on all platforms, otherwise it contains
-#   comma-separated list of the platform, just as they are if the symbol exists
-#   for those platforms, or prepended with a &quot;!&quot; if not.  This helps resolve
-#   symbol name variants for platforms where the names are too long for the
-#   compiler or linker, or if the systems is case insensitive and there is a
-#   clash, or the symbol is implemented differently (see
-#   EXPORT_VAR_AS_FUNCTION).  This script assumes renaming of symbols is found
-#   in the file crypto/symhacks.h.
-#   The semantics for the platforms is that every item is checked against the
-#   environment.  For the negative items (&quot;!FOO&quot;), if any of them is false
-#   (i.e. &quot;FOO&quot; is true) in the environment, the corresponding symbol can't be
-#   used.  For the positive items, if all of them are false in the environment,
-#   the corresponding symbol can't be used.  Any combination of positive and
-#   negative items are possible, and of course leave room for some redundancy.
-# - &quot;kind&quot; is &quot;FUNCTION&quot; or &quot;VARIABLE&quot;.  The meaning of that is obvious.
-# - &quot;algorithms&quot; is a comma-separated list of algorithm names.  This helps
-#   exclude symbols that are part of an algorithm that some user wants to
-#   exclude.
-#
+# Generate a linker version script suitable for the given platform
+# from a given ordinals file.
 
-use lib &quot;.&quot;;
-use configdata;
-use File::Spec::Functions;
-use File::Basename;
+use strict;
+use warnings;
+
+use Getopt::Long;
 use FindBin;
 use lib &quot;$FindBin::Bin/perl&quot;;
-use OpenSSL::Glob;
+
+use OpenSSL::Ordinals;
+
+use lib '.';
+use configdata;
+
+my $name = undef;               # internal library/module name
+my $ordinals_file = undef;      # the ordinals file to use
+my $OS = undef;                 # the operating system family
+my $verbose = 0;
+my $ctest = 0;
+
+GetOptions('name=s'     =&gt; \$name,
+           'ordinals=s' =&gt; \$ordinals_file,
+           'OS=s'       =&gt; \$OS,
+           'ctest'      =&gt; \$ctest,
+           'verbose'    =&gt; \$verbose)
+    or die &quot;Error in command line arguments\n&quot;;
+
+die &quot;Please supply arguments\n&quot;
+    unless $name &amp;&amp; $ordinals_file &amp;&amp; $OS;
 
 # When building a &quot;variant&quot; shared library, with a custom SONAME, also customize
 # all the symbol versions.  This produces a shared object that can coexist
@@ -103,1532 +87,302 @@ use OpenSSL::Glob;
 # 0000000000000000 A OPENSSL_OPT_1_1_0
 # 0000000000000000 A OPENSSL_OPT_1_1_0d
 #
-(my $SO_VARIANT = qq{\U$target{&quot;shlib_variant&quot;}}) =~ s/\W/_/g;
-
-my $debug=0;
-my $trace=0;
-my $verbose=0;
-
-my $crypto_num= catfile($config{sourcedir},&quot;util&quot;,&quot;libcrypto.num&quot;);
-my $ssl_num=    catfile($config{sourcedir},&quot;util&quot;,&quot;libssl.num&quot;);
-my $libname;
-
-my $do_update = 0;
-my $do_rewrite = 1;
-my $do_crypto = 0;
-my $do_ssl = 0;
-my $do_ctest = 0;
-my $do_ctestall = 0;
-my $do_checkexist = 0;
-
-my $VMS=0;
-my $W32=0;
-my $NT=0;
-my $UNIX=0;
-my $linux=0;
-my $aix=0;
-# Set this to make typesafe STACK definitions appear in DEF
-my $safe_stack_def = 0;
-
-my @known_platforms = ( &quot;__FreeBSD__&quot;, &quot;PERL5&quot;,
-			&quot;EXPORT_VAR_AS_FUNCTION&quot;, &quot;ZLIB&quot;, &quot;_WIN32&quot;
-			);
-my @known_ossl_platforms = ( &quot;UNIX&quot;, &quot;VMS&quot;, &quot;WIN32&quot;, &quot;WINNT&quot;, &quot;OS2&quot; );
-my @known_algorithms = ( # These are algorithms we know are guarded in relevant
-			 # header files, but aren't actually disablable.
-			 # Without these, this script will warn a lot.
-			 &quot;RSA&quot;, &quot;MD5&quot;,
-			 # @disablables comes from configdata.pm
-			 map { (my $x = uc $_) =~ s|-|_|g; $x; } @disablables,
-			 # Deprecated functions.  Not really algorithmss, but
-			 # treated as such here for the sake of simplicity
-			 &quot;DEPRECATEDIN_0_9_8&quot;,
-			 &quot;DEPRECATEDIN_1_0_0&quot;,
-			 &quot;DEPRECATEDIN_1_1_0&quot;,
-			 &quot;DEPRECATEDIN_1_2_0&quot;,
-                     );
-
-# %disabled comes from configdata.pm
-my %disabled_algorithms =
-    map { (my $x = uc $_) =~ s|-|_|g; $x =&gt; 1; } keys %disabled;
-
-my $apiv = sprintf &quot;%x%02x%02x&quot;, split(/\./, $config{api});
-foreach (@known_algorithms) {
-	if (/^DEPRECATEDIN_(\d+)_(\d+)_(\d+)$/) {
-		my $depv = sprintf &quot;%x%02x%02x&quot;, $1, $2, $3;
-		$disabled_algorithms{$_} = 1 if $apiv ge $depv;
-	}
-}
-
-my $zlib;
-
-foreach (@ARGV, split(/ /, $config{options}))
-	{
-	$debug=1 if $_ eq &quot;debug&quot;;
-	$trace=1 if $_ eq &quot;trace&quot;;
-	$verbose=1 if $_ eq &quot;verbose&quot;;
-	die &quot;win16 not supported&quot; if $_ eq &quot;16&quot;;
-	if ($_ eq &quot;32&quot; || $_ eq &quot;mingw&quot;) {
-		$W32=1;
-	} elsif ($_ eq &quot;NT&quot;) {
-		$W32 = 1;
-		$NT = 1;
-	} elsif ($_ eq &quot;linux&quot; || $_ eq &quot;solaris&quot;) {
-		$linux=1;
-		$UNIX=1;
-	} elsif ($_ eq &quot;aix&quot;) {
-		$aix=1;
-		$UNIX=1;
-	} elsif ($_ eq &quot;VMS&quot;) {
-		$VMS=1;
-	}
-	if ($_ eq &quot;zlib&quot; || $_ eq &quot;enable-zlib&quot; || $_ eq &quot;zlib-dynamic&quot;
-			 || $_ eq &quot;enable-zlib-dynamic&quot;) {
-		$zlib = 1;
-	}
-
-	$do_crypto=1 if $_ eq &quot;libcrypto&quot; || $_ eq &quot;crypto&quot;;
-	$do_ssl=1 if $_ eq &quot;libssl&quot; || $_ eq &quot;ssl&quot;;
-
-	$do_update=1 if $_ eq &quot;update&quot;;
-	$do_rewrite=1 if $_ eq &quot;rewrite&quot;;
-	$do_ctest=1 if $_ eq &quot;ctest&quot;;
-	$do_ctestall=1 if $_ eq &quot;ctestall&quot;;
-	$do_checkexist=1 if $_ eq &quot;exist&quot;;
-	}
-$libname = $unified_info{sharednames}-&gt;{libcrypto} if $do_crypto;
-$libname = $unified_info{sharednames}-&gt;{libssl} if $do_ssl;
-
-if (!$libname) {
-	if ($do_ssl) {
-		$libname=&quot;LIBSSL&quot;;
-	}
-	if ($do_crypto) {
-		$libname=&quot;LIBCRYPTO&quot;;
-	}
-}
-
-# If no platform is given, assume WIN32
-if ($W32 + $VMS + $linux + $aix == 0) {
-	$W32 = 1;
-}
-die &quot;Please, only one platform at a time&quot;
-    if ($W32 + $VMS + $linux + $aix &gt; 1);
-
-if (!$do_ssl &amp;&amp; !$do_crypto)
-	{
-	print STDERR &quot;usage: $0 ( ssl | crypto ) [ 16 | 32 | NT | OS2 | linux | VMS ]\n&quot;;
-	exit(1);
-	}
-
-%ssl_list=&amp;load_numbers($ssl_num);
-$max_ssl = $max_num;
-%crypto_list=&amp;load_numbers($crypto_num);
-$max_crypto = $max_num;
-
-my $ssl=&quot;include/openssl/ssl.h&quot;;
-$ssl.=&quot; include/openssl/sslerr.h&quot;;
-$ssl.=&quot; include/openssl/tls1.h&quot;;
-$ssl.=&quot; include/openssl/srtp.h&quot;;
-
-# When scanning include/openssl, skip all SSL files and some internal ones.
-my %skipthese;
-foreach my $f ( split(/\s+/, $ssl) ) {
-    $skipthese{$f} = 1;
-}
-$skipthese{'include/openssl/conf_api.h'} = 1;
-$skipthese{'include/openssl/ebcdic.h'} = 1;
-$skipthese{'include/openssl/opensslconf.h'} = 1;
-
-# We use headers found in include/openssl and include/internal only.
-# The latter is needed so libssl.so/.dll/.exe can link properly.
-my $crypto =&quot;include/internal/dso.h&quot;;
-$crypto.=&quot; include/internal/o_dir.h&quot;;
-$crypto.=&quot; include/internal/o_str.h&quot;;
-$crypto.=&quot; include/internal/err.h&quot;;
-$crypto.=&quot; include/internal/sslconf.h&quot;;
-foreach my $f ( glob(catfile($config{sourcedir},'include/openssl/*.h')) ) {
-    my $fn = &quot;include/openssl/&quot; . basename($f);
-    $crypto .= &quot; $fn&quot; if !defined $skipthese{$fn};
-}
-
-my $symhacks=&quot;include/openssl/symhacks.h&quot;;
-
-my @ssl_symbols = &amp;do_defs(&quot;LIBSSL&quot;, $ssl, $symhacks);
-my @crypto_symbols = &amp;do_defs(&quot;LIBCRYPTO&quot;, $crypto, $symhacks);
-
-if ($do_update) {
-
-if ($do_ssl == 1) {
-
-	&amp;maybe_add_info(&quot;LIBSSL&quot;,*<A HREF="../../../mailman/listinfo/openssl-commits.html">ssl_list, at ssl_symbols</A>);
-	if ($do_rewrite == 1) {
-		open(OUT, &quot;&gt;$ssl_num&quot;);
-		&amp;rewrite_numbers(*OUT,&quot;LIBSSL&quot;,*<A HREF="../../../mailman/listinfo/openssl-commits.html">ssl_list, at ssl_symbols</A>);
-	} else {
-		open(OUT, &quot;&gt;&gt;$ssl_num&quot;);
-	}
-	&amp;update_numbers(*OUT,&quot;LIBSSL&quot;,*ssl_list,$<A HREF="../../../mailman/listinfo/openssl-commits.html">max_ssl, at ssl_symbols</A>);
-	close OUT;
-}
-
-if($do_crypto == 1) {
-
-	&amp;maybe_add_info(&quot;LIBCRYPTO&quot;,*<A HREF="../../../mailman/listinfo/openssl-commits.html">crypto_list, at crypto_symbols</A>);
-	if ($do_rewrite == 1) {
-		open(OUT, &quot;&gt;$crypto_num&quot;);
-		&amp;rewrite_numbers(*OUT,&quot;LIBCRYPTO&quot;,*<A HREF="../../../mailman/listinfo/openssl-commits.html">crypto_list, at crypto_symbols</A>);
-	} else {
-		open(OUT, &quot;&gt;&gt;$crypto_num&quot;);
-	}
-	&amp;update_numbers(*OUT,&quot;LIBCRYPTO&quot;,*crypto_list,$<A HREF="../../../mailman/listinfo/openssl-commits.html">max_crypto, at crypto_symbols</A>);
-	close OUT;
-}
-
-} elsif ($do_checkexist) {
-	&amp;check_existing(*ssl_list, @ssl_symbols)
-		if $do_ssl == 1;
-	&amp;check_existing(*crypto_list, @crypto_symbols)
-		if $do_crypto == 1;
-} elsif ($do_ctest || $do_ctestall) {
-
-	print &lt;&lt;&quot;EOF&quot;;
-
-/* Test file to check all DEF file symbols are present by trying
- * to link to all of them. This is *not* intended to be run!
- */
-
-int main()
-{
-EOF
-	&amp;print_test_file(*STDOUT,&quot;LIBSSL&quot;,*ssl_list,$<A HREF="../../../mailman/listinfo/openssl-commits.html">do_ctestall, at ssl_symbols</A>)
-		if $do_ssl == 1;
-
-	&amp;print_test_file(*STDOUT,&quot;LIBCRYPTO&quot;,*crypto_list,$<A HREF="../../../mailman/listinfo/openssl-commits.html">do_ctestall, at crypto_symbols</A>)
-		if $do_crypto == 1;
-
-	print &quot;}\n&quot;;
-
-} else {
-
-	&amp;print_def_file(*STDOUT,$libname,*<A HREF="../../../mailman/listinfo/openssl-commits.html">ssl_list, at ssl_symbols</A>)
-		if $do_ssl == 1;
-
-	&amp;print_def_file(*STDOUT,$libname,*<A HREF="../../../mailman/listinfo/openssl-commits.html">crypto_list, at crypto_symbols</A>)
-		if $do_crypto == 1;
-
-}
-
-
-sub do_defs
-{
-	my($name,$files,$symhacksfile)=@_;
-	my $file;
-	my @ret;
-	my %syms;
-	my %platform;		# For anything undefined, we assume &quot;&quot;
-	my %kind;		# For anything undefined, we assume &quot;FUNCTION&quot;
-	my %algorithm;		# For anything undefined, we assume &quot;&quot;
-	my %variant;
-	my %variant_cnt;	# To be able to allocate &quot;name{n}&quot; if &quot;name&quot;
-				# is the same name as the original.
-	my $cpp;
-	my %unknown_algorithms = ();
-	my $parens = 0;
-
-	foreach $file (split(/\s+/,$symhacksfile.&quot; &quot;.$files))
-		{
-		my $fn = catfile($config{sourcedir},$file);
-		print STDERR &quot;DEBUG: starting on $fn:\n&quot; if $debug;
-		print STDERR &quot;TRACE: start reading $fn\n&quot; if $trace;
-		open(IN,&quot;&lt;$fn&quot;) || die &quot;Can't open $fn, $!,&quot;;
-		my $line = &quot;&quot;, my $def= &quot;&quot;;
-		my %tag = (
-			(map { $_ =&gt; 0 } @known_platforms),
-			(map { &quot;OPENSSL_SYS_&quot;.$_ =&gt; 0 } @known_ossl_platforms),
-			(map { &quot;OPENSSL_NO_&quot;.$_ =&gt; 0 } @known_algorithms),
-			(map { &quot;OPENSSL_USE_&quot;.$_ =&gt; 0 } @known_algorithms),
-			(grep /^DEPRECATED_/, @known_algorithms),
-			NOPROTO		=&gt; 0,
-			PERL5		=&gt; 0,
-			_WINDLL		=&gt; 0,
-			CONST_STRICT	=&gt; 0,
-			TRUE		=&gt; 1,
-		);
-		my $symhacking = $file eq $symhacksfile;
-		my @current_platforms = ();
-		my @current_algorithms = ();
-
-		# params: symbol, alias, platforms, kind
-		# The reason to put this subroutine in a variable is that
-		# it will otherwise create it's own, unshared, version of
-		# %tag and %variant...
-		my $make_variant = sub
-		{
-			my ($s, $a, $p, $k) = @_;
-			my ($a1, $a2);
-
-			print STDERR &quot;DEBUG: make_variant: Entered with &quot;,$s,&quot;, &quot;,$a,&quot;, &quot;,(defined($p)?$p:&quot;&quot;),&quot;, &quot;,(defined($k)?$k:&quot;&quot;),&quot;\n&quot; if $debug;
-			if (defined($p))
-			{
-				$a1 = join(&quot;,&quot;,$p,
-					   grep(!/^$/,
-						map { $tag{$_} == 1 ? $_ : &quot;&quot; }
-						@known_platforms));
-			}
-			else
-			{
-				$a1 = join(&quot;,&quot;,
-					   grep(!/^$/,
-						map { $tag{$_} == 1 ? $_ : &quot;&quot; }
-						@known_platforms));
-			}
-			$a2 = join(&quot;,&quot;,
-				   grep(!/^$/,
-					map { $tag{&quot;OPENSSL_SYS_&quot;.$_} == 1 ? $_ : &quot;&quot; }
-					@known_ossl_platforms));
-			print STDERR &quot;DEBUG: make_variant: a1 = $a1; a2 = $a2\n&quot; if $debug;
-			if ($a1 eq &quot;&quot;) { $a1 = $a2; }
-			elsif ($a1 ne &quot;&quot; &amp;&amp; $a2 ne &quot;&quot;) { $a1 .= &quot;,&quot;.$a2; }
-			if ($a eq $s)
-			{
-				if (!defined($variant_cnt{$s}))
-				{
-					$variant_cnt{$s} = 0;
-				}
-				$variant_cnt{$s}++;
-				$a .= &quot;{$variant_cnt{$s}}&quot;;
-			}
-			my $toadd = $a.&quot;:&quot;.$a1.(defined($k)?&quot;:&quot;.$k:&quot;&quot;);
-			my $togrep = $s.'(\{[0-9]+\})?:'.$a1.(defined($k)?&quot;:&quot;.$k:&quot;&quot;);
-			if (!grep(/^$togrep$/,
-				  split(/;/, defined($variant{$s})?$variant{$s}:&quot;&quot;))) {
-				if (defined($variant{$s})) { $variant{$s} .= &quot;;&quot;; }
-				$variant{$s} .= $toadd;
-			}
-			print STDERR &quot;DEBUG: make_variant: Exit with variant of &quot;,$s,&quot; = &quot;,$variant{$s},&quot;\n&quot; if $debug;
-		};
-
-		print STDERR &quot;DEBUG: parsing ----------\n&quot; if $debug;
-		while(&lt;IN&gt;) {
-			s|\R$||; # Better chomp
-			if($parens &gt; 0) {
-				#Inside a DEPRECATEDIN
-				$stored_multiline .= $_;
-				print STDERR &quot;DEBUG: Continuing multiline DEPRECATEDIN: $stored_multiline\n&quot; if $debug;
-				$parens = count_parens($stored_multiline);
-				if ($parens == 0) {
-					$def .= do_deprecated($stored_multiline,
-							\@current_platforms,
-							\@current_algorithms);
-				}
-				next;
-			}
-			if (/\/\* Error codes for the \w+ functions\. \*\//)
-				{
-				undef @tag;
-				last;
-				}
-			if ($line ne '') {
-				$_ = $line . $_;
-				$line = '';
-			}
-
-			if (/\\$/) {
-				$line = $`; # keep what was before the backslash
-				next;
-			}
-
-			if(/\/\*/) {
-				if (not /\*\//) {	# multi-line comment...
-					$line = $_;	# ... just accumulate
-					next;
-				} else {
-					s/\/\*.*?\*\///gs;# wipe it
-				}
-			}
-
-			if ($cpp) {
-				$cpp++ if /^#\s*if/;
-				$cpp-- if /^#\s*endif/;
-				next;
-			}
-			if (/^#.*ifdef.*cplusplus/) {
-				$cpp = 1;
-				next;
-			}
-
-			s/{[^{}]*}//gs;                      # ignore {} blocks
-			print STDERR &quot;DEBUG: \$def=\&quot;$def\&quot;\n&quot; if $debug &amp;&amp; $def ne &quot;&quot;;
-			print STDERR &quot;DEBUG: \$_=\&quot;$_\&quot;\n&quot; if $debug;
-			if (/^\#\s*if\s+OPENSSL_API_COMPAT\s*(\S)\s*(0x[0-9a-fA-F]{8})L\s*$/) {
-				my $op = $1;
-				my $v = hex($2);
-				if ($op ne '&lt;' &amp;&amp; $op ne '&gt;=') {
-				    die &quot;$file unacceptable operator $op: $_\n&quot;;
-				}
-				my ($one, $major, $minor) =
-				    ( ($v &gt;&gt; 28) &amp; 0xf,
-				      ($v &gt;&gt; 20) &amp; 0xff,
-				      ($v &gt;&gt; 12) &amp; 0xff );
-				my $t = &quot;DEPRECATEDIN_${one}_${major}_${minor}&quot;;
-				push(@tag,&quot;-&quot;);
-				push(@tag,$t);
-				$tag{$t}=($op eq '&lt;' ? 1 : -1);
-				print STDERR &quot;DEBUG: $file: found tag $t = $tag{$t}\n&quot; if $debug;
-			} elsif (/^\#\s*ifndef\s+(.*)/) {
-				push(@tag,&quot;-&quot;);
-				push(@tag,$1);
-				$tag{$1}=-1;
-				print STDERR &quot;DEBUG: $file: found tag $1 = -1\n&quot; if $debug;
-			} elsif (/^\#\s*if\s+!defined\s*\(([^\)]+)\)/) {
-				push(@tag,&quot;-&quot;);
-				if (/^\#\s*if\s+(!defined\s*\(([^\)]+)\)(\s+\&amp;\&amp;\s+!defined\s*\(([^\)]+)\))*)$/) {
-					my $tmp_1 = $1;
-					my $tmp_;
-					foreach $tmp_ (split '\&amp;\&amp;',$tmp_1) {
-						$tmp_ =~ /!defined\s*\(([^\)]+)\)/;
-						print STDERR &quot;DEBUG: $file: found tag $1 = -1\n&quot; if $debug;
-						push(@tag,$1);
-						$tag{$1}=-1;
-					}
-				} else {
-					print STDERR &quot;Warning: $file: taking only '!defined($1)' of complicated expression: $_&quot; if $verbose; # because it is O...
-					print STDERR &quot;DEBUG: $file: found tag $1 = -1\n&quot; if $debug;
-					push(@tag,$1);
-					$tag{$1}=-1;
-				}
-			} elsif (/^\#\s*ifdef\s+(\S*)/) {
-				push(@tag,&quot;-&quot;);
-				push(@tag,$1);
-				$tag{$1}=1;
-				print STDERR &quot;DEBUG: $file: found tag $1 = 1\n&quot; if $debug;
-			} elsif (/^\#\s*if\s+defined\s*\(([^\)]+)\)/) {
-				push(@tag,&quot;-&quot;);
-				if (/^\#\s*if\s+(defined\s*\(([^\)]+)\)(\s+\|\|\s+defined\s*\(([^\)]+)\))*)$/) {
-					my $tmp_1 = $1;
-					my $tmp_;
-					foreach $tmp_ (split '\|\|',$tmp_1) {
-						$tmp_ =~ /defined\s*\(([^\)]+)\)/;
-						print STDERR &quot;DEBUG: $file: found tag $1 = 1\n&quot; if $debug;
-						push(@tag,$1);
-						$tag{$1}=1;
-					}
-				} else {
-					print STDERR &quot;Warning: $file: taking only 'defined($1)' of complicated expression: $_\n&quot; if $verbose; # because it is O...
-					print STDERR &quot;DEBUG: $file: found tag $1 = 1\n&quot; if $debug;
-					push(@tag,$1);
-					$tag{$1}=1;
-				}
-			} elsif (/^\#\s*error\s+(\w+) is disabled\./) {
-				my $tag_i = $#tag;
-				while($tag[$tag_i] ne &quot;-&quot;) {
-					if ($tag[$tag_i] eq &quot;OPENSSL_NO_&quot;.$1) {
-						$tag{$tag[$tag_i]}=2;
-						print STDERR &quot;DEBUG: $file: changed tag $1 = 2\n&quot; if $debug;
-					}
-					$tag_i--;
-				}
-			} elsif (/^\#\s*endif/) {
-				my $tag_i = $#tag;
-				while($tag_i &gt; 0 &amp;&amp; $tag[$tag_i] ne &quot;-&quot;) {
-					my $t=$tag[$tag_i];
-					print STDERR &quot;DEBUG: \$t=\&quot;$t\&quot;\n&quot; if $debug;
-					if ($tag{$t}==2) {
-						$tag{$t}=-1;
-					} else {
-						$tag{$t}=0;
-					}
-					print STDERR &quot;DEBUG: $file: changed tag &quot;,$t,&quot; = &quot;,$tag{$t},&quot;\n&quot; if $debug;
-					pop(@tag);
-					if ($t =~ /^OPENSSL_NO_([A-Z0-9_]+)$/) {
-						$t=$1;
-					} elsif($t =~ /^OPENSSL_USE_([A-Z0-9_]+)$/) {
-						$t=$1;
-					} else {
-						$t=&quot;&quot;;
-					}
-					if ($t ne &quot;&quot;
-					    &amp;&amp; !grep(/^$t$/, @known_algorithms)) {
-						$unknown_algorithms{$t} = 1;
-						#print STDERR &quot;DEBUG: Added as unknown algorithm: $t\n&quot; if $debug;
-					}
-					$tag_i--;
-				}
-				pop(@tag);
-			} elsif (/^\#\s*else/) {
-				my $tag_i = $#tag;
-				die &quot;$file unmatched else\n&quot; if $tag_i &lt; 0;
-				while($tag[$tag_i] ne &quot;-&quot;) {
-					my $t=$tag[$tag_i];
-					$tag{$t}= -$tag{$t};
-					print STDERR &quot;DEBUG: $file: changed tag &quot;,$t,&quot; = &quot;,$tag{$t},&quot;\n&quot; if $debug;
-					$tag_i--;
-				}
-			} elsif (/^\#\s*if\s+1/) {
-				push(@tag,&quot;-&quot;);
-				# Dummy tag
-				push(@tag,&quot;TRUE&quot;);
-				$tag{&quot;TRUE&quot;}=1;
-				print STDERR &quot;DEBUG: $file: found 1\n&quot; if $debug;
-			} elsif (/^\#\s*if\s+0/) {
-				push(@tag,&quot;-&quot;);
-				# Dummy tag
-				push(@tag,&quot;TRUE&quot;);
-				$tag{&quot;TRUE&quot;}=-1;
-				print STDERR &quot;DEBUG: $file: found 0\n&quot; if $debug;
-			} elsif (/^\#\s*if\s+/) {
-				#Some other unrecognized &quot;if&quot; style
-				push(@tag,&quot;-&quot;);
-				print STDERR &quot;Warning: $file: ignoring unrecognized expression: $_\n&quot; if $verbose; # because it is O...
-			} elsif (/^\#\s*define\s+(\w+)\s+(\w+)/
-				 &amp;&amp; $symhacking &amp;&amp; $tag{'TRUE'} != -1) {
-				# This is for aliasing.  When we find an alias,
-				# we have to invert
-				&amp;$make_variant($1,$2);
-				print STDERR &quot;DEBUG: $file: defined $1 = $2\n&quot; if $debug;
-			}
-			if (/^\#/) {
-				@current_platforms =
-				    grep(!/^$/,
-					 map { $tag{$_} == 1 ? $_ :
-						   $tag{$_} == -1 ? &quot;!&quot;.$_  : &quot;&quot; }
-					 @known_platforms);
-				push @current_platforms
-				    , grep(!/^$/,
-					   map { $tag{&quot;OPENSSL_SYS_&quot;.$_} == 1 ? $_ :
-						     $tag{&quot;OPENSSL_SYS_&quot;.$_} == -1 ? &quot;!&quot;.$_  : &quot;&quot; }
-					   @known_ossl_platforms);
-				@current_algorithms = ();
-				@current_algorithms =
-				    grep(!/^$/,
-					 map { $tag{&quot;OPENSSL_NO_&quot;.$_} == -1 ? $_ : &quot;&quot; }
-					 @known_algorithms);
-				push @current_algorithms
-				    , grep(!/^$/,
-					 map { $tag{&quot;OPENSSL_USE_&quot;.$_} == 1 ? $_ : &quot;&quot; }
-					 @known_algorithms);
-				push @current_algorithms,
-				    grep { /^DEPRECATEDIN_/ &amp;&amp; $tag{$_} == 1 }
-				    @known_algorithms;
-				$def .=
-				    &quot;#INFO:&quot;
-					.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-					    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-				next;
-			}
-			if ($tag{'TRUE'} != -1) {
-				if (/^\s*DEFINE_STACK_OF\s*\(\s*(\w*)\s*\)/
-						|| /^\s*DEFINE_STACK_OF_CONST\s*\(\s*(\w*)\s*\)/) {
-					next;
-				} elsif (/^\s*DECLARE_ASN1_ENCODE_FUNCTIONS\s*\(\s*(\w*)\s*,\s*(\w*)\s*,\s*(\w*)\s*\)/) {
-					$def .= &quot;int d2i_$3(void);&quot;;
-					$def .= &quot;int i2d_$3(void);&quot;;
-					# Variant for platforms that do not
-					# have to access global variables
-					# in shared libraries through functions
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(',',&quot;!EXPORT_VAR_AS_FUNCTION&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					$def .= &quot;OPENSSL_EXTERN int $2_it;&quot;;
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					# Variant for platforms that have to
-					# access global variables in shared
-					# libraries through functions
-					&amp;$make_variant(&quot;$2_it&quot;,&quot;$2_it&quot;,
-						      &quot;EXPORT_VAR_AS_FUNCTION&quot;,
-						      &quot;FUNCTION&quot;);
-					next;
-				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS_fname\s*\(\s*(\w*)\s*,\s*(\w*)\s*,\s*(\w*)\s*\)/) {
-					$def .= &quot;int d2i_$3(void);&quot;;
-					$def .= &quot;int i2d_$3(void);&quot;;
-					$def .= &quot;int $3_free(void);&quot;;
-					$def .= &quot;int $3_new(void);&quot;;
-					# Variant for platforms that do not
-					# have to access global variables
-					# in shared libraries through functions
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(',',&quot;!EXPORT_VAR_AS_FUNCTION&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					$def .= &quot;OPENSSL_EXTERN int $2_it;&quot;;
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					# Variant for platforms that have to
-					# access global variables in shared
-					# libraries through functions
-					&amp;$make_variant(&quot;$2_it&quot;,&quot;$2_it&quot;,
-						      &quot;EXPORT_VAR_AS_FUNCTION&quot;,
-						      &quot;FUNCTION&quot;);
-					next;
-				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS\s*\(\s*(\w*)\s*\)/ ||
-					 /^\s*DECLARE_ASN1_FUNCTIONS_const\s*\(\s*(\w*)\s*\)/) {
-					$def .= &quot;int d2i_$1(void);&quot;;
-					$def .= &quot;int i2d_$1(void);&quot;;
-					$def .= &quot;int $1_free(void);&quot;;
-					$def .= &quot;int $1_new(void);&quot;;
-					# Variant for platforms that do not
-					# have to access global variables
-					# in shared libraries through functions
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(',',&quot;!EXPORT_VAR_AS_FUNCTION&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					$def .= &quot;OPENSSL_EXTERN int $1_it;&quot;;
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					# Variant for platforms that have to
-					# access global variables in shared
-					# libraries through functions
-					&amp;$make_variant(&quot;$1_it&quot;,&quot;$1_it&quot;,
-						      &quot;EXPORT_VAR_AS_FUNCTION&quot;,
-						      &quot;FUNCTION&quot;);
-					next;
-				} elsif (/^\s*DECLARE_ASN1_ENCODE_FUNCTIONS_const\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
-					$def .= &quot;int d2i_$2(void);&quot;;
-					$def .= &quot;int i2d_$2(void);&quot;;
-					# Variant for platforms that do not
-					# have to access global variables
-					# in shared libraries through functions
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(',',&quot;!EXPORT_VAR_AS_FUNCTION&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					$def .= &quot;OPENSSL_EXTERN int $2_it;&quot;;
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					# Variant for platforms that have to
-					# access global variables in shared
-					# libraries through functions
-					&amp;$make_variant(&quot;$2_it&quot;,&quot;$2_it&quot;,
-						      &quot;EXPORT_VAR_AS_FUNCTION&quot;,
-						      &quot;FUNCTION&quot;);
-					next;
-				} elsif (/^\s*DECLARE_ASN1_ALLOC_FUNCTIONS\s*\(\s*(\w*)\s*\)/) {
-					$def .= &quot;int $1_free(void);&quot;;
-					$def .= &quot;int $1_new(void);&quot;;
-					next;
-				} elsif (/^\s*DECLARE_ASN1_FUNCTIONS_name\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
-					$def .= &quot;int d2i_$2(void);&quot;;
-					$def .= &quot;int i2d_$2(void);&quot;;
-					$def .= &quot;int $2_free(void);&quot;;
-					$def .= &quot;int $2_new(void);&quot;;
-					# Variant for platforms that do not
-					# have to access global variables
-					# in shared libraries through functions
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(',',&quot;!EXPORT_VAR_AS_FUNCTION&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					$def .= &quot;OPENSSL_EXTERN int $2_it;&quot;;
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					# Variant for platforms that have to
-					# access global variables in shared
-					# libraries through functions
-					&amp;$make_variant(&quot;$2_it&quot;,&quot;$2_it&quot;,
-						      &quot;EXPORT_VAR_AS_FUNCTION&quot;,
-						      &quot;FUNCTION&quot;);
-					next;
-				} elsif (/^\s*DECLARE_ASN1_ITEM\s*\(\s*(\w*)\s*\)/) {
-					# Variant for platforms that do not
-					# have to access global variables
-					# in shared libraries through functions
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(',',&quot;!EXPORT_VAR_AS_FUNCTION&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					$def .= &quot;OPENSSL_EXTERN int $1_it;&quot;;
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					# Variant for platforms that have to
-					# access global variables in shared
-					# libraries through functions
-					&amp;$make_variant(&quot;$1_it&quot;,&quot;$1_it&quot;,
-						      &quot;EXPORT_VAR_AS_FUNCTION&quot;,
-						      &quot;FUNCTION&quot;);
-					next;
-				} elsif (/^\s*DECLARE_ASN1_NDEF_FUNCTION\s*\(\s*(\w*)\s*\)/) {
-					$def .= &quot;int i2d_$1_NDEF(void);&quot;;
-				} elsif (/^\s*DECLARE_ASN1_SET_OF\s*\(\s*(\w*)\s*\)/) {
-					next;
-				} elsif (/^\s*DECLARE_ASN1_PRINT_FUNCTION\s*\(\s*(\w*)\s*\)/) {
-					$def .= &quot;int $1_print_ctx(void);&quot;;
-					next;
-				} elsif (/^\s*DECLARE_ASN1_PRINT_FUNCTION_name\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
-					$def .= &quot;int $2_print_ctx(void);&quot;;
-					next;
-				} elsif (/^\s*DECLARE_PKCS12_STACK_OF\s*\(\s*(\w*)\s*\)/) {
-					next;
-				} elsif (/^DECLARE_PEM_rw\s*\(\s*(\w*)\s*,/ ||
-					 /^DECLARE_PEM_rw_cb\s*\(\s*(\w*)\s*,/ ||
-					 /^DECLARE_PEM_rw_const\s*\(\s*(\w*)\s*,/ ) {
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(',',&quot;STDIO&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					$def .= &quot;int PEM_read_$1(void);&quot;;
-					$def .= &quot;int PEM_write_$1(void);&quot;;
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					# Things that are everywhere
-					$def .= &quot;int PEM_read_bio_$1(void);&quot;;
-					$def .= &quot;int PEM_write_bio_$1(void);&quot;;
-					next;
-				} elsif (/^DECLARE_PEM_write\s*\(\s*(\w*)\s*,/ ||
-					/^DECLARE_PEM_write_const\s*\(\s*(\w*)\s*,/ ||
-					 /^DECLARE_PEM_write_cb\s*\(\s*(\w*)\s*,/ ) {
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(',',&quot;STDIO&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					$def .= &quot;int PEM_write_$1(void);&quot;;
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					# Things that are everywhere
-					$def .= &quot;int PEM_write_bio_$1(void);&quot;;
-					next;
-				} elsif (/^DECLARE_PEM_read\s*\(\s*(\w*)\s*,/ ||
-					 /^DECLARE_PEM_read_cb\s*\(\s*(\w*)\s*,/ ) {
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(',',&quot;STDIO&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					$def .= &quot;int PEM_read_$1(void);&quot;;
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(',',&quot;STDIO&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					# Things that are everywhere
-					$def .= &quot;int PEM_read_bio_$1(void);&quot;;
-					next;
-				} elsif (/^OPENSSL_DECLARE_GLOBAL\s*\(\s*(\w*)\s*,\s*(\w*)\s*\)/) {
-					# Variant for platforms that do not
-					# have to access global variables
-					# in shared libraries through functions
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(',',&quot;!EXPORT_VAR_AS_FUNCTION&quot;<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					$def .= &quot;OPENSSL_EXTERN int _shadow_$2;&quot;;
-					$def .=
-					    &quot;#INFO:&quot;
-						.join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_platforms</A>).&quot;:&quot;
-						    .join(','<A HREF="../../../mailman/listinfo/openssl-commits.html">, at current_algorithms</A>).&quot;;&quot;;
-					# Variant for platforms that have to
-					# access global variables in shared
-					# libraries through functions
-					&amp;$make_variant(&quot;_shadow_$2&quot;,&quot;_shadow_$2&quot;,
-						      &quot;EXPORT_VAR_AS_FUNCTION&quot;,
-						      &quot;FUNCTION&quot;);
-				} elsif (/^\s*DEPRECATEDIN/) {
-					$parens = count_parens($_);
-					if ($parens == 0) {
-						$def .= do_deprecated($_,
-							\@current_platforms,
-							\@current_algorithms);
-					} else {
-						$stored_multiline = $_;
-						print STDERR &quot;DEBUG: Found multiline DEPRECATEDIN starting with: $stored_multiline\n&quot; if $debug;
-						next;
-					}
-				} elsif ($tag{'CONST_STRICT'} != 1) {
-					if (/\{|\/\*|\([^\)]*$/) {
-						$line = $_;
-					} else {
-						$def .= $_;
-					}
-				}
-			}
-		}
-		close(IN);
-		die &quot;$file: Unmatched tags\n&quot; if $#tag &gt;= 0;
-
-		my $algs;
-		my $plays;
-
-		print STDERR &quot;DEBUG: postprocessing ----------\n&quot; if $debug;
-		foreach (split /;/, $def) {
-			my $s; my $k = &quot;FUNCTION&quot;; my $p; my $a;
-			s/^[\n\s]*//g;
-			s/[\n\s]*$//g;
-			next if(/\#undef/);
-			next if(/typedef\W/);
-			next if(/\#define/);
-
-			print STDERR &quot;TRACE: processing $_\n&quot; if $trace &amp;&amp; !/^\#INFO:/;
-			# Reduce argument lists to empty ()
-			# fold round brackets recursively: (t(*v)(t),t) -&gt; (t{}{},t) -&gt; {}
-			my $nsubst = 1; # prevent infinite loop, e.g., on  int fn()
-			while($nsubst &amp;&amp; /\(.*\)/s) {
-				$nsubst = s/\([^\(\)]+\)/\{\}/gs;
-				$nsubst+= s/\(\s*\*\s*(\w+)\s*\{\}\s*\)/$1/gs;	#(*f{}) -&gt; f
-			}
-			# pretend as we didn't use curly braces: {} -&gt; ()
-			s/\{\}/\(\)/gs;
-
-			s/STACK_OF\(\)/void/gs;
-			s/LHASH_OF\(\)/void/gs;
-
-			print STDERR &quot;DEBUG: \$_ = \&quot;$_\&quot;\n&quot; if $debug;
-			if (/^\#INFO:([^:]*):(.*)$/) {
-				$plats = $1;
-				$algs = $2;
-				print STDERR &quot;DEBUG: found info on platforms ($plats) and algorithms ($algs)\n&quot; if $debug;
-				next;
-			} elsif (/^\s*OPENSSL_EXTERN\s.*?(\w+(\{[0-9]+\})?)(\[[0-9]*\])*\s*$/) {
-				$s = $1;
-				$k = &quot;VARIABLE&quot;;
-				print STDERR &quot;DEBUG: found external variable $s\n&quot; if $debug;
-			} elsif (/TYPEDEF_\w+_OF/s) {
-				next;
-			} elsif (/(\w+)\s*\(\).*/s) {	# first token prior [first] () is
-				$s = $1;		# a function name!
-				print STDERR &quot;DEBUG: found function $s\n&quot; if $debug;
-			} elsif (/\(/ and not (/=/)) {
-				print STDERR &quot;File $file: cannot parse: $_;\n&quot;;
-				next;
-			} else {
-				next;
-			}
-
-			$syms{$s} = 1;
-			$kind{$s} = $k;
-
-			$p = $plats;
-			$a = $algs;
-
-			$platform{$s} =
-			    &amp;reduce_platforms((defined($platform{$s})?$platform{$s}.',':&quot;&quot;).$p);
-			$algorithm{$s} .= ','.$a;
-
-			if (defined($variant{$s})) {
-				foreach $v (split /;/,$variant{$s}) {
-					(my $r, my $p, my $k) = split(/:/,$v);
-					my $ip = join ',',map({ /^!(.*)$/ ? $1 : &quot;!&quot;.$_ } split /,/, $p);
-					$syms{$r} = 1;
-					if (!defined($k)) { $k = $kind{$s}; }
-					$kind{$r} = $k.&quot;(&quot;.$s.&quot;)&quot;;
-					$algorithm{$r} = $algorithm{$s};
-					$platform{$r} = &amp;reduce_platforms($platform{$s}.&quot;,&quot;.$p.&quot;,&quot;.$p);
-					$platform{$s} = &amp;reduce_platforms($platform{$s}.','.$ip.','.$ip);
-					print STDERR &quot;DEBUG: \$variant{\&quot;$s\&quot;} = &quot;,$v,&quot;; \$r = $r; \$p = &quot;,$platform{$r},&quot;; \$a = &quot;,$algorithm{$r},&quot;; \$kind = &quot;,$kind{$r},&quot;\n&quot; if $debug;
-				}
-			}
-			print STDERR &quot;DEBUG: \$s = $s; \$p = &quot;,$platform{$s},&quot;; \$a = &quot;,$algorithm{$s},&quot;; \$kind = &quot;,$kind{$s},&quot;\n&quot; if $debug;
-		}
-	}
-
-	# Info we know about
-
-	push @ret, map { $_.&quot;\\&quot;.&amp;info_string($_,&quot;EXIST&quot;,
-					      $platform{$_},
-					      $kind{$_},
-					      $algorithm{$_}) } keys %syms;
+(my $SO_VARIANT = uc($target{&quot;shlib_variant&quot;} // '')) =~ s/\W/_/g;
+
+my $apiv = undef;
+$apiv = sprintf &quot;%x%02x%02x&quot;, split(/\./, $config{api})
+    if $config{api};
+
+my $libname = $unified_info{sharednames}-&gt;{$name} // $name;
+
+my %OS_data = (
+    solaris     =&gt; { writer     =&gt; \&amp;writer_linux,
+                     sort       =&gt; sorter_linux(),
+                     platforms  =&gt; { UNIX                       =&gt; 1,
+                                     EXPORT_VAR_AS_FUNCTION     =&gt; 0 } },
+    linux       =&gt; 'solaris',   # alias
+    aix         =&gt; { writer     =&gt; \&amp;writer_aix,
+                     sort       =&gt; sorter_unix(),
+                     platforms  =&gt; { UNIX                       =&gt; 1,
+                                     EXPORT_VAR_AS_FUNCTION     =&gt; 0 } },
+    VMS         =&gt; { writer     =&gt; \&amp;writer_VMS,
+                     sort       =&gt; OpenSSL::Ordinals::by_number(),
+                     platforms  =&gt; { VMS                        =&gt; 1,
+                                     EXPORT_VAR_AS_FUNCTION     =&gt; 0 } },
+    vms         =&gt; 'VMS',       # alias
+    WINDOWS     =&gt; { writer     =&gt; \&amp;writer_windows,
+                     sort       =&gt; OpenSSL::Ordinals::by_name(),
+                     platforms  =&gt; { WIN32                      =&gt; 1,
+                                     _WIN32                     =&gt; 1,
+                                     EXPORT_VAR_AS_FUNCTION     =&gt; 1 } },
+    windows     =&gt; 'WINDOWS',   # alias
+    WIN32       =&gt; 'WINDOWS',   # alias
+    win32       =&gt; 'WIN32',     # alias
+    32          =&gt; 'WIN32',     # alias
+    NT          =&gt; 'WIN32',     # alias
+    nt          =&gt; 'WIN32',     # alias
+    mingw       =&gt; 'WINDOWS',   # alias
+   );
+
+do {
+    die &quot;Unknown operating system family $OS\n&quot;
+        unless exists $OS_data{$OS};
+    $OS = $OS_data{$OS};
+} while(ref($OS) eq '');
+
+my %disabled_uc = map { my $x = uc $_; $x =~ s|-|_|g; $x =&gt; 1 } keys %disabled;
+
+my %ordinal_opts = ();
+$ordinal_opts{sort} = $OS-&gt;{sort} if $OS-&gt;{sort};
+$ordinal_opts{filter} =
+    sub {
+        my $item = shift;
+        return
+            $item-&gt;exists()
+            &amp;&amp; platform_filter($item)
+            &amp;&amp; feature_filter($item);
+    };
+my $ordinals = OpenSSL::Ordinals-&gt;new(from =&gt; $ordinals_file);
+
+my $writer = $OS-&gt;{writer};
+$writer = \&amp;writer_ctest if $ctest;
+
+$writer-&gt;($ordinals-&gt;items(%ordinal_opts));
+
+exit 0;
+
+sub platform_filter {
+    my $item = shift;
+    my %platforms = ( $item-&gt;platforms() );
+
+    # True if no platforms are defined
+    return 1 if scalar keys %platforms == 0;
+
+    # For any item platform tag, return the equivalence with the
+    # current platform settings if it exists there, return 0 otherwise
+    # if the item platform tag is true
+    for (keys %platforms) {
+        if (exists $OS-&gt;{platforms}-&gt;{$_}) {
+            return $platforms{$_} == $OS-&gt;{platforms}-&gt;{$_};
+        }
+        if ($platforms{$_}) {
+            return 0;
+        }
+    }
 
-	if (keys %unknown_algorithms) {
-		print STDERR &quot;WARNING: mkdef.pl doesn't know the following algorithms:\n&quot;;
-		print STDERR &quot;\t&quot;,join(&quot;\n\t&quot;,keys %unknown_algorithms),&quot;\n&quot;;
-	}
-	return(@ret);
+    # Found no match?  Then it's a go
+    return 1;
 }
 
-# Param: string of comma-separated platform-specs.
-sub reduce_platforms
-{
-	my ($platforms) = @_;
-	my $pl = defined($platforms) ? $platforms : &quot;&quot;;
-	my %p = map { $_ =&gt; 0 } split /,/, $pl;
-	my $ret;
-
-	print STDERR &quot;DEBUG: Entered reduce_platforms with \&quot;$platforms\&quot;\n&quot;
-	    if $debug;
-	# We do this, because if there's code like the following, it really
-	# means the function exists in all cases and should therefore be
-	# everywhere.  By increasing and decreasing, we may attain 0:
-	#
-	# ifndef WIN16
-	#    int foo();
-	# else
-	#    int _fat foo();
-	# endif
-	foreach $platform (split /,/, $pl) {
-		if ($platform =~ /^!(.*)$/) {
-			$p{$1}--;
-		} else {
-			$p{$platform}++;
-		}
-	}
-	foreach $platform (keys %p) {
-		if ($p{$platform} == 0) { delete $p{$platform}; }
-	}
+sub feature_filter {
+    my $item = shift;
+    my @features = ( $item-&gt;features() );
 
-	delete $p{&quot;&quot;};
+    # True if no features are defined
+    return 1 if scalar @features == 0;
 
-	$ret = join(',',sort(map { $p{$_} &lt; 0 ? &quot;!&quot;.$_ : $_ } keys %p));
-	print STDERR &quot;DEBUG: Exiting reduce_platforms with \&quot;$ret\&quot;\n&quot;
-	    if $debug;
-	return $ret;
-}
-
-sub info_string
-{
-	(my $symbol, my $exist, my $platforms, my $kind, my $algorithms) = @_;
+    my $verdict = ! grep { $disabled_uc{$_} } @features;
 
-	my %a = defined($algorithms) ?
-	    map { $_ =&gt; 1 } split /,/, $algorithms : ();
-	my $k = defined($kind) ? $kind : &quot;FUNCTION&quot;;
-	my $ret;
-	my $p = &amp;reduce_platforms($platforms);
-
-	delete $a{&quot;&quot;};
+    if ($apiv) {
+        foreach (@features) {
+            next unless /^DEPRECATEDIN_(\d+)_(\d+)_(\d+)$/;
+            my $symdep = sprintf &quot;%x%02x%02x&quot;, $1, $2, $3;
+            $verdict = 0 if $apiv ge $symdep;
+        }
+    }
 
-	$ret = $exist;
-	$ret .= &quot;:&quot;.$p;
-	$ret .= &quot;:&quot;.$k;
-	$ret .= &quot;:&quot;.join(',',sort keys %a);
-	return $ret;
+    return $verdict;
 }
 
-sub maybe_add_info
-{
-	(my $name, *nums, my @symbols) = @_;
-	my $sym;
-	my $new_info = 0;
-	my %syms=();
+sub sorter_unix {
+    my $by_name = OpenSSL::Ordinals::by_name();
+    my %weight = (
+        'FUNCTION'      =&gt; 1,
+        'VARIABLE'      =&gt; 2
+       );
 
-	foreach $sym (@symbols) {
-		(my $s, my $i) = split /\\/, $sym;
-		if (defined($nums{$s})) {
-			$i =~ s/^(.*?:.*?:\w+)(\(\w+\))?/$1/;
-			(my $n, my $vers, my $dummy) = split /\\/, $nums{$s};
-			if (!defined($dummy) || $i ne $dummy) {
-				$nums{$s} = $n.&quot;\\&quot;.$vers.&quot;\\&quot;.$i;
-				$new_info++;
-				print STDERR &quot;DEBUG: maybe_add_info for $s: \&quot;$dummy\&quot; =&gt; \&quot;$i\&quot;\n&quot; if $debug;
-			}
-		}
-		$syms{$s} = 1;
-	}
+    return sub {
+        my $item1 = shift;
+        my $item2 = shift;
 
-	my @s=sort { &amp;parse_number($nums{$a},&quot;n&quot;) &lt;=&gt; &amp;parse_number($nums{$b},&quot;n&quot;) } keys %nums;
-	foreach $sym (@s) {
-		(my $n, my $vers, my $i) = split /\\/, $nums{$sym};
-		if (!defined($syms{$sym}) &amp;&amp; $i !~ /^NOEXIST:/) {
-			$new_info++;
-			print STDERR &quot;DEBUG: maybe_add_info for $sym: -&gt; undefined\n&quot; if $debug;
-		}
-	}
-	if ($new_info) {
-		print STDERR &quot;$name: $new_info old symbols have updated info\n&quot;;
-		if (!$do_rewrite) {
-			print STDERR &quot;You should do a rewrite to fix this.\n&quot;;
-		}
-	} else {
-	}
+        my $verdict = $weight{$item1-&gt;type()} &lt;=&gt; $weight{$item2-&gt;type()};
+        if ($verdict == 0) {
+            $verdict = $by_name-&gt;($item1, $item2);
+        }
+        return $verdict;
+    };
 }
 
-# Param: string of comma-separated keywords, each possibly prefixed with a &quot;!&quot;
-sub is_valid
-{
-	my ($keywords_txt,$platforms) = @_;
-	my (@keywords) = split /,/,$keywords_txt;
-	my ($falsesum, $truesum) = (0, 1);
-
-	# Param: one keyword
-	sub recognise
-	{
-		my ($keyword,$platforms) = @_;
-
-		if ($platforms) {
-			# platforms
-			if ($keyword eq &quot;UNIX&quot; &amp;&amp; $UNIX) { return 1; }
-			if ($keyword eq &quot;VMS&quot; &amp;&amp; $VMS) { return 1; }
-			if ($keyword eq &quot;WIN32&quot; &amp;&amp; $W32) { return 1; }
-			if ($keyword eq &quot;_WIN32&quot; &amp;&amp; $W32) { return 1; }
-			if ($keyword eq &quot;WINNT&quot; &amp;&amp; $NT) { return 1; }
-			# Special platforms:
-			# EXPORT_VAR_AS_FUNCTION means that global variables
-			# will be represented as functions.
-			if ($keyword eq &quot;EXPORT_VAR_AS_FUNCTION&quot; &amp;&amp; $W32) {
-				return 1;
-			}
-			if ($keyword eq &quot;ZLIB&quot; &amp;&amp; $zlib) { return 1; }
-			return 0;
-		} else {
-			# algorithms
-			if ($disabled_algorithms{$keyword}) { return 0;}
+sub sorter_linux {
+    my $by_version = OpenSSL::Ordinals::by_version();
+    my $by_unix = sorter_unix();
 
-			# Nothing recognise as true
-			return 1;
-		}
-	}
+    return sub {
+        my $item1 = shift;
+        my $item2 = shift;
 
-	foreach $k (@keywords) {
-		if ($k =~ /^!(.*)$/) {
-			$falsesum += &amp;recognise($1,$platforms);
-		} else {
-			$truesum *= &amp;recognise($k,$platforms);
-		}
-	}
-	print STDERR &quot;DEBUG: [&quot;,$#keywords,&quot;,&quot;,$#keywords &lt; 0,&quot;] is_valid($keywords_txt) =&gt; (\!$falsesum) &amp;&amp; $truesum = &quot;,(!$falsesum) &amp;&amp; $truesum,&quot;\n&quot; if $debug;
-	return (!$falsesum) &amp;&amp; $truesum;
+        my $verdict = $by_version-&gt;($item1, $item2);
+        if ($verdict == 0) {
+            $verdict = $by_unix-&gt;($item1, $item2);
+        }
+        return $verdict;
+    };
 }
 
-sub print_test_file
-{
-	(*OUT,my $name,*nums,my $testall,my @symbols)=@_;
-	my $n = 1; my @e; my @r;
-	my $sym; my $prev = &quot;&quot;; my $prefSSLeay;
-
-	(@e)=grep(/^SSLeay(\{[0-9]+\})?\\.*?:.*?:.*/<A HREF="../../../mailman/listinfo/openssl-commits.html">, at symbols</A>);
-	(@r)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:.*/ &amp;&amp; !/^SSLeay(\{[0-9]+\})?\\.*?:.*?:.*/<A HREF="../../../mailman/listinfo/openssl-commits.html">, at symbols</A>);
-	@symbols=((sort @e),(sort @r));
-
-	foreach $sym (@symbols) {
-		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
-		my $v = 0;
-		$v = 1 if $i=~ /^.*?:.*?:VARIABLE/;
-		my $p = ($i =~ /^[^:]*:([^:]*):/,$1);
-		my $a = ($i =~ /^[^:]*:[^:]*:[^:]*:([^:]*)/,$1);
-		if (!defined($nums{$s})) {
-			print STDERR &quot;Warning: $s does not have a number assigned\n&quot;
-			    if(!$do_update);
-		} elsif (is_valid($p,1) &amp;&amp; is_valid($a,0)) {
-			my $s2 = ($s =~ /^(.*?)(\{[0-9]+\})?$/, $1);
-			if ($prev eq $s2) {
-				print OUT &quot;\t/* The following has already appeared previously */\n&quot;;
-				print STDERR &quot;Warning: Symbol '&quot;,$s2,&quot;' redefined. old=&quot;,($nums{$prev} =~ /^(.*?)\\/,$1),&quot;, new=&quot;,($nums{$s2} =~ /^(.*?)\\/,$1),&quot;\n&quot;;
-			}
-			$prev = $s2;	# To warn about duplicates...
+sub writer_linux {
+    my $thisversion = '';
+    my $prevversion = '';
+
+    for (@_) {
+        if ($thisversion &amp;&amp; $_-&gt;version() ne $thisversion) {
+            print &lt;&lt;&quot;_____&quot;;
+}$prevversion;
+_____
+            $prevversion = &quot; OPENSSL${SO_VARIANT}_$thisversion&quot;;
+            $thisversion = '';  # Trigger start of next section
+        }
+        unless ($thisversion) {
+            $thisversion = $_-&gt;version();
+            print &lt;&lt;&quot;_____&quot;;
+OPENSSL${SO_VARIANT}_$thisversion {
+    global:
+_____
+        }
+        print '        ', $_-&gt;name(), &quot;;\n&quot;;
+    }
 
-			(my $nn, my $vers, my $ni) = split /\\/, $nums{$s2};
-			if ($v) {
-				print OUT &quot;\textern int $s2; /* type unknown */ /* $nn $ni */\n&quot;;
-			} else {
-				print OUT &quot;\textern int $s2(); /* type unknown */ /* $nn $ni */\n&quot;;
-			}
-		}
-	}
+    print &lt;&lt;&quot;_____&quot;;
+    local: *;
+}$prevversion;
+_____
 }
 
-sub get_version
-{
-   return $config{version};
+sub writer_aix {
+    for (@_) {
+        print $_-&gt;name(),&quot;\n&quot;;
+    }
 }
 
-sub print_def_file
-{
-	(*OUT,my $name,*nums,my @symbols)=@_;
-	my $n = 1; my @e; my @r; my @v; my $prev=&quot;&quot;;
-	my $liboptions=&quot;&quot;;
-	my $libname = $name;
-	my $http_vendor = 'www.openssl.org/';
-	my $version = get_version();
-	my $what = &quot;OpenSSL: implementation of Secure Socket Layer&quot;;
-	my $description = &quot;$what $version, $name - <A HREF="http://$http_vendor">http://$http_vendor</A>&quot;;
-	my $prevsymversion = &quot;&quot;, $prevprevsymversion = &quot;&quot;;
-        # For VMS
-        my $prevnum = 0;
-        my $symvtextcount = 0;
-
-        if ($W32)
-                {
-                print OUT &lt;&lt;&quot;EOF&quot;;
+sub writer_windows {
+    print &lt;&lt;&quot;_____&quot;;
 ;
-; Definition file for the DLL version of the $name library from OpenSSL
+; Definition file for the DLL version of the $libname library from OpenSSL
 ;
 
-LIBRARY         $libname	$liboptions
+LIBRARY         $libname
 
-EOF
-
-		print &quot;EXPORTS\n&quot;;
-                }
-        elsif ($VMS)
-                {
-                print OUT &lt;&lt;&quot;EOF&quot;;
-IDENTIFICATION=$version
-CASE_SENSITIVE=YES
-SYMBOL_VECTOR=(-
-EOF
-                $symvtextcount = 16; # length of &quot;SYMBOL_VECTOR=(-&quot;
-                }
+EXPORTS
+_____
+    for (@_) {
+        print &quot;    &quot;,$_-&gt;name(),&quot;\n&quot;;
+    }
+}
 
-	(@r)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:FUNCTION/<A HREF="../../../mailman/listinfo/openssl-commits.html">, at symbols</A>);
-	(@v)=grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:VARIABLE/<A HREF="../../../mailman/listinfo/openssl-commits.html">, at symbols</A>);
-        if ($VMS) {
-            # VMS needs to have the symbols on slot number order
-            @symbols=(map { $_-&gt;[1] }
-                      sort { $a-&gt;[0] &lt;=&gt; $b-&gt;[0] }
-                      map { (my $s, my $i) = $_ =~ /^(.*?)\\(.*)$/;
-                            die &quot;Error: $s doesn't have a number assigned\n&quot;
-                                if !defined($nums{$s});
-                            (my $n, my @rest) = split /\\/, $nums{$s};
-                            [ $n, $_ ] } (@e, @r, @v));
+sub writer_VMS {
+    my @slot_collection = ();
+    my $write_vector_slot_pair =
+        sub {
+            my $slot1 = shift;
+            my $slot2 = shift;
+            my $slotpair_text = &quot; $slot1, -\n  $slot2, -\n&quot;
+        };
+
+    my $last_num = 0;
+    foreach (@_) {
+        while (++$last_num &lt; $_-&gt;number()) {
+            push @slot_collection, [ 'SPARE', 'SPARE' ];
+        }
+        my $type = {
+            FUNCTION    =&gt; 'PROCEDURE',
+            VARIABLE    =&gt; 'DATA'
+           } -&gt; {$_-&gt;type()};
+        my $s = $_-&gt;name();
+        my $s_uc = uc($s);
+        if ($s_uc eq $s) {
+            push @slot_collection, [ &quot;$s=$type&quot;, 'SPARE' ];
         } else {
-            @symbols=((sort @e),(sort @r), (sort @v));
+            push @slot_collection, [ &quot;$s_uc/$s=$type&quot;, &quot;$s=$type&quot; ];
         }
+    }
 
-	my ($baseversion, $currversion) = get_openssl_version();
-	my $thisversion;
-	do {
-		if (!defined($thisversion)) {
-			$thisversion = $baseversion;
-		} else {
-			$thisversion = get_next_version($thisversion);
-		}
-		foreach $sym (@symbols) {
-			(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
-			my $v = 0;
-			$v = 1 if $i =~ /^.*?:.*?:VARIABLE/;
-			if (!defined($nums{$s})) {
-				die &quot;Error: $s does not have a number assigned\n&quot;
-					if(!$do_update);
-			} else {
-				(my $n, my $symversion, my $dummy) = split /\\/, $nums{$s};
-				my %pf = ();
-				my $p = ($i =~ /^[^:]*:([^:]*):/,$1);
-				my $a = ($i =~ /^[^:]*:[^:]*:[^:]*:([^:]*)/,$1);
-				if (is_valid($p,1) &amp;&amp; is_valid($a,0)) {
-					my $s2 = ($s =~ /^(.*?)(\{[0-9]+\})?$/, $1);
-					if ($prev eq $s2) {
-						print STDERR &quot;Warning: Symbol '&quot;,$s2,
-							&quot;' redefined. old=&quot;,($nums{$prev} =~ /^(.*?)\\/,$1),
-							&quot;, new=&quot;,($nums{$s2} =~ /^(.*?)\\/,$1),&quot;\n&quot;;
-					}
-					$prev = $s2;	# To warn about duplicates...
-					if($linux) {
-						next if $symversion ne $thisversion;
-						if ($symversion ne $prevsymversion) {
-							if ($prevsymversion ne &quot;&quot;) {
-								if ($prevprevsymversion ne &quot;&quot;) {
-									print OUT &quot;} OPENSSL${SO_VARIANT}_&quot;
-												.&quot;$prevprevsymversion;\n\n&quot;;
-								} else {
-									print OUT &quot;};\n\n&quot;;
-								}
-							}
-							print OUT &quot;OPENSSL${SO_VARIANT}_$symversion {\n    global:\n&quot;;
-							$prevprevsymversion = $prevsymversion;
-							$prevsymversion = $symversion;
-						}
-						print OUT &quot;        $s2;\n&quot;;
-					} elsif ($aix) {
-						print OUT &quot;$s2\n&quot;;
-                                        } elsif ($VMS) {
-                                            while(++$prevnum &lt; $n) {
-                                                my $symline=&quot; ,SPARE -\n  ,SPARE -\n&quot;;
-                                                if ($symvtextcount + length($symline) - 2 &gt; 1024) {
-                                                    print OUT &quot;)\nSYMBOL_VECTOR=(-\n&quot;;
-                                                    $symvtextcount = 16; # length of &quot;SYMBOL_VECTOR=(-&quot;
-                                                }
-                                                if ($symvtextcount == 16) {
-                                                    # Take away first comma
-                                                    $symline =~ s/,//;
-                                                }
-                                                print OUT $symline;
-                                                $symvtextcount += length($symline) - 2;
-                                            }
-                                            (my $s_uc = $s) =~ tr/a-z/A-Z/;
-                                            my $symtype=
-                                                $v ? &quot;DATA&quot; : &quot;PROCEDURE&quot;;
-                                            my $symline=
-                                                ($s_uc ne $s
-                                                 ? &quot; ,$s_uc/$s=$symtype -\n  ,$s=$symtype -\n&quot;
-                                                 : &quot; ,$s=$symtype -\n  ,SPARE -\n&quot;);
-                                            if ($symvtextcount + length($symline) - 2 &gt; 1024) {
-                                                print OUT &quot;)\nSYMBOL_VECTOR=(-\n&quot;;
-                                                $symvtextcount = 16; # length of &quot;SYMBOL_VECTOR=(-&quot;
-                                            }
-                                            if ($symvtextcount == 16) {
-                                                # Take away first comma
-                                                $symline =~ s/,//;
-                                            }
-                                            print OUT $symline;
-                                            $symvtextcount += length($symline) - 2;
-					} elsif($v) {
-						printf OUT &quot;    %s%-39s DATA\n&quot;,
-								($W32)?&quot;&quot;:&quot;_&quot;,$s2;
-					} else {
-						printf OUT &quot;    %s%s\n&quot;,
-								($W32)?&quot;&quot;:&quot;_&quot;,$s2;
-					}
-				}
-			}
-		}
-	} while ($linux &amp;&amp; $thisversion ne $currversion);
-	if ($linux) {
-		if ($prevprevsymversion ne &quot;&quot;) {
-			print OUT &quot;    local: *;\n} OPENSSL${SO_VARIANT}_$prevprevsymversion;\n\n&quot;;
-		} else {
-			print OUT &quot;    local: *;\n};\n\n&quot;;
-		}
-	} elsif ($VMS) {
-            print OUT &quot;)\n&quot;;
-            (my $libvmaj, my $libvmin, my $libvedit) =
-                $currversion =~ /^(\d+)_(\d+)_(\d+)[a-z]{0,2}$/;
-            # The reason to multiply the edit number with 100 is to make space
-            # for the possibility that we want to encode the patch letters
-            print OUT &quot;GSMATCH=LEQUAL,&quot;,($libvmaj * 100 + $libvmin),&quot;,&quot;,($libvedit * 100),&quot;\n&quot;;
+    print &lt;&lt;&quot;_____&quot;;
+IDENTIFICATION=$config{version}
+CASE_SENSITIVE=YES
+SYMBOL_VECTOR=(-
+_____
+    # It's uncertain how long aggregated lines the linker can handle,
+    # but it has been observed that at least 1024 characters is ok.
+    # Either way, this means that we need to keep track of the total
+    # line length of each &quot;SYMBOL_VECTOR&quot; statement.  Fortunately, we
+    # can have more than one of those...
+    my $symvtextcount = 16;     # The length of &quot;SYMBOL_VECTOR=(&quot;
+    while (@slot_collection) {
+        my $pair = shift @slot_collection;
+        my $pairtextlength =
+            2                   # one space indentation and comma
+            + length($pair-&gt;[0])
+            + 1                 # postdent
+            + 3                 # two space indentation and comma
+            + length($pair-&gt;[1])
+            + 1                 # postdent
+            ;
+        my $firstcomma = ',';
+
+        if ($symvtextcount + $pairtextlength &gt; 1024) {
+            print &lt;&lt;&quot;_____&quot;;
+)
+SYMBOL_VECTOR=(-
+_____
+            $symvtextcount = 16; # The length of &quot;SYMBOL_VECTOR=(&quot;
         }
-	printf OUT &quot;\n&quot;;
-}
-
-sub load_numbers
-{
-	my($name)=@_;
-	my(@a,%ret);
-	my $prevversion;
-
-	$max_num = 0;
-	$num_noinfo = 0;
-	$prev = &quot;&quot;;
-	$prev_cnt = 0;
-
-	my ($baseversion, $currversion) = get_openssl_version();
-
-	open(IN,&quot;&lt;$name&quot;) || die &quot;unable to open $name:$!\n&quot;;
-	while (&lt;IN&gt;) {
-		s|\R$||;        # Better chomp
-		s/#.*$//;
-		next if /^\s*$/;
-		@a=split;
-		if (defined $ret{$a[0]}) {
-			# This is actually perfectly OK
-			#print STDERR &quot;Warning: Symbol '&quot;,$a[0],&quot;' redefined. old=&quot;,$ret{$a[0]},&quot;, new=&quot;,$a[1],&quot;\n&quot;;
-		}
-		if ($max_num &gt; $a[1]) {
-			print STDERR &quot;Warning: Number decreased from &quot;,$max_num,&quot; to &quot;,$a[1],&quot;\n&quot;;
-		}
-		elsif ($max_num == $a[1]) {
-			# This is actually perfectly OK
-			#print STDERR &quot;Warning: Symbol &quot;,$a[0],&quot; has same number as previous &quot;,$prev,&quot;: &quot;,$a[1],&quot;\n&quot;;
-			if ($a[0] eq $prev) {
-				$prev_cnt++;
-				$a[0] .= &quot;{$prev_cnt}&quot;;
-			}
-		}
-		else {
-			$prev_cnt = 0;
-		}
-		if ($#a &lt; 2) {
-			# Existence will be proven later, in do_defs
-			$ret{$a[0]}=$a[1];
-			$num_noinfo++;
-		} else {
-			#Sanity check the version number
-			if (defined $prevversion) {
-				check_version_lte($prevversion, $a[2]);
-			}
-			check_version_lte($a[2], $currversion);
-			$prevversion = $a[2];
-			$ret{$a[0]}=$a[1].&quot;\\&quot;.$a[2].&quot;\\&quot;.$a[3]; # \\ is a special marker
-		}
-		$max_num = $a[1] if $a[1] &gt; $max_num;
-		$prev=$a[0];
-	}
-	if ($num_noinfo) {
-		print STDERR &quot;Warning: $num_noinfo symbols were without info.&quot; if $verbose || !$do_rewrite;
-		if ($do_rewrite) {
-			printf STDERR &quot;  The rewrite will fix this.\n&quot; if $verbose;
-		} else {
-			printf STDERR &quot;  You should do a rewrite to fix this.\n&quot;;
-		}
-	}
-	close(IN);
-	return(%ret);
-}
-
-sub parse_number
-{
-	(my $str, my $what) = @_;
-	(my $n, my $v, my $i) = split(/\\/,$str);
-	if ($what eq &quot;n&quot;) {
-		return $n;
-	} else {
-		return $i;
-	}
-}
-
-sub rewrite_numbers
-{
-	(*OUT,$name,*<A HREF="../../../mailman/listinfo/openssl-commits.html">nums, at symbols</A>)=@_;
-	my $thing;
-
-	my @r = grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:\w+\(\w+\)/<A HREF="../../../mailman/listinfo/openssl-commits.html">, at symbols</A>);
-	my $r; my %r; my %rsyms;
-	foreach $r (@r) {
-		(my $s, my $i) = split /\\/, $r;
-		my $a = $1 if $i =~ /^.*?:.*?:\w+\((\w+)\)/;
-		$i =~ s/^(.*?:.*?:\w+)\(\w+\)/$1/;
-		$r{$a} = $s.&quot;\\&quot;.$i;
-		$rsyms{$s} = 1;
-	}
-
-	my %syms = ();
-	foreach $_ (@symbols) {
-		(my $n, my $i) = split /\\/;
-		$syms{$n} = 1;
-	}
-
-	my @s=sort {
-	    &amp;parse_number($nums{$a},&quot;n&quot;) &lt;=&gt; &amp;parse_number($nums{$b},&quot;n&quot;)
-	    || $a cmp $b
-	} keys %nums;
-	foreach $sym (@s) {
-		(my $n, my $vers, my $i) = split /\\/, $nums{$sym};
-		next if defined($i) &amp;&amp; $i =~ /^.*?:.*?:\w+\(\w+\)/;
-		next if defined($rsyms{$sym});
-		print STDERR &quot;DEBUG: rewrite_numbers for sym = &quot;,$sym,&quot;: i = &quot;,$i,&quot;, n = &quot;,$n,&quot;, rsym{sym} = &quot;,$rsyms{$sym},&quot;syms{sym} = &quot;,$syms{$sym},&quot;\n&quot; if $debug;
-		$i=&quot;NOEXIST::FUNCTION:&quot;
-			if !defined($i) || $i eq &quot;&quot; || !defined($syms{$sym});
-		my $s2 = $sym;
-		$s2 =~ s/\{[0-9]+\}$//;
-		printf OUT &quot;%s%-39s %d\t%s\t%s\n&quot;,&quot;&quot;,$s2,$n,$vers,$i;
-		if (exists $r{$sym}) {
-			(my $s, $i) = split /\\/,$r{$sym};
-			my $s2 = $s;
-			$s2 =~ s/\{[0-9]+\}$//;
-			printf OUT &quot;%s%-39s %d\t%s\t%s\n&quot;,&quot;&quot;,$s2,$n,$vers,$i;
-		}
-	}
-}
-
-sub update_numbers
-{
-	(*OUT,$name,*nums,my $start_num, my @symbols)=@_;
-	my $new_syms = 0;
-	my $basevers;
-	my $vers;
-
-	($basevers, $vers) = get_openssl_version();
-
-	my @r = grep(/^\w+(\{[0-9]+\})?\\.*?:.*?:\w+\(\w+\)/<A HREF="../../../mailman/listinfo/openssl-commits.html">, at symbols</A>);
-	my $r; my %r; my %rsyms;
-	foreach $r (@r) {
-		(my $s, my $i) = split /\\/, $r;
-		my $a = $1 if $i =~ /^.*?:.*?:\w+\((\w+)\)/;
-		$i =~ s/^(.*?:.*?:\w+)\(\w+\)/$1/;
-		$r{$a} = $s.&quot;\\&quot;.$i;
-		$rsyms{$s} = 1;
-	}
-
-	foreach $sym (@symbols) {
-		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
-		next if $i =~ /^.*?:.*?:\w+\(\w+\)/;
-		next if defined($rsyms{$sym});
-		die &quot;ERROR: Symbol $sym had no info attached to it.&quot;
-		    if $i eq &quot;&quot;;
-		if (!exists $nums{$s}) {
-			$new_syms++;
-			my $s2 = $s;
-			$s2 =~ s/\{[0-9]+\}$//;
-			printf OUT &quot;%s%-39s %d\t%s\t%s\n&quot;,&quot;&quot;,$s2, ++$start_num,$vers,$i;
-			if (exists $r{$s}) {
-				($s, $i) = split /\\/,$r{$s};
-				$s =~ s/\{[0-9]+\}$//;
-				printf OUT &quot;%s%-39s %d\t%s\t%s\n&quot;,&quot;&quot;,$s, $start_num,$vers,$i;
-			}
-		}
-	}
-	if($new_syms) {
-		print STDERR &quot;$name: Added $new_syms new symbols\n&quot;;
-	} else {
-		print STDERR &quot;$name: No new symbols added\n&quot;;
-	}
-}
-
-sub check_existing
-{
-	(*nums, my @symbols)=@_;
-	my %existing; my @remaining;
-	@remaining=();
-	foreach $sym (@symbols) {
-		(my $s, my $i) = $sym =~ /^(.*?)\\(.*)$/;
-		$existing{$s}=1;
-	}
-	foreach $sym (keys %nums) {
-		if (!exists $existing{$sym}) {
-			push @remaining, $sym;
-		}
-	}
-	if(@remaining) {
-		print STDERR &quot;The following symbols do not seem to exist:\n&quot;;
-		foreach $sym (@remaining) {
-			print STDERR &quot;\t&quot;,$sym,&quot;\n&quot;;
-		}
-	}
-}
-
-sub count_parens
-{
-	my $line = shift(@_);
-
-	my $open = $line =~ tr/\(//;
-	my $close = $line =~ tr/\)//;
-
-	return $open - $close;
-}
-
-#Parse opensslv.h to get the current version number. Also work out the base
-#version, i.e. the lowest version number that is binary compatible with this
-#version
-sub get_openssl_version()
-{
-	my $fn = catfile($config{sourcedir},&quot;include&quot;,&quot;openssl&quot;,&quot;opensslv.h&quot;);
-	open (IN, &quot;$fn&quot;) || die &quot;Can't open opensslv.h&quot;;
-
-	while(&lt;IN&gt;) {
-		if (/OPENSSL_VERSION_TEXT\s+&quot;OpenSSL (\d\.\d\.)(\d[a-z]*)(-| )/) {
-			my $suffix = $2;
-			(my $baseversion = $1) =~ s/\./_/g;
-			close IN;
-			return ($baseversion.&quot;0&quot;, $baseversion.$suffix);
-		}
-	}
-	die &quot;Can't find OpenSSL version number\n&quot;;
-}
-
-#Given an OpenSSL version number, calculate the next version number. If the
-#version number gets to a.b.czz then we go to a.b.(c+1)
-sub get_next_version()
-{
-	my $thisversion = shift;
-
-	my ($base, $letter) = $thisversion =~ /^(\d_\d_\d)([a-z]{0,2})$/;
-
-	if ($letter eq &quot;zz&quot;) {
-		my $lastnum = substr($base, -1);
-		return substr($base, 0, length($base)-1).(++$lastnum);
-	}
-	return $base.get_next_letter($letter);
+        if ($symvtextcount == 16) {
+            $firstcomma = '';
+        }
+        print &lt;&lt;&quot;_____&quot;;
+ $firstcomma$pair-&gt;[0] -
+  ,$pair-&gt;[1] -
+_____
+        $symvtextcount += $pairtextlength;
+    }
+    print &lt;&lt;&quot;_____&quot;;
+)
+_____
+
+    my ($libvmajor, $libvminor, $libvedit, $libvpatch) =
+        $config{version} =~ /^(\d+)_(\d+)_(\d+)([a-z]{0,2})-.*$/;
+    my $libvpatchnum = 0;
+    for (split '', $libvpatch // '') {
+        $libvpatchnum += ord(lc($_)) - 96;
+        # To compensate because the letter 'z' is always followed by another,
+        # i.e. doesn't add any value on its own
+        $libvpatchnum-- if lc($_) eq 'z';
+    }
+    my $match1 = $libvmajor * 100 + $libvminor;
+    my $match2 = $libvedit * 100 + $libvpatchnum;
+    print &lt;&lt;&quot;_____&quot;;
+GSMATCH=LEQUAL,$match1,$match2
+_____
 }
 
-#Given the letters off the end of an OpenSSL version string, calculate what
-#the letters for the next release would be.
-sub get_next_letter()
-{
-	my $thisletter = shift;
-	my $baseletter = &quot;&quot;;
-	my $endletter;
-
-	if ($thisletter eq &quot;&quot;) {
-		return &quot;a&quot;;
-	}
-	if ((length $thisletter) &gt; 1) {
-		($baseletter, $endletter) = $thisletter =~ /([a-z]+)([a-z])/;
-	} else {
-		$endletter = $thisletter;
-	}
-
-	if ($endletter eq &quot;z&quot;) {
-		return $thisletter.&quot;a&quot;;
-	} else {
-		return $baseletter.(++$endletter);
-	}
-}
+sub writer_ctest {
+    print &lt;&lt;'_____';
+/*
+ * Test file to check all DEF file symbols are present by trying
+ * to link to all of them. This is *not* intended to be run!
+ */
 
-#Check if a version is less than or equal to the current version. Its a fatal
-#error if not. They must also only differ in letters, or the last number (i.e.
-#the first two numbers must be the same)
-sub check_version_lte()
+int main()
 {
-	my ($testversion, $currversion) = @_;
-	my $lentv;
-	my $lencv;
-	my $cvbase;
+_____
 
-	my ($cvnums) = $currversion =~ /^(\d_\d_\d)[a-z]*$/;
-	my ($tvnums) = $testversion =~ /^(\d_\d_\d)[a-z]*$/;
-
-	#Die if we can't parse the version numbers or they don't look sane
-	die &quot;Invalid version number: $testversion and $currversion\n&quot;
-		if (!defined($cvnums) || !defined($tvnums)
-			|| length($cvnums) != 5
-			|| length($tvnums) != 5);
-
-	#If the base versions (without letters) don't match check they only differ
-	#in the last number
-	if ($cvnums ne $tvnums) {
-		die &quot;Invalid version number: $testversion &quot;
-			.&quot;for current version $currversion\n&quot;
-			if (substr($cvnums, 0, 4) ne substr($tvnums, 0, 4));
-		return;
-	}
-	#If we get here then the base version (i.e. the numbers) are the same - they
-	#only differ in the letters
-
-	$lentv = length $testversion;
-	$lencv = length $currversion;
-
-	#If the testversion has more letters than the current version then it must
-	#be later (or malformed)
-	if ($lentv &gt; $lencv) {
-		die &quot;Invalid version number: $testversion &quot;
-			.&quot;is greater than $currversion\n&quot;;
-	}
-
-	#Get the last letter from the current version
-	my ($cvletter) = $currversion =~ /([a-z])$/;
-	if (defined $cvletter) {
-		($cvbase) = $currversion =~ /(\d_\d_\d[a-z]*)$cvletter$/;
-	} else {
-		$cvbase = $currversion;
-	}
-	die &quot;Unable to parse version number $currversion&quot; if (!defined $cvbase);
-	my $tvbase;
-	my ($tvletter) = $testversion =~ /([a-z])$/;
-	if (defined $tvletter) {
-		($tvbase) = $testversion =~ /(\d_\d_\d[a-z]*)$tvletter$/;
-	} else {
-		$tvbase = $testversion;
-	}
-	die &quot;Unable to parse version number $testversion&quot; if (!defined $tvbase);
-
-	if ($lencv &gt; $lentv) {
-		#If current version has more letters than testversion then testversion
-		#minus the final letter must be a substring of the current version
-		die &quot;Invalid version number $testversion &quot;
-			.&quot;is greater than $currversion or is invalid\n&quot;
-			if (index($cvbase, $tvbase) != 0);
-	} else {
-		#If both versions have the same number of letters then they must be
-		#equal up to the last letter, and the last letter in testversion must
-		#be less than or equal to the last letter in current version.
-		die &quot;Invalid version number $testversion &quot;
-			.&quot;is greater than $currversion\n&quot;
-			if (($cvbase ne $tvbase) &amp;&amp; ($tvletter gt $cvletter));
-	}
+    for (@_) {
+        if ($_-&gt;type() eq 'VARIABLE') {
+            print &quot;\textern int &quot;, $_-&gt;name(), '; /* type unknown */ /* ', $_-&gt;number(), ' ', $_-&gt;version(), &quot; */\n&quot;;
+        } else {
+            print &quot;\textern int &quot;, $_-&gt;name(), '(); /* type unknown */ /* ', $_-&gt;number(), ' ', $_-&gt;version(), &quot; */\n&quot;;
+        }
+    }
+    print &lt;&lt;'_____';
 }
-
-sub do_deprecated()
-{
-	my ($decl, $plats, $algs) = @_;
-	$decl =~ /^\s*(DEPRECATEDIN_\d+_\d+_\d+)\s*\((.*)\)\s*$/
-            or die &quot;Bad DEPRECATEDIN: $decl\n&quot;;
-	my $info1 .= &quot;#INFO:&quot;;
-	$info1 .= join(',', @{$plats}) . &quot;:&quot;;
-	my $info2 = $info1;
-	$info1 .= join(',',@{$algs}, $1) . &quot;;&quot;;
-	$info2 .= join(',',@{$algs}) . &quot;;&quot;;
-	return $info1 . $2 . &quot;;&quot; . $info2;
+_____
 }
diff --git a/util/mknum.pl b/util/mknum.pl
new file mode 100644
index 0000000..a5f96b7
--- /dev/null
+++ b/util/mknum.pl
@@ -0,0 +1,125 @@
+
+#! /usr/bin/env perl
+# Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+use strict;
+use warnings;
+
+use Getopt::Long;
+use FindBin;
+use lib &quot;$FindBin::Bin/perl&quot;;
+
+use OpenSSL::Ordinals;
+use OpenSSL::ParseC;
+
+my $ordinals_file = undef;      # the ordinals file to use
+my $symhacks_file = undef;      # a symbol hacking file (optional)
+my $version = undef;            # the version to use for added symbols
+my $checkexist = 0;             # (unsure yet)
+my $warnings = 1;
+my $verbose = 0;
+my $debug = 0;
+
+GetOptions('ordinals=s' =&gt; \$ordinals_file,
+           'symhacks=s' =&gt; \$symhacks_file,
+           'version=s'  =&gt; \$version,
+           'exist'      =&gt; \$checkexist,
+           'warnings!'  =&gt; \$warnings,
+           'verbose'    =&gt; \$verbose,
+           'debug'      =&gt; \$debug)
+    or die &quot;Error in command line arguments\n&quot;;
+
+die &quot;Please supply ordinals file\n&quot;
+    unless $ordinals_file;
+
+my $ordinals = OpenSSL::Ordinals-&gt;new(from =&gt; $ordinals_file,
+                                      warnings =&gt; $warnings,
+                                      verbose =&gt; $verbose,
+                                      debug =&gt; $debug);
+$ordinals-&gt;set_version($version);
+
+my %orig_names = ();
+%orig_names = map { $_-&gt;name() =&gt; 1 }
+    $ordinals-&gt;items(comparator =&gt; sub { $_[0] cmp $_[1] },
+                     filter =&gt; sub { $_-&gt;exists() })
+    if $checkexist;
+
+# Invalidate all entries, they get revalidated when we re-check below
+$ordinals-&gt;invalidate();
+
+foreach my $f (($symhacks_file // (), @ARGV)) {
+    print STDERR $f,&quot; &quot;,&quot;-&quot; x (69 - length($f)),&quot;\n&quot; if $verbose;
+    open IN, $f || die &quot;Couldn't open $f: $!\n&quot;;
+    foreach (parse(&lt;IN&gt;, { filename =&gt; $f,
+                           warnings =&gt; $warnings,
+                           verbose =&gt; $verbose,
+                           debug =&gt; $debug })) {
+        $_-&gt;{value} = $_-&gt;{value}||&quot;&quot;;
+        next if grep { $_ eq 'CONST_STRICT' } @{$_-&gt;{conds}};
+        printf STDERR &quot;%s&gt; %s%s : %s\n&quot;,
+            $_-&gt;{type},
+            $_-&gt;{name},
+            ($_-&gt;{type} eq 'M' &amp;&amp; defined $symhacks_file &amp;&amp; $f eq $symhacks_file
+             ? ' = ' . $_-&gt;{value}
+             : ''),
+            join(', ', @{$_-&gt;{conds}})
+            if $verbose;
+        if ($_-&gt;{type} eq 'M'
+                &amp;&amp; defined $symhacks_file
+                &amp;&amp; $f eq $symhacks_file
+                &amp;&amp; $_-&gt;{value} =~ /^\w(?:\w|\d)*/) {
+            $ordinals-&gt;add_alias($_-&gt;{value}, $_-&gt;{name}, @{$_-&gt;{conds}});
+        } else {
+            next if $_-&gt;{returntype} =~ /\b(?:ossl_)inline/;
+            my $type = {
+                F =&gt; 'FUNCTION',
+                V =&gt; 'VARIABLE',
+            } -&gt; {$_-&gt;{type}};
+            if ($type) {
+                $ordinals-&gt;add($_-&gt;{name}, $type, @{$_-&gt;{conds}});
+            }
+        }
+    }
+    close IN;
+}
+
+if ($checkexist) {
+    my %new_names = map { $_-&gt;name() =&gt; 1 }
+        $ordinals-&gt;items(comparator =&gt; sub { $_[0] cmp $_[1] },
+                         filter =&gt; sub { $_-&gt;exists() });
+    # Eliminate common names
+    foreach (keys %orig_names) {
+        next unless exists $new_names{$_};
+        delete $orig_names{$_};
+        delete $new_names{$_};
+    }
+    if (%orig_names) {
+        print &quot;The following symbols do not seem to exist in code:\n&quot;;
+        foreach (sort keys %orig_names) {
+            print &quot;\t$_\n&quot;;
+        }
+    }
+    if (%new_names) {
+        print &quot;The following existing symbols are not in ordinals file:\n&quot;;
+        foreach (sort keys %new_names) {
+            print &quot;\t$_\n&quot;;
+        }
+    }
+} else {
+    $ordinals-&gt;rewrite();
+    my %stats = $ordinals-&gt;stats();
+    print STDERR
+        &quot;${ordinals_file}: $stats{modified} old symbols have updated info\n&quot;
+        if $stats{modified};
+    if ($stats{new}) {
+        print STDERR &quot;${ordinals_file}: Added $stats{new} new symbols\n&quot;;
+    } else {
+        print STDERR &quot;${ordinals_file}: No new symbols added\n&quot;;
+    }
+
+}
diff --git a/util/perl/OpenSSL/Ordinals.pm b/util/perl/OpenSSL/Ordinals.pm
new file mode 100644
index 0000000..07bdf81
--- /dev/null
+++ b/util/perl/OpenSSL/Ordinals.pm
@@ -0,0 +1,946 @@
+#! /usr/bin/env perl
+# Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+package OpenSSL::Ordinals;
+
+use strict;
+use warnings;
+use Carp;
+use Scalar::Util qw(blessed);
+
+use constant {
+    # &quot;magic&quot; filters, see the filters at the end of the file
+    F_NAME      =&gt; 1,
+    F_NUMBER    =&gt; 2,
+};
+
+=head1 NAME
+
+OpenSSL::Ordinals - a private module to read and walk through ordinals
+
+=head1 SYNOPSIS
+
+  use OpenSSL::Ordinals;
+
+  my $ordinals = OpenSSL::Ordinals-&gt;new(from =&gt; &quot;foo.num&quot;);
+  # or alternatively
+  my $ordinals = OpenSSL::Ordinals-&gt;new();
+  $ordinals-&gt;load(&quot;foo.num&quot;);
+
+  foreach ($ordinals-&gt;items(comparator =&gt; by_name()) {
+    print $_-&gt;name(), &quot;\n&quot;;
+  }
+
+=head1 DESCRIPTION
+
+This is a OpenSSL private module to load an ordinals (F&lt;.num&gt;) file and
+write out the data you want, sorted and filtered according to your rules.
+
+An ordinals file is a file that enumerates all the symbols that a shared
+library or loadable module must export.  Each of them have a unique
+assigned number as well as other attributes to indicate if they only exist
+on a subset of the supported platforms, or if they are specific to certain
+features.
+
+The unique numbers each symbol gets assigned needs to be maintained for a
+shared library or module to stay compatible with previous versions on
+platforms that maintain a transfer vector indexed by position rather than
+by name.  They also help keep information on certain symbols that are
+aliases for others for certain platforms, or that have different forms
+on different platforms.
+
+=head2 Main methods
+
+=over  4
+
+=cut
+
+=item B&lt;new&gt; I&lt;%options&gt;
+
+Creates a new instance of the C&lt;OpenSSL::Ordinals&gt; class.  It takes options
+in keyed pair form, i.e. a series of C&lt;key =E&lt;gt&gt; value&gt; pairs.  Available
+options are:
+
+=over 4
+
+=item B&lt;from =E&lt;gt&gt; FILENAME&gt;
+
+Not only create a new instance, but immediately load it with data from the
+ordinals file FILENAME.
+
+=back
+
+=cut
+
+sub new {
+    my $class = shift;
+    my %opts = @_;
+
+    my $instance = {
+        filename        =&gt; undef, # File name registered when loading
+        loaded_maxnum   =&gt; 0,     # Highest allocated item number when loading
+        loaded_contents =&gt; [],    # Loaded items, if loading there was
+        maxnum          =&gt; 0,     # Current highest allocated item number
+        contents        =&gt; [],    # Items, indexed by number
+        name2num        =&gt; {},    # Name to number dictionary
+        aliases         =&gt; {},    # Aliases cache.
+        stats           =&gt; {},    # Statistics, see 'sub validate'
+        currversion     =&gt; $opts{version} // '*', # '*' is for &quot;we don't care&quot;
+        debug           =&gt; $opts{debug},
+    };
+    bless $instance, $class;
+
+    $instance-&gt;load($opts{from}) if defined($opts{from});
+
+    return $instance;
+}
+
+=item B&lt;$ordinals-E&lt;gt&gt;load FILENAME&gt;
+
+Loads the data from FILENAME into the instance.  Any previously loaded data
+is dropped.
+
+Two internal databases are created.  One database is simply a copy of the file
+contents and is treated as read-only.  The other database is an exact copy of
+the first, but is treated as a work database, i.e. it can be modified and added
+to.
+
+=cut
+
+sub load {
+    my $self = shift;
+    my $filename = shift;
+
+    croak &quot;Undefined filename&quot; unless defined($filename);
+
+    my @tmp_contents = ();
+    my %tmp_name2num = ();
+    my $max_num = 0;
+    open F, '&lt;', $filename or croak &quot;Unable to open $filename&quot;;
+    while (&lt;F&gt;) {
+        s|\R$||;                # Better chomp
+        s|#.*||;
+        next if /^\s*$/;
+
+        my $item = OpenSSL::Ordinals::Item-&gt;new(from =&gt; $_);
+
+        my $num = $item-&gt;number();
+        croak &quot;Disordered ordinals, $num &lt; $max_num&quot;
+            if $num &lt; $max_num;
+        $max_num = $num;
+
+        push @{$tmp_contents[$item-&gt;number()]}, $item;
+        $tmp_name2num{$item-&gt;name()} = $item-&gt;number();
+    }
+    close F;
+
+    $self-&gt;{contents} = [ @tmp_contents ];
+    $self-&gt;{name2num} = { %tmp_name2num };
+    $self-&gt;{maxnum} = $max_num;
+    $self-&gt;{filename} = $filename;
+
+    # Make a deep copy, allowing {contents} to be an independent work array
+    foreach my $i (1..$max_num) {
+        if ($tmp_contents[$i]) {
+            $self-&gt;{loaded_contents}-&gt;[$i] =
+                [ map { OpenSSL::Ordinals::Item-&gt;new($_) }
+                  @{$tmp_contents[$i]} ];
+        }
+    }
+    $self-&gt;{loaded_maxnum} = $max_num;
+    return 1;
+}
+
+=item B&lt;$ordinals-E&lt;gt&gt;rewrite&gt;
+
+If an ordinals file has been loaded, it gets rewritten with the data from
+the current work database.
+
+=cut
+
+sub rewrite {
+    my $self = shift;
+
+    $self-&gt;write($self-&gt;{filename});
+}
+
+=item B&lt;$ordinals-E&lt;gt&gt;write FILENAME&gt;
+
+Writes the current work database data to the ordinals file FILENAME.
+This also validates the data, see B&lt;$ordinals-E&lt;gt&gt;validate&gt; below.
+
+=cut
+
+sub write {
+    my $self = shift;
+    my $filename = shift;
+
+    croak &quot;Undefined filename&quot; unless defined($filename);
+
+    $self-&gt;validate();
+
+    open F, '&gt;', $filename or croak &quot;Unable to open $filename&quot;;
+    foreach ($self-&gt;items(by =&gt; by_number())) {
+        print F $_-&gt;to_string(),&quot;\n&quot;;
+    }
+    close F;
+    $self-&gt;{filename} = $filename;
+    $self-&gt;{loaded_maxnum} = $self-&gt;{maxnum};
+    return 1;
+}
+
+=item B&lt;$ordinals-E&lt;gt&gt;items&gt; I&lt;%options&gt;
+
+Returns a list of items according to a set of criteria.  The criteria is
+given in form keyed pair form, i.e. a series of C&lt;key =E&lt;gt&gt; value&gt; pairs.
+Available options are:
+
+=over 4
+
+=item B&lt;sort =E&lt;gt&gt; SORTFUNCTION&gt;
+
+SORTFUNCTION is a reference to a function that takes two arguments, which
+correspond to the classic C&lt;$a&gt; and C&lt;$b&gt; that are available in a C&lt;sort&gt;
+block.
+
+=item B&lt;filter =E&lt;gt&gt; FILTERFUNCTION&gt;
+
+FILTERFUNTION is a reference to a function that takes one argument, which
+is every OpenSSL::Ordinals::Item element available.
+
+=back
+
+=cut
+
+sub items {
+    my $self = shift;
+    my %opts = @_;
+
+    my $comparator = $opts{sort};
+    my $filter = $opts{filter} // sub { 1; };
+
+    my @l = undef;
+    if (ref($filter) eq 'ARRAY') {
+        # run a &quot;magic&quot; filter
+        if    ($filter-&gt;[0] == F_NUMBER) {
+            my $index = $filter-&gt;[1];
+            @l = $index ? @{$self-&gt;{contents}-&gt;[$index] // []} : ();
+        } elsif ($filter-&gt;[0] == F_NAME) {
+            my $index = $self-&gt;{name2num}-&gt;{$filter-&gt;[1]};
+            @l = $index ? @{$self-&gt;{contents}-&gt;[$index] // []} : ();
+        } else {
+            croak __PACKAGE__.&quot;-&gt;items called with invalid filter&quot;;
+        }
+    } elsif (ref($filter) eq 'CODE') {
+        @l = grep { $filter-&gt;($_) }
+            map { @{$_ // []} }
+            @{$self-&gt;{contents}};
+    } else {
+        croak __PACKAGE__.&quot;-&gt;items called with invalid filter&quot;;
+    }
+
+    return sort { $comparator-&gt;($a, $b); } @l
+        if (defined $comparator);
+    return @l;
+}
+
+# Put an array of items back into the object after having checked consistency
+# If there are exactly two items:
+# - They MUST have the same number
+# - For platforms, both MUST hold the same ones, but with opposite values
+# - For features, both MUST hold the same ones.
+# If there's just one item, just put it in the slot of its number
+# In all other cases, something is wrong
+sub _putback {
+    my $self = shift;
+    my @items = @_;
+
+    if (scalar @items &lt; 1 || scalar @items &gt; 2) {
+        croak &quot;Wrong number of items: &quot;, scalar @items, &quot; : &quot;,
+            join(&quot;, &quot;, map { $_-&gt;name() } @items), &quot;\n&quot;;
+    }
+    if (scalar @items == 2) {
+        # Collect some data
+        my %numbers = ();
+        my %versions = ();
+        my %features = ();
+        foreach (@items) {
+            $numbers{$_-&gt;number()} = 1;
+            $versions{$_-&gt;version()} = 1;
+            foreach ($_-&gt;features()) {
+                $features{$_}++;
+            }
+        }
+
+        # Check that all items we're trying to put back have the same number
+        croak &quot;Items don't have the same numeral: &quot;,
+            join(&quot;, &quot;, map { $_-&gt;name().&quot; =&gt; &quot;.$_-&gt;number() } @items), &quot;\n&quot;
+            if (scalar keys %numbers &gt; 1);
+        croak &quot;Items don't have the same version: &quot;,
+            join(&quot;, &quot;, map { $_-&gt;name().&quot; =&gt; &quot;.$_-&gt;version() } @items), &quot;\n&quot;
+            if (scalar keys %versions &gt; 1);
+
+        # Check that both items run with the same features
+        foreach (@items) {
+        }
+        foreach (keys %features) {
+            delete $features{$_} if $features{$_} == 2;
+        }
+        croak &quot;Features not in common between &quot;,
+            $items[0]-&gt;name(), &quot; and &quot;, $items[1]-&gt;name(), &quot;:&quot;,
+            join(&quot;, &quot;, sort keys %features), &quot;\n&quot;
+            if %features;
+
+        # Check that all platforms exist in both items, and have opposite values
+        my @platforms = ( { $items[0]-&gt;platforms() },
+                          { $items[1]-&gt;platforms() } );
+        foreach my $platform (keys %{$platforms[0]}) {
+            if (exists $platforms[1]-&gt;{$platform}) {
+                if ($platforms[0]-&gt;{$platform} != !$platforms[1]-&gt;{$platform}) {
+                    croak &quot;Platforms aren't opposite: &quot;,
+                        join(&quot;, &quot;,
+                             map { my %tmp_h = $_-&gt;platforms();
+                                   $_-&gt;name().&quot;:&quot;.$platform
+                                       .&quot; =&gt; &quot;
+                                       .$tmp_h{$platform} } @items),
+                        &quot;\n&quot;;
+                }
+
+                # We're done with these
+                delete $platforms[0]-&gt;{$platform};
+                delete $platforms[1]-&gt;{$platform};
+            }
+        }
+        # If there are any remaining platforms, something's wrong
+        if (%{$platforms[0]} || %{$platforms[0]}) {
+            croak &quot;There are platforms not in common between &quot;,
+                $items[0]-&gt;name(), &quot; and &quot;, $items[1]-&gt;name(), &quot;\n&quot;;
+        }
+    }
+    $self-&gt;{contents}-&gt;[$items[0]-&gt;number()] = [ @items ];
+}
+
+sub _parse_platforms {
+    my $self = shift;
+    my @defs = @_;
+
+    my %platforms = ();
+    foreach (@defs) {
+        m{^(!)?};
+        my $op = !(defined $1 &amp;&amp; $1 eq '!');
+        my $def = $';
+
+        if ($def =~ m{^_?WIN32$})                   { $platforms{$&amp;} = $op; }
+        if ($def =~ m{^__FreeBSD__$})               { $platforms{$&amp;} = $op; }
+# For future support
+#       if ($def =~ m{^__DragonFly__$})             { $platforms{$&amp;} = $op; }
+#       if ($def =~ m{^__OpenBSD__$})               { $platforms{$&amp;} = $op; }
+#       if ($def =~ m{^__NetBSD__$})                { $platforms{$&amp;} = $op; }
+        if ($def =~
+            m{^OPENSSL_(EXPORT_VAR_AS_FUNCTION)$})  { $platforms{$1} = $op; }
+        if ($def =~ m{^OPENSSL_SYS_})               { $platforms{$'} = $op; }
+    }
+
+    return %platforms;
+}
+
+sub _parse_features {
+    my $self = shift;
+    my @defs = @_;
+
+    my %features = ();
+    foreach (@defs) {
+        m{^(!)?};
+        my $op = !(defined $1 &amp;&amp; $1 eq '!');
+        my $def = $';
+
+        if ($def =~ m{^ZLIB$})                      { $features{$&amp;} =  $op; }
+        if ($def =~ m{^OPENSSL_USE_})               { $features{$'} =  $op; }
+        if ($def =~ m{^OPENSSL_NO_})                { $features{$'} = !$op; }
+        if ($def =~ m{^DEPRECATEDIN_(.*)$})         { $features{$&amp;} = !$op; }
+    }
+
+    return %features;
+}
+
+=item B&lt;$ordinals-E&lt;gt&gt;add NAME, TYPE, LIST&gt;
+
+Adds a new item named NAME with the type TYPE, and a set of C macros in
+LIST that are expected to be defined or undefined to use this symbol, if
+any.  For undefined macros, they each must be prefixed with a C&lt;!&gt;.
+
+If this symbol already exists in loaded data, it will be rewritten using
+the new input data, but will keep the same ordinal number and version.
+If it's entirely new, it will get a new number and the current default
+version.  The new ordinal number is a simple increment from the last
+maximum number.
+
+=cut
+
+sub add {
+    my $self = shift;
+    my $name = shift;
+    my $type = shift;           # FUNCTION or VARIABLE
+    my @defs = @_;              # Macros from #ifdef and #ifndef
+                                # (the latter prefixed with a '!')
+
+    # call signature for debug output
+    my $verbsig = &quot;add('$name' , '$type' , [ &quot; . join(', ', @defs) . &quot; ])&quot;;
+
+    croak __PACKAGE__.&quot;-&gt;add got a bad type '$type'&quot;
+        unless $type eq 'FUNCTION' || $type eq 'VARIABLE';
+
+    my %platforms = _parse_platforms(@defs);
+    my %features = _parse_features(@defs);
+
+    my @items = $self-&gt;items(filter =&gt; f_name($name));
+    my $version = @items ? $items[0]-&gt;version() : $self-&gt;{currversion};
+    my $number = @items ? $items[0]-&gt;number() : ++$self-&gt;{maxnum};
+    print STDERR &quot;DEBUG[&quot;,__PACKAGE__,&quot;:add] $verbsig\n&quot;,
+        @items ? map { &quot;\t&quot;.$_-&gt;to_string().&quot;\n&quot; } @items : &quot;No previous items\n&quot;,
+        if $self-&gt;{debug};
+    @items = grep { $_-&gt;exists() } @items;
+
+    my $new_item =
+        OpenSSL::Ordinals::Item-&gt;new( name          =&gt; $name,
+                                      type          =&gt; $type,
+                                      number        =&gt; $number,
+                                      version       =&gt; $version,
+                                      exists        =&gt; 1,
+                                      platforms     =&gt; { %platforms },
+                                      features      =&gt; [
+                                          grep { $features{$_} } keys %features
+                                      ] );
+
+    push @items, $new_item;
+    print STDERR &quot;DEBUG[&quot;,__PACKAGE__,&quot;::add] $verbsig\n&quot;, map { &quot;\t&quot;.$_-&gt;to_string().&quot;\n&quot; } @items
+        if $self-&gt;{debug};
+    $self-&gt;_putback(@items);
+
+    # If an alias was defined beforehand, add an item for it now
+    my $alias = $self-&gt;{aliases}-&gt;{$name};
+    delete $self-&gt;{aliases}-&gt;{$name};
+
+    # For the caller to show
+    my @returns = ( $new_item );
+    push @returns, $self-&gt;add_alias($alias-&gt;{name}, $name, @{$alias-&gt;{defs}})
+        if defined $alias;
+    return @returns;
+}
+
+=item B&lt;$ordinals-E&lt;gt&gt;add_alias ALIAS, NAME, LIST&gt;
+
+Adds an alias ALIAS for the symbol NAME, and a set of C macros in LIST
+that are expected to be defined or undefined to use this symbol, if any.
+For undefined macros, they each must be prefixed with a C&lt;!&gt;.
+
+If this symbol already exists in loaded data, it will be rewritten using
+the new input data.  Otherwise, the data will just be store away, to wait
+that the symbol NAME shows up.
+
+=cut
+
+sub add_alias {
+    my $self = shift;
+    my $alias = shift;          # This is the alias being added
+    my $name  = shift;          # For this name (assuming it exists)
+    my @defs = @_;              # Platform attributes for the alias
+
+    # call signature for debug output
+    my $verbsig =
+        &quot;add_alias('$alias' , '$name' , [ &quot; . join(', ', @defs) . &quot; ])&quot;;
+
+    croak &quot;You're kidding me...&quot; if $alias eq $name;
+
+    my %platforms = _parse_platforms(@defs);
+    my %features = _parse_features(@defs);
+
+    croak &quot;Alias with associated features is forbidden\n&quot;
+        if %features;
+
+    my $f_byalias = f_name($alias);
+    my $f_byname = f_name($name);
+    my @items = $self-&gt;items(filter =&gt; $f_byalias);
+    foreach my $item ($self-&gt;items(filter =&gt; $f_byname)) {
+        push @items, $item unless grep { $_ == $item } @items;
+    }
+    @items = grep { $_-&gt;exists() } @items;
+
+    croak &quot;Alias already exists ($alias =&gt; $name)&quot;
+        if scalar @items &gt; 1;
+    if (scalar @items == 0) {
+        # The item we want to alias for doesn't exist yet, so we cache the
+        # alias and hope the item we're making an alias of shows up later
+        $self-&gt;{aliases}-&gt;{$name} = { name =&gt; $alias, defs =&gt; [ @defs ] };
+
+        print STDERR &quot;DEBUG[&quot;,__PACKAGE__,&quot;:add_alias] $verbsig\n&quot;,
+            &quot;\tSet future alias $alias =&gt; $name\n&quot;
+            if $self-&gt;{debug};
+        return ();
+    } elsif (scalar @items == 1) {
+        # The rule is that an alias is more or less a copy of the original
+        # item, just with another name.  Also, the platforms given here are
+        # given to the original item as well, with opposite values.
+        my %alias_platforms = $items[0]-&gt;platforms();
+        foreach (keys %platforms) {
+            $alias_platforms{$_} = !$platforms{$_};
+        }
+        # We supposedly do now know how to do this...  *ahem*
+        $items[0]-&gt;{platforms} = { %alias_platforms };
+
+        my $alias_item = OpenSSL::Ordinals::Item-&gt;new(
+            name          =&gt; $alias,
+            type          =&gt; $items[0]-&gt;type(),
+            number        =&gt; $items[0]-&gt;number(),
+            version       =&gt; $items[0]-&gt;version(),
+            exists        =&gt; $items[0]-&gt;exists(),
+            platforms     =&gt; { %platforms },
+            features      =&gt; [ $items[0]-&gt;features() ]
+           );
+        push @items, $alias_item;
+
+        print STDERR &quot;DEBUG[&quot;,__PACKAGE__,&quot;:add_alias] $verbsig\n&quot;,
+            map { &quot;\t&quot;.$_-&gt;to_string().&quot;\n&quot; } @items
+            if $self-&gt;{debug};
+        $self-&gt;_putback(@items);
+
+        # For the caller to show
+        return ( $alias_item-&gt;to_string() );
+    }
+    croak &quot;$name has an alias already (trying to add alias $alias)\n&quot;,
+        &quot;\t&quot;, join(&quot;, &quot;, map { $_-&gt;name() } @items), &quot;\n&quot;;
+}
+
+=item B&lt;$ordinals-E&lt;gt&gt;set_version VERSION&gt;
+
+Sets the default version for new symbol to VERSION.
+
+=cut
+
+sub set_version {
+    my $self = shift;
+    my $version = shift;
+
+    $version //= '*';
+    $version =~ s|-.*||g;
+    $version =~ s|\.|_|g;
+    $self-&gt;{currversion} = $version;
+    foreach ($self-&gt;items(filter =&gt; sub { $_[0] eq '*' })) {
+        $_-&gt;{version} = $self-&gt;{currversion};
+    }
+    return 1;
+}
+
+=item B&lt;$ordinals-E&lt;gt&gt;invalidate&gt;
+
+Invalidates the whole working database.  The practical effect is that all
+symbols are set to not exist, but are kept around in the database to retain
+ordinal numbers and versions.
+
+=cut
+
+sub invalidate {
+    my $self = shift;
+
+    foreach (@{$self-&gt;{contents}}) {
+        foreach (@{$_ // []}) {
+            $_-&gt;{exists} = 0;
+        }
+    }
+    $self-&gt;{stats} = {};
+}
+
+=item B&lt;$ordinals-E&lt;gt&gt;validate&gt;
+
+Validates the current working database by collection statistics on how many
+symbols were added and how many were changed.  These numbers can be retrieved
+with B&lt;$ordinals-E&lt;gt&gt;stats&gt;.
+
+=cut
+
+sub validate {
+    my $self = shift;
+
+    $self-&gt;{stats} = {};
+    for my $i (1..$self-&gt;{maxnum}) {
+        if ($i &gt; $self-&gt;{loaded_maxnum}
+                || (!@{$self-&gt;{loaded_contents}-&gt;[$i] // []}
+                    &amp;&amp; @{$self-&gt;{contents}-&gt;[$i] // []})) {
+            $self-&gt;{stats}-&gt;{new}++;
+        }
+        next if ($i &gt; $self-&gt;{loaded_maxnum});
+
+        my @loaded_strings =
+            map { $_-&gt;to_string() } @{$self-&gt;{loaded_contents}-&gt;[$i] // []};
+        my @current_strings =
+            map { $_-&gt;to_string() } @{$self-&gt;{contents}-&gt;[$i] // []};
+
+        foreach my $str (@current_strings) {
+            @loaded_strings = grep { $str ne $_ } @loaded_strings;
+        }
+        if (@loaded_strings) {
+            $self-&gt;{stats}-&gt;{modified}++;
+        }
+    }
+}
+
+=item B&lt;$ordinals-E&lt;gt&gt;stats&gt;
+
+Returns the statistics that B&lt;validate&gt; calculate.
+
+=cut
+
+sub stats {
+    my $self = shift;
+
+    return %{$self-&gt;{stats}};
+}
+
+=back
+
+=head2 Data elements
+
+Data elements, which is each line in an ordinals file, are instances
+of a separate class, OpenSSL::Ordinals::Item, with its own methods:
+
+=over 4
+
+=cut
+
+package OpenSSL::Ordinals::Item;
+
+use strict;
+use warnings;
+use Carp;
+
+=item B&lt;new&gt; I&lt;%options&gt;
+
+Creates a new instance of the C&lt;OpenSSL::Ordinals::Item&gt; class.  It takes
+options in keyed pair form, i.e. a series of C&lt;key =E&lt;gt&gt; value&gt; pairs.
+Available options are:
+
+=over 4
+
+=item B&lt;from =E&lt;gt&gt; STRING&gt;
+
+This will create a new item, filled with data coming from STRING.
+
+STRING must conform to the following EBNF description:
+
+  ordinal string = symbol, spaces, ordinal, spaces, version, spaces,
+                   exist, &quot;:&quot;, platforms, &quot;:&quot;, type, &quot;:&quot;, features;
+  spaces         = space, { space };
+  space          = &quot; &quot; | &quot;\t&quot;;
+  symbol         = ( letter | &quot;_&quot;), { letter | digit | &quot;_&quot; };
+  ordinal        = number;
+  version        = number, &quot;_&quot;, number, &quot;_&quot;, number, letter, [ letter ];
+  exist          = &quot;EXIST&quot; | &quot;NOEXIST&quot;;
+  platforms      = platform, { &quot;,&quot;, platform };
+  platform       = ( letter | &quot;_&quot; ) { letter | digit | &quot;_&quot; };
+  type           = &quot;FUNCTION&quot; | &quot;VARIABLE&quot;;
+  features       = feature, { &quot;,&quot;, feature };
+  feature        = ( letter | &quot;_&quot; ) { letter | digit | &quot;_&quot; };
+  number         = digit, { digit };
+
+(C&lt;letter&gt; and C&lt;digit&gt; are assumed self evident)
+
+=item B&lt;name =E&lt;gt&gt; STRING&gt;, B&lt;number =E&lt;gt&gt; NUMBER&gt;, B&lt;version =E&lt;gt&gt; STRING&gt;,
+      B&lt;exists =E&lt;gt&gt; BOOLEAN&gt;, B&lt;type =E&lt;gt&gt; STRING&gt;,
+      B&lt;platforms =E&lt;gt&gt; HASHref&gt;, B&lt;features =E&lt;gt&gt; LISTref&gt;
+
+This will create a new item with data coming from the arguments.
+
+=back
+
+=cut
+
+sub new {
+    my $class = shift;
+
+    if (ref($_[0]) eq $class) {
+        return $class-&gt;new( map { $_ =&gt; $_[0]-&gt;{$_} } keys %{$_[0]} );
+    }
+
+    my %opts = @_;
+
+    croak &quot;No argument given&quot; unless %opts;
+
+    my $instance = undef;
+    if ($opts{from}) {
+        my @a = split /\s+/, $opts{from};
+
+        croak &quot;Badly formatted ordinals string: $opts{from}&quot;
+            unless ( scalar @a == 4
+                     &amp;&amp; $a[0] =~ /^[A-Za-z_][A-Za-z_0-9]*$/
+                     &amp;&amp; $a[1] =~ /^\d+$/
+                     &amp;&amp; $a[2] =~ /^(?:\*|\d+_\d+_\d+(?:[a-z]{0,2}))$/
+                     &amp;&amp; $a[3] =~ /^
+                                  (?:NO)?EXIST:
+                                  [^:]*:
+                                  (?:FUNCTION|VARIABLE):
+                                  [^:]*
+                                  $
+                                 /x );
+
+        my @b = split /:/, $a[3];
+        %opts = ( name          =&gt; $a[0],
+                  number        =&gt; $a[1],
+                  version       =&gt; $a[2],
+                  exists        =&gt; $b[0] eq 'EXIST',
+                  platforms     =&gt; { map { m|^(!)?|; $' =&gt; !$1 }
+                                         split /,/,$b[1] },
+                  type          =&gt; $b[2],
+                  features      =&gt; [ split /,/,$b[3] // '' ] );
+    }
+
+    if ($opts{name} &amp;&amp; $opts{version} &amp;&amp; defined $opts{exists} &amp;&amp; $opts{type}
+            &amp;&amp; ref($opts{platforms} // {}) eq 'HASH'
+            &amp;&amp; ref($opts{features} // []) eq 'ARRAY') {
+        $instance = { name      =&gt; $opts{name},
+                      type      =&gt; $opts{type},
+                      number    =&gt; $opts{number},
+                      version   =&gt; $opts{version},
+                      exists    =&gt; !!$opts{exists},
+                      platforms =&gt; { %{$opts{platforms} // {}} },
+                      features  =&gt; [ sort @{$opts{features} // []} ] };
+    } else {
+        croak __PACKAGE__.&quot;-&gt;new() called with bad arguments\n&quot;.
+            join(&quot;&quot;, map { &quot;    $_\t=&gt; &quot;.$opts{$_}.&quot;\n&quot; } sort keys %opts);
+    }
+
+    return bless $instance, $class;
+}
+
+sub DESTROY {
+}
+
+=item B&lt;$item-E&lt;gt&gt;name&gt;
+
+The symbol name for this item.
+
+=item B&lt;$item-E&lt;gt&gt;number&gt;
+
+The positional number for this item.
+
+=item B&lt;$item-E&lt;gt&gt;version&gt;
+
+The version number for this item.  Please note that these version numbers
+have underscore (C&lt;_&gt;) as a separator the the version parts.
+
+=item B&lt;$item-E&lt;gt&gt;exists&gt;
+
+A boolean that tells if this symbol exists in code or not.
+
+=item B&lt;$item-E&lt;gt&gt;platforms&gt;
+
+A hash table reference.  The keys of the hash table are the names of
+the specified platforms, with a value of 0 to indicate that this symbol
+isn't available on that platform, and 1 to indicate that it is.  Platforms
+that aren't mentioned default to 1.
+
+=item B&lt;$item-E&lt;gt&gt;type&gt;
+
+C&lt;FUNCTION&gt; or C&lt;VARIABLE&gt;, depending on what the symbol represents.
+Some platforms do not care about this, others do.
+
+=item B&lt;$item-E&lt;gt&gt;features&gt;
+
+An array reference, where every item indicates a feature where this symbol
+is available.  If no features are mentioned, the symbol is always available.
+If any feature is mentioned, this symbol is I&lt;only&gt; available when those
+features are enabled.
+
+=cut
+
+our $AUTOLOAD;
+
+# Generic getter
+sub AUTOLOAD {
+    my $self = shift;
+    my $funcname = $AUTOLOAD;
+    (my $item = $funcname) =~ s|.*::||g;
+
+    croak &quot;$funcname called as setter&quot; if @_;
+    croak &quot;$funcname invalid&quot; unless exists $self-&gt;{$item};
+    return $self-&gt;{$item} if ref($self-&gt;{$item}) eq '';
+    return @{$self-&gt;{$item}} if ref($self-&gt;{$item}) eq 'ARRAY';
+    return %{$self-&gt;{$item}} if ref($self-&gt;{$item}) eq 'HASH';
+}
+
+=item B&lt;$item-E&lt;gt&gt;to_string&gt;
+
+Converts the item to a string that can be saved in an ordinals file.
+
+=cut
+
+sub to_string {
+    my $self = shift;
+
+    croak &quot;Too many arguments&quot; if @_;
+    my %platforms = $self-&gt;platforms();
+    my @features = $self-&gt;features();
+    return sprintf &quot;%-39s %d\t%s\t%s:%s:%s:%s&quot;,
+        $self-&gt;name(),
+        $self-&gt;number(),
+        $self-&gt;version(),
+        $self-&gt;exists() ? 'EXIST' : 'NOEXIST',
+        join(',', (map { ($platforms{$_} ? '' : '!') . $_ }
+                   sort keys %platforms)),
+        $self-&gt;type(),
+        join(',', @features);
+}
+
+=back
+
+=head2 Comparators and filters
+
+For the B&lt;$ordinals-E&lt;gt&gt;items&gt; method, there are a few functions to create
+comparators based on specific data:
+
+=over 4
+
+=cut
+
+# Go back to the main package to create comparators and filters
+package OpenSSL::Ordinals;
+
+# Comparators...
+
+=item B&lt;by_name&gt;
+
+Returns a comparator that will compare the names of two OpenSSL::Ordinals::Item
+objects.
+
+=cut
+
+sub by_name {
+    return sub { $_[0]-&gt;name() cmp $_[1]-&gt;name() };
+}
+
+=item B&lt;by_number&gt;
+
+Returns a comparator that will compare the ordinal numbers of two
+OpenSSL::Ordinals::Item objects.
+
+=cut
+
+sub by_number {
+    return sub { $_[0]-&gt;number() &lt;=&gt; $_[1]-&gt;number() };
+}
+
+=item B&lt;by_version&gt;
+
+Returns a comparator that will compare the version of two
+OpenSSL::Ordinals::Item objects.
+
+=cut
+
+sub by_version {
+    sub _ossl_versionsplit {
+        my $textversion = shift;
+        return $textversion if $textversion eq '*';
+        my ($major,$minor,$edit,$patch) =
+            $textversion =~ /^(\d+)_(\d+)_(\d+)([a-z]{0,2})$/;
+        return ($major,$minor,$edit,$patch);
+    }
+
+    return sub {
+        my @a_split = _ossl_versionsplit($_[0]-&gt;version());
+        my @b_split = _ossl_versionsplit($_[1]-&gt;version());
+        my $verdict = 0;
+        while (@a_split) {
+            # The last part is a letter sequence (or a '*')
+            if (scalar @a_split == 1) {
+                $verdict = $a_split[0] cmp $b_split[0];
+            } else {
+                $verdict = $a_split[0] &lt;=&gt; $b_split[0];
+            }
+            shift @a_split;
+            shift @b_split;
+            last unless $verdict == 0;
+        }
+        $verdict;
+    };
+}
+
+=back
+
+There are also the following filters:
+
+=over 4
+
+=cut
+
+# Filters...  these are called by grep, the return sub must use $_ for
+# the item to check
+
+=item B&lt;f_version VERSION&gt;
+
+Returns a filter that only lets through symbols with a version number
+matching B&lt;VERSION&gt;.
+
+=cut
+
+sub f_version {
+    my $version = shift;
+
+    $version =~ s|\.|_|g if $version;
+    croak &quot;No version specified&quot;
+        unless $version &amp;&amp; $version =~ /^\d_\d_\d[a-z]{0,2}$/;
+
+    return sub { $_[0]-&gt;version() eq $version };
+}
+
+=item B&lt;f_number NUMBER&gt;
+
+Returns a filter that only lets through symbols with the ordinal number
+matching B&lt;NUMBER&gt;.
+
+NOTE that this returns a &quot;magic&quot; value that can not be used as a function.
+It's only useful when passed directly as a filter to B&lt;items&gt;.
+
+=cut
+
+sub f_number {
+    my $number = shift;
+
+    croak &quot;No number specified&quot;
+        unless $number &amp;&amp; $number =~ /^\d+$/;
+
+    return [ F_NUMBER, $number ];
+}
+
+
+=item B&lt;f_name NAME&gt;
+
+Returns a filter that only lets through symbols with the symbol name
+matching B&lt;NAME&gt;.
+
+NOTE that this returns a &quot;magic&quot; value that can not be used as a function.
+It's only useful when passed directly as a filter to B&lt;items&gt;.
+
+=cut
+
+sub f_name {
+    my $name = shift;
+
+    croak &quot;No name specified&quot;
+        unless $name;
+
+    return [ F_NAME, $name ];
+}
+
+=back
+
+=head1 AUTHORS
+
+Richard Levitte E&lt;lt&gt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.orgE</A>&lt;gt&gt;.
+
+=cut
+
+1;
diff --git a/util/perl/OpenSSL/ParseC.pm b/util/perl/OpenSSL/ParseC.pm
new file mode 100644
index 0000000..ba2427c
--- /dev/null
+++ b/util/perl/OpenSSL/ParseC.pm
@@ -0,0 +1,1129 @@
+#! /usr/bin/env perl
+# Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+package OpenSSL::ParseC;
+
+use strict;
+use warnings;
+
+use Exporter;
+use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
+$VERSION = &quot;0.9&quot;;
<A HREF="../../../mailman/listinfo/openssl-commits.html">+ at ISA</A> = qw(Exporter);
<A HREF="../../../mailman/listinfo/openssl-commits.html">+ at EXPORT</A> = qw(parse);
+
+# Global handler data
+my @preprocessor_conds;         # A list of simple preprocessor conditions,
+                                # each item being a list of macros defined
+                                # or not defined.
+
+# Handler helpers
+sub all_conds {
+    return map { ( @$_ ) } @preprocessor_conds;
+}
+
+# A list of handlers that will look at a &quot;complete&quot; string and try to
+# figure out what to make of it.
+# Each handler is a hash with the following keys:
+#
+# regexp                a regexp to compare the &quot;complete&quot; string with.
+# checker               a function that does a more complex comparison.
+#                       Use this instead of regexp if that isn't enough.
+# massager              massages the &quot;complete&quot; string into an array with
+#                       the following elements:
+#
+#                       [0]     String that needs further processing (this
+#                               applies to typedefs of structs), or empty.
+#                       [1]     The name of what was found.
+#                       [2]     A character that denotes what type of thing
+#                               this is: 'F' for function, 'S' for struct,
+#                               'T' for typedef, 'M' for macro, 'V' for
+#                               variable.
+#                       [3]     Return type (only for type 'F' and 'V')
+#                       [4]     Value (for type 'M') or signature (for type 'F',
+#                               'V', 'T' or 'S')
+#                       [5...]  The list of preprocessor conditions this is
+#                               found in, as in checks for macro definitions
+#                               (stored as the macro's name) or the absence
+#                               of definition (stored as the macro's name
+#                               prefixed with a '!'
+#
+#                       If the massager returns an empty list, it means the
+#                       &quot;complete&quot; string has side effects but should otherwise
+#                       be ignored.
+#                       If the massager is undefined, the &quot;complete&quot; string
+#                       should be ignored.
+my @opensslcpphandlers = (
+    ##################################################################
+    # OpenSSL CPP specials
+    #
+    # These are used to convert certain pre-precessor expressions into
+    # others that @cpphandlers have a better chance to understand.
+
+    { regexp   =&gt; qr/#if OPENSSL_API_COMPAT(\S+)(0x[0-9a-fA-F]{8})L$/,
+      massager =&gt; sub {
+          my $op = $1;
+          my $v = hex($2);
+          if ($op ne '&lt;' &amp;&amp; $op ne '&gt;=') {
+              die &quot;Error: unacceptable operator $op: $_[0]\n&quot;;
+          }
+          my ($one, $major, $minor) =
+              ( ($v &gt;&gt; 28) &amp; 0xf,
+                ($v &gt;&gt; 20) &amp; 0xff,
+                ($v &gt;&gt; 12) &amp; 0xff );
+          my $t = &quot;DEPRECATEDIN_${one}_${major}_${minor}&quot;;
+          my $cond = $op eq '&lt;' ? 'ifndef' : 'ifdef';
+          return (&lt;&lt;&quot;EOF&quot;);
+#$cond $t
+EOF
+      }
+   }
+);
+my @cpphandlers = (
+    ##################################################################
+    # CPP stuff
+
+    { regexp   =&gt; qr/#ifdef ?(.*)/,
+      massager =&gt; sub {
+          my %opts;
+          if (ref($_[$#_]) eq &quot;HASH&quot;) {
+              %opts = %{$_[$#_]};
+              pop @_;
+          }
+          push @preprocessor_conds, [ $1 ];
+          print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: preprocessor level: &quot;, scalar(@preprocessor_conds), &quot;\n&quot;
+              if $opts{debug};
+          return ();
+      },
+    },
+    { regexp   =&gt; qr/#ifndef ?(.*)/,
+      massager =&gt; sub {
+          my %opts;
+          if (ref($_[$#_]) eq &quot;HASH&quot;) {
+              %opts = %{$_[$#_]};
+              pop @_;
+          }
+          push @preprocessor_conds, [ '!'.$1 ];
+          print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: preprocessor level: &quot;, scalar(@preprocessor_conds), &quot;\n&quot;
+              if $opts{debug};
+          return ();
+      },
+    },
+    { regexp   =&gt; qr/#if (0|1)/,
+      massager =&gt; sub {
+          my %opts;
+          if (ref($_[$#_]) eq &quot;HASH&quot;) {
+              %opts = %{$_[$#_]};
+              pop @_;
+          }
+          if ($1 eq &quot;1&quot;) {
+              push @preprocessor_conds, [ &quot;TRUE&quot; ];
+          } else {
+              push @preprocessor_conds, [ &quot;!TRUE&quot; ];
+          }
+          print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: preprocessor level: &quot;, scalar(@preprocessor_conds), &quot;\n&quot;
+              if $opts{debug};
+          return ();
+      },
+    },
+    { regexp   =&gt; qr/#if ?(.*)/,
+      massager =&gt; sub {
+          my %opts;
+          if (ref($_[$#_]) eq &quot;HASH&quot;) {
+              %opts = %{$_[$#_]};
+              pop @_;
+          }
+          my @results = ();
+          my $conds = $1;
+          if ($conds =~ m|^defined&lt;&lt;&lt;\(([^\)]*)\)&gt;&gt;&gt;(.*)$|) {
+              push @results, $1; # Handle the simple case
+              my $rest = $2;
+              my $re = qr/^(?:\|\|defined&lt;&lt;&lt;\([^\)]*\)&gt;&gt;&gt;)*$/;
+              print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: Matching '$rest' with '$re'\n&quot;
+                  if $opts{debug};
+              if ($rest =~ m/$re/) {
+                  my @rest = split /\|\|/, $rest;
+                  shift @rest;
+                  foreach (@rest) {
+                      m|^defined&lt;&lt;&lt;\(([^\)]*)\)&gt;&gt;&gt;$|;
+                      die &quot;Something wrong...$opts{PLACE}&quot; if $1 eq &quot;&quot;;
+                      push @results, $1;
+                  }
+              } else {
+                  $conds =~ s/&lt;&lt;&lt;|&gt;&gt;&gt;//g;
+                  warn &quot;Warning: complicated #if expression(1): $conds$opts{PLACE}&quot;
+                      if $opts{warnings};
+              }
+          } elsif ($conds =~ m|^!defined&lt;&lt;&lt;\(([^\)]*)\)&gt;&gt;&gt;(.*)$|) {
+              push @results, '!'.$1; # Handle the simple case
+              my $rest = $2;
+              my $re = qr/^(?:\&amp;\&amp;!defined&lt;&lt;&lt;\([^\)]*\)&gt;&gt;&gt;)*$/;
+              print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: Matching '$rest' with '$re'\n&quot;
+                  if $opts{debug};
+              if ($rest =~ m/$re/) {
+                  my @rest = split /\&amp;\&amp;/, $rest;
+                  shift @rest;
+                  foreach (@rest) {
+                      m|^!defined&lt;&lt;&lt;\(([^\)]*)\)&gt;&gt;&gt;$|;
+                      die &quot;Something wrong...$opts{PLACE}&quot; if $1 eq &quot;&quot;;
+                      push @results, '!'.$1;
+                  }
+              } else {
+                  $conds =~ s/&lt;&lt;&lt;|&gt;&gt;&gt;//g;
+                  warn &quot;Warning: complicated #if expression(2): $conds$opts{PLACE}&quot;
+                      if $opts{warnings};
+              }
+          } else {
+              $conds =~ s/&lt;&lt;&lt;|&gt;&gt;&gt;//g;
+              warn &quot;Warning: complicated #if expression(3): $conds$opts{PLACE}&quot;
+                  if $opts{warnings};
+          }
+          print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: Added preprocessor conds: '&quot;, join(&quot;', '&quot;, @results), &quot;'\n&quot;
+              if $opts{debug};
+          push @preprocessor_conds, [ @results ];
+          print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: preprocessor level: &quot;, scalar(@preprocessor_conds), &quot;\n&quot;
+              if $opts{debug};
+          return ();
+      },
+    },
+    { regexp   =&gt; qr/#elif (.*)/,
+      massager =&gt; sub {
+          my %opts;
+          if (ref($_[$#_]) eq &quot;HASH&quot;) {
+              %opts = %{$_[$#_]};
+              pop @_;
+          }
+          die &quot;An #elif without corresponding condition$opts{PLACE}&quot;
+              if !@preprocessor_conds;
+          pop @preprocessor_conds;
+          print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: preprocessor level: &quot;, scalar(@preprocessor_conds), &quot;\n&quot;
+              if $opts{debug};
+          return (&lt;&lt;&quot;EOF&quot;);
+#if $1
+EOF
+      },
+    },
+    { regexp   =&gt; qr/#else/,
+      massager =&gt; sub {
+          my %opts;
+          if (ref($_[$#_]) eq &quot;HASH&quot;) {
+              %opts = %{$_[$#_]};
+              pop @_;
+          }
+          die &quot;An #else without corresponding condition$opts{PLACE}&quot;
+              if !@preprocessor_conds;
+          # Invert all conditions on the last level
+          my $stuff = pop @preprocessor_conds;
+          push @preprocessor_conds, [
+              map { m|^!(.*)$| ? $1 : '!'.$_ } @$stuff
+          ];
+          print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: preprocessor level: &quot;, scalar(@preprocessor_conds), &quot;\n&quot;
+              if $opts{debug};
+          return ();
+      },
+    },
+    { regexp   =&gt; qr/#endif ?/,
+      massager =&gt; sub {
+          my %opts;
+          if (ref($_[$#_]) eq &quot;HASH&quot;) {
+              %opts = %{$_[$#_]};
+              pop @_;
+          }
+          die &quot;An #endif without corresponding condition$opts{PLACE}&quot;
+              if !@preprocessor_conds;
+          pop @preprocessor_conds;
+          print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: preprocessor level: &quot;, scalar(@preprocessor_conds), &quot;\n&quot;
+              if $opts{debug};
+          return ();
+      },
+    },
+    { regexp   =&gt; qr/#define ([[:alpha:]_]\w*)(&lt;&lt;&lt;\(.*?\)&gt;&gt;&gt;)?( (.*))?/,
+      massager =&gt; sub {
+          my $name = $1;
+          my $params = $2;
+          my $spaceval = $3||&quot;&quot;;
+          my $val = $4||&quot;&quot;;
+          return (&quot;&quot;,
+                  $1, 'M', &quot;&quot;, $params ? &quot;$name$params$spaceval&quot; : $val,
+                  all_conds()); }
+    },
+    { regexp   =&gt; qr/#.*/,
+      massager =&gt; sub { return (); }
+    },
+    );
+
+my @opensslchandlers = (
+    ##################################################################
+    # OpenSSL C specials
+    #
+    # They are really preprocessor stuff, but they look like C stuff
+    # to this parser.  All of these do replacements, anything else is
+    # an error.
+
+    #####
+    # Global variable stuff
+    { regexp   =&gt; qr/OPENSSL_DECLARE_GLOBAL&lt;&lt;&lt;\((.*),(.*)\)&gt;&gt;&gt;;/,
+      massager =&gt; sub { return (&lt;&lt;&quot;EOF&quot;);
+#ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION
+OPENSSL_EXPORT $1 _shadow_$2;
+#else
+$1 *_shadow_$2(void);
+#endif
+EOF
+      },
+    },
+
+    #####
+    # Deprecated stuff, by OpenSSL release.
+
+    # We trick the parser by pretending that the declaration is wrapped in a
+    # check if the DEPRECATEDIN macro is defined or not.  Callers of parse()
+    # will have to decide what to do with it.
+    { regexp   =&gt; qr/(DEPRECATEDIN_\d+_\d+_\d+)&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&lt;&lt;&quot;EOF&quot;);
+#ifndef $1
+$2;
+#endif
+EOF
+      },
+    },
+
+    #####
+    # LHASH stuff
+
+    # LHASH_OF(foo) is used as a type, but the chandlers won't take it
+    # gracefully, so we expand it here.
+    { regexp   =&gt; qr/(.*)\bLHASH_OF&lt;&lt;&lt;\((.*?)\)&gt;&gt;&gt;(.*)/,
+      massager =&gt; sub { return (&quot;$1struct lhash_st_$2$3&quot;); }
+    },
+    { regexp   =&gt; qr/DEFINE_LHASH_OF&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&lt;&lt;&quot;EOF&quot;);
+static ossl_inline LHASH_OF($1) * lh_$1_new(unsigned long (*hfn)(const $1 *),
+                                            int (*cfn)(const $1 *, const $1 *));
+static ossl_inline void lh_$1_free(LHASH_OF($1) *lh);
+static ossl_inline $1 *lh_$1_insert(LHASH_OF($1) *lh, $1 *d);
+static ossl_inline $1 *lh_$1_delete(LHASH_OF($1) *lh, const $1 *d);
+static ossl_inline $1 *lh_$1_retrieve(LHASH_OF($1) *lh, const $1 *d);
+static ossl_inline int lh_$1_error(LHASH_OF($1) *lh);
+static ossl_inline unsigned long lh_$1_num_items(LHASH_OF($1) *lh);
+static ossl_inline void lh_$1_node_stats_bio(const LHASH_OF($1) *lh, BIO *out);
+static ossl_inline void lh_$1_node_usage_stats_bio(const LHASH_OF($1) *lh,
+                                                   BIO *out);
+static ossl_inline void lh_$1_stats_bio(const LHASH_OF($1) *lh, BIO *out);
+static ossl_inline unsigned long lh_$1_get_down_load(LHASH_OF($1) *lh);
+static ossl_inline void lh_$1_set_down_load(LHASH_OF($1) *lh, unsigned long dl);
+static ossl_inline void lh_$1_doall(LHASH_OF($1) *lh, void (*doall)($1 *));
+LHASH_OF($1)
+EOF
+      }
+     },
+
+    #####
+    # STACK stuff
+
+    # STACK_OF(foo) is used as a type, but the chandlers won't take it
+    # gracefully, so we expand it here.
+    { regexp   =&gt; qr/(.*)\bSTACK_OF&lt;&lt;&lt;\((.*?)\)&gt;&gt;&gt;(.*)/,
+      massager =&gt; sub { return (&quot;$1struct stack_st_$2$3&quot;); }
+    },
+#    { regexp   =&gt; qr/(.*)\bSTACK_OF\((.*?)\)(.*)/,
+#      massager =&gt; sub {
+#          my $before = $1;
+#          my $stack_of = &quot;struct stack_st_$2&quot;;
+#          my $after = $3;
+#          if ($after =~ m|^\w|) { $after = &quot; &quot;.$after; }
+#          return (&quot;$before$stack_of$after&quot;);
+#      }
+#    },
+    { regexp   =&gt; qr/SKM_DEFINE_STACK_OF&lt;&lt;&lt;\((.*),(.*),(.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&lt;&lt;&quot;EOF&quot;);
+STACK_OF($1);
+typedef int (*sk_$1_compfunc)(const $3 * const *a, const $3 *const *b);
+typedef void (*sk_$1_freefunc)($3 *a);
+typedef $3 * (*sk_$1_copyfunc)(const $3 *a);
+static ossl_inline int sk_$1_num(const STACK_OF($1) *sk);
+static ossl_inline $2 *sk_$1_value(const STACK_OF($1) *sk, int idx);
+static ossl_inline STACK_OF($1) *sk_$1_new(sk_$1_compfunc compare);
+static ossl_inline STACK_OF($1) *sk_$1_new_null(void);
+static ossl_inline STACK_OF($1) *sk_$1_new_reserve(sk_$1_compfunc compare,
+                                                   int n);
+static ossl_inline int sk_$1_reserve(STACK_OF($1) *sk, int n);
+static ossl_inline void sk_$1_free(STACK_OF($1) *sk);
+static ossl_inline void sk_$1_zero(STACK_OF($1) *sk);
+static ossl_inline $2 *sk_$1_delete(STACK_OF($1) *sk, int i);
+static ossl_inline $2 *sk_$1_delete_ptr(STACK_OF($1) *sk, $2 *ptr);
+static ossl_inline int sk_$1_push(STACK_OF($1) *sk, $2 *ptr);
+static ossl_inline int sk_$1_unshift(STACK_OF($1) *sk, $2 *ptr);
+static ossl_inline $2 *sk_$1_pop(STACK_OF($1) *sk);
+static ossl_inline $2 *sk_$1_shift(STACK_OF($1) *sk);
+static ossl_inline void sk_$1_pop_free(STACK_OF($1) *sk,
+                                       sk_$1_freefunc freefunc);
+static ossl_inline int sk_$1_insert(STACK_OF($1) *sk, $2 *ptr, int idx);
+static ossl_inline $2 *sk_$1_set(STACK_OF($1) *sk, int idx, $2 *ptr);
+static ossl_inline int sk_$1_find(STACK_OF($1) *sk, $2 *ptr);
+static ossl_inline int sk_$1_find_ex(STACK_OF($1) *sk, $2 *ptr);
+static ossl_inline void sk_$1_sort(STACK_OF($1) *sk);
+static ossl_inline int sk_$1_is_sorted(const STACK_OF($1) *sk);
+static ossl_inline STACK_OF($1) * sk_$1_dup(const STACK_OF($1) *sk);
+static ossl_inline STACK_OF($1) *sk_$1_deep_copy(const STACK_OF($1) *sk,
+                                                 sk_$1_copyfunc copyfunc,
+                                                 sk_$1_freefunc freefunc);
+static ossl_inline sk_$1_compfunc sk_$1_set_cmp_func(STACK_OF($1) *sk,
+                                                     sk_$1_compfunc compare);
+EOF
+      }
+    },
+    { regexp   =&gt; qr/DEFINE_SPECIAL_STACK_OF&lt;&lt;&lt;\((.*),(.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&quot;SKM_DEFINE_STACK_OF($1,$2,$2)&quot;); },
+    },
+    { regexp   =&gt; qr/DEFINE_STACK_OF&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&quot;SKM_DEFINE_STACK_OF($1,$1,$1)&quot;); },
+    },
+    { regexp   =&gt; qr/DEFINE_SPECIAL_STACK_OF_CONST&lt;&lt;&lt;\((.*),(.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&quot;SKM_DEFINE_STACK_OF($1,const $2,$2)&quot;); },
+    },
+    { regexp   =&gt; qr/DEFINE_STACK_OF_CONST&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&quot;SKM_DEFINE_STACK_OF($1,const $1,$1)&quot;); },
+    },
+    { regexp   =&gt; qr/PREDECLARE_STACK_OF&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&quot;STACK_OF($1);&quot;); }
+    },
+    { regexp   =&gt; qr/DECLARE_STACK_OF&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&quot;STACK_OF($1);&quot;); }
+    },
+    { regexp   =&gt; qr/DECLARE_SPECIAL_STACK_OF&lt;&lt;&lt;\((.*?),(.*?)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&quot;STACK_OF($1);&quot;); }
+     },
+
+    #####
+    # ASN1 stuff
+
+    { regexp   =&gt; qr/TYPEDEF_D2I_OF&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&quot;typedef $1 *d2i_of_$1($1 **,const unsigned char **,long)&quot;);
+      },
+    },
+    { regexp   =&gt; qr/TYPEDEF_I2D_OF&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&quot;typedef $1 *i2d_of_$1($1 *,unsigned char **)&quot;);
+      },
+    },
+    { regexp   =&gt; qr/TYPEDEF_D2I2D_OF&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&quot;TYPEDEF_D2I_OF($1); TYPEDEF_I2D_OF($1)&quot;);
+      },
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_ITEM&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&lt;&lt;&quot;EOF&quot;);
+#ifndef OPENSSL_EXPORT_VAR_AS_FUNCTION
+OPENSSL_EXTERN const ASN1_ITEM *$1_it;
+#else
+const ASN1_ITEM *$1_it(void);
+#endif
+EOF
+      },
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_ENCODE_FUNCTIONS&lt;&lt;&lt;\((.*),(.*),(.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&lt;&lt;&quot;EOF&quot;);
+int d2i_$3(void);
+int i2d_$3(void);
+DECLARE_ASN1_ITEM($2)
+EOF
+      },
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_ENCODE_FUNCTIONS_const&lt;&lt;&lt;\((.*),(.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&lt;&lt;&quot;EOF&quot;);
+int d2i_$2(void);
+int i2d_$2(void);
+DECLARE_ASN1_ITEM($2)
+EOF
+      },
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_ALLOC_FUNCTIONS&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&lt;&lt;&quot;EOF&quot;);
+int $1_free(void);
+int $1_new(void);
+EOF
+      },
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_FUNCTIONS_name&lt;&lt;&lt;\((.*),(.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&lt;&lt;&quot;EOF&quot;);
+int d2i_$2(void);
+int i2d_$2(void);
+int $2_free(void);
+int $2_new(void);
+DECLARE_ASN1_ITEM($2)
+EOF
+      },
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_FUNCTIONS_fname&lt;&lt;&lt;\((.*),(.*),(.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&lt;&lt;&quot;EOF&quot;);
+int d2i_$3(void);
+int i2d_$3(void);
+int $3_free(void);
+int $3_new(void);
+DECLARE_ASN1_ITEM($2)
+EOF
+      }
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_FUNCTIONS(?:_const)?&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&lt;&lt;&quot;EOF&quot;);
+int d2i_$1(void);
+int i2d_$1(void);
+int $1_free(void);
+int $1_new(void);
+DECLARE_ASN1_ITEM($1)
+EOF
+      }
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_NDEF_FUNCTION&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&lt;&lt;&quot;EOF&quot;);
+int i2d_$1_NDEF(void);
+EOF
+      }
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_PRINT_FUNCTION&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&lt;&lt;&quot;EOF&quot;);
+int $1_print_ctx(void);
+EOF
+      }
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_PRINT_FUNCTION_name&lt;&lt;&lt;\((.*),(.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub {
+          return (&lt;&lt;&quot;EOF&quot;);
+int $2_print_ctx(void);
+EOF
+      }
+    },
+    { regexp   =&gt; qr/DECLARE_ASN1_SET_OF&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (); }
+    },
+    { regexp   =&gt; qr/DECLARE_PKCS12_SET_OF&lt;&lt;&lt;\((.*)\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (); }
+    },
+    { regexp   =&gt; qr/DECLARE_PEM(?|_rw|_rw_cb|_rw_const)&lt;&lt;&lt;\((.*?),.*\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&lt;&lt;&quot;EOF&quot;);
+#ifndef OPENSSL_NO_STDIO
+int PEM_read_$1(void);
+int PEM_write_$1(void);
+#endif
+int PEM_read_bio_$1(void);
+int PEM_write_bio_$1(void);
+EOF
+      },
+    },
+
+    #####
+    # PEM stuff
+    { regexp   =&gt; qr/DECLARE_PEM(?|_write|_write_cb|_write_const)&lt;&lt;&lt;\((.*?),.*\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&lt;&lt;&quot;EOF&quot;);
+#ifndef OPENSSL_NO_STDIO
+int PEM_write_$1(void);
+#endif
+int PEM_write_bio_$1(void);
+EOF
+      },
+    },
+    { regexp   =&gt; qr/DECLARE_PEM(?|_read|_read_cb)&lt;&lt;&lt;\((.*?),.*\)&gt;&gt;&gt;/,
+      massager =&gt; sub { return (&lt;&lt;&quot;EOF&quot;);
+#ifndef OPENSSL_NO_STDIO
+int PEM_read_$1(void);
+#endif
+int PEM_read_bio_$1(void);
+EOF
+      },
+    },
+
+    # Spurious stuff found in the OpenSSL headers
+    # Usually, these are just macros that expand to, well, something
+    { regexp   =&gt; qr/__NDK_FPABI__/,
+      massager =&gt; sub { return (); }
+    },
+    );
+
+my $anoncnt = 0;
+
+my @chandlers = (
+    ##################################################################
+    # C stuff
+
+    # extern &quot;C&quot; of individual items
+    # Note that the main parse function has a special hack for 'extern &quot;C&quot; {'
+    # which can't be done in handlers
+    # We simply ignore it.
+    { regexp   =&gt; qr/extern &quot;C&quot; (.*;)/,
+      massager =&gt; sub { return ($1); },
+    },
+    # union, struct and enum definitions
+    # Because this one might appear a little everywhere within type
+    # definitions, we take it out and replace it with just
+    # 'union|struct|enum name' while registering it.
+    # This makes use of the parser trick to surround the outer braces
+    # with &lt;&lt;&lt; and &gt;&gt;&gt;
+    { regexp   =&gt; qr/(.*)                       # Anything before       ($1)
+                     \b                         # word to non-word boundary
+                     (union|struct|enum)        # The word used         ($2)
+                     (?:\s([[:alpha:]_]\w*))?   # Struct or enum name   ($3)
+                     &lt;&lt;&lt;(\{.*?\})&gt;&gt;&gt;            # Struct or enum definition ($4)
+                     (.*)                       # Anything after        ($5)
+                     ;
+                    /x,
+      massager =&gt; sub {
+          my $before = $1;
+          my $word = $2;
+          my $name = $3
+              || sprintf(&quot;__anon%03d&quot;, ++$anoncnt); # Anonymous struct
+          my $definition = $4;
+          my $after = $5;
+          my $type = $word eq &quot;struct&quot; ? 'S' : 'E';
+          if ($before ne &quot;&quot; || $after ne &quot;;&quot;) {
+              if ($after =~ m|^\w|) { $after = &quot; &quot;.$after; }
+              return (&quot;$before$word $name$after;&quot;,
+                      &quot;$word $name&quot;, $type, &quot;&quot;, &quot;$word$definition&quot;, all_conds());
+          }
+          # If there was no before nor after, make the return much simple
+          return (&quot;&quot;, &quot;$word $name&quot;, $type, &quot;&quot;, &quot;$word$definition&quot;, all_conds());
+      }
+    },
+    # Named struct and enum forward declarations
+    # We really just ignore them, but we need to parse them or the variable
+    # declaration handler further down will think it's a variable declaration.
+    { regexp   =&gt; qr/^(union|struct|enum) ([[:alpha:]_]\w*);/,
+      massager =&gt; sub { return (); }
+    },
+    # Function returning function pointer declaration
+    { regexp   =&gt; qr/(?:(typedef)\s?)?          # Possible typedef      ($1)
+                     ((?:\w|\*|\s)*?)           # Return type           ($2)
+                     \s?                        # Possible space
+                     &lt;&lt;&lt;\(\*
+                     ([[:alpha:]_]\w*)          # Function name         ($3)
+                     (\(.*\))                   # Parameters            ($4)
+                     \)&gt;&gt;&gt;
+                     &lt;&lt;&lt;(\(.*\))&gt;&gt;&gt;             # F.p. parameters       ($5)
+                     ;
+                    /x,
+      massager =&gt; sub {
+          return (&quot;&quot;, $3, 'F', &quot;&quot;, &quot;$2(*$4)$5&quot;, all_conds())
+              if defined $1;
+          return (&quot;&quot;, $3, 'F', &quot;$2(*)$5&quot;, &quot;$2(*$4)$5&quot;, all_conds()); }
+    },
+    # Function pointer declaration, or typedef thereof
+    { regexp   =&gt; qr/(?:(typedef)\s?)?          # Possible typedef      ($1)
+                     ((?:\w|\*|\s)*?)           # Return type           ($2)
+                     &lt;&lt;&lt;\(\*([[:alpha:]_]\w*)\)&gt;&gt;&gt; # T.d. or var name   ($3)
+                     &lt;&lt;&lt;(\(.*\))&gt;&gt;&gt;             # F.p. parameters       ($4)
+                     ;
+                    /x,
+      massager =&gt; sub {
+          return (&quot;&quot;, $3, 'T', &quot;&quot;, &quot;$2(*)$4&quot;, all_conds())
+              if defined $1;
+          return (&quot;&quot;, $3, 'V', &quot;$2(*)$4&quot;, &quot;$2(*)$4&quot;, all_conds());
+      },
+    },
+    # Function declaration, or typedef thereof
+    { regexp   =&gt; qr/(?:(typedef)\s?)?          # Possible typedef      ($1)
+                     ((?:\w|\*|\s)*?)           # Return type           ($2)
+                     \s?                        # Possible space
+                     ([[:alpha:]_]\w*)          # Function name         ($3)
+                     &lt;&lt;&lt;(\(.*\))&gt;&gt;&gt;             # Parameters            ($4)
+                     ;
+                    /x,
+      massager =&gt; sub {
+          return (&quot;&quot;, $3, 'T', &quot;&quot;, &quot;$2$4&quot;, all_conds())
+              if defined $1;
+          return (&quot;&quot;, $3, 'F', $2, &quot;$2$4&quot;, all_conds());
+      },
+    },
+    # Variable declaration, including arrays, or typedef thereof
+    { regexp   =&gt; qr/(?:(typedef)\s?)?          # Possible typedef      ($1)
+                     ((?:\w|\*|\s)*?)           # Type                  ($2)
+                     \s?                        # Possible space
+                     ([[:alpha:]_]\w*)          # Variable name         ($3)
+                     ((?:&lt;&lt;&lt;\[[^\]]*\]&gt;&gt;&gt;)*)    # Possible array declaration ($4)
+                     ;
+                    /x,
+      massager =&gt; sub {
+          return (&quot;&quot;, $3, 'T', &quot;&quot;, $2.($4||&quot;&quot;), all_conds())
+              if defined $1;
+          return (&quot;&quot;, $3, 'V', $2.($4||&quot;&quot;), $2.($4||&quot;&quot;), all_conds());
+      },
+    },
+);
+
+# End handlers are almost the same as handlers, except they are run through
+# ONCE when the input has been parsed through.  These are used to check for
+# remaining stuff, such as an unfinished #ifdef and stuff like that that the
+# main parser can't check on its own.
+my @endhandlers = (
+    { massager =&gt; sub {
+        my %opts = %{$_[0]};
+
+        die &quot;Unfinished preprocessor conditions levels: &quot;,scalar(@preprocessor_conds),($opts{filename} ? &quot; in file &quot;.$opts{filename}: &quot;&quot;),$opts{PLACE}
+            if @preprocessor_conds;
+      }
+    }
+    );
+
+# takes a list of strings that can each contain one or several lines of code
+# also takes a hash of options as last argument.
+#
+# returns a list of hashes with information:
+#
+#       name            name of the thing
+#       type            type, see the massage handler function
+#       returntype      return type of functions and variables
+#       value           value for macros, signature for functions, variables
+#                       and structs
+#       conds           preprocessor conditions (array ref)
+
+sub parse {
+    my %opts;
+    if (ref($_[$#_]) eq &quot;HASH&quot;) {
+        %opts = %{$_[$#_]};
+        pop @_;
+    }
+    my %state = (
+        in_extern_C =&gt; 0,       # An exception to parenthesis processing.
+        cpp_parens =&gt; [],       # A list of ending parens and braces found in
+                                # preprocessor directives
+        c_parens =&gt; [],         # A list of ending parens and braces found in
+                                # C statements
+        in_string =&gt; &quot;&quot;,        # empty string when outside a string, otherwise
+                                # &quot;'&quot; or '&quot;' depending on the starting quote.
+        in_comment =&gt; &quot;&quot;,       # empty string when outside a comment, otherwise
+                                # &quot;/*&quot; or &quot;//&quot; depending on the type of comment
+                                # found.  The latter will never be multiline
+                                # NOTE: in_string and in_comment will never be
+                                # true (in perl semantics) at the same time.
+        current_line =&gt; 0,
+        );
+    my @result = ();
+    my $normalized_line = &quot;&quot;;   # $input_line, but normalized.  In essence, this
+                                # means that ALL whitespace is removed unless
+                                # it absolutely has to be present, and in that
+                                # case, there's only one space.
+                                # The cases where a space needs to stay present
+                                # are:
+                                # 1. between words
+                                # 2. between words and number
+                                # 3. after the first word of a preprocessor
+                                #    directive.
+                                # 4. for the #define directive, between the macro
+                                #    name/args and its value, so we end up with:
+                                #       #define FOO val
+                                #       #define BAR(x) something(x)
+    my $collected_stmt = &quot;&quot;;    # Where we're building up a C line until it's a
+                                # complete definition/declaration, as determined
+                                # by any handler being capable of matching it.
+
+    # We use $_ shamelessly when looking through @lines.
+    # In case we find a \ at the end, we keep filling it up with more lines.
+    $_ = undef;
+
+    foreach my $line (@_) {
+        # split tries to be smart when a string ends with the thing we split on
+        $line .= &quot;\n&quot; unless $line =~ m|\R$|;
+        $line .= &quot;#&quot;;
+
+        # We use &#166;undef&#166; as a marker for a new line from the file.
+        # Since we convert one line to several and unshift that into @lines,
+        # that's the only safe way we have to track the original lines
+        my @lines = map { ( undef, $_ ) } split $/, $line;
+
+        # Remember that extra # we added above?  Now we remove it
+        pop @lines;
+        pop @lines;             # Don't forget the undef
+
+        while (@lines) {
+            if (!defined($lines[0])) {
+                shift @lines;
+                $state{current_line}++;
+                if (!defined($_)) {
+                    $opts{PLACE} = &quot; at &quot;.$opts{filename}.&quot; line &quot;.$state{current_line}.&quot;\n&quot;;
+                    $opts{PLACE2} = $opts{filename}.&quot;:&quot;.$state{current_line};
+                }
+                next;
+            }
+
+            $_ = &quot;&quot; unless defined $_;
+            $_ .= shift @lines;
+
+            if (m|\\$|) {
+                $_ = $`;
+                next;
+            }
+
+            if ($opts{debug}) {
+                print STDERR &quot;DEBUG:----------------------------\n&quot;;
+                print STDERR &quot;DEBUG: \$_      = '$_'\n&quot;;
+            }
+
+            ##########################################################
+            # Now that we have a full line, let's process through it
+            while(1) {
+                unless ($state{in_comment}) {
+                    # Begin with checking if the current $normalized_line
+                    # contains a preprocessor directive
+                    # This is only done if we're not inside a comment and
+                    # if it's a preprocessor directive and it's finished.
+                    if ($normalized_line =~ m|^#| &amp;&amp; $_ eq &quot;&quot;) {
+                        print STDERR &quot;DEBUG[OPENSSL CPP]: \$normalized_line = '$normalized_line'\n&quot;
+                            if $opts{debug};
+                        $opts{debug_type} = &quot;OPENSSL CPP&quot;;
+                        my @r = ( _run_handlers($normalized_line,
+                                                @opensslcpphandlers,
+                                                \%opts) );
+                        if (shift @r) {
+                            # Checking if there are lines to inject.
+                            if (@r) {
+                                @r = split $/, (pop @r).$_;
+                                print STDERR &quot;DEBUG[OPENSSL CPP]: injecting '&quot;, join(&quot;', '&quot;, @r),&quot;'\n&quot;
+                                    if $opts{debug} &amp;&amp; @r;
+                                @lines = ( @r, @lines );
+
+                                $_ = &quot;&quot;;
+                            }
+                        } else {
+                            print STDERR &quot;DEBUG[CPP]: \$normalized_line = '$normalized_line'\n&quot;
+                                if $opts{debug};
+                            $opts{debug_type} = &quot;CPP&quot;;
+                            my @r = ( _run_handlers($normalized_line,
+                                                    @cpphandlers,
+                                                    \%opts) );
+                            if (shift @r) {
+                                if (ref($r[0]) eq &quot;HASH&quot;) {
+                                    push @result, shift @r;
+                                }
+
+                                # Now, check if there are lines to inject.
+                                # Really, this should never happen, it IS a
+                                # preprocessor directive after all...
+                                if (@r) {
+                                    @r = split $/, pop @r;
+                                    print STDERR &quot;DEBUG[CPP]: injecting '&quot;, join(&quot;', '&quot;, @r),&quot;'\n&quot;
+                                    if $opts{debug} &amp;&amp; @r;
+                                    @lines = ( @r, @lines );
+                                    $_ = &quot;&quot;;
+                                }
+                            }
+                        }
+
+                        # Note: we simply ignore all directives that no
+                        # handler matches
+                        $normalized_line = &quot;&quot;;
+                    }
+
+                    # If the two strings end and start with a character that
+                    # shouldn't get concatenated, add a space
+                    my $space =
+                        ($collected_stmt =~ m/(?:&quot;|')$/
+                         || ($collected_stmt =~ m/(?:\w|\d)$/
+                             &amp;&amp; $normalized_line =~ m/^(?:\w|\d)/)) ? &quot; &quot; : &quot;&quot;;
+
+                    # Now, unless we're building up a preprocessor directive or
+                    # are in the middle of a string, or the parens et al aren't
+                    # balanced up yet, let's try and see if there's a OpenSSL
+                    # or C handler that can make sense of what we have so far.
+                    if ( $normalized_line !~ m|^#|
+                         &amp;&amp; ($collected_stmt ne &quot;&quot; || $normalized_line ne &quot;&quot;)
+                         &amp;&amp; ! @{$state{c_parens}}
+                         &amp;&amp; ! $state{in_string} ) {
+                        if ($opts{debug}) {
+                            print STDERR &quot;DEBUG[OPENSSL C]: \$collected_stmt  = '$collected_stmt'\n&quot;;
+                            print STDERR &quot;DEBUG[OPENSSL C]: \$normalized_line = '$normalized_line'\n&quot;;
+                        }
+                        $opts{debug_type} = &quot;OPENSSL C&quot;;
+                        my @r = ( _run_handlers($collected_stmt
+                                                    .$space
+                                                    .$normalized_line,
+                                                @opensslchandlers,
+                                                \%opts) );
+                        if (shift @r) {
+                            # Checking if there are lines to inject.
+                            if (@r) {
+                                @r = split $/, (pop @r).$_;
+                                print STDERR &quot;DEBUG[OPENSSL]: injecting '&quot;, join(&quot;', '&quot;, @r),&quot;'\n&quot;
+                                    if $opts{debug} &amp;&amp; @r;
+                                @lines = ( @r, @lines );
+
+                                $_ = &quot;&quot;;
+                            }
+                            $normalized_line = &quot;&quot;;
+                            $collected_stmt = &quot;&quot;;
+                        } else {
+                            if ($opts{debug}) {
+                                print STDERR &quot;DEBUG[C]: \$collected_stmt  = '$collected_stmt'\n&quot;;
+                                print STDERR &quot;DEBUG[C]: \$normalized_line = '$normalized_line'\n&quot;;
+                            }
+                            $opts{debug_type} = &quot;C&quot;;
+                            my @r = ( _run_handlers($collected_stmt
+                                                        .$space
+                                                        .$normalized_line,
+                                                    @chandlers,
+                                                    \%opts) );
+                            if (shift @r) {
+                                if (ref($r[0]) eq &quot;HASH&quot;) {
+                                    push @result, shift @r;
+                                }
+
+                                # Checking if there are lines to inject.
+                                if (@r) {
+                                    @r = split $/, (pop @r).$_;
+                                    print STDERR &quot;DEBUG[C]: injecting '&quot;, join(&quot;', '&quot;, @r),&quot;'\n&quot;
+                                        if $opts{debug} &amp;&amp; @r;
+                                    @lines = ( @r, @lines );
+
+                                    $_ = &quot;&quot;;
+                                }
+                                $normalized_line = &quot;&quot;;
+                                $collected_stmt = &quot;&quot;;
+                            }
+                        }
+                    }
+                    if ($_ eq &quot;&quot;) {
+                        $collected_stmt .= $space.$normalized_line;
+                        $normalized_line = &quot;&quot;;
+                    }
+                }
+
+                if ($_ eq &quot;&quot;) {
+                    $_ = undef;
+                    last;
+                }
+
+                # Take care of inside string first.
+                if ($state{in_string}) {
+                    if (m/ (?:^|(?&lt;!\\))        # Make sure it's not escaped
+                           $state{in_string}    # Look for matching quote
+                         /x) {
+                        $normalized_line .= $`.$&amp;;
+                        $state{in_string} = &quot;&quot;;
+                        $_ = $';
+                        next;
+                    } else {
+                        die &quot;Unfinished string without continuation found$opts{PLACE}\n&quot;;
+                    }
+                }
+                # ... or inside comments, whichever happens to apply
+                elsif ($state{in_comment}) {
+
+                    # This should never happen
+                    die &quot;Something went seriously wrong, multiline //???$opts{PLACE}\n&quot;
+                        if ($state{in_comment} eq &quot;//&quot;);
+
+                    # A note: comments are simply discarded.
+
+                    if (m/ (?:^|(?&lt;!\\))        # Make sure it's not escaped
+                           \*\/                 # Look for C comment end
+                         /x) {
+                        $state{in_comment} = &quot;&quot;;
+                        $_ = $';
+                        print STDERR &quot;DEBUG: Found end of comment, followed by '$_'\n&quot;
+                            if $opts{debug};
+                        next;
+                    } else {
+                        $_ = &quot;&quot;;
+                        next;
+                    }
+                }
+
+                # At this point, it's safe to remove leading whites, but
+                # we need to be careful with some preprocessor lines
+                if (m|^\s+|) {
+                    my $rest = $';
+                    my $space = &quot;&quot;;
+                    $space = &quot; &quot;
+                        if ($normalized_line =~ m/^
+                                                  \#define\s\w(?:\w|\d)*(?:&lt;&lt;&lt;\([^\)]*\)&gt;&gt;&gt;)?
+                                                  | \#[a-z]+
+                                                  $/x);
+                    print STDERR &quot;DEBUG: Processing leading spaces: \$normalized_line = '$normalized_line', \$space = '$space', \$rest = '$rest'\n&quot;
+                        if $opts{debug};
+                    $_ = $space.$rest;
+                }
+
+                my $parens =
+                    $normalized_line =~ m|^#| ? 'cpp_parens' : 'c_parens';
+                (my $paren_singular = $parens) =~ s|s$||;
+
+                # Now check for specific tokens, and if they are parens,
+                # check them against $state{$parens}.  Note that we surround
+                # the outermost parens with extra &quot;&lt;&lt;&lt;&quot; and &quot;&gt;&gt;&gt;&quot;.  Those
+                # are for the benefit of handlers who to need to detect
+                # them, and they will be removed from the final output.
+                if (m|^[\{\[\(]|) {
+                    my $body = $&amp;;
+                    $_ = $';
+                    if (!@{$state{$parens}}) {
+                        if (&quot;$normalized_line$body&quot; =~ m|^extern &quot;C&quot;\{$|) {
+                            $state{in_extern_C} = 1;
+                            print STDERR &quot;DEBUG: found start of 'extern \&quot;C\&quot;' ($normalized_line$body)\n&quot;
+                                if $opts{debug};
+                            $normalized_line = &quot;&quot;;
+                        } else {
+                            $normalized_line .= &quot;&lt;&lt;&lt;&quot;.$body;
+                        }
+                    } else {
+                        $normalized_line .= $body;
+                    }
+
+                    if ($normalized_line ne &quot;&quot;) {
+                        print STDERR &quot;DEBUG: found $paren_singular start '$body'\n&quot;
+                            if $opts{debug};
+                        $body =~ tr|\{\[\(|\}\]\)|;
+                        print STDERR &quot;DEBUG: pushing $paren_singular end '$body'\n&quot;
+                            if $opts{debug};
+                        push @{$state{$parens}}, $body;
+                    }
+                } elsif (m|^[\}\]\)]|) {
+                    $_ = $';
+
+                    if (!@{$state{$parens}}
+                        &amp;&amp; $&amp; eq '}' &amp;&amp; $state{in_extern_C}) {
+                        print STDERR &quot;DEBUG: found end of 'extern \&quot;C\&quot;'\n&quot;
+                            if $opts{debug};
+                        $state{in_extern_C} = 0;
+                    } else {
+                        print STDERR &quot;DEBUG: Trying to match '$&amp;' against '&quot;
+                            ,join(&quot;', '&quot;, @{$state{$parens}})
+                            ,&quot;'\n&quot;
+                            if $opts{debug};
+                        die &quot;Unmatched parentheses$opts{PLACE}\n&quot;
+                            unless (@{$state{$parens}}
+                                    &amp;&amp; pop @{$state{$parens}} eq $&amp;);
+                        if (!@{$state{$parens}}) {
+                            $normalized_line .= $&amp;.&quot;&gt;&gt;&gt;&quot;;
+                        } else {
+                            $normalized_line .= $&amp;;
+                        }
+                    }
+                } elsif (m|^[&quot;']|) { # string start
+                    my $body = $&amp;;
+                    $_ = $';
+
+                    # We want to separate strings from \w and \d with one space.
+                    $normalized_line .= &quot; &quot; if $normalized_line =~ m/(\w|\d)$/;
+                    $normalized_line .= $body;
+                    $state{in_string} = $body;
+                } elsif (m|^\/\*|) { # C style comment
+                    print STDERR &quot;DEBUG: found start of C style comment\n&quot;
+                        if $opts{debug};
+                    $state{in_comment} = $&amp;;
+                    $_ = $';
+                } elsif (m|^\/\/|) { # C++ style comment
+                    print STDERR &quot;DEBUG: found C++ style comment\n&quot;
+                        if $opts{debug};
+                    $_ = &quot;&quot;;    # (just discard it entirely)
+                } elsif (m/^ (?| (?: 0[xX][[:xdigit:]]+ | 0[bB][01]+ | [0-9]+ )
+                                 (?i: U | L | UL | LL | ULL )?
+                               | [0-9]+\.[0-9]+(?:[eE][\-\+]\d+)? (?i: F | L)?
+                               ) /x) {
+                    print STDERR &quot;DEBUG: Processing numbers: \$normalized_line = '$normalized_line', \$&amp; = '$&amp;', \$' = '$''\n&quot;
+                        if $opts{debug};
+                    $normalized_line .= $&amp;;
+                    $_ = $';
+                } elsif (m/^[[:alpha:]_]\w*/) {
+                    my $body = $&amp;;
+                    my $rest = $';
+                    my $space = &quot;&quot;;
+
+                    # Now, only add a space if it's needed to separate
+                    # two \w characters, and we also surround strings with
+                    # a space.  In this case, that's if $normalized_line ends
+                    # with a \w, \d, &quot; or '.
+                    $space = &quot; &quot;
+                        if ($normalized_line =~ m/(&quot;|')$/
+                            || ($normalized_line =~ m/(\w|\d)$/
+                                &amp;&amp; $body =~ m/^(\w|\d)/));
+
+                    print STDERR &quot;DEBUG: Processing words: \$normalized_line = '$normalized_line', \$space = '$space', \$body = '$body', \$rest = '$rest'\n&quot;
+                        if $opts{debug};
+                    $normalized_line .= $space.$body;
+                    $_ = $rest;
+                } elsif (m|^(?:\\)?.|) { # Catch-all
+                    $normalized_line .= $&amp;;
+                    $_ = $';
+                }
+            }
+        }
+    }
+    foreach my $handler (@endhandlers) {
+        if ($handler-&gt;{massager}) {
+            $handler-&gt;{massager}-&gt;(\%opts);
+        }
+    }
+    return @result;
+}
+
+# arg1:    line to check
+# arg2...: handlers to check
+# return undef when no handler matched
+sub _run_handlers {
+    my %opts;
+    if (ref($_[$#_]) eq &quot;HASH&quot;) {
+        %opts = %{$_[$#_]};
+        pop @_;
+    }
+    my $line = shift;
+    my @handlers = @_;
+
+    foreach my $handler (@handlers) {
+        if ($handler-&gt;{regexp}
+            &amp;&amp; $line =~ m|^$handler-&gt;{regexp}$|) {
+            if ($handler-&gt;{massager}) {
+                if ($opts{debug}) {
+                    print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: Trying to handle '$line'\n&quot;;
+                    print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: (matches /\^&quot;,$handler-&gt;{regexp},&quot;\$/)\n&quot;;
+                }
+                my $saved_line = $line;
+                my @massaged =
+                    map { s/(&lt;&lt;&lt;|&gt;&gt;&gt;)//g; $_ }
+                    $handler-&gt;{massager}-&gt;($saved_line, \%opts);
+                print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]: Got back '&quot;
+                    , join(&quot;', '&quot;, @massaged), &quot;'\n&quot;
+                    if $opts{debug};
+
+                # Because we may get back new lines to be
+                # injected before whatever else that follows,
+                # and the injected stuff might include
+                # preprocessor lines, we need to inject them
+                # in @lines and set $_ to the empty string to
+                # break out from the inner loops
+                my $injected_lines = shift @massaged || &quot;&quot;;
+
+                if (@massaged) {
+                    return (1,
+                            {
+                                name    =&gt; shift @massaged,
+                                type    =&gt; shift @massaged,
+                                returntype =&gt; shift @massaged,
+                                value   =&gt; shift @massaged,
+                                conds   =&gt; [ @massaged ]
+                            },
+                            $injected_lines
+                        );
+                } else {
+                    print STDERR &quot;DEBUG[&quot;,$opts{debug_type},&quot;]:   (ignore, possible side effects)\n&quot;
+                        if $opts{debug} &amp;&amp; $injected_lines eq &quot;&quot;;
+                    return (1, $injected_lines);
+                }
+            }
+            return (1);
+        }
+    }
+    return (0);
+}
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020352.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="020361.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20360">[ date ]</a>
              <a href="thread.html#20360">[ thread ]</a>
              <a href="subject.html#20360">[ subject ]</a>
              <a href="author.html#20360">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
