<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  OpenSSL_1_1_1-stable update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2018-October/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20OpenSSL_1_1_1-stable%20update&In-Reply-To=%3C1539772503.051495.24042.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020461.html">
   <LINK REL="Next"  HREF="020472.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  OpenSSL_1_1_1-stable update</H1>
    <B>nic.tuv at gmail.com</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20OpenSSL_1_1_1-stable%20update&In-Reply-To=%3C1539772503.051495.24042.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  OpenSSL_1_1_1-stable update">nic.tuv at gmail.com
       </A><BR>
    <I>Wed Oct 17 10:35:03 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="020461.html">[openssl-commits] [openssl]  OpenSSL_1_1_1-stable update
</A></li>
        <LI>Next message: <A HREF="020472.html">[openssl-commits] [openssl]  OpenSSL_1_1_1-stable update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20463">[ date ]</a>
              <a href="thread.html#20463">[ thread ]</a>
              <a href="subject.html#20463">[ subject ]</a>
              <a href="author.html#20463">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch OpenSSL_1_1_1-stable has been updated
       via  871039698042467b814b4fa37353db120be5b331 (commit)
      from  135e8062369f3c7a2398ac12e7eea3c3c18b017d (commit)


- Log -----------------------------------------------------------------
commit 871039698042467b814b4fa37353db120be5b331
Author: Antoine Salon &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">asalon at vmware.com</A>&gt;
Date:   Mon Oct 1 14:11:57 2018 -0700

    EVP module documentation pass
    
    Replace ECDH_KDF_X9_62() with internal ecdh_KDF_X9_63()
    
    Signed-off-by: Antoine Salon &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">asalon at vmware.com</A>&gt;
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    Reviewed-by: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7345">https://github.com/openssl/openssl/pull/7345</A>)
    
    (cherry picked from commit ffd89124bdfc9e69349492c3f15383bb35520a11)

-----------------------------------------------------------------------

Summary of changes:
 CHANGES                                         |   7 +-
 crypto/ec/ec_ameth.c                            |   4 +-
 crypto/ec/ec_pmeth.c                            |   4 +-
 crypto/ec/ecdh_kdf.c                            |  19 +-
 crypto/include/internal/ec_int.h                |   8 +
 crypto/sm2/sm2_crypt.c                          |   5 +-
 doc/man3/EVP_PKEY_CTX_ctrl.pod                  | 283 ++++++++++++++++++++++--
 doc/man3/EVP_PKEY_CTX_set_rsa_pss_keygen_md.pod |   4 +-
 doc/man3/EVP_PKEY_set1_RSA.pod                  |  35 +--
 doc/man3/EVP_aes.pod                            |   6 +
 doc/man3/EVP_aria.pod                           |   6 +
 doc/man3/EVP_bf_cbc.pod                         |   3 +
 doc/man3/EVP_camellia.pod                       |   6 +
 doc/man3/EVP_cast5_cbc.pod                      |   3 +
 doc/man3/EVP_des.pod                            |  30 ++-
 doc/man3/EVP_idea_cbc.pod                       |   3 +
 doc/man3/EVP_md5.pod                            |   4 +-
 doc/man3/EVP_rc2_cbc.pod                        |   3 +
 doc/man3/EVP_rc5_32_12_16_cbc.pod               |   3 +
 doc/man3/EVP_seed_cbc.pod                       |   3 +
 doc/man3/EVP_sm4_cbc.pod                        |   3 +
 include/openssl/ec.h                            |  13 +-
 util/private.num                                |  39 +++-
 23 files changed, 433 insertions(+), 61 deletions(-)

diff --git a/CHANGES b/CHANGES
index 59d5733..cf45875 100644
--- a/CHANGES
+++ b/CHANGES
@@ -9,9 +9,10 @@
 
  Changes between 1.1.1 and 1.1.1a [xx XXX xxxx]
 
-  *)
-
- Changes between 1.1.1 and 1.1.1a [xx XXX xxxx]
+  *) Added EVP_PKEY_ECDH_KDF_X9_63 and ecdh_KDF_X9_63() as replacements for
+     the EVP_PKEY_ECDH_KDF_X9_62 KDF type and ECDH_KDF_X9_62(). The old names
+     are retained for backwards compatibility.
+     [Antoine Salon]
 
   *) Fixed the issue that RAND_add()/RAND_seed() silently discards random input
      if its length exceeds 4096 bytes. The limit has been raised to a buffer size
diff --git a/crypto/ec/ec_ameth.c b/crypto/ec/ec_ameth.c
index 2130268..a3164b5 100644
--- a/crypto/ec/ec_ameth.c
+++ b/crypto/ec/ec_ameth.c
@@ -699,7 +699,7 @@ static int ecdh_cms_set_kdf_param(EVP_PKEY_CTX *pctx, int eckdf_nid)
     if (EVP_PKEY_CTX_set_ecdh_cofactor_mode(pctx, cofactor) &lt;= 0)
         return 0;
 
-    if (EVP_PKEY_CTX_set_ecdh_kdf_type(pctx, EVP_PKEY_ECDH_KDF_X9_62) &lt;= 0)
+    if (EVP_PKEY_CTX_set_ecdh_kdf_type(pctx, EVP_PKEY_ECDH_KDF_X9_63) &lt;= 0)
         return 0;
 
     kdf_md = EVP_get_digestbynid(kdfmd_nid);
@@ -864,7 +864,7 @@ static int ecdh_cms_encrypt(CMS_RecipientInfo *ri)
         ecdh_nid = NID_dh_cofactor_kdf;
 
     if (kdf_type == EVP_PKEY_ECDH_KDF_NONE) {
-        kdf_type = EVP_PKEY_ECDH_KDF_X9_62;
+        kdf_type = EVP_PKEY_ECDH_KDF_X9_63;
         if (EVP_PKEY_CTX_set_ecdh_kdf_type(pctx, kdf_type) &lt;= 0)
             goto err;
     } else
diff --git a/crypto/ec/ec_pmeth.c b/crypto/ec/ec_pmeth.c
index 5bee031..f4ad074 100644
--- a/crypto/ec/ec_pmeth.c
+++ b/crypto/ec/ec_pmeth.c
@@ -209,7 +209,7 @@ static int pkey_ec_kdf_derive(EVP_PKEY_CTX *ctx,
     if (!pkey_ec_derive(ctx, ktmp, &amp;ktmplen))
         goto err;
     /* Do KDF stuff */
-    if (!ECDH_KDF_X9_62(key, *keylen, ktmp, ktmplen,
+    if (!ecdh_KDF_X9_63(key, *keylen, ktmp, ktmplen,
                         dctx-&gt;kdf_ukm, dctx-&gt;kdf_ukmlen, dctx-&gt;kdf_md))
         goto err;
     rv = 1;
@@ -281,7 +281,7 @@ static int pkey_ec_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
     case EVP_PKEY_CTRL_EC_KDF_TYPE:
         if (p1 == -2)
             return dctx-&gt;kdf_type;
-        if (p1 != EVP_PKEY_ECDH_KDF_NONE &amp;&amp; p1 != EVP_PKEY_ECDH_KDF_X9_62)
+        if (p1 != EVP_PKEY_ECDH_KDF_NONE &amp;&amp; p1 != EVP_PKEY_ECDH_KDF_X9_63)
             return -2;
         dctx-&gt;kdf_type = p1;
         return 1;
diff --git a/crypto/ec/ecdh_kdf.c b/crypto/ec/ecdh_kdf.c
index d47486e..d686f9d 100644
--- a/crypto/ec/ecdh_kdf.c
+++ b/crypto/ec/ecdh_kdf.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2015-2018 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -10,12 +10,13 @@
 #include &lt;string.h&gt;
 #include &lt;openssl/ec.h&gt;
 #include &lt;openssl/evp.h&gt;
+#include &quot;ec_lcl.h&quot;
 
-/* Key derivation function from X9.62/SECG */
+/* Key derivation function from X9.63/SECG */
 /* Way more than we will ever need */
 #define ECDH_KDF_MAX    (1 &lt;&lt; 30)
 
-int ECDH_KDF_X9_62(unsigned char *out, size_t outlen,
+int ecdh_KDF_X9_63(unsigned char *out, size_t outlen,
                    const unsigned char *Z, size_t Zlen,
                    const unsigned char *sinfo, size_t sinfolen,
                    const EVP_MD *md)
@@ -66,3 +67,15 @@ int ECDH_KDF_X9_62(unsigned char *out, size_t outlen,
     EVP_MD_CTX_free(mctx);
     return rv;
 }
+
+/*-
+ * The old name for ecdh_KDF_X9_63
+ * Retained for ABI compatibility
+ */
+int ECDH_KDF_X9_62(unsigned char *out, size_t outlen,
+                   const unsigned char *Z, size_t Zlen,
+                   const unsigned char *sinfo, size_t sinfolen,
+                   const EVP_MD *md)
+{
+    return ecdh_KDF_X9_63(out, outlen, Z, Zlen, sinfo, sinfolen, md);
+}
diff --git a/crypto/include/internal/ec_int.h b/crypto/include/internal/ec_int.h
index bb4b512..182c39c 100644
--- a/crypto/include/internal/ec_int.h
+++ b/crypto/include/internal/ec_int.h
@@ -41,5 +41,13 @@
 __owur int ec_group_do_inverse_ord(const EC_GROUP *group, BIGNUM *res,
                                    const BIGNUM *x, BN_CTX *ctx);
 
+/*-
+ * ECDH Key Derivation Function as defined in ANSI X9.63
+ */
+int ecdh_KDF_X9_63(unsigned char *out, size_t outlen,
+                   const unsigned char *Z, size_t Zlen,
+                   const unsigned char *sinfo, size_t sinfolen,
+                   const EVP_MD *md);
+
 # endif /* OPENSSL_NO_EC */
 #endif
diff --git a/crypto/sm2/sm2_crypt.c b/crypto/sm2/sm2_crypt.c
index 9c69a45..4389fc7 100644
--- a/crypto/sm2/sm2_crypt.c
+++ b/crypto/sm2/sm2_crypt.c
@@ -11,6 +11,7 @@
 
 #include &quot;internal/sm2.h&quot;
 #include &quot;internal/sm2err.h&quot;
+#include &quot;internal/ec_int.h&quot; /* ecdh_KDF_X9_63() */
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/bn.h&gt;
@@ -203,7 +204,7 @@ int sm2_encrypt(const EC_KEY *key,
    }
 
     /* X9.63 with no salt happens to match the KDF used in SM2 */
-    if (!ECDH_KDF_X9_62(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,
+    if (!ecdh_KDF_X9_63(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,
                         digest)) {
         SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB);
         goto done;
@@ -344,7 +345,7 @@ int sm2_decrypt(const EC_KEY *key,
 
     if (BN_bn2binpad(x2, x2y2, field_size) &lt; 0
             || BN_bn2binpad(y2, x2y2 + field_size, field_size) &lt; 0
-            || !ECDH_KDF_X9_62(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,
+            || !ecdh_KDF_X9_63(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,
                                digest)) {
         SM2err(SM2_F_SM2_DECRYPT, ERR_R_INTERNAL_ERROR);
         goto done;
diff --git a/doc/man3/EVP_PKEY_CTX_ctrl.pod b/doc/man3/EVP_PKEY_CTX_ctrl.pod
index e1a107c..75fba58 100644
--- a/doc/man3/EVP_PKEY_CTX_ctrl.pod
+++ b/doc/man3/EVP_PKEY_CTX_ctrl.pod
@@ -4,20 +4,55 @@
 
 EVP_PKEY_CTX_ctrl,
 EVP_PKEY_CTX_ctrl_str,
+EVP_PKEY_CTX_ctrl_uint64,
+EVP_PKEY_CTX_md,
 EVP_PKEY_CTX_set_signature_md,
 EVP_PKEY_CTX_get_signature_md,
 EVP_PKEY_CTX_set_mac_key,
 EVP_PKEY_CTX_set_rsa_padding,
+EVP_PKEY_CTX_get_rsa_padding,
 EVP_PKEY_CTX_set_rsa_pss_saltlen,
+EVP_PKEY_CTX_get_rsa_pss_saltlen,
 EVP_PKEY_CTX_set_rsa_keygen_bits,
 EVP_PKEY_CTX_set_rsa_keygen_pubexp,
+EVP_PKEY_CTX_set_rsa_keygen_primes,
+EVP_PKEY_CTX_set_rsa_mgf1_md,
+EVP_PKEY_CTX_get_rsa_mgf1_md,
+EVP_PKEY_CTX_set_rsa_oaep_md,
+EVP_PKEY_CTX_get_rsa_oaep_md,
+EVP_PKEY_CTX_set0_rsa_oaep_label,
+EVP_PKEY_CTX_get0_rsa_oaep_label,
 EVP_PKEY_CTX_set_dsa_paramgen_bits,
 EVP_PKEY_CTX_set_dh_paramgen_prime_len,
+EVP_PKEY_CTX_set_dh_paramgen_subprime_len,
 EVP_PKEY_CTX_set_dh_paramgen_generator,
+EVP_PKEY_CTX_set_dh_paramgen_type,
+EVP_PKEY_CTX_set_dh_rfc5114,
+EVP_PKEY_CTX_set_dhx_rfc5114,
 EVP_PKEY_CTX_set_dh_pad,
 EVP_PKEY_CTX_set_dh_nid,
+EVP_PKEY_CTX_set_dh_kdf_type,
+EVP_PKEY_CTX_get_dh_kdf_type,
+EVP_PKEY_CTX_set0_dh_kdf_oid,
+EVP_PKEY_CTX_get0_dh_kdf_oid,
+EVP_PKEY_CTX_set_dh_kdf_md,
+EVP_PKEY_CTX_get_dh_kdf_md,
+EVP_PKEY_CTX_set_dh_kdf_outlen,
+EVP_PKEY_CTX_get_dh_kdf_outlen,
+EVP_PKEY_CTX_set0_dh_kdf_ukm,
+EVP_PKEY_CTX_get0_dh_kdf_ukm,
 EVP_PKEY_CTX_set_ec_paramgen_curve_nid,
 EVP_PKEY_CTX_set_ec_param_enc,
+EVP_PKEY_CTX_set_ecdh_cofactor_mode,
+EVP_PKEY_CTX_get_ecdh_cofactor_mode,
+EVP_PKEY_CTX_set_ecdh_kdf_type,
+EVP_PKEY_CTX_get_ecdh_kdf_type,
+EVP_PKEY_CTX_set_ecdh_kdf_md,
+EVP_PKEY_CTX_get_ecdh_kdf_md,
+EVP_PKEY_CTX_set_ecdh_kdf_outlen,
+EVP_PKEY_CTX_get_ecdh_kdf_outlen,
+EVP_PKEY_CTX_set0_ecdh_kdf_ukm,
+EVP_PKEY_CTX_get0_ecdh_kdf_ukm,
 EVP_PKEY_CTX_set1_id, EVP_PKEY_CTX_get1_id, EVP_PKEY_CTX_get1_id_len
 - algorithm specific control operations
 
@@ -27,9 +62,13 @@ EVP_PKEY_CTX_set1_id, EVP_PKEY_CTX_get1_id, EVP_PKEY_CTX_get1_id_len
 
  int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
                        int cmd, int p1, void *p2);
+ int EVP_PKEY_CTX_ctrl_uint64(EVP_PKEY_CTX *ctx, int keytype, int optype,
+                              int cmd, uint64_t value);
  int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
                            const char *value);
 
+ int EVP_PKEY_CTX_md(EVP_PKEY_CTX *ctx, int optype, int cmd, const char *md);
+
  int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
  int EVP_PKEY_CTX_get_signature_md(EVP_PKEY_CTX *ctx, const EVP_MD **pmd);
 
@@ -38,22 +77,58 @@ EVP_PKEY_CTX_set1_id, EVP_PKEY_CTX_get1_id, EVP_PKEY_CTX_get1_id_len
  #include &lt;openssl/rsa.h&gt;
 
  int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int pad);
+ int EVP_PKEY_CTX_get_rsa_padding(EVP_PKEY_CTX *ctx, int *pad);
  int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int len);
+ int EVP_PKEY_CTX_get_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int *len);
  int EVP_PKEY_CTX_set_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int mbits);
  int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx, BIGNUM *pubexp);
+ int EVP_PKEY_CTX_set_rsa_keygen_primes(EVP_PKEY_CTX *ctx, int primes);
+ int EVP_PKEY_CTX_set_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
+ int EVP_PKEY_CTX_get_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const EVP_MD **md);
+ int EVP_PKEY_CTX_set_rsa_oaep_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
+ int EVP_PKEY_CTX_get_rsa_oaep_md(EVP_PKEY_CTX *ctx, const EVP_MD **md);
+ int EVP_PKEY_CTX_set0_rsa_oaep_label(EVP_PKEY_CTX *ctx, unsigned char *label, int len);
+ int EVP_PKEY_CTX_get0_rsa_oaep_label(EVP_PKEY_CTX *ctx, unsigned char **label);
 
  #include &lt;openssl/dsa.h&gt;
+
  int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx, int nbits);
 
  #include &lt;openssl/dh.h&gt;
+
  int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX *ctx, int len);
+ int EVP_PKEY_CTX_set_dh_paramgen_subprime_len(EVP_PKEY_CTX *ctx, int len);
  int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX *ctx, int gen);
+ int EVP_PKEY_CTX_set_dh_paramgen_type(EVP_PKEY_CTX *ctx, int type);
  int EVP_PKEY_CTX_set_dh_pad(EVP_PKEY_CTX *ctx, int pad);
  int EVP_PKEY_CTX_set_dh_nid(EVP_PKEY_CTX *ctx, int nid);
+ int EVP_PKEY_CTX_set_dh_rfc5114(EVP_PKEY_CTX *ctx, int rfc5114);
+ int EVP_PKEY_CTX_set_dhx_rfc5114(EVP_PKEY_CTX *ctx, int rfc5114);
+ int EVP_PKEY_CTX_set_dh_kdf_type(EVP_PKEY_CTX *ctx, int kdf);
+ int EVP_PKEY_CTX_get_dh_kdf_type(EVP_PKEY_CTX *ctx);
+ int EVP_PKEY_CTX_set0_dh_kdf_oid(EVP_PKEY_CTX *ctx, ASN1_OBJECT *oid);
+ int EVP_PKEY_CTX_get0_dh_kdf_oid(EVP_PKEY_CTX *ctx, ASN1_OBJECT **oid);
+ int EVP_PKEY_CTX_set_dh_kdf_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
+ int EVP_PKEY_CTX_get_dh_kdf_md(EVP_PKEY_CTX *ctx, const EVP_MD **md);
+ int EVP_PKEY_CTX_set_dh_kdf_outlen(EVP_PKEY_CTX *ctx, int len);
+ int EVP_PKEY_CTX_get_dh_kdf_outlen(EVP_PKEY_CTX *ctx, int *len);
+ int EVP_PKEY_CTX_set0_dh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned char *ukm, int len);
+ int EVP_PKEY_CTX_get0_dh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned char **ukm);
 
  #include &lt;openssl/ec.h&gt;
+ 
  int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *ctx, int nid);
  int EVP_PKEY_CTX_set_ec_param_enc(EVP_PKEY_CTX *ctx, int param_enc);
+ int EVP_PKEY_CTX_set_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx, int cofactor_mode);
+ int EVP_PKEY_CTX_get_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx);
+ int EVP_PKEY_CTX_set_ecdh_kdf_type(EVP_PKEY_CTX *ctx, int kdf);
+ int EVP_PKEY_CTX_get_ecdh_kdf_type(EVP_PKEY_CTX *ctx);
+ int EVP_PKEY_CTX_set_ecdh_kdf_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
+ int EVP_PKEY_CTX_get_ecdh_kdf_md(EVP_PKEY_CTX *ctx, const EVP_MD **md);
+ int EVP_PKEY_CTX_set_ecdh_kdf_outlen(EVP_PKEY_CTX *ctx, int len);
+ int EVP_PKEY_CTX_get_ecdh_kdf_outlen(EVP_PKEY_CTX *ctx, int *len);
+ int EVP_PKEY_CTX_set0_ecdh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned char *ukm, int len);
+ int EVP_PKEY_CTX_get0_ecdh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned char **ukm);
 
  int EVP_PKEY_CTX_set1_id(EVP_PKEY_CTX *ctx, void *id, size_t id_len);
  int EVP_PKEY_CTX_get1_id(EVP_PKEY_CTX *ctx, void *id);
@@ -73,6 +148,9 @@ and B&lt;p2&gt; is MAC key. This is used by Poly1305, SipHash, HMAC and CMAC.
 Applications will not normally call EVP_PKEY_CTX_ctrl() directly but will
 instead call one of the algorithm specific macros below.
 
+The function EVP_PKEY_CTX_ctrl_uint64() is a wrapper that directly passes a
+uint64 value as B&lt;p2&gt; to EVP_PKEY_CTX_ctrl().
+
 The function EVP_PKEY_CTX_ctrl_str() allows an application to send an algorithm
 specific control operation to a context B&lt;ctx&gt; in string form. This is
 intended to be used for options specified on the command line or in text
@@ -80,6 +158,9 @@ files. The commands supported are documented in the openssl utility
 command line pages for the option B&lt;-pkeyopt&gt; which is supported by the
 B&lt;pkeyutl&gt;, B&lt;genpkey&gt; and B&lt;req&gt; commands.
 
+The function EVP_PKEY_CTX_md() sends a message digest control operation
+to the context B&lt;ctx&gt;. The message digest is specified by its name B&lt;md&gt;.
+
 All the remaining &quot;functions&quot; are implemented as macros.
 
 The EVP_PKEY_CTX_set_signature_md() macro sets the message digest type used
@@ -99,12 +180,14 @@ L&lt;EVP_PKEY_new_raw_private_key(3)&gt; or similar functions instead of this macro.
 The EVP_PKEY_CTX_set_mac_key() macro can be used with any of the algorithms
 supported by the L&lt;EVP_PKEY_new_raw_private_key(3)&gt; function.
 
-The macro EVP_PKEY_CTX_set_rsa_padding() sets the RSA padding mode for B&lt;ctx&gt;.
-The B&lt;pad&gt; parameter can take the value RSA_PKCS1_PADDING for PKCS#1 padding,
-RSA_SSLV23_PADDING for SSLv23 padding, RSA_NO_PADDING for no padding,
-RSA_PKCS1_OAEP_PADDING for OAEP padding (encrypt and decrypt only),
-RSA_X931_PADDING for X9.31 padding (signature operations only) and
-RSA_PKCS1_PSS_PADDING (sign and verify only).
+=head2 RSA parameters
+
+The EVP_PKEY_CTX_set_rsa_padding() macro sets the RSA padding mode for B&lt;ctx&gt;.
+The B&lt;pad&gt; parameter can take the value B&lt;RSA_PKCS1_PADDING&gt; for PKCS#1
+padding, B&lt;RSA_SSLV23_PADDING&gt; for SSLv23 padding, B&lt;RSA_NO_PADDING&gt; for
+no padding, B&lt;RSA_PKCS1_OAEP_PADDING&gt; for OAEP padding (encrypt and
+decrypt only), B&lt;RSA_X931_PADDING&gt; for X9.31 padding (signature operations
+only) and B&lt;RSA_PKCS1_PSS_PADDING&gt; (sign and verify only).
 
 Two RSA padding modes behave differently if EVP_PKEY_CTX_set_signature_md()
 is used. If this macro is called for PKCS#1 padding the plaintext buffer is
@@ -116,41 +199,154 @@ padding for RSA the algorithm identifier byte is added or checked and removed
 if this control is called. If it is not called then the first byte of the plaintext
 buffer is expected to be the algorithm identifier byte.
 
+The EVP_PKEY_CTX_get_rsa_padding() macro gets the RSA padding mode for B&lt;ctx&gt;.
+
 The EVP_PKEY_CTX_set_rsa_pss_saltlen() macro sets the RSA PSS salt length to
-B&lt;len&gt; as its name implies it is only supported for PSS padding.  Three special
-values are supported: RSA_PSS_SALTLEN_DIGEST sets the salt length to the
-digest length, RSA_PSS_SALTLEN_MAX sets the salt length to the maximum
-permissible value. When verifying RSA_PSS_SALTLEN_AUTO causes the salt length
+B&lt;len&gt;. As its name implies it is only supported for PSS padding. Three special
+values are supported: B&lt;RSA_PSS_SALTLEN_DIGEST&gt; sets the salt length to the
+digest length, B&lt;RSA_PSS_SALTLEN_MAX&gt; sets the salt length to the maximum
+permissible value. When verifying B&lt;RSA_PSS_SALTLEN_AUTO&gt; causes the salt length
 to be automatically determined based on the B&lt;PSS&gt; block structure. If this
 macro is not called maximum salt length is used when signing and auto detection
 when verifying is used by default.
 
+The EVP_PKEY_CTX_get_rsa_pss_saltlen() macro gets the RSA PSS salt length
+for B&lt;ctx&gt;. The padding mode must have been set to B&lt;RSA_PKCS1_PSS_PADDING&gt;.
+
 The EVP_PKEY_CTX_set_rsa_keygen_bits() macro sets the RSA key length for
 RSA key generation to B&lt;bits&gt;. If not specified 1024 bits is used.
 
 The EVP_PKEY_CTX_set_rsa_keygen_pubexp() macro sets the public exponent value
-for RSA key generation to B&lt;pubexp&gt; currently it should be an odd integer. The
+for RSA key generation to B&lt;pubexp&gt;. Currently it should be an odd integer. The
 B&lt;pubexp&gt; pointer is used internally by this function so it should not be
-modified or free after the call. If this macro is not called then 65537 is used.
+modified or freed after the call. If not specified 65537 is used.
+
+The EVP_PKEY_CTX_set_rsa_keygen_primes() macro sets the number of primes for
+RSA key generation to B&lt;primes&gt;. If not specified 2 is used.
+
+The EVP_PKEY_CTX_set_rsa_mgf1_md() macro sets the MGF1 digest for RSA padding
+schemes to B&lt;md&gt;. If not explicitly set the signing digest is used. The
+padding mode must have been set to B&lt;RSA_PKCS1_OAEP_PADDING&gt;
+or B&lt;RSA_PKCS1_PSS_PADDING&gt;.
+
+The EVP_PKEY_CTX_get_rsa_mgf1_md() macro gets the MGF1 digest for B&lt;ctx&gt;.
+If not explicitly set the signing digest is used. The padding mode must have
+been set to B&lt;RSA_PKCS1_OAEP_PADDING&gt; or B&lt;RSA_PKCS1_PSS_PADDING&gt;.
+
+The EVP_PKEY_CTX_set_rsa_oaep_md() macro sets the message digest type used
+in RSA OAEP to B&lt;md&gt;. The padding mode must have been set to
+B&lt;RSA_PKCS1_OAEP_PADDING&gt;.
+
+The EVP_PKEY_CTX_get_rsa_oaep_md() macro gets the message digest type used
+in RSA OAEP to B&lt;md&gt;. The padding mode must have been set to
+B&lt;RSA_PKCS1_OAEP_PADDING&gt;.
+
+The EVP_PKEY_CTX_set0_rsa_oaep_label() macro sets the RSA OAEP label to
+B&lt;label&gt; and its length to B&lt;len&gt;. If B&lt;label&gt; is NULL or B&lt;len&gt; is 0,
+the label is cleared. The library takes ownership of the label so the
+caller should not free the original memory pointed to by B&lt;label&gt;.
+The padding mode must have been set to B&lt;RSA_PKCS1_OAEP_PADDING&gt;.
+
+The EVP_PKEY_CTX_get0_rsa_oaep_label() macro gets the RSA OAEP label to
+B&lt;label&gt;. The return value is the label length. The padding mode
+must have been set to B&lt;RSA_PKCS1_OAEP_PADDING&gt;. The resulting pointer is owned
+by the library and should not be freed by the caller.
+
+=head2 DSA parameters
 
-The macro EVP_PKEY_CTX_set_dsa_paramgen_bits() sets the number of bits used
+The EVP_PKEY_CTX_set_dsa_paramgen_bits() macro sets the number of bits used
 for DSA parameter generation to B&lt;bits&gt;. If not specified 1024 is used.
 
-The macro EVP_PKEY_CTX_set_dh_paramgen_prime_len() sets the length of the DH
+=head2 DH parameters
+
+The EVP_PKEY_CTX_set_dh_paramgen_prime_len() macro sets the length of the DH
 prime parameter B&lt;p&gt; for DH parameter generation. If this macro is not called
-then 1024 is used.
+then 1024 is used. Only accepts lengths greater than or equal to 256.
+
+The EVP_PKEY_CTX_set_dh_paramgen_subprime_len() macro sets the length of the DH
+optional subprime parameter B&lt;q&gt; for DH parameter generation. The default is
+256 if the prime is at least 2048 bits long or 160 otherwise. The DH
+paramgen type must have been set to x9.42.
 
 The EVP_PKEY_CTX_set_dh_paramgen_generator() macro sets DH generator to B&lt;gen&gt;
 for DH parameter generation. If not specified 2 is used.
 
+The EVP_PKEY_CTX_set_dh_paramgen_type() macro sets the key type for DH
+parameter generation. Use 0 for PKCS#3 DH and 1 for X9.42 DH.
+The default is 0.
+
 The EVP_PKEY_CTX_set_dh_pad() macro sets the DH padding mode. If B&lt;pad&gt; is
 1 the shared secret is padded with zeroes up to the size of the DH prime B&lt;p&gt;.
 If B&lt;pad&gt; is zero (the default) then no padding is performed.
 
 EVP_PKEY_CTX_set_dh_nid() sets the DH parameters to values corresponding to
-B&lt;nid&gt;. The B&lt;nid&gt; parameter must be B&lt;NID_ffdhe2048&gt;, B&lt;NID_ffdhe3072&gt;,
-B&lt;NID_ffdhe4096&gt;, B&lt;NID_ffdhe6144&gt; or B&lt;NID_ffdhe8192&gt;.  This macro can be
-called during parameter or key generation.
+B&lt;nid&gt; as defined in RFC7919. The B&lt;nid&gt; parameter must be B&lt;NID_ffdhe2048&gt;,
+B&lt;NID_ffdhe3072&gt;, B&lt;NID_ffdhe4096&gt;, B&lt;NID_ffdhe6144&gt;, B&lt;NID_ffdhe8192&gt;
+or B&lt;NID_undef&gt; to clear the stored value. This macro can be called during
+parameter or key generation.
+The nid parameter and the rfc5114 parameter are mutually exclusive.
+
+The EVP_PKEY_CTX_set_dh_rfc5114() and EVP_PKEY_CTX_set_dhx_rfc5114() macros are
+synonymous. They set the DH parameters to the values defined in RFC5114. The
+B&lt;rfc5114&gt; parameter must be 1, 2 or 3 corresponding to RFC5114 sections
+2.1, 2.2 and 2.3. or 0 to clear the stored value. This macro can be called
+during parameter generation. The B&lt;ctx&gt; must have a key type of
+B&lt;EVP_PKEY_DHX&gt;.
+The rfc5114 parameter and the nid parameter are mutually exclusive.
+
+=head2 DH key derivation function parameters
+
+Note that all of the following functions require that the B&lt;ctx&gt; parameter has
+a private key type of B&lt;EVP_PKEY_DHX&gt;. When using key derivation, the output of
+EVP_PKEY_derive() is the output of the KDF instead of the DH shared secret.
+The KDF output is typically used as a Key Encryption Key (KEK) that in turn
+encrypts a Content Encryption Key (CEK).
+
+The EVP_PKEY_CTX_set_dh_kdf_type() macro sets the key derivation function type
+to B&lt;kdf&gt; for DH key derivation. Possible values are B&lt;EVP_PKEY_DH_KDF_NONE&gt;
+and B&lt;EVP_PKEY_DH_KDF_X9_42&gt; which uses the key derivation specified in RFC2631
+(based on the keying algorithm described in X9.42). When using key derivation,
+the B&lt;kdf_oid&gt;, B&lt;kdf_md&gt; and B&lt;kdf_outlen&gt; parameters must also be specified.
+
+The EVP_PKEY_CTX_get_dh_kdf_type() macro gets the key derivation function type
+for B&lt;ctx&gt; used for DH key derivation. Possible values are B&lt;EVP_PKEY_DH_KDF_NONE&gt;
+and B&lt;EVP_PKEY_DH_KDF_X9_42&gt;.
+
+The EVP_PKEY_CTX_set0_dh_kdf_oid() macro sets the key derivation function
+object identifier to B&lt;oid&gt; for DH key derivation. This OID should identify
+the algorithm to be used with the Content Encryption Key.
+The library takes ownership of the object identifier so the caller should not
+free the original memory pointed to by B&lt;oid&gt;.
+
+The EVP_PKEY_CTX_get0_dh_kdf_oid() macro gets the key derivation function oid
+for B&lt;ctx&gt; used for DH key derivation. The resulting pointer is owned by the
+library and should not be freed by the caller.
+
+The EVP_PKEY_CTX_set_dh_kdf_md() macro sets the key derivation function
+message digest to B&lt;md&gt; for DH key derivation. Note that RFC2631 specifies
+that this digest should be SHA1 but OpenSSL tolerates other digests.
+
+The EVP_PKEY_CTX_get_dh_kdf_md() macro gets the key derivation function
+message digest for B&lt;ctx&gt; used for DH key derivation.
+
+The EVP_PKEY_CTX_set_dh_kdf_outlen() macro sets the key derivation function
+output length to B&lt;len&gt; for DH key derivation.
+
+The EVP_PKEY_CTX_get_dh_kdf_outlen() macro gets the key derivation function
+output length for B&lt;ctx&gt; used for DH key derivation.
+
+The EVP_PKEY_CTX_set0_dh_kdf_ukm() macro sets the user key material to
+B&lt;ukm&gt; and its length to B&lt;len&gt; for DH key derivation. This parameter is optional
+and corresponds to the partyAInfo field in RFC2631 terms. The specification
+requires that it is 512 bits long but this is not enforced by OpenSSL.
+The library takes ownership of the user key material so the caller should not
+free the original memory pointed to by B&lt;ukm&gt;.
+
+The EVP_PKEY_CTX_get0_dh_kdf_ukm() macro gets the user key material for B&lt;ctx&gt;.
+The return value is the user key material length. The resulting pointer is owned
+by the library and should not be freed by the caller.
+
+=head2 EC parameters
 
 The EVP_PKEY_CTX_set_ec_paramgen_curve_nid() sets the EC curve for EC parameter
 generation to B&lt;nid&gt;. For EC parameter generation this macro must be called
@@ -158,7 +354,7 @@ or an error occurs because there is no default curve.
 This function can also be called to set the curve explicitly when
 generating an EC key.
 
-The EVP_PKEY_CTX_set_ec_param_enc() sets the EC parameter encoding to
+The EVP_PKEY_CTX_set_ec_param_enc() macro sets the EC parameter encoding to
 B&lt;param_enc&gt; when generating EC parameters or an EC key. The encoding can be
 B&lt;OPENSSL_EC_EXPLICIT_CURVE&gt; for explicit parameters (the default in versions
 of OpenSSL before 1.1.0) or B&lt;OPENSSL_EC_NAMED_CURVE&gt; to use named curve form.
@@ -166,6 +362,53 @@ For maximum compatibility the named curve form should be used. Note: the
 B&lt;OPENSSL_EC_NAMED_CURVE&gt; value was only added to OpenSSL 1.1.0; previous
 versions should use 0 instead.
 
+=head2 ECDH parameters
+
+The EVP_PKEY_CTX_set_ecdh_cofactor_mode() macro sets the cofactor mode to
+B&lt;cofactor_mode&gt; for ECDH key derivation. Possible values are 1 to enable
+cofactor key derivation, 0 to disable it and -1 to clear the stored cofactor
+mode and fallback to the private key cofactor mode.
+
+The EVP_PKEY_CTX_get_ecdh_cofactor_mode() macro returns the cofactor mode for
+B&lt;ctx&gt; used for ECDH key derivation. Possible values are 1 when cofactor key
+derivation is enabled and 0 otherwise.
+
+=head2 ECDH key derivation function parameters
+
+The EVP_PKEY_CTX_set_ecdh_kdf_type() macro sets the key derivation function type
+to B&lt;kdf&gt; for ECDH key derivation. Possible values are B&lt;EVP_PKEY_ECDH_KDF_NONE&gt;
+and B&lt;EVP_PKEY_ECDH_KDF_X9_63&gt; which uses the key derivation specified in X9.63.
+When using key derivation, the B&lt;kdf_md&gt; and B&lt;kdf_outlen&gt; parameters must
+also be specified.
+
+The EVP_PKEY_CTX_get_ecdh_kdf_type() macro returns the key derivation function
+type for B&lt;ctx&gt; used for ECDH key derivation. Possible values are
+B&lt;EVP_PKEY_ECDH_KDF_NONE&gt; and B&lt;EVP_PKEY_ECDH_KDF_X9_63&gt;.
+
+The EVP_PKEY_CTX_set_ecdh_kdf_md() macro sets the key derivation function
+message digest to B&lt;md&gt; for ECDH key derivation. Note that X9.63 specifies
+that this digest should be SHA1 but OpenSSL tolerates other digests.
+
+The EVP_PKEY_CTX_get_ecdh_kdf_md() macro gets the key derivation function
+message digest for B&lt;ctx&gt; used for ECDH key derivation.
+
+The EVP_PKEY_CTX_set_ecdh_kdf_outlen() macro sets the key derivation function
+output length to B&lt;len&gt; for ECDH key derivation.
+
+The EVP_PKEY_CTX_get_ecdh_kdf_outlen() macro gets the key derivation function
+output length for B&lt;ctx&gt; used for ECDH key derivation.
+
+The EVP_PKEY_CTX_set0_ecdh_kdf_ukm() macro sets the user key material to B&lt;ukm&gt;
+for ECDH key derivation. This parameter is optional and corresponds to the
+shared info in X9.63 terms. The library takes ownership of the user key material
+so the caller should not free the original memory pointed to by B&lt;ukm&gt;.
+
+The EVP_PKEY_CTX_get0_ecdh_kdf_ukm() macro gets the user key material for B&lt;ctx&gt;.
+The return value is the user key material length. The resulting pointer is owned
+by the library and should not be freed by the caller.
+
+=head2 Other parameters
+
 The EVP_PKEY_CTX_set1_id(), EVP_PKEY_CTX_get1_id() and EVP_PKEY_CTX_get1_id_len()
 macros are used to manipulate the special identifier field for specific signature
 algorithms such as SM2. The EVP_PKEY_CTX_set1_id() sets an ID pointed by B&lt;id&gt; with
@@ -191,7 +434,7 @@ L&lt;EVP_PKEY_decrypt(3)&gt;,
 L&lt;EVP_PKEY_sign(3)&gt;,
 L&lt;EVP_PKEY_verify(3)&gt;,
 L&lt;EVP_PKEY_verify_recover(3)&gt;,
-L&lt;EVP_PKEY_derive(3)&gt;
+L&lt;EVP_PKEY_derive(3)&gt;,
 L&lt;EVP_PKEY_keygen(3)&gt;
 
 =head1 HISTORY
diff --git a/doc/man3/EVP_PKEY_CTX_set_rsa_pss_keygen_md.pod b/doc/man3/EVP_PKEY_CTX_set_rsa_pss_keygen_md.pod
index bd1193e..7578278 100644
--- a/doc/man3/EVP_PKEY_CTX_set_rsa_pss_keygen_md.pod
+++ b/doc/man3/EVP_PKEY_CTX_set_rsa_pss_keygen_md.pod
@@ -32,7 +32,7 @@ The EVP_PKEY_CTX_set_rsa_pss_saltlen() macro is used to set the salt length.
 If the key has usage restrictions then an error is returned if an attempt is
 made to set the salt length below the minimum value. It is otherwise similar
 to the B&lt;RSA&gt; operation except detection of the salt length (using
-RSA_PSS_SALTLEN_AUTO is not supported for verification if the key has
+RSA_PSS_SALTLEN_AUTO) is not supported for verification if the key has
 usage restrictions.
 
 The EVP_PKEY_CTX_set_signature_md() and EVP_PKEY_CTX_set_rsa_mgf1_md() macros
@@ -43,7 +43,7 @@ similar to the B&lt;RSA&gt; versions.
 
 =head2 Key Generation
 
-As with RSA key generation the EVP_PKEY_CTX_set_rsa_rsa_keygen_bits()
+As with RSA key generation the EVP_PKEY_CTX_set_rsa_keygen_bits()
 and EVP_PKEY_CTX_set_rsa_keygen_pubexp() macros are supported for RSA-PSS:
 they have exactly the same meaning as for the RSA algorithm.
 
diff --git a/doc/man3/EVP_PKEY_set1_RSA.pod b/doc/man3/EVP_PKEY_set1_RSA.pod
index 749c52c..d10fc59 100644
--- a/doc/man3/EVP_PKEY_set1_RSA.pod
+++ b/doc/man3/EVP_PKEY_set1_RSA.pod
@@ -6,8 +6,10 @@ EVP_PKEY_set1_RSA, EVP_PKEY_set1_DSA, EVP_PKEY_set1_DH, EVP_PKEY_set1_EC_KEY,
 EVP_PKEY_get1_RSA, EVP_PKEY_get1_DSA, EVP_PKEY_get1_DH, EVP_PKEY_get1_EC_KEY,
 EVP_PKEY_get0_RSA, EVP_PKEY_get0_DSA, EVP_PKEY_get0_DH, EVP_PKEY_get0_EC_KEY,
 EVP_PKEY_assign_RSA, EVP_PKEY_assign_DSA, EVP_PKEY_assign_DH,
-EVP_PKEY_assign_EC_KEY, EVP_PKEY_get0_hmac, EVP_PKEY_type, EVP_PKEY_id,
-EVP_PKEY_base_id, EVP_PKEY_set_alias_type, EVP_PKEY_set1_engine - EVP_PKEY assignment functions
+EVP_PKEY_assign_EC_KEY, EVP_PKEY_assign_POLY1305, EVP_PKEY_assign_SIPHASH,
+EVP_PKEY_get0_hmac, EVP_PKEY_get0_poly1305, EVP_PKEY_get0_siphash,
+EVP_PKEY_type, EVP_PKEY_id, EVP_PKEY_base_id, EVP_PKEY_set_alias_type,
+EVP_PKEY_set1_engine - EVP_PKEY assignment functions
 
 =head1 SYNOPSIS
 
@@ -24,6 +26,8 @@ EVP_PKEY_base_id, EVP_PKEY_set_alias_type, EVP_PKEY_set1_engine - EVP_PKEY assig
  EC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);
 
  const unsigned char *EVP_PKEY_get0_hmac(const EVP_PKEY *pkey, size_t *len);
+ const unsigned char *EVP_PKEY_get0_poly1305(const EVP_PKEY *pkey, size_t *len);
+ const unsigned char *EVP_PKEY_get0_siphash(const EVP_PKEY *pkey, size_t *len);
  RSA *EVP_PKEY_get0_RSA(EVP_PKEY *pkey);
  DSA *EVP_PKEY_get0_DSA(EVP_PKEY *pkey);
  DH *EVP_PKEY_get0_DH(EVP_PKEY *pkey);
@@ -33,6 +37,8 @@ EVP_PKEY_base_id, EVP_PKEY_set_alias_type, EVP_PKEY_set1_engine - EVP_PKEY assig
  int EVP_PKEY_assign_DSA(EVP_PKEY *pkey, DSA *key);
  int EVP_PKEY_assign_DH(EVP_PKEY *pkey, DH *key);
  int EVP_PKEY_assign_EC_KEY(EVP_PKEY *pkey, EC_KEY *key);
+ int EVP_PKEY_assign_POLY1305(EVP_PKEY *pkey, ASN1_OCTET_STRING *key);
+ int EVP_PKEY_assign_SIPHASH(EVP_PKEY *pkey, ASN1_OCTET_STRING *key);
 
  int EVP_PKEY_id(const EVP_PKEY *pkey);
  int EVP_PKEY_base_id(const EVP_PKEY *pkey);
@@ -50,14 +56,15 @@ EVP_PKEY_get1_RSA(), EVP_PKEY_get1_DSA(), EVP_PKEY_get1_DH() and
 EVP_PKEY_get1_EC_KEY() return the referenced key in B&lt;pkey&gt; or
 B&lt;NULL&gt; if the key is not of the correct type.
 
-EVP_PKEY_get0_hmac(), EVP_PKEY_get0_RSA(), EVP_PKEY_get0_DSA(),
-EVP_PKEY_get0_DH() and EVP_PKEY_get0_EC_KEY() also return the
-referenced key in B&lt;pkey&gt; or B&lt;NULL&gt; if the key is not of the
-correct type but the reference count of the returned key is
-B&lt;not&gt; incremented and so must not be freed up after use.
+EVP_PKEY_get0_hmac(), EVP_PKEY_get0_poly1305(), EVP_PKEY_get0_siphash(),
+EVP_PKEY_get0_RSA(), EVP_PKEY_get0_DSA(), EVP_PKEY_get0_DH()
+and EVP_PKEY_get0_EC_KEY() also return the referenced key in B&lt;pkey&gt; or B&lt;NULL&gt;
+if the key is not of the correct type but the reference count of the
+returned key is B&lt;not&gt; incremented and so must not be freed up after use.
 
-EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()
-and EVP_PKEY_assign_EC_KEY() also set the referenced key to B&lt;key&gt;
+EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH(),
+EVP_PKEY_assign_EC_KEY(), EVP_PKEY_assign_POLY1305() and
+EVP_PKEY_assign_SIPHASH() also set the referenced key to B&lt;key&gt;
 however these use the supplied B&lt;key&gt; internally and so B&lt;key&gt;
 will be freed when the parent B&lt;pkey&gt; is freed.
 
@@ -89,8 +96,9 @@ In accordance with the OpenSSL naming convention the key obtained
 from or assigned to the B&lt;pkey&gt; using the B&lt;1&gt; functions must be
 freed as well as B&lt;pkey&gt;.
 
-EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()
-and EVP_PKEY_assign_EC_KEY() are implemented as macros.
+EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH(),
+EVP_PKEY_assign_EC_KEY(), EVP_PKEY_assign_POLY1305()
+and EVP_PKEY_assign_SIPHASH() are implemented as macros.
 
 Most applications wishing to know a key type will simply call
 EVP_PKEY_base_id() and will not care about the actual type:
@@ -119,8 +127,9 @@ EVP_PKEY_get1_RSA(), EVP_PKEY_get1_DSA(), EVP_PKEY_get1_DH() and
 EVP_PKEY_get1_EC_KEY() return the referenced key or B&lt;NULL&gt; if
 an error occurred.
 
-EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH()
-and EVP_PKEY_assign_EC_KEY() return 1 for success and 0 for failure.
+EVP_PKEY_assign_RSA(), EVP_PKEY_assign_DSA(), EVP_PKEY_assign_DH(),
+EVP_PKEY_assign_EC_KEY(), EVP_PKEY_assign_POLY1305()
+and EVP_PKEY_assign_SIPHASH() return 1 for success and 0 for failure.
 
 EVP_PKEY_base_id(), EVP_PKEY_id() and EVP_PKEY_type() return a key
 type or B&lt;NID_undef&gt; (equivalently B&lt;EVP_PKEY_NONE&gt;) on error.
diff --git a/doc/man3/EVP_aes.pod b/doc/man3/EVP_aes.pod
index 6a89399..a47c7eb 100644
--- a/doc/man3/EVP_aes.pod
+++ b/doc/man3/EVP_aes.pod
@@ -14,6 +14,9 @@ EVP_aes_256_cfb1,
 EVP_aes_128_cfb8,
 EVP_aes_192_cfb8,
 EVP_aes_256_cfb8,
+EVP_aes_128_cfb128,
+EVP_aes_192_cfb128,
+EVP_aes_256_cfb128,
 EVP_aes_128_ctr,
 EVP_aes_192_ctr,
 EVP_aes_256_ctr,
@@ -75,6 +78,9 @@ EVP_aes_256_cfb1(),
 EVP_aes_128_cfb8(),
 EVP_aes_192_cfb8(),
 EVP_aes_256_cfb8(),
+EVP_aes_128_cfb128(),
+EVP_aes_192_cfb128(),
+EVP_aes_256_cfb128(),
 EVP_aes_128_ctr(),
 EVP_aes_192_ctr(),
 EVP_aes_256_ctr(),
diff --git a/doc/man3/EVP_aria.pod b/doc/man3/EVP_aria.pod
index 3b6ad35..b98ec56 100644
--- a/doc/man3/EVP_aria.pod
+++ b/doc/man3/EVP_aria.pod
@@ -14,6 +14,9 @@ EVP_aria_256_cfb1,
 EVP_aria_128_cfb8,
 EVP_aria_192_cfb8,
 EVP_aria_256_cfb8,
+EVP_aria_128_cfb128,
+EVP_aria_192_cfb128,
+EVP_aria_256_cfb128,
 EVP_aria_128_ctr,
 EVP_aria_192_ctr,
 EVP_aria_256_ctr,
@@ -60,6 +63,9 @@ EVP_aria_256_cfb1(),
 EVP_aria_128_cfb8(),
 EVP_aria_192_cfb8(),
 EVP_aria_256_cfb8(),
+EVP_aria_128_cfb128(),
+EVP_aria_192_cfb128(),
+EVP_aria_256_cfb128(),
 EVP_aria_128_ctr(),
 EVP_aria_192_ctr(),
 EVP_aria_256_ctr(),
diff --git a/doc/man3/EVP_bf_cbc.pod b/doc/man3/EVP_bf_cbc.pod
index 4a9d3a9..09b412d 100644
--- a/doc/man3/EVP_bf_cbc.pod
+++ b/doc/man3/EVP_bf_cbc.pod
@@ -4,6 +4,7 @@
 
 EVP_bf_cbc,
 EVP_bf_cfb,
+EVP_bf_cfb64,
 EVP_bf_ecb,
 EVP_bf_ofb
 - EVP Blowfish cipher
@@ -14,6 +15,7 @@ EVP_bf_ofb
 
  const EVP_CIPHER *EVP_bf_cbc(void)
  const EVP_CIPHER *EVP_bf_cfb(void)
+ const EVP_CIPHER *EVP_bf_cfb64(void)
  const EVP_CIPHER *EVP_bf_ecb(void)
  const EVP_CIPHER *EVP_bf_ofb(void)
 
@@ -27,6 +29,7 @@ This is a variable key length cipher.
 
 =item EVP_bf_cbc(),
 EVP_bf_cfb(),
+EVP_bf_cfb64(),
 EVP_bf_ecb(),
 EVP_bf_ofb()
 
diff --git a/doc/man3/EVP_camellia.pod b/doc/man3/EVP_camellia.pod
index 75602cf..fe21cac 100644
--- a/doc/man3/EVP_camellia.pod
+++ b/doc/man3/EVP_camellia.pod
@@ -14,6 +14,9 @@ EVP_camellia_256_cfb1,
 EVP_camellia_128_cfb8,
 EVP_camellia_192_cfb8,
 EVP_camellia_256_cfb8,
+EVP_camellia_128_cfb128,
+EVP_camellia_192_cfb128,
+EVP_camellia_256_cfb128,
 EVP_camellia_128_ctr,
 EVP_camellia_192_ctr,
 EVP_camellia_256_ctr,
@@ -54,6 +57,9 @@ EVP_camellia_256_cfb1(),
 EVP_camellia_128_cfb8(),
 EVP_camellia_192_cfb8(),
 EVP_camellia_256_cfb8(),
+EVP_camellia_128_cfb128(),
+EVP_camellia_192_cfb128(),
+EVP_camellia_256_cfb128(),
 EVP_camellia_128_ctr(),
 EVP_camellia_192_ctr(),
 EVP_camellia_256_ctr(),
diff --git a/doc/man3/EVP_cast5_cbc.pod b/doc/man3/EVP_cast5_cbc.pod
index 01c3841..95c9b8d 100644
--- a/doc/man3/EVP_cast5_cbc.pod
+++ b/doc/man3/EVP_cast5_cbc.pod
@@ -4,6 +4,7 @@
 
 EVP_cast5_cbc,
 EVP_cast5_cfb,
+EVP_cast5_cfb64,
 EVP_cast5_ecb,
 EVP_cast5_ofb
 - EVP CAST cipher
@@ -14,6 +15,7 @@ EVP_cast5_ofb
 
  const EVP_CIPHER *EVP_cast5_cbc(void)
  const EVP_CIPHER *EVP_cast5_cfb(void)
+ const EVP_CIPHER *EVP_cast5_cfb64(void)
  const EVP_CIPHER *EVP_cast5_ecb(void)
  const EVP_CIPHER *EVP_cast5_ofb(void)
 
@@ -28,6 +30,7 @@ This is a variable key length cipher.
 =item EVP_cast5_cbc(),
 EVP_cast5_ecb(),
 EVP_cast5_cfb(),
+EVP_cast5_cfb64(),
 EVP_cast5_ofb()
 
 CAST encryption algorithm in CBC, ECB, CFB and OFB modes respectively.
diff --git a/doc/man3/EVP_des.pod b/doc/man3/EVP_des.pod
index 836c399..9b42656 100644
--- a/doc/man3/EVP_des.pod
+++ b/doc/man3/EVP_des.pod
@@ -6,19 +6,24 @@ EVP_des_cbc,
 EVP_des_cfb,
 EVP_des_cfb1,
 EVP_des_cfb8,
+EVP_des_cfb64,
 EVP_des_ecb,
+EVP_des_ofb,
 EVP_des_ede,
+EVP_des_ede_cbc,
 EVP_des_ede_cfb,
+EVP_des_ede_cfb64,
+EVP_des_ede_ecb,
 EVP_des_ede_ofb,
-EVP_des_ofb,
 EVP_des_ede3,
 EVP_des_ede3_cbc,
 EVP_des_ede3_cfb,
 EVP_des_ede3_cfb1,
 EVP_des_ede3_cfb8,
+EVP_des_ede3_cfb64,
+EVP_des_ede3_ecb,
 EVP_des_ede3_ofb,
-EVP_des_ede3_wrap,
-EVP_des_ede_cbc
+EVP_des_ede3_wrap
 - EVP DES cipher
 
 =head1 SYNOPSIS
@@ -43,27 +48,32 @@ EVP_des_ecb(),
 EVP_des_cfb(),
 EVP_des_cfb1(),
 EVP_des_cfb8(),
+EVP_des_cfb64(),
 EVP_des_ofb()
 
-DES in CBC, ECB, CFB with 128-bit shift, CFB with 1-bit shift, CFB with 8-bit
-shift and OFB modes respectively.
+DES in CBC, ECB, CFB with 64-bit shift, CFB with 1-bit shift, CFB with 8-bit
+shift and OFB modes.
 
 =item EVP_des_ede(),
 EVP_des_ede_cbc(),
-EVP_des_ede_ofb(),
-EVP_des_ede_cfb()
+EVP_des_ede_cfb(),
+EVP_des_ede_cfb64(),
+EVP_des_ede_ecb(),
+EVP_des_ede_ofb()
 
-Two key triple DES in ECB, CBC, CFB and OFB modes respectively.
+Two key triple DES in ECB, CBC, CFB with 64-bit shift and OFB modes.
 
 =item EVP_des_ede3(),
 EVP_des_ede3_cbc(),
 EVP_des_ede3_cfb(),
 EVP_des_ede3_cfb1(),
 EVP_des_ede3_cfb8(),
+EVP_des_ede3_cfb64(),
+EVP_des_ede3_ecb(),
 EVP_des_ede3_ofb()
 
-Three-key triple DES in ECB, CBC, CFB with 128-bit shift, CFB with 1-bit shift,
-CFB with 8-bit shift and OFB modes respectively.
+Three-key triple DES in ECB, CBC, CFB with 64-bit shift, CFB with 1-bit shift,
+CFB with 8-bit shift and OFB modes.
 
 =item EVP_des_ede3_wrap()
 
diff --git a/doc/man3/EVP_idea_cbc.pod b/doc/man3/EVP_idea_cbc.pod
index ace7988..61d0150 100644
--- a/doc/man3/EVP_idea_cbc.pod
+++ b/doc/man3/EVP_idea_cbc.pod
@@ -4,6 +4,7 @@
 
 EVP_idea_cbc,
 EVP_idea_cfb,
+EVP_idea_cfb64,
 EVP_idea_ecb,
 EVP_idea_ofb
 - EVP IDEA cipher
@@ -14,6 +15,7 @@ EVP_idea_ofb
 
  const EVP_CIPHER *EVP_idea_cbc(void)
  const EVP_CIPHER *EVP_idea_cfb(void)
+ const EVP_CIPHER *EVP_idea_cfb64(void)
  const EVP_CIPHER *EVP_idea_ecb(void)
  const EVP_CIPHER *EVP_idea_ofb(void)
 
@@ -25,6 +27,7 @@ The IDEA encryption algorithm for EVP.
 
 =item EVP_idea_cbc(),
 EVP_idea_cfb(),
+EVP_idea_cfb64(),
 EVP_idea_ecb(),
 EVP_idea_ofb()
 
diff --git a/doc/man3/EVP_md5.pod b/doc/man3/EVP_md5.pod
index 8101143..725fcbf 100644
--- a/doc/man3/EVP_md5.pod
+++ b/doc/man3/EVP_md5.pod
@@ -2,7 +2,8 @@
 
 =head1 NAME
 
-EVP_md5
+EVP_md5,
+EVP_md5_sha1
 - MD5 For EVP
 
 =head1 SYNOPSIS
@@ -10,6 +11,7 @@ EVP_md5
  #include &lt;openssl/evp.h&gt;
 
  const EVP_MD *EVP_md5(void);
+ const EVP_MD *EVP_md5_sha1(void);
 
 =head1 DESCRIPTION
 
diff --git a/doc/man3/EVP_rc2_cbc.pod b/doc/man3/EVP_rc2_cbc.pod
index 0958e93..8fde8e5 100644
--- a/doc/man3/EVP_rc2_cbc.pod
+++ b/doc/man3/EVP_rc2_cbc.pod
@@ -4,6 +4,7 @@
 
 EVP_rc2_cbc,
 EVP_rc2_cfb,
+EVP_rc2_cfb64,
 EVP_rc2_ecb,
 EVP_rc2_ofb,
 EVP_rc2_40_cbc,
@@ -16,6 +17,7 @@ EVP_rc2_64_cbc
 
  const EVP_CIPHER *EVP_rc2_cbc(void)
  const EVP_CIPHER *EVP_rc2_cfb(void)
+ const EVP_CIPHER *EVP_rc2_cfb64(void)
  const EVP_CIPHER *EVP_rc2_ecb(void)
  const EVP_CIPHER *EVP_rc2_ofb(void)
  const EVP_CIPHER *EVP_rc2_40_cbc(void)
@@ -29,6 +31,7 @@ The RC2 encryption algorithm for EVP.
 
 =item EVP_rc2_cbc(),
 EVP_rc2_cfb(),
+EVP_rc2_cfb64(),
 EVP_rc2_ecb(),
 EVP_rc2_ofb()
 
diff --git a/doc/man3/EVP_rc5_32_12_16_cbc.pod b/doc/man3/EVP_rc5_32_12_16_cbc.pod
index 56175e9..9d580da 100644
--- a/doc/man3/EVP_rc5_32_12_16_cbc.pod
+++ b/doc/man3/EVP_rc5_32_12_16_cbc.pod
@@ -4,6 +4,7 @@
 
 EVP_rc5_32_12_16_cbc,
 EVP_rc5_32_12_16_cfb,
+EVP_rc5_32_12_16_cfb64,
 EVP_rc5_32_12_16_ecb,
 EVP_rc5_32_12_16_ofb
 - EVP RC5 cipher
@@ -14,6 +15,7 @@ EVP_rc5_32_12_16_ofb
 
  const EVP_CIPHER *EVP_rc5_32_12_16_cbc(void)
  const EVP_CIPHER *EVP_rc5_32_12_16_cfb(void)
+ const EVP_CIPHER *EVP_rc5_32_12_16_cfb64(void)
  const EVP_CIPHER *EVP_rc5_32_12_16_ecb(void)
  const EVP_CIPHER *EVP_rc5_32_12_16_ofb(void)
 
@@ -25,6 +27,7 @@ The RC5 encryption algorithm for EVP.
 
 =item EVP_rc5_32_12_16_cbc(),
 EVP_rc5_32_12_16_cfb(),
+EVP_rc5_32_12_16_cfb64(),
 EVP_rc5_32_12_16_ecb(),
 EVP_rc5_32_12_16_ofb()
 
diff --git a/doc/man3/EVP_seed_cbc.pod b/doc/man3/EVP_seed_cbc.pod
index e9f1f69..cd75392 100644
--- a/doc/man3/EVP_seed_cbc.pod
+++ b/doc/man3/EVP_seed_cbc.pod
@@ -4,6 +4,7 @@
 
 EVP_seed_cbc,
 EVP_seed_cfb,
+EVP_seed_cfb128,
 EVP_seed_ecb,
 EVP_seed_ofb
 - EVP SEED cipher
@@ -14,6 +15,7 @@ EVP_seed_ofb
 
  const EVP_CIPHER *EVP_seed_cbc(void)
  const EVP_CIPHER *EVP_seed_cfb(void)
+ const EVP_CIPHER *EVP_seed_cfb128(void)
  const EVP_CIPHER *EVP_seed_ecb(void)
  const EVP_CIPHER *EVP_seed_ofb(void)
 
@@ -27,6 +29,7 @@ All modes below use a key length of 128 bits and acts on blocks of 128-bits.
 
 =item EVP_seed_cbc(),
 EVP_seed_cfb(),
+EVP_seed_cfb128(),
 EVP_seed_ecb(),
 EVP_seed_ofb()
 
diff --git a/doc/man3/EVP_sm4_cbc.pod b/doc/man3/EVP_sm4_cbc.pod
index 4e02409..ecd51f0 100644
--- a/doc/man3/EVP_sm4_cbc.pod
+++ b/doc/man3/EVP_sm4_cbc.pod
@@ -5,6 +5,7 @@
 EVP_sm4_cbc,
 EVP_sm4_ecb,
 EVP_sm4_cfb,
+EVP_sm4_cfb128,
 EVP_sm4_ofb,
 EVP_sm4_ctr
 - EVP SM4 cipher
@@ -16,6 +17,7 @@ EVP_sm4_ctr
  const EVP_CIPHER *EVP_sm4_cbc(void);
  const EVP_CIPHER *EVP_sm4_ecb(void);
  const EVP_CIPHER *EVP_sm4_cfb(void);
+ const EVP_CIPHER *EVP_sm4_cfb128(void);
  const EVP_CIPHER *EVP_sm4_ofb(void);
  const EVP_CIPHER *EVP_sm4_ctr(void);
 
@@ -30,6 +32,7 @@ All modes below use a key length of 128 bits and acts on blocks of 128 bits.
 =item EVP_sm4_cbc(),
 EVP_sm4_ecb(),
 EVP_sm4_cfb(),
+EVP_sm4_cfb128(),
 EVP_sm4_ofb(),
 EVP_sm4_ctr()
 
diff --git a/include/openssl/ec.h b/include/openssl/ec.h
index 4d70da7..347cfb6 100644
--- a/include/openssl/ec.h
+++ b/include/openssl/ec.h
@@ -1107,6 +1107,11 @@ const EC_KEY_METHOD *EC_KEY_get_method(const EC_KEY *key);
 int EC_KEY_set_method(EC_KEY *key, const EC_KEY_METHOD *meth);
 EC_KEY *EC_KEY_new_method(ENGINE *engine);
 
+/** The old name for ecdh_KDF_X9_63
+ *  The ECDH KDF specification has been mistakingly attributed to ANSI X9.62,
+ *  it is actually specified in ANSI X9.63.
+ *  This identifier is retained for backwards compatibility
+ */
 int ECDH_KDF_X9_62(unsigned char *out, size_t outlen,
                    const unsigned char *Z, size_t Zlen,
                    const unsigned char *sinfo, size_t sinfolen,
@@ -1457,7 +1462,13 @@ void EC_KEY_METHOD_get_verify(const EC_KEY_METHOD *meth,
 # define EVP_PKEY_CTRL_GET1_ID_LEN                       (EVP_PKEY_ALG_CTRL + 13)
 /* KDF types */
 # define EVP_PKEY_ECDH_KDF_NONE                          1
-# define EVP_PKEY_ECDH_KDF_X9_62                         2
+# define EVP_PKEY_ECDH_KDF_X9_63                         2
+/** The old name for EVP_PKEY_ECDH_KDF_X9_63
+ *  The ECDH KDF specification has been mistakingly attributed to ANSI X9.62,
+ *  it is actually specified in ANSI X9.63.
+ *  This identifier is retained for backwards compatibility
+ */
+# define EVP_PKEY_ECDH_KDF_X9_62   EVP_PKEY_ECDH_KDF_X9_63
 
 
 #  ifdef  __cplusplus
diff --git a/util/private.num b/util/private.num
index 9aad2b2..c456578 100644
--- a/util/private.num
+++ b/util/private.num
@@ -190,8 +190,27 @@ EVP_MD_CTX_type                         define
 EVP_OpenUpdate                          define
 EVP_PKEY_CTX_add1_hkdf_info             define
 EVP_PKEY_CTX_add1_tls1_prf_seed         define
+EVP_PKEY_CTX_get0_dh_kdf_oid            define
+EVP_PKEY_CTX_get0_dh_kdf_ukm            define
+EVP_PKEY_CTX_get0_ecdh_kdf_ukm          define
+EVP_PKEY_CTX_get0_rsa_oaep_label        define
+EVP_PKEY_CTX_get_dh_kdf_md              define
+EVP_PKEY_CTX_get_dh_kdf_outlen          define
+EVP_PKEY_CTX_get_dh_kdf_type            define
+EVP_PKEY_CTX_get_ecdh_cofactor_mode     define
+EVP_PKEY_CTX_get_ecdh_kdf_md            define
+EVP_PKEY_CTX_get_ecdh_kdf_outlen        define
+EVP_PKEY_CTX_get_ecdh_kdf_type          define
+EVP_PKEY_CTX_get_rsa_mgf1_md            define
+EVP_PKEY_CTX_get_rsa_oaep_md            define
+EVP_PKEY_CTX_get_rsa_padding            define
+EVP_PKEY_CTX_get_rsa_pss_saltlen        define
 EVP_PKEY_CTX_get_signature_md           define
 EVP_PKEY_CTX_hkdf_mode                  define
+EVP_PKEY_CTX_set0_dh_kdf_oid            define
+EVP_PKEY_CTX_set0_dh_kdf_ukm            define
+EVP_PKEY_CTX_set0_ecdh_kdf_ukm          define
+EVP_PKEY_CTX_set0_rsa_oaep_label        define
 EVP_PKEY_CTX_set1_hkdf_key              define
 EVP_PKEY_CTX_set1_hkdf_salt             define
 EVP_PKEY_CTX_set1_pbe_pass              define
@@ -199,14 +218,29 @@ EVP_PKEY_CTX_set1_scrypt_salt           define
 EVP_PKEY_CTX_set1_tls1_prf_secret       define
 EVP_PKEY_CTX_set_dh_paramgen_generator  define
 EVP_PKEY_CTX_set_dh_paramgen_prime_len  define
-EVP_PKEY_CTX_set_dh_pad                 define
+EVP_PKEY_CTX_set_dh_paramgen_subprime_len     define
+EVP_PKEY_CTX_set_dh_paramgen_type       define
+EVP_PKEY_CTX_set_dh_kdf_md              define
+EVP_PKEY_CTX_set_dh_kdf_outlen          define
+EVP_PKEY_CTX_set_dh_kdf_type            define
 EVP_PKEY_CTX_set_dh_nid                 define
+EVP_PKEY_CTX_set_dh_pad                 define
+EVP_PKEY_CTX_set_dh_rfc5114             define
+EVP_PKEY_CTX_set_dhx_rfc5114            define
 EVP_PKEY_CTX_set_dsa_paramgen_bits      define
 EVP_PKEY_CTX_set_ec_param_enc           define
 EVP_PKEY_CTX_set_ec_paramgen_curve_nid  define
+EVP_PKEY_CTX_set_ecdh_cofactor_mode     define
+EVP_PKEY_CTX_set_ecdh_kdf_md            define
+EVP_PKEY_CTX_set_ecdh_kdf_outlen        define
+EVP_PKEY_CTX_set_ecdh_kdf_type          define
 EVP_PKEY_CTX_set_hkdf_md                define
 EVP_PKEY_CTX_set_mac_key                define
+EVP_PKEY_CTX_set_rsa_keygen_bits        define
 EVP_PKEY_CTX_set_rsa_keygen_pubexp      define
+EVP_PKEY_CTX_set_rsa_keygen_primes      define
+EVP_PKEY_CTX_set_rsa_mgf1_md            define
+EVP_PKEY_CTX_set_rsa_oaep_md            define
 EVP_PKEY_CTX_set_rsa_padding            define
 EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md define
 EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen define
@@ -221,7 +255,9 @@ EVP_PKEY_CTX_set_tls1_prf_md            define
 EVP_PKEY_assign_DH                      define
 EVP_PKEY_assign_DSA                     define
 EVP_PKEY_assign_EC_KEY                  define
+EVP_PKEY_assign_POLY1305                define
 EVP_PKEY_assign_RSA                     define
+EVP_PKEY_assign_SIPHASH                 define
 EVP_SealUpdate                          define
 EVP_SignInit                            define
 EVP_SignInit_ex                         define
@@ -269,7 +305,6 @@ PEM_FLAG_ONLY_B64                       define
 PEM_FLAG_SECURE                         define
 RAND_cleanup                            define deprecated 1.1.0
 RAND_DRBG_get_ex_new_index              define
-EVP_PKEY_CTX_set_rsa_keygen_bits        define
 SSL_COMP_free_compression_methods       define deprecated 1.1.0
 SSL_CTX_add0_chain_cert                 define
 SSL_CTX_add1_chain_cert                 define
</PRE>















































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020461.html">[openssl-commits] [openssl]  OpenSSL_1_1_1-stable update
</A></li>
	<LI>Next message: <A HREF="020472.html">[openssl-commits] [openssl]  OpenSSL_1_1_1-stable update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20463">[ date ]</a>
              <a href="thread.html#20463">[ thread ]</a>
              <a href="subject.html#20463">[ subject ]</a>
              <a href="author.html#20463">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
