<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2018-December/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1544006534.498406.22318.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020921.html">
   <LINK REL="Next"  HREF="020931.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1544006534.498406.22318.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Wed Dec  5 10:42:14 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="020921.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="020931.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20929">[ date ]</a>
              <a href="thread.html#20929">[ thread ]</a>
              <a href="subject.html#20929">[ subject ]</a>
              <a href="author.html#20929">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  3a4a88f436ed1dd1165e0b59c1ca4a25e9e1d690 (commit)
       via  3da2e9c4ee45989a426ff513dc6c6250d1e460de (commit)
       via  31703da3b8e743c07a9fdb6025aa526594c2a319 (commit)
       via  b34446cca2b1814fa674adc8076707d2b65a697f (commit)
      from  871493a2bed80310169ec4ba7cc428bc194623bf (commit)


- Log -----------------------------------------------------------------
commit 3a4a88f436ed1dd1165e0b59c1ca4a25e9e1d690
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Fri Nov 23 17:23:31 2018 +0100

    bn/bn_{div|shift}.c: introduce fixed-top interfaces.
    
    Fixed-top interfaces tolerate zero-padded inputs and facilitate
    constant-time-ness. bn_div_fixed_top tolerates zero-padded dividend,
    but not divisor. It's argued that divisor's length is public even
    when value is secret.
    
    [extended tests]
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7589">https://github.com/openssl/openssl/pull/7589</A>)

commit 3da2e9c4ee45989a426ff513dc6c6250d1e460de
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Wed Nov 7 22:18:33 2018 +0100

    bn/bn_div.c: make conditional addition unconditional
    
    and add template for constant-time bn_div_3_words.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7589">https://github.com/openssl/openssl/pull/7589</A>)

commit 31703da3b8e743c07a9fdb6025aa526594c2a319
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon Nov 12 15:13:48 2018 +0100

    Configure: recognize div3w modules and add -DBN_DIV3W.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7589">https://github.com/openssl/openssl/pull/7589</A>)

commit b34446cca2b1814fa674adc8076707d2b65a697f
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon Nov 12 15:03:39 2018 +0100

    Configurations/10-main.conf: remove MIPS bn_div_3_words.
    
    It's being replaced with constant-time alternative.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/7589">https://github.com/openssl/openssl/pull/7589</A>)

-----------------------------------------------------------------------

Summary of changes:
 Configurations/10-main.conf      |   5 +-
 Configure                        |   1 +
 crypto/bn/asm/mips.pl            |   6 +
 crypto/bn/bn_div.c               | 319 ++++++++++++++++++++++-----------------
 crypto/bn/bn_shift.c             | 130 +++++++++++++---
 crypto/include/internal/bn_int.h |   9 +-
 6 files changed, 301 insertions(+), 169 deletions(-)

diff --git a/Configurations/10-main.conf b/Configurations/10-main.conf
index d86691c..6506203 100644
--- a/Configurations/10-main.conf
+++ b/Configurations/10-main.conf
@@ -360,7 +360,7 @@ my %targets = (
         inherit_from     =&gt; [ &quot;BASE_unix&quot; ],
         template         =&gt; 1,
         cppflags         =&gt; threads(&quot;-D_SGI_MP_SOURCE&quot;),
-        lib_cppflags     =&gt; &quot;-DB_ENDIAN -DBN_DIV3W&quot;,
+        lib_cppflags     =&gt; &quot;-DB_ENDIAN&quot;,
         ex_libs          =&gt; add(threads(&quot;-lpthread&quot;)),
         thread_scheme    =&gt; &quot;pthreads&quot;,
         dso_scheme       =&gt; &quot;dlfcn&quot;,
@@ -733,7 +733,6 @@ my %targets = (
         inherit_from     =&gt; [ &quot;linux-generic32&quot;, asm(&quot;mips32_asm&quot;) ],
         cflags           =&gt; add(&quot;-mabi=32&quot;),
         cxxflags         =&gt; add(&quot;-mabi=32&quot;),
-        lib_cppflags     =&gt; add(&quot;-DBN_DIV3W&quot;),
         perlasm_scheme   =&gt; &quot;o32&quot;,
     },
     # mips32 and mips64 below refer to contemporary MIPS Architecture
@@ -742,7 +741,6 @@ my %targets = (
         inherit_from     =&gt; [ &quot;linux-generic32&quot;, asm(&quot;mips64_asm&quot;) ],
         cflags           =&gt; add(&quot;-mabi=n32&quot;),
         cxxflags         =&gt; add(&quot;-mabi=n32&quot;),
-        lib_cppflags     =&gt; add(&quot;-DBN_DIV3W&quot;),
         bn_ops           =&gt; &quot;SIXTY_FOUR_BIT RC4_CHAR&quot;,
         perlasm_scheme   =&gt; &quot;n32&quot;,
         multilib         =&gt; &quot;32&quot;,
@@ -751,7 +749,6 @@ my %targets = (
         inherit_from     =&gt; [ &quot;linux-generic64&quot;, asm(&quot;mips64_asm&quot;) ],
         cflags           =&gt; add(&quot;-mabi=64&quot;),
         cxxflags         =&gt; add(&quot;-mabi=64&quot;),
-        lib_cppflags     =&gt; add(&quot;-DBN_DIV3W&quot;),
         perlasm_scheme   =&gt; &quot;64&quot;,
         multilib         =&gt; &quot;64&quot;,
     },
diff --git a/Configure b/Configure
index cc061dc..65bbec1 100755
--- a/Configure
+++ b/Configure
@@ -1354,6 +1354,7 @@ unless ($disabled{asm}) {
     push @{$config{lib_defines}}, &quot;OPENSSL_BN_ASM_MONT&quot; if ($target{bn_asm_src} =~ /-mont/);
     push @{$config{lib_defines}}, &quot;OPENSSL_BN_ASM_MONT5&quot; if ($target{bn_asm_src} =~ /-mont5/);
     push @{$config{lib_defines}}, &quot;OPENSSL_BN_ASM_GF2m&quot; if ($target{bn_asm_src} =~ /-gf2m/);
+    push @{$config{lib_defines}}, &quot;BN_DIV3W&quot; if ($target{bn_asm_src} =~ /-div3w/);
 
     if ($target{sha1_asm_src}) {
 	push @{$config{lib_defines}}, &quot;SHA1_ASM&quot;   if ($target{sha1_asm_src} =~ /sx86/ || $target{sha1_asm_src} =~ /sha1/);
diff --git a/crypto/bn/asm/mips.pl b/crypto/bn/asm/mips.pl
index da35ec1..3875132 100644
--- a/crypto/bn/asm/mips.pl
+++ b/crypto/bn/asm/mips.pl
@@ -798,6 +798,11 @@ $code.=&lt;&lt;___;
 	move	$a0,$v0
 .end	bn_sub_words_internal
 
+#if 0
+/*
+ * The bn_div_3_words entry point is re-used for constant-time interface.
+ * Implementation is retained as hystorical reference.
+ */
 .align 5
 .globl	bn_div_3_words
 .ent	bn_div_3_words
@@ -877,6 +882,7 @@ $code.=&lt;&lt;___;
 	jr	$ra
 	move	$a0,$v0
 .end	bn_div_3_words_internal
+#endif
 
 .align	5
 .globl	bn_div_words
diff --git a/crypto/bn/bn_div.c b/crypto/bn/bn_div.c
index 70add10..3a6fa0a 100644
--- a/crypto/bn/bn_div.c
+++ b/crypto/bn/bn_div.c
@@ -7,6 +7,7 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
+#include &lt;assert.h&gt;
 #include &lt;openssl/bn.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;bn_lcl.h&quot;
@@ -86,6 +87,77 @@ int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d,
 
 #else
 
+# if defined(BN_DIV3W)
+BN_ULONG bn_div_3_words(const BN_ULONG *m, BN_ULONG d1, BN_ULONG d0);
+# elif 0
+/*
+ * This is #if-ed away, because it's a reference for assembly implementations,
+ * where it can and should be made constant-time. But if you want to test it,
+ * just replace 0 with 1.
+ */
+#  if BN_BITS2 == 64 &amp;&amp; defined(__SIZEOF_INT128__) &amp;&amp; __SIZEOF_INT128__==16
+#   undef BN_ULLONG
+#   define BN_ULLONG __uint128_t
+#   define BN_LLONG
+#  endif
+
+#  ifdef BN_LLONG
+#   define BN_DIV3W
+/*
+ * Interface is somewhat quirky, |m| is pointer to most significant limb,
+ * and less significant limb is referred at |m[-1]|. This means that caller
+ * is responsible for ensuring that |m[-1]| is valid. Second condition that
+ * has to be met is that |d0|'s most significant bit has to be set. Or in
+ * other words divisor has to be &quot;bit-aligned to the left.&quot; bn_div_fixed_top
+ * does all this. The subroutine considers four limbs, two of which are
+ * &quot;overlapping,&quot; hence the name...
+ */
+static BN_ULONG bn_div_3_words(const BN_ULONG *m, BN_ULONG d1, BN_ULONG d0)
+{
+    BN_ULLONG R = ((BN_ULLONG)m[0] &lt;&lt; BN_BITS2) | m[-1];
+    BN_ULLONG D = ((BN_ULLONG)d0 &lt;&lt; BN_BITS2) | d1;
+    BN_ULONG Q = 0, mask;
+    int i;
+
+    for (i = 0; i &lt; BN_BITS2; i++) {
+        Q &lt;&lt;= 1;
+        if (R &gt;= D) {
+            Q |= 1;
+            R -= D;
+        }
+        D &gt;&gt;= 1;
+    }
+
+    mask = 0 - (Q &gt;&gt; (BN_BITS2 - 1));   /* does it overflow? */
+
+    Q &lt;&lt;= 1;
+    Q |= (R &gt;= D);
+
+    return (Q | mask) &amp; BN_MASK2;
+}
+#  endif
+# endif
+
+static int bn_left_align(BIGNUM *num)
+{
+    BN_ULONG *d = num-&gt;d, n, m, rmask;
+    int top = num-&gt;top;
+    int rshift = BN_num_bits_word(d[top - 1]), lshift, i;
+
+    lshift = BN_BITS2 - rshift;
+    rshift %= BN_BITS2;            /* say no to undefined behaviour */
+    rmask = (BN_ULONG)0 - rshift;  /* rmask = 0 - (rshift != 0) */
+    rmask |= rmask &gt;&gt; 8;
+
+    for (i = 0, m = 0; i &lt; top; i++) {
+        n = d[i];
+        d[i] = ((n &lt;&lt; lshift) | m) &amp; BN_MASK2;
+        m = (n &gt;&gt; rshift) &amp; rmask;
+    }
+
+    return lshift;
+}
+
 # if !defined(OPENSSL_NO_ASM) &amp;&amp; !defined(OPENSSL_NO_INLINE_ASM) \
     &amp;&amp; !defined(PEDANTIC) &amp;&amp; !defined(BN_DIV3W)
 #  if defined(__GNUC__) &amp;&amp; __GNUC__&gt;=2
@@ -137,55 +209,73 @@ int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d,
 int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
            BN_CTX *ctx)
 {
-    int norm_shift, i, loop;
-    BIGNUM *tmp, wnum, *snum, *sdiv, *res;
-    BN_ULONG *resp, *wnump;
-    BN_ULONG d0, d1;
-    int num_n, div_n;
-    int no_branch = 0;
+    int ret;
+
+    if (BN_is_zero(divisor)) {
+        BNerr(BN_F_BN_DIV, BN_R_DIV_BY_ZERO);
+        return 0;
+    }
 
     /*
      * Invalid zero-padding would have particularly bad consequences so don't
      * just rely on bn_check_top() here (bn_check_top() works only for
      * BN_DEBUG builds)
      */
-    if ((num-&gt;top &gt; 0 &amp;&amp; num-&gt;d[num-&gt;top - 1] == 0) ||
-        (divisor-&gt;top &gt; 0 &amp;&amp; divisor-&gt;d[divisor-&gt;top - 1] == 0)) {
+    if (divisor-&gt;d[divisor-&gt;top - 1] == 0) {
         BNerr(BN_F_BN_DIV, BN_R_NOT_INITIALIZED);
         return 0;
     }
 
-    bn_check_top(num);
-    bn_check_top(divisor);
+    ret = bn_div_fixed_top(dv, rm, num, divisor, ctx);
 
-    if ((BN_get_flags(num, BN_FLG_CONSTTIME) != 0)
-        || (BN_get_flags(divisor, BN_FLG_CONSTTIME) != 0)) {
-        no_branch = 1;
+    if (ret) {
+        if (dv != NULL)
+            bn_correct_top(dv);
+        if (rm != NULL)
+            bn_correct_top(rm);
     }
 
-    bn_check_top(dv);
-    bn_check_top(rm);
-    /*- bn_check_top(num); *//*
-     * 'num' has been checked already
-     */
-    /*- bn_check_top(divisor); *//*
-     * 'divisor' has been checked already
-     */
+    return ret;
+}
 
-    if (BN_is_zero(divisor)) {
-        BNerr(BN_F_BN_DIV, BN_R_DIV_BY_ZERO);
-        return 0;
-    }
+/*
+ * It's argued that *length* of *significant* part of divisor is public.
+ * Even if it's private modulus that is. Again, *length* is assumed
+ * public, but not *value*. Former is likely to be pre-defined by
+ * algorithm with bit granularity, though below subroutine is invariant
+ * of limb length. Thanks to this assumption we can require that |divisor|
+ * may not be zero-padded, yet claim this subroutine &quot;constant-time&quot;(*).
+ * This is because zero-padded dividend, |num|, is tolerated, so that
+ * caller can pass dividend of public length(*), but with smaller amount
+ * of significant limbs. This naturally means that quotient, |dv|, would
+ * contain correspongly less significant limbs as well, and will be zero-
+ * padded accordingly. Returned remainder, |rm|, will have same bit length
+ * as divisor, also zero-padded if needed. These actually leave sign bits
+ * in ambiguous state. In sense that we try to avoid negative zeros, while
+ * zero-padded zeros would retain sign.
+ *
+ * (*) &quot;Constant-time-ness&quot; has two pre-conditions:
+ *
+ *     - availability of constant-time bn_div_3_words;
+ *     - dividend is at least as &quot;wide&quot; as divisor, limb-wise, zero-padded
+ *       if so requied, which shouldn't be a privacy problem, because
+ *       divisor's length is considered public;
+ */
+int bn_div_fixed_top(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num,
+                     const BIGNUM *divisor, BN_CTX *ctx)
+{
+    int norm_shift, i, j, loop;
+    BIGNUM *tmp, *snum, *sdiv, *res;
+    BN_ULONG *resp, *wnum, *wnumtop;
+    BN_ULONG d0, d1;
+    int num_n, div_n;
 
-    if (!no_branch &amp;&amp; BN_ucmp(num, divisor) &lt; 0) {
-        if (rm != NULL) {
-            if (BN_copy(rm, num) == NULL)
-                return 0;
-        }
-        if (dv != NULL)
-            BN_zero(dv);
-        return 1;
-    }
+    assert(divisor-&gt;top &gt; 0 &amp;&amp; divisor-&gt;d[divisor-&gt;top - 1] != 0);
+
+    bn_check_top(num);
+    bn_check_top(divisor);
+    bn_check_top(dv);
+    bn_check_top(rm);
 
     BN_CTX_start(ctx);
     res = (dv == NULL) ? BN_CTX_get(ctx) : dv;
@@ -196,113 +286,72 @@ int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
         goto err;
 
     /* First we normalise the numbers */
-    norm_shift = BN_BITS2 - ((BN_num_bits(divisor)) % BN_BITS2);
-    if (!(BN_lshift(sdiv, divisor, norm_shift)))
+    if (!BN_copy(sdiv, divisor))
         goto err;
+    norm_shift = bn_left_align(sdiv);
     sdiv-&gt;neg = 0;
-    norm_shift += BN_BITS2;
-    if (!(BN_lshift(snum, num, norm_shift)))
+    /*
+     * Note that bn_lshift_fixed_top's output is always one limb longer
+     * than input, even when norm_shift is zero. This means that amount of
+     * inner loop iterations is invariant of dividend value, and that one
+     * doesn't need to compare dividend and divisor if they were originally
+     * of the same bit length.
+     */
+    if (!(bn_lshift_fixed_top(snum, num, norm_shift)))
         goto err;
-    snum-&gt;neg = 0;
-
-    if (no_branch) {
-        /*
-         * Since we don't know whether snum is larger than sdiv, we pad snum
-         * with enough zeroes without changing its value.
-         */
-        if (snum-&gt;top &lt;= sdiv-&gt;top + 1) {
-            if (bn_wexpand(snum, sdiv-&gt;top + 2) == NULL)
-                goto err;
-            for (i = snum-&gt;top; i &lt; sdiv-&gt;top + 2; i++)
-                snum-&gt;d[i] = 0;
-            snum-&gt;top = sdiv-&gt;top + 2;
-        } else {
-            if (bn_wexpand(snum, snum-&gt;top + 1) == NULL)
-                goto err;
-            snum-&gt;d[snum-&gt;top] = 0;
-            snum-&gt;top++;
-        }
-    }
 
     div_n = sdiv-&gt;top;
     num_n = snum-&gt;top;
+
+    if (num_n &lt;= div_n) {
+        /* caller didn't pad dividend -&gt; no constant-time guarantee... */
+        if (bn_wexpand(snum, div_n + 1) == NULL)
+            goto err;
+        memset(&amp;(snum-&gt;d[num_n]), 0, (div_n - num_n + 1) * sizeof(BN_ULONG));
+        snum-&gt;top = num_n = div_n + 1;
+    }
+
     loop = num_n - div_n;
     /*
      * Lets setup a 'window' into snum This is the part that corresponds to
      * the current 'area' being divided
      */
-    wnum.neg = 0;
-    wnum.d = &amp;(snum-&gt;d[loop]);
-    wnum.top = div_n;
-    wnum.flags = BN_FLG_STATIC_DATA;
-    /*
-     * only needed when BN_ucmp messes up the values between top and max
-     */
-    wnum.dmax = snum-&gt;dmax - loop; /* so we don't step out of bounds */
+    wnum = &amp;(snum-&gt;d[loop]);
+    wnumtop = &amp;(snum-&gt;d[num_n - 1]);
 
     /* Get the top 2 words of sdiv */
-    /* div_n=sdiv-&gt;top; */
     d0 = sdiv-&gt;d[div_n - 1];
     d1 = (div_n == 1) ? 0 : sdiv-&gt;d[div_n - 2];
 
-    /* pointer to the 'top' of snum */
-    wnump = &amp;(snum-&gt;d[num_n - 1]);
-
-    /* Setup to 'res' */
-    if (!bn_wexpand(res, (loop + 1)))
+    /* Setup quotient */
+    if (!bn_wexpand(res, loop))
         goto err;
     res-&gt;neg = (num-&gt;neg ^ divisor-&gt;neg);
-    res-&gt;top = loop - no_branch;
-    resp = &amp;(res-&gt;d[loop - 1]);
+    res-&gt;top = loop;
+    res-&gt;flags |= BN_FLG_FIXED_TOP;
+    resp = &amp;(res-&gt;d[loop]);
 
     /* space for temp */
     if (!bn_wexpand(tmp, (div_n + 1)))
         goto err;
 
-    if (!no_branch) {
-        if (BN_ucmp(&amp;wnum, sdiv) &gt;= 0) {
-            /*
-             * If BN_DEBUG_RAND is defined BN_ucmp changes (via bn_pollute)
-             * the const bignum arguments =&gt; clean the values between top and
-             * max again
-             */
-            bn_clear_top2max(&amp;wnum);
-            bn_sub_words(wnum.d, wnum.d, sdiv-&gt;d, div_n);
-            *resp = 1;
-        } else
-            res-&gt;top--;
-    }
-
-    /* Increase the resp pointer so that we never create an invalid pointer. */
-    resp++;
-
-    /*
-     * if res-&gt;top == 0 then clear the neg value otherwise decrease the resp
-     * pointer
-     */
-    if (res-&gt;top == 0)
-        res-&gt;neg = 0;
-    else
-        resp--;
-
-    for (i = 0; i &lt; loop - 1; i++, wnump--) {
+    for (i = 0; i &lt; loop; i++, wnumtop--) {
         BN_ULONG q, l0;
         /*
          * the first part of the loop uses the top two words of snum and sdiv
          * to calculate a BN_ULONG q such that | wnum - sdiv * q | &lt; sdiv
          */
-# if defined(BN_DIV3W) &amp;&amp; !defined(OPENSSL_NO_ASM)
-        BN_ULONG bn_div_3_words(BN_ULONG *, BN_ULONG, BN_ULONG);
-        q = bn_div_3_words(wnump, d1, d0);
+# if defined(BN_DIV3W)
+        q = bn_div_3_words(wnumtop, d1, d0);
 # else
         BN_ULONG n0, n1, rem = 0;
 
-        n0 = wnump[0];
-        n1 = wnump[-1];
+        n0 = wnumtop[0];
+        n1 = wnumtop[-1];
         if (n0 == d0)
             q = BN_MASK2;
         else {                  /* n0 &lt; d0 */
-
+            BN_ULONG n2 = (wnumtop == wnum) ? 0 : wnumtop[-2];
 #  ifdef BN_LLONG
             BN_ULLONG t2;
 
@@ -322,7 +371,7 @@ int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
             t2 = (BN_ULLONG) d1 *q;
 
             for (;;) {
-                if (t2 &lt;= ((((BN_ULLONG) rem) &lt;&lt; BN_BITS2) | wnump[-2]))
+                if (t2 &lt;= ((((BN_ULLONG) rem) &lt;&lt; BN_BITS2) | n2))
                     break;
                 q--;
                 rem += d0;
@@ -355,7 +404,7 @@ int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
 #   endif
 
             for (;;) {
-                if ((t2h &lt; rem) || ((t2h == rem) &amp;&amp; (t2l &lt;= wnump[-2])))
+                if ((t2h &lt; rem) || ((t2h == rem) &amp;&amp; (t2l &lt;= n2)))
                     break;
                 q--;
                 rem += d0;
@@ -371,43 +420,33 @@ int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,
 
         l0 = bn_mul_words(tmp-&gt;d, sdiv-&gt;d, div_n, q);
         tmp-&gt;d[div_n] = l0;
-        wnum.d--;
+        wnum--;
         /*
-         * ingore top values of the bignums just sub the two BN_ULONG arrays
+         * ignore top values of the bignums just sub the two BN_ULONG arrays
          * with bn_sub_words
          */
-        if (bn_sub_words(wnum.d, wnum.d, tmp-&gt;d, div_n + 1)) {
-            /*
-             * Note: As we have considered only the leading two BN_ULONGs in
-             * the calculation of q, sdiv * q might be greater than wnum (but
-             * then (q-1) * sdiv is less or equal than wnum)
-             */
-            q--;
-            if (bn_add_words(wnum.d, wnum.d, sdiv-&gt;d, div_n))
-                /*
-                 * we can't have an overflow here (assuming that q != 0, but
-                 * if q == 0 then tmp is zero anyway)
-                 */
-                (*wnump)++;
-        }
-        /* store part of the result */
-        resp--;
-        *resp = q;
-    }
-    bn_correct_top(snum);
-    if (rm != NULL) {
+        l0 = bn_sub_words(wnum, wnum, tmp-&gt;d, div_n + 1);
+        q -= l0;
         /*
-         * Keep a copy of the neg flag in num because if rm==num BN_rshift()
-         * will overwrite it.
+         * Note: As we have considered only the leading two BN_ULONGs in
+         * the calculation of q, sdiv * q might be greater than wnum (but
+         * then (q-1) * sdiv is less or equal than wnum)
          */
-        int neg = num-&gt;neg;
-        BN_rshift(rm, snum, norm_shift);
-        if (!BN_is_zero(rm))
-            rm-&gt;neg = neg;
-        bn_check_top(rm);
+        for (l0 = 0 - l0, j = 0; j &lt; div_n; j++)
+            tmp-&gt;d[j] = sdiv-&gt;d[j] &amp; l0;
+        l0 = bn_add_words(wnum, wnum, tmp-&gt;d, div_n);
+        (*wnumtop) += l0;
+        assert((*wnumtop) == 0);
+
+        /* store part of the result */
+        *--resp = q;
     }
-    if (no_branch)
-        bn_correct_top(res);
+    /* snum holds remainder, it's as wide as divisor */
+    snum-&gt;neg = num-&gt;neg;
+    snum-&gt;top = div_n;
+    snum-&gt;flags |= BN_FLG_FIXED_TOP;
+    if (rm != NULL)
+        bn_rshift_fixed_top(rm, snum, norm_shift);
     BN_CTX_end(ctx);
     return 1;
  err:
diff --git a/crypto/bn/bn_shift.c b/crypto/bn/bn_shift.c
index 15d4b32..b7a1e0f 100644
--- a/crypto/bn/bn_shift.c
+++ b/crypto/bn/bn_shift.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2018 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -7,6 +7,7 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
+#include &lt;assert.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;bn_lcl.h&quot;
 
@@ -82,40 +83,70 @@ int BN_rshift1(BIGNUM *r, const BIGNUM *a)
 
 int BN_lshift(BIGNUM *r, const BIGNUM *a, int n)
 {
-    int i, nw, lb, rb;
-    BN_ULONG *t, *f;
-    BN_ULONG l;
-
-    bn_check_top(r);
-    bn_check_top(a);
+    int ret;
 
     if (n &lt; 0) {
         BNerr(BN_F_BN_LSHIFT, BN_R_INVALID_SHIFT);
         return 0;
     }
 
+    ret = bn_lshift_fixed_top(r, a, n);
+
+    bn_correct_top(r);
+    bn_check_top(r);
+
+    return ret;
+}
+
+/*
+ * In respect to shift factor the execution time is invariant of
+ * |n % BN_BITS2|, but not |n / BN_BITS2|. Or in other words pre-condition
+ * for constant-time-ness is |n &lt; BN_BITS2| or |n / BN_BITS2| being
+ * non-secret.
+ */
+int bn_lshift_fixed_top(BIGNUM *r, const BIGNUM *a, int n)
+{
+    int i, nw;
+    unsigned int lb, rb;
+    BN_ULONG *t, *f;
+    BN_ULONG l, m, rmask = 0;
+
+    assert(n &gt;= 0);
+
+    bn_check_top(r);
+    bn_check_top(a);
+
     nw = n / BN_BITS2;
     if (bn_wexpand(r, a-&gt;top + nw + 1) == NULL)
         return 0;
-    r-&gt;neg = a-&gt;neg;
-    lb = n % BN_BITS2;
-    rb = BN_BITS2 - lb;
-    f = a-&gt;d;
-    t = r-&gt;d;
-    t[a-&gt;top + nw] = 0;
-    if (lb == 0)
-        for (i = a-&gt;top - 1; i &gt;= 0; i--)
-            t[nw + i] = f[i];
-    else
-        for (i = a-&gt;top - 1; i &gt;= 0; i--) {
-            l = f[i];
-            t[nw + i + 1] |= (l &gt;&gt; rb) &amp; BN_MASK2;
-            t[nw + i] = (l &lt;&lt; lb) &amp; BN_MASK2;
+
+    if (a-&gt;top != 0) {
+        lb = (unsigned int)n % BN_BITS2;
+        rb = BN_BITS2 - lb;
+        rb %= BN_BITS2;            /* say no to undefined behaviour */
+        rmask = (BN_ULONG)0 - rb;  /* rmask = 0 - (rb != 0) */
+        rmask |= rmask &gt;&gt; 8;
+        f = &amp;(a-&gt;d[0]);
+        t = &amp;(r-&gt;d[nw]);
+        l = f[a-&gt;top - 1];
+        t[a-&gt;top] = (l &gt;&gt; rb) &amp; rmask;
+        for (i = a-&gt;top - 1; i &gt; 0; i--) {
+            m = l &lt;&lt; lb;
+            l = f[i - 1];
+            t[i] = (m | ((l &gt;&gt; rb) &amp; rmask)) &amp; BN_MASK2;
         }
-    memset(t, 0, sizeof(*t) * nw);
+        t[0] = (l &lt;&lt; lb) &amp; BN_MASK2;
+    } else {
+        /* shouldn't happen, but formally required */
+        r-&gt;d[nw] = 0;
+    }
+    if (nw != 0)
+        memset(r-&gt;d, 0, sizeof(*t) * nw);
+
+    r-&gt;neg = a-&gt;neg;
     r-&gt;top = a-&gt;top + nw + 1;
-    bn_correct_top(r);
-    bn_check_top(r);
+    r-&gt;flags |= BN_FLG_FIXED_TOP;
+
     return 1;
 }
 
@@ -173,3 +204,54 @@ int BN_rshift(BIGNUM *r, const BIGNUM *a, int n)
     bn_check_top(r);
     return 1;
 }
+
+/*
+ * In respect to shift factor the execution time is invariant of
+ * |n % BN_BITS2|, but not |n / BN_BITS2|. Or in other words pre-condition
+ * for constant-time-ness for sufficiently[!] zero-padded inputs is
+ * |n &lt; BN_BITS2| or |n / BN_BITS2| being non-secret.
+ */
+int bn_rshift_fixed_top(BIGNUM *r, const BIGNUM *a, int n)
+{
+    int i, top, nw;
+    unsigned int lb, rb;
+    BN_ULONG *t, *f;
+    BN_ULONG l, m, mask;
+
+    bn_check_top(r);
+    bn_check_top(a);
+
+    assert(n &gt;= 0);
+
+    nw = n / BN_BITS2;
+    if (nw &gt;= a-&gt;top) {
+        /* shouldn't happen, but formally required */
+        BN_zero(r);
+        return 1;
+    }
+
+    rb = (unsigned int)n % BN_BITS2;
+    lb = BN_BITS2 - rb;
+    lb %= BN_BITS2;            /* say no to undefined behaviour */
+    mask = (BN_ULONG)0 - lb;   /* mask = 0 - (lb != 0) */
+    mask |= mask &gt;&gt; 8;
+    top = a-&gt;top - nw;
+    if (r != a &amp;&amp; bn_wexpand(r, top) == NULL)
+        return 0;
+
+    t = &amp;(r-&gt;d[0]);
+    f = &amp;(a-&gt;d[nw]);
+    l = f[0];
+    for (i = 0; i &lt; top - 1; i++) {
+        m = f[i + 1];
+        t[i] = (l &gt;&gt; rb) | ((m &lt;&lt; lb) &amp; mask);
+        l = m;
+    }
+    t[i] = l &gt;&gt; rb;
+
+    r-&gt;neg = a-&gt;neg;
+    r-&gt;top = top;
+    r-&gt;flags |= BN_FLG_FIXED_TOP;
+
+    return 1;
+}
diff --git a/crypto/include/internal/bn_int.h b/crypto/include/internal/bn_int.h
index cffe5cf..30be7ef 100644
--- a/crypto/include/internal/bn_int.h
+++ b/crypto/include/internal/bn_int.h
@@ -65,7 +65,10 @@ int bn_set_words(BIGNUM *a, const BN_ULONG *words, int num_words);
  * is customarily arranged by bn_correct_top. Output from below functions
  * is not processed with bn_correct_top, and for this reason it may not be
  * returned out of public API. It may only be passed internally into other
- * functions known to support non-minimal or zero-padded BIGNUMs.
+ * functions known to support non-minimal or zero-padded BIGNUMs. Even
+ * though the goal is to facilitate constant-time-ness, not each subroutine
+ * is constant-time by itself. They all have pre-conditions, consult source
+ * code...
  */
 int bn_mul_mont_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                           BN_MONT_CTX *mont, BN_CTX *ctx);
@@ -79,5 +82,9 @@ int bn_mod_sub_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                          const BIGNUM *m);
 int bn_mul_fixed_top(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
 int bn_sqr_fixed_top(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx);
+int bn_lshift_fixed_top(BIGNUM *r, const BIGNUM *a, int n);
+int bn_rshift_fixed_top(BIGNUM *r, const BIGNUM *a, int n);
+int bn_div_fixed_top(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m,
+                     const BIGNUM *d, BN_CTX *ctx);
 
 #endif
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020921.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="020931.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20929">[ date ]</a>
              <a href="thread.html#20929">[ thread ]</a>
              <a href="subject.html#20929">[ subject ]</a>
              <a href="author.html#20929">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
