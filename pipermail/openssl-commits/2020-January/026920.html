<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-January/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1578280124.235040.10445.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="026930.html">
   <LINK REL="Next"  HREF="026921.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>shane.lontis at oracle.com</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1578280124.235040.10445.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">shane.lontis at oracle.com
       </A><BR>
    <I>Mon Jan  6 03:08:44 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="026930.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="026921.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26920">[ date ]</a>
              <a href="thread.html#26920">[ thread ]</a>
              <a href="subject.html#26920">[ subject ]</a>
              <a href="author.html#26920">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  0d2bfe52bb7e839f7bddcdb1160c335f2994df2f (commit)
      from  26583f6aa8dc28e3598e61db66e54e2fdf8b195f (commit)


- Log -----------------------------------------------------------------
commit 0d2bfe52bb7e839f7bddcdb1160c335f2994df2f
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Mon Jan 6 13:02:16 2020 +1000

    Add AES_CBC_HMAC_SHA ciphers to providers.
    
    Also Add ability for providers to dynamically exclude cipher algorithms.
    Cipher algorithms are only returned from providers if their capable() method is either NULL,
    or the method returns 1.
    This is mainly required for ciphers that only have hardware implementations.
    If there is no hardware support, then the algorithm needs to be not available.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10146">https://github.com/openssl/openssl/pull/10146</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/aes/build.info                              |   2 -
 crypto/evp/evp_enc.c                               |  85 ++-
 doc/man7/provider-cipher.pod                       |  49 ++
 include/crypto/aes_platform.h                      |   7 +
 include/openssl/core_names.h                       |  16 +
 providers/common/include/prov/provider_util.h      |  12 +
 providers/common/include/prov/providercommon.h     |   2 +
 providers/common/provider_util.c                   |  14 +
 providers/defltprov.c                              | 317 ++++----
 providers/fips/fipsprov.c                          |  89 ++-
 providers/implementations/ciphers/build.info       |   6 +-
 .../ciphers/cipher_aes_cbc_hmac_sha.c              | 345 +++++++++
 .../ciphers/cipher_aes_cbc_hmac_sha.h              |  65 ++
 .../ciphers/cipher_aes_cbc_hmac_sha1_hw.c          | 782 +++++++++++++++++++
 .../ciphers/cipher_aes_cbc_hmac_sha256_hw.c        | 831 +++++++++++++++++++++
 .../implementations/include/prov/implementations.h |   4 +
 test/sslapitest.c                                  | 100 +++
 17 files changed, 2529 insertions(+), 197 deletions(-)
 create mode 100644 providers/implementations/ciphers/cipher_aes_cbc_hmac_sha.c
 create mode 100644 providers/implementations/ciphers/cipher_aes_cbc_hmac_sha.h
 create mode 100644 providers/implementations/ciphers/cipher_aes_cbc_hmac_sha1_hw.c
 create mode 100644 providers/implementations/ciphers/cipher_aes_cbc_hmac_sha256_hw.c

diff --git a/crypto/aes/build.info b/crypto/aes/build.info
index 291bf2af9b..dc00df0cda 100644
--- a/crypto/aes/build.info
+++ b/crypto/aes/build.info
@@ -68,8 +68,6 @@ SOURCE[../../providers/libfips.a]=$COMMON
 DEFINE[../../libcrypto]=$AESDEF
 DEFINE[../../providers/libfips.a]=$AESDEF
 DEFINE[../../providers/libimplementations.a]=$AESDEF
-# fipsprov.c needs access to AESNI.
-DEFINE[../../providers/fips]=$AESDEF
 
 GENERATE[aes-ia64.s]=asm/aes-ia64.S
 
diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
index 3896cff34d..c650addbd1 100644
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -174,6 +174,10 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
         case NID_aes_256_siv:
         case NID_aes_192_siv:
         case NID_aes_128_siv:
+        case NID_aes_256_cbc_hmac_sha256:
+        case NID_aes_128_cbc_hmac_sha256:
+        case NID_aes_256_cbc_hmac_sha1:
+        case NID_aes_128_cbc_hmac_sha1:
         case NID_id_aes256_wrap:
         case NID_id_aes256_wrap_pad:
         case NID_id_aes192_wrap:
@@ -1086,7 +1090,9 @@ int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
     int set_params = 1;
     size_t sz = arg;
     unsigned int i;
-    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
+    OSSL_PARAM params[4] = {
+        OSSL_PARAM_END, OSSL_PARAM_END, OSSL_PARAM_END, OSSL_PARAM_END
+    };
 
     if (ctx == NULL || ctx-&gt;cipher == NULL) {
         EVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_NO_CIPHER_SET);
@@ -1154,13 +1160,8 @@ int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
         params[0] = OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_TAG,
                                                       ptr, sz);
         break;
-    case EVP_CTRL_AEAD_SET_MAC_KEY:
-        params[0] =
-            OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_MAC_KEY,
-                                              ptr, sz);
-        break;
     case EVP_CTRL_AEAD_TLS1_AAD:
-        /* This one does a set and a get - since it returns a padding size */
+        /* This one does a set and a get - since it returns a size */
         params[0] =
             OSSL_PARAM_construct_octet_string(OSSL_CIPHER_PARAM_AEAD_TLS1_AAD,
                                               ptr, sz);
@@ -1180,6 +1181,76 @@ int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
         params[0] = OSSL_PARAM_construct_size_t(OSSL_CIPHER_PARAM_RC2_KEYBITS, &amp;sz);
         break;
 #endif /* OPENSSL_NO_RC2 */
+#if !defined(OPENSSL_NO_MULTIBLOCK)
+    case EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE:
+        params[0] = OSSL_PARAM_construct_size_t(
+                OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_SEND_FRAGMENT, &amp;sz);
+        ret = evp_do_ciph_ctx_setparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+        if (ret &lt;= 0)
+            return 0;
+
+        params[0] = OSSL_PARAM_construct_size_t(
+                OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_BUFSIZE, &amp;sz);
+        params[1] = OSSL_PARAM_construct_end();
+        ret = evp_do_ciph_ctx_getparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+        if (ret &lt;= 0)
+            return 0;
+        return sz;
+    case EVP_CTRL_TLS1_1_MULTIBLOCK_AAD: {
+        EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *p =
+            (EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *)ptr;
+
+        if (arg &lt; (int)sizeof(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM))
+            return 0;
+
+        params[0] = OSSL_PARAM_construct_octet_string(
+                OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD, (void*)p-&gt;inp, p-&gt;len);
+        params[1] = OSSL_PARAM_construct_uint(
+                OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE, &amp;p-&gt;interleave);
+        ret = evp_do_ciph_ctx_setparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+        if (ret &lt;= 0)
+            return ret;
+        /* Retrieve the return values changed by the set */
+        params[0] = OSSL_PARAM_construct_size_t(
+                OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD_PACKLEN, &amp;sz);
+        params[1] = OSSL_PARAM_construct_uint(
+                OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE, &amp;p-&gt;interleave);
+        params[2] = OSSL_PARAM_construct_end();
+        ret = evp_do_ciph_ctx_getparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+        if (ret &lt;= 0)
+            return 0;
+        return sz;
+    }
+    case EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT: {
+        EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *p =
+            (EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *)ptr;
+
+        params[0] = OSSL_PARAM_construct_octet_string(
+                        OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC, p-&gt;out, p-&gt;len);
+
+        params[1] = OSSL_PARAM_construct_octet_string(
+                OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_IN, (void*)p-&gt;inp,
+                p-&gt;len);
+        params[2] = OSSL_PARAM_construct_uint(
+                OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE, &amp;p-&gt;interleave);
+        ret = evp_do_ciph_ctx_setparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+        if (ret &lt;= 0)
+            return ret;
+        params[0] = OSSL_PARAM_construct_size_t(
+                        OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_LEN, &amp;sz);
+        params[1] = OSSL_PARAM_construct_end();
+        ret = evp_do_ciph_ctx_getparams(ctx-&gt;cipher, ctx-&gt;provctx, params);
+        if (ret &lt;= 0)
+            return 0;
+        return sz;
+    }
+#endif /* OPENSSL_NO_MULTIBLOCK */
+    case EVP_CTRL_AEAD_SET_MAC_KEY:
+        if (arg &lt; 0)
+            return -1;
+        params[0] = OSSL_PARAM_construct_octet_string(
+                OSSL_CIPHER_PARAM_AEAD_MAC_KEY, ptr, sz);
+        break;
     }
 
     if (set_params)
diff --git a/doc/man7/provider-cipher.pod b/doc/man7/provider-cipher.pod
index 5e64c0e196..7ad239bcb6 100644
--- a/doc/man7/provider-cipher.pod
+++ b/doc/man7/provider-cipher.pod
@@ -349,6 +349,55 @@ by AES SIV ciphers which disallow multiple operations by default.
 Setting &quot;speed&quot; to 1 allows another encrypt or decrypt operation to be
 performed. This is used for performance testing.
 
+=item &quot;tls1multi_enc&quot; (B&lt;OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC&gt;) &lt;octet string&gt;
+
+Triggers a multiblock tls1 encrypt operation for a tls1 aware cipher that supports
+sending 4 or 8 records in one go.
+The cipher performs both the MAC and encrypt stages and constructs the record
+headers itself.
+&quot;tls1multi_enc&quot; supplies the output buffer for the encrypt operation,
+&quot;tls1multi_encin&quot; &amp; &quot;tls1multi_interleave&quot; must also be set in order to supply
+values to the encrypt operation.
+
+=item &quot;tls1multi_enclen&quot; (B&lt;OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_LEN&gt;) &lt;unsigned integer&gt;
+
+Get the total length of the record returned from the &quot;tls1multi_enc&quot; operation.
+
+=item &quot;tls1multi_interleave&quot; (B&lt;OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE&gt;) &lt;unsigned integer&gt;
+
+Sets or gets the number of records being sent in one go for a tls1 multiblock
+cipher operation (either 4 or 8 records).
+
+=item &quot;tls1multi_encin&quot; (B&lt;OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_IN&gt;) &lt;octet string&gt;
+
+Supplies the data to encrypt for a tls1 multiblock cipher operation.
+
+=item &quot;tls1multi_maxsndfrag&quot; (B&lt;OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_SEND_FRAGMENT&gt;) &lt;unsigned integer&gt;
+
+Sets the maximum send fragment size for a tls1 multiblock cipher operation.
+It must be set before using &quot;tls1multi_maxbufsz&quot;.
+The length of the &quot;tls1multi_maxsndfrag&quot; parameter should not exceed that of a B&lt;size_t&gt;.
+
+=item &quot;tls1multi_maxbufsz&quot; (B&lt;OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_BUFSIZE&gt;) &lt;unsigned integer&gt;
+
+Gets the maximum record length for a tls1 multiblock cipher operation.
+The length of the &quot;tls1multi_maxbufsz&quot; parameter should not exceed that of a B&lt;size_t&gt;.
+
+=item &quot;tls1multi_aad&quot; (B&lt;OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD&gt;) &lt;octet string&gt;
+
+Sets the authenticated additional data used by a tls1 multiblock cipher operation.
+The supplied data consists of 13 bytes of record data containing:
+Bytes 0-7: The sequence number of the first record
+Byte 8: The record type
+Byte 9-10: The protocol version
+Byte 11-12: Input length (Always 0)
+
+&quot;tls1multi_interleave&quot; must also be set for this operation.
+
+=item &quot;tls1multi_aadpacklen&quot; (B&lt;OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD_PACKLEN&gt;) &lt;unsigned integer&gt;
+
+Gets the result of running the &quot;tls1multi_aad&quot; operation.
+
 =back
 
 =head1 RETURN VALUES
diff --git a/include/crypto/aes_platform.h b/include/crypto/aes_platform.h
index 483a1949ee..b478520cf8 100644
--- a/include/crypto/aes_platform.h
+++ b/include/crypto/aes_platform.h
@@ -121,6 +121,13 @@ void gcm_ghash_v8(u64 Xi[2],const u128 Htable[16],const u8 *inp, size_t len);
 #  endif
 # endif /* OPENSSL_CPUID_OBJ */
 
+# if     defined(AES_ASM) &amp;&amp;     ( \
+         defined(__x86_64)       || defined(__x86_64__)  || \
+         defined(_M_AMD64)       || defined(_M_X64)      )
+#  define AES_CBC_HMAC_SHA_CAPABLE 1
+#  define AESNI_CBC_HMAC_SHA_CAPABLE (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(57-32)))
+# endif
+
 # if     defined(AES_ASM) &amp;&amp; !defined(I386_ONLY) &amp;&amp;      (  \
          ((defined(__i386)       || defined(__i386__)    || \
            defined(_M_IX86)) &amp;&amp; defined(OPENSSL_IA32_SSE2))|| \
diff --git a/include/openssl/core_names.h b/include/openssl/core_names.h
index e441ddf6c8..446af5fa8e 100644
--- a/include/openssl/core_names.h
+++ b/include/openssl/core_names.h
@@ -73,6 +73,22 @@ extern &quot;C&quot; {
 /* For passing the AlgorithmIdentifier parameter in DER form */
 #define OSSL_CIPHER_PARAM_ALG_ID             &quot;alg_id_param&quot; /* octet_string */
 
+#define OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_SEND_FRAGMENT                    \
+    &quot;tls1multi_maxsndfrag&quot; /* uint */
+#define OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_BUFSIZE                          \
+    &quot;tls1multi_maxbufsz&quot;   /* size_t */
+#define OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE                           \
+    &quot;tls1multi_interleave&quot; /* uint */
+#define OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD                                  \
+    &quot;tls1multi_aad&quot;        /* octet_string */
+#define OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD_PACKLEN                          \
+    &quot;tls1multi_aadpacklen&quot; /* uint */
+#define OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC                                  \
+    &quot;tls1multi_enc&quot;        /* octet_string */
+#define OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_IN                               \
+    &quot;tls1multi_encin&quot;      /* octet_string */
+#define OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_LEN                              \
+    &quot;tls1multi_enclen&quot;     /* size_t */
 
 /* digest parameters */
 #define OSSL_DIGEST_PARAM_XOFLEN     &quot;xoflen&quot;    /* size_t */
diff --git a/providers/common/include/prov/provider_util.h b/providers/common/include/prov/provider_util.h
index 9925ac2b09..ca3550b3f7 100644
--- a/providers/common/include/prov/provider_util.h
+++ b/providers/common/include/prov/provider_util.h
@@ -101,3 +101,15 @@ int ossl_prov_macctx_load_from_params(EVP_MAC_CTX **macctx,
                                       const char *ciphername,
                                       const char *mdname,
                                       OPENSSL_CTX *ctx);
+
+typedef struct ag_capable_st {
+    OSSL_ALGORITHM alg;
+    int (*capable)(void);
+} OSSL_ALGORITHM_CAPABLE;
+
+/*
+ * Dynamically select algorithms by calling a capable() method.
+ * If this method is NULL or the method returns 1 then the algorithm is added.
+ */
+void ossl_prov_cache_exported_algorithms(const OSSL_ALGORITHM_CAPABLE *in,
+                                         OSSL_ALGORITHM *out);
diff --git a/providers/common/include/prov/providercommon.h b/providers/common/include/prov/providercommon.h
index 569c08c0b1..995c685292 100644
--- a/providers/common/include/prov/providercommon.h
+++ b/providers/common/include/prov/providercommon.h
@@ -13,3 +13,5 @@ const OSSL_PROVIDER *FIPS_get_provider(OPENSSL_CTX *ctx);
 
 const char *ossl_prov_util_nid_to_name(int nid);
 
+int cipher_capable_aes_cbc_hmac_sha1(void);
+int cipher_capable_aes_cbc_hmac_sha256(void);
diff --git a/providers/common/provider_util.c b/providers/common/provider_util.c
index ef4396f432..504463df19 100644
--- a/providers/common/provider_util.c
+++ b/providers/common/provider_util.c
@@ -237,3 +237,17 @@ int ossl_prov_macctx_load_from_params(EVP_MAC_CTX **macctx,
     *macctx = NULL;
     return 0;
 }
+
+void ossl_prov_cache_exported_algorithms(const OSSL_ALGORITHM_CAPABLE *in,
+                                         OSSL_ALGORITHM *out)
+{
+    int i, j;
+
+    if (out[0].algorithm_names == NULL) {
+        for (i = j = 0; in[i].alg.algorithm_names != NULL; ++i) {
+            if (in[i].capable == NULL || in[i].capable())
+                out[j++] = in[i].alg;
+        }
+        out[j++] = in[i].alg;
+    }
+}
diff --git a/providers/defltprov.c b/providers/defltprov.c
index 51cd2b9794..5c11b4a910 100644
--- a/providers/defltprov.c
+++ b/providers/defltprov.c
@@ -15,7 +15,13 @@
 #include &lt;openssl/core_names.h&gt;
 #include &lt;openssl/params.h&gt;
 #include &quot;prov/bio.h&quot;
+#include &quot;prov/providercommon.h&quot;
 #include &quot;prov/implementations.h&quot;
+#include &quot;prov/provider_util.h&quot;
+#include &quot;internal/nelem.h&quot;
+
+#define ALGC(NAMES, FUNC, CHECK) { { NAMES, &quot;default=yes&quot;, FUNC }, CHECK }
+#define ALG(NAMES, FUNC) ALGC(NAMES, FUNC, NULL)
 
 /* Functions provided by the core */
 static OSSL_core_gettable_params_fn *c_gettable_params = NULL;
@@ -131,190 +137,196 @@ static const OSSL_ALGORITHM deflt_digests[] = {
     { NULL, NULL, NULL }
 };
 
-static const OSSL_ALGORITHM deflt_ciphers[] = {
-    { &quot;AES-256-ECB&quot;, &quot;default=yes&quot;, aes256ecb_functions },
-    { &quot;AES-192-ECB&quot;, &quot;default=yes&quot;, aes192ecb_functions },
-    { &quot;AES-128-ECB&quot;, &quot;default=yes&quot;, aes128ecb_functions },
-    { &quot;AES-256-CBC&quot;, &quot;default=yes&quot;, aes256cbc_functions },
-    { &quot;AES-192-CBC&quot;, &quot;default=yes&quot;, aes192cbc_functions },
-    { &quot;AES-128-CBC&quot;, &quot;default=yes&quot;, aes128cbc_functions },
-    { &quot;AES-256-OFB&quot;, &quot;default=yes&quot;, aes256ofb_functions },
-    { &quot;AES-192-OFB&quot;, &quot;default=yes&quot;, aes192ofb_functions },
-    { &quot;AES-128-OFB&quot;, &quot;default=yes&quot;, aes128ofb_functions },
-    { &quot;AES-256-CFB&quot;, &quot;default=yes&quot;, aes256cfb_functions },
-    { &quot;AES-192-CFB&quot;, &quot;default=yes&quot;, aes192cfb_functions },
-    { &quot;AES-128-CFB&quot;, &quot;default=yes&quot;, aes128cfb_functions },
-    { &quot;AES-256-CFB1&quot;, &quot;default=yes&quot;, aes256cfb1_functions },
-    { &quot;AES-192-CFB1&quot;, &quot;default=yes&quot;, aes192cfb1_functions },
-    { &quot;AES-128-CFB1&quot;, &quot;default=yes&quot;, aes128cfb1_functions },
-    { &quot;AES-256-CFB8&quot;, &quot;default=yes&quot;, aes256cfb8_functions },
-    { &quot;AES-192-CFB8&quot;, &quot;default=yes&quot;, aes192cfb8_functions },
-    { &quot;AES-128-CFB8&quot;, &quot;default=yes&quot;, aes128cfb8_functions },
-    { &quot;AES-256-CTR&quot;, &quot;default=yes&quot;, aes256ctr_functions },
-    { &quot;AES-192-CTR&quot;, &quot;default=yes&quot;, aes192ctr_functions },
-    { &quot;AES-128-CTR&quot;, &quot;default=yes&quot;, aes128ctr_functions },
-    { &quot;AES-256-XTS&quot;, &quot;default=yes&quot;, aes256xts_functions },
-    { &quot;AES-128-XTS&quot;, &quot;default=yes&quot;, aes128xts_functions },
+static const OSSL_ALGORITHM_CAPABLE deflt_ciphers[] = {
+    ALG(&quot;AES-256-ECB&quot;, aes256ecb_functions),
+    ALG(&quot;AES-192-ECB&quot;, aes192ecb_functions),
+    ALG(&quot;AES-128-ECB&quot;, aes128ecb_functions),
+    ALG(&quot;AES-256-CBC&quot;, aes256cbc_functions),
+    ALG(&quot;AES-192-CBC&quot;, aes192cbc_functions),
+    ALG(&quot;AES-128-CBC&quot;, aes128cbc_functions),
+    ALG(&quot;AES-256-OFB&quot;, aes256ofb_functions),
+    ALG(&quot;AES-192-OFB&quot;, aes192ofb_functions),
+    ALG(&quot;AES-128-OFB&quot;, aes128ofb_functions),
+    ALG(&quot;AES-256-CFB&quot;, aes256cfb_functions),
+    ALG(&quot;AES-192-CFB&quot;, aes192cfb_functions),
+    ALG(&quot;AES-128-CFB&quot;, aes128cfb_functions),
+    ALG(&quot;AES-256-CFB1&quot;, aes256cfb1_functions),
+    ALG(&quot;AES-192-CFB1&quot;, aes192cfb1_functions),
+    ALG(&quot;AES-128-CFB1&quot;, aes128cfb1_functions),
+    ALG(&quot;AES-256-CFB8&quot;, aes256cfb8_functions),
+    ALG(&quot;AES-192-CFB8&quot;, aes192cfb8_functions),
+    ALG(&quot;AES-128-CFB8&quot;, aes128cfb8_functions),
+    ALG(&quot;AES-256-CTR&quot;, aes256ctr_functions),
+    ALG(&quot;AES-192-CTR&quot;, aes192ctr_functions),
+    ALG(&quot;AES-128-CTR&quot;, aes128ctr_functions),
+    ALG(&quot;AES-256-XTS&quot;, aes256xts_functions),
+    ALG(&quot;AES-128-XTS&quot;, aes128xts_functions),
 #ifndef OPENSSL_NO_OCB
-    { &quot;AES-256-OCB&quot;, &quot;default=yes&quot;, aes256ocb_functions },
-    { &quot;AES-192-OCB&quot;, &quot;default=yes&quot;, aes192ocb_functions },
-    { &quot;AES-128-OCB&quot;, &quot;default=yes&quot;, aes128ocb_functions },
+    ALG(&quot;AES-256-OCB&quot;, aes256ocb_functions),
+    ALG(&quot;AES-192-OCB&quot;, aes192ocb_functions),
+    ALG(&quot;AES-128-OCB&quot;, aes128ocb_functions),
 #endif /* OPENSSL_NO_OCB */
 #ifndef OPENSSL_NO_SIV
-    { &quot;AES-128-SIV&quot;, &quot;default=yes&quot;, aes128siv_functions },
-    { &quot;AES-192-SIV&quot;, &quot;default=yes&quot;, aes192siv_functions },
-    { &quot;AES-256-SIV&quot;, &quot;default=yes&quot;, aes256siv_functions },
+    ALG(&quot;AES-128-SIV&quot;, aes128siv_functions),
+    ALG(&quot;AES-192-SIV&quot;, aes192siv_functions),
+    ALG(&quot;AES-256-SIV&quot;, aes256siv_functions),
 #endif /* OPENSSL_NO_SIV */
-    { &quot;AES-256-GCM:id-aes256-GCM&quot;, &quot;default=yes&quot;, aes256gcm_functions },
-    { &quot;AES-192-GCM:id-aes192-GCM&quot;, &quot;default=yes&quot;, aes192gcm_functions },
-    { &quot;AES-128-GCM:id-aes128-GCM&quot;, &quot;default=yes&quot;, aes128gcm_functions },
-    { &quot;AES-256-CCM:id-aes256-CCM&quot;, &quot;default=yes&quot;, aes256ccm_functions },
-    { &quot;AES-192-CCM:id-aes192-CCM&quot;, &quot;default=yes&quot;, aes192ccm_functions },
-    { &quot;AES-128-CCM:id-aes128-CCM&quot;, &quot;default=yes&quot;, aes128ccm_functions },
-    { &quot;AES-256-WRAP:id-aes256-wrap:AES256-WRAP&quot;, &quot;default=yes&quot;,
-      aes256wrap_functions },
-    { &quot;AES-192-WRAP:id-aes192-wrap:AES192-WRAP&quot;, &quot;default=yes&quot;,
-      aes192wrap_functions },
-    { &quot;AES-128-WRAP:id-aes128-wrap:AES128-WRAP&quot;, &quot;default=yes&quot;,
-      aes128wrap_functions },
-    { &quot;AES-256-WRAP-PAD:id-aes256-wrap-pad:AES256-WRAP-PAD&quot;, &quot;default=yes&quot;,
-      aes256wrappad_functions },
-    { &quot;AES-192-WRAP-PAD:id-aes192-wrap-pad:AES192-WRAP-PAD&quot;, &quot;default=yes&quot;,
-      aes192wrappad_functions },
-    { &quot;AES-128-WRAP-PAD:id-aes128-wrap-pad:AES128-WRAP-PAD&quot;, &quot;default=yes&quot;,
-      aes128wrappad_functions },
+    ALG(&quot;AES-256-GCM:id-aes256-GCM&quot;, aes256gcm_functions),
+    ALG(&quot;AES-192-GCM:id-aes192-GCM&quot;, aes192gcm_functions),
+    ALG(&quot;AES-128-GCM:id-aes128-GCM&quot;, aes128gcm_functions),
+    ALG(&quot;AES-256-CCM:id-aes256-CCM&quot;, aes256ccm_functions),
+    ALG(&quot;AES-192-CCM:id-aes192-CCM&quot;, aes192ccm_functions),
+    ALG(&quot;AES-128-CCM:id-aes128-CCM&quot;, aes128ccm_functions),
+    ALG(&quot;AES-256-WRAP:id-aes256-wrap:AES256-WRAP&quot;, aes256wrap_functions),
+    ALG(&quot;AES-192-WRAP:id-aes192-wrap:AES192-WRAP&quot;, aes192wrap_functions),
+    ALG(&quot;AES-128-WRAP:id-aes128-wrap:AES128-WRAP&quot;, aes128wrap_functions),
+    ALG(&quot;AES-256-WRAP-PAD:id-aes256-wrap-pad:AES256-WRAP-PAD&quot;,
+        aes256wrappad_functions),
+    ALG(&quot;AES-192-WRAP-PAD:id-aes192-wrap-pad:AES192-WRAP-PAD&quot;,
+        aes192wrappad_functions),
+    ALG(&quot;AES-128-WRAP-PAD:id-aes128-wrap-pad:AES128-WRAP-PAD&quot;,
+        aes128wrappad_functions),
+    ALGC(&quot;AES-128-CBC-HMAC-SHA1&quot;, aes128cbc_hmac_sha1_functions,
+         cipher_capable_aes_cbc_hmac_sha1),
+    ALGC(&quot;AES-256-CBC-HMAC-SHA1&quot;, aes256cbc_hmac_sha1_functions,
+         cipher_capable_aes_cbc_hmac_sha1),
+    ALGC(&quot;AES-128-CBC-HMAC-SHA256&quot;, aes128cbc_hmac_sha256_functions,
+        cipher_capable_aes_cbc_hmac_sha256),
+    ALGC(&quot;AES-256-CBC-HMAC-SHA256&quot;, aes256cbc_hmac_sha256_functions,
+         cipher_capable_aes_cbc_hmac_sha256),
 #ifndef OPENSSL_NO_ARIA
-    { &quot;ARIA-256-GCM&quot;, &quot;default=yes&quot;, aria256gcm_functions },
-    { &quot;ARIA-192-GCM&quot;, &quot;default=yes&quot;, aria192gcm_functions },
-    { &quot;ARIA-128-GCM&quot;, &quot;default=yes&quot;, aria128gcm_functions },
-    { &quot;ARIA-256-CCM&quot;, &quot;default=yes&quot;, aria256ccm_functions },
-    { &quot;ARIA-192-CCM&quot;, &quot;default=yes&quot;, aria192ccm_functions },
-    { &quot;ARIA-128-CCM&quot;, &quot;default=yes&quot;, aria128ccm_functions },
-    { &quot;ARIA-256-ECB&quot;, &quot;default=yes&quot;, aria256ecb_functions },
-    { &quot;ARIA-192-ECB&quot;, &quot;default=yes&quot;, aria192ecb_functions },
-    { &quot;ARIA-128-ECB&quot;, &quot;default=yes&quot;, aria128ecb_functions },
-    { &quot;ARIA-256-CBC:ARIA256&quot;, &quot;default=yes&quot;, aria256cbc_functions },
-    { &quot;ARIA-192-CBC:ARIA192&quot;, &quot;default=yes&quot;, aria192cbc_functions },
-    { &quot;ARIA-128-CBC:ARIA128&quot;, &quot;default=yes&quot;, aria128cbc_functions },
-    { &quot;ARIA-256-OFB&quot;, &quot;default=yes&quot;, aria256ofb_functions },
-    { &quot;ARIA-192-OFB&quot;, &quot;default=yes&quot;, aria192ofb_functions },
-    { &quot;ARIA-128-OFB&quot;, &quot;default=yes&quot;, aria128ofb_functions },
-    { &quot;ARIA-256-CFB&quot;, &quot;default=yes&quot;, aria256cfb_functions },
-    { &quot;ARIA-192-CFB&quot;, &quot;default=yes&quot;, aria192cfb_functions },
-    { &quot;ARIA-128-CFB&quot;, &quot;default=yes&quot;, aria128cfb_functions },
-    { &quot;ARIA-256-CFB1&quot;, &quot;default=yes&quot;, aria256cfb1_functions },
-    { &quot;ARIA-192-CFB1&quot;, &quot;default=yes&quot;, aria192cfb1_functions },
-    { &quot;ARIA-128-CFB1&quot;, &quot;default=yes&quot;, aria128cfb1_functions },
-    { &quot;ARIA-256-CFB8&quot;, &quot;default=yes&quot;, aria256cfb8_functions },
-    { &quot;ARIA-192-CFB8&quot;, &quot;default=yes&quot;, aria192cfb8_functions },
-    { &quot;ARIA-128-CFB8&quot;, &quot;default=yes&quot;, aria128cfb8_functions },
-    { &quot;ARIA-256-CTR&quot;, &quot;default=yes&quot;, aria256ctr_functions },
-    { &quot;ARIA-192-CTR&quot;, &quot;default=yes&quot;, aria192ctr_functions },
-    { &quot;ARIA-128-CTR&quot;, &quot;default=yes&quot;, aria128ctr_functions },
+    ALG(&quot;ARIA-256-GCM&quot;, aria256gcm_functions),
+    ALG(&quot;ARIA-192-GCM&quot;, aria192gcm_functions),
+    ALG(&quot;ARIA-128-GCM&quot;, aria128gcm_functions),
+    ALG(&quot;ARIA-256-CCM&quot;, aria256ccm_functions),
+    ALG(&quot;ARIA-192-CCM&quot;, aria192ccm_functions),
+    ALG(&quot;ARIA-128-CCM&quot;, aria128ccm_functions),
+    ALG(&quot;ARIA-256-ECB&quot;, aria256ecb_functions),
+    ALG(&quot;ARIA-192-ECB&quot;, aria192ecb_functions),
+    ALG(&quot;ARIA-128-ECB&quot;, aria128ecb_functions),
+    ALG(&quot;ARIA-256-CBC:ARIA256&quot;, aria256cbc_functions),
+    ALG(&quot;ARIA-192-CBC:ARIA192&quot;, aria192cbc_functions),
+    ALG(&quot;ARIA-128-CBC:ARIA128&quot;, aria128cbc_functions),
+    ALG(&quot;ARIA-256-OFB&quot;, aria256ofb_functions),
+    ALG(&quot;ARIA-192-OFB&quot;, aria192ofb_functions),
+    ALG(&quot;ARIA-128-OFB&quot;, aria128ofb_functions),
+    ALG(&quot;ARIA-256-CFB&quot;, aria256cfb_functions),
+    ALG(&quot;ARIA-192-CFB&quot;, aria192cfb_functions),
+    ALG(&quot;ARIA-128-CFB&quot;, aria128cfb_functions),
+    ALG(&quot;ARIA-256-CFB1&quot;, aria256cfb1_functions),
+    ALG(&quot;ARIA-192-CFB1&quot;, aria192cfb1_functions),
+    ALG(&quot;ARIA-128-CFB1&quot;, aria128cfb1_functions),
+    ALG(&quot;ARIA-256-CFB8&quot;, aria256cfb8_functions),
+    ALG(&quot;ARIA-192-CFB8&quot;, aria192cfb8_functions),
+    ALG(&quot;ARIA-128-CFB8&quot;, aria128cfb8_functions),
+    ALG(&quot;ARIA-256-CTR&quot;, aria256ctr_functions),
+    ALG(&quot;ARIA-192-CTR&quot;, aria192ctr_functions),
+    ALG(&quot;ARIA-128-CTR&quot;, aria128ctr_functions),
 #endif /* OPENSSL_NO_ARIA */
 #ifndef OPENSSL_NO_CAMELLIA
-    { &quot;CAMELLIA-256-ECB&quot;, &quot;default=yes&quot;, camellia256ecb_functions },
-    { &quot;CAMELLIA-192-ECB&quot;, &quot;default=yes&quot;, camellia192ecb_functions },
-    { &quot;CAMELLIA-128-ECB&quot;, &quot;default=yes&quot;, camellia128ecb_functions },
-    { &quot;CAMELLIA-256-CBC:CAMELLIA256&quot;, &quot;default=yes&quot;, camellia256cbc_functions },
-    { &quot;CAMELLIA-192-CBC:CAMELLIA192&quot;, &quot;default=yes&quot;, camellia192cbc_functions },
-    { &quot;CAMELLIA-128-CBC:CAMELLIA128&quot;, &quot;default=yes&quot;, camellia128cbc_functions },
-    { &quot;CAMELLIA-256-OFB&quot;, &quot;default=yes&quot;, camellia256ofb_functions },
-    { &quot;CAMELLIA-192-OFB&quot;, &quot;default=yes&quot;, camellia192ofb_functions },
-    { &quot;CAMELLIA-128-OFB&quot;, &quot;default=yes&quot;, camellia128ofb_functions },
-    { &quot;CAMELLIA-256-CFB&quot;, &quot;default=yes&quot;, camellia256cfb_functions },
-    { &quot;CAMELLIA-192-CFB&quot;, &quot;default=yes&quot;, camellia192cfb_functions },
-    { &quot;CAMELLIA-128-CFB&quot;, &quot;default=yes&quot;, camellia128cfb_functions },
-    { &quot;CAMELLIA-256-CFB1&quot;, &quot;default=yes&quot;, camellia256cfb1_functions },
-    { &quot;CAMELLIA-192-CFB1&quot;, &quot;default=yes&quot;, camellia192cfb1_functions },
-    { &quot;CAMELLIA-128-CFB1&quot;, &quot;default=yes&quot;, camellia128cfb1_functions },
-    { &quot;CAMELLIA-256-CFB8&quot;, &quot;default=yes&quot;, camellia256cfb8_functions },
-    { &quot;CAMELLIA-192-CFB8&quot;, &quot;default=yes&quot;, camellia192cfb8_functions },
-    { &quot;CAMELLIA-128-CFB8&quot;, &quot;default=yes&quot;, camellia128cfb8_functions },
-    { &quot;CAMELLIA-256-CTR&quot;, &quot;default=yes&quot;, camellia256ctr_functions },
-    { &quot;CAMELLIA-192-CTR&quot;, &quot;default=yes&quot;, camellia192ctr_functions },
-    { &quot;CAMELLIA-128-CTR&quot;, &quot;default=yes&quot;, camellia128ctr_functions },
+    ALG(&quot;CAMELLIA-256-ECB&quot;, camellia256ecb_functions),
+    ALG(&quot;CAMELLIA-192-ECB&quot;, camellia192ecb_functions),
+    ALG(&quot;CAMELLIA-128-ECB&quot;, camellia128ecb_functions),
+    ALG(&quot;CAMELLIA-256-CBC:CAMELLIA256&quot;, camellia256cbc_functions),
+    ALG(&quot;CAMELLIA-192-CBC:CAMELLIA192&quot;, camellia192cbc_functions),
+    ALG(&quot;CAMELLIA-128-CBC:CAMELLIA128&quot;, camellia128cbc_functions),
+    ALG(&quot;CAMELLIA-256-OFB&quot;, camellia256ofb_functions),
+    ALG(&quot;CAMELLIA-192-OFB&quot;, camellia192ofb_functions),
+    ALG(&quot;CAMELLIA-128-OFB&quot;, camellia128ofb_functions),
+    ALG(&quot;CAMELLIA-256-CFB&quot;, camellia256cfb_functions),
+    ALG(&quot;CAMELLIA-192-CFB&quot;, camellia192cfb_functions),
+    ALG(&quot;CAMELLIA-128-CFB&quot;, camellia128cfb_functions),
+    ALG(&quot;CAMELLIA-256-CFB1&quot;, camellia256cfb1_functions),
+    ALG(&quot;CAMELLIA-192-CFB1&quot;, camellia192cfb1_functions),
+    ALG(&quot;CAMELLIA-128-CFB1&quot;, camellia128cfb1_functions),
+    ALG(&quot;CAMELLIA-256-CFB8&quot;, camellia256cfb8_functions),
+    ALG(&quot;CAMELLIA-192-CFB8&quot;, camellia192cfb8_functions),
+    ALG(&quot;CAMELLIA-128-CFB8&quot;, camellia128cfb8_functions),
+    ALG(&quot;CAMELLIA-256-CTR&quot;, camellia256ctr_functions),
+    ALG(&quot;CAMELLIA-192-CTR&quot;, camellia192ctr_functions),
+    ALG(&quot;CAMELLIA-128-CTR&quot;, camellia128ctr_functions),
 #endif /* OPENSSL_NO_CAMELLIA */
 #ifndef OPENSSL_NO_DES
-    { &quot;DES-EDE3-ECB:DES-EDE3&quot;, &quot;default=yes&quot;, tdes_ede3_ecb_functions },
-    { &quot;DES-EDE3-CBC:DES3&quot;, &quot;default=yes&quot;, tdes_ede3_cbc_functions },
-    { &quot;DES-EDE3-OFB&quot;, &quot;default=yes&quot;, tdes_ede3_ofb_functions },
-    { &quot;DES-EDE3-CFB&quot;, &quot;default=yes&quot;, tdes_ede3_cfb_functions },
-    { &quot;DES-EDE3-CFB8&quot;, &quot;default=yes&quot;, tdes_ede3_cfb8_functions },
-    { &quot;DES-EDE3-CFB1&quot;, &quot;default=yes&quot;, tdes_ede3_cfb1_functions },
-    { &quot;DES-EDE-ECB:DES-EDE&quot;, &quot;default=yes&quot;, tdes_ede2_ecb_functions },
-    { &quot;DES-EDE-CBC&quot;, &quot;default=yes&quot;, tdes_ede2_cbc_functions },
-    { &quot;DES-EDE-OFB&quot;, &quot;default=yes&quot;, tdes_ede2_ofb_functions },
-    { &quot;DES-EDE-CFB&quot;, &quot;default=yes&quot;, tdes_ede2_cfb_functions },
-    { &quot;DESX-CBC:DESX&quot;, &quot;default=yes&quot;, tdes_desx_cbc_functions },
-    { &quot;DES3-WRAP:id-smime-alg-CMS3DESwrap&quot;, &quot;default=yes&quot;, tdes_wrap_cbc_functions },
-    { &quot;DES-ECB&quot;, &quot;default=yes&quot;, des_ecb_functions },
-    { &quot;DES-CBC:DES&quot;, &quot;default=yes&quot;, des_cbc_functions },
-    { &quot;DES-OFB&quot;, &quot;default=yes&quot;, des_ofb64_functions },
-    { &quot;DES-CFB&quot;, &quot;default=yes&quot;, des_cfb64_functions },
-    { &quot;DES-CFB1&quot;, &quot;default=yes&quot;, des_cfb1_functions },
-    { &quot;DES-CFB8&quot;, &quot;default=yes&quot;, des_cfb8_functions },
+    ALG(&quot;DES-EDE3-ECB:DES-EDE3&quot;, tdes_ede3_ecb_functions),
+    ALG(&quot;DES-EDE3-CBC:DES3&quot;, tdes_ede3_cbc_functions),
+    ALG(&quot;DES-EDE3-OFB&quot;, tdes_ede3_ofb_functions),
+    ALG(&quot;DES-EDE3-CFB&quot;, tdes_ede3_cfb_functions),
+    ALG(&quot;DES-EDE3-CFB8&quot;, tdes_ede3_cfb8_functions),
+    ALG(&quot;DES-EDE3-CFB1&quot;, tdes_ede3_cfb1_functions),
+    ALG(&quot;DES-EDE-ECB:DES-EDE&quot;, tdes_ede2_ecb_functions),
+    ALG(&quot;DES-EDE-CBC&quot;, tdes_ede2_cbc_functions),
+    ALG(&quot;DES-EDE-OFB&quot;, tdes_ede2_ofb_functions),
+    ALG(&quot;DES-EDE-CFB&quot;, tdes_ede2_cfb_functions),
+    ALG(&quot;DESX-CBC:DESX&quot;, tdes_desx_cbc_functions),
+    ALG(&quot;DES3-WRAP:id-smime-alg-CMS3DESwrap&quot;, tdes_wrap_cbc_functions),
+    ALG(&quot;DES-ECB&quot;, des_ecb_functions),
+    ALG(&quot;DES-CBC:DES&quot;, des_cbc_functions),
+    ALG(&quot;DES-OFB&quot;, des_ofb64_functions),
+    ALG(&quot;DES-CFB&quot;, des_cfb64_functions),
+    ALG(&quot;DES-CFB1&quot;, des_cfb1_functions),
+    ALG(&quot;DES-CFB8&quot;, des_cfb8_functions),
 #endif /* OPENSSL_NO_DES */
 #ifndef OPENSSL_NO_BF
-    { &quot;BF-ECB&quot;, &quot;default=yes&quot;, blowfish128ecb_functions },
-    { &quot;BF-CBC:BF:BLOWFISH&quot;, &quot;default=yes&quot;, blowfish128cbc_functions },
-    { &quot;BF-OFB&quot;, &quot;default=yes&quot;, blowfish64ofb64_functions },
-    { &quot;BF-CFB&quot;, &quot;default=yes&quot;, blowfish64cfb64_functions },
+    ALG(&quot;BF-ECB&quot;, blowfish128ecb_functions),
+    ALG(&quot;BF-CBC:BF:BLOWFISH&quot;, blowfish128cbc_functions),
+    ALG(&quot;BF-OFB&quot;, blowfish64ofb64_functions),
+    ALG(&quot;BF-CFB&quot;, blowfish64cfb64_functions),
 #endif /* OPENSSL_NO_BF */
 #ifndef OPENSSL_NO_IDEA
-    { &quot;IDEA-ECB&quot;, &quot;default=yes&quot;, idea128ecb_functions },
-    { &quot;IDEA-CBC:IDEA&quot;, &quot;default=yes&quot;, idea128cbc_functions },
-    { &quot;IDEA-OFB:IDEA-OFB64&quot;, &quot;default=yes&quot;, idea128ofb64_functions },
-    { &quot;IDEA-CFB:IDEA-CFB64&quot;, &quot;default=yes&quot;, idea128cfb64_functions },
+    ALG(&quot;IDEA-ECB&quot;, idea128ecb_functions),
+    ALG(&quot;IDEA-CBC:IDEA&quot;, idea128cbc_functions),
+    ALG(&quot;IDEA-OFB:IDEA-OFB64&quot;, idea128ofb64_functions),
+    ALG(&quot;IDEA-CFB:IDEA-CFB64&quot;, idea128cfb64_functions),
 #endif /* OPENSSL_NO_IDEA */
 #ifndef OPENSSL_NO_CAST
-    { &quot;CAST5-ECB&quot;, &quot;default=yes&quot;, cast5128ecb_functions },
-    { &quot;CAST5-CBC:CAST-CBC:CAST&quot;, &quot;default=yes&quot;, cast5128cbc_functions },
-    { &quot;CAST5-OFB&quot;, &quot;default=yes&quot;, cast564ofb64_functions },
-    { &quot;CAST5-CFB&quot;, &quot;default=yes&quot;, cast564cfb64_functions },
+    ALG(&quot;CAST5-ECB&quot;, cast5128ecb_functions),
+    ALG(&quot;CAST5-CBC:CAST-CBC:CAST&quot;, cast5128cbc_functions),
+    ALG(&quot;CAST5-OFB&quot;, cast564ofb64_functions),
+    ALG(&quot;CAST5-CFB&quot;, cast564cfb64_functions),
 #endif /* OPENSSL_NO_CAST */
 #ifndef OPENSSL_NO_SEED
-    { &quot;SEED-ECB&quot;, &quot;default=yes&quot;, seed128ecb_functions },
-    { &quot;SEED-CBC:SEED&quot;, &quot;default=yes&quot;, seed128cbc_functions },
-    { &quot;SEED-OFB:SEED-OFB128&quot;, &quot;default=yes&quot;, seed128ofb128_functions },
-    { &quot;SEED-CFB:SEED-CFB128&quot;, &quot;default=yes&quot;, seed128cfb128_functions },
+    ALG(&quot;SEED-ECB&quot;, seed128ecb_functions),
+    ALG(&quot;SEED-CBC:SEED&quot;, seed128cbc_functions),
+    ALG(&quot;SEED-OFB:SEED-OFB128&quot;, seed128ofb128_functions),
+    ALG(&quot;SEED-CFB:SEED-CFB128&quot;, seed128cfb128_functions),
 #endif /* OPENSSL_NO_SEED */
 #ifndef OPENSSL_NO_SM4
-    { &quot;SM4-ECB&quot;, &quot;default=yes&quot;, sm4128ecb_functions },
-    { &quot;SM4-CBC:SM4&quot;, &quot;default=yes&quot;, sm4128cbc_functions },
-    { &quot;SM4-CTR&quot;, &quot;default=yes&quot;, sm4128ctr_functions },
-    { &quot;SM4-OFB:SM4-OFB128&quot;, &quot;default=yes&quot;, sm4128ofb128_functions },
-    { &quot;SM4-CFB:SM4-CFB128&quot;, &quot;default=yes&quot;, sm4128cfb128_functions },
+    ALG(&quot;SM4-ECB&quot;, sm4128ecb_functions),
+    ALG(&quot;SM4-CBC:SM4&quot;, sm4128cbc_functions),
+    ALG(&quot;SM4-CTR&quot;, sm4128ctr_functions),
+    ALG(&quot;SM4-OFB:SM4-OFB128&quot;, sm4128ofb128_functions),
+    ALG(&quot;SM4-CFB:SM4-CFB128&quot;, sm4128cfb128_functions),
 #endif /* OPENSSL_NO_SM4 */
 #ifndef OPENSSL_NO_RC4
-    { &quot;RC4&quot;, &quot;default=yes&quot;, rc4128_functions },
-    { &quot;RC4-40&quot;, &quot;default=yes&quot;, rc440_functions },
+    ALG(&quot;RC4&quot;, rc4128_functions),
+    ALG(&quot;RC4-40&quot;, rc440_functions),
 # ifndef OPENSSL_NO_MD5
-    { &quot;RC4-HMAC-MD5&quot;, &quot;default=yes&quot;, rc4_hmac_md5_functions },
+    ALG(&quot;RC4-HMAC-MD5&quot;, rc4_hmac_md5_functions),
 # endif /* OPENSSL_NO_MD5 */
 #endif /* OPENSSL_NO_RC4 */
 #ifndef OPENSSL_NO_RC5
-    { &quot;RC5-ECB&quot;, &quot;default=yes&quot;, rc5128ecb_functions },
-    { &quot;RC5-CBC&quot;, &quot;default=yes&quot;, rc5128cbc_functions },
-    { &quot;RC5-OFB&quot;, &quot;default=yes&quot;, rc5128ofb64_functions },
-    { &quot;RC5-CFB&quot;, &quot;default=yes&quot;, rc5128cfb64_functions },
+    ALG(&quot;RC5-ECB&quot;, rc5128ecb_functions),
+    ALG(&quot;RC5-CBC&quot;, rc5128cbc_functions),
+    ALG(&quot;RC5-OFB&quot;, rc5128ofb64_functions),
+    ALG(&quot;RC5-CFB&quot;, rc5128cfb64_functions),
 #endif /* OPENSSL_NO_RC5 */
 #ifndef OPENSSL_NO_RC2
-    { &quot;RC2-ECB&quot;, &quot;default=yes&quot;, rc2128ecb_functions },
-    { &quot;RC2-CBC&quot;, &quot;default=yes&quot;, rc2128cbc_functions },
-    { &quot;RC2-40-CBC&quot;, &quot;default=yes&quot;, rc240cbc_functions },
-    { &quot;RC2-64-CBC&quot;, &quot;default=yes&quot;, rc264cbc_functions },
-    { &quot;RC2-CFB&quot;, &quot;default=yes&quot;, rc2128cfb128_functions },
-    { &quot;RC2-OFB&quot;, &quot;default=yes&quot;, rc2128ofb128_functions },
+    ALG(&quot;RC2-ECB&quot;, rc2128ecb_functions),
+    ALG(&quot;RC2-CBC&quot;, rc2128cbc_functions),
+    ALG(&quot;RC2-40-CBC&quot;, rc240cbc_functions),
+    ALG(&quot;RC2-64-CBC&quot;, rc264cbc_functions),
+    ALG(&quot;RC2-CFB&quot;, rc2128cfb128_functions),
+    ALG(&quot;RC2-OFB&quot;, rc2128ofb128_functions),
 #endif /* OPENSSL_NO_RC2 */
 #ifndef OPENSSL_NO_CHACHA
-    { &quot;ChaCha20&quot;, &quot;default=yes&quot;, chacha20_functions },
+    ALG(&quot;ChaCha20&quot;, chacha20_functions),
 # ifndef OPENSSL_NO_POLY1305
-    { &quot;ChaCha20-Poly1305&quot;, &quot;default=yes&quot;, chacha20_poly1305_functions },
+    ALG(&quot;ChaCha20-Poly1305&quot;, chacha20_poly1305_functions),
 # endif /* OPENSSL_NO_POLY1305 */
 #endif /* OPENSSL_NO_CHACHA */
-    { NULL, NULL, NULL }
+    { { NULL, NULL, NULL }, NULL }
 };
+static OSSL_ALGORITHM exported_ciphers[OSSL_NELEM(deflt_ciphers)];
 
 static const OSSL_ALGORITHM deflt_macs[] = {
 #ifndef OPENSSL_NO_BLAKE2
@@ -432,7 +444,8 @@ static const OSSL_ALGORITHM *deflt_query(OSSL_PROVIDER *prov,
     case OSSL_OP_DIGEST:
         return deflt_digests;
     case OSSL_OP_CIPHER:
-        return deflt_ciphers;
+        ossl_prov_cache_exported_algorithms(deflt_ciphers, exported_ciphers);
+        return exported_ciphers;
     case OSSL_OP_MAC:
         return deflt_macs;
     case OSSL_OP_KDF:
diff --git a/providers/fips/fipsprov.c b/providers/fips/fipsprov.c
index 12c471f325..7afab78063 100644
--- a/providers/fips/fipsprov.c
+++ b/providers/fips/fipsprov.c
@@ -25,12 +25,17 @@
 
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;internal/property.h&quot;
+#include &quot;internal/nelem.h&quot;
 #include &quot;crypto/evp.h&quot;
 #include &quot;prov/implementations.h&quot;
 #include &quot;prov/provider_ctx.h&quot;
 #include &quot;prov/providercommon.h&quot;
+#include &quot;prov/provider_util.h&quot;
 #include &quot;selftest.h&quot;
 
+#define ALGC(NAMES, FUNC, CHECK) { { NAMES, &quot;fips=yes&quot;, FUNC }, CHECK }
+#define ALG(NAMES, FUNC) ALGC(NAMES, FUNC, NULL)
+
 extern OSSL_core_thread_start_fn *c_thread_start;
 
 /*
@@ -300,6 +305,14 @@ const char *ossl_prov_util_nid_to_name(int nid)
         return &quot;DES-EDE3&quot;;
     case NID_des_ede3_cbc:
         return &quot;DES-EDE3-CBC&quot;;
+    case NID_aes_256_cbc_hmac_sha256:
+        return &quot;AES-256-CBC-HMAC-SHA256&quot;;
+    case NID_aes_128_cbc_hmac_sha256:
+        return &quot;AES-128-CBC-HMAC-SHA256&quot;;
+    case NID_aes_256_cbc_hmac_sha1:
+        return &quot;AES-256-CBC-HMAC-SHA1&quot;;
+    case NID_aes_128_cbc_hmac_sha1:
+        return &quot;AES-128-CBC-HMAC-SHA1&quot;;
     default:
         break;
     }
@@ -358,43 +371,49 @@ static const OSSL_ALGORITHM fips_digests[] = {
     { NULL, NULL, NULL }
 };
 
-static const OSSL_ALGORITHM fips_ciphers[] = {
+static const OSSL_ALGORITHM_CAPABLE fips_ciphers[] = {
     /* Our primary name[:ASN.1 OID name][:our older names] */
-    { &quot;AES-256-ECB&quot;, &quot;fips=yes&quot;, aes256ecb_functions },
-    { &quot;AES-192-ECB&quot;, &quot;fips=yes&quot;, aes192ecb_functions },
-    { &quot;AES-128-ECB&quot;, &quot;fips=yes&quot;, aes128ecb_functions },
-    { &quot;AES-256-CBC&quot;, &quot;fips=yes&quot;, aes256cbc_functions },
-    { &quot;AES-192-CBC&quot;, &quot;fips=yes&quot;, aes192cbc_functions },
-    { &quot;AES-128-CBC&quot;, &quot;fips=yes&quot;, aes128cbc_functions },
-    { &quot;AES-256-CTR&quot;, &quot;fips=yes&quot;, aes256ctr_functions },
-    { &quot;AES-192-CTR&quot;, &quot;fips=yes&quot;, aes192ctr_functions },
-    { &quot;AES-128-CTR&quot;, &quot;fips=yes&quot;, aes128ctr_functions },
-    { &quot;AES-256-XTS&quot;, &quot;fips=yes&quot;, aes256xts_functions },
-    { &quot;AES-128-XTS&quot;, &quot;fips=yes&quot;, aes128xts_functions },
-    { &quot;AES-256-GCM:id-aes256-GCM&quot;, &quot;fips=yes&quot;, aes256gcm_functions },
-    { &quot;AES-192-GCM:id-aes192-GCM&quot;, &quot;fips=yes&quot;, aes192gcm_functions },
-    { &quot;AES-128-GCM:id-aes128-GCM&quot;, &quot;fips=yes&quot;, aes128gcm_functions },
-    { &quot;AES-256-CCM:id-aes256-CCM&quot;, &quot;fips=yes&quot;, aes256ccm_functions },
-    { &quot;AES-192-CCM:id-aes192-CCM&quot;, &quot;fips=yes&quot;, aes192ccm_functions },
-    { &quot;AES-128-CCM:id-aes128-CCM&quot;, &quot;fips=yes&quot;, aes128ccm_functions },
-    { &quot;AES-256-WRAP:id-aes256-wrap:AES256-WRAP&quot;, &quot;fips=yes&quot;,
-      aes256wrap_functions },
-    { &quot;AES-192-WRAP:id-aes192-wrap:AES192-WRAP&quot;, &quot;fips=yes&quot;,
-      aes192wrap_functions },
-    { &quot;AES-128-WRAP:id-aes128-wrap:AES128-WRAP&quot;, &quot;fips=yes&quot;,
-      aes128wrap_functions },
-    { &quot;AES-256-WRAP-PAD:id-aes256-wrap-pad:AES256-WRAP-PAD&quot;, &quot;fips=yes&quot;,
-      aes256wrappad_functions },
-    { &quot;AES-192-WRAP-PAD:id-aes192-wrap-pad:AES192-WRAP-PAD&quot;, &quot;fips=yes&quot;,
-      aes192wrappad_functions },
-    { &quot;AES-128-WRAP-PAD:id-aes128-wrap-pad:AES128-WRAP-PAD&quot;, &quot;fips=yes&quot;,
-      aes128wrappad_functions },
+    ALG(&quot;AES-256-ECB&quot;, aes256ecb_functions),
+    ALG(&quot;AES-192-ECB&quot;, aes192ecb_functions),
+    ALG(&quot;AES-128-ECB&quot;, aes128ecb_functions),
+    ALG(&quot;AES-256-CBC&quot;, aes256cbc_functions),
+    ALG(&quot;AES-192-CBC&quot;, aes192cbc_functions),
+    ALG(&quot;AES-128-CBC&quot;, aes128cbc_functions),
+    ALG(&quot;AES-256-CTR&quot;, aes256ctr_functions),
+    ALG(&quot;AES-192-CTR&quot;, aes192ctr_functions),
+    ALG(&quot;AES-128-CTR&quot;, aes128ctr_functions),
+    ALG(&quot;AES-256-XTS&quot;, aes256xts_functions),
+    ALG(&quot;AES-128-XTS&quot;, aes128xts_functions),
+    ALG(&quot;AES-256-GCM:id-aes256-GCM&quot;, aes256gcm_functions),
+    ALG(&quot;AES-192-GCM:id-aes192-GCM&quot;, aes192gcm_functions),
+    ALG(&quot;AES-128-GCM:id-aes128-GCM&quot;, aes128gcm_functions),
+    ALG(&quot;AES-256-CCM:id-aes256-CCM&quot;, aes256ccm_functions),
+    ALG(&quot;AES-192-CCM:id-aes192-CCM&quot;, aes192ccm_functions),
+    ALG(&quot;AES-128-CCM:id-aes128-CCM&quot;, aes128ccm_functions),
+    ALG(&quot;AES-256-WRAP:id-aes256-wrap:AES256-WRAP&quot;, aes256wrap_functions),
+    ALG(&quot;AES-192-WRAP:id-aes192-wrap:AES192-WRAP&quot;, aes192wrap_functions),
+    ALG(&quot;AES-128-WRAP:id-aes128-wrap:AES128-WRAP&quot;, aes128wrap_functions),
+    ALG(&quot;AES-256-WRAP-PAD:id-aes256-wrap-pad:AES256-WRAP-PAD&quot;,
+        aes256wrappad_functions),
+    ALG(&quot;AES-192-WRAP-PAD:id-aes192-wrap-pad:AES192-WRAP-PAD&quot;,
+        aes192wrappad_functions),
+    ALG(&quot;AES-128-WRAP-PAD:id-aes128-wrap-pad:AES128-WRAP-PAD&quot;,
+        aes128wrappad_functions),
+    ALGC(&quot;AES-128-CBC-HMAC-SHA1&quot;, aes128cbc_hmac_sha1_functions,
+         cipher_capable_aes_cbc_hmac_sha1),
+    ALGC(&quot;AES-256-CBC-HMAC-SHA1&quot;, aes256cbc_hmac_sha1_functions,
+         cipher_capable_aes_cbc_hmac_sha1),
+    ALGC(&quot;AES-128-CBC-HMAC-SHA256&quot;, aes128cbc_hmac_sha256_functions,
+         cipher_capable_aes_cbc_hmac_sha256),
+    ALGC(&quot;AES-256-CBC-HMAC-SHA256&quot;, aes256cbc_hmac_sha256_functions,
+         cipher_capable_aes_cbc_hmac_sha256),
 #ifndef OPENSSL_NO_DES
-    { &quot;DES-EDE3-ECB:DES-EDE3&quot;, &quot;fips=yes&quot;, tdes_ede3_ecb_functions },
-    { &quot;DES-EDE3-CBC:DES3&quot;, &quot;fips=yes&quot;, tdes_ede3_cbc_functions },
+    ALG(&quot;DES-EDE3-ECB:DES-EDE3&quot;, tdes_ede3_ecb_functions),
+    ALG(&quot;DES-EDE3-CBC:DES3&quot;, tdes_ede3_cbc_functions),
 #endif  /* OPENSSL_NO_DES */
-    { NULL, NULL, NULL }
+    { { NULL, NULL, NULL }, NULL }
 };
+static OSSL_ALGORITHM exported_fips_ciphers[OSSL_NELEM(fips_ciphers)];
 
 static const OSSL_ALGORITHM fips_macs[] = {
 #ifndef OPENSSL_NO_CMAC
@@ -416,6 +435,7 @@ static const OSSL_ALGORITHM fips_kdfs[] = {
     { NULL, NULL, NULL }
 };
 
+
 static const OSSL_ALGORITHM *fips_query(OSSL_PROVIDER *prov,
                                          int operation_id,
                                          int *no_cache)
@@ -425,7 +445,8 @@ static const OSSL_ALGORITHM *fips_query(OSSL_PROVIDER *prov,
     case OSSL_OP_DIGEST:
         return fips_digests;
     case OSSL_OP_CIPHER:
-        return fips_ciphers;
+        ossl_prov_cache_exported_algorithms(fips_ciphers, exported_fips_ciphers);
+        return exported_fips_ciphers;
     case OSSL_OP_MAC:
         return fips_macs;
     case OSSL_OP_KDF:
diff --git a/providers/implementations/ciphers/build.info b/providers/implementations/ciphers/build.info
index abc193bb1d..bff5a2d41f 100644
--- a/providers/implementations/ciphers/build.info
+++ b/providers/implementations/ciphers/build.info
@@ -40,7 +40,10 @@ SOURCE[$AES_GOAL]=\
         cipher_aes_xts.c cipher_aes_xts_hw.c \
         cipher_aes_gcm.c cipher_aes_gcm_hw.c \
         cipher_aes_ccm.c cipher_aes_ccm_hw.c \
-        cipher_aes_wrp.c
+        cipher_aes_wrp.c \
+        cipher_aes_cbc_hmac_sha.c \
+        cipher_aes_cbc_hmac_sha256_hw.c cipher_aes_cbc_hmac_sha1_hw.c
+
 # Extra code to satisfy the FIPS and non-FIPS separation.
 # When the AES-xxx-XTS moves to legacy, this can be removed.
 SOURCE[../../libfips.a]=cipher_aes_xts_fips.c
@@ -129,4 +132,3 @@ IF[{- !$disabled{chacha} -}]
       cipher_chacha20_poly1305.c cipher_chacha20_poly1305_hw.c
  ENDIF
 ENDIF
-
diff --git a/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha.c b/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha.c
new file mode 100644
index 0000000000..00b46c3f78
--- /dev/null
+++ b/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha.c
@@ -0,0 +1,345 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+/* Dispatch functions for AES_CBC_HMAC_SHA ciphers */
+
+
+#include &quot;cipher_aes_cbc_hmac_sha.h&quot;
+#include &quot;prov/implementations.h&quot;
+
+#ifndef AES_CBC_HMAC_SHA_CAPABLE
+# define IMPLEMENT_CIPHER(nm, sub, kbits, blkbits, ivbits, flags)              \
+const OSSL_DISPATCH nm##kbits##sub##_functions[] = {                           \
+    { 0, NULL }                                                                \
+};
+#else
+# include &quot;prov/providercommonerr.h&quot;
+
+/* TODO(3.0) Figure out what flags are required */
+# define AES_CBC_HMAC_SHA_FLAGS (EVP_CIPH_CBC_MODE                             \
+                                 | EVP_CIPH_FLAG_DEFAULT_ASN1                  \
+                                 | EVP_CIPH_FLAG_AEAD_CIPHER                   \
+                                 | EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)
+
+static OSSL_OP_cipher_freectx_fn aes_cbc_hmac_sha1_freectx;
+static OSSL_OP_cipher_freectx_fn aes_cbc_hmac_sha256_freectx;
+static OSSL_OP_cipher_get_ctx_params_fn aes_get_ctx_params;
+static OSSL_OP_cipher_gettable_ctx_params_fn aes_gettable_ctx_params;
+static OSSL_OP_cipher_set_ctx_params_fn aes_set_ctx_params;
+static OSSL_OP_cipher_settable_ctx_params_fn aes_settable_ctx_params;
+# define aes_gettable_params cipher_generic_gettable_params
+# define aes_einit cipher_generic_einit
+# define aes_dinit cipher_generic_dinit
+# define aes_update cipher_generic_stream_update
+# define aes_final cipher_generic_stream_final
+# define aes_cipher cipher_generic_cipher
+
+static const OSSL_PARAM cipher_aes_known_settable_ctx_params[] = {
+    OSSL_PARAM_octet_string(OSSL_CIPHER_PARAM_AEAD_MAC_KEY, NULL, 0),
+    OSSL_PARAM_octet_string(OSSL_CIPHER_PARAM_AEAD_TLS1_AAD, NULL, 0),
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+    OSSL_PARAM_size_t(OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_SEND_FRAGMENT, NULL),
+    OSSL_PARAM_size_t(OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD, NULL),
+    OSSL_PARAM_uint(OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE, NULL),
+    OSSL_PARAM_octet_string(OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC, NULL, 0),
+    OSSL_PARAM_octet_string(OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_IN, NULL, 0),
+# endif /* !defined(OPENSSL_NO_MULTIBLOCK) */
+    OSSL_PARAM_size_t(OSSL_CIPHER_PARAM_KEYLEN, NULL),
+    OSSL_PARAM_END
+};
+const OSSL_PARAM *aes_settable_ctx_params(void)
+{
+    return cipher_aes_known_settable_ctx_params;
+}
+
+static int aes_set_ctx_params(void *vctx, const OSSL_PARAM params[])
+{
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_CIPHER_HW_AES_HMAC_SHA *hw =
+       (PROV_CIPHER_HW_AES_HMAC_SHA *)ctx-&gt;hw;
+    EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param;
+    const OSSL_PARAM *p, *p1, *pin;
+    int ret = 1;
+
+    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_MAC_KEY);
+    if (p != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_OCTET_STRING) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+        hw-&gt;init_mac_key(ctx, p-&gt;data, p-&gt;data_size);
+    }
+
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+    p = OSSL_PARAM_locate_const(params,
+            OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_SEND_FRAGMENT);
+    if (p != NULL
+            &amp;&amp; !OSSL_PARAM_get_size_t(p, &amp;ctx-&gt;multiblock_max_send_fragment)) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);
+        return 0;
+    }
+    /*
+     * The inputs to tls1_multiblock_aad are:
+     *   mb_param-&gt;inp
+     *   mb_param-&gt;len
+     *   mb_param-&gt;interleave
+     * The outputs of tls1_multiblock_aad are written to:
+     *   ctx-&gt;multiblock_interleave
+     *   ctx-&gt;multiblock_aad_packlen
+     */
+    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD);
+    if (p != NULL) {
+        p1 = OSSL_PARAM_locate_const(params,
+                OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE);
+        if (p-&gt;data_type != OSSL_PARAM_OCTET_STRING
+            || p1 == NULL
+            || !OSSL_PARAM_get_uint(p1, &amp;mb_param.interleave)) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+        mb_param.inp = p-&gt;data;
+        mb_param.len = p-&gt;data_size;
+        if (hw-&gt;tls1_multiblock_aad(vctx, &amp;mb_param) &lt;= 0)
+            return 0;
+    }
+
+    /*
+     * The inputs to tls1_multiblock_encrypt are:
+     *   mb_param-&gt;inp
+     *   mb_param-&gt;len
+     *   mb_param-&gt;interleave
+     *   mb_param-&gt;out
+     * The outputs of tls1_multiblock_encrypt are:
+     *   ctx-&gt;multiblock_encrypt_len
+     */
+    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC);
+    if (p != NULL) {
+        p1 = OSSL_PARAM_locate_const(params,
+                OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE);
+        pin = OSSL_PARAM_locate_const(params,
+                   OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_IN);
+        if (p-&gt;data_type != OSSL_PARAM_OCTET_STRING
+            || pin == NULL
+            || pin-&gt;data_type != OSSL_PARAM_OCTET_STRING
+            || p1 == NULL
+            || !OSSL_PARAM_get_uint(p1, &amp;mb_param.interleave)) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+        mb_param.out = p-&gt;data;
+        mb_param.inp = pin-&gt;data;
+        mb_param.len = pin-&gt;data_size;
+        if (hw-&gt;tls1_multiblock_encrypt(vctx, &amp;mb_param) &lt;= 0)
+            return 0;
+    }
+# endif /* !defined(OPENSSL_NO_MULTIBLOCK) */
+
+    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD);
+    if (p != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_OCTET_STRING) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+        if (hw-&gt;set_tls1_aad(ctx, p-&gt;data, p-&gt;data_size) &lt;= 0)
+            return 0;
+    }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_KEYLEN);
+    if (p != NULL) {
+        size_t keylen;
+
+        if (!OSSL_PARAM_get_size_t(p, &amp;keylen)) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+        if (ctx-&gt;base.keylen != keylen) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_KEY_LENGTH);
+            return 0;
+        }
+    }
+    return ret;
+}
+
+static int aes_get_ctx_params(void *vctx, OSSL_PARAM params[])
+{
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_CIPHER_HW_AES_HMAC_SHA *hw =
+       (PROV_CIPHER_HW_AES_HMAC_SHA *)ctx-&gt;hw;
+    OSSL_PARAM *p;
+
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_BUFSIZE);
+    if (p != NULL) {
+        size_t len = hw-&gt;tls1_multiblock_max_bufsize(ctx);
+
+        if (!OSSL_PARAM_set_size_t(p, len)) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+            return 0;
+        }
+    }
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE);
+    if (p != NULL &amp;&amp; !OSSL_PARAM_set_uint(p, ctx-&gt;multiblock_interleave)) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD_PACKLEN);
+    if (p != NULL &amp;&amp; !OSSL_PARAM_set_uint(p, ctx-&gt;multiblock_aad_packlen)) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_LEN);
+    if (p != NULL &amp;&amp; !OSSL_PARAM_set_size_t(p, ctx-&gt;multiblock_encrypt_len)) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+# endif /* !defined(OPENSSL_NO_MULTIBLOCK) */
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD);
+    if (p != NULL &amp;&amp; !OSSL_PARAM_set_size_t(p, ctx-&gt;tls_aad_pad)) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_KEYLEN);
+    if (p != NULL &amp;&amp; !OSSL_PARAM_set_size_t(p, ctx-&gt;base.keylen)) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_IVLEN);
+    if (p != NULL &amp;&amp; !OSSL_PARAM_set_size_t(p, ctx-&gt;base.ivlen)) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_IV);
+    if (p != NULL
+        &amp;&amp; !OSSL_PARAM_set_octet_string(p, ctx-&gt;base.oiv, ctx-&gt;base.ivlen)) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+    return 1;
+}
+
+static const OSSL_PARAM cipher_aes_known_gettable_ctx_params[] = {
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+    OSSL_PARAM_size_t(OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_MAX_BUFSIZE, NULL),
+    OSSL_PARAM_uint(OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_INTERLEAVE, NULL),
+    OSSL_PARAM_uint(OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_AAD_PACKLEN, NULL),
+    OSSL_PARAM_size_t(OSSL_CIPHER_PARAM_TLS1_MULTIBLOCK_ENC_LEN, NULL),
+# endif /* !defined(OPENSSL_NO_MULTIBLOCK) */
+    OSSL_PARAM_size_t(OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD, NULL),
+    OSSL_PARAM_size_t(OSSL_CIPHER_PARAM_KEYLEN, NULL),
+    OSSL_PARAM_size_t(OSSL_CIPHER_PARAM_IVLEN, NULL),
+    OSSL_PARAM_octet_string(OSSL_CIPHER_PARAM_IV, NULL, 0),
+    OSSL_PARAM_END
+};
+const OSSL_PARAM *aes_gettable_ctx_params(void)
+{
+    return cipher_aes_known_gettable_ctx_params;
+}
+
+static void base_init(void *provctx, PROV_AES_HMAC_SHA_CTX *ctx,
+                      const PROV_CIPHER_HW_AES_HMAC_SHA *meths,
+                      size_t kbits, size_t blkbits, size_t ivbits,
+                      uint64_t flags)
+{
+    cipher_generic_initkey(&amp;ctx-&gt;base, kbits, blkbits, ivbits,
+                           EVP_CIPH_CBC_MODE, flags,
+                           &amp;meths-&gt;base, provctx);
+    ctx-&gt;hw = (PROV_CIPHER_HW_AES_HMAC_SHA *)ctx-&gt;base.hw;
+}
+
+static void *aes_cbc_hmac_sha1_newctx(void *provctx, size_t kbits,
+                                      size_t blkbits, size_t ivbits,
+                                      uint64_t flags)
+{
+    PROV_AES_HMAC_SHA1_CTX *ctx = OPENSSL_zalloc(sizeof(*ctx));
+
+    if (ctx != NULL)
+        base_init(provctx, &amp;ctx-&gt;base_ctx,
+                  PROV_CIPHER_HW_aes_cbc_hmac_sha1(), kbits, blkbits,
+                  ivbits, flags);
+    return ctx;
+}
+
+static void aes_cbc_hmac_sha1_freectx(void *vctx)
+{
+    PROV_AES_HMAC_SHA1_CTX *ctx = (PROV_AES_HMAC_SHA1_CTX *)vctx;
+
+    if (ctx != NULL)
+        OPENSSL_clear_free(ctx, sizeof(ctx));
+}
+
+static void *aes_cbc_hmac_sha256_newctx(void *provctx, size_t kbits,
+                                        size_t blkbits, size_t ivbits,
+                                        uint64_t flags)
+{
+    PROV_AES_HMAC_SHA256_CTX *ctx = OPENSSL_zalloc(sizeof(*ctx));
+
+    if (ctx != NULL)
+        base_init(provctx, &amp;ctx-&gt;base_ctx,
+                  PROV_CIPHER_HW_aes_cbc_hmac_sha256(), kbits, blkbits,
+                  ivbits, flags);
+    return ctx;
+}
+
+static void aes_cbc_hmac_sha256_freectx(void *vctx)
+{
+    PROV_AES_HMAC_SHA256_CTX *ctx = (PROV_AES_HMAC_SHA256_CTX *)vctx;
+
+    if (ctx != NULL)
+        OPENSSL_clear_free(ctx, sizeof(ctx));
+}
+
+# define IMPLEMENT_CIPHER(nm, sub, kbits, blkbits, ivbits, flags)               \
+static OSSL_OP_cipher_newctx_fn nm##_##kbits##_##sub##_newctx;                 \
+static void *nm##_##kbits##_##sub##_newctx(void *provctx)                      \
+{                                                                              \
+    return nm##_##sub##_newctx(provctx, kbits, blkbits, ivbits, flags);        \
+}                                                                              \
+static OSSL_OP_cipher_get_params_fn nm##_##kbits##_##sub##_get_params;         \
+static int nm##_##kbits##_##sub##_get_params(OSSL_PARAM params[])              \
+{                                                                              \
+    return cipher_generic_get_params(params, EVP_CIPH_CBC_MODE,                \
+                                     flags, kbits, blkbits, ivbits);           \
+}                                                                              \
+const OSSL_DISPATCH nm##kbits##sub##_functions[] = {                           \
+    { OSSL_FUNC_CIPHER_NEWCTX, (void (*)(void))nm##_##kbits##_##sub##_newctx },\
+    { OSSL_FUNC_CIPHER_FREECTX, (void (*)(void))nm##_##sub##_freectx },        \
+    { OSSL_FUNC_CIPHER_ENCRYPT_INIT, (void (*)(void))nm##_einit },             \
+    { OSSL_FUNC_CIPHER_DECRYPT_INIT, (void (*)(void))nm##_dinit },             \
+    { OSSL_FUNC_CIPHER_UPDATE, (void (*)(void))nm##_update },                  \
+    { OSSL_FUNC_CIPHER_FINAL, (void (*)(void))nm##_final },                    \
+    { OSSL_FUNC_CIPHER_CIPHER, (void (*)(void))nm##_cipher },                  \
+    { OSSL_FUNC_CIPHER_GET_PARAMS,                                             \
+        (void (*)(void))nm##_##kbits##_##sub##_get_params },                   \
+    { OSSL_FUNC_CIPHER_GETTABLE_PARAMS,                                        \
+        (void (*)(void))nm##_gettable_params },                                \
+    { OSSL_FUNC_CIPHER_GET_CTX_PARAMS,                                         \
+         (void (*)(void))nm##_get_ctx_params },                                \
+    { OSSL_FUNC_CIPHER_GETTABLE_CTX_PARAMS,                                    \
+        (void (*)(void))nm##_gettable_ctx_params },                            \
+    { OSSL_FUNC_CIPHER_SET_CTX_PARAMS,                                         \
+        (void (*)(void))nm##_set_ctx_params },                                 \
+    { OSSL_FUNC_CIPHER_SETTABLE_CTX_PARAMS,                                    \
+        (void (*)(void))nm##_settable_ctx_params },                            \
+    { 0, NULL }                                                                \
+};
+
+#endif /* AES_CBC_HMAC_SHA_CAPABLE */
+
+/* aes128cbc_hmac_sha1_functions */
+IMPLEMENT_CIPHER(aes, cbc_hmac_sha1, 128, 128, 128, AES_CBC_HMAC_SHA_FLAGS)
+/* aes256cbc_hmac_sha1_functions */
+IMPLEMENT_CIPHER(aes, cbc_hmac_sha1, 256, 128, 128, AES_CBC_HMAC_SHA_FLAGS)
+/* aes128cbc_hmac_sha256_functions */
+IMPLEMENT_CIPHER(aes, cbc_hmac_sha256, 128, 128, 128, AES_CBC_HMAC_SHA_FLAGS)
+/* aes256cbc_hmac_sha256_functions */
+IMPLEMENT_CIPHER(aes, cbc_hmac_sha256, 256, 128, 128, AES_CBC_HMAC_SHA_FLAGS)
diff --git a/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha.h b/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha.h
new file mode 100644
index 0000000000..86da791c49
--- /dev/null
+++ b/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &quot;prov/ciphercommon.h&quot;
+#include &quot;crypto/aes_platform.h&quot;
+
+int cipher_capable_aes_cbc_hmac_sha1(void);
+int cipher_capable_aes_cbc_hmac_sha256(void);
+
+#ifdef AES_CBC_HMAC_SHA_CAPABLE
+# include &lt;openssl/aes.h&gt;
+# include &lt;openssl/sha.h&gt;
+
+typedef struct prov_cipher_hw_aes_hmac_sha_ctx_st {
+    PROV_CIPHER_HW base; /* must be first */
+    void (*init_mac_key)(void *ctx, const unsigned char *inkey, size_t inlen);
+    int (*set_tls1_aad)(void *ctx, unsigned char *aad_rec, int aad_len);
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+    int (*tls1_multiblock_max_bufsize)(void *ctx);
+    int (*tls1_multiblock_aad)(
+        void *vctx, EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *param);
+    int (*tls1_multiblock_encrypt)(
+        void *ctx, EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *param);
+# endif /* OPENSSL_NO_MULTIBLOCK) */
+} PROV_CIPHER_HW_AES_HMAC_SHA;
+
+typedef struct prov_aes_hmac_sha_ctx_st {
+    PROV_CIPHER_CTX base;
+    AES_KEY ks;
+    size_t payload_length;      /* AAD length in decrypt case */
+    union {
+        unsigned int tls_ver;
+        unsigned char tls_aad[16]; /* 13 used */
+    } aux;
+    const PROV_CIPHER_HW_AES_HMAC_SHA *hw;
+    /* some value that are setup by set methods - that can be retrieved */
+    unsigned int multiblock_interleave;
+    unsigned int multiblock_aad_packlen;
+    size_t multiblock_max_send_fragment;
+    size_t multiblock_encrypt_len;
+    size_t tls_aad_pad;
+} PROV_AES_HMAC_SHA_CTX;
+
+typedef struct prov_aes_hmac_sha1_ctx_st {
+    PROV_AES_HMAC_SHA_CTX base_ctx;
+    SHA_CTX head, tail, md;
+} PROV_AES_HMAC_SHA1_CTX;
+
+typedef struct prov_aes_hmac_sha256_ctx_st {
+    PROV_AES_HMAC_SHA_CTX base_ctx;
+    SHA256_CTX head, tail, md;
+} PROV_AES_HMAC_SHA256_CTX;
+
+# define NO_PAYLOAD_LENGTH ((size_t)-1)
+
+const PROV_CIPHER_HW_AES_HMAC_SHA *PROV_CIPHER_HW_aes_cbc_hmac_sha1(void);
+const PROV_CIPHER_HW_AES_HMAC_SHA *PROV_CIPHER_HW_aes_cbc_hmac_sha256(void);
+
+#endif /* AES_CBC_HMAC_SHA_CAPABLE */
diff --git a/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha1_hw.c b/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha1_hw.c
new file mode 100644
index 0000000000..125369d7ff
--- /dev/null
+++ b/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha1_hw.c
@@ -0,0 +1,782 @@
+/*
+ * Copyright 2011-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &quot;cipher_aes_cbc_hmac_sha.h&quot;
+
+#ifndef AES_CBC_HMAC_SHA_CAPABLE
+int cipher_capable_aes_cbc_hmac_sha1(void)
+{
+    return 0;
+}
+#else
+
+# include &quot;crypto/rand.h&quot;
+# include &quot;crypto/evp.h&quot;
+# include &quot;internal/constant_time.h&quot;
+
+void sha1_block_data_order(void *c, const void *p, size_t len);
+void aesni_cbc_sha1_enc(const void *inp, void *out, size_t blocks,
+                        const AES_KEY *key, unsigned char iv[16],
+                        SHA_CTX *ctx, const void *in0);
+
+int cipher_capable_aes_cbc_hmac_sha1(void)
+{
+    return AESNI_CBC_HMAC_SHA_CAPABLE;
+}
+
+static int aesni_cbc_hmac_sha1_init_key(PROV_CIPHER_CTX *vctx,
+                                        const unsigned char *key, size_t keylen)
+{
+    int ret;
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_AES_HMAC_SHA1_CTX *sctx = (PROV_AES_HMAC_SHA1_CTX *)vctx;
+
+    if (ctx-&gt;base.enc)
+        ret = aesni_set_encrypt_key(key, keylen * 8, &amp;ctx-&gt;ks);
+    else
+        ret = aesni_set_decrypt_key(key, keylen * 8, &amp;ctx-&gt;ks);
+
+    SHA1_Init(&amp;sctx-&gt;head);      /* handy when benchmarking */
+    sctx-&gt;tail = sctx-&gt;head;
+    sctx-&gt;md = sctx-&gt;head;
+
+    ctx-&gt;payload_length = NO_PAYLOAD_LENGTH;
+
+    return ret &lt; 0 ? 0 : 1;
+}
+
+static void sha1_update(SHA_CTX *c, const void *data, size_t len)
+{
+    const unsigned char *ptr = data;
+    size_t res;
+
+    if ((res = c-&gt;num)) {
+        res = SHA_CBLOCK - res;
+        if (len &lt; res)
+            res = len;
+        SHA1_Update(c, ptr, res);
+        ptr += res;
+        len -= res;
+    }
+
+    res = len % SHA_CBLOCK;
+    len -= res;
+
+    if (len) {
+        sha1_block_data_order(c, ptr, len / SHA_CBLOCK);
+
+        ptr += len;
+        c-&gt;Nh += len &gt;&gt; 29;
+        c-&gt;Nl += len &lt;&lt;= 3;
+        if (c-&gt;Nl &lt; (unsigned int)len)
+            c-&gt;Nh++;
+    }
+
+    if (res)
+        SHA1_Update(c, ptr, res);
+}
+
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+
+typedef struct {
+    unsigned int A[8], B[8], C[8], D[8], E[8];
+} SHA1_MB_CTX;
+
+typedef struct {
+    const unsigned char *ptr;
+    int blocks;
+} HASH_DESC;
+
+typedef struct {
+    const unsigned char *inp;
+    unsigned char *out;
+    int blocks;
+    u64 iv[2];
+} CIPH_DESC;
+
+void sha1_multi_block(SHA1_MB_CTX *, const HASH_DESC *, int);
+void aesni_multi_cbc_encrypt(CIPH_DESC *, void *, int);
+
+static size_t tls1_multi_block_encrypt(void *vctx,
+                                       unsigned char *out,
+                                       const unsigned char *inp,
+                                       size_t inp_len, int n4x)
+{                               /* n4x is 1 or 2 */
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_AES_HMAC_SHA1_CTX *sctx = (PROV_AES_HMAC_SHA1_CTX *)vctx;
+    HASH_DESC hash_d[8], edges[8];
+    CIPH_DESC ciph_d[8];
+    unsigned char storage[sizeof(SHA1_MB_CTX) + 32];
+    union {
+        u64 q[16];
+        u32 d[32];
+        u8 c[128];
+    } blocks[8];
+    SHA1_MB_CTX *mctx;
+    unsigned int frag, last, packlen, i;
+    unsigned int x4 = 4 * n4x, minblocks, processed = 0;
+    size_t ret = 0;
+    u8 *IVs;
+#  if defined(BSWAP8)
+    u64 seqnum;
+#  endif
+
+    /* ask for IVs in bulk */
+    if (rand_bytes_ex(ctx-&gt;base.libctx, (IVs = blocks[0].c), 16 * x4) &lt;= 0)
+        return 0;
+
+    mctx = (SHA1_MB_CTX *) (storage + 32 - ((size_t)storage % 32)); /* align */
+
+    frag = (unsigned int)inp_len &gt;&gt; (1 + n4x);
+    last = (unsigned int)inp_len + frag - (frag &lt;&lt; (1 + n4x));
+    if (last &gt; frag &amp;&amp; ((last + 13 + 9) % 64) &lt; (x4 - 1)) {
+        frag++;
+        last -= x4 - 1;
+    }
+
+    packlen = 5 + 16 + ((frag + 20 + 16) &amp; -16);
+
+    /* populate descriptors with pointers and IVs */
+    hash_d[0].ptr = inp;
+    ciph_d[0].inp = inp;
+    /* 5+16 is place for header and explicit IV */
+    ciph_d[0].out = out + 5 + 16;
+    memcpy(ciph_d[0].out - 16, IVs, 16);
+    memcpy(ciph_d[0].iv, IVs, 16);
+    IVs += 16;
+
+    for (i = 1; i &lt; x4; i++) {
+        ciph_d[i].inp = hash_d[i].ptr = hash_d[i - 1].ptr + frag;
+        ciph_d[i].out = ciph_d[i - 1].out + packlen;
+        memcpy(ciph_d[i].out - 16, IVs, 16);
+        memcpy(ciph_d[i].iv, IVs, 16);
+        IVs += 16;
+    }
+
+#  if defined(BSWAP8)
+    memcpy(blocks[0].c, sctx-&gt;md.data, 8);
+    seqnum = BSWAP8(blocks[0].q[0]);
+#  endif
+    for (i = 0; i &lt; x4; i++) {
+        unsigned int len = (i == (x4 - 1) ? last : frag);
+#  if !defined(BSWAP8)
+        unsigned int carry, j;
+#  endif
+
+        mctx-&gt;A[i] = sctx-&gt;md.h0;
+        mctx-&gt;B[i] = sctx-&gt;md.h1;
+        mctx-&gt;C[i] = sctx-&gt;md.h2;
+        mctx-&gt;D[i] = sctx-&gt;md.h3;
+        mctx-&gt;E[i] = sctx-&gt;md.h4;
+
+        /* fix seqnum */
+#  if defined(BSWAP8)
+        blocks[i].q[0] = BSWAP8(seqnum + i);
+#  else
+        for (carry = i, j = 8; j--;) {
+            blocks[i].c[j] = ((u8 *)sctx-&gt;md.data)[j] + carry;
+            carry = (blocks[i].c[j] - carry) &gt;&gt; (sizeof(carry) * 8 - 1);
+        }
+#  endif
+        blocks[i].c[8] = ((u8 *)sctx-&gt;md.data)[8];
+        blocks[i].c[9] = ((u8 *)sctx-&gt;md.data)[9];
+        blocks[i].c[10] = ((u8 *)sctx-&gt;md.data)[10];
+        /* fix length */
+        blocks[i].c[11] = (u8)(len &gt;&gt; 8);
+        blocks[i].c[12] = (u8)(len);
+
+        memcpy(blocks[i].c + 13, hash_d[i].ptr, 64 - 13);
+        hash_d[i].ptr += 64 - 13;
+        hash_d[i].blocks = (len - (64 - 13)) / 64;
+
+        edges[i].ptr = blocks[i].c;
+        edges[i].blocks = 1;
+    }
+
+    /* hash 13-byte headers and first 64-13 bytes of inputs */
+    sha1_multi_block(mctx, edges, n4x);
+    /* hash bulk inputs */
+#  define MAXCHUNKSIZE    2048
+#  if     MAXCHUNKSIZE%64
+#   error  &quot;MAXCHUNKSIZE is not divisible by 64&quot;
+#  elif   MAXCHUNKSIZE
+    /*
+     * goal is to minimize pressure on L1 cache by moving in shorter steps,
+     * so that hashed data is still in the cache by the time we encrypt it
+     */
+    minblocks = ((frag &lt;= last ? frag : last) - (64 - 13)) / 64;
+    if (minblocks &gt; MAXCHUNKSIZE / 64) {
+        for (i = 0; i &lt; x4; i++) {
+            edges[i].ptr = hash_d[i].ptr;
+            edges[i].blocks = MAXCHUNKSIZE / 64;
+            ciph_d[i].blocks = MAXCHUNKSIZE / 16;
+        }
+        do {
+            sha1_multi_block(mctx, edges, n4x);
+            aesni_multi_cbc_encrypt(ciph_d, &amp;ctx-&gt;ks, n4x);
+
+            for (i = 0; i &lt; x4; i++) {
+                edges[i].ptr = hash_d[i].ptr += MAXCHUNKSIZE;
+                hash_d[i].blocks -= MAXCHUNKSIZE / 64;
+                edges[i].blocks = MAXCHUNKSIZE / 64;
+                ciph_d[i].inp += MAXCHUNKSIZE;
+                ciph_d[i].out += MAXCHUNKSIZE;
+                ciph_d[i].blocks = MAXCHUNKSIZE / 16;
+                memcpy(ciph_d[i].iv, ciph_d[i].out - 16, 16);
+            }
+            processed += MAXCHUNKSIZE;
+            minblocks -= MAXCHUNKSIZE / 64;
+        } while (minblocks &gt; MAXCHUNKSIZE / 64);
+    }
+#  endif
+#  undef  MAXCHUNKSIZE
+    sha1_multi_block(mctx, hash_d, n4x);
+
+    memset(blocks, 0, sizeof(blocks));
+    for (i = 0; i &lt; x4; i++) {
+        unsigned int len = (i == (x4 - 1) ? last : frag),
+            off = hash_d[i].blocks * 64;
+        const unsigned char *ptr = hash_d[i].ptr + off;
+
+        off = (len - processed) - (64 - 13) - off; /* remainder actually */
+        memcpy(blocks[i].c, ptr, off);
+        blocks[i].c[off] = 0x80;
+        len += 64 + 13;         /* 64 is HMAC header */
+        len *= 8;               /* convert to bits */
+        if (off &lt; (64 - 8)) {
+#  ifdef BSWAP4
+            blocks[i].d[15] = BSWAP4(len);
+#  else
+            PUTU32(blocks[i].c + 60, len);
+#  endif
+            edges[i].blocks = 1;
+        } else {
+#  ifdef BSWAP4
+            blocks[i].d[31] = BSWAP4(len);
+#  else
+            PUTU32(blocks[i].c + 124, len);
+#  endif
+            edges[i].blocks = 2;
+        }
+        edges[i].ptr = blocks[i].c;
+    }
+
+    /* hash input tails and finalize */
+    sha1_multi_block(mctx, edges, n4x);
+
+    memset(blocks, 0, sizeof(blocks));
+    for (i = 0; i &lt; x4; i++) {
+#  ifdef BSWAP4
+        blocks[i].d[0] = BSWAP4(mctx-&gt;A[i]);
+        mctx-&gt;A[i] = sctx-&gt;tail.h0;
+        blocks[i].d[1] = BSWAP4(mctx-&gt;B[i]);
+        mctx-&gt;B[i] = sctx-&gt;tail.h1;
+        blocks[i].d[2] = BSWAP4(mctx-&gt;C[i]);
+        mctx-&gt;C[i] = sctx-&gt;tail.h2;
+        blocks[i].d[3] = BSWAP4(mctx-&gt;D[i]);
+        mctx-&gt;D[i] = sctx-&gt;tail.h3;
+        blocks[i].d[4] = BSWAP4(mctx-&gt;E[i]);
+        mctx-&gt;E[i] = sctx-&gt;tail.h4;
+        blocks[i].c[20] = 0x80;
+        blocks[i].d[15] = BSWAP4((64 + 20) * 8);
+#  else
+        PUTU32(blocks[i].c + 0, mctx-&gt;A[i]);
+        mctx-&gt;A[i] = sctx-&gt;tail.h0;
+        PUTU32(blocks[i].c + 4, mctx-&gt;B[i]);
+        mctx-&gt;B[i] = sctx-&gt;tail.h1;
+        PUTU32(blocks[i].c + 8, mctx-&gt;C[i]);
+        mctx-&gt;C[i] = sctx-&gt;tail.h2;
+        PUTU32(blocks[i].c + 12, mctx-&gt;D[i]);
+        mctx-&gt;D[i] = sctx-&gt;tail.h3;
+        PUTU32(blocks[i].c + 16, mctx-&gt;E[i]);
+        mctx-&gt;E[i] = sctx-&gt;tail.h4;
+        blocks[i].c[20] = 0x80;
+        PUTU32(blocks[i].c + 60, (64 + 20) * 8);
+#  endif /* BSWAP */
+        edges[i].ptr = blocks[i].c;
+        edges[i].blocks = 1;
+    }
+
+    /* finalize MACs */
+    sha1_multi_block(mctx, edges, n4x);
+
+    for (i = 0; i &lt; x4; i++) {
+        unsigned int len = (i == (x4 - 1) ? last : frag), pad, j;
+        unsigned char *out0 = out;
+
+        memcpy(ciph_d[i].out, ciph_d[i].inp, len - processed);
+        ciph_d[i].inp = ciph_d[i].out;
+
+        out += 5 + 16 + len;
+
+        /* write MAC */
+        PUTU32(out + 0, mctx-&gt;A[i]);
+        PUTU32(out + 4, mctx-&gt;B[i]);
+        PUTU32(out + 8, mctx-&gt;C[i]);
+        PUTU32(out + 12, mctx-&gt;D[i]);
+        PUTU32(out + 16, mctx-&gt;E[i]);
+        out += 20;
+        len += 20;
+
+        /* pad */
+        pad = 15 - len % 16;
+        for (j = 0; j &lt;= pad; j++)
+            *(out++) = pad;
+        len += pad + 1;
+
+        ciph_d[i].blocks = (len - processed) / 16;
+        len += 16;              /* account for explicit iv */
+
+        /* arrange header */
+        out0[0] = ((u8 *)sctx-&gt;md.data)[8];
+        out0[1] = ((u8 *)sctx-&gt;md.data)[9];
+        out0[2] = ((u8 *)sctx-&gt;md.data)[10];
+        out0[3] = (u8)(len &gt;&gt; 8);
+        out0[4] = (u8)(len);
+
+        ret += len + 5;
+        inp += frag;
+    }
+
+    aesni_multi_cbc_encrypt(ciph_d, &amp;ctx-&gt;ks, n4x);
+
+    OPENSSL_cleanse(blocks, sizeof(blocks));
+    OPENSSL_cleanse(mctx, sizeof(*mctx));
+
+    ctx-&gt;multiblock_encrypt_len = ret;
+    return ret;
+}
+# endif /* OPENSSL_NO_MULTIBLOCK */
+
+static int aesni_cbc_hmac_sha1_cipher(PROV_CIPHER_CTX *vctx,
+                                      unsigned char *out,
+                                      const unsigned char *in, size_t len)
+{
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_AES_HMAC_SHA1_CTX *sctx = (PROV_AES_HMAC_SHA1_CTX *)vctx;
+    unsigned int l;
+    size_t plen = ctx-&gt;payload_length;
+    size_t iv = 0; /* explicit IV in TLS 1.1 and later */
+    size_t aes_off = 0, blocks;
+    size_t sha_off = SHA_CBLOCK - sctx-&gt;md.num;
+
+    ctx-&gt;payload_length = NO_PAYLOAD_LENGTH;
+
+    if (len % AES_BLOCK_SIZE)
+        return 0;
+
+    if (ctx-&gt;base.enc) {
+        if (plen == NO_PAYLOAD_LENGTH)
+            plen = len;
+        else if (len !=
+                 ((plen + SHA_DIGEST_LENGTH +
+                   AES_BLOCK_SIZE) &amp; -AES_BLOCK_SIZE))
+            return 0;
+        else if (ctx-&gt;aux.tls_ver &gt;= TLS1_1_VERSION)
+            iv = AES_BLOCK_SIZE;
+
+        if (plen &gt; (sha_off + iv)
+                &amp;&amp; (blocks = (plen - (sha_off + iv)) / SHA_CBLOCK)) {
+            sha1_update(&amp;sctx-&gt;md, in + iv, sha_off);
+
+            aesni_cbc_sha1_enc(in, out, blocks, &amp;ctx-&gt;ks, ctx-&gt;base.iv,
+                               &amp;sctx-&gt;md, in + iv + sha_off);
+            blocks *= SHA_CBLOCK;
+            aes_off += blocks;
+            sha_off += blocks;
+            sctx-&gt;md.Nh += blocks &gt;&gt; 29;
+            sctx-&gt;md.Nl += blocks &lt;&lt;= 3;
+            if (sctx-&gt;md.Nl &lt; (unsigned int)blocks)
+                sctx-&gt;md.Nh++;
+        } else {
+            sha_off = 0;
+        }
+        sha_off += iv;
+        sha1_update(&amp;sctx-&gt;md, in + sha_off, plen - sha_off);
+
+        if (plen != len) {      /* &quot;TLS&quot; mode of operation */
+            if (in != out)
+                memcpy(out + aes_off, in + aes_off, plen - aes_off);
+
+            /* calculate HMAC and append it to payload */
+            SHA1_Final(out + plen, &amp;sctx-&gt;md);
+            sctx-&gt;md = sctx-&gt;tail;
+            sha1_update(&amp;sctx-&gt;md, out + plen, SHA_DIGEST_LENGTH);
+            SHA1_Final(out + plen, &amp;sctx-&gt;md);
+
+            /* pad the payload|hmac */
+            plen += SHA_DIGEST_LENGTH;
+            for (l = len - plen - 1; plen &lt; len; plen++)
+                out[plen] = l;
+            /* encrypt HMAC|padding at once */
+            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,
+                              &amp;ctx-&gt;ks, ctx-&gt;base.iv, 1);
+        } else {
+            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,
+                              &amp;ctx-&gt;ks, ctx-&gt;base.iv, 1);
+        }
+    } else {
+        union {
+            unsigned int u[SHA_DIGEST_LENGTH / sizeof(unsigned int)];
+            unsigned char c[32 + SHA_DIGEST_LENGTH];
+        } mac, *pmac;
+
+        /* arrange cache line alignment */
+        pmac = (void *)(((size_t)mac.c + 31) &amp; ((size_t)0 - 32));
+
+        if (plen != NO_PAYLOAD_LENGTH) { /* &quot;TLS&quot; mode of operation */
+            size_t inp_len, mask, j, i;
+            unsigned int res, maxpad, pad, bitlen;
+            int ret = 1;
+            union {
+                unsigned int u[SHA_LBLOCK];
+                unsigned char c[SHA_CBLOCK];
+            } *data = (void *)sctx-&gt;md.data;
+
+            if ((ctx-&gt;aux.tls_aad[plen - 4] &lt;&lt; 8 | ctx-&gt;aux.tls_aad[plen - 3])
+                &gt;= TLS1_1_VERSION) {
+                if (len &lt; (AES_BLOCK_SIZE + SHA_DIGEST_LENGTH + 1))
+                    return 0;
+
+                /* omit explicit iv */
+                memcpy(ctx-&gt;base.iv, in, AES_BLOCK_SIZE);
+
+                in += AES_BLOCK_SIZE;
+                out += AES_BLOCK_SIZE;
+                len -= AES_BLOCK_SIZE;
+            } else if (len &lt; (SHA_DIGEST_LENGTH + 1))
+                return 0;
+
+            /* decrypt HMAC|padding at once */
+            aesni_cbc_encrypt(in, out, len, &amp;ctx-&gt;ks, ctx-&gt;base.iv, 0);
+
+            /* figure out payload length */
+            pad = out[len - 1];
+            maxpad = len - (SHA_DIGEST_LENGTH + 1);
+            maxpad |= (255 - maxpad) &gt;&gt; (sizeof(maxpad) * 8 - 8);
+            maxpad &amp;= 255;
+
+            mask = constant_time_ge(maxpad, pad);
+            ret &amp;= mask;
+            /*
+             * If pad is invalid then we will fail the above test but we must
+             * continue anyway because we are in constant time code. However,
+             * we'll use the maxpad value instead of the supplied pad to make
+             * sure we perform well defined pointer arithmetic.
+             */
+            pad = constant_time_select(mask, pad, maxpad);
+
+            inp_len = len - (SHA_DIGEST_LENGTH + pad + 1);
+
+            ctx-&gt;aux.tls_aad[plen - 2] = inp_len &gt;&gt; 8;
+            ctx-&gt;aux.tls_aad[plen - 1] = inp_len;
+
+            /* calculate HMAC */
+            sctx-&gt;md = sctx-&gt;head;
+            sha1_update(&amp;sctx-&gt;md, ctx-&gt;aux.tls_aad, plen);
+
+            /* code containing lucky-13 fix */
+            len -= SHA_DIGEST_LENGTH; /* amend mac */
+            if (len &gt;= (256 + SHA_CBLOCK)) {
+                j = (len - (256 + SHA_CBLOCK)) &amp; (0 - SHA_CBLOCK);
+                j += SHA_CBLOCK - sctx-&gt;md.num;
+                sha1_update(&amp;sctx-&gt;md, out, j);
+                out += j;
+                len -= j;
+                inp_len -= j;
+            }
+
+            /* but pretend as if we hashed padded payload */
+            bitlen = sctx-&gt;md.Nl + (inp_len &lt;&lt; 3); /* at most 18 bits */
+# ifdef BSWAP4
+            bitlen = BSWAP4(bitlen);
+# else
+            mac.c[0] = 0;
+            mac.c[1] = (unsigned char)(bitlen &gt;&gt; 16);
+            mac.c[2] = (unsigned char)(bitlen &gt;&gt; 8);
+            mac.c[3] = (unsigned char)bitlen;
+            bitlen = mac.u[0];
+# endif /* BSWAP */
+
+            pmac-&gt;u[0] = 0;
+            pmac-&gt;u[1] = 0;
+            pmac-&gt;u[2] = 0;
+            pmac-&gt;u[3] = 0;
+            pmac-&gt;u[4] = 0;
+
+            for (res = sctx-&gt;md.num, j = 0; j &lt; len; j++) {
+                size_t c = out[j];
+                mask = (j - inp_len) &gt;&gt; (sizeof(j) * 8 - 8);
+                c &amp;= mask;
+                c |= 0x80 &amp; ~mask &amp; ~((inp_len - j) &gt;&gt; (sizeof(j) * 8 - 8));
+                data-&gt;c[res++] = (unsigned char)c;
+
+                if (res != SHA_CBLOCK)
+                    continue;
+
+                /* j is not incremented yet */
+                mask = 0 - ((inp_len + 7 - j) &gt;&gt; (sizeof(j) * 8 - 1));
+                data-&gt;u[SHA_LBLOCK - 1] |= bitlen &amp; mask;
+                sha1_block_data_order(&amp;sctx-&gt;md, data, 1);
+                mask &amp;= 0 - ((j - inp_len - 72) &gt;&gt; (sizeof(j) * 8 - 1));
+                pmac-&gt;u[0] |= sctx-&gt;md.h0 &amp; mask;
+                pmac-&gt;u[1] |= sctx-&gt;md.h1 &amp; mask;
+                pmac-&gt;u[2] |= sctx-&gt;md.h2 &amp; mask;
+                pmac-&gt;u[3] |= sctx-&gt;md.h3 &amp; mask;
+                pmac-&gt;u[4] |= sctx-&gt;md.h4 &amp; mask;
+                res = 0;
+            }
+
+            for (i = res; i &lt; SHA_CBLOCK; i++, j++)
+                data-&gt;c[i] = 0;
+
+            if (res &gt; SHA_CBLOCK - 8) {
+                mask = 0 - ((inp_len + 8 - j) &gt;&gt; (sizeof(j) * 8 - 1));
+                data-&gt;u[SHA_LBLOCK - 1] |= bitlen &amp; mask;
+                sha1_block_data_order(&amp;sctx-&gt;md, data, 1);
+                mask &amp;= 0 - ((j - inp_len - 73) &gt;&gt; (sizeof(j) * 8 - 1));
+                pmac-&gt;u[0] |= sctx-&gt;md.h0 &amp; mask;
+                pmac-&gt;u[1] |= sctx-&gt;md.h1 &amp; mask;
+                pmac-&gt;u[2] |= sctx-&gt;md.h2 &amp; mask;
+                pmac-&gt;u[3] |= sctx-&gt;md.h3 &amp; mask;
+                pmac-&gt;u[4] |= sctx-&gt;md.h4 &amp; mask;
+
+                memset(data, 0, SHA_CBLOCK);
+                j += 64;
+            }
+            data-&gt;u[SHA_LBLOCK - 1] = bitlen;
+            sha1_block_data_order(&amp;sctx-&gt;md, data, 1);
+            mask = 0 - ((j - inp_len - 73) &gt;&gt; (sizeof(j) * 8 - 1));
+            pmac-&gt;u[0] |= sctx-&gt;md.h0 &amp; mask;
+            pmac-&gt;u[1] |= sctx-&gt;md.h1 &amp; mask;
+            pmac-&gt;u[2] |= sctx-&gt;md.h2 &amp; mask;
+            pmac-&gt;u[3] |= sctx-&gt;md.h3 &amp; mask;
+            pmac-&gt;u[4] |= sctx-&gt;md.h4 &amp; mask;
+
+# ifdef BSWAP4
+            pmac-&gt;u[0] = BSWAP4(pmac-&gt;u[0]);
+            pmac-&gt;u[1] = BSWAP4(pmac-&gt;u[1]);
+            pmac-&gt;u[2] = BSWAP4(pmac-&gt;u[2]);
+            pmac-&gt;u[3] = BSWAP4(pmac-&gt;u[3]);
+            pmac-&gt;u[4] = BSWAP4(pmac-&gt;u[4]);
+# else
+            for (i = 0; i &lt; 5; i++) {
+                res = pmac-&gt;u[i];
+                pmac-&gt;c[4 * i + 0] = (unsigned char)(res &gt;&gt; 24);
+                pmac-&gt;c[4 * i + 1] = (unsigned char)(res &gt;&gt; 16);
+                pmac-&gt;c[4 * i + 2] = (unsigned char)(res &gt;&gt; 8);
+                pmac-&gt;c[4 * i + 3] = (unsigned char)res;
+            }
+# endif /* BSWAP4 */
+            len += SHA_DIGEST_LENGTH;
+            sctx-&gt;md = sctx-&gt;tail;
+            sha1_update(&amp;sctx-&gt;md, pmac-&gt;c, SHA_DIGEST_LENGTH);
+            SHA1_Final(pmac-&gt;c, &amp;sctx-&gt;md);
+
+            /* verify HMAC */
+            out += inp_len;
+            len -= inp_len;
+            /* version of code with lucky-13 fix */
+            {
+                unsigned char *p = out + len - 1 - maxpad - SHA_DIGEST_LENGTH;
+                size_t off = out - p;
+                unsigned int c, cmask;
+
+                maxpad += SHA_DIGEST_LENGTH;
+                for (res = 0, i = 0, j = 0; j &lt; maxpad; j++) {
+                    c = p[j];
+                    cmask =
+                        ((int)(j - off - SHA_DIGEST_LENGTH)) &gt;&gt; (sizeof(int) *
+                                                                 8 - 1);
+                    res |= (c ^ pad) &amp; ~cmask; /* ... and padding */
+                    cmask &amp;= ((int)(off - 1 - j)) &gt;&gt; (sizeof(int) * 8 - 1);
+                    res |= (c ^ pmac-&gt;c[i]) &amp; cmask;
+                    i += 1 &amp; cmask;
+                }
+                maxpad -= SHA_DIGEST_LENGTH;
+
+                res = 0 - ((0 - res) &gt;&gt; (sizeof(res) * 8 - 1));
+                ret &amp;= (int)~res;
+            }
+            return ret;
+        } else {
+            /* decrypt HMAC|padding at once */
+            aesni_cbc_encrypt(in, out, len, &amp;ctx-&gt;ks, ctx-&gt;base.iv, 0);
+            sha1_update(&amp;sctx-&gt;md, out, len);
+        }
+    }
+
+    return 1;
+}
+
+/* EVP_CTRL_AEAD_SET_MAC_KEY */
+static void aesni_cbc_hmac_sha1_set_mac_key(void *vctx,
+                                            const unsigned char *mac, size_t len)
+{
+    PROV_AES_HMAC_SHA1_CTX *ctx = (PROV_AES_HMAC_SHA1_CTX *)vctx;
+    unsigned int i;
+    unsigned char hmac_key[64];
+
+    memset(hmac_key, 0, sizeof(hmac_key));
+
+    if (len &gt; (int)sizeof(hmac_key)) {
+        SHA1_Init(&amp;ctx-&gt;head);
+        sha1_update(&amp;ctx-&gt;head, mac, len);
+        SHA1_Final(hmac_key, &amp;ctx-&gt;head);
+    } else {
+        memcpy(hmac_key, mac, len);
+    }
+
+    for (i = 0; i &lt; sizeof(hmac_key); i++)
+        hmac_key[i] ^= 0x36; /* ipad */
+    SHA1_Init(&amp;ctx-&gt;head);
+    sha1_update(&amp;ctx-&gt;head, hmac_key, sizeof(hmac_key));
+
+    for (i = 0; i &lt; sizeof(hmac_key); i++)
+        hmac_key[i] ^= 0x36 ^ 0x5c; /* opad */
+    SHA1_Init(&amp;ctx-&gt;tail);
+    sha1_update(&amp;ctx-&gt;tail, hmac_key, sizeof(hmac_key));
+
+    OPENSSL_cleanse(hmac_key, sizeof(hmac_key));
+}
+
+/* EVP_CTRL_AEAD_TLS1_AAD */
+static int aesni_cbc_hmac_sha1_set_tls1_aad(void *vctx,
+                                            unsigned char *aad_rec, int aad_len)
+{
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_AES_HMAC_SHA1_CTX *sctx = (PROV_AES_HMAC_SHA1_CTX *)vctx;
+    unsigned char *p = aad_rec;
+    unsigned int len;
+
+    if (aad_len != EVP_AEAD_TLS1_AAD_LEN)
+        return -1;
+
+    len = p[aad_len - 2] &lt;&lt; 8 | p[aad_len - 1];
+
+    if (ctx-&gt;base.enc) {
+        ctx-&gt;payload_length = len;
+        if ((ctx-&gt;aux.tls_ver =
+             p[aad_len - 4] &lt;&lt; 8 | p[aad_len - 3]) &gt;= TLS1_1_VERSION) {
+            if (len &lt; AES_BLOCK_SIZE)
+                return 0;
+            len -= AES_BLOCK_SIZE;
+            p[aad_len - 2] = len &gt;&gt; 8;
+            p[aad_len - 1] = len;
+        }
+        sctx-&gt;md = sctx-&gt;head;
+        sha1_update(&amp;sctx-&gt;md, p, aad_len);
+        ctx-&gt;tls_aad_pad = (int)(((len + SHA_DIGEST_LENGTH +
+                       AES_BLOCK_SIZE) &amp; -AES_BLOCK_SIZE)
+                     - len);
+        return 1;
+    } else {
+        memcpy(ctx-&gt;aux.tls_aad, aad_rec, aad_len);
+        ctx-&gt;payload_length = aad_len;
+        ctx-&gt;tls_aad_pad = SHA_DIGEST_LENGTH;
+        return 1;
+    }
+}
+
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+
+/* EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE */
+static int aesni_cbc_hmac_sha1_tls1_multiblock_max_bufsize(void *vctx)
+{
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+
+    OPENSSL_assert(ctx-&gt;multiblock_max_send_fragment != 0);
+    return (int)(5 + 16
+                 + (((int)ctx-&gt;multiblock_max_send_fragment + 20 + 16) &amp; -16));
+}
+
+/* EVP_CTRL_TLS1_1_MULTIBLOCK_AAD */
+static int aesni_cbc_hmac_sha1_tls1_multiblock_aad(
+    void *vctx, EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *param)
+{
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_AES_HMAC_SHA1_CTX *sctx = (PROV_AES_HMAC_SHA1_CTX *)vctx;
+    unsigned int n4x = 1, x4;
+    unsigned int frag, last, packlen, inp_len;
+
+    inp_len = param-&gt;inp[11] &lt;&lt; 8 | param-&gt;inp[12];
+    ctx-&gt;multiblock_interleave = param-&gt;interleave;
+
+    if (ctx-&gt;base.enc) {
+        if ((param-&gt;inp[9] &lt;&lt; 8 | param-&gt;inp[10]) &lt; TLS1_1_VERSION)
+            return -1;
+
+        if (inp_len) {
+            if (inp_len &lt; 4096)
+                return 0; /* too short */
+
+            if (inp_len &gt;= 8192 &amp;&amp; OPENSSL_ia32cap_P[2] &amp; (1 &lt;&lt; 5))
+                n4x = 2; /* AVX2 */
+        } else if ((n4x = param-&gt;interleave / 4) &amp;&amp; n4x &lt;= 2)
+            inp_len = param-&gt;len;
+        else
+            return -1;
+
+        sctx-&gt;md = sctx-&gt;head;
+        sha1_update(&amp;sctx-&gt;md, param-&gt;inp, 13);
+
+        x4 = 4 * n4x;
+        n4x += 1;
+
+        frag = inp_len &gt;&gt; n4x;
+        last = inp_len + frag - (frag &lt;&lt; n4x);
+        if (last &gt; frag &amp;&amp; ((last + 13 + 9) % 64 &lt; (x4 - 1))) {
+            frag++;
+            last -= x4 - 1;
+        }
+
+        packlen = 5 + 16 + ((frag + 20 + 16) &amp; -16);
+        packlen = (packlen &lt;&lt; n4x) - packlen;
+        packlen += 5 + 16 + ((last + 20 + 16) &amp; -16);
+
+        param-&gt;interleave = x4;
+        /* The returned values used by get need to be stored */
+        ctx-&gt;multiblock_interleave = x4;
+        ctx-&gt;multiblock_aad_packlen = packlen;
+        return 1;
+    }
+    return -1;      /* not yet */
+}
+
+/* EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT */
+static int aesni_cbc_hmac_sha1_tls1_multiblock_encrypt(
+    void *ctx, EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *param)
+{
+    return (int)tls1_multi_block_encrypt(ctx, param-&gt;out,
+                                         param-&gt;inp, param-&gt;len,
+                                         param-&gt;interleave / 4);
+}
+
+#endif /* OPENSSL_NO_MULTIBLOCK */
+
+static const PROV_CIPHER_HW_AES_HMAC_SHA cipher_hw_aes_hmac_sha1 = {
+    {
+      aesni_cbc_hmac_sha1_init_key,
+      aesni_cbc_hmac_sha1_cipher
+    },
+    aesni_cbc_hmac_sha1_set_mac_key,
+    aesni_cbc_hmac_sha1_set_tls1_aad,
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+    aesni_cbc_hmac_sha1_tls1_multiblock_max_bufsize,
+    aesni_cbc_hmac_sha1_tls1_multiblock_aad,
+    aesni_cbc_hmac_sha1_tls1_multiblock_encrypt
+# endif
+};
+
+const PROV_CIPHER_HW_AES_HMAC_SHA *PROV_CIPHER_HW_aes_cbc_hmac_sha1(void)
+{
+    return &amp;cipher_hw_aes_hmac_sha1;
+}
+
+#endif /* AES_CBC_HMAC_SHA_CAPABLE */
diff --git a/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha256_hw.c b/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha256_hw.c
new file mode 100644
index 0000000000..4352476264
--- /dev/null
+++ b/providers/implementations/ciphers/cipher_aes_cbc_hmac_sha256_hw.c
@@ -0,0 +1,831 @@
+/*
+ * Copyright 2011-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &quot;cipher_aes_cbc_hmac_sha.h&quot;
+
+#ifndef AES_CBC_HMAC_SHA_CAPABLE
+int cipher_capable_aes_cbc_hmac_sha256(void)
+{
+    return 0;
+}
+#else
+
+# include &quot;crypto/rand.h&quot;
+# include &quot;crypto/evp.h&quot;
+# include &quot;internal/constant_time.h&quot;
+
+void sha256_block_data_order(void *c, const void *p, size_t len);
+int aesni_cbc_sha256_enc(const void *inp, void *out, size_t blocks,
+                         const AES_KEY *key, unsigned char iv[16],
+                         SHA256_CTX *ctx, const void *in0);
+
+int cipher_capable_aes_cbc_hmac_sha256(void)
+{
+    return AESNI_CBC_HMAC_SHA_CAPABLE
+           &amp;&amp; aesni_cbc_sha256_enc(NULL, NULL, 0, NULL, NULL, NULL, NULL);
+}
+
+static int aesni_cbc_hmac_sha256_init_key(PROV_CIPHER_CTX *vctx,
+                                          const unsigned char *key,
+                                          size_t keylen)
+{
+    int ret;
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_AES_HMAC_SHA256_CTX *sctx = (PROV_AES_HMAC_SHA256_CTX *)vctx;
+
+    if (ctx-&gt;base.enc)
+        ret = aesni_set_encrypt_key(key, ctx-&gt;base.keylen * 8, &amp;ctx-&gt;ks);
+    else
+        ret = aesni_set_decrypt_key(key, ctx-&gt;base.keylen * 8, &amp;ctx-&gt;ks);
+
+    SHA256_Init(&amp;sctx-&gt;head);    /* handy when benchmarking */
+    sctx-&gt;tail = sctx-&gt;head;
+    sctx-&gt;md = sctx-&gt;head;
+
+    ctx-&gt;payload_length = NO_PAYLOAD_LENGTH;
+
+    return ret &lt; 0 ? 0 : 1;
+}
+
+void sha256_block_data_order(void *c, const void *p, size_t len);
+
+static void sha256_update(SHA256_CTX *c, const void *data, size_t len)
+{
+    const unsigned char *ptr = data;
+    size_t res;
+
+    if ((res = c-&gt;num)) {
+        res = SHA256_CBLOCK - res;
+        if (len &lt; res)
+            res = len;
+        SHA256_Update(c, ptr, res);
+        ptr += res;
+        len -= res;
+    }
+
+    res = len % SHA256_CBLOCK;
+    len -= res;
+
+    if (len) {
+        sha256_block_data_order(c, ptr, len / SHA256_CBLOCK);
+
+        ptr += len;
+        c-&gt;Nh += len &gt;&gt; 29;
+        c-&gt;Nl += len &lt;&lt;= 3;
+        if (c-&gt;Nl &lt; (unsigned int)len)
+            c-&gt;Nh++;
+    }
+
+    if (res)
+        SHA256_Update(c, ptr, res);
+}
+
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+
+typedef struct {
+    unsigned int A[8], B[8], C[8], D[8], E[8], F[8], G[8], H[8];
+} SHA256_MB_CTX;
+
+typedef struct {
+    const unsigned char *ptr;
+    int blocks;
+} HASH_DESC;
+
+typedef struct {
+    const unsigned char *inp;
+    unsigned char *out;
+    int blocks;
+    u64 iv[2];
+} CIPH_DESC;
+
+void sha256_multi_block(SHA256_MB_CTX *, const HASH_DESC *, int);
+void aesni_multi_cbc_encrypt(CIPH_DESC *, void *, int);
+
+static size_t tls1_multi_block_encrypt(void *vctx,
+                                       unsigned char *out,
+                                       const unsigned char *inp,
+                                       size_t inp_len, int n4x)
+{                               /* n4x is 1 or 2 */
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_AES_HMAC_SHA256_CTX *sctx = (PROV_AES_HMAC_SHA256_CTX *)vctx;
+    HASH_DESC hash_d[8], edges[8];
+    CIPH_DESC ciph_d[8];
+    unsigned char storage[sizeof(SHA256_MB_CTX) + 32];
+    union {
+        u64 q[16];
+        u32 d[32];
+        u8 c[128];
+    } blocks[8];
+    SHA256_MB_CTX *mctx;
+    unsigned int frag, last, packlen, i;
+    unsigned int x4 = 4 * n4x, minblocks, processed = 0;
+    size_t ret = 0;
+    u8 *IVs;
+#  if defined(BSWAP8)
+    u64 seqnum;
+#  endif
+
+    /* ask for IVs in bulk */
+    if (rand_bytes_ex(ctx-&gt;base.libctx, (IVs = blocks[0].c), 16 * x4) &lt;= 0)
+        return 0;
+
+    mctx = (SHA256_MB_CTX *) (storage + 32 - ((size_t)storage % 32)); /* align */
+
+    frag = (unsigned int)inp_len &gt;&gt; (1 + n4x);
+    last = (unsigned int)inp_len + frag - (frag &lt;&lt; (1 + n4x));
+    if (last &gt; frag &amp;&amp; ((last + 13 + 9) % 64) &lt; (x4 - 1)) {
+        frag++;
+        last -= x4 - 1;
+    }
+
+    packlen = 5 + 16 + ((frag + 32 + 16) &amp; -16);
+
+    /* populate descriptors with pointers and IVs */
+    hash_d[0].ptr = inp;
+    ciph_d[0].inp = inp;
+    /* 5+16 is place for header and explicit IV */
+    ciph_d[0].out = out + 5 + 16;
+    memcpy(ciph_d[0].out - 16, IVs, 16);
+    memcpy(ciph_d[0].iv, IVs, 16);
+    IVs += 16;
+
+    for (i = 1; i &lt; x4; i++) {
+        ciph_d[i].inp = hash_d[i].ptr = hash_d[i - 1].ptr + frag;
+        ciph_d[i].out = ciph_d[i - 1].out + packlen;
+        memcpy(ciph_d[i].out - 16, IVs, 16);
+        memcpy(ciph_d[i].iv, IVs, 16);
+        IVs += 16;
+    }
+
+#  if defined(BSWAP8)
+    memcpy(blocks[0].c, sctx-&gt;md.data, 8);
+    seqnum = BSWAP8(blocks[0].q[0]);
+#  endif
+
+    for (i = 0; i &lt; x4; i++) {
+        unsigned int len = (i == (x4 - 1) ? last : frag);
+#  if !defined(BSWAP8)
+        unsigned int carry, j;
+#  endif
+
+        mctx-&gt;A[i] = sctx-&gt;md.h[0];
+        mctx-&gt;B[i] = sctx-&gt;md.h[1];
+        mctx-&gt;C[i] = sctx-&gt;md.h[2];
+        mctx-&gt;D[i] = sctx-&gt;md.h[3];
+        mctx-&gt;E[i] = sctx-&gt;md.h[4];
+        mctx-&gt;F[i] = sctx-&gt;md.h[5];
+        mctx-&gt;G[i] = sctx-&gt;md.h[6];
+        mctx-&gt;H[i] = sctx-&gt;md.h[7];
+
+        /* fix seqnum */
+#  if defined(BSWAP8)
+        blocks[i].q[0] = BSWAP8(seqnum + i);
+#  else
+        for (carry = i, j = 8; j--;) {
+            blocks[i].c[j] = ((u8 *)sctx-&gt;md.data)[j] + carry;
+            carry = (blocks[i].c[j] - carry) &gt;&gt; (sizeof(carry) * 8 - 1);
+        }
+#  endif
+        blocks[i].c[8] = ((u8 *)sctx-&gt;md.data)[8];
+        blocks[i].c[9] = ((u8 *)sctx-&gt;md.data)[9];
+        blocks[i].c[10] = ((u8 *)sctx-&gt;md.data)[10];
+        /* fix length */
+        blocks[i].c[11] = (u8)(len &gt;&gt; 8);
+        blocks[i].c[12] = (u8)(len);
+
+        memcpy(blocks[i].c + 13, hash_d[i].ptr, 64 - 13);
+        hash_d[i].ptr += 64 - 13;
+        hash_d[i].blocks = (len - (64 - 13)) / 64;
+
+        edges[i].ptr = blocks[i].c;
+        edges[i].blocks = 1;
+    }
+
+    /* hash 13-byte headers and first 64-13 bytes of inputs */
+    sha256_multi_block(mctx, edges, n4x);
+    /* hash bulk inputs */
+#  define MAXCHUNKSIZE    2048
+#  if     MAXCHUNKSIZE%64
+#   error  &quot;MAXCHUNKSIZE is not divisible by 64&quot;
+#  elif   MAXCHUNKSIZE
+    /*
+     * goal is to minimize pressure on L1 cache by moving in shorter steps,
+     * so that hashed data is still in the cache by the time we encrypt it
+     */
+    minblocks = ((frag &lt;= last ? frag : last) - (64 - 13)) / 64;
+    if (minblocks &gt; MAXCHUNKSIZE / 64) {
+        for (i = 0; i &lt; x4; i++) {
+            edges[i].ptr = hash_d[i].ptr;
+            edges[i].blocks = MAXCHUNKSIZE / 64;
+            ciph_d[i].blocks = MAXCHUNKSIZE / 16;
+        }
+        do {
+            sha256_multi_block(mctx, edges, n4x);
+            aesni_multi_cbc_encrypt(ciph_d, &amp;ctx-&gt;ks, n4x);
+
+            for (i = 0; i &lt; x4; i++) {
+                edges[i].ptr = hash_d[i].ptr += MAXCHUNKSIZE;
+                hash_d[i].blocks -= MAXCHUNKSIZE / 64;
+                edges[i].blocks = MAXCHUNKSIZE / 64;
+                ciph_d[i].inp += MAXCHUNKSIZE;
+                ciph_d[i].out += MAXCHUNKSIZE;
+                ciph_d[i].blocks = MAXCHUNKSIZE / 16;
+                memcpy(ciph_d[i].iv, ciph_d[i].out - 16, 16);
+            }
+            processed += MAXCHUNKSIZE;
+            minblocks -= MAXCHUNKSIZE / 64;
+        } while (minblocks &gt; MAXCHUNKSIZE / 64);
+    }
+#  endif
+#  undef  MAXCHUNKSIZE
+    sha256_multi_block(mctx, hash_d, n4x);
+
+    memset(blocks, 0, sizeof(blocks));
+    for (i = 0; i &lt; x4; i++) {
+        unsigned int len = (i == (x4 - 1) ? last : frag),
+            off = hash_d[i].blocks * 64;
+        const unsigned char *ptr = hash_d[i].ptr + off;
+
+        off = (len - processed) - (64 - 13) - off; /* remainder actually */
+        memcpy(blocks[i].c, ptr, off);
+        blocks[i].c[off] = 0x80;
+        len += 64 + 13;         /* 64 is HMAC header */
+        len *= 8;               /* convert to bits */
+        if (off &lt; (64 - 8)) {
+#  ifdef BSWAP4
+            blocks[i].d[15] = BSWAP4(len);
+#  else
+            PUTU32(blocks[i].c + 60, len);
+#  endif
+            edges[i].blocks = 1;
+        } else {
+#  ifdef BSWAP4
+            blocks[i].d[31] = BSWAP4(len);
+#  else
+            PUTU32(blocks[i].c + 124, len);
+#  endif
+            edges[i].blocks = 2;
+        }
+        edges[i].ptr = blocks[i].c;
+    }
+
+    /* hash input tails and finalize */
+    sha256_multi_block(mctx, edges, n4x);
+
+    memset(blocks, 0, sizeof(blocks));
+    for (i = 0; i &lt; x4; i++) {
+#  ifdef BSWAP4
+        blocks[i].d[0] = BSWAP4(mctx-&gt;A[i]);
+        mctx-&gt;A[i] = sctx-&gt;tail.h[0];
+        blocks[i].d[1] = BSWAP4(mctx-&gt;B[i]);
+        mctx-&gt;B[i] = sctx-&gt;tail.h[1];
+        blocks[i].d[2] = BSWAP4(mctx-&gt;C[i]);
+        mctx-&gt;C[i] = sctx-&gt;tail.h[2];
+        blocks[i].d[3] = BSWAP4(mctx-&gt;D[i]);
+        mctx-&gt;D[i] = sctx-&gt;tail.h[3];
+        blocks[i].d[4] = BSWAP4(mctx-&gt;E[i]);
+        mctx-&gt;E[i] = sctx-&gt;tail.h[4];
+        blocks[i].d[5] = BSWAP4(mctx-&gt;F[i]);
+        mctx-&gt;F[i] = sctx-&gt;tail.h[5];
+        blocks[i].d[6] = BSWAP4(mctx-&gt;G[i]);
+        mctx-&gt;G[i] = sctx-&gt;tail.h[6];
+        blocks[i].d[7] = BSWAP4(mctx-&gt;H[i]);
+        mctx-&gt;H[i] = sctx-&gt;tail.h[7];
+        blocks[i].c[32] = 0x80;
+        blocks[i].d[15] = BSWAP4((64 + 32) * 8);
+#  else
+        PUTU32(blocks[i].c + 0, mctx-&gt;A[i]);
+        mctx-&gt;A[i] = sctx-&gt;tail.h[0];
+        PUTU32(blocks[i].c + 4, mctx-&gt;B[i]);
+        mctx-&gt;B[i] = sctx-&gt;tail.h[1];
+        PUTU32(blocks[i].c + 8, mctx-&gt;C[i]);
+        mctx-&gt;C[i] = sctx-&gt;tail.h[2];
+        PUTU32(blocks[i].c + 12, mctx-&gt;D[i]);
+        mctx-&gt;D[i] = sctx-&gt;tail.h[3];
+        PUTU32(blocks[i].c + 16, mctx-&gt;E[i]);
+        mctx-&gt;E[i] = sctx-&gt;tail.h[4];
+        PUTU32(blocks[i].c + 20, mctx-&gt;F[i]);
+        mctx-&gt;F[i] = sctx-&gt;tail.h[5];
+        PUTU32(blocks[i].c + 24, mctx-&gt;G[i]);
+        mctx-&gt;G[i] = sctx-&gt;tail.h[6];
+        PUTU32(blocks[i].c + 28, mctx-&gt;H[i]);
+        mctx-&gt;H[i] = sctx-&gt;tail.h[7];
+        blocks[i].c[32] = 0x80;
+        PUTU32(blocks[i].c + 60, (64 + 32) * 8);
+#  endif /* BSWAP */
+        edges[i].ptr = blocks[i].c;
+        edges[i].blocks = 1;
+    }
+
+    /* finalize MACs */
+    sha256_multi_block(mctx, edges, n4x);
+
+    for (i = 0; i &lt; x4; i++) {
+        unsigned int len = (i == (x4 - 1) ? last : frag), pad, j;
+        unsigned char *out0 = out;
+
+        memcpy(ciph_d[i].out, ciph_d[i].inp, len - processed);
+        ciph_d[i].inp = ciph_d[i].out;
+
+        out += 5 + 16 + len;
+
+        /* write MAC */
+        PUTU32(out + 0, mctx-&gt;A[i]);
+        PUTU32(out + 4, mctx-&gt;B[i]);
+        PUTU32(out + 8, mctx-&gt;C[i]);
+        PUTU32(out + 12, mctx-&gt;D[i]);
+        PUTU32(out + 16, mctx-&gt;E[i]);
+        PUTU32(out + 20, mctx-&gt;F[i]);
+        PUTU32(out + 24, mctx-&gt;G[i]);
+        PUTU32(out + 28, mctx-&gt;H[i]);
+        out += 32;
+        len += 32;
+
+        /* pad */
+        pad = 15 - len % 16;
+        for (j = 0; j &lt;= pad; j++)
+            *(out++) = pad;
+        len += pad + 1;
+
+        ciph_d[i].blocks = (len - processed) / 16;
+        len += 16;              /* account for explicit iv */
+
+        /* arrange header */
+        out0[0] = ((u8 *)sctx-&gt;md.data)[8];
+        out0[1] = ((u8 *)sctx-&gt;md.data)[9];
+        out0[2] = ((u8 *)sctx-&gt;md.data)[10];
+        out0[3] = (u8)(len &gt;&gt; 8);
+        out0[4] = (u8)(len);
+
+        ret += len + 5;
+        inp += frag;
+    }
+
+    aesni_multi_cbc_encrypt(ciph_d, &amp;ctx-&gt;ks, n4x);
+
+    OPENSSL_cleanse(blocks, sizeof(blocks));
+    OPENSSL_cleanse(mctx, sizeof(*mctx));
+
+    ctx-&gt;multiblock_encrypt_len = ret;
+    return ret;
+}
+# endif /* !OPENSSL_NO_MULTIBLOCK */
+
+static int aesni_cbc_hmac_sha256_cipher(PROV_CIPHER_CTX *vctx,
+                                        unsigned char *out,
+                                        const unsigned char *in, size_t len)
+{
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_AES_HMAC_SHA256_CTX *sctx = (PROV_AES_HMAC_SHA256_CTX *)vctx;
+    unsigned int l;
+    size_t plen = ctx-&gt;payload_length;
+    size_t iv = 0; /* explicit IV in TLS 1.1 and * later */
+    size_t aes_off = 0, blocks;
+    size_t sha_off = SHA256_CBLOCK - sctx-&gt;md.num;
+
+    ctx-&gt;payload_length = NO_PAYLOAD_LENGTH;
+
+    if (len % AES_BLOCK_SIZE)
+        return 0;
+
+    if (ctx-&gt;base.enc) {
+        if (plen == NO_PAYLOAD_LENGTH)
+            plen = len;
+        else if (len !=
+                 ((plen + SHA256_DIGEST_LENGTH +
+                   AES_BLOCK_SIZE) &amp; -AES_BLOCK_SIZE))
+            return 0;
+        else if (ctx-&gt;aux.tls_ver &gt;= TLS1_1_VERSION)
+            iv = AES_BLOCK_SIZE;
+
+        /*
+         * Assembly stitch handles AVX-capable processors, but its
+         * performance is not optimal on AMD Jaguar, ~40% worse, for
+         * unknown reasons. Incidentally processor in question supports
+         * AVX, but not AMD-specific XOP extension, which can be used
+         * to identify it and avoid stitch invocation. So that after we
+         * establish that current CPU supports AVX, we even see if it's
+         * either even XOP-capable Bulldozer-based or GenuineIntel one.
+         * But SHAEXT-capable go ahead...
+         */
+        if (((OPENSSL_ia32cap_P[2] &amp; (1 &lt;&lt; 29)) ||         /* SHAEXT? */
+             ((OPENSSL_ia32cap_P[1] &amp; (1 &lt;&lt; (60 - 32))) &amp;&amp; /* AVX? */
+              ((OPENSSL_ia32cap_P[1] &amp; (1 &lt;&lt; (43 - 32)))   /* XOP? */
+               | (OPENSSL_ia32cap_P[0] &amp; (1 &lt;&lt; 30))))) &amp;&amp;  /* &quot;Intel CPU&quot;? */
+            plen &gt; (sha_off + iv) &amp;&amp;
+            (blocks = (plen - (sha_off + iv)) / SHA256_CBLOCK)) {
+            sha256_update(&amp;sctx-&gt;md, in + iv, sha_off);
+
+            (void)aesni_cbc_sha256_enc(in, out, blocks, &amp;ctx-&gt;ks,
+                                       ctx-&gt;base.iv,
+                                       &amp;sctx-&gt;md, in + iv + sha_off);
+            blocks *= SHA256_CBLOCK;
+            aes_off += blocks;
+            sha_off += blocks;
+            sctx-&gt;md.Nh += blocks &gt;&gt; 29;
+            sctx-&gt;md.Nl += blocks &lt;&lt;= 3;
+            if (sctx-&gt;md.Nl &lt; (unsigned int)blocks)
+                sctx-&gt;md.Nh++;
+        } else {
+            sha_off = 0;
+        }
+        sha_off += iv;
+        sha256_update(&amp;sctx-&gt;md, in + sha_off, plen - sha_off);
+
+        if (plen != len) {      /* &quot;TLS&quot; mode of operation */
+            if (in != out)
+                memcpy(out + aes_off, in + aes_off, plen - aes_off);
+
+            /* calculate HMAC and append it to payload */
+            SHA256_Final(out + plen, &amp;sctx-&gt;md);
+            sctx-&gt;md = sctx-&gt;tail;
+            sha256_update(&amp;sctx-&gt;md, out + plen, SHA256_DIGEST_LENGTH);
+            SHA256_Final(out + plen, &amp;sctx-&gt;md);
+
+            /* pad the payload|hmac */
+            plen += SHA256_DIGEST_LENGTH;
+            for (l = len - plen - 1; plen &lt; len; plen++)
+                out[plen] = l;
+            /* encrypt HMAC|padding at once */
+            aesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,
+                              &amp;ctx-&gt;ks, ctx-&gt;base.iv, 1);
+        } else {
+            aesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,
+                              &amp;ctx-&gt;ks, ctx-&gt;base.iv, 1);
+        }
+    } else {
+        union {
+            unsigned int u[SHA256_DIGEST_LENGTH / sizeof(unsigned int)];
+            unsigned char c[64 + SHA256_DIGEST_LENGTH];
+        } mac, *pmac;
+
+        /* arrange cache line alignment */
+        pmac = (void *)(((size_t)mac.c + 63) &amp; ((size_t)0 - 64));
+
+        /* decrypt HMAC|padding at once */
+        aesni_cbc_encrypt(in, out, len, &amp;ctx-&gt;ks,
+                          ctx-&gt;base.iv, 0);
+
+        if (plen != NO_PAYLOAD_LENGTH) { /* &quot;TLS&quot; mode of operation */
+            size_t inp_len, mask, j, i;
+            unsigned int res, maxpad, pad, bitlen;
+            int ret = 1;
+            union {
+                unsigned int u[SHA_LBLOCK];
+                unsigned char c[SHA256_CBLOCK];
+            } *data = (void *)sctx-&gt;md.data;
+
+            if ((ctx-&gt;aux.tls_aad[plen - 4] &lt;&lt; 8 | ctx-&gt;aux.tls_aad[plen - 3])
+                &gt;= TLS1_1_VERSION)
+                iv = AES_BLOCK_SIZE;
+
+            if (len &lt; (iv + SHA256_DIGEST_LENGTH + 1))
+                return 0;
+
+            /* omit explicit iv */
+            out += iv;
+            len -= iv;
+
+            /* figure out payload length */
+            pad = out[len - 1];
+            maxpad = len - (SHA256_DIGEST_LENGTH + 1);
+            maxpad |= (255 - maxpad) &gt;&gt; (sizeof(maxpad) * 8 - 8);
+            maxpad &amp;= 255;
+
+            mask = constant_time_ge(maxpad, pad);
+            ret &amp;= mask;
+            /*
+             * If pad is invalid then we will fail the above test but we must
+             * continue anyway because we are in constant time code. However,
+             * we'll use the maxpad value instead of the supplied pad to make
+             * sure we perform well defined pointer arithmetic.
+             */
+            pad = constant_time_select(mask, pad, maxpad);
+
+            inp_len = len - (SHA256_DIGEST_LENGTH + pad + 1);
+
+            ctx-&gt;aux.tls_aad[plen - 2] = inp_len &gt;&gt; 8;
+            ctx-&gt;aux.tls_aad[plen - 1] = inp_len;
+
+            /* calculate HMAC */
+            sctx-&gt;md = sctx-&gt;head;
+            sha256_update(&amp;sctx-&gt;md, ctx-&gt;aux.tls_aad, plen);
+
+            /* code with lucky-13 fix */
+            len -= SHA256_DIGEST_LENGTH; /* amend mac */
+            if (len &gt;= (256 + SHA256_CBLOCK)) {
+                j = (len - (256 + SHA256_CBLOCK)) &amp; (0 - SHA256_CBLOCK);
+                j += SHA256_CBLOCK - sctx-&gt;md.num;
+                sha256_update(&amp;sctx-&gt;md, out, j);
+                out += j;
+                len -= j;
+                inp_len -= j;
+            }
+
+            /* but pretend as if we hashed padded payload */
+            bitlen = sctx-&gt;md.Nl + (inp_len &lt;&lt; 3); /* at most 18 bits */
+# ifdef BSWAP4
+            bitlen = BSWAP4(bitlen);
+# else
+            mac.c[0] = 0;
+            mac.c[1] = (unsigned char)(bitlen &gt;&gt; 16);
+            mac.c[2] = (unsigned char)(bitlen &gt;&gt; 8);
+            mac.c[3] = (unsigned char)bitlen;
+            bitlen = mac.u[0];
+# endif /* BSWAP */
+
+            pmac-&gt;u[0] = 0;
+            pmac-&gt;u[1] = 0;
+            pmac-&gt;u[2] = 0;
+            pmac-&gt;u[3] = 0;
+            pmac-&gt;u[4] = 0;
+            pmac-&gt;u[5] = 0;
+            pmac-&gt;u[6] = 0;
+            pmac-&gt;u[7] = 0;
+
+            for (res = sctx-&gt;md.num, j = 0; j &lt; len; j++) {
+                size_t c = out[j];
+                mask = (j - inp_len) &gt;&gt; (sizeof(j) * 8 - 8);
+                c &amp;= mask;
+                c |= 0x80 &amp; ~mask &amp; ~((inp_len - j) &gt;&gt; (sizeof(j) * 8 - 8));
+                data-&gt;c[res++] = (unsigned char)c;
+
+                if (res != SHA256_CBLOCK)
+                    continue;
+
+                /* j is not incremented yet */
+                mask = 0 - ((inp_len + 7 - j) &gt;&gt; (sizeof(j) * 8 - 1));
+                data-&gt;u[SHA_LBLOCK - 1] |= bitlen &amp; mask;
+                sha256_block_data_order(&amp;sctx-&gt;md, data, 1);
+                mask &amp;= 0 - ((j - inp_len - 72) &gt;&gt; (sizeof(j) * 8 - 1));
+                pmac-&gt;u[0] |= sctx-&gt;md.h[0] &amp; mask;
+                pmac-&gt;u[1] |= sctx-&gt;md.h[1] &amp; mask;
+                pmac-&gt;u[2] |= sctx-&gt;md.h[2] &amp; mask;
+                pmac-&gt;u[3] |= sctx-&gt;md.h[3] &amp; mask;
+                pmac-&gt;u[4] |= sctx-&gt;md.h[4] &amp; mask;
+                pmac-&gt;u[5] |= sctx-&gt;md.h[5] &amp; mask;
+                pmac-&gt;u[6] |= sctx-&gt;md.h[6] &amp; mask;
+                pmac-&gt;u[7] |= sctx-&gt;md.h[7] &amp; mask;
+                res = 0;
+            }
+
+            for (i = res; i &lt; SHA256_CBLOCK; i++, j++)
+                data-&gt;c[i] = 0;
+
+            if (res &gt; SHA256_CBLOCK - 8) {
+                mask = 0 - ((inp_len + 8 - j) &gt;&gt; (sizeof(j) * 8 - 1));
+                data-&gt;u[SHA_LBLOCK - 1] |= bitlen &amp; mask;
+                sha256_block_data_order(&amp;sctx-&gt;md, data, 1);
+                mask &amp;= 0 - ((j - inp_len - 73) &gt;&gt; (sizeof(j) * 8 - 1));
+                pmac-&gt;u[0] |= sctx-&gt;md.h[0] &amp; mask;
+                pmac-&gt;u[1] |= sctx-&gt;md.h[1] &amp; mask;
+                pmac-&gt;u[2] |= sctx-&gt;md.h[2] &amp; mask;
+                pmac-&gt;u[3] |= sctx-&gt;md.h[3] &amp; mask;
+                pmac-&gt;u[4] |= sctx-&gt;md.h[4] &amp; mask;
+                pmac-&gt;u[5] |= sctx-&gt;md.h[5] &amp; mask;
+                pmac-&gt;u[6] |= sctx-&gt;md.h[6] &amp; mask;
+                pmac-&gt;u[7] |= sctx-&gt;md.h[7] &amp; mask;
+
+                memset(data, 0, SHA256_CBLOCK);
+                j += 64;
+            }
+            data-&gt;u[SHA_LBLOCK - 1] = bitlen;
+            sha256_block_data_order(&amp;sctx-&gt;md, data, 1);
+            mask = 0 - ((j - inp_len - 73) &gt;&gt; (sizeof(j) * 8 - 1));
+            pmac-&gt;u[0] |= sctx-&gt;md.h[0] &amp; mask;
+            pmac-&gt;u[1] |= sctx-&gt;md.h[1] &amp; mask;
+            pmac-&gt;u[2] |= sctx-&gt;md.h[2] &amp; mask;
+            pmac-&gt;u[3] |= sctx-&gt;md.h[3] &amp; mask;
+            pmac-&gt;u[4] |= sctx-&gt;md.h[4] &amp; mask;
+            pmac-&gt;u[5] |= sctx-&gt;md.h[5] &amp; mask;
+            pmac-&gt;u[6] |= sctx-&gt;md.h[6] &amp; mask;
+            pmac-&gt;u[7] |= sctx-&gt;md.h[7] &amp; mask;
+
+# ifdef BSWAP4
+            pmac-&gt;u[0] = BSWAP4(pmac-&gt;u[0]);
+            pmac-&gt;u[1] = BSWAP4(pmac-&gt;u[1]);
+            pmac-&gt;u[2] = BSWAP4(pmac-&gt;u[2]);
+            pmac-&gt;u[3] = BSWAP4(pmac-&gt;u[3]);
+            pmac-&gt;u[4] = BSWAP4(pmac-&gt;u[4]);
+            pmac-&gt;u[5] = BSWAP4(pmac-&gt;u[5]);
+            pmac-&gt;u[6] = BSWAP4(pmac-&gt;u[6]);
+            pmac-&gt;u[7] = BSWAP4(pmac-&gt;u[7]);
+# else
+            for (i = 0; i &lt; 8; i++) {
+                res = pmac-&gt;u[i];
+                pmac-&gt;c[4 * i + 0] = (unsigned char)(res &gt;&gt; 24);
+                pmac-&gt;c[4 * i + 1] = (unsigned char)(res &gt;&gt; 16);
+                pmac-&gt;c[4 * i + 2] = (unsigned char)(res &gt;&gt; 8);
+                pmac-&gt;c[4 * i + 3] = (unsigned char)res;
+            }
+# endif /* BSWAP */
+            len += SHA256_DIGEST_LENGTH;
+            sctx-&gt;md = sctx-&gt;tail;
+            sha256_update(&amp;sctx-&gt;md, pmac-&gt;c, SHA256_DIGEST_LENGTH);
+            SHA256_Final(pmac-&gt;c, &amp;sctx-&gt;md);
+
+            /* verify HMAC */
+            out += inp_len;
+            len -= inp_len;
+            /* code containing lucky-13 fix */
+            {
+                unsigned char *p =
+                    out + len - 1 - maxpad - SHA256_DIGEST_LENGTH;
+                size_t off = out - p;
+                unsigned int c, cmask;
+
+                maxpad += SHA256_DIGEST_LENGTH;
+                for (res = 0, i = 0, j = 0; j &lt; maxpad; j++) {
+                    c = p[j];
+                    cmask =
+                        ((int)(j - off - SHA256_DIGEST_LENGTH)) &gt;&gt;
+                        (sizeof(int) * 8 - 1);
+                    res |= (c ^ pad) &amp; ~cmask; /* ... and padding */
+                    cmask &amp;= ((int)(off - 1 - j)) &gt;&gt; (sizeof(int) * 8 - 1);
+                    res |= (c ^ pmac-&gt;c[i]) &amp; cmask;
+                    i += 1 &amp; cmask;
+                }
+                maxpad -= SHA256_DIGEST_LENGTH;
+
+                res = 0 - ((0 - res) &gt;&gt; (sizeof(res) * 8 - 1));
+                ret &amp;= (int)~res;
+            }
+            return ret;
+        } else {
+            sha256_update(&amp;sctx-&gt;md, out, len);
+        }
+    }
+
+    return 1;
+}
+
+/* EVP_CTRL_AEAD_SET_MAC_KEY */
+static void aesni_cbc_hmac_sha256_set_mac_key(void *vctx,
+                                              const unsigned char *mackey,
+                                              size_t len)
+{
+    PROV_AES_HMAC_SHA256_CTX *ctx = (PROV_AES_HMAC_SHA256_CTX *)vctx;
+    unsigned int i;
+    unsigned char hmac_key[64];
+
+    memset(hmac_key, 0, sizeof(hmac_key));
+
+    if (len &gt; sizeof(hmac_key)) {
+        SHA256_Init(&amp;ctx-&gt;head);
+        sha256_update(&amp;ctx-&gt;head, mackey, len);
+        SHA256_Final(hmac_key, &amp;ctx-&gt;head);
+    } else {
+        memcpy(hmac_key, mackey, len);
+    }
+
+    for (i = 0; i &lt; sizeof(hmac_key); i++)
+        hmac_key[i] ^= 0x36; /* ipad */
+    SHA256_Init(&amp;ctx-&gt;head);
+    sha256_update(&amp;ctx-&gt;head, hmac_key, sizeof(hmac_key));
+
+    for (i = 0; i &lt; sizeof(hmac_key); i++)
+        hmac_key[i] ^= 0x36 ^ 0x5c; /* opad */
+    SHA256_Init(&amp;ctx-&gt;tail);
+    sha256_update(&amp;ctx-&gt;tail, hmac_key, sizeof(hmac_key));
+
+    OPENSSL_cleanse(hmac_key, sizeof(hmac_key));
+}
+
+/* EVP_CTRL_AEAD_TLS1_AAD */
+static int aesni_cbc_hmac_sha256_set_tls1_aad(void *vctx,
+                                              unsigned char *aad_rec, int aad_len)
+{
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_AES_HMAC_SHA256_CTX *sctx = (PROV_AES_HMAC_SHA256_CTX *)vctx;
+    unsigned char *p = aad_rec;
+    unsigned int len;
+
+    if (aad_len != EVP_AEAD_TLS1_AAD_LEN)
+        return -1;
+
+    len = p[aad_len - 2] &lt;&lt; 8 | p[aad_len - 1];
+
+    if (ctx-&gt;base.enc) {
+        ctx-&gt;payload_length = len;
+        if ((ctx-&gt;aux.tls_ver =
+             p[aad_len - 4] &lt;&lt; 8 | p[aad_len - 3]) &gt;= TLS1_1_VERSION) {
+            if (len &lt; AES_BLOCK_SIZE)
+                return 0;
+            len -= AES_BLOCK_SIZE;
+            p[aad_len] = len &gt;&gt; 8;
+            p[aad_len - 1] = len;
+        }
+        sctx-&gt;md = sctx-&gt;head;
+        sha256_update(&amp;sctx-&gt;md, p, aad_len);
+        ctx-&gt;tls_aad_pad = (int)(((len + SHA256_DIGEST_LENGTH +
+                                   AES_BLOCK_SIZE) &amp; -AES_BLOCK_SIZE)
+                                   - len);
+        return 1;
+    } else {
+        memcpy(ctx-&gt;aux.tls_aad, p, aad_len);
+        ctx-&gt;payload_length = aad_len;
+        ctx-&gt;tls_aad_pad = SHA256_DIGEST_LENGTH;
+        return 1;
+    }
+}
+
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+/* EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE */
+static int aesni_cbc_hmac_sha256_tls1_multiblock_max_bufsize(
+    void *vctx)
+{
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+
+    OPENSSL_assert(ctx-&gt;multiblock_max_send_fragment != 0);
+    return (int)(5 + 16
+                 + (((int)ctx-&gt;multiblock_max_send_fragment + 32 + 16) &amp; -16));
+}
+
+/* EVP_CTRL_TLS1_1_MULTIBLOCK_AAD */
+static int aesni_cbc_hmac_sha256_tls1_multiblock_aad(
+    void *vctx, EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *param)
+{
+    PROV_AES_HMAC_SHA_CTX *ctx = (PROV_AES_HMAC_SHA_CTX *)vctx;
+    PROV_AES_HMAC_SHA256_CTX *sctx = (PROV_AES_HMAC_SHA256_CTX *)vctx;
+    unsigned int n4x = 1, x4;
+    unsigned int frag, last, packlen, inp_len;
+
+    inp_len = param-&gt;inp[11] &lt;&lt; 8 | param-&gt;inp[12];
+
+    if (ctx-&gt;base.enc) {
+        if ((param-&gt;inp[9] &lt;&lt; 8 | param-&gt;inp[10]) &lt; TLS1_1_VERSION)
+            return -1;
+
+        if (inp_len) {
+            if (inp_len &lt; 4096)
+                return 0; /* too short */
+
+            if (inp_len &gt;= 8192 &amp;&amp; OPENSSL_ia32cap_P[2] &amp; (1 &lt;&lt; 5))
+                n4x = 2; /* AVX2 */
+        } else if ((n4x = param-&gt;interleave / 4) &amp;&amp; n4x &lt;= 2)
+            inp_len = param-&gt;len;
+        else
+            return -1;
+
+        sctx-&gt;md = sctx-&gt;head;
+        sha256_update(&amp;sctx-&gt;md, param-&gt;inp, 13);
+
+        x4 = 4 * n4x;
+        n4x += 1;
+
+        frag = inp_len &gt;&gt; n4x;
+        last = inp_len + frag - (frag &lt;&lt; n4x);
+        if (last &gt; frag &amp;&amp; ((last + 13 + 9) % 64 &lt; (x4 - 1))) {
+            frag++;
+            last -= x4 - 1;
+        }
+
+        packlen = 5 + 16 + ((frag + 32 + 16) &amp; -16);
+        packlen = (packlen &lt;&lt; n4x) - packlen;
+        packlen += 5 + 16 + ((last + 32 + 16) &amp; -16);
+
+        param-&gt;interleave = x4;
+        /* The returned values used by get need to be stored */
+        ctx-&gt;multiblock_interleave = x4;
+        ctx-&gt;multiblock_aad_packlen = packlen;
+        return 1;
+    }
+    return -1;      /* not yet */
+}
+
+/* EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT */
+static int aesni_cbc_hmac_sha256_tls1_multiblock_encrypt(
+    void *ctx, EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *param)
+{
+    return (int)tls1_multi_block_encrypt(ctx, param-&gt;out,
+                                         param-&gt;inp, param-&gt;len,
+                                         param-&gt;interleave / 4);
+}
+#endif
+
+static const PROV_CIPHER_HW_AES_HMAC_SHA cipher_hw_aes_hmac_sha256 = {
+    {
+      aesni_cbc_hmac_sha256_init_key,
+      aesni_cbc_hmac_sha256_cipher
+    },
+    aesni_cbc_hmac_sha256_set_mac_key,
+    aesni_cbc_hmac_sha256_set_tls1_aad,
+# if !defined(OPENSSL_NO_MULTIBLOCK)
+    aesni_cbc_hmac_sha256_tls1_multiblock_max_bufsize,
+    aesni_cbc_hmac_sha256_tls1_multiblock_aad,
+    aesni_cbc_hmac_sha256_tls1_multiblock_encrypt
+# endif
+};
+
+const PROV_CIPHER_HW_AES_HMAC_SHA *PROV_CIPHER_HW_aes_cbc_hmac_sha256(void)
+{
+    return &amp;cipher_hw_aes_hmac_sha256;
+}
+
+#endif /* AES_CBC_HMAC_SHA_CAPABLE */
diff --git a/providers/implementations/include/prov/implementations.h b/providers/implementations/include/prov/implementations.h
index 75c20a096e..ed44d68a5a 100644
--- a/providers/implementations/include/prov/implementations.h
+++ b/providers/implementations/include/prov/implementations.h
@@ -75,6 +75,10 @@ extern const OSSL_DISPATCH aes128wrap_functions[];
 extern const OSSL_DISPATCH aes256wrappad_functions[];
 extern const OSSL_DISPATCH aes192wrappad_functions[];
 extern const OSSL_DISPATCH aes128wrappad_functions[];
+extern const OSSL_DISPATCH aes256cbc_hmac_sha1_functions[];
+extern const OSSL_DISPATCH aes128cbc_hmac_sha1_functions[];
+extern const OSSL_DISPATCH aes256cbc_hmac_sha256_functions[];
+extern const OSSL_DISPATCH aes128cbc_hmac_sha256_functions[];
 
 #ifndef OPENSSL_NO_ARIA
 extern const OSSL_DISPATCH aria256gcm_functions[];
diff --git a/test/sslapitest.c b/test/sslapitest.c
index 46e490a417..4993f16f4c 100644
--- a/test/sslapitest.c
+++ b/test/sslapitest.c
@@ -6820,6 +6820,103 @@ static int test_ca_names(int tst)
     return testresult;
 }
 
+#ifndef OPENSSL_NO_TLS1_2
+static const char *multiblock_cipherlist_data[]=
+{
+    &quot;AES128-SHA&quot;,
+    &quot;AES128-SHA256&quot;,
+    &quot;AES256-SHA&quot;,
+    &quot;AES256-SHA256&quot;,
+};
+
+/* Reduce the fragment size - so the multiblock test buffer can be small */
+# define MULTIBLOCK_FRAGSIZE 512
+
+static int test_multiblock_write(int test_index)
+{
+    static const char *fetchable_ciphers[]=
+    {
+        &quot;AES-128-CBC-HMAC-SHA1&quot;,
+        &quot;AES-128-CBC-HMAC-SHA256&quot;,
+        &quot;AES-256-CBC-HMAC-SHA1&quot;,
+        &quot;AES-256-CBC-HMAC-SHA256&quot;
+    };
+    const char *cipherlist = multiblock_cipherlist_data[test_index];
+    const SSL_METHOD *smeth = TLS_server_method();
+    const SSL_METHOD *cmeth = TLS_client_method();
+    int min_version = TLS1_VERSION;
+    int max_version = TLS1_2_VERSION; /* Don't select TLS1_3 */
+    SSL_CTX *cctx = NULL, *sctx = NULL;
+    SSL *clientssl = NULL, *serverssl = NULL;
+    int testresult = 0;
+
+    /*
+     * Choose a buffer large enough to perform a multi-block operation
+     * i.e: write_len &gt;= 4 * frag_size
+     * 9 * is chosen so that multiple multiblocks are used + some leftover.
+     */
+    unsigned char msg[MULTIBLOCK_FRAGSIZE * 9];
+    unsigned char buf[sizeof(msg)], *p = buf;
+    size_t readbytes, written, len;
+    EVP_CIPHER *ciph = NULL;
+
+    /*
+     * Check if the cipher exists before attempting to use it since it only has
+     * a hardware specific implementation.
+     */
+    ciph = EVP_CIPHER_fetch(NULL, fetchable_ciphers[test_index], &quot;&quot;);
+    if (ciph == NULL) {
+        TEST_skip(&quot;Multiblock cipher is not available for %s&quot;, cipherlist);
+        return 1;
+    }
+    EVP_CIPHER_free(ciph);
+
+    /* Set up a buffer with some data that will be sent to the client */
+    RAND_bytes(msg, sizeof(msg));
+
+    if (!TEST_true(create_ssl_ctx_pair(smeth, cmeth, min_version, max_version,
+                                       &amp;sctx, &amp;cctx, cert, privkey)))
+        goto end;
+
+    if (!TEST_true(SSL_CTX_set_max_send_fragment(sctx, MULTIBLOCK_FRAGSIZE)))
+        goto end;
+
+    if (!TEST_true(create_ssl_objects(sctx, cctx, &amp;serverssl, &amp;clientssl,
+                                      NULL, NULL)))
+            goto end;
+
+    /* settings to force it to use AES-CBC-HMAC_SHA */
+    SSL_set_options(serverssl, SSL_OP_NO_ENCRYPT_THEN_MAC);
+    if (!TEST_true(SSL_CTX_set_cipher_list(cctx, cipherlist)))
+       goto end;
+
+    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
+        goto end;
+
+    if (!TEST_true(SSL_write_ex(serverssl, msg, sizeof(msg), &amp;written))
+        || !TEST_size_t_eq(written, sizeof(msg)))
+        goto end;
+
+    len = written;
+    while (len &gt; 0) {
+        if (!TEST_true(SSL_read_ex(clientssl, p, MULTIBLOCK_FRAGSIZE, &amp;readbytes)))
+            goto end;
+        p += readbytes;
+        len -= readbytes;
+    }
+    if (!TEST_mem_eq(msg, sizeof(msg), buf, sizeof(buf)))
+        goto end;
+
+    testresult = 1;
+end:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+
+    return testresult;
+}
+#endif /* OPENSSL_NO_TLS1_2 */
 
 OPT_TEST_DECLARE_USAGE(&quot;certfile privkeyfile srpvfile tmpfile\n&quot;)
 
@@ -6968,6 +7065,9 @@ int setup_tests(void)
     ADD_ALL_TESTS(test_cert_cb, 6);
     ADD_ALL_TESTS(test_client_cert_cb, 2);
     ADD_ALL_TESTS(test_ca_names, 3);
+#ifndef OPENSSL_NO_TLS1_2
+    ADD_ALL_TESTS(test_multiblock_write, OSSL_NELEM(multiblock_cipherlist_data));
+#endif
     return 1;
 }
 
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="026930.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="026921.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#26920">[ date ]</a>
              <a href="thread.html#26920">[ thread ]</a>
              <a href="subject.html#26920">[ subject ]</a>
              <a href="author.html#26920">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
