<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-January/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1580294119.989432.10084.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027273.html">
   <LINK REL="Next"  HREF="027278.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>shane.lontis at oracle.com</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1580294119.989432.10084.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">shane.lontis at oracle.com
       </A><BR>
    <I>Wed Jan 29 10:35:19 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="027273.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="027278.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27275">[ date ]</a>
              <a href="thread.html#27275">[ thread ]</a>
              <a href="subject.html#27275">[ subject ]</a>
              <a href="author.html#27275">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  12603de634fe628488066d1f3f2c720ca20d6df9 (commit)
      from  a76ce2862bc6ae2cf8a749c8747d371041fc42d1 (commit)


- Log -----------------------------------------------------------------
commit 12603de634fe628488066d1f3f2c720ca20d6df9
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Wed Jan 29 20:32:32 2020 +1000

    Add RSA key validation to default provider
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10780">https://github.com/openssl/openssl/pull/10780</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/evp/build.info                         |   3 +-
 crypto/evp/evp_local.h                        |   4 +
 crypto/evp/keymgmt_lib.c                      |  23 ++++
 crypto/evp/keymgmt_meth.c                     |  24 ++++
 crypto/evp/pmeth_check.c                      | 158 ++++++++++++++++++++++++++
 crypto/evp/pmeth_gn.c                         |  71 ------------
 crypto/evp/pmeth_lib.c                        |   1 -
 crypto/rsa/rsa_chk.c                          |  90 +++++++++------
 crypto/rsa/rsa_sp800_56b_check.c              |   8 +-
 doc/man3/EVP_PKEY_check.pod                   |  73 ++++++++++++
 doc/man3/EVP_PKEY_keygen.pod                  |  26 +----
 doc/man7/provider-keymgmt.pod                 |  26 ++++-
 include/crypto/evp.h                          |   6 +
 include/crypto/rsa.h                          |   5 +
 include/openssl/core_numbers.h                |  14 ++-
 include/openssl/evp.h                         |   2 +
 providers/implementations/keymgmt/rsa_kmgmt.c |  30 +++++
 test/evp_pkey_provided_test.c                 |  12 +-
 util/libcrypto.num                            |   2 +
 19 files changed, 439 insertions(+), 139 deletions(-)
 create mode 100644 crypto/evp/pmeth_check.c
 create mode 100644 doc/man3/EVP_PKEY_check.pod

diff --git a/crypto/evp/build.info b/crypto/evp/build.info
index d3ebac9f4e..7972706f86 100644
--- a/crypto/evp/build.info
+++ b/crypto/evp/build.info
@@ -1,7 +1,8 @@
 LIBS=../../libcrypto
 $COMMON=digest.c evp_enc.c evp_lib.c evp_fetch.c cmeth_lib.c evp_utils.c \
         mac_lib.c mac_meth.c keymgmt_meth.c keymgmt_lib.c kdf_lib.c kdf_meth.c \
-        m_sigver.c pmeth_lib.c signature.c p_lib.c pmeth_gn.c exchange.c
+        m_sigver.c pmeth_lib.c signature.c p_lib.c pmeth_gn.c exchange.c \
+        pmeth_check.c
 
 SOURCE[../../libcrypto]=$COMMON\
         encode.c evp_key.c evp_cnf.c \
diff --git a/crypto/evp/evp_local.h b/crypto/evp/evp_local.h
index 894fdf996e..5f34aaeb23 100644
--- a/crypto/evp/evp_local.h
+++ b/crypto/evp/evp_local.h
@@ -82,6 +82,7 @@ struct evp_keymgmt_st {
     OSSL_OP_keymgmt_exportdomparam_types_fn *exportdomparam_types;
     OSSL_OP_keymgmt_get_domparam_params_fn *get_domparam_params;
     OSSL_OP_keymgmt_gettable_domparam_params_fn *gettable_domparam_params;
+    OSSL_OP_keymgmt_validate_domparams_fn *validatedomparams;
 
     /* Key routines */
     OSSL_OP_keymgmt_importkey_fn *importkey;
@@ -95,6 +96,9 @@ struct evp_keymgmt_st {
     OSSL_OP_keymgmt_gettable_key_params_fn *gettable_key_params;
 
     OSSL_OP_keymgmt_query_operation_name_fn *query_operation_name;
+    OSSL_OP_keymgmt_validate_public_fn *validatepublic;
+    OSSL_OP_keymgmt_validate_private_fn *validateprivate;
+    OSSL_OP_keymgmt_validate_pairwise_fn *validatepairwise;
 } /* EVP_KEYMGMT */ ;
 
 struct keymgmt_data_st {
diff --git a/crypto/evp/keymgmt_lib.c b/crypto/evp/keymgmt_lib.c
index 53610d3ef8..1f4b4a104f 100644
--- a/crypto/evp/keymgmt_lib.c
+++ b/crypto/evp/keymgmt_lib.c
@@ -342,3 +342,26 @@ const OSSL_PARAM *evp_keymgmt_gettable_key_params(const EVP_KEYMGMT *keymgmt)
         return NULL;
     return keymgmt-&gt;gettable_key_params();
 }
+
+int evp_keymgmt_validate_domparams(const EVP_KEYMGMT *keymgmt, void *provkey)
+{
+    /* if domainparams are not supported - then pass */
+    if (keymgmt-&gt;validatedomparams == NULL)
+        return 1;
+    return keymgmt-&gt;validatedomparams(provkey);
+}
+
+int evp_keymgmt_validate_public(const EVP_KEYMGMT *keymgmt, void *provkey)
+{
+    return keymgmt-&gt;validatepublic(provkey);
+}
+
+int evp_keymgmt_validate_private(const EVP_KEYMGMT *keymgmt, void *provkey)
+{
+    return keymgmt-&gt;validateprivate(provkey);
+}
+
+int evp_keymgmt_validate_pairwise(const EVP_KEYMGMT *keymgmt, void *provkey)
+{
+    return keymgmt-&gt;validatepairwise(provkey);
+}
diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
index ae1f10e6b3..e9e7f89744 100644
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -144,6 +144,30 @@ static void *keymgmt_from_dispatch(int name_id,
             keymgmt-&gt;query_operation_name =
                 OSSL_get_OP_keymgmt_query_operation_name(fns);
             break;
+        case OSSL_FUNC_KEYMGMT_VALIDATE_DOMPARAMS:
+            if (keymgmt-&gt;validatedomparams != NULL)
+                break;
+            keymgmt-&gt;validatedomparams =
+                OSSL_get_OP_keymgmt_validate_domparams(fns);
+            break;
+        case OSSL_FUNC_KEYMGMT_VALIDATE_PUBLIC:
+            if (keymgmt-&gt;validatepublic != NULL)
+                break;
+            keymgmt-&gt;validatepublic =
+                OSSL_get_OP_keymgmt_validate_public(fns);
+            break;
+        case OSSL_FUNC_KEYMGMT_VALIDATE_PRIVATE:
+            if (keymgmt-&gt;validateprivate != NULL)
+                break;
+            keymgmt-&gt;validateprivate =
+                OSSL_get_OP_keymgmt_validate_private(fns);
+            break;
+        case OSSL_FUNC_KEYMGMT_VALIDATE_PAIRWISE:
+            if (keymgmt-&gt;validatepairwise != NULL)
+                break;
+            keymgmt-&gt;validatepairwise =
+                OSSL_get_OP_keymgmt_validate_pairwise(fns);
+            break;
         }
     }
     /*
diff --git a/crypto/evp/pmeth_check.c b/crypto/evp/pmeth_check.c
new file mode 100644
index 0000000000..19f200a3ce
--- /dev/null
+++ b/crypto/evp/pmeth_check.c
@@ -0,0 +1,158 @@
+/*
+ * Copyright 2006-2020 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;internal/cryptlib.h&quot;
+#include &lt;openssl/objects.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &quot;crypto/bn.h&quot;
+#include &quot;crypto/asn1.h&quot;
+#include &quot;crypto/evp.h&quot;
+#include &quot;evp_local.h&quot;
+
+int EVP_PKEY_public_check(EVP_PKEY_CTX *ctx)
+{
+    EVP_PKEY *pkey = ctx-&gt;pkey;
+    void *key;
+    EVP_KEYMGMT *keymgmt;
+
+    if (pkey == NULL) {
+        EVPerr(EVP_F_EVP_PKEY_PUBLIC_CHECK, EVP_R_NO_KEY_SET);
+        return 0;
+    }
+
+    keymgmt = pkey-&gt;pkeys[0].keymgmt;
+    key = pkey-&gt;pkeys[0].provdata;
+
+    if (key != NULL &amp;&amp; keymgmt != NULL)
+        return evp_keymgmt_validate_public(keymgmt, key);
+
+    /* legacy */
+    /* call customized public key check function first */
+    if (ctx-&gt;pmeth-&gt;public_check != NULL)
+        return ctx-&gt;pmeth-&gt;public_check(pkey);
+
+    /* use default public key check function in ameth */
+    if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;pkey_public_check == NULL) {
+        EVPerr(EVP_F_EVP_PKEY_PUBLIC_CHECK,
+               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        return -2;
+    }
+
+    return pkey-&gt;ameth-&gt;pkey_public_check(pkey);
+}
+
+int EVP_PKEY_param_check(EVP_PKEY_CTX *ctx)
+{
+    EVP_PKEY *pkey = ctx-&gt;pkey;
+    void *key;
+    EVP_KEYMGMT *keymgmt;
+
+    if (pkey == NULL) {
+        EVPerr(EVP_F_EVP_PKEY_PARAM_CHECK, EVP_R_NO_KEY_SET);
+        return 0;
+    }
+
+    keymgmt = pkey-&gt;pkeys[0].keymgmt;
+    key = pkey-&gt;pkeys[0].provdata;
+
+    if (key != NULL &amp;&amp; keymgmt != NULL)
+        return evp_keymgmt_validate_domparams(keymgmt, key);
+
+    /* call customized param check function first */
+    if (ctx-&gt;pmeth-&gt;param_check != NULL)
+        return ctx-&gt;pmeth-&gt;param_check(pkey);
+
+    /* legacy */
+    /* use default param check function in ameth */
+    if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;pkey_param_check == NULL) {
+        EVPerr(EVP_F_EVP_PKEY_PARAM_CHECK,
+               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        return -2;
+    }
+
+    return pkey-&gt;ameth-&gt;pkey_param_check(pkey);
+}
+
+int EVP_PKEY_private_check(EVP_PKEY_CTX *ctx)
+{
+    EVP_PKEY *pkey = ctx-&gt;pkey;
+    void *key;
+    EVP_KEYMGMT *keymgmt;
+
+    if (pkey == NULL) {
+        EVPerr(0, EVP_R_NO_KEY_SET);
+        return 0;
+    }
+
+    keymgmt = pkey-&gt;pkeys[0].keymgmt;
+    key = pkey-&gt;pkeys[0].provdata;
+
+    if (key != NULL &amp;&amp; keymgmt != NULL)
+        return evp_keymgmt_validate_private(keymgmt, key);
+    /* not supported for legacy keys */
+    return -2;
+}
+
+int EVP_PKEY_pairwise_check(EVP_PKEY_CTX *ctx)
+{
+    EVP_PKEY *pkey = ctx-&gt;pkey;
+    void *key;
+    EVP_KEYMGMT *keymgmt;
+
+    if (pkey == NULL) {
+        EVPerr(0, EVP_R_NO_KEY_SET);
+        return 0;
+    }
+
+    keymgmt = pkey-&gt;pkeys[0].keymgmt;
+    key = pkey-&gt;pkeys[0].provdata;
+
+    if (key != NULL &amp;&amp; keymgmt != NULL)
+        return evp_keymgmt_validate_pairwise(keymgmt, key);
+    /* not supported for legacy keys */
+    return -2;
+}
+
+int EVP_PKEY_check(EVP_PKEY_CTX *ctx)
+{
+    EVP_PKEY *pkey = ctx-&gt;pkey;
+    void *key;
+    EVP_KEYMGMT *keymgmt;
+
+    if (pkey == NULL) {
+        EVPerr(EVP_F_EVP_PKEY_CHECK, EVP_R_NO_KEY_SET);
+        return 0;
+    }
+
+    keymgmt = pkey-&gt;pkeys[0].keymgmt;
+    key = pkey-&gt;pkeys[0].provdata;
+
+    if (key != NULL &amp;&amp; keymgmt != NULL) {
+        return evp_keymgmt_validate_domparams(keymgmt, key)
+               &amp;&amp; evp_keymgmt_validate_public(keymgmt, key)
+               &amp;&amp; evp_keymgmt_validate_private(keymgmt, key)
+               &amp;&amp; evp_keymgmt_validate_pairwise(keymgmt, key);
+    }
+    /* legacy */
+    /* call customized check function first */
+    if (ctx-&gt;pmeth-&gt;check != NULL)
+        return ctx-&gt;pmeth-&gt;check(pkey);
+
+    /* use default check function in ameth */
+    if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;pkey_check == NULL) {
+        EVPerr(EVP_F_EVP_PKEY_CHECK,
+               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+        return -2;
+    }
+
+    return pkey-&gt;ameth-&gt;pkey_check(pkey);
+}
+
diff --git a/crypto/evp/pmeth_gn.c b/crypto/evp/pmeth_gn.c
index 14c5fd4b99..a093337e62 100644
--- a/crypto/evp/pmeth_gn.c
+++ b/crypto/evp/pmeth_gn.c
@@ -171,75 +171,6 @@ EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,
     return mac_key;
 }
 
-int EVP_PKEY_check(EVP_PKEY_CTX *ctx)
-{
-    EVP_PKEY *pkey = ctx-&gt;pkey;
-
-    if (pkey == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_CHECK, EVP_R_NO_KEY_SET);
-        return 0;
-    }
-
-    /* call customized check function first */
-    if (ctx-&gt;pmeth-&gt;check != NULL)
-        return ctx-&gt;pmeth-&gt;check(pkey);
-
-    /* use default check function in ameth */
-    if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;pkey_check == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_CHECK,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
-        return -2;
-    }
-
-    return pkey-&gt;ameth-&gt;pkey_check(pkey);
-}
-
-int EVP_PKEY_public_check(EVP_PKEY_CTX *ctx)
-{
-    EVP_PKEY *pkey = ctx-&gt;pkey;
-
-    if (pkey == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_PUBLIC_CHECK, EVP_R_NO_KEY_SET);
-        return 0;
-    }
-
-    /* call customized public key check function first */
-    if (ctx-&gt;pmeth-&gt;public_check != NULL)
-        return ctx-&gt;pmeth-&gt;public_check(pkey);
-
-    /* use default public key check function in ameth */
-    if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;pkey_public_check == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_PUBLIC_CHECK,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
-        return -2;
-    }
-
-    return pkey-&gt;ameth-&gt;pkey_public_check(pkey);
-}
-
-int EVP_PKEY_param_check(EVP_PKEY_CTX *ctx)
-{
-    EVP_PKEY *pkey = ctx-&gt;pkey;
-
-    if (pkey == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_PARAM_CHECK, EVP_R_NO_KEY_SET);
-        return 0;
-    }
-
-    /* call customized param check function first */
-    if (ctx-&gt;pmeth-&gt;param_check != NULL)
-        return ctx-&gt;pmeth-&gt;param_check(pkey);
-
-    /* use default param check function in ameth */
-    if (pkey-&gt;ameth == NULL || pkey-&gt;ameth-&gt;pkey_param_check == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_PARAM_CHECK,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
-        return -2;
-    }
-
-    return pkey-&gt;ameth-&gt;pkey_param_check(pkey);
-}
-
 #endif /* FIPS_MODE */
 
 /*- All methods below can also be used in FIPS_MODE */
@@ -327,5 +258,3 @@ const OSSL_PARAM *EVP_PKEY_key_fromdata_settable(EVP_PKEY_CTX *ctx)
         return evp_keymgmt_importdomparam_types(ctx-&gt;keymgmt);
     return NULL;
 }
-
-
diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index 03d6ab4da4..dda9358c4e 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -379,7 +379,6 @@ EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e)
     return int_ctx_new(NULL, NULL, e, NULL, NULL, id);
 }
 
-
 EVP_PKEY_CTX *EVP_PKEY_CTX_dup(const EVP_PKEY_CTX *pctx)
 {
     EVP_PKEY_CTX *rctx;
diff --git a/crypto/rsa/rsa_chk.c b/crypto/rsa/rsa_chk.c
index 9d8049132b..6ba0010c77 100644
--- a/crypto/rsa/rsa_chk.c
+++ b/crypto/rsa/rsa_chk.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1999-2017 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1999-2020 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -9,26 +9,12 @@
 
 #include &lt;openssl/bn.h&gt;
 #include &lt;openssl/err.h&gt;
+#include &quot;crypto/rsa.h&quot;
 #include &quot;rsa_local.h&quot;
 
-int RSA_check_key(const RSA *key)
+#ifndef FIPS_MODE
+static int rsa_validate_keypair_multiprime(const RSA *key, BN_GENCB *cb)
 {
-    return RSA_check_key_ex(key, NULL);
-}
-
-/*
- * NOTE: Key validation requires separate checks to be able to be accessed
- *  individually. These should be visible from the PKEY API..
- *  See rsa_sp800_56b_check_public, rsa_sp800_56b_check_private and
- *      rsa_sp800_56b_check_keypair.
- */
-int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
-{
-#ifdef FIPS_MODE
-    return rsa_sp800_56b_check_public(key)
-               &amp;&amp; rsa_sp800_56b_check_private(key)
-               &amp;&amp; rsa_sp800_56b_check_keypair(key, NULL, -1, RSA_bits(key));
-#else
     BIGNUM *i, *j, *k, *l, *m;
     BN_CTX *ctx;
     int ret = 1, ex_primes = 0, idx;
@@ -36,7 +22,7 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
 
     if (key-&gt;p == NULL || key-&gt;q == NULL || key-&gt;n == NULL
             || key-&gt;e == NULL || key-&gt;d == NULL) {
-        RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_VALUE_MISSING);
+        RSAerr(0, RSA_R_VALUE_MISSING);
         return 0;
     }
 
@@ -45,7 +31,7 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
         ex_primes = sk_RSA_PRIME_INFO_num(key-&gt;prime_infos);
         if (ex_primes &lt;= 0
                 || (ex_primes + 2) &gt; rsa_multip_cap(BN_num_bits(key-&gt;n))) {
-            RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_INVALID_MULTI_PRIME_KEY);
+            RSAerr(0, RSA_R_INVALID_MULTI_PRIME_KEY);
             return 0;
         }
     }
@@ -59,29 +45,29 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
     if (i == NULL || j == NULL || k == NULL || l == NULL
             || m == NULL || ctx == NULL) {
         ret = -1;
-        RSAerr(RSA_F_RSA_CHECK_KEY_EX, ERR_R_MALLOC_FAILURE);
+        RSAerr(0, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     if (BN_is_one(key-&gt;e)) {
         ret = 0;
-        RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_BAD_E_VALUE);
+        RSAerr(0, RSA_R_BAD_E_VALUE);
     }
     if (!BN_is_odd(key-&gt;e)) {
         ret = 0;
-        RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_BAD_E_VALUE);
+        RSAerr(0, RSA_R_BAD_E_VALUE);
     }
 
     /* p prime? */
     if (BN_check_prime(key-&gt;p, NULL, cb) != 1) {
         ret = 0;
-        RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_P_NOT_PRIME);
+        RSAerr(0, RSA_R_P_NOT_PRIME);
     }
 
     /* q prime? */
     if (BN_check_prime(key-&gt;q, NULL, cb) != 1) {
         ret = 0;
-        RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_Q_NOT_PRIME);
+        RSAerr(0, RSA_R_Q_NOT_PRIME);
     }
 
     /* r_i prime? */
@@ -89,7 +75,7 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
         pinfo = sk_RSA_PRIME_INFO_value(key-&gt;prime_infos, idx);
         if (BN_check_prime(pinfo-&gt;r, NULL, cb) != 1) {
             ret = 0;
-            RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_MP_R_NOT_PRIME);
+            RSAerr(0, RSA_R_MP_R_NOT_PRIME);
         }
     }
 
@@ -108,10 +94,9 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
     if (BN_cmp(i, key-&gt;n) != 0) {
         ret = 0;
         if (ex_primes)
-            RSAerr(RSA_F_RSA_CHECK_KEY_EX,
-                   RSA_R_N_DOES_NOT_EQUAL_PRODUCT_OF_PRIMES);
+            RSAerr(0, RSA_R_N_DOES_NOT_EQUAL_PRODUCT_OF_PRIMES);
         else
-            RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_N_DOES_NOT_EQUAL_P_Q);
+            RSAerr(0, RSA_R_N_DOES_NOT_EQUAL_P_Q);
     }
 
     /* d*e = 1  mod \lambda(n)? */
@@ -159,7 +144,7 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
 
     if (!BN_is_one(i)) {
         ret = 0;
-        RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_D_E_NOT_CONGRUENT_TO_1);
+        RSAerr(0, RSA_R_D_E_NOT_CONGRUENT_TO_1);
     }
 
     if (key-&gt;dmp1 != NULL &amp;&amp; key-&gt;dmq1 != NULL &amp;&amp; key-&gt;iqmp != NULL) {
@@ -174,7 +159,7 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
         }
         if (BN_cmp(j, key-&gt;dmp1) != 0) {
             ret = 0;
-            RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_DMP1_NOT_CONGRUENT_TO_D);
+            RSAerr(0, RSA_R_DMP1_NOT_CONGRUENT_TO_D);
         }
 
         /* dmq1 = d mod (q-1)? */
@@ -188,7 +173,7 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
         }
         if (BN_cmp(j, key-&gt;dmq1) != 0) {
             ret = 0;
-            RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_DMQ1_NOT_CONGRUENT_TO_D);
+            RSAerr(0, RSA_R_DMQ1_NOT_CONGRUENT_TO_D);
         }
 
         /* iqmp = q^-1 mod p? */
@@ -198,7 +183,7 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
         }
         if (BN_cmp(i, key-&gt;iqmp) != 0) {
             ret = 0;
-            RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_IQMP_NOT_INVERSE_OF_Q);
+            RSAerr(0, RSA_R_IQMP_NOT_INVERSE_OF_Q);
         }
     }
 
@@ -215,7 +200,7 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
         }
         if (BN_cmp(j, pinfo-&gt;d) != 0) {
             ret = 0;
-            RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_MP_EXPONENT_NOT_CONGRUENT_TO_D);
+            RSAerr(0, RSA_R_MP_EXPONENT_NOT_CONGRUENT_TO_D);
         }
         /* t_i = R_i ^ -1 mod r_i ? */
         if (!BN_mod_inverse(i, pinfo-&gt;pp, pinfo-&gt;r, ctx)) {
@@ -224,7 +209,7 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
         }
         if (BN_cmp(i, pinfo-&gt;t) != 0) {
             ret = 0;
-            RSAerr(RSA_F_RSA_CHECK_KEY_EX, RSA_R_MP_COEFFICIENT_NOT_INVERSE_OF_R);
+            RSAerr(0, RSA_R_MP_COEFFICIENT_NOT_INVERSE_OF_R);
         }
     }
 
@@ -236,5 +221,40 @@ int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
     BN_free(m);
     BN_CTX_free(ctx);
     return ret;
+}
+#endif /* FIPS_MODE */
+
+int rsa_validate_public(const RSA *key)
+{
+    return rsa_sp800_56b_check_public(key);
+}
+
+int rsa_validate_private(const RSA *key)
+{
+    return rsa_sp800_56b_check_private(key);
+}
+
+int rsa_validate_pairwise(const RSA *key)
+{
+#ifdef FIPS_MODE
+    return rsa_sp800_56b_check_keypair(key, NULL, -1, RSA_bits(key));
+#else
+    return rsa_validate_keypair_multiprime(key, NULL);
+#endif
+}
+
+int RSA_check_key(const RSA *key)
+{
+    return RSA_check_key_ex(key, NULL);
+}
+
+int RSA_check_key_ex(const RSA *key, BN_GENCB *cb)
+{
+#ifdef FIPS_MODE
+    return rsa_validate_public(key)
+           &amp;&amp; rsa_validate_private(key)
+           &amp;&amp; rsa_validate_pairwise(key);
+#else
+    return rsa_validate_keypair_multiprime(key, cb);
 #endif /* FIPS_MODE */
 }
diff --git a/crypto/rsa/rsa_sp800_56b_check.c b/crypto/rsa/rsa_sp800_56b_check.c
index a580b1dc59..93d3103a18 100644
--- a/crypto/rsa/rsa_sp800_56b_check.c
+++ b/crypto/rsa/rsa_sp800_56b_check.c
@@ -237,13 +237,17 @@ int rsa_get_lcm(BN_CTX *ctx, const BIGNUM *p, const BIGNUM *q,
  */
 int rsa_sp800_56b_check_public(const RSA *rsa)
 {
-    int ret = 0, nbits, status;
+    int ret = 0, status;
+#ifdef FIPS_MODE
+    int nbits;
+#endif
     BN_CTX *ctx = NULL;
     BIGNUM *gcd = NULL;
 
     if (rsa-&gt;n == NULL || rsa-&gt;e == NULL)
         return 0;
 
+#ifdef FIPS_MODE
     /*
      * (Step a): modulus must be 2048 or 3072 (caveat from SP800-56Br1)
      * NOTE: changed to allow keys &gt;= 2048
@@ -253,11 +257,11 @@ int rsa_sp800_56b_check_public(const RSA *rsa)
         RSAerr(RSA_F_RSA_SP800_56B_CHECK_PUBLIC, RSA_R_INVALID_KEY_LENGTH);
         return 0;
     }
+#endif
     if (!BN_is_odd(rsa-&gt;n)) {
         RSAerr(RSA_F_RSA_SP800_56B_CHECK_PUBLIC, RSA_R_INVALID_MODULUS);
         return 0;
     }
-
     /* (Steps b-c): 2^16 &lt; e &lt; 2^256, n and e must be odd */
     if (!rsa_check_public_exponent(rsa-&gt;e)) {
         RSAerr(RSA_F_RSA_SP800_56B_CHECK_PUBLIC,
diff --git a/doc/man3/EVP_PKEY_check.pod b/doc/man3/EVP_PKEY_check.pod
new file mode 100644
index 0000000000..95b57a3fb8
--- /dev/null
+++ b/doc/man3/EVP_PKEY_check.pod
@@ -0,0 +1,73 @@
+=pod
+
+=head1 NAME
+
+EVP_PKEY_check, EVP_PKEY_param_check, EVP_PKEY_public_check,
+EVP_PKEY_private_check, EVP_PKEY_pairwise_check
+- key and parameter validation functions
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/evp.h&gt;
+
+ int EVP_PKEY_check(EVP_PKEY_CTX *ctx);
+ int EVP_PKEY_param_check(EVP_PKEY_CTX *ctx);
+ int EVP_PKEY_public_check(EVP_PKEY_CTX *ctx);
+ int EVP_PKEY_private_check(EVP_PKEY_CTX *ctx);
+ int EVP_PKEY_pairwise_check(EVP_PKEY_CTX *ctx);
+
+=head1 DESCRIPTION
+
+EVP_PKEY_param_check() validates the domain parameters component of the key
+given by B&lt;ctx&gt;.
+
+EVP_PKEY_public_check() validates the public component of the key given by B&lt;ctx&gt;.
+
+EVP_PKEY_private_check() validates the private component of the key given by B&lt;ctx&gt;.
+
+EVP_PKEY_pairwise_check() validates that the public and private components have
+the correct mathematical relationship to each other for the key given by B&lt;ctx&gt;.
+
+EVP_PKEY_check() validates all components of a key given by B&lt;ctx&gt;.
+
+=head1 NOTES
+
+Refer to SP800-56A and SP800-56B for rules relating to when these functions
+should be called during key establishment.
+It is not necessary to call these functions after locally calling an approved key
+generation method, but may be required for assurance purposes when receiving
+keys from a third party.
+
+In OpenSSL an EVP_PKEY structure containing a private key also contains the
+public key components and parameters (if any). An OpenSSL private key is
+equivalent to what some libraries call a &quot;key pair&quot;. A private key can be used
+in functions which require the use of a public key or parameters.
+
+=head1 RETURN VALUES
+
+All functions return 1 for success or others for failure.
+They return -2 if the operation is not supported for the specific algorithm.
+
+=head1 SEE ALSO
+
+L&lt;EVP_PKEY_CTX_new(3)&gt;,
+L&lt;EVP_PKEY_fromdata(3)&gt;,
+
+=head1 HISTORY
+
+EVP_PKEY_check(), EVP_PKEY_public_check() and EVP_PKEY_param_check() were added
+in OpenSSL 1.1.1.
+
+EVP_PKEY_private_check() and EVP_PKEY_pairwise_check() were added
+in OpenSSL 3.0.
+
+=head1 COPYRIGHT
+
+Copyright 2006-2020 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man3/EVP_PKEY_keygen.pod b/doc/man3/EVP_PKEY_keygen.pod
index 439d7d11fd..e326b82ffa 100644
--- a/doc/man3/EVP_PKEY_keygen.pod
+++ b/doc/man3/EVP_PKEY_keygen.pod
@@ -6,8 +6,7 @@ EVP_PKEY_keygen_init, EVP_PKEY_keygen, EVP_PKEY_paramgen_init,
 EVP_PKEY_paramgen, EVP_PKEY_CTX_set_cb, EVP_PKEY_CTX_get_cb,
 EVP_PKEY_CTX_get_keygen_info, EVP_PKEY_CTX_set_app_data,
 EVP_PKEY_CTX_get_app_data,
-EVP_PKEY_gen_cb, EVP_PKEY_check, EVP_PKEY_public_check,
-EVP_PKEY_param_check
+EVP_PKEY_gen_cb
 - key and parameter generation and check functions
 
 =head1 SYNOPSIS
@@ -29,10 +28,6 @@ EVP_PKEY_param_check
  void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);
  void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);
 
- int EVP_PKEY_check(EVP_PKEY_CTX *ctx);
- int EVP_PKEY_public_check(EVP_PKEY_CTX *ctx);
- int EVP_PKEY_param_check(EVP_PKEY_CTX *ctx);
-
 =head1 DESCRIPTION
 
 The EVP_PKEY_keygen_init() function initializes a public key algorithm
@@ -63,18 +58,6 @@ and retrieve an opaque pointer. This can be used to set some application
 defined value which can be retrieved in the callback: for example a handle
 which is used to update a &quot;progress dialog&quot;.
 
-EVP_PKEY_check() validates the key-pair given by B&lt;ctx&gt;. This function first tries
-to use customized key check method in B&lt;EVP_PKEY_METHOD&gt; if it's present; otherwise
-it calls a default one defined in B&lt;EVP_PKEY_ASN1_METHOD&gt;.
-
-EVP_PKEY_public_check() validates the public component of the key-pair given by B&lt;ctx&gt;.
-This function first tries to use customized key check method in B&lt;EVP_PKEY_METHOD&gt;
-if it's present; otherwise it calls a default one defined in B&lt;EVP_PKEY_ASN1_METHOD&gt;.
-
-EVP_PKEY_param_check() validates the algorithm parameters of the key-pair given by B&lt;ctx&gt;.
-This function first tries to use customized key check method in B&lt;EVP_PKEY_METHOD&gt;
-if it's present; otherwise it calls a default one defined in B&lt;EVP_PKEY_ASN1_METHOD&gt;.
-
 =head1 NOTES
 
 After the call to EVP_PKEY_keygen_init() or EVP_PKEY_paramgen_init() algorithm
@@ -106,10 +89,6 @@ EVP_PKEY_paramgen() return 1 for success and 0 or a negative value for failure.
 In particular a return value of -2 indicates the operation is not supported by
 the public key algorithm.
 
-EVP_PKEY_check(), EVP_PKEY_public_check() and EVP_PKEY_param_check() return 1
-for success or others for failure. They return -2 if the operation is not supported
-for the specific algorithm.
-
 =head1 EXAMPLES
 
 Generate a 2048 bit RSA key:
@@ -191,9 +170,6 @@ L&lt;EVP_PKEY_derive(3)&gt;
 
 These functions were added in OpenSSL 1.0.0.
 
-EVP_PKEY_check(), EVP_PKEY_public_check() and EVP_PKEY_param_check() were added
-in OpenSSL 1.1.1.
-
 =head1 COPYRIGHT
 
 Copyright 2006-2018 The OpenSSL Project Authors. All Rights Reserved.
diff --git a/doc/man7/provider-keymgmt.pod b/doc/man7/provider-keymgmt.pod
index adc1978a36..94427de89f 100644
--- a/doc/man7/provider-keymgmt.pod
+++ b/doc/man7/provider-keymgmt.pod
@@ -30,6 +30,9 @@ provider-keymgmt - The KEYMGMT library E&lt;lt&gt;-E&lt;gt&gt; provider functions
  int OP_keymgmt_get_domparam_params(void *domparams, OSSL_PARAM params[]);
  const OSSL_PARAM *OP_keymgmt_gettable_domparam_params(void);
 
+ /* Key domain parameter validation */
+ int OP_keymgmt_validate_domparams(void *key);
+
  /* Key creation and destruction */
  void *OP_keymgmt_importkey(void *provctx, const OSSL_PARAM params[]);
  void *OP_keymgmt_genkey(void *provctx,
@@ -48,6 +51,11 @@ provider-keymgmt - The KEYMGMT library E&lt;lt&gt;-E&lt;gt&gt; provider functions
  int OP_keymgmt_get_key_params(void *key, OSSL_PARAM params[]);
  const OSSL_PARAM *OP_keymgmt_gettable_key_params(void);
 
+ /* Key validation */
+ int OP_keymgmt_validate_public(void *key);
+ int OP_keymgmt_validate_private(void *key);
+ int OP_keymgmt_validate_pairwise(void *key);
+
  /* Discovery of supported operations */
  const char *OP_keymgmt_query_operation_name(int operation_id);
 
@@ -108,6 +116,11 @@ macros in L&lt;openssl-core_numbers.h(7)&gt;, as follows:
 
  OP_keymgmt_query_operation_name OSSL_FUNC_KEYMGMT_QUERY_OPERATION_NAME
 
+ OP_keymgmt_validate_domparams   OSSL_FUNC_KEYMGMT_VALIDATE_DOMPARAMS
+ OP_keymgmt_validate_public      OSSL_FUNC_KEYMGMT_VALIDATE_PUBLIC
+ OP_keymgmt_validate_private     OSSL_FUNC_KEYMGMT_VALIDATE_PRIVATE
+ OP_keymgmt_validate_pairwise    OSSL_FUNC_KEYMGMT_VALIDATE_PAIRWISE
+
 =head2 Domain Parameter Functions
 
 OP_keymgmt_importdomparams() should create a provider side structure
@@ -143,6 +156,9 @@ OP_keymgmt_gettable_domparam_params() should return a constant array
 of descriptor B&lt;OSSL_PARAM&gt;, for parameters that
 OP_keymgmt_get_domparam_params() can handle.
 
+OP_keymgmt_validate_domparams() should return a value of 1 if the
+domain parameters are valid, or 0 for invalid.
+
 =head2 Key functions
 
 OP_keymgmt_importkey() should create a provider side structure
@@ -185,6 +201,14 @@ OP_keymgmt_gettable_key_params() should return a constant array of
 descriptor B&lt;OSSL_PARAM&gt;, for parameters that
 OP_keymgmt_get_key_params() can handle.
 
+OP_keymgmt_validate_public() should return 1 if the public component of the
+key is valid, or 0 if invalid.
+OP_keymgmt_validate_private() should return 1 if the private component of the
+key is valid, or 0 if invalid.
+OP_keymgmt_validate_pairwise() should return 1 if the the pairwise consistency
+of the key is valid, or 0 if invalid.
+
+
 =head2 Supported operations
 
 OP_keymgmt_query_operation_name() should return the name of the
@@ -241,7 +265,7 @@ The KEYMGMT interface was introduced in OpenSSL 3.0.
 
 =head1 COPYRIGHT
 
-Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+Copyright 2019-2020 The OpenSSL Project Authors. All Rights Reserved.
 
 Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
 this file except in compliance with the License.  You can obtain a copy
diff --git a/include/crypto/evp.h b/include/crypto/evp.h
index b3d1f7d21c..5d6f70be78 100644
--- a/include/crypto/evp.h
+++ b/include/crypto/evp.h
@@ -637,6 +637,12 @@ int evp_keymgmt_get_key_params(const EVP_KEYMGMT *keymgmt,
                                void *provkey, OSSL_PARAM params[]);
 const OSSL_PARAM *evp_keymgmt_gettable_key_params(const EVP_KEYMGMT *keymgmt);
 
+int evp_keymgmt_validate_domparams(const EVP_KEYMGMT *keymgmt, void *provkey);
+int evp_keymgmt_validate_public(const EVP_KEYMGMT *keymgmt, void *provkey);
+int evp_keymgmt_validate_private(const EVP_KEYMGMT *keymgmt, void *provkey);
+int evp_keymgmt_validate_pairwise(const EVP_KEYMGMT *keymgmt, void *provkey);
+
+
 /* Pulling defines out of C source files */
 
 #define EVP_RC4_KEY_SIZE 16
diff --git a/include/crypto/rsa.h b/include/crypto/rsa.h
index 29256371f6..c3763d1e1f 100644
--- a/include/crypto/rsa.h
+++ b/include/crypto/rsa.h
@@ -22,4 +22,9 @@ int rsa_get0_all_params(RSA *r, STACK_OF(BIGNUM_const) *primes,
 int rsa_padding_check_PKCS1_type_2_TLS(unsigned char *to, size_t tlen,
                                        const unsigned char *from, size_t flen,
                                        int client_version, int alt_version);
+
+int rsa_validate_public(const RSA *key);
+int rsa_validate_private(const RSA *key);
+int rsa_validate_pairwise(const RSA *key);
+
 #endif
diff --git a/include/openssl/core_numbers.h b/include/openssl/core_numbers.h
index 3aa35a0ade..ecee173d09 100644
--- a/include/openssl/core_numbers.h
+++ b/include/openssl/core_numbers.h
@@ -416,8 +416,8 @@ OSSL_CORE_MAKE_FUNC(const OSSL_PARAM *, OP_keymgmt_importkey_types, (void))
 OSSL_CORE_MAKE_FUNC(const OSSL_PARAM *, OP_keymgmt_exportkey_types, (void))
 
 /* Key information */
-#define OSSL_FUNC_KEYMGMT_GET_KEY_PARAMS            27
-#define OSSL_FUNC_KEYMGMT_GETTABLE_KEY_PARAMS       28
+# define OSSL_FUNC_KEYMGMT_GET_KEY_PARAMS           27
+# define OSSL_FUNC_KEYMGMT_GETTABLE_KEY_PARAMS      28
 OSSL_CORE_MAKE_FUNC(int, OP_keymgmt_get_key_params,
                     (void *key, OSSL_PARAM params[]))
 OSSL_CORE_MAKE_FUNC(const OSSL_PARAM *, OP_keymgmt_gettable_key_params, (void))
@@ -427,6 +427,16 @@ OSSL_CORE_MAKE_FUNC(const OSSL_PARAM *, OP_keymgmt_gettable_key_params, (void))
 OSSL_CORE_MAKE_FUNC(const char *,OP_keymgmt_query_operation_name,
                     (int operation_id))
 
+/* Key validation */
+# define OSSL_FUNC_KEYMGMT_VALIDATE_DOMPARAMS       29
+# define OSSL_FUNC_KEYMGMT_VALIDATE_PUBLIC          30
+# define OSSL_FUNC_KEYMGMT_VALIDATE_PRIVATE         31
+# define OSSL_FUNC_KEYMGMT_VALIDATE_PAIRWISE        32
+OSSL_CORE_MAKE_FUNC(int, OP_keymgmt_validate_domparams, (void *key))
+OSSL_CORE_MAKE_FUNC(int, OP_keymgmt_validate_public, (void *key))
+OSSL_CORE_MAKE_FUNC(int, OP_keymgmt_validate_private, (void *key))
+OSSL_CORE_MAKE_FUNC(int, OP_keymgmt_validate_pairwise, (void *key))
+
 /* Key Exchange */
 
 # define OSSL_FUNC_KEYEXCH_NEWCTX                      1
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 181c588f0f..7aa56b3e93 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -1590,6 +1590,8 @@ int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
 int EVP_PKEY_check(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_public_check(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_param_check(EVP_PKEY_CTX *ctx);
+int EVP_PKEY_private_check(EVP_PKEY_CTX *ctx);
+int EVP_PKEY_pairwise_check(EVP_PKEY_CTX *ctx);
 
 void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);
 EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);
diff --git a/providers/implementations/keymgmt/rsa_kmgmt.c b/providers/implementations/keymgmt/rsa_kmgmt.c
index 54e4c540d9..e205a412f3 100644
--- a/providers/implementations/keymgmt/rsa_kmgmt.c
+++ b/providers/implementations/keymgmt/rsa_kmgmt.c
@@ -23,6 +23,9 @@
 static OSSL_OP_keymgmt_importkey_fn rsa_importkey;
 static OSSL_OP_keymgmt_exportkey_fn rsa_exportkey;
 static OSSL_OP_keymgmt_get_key_params_fn rsa_get_key_params;
+static OSSL_OP_keymgmt_validate_public_fn rsa_validatekey_public;
+static OSSL_OP_keymgmt_validate_private_fn rsa_validatekey_private;
+static OSSL_OP_keymgmt_validate_pairwise_fn rsa_validatekey_pairwise;
 
 #define RSA_DEFAULT_MD &quot;SHA256&quot;
 
@@ -288,6 +291,27 @@ static int rsa_get_key_params(void *key, OSSL_PARAM params[])
     return 1;
 }
 
+static int rsa_validatekey_public(void *key)
+{
+    RSA *rsa = key;
+
+    return rsa_validate_public(rsa);
+}
+
+static int rsa_validatekey_private(void *key)
+{
+    RSA *rsa = key;
+
+    return rsa_validate_private(rsa);
+}
+
+static int rsa_validatekey_pairwise(void *key)
+{
+    RSA *rsa = key;
+
+    return rsa_validate_pairwise(rsa);
+}
+
 const OSSL_DISPATCH rsa_keymgmt_functions[] = {
     { OSSL_FUNC_KEYMGMT_IMPORTKEY, (void (*)(void))rsa_importkey },
     { OSSL_FUNC_KEYMGMT_IMPORTKEY_TYPES, (void (*)(void))rsa_importkey_types },
@@ -295,5 +319,11 @@ const OSSL_DISPATCH rsa_keymgmt_functions[] = {
     { OSSL_FUNC_KEYMGMT_EXPORTKEY_TYPES, (void (*)(void))rsa_exportkey_types },
     { OSSL_FUNC_KEYMGMT_FREEKEY, (void (*)(void))RSA_free },
     { OSSL_FUNC_KEYMGMT_GET_KEY_PARAMS,  (void (*) (void))rsa_get_key_params },
+    { OSSL_FUNC_KEYMGMT_VALIDATE_PUBLIC,
+          (void (*)(void))rsa_validatekey_public },
+    { OSSL_FUNC_KEYMGMT_VALIDATE_PRIVATE,
+          (void (*)(void))rsa_validatekey_private },
+    { OSSL_FUNC_KEYMGMT_VALIDATE_PAIRWISE,
+          (void (*)(void))rsa_validatekey_pairwise },
     { 0, NULL }
 };
diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c
index 8101585d95..a39fa0a724 100644
--- a/test/evp_pkey_provided_test.c
+++ b/test/evp_pkey_provided_test.c
@@ -92,7 +92,7 @@ err:
 static int test_fromdata_rsa(void)
 {
     int ret = 0;
-    EVP_PKEY_CTX *ctx = NULL;
+    EVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;
     EVP_PKEY *pk = NULL;
     /*
      * 32-bit RSA key, extracted from this command,
@@ -132,11 +132,21 @@ static int test_fromdata_rsa(void)
         || !TEST_int_eq(EVP_PKEY_size(pk), 4))
         goto err;
 
+    if (!TEST_ptr(key_ctx = EVP_PKEY_CTX_new_from_pkey(NULL, pk, &quot;&quot;)))
+        goto err;
+
+    if (!TEST_true(EVP_PKEY_check(key_ctx))
+        || !TEST_true(EVP_PKEY_public_check(key_ctx))
+        || !TEST_true(EVP_PKEY_private_check(key_ctx))
+        || !TEST_true(EVP_PKEY_pairwise_check(key_ctx)))
+        goto err;
+
     ret = test_print_key_using_pem(pk)
         | test_print_key_using_serializer(pk);
 
  err:
     EVP_PKEY_free(pk);
+    EVP_PKEY_CTX_free(key_ctx);
     EVP_PKEY_CTX_free(ctx);
 
     return ret;
diff --git a/util/libcrypto.num b/util/libcrypto.num
index d3b23f7b59..8bec3443b6 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4915,3 +4915,5 @@ RAND_bytes_ex                           ?	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_get_default_digest_name        ?	3_0_0	EXIST::FUNCTION:
 PKCS8_pkey_add1_attr                    ?	3_0_0	EXIST::FUNCTION:
 PKCS8_pkey_add1_attr_by_OBJ             ?	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_private_check                  ?	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_pairwise_check                 ?	3_0_0	EXIST::FUNCTION:
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027273.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="027278.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27275">[ date ]</a>
              <a href="thread.html#27275">[ thread ]</a>
              <a href="subject.html#27275">[ subject ]</a>
              <a href="author.html#27275">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
