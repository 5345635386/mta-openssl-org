<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-April/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1460585560.747620.20130.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006426.html">
   <LINK REL="Next"  HREF="006429.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1460585560.747620.20130.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Wed Apr 13 22:12:40 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006426.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="006429.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6428">[ date ]</a>
              <a href="thread.html#6428">[ thread ]</a>
              <a href="subject.html#6428">[ subject ]</a>
              <a href="author.html#6428">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  a50ad1daaa68c109ea1a14225a7aba8660526101 (commit)
       via  4f4d13b146b7d90b63f4cef1d7a0437ac9441332 (commit)
       via  05328815134a823f60f06b7764c6ba83c9b0b9d6 (commit)
       via  ecabf05e5bddb8afcffe02c9c93736ff6e9888f8 (commit)
       via  a39a87928d3687d39c9c18a6d84c3aeda104e8d8 (commit)
       via  d064e6ab52ac8e7b80b2a5d11b31bca583b769c7 (commit)
       via  5158c763f5af973b26dd1927956ac27b6171de5c (commit)
       via  7ec8de16fe23e207d3e1bbb95d53843dbc9c06c8 (commit)
      from  a48eaf711871b689b2287cf3c6c4038a5af636e9 (commit)


- Log -----------------------------------------------------------------
commit a50ad1daaa68c109ea1a14225a7aba8660526101
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 13 21:26:24 2016 +0100

    make update
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 4f4d13b146b7d90b63f4cef1d7a0437ac9441332
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 13 21:05:50 2016 +0100

    Add a CHANGES entry for removal of Configure options
    
    Document removal of no-aes, no-hmac, no-rsa, no-sha and no-md5.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 05328815134a823f60f06b7764c6ba83c9b0b9d6
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 13 21:01:28 2016 +0100

    Update INSTALL file based on feedback
    
    Update the config options documentation based on feedback.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit ecabf05e5bddb8afcffe02c9c93736ff6e9888f8
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 13 15:04:01 2016 +0100

    Update the INSTALL instructions with lots of options
    
    There were a lot of options missing from INSTALL. This adds descriptions
    for them.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit a39a87928d3687d39c9c18a6d84c3aeda104e8d8
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 13 11:31:51 2016 +0100

    Remove OPENSSL_NO_HMAC
    
    no-hmac is no longer an option so remove OPENSSL_NO_HMAC guards.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit d064e6ab52ac8e7b80b2a5d11b31bca583b769c7
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 13 11:31:00 2016 +0100

    Remove OPENSSL_NO_SHA guards
    
    no-sha is no longer an option so remove OPENSSL_NO_SHA guards.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 5158c763f5af973b26dd1927956ac27b6171de5c
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 13 11:28:45 2016 +0100

    Remove OPENSSL_NO_AES guards
    
    no-aes is no longer a Configure option and therefore the OPENSSL_NO_AES
    guards can be removed.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 7ec8de16fe23e207d3e1bbb95d53843dbc9c06c8
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 13 10:46:15 2016 +0100

    Remove no-aes, no-rsa, no-sha, no-md5 and no-hmac
    
    These algorithms are fundamental and extensively used. The &quot;no-&quot; options
    do not work either in 1.1.0 or in other released branches. Therefore the
    ability to disable them should be removed.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 CHANGES                            |   7 +-
 Configure                          |   5 -
 INSTALL                            | 263 ++++++++++++++++++++++----
 apps/cms.c                         |   9 -
 apps/openssl.c                     |   9 -
 apps/progs.h                       |  14 --
 apps/speed.c                       |  29 +--
 crypto/evp/c_allc.c                |  14 +-
 crypto/evp/e_aes.c                 | 366 ++++++++++++++++++-------------------
 crypto/evp/e_aes_cbc_hmac_sha1.c   | 187 ++++++++++---------
 crypto/evp/e_aes_cbc_hmac_sha256.c | 168 +++++++++--------
 crypto/evp/e_old.c                 |   8 +-
 crypto/evp/m_md5_sha1.c            |   2 +-
 engines/e_padlock.c                |  78 ++++----
 include/openssl/aes.h              |   2 -
 include/openssl/evp.h              |  20 +-
 ssl/ssl_init.c                     |   4 -
 util/libcrypto.num                 | 114 ++++++------
 18 files changed, 704 insertions(+), 595 deletions(-)

diff --git a/CHANGES b/CHANGES
index c0d85b3..70b846e 100644
--- a/CHANGES
+++ b/CHANGES
@@ -3,7 +3,12 @@
  _______________
 
  Changes between 1.0.2g and 1.1.0  [xx XXX xxxx]
- 
+
+  *) Remove the no-aes, no-hmac, no-rsa, no-sha and no-md5 Configure options.
+     All of these option have not worked for some while and are fundamental
+     algorithms.
+     [Matt Caswell]
+
   *) Make various cleanup routines no-ops and mark them as deprecated. Most
      global cleanup functions are no longer required because they are handled
      via auto-deinit (see OPENSSL_init_crypto and OPENSSL_init_ssl man pages).
diff --git a/Configure b/Configure
index 4e0e342..90d0846 100755
--- a/Configure
+++ b/Configure
@@ -243,7 +243,6 @@ my @dtls = qw(dtls1 dtls1_2);
 # For developers: keep it sorted alphabetically
 
 my @disablables = (
-    &quot;aes&quot;,
     &quot;afalgeng&quot;,
     &quot;asm&quot;,
     &quot;async&quot;,
@@ -280,13 +279,11 @@ my @disablables = (
     &quot;filenames&quot;,
     &quot;gost&quot;,
     &quot;heartbeats&quot;,
-    &quot;hmac&quot;,
     &quot;hw(-.+)?&quot;,
     &quot;idea&quot;,
     &quot;makedepend&quot;,
     &quot;md2&quot;,
     &quot;md4&quot;,
-    &quot;md5&quot;,
     &quot;mdc2&quot;,
     &quot;multiblock&quot;,
     &quot;nextprotoneg&quot;,
@@ -303,12 +300,10 @@ my @disablables = (
     &quot;rfc3779&quot;,
     &quot;ripemd&quot;,
     &quot;rmd160&quot;,
-    &quot;rsa&quot;,
     &quot;scrypt&quot;,
     &quot;sct&quot;,
     &quot;sctp&quot;,
     &quot;seed&quot;,
-    &quot;sha&quot;,
     &quot;shared&quot;,
     &quot;sock&quot;,
     &quot;srp&quot;,
diff --git a/INSTALL b/INSTALL
index 6d532d4..3e0496d 100644
--- a/INSTALL
+++ b/INSTALL
@@ -77,14 +77,16 @@
  --openssldir depend in what configuration is used and what Windows
  implementation OpenSSL is built on.  More notes on this in NOTES.WIN):
 
-  --prefix=DIR     The top of the installation directory tree.  Defaults are:
+  --prefix=DIR
+                   The top of the installation directory tree.  Defaults are:
 
                    Unix:           /usr/local
                    Windows:        C:\Program Files\OpenSSL
                                 or C:\Program Files (x86)\OpenSSL
                    OpenVMS:        SYS$COMMON:[OPENSSL-'version']
 
-  --openssldir=DIR Directory for OpenSSL configuration files, and also the
+  --openssldir=DIR
+                   Directory for OpenSSL configuration files, and also the
                    default certificate and key store.  Defaults are:
 
                    Unix:           /usr/local/ssl
@@ -92,60 +94,168 @@
                                 or C:\Program Files (x86)\Common Files\SSL
                    OpenVMS:        SYS$COMMON:[OPENSSL-COMMON]
 
-  --api=x.y.z      Don't build with support for deprecated APIs below the
+  --api=x.y.z
+                   Don't build with support for deprecated APIs below the
                    specified version number. For example &quot;--api=1.1.0&quot; will
                    remove support for all APIS that were deprecated in OpenSSL
                    version 1.1.0 or below.
 
-  no-deprecated    Don't build with support for any deprecated APIs. This is the
-                   same as using &quot;--api&quot; and supplying the latest version
-                   number.
+  no-afalgeng
+                   Don't build the AFALG engine. This option will be forced if
+                   on a platform that does not support AFALG.
+
+  no-asm
+                   Do not use assembler code. On some platforms a small amount
+                   of assembler code may still be used.
+
+  no-async
+                   Do not build support for async operations.
 
-  no-autoalginit   Don't automatically load all supported ciphers and digests.
+  no-autoalginit
+                   Don't automatically load all supported ciphers and digests.
                    Typically OpenSSL will make available all of its supported
                    ciphers and digests. For a statically linked application this
                    may be undesirable if small executable size is an objective.
                    This only affects libcrypto. Ciphers and digests will have to
                    be loaded manually using EVP_add_cipher() and
-                   EVP_add_digest() if this option is used.
+                   EVP_add_digest() if this option is used. This option will
+                   force a non-shared build.
 
-  no-autoerrinit   Don't automatically load all libcrypto/libssl error strings.
+  no-autoerrinit
+                   Don't automatically load all libcrypto/libssl error strings.
                    Typically OpenSSL will automatically load human readable
                    error strings. For a statically linked application this may
                    be undesirable if small executable size is an objective.
 
-  no-threads       Don't try to build with support for multi-threaded
-                   applications.
 
-  threads          Build with support for multi-threaded applications.
-                   This will usually require additional system-dependent
-                   options! See &quot;Note on multi-threading&quot; below.
+  no-capieng
+                   Don't build the CAPI engine. This option will be forced if
+                   on a platform that does not support CAPI.
 
-  no-zlib          Don't try to build with support for zlib compression and
-                   decompression.
+  no-cms
+                   Don't build support for CMS features
 
-  zlib             Build with support for zlib compression/decompression.
+  no-comp
+                   Don't build support for SSL/TLS compression. If this option
+                   is left enabled (the default), then compression will only
+                   work if the zlib or zlib-dynamic options are also chosen.
 
-  zlib-dynamic     Like &quot;zlib&quot;, but has OpenSSL load the zlib library
-                   dynamically when needed.  This is only supported on systems
-                   where loading of shared libraries is supported.  This is the
-                   default choice.
+  enable-crypto-mdebug
+                   Build support for debugging memory allocated via
+                   OPENSSL_malloc() or OPENSSL_zalloc().
+
+  enable-crypto-mdebug-backtrace
+                   As for crypto-mdebug, but additionally provide backtrace
+                   information for allocated memory.
+
+  no-ct
+                   Don't build support for Certificate Transparency.
+
+  no-deprecated
+                   Don't build with support for any deprecated APIs. This is the
+                   same as using &quot;--api&quot; and supplying the latest version
+                   number.
+
+  no-dgram
+                   Don't build support for datagram based BIOs. Selecting this
+                   option will also force the disabling of DTLS.
+
+  no-dso
+                   Don't build support for loading Dynamic Shared Objects.
+
+  no-dynamic-engine
+                   Don't build the dynamically loaded engines. This only has an
+                   effect in a &quot;shared&quot; build
+
+  no-ec
+                   Don't build support for Elliptic Curves.
+
+  no-ec2m
+                   Don't build support for binary Elliptic Curves
+
+  enable-ec_nistp_64_gcc_128
+                   Enable support for optimised implementations of some commonly
+                   used NIST elliptic curves. This is only supported on some
+                   platforms.
+
+  enable-egd
+                   Build support for gathering entropy from EGD (Entropy
+                   Gathering Daemon).
+
+  no-engine
+                   Don't build support for loading engines.
+
+  no-err
+                   Don't compile in any error strings.
+
+  no-filenames
+                   Don't compile in filename and line number information (e.g.
+                   for errors and memory allocation).
+
+  no-gost
+                   Don't build support for GOST based ciphersuites. Note that
+                   if this feature is enabled then GOST ciphersuites are only
+                   available if the GOST algorithms are also available through
+                   loading an externally supplied engine.
+
+  enable-heartbeats
+                   Build support for DTLS heartbeats.
+
+  no-hw-padlock
+                   Don't build the padlock engine.
+
+  no-makedepend
+                   Don't generate dependencies.
+
+  no-multiblock
+                   Don't build support for writing multiple records in one
+                   go in libssl (Note: this is a different capability to the
+                   pipelining functionality).
+
+  no-nextprotoneg
+                   Don't build support for the NPN TLS extension.
+
+  no-ocsp
+                   Don't build support for OCSP.
 
-  no-shared        Don't try to create shared libraries.
+  no-pic
+                   Don't build with support for Position Independent Code.
 
-  shared           In addition to the usual static libraries, create shared
+  no-posix-io
+                   Don't use POSIX IO capabilities.
+
+  no-psk
+                   Don't build support for Pre-Shared Key based ciphersuites.
+
+  no-rdrand
+                   Don't use hardware RDRAND capabilities.
+
+  no-rfc3779
+                   Don't build support for RFC3779 (&quot;X.509 Extensions for IP
+                   Addresses and AS Identifiers&quot;)
+
+  no-sct
+                   ??
+
+  sctp
+                   Build support for SCTP
+
+  shared
+                   In addition to the usual static libraries, create shared
                    libraries on platforms where it's supported.  See &quot;Note on
                    shared libraries&quot; below.
 
-  no-asm           Do not use assembler code.
+  no-sock
+                   Don't build support for socket BIOs
 
-  386              On Intel hardware, use the 80386 instruction set only
-                   (the default x86 code is more efficient, but requires at
-                   least a 486). Note: Use compiler flags for any other CPU
-                   specific configuration, e.g. &quot;-m32&quot; to build x86 code on
-                   an x64 system.
+  no-srp
+                   Don't build support for SRP or SRP based ciphersuites.
+
+  no-srtp
+                   Don't build SRTP support
 
-  no-sse2          Exclude SSE2 code pathes. Normally SSE2 extension is
+  no-sse2
+                   Exclude SSE2 code paths. Normally SSE2 extension is
                    detected at run-time, but the decision whether or not the
                    machine code will be executed is taken solely on CPU
                    capability vector. This means that if you happen to run OS
@@ -156,15 +266,96 @@
                    compiled with CPU_ENABLE_SSE, and there is a way to
                    disengage SSE2 code pathes upon application start-up,
                    but if you aim for wider &quot;audience&quot; running such kernel,
-                   consider no-sse2. Both 386 and no-asm options above imply
+                   consider no-sse2. Both the 386 and no-asm options imply
                    no-sse2.
 
-  no-&lt;alg&gt;         Build without the specified algorithm (bf, cast, des, dh,
-                   dsa, hmac, md2, md5, mdc2, rc2, rc4, rc5, rsa, sha).
+  enable-ssl-trace
+                   Build with the SSL Trace capabilities (adds the &quot;-trace&quot;
+                   option to s_client and s_server).
+
+  no-static-engine
+                   Don't build the statically linked engines. This only
+                   has an impact when not built &quot;shared&quot;.
+
+  no-stdio
+                   Don't use any C &quot;stdio&quot; features. Only libcrypto and libssl
+                   can be built in this way. Using this option will suppress
+                   building the command line applications. Additionally since
+                   the OpenSSL tests also use the command line applications the
+                   tests will also be skipped.
+
+  no-threads
+                   Don't try to build with support for multi-threaded
+                   applications.
+
+  threads
+                   Build with support for multi-threaded applications. Most
+                   platforms will enable this by default. However if on a
+                   platform where this is not the case then this will usually
+                   require additional system-dependent options! See &quot;Note on
+                   multi-threading&quot; below.
+
+  no-ts
+                   Don't build Time Stamping Authority support.
+
+  no-ui
+                   Don't build with the &quot;UI&quot; capability (i.e. the set of
+                   features enabling text based prompts).
+
+  enable-unit-test
+                   Enable additional unit test APIs. This should not typically
+                   be used in production deployments.
+
+  enable-weak-ssl-ciphers
+                   Build support for SSL/TLS ciphers that are considered &quot;weak&quot;
+                   (e.g. RC4 based ciphersuites).
+
+  zlib
+                   Build with support for zlib compression/decompression.
+
+  zlib-dynamic
+                   Like &quot;zlib&quot;, but has OpenSSL load the zlib library
+                   dynamically when needed.  This is only supported on systems
+                   where loading of shared libraries is supported.
+
+  386
+                   On Intel hardware, use the 80386 instruction set only
+                   (the default x86 code is more efficient, but requires at
+                   least a 486). Note: Use compiler flags for any other CPU
+                   specific configuration, e.g. &quot;-m32&quot; to build x86 code on
+                   an x64 system.
 
-  -Dxxx, -lxxx,    These system specific options will be passed through to the
-  -Lxxx, -fxxx,    compiler to allow you to define preprocessor symbols, specify
-  -mXXX, -Kxxx     additional libraries, library directories or other compiler
+  no-&lt;prot&gt;
+                   Don't build support for negotiating the specified SSL/TLS
+                   protocol (one of ssl, ssl3, tls, tls1, tls1_1, tls1_2, dtls,
+                   dtls1 or dtls1_2). If &quot;no-tls&quot; is selected then all of tls1,
+                   tls1_1 and tls1_2 are disabled. Similarly &quot;no-dtls&quot; will
+                   disable dtls1 and dtls1_2. The &quot;no-ssl&quot; option is synonymous
+                   with &quot;no-ssl3&quot;. Note this only affects version negotiation.
+                   OpenSSL will still provide the methods for applications to
+                   explicitly select the individual protocol versions.
+
+  no-&lt;prot&gt;-method
+                   As for no-&lt;prot&gt; but in addition do not build the methods for
+                   applications to explicitly select individual protocol
+                   versions.
+
+  enable-&lt;alg&gt;
+                   Build with support for the specified algorithm, where &lt;alg&gt;
+                   is one of: md2 or rc5.
+
+  no-&lt;alg&gt;
+                   Build without support for the specified algorithm, where
+                   &lt;alg&gt; is one of: bf, blake2, camellia, cast, chacha, cmac,
+                   des, dh, dsa, ecdh, ecdsa, idea, md4, md5, mdc2, ocb,
+                   ploy1305, rc2, rc4, rmd160, scrypt, seed or whirlpool. The
+                   &quot;ripemd&quot; algorithm is deprecated and if used is synonymous
+                   with rmd160.
+
+  -Dxxx, -lxxx, -Lxxx, -fxxx, -mXXX, -Kxxx
+                   These system specific options will be passed through to the
+                   compiler to allow you to define preprocessor symbols, specify
+                   additional libraries, library directories or other compiler
                    options.
 
 
diff --git a/apps/cms.c b/apps/cms.c
index 1f0e192..a74ca9d 100644
--- a/apps/cms.c
+++ b/apps/cms.c
@@ -214,11 +214,9 @@ OPTIONS cms_options[] = {
     {&quot;receipt_request_to&quot;, OPT_RR_TO, 's'},
     {&quot;&quot;, OPT_CIPHER, '-', &quot;Any supported cipher&quot;},
     OPT_V_OPTIONS,
-# ifndef OPENSSL_NO_AES
     {&quot;aes128-wrap&quot;, OPT_AES128_WRAP, '-', &quot;Use AES128 to wrap key&quot;},
     {&quot;aes192-wrap&quot;, OPT_AES192_WRAP, '-', &quot;Use AES192 to wrap key&quot;},
     {&quot;aes256-wrap&quot;, OPT_AES256_WRAP, '-', &quot;Use AES256 to wrap key&quot;},
-# endif
 # ifndef OPENSSL_NO_DES
     {&quot;des3-wrap&quot;, OPT_3DES_WRAP, '-', &quot;Use 3DES-EDE to wrap key&quot;},
 # endif
@@ -603,7 +601,6 @@ int cms_main(int argc, char **argv)
             wrap_cipher = EVP_des_ede3_wrap();
 # endif
             break;
-# ifndef OPENSSL_NO_AES
         case OPT_AES128_WRAP:
             wrap_cipher = EVP_aes_128_wrap();
             break;
@@ -613,12 +610,6 @@ int cms_main(int argc, char **argv)
         case OPT_AES256_WRAP:
             wrap_cipher = EVP_aes_256_wrap();
             break;
-# else
-        case OPT_AES128_WRAP:
-        case OPT_AES192_WRAP:
-        case OPT_AES256_WRAP:
-            break;
-# endif
         }
     }
     argc = opt_num_rest();
diff --git a/apps/openssl.c b/apps/openssl.c
index 26ea449..c8912ee 100644
--- a/apps/openssl.c
+++ b/apps/openssl.c
@@ -644,9 +644,6 @@ static int SortFnByName(const void *_f1, const void *_f2)
 static void list_disabled(void)
 {
     BIO_puts(bio_out, &quot;Disabled algorithms:\n&quot;);
-#ifdef OPENSSL_NO_AES
-    BIO_puts(bio_out, &quot;AES\n&quot;);
-#endif
 #ifdef OPENSSL_NO_BF
     BIO_puts(bio_out, &quot;BF\n&quot;);
 #endif
@@ -704,9 +701,6 @@ static void list_disabled(void)
 #ifdef OPENSSL_NO_HEARTBEATS
     BIO_puts(bio_out, &quot;HEARTBEATS\n&quot;);
 #endif
-#ifdef OPENSSL_NO_HMAC
-    BIO_puts(bio_out, &quot;HMAC\n&quot;);
-#endif
 #ifdef OPENSSL_NO_IDEA
     BIO_puts(bio_out, &quot;IDEA\n&quot;);
 #endif
@@ -758,9 +752,6 @@ static void list_disabled(void)
 #ifdef OPENSSL_NO_SEED
     BIO_puts(bio_out, &quot;SEED\n&quot;);
 #endif
-#ifdef OPENSSL_NO_SHA
-    BIO_puts(bio_out, &quot;SHA\n&quot;);
-#endif
 #ifdef OPENSSL_NO_SOCK
     BIO_puts(bio_out, &quot;SOCK\n&quot;);
 #endif
diff --git a/apps/progs.h b/apps/progs.h
index 2711f2a..c8779d9 100644
--- a/apps/progs.h
+++ b/apps/progs.h
@@ -181,9 +181,7 @@ static FUNCTION functions[] = {
     { FT_general, &quot;rand&quot;, rand_main, rand_options },
     { FT_general, &quot;rehash&quot;, rehash_main, rehash_options },
     { FT_general, &quot;req&quot;, req_main, req_options },
-#ifndef OPENSSL_NO_RSA
     { FT_general, &quot;rsa&quot;, rsa_main, rsa_options },
-#endif
 #ifndef OPENSSL_NO_RSA
     { FT_general, &quot;rsautl&quot;, rsautl_main, rsautl_options },
 #endif
@@ -248,24 +246,12 @@ static FUNCTION functions[] = {
 #ifndef OPENSSL_NO_BLAKE2
     { FT_md, &quot;blake2s256&quot;, dgst_main},
 #endif
-#ifndef OPENSSL_NO_AES
     { FT_cipher, &quot;aes-128-cbc&quot;, enc_main, enc_options },
-#endif
-#ifndef OPENSSL_NO_AES
     { FT_cipher, &quot;aes-128-ecb&quot;, enc_main, enc_options },
-#endif
-#ifndef OPENSSL_NO_AES
     { FT_cipher, &quot;aes-192-cbc&quot;, enc_main, enc_options },
-#endif
-#ifndef OPENSSL_NO_AES
     { FT_cipher, &quot;aes-192-ecb&quot;, enc_main, enc_options },
-#endif
-#ifndef OPENSSL_NO_AES
     { FT_cipher, &quot;aes-256-cbc&quot;, enc_main, enc_options },
-#endif
-#ifndef OPENSSL_NO_AES
     { FT_cipher, &quot;aes-256-ecb&quot;, enc_main, enc_options },
-#endif
 #ifndef OPENSSL_NO_CAMELLIA
     { FT_cipher, &quot;camellia-128-cbc&quot;, enc_main, enc_options },
 #endif
diff --git a/apps/speed.c b/apps/speed.c
index b2c247f..345e539 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -99,9 +99,7 @@
 #ifndef OPENSSL_NO_DES
 # include &lt;openssl/des.h&gt;
 #endif
-#ifndef OPENSSL_NO_AES
-# include &lt;openssl/aes.h&gt;
-#endif
+#include &lt;openssl/aes.h&gt;
 #ifndef OPENSSL_NO_CAMELLIA
 # include &lt;openssl/camellia.h&gt;
 #endif
@@ -249,7 +247,6 @@ static int RC4_loop(void *args);
 static int DES_ncbc_encrypt_loop(void *args);
 static int DES_ede3_cbc_encrypt_loop(void *args);
 #endif
-#ifndef OPENSSL_NO_AES
 static int AES_cbc_128_encrypt_loop(void *args);
 static int AES_cbc_192_encrypt_loop(void *args);
 static int AES_ige_128_encrypt_loop(void *args);
@@ -257,7 +254,6 @@ static int AES_cbc_256_encrypt_loop(void *args);
 static int AES_ige_192_encrypt_loop(void *args);
 static int AES_ige_256_encrypt_loop(void *args);
 static int CRYPTO_gcm128_aad_loop(void *args);
-#endif
 static int EVP_Update_loop(void *args);
 static int EVP_Digest_loop(void *args);
 #ifndef OPENSSL_NO_RSA
@@ -508,14 +504,12 @@ static OPT_PAIR doit_choices[] = {
     {&quot;des-cbc&quot;, D_CBC_DES},
     {&quot;des-ede3&quot;, D_EDE3_DES},
 #endif
-#ifndef OPENSSL_NO_AES
     {&quot;aes-128-cbc&quot;, D_CBC_128_AES},
     {&quot;aes-192-cbc&quot;, D_CBC_192_AES},
     {&quot;aes-256-cbc&quot;, D_CBC_256_AES},
     {&quot;aes-128-ige&quot;, D_IGE_128_AES},
     {&quot;aes-192-ige&quot;, D_IGE_192_AES},
     {&quot;aes-256-ige&quot;, D_IGE_256_AES},
-#endif
 #ifndef OPENSSL_NO_RC2
     {&quot;rc2-cbc&quot;, D_CBC_RC2},
     {&quot;rc2&quot;, D_CBC_RC2},
@@ -819,14 +813,9 @@ static int DES_ede3_cbc_encrypt_loop(void *args)
 }
 #endif
 
-#ifndef OPENSSL_NO_AES
-# define MAX_BLOCK_SIZE 128
-#else
-# define MAX_BLOCK_SIZE 64
-#endif
+#define MAX_BLOCK_SIZE 128
 
 static unsigned char iv[2 * MAX_BLOCK_SIZE / 8];
-#ifndef OPENSSL_NO_AES
 static AES_KEY aes_ks1, aes_ks2, aes_ks3;
 static int AES_cbc_128_encrypt_loop(void *args)
 {
@@ -914,8 +903,6 @@ static int CRYPTO_gcm128_aad_loop(void *args)
     return count;
 }
 
-#endif
-
 static int decrypt = 0;
 static int EVP_Update_loop(void *args)
 {
@@ -1294,7 +1281,6 @@ int speed_main(int argc, char **argv)
         0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
         0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12
     };
-#ifndef OPENSSL_NO_AES
     static const unsigned char key24[24] = {
         0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
         0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
@@ -1306,7 +1292,6 @@ int speed_main(int argc, char **argv)
         0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
         0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56
     };
-#endif
 #ifndef OPENSSL_NO_CAMELLIA
     static const unsigned char ckey24[24] = {
         0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
@@ -1542,13 +1527,11 @@ int speed_main(int argc, char **argv)
             continue;
         }
 #endif
-#ifndef OPENSSL_NO_AES
         if (strcmp(*argv, &quot;aes&quot;) == 0) {
             doit[D_CBC_128_AES] = doit[D_CBC_192_AES] =
                 doit[D_CBC_256_AES] = 1;
             continue;
         }
-#endif
 #ifndef OPENSSL_NO_CAMELLIA
         if (strcmp(*argv, &quot;camellia&quot;) == 0) {
             doit[D_CBC_128_CML] = doit[D_CBC_192_CML] =
@@ -1675,11 +1658,9 @@ int speed_main(int argc, char **argv)
     DES_set_key_unchecked(&amp;key2, &amp;sch2);
     DES_set_key_unchecked(&amp;key3, &amp;sch3);
 #endif
-#ifndef OPENSSL_NO_AES
     AES_set_encrypt_key(key16, 128, &amp;aes_ks1);
     AES_set_encrypt_key(key24, 192, &amp;aes_ks2);
     AES_set_encrypt_key(key32, 256, &amp;aes_ks3);
-#endif
 #ifndef OPENSSL_NO_CAMELLIA
     Camellia_set_key(key16, 128, &amp;camellia_ks1);
     Camellia_set_key(ckey24, 192, &amp;camellia_ks2);
@@ -2079,7 +2060,7 @@ int speed_main(int argc, char **argv)
         }
     }
 #endif
-#ifndef OPENSSL_NO_AES
+
     if (doit[D_CBC_128_AES]) {
         for (testnum = 0; testnum &lt; SIZE_NUM; testnum++) {
             print_message(names[D_CBC_128_AES], c[D_CBC_128_AES][testnum],
@@ -2157,7 +2138,7 @@ int speed_main(int argc, char **argv)
         for (i = 0; i &lt; loopargs_len; i++)
             CRYPTO_gcm128_release(loopargs[i].gcm_ctx);
     }
-#endif
+
 #ifndef OPENSSL_NO_CAMELLIA
     if (doit[D_CBC_128_CML]) {
         for (testnum = 0; testnum &lt; SIZE_NUM; testnum++) {
@@ -2710,9 +2691,7 @@ int speed_main(int argc, char **argv)
 #ifndef OPENSSL_NO_DES
         printf(&quot;%s &quot;, DES_options());
 #endif
-#ifndef OPENSSL_NO_AES
         printf(&quot;%s &quot;, AES_options());
-#endif
 #ifndef OPENSSL_NO_IDEA
         printf(&quot;%s &quot;, idea_options());
 #endif
diff --git a/crypto/evp/c_allc.c b/crypto/evp/c_allc.c
index a36e2c6..ac172e8 100644
--- a/crypto/evp/c_allc.c
+++ b/crypto/evp/c_allc.c
@@ -167,7 +167,6 @@ void openssl_add_all_ciphers_int(void)
     EVP_add_cipher_alias(SN_rc5_cbc, &quot;RC5&quot;);
 #endif
 
-#ifndef OPENSSL_NO_AES
     EVP_add_cipher(EVP_aes_128_ecb());
     EVP_add_cipher(EVP_aes_128_cbc());
     EVP_add_cipher(EVP_aes_128_cfb());
@@ -176,9 +175,9 @@ void openssl_add_all_ciphers_int(void)
     EVP_add_cipher(EVP_aes_128_ofb());
     EVP_add_cipher(EVP_aes_128_ctr());
     EVP_add_cipher(EVP_aes_128_gcm());
-# ifndef OPENSSL_NO_OCB
+#ifndef OPENSSL_NO_OCB
     EVP_add_cipher(EVP_aes_128_ocb());
-# endif
+#endif
     EVP_add_cipher(EVP_aes_128_xts());
     EVP_add_cipher(EVP_aes_128_ccm());
     EVP_add_cipher(EVP_aes_128_wrap());
@@ -194,9 +193,9 @@ void openssl_add_all_ciphers_int(void)
     EVP_add_cipher(EVP_aes_192_ofb());
     EVP_add_cipher(EVP_aes_192_ctr());
     EVP_add_cipher(EVP_aes_192_gcm());
-# ifndef OPENSSL_NO_OCB
+#ifndef OPENSSL_NO_OCB
     EVP_add_cipher(EVP_aes_192_ocb());
-# endif
+#endif
     EVP_add_cipher(EVP_aes_192_ccm());
     EVP_add_cipher(EVP_aes_192_wrap());
     EVP_add_cipher_alias(SN_id_aes192_wrap, &quot;aes192-wrap&quot;);
@@ -211,9 +210,9 @@ void openssl_add_all_ciphers_int(void)
     EVP_add_cipher(EVP_aes_256_ofb());
     EVP_add_cipher(EVP_aes_256_ctr());
     EVP_add_cipher(EVP_aes_256_gcm());
-# ifndef OPENSSL_NO_OCB
+#ifndef OPENSSL_NO_OCB
     EVP_add_cipher(EVP_aes_256_ocb());
-# endif
+#endif
     EVP_add_cipher(EVP_aes_256_xts());
     EVP_add_cipher(EVP_aes_256_ccm());
     EVP_add_cipher(EVP_aes_256_wrap());
@@ -225,7 +224,6 @@ void openssl_add_all_ciphers_int(void)
     EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
     EVP_add_cipher(EVP_aes_128_cbc_hmac_sha256());
     EVP_add_cipher(EVP_aes_256_cbc_hmac_sha256());
-#endif
 
 #ifndef OPENSSL_NO_CAMELLIA
     EVP_add_cipher(EVP_camellia_128_ecb());
diff --git a/crypto/evp/e_aes.c b/crypto/evp/e_aes.c
index c906e6f..f0e410f 100644
--- a/crypto/evp/e_aes.c
+++ b/crypto/evp/e_aes.c
@@ -49,16 +49,15 @@
  */
 
 #include &lt;openssl/opensslconf.h&gt;
-#ifndef OPENSSL_NO_AES
-# include &lt;openssl/crypto.h&gt;
-# include &lt;openssl/evp.h&gt;
-# include &lt;openssl/err.h&gt;
-# include &lt;string.h&gt;
-# include &lt;assert.h&gt;
-# include &lt;openssl/aes.h&gt;
-# include &quot;internal/evp_int.h&quot;
-# include &quot;modes_lcl.h&quot;
-# include &lt;openssl/rand.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/err.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;openssl/aes.h&gt;
+#include &quot;internal/evp_int.h&quot;
+#include &quot;modes_lcl.h&quot;
+#include &lt;openssl/rand.h&gt;
 
 typedef struct {
     union {
@@ -115,7 +114,7 @@ typedef struct {
     ccm128_f str;
 } EVP_AES_CCM_CTX;
 
-# ifndef OPENSSL_NO_OCB
+#ifndef OPENSSL_NO_OCB
 typedef struct {
     union {
         double align;
@@ -137,11 +136,11 @@ typedef struct {
     int ivlen;                  /* IV length */
     int taglen;
 } EVP_AES_OCB_CTX;
-# endif
+#endif
 
-# define MAXBITCHUNK     ((size_t)1&lt;&lt;(sizeof(size_t)*8-4))
+#define MAXBITCHUNK     ((size_t)1&lt;&lt;(sizeof(size_t)*8-4))
 
-# ifdef VPAES_ASM
+#ifdef VPAES_ASM
 int vpaes_set_encrypt_key(const unsigned char *userKey, int bits,
                           AES_KEY *key);
 int vpaes_set_decrypt_key(const unsigned char *userKey, int bits,
@@ -156,8 +155,8 @@ void vpaes_cbc_encrypt(const unsigned char *in,
                        unsigned char *out,
                        size_t length,
                        const AES_KEY *key, unsigned char *ivec, int enc);
-# endif
-# ifdef BSAES_ASM
+#endif
+#ifdef BSAES_ASM
 void bsaes_cbc_encrypt(const unsigned char *in, unsigned char *out,
                        size_t length, const AES_KEY *key,
                        unsigned char ivec[16], int enc);
@@ -170,36 +169,36 @@ void bsaes_xts_encrypt(const unsigned char *inp, unsigned char *out,
 void bsaes_xts_decrypt(const unsigned char *inp, unsigned char *out,
                        size_t len, const AES_KEY *key1,
                        const AES_KEY *key2, const unsigned char iv[16]);
-# endif
-# ifdef AES_CTR_ASM
+#endif
+#ifdef AES_CTR_ASM
 void AES_ctr32_encrypt(const unsigned char *in, unsigned char *out,
                        size_t blocks, const AES_KEY *key,
                        const unsigned char ivec[AES_BLOCK_SIZE]);
-# endif
-# ifdef AES_XTS_ASM
+#endif
+#ifdef AES_XTS_ASM
 void AES_xts_encrypt(const char *inp, char *out, size_t len,
                      const AES_KEY *key1, const AES_KEY *key2,
                      const unsigned char iv[16]);
 void AES_xts_decrypt(const char *inp, char *out, size_t len,
                      const AES_KEY *key1, const AES_KEY *key2,
                      const unsigned char iv[16]);
-# endif
+#endif
 
-# if     defined(OPENSSL_CPUID_OBJ) &amp;&amp; (defined(__powerpc__) || defined(__ppc__) || defined(_ARCH_PPC))
-#  include &quot;ppc_arch.h&quot;
-#  ifdef VPAES_ASM
-#   define VPAES_CAPABLE (OPENSSL_ppccap_P &amp; PPC_ALTIVEC)
-#  endif
-#  define HWAES_CAPABLE  (OPENSSL_ppccap_P &amp; PPC_CRYPTO207)
-#  define HWAES_set_encrypt_key aes_p8_set_encrypt_key
-#  define HWAES_set_decrypt_key aes_p8_set_decrypt_key
-#  define HWAES_encrypt aes_p8_encrypt
-#  define HWAES_decrypt aes_p8_decrypt
-#  define HWAES_cbc_encrypt aes_p8_cbc_encrypt
-#  define HWAES_ctr32_encrypt_blocks aes_p8_ctr32_encrypt_blocks
+#if     defined(OPENSSL_CPUID_OBJ) &amp;&amp; (defined(__powerpc__) || defined(__ppc__) || defined(_ARCH_PPC))
+# include &quot;ppc_arch.h&quot;
+# ifdef VPAES_ASM
+#  define VPAES_CAPABLE (OPENSSL_ppccap_P &amp; PPC_ALTIVEC)
 # endif
+# define HWAES_CAPABLE  (OPENSSL_ppccap_P &amp; PPC_CRYPTO207)
+# define HWAES_set_encrypt_key aes_p8_set_encrypt_key
+# define HWAES_set_decrypt_key aes_p8_set_decrypt_key
+# define HWAES_encrypt aes_p8_encrypt
+# define HWAES_decrypt aes_p8_decrypt
+# define HWAES_cbc_encrypt aes_p8_cbc_encrypt
+# define HWAES_ctr32_encrypt_blocks aes_p8_ctr32_encrypt_blocks
+#endif
 
-# if     defined(AES_ASM) &amp;&amp; !defined(I386_ONLY) &amp;&amp;      (  \
+#if     defined(AES_ASM) &amp;&amp; !defined(I386_ONLY) &amp;&amp;      (  \
         ((defined(__i386)       || defined(__i386__)    || \
           defined(_M_IX86)) &amp;&amp; defined(OPENSSL_IA32_SSE2))|| \
         defined(__x86_64)       || defined(__x86_64__)  || \
@@ -208,16 +207,16 @@ void AES_xts_decrypt(const char *inp, char *out, size_t len,
 
 extern unsigned int OPENSSL_ia32cap_P[];
 
-#  ifdef VPAES_ASM
-#   define VPAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
-#  endif
-#  ifdef BSAES_ASM
-#   define BSAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
-#  endif
+# ifdef VPAES_ASM
+#  define VPAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
+# endif
+# ifdef BSAES_ASM
+#  define BSAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
+# endif
 /*
  * AES-NI section
  */
-#  define AESNI_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(57-32)))
+# define AESNI_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(57-32)))
 
 int aesni_set_encrypt_key(const unsigned char *userKey, int bits,
                           AES_KEY *key);
@@ -268,25 +267,25 @@ void aesni_ccm64_decrypt_blocks(const unsigned char *in,
                                 const unsigned char ivec[16],
                                 unsigned char cmac[16]);
 
-#  if defined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)
+# if defined(__x86_64) || defined(__x86_64__) || defined(_M_AMD64) || defined(_M_X64)
 size_t aesni_gcm_encrypt(const unsigned char *in,
                          unsigned char *out,
                          size_t len,
                          const void *key, unsigned char ivec[16], u64 *Xi);
-#   define AES_gcm_encrypt aesni_gcm_encrypt
+#  define AES_gcm_encrypt aesni_gcm_encrypt
 size_t aesni_gcm_decrypt(const unsigned char *in,
                          unsigned char *out,
                          size_t len,
                          const void *key, unsigned char ivec[16], u64 *Xi);
-#   define AES_gcm_decrypt aesni_gcm_decrypt
+#  define AES_gcm_decrypt aesni_gcm_decrypt
 void gcm_ghash_avx(u64 Xi[2], const u128 Htable[16], const u8 *in,
                    size_t len);
-#   define AES_GCM_ASM(gctx)       (gctx-&gt;ctr==aesni_ctr32_encrypt_blocks &amp;&amp; \
+#  define AES_GCM_ASM(gctx)       (gctx-&gt;ctr==aesni_ctr32_encrypt_blocks &amp;&amp; \
                                  gctx-&gt;gcm.ghash==gcm_ghash_avx)
-#   define AES_GCM_ASM2(gctx)      (gctx-&gt;gcm.block==(block128_f)aesni_encrypt &amp;&amp; \
+#  define AES_GCM_ASM2(gctx)      (gctx-&gt;gcm.block==(block128_f)aesni_encrypt &amp;&amp; \
                                  gctx-&gt;gcm.ghash==gcm_ghash_avx)
-#   undef AES_GCM_ASM2          /* minor size optimization */
-#  endif
+#  undef AES_GCM_ASM2          /* minor size optimization */
+# endif
 
 static int aesni_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                           const unsigned char *iv, int enc)
@@ -346,23 +345,23 @@ static int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     return 1;
 }
 
-#  define aesni_ofb_cipher aes_ofb_cipher
+# define aesni_ofb_cipher aes_ofb_cipher
 static int aesni_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t len);
 
-#  define aesni_cfb_cipher aes_cfb_cipher
+# define aesni_cfb_cipher aes_cfb_cipher
 static int aesni_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t len);
 
-#  define aesni_cfb8_cipher aes_cfb8_cipher
+# define aesni_cfb8_cipher aes_cfb8_cipher
 static int aesni_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
 
-#  define aesni_cfb1_cipher aes_cfb1_cipher
+# define aesni_cfb1_cipher aes_cfb1_cipher
 static int aesni_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
 
-#  define aesni_ctr_cipher aes_ctr_cipher
+# define aesni_ctr_cipher aes_ctr_cipher
 static int aesni_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t len);
 
@@ -399,7 +398,7 @@ static int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     return 1;
 }
 
-#  define aesni_gcm_cipher aes_gcm_cipher
+# define aesni_gcm_cipher aes_gcm_cipher
 static int aesni_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t len);
 
@@ -440,7 +439,7 @@ static int aesni_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     return 1;
 }
 
-#  define aesni_xts_cipher aes_xts_cipher
+# define aesni_xts_cipher aes_xts_cipher
 static int aesni_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t len);
 
@@ -466,11 +465,11 @@ static int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     return 1;
 }
 
-#  define aesni_ccm_cipher aes_ccm_cipher
+# define aesni_ccm_cipher aes_ccm_cipher
 static int aesni_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t len);
 
-#  ifndef OPENSSL_NO_OCB
+# ifndef OPENSSL_NO_OCB
 void aesni_ocb_encrypt(const unsigned char *in, unsigned char *out,
                        size_t blocks, const void *key,
                        size_t start_block_num,
@@ -534,12 +533,12 @@ static int aesni_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     return 1;
 }
 
-#   define aesni_ocb_cipher aes_ocb_cipher
+#  define aesni_ocb_cipher aes_ocb_cipher
 static int aesni_ocb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                             const unsigned char *in, size_t len);
-#  endif                        /* OPENSSL_NO_OCB */
+# endif                        /* OPENSSL_NO_OCB */
 
-#  define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
+# define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
 static const EVP_CIPHER aesni_##keylen##_##mode = { \
         nid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \
         flags|EVP_CIPH_##MODE##_MODE,   \
@@ -560,7 +559,7 @@ static const EVP_CIPHER aes_##keylen##_##mode = { \
 const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 { return AESNI_CAPABLE?&amp;aesni_##keylen##_##mode:&amp;aes_##keylen##_##mode; }
 
-#  define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \
+# define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \
 static const EVP_CIPHER aesni_##keylen##_##mode = { \
         nid##_##keylen##_##mode,blocksize, \
         (EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \
@@ -582,13 +581,13 @@ static const EVP_CIPHER aes_##keylen##_##mode = { \
 const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 { return AESNI_CAPABLE?&amp;aesni_##keylen##_##mode:&amp;aes_##keylen##_##mode; }
 
-# elif   defined(AES_ASM) &amp;&amp; (defined(__sparc) || defined(__sparc__))
+#elif   defined(AES_ASM) &amp;&amp; (defined(__sparc) || defined(__sparc__))
 
-#  include &quot;sparc_arch.h&quot;
+# include &quot;sparc_arch.h&quot;
 
 extern unsigned int OPENSSL_sparcv9cap_P[];
 
-#  define SPARC_AES_CAPABLE       (OPENSSL_sparcv9cap_P[1] &amp; CFR_AES)
+# define SPARC_AES_CAPABLE       (OPENSSL_sparcv9cap_P[1] &amp; CFR_AES)
 
 void aes_t4_set_encrypt_key(const unsigned char *key, int bits, AES_KEY *ks);
 void aes_t4_set_decrypt_key(const unsigned char *key, int bits, AES_KEY *ks);
@@ -718,31 +717,31 @@ static int aes_t4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     return 1;
 }
 
-#  define aes_t4_cbc_cipher aes_cbc_cipher
+# define aes_t4_cbc_cipher aes_cbc_cipher
 static int aes_t4_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
 
-#  define aes_t4_ecb_cipher aes_ecb_cipher
+# define aes_t4_ecb_cipher aes_ecb_cipher
 static int aes_t4_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
 
-#  define aes_t4_ofb_cipher aes_ofb_cipher
+# define aes_t4_ofb_cipher aes_ofb_cipher
 static int aes_t4_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
 
-#  define aes_t4_cfb_cipher aes_cfb_cipher
+# define aes_t4_cfb_cipher aes_cfb_cipher
 static int aes_t4_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
 
-#  define aes_t4_cfb8_cipher aes_cfb8_cipher
+# define aes_t4_cfb8_cipher aes_cfb8_cipher
 static int aes_t4_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                               const unsigned char *in, size_t len);
 
-#  define aes_t4_cfb1_cipher aes_cfb1_cipher
+# define aes_t4_cfb1_cipher aes_cfb1_cipher
 static int aes_t4_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                               const unsigned char *in, size_t len);
 
-#  define aes_t4_ctr_cipher aes_ctr_cipher
+# define aes_t4_ctr_cipher aes_ctr_cipher
 static int aes_t4_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
 
@@ -792,7 +791,7 @@ static int aes_t4_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     return 1;
 }
 
-#  define aes_t4_gcm_cipher aes_gcm_cipher
+# define aes_t4_gcm_cipher aes_gcm_cipher
 static int aes_t4_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
 
@@ -852,7 +851,7 @@ static int aes_t4_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     return 1;
 }
 
-#  define aes_t4_xts_cipher aes_xts_cipher
+# define aes_t4_xts_cipher aes_xts_cipher
 static int aes_t4_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
 
@@ -877,11 +876,11 @@ static int aes_t4_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     return 1;
 }
 
-#  define aes_t4_ccm_cipher aes_ccm_cipher
+# define aes_t4_ccm_cipher aes_ccm_cipher
 static int aes_t4_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
 
-#  ifndef OPENSSL_NO_OCB
+# ifndef OPENSSL_NO_OCB
 static int aes_t4_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                                const unsigned char *iv, int enc)
 {
@@ -931,12 +930,12 @@ static int aes_t4_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     return 1;
 }
 
-#   define aes_t4_ocb_cipher aes_ocb_cipher
+#  define aes_t4_ocb_cipher aes_ocb_cipher
 static int aes_t4_ocb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                              const unsigned char *in, size_t len);
-#  endif                        /* OPENSSL_NO_OCB */
+# endif                        /* OPENSSL_NO_OCB */
 
-#  define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
+# define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
 static const EVP_CIPHER aes_t4_##keylen##_##mode = { \
         nid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \
         flags|EVP_CIPH_##MODE##_MODE,   \
@@ -957,7 +956,7 @@ static const EVP_CIPHER aes_##keylen##_##mode = { \
 const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 { return SPARC_AES_CAPABLE?&amp;aes_t4_##keylen##_##mode:&amp;aes_##keylen##_##mode; }
 
-#  define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \
+# define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \
 static const EVP_CIPHER aes_t4_##keylen##_##mode = { \
         nid##_##keylen##_##mode,blocksize, \
         (EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \
@@ -979,9 +978,9 @@ static const EVP_CIPHER aes_##keylen##_##mode = { \
 const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 { return SPARC_AES_CAPABLE?&amp;aes_t4_##keylen##_##mode:&amp;aes_##keylen##_##mode; }
 
-# else
+#else
 
-#  define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
+# define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
 static const EVP_CIPHER aes_##keylen##_##mode = { \
         nid##_##keylen##_##nmode,blocksize,keylen/8,ivlen, \
         flags|EVP_CIPH_##MODE##_MODE,   \
@@ -993,7 +992,7 @@ static const EVP_CIPHER aes_##keylen##_##mode = { \
 const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 { return &amp;aes_##keylen##_##mode; }
 
-#  define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \
+# define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags) \
 static const EVP_CIPHER aes_##keylen##_##mode = { \
         nid##_##keylen##_##mode,blocksize, \
         (EVP_CIPH_##MODE##_MODE==EVP_CIPH_XTS_MODE?2:1)*keylen/8, ivlen, \
@@ -1006,28 +1005,28 @@ static const EVP_CIPHER aes_##keylen##_##mode = { \
 const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 { return &amp;aes_##keylen##_##mode; }
 
-# endif
+#endif
 
-# if defined(OPENSSL_CPUID_OBJ) &amp;&amp; (defined(__arm__) || defined(__arm) || defined(__aarch64__))
-#  include &quot;arm_arch.h&quot;
-#  if __ARM_MAX_ARCH__&gt;=7
-#   if defined(BSAES_ASM)
-#    define BSAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
-#   endif
-#   if defined(VPAES_ASM)
-#    define VPAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
-#   endif
-#   define HWAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV8_AES)
-#   define HWAES_set_encrypt_key aes_v8_set_encrypt_key
-#   define HWAES_set_decrypt_key aes_v8_set_decrypt_key
-#   define HWAES_encrypt aes_v8_encrypt
-#   define HWAES_decrypt aes_v8_decrypt
-#   define HWAES_cbc_encrypt aes_v8_cbc_encrypt
-#   define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks
+#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; (defined(__arm__) || defined(__arm) || defined(__aarch64__))
+# include &quot;arm_arch.h&quot;
+# if __ARM_MAX_ARCH__&gt;=7
+#  if defined(BSAES_ASM)
+#   define BSAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
+#  endif
+#  if defined(VPAES_ASM)
+#   define VPAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
 #  endif
+#  define HWAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV8_AES)
+#  define HWAES_set_encrypt_key aes_v8_set_encrypt_key
+#  define HWAES_set_decrypt_key aes_v8_set_decrypt_key
+#  define HWAES_encrypt aes_v8_encrypt
+#  define HWAES_decrypt aes_v8_decrypt
+#  define HWAES_cbc_encrypt aes_v8_cbc_encrypt
+#  define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks
 # endif
+#endif
 
-# if defined(HWAES_CAPABLE)
+#if defined(HWAES_CAPABLE)
 int HWAES_set_encrypt_key(const unsigned char *userKey, const int bits,
                           AES_KEY *key);
 int HWAES_set_decrypt_key(const unsigned char *userKey, const int bits,
@@ -1042,9 +1041,9 @@ void HWAES_cbc_encrypt(const unsigned char *in, unsigned char *out,
 void HWAES_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
                                 size_t len, const AES_KEY *key,
                                 const unsigned char ivec[16]);
-# endif
+#endif
 
-# define BLOCK_CIPHER_generic_pack(nid,keylen,flags)             \
+#define BLOCK_CIPHER_generic_pack(nid,keylen,flags)             \
         BLOCK_CIPHER_generic(nid,keylen,16,16,cbc,cbc,CBC,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)     \
         BLOCK_CIPHER_generic(nid,keylen,16,0,ecb,ecb,ECB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)      \
         BLOCK_CIPHER_generic(nid,keylen,1,16,ofb128,ofb,OFB,flags|EVP_CIPH_FLAG_DEFAULT_ASN1)   \
@@ -1062,28 +1061,28 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     mode = EVP_CIPHER_CTX_mode(ctx);
     if ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)
         &amp;&amp; !enc)
-# ifdef HWAES_CAPABLE
+#ifdef HWAES_CAPABLE
         if (HWAES_CAPABLE) {
             ret = HWAES_set_decrypt_key(key,
                                         EVP_CIPHER_CTX_key_length(ctx) * 8,
                                         &amp;dat-&gt;ks.ks);
             dat-&gt;block = (block128_f) HWAES_decrypt;
             dat-&gt;stream.cbc = NULL;
-#  ifdef HWAES_cbc_encrypt
+# ifdef HWAES_cbc_encrypt
             if (mode == EVP_CIPH_CBC_MODE)
                 dat-&gt;stream.cbc = (cbc128_f) HWAES_cbc_encrypt;
-#  endif
-        } else
 # endif
-# ifdef BSAES_CAPABLE
+        } else
+#endif
+#ifdef BSAES_CAPABLE
         if (BSAES_CAPABLE &amp;&amp; mode == EVP_CIPH_CBC_MODE) {
             ret = AES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                       &amp;dat-&gt;ks.ks);
             dat-&gt;block = (block128_f) AES_decrypt;
             dat-&gt;stream.cbc = (cbc128_f) bsaes_cbc_encrypt;
         } else
-# endif
-# ifdef VPAES_CAPABLE
+#endif
+#ifdef VPAES_CAPABLE
         if (VPAES_CAPABLE) {
             ret = vpaes_set_decrypt_key(key,
                                         EVP_CIPHER_CTX_key_length(ctx) * 8,
@@ -1092,7 +1091,7 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
             dat-&gt;stream.cbc = mode == EVP_CIPH_CBC_MODE ?
                 (cbc128_f) vpaes_cbc_encrypt : NULL;
         } else
-# endif
+#endif
         {
             ret = AES_set_decrypt_key(key,
                                       EVP_CIPHER_CTX_key_length(ctx) * 8,
@@ -1101,34 +1100,34 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
             dat-&gt;stream.cbc = mode == EVP_CIPH_CBC_MODE ?
                 (cbc128_f) AES_cbc_encrypt : NULL;
     } else
-# ifdef HWAES_CAPABLE
+#ifdef HWAES_CAPABLE
     if (HWAES_CAPABLE) {
         ret = HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                     &amp;dat-&gt;ks.ks);
         dat-&gt;block = (block128_f) HWAES_encrypt;
         dat-&gt;stream.cbc = NULL;
-#  ifdef HWAES_cbc_encrypt
+# ifdef HWAES_cbc_encrypt
         if (mode == EVP_CIPH_CBC_MODE)
             dat-&gt;stream.cbc = (cbc128_f) HWAES_cbc_encrypt;
         else
-#  endif
-#  ifdef HWAES_ctr32_encrypt_blocks
+# endif
+# ifdef HWAES_ctr32_encrypt_blocks
         if (mode == EVP_CIPH_CTR_MODE)
             dat-&gt;stream.ctr = (ctr128_f) HWAES_ctr32_encrypt_blocks;
         else
-#  endif
+# endif
             (void)0;            /* terminate potentially open 'else' */
     } else
-# endif
-# ifdef BSAES_CAPABLE
+#endif
+#ifdef BSAES_CAPABLE
     if (BSAES_CAPABLE &amp;&amp; mode == EVP_CIPH_CTR_MODE) {
         ret = AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                   &amp;dat-&gt;ks.ks);
         dat-&gt;block = (block128_f) AES_encrypt;
         dat-&gt;stream.ctr = (ctr128_f) bsaes_ctr32_encrypt_blocks;
     } else
-# endif
-# ifdef VPAES_CAPABLE
+#endif
+#ifdef VPAES_CAPABLE
     if (VPAES_CAPABLE) {
         ret = vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                     &amp;dat-&gt;ks.ks);
@@ -1136,17 +1135,17 @@ static int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         dat-&gt;stream.cbc = mode == EVP_CIPH_CBC_MODE ?
             (cbc128_f) vpaes_cbc_encrypt : NULL;
     } else
-# endif
+#endif
     {
         ret = AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                   &amp;dat-&gt;ks.ks);
         dat-&gt;block = (block128_f) AES_encrypt;
         dat-&gt;stream.cbc = mode == EVP_CIPH_CBC_MODE ?
             (cbc128_f) AES_cbc_encrypt : NULL;
-# ifdef AES_CTR_ASM
+#ifdef AES_CTR_ASM
         if (mode == EVP_CIPH_CTR_MODE)
             dat-&gt;stream.ctr = (ctr128_f) AES_ctr32_encrypt;
-# endif
+#endif
     }
 
     if (ret &lt; 0) {
@@ -1454,21 +1453,21 @@ static int aes_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         return 1;
     if (key) {
         do {
-# ifdef HWAES_CAPABLE
+#ifdef HWAES_CAPABLE
             if (HWAES_CAPABLE) {
                 HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                       &amp;gctx-&gt;ks.ks);
                 CRYPTO_gcm128_init(&amp;gctx-&gt;gcm, &amp;gctx-&gt;ks,
                                    (block128_f) HWAES_encrypt);
-#  ifdef HWAES_ctr32_encrypt_blocks
+# ifdef HWAES_ctr32_encrypt_blocks
                 gctx-&gt;ctr = (ctr128_f) HWAES_ctr32_encrypt_blocks;
-#  else
+# else
                 gctx-&gt;ctr = NULL;
-#  endif
+# endif
                 break;
             } else
-# endif
-# ifdef BSAES_CAPABLE
+#endif
+#ifdef BSAES_CAPABLE
             if (BSAES_CAPABLE) {
                 AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                     &amp;gctx-&gt;ks.ks);
@@ -1477,8 +1476,8 @@ static int aes_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                 gctx-&gt;ctr = (ctr128_f) bsaes_ctr32_encrypt_blocks;
                 break;
             } else
-# endif
-# ifdef VPAES_CAPABLE
+#endif
+#ifdef VPAES_CAPABLE
             if (VPAES_CAPABLE) {
                 vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                       &amp;gctx-&gt;ks.ks);
@@ -1487,18 +1486,18 @@ static int aes_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                 gctx-&gt;ctr = NULL;
                 break;
             } else
-# endif
+#endif
                 (void)0;        /* terminate potentially open 'else' */
 
             AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                 &amp;gctx-&gt;ks.ks);
             CRYPTO_gcm128_init(&amp;gctx-&gt;gcm, &amp;gctx-&gt;ks,
                                (block128_f) AES_encrypt);
-# ifdef AES_CTR_ASM
+#ifdef AES_CTR_ASM
             gctx-&gt;ctr = (ctr128_f) AES_ctr32_encrypt;
-# else
+#else
             gctx-&gt;ctr = NULL;
-# endif
+#endif
         } while (0);
 
         /*
@@ -1559,7 +1558,7 @@ static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         /* Encrypt payload */
         if (gctx-&gt;ctr) {
             size_t bulk = 0;
-# if defined(AES_GCM_ASM)
+#if defined(AES_GCM_ASM)
             if (len &gt;= 32 &amp;&amp; AES_GCM_ASM(gctx)) {
                 if (CRYPTO_gcm128_encrypt(&amp;gctx-&gt;gcm, NULL, NULL, 0))
                     return -1;
@@ -1569,7 +1568,7 @@ static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                        gctx-&gt;gcm.Yi.c, gctx-&gt;gcm.Xi.u);
                 gctx-&gt;gcm.len.u[1] += bulk;
             }
-# endif
+#endif
             if (CRYPTO_gcm128_encrypt_ctr32(&amp;gctx-&gt;gcm,
                                             in + bulk,
                                             out + bulk,
@@ -1577,7 +1576,7 @@ static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                 goto err;
         } else {
             size_t bulk = 0;
-# if defined(AES_GCM_ASM2)
+#if defined(AES_GCM_ASM2)
             if (len &gt;= 32 &amp;&amp; AES_GCM_ASM2(gctx)) {
                 if (CRYPTO_gcm128_encrypt(&amp;gctx-&gt;gcm, NULL, NULL, 0))
                     return -1;
@@ -1587,7 +1586,7 @@ static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                        gctx-&gt;gcm.Yi.c, gctx-&gt;gcm.Xi.u);
                 gctx-&gt;gcm.len.u[1] += bulk;
             }
-# endif
+#endif
             if (CRYPTO_gcm128_encrypt(&amp;gctx-&gt;gcm,
                                       in + bulk, out + bulk, len - bulk))
                 goto err;
@@ -1600,7 +1599,7 @@ static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         /* Decrypt */
         if (gctx-&gt;ctr) {
             size_t bulk = 0;
-# if defined(AES_GCM_ASM)
+#if defined(AES_GCM_ASM)
             if (len &gt;= 16 &amp;&amp; AES_GCM_ASM(gctx)) {
                 if (CRYPTO_gcm128_decrypt(&amp;gctx-&gt;gcm, NULL, NULL, 0))
                     return -1;
@@ -1610,7 +1609,7 @@ static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                        gctx-&gt;gcm.Yi.c, gctx-&gt;gcm.Xi.u);
                 gctx-&gt;gcm.len.u[1] += bulk;
             }
-# endif
+#endif
             if (CRYPTO_gcm128_decrypt_ctr32(&amp;gctx-&gt;gcm,
                                             in + bulk,
                                             out + bulk,
@@ -1618,7 +1617,7 @@ static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                 goto err;
         } else {
             size_t bulk = 0;
-# if defined(AES_GCM_ASM2)
+#if defined(AES_GCM_ASM2)
             if (len &gt;= 16 &amp;&amp; AES_GCM_ASM2(gctx)) {
                 if (CRYPTO_gcm128_decrypt(&amp;gctx-&gt;gcm, NULL, NULL, 0))
                     return -1;
@@ -1628,7 +1627,7 @@ static int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                        gctx-&gt;gcm.Yi.c, gctx-&gt;gcm.Xi.u);
                 gctx-&gt;gcm.len.u[1] += bulk;
             }
-# endif
+#endif
             if (CRYPTO_gcm128_decrypt(&amp;gctx-&gt;gcm,
                                       in + bulk, out + bulk, len - bulk))
                 goto err;
@@ -1671,7 +1670,7 @@ static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         } else if (EVP_CIPHER_CTX_encrypting(ctx)) {
             if (gctx-&gt;ctr) {
                 size_t bulk = 0;
-# if defined(AES_GCM_ASM)
+#if defined(AES_GCM_ASM)
                 if (len &gt;= 32 &amp;&amp; AES_GCM_ASM(gctx)) {
                     size_t res = (16 - gctx-&gt;gcm.mres) % 16;
 
@@ -1685,7 +1684,7 @@ static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                     gctx-&gt;gcm.len.u[1] += bulk;
                     bulk += res;
                 }
-# endif
+#endif
                 if (CRYPTO_gcm128_encrypt_ctr32(&amp;gctx-&gt;gcm,
                                                 in + bulk,
                                                 out + bulk,
@@ -1693,7 +1692,7 @@ static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                     return -1;
             } else {
                 size_t bulk = 0;
-# if defined(AES_GCM_ASM2)
+#if defined(AES_GCM_ASM2)
                 if (len &gt;= 32 &amp;&amp; AES_GCM_ASM2(gctx)) {
                     size_t res = (16 - gctx-&gt;gcm.mres) % 16;
 
@@ -1707,7 +1706,7 @@ static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                     gctx-&gt;gcm.len.u[1] += bulk;
                     bulk += res;
                 }
-# endif
+#endif
                 if (CRYPTO_gcm128_encrypt(&amp;gctx-&gt;gcm,
                                           in + bulk, out + bulk, len - bulk))
                     return -1;
@@ -1715,7 +1714,7 @@ static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         } else {
             if (gctx-&gt;ctr) {
                 size_t bulk = 0;
-# if defined(AES_GCM_ASM)
+#if defined(AES_GCM_ASM)
                 if (len &gt;= 16 &amp;&amp; AES_GCM_ASM(gctx)) {
                     size_t res = (16 - gctx-&gt;gcm.mres) % 16;
 
@@ -1729,7 +1728,7 @@ static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                     gctx-&gt;gcm.len.u[1] += bulk;
                     bulk += res;
                 }
-# endif
+#endif
                 if (CRYPTO_gcm128_decrypt_ctr32(&amp;gctx-&gt;gcm,
                                                 in + bulk,
                                                 out + bulk,
@@ -1737,7 +1736,7 @@ static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                     return -1;
             } else {
                 size_t bulk = 0;
-# if defined(AES_GCM_ASM2)
+#if defined(AES_GCM_ASM2)
                 if (len &gt;= 16 &amp;&amp; AES_GCM_ASM2(gctx)) {
                     size_t res = (16 - gctx-&gt;gcm.mres) % 16;
 
@@ -1751,7 +1750,7 @@ static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                     gctx-&gt;gcm.len.u[1] += bulk;
                     bulk += res;
                 }
-# endif
+#endif
                 if (CRYPTO_gcm128_decrypt(&amp;gctx-&gt;gcm,
                                           in + bulk, out + bulk, len - bulk))
                     return -1;
@@ -1778,7 +1777,7 @@ static int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 
 }
 
-# define CUSTOM_FLAGS    (EVP_CIPH_FLAG_DEFAULT_ASN1 \
+#define CUSTOM_FLAGS    (EVP_CIPH_FLAG_DEFAULT_ASN1 \
                 | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \
                 | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \
                 | EVP_CIPH_CUSTOM_COPY)
@@ -1824,13 +1823,13 @@ static int aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
 
     if (key)
         do {
-# ifdef AES_XTS_ASM
+#ifdef AES_XTS_ASM
             xctx-&gt;stream = enc ? AES_xts_encrypt : AES_xts_decrypt;
-# else
+#else
             xctx-&gt;stream = NULL;
-# endif
+#endif
             /* key_len is two AES keys */
-# ifdef HWAES_CAPABLE
+#ifdef HWAES_CAPABLE
             if (HWAES_CAPABLE) {
                 if (enc) {
                     HWAES_set_encrypt_key(key,
@@ -1852,13 +1851,13 @@ static int aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                 xctx-&gt;xts.key1 = &amp;xctx-&gt;ks1;
                 break;
             } else
-# endif
-# ifdef BSAES_CAPABLE
+#endif
+#ifdef BSAES_CAPABLE
             if (BSAES_CAPABLE)
                 xctx-&gt;stream = enc ? bsaes_xts_encrypt : bsaes_xts_decrypt;
             else
-# endif
-# ifdef VPAES_CAPABLE
+#endif
+#ifdef VPAES_CAPABLE
             if (VPAES_CAPABLE) {
                 if (enc) {
                     vpaes_set_encrypt_key(key,
@@ -1880,7 +1879,7 @@ static int aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                 xctx-&gt;xts.key1 = &amp;xctx-&gt;ks1;
                 break;
             } else
-# endif
+#endif
                 (void)0;        /* terminate potentially open 'else' */
 
             if (enc) {
@@ -1928,9 +1927,9 @@ static int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     return 1;
 }
 
-# define aes_xts_cleanup NULL
+#define aes_xts_cleanup NULL
 
-# define XTS_FLAGS       (EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \
+#define XTS_FLAGS       (EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CUSTOM_IV \
                          | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_CTRL_INIT \
                          | EVP_CIPH_CUSTOM_COPY)
 
@@ -2036,7 +2035,7 @@ static int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
         return 1;
     if (key)
         do {
-# ifdef HWAES_CAPABLE
+#ifdef HWAES_CAPABLE
             if (HWAES_CAPABLE) {
                 HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                       &amp;cctx-&gt;ks.ks);
@@ -2047,8 +2046,8 @@ static int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                 cctx-&gt;key_set = 1;
                 break;
             } else
-# endif
-# ifdef VPAES_CAPABLE
+#endif
+#ifdef VPAES_CAPABLE
             if (VPAES_CAPABLE) {
                 vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                       &amp;cctx-&gt;ks.ks);
@@ -2058,7 +2057,7 @@ static int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                 cctx-&gt;key_set = 1;
                 break;
             }
-# endif
+#endif
             AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                 &amp;cctx-&gt;ks.ks);
             CRYPTO_ccm128_init(&amp;cctx-&gt;ccm, cctx-&gt;M, cctx-&gt;L,
@@ -2190,7 +2189,7 @@ static int aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     }
 }
 
-# define aes_ccm_cleanup NULL
+#define aes_ccm_cleanup NULL
 
 BLOCK_CIPHER_custom(NID_aes, 128, 1, 12, ccm, CCM,
                     EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS)
@@ -2286,7 +2285,7 @@ static int aes_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     return rv ? (int)rv : -1;
 }
 
-# define WRAP_FLAGS      (EVP_CIPH_WRAP_MODE \
+#define WRAP_FLAGS      (EVP_CIPH_WRAP_MODE \
                 | EVP_CIPH_CUSTOM_IV | EVP_CIPH_FLAG_CUSTOM_CIPHER \
                 | EVP_CIPH_ALWAYS_CALL_INIT | EVP_CIPH_FLAG_DEFAULT_ASN1)
 
@@ -2374,7 +2373,7 @@ const EVP_CIPHER *EVP_aes_256_wrap_pad(void)
     return &amp;aes_256_wrap_pad;
 }
 
-# ifndef OPENSSL_NO_OCB
+#ifndef OPENSSL_NO_OCB
 static int aes_ocb_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
 {
     EVP_AES_OCB_CTX *octx = EVP_C_DATA(EVP_AES_OCB_CTX,c);
@@ -2434,28 +2433,28 @@ static int aes_ocb_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
     }
 }
 
-#  ifdef HWAES_CAPABLE
-#   ifdef HWAES_ocb_encrypt
+# ifdef HWAES_CAPABLE
+#  ifdef HWAES_ocb_encrypt
 void HWAES_ocb_encrypt(const unsigned char *in, unsigned char *out,
                        size_t blocks, const void *key,
                        size_t start_block_num,
                        unsigned char offset_i[16],
                        const unsigned char L_[][16],
                        unsigned char checksum[16]);
-#   else
-#     define HWAES_ocb_encrypt NULL
-#   endif
-#   ifdef HWAES_ocb_decrypt
+#  else
+#    define HWAES_ocb_encrypt NULL
+#  endif
+#  ifdef HWAES_ocb_decrypt
 void HWAES_ocb_decrypt(const unsigned char *in, unsigned char *out,
                        size_t blocks, const void *key,
                        size_t start_block_num,
                        unsigned char offset_i[16],
                        const unsigned char L_[][16],
                        unsigned char checksum[16]);
-#   else
-#     define HWAES_ocb_decrypt NULL
-#   endif
+#  else
+#    define HWAES_ocb_decrypt NULL
 #  endif
+# endif
 
 static int aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                             const unsigned char *iv, int enc)
@@ -2470,7 +2469,7 @@ static int aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
              * needs both. We could possibly optimise to remove setting the
              * decrypt for an encryption operation.
              */
-#  ifdef HWAES_CAPABLE
+# ifdef HWAES_CAPABLE
             if (HWAES_CAPABLE) {
                 HWAES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                       &amp;octx-&gt;ksenc.ks);
@@ -2485,8 +2484,8 @@ static int aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                     return 0;
                 break;
             }
-#  endif
-#  ifdef VPAES_CAPABLE
+# endif
+# ifdef VPAES_CAPABLE
             if (VPAES_CAPABLE) {
                 vpaes_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                       &amp;octx-&gt;ksenc.ks);
@@ -2500,7 +2499,7 @@ static int aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                     return 0;
                 break;
             }
-#  endif
+# endif
             AES_set_encrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
                                 &amp;octx-&gt;ksenc.ks);
             AES_set_decrypt_key(key, EVP_CIPHER_CTX_key_length(ctx) * 8,
@@ -2690,5 +2689,4 @@ BLOCK_CIPHER_custom(NID_aes, 192, 16, 12, ocb, OCB,
                     EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS)
 BLOCK_CIPHER_custom(NID_aes, 256, 16, 12, ocb, OCB,
                     EVP_CIPH_FLAG_AEAD_CIPHER | CUSTOM_FLAGS)
-# endif                         /* OPENSSL_NO_OCB */
-#endif
+#endif                         /* OPENSSL_NO_OCB */
diff --git a/crypto/evp/e_aes_cbc_hmac_sha1.c b/crypto/evp/e_aes_cbc_hmac_sha1.c
index 6f95f4b..4d8c973 100644
--- a/crypto/evp/e_aes_cbc_hmac_sha1.c
+++ b/crypto/evp/e_aes_cbc_hmac_sha1.c
@@ -52,31 +52,29 @@
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 
-#if !defined(OPENSSL_NO_AES)
-
-# include &lt;openssl/evp.h&gt;
-# include &lt;openssl/objects.h&gt;
-# include &lt;openssl/aes.h&gt;
-# include &lt;openssl/sha.h&gt;
-# include &lt;openssl/rand.h&gt;
-# include &quot;modes_lcl.h&quot;
-# include &quot;internal/evp_int.h&quot;
-
-# ifndef EVP_CIPH_FLAG_AEAD_CIPHER
-#  define EVP_CIPH_FLAG_AEAD_CIPHER       0x200000
-#  define EVP_CTRL_AEAD_TLS1_AAD          0x16
-#  define EVP_CTRL_AEAD_SET_MAC_KEY       0x17
-# endif
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/objects.h&gt;
+#include &lt;openssl/aes.h&gt;
+#include &lt;openssl/sha.h&gt;
+#include &lt;openssl/rand.h&gt;
+#include &quot;modes_lcl.h&quot;
+#include &quot;internal/evp_int.h&quot;
+
+#ifndef EVP_CIPH_FLAG_AEAD_CIPHER
+# define EVP_CIPH_FLAG_AEAD_CIPHER       0x200000
+# define EVP_CTRL_AEAD_TLS1_AAD          0x16
+# define EVP_CTRL_AEAD_SET_MAC_KEY       0x17
+#endif
 
-# if !defined(EVP_CIPH_FLAG_DEFAULT_ASN1)
-#  define EVP_CIPH_FLAG_DEFAULT_ASN1 0
-# endif
+#if !defined(EVP_CIPH_FLAG_DEFAULT_ASN1)
+# define EVP_CIPH_FLAG_DEFAULT_ASN1 0
+#endif
 
-# if !defined(EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)
-#  define EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK 0
-# endif
+#if !defined(EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)
+# define EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK 0
+#endif
 
-# define TLS1_1_VERSION 0x0302
+#define TLS1_1_VERSION 0x0302
 
 typedef struct {
     AES_KEY ks;
@@ -88,15 +86,15 @@ typedef struct {
     } aux;
 } EVP_AES_HMAC_SHA1;
 
-# define NO_PAYLOAD_LENGTH       ((size_t)-1)
+#define NO_PAYLOAD_LENGTH       ((size_t)-1)
 
-# if     defined(AES_ASM) &amp;&amp;     ( \
+#if     defined(AES_ASM) &amp;&amp;     ( \
         defined(__x86_64)       || defined(__x86_64__)  || \
         defined(_M_AMD64)       || defined(_M_X64)      || \
         defined(__INTEL__)      )
 
 extern unsigned int OPENSSL_ia32cap_P[];
-#  define AESNI_CAPABLE   (1&lt;&lt;(57-32))
+# define AESNI_CAPABLE   (1&lt;&lt;(57-32))
 
 int aesni_set_encrypt_key(const unsigned char *userKey, int bits,
                           AES_KEY *key);
@@ -116,7 +114,7 @@ void aesni256_cbc_sha1_dec(const void *inp, void *out, size_t blocks,
                            const AES_KEY *key, unsigned char iv[16],
                            SHA_CTX *ctx, const void *in0);
 
-#  define data(ctx) ((EVP_AES_HMAC_SHA1 *)EVP_CIPHER_CTX_get_cipher_data(ctx))
+# define data(ctx) ((EVP_AES_HMAC_SHA1 *)EVP_CIPHER_CTX_get_cipher_data(ctx))
 
 static int aesni_cbc_hmac_sha1_init_key(EVP_CIPHER_CTX *ctx,
                                         const unsigned char *inkey,
@@ -143,12 +141,12 @@ static int aesni_cbc_hmac_sha1_init_key(EVP_CIPHER_CTX *ctx,
     return ret &lt; 0 ? 0 : 1;
 }
 
-#  define STITCHED_CALL
-#  undef  STITCHED_DECRYPT_CALL
+# define STITCHED_CALL
+# undef  STITCHED_DECRYPT_CALL
 
-#  if !defined(STITCHED_CALL)
-#   define aes_off 0
-#  endif
+# if !defined(STITCHED_CALL)
+#  define aes_off 0
+# endif
 
 void sha1_block_data_order(void *c, const void *p, size_t len);
 
@@ -183,12 +181,12 @@ static void sha1_update(SHA_CTX *c, const void *data, size_t len)
         SHA1_Update(c, ptr, res);
 }
 
-#  ifdef SHA1_Update
-#   undef SHA1_Update
-#  endif
-#  define SHA1_Update sha1_update
+# ifdef SHA1_Update
+#  undef SHA1_Update
+# endif
+# define SHA1_Update sha1_update
 
-#  if !defined(OPENSSL_NO_MULTIBLOCK) &amp;&amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
+# if !defined(OPENSSL_NO_MULTIBLOCK) &amp;&amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
 
 typedef struct {
     unsigned int A[8], B[8], C[8], D[8], E[8];
@@ -227,9 +225,9 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,
         0;
     size_t ret = 0;
     u8 *IVs;
-#   if defined(BSWAP8)
+#  if defined(BSWAP8)
     u64 seqnum;
-#   endif
+#  endif
 
     /* ask for IVs in bulk */
     if (RAND_bytes((IVs = blocks[0].c), 16 * x4) &lt;= 0)
@@ -263,15 +261,15 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,
         IVs += 16;
     }
 
-#   if defined(BSWAP8)
+#  if defined(BSWAP8)
     memcpy(blocks[0].c, key-&gt;md.data, 8);
     seqnum = BSWAP8(blocks[0].q[0]);
-#   endif
+#  endif
     for (i = 0; i &lt; x4; i++) {
         unsigned int len = (i == (x4 - 1) ? last : frag);
-#   if !defined(BSWAP8)
+#  if !defined(BSWAP8)
         unsigned int carry, j;
-#   endif
+#  endif
 
         ctx-&gt;A[i] = key-&gt;md.h0;
         ctx-&gt;B[i] = key-&gt;md.h1;
@@ -280,14 +278,14 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,
         ctx-&gt;E[i] = key-&gt;md.h4;
 
         /* fix seqnum */
-#   if defined(BSWAP8)
+#  if defined(BSWAP8)
         blocks[i].q[0] = BSWAP8(seqnum + i);
-#   else
+#  else
         for (carry = i, j = 8; j--;) {
             blocks[i].c[j] = ((u8 *)key-&gt;md.data)[j] + carry;
             carry = (blocks[i].c[j] - carry) &gt;&gt; (sizeof(carry) * 8 - 1);
         }
-#   endif
+#  endif
         blocks[i].c[8] = ((u8 *)key-&gt;md.data)[8];
         blocks[i].c[9] = ((u8 *)key-&gt;md.data)[9];
         blocks[i].c[10] = ((u8 *)key-&gt;md.data)[10];
@@ -306,10 +304,10 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,
     /* hash 13-byte headers and first 64-13 bytes of inputs */
     sha1_multi_block(ctx, edges, n4x);
     /* hash bulk inputs */
-#   define MAXCHUNKSIZE    2048
-#   if     MAXCHUNKSIZE%64
-#    error  &quot;MAXCHUNKSIZE is not divisible by 64&quot;
-#   elif   MAXCHUNKSIZE
+#  define MAXCHUNKSIZE    2048
+#  if     MAXCHUNKSIZE%64
+#   error  &quot;MAXCHUNKSIZE is not divisible by 64&quot;
+#  elif   MAXCHUNKSIZE
     /*
      * goal is to minimize pressure on L1 cache by moving in shorter steps,
      * so that hashed data is still in the cache by the time we encrypt it
@@ -338,8 +336,8 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,
             minblocks -= MAXCHUNKSIZE / 64;
         } while (minblocks &gt; MAXCHUNKSIZE / 64);
     }
-#   endif
-#   undef  MAXCHUNKSIZE
+#  endif
+#  undef  MAXCHUNKSIZE
     sha1_multi_block(ctx, hash_d, n4x);
 
     memset(blocks, 0, sizeof(blocks));
@@ -354,18 +352,18 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,
         len += 64 + 13;         /* 64 is HMAC header */
         len *= 8;               /* convert to bits */
         if (off &lt; (64 - 8)) {
-#   ifdef BSWAP4
+#  ifdef BSWAP4
             blocks[i].d[15] = BSWAP4(len);
-#   else
+#  else
             PUTU32(blocks[i].c + 60, len);
-#   endif
+#  endif
             edges[i].blocks = 1;
         } else {
-#   ifdef BSWAP4
+#  ifdef BSWAP4
             blocks[i].d[31] = BSWAP4(len);
-#   else
+#  else
             PUTU32(blocks[i].c + 124, len);
-#   endif
+#  endif
             edges[i].blocks = 2;
         }
         edges[i].ptr = blocks[i].c;
@@ -376,7 +374,7 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,
 
     memset(blocks, 0, sizeof(blocks));
     for (i = 0; i &lt; x4; i++) {
-#   ifdef BSWAP4
+#  ifdef BSWAP4
         blocks[i].d[0] = BSWAP4(ctx-&gt;A[i]);
         ctx-&gt;A[i] = key-&gt;tail.h0;
         blocks[i].d[1] = BSWAP4(ctx-&gt;B[i]);
@@ -389,7 +387,7 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,
         ctx-&gt;E[i] = key-&gt;tail.h4;
         blocks[i].c[20] = 0x80;
         blocks[i].d[15] = BSWAP4((64 + 20) * 8);
-#   else
+#  else
         PUTU32(blocks[i].c + 0, ctx-&gt;A[i]);
         ctx-&gt;A[i] = key-&gt;tail.h0;
         PUTU32(blocks[i].c + 4, ctx-&gt;B[i]);
@@ -402,7 +400,7 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,
         ctx-&gt;E[i] = key-&gt;tail.h4;
         blocks[i].c[20] = 0x80;
         PUTU32(blocks[i].c + 60, (64 + 20) * 8);
-#   endif
+#  endif
         edges[i].ptr = blocks[i].c;
         edges[i].blocks = 1;
     }
@@ -455,7 +453,7 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,
 
     return ret;
 }
-#  endif
+# endif
 
 static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                       const unsigned char *in, size_t len)
@@ -465,11 +463,11 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
     size_t plen = key-&gt;payload_length, iv = 0, /* explicit IV in TLS 1.1 and
                                                 * later */
         sha_off = 0;
-#  if defined(STITCHED_CALL)
+# if defined(STITCHED_CALL)
     size_t aes_off = 0, blocks;
 
     sha_off = SHA_CBLOCK - key-&gt;md.num;
-#  endif
+# endif
 
     key-&gt;payload_length = NO_PAYLOAD_LENGTH;
 
@@ -486,7 +484,7 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         else if (key-&gt;aux.tls_ver &gt;= TLS1_1_VERSION)
             iv = AES_BLOCK_SIZE;
 
-#  if defined(STITCHED_CALL)
+# if defined(STITCHED_CALL)
         if (plen &gt; (sha_off + iv)
             &amp;&amp; (blocks = (plen - (sha_off + iv)) / SHA_CBLOCK)) {
             SHA1_Update(&amp;key-&gt;md, in + iv, sha_off);
@@ -504,7 +502,7 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
         } else {
             sha_off = 0;
         }
-#  endif
+# endif
         sha_off += iv;
         SHA1_Update(&amp;key-&gt;md, in + sha_off, plen - sha_off);
 
@@ -546,10 +544,10 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                 unsigned int u[SHA_LBLOCK];
                 unsigned char c[SHA_CBLOCK];
             } *data = (void *)key-&gt;md.data;
-#  if defined(STITCHED_DECRYPT_CALL)
+# if defined(STITCHED_DECRYPT_CALL)
             unsigned char tail_iv[AES_BLOCK_SIZE];
             int stitch = 0;
-#  endif
+# endif
 
             if ((key-&gt;aux.tls_aad[plen - 4] &lt;&lt; 8 | key-&gt;aux.tls_aad[plen - 3])
                 &gt;= TLS1_1_VERSION) {
@@ -565,7 +563,7 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             } else if (len &lt; (SHA_DIGEST_LENGTH + 1))
                 return 0;
 
-#  if defined(STITCHED_DECRYPT_CALL)
+# if defined(STITCHED_DECRYPT_CALL)
             if (len &gt;= 1024 &amp;&amp; ctx-&gt;key_len == 32) {
                 /* decrypt last block */
                 memcpy(tail_iv, in + len - 2 * AES_BLOCK_SIZE,
@@ -575,7 +573,7 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                                   &amp;key-&gt;ks, tail_iv, 0);
                 stitch = 1;
             } else
-#  endif
+# endif
                 /* decrypt HMAC|padding at once */
                 aesni_cbc_encrypt(in, out, len, &amp;key-&gt;ks,
                                   EVP_CIPHER_CTX_iv_noconst(ctx), 0);
@@ -598,7 +596,7 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             key-&gt;md = key-&gt;head;
             SHA1_Update(&amp;key-&gt;md, key-&gt;aux.tls_aad, plen);
 
-#  if defined(STITCHED_DECRYPT_CALL)
+# if defined(STITCHED_DECRYPT_CALL)
             if (stitch) {
                 blocks = (len - (256 + 32 + SHA_CBLOCK)) / SHA_CBLOCK;
                 aes_off = len - AES_BLOCK_SIZE - blocks * SHA_CBLOCK;
@@ -619,9 +617,9 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                 key-&gt;md.Nl += (blocks &lt;&lt; 3); /* at most 18 bits */
                 memcpy(ctx-&gt;iv, tail_iv, AES_BLOCK_SIZE);
             }
-#  endif
+# endif
 
-#  if 1
+# if 1
             len -= SHA_DIGEST_LENGTH; /* amend mac */
             if (len &gt;= (256 + SHA_CBLOCK)) {
                 j = (len - (256 + SHA_CBLOCK)) &amp; (0 - SHA_CBLOCK);
@@ -634,15 +632,15 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 
             /* but pretend as if we hashed padded payload */
             bitlen = key-&gt;md.Nl + (inp_len &lt;&lt; 3); /* at most 18 bits */
-#   ifdef BSWAP4
+#  ifdef BSWAP4
             bitlen = BSWAP4(bitlen);
-#   else
+#  else
             mac.c[0] = 0;
             mac.c[1] = (unsigned char)(bitlen &gt;&gt; 16);
             mac.c[2] = (unsigned char)(bitlen &gt;&gt; 8);
             mac.c[3] = (unsigned char)bitlen;
             bitlen = mac.u[0];
-#   endif
+#  endif
 
             pmac-&gt;u[0] = 0;
             pmac-&gt;u[1] = 0;
@@ -699,13 +697,13 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             pmac-&gt;u[3] |= key-&gt;md.h3 &amp; mask;
             pmac-&gt;u[4] |= key-&gt;md.h4 &amp; mask;
 
-#   ifdef BSWAP4
+#  ifdef BSWAP4
             pmac-&gt;u[0] = BSWAP4(pmac-&gt;u[0]);
             pmac-&gt;u[1] = BSWAP4(pmac-&gt;u[1]);
             pmac-&gt;u[2] = BSWAP4(pmac-&gt;u[2]);
             pmac-&gt;u[3] = BSWAP4(pmac-&gt;u[3]);
             pmac-&gt;u[4] = BSWAP4(pmac-&gt;u[4]);
-#   else
+#  else
             for (i = 0; i &lt; 5; i++) {
                 res = pmac-&gt;u[i];
                 pmac-&gt;c[4 * i + 0] = (unsigned char)(res &gt;&gt; 24);
@@ -713,9 +711,9 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                 pmac-&gt;c[4 * i + 2] = (unsigned char)(res &gt;&gt; 8);
                 pmac-&gt;c[4 * i + 3] = (unsigned char)res;
             }
-#   endif
+#  endif
             len += SHA_DIGEST_LENGTH;
-#  else
+# else
             SHA1_Update(&amp;key-&gt;md, out, inp_len);
             res = key-&gt;md.num;
             SHA1_Final(pmac-&gt;c, &amp;key-&gt;md);
@@ -734,7 +732,7 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                 for (; inp_blocks &lt; pad_blocks; inp_blocks++)
                     sha1_block_data_order(&amp;key-&gt;md, data, 1);
             }
-#  endif
+# endif
             key-&gt;md = key-&gt;tail;
             SHA1_Update(&amp;key-&gt;md, pmac-&gt;c, SHA_DIGEST_LENGTH);
             SHA1_Final(pmac-&gt;c, &amp;key-&gt;md);
@@ -742,7 +740,7 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
             /* verify HMAC */
             out += inp_len;
             len -= inp_len;
-#  if 1
+# if 1
             {
                 unsigned char *p = out + len - 1 - maxpad - SHA_DIGEST_LENGTH;
                 size_t off = out - p;
@@ -764,7 +762,7 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                 res = 0 - ((0 - res) &gt;&gt; (sizeof(res) * 8 - 1));
                 ret &amp;= (int)~res;
             }
-#  else
+# else
             for (res = 0, i = 0; i &lt; SHA_DIGEST_LENGTH; i++)
                 res |= out[i] ^ pmac-&gt;c[i];
             res = 0 - ((0 - res) &gt;&gt; (sizeof(res) * 8 - 1));
@@ -778,10 +776,10 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
 
             res = (0 - res) &gt;&gt; (sizeof(res) * 8 - 1);
             ret &amp;= (int)~res;
-#  endif
+# endif
             return ret;
         } else {
-#  if defined(STITCHED_DECRYPT_CALL)
+# if defined(STITCHED_DECRYPT_CALL)
             if (len &gt;= 1024 &amp;&amp; ctx-&gt;key_len == 32) {
                 if (sha_off %= SHA_CBLOCK)
                     blocks = (len - 3 * SHA_CBLOCK) / SHA_CBLOCK;
@@ -804,7 +802,7 @@ static int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                 if (key-&gt;md.Nl &lt; (unsigned int)blocks)
                     key-&gt;md.Nh++;
             } else
-#  endif
+# endif
                 /* decrypt HMAC|padding at once */
                 aesni_cbc_encrypt(in, out, len, &amp;key-&gt;ks,
                                   EVP_CIPHER_CTX_iv_noconst(ctx), 0);
@@ -882,7 +880,7 @@ static int aesni_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
                 return SHA_DIGEST_LENGTH;
             }
         }
-#  if !defined(OPENSSL_NO_MULTIBLOCK) &amp;&amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
+# if !defined(OPENSSL_NO_MULTIBLOCK) &amp;&amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
     case EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE:
         return (int)(5 + 16 + ((arg + 20 + 16) &amp; -16));
     case EVP_CTRL_TLS1_1_MULTIBLOCK_AAD:
@@ -945,18 +943,18 @@ static int aesni_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
                                                    param-&gt;interleave / 4);
         }
     case EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT:
-#  endif
+# endif
     default:
         return -1;
     }
 }
 
 static EVP_CIPHER aesni_128_cbc_hmac_sha1_cipher = {
-#  ifdef NID_aes_128_cbc_hmac_sha1
+# ifdef NID_aes_128_cbc_hmac_sha1
     NID_aes_128_cbc_hmac_sha1,
-#  else
+# else
     NID_undef,
-#  endif
+# endif
     AES_BLOCK_SIZE, 16, AES_BLOCK_SIZE,
     EVP_CIPH_CBC_MODE | EVP_CIPH_FLAG_DEFAULT_ASN1 |
         EVP_CIPH_FLAG_AEAD_CIPHER | EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK,
@@ -971,11 +969,11 @@ static EVP_CIPHER aesni_128_cbc_hmac_sha1_cipher = {
 };
 
 static EVP_CIPHER aesni_256_cbc_hmac_sha1_cipher = {
-#  ifdef NID_aes_256_cbc_hmac_sha1
+# ifdef NID_aes_256_cbc_hmac_sha1
     NID_aes_256_cbc_hmac_sha1,
-#  else
+# else
     NID_undef,
-#  endif
+# endif
     AES_BLOCK_SIZE, 32, AES_BLOCK_SIZE,
     EVP_CIPH_CBC_MODE | EVP_CIPH_FLAG_DEFAULT_ASN1 |
         EVP_CIPH_FLAG_AEAD_CIPHER | EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK,
@@ -1000,7 +998,7 @@ const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void)
     return (OPENSSL_ia32cap_P[1] &amp; AESNI_CAPABLE ?
             &amp;aesni_256_cbc_hmac_sha1_cipher : NULL);
 }
-# else
+#else
 const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void)
 {
     return NULL;
@@ -1010,5 +1008,4 @@ const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void)
 {
     return NULL;
 }
-# endif
 #endif
diff --git a/crypto/evp/e_aes_cbc_hmac_sha256.c b/crypto/evp/e_aes_cbc_hmac_sha256.c
index 66f536c..075a8e8 100644
--- a/crypto/evp/e_aes_cbc_hmac_sha256.c
+++ b/crypto/evp/e_aes_cbc_hmac_sha256.c
@@ -52,31 +52,30 @@
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 
-#if !defined(OPENSSL_NO_AES)
-
-# include &lt;openssl/evp.h&gt;
-# include &lt;openssl/objects.h&gt;
-# include &lt;openssl/aes.h&gt;
-# include &lt;openssl/sha.h&gt;
-# include &lt;openssl/rand.h&gt;
-# include &quot;modes_lcl.h&quot;
-# include &quot;internal/evp_int.h&quot;
-
-# ifndef EVP_CIPH_FLAG_AEAD_CIPHER
-#  define EVP_CIPH_FLAG_AEAD_CIPHER       0x200000
-#  define EVP_CTRL_AEAD_TLS1_AAD          0x16
-#  define EVP_CTRL_AEAD_SET_MAC_KEY       0x17
-# endif
 
-# if !defined(EVP_CIPH_FLAG_DEFAULT_ASN1)
-#  define EVP_CIPH_FLAG_DEFAULT_ASN1 0
-# endif
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/objects.h&gt;
+#include &lt;openssl/aes.h&gt;
+#include &lt;openssl/sha.h&gt;
+#include &lt;openssl/rand.h&gt;
+#include &quot;modes_lcl.h&quot;
+#include &quot;internal/evp_int.h&quot;
+
+#ifndef EVP_CIPH_FLAG_AEAD_CIPHER
+# define EVP_CIPH_FLAG_AEAD_CIPHER       0x200000
+# define EVP_CTRL_AEAD_TLS1_AAD          0x16
+# define EVP_CTRL_AEAD_SET_MAC_KEY       0x17
+#endif
 
-# if !defined(EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)
-#  define EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK 0
-# endif
+#if !defined(EVP_CIPH_FLAG_DEFAULT_ASN1)
+# define EVP_CIPH_FLAG_DEFAULT_ASN1 0
+#endif
+
+#if !defined(EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)
+# define EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK 0
+#endif
 
-# define TLS1_1_VERSION 0x0302
+#define TLS1_1_VERSION 0x0302
 
 typedef struct {
     AES_KEY ks;
@@ -90,13 +89,13 @@ typedef struct {
 
 # define NO_PAYLOAD_LENGTH       ((size_t)-1)
 
-# if     defined(AES_ASM) &amp;&amp;     ( \
+#if     defined(AES_ASM) &amp;&amp;     ( \
         defined(__x86_64)       || defined(__x86_64__)  || \
         defined(_M_AMD64)       || defined(_M_X64)      || \
         defined(__INTEL__)      )
 
 extern unsigned int OPENSSL_ia32cap_P[];
-#  define AESNI_CAPABLE   (1&lt;&lt;(57-32))
+# define AESNI_CAPABLE   (1&lt;&lt;(57-32))
 
 int aesni_set_encrypt_key(const unsigned char *userKey, int bits,
                           AES_KEY *key);
@@ -112,7 +111,7 @@ int aesni_cbc_sha256_enc(const void *inp, void *out, size_t blocks,
                          const AES_KEY *key, unsigned char iv[16],
                          SHA256_CTX *ctx, const void *in0);
 
-#  define data(ctx) ((EVP_AES_HMAC_SHA256 *)EVP_CIPHER_CTX_get_cipher_data(ctx))
+# define data(ctx) ((EVP_AES_HMAC_SHA256 *)EVP_CIPHER_CTX_get_cipher_data(ctx))
 
 static int aesni_cbc_hmac_sha256_init_key(EVP_CIPHER_CTX *ctx,
                                           const unsigned char *inkey,
@@ -140,11 +139,11 @@ static int aesni_cbc_hmac_sha256_init_key(EVP_CIPHER_CTX *ctx,
     return ret &lt; 0 ? 0 : 1;
 }
 
-#  define STITCHED_CALL
+# define STITCHED_CALL
 
-#  if !defined(STITCHED_CALL)
-#   define aes_off 0
-#  endif
+# if !defined(STITCHED_CALL)
+#  define aes_off 0
+# endif
 
 void sha256_block_data_order(void *c, const void *p, size_t len);
 
@@ -179,12 +178,12 @@ static void sha256_update(SHA256_CTX *c, const void *data, size_t len)
         SHA256_Update(c, ptr, res);
 }
 
-#  ifdef SHA256_Update
-#   undef SHA256_Update
-#  endif
-#  define SHA256_Update sha256_update
+# ifdef SHA256_Update
+#  undef SHA256_Update
+# endif
+# define SHA256_Update sha256_update
 
-#  if !defined(OPENSSL_NO_MULTIBLOCK) &amp;&amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
+# if !defined(OPENSSL_NO_MULTIBLOCK) &amp;&amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
 
 typedef struct {
     unsigned int A[8], B[8], C[8], D[8], E[8], F[8], G[8], H[8];
@@ -223,9 +222,9 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,
         0;
     size_t ret = 0;
     u8 *IVs;
-#   if defined(BSWAP8)
+#  if defined(BSWAP8)
     u64 seqnum;
-#   endif
+#  endif
 
     /* ask for IVs in bulk */
     if (RAND_bytes((IVs = blocks[0].c), 16 * x4) &lt;= 0)
@@ -260,15 +259,15 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,
         IVs += 16;
     }
 
-#   if defined(BSWAP8)
+#  if defined(BSWAP8)
     memcpy(blocks[0].c, key-&gt;md.data, 8);
     seqnum = BSWAP8(blocks[0].q[0]);
-#   endif
+#  endif
     for (i = 0; i &lt; x4; i++) {
         unsigned int len = (i == (x4 - 1) ? last : frag);
-#   if !defined(BSWAP8)
+#  if !defined(BSWAP8)
         unsigned int carry, j;
-#   endif
+#  endif
 
         ctx-&gt;A[i] = key-&gt;md.h[0];
         ctx-&gt;B[i] = key-&gt;md.h[1];
@@ -280,14 +279,14 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,
         ctx-&gt;H[i] = key-&gt;md.h[7];
 
         /* fix seqnum */
-#   if defined(BSWAP8)
+#  if defined(BSWAP8)
         blocks[i].q[0] = BSWAP8(seqnum + i);
-#   else
+#  else
         for (carry = i, j = 8; j--;) {
             blocks[i].c[j] = ((u8 *)key-&gt;md.data)[j] + carry;
             carry = (blocks[i].c[j] - carry) &gt;&gt; (sizeof(carry) * 8 - 1);
         }
-#   endif
+#  endif
         blocks[i].c[8] = ((u8 *)key-&gt;md.data)[8];
         blocks[i].c[9] = ((u8 *)key-&gt;md.data)[9];
         blocks[i].c[10] = ((u8 *)key-&gt;md.data)[10];
@@ -306,10 +305,10 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,
     /* hash 13-byte headers and first 64-13 bytes of inputs */
     sha256_multi_block(ctx, edges, n4x);
     /* hash bulk inputs */
-#   define MAXCHUNKSIZE    2048
-#   if     MAXCHUNKSIZE%64
-#    error  &quot;MAXCHUNKSIZE is not divisible by 64&quot;
-#   elif   MAXCHUNKSIZE
+#  define MAXCHUNKSIZE    2048
+#  if     MAXCHUNKSIZE%64
+#   error  &quot;MAXCHUNKSIZE is not divisible by 64&quot;
+#  elif   MAXCHUNKSIZE
     /*
      * goal is to minimize pressure on L1 cache by moving in shorter steps,
      * so that hashed data is still in the cache by the time we encrypt it
@@ -338,8 +337,8 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,
             minblocks -= MAXCHUNKSIZE / 64;
         } while (minblocks &gt; MAXCHUNKSIZE / 64);
     }
-#   endif
-#   undef  MAXCHUNKSIZE
+#  endif
+#  undef  MAXCHUNKSIZE
     sha256_multi_block(ctx, hash_d, n4x);
 
     memset(blocks, 0, sizeof(blocks));
@@ -354,18 +353,18 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,
         len += 64 + 13;         /* 64 is HMAC header */
         len *= 8;               /* convert to bits */
         if (off &lt; (64 - 8)) {
-#   ifdef BSWAP4
+#  ifdef BSWAP4
             blocks[i].d[15] = BSWAP4(len);
-#   else
+#  else
             PUTU32(blocks[i].c + 60, len);
-#   endif
+#  endif
             edges[i].blocks = 1;
         } else {
-#   ifdef BSWAP4
+#  ifdef BSWAP4
             blocks[i].d[31] = BSWAP4(len);
-#   else
+#  else
             PUTU32(blocks[i].c + 124, len);
-#   endif
+#  endif
             edges[i].blocks = 2;
         }
         edges[i].ptr = blocks[i].c;
@@ -376,7 +375,7 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,
 
     memset(blocks, 0, sizeof(blocks));
     for (i = 0; i &lt; x4; i++) {
-#   ifdef BSWAP4
+#  ifdef BSWAP4
         blocks[i].d[0] = BSWAP4(ctx-&gt;A[i]);
         ctx-&gt;A[i] = key-&gt;tail.h[0];
         blocks[i].d[1] = BSWAP4(ctx-&gt;B[i]);
@@ -395,7 +394,7 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,
         ctx-&gt;H[i] = key-&gt;tail.h[7];
         blocks[i].c[32] = 0x80;
         blocks[i].d[15] = BSWAP4((64 + 32) * 8);
-#   else
+#  else
         PUTU32(blocks[i].c + 0, ctx-&gt;A[i]);
         ctx-&gt;A[i] = key-&gt;tail.h[0];
         PUTU32(blocks[i].c + 4, ctx-&gt;B[i]);
@@ -414,7 +413,7 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,
         ctx-&gt;H[i] = key-&gt;tail.h[7];
         blocks[i].c[32] = 0x80;
         PUTU32(blocks[i].c + 60, (64 + 32) * 8);
-#   endif
+#  endif
         edges[i].ptr = blocks[i].c;
         edges[i].blocks = 1;
     }
@@ -470,7 +469,7 @@ static size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,
 
     return ret;
 }
-#  endif
+# endif
 
 static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
                                         unsigned char *out,
@@ -481,11 +480,11 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
     size_t plen = key-&gt;payload_length, iv = 0, /* explicit IV in TLS 1.1 and
                                                 * later */
         sha_off = 0;
-#  if defined(STITCHED_CALL)
+# if defined(STITCHED_CALL)
     size_t aes_off = 0, blocks;
 
     sha_off = SHA256_CBLOCK - key-&gt;md.num;
-#  endif
+# endif
 
     key-&gt;payload_length = NO_PAYLOAD_LENGTH;
 
@@ -502,7 +501,7 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
         else if (key-&gt;aux.tls_ver &gt;= TLS1_1_VERSION)
             iv = AES_BLOCK_SIZE;
 
-#  if defined(STITCHED_CALL)
+# if defined(STITCHED_CALL)
         /*
          * Assembly stitch handles AVX-capable processors, but its
          * performance is not optimal on AMD Jaguar, ~40% worse, for
@@ -532,7 +531,7 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
         } else {
             sha_off = 0;
         }
-#  endif
+# endif
         sha_off += iv;
         SHA256_Update(&amp;key-&gt;md, in + sha_off, plen - sha_off);
 
@@ -608,7 +607,7 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
             key-&gt;md = key-&gt;head;
             SHA256_Update(&amp;key-&gt;md, key-&gt;aux.tls_aad, plen);
 
-#  if 1
+# if 1
             len -= SHA256_DIGEST_LENGTH; /* amend mac */
             if (len &gt;= (256 + SHA256_CBLOCK)) {
                 j = (len - (256 + SHA256_CBLOCK)) &amp; (0 - SHA256_CBLOCK);
@@ -621,15 +620,15 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
 
             /* but pretend as if we hashed padded payload */
             bitlen = key-&gt;md.Nl + (inp_len &lt;&lt; 3); /* at most 18 bits */
-#   ifdef BSWAP4
+#  ifdef BSWAP4
             bitlen = BSWAP4(bitlen);
-#   else
+#  else
             mac.c[0] = 0;
             mac.c[1] = (unsigned char)(bitlen &gt;&gt; 16);
             mac.c[2] = (unsigned char)(bitlen &gt;&gt; 8);
             mac.c[3] = (unsigned char)bitlen;
             bitlen = mac.u[0];
-#   endif
+#  endif
 
             pmac-&gt;u[0] = 0;
             pmac-&gt;u[1] = 0;
@@ -698,7 +697,7 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
             pmac-&gt;u[6] |= key-&gt;md.h[6] &amp; mask;
             pmac-&gt;u[7] |= key-&gt;md.h[7] &amp; mask;
 
-#   ifdef BSWAP4
+#  ifdef BSWAP4
             pmac-&gt;u[0] = BSWAP4(pmac-&gt;u[0]);
             pmac-&gt;u[1] = BSWAP4(pmac-&gt;u[1]);
             pmac-&gt;u[2] = BSWAP4(pmac-&gt;u[2]);
@@ -707,7 +706,7 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
             pmac-&gt;u[5] = BSWAP4(pmac-&gt;u[5]);
             pmac-&gt;u[6] = BSWAP4(pmac-&gt;u[6]);
             pmac-&gt;u[7] = BSWAP4(pmac-&gt;u[7]);
-#   else
+#  else
             for (i = 0; i &lt; 8; i++) {
                 res = pmac-&gt;u[i];
                 pmac-&gt;c[4 * i + 0] = (unsigned char)(res &gt;&gt; 24);
@@ -715,9 +714,9 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
                 pmac-&gt;c[4 * i + 2] = (unsigned char)(res &gt;&gt; 8);
                 pmac-&gt;c[4 * i + 3] = (unsigned char)res;
             }
-#   endif
+#  endif
             len += SHA256_DIGEST_LENGTH;
-#  else
+# else
             SHA256_Update(&amp;key-&gt;md, out, inp_len);
             res = key-&gt;md.num;
             SHA256_Final(pmac-&gt;c, &amp;key-&gt;md);
@@ -736,7 +735,7 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
                 for (; inp_blocks &lt; pad_blocks; inp_blocks++)
                     sha1_block_data_order(&amp;key-&gt;md, data, 1);
             }
-#  endif
+# endif
             key-&gt;md = key-&gt;tail;
             SHA256_Update(&amp;key-&gt;md, pmac-&gt;c, SHA256_DIGEST_LENGTH);
             SHA256_Final(pmac-&gt;c, &amp;key-&gt;md);
@@ -744,7 +743,7 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
             /* verify HMAC */
             out += inp_len;
             len -= inp_len;
-#  if 1
+# if 1
             {
                 unsigned char *p =
                     out + len - 1 - maxpad - SHA256_DIGEST_LENGTH;
@@ -767,7 +766,7 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
                 res = 0 - ((0 - res) &gt;&gt; (sizeof(res) * 8 - 1));
                 ret &amp;= (int)~res;
             }
-#  else
+# else
             for (res = 0, i = 0; i &lt; SHA256_DIGEST_LENGTH; i++)
                 res |= out[i] ^ pmac-&gt;c[i];
             res = 0 - ((0 - res) &gt;&gt; (sizeof(res) * 8 - 1));
@@ -781,7 +780,7 @@ static int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,
 
             res = (0 - res) &gt;&gt; (sizeof(res) * 8 - 1);
             ret &amp;= (int)~res;
-#  endif
+# endif
             return ret;
         } else {
             SHA256_Update(&amp;key-&gt;md, out, len);
@@ -859,7 +858,7 @@ static int aesni_cbc_hmac_sha256_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
                 return SHA256_DIGEST_LENGTH;
             }
         }
-#  if !defined(OPENSSL_NO_MULTIBLOCK) &amp;&amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
+# if !defined(OPENSSL_NO_MULTIBLOCK) &amp;&amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
     case EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE:
         return (int)(5 + 16 + ((arg + 32 + 16) &amp; -16));
     case EVP_CTRL_TLS1_1_MULTIBLOCK_AAD:
@@ -925,18 +924,18 @@ static int aesni_cbc_hmac_sha256_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
                                                    param-&gt;interleave / 4);
         }
     case EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT:
-#  endif
+# endif
     default:
         return -1;
     }
 }
 
 static EVP_CIPHER aesni_128_cbc_hmac_sha256_cipher = {
-#  ifdef NID_aes_128_cbc_hmac_sha256
+# ifdef NID_aes_128_cbc_hmac_sha256
     NID_aes_128_cbc_hmac_sha256,
-#  else
+# else
     NID_undef,
-#  endif
+# endif
     AES_BLOCK_SIZE, 16, AES_BLOCK_SIZE,
     EVP_CIPH_CBC_MODE | EVP_CIPH_FLAG_DEFAULT_ASN1 |
         EVP_CIPH_FLAG_AEAD_CIPHER | EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK,
@@ -951,11 +950,11 @@ static EVP_CIPHER aesni_128_cbc_hmac_sha256_cipher = {
 };
 
 static EVP_CIPHER aesni_256_cbc_hmac_sha256_cipher = {
-#  ifdef NID_aes_256_cbc_hmac_sha256
+# ifdef NID_aes_256_cbc_hmac_sha256
     NID_aes_256_cbc_hmac_sha256,
-#  else
+# else
     NID_undef,
-#  endif
+# endif
     AES_BLOCK_SIZE, 32, AES_BLOCK_SIZE,
     EVP_CIPH_CBC_MODE | EVP_CIPH_FLAG_DEFAULT_ASN1 |
         EVP_CIPH_FLAG_AEAD_CIPHER | EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK,
@@ -982,7 +981,7 @@ const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha256(void)
             aesni_cbc_sha256_enc(NULL, NULL, 0, NULL, NULL, NULL, NULL) ?
             &amp;aesni_256_cbc_hmac_sha256_cipher : NULL);
 }
-# else
+#else
 const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha256(void)
 {
     return NULL;
@@ -992,5 +991,4 @@ const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha256(void)
 {
     return NULL;
 }
-# endif
 #endif
diff --git a/crypto/evp/e_old.c b/crypto/evp/e_old.c
index c318537..5f0cbee 100644
--- a/crypto/evp/e_old.c
+++ b/crypto/evp/e_old.c
@@ -138,27 +138,25 @@ const EVP_CIPHER *EVP_rc5_32_12_16_cfb(void)
 }
 # endif
 
-# ifndef OPENSSL_NO_AES
-#  undef EVP_aes_128_cfb
+# undef EVP_aes_128_cfb
 const EVP_CIPHER *EVP_aes_128_cfb(void);
 const EVP_CIPHER *EVP_aes_128_cfb(void)
 {
     return EVP_aes_128_cfb128();
 }
 
-#  undef EVP_aes_192_cfb
+# undef EVP_aes_192_cfb
 const EVP_CIPHER *EVP_aes_192_cfb(void);
 const EVP_CIPHER *EVP_aes_192_cfb(void)
 {
     return EVP_aes_192_cfb128();
 }
 
-#  undef EVP_aes_256_cfb
+# undef EVP_aes_256_cfb
 const EVP_CIPHER *EVP_aes_256_cfb(void);
 const EVP_CIPHER *EVP_aes_256_cfb(void)
 {
     return EVP_aes_256_cfb128();
 }
-# endif
 
 #endif
diff --git a/crypto/evp/m_md5_sha1.c b/crypto/evp/m_md5_sha1.c
index ae28ddc..6367dc7 100644
--- a/crypto/evp/m_md5_sha1.c
+++ b/crypto/evp/m_md5_sha1.c
@@ -51,7 +51,7 @@
  * ====================================================================
  */
 
-#if !defined(OPENSSL_NO_MD5) &amp;&amp; !defined(OPENSSL_NO_SHA1)
+#if !defined(OPENSSL_NO_MD5)
 
 # include &lt;openssl/evp.h&gt;
 # include &lt;openssl/objects.h&gt;
diff --git a/engines/e_padlock.c b/engines/e_padlock.c
index 5bde91d..dab6c44 100644
--- a/engines/e_padlock.c
+++ b/engines/e_padlock.c
@@ -69,9 +69,7 @@
 #include &lt;openssl/crypto.h&gt;
 #include &lt;openssl/engine.h&gt;
 #include &lt;openssl/evp.h&gt;
-#ifndef OPENSSL_NO_AES
-# include &lt;openssl/aes.h&gt;
-#endif
+#include &lt;openssl/aes.h&gt;
 #include &lt;openssl/rand.h&gt;
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/modes.h&gt;
@@ -137,10 +135,8 @@ static int padlock_init(ENGINE *e);
 static RAND_METHOD padlock_rand;
 
 /* Cipher Stuff */
-#   ifndef OPENSSL_NO_AES
 static int padlock_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
                            const int **nids, int nid);
-#   endif
 
 /* Engine names */
 static const char *padlock_id = &quot;padlock&quot;;
@@ -174,9 +170,7 @@ static int padlock_bind_helper(ENGINE *e)
     if (!ENGINE_set_id(e, padlock_id) ||
         !ENGINE_set_name(e, padlock_name) ||
         !ENGINE_set_init_function(e, padlock_init) ||
-#   ifndef OPENSSL_NO_AES
         (padlock_use_ace &amp;&amp; !ENGINE_set_ciphers(e, padlock_ciphers)) ||
-#   endif
         (padlock_use_rng &amp;&amp; !ENGINE_set_RAND(e, &amp;padlock_rand))) {
         return 0;
     }
@@ -232,12 +226,12 @@ IMPLEMENT_DYNAMIC_CHECK_FN()
 IMPLEMENT_DYNAMIC_BIND_FN(padlock_bind_fn)
 #   endif                       /* DYNAMIC_ENGINE */
 /* ===== Here comes the &quot;real&quot; engine ===== */
-#   ifndef OPENSSL_NO_AES
+
 /* Some AES-related constants */
-#    define AES_BLOCK_SIZE          16
-#    define AES_KEY_SIZE_128        16
-#    define AES_KEY_SIZE_192        24
-#    define AES_KEY_SIZE_256        32
+#   define AES_BLOCK_SIZE          16
+#   define AES_KEY_SIZE_128        16
+#   define AES_KEY_SIZE_192        24
+#   define AES_KEY_SIZE_256        32
     /*
      * Here we store the status information relevant to the current context.
      */
@@ -263,7 +257,6 @@ struct padlock_cipher_data {
     } cword;                    /* Control word */
     AES_KEY ks;                 /* Encryption key */
 };
-#   endif
 
 /* Interface to assembler module */
 unsigned int padlock_capability();
@@ -303,31 +296,30 @@ static int padlock_available(void)
 }
 
 /* ===== AES encryption/decryption ===== */
-#   ifndef OPENSSL_NO_AES
 
-#    if defined(NID_aes_128_cfb128) &amp;&amp; ! defined (NID_aes_128_cfb)
-#     define NID_aes_128_cfb NID_aes_128_cfb128
-#    endif
+#   if defined(NID_aes_128_cfb128) &amp;&amp; ! defined (NID_aes_128_cfb)
+#    define NID_aes_128_cfb NID_aes_128_cfb128
+#   endif
 
-#    if defined(NID_aes_128_ofb128) &amp;&amp; ! defined (NID_aes_128_ofb)
-#     define NID_aes_128_ofb NID_aes_128_ofb128
-#    endif
+#   if defined(NID_aes_128_ofb128) &amp;&amp; ! defined (NID_aes_128_ofb)
+#    define NID_aes_128_ofb NID_aes_128_ofb128
+#   endif
 
-#    if defined(NID_aes_192_cfb128) &amp;&amp; ! defined (NID_aes_192_cfb)
-#     define NID_aes_192_cfb NID_aes_192_cfb128
-#    endif
+#   if defined(NID_aes_192_cfb128) &amp;&amp; ! defined (NID_aes_192_cfb)
+#    define NID_aes_192_cfb NID_aes_192_cfb128
+#   endif
 
-#    if defined(NID_aes_192_ofb128) &amp;&amp; ! defined (NID_aes_192_ofb)
-#     define NID_aes_192_ofb NID_aes_192_ofb128
-#    endif
+#   if defined(NID_aes_192_ofb128) &amp;&amp; ! defined (NID_aes_192_ofb)
+#    define NID_aes_192_ofb NID_aes_192_ofb128
+#   endif
 
-#    if defined(NID_aes_256_cfb128) &amp;&amp; ! defined (NID_aes_256_cfb)
-#     define NID_aes_256_cfb NID_aes_256_cfb128
-#    endif
+#   if defined(NID_aes_256_cfb128) &amp;&amp; ! defined (NID_aes_256_cfb)
+#    define NID_aes_256_cfb NID_aes_256_cfb128
+#   endif
 
-#    if defined(NID_aes_256_ofb128) &amp;&amp; ! defined (NID_aes_256_ofb)
-#     define NID_aes_256_ofb NID_aes_256_ofb128
-#    endif
+#   if defined(NID_aes_256_ofb128) &amp;&amp; ! defined (NID_aes_256_ofb)
+#    define NID_aes_256_ofb NID_aes_256_ofb128
+#   endif
 
 /* List of supported ciphers. */
 static const int padlock_cipher_nids[] = {
@@ -357,9 +349,9 @@ static int padlock_cipher_nids_num = (sizeof(padlock_cipher_nids) /
 static int padlock_aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
                                 const unsigned char *iv, int enc);
 
-#    define NEAREST_ALIGNED(ptr) ( (unsigned char *)(ptr) +         \
+#   define NEAREST_ALIGNED(ptr) ( (unsigned char *)(ptr) +         \
         ( (0x10 - ((size_t)(ptr) &amp; 0x0F)) &amp; 0x0F )      )
-#    define ALIGNED_CIPHER_DATA(ctx) ((struct padlock_cipher_data *)\
+#   define ALIGNED_CIPHER_DATA(ctx) ((struct padlock_cipher_data *)\
         NEAREST_ALIGNED(EVP_CIPHER_CTX_get_cipher_data(ctx)))
 
 static int
@@ -534,17 +526,17 @@ padlock_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out_arg,
     return 1;
 }
 
-#    define EVP_CIPHER_block_size_ECB       AES_BLOCK_SIZE
-#    define EVP_CIPHER_block_size_CBC       AES_BLOCK_SIZE
-#    define EVP_CIPHER_block_size_OFB       1
-#    define EVP_CIPHER_block_size_CFB       1
-#    define EVP_CIPHER_block_size_CTR       1
+#   define EVP_CIPHER_block_size_ECB       AES_BLOCK_SIZE
+#   define EVP_CIPHER_block_size_CBC       AES_BLOCK_SIZE
+#   define EVP_CIPHER_block_size_OFB       1
+#   define EVP_CIPHER_block_size_CFB       1
+#   define EVP_CIPHER_block_size_CTR       1
 
 /*
  * Declaring so many ciphers by hand would be a pain. Instead introduce a bit
  * of preprocessor magic :-)
  */
-#    define DECLARE_AES_EVP(ksize,lmode,umode)      \
+#   define DECLARE_AES_EVP(ksize,lmode,umode)      \
 static EVP_CIPHER *_hidden_aes_##ksize##_##lmode = NULL; \
 static const EVP_CIPHER *padlock_aes_##ksize##_##lmode(void) \
 {                                                                       \
@@ -707,12 +699,12 @@ padlock_aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
             AES_set_decrypt_key(key, key_len, &amp;cdata-&gt;ks);
         else
             AES_set_encrypt_key(key, key_len, &amp;cdata-&gt;ks);
-#    ifndef AES_ASM
+#   ifndef AES_ASM
         /*
          * OpenSSL C functions use byte-swapped extended key.
          */
         padlock_key_bswap(&amp;cdata-&gt;ks);
-#    endif
+#   endif
         cdata-&gt;cword.b.keygen = 1;
         break;
 
@@ -731,8 +723,6 @@ padlock_aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
     return 1;
 }
 
-#   endif                       /* OPENSSL_NO_AES */
-
 /* ===== Random Number Generator ===== */
 /*
  * This code is not engaged. The reason is that it does not comply
diff --git a/include/openssl/aes.h b/include/openssl/aes.h
index f81ec0d..ee12540 100644
--- a/include/openssl/aes.h
+++ b/include/openssl/aes.h
@@ -53,7 +53,6 @@
 
 # include &lt;openssl/opensslconf.h&gt;
 
-#ifndef OPENSSL_NO_AES
 # include &lt;stddef.h&gt;
 # ifdef  __cplusplus
 extern &quot;C&quot; {
@@ -130,6 +129,5 @@ int AES_unwrap_key(AES_KEY *key, const unsigned char *iv,
 # ifdef  __cplusplus
 }
 # endif
-# endif
 
 #endif
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 0dabdbc..250730f 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -793,13 +793,12 @@ const EVP_CIPHER *EVP_rc5_32_12_16_cfb64(void);
 #  define EVP_rc5_32_12_16_cfb EVP_rc5_32_12_16_cfb64
 const EVP_CIPHER *EVP_rc5_32_12_16_ofb(void);
 # endif
-# ifndef OPENSSL_NO_AES
 const EVP_CIPHER *EVP_aes_128_ecb(void);
 const EVP_CIPHER *EVP_aes_128_cbc(void);
 const EVP_CIPHER *EVP_aes_128_cfb1(void);
 const EVP_CIPHER *EVP_aes_128_cfb8(void);
 const EVP_CIPHER *EVP_aes_128_cfb128(void);
-#  define EVP_aes_128_cfb EVP_aes_128_cfb128
+# define EVP_aes_128_cfb EVP_aes_128_cfb128
 const EVP_CIPHER *EVP_aes_128_ofb(void);
 const EVP_CIPHER *EVP_aes_128_ctr(void);
 const EVP_CIPHER *EVP_aes_128_ccm(void);
@@ -807,30 +806,30 @@ const EVP_CIPHER *EVP_aes_128_gcm(void);
 const EVP_CIPHER *EVP_aes_128_xts(void);
 const EVP_CIPHER *EVP_aes_128_wrap(void);
 const EVP_CIPHER *EVP_aes_128_wrap_pad(void);
-#  ifndef OPENSSL_NO_OCB
+# ifndef OPENSSL_NO_OCB
 const EVP_CIPHER *EVP_aes_128_ocb(void);
-#  endif
+# endif
 const EVP_CIPHER *EVP_aes_192_ecb(void);
 const EVP_CIPHER *EVP_aes_192_cbc(void);
 const EVP_CIPHER *EVP_aes_192_cfb1(void);
 const EVP_CIPHER *EVP_aes_192_cfb8(void);
 const EVP_CIPHER *EVP_aes_192_cfb128(void);
-#  define EVP_aes_192_cfb EVP_aes_192_cfb128
+# define EVP_aes_192_cfb EVP_aes_192_cfb128
 const EVP_CIPHER *EVP_aes_192_ofb(void);
 const EVP_CIPHER *EVP_aes_192_ctr(void);
 const EVP_CIPHER *EVP_aes_192_ccm(void);
 const EVP_CIPHER *EVP_aes_192_gcm(void);
 const EVP_CIPHER *EVP_aes_192_wrap(void);
 const EVP_CIPHER *EVP_aes_192_wrap_pad(void);
-#  ifndef OPENSSL_NO_OCB
+# ifndef OPENSSL_NO_OCB
 const EVP_CIPHER *EVP_aes_192_ocb(void);
-#  endif
+# endif
 const EVP_CIPHER *EVP_aes_256_ecb(void);
 const EVP_CIPHER *EVP_aes_256_cbc(void);
 const EVP_CIPHER *EVP_aes_256_cfb1(void);
 const EVP_CIPHER *EVP_aes_256_cfb8(void);
 const EVP_CIPHER *EVP_aes_256_cfb128(void);
-#  define EVP_aes_256_cfb EVP_aes_256_cfb128
+# define EVP_aes_256_cfb EVP_aes_256_cfb128
 const EVP_CIPHER *EVP_aes_256_ofb(void);
 const EVP_CIPHER *EVP_aes_256_ctr(void);
 const EVP_CIPHER *EVP_aes_256_ccm(void);
@@ -838,14 +837,13 @@ const EVP_CIPHER *EVP_aes_256_gcm(void);
 const EVP_CIPHER *EVP_aes_256_xts(void);
 const EVP_CIPHER *EVP_aes_256_wrap(void);
 const EVP_CIPHER *EVP_aes_256_wrap_pad(void);
-#  ifndef OPENSSL_NO_OCB
+# ifndef OPENSSL_NO_OCB
 const EVP_CIPHER *EVP_aes_256_ocb(void);
-#  endif
+# endif
 const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void);
 const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void);
 const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha256(void);
 const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha256(void);
-# endif
 # ifndef OPENSSL_NO_CAMELLIA
 const EVP_CIPHER *EVP_camellia_128_ecb(void);
 const EVP_CIPHER *EVP_camellia_128_cbc(void);
diff --git a/ssl/ssl_init.c b/ssl/ssl_init.c
index 54892b9..546f5d2 100644
--- a/ssl/ssl_init.c
+++ b/ssl/ssl_init.c
@@ -97,7 +97,6 @@ static void ossl_init_ssl_base(void)
      */
     EVP_add_cipher(EVP_rc2_40_cbc());
 #endif
-#ifndef OPENSSL_NO_AES
     EVP_add_cipher(EVP_aes_128_cbc());
     EVP_add_cipher(EVP_aes_192_cbc());
     EVP_add_cipher(EVP_aes_256_cbc());
@@ -109,7 +108,6 @@ static void ossl_init_ssl_base(void)
     EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
     EVP_add_cipher(EVP_aes_128_cbc_hmac_sha256());
     EVP_add_cipher(EVP_aes_256_cbc_hmac_sha256());
-#endif
 #ifndef OPENSSL_NO_CAMELLIA
     EVP_add_cipher(EVP_camellia_128_cbc());
     EVP_add_cipher(EVP_camellia_256_cbc());
@@ -125,9 +123,7 @@ static void ossl_init_ssl_base(void)
 #ifndef OPENSSL_NO_MD5
     EVP_add_digest(EVP_md5());
     EVP_add_digest_alias(SN_md5, &quot;ssl3-md5&quot;);
-# ifndef OPENSSL_NO_SHA
     EVP_add_digest(EVP_md5_sha1());
-# endif
 #endif
     EVP_add_digest(EVP_sha1()); /* RSA with sha1 */
     EVP_add_digest_alias(SN_sha1, &quot;ssl3-sha1&quot;);
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 2bdfeb6..6a9311c 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -22,7 +22,7 @@ CONF_modules_free                       20	1_1_0	NOEXIST::FUNCTION:
 Camellia_cfb128_encrypt                 21	1_1_0	EXIST::FUNCTION:CAMELLIA
 DES_ncbc_encrypt                        22	1_1_0	EXIST::FUNCTION:DES
 TS_REQ_get_ext_count                    23	1_1_0	EXIST::FUNCTION:TS
-EVP_aes_128_ocb                         24	1_1_0	EXIST::FUNCTION:AES,OCB
+EVP_aes_128_ocb                         24	1_1_0	EXIST::FUNCTION:OCB
 ASN1_item_d2i_fp                        25	1_1_0	EXIST::FUNCTION:STDIO
 BN_lshift                               26	1_1_0	EXIST::FUNCTION:
 X509_NAME_add_entry_by_NID              27	1_1_0	EXIST::FUNCTION:
@@ -384,7 +384,7 @@ v3_asid_subset                          376	1_1_0	EXIST::FUNCTION:RFC3779
 RSA_check_key_ex                        377	1_1_0	EXIST::FUNCTION:RSA
 d2i_TS_MSG_IMPRINT_bio                  378	1_1_0	EXIST::FUNCTION:TS
 i2d_ASN1_TYPE                           379	1_1_0	EXIST::FUNCTION:
-EVP_aes_256_wrap_pad                    380	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_wrap_pad                    380	1_1_0	EXIST::FUNCTION:
 CMS_RecipientInfo_kekri_id_cmp          381	1_1_0	EXIST::FUNCTION:CMS
 X509_VERIFY_PARAM_get0_peername         382	1_1_0	EXIST::FUNCTION:
 ASN1_PCTX_get_oid_flags                 383	1_1_0	EXIST::FUNCTION:
@@ -430,7 +430,7 @@ ASN1_SCTX_get_flags                     422	1_1_0	EXIST::FUNCTION:
 RIPEMD160                               423	1_1_0	EXIST::FUNCTION:RMD160
 CRYPTO_ocb128_setiv                     424	1_1_0	EXIST::FUNCTION:OCB
 X509_CRL_digest                         425	1_1_0	EXIST::FUNCTION:
-EVP_aes_128_cbc_hmac_sha1               426	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_cbc_hmac_sha1               426	1_1_0	EXIST::FUNCTION:
 ERR_load_CMS_strings                    427	1_1_0	EXIST::FUNCTION:CMS
 EVP_MD_CTX_md                           428	1_1_0	EXIST::FUNCTION:
 X509_REVOKED_get_ext                    429	1_1_0	EXIST::FUNCTION:
@@ -559,7 +559,7 @@ EC_POINT_set_compressed_coordinates_GF2m 547	1_1_0	EXIST::FUNCTION:EC,EC2M
 RSA_sign_ASN1_OCTET_STRING              548	1_1_0	EXIST::FUNCTION:RSA
 d2i_X509_CRL_fp                         549	1_1_0	EXIST::FUNCTION:STDIO
 i2d_RSA_PUBKEY                          550	1_1_0	EXIST::FUNCTION:RSA
-EVP_aes_128_ccm                         551	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_ccm                         551	1_1_0	EXIST::FUNCTION:
 ECParameters_print                      552	1_1_0	EXIST::FUNCTION:EC
 OCSP_SINGLERESP_get1_ext_d2i            553	1_1_0	EXIST::FUNCTION:
 RAND_status                             554	1_1_0	EXIST::FUNCTION:
@@ -694,13 +694,13 @@ X509_TRUST_set_default                  677	1_1_0	EXIST::FUNCTION:
 TXT_DB_read                             678	1_1_0	EXIST::FUNCTION:
 BN_sub                                  679	1_1_0	EXIST::FUNCTION:
 ASRange_free                            680	1_1_0	EXIST::FUNCTION:RFC3779
-EVP_aes_192_cfb8                        681	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_cfb8                        681	1_1_0	EXIST::FUNCTION:
 DSO_global_lookup                       682	1_1_0	EXIST::FUNCTION:
 PKCS7_SIGNER_INFO_it                    683	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 PKCS7_SIGNER_INFO_it                    683	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 CRYPTO_ocb128_copy_ctx                  684	1_1_0	EXIST::FUNCTION:OCB
 TS_REQ_get_ext_d2i                      685	1_1_0	EXIST::FUNCTION:TS
-AES_ige_encrypt                         686	1_1_0	EXIST::FUNCTION:AES
+AES_ige_encrypt                         686	1_1_0	EXIST::FUNCTION:
 d2i_SXNET                               687	1_1_0	EXIST::FUNCTION:
 CTLOG_get0_log_id                       688	1_1_0	EXIST::FUNCTION:CT
 CMS_RecipientInfo_ktri_get0_signer_id   689	1_1_0	EXIST::FUNCTION:CMS
@@ -782,7 +782,7 @@ PKCS7_ENC_CONTENT_free                  763	1_1_0	EXIST::FUNCTION:
 CMS_RecipientInfo_type                  764	1_1_0	EXIST::FUNCTION:CMS
 OCSP_BASICRESP_get_ext                  765	1_1_0	EXIST::FUNCTION:
 BN_lebin2bn                             766	1_1_0	EXIST::FUNCTION:
-AES_decrypt                             767	1_1_0	EXIST::FUNCTION:AES
+AES_decrypt                             767	1_1_0	EXIST::FUNCTION:
 BIO_fd_should_retry                     768	1_1_0	EXIST::FUNCTION:
 ASN1_STRING_new                         769	1_1_0	EXIST::FUNCTION:
 ENGINE_init                             770	1_1_0	EXIST::FUNCTION:ENGINE
@@ -900,7 +900,7 @@ EC_KEY_METHOD_set_compute_key           877	1_1_0	EXIST::FUNCTION:EC
 X509_REQ_INFO_free                      878	1_1_0	EXIST::FUNCTION:
 CMS_ReceiptRequest_create0              879	1_1_0	EXIST::FUNCTION:CMS
 EVP_MD_meth_set_cleanup                 880	1_1_0	EXIST::FUNCTION:
-EVP_aes_128_xts                         881	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_xts                         881	1_1_0	EXIST::FUNCTION:
 CRYPTO_set_dynlock_destroy_callback     882	1_1_0	NOEXIST::FUNCTION:
 TS_RESP_verify_signature                883	1_1_0	EXIST::FUNCTION:TS
 ENGINE_set_pkey_meths                   884	1_1_0	EXIST::FUNCTION:ENGINE
@@ -1003,7 +1003,7 @@ ASIdentifierChoice_free                 975	1_1_0	EXIST::FUNCTION:RFC3779
 BIO_dgram_sctp_msg_waiting              976	1_1_0	EXIST::FUNCTION:SCTP
 CRYPTO_get_dynlock_value                977	1_1_0	NOEXIST::FUNCTION:
 BN_is_bit_set                           978	1_1_0	EXIST::FUNCTION:
-AES_ofb128_encrypt                      979	1_1_0	EXIST::FUNCTION:AES
+AES_ofb128_encrypt                      979	1_1_0	EXIST::FUNCTION:
 X509_STORE_add_lookup                   980	1_1_0	EXIST::FUNCTION:
 ASN1_GENERALSTRING_new                  981	1_1_0	EXIST::FUNCTION:
 idea_options                            982	1_1_0	EXIST::FUNCTION:IDEA
@@ -1185,7 +1185,7 @@ EC_POINT_dup                            1150	1_1_0	EXIST::FUNCTION:EC
 PKCS5_v2_scrypt_keyivgen                1151	1_1_0	EXIST::FUNCTION:SCRYPT
 X509_STORE_CTX_set0_param               1152	1_1_0	EXIST::FUNCTION:
 DES_check_key_parity                    1153	1_1_0	EXIST::FUNCTION:DES
-EVP_aes_256_ocb                         1154	1_1_0	EXIST::FUNCTION:AES,OCB
+EVP_aes_256_ocb                         1154	1_1_0	EXIST::FUNCTION:OCB
 X509_VAL_free                           1155	1_1_0	EXIST::FUNCTION:
 X509_STORE_get1_certs                   1156	1_1_0	EXIST::FUNCTION:
 PEM_write_RSA_PUBKEY                    1157	1_1_0	EXIST::FUNCTION:RSA
@@ -1213,12 +1213,12 @@ ASN1_BIT_STRING_check                   1177	1_1_0	EXIST::FUNCTION:
 ENGINE_set_default_RAND                 1178	1_1_0	EXIST::FUNCTION:ENGINE
 BIO_connect                             1179	1_1_0	EXIST::FUNCTION:
 TS_TST_INFO_add_ext                     1180	1_1_0	EXIST::FUNCTION:TS
-EVP_aes_192_ccm                         1181	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_ccm                         1181	1_1_0	EXIST::FUNCTION:
 X509V3_add_value                        1182	1_1_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_set0_keygen_info           1183	1_1_0	EXIST::FUNCTION:
 ENGINE_unregister_digests               1184	1_1_0	EXIST::FUNCTION:ENGINE
 IPAddressOrRange_new                    1185	1_1_0	EXIST::FUNCTION:RFC3779
-EVP_aes_256_ofb                         1186	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_ofb                         1186	1_1_0	EXIST::FUNCTION:
 CRYPTO_mem_debug_push                   1187	1_1_0	EXIST::FUNCTION:CRYPTO_MDEBUG
 X509_PKEY_new                           1188	1_1_0	EXIST::FUNCTION:
 X509_get_key_usage                      1189	1_1_0	EXIST::FUNCTION:
@@ -1289,7 +1289,7 @@ CMS_add_smimecap                        1251	1_1_0	EXIST::FUNCTION:CMS
 X509_check_email                        1252	1_1_0	EXIST::FUNCTION:
 CRYPTO_cts128_decrypt_block             1253	1_1_0	EXIST::FUNCTION:
 UI_method_get_opener                    1254	1_1_0	EXIST::FUNCTION:
-EVP_aes_192_gcm                         1255	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_gcm                         1255	1_1_0	EXIST::FUNCTION:
 TS_CONF_set_tsa_name                    1256	1_1_0	EXIST::FUNCTION:TS
 X509_email_free                         1257	1_1_0	EXIST::FUNCTION:
 BIO_get_callback                        1258	1_1_0	EXIST::FUNCTION:
@@ -1317,7 +1317,7 @@ d2i_DIST_POINT_NAME                     1279	1_1_0	EXIST::FUNCTION:
 ASN1_INTEGER_set_int64                  1280	1_1_0	EXIST::FUNCTION:
 ASN1_TIME_free                          1281	1_1_0	EXIST::FUNCTION:
 i2o_SCT_LIST                            1282	1_1_0	EXIST::FUNCTION:CT
-AES_encrypt                             1283	1_1_0	EXIST::FUNCTION:AES
+AES_encrypt                             1283	1_1_0	EXIST::FUNCTION:
 MD5_Init                                1284	1_1_0	EXIST::FUNCTION:MD5
 UI_add_error_string                     1285	1_1_0	EXIST::FUNCTION:
 X509_TRUST_cleanup                      1286	1_1_0	EXIST::FUNCTION:
@@ -1381,7 +1381,7 @@ AUTHORITY_INFO_ACCESS_new               1339	1_1_0	EXIST::FUNCTION:
 CRYPTO_mem_leaks_fp                     1340	1_1_0	EXIST::FUNCTION:CRYPTO_MDEBUG,STDIO
 DES_set_key_unchecked                   1341	1_1_0	EXIST::FUNCTION:DES
 BN_free                                 1342	1_1_0	EXIST::FUNCTION:
-EVP_aes_128_cfb1                        1343	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_cfb1                        1343	1_1_0	EXIST::FUNCTION:
 EC_KEY_get0_group                       1344	1_1_0	EXIST::FUNCTION:EC
 PEM_write_bio_CMS_stream                1345	1_1_0	EXIST::FUNCTION:CMS
 BIO_f_linebuffer                        1346	1_1_0	EXIST::FUNCTION:
@@ -1471,7 +1471,7 @@ BN_value_one                            1427	1_1_0	EXIST::FUNCTION:
 RSA_padding_add_SSLv23                  1428	1_1_0	EXIST::FUNCTION:RSA
 OCSP_RESPBYTES_it                       1429	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 OCSP_RESPBYTES_it                       1429	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
-EVP_aes_192_wrap                        1430	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_wrap                        1430	1_1_0	EXIST::FUNCTION:
 OCSP_CERTID_it                          1431	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 OCSP_CERTID_it                          1431	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 ENGINE_get_RSA                          1432	1_1_0	EXIST::FUNCTION:ENGINE
@@ -1488,7 +1488,7 @@ EVP_PKEY_get0_DH                        1442	1_1_0	EXIST::FUNCTION:DH
 d2i_OCSP_CRLID                          1443	1_1_0	EXIST::FUNCTION:
 EVP_CIPHER_CTX_set_padding              1444	1_1_0	EXIST::FUNCTION:
 CTLOG_new_from_base64                   1445	1_1_0	EXIST::FUNCTION:CT
-AES_bi_ige_encrypt                      1446	1_1_0	EXIST::FUNCTION:AES
+AES_bi_ige_encrypt                      1446	1_1_0	EXIST::FUNCTION:
 ERR_pop_to_mark                         1447	1_1_0	EXIST::FUNCTION:
 DSO_METHOD_win32                        1448	1_1_0	NOEXIST::FUNCTION:
 CRL_DIST_POINTS_new                     1449	1_1_0	EXIST::FUNCTION:
@@ -1550,9 +1550,9 @@ PKCS7_dataFinal                         1503	1_1_0	EXIST::FUNCTION:
 SHA1_Final                              1504	1_1_0	EXIST::FUNCTION:
 i2a_ASN1_STRING                         1505	1_1_0	EXIST::FUNCTION:
 EVP_CIPHER_CTX_rand_key                 1506	1_1_0	EXIST::FUNCTION:
-AES_set_encrypt_key                     1507	1_1_0	EXIST::FUNCTION:AES
+AES_set_encrypt_key                     1507	1_1_0	EXIST::FUNCTION:
 ASN1_UTCTIME_new                        1508	1_1_0	EXIST::FUNCTION:
-AES_cbc_encrypt                         1509	1_1_0	EXIST::FUNCTION:AES
+AES_cbc_encrypt                         1509	1_1_0	EXIST::FUNCTION:
 OCSP_RESPDATA_free                      1510	1_1_0	EXIST::FUNCTION:
 EVP_PKEY_asn1_find                      1511	1_1_0	EXIST::FUNCTION:
 d2i_ASN1_GENERALIZEDTIME                1512	1_1_0	EXIST::FUNCTION:
@@ -1726,7 +1726,7 @@ X509_SIG_it                             1676	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION
 X509_SIG_it                             1676	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 ASYNC_start_job                         1677	1_1_0	EXIST::FUNCTION:
 TS_TST_INFO_dup                         1678	1_1_0	EXIST::FUNCTION:TS
-EVP_aes_192_ctr                         1679	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_ctr                         1679	1_1_0	EXIST::FUNCTION:
 PKCS12_pack_authsafes                   1680	1_1_0	EXIST::FUNCTION:
 PKCS7_get_attribute                     1681	1_1_0	EXIST::FUNCTION:
 OPENSSL_config                          1682	1_1_0	EXIST::FUNCTION:DEPRECATEDIN_1_1_0
@@ -1764,9 +1764,9 @@ d2i_PKCS7_bio                           1712	1_1_0	EXIST::FUNCTION:
 ENGINE_set_default_digests              1713	1_1_0	EXIST::FUNCTION:ENGINE
 i2d_PublicKey                           1714	1_1_0	EXIST::FUNCTION:
 RC5_32_set_key                          1715	1_1_0	EXIST::FUNCTION:RC5
-AES_unwrap_key                          1716	1_1_0	EXIST::FUNCTION:AES
+AES_unwrap_key                          1716	1_1_0	EXIST::FUNCTION:
 EVP_Cipher                              1717	1_1_0	EXIST::FUNCTION:
-AES_set_decrypt_key                     1718	1_1_0	EXIST::FUNCTION:AES
+AES_set_decrypt_key                     1718	1_1_0	EXIST::FUNCTION:
 BF_ofb64_encrypt                        1719	1_1_0	EXIST::FUNCTION:BF
 d2i_TS_TST_INFO_fp                      1720	1_1_0	EXIST::FUNCTION:STDIO,TS
 X509_find_by_issuer_and_serial          1721	1_1_0	EXIST::FUNCTION:
@@ -1779,7 +1779,7 @@ a2d_ASN1_OBJECT                         1727	1_1_0	EXIST::FUNCTION:
 OCSP_ONEREQ_delete_ext                  1728	1_1_0	EXIST::FUNCTION:
 UI_method_get_reader                    1729	1_1_0	EXIST::FUNCTION:
 CMS_unsigned_get_attr                   1730	1_1_0	EXIST::FUNCTION:CMS
-EVP_aes_256_cbc                         1731	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_cbc                         1731	1_1_0	EXIST::FUNCTION:
 X509_check_ip_asc                       1732	1_1_0	EXIST::FUNCTION:
 PEM_write_bio_X509_AUX                  1733	1_1_0	EXIST::FUNCTION:
 RC2_cbc_encrypt                         1734	1_1_0	EXIST::FUNCTION:RC2
@@ -1816,7 +1816,7 @@ X509_alias_get0                         1763	1_1_0	EXIST::FUNCTION:
 X509_ATTRIBUTE_free                     1764	1_1_0	EXIST::FUNCTION:
 d2i_X509_bio                            1765	1_1_0	EXIST::FUNCTION:
 TS_TST_INFO_get_exts                    1766	1_1_0	EXIST::FUNCTION:TS
-EVP_aes_256_ecb                         1767	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_ecb                         1767	1_1_0	EXIST::FUNCTION:
 ASN1_BIT_STRING_name_print              1768	1_1_0	EXIST::FUNCTION:
 d2i_X509_EXTENSIONS                     1769	1_1_0	EXIST::FUNCTION:
 ASN1_OCTET_STRING_free                  1770	1_1_0	EXIST::FUNCTION:
@@ -1829,10 +1829,10 @@ X509_digest                             1776	1_1_0	EXIST::FUNCTION:
 CRYPTO_THREAD_cleanup_local             1777	1_1_0	EXIST::FUNCTION:
 NETSCAPE_CERT_SEQUENCE_it               1778	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 NETSCAPE_CERT_SEQUENCE_it               1778	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
-EVP_aes_128_wrap                        1779	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_wrap                        1779	1_1_0	EXIST::FUNCTION:
 X509V3_conf_free                        1780	1_1_0	EXIST::FUNCTION:
 TS_TST_INFO_get_ext_by_NID              1781	1_1_0	EXIST::FUNCTION:TS
-EVP_aes_256_cfb1                        1782	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_cfb1                        1782	1_1_0	EXIST::FUNCTION:
 X509_issuer_name_cmp                    1783	1_1_0	EXIST::FUNCTION:
 CMS_RecipientEncryptedKey_get0_id       1784	1_1_0	EXIST::FUNCTION:CMS
 EVP_PKEY_meth_get_verify_recover        1785	1_1_0	EXIST::FUNCTION:
@@ -1927,7 +1927,7 @@ DSA_generate_key                        1867	1_1_0	EXIST::FUNCTION:DSA
 EVP_DigestUpdate                        1868	1_1_0	EXIST::FUNCTION:
 X509_get_ext_by_OBJ                     1869	1_1_0	EXIST::FUNCTION:
 PBEPARAM_new                            1870	1_1_0	EXIST::FUNCTION:
-EVP_aes_128_cbc                         1871	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_cbc                         1871	1_1_0	EXIST::FUNCTION:
 CRYPTO_dup_ex_data                      1872	1_1_0	EXIST::FUNCTION:
 OCSP_single_get0_status                 1873	1_1_0	EXIST::FUNCTION:
 d2i_AUTHORITY_INFO_ACCESS               1874	1_1_0	EXIST::FUNCTION:
@@ -1952,13 +1952,13 @@ BN_CTX_secure_new                       1891	1_1_0	EXIST::FUNCTION:
 OCSP_ONEREQ_add_ext                     1892	1_1_0	EXIST::FUNCTION:
 CMS_uncompress                          1893	1_1_0	EXIST::FUNCTION:CMS
 CRYPTO_mem_debug_pop                    1895	1_1_0	EXIST::FUNCTION:CRYPTO_MDEBUG
-EVP_aes_192_cfb128                      1896	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_cfb128                      1896	1_1_0	EXIST::FUNCTION:
 OCSP_REQ_CTX_nbio                       1897	1_1_0	EXIST::FUNCTION:
 EVP_CIPHER_CTX_copy                     1898	1_1_0	EXIST::FUNCTION:
 CRYPTO_secure_allocated                 1899	1_1_0	EXIST::FUNCTION:
 UI_UTIL_read_pw_string                  1900	1_1_0	EXIST::FUNCTION:
 NOTICEREF_free                          1901	1_1_0	EXIST::FUNCTION:
-AES_cfb1_encrypt                        1902	1_1_0	EXIST::FUNCTION:AES
+AES_cfb1_encrypt                        1902	1_1_0	EXIST::FUNCTION:
 X509v3_get_ext                          1903	1_1_0	EXIST::FUNCTION:
 BN_BLINDING_set_thread_id               1904	1_1_0	NOEXIST::FUNCTION:
 CRYPTO_gcm128_encrypt_ctr32             1905	1_1_0	EXIST::FUNCTION:
@@ -2001,7 +2001,7 @@ SHA256_Init                             1942	1_1_0	EXIST::FUNCTION:
 X509_NAME_ENTRY_get_object              1943	1_1_0	EXIST::FUNCTION:
 ASN1_ENUMERATED_free                    1944	1_1_0	EXIST::FUNCTION:
 X509_CRL_set_meth_data                  1945	1_1_0	EXIST::FUNCTION:
-EVP_aes_192_cfb1                        1946	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_cfb1                        1946	1_1_0	EXIST::FUNCTION:
 EVP_MD_CTX_set_flags                    1947	1_1_0	EXIST::FUNCTION:
 EVP_seed_cbc                            1948	1_1_0	EXIST::FUNCTION:SEED
 d2i_PKCS12                              1949	1_1_0	EXIST::FUNCTION:
@@ -2100,7 +2100,7 @@ _shadow_DES_check_key                   2037	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION
 _shadow_DES_check_key                   2037	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:DES
 CMS_RecipientInfo_set0_pkey             2038	1_1_0	EXIST::FUNCTION:CMS
 X509_STORE_CTX_set_default              2039	1_1_0	EXIST::FUNCTION:
-AES_wrap_key                            2040	1_1_0	EXIST::FUNCTION:AES
+AES_wrap_key                            2040	1_1_0	EXIST::FUNCTION:
 EVP_md_null                             2041	1_1_0	EXIST::FUNCTION:
 i2d_SCT_LIST                            2042	1_1_0	EXIST::FUNCTION:CT
 PKCS7_get_issuer_and_serial             2043	1_1_0	EXIST::FUNCTION:
@@ -2365,13 +2365,13 @@ TS_TST_INFO_set_nonce                   2288	1_1_0	EXIST::FUNCTION:TS
 PEM_read_ECPrivateKey                   2289	1_1_0	EXIST::FUNCTION:EC
 RSA_free                                2290	1_1_0	EXIST::FUNCTION:RSA
 X509_CRL_INFO_new                       2291	1_1_0	EXIST::FUNCTION:
-AES_cfb8_encrypt                        2292	1_1_0	EXIST::FUNCTION:AES
+AES_cfb8_encrypt                        2292	1_1_0	EXIST::FUNCTION:
 d2i_ASN1_SEQUENCE_ANY                   2293	1_1_0	EXIST::FUNCTION:
 PKCS12_create                           2294	1_1_0	EXIST::FUNCTION:
 X509at_get_attr_count                   2295	1_1_0	EXIST::FUNCTION:
 PKCS12_init                             2296	1_1_0	EXIST::FUNCTION:
 CRYPTO_free_ex_data                     2297	1_1_0	EXIST::FUNCTION:
-EVP_aes_128_cfb8                        2298	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_cfb8                        2298	1_1_0	EXIST::FUNCTION:
 ESS_ISSUER_SERIAL_free                  2299	1_1_0	EXIST::FUNCTION:TS
 BN_mod_exp_mont_word                    2300	1_1_0	EXIST::FUNCTION:
 X509V3_EXT_nconf_nid                    2301	1_1_0	EXIST::FUNCTION:
@@ -2406,7 +2406,7 @@ CMS_signed_get_attr_by_OBJ              2329	1_1_0	EXIST::FUNCTION:CMS
 X509_REVOKED_add_ext                    2330	1_1_0	EXIST::FUNCTION:
 EVP_CipherUpdate                        2331	1_1_0	EXIST::FUNCTION:
 Camellia_cfb8_encrypt                   2332	1_1_0	EXIST::FUNCTION:CAMELLIA
-EVP_aes_256_xts                         2333	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_xts                         2333	1_1_0	EXIST::FUNCTION:
 EVP_DigestSignFinal                     2334	1_1_0	EXIST::FUNCTION:
 ASN1_STRING_cmp                         2335	1_1_0	EXIST::FUNCTION:
 EVP_chacha20_poly1305                   2336	1_1_0	EXIST::FUNCTION:CHACHA,POLY1305
@@ -2426,7 +2426,7 @@ ASN1_TIME_diff                          2349	1_1_0	EXIST::FUNCTION:
 BIO_s_fd                                2350	1_1_0	EXIST::FUNCTION:
 i2d_CMS_bio                             2351	1_1_0	EXIST::FUNCTION:CMS
 CRYPTO_gcm128_decrypt                   2352	1_1_0	EXIST::FUNCTION:
-EVP_aes_256_ctr                         2353	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_ctr                         2353	1_1_0	EXIST::FUNCTION:
 EVP_PKEY_bits                           2354	1_1_0	EXIST::FUNCTION:
 BN_BLINDING_new                         2355	1_1_0	EXIST::FUNCTION:
 ASN1_GENERALIZEDTIME_check              2356	1_1_0	EXIST::FUNCTION:
@@ -2504,7 +2504,7 @@ ASN1_GENERALIZEDTIME_it                 2425	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION
 ASN1_GENERALIZEDTIME_it                 2425	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 PKCS8_pkey_get0                         2426	1_1_0	EXIST::FUNCTION:
 OCSP_sendreq_new                        2427	1_1_0	EXIST::FUNCTION:
-EVP_aes_256_cfb128                      2428	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_cfb128                      2428	1_1_0	EXIST::FUNCTION:
 RSA_set_ex_data                         2429	1_1_0	EXIST::FUNCTION:RSA
 BN_GENCB_call                           2430	1_1_0	EXIST::FUNCTION:
 X509V3_EXT_add_nconf_sk                 2431	1_1_0	EXIST::FUNCTION:
@@ -2553,7 +2553,7 @@ NETSCAPE_SPKAC_it                       2471	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION
 NETSCAPE_SPKAC_it                       2471	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 ASIdOrRange_free                        2472	1_1_0	EXIST::FUNCTION:RFC3779
 EC_POINT_get_Jprojective_coordinates_GFp 2473	1_1_0	EXIST::FUNCTION:EC
-EVP_aes_128_cbc_hmac_sha256             2474	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_cbc_hmac_sha256             2474	1_1_0	EXIST::FUNCTION:
 i2d_PKCS7_SIGNED                        2475	1_1_0	EXIST::FUNCTION:
 TS_VERIFY_CTX_set_data                  2476	1_1_0	EXIST::FUNCTION:TS
 BN_pseudo_rand_range                    2477	1_1_0	EXIST::FUNCTION:
@@ -2579,7 +2579,7 @@ TS_STATUS_INFO_free                     2495	1_1_0	EXIST::FUNCTION:TS
 BN_mod_mul                              2496	1_1_0	EXIST::FUNCTION:
 CMS_add0_recipient_key                  2497	1_1_0	EXIST::FUNCTION:CMS
 BIO_f_zlib                              2498	1_1_0	EXIST:ZLIB:FUNCTION:COMP
-AES_cfb128_encrypt                      2499	1_1_0	EXIST::FUNCTION:AES
+AES_cfb128_encrypt                      2499	1_1_0	EXIST::FUNCTION:
 ENGINE_set_EC                           2500	1_1_0	EXIST::FUNCTION:ENGINE
 d2i_ECPKParameters                      2501	1_1_0	EXIST::FUNCTION:EC
 idea_ofb64_encrypt                      2502	1_1_0	EXIST::FUNCTION:IDEA
@@ -2738,7 +2738,7 @@ X509_issuer_name_hash                   2648	1_1_0	EXIST::FUNCTION:
 TS_TST_INFO_get_nonce                   2649	1_1_0	EXIST::FUNCTION:TS
 MD4_Init                                2650	1_1_0	EXIST::FUNCTION:MD4
 X509_EXTENSION_create_by_OBJ            2651	1_1_0	EXIST::FUNCTION:
-EVP_aes_256_cbc_hmac_sha1               2652	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_cbc_hmac_sha1               2652	1_1_0	EXIST::FUNCTION:
 SCT_validate                            2653	1_1_0	EXIST::FUNCTION:CT
 EC_GROUP_dup                            2654	1_1_0	EXIST::FUNCTION:EC
 EVP_sha1                                2655	1_1_0	EXIST::FUNCTION:
@@ -2749,7 +2749,7 @@ CONF_module_set_usr_data                2659	1_1_0	EXIST::FUNCTION:
 EC_KEY_generate_key                     2660	1_1_0	EXIST::FUNCTION:EC
 BIO_ctrl_get_write_guarantee            2661	1_1_0	EXIST::FUNCTION:
 EVP_PKEY_assign                         2662	1_1_0	EXIST::FUNCTION:
-EVP_aes_128_ofb                         2663	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_ofb                         2663	1_1_0	EXIST::FUNCTION:
 CMS_data                                2664	1_1_0	EXIST::FUNCTION:CMS
 X509_load_cert_file                     2665	1_1_0	EXIST::FUNCTION:
 CRYPTO_THREADID_cpy                     2666	1_1_0	NOEXIST::FUNCTION:
@@ -2792,7 +2792,7 @@ OCSP_basic_add1_cert                    2700	1_1_0	EXIST::FUNCTION:
 ASN1_PRINTABLESTRING_new                2701	1_1_0	EXIST::FUNCTION:
 i2d_PBEPARAM                            2702	1_1_0	EXIST::FUNCTION:
 NETSCAPE_SPKI_new                       2703	1_1_0	EXIST::FUNCTION:
-AES_options                             2704	1_1_0	EXIST::FUNCTION:AES
+AES_options                             2704	1_1_0	EXIST::FUNCTION:
 POLICYINFO_free                         2705	1_1_0	EXIST::FUNCTION:
 PEM_read_bio_Parameters                 2706	1_1_0	EXIST::FUNCTION:
 BN_abs_is_word                          2707	1_1_0	EXIST::FUNCTION:
@@ -2840,7 +2840,7 @@ d2i_OCSP_REQINFO                        2747	1_1_0	EXIST::FUNCTION:
 d2i_X509_CINF                           2748	1_1_0	EXIST::FUNCTION:
 OCSP_REQUEST_get_ext_by_critical        2749	1_1_0	EXIST::FUNCTION:
 X509_REQ_to_X509                        2750	1_1_0	EXIST::FUNCTION:
-EVP_aes_192_wrap_pad                    2751	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_wrap_pad                    2751	1_1_0	EXIST::FUNCTION:
 PKCS7_SIGN_ENVELOPE_new                 2752	1_1_0	EXIST::FUNCTION:
 TS_REQ_get_policy_id                    2753	1_1_0	EXIST::FUNCTION:TS
 RC5_32_cbc_encrypt                      2754	1_1_0	EXIST::FUNCTION:RC5
@@ -3008,7 +3008,7 @@ RSA_size                                2904	1_1_0	EXIST::FUNCTION:RSA
 EVP_CIPHER_CTX_iv_noconst               2905	1_1_0	EXIST::FUNCTION:
 DH_set_default_method                   2906	1_1_0	EXIST::FUNCTION:DH
 X509_ALGOR_new                          2907	1_1_0	EXIST::FUNCTION:
-EVP_aes_192_ofb                         2908	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_ofb                         2908	1_1_0	EXIST::FUNCTION:
 EVP_des_ede3_cfb1                       2909	1_1_0	EXIST::FUNCTION:DES
 TS_REQ_to_TS_VERIFY_CTX                 2910	1_1_0	EXIST::FUNCTION:TS
 d2i_PBEPARAM                            2911	1_1_0	EXIST::FUNCTION:
@@ -3037,7 +3037,7 @@ EVP_MD_meth_get_final                   2932	1_1_0	EXIST::FUNCTION:
 ASN1_TYPE_get_octetstring               2933	1_1_0	EXIST::FUNCTION:
 ENGINE_by_id                            2934	1_1_0	EXIST::FUNCTION:ENGINE
 d2i_PKCS7_SIGNER_INFO                   2935	1_1_0	EXIST::FUNCTION:
-EVP_aes_192_cbc                         2936	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_cbc                         2936	1_1_0	EXIST::FUNCTION:
 PKCS8_pkey_set0                         2937	1_1_0	EXIST::FUNCTION:
 X509_get1_email                         2938	1_1_0	EXIST::FUNCTION:
 EC_POINT_point2oct                      2939	1_1_0	EXIST::FUNCTION:EC
@@ -3117,7 +3117,7 @@ EVP_PKEY_get0_RSA                       3011	1_1_0	EXIST::FUNCTION:RSA
 DES_ede3_cfb64_encrypt                  3012	1_1_0	EXIST::FUNCTION:DES
 DSO_METHOD_vms                          3013	1_1_0	NOEXIST::FUNCTION:
 POLICY_MAPPING_free                     3014	1_1_0	EXIST::FUNCTION:
-EVP_aes_128_gcm                         3015	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_gcm                         3015	1_1_0	EXIST::FUNCTION:
 BIO_dgram_non_fatal_error               3016	1_1_0	EXIST::FUNCTION:
 OCSP_request_is_signed                  3017	1_1_0	EXIST::FUNCTION:
 i2d_BASIC_CONSTRAINTS                   3018	1_1_0	EXIST::FUNCTION:
@@ -3223,7 +3223,7 @@ OCSP_REQUEST_free                       3114	1_1_0	EXIST::FUNCTION:
 CRYPTO_ocb128_aad                       3115	1_1_0	EXIST::FUNCTION:OCB
 sk_deep_copy                            3116	1_1_0	EXIST::FUNCTION:
 i2d_RSA_PSS_PARAMS                      3117	1_1_0	EXIST::FUNCTION:RSA
-EVP_aes_128_wrap_pad                    3118	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_wrap_pad                    3118	1_1_0	EXIST::FUNCTION:
 ASN1_BIT_STRING_set                     3119	1_1_0	EXIST::FUNCTION:
 PKCS5_PBKDF2_HMAC_SHA1                  3120	1_1_0	EXIST::FUNCTION:
 RSA_padding_check_PKCS1_type_2          3121	1_1_0	EXIST::FUNCTION:RSA
@@ -3231,7 +3231,7 @@ EVP_des_ede3_ecb                        3122	1_1_0	EXIST::FUNCTION:DES
 CBIGNUM_it                              3123	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 CBIGNUM_it                              3123	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 BIO_new_NDEF                            3124	1_1_0	EXIST::FUNCTION:
-EVP_aes_256_wrap                        3125	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_wrap                        3125	1_1_0	EXIST::FUNCTION:
 ASN1_STRING_print                       3126	1_1_0	EXIST::FUNCTION:
 CRYPTO_THREAD_lock_free                 3127	1_1_0	EXIST::FUNCTION:
 TS_ACCURACY_get_seconds                 3128	1_1_0	EXIST::FUNCTION:TS
@@ -3240,7 +3240,7 @@ BIO_debug_callback                      3130	1_1_0	EXIST::FUNCTION:
 EVP_MD_meth_get_update                  3131	1_1_0	EXIST::FUNCTION:
 GENERAL_NAME_set0_othername             3132	1_1_0	EXIST::FUNCTION:
 ASN1_BIT_STRING_set_bit                 3133	1_1_0	EXIST::FUNCTION:
-EVP_aes_256_ccm                         3134	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_ccm                         3134	1_1_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_get0_pkey                  3135	1_1_0	EXIST::FUNCTION:
 CONF_load_fp                            3136	1_1_0	EXIST::FUNCTION:STDIO
 BN_to_ASN1_ENUMERATED                   3137	1_1_0	EXIST::FUNCTION:
@@ -3281,7 +3281,7 @@ BN_mod_sub                              3171	1_1_0	EXIST::FUNCTION:
 ASN1_NULL_new                           3172	1_1_0	EXIST::FUNCTION:
 HMAC_Init                               3173	1_1_0	EXIST::FUNCTION:DEPRECATEDIN_1_1_0
 EVP_MD_CTX_update_fn                    3174	1_1_0	EXIST::FUNCTION:
-EVP_aes_128_ecb                         3175	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_ecb                         3175	1_1_0	EXIST::FUNCTION:
 i2d_PKCS7_bio_stream                    3176	1_1_0	EXIST::FUNCTION:
 CRYPTO_get_dynlock_create_callback      3177	1_1_0	NOEXIST::FUNCTION:
 i2a_ACCESS_DESCRIPTION                  3178	1_1_0	EXIST::FUNCTION:
@@ -3311,7 +3311,7 @@ SRP_Calc_A                              3201	1_1_0	EXIST::FUNCTION:SRP
 OCSP_BASICRESP_add_ext                  3202	1_1_0	EXIST::FUNCTION:
 EVP_idea_cfb64                          3203	1_1_0	EXIST::FUNCTION:IDEA
 PKCS12_newpass                          3204	1_1_0	EXIST::FUNCTION:
-EVP_aes_256_cbc_hmac_sha256             3205	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_cbc_hmac_sha256             3205	1_1_0	EXIST::FUNCTION:
 TS_ACCURACY_get_millis                  3206	1_1_0	EXIST::FUNCTION:TS
 X509_CRL_get_REVOKED                    3207	1_1_0	EXIST::FUNCTION:
 X509_issuer_name_hash_old               3208	1_1_0	EXIST::FUNCTION:MD5
@@ -3355,7 +3355,7 @@ ERR_get_error_line                      3245	1_1_0	EXIST::FUNCTION:
 X509_CRL_get_ext_by_NID                 3246	1_1_0	EXIST::FUNCTION:
 OPENSSL_INIT_free                       3247	1_1_0	EXIST::FUNCTION:
 PBE2PARAM_free                          3248	1_1_0	EXIST::FUNCTION:
-EVP_aes_192_ecb                         3249	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_192_ecb                         3249	1_1_0	EXIST::FUNCTION:
 ASN1_OCTET_STRING_new                   3250	1_1_0	EXIST::FUNCTION:
 CMS_set1_eContentType                   3251	1_1_0	EXIST::FUNCTION:CMS
 EVP_des_ede3_wrap                       3252	1_1_0	EXIST::FUNCTION:DES
@@ -3385,7 +3385,7 @@ CRYPTO_THREADID_set_numeric             3274	1_1_0	NOEXIST::FUNCTION:
 SCT_print                               3275	1_1_0	EXIST::FUNCTION:CT
 X509_PUBKEY_set                         3276	1_1_0	EXIST::FUNCTION:
 POLICY_CONSTRAINTS_free                 3277	1_1_0	EXIST::FUNCTION:
-EVP_aes_256_cfb8                        3278	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_cfb8                        3278	1_1_0	EXIST::FUNCTION:
 d2i_DSA_PUBKEY_bio                      3279	1_1_0	EXIST::FUNCTION:DSA
 X509_NAME_get_text_by_OBJ               3280	1_1_0	EXIST::FUNCTION:
 RSA_padding_check_none                  3281	1_1_0	EXIST::FUNCTION:RSA
@@ -3495,7 +3495,7 @@ PKCS7_DIGEST_it                         3381	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION
 PKCS7_DIGEST_it                         3381	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 X509_CINF_new                           3382	1_1_0	EXIST::FUNCTION:
 EVP_PKEY_keygen_init                    3383	1_1_0	EXIST::FUNCTION:
-EVP_aes_192_ocb                         3384	1_1_0	EXIST::FUNCTION:AES,OCB
+EVP_aes_192_ocb                         3384	1_1_0	EXIST::FUNCTION:OCB
 EVP_camellia_256_cfb1                   3385	1_1_0	EXIST::FUNCTION:CAMELLIA
 DES_read_2passwords                     3386	1_1_0	EXIST::FUNCTION:DES,UI
 CRYPTO_secure_actual_size               3387	1_1_0	EXIST::FUNCTION:
@@ -3508,7 +3508,7 @@ ERR_release_err_state_table             3393	1_1_0	NOEXIST::FUNCTION:
 X509_INFO_free                          3394	1_1_0	EXIST::FUNCTION:
 d2i_PKCS8_PRIV_KEY_INFO_fp              3395	1_1_0	EXIST::FUNCTION:STDIO
 X509_OBJECT_retrieve_match              3396	1_1_0	EXIST::FUNCTION:
-EVP_aes_128_ctr                         3397	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_ctr                         3397	1_1_0	EXIST::FUNCTION:
 EVP_PBE_find                            3398	1_1_0	EXIST::FUNCTION:
 SHA512_Transform                        3399	1_1_0	EXIST:!VMSVAX:FUNCTION:
 ERR_add_error_vdata                     3400	1_1_0	EXIST::FUNCTION:
@@ -3659,11 +3659,11 @@ ERR_load_OBJ_strings                    3544	1_1_0	EXIST::FUNCTION:
 BIO_ctrl_get_read_request               3545	1_1_0	EXIST::FUNCTION:
 BN_from_montgomery                      3546	1_1_0	EXIST::FUNCTION:
 DSO_new                                 3547	1_1_0	EXIST::FUNCTION:
-AES_ecb_encrypt                         3548	1_1_0	EXIST::FUNCTION:AES
+AES_ecb_encrypt                         3548	1_1_0	EXIST::FUNCTION:
 BN_dec2bn                               3549	1_1_0	EXIST::FUNCTION:
 CMS_decrypt                             3550	1_1_0	EXIST::FUNCTION:CMS
 BN_mpi2bn                               3551	1_1_0	EXIST::FUNCTION:
-EVP_aes_128_cfb128                      3552	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_128_cfb128                      3552	1_1_0	EXIST::FUNCTION:
 EVP_cleanup                             3553	1_1_0	NOEXIST::FUNCTION:
 RC5_32_ecb_encrypt                      3554	1_1_0	EXIST::FUNCTION:RC5
 EVP_CIPHER_meth_new                     3555	1_1_0	EXIST::FUNCTION:
@@ -3877,7 +3877,7 @@ d2i_OCSP_RESPDATA                       3756	1_1_0	EXIST::FUNCTION:
 BIO_set_callback                        3757	1_1_0	EXIST::FUNCTION:
 BN_GF2m_poly2arr                        3758	1_1_0	EXIST::FUNCTION:EC2M
 CMS_unsigned_get_attr_count             3759	1_1_0	EXIST::FUNCTION:CMS
-EVP_aes_256_gcm                         3760	1_1_0	EXIST::FUNCTION:AES
+EVP_aes_256_gcm                         3760	1_1_0	EXIST::FUNCTION:
 RSA_padding_check_X931                  3761	1_1_0	EXIST::FUNCTION:RSA
 ECDH_compute_key                        3762	1_1_0	EXIST::FUNCTION:EC
 ASN1_TIME_print                         3763	1_1_0	EXIST::FUNCTION:
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006426.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="006429.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6428">[ date ]</a>
              <a href="thread.html#6428">[ thread ]</a>
              <a href="subject.html#6428">[ subject ]</a>
              <a href="author.html#6428">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
