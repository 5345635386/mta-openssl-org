<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-April/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1459952513.815513.18923.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006275.html">
   <LINK REL="Next"  HREF="006279.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1459952513.815513.18923.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Wed Apr  6 14:21:53 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="006275.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="006279.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6277">[ date ]</a>
              <a href="thread.html#6277">[ thread ]</a>
              <a href="subject.html#6277">[ subject ]</a>
              <a href="author.html#6277">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  c014a7cb82e671859de1e922263bf819d557b55e (commit)
       via  36297463a55ced7b7a6c49726b3096c4f0dd9931 (commit)
       via  cd35e6c06db9bd412f0ac629c264e11171bf21b9 (commit)
       via  b72c9121379a5de0c8be0d4e1a4a6b9495042621 (commit)
       via  b879882a4b260067bc963807cb6b15b3c75902e8 (commit)
       via  9862e9aa98ee1e38fbcef8d1dd5db0e750eb5e8d (commit)
      from  3e41ac35281827b59e55d51058cf6bb086c1f2b5 (commit)


- Log -----------------------------------------------------------------
commit c014a7cb82e671859de1e922263bf819d557b55e
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Apr 2 19:54:51 2016 +0200

    make update
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;

commit 36297463a55ced7b7a6c49726b3096c4f0dd9931
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Apr 2 19:54:30 2016 +0200

    Update CHANGES with the new about RSA and RSA_METHOD
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;

commit cd35e6c06db9bd412f0ac629c264e11171bf21b9
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Apr 2 19:52:14 2016 +0200

    Document RSA_METHOD creators/destructor/accessors/writers
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;

commit b72c9121379a5de0c8be0d4e1a4a6b9495042621
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Apr 2 18:46:17 2016 +0200

    Make the RSA_METHOD structure opaque
    
    Move rsa_meth_st away from public headers.
    Add RSA_METHOD creator/destructor functions.
    Add RSA_METHOD accessor/writer functions.
    Adapt all other source to use the creator, destructor, accessors and writers.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;

commit b879882a4b260067bc963807cb6b15b3c75902e8
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Apr 2 16:43:21 2016 +0200

    Document RSA accessors/writers
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;

commit 9862e9aa98ee1e38fbcef8d1dd5db0e750eb5e8d
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Apr 2 15:12:58 2016 +0200

    Make the RSA structure opaque
    
    Move rsa_st away from public headers.
    Add accessor/writer functions for the public RSA data.
    Adapt all other source to use the accessors and writers.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 CHANGES                     |   5 +
 apps/genrsa.c               |  12 ++-
 apps/req.c                  |   8 +-
 apps/rsa.c                  |   4 +-
 apps/x509.c                 |   8 +-
 crypto/pem/pvkfmt.c         |  83 ++++++++------
 crypto/rsa/Makefile.in      |   4 +-
 crypto/rsa/build.info       |   2 +-
 crypto/rsa/rsa_ameth.c      |   2 +-
 crypto/rsa/rsa_asn1.c       |   2 +-
 crypto/rsa/rsa_chk.c        |   2 +-
 crypto/rsa/rsa_crpt.c       |   2 +-
 crypto/rsa/rsa_gen.c        |   2 +-
 crypto/rsa/rsa_lib.c        |  95 +++++++++++++++-
 crypto/rsa/rsa_locl.h       |  93 ++++++++++++++++
 crypto/rsa/rsa_meth.c       | 257 ++++++++++++++++++++++++++++++++++++++++++++
 crypto/rsa/rsa_null.c       |   2 +-
 crypto/rsa/rsa_oaep.c       |   2 +-
 crypto/rsa/rsa_ossl.c       |   2 +-
 crypto/rsa/rsa_x931g.c      |   2 +-
 doc/crypto/RSA_get0_key.pod |  86 +++++++++++++++
 doc/crypto/RSA_meth_new.pod | 225 ++++++++++++++++++++++++++++++++++++++
 doc/crypto/rsa.pod          |  27 ++---
 engines/e_dasync.c          |  53 ++++-----
 include/openssl/rsa.h       | 174 ++++++++++++++++--------------
 test/rsa_test.c             |  25 +++--
 util/libcrypto.num          |  41 +++++++
 27 files changed, 1027 insertions(+), 193 deletions(-)
 create mode 100644 crypto/rsa/rsa_meth.c
 create mode 100644 doc/crypto/RSA_get0_key.pod
 create mode 100644 doc/crypto/RSA_meth_new.pod

diff --git a/CHANGES b/CHANGES
index 5ac7ef5..8ea1330 100644
--- a/CHANGES
+++ b/CHANGES
@@ -4,6 +4,11 @@
 
  Changes between 1.0.2g and 1.1.0  [xx XXX xxxx]
 
+  *) Made RSA and RSA_METHOD opaque. The structures for managing RSA
+     objects have been moved out of the public header files. New
+     functions for managing these have been added.
+     [Richard Levitte]
+
   *) Made DSA and DSA_METHOD opaque. The structures for managing DSA objects
      have been moved out of the public header files. New functions for managing
      these have been added.
diff --git a/apps/genrsa.c b/apps/genrsa.c
index 0b0123fa..8b6dd03 100644
--- a/apps/genrsa.c
+++ b/apps/genrsa.c
@@ -104,9 +104,10 @@ int genrsa_main(int argc, char **argv)
 {
     BN_GENCB *cb = BN_GENCB_new();
     PW_CB_DATA cb_data;
-    ENGINE *e = NULL;
+    ENGINE *eng = NULL;
     BIGNUM *bn = BN_new();
     BIO *out = NULL;
+    BIGNUM *e;
     RSA *rsa = NULL;
     const EVP_CIPHER *enc = NULL;
     int ret = 1, num = DEFBITS, private = 0;
@@ -141,7 +142,7 @@ int genrsa_main(int argc, char **argv)
             outfile = opt_arg();
             break;
         case OPT_ENGINE:
-            e = setup_engine(opt_arg(), 0);
+            eng = setup_engine(opt_arg(), 0);
             break;
         case OPT_RAND:
             inrand = opt_arg();
@@ -182,7 +183,7 @@ int genrsa_main(int argc, char **argv)
 
     BIO_printf(bio_err, &quot;Generating RSA private key, %d bit long modulus\n&quot;,
                num);
-    rsa = e ? RSA_new_method(e) : RSA_new();
+    rsa = eng ? RSA_new_method(eng) : RSA_new();
     if (rsa == NULL)
         goto end;
 
@@ -191,8 +192,9 @@ int genrsa_main(int argc, char **argv)
 
     app_RAND_write_file(NULL);
 
-    hexe = BN_bn2hex(rsa-&gt;e);
-    dece = BN_bn2dec(rsa-&gt;e);
+    RSA_get0_key(rsa, NULL, &amp;e, NULL);
+    hexe = BN_bn2hex(e);
+    dece = BN_bn2dec(e);
     if (hexe &amp;&amp; dece) {
         BIO_printf(bio_err, &quot;e is %s (0x%s)\n&quot;, dece, hexe);
     }
diff --git a/apps/req.c b/apps/req.c
index b6a545f..e3869ba 100644
--- a/apps/req.c
+++ b/apps/req.c
@@ -811,9 +811,11 @@ int req_main(int argc, char **argv)
         }
         fprintf(stdout, &quot;Modulus=&quot;);
 #ifndef OPENSSL_NO_RSA
-        if (EVP_PKEY_base_id(tpubkey) == EVP_PKEY_RSA)
-            BN_print(out, EVP_PKEY_get0_RSA(tpubkey)-&gt;n);
-        else
+        if (EVP_PKEY_base_id(tpubkey) == EVP_PKEY_RSA) {
+            BIGNUM *n;
+            RSA_get0_key(EVP_PKEY_get0_RSA(tpubkey), &amp;n, NULL, NULL);
+            BN_print(out, n);
+        } else
 #endif
             fprintf(stdout, &quot;Wrong Algorithm type&quot;);
         EVP_PKEY_free(tpubkey);
diff --git a/apps/rsa.c b/apps/rsa.c
index 38cedf7..980d9ef 100644
--- a/apps/rsa.c
+++ b/apps/rsa.c
@@ -310,8 +310,10 @@ int rsa_main(int argc, char **argv)
     }
 
     if (modulus) {
+        BIGNUM *n;
+        RSA_get0_key(rsa, &amp;n, NULL, NULL);
         BIO_printf(out, &quot;Modulus=&quot;);
-        BN_print(out, rsa-&gt;n);
+        BN_print(out, n);
         BIO_printf(out, &quot;\n&quot;);
     }
 
diff --git a/apps/x509.c b/apps/x509.c
index bc56233..6ee2611 100644
--- a/apps/x509.c
+++ b/apps/x509.c
@@ -727,9 +727,11 @@ int x509_main(int argc, char **argv)
                 }
                 BIO_printf(out, &quot;Modulus=&quot;);
 #ifndef OPENSSL_NO_RSA
-                if (EVP_PKEY_id(pkey) == EVP_PKEY_RSA)
-                    BN_print(out, EVP_PKEY_get0_RSA(pkey)-&gt;n);
-                else
+                if (EVP_PKEY_id(pkey) == EVP_PKEY_RSA) {
+                    BIGNUM *n;
+                    RSA_get0_key(EVP_PKEY_get0_RSA(pkey), &amp;n, NULL, NULL);
+                    BN_print(out, n);
+                } else
 #endif
 #ifndef OPENSSL_NO_DSA
                 if (EVP_PKEY_id(pkey) == EVP_PKEY_DSA) {
diff --git a/crypto/pem/pvkfmt.c b/crypto/pem/pvkfmt.c
index e378b57..634cc59 100644
--- a/crypto/pem/pvkfmt.c
+++ b/crypto/pem/pvkfmt.c
@@ -353,8 +353,9 @@ static EVP_PKEY *b2i_dss(const unsigned char **in,
 static EVP_PKEY *b2i_rsa(const unsigned char **in,
                          unsigned int bitlen, int ispub)
 {
-    const unsigned char *p = *in;
+    const unsigned char *pin = *in;
     EVP_PKEY *ret = NULL;
+    BIGNUM *e = NULL, *n = NULL, *d = NULL;
     RSA *rsa = NULL;
     unsigned int nbyte, hnbyte;
     nbyte = (bitlen + 7) &gt;&gt; 3;
@@ -363,31 +364,35 @@ static EVP_PKEY *b2i_rsa(const unsigned char **in,
     ret = EVP_PKEY_new();
     if (rsa == NULL || ret == NULL)
         goto memerr;
-    rsa-&gt;e = BN_new();
-    if (rsa-&gt;e == NULL)
+    e = BN_new();
+    if (e == NULL)
         goto memerr;
-    if (!BN_set_word(rsa-&gt;e, read_ledword(&amp;p)))
+    if (!BN_set_word(e, read_ledword(&amp;pin)))
         goto memerr;
-    if (!read_lebn(&amp;p, nbyte, &amp;rsa-&gt;n))
+    if (!read_lebn(&amp;pin, nbyte, &amp;n))
         goto memerr;
     if (!ispub) {
-        if (!read_lebn(&amp;p, hnbyte, &amp;rsa-&gt;p))
+        BIGNUM *p = NULL, *q = NULL, *dmp1 = NULL, *dmq1 = NULL, *iqmp = NULL;
+        if (!read_lebn(&amp;pin, hnbyte, &amp;p))
             goto memerr;
-        if (!read_lebn(&amp;p, hnbyte, &amp;rsa-&gt;q))
+        if (!read_lebn(&amp;pin, hnbyte, &amp;q))
             goto memerr;
-        if (!read_lebn(&amp;p, hnbyte, &amp;rsa-&gt;dmp1))
+        if (!read_lebn(&amp;pin, hnbyte, &amp;dmp1))
             goto memerr;
-        if (!read_lebn(&amp;p, hnbyte, &amp;rsa-&gt;dmq1))
+        if (!read_lebn(&amp;pin, hnbyte, &amp;dmq1))
             goto memerr;
-        if (!read_lebn(&amp;p, hnbyte, &amp;rsa-&gt;iqmp))
+        if (!read_lebn(&amp;pin, hnbyte, &amp;iqmp))
             goto memerr;
-        if (!read_lebn(&amp;p, nbyte, &amp;rsa-&gt;d))
+        if (!read_lebn(&amp;pin, nbyte, &amp;d))
             goto memerr;
+        RSA_set0_factors(rsa, p, q);
+        RSA_set0_crt_params(rsa, dmp1, dmq1, iqmp);
     }
+    RSA_set0_key(rsa, e, n, d);
 
     EVP_PKEY_set1_RSA(ret, rsa);
     RSA_free(rsa);
-    *in = p;
+    *in = pin;
     return ret;
  memerr:
     PEMerr(PEM_F_B2I_RSA, ERR_R_MALLOC_FAILURE);
@@ -530,26 +535,35 @@ static int check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *pmagic)
 static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)
 {
     int nbyte, hnbyte, bitlen;
-    if (BN_num_bits(rsa-&gt;e) &gt; 32)
+    BIGNUM *e;
+
+    RSA_get0_key(rsa, &amp;e, NULL, NULL);
+    if (BN_num_bits(e) &gt; 32)
         goto badkey;
-    bitlen = BN_num_bits(rsa-&gt;n);
-    nbyte = BN_num_bytes(rsa-&gt;n);
-    hnbyte = (BN_num_bits(rsa-&gt;n) + 15) &gt;&gt; 4;
+    bitlen = RSA_bits(rsa);
+    nbyte = RSA_size(rsa);
+    hnbyte = (bitlen + 15) &gt;&gt; 4;
     if (ispub) {
         *pmagic = MS_RSA1MAGIC;
         return bitlen;
     } else {
+        BIGNUM *d, *p, *q, *iqmp, *dmp1, *dmq1;
+
         *pmagic = MS_RSA2MAGIC;
+
         /*
          * For private key each component must fit within nbyte or hnbyte.
          */
-        if (BN_num_bytes(rsa-&gt;d) &gt; nbyte)
+        RSA_get0_key(rsa, NULL, NULL, &amp;d);
+        if (BN_num_bytes(d) &gt; nbyte)
             goto badkey;
-        if ((BN_num_bytes(rsa-&gt;iqmp) &gt; hnbyte)
-            || (BN_num_bytes(rsa-&gt;p) &gt; hnbyte)
-            || (BN_num_bytes(rsa-&gt;q) &gt; hnbyte)
-            || (BN_num_bytes(rsa-&gt;dmp1) &gt; hnbyte)
-            || (BN_num_bytes(rsa-&gt;dmq1) &gt; hnbyte))
+        RSA_get0_factors(rsa, &amp;p, &amp;q);
+        RSA_get0_crt_params(rsa, &amp;dmp1, &amp;dmq1, &amp;iqmp);
+        if ((BN_num_bytes(iqmp) &gt; hnbyte)
+            || (BN_num_bytes(p) &gt; hnbyte)
+            || (BN_num_bytes(q) &gt; hnbyte)
+            || (BN_num_bytes(dmp1) &gt; hnbyte)
+            || (BN_num_bytes(dmq1) &gt; hnbyte))
             goto badkey;
     }
     return bitlen;
@@ -561,18 +575,23 @@ static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)
 static void write_rsa(unsigned char **out, RSA *rsa, int ispub)
 {
     int nbyte, hnbyte;
-    nbyte = BN_num_bytes(rsa-&gt;n);
-    hnbyte = (BN_num_bits(rsa-&gt;n) + 15) &gt;&gt; 4;
-    write_lebn(out, rsa-&gt;e, 4);
-    write_lebn(out, rsa-&gt;n, -1);
+    BIGNUM *n, *d, *e, *p, *q, *iqmp, *dmp1, *dmq1;
+
+    nbyte = RSA_size(rsa);
+    hnbyte = (RSA_bits(rsa) + 15) &gt;&gt; 4;
+    RSA_get0_key(rsa, &amp;e, &amp;n, &amp;d);
+    write_lebn(out, e, 4);
+    write_lebn(out, n, -1);
     if (ispub)
         return;
-    write_lebn(out, rsa-&gt;p, hnbyte);
-    write_lebn(out, rsa-&gt;q, hnbyte);
-    write_lebn(out, rsa-&gt;dmp1, hnbyte);
-    write_lebn(out, rsa-&gt;dmq1, hnbyte);
-    write_lebn(out, rsa-&gt;iqmp, hnbyte);
-    write_lebn(out, rsa-&gt;d, nbyte);
+    RSA_get0_factors(rsa, &amp;p, &amp;q);
+    RSA_get0_crt_params(rsa, &amp;dmp1, &amp;dmq1, &amp;iqmp);
+    write_lebn(out, p, hnbyte);
+    write_lebn(out, q, hnbyte);
+    write_lebn(out, dmp1, hnbyte);
+    write_lebn(out, dmq1, hnbyte);
+    write_lebn(out, iqmp, hnbyte);
+    write_lebn(out, d, nbyte);
 }
 
 static void write_dsa(unsigned char **out, DSA *dsa, int ispub)
diff --git a/crypto/rsa/Makefile.in b/crypto/rsa/Makefile.in
index 5a8ecc4..199d887 100644
--- a/crypto/rsa/Makefile.in
+++ b/crypto/rsa/Makefile.in
@@ -18,11 +18,11 @@ LIB=$(TOP)/libcrypto.a
 LIBSRC= rsa_ossl.c rsa_gen.c rsa_lib.c rsa_sign.c rsa_saos.c rsa_err.c \
 	rsa_pk1.c rsa_ssl.c rsa_none.c rsa_oaep.c rsa_chk.c rsa_null.c \
 	rsa_pss.c rsa_x931.c rsa_asn1.c rsa_depr.c rsa_ameth.c rsa_prn.c \
-	rsa_pmeth.c rsa_crpt.c rsa_x931g.c
+	rsa_pmeth.c rsa_crpt.c rsa_x931g.c rsa_meth.c
 LIBOBJ= rsa_ossl.o rsa_gen.o rsa_lib.o rsa_sign.o rsa_saos.o rsa_err.o \
 	rsa_pk1.o rsa_ssl.o rsa_none.o rsa_oaep.o rsa_chk.o rsa_null.o \
 	rsa_pss.o rsa_x931.o rsa_asn1.o rsa_depr.o rsa_ameth.o rsa_prn.o \
-	rsa_pmeth.o rsa_crpt.o rsa_x931g.o
+	rsa_pmeth.o rsa_crpt.o rsa_x931g.o rsa_meth.o
 
 SRC= $(LIBSRC)
 
diff --git a/crypto/rsa/build.info b/crypto/rsa/build.info
index 012c9d0..39b7464 100644
--- a/crypto/rsa/build.info
+++ b/crypto/rsa/build.info
@@ -3,4 +3,4 @@ SOURCE[../../libcrypto]=\
         rsa_ossl.c rsa_gen.c rsa_lib.c rsa_sign.c rsa_saos.c rsa_err.c \
         rsa_pk1.c rsa_ssl.c rsa_none.c rsa_oaep.c rsa_chk.c rsa_null.c \
         rsa_pss.c rsa_x931.c rsa_asn1.c rsa_depr.c rsa_ameth.c rsa_prn.c \
-        rsa_pmeth.c rsa_crpt.c rsa_x931g.c
+        rsa_pmeth.c rsa_crpt.c rsa_x931g.c rsa_meth.c
diff --git a/crypto/rsa/rsa_ameth.c b/crypto/rsa/rsa_ameth.c
index ad51a44..4ff2665 100644
--- a/crypto/rsa/rsa_ameth.c
+++ b/crypto/rsa/rsa_ameth.c
@@ -60,11 +60,11 @@
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/asn1t.h&gt;
 #include &lt;openssl/x509.h&gt;
-#include &lt;openssl/rsa.h&gt;
 #include &lt;openssl/bn.h&gt;
 #include &lt;openssl/cms.h&gt;
 #include &quot;internal/asn1_int.h&quot;
 #include &quot;internal/evp_int.h&quot;
+#include &quot;rsa_locl.h&quot;
 
 #ifndef OPENSSL_NO_CMS
 static int rsa_cms_sign(CMS_SignerInfo *si);
diff --git a/crypto/rsa/rsa_asn1.c b/crypto/rsa/rsa_asn1.c
index 86a71b7..da8b240 100644
--- a/crypto/rsa/rsa_asn1.c
+++ b/crypto/rsa/rsa_asn1.c
@@ -59,9 +59,9 @@
 #include &lt;stdio.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/bn.h&gt;
-#include &lt;openssl/rsa.h&gt;
 #include &lt;openssl/x509.h&gt;
 #include &lt;openssl/asn1t.h&gt;
+#include &quot;rsa_locl.h&quot;
 
 /* Override the default free and new methods */
 static int rsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
diff --git a/crypto/rsa/rsa_chk.c b/crypto/rsa/rsa_chk.c
index 02d3c41..f780508 100644
--- a/crypto/rsa/rsa_chk.c
+++ b/crypto/rsa/rsa_chk.c
@@ -49,7 +49,7 @@
 
 #include &lt;openssl/bn.h&gt;
 #include &lt;openssl/err.h&gt;
-#include &lt;openssl/rsa.h&gt;
+#include &quot;rsa_locl.h&quot;
 
 int RSA_check_key(const RSA *key)
 {
diff --git a/crypto/rsa/rsa_crpt.c b/crypto/rsa/rsa_crpt.c
index cec4a7c..6cc3c70 100644
--- a/crypto/rsa/rsa_crpt.c
+++ b/crypto/rsa/rsa_crpt.c
@@ -60,8 +60,8 @@
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/lhash.h&gt;
 #include &quot;internal/bn_int.h&quot;
-#include &lt;openssl/rsa.h&gt;
 #include &lt;openssl/rand.h&gt;
+#include &quot;rsa_locl.h&quot;
 
 int RSA_bits(const RSA *r)
 {
diff --git a/crypto/rsa/rsa_gen.c b/crypto/rsa/rsa_gen.c
index 6ec2749..c456258 100644
--- a/crypto/rsa/rsa_gen.c
+++ b/crypto/rsa/rsa_gen.c
@@ -65,7 +65,7 @@
 #include &lt;time.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/bn.h&gt;
-#include &lt;openssl/rsa.h&gt;
+#include &quot;rsa_locl.h&quot;
 
 static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value,
                               BN_GENCB *cb);
diff --git a/crypto/rsa/rsa_lib.c b/crypto/rsa/rsa_lib.c
index bd881ed..7ee575d 100644
--- a/crypto/rsa/rsa_lib.c
+++ b/crypto/rsa/rsa_lib.c
@@ -60,9 +60,9 @@
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/lhash.h&gt;
 #include &quot;internal/bn_int.h&quot;
-#include &lt;openssl/rsa.h&gt;
 #include &lt;openssl/rand.h&gt;
 #include &lt;openssl/engine.h&gt;
+#include &quot;rsa_locl.h&quot;
 
 static const RSA_METHOD *default_RSA_meth = NULL;
 
@@ -283,3 +283,96 @@ int RSA_security_bits(const RSA *rsa)
 {
     return BN_security_bits(BN_num_bits(rsa-&gt;n), -1);
 }
+
+int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)
+{
+    /* d is the private component and may be NULL */
+    if (n == NULL || e == NULL)
+        return 0;
+
+    BN_free(r-&gt;n);
+    BN_free(r-&gt;e);
+    BN_free(r-&gt;d);
+    r-&gt;n = n;
+    r-&gt;e = e;
+    r-&gt;d = d;
+
+    return 1;
+}
+
+int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q)
+{
+    if (p == NULL || q == NULL)
+        return 0;
+
+    BN_free(r-&gt;p);
+    BN_free(r-&gt;q);
+    r-&gt;p = p;
+    r-&gt;q = q;
+
+    return 1;
+}
+
+int RSA_set0_crt_params(RSA *r, BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp)
+{
+    if (dmp1 == NULL || dmq1 == NULL || iqmp == NULL)
+        return 0;
+
+    BN_free(r-&gt;dmp1);
+    BN_free(r-&gt;dmq1);
+    BN_free(r-&gt;iqmp);
+    r-&gt;dmp1 = dmp1;
+    r-&gt;dmq1 = dmq1;
+    r-&gt;iqmp = iqmp;
+
+    return 1;
+}
+
+void RSA_get0_key(const RSA *r, BIGNUM **n, BIGNUM **e, BIGNUM **d)
+{
+    if (n != NULL)
+        *n = r-&gt;n;
+    if (e != NULL)
+        *e = r-&gt;e;
+    if (d != NULL)
+        *d = r-&gt;d;
+}
+
+void RSA_get0_factors(const RSA *r, BIGNUM **p, BIGNUM **q)
+{
+    if (p != NULL)
+        *p = r-&gt;p;
+    if (q != NULL)
+        *q = r-&gt;q;
+}
+
+void RSA_get0_crt_params(const RSA *r,
+                         BIGNUM **dmp1, BIGNUM **dmq1, BIGNUM **iqmp)
+{
+    if (dmp1 != NULL)
+        *dmp1 = r-&gt;dmp1;
+    if (dmq1 != NULL)
+        *dmq1 = r-&gt;dmq1;
+    if (iqmp != NULL)
+        *iqmp = r-&gt;iqmp;
+}
+
+void RSA_clear_flags(RSA *r, int flags)
+{
+    r-&gt;flags &amp;= ~flags;
+}
+
+int RSA_test_flags(const RSA *r, int flags)
+{
+    return r-&gt;flags &amp; flags;
+}
+
+void RSA_set_flags(RSA *r, int flags)
+{
+    r-&gt;flags |= flags;
+}
+
+ENGINE *RSA_get0_engine(RSA *r)
+{
+    return r-&gt;engine;
+}
diff --git a/crypto/rsa/rsa_locl.h b/crypto/rsa/rsa_locl.h
index 3e88187..598fcb7 100644
--- a/crypto/rsa/rsa_locl.h
+++ b/crypto/rsa/rsa_locl.h
@@ -1,3 +1,96 @@
+/*
+ * Copyright 2006-2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL licenses, (the &quot;License&quot;);
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ * or in the file LICENSE in the source distribution.
+ */
+
+#include &lt;openssl/rsa.h&gt;
+
+struct rsa_st {
+    /*
+     * The first parameter is used to pickup errors where this is passed
+     * instead of aEVP_PKEY, it is set to 0
+     */
+    int pad;
+    long version;
+    const RSA_METHOD *meth;
+    /* functional reference if 'meth' is ENGINE-provided */
+    ENGINE *engine;
+    BIGNUM *n;
+    BIGNUM *e;
+    BIGNUM *d;
+    BIGNUM *p;
+    BIGNUM *q;
+    BIGNUM *dmp1;
+    BIGNUM *dmq1;
+    BIGNUM *iqmp;
+    /* be careful using this if the RSA structure is shared */
+    CRYPTO_EX_DATA ex_data;
+    int references;
+    int flags;
+    /* Used to cache montgomery values */
+    BN_MONT_CTX *_method_mod_n;
+    BN_MONT_CTX *_method_mod_p;
+    BN_MONT_CTX *_method_mod_q;
+    /*
+     * all BIGNUM values are actually in the following data, if it is not
+     * NULL
+     */
+    char *bignum_data;
+    BN_BLINDING *blinding;
+    BN_BLINDING *mt_blinding;
+    CRYPTO_RWLOCK *lock;
+};
+
+struct rsa_meth_st {
+    char *name;
+    int (*rsa_pub_enc) (int flen, const unsigned char *from,
+                        unsigned char *to, RSA *rsa, int padding);
+    int (*rsa_pub_dec) (int flen, const unsigned char *from,
+                        unsigned char *to, RSA *rsa, int padding);
+    int (*rsa_priv_enc) (int flen, const unsigned char *from,
+                         unsigned char *to, RSA *rsa, int padding);
+    int (*rsa_priv_dec) (int flen, const unsigned char *from,
+                         unsigned char *to, RSA *rsa, int padding);
+    /* Can be null */
+    int (*rsa_mod_exp) (BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx);
+    /* Can be null */
+    int (*bn_mod_exp) (BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+                       const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
+    /* called at new */
+    int (*init) (RSA *rsa);
+    /* called at free */
+    int (*finish) (RSA *rsa);
+    /* RSA_METHOD_FLAG_* things */
+    int flags;
+    /* may be needed! */
+    char *app_data;
+    /*
+     * New sign and verify functions: some libraries don't allow arbitrary
+     * data to be signed/verified: this allows them to be used. Note: for
+     * this to work the RSA_public_decrypt() and RSA_private_encrypt() should
+     * *NOT* be used RSA_sign(), RSA_verify() should be used instead.
+     */
+    int (*rsa_sign) (int type,
+                     const unsigned char *m, unsigned int m_length,
+                     unsigned char *sigret, unsigned int *siglen,
+                     const RSA *rsa);
+    int (*rsa_verify) (int dtype, const unsigned char *m,
+                       unsigned int m_length, const unsigned char *sigbuf,
+                       unsigned int siglen, const RSA *rsa);
+    /*
+     * If this callback is NULL, the builtin software RSA key-gen will be
+     * used. This is for behavioural compatibility whilst the code gets
+     * rewired, but one day it would be nice to assume there are no such
+     * things as &quot;builtin software&quot; implementations.
+     */
+    int (*rsa_keygen) (RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
+};
+
 extern int int_rsa_verify(int dtype, const unsigned char *m,
                           unsigned int m_len, unsigned char *rm,
                           size_t *prm_len, const unsigned char *sigbuf,
diff --git a/crypto/rsa/rsa_meth.c b/crypto/rsa/rsa_meth.c
new file mode 100644
index 0000000..6c7679d
--- /dev/null
+++ b/crypto/rsa/rsa_meth.c
@@ -0,0 +1,257 @@
+/*
+ * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL licenses, (the &quot;License&quot;);
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ * or in the file LICENSE in the source distribution.
+ */
+
+#include &lt;string.h&gt;
+#include &quot;rsa_locl.h&quot;
+
+RSA_METHOD *RSA_meth_new(const char *name, int flags)
+{
+    RSA_METHOD *meth = OPENSSL_zalloc(sizeof(RSA_METHOD));
+
+    if (meth != NULL) {
+        meth-&gt;name = OPENSSL_strdup(name);
+        meth-&gt;flags = flags;
+    }
+
+    return meth;
+}
+
+void RSA_meth_free(RSA_METHOD *meth)
+{
+    if (meth != NULL) {
+        if (meth-&gt;name != NULL)
+            OPENSSL_free(meth-&gt;name);
+        OPENSSL_free(meth);
+    }
+}
+
+RSA_METHOD *RSA_meth_dup(const RSA_METHOD *meth)
+{
+    RSA_METHOD *ret;
+
+    ret = OPENSSL_malloc(sizeof(RSA_METHOD));
+
+    if (ret != NULL) {
+        memcpy(ret, meth, sizeof(*meth));
+        ret-&gt;name = OPENSSL_strdup(meth-&gt;name);
+    }
+
+    return ret;
+}
+
+const char *RSA_meth_get0_name(const RSA_METHOD *meth)
+{
+    return meth-&gt;name;
+}
+
+int RSA_meth_set1_name(RSA_METHOD *meth, const char *name)
+{
+    OPENSSL_free(meth-&gt;name);
+    meth-&gt;name = OPENSSL_strdup(name);
+
+    return meth-&gt;name != NULL;
+}
+
+int RSA_meth_get_flags(RSA_METHOD *meth)
+{
+    return meth-&gt;flags;
+}
+
+int RSA_meth_set_flags(RSA_METHOD *meth, int flags)
+{
+    meth-&gt;flags = flags;
+    return 1;
+}
+
+void *RSA_meth_get0_app_data(const RSA_METHOD *meth)
+{
+    return meth-&gt;app_data;
+}
+
+int RSA_meth_set0_app_data(RSA_METHOD *meth, void *app_data)
+{
+    meth-&gt;app_data = app_data;
+    return 1;
+}
+
+int (*RSA_meth_get_pub_enc(const RSA_METHOD *meth))
+    (int flen, const unsigned char *from,
+     unsigned char *to, RSA *rsa, int padding)
+{
+    return meth-&gt;rsa_pub_enc;
+}
+
+int RSA_meth_set_pub_enc(RSA_METHOD *meth,
+                         int (*pub_enc) (int flen, const unsigned char *from,
+                                         unsigned char *to, RSA *rsa,
+                                         int padding))
+{
+    meth-&gt;rsa_pub_enc = pub_enc;
+    return 1;
+}
+
+int (*RSA_meth_get_pub_dec(const RSA_METHOD *meth))
+    (int flen, const unsigned char *from,
+     unsigned char *to, RSA *rsa, int padding)
+{
+    return meth-&gt;rsa_pub_dec;
+}
+
+int RSA_meth_set_pub_dec(RSA_METHOD *meth,
+                         int (*pub_dec) (int flen, const unsigned char *from,
+                                         unsigned char *to, RSA *rsa,
+                                         int padding))
+{
+    meth-&gt;rsa_pub_dec = pub_dec;
+    return 1;
+}
+
+int (*RSA_meth_get_priv_enc(const RSA_METHOD *meth))
+    (int flen, const unsigned char *from,
+     unsigned char *to, RSA *rsa, int padding)
+{
+    return meth-&gt;rsa_priv_enc;
+}
+
+int RSA_meth_set_priv_enc(RSA_METHOD *meth,
+                          int (*priv_enc) (int flen, const unsigned char *from,
+                                           unsigned char *to, RSA *rsa,
+                                           int padding))
+{
+    meth-&gt;rsa_priv_enc = priv_enc;
+    return 1;
+}
+
+int (*RSA_meth_get_priv_dec(const RSA_METHOD *meth))
+    (int flen, const unsigned char *from,
+     unsigned char *to, RSA *rsa, int padding)
+{
+    return meth-&gt;rsa_priv_dec;
+}
+
+int RSA_meth_set_priv_dec(RSA_METHOD *meth,
+                          int (*priv_dec) (int flen, const unsigned char *from,
+                                           unsigned char *to, RSA *rsa,
+                                           int padding))
+{
+    meth-&gt;rsa_priv_dec = priv_dec;
+    return 1;
+}
+
+    /* Can be null */
+int (*RSA_meth_get_mod_exp(const RSA_METHOD *meth))
+    (BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
+{
+    return meth-&gt;rsa_mod_exp;
+}
+
+int RSA_meth_set_mod_exp(RSA_METHOD *meth,
+                         int (*mod_exp) (BIGNUM *r0, const BIGNUM *I, RSA *rsa,
+                                         BN_CTX *ctx))
+{
+    meth-&gt;rsa_mod_exp = mod_exp;
+    return 1;
+}
+
+    /* Can be null */
+int (*RSA_meth_get_bn_mod_exp(const RSA_METHOD *meth))
+    (BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+     const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
+{
+    return meth-&gt;bn_mod_exp;
+}
+
+int RSA_meth_set_bn_mod_exp(RSA_METHOD *meth,
+                            int (*bn_mod_exp) (BIGNUM *r,
+                                               const BIGNUM *a,
+                                               const BIGNUM *p,
+                                               const BIGNUM *m,
+                                               BN_CTX *ctx,
+                                               BN_MONT_CTX *m_ctx))
+{
+    meth-&gt;bn_mod_exp = bn_mod_exp;
+    return 1;
+}
+
+    /* called at new */
+int (*RSA_meth_get_init(const RSA_METHOD *meth)) (RSA *rsa)
+{
+    return meth-&gt;init;
+}
+
+int RSA_meth_set_init(RSA_METHOD *meth, int (*init) (RSA *rsa))
+{
+    meth-&gt;init = init;
+    return 1;
+}
+
+    /* called at free */
+int (*RSA_meth_get_finish(const RSA_METHOD *meth)) (RSA *rsa)
+{
+    return meth-&gt;finish;
+}
+
+int RSA_meth_set_finish(RSA_METHOD *meth, int (*finish) (RSA *rsa))
+{
+    meth-&gt;finish = finish;
+    return 1;
+}
+
+int (*RSA_meth_get_sign(const RSA_METHOD *meth))
+    (int type,
+     const unsigned char *m, unsigned int m_length,
+     unsigned char *sigret, unsigned int *siglen,
+     const RSA *rsa)
+{
+    return meth-&gt;rsa_sign;
+}
+
+int RSA_meth_set_sign(RSA_METHOD *meth,
+                      int (*sign) (int type, const unsigned char *m,
+                                   unsigned int m_length,
+                                   unsigned char *sigret, unsigned int *siglen,
+                                   const RSA *rsa))
+{
+    meth-&gt;rsa_sign = sign;
+    return 1;
+}
+
+int (*RSA_meth_get_verify(const RSA_METHOD *meth))
+    (int dtype, const unsigned char *m,
+     unsigned int m_length, const unsigned char *sigbuf,
+     unsigned int siglen, const RSA *rsa)
+{
+    return meth-&gt;rsa_verify;
+}
+
+int RSA_meth_set_verify(RSA_METHOD *meth,
+                        int (*verify) (int dtype, const unsigned char *m,
+                                       unsigned int m_length,
+                                       const unsigned char *sigbuf,
+                                       unsigned int siglen, const RSA *rsa))
+{
+    meth-&gt;rsa_verify = verify;
+    return 1;
+}
+
+int (*RSA_meth_get_keygen(const RSA_METHOD *meth))
+    (RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb)
+{
+    return meth-&gt;rsa_keygen;
+}
+
+int RSA_meth_set_keygen(RSA_METHOD *meth,
+                        int (*keygen) (RSA *rsa, int bits, BIGNUM *e,
+                                       BN_GENCB *cb))
+{
+    meth-&gt;rsa_keygen = keygen;
+    return 1;
+}
+
diff --git a/crypto/rsa/rsa_null.c b/crypto/rsa/rsa_null.c
index 6ac2249..9f739f7 100644
--- a/crypto/rsa/rsa_null.c
+++ b/crypto/rsa/rsa_null.c
@@ -59,8 +59,8 @@
 #include &lt;stdio.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/bn.h&gt;
-#include &lt;openssl/rsa.h&gt;
 #include &lt;openssl/rand.h&gt;
+#include &quot;rsa_locl.h&quot;
 
 /*
  * This is a dummy RSA implementation that just returns errors when called.
diff --git a/crypto/rsa/rsa_oaep.c b/crypto/rsa/rsa_oaep.c
index 3557884..27a6e78 100644
--- a/crypto/rsa/rsa_oaep.c
+++ b/crypto/rsa/rsa_oaep.c
@@ -21,10 +21,10 @@
 #include &lt;stdio.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/bn.h&gt;
-#include &lt;openssl/rsa.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/rand.h&gt;
 #include &lt;openssl/sha.h&gt;
+#include &quot;rsa_locl.h&quot;
 
 int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,
                                const unsigned char *from, int flen,
diff --git a/crypto/rsa/rsa_ossl.c b/crypto/rsa/rsa_ossl.c
index 8d3383b..5c3c0bf 100644
--- a/crypto/rsa/rsa_ossl.c
+++ b/crypto/rsa/rsa_ossl.c
@@ -110,8 +110,8 @@
 
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;internal/bn_int.h&quot;
-#include &lt;openssl/rsa.h&gt;
 #include &lt;openssl/rand.h&gt;
+#include &quot;rsa_locl.h&quot;
 
 #ifndef RSA_NULL
 
diff --git a/crypto/rsa/rsa_x931g.c b/crypto/rsa/rsa_x931g.c
index d4c520c..1e164e8 100644
--- a/crypto/rsa/rsa_x931g.c
+++ b/crypto/rsa/rsa_x931g.c
@@ -60,7 +60,7 @@
 #include &lt;time.h&gt;
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/bn.h&gt;
-#include &lt;openssl/rsa.h&gt;
+#include &quot;rsa_locl.h&quot;
 
 /* X9.31 RSA key derivation and generation */
 
diff --git a/doc/crypto/RSA_get0_key.pod b/doc/crypto/RSA_get0_key.pod
new file mode 100644
index 0000000..5caf9dd
--- /dev/null
+++ b/doc/crypto/RSA_get0_key.pod
@@ -0,0 +1,86 @@
+=pod
+
+=head1 NAME
+
+RSA_set0_key, RSA_set0_factors, RSA_set0_crt_params, RSA_get0_key,
+RSA_get0_factors, RSA_get0_crt_params, RSA_clear_flags,
+RSA_test_flags, RSA_set_flags, RSA_get0_engine - Routines for getting
+and setting data in an RSA object
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/rsa.h&gt;
+
+ int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d);
+ int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q);
+ int RSA_set0_crt_params(RSA *r,BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp);
+ void RSA_get0_key(const RSA *r, BIGNUM **n, BIGNUM **e, BIGNUM **d);
+ void RSA_get0_factors(const RSA *r, BIGNUM **p, BIGNUM **q);
+ void RSA_get0_crt_params(const RSA *r,
+                          BIGNUM **dmp1, BIGNUM **dmq1, BIGNUM **iqmp);
+ void RSA_clear_flags(RSA *r, int flags);
+ int RSA_test_flags(const RSA *r, int flags);
+ void RSA_set_flags(RSA *r, int flags);
+ ENGINE *RSA_get0_engine(RSA *r);
+
+=head1 DESCRIPTION
+
+An RSA object contains the components for the public and private key,
+B&lt;n&gt;, B&lt;e&gt;, B&lt;d&gt;, B&lt;p&gt;, B&lt;q&gt;, B&lt;dmp1&gt;, B&lt;dmq1&gt; and B&lt;iqmp&gt;.  B&lt;n&gt; is
+the modulus common to both public and private key, B&lt;e&gt; is the public
+exponent and B&lt;d&gt; is the private exponent.  B&lt;p&gt;, B&lt;q&gt;, B&lt;dmp1&gt;,
+B&lt;dmq1&gt; and B&lt;iqmp&gt; are the factors for the second representation of a
+private key (see PKCS#1 section 3 Key Types), where B&lt;p&gt; and B&lt;q&gt; are
+the first and second factor of B&lt;n&gt; and B&lt;dmp1&gt;, B&lt;dmq1&gt; and B&lt;iqmp&gt;
+are the exponents and coefficient for CRT calculations.
+
+The B&lt;n&gt;, B&lt;e&gt; and B&lt;d&gt; parameters can be obtained by calling
+RSA_get0_key().  If they have not been set yet, then B&lt;*n&gt;, B&lt;*e&gt; and
+B&lt;*d&gt; will be set to NULL.  Otherwise, they are set to pointers to
+their respective values. These point directly to the internal
+representations of the values and therefore should not be freed
+by the caller.
+
+The B&lt;n&gt;, B&lt;e&gt; and B&lt;d&gt; parameter values can be set by calling
+RSA_set0_key() and passing the new values for B&lt;n&gt;, B&lt;e&gt; and B&lt;d&gt; as
+parameters to the function. Calling this function transfers the memory
+management of the values to the RSA object, and therefore the values
+that have been passed in should not be freed by the caller after this
+function has been called.
+
+In a similar fashion, the B&lt;p&gt; and B&lt;q&gt; parameters can be obtained and
+set with RSA_get0_factors() and RSA_set0_factors(), and the B&lt;dmp1&gt;,
+B&lt;dmq1&gt; and B&lt;iqmp&gt; parameters can be obtained and set with
+RSA_get0_crt_params() and RSA_set0_crt_params().
+
+RSA_set_flags() sets the flags in the B&lt;flags&gt; parameter on the RSA
+object. Multiple flags can be passed in one go (bitwise ORed together).
+Any flags that are already set are left set. RSA_test_flags() tests to
+see whether the flags passed in the B&lt;flags&gt; parameter are currently
+set in the RSA object. Multiple flags can be tested in one go. All
+flags that are currently set are returned, or zero if none of the
+flags are set. RSA_clear_flags() clears the specified flags within the
+RSA object.
+
+RSA_get0_engine() returns a handle to the ENGINE that has been set for
+this RSA object, or NULL if no such ENGINE has been set.
+
+=head1 RETURN VALUES
+
+RSA_set0_key(), RSA_set0_factors and RSA_set0_crt_params() return 1 on
+success or 0 on failure.
+
+RSA_test_flags() returns the current state of the flags in the RSA object.
+
+RSA_get0_engine() returns the ENGINE set for the RSA object or NULL if no
+ENGINE has been set.
+
+=head1 SEE ALSO
+
+L&lt;rsa(3)&gt;, L&lt;RSA_new(3)&gt;, L&lt;RSA_size(3)&gt;
+
+=head1 HISTORY
+
+The functions described here were added in OpenSSL version 1.1.0.
+
+=cut
diff --git a/doc/crypto/RSA_meth_new.pod b/doc/crypto/RSA_meth_new.pod
new file mode 100644
index 0000000..e6499b7
--- /dev/null
+++ b/doc/crypto/RSA_meth_new.pod
@@ -0,0 +1,225 @@
+=pod
+
+=head1 NAME
+
+RSA_meth_new, RSA_meth_free, RSA_meth_dup, RSA_meth_get0_name,
+RSA_meth_set1_name, RSA_meth_get_flags, RSA_meth_set_flags,
+RSA_meth_get_app_data, RSA_meth_set_app_data, RSA_meth_get_pub_enc,
+RSA_meth_set_pub_enc, RSA_meth_get_pub_dec, RSA_meth_set_pub_dec,
+RSA_meth_get_priv_enc, RSA_meth_set_priv_enc, RSA_meth_get_priv_dec,
+RSA_meth_set_priv_dec, RSA_meth_get_mod_exp, RSA_meth_set_mod_exp,
+RSA_meth_get_bn_mod_exp, RSA_meth_set_bn_mod_exp, RSA_meth_get_init,
+RSA_meth_set_init, RSA_meth_get_finish, RSA_meth_set_finish,
+RSA_meth_get_sign, RSA_meth_set_sign, RSA_meth_get_verify,
+RSA_meth_set_verify, RSA_meth_get_keygen, RSA_meth_set_keygen
+- Routines to build up RSA methods
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/rsa.h&gt;
+
+ RSA_METHOD *RSA_meth_new(const char *name, int flags);
+ void RSA_meth_free(RSA_METHOD *meth);
+ RSA_METHOD *RSA_meth_dup(const RSA_METHOD *meth);
+ const char *RSA_meth_get0_name(const RSA_METHOD *meth);
+ int RSA_meth_set1_name(RSA_METHOD *meth, const char *name);
+ int RSA_meth_get_flags(RSA_METHOD *meth);
+ int RSA_meth_set_flags(RSA_METHOD *meth, int flags);
+ void *RSA_meth_get0_app_data(const RSA_METHOD *meth);
+ int RSA_meth_set0_app_data(RSA_METHOD *meth, void *app_data);
+ int (*RSA_meth_get_pub_enc(const RSA_METHOD *meth))
+     (int flen, const unsigned char *from,
+      unsigned char *to, RSA *rsa, int padding);
+ int RSA_meth_set_pub_enc(RSA_METHOD *rsa,
+                          int (*pub_enc) (int flen, const unsigned char *from,
+                                          unsigned char *to, RSA *rsa,
+                                          int padding));
+ int (*RSA_meth_get_pub_dec(const RSA_METHOD *meth))
+     (int flen, const unsigned char *from,
+      unsigned char *to, RSA *rsa, int padding);
+ int RSA_meth_set_pub_dec(RSA_METHOD *rsa,
+                          int (*pub_dec) (int flen, const unsigned char *from,
+                                          unsigned char *to, RSA *rsa,
+                                          int padding));
+ int (*RSA_meth_get_priv_enc(const RSA_METHOD *meth))
+     (int flen, const unsigned char *from,
+      unsigned char *to, RSA *rsa, int padding);
+ int RSA_meth_set_priv_enc(RSA_METHOD *rsa,
+                           int (*priv_enc) (int flen, const unsigned char *from,
+                                            unsigned char *to, RSA *rsa,
+                                            int padding));
+ int (*RSA_meth_get_priv_dec(const RSA_METHOD *meth))
+     (int flen, const unsigned char *from,
+      unsigned char *to, RSA *rsa, int padding);
+ int RSA_meth_set_priv_dec(RSA_METHOD *rsa,
+                           int (*priv_dec) (int flen, const unsigned char *from,
+                                            unsigned char *to, RSA *rsa,
+                                            int padding));
+     /* Can be null */
+ int (*RSA_meth_get_mod_exp(const RSA_METHOD *meth))
+     (BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx);
+ int RSA_meth_set_mod_exp(RSA_METHOD *rsa,
+                          int (*mod_exp) (BIGNUM *r0, const BIGNUM *I, RSA *rsa,
+                                          BN_CTX *ctx));
+     /* Can be null */
+ int (*RSA_meth_get_bn_mod_exp(const RSA_METHOD *meth))
+     (BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+      const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
+ int RSA_meth_set_bn_mod_exp(RSA_METHOD *rsa,
+                             int (*bn_mod_exp) (BIGNUM *r,
+                                                const BIGNUM *a,
+                                                const BIGNUM *p,
+                                                const BIGNUM *m,
+                                                BN_CTX *ctx,
+                                                BN_MONT_CTX *m_ctx));
+     /* called at new */
+ int (*RSA_meth_get_init(const RSA_METHOD *meth)) (RSA *rsa);
+ int RSA_meth_set_init(RSA_METHOD *rsa, int (*init) (RSA *rsa));
+     /* called at free */
+ int (*RSA_meth_get_finish(const RSA_METHOD *meth)) (RSA *rsa);
+ int RSA_meth_set_finish(RSA_METHOD *rsa, int (*finish) (RSA *rsa));
+ int (*RSA_meth_get_sign(const RSA_METHOD *meth))
+     (int type,
+      const unsigned char *m, unsigned int m_length,
+      unsigned char *sigret, unsigned int *siglen,
+      const RSA *rsa);
+ int RSA_meth_set_sign(RSA_METHOD *rsa,
+                       int (*sign) (int type, const unsigned char *m,
+                                    unsigned int m_length,
+                                    unsigned char *sigret, unsigned int *siglen,
+                                    const RSA *rsa));
+ int (*RSA_meth_get_verify(const RSA_METHOD *meth))
+     (int dtype, const unsigned char *m,
+      unsigned int m_length, const unsigned char *sigbuf,
+      unsigned int siglen, const RSA *rsa);
+ int RSA_meth_set_verify(RSA_METHOD *rsa,
+                         int (*verify) (int dtype, const unsigned char *m,
+                                        unsigned int m_length,
+                                        const unsigned char *sigbuf,
+                                        unsigned int siglen, const RSA *rsa));
+ int (*RSA_meth_get_keygen(const RSA_METHOD *meth))
+     (RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
+ int RSA_meth_set_keygen(RSA_METHOD *rsa,
+                         int (*keygen) (RSA *rsa, int bits, BIGNUM *e,
+                                        BN_GENCB *cb));
+
+=head1 DESCRIPTION
+
+The B&lt;RSA_METHOD&gt; type is a structure used for the provision of custom
+RSA implementations. It provides a set of of functions used by OpenSSL
+for the implementation of the various RSA capabilities. See the L&lt;rsa&gt;
+page for more information.
+
+RSA_meth_new() creates a new B&lt;RSA_METHOD&gt; structure. It should be
+given a unique B&lt;name&gt; and a set of B&lt;flags&gt;. The B&lt;name&gt; should be a
+NULL terminated string, which will be duplicated and stored in the
+B&lt;RSA_METHOD&gt; object. It is the callers responsibility to free the
+original string. The flags will be used during the construction of a
+new B&lt;RSA&gt; object based on this B&lt;RSA_METHOD&gt;. Any new B&lt;RSA&gt; object
+will have those flags set by default.
+
+RSA_meth_dup() creates a duplicate copy of the B&lt;RSA_METHOD&gt; object
+passed as a parameter. This might be useful for creating a new
+B&lt;RSA_METHOD&gt; based on an existing one, but with some differences.
+
+RSA_meth_free() destroys an B&lt;RSA_METHOD&gt; structure and frees up any
+memory associated with it.
+
+RSA_meth_get0_name() will return a pointer to the name of this
+RSA_METHOD. This is a pointer to the internal name string and so
+should not be freed by the caller. RSA_meth_set1_name() sets the name
+of the RSA_METHOD to B&lt;name&gt;. The string is duplicated and the copy is
+stored in the RSA_METHOD structure, so the caller remains responsible
+for freeing the memory associated with the name.
+
+RSA_meth_get_flags() returns the current value of the flags associated
+with this RSA_METHOD. RSA_meth_set_flags() provides the ability to set
+these flags.
+
+The functions RSA_meth_get0_app_data() and RSA_meth_set0_app_data()
+provide the ability to associate implementation specific data with the
+RSA_METHOD. It is the application's responsibility to free this data
+before the RSA_METHOD is freed via a call to RSA_meth_free().
+
+RSA_meth_get_sign() and RSA_meth_set_sign() get and set the function
+used for creating an RSA signature respectively. This function will be
+called in response to the application calling RSA_sign(). The
+parameters for the function have the same meaning as for RSA_sign().
+
+RSA_meth_get_verify() and RSA_meth_set_verify() get and set the
+function used for verifying an RSA signature respectively. This
+function will be called in response to the application calling
+RSA_verify(). The parameters for the function have the same meaning as
+for RSA_verify().
+
+RSA_meth_get_mod_exp() and RSA_meth_set_mod_exp() get and set the
+function used for CRT computations.
+
+RSA_meth_get_bn_mod_exp() and RSA_meth_set_bn_mod_exp() get and set
+the function used for CRT computations, specifically the following
+value:
+
+ r = a ^ p mod m
+
+Both the mod_exp() and bn_mod_exp() functions are called by the
+default OpenSSL method during encryption, decryption, signing and
+verification.
+
+RSA_meth_get_init() and RSA_meth_set_init() get and set the function
+used for creating a new RSA instance respectively. This function will
+be called in response to the application calling RSA_new() (if the
+current default RSA_METHOD is this one) or RSA_new_method(). The
+RSA_new() and RSA_new_method() functions will allocate the memory for
+the new RSA object, and a pointer to this newly allocated structure
+will be passed as a parameter to the function. This function may be
+NULL.
+
+RSA_meth_get_finish() and RSA_meth_set_finish() get and set the
+function used for destroying an instance of an RSA object respectively.
+This function will be called in response to the application calling
+RSA_free(). A pointer to the RSA to be destroyed is passed as a
+parameter. The destroy function should be used for RSA implementation
+specific clean up. The memory for the RSA itself should not be freed
+by this function. This function may be NULL.
+
+RSA_meth_get_keygen() and RSA_meth_set_keygen() get and set the
+function used for generating a new RSA key pair respectively. This
+function will be called in response to the application calling
+RSA_generate_key(). The parameter for the function has the same
+meaning as for RSA_generate_key().
+
+RSA_meth_get_pub_enc(), RSA_meth_set_pub_enc(),
+RSA_meth_get_pub_dec(), RSA_meth_set_pub_dec(),
+RSA_meth_get_priv_enc(), RSA_meth_set_priv_enc(),
+RSA_meth_get_priv_dec(), RSA_meth_set_priv_dec() get and set the
+functions used for public and private key encryption and decryption.
+These functions will be called in response to the application calling
+RSA_public_encrypt(), RSA_private_decrypt(), RSA_private_encrypt() and
+RSA_public_decrypt() and take the same parameters as those.
+
+
+=head1 RETURN VALUES
+
+RSA_meth_new() and RSA_meth_dup() return the newly allocated
+RSA_METHOD object or NULL on failure.
+
+RSA_meth_get0_name() and RSA_meth_get_flags() return the name and
+flags associated with the RSA_METHOD respectively.
+
+All other RSA_meth_get_*() functions return the appropriate function
+pointer that has been set in the RSA_METHOD, or NULL if no such
+pointer has yet been set.
+
+RSA_meth_set1_name and all RSA_meth_set_*() functions return 1 on
+success or 0 on failure.
+
+=head1 SEE ALSO
+
+L&lt;rsa(3)&gt;, L&lt;RSA_new(3)&gt;, L&lt;RSA_generate_key(3)&gt;, L&lt;RSA_sign(3)&gt;,
+L&lt;RSA_set_method(3)&gt;, L&lt;RSA_size(3)&gt;, L&lt;RSA_get0_key(3)&gt;
+
+=head1 HISTORY
+
+The functions described here were added in OpenSSL version 1.1.0.
+
+=cut
diff --git a/doc/crypto/rsa.pod b/doc/crypto/rsa.pod
index 9c42923..a1341b8 100644
--- a/doc/crypto/rsa.pod
+++ b/doc/crypto/rsa.pod
@@ -58,25 +58,12 @@ rsa - RSA public key cryptosystem
 These functions implement RSA public key encryption and signatures
 as defined in PKCS #1 v2.0 [RFC 2437].
 
-The B&lt;RSA&gt; structure consists of several BIGNUM components. It can
-contain public as well as private RSA keys:
-
- struct
-        {
-        BIGNUM *n;		// public modulus
-        BIGNUM *e;		// public exponent
-        BIGNUM *d;		// private exponent
-        BIGNUM *p;		// secret prime factor
-        BIGNUM *q;		// secret prime factor
-        BIGNUM *dmp1;		// d mod (p-1)
-        BIGNUM *dmq1;		// d mod (q-1)
-        BIGNUM *iqmp;		// q^-1 mod p
-	// ...
-        };
- RSA
-
-In public keys, the private exponent and the related secret values are
-B&lt;NULL&gt;.
+The B&lt;RSA&gt; structure consists of the BIGNUM components B&lt;n&gt;, B&lt;e&gt;,
+B&lt;d&gt;, B&lt;p&gt;, B&lt;q&gt;, B&lt;dmp1&gt;, B&lt;dmq1&gt; and B&lt;iqmp&gt;, which represent public
+as well as private RSA keys.
+
+In public keys, the private exponent B&lt;d&gt; and the related secret
+values B&lt;p&gt;, B&lt;q&gt;, B&lt;dmp1&gt;, B&lt;dmq1&gt; and B&lt;iqmp&gt; are B&lt;NULL&gt;.
 
 B&lt;p&gt;, B&lt;q&gt;, B&lt;dmp1&gt;, B&lt;dmq1&gt; and B&lt;iqmp&gt; may be B&lt;NULL&gt; in private
 keys, but the RSA operations are much faster when these values are
@@ -101,7 +88,7 @@ RSA was covered by a US patent which expired in September 2000.
 =head1 SEE ALSO
 
 L&lt;rsa(1)&gt;, L&lt;bn(3)&gt;, L&lt;dsa(3)&gt;, L&lt;dh(3)&gt;,
-L&lt;rand(3)&gt;, L&lt;engine(3)&gt;, L&lt;RSA_new(3)&gt;,
+L&lt;rand(3)&gt;, L&lt;engine(3)&gt;, L&lt;RSA_new(3)&gt;, L&lt;RSA_set0_key(3)&gt;
 L&lt;RSA_public_encrypt(3)&gt;,
 L&lt;RSA_sign(3)&gt;, L&lt;RSA_size(3)&gt;,
 L&lt;RSA_generate_key(3)&gt;,
diff --git a/engines/e_dasync.c b/engines/e_dasync.c
index 0e10f6d..2ee7d63 100644
--- a/engines/e_dasync.c
+++ b/engines/e_dasync.c
@@ -149,23 +149,7 @@ static int dasync_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa,
 static int dasync_rsa_init(RSA *rsa);
 static int dasync_rsa_finish(RSA *rsa);
 
-static RSA_METHOD dasync_rsa_method = {
-    &quot;Dummy Async RSA method&quot;,
-    dasync_pub_enc,             /* pub_enc */
-    dasync_pub_dec,             /* pub_dec */
-    dasync_rsa_priv_enc,        /* priv_enc */
-    dasync_rsa_priv_dec,        /* priv_dec */
-    dasync_rsa_mod_exp,         /* rsa_mod_exp */
-    BN_mod_exp_mont,            /* bn_mod_exp */
-    dasync_rsa_init,            /* init */
-    dasync_rsa_finish,          /* finish */
-    0,                          /* flags */
-    NULL,                       /* app_data */
-    0,                          /* rsa_sign */
-    0,                          /* rsa_verify */
-    NULL                        /* rsa_keygen */
-};
-
+static RSA_METHOD *dasync_rsa_method = NULL;
 
 /* AES */
 
@@ -239,12 +223,26 @@ static int dasync_cipher_nids[] = {
 
 static int bind_dasync(ENGINE *e)
 {
+    /* Setup RSA_METHOD */
+    if ((dasync_rsa_method = RSA_meth_new(&quot;Dummy Async RSA method&quot;, 0)) == NULL
+        || RSA_meth_set_pub_enc(dasync_rsa_method, dasync_pub_enc) == 0
+        || RSA_meth_set_pub_dec(dasync_rsa_method, dasync_pub_dec) == 0
+        || RSA_meth_set_priv_enc(dasync_rsa_method, dasync_rsa_priv_enc) == 0
+        || RSA_meth_set_priv_enc(dasync_rsa_method, dasync_rsa_priv_dec) == 0
+        || RSA_meth_set_mod_exp(dasync_rsa_method, dasync_rsa_mod_exp) == 0
+        || RSA_meth_set_bn_mod_exp(dasync_rsa_method, BN_mod_exp_mont) == 0
+        || RSA_meth_set_init(dasync_rsa_method, dasync_rsa_init) == 0
+        || RSA_meth_set_finish(dasync_rsa_method, dasync_rsa_finish) == 0) {
+        DASYNCerr(DASYNC_F_BIND_DASYNC, DASYNC_R_INIT_FAILED);
+        return 0;
+    }
+
     /* Ensure the dasync error handling is set up */
     ERR_load_DASYNC_strings();
 
     if (!ENGINE_set_id(e, engine_dasync_id)
         || !ENGINE_set_name(e, engine_dasync_name)
-        || !ENGINE_set_RSA(e, &amp;dasync_rsa_method)
+        || !ENGINE_set_RSA(e, dasync_rsa_method)
         || !ENGINE_set_digests(e, dasync_digests)
         || !ENGINE_set_ciphers(e, dasync_ciphers)
         || !ENGINE_set_destroy_function(e, dasync_destroy)
@@ -375,6 +373,7 @@ static int dasync_destroy(ENGINE *e)
 {
     destroy_digests();
     destroy_ciphers();
+    RSA_meth_free(dasync_rsa_method);
     ERR_unload_DASYNC_strings();
     return 1;
 }
@@ -545,14 +544,16 @@ static int dasync_pub_enc(int flen, const unsigned char *from,
                     unsigned char *to, RSA *rsa, int padding) {
     /* Ignore errors - we carry on anyway */
     dummy_pause_job();
-    return RSA_PKCS1_OpenSSL()-&gt;rsa_pub_enc(flen, from, to, rsa, padding);
+    return RSA_meth_get_pub_enc(RSA_PKCS1_OpenSSL())
+        (flen, from, to, rsa, padding);
 }
 
 static int dasync_pub_dec(int flen, const unsigned char *from,
                     unsigned char *to, RSA *rsa, int padding) {
     /* Ignore errors - we carry on anyway */
     dummy_pause_job();
-    return RSA_PKCS1_OpenSSL()-&gt;rsa_pub_dec(flen, from, to, rsa, padding);
+    return RSA_meth_get_pub_dec(RSA_PKCS1_OpenSSL())
+        (flen, from, to, rsa, padding);
 }
 
 static int dasync_rsa_priv_enc(int flen, const unsigned char *from,
@@ -560,7 +561,8 @@ static int dasync_rsa_priv_enc(int flen, const unsigned char *from,
 {
     /* Ignore errors - we carry on anyway */
     dummy_pause_job();
-    return RSA_PKCS1_OpenSSL()-&gt;rsa_priv_enc(flen, from, to, rsa, padding);
+    return RSA_meth_get_priv_enc(RSA_PKCS1_OpenSSL())
+        (flen, from, to, rsa, padding);
 }
 
 static int dasync_rsa_priv_dec(int flen, const unsigned char *from,
@@ -568,23 +570,24 @@ static int dasync_rsa_priv_dec(int flen, const unsigned char *from,
 {
     /* Ignore errors - we carry on anyway */
     dummy_pause_job();
-    return RSA_PKCS1_OpenSSL()-&gt;rsa_priv_dec(flen, from, to, rsa, padding);
+    return RSA_meth_get_priv_dec(RSA_PKCS1_OpenSSL())
+        (flen, from, to, rsa, padding);
 }
 
 static int dasync_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
 {
     /* Ignore errors - we carry on anyway */
     dummy_pause_job();
-    return RSA_PKCS1_OpenSSL()-&gt;rsa_mod_exp(r0, I, rsa, ctx);
+    return RSA_meth_get_mod_exp(RSA_PKCS1_OpenSSL())(r0, I, rsa, ctx);
 }
 
 static int dasync_rsa_init(RSA *rsa)
 {
-    return RSA_PKCS1_OpenSSL()-&gt;init(rsa);
+    return RSA_meth_get_init(RSA_PKCS1_OpenSSL())(rsa);
 }
 static int dasync_rsa_finish(RSA *rsa)
 {
-    return RSA_PKCS1_OpenSSL()-&gt;finish(rsa);
+    return RSA_meth_get_finish(RSA_PKCS1_OpenSSL())(rsa);
 }
 
 /* Cipher helper functions */
diff --git a/include/openssl/rsa.h b/include/openssl/rsa.h
index e7ae827..1698fb3 100644
--- a/include/openssl/rsa.h
+++ b/include/openssl/rsa.h
@@ -72,86 +72,7 @@
 extern &quot;C&quot; {
 # endif
 
-struct rsa_meth_st {
-    const char *name;
-    int (*rsa_pub_enc) (int flen, const unsigned char *from,
-                        unsigned char *to, RSA *rsa, int padding);
-    int (*rsa_pub_dec) (int flen, const unsigned char *from,
-                        unsigned char *to, RSA *rsa, int padding);
-    int (*rsa_priv_enc) (int flen, const unsigned char *from,
-                         unsigned char *to, RSA *rsa, int padding);
-    int (*rsa_priv_dec) (int flen, const unsigned char *from,
-                         unsigned char *to, RSA *rsa, int padding);
-    /* Can be null */
-    int (*rsa_mod_exp) (BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx);
-    /* Can be null */
-    int (*bn_mod_exp) (BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                       const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
-    /* called at new */
-    int (*init) (RSA *rsa);
-    /* called at free */
-    int (*finish) (RSA *rsa);
-    /* RSA_METHOD_FLAG_* things */
-    int flags;
-    /* may be needed! */
-    char *app_data;
-    /*
-     * New sign and verify functions: some libraries don't allow arbitrary
-     * data to be signed/verified: this allows them to be used. Note: for
-     * this to work the RSA_public_decrypt() and RSA_private_encrypt() should
-     * *NOT* be used RSA_sign(), RSA_verify() should be used instead.
-     */
-    int (*rsa_sign) (int type,
-                     const unsigned char *m, unsigned int m_length,
-                     unsigned char *sigret, unsigned int *siglen,
-                     const RSA *rsa);
-    int (*rsa_verify) (int dtype, const unsigned char *m,
-                       unsigned int m_length, const unsigned char *sigbuf,
-                       unsigned int siglen, const RSA *rsa);
-    /*
-     * If this callback is NULL, the builtin software RSA key-gen will be
-     * used. This is for behavioural compatibility whilst the code gets
-     * rewired, but one day it would be nice to assume there are no such
-     * things as &quot;builtin software&quot; implementations.
-     */
-    int (*rsa_keygen) (RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
-};
-
-struct rsa_st {
-    /*
-     * The first parameter is used to pickup errors where this is passed
-     * instead of aEVP_PKEY, it is set to 0
-     */
-    int pad;
-    long version;
-    const RSA_METHOD *meth;
-    /* functional reference if 'meth' is ENGINE-provided */
-    ENGINE *engine;
-    BIGNUM *n;
-    BIGNUM *e;
-    BIGNUM *d;
-    BIGNUM *p;
-    BIGNUM *q;
-    BIGNUM *dmp1;
-    BIGNUM *dmq1;
-    BIGNUM *iqmp;
-    /* be careful using this if the RSA structure is shared */
-    CRYPTO_EX_DATA ex_data;
-    int references;
-    int flags;
-    /* Used to cache montgomery values */
-    BN_MONT_CTX *_method_mod_n;
-    BN_MONT_CTX *_method_mod_p;
-    BN_MONT_CTX *_method_mod_q;
-    /*
-     * all BIGNUM values are actually in the following data, if it is not
-     * NULL
-     */
-    char *bignum_data;
-    BN_BLINDING *blinding;
-    BN_BLINDING *mt_blinding;
-    CRYPTO_RWLOCK *lock;
-};
+/* The types RSA and RSA_METHOD are defined in ossl_typ.h */
 
 # ifndef OPENSSL_RSA_MAX_MODULUS_BITS
 #  define OPENSSL_RSA_MAX_MODULUS_BITS   16384
@@ -308,6 +229,18 @@ int RSA_bits(const RSA *rsa);
 int RSA_size(const RSA *rsa);
 int RSA_security_bits(const RSA *rsa);
 
+int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d);
+int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q);
+int RSA_set0_crt_params(RSA *r,BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp);
+void RSA_get0_key(const RSA *r, BIGNUM **n, BIGNUM **e, BIGNUM **d);
+void RSA_get0_factors(const RSA *r, BIGNUM **p, BIGNUM **q);
+void RSA_get0_crt_params(const RSA *r,
+                         BIGNUM **dmp1, BIGNUM **dmq1, BIGNUM **iqmp);
+void RSA_clear_flags(RSA *r, int flags);
+int RSA_test_flags(const RSA *r, int flags);
+void RSA_set_flags(RSA *r, int flags);
+ENGINE *RSA_get0_engine(RSA *r);
+
 /* Deprecated version */
 DEPRECATEDIN_0_9_8(RSA *RSA_generate_key(int bits, unsigned long e, void
                                          (*callback) (int, int, void *),
@@ -491,6 +424,87 @@ RSA *RSAPrivateKey_dup(RSA *rsa);
  */
 # define RSA_FLAG_CHECKED                        0x0800
 
+RSA_METHOD *RSA_meth_new(const char *name, int flags);
+void RSA_meth_free(RSA_METHOD *meth);
+RSA_METHOD *RSA_meth_dup(const RSA_METHOD *meth);
+const char *RSA_meth_get0_name(const RSA_METHOD *meth);
+int RSA_meth_set1_name(RSA_METHOD *meth, const char *name);
+int RSA_meth_get_flags(RSA_METHOD *meth);
+int RSA_meth_set_flags(RSA_METHOD *meth, int flags);
+void *RSA_meth_get0_app_data(const RSA_METHOD *meth);
+int RSA_meth_set0_app_data(RSA_METHOD *meth, void *app_data);
+int (*RSA_meth_get_pub_enc(const RSA_METHOD *meth))
+    (int flen, const unsigned char *from,
+     unsigned char *to, RSA *rsa, int padding);
+int RSA_meth_set_pub_enc(RSA_METHOD *rsa,
+                         int (*pub_enc) (int flen, const unsigned char *from,
+                                         unsigned char *to, RSA *rsa,
+                                         int padding));
+int (*RSA_meth_get_pub_dec(const RSA_METHOD *meth))
+    (int flen, const unsigned char *from,
+     unsigned char *to, RSA *rsa, int padding);
+int RSA_meth_set_pub_dec(RSA_METHOD *rsa,
+                         int (*pub_dec) (int flen, const unsigned char *from,
+                                         unsigned char *to, RSA *rsa,
+                                         int padding));
+int (*RSA_meth_get_priv_enc(const RSA_METHOD *meth))
+    (int flen, const unsigned char *from,
+     unsigned char *to, RSA *rsa, int padding);
+int RSA_meth_set_priv_enc(RSA_METHOD *rsa,
+                          int (*priv_enc) (int flen, const unsigned char *from,
+                                           unsigned char *to, RSA *rsa,
+                                           int padding));
+int (*RSA_meth_get_priv_dec(const RSA_METHOD *meth))
+    (int flen, const unsigned char *from,
+     unsigned char *to, RSA *rsa, int padding);
+int RSA_meth_set_priv_dec(RSA_METHOD *rsa,
+                          int (*priv_dec) (int flen, const unsigned char *from,
+                                           unsigned char *to, RSA *rsa,
+                                           int padding));
+int (*RSA_meth_get_mod_exp(const RSA_METHOD *meth))
+    (BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx);
+int RSA_meth_set_mod_exp(RSA_METHOD *rsa,
+                         int (*mod_exp) (BIGNUM *r0, const BIGNUM *I, RSA *rsa,
+                                         BN_CTX *ctx));
+int (*RSA_meth_get_bn_mod_exp(const RSA_METHOD *meth))
+    (BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
+     const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
+int RSA_meth_set_bn_mod_exp(RSA_METHOD *rsa,
+                            int (*bn_mod_exp) (BIGNUM *r,
+                                               const BIGNUM *a,
+                                               const BIGNUM *p,
+                                               const BIGNUM *m,
+                                               BN_CTX *ctx,
+                                               BN_MONT_CTX *m_ctx));
+int (*RSA_meth_get_init(const RSA_METHOD *meth)) (RSA *rsa);
+int RSA_meth_set_init(RSA_METHOD *rsa, int (*init) (RSA *rsa));
+int (*RSA_meth_get_finish(const RSA_METHOD *meth)) (RSA *rsa);
+int RSA_meth_set_finish(RSA_METHOD *rsa, int (*finish) (RSA *rsa));
+int (*RSA_meth_get_sign(const RSA_METHOD *meth))
+    (int type,
+     const unsigned char *m, unsigned int m_length,
+     unsigned char *sigret, unsigned int *siglen,
+     const RSA *rsa);
+int RSA_meth_set_sign(RSA_METHOD *rsa,
+                      int (*sign) (int type, const unsigned char *m,
+                                   unsigned int m_length,
+                                   unsigned char *sigret, unsigned int *siglen,
+                                   const RSA *rsa));
+int (*RSA_meth_get_verify(const RSA_METHOD *meth))
+    (int dtype, const unsigned char *m,
+     unsigned int m_length, const unsigned char *sigbuf,
+     unsigned int siglen, const RSA *rsa);
+int RSA_meth_set_verify(RSA_METHOD *rsa,
+                        int (*verify) (int dtype, const unsigned char *m,
+                                       unsigned int m_length,
+                                       const unsigned char *sigbuf,
+                                       unsigned int siglen, const RSA *rsa));
+int (*RSA_meth_get_keygen(const RSA_METHOD *meth))
+    (RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
+int RSA_meth_set_keygen(RSA_METHOD *rsa,
+                        int (*keygen) (RSA *rsa, int bits, BIGNUM *e,
+                                       BN_GENCB *cb));
+
 /* BEGIN ERROR CODES */
 /*
  * The following lines are auto generated by the script mkerr.pl. Any changes
diff --git a/test/rsa_test.c b/test/rsa_test.c
index d5d73e0..2bc21b0 100644
--- a/test/rsa_test.c
+++ b/test/rsa_test.c
@@ -19,16 +19,19 @@ int main(int argc, char *argv[])
 # include &lt;openssl/rsa.h&gt;
 
 # define SetKey \
-  key-&gt;n = BN_bin2bn(n, sizeof(n)-1, key-&gt;n); \
-  key-&gt;e = BN_bin2bn(e, sizeof(e)-1, key-&gt;e); \
-  key-&gt;d = BN_bin2bn(d, sizeof(d)-1, key-&gt;d); \
-  key-&gt;p = BN_bin2bn(p, sizeof(p)-1, key-&gt;p); \
-  key-&gt;q = BN_bin2bn(q, sizeof(q)-1, key-&gt;q); \
-  key-&gt;dmp1 = BN_bin2bn(dmp1, sizeof(dmp1)-1, key-&gt;dmp1); \
-  key-&gt;dmq1 = BN_bin2bn(dmq1, sizeof(dmq1)-1, key-&gt;dmq1); \
-  key-&gt;iqmp = BN_bin2bn(iqmp, sizeof(iqmp)-1, key-&gt;iqmp); \
-  memcpy(c, ctext_ex, sizeof(ctext_ex) - 1); \
-  return (sizeof(ctext_ex) - 1);
+    RSA_set0_key(key,                                           \
+                 BN_bin2bn(n, sizeof(n)-1, NULL),               \
+                 BN_bin2bn(e, sizeof(e)-1, NULL),               \
+                 BN_bin2bn(d, sizeof(d)-1, NULL));              \
+    RSA_set0_factors(key,                                       \
+                     BN_bin2bn(p, sizeof(p)-1, NULL),           \
+                     BN_bin2bn(q, sizeof(q)-1, NULL));          \
+    RSA_set0_crt_params(key,                                    \
+                        BN_bin2bn(dmp1, sizeof(dmp1)-1, NULL),  \
+                        BN_bin2bn(dmq1, sizeof(dmq1)-1, NULL),  \
+                        BN_bin2bn(iqmp, sizeof(iqmp)-1, NULL)); \
+    memcpy(c, ctext_ex, sizeof(ctext_ex) - 1);                  \
+    return (sizeof(ctext_ex) - 1);
 
 static int key1(RSA *key, unsigned char *c)
 {
@@ -243,7 +246,7 @@ int main(int argc, char *argv[])
             break;
         }
         if (v / 3 &gt;= 1)
-            key-&gt;flags |= RSA_FLAG_NO_CONSTTIME;
+            RSA_set_flags(key, RSA_FLAG_NO_CONSTTIME);
 
         num = RSA_public_encrypt(plen, ptext_ex, ctext, key,
                                  RSA_PKCS1_PADDING);
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 581a84b..5cbdfcc 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4125,3 +4125,44 @@ DSA_get0_engine                         3990	1_1_0	EXIST::FUNCTION:DSA
 X509_VERIFY_PARAM_set_auth_level        3991	1_1_0	EXIST::FUNCTION:
 X509_VERIFY_PARAM_get_auth_level        3992	1_1_0	EXIST::FUNCTION:
 X509_REQ_get0_pubkey                    3993	1_1_0	EXIST::FUNCTION:
+RSA_set0_key                            3994	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_flags                      3995	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_finish                     3996	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_priv_dec                   3997	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_sign                       3998	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_bn_mod_exp                 3999	1_1_0	EXIST::FUNCTION:RSA
+RSA_test_flags                          4000	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_new                            4001	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get0_app_data                  4002	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_dup                            4003	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set1_name                      4004	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set0_app_data                  4005	1_1_0	EXIST::FUNCTION:RSA
+RSA_set_flags                           4006	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_sign                       4007	1_1_0	EXIST::FUNCTION:RSA
+RSA_clear_flags                         4008	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_keygen                     4009	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_keygen                     4010	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_pub_dec                    4011	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_finish                     4012	1_1_0	EXIST::FUNCTION:RSA
+RSA_get0_key                            4013	1_1_0	EXIST::FUNCTION:RSA
+RSA_get0_engine                         4014	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_priv_enc                   4015	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_verify                     4016	1_1_0	EXIST::FUNCTION:RSA
+RSA_get0_factors                        4017	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get0_name                      4018	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_mod_exp                    4019	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_flags                      4020	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_pub_dec                    4021	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_bn_mod_exp                 4022	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_init                       4023	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_free                           4024	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_pub_enc                    4025	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_mod_exp                    4026	1_1_0	EXIST::FUNCTION:RSA
+RSA_set0_factors                        4027	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_pub_enc                    4028	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_priv_dec                   4029	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_verify                     4030	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_set_init                       4031	1_1_0	EXIST::FUNCTION:RSA
+RSA_meth_get_priv_enc                   4032	1_1_0	EXIST::FUNCTION:RSA
+RSA_set0_crt_params                     4037	1_1_0	EXIST::FUNCTION:RSA
+RSA_get0_crt_params                     4038	1_1_0	EXIST::FUNCTION:RSA
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006275.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="006279.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6277">[ date ]</a>
              <a href="thread.html#6277">[ thread ]</a>
              <a href="subject.html#6277">[ subject ]</a>
              <a href="author.html#6277">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
