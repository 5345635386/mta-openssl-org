<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-February/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1456516658.403556.7512.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004577.html">
   <LINK REL="Next"  HREF="004586.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1456516658.403556.7512.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Fri Feb 26 19:57:38 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004577.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="004586.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4578">[ date ]</a>
              <a href="thread.html#4578">[ thread ]</a>
              <a href="subject.html#4578">[ subject ]</a>
              <a href="author.html#4578">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  a8d177acf0bbb4da4d7c2d9dd4c645d447f8da75 (commit)
       via  2882e96a5f22ebd0af5dfaf8617f7cff5a409512 (commit)
       via  0cea8832df37d8fd3e664caec8abbdaa002122b1 (commit)
      from  186d04a543498753103f4b6e99f3d4460fe2676d (commit)


- Log -----------------------------------------------------------------
commit a8d177acf0bbb4da4d7c2d9dd4c645d447f8da75
Author: Rob Percival &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">robpercival at google.com</A>&gt;
Date:   Thu Feb 25 16:24:10 2016 +0000

    Moves SCT struct typedef into ossl_typ.h
    
    Reviewed-by: Ben Laurie &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">ben at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 2882e96a5f22ebd0af5dfaf8617f7cff5a409512
Author: Rob Percival &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">robpercival at google.com</A>&gt;
Date:   Wed Feb 24 15:11:36 2016 +0000

    Fix for potential deferencing of null pointer in o2i_SCT_signature
    
    Reviewed-by: Ben Laurie &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">ben at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 0cea8832df37d8fd3e664caec8abbdaa002122b1
Author: Rob Percival &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">robpercival at google.com</A>&gt;
Date:   Thu Feb 25 18:11:16 2016 +0000

    Public API for Certificate Transparency
    
    Reviewed-by: Ben Laurie &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">ben at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 Configurations/descrip.mms.tmpl                    |   6 +-
 Configurations/unix-Makefile.tmpl                  |   2 -
 Makefile.in                                        |   1 -
 crypto/ct/Makefile.in                              |   9 +-
 crypto/ct/build.info                               |   2 +-
 crypto/ct/ct.ec                                    |   6 -
 crypto/ct/ct_err.c                                 |   3 +-
 include/openssl/kdf.h =&gt; crypto/ct/ct_locl.h       |  76 ++--
 crypto/ct/ct_oct.c                                 | 160 +++------
 crypto/ct/ct_prn.c                                 |  40 ++-
 crypto/ct/{ct_lib.c =&gt; ct_sct.c}                   |  99 ++---
 crypto/{asn1/t_bitst.c =&gt; ct/ct_x509v3.c}          |  86 ++---
 crypto/err/err.c                                   |   1 +
 crypto/err/err_all.c                               |   4 +-
 crypto/err/openssl.ec                              |   3 +-
 crypto/include/internal/ct_int.h                   | 328 +----------------
 .../internal/ct_int.h =&gt; include/openssl/ct.h      | 397 ++++++++++-----------
 include/openssl/ossl_typ.h                         |   2 +
 test/ct_test.c                                     |   3 +-
 util/libeay.num                                    |  31 ++
 util/mkdef.pl                                      |   5 +-
 21 files changed, 489 insertions(+), 775 deletions(-)
 delete mode 100644 crypto/ct/ct.ec
 copy include/openssl/kdf.h =&gt; crypto/ct/ct_locl.h (60%)
 rename crypto/ct/{ct_lib.c =&gt; ct_sct.c} (79%)
 copy crypto/{asn1/t_bitst.c =&gt; ct/ct_x509v3.c} (63%)
 copy crypto/include/internal/ct_int.h =&gt; include/openssl/ct.h (57%)

diff --git a/Configurations/descrip.mms.tmpl b/Configurations/descrip.mms.tmpl
index e8e335d..5b52a09 100644
--- a/Configurations/descrip.mms.tmpl
+++ b/Configurations/descrip.mms.tmpl
@@ -50,15 +50,13 @@
   }
   my $sd1 = sourcedir(&quot;ssl&quot;,&quot;record&quot;);
   my $sd2 = sourcedir(&quot;ssl&quot;,&quot;statem&quot;);
-  $unified_info{before}-&gt;{&quot;[.crypto.ct]ct_lib.OBJ&quot;}
-      = $unified_info{before}-&gt;{&quot;[.test]heartbeat_test.OBJ&quot;}
+  $unified_info{before}-&gt;{&quot;[.test]heartbeat_test.OBJ&quot;}
       = $unified_info{before}-&gt;{&quot;[.test]ssltest.OBJ&quot;}
       = qq(record = F\$PARSE(&quot;$sd1&quot;,&quot;A.;&quot;,,,&quot;SYNTAX_ONLY&quot;) - &quot;A.;&quot;
         define record 'record'
         statem = F\$PARSE(&quot;$sd2&quot;,&quot;A.;&quot;,,,&quot;SYNTAX_ONLY&quot;) - &quot;A.;&quot;
         define statem 'statem');
-  $unified_info{after}-&gt;{&quot;[.crypto.ct]ct_lib.OBJ&quot;}
-      = $unified_info{after}-&gt;{&quot;[.test]heartbeat_test.OBJ&quot;}
+  $unified_info{after}-&gt;{&quot;[.test]heartbeat_test.OBJ&quot;}
       = $unified_info{after}-&gt;{&quot;[.test]ssltest.OBJ&quot;}
       = qq(deassign statem
         deassign record);
diff --git a/Configurations/unix-Makefile.tmpl b/Configurations/unix-Makefile.tmpl
index 2dbfaaa..0e91fb0 100644
--- a/Configurations/unix-Makefile.tmpl
+++ b/Configurations/unix-Makefile.tmpl
@@ -650,8 +650,6 @@ errors:
 	      $(PERL) ../util/mkerr.pl -conf $$e \
 		      -nostatic -staticloader -write *.c; \
 	  done )
-	( cd $(SRCDIR)/crypto/ct; \
-	  $(PERL) ../../util/mkerr.pl -conf ct.ec -hprefix internal/ -write *.c )
 
 ordinals:
 	( b=`pwd`; cd $(SRCDIR); $(PERL) -I$$b util/mkdef.pl crypto update )
diff --git a/Makefile.in b/Makefile.in
index 924dfa0..4e7aa71 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -521,7 +521,6 @@ errors:
 	$(PERL) util/ck_errf.pl -strict */*.c */*/*.c
 	$(PERL) util/mkerr.pl -recurse -write
 	(cd engines; $(MAKE) PERL=$(PERL) errors)
-	(cd crypto/ct; $(MAKE) PERL=$(PERL) errors)
 
 ordinals: util/libeay.num util/ssleay.num test_ordinals TABLE
 util/libeay.num::
diff --git a/crypto/ct/Makefile.in b/crypto/ct/Makefile.in
index 7e58c3b..21ff231 100644
--- a/crypto/ct/Makefile.in
+++ b/crypto/ct/Makefile.in
@@ -15,8 +15,8 @@ CFLAGS= $(INCLUDES) $(CFLAG) $(SHARED_CFLAG)
 GENERAL=Makefile
 
 LIB=$(TOP)/libcrypto.a
-LIBSRC= ct_lib.c ct_err.c ct_oct.c ct_prn.c
-LIBOBJ= ct_lib.o ct_err.o ct_oct.o ct_prn.o
+LIBSRC= ct_err.c ct_oct.c ct_prn.c ct_sct.c ct_x509v3.c
+LIBOBJ= ct_err.o ct_oct.o ct_prn.o ct_sct.o ct_x509v3.o
 
 SRC= $(LIBSRC)
 
@@ -27,8 +27,6 @@ ALL=    $(GENERAL) $(SRC) $(HEADER)
 top:
 	(cd ../..; $(MAKE) DIRS=crypto SDIRS=$(DIR) sub_all)
 
-test:
-
 all:	lib
 
 lib:	$(LIBOBJ)
@@ -39,9 +37,6 @@ lib:	$(LIBOBJ)
 files:
 	$(PERL) $(TOP)/util/files.pl Makefile &gt;&gt; $(TOP)/MINFO
 
-errors:
-	$(PERL) $(TOP)/util/mkerr.pl -conf ct.ec -hprefix internal/ -write *.c
-
 depend:
 	$(TOP)/util/domd $(CFLAG) $(INCLUDES) -- $(PROGS) $(LIBSRC)
 
diff --git a/crypto/ct/build.info b/crypto/ct/build.info
index 2007715..b7766b6 100644
--- a/crypto/ct/build.info
+++ b/crypto/ct/build.info
@@ -1,2 +1,2 @@
 LIBS=../../libcrypto
-SOURCE[../../libcrypto]= ct_lib.c ct_err.c ct_oct.c ct_prn.c
+SOURCE[../../libcrypto]= ct_err.c ct_oct.c ct_prn.c ct_sct.c ct_x509v3.c
diff --git a/crypto/ct/ct.ec b/crypto/ct/ct.ec
deleted file mode 100644
index 6f50f9a..0000000
--- a/crypto/ct/ct.ec
+++ /dev/null
@@ -1,6 +0,0 @@
-# crypto/ct/ct.ec
-
-# configuration file for util/mkerr.pl
-
-# files that may have to be rewritten by util/mkerr.pl
-L CT	../../crypto/include/internal/ct_int.h		ct_err.c
diff --git a/crypto/ct/ct_err.c b/crypto/ct/ct_err.c
index b2ba432..033872e 100644
--- a/crypto/ct/ct_err.c
+++ b/crypto/ct/ct_err.c
@@ -1,4 +1,3 @@
-/* ct_err.c */
 /* ====================================================================
  * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
  *
@@ -61,7 +60,7 @@
 
 #include &lt;stdio.h&gt;
 #include &lt;openssl/err.h&gt;
-#include &lt;internal/ct_int.h&gt;
+#include &lt;openssl/ct.h&gt;
 
 /* BEGIN ERROR CODES */
 #ifndef OPENSSL_NO_ERR
diff --git a/include/openssl/kdf.h b/crypto/ct/ct_locl.h
similarity index 60%
copy from include/openssl/kdf.h
copy to crypto/ct/ct_locl.h
index b28a3f2..9b76d16 100644
--- a/include/openssl/kdf.h
+++ b/crypto/ct/ct_locl.h
@@ -1,6 +1,5 @@
 /*
- * Written by Dr Stephen N Henson (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL
- * project.
+ * Written by Rob Percival (<A HREF="../../../mailman/listinfo/openssl-commits.html">robpercival at google.com</A>) for the OpenSSL project.
  */
 /* ====================================================================
  * Copyright (c) 2016 The OpenSSL Project.  All rights reserved.
@@ -51,30 +50,61 @@
  * ====================================================================
  */
 
-#ifndef HEADER_KDF_H
-# define HEADER_KDF_H
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
+#ifdef OPENSSL_NO_CT
+# error CT is disabled.
 #endif
 
-# define EVP_PKEY_CTRL_TLS_MD       (EVP_PKEY_ALG_CTRL)
-# define EVP_PKEY_CTRL_TLS_SECRET   (EVP_PKEY_ALG_CTRL + 1)
-# define EVP_PKEY_CTRL_TLS_SEED     (EVP_PKEY_ALG_CTRL + 2)
+#include &lt;stddef.h&gt;
 
-# define EVP_PKEY_CTX_set_tls1_prf_md(pctx, md) \
-            EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
-                              EVP_PKEY_CTRL_TLS_MD, 0, (void *)md)
+#include &lt;openssl/ct.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/x509.h&gt;
+#include &lt;openssl/safestack.h&gt;
 
-# define EVP_PKEY_CTX_set1_tls1_prf_secret(pctx, sec, seclen) \
-            EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
-                              EVP_PKEY_CTRL_TLS_SECRET, seclen, (void *)sec)
+/*
+ * From RFC6962: opaque SerializedSCT&lt;1..2^16-1&gt;; struct { SerializedSCT
+ * sct_list &lt;1..2^16-1&gt;; } SignedCertificateTimestampList;
+ */
+# define MAX_SCT_SIZE            65535
+# define MAX_SCT_LIST_SIZE       MAX_SCT_SIZE
+
+/* Signed Certificate Timestamp */
+struct sct_st {
+    sct_version_t version;
+    /* If version is not SCT_VERSION_V1, this contains the encoded SCT */
+    unsigned char *sct;
+    size_t sct_len;
+    /* If version is SCT_VERSION_V1, fields below contain components of the SCT */
+    unsigned char *log_id;
+    size_t log_id_len;
+    /*
+    * Note, we cannot distinguish between an unset timestamp, and one
+    * that is set to 0.  However since CT didn't exist in 1970, no real
+    * SCT should ever be set as such.
+    */
+    uint64_t timestamp;
+    unsigned char *ext;
+    size_t ext_len;
+    unsigned char hash_alg;
+    unsigned char sig_alg;
+    unsigned char *sig;
+    size_t sig_len;
+    /* Log entry type */
+    ct_log_entry_type_t entry_type;
+};
+
+/*
+ * Does this SCT have the minimum fields populated to be usuable?
+ * Returns 1 if so, 0 otherwise.
+ */
+int SCT_is_complete(const SCT *sct);
+
+/*
+ * Does this SCT have the signature-related fields populated?
+ * Returns 1 if so, 0 otherwise.
+ * This checks that the signature and hash algorithms are set to supported
+ * values and that the signature field is set.
+ */
+int SCT_signature_is_complete(const SCT *sct);
 
-# define EVP_PKEY_CTX_add1_tls1_prf_seed(pctx, seed, seedlen) \
-            EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
-                              EVP_PKEY_CTRL_TLS_SEED, seedlen, (void *)seed)
 
-#ifdef  __cplusplus
-}
-#endif
-#endif
diff --git a/crypto/ct/ct_oct.c b/crypto/ct/ct_oct.c
index 8d075fc..73fc61d 100644
--- a/crypto/ct/ct_oct.c
+++ b/crypto/ct/ct_oct.c
@@ -55,90 +55,52 @@
  * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
  *
  */
- 
-#ifndef OPENSSL_NO_CT
-
-# include &lt;limits.h&gt;
-# include &quot;internal/cryptlib.h&quot;
-# include &lt;openssl/asn1.h&gt;
-# include &lt;openssl/evp.h&gt;
-# include &lt;openssl/x509.h&gt;
-# include &lt;openssl/x509v3.h&gt;
-# include &quot;crypto/include/internal/ct_int.h&quot;
-
-# define n2s(c,s)        ((s=(((unsigned int)((c)[0]))&lt;&lt; 8)| \
-                             (((unsigned int)((c)[1]))    )),c+=2)
-
-# define s2n(s,c)        ((c[0]=(unsigned char)(((s)&gt;&gt; 8)&amp;0xff), \
-                           c[1]=(unsigned char)(((s)    )&amp;0xff)),c+=2)
-
-# define n2l8(c,l)       (l =((uint64_t)(*((c)++)))&lt;&lt;56, \
-                          l|=((uint64_t)(*((c)++)))&lt;&lt;48, \
-                          l|=((uint64_t)(*((c)++)))&lt;&lt;40, \
-                          l|=((uint64_t)(*((c)++)))&lt;&lt;32, \
-                          l|=((uint64_t)(*((c)++)))&lt;&lt;24, \
-                          l|=((uint64_t)(*((c)++)))&lt;&lt;16, \
-                          l|=((uint64_t)(*((c)++)))&lt;&lt; 8, \
-                          l|=((uint64_t)(*((c)++))))
-
-# define l2n8(l,c)       (*((c)++)=(unsigned char)(((l)&gt;&gt;56)&amp;0xff), \
-                          *((c)++)=(unsigned char)(((l)&gt;&gt;48)&amp;0xff), \
-                          *((c)++)=(unsigned char)(((l)&gt;&gt;40)&amp;0xff), \
-                          *((c)++)=(unsigned char)(((l)&gt;&gt;32)&amp;0xff), \
-                          *((c)++)=(unsigned char)(((l)&gt;&gt;24)&amp;0xff), \
-                          *((c)++)=(unsigned char)(((l)&gt;&gt;16)&amp;0xff), \
-                          *((c)++)=(unsigned char)(((l)&gt;&gt; 8)&amp;0xff), \
-                          *((c)++)=(unsigned char)(((l)    )&amp;0xff))
-
-static STACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a,
-                                   const unsigned char **pp, int len);
-static int i2d_SCT_LIST(STACK_OF(SCT) *a, unsigned char **pp);
-static int i2r_SCT_LIST(X509V3_EXT_METHOD *method, STACK_OF(SCT) *sct_list,
-                        BIO *out, int indent);
-
-static char *i2s_poison(const X509V3_EXT_METHOD *method, void *val)
-{
-    return OPENSSL_strdup(&quot;NULL&quot;);
-}
 
-const X509V3_EXT_METHOD v3_ct_scts[] = {
-    { NID_ct_precert_scts, 0, NULL,
-    0, (X509V3_EXT_FREE)SCT_LIST_free,
-    (X509V3_EXT_D2I)d2i_SCT_LIST, (X509V3_EXT_I2D)i2d_SCT_LIST,
-    0, 0, 0, 0,
-    (X509V3_EXT_I2R)i2r_SCT_LIST, 0,
-    NULL },
-
-    { NID_ct_precert_poison, 0, ASN1_ITEM_ref(ASN1_NULL),
-    0, 0, 0, 0, i2s_poison, 0,
-    0, 0, 0, 0, NULL },
-
-    { NID_ct_cert_scts, 0, NULL,
-    0, (X509V3_EXT_FREE)SCT_LIST_free,
-    (X509V3_EXT_D2I)d2i_SCT_LIST, (X509V3_EXT_I2D)i2d_SCT_LIST,
-    0, 0, 0, 0,
-    (X509V3_EXT_I2R)i2r_SCT_LIST, 0,
-    NULL },
-};
-
-int SCT_signature_is_valid(const SCT *sct)
-{
-    if (SCT_get_signature_nid(sct) == NID_undef ||
-        sct-&gt;sig_len == 0 || sct-&gt;sig == NULL) {
-        return 0;
-    }
+#ifdef OPENSSL_NO_CT
+# error &quot;CT is disabled&quot;
+#endif
 
-    return 1;
-}
+#include &lt;limits.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;openssl/asn1.h&gt;
+#include &lt;openssl/buffer.h&gt;
+#include &lt;openssl/ct.h&gt;
+#include &lt;openssl/err.h&gt;
+
+#include &quot;ct_locl.h&quot;
+
+#define n2s(c,s)        ((s=(((unsigned int)((c)[0]))&lt;&lt; 8)| \
+                            (((unsigned int)((c)[1]))    )),c+=2)
+
+#define s2n(s,c)        ((c[0]=(unsigned char)(((s)&gt;&gt; 8)&amp;0xff), \
+                          c[1]=(unsigned char)(((s)    )&amp;0xff)),c+=2)
+
+#define n2l8(c,l)       (l =((uint64_t)(*((c)++)))&lt;&lt;56, \
+                         l|=((uint64_t)(*((c)++)))&lt;&lt;48, \
+                         l|=((uint64_t)(*((c)++)))&lt;&lt;40, \
+                         l|=((uint64_t)(*((c)++)))&lt;&lt;32, \
+                         l|=((uint64_t)(*((c)++)))&lt;&lt;24, \
+                         l|=((uint64_t)(*((c)++)))&lt;&lt;16, \
+                         l|=((uint64_t)(*((c)++)))&lt;&lt; 8, \
+                         l|=((uint64_t)(*((c)++))))
 
+#define l2n8(l,c)       (*((c)++)=(unsigned char)(((l)&gt;&gt;56)&amp;0xff), \
+                         *((c)++)=(unsigned char)(((l)&gt;&gt;48)&amp;0xff), \
+                         *((c)++)=(unsigned char)(((l)&gt;&gt;40)&amp;0xff), \
+                         *((c)++)=(unsigned char)(((l)&gt;&gt;32)&amp;0xff), \
+                         *((c)++)=(unsigned char)(((l)&gt;&gt;24)&amp;0xff), \
+                         *((c)++)=(unsigned char)(((l)&gt;&gt;16)&amp;0xff), \
+                         *((c)++)=(unsigned char)(((l)&gt;&gt; 8)&amp;0xff), \
+                         *((c)++)=(unsigned char)(((l)    )&amp;0xff))
 
 int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len)
 {
     size_t siglen;
     size_t len_remaining = len;
-    const unsigned char *p = *in;
+    const unsigned char *p;
 
-    if (sct-&gt;version != SCT_V1) {
+    if (sct-&gt;version != SCT_VERSION_V1) {
         CTerr(CT_F_O2I_SCT_SIGNATURE, CT_R_UNSUPPORTED_VERSION);
         return -1;
     }
@@ -154,6 +116,7 @@ int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len)
         return -1;
     }
 
+    p = *in;
     /* Get hash and signature algorithm */
     sct-&gt;hash_alg = *p++;
     sct-&gt;sig_alg = *p++;
@@ -193,7 +156,7 @@ SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len)
     p = *in;
 
     sct-&gt;version = *p;
-    if (sct-&gt;version == SCT_V1) {
+    if (sct-&gt;version == SCT_VERSION_V1) {
         int sig_len;
         size_t len2;
         /*
@@ -207,11 +170,11 @@ SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len)
         }
         len -= 43;
         p++;
-        sct-&gt;log_id = BUF_memdup(p, SCT_V1_HASHLEN);
+        sct-&gt;log_id = BUF_memdup(p, CT_V1_HASHLEN);
         if (sct-&gt;log_id == NULL)
             goto err;
-        sct-&gt;log_id_len = SCT_V1_HASHLEN;
-        p += SCT_V1_HASHLEN;
+        sct-&gt;log_id_len = CT_V1_HASHLEN;
+        p += CT_V1_HASHLEN;
 
         n2l8(p, sct-&gt;timestamp);
 
@@ -261,12 +224,12 @@ int i2o_SCT_signature(const SCT *sct, unsigned char **out)
     size_t len;
     unsigned char *p = NULL;
 
-    if (!SCT_signature_is_valid(sct)) {
+    if (!SCT_signature_is_complete(sct)) {
         CTerr(CT_F_I2O_SCT_SIGNATURE, CT_R_SCT_INVALID_SIGNATURE);
         goto err;
     }
 
-    if (sct-&gt;version != SCT_V1) {
+    if (sct-&gt;version != SCT_VERSION_V1) {
         CTerr(CT_F_I2O_SCT_SIGNATURE, CT_R_UNSUPPORTED_VERSION);
         goto err;
     }
@@ -308,7 +271,7 @@ int i2o_SCT(const SCT *sct, unsigned char **out)
     size_t len;
     unsigned char *p = NULL;
 
-    if (!SCT_is_valid(sct)) {
+    if (!SCT_is_complete(sct)) {
         CTerr(CT_F_I2O_SCT, CT_R_SCT_NOT_SET);
         goto err;
     }
@@ -318,7 +281,7 @@ int i2o_SCT(const SCT *sct, unsigned char **out)
      * extensions; (1 byte) Hash algorithm (1 byte) Signature algorithm (2
      * bytes + ?) Signature
      */
-    if (sct-&gt;version == SCT_V1)
+    if (sct-&gt;version == SCT_VERSION_V1)
         len = 43 + sct-&gt;ext_len + 4 + sct-&gt;sig_len;
     else
         len = sct-&gt;sct_len;
@@ -338,10 +301,10 @@ int i2o_SCT(const SCT *sct, unsigned char **out)
         *out = p;
     }
 
-    if (sct-&gt;version == SCT_V1) {
+    if (sct-&gt;version == SCT_VERSION_V1) {
         *p++ = sct-&gt;version;
-        memcpy(p, sct-&gt;log_id, SCT_V1_HASHLEN);
-        p += SCT_V1_HASHLEN;
+        memcpy(p, sct-&gt;log_id, CT_V1_HASHLEN);
+        p += CT_V1_HASHLEN;
         l2n8(sct-&gt;timestamp, p);
         s2n(sct-&gt;ext_len, p);
         if (sct-&gt;ext_len &gt; 0) {
@@ -429,7 +392,7 @@ STACK_OF(SCT) *o2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,
     return NULL;
 }
 
-int i2o_SCT_LIST(STACK_OF(SCT) *a, unsigned char **pp)
+int i2o_SCT_LIST(const STACK_OF(SCT) *a, unsigned char **pp)
 {
     int len, sct_len, i, is_pp_new = 0;
     size_t len2;
@@ -484,8 +447,8 @@ int i2o_SCT_LIST(STACK_OF(SCT) *a, unsigned char **pp)
     return -1;
 }
 
-static STACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a,
-                                   const unsigned char **pp, int len)
+STACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,
+                            long len)
 {
     ASN1_OCTET_STRING *oct = NULL;
     STACK_OF(SCT) *sk = NULL;
@@ -503,7 +466,7 @@ static STACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a,
     return sk;
 }
 
-static int i2d_SCT_LIST(STACK_OF(SCT) *a, unsigned char **out)
+int i2d_SCT_LIST(STACK_OF(SCT) *a, unsigned char **out)
 {
     ASN1_OCTET_STRING oct;
     int len;
@@ -516,20 +479,3 @@ static int i2d_SCT_LIST(STACK_OF(SCT) *a, unsigned char **out)
     OPENSSL_free(oct.data);
     return len;
 }
-
-static int i2r_SCT_LIST(X509V3_EXT_METHOD *method, STACK_OF(SCT) *sct_list,
-                        BIO *out, int indent)
-{
-    int i;
-
-    for (i = 0; i &lt; sk_SCT_num(sct_list); ++i) {
-        SCT *sct = sk_SCT_value(sct_list, i);
-        SCT_print(sct, out, indent);
-        if (i &lt; sk_SCT_num(sct_list) - 1)
-            BIO_printf(out, &quot;\n&quot;);
-    }
-
-    return 1;
-}
-
-#endif
diff --git a/crypto/ct/ct_prn.c b/crypto/ct/ct_prn.c
index 9132553..73aba7e 100644
--- a/crypto/ct/ct_prn.c
+++ b/crypto/ct/ct_prn.c
@@ -56,17 +56,16 @@
  *
  */
 
-#ifndef OPENSSL_NO_CT
+#ifdef OPENSSL_NO_CT
+# error &quot;CT is disabled&quot;
+#endif
+
+#include &lt;openssl/asn1.h&gt;
+#include &lt;openssl/bio.h&gt;
 
-# include &lt;limits.h&gt;
-# include &quot;internal/cryptlib.h&quot;
-# include &lt;openssl/asn1.h&gt;
-# include &lt;openssl/evp.h&gt;
-# include &lt;openssl/x509.h&gt;
-# include &lt;openssl/x509v3.h&gt;
-# include &quot;crypto/include/internal/ct_int.h&quot;
+#include &quot;ct_locl.h&quot;
 
-static void sct_sigalg_print(BIO *out, const SCT *sct)
+static void SCT_signature_algorithms_print(const SCT *sct, BIO *out)
 {
     int nid = SCT_get_signature_nid(sct);
 
@@ -76,7 +75,7 @@ static void sct_sigalg_print(BIO *out, const SCT *sct)
         BIO_printf(out, &quot;%s&quot;, OBJ_nid2ln(nid));
 }
 
-static void timestamp_print(BIO *out, uint64_t timestamp)
+static void timestamp_print(uint64_t timestamp, BIO *out)
 {
     ASN1_GENERALIZEDTIME *gen = ASN1_GENERALIZEDTIME_new();
     char genstr[20];
@@ -95,12 +94,12 @@ static void timestamp_print(BIO *out, uint64_t timestamp)
     ASN1_GENERALIZEDTIME_free(gen);
 }
 
-void SCT_print(SCT *sct, BIO *out, int indent)
+void SCT_print(const SCT *sct, BIO *out, int indent)
 {
     BIO_printf(out, &quot;%*sSigned Certificate Timestamp:&quot;, indent, &quot;&quot;);
     BIO_printf(out, &quot;\n%*sVersion   : &quot;, indent + 4, &quot;&quot;);
 
-    if (sct-&gt;version != SCT_V1) {
+    if (sct-&gt;version != SCT_VERSION_V1) {
         BIO_printf(out, &quot;unknown\n%*s&quot;, indent + 16, &quot;&quot;);
         BIO_hex_string(out, indent + 16, 16, sct-&gt;sct, sct-&gt;sct_len);
         return;
@@ -112,7 +111,7 @@ void SCT_print(SCT *sct, BIO *out, int indent)
     BIO_hex_string(out, indent + 16, 16, sct-&gt;log_id, sct-&gt;log_id_len);
 
     BIO_printf(out, &quot;\n%*sTimestamp : &quot;, indent + 4, &quot;&quot;);
-    timestamp_print(out, sct-&gt;timestamp);
+    timestamp_print(sct-&gt;timestamp, out);
 
     BIO_printf(out, &quot;\n%*sExtensions: &quot;, indent + 4, &quot;&quot;);
     if (sct-&gt;ext_len == 0)
@@ -121,9 +120,20 @@ void SCT_print(SCT *sct, BIO *out, int indent)
         BIO_hex_string(out, indent + 16, 16, sct-&gt;ext, sct-&gt;ext_len);
 
     BIO_printf(out, &quot;\n%*sSignature : &quot;, indent + 4, &quot;&quot;);
-    sct_sigalg_print(out, sct);
+    SCT_signature_algorithms_print(sct, out);
     BIO_printf(out, &quot;\n%*s            &quot;, indent + 4, &quot;&quot;);
     BIO_hex_string(out, indent + 16, 16, sct-&gt;sig, sct-&gt;sig_len);
 }
 
-#endif
+void SCT_LIST_print(const STACK_OF(SCT) *sct_list, BIO *out, int indent,
+                    const char *separator)
+{
+    int i;
+
+    for (i = 0; i &lt; sk_SCT_num(sct_list); ++i) {
+        SCT *sct = sk_SCT_value(sct_list, i);
+        SCT_print(sct, out, indent);
+        if (i &lt; sk_SCT_num(sct_list) - 1)
+            BIO_printf(out, &quot;%s&quot;, separator);
+    }
+}
diff --git a/crypto/ct/ct_lib.c b/crypto/ct/ct_sct.c
similarity index 79%
rename from crypto/ct/ct_lib.c
rename to crypto/ct/ct_sct.c
index 81676e3..81e51f0 100644
--- a/crypto/ct/ct_lib.c
+++ b/crypto/ct/ct_sct.c
@@ -1,6 +1,6 @@
 /*
- * Written by Rob Stradling (<A HREF="../../../mailman/listinfo/openssl-commits.html">rob at comodo.com</A>) and Stephen Henson
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL project 2014.
+ * Written by Rob Stradling (<A HREF="../../../mailman/listinfo/openssl-commits.html">rob at comodo.com</A>), Stephen Henson (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>)
+ * and Adam Eijdenberg (<A HREF="../../../mailman/listinfo/openssl-commits.html">adam.eijdenberg at gmail.com</A>) for the OpenSSL project 2016.
  */
 /* ====================================================================
  * Copyright (c) 2014 The OpenSSL Project.  All rights reserved.
@@ -56,39 +56,47 @@
  *
  */
 
-#ifndef OPENSSL_NO_CT
+#ifdef OPENSSL_NO_CT
+# error &quot;CT disabled&quot;
+#endif
+
+#include &lt;openssl/ct.h&gt;
+#include &lt;openssl/err.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/tls1.h&gt;
+#include &lt;openssl/x509.h&gt;
 
-# include &lt;limits.h&gt;
-# include &quot;internal/cryptlib.h&quot;
-# include &quot;../../ssl/ssl_locl.h&quot;
-# include &quot;internal/ct_int.h&quot;
+#include &quot;ct_locl.h&quot;
 
 SCT *SCT_new(void)
 {
     SCT *sct = OPENSSL_zalloc(sizeof(SCT));
+
     if (sct == NULL) {
         CTerr(CT_F_SCT_NEW, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
-    sct-&gt;entry_type = UNSET_ENTRY;
-    sct-&gt;version = UNSET_VERSION;
+
+    sct-&gt;entry_type = CT_LOG_ENTRY_TYPE_NOT_SET;
+    sct-&gt;version = SCT_VERSION_NOT_SET;
     return sct;
 }
 
 void SCT_free(SCT *sct)
 {
-    if (sct != NULL) {
-        OPENSSL_free(sct-&gt;log_id);
-        OPENSSL_free(sct-&gt;ext);
-        OPENSSL_free(sct-&gt;sig);
-        OPENSSL_free(sct-&gt;sct);
-        OPENSSL_free(sct);
-    }
+    if (sct == NULL)
+        return;
+
+    OPENSSL_free(sct-&gt;log_id);
+    OPENSSL_free(sct-&gt;ext);
+    OPENSSL_free(sct-&gt;sig);
+    OPENSSL_free(sct-&gt;sct);
+    OPENSSL_free(sct);
 }
 
 int SCT_set_version(SCT *sct, sct_version_t version)
 {
-    if (version != SCT_V1) {
+    if (version != SCT_VERSION_V1) {
         CTerr(CT_F_SCT_SET_VERSION, CT_R_UNSUPPORTED_VERSION);
         return 0;
     }
@@ -96,23 +104,26 @@ int SCT_set_version(SCT *sct, sct_version_t version)
     return 1;
 }
 
-int SCT_set_log_entry_type(SCT *sct, log_entry_type_t entry_type)
+int SCT_set_log_entry_type(SCT *sct, ct_log_entry_type_t entry_type)
 {
-    if (entry_type != X509_ENTRY &amp;&amp; entry_type != PRECERT_ENTRY) {
+    switch (entry_type) {
+    case CT_LOG_ENTRY_TYPE_X509:
+    case CT_LOG_ENTRY_TYPE_PRECERT:
+        sct-&gt;entry_type = entry_type;
+        return 1;
+    default:
         CTerr(CT_F_SCT_SET_LOG_ENTRY_TYPE, CT_R_UNSUPPORTED_ENTRY_TYPE);
         return 0;
     }
-    sct-&gt;entry_type = entry_type;
-    return 1;
 }
 
 int SCT_set0_log_id(SCT *sct, unsigned char *log_id, size_t log_id_len)
 {
-    /* Currently only SHA-256 allowed so length must be SCT_V1_HASHLEN */
-    if (log_id_len != SCT_V1_HASHLEN) {
+    if (sct-&gt;version == SCT_VERSION_V1 &amp;&amp; log_id_len != CT_V1_HASHLEN) {
         CTerr(CT_F_SCT_SET0_LOG_ID, CT_R_INVALID_LOG_ID_LENGTH);
         return 0;
     }
+
     OPENSSL_free(sct-&gt;log_id);
     sct-&gt;log_id = log_id;
     sct-&gt;log_id_len = log_id_len;
@@ -121,25 +132,23 @@ int SCT_set0_log_id(SCT *sct, unsigned char *log_id, size_t log_id_len)
 
 int SCT_set1_log_id(SCT *sct, const unsigned char *log_id, size_t log_id_len)
 {
-    /* Currently only SHA-256 allowed so length must be SCT_V1_HASHLEN */
-    if (log_id_len != SCT_V1_HASHLEN) {
+    if (sct-&gt;version == SCT_VERSION_V1 &amp;&amp; log_id_len != CT_V1_HASHLEN) {
         CTerr(CT_F_SCT_SET1_LOG_ID, CT_R_INVALID_LOG_ID_LENGTH);
         return 0;
     }
 
     OPENSSL_free(sct-&gt;log_id);
-    if (log_id == NULL || log_id_len == 0) {
-        sct-&gt;log_id = NULL;
-    } else {
-        sct-&gt;log_id = OPENSSL_memdup(log_id, log_id_len);
+    sct-&gt;log_id = NULL;
+    sct-&gt;log_id_len = 0;
 
+    if (log_id != NULL &amp;&amp; log_id_len &gt; 0) {
+        sct-&gt;log_id = OPENSSL_memdup(log_id, log_id_len);
         if (sct-&gt;log_id == NULL) {
             CTerr(CT_F_SCT_SET1_LOG_ID, ERR_R_MALLOC_FAILURE);
             return 0;
         }
+        sct-&gt;log_id_len = log_id_len;
     }
-
-    sct-&gt;log_id_len = log_id_len;
     return 1;
 }
 
@@ -200,16 +209,17 @@ void SCT_set0_signature(SCT *sct, unsigned char *sig, size_t sig_len)
 int SCT_set1_signature(SCT *sct, const unsigned char *sig, size_t sig_len)
 {
     OPENSSL_free(sct-&gt;sig);
-    if (sig == NULL || sig_len == 0) {
-        sct-&gt;sig = NULL;
-    } else {
+    sct-&gt;sig = NULL;
+    sct-&gt;sig_len = 0;
+
+    if (sig != NULL &amp;&amp; sig_len &gt; 0) {
         sct-&gt;sig = OPENSSL_memdup(sig, sig_len);
         if (sct-&gt;sig == NULL) {
             CTerr(CT_F_SCT_SET1_SIGNATURE, ERR_R_MALLOC_FAILURE);
             return 0;
         }
+        sct-&gt;sig_len = sig_len;
     }
-    sct-&gt;sig_len = sig_len;
     return 1;
 }
 
@@ -218,7 +228,7 @@ sct_version_t SCT_get_version(const SCT *sct)
     return sct-&gt;version;
 }
 
-log_entry_type_t SCT_get_log_entry_type(const SCT *sct)
+ct_log_entry_type_t SCT_get_log_entry_type(const SCT *sct)
 {
     return sct-&gt;entry_type;
 }
@@ -236,7 +246,7 @@ uint64_t SCT_get_timestamp(const SCT *sct)
 
 int SCT_get_signature_nid(const SCT *sct)
 {
-    if (sct-&gt;version == SCT_V1) {
+    if (sct-&gt;version == SCT_VERSION_V1) {
         if (sct-&gt;hash_alg == TLSEXT_hash_sha256) {
             switch (sct-&gt;sig_alg) {
             case TLSEXT_signature_ecdsa:
@@ -263,16 +273,21 @@ size_t SCT_get0_signature(const SCT *sct, unsigned char **sig)
     return sct-&gt;sig_len;
 }
 
-int SCT_is_valid(const SCT *sct)
+int SCT_is_complete(const SCT *sct)
 {
     switch (sct-&gt;version) {
-    case UNSET_VERSION:
+    case SCT_VERSION_NOT_SET:
         return 0;
-    case SCT_V1:
-        return sct-&gt;log_id != NULL &amp;&amp; SCT_signature_is_valid(sct);
+    case SCT_VERSION_V1:
+        return sct-&gt;log_id != NULL &amp;&amp; SCT_signature_is_complete(sct);
     default:
         return sct-&gt;sct != NULL; /* Just need cached encoding */
     }
 }
 
-#endif
+int SCT_signature_is_complete(const SCT *sct)
+{
+    return SCT_get_signature_nid(sct) != NID_undef &amp;&amp;
+        sct-&gt;sig != NULL &amp;&amp; sct-&gt;sig_len &gt; 0;
+}
+
diff --git a/crypto/asn1/t_bitst.c b/crypto/ct/ct_x509v3.c
similarity index 63%
copy from crypto/asn1/t_bitst.c
copy to crypto/ct/ct_x509v3.c
index 2b38e05..2617f13 100644
--- a/crypto/asn1/t_bitst.c
+++ b/crypto/ct/ct_x509v3.c
@@ -1,9 +1,9 @@
 /*
- * Written by Dr Stephen N Henson (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL project
- * 1999.
+ * Written by Rob Stradling (<A HREF="../../../mailman/listinfo/openssl-commits.html">rob at comodo.com</A>) and Stephen Henson
+ * (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL project 2014.
  */
 /* ====================================================================
- * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 2014 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -56,50 +56,54 @@
  *
  */
 
-#include &lt;stdio.h&gt;
-#include &quot;internal/cryptlib.h&quot;
-#include &lt;openssl/conf.h&gt;
+#ifdef OPENSSL_NO_CT
+# error &quot;CT is disabled&quot;
+#endif
+
+#include &lt;openssl/bio.h&gt;
+#include &lt;openssl/ct.h&gt;
+#include &lt;openssl/obj_mac.h&gt;
 #include &lt;openssl/x509v3.h&gt;
 
-int ASN1_BIT_STRING_name_print(BIO *out, ASN1_BIT_STRING *bs,
-                               BIT_STRING_BITNAME *tbl, int indent)
+#include &quot;internal/ct_int.h&quot;
+
+static char *i2s_poison(const X509V3_EXT_METHOD *method, void *val)
 {
-    BIT_STRING_BITNAME *bnam;
-    char first = 1;
-    BIO_printf(out, &quot;%*s&quot;, indent, &quot;&quot;);
-    for (bnam = tbl; bnam-&gt;lname; bnam++) {
-        if (ASN1_BIT_STRING_get_bit(bs, bnam-&gt;bitnum)) {
-            if (!first)
-                BIO_puts(out, &quot;, &quot;);
-            BIO_puts(out, bnam-&gt;lname);
-            first = 0;
-        }
-    }
-    BIO_puts(out, &quot;\n&quot;);
-    return 1;
+    return OPENSSL_strdup(&quot;NULL&quot;);
 }
 
-int ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs, char *name, int value,
-                            BIT_STRING_BITNAME *tbl)
+static int i2r_SCT_LIST(X509V3_EXT_METHOD *method, STACK_OF(SCT) *sct_list,
+                 BIO *out, int indent)
 {
-    int bitnum;
-    bitnum = ASN1_BIT_STRING_num_asc(name, tbl);
-    if (bitnum &lt; 0)
-        return 0;
-    if (bs) {
-        if (!ASN1_BIT_STRING_set_bit(bs, bitnum, value))
-            return 0;
-    }
+    SCT_LIST_print(sct_list, out, indent, &quot;\n&quot;);
     return 1;
 }
 
-int ASN1_BIT_STRING_num_asc(char *name, BIT_STRING_BITNAME *tbl)
-{
-    BIT_STRING_BITNAME *bnam;
-    for (bnam = tbl; bnam-&gt;lname; bnam++) {
-        if ((strcmp(bnam-&gt;sname, name) == 0)
-            || (strcmp(bnam-&gt;lname, name) == 0))
-            return bnam-&gt;bitnum;
-    }
-    return -1;
-}
+/* Handlers for X509v3/OCSP Certificate Transparency extensions */
+const X509V3_EXT_METHOD v3_ct_scts[] = {
+    /* X509v3 extension in certificates that contains SCTs */
+    { NID_ct_precert_scts, 0, NULL,
+    NULL, (X509V3_EXT_FREE)SCT_LIST_free,
+    (X509V3_EXT_D2I)d2i_SCT_LIST, (X509V3_EXT_I2D)i2d_SCT_LIST,
+    NULL, NULL,
+    NULL, NULL,
+    (X509V3_EXT_I2R)i2r_SCT_LIST, NULL,
+    NULL },
+
+    /* X509v3 extension to mark a certificate as a pre-certificate */
+    { NID_ct_precert_poison, 0, ASN1_ITEM_ref(ASN1_NULL),
+    NULL, NULL, NULL, NULL,
+    i2s_poison, NULL,
+    NULL, NULL,
+    NULL, NULL,
+    NULL },
+
+    /* OCSP extension that contains SCTs */
+    { NID_ct_cert_scts, 0, NULL,
+    0, (X509V3_EXT_FREE)SCT_LIST_free,
+    (X509V3_EXT_D2I)d2i_SCT_LIST, (X509V3_EXT_I2D)i2d_SCT_LIST,
+    NULL, NULL,
+    NULL, NULL,
+    (X509V3_EXT_I2R)i2r_SCT_LIST, NULL,
+    NULL },
+};
diff --git a/crypto/err/err.c b/crypto/err/err.c
index 00565fa..1547181 100644
--- a/crypto/err/err.c
+++ b/crypto/err/err.c
@@ -155,6 +155,7 @@ static ERR_STRING_DATA ERR_str_libraries[] = {
     {ERR_PACK(ERR_LIB_FIPS, 0, 0), &quot;FIPS routines&quot;},
     {ERR_PACK(ERR_LIB_CMS, 0, 0), &quot;CMS routines&quot;},
     {ERR_PACK(ERR_LIB_HMAC, 0, 0), &quot;HMAC routines&quot;},
+    {ERR_PACK(ERR_LIB_CT, 0, 0), &quot;CT routines&quot;},
     {ERR_PACK(ERR_LIB_ASYNC, 0, 0), &quot;ASYNC routines&quot;},
     {0, NULL},
 };
diff --git a/crypto/err/err_all.c b/crypto/err/err_all.c
index 4932587..345ce44 100644
--- a/crypto/err/err_all.c
+++ b/crypto/err/err_all.c
@@ -98,7 +98,9 @@
 #ifndef OPENSSL_NO_CMS
 # include &lt;openssl/cms.h&gt;
 #endif
-#include &lt;internal/ct_int.h&gt;
+#ifndef OPENSSL_NO_CT
+# include &lt;openssl/ct.h&gt;
+#endif
 #include &lt;openssl/async.h&gt;
 
 void err_load_crypto_strings_intern(void)
diff --git a/crypto/err/openssl.ec b/crypto/err/openssl.ec
index 88d7be5..ce9dc5c 100644
--- a/crypto/err/openssl.ec
+++ b/crypto/err/openssl.ec
@@ -33,6 +33,7 @@ L TS		include/openssl/ts.h		crypto/ts/ts_err.c
 L HMAC		include/openssl/hmac.h		crypto/hmac/hmac_err.c
 L CMS		include/openssl/cms.h		crypto/cms/cms_err.c
 L FIPS		include/openssl/fips.h		crypto/fips_err.h
+L CT		include/openssl/ct.h		crypto/ct/ct_err.c
 L ASYNC		include/openssl/async.h		crypto/async/async_err.c
 
 # additional header files to be scanned for function names
@@ -40,10 +41,10 @@ L NONE		crypto/x509/x509_vfy.h		NONE
 L NONE		crypto/ec/ec_lcl.h		NONE
 L NONE		crypto/asn1/asn_lcl.h		NONE
 L NONE		crypto/cms/cms_lcl.h		NONE
+L NONE		crypto/ct/ct_locl.h		NONE
 L NONE		fips/rand/fips_rand.h		NONE
 L NONE		ssl/ssl_locl.h			NONE
 
-
 F RSAREF_F_RSA_BN2BIN
 F RSAREF_F_RSA_PRIVATE_DECRYPT
 F RSAREF_F_RSA_PRIVATE_ENCRYPT
diff --git a/crypto/include/internal/ct_int.h b/crypto/include/internal/ct_int.h
index b564dce..99b9332 100644
--- a/crypto/include/internal/ct_int.h
+++ b/crypto/include/internal/ct_int.h
@@ -1,6 +1,6 @@
 /*
- * Written by Dr Stephen N Henson (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL project
- * 2015.
+ * Written by Dr Stephen N Henson (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>)
+ * and Adam Eijdenberg (<A HREF="../../../mailman/listinfo/openssl-commits.html">eijdenberg at google.com</A>) for the OpenSSL project 2015.
  */
 /* ====================================================================
  * Copyright (c) 2015 The OpenSSL Project.  All rights reserved.
@@ -51,329 +51,25 @@
  * ====================================================================
  *
  */
-#ifndef HEADER_CT_LOCL_H
-# define HEADER_CT_LOCL_H
+#ifndef HEADER_CT_INT_H
+# define HEADER_CT_INT_H
 
 # ifdef __cplusplus
 extern &quot;C&quot; {
 # endif
 
-# ifndef OPENSSL_NO_CT
+# ifdef OPENSSL_NO_CT
+#  error CT is disabled.
+# endif
 
+# include &lt;openssl/ct.h&gt;
 # include &lt;openssl/x509v3.h&gt;
 
-/* All hashes are currently SHA256 */
-#  define SCT_V1_HASHLEN  32
-/* Minimum RSA key size, from RFC6962 */
-#  define SCT_MIN_RSA_BITS 2048
-
-/*
- * From RFC6962: opaque SerializedSCT&lt;1..2^16-1&gt;; struct { SerializedSCT
- * sct_list &lt;1..2^16-1&gt;; } SignedCertificateTimestampList;
- */
-
-#  define MAX_SCT_SIZE            65535
-#  define MAX_SCT_LIST_SIZE       MAX_SCT_SIZE
-
-typedef enum {
-    UNSET_ENTRY = -1,
-    X509_ENTRY = 0,
-    PRECERT_ENTRY = 1
-} log_entry_type_t;
-
-typedef enum {
-    UNSET_VERSION = -1,
-    SCT_V1 = 0
-} sct_version_t;
-
-typedef struct {
-    sct_version_t version;
-    /* If version is not SCT_V1 this contains the encoded SCT */
-    unsigned char *sct;
-    size_t sct_len;
-    /*
-     * If version is SCT_V1, fields below contain components of the SCT.
-     * &quot;log_id&quot;, &quot;ext&quot; and &quot;sig&quot; point to buffers allocated with
-     * OPENSSL_malloc().
-     */
-    unsigned char *log_id;
-    size_t log_id_len;
-
-    /*
-     * Note, we cannot distinguish between an unset timestamp, and one
-     * that is set to 0.  However since CT didn't exist in 1970, no real
-     * SCT should ever be set as such.
-     */
-    uint64_t timestamp;
-    unsigned char *ext;
-    size_t ext_len;
-    /* TODO(robpercival): Extract the following 4 fields into a struct */
-    unsigned char hash_alg;
-    unsigned char sig_alg;
-    unsigned char *sig;
-    size_t sig_len;
-    /* Log entry type */
-    log_entry_type_t entry_type;
-} SCT;
-
-DEFINE_STACK_OF(SCT)
-
+/* Handlers for Certificate Transparency X509v3/OCSP extensions */
 extern const X509V3_EXT_METHOD v3_ct_scts[];
 
-/*
- * Allocate new SCT.
- * Caller is responsible for calling SCT_free when done.
- */
-SCT *SCT_new(void);
-
-/*
- * Free SCT and underlying datastructures.
- */
-void SCT_free(SCT *sct);
-
-/*
- * Set the version of an SCT.
- * Returns 1 on success, 0 if the version is unrecognized.
- */
-int SCT_set_version(SCT *sct, sct_version_t version);
-
-/*
- * Set the log entry type of an SCT.
- * Returns 1 on success.
- */
-int SCT_set_log_entry_type(SCT *sct, log_entry_type_t entry_type);
-
-/*
- * Set the log ID of an SCT to point directly to the *log_id specified.
- * The SCT takes ownership of the specified pointer.
- * Returns 1 on success.
- */
-int SCT_set0_log_id(SCT *sct, unsigned char *log_id, size_t log_id_len);
-
-/*
- * Set the log ID of an SCT.
- * This makes a copy of the log_id.
- * Returns 1 on success.
- */
-int SCT_set1_log_id(SCT *sct, const unsigned char *log_id, size_t log_id_len);
-
-/*
- * Set the timestamp of an SCT.
- */
-void SCT_set_timestamp(SCT *sct, uint64_t timestamp);
-
-/*
- * Set the signature type of an SCT
- * Currently NID_sha256WithRSAEncryption or NID_ecdsa_with_SHA256.
- * Returns 1 on success.
- */
-int SCT_set_signature_nid(SCT *sct, int nid);
-
-/*
- * Set the extensions of an SCT to point directly to the *ext specified.
- * The SCT takes ownership of the specified pointer.
- */
-void SCT_set0_extensions(SCT *sct, unsigned char *ext, size_t ext_len);
-
-/*
- * Set the extensions of an SCT.
- * This takes a copy of the ext.
- * Returns 1 on success.
- */
-int SCT_set1_extensions(SCT *sct, const unsigned char *ext, size_t ext_len);
-
-/*
- * Set the signature of an SCT to point directly to the *sig specified.
- * The SCT takes ownership of the specified pointer.
- */
-void SCT_set0_signature(SCT *sct, unsigned char *sig, size_t sig_len);
-
-/*
- * Set the signature of an SCT to be a copy of the *sig specified.
- * Returns 1 on success.
- */
-int SCT_set1_signature(SCT *sct, const unsigned char *sig, size_t sig_len);
-
-/*
- * Returns the version of the SCT.
- */
-sct_version_t SCT_get_version(const SCT *sct);
-
-/*
- * Returns the log entry type of the SCT.
- */
-log_entry_type_t SCT_get_log_entry_type(const SCT *sct);
-
-/*
- * Set *log_id to point to the log id for the SCT. log_id must not be NULL.
- * The SCT retains ownership of this pointer.
- * Returns length of the data pointed to.
- */
-size_t SCT_get0_log_id(const SCT *sct, unsigned char **log_id);
-
-/*
- * Returns the timestamp for the SCT.
- */
-uint64_t SCT_get_timestamp(const SCT *sct);
-
-/*
- * Return the nid for the signature used by the SCT.
- * Currently NID_sha256WithRSAEncryption or NID_ecdsa_with_SHA256
- * (or NID_undef).
- */
-int SCT_get_signature_nid(const SCT *sct);
-
-/*
- * Set *ext to point to the extension data for the SCT. ext must not be NULL.
- * The SCT retains ownership of this pointer.
- * Returns length of the data pointed to.
- */
-size_t SCT_get0_extensions(const SCT *sct, unsigned char **ext);
-
-/*
- * Set *sig to point to the signature for the SCT. sig must not be NULL.
- * The SCT retains ownership of this pointer.
- * Returns length of the data pointed to.
- */
-size_t SCT_get0_signature(const SCT *sct, unsigned char **sig);
-
-/*
- * Pretty-print debug information about a SCT, indented as specified.
- */
-void SCT_print(SCT *sct, BIO *out, int indent);
-
-/*
- * Does this SCT have the minimum fields populated to be valid?
- * Returns 1 if so, 0 otherwise.
- * This does not verify the SCT signature.
- */
-int SCT_is_valid(const SCT *sct);
-
-/*
- * Is the signature of this SCT valid?
- * Returns 1 if so, 0 otherwise.
- * This checks that the signature and hash algorithms are supported and that the
- * signature field is set.
- */
-int SCT_signature_is_valid(const SCT *sct);
-
-/*
- * Free a stack of SCTs, and the underlying SCTs themselves.
- * Intended to be compatible with X509V3_EXT_FREE.
- */
-void SCT_LIST_free(STACK_OF(SCT) *a);
-
-/*
- * Serialize (to TLS format) a stack of SCTs and return the length.
- * &quot;a&quot; must not be NULL.
- * If &quot;pp&quot; is NULL, just return the length of what would have been serialized.
- * If &quot;pp&quot; is not NULL and &quot;*pp&quot; is null, function will allocate a new pointer
- * for data that caller is responsible for freeing (only if function returns
- * successfully).
- * If &quot;pp&quot; is NULL and &quot;*pp&quot; is not NULL, caller is responsible for ensuring
- * that &quot;*pp&quot; is large enough to accept all of the serializied data.
- * Returns &lt; 0 on error, &gt;= 0 indicating bytes written (or would have been)
- * on success.
- */
-int i2o_SCT_LIST(STACK_OF(SCT) *a, unsigned char **pp);
-
-/*
-* Parses an SCT signature in TLS format and populates the |sct| with it.
-* |in| should be a pointer to a string contianing the TLS-format signature.
-* |in| will be advanced to the end of the signature if parsing succeeds.
-* |len| should be the length of the signature in |in|.
-* Returns the number of bytes parsed, or a negative integer if an error occurs.
-*/
-int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len);
-
-/*
- * Parses an SCT in TLS format and returns it.
- * If |psct| is not null, it will end up pointing to the parsed SCT. If it
- * already points to a non-null pointer, the pointer will be free'd.
- * |in| should be a pointer to a string contianing the TLS-format SCT.
- * |in| will be advanced to the end of the SCT if parsing succeeds.
- * |len| should be the length of the SCT in |in|.
- * Returns NULL if an error occurs.
- * If the SCT is an unsupported version, only the SCT's 'sct' and 'sct_len'
- * fields will be populated (with |in| and |len| respectively).
- */
-SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len);
-
-/*
-* Converts an |sct| signature into TLS format and writes it to |out|.
-* If |out| is null, no signature will be output but the length will be returned.
-* If |out| points to a null pointer, a string will be allocated to hold the
-* TLS-format signature. It is the responsibility of the caller to free it.
-* If |out| points to an allocated string, the signature will be written to it.
-* The length of the signature in TLS format will be returned.
-*/
-int i2o_SCT_signature(const SCT *sct, unsigned char **out);
-
-/*
- * Converts an |sct| into TLS format and writes it to |out|.
- * If |out| is null, no SCT will be output but the length will still be returned.
- * If |out| points to a null pointer, a string will be allocated to hold the
- * TLS-format SCT. It is the responsibility of the caller to free it.
- * If |out| points to an allocated string, the TLS-format SCT will be written
- * to it.
- * The length of the SCT in TLS format will be returned.
- */
-int i2o_SCT(const SCT *sct, unsigned char **out);
-
-/*
- * Convert TLS format SCT list to a stack of SCTs.
- * If &quot;a&quot; or &quot;*a&quot; is NULL, a new stack will be created that the caller is
- * responsible for freeing (by calling SCT_LIST_free).
- * &quot;**pp&quot; and &quot;*pp&quot; must not be NULL.
- * Upon success, &quot;*pp&quot; will point to after the last bytes read, and a stack
- * will be returned.
- * Upon failure, a NULL pointer will be returned, and the position of &quot;*p&quot; is
- * not defined.
- */
-STACK_OF(SCT) *o2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,
-                            size_t len);
-
+# ifdef  __cplusplus
+}
 # endif
 
-/* BEGIN ERROR CODES */
-/*
- * The following lines are auto generated by the script mkerr.pl. Any changes
- * made after this point may be overwritten when the script is next run.
- */
-void ERR_load_CT_strings(void);
-
-/* Error codes for the CT functions. */
-
-/* Function codes. */
-# define CT_F_D2I_SCT_LIST                                105
-# define CT_F_I2D_SCT_LIST                                106
-# define CT_F_I2O_SCT                                     107
-# define CT_F_I2O_SCT_LIST                                108
-# define CT_F_I2O_SCT_SIGNATURE                           109
-# define CT_F_O2I_SCT                                     110
-# define CT_F_O2I_SCT_LIST                                111
-# define CT_F_O2I_SCT_SIGNATURE                           112
-# define CT_F_SCT_NEW                                     100
-# define CT_F_SCT_SET0_LOG_ID                             101
-# define CT_F_SCT_SET1_EXTENSIONS                         114
-# define CT_F_SCT_SET1_LOG_ID                             115
-# define CT_F_SCT_SET1_SIGNATURE                          116
-# define CT_F_SCT_SET_LOG_ENTRY_TYPE                      102
-# define CT_F_SCT_SET_SIGNATURE_NID                       103
-# define CT_F_SCT_SET_VERSION                             104
-# define CT_F_SCT_SIGNATURE_IS_VALID                      113
-
-/* Reason codes. */
-# define CT_R_INVALID_LOG_ID_LENGTH                       100
-# define CT_R_SCT_INVALID                                 104
-# define CT_R_SCT_INVALID_SIGNATURE                       107
-# define CT_R_SCT_LIST_INVALID                            105
-# define CT_R_SCT_NOT_SET                                 106
-# define CT_R_UNRECOGNIZED_SIGNATURE_NID                  101
-# define CT_R_UNSUPPORTED_ENTRY_TYPE                      102
-# define CT_R_UNSUPPORTED_VERSION                         103
-
-#ifdef  __cplusplus
-}
-#endif
-#endif
+#endif /* HEADER_CT_INT_H */
diff --git a/crypto/include/internal/ct_int.h b/include/openssl/ct.h
similarity index 57%
copy from crypto/include/internal/ct_int.h
copy to include/openssl/ct.h
index b564dce..520174f 100644
--- a/crypto/include/internal/ct_int.h
+++ b/include/openssl/ct.h
@@ -1,147 +1,139 @@
 /*
- * Written by Dr Stephen N Henson (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL project
- * 2015.
- */
+* Public API for Certificate Transparency (CT).
+* Written by Rob Percival (<A HREF="../../../mailman/listinfo/openssl-commits.html">robpercival at google.com</A>) for the OpenSSL project.
+*/
 /* ====================================================================
- * Copyright (c) 2015 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">licensing at OpenSSL.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- */
-#ifndef HEADER_CT_LOCL_H
-# define HEADER_CT_LOCL_H
+* Copyright (c) 2016 The OpenSSL Project.  All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+*    notice, this list of conditions and the following disclaimer.
+*
+* 2. Redistributions in binary form must reproduce the above copyright
+*    notice, this list of conditions and the following disclaimer in
+*    the documentation and/or other materials provided with the
+*    distribution.
+*
+* 3. All advertising materials mentioning features or use of this
+*    software must display the following acknowledgment:
+*    &quot;This product includes software developed by the OpenSSL Project
+*    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
+*
+* 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+*    endorse or promote products derived from this software without
+*    prior written permission. For written permission, please contact
+*    <A HREF="../../../mailman/listinfo/openssl-commits.html">licensing at OpenSSL.org.</A>
+*
+* 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+*    nor may &quot;OpenSSL&quot; appear in their names without prior written
+*    permission of the OpenSSL Project.
+*
+* 6. Redistributions of any form whatsoever must retain the following
+*    acknowledgment:
+*    &quot;This product includes software developed by the OpenSSL Project
+*    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
+*
+* THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+* EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+* PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+* ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+* OF THE POSSIBILITY OF SUCH DAMAGE.
+* ====================================================================
+*/
 
-# ifdef __cplusplus
-extern &quot;C&quot; {
-# endif
+#ifdef OPENSSL_NO_CT
+# error &quot;CT is disabled&quot;
+#endif
 
-# ifndef OPENSSL_NO_CT
+#ifndef HEADER_CT_H
+# define HEADER_CT_H
 
-# include &lt;openssl/x509v3.h&gt;
+# include &lt;openssl/ossl_typ.h&gt;
+# include &lt;openssl/safestack.h&gt;
+# include &lt;openssl/x509.h&gt;
 
-/* All hashes are currently SHA256 */
-#  define SCT_V1_HASHLEN  32
-/* Minimum RSA key size, from RFC6962 */
-#  define SCT_MIN_RSA_BITS 2048
+# ifdef  __cplusplus
+extern &quot;C&quot; {
+# endif
 
-/*
- * From RFC6962: opaque SerializedSCT&lt;1..2^16-1&gt;; struct { SerializedSCT
- * sct_list &lt;1..2^16-1&gt;; } SignedCertificateTimestampList;
- */
+/* Minimum RSA key size, from RFC6962 */
+# define SCT_MIN_RSA_BITS 2048
 
-#  define MAX_SCT_SIZE            65535
-#  define MAX_SCT_LIST_SIZE       MAX_SCT_SIZE
+/* All hashes are SHA256 in v1 of Certificate Transparency */
+# define CT_V1_HASHLEN SHA256_DIGEST_LENGTH
 
 typedef enum {
-    UNSET_ENTRY = -1,
-    X509_ENTRY = 0,
-    PRECERT_ENTRY = 1
-} log_entry_type_t;
+    CT_LOG_ENTRY_TYPE_NOT_SET = -1,
+    CT_LOG_ENTRY_TYPE_X509 = 0,
+    CT_LOG_ENTRY_TYPE_PRECERT = 1
+} ct_log_entry_type_t;
 
 typedef enum {
-    UNSET_VERSION = -1,
-    SCT_V1 = 0
+    SCT_VERSION_NOT_SET = -1,
+    SCT_VERSION_V1 = 0
 } sct_version_t;
 
-typedef struct {
-    sct_version_t version;
-    /* If version is not SCT_V1 this contains the encoded SCT */
-    unsigned char *sct;
-    size_t sct_len;
-    /*
-     * If version is SCT_V1, fields below contain components of the SCT.
-     * &quot;log_id&quot;, &quot;ext&quot; and &quot;sig&quot; point to buffers allocated with
-     * OPENSSL_malloc().
-     */
-    unsigned char *log_id;
-    size_t log_id_len;
-
-    /*
-     * Note, we cannot distinguish between an unset timestamp, and one
-     * that is set to 0.  However since CT didn't exist in 1970, no real
-     * SCT should ever be set as such.
-     */
-    uint64_t timestamp;
-    unsigned char *ext;
-    size_t ext_len;
-    /* TODO(robpercival): Extract the following 4 fields into a struct */
-    unsigned char hash_alg;
-    unsigned char sig_alg;
-    unsigned char *sig;
-    size_t sig_len;
-    /* Log entry type */
-    log_entry_type_t entry_type;
-} SCT;
-
 DEFINE_STACK_OF(SCT)
 
-extern const X509V3_EXT_METHOD v3_ct_scts[];
+/*****************
+ * SCT functions *
+ *****************/
 
 /*
- * Allocate new SCT.
- * Caller is responsible for calling SCT_free when done.
+ * Creates a new, blank SCT.
+ * The caller is responsible for calling SCT_free when finished with the SCT.
  */
 SCT *SCT_new(void);
 
 /*
- * Free SCT and underlying datastructures.
+ * Frees the SCT and the underlying data structures.
  */
 void SCT_free(SCT *sct);
 
 /*
+ * Free a stack of SCTs, and the underlying SCTs themselves.
+ * Intended to be compatible with X509V3_EXT_FREE.
+ */
+void SCT_LIST_free(STACK_OF(SCT) *a);
+
+/*
+ * Returns the version of the SCT.
+ */
+sct_version_t SCT_get_version(const SCT *sct);
+
+/*
  * Set the version of an SCT.
  * Returns 1 on success, 0 if the version is unrecognized.
  */
 int SCT_set_version(SCT *sct, sct_version_t version);
 
 /*
+ * Returns the log entry type of the SCT.
+ */
+ct_log_entry_type_t SCT_get_log_entry_type(const SCT *sct);
+
+/*
  * Set the log entry type of an SCT.
  * Returns 1 on success.
  */
-int SCT_set_log_entry_type(SCT *sct, log_entry_type_t entry_type);
+int SCT_set_log_entry_type(SCT *sct, ct_log_entry_type_t entry_type);
+
+/*
+ * Gets the ID of the log that an SCT came from.
+ * Ownership of the log ID remains with the SCT.
+ * Returns the length of the log ID.
+ */
+size_t SCT_get0_log_id(const SCT *sct, unsigned char **log_id);
 
 /*
  * Set the log ID of an SCT to point directly to the *log_id specified.
@@ -158,18 +150,38 @@ int SCT_set0_log_id(SCT *sct, unsigned char *log_id, size_t log_id_len);
 int SCT_set1_log_id(SCT *sct, const unsigned char *log_id, size_t log_id_len);
 
 /*
- * Set the timestamp of an SCT.
+ * Returns the timestamp for the SCT (epoch time in milliseconds).
+ */
+uint64_t SCT_get_timestamp(const SCT *sct);
+
+/*
+ * Set the timestamp of an SCT (epoch time in milliseconds).
  */
 void SCT_set_timestamp(SCT *sct, uint64_t timestamp);
 
 /*
+ * Return the NID for the signature used by the SCT.
+ * For CT v1, this will be either NID_sha256WithRSAEncryption or
+ * NID_ecdsa_with_SHA256 (or NID_undef if incorrect/unset).
+ */
+int SCT_get_signature_nid(const SCT *sct);
+
+/*
  * Set the signature type of an SCT
- * Currently NID_sha256WithRSAEncryption or NID_ecdsa_with_SHA256.
+ * For CT v1, this should be either NID_sha256WithRSAEncryption or
+ * NID_ecdsa_with_SHA256.
  * Returns 1 on success.
  */
 int SCT_set_signature_nid(SCT *sct, int nid);
 
 /*
+ * Set *ext to point to the extension data for the SCT. ext must not be NULL.
+ * The SCT retains ownership of this pointer.
+ * Returns length of the data pointed to.
+ */
+size_t SCT_get0_extensions(const SCT *sct, unsigned char **ext);
+
+/*
  * Set the extensions of an SCT to point directly to the *ext specified.
  * The SCT takes ownership of the specified pointer.
  */
@@ -183,6 +195,13 @@ void SCT_set0_extensions(SCT *sct, unsigned char *ext, size_t ext_len);
 int SCT_set1_extensions(SCT *sct, const unsigned char *ext, size_t ext_len);
 
 /*
+ * Set *sig to point to the signature for the SCT. sig must not be NULL.
+ * The SCT retains ownership of this pointer.
+ * Returns length of the data pointed to.
+ */
+size_t SCT_get0_signature(const SCT *sct, unsigned char **sig);
+
+/*
  * Set the signature of an SCT to point directly to the *sig specified.
  * The SCT takes ownership of the specified pointer.
  */
@@ -195,78 +214,54 @@ void SCT_set0_signature(SCT *sct, unsigned char *sig, size_t sig_len);
 int SCT_set1_signature(SCT *sct, const unsigned char *sig, size_t sig_len);
 
 /*
- * Returns the version of the SCT.
- */
-sct_version_t SCT_get_version(const SCT *sct);
-
-/*
- * Returns the log entry type of the SCT.
- */
-log_entry_type_t SCT_get_log_entry_type(const SCT *sct);
-
-/*
- * Set *log_id to point to the log id for the SCT. log_id must not be NULL.
- * The SCT retains ownership of this pointer.
- * Returns length of the data pointed to.
- */
-size_t SCT_get0_log_id(const SCT *sct, unsigned char **log_id);
-
-/*
- * Returns the timestamp for the SCT.
- */
-uint64_t SCT_get_timestamp(const SCT *sct);
-
-/*
- * Return the nid for the signature used by the SCT.
- * Currently NID_sha256WithRSAEncryption or NID_ecdsa_with_SHA256
- * (or NID_undef).
- */
-int SCT_get_signature_nid(const SCT *sct);
-
-/*
- * Set *ext to point to the extension data for the SCT. ext must not be NULL.
- * The SCT retains ownership of this pointer.
- * Returns length of the data pointed to.
- */
-size_t SCT_get0_extensions(const SCT *sct, unsigned char **ext);
-
-/*
- * Set *sig to point to the signature for the SCT. sig must not be NULL.
- * The SCT retains ownership of this pointer.
- * Returns length of the data pointed to.
+ * Pretty-prints an |sct| to |out|.
+ * It will be indented by the number of spaces specified by |indent|.
  */
-size_t SCT_get0_signature(const SCT *sct, unsigned char **sig);
+void SCT_print(const SCT *sct, BIO *out, int indent);
 
 /*
- * Pretty-print debug information about a SCT, indented as specified.
+ * Pretty-prints an |sct_list| to |out|.
+ * It will be indented by the number of spaces specified by |indent|.
+ * SCTs will be delimited by |separator|.
  */
-void SCT_print(SCT *sct, BIO *out, int indent);
+void SCT_LIST_print(const STACK_OF(SCT) *sct_list, BIO *out, int indent,
+                    const char *separator);
 
-/*
- * Does this SCT have the minimum fields populated to be valid?
- * Returns 1 if so, 0 otherwise.
- * This does not verify the SCT signature.
- */
-int SCT_is_valid(const SCT *sct);
+/*********************************
+ * SCT parsing and serialisation *
+ *********************************/
 
 /*
- * Is the signature of this SCT valid?
- * Returns 1 if so, 0 otherwise.
- * This checks that the signature and hash algorithms are supported and that the
- * signature field is set.
+ * Serialize (to TLS format) a stack of SCTs and return the length.
+ * &quot;a&quot; must not be NULL.
+ * If &quot;pp&quot; is NULL, just return the length of what would have been serialized.
+ * If &quot;pp&quot; is not NULL and &quot;*pp&quot; is null, function will allocate a new pointer
+ * for data that caller is responsible for freeing (only if function returns
+ * successfully).
+ * If &quot;pp&quot; is NULL and &quot;*pp&quot; is not NULL, caller is responsible for ensuring
+ * that &quot;*pp&quot; is large enough to accept all of the serializied data.
+ * Returns &lt; 0 on error, &gt;= 0 indicating bytes written (or would have been)
+ * on success.
  */
-int SCT_signature_is_valid(const SCT *sct);
+int i2o_SCT_LIST(const STACK_OF(SCT) *a, unsigned char **pp);
 
 /*
- * Free a stack of SCTs, and the underlying SCTs themselves.
- * Intended to be compatible with X509V3_EXT_FREE.
+ * Convert TLS format SCT list to a stack of SCTs.
+ * If &quot;a&quot; or &quot;*a&quot; is NULL, a new stack will be created that the caller is
+ * responsible for freeing (by calling SCT_LIST_free).
+ * &quot;**pp&quot; and &quot;*pp&quot; must not be NULL.
+ * Upon success, &quot;*pp&quot; will point to after the last bytes read, and a stack
+ * will be returned.
+ * Upon failure, a NULL pointer will be returned, and the position of &quot;*pp&quot; is
+ * not defined.
  */
-void SCT_LIST_free(STACK_OF(SCT) *a);
+STACK_OF(SCT) *o2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,
+                            size_t len);
 
 /*
- * Serialize (to TLS format) a stack of SCTs and return the length.
+ * Serialize (to DER format) a stack of SCTs and return the length.
  * &quot;a&quot; must not be NULL.
- * If &quot;pp&quot; is NULL, just return the length of what would have been serialized.
+ * If &quot;pp&quot; is NULL, just returns the length of what would have been serialized.
  * If &quot;pp&quot; is not NULL and &quot;*pp&quot; is null, function will allocate a new pointer
  * for data that caller is responsible for freeing (only if function returns
  * successfully).
@@ -275,16 +270,31 @@ void SCT_LIST_free(STACK_OF(SCT) *a);
  * Returns &lt; 0 on error, &gt;= 0 indicating bytes written (or would have been)
  * on success.
  */
-int i2o_SCT_LIST(STACK_OF(SCT) *a, unsigned char **pp);
+int i2d_SCT_LIST(STACK_OF(SCT) *a, unsigned char **pp);
 
 /*
-* Parses an SCT signature in TLS format and populates the |sct| with it.
-* |in| should be a pointer to a string contianing the TLS-format signature.
-* |in| will be advanced to the end of the signature if parsing succeeds.
-* |len| should be the length of the signature in |in|.
-* Returns the number of bytes parsed, or a negative integer if an error occurs.
-*/
-int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len);
+ * Parses an SCT list in DER format and returns it.
+ * If &quot;a&quot; or &quot;*a&quot; is NULL, a new stack will be created that the caller is
+ * responsible for freeing (by calling SCT_LIST_free).
+ * &quot;**pp&quot; and &quot;*pp&quot; must not be NULL.
+ * Upon success, &quot;*pp&quot; will point to after the last bytes read, and a stack
+ * will be returned.
+ * Upon failure, a NULL pointer will be returned, and the position of &quot;*pp&quot; is
+ * not defined.
+ */
+STACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,
+                            long len);
+
+/*
+ * Serialize (to TLS format) an |sct| and write it to |out|.
+ * If |out| is null, no SCT will be output but the length will still be returned.
+ * If |out| points to a null pointer, a string will be allocated to hold the
+ * TLS-format SCT. It is the responsibility of the caller to free it.
+ * If |out| points to an allocated string, the TLS-format SCT will be written
+ * to it.
+ * The length of the SCT in TLS format will be returned.
+ */
+int i2o_SCT(const SCT *sct, unsigned char **out);
 
 /*
  * Parses an SCT in TLS format and returns it.
@@ -300,7 +310,7 @@ int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len);
 SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len);
 
 /*
-* Converts an |sct| signature into TLS format and writes it to |out|.
+* Serialize (to TLS format) an |sct| signature and write it to |out|.
 * If |out| is null, no signature will be output but the length will be returned.
 * If |out| points to a null pointer, a string will be allocated to hold the
 * TLS-format signature. It is the responsibility of the caller to free it.
@@ -310,30 +320,13 @@ SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len);
 int i2o_SCT_signature(const SCT *sct, unsigned char **out);
 
 /*
- * Converts an |sct| into TLS format and writes it to |out|.
- * If |out| is null, no SCT will be output but the length will still be returned.
- * If |out| points to a null pointer, a string will be allocated to hold the
- * TLS-format SCT. It is the responsibility of the caller to free it.
- * If |out| points to an allocated string, the TLS-format SCT will be written
- * to it.
- * The length of the SCT in TLS format will be returned.
- */
-int i2o_SCT(const SCT *sct, unsigned char **out);
-
-/*
- * Convert TLS format SCT list to a stack of SCTs.
- * If &quot;a&quot; or &quot;*a&quot; is NULL, a new stack will be created that the caller is
- * responsible for freeing (by calling SCT_LIST_free).
- * &quot;**pp&quot; and &quot;*pp&quot; must not be NULL.
- * Upon success, &quot;*pp&quot; will point to after the last bytes read, and a stack
- * will be returned.
- * Upon failure, a NULL pointer will be returned, and the position of &quot;*p&quot; is
- * not defined.
- */
-STACK_OF(SCT) *o2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,
-                            size_t len);
-
-# endif
+* Parses an SCT signature in TLS format and populates the |sct| with it.
+* |in| should be a pointer to a string contianing the TLS-format signature.
+* |in| will be advanced to the end of the signature if parsing succeeds.
+* |len| should be the length of the signature in |in|.
+* Returns the number of bytes parsed, or a negative integer if an error occurs.
+*/
+int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len);
 
 /* BEGIN ERROR CODES */
 /*
diff --git a/include/openssl/ossl_typ.h b/include/openssl/ossl_typ.h
index d29be73..536ffa2 100644
--- a/include/openssl/ossl_typ.h
+++ b/include/openssl/ossl_typ.h
@@ -200,6 +200,8 @@ typedef struct ocsp_req_ctx_st OCSP_REQ_CTX;
 typedef struct ocsp_response_st OCSP_RESPONSE;
 typedef struct ocsp_responder_id_st OCSP_RESPID;
 
+typedef struct sct_st SCT;
+
 #if defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L &amp;&amp; \
     defined(INTMAX_MAX) &amp;&amp; defined(UINTMAX_MAX)
 typedef intmax_t ossl_intmax_t;
diff --git a/test/ct_test.c b/test/ct_test.c
index dd0d8d2..ac739ff 100644
--- a/test/ct_test.c
+++ b/test/ct_test.c
@@ -58,9 +58,8 @@
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 
-#include &quot;internal/ct_int.h&quot;
+#include &lt;openssl/ct.h&gt;
 #include &lt;openssl/err.h&gt;
-#include &lt;openssl/safestack.h&gt;
 #include &lt;openssl/ssl.h&gt;
 #include &lt;openssl/x509.h&gt;
 #include &lt;openssl/x509v3.h&gt;
diff --git a/util/libeay.num b/util/libeay.num
index 3eaa997..9323df0 100755
--- a/util/libeay.num
+++ b/util/libeay.num
@@ -4726,3 +4726,34 @@ CRYPTO_THREAD_get_local                 5229	1_1_0	EXIST::FUNCTION:
 CRYPTO_THREAD_get_current_id            5230	1_1_0	EXIST::FUNCTION:
 CRYPTO_THREAD_compare_id                5231	1_1_0	EXIST::FUNCTION:
 CRYPTO_THREAD_run_once                  5232	1_1_0	EXIST::FUNCTION:
+SCT_get0_extensions                     5233	1_1_0	EXIST::FUNCTION:
+SCT_get0_log_id                         5234	1_1_0	EXIST::FUNCTION:
+o2i_SCT_signature                       5235	1_1_0	EXIST::FUNCTION:
+i2o_SCT_signature                       5236	1_1_0	EXIST::FUNCTION:
+SCT_set_timestamp                       5237	1_1_0	EXIST::FUNCTION:
+i2o_SCT_LIST                            5238	1_1_0	EXIST::FUNCTION:
+SCT_get_version                         5239	1_1_0	EXIST::FUNCTION:
+i2d_SCT_LIST                            5240	1_1_0	EXIST::FUNCTION:
+SCT_set1_log_id                         5241	1_1_0	EXIST::FUNCTION:
+SCT_new                                 5242	1_1_0	EXIST::FUNCTION:
+SCT_get_signature_nid                   5243	1_1_0	EXIST::FUNCTION:
+SCT_set0_extensions                     5244	1_1_0	EXIST::FUNCTION:
+SCT_print                               5245	1_1_0	EXIST::FUNCTION:
+SCT_get_timestamp                       5246	1_1_0	EXIST::FUNCTION:
+SCT_set0_signature                      5247	1_1_0	EXIST::FUNCTION:
+o2i_SCT                                 5248	1_1_0	EXIST::FUNCTION:
+SCT_set1_signature                      5249	1_1_0	EXIST::FUNCTION:
+ERR_load_CT_strings                     5250	1_1_0	EXIST::FUNCTION:
+SCT_set_signature_nid                   5251	1_1_0	EXIST::FUNCTION:
+SCT_free                                5252	1_1_0	EXIST::FUNCTION:
+SCT_set1_extensions                     5253	1_1_0	EXIST::FUNCTION:
+SCT_set0_log_id                         5254	1_1_0	EXIST::FUNCTION:
+d2i_SCT_LIST                            5255	1_1_0	EXIST::FUNCTION:
+SCT_set_log_entry_type                  5256	1_1_0	EXIST::FUNCTION:
+SCT_LIST_print                          5257	1_1_0	EXIST::FUNCTION:
+SCT_get0_signature                      5258	1_1_0	EXIST::FUNCTION:
+i2o_SCT                                 5259	1_1_0	EXIST::FUNCTION:
+o2i_SCT_LIST                            5260	1_1_0	EXIST::FUNCTION:
+SCT_set_version                         5261	1_1_0	EXIST::FUNCTION:
+SCT_LIST_free                           5262	1_1_0	EXIST::FUNCTION:
+SCT_get_log_entry_type                  5263	1_1_0	EXIST::FUNCTION:
diff --git a/util/mkdef.pl b/util/mkdef.pl
index a7abfd2..a11b008 100755
--- a/util/mkdef.pl
+++ b/util/mkdef.pl
@@ -90,8 +90,8 @@ my @known_algorithms = ( &quot;RC2&quot;, &quot;RC4&quot;, &quot;RC5&quot;, &quot;IDEA&quot;, &quot;DES&quot;, &quot;BF&quot;,
                          &quot;STATIC_ENGINE&quot;, &quot;ENGINE&quot;, &quot;HW&quot;, &quot;GMP&quot;,
 			 # Entropy Gathering
 			 &quot;EGD&quot;,
-                         # X.509v3 Signed Certificate Timestamps
-                         &quot;SCT&quot;,
+			 # Certificate Transparency
+			 &quot;CT&quot;,
 			 # RFC3779
 			 &quot;RFC3779&quot;,
 			 # TLS
@@ -294,6 +294,7 @@ $crypto.=&quot; include/openssl/cms.h&quot;;
 $crypto.=&quot; include/openssl/srp.h&quot;;
 $crypto.=&quot; include/openssl/modes.h&quot;;
 $crypto.=&quot; include/openssl/async.h&quot;;
+$crypto.=&quot; include/openssl/ct.h&quot;;
 
 my $symhacks=&quot;include/openssl/symhacks.h&quot;;
 
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004577.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="004586.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4578">[ date ]</a>
              <a href="thread.html#4578">[ thread ]</a>
              <a href="subject.html#4578">[ subject ]</a>
              <a href="author.html#4578">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
