<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-February/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1456482300.739017.32759.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004537.html">
   <LINK REL="Next"  HREF="004547.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1456482300.739017.32759.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Fri Feb 26 10:25:00 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004537.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="004547.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4543">[ date ]</a>
              <a href="thread.html#4543">[ thread ]</a>
              <a href="subject.html#4543">[ subject ]</a>
              <a href="author.html#4543">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  71a04cfca03bf6d5a93ad3ffd23e0fb9e0da2919 (commit)
      from  bdcd83e1272c84f3de576f793ba03fdc2c21a557 (commit)


- Log -----------------------------------------------------------------
commit 71a04cfca03bf6d5a93ad3ffd23e0fb9e0da2919
Author: Alessandro Ghedini &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">alessandro at ghedini.me</A>&gt;
Date:   Sun Oct 25 17:43:55 2015 +0100

    Implement new multi-threading API
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 crypto/Makefile.in                                 |   2 +
 crypto/build.info                                  |   1 +
 test/exdatatest.c =&gt; crypto/threads_none.c         | 161 ++++++------
 .../internal/bn_conf.h.in =&gt; threads_pthread.c}    | 131 ++++++++--
 crypto/threads_win.c                               | 190 ++++++++++++++
 doc/crypto/threads.pod                             | 187 +++-----------
 include/{openssl/kdf.h =&gt; internal/threads.h}      |  62 +++--
 include/openssl/crypto.h                           |  10 +
 test/Makefile.in                                   |  12 +-
 test/build.info                                    |   6 +-
 test/recipes/{05-test_hmac.t =&gt; 90-test_threads.t} |   2 +-
 test/threadstest.c                                 | 283 +++++++++++++++++++++
 util/libeay.num                                    |  13 +
 util/mkdef.pl                                      |   1 +
 14 files changed, 785 insertions(+), 276 deletions(-)
 copy test/exdatatest.c =&gt; crypto/threads_none.c (53%)
 copy crypto/{include/internal/bn_conf.h.in =&gt; threads_pthread.c} (53%)
 create mode 100644 crypto/threads_win.c
 copy include/{openssl/kdf.h =&gt; internal/threads.h} (65%)
 copy test/recipes/{05-test_hmac.t =&gt; 90-test_threads.t} (51%)
 mode change 100644 =&gt; 100755
 create mode 100644 test/threadstest.c

diff --git a/crypto/Makefile.in b/crypto/Makefile.in
index c8184e5..c29d44c 100644
--- a/crypto/Makefile.in
+++ b/crypto/Makefile.in
@@ -34,9 +34,11 @@ LIB= $(TOP)/libcrypto.a
 SHARED_LIB= libcrypto$(SHLIB_EXT)
 LIBSRC=	cryptlib.c mem.c mem_clr.c mem_dbg.c cversion.c ex_data.c cpt_err.c \
 	ebcdic.c uid.c o_time.c o_str.c o_dir.c thr_id.c lock.c \
+	threads_pthread.c threads_win.c threads_none.c \
 	o_init.c o_fips.c mem_sec.c init.c
 LIBOBJ= cryptlib.o mem.o mem_dbg.o cversion.o ex_data.o cpt_err.o \
 	ebcdic.o uid.o o_time.o o_str.o o_dir.o thr_id.o lock.o \
+	threads_pthread.o threads_win.o threads_none.o \
 	o_init.o o_fips.o mem_sec.o init.o $(CPUID_OBJ)
 
 SRC= $(LIBSRC)
diff --git a/crypto/build.info b/crypto/build.info
index a3ea7f0..24a009a 100644
--- a/crypto/build.info
+++ b/crypto/build.info
@@ -3,6 +3,7 @@ LIBS=../libcrypto
 SOURCE[../libcrypto]=\
         cryptlib.c mem.c mem_dbg.c cversion.c ex_data.c cpt_err.c \
         ebcdic.c uid.c o_time.c o_str.c o_dir.c thr_id.c lock.c \
+        threads_pthread.c threads_win.c threads_none.c \
         o_init.c o_fips.c mem_sec.c init.c {- $target{cpuid_asm_src} -}
 EXTRA=  ../ms/uplink-x86.pl ../ms/uplink.c ../ms/applink.c \
         x86cpuid.pl x86_64cpuid.pl ia64cpuid.S \
diff --git a/test/exdatatest.c b/crypto/threads_none.c
similarity index 53%
copy from test/exdatatest.c
copy to crypto/threads_none.c
index 96105bb..4e3b7a5 100644
--- a/test/exdatatest.c
+++ b/crypto/threads_none.c
@@ -1,5 +1,5 @@
 /* ====================================================================
- * Copyright (c) 2015 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 2016 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -45,104 +45,121 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
  */
-#include &lt;stdio.h&gt;
-#include &lt;assert.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdlib.h&gt;
+
 #include &lt;openssl/crypto.h&gt;
+#include &quot;internal/threads.h&quot;
 
-static long sargl;
-static void *sargp;
-static int sidx;
+#if !defined(OPENSSL_THREADS) || defined(CRYPTO_TDEBUG)
 
-static void exnew(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
-          int idx, long argl, void *argp)
+CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void)
 {
-    assert(idx == sidx);
-    assert(argl == sargl);
-    assert(argp == sargp);
+    CRYPTO_RWLOCK *lock = OPENSSL_zalloc(sizeof(unsigned int));
+    if (lock == NULL)
+        return NULL;
+
+    *(unsigned int *)lock = 1;
+
+    return lock;
 }
 
-static int exdup(CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from,
-          void *from_d, int idx, long argl, void *argp)
+int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock)
 {
-    assert(idx == sidx);
-    assert(argl == sargl);
-    assert(argp == sargp);
-    return 0;
+    OPENSSL_assert(*(unsigned int *)lock == 1);
+    return 1;
+}
+
+int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock)
+{
+    OPENSSL_assert(*(unsigned int *)lock == 1);
+    return 1;
 }
 
-static void exfree(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
-            int idx, long argl, void *argp)
+int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock)
 {
-    assert(idx == sidx);
-    assert(argl == sargl);
-    assert(argp == sargp);
+    OPENSSL_assert(*(unsigned int *)lock == 1);
+    return 1;
 }
 
-typedef struct myobj_st {
-    CRYPTO_EX_DATA ex_data;
-    int id;
-} MYOBJ;
+void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock) {
+    if (lock == NULL)
+        return;
 
-static MYOBJ *MYOBJ_new()
+    *(unsigned int *)lock = 0;
+    OPENSSL_free(lock);
+
+    return;
+}
+
+int CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void (*init)(void))
 {
-    static int count = 0;
-    MYOBJ *obj = OPENSSL_malloc(sizeof(*obj));
-    int st;
-
-    obj-&gt;id = ++count;
-    st = CRYPTO_new_ex_data(CRYPTO_EX_INDEX_APP, obj, &amp;obj-&gt;ex_data);
-    assert(st != 0);
-    return obj;
+    if (*once != 0)
+        return 1;
+
+    init();
+    *once = 1;
+
+    return 1;
 }
 
-static void MYOBJ_sethello(MYOBJ *obj, char *cp)
+#define OPENSSL_CRYPTO_THREAD_LOCAL_KEY_MAX 256
+
+static void *thread_local_storage[OPENSSL_CRYPTO_THREAD_LOCAL_KEY_MAX];
+
+int CRYPTO_THREAD_init_local(CRYPTO_THREAD_LOCAL *key, void (*cleanup)(void *))
 {
-    int st;
+    static unsigned int thread_local_key = 0;
+
+    if (thread_local_key &gt;= OPENSSL_CRYPTO_THREAD_LOCAL_KEY_MAX)
+        return 0;
 
-    st = CRYPTO_set_ex_data(&amp;obj-&gt;ex_data, sidx, cp);
-    assert(st != 0);
+    *key = thread_local_key++;
+
+    thread_local_storage[*key] = NULL;
+
+    return 1;
+}
+
+void *CRYPTO_THREAD_get_local(CRYPTO_THREAD_LOCAL *key)
+{
+    if (*key &gt;= OPENSSL_CRYPTO_THREAD_LOCAL_KEY_MAX)
+        return NULL;
+
+    return thread_local_storage[*key];
 }
 
-static char *MYOBJ_gethello(MYOBJ *obj)
+int CRYPTO_THREAD_set_local(CRYPTO_THREAD_LOCAL *key, void *val)
 {
-    return CRYPTO_get_ex_data(&amp;obj-&gt;ex_data, sidx);
+    if (*key &gt;= OPENSSL_CRYPTO_THREAD_LOCAL_KEY_MAX)
+        return 0;
+
+    thread_local_storage[*key] = val;
+
+    return 1;
 }
 
-static void MYOBJ_free(MYOBJ *obj)
+int CRYPTO_THREAD_cleanup_local(CRYPTO_THREAD_LOCAL *key)
 {
-    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_APP, obj, &amp;obj-&gt;ex_data);
-    OPENSSL_free(obj);
+    *key = OPENSSL_CRYPTO_THREAD_LOCAL_KEY_MAX + 1;
+    return 1;
 }
 
-int main()
+CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)
 {
-    MYOBJ *t1, *t2;
-    const char *cp;
-    char *p;
-
-    p = strdup(&quot;hello world&quot;);
-    sargl = 21;
-    sargp = malloc(1);
-    sidx = CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_APP, sargl, sargp,
-                                   exnew, exdup, exfree);
-    t1 = MYOBJ_new();
-    t2 = MYOBJ_new();
-    MYOBJ_sethello(t1, p);
-    cp = MYOBJ_gethello(t1);
-    assert(cp == p);
-    cp = MYOBJ_gethello(t2);
-    assert(cp == NULL);
-    MYOBJ_free(t1);
-    MYOBJ_free(t2);
-    free(sargp);
-    free(p);
     return 0;
 }
+
+int CRYPTO_THREAD_compare_id(CRYPTO_THREAD_ID a, CRYPTO_THREAD_ID b)
+{
+    return (a == b);
+}
+
+int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock)
+{
+    *val += amount;
+    *ret  = *val;
+
+    return 1;
+}
+
+#endif
diff --git a/crypto/include/internal/bn_conf.h.in b/crypto/threads_pthread.c
similarity index 53%
copy from crypto/include/internal/bn_conf.h.in
copy to crypto/threads_pthread.c
index e25a435..2b32e14 100644
--- a/crypto/include/internal/bn_conf.h.in
+++ b/crypto/threads_pthread.c
@@ -1,4 +1,3 @@
-{- join(&quot;\n&quot;,map { &quot;/* $_ */&quot; } @autowarntext) -}
 /* ====================================================================
  * Copyright (c) 2016 The OpenSSL Project.  All rights reserved.
  *
@@ -46,27 +45,123 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
  * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
  */
 
-#ifndef HEADER_BN_CONF_H
-# define HEADER_BN_CONF_H
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/threads.h&quot;
 
-/*
- * The contents of this file are not used in the UEFI build, as
- * both 32-bit and 64-bit builds are supported from a single run
- * of the Configure script.
- */
+#if defined(OPENSSL_THREADS) &amp;&amp; !defined(CRYPTO_TDEBUG) &amp;&amp; !defined(OPENSSL_SYS_WINDOWS)
+
+CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void)
+{
+    CRYPTO_RWLOCK *lock = OPENSSL_zalloc(sizeof(pthread_rwlock_t));
+    if (lock == NULL)
+        return NULL;
+
+    if (pthread_rwlock_init(lock, NULL) != 0)
+        return NULL;
+
+    return lock;
+}
+
+int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock)
+{
+    if (pthread_rwlock_rdlock(lock) != 0)
+        return 0;
+
+    return 1;
+}
+
+int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock)
+{
+    if (pthread_rwlock_wrlock(lock) != 0)
+        return 0;
+
+    return 1;
+}
+
+int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock)
+{
+    if (pthread_rwlock_unlock(lock) != 0)
+        return 0;
+
+    return 1;
+}
+
+void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock)
+{
+    if (lock == NULL)
+        return;
+
+    pthread_rwlock_destroy(lock);
+    OPENSSL_free(lock);
+
+    return;
+}
 
-/* Should we define BN_DIV2W here? */
+int CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void (*init)(void))
+{
+    if (pthread_once(once, init) != 0)
+        return 0;
+
+    return 1;
+}
+
+int CRYPTO_THREAD_init_local(CRYPTO_THREAD_LOCAL *key, void (*cleanup)(void *))
+{
+    if (pthread_key_create(key, cleanup) != 0)
+        return 0;
+
+    return 1;
+}
+
+void *CRYPTO_THREAD_get_local(CRYPTO_THREAD_LOCAL *key)
+{
+    return pthread_getspecific(*key);
+}
+
+int CRYPTO_THREAD_set_local(CRYPTO_THREAD_LOCAL *key, void *val)
+{
+    if (pthread_setspecific(*key, val) != 0)
+        return 0;
+
+    return 1;
+}
+
+int CRYPTO_THREAD_cleanup_local(CRYPTO_THREAD_LOCAL *key)
+{
+    if (pthread_key_delete(*key) != 0)
+        return 0;
+
+    return 1;
+}
+
+CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)
+{
+    return pthread_self();
+}
+
+int CRYPTO_THREAD_compare_id(CRYPTO_THREAD_ID a, CRYPTO_THREAD_ID b)
+{
+    return pthread_equal(a, b);
+}
+
+int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock)
+{
+#ifdef __ATOMIC_RELAXED
+    *ret = __atomic_add_fetch(val, amount, __ATOMIC_RELAXED);
+#else
+    if (!CRYPTO_THREAD_write_lock(lock))
+        return 0;
+
+    *val += amount;
+    *ret  = *val;
+
+    if (!CRYPTO_THREAD_unlock(lock))
+        return 0;
+#endif
 
-/* Only one for the following should be defined */
-{- $config{b64l} ? &quot;#define&quot; : &quot;#undef&quot; -} SIXTY_FOUR_BIT_LONG
-{- $config{b64}  ? &quot;#define&quot; : &quot;#undef&quot; -} SIXTY_FOUR_BIT
-{- $config{b32}  ? &quot;#define&quot; : &quot;#undef&quot; -} THIRTY_TWO_BIT
+    return 1;
+}
 
 #endif
diff --git a/crypto/threads_win.c b/crypto/threads_win.c
new file mode 100644
index 0000000..bee628f
--- /dev/null
+++ b/crypto/threads_win.c
@@ -0,0 +1,190 @@
+/* ====================================================================
+ * Copyright (c) 2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+ *
+ * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+ *    nor may &quot;OpenSSL&quot; appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/threads.h&quot;
+
+#if defined(OPENSSL_THREADS) &amp;&amp; !defined(CRYPTO_TDEBUG) &amp;&amp; defined(OPENSSL_SYS_WINDOWS)
+
+CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void)
+{
+    CRYPTO_RWLOCK *lock = OPENSSL_zalloc(sizeof(CRITICAL_SECTION));
+    if (lock == NULL)
+        return NULL;
+
+    /* 0x400 is the spin count value suggested in the documentation */
+    if (!InitializeCriticalSectionAndSpinCount(lock, 0x400))
+        return NULL;
+
+    return lock;
+}
+
+int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock)
+{
+    EnterCriticalSection(lock);
+    return 1;
+}
+
+int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock)
+{
+    EnterCriticalSection(lock);
+    return 1;
+}
+
+int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock)
+{
+    LeaveCriticalSection(lock);
+    return 1;
+}
+
+void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock)
+{
+    if (lock == NULL)
+        return;
+
+    DeleteCriticalSection(lock);
+    OPENSSL_free(lock);
+
+    return;
+}
+
+# if _WIN32_WINNT &lt; 0x0600
+
+#  define ONCE_UNINITED     0
+#  define ONCE_ININIT       1
+#  define ONCE_DONE         2
+
+int CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void (*init)(void))
+{
+    LONG volatile *lock = (LONG *)once;
+    LONG result;
+
+    if (*lock == ONCE_DONE)
+        return 1;
+
+    do {
+        result = InterlockedCompareExchange(lock, ONCE_ININIT, ONCE_UNINITED);
+        if (result == ONCE_UNINITED) {
+            init();
+            *lock = ONCE_DONE;
+            return 1;
+        }
+    } while (result == ONCE_ININIT);
+
+    return (*lock == ONCE_DONE);
+}
+
+# else
+
+BOOL CALLBACK once_cb(PINIT_ONCE once, PVOID p, PVOID *pp)
+{
+    void (*init)(void) = p;
+
+    init();
+
+    return TRUE;
+}
+
+void CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void (*init)(void))
+{
+    if (InitOnceExecuteOnce(once, once_cb, init, NULL))
+        return 0;
+
+    return 1;
+}
+
+# endif
+
+int CRYPTO_THREAD_init_local(CRYPTO_THREAD_LOCAL *key, void (*cleanup)(void *))
+{
+    *key = TlsAlloc();
+    if (*key == TLS_OUT_OF_INDEXES)
+        return 0;
+
+    return 1;
+}
+
+void *CRYPTO_THREAD_get_local(CRYPTO_THREAD_LOCAL *key)
+{
+    return TlsGetValue(*key);
+}
+
+int CRYPTO_THREAD_set_local(CRYPTO_THREAD_LOCAL *key, void *val)
+{
+    if (TlsSetValue(*key, val) == 0)
+        return 0;
+
+    return 1;
+}
+
+int CRYPTO_THREAD_cleanup_local(CRYPTO_THREAD_LOCAL *key)
+{
+    if (TlsFree(*key) == 0)
+        return 0;
+
+    return 1;
+}
+
+CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)
+{
+    return GetCurrentThreadId();
+}
+
+int CRYPTO_THREAD_compare_id(CRYPTO_THREAD_ID a, CRYPTO_THREAD_ID b)
+{
+    return (a == b);
+}
+
+int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock)
+{
+    *ret = InterlockedExchangeAdd(val, amount) + amount;
+    return 1;
+}
+
+#endif
diff --git a/doc/crypto/threads.pod b/doc/crypto/threads.pod
index 9ee75b3..90c5709 100644
--- a/doc/crypto/threads.pod
+++ b/doc/crypto/threads.pod
@@ -2,176 +2,66 @@
 
 =head1 NAME
 
-CRYPTO_THREADID_set_callback, CRYPTO_THREADID_get_callback,
-CRYPTO_THREADID_current, CRYPTO_THREADID_cmp, CRYPTO_THREADID_cpy,
-CRYPTO_THREADID_hash, CRYPTO_set_locking_callback, CRYPTO_num_locks,
-CRYPTO_set_dynlock_create_callback, CRYPTO_set_dynlock_lock_callback,
-CRYPTO_set_dynlock_destroy_callback, CRYPTO_get_new_dynlockid,
-CRYPTO_destroy_dynlockid, CRYPTO_lock - OpenSSL thread support
+CRYPTO_THREAD_lock_new, CRYPTO_THREAD_read_lock, CRYPTO_THREAD_write_lock,
+CRYPTO_THREAD_unlock, CRYPTO_THREAD_lock_free, CRYPTO_atomic_add - OpenSSL thread support
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/crypto.h&gt;
 
- /* Don't use this structure directly. */
- typedef struct crypto_threadid_st
-         {
-         void *ptr;
-         unsigned long val;
-         } CRYPTO_THREADID;
- /* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */
- void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val);
- void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);
- int CRYPTO_THREADID_set_callback(void (*threadid_func)(CRYPTO_THREADID *));
- void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *);
- void CRYPTO_THREADID_current(CRYPTO_THREADID *id);
- int CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,
-                         const CRYPTO_THREADID *b);
- void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,
-                          const CRYPTO_THREADID *src);
- unsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);
-
- int CRYPTO_num_locks(void);
-
- /* struct CRYPTO_dynlock_value needs to be defined by the user */
- struct CRYPTO_dynlock_value;
-
- void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *
-	(*dyn_create_function)(const char *file, int line));
- void CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)
-	(int mode, struct CRYPTO_dynlock_value *l,
-	const char *file, int line));
- void CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)
-	(struct CRYPTO_dynlock_value *l, const char *file, int line));
-
- int CRYPTO_get_new_dynlockid(void);
-
- void CRYPTO_destroy_dynlockid(int i);
-
- void CRYPTO_lock(int mode, int n, const char *file, int line);
-
- #define CRYPTO_w_lock(type)	\
-	CRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,OPENSSL_FILE,OPENSSL_LINE)
- #define CRYPTO_w_unlock(type)	\
-	CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,OPENSSL_FILE,OPENSSL_LINE)
- #define CRYPTO_r_lock(type)	\
-	CRYPTO_lock(CRYPTO_LOCK|CRYPTO_READ,type,OPENSSL_FILE,OPENSSL_LINE)
- #define CRYPTO_r_unlock(type)	\
-	CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_READ,type,OPENSSL_FILE,OPENSSL_LINE)
- #define CRYPTO_add(addr,amount,type)	\
-	CRYPTO_add_lock(addr,amount,type,OPENSSL_FILE,OPENSSL_LINE)
+ CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void);
+ int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock);
+ int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock);
+ int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock);
+ void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock);
+
+ int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock);
 
 =head1 DESCRIPTION
 
-OpenSSL can safely be used in multi-threaded applications provided
-that at least two callback functions are set, locking_function and
-threadid_func.
-
-locking_function(int mode, int n, const char *file, int line) is
-needed to perform locking on shared data structures. 
-(Note that OpenSSL uses a number of global data structures that
-will be implicitly shared whenever multiple threads use OpenSSL.)
-Multi-threaded applications will crash at random if it is not set.
-
-locking_function() must be able to handle up to CRYPTO_num_locks()
-different mutex locks. It sets the B&lt;n&gt;-th lock if B&lt;mode&gt; &amp;
-B&lt;CRYPTO_LOCK&gt;, and releases it otherwise.
-
-B&lt;file&gt; and B&lt;line&gt; are the file number of the function setting the
-lock. They can be useful for debugging.
-
-threadid_func(CRYPTO_THREADID *id) is needed to record the currently-executing
-thread's identifier into B&lt;id&gt;. The implementation of this callback should not
-fill in B&lt;id&gt; directly, but should use CRYPTO_THREADID_set_numeric() if thread
-IDs are numeric, or CRYPTO_THREADID_set_pointer() if they are pointer-based.
-The B&lt;id&gt; must be unique for the duration of the execution of the program.
-If the application does not register such a callback using
-CRYPTO_THREADID_set_callback(), then a default implementation is used - on
-Windows this uses the system's default thread identifying APIs, and on
-all other platforms it uses the address of B&lt;errno&gt;. The latter is satisfactory
-for thread-safety if and only if the platform has a thread-local error number
-facility.
-
-Once threadid_func() is registered, or if the built-in default implementation is
-to be used;
+OpenSSL can be safely used in multi-threaded applications provided that
+support for the underlying OS threading API is built-in. Currently, OpenSSL
+supports the pthread and Windows APIs. OpenSSL can also be built without
+any multi-threading support, for example on platforms that don't provide
+any threading support or that provide a threading API that is not yet
+supported by OpenSSL.
+
+The following multi-threading function are provided:
 
 =over 4
 
 =item *
-CRYPTO_THREADID_current() records the currently-executing thread ID into the
-given B&lt;id&gt; object.
+CRYPTO_THREAD_lock_new() allocates, initializes and returns a new read/write
+lock.
 
 =item *
-CRYPTO_THREADID_cmp() compares two thread IDs (returning zero for equality, ie.
-the same semantics as memcmp()).
+CRYPTO_THREAD_read_lock() locks the provided B&lt;lock&gt; for reading.
 
 =item *
-CRYPTO_THREADID_cpy() duplicates a thread ID value,
+CRYPTO_THREAD_write_lock() locks the provided B&lt;lock&gt; for writing.
 
 =item *
-CRYPTO_THREADID_hash() returns a numeric value usable as a hash-table key. This
-is usually the exact numeric or pointer-based thread ID used internally, however
-this also handles the unusual case where pointers are larger than 'long'
-variables and the platform's thread IDs are pointer-based - in this case, mixing
-is done to attempt to produce a unique numeric value even though it is not as
-wide as the platform's true thread IDs.
-
-=back
-
-Additionally, OpenSSL supports dynamic locks, and sometimes, some parts
-of OpenSSL need it for better performance.  To enable this, the following
-is required:
-
-=over 4
+CRYPTO_THREAD_unlock() unlocks the previously locked B&lt;lock&gt;.
 
 =item *
-Three additional callback function, dyn_create_function, dyn_lock_function
-and dyn_destroy_function.
+CRYPTO_THREAD_lock_frees() frees the provided B&lt;lock&gt;.
 
 =item *
-A structure defined with the data that each lock needs to handle.
+CRYPTO_atomic_add() atomically adds B&lt;amount&gt; to B&lt;val&gt; and returns the
+result of the operation in B&lt;ret&gt;. B&lt;lock&gt; will be locked, unless atomic
+operations are supported on the specific platform. Because of this, if a
+variable is modified by CRYPTO_atomic_add() then CRYPTO_atomic_add() must
+be the only way that the variable is modified.
 
 =back
 
-struct CRYPTO_dynlock_value has to be defined to contain whatever structure
-is needed to handle locks.
-
-dyn_create_function(const char *file, int line) is needed to create a
-lock.  Multi-threaded applications might crash at random if it is not set.
-
-dyn_lock_function(int mode, CRYPTO_dynlock *l, const char *file, int line)
-is needed to perform locking off dynamic lock numbered n. Multi-threaded
-applications might crash at random if it is not set.
-
-dyn_destroy_function(CRYPTO_dynlock *l, const char *file, int line) is
-needed to destroy the lock l. Multi-threaded applications might crash at
-random if it is not set.
-
-CRYPTO_get_new_dynlockid() is used to create locks.  It will call
-dyn_create_function for the actual creation.
-
-CRYPTO_destroy_dynlockid() is used to destroy locks.  It will call
-dyn_destroy_function for the actual destruction.
-
-CRYPTO_lock() is used to lock and unlock the locks.  mode is a bitfield
-describing what should be done with the lock.  n is the number of the
-lock as returned from CRYPTO_get_new_dynlockid().  mode can be combined
-from the following values.  These values are pairwise exclusive, with
-undefined behaviour if misused (for example, CRYPTO_READ and CRYPTO_WRITE
-should not be used together):
-
-	CRYPTO_LOCK	0x01
-	CRYPTO_UNLOCK	0x02
-	CRYPTO_READ	0x04
-	CRYPTO_WRITE	0x08
-
 =head1 RETURN VALUES
 
-CRYPTO_num_locks() returns the required number of locks.
+CRYPTO_THREAD_lock_new() returns the allocated lock, or NULL on error.
 
-CRYPTO_get_new_dynlockid() returns the index to the newly created lock.
+CRYPTO_THREAD_lock_frees() returns no value.
 
-The other functions return no values.
+The other functions return 1 on success or 0 on error.
 
 =head1 NOTES
 
@@ -185,21 +75,6 @@ You can find out if OpenSSL was configured with thread support:
    // no thread support
  #endif
 
-Also, dynamic locks are currently not used internally by OpenSSL, but
-may do so in the future.
-
-=head1 EXAMPLES
-
-B&lt;crypto/threads/mttest.c&gt; shows examples of the callback functions on
-Solaris, Irix and Win32.
-
-=head1 HISTORY
-
-B&lt;CRYPTO_THREADID&gt; and associated functions were introduced in OpenSSL 1.0.0
-to replace (actually, deprecate) the previous CRYPTO_set_id_callback(),
-CRYPTO_get_id_callback(), and CRYPTO_thread_id() functions which assumed
-thread IDs to always be represented by 'unsigned long'.
-
 =head1 SEE ALSO
 
 L&lt;crypto(3)&gt;
diff --git a/include/openssl/kdf.h b/include/internal/threads.h
similarity index 65%
copy from include/openssl/kdf.h
copy to include/internal/threads.h
index b28a3f2..7897728 100644
--- a/include/openssl/kdf.h
+++ b/include/internal/threads.h
@@ -1,7 +1,3 @@
-/*
- * Written by Dr Stephen N Henson (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL
- * project.
- */
 /* ====================================================================
  * Copyright (c) 2016 The OpenSSL Project.  All rights reserved.
  *
@@ -48,33 +44,49 @@
  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
  */
 
-#ifndef HEADER_KDF_H
-# define HEADER_KDF_H
+#ifndef HEADER_INTERNAL_THREADS_H
+# define HEADER_INTERNAL_THREADS_H
 
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
+#include &quot;e_os.h&quot;
 
-# define EVP_PKEY_CTRL_TLS_MD       (EVP_PKEY_ALG_CTRL)
-# define EVP_PKEY_CTRL_TLS_SECRET   (EVP_PKEY_ALG_CTRL + 1)
-# define EVP_PKEY_CTRL_TLS_SEED     (EVP_PKEY_ALG_CTRL + 2)
+# if !defined(OPENSSL_THREADS) || defined(CRYPTO_TDEBUG)
+typedef unsigned int CRYPTO_ONCE;
+typedef unsigned int CRYPTO_THREAD_LOCAL;
+typedef unsigned int CRYPTO_THREAD_ID;
 
-# define EVP_PKEY_CTX_set_tls1_prf_md(pctx, md) \
-            EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
-                              EVP_PKEY_CTRL_TLS_MD, 0, (void *)md)
+#  define CRYPTO_ONCE_STATIC_INIT 0
+# elif defined(OPENSSL_SYS_WINDOWS)
+#  include &lt;windows.h&gt;
+typedef DWORD CRYPTO_THREAD_LOCAL;
+typedef DWORD CRYPTO_THREAD_ID;
 
-# define EVP_PKEY_CTX_set1_tls1_prf_secret(pctx, sec, seclen) \
-            EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
-                              EVP_PKEY_CTRL_TLS_SECRET, seclen, (void *)sec)
+#  if _WIN32_WINNT &lt; 0x0600
+typedef LONG CRYPTO_ONCE;
+#   define CRYPTO_ONCE_STATIC_INIT 0
+#  else
+typedef INIT_ONCE CRYPTO_ONCE;
+#   define CRYPTO_ONCE_STATIC_INIT INIT_ONCE_STATIC_INIT
+#  endif
 
-# define EVP_PKEY_CTX_add1_tls1_prf_seed(pctx, seed, seedlen) \
-            EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
-                              EVP_PKEY_CTRL_TLS_SEED, seedlen, (void *)seed)
+# else
+#  include &lt;pthread.h&gt;
+typedef pthread_once_t CRYPTO_ONCE;
+typedef pthread_key_t CRYPTO_THREAD_LOCAL;
+typedef pthread_t CRYPTO_THREAD_ID;
+
+#  define CRYPTO_ONCE_STATIC_INIT PTHREAD_ONCE_INIT
+# endif
+
+int CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void (*init)(void));
+
+int CRYPTO_THREAD_init_local(CRYPTO_THREAD_LOCAL *key, void (*cleanup)(void *));
+void *CRYPTO_THREAD_get_local(CRYPTO_THREAD_LOCAL *key);
+int CRYPTO_THREAD_set_local(CRYPTO_THREAD_LOCAL *key, void *val);
+int CRYPTO_THREAD_cleanup_local(CRYPTO_THREAD_LOCAL *key);
+
+CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void);
+int CRYPTO_THREAD_compare_id(CRYPTO_THREAD_ID a, CRYPTO_THREAD_ID b);
 
-#ifdef  __cplusplus
-}
-#endif
 #endif
diff --git a/include/openssl/crypto.h b/include/openssl/crypto.h
index 2cabcc8..fb6a2b9 100644
--- a/include/openssl/crypto.h
+++ b/include/openssl/crypto.h
@@ -245,6 +245,16 @@ typedef struct {
     struct CRYPTO_dynlock_value *data;
 } CRYPTO_dynlock;
 
+typedef void CRYPTO_RWLOCK;
+
+CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void);
+int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock);
+int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock);
+int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock);
+void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock);
+
+int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock);
+
 /*
  * The following can be used to detect memory leaks in the library. If
  * used, it turns on malloc checking
diff --git a/test/Makefile.in b/test/Makefile.in
index 0b6938c..2fb1f49 100644
--- a/test/Makefile.in
+++ b/test/Makefile.in
@@ -82,6 +82,7 @@ SSLSKEWITH0PTEST=	sslskewith0ptest
 ASYNCTEST=	asynctest
 DTLSV1LISTENTEST = dtlsv1listentest
 CTTEST=	ct_test
+THREADSTEST=	threadstest
 
 TESTS=		alltests
 
@@ -103,7 +104,7 @@ EXE=	$(NPTEST)$(EXE_EXT) $(MEMLEAKTEST)$(EXE_EXT) \
 	$(HEARTBEATTEST)$(EXE_EXT) $(P5_CRPT2_TEST)$(EXE_EXT) \
 	$(CONSTTIMETEST)$(EXE_EXT) $(VERIFYEXTRATEST)$(EXE_EXT) \
 	$(CLIENTHELLOTEST)$(EXE_EXT) $(PACKETTEST)$(EXE_EXT) $(ASYNCTEST)$(EXE_EXT) \
-	$(DTLSV1LISTENTEST)$(EXE_EXT) $(CTTEST)$(EXE_EXT)
+	$(DTLSV1LISTENTEST)$(EXE_EXT) $(CTTEST)$(EXE_EXT) $(THREADSTEST)$(EXE_EXT)
 
 # $(METHTEST)$(EXE_EXT)
 
@@ -120,7 +121,8 @@ OBJ=	$(NPTEST).o $(MEMLEAKTEST).o \
 	$(EVPTEST).o $(EVPEXTRATEST).o $(IGETEST).o $(V3NAMETEST).o \
 	$(HEARTBEATTEST).o $(P5_CRPT2_TEST).o \
 	$(CONSTTIMETEST).o $(VERIFYEXTRATEST).o $(CLIENTHELLOTEST).o \
-	$(PACKETTEST).o $(ASYNCTEST).o $(DTLSV1LISTENTEST).o $(CTTEST).o testutil.o
+	$(PACKETTEST).o $(ASYNCTEST).o $(DTLSV1LISTENTEST).o $(CTTEST).o \
+	$(THREADSTEST).o testutil.o
 
 SRC=	$(NPTEST).c $(MEMLEAKTEST).c \
 	$(BNTEST).c $(ECTEST).c \
@@ -134,7 +136,8 @@ SRC=	$(NPTEST).c $(MEMLEAKTEST).c \
 	$(EVPTEST).c $(EVPEXTRATEST).c $(IGETEST).c $(V3NAMETEST).c \
 	$(HEARTBEATTEST).c $(P5_CRPT2_TEST).c \
 	$(CONSTTIMETEST).c $(VERIFYEXTRATEST).c $(CLIENTHELLOTEST).c \
-	$(PACKETTEST).c $(ASYNCTEST).c $(DTLSV1LISTENTEST).c $(CTTEST).c testutil.c
+	$(PACKETTEST).c $(ASYNCTEST).c $(DTLSV1LISTENTEST).c $(CTTEST).c \
+	$(THREADSTEST).c testutil.c
 
 HEADER=	testutil.h
 
@@ -373,6 +376,9 @@ $(DTLSV1LISTENTEST)$(EXE_EXT): $(DTLSV1LISTENTEST).o
 $(CTTEST)$(EXE_EXT): $(CTTEST).o testutil.o
 	@target=$(CTTEST) testutil=testutil.o;  $(BUILD_CMD)
 
+$(THREADSTEST)$(EXE_EXT): $(THREADSTEST).o $(DLIBCRYPTO)
+	@target=$(THREADSTEST) $(BUILD_CMD)
+
 dummytest$(EXE_EXT): dummytest.o $(DLIBCRYPTO)
 	@target=dummytest; $(BUILD_CMD)
 
diff --git a/test/build.info b/test/build.info
index f8ce69e..e3b0ee4 100644
--- a/test/build.info
+++ b/test/build.info
@@ -13,7 +13,7 @@ PROGRAMS=\
         danetest heartbeat_test p5_crpt2_test \
         constant_time_test verify_extra_test clienthellotest \
         packettest asynctest secmemtest srptest memleaktest \
-        dtlsv1listentest ct_test
+        dtlsv1listentest ct_test threadstest
 
 SOURCE[nptest]=nptest.c
 INCLUDE[nptest]={- rel2abs(catdir($builddir,&quot;../include&quot;)) -} ../include
@@ -206,3 +206,7 @@ DEPEND[dtlsv1listentest]=../libssl
 SOURCE[ct_test]=ct_test.c
 INCLUDE[ct_test]={- rel2abs(catdir($builddir,&quot;../include&quot;)) -} ../include
 DEPEND[ct_test]=../libcrypto
+
+SOURCE[threadstest]=threadstest.c
+INCLUDE[threadstest]={- rel2abs(catdir($builddir,&quot;../include&quot;)) -} .. ../include
+DEPEND[threadstest]=../libcrypto
diff --git a/test/recipes/05-test_hmac.t b/test/recipes/90-test_threads.t
old mode 100644
new mode 100755
similarity index 51%
copy from test/recipes/05-test_hmac.t
copy to test/recipes/90-test_threads.t
index ba7a92b..a08d8b0
--- a/test/recipes/05-test_hmac.t
+++ b/test/recipes/90-test_threads.t
@@ -2,4 +2,4 @@
 
 use OpenSSL::Test::Simple;
 
-simple_test(&quot;test_hmac&quot;, &quot;hmactest&quot;);
+simple_test(&quot;test_threads&quot;, &quot;threadstest&quot;);
diff --git a/test/threadstest.c b/test/threadstest.c
new file mode 100644
index 0000000..e3a9ff5
--- /dev/null
+++ b/test/threadstest.c
@@ -0,0 +1,283 @@
+/* ====================================================================
+ * Copyright (c) 2016 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+ *
+ * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+ *    nor may &quot;OpenSSL&quot; appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+#include &lt;stdio.h&gt;
+
+#include &lt;openssl/crypto.h&gt;
+#include &quot;internal/threads.h&quot;
+
+#if !defined(OPENSSL_THREADS) || defined(CRYPTO_TDEBUG)
+
+typedef unsigned int thread_t;
+
+static int run_thread(thread_t *t, void (*f)(void))
+{
+    f();
+    return 1;
+}
+
+static int wait_for_thread(thread_t thread)
+{
+    return 1;
+}
+
+#elif defined(OPENSSL_SYS_WINDOWS)
+
+typedef HANDLE thread_t;
+
+static DWORD WINAPI thread_run(LPVOID arg)
+{
+    void (*f)(void);
+
+    *(void **) (&amp;f) = arg;
+
+    f();
+    return 0;
+}
+
+static int run_thread(thread_t *t, void (*f)(void))
+{
+    *t = CreateThread(NULL, 0, thread_run, *(void **) &amp;f, 0, NULL);
+    return *t != NULL;
+}
+
+static int wait_for_thread(thread_t thread)
+{
+    return WaitForSingleObject(thread, INFINITE) == 0;
+}
+
+#else
+
+typedef pthread_t thread_t;
+
+static void *thread_run(void *arg)
+{
+    void (*f)(void);
+
+    *(void **) (&amp;f) = arg;
+
+    f();
+    return NULL;
+}
+
+static int run_thread(thread_t *t, void (*f)(void))
+{
+    return pthread_create(t, NULL, thread_run, *(void **) &amp;f) == 0;
+}
+
+static int wait_for_thread(thread_t thread)
+{
+    return pthread_join(thread, NULL) == 0;
+}
+
+#endif
+
+static int test_lock(void)
+{
+    CRYPTO_RWLOCK *lock = CRYPTO_THREAD_lock_new();
+
+    if (!CRYPTO_THREAD_read_lock(lock)) {
+        fprintf(stderr, &quot;CRYPTO_THREAD_read_lock() failed\n&quot;);
+        return 0;
+    }
+
+    if (!CRYPTO_THREAD_unlock(lock)) {
+        fprintf(stderr, &quot;CRYPTO_THREAD_unlock() failed\n&quot;);
+        return 0;
+    }
+
+    CRYPTO_THREAD_lock_free(lock);
+
+    return 1;
+}
+
+static CRYPTO_ONCE once_run = CRYPTO_ONCE_STATIC_INIT;
+static unsigned once_run_count = 0;
+
+static void once_do_run(void)
+{
+    once_run_count++;
+}
+
+static void once_run_thread_cb(void)
+{
+    CRYPTO_THREAD_run_once(&amp;once_run, once_do_run);
+}
+
+static int test_once(void)
+{
+    thread_t thread;
+    if (!run_thread(&amp;thread, once_run_thread_cb) ||
+        !wait_for_thread(thread))
+    {
+        fprintf(stderr, &quot;run_thread() failed\n&quot;);
+        return 0;
+    }
+
+    if (!CRYPTO_THREAD_run_once(&amp;once_run, once_do_run)) {
+        fprintf(stderr, &quot;CRYPTO_THREAD_run_once() failed\n&quot;);
+        return 0;
+    }
+
+    if (once_run_count != 1) {
+        fprintf(stderr, &quot;once run %u times\n&quot;, once_run_count);
+        return 0;
+    }
+
+    return 1;
+}
+
+static CRYPTO_THREAD_LOCAL thread_local_key;
+static unsigned destructor_run_count = 0;
+static int thread_local_thread_cb_ok = 0;
+
+static void thread_local_destructor(void *arg)
+{
+    unsigned *count;
+
+    if (arg == NULL)
+        return;
+
+    count = arg;
+
+    (*count)++;
+}
+
+static void thread_local_thread_cb(void)
+{
+    void *ptr;
+
+    ptr = CRYPTO_THREAD_get_local(&amp;thread_local_key);
+    if (ptr != NULL) {
+        fprintf(stderr, &quot;ptr not NULL\n&quot;);
+        return;
+    }
+
+    if (!CRYPTO_THREAD_set_local(&amp;thread_local_key, &amp;destructor_run_count)) {
+        fprintf(stderr, &quot;CRYPTO_THREAD_set_local() failed\n&quot;);
+        return;
+    }
+
+    ptr = CRYPTO_THREAD_get_local(&amp;thread_local_key);
+    if (ptr != &amp;destructor_run_count) {
+        fprintf(stderr, &quot;invalid ptr\n&quot;);
+        return;
+    }
+
+    thread_local_thread_cb_ok = 1;
+}
+
+static int test_thread_local(void)
+{
+    thread_t thread;
+    void *ptr = NULL;
+
+    if (!CRYPTO_THREAD_init_local(&amp;thread_local_key, thread_local_destructor)) {
+        fprintf(stderr, &quot;CRYPTO_THREAD_init_local() failed\n&quot;);
+        return 0;
+    }
+
+    ptr = CRYPTO_THREAD_get_local(&amp;thread_local_key);
+    if (ptr != NULL) {
+        fprintf(stderr, &quot;ptr not NULL\n&quot;);
+        return 0;
+    }
+
+    if (!run_thread(&amp;thread, thread_local_thread_cb) ||
+        !wait_for_thread(thread))
+    {
+        fprintf(stderr, &quot;run_thread() failed\n&quot;);
+        return 0;
+    }
+
+    if (thread_local_thread_cb_ok != 1) {
+        fprintf(stderr, &quot;thread-local thread callback failed\n&quot;);
+        return 0;
+    }
+
+#if defined(OPENSSL_THREADS) &amp;&amp; !defined(CRYPTO_TDEBUG)
+
+    ptr = CRYPTO_THREAD_get_local(&amp;thread_local_key);
+    if (ptr != NULL) {
+        fprintf(stderr, &quot;ptr not NULL\n&quot;);
+        return 0;
+    }
+
+# if !defined(OPENSSL_SYS_WINDOWS)
+    if (destructor_run_count != 1) {
+        fprintf(stderr, &quot;thread-local destructor run %u times\n&quot;,
+                destructor_run_count);
+        return 0;
+    }
+# endif
+
+#endif
+
+    if (!CRYPTO_THREAD_cleanup_local(&amp;thread_local_key)) {
+        fprintf(stderr, &quot;CRYPTO_THREAD_cleanup_local() failed\n&quot;);
+        return 0;
+    }
+
+    return 1;
+}
+
+int main(int argc, char **argv)
+{
+    if (!test_lock())
+      return 1;
+
+    if (!test_once())
+      return 1;
+
+    if (!test_thread_local())
+      return 1;
+
+    printf(&quot;PASS\n&quot;);
+    return 0;
+}
diff --git a/util/libeay.num b/util/libeay.num
index ad7ad9d..3eaa997 100755
--- a/util/libeay.num
+++ b/util/libeay.num
@@ -4713,3 +4713,16 @@ OPENSSL_INIT_free                       5216	1_1_0	EXIST::FUNCTION:
 OPENSSL_INIT_set_config_filename        5217	1_1_0	EXIST::FUNCTION:
 SRP_user_pwd_free                       5218	1_1_0	EXIST::FUNCTION:SRP
 SRP_VBASE_get1_by_user                  5219	1_1_0	EXIST::FUNCTION:SRP
+CRYPTO_THREAD_lock_new                  5220	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_lock_free                 5221	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_read_lock                 5222	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_write_lock                5223	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_unlock                    5224	1_1_0	EXIST::FUNCTION:
+CRYPTO_atomic_add                       5225	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_init_local                5226	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_cleanup_local             5227	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_set_local                 5228	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_get_local                 5229	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_get_current_id            5230	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_compare_id                5231	1_1_0	EXIST::FUNCTION:
+CRYPTO_THREAD_run_once                  5232	1_1_0	EXIST::FUNCTION:
diff --git a/util/mkdef.pl b/util/mkdef.pl
index a2fedc5..a79ddf5 100755
--- a/util/mkdef.pl
+++ b/util/mkdef.pl
@@ -236,6 +236,7 @@ $ssl.=&quot; include/openssl/srtp.h&quot;;
 my $crypto =&quot;include/openssl/crypto.h&quot;;
 $crypto.=&quot; include/internal/o_dir.h&quot;;
 $crypto.=&quot; include/internal/o_str.h&quot;;
+$crypto.=&quot; include/internal/threads.h&quot;;
 $crypto.=&quot; include/openssl/des.h&quot; ; # unless $no_des;
 $crypto.=&quot; include/openssl/idea.h&quot; ; # unless $no_idea;
 $crypto.=&quot; include/openssl/rc4.h&quot; ; # unless $no_rc4;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004537.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="004547.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4543">[ date ]</a>
              <a href="thread.html#4543">[ thread ]</a>
              <a href="subject.html#4543">[ subject ]</a>
              <a href="author.html#4543">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
