<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-February/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1456426848.605860.5998.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004487.html">
   <LINK REL="Next"  HREF="004493.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1456426848.605860.5998.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Thu Feb 25 19:00:48 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004487.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="004493.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4492">[ date ]</a>
              <a href="thread.html#4492">[ thread ]</a>
              <a href="subject.html#4492">[ subject ]</a>
              <a href="author.html#4492">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  5dc312215fa54b70cc8b4baec933bcc19525bc03 (commit)
       via  5ad29c54082ae0e00f389b2373c7ca065d3860ad (commit)
      from  5d3222876e7cbd8bf87fb3b9c951cba3c9be08eb (commit)


- Log -----------------------------------------------------------------
commit 5dc312215fa54b70cc8b4baec933bcc19525bc03
Author: Rob Percival &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">robpercival at google.com</A>&gt;
Date:   Mon Feb 22 16:51:44 2016 +0000

    Tests for parsing and printing certificates containing SCTs
    
    Reviewed-by: Ben Laurie &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">ben at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 5ad29c54082ae0e00f389b2373c7ca065d3860ad
Author: Adam Eijdenberg &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">eijdenberg at google.com</A>&gt;
Date:   Fri Dec 4 10:49:14 2015 -0800

    Add more CT utility routines to be used as part of larger patch.
    
    Reviewed-by: Ben Laurie &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">ben at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 crypto/ct/Makefile.in                        |   4 +-
 crypto/ct/ct_err.c                           |  19 +-
 crypto/ct/ct_lib.c                           |  72 +++-
 crypto/ct/ct_oct.c                           | 535 +++++++++++++++++++++++++++
 crypto/{asn1/tasn_scn.c =&gt; ct/ct_prn.c}      | 105 +++---
 crypto/include/internal/ct_int.h             | 138 ++++++-
 crypto/x509v3/Makefile.in                    |   4 +-
 crypto/x509v3/build.info                     |   2 +-
 crypto/x509v3/v3_lib.c                       |   1 +
 crypto/x509v3/v3_scts.c                      | 299 ---------------
 test/Makefile.in                             |  10 +-
 test/certs/embeddedSCTs1.pem                 |  20 +
 test/certs/embeddedSCTs1.sct                 |  12 +
 test/certs/embeddedSCTs3.pem                 |  44 +++
 test/certs/embeddedSCTs3.sct                 |  36 ++
 test/ct/tls1.sct                             |  12 +
 test/ct_test.c                               | 404 ++++++++++++++++++++
 test/recipes/{90-test_ige.t =&gt; 80-test_ct.t} |   3 +-
 18 files changed, 1364 insertions(+), 356 deletions(-)
 create mode 100644 crypto/ct/ct_oct.c
 copy crypto/{asn1/tasn_scn.c =&gt; ct/ct_prn.c} (52%)
 delete mode 100644 crypto/x509v3/v3_scts.c
 create mode 100644 test/certs/embeddedSCTs1.pem
 create mode 100644 test/certs/embeddedSCTs1.sct
 create mode 100644 test/certs/embeddedSCTs3.pem
 create mode 100644 test/certs/embeddedSCTs3.sct
 create mode 100644 test/ct/tls1.sct
 create mode 100644 test/ct_test.c
 copy test/recipes/{90-test_ige.t =&gt; 80-test_ct.t} (56%)

diff --git a/crypto/ct/Makefile.in b/crypto/ct/Makefile.in
index 100179d..7e58c3b 100644
--- a/crypto/ct/Makefile.in
+++ b/crypto/ct/Makefile.in
@@ -15,8 +15,8 @@ CFLAGS= $(INCLUDES) $(CFLAG) $(SHARED_CFLAG)
 GENERAL=Makefile
 
 LIB=$(TOP)/libcrypto.a
-LIBSRC= ct_lib.c ct_err.c
-LIBOBJ= ct_lib.o ct_err.o
+LIBSRC= ct_lib.c ct_err.c ct_oct.c ct_prn.c
+LIBOBJ= ct_lib.o ct_err.o ct_oct.o ct_prn.o
 
 SRC= $(LIBSRC)
 
diff --git a/crypto/ct/ct_err.c b/crypto/ct/ct_err.c
index 1657764..b2ba432 100644
--- a/crypto/ct/ct_err.c
+++ b/crypto/ct/ct_err.c
@@ -1,5 +1,6 @@
+/* ct_err.c */
 /* ====================================================================
- * Copyright (c) 1999-2015 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -69,16 +70,32 @@
 # define ERR_REASON(reason) ERR_PACK(ERR_LIB_CT,0,reason)
 
 static ERR_STRING_DATA CT_str_functs[] = {
+    {ERR_FUNC(CT_F_D2I_SCT_LIST), &quot;d2i_SCT_LIST&quot;},
+    {ERR_FUNC(CT_F_I2D_SCT_LIST), &quot;i2d_SCT_LIST&quot;},
+    {ERR_FUNC(CT_F_I2O_SCT), &quot;i2o_SCT&quot;},
+    {ERR_FUNC(CT_F_I2O_SCT_LIST), &quot;i2o_SCT_LIST&quot;},
+    {ERR_FUNC(CT_F_I2O_SCT_SIGNATURE), &quot;i2o_SCT_signature&quot;},
+    {ERR_FUNC(CT_F_O2I_SCT), &quot;o2i_SCT&quot;},
+    {ERR_FUNC(CT_F_O2I_SCT_LIST), &quot;o2i_SCT_LIST&quot;},
+    {ERR_FUNC(CT_F_O2I_SCT_SIGNATURE), &quot;o2i_SCT_signature&quot;},
     {ERR_FUNC(CT_F_SCT_NEW), &quot;SCT_new&quot;},
     {ERR_FUNC(CT_F_SCT_SET0_LOG_ID), &quot;SCT_set0_log_id&quot;},
+    {ERR_FUNC(CT_F_SCT_SET1_EXTENSIONS), &quot;SCT_set1_extensions&quot;},
+    {ERR_FUNC(CT_F_SCT_SET1_LOG_ID), &quot;SCT_set1_log_id&quot;},
+    {ERR_FUNC(CT_F_SCT_SET1_SIGNATURE), &quot;SCT_set1_signature&quot;},
     {ERR_FUNC(CT_F_SCT_SET_LOG_ENTRY_TYPE), &quot;SCT_set_log_entry_type&quot;},
     {ERR_FUNC(CT_F_SCT_SET_SIGNATURE_NID), &quot;SCT_set_signature_nid&quot;},
     {ERR_FUNC(CT_F_SCT_SET_VERSION), &quot;SCT_set_version&quot;},
+    {ERR_FUNC(CT_F_SCT_SIGNATURE_IS_VALID), &quot;SCT_signature_is_valid&quot;},
     {0, NULL}
 };
 
 static ERR_STRING_DATA CT_str_reasons[] = {
     {ERR_REASON(CT_R_INVALID_LOG_ID_LENGTH), &quot;invalid log id length&quot;},
+    {ERR_REASON(CT_R_SCT_INVALID), &quot;sct invalid&quot;},
+    {ERR_REASON(CT_R_SCT_INVALID_SIGNATURE), &quot;sct invalid signature&quot;},
+    {ERR_REASON(CT_R_SCT_LIST_INVALID), &quot;sct list invalid&quot;},
+    {ERR_REASON(CT_R_SCT_NOT_SET), &quot;sct not set&quot;},
     {ERR_REASON(CT_R_UNRECOGNIZED_SIGNATURE_NID),
      &quot;unrecognized signature nid&quot;},
     {ERR_REASON(CT_R_UNSUPPORTED_ENTRY_TYPE), &quot;unsupported entry type&quot;},
diff --git a/crypto/ct/ct_lib.c b/crypto/ct/ct_lib.c
index d1ec85d..81676e3 100644
--- a/crypto/ct/ct_lib.c
+++ b/crypto/ct/ct_lib.c
@@ -77,7 +77,7 @@ SCT *SCT_new(void)
 
 void SCT_free(SCT *sct)
 {
-    if (sct) {
+    if (sct != NULL) {
         OPENSSL_free(sct-&gt;log_id);
         OPENSSL_free(sct-&gt;ext);
         OPENSSL_free(sct-&gt;sig);
@@ -119,6 +119,31 @@ int SCT_set0_log_id(SCT *sct, unsigned char *log_id, size_t log_id_len)
     return 1;
 }
 
+int SCT_set1_log_id(SCT *sct, const unsigned char *log_id, size_t log_id_len)
+{
+    /* Currently only SHA-256 allowed so length must be SCT_V1_HASHLEN */
+    if (log_id_len != SCT_V1_HASHLEN) {
+        CTerr(CT_F_SCT_SET1_LOG_ID, CT_R_INVALID_LOG_ID_LENGTH);
+        return 0;
+    }
+
+    OPENSSL_free(sct-&gt;log_id);
+    if (log_id == NULL || log_id_len == 0) {
+        sct-&gt;log_id = NULL;
+    } else {
+        sct-&gt;log_id = OPENSSL_memdup(log_id, log_id_len);
+
+        if (sct-&gt;log_id == NULL) {
+            CTerr(CT_F_SCT_SET1_LOG_ID, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+    }
+
+    sct-&gt;log_id_len = log_id_len;
+    return 1;
+}
+
+
 void SCT_set_timestamp(SCT *sct, uint64_t timestamp)
 {
     sct-&gt;timestamp = timestamp;
@@ -148,6 +173,23 @@ void SCT_set0_extensions(SCT *sct, unsigned char *ext, size_t ext_len)
     sct-&gt;ext_len = ext_len;
 }
 
+int SCT_set1_extensions(SCT *sct, const unsigned char *ext, size_t ext_len)
+{
+    OPENSSL_free(sct-&gt;ext);
+    sct-&gt;ext = NULL;
+    sct-&gt;ext_len = 0;
+
+    if (ext != NULL &amp;&amp; ext_len &gt; 0) {
+        sct-&gt;ext = OPENSSL_memdup(ext, ext_len);
+        if (sct-&gt;ext == NULL) {
+            CTerr(CT_F_SCT_SET1_EXTENSIONS, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+        sct-&gt;ext_len = ext_len;
+    }
+    return 1;
+}
+
 void SCT_set0_signature(SCT *sct, unsigned char *sig, size_t sig_len)
 {
     OPENSSL_free(sct-&gt;sig);
@@ -155,6 +197,22 @@ void SCT_set0_signature(SCT *sct, unsigned char *sig, size_t sig_len)
     sct-&gt;sig_len = sig_len;
 }
 
+int SCT_set1_signature(SCT *sct, const unsigned char *sig, size_t sig_len)
+{
+    OPENSSL_free(sct-&gt;sig);
+    if (sig == NULL || sig_len == 0) {
+        sct-&gt;sig = NULL;
+    } else {
+        sct-&gt;sig = OPENSSL_memdup(sig, sig_len);
+        if (sct-&gt;sig == NULL) {
+            CTerr(CT_F_SCT_SET1_SIGNATURE, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+    }
+    sct-&gt;sig_len = sig_len;
+    return 1;
+}
+
 sct_version_t SCT_get_version(const SCT *sct)
 {
     return sct-&gt;version;
@@ -205,4 +263,16 @@ size_t SCT_get0_signature(const SCT *sct, unsigned char **sig)
     return sct-&gt;sig_len;
 }
 
+int SCT_is_valid(const SCT *sct)
+{
+    switch (sct-&gt;version) {
+    case UNSET_VERSION:
+        return 0;
+    case SCT_V1:
+        return sct-&gt;log_id != NULL &amp;&amp; SCT_signature_is_valid(sct);
+    default:
+        return sct-&gt;sct != NULL; /* Just need cached encoding */
+    }
+}
+
 #endif
diff --git a/crypto/ct/ct_oct.c b/crypto/ct/ct_oct.c
new file mode 100644
index 0000000..8d075fc
--- /dev/null
+++ b/crypto/ct/ct_oct.c
@@ -0,0 +1,535 @@
+/*
+ * Written by Rob Stradling (<A HREF="../../../mailman/listinfo/openssl-commits.html">rob at comodo.com</A>) and Stephen Henson
+ * (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL project 2014.
+ */
+/* ====================================================================
+ * Copyright (c) 2014 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
+ *
+ * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    <A HREF="../../../mailman/listinfo/openssl-commits.html">licensing at OpenSSL.org.</A>
+ *
+ * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+ *    nor may &quot;OpenSSL&quot; appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+ * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+ *
+ */
+ 
+#ifndef OPENSSL_NO_CT
+
+# include &lt;limits.h&gt;
+# include &quot;internal/cryptlib.h&quot;
+# include &lt;openssl/asn1.h&gt;
+# include &lt;openssl/evp.h&gt;
+# include &lt;openssl/x509.h&gt;
+# include &lt;openssl/x509v3.h&gt;
+# include &quot;crypto/include/internal/ct_int.h&quot;
+
+# define n2s(c,s)        ((s=(((unsigned int)((c)[0]))&lt;&lt; 8)| \
+                             (((unsigned int)((c)[1]))    )),c+=2)
+
+# define s2n(s,c)        ((c[0]=(unsigned char)(((s)&gt;&gt; 8)&amp;0xff), \
+                           c[1]=(unsigned char)(((s)    )&amp;0xff)),c+=2)
+
+# define n2l8(c,l)       (l =((uint64_t)(*((c)++)))&lt;&lt;56, \
+                          l|=((uint64_t)(*((c)++)))&lt;&lt;48, \
+                          l|=((uint64_t)(*((c)++)))&lt;&lt;40, \
+                          l|=((uint64_t)(*((c)++)))&lt;&lt;32, \
+                          l|=((uint64_t)(*((c)++)))&lt;&lt;24, \
+                          l|=((uint64_t)(*((c)++)))&lt;&lt;16, \
+                          l|=((uint64_t)(*((c)++)))&lt;&lt; 8, \
+                          l|=((uint64_t)(*((c)++))))
+
+# define l2n8(l,c)       (*((c)++)=(unsigned char)(((l)&gt;&gt;56)&amp;0xff), \
+                          *((c)++)=(unsigned char)(((l)&gt;&gt;48)&amp;0xff), \
+                          *((c)++)=(unsigned char)(((l)&gt;&gt;40)&amp;0xff), \
+                          *((c)++)=(unsigned char)(((l)&gt;&gt;32)&amp;0xff), \
+                          *((c)++)=(unsigned char)(((l)&gt;&gt;24)&amp;0xff), \
+                          *((c)++)=(unsigned char)(((l)&gt;&gt;16)&amp;0xff), \
+                          *((c)++)=(unsigned char)(((l)&gt;&gt; 8)&amp;0xff), \
+                          *((c)++)=(unsigned char)(((l)    )&amp;0xff))
+
+static STACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a,
+                                   const unsigned char **pp, int len);
+static int i2d_SCT_LIST(STACK_OF(SCT) *a, unsigned char **pp);
+static int i2r_SCT_LIST(X509V3_EXT_METHOD *method, STACK_OF(SCT) *sct_list,
+                        BIO *out, int indent);
+
+static char *i2s_poison(const X509V3_EXT_METHOD *method, void *val)
+{
+    return OPENSSL_strdup(&quot;NULL&quot;);
+}
+
+const X509V3_EXT_METHOD v3_ct_scts[] = {
+    { NID_ct_precert_scts, 0, NULL,
+    0, (X509V3_EXT_FREE)SCT_LIST_free,
+    (X509V3_EXT_D2I)d2i_SCT_LIST, (X509V3_EXT_I2D)i2d_SCT_LIST,
+    0, 0, 0, 0,
+    (X509V3_EXT_I2R)i2r_SCT_LIST, 0,
+    NULL },
+
+    { NID_ct_precert_poison, 0, ASN1_ITEM_ref(ASN1_NULL),
+    0, 0, 0, 0, i2s_poison, 0,
+    0, 0, 0, 0, NULL },
+
+    { NID_ct_cert_scts, 0, NULL,
+    0, (X509V3_EXT_FREE)SCT_LIST_free,
+    (X509V3_EXT_D2I)d2i_SCT_LIST, (X509V3_EXT_I2D)i2d_SCT_LIST,
+    0, 0, 0, 0,
+    (X509V3_EXT_I2R)i2r_SCT_LIST, 0,
+    NULL },
+};
+
+int SCT_signature_is_valid(const SCT *sct)
+{
+    if (SCT_get_signature_nid(sct) == NID_undef ||
+        sct-&gt;sig_len == 0 || sct-&gt;sig == NULL) {
+        return 0;
+    }
+
+    return 1;
+}
+
+
+int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len)
+{
+    size_t siglen;
+    size_t len_remaining = len;
+    const unsigned char *p = *in;
+
+    if (sct-&gt;version != SCT_V1) {
+        CTerr(CT_F_O2I_SCT_SIGNATURE, CT_R_UNSUPPORTED_VERSION);
+        return -1;
+    }
+    /*
+     * digitally-signed struct header: (1 byte) Hash algorithm (1 byte)
+     * Signature algorithm (2 bytes + ?) Signature
+     *
+     * This explicitly rejects empty signatures: they're invalid for
+     * all supported algorithms.
+     */
+    if (len &lt;= 4) {
+        CTerr(CT_F_O2I_SCT_SIGNATURE, CT_R_SCT_INVALID_SIGNATURE);
+        return -1;
+    }
+
+    /* Get hash and signature algorithm */
+    sct-&gt;hash_alg = *p++;
+    sct-&gt;sig_alg = *p++;
+    if (SCT_get_signature_nid(sct) == NID_undef) {
+        CTerr(CT_F_O2I_SCT_SIGNATURE, CT_R_SCT_INVALID_SIGNATURE);
+        return -1;
+    }
+    /* Retrieve signature and check it is consistent with the buffer length */
+    n2s(p, siglen);
+    len_remaining -= (p - *in);
+    if (siglen &gt; len_remaining) {
+        CTerr(CT_F_O2I_SCT_SIGNATURE, CT_R_SCT_INVALID_SIGNATURE);
+        return -1;
+    }
+
+    if (SCT_set1_signature(sct, p, siglen) != 1)
+        return -1;
+    len_remaining -= siglen;
+    *in = p + siglen;
+
+    return len - len_remaining;
+}
+
+SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len)
+{
+    SCT *sct = NULL;
+    const unsigned char *p;
+
+    if (len == 0 || len &gt; MAX_SCT_SIZE) {
+        CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);
+        goto err;
+    }
+
+    if ((sct = SCT_new()) == NULL)
+        goto err;
+
+    p = *in;
+
+    sct-&gt;version = *p;
+    if (sct-&gt;version == SCT_V1) {
+        int sig_len;
+        size_t len2;
+        /*
+         * Fixed-length header: struct { (1 byte) Version sct_version; (32
+         * bytes) log_id id; (8 bytes) uint64 timestamp; (2 bytes + ?)
+         * CtExtensions extensions;
+         */
+        if (len &lt; 43) {
+            CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);
+            goto err;
+        }
+        len -= 43;
+        p++;
+        sct-&gt;log_id = BUF_memdup(p, SCT_V1_HASHLEN);
+        if (sct-&gt;log_id == NULL)
+            goto err;
+        sct-&gt;log_id_len = SCT_V1_HASHLEN;
+        p += SCT_V1_HASHLEN;
+
+        n2l8(p, sct-&gt;timestamp);
+
+        n2s(p, len2);
+        if (len &lt; len2) {
+            CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);
+            goto err;
+        }
+        if (len2 &gt; 0) {
+            sct-&gt;ext = BUF_memdup(p, len2);
+            if (sct-&gt;ext == NULL)
+                goto err;
+        }
+        sct-&gt;ext_len = len2;
+        p += len2;
+        len -= len2;
+
+        sig_len = o2i_SCT_signature(sct, &amp;p, len);
+        if (sig_len &lt;= 0) {
+            CTerr(CT_F_O2I_SCT, CT_R_SCT_INVALID);
+            goto err;
+        }
+        len -= sig_len;
+        *in = p + len;
+    } else {
+        /* If not V1 just cache encoding */
+        sct-&gt;sct = BUF_memdup(p, len);
+        if (sct-&gt;sct == NULL)
+            goto err;
+        sct-&gt;sct_len = len;
+        *in = p + len;
+    }
+
+    if (psct != NULL) {
+        SCT_free(*psct);
+        *psct = sct;
+    }
+
+    return sct;
+err:
+    SCT_free(sct);
+    return NULL;
+}
+
+int i2o_SCT_signature(const SCT *sct, unsigned char **out)
+{
+    size_t len;
+    unsigned char *p = NULL;
+
+    if (!SCT_signature_is_valid(sct)) {
+        CTerr(CT_F_I2O_SCT_SIGNATURE, CT_R_SCT_INVALID_SIGNATURE);
+        goto err;
+    }
+
+    if (sct-&gt;version != SCT_V1) {
+        CTerr(CT_F_I2O_SCT_SIGNATURE, CT_R_UNSUPPORTED_VERSION);
+        goto err;
+    }
+
+    /*
+    * (1 byte) Hash algorithm
+    * (1 byte) Signature algorithm
+    * (2 bytes + ?) Signature
+    */
+    len = 4 + sct-&gt;sig_len;
+
+    if (out != NULL) {
+        if (*out != NULL) {
+            p = *out;
+            *out += len;
+        } else {
+            p = OPENSSL_malloc(len);
+            if (p == NULL) {
+                CTerr(CT_F_I2O_SCT_SIGNATURE, ERR_R_MALLOC_FAILURE);
+                goto err;
+            }
+            *out = p;
+        }
+
+        *p++ = sct-&gt;hash_alg;
+        *p++ = sct-&gt;sig_alg;
+        s2n(sct-&gt;sig_len, p);
+        memcpy(p, sct-&gt;sig, sct-&gt;sig_len);
+    }
+
+    return len;
+err:
+    OPENSSL_free(p);
+    return -1;
+}
+
+int i2o_SCT(const SCT *sct, unsigned char **out)
+{
+    size_t len;
+    unsigned char *p = NULL;
+
+    if (!SCT_is_valid(sct)) {
+        CTerr(CT_F_I2O_SCT, CT_R_SCT_NOT_SET);
+        goto err;
+    }
+    /*
+     * Fixed-length header: struct { (1 byte) Version sct_version; (32 bytes)
+     * log_id id; (8 bytes) uint64 timestamp; (2 bytes + ?) CtExtensions
+     * extensions; (1 byte) Hash algorithm (1 byte) Signature algorithm (2
+     * bytes + ?) Signature
+     */
+    if (sct-&gt;version == SCT_V1)
+        len = 43 + sct-&gt;ext_len + 4 + sct-&gt;sig_len;
+    else
+        len = sct-&gt;sct_len;
+
+    if (out == NULL)
+        return len;
+
+    if (*out != NULL) {
+        p = *out;
+        *out += len;
+    } else {
+        p = OPENSSL_malloc(len);
+        if (p == NULL) {
+            CTerr(CT_F_I2O_SCT, ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+        *out = p;
+    }
+
+    if (sct-&gt;version == SCT_V1) {
+        *p++ = sct-&gt;version;
+        memcpy(p, sct-&gt;log_id, SCT_V1_HASHLEN);
+        p += SCT_V1_HASHLEN;
+        l2n8(sct-&gt;timestamp, p);
+        s2n(sct-&gt;ext_len, p);
+        if (sct-&gt;ext_len &gt; 0) {
+            memcpy(p, sct-&gt;ext, sct-&gt;ext_len);
+            p += sct-&gt;ext_len;
+        }
+        if (i2o_SCT_signature(sct, &amp;p) &lt;= 0)
+            goto err;
+    } else {
+        memcpy(p, sct-&gt;sct, len);
+    }
+
+    return len;
+err:
+    OPENSSL_free(p);
+    return -1;
+}
+
+void SCT_LIST_free(STACK_OF(SCT) *a)
+{
+    sk_SCT_pop_free(a, SCT_free);
+}
+
+STACK_OF(SCT) *o2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,
+                            size_t len)
+{
+    STACK_OF(SCT) *sk = NULL;
+    size_t list_len, sct_len;
+
+    if (len &lt; 2 || len &gt; MAX_SCT_LIST_SIZE) {
+        CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);
+        return NULL;
+    }
+
+    n2s(*pp, list_len);
+    if (list_len != len - 2) {
+        CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);
+        return NULL;
+    }
+
+    if (a == NULL || *a == NULL) {
+        sk = sk_SCT_new_null();
+        if (sk == NULL)
+            return NULL;
+    } else {
+        SCT *sct;
+
+        /* Use the given stack, but empty it first. */
+        sk = *a;
+        while ((sct = sk_SCT_pop(sk)) != NULL)
+            SCT_free(sct);
+    }
+
+    while (list_len &gt; 0) {
+        SCT *sct;
+
+        if (list_len &lt; 2) {
+            CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);
+            goto err;
+        }
+        n2s(*pp, sct_len);
+        list_len -= 2;
+
+        if (sct_len == 0 || sct_len &gt; list_len) {
+            CTerr(CT_F_O2I_SCT_LIST, CT_R_SCT_LIST_INVALID);
+            goto err;
+        }
+        list_len -= sct_len;
+
+        if ((sct = o2i_SCT(NULL, pp, sct_len)) == NULL)
+            goto err;
+        if (!sk_SCT_push(sk, sct)) {
+            SCT_free(sct);
+            goto err;
+        }
+    }
+
+    if (a != NULL &amp;&amp; *a == NULL)
+        *a = sk;
+    return sk;
+
+ err:
+    if (a == NULL || *a == NULL)
+        SCT_LIST_free(sk);
+    return NULL;
+}
+
+int i2o_SCT_LIST(STACK_OF(SCT) *a, unsigned char **pp)
+{
+    int len, sct_len, i, is_pp_new = 0;
+    size_t len2;
+    unsigned char *p = NULL, *p2;
+
+    if (pp != NULL) {
+        if (*pp == NULL) {
+            if ((len = i2o_SCT_LIST(a, NULL)) == -1) {
+                CTerr(CT_F_I2O_SCT_LIST, CT_R_SCT_LIST_INVALID);
+                return -1;
+            }
+            if ((*pp = OPENSSL_malloc(len)) == NULL) {
+                CTerr(CT_F_I2O_SCT_LIST, ERR_R_MALLOC_FAILURE);
+                return -1;
+            }
+            is_pp_new = 1;
+        }
+        p = *pp + 2;
+    }
+
+    len2 = 2;
+    for (i = 0; i &lt; sk_SCT_num(a); i++) {
+        if (pp != NULL) {
+            p2 = p;
+            p += 2;
+            if ((sct_len = i2o_SCT(sk_SCT_value(a, i), &amp;p)) == -1)
+                goto err;
+            s2n(sct_len, p2);
+        } else {
+          if ((sct_len = i2o_SCT(sk_SCT_value(a, i), NULL)) == -1)
+              goto err;
+        }
+        len2 += 2 + sct_len;
+    }
+
+    if (len2 &gt; MAX_SCT_LIST_SIZE)
+        goto err;
+
+    if (pp != NULL) {
+        p = *pp;
+        s2n(len2 - 2, p);
+    }
+    if (!is_pp_new)
+        *pp += len2;
+    return len2;
+
+ err:
+    if (is_pp_new) {
+        OPENSSL_free(*pp);
+        *pp = NULL;
+    }
+    return -1;
+}
+
+static STACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a,
+                                   const unsigned char **pp, int len)
+{
+    ASN1_OCTET_STRING *oct = NULL;
+    STACK_OF(SCT) *sk = NULL;
+    const unsigned char *p;
+
+    p = *pp;
+    if (d2i_ASN1_OCTET_STRING(&amp;oct, &amp;p, len) == NULL)
+        return NULL;
+
+    p = oct-&gt;data;
+    if ((sk = o2i_SCT_LIST(a, &amp;p, oct-&gt;length)) != NULL)
+        *pp += len;
+
+    ASN1_OCTET_STRING_free(oct);
+    return sk;
+}
+
+static int i2d_SCT_LIST(STACK_OF(SCT) *a, unsigned char **out)
+{
+    ASN1_OCTET_STRING oct;
+    int len;
+
+    oct.data = NULL;
+    if ((oct.length = i2o_SCT_LIST(a, &amp;oct.data)) == -1)
+        return -1;
+
+    len = i2d_ASN1_OCTET_STRING(&amp;oct, out);
+    OPENSSL_free(oct.data);
+    return len;
+}
+
+static int i2r_SCT_LIST(X509V3_EXT_METHOD *method, STACK_OF(SCT) *sct_list,
+                        BIO *out, int indent)
+{
+    int i;
+
+    for (i = 0; i &lt; sk_SCT_num(sct_list); ++i) {
+        SCT *sct = sk_SCT_value(sct_list, i);
+        SCT_print(sct, out, indent);
+        if (i &lt; sk_SCT_num(sct_list) - 1)
+            BIO_printf(out, &quot;\n&quot;);
+    }
+
+    return 1;
+}
+
+#endif
diff --git a/crypto/asn1/tasn_scn.c b/crypto/ct/ct_prn.c
similarity index 52%
copy from crypto/asn1/tasn_scn.c
copy to crypto/ct/ct_prn.c
index a775839..9132553 100644
--- a/crypto/asn1/tasn_scn.c
+++ b/crypto/ct/ct_prn.c
@@ -1,9 +1,9 @@
 /*
- * Written by Dr Stephen N Henson (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL project
- * 2010.
+ * Written by Rob Stradling (<A HREF="../../../mailman/listinfo/openssl-commits.html">rob at comodo.com</A>) and Stephen Henson
+ * (<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>) for the OpenSSL project 2014.
  */
 /* ====================================================================
- * Copyright (c) 2010 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 2014 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -56,59 +56,74 @@
  *
  */
 
-#include &lt;stddef.h&gt;
-#include &quot;internal/cryptlib.h&quot;
-#include &lt;openssl/asn1.h&gt;
-#include &lt;openssl/asn1t.h&gt;
-#include &lt;openssl/objects.h&gt;
-#include &lt;openssl/buffer.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &lt;openssl/x509v3.h&gt;
-#include &quot;asn1_locl.h&quot;
+#ifndef OPENSSL_NO_CT
 
-/*
- * General ASN1 structure recursive scanner: iterate through all fields
- * passing details to a callback.
- */
+# include &lt;limits.h&gt;
+# include &quot;internal/cryptlib.h&quot;
+# include &lt;openssl/asn1.h&gt;
+# include &lt;openssl/evp.h&gt;
+# include &lt;openssl/x509.h&gt;
+# include &lt;openssl/x509v3.h&gt;
+# include &quot;crypto/include/internal/ct_int.h&quot;
 
-ASN1_SCTX *ASN1_SCTX_new(int (*scan_cb) (ASN1_SCTX *ctx))
+static void sct_sigalg_print(BIO *out, const SCT *sct)
 {
-    ASN1_SCTX *ret;
-    ret = OPENSSL_malloc(sizeof(*ret));
-    if (ret == NULL) {
-        ASN1err(ASN1_F_ASN1_SCTX_NEW, ERR_R_MALLOC_FAILURE);
-        return NULL;
-    }
-    ret-&gt;scan_cb = scan_cb;
-    return ret;
-}
+    int nid = SCT_get_signature_nid(sct);
 
-void ASN1_SCTX_free(ASN1_SCTX *p)
-{
-    OPENSSL_free(p);
+    if (nid &lt;= 0)
+        BIO_printf(out, &quot;%02X%02X&quot;, sct-&gt;hash_alg, sct-&gt;sig_alg);
+    else
+        BIO_printf(out, &quot;%s&quot;, OBJ_nid2ln(nid));
 }
 
-const ASN1_ITEM *ASN1_SCTX_get_item(ASN1_SCTX *p)
+static void timestamp_print(BIO *out, uint64_t timestamp)
 {
-    return p-&gt;it;
-}
+    ASN1_GENERALIZEDTIME *gen = ASN1_GENERALIZEDTIME_new();
+    char genstr[20];
 
-const ASN1_TEMPLATE *ASN1_SCTX_get_template(ASN1_SCTX *p)
-{
-    return p-&gt;tt;
+    ASN1_GENERALIZEDTIME_adj(gen, (time_t)0,
+                             (int)(timestamp / 86400000),
+                             (timestamp % 86400000) / 1000);
+    /*
+     * Note GeneralizedTime from ASN1_GENERALIZETIME_adj is always 15
+     * characters long with a final Z. Update it with fractional seconds.
+     */
+    BIO_snprintf(genstr, sizeof(genstr), &quot;%.14s.%03dZ&quot;,
+                 ASN1_STRING_data(gen), (unsigned int)(timestamp % 1000));
+    ASN1_GENERALIZEDTIME_set_string(gen, genstr);
+    ASN1_GENERALIZEDTIME_print(out, gen);
+    ASN1_GENERALIZEDTIME_free(gen);
 }
 
-unsigned long ASN1_SCTX_get_flags(ASN1_SCTX *p)
+void SCT_print(SCT *sct, BIO *out, int indent)
 {
-    return p-&gt;flags;
-}
+    BIO_printf(out, &quot;%*sSigned Certificate Timestamp:&quot;, indent, &quot;&quot;);
+    BIO_printf(out, &quot;\n%*sVersion   : &quot;, indent + 4, &quot;&quot;);
 
-void ASN1_SCTX_set_app_data(ASN1_SCTX *p, void *data)
-{
-    p-&gt;app_data = data;
-}
+    if (sct-&gt;version != SCT_V1) {
+        BIO_printf(out, &quot;unknown\n%*s&quot;, indent + 16, &quot;&quot;);
+        BIO_hex_string(out, indent + 16, 16, sct-&gt;sct, sct-&gt;sct_len);
+        return;
+    }
 
-void *ASN1_SCTX_get_app_data(ASN1_SCTX *p)
-{
-    return p-&gt;app_data;
+    BIO_printf(out, &quot;v1 (0x0)&quot;);
+
+    BIO_printf(out, &quot;\n%*sLog ID    : &quot;, indent + 4, &quot;&quot;);
+    BIO_hex_string(out, indent + 16, 16, sct-&gt;log_id, sct-&gt;log_id_len);
+
+    BIO_printf(out, &quot;\n%*sTimestamp : &quot;, indent + 4, &quot;&quot;);
+    timestamp_print(out, sct-&gt;timestamp);
+
+    BIO_printf(out, &quot;\n%*sExtensions: &quot;, indent + 4, &quot;&quot;);
+    if (sct-&gt;ext_len == 0)
+        BIO_printf(out, &quot;none&quot;);
+    else
+        BIO_hex_string(out, indent + 16, 16, sct-&gt;ext, sct-&gt;ext_len);
+
+    BIO_printf(out, &quot;\n%*sSignature : &quot;, indent + 4, &quot;&quot;);
+    sct_sigalg_print(out, sct);
+    BIO_printf(out, &quot;\n%*s            &quot;, indent + 4, &quot;&quot;);
+    BIO_hex_string(out, indent + 16, 16, sct-&gt;sig, sct-&gt;sig_len);
 }
+
+#endif
diff --git a/crypto/include/internal/ct_int.h b/crypto/include/internal/ct_int.h
index 1aa3745..b564dce 100644
--- a/crypto/include/internal/ct_int.h
+++ b/crypto/include/internal/ct_int.h
@@ -60,6 +60,8 @@ extern &quot;C&quot; {
 
 # ifndef OPENSSL_NO_CT
 
+# include &lt;openssl/x509v3.h&gt;
+
 /* All hashes are currently SHA256 */
 #  define SCT_V1_HASHLEN  32
 /* Minimum RSA key size, from RFC6962 */
@@ -105,6 +107,7 @@ typedef struct {
     uint64_t timestamp;
     unsigned char *ext;
     size_t ext_len;
+    /* TODO(robpercival): Extract the following 4 fields into a struct */
     unsigned char hash_alg;
     unsigned char sig_alg;
     unsigned char *sig;
@@ -115,6 +118,8 @@ typedef struct {
 
 DEFINE_STACK_OF(SCT)
 
+extern const X509V3_EXT_METHOD v3_ct_scts[];
+
 /*
  * Allocate new SCT.
  * Caller is responsible for calling SCT_free when done.
@@ -139,13 +144,20 @@ int SCT_set_version(SCT *sct, sct_version_t version);
 int SCT_set_log_entry_type(SCT *sct, log_entry_type_t entry_type);
 
 /*
- * Set the log id of an SCT to point directly to the *log_id specified.
+ * Set the log ID of an SCT to point directly to the *log_id specified.
  * The SCT takes ownership of the specified pointer.
  * Returns 1 on success.
  */
 int SCT_set0_log_id(SCT *sct, unsigned char *log_id, size_t log_id_len);
 
 /*
+ * Set the log ID of an SCT.
+ * This makes a copy of the log_id.
+ * Returns 1 on success.
+ */
+int SCT_set1_log_id(SCT *sct, const unsigned char *log_id, size_t log_id_len);
+
+/*
  * Set the timestamp of an SCT.
  */
 void SCT_set_timestamp(SCT *sct, uint64_t timestamp);
@@ -164,12 +176,25 @@ int SCT_set_signature_nid(SCT *sct, int nid);
 void SCT_set0_extensions(SCT *sct, unsigned char *ext, size_t ext_len);
 
 /*
+ * Set the extensions of an SCT.
+ * This takes a copy of the ext.
+ * Returns 1 on success.
+ */
+int SCT_set1_extensions(SCT *sct, const unsigned char *ext, size_t ext_len);
+
+/*
  * Set the signature of an SCT to point directly to the *sig specified.
  * The SCT takes ownership of the specified pointer.
  */
 void SCT_set0_signature(SCT *sct, unsigned char *sig, size_t sig_len);
 
 /*
+ * Set the signature of an SCT to be a copy of the *sig specified.
+ * Returns 1 on success.
+ */
+int SCT_set1_signature(SCT *sct, const unsigned char *sig, size_t sig_len);
+
+/*
  * Returns the version of the SCT.
  */
 sct_version_t SCT_get_version(const SCT *sct);
@@ -212,6 +237,101 @@ size_t SCT_get0_extensions(const SCT *sct, unsigned char **ext);
  */
 size_t SCT_get0_signature(const SCT *sct, unsigned char **sig);
 
+/*
+ * Pretty-print debug information about a SCT, indented as specified.
+ */
+void SCT_print(SCT *sct, BIO *out, int indent);
+
+/*
+ * Does this SCT have the minimum fields populated to be valid?
+ * Returns 1 if so, 0 otherwise.
+ * This does not verify the SCT signature.
+ */
+int SCT_is_valid(const SCT *sct);
+
+/*
+ * Is the signature of this SCT valid?
+ * Returns 1 if so, 0 otherwise.
+ * This checks that the signature and hash algorithms are supported and that the
+ * signature field is set.
+ */
+int SCT_signature_is_valid(const SCT *sct);
+
+/*
+ * Free a stack of SCTs, and the underlying SCTs themselves.
+ * Intended to be compatible with X509V3_EXT_FREE.
+ */
+void SCT_LIST_free(STACK_OF(SCT) *a);
+
+/*
+ * Serialize (to TLS format) a stack of SCTs and return the length.
+ * &quot;a&quot; must not be NULL.
+ * If &quot;pp&quot; is NULL, just return the length of what would have been serialized.
+ * If &quot;pp&quot; is not NULL and &quot;*pp&quot; is null, function will allocate a new pointer
+ * for data that caller is responsible for freeing (only if function returns
+ * successfully).
+ * If &quot;pp&quot; is NULL and &quot;*pp&quot; is not NULL, caller is responsible for ensuring
+ * that &quot;*pp&quot; is large enough to accept all of the serializied data.
+ * Returns &lt; 0 on error, &gt;= 0 indicating bytes written (or would have been)
+ * on success.
+ */
+int i2o_SCT_LIST(STACK_OF(SCT) *a, unsigned char **pp);
+
+/*
+* Parses an SCT signature in TLS format and populates the |sct| with it.
+* |in| should be a pointer to a string contianing the TLS-format signature.
+* |in| will be advanced to the end of the signature if parsing succeeds.
+* |len| should be the length of the signature in |in|.
+* Returns the number of bytes parsed, or a negative integer if an error occurs.
+*/
+int o2i_SCT_signature(SCT *sct, const unsigned char **in, size_t len);
+
+/*
+ * Parses an SCT in TLS format and returns it.
+ * If |psct| is not null, it will end up pointing to the parsed SCT. If it
+ * already points to a non-null pointer, the pointer will be free'd.
+ * |in| should be a pointer to a string contianing the TLS-format SCT.
+ * |in| will be advanced to the end of the SCT if parsing succeeds.
+ * |len| should be the length of the SCT in |in|.
+ * Returns NULL if an error occurs.
+ * If the SCT is an unsupported version, only the SCT's 'sct' and 'sct_len'
+ * fields will be populated (with |in| and |len| respectively).
+ */
+SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len);
+
+/*
+* Converts an |sct| signature into TLS format and writes it to |out|.
+* If |out| is null, no signature will be output but the length will be returned.
+* If |out| points to a null pointer, a string will be allocated to hold the
+* TLS-format signature. It is the responsibility of the caller to free it.
+* If |out| points to an allocated string, the signature will be written to it.
+* The length of the signature in TLS format will be returned.
+*/
+int i2o_SCT_signature(const SCT *sct, unsigned char **out);
+
+/*
+ * Converts an |sct| into TLS format and writes it to |out|.
+ * If |out| is null, no SCT will be output but the length will still be returned.
+ * If |out| points to a null pointer, a string will be allocated to hold the
+ * TLS-format SCT. It is the responsibility of the caller to free it.
+ * If |out| points to an allocated string, the TLS-format SCT will be written
+ * to it.
+ * The length of the SCT in TLS format will be returned.
+ */
+int i2o_SCT(const SCT *sct, unsigned char **out);
+
+/*
+ * Convert TLS format SCT list to a stack of SCTs.
+ * If &quot;a&quot; or &quot;*a&quot; is NULL, a new stack will be created that the caller is
+ * responsible for freeing (by calling SCT_LIST_free).
+ * &quot;**pp&quot; and &quot;*pp&quot; must not be NULL.
+ * Upon success, &quot;*pp&quot; will point to after the last bytes read, and a stack
+ * will be returned.
+ * Upon failure, a NULL pointer will be returned, and the position of &quot;*p&quot; is
+ * not defined.
+ */
+STACK_OF(SCT) *o2i_SCT_LIST(STACK_OF(SCT) **a, const unsigned char **pp,
+                            size_t len);
 
 # endif
 
@@ -225,14 +345,30 @@ void ERR_load_CT_strings(void);
 /* Error codes for the CT functions. */
 
 /* Function codes. */
+# define CT_F_D2I_SCT_LIST                                105
+# define CT_F_I2D_SCT_LIST                                106
+# define CT_F_I2O_SCT                                     107
+# define CT_F_I2O_SCT_LIST                                108
+# define CT_F_I2O_SCT_SIGNATURE                           109
+# define CT_F_O2I_SCT                                     110
+# define CT_F_O2I_SCT_LIST                                111
+# define CT_F_O2I_SCT_SIGNATURE                           112
 # define CT_F_SCT_NEW                                     100
 # define CT_F_SCT_SET0_LOG_ID                             101
+# define CT_F_SCT_SET1_EXTENSIONS                         114
+# define CT_F_SCT_SET1_LOG_ID                             115
+# define CT_F_SCT_SET1_SIGNATURE                          116
 # define CT_F_SCT_SET_LOG_ENTRY_TYPE                      102
 # define CT_F_SCT_SET_SIGNATURE_NID                       103
 # define CT_F_SCT_SET_VERSION                             104
+# define CT_F_SCT_SIGNATURE_IS_VALID                      113
 
 /* Reason codes. */
 # define CT_R_INVALID_LOG_ID_LENGTH                       100
+# define CT_R_SCT_INVALID                                 104
+# define CT_R_SCT_INVALID_SIGNATURE                       107
+# define CT_R_SCT_LIST_INVALID                            105
+# define CT_R_SCT_NOT_SET                                 106
 # define CT_R_UNRECOGNIZED_SIGNATURE_NID                  101
 # define CT_R_UNSUPPORTED_ENTRY_TYPE                      102
 # define CT_R_UNSUPPORTED_VERSION                         103
diff --git a/crypto/x509v3/Makefile.in b/crypto/x509v3/Makefile.in
index 243d5c5..b6af01e 100644
--- a/crypto/x509v3/Makefile.in
+++ b/crypto/x509v3/Makefile.in
@@ -20,13 +20,13 @@ v3_prn.c v3_utl.c v3err.c v3_genn.c v3_alt.c v3_skey.c v3_akey.c v3_pku.c \
 v3_int.c v3_enum.c v3_sxnet.c v3_cpols.c v3_crld.c v3_purp.c v3_info.c \
 v3_akeya.c v3_pmaps.c v3_pcons.c v3_ncons.c v3_pcia.c v3_pci.c \
 pcy_cache.c pcy_node.c pcy_data.c pcy_map.c pcy_tree.c pcy_lib.c \
-v3_asid.c v3_addr.c v3_scts.c v3_tlsf.c
+v3_asid.c v3_addr.c v3_tlsf.c
 LIBOBJ= v3_bcons.o v3_bitst.o v3_conf.o v3_extku.o v3_ia5.o v3_lib.o \
 v3_prn.o v3_utl.o v3err.o v3_genn.o v3_alt.o v3_skey.o v3_akey.o v3_pku.o \
 v3_int.o v3_enum.o v3_sxnet.o v3_cpols.o v3_crld.o v3_purp.o v3_info.o \
 v3_akeya.o v3_pmaps.o v3_pcons.o v3_ncons.o v3_pcia.o v3_pci.o \
 pcy_cache.o pcy_node.o pcy_data.o pcy_map.o pcy_tree.o pcy_lib.o \
-v3_asid.o v3_addr.o v3_scts.o v3_tlsf.o
+v3_asid.o v3_addr.o v3_tlsf.o
 
 SRC= $(LIBSRC)
 
diff --git a/crypto/x509v3/build.info b/crypto/x509v3/build.info
index 7214a38..452a8b0 100644
--- a/crypto/x509v3/build.info
+++ b/crypto/x509v3/build.info
@@ -5,4 +5,4 @@ SOURCE[../../libcrypto]=\
   v3_int.c v3_enum.c v3_sxnet.c v3_cpols.c v3_crld.c v3_purp.c v3_info.c \
   v3_akeya.c v3_pmaps.c v3_pcons.c v3_ncons.c v3_pcia.c v3_pci.c \
   pcy_cache.c pcy_node.c pcy_data.c pcy_map.c pcy_tree.c pcy_lib.c \
-  v3_asid.c v3_addr.c v3_scts.c v3_tlsf.c
+  v3_asid.c v3_addr.c v3_tlsf.c
diff --git a/crypto/x509v3/v3_lib.c b/crypto/x509v3/v3_lib.c
index 0db199c..a82050f 100644
--- a/crypto/x509v3/v3_lib.c
+++ b/crypto/x509v3/v3_lib.c
@@ -154,6 +154,7 @@ static const X509V3_EXT_METHOD *standard_exts[] = {
 #ifndef OPENSSL_NO_CT
     &amp;v3_ct_scts[0],
     &amp;v3_ct_scts[1],
+    &amp;v3_ct_scts[2],
 #endif
     &amp;v3_tls_feature,
 };
diff --git a/crypto/x509v3/v3_scts.c b/crypto/x509v3/v3_scts.c
deleted file mode 100644
index 9c6c320..0000000
--- a/crypto/x509v3/v3_scts.c
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- * Written by Rob Stradling (<A HREF="../../../mailman/listinfo/openssl-commits.html">rob at comodo.com</A>) for the OpenSSL project 2014.
- */
-/* ====================================================================
- * Copyright (c) 2014 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">licensing at OpenSSL.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-#include &lt;stdio.h&gt;
-#include &quot;internal/cryptlib.h&quot;
-#include &lt;openssl/asn1.h&gt;
-#include &lt;openssl/x509v3.h&gt;
-#include &quot;ext_dat.h&quot;
-#include &quot;internal/ct_int.h&quot;
-
-#ifndef OPENSSL_NO_CT
-/* Signature and hash algorithms from RFC 5246 */
-#define TLSEXT_hash_sha256                              4
-
-#define TLSEXT_signature_rsa                            1
-#define TLSEXT_signature_ecdsa                          3
-
-
-#define n2s(c,s)        ((s=(((unsigned int)(c[0]))&lt;&lt; 8)| \
-                            (((unsigned int)(c[1]))    )),c+=2)
-
-#define n2l8(c,l)       (l =((uint64_t)(*((c)++)))&lt;&lt;56, \
-                         l|=((uint64_t)(*((c)++)))&lt;&lt;48, \
-                         l|=((uint64_t)(*((c)++)))&lt;&lt;40, \
-                         l|=((uint64_t)(*((c)++)))&lt;&lt;32, \
-                         l|=((uint64_t)(*((c)++)))&lt;&lt;24, \
-                         l|=((uint64_t)(*((c)++)))&lt;&lt;16, \
-                         l|=((uint64_t)(*((c)++)))&lt;&lt; 8, \
-                         l|=((uint64_t)(*((c)++))))
-
-
-static void SCT_LIST_free(STACK_OF(SCT) *a);
-static STACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a,
-                                   const unsigned char **pp, long length);
-static int i2r_SCT_LIST(X509V3_EXT_METHOD *method, STACK_OF(SCT) *sct_list,
-                        BIO *out, int indent);
-
-const X509V3_EXT_METHOD v3_ct_scts[] = {
-    {NID_ct_precert_scts, 0, NULL,
-     0, (X509V3_EXT_FREE)SCT_LIST_free,
-     (X509V3_EXT_D2I)d2i_SCT_LIST, 0,
-     0, 0, 0, 0,
-     (X509V3_EXT_I2R)i2r_SCT_LIST, 0,
-     NULL},
-
-    {NID_ct_cert_scts, 0, NULL,
-     0, (X509V3_EXT_FREE)SCT_LIST_free,
-     (X509V3_EXT_D2I)d2i_SCT_LIST, 0,
-     0, 0, 0, 0,
-     (X509V3_EXT_I2R)i2r_SCT_LIST, 0,
-     NULL},
-};
-
-static void tls12_signature_print(BIO *out, const unsigned char hash_alg,
-                                  const unsigned char sig_alg)
-{
-    int nid = NID_undef;
-    /* RFC6962 only permits two signature algorithms */
-    if (hash_alg == TLSEXT_hash_sha256) {
-        if (sig_alg == TLSEXT_signature_rsa)
-            nid = NID_sha256WithRSAEncryption;
-        else if (sig_alg == TLSEXT_signature_ecdsa)
-            nid = NID_ecdsa_with_SHA256;
-    }
-    if (nid == NID_undef)
-        BIO_printf(out, &quot;%02X%02X&quot;, hash_alg, sig_alg);
-    else
-        BIO_printf(out, &quot;%s&quot;, OBJ_nid2ln(nid));
-}
-
-static void timestamp_print(BIO *out, uint64_t timestamp)
-{
-    ASN1_GENERALIZEDTIME *gen;
-    char genstr[20];
-    gen = ASN1_GENERALIZEDTIME_new();
-    ASN1_GENERALIZEDTIME_adj(gen, (time_t)0,
-                             (int)(timestamp / 86400000),
-                             (timestamp % 86400000) / 1000);
-    /*
-     * Note GeneralizedTime from ASN1_GENERALIZETIME_adj is always 15
-     * characters long with a final Z. Update it with fractional seconds.
-     */
-    BIO_snprintf(genstr, sizeof(genstr), &quot;%.14s.%03dZ&quot;,
-                 ASN1_STRING_data(gen), (unsigned int)(timestamp % 1000));
-    ASN1_GENERALIZEDTIME_set_string(gen, genstr);
-    ASN1_GENERALIZEDTIME_print(out, gen);
-    ASN1_GENERALIZEDTIME_free(gen);
-}
-
-static void SCT_LIST_free(STACK_OF(SCT) *a)
-{
-    sk_SCT_pop_free(a, SCT_free);
-}
-
-static STACK_OF(SCT) *d2i_SCT_LIST(STACK_OF(SCT) **a,
-                                   const unsigned char **pp, long length)
-{
-    ASN1_OCTET_STRING *oct = NULL;
-    STACK_OF(SCT) *sk = NULL;
-    SCT *sct;
-    unsigned char *p, *p2;
-    unsigned short listlen, sctlen = 0, fieldlen;
-    const unsigned char *q = *pp;
-
-    if (d2i_ASN1_OCTET_STRING(&amp;oct, &amp;q, length) == NULL)
-        return NULL;
-    if (oct-&gt;length &lt; 2)
-        goto done;
-    p = oct-&gt;data;
-    n2s(p, listlen);
-    if (listlen != oct-&gt;length - 2)
-        goto done;
-
-    if ((sk = sk_SCT_new_null()) == NULL)
-        goto done;
-
-    while (listlen &gt; 0) {
-        if (listlen &lt; 2)
-            goto err;
-        n2s(p, sctlen);
-        listlen -= 2;
-
-        if ((sctlen &lt; 1) || (sctlen &gt; listlen))
-            goto err;
-        listlen -= sctlen;
-
-        sct = OPENSSL_malloc(sizeof(*sct));
-        if (sct == NULL)
-            goto err;
-        if (!sk_SCT_push(sk, sct)) {
-            OPENSSL_free(sct);
-            goto err;
-        }
-
-        sct-&gt;sct = OPENSSL_malloc(sctlen);
-        if (sct-&gt;sct == NULL)
-            goto err;
-        memcpy(sct-&gt;sct, p, sctlen);
-        sct-&gt;sct_len = sctlen;
-        p += sctlen;
-        p2 = sct-&gt;sct;
-
-        sct-&gt;version = *p2++;
-        if (sct-&gt;version == 0) { /* SCT v1 */
-            /*-
-             * Fixed-length header:
-             *              struct {
-             * (1 byte)       Version sct_version;
-             * (32 bytes)     LogID id;
-             * (8 bytes)      uint64 timestamp;
-             * (2 bytes + ?)  CtExtensions extensions;
-             */
-            if (sctlen &lt; 43)
-                goto err;
-            sctlen -= 43;
-
-            sct-&gt;log_id = p2;
-            sct-&gt;log_id_len = 32;
-            p2 += 32;
-
-            n2l8(p2, sct-&gt;timestamp);
-
-            n2s(p2, fieldlen);
-            if (sctlen &lt; fieldlen)
-                goto err;
-            sct-&gt;ext = p2;
-            sct-&gt;ext_len = fieldlen;
-            p2 += fieldlen;
-            sctlen -= fieldlen;
-
-            /*-
-             * digitally-signed struct header:
-             * (1 byte)       Hash algorithm
-             * (1 byte)       Signature algorithm
-             * (2 bytes + ?)  Signature
-             */
-            if (sctlen &lt; 4)
-                goto err;
-            sctlen -= 4;
-
-            sct-&gt;hash_alg = *p2++;
-            sct-&gt;sig_alg = *p2++;
-            n2s(p2, fieldlen);
-            if (sctlen != fieldlen)
-                goto err;
-            sct-&gt;sig = p2;
-            sct-&gt;sig_len = fieldlen;
-        }
-    }
-
- done:
-    ASN1_OCTET_STRING_free(oct);
-    *pp = q;
-    return sk;
-
- err:
-    SCT_LIST_free(sk);
-    sk = NULL;
-    goto done;
-}
-
-static int i2r_SCT_LIST(X509V3_EXT_METHOD *method, STACK_OF(SCT) *sct_list,
-                        BIO *out, int indent)
-{
-    SCT *sct;
-    int i;
-
-    for (i = 0; i &lt; sk_SCT_num(sct_list);) {
-        sct = sk_SCT_value(sct_list, i);
-
-        BIO_printf(out, &quot;%*sSigned Certificate Timestamp:&quot;, indent, &quot;&quot;);
-        BIO_printf(out, &quot;\n%*sVersion   : &quot;, indent + 4, &quot;&quot;);
-
-        if (sct-&gt;version == 0) { /* SCT v1 */
-            BIO_printf(out, &quot;v1(0)&quot;);
-
-            BIO_printf(out, &quot;\n%*sLog ID    : &quot;, indent + 4, &quot;&quot;);
-            BIO_hex_string(out, indent + 16, 16, sct-&gt;log_id, sct-&gt;log_id_len);
-
-            BIO_printf(out, &quot;\n%*sTimestamp : &quot;, indent + 4, &quot;&quot;);
-            timestamp_print(out, sct-&gt;timestamp);
-
-            BIO_printf(out, &quot;\n%*sExtensions: &quot;, indent + 4, &quot;&quot;);
-            if (sct-&gt;ext_len == 0)
-                BIO_printf(out, &quot;none&quot;);
-            else
-                BIO_hex_string(out, indent + 16, 16, sct-&gt;ext, sct-&gt;ext_len);
-
-            BIO_printf(out, &quot;\n%*sSignature : &quot;, indent + 4, &quot;&quot;);
-            tls12_signature_print(out, sct-&gt;hash_alg, sct-&gt;sig_alg);
-            BIO_printf(out, &quot;\n%*s            &quot;, indent + 4, &quot;&quot;);
-            BIO_hex_string(out, indent + 16, 16, sct-&gt;sig, sct-&gt;sig_len);
-        } else {                /* Unknown version */
-
-            BIO_printf(out, &quot;unknown\n%*s&quot;, indent + 16, &quot;&quot;);
-            BIO_hex_string(out, indent + 16, 16, sct-&gt;sct, sct-&gt;sct_len);
-        }
-
-        if (++i &lt; sk_SCT_num(sct_list))
-            BIO_printf(out, &quot;\n&quot;);
-    }
-
-    return 1;
-}
-#endif
diff --git a/test/Makefile.in b/test/Makefile.in
index 767948c..0b6938c 100644
--- a/test/Makefile.in
+++ b/test/Makefile.in
@@ -81,6 +81,7 @@ SSLSESSIONTICKTEST= 	sslsessionticktest
 SSLSKEWITH0PTEST=	sslskewith0ptest
 ASYNCTEST=	asynctest
 DTLSV1LISTENTEST = dtlsv1listentest
+CTTEST=	ct_test
 
 TESTS=		alltests
 
@@ -102,7 +103,7 @@ EXE=	$(NPTEST)$(EXE_EXT) $(MEMLEAKTEST)$(EXE_EXT) \
 	$(HEARTBEATTEST)$(EXE_EXT) $(P5_CRPT2_TEST)$(EXE_EXT) \
 	$(CONSTTIMETEST)$(EXE_EXT) $(VERIFYEXTRATEST)$(EXE_EXT) \
 	$(CLIENTHELLOTEST)$(EXE_EXT) $(PACKETTEST)$(EXE_EXT) $(ASYNCTEST)$(EXE_EXT) \
-	$(DTLSV1LISTENTEST)$(EXE_EXT)
+	$(DTLSV1LISTENTEST)$(EXE_EXT) $(CTTEST)$(EXE_EXT)
 
 # $(METHTEST)$(EXE_EXT)
 
@@ -119,7 +120,7 @@ OBJ=	$(NPTEST).o $(MEMLEAKTEST).o \
 	$(EVPTEST).o $(EVPEXTRATEST).o $(IGETEST).o $(V3NAMETEST).o \
 	$(HEARTBEATTEST).o $(P5_CRPT2_TEST).o \
 	$(CONSTTIMETEST).o $(VERIFYEXTRATEST).o $(CLIENTHELLOTEST).o \
-	$(PACKETTEST).o $(ASYNCTEST).o $(DTLSV1LISTENTEST).o testutil.o
+	$(PACKETTEST).o $(ASYNCTEST).o $(DTLSV1LISTENTEST).o $(CTTEST).o testutil.o
 
 SRC=	$(NPTEST).c $(MEMLEAKTEST).c \
 	$(BNTEST).c $(ECTEST).c \
@@ -133,7 +134,7 @@ SRC=	$(NPTEST).c $(MEMLEAKTEST).c \
 	$(EVPTEST).c $(EVPEXTRATEST).c $(IGETEST).c $(V3NAMETEST).c \
 	$(HEARTBEATTEST).c $(P5_CRPT2_TEST).c \
 	$(CONSTTIMETEST).c $(VERIFYEXTRATEST).c $(CLIENTHELLOTEST).c \
-	$(PACKETTEST).c $(ASYNCTEST).c $(DTLSV1LISTENTEST).c testutil.c
+	$(PACKETTEST).c $(ASYNCTEST).c $(DTLSV1LISTENTEST).c $(CTTEST).c testutil.c
 
 HEADER=	testutil.h
 
@@ -369,6 +370,9 @@ $(ASYNCTEST)$(EXE_EXT): $(ASYNCTEST).o
 $(DTLSV1LISTENTEST)$(EXE_EXT): $(DTLSV1LISTENTEST).o
 	@target=$(DTLSV1LISTENTEST) $(BUILD_CMD)
 
+$(CTTEST)$(EXE_EXT): $(CTTEST).o testutil.o
+	@target=$(CTTEST) testutil=testutil.o;  $(BUILD_CMD)
+
 dummytest$(EXE_EXT): dummytest.o $(DLIBCRYPTO)
 	@target=dummytest; $(BUILD_CMD)
 
diff --git a/test/certs/embeddedSCTs1.pem b/test/certs/embeddedSCTs1.pem
new file mode 100644
index 0000000..d1e8512
--- /dev/null
+++ b/test/certs/embeddedSCTs1.pem
@@ -0,0 +1,20 @@
+-----BEGIN CERTIFICATE-----
+MIIDWTCCAsKgAwIBAgIBBzANBgkqhkiG9w0BAQUFADBVMQswCQYDVQQGEwJHQjEk
+MCIGA1UEChMbQ2VydGlmaWNhdGUgVHJhbnNwYXJlbmN5IENBMQ4wDAYDVQQIEwVX
+YWxlczEQMA4GA1UEBxMHRXJ3IFdlbjAeFw0xMjA2MDEwMDAwMDBaFw0yMjA2MDEw
+MDAwMDBaMFIxCzAJBgNVBAYTAkdCMSEwHwYDVQQKExhDZXJ0aWZpY2F0ZSBUcmFu
+c3BhcmVuY3kxDjAMBgNVBAgTBVdhbGVzMRAwDgYDVQQHEwdFcncgV2VuMIGfMA0G
+CSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+75jnwmh3rjhfdTJaDB0ym+3xj6r015a/
+BH634c4VyVui+A7kWL19uG+KSyUhkaeb1wDDjpwDibRc1NyaEgqyHgy0HNDnKAWk
+EM2cW9tdSSdyba8XEPYBhzd+olsaHjnu0LiBGdwVTcaPfajjDK8VijPmyVCfSgWw
+FAn/Xdh+tQIDAQABo4IBOjCCATYwHQYDVR0OBBYEFCAxVBryXAX/2GWLaEN5T16Q
+Nve0MH0GA1UdIwR2MHSAFF+diA3Ic+ZU1PgN2OawwSS0R8NVoVmkVzBVMQswCQYD
+VQQGEwJHQjEkMCIGA1UEChMbQ2VydGlmaWNhdGUgVHJhbnNwYXJlbmN5IENBMQ4w
+DAYDVQQIEwVXYWxlczEQMA4GA1UEBxMHRXJ3IFdlboIBADAJBgNVHRMEAjAAMIGK
+BgorBgEEAdZ5AgQCBHwEegB4AHYA3xwuwRUAlFJHqWFoMl3cXHlZ6PfG04j8AC4L
+vT9012QAAAE92yffkwAABAMARzBFAiBIL2dRrzXbplQ2vh/WZA89v5pBQpSVkkUw
+KI+j5eI+BgIhAOTtwNs6xXKx4vXoq2poBlOYfc9BAn3+/6EFUZ2J7b8IMA0GCSqG
+SIb3DQEBBQUAA4GBAIoMS+8JnUeSea+goo5on5HhxEIb4tJpoupspOghXd7dyhUE
+oR58h8S3foDw6XkDUmjyfKIOFmgErlVvMWmB+Wo5Srer/T4lWsAERRP+dlcMZ5Wr
+5HAxM9MD+J86+mu8/FFzGd/ZW5NCQSEfY0A1w9B4MHpoxgdaLiDInza4kQyg
+-----END CERTIFICATE-----
diff --git a/test/certs/embeddedSCTs1.sct b/test/certs/embeddedSCTs1.sct
new file mode 100644
index 0000000..59362dc
--- /dev/null
+++ b/test/certs/embeddedSCTs1.sct
@@ -0,0 +1,12 @@
+Signed Certificate Timestamp:
+    Version   : v1 (0x0)
+    Log ID    : DF:1C:2E:C1:15:00:94:52:47:A9:61:68:32:5D:DC:5C:
+                79:59:E8:F7:C6:D3:88:FC:00:2E:0B:BD:3F:74:D7:64
+    Timestamp : Apr  5 17:04:16.275 2013 GMT
+    Extensions: none
+    Signature : ecdsa-with-SHA256
+                30:45:02:20:48:2F:67:51:AF:35:DB:A6:54:36:BE:1F:
+                D6:64:0F:3D:BF:9A:41:42:94:95:92:45:30:28:8F:A3:
+                E5:E2:3E:06:02:21:00:E4:ED:C0:DB:3A:C5:72:B1:E2:
+                F5:E8:AB:6A:68:06:53:98:7D:CF:41:02:7D:FE:FF:A1:
+                05:51:9D:89:ED:BF:08
\ No newline at end of file
diff --git a/test/certs/embeddedSCTs3.pem b/test/certs/embeddedSCTs3.pem
new file mode 100644
index 0000000..bce8918
--- /dev/null
+++ b/test/certs/embeddedSCTs3.pem
@@ -0,0 +1,44 @@
+-----BEGIN CERTIFICATE-----
+MIIHvzCCBqegAwIBAgIRANSYNM/GMmLagfa+3OOk63swDQYJKoZIhvcNAQELBQAw
+gZIxCzAJBgNVBAYTAkdCMRswGQYDVQQIExJHcmVhdGVyIE1hbmNoZXN0ZXIxEDAO
+BgNVBAcTB1NhbGZvcmQxGjAYBgNVBAoTEUNPTU9ETyBDQSBMaW1pdGVkMTgwNgYD
+VQQDEy9DT01PRE8gUlNBIEV4dGVuZGVkIFZhbGlkYXRpb24gU2VjdXJlIFNlcnZl
+ciBDQTAeFw0xNTEyMDEwMDAwMDBaFw0xODAyMjUyMzU5NTlaMIIBMzEQMA4GA1UE
+BRMHMzgzMDEzODETMBEGCysGAQQBgjc8AgEDEwJVUzEZMBcGCysGAQQBgjc8AgEC
+EwhEZWxhd2FyZTEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xCzAJBgNV
+BAYTAlVTMQ4wDAYDVQQREwUwNzAxMzELMAkGA1UECBMCTkoxEDAOBgNVBAcTB0Ns
+aWZ0b24xEjAQBgNVBAkTCVN1aXRlIDEwMDEXMBUGA1UECRMOMTI1NSBCcm9hZCBT
+dC4xGjAYBgNVBAoTEUNvbW9kbyBHcm91cCBJbmMuMRYwFAYDVQQLEw1DT01PRE8g
+RVYgU1NMMRowGAYDVQQLExFDT01PRE8gRVYgU0dDIFNTTDEXMBUGA1UEAxMOd3d3
+LmNvbW9kby5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC5S2RD
+XGjch2spb10rLVCA4TgeB/TiNLHPczeKMJzIY9qKUGQfcYCTwfWe2E1xBer/i0OX
+IUca+/Br3HTK2qkNoc/nuFkJJ3ej17A9Kv1EYhsN+2gHobKEy+sMTJyGmFVo98nu
+V9mmiEWM7Bi0Y6YRVYCOey4K2yUwSK1MOgc10RzbwDsk+P2mvTzvPi8QZzd4I36/
+xlFFhk39VKY94PorJCzF/6qifmNnIjxMkrmSKJKKQaZu8vgbshqlj3+TkeCtIjdR
+77OcZuROMFdnKsp8JKAq9bzXmDkwlDmUzxAzgYmAvqCwQvNWtJrm0SeiEkNsoK5F
+xadrfw6OO7BCGXiNAgMBAAGjggNqMIIDZjAfBgNVHSMEGDAWgBQ52v/KKBSKqHQT
+CLnkDqnS+n6daTAdBgNVHQ4EFgQURD5zMOsLG6ennQ/aeZZNGofpnSEwDgYDVR0P
+AQH/BAQDAgWgMAwGA1UdEwEB/wQCMAAwNAYDVR0lBC0wKwYIKwYBBQUHAwEGCCsG
+AQUFBwMCBgorBgEEAYI3CgMDBglghkgBhvhCBAEwRgYDVR0gBD8wPTA7BgwrBgEE
+AbIxAQIBBQEwKzApBggrBgEFBQcCARYdaHR0cHM6Ly9zZWN1cmUuY29tb2RvLmNv
+bS9DUFMwVgYDVR0fBE8wTTBLoEmgR4ZFaHR0cDovL2NybC5jb21vZG9jYS5jb20v
+Q09NT0RPUlNBRXh0ZW5kZWRWYWxpZGF0aW9uU2VjdXJlU2VydmVyQ0EuY3JsMIGH
+BggrBgEFBQcBAQR7MHkwUQYIKwYBBQUHMAKGRWh0dHA6Ly9jcnQuY29tb2RvY2Eu
+Y29tL0NPTU9ET1JTQUV4dGVuZGVkVmFsaWRhdGlvblNlY3VyZVNlcnZlckNBLmNy
+dDAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuY29tb2RvY2EuY29tMCUGA1UdEQQe
+MByCDnd3dy5jb21vZG8uY29tggpjb21vZG8uY29tMIIBfQYKKwYBBAHWeQIEAgSC
+AW0EggFpAWcAdQBo9pj4H2SCvjqM7rkoHUz8cVFdZ5PURNEKZ6y7T0/7xAAAAVFd
+vZuJAAAEAwBGMEQCIFgtCr54QYrnialeZiHFahZ53zOFitPzHXGvdTD7zE5FAiBB
+nIm4gBmHRmwcOpULvvSYddTKSZf9JS7jeLU2MCAmTQB2AFYUBpov18Ls0/XhvUSy
+PsdGdrm8mRFcwO+UmFXWidDdAAABUV29mSgAAAQDAEcwRQIgeWjpcDhaY/OmsZcO
+ftDFcRt2BssJY0ge4SDzp+8qTnQCIQCOt7vthV2FG1RePMXs8hOcCdEKAcJZX3wx
+GaGd4RfHHwB2AKS5CZC0GFgUh7sTosxncAo8NZgE+RvfuON3zQ7IDdwQAAABUV29
+m5wAAAQDAEcwRQIgKwZCD9lxvSFCpfnFVYPSneWhjbY9pnOJQjKckQ87anQCIQCG
+7hD5EOZ7F2XZLTdTSjvwrgPkIXY376+0RC4r9VzGkTANBgkqhkiG9w0BAQsFAAOC
+AQEAHVZgKwtIKcxJg6k5THIICJ63vZyaPJN21HVYPAN/heDUcbYzOqP0F+v+ahj5
+yNiRhSji/xxcOf5bWT158dHQoMtC1Ld1dI3lttVAvDTgXOApbmc8N0Xpjvapag3r
+b0IYW5SJio0qn1VxgeSsf0UCBTyw0N8lgbaIr3FHw2SP2rUS8PUixFRK52MYnyEp
+6Imz730Adl0RgUvp7mzRcWVDK4i6sPRqV6my68XsyaBcQr2qKALQK0Js+mE/0850
+47USqZ1XjbUke47OPxdlF85uUtIUSGquHTWnxrqy7FLMPIu9HL8XGo3vVlTYCCsb
+d6V/RWexyzZiHDGA1ToA0Y16Aw==
+-----END CERTIFICATE-----
diff --git a/test/certs/embeddedSCTs3.sct b/test/certs/embeddedSCTs3.sct
new file mode 100644
index 0000000..ad1ccf0
--- /dev/null
+++ b/test/certs/embeddedSCTs3.sct
@@ -0,0 +1,36 @@
+Signed Certificate Timestamp:
+    Version   : v1 (0x0)
+    Log ID    : 68:F6:98:F8:1F:64:82:BE:3A:8C:EE:B9:28:1D:4C:FC:
+                71:51:5D:67:93:D4:44:D1:0A:67:AC:BB:4F:4F:FB:C4
+    Timestamp : Dec  1 13:31:25.961 2015 GMT
+    Extensions: none
+    Signature : ecdsa-with-SHA256
+                30:44:02:20:58:2D:0A:BE:78:41:8A:E7:89:A9:5E:66:
+                21:C5:6A:16:79:DF:33:85:8A:D3:F3:1D:71:AF:75:30:
+                FB:CC:4E:45:02:20:41:9C:89:B8:80:19:87:46:6C:1C:
+                3A:95:0B:BE:F4:98:75:D4:CA:49:97:FD:25:2E:E3:78:
+                B5:36:30:20:26:4D
+Signed Certificate Timestamp:
+    Version   : v1 (0x0)
+    Log ID    : 56:14:06:9A:2F:D7:C2:EC:D3:F5:E1:BD:44:B2:3E:C7:
+                46:76:B9:BC:99:11:5C:C0:EF:94:98:55:D6:89:D0:DD
+    Timestamp : Dec  1 13:31:25.352 2015 GMT
+    Extensions: none
+    Signature : ecdsa-with-SHA256
+                30:45:02:20:79:68:E9:70:38:5A:63:F3:A6:B1:97:0E:
+                7E:D0:C5:71:1B:76:06:CB:09:63:48:1E:E1:20:F3:A7:
+                EF:2A:4E:74:02:21:00:8E:B7:BB:ED:85:5D:85:1B:54:
+                5E:3C:C5:EC:F2:13:9C:09:D1:0A:01:C2:59:5F:7C:31:
+                19:A1:9D:E1:17:C7:1F
+Signed Certificate Timestamp:
+    Version   : v1 (0x0)
+    Log ID    : A4:B9:09:90:B4:18:58:14:87:BB:13:A2:CC:67:70:0A:
+                3C:35:98:04:F9:1B:DF:B8:E3:77:CD:0E:C8:0D:DC:10
+    Timestamp : Dec  1 13:31:25.980 2015 GMT
+    Extensions: none
+    Signature : ecdsa-with-SHA256
+                30:45:02:20:2B:06:42:0F:D9:71:BD:21:42:A5:F9:C5:
+                55:83:D2:9D:E5:A1:8D:B6:3D:A6:73:89:42:32:9C:91:
+                0F:3B:6A:74:02:21:00:86:EE:10:F9:10:E6:7B:17:65:
+                D9:2D:37:53:4A:3B:F0:AE:03:E4:21:76:37:EF:AF:B4:
+                44:2E:2B:F5:5C:C6:91
\ No newline at end of file
diff --git a/test/ct/tls1.sct b/test/ct/tls1.sct
new file mode 100644
index 0000000..59362dc
--- /dev/null
+++ b/test/ct/tls1.sct
@@ -0,0 +1,12 @@
+Signed Certificate Timestamp:
+    Version   : v1 (0x0)
+    Log ID    : DF:1C:2E:C1:15:00:94:52:47:A9:61:68:32:5D:DC:5C:
+                79:59:E8:F7:C6:D3:88:FC:00:2E:0B:BD:3F:74:D7:64
+    Timestamp : Apr  5 17:04:16.275 2013 GMT
+    Extensions: none
+    Signature : ecdsa-with-SHA256
+                30:45:02:20:48:2F:67:51:AF:35:DB:A6:54:36:BE:1F:
+                D6:64:0F:3D:BF:9A:41:42:94:95:92:45:30:28:8F:A3:
+                E5:E2:3E:06:02:21:00:E4:ED:C0:DB:3A:C5:72:B1:E2:
+                F5:E8:AB:6A:68:06:53:98:7D:CF:41:02:7D:FE:FF:A1:
+                05:51:9D:89:ED:BF:08
\ No newline at end of file
diff --git a/test/ct_test.c b/test/ct_test.c
new file mode 100644
index 0000000..cc01b13
--- /dev/null
+++ b/test/ct_test.c
@@ -0,0 +1,404 @@
+/*
+ * Tests the Certificate Transparency public and internal APIs.
+ *
+ * Author:    Rob Percival (<A HREF="../../../mailman/listinfo/openssl-commits.html">robpercival at google.com</A>)
+ * Date:        2016-01-26
+ *
+ * ====================================================================
+ * Copyright (c) 2016 The OpenSSL Project.    All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *        notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *        notice, this list of conditions and the following disclaimer in
+ *        the documentation and/or other materials provided with the
+ *        distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *        software must display the following acknowledgment:
+ *        &quot;This product includes software developed by the OpenSSL Project
+ *        for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
+ *
+ * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+ *        endorse or promote products derived from this software without
+ *        prior written permission. For written permission, please contact
+ *        <A HREF="../../../mailman/listinfo/openssl-commits.html">licensing at OpenSSL.org.</A>
+ *
+ * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+ *        nor may &quot;OpenSSL&quot; appear in their names without prior written
+ *        permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *        acknowledgment:
+ *        &quot;This product includes software developed by the OpenSSL Project
+ *        for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.    IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+#include &lt;ctype.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;crypto/include/internal/ct_int.h&quot;
+#include &quot;openssl/err.h&quot;
+#include &quot;openssl/safestack.h&quot;
+#include &quot;openssl/ssl.h&quot;
+#include &quot;openssl/x509.h&quot;
+#include &quot;openssl/x509v3.h&quot;
+#include &quot;testutil.h&quot;
+
+#if !defined(OPENSSL_NO_CT) &amp;&amp; !defined(OPENSSL_NO_UNIT_TEST)
+
+/* Used when declaring buffers to read text files into */
+#define CT_TEST_MAX_FILE_SIZE 8096
+
+typedef struct ct_test_fixture {
+    const char *test_case_name;
+    /* Set the following to test handling of SCTs in X509 certificates */
+    const char *certificate_file_path;
+    size_t expected_sct_count;
+    /* Set the following to test handling of SCTs in TLS format */
+    const uint8_t *tls_sct;
+    size_t tls_sct_len;
+    const SCT *sct;
+    /*
+     * A file to load the expected SCT text from.
+     * This text will be compared to the actual text output during the test.
+     * A maximum of |CT_TEST_MAX_FILE_SIZE| bytes will be read of this file.
+     */
+    const char *sct_text_file_path;
+
+} CT_TEST_FIXTURE;
+
+static CT_TEST_FIXTURE set_up(const char *const test_case_name)
+{
+    CT_TEST_FIXTURE fixture;
+    int setup_ok = 1;
+
+    memset(&amp;fixture, 0, sizeof(fixture));
+    fixture.test_case_name = test_case_name;
+
+    if (!setup_ok) {
+        exit(EXIT_FAILURE);
+    }
+    return fixture;
+}
+
+static void tear_down(CT_TEST_FIXTURE fixture)
+{
+    ERR_print_errors_fp(stderr);
+}
+
+static X509 *load_pem_cert(const char *file)
+{
+    BIO *cert_io = BIO_new_file(file, &quot;r&quot;);
+    X509 *cert = NULL;
+
+    if (cert_io == NULL) goto end;
+
+    cert = PEM_read_bio_X509(cert_io, NULL, NULL, NULL);
+
+end:
+    BIO_free(cert_io);
+    return cert;
+}
+
+static int read_text_file(const char *path, char *buffer, int buffer_length)
+{
+    BIO *file = BIO_new_file(path, &quot;r&quot;);
+    int result = -1;
+
+    if (file != NULL) {
+        result = BIO_read(file, buffer, buffer_length);
+        BIO_free(file);
+    }
+
+    return result;
+}
+
+static int compare_sct_printout(SCT *sct,
+    const char *expected_output)
+{
+    BIO *text_buffer = NULL;
+    char *actual_output = NULL;
+    int result = 1;
+
+    text_buffer = BIO_new(BIO_s_mem());
+    if (text_buffer == NULL) {
+        fprintf(stderr, &quot;Unable to allocate buffer\n&quot;);
+        goto end;
+    }
+
+    SCT_print(sct, text_buffer, 0);
+
+    /* Append null terminator because we're about to use the buffer contents
+    * as a string. */
+    if (BIO_write(text_buffer, &quot;\0&quot;, 1) != 1) {
+        fprintf(stderr, &quot;Failed to append null terminator to SCT text\n&quot;);
+        goto end;
+    }
+
+    BIO_get_mem_data(text_buffer, &amp;actual_output);
+    result = strcmp(actual_output, expected_output);
+
+    if (result != 0) {
+        fprintf(stderr,
+            &quot;Expected SCT printout:\n%s\nActual SCT printout:\n%s\n&quot;,
+            expected_output, actual_output);
+    }
+
+end:
+    BIO_free(text_buffer);
+    return result;
+}
+
+static int compare_extension_printout(X509_EXTENSION *extension,
+                                      const char *expected_output)
+{
+    BIO *text_buffer = NULL;
+    char *actual_output = NULL;
+    int result = 1;
+
+    text_buffer = BIO_new(BIO_s_mem());
+    if (text_buffer == NULL) {
+        fprintf(stderr, &quot;Unable to allocate buffer\n&quot;);
+        goto end;
+    }
+
+    if (!X509V3_EXT_print(text_buffer, extension, X509V3_EXT_DEFAULT, 0)) {
+        fprintf(stderr, &quot;Failed to print extension\n&quot;);
+        goto end;
+    }
+
+    /* Append null terminator because we're about to use the buffer contents
+     * as a string. */
+    if (BIO_write(text_buffer, &quot;\0&quot;, 1) != 1) {
+        fprintf(stderr, &quot;Failed to append null terminator to extension text\n&quot;);
+        goto end;
+    }
+
+    BIO_get_mem_data(text_buffer, &amp;actual_output);
+    result = strcmp(actual_output, expected_output);
+
+    if (result != 0) {
+        fprintf(stderr,
+                &quot;Expected SCT printout:\n%s\nActual SCT printout:\n%s\n&quot;,
+                expected_output, actual_output);
+    }
+
+end:
+    BIO_free(text_buffer);
+    return result;
+}
+
+static int execute_cert_test(CT_TEST_FIXTURE fixture)
+{
+    int result = 0;
+    X509 *cert = NULL;
+    SCT *sct = NULL;
+    char expected_sct_text[CT_TEST_MAX_FILE_SIZE];
+    int sct_text_len = 0;
+
+    if (fixture.sct_text_file_path != NULL) {
+        sct_text_len = read_text_file(
+            fixture.sct_text_file_path,
+            expected_sct_text,
+            CT_TEST_MAX_FILE_SIZE - 1);
+
+        if (sct_text_len &lt; 0) {
+            result = 1;
+            fprintf(stderr, &quot;Test data file not found: %s\n&quot;,
+                fixture.sct_text_file_path);
+            goto end;
+        }
+
+        expected_sct_text[sct_text_len] = '\0';
+    }
+
+    if (fixture.certificate_file_path != NULL) {
+        int sct_extension_index;
+        X509_EXTENSION *sct_extension = NULL;
+        cert = load_pem_cert(fixture.certificate_file_path);
+
+        if (cert == NULL) {
+            result = 1;
+            fprintf(stderr, &quot;Unable to load certificate: %s\n&quot;,
+                fixture.certificate_file_path);
+            goto end;
+        }
+
+        sct_extension_index = X509_get_ext_by_NID(cert, NID_ct_precert_scts, -1);
+        sct_extension = X509_get_ext(cert, sct_extension_index);
+        if (fixture.expected_sct_count &gt; 0) {
+            if (sct_extension == NULL) {
+                result = 1;
+                fprintf(stderr, &quot;SCT extension not found in: %s\n&quot;,
+                    fixture.certificate_file_path);
+                goto end;
+            }
+
+            if (fixture.sct_text_file_path) {
+                result = compare_extension_printout(sct_extension,
+                                                    expected_sct_text);
+                if (result != 0)
+                    goto end;
+            }
+        } else if (sct_extension != NULL) {
+            result = 1;
+            fprintf(stderr, &quot;Expected no SCTs, but found SCT extension in: %s\n&quot;,
+                fixture.certificate_file_path);
+            goto end;
+        }
+    }
+
+    if (fixture.tls_sct != NULL) {
+        const unsigned char *p = fixture.tls_sct;
+        unsigned char *tls_sct;
+        size_t tls_sct_len;
+        if (o2i_SCT(&amp;sct, &amp;p, fixture.tls_sct_len) == NULL) {
+            result = 1;
+            fprintf(stderr, &quot;Failed to decode SCT from TLS format\n&quot;);
+            goto end;
+        }
+
+        if (fixture.sct_text_file_path) {
+            result = compare_sct_printout(sct, expected_sct_text);
+            if (result != 0)
+                goto end;
+        }
+
+        tls_sct_len = i2o_SCT(sct, &amp;tls_sct);
+        if (tls_sct_len != fixture.tls_sct_len ||
+            memcmp(fixture.tls_sct, tls_sct, tls_sct_len) != 0) {
+            result = 1;
+            fprintf(stderr, &quot;Failed to encode SCT into TLS format correctly\n&quot;);
+            goto end;
+        }
+    }
+
+end:
+    X509_free(cert);
+    SCT_free(sct);
+    return result;
+}
+
+#define SETUP_CT_TEST_FIXTURE() SETUP_TEST_FIXTURE(CT_TEST_FIXTURE, set_up)
+#define EXECUTE_CT_TEST() EXECUTE_TEST(execute_cert_test, tear_down)
+
+static int test_no_scts_in_certificate()
+{
+    SETUP_CT_TEST_FIXTURE();
+    fixture.certificate_file_path = &quot;certs/leaf.pem&quot;;
+    fixture.expected_sct_count = 0;
+    EXECUTE_CT_TEST();
+}
+
+static int test_one_sct_in_certificate()
+{
+    SETUP_CT_TEST_FIXTURE();
+    fixture.certificate_file_path = &quot;certs/embeddedSCTs1.pem&quot;;
+    fixture.expected_sct_count = 1;
+    fixture.sct_text_file_path = &quot;certs/embeddedSCTs1.sct&quot;;
+    EXECUTE_CT_TEST();
+}
+
+static int test_multiple_scts_in_certificate()
+{
+    SETUP_CT_TEST_FIXTURE();
+    fixture.certificate_file_path = &quot;certs/embeddedSCTs3.pem&quot;;
+    fixture.expected_sct_count = 3;
+    fixture.sct_text_file_path = &quot;certs/embeddedSCTs3.sct&quot;;
+    EXECUTE_CT_TEST();
+}
+
+static int test_decode_tls_sct()
+{
+    SETUP_CT_TEST_FIXTURE();
+    fixture.tls_sct = (unsigned char *)
+        &quot;\x00&quot; /* version */
+        /* log ID */
+        &quot;\xDF\x1C\x2E\xC1\x15\x00\x94\x52\x47\xA9\x61\x68\x32\x5D\xDC\x5C\x79&quot;
+        &quot;\x59\xE8\xF7\xC6\xD3\x88\xFC\x00\x2E\x0B\xBD\x3F\x74\xD7\x64&quot;
+        &quot;\x00\x00\x01\x3D\xDB\x27\xDF\x93&quot; /* timestamp */
+        &quot;\x00\x00&quot; /* extensions length */
+        &quot;&quot; /* extensions */
+        &quot;\x04\x03&quot; /* hash and signature algorithms */
+        &quot;\x00\x47&quot; /* signature length */
+        &quot;\x30\x45\x02\x20\x48\x2F\x67\x51\xAF\x35\xDB\xA6\x54\x36\xBE\x1F\xD6&quot;
+        &quot;\x64\x0F\x3D\xBF\x9A\x41\x42\x94\x95\x92\x45\x30\x28\x8F\xA3\xE5\xE2&quot;
+        &quot;\x3E\x06\x02\x21\x00\xE4\xED\xC0\xDB\x3A\xC5\x72\xB1\xE2\xF5\xE8\xAB&quot;
+        &quot;\x6A\x68\x06\x53\x98\x7D\xCF\x41\x02\x7D\xFE\xFF\xA1\x05\x51\x9D\x89&quot;
+        &quot;\xED\xBF\x08&quot;; /* signature */
+    fixture.tls_sct_len = 118;
+    fixture.sct_text_file_path = &quot;ct/tls1.sct&quot;;
+    EXECUTE_CT_TEST();
+}
+
+static int test_encode_tls_sct()
+{
+    SETUP_CT_TEST_FIXTURE();
+
+    SCT *sct = SCT_new();
+    SCT_set_version(sct, 0);
+    SCT_set1_log_id(sct, (unsigned char *)
+        &quot;\xDF\x1C\x2E\xC1\x15\x00\x94\x52\x47\xA9\x61\x68\x32\x5D\xDC\x5C\x79&quot;
+        &quot;\x59\xE8\xF7\xC6\xD3\x88\xFC\x00\x2E\x0B\xBD\x3F\x74\xD7\x64&quot;, 32);
+    SCT_set_timestamp(sct, 1);
+    SCT_set1_extensions(sct, (unsigned char *)&quot;&quot;, 0);
+    SCT_set_signature_nid(sct, NID_ecdsa_with_SHA256);
+    SCT_set1_signature(sct, (unsigned char *)
+        &quot;\x45\x02\x20\x48\x2F\x67\x51\xAF\x35\xDB\xA6\x54\x36\xBE&quot;
+        &quot;\x1F\xD6\x64\x0F\x3D\xBF\x9A\x41\x42\x94\x95\x92\x45\x30\x28\x8F\xA3&quot;
+        &quot;\xE5\xE2\x3E\x06\x02\x21\x00\xE4\xED\xC0\xDB\x3A\xC5\x72\xB1\xE2\xF5&quot;
+        &quot;\xE8\xAB\x6A\x68\x06\x53\x98\x7D\xCF\x41\x02\x7D\xFE\xFF\xA1\x05\x51&quot;
+        &quot;\x9D\x89\xED\xBF\x08&quot;, 71);
+    fixture.sct = sct;
+    fixture.sct_text_file_path = &quot;ct/tls1.sct&quot;;
+    EXECUTE_CT_TEST();
+
+    SCT_free(sct);
+}
+
+int main(int argc, char *argv[])
+{
+    int result = 0;
+
+    ADD_TEST(test_no_scts_in_certificate);
+    ADD_TEST(test_one_sct_in_certificate);
+    ADD_TEST(test_multiple_scts_in_certificate);
+    ADD_TEST(test_decode_tls_sct);
+    ADD_TEST(test_encode_tls_sct);
+
+    result = run_tests(argv[0]);
+    ERR_print_errors_fp(stderr);
+
+    return result;
+}
+
+#else /* OPENSSL_NO_CT */
+
+int main(int argc, char* argv[])
+{
+    return EXIT_SUCCESS;
+}
+
+#endif /* OPENSSL_NO_CT */
diff --git a/test/recipes/90-test_ige.t b/test/recipes/80-test_ct.t
similarity index 56%
copy from test/recipes/90-test_ige.t
copy to test/recipes/80-test_ct.t
index f008350..616bb17 100644
--- a/test/recipes/90-test_ige.t
+++ b/test/recipes/80-test_ct.t
@@ -2,4 +2,5 @@
 
 use OpenSSL::Test::Simple;
 
-simple_test(&quot;test_ige&quot;, &quot;igetest&quot;);
+simple_test(&quot;test_ct&quot;, &quot;ct_test&quot;);
+
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004487.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="004493.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4492">[ date ]</a>
              <a href="thread.html#4492">[ thread ]</a>
              <a href="subject.html#4492">[ subject ]</a>
              <a href="author.html#4492">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
