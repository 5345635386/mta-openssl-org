<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2015-March/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1427399745.957492.4245.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000806.html">
   <LINK REL="Next"  HREF="000808.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1427399745.957492.4245.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Thu Mar 26 19:55:45 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="000806.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="000808.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#807">[ date ]</a>
              <a href="thread.html#807">[ thread ]</a>
              <a href="subject.html#807">[ subject ]</a>
              <a href="author.html#807">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  ee3ef9cbe9b355c460ebb06c3eee0e503fe1fb1a (commit)
       via  6f7ae319df8e7cb4578815f9944b3b912c0df308 (commit)
       via  d2200cafd4870c20ef170834e072fae1d8c412d5 (commit)
       via  e5bf62f716f71e4df6995a07d1fbc4cad82a2637 (commit)
       via  3497ac5d333af98947d0356146a0898e2398d321 (commit)
       via  1711f8de45cdee01fdf21e55db5522d23b450867 (commit)
       via  9e7ba3b2a2ffc049b4b5c664cf33473b475ce323 (commit)
       via  c99c4c11a202ed71d4c232075668a876f352d71a (commit)
       via  44cc35d38278da82d8be7ec3799d2f6565c2dfe5 (commit)
       via  cca52a844f7e62b312f9699a1494807295858064 (commit)
       via  3bb8f87d2d9aa1ab51703a725759d440785685e3 (commit)
       via  14daae5a625b38b43229eed0cf750f44d5881c0b (commit)
       via  24a1e2f2ec1553c2cc26574bdb48b5d8c1b913f7 (commit)
       via  c661ac16891460eaf443db3303a7b1358b14526d (commit)
       via  5fb6f80cdfa418d9429f39f348d7bab8b5f9578a (commit)
       via  cb2ce7abfd3e2e641851e0ed9dff1a883b38037e (commit)
       via  91f93f69ef59bbe9ad8d191eed5a88b2125fba26 (commit)
       via  78a39fe735ef253bbf1d028a3e7934bda76f8276 (commit)
       via  40f37188a63c988c66bfece95280b67158998e64 (commit)
       via  bb4203d97e7b3350fe501d90485526a6e5dc1e3e (commit)
       via  de07f311ce5569d698c86c7498f98345a9f472d6 (commit)
       via  f8caa3c813bcf9c621f8576eeba8a0df67596dac (commit)
       via  4aa7389e6c5509416d1672c7adddd1476dc1af09 (commit)
       via  e2228d318c51c2238ad8667b27574ae06afea191 (commit)
       via  295c3f41113f4ff537fb95e29f7f709ba03c6a21 (commit)
       via  7a7048aff053929feaadee4895749fe0a661d353 (commit)
       via  24a90afd858634d3fc4aabae6aa7e30020dc87ff (commit)
       via  88c23039484522457abdf83db2c64e3af6d0d8ca (commit)
       via  2c60ed0452919ea9a67886685e2fa5c8b9330620 (commit)
       via  bd2e3a9512523ff888982cd91e830fc49f1a9595 (commit)
       via  75d40c9332e271a03a3cad09502ea4f8363590dc (commit)
       via  d5a25ae0deeabc9baaacef64f4c23fbd0c2d67e9 (commit)
       via  c036e210f3339fc30fa88da4bd78753c6e643eaa (commit)
       via  bbcd6d7fe263361f18060c40cac676d6a6193ead (commit)
       via  f161995e0e1a77415354b1690fb92ae3f1480547 (commit)
       via  af9752e5faff5dd3c82fc2d02d1e7ad457ccb84a (commit)
       via  a0682a5e26dc7ac1466b218cc87d322094651518 (commit)
       via  999005e49355d738a017fa300630864f832b6273 (commit)
       via  c103c7e266145dc922115a2c3079776bb8216939 (commit)
       via  02a36fdae8cb503e2f88eac52eb3053431089397 (commit)
       via  fe589e6175f350a3e83b39ea07a08b0c824ea6fb (commit)
       via  7604202070b3d3767fe75bc8c5a268ee8aedfb52 (commit)
       via  4e08d4a84c5935667ae266008174565b3ba39b58 (commit)
       via  92ffa83d8b5bb9ba9d56a8e321d5924956a0bbe4 (commit)
       via  cd986e55865987c95bb89bd48b0ea1b0d7422860 (commit)
       via  258f8721a5d2c3ec5fd433e89112885139be1db3 (commit)
       via  ab97b2cd4301074fd88fd2f13b8c79342593dae4 (commit)
       via  db9a32e7193ef5841e5a021061237b8b24f68126 (commit)
       via  33d23b87a0d06bc497a13b1998737a1ce469a785 (commit)
       via  28d59af8740680c89e22ac19304457f2163e4371 (commit)
       via  52e1d7b152a92d4fc2c3704a0129ec0ee0ce5e21 (commit)
      from  8e3f0c988fabf60b65f7109b7f47daec0fde9c39 (commit)


- Log -----------------------------------------------------------------
commit ee3ef9cbe9b355c460ebb06c3eee0e503fe1fb1a
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Mar 26 13:51:32 2015 +0000

    Add Record Layer documentation
    
    Add some design documentation on how the record layer works to aid future
    maintenance.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 6f7ae319df8e7cb4578815f9944b3b912c0df308
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Mar 26 15:14:42 2015 +0000

    Fix formatting oddities
    
    Fix some formatting oddities in rec_layer_d1.c.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit d2200cafd4870c20ef170834e072fae1d8c412d5
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Mar 26 13:17:38 2015 +0000

    Fix record.h formatting
    
    Fix some strange formatting in record.h. This was probably originally
    introduced as part of the reformat work.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit e5bf62f716f71e4df6995a07d1fbc4cad82a2637
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Mar 26 13:12:24 2015 +0000

    Define SEQ_NUM_SIZE
    
    Replace the hard coded value 8 (the size of the sequence number) with a
    constant defined in a macro.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 3497ac5d333af98947d0356146a0898e2398d321
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Feb 4 16:29:38 2015 +0000

    Fix compilation on windows for record layer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 1711f8de45cdee01fdf21e55db5522d23b450867
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Feb 4 16:02:37 2015 +0000

    Rename record layer source files
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 9e7ba3b2a2ffc049b4b5c664cf33473b475ce323
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Feb 4 15:52:15 2015 +0000

    Remove some unneccessary macros
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit c99c4c11a202ed71d4c232075668a876f352d71a
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Feb 4 15:52:05 2015 +0000

    Renamed record layer header files
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 44cc35d38278da82d8be7ec3799d2f6565c2dfe5
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Feb 4 15:44:12 2015 +0000

    Reorganise header files
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit cca52a844f7e62b312f9699a1494807295858064
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Feb 4 14:30:20 2015 +0000

    Remove last trace of non-record layer code reading and writing sequence
    numbers directly
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 3bb8f87d2d9aa1ab51703a725759d440785685e3
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Feb 4 11:57:34 2015 +0000

    Move last_write_sequence from s-&gt;d1 to s-&gt;rlayer.d.
    Also push some usage of last_write_sequence out of dtls1_retransmit_message
    and into the record layer.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 14daae5a625b38b43229eed0cf750f44d5881c0b
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Feb 4 11:24:24 2015 +0000

    Move ssl3_record_sequence_update into record layer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 24a1e2f2ec1553c2cc26574bdb48b5d8c1b913f7
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Feb 4 10:27:43 2015 +0000

    Move buffered_app_data from s-&gt;d1 to s-&gt;rlayer.d
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit c661ac16891460eaf443db3303a7b1358b14526d
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Feb 4 10:14:36 2015 +0000

    Move handshake_fragment, handshake_fragment_len, alert_fragment and
    alert_fragment_len from s-&gt;d1 to s-&gt;rlayer.d
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 5fb6f80cdfa418d9429f39f348d7bab8b5f9578a
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 16:11:49 2015 +0000

    Fix seg fault in dtls1_new
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit cb2ce7abfd3e2e641851e0ed9dff1a883b38037e
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 16:05:28 2015 +0000

    Moved processed_rcds and unprocessed_rcds from s-&gt;d1 to s-&gt;rlayer.d
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 91f93f69ef59bbe9ad8d191eed5a88b2125fba26
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 15:39:06 2015 +0000

    Move bitmap and next_bitmap from s-&gt;d1 to s-&gt;rlayer.d.
    Create dtls_bitmap.h and dtls_bitmap.c
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 78a39fe735ef253bbf1d028a3e7934bda76f8276
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 15:14:24 2015 +0000

    Move r_epoch and w_epoch from s-&gt;d1 to s-&gt;rlayer.d
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 40f37188a63c988c66bfece95280b67158998e64
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 14:54:13 2015 +0000

    Introduce a DTLS_RECORD_LAYER type for DTLS record layer state
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit bb4203d97e7b3350fe501d90485526a6e5dc1e3e
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 14:32:15 2015 +0000

    Move DTLS1_RECORD_DATA into rec_layer.h
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit de07f311ce5569d698c86c7498f98345a9f472d6
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 14:26:50 2015 +0000

    Move read_sequence and write_sequence from s-&gt;s3 to s-&gt;rlayer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit f8caa3c813bcf9c621f8576eeba8a0df67596dac
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 13:22:12 2015 +0000

    Move s-&gt;s3-&gt;wpend_* to s-&gt;rlayer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 4aa7389e6c5509416d1672c7adddd1476dc1af09
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 13:12:22 2015 +0000

    Move handshake_fragment, handshake_fragment_len, alert_fragment and
    alert_fragment_len from s-&gt;s3 into s-&gt;rlayer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit e2228d318c51c2238ad8667b27574ae06afea191
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 11:16:30 2015 +0000

    Move s-&gt;s3-&gt;wnum to s-&gt;rlayer.wnum
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 295c3f41113f4ff537fb95e29f7f709ba03c6a21
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Feb 3 10:48:28 2015 +0000

    Move s-&gt;rstate to s-&gt;rlayer.rstate
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 7a7048aff053929feaadee4895749fe0a661d353
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 20:55:15 2015 +0000

    Move s-&gt;packet and s-&gt;packet_length into s-&gt;rlayer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 24a90afd858634d3fc4aabae6aa7e30020dc87ff
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 16:14:03 2015 +0000

    Remove unneccessary use of accessor function now code is moved into record
    layer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 88c23039484522457abdf83db2c64e3af6d0d8ca
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 16:02:55 2015 +0000

    Make rrec, wrec, rbuf and wbuf fully private to the record layer. Also, clean
    up some access to them. Now that various functions have been moved into the
    record layer they no longer need to use the accessor macros.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 2c60ed0452919ea9a67886685e2fa5c8b9330620
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 15:47:39 2015 +0000

    Removed dependency on rrec from heartbeat processing
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit bd2e3a9512523ff888982cd91e830fc49f1a9595
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 14:52:32 2015 +0000

    Introduce macro RECORD_LAYER_setup_comp_buffer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 75d40c9332e271a03a3cad09502ea4f8363590dc
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 14:08:34 2015 +0000

    Fix bug where rrec was being released...should have been removed by one of
    the earlier record layer commits
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit d5a25ae0deeabc9baaacef64f4c23fbd0c2d67e9
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 14:03:50 2015 +0000

    Move ssl3_pending into the record layer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit c036e210f3339fc30fa88da4bd78753c6e643eaa
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 13:57:12 2015 +0000

    Remove RECORD_LAYER_set_ssl and introduce RECORD_LAYER_init
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit bbcd6d7fe263361f18060c40cac676d6a6193ead
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 13:43:38 2015 +0000

    Provide RECORD_LAYER_set_data function
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit f161995e0e1a77415354b1690fb92ae3f1480547
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 12:18:03 2015 +0000

    Introduce the functions RECORD_LAYER_release, RECORD_LAYER_read_pending, and
    RECORD_LAYER_write_pending.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit af9752e5faff5dd3c82fc2d02d1e7ad457ccb84a
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 11:53:20 2015 +0000

    Create RECORD_LAYER_clear function.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit a0682a5e26dc7ac1466b218cc87d322094651518
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 11:41:29 2015 +0000

    Tidy up rec_layer.h. Add some comments regarding which functions should be
    being used for what purpose.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 999005e49355d738a017fa300630864f832b6273
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 10:38:12 2015 +0000

    Moved s3_pkt.c, s23_pkt.c and d1_pkt.c into the record layer.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit c103c7e266145dc922115a2c3079776bb8216939
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Feb 2 10:05:09 2015 +0000

    Split out non record layer functions out of s3_pkt.c and d1_pkt.c into
    the new files s3_msg.c and s1_msg.c respectively.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 02a36fdae8cb503e2f88eac52eb3053431089397
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Sun Feb 1 17:14:43 2015 +0000

    Move more SSL3_RECORD oriented functions into ssl3_record.c
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit fe589e6175f350a3e83b39ea07a08b0c824ea6fb
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Sun Feb 1 16:47:15 2015 +0000

    Move SSL3_RECORD oriented functions into ssl3_record.c
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 7604202070b3d3767fe75bc8c5a268ee8aedfb52
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Sun Feb 1 16:03:18 2015 +0000

    Move SSL3_BUFFER set up and release code into ssl3_buffer.c
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 4e08d4a84c5935667ae266008174565b3ba39b58
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Sun Feb 1 15:41:06 2015 +0000

    Move s-&gt;s3-&gt;wrec to s&gt;rlayer&gt;wrec
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 92ffa83d8b5bb9ba9d56a8e321d5924956a0bbe4
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Sun Feb 1 15:30:37 2015 +0000

    Encapsulate s-&gt;s3-&gt;wrec
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit cd986e55865987c95bb89bd48b0ea1b0d7422860
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Jan 30 23:27:17 2015 +0000

    Move s-&gt;s3-&gt;rrec to s-&gt;rlayer-&gt;rrec
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 258f8721a5d2c3ec5fd433e89112885139be1db3
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Jan 30 17:29:41 2015 +0000

    Encapsulate s-&gt;s3-&gt;rrec
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit ab97b2cd4301074fd88fd2f13b8c79342593dae4
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Jan 30 16:17:25 2015 +0000

    Move s-&gt;s3-&gt;wbuf to s-&gt;rlayer-&gt;wbuf
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit db9a32e7193ef5841e5a021061237b8b24f68126
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Jan 30 16:05:47 2015 +0000

    Encapsulate access to s-&gt;s3-&gt;wbuf
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 33d23b87a0d06bc497a13b1998737a1ce469a785
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Jan 30 15:38:10 2015 +0000

    Move s-&gt;s3-&gt;rrec into s-&gt;rlayer
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 28d59af8740680c89e22ac19304457f2163e4371
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Jan 30 14:57:54 2015 +0000

    Encapsulate SSL3_BUFFER and all access to s-&gt;s3-&gt;rbuf.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 52e1d7b152a92d4fc2c3704a0129ec0ee0ce5e21
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Jan 30 13:46:43 2015 +0000

    Create a RECORD_LAYER structure and move read_ahead into it.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 ssl/Makefile                                      |   22 +-
 ssl/d1_both.c                                     |   43 +-
 ssl/d1_lib.c                                      |   63 +-
 crypto/rand/rand_nw.c =&gt; ssl/d1_msg.c             |  241 ++--
 ssl/d1_srvr.c                                     |    3 +-
 ssl/heartbeat_test.c                              |   15 +-
 ssl/record/README                                 |   78 ++
 apps/app_rand.c =&gt; ssl/record/dtls1_bitmap.c      |  290 ++--
 ssl/{d1_pkt.c =&gt; record/rec_layer_d1.c}           |  847 +++--------
 ssl/{s23_pkt.c =&gt; record/rec_layer_s23.c}         |   19 +-
 ssl/{s3_pkt.c =&gt; record/rec_layer_s3.c}           |  777 ++++------
 ssl/record/record.h                               |  345 +++++
 crypto/rand/rand_nw.c =&gt; ssl/record/record_locl.h |  127 +-
 apps/app_rand.c =&gt; ssl/record/ssl3_buffer.c       |  200 +--
 ssl/record/ssl3_record.c                          | 1558 +++++++++++++++++++++
 ssl/s23_clnt.c                                    |   15 +-
 ssl/s23_srvr.c                                    |   54 +-
 ssl/s3_both.c                                     |  105 +-
 ssl/s3_cbc.c                                      |  220 ---
 ssl/s3_enc.c                                      |  189 +--
 ssl/s3_lib.c                                      |   40 +-
 apps/app_rand.c =&gt; ssl/s3_msg.c                   |  194 +--
 ssl/ssl.h                                         |    4 +-
 ssl/ssl_lib.c                                     |   23 +-
 ssl/ssl_locl.h                                    |  184 +--
 ssl/ssl_stat.c                                    |   41 -
 ssl/t1_enc.c                                      |  300 +---
 ssl/t1_lib.c                                      |   10 +-
 28 files changed, 3124 insertions(+), 2883 deletions(-)
 copy crypto/rand/rand_nw.c =&gt; ssl/d1_msg.c (68%)
 create mode 100644 ssl/record/README
 copy apps/app_rand.c =&gt; ssl/record/dtls1_bitmap.c (66%)
 rename ssl/{d1_pkt.c =&gt; record/rec_layer_d1.c} (62%)
 rename ssl/{s23_pkt.c =&gt; record/rec_layer_s23.c} (90%)
 rename ssl/{s3_pkt.c =&gt; record/rec_layer_s3.c} (68%)
 create mode 100644 ssl/record/record.h
 copy crypto/rand/rand_nw.c =&gt; ssl/record/record_locl.h (59%)
 copy apps/app_rand.c =&gt; ssl/record/ssl3_buffer.c (65%)
 create mode 100644 ssl/record/ssl3_record.c
 copy apps/app_rand.c =&gt; ssl/s3_msg.c (62%)

diff --git a/ssl/Makefile b/ssl/Makefile
index 90b6ac5..d876d91 100644
--- a/ssl/Makefile
+++ b/ssl/Makefile
@@ -21,30 +21,34 @@ APPS=
 LIB=$(TOP)/libssl.a
 SHARED_LIB= libssl$(SHLIB_EXT)
 LIBSRC=	\
-	s3_meth.c   s3_srvr.c s3_clnt.c  s3_lib.c  s3_enc.c s3_pkt.c s3_both.c s3_cbc.c \
-	s23_meth.c s23_srvr.c s23_clnt.c s23_lib.c          s23_pkt.c \
+	s3_meth.c   s3_srvr.c s3_clnt.c  s3_lib.c  s3_enc.c record/rec_layer_s3.c \
+	s3_both.c s3_cbc.c s3_msg.c \
+	s23_meth.c s23_srvr.c s23_clnt.c s23_lib.c record/rec_layer_s23.c \
 	t1_meth.c   t1_srvr.c t1_clnt.c  t1_lib.c  t1_enc.c t1_ext.c \
-	d1_meth.c   d1_srvr.c d1_clnt.c  d1_lib.c  d1_pkt.c \
+	d1_meth.c   d1_srvr.c d1_clnt.c  d1_lib.c  record/rec_layer_d1.c d1_msg.c \
 	d1_both.c d1_srtp.c \
 	ssl_lib.c ssl_err2.c ssl_cert.c ssl_sess.c \
 	ssl_ciph.c ssl_stat.c ssl_rsa.c \
 	ssl_asn1.c ssl_txt.c ssl_algs.c ssl_conf.c \
-	bio_ssl.c ssl_err.c kssl.c t1_reneg.c tls_srp.c t1_trce.c ssl_utst.c
+	bio_ssl.c ssl_err.c kssl.c t1_reneg.c tls_srp.c t1_trce.c ssl_utst.c \
+	record/ssl3_buffer.c record/ssl3_record.c record/dtls1_bitmap.c
 LIBOBJ= \
-	s3_meth.o  s3_srvr.o  s3_clnt.o  s3_lib.o  s3_enc.o s3_pkt.o s3_both.o s3_cbc.o \
-	s23_meth.o s23_srvr.o s23_clnt.o s23_lib.o          s23_pkt.o \
+	s3_meth.o  s3_srvr.o  s3_clnt.o  s3_lib.o  s3_enc.o record/rec_layer_s3.o \
+	s3_both.o s3_cbc.o s3_msg.o \
+	s23_meth.o s23_srvr.o s23_clnt.o s23_lib.o record/rec_layer_s23.o \
 	t1_meth.o   t1_srvr.o t1_clnt.o  t1_lib.o  t1_enc.o t1_ext.o \
-	d1_meth.o   d1_srvr.o d1_clnt.o  d1_lib.o  d1_pkt.o \
+	d1_meth.o   d1_srvr.o d1_clnt.o  d1_lib.o  record/rec_layer_d1.o d1_msg.o \
 	d1_both.o d1_srtp.o\
 	ssl_lib.o ssl_err2.o ssl_cert.o ssl_sess.o \
 	ssl_ciph.o ssl_stat.o ssl_rsa.o \
 	ssl_asn1.o ssl_txt.o ssl_algs.o ssl_conf.o \
-	bio_ssl.o ssl_err.o kssl.o t1_reneg.o tls_srp.o t1_trce.o ssl_utst.o
+	bio_ssl.o ssl_err.o kssl.o t1_reneg.o tls_srp.o t1_trce.o ssl_utst.o \
+	record/ssl3_buffer.o record/ssl3_record.o record/dtls1_bitmap.o
 
 SRC= $(LIBSRC)
 
 EXHEADER= ssl.h ssl2.h ssl3.h ssl23.h tls1.h dtls1.h kssl.h srtp.h
-HEADER=	$(EXHEADER) ssl_locl.h kssl_lcl.h
+HEADER=	$(EXHEADER) ssl_locl.h kssl_lcl.h  record/record_locl.h record/record.h
 
 ALL=    $(GENERAL) $(SRC) $(HEADER)
 
diff --git a/ssl/d1_both.c b/ssl/d1_both.c
index 8d15f70..094b337 100644
--- a/ssl/d1_both.c
+++ b/ssl/d1_both.c
@@ -961,7 +961,7 @@ dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok)
 /*-
  * for these 2 messages, we need to
  * ssl-&gt;enc_read_ctx                    re-init
- * ssl-&gt;s3-&gt;read_sequence               zero
+ * ssl-&gt;rlayer.read_sequence            zero
  * ssl-&gt;s3-&gt;read_mac_secret             re-init
  * ssl-&gt;session-&gt;read_sym_enc           assign
  * ssl-&gt;session-&gt;read_compression       assign
@@ -1110,7 +1110,8 @@ int dtls1_buffer_message(SSL *s, int is_ccs)
     frag-&gt;msg_header.saved_retransmit_state.write_hash = s-&gt;write_hash;
     frag-&gt;msg_header.saved_retransmit_state.compress = s-&gt;compress;
     frag-&gt;msg_header.saved_retransmit_state.session = s-&gt;session;
-    frag-&gt;msg_header.saved_retransmit_state.epoch = s-&gt;d1-&gt;w_epoch;
+    frag-&gt;msg_header.saved_retransmit_state.epoch =
+        DTLS_RECORD_LAYER_get_w_epoch(&amp;s-&gt;rlayer);
 
     memset(seq64be, 0, sizeof(seq64be));
     seq64be[6] =
@@ -1143,7 +1144,6 @@ dtls1_retransmit_message(SSL *s, unsigned short seq, unsigned long frag_off,
     unsigned long header_length;
     unsigned char seq64be[8];
     struct dtls1_retransmit_state saved_state;
-    unsigned char save_write_sequence[8];
 
     /*-
       OPENSSL_assert(s-&gt;init_num == 0);
@@ -1184,8 +1184,7 @@ dtls1_retransmit_message(SSL *s, unsigned short seq, unsigned long frag_off,
     saved_state.write_hash = s-&gt;write_hash;
     saved_state.compress = s-&gt;compress;
     saved_state.session = s-&gt;session;
-    saved_state.epoch = s-&gt;d1-&gt;w_epoch;
-    saved_state.epoch = s-&gt;d1-&gt;w_epoch;
+    saved_state.epoch = DTLS_RECORD_LAYER_get_w_epoch(&amp;s-&gt;rlayer);
 
     s-&gt;d1-&gt;retransmitting = 1;
 
@@ -1194,15 +1193,8 @@ dtls1_retransmit_message(SSL *s, unsigned short seq, unsigned long frag_off,
     s-&gt;write_hash = frag-&gt;msg_header.saved_retransmit_state.write_hash;
     s-&gt;compress = frag-&gt;msg_header.saved_retransmit_state.compress;
     s-&gt;session = frag-&gt;msg_header.saved_retransmit_state.session;
-    s-&gt;d1-&gt;w_epoch = frag-&gt;msg_header.saved_retransmit_state.epoch;
-
-    if (frag-&gt;msg_header.saved_retransmit_state.epoch ==
-        saved_state.epoch - 1) {
-        memcpy(save_write_sequence, s-&gt;s3-&gt;write_sequence,
-               sizeof(s-&gt;s3-&gt;write_sequence));
-        memcpy(s-&gt;s3-&gt;write_sequence, s-&gt;d1-&gt;last_write_sequence,
-               sizeof(s-&gt;s3-&gt;write_sequence));
-    }
+    DTLS_RECORD_LAYER_set_saved_w_epoch(&amp;s-&gt;rlayer,
+        frag-&gt;msg_header.saved_retransmit_state.epoch);
 
     ret = dtls1_do_write(s, frag-&gt;msg_header.is_ccs ?
                          SSL3_RT_CHANGE_CIPHER_SPEC : SSL3_RT_HANDSHAKE);
@@ -1212,15 +1204,7 @@ dtls1_retransmit_message(SSL *s, unsigned short seq, unsigned long frag_off,
     s-&gt;write_hash = saved_state.write_hash;
     s-&gt;compress = saved_state.compress;
     s-&gt;session = saved_state.session;
-    s-&gt;d1-&gt;w_epoch = saved_state.epoch;
-
-    if (frag-&gt;msg_header.saved_retransmit_state.epoch ==
-        saved_state.epoch - 1) {
-        memcpy(s-&gt;d1-&gt;last_write_sequence, s-&gt;s3-&gt;write_sequence,
-               sizeof(s-&gt;s3-&gt;write_sequence));
-        memcpy(s-&gt;s3-&gt;write_sequence, save_write_sequence,
-               sizeof(s-&gt;s3-&gt;write_sequence));
-    }
+    DTLS_RECORD_LAYER_set_saved_w_epoch(&amp;s-&gt;rlayer, saved_state.epoch);
 
     s-&gt;d1-&gt;retransmitting = 0;
 
@@ -1347,27 +1331,26 @@ int dtls1_shutdown(SSL *s)
 }
 
 #ifndef OPENSSL_NO_HEARTBEATS
-int dtls1_process_heartbeat(SSL *s)
+int dtls1_process_heartbeat(SSL *s, unsigned char *p, unsigned int length)
 {
-    unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;
+    unsigned char *pl;
     unsigned short hbtype;
     unsigned int payload;
     unsigned int padding = 16;  /* Use minimum padding */
 
     if (s-&gt;msg_callback)
         s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT,
-                        &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length,
-                        s, s-&gt;msg_callback_arg);
+                        p, length, s, s-&gt;msg_callback_arg);
 
     /* Read type and payload length first */
-    if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
+    if (1 + 2 + 16 &gt; length)
         return 0;               /* silently discard */
-    if (s-&gt;s3-&gt;rrec.length &gt; SSL3_RT_MAX_PLAIN_LENGTH)
+    if (length &gt; SSL3_RT_MAX_PLAIN_LENGTH)
         return 0;               /* silently discard per RFC 6520 sec. 4 */
 
     hbtype = *p++;
     n2s(p, payload);
-    if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
+    if (1 + 2 + payload + 16 &gt; length)
         return 0;               /* silently discard per RFC 6520 sec. 4 */
     pl = p;
 
diff --git a/ssl/d1_lib.c b/ssl/d1_lib.c
index ad6561c..eac271d 100644
--- a/ssl/d1_lib.c
+++ b/ssl/d1_lib.c
@@ -124,6 +124,10 @@ int dtls1_new(SSL *s)
 {
     DTLS1_STATE *d1;
 
+    if(!DTLS_RECORD_LAYER_new(&amp;s-&gt;rlayer)) {
+        return 0;
+    }
+    
     if (!ssl3_new(s))
         return (0);
     if ((d1 = OPENSSL_malloc(sizeof *d1)) == NULL) {
@@ -132,13 +136,8 @@ int dtls1_new(SSL *s)
     }
     memset(d1, 0, sizeof *d1);
 
-    /* d1-&gt;handshake_epoch=0; */
-
-    d1-&gt;unprocessed_rcds.q = pqueue_new();
-    d1-&gt;processed_rcds.q = pqueue_new();
     d1-&gt;buffered_messages = pqueue_new();
     d1-&gt;sent_messages = pqueue_new();
-    d1-&gt;buffered_app_data.q = pqueue_new();
 
     if (s-&gt;server) {
         d1-&gt;cookie_len = sizeof(s-&gt;d1-&gt;cookie);
@@ -147,19 +146,11 @@ int dtls1_new(SSL *s)
     d1-&gt;link_mtu = 0;
     d1-&gt;mtu = 0;
 
-    if (!d1-&gt;unprocessed_rcds.q || !d1-&gt;processed_rcds.q
-        || !d1-&gt;buffered_messages || !d1-&gt;sent_messages
-        || !d1-&gt;buffered_app_data.q) {
-        if (d1-&gt;unprocessed_rcds.q)
-            pqueue_free(d1-&gt;unprocessed_rcds.q);
-        if (d1-&gt;processed_rcds.q)
-            pqueue_free(d1-&gt;processed_rcds.q);
+    if (!d1-&gt;buffered_messages || !d1-&gt;sent_messages) {
         if (d1-&gt;buffered_messages)
             pqueue_free(d1-&gt;buffered_messages);
         if (d1-&gt;sent_messages)
             pqueue_free(d1-&gt;sent_messages);
-        if (d1-&gt;buffered_app_data.q)
-            pqueue_free(d1-&gt;buffered_app_data.q);
         OPENSSL_free(d1);
         ssl3_free(s);
         return (0);
@@ -174,25 +165,6 @@ static void dtls1_clear_queues(SSL *s)
 {
     pitem *item = NULL;
     hm_fragment *frag = NULL;
-    DTLS1_RECORD_DATA *rdata;
-
-    while ((item = pqueue_pop(s-&gt;d1-&gt;unprocessed_rcds.q)) != NULL) {
-        rdata = (DTLS1_RECORD_DATA *)item-&gt;data;
-        if (rdata-&gt;rbuf.buf) {
-            OPENSSL_free(rdata-&gt;rbuf.buf);
-        }
-        OPENSSL_free(item-&gt;data);
-        pitem_free(item);
-    }
-
-    while ((item = pqueue_pop(s-&gt;d1-&gt;processed_rcds.q)) != NULL) {
-        rdata = (DTLS1_RECORD_DATA *)item-&gt;data;
-        if (rdata-&gt;rbuf.buf) {
-            OPENSSL_free(rdata-&gt;rbuf.buf);
-        }
-        OPENSSL_free(item-&gt;data);
-        pitem_free(item);
-    }
 
     while ((item = pqueue_pop(s-&gt;d1-&gt;buffered_messages)) != NULL) {
         frag = (hm_fragment *)item-&gt;data;
@@ -205,28 +177,18 @@ static void dtls1_clear_queues(SSL *s)
         dtls1_hm_fragment_free(frag);
         pitem_free(item);
     }
-
-    while ((item = pqueue_pop(s-&gt;d1-&gt;buffered_app_data.q)) != NULL) {
-        rdata = (DTLS1_RECORD_DATA *)item-&gt;data;
-        if (rdata-&gt;rbuf.buf) {
-            OPENSSL_free(rdata-&gt;rbuf.buf);
-        }
-        OPENSSL_free(item-&gt;data);
-        pitem_free(item);
-    }
 }
 
 void dtls1_free(SSL *s)
 {
+    DTLS_RECORD_LAYER_free(&amp;s-&gt;rlayer);
+
     ssl3_free(s);
 
     dtls1_clear_queues(s);
 
-    pqueue_free(s-&gt;d1-&gt;unprocessed_rcds.q);
-    pqueue_free(s-&gt;d1-&gt;processed_rcds.q);
     pqueue_free(s-&gt;d1-&gt;buffered_messages);
     pqueue_free(s-&gt;d1-&gt;sent_messages);
-    pqueue_free(s-&gt;d1-&gt;buffered_app_data.q);
 
     OPENSSL_free(s-&gt;d1);
     s-&gt;d1 = NULL;
@@ -234,20 +196,16 @@ void dtls1_free(SSL *s)
 
 void dtls1_clear(SSL *s)
 {
-    pqueue unprocessed_rcds;
-    pqueue processed_rcds;
     pqueue buffered_messages;
     pqueue sent_messages;
-    pqueue buffered_app_data;
     unsigned int mtu;
     unsigned int link_mtu;
 
+    DTLS_RECORD_LAYER_clear(&amp;s-&gt;rlayer);
+
     if (s-&gt;d1) {
-        unprocessed_rcds = s-&gt;d1-&gt;unprocessed_rcds.q;
-        processed_rcds = s-&gt;d1-&gt;processed_rcds.q;
         buffered_messages = s-&gt;d1-&gt;buffered_messages;
         sent_messages = s-&gt;d1-&gt;sent_messages;
-        buffered_app_data = s-&gt;d1-&gt;buffered_app_data.q;
         mtu = s-&gt;d1-&gt;mtu;
         link_mtu = s-&gt;d1-&gt;link_mtu;
 
@@ -264,11 +222,8 @@ void dtls1_clear(SSL *s)
             s-&gt;d1-&gt;link_mtu = link_mtu;
         }
 
-        s-&gt;d1-&gt;unprocessed_rcds.q = unprocessed_rcds;
-        s-&gt;d1-&gt;processed_rcds.q = processed_rcds;
         s-&gt;d1-&gt;buffered_messages = buffered_messages;
         s-&gt;d1-&gt;sent_messages = sent_messages;
-        s-&gt;d1-&gt;buffered_app_data.q = buffered_app_data;
     }
 
     ssl3_clear(s);
diff --git a/crypto/rand/rand_nw.c b/ssl/d1_msg.c
similarity index 68%
copy from crypto/rand/rand_nw.c
copy to ssl/d1_msg.c
index 76ef70c..f71b1cc 100644
--- a/crypto/rand/rand_nw.c
+++ b/ssl/d1_msg.c
@@ -1,4 +1,61 @@
-/* crypto/rand/rand_nw.c */
+/* ssl/d1_msg.c */
+/*
+ * DTLS implementation written by Nagendra Modadugu
+ * (<A HREF="../../../mailman/listinfo/openssl-commits.html">nagendra at cs.stanford.edu</A>) for the OpenSSL project 2005.
+ */
+/* ====================================================================
+ * Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+ *
+ * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+ *    nor may &quot;OpenSSL&quot; appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+ * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+ *
+ */
 /* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
  * All rights reserved.
  *
@@ -55,125 +112,91 @@
  * copied and put under another distribution licence
  * [including the GNU Public Licence.]
  */
-/* ====================================================================
- * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-#include &quot;cryptlib.h&quot;
-#include &lt;openssl/rand.h&gt;
-#include &quot;rand_lcl.h&quot;
-
-#if defined (OPENSSL_SYS_NETWARE)
-
-# if defined(NETWARE_LIBC)
-#  include &lt;nks/thread.h&gt;
-# else
-#  include &lt;nwthread.h&gt;
-# endif
 
-extern int GetProcessSwitchCount(void);
-# if !defined(NETWARE_LIBC) || (CURRENT_NDK_THRESHOLD &lt; 509220000)
-extern void *RunningProcess;    /* declare here same as found in newer NDKs */
-extern unsigned long GetSuperHighResolutionTimer(void);
-# endif
-
-   /*
-    * the FAQ indicates we need to provide at least 20 bytes (160 bits) of
-    * seed
-    */
-int RAND_poll(void)
+#define USE_SOCKETS
+#include &quot;ssl_locl.h&quot;
+    
+int dtls1_write_app_data_bytes(SSL *s, int type, const void *buf_, int len)
 {
-    unsigned long l;
-    unsigned long tsc;
     int i;
 
+#ifndef OPENSSL_NO_SCTP
     /*
-     * There are several options to gather miscellaneous data but for now we
-     * will loop checking the time stamp counter (rdtsc) and the
-     * SuperHighResolutionTimer.  Each iteration will collect 8 bytes of data
-     * but it is treated as only 1 byte of entropy.  The call to
-     * ThreadSwitchWithDelay() will introduce additional variability into the
-     * data returned by rdtsc. Applications can argument the seed material
-     * by adding additional stuff with RAND_add() and should probably do so.
+     * Check if we have to continue an interrupted handshake for reading
+     * belated app data with SCTP.
      */
-    l = GetProcessSwitchCount();
-    RAND_add(&amp;l, sizeof(l), 1);
+    if ((SSL_in_init(s) &amp;&amp; !s-&gt;in_handshake) ||
+        (BIO_dgram_is_sctp(SSL_get_wbio(s)) &amp;&amp;
+         (s-&gt;state == DTLS1_SCTP_ST_SR_READ_SOCK
+          || s-&gt;state == DTLS1_SCTP_ST_CR_READ_SOCK)))
+#else
+    if (SSL_in_init(s) &amp;&amp; !s-&gt;in_handshake)
+#endif
+    {
+        i = s-&gt;handshake_func(s);
+        if (i &lt; 0)
+            return (i);
+        if (i == 0) {
+            SSLerr(SSL_F_DTLS1_WRITE_APP_DATA_BYTES,
+                   SSL_R_SSL_HANDSHAKE_FAILURE);
+            return -1;
+        }
+    }
 
-    /* need to cast the void* to unsigned long here */
-    l = (unsigned long)RunningProcess;
-    RAND_add(&amp;l, sizeof(l), 1);
+    if (len &gt; SSL3_RT_MAX_PLAIN_LENGTH) {
+        SSLerr(SSL_F_DTLS1_WRITE_APP_DATA_BYTES, SSL_R_DTLS_MESSAGE_TOO_BIG);
+        return -1;
+    }
 
-    for (i = 2; i &lt; ENTROPY_NEEDED; i++) {
-# ifdef __MWERKS__
-        asm {
-        rdtsc mov tsc, eax}
-# elif defined(__GNUC__) &amp;&amp; __GNUC__&gt;=2 &amp;&amp; !defined(OPENSSL_NO_ASM) &amp;&amp; !defined(OPENSSL_NO_INLINE_ASM)
-        asm volatile (&quot;rdtsc&quot;:&quot;=a&quot; (tsc)::&quot;edx&quot;);
-# endif
+    i = dtls1_write_bytes(s, type, buf_, len);
+    return i;
+}
 
-        RAND_add(&amp;tsc, sizeof(tsc), 1);
+int dtls1_dispatch_alert(SSL *s)
+{
+    int i, j;
+    void (*cb) (const SSL *ssl, int type, int val) = NULL;
+    unsigned char buf[DTLS1_AL_HEADER_LENGTH];
+    unsigned char *ptr = &amp;buf[0];
 
-        l = GetSuperHighResolutionTimer();
-        RAND_add(&amp;l, sizeof(l), 0);
+    s-&gt;s3-&gt;alert_dispatch = 0;
 
-# if defined(NETWARE_LIBC)
-        NXThreadYield();
-# else                          /* NETWARE_CLIB */
-        ThreadSwitchWithDelay();
-# endif
-    }
+    memset(buf, 0x00, sizeof(buf));
+    *ptr++ = s-&gt;s3-&gt;send_alert[0];
+    *ptr++ = s-&gt;s3-&gt;send_alert[1];
 
-    return 1;
-}
+#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
+    if (s-&gt;s3-&gt;send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE) {
+        s2n(s-&gt;d1-&gt;handshake_read_seq, ptr);
+        l2n3(s-&gt;d1-&gt;r_msg_hdr.frag_off, ptr);
+    }
+#endif
 
+    i = do_dtls1_write(s, SSL3_RT_ALERT, &amp;buf[0], sizeof(buf), 0);
+    if (i &lt;= 0) {
+        s-&gt;s3-&gt;alert_dispatch = 1;
+        /* fprintf( stderr, &quot;not done with alert\n&quot; ); */
+    } else {
+        if (s-&gt;s3-&gt;send_alert[0] == SSL3_AL_FATAL
+#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
+            || s-&gt;s3-&gt;send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
 #endif
+            )
+            (void)BIO_flush(s-&gt;wbio);
+
+        if (s-&gt;msg_callback)
+            s-&gt;msg_callback(1, s-&gt;version, SSL3_RT_ALERT, s-&gt;s3-&gt;send_alert,
+                            2, s, s-&gt;msg_callback_arg);
+
+        if (s-&gt;info_callback != NULL)
+            cb = s-&gt;info_callback;
+        else if (s-&gt;ctx-&gt;info_callback != NULL)
+            cb = s-&gt;ctx-&gt;info_callback;
+
+        if (cb != NULL) {
+            j = (s-&gt;s3-&gt;send_alert[0] &lt;&lt; 8) | s-&gt;s3-&gt;send_alert[1];
+            cb(s, SSL_CB_WRITE_ALERT, j);
+        }
+    }
+    return (i);
+}
diff --git a/ssl/d1_srvr.c b/ssl/d1_srvr.c
index b55af35..5ddfeac 100644
--- a/ssl/d1_srvr.c
+++ b/ssl/d1_srvr.c
@@ -330,8 +330,7 @@ int dtls1_accept(SSL *s)
              * listening
              */
             if (listen) {
-                memcpy(s-&gt;s3-&gt;write_sequence, s-&gt;s3-&gt;read_sequence,
-                       sizeof(s-&gt;s3-&gt;write_sequence));
+                DTLS_RECORD_LAYER_resync_write(&amp;s-&gt;rlayer);
             }
 
             /* If we're just listening, stop here */
diff --git a/ssl/heartbeat_test.c b/ssl/heartbeat_test.c
index d6b7cfc..491bbed 100644
--- a/ssl/heartbeat_test.c
+++ b/ssl/heartbeat_test.c
@@ -60,7 +60,7 @@ typedef struct heartbeat_test_fixture {
     SSL_CTX *ctx;
     SSL *s;
     const char *test_case_name;
-    int (*process_heartbeat) (SSL *s);
+    int (*process_heartbeat) (SSL *s, unsigned char *p, unsigned int length);
     unsigned char *payload;
     int sent_payload_len;
     int expected_return_value;
@@ -112,7 +112,7 @@ static HEARTBEAT_TEST_FIXTURE set_up(const char *const test_case_name,
      * zeroed in opt mode and will cause spurious test failures that will
      * change with each execution.
      */
-    memset(fixture.s-&gt;s3-&gt;wbuf.buf, 0, fixture.s-&gt;s3-&gt;wbuf.len);
+    memset(fixture.s-&gt;rlayer.wbuf.buf, 0, fixture.s-&gt;rlayer.wbuf.len);
 
  fail:
     if (!setup_ok) {
@@ -202,8 +202,8 @@ static int execute_heartbeat(HEARTBEAT_TEST_FIXTURE fixture)
     unsigned const char *p;
     int actual_payload_len;
 
-    s-&gt;s3-&gt;rrec.data = payload;
-    s-&gt;s3-&gt;rrec.length = strlen((const char *)payload);
+    s-&gt;rlayer.rrec.data = payload;
+    s-&gt;rlayer.rrec.length = strlen((const char *)payload);
     *payload++ = TLS1_HB_REQUEST;
     s2n(fixture.sent_payload_len, payload);
 
@@ -213,7 +213,8 @@ static int execute_heartbeat(HEARTBEAT_TEST_FIXTURE fixture)
      */
     memcpy((char *)sent_buf, (const char *)payload, sizeof(sent_buf));
 
-    return_value = fixture.process_heartbeat(s);
+    return_value = fixture.process_heartbeat(s, s-&gt;rlayer.rrec.data,
+        s-&gt;rlayer.rrec.length);
 
     if (return_value != fixture.expected_return_value) {
         printf(&quot;%s failed: expected return value %d, received %d\n&quot;,
@@ -225,8 +226,8 @@ static int execute_heartbeat(HEARTBEAT_TEST_FIXTURE fixture)
     /*
      * If there is any byte alignment, it will be stored in wbuf.offset.
      */
-    p = &amp;(s-&gt;s3-&gt;
-          wbuf.buf[fixture.return_payload_offset + s-&gt;s3-&gt;wbuf.offset]);
+    p = &amp;(s-&gt;rlayer.
+          wbuf.buf[fixture.return_payload_offset + s-&gt;rlayer.wbuf.offset]);
     actual_payload_len = 0;
     n2s(p, actual_payload_len);
 
diff --git a/ssl/record/README b/ssl/record/README
new file mode 100644
index 0000000..6870b53
--- /dev/null
+++ b/ssl/record/README
@@ -0,0 +1,78 @@
+Record Layer Design
+===================
+
+This file provides some guidance on the thinking behind the design of the
+record layer code to aid future maintenance.
+
+The record layer is divided into a number of components. At the time of writing
+there are four: SSL3_RECORD, SSL3_BUFFER, DLTS1_BITMAP and RECORD_LAYER. Each
+of these components is defined by:
+1) A struct definition of the same name as the component
+2) A set of source files that define the functions for that component
+3) A set of accessor macros
+
+All struct definitions are in record.h. The functions and macros are either
+defined in record.h or record_locl.h dependent on whether they are intended to
+be private to the record layer, or whether they form part of the API to the rest
+of libssl.
+
+The source files map to components as follows:
+
+dtls1_bitmap.c                                   -&gt; DTLS1_BITMAP component
+ssl3_buffer.c                                    -&gt; SSL3_BUFFER component
+ssl3_record.c                                    -&gt; SSL3_RECORD component
+rec_layer_s23.c, rec_layer_s3.c, rec_layer_d1.c  -&gt; RECORD_LAYER component
+
+The RECORD_LAYER component is a facade pattern, i.e. it provides a simplified
+interface to the record layer for the rest of libssl. The other 3 components are
+entirely private to the record layer and therefore should never be accessed
+directly by libssl.
+
+Any component can directly access its own members - they are private to that
+component, e.g. ssl3_buffer.c can access members of the SSL3_BUFFER struct
+without using a macro. No component can directly access the members of another
+component, e.g. ssl3_buffer cannot reach inside the RECORD_LAYER component to
+directly access its members. Instead components use accessor macros, so if code
+in ssl3_buffer.c wants to access the members of the RECORD_LAYER it uses the
+RECORD_LAYER_* macros.
+
+Conceptually it looks like this:
+
+                        libssl
+                           |
+---------------------------|-----record.h--------------------------------------
+                           |
+                    _______V______________
+                   |                      |
+                   |    RECORD_LAYER      |
+                   |                      |
+                   |    rec_layer_s23.c   |
+                   |          ^           |
+                   |          |           |
+                   |    rec_layer_s3.c    |
+                   |          ^           |
+                   | _________|__________ |
+                   ||                    ||
+                   || DTLS1_RECORD_LAYER ||
+                   ||                    ||
+                   || rec_layer_d1.c     ||
+                   ||____________________||
+                   |______________________|
+        record_locl.h     ^   ^   ^
+         _________________|   |   |_________________
+        |                     |                     |
+   _____V_________      ______V________      _______V________
+  |               |    |               |    |                |
+  | SSL3_BUFFER   |    | SSL3_RECORD   |    | DTLS1_BITMAP   |
+  |               |---&gt;|               |    |                |
+  | ssl3_buffer.c |    | ssl3_record.c |    | dtls1_bitmap.c |
+  |_______________|    |_______________|    |________________|
+
+
+The three RECORD_LAYER source files build progressively on each other, i.e.
+the simplest is rec_layer_s23.c. This provides the most basic functions used
+for version negotiation. Next rec_layer_s3.c adds the SSL/TLS layer. Finally
+rec_layer_d1.c builds off of the SSL/TLS code to provide DTLS specific
+capabilities. It uses some DTLS specific RECORD_LAYER component members which
+should only be accessed from rec_layer_d1.c. These are held in the
+DTLS1_RECORD_LAYER struct.
diff --git a/apps/app_rand.c b/ssl/record/dtls1_bitmap.c
similarity index 66%
copy from apps/app_rand.c
copy to ssl/record/dtls1_bitmap.c
index 595fc78..9d2d681 100644
--- a/apps/app_rand.c
+++ b/ssl/record/dtls1_bitmap.c
@@ -1,4 +1,61 @@
-/* apps/app_rand.c */
+/* ssl/record/dtls1_bitmap.c */
+/*
+ * DTLS implementation written by Nagendra Modadugu
+ * (<A HREF="../../../mailman/listinfo/openssl-commits.html">nagendra at cs.stanford.edu</A>) for the OpenSSL project 2005.
+ */
+/* ====================================================================
+ * Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+ *
+ * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+ *    nor may &quot;OpenSSL&quot; appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+ * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+ *
+ */
 /* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
  * All rights reserved.
  *
@@ -55,166 +112,107 @@
  * copied and put under another distribution licence
  * [including the GNU Public Licence.]
  */
-/* ====================================================================
- * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-#define NON_MAIN
-#include &quot;apps.h&quot;
-#undef NON_MAIN
-#include &lt;openssl/bio.h&gt;
-#include &lt;openssl/rand.h&gt;
 
-static int seeded = 0;
-static int egdsocket = 0;
+#include &quot;../ssl_locl.h&quot;
+#include &quot;record_locl.h&quot;
 
-int app_RAND_load_file(const char *file, BIO *bio_e, int dont_warn)
+/* mod 128 saturating subtract of two 64-bit values in big-endian order */
+static int satsub64be(const unsigned char *v1, const unsigned char *v2)
 {
-    int consider_randfile = (file == NULL);
-    char buffer[200];
-
-#ifdef OPENSSL_SYS_WINDOWS
-    BIO_printf(bio_e, &quot;Loading 'screen' into random state -&quot;);
-    BIO_flush(bio_e);
-    RAND_screen();
-    BIO_printf(bio_e, &quot; done\n&quot;);
-#endif
+    int ret, sat, brw, i;
 
-    if (file == NULL)
-        file = RAND_file_name(buffer, sizeof buffer);
-    else if (RAND_egd(file) &gt; 0) {
-        /*
-         * we try if the given filename is an EGD socket. if it is, we don't
-         * write anything back to the file.
-         */
-        egdsocket = 1;
-        return 1;
-    }
-    if (file == NULL || !RAND_load_file(file, -1)) {
-        if (RAND_status() == 0) {
-            if (!dont_warn) {
-                BIO_printf(bio_e, &quot;unable to load 'random state'\n&quot;);
-                BIO_printf(bio_e,
-                           &quot;This means that the random number generator has not been seeded\n&quot;);
-                BIO_printf(bio_e, &quot;with much random data.\n&quot;);
-                if (consider_randfile) { /* explanation does not apply when a
-                                          * file is explicitly named */
-                    BIO_printf(bio_e,
-                               &quot;Consider setting the RANDFILE environment variable to point at a file that\n&quot;);
-                    BIO_printf(bio_e,
-                               &quot;'random' data can be kept in (the file will be overwritten).\n&quot;);
-                }
-            }
-            return 0;
-        }
-    }
-    seeded = 1;
-    return 1;
-}
+    if (sizeof(long) == 8)
+        do {
+            const union {
+                long one;
+                char little;
+            } is_endian = {
+                1
+            };
+            long l;
 
-long app_RAND_load_files(char *name)
-{
-    char *p, *n;
-    int last;
-    long tot = 0;
-    int egd;
+            if (is_endian.little)
+                break;
+            /* not reached on little-endians */
+            /*
+             * following test is redundant, because input is always aligned,
+             * but I take no chances...
+             */
+            if (((size_t)v1 | (size_t)v2) &amp; 0x7)
+                break;
 
-    for (;;) {
-        last = 0;
-        for (p = name; ((*p != '\0') &amp;&amp; (*p != LIST_SEPARATOR_CHAR)); p++) ;
-        if (*p == '\0')
-            last = 1;
-        *p = '\0';
-        n = name;
-        name = p + 1;
-        if (*n == '\0')
-            break;
+            l = *((long *)v1);
+            l -= *((long *)v2);
+            if (l &gt; 128)
+                return 128;
+            else if (l &lt; -128)
+                return -128;
+            else
+                return (int)l;
+        } while (0);
 
-        egd = RAND_egd(n);
-        if (egd &gt; 0)
-            tot += egd;
-        else
-            tot += RAND_load_file(n, -1);
-        if (last)
-            break;
+    ret = (int)v1[7] - (int)v2[7];
+    sat = 0;
+    brw = ret &gt;&gt; 8;             /* brw is either 0 or -1 */
+    if (ret &amp; 0x80) {
+        for (i = 6; i &gt;= 0; i--) {
+            brw += (int)v1[i] - (int)v2[i];
+            sat |= ~brw;
+            brw &gt;&gt;= 8;
+        }
+    } else {
+        for (i = 6; i &gt;= 0; i--) {
+            brw += (int)v1[i] - (int)v2[i];
+            sat |= brw;
+            brw &gt;&gt;= 8;
+        }
     }
-    if (tot &gt; 512)
-        app_RAND_allow_write_file();
-    return (tot);
+    brw &lt;&lt;= 8;                  /* brw is either 0 or -256 */
+
+    if (sat &amp; 0xff)
+        return brw | 0x80;
+    else
+        return brw + (ret &amp; 0xFF);
 }
 
-int app_RAND_write_file(const char *file, BIO *bio_e)
+int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap)
 {
-    char buffer[200];
+    int cmp;
+    unsigned int shift;
+    const unsigned char *seq = s-&gt;rlayer.read_sequence;
 
-    if (egdsocket || !seeded)
-        /*
-         * If we did not manage to read the seed file, we should not write a
-         * low-entropy seed file back -- it would suppress a crucial warning
-         * the next time we want to use it.
-         */
-        return 0;
-
-    if (file == NULL)
-        file = RAND_file_name(buffer, sizeof buffer);
-    if (file == NULL || !RAND_write_file(file)) {
-        BIO_printf(bio_e, &quot;unable to write 'random state'\n&quot;);
-        return 0;
+    cmp = satsub64be(seq, bitmap-&gt;max_seq_num);
+    if (cmp &gt; 0) {
+        SSL3_RECORD_set_seq_num(RECORD_LAYER_get_rrec(&amp;s-&gt;rlayer), seq);
+        return 1;               /* this record in new */
     }
+    shift = -cmp;
+    if (shift &gt;= sizeof(bitmap-&gt;map) * 8)
+        return 0;               /* stale, outside the window */
+    else if (bitmap-&gt;map &amp; (1UL &lt;&lt; shift))
+        return 0;               /* record previously received */
+
+    SSL3_RECORD_set_seq_num(RECORD_LAYER_get_rrec(&amp;s-&gt;rlayer), seq);
     return 1;
 }
 
-void app_RAND_allow_write_file(void)
+void dtls1_record_bitmap_update(SSL *s, DTLS1_BITMAP *bitmap)
 {
-    seeded = 1;
+    int cmp;
+    unsigned int shift;
+    const unsigned char *seq = RECORD_LAYER_get_read_sequence(&amp;s-&gt;rlayer);
+
+    cmp = satsub64be(seq, bitmap-&gt;max_seq_num);
+    if (cmp &gt; 0) {
+        shift = cmp;
+        if (shift &lt; sizeof(bitmap-&gt;map) * 8)
+            bitmap-&gt;map &lt;&lt;= shift, bitmap-&gt;map |= 1UL;
+        else
+            bitmap-&gt;map = 1UL;
+        memcpy(bitmap-&gt;max_seq_num, seq, SEQ_NUM_SIZE);
+    } else {
+        shift = -cmp;
+        if (shift &lt; sizeof(bitmap-&gt;map) * 8)
+            bitmap-&gt;map |= 1UL &lt;&lt; shift;
+    }
 }
diff --git a/ssl/d1_pkt.c b/ssl/record/rec_layer_d1.c
similarity index 62%
rename from ssl/d1_pkt.c
rename to ssl/record/rec_layer_d1.c
index 19e60b7..80f10be 100644
--- a/ssl/d1_pkt.c
+++ b/ssl/record/rec_layer_d1.c
@@ -1,4 +1,4 @@
-/* ssl/d1_pkt.c */
+/* ssl/record/rec_layer_d1.c */
 /*
  * DTLS implementation written by Nagendra Modadugu
  * (<A HREF="../../../mailman/listinfo/openssl-commits.html">nagendra at cs.stanford.edu</A>) for the OpenSSL project 2005.
@@ -116,80 +116,128 @@
 #include &lt;stdio.h&gt;
 #include &lt;errno.h&gt;
 #define USE_SOCKETS
-#include &quot;ssl_locl.h&quot;
+#include &quot;../ssl_locl.h&quot;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/buffer.h&gt;
 #include &lt;openssl/pqueue.h&gt;
 #include &lt;openssl/rand.h&gt;
+#include &quot;record_locl.h&quot;
 
-/* mod 128 saturating subtract of two 64-bit values in big-endian order */
-static int satsub64be(const unsigned char *v1, const unsigned char *v2)
+int DTLS_RECORD_LAYER_new(RECORD_LAYER *rl)
 {
-    int ret, sat, brw, i;
-
-    if (sizeof(long) == 8)
-        do {
-            const union {
-                long one;
-                char little;
-            } is_endian = {
-                1
-            };
-            long l;
-
-            if (is_endian.little)
-                break;
-            /* not reached on little-endians */
-            /*
-             * following test is redundant, because input is always aligned,
-             * but I take no chances...
-             */
-            if (((size_t)v1 | (size_t)v2) &amp; 0x7)
-                break;
-
-            l = *((long *)v1);
-            l -= *((long *)v2);
-            if (l &gt; 128)
-                return 128;
-            else if (l &lt; -128)
-                return -128;
-            else
-                return (int)l;
-        } while (0);
-
-    ret = (int)v1[7] - (int)v2[7];
-    sat = 0;
-    brw = ret &gt;&gt; 8;             /* brw is either 0 or -1 */
-    if (ret &amp; 0x80) {
-        for (i = 6; i &gt;= 0; i--) {
-            brw += (int)v1[i] - (int)v2[i];
-            sat |= ~brw;
-            brw &gt;&gt;= 8;
+    DTLS_RECORD_LAYER *d;
+    
+    if ((d = OPENSSL_malloc(sizeof *d)) == NULL) {
+        return (0);
+    }
+
+
+    rl-&gt;d = d;
+
+    d-&gt;unprocessed_rcds.q = pqueue_new();
+    d-&gt;processed_rcds.q = pqueue_new();
+    d-&gt;buffered_app_data.q = pqueue_new();
+
+    if (!d-&gt;unprocessed_rcds.q || !d-&gt;processed_rcds.q
+        || !d-&gt;buffered_app_data.q) {
+        if (d-&gt;unprocessed_rcds.q)
+            pqueue_free(d-&gt;unprocessed_rcds.q);
+        if (d-&gt;processed_rcds.q)
+            pqueue_free(d-&gt;processed_rcds.q);
+        if (d-&gt;buffered_app_data.q)
+            pqueue_free(d-&gt;buffered_app_data.q);
+        OPENSSL_free(d);
+        rl-&gt;d = NULL;
+        return (0);
+    }
+
+    return 1;
+}
+
+void DTLS_RECORD_LAYER_free(RECORD_LAYER *rl)
+{
+    DTLS_RECORD_LAYER_clear(rl);
+    pqueue_free(rl-&gt;d-&gt;unprocessed_rcds.q);
+    pqueue_free(rl-&gt;d-&gt;processed_rcds.q);
+    pqueue_free(rl-&gt;d-&gt;buffered_app_data.q);
+    OPENSSL_free(rl-&gt;d);
+    rl-&gt;d = NULL;
+}
+
+void DTLS_RECORD_LAYER_clear(RECORD_LAYER *rl)
+{
+    DTLS_RECORD_LAYER *d;
+    pitem *item = NULL;
+    DTLS1_RECORD_DATA *rdata;
+    pqueue unprocessed_rcds;
+    pqueue processed_rcds;
+    pqueue buffered_app_data;
+
+    d = rl-&gt;d;
+    
+    while ((item = pqueue_pop(d-&gt;unprocessed_rcds.q)) != NULL) {
+        rdata = (DTLS1_RECORD_DATA *)item-&gt;data;
+        if (rdata-&gt;rbuf.buf) {
+            OPENSSL_free(rdata-&gt;rbuf.buf);
         }
-    } else {
-        for (i = 6; i &gt;= 0; i--) {
-            brw += (int)v1[i] - (int)v2[i];
-            sat |= brw;
-            brw &gt;&gt;= 8;
+        OPENSSL_free(item-&gt;data);
+        pitem_free(item);
+    }
+
+    while ((item = pqueue_pop(d-&gt;processed_rcds.q)) != NULL) {
+        rdata = (DTLS1_RECORD_DATA *)item-&gt;data;
+        if (rdata-&gt;rbuf.buf) {
+            OPENSSL_free(rdata-&gt;rbuf.buf);
         }
+        OPENSSL_free(item-&gt;data);
+        pitem_free(item);
     }
-    brw &lt;&lt;= 8;                  /* brw is either 0 or -256 */
 
-    if (sat &amp; 0xff)
-        return brw | 0x80;
-    else
-        return brw + (ret &amp; 0xFF);
+    while ((item = pqueue_pop(d-&gt;buffered_app_data.q)) != NULL) {
+        rdata = (DTLS1_RECORD_DATA *)item-&gt;data;
+        if (rdata-&gt;rbuf.buf) {
+            OPENSSL_free(rdata-&gt;rbuf.buf);
+        }
+        OPENSSL_free(item-&gt;data);
+        pitem_free(item);
+    }
+
+    unprocessed_rcds = d-&gt;unprocessed_rcds.q;
+    processed_rcds = d-&gt;processed_rcds.q;
+    buffered_app_data = d-&gt;buffered_app_data.q;
+    memset(d, 0, sizeof *d);
+    d-&gt;unprocessed_rcds.q = unprocessed_rcds;
+    d-&gt;processed_rcds.q = processed_rcds;
+    d-&gt;buffered_app_data.q = buffered_app_data;
+}
+
+void DTLS_RECORD_LAYER_set_saved_w_epoch(RECORD_LAYER *rl, unsigned short e)
+{
+    if (e == rl-&gt;d-&gt;w_epoch - 1) {
+        memcpy(rl-&gt;d-&gt;curr_write_sequence,
+               rl-&gt;write_sequence,
+               sizeof(rl-&gt;write_sequence));
+        memcpy(rl-&gt;write_sequence,
+               rl-&gt;d-&gt;last_write_sequence,
+               sizeof(rl-&gt;write_sequence));
+    } else if (e == rl-&gt;d-&gt;w_epoch + 1) {
+        memcpy(rl-&gt;d-&gt;last_write_sequence,
+               rl-&gt;write_sequence,
+               sizeof(unsigned char[8]));
+        memcpy(rl-&gt;write_sequence,
+               rl-&gt;d-&gt;curr_write_sequence,
+               sizeof(rl-&gt;write_sequence));
+    }
+    rl-&gt;d-&gt;w_epoch = e;
+}
+
+void DTLS_RECORD_LAYER_resync_write(RECORD_LAYER *rl)
+{
+    memcpy(rl-&gt;write_sequence, rl-&gt;read_sequence, sizeof(rl-&gt;write_sequence));
 }
 
 static int have_handshake_fragment(SSL *s, int type, unsigned char *buf,
                                    int len, int peek);
-static int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap);
-static void dtls1_record_bitmap_update(SSL *s, DTLS1_BITMAP *bitmap);
-static DTLS1_BITMAP *dtls1_get_bitmap(SSL *s, SSL3_RECORD *rr,
-                                      unsigned int *is_next_epoch);
-static int dtls1_buffer_record(SSL *s, record_pqueue *q,
-                               unsigned char *priority);
-static int dtls1_process_record(SSL *s);
 
 /* copy buffered record into SSL structure */
 static int dtls1_copy_record(SSL *s, pitem *item)
@@ -198,22 +246,20 @@ static int dtls1_copy_record(SSL *s, pitem *item)
 
     rdata = (DTLS1_RECORD_DATA *)item-&gt;data;
 
-    if (s-&gt;s3-&gt;rbuf.buf != NULL)
-        OPENSSL_free(s-&gt;s3-&gt;rbuf.buf);
+    SSL3_BUFFER_release(&amp;s-&gt;rlayer.rbuf);
 
-    s-&gt;packet = rdata-&gt;packet;
-    s-&gt;packet_length = rdata-&gt;packet_length;
-    memcpy(&amp;(s-&gt;s3-&gt;rbuf), &amp;(rdata-&gt;rbuf), sizeof(SSL3_BUFFER));
-    memcpy(&amp;(s-&gt;s3-&gt;rrec), &amp;(rdata-&gt;rrec), sizeof(SSL3_RECORD));
+    s-&gt;rlayer.packet = rdata-&gt;packet;
+    s-&gt;rlayer.packet_length = rdata-&gt;packet_length;
+    memcpy(&amp;s-&gt;rlayer.rbuf, &amp;(rdata-&gt;rbuf), sizeof(SSL3_BUFFER));
+    memcpy(&amp;s-&gt;rlayer.rrec, &amp;(rdata-&gt;rrec), sizeof(SSL3_RECORD));
 
     /* Set proper sequence number for mac calculation */
-    memcpy(&amp;(s-&gt;s3-&gt;read_sequence[2]), &amp;(rdata-&gt;packet[5]), 6);
+    memcpy(&amp;(s-&gt;rlayer.read_sequence[2]), &amp;(rdata-&gt;packet[5]), 6);
 
     return (1);
 }
 
-static int
-dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)
+int dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)
 {
     DTLS1_RECORD_DATA *rdata;
     pitem *item;
@@ -234,10 +280,10 @@ dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)
         return -1;
     }
 
-    rdata-&gt;packet = s-&gt;packet;
-    rdata-&gt;packet_length = s-&gt;packet_length;
-    memcpy(&amp;(rdata-&gt;rbuf), &amp;(s-&gt;s3-&gt;rbuf), sizeof(SSL3_BUFFER));
-    memcpy(&amp;(rdata-&gt;rrec), &amp;(s-&gt;s3-&gt;rrec), sizeof(SSL3_RECORD));
+    rdata-&gt;packet = s-&gt;rlayer.packet;
+    rdata-&gt;packet_length = s-&gt;rlayer.packet_length;
+    memcpy(&amp;(rdata-&gt;rbuf), &amp;s-&gt;rlayer.rbuf, sizeof(SSL3_BUFFER));
+    memcpy(&amp;(rdata-&gt;rrec), &amp;s-&gt;rlayer.rrec, sizeof(SSL3_RECORD));
 
     item-&gt;data = rdata;
 
@@ -251,10 +297,10 @@ dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)
     }
 #endif
 
-    s-&gt;packet = NULL;
-    s-&gt;packet_length = 0;
-    memset(&amp;(s-&gt;s3-&gt;rbuf), 0, sizeof(SSL3_BUFFER));
-    memset(&amp;(s-&gt;s3-&gt;rrec), 0, sizeof(SSL3_RECORD));
+    s-&gt;rlayer.packet = NULL;
+    s-&gt;rlayer.packet_length = 0;
+    memset(&amp;s-&gt;rlayer.rbuf, 0, sizeof(SSL3_BUFFER));
+    memset(&amp;s-&gt;rlayer.rrec, 0, sizeof(SSL3_RECORD));
 
     if (!ssl3_setup_buffers(s)) {
         SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);
@@ -278,7 +324,7 @@ dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)
     return (1);
 }
 
-static int dtls1_retrieve_buffered_record(SSL *s, record_pqueue *queue)
+int dtls1_retrieve_buffered_record(SSL *s, record_pqueue *queue)
 {
     pitem *item;
 
@@ -301,33 +347,26 @@ static int dtls1_retrieve_buffered_record(SSL *s, record_pqueue *queue)
  */
 #define dtls1_get_unprocessed_record(s) \
                    dtls1_retrieve_buffered_record((s), \
-                   &amp;((s)-&gt;d1-&gt;unprocessed_rcds))
+                   &amp;((s)-&gt;rlayer.d-&gt;unprocessed_rcds))
 
-/*
- * retrieve a buffered record that belongs to the current epoch, ie,
- * processed
- */
-#define dtls1_get_processed_record(s) \
-                   dtls1_retrieve_buffered_record((s), \
-                   &amp;((s)-&gt;d1-&gt;processed_rcds))
 
-static int dtls1_process_buffered_records(SSL *s)
+int dtls1_process_buffered_records(SSL *s)
 {
     pitem *item;
 
-    item = pqueue_peek(s-&gt;d1-&gt;unprocessed_rcds.q);
+    item = pqueue_peek(s-&gt;rlayer.d-&gt;unprocessed_rcds.q);
     if (item) {
         /* Check if epoch is current. */
-        if (s-&gt;d1-&gt;unprocessed_rcds.epoch != s-&gt;d1-&gt;r_epoch)
+        if (s-&gt;rlayer.d-&gt;unprocessed_rcds.epoch != s-&gt;rlayer.d-&gt;r_epoch)
             return (1);         /* Nothing to do. */
 
         /* Process all the records. */
-        while (pqueue_peek(s-&gt;d1-&gt;unprocessed_rcds.q)) {
+        while (pqueue_peek(s-&gt;rlayer.d-&gt;unprocessed_rcds.q)) {
             dtls1_get_unprocessed_record(s);
             if (!dtls1_process_record(s))
                 return (0);
-            if (dtls1_buffer_record(s, &amp;(s-&gt;d1-&gt;processed_rcds),
-                                    s-&gt;s3-&gt;rrec.seq_num) &lt; 0)
+            if (dtls1_buffer_record(s, &amp;(s-&gt;rlayer.d-&gt;processed_rcds),
+                SSL3_RECORD_get_seq_num(&amp;s-&gt;rlayer.rrec)) &lt; 0)
                 return -1;
         }
     }
@@ -336,356 +375,12 @@ static int dtls1_process_buffered_records(SSL *s)
      * sync epoch numbers once all the unprocessed records have been
      * processed
      */
-    s-&gt;d1-&gt;processed_rcds.epoch = s-&gt;d1-&gt;r_epoch;
-    s-&gt;d1-&gt;unprocessed_rcds.epoch = s-&gt;d1-&gt;r_epoch + 1;
+    s-&gt;rlayer.d-&gt;processed_rcds.epoch = s-&gt;rlayer.d-&gt;r_epoch;
+    s-&gt;rlayer.d-&gt;unprocessed_rcds.epoch = s-&gt;rlayer.d-&gt;r_epoch + 1;
 
     return (1);
 }
 
-static int dtls1_process_record(SSL *s)
-{
-    int i, al;
-    int enc_err;
-    SSL_SESSION *sess;
-    SSL3_RECORD *rr;
-    unsigned int mac_size;
-    unsigned char md[EVP_MAX_MD_SIZE];
-
-    rr = &amp;(s-&gt;s3-&gt;rrec);
-    sess = s-&gt;session;
-
-    /*
-     * At this point, s-&gt;packet_length == SSL3_RT_HEADER_LNGTH + rr-&gt;length,
-     * and we have that many bytes in s-&gt;packet
-     */
-    rr-&gt;input = &amp;(s-&gt;packet[DTLS1_RT_HEADER_LENGTH]);
-
-    /*
-     * ok, we can now read from 's-&gt;packet' data into 'rr' rr-&gt;input points
-     * at rr-&gt;length bytes, which need to be copied into rr-&gt;data by either
-     * the decryption or by the decompression When the data is 'copied' into
-     * the rr-&gt;data buffer, rr-&gt;input will be pointed at the new buffer
-     */
-
-    /*
-     * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr-&gt;length
-     * bytes of encrypted compressed stuff.
-     */
-
-    /* check is not needed I believe */
-    if (rr-&gt;length &gt; SSL3_RT_MAX_ENCRYPTED_LENGTH) {
-        al = SSL_AD_RECORD_OVERFLOW;
-        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
-        goto f_err;
-    }
-
-    /* decrypt in place in 'rr-&gt;input' */
-    rr-&gt;data = rr-&gt;input;
-    rr-&gt;orig_len = rr-&gt;length;
-
-    enc_err = s-&gt;method-&gt;ssl3_enc-&gt;enc(s, 0);
-    /*-
-     * enc_err is:
-     *    0: (in non-constant time) if the record is publically invalid.
-     *    1: if the padding is valid
-     *   -1: if the padding is invalid
-     */
-    if (enc_err == 0) {
-        /* For DTLS we simply ignore bad packets. */
-        rr-&gt;length = 0;
-        s-&gt;packet_length = 0;
-        goto err;
-    }
-#ifdef TLS_DEBUG
-    printf(&quot;dec %d\n&quot;, rr-&gt;length);
-    {
-        unsigned int z;
-        for (z = 0; z &lt; rr-&gt;length; z++)
-            printf(&quot;%02X%c&quot;, rr-&gt;data[z], ((z + 1) % 16) ? ' ' : '\n');
-    }
-    printf(&quot;\n&quot;);
-#endif
-
-    /* r-&gt;length is now the compressed data plus mac */
-    if ((sess != NULL) &amp;&amp;
-        (s-&gt;enc_read_ctx != NULL) &amp;&amp; (EVP_MD_CTX_md(s-&gt;read_hash) != NULL)) {
-        /* s-&gt;read_hash != NULL =&gt; mac_size != -1 */
-        unsigned char *mac = NULL;
-        unsigned char mac_tmp[EVP_MAX_MD_SIZE];
-        mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
-        OPENSSL_assert(mac_size &lt;= EVP_MAX_MD_SIZE);
-
-        /*
-         * orig_len is the length of the record before any padding was
-         * removed. This is public information, as is the MAC in use,
-         * therefore we can safely process the record in a different amount
-         * of time if it's too short to possibly contain a MAC.
-         */
-        if (rr-&gt;orig_len &lt; mac_size ||
-            /* CBC records must have a padding length byte too. */
-            (EVP_CIPHER_CTX_mode(s-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE &amp;&amp;
-             rr-&gt;orig_len &lt; mac_size + 1)) {
-            al = SSL_AD_DECODE_ERROR;
-            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT);
-            goto f_err;
-        }
-
-        if (EVP_CIPHER_CTX_mode(s-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE) {
-            /*
-             * We update the length so that the TLS header bytes can be
-             * constructed correctly but we need to extract the MAC in
-             * constant time from within the record, without leaking the
-             * contents of the padding bytes.
-             */
-            mac = mac_tmp;
-            ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);
-            rr-&gt;length -= mac_size;
-        } else {
-            /*
-             * In this case there's no padding, so |rec-&gt;orig_len| equals
-             * |rec-&gt;length| and we checked that there's enough bytes for
-             * |mac_size| above.
-             */
-            rr-&gt;length -= mac_size;
-            mac = &amp;rr-&gt;data[rr-&gt;length];
-        }
-
-        i = s-&gt;method-&gt;ssl3_enc-&gt;mac(s, md, 0 /* not send */ );
-        if (i &lt; 0 || mac == NULL
-            || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
-            enc_err = -1;
-        if (rr-&gt;length &gt; SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)
-            enc_err = -1;
-    }
-
-    if (enc_err &lt; 0) {
-        /* decryption failed, silently discard message */
-        rr-&gt;length = 0;
-        s-&gt;packet_length = 0;
-        goto err;
-    }
-
-    /* r-&gt;length is now just compressed */
-    if (s-&gt;expand != NULL) {
-        if (rr-&gt;length &gt; SSL3_RT_MAX_COMPRESSED_LENGTH) {
-            al = SSL_AD_RECORD_OVERFLOW;
-            SSLerr(SSL_F_DTLS1_PROCESS_RECORD,
-                   SSL_R_COMPRESSED_LENGTH_TOO_LONG);
-            goto f_err;
-        }
-        if (!ssl3_do_uncompress(s)) {
-            al = SSL_AD_DECOMPRESSION_FAILURE;
-            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_BAD_DECOMPRESSION);
-            goto f_err;
-        }
-    }
-
-    if (rr-&gt;length &gt; SSL3_RT_MAX_PLAIN_LENGTH) {
-        al = SSL_AD_RECORD_OVERFLOW;
-        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);
-        goto f_err;
-    }
-
-    rr-&gt;off = 0;
-    /*-
-     * So at this point the following is true
-     * ssl-&gt;s3-&gt;rrec.type   is the type of record
-     * ssl-&gt;s3-&gt;rrec.length == number of bytes in record
-     * ssl-&gt;s3-&gt;rrec.off    == offset to first valid byte
-     * ssl-&gt;s3-&gt;rrec.data   == where to take bytes from, increment
-     *                         after use :-).
-     */
-
-    /* we have pulled in a full packet so zero things */
-    s-&gt;packet_length = 0;
-    return (1);
-
- f_err:
-    ssl3_send_alert(s, SSL3_AL_FATAL, al);
- err:
-    return (0);
-}
-
-/*-
- * Call this to get a new input record.
- * It will return &lt;= 0 if more data is needed, normally due to an error
- * or non-blocking IO.
- * When it finishes, one packet has been decoded and can be found in
- * ssl-&gt;s3-&gt;rrec.type    - is the type of record
- * ssl-&gt;s3-&gt;rrec.data,   - data
- * ssl-&gt;s3-&gt;rrec.length, - number of bytes
- */
-/* used only by dtls1_read_bytes */
-int dtls1_get_record(SSL *s)
-{
-    int ssl_major, ssl_minor;
-    int i, n;
-    SSL3_RECORD *rr;
-    unsigned char *p = NULL;
-    unsigned short version;
-    DTLS1_BITMAP *bitmap;
-    unsigned int is_next_epoch;
-
-    rr = &amp;(s-&gt;s3-&gt;rrec);
-
-    /*
-     * The epoch may have changed.  If so, process all the pending records.
-     * This is a non-blocking operation.
-     */
-    if (dtls1_process_buffered_records(s) &lt; 0)
-        return -1;
-
-    /* if we're renegotiating, then there may be buffered records */
-    if (dtls1_get_processed_record(s))
-        return 1;
-
-    /* get something from the wire */
- again:
-    /* check if we have the header */
-    if ((s-&gt;rstate != SSL_ST_READ_BODY) ||
-        (s-&gt;packet_length &lt; DTLS1_RT_HEADER_LENGTH)) {
-        n = ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s-&gt;s3-&gt;rbuf.len, 0);
-        /* read timeout is handled by dtls1_read_bytes */
-        if (n &lt;= 0)
-            return (n);         /* error or non-blocking */
-
-        /* this packet contained a partial record, dump it */
-        if (s-&gt;packet_length != DTLS1_RT_HEADER_LENGTH) {
-            s-&gt;packet_length = 0;
-            goto again;
-        }
-
-        s-&gt;rstate = SSL_ST_READ_BODY;
-
-        p = s-&gt;packet;
-
-        if (s-&gt;msg_callback)
-            s-&gt;msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH,
-                            s, s-&gt;msg_callback_arg);
-
-        /* Pull apart the header into the DTLS1_RECORD */
-        rr-&gt;type = *(p++);
-        ssl_major = *(p++);
-        ssl_minor = *(p++);
-        version = (ssl_major &lt;&lt; 8) | ssl_minor;
-
-        /* sequence number is 64 bits, with top 2 bytes = epoch */
-        n2s(p, rr-&gt;epoch);
-
-        memcpy(&amp;(s-&gt;s3-&gt;read_sequence[2]), p, 6);
-        p += 6;
-
-        n2s(p, rr-&gt;length);
-
-        /* Lets check version */
-        if (!s-&gt;first_packet) {
-            if (version != s-&gt;version) {
-                /* unexpected version, silently discard */
-                rr-&gt;length = 0;
-                s-&gt;packet_length = 0;
-                goto again;
-            }
-        }
-
-        if ((version &amp; 0xff00) != (s-&gt;version &amp; 0xff00)) {
-            /* wrong version, silently discard record */
-            rr-&gt;length = 0;
-            s-&gt;packet_length = 0;
-            goto again;
-        }
-
-        if (rr-&gt;length &gt; SSL3_RT_MAX_ENCRYPTED_LENGTH) {
-            /* record too long, silently discard it */
-            rr-&gt;length = 0;
-            s-&gt;packet_length = 0;
-            goto again;
-        }
-
-        /* now s-&gt;rstate == SSL_ST_READ_BODY */
-    }
-
-    /* s-&gt;rstate == SSL_ST_READ_BODY, get and decode the data */
-
-    if (rr-&gt;length &gt; s-&gt;packet_length - DTLS1_RT_HEADER_LENGTH) {
-        /* now s-&gt;packet_length == DTLS1_RT_HEADER_LENGTH */
-        i = rr-&gt;length;
-        n = ssl3_read_n(s, i, i, 1);
-        /* this packet contained a partial record, dump it */
-        if (n != i) {
-            rr-&gt;length = 0;
-            s-&gt;packet_length = 0;
-            goto again;
-        }
-
-        /*
-         * now n == rr-&gt;length, and s-&gt;packet_length ==
-         * DTLS1_RT_HEADER_LENGTH + rr-&gt;length
-         */
-    }
-    s-&gt;rstate = SSL_ST_READ_HEADER; /* set state for later operations */
-
-    /* match epochs.  NULL means the packet is dropped on the floor */
-    bitmap = dtls1_get_bitmap(s, rr, &amp;is_next_epoch);
-    if (bitmap == NULL) {
-        rr-&gt;length = 0;
-        s-&gt;packet_length = 0;   /* dump this record */
-        goto again;             /* get another record */
-    }
-#ifndef OPENSSL_NO_SCTP
-    /* Only do replay check if no SCTP bio */
-    if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {
-#endif
-        /*
-         * Check whether this is a repeat, or aged record. Don't check if
-         * we're listening and this message is a ClientHello. They can look
-         * as if they're replayed, since they arrive from different
-         * connections and would be dropped unnecessarily.
-         */
-        if (!(s-&gt;d1-&gt;listen &amp;&amp; rr-&gt;type == SSL3_RT_HANDSHAKE &amp;&amp;
-              s-&gt;packet_length &gt; DTLS1_RT_HEADER_LENGTH &amp;&amp;
-              s-&gt;packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &amp;&amp;
-            !dtls1_record_replay_check(s, bitmap)) {
-            rr-&gt;length = 0;
-            s-&gt;packet_length = 0; /* dump this record */
-            goto again;         /* get another record */
-        }
-#ifndef OPENSSL_NO_SCTP
-    }
-#endif
-
-    /* just read a 0 length packet */
-    if (rr-&gt;length == 0)
-        goto again;
-
-    /*
-     * If this record is from the next epoch (either HM or ALERT), and a
-     * handshake is currently in progress, buffer it since it cannot be
-     * processed at this time. However, do not buffer anything while
-     * listening.
-     */
-    if (is_next_epoch) {
-        if ((SSL_in_init(s) || s-&gt;in_handshake) &amp;&amp; !s-&gt;d1-&gt;listen) {
-            if (dtls1_buffer_record
-                (s, &amp;(s-&gt;d1-&gt;unprocessed_rcds), rr-&gt;seq_num) &lt; 0)
-                return -1;
-            /* Mark receipt of record. */
-            dtls1_record_bitmap_update(s, bitmap);
-        }
-        rr-&gt;length = 0;
-        s-&gt;packet_length = 0;
-        goto again;
-    }
-
-    if (!dtls1_process_record(s)) {
-        rr-&gt;length = 0;
-        s-&gt;packet_length = 0;   /* dump this record */
-        goto again;             /* get another record */
-    }
-    dtls1_record_bitmap_update(s, bitmap); /* Mark receipt of record. */
-
-    return (1);
-
-}
 
 /*-
  * Return up to 'len' payload bytes received in 'type' records.
@@ -722,9 +417,11 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
     SSL3_RECORD *rr;
     void (*cb) (const SSL *ssl, int type2, int val) = NULL;
 
-    if (s-&gt;s3-&gt;rbuf.buf == NULL) /* Not initialized yet */
+    if (!SSL3_BUFFER_is_initialised(&amp;s-&gt;rlayer.rbuf)) {
+        /* Not initialized yet */
         if (!ssl3_setup_buffers(s))
             return (-1);
+    }
 
     if ((type &amp;&amp; (type != SSL3_RT_APPLICATION_DATA) &amp;&amp;
          (type != SSL3_RT_HANDSHAKE)) ||
@@ -740,7 +437,8 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
         return ret;
 
     /*
-     * Now s-&gt;d1-&gt;handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE.
+     * Now s-&gt;rlayer.d-&gt;handshake_fragment_len == 0 if
+     * type == SSL3_RT_HANDSHAKE.
      */
 
 #ifndef OPENSSL_NO_SCTP
@@ -776,7 +474,7 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
      * s-&gt;s3-&gt;rrec.off,     - offset into 'data' for next read
      * s-&gt;s3-&gt;rrec.length,  - number of bytes.
      */
-    rr = &amp;(s-&gt;s3-&gt;rrec);
+    rr = &amp;s-&gt;rlayer.rrec;
 
     /*
      * We are not handshaking and have no data yet, so process data buffered
@@ -784,7 +482,7 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
      */
     if (s-&gt;state == SSL_ST_OK &amp;&amp; rr-&gt;length == 0) {
         pitem *item;
-        item = pqueue_pop(s-&gt;d1-&gt;buffered_app_data.q);
+        item = pqueue_pop(s-&gt;rlayer.d-&gt;buffered_app_data.q);
         if (item) {
 #ifndef OPENSSL_NO_SCTP
             /* Restore bio_dgram_sctp_rcvinfo struct */
@@ -807,7 +505,7 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
         goto start;
 
     /* get new packet if necessary */
-    if ((rr-&gt;length == 0) || (s-&gt;rstate == SSL_ST_READ_BODY)) {
+    if ((rr-&gt;length == 0) || (s-&gt;rlayer.rstate == SSL_ST_READ_BODY)) {
         ret = dtls1_get_record(s);
         if (ret &lt;= 0) {
             ret = dtls1_read_failed(s, ret);
@@ -834,8 +532,8 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
          * the packets were reordered on their way, so buffer the application
          * data for later processing rather than dropping the connection.
          */
-        if (dtls1_buffer_record(s, &amp;(s-&gt;d1-&gt;buffered_app_data), rr-&gt;seq_num) &lt;
-            0) {
+        if (dtls1_buffer_record(s, &amp;(s-&gt;rlayer.d-&gt;buffered_app_data),
+            rr-&gt;seq_num) &lt; 0) {
             SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
             return -1;
         }
@@ -879,7 +577,7 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
             rr-&gt;length -= n;
             rr-&gt;off += n;
             if (rr-&gt;length == 0) {
-                s-&gt;rstate = SSL_ST_READ_HEADER;
+                s-&gt;rlayer.rstate = SSL_ST_READ_HEADER;
                 rr-&gt;off = 0;
             }
         }
@@ -927,21 +625,21 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
         unsigned int *dest_len = NULL;
 
         if (rr-&gt;type == SSL3_RT_HANDSHAKE) {
-            dest_maxlen = sizeof s-&gt;d1-&gt;handshake_fragment;
-            dest = s-&gt;d1-&gt;handshake_fragment;
-            dest_len = &amp;s-&gt;d1-&gt;handshake_fragment_len;
+            dest_maxlen = sizeof s-&gt;rlayer.d-&gt;handshake_fragment;
+            dest = s-&gt;rlayer.d-&gt;handshake_fragment;
+            dest_len = &amp;s-&gt;rlayer.d-&gt;handshake_fragment_len;
         } else if (rr-&gt;type == SSL3_RT_ALERT) {
-            dest_maxlen = sizeof(s-&gt;d1-&gt;alert_fragment);
-            dest = s-&gt;d1-&gt;alert_fragment;
-            dest_len = &amp;s-&gt;d1-&gt;alert_fragment_len;
+            dest_maxlen = sizeof(s-&gt;rlayer.d-&gt;alert_fragment);
+            dest = s-&gt;rlayer.d-&gt;alert_fragment;
+            dest_len = &amp;s-&gt;rlayer.d-&gt;alert_fragment_len;
         }
 #ifndef OPENSSL_NO_HEARTBEATS
         else if (rr-&gt;type == TLS1_RT_HEARTBEAT) {
             /* We allow a 0 return */
-            if(dtls1_process_heartbeat(s) &lt; 0) {
+            if(dtls1_process_heartbeat(s, SSL3_RECORD_get_data(&amp;s-&gt;rlayer.rrec),
+                    SSL3_RECORD_get_length(&amp;s-&gt;rlayer.rrec)) &lt; 0) {
                 return -1;
             }
-
             /* Exit and notify application to read again */
             rr-&gt;length = 0;
             s-&gt;rwstate = SSL_READING;
@@ -986,7 +684,7 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
                  */
                 FIX ME
 #endif
-                 s-&gt;rstate = SSL_ST_READ_HEADER;
+                 s-&gt;rlayer.rstate = SSL_ST_READ_HEADER;
                 rr-&gt;length = 0;
                 goto start;
             }
@@ -1001,21 +699,21 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
     }
 
     /*-
-     * s-&gt;d1-&gt;handshake_fragment_len == 12  iff  rr-&gt;type == SSL3_RT_HANDSHAKE;
-     * s-&gt;d1-&gt;alert_fragment_len == 7      iff  rr-&gt;type == SSL3_RT_ALERT.
+     * s-&gt;rlayer.d-&gt;handshake_fragment_len == 12  iff  rr-&gt;type == SSL3_RT_HANDSHAKE;
+     * s-&gt;rlayer.d-&gt;alert_fragment_len == 7      iff  rr-&gt;type == SSL3_RT_ALERT.
      * (Possibly rr is 'empty' now, i.e. rr-&gt;length may be 0.)
      */
 
     /* If we are a client, check for an incoming 'Hello Request': */
     if ((!s-&gt;server) &amp;&amp;
-        (s-&gt;d1-&gt;handshake_fragment_len &gt;= DTLS1_HM_HEADER_LENGTH) &amp;&amp;
-        (s-&gt;d1-&gt;handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &amp;&amp;
+        (s-&gt;rlayer.d-&gt;handshake_fragment_len &gt;= DTLS1_HM_HEADER_LENGTH) &amp;&amp;
+        (s-&gt;rlayer.d-&gt;handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &amp;&amp;
         (s-&gt;session != NULL) &amp;&amp; (s-&gt;session-&gt;cipher != NULL)) {
-        s-&gt;d1-&gt;handshake_fragment_len = 0;
+        s-&gt;rlayer.d-&gt;handshake_fragment_len = 0;
 
-        if ((s-&gt;d1-&gt;handshake_fragment[1] != 0) ||
-            (s-&gt;d1-&gt;handshake_fragment[2] != 0) ||
-            (s-&gt;d1-&gt;handshake_fragment[3] != 0)) {
+        if ((s-&gt;rlayer.d-&gt;handshake_fragment[1] != 0) ||
+            (s-&gt;rlayer.d-&gt;handshake_fragment[2] != 0) ||
+            (s-&gt;rlayer.d-&gt;handshake_fragment[3] != 0)) {
             al = SSL_AD_DECODE_ERROR;
             SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);
             goto err;
@@ -1027,7 +725,7 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
 
         if (s-&gt;msg_callback)
             s-&gt;msg_callback(0, s-&gt;version, SSL3_RT_HANDSHAKE,
-                            s-&gt;d1-&gt;handshake_fragment, 4, s,
+                            s-&gt;rlayer.d-&gt;handshake_fragment, 4, s,
                             s-&gt;msg_callback_arg);
 
         if (SSL_is_init_finished(s) &amp;&amp;
@@ -1047,7 +745,8 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
                 }
 
                 if (!(s-&gt;mode &amp; SSL_MODE_AUTO_RETRY)) {
-                    if (s-&gt;s3-&gt;rbuf.left == 0) { /* no read-ahead left? */
+                    if (SSL3_BUFFER_get_left(&amp;s-&gt;rlayer.rbuf) == 0) {
+                        /* no read-ahead left? */
                         BIO *bio;
                         /*
                          * In the case where we try to read application data,
@@ -1071,15 +770,16 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
         goto start;
     }
 
-    if (s-&gt;d1-&gt;alert_fragment_len &gt;= DTLS1_AL_HEADER_LENGTH) {
-        int alert_level = s-&gt;d1-&gt;alert_fragment[0];
-        int alert_descr = s-&gt;d1-&gt;alert_fragment[1];
+    if (s-&gt;rlayer.d-&gt;alert_fragment_len &gt;= DTLS1_AL_HEADER_LENGTH) {
+        int alert_level = s-&gt;rlayer.d-&gt;alert_fragment[0];
+        int alert_descr = s-&gt;rlayer.d-&gt;alert_fragment[1];
 
-        s-&gt;d1-&gt;alert_fragment_len = 0;
+        s-&gt;rlayer.d-&gt;alert_fragment_len = 0;
 
         if (s-&gt;msg_callback)
             s-&gt;msg_callback(0, s-&gt;version, SSL3_RT_ALERT,
-                            s-&gt;d1-&gt;alert_fragment, 2, s, s-&gt;msg_callback_arg);
+                            s-&gt;rlayer.d-&gt;alert_fragment, 2, s,
+                            s-&gt;msg_callback_arg);
 
         if (s-&gt;info_callback != NULL)
             cb = s-&gt;info_callback;
@@ -1118,7 +818,7 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
             if (alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE) {
                 unsigned short seq;
                 unsigned int frag_off;
-                unsigned char *p = &amp;(s-&gt;d1-&gt;alert_fragment[2]);
+                unsigned char *p = &amp;(s-&gt;rlayer.d-&gt;alert_fragment[2]);
 
                 n2s(p, seq);
                 n2l3(p, frag_off);
@@ -1230,13 +930,13 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
     /*
      * Unexpected handshake message (Client Hello, or protocol violation)
      */
-    if ((s-&gt;d1-&gt;handshake_fragment_len &gt;= DTLS1_HM_HEADER_LENGTH) &amp;&amp;
+    if ((s-&gt;rlayer.d-&gt;handshake_fragment_len &gt;= DTLS1_HM_HEADER_LENGTH) &amp;&amp;
         !s-&gt;in_handshake) {
         struct hm_header_st msg_hdr;
 
         /* this may just be a stale retransmit */
         dtls1_get_message_header(rr-&gt;data, &amp;msg_hdr);
-        if (rr-&gt;epoch != s-&gt;d1-&gt;r_epoch) {
+        if (rr-&gt;epoch != s-&gt;rlayer.d-&gt;r_epoch) {
             rr-&gt;length = 0;
             goto start;
         }
@@ -1269,7 +969,8 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
         }
 
         if (!(s-&gt;mode &amp; SSL_MODE_AUTO_RETRY)) {
-            if (s-&gt;s3-&gt;rbuf.left == 0) { /* no read-ahead left? */
+            if (SSL3_BUFFER_get_left(&amp;s-&gt;rlayer.rbuf) == 0) {
+                /* no read-ahead left? */
                 BIO *bio;
                 /*
                  * In the case where we try to read application data, but we
@@ -1342,69 +1043,34 @@ int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
     return (-1);
 }
 
-int dtls1_write_app_data_bytes(SSL *s, int type, const void *buf_, int len)
-{
-    int i;
-
-#ifndef OPENSSL_NO_SCTP
-    /*
-     * Check if we have to continue an interrupted handshake for reading
-     * belated app data with SCTP.
-     */
-    if ((SSL_in_init(s) &amp;&amp; !s-&gt;in_handshake) ||
-        (BIO_dgram_is_sctp(SSL_get_wbio(s)) &amp;&amp;
-         (s-&gt;state == DTLS1_SCTP_ST_SR_READ_SOCK
-          || s-&gt;state == DTLS1_SCTP_ST_CR_READ_SOCK)))
-#else
-    if (SSL_in_init(s) &amp;&amp; !s-&gt;in_handshake)
-#endif
-    {
-        i = s-&gt;handshake_func(s);
-        if (i &lt; 0)
-            return (i);
-        if (i == 0) {
-            SSLerr(SSL_F_DTLS1_WRITE_APP_DATA_BYTES,
-                   SSL_R_SSL_HANDSHAKE_FAILURE);
-            return -1;
-        }
-    }
-
-    if (len &gt; SSL3_RT_MAX_PLAIN_LENGTH) {
-        SSLerr(SSL_F_DTLS1_WRITE_APP_DATA_BYTES, SSL_R_DTLS_MESSAGE_TOO_BIG);
-        return -1;
-    }
-
-    i = dtls1_write_bytes(s, type, buf_, len);
-    return i;
-}
 
         /*
          * this only happens when a client hello is received and a handshake
          * is started.
          */
-static int
-have_handshake_fragment(SSL *s, int type, unsigned char *buf,
-                        int len, int peek)
+static int have_handshake_fragment(SSL *s, int type, unsigned char *buf,
+                                   int len, int peek)
 {
 
-    if ((type == SSL3_RT_HANDSHAKE) &amp;&amp; (s-&gt;d1-&gt;handshake_fragment_len &gt; 0))
+    if ((type == SSL3_RT_HANDSHAKE)
+            &amp;&amp; (s-&gt;rlayer.d-&gt;handshake_fragment_len &gt; 0))
         /* (partially) satisfy request from storage */
     {
-        unsigned char *src = s-&gt;d1-&gt;handshake_fragment;
+        unsigned char *src = s-&gt;rlayer.d-&gt;handshake_fragment;
         unsigned char *dst = buf;
         unsigned int k, n;
 
         /* peek == 0 */
         n = 0;
-        while ((len &gt; 0) &amp;&amp; (s-&gt;d1-&gt;handshake_fragment_len &gt; 0)) {
+        while ((len &gt; 0) &amp;&amp; (s-&gt;rlayer.d-&gt;handshake_fragment_len &gt; 0)) {
             *dst++ = *src++;
             len--;
-            s-&gt;d1-&gt;handshake_fragment_len--;
+            s-&gt;rlayer.d-&gt;handshake_fragment_len--;
             n++;
         }
         /* move any remaining fragment bytes: */
-        for (k = 0; k &lt; s-&gt;d1-&gt;handshake_fragment_len; k++)
-            s-&gt;d1-&gt;handshake_fragment[k] = *src++;
+        for (k = 0; k &lt; s-&gt;rlayer.d-&gt;handshake_fragment_len; k++)
+            s-&gt;rlayer.d-&gt;handshake_fragment[k] = *src++;
         return n;
     }
 
@@ -1436,11 +1102,13 @@ int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
     SSL3_BUFFER *wb;
     SSL_SESSION *sess;
 
+    wb = &amp;s-&gt;rlayer.wbuf;
+
     /*
      * first check if there is a SSL3_BUFFER still being written out.  This
      * will happen with non blocking IO
      */
-    if (s-&gt;s3-&gt;wbuf.left != 0) {
+    if (SSL3_BUFFER_get_left(wb) != 0) {
         OPENSSL_assert(0);      /* XDTLS: want to see if we ever get here */
         return (ssl3_write_pending(s, type, buf, len));
     }
@@ -1456,8 +1124,7 @@ int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
     if (len == 0 &amp;&amp; !create_empty_fragment)
         return 0;
 
-    wr = &amp;(s-&gt;s3-&gt;wrec);
-    wb = &amp;(s-&gt;s3-&gt;wbuf);
+    wr = &amp;s-&gt;rlayer.wrec;
     sess = s-&gt;session;
 
     if ((sess == NULL) ||
@@ -1561,14 +1228,14 @@ int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
 
     /* there's only one epoch between handshake and app data */
 
-    s2n(s-&gt;d1-&gt;w_epoch, pseq);
+    s2n(s-&gt;rlayer.d-&gt;w_epoch, pseq);
 
     /* XDTLS: ?? */
     /*
      * else s2n(s-&gt;d1-&gt;handshake_epoch, pseq);
      */
 
-    memcpy(pseq, &amp;(s-&gt;s3-&gt;write_sequence[2]), 6);
+    memcpy(pseq, &amp;(s-&gt;rlayer.write_sequence[2]), 6);
     pseq += 6;
     s2n(wr-&gt;length, pseq);
 
@@ -1583,7 +1250,7 @@ int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
     wr-&gt;type = type;            /* not needed but helps for debugging */
     wr-&gt;length += DTLS1_RT_HEADER_LENGTH;
 
-    ssl3_record_sequence_update(&amp;(s-&gt;s3-&gt;write_sequence[0]));
+    ssl3_record_sequence_update(&amp;(s-&gt;rlayer.write_sequence[0]));
 
     if (create_empty_fragment) {
         /*
@@ -1601,10 +1268,10 @@ int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
      * memorize arguments so that ssl3_write_pending can detect bad write
      * retries later
      */
-    s-&gt;s3-&gt;wpend_tot = len;
-    s-&gt;s3-&gt;wpend_buf = buf;
-    s-&gt;s3-&gt;wpend_type = type;
-    s-&gt;s3-&gt;wpend_ret = len;
+    s-&gt;rlayer.wpend_tot = len;
+    s-&gt;rlayer.wpend_buf = buf;
+    s-&gt;rlayer.wpend_type = type;
+    s-&gt;rlayer.wpend_ret = len;
 
     /* we now just need to write the buffer */
     return ssl3_write_pending(s, type, buf, len);
@@ -1612,112 +1279,21 @@ int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
     return -1;
 }
 
-static int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap)
-{
-    int cmp;
-    unsigned int shift;
-    const unsigned char *seq = s-&gt;s3-&gt;read_sequence;
-
-    cmp = satsub64be(seq, bitmap-&gt;max_seq_num);
-    if (cmp &gt; 0) {
-        memcpy(s-&gt;s3-&gt;rrec.seq_num, seq, 8);
-        return 1;               /* this record in new */
-    }
-    shift = -cmp;
-    if (shift &gt;= sizeof(bitmap-&gt;map) * 8)
-        return 0;               /* stale, outside the window */
-    else if (bitmap-&gt;map &amp; (1UL &lt;&lt; shift))
-        return 0;               /* record previously received */
-
-    memcpy(s-&gt;s3-&gt;rrec.seq_num, seq, 8);
-    return 1;
-}
-
-static void dtls1_record_bitmap_update(SSL *s, DTLS1_BITMAP *bitmap)
-{
-    int cmp;
-    unsigned int shift;
-    const unsigned char *seq = s-&gt;s3-&gt;read_sequence;
-
-    cmp = satsub64be(seq, bitmap-&gt;max_seq_num);
-    if (cmp &gt; 0) {
-        shift = cmp;
-        if (shift &lt; sizeof(bitmap-&gt;map) * 8)
-            bitmap-&gt;map &lt;&lt;= shift, bitmap-&gt;map |= 1UL;
-        else
-            bitmap-&gt;map = 1UL;
-        memcpy(bitmap-&gt;max_seq_num, seq, 8);
-    } else {
-        shift = -cmp;
-        if (shift &lt; sizeof(bitmap-&gt;map) * 8)
-            bitmap-&gt;map |= 1UL &lt;&lt; shift;
-    }
-}
-
-int dtls1_dispatch_alert(SSL *s)
-{
-    int i, j;
-    void (*cb) (const SSL *ssl, int type, int val) = NULL;
-    unsigned char buf[DTLS1_AL_HEADER_LENGTH];
-    unsigned char *ptr = &amp;buf[0];
-
-    s-&gt;s3-&gt;alert_dispatch = 0;
-
-    memset(buf, 0x00, sizeof(buf));
-    *ptr++ = s-&gt;s3-&gt;send_alert[0];
-    *ptr++ = s-&gt;s3-&gt;send_alert[1];
-
-#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
-    if (s-&gt;s3-&gt;send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE) {
-        s2n(s-&gt;d1-&gt;handshake_read_seq, ptr);
-        l2n3(s-&gt;d1-&gt;r_msg_hdr.frag_off, ptr);
-    }
-#endif
-
-    i = do_dtls1_write(s, SSL3_RT_ALERT, &amp;buf[0], sizeof(buf), 0);
-    if (i &lt;= 0) {
-        s-&gt;s3-&gt;alert_dispatch = 1;
-        /* fprintf( stderr, &quot;not done with alert\n&quot; ); */
-    } else {
-        if (s-&gt;s3-&gt;send_alert[0] == SSL3_AL_FATAL
-#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
-            || s-&gt;s3-&gt;send_alert[1] == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
-#endif
-            )
-            (void)BIO_flush(s-&gt;wbio);
-
-        if (s-&gt;msg_callback)
-            s-&gt;msg_callback(1, s-&gt;version, SSL3_RT_ALERT, s-&gt;s3-&gt;send_alert,
-                            2, s, s-&gt;msg_callback_arg);
-
-        if (s-&gt;info_callback != NULL)
-            cb = s-&gt;info_callback;
-        else if (s-&gt;ctx-&gt;info_callback != NULL)
-            cb = s-&gt;ctx-&gt;info_callback;
-
-        if (cb != NULL) {
-            j = (s-&gt;s3-&gt;send_alert[0] &lt;&lt; 8) | s-&gt;s3-&gt;send_alert[1];
-            cb(s, SSL_CB_WRITE_ALERT, j);
-        }
-    }
-    return (i);
-}
-
-static DTLS1_BITMAP *dtls1_get_bitmap(SSL *s, SSL3_RECORD *rr,
+DTLS1_BITMAP *dtls1_get_bitmap(SSL *s, SSL3_RECORD *rr,
                                       unsigned int *is_next_epoch)
 {
 
     *is_next_epoch = 0;
 
     /* In current epoch, accept HM, CCS, DATA, &amp; ALERT */
-    if (rr-&gt;epoch == s-&gt;d1-&gt;r_epoch)
-        return &amp;s-&gt;d1-&gt;bitmap;
+    if (rr-&gt;epoch == s-&gt;rlayer.d-&gt;r_epoch)
+        return &amp;s-&gt;rlayer.d-&gt;bitmap;
 
     /* Only HM and ALERT messages can be from the next epoch */
-    else if (rr-&gt;epoch == (unsigned long)(s-&gt;d1-&gt;r_epoch + 1) &amp;&amp;
-             (rr-&gt;type == SSL3_RT_HANDSHAKE || rr-&gt;type == SSL3_RT_ALERT)) {
+    else if (rr-&gt;epoch == (unsigned long)(s-&gt;rlayer.d-&gt;r_epoch + 1) &amp;&amp;
+            (rr-&gt;type == SSL3_RT_HANDSHAKE || rr-&gt;type == SSL3_RT_ALERT)) {
         *is_next_epoch = 1;
-        return &amp;s-&gt;d1-&gt;next_bitmap;
+        return &amp;s-&gt;rlayer.d-&gt;next_bitmap;
     }
 
     return NULL;
@@ -1726,18 +1302,19 @@ static DTLS1_BITMAP *dtls1_get_bitmap(SSL *s, SSL3_RECORD *rr,
 void dtls1_reset_seq_numbers(SSL *s, int rw)
 {
     unsigned char *seq;
-    unsigned int seq_bytes = sizeof(s-&gt;s3-&gt;read_sequence);
+    unsigned int seq_bytes = sizeof(s-&gt;rlayer.read_sequence);
 
     if (rw &amp; SSL3_CC_READ) {
-        seq = s-&gt;s3-&gt;read_sequence;
-        s-&gt;d1-&gt;r_epoch++;
-        memcpy(&amp;(s-&gt;d1-&gt;bitmap), &amp;(s-&gt;d1-&gt;next_bitmap), sizeof(DTLS1_BITMAP));
-        memset(&amp;(s-&gt;d1-&gt;next_bitmap), 0x00, sizeof(DTLS1_BITMAP));
+        seq = s-&gt;rlayer.read_sequence;
+        s-&gt;rlayer.d-&gt;r_epoch++;
+        memcpy(&amp;(s-&gt;rlayer.d-&gt;bitmap), &amp;(s-&gt;rlayer.d-&gt;next_bitmap),
+            sizeof(DTLS1_BITMAP));
+        memset(&amp;(s-&gt;rlayer.d-&gt;next_bitmap), 0x00, sizeof(DTLS1_BITMAP));
     } else {
-        seq = s-&gt;s3-&gt;write_sequence;
-        memcpy(s-&gt;d1-&gt;last_write_sequence, seq,
-               sizeof(s-&gt;s3-&gt;write_sequence));
-        s-&gt;d1-&gt;w_epoch++;
+        seq = s-&gt;rlayer.write_sequence;
+        memcpy(s-&gt;rlayer.d-&gt;last_write_sequence, seq,
+               sizeof(s-&gt;rlayer.write_sequence));
+        s-&gt;rlayer.d-&gt;w_epoch++;
     }
 
     memset(seq, 0x00, seq_bytes);
diff --git a/ssl/s23_pkt.c b/ssl/record/rec_layer_s23.c
similarity index 90%
rename from ssl/s23_pkt.c
rename to ssl/record/rec_layer_s23.c
index efc8647..eb09be1 100644
--- a/ssl/s23_pkt.c
+++ b/ssl/record/rec_layer_s23.c
@@ -1,4 +1,4 @@
-/* ssl/s23_pkt.c */
+/* ssl/record/rec_layer_s23.c */
 /* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
  * All rights reserved.
  *
@@ -59,7 +59,7 @@
 #include &lt;stdio.h&gt;
 #include &lt;errno.h&gt;
 #define USE_SOCKETS
-#include &quot;ssl_locl.h&quot;
+#include &quot;../ssl_locl.h&quot;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/buffer.h&gt;
 
@@ -94,19 +94,20 @@ int ssl23_read_bytes(SSL *s, int n)
     unsigned char *p;
     int j;
 
-    if (s-&gt;packet_length &lt; (unsigned int)n) {
-        p = s-&gt;packet;
+    if (s-&gt;rlayer.packet_length &lt; (unsigned int)n) {
+        p = s-&gt;rlayer.packet;
 
         for (;;) {
             s-&gt;rwstate = SSL_READING;
-            j = BIO_read(s-&gt;rbio, (char *)&amp;(p[s-&gt;packet_length]),
-                         n - s-&gt;packet_length);
+            j = BIO_read(s-&gt;rbio,
+                (char *)&amp;(p[s-&gt;rlayer.packet_length]),
+                n - s-&gt;rlayer.packet_length);
             if (j &lt;= 0)
                 return (j);
             s-&gt;rwstate = SSL_NOTHING;
-            s-&gt;packet_length += j;
-            if (s-&gt;packet_length &gt;= (unsigned int)n)
-                return (s-&gt;packet_length);
+            s-&gt;rlayer.packet_length += j;
+            if (s-&gt;rlayer.packet_length &gt;= (unsigned int)n)
+                return (s-&gt;rlayer.packet_length);
         }
     }
     return (n);
diff --git a/ssl/s3_pkt.c b/ssl/record/rec_layer_s3.c
similarity index 68%
rename from ssl/s3_pkt.c
rename to ssl/record/rec_layer_s3.c
index 4f81f1a..dc89be8 100644
--- a/ssl/s3_pkt.c
+++ b/ssl/record/rec_layer_s3.c
@@ -1,4 +1,4 @@
-/* ssl/s3_pkt.c */
+/* ssl/record/rec_layer_s3.c */
 /* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
  * All rights reserved.
  *
@@ -113,10 +113,11 @@
 #include &lt;limits.h&gt;
 #include &lt;errno.h&gt;
 #define USE_SOCKETS
-#include &quot;ssl_locl.h&quot;
+#include &quot;../ssl_locl.h&quot;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/buffer.h&gt;
 #include &lt;openssl/rand.h&gt;
+#include &quot;record_locl.h&quot;
 
 #ifndef  EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
 # define EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK 0
@@ -132,9 +133,156 @@
 # define EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK 0
 #endif
 
-static int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
-                         unsigned int len, int create_empty_fragment);
-static int ssl3_get_record(SSL *s);
+void RECORD_LAYER_init(RECORD_LAYER *rl, SSL *s)
+{
+    rl-&gt;s = s;
+    SSL3_RECORD_clear(&amp;rl-&gt;rrec);
+    SSL3_RECORD_clear(&amp;rl-&gt;wrec);
+}
+
+void RECORD_LAYER_clear(RECORD_LAYER *rl)
+{
+    unsigned char *rp, *wp;
+    size_t rlen, wlen;
+    int read_ahead;
+    SSL *s;
+    DTLS_RECORD_LAYER *d;
+
+    s = rl-&gt;s;
+    d = rl-&gt;d;
+    read_ahead = rl-&gt;read_ahead;
+    rp = SSL3_BUFFER_get_buf(&amp;rl-&gt;rbuf);
+    rlen = SSL3_BUFFER_get_len(&amp;rl-&gt;rbuf);
+    wp = SSL3_BUFFER_get_buf(&amp;rl-&gt;wbuf);
+    wlen = SSL3_BUFFER_get_len(&amp;rl-&gt;wbuf);
+    memset(rl, 0, sizeof (RECORD_LAYER));
+    SSL3_BUFFER_set_buf(&amp;rl-&gt;rbuf, rp);
+    SSL3_BUFFER_set_len(&amp;rl-&gt;rbuf, rlen);
+    SSL3_BUFFER_set_buf(&amp;rl-&gt;wbuf, wp);
+    SSL3_BUFFER_set_len(&amp;rl-&gt;wbuf, wlen);
+
+    /* Do I need to do this? As far as I can tell read_ahead did not
+     * previously get reset by SSL_clear...so I'll keep it that way..but is
+     * that right?
+     */
+    rl-&gt;read_ahead = read_ahead;
+    rl-&gt;rstate = SSL_ST_READ_HEADER;
+    rl-&gt;s = s;
+    rl-&gt;d = d;
+    
+    if(d)
+        DTLS_RECORD_LAYER_clear(rl);
+}
+
+void RECORD_LAYER_release(RECORD_LAYER *rl)
+{
+    if (SSL3_BUFFER_is_initialised(&amp;rl-&gt;rbuf))
+        ssl3_release_read_buffer(rl-&gt;s);
+    if (SSL3_BUFFER_is_initialised(&amp;rl-&gt;wbuf))
+        ssl3_release_write_buffer(rl-&gt;s);
+    SSL3_RECORD_release(&amp;rl-&gt;rrec);
+}
+
+int RECORD_LAYER_read_pending(RECORD_LAYER *rl)
+{
+    return SSL3_BUFFER_get_left(&amp;rl-&gt;rbuf) != 0;
+}
+
+int RECORD_LAYER_write_pending(RECORD_LAYER *rl)
+{
+    return SSL3_BUFFER_get_left(&amp;rl-&gt;wbuf) != 0;
+}
+
+int RECORD_LAYER_set_data(RECORD_LAYER *rl, const unsigned char *buf, int len)
+{
+    rl-&gt;packet_length = len;
+    if(len != 0) {
+        rl-&gt;rstate = SSL_ST_READ_HEADER;
+        if (!SSL3_BUFFER_is_initialised(&amp;rl-&gt;rbuf))
+            if (!ssl3_setup_read_buffer(rl-&gt;s))
+                return 0;
+    }
+
+    rl-&gt;packet = SSL3_BUFFER_get_buf(&amp;rl-&gt;rbuf);
+    SSL3_BUFFER_set_data(&amp;rl-&gt;rbuf, buf, len);
+
+    return 1;
+}
+
+void RECORD_LAYER_dup(RECORD_LAYER *dst, RECORD_LAYER *src)
+{
+    /*
+     * Currently only called from SSL_dup...which only seems to expect the
+     * rstate to be duplicated and nothing else from the RECORD_LAYER???
+     */
+    dst-&gt;rstate = src-&gt;rstate;
+}
+
+void RECORD_LAYER_reset_read_sequence(RECORD_LAYER *rl)
+{
+    memset(rl-&gt;read_sequence, 0, 8);
+}
+
+void RECORD_LAYER_reset_write_sequence(RECORD_LAYER *rl)
+{
+    memset(rl-&gt;write_sequence, 0, 8);
+}
+
+int RECORD_LAYER_setup_comp_buffer(RECORD_LAYER *rl)
+{
+    return SSL3_RECORD_setup(&amp;(rl)-&gt;rrec);
+}
+
+int ssl3_pending(const SSL *s)
+{
+    if (s-&gt;rlayer.rstate == SSL_ST_READ_BODY)
+        return 0;
+
+    return (SSL3_RECORD_get_type(&amp;s-&gt;rlayer.rrec) == SSL3_RT_APPLICATION_DATA)
+           ? SSL3_RECORD_get_length(&amp;s-&gt;rlayer.rrec) : 0;
+}
+
+const char *SSL_rstate_string_long(const SSL *s)
+{
+    const char *str;
+
+    switch (s-&gt;rlayer.rstate) {
+    case SSL_ST_READ_HEADER:
+        str = &quot;read header&quot;;
+        break;
+    case SSL_ST_READ_BODY:
+        str = &quot;read body&quot;;
+        break;
+    case SSL_ST_READ_DONE:
+        str = &quot;read done&quot;;
+        break;
+    default:
+        str = &quot;unknown&quot;;
+        break;
+    }
+    return (str);
+}
+
+const char *SSL_rstate_string(const SSL *s)
+{
+    const char *str;
+
+    switch (s-&gt;rlayer.rstate) {
+    case SSL_ST_READ_HEADER:
+        str = &quot;RH&quot;;
+        break;
+    case SSL_ST_READ_BODY:
+        str = &quot;RB&quot;;
+        break;
+    case SSL_ST_READ_DONE:
+        str = &quot;RD&quot;;
+        break;
+    default:
+        str = &quot;unknown&quot;;
+        break;
+    }
+    return (str);
+}
 
 int ssl3_read_n(SSL *s, int n, int max, int extend)
 {
@@ -142,7 +290,7 @@ int ssl3_read_n(SSL *s, int n, int max, int extend)
      * If extend == 0, obtain new n-byte packet; if extend == 1, increase
      * packet by another n bytes. The packet will be in the sub-array of
      * s-&gt;s3-&gt;rbuf.buf specified by s-&gt;packet and s-&gt;packet_length. (If
-     * s-&gt;read_ahead is set, 'max' bytes may be stored in rbuf [plus
+     * s-&gt;rlayer.read_ahead is set, 'max' bytes may be stored in rbuf [plus
      * s-&gt;packet_length bytes if extend == 1].)
      */
     int i, len, left;
@@ -153,7 +301,7 @@ int ssl3_read_n(SSL *s, int n, int max, int extend)
     if (n &lt;= 0)
         return n;
 
-    rb = &amp;(s-&gt;s3-&gt;rbuf);
+    rb = &amp;s-&gt;rlayer.rbuf;
     if (rb-&gt;buf == NULL)
         if (!ssl3_setup_read_buffer(s))
             return -1;
@@ -187,8 +335,8 @@ int ssl3_read_n(SSL *s, int n, int max, int extend)
                 rb-&gt;offset = align;
             }
         }
-        s-&gt;packet = rb-&gt;buf + rb-&gt;offset;
-        s-&gt;packet_length = 0;
+        s-&gt;rlayer.packet = rb-&gt;buf + rb-&gt;offset;
+        s-&gt;rlayer.packet_length = 0;
         /* ... now we can act as if 'extend' was set */
     }
 
@@ -206,7 +354,7 @@ int ssl3_read_n(SSL *s, int n, int max, int extend)
 
     /* if there is enough in the buffer from a previous read, take some */
     if (left &gt;= n) {
-        s-&gt;packet_length += n;
+        s-&gt;rlayer.packet_length += n;
         rb-&gt;left = left - n;
         rb-&gt;offset += n;
         return (n);
@@ -214,15 +362,15 @@ int ssl3_read_n(SSL *s, int n, int max, int extend)
 
     /* else we need to read more data */
 
-    len = s-&gt;packet_length;
+    len = s-&gt;rlayer.packet_length;
     pkt = rb-&gt;buf + align;
     /*
      * Move any available bytes to front of buffer: 'len' bytes already
      * pointed to by 'packet', 'left' extra ones at the end
      */
-    if (s-&gt;packet != pkt) {     /* len &gt; 0 */
-        memmove(pkt, s-&gt;packet, len + left);
-        s-&gt;packet = pkt;
+    if (s-&gt;rlayer.packet != pkt) {     /* len &gt; 0 */
+        memmove(pkt, s-&gt;rlayer.packet, len + left);
+        s-&gt;rlayer.packet = pkt;
         rb-&gt;offset = len + align;
     }
 
@@ -232,7 +380,7 @@ int ssl3_read_n(SSL *s, int n, int max, int extend)
     }
 
     /* We always act like read_ahead is set for DTLS */
-    if (!s-&gt;read_ahead &amp;&amp; !SSL_IS_DTLS(s))
+    if (&amp;s-&gt;rlayer.read_ahead &amp;&amp; !SSL_IS_DTLS(s))
         /* ignore max parameter */
         max = n;
     else {
@@ -280,355 +428,11 @@ int ssl3_read_n(SSL *s, int n, int max, int extend)
     /* done reading, now the book-keeping */
     rb-&gt;offset += n;
     rb-&gt;left = left - n;
-    s-&gt;packet_length += n;
+    s-&gt;rlayer.packet_length += n;
     s-&gt;rwstate = SSL_NOTHING;
     return (n);
 }
 
-/*
- * MAX_EMPTY_RECORDS defines the number of consecutive, empty records that
- * will be processed per call to ssl3_get_record. Without this limit an
- * attacker could send empty records at a faster rate than we can process and
- * cause ssl3_get_record to loop forever.
- */
-#define MAX_EMPTY_RECORDS 32
-
-/*-
- * Call this to get a new input record.
- * It will return &lt;= 0 if more data is needed, normally due to an error
- * or non-blocking IO.
- * When it finishes, one packet has been decoded and can be found in
- * ssl-&gt;s3-&gt;rrec.type    - is the type of record
- * ssl-&gt;s3-&gt;rrec.data,   - data
- * ssl-&gt;s3-&gt;rrec.length, - number of bytes
- */
-/* used only by ssl3_read_bytes */
-static int ssl3_get_record(SSL *s)
-{
-    int ssl_major, ssl_minor, al;
-    int enc_err, n, i, ret = -1;
-    SSL3_RECORD *rr;
-    SSL_SESSION *sess;
-    unsigned char *p;
-    unsigned char md[EVP_MAX_MD_SIZE];
-    short version;
-    unsigned mac_size;
-    size_t extra;
-    unsigned empty_record_count = 0;
-
-    rr = &amp;(s-&gt;s3-&gt;rrec);
-    sess = s-&gt;session;
-
-    if (s-&gt;options &amp; SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)
-        extra = SSL3_RT_MAX_EXTRA;
-    else
-        extra = 0;
-    if (extra &amp;&amp; !s-&gt;s3-&gt;init_extra) {
-        /*
-         * An application error: SLS_OP_MICROSOFT_BIG_SSLV3_BUFFER set after
-         * ssl3_setup_buffers() was done
-         */
-        SSLerr(SSL_F_SSL3_GET_RECORD, ERR_R_INTERNAL_ERROR);
-        return -1;
-    }
-
- again:
-    /* check if we have the header */
-    if ((s-&gt;rstate != SSL_ST_READ_BODY) ||
-        (s-&gt;packet_length &lt; SSL3_RT_HEADER_LENGTH)) {
-        n = ssl3_read_n(s, SSL3_RT_HEADER_LENGTH, s-&gt;s3-&gt;rbuf.len, 0);
-        if (n &lt;= 0)
-            return (n);         /* error or non-blocking */
-        s-&gt;rstate = SSL_ST_READ_BODY;
-
-        p = s-&gt;packet;
-        if (s-&gt;msg_callback)
-            s-&gt;msg_callback(0, 0, SSL3_RT_HEADER, p, 5, s,
-                            s-&gt;msg_callback_arg);
-
-        /* Pull apart the header into the SSL3_RECORD */
-        rr-&gt;type = *(p++);
-        ssl_major = *(p++);
-        ssl_minor = *(p++);
-        version = (ssl_major &lt;&lt; 8) | ssl_minor;
-        n2s(p, rr-&gt;length);
-
-        /* Lets check version */
-        if (!s-&gt;first_packet) {
-            if (version != s-&gt;version) {
-                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);
-                if ((s-&gt;version &amp; 0xFF00) == (version &amp; 0xFF00)
-                    &amp;&amp; !s-&gt;enc_write_ctx &amp;&amp; !s-&gt;write_hash)
-                    /*
-                     * Send back error using their minor version number :-)
-                     */
-                    s-&gt;version = (unsigned short)version;
-                al = SSL_AD_PROTOCOL_VERSION;
-                goto f_err;
-            }
-        }
-
-        if ((version &gt;&gt; 8) != SSL3_VERSION_MAJOR) {
-            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);
-            goto err;
-        }
-
-        if (rr-&gt;length &gt; s-&gt;s3-&gt;rbuf.len - SSL3_RT_HEADER_LENGTH) {
-            al = SSL_AD_RECORD_OVERFLOW;
-            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);
-            goto f_err;
-        }
-
-        /* now s-&gt;rstate == SSL_ST_READ_BODY */
-    }
-
-    /* s-&gt;rstate == SSL_ST_READ_BODY, get and decode the data */
-
-    if (rr-&gt;length &gt; s-&gt;packet_length - SSL3_RT_HEADER_LENGTH) {
-        /* now s-&gt;packet_length == SSL3_RT_HEADER_LENGTH */
-        i = rr-&gt;length;
-        n = ssl3_read_n(s, i, i, 1);
-        if (n &lt;= 0)
-            return (n);         /* error or non-blocking io */
-        /*
-         * now n == rr-&gt;length, and s-&gt;packet_length == SSL3_RT_HEADER_LENGTH
-         * + rr-&gt;length
-         */
-    }
-
-    s-&gt;rstate = SSL_ST_READ_HEADER; /* set state for later operations */
-
-    /*
-     * At this point, s-&gt;packet_length == SSL3_RT_HEADER_LNGTH + rr-&gt;length,
-     * and we have that many bytes in s-&gt;packet
-     */
-    rr-&gt;input = &amp;(s-&gt;packet[SSL3_RT_HEADER_LENGTH]);
-
-    /*
-     * ok, we can now read from 's-&gt;packet' data into 'rr' rr-&gt;input points
-     * at rr-&gt;length bytes, which need to be copied into rr-&gt;data by either
-     * the decryption or by the decompression When the data is 'copied' into
-     * the rr-&gt;data buffer, rr-&gt;input will be pointed at the new buffer
-     */
-
-    /*
-     * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr-&gt;length
-     * bytes of encrypted compressed stuff.
-     */
-
-    /* check is not needed I believe */
-    if (rr-&gt;length &gt; SSL3_RT_MAX_ENCRYPTED_LENGTH + extra) {
-        al = SSL_AD_RECORD_OVERFLOW;
-        SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
-        goto f_err;
-    }
-
-    /* decrypt in place in 'rr-&gt;input' */
-    rr-&gt;data = rr-&gt;input;
-    rr-&gt;orig_len = rr-&gt;length;
-    /*
-     * If in encrypt-then-mac mode calculate mac from encrypted record. All
-     * the details below are public so no timing details can leak.
-     */
-    if (SSL_USE_ETM(s) &amp;&amp; s-&gt;read_hash) {
-        unsigned char *mac;
-        mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
-        OPENSSL_assert(mac_size &lt;= EVP_MAX_MD_SIZE);
-        if (rr-&gt;length &lt; mac_size) {
-            al = SSL_AD_DECODE_ERROR;
-            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);
-            goto f_err;
-        }
-        rr-&gt;length -= mac_size;
-        mac = rr-&gt;data + rr-&gt;length;
-        i = s-&gt;method-&gt;ssl3_enc-&gt;mac(s, md, 0 /* not send */ );
-        if (i &lt; 0 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0) {
-            al = SSL_AD_BAD_RECORD_MAC;
-            SSLerr(SSL_F_SSL3_GET_RECORD,
-                   SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
-            goto f_err;
-        }
-    }
-
-    enc_err = s-&gt;method-&gt;ssl3_enc-&gt;enc(s, 0);
-    /*-
-     * enc_err is:
-     *    0: (in non-constant time) if the record is publically invalid.
-     *    1: if the padding is valid
-     *    -1: if the padding is invalid
-     */
-    if (enc_err == 0) {
-        al = SSL_AD_DECRYPTION_FAILED;
-        SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
-        goto f_err;
-    }
-#ifdef TLS_DEBUG
-    printf(&quot;dec %d\n&quot;, rr-&gt;length);
-    {
-        unsigned int z;
-        for (z = 0; z &lt; rr-&gt;length; z++)
-            printf(&quot;%02X%c&quot;, rr-&gt;data[z], ((z + 1) % 16) ? ' ' : '\n');
-    }
-    printf(&quot;\n&quot;);
-#endif
-
-    /* r-&gt;length is now the compressed data plus mac */
-    if ((sess != NULL) &amp;&amp;
-        (s-&gt;enc_read_ctx != NULL) &amp;&amp;
-        (EVP_MD_CTX_md(s-&gt;read_hash) != NULL) &amp;&amp; !SSL_USE_ETM(s)) {
-        /* s-&gt;read_hash != NULL =&gt; mac_size != -1 */
-        unsigned char *mac = NULL;
-        unsigned char mac_tmp[EVP_MAX_MD_SIZE];
-        mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
-        OPENSSL_assert(mac_size &lt;= EVP_MAX_MD_SIZE);
-
-        /*
-         * orig_len is the length of the record before any padding was
-         * removed. This is public information, as is the MAC in use,
-         * therefore we can safely process the record in a different amount
-         * of time if it's too short to possibly contain a MAC.
-         */
-        if (rr-&gt;orig_len &lt; mac_size ||
-            /* CBC records must have a padding length byte too. */
-            (EVP_CIPHER_CTX_mode(s-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE &amp;&amp;
-             rr-&gt;orig_len &lt; mac_size + 1)) {
-            al = SSL_AD_DECODE_ERROR;
-            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);
-            goto f_err;
-        }
-
-        if (EVP_CIPHER_CTX_mode(s-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE) {
-            /*
-             * We update the length so that the TLS header bytes can be
-             * constructed correctly but we need to extract the MAC in
-             * constant time from within the record, without leaking the
-             * contents of the padding bytes.
-             */
-            mac = mac_tmp;
-            ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);
-            rr-&gt;length -= mac_size;
-        } else {
-            /*
-             * In this case there's no padding, so |rec-&gt;orig_len| equals
-             * |rec-&gt;length| and we checked that there's enough bytes for
-             * |mac_size| above.
-             */
-            rr-&gt;length -= mac_size;
-            mac = &amp;rr-&gt;data[rr-&gt;length];
-        }
-
-        i = s-&gt;method-&gt;ssl3_enc-&gt;mac(s, md, 0 /* not send */ );
-        if (i &lt; 0 || mac == NULL
-            || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
-            enc_err = -1;
-        if (rr-&gt;length &gt; SSL3_RT_MAX_COMPRESSED_LENGTH + extra + mac_size)
-            enc_err = -1;
-    }
-
-    if (enc_err &lt; 0) {
-        /*
-         * A separate 'decryption_failed' alert was introduced with TLS 1.0,
-         * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption
-         * failure is directly visible from the ciphertext anyway, we should
-         * not reveal which kind of error occurred -- this might become
-         * visible to an attacker (e.g. via a logfile)
-         */
-        al = SSL_AD_BAD_RECORD_MAC;
-        SSLerr(SSL_F_SSL3_GET_RECORD,
-               SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
-        goto f_err;
-    }
-
-    /* r-&gt;length is now just compressed */
-    if (s-&gt;expand != NULL) {
-        if (rr-&gt;length &gt; SSL3_RT_MAX_COMPRESSED_LENGTH + extra) {
-            al = SSL_AD_RECORD_OVERFLOW;
-            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);
-            goto f_err;
-        }
-        if (!ssl3_do_uncompress(s)) {
-            al = SSL_AD_DECOMPRESSION_FAILURE;
-            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_DECOMPRESSION);
-            goto f_err;
-        }
-    }
-
-    if (rr-&gt;length &gt; SSL3_RT_MAX_PLAIN_LENGTH + extra) {
-        al = SSL_AD_RECORD_OVERFLOW;
-        SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);
-        goto f_err;
-    }
-
-    rr-&gt;off = 0;
-    /*-
-     * So at this point the following is true
-     * ssl-&gt;s3-&gt;rrec.type   is the type of record
-     * ssl-&gt;s3-&gt;rrec.length == number of bytes in record
-     * ssl-&gt;s3-&gt;rrec.off    == offset to first valid byte
-     * ssl-&gt;s3-&gt;rrec.data   == where to take bytes from, increment
-     *                         after use :-).
-     */
-
-    /* we have pulled in a full packet so zero things */
-    s-&gt;packet_length = 0;
-
-    /* just read a 0 length packet */
-    if (rr-&gt;length == 0) {
-        empty_record_count++;
-        if (empty_record_count &gt; MAX_EMPTY_RECORDS) {
-            al = SSL_AD_UNEXPECTED_MESSAGE;
-            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_RECORD_TOO_SMALL);
-            goto f_err;
-        }
-        goto again;
-    }
-
-    return (1);
-
- f_err:
-    ssl3_send_alert(s, SSL3_AL_FATAL, al);
- err:
-    return (ret);
-}
-
-int ssl3_do_uncompress(SSL *ssl)
-{
-#ifndef OPENSSL_NO_COMP
-    int i;
-    SSL3_RECORD *rr;
-
-    rr = &amp;(ssl-&gt;s3-&gt;rrec);
-    i = COMP_expand_block(ssl-&gt;expand, rr-&gt;comp,
-                          SSL3_RT_MAX_PLAIN_LENGTH, rr-&gt;data,
-                          (int)rr-&gt;length);
-    if (i &lt; 0)
-        return (0);
-    else
-        rr-&gt;length = i;
-    rr-&gt;data = rr-&gt;comp;
-#endif
-    return (1);
-}
-
-int ssl3_do_compress(SSL *ssl)
-{
-#ifndef OPENSSL_NO_COMP
-    int i;
-    SSL3_RECORD *wr;
-
-    wr = &amp;(ssl-&gt;s3-&gt;wrec);
-    i = COMP_compress_block(ssl-&gt;compress, wr-&gt;data,
-                            SSL3_RT_MAX_COMPRESSED_LENGTH,
-                            wr-&gt;input, (int)wr-&gt;length);
-    if (i &lt; 0)
-        return (0);
-    else
-        wr-&gt;length = i;
-
-    wr-&gt;input = wr-&gt;data;
-#endif
-    return (1);
-}
 
 /*
  * Call this to write data in records of type 'type' It will return &lt;= 0 if
@@ -642,7 +446,7 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
 #if !defined(OPENSSL_NO_MULTIBLOCK) &amp;&amp; EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK
     unsigned int max_send_fragment;
 #endif
-    SSL3_BUFFER *wb = &amp;(s-&gt;s3-&gt;wbuf);
+    SSL3_BUFFER *wb = &amp;s-&gt;rlayer.wbuf;
     int i;
     unsigned int u_len = (unsigned int)len;
 
@@ -652,9 +456,9 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
     }
 
     s-&gt;rwstate = SSL_NOTHING;
-    OPENSSL_assert(s-&gt;s3-&gt;wnum &lt;= INT_MAX);
-    tot = s-&gt;s3-&gt;wnum;
-    s-&gt;s3-&gt;wnum = 0;
+    OPENSSL_assert(s-&gt;rlayer.wnum &lt;= INT_MAX);
+    tot = s-&gt;rlayer.wnum;
+    s-&gt;rlayer.wnum = 0;
 
     if (SSL_in_init(s) &amp;&amp; !s-&gt;in_handshake) {
         i = s-&gt;handshake_func(s);
@@ -685,10 +489,10 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
      * will happen with non blocking IO
      */
     if (wb-&gt;left != 0) {
-        i = ssl3_write_pending(s, type, &amp;buf[tot], s-&gt;s3-&gt;wpend_tot);
+        i = ssl3_write_pending(s, type, &amp;buf[tot], s-&gt;rlayer.wpend_tot);
         if (i &lt;= 0) {
             /* XXX should we ssl3_release_write_buffer if i&lt;0? */
-            s-&gt;s3-&gt;wnum = tot;
+            s-&gt;rlayer.wnum = tot;
             return i;
         }
         tot += i;               /* this might be last fragment */
@@ -749,7 +553,7 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
             if (s-&gt;s3-&gt;alert_dispatch) {
                 i = s-&gt;method-&gt;ssl_dispatch_alert(s);
                 if (i &lt;= 0) {
-                    s-&gt;s3-&gt;wnum = tot;
+                    s-&gt;rlayer.wnum = tot;
                     return i;
                 }
             }
@@ -759,7 +563,7 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
             else
                 nw = max_send_fragment * (mb_param.interleave = 4);
 
-            memcpy(aad, s-&gt;s3-&gt;write_sequence, 8);
+            memcpy(aad, s-&gt;rlayer.write_sequence, 8);
             aad[8] = type;
             aad[9] = (unsigned char)(s-&gt;version &gt;&gt; 8);
             aad[10] = (unsigned char)(s-&gt;version);
@@ -788,19 +592,19 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
                                     sizeof(mb_param), &amp;mb_param) &lt;= 0)
                 return -1;
 
-            s-&gt;s3-&gt;write_sequence[7] += mb_param.interleave;
-            if (s-&gt;s3-&gt;write_sequence[7] &lt; mb_param.interleave) {
+            s-&gt;rlayer.write_sequence[7] += mb_param.interleave;
+            if (s-&gt;rlayer.write_sequence[7] &lt; mb_param.interleave) {
                 int j = 6;
-                while (j &gt;= 0 &amp;&amp; (++s-&gt;s3-&gt;write_sequence[j--]) == 0) ;
+                while (j &gt;= 0 &amp;&amp; (++s-&gt;rlayer.write_sequence[j--]) == 0) ;
             }
 
             wb-&gt;offset = 0;
             wb-&gt;left = packlen;
 
-            s-&gt;s3-&gt;wpend_tot = nw;
-            s-&gt;s3-&gt;wpend_buf = &amp;buf[tot];
-            s-&gt;s3-&gt;wpend_type = type;
-            s-&gt;s3-&gt;wpend_ret = nw;
+            s-&gt;rlayer.wpend_tot = nw;
+            s-&gt;rlayer.wpend_buf = &amp;buf[tot];
+            s-&gt;rlayer.wpend_type = type;
+            s-&gt;rlayer.wpend_ret = nw;
 
             i = ssl3_write_pending(s, type, &amp;buf[tot], nw);
             if (i &lt;= 0) {
@@ -808,7 +612,7 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
                     OPENSSL_free(wb-&gt;buf);
                     wb-&gt;buf = NULL;
                 }
-                s-&gt;s3-&gt;wnum = tot;
+                s-&gt;rlayer.wnum = tot;
                 return i;
             }
             if (i == (int)n) {
@@ -838,7 +642,7 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
         i = do_ssl3_write(s, type, &amp;(buf[tot]), nw, 0);
         if (i &lt;= 0) {
             /* XXX should we ssl3_release_write_buffer if i&lt;0? */
-            s-&gt;s3-&gt;wnum = tot;
+            s-&gt;rlayer.wnum = tot;
             return i;
         }
 
@@ -863,8 +667,8 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)
     }
 }
 
-static int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
-                         unsigned int len, int create_empty_fragment)
+int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
+                  unsigned int len, int create_empty_fragment)
 {
     unsigned char *p, *plen;
     int i, mac_size, clear = 0;
@@ -872,7 +676,7 @@ static int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
     int eivlen;
     long align = 0;
     SSL3_RECORD *wr;
-    SSL3_BUFFER *wb = &amp;(s-&gt;s3-&gt;wbuf);
+    SSL3_BUFFER *wb = &amp;s-&gt;rlayer.wbuf;
     SSL_SESSION *sess;
 
     /*
@@ -897,7 +701,7 @@ static int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
     if (len == 0 &amp;&amp; !create_empty_fragment)
         return 0;
 
-    wr = &amp;(s-&gt;s3-&gt;wrec);
+    wr = &amp;s-&gt;rlayer.wrec;
     sess = s-&gt;session;
 
     if ((sess == NULL) ||
@@ -1081,10 +885,10 @@ static int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
      * memorize arguments so that ssl3_write_pending can detect bad write
      * retries later
      */
-    s-&gt;s3-&gt;wpend_tot = len;
-    s-&gt;s3-&gt;wpend_buf = buf;
-    s-&gt;s3-&gt;wpend_type = type;
-    s-&gt;s3-&gt;wpend_ret = len;
+    s-&gt;rlayer.wpend_tot = len;
+    s-&gt;rlayer.wpend_buf = buf;
+    s-&gt;rlayer.wpend_type = type;
+    s-&gt;rlayer.wpend_ret = len;
 
     /* we now just need to write the buffer */
     return ssl3_write_pending(s, type, buf, len);
@@ -1097,13 +901,13 @@ int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
                        unsigned int len)
 {
     int i;
-    SSL3_BUFFER *wb = &amp;(s-&gt;s3-&gt;wbuf);
+    SSL3_BUFFER *wb = &amp;s-&gt;rlayer.wbuf;
 
 /* XXXX */
-    if ((s-&gt;s3-&gt;wpend_tot &gt; (int)len)
-        || ((s-&gt;s3-&gt;wpend_buf != buf) &amp;&amp;
+    if ((s-&gt;rlayer.wpend_tot &gt; (int)len)
+        || ((s-&gt;rlayer.wpend_buf != buf) &amp;&amp;
             !(s-&gt;mode &amp; SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER))
-        || (s-&gt;s3-&gt;wpend_type != type)) {
+        || (s-&gt;rlayer.wpend_type != type)) {
         SSLerr(SSL_F_SSL3_WRITE_PENDING, SSL_R_BAD_WRITE_RETRY);
         return (-1);
     }
@@ -1123,7 +927,7 @@ int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
             wb-&gt;left = 0;
             wb-&gt;offset += i;
             s-&gt;rwstate = SSL_NOTHING;
-            return (s-&gt;s3-&gt;wpend_ret);
+            return (s-&gt;rlayer.wpend_ret);
         } else if (i &lt;= 0) {
             if (s-&gt;version == DTLS1_VERSION || s-&gt;version == DTLS1_BAD_VER) {
                 /*
@@ -1174,9 +978,11 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
     SSL3_RECORD *rr;
     void (*cb) (const SSL *ssl, int type2, int val) = NULL;
 
-    if (s-&gt;s3-&gt;rbuf.buf == NULL) /* Not initialized yet */
+    if (!SSL3_BUFFER_is_initialised(&amp;s-&gt;rlayer.rbuf)) {
+        /* Not initialized yet */
         if (!ssl3_setup_read_buffer(s))
             return (-1);
+    }
 
     if ((type &amp;&amp; (type != SSL3_RT_APPLICATION_DATA)
          &amp;&amp; (type != SSL3_RT_HANDSHAKE)) || (peek
@@ -1186,29 +992,29 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
         return -1;
     }
 
-    if ((type == SSL3_RT_HANDSHAKE) &amp;&amp; (s-&gt;s3-&gt;handshake_fragment_len &gt; 0))
+    if ((type == SSL3_RT_HANDSHAKE) &amp;&amp; (s-&gt;rlayer.handshake_fragment_len &gt; 0))
         /* (partially) satisfy request from storage */
     {
-        unsigned char *src = s-&gt;s3-&gt;handshake_fragment;
+        unsigned char *src = s-&gt;rlayer.handshake_fragment;
         unsigned char *dst = buf;
         unsigned int k;
 
         /* peek == 0 */
         n = 0;
-        while ((len &gt; 0) &amp;&amp; (s-&gt;s3-&gt;handshake_fragment_len &gt; 0)) {
+        while ((len &gt; 0) &amp;&amp; (s-&gt;rlayer.handshake_fragment_len &gt; 0)) {
             *dst++ = *src++;
             len--;
-            s-&gt;s3-&gt;handshake_fragment_len--;
+            s-&gt;rlayer.handshake_fragment_len--;
             n++;
         }
         /* move any remaining fragment bytes: */
-        for (k = 0; k &lt; s-&gt;s3-&gt;handshake_fragment_len; k++)
-            s-&gt;s3-&gt;handshake_fragment[k] = *src++;
+        for (k = 0; k &lt; s-&gt;rlayer.handshake_fragment_len; k++)
+            s-&gt;rlayer.handshake_fragment[k] = *src++;
         return n;
     }
 
     /*
-     * Now s-&gt;s3-&gt;handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE.
+     * Now s-&gt;rlayer.handshake_fragment_len == 0 if type == SSL3_RT_HANDSHAKE.
      */
 
     if (!s-&gt;in_handshake &amp;&amp; SSL_in_init(s)) {
@@ -1230,10 +1036,10 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
      * s-&gt;s3-&gt;rrec.off,     - offset into 'data' for next read
      * s-&gt;s3-&gt;rrec.length,  - number of bytes.
      */
-    rr = &amp;(s-&gt;s3-&gt;rrec);
+    rr = &amp;s-&gt;rlayer.rrec;
 
     /* get new packet if necessary */
-    if ((rr-&gt;length == 0) || (s-&gt;rstate == SSL_ST_READ_BODY)) {
+    if ((rr-&gt;length == 0) || (s-&gt;rlayer.rstate == SSL_ST_READ_BODY)) {
         ret = ssl3_get_record(s);
         if (ret &lt;= 0)
             return (ret);
@@ -1285,10 +1091,10 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
             rr-&gt;length -= n;
             rr-&gt;off += n;
             if (rr-&gt;length == 0) {
-                s-&gt;rstate = SSL_ST_READ_HEADER;
+                s-&gt;rlayer.rstate = SSL_ST_READ_HEADER;
                 rr-&gt;off = 0;
                 if (s-&gt;mode &amp; SSL_MODE_RELEASE_BUFFERS
-                    &amp;&amp; s-&gt;s3-&gt;rbuf.left == 0)
+                    &amp;&amp; SSL3_BUFFER_get_left(&amp;s-&gt;rlayer.rbuf) == 0)
                     ssl3_release_read_buffer(s);
             }
         }
@@ -1310,18 +1116,19 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
         unsigned int *dest_len = NULL;
 
         if (rr-&gt;type == SSL3_RT_HANDSHAKE) {
-            dest_maxlen = sizeof s-&gt;s3-&gt;handshake_fragment;
-            dest = s-&gt;s3-&gt;handshake_fragment;
-            dest_len = &amp;s-&gt;s3-&gt;handshake_fragment_len;
+            dest_maxlen = sizeof s-&gt;rlayer.handshake_fragment;
+            dest = s-&gt;rlayer.handshake_fragment;
+            dest_len = &amp;s-&gt;rlayer.handshake_fragment_len;
         } else if (rr-&gt;type == SSL3_RT_ALERT) {
-            dest_maxlen = sizeof s-&gt;s3-&gt;alert_fragment;
-            dest = s-&gt;s3-&gt;alert_fragment;
-            dest_len = &amp;s-&gt;s3-&gt;alert_fragment_len;
+            dest_maxlen = sizeof s-&gt;rlayer.alert_fragment;
+            dest = s-&gt;rlayer.alert_fragment;
+            dest_len = &amp;s-&gt;rlayer.alert_fragment_len;
         }
 #ifndef OPENSSL_NO_HEARTBEATS
         else if (rr-&gt;type == TLS1_RT_HEARTBEAT) {
             /* We can ignore 0 return values */
-            if(tls1_process_heartbeat(s) &lt; 0) {
+            if(tls1_process_heartbeat(s, SSL3_RECORD_get_data(&amp;s-&gt;rlayer.rrec),
+                    SSL3_RECORD_get_length(&amp;s-&gt;rlayer.rrec)) &lt; 0) {
                 return -1;
             }
 
@@ -1351,21 +1158,21 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
     }
 
     /*-
-     * s-&gt;s3-&gt;handshake_fragment_len == 4  iff  rr-&gt;type == SSL3_RT_HANDSHAKE;
-     * s-&gt;s3-&gt;alert_fragment_len == 2      iff  rr-&gt;type == SSL3_RT_ALERT.
+     * s-&gt;rlayer.handshake_fragment_len == 4  iff  rr-&gt;type == SSL3_RT_HANDSHAKE;
+     * s-&gt;rlayer.alert_fragment_len == 2      iff  rr-&gt;type == SSL3_RT_ALERT.
      * (Possibly rr is 'empty' now, i.e. rr-&gt;length may be 0.)
      */
 
     /* If we are a client, check for an incoming 'Hello Request': */
     if ((!s-&gt;server) &amp;&amp;
-        (s-&gt;s3-&gt;handshake_fragment_len &gt;= 4) &amp;&amp;
-        (s-&gt;s3-&gt;handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &amp;&amp;
+        (s-&gt;rlayer.handshake_fragment_len &gt;= 4) &amp;&amp;
+        (s-&gt;rlayer.handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &amp;&amp;
         (s-&gt;session != NULL) &amp;&amp; (s-&gt;session-&gt;cipher != NULL)) {
-        s-&gt;s3-&gt;handshake_fragment_len = 0;
+        s-&gt;rlayer.handshake_fragment_len = 0;
 
-        if ((s-&gt;s3-&gt;handshake_fragment[1] != 0) ||
-            (s-&gt;s3-&gt;handshake_fragment[2] != 0) ||
-            (s-&gt;s3-&gt;handshake_fragment[3] != 0)) {
+        if ((s-&gt;rlayer.handshake_fragment[1] != 0) ||
+            (s-&gt;rlayer.handshake_fragment[2] != 0) ||
+            (s-&gt;rlayer.handshake_fragment[3] != 0)) {
             al = SSL_AD_DECODE_ERROR;
             SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST);
             goto f_err;
@@ -1373,7 +1180,7 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
 
         if (s-&gt;msg_callback)
             s-&gt;msg_callback(0, s-&gt;version, SSL3_RT_HANDSHAKE,
-                            s-&gt;s3-&gt;handshake_fragment, 4, s,
+                            s-&gt;rlayer.handshake_fragment, 4, s,
                             s-&gt;msg_callback_arg);
 
         if (SSL_is_init_finished(s) &amp;&amp;
@@ -1391,7 +1198,8 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
                 }
 
                 if (!(s-&gt;mode &amp; SSL_MODE_AUTO_RETRY)) {
-                    if (s-&gt;s3-&gt;rbuf.left == 0) { /* no read-ahead left? */
+                    if (SSL3_BUFFER_get_left(&amp;s-&gt;rlayer.rbuf) == 0) {
+                        /* no read-ahead left? */
                         BIO *bio;
                         /*
                          * In the case where we try to read application data,
@@ -1423,26 +1231,24 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
         SSL_is_init_finished(s) &amp;&amp;
         !s-&gt;s3-&gt;send_connection_binding &amp;&amp;
         (s-&gt;version &gt; SSL3_VERSION) &amp;&amp;
-        (s-&gt;s3-&gt;handshake_fragment_len &gt;= 4) &amp;&amp;
-        (s-&gt;s3-&gt;handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &amp;&amp;
+        (s-&gt;rlayer.handshake_fragment_len &gt;= 4) &amp;&amp;
+        (s-&gt;rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &amp;&amp;
         (s-&gt;session != NULL) &amp;&amp; (s-&gt;session-&gt;cipher != NULL) &amp;&amp;
         !(s-&gt;ctx-&gt;options &amp; SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
-        /*
-         * s-&gt;s3-&gt;handshake_fragment_len = 0;
-         */
         rr-&gt;length = 0;
         ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);
         goto start;
     }
-    if (s-&gt;s3-&gt;alert_fragment_len &gt;= 2) {
-        int alert_level = s-&gt;s3-&gt;alert_fragment[0];
-        int alert_descr = s-&gt;s3-&gt;alert_fragment[1];
+    if (s-&gt;rlayer.alert_fragment_len &gt;= 2) {
+        int alert_level = s-&gt;rlayer.alert_fragment[0];
+        int alert_descr = s-&gt;rlayer.alert_fragment[1];
 
-        s-&gt;s3-&gt;alert_fragment_len = 0;
+        s-&gt;rlayer.alert_fragment_len = 0;
 
         if (s-&gt;msg_callback)
             s-&gt;msg_callback(0, s-&gt;version, SSL3_RT_ALERT,
-                            s-&gt;s3-&gt;alert_fragment, 2, s, s-&gt;msg_callback_arg);
+                            s-&gt;rlayer.alert_fragment, 2, s,
+                            s-&gt;msg_callback_arg);
 
         if (s-&gt;info_callback != NULL)
             cb = s-&gt;info_callback;
@@ -1547,7 +1353,7 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
     /*
      * Unexpected handshake message (Client Hello, or protocol violation)
      */
-    if ((s-&gt;s3-&gt;handshake_fragment_len &gt;= 4) &amp;&amp; !s-&gt;in_handshake) {
+    if ((s-&gt;rlayer.handshake_fragment_len &gt;= 4) &amp;&amp; !s-&gt;in_handshake) {
         if (((s-&gt;state &amp; SSL_ST_MASK) == SSL_ST_OK) &amp;&amp;
             !(s-&gt;s3-&gt;flags &amp; SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) {
             s-&gt;state = s-&gt;server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;
@@ -1563,7 +1369,8 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
         }
 
         if (!(s-&gt;mode &amp; SSL_MODE_AUTO_RETRY)) {
-            if (s-&gt;s3-&gt;rbuf.left == 0) { /* no read-ahead left? */
+            if (SSL3_BUFFER_get_left(&amp;s-&gt;rlayer.rbuf) == 0) {
+                /* no read-ahead left? */
                 BIO *bio;
                 /*
                  * In the case where we try to read application data, but we
@@ -1639,113 +1446,15 @@ int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek)
     return (-1);
 }
 
-int ssl3_do_change_cipher_spec(SSL *s)
+void ssl3_record_sequence_update(unsigned char *seq)
 {
     int i;
-    const char *sender;
-    int slen;
-
-    if (s-&gt;state &amp; SSL_ST_ACCEPT)
-        i = SSL3_CHANGE_CIPHER_SERVER_READ;
-    else
-        i = SSL3_CHANGE_CIPHER_CLIENT_READ;
-
-    if (s-&gt;s3-&gt;tmp.key_block == NULL) {
-        if (s-&gt;session == NULL || s-&gt;session-&gt;master_key_length == 0) {
-            /* might happen if dtls1_read_bytes() calls this */
-            SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,
-                   SSL_R_CCS_RECEIVED_EARLY);
-            return (0);
-        }
-
-        s-&gt;session-&gt;cipher = s-&gt;s3-&gt;tmp.new_cipher;
-        if (!s-&gt;method-&gt;ssl3_enc-&gt;setup_key_block(s))
-            return (0);
-    }
-
-    if (!s-&gt;method-&gt;ssl3_enc-&gt;change_cipher_state(s, i))
-        return (0);
-
-    /*
-     * we have to record the message digest at this point so we can get it
-     * before we read the finished message
-     */
-    if (s-&gt;state &amp; SSL_ST_CONNECT) {
-        sender = s-&gt;method-&gt;ssl3_enc-&gt;server_finished_label;
-        slen = s-&gt;method-&gt;ssl3_enc-&gt;server_finished_label_len;
-    } else {
-        sender = s-&gt;method-&gt;ssl3_enc-&gt;client_finished_label;
-        slen = s-&gt;method-&gt;ssl3_enc-&gt;client_finished_label_len;
-    }
 
-    i = s-&gt;method-&gt;ssl3_enc-&gt;final_finish_mac(s,
-                                              sender, slen,
-                                              s-&gt;s3-&gt;tmp.peer_finish_md);
-    if (i == 0) {
-        SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);
-        return 0;
+    for (i = 7; i &gt;= 0; i--) {
+        ++seq[i];
+        if (seq[i] != 0)
+            break;
     }
-    s-&gt;s3-&gt;tmp.peer_finish_md_len = i;
-
-    return (1);
-}
-
-int ssl3_send_alert(SSL *s, int level, int desc)
-{
-    /* Map tls/ssl alert value to correct one */
-    desc = s-&gt;method-&gt;ssl3_enc-&gt;alert_value(desc);
-    if (s-&gt;version == SSL3_VERSION &amp;&amp; desc == SSL_AD_PROTOCOL_VERSION)
-        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have
-                                          * protocol_version alerts */
-    if (desc &lt; 0)
-        return -1;
-    /* If a fatal one, remove from cache */
-    if ((level == SSL3_AL_FATAL) &amp;&amp; (s-&gt;session != NULL))
-        SSL_CTX_remove_session(s-&gt;ctx, s-&gt;session);
-
-    s-&gt;s3-&gt;alert_dispatch = 1;
-    s-&gt;s3-&gt;send_alert[0] = level;
-    s-&gt;s3-&gt;send_alert[1] = desc;
-    if (s-&gt;s3-&gt;wbuf.left == 0)  /* data still being written out? */
-        return s-&gt;method-&gt;ssl_dispatch_alert(s);
-    /*
-     * else data is still being written out, we will get written some time in
-     * the future
-     */
-    return -1;
 }
 
-int ssl3_dispatch_alert(SSL *s)
-{
-    int i, j;
-    void (*cb) (const SSL *ssl, int type, int val) = NULL;
-
-    s-&gt;s3-&gt;alert_dispatch = 0;
-    i = do_ssl3_write(s, SSL3_RT_ALERT, &amp;s-&gt;s3-&gt;send_alert[0], 2, 0);
-    if (i &lt;= 0) {
-        s-&gt;s3-&gt;alert_dispatch = 1;
-    } else {
-        /*
-         * Alert sent to BIO.  If it is important, flush it now. If the
-         * message does not get sent due to non-blocking IO, we will not
-         * worry too much.
-         */
-        if (s-&gt;s3-&gt;send_alert[0] == SSL3_AL_FATAL)
-            (void)BIO_flush(s-&gt;wbio);
-
-        if (s-&gt;msg_callback)
-            s-&gt;msg_callback(1, s-&gt;version, SSL3_RT_ALERT, s-&gt;s3-&gt;send_alert,
-                            2, s, s-&gt;msg_callback_arg);
-
-        if (s-&gt;info_callback != NULL)
-            cb = s-&gt;info_callback;
-        else if (s-&gt;ctx-&gt;info_callback != NULL)
-            cb = s-&gt;ctx-&gt;info_callback;
 
-        if (cb != NULL) {
-            j = (s-&gt;s3-&gt;send_alert[0] &lt;&lt; 8) | s-&gt;s3-&gt;send_alert[1];
-            cb(s, SSL_CB_WRITE_ALERT, j);
-        }
-    }
-    return (i);
-}
diff --git a/ssl/record/record.h b/ssl/record/record.h
new file mode 100644
index 0000000..29c74d7
--- /dev/null
+++ b/ssl/record/record.h
@@ -0,0 +1,345 @@
+/* ssl/record/record.h */
+/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    &quot;This product includes cryptographic software written by
+ *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+/* ====================================================================
+ * Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+ *
+ * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+ *    nor may &quot;OpenSSL&quot; appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+ * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+ *
+ */
+
+/*****************************************************************************
+ *                                                                           *
+ * These structures should be considered PRIVATE to the record layer. No     *
+ * non-record layer code should be using these structures in any way.        *
+ *                                                                           *
+ *****************************************************************************/
+
+typedef struct ssl3_buffer_st {
+    /* at least SSL3_RT_MAX_PACKET_SIZE bytes, see ssl3_setup_buffers() */
+    unsigned char *buf;
+    /* buffer size */
+    size_t len;
+    /* where to 'copy from' */
+    int offset;
+    /* how many bytes left */
+    int left;
+} SSL3_BUFFER;
+
+#define SEQ_NUM_SIZE                            8
+
+typedef struct ssl3_record_st {
+    /* type of record */
+    /* r */
+    int type;
+
+    /* How many bytes available */
+    /* rw */
+    unsigned int length;
+
+    /*
+     * How many bytes were available before padding was removed? This is used
+     * to implement the MAC check in constant time for CBC records.
+     */
+    /* rw */
+    unsigned int orig_len;
+
+    /* read/write offset into 'buf' */
+    /* r */
+    unsigned int off;
+
+    /* pointer to the record data */
+    /* rw */
+    unsigned char *data;
+
+    /* where the decode bytes are */
+    /* rw */
+    unsigned char *input;
+
+    /* only used with decompression - malloc()ed */
+    /* r */
+    unsigned char *comp;
+
+    /* epoch number, needed by DTLS1 */
+    /* r */
+    unsigned long epoch;
+
+    /* sequence number, needed by DTLS1 */
+    /* r */
+    unsigned char seq_num[SEQ_NUM_SIZE];
+} SSL3_RECORD;
+
+typedef struct dtls1_bitmap_st {
+    /* Track 32 packets on 32-bit systems and 64 - on 64-bit systems */
+    unsigned long map;
+
+    /* Max record number seen so far, 64-bit value in big-endian encoding */
+    unsigned char max_seq_num[SEQ_NUM_SIZE];
+} DTLS1_BITMAP;
+
+typedef struct record_pqueue_st {
+    unsigned short epoch;
+    pqueue q;
+} record_pqueue;
+
+typedef struct dtls1_record_data_st {
+    unsigned char *packet;
+    unsigned int packet_length;
+    SSL3_BUFFER rbuf;
+    SSL3_RECORD rrec;
+#  ifndef OPENSSL_NO_SCTP
+    struct bio_dgram_sctp_rcvinfo recordinfo;
+#  endif
+} DTLS1_RECORD_DATA;
+
+
+typedef struct dtls_record_layer_st {
+    /*
+     * The current data and handshake epoch.  This is initially
+     * undefined, and starts at zero once the initial handshake is
+     * completed
+     */
+    unsigned short r_epoch;
+    unsigned short w_epoch;
+
+    /* records being received in the current epoch */
+    DTLS1_BITMAP bitmap;
+    /* renegotiation starts a new set of sequence numbers */
+    DTLS1_BITMAP next_bitmap;
+
+    /* Received handshake records (processed and unprocessed) */
+    record_pqueue unprocessed_rcds;
+    record_pqueue processed_rcds;
+    /*
+     * Buffered application records. Only for records between CCS and
+     * Finished to prevent either protocol violation or unnecessary message
+     * loss.
+     */
+    record_pqueue buffered_app_data;
+    /*
+     * storage for Alert/Handshake protocol data received but not yet
+     * processed by ssl3_read_bytes:
+     */
+    unsigned char alert_fragment[DTLS1_AL_HEADER_LENGTH];
+    unsigned int alert_fragment_len;
+    unsigned char handshake_fragment[DTLS1_HM_HEADER_LENGTH];
+    unsigned int handshake_fragment_len;
+
+    /* save last and current sequence numbers for retransmissions */
+    unsigned char last_write_sequence[8];
+    unsigned char curr_write_sequence[8];
+} DTLS_RECORD_LAYER;
+
+/*****************************************************************************
+ *                                                                           *
+ * This structure should be considered &quot;opaque&quot; to anything outside of the   *
+ * record layer. No non-record layer code should be accessing the members of *
+ * this structure.                                                           *
+ *                                                                           *
+ *****************************************************************************/
+
+typedef struct record_layer_st {
+    /* The parent SSL structure */
+    SSL *s;
+    /*
+     * Read as many input bytes as possible (for
+     * non-blocking reads)
+     */
+    int read_ahead;
+    /* where we are when reading */
+    int rstate;
+    /* read IO goes into here */
+    SSL3_BUFFER rbuf;
+    /* write IO goes into here */
+    SSL3_BUFFER wbuf;
+    /* each decoded record goes in here */
+    SSL3_RECORD rrec;
+    /* goes out from here */
+    SSL3_RECORD wrec;
+
+    /* used internally to point at a raw packet */
+    unsigned char *packet;
+    unsigned int packet_length;
+
+    /* number of bytes sent so far */
+    unsigned int wnum;
+
+    /*
+     * storage for Alert/Handshake protocol data received but not yet
+     * processed by ssl3_read_bytes:
+     */
+    unsigned char alert_fragment[2];
+    unsigned int alert_fragment_len;
+    unsigned char handshake_fragment[4];
+    unsigned int handshake_fragment_len;
+
+    /* partial write - check the numbers match */
+    /* number bytes written */
+    int wpend_tot;
+    int wpend_type;
+    /* number of bytes submitted */
+    int wpend_ret;
+    const unsigned char *wpend_buf;
+
+    unsigned char read_sequence[8];
+    unsigned char write_sequence[8];
+    
+    DTLS_RECORD_LAYER *d;
+} RECORD_LAYER;
+
+
+/*****************************************************************************
+ *                                                                           *
+ * The following macros/functions represent the libssl internal API to the   *
+ * record layer. Any libssl code may call these functions/macros             *
+ *                                                                           *
+ *****************************************************************************/
+
+#define RECORD_LAYER_set_read_ahead(rl, ra)     ((rl)-&gt;read_ahead = (ra))
+#define RECORD_LAYER_get_read_ahead(rl)         ((rl)-&gt;read_ahead)
+#define RECORD_LAYER_get_packet(rl)             ((rl)-&gt;packet)
+#define RECORD_LAYER_get_packet_length(rl)      ((rl)-&gt;packet_length)
+#define RECORD_LAYER_add_packet_length(rl, inc) ((rl)-&gt;packet_length += (inc))
+#define DTLS_RECORD_LAYER_get_w_epoch(rl)       ((rl)-&gt;d-&gt;w_epoch)
+#define DTLS_RECORD_LAYER_get_processed_rcds(rl) \
+                                                ((rl)-&gt;d-&gt;processed_rcds)
+#define DTLS_RECORD_LAYER_get_unprocessed_rcds(rl) \
+                                                ((rl)-&gt;d-&gt;unprocessed_rcds)
+
+void RECORD_LAYER_init(RECORD_LAYER *rl, SSL *s);
+void RECORD_LAYER_clear(RECORD_LAYER *rl);
+void RECORD_LAYER_release(RECORD_LAYER *rl);
+int RECORD_LAYER_read_pending(RECORD_LAYER *rl);
+int RECORD_LAYER_write_pending(RECORD_LAYER *rl);
+int RECORD_LAYER_set_data(RECORD_LAYER *rl, const unsigned char *buf, int len);
+void RECORD_LAYER_dup(RECORD_LAYER *dst, RECORD_LAYER *src);
+void RECORD_LAYER_reset_read_sequence(RECORD_LAYER *rl);
+void RECORD_LAYER_reset_write_sequence(RECORD_LAYER *rl);
+int RECORD_LAYER_setup_comp_buffer(RECORD_LAYER *rl);
+__owur int ssl3_pending(const SSL *s);
+__owur int ssl23_read_bytes(SSL *s, int n);
+__owur int ssl23_write_bytes(SSL *s);
+__owur int ssl3_write_bytes(SSL *s, int type, const void *buf, int len);
+__owur int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
+                         unsigned int len, int create_empty_fragment);
+__owur int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek);
+__owur int ssl3_setup_buffers(SSL *s);
+__owur int ssl3_enc(SSL *s, int send_data);
+__owur int n_ssl3_mac(SSL *ssl, unsigned char *md, int send_data);
+__owur int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
+                       unsigned int len);
+__owur int tls1_enc(SSL *s, int snd);
+__owur int tls1_mac(SSL *ssl, unsigned char *md, int snd);
+int DTLS_RECORD_LAYER_new(RECORD_LAYER *rl);
+void DTLS_RECORD_LAYER_free(RECORD_LAYER *rl);
+void DTLS_RECORD_LAYER_clear(RECORD_LAYER *rl);
+void DTLS_RECORD_LAYER_set_saved_w_epoch(RECORD_LAYER *rl, unsigned short e);
+void DTLS_RECORD_LAYER_clear(RECORD_LAYER *rl);
+void DTLS_RECORD_LAYER_resync_write(RECORD_LAYER *rl);
+__owur int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek);
+__owur int dtls1_write_bytes(SSL *s, int type, const void *buf, int len);
+__owur int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
+                   unsigned int len, int create_empty_fragement);
+void dtls1_reset_seq_numbers(SSL *s, int rw);
+
diff --git a/crypto/rand/rand_nw.c b/ssl/record/record_locl.h
similarity index 59%
copy from crypto/rand/rand_nw.c
copy to ssl/record/record_locl.h
index 76ef70c..26b5a15 100644
--- a/crypto/rand/rand_nw.c
+++ b/ssl/record/record_locl.h
@@ -1,4 +1,4 @@
-/* crypto/rand/rand_nw.c */
+/* ssl/record/record_locl.h */
 /* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
  * All rights reserved.
  *
@@ -56,7 +56,7 @@
  * [including the GNU Public Licence.]
  */
 /* ====================================================================
- * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -109,71 +109,82 @@
  *
  */
 
-#include &quot;cryptlib.h&quot;
-#include &lt;openssl/rand.h&gt;
-#include &quot;rand_lcl.h&quot;
 
-#if defined (OPENSSL_SYS_NETWARE)
+/*****************************************************************************
+ *                                                                           *
+ * The following macros/functions are PRIVATE to the record layer. They      *
+ * should NOT be used outside of the record layer.                           *
+ *                                                                           *
+ *****************************************************************************/
 
-# if defined(NETWARE_LIBC)
-#  include &lt;nks/thread.h&gt;
-# else
-#  include &lt;nwthread.h&gt;
-# endif
+/* Functions/macros provided by the RECORD_LAYER component */
 
-extern int GetProcessSwitchCount(void);
-# if !defined(NETWARE_LIBC) || (CURRENT_NDK_THRESHOLD &lt; 509220000)
-extern void *RunningProcess;    /* declare here same as found in newer NDKs */
-extern unsigned long GetSuperHighResolutionTimer(void);
-# endif
+#define RECORD_LAYER_get_rbuf(rl)               (&amp;(rl)-&gt;rbuf)
+#define RECORD_LAYER_get_wbuf(rl)               (&amp;(rl)-&gt;wbuf)
+#define RECORD_LAYER_get_rrec(rl)               (&amp;(rl)-&gt;rrec)
+#define RECORD_LAYER_get_wrec(rl)               (&amp;(rl)-&gt;wrec)
+#define RECORD_LAYER_set_packet(rl, p)          ((rl)-&gt;packet = (p))
+#define RECORD_LAYER_reset_packet_length(rl)    ((rl)-&gt;packet_length = 0)
+#define RECORD_LAYER_get_rstate(rl)             ((rl)-&gt;rstate)
+#define RECORD_LAYER_set_rstate(rl, st)         ((rl)-&gt;rstate = (st))
+#define RECORD_LAYER_get_read_sequence(rl)      ((rl)-&gt;read_sequence)
+#define RECORD_LAYER_get_write_sequence(rl)     ((rl)-&gt;write_sequence)
+#define DTLS_RECORD_LAYER_get_r_epoch(rl)       ((rl)-&gt;d-&gt;r_epoch)
 
-   /*
-    * the FAQ indicates we need to provide at least 20 bytes (160 bits) of
-    * seed
-    */
-int RAND_poll(void)
-{
-    unsigned long l;
-    unsigned long tsc;
-    int i;
+__owur int ssl3_read_n(SSL *s, int n, int max, int extend);
 
-    /*
-     * There are several options to gather miscellaneous data but for now we
-     * will loop checking the time stamp counter (rdtsc) and the
-     * SuperHighResolutionTimer.  Each iteration will collect 8 bytes of data
-     * but it is treated as only 1 byte of entropy.  The call to
-     * ThreadSwitchWithDelay() will introduce additional variability into the
-     * data returned by rdtsc. Applications can argument the seed material
-     * by adding additional stuff with RAND_add() and should probably do so.
-     */
-    l = GetProcessSwitchCount();
-    RAND_add(&amp;l, sizeof(l), 1);
+void RECORD_LAYER_set_write_sequence(RECORD_LAYER *rl, const unsigned char *ws);
+DTLS1_BITMAP *dtls1_get_bitmap(SSL *s, SSL3_RECORD *rr,
+                                      unsigned int *is_next_epoch);
+int dtls1_process_buffered_records(SSL *s);
+int dtls1_retrieve_buffered_record(SSL *s, record_pqueue *queue);
+int dtls1_buffer_record(SSL *s, record_pqueue *q,
+                               unsigned char *priority);
+void ssl3_record_sequence_update(unsigned char *seq);
 
-    /* need to cast the void* to unsigned long here */
-    l = (unsigned long)RunningProcess;
-    RAND_add(&amp;l, sizeof(l), 1);
+/* Functions provided by the DTLS1_BITMAP component */
 
-    for (i = 2; i &lt; ENTROPY_NEEDED; i++) {
-# ifdef __MWERKS__
-        asm {
-        rdtsc mov tsc, eax}
-# elif defined(__GNUC__) &amp;&amp; __GNUC__&gt;=2 &amp;&amp; !defined(OPENSSL_NO_ASM) &amp;&amp; !defined(OPENSSL_NO_INLINE_ASM)
-        asm volatile (&quot;rdtsc&quot;:&quot;=a&quot; (tsc)::&quot;edx&quot;);
-# endif
+int dtls1_record_replay_check(SSL *s, DTLS1_BITMAP *bitmap);
+void dtls1_record_bitmap_update(SSL *s, DTLS1_BITMAP *bitmap);
 
-        RAND_add(&amp;tsc, sizeof(tsc), 1);
 
-        l = GetSuperHighResolutionTimer();
-        RAND_add(&amp;l, sizeof(l), 0);
+/* Macros/functions provided by the SSL3_BUFFER component */
 
-# if defined(NETWARE_LIBC)
-        NXThreadYield();
-# else                          /* NETWARE_CLIB */
-        ThreadSwitchWithDelay();
-# endif
-    }
+#define SSL3_BUFFER_get_buf(b)              ((b)-&gt;buf)
+#define SSL3_BUFFER_set_buf(b, n)           ((b)-&gt;buf = (n))
+#define SSL3_BUFFER_get_len(b)              ((b)-&gt;len)
+#define SSL3_BUFFER_set_len(b, l)           ((b)-&gt;len = (l))
+#define SSL3_BUFFER_get_left(b)             ((b)-&gt;left)
+#define SSL3_BUFFER_is_initialised(b)       ((b)-&gt;buf != NULL)
 
-    return 1;
-}
+void SSL3_BUFFER_set_data(SSL3_BUFFER *b, const unsigned char *d, int n);
+void SSL3_BUFFER_release(SSL3_BUFFER *b);
+__owur int ssl3_setup_read_buffer(SSL *s);
+__owur int ssl3_setup_write_buffer(SSL *s);
+int ssl3_release_read_buffer(SSL *s);
+int ssl3_release_write_buffer(SSL *s);
 
-#endif
+/* Macros/functions provided by the SSL3_RECORD component */
+
+#define SSL3_RECORD_get_type(r)                 ((r)-&gt;type)
+#define SSL3_RECORD_get_length(r)               ((r)-&gt;length)
+#define SSL3_RECORD_get_data(r)                 ((r)-&gt;data)
+#define SSL3_RECORD_get_seq_num(r)              ((r)-&gt;seq_num)
+
+void SSL3_RECORD_clear(SSL3_RECORD *r);
+void SSL3_RECORD_release(SSL3_RECORD *r);
+int SSL3_RECORD_setup(SSL3_RECORD *r);
+void SSL3_RECORD_set_seq_num(SSL3_RECORD *r, const unsigned char *seq_num);
+int ssl3_get_record(SSL *s);
+__owur int ssl3_do_compress(SSL *ssl);
+__owur int ssl3_do_uncompress(SSL *ssl);
+void ssl3_cbc_copy_mac(unsigned char *out,
+                       const SSL3_RECORD *rec, unsigned md_size);
+__owur int ssl3_cbc_remove_padding(const SSL *s,
+                            SSL3_RECORD *rec,
+                            unsigned block_size, unsigned mac_size);
+__owur int tls1_cbc_remove_padding(const SSL *s,
+                            SSL3_RECORD *rec,
+                            unsigned block_size, unsigned mac_size);
+int dtls1_process_record(SSL *s);
+__owur int dtls1_get_record(SSL *s);
diff --git a/apps/app_rand.c b/ssl/record/ssl3_buffer.c
similarity index 65%
copy from apps/app_rand.c
copy to ssl/record/ssl3_buffer.c
index 595fc78..79a7636 100644
--- a/apps/app_rand.c
+++ b/ssl/record/ssl3_buffer.c
@@ -1,4 +1,4 @@
-/* apps/app_rand.c */
+/* ssl/record/ssl3_buffer.c */
 /* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
  * All rights reserved.
  *
@@ -56,7 +56,7 @@
  * [including the GNU Public Licence.]
  */
 /* ====================================================================
- * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -109,112 +109,136 @@
  *
  */
 
-#define NON_MAIN
-#include &quot;apps.h&quot;
-#undef NON_MAIN
-#include &lt;openssl/bio.h&gt;
-#include &lt;openssl/rand.h&gt;
+#include &quot;../ssl_locl.h&quot;
+#include &quot;record_locl.h&quot;
 
-static int seeded = 0;
-static int egdsocket = 0;
+void SSL3_BUFFER_set_data(SSL3_BUFFER *b, const unsigned char *d, int n)
+{
+    if(d != NULL)
+        memcpy(b-&gt;buf, d, n);
+    b-&gt;left = n;
+    b-&gt;offset = 0;
+}
+
+void SSL3_BUFFER_release(SSL3_BUFFER *b)
+{
+    if (b-&gt;buf != NULL)
+        OPENSSL_free(b-&gt;buf);
+    b-&gt;buf = NULL;
+}
 
-int app_RAND_load_file(const char *file, BIO *bio_e, int dont_warn)
+int ssl3_setup_read_buffer(SSL *s)
 {
-    int consider_randfile = (file == NULL);
-    char buffer[200];
-
-#ifdef OPENSSL_SYS_WINDOWS
-    BIO_printf(bio_e, &quot;Loading 'screen' into random state -&quot;);
-    BIO_flush(bio_e);
-    RAND_screen();
-    BIO_printf(bio_e, &quot; done\n&quot;);
+    unsigned char *p;
+    size_t len, align = 0, headerlen;
+    SSL3_BUFFER *b;
+    
+    b = RECORD_LAYER_get_rbuf(&amp;s-&gt;rlayer);
+
+    if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
+        headerlen = DTLS1_RT_HEADER_LENGTH;
+    else
+        headerlen = SSL3_RT_HEADER_LENGTH;
+
+#if defined(SSL3_ALIGN_PAYLOAD) &amp;&amp; SSL3_ALIGN_PAYLOAD!=0
+    align = (-SSL3_RT_HEADER_LENGTH) &amp; (SSL3_ALIGN_PAYLOAD - 1);
 #endif
 
-    if (file == NULL)
-        file = RAND_file_name(buffer, sizeof buffer);
-    else if (RAND_egd(file) &gt; 0) {
-        /*
-         * we try if the given filename is an EGD socket. if it is, we don't
-         * write anything back to the file.
-         */
-        egdsocket = 1;
-        return 1;
-    }
-    if (file == NULL || !RAND_load_file(file, -1)) {
-        if (RAND_status() == 0) {
-            if (!dont_warn) {
-                BIO_printf(bio_e, &quot;unable to load 'random state'\n&quot;);
-                BIO_printf(bio_e,
-                           &quot;This means that the random number generator has not been seeded\n&quot;);
-                BIO_printf(bio_e, &quot;with much random data.\n&quot;);
-                if (consider_randfile) { /* explanation does not apply when a
-                                          * file is explicitly named */
-                    BIO_printf(bio_e,
-                               &quot;Consider setting the RANDFILE environment variable to point at a file that\n&quot;);
-                    BIO_printf(bio_e,
-                               &quot;'random' data can be kept in (the file will be overwritten).\n&quot;);
-                }
-            }
-            return 0;
+    if (b-&gt;buf == NULL) {
+        len = SSL3_RT_MAX_PLAIN_LENGTH
+            + SSL3_RT_MAX_ENCRYPTED_OVERHEAD + headerlen + align;
+        if (s-&gt;options &amp; SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER) {
+            s-&gt;s3-&gt;init_extra = 1;
+            len += SSL3_RT_MAX_EXTRA;
         }
+#ifndef OPENSSL_NO_COMP
+        if (ssl_allow_compression(s))
+            len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
+#endif
+        if ((p = OPENSSL_malloc(len)) == NULL)
+            goto err;
+        b-&gt;buf = p;
+        b-&gt;len = len;
     }
-    seeded = 1;
+
+    RECORD_LAYER_set_packet(&amp;s-&gt;rlayer, &amp;(b-&gt;buf[0]));
     return 1;
+
+ err:
+    SSLerr(SSL_F_SSL3_SETUP_READ_BUFFER, ERR_R_MALLOC_FAILURE);
+    return 0;
 }
 
-long app_RAND_load_files(char *name)
+int ssl3_setup_write_buffer(SSL *s)
 {
-    char *p, *n;
-    int last;
-    long tot = 0;
-    int egd;
-
-    for (;;) {
-        last = 0;
-        for (p = name; ((*p != '\0') &amp;&amp; (*p != LIST_SEPARATOR_CHAR)); p++) ;
-        if (*p == '\0')
-            last = 1;
-        *p = '\0';
-        n = name;
-        name = p + 1;
-        if (*n == '\0')
-            break;
-
-        egd = RAND_egd(n);
-        if (egd &gt; 0)
-            tot += egd;
-        else
-            tot += RAND_load_file(n, -1);
-        if (last)
-            break;
+    unsigned char *p;
+    size_t len, align = 0, headerlen;
+    SSL3_BUFFER *wb;
+
+    wb = RECORD_LAYER_get_wbuf(&amp;s-&gt;rlayer);
+
+    if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
+        headerlen = DTLS1_RT_HEADER_LENGTH + 1;
+    else
+        headerlen = SSL3_RT_HEADER_LENGTH;
+
+#if defined(SSL3_ALIGN_PAYLOAD) &amp;&amp; SSL3_ALIGN_PAYLOAD!=0
+    align = (-SSL3_RT_HEADER_LENGTH) &amp; (SSL3_ALIGN_PAYLOAD - 1);
+#endif
+
+    if (wb-&gt;buf == NULL) {
+        len = s-&gt;max_send_fragment
+            + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD + headerlen + align;
+#ifndef OPENSSL_NO_COMP
+        if (ssl_allow_compression(s))
+            len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
+#endif
+        if (!(s-&gt;options &amp; SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
+            len += headerlen + align + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD;
+
+        if ((p = OPENSSL_malloc(len)) == NULL)
+            goto err;
+        wb-&gt;buf = p;
+        wb-&gt;len = len;
     }
-    if (tot &gt; 512)
-        app_RAND_allow_write_file();
-    return (tot);
+
+    return 1;
+
+ err:
+    SSLerr(SSL_F_SSL3_SETUP_WRITE_BUFFER, ERR_R_MALLOC_FAILURE);
+    return 0;
 }
 
-int app_RAND_write_file(const char *file, BIO *bio_e)
+int ssl3_setup_buffers(SSL *s)
 {
-    char buffer[200];
-
-    if (egdsocket || !seeded)
-        /*
-         * If we did not manage to read the seed file, we should not write a
-         * low-entropy seed file back -- it would suppress a crucial warning
-         * the next time we want to use it.
-         */
+    if (!ssl3_setup_read_buffer(s))
         return 0;
-
-    if (file == NULL)
-        file = RAND_file_name(buffer, sizeof buffer);
-    if (file == NULL || !RAND_write_file(file)) {
-        BIO_printf(bio_e, &quot;unable to write 'random state'\n&quot;);
+    if (!ssl3_setup_write_buffer(s))
         return 0;
+    return 1;
+}
+
+int ssl3_release_write_buffer(SSL *s)
+{
+    SSL3_BUFFER *wb;
+
+    wb = RECORD_LAYER_get_wbuf(&amp;s-&gt;rlayer);
+
+    if (wb-&gt;buf != NULL) {
+        OPENSSL_free(wb-&gt;buf);
+        wb-&gt;buf = NULL;
     }
     return 1;
 }
 
-void app_RAND_allow_write_file(void)
+int ssl3_release_read_buffer(SSL *s)
 {
-    seeded = 1;
+    SSL3_BUFFER *b;
+
+    b = RECORD_LAYER_get_rbuf(&amp;s-&gt;rlayer);
+    if (b-&gt;buf != NULL) {
+        OPENSSL_free(b-&gt;buf);
+        b-&gt;buf = NULL;
+    }
+    return 1;
 }
diff --git a/ssl/record/ssl3_record.c b/ssl/record/ssl3_record.c
new file mode 100644
index 0000000..cfd8290
--- /dev/null
+++ b/ssl/record/ssl3_record.c
@@ -0,0 +1,1558 @@
+/* ssl/record/ssl3_record.c */
+/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    &quot;This product includes cryptographic software written by
+ *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+/* ====================================================================
+ * Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+ *
+ * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+ *    nor may &quot;OpenSSL&quot; appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+ * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+ *
+ */
+
+#include &quot;../ssl_locl.h&quot;
+#include &quot;../../crypto/constant_time_locl.h&quot;
+#include &lt;openssl/rand.h&gt;
+#include &quot;record_locl.h&quot;
+
+static const unsigned char ssl3_pad_1[48] = {
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
+    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
+};
+
+static const unsigned char ssl3_pad_2[48] = {
+    0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
+    0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
+    0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
+    0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
+    0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
+    0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c
+};
+
+void SSL3_RECORD_clear(SSL3_RECORD *r)
+{
+    memset(r-&gt;seq_num, 0, sizeof(r-&gt;seq_num));
+}
+
+void SSL3_RECORD_release(SSL3_RECORD *r)
+{
+    if (r-&gt;comp != NULL)
+        OPENSSL_free(r-&gt;comp);
+    r-&gt;comp = NULL;
+}
+
+int SSL3_RECORD_setup(SSL3_RECORD *r)
+{
+    if (r-&gt;comp == NULL)
+        r-&gt;comp = (unsigned char *)
+            OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
+    if (r-&gt;comp == NULL)
+        return 0;
+    return 1;
+}
+
+void SSL3_RECORD_set_seq_num(SSL3_RECORD *r, const unsigned char *seq_num)
+{
+    memcpy(r-&gt;seq_num, seq_num, SEQ_NUM_SIZE);
+}
+
+/*
+ * MAX_EMPTY_RECORDS defines the number of consecutive, empty records that
+ * will be processed per call to ssl3_get_record. Without this limit an
+ * attacker could send empty records at a faster rate than we can process and
+ * cause ssl3_get_record to loop forever.
+ */
+#define MAX_EMPTY_RECORDS 32
+
+/*-
+ * Call this to get a new input record.
+ * It will return &lt;= 0 if more data is needed, normally due to an error
+ * or non-blocking IO.
+ * When it finishes, one packet has been decoded and can be found in
+ * ssl-&gt;s3-&gt;rrec.type    - is the type of record
+ * ssl-&gt;s3-&gt;rrec.data,   - data
+ * ssl-&gt;s3-&gt;rrec.length, - number of bytes
+ */
+/* used only by ssl3_read_bytes */
+int ssl3_get_record(SSL *s)
+{
+    int ssl_major, ssl_minor, al;
+    int enc_err, n, i, ret = -1;
+    SSL3_RECORD *rr;
+    SSL_SESSION *sess;
+    unsigned char *p;
+    unsigned char md[EVP_MAX_MD_SIZE];
+    short version;
+    unsigned mac_size;
+    size_t extra;
+    unsigned empty_record_count = 0;
+
+    rr = RECORD_LAYER_get_rrec(&amp;s-&gt;rlayer);
+    sess = s-&gt;session;
+
+    if (s-&gt;options &amp; SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)
+        extra = SSL3_RT_MAX_EXTRA;
+    else
+        extra = 0;
+    if (extra &amp;&amp; !s-&gt;s3-&gt;init_extra) {
+        /*
+         * An application error: SLS_OP_MICROSOFT_BIG_SSLV3_BUFFER set after
+         * ssl3_setup_buffers() was done
+         */
+        SSLerr(SSL_F_SSL3_GET_RECORD, ERR_R_INTERNAL_ERROR);
+        return -1;
+    }
+
+ again:
+    /* check if we have the header */
+    if ((RECORD_LAYER_get_rstate(&amp;s-&gt;rlayer) != SSL_ST_READ_BODY) ||
+        (RECORD_LAYER_get_packet_length(&amp;s-&gt;rlayer) &lt; SSL3_RT_HEADER_LENGTH)) {
+        n = ssl3_read_n(s, SSL3_RT_HEADER_LENGTH,
+            SSL3_BUFFER_get_len(&amp;s-&gt;rlayer.rbuf), 0);
+        if (n &lt;= 0)
+            return (n);         /* error or non-blocking */
+        RECORD_LAYER_set_rstate(&amp;s-&gt;rlayer, SSL_ST_READ_BODY);
+
+        p = RECORD_LAYER_get_packet(&amp;s-&gt;rlayer);
+        if (s-&gt;msg_callback)
+            s-&gt;msg_callback(0, 0, SSL3_RT_HEADER, p, 5, s,
+                            s-&gt;msg_callback_arg);
+
+        /* Pull apart the header into the SSL3_RECORD */
+        rr-&gt;type = *(p++);
+        ssl_major = *(p++);
+        ssl_minor = *(p++);
+        version = (ssl_major &lt;&lt; 8) | ssl_minor;
+        n2s(p, rr-&gt;length);
+
+        /* Lets check version */
+        if (!s-&gt;first_packet) {
+            if (version != s-&gt;version) {
+                SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);
+                if ((s-&gt;version &amp; 0xFF00) == (version &amp; 0xFF00)
+                    &amp;&amp; !s-&gt;enc_write_ctx &amp;&amp; !s-&gt;write_hash)
+                    /*
+                     * Send back error using their minor version number :-)
+                     */
+                    s-&gt;version = (unsigned short)version;
+                al = SSL_AD_PROTOCOL_VERSION;
+                goto f_err;
+            }
+        }
+
+        if ((version &gt;&gt; 8) != SSL3_VERSION_MAJOR) {
+            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);
+            goto err;
+        }
+
+        if (rr-&gt;length &gt;
+                SSL3_BUFFER_get_len(&amp;s-&gt;rlayer.rbuf)
+                - SSL3_RT_HEADER_LENGTH) {
+            al = SSL_AD_RECORD_OVERFLOW;
+            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);
+            goto f_err;
+        }
+
+        /* now s-&gt;rlayer.rstate == SSL_ST_READ_BODY */
+    }
+
+    /* s-&gt;rlayer.rstate == SSL_ST_READ_BODY, get and decode the data */
+
+    if (rr-&gt;length &gt;
+        RECORD_LAYER_get_packet_length(&amp;s-&gt;rlayer) - SSL3_RT_HEADER_LENGTH) {
+        /* now s-&gt;packet_length == SSL3_RT_HEADER_LENGTH */
+        i = rr-&gt;length;
+        n = ssl3_read_n(s, i, i, 1);
+        if (n &lt;= 0)
+            return (n);         /* error or non-blocking io */
+        /*
+         * now n == rr-&gt;length, and s-&gt;packet_length == SSL3_RT_HEADER_LENGTH
+         * + rr-&gt;length
+         */
+    }
+
+    /* set state for later operations */
+    RECORD_LAYER_set_rstate(&amp;s-&gt;rlayer, SSL_ST_READ_HEADER);
+
+    /*
+     * At this point, s-&gt;packet_length == SSL3_RT_HEADER_LNGTH + rr-&gt;length,
+     * and we have that many bytes in s-&gt;packet
+     */
+    rr-&gt;input = &amp;(RECORD_LAYER_get_packet(&amp;s-&gt;rlayer)[SSL3_RT_HEADER_LENGTH]);
+
+    /*
+     * ok, we can now read from 's-&gt;packet' data into 'rr' rr-&gt;input points
+     * at rr-&gt;length bytes, which need to be copied into rr-&gt;data by either
+     * the decryption or by the decompression When the data is 'copied' into
+     * the rr-&gt;data buffer, rr-&gt;input will be pointed at the new buffer
+     */
+
+    /*
+     * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr-&gt;length
+     * bytes of encrypted compressed stuff.
+     */
+
+    /* check is not needed I believe */
+    if (rr-&gt;length &gt; SSL3_RT_MAX_ENCRYPTED_LENGTH + extra) {
+        al = SSL_AD_RECORD_OVERFLOW;
+        SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
+        goto f_err;
+    }
+
+    /* decrypt in place in 'rr-&gt;input' */
+    rr-&gt;data = rr-&gt;input;
+    rr-&gt;orig_len = rr-&gt;length;
+    /*
+     * If in encrypt-then-mac mode calculate mac from encrypted record. All
+     * the details below are public so no timing details can leak.
+     */
+    if (SSL_USE_ETM(s) &amp;&amp; s-&gt;read_hash) {
+        unsigned char *mac;
+        mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
+        OPENSSL_assert(mac_size &lt;= EVP_MAX_MD_SIZE);
+        if (rr-&gt;length &lt; mac_size) {
+            al = SSL_AD_DECODE_ERROR;
+            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);
+            goto f_err;
+        }
+        rr-&gt;length -= mac_size;
+        mac = rr-&gt;data + rr-&gt;length;
+        i = s-&gt;method-&gt;ssl3_enc-&gt;mac(s, md, 0 /* not send */ );
+        if (i &lt; 0 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0) {
+            al = SSL_AD_BAD_RECORD_MAC;
+            SSLerr(SSL_F_SSL3_GET_RECORD,
+                   SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
+            goto f_err;
+        }
+    }
+
+    enc_err = s-&gt;method-&gt;ssl3_enc-&gt;enc(s, 0);
+    /*-
+     * enc_err is:
+     *    0: (in non-constant time) if the record is publically invalid.
+     *    1: if the padding is valid
+     *    -1: if the padding is invalid
+     */
+    if (enc_err == 0) {
+        al = SSL_AD_DECRYPTION_FAILED;
+        SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
+        goto f_err;
+    }
+#ifdef TLS_DEBUG
+    printf(&quot;dec %d\n&quot;, rr-&gt;length);
+    {
+        unsigned int z;
+        for (z = 0; z &lt; rr-&gt;length; z++)
+            printf(&quot;%02X%c&quot;, rr-&gt;data[z], ((z + 1) % 16) ? ' ' : '\n');
+    }
+    printf(&quot;\n&quot;);
+#endif
+
+    /* r-&gt;length is now the compressed data plus mac */
+    if ((sess != NULL) &amp;&amp;
+        (s-&gt;enc_read_ctx != NULL) &amp;&amp;
+        (EVP_MD_CTX_md(s-&gt;read_hash) != NULL) &amp;&amp; !SSL_USE_ETM(s)) {
+        /* s-&gt;read_hash != NULL =&gt; mac_size != -1 */
+        unsigned char *mac = NULL;
+        unsigned char mac_tmp[EVP_MAX_MD_SIZE];
+        mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
+        OPENSSL_assert(mac_size &lt;= EVP_MAX_MD_SIZE);
+
+        /*
+         * orig_len is the length of the record before any padding was
+         * removed. This is public information, as is the MAC in use,
+         * therefore we can safely process the record in a different amount
+         * of time if it's too short to possibly contain a MAC.
+         */
+        if (rr-&gt;orig_len &lt; mac_size ||
+            /* CBC records must have a padding length byte too. */
+            (EVP_CIPHER_CTX_mode(s-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE &amp;&amp;
+             rr-&gt;orig_len &lt; mac_size + 1)) {
+            al = SSL_AD_DECODE_ERROR;
+            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);
+            goto f_err;
+        }
+
+        if (EVP_CIPHER_CTX_mode(s-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE) {
+            /*
+             * We update the length so that the TLS header bytes can be
+             * constructed correctly but we need to extract the MAC in
+             * constant time from within the record, without leaking the
+             * contents of the padding bytes.
+             */
+            mac = mac_tmp;
+            ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);
+            rr-&gt;length -= mac_size;
+        } else {
+            /*
+             * In this case there's no padding, so |rec-&gt;orig_len| equals
+             * |rec-&gt;length| and we checked that there's enough bytes for
+             * |mac_size| above.
+             */
+            rr-&gt;length -= mac_size;
+            mac = &amp;rr-&gt;data[rr-&gt;length];
+        }
+
+        i = s-&gt;method-&gt;ssl3_enc-&gt;mac(s, md, 0 /* not send */ );
+        if (i &lt; 0 || mac == NULL
+            || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
+            enc_err = -1;
+        if (rr-&gt;length &gt; SSL3_RT_MAX_COMPRESSED_LENGTH + extra + mac_size)
+            enc_err = -1;
+    }
+
+    if (enc_err &lt; 0) {
+        /*
+         * A separate 'decryption_failed' alert was introduced with TLS 1.0,
+         * SSL 3.0 only has 'bad_record_mac'.  But unless a decryption
+         * failure is directly visible from the ciphertext anyway, we should
+         * not reveal which kind of error occurred -- this might become
+         * visible to an attacker (e.g. via a logfile)
+         */
+        al = SSL_AD_BAD_RECORD_MAC;
+        SSLerr(SSL_F_SSL3_GET_RECORD,
+               SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);
+        goto f_err;
+    }
+
+    /* r-&gt;length is now just compressed */
+    if (s-&gt;expand != NULL) {
+        if (rr-&gt;length &gt; SSL3_RT_MAX_COMPRESSED_LENGTH + extra) {
+            al = SSL_AD_RECORD_OVERFLOW;
+            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);
+            goto f_err;
+        }
+        if (!ssl3_do_uncompress(s)) {
+            al = SSL_AD_DECOMPRESSION_FAILURE;
+            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_DECOMPRESSION);
+            goto f_err;
+        }
+    }
+
+    if (rr-&gt;length &gt; SSL3_RT_MAX_PLAIN_LENGTH + extra) {
+        al = SSL_AD_RECORD_OVERFLOW;
+        SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);
+        goto f_err;
+    }
+
+    rr-&gt;off = 0;
+    /*-
+     * So at this point the following is true
+     * ssl-&gt;s3-&gt;rrec.type   is the type of record
+     * ssl-&gt;s3-&gt;rrec.length == number of bytes in record
+     * ssl-&gt;s3-&gt;rrec.off    == offset to first valid byte
+     * ssl-&gt;s3-&gt;rrec.data   == where to take bytes from, increment
+     *                         after use :-).
+     */
+
+    /* we have pulled in a full packet so zero things */
+    RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
+
+    /* just read a 0 length packet */
+    if (rr-&gt;length == 0) {
+        empty_record_count++;
+        if (empty_record_count &gt; MAX_EMPTY_RECORDS) {
+            al = SSL_AD_UNEXPECTED_MESSAGE;
+            SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_RECORD_TOO_SMALL);
+            goto f_err;
+        }
+        goto again;
+    }
+
+    return (1);
+
+ f_err:
+    ssl3_send_alert(s, SSL3_AL_FATAL, al);
+ err:
+    return (ret);
+}
+
+int ssl3_do_uncompress(SSL *ssl)
+{
+#ifndef OPENSSL_NO_COMP
+    int i;
+    SSL3_RECORD *rr;
+
+    rr = RECORD_LAYER_get_rrec(&amp;ssl-&gt;rlayer);
+    i = COMP_expand_block(ssl-&gt;expand, rr-&gt;comp,
+                          SSL3_RT_MAX_PLAIN_LENGTH, rr-&gt;data,
+                          (int)rr-&gt;length);
+    if (i &lt; 0)
+        return (0);
+    else
+        rr-&gt;length = i;
+    rr-&gt;data = rr-&gt;comp;
+#endif
+    return (1);
+}
+
+int ssl3_do_compress(SSL *ssl)
+{
+#ifndef OPENSSL_NO_COMP
+    int i;
+    SSL3_RECORD *wr;
+
+    wr = RECORD_LAYER_get_wrec(&amp;ssl-&gt;rlayer);
+    i = COMP_compress_block(ssl-&gt;compress, wr-&gt;data,
+                            SSL3_RT_MAX_COMPRESSED_LENGTH,
+                            wr-&gt;input, (int)wr-&gt;length);
+    if (i &lt; 0)
+        return (0);
+    else
+        wr-&gt;length = i;
+
+    wr-&gt;input = wr-&gt;data;
+#endif
+    return (1);
+}
+
+/*-
+ * ssl3_enc encrypts/decrypts the record in |s-&gt;wrec| / |s-&gt;rrec|, respectively.
+ *
+ * Returns:
+ *   0: (in non-constant time) if the record is publically invalid (i.e. too
+ *       short etc).
+ *   1: if the record's padding is valid / the encryption was successful.
+ *   -1: if the record's padding is invalid or, if sending, an internal error
+ *       occurred.
+ */
+int ssl3_enc(SSL *s, int send)
+{
+    SSL3_RECORD *rec;
+    EVP_CIPHER_CTX *ds;
+    unsigned long l;
+    int bs, i, mac_size = 0;
+    const EVP_CIPHER *enc;
+
+    if (send) {
+        ds = s-&gt;enc_write_ctx;
+        rec = RECORD_LAYER_get_wrec(&amp;s-&gt;rlayer);
+        if (s-&gt;enc_write_ctx == NULL)
+            enc = NULL;
+        else
+            enc = EVP_CIPHER_CTX_cipher(s-&gt;enc_write_ctx);
+    } else {
+        ds = s-&gt;enc_read_ctx;
+        rec = RECORD_LAYER_get_rrec(&amp;s-&gt;rlayer);
+        if (s-&gt;enc_read_ctx == NULL)
+            enc = NULL;
+        else
+            enc = EVP_CIPHER_CTX_cipher(s-&gt;enc_read_ctx);
+    }
+
+    if ((s-&gt;session == NULL) || (ds == NULL) || (enc == NULL)) {
+        memmove(rec-&gt;data, rec-&gt;input, rec-&gt;length);
+        rec-&gt;input = rec-&gt;data;
+    } else {
+        l = rec-&gt;length;
+        bs = EVP_CIPHER_block_size(ds-&gt;cipher);
+
+        /* COMPRESS */
+
+        if ((bs != 1) &amp;&amp; send) {
+            i = bs - ((int)l % bs);
+
+            /* we need to add 'i-1' padding bytes */
+            l += i;
+            /*
+             * the last of these zero bytes will be overwritten with the
+             * padding length.
+             */
+            memset(&amp;rec-&gt;input[rec-&gt;length], 0, i);
+            rec-&gt;length += i;
+            rec-&gt;input[l - 1] = (i - 1);
+        }
+
+        if (!send) {
+            if (l == 0 || l % bs != 0)
+                return 0;
+            /* otherwise, rec-&gt;length &gt;= bs */
+        }
+
+        if (EVP_Cipher(ds, rec-&gt;data, rec-&gt;input, l) &lt; 1)
+            return -1;
+
+        if (EVP_MD_CTX_md(s-&gt;read_hash) != NULL)
+            mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
+        if ((bs != 1) &amp;&amp; !send)
+            return ssl3_cbc_remove_padding(s, rec, bs, mac_size);
+    }
+    return (1);
+}
+
+/*-
+ * tls1_enc encrypts/decrypts the record in |s-&gt;wrec| / |s-&gt;rrec|, respectively.
+ *
+ * Returns:
+ *   0: (in non-constant time) if the record is publically invalid (i.e. too
+ *       short etc).
+ *   1: if the record's padding is valid / the encryption was successful.
+ *   -1: if the record's padding/AEAD-authenticator is invalid or, if sending,
+ *       an internal error occurred.
+ */
+int tls1_enc(SSL *s, int send)
+{
+    SSL3_RECORD *rec;
+    EVP_CIPHER_CTX *ds;
+    unsigned long l;
+    int bs, i, j, k, pad = 0, ret, mac_size = 0;
+    const EVP_CIPHER *enc;
+
+    if (send) {
+        if (EVP_MD_CTX_md(s-&gt;write_hash)) {
+            int n = EVP_MD_CTX_size(s-&gt;write_hash);
+            OPENSSL_assert(n &gt;= 0);
+        }
+        ds = s-&gt;enc_write_ctx;
+        rec = RECORD_LAYER_get_wrec(&amp;s-&gt;rlayer);
+        if (s-&gt;enc_write_ctx == NULL)
+            enc = NULL;
+        else {
+            int ivlen;
+            enc = EVP_CIPHER_CTX_cipher(s-&gt;enc_write_ctx);
+            /* For TLSv1.1 and later explicit IV */
+            if (SSL_USE_EXPLICIT_IV(s)
+                &amp;&amp; EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)
+                ivlen = EVP_CIPHER_iv_length(enc);
+            else
+                ivlen = 0;
+            if (ivlen &gt; 1) {
+                if (rec-&gt;data != rec-&gt;input)
+                    /*
+                     * we can't write into the input stream: Can this ever
+                     * happen?? (steve)
+                     */
+                    fprintf(stderr,
+                            &quot;%s:%d: rec-&gt;data != rec-&gt;input\n&quot;,
+                            __FILE__, __LINE__);
+                else if (RAND_bytes(rec-&gt;input, ivlen) &lt;= 0)
+                    return -1;
+            }
+        }
+    } else {
+        if (EVP_MD_CTX_md(s-&gt;read_hash)) {
+            int n = EVP_MD_CTX_size(s-&gt;read_hash);
+            OPENSSL_assert(n &gt;= 0);
+        }
+        ds = s-&gt;enc_read_ctx;
+        rec = RECORD_LAYER_get_rrec(&amp;s-&gt;rlayer);
+        if (s-&gt;enc_read_ctx == NULL)
+            enc = NULL;
+        else
+            enc = EVP_CIPHER_CTX_cipher(s-&gt;enc_read_ctx);
+    }
+
+#ifdef KSSL_DEBUG
+    fprintf(stderr, &quot;tls1_enc(%d)\n&quot;, send);
+#endif                          /* KSSL_DEBUG */
+
+    if ((s-&gt;session == NULL) || (ds == NULL) || (enc == NULL)) {
+        memmove(rec-&gt;data, rec-&gt;input, rec-&gt;length);
+        rec-&gt;input = rec-&gt;data;
+        ret = 1;
+    } else {
+        l = rec-&gt;length;
+        bs = EVP_CIPHER_block_size(ds-&gt;cipher);
+
+        if (EVP_CIPHER_flags(ds-&gt;cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) {
+            unsigned char buf[13], *seq;
+
+            seq = send ? RECORD_LAYER_get_write_sequence(&amp;s-&gt;rlayer)
+                : RECORD_LAYER_get_read_sequence(&amp;s-&gt;rlayer);
+
+            if (SSL_IS_DTLS(s)) {
+                unsigned char dtlsseq[9], *p = dtlsseq;
+
+                s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&amp;s-&gt;rlayer) :
+                    DTLS_RECORD_LAYER_get_r_epoch(&amp;s-&gt;rlayer), p);
+                memcpy(p, &amp;seq[2], 6);
+                memcpy(buf, dtlsseq, 8);
+            } else {
+                memcpy(buf, seq, 8);
+                for (i = 7; i &gt;= 0; i--) { /* increment */
+                    ++seq[i];
+                    if (seq[i] != 0)
+                        break;
+                }
+            }
+
+            buf[8] = rec-&gt;type;
+            buf[9] = (unsigned char)(s-&gt;version &gt;&gt; 8);
+            buf[10] = (unsigned char)(s-&gt;version);
+            buf[11] = rec-&gt;length &gt;&gt; 8;
+            buf[12] = rec-&gt;length &amp; 0xff;
+            pad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD, 13, buf);
+            if (send) {
+                l += pad;
+                rec-&gt;length += pad;
+            }
+        } else if ((bs != 1) &amp;&amp; send) {
+            i = bs - ((int)l % bs);
+
+            /* Add weird padding of upto 256 bytes */
+
+            /* we need to add 'i' padding bytes of value j */
+            j = i - 1;
+            if (s-&gt;options &amp; SSL_OP_TLS_BLOCK_PADDING_BUG) {
+                if (s-&gt;s3-&gt;flags &amp; TLS1_FLAGS_TLS_PADDING_BUG)
+                    j++;
+            }
+            for (k = (int)l; k &lt; (int)(l + i); k++)
+                rec-&gt;input[k] = j;
+            l += i;
+            rec-&gt;length += i;
+        }
+#ifdef KSSL_DEBUG
+        {
+            unsigned long ui;
+            fprintf(stderr,
+                    &quot;EVP_Cipher(ds=%p,rec-&gt;data=%p,rec-&gt;input=%p,l=%ld) ==&gt;\n&quot;,
+                    ds, rec-&gt;data, rec-&gt;input, l);
+            fprintf(stderr,
+                    &quot;\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%lu %lu], %d iv_len\n&quot;,
+                    ds-&gt;buf_len, ds-&gt;cipher-&gt;key_len, DES_KEY_SZ,
+                    DES_SCHEDULE_SZ, ds-&gt;cipher-&gt;iv_len);
+            fprintf(stderr, &quot;\t\tIV: &quot;);
+            for (i = 0; i &lt; ds-&gt;cipher-&gt;iv_len; i++)
+                fprintf(stderr, &quot;%02X&quot;, ds-&gt;iv[i]);
+            fprintf(stderr, &quot;\n&quot;);
+            fprintf(stderr, &quot;\trec-&gt;input=&quot;);
+            for (ui = 0; ui &lt; l; ui++)
+                fprintf(stderr, &quot; %02x&quot;, rec-&gt;input[ui]);
+            fprintf(stderr, &quot;\n&quot;);
+        }
+#endif                          /* KSSL_DEBUG */
+
+        if (!send) {
+            if (l == 0 || l % bs != 0)
+                return 0;
+        }
+
+        i = EVP_Cipher(ds, rec-&gt;data, rec-&gt;input, l);
+        if ((EVP_CIPHER_flags(ds-&gt;cipher) &amp; EVP_CIPH_FLAG_CUSTOM_CIPHER)
+            ? (i &lt; 0)
+            : (i == 0))
+            return -1;          /* AEAD can fail to verify MAC */
+        if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE &amp;&amp; !send) {
+            rec-&gt;data += EVP_GCM_TLS_EXPLICIT_IV_LEN;
+            rec-&gt;input += EVP_GCM_TLS_EXPLICIT_IV_LEN;
+            rec-&gt;length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
+        }
+#ifdef KSSL_DEBUG
+        {
+            unsigned long i;
+            fprintf(stderr, &quot;\trec-&gt;data=&quot;);
+            for (i = 0; i &lt; l; i++)
+                fprintf(stderr, &quot; %02x&quot;, rec-&gt;data[i]);
+            fprintf(stderr, &quot;\n&quot;);
+        }
+#endif                          /* KSSL_DEBUG */
+
+        ret = 1;
+        if (!SSL_USE_ETM(s) &amp;&amp; EVP_MD_CTX_md(s-&gt;read_hash) != NULL)
+            mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
+        if ((bs != 1) &amp;&amp; !send)
+            ret = tls1_cbc_remove_padding(s, rec, bs, mac_size);
+        if (pad &amp;&amp; !send)
+            rec-&gt;length -= pad;
+    }
+    return ret;
+}
+
+int n_ssl3_mac(SSL *ssl, unsigned char *md, int send)
+{
+    SSL3_RECORD *rec;
+    unsigned char *mac_sec, *seq;
+    EVP_MD_CTX md_ctx;
+    const EVP_MD_CTX *hash;
+    unsigned char *p, rec_char;
+    size_t md_size;
+    int npad;
+    int t;
+
+    if (send) {
+        rec = RECORD_LAYER_get_wrec(&amp;ssl-&gt;rlayer);
+        mac_sec = &amp;(ssl-&gt;s3-&gt;write_mac_secret[0]);
+        seq = RECORD_LAYER_get_write_sequence(&amp;ssl-&gt;rlayer);
+        hash = ssl-&gt;write_hash;
+    } else {
+        rec = RECORD_LAYER_get_rrec(&amp;ssl-&gt;rlayer);
+        mac_sec = &amp;(ssl-&gt;s3-&gt;read_mac_secret[0]);
+        seq = RECORD_LAYER_get_read_sequence(&amp;ssl-&gt;rlayer);
+        hash = ssl-&gt;read_hash;
+    }
+
+    t = EVP_MD_CTX_size(hash);
+    if (t &lt; 0)
+        return -1;
+    md_size = t;
+    npad = (48 / md_size) * md_size;
+
+    if (!send &amp;&amp;
+        EVP_CIPHER_CTX_mode(ssl-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE &amp;&amp;
+        ssl3_cbc_record_digest_supported(hash)) {
+        /*
+         * This is a CBC-encrypted record. We must avoid leaking any
+         * timing-side channel information about how many blocks of data we
+         * are hashing because that gives an attacker a timing-oracle.
+         */
+
+        /*-
+         * npad is, at most, 48 bytes and that's with MD5:
+         *   16 + 48 + 8 (sequence bytes) + 1 + 2 = 75.
+         *
+         * With SHA-1 (the largest hash speced for SSLv3) the hash size
+         * goes up 4, but npad goes down by 8, resulting in a smaller
+         * total size.
+         */
+        unsigned char header[75];
+        unsigned j = 0;
+        memcpy(header + j, mac_sec, md_size);
+        j += md_size;
+        memcpy(header + j, ssl3_pad_1, npad);
+        j += npad;
+        memcpy(header + j, seq, 8);
+        j += 8;
+        header[j++] = rec-&gt;type;
+        header[j++] = rec-&gt;length &gt;&gt; 8;
+        header[j++] = rec-&gt;length &amp; 0xff;
+
+        /* Final param == is SSLv3 */
+        ssl3_cbc_digest_record(hash,
+                               md, &amp;md_size,
+                               header, rec-&gt;input,
+                               rec-&gt;length + md_size, rec-&gt;orig_len,
+                               mac_sec, md_size, 1);
+    } else {
+        unsigned int md_size_u;
+        /* Chop the digest off the end :-) */
+        EVP_MD_CTX_init(&amp;md_ctx);
+
+        EVP_MD_CTX_copy_ex(&amp;md_ctx, hash);
+        EVP_DigestUpdate(&amp;md_ctx, mac_sec, md_size);
+        EVP_DigestUpdate(&amp;md_ctx, ssl3_pad_1, npad);
+        EVP_DigestUpdate(&amp;md_ctx, seq, 8);
+        rec_char = rec-&gt;type;
+        EVP_DigestUpdate(&amp;md_ctx, &amp;rec_char, 1);
+        p = md;
+        s2n(rec-&gt;length, p);
+        EVP_DigestUpdate(&amp;md_ctx, md, 2);
+        EVP_DigestUpdate(&amp;md_ctx, rec-&gt;input, rec-&gt;length);
+        EVP_DigestFinal_ex(&amp;md_ctx, md, NULL);
+
+        EVP_MD_CTX_copy_ex(&amp;md_ctx, hash);
+        EVP_DigestUpdate(&amp;md_ctx, mac_sec, md_size);
+        EVP_DigestUpdate(&amp;md_ctx, ssl3_pad_2, npad);
+        EVP_DigestUpdate(&amp;md_ctx, md, md_size);
+        EVP_DigestFinal_ex(&amp;md_ctx, md, &amp;md_size_u);
+        md_size = md_size_u;
+
+        EVP_MD_CTX_cleanup(&amp;md_ctx);
+    }
+
+    ssl3_record_sequence_update(seq);
+    return (md_size);
+}
+
+int tls1_mac(SSL *ssl, unsigned char *md, int send)
+{
+    SSL3_RECORD *rec;
+    unsigned char *seq;
+    EVP_MD_CTX *hash;
+    size_t md_size;
+    int i;
+    EVP_MD_CTX hmac, *mac_ctx;
+    unsigned char header[13];
+    int stream_mac = (send ? (ssl-&gt;mac_flags &amp; SSL_MAC_FLAG_WRITE_MAC_STREAM)
+                      : (ssl-&gt;mac_flags &amp; SSL_MAC_FLAG_READ_MAC_STREAM));
+    int t;
+
+    if (send) {
+        rec = RECORD_LAYER_get_wrec(&amp;ssl-&gt;rlayer);
+        seq = RECORD_LAYER_get_write_sequence(&amp;ssl-&gt;rlayer);
+        hash = ssl-&gt;write_hash;
+    } else {
+        rec = RECORD_LAYER_get_rrec(&amp;ssl-&gt;rlayer);
+        seq = RECORD_LAYER_get_read_sequence(&amp;ssl-&gt;rlayer);
+        hash = ssl-&gt;read_hash;
+    }
+
+    t = EVP_MD_CTX_size(hash);
+    OPENSSL_assert(t &gt;= 0);
+    md_size = t;
+
+    /* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */
+    if (stream_mac) {
+        mac_ctx = hash;
+    } else {
+        if (!EVP_MD_CTX_copy(&amp;hmac, hash))
+            return -1;
+        mac_ctx = &hmac;
+    }
+
+    if (SSL_IS_DTLS(ssl)) {
+        unsigned char dtlsseq[8], *p = dtlsseq;
+
+        s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&amp;ssl-&gt;rlayer) :
+            DTLS_RECORD_LAYER_get_r_epoch(&amp;ssl-&gt;rlayer), p);
+        memcpy(p, &amp;seq[2], 6);
+
+        memcpy(header, dtlsseq, 8);
+    } else
+        memcpy(header, seq, 8);
+
+    header[8] = rec-&gt;type;
+    header[9] = (unsigned char)(ssl-&gt;version &gt;&gt; 8);
+    header[10] = (unsigned char)(ssl-&gt;version);
+    header[11] = (rec-&gt;length) &gt;&gt; 8;
+    header[12] = (rec-&gt;length) &amp; 0xff;
+
+    if (!send &amp;&amp; !SSL_USE_ETM(ssl) &amp;&amp;
+        EVP_CIPHER_CTX_mode(ssl-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE &amp;&amp;
+        ssl3_cbc_record_digest_supported(mac_ctx)) {
+        /*
+         * This is a CBC-encrypted record. We must avoid leaking any
+         * timing-side channel information about how many blocks of data we
+         * are hashing because that gives an attacker a timing-oracle.
+         */
+        /* Final param == not SSLv3 */
+        ssl3_cbc_digest_record(mac_ctx,
+                               md, &amp;md_size,
+                               header, rec-&gt;input,
+                               rec-&gt;length + md_size, rec-&gt;orig_len,
+                               ssl-&gt;s3-&gt;read_mac_secret,
+                               ssl-&gt;s3-&gt;read_mac_secret_size, 0);
+    } else {
+        EVP_DigestSignUpdate(mac_ctx, header, sizeof(header));
+        EVP_DigestSignUpdate(mac_ctx, rec-&gt;input, rec-&gt;length);
+        t = EVP_DigestSignFinal(mac_ctx, md, &amp;md_size);
+        OPENSSL_assert(t &gt; 0);
+        if (!send &amp;&amp; !SSL_USE_ETM(ssl) &amp;&amp; FIPS_mode())
+            tls_fips_digest_extra(ssl-&gt;enc_read_ctx,
+                                  mac_ctx, rec-&gt;input,
+                                  rec-&gt;length, rec-&gt;orig_len);
+    }
+
+    if (!stream_mac)
+        EVP_MD_CTX_cleanup(&amp;hmac);
+#ifdef TLS_DEBUG
+    fprintf(stderr, &quot;seq=&quot;);
+    {
+        int z;
+        for (z = 0; z &lt; 8; z++)
+            fprintf(stderr, &quot;%02X &quot;, seq[z]);
+        fprintf(stderr, &quot;\n&quot;);
+    }
+    fprintf(stderr, &quot;rec=&quot;);
+    {
+        unsigned int z;
+        for (z = 0; z &lt; rec-&gt;length; z++)
+            fprintf(stderr, &quot;%02X &quot;, rec-&gt;data[z]);
+        fprintf(stderr, &quot;\n&quot;);
+    }
+#endif
+
+    if (!SSL_IS_DTLS(ssl)) {
+        for (i = 7; i &gt;= 0; i--) {
+            ++seq[i];
+            if (seq[i] != 0)
+                break;
+        }
+    }
+#ifdef TLS_DEBUG
+    {
+        unsigned int z;
+        for (z = 0; z &lt; md_size; z++)
+            fprintf(stderr, &quot;%02X &quot;, md[z]);
+        fprintf(stderr, &quot;\n&quot;);
+    }
+#endif
+    return (md_size);
+}
+
+/*-
+ * ssl3_cbc_remove_padding removes padding from the decrypted, SSLv3, CBC
+ * record in |rec| by updating |rec-&gt;length| in constant time.
+ *
+ * block_size: the block size of the cipher used to encrypt the record.
+ * returns:
+ *   0: (in non-constant time) if the record is publicly invalid.
+ *   1: if the padding was valid
+ *  -1: otherwise.
+ */
+int ssl3_cbc_remove_padding(const SSL *s,
+                            SSL3_RECORD *rec,
+                            unsigned block_size, unsigned mac_size)
+{
+    unsigned padding_length, good;
+    const unsigned overhead = 1 /* padding length byte */  + mac_size;
+
+    /*
+     * These lengths are all public so we can test them in non-constant time.
+     */
+    if (overhead &gt; rec-&gt;length)
+        return 0;
+
+    padding_length = rec-&gt;data[rec-&gt;length - 1];
+    good = constant_time_ge(rec-&gt;length, padding_length + overhead);
+    /* SSLv3 requires that the padding is minimal. */
+    good &amp;= constant_time_ge(block_size, padding_length + 1);
+    rec-&gt;length -= good &amp; (padding_length + 1);
+    return constant_time_select_int(good, 1, -1);
+}
+
+/*-
+ * tls1_cbc_remove_padding removes the CBC padding from the decrypted, TLS, CBC
+ * record in |rec| in constant time and returns 1 if the padding is valid and
+ * -1 otherwise. It also removes any explicit IV from the start of the record
+ * without leaking any timing about whether there was enough space after the
+ * padding was removed.
+ *
+ * block_size: the block size of the cipher used to encrypt the record.
+ * returns:
+ *   0: (in non-constant time) if the record is publicly invalid.
+ *   1: if the padding was valid
+ *  -1: otherwise.
+ */
+int tls1_cbc_remove_padding(const SSL *s,
+                            SSL3_RECORD *rec,
+                            unsigned block_size, unsigned mac_size)
+{
+    unsigned padding_length, good, to_check, i;
+    const unsigned overhead = 1 /* padding length byte */  + mac_size;
+    /* Check if version requires explicit IV */
+    if (SSL_USE_EXPLICIT_IV(s)) {
+        /*
+         * These lengths are all public so we can test them in non-constant
+         * time.
+         */
+        if (overhead + block_size &gt; rec-&gt;length)
+            return 0;
+        /* We can now safely skip explicit IV */
+        rec-&gt;data += block_size;
+        rec-&gt;input += block_size;
+        rec-&gt;length -= block_size;
+        rec-&gt;orig_len -= block_size;
+    } else if (overhead &gt; rec-&gt;length)
+        return 0;
+
+    padding_length = rec-&gt;data[rec-&gt;length - 1];
+
+    /*
+     * NB: if compression is in operation the first packet may not be of even
+     * length so the padding bug check cannot be performed. This bug
+     * workaround has been around since SSLeay so hopefully it is either
+     * fixed now or no buggy implementation supports compression [steve]
+     */
+    if ((s-&gt;options &amp; SSL_OP_TLS_BLOCK_PADDING_BUG) &amp;&amp; !s-&gt;expand) {
+        /* First packet is even in size, so check */
+        if ((memcmp(RECORD_LAYER_get_read_sequence(&amp;s-&gt;rlayer),
+                &quot;\0\0\0\0\0\0\0\0&quot;, 8) == 0) &amp;&amp;
+            !(padding_length &amp; 1)) {
+            s-&gt;s3-&gt;flags |= TLS1_FLAGS_TLS_PADDING_BUG;
+        }
+        if ((s-&gt;s3-&gt;flags &amp; TLS1_FLAGS_TLS_PADDING_BUG) &amp;&amp; padding_length &gt; 0) {
+            padding_length--;
+        }
+    }
+
+    if (EVP_CIPHER_flags(s-&gt;enc_read_ctx-&gt;cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) {
+        /* padding is already verified */
+        rec-&gt;length -= padding_length + 1;
+        return 1;
+    }
+
+    good = constant_time_ge(rec-&gt;length, overhead + padding_length);
+    /*
+     * The padding consists of a length byte at the end of the record and
+     * then that many bytes of padding, all with the same value as the length
+     * byte. Thus, with the length byte included, there are i+1 bytes of
+     * padding. We can't check just |padding_length+1| bytes because that
+     * leaks decrypted information. Therefore we always have to check the
+     * maximum amount of padding possible. (Again, the length of the record
+     * is public information so we can use it.)
+     */
+    to_check = 255;             /* maximum amount of padding. */
+    if (to_check &gt; rec-&gt;length - 1)
+        to_check = rec-&gt;length - 1;
+
+    for (i = 0; i &lt; to_check; i++) {
+        unsigned char mask = constant_time_ge_8(padding_length, i);
+        unsigned char b = rec-&gt;data[rec-&gt;length - 1 - i];
+        /*
+         * The final |padding_length+1| bytes should all have the value
+         * |padding_length|. Therefore the XOR should be zero.
+         */
+        good &amp;= ~(mask &amp; (padding_length ^ b));
+    }
+
+    /*
+     * If any of the final |padding_length+1| bytes had the wrong value, one
+     * or more of the lower eight bits of |good| will be cleared.
+     */
+    good = constant_time_eq(0xff, good &amp; 0xff);
+    rec-&gt;length -= good &amp; (padding_length + 1);
+
+    return constant_time_select_int(good, 1, -1);
+}
+
+/*-
+ * ssl3_cbc_copy_mac copies |md_size| bytes from the end of |rec| to |out| in
+ * constant time (independent of the concrete value of rec-&gt;length, which may
+ * vary within a 256-byte window).
+ *
+ * ssl3_cbc_remove_padding or tls1_cbc_remove_padding must be called prior to
+ * this function.
+ *
+ * On entry:
+ *   rec-&gt;orig_len &gt;= md_size
+ *   md_size &lt;= EVP_MAX_MD_SIZE
+ *
+ * If CBC_MAC_ROTATE_IN_PLACE is defined then the rotation is performed with
+ * variable accesses in a 64-byte-aligned buffer. Assuming that this fits into
+ * a single or pair of cache-lines, then the variable memory accesses don't
+ * actually affect the timing. CPUs with smaller cache-lines [if any] are
+ * not multi-core and are not considered vulnerable to cache-timing attacks.
+ */
+#define CBC_MAC_ROTATE_IN_PLACE
+
+void ssl3_cbc_copy_mac(unsigned char *out,
+                       const SSL3_RECORD *rec, unsigned md_size)
+{
+#if defined(CBC_MAC_ROTATE_IN_PLACE)
+    unsigned char rotated_mac_buf[64 + EVP_MAX_MD_SIZE];
+    unsigned char *rotated_mac;
+#else
+    unsigned char rotated_mac[EVP_MAX_MD_SIZE];
+#endif
+
+    /*
+     * mac_end is the index of |rec-&gt;data| just after the end of the MAC.
+     */
+    unsigned mac_end = rec-&gt;length;
+    unsigned mac_start = mac_end - md_size;
+    /*
+     * scan_start contains the number of bytes that we can ignore because the
+     * MAC's position can only vary by 255 bytes.
+     */
+    unsigned scan_start = 0;
+    unsigned i, j;
+    unsigned div_spoiler;
+    unsigned rotate_offset;
+
+    OPENSSL_assert(rec-&gt;orig_len &gt;= md_size);
+    OPENSSL_assert(md_size &lt;= EVP_MAX_MD_SIZE);
+
+#if defined(CBC_MAC_ROTATE_IN_PLACE)
+    rotated_mac = rotated_mac_buf + ((0 - (size_t)rotated_mac_buf) &amp; 63);
+#endif
+
+    /* This information is public so it's safe to branch based on it. */
+    if (rec-&gt;orig_len &gt; md_size + 255 + 1)
+        scan_start = rec-&gt;orig_len - (md_size + 255 + 1);
+    /*
+     * div_spoiler contains a multiple of md_size that is used to cause the
+     * modulo operation to be constant time. Without this, the time varies
+     * based on the amount of padding when running on Intel chips at least.
+     * The aim of right-shifting md_size is so that the compiler doesn't
+     * figure out that it can remove div_spoiler as that would require it to
+     * prove that md_size is always even, which I hope is beyond it.
+     */
+    div_spoiler = md_size &gt;&gt; 1;
+    div_spoiler &lt;&lt;= (sizeof(div_spoiler) - 1) * 8;
+    rotate_offset = (div_spoiler + mac_start - scan_start) % md_size;
+
+    memset(rotated_mac, 0, md_size);
+    for (i = scan_start, j = 0; i &lt; rec-&gt;orig_len; i++) {
+        unsigned char mac_started = constant_time_ge_8(i, mac_start);
+        unsigned char mac_ended = constant_time_ge_8(i, mac_end);
+        unsigned char b = rec-&gt;data[i];
+        rotated_mac[j++] |= b &amp; mac_started &amp; ~mac_ended;
+        j &amp;= constant_time_lt(j, md_size);
+    }
+
+    /* Now rotate the MAC */
+#if defined(CBC_MAC_ROTATE_IN_PLACE)
+    j = 0;
+    for (i = 0; i &lt; md_size; i++) {
+        /* in case cache-line is 32 bytes, touch second line */
+        ((volatile unsigned char *)rotated_mac)[rotate_offset ^ 32];
+        out[j++] = rotated_mac[rotate_offset++];
+        rotate_offset &amp;= constant_time_lt(rotate_offset, md_size);
+    }
+#else
+    memset(out, 0, md_size);
+    rotate_offset = md_size - rotate_offset;
+    rotate_offset &amp;= constant_time_lt(rotate_offset, md_size);
+    for (i = 0; i &lt; md_size; i++) {
+        for (j = 0; j &lt; md_size; j++)
+            out[j] |= rotated_mac[i] &amp; constant_time_eq_8(j, rotate_offset);
+        rotate_offset++;
+        rotate_offset &amp;= constant_time_lt(rotate_offset, md_size);
+    }
+#endif
+}
+
+int dtls1_process_record(SSL *s)
+{
+    int i, al;
+    int enc_err;
+    SSL_SESSION *sess;
+    SSL3_RECORD *rr;
+    unsigned int mac_size;
+    unsigned char md[EVP_MAX_MD_SIZE];
+
+    rr = RECORD_LAYER_get_rrec(&amp;s-&gt;rlayer);
+    sess = s-&gt;session;
+
+    /*
+     * At this point, s-&gt;packet_length == SSL3_RT_HEADER_LNGTH + rr-&gt;length,
+     * and we have that many bytes in s-&gt;packet
+     */
+    rr-&gt;input = &amp;(RECORD_LAYER_get_packet(&amp;s-&gt;rlayer)[DTLS1_RT_HEADER_LENGTH]);
+
+    /*
+     * ok, we can now read from 's-&gt;packet' data into 'rr' rr-&gt;input points
+     * at rr-&gt;length bytes, which need to be copied into rr-&gt;data by either
+     * the decryption or by the decompression When the data is 'copied' into
+     * the rr-&gt;data buffer, rr-&gt;input will be pointed at the new buffer
+     */
+
+    /*
+     * We now have - encrypted [ MAC [ compressed [ plain ] ] ] rr-&gt;length
+     * bytes of encrypted compressed stuff.
+     */
+
+    /* check is not needed I believe */
+    if (rr-&gt;length &gt; SSL3_RT_MAX_ENCRYPTED_LENGTH) {
+        al = SSL_AD_RECORD_OVERFLOW;
+        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);
+        goto f_err;
+    }
+
+    /* decrypt in place in 'rr-&gt;input' */
+    rr-&gt;data = rr-&gt;input;
+    rr-&gt;orig_len = rr-&gt;length;
+
+    enc_err = s-&gt;method-&gt;ssl3_enc-&gt;enc(s, 0);
+    /*-
+     * enc_err is:
+     *    0: (in non-constant time) if the record is publically invalid.
+     *    1: if the padding is valid
+     *   -1: if the padding is invalid
+     */
+    if (enc_err == 0) {
+        /* For DTLS we simply ignore bad packets. */
+        rr-&gt;length = 0;
+        RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
+        goto err;
+    }
+#ifdef TLS_DEBUG
+    printf(&quot;dec %d\n&quot;, rr-&gt;length);
+    {
+        unsigned int z;
+        for (z = 0; z &lt; rr-&gt;length; z++)
+            printf(&quot;%02X%c&quot;, rr-&gt;data[z], ((z + 1) % 16) ? ' ' : '\n');
+    }
+    printf(&quot;\n&quot;);
+#endif
+
+    /* r-&gt;length is now the compressed data plus mac */
+    if ((sess != NULL) &amp;&amp;
+        (s-&gt;enc_read_ctx != NULL) &amp;&amp; (EVP_MD_CTX_md(s-&gt;read_hash) != NULL)) {
+        /* s-&gt;read_hash != NULL =&gt; mac_size != -1 */
+        unsigned char *mac = NULL;
+        unsigned char mac_tmp[EVP_MAX_MD_SIZE];
+        mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
+        OPENSSL_assert(mac_size &lt;= EVP_MAX_MD_SIZE);
+
+        /*
+         * orig_len is the length of the record before any padding was
+         * removed. This is public information, as is the MAC in use,
+         * therefore we can safely process the record in a different amount
+         * of time if it's too short to possibly contain a MAC.
+         */
+        if (rr-&gt;orig_len &lt; mac_size ||
+            /* CBC records must have a padding length byte too. */
+            (EVP_CIPHER_CTX_mode(s-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE &amp;&amp;
+             rr-&gt;orig_len &lt; mac_size + 1)) {
+            al = SSL_AD_DECODE_ERROR;
+            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT);
+            goto f_err;
+        }
+
+        if (EVP_CIPHER_CTX_mode(s-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE) {
+            /*
+             * We update the length so that the TLS header bytes can be
+             * constructed correctly but we need to extract the MAC in
+             * constant time from within the record, without leaking the
+             * contents of the padding bytes.
+             */
+            mac = mac_tmp;
+            ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);
+            rr-&gt;length -= mac_size;
+        } else {
+            /*
+             * In this case there's no padding, so |rec-&gt;orig_len| equals
+             * |rec-&gt;length| and we checked that there's enough bytes for
+             * |mac_size| above.
+             */
+            rr-&gt;length -= mac_size;
+            mac = &amp;rr-&gt;data[rr-&gt;length];
+        }
+
+        i = s-&gt;method-&gt;ssl3_enc-&gt;mac(s, md, 0 /* not send */ );
+        if (i &lt; 0 || mac == NULL
+            || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)
+            enc_err = -1;
+        if (rr-&gt;length &gt; SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)
+            enc_err = -1;
+    }
+
+    if (enc_err &lt; 0) {
+        /* decryption failed, silently discard message */
+        rr-&gt;length = 0;
+        RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
+        goto err;
+    }
+
+    /* r-&gt;length is now just compressed */
+    if (s-&gt;expand != NULL) {
+        if (rr-&gt;length &gt; SSL3_RT_MAX_COMPRESSED_LENGTH) {
+            al = SSL_AD_RECORD_OVERFLOW;
+            SSLerr(SSL_F_DTLS1_PROCESS_RECORD,
+                   SSL_R_COMPRESSED_LENGTH_TOO_LONG);
+            goto f_err;
+        }
+        if (!ssl3_do_uncompress(s)) {
+            al = SSL_AD_DECOMPRESSION_FAILURE;
+            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_BAD_DECOMPRESSION);
+            goto f_err;
+        }
+    }
+
+    if (rr-&gt;length &gt; SSL3_RT_MAX_PLAIN_LENGTH) {
+        al = SSL_AD_RECORD_OVERFLOW;
+        SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);
+        goto f_err;
+    }
+
+    rr-&gt;off = 0;
+    /*-
+     * So at this point the following is true
+     * ssl-&gt;s3-&gt;rrec.type   is the type of record
+     * ssl-&gt;s3-&gt;rrec.length == number of bytes in record
+     * ssl-&gt;s3-&gt;rrec.off    == offset to first valid byte
+     * ssl-&gt;s3-&gt;rrec.data   == where to take bytes from, increment
+     *                         after use :-).
+     */
+
+    /* we have pulled in a full packet so zero things */
+    RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
+    return (1);
+
+ f_err:
+    ssl3_send_alert(s, SSL3_AL_FATAL, al);
+ err:
+    return (0);
+}
+
+
+/*
+ * retrieve a buffered record that belongs to the current epoch, ie,
+ * processed
+ */
+#define dtls1_get_processed_record(s) \
+                   dtls1_retrieve_buffered_record((s), \
+                   &amp;(DTLS_RECORD_LAYER_get_processed_rcds(&amp;s-&gt;rlayer)))
+
+/*-
+ * Call this to get a new input record.
+ * It will return &lt;= 0 if more data is needed, normally due to an error
+ * or non-blocking IO.
+ * When it finishes, one packet has been decoded and can be found in
+ * ssl-&gt;s3-&gt;rrec.type    - is the type of record
+ * ssl-&gt;s3-&gt;rrec.data,   - data
+ * ssl-&gt;s3-&gt;rrec.length, - number of bytes
+ */
+/* used only by dtls1_read_bytes */
+int dtls1_get_record(SSL *s)
+{
+    int ssl_major, ssl_minor;
+    int i, n;
+    SSL3_RECORD *rr;
+    unsigned char *p = NULL;
+    unsigned short version;
+    DTLS1_BITMAP *bitmap;
+    unsigned int is_next_epoch;
+
+    rr = RECORD_LAYER_get_rrec(&amp;s-&gt;rlayer);
+
+    /*
+     * The epoch may have changed.  If so, process all the pending records.
+     * This is a non-blocking operation.
+     */
+    if (dtls1_process_buffered_records(s) &lt; 0)
+        return -1;
+
+    /* if we're renegotiating, then there may be buffered records */
+    if (dtls1_get_processed_record(s))
+        return 1;
+
+    /* get something from the wire */
+ again:
+    /* check if we have the header */
+    if ((RECORD_LAYER_get_rstate(&amp;s-&gt;rlayer) != SSL_ST_READ_BODY) ||
+        (RECORD_LAYER_get_packet_length(&amp;s-&gt;rlayer) &lt; DTLS1_RT_HEADER_LENGTH)) {
+        n = ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH,
+            SSL3_BUFFER_get_len(&amp;s-&gt;rlayer.rbuf), 0);
+        /* read timeout is handled by dtls1_read_bytes */
+        if (n &lt;= 0)
+            return (n);         /* error or non-blocking */
+
+        /* this packet contained a partial record, dump it */
+        if (RECORD_LAYER_get_packet_length(&amp;s-&gt;rlayer) != DTLS1_RT_HEADER_LENGTH) {
+            RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
+            goto again;
+        }
+
+        RECORD_LAYER_set_rstate(&amp;s-&gt;rlayer, SSL_ST_READ_BODY);
+
+        p = RECORD_LAYER_get_packet(&amp;s-&gt;rlayer);
+
+        if (s-&gt;msg_callback)
+            s-&gt;msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH,
+                            s, s-&gt;msg_callback_arg);
+
+        /* Pull apart the header into the DTLS1_RECORD */
+        rr-&gt;type = *(p++);
+        ssl_major = *(p++);
+        ssl_minor = *(p++);
+        version = (ssl_major &lt;&lt; 8) | ssl_minor;
+
+        /* sequence number is 64 bits, with top 2 bytes = epoch */
+        n2s(p, rr-&gt;epoch);
+
+        memcpy(&amp;(RECORD_LAYER_get_read_sequence(&amp;s-&gt;rlayer)[2]), p, 6);
+        p += 6;
+
+        n2s(p, rr-&gt;length);
+
+        /* Lets check version */
+        if (!s-&gt;first_packet) {
+            if (version != s-&gt;version) {
+                /* unexpected version, silently discard */
+                rr-&gt;length = 0;
+                RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
+                goto again;
+            }
+        }
+
+        if ((version &amp; 0xff00) != (s-&gt;version &amp; 0xff00)) {
+            /* wrong version, silently discard record */
+            rr-&gt;length = 0;
+            RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
+            goto again;
+        }
+
+        if (rr-&gt;length &gt; SSL3_RT_MAX_ENCRYPTED_LENGTH) {
+            /* record too long, silently discard it */
+            rr-&gt;length = 0;
+            RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
+            goto again;
+        }
+
+        /* now s-&gt;rlayer.rstate == SSL_ST_READ_BODY */
+    }
+
+    /* s-&gt;rlayer.rstate == SSL_ST_READ_BODY, get and decode the data */
+
+    if (rr-&gt;length &gt;
+        RECORD_LAYER_get_packet_length(&amp;s-&gt;rlayer) - DTLS1_RT_HEADER_LENGTH) {
+        /* now s-&gt;packet_length == DTLS1_RT_HEADER_LENGTH */
+        i = rr-&gt;length;
+        n = ssl3_read_n(s, i, i, 1);
+        /* this packet contained a partial record, dump it */
+        if (n != i) {
+            rr-&gt;length = 0;
+            RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
+            goto again;
+        }
+
+        /*
+         * now n == rr-&gt;length, and s-&gt;packet_length ==
+         * DTLS1_RT_HEADER_LENGTH + rr-&gt;length
+         */
+    }
+    /* set state for later operations */
+    RECORD_LAYER_set_rstate(&amp;s-&gt;rlayer, SSL_ST_READ_HEADER);
+
+    /* match epochs.  NULL means the packet is dropped on the floor */
+    bitmap = dtls1_get_bitmap(s, rr, &amp;is_next_epoch);
+    if (bitmap == NULL) {
+        rr-&gt;length = 0;
+        RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);   /* dump this record */
+        goto again;             /* get another record */
+    }
+#ifndef OPENSSL_NO_SCTP
+    /* Only do replay check if no SCTP bio */
+    if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {
+#endif
+        /*
+         * Check whether this is a repeat, or aged record. Don't check if
+         * we're listening and this message is a ClientHello. They can look
+         * as if they're replayed, since they arrive from different
+         * connections and would be dropped unnecessarily.
+         */
+        if (!(s-&gt;d1-&gt;listen &amp;&amp; rr-&gt;type == SSL3_RT_HANDSHAKE &amp;&amp;
+              RECORD_LAYER_get_packet_length(&amp;s-&gt;rlayer)
+                  &gt; DTLS1_RT_HEADER_LENGTH &amp;&amp;
+              RECORD_LAYER_get_packet(&amp;s-&gt;rlayer)[DTLS1_RT_HEADER_LENGTH]
+                  == SSL3_MT_CLIENT_HELLO) &amp;&amp;
+            !dtls1_record_replay_check(s, bitmap)) {
+            rr-&gt;length = 0;
+            RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer); /* dump this record */
+            goto again;         /* get another record */
+        }
+#ifndef OPENSSL_NO_SCTP
+    }
+#endif
+
+    /* just read a 0 length packet */
+    if (rr-&gt;length == 0)
+        goto again;
+
+    /*
+     * If this record is from the next epoch (either HM or ALERT), and a
+     * handshake is currently in progress, buffer it since it cannot be
+     * processed at this time. However, do not buffer anything while
+     * listening.
+     */
+    if (is_next_epoch) {
+        if ((SSL_in_init(s) || s-&gt;in_handshake) &amp;&amp; !s-&gt;d1-&gt;listen) {
+            if (dtls1_buffer_record
+                (s, &amp;(DTLS_RECORD_LAYER_get_unprocessed_rcds(&amp;s-&gt;rlayer)),
+                rr-&gt;seq_num) &lt; 0)
+                return -1;
+            /* Mark receipt of record. */
+            dtls1_record_bitmap_update(s, bitmap);
+        }
+        rr-&gt;length = 0;
+        RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
+        goto again;
+    }
+
+    if (!dtls1_process_record(s)) {
+        rr-&gt;length = 0;
+        RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);   /* dump this record */
+        goto again;             /* get another record */
+    }
+    dtls1_record_bitmap_update(s, bitmap); /* Mark receipt of record. */
+
+    return (1);
+
+}
+
diff --git a/ssl/s23_clnt.c b/ssl/s23_clnt.c
index 3451b7c..76ad876 100644
--- a/ssl/s23_clnt.c
+++ b/ssl/s23_clnt.c
@@ -481,7 +481,7 @@ static int ssl23_client_hello(SSL *s)
 
 static int ssl23_get_server_hello(SSL *s)
 {
-    char buf[8];
+    unsigned char buf[8];
     unsigned char *p;
     int i;
     int n;
@@ -490,7 +490,7 @@ static int ssl23_get_server_hello(SSL *s)
 
     if (n != 7)
         return (n);
-    p = s-&gt;packet;
+    p = RECORD_LAYER_get_packet(&amp;s-&gt;rlayer);
 
     memcpy(buf, p, n);
 
@@ -573,15 +573,8 @@ static int ssl23_get_server_hello(SSL *s)
         /*
          * put the 7 bytes we have read into the input buffer for SSLv3
          */
-        s-&gt;rstate = SSL_ST_READ_HEADER;
-        s-&gt;packet_length = n;
-        if (s-&gt;s3-&gt;rbuf.buf == NULL)
-            if (!ssl3_setup_read_buffer(s))
-                goto err;
-        s-&gt;packet = &amp;(s-&gt;s3-&gt;rbuf.buf[0]);
-        memcpy(s-&gt;packet, buf, n);
-        s-&gt;s3-&gt;rbuf.left = n;
-        s-&gt;s3-&gt;rbuf.offset = 0;
+        if(!RECORD_LAYER_set_data(&amp;s-&gt;rlayer, buf, n))
+            goto err;
 
         s-&gt;handshake_func = s-&gt;method-&gt;ssl_connect;
     } else {
diff --git a/ssl/s23_srvr.c b/ssl/s23_srvr.c
index 255d278..7287022 100644
--- a/ssl/s23_srvr.c
+++ b/ssl/s23_srvr.c
@@ -244,8 +244,8 @@ int ssl23_get_client_hello(SSL *s)
      *  6-8   length           &gt; Client Hello message
      *  9/10  client_version  /
      */
-    char buf_space[11];
-    char *buf = &amp;(buf_space[0]);
+    unsigned char buf_space[11];
+    unsigned char *buf = &amp;(buf_space[0]);
     unsigned char *p, *d, *d_len, *dd;
     unsigned int i;
     unsigned int csl, sil, cl;
@@ -264,7 +264,7 @@ int ssl23_get_client_hello(SSL *s)
         if (n != sizeof buf_space)
             return (n);         /* n == -1 || n == 0 */
 
-        p = s-&gt;packet;
+        p = RECORD_LAYER_get_packet(&amp;s-&gt;rlayer);
 
         memcpy(buf, p, n);
 
@@ -415,7 +415,7 @@ int ssl23_get_client_hello(SSL *s)
          */
 
         type = 2;
-        p = s-&gt;packet;
+        p = RECORD_LAYER_get_packet(&amp;s-&gt;rlayer);
         v[0] = p[3];            /* == SSL3_VERSION_MAJOR */
         v[1] = p[4];
 
@@ -451,27 +451,32 @@ int ssl23_get_client_hello(SSL *s)
         if (j &lt;= 0)
             return (j);
 
-        ssl3_finish_mac(s, s-&gt;packet + 2, s-&gt;packet_length - 2);
+        ssl3_finish_mac(s, RECORD_LAYER_get_packet(&amp;s-&gt;rlayer) + 2,
+                        RECORD_LAYER_get_packet_length(&amp;s-&gt;rlayer) - 2);
 
         /* CLIENT-HELLO */
         if (s-&gt;msg_callback)
-            s-&gt;msg_callback(0, SSL2_VERSION, 0, s-&gt;packet + 2,
-                            s-&gt;packet_length - 2, s, s-&gt;msg_callback_arg);
+            s-&gt;msg_callback(0, SSL2_VERSION, 0,
+                            RECORD_LAYER_get_packet(&amp;s-&gt;rlayer) + 2,
+                            RECORD_LAYER_get_packet_length(&amp;s-&gt;rlayer) - 2, s,
+                            s-&gt;msg_callback_arg);
 
-        p = s-&gt;packet;
+        p = RECORD_LAYER_get_packet(&amp;s-&gt;rlayer);
         p += 5;
         n2s(p, csl);
         n2s(p, sil);
         n2s(p, cl);
         d = (unsigned char *)s-&gt;init_buf-&gt;data;
-        if ((csl + sil + cl + 11) != s-&gt;packet_length) { /* We can't have TLS
-                                                          * extensions in SSL
-                                                          * 2.0 format *
-                                                          * Client Hello, can
-                                                          * we? Error
-                                                          * condition should
-                                                          * be * '&gt;'
-                                                          * otherweise */
+        if ((csl + sil + cl + 11)
+                != RECORD_LAYER_get_packet_length(&amp;s-&gt;rlayer)) {
+            /* We can't have TLS
+             * extensions in SSL
+             * 2.0 format *
+             * Client Hello, can
+             * we? Error
+             * condition should
+             * be * '&gt;'
+             * otherweise */
             SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,
                    SSL_R_RECORD_LENGTH_MISMATCH);
             goto err;
@@ -556,20 +561,11 @@ int ssl23_get_client_hello(SSL *s)
             /*
              * put the 'n' bytes we have read into the input buffer for SSLv3
              */
-            s-&gt;rstate = SSL_ST_READ_HEADER;
-            s-&gt;packet_length = n;
-            if (s-&gt;s3-&gt;rbuf.buf == NULL)
-                if (!ssl3_setup_read_buffer(s))
-                    goto err;
-
-            s-&gt;packet = &amp;(s-&gt;s3-&gt;rbuf.buf[0]);
-            memcpy(s-&gt;packet, buf, n);
-            s-&gt;s3-&gt;rbuf.left = n;
-            s-&gt;s3-&gt;rbuf.offset = 0;
+            if(!RECORD_LAYER_set_data(&amp;s-&gt;rlayer, buf, n))
+                goto err;
         } else {
-            s-&gt;packet_length = 0;
-            s-&gt;s3-&gt;rbuf.left = 0;
-            s-&gt;s3-&gt;rbuf.offset = 0;
+            if(!RECORD_LAYER_set_data(&amp;s-&gt;rlayer, NULL, 0))
+                goto err;
         }
         s-&gt;handshake_func = s-&gt;method-&gt;ssl_accept;
     } else {
diff --git a/ssl/s3_both.c b/ssl/s3_both.c
index 2bc4e6a..ed6ae12 100644
--- a/ssl/s3_both.c
+++ b/ssl/s3_both.c
@@ -292,7 +292,7 @@ int ssl3_get_finished(SSL *s, int a, int b)
 /*-
  * for these 2 messages, we need to
  * ssl-&gt;enc_read_ctx                    re-init
- * ssl-&gt;s3-&gt;read_sequence               zero
+ * ssl-&gt;rlayer.read_sequence            zero
  * ssl-&gt;s3-&gt;read_mac_secret             re-init
  * ssl-&gt;session-&gt;read_sym_enc           assign
  * ssl-&gt;session-&gt;read_compression       assign
@@ -573,109 +573,6 @@ int ssl_verify_alarm_type(long type)
     return (al);
 }
 
-int ssl3_setup_read_buffer(SSL *s)
-{
-    unsigned char *p;
-    size_t len, align = 0, headerlen;
-
-    if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
-        headerlen = DTLS1_RT_HEADER_LENGTH;
-    else
-        headerlen = SSL3_RT_HEADER_LENGTH;
-
-#if defined(SSL3_ALIGN_PAYLOAD) &amp;&amp; SSL3_ALIGN_PAYLOAD!=0
-    align = (-SSL3_RT_HEADER_LENGTH) &amp; (SSL3_ALIGN_PAYLOAD - 1);
-#endif
-
-    if (s-&gt;s3-&gt;rbuf.buf == NULL) {
-        len = SSL3_RT_MAX_PLAIN_LENGTH
-            + SSL3_RT_MAX_ENCRYPTED_OVERHEAD + headerlen + align;
-        if (s-&gt;options &amp; SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER) {
-            s-&gt;s3-&gt;init_extra = 1;
-            len += SSL3_RT_MAX_EXTRA;
-        }
-#ifndef OPENSSL_NO_COMP
-        if (ssl_allow_compression(s))
-            len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
-#endif
-        if ((p = OPENSSL_malloc(len)) == NULL)
-            goto err;
-        s-&gt;s3-&gt;rbuf.buf = p;
-        s-&gt;s3-&gt;rbuf.len = len;
-    }
-
-    s-&gt;packet = &amp;(s-&gt;s3-&gt;rbuf.buf[0]);
-    return 1;
-
- err:
-    SSLerr(SSL_F_SSL3_SETUP_READ_BUFFER, ERR_R_MALLOC_FAILURE);
-    return 0;
-}
-
-int ssl3_setup_write_buffer(SSL *s)
-{
-    unsigned char *p;
-    size_t len, align = 0, headerlen;
-
-    if (SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
-        headerlen = DTLS1_RT_HEADER_LENGTH + 1;
-    else
-        headerlen = SSL3_RT_HEADER_LENGTH;
-
-#if defined(SSL3_ALIGN_PAYLOAD) &amp;&amp; SSL3_ALIGN_PAYLOAD!=0
-    align = (-SSL3_RT_HEADER_LENGTH) &amp; (SSL3_ALIGN_PAYLOAD - 1);
-#endif
-
-    if (s-&gt;s3-&gt;wbuf.buf == NULL) {
-        len = s-&gt;max_send_fragment
-            + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD + headerlen + align;
-#ifndef OPENSSL_NO_COMP
-        if (ssl_allow_compression(s))
-            len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
-#endif
-        if (!(s-&gt;options &amp; SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
-            len += headerlen + align + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD;
-
-        if ((p = OPENSSL_malloc(len)) == NULL)
-            goto err;
-        s-&gt;s3-&gt;wbuf.buf = p;
-        s-&gt;s3-&gt;wbuf.len = len;
-    }
-
-    return 1;
-
- err:
-    SSLerr(SSL_F_SSL3_SETUP_WRITE_BUFFER, ERR_R_MALLOC_FAILURE);
-    return 0;
-}
-
-int ssl3_setup_buffers(SSL *s)
-{
-    if (!ssl3_setup_read_buffer(s))
-        return 0;
-    if (!ssl3_setup_write_buffer(s))
-        return 0;
-    return 1;
-}
-
-int ssl3_release_write_buffer(SSL *s)
-{
-    if (s-&gt;s3-&gt;wbuf.buf != NULL) {
-        OPENSSL_free(s-&gt;s3-&gt;wbuf.buf);
-        s-&gt;s3-&gt;wbuf.buf = NULL;
-    }
-    return 1;
-}
-
-int ssl3_release_read_buffer(SSL *s)
-{
-    if (s-&gt;s3-&gt;rbuf.buf != NULL) {
-        OPENSSL_free(s-&gt;s3-&gt;rbuf.buf);
-        s-&gt;s3-&gt;rbuf.buf = NULL;
-    }
-    return 1;
-}
-
 int ssl_allow_compression(SSL *s)
 {
     if (s-&gt;options &amp; SSL_OP_NO_COMPRESSION)
diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c
index 53e3c87..b20c564 100644
--- a/ssl/s3_cbc.c
+++ b/ssl/s3_cbc.c
@@ -72,227 +72,7 @@
  */
 #define MAX_HASH_BLOCK_SIZE 128
 
-/*-
- * ssl3_cbc_remove_padding removes padding from the decrypted, SSLv3, CBC
- * record in |rec| by updating |rec-&gt;length| in constant time.
- *
- * block_size: the block size of the cipher used to encrypt the record.
- * returns:
- *   0: (in non-constant time) if the record is publicly invalid.
- *   1: if the padding was valid
- *  -1: otherwise.
- */
-int ssl3_cbc_remove_padding(const SSL *s,
-                            SSL3_RECORD *rec,
-                            unsigned block_size, unsigned mac_size)
-{
-    unsigned padding_length, good;
-    const unsigned overhead = 1 /* padding length byte */  + mac_size;
-
-    /*
-     * These lengths are all public so we can test them in non-constant time.
-     */
-    if (overhead &gt; rec-&gt;length)
-        return 0;
-
-    padding_length = rec-&gt;data[rec-&gt;length - 1];
-    good = constant_time_ge(rec-&gt;length, padding_length + overhead);
-    /* SSLv3 requires that the padding is minimal. */
-    good &amp;= constant_time_ge(block_size, padding_length + 1);
-    rec-&gt;length -= good &amp; (padding_length + 1);
-    return constant_time_select_int(good, 1, -1);
-}
-
-/*-
- * tls1_cbc_remove_padding removes the CBC padding from the decrypted, TLS, CBC
- * record in |rec| in constant time and returns 1 if the padding is valid and
- * -1 otherwise. It also removes any explicit IV from the start of the record
- * without leaking any timing about whether there was enough space after the
- * padding was removed.
- *
- * block_size: the block size of the cipher used to encrypt the record.
- * returns:
- *   0: (in non-constant time) if the record is publicly invalid.
- *   1: if the padding was valid
- *  -1: otherwise.
- */
-int tls1_cbc_remove_padding(const SSL *s,
-                            SSL3_RECORD *rec,
-                            unsigned block_size, unsigned mac_size)
-{
-    unsigned padding_length, good, to_check, i;
-    const unsigned overhead = 1 /* padding length byte */  + mac_size;
-    /* Check if version requires explicit IV */
-    if (SSL_USE_EXPLICIT_IV(s)) {
-        /*
-         * These lengths are all public so we can test them in non-constant
-         * time.
-         */
-        if (overhead + block_size &gt; rec-&gt;length)
-            return 0;
-        /* We can now safely skip explicit IV */
-        rec-&gt;data += block_size;
-        rec-&gt;input += block_size;
-        rec-&gt;length -= block_size;
-        rec-&gt;orig_len -= block_size;
-    } else if (overhead &gt; rec-&gt;length)
-        return 0;
-
-    padding_length = rec-&gt;data[rec-&gt;length - 1];
-
-    /*
-     * NB: if compression is in operation the first packet may not be of even
-     * length so the padding bug check cannot be performed. This bug
-     * workaround has been around since SSLeay so hopefully it is either
-     * fixed now or no buggy implementation supports compression [steve]
-     */
-    if ((s-&gt;options &amp; SSL_OP_TLS_BLOCK_PADDING_BUG) &amp;&amp; !s-&gt;expand) {
-        /* First packet is even in size, so check */
-        if ((memcmp(s-&gt;s3-&gt;read_sequence, &quot;\0\0\0\0\0\0\0\0&quot;, 8) == 0) &amp;&amp;
-            !(padding_length &amp; 1)) {
-            s-&gt;s3-&gt;flags |= TLS1_FLAGS_TLS_PADDING_BUG;
-        }
-        if ((s-&gt;s3-&gt;flags &amp; TLS1_FLAGS_TLS_PADDING_BUG) &amp;&amp; padding_length &gt; 0) {
-            padding_length--;
-        }
-    }
-
-    if (EVP_CIPHER_flags(s-&gt;enc_read_ctx-&gt;cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) {
-        /* padding is already verified */
-        rec-&gt;length -= padding_length + 1;
-        return 1;
-    }
-
-    good = constant_time_ge(rec-&gt;length, overhead + padding_length);
-    /*
-     * The padding consists of a length byte at the end of the record and
-     * then that many bytes of padding, all with the same value as the length
-     * byte. Thus, with the length byte included, there are i+1 bytes of
-     * padding. We can't check just |padding_length+1| bytes because that
-     * leaks decrypted information. Therefore we always have to check the
-     * maximum amount of padding possible. (Again, the length of the record
-     * is public information so we can use it.)
-     */
-    to_check = 255;             /* maximum amount of padding. */
-    if (to_check &gt; rec-&gt;length - 1)
-        to_check = rec-&gt;length - 1;
-
-    for (i = 0; i &lt; to_check; i++) {
-        unsigned char mask = constant_time_ge_8(padding_length, i);
-        unsigned char b = rec-&gt;data[rec-&gt;length - 1 - i];
-        /*
-         * The final |padding_length+1| bytes should all have the value
-         * |padding_length|. Therefore the XOR should be zero.
-         */
-        good &amp;= ~(mask &amp; (padding_length ^ b));
-    }
-
-    /*
-     * If any of the final |padding_length+1| bytes had the wrong value, one
-     * or more of the lower eight bits of |good| will be cleared.
-     */
-    good = constant_time_eq(0xff, good &amp; 0xff);
-    rec-&gt;length -= good &amp; (padding_length + 1);
-
-    return constant_time_select_int(good, 1, -1);
-}
-
-/*-
- * ssl3_cbc_copy_mac copies |md_size| bytes from the end of |rec| to |out| in
- * constant time (independent of the concrete value of rec-&gt;length, which may
- * vary within a 256-byte window).
- *
- * ssl3_cbc_remove_padding or tls1_cbc_remove_padding must be called prior to
- * this function.
- *
- * On entry:
- *   rec-&gt;orig_len &gt;= md_size
- *   md_size &lt;= EVP_MAX_MD_SIZE
- *
- * If CBC_MAC_ROTATE_IN_PLACE is defined then the rotation is performed with
- * variable accesses in a 64-byte-aligned buffer. Assuming that this fits into
- * a single or pair of cache-lines, then the variable memory accesses don't
- * actually affect the timing. CPUs with smaller cache-lines [if any] are
- * not multi-core and are not considered vulnerable to cache-timing attacks.
- */
-#define CBC_MAC_ROTATE_IN_PLACE
-
-void ssl3_cbc_copy_mac(unsigned char *out,
-                       const SSL3_RECORD *rec, unsigned md_size)
-{
-#if defined(CBC_MAC_ROTATE_IN_PLACE)
-    unsigned char rotated_mac_buf[64 + EVP_MAX_MD_SIZE];
-    unsigned char *rotated_mac;
-#else
-    unsigned char rotated_mac[EVP_MAX_MD_SIZE];
-#endif
 
-    /*
-     * mac_end is the index of |rec-&gt;data| just after the end of the MAC.
-     */
-    unsigned mac_end = rec-&gt;length;
-    unsigned mac_start = mac_end - md_size;
-    /*
-     * scan_start contains the number of bytes that we can ignore because the
-     * MAC's position can only vary by 255 bytes.
-     */
-    unsigned scan_start = 0;
-    unsigned i, j;
-    unsigned div_spoiler;
-    unsigned rotate_offset;
-
-    OPENSSL_assert(rec-&gt;orig_len &gt;= md_size);
-    OPENSSL_assert(md_size &lt;= EVP_MAX_MD_SIZE);
-
-#if defined(CBC_MAC_ROTATE_IN_PLACE)
-    rotated_mac = rotated_mac_buf + ((0 - (size_t)rotated_mac_buf) &amp; 63);
-#endif
-
-    /* This information is public so it's safe to branch based on it. */
-    if (rec-&gt;orig_len &gt; md_size + 255 + 1)
-        scan_start = rec-&gt;orig_len - (md_size + 255 + 1);
-    /*
-     * div_spoiler contains a multiple of md_size that is used to cause the
-     * modulo operation to be constant time. Without this, the time varies
-     * based on the amount of padding when running on Intel chips at least.
-     * The aim of right-shifting md_size is so that the compiler doesn't
-     * figure out that it can remove div_spoiler as that would require it to
-     * prove that md_size is always even, which I hope is beyond it.
-     */
-    div_spoiler = md_size &gt;&gt; 1;
-    div_spoiler &lt;&lt;= (sizeof(div_spoiler) - 1) * 8;
-    rotate_offset = (div_spoiler + mac_start - scan_start) % md_size;
-
-    memset(rotated_mac, 0, md_size);
-    for (i = scan_start, j = 0; i &lt; rec-&gt;orig_len; i++) {
-        unsigned char mac_started = constant_time_ge_8(i, mac_start);
-        unsigned char mac_ended = constant_time_ge_8(i, mac_end);
-        unsigned char b = rec-&gt;data[i];
-        rotated_mac[j++] |= b &amp; mac_started &amp; ~mac_ended;
-        j &amp;= constant_time_lt(j, md_size);
-    }
-
-    /* Now rotate the MAC */
-#if defined(CBC_MAC_ROTATE_IN_PLACE)
-    j = 0;
-    for (i = 0; i &lt; md_size; i++) {
-        /* in case cache-line is 32 bytes, touch second line */
-        ((volatile unsigned char *)rotated_mac)[rotate_offset ^ 32];
-        out[j++] = rotated_mac[rotate_offset++];
-        rotate_offset &amp;= constant_time_lt(rotate_offset, md_size);
-    }
-#else
-    memset(out, 0, md_size);
-    rotate_offset = md_size - rotate_offset;
-    rotate_offset &amp;= constant_time_lt(rotate_offset, md_size);
-    for (i = 0; i &lt; md_size; i++) {
-        for (j = 0; j &lt; md_size; j++)
-            out[j] |= rotated_mac[i] &amp; constant_time_eq_8(j, rotate_offset);
-        rotate_offset++;
-        rotate_offset &amp;= constant_time_lt(rotate_offset, md_size);
-    }
-#endif
-}
 
 /*
  * u32toLE serialises an unsigned, 32-bit number (n) as four bytes at (p) in
diff --git a/ssl/s3_enc.c b/ssl/s3_enc.c
index 94f6dd0..1db2f77 100644
--- a/ssl/s3_enc.c
+++ b/ssl/s3_enc.c
@@ -270,14 +270,11 @@ int ssl3_change_cipher_state(SSL *s, int which)
                        SSL_R_COMPRESSION_LIBRARY_ERROR);
                 goto err2;
             }
-            if (s-&gt;s3-&gt;rrec.comp == NULL)
-                s-&gt;s3-&gt;rrec.comp = (unsigned char *)
-                    OPENSSL_malloc(SSL3_RT_MAX_PLAIN_LENGTH);
-            if (s-&gt;s3-&gt;rrec.comp == NULL)
+            if(!RECORD_LAYER_setup_comp_buffer(&amp;s-&gt;rlayer))
                 goto err;
         }
 #endif
-        memset(&amp;(s-&gt;s3-&gt;read_sequence[0]), 0, 8);
+        RECORD_LAYER_reset_read_sequence(&amp;s-&gt;rlayer);
         mac_secret = &amp;(s-&gt;s3-&gt;read_mac_secret[0]);
     } else {
         if (s-&gt;enc_write_ctx != NULL)
@@ -310,7 +307,7 @@ int ssl3_change_cipher_state(SSL *s, int which)
             }
         }
 #endif
-        memset(&amp;(s-&gt;s3-&gt;write_sequence[0]), 0, 8);
+        RECORD_LAYER_reset_write_sequence(&amp;s-&gt;rlayer);
         mac_secret = &amp;(s-&gt;s3-&gt;write_mac_secret[0]);
     }
 
@@ -482,80 +479,6 @@ void ssl3_cleanup_key_block(SSL *s)
     s-&gt;s3-&gt;tmp.key_block_length = 0;
 }
 
-/*-
- * ssl3_enc encrypts/decrypts the record in |s-&gt;wrec| / |s-&gt;rrec|, respectively.
- *
- * Returns:
- *   0: (in non-constant time) if the record is publically invalid (i.e. too
- *       short etc).
- *   1: if the record's padding is valid / the encryption was successful.
- *   -1: if the record's padding is invalid or, if sending, an internal error
- *       occurred.
- */
-int ssl3_enc(SSL *s, int send)
-{
-    SSL3_RECORD *rec;
-    EVP_CIPHER_CTX *ds;
-    unsigned long l;
-    int bs, i, mac_size = 0;
-    const EVP_CIPHER *enc;
-
-    if (send) {
-        ds = s-&gt;enc_write_ctx;
-        rec = &amp;(s-&gt;s3-&gt;wrec);
-        if (s-&gt;enc_write_ctx == NULL)
-            enc = NULL;
-        else
-            enc = EVP_CIPHER_CTX_cipher(s-&gt;enc_write_ctx);
-    } else {
-        ds = s-&gt;enc_read_ctx;
-        rec = &amp;(s-&gt;s3-&gt;rrec);
-        if (s-&gt;enc_read_ctx == NULL)
-            enc = NULL;
-        else
-            enc = EVP_CIPHER_CTX_cipher(s-&gt;enc_read_ctx);
-    }
-
-    if ((s-&gt;session == NULL) || (ds == NULL) || (enc == NULL)) {
-        memmove(rec-&gt;data, rec-&gt;input, rec-&gt;length);
-        rec-&gt;input = rec-&gt;data;
-    } else {
-        l = rec-&gt;length;
-        bs = EVP_CIPHER_block_size(ds-&gt;cipher);
-
-        /* COMPRESS */
-
-        if ((bs != 1) &amp;&amp; send) {
-            i = bs - ((int)l % bs);
-
-            /* we need to add 'i-1' padding bytes */
-            l += i;
-            /*
-             * the last of these zero bytes will be overwritten with the
-             * padding length.
-             */
-            memset(&amp;rec-&gt;input[rec-&gt;length], 0, i);
-            rec-&gt;length += i;
-            rec-&gt;input[l - 1] = (i - 1);
-        }
-
-        if (!send) {
-            if (l == 0 || l % bs != 0)
-                return 0;
-            /* otherwise, rec-&gt;length &gt;= bs */
-        }
-
-        if (EVP_Cipher(ds, rec-&gt;data, rec-&gt;input, l) &lt; 1)
-            return -1;
-
-        if (EVP_MD_CTX_md(s-&gt;read_hash) != NULL)
-            mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
-        if ((bs != 1) &amp;&amp; !send)
-            return ssl3_cbc_remove_padding(s, rec, bs, mac_size);
-    }
-    return (1);
-}
-
 void ssl3_init_finished_mac(SSL *s)
 {
     BIO_free(s-&gt;s3-&gt;handshake_buffer);
@@ -715,112 +638,6 @@ static int ssl3_handshake_mac(SSL *s, int md_nid,
     return ((int)ret);
 }
 
-int n_ssl3_mac(SSL *ssl, unsigned char *md, int send)
-{
-    SSL3_RECORD *rec;
-    unsigned char *mac_sec, *seq;
-    EVP_MD_CTX md_ctx;
-    const EVP_MD_CTX *hash;
-    unsigned char *p, rec_char;
-    size_t md_size;
-    int npad;
-    int t;
-
-    if (send) {
-        rec = &amp;(ssl-&gt;s3-&gt;wrec);
-        mac_sec = &amp;(ssl-&gt;s3-&gt;write_mac_secret[0]);
-        seq = &amp;(ssl-&gt;s3-&gt;write_sequence[0]);
-        hash = ssl-&gt;write_hash;
-    } else {
-        rec = &amp;(ssl-&gt;s3-&gt;rrec);
-        mac_sec = &amp;(ssl-&gt;s3-&gt;read_mac_secret[0]);
-        seq = &amp;(ssl-&gt;s3-&gt;read_sequence[0]);
-        hash = ssl-&gt;read_hash;
-    }
-
-    t = EVP_MD_CTX_size(hash);
-    if (t &lt; 0)
-        return -1;
-    md_size = t;
-    npad = (48 / md_size) * md_size;
-
-    if (!send &amp;&amp;
-        EVP_CIPHER_CTX_mode(ssl-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE &amp;&amp;
-        ssl3_cbc_record_digest_supported(hash)) {
-        /*
-         * This is a CBC-encrypted record. We must avoid leaking any
-         * timing-side channel information about how many blocks of data we
-         * are hashing because that gives an attacker a timing-oracle.
-         */
-
-        /*-
-         * npad is, at most, 48 bytes and that's with MD5:
-         *   16 + 48 + 8 (sequence bytes) + 1 + 2 = 75.
-         *
-         * With SHA-1 (the largest hash speced for SSLv3) the hash size
-         * goes up 4, but npad goes down by 8, resulting in a smaller
-         * total size.
-         */
-        unsigned char header[75];
-        unsigned j = 0;
-        memcpy(header + j, mac_sec, md_size);
-        j += md_size;
-        memcpy(header + j, ssl3_pad_1, npad);
-        j += npad;
-        memcpy(header + j, seq, 8);
-        j += 8;
-        header[j++] = rec-&gt;type;
-        header[j++] = rec-&gt;length &gt;&gt; 8;
-        header[j++] = rec-&gt;length &amp; 0xff;
-
-        /* Final param == is SSLv3 */
-        ssl3_cbc_digest_record(hash,
-                               md, &amp;md_size,
-                               header, rec-&gt;input,
-                               rec-&gt;length + md_size, rec-&gt;orig_len,
-                               mac_sec, md_size, 1);
-    } else {
-        unsigned int md_size_u;
-        /* Chop the digest off the end :-) */
-        EVP_MD_CTX_init(&amp;md_ctx);
-
-        EVP_MD_CTX_copy_ex(&amp;md_ctx, hash);
-        EVP_DigestUpdate(&amp;md_ctx, mac_sec, md_size);
-        EVP_DigestUpdate(&amp;md_ctx, ssl3_pad_1, npad);
-        EVP_DigestUpdate(&amp;md_ctx, seq, 8);
-        rec_char = rec-&gt;type;
-        EVP_DigestUpdate(&amp;md_ctx, &amp;rec_char, 1);
-        p = md;
-        s2n(rec-&gt;length, p);
-        EVP_DigestUpdate(&amp;md_ctx, md, 2);
-        EVP_DigestUpdate(&amp;md_ctx, rec-&gt;input, rec-&gt;length);
-        EVP_DigestFinal_ex(&amp;md_ctx, md, NULL);
-
-        EVP_MD_CTX_copy_ex(&amp;md_ctx, hash);
-        EVP_DigestUpdate(&amp;md_ctx, mac_sec, md_size);
-        EVP_DigestUpdate(&amp;md_ctx, ssl3_pad_2, npad);
-        EVP_DigestUpdate(&amp;md_ctx, md, md_size);
-        EVP_DigestFinal_ex(&amp;md_ctx, md, &amp;md_size_u);
-        md_size = md_size_u;
-
-        EVP_MD_CTX_cleanup(&amp;md_ctx);
-    }
-
-    ssl3_record_sequence_update(seq);
-    return (md_size);
-}
-
-void ssl3_record_sequence_update(unsigned char *seq)
-{
-    int i;
-
-    for (i = 7; i &gt;= 0; i--) {
-        ++seq[i];
-        if (seq[i] != 0)
-            break;
-    }
-}
-
 int ssl3_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
                                 int len)
 {
diff --git a/ssl/s3_lib.c b/ssl/s3_lib.c
index 69f3d5d..a7dbbf6 100644
--- a/ssl/s3_lib.c
+++ b/ssl/s3_lib.c
@@ -3078,15 +3078,6 @@ const SSL_CIPHER *ssl3_get_cipher(unsigned int u)
         return (NULL);
 }
 
-int ssl3_pending(const SSL *s)
-{
-    if (s-&gt;rstate == SSL_ST_READ_BODY)
-        return 0;
-
-    return (s-&gt;s3-&gt;rrec.type ==
-            SSL3_RT_APPLICATION_DATA) ? s-&gt;s3-&gt;rrec.length : 0;
-}
-
 int ssl3_set_handshake_header(SSL *s, int htype, unsigned long len)
 {
     unsigned char *p = (unsigned char *)s-&gt;init_buf-&gt;data;
@@ -3110,11 +3101,8 @@ int ssl3_new(SSL *s)
     if ((s3 = OPENSSL_malloc(sizeof *s3)) == NULL)
         goto err;
     memset(s3, 0, sizeof *s3);
-    memset(s3-&gt;rrec.seq_num, 0, sizeof(s3-&gt;rrec.seq_num));
-    memset(s3-&gt;wrec.seq_num, 0, sizeof(s3-&gt;wrec.seq_num));
-
     s-&gt;s3 = s3;
-
+    
 #ifndef OPENSSL_NO_SRP
     if(!SSL_SRP_CTX_init(s))
           goto err;
@@ -3131,12 +3119,6 @@ void ssl3_free(SSL *s)
         return;
 
     ssl3_cleanup_key_block(s);
-    if (s-&gt;s3-&gt;rbuf.buf != NULL)
-        ssl3_release_read_buffer(s);
-    if (s-&gt;s3-&gt;wbuf.buf != NULL)
-        ssl3_release_write_buffer(s);
-    if (s-&gt;s3-&gt;rrec.comp != NULL)
-        OPENSSL_free(s-&gt;s3-&gt;rrec.comp);
 #ifndef OPENSSL_NO_DH
     DH_free(s-&gt;s3-&gt;tmp.dh);
 #endif
@@ -3164,18 +3146,12 @@ void ssl3_free(SSL *s)
 
 void ssl3_clear(SSL *s)
 {
-    unsigned char *rp, *wp;
-    size_t rlen, wlen;
     int init_extra;
 
     ssl3_cleanup_key_block(s);
     if (s-&gt;s3-&gt;tmp.ca_names != NULL)
         sk_X509_NAME_pop_free(s-&gt;s3-&gt;tmp.ca_names, X509_NAME_free);
 
-    if (s-&gt;s3-&gt;rrec.comp != NULL) {
-        OPENSSL_free(s-&gt;s3-&gt;rrec.comp);
-        s-&gt;s3-&gt;rrec.comp = NULL;
-    }
 #ifndef OPENSSL_NO_DH
     DH_free(s-&gt;s3-&gt;tmp.dh);
     s-&gt;s3-&gt;tmp.dh = NULL;
@@ -3190,10 +3166,6 @@ void ssl3_clear(SSL *s)
 # endif                         /* !OPENSSL_NO_EC */
 #endif                          /* !OPENSSL_NO_TLSEXT */
 
-    rp = s-&gt;s3-&gt;rbuf.buf;
-    wp = s-&gt;s3-&gt;wbuf.buf;
-    rlen = s-&gt;s3-&gt;rbuf.len;
-    wlen = s-&gt;s3-&gt;wbuf.len;
     init_extra = s-&gt;s3-&gt;init_extra;
     BIO_free(s-&gt;s3-&gt;handshake_buffer);
     s-&gt;s3-&gt;handshake_buffer = NULL;
@@ -3207,15 +3179,10 @@ void ssl3_clear(SSL *s)
     }
 #endif
     memset(s-&gt;s3, 0, sizeof *s-&gt;s3);
-    s-&gt;s3-&gt;rbuf.buf = rp;
-    s-&gt;s3-&gt;wbuf.buf = wp;
-    s-&gt;s3-&gt;rbuf.len = rlen;
-    s-&gt;s3-&gt;wbuf.len = wlen;
     s-&gt;s3-&gt;init_extra = init_extra;
 
     ssl_free_wbio_buffer(s);
 
-    s-&gt;packet_length = 0;
     s-&gt;s3-&gt;renegotiate = 0;
     s-&gt;s3-&gt;total_renegotiations = 0;
     s-&gt;s3-&gt;num_renegotiations = 0;
@@ -4494,8 +4461,9 @@ int ssl3_renegotiate_check(SSL *s)
     int ret = 0;
 
     if (s-&gt;s3-&gt;renegotiate) {
-        if ((s-&gt;s3-&gt;rbuf.left == 0) &amp;&amp;
-            (s-&gt;s3-&gt;wbuf.left == 0) &amp;&amp; !SSL_in_init(s)) {
+        if (!RECORD_LAYER_read_pending(&amp;s-&gt;rlayer)
+            &amp;&amp; !RECORD_LAYER_write_pending(&amp;s-&gt;rlayer)
+            &amp;&amp; !SSL_in_init(s)) {
             /*
              * if we are the server, and we have sent a 'RENEGOTIATE'
              * message, we need to go to SSL_ST_ACCEPT.
diff --git a/apps/app_rand.c b/ssl/s3_msg.c
similarity index 62%
copy from apps/app_rand.c
copy to ssl/s3_msg.c
index 595fc78..fcf4744 100644
--- a/apps/app_rand.c
+++ b/ssl/s3_msg.c
@@ -1,4 +1,4 @@
-/* apps/app_rand.c */
+/* ssl/s3_msg.c */
 /* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
  * All rights reserved.
  *
@@ -56,7 +56,7 @@
  * [including the GNU Public Licence.]
  */
 /* ====================================================================
- * Copyright (c) 1998-2000 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -109,112 +109,118 @@
  *
  */
 
-#define NON_MAIN
-#include &quot;apps.h&quot;
-#undef NON_MAIN
-#include &lt;openssl/bio.h&gt;
-#include &lt;openssl/rand.h&gt;
+#define USE_SOCKETS
+#include &quot;ssl_locl.h&quot;
 
-static int seeded = 0;
-static int egdsocket = 0;
-
-int app_RAND_load_file(const char *file, BIO *bio_e, int dont_warn)
+int ssl3_do_change_cipher_spec(SSL *s)
 {
-    int consider_randfile = (file == NULL);
-    char buffer[200];
-
-#ifdef OPENSSL_SYS_WINDOWS
-    BIO_printf(bio_e, &quot;Loading 'screen' into random state -&quot;);
-    BIO_flush(bio_e);
-    RAND_screen();
-    BIO_printf(bio_e, &quot; done\n&quot;);
-#endif
-
-    if (file == NULL)
-        file = RAND_file_name(buffer, sizeof buffer);
-    else if (RAND_egd(file) &gt; 0) {
-        /*
-         * we try if the given filename is an EGD socket. if it is, we don't
-         * write anything back to the file.
-         */
-        egdsocket = 1;
-        return 1;
-    }
-    if (file == NULL || !RAND_load_file(file, -1)) {
-        if (RAND_status() == 0) {
-            if (!dont_warn) {
-                BIO_printf(bio_e, &quot;unable to load 'random state'\n&quot;);
-                BIO_printf(bio_e,
-                           &quot;This means that the random number generator has not been seeded\n&quot;);
-                BIO_printf(bio_e, &quot;with much random data.\n&quot;);
-                if (consider_randfile) { /* explanation does not apply when a
-                                          * file is explicitly named */
-                    BIO_printf(bio_e,
-                               &quot;Consider setting the RANDFILE environment variable to point at a file that\n&quot;);
-                    BIO_printf(bio_e,
-                               &quot;'random' data can be kept in (the file will be overwritten).\n&quot;);
-                }
-            }
-            return 0;
+    int i;
+    const char *sender;
+    int slen;
+
+    if (s-&gt;state &amp; SSL_ST_ACCEPT)
+        i = SSL3_CHANGE_CIPHER_SERVER_READ;
+    else
+        i = SSL3_CHANGE_CIPHER_CLIENT_READ;
+
+    if (s-&gt;s3-&gt;tmp.key_block == NULL) {
+        if (s-&gt;session == NULL || s-&gt;session-&gt;master_key_length == 0) {
+            /* might happen if dtls1_read_bytes() calls this */
+            SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,
+                   SSL_R_CCS_RECEIVED_EARLY);
+            return (0);
         }
+
+        s-&gt;session-&gt;cipher = s-&gt;s3-&gt;tmp.new_cipher;
+        if (!s-&gt;method-&gt;ssl3_enc-&gt;setup_key_block(s))
+            return (0);
+    }
+
+    if (!s-&gt;method-&gt;ssl3_enc-&gt;change_cipher_state(s, i))
+        return (0);
+
+    /*
+     * we have to record the message digest at this point so we can get it
+     * before we read the finished message
+     */
+    if (s-&gt;state &amp; SSL_ST_CONNECT) {
+        sender = s-&gt;method-&gt;ssl3_enc-&gt;server_finished_label;
+        slen = s-&gt;method-&gt;ssl3_enc-&gt;server_finished_label_len;
+    } else {
+        sender = s-&gt;method-&gt;ssl3_enc-&gt;client_finished_label;
+        slen = s-&gt;method-&gt;ssl3_enc-&gt;client_finished_label_len;
     }
-    seeded = 1;
-    return 1;
+
+    i = s-&gt;method-&gt;ssl3_enc-&gt;final_finish_mac(s,
+                                              sender, slen,
+                                              s-&gt;s3-&gt;tmp.peer_finish_md);
+    if (i == 0) {
+        SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+    s-&gt;s3-&gt;tmp.peer_finish_md_len = i;
+
+    return (1);
 }
 
-long app_RAND_load_files(char *name)
+int ssl3_send_alert(SSL *s, int level, int desc)
 {
-    char *p, *n;
-    int last;
-    long tot = 0;
-    int egd;
-
-    for (;;) {
-        last = 0;
-        for (p = name; ((*p != '\0') &amp;&amp; (*p != LIST_SEPARATOR_CHAR)); p++) ;
-        if (*p == '\0')
-            last = 1;
-        *p = '\0';
-        n = name;
-        name = p + 1;
-        if (*n == '\0')
-            break;
-
-        egd = RAND_egd(n);
-        if (egd &gt; 0)
-            tot += egd;
-        else
-            tot += RAND_load_file(n, -1);
-        if (last)
-            break;
+    /* Map tls/ssl alert value to correct one */
+    desc = s-&gt;method-&gt;ssl3_enc-&gt;alert_value(desc);
+    if (s-&gt;version == SSL3_VERSION &amp;&amp; desc == SSL_AD_PROTOCOL_VERSION)
+        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have
+                                          * protocol_version alerts */
+    if (desc &lt; 0)
+        return -1;
+    /* If a fatal one, remove from cache */
+    if ((level == SSL3_AL_FATAL) &amp;&amp; (s-&gt;session != NULL))
+        SSL_CTX_remove_session(s-&gt;ctx, s-&gt;session);
+
+    s-&gt;s3-&gt;alert_dispatch = 1;
+    s-&gt;s3-&gt;send_alert[0] = level;
+    s-&gt;s3-&gt;send_alert[1] = desc;
+    if (!RECORD_LAYER_write_pending(&amp;s-&gt;rlayer)) {
+        /* data still being written out? */
+        return s-&gt;method-&gt;ssl_dispatch_alert(s);
     }
-    if (tot &gt; 512)
-        app_RAND_allow_write_file();
-    return (tot);
+    /*
+     * else data is still being written out, we will get written some time in
+     * the future
+     */
+    return -1;
 }
 
-int app_RAND_write_file(const char *file, BIO *bio_e)
+int ssl3_dispatch_alert(SSL *s)
 {
-    char buffer[200];
+    int i, j;
+    void (*cb) (const SSL *ssl, int type, int val) = NULL;
 
-    if (egdsocket || !seeded)
+    s-&gt;s3-&gt;alert_dispatch = 0;
+    i = do_ssl3_write(s, SSL3_RT_ALERT, &amp;s-&gt;s3-&gt;send_alert[0], 2, 0);
+    if (i &lt;= 0) {
+        s-&gt;s3-&gt;alert_dispatch = 1;
+    } else {
         /*
-         * If we did not manage to read the seed file, we should not write a
-         * low-entropy seed file back -- it would suppress a crucial warning
-         * the next time we want to use it.
+         * Alert sent to BIO.  If it is important, flush it now. If the
+         * message does not get sent due to non-blocking IO, we will not
+         * worry too much.
          */
-        return 0;
+        if (s-&gt;s3-&gt;send_alert[0] == SSL3_AL_FATAL)
+            (void)BIO_flush(s-&gt;wbio);
 
-    if (file == NULL)
-        file = RAND_file_name(buffer, sizeof buffer);
-    if (file == NULL || !RAND_write_file(file)) {
-        BIO_printf(bio_e, &quot;unable to write 'random state'\n&quot;);
-        return 0;
-    }
-    return 1;
-}
+        if (s-&gt;msg_callback)
+            s-&gt;msg_callback(1, s-&gt;version, SSL3_RT_ALERT, s-&gt;s3-&gt;send_alert,
+                            2, s, s-&gt;msg_callback_arg);
 
-void app_RAND_allow_write_file(void)
-{
-    seeded = 1;
+        if (s-&gt;info_callback != NULL)
+            cb = s-&gt;info_callback;
+        else if (s-&gt;ctx-&gt;info_callback != NULL)
+            cb = s-&gt;ctx-&gt;info_callback;
+
+        if (cb != NULL) {
+            j = (s-&gt;s3-&gt;send_alert[0] &lt;&lt; 8) | s-&gt;s3-&gt;send_alert[1];
+            cb(s, SSL_CB_WRITE_ALERT, j);
+        }
+    }
+    return (i);
 }
diff --git a/ssl/ssl.h b/ssl/ssl.h
index 55aa6a6..50a79a8 100644
--- a/ssl/ssl.h
+++ b/ssl/ssl.h
@@ -999,8 +999,8 @@ extern &quot;C&quot; {
 # define SSL_in_accept_init(a)           (SSL_state(a)&amp;SSL_ST_ACCEPT)
 
 /*
- * The following 2 states are kept in ssl-&gt;rstate when reads fail, you should
- * not need these
+ * The following 3 states are kept in ssl-&gt;rlayer.rstate when reads fail, you
+ * should not need these
  */
 # define SSL_ST_READ_HEADER                      0xF0
 # define SSL_ST_READ_BODY                        0xF1
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index 0b2d8de..abb3fd3 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -189,7 +189,6 @@ SSL3_ENC_METHOD ssl3_undef_enc_method = {
 
 int SSL_clear(SSL *s)
 {
-
     if (s-&gt;method == NULL) {
         SSLerr(SSL_F_SSL_CLEAR, SSL_R_NO_METHOD_SPECIFIED);
         return (0);
@@ -216,7 +215,6 @@ int SSL_clear(SSL *s)
     s-&gt;version = s-&gt;method-&gt;version;
     s-&gt;client_version = s-&gt;version;
     s-&gt;rwstate = SSL_NOTHING;
-    s-&gt;rstate = SSL_ST_READ_HEADER;
 
     if (s-&gt;init_buf != NULL) {
         BUF_MEM_free(s-&gt;init_buf);
@@ -241,6 +239,9 @@ int SSL_clear(SSL *s)
             return (0);
     } else
         s-&gt;method-&gt;ssl_clear(s);
+
+    RECORD_LAYER_clear(&amp;s-&gt;rlayer);
+
     return (1);
 }
 
@@ -280,6 +281,8 @@ SSL *SSL_new(SSL_CTX *ctx)
         goto err;
     memset(s, 0, sizeof(SSL));
 
+    RECORD_LAYER_init(&amp;s-&gt;rlayer, s);
+
 #ifndef OPENSSL_NO_KRB5
     s-&gt;kssl_ctx = kssl_ctx_new();
 #endif                          /* OPENSSL_NO_KRB5 */
@@ -301,7 +304,7 @@ SSL *SSL_new(SSL_CTX *ctx)
     if (s-&gt;cert == NULL)
         goto err;
 
-    s-&gt;read_ahead = ctx-&gt;read_ahead;
+    RECORD_LAYER_set_read_ahead(&amp;s-&gt;rlayer, ctx-&gt;read_ahead);
     s-&gt;msg_callback = ctx-&gt;msg_callback;
     s-&gt;msg_callback_arg = ctx-&gt;msg_callback_arg;
     s-&gt;verify_mode = ctx-&gt;verify_mode;
@@ -597,6 +600,8 @@ void SSL_free(SSL *s)
     if (s-&gt;method != NULL)
         s-&gt;method-&gt;ssl_free(s);
 
+    RECORD_LAYER_release(&amp;s-&gt;rlayer);
+
     if (s-&gt;ctx)
         SSL_CTX_free(s-&gt;ctx);
 
@@ -821,12 +826,12 @@ void SSL_set_verify_depth(SSL *s, int depth)
 
 void SSL_set_read_ahead(SSL *s, int yes)
 {
-    s-&gt;read_ahead = yes;
+    RECORD_LAYER_set_read_ahead(&amp;s-&gt;rlayer, yes);
 }
 
 int SSL_get_read_ahead(const SSL *s)
 {
-    return (s-&gt;read_ahead);
+    return RECORD_LAYER_get_read_ahead(&amp;s-&gt;rlayer);
 }
 
 int SSL_pending(const SSL *s)
@@ -1063,10 +1068,10 @@ long SSL_ctrl(SSL *s, int cmd, long larg, void *parg)
 
     switch (cmd) {
     case SSL_CTRL_GET_READ_AHEAD:
-        return (s-&gt;read_ahead);
+        return (RECORD_LAYER_get_read_ahead(&amp;s-&gt;rlayer));
     case SSL_CTRL_SET_READ_AHEAD:
-        l = s-&gt;read_ahead;
-        s-&gt;read_ahead = larg;
+        l = RECORD_LAYER_get_read_ahead(&amp;s-&gt;rlayer);
+        RECORD_LAYER_set_read_ahead(&amp;s-&gt;rlayer, larg);
         return (l);
 
     case SSL_CTRL_SET_MSG_CALLBACK_ARG:
@@ -2824,7 +2829,7 @@ SSL *SSL_dup(SSL *s)
     ret-&gt;shutdown = s-&gt;shutdown;
     ret-&gt;state = s-&gt;state;      /* SSL_dup does not really work at any state,
                                  * though */
-    ret-&gt;rstate = s-&gt;rstate;
+    RECORD_LAYER_dup(&amp;ret-&gt;rlayer, &amp;s-&gt;rlayer);
     ret-&gt;init_num = 0;          /* would have to copy ret-&gt;init_buf,
                                  * ret-&gt;init_msg, ret-&gt;init_num,
                                  * ret-&gt;init_off */
diff --git a/ssl/ssl_locl.h b/ssl/ssl_locl.h
index 40c42a8..8b4c615 100644
--- a/ssl/ssl_locl.h
+++ b/ssl/ssl_locl.h
@@ -165,6 +165,8 @@
 # include &lt;openssl/ssl.h&gt;
 # include &lt;openssl/symhacks.h&gt;
 
+#include &quot;record/record.h&quot;
+
 # ifdef OPENSSL_BUILD_SHLIBSSL
 #  undef OPENSSL_EXTERN
 #  define OPENSSL_EXTERN OPENSSL_EXPORT
@@ -1018,20 +1020,15 @@ struct ssl_st {
     int shutdown;
     /* where we are */
     int state;
-    /* where we are when reading */
-    int rstate;
     BUF_MEM *init_buf;          /* buffer used during init */
     void *init_msg;             /* pointer to handshake message body, set by
                                  * ssl3_get_message() */
     int init_num;               /* amount read/written */
     int init_off;               /* amount read/written */
-    /* used internally to point at a raw packet */
-    unsigned char *packet;
-    unsigned int packet_length;
+
     struct ssl3_state_st *s3;   /* SSLv3 variables */
     struct dtls1_state_st *d1;  /* DTLSv1 variables */
-    int read_ahead;             /* Read as many input bytes as possible (for
-                                 * non-blocking reads) */
+
     /* callback that allows applications to peek at protocol messages */
     void (*msg_callback) (int write_p, int version, int content_type,
                           const void *buf, size_t len, SSL *ssl, void *arg);
@@ -1217,68 +1214,16 @@ struct ssl_st {
      * basis, depending on the chosen cipher.
      */
     int (*not_resumable_session_cb) (SSL *ssl, int is_forward_secure);
+    
+    RECORD_LAYER rlayer;
 };
 
-typedef struct ssl3_record_st {
-    /* type of record */
-    /*
-     * r
-     */ int type;
-    /* How many bytes available */
-    /*
-     * rw
-     */ unsigned int length;
-    /*
-     * How many bytes were available before padding was removed? This is used
-     * to implement the MAC check in constant time for CBC records.
-     */
-    /*
-     * rw
-     */ unsigned int orig_len;
-    /* read/write offset into 'buf' */
-    /*
-     * r
-     */ unsigned int off;
-    /* pointer to the record data */
-    /*
-     * rw
-     */ unsigned char *data;
-    /* where the decode bytes are */
-    /*
-     * rw
-     */ unsigned char *input;
-    /* only used with decompression - malloc()ed */
-    /*
-     * r
-     */ unsigned char *comp;
-    /* epoch number, needed by DTLS1 */
-    /*
-     * r
-     */ unsigned long epoch;
-    /* sequence number, needed by DTLS1 */
-    /*
-     * r
-     */ unsigned char seq_num[8];
-} SSL3_RECORD;
-
-typedef struct ssl3_buffer_st {
-    /* at least SSL3_RT_MAX_PACKET_SIZE bytes, see ssl3_setup_buffers() */
-    unsigned char *buf;
-    /* buffer size */
-    size_t len;
-    /* where to 'copy from' */
-    int offset;
-    /* how many bytes left */
-    int left;
-} SSL3_BUFFER;
 
 typedef struct ssl3_state_st {
     long flags;
     int delay_buf_pop_ret;
-    unsigned char read_sequence[8];
     int read_mac_secret_size;
     unsigned char read_mac_secret[EVP_MAX_MD_SIZE];
-    unsigned char write_sequence[8];
     int write_mac_secret_size;
     unsigned char write_mac_secret[EVP_MAX_MD_SIZE];
     unsigned char server_random[SSL3_RANDOM_SIZE];
@@ -1288,24 +1233,6 @@ typedef struct ssl3_state_st {
     int empty_fragment_done;
     /* The value of 'extra' when the buffers were initialized */
     int init_extra;
-    SSL3_BUFFER rbuf;           /* read IO goes into here */
-    SSL3_BUFFER wbuf;           /* write IO goes into here */
-    SSL3_RECORD rrec;           /* each decoded record goes in here */
-    SSL3_RECORD wrec;           /* goes out from here */
-    /*
-     * storage for Alert/Handshake protocol data received but not yet
-     * processed by ssl3_read_bytes:
-     */
-    unsigned char alert_fragment[2];
-    unsigned int alert_fragment_len;
-    unsigned char handshake_fragment[4];
-    unsigned int handshake_fragment_len;
-    /* partial write - check the numbers match */
-    unsigned int wnum;          /* number of bytes sent so far */
-    int wpend_tot;              /* number bytes written */
-    int wpend_type;
-    int wpend_ret;              /* number of bytes submitted */
-    const unsigned char *wpend_buf;
     /* used during startup, digest all incoming/outgoing packets */
     BIO *handshake_buffer;
     /*
@@ -1427,13 +1354,6 @@ typedef struct ssl3_state_st {
 /* Max MTU overhead we know about so far is 40 for IPv6 + 8 for UDP */
 #  define DTLS1_MAX_MTU_OVERHEAD                   48
 
-typedef struct dtls1_bitmap_st {
-    unsigned long map;          /* track 32 packets on 32-bit systems and 64
-                                 * - on 64-bit systems */
-    unsigned char max_seq_num[8]; /* max record number seen so far, 64-bit
-                                   * value in big-endian encoding */
-} DTLS1_BITMAP;
-
 struct dtls1_retransmit_state {
     EVP_CIPHER_CTX *enc_write_ctx; /* cryptographic state */
     EVP_MD_CTX *write_hash;     /* used for mac generation */
@@ -1470,11 +1390,6 @@ struct dtls1_timeout_st {
     unsigned int num_alerts;
 };
 
-typedef struct record_pqueue_st {
-    unsigned short epoch;
-    pqueue q;
-} record_pqueue;
-
 typedef struct hm_fragment_st {
     struct hm_header_st msg_header;
     unsigned char *fragment;
@@ -1486,36 +1401,17 @@ typedef struct dtls1_state_st {
     unsigned char cookie[DTLS1_COOKIE_LENGTH];
     unsigned char rcvd_cookie[DTLS1_COOKIE_LENGTH];
     unsigned int cookie_len;
-    /*
-     * The current data and handshake epoch.  This is initially
-     * undefined, and starts at zero once the initial handshake is
-     * completed
-     */
-    unsigned short r_epoch;
-    unsigned short w_epoch;
-    /* records being received in the current epoch */
-    DTLS1_BITMAP bitmap;
-    /* renegotiation starts a new set of sequence numbers */
-    DTLS1_BITMAP next_bitmap;
+
     /* handshake message numbers */
     unsigned short handshake_write_seq;
     unsigned short next_handshake_write_seq;
     unsigned short handshake_read_seq;
-    /* save last sequence number for retransmissions */
-    unsigned char last_write_sequence[8];
-    /* Received handshake records (processed and unprocessed) */
-    record_pqueue unprocessed_rcds;
-    record_pqueue processed_rcds;
+
     /* Buffered handshake messages */
     pqueue buffered_messages;
     /* Buffered (sent) handshake records */
     pqueue sent_messages;
-    /*
-     * Buffered application records. Only for records between CCS and
-     * Finished to prevent either protocol violation or unnecessary message
-     * loss.
-     */
-    record_pqueue buffered_app_data;
+
     /* Is set when listening for new connections with dtls1_listen() */
     unsigned int listen;
     unsigned int link_mtu;      /* max on-the-wire DTLS packet size */
@@ -1529,14 +1425,7 @@ typedef struct dtls1_state_st {
     struct timeval next_timeout;
     /* Timeout duration */
     unsigned short timeout_duration;
-    /*
-     * storage for Alert/Handshake protocol data received but not yet
-     * processed by ssl3_read_bytes:
-     */
-    unsigned char alert_fragment[DTLS1_AL_HEADER_LENGTH];
-    unsigned int alert_fragment_len;
-    unsigned char handshake_fragment[DTLS1_HM_HEADER_LENGTH];
-    unsigned int handshake_fragment_len;
+
     unsigned int retransmitting;
     /*
      * Set when the handshake is ready to process peer's ChangeCipherSpec message.
@@ -1550,15 +1439,6 @@ typedef struct dtls1_state_st {
 #  endif
 } DTLS1_STATE;
 
-typedef struct dtls1_record_data_st {
-    unsigned char *packet;
-    unsigned int packet_length;
-    SSL3_BUFFER rbuf;
-    SSL3_RECORD rrec;
-#  ifndef OPENSSL_NO_SCTP
-    struct bio_dgram_sctp_rcvinfo recordinfo;
-#  endif
-} DTLS1_RECORD_DATA;
 
 
 # ifndef OPENSSL_NO_EC
@@ -2042,8 +1922,10 @@ const SSL_METHOD *func_name(void)  \
 struct openssl_ssl_test_functions {
     int (*p_ssl_init_wbio_buffer) (SSL *s, int push);
     int (*p_ssl3_setup_buffers) (SSL *s);
-    int (*p_tls1_process_heartbeat) (SSL *s);
-    int (*p_dtls1_process_heartbeat) (SSL *s);
+    int (*p_tls1_process_heartbeat) (SSL *s,
+        unsigned char *p, unsigned int length);
+    int (*p_dtls1_process_heartbeat) (SSL *s,
+        unsigned char *p, unsigned int length);
 };
 
 # ifndef OPENSSL_UNIT_TEST
@@ -2140,23 +2022,14 @@ __owur const SSL_CIPHER *ssl3_get_cipher(unsigned int u);
 int ssl3_renegotiate(SSL *ssl);
 int ssl3_renegotiate_check(SSL *ssl);
 __owur int ssl3_dispatch_alert(SSL *s);
-__owur int ssl3_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek);
-__owur int ssl3_write_bytes(SSL *s, int type, const void *buf, int len);
 __owur int ssl3_final_finish_mac(SSL *s, const char *sender, int slen,
                           unsigned char *p);
 __owur int ssl3_cert_verify_mac(SSL *s, int md_nid, unsigned char *p);
 void ssl3_finish_mac(SSL *s, const unsigned char *buf, int len);
-__owur int ssl3_enc(SSL *s, int send_data);
-__owur int n_ssl3_mac(SSL *ssl, unsigned char *md, int send_data);
 void ssl3_free_digest_list(SSL *s);
 __owur unsigned long ssl3_output_cert_chain(SSL *s, CERT_PKEY *cpk);
 __owur SSL_CIPHER *ssl3_choose_cipher(SSL *ssl, STACK_OF(SSL_CIPHER) *clnt,
                                STACK_OF(SSL_CIPHER) *srvr);
-__owur int ssl3_setup_buffers(SSL *s);
-__owur int ssl3_setup_read_buffer(SSL *s);
-__owur int ssl3_setup_write_buffer(SSL *s);
-int ssl3_release_read_buffer(SSL *s);
-int ssl3_release_write_buffer(SSL *s);
 __owur int ssl3_digest_cached_records(SSL *s);
 __owur int ssl3_new(SSL *s);
 void ssl3_free(SSL *s);
@@ -2171,9 +2044,7 @@ __owur long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg);
 __owur long ssl3_ctx_ctrl(SSL_CTX *s, int cmd, long larg, void *parg);
 __owur long ssl3_callback_ctrl(SSL *s, int cmd, void (*fp) (void));
 __owur long ssl3_ctx_callback_ctrl(SSL_CTX *s, int cmd, void (*fp) (void));
-__owur int ssl3_pending(const SSL *s);
 
-void ssl3_record_sequence_update(unsigned char *seq);
 __owur int ssl3_do_change_cipher_spec(SSL *ssl);
 __owur long ssl3_default_timeout(void);
 
@@ -2193,12 +2064,6 @@ __owur int ssl_allow_compression(SSL *s);
 
 __owur long tls1_default_timeout(void);
 __owur int dtls1_do_write(SSL *s, int type);
-__owur int ssl3_read_n(SSL *s, int n, int max, int extend);
-__owur int dtls1_read_bytes(SSL *s, int type, unsigned char *buf, int len, int peek);
-__owur int ssl3_do_compress(SSL *ssl);
-__owur int ssl3_do_uncompress(SSL *ssl);
-__owur int ssl3_write_pending(SSL *s, int type, const unsigned char *buf,
-                       unsigned int len);
 void dtls1_set_message_header(SSL *s,
                               unsigned char *p, unsigned char mt,
                               unsigned long len,
@@ -2206,7 +2071,6 @@ void dtls1_set_message_header(SSL *s,
                               unsigned long frag_len);
 
 __owur int dtls1_write_app_data_bytes(SSL *s, int type, const void *buf, int len);
-__owur int dtls1_write_bytes(SSL *s, int type, const void *buf, int len);
 
 __owur int dtls1_send_change_cipher_spec(SSL *s, int a, int b);
 __owur int dtls1_send_finished(SSL *s, int a, int b, const char *sender, int slen);
@@ -2220,7 +2084,6 @@ void dtls1_clear_record_buffer(SSL *s);
 void dtls1_get_message_header(unsigned char *data,
                               struct hm_header_st *msg_hdr);
 void dtls1_get_ccs_header(unsigned char *data, struct ccs_header_st *ccs_hdr);
-void dtls1_reset_seq_numbers(SSL *s, int rw);
 __owur long dtls1_default_timeout(void);
 __owur struct timeval *dtls1_get_timeout(SSL *s, struct timeval *timeleft);
 __owur int dtls1_check_timeout_num(SSL *s);
@@ -2273,8 +2136,6 @@ __owur int ssl3_get_next_proto(SSL *s);
 
 __owur int ssl23_accept(SSL *s);
 __owur int ssl23_connect(SSL *s);
-__owur int ssl23_read_bytes(SSL *s, int n);
-__owur int ssl23_write_bytes(SSL *s);
 
 __owur int tls1_new(SSL *s);
 void tls1_free(SSL *s);
@@ -2291,9 +2152,6 @@ long dtls1_ctrl(SSL *s, int cmd, long larg, void *parg);
 __owur int dtls1_shutdown(SSL *s);
 
 __owur long dtls1_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok);
-__owur int dtls1_get_record(SSL *s);
-__owur int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
-                   unsigned int len, int create_empty_fragement);
 __owur int dtls1_dispatch_alert(SSL *s);
 
 __owur int ssl_init_wbio_buffer(SSL *s, int push);
@@ -2301,11 +2159,9 @@ void ssl_free_wbio_buffer(SSL *s);
 
 __owur int tls1_change_cipher_state(SSL *s, int which);
 __owur int tls1_setup_key_block(SSL *s);
-__owur int tls1_enc(SSL *s, int snd);
 __owur int tls1_final_finish_mac(SSL *s,
                           const char *str, int slen, unsigned char *p);
 __owur int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *p);
-__owur int tls1_mac(SSL *ssl, unsigned char *md, int snd);
 __owur int tls1_generate_master_secret(SSL *s, unsigned char *out,
                                 unsigned char *p, int len);
 __owur int tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,
@@ -2354,8 +2210,8 @@ __owur int ssl_prepare_serverhello_tlsext(SSL *s);
 #   ifndef OPENSSL_NO_HEARTBEATS
 __owur int tls1_heartbeat(SSL *s);
 __owur int dtls1_heartbeat(SSL *s);
-__owur int tls1_process_heartbeat(SSL *s);
-__owur int dtls1_process_heartbeat(SSL *s);
+__owur int tls1_process_heartbeat(SSL *s, unsigned char *p, unsigned int length);
+__owur int dtls1_process_heartbeat(SSL *s, unsigned char *p, unsigned int length);
 #   endif
 
 __owur int tls1_process_ticket(SSL *s, unsigned char *session_id, int len,
@@ -2414,14 +2270,6 @@ __owur int ssl_parse_serverhello_use_srtp_ext(SSL *s, unsigned char *d, int len,
 __owur int ssl_handshake_hash(SSL *s, unsigned char *out, int outlen);
 
 /* s3_cbc.c */
-void ssl3_cbc_copy_mac(unsigned char *out,
-                       const SSL3_RECORD *rec, unsigned md_size);
-__owur int ssl3_cbc_remove_padding(const SSL *s,
-                            SSL3_RECORD *rec,
-                            unsigned block_size, unsigned mac_size);
-__owur int tls1_cbc_remove_padding(const SSL *s,
-                            SSL3_RECORD *rec,
-                            unsigned block_size, unsigned mac_size);
 __owur char ssl3_cbc_record_digest_supported(const EVP_MD_CTX *ctx);
 void ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,
                             unsigned char *md_out,
diff --git a/ssl/ssl_stat.c b/ssl/ssl_stat.c
index 4e39a9b..258c4eb 100644
--- a/ssl/ssl_stat.c
+++ b/ssl/ssl_stat.c
@@ -342,26 +342,6 @@ const char *SSL_state_string_long(const SSL *s)
     return (str);
 }
 
-const char *SSL_rstate_string_long(const SSL *s)
-{
-    const char *str;
-
-    switch (s-&gt;rstate) {
-    case SSL_ST_READ_HEADER:
-        str = &quot;read header&quot;;
-        break;
-    case SSL_ST_READ_BODY:
-        str = &quot;read body&quot;;
-        break;
-    case SSL_ST_READ_DONE:
-        str = &quot;read done&quot;;
-        break;
-    default:
-        str = &quot;unknown&quot;;
-        break;
-    }
-    return (str);
-}
 
 const char *SSL_state_string(const SSL *s)
 {
@@ -817,24 +797,3 @@ const char *SSL_alert_desc_string_long(int value)
     }
     return (str);
 }
-
-const char *SSL_rstate_string(const SSL *s)
-{
-    const char *str;
-
-    switch (s-&gt;rstate) {
-    case SSL_ST_READ_HEADER:
-        str = &quot;RH&quot;;
-        break;
-    case SSL_ST_READ_BODY:
-        str = &quot;RB&quot;;
-        break;
-    case SSL_ST_READ_DONE:
-        str = &quot;RD&quot;;
-        break;
-    default:
-        str = &quot;unknown&quot;;
-        break;
-    }
-    return (str);
-}
diff --git a/ssl/t1_enc.c b/ssl/t1_enc.c
index e4a689e..19b79e9 100644
--- a/ssl/t1_enc.c
+++ b/ssl/t1_enc.c
@@ -396,10 +396,7 @@ int tls1_change_cipher_state(SSL *s, int which)
                        SSL_R_COMPRESSION_LIBRARY_ERROR);
                 goto err2;
             }
-            if (s-&gt;s3-&gt;rrec.comp == NULL)
-                s-&gt;s3-&gt;rrec.comp = (unsigned char *)
-                    OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
-            if (s-&gt;s3-&gt;rrec.comp == NULL)
+            if (!RECORD_LAYER_setup_comp_buffer(&amp;s-&gt;rlayer))
                 goto err;
         }
 #endif
@@ -407,7 +404,7 @@ int tls1_change_cipher_state(SSL *s, int which)
          * this is done by dtls1_reset_seq_numbers for DTLS
          */
         if (!SSL_IS_DTLS(s))
-            memset(&amp;(s-&gt;s3-&gt;read_sequence[0]), 0, 8);
+            RECORD_LAYER_reset_read_sequence(&amp;s-&gt;rlayer);
         mac_secret = &amp;(s-&gt;s3-&gt;read_mac_secret[0]);
         mac_secret_size = &amp;(s-&gt;s3-&gt;read_mac_secret_size);
     } else {
@@ -445,7 +442,7 @@ int tls1_change_cipher_state(SSL *s, int which)
          * this is done by dtls1_reset_seq_numbers for DTLS
          */
         if (!SSL_IS_DTLS(s))
-            memset(&amp;(s-&gt;s3-&gt;write_sequence[0]), 0, 8);
+            RECORD_LAYER_reset_write_sequence(&amp;s-&gt;rlayer);
         mac_secret = &amp;(s-&gt;s3-&gt;write_mac_secret[0]);
         mac_secret_size = &amp;(s-&gt;s3-&gt;write_mac_secret_size);
     }
@@ -727,182 +724,6 @@ int tls1_setup_key_block(SSL *s)
     return (ret);
 }
 
-/*-
- * tls1_enc encrypts/decrypts the record in |s-&gt;wrec| / |s-&gt;rrec|, respectively.
- *
- * Returns:
- *   0: (in non-constant time) if the record is publically invalid (i.e. too
- *       short etc).
- *   1: if the record's padding is valid / the encryption was successful.
- *   -1: if the record's padding/AEAD-authenticator is invalid or, if sending,
- *       an internal error occurred.
- */
-int tls1_enc(SSL *s, int send)
-{
-    SSL3_RECORD *rec;
-    EVP_CIPHER_CTX *ds;
-    unsigned long l;
-    int bs, i, j, k, pad = 0, ret, mac_size = 0;
-    const EVP_CIPHER *enc;
-
-    if (send) {
-        if (EVP_MD_CTX_md(s-&gt;write_hash)) {
-            int n = EVP_MD_CTX_size(s-&gt;write_hash);
-            OPENSSL_assert(n &gt;= 0);
-        }
-        ds = s-&gt;enc_write_ctx;
-        rec = &amp;(s-&gt;s3-&gt;wrec);
-        if (s-&gt;enc_write_ctx == NULL)
-            enc = NULL;
-        else {
-            int ivlen;
-            enc = EVP_CIPHER_CTX_cipher(s-&gt;enc_write_ctx);
-            /* For TLSv1.1 and later explicit IV */
-            if (SSL_USE_EXPLICIT_IV(s)
-                &amp;&amp; EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)
-                ivlen = EVP_CIPHER_iv_length(enc);
-            else
-                ivlen = 0;
-            if (ivlen &gt; 1) {
-                if (rec-&gt;data != rec-&gt;input)
-                    /*
-                     * we can't write into the input stream: Can this ever
-                     * happen?? (steve)
-                     */
-                    fprintf(stderr,
-                            &quot;%s:%d: rec-&gt;data != rec-&gt;input\n&quot;,
-                            __FILE__, __LINE__);
-                else if (RAND_bytes(rec-&gt;input, ivlen) &lt;= 0)
-                    return -1;
-            }
-        }
-    } else {
-        if (EVP_MD_CTX_md(s-&gt;read_hash)) {
-            int n = EVP_MD_CTX_size(s-&gt;read_hash);
-            OPENSSL_assert(n &gt;= 0);
-        }
-        ds = s-&gt;enc_read_ctx;
-        rec = &amp;(s-&gt;s3-&gt;rrec);
-        if (s-&gt;enc_read_ctx == NULL)
-            enc = NULL;
-        else
-            enc = EVP_CIPHER_CTX_cipher(s-&gt;enc_read_ctx);
-    }
-
-#ifdef KSSL_DEBUG
-    fprintf(stderr, &quot;tls1_enc(%d)\n&quot;, send);
-#endif                          /* KSSL_DEBUG */
-
-    if ((s-&gt;session == NULL) || (ds == NULL) || (enc == NULL)) {
-        memmove(rec-&gt;data, rec-&gt;input, rec-&gt;length);
-        rec-&gt;input = rec-&gt;data;
-        ret = 1;
-    } else {
-        l = rec-&gt;length;
-        bs = EVP_CIPHER_block_size(ds-&gt;cipher);
-
-        if (EVP_CIPHER_flags(ds-&gt;cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER) {
-            unsigned char buf[13], *seq;
-
-            seq = send ? s-&gt;s3-&gt;write_sequence : s-&gt;s3-&gt;read_sequence;
-
-            if (SSL_IS_DTLS(s)) {
-                unsigned char dtlsseq[9], *p = dtlsseq;
-
-                s2n(send ? s-&gt;d1-&gt;w_epoch : s-&gt;d1-&gt;r_epoch, p);
-                memcpy(p, &amp;seq[2], 6);
-                memcpy(buf, dtlsseq, 8);
-            } else {
-                memcpy(buf, seq, 8);
-                for (i = 7; i &gt;= 0; i--) { /* increment */
-                    ++seq[i];
-                    if (seq[i] != 0)
-                        break;
-                }
-            }
-
-            buf[8] = rec-&gt;type;
-            buf[9] = (unsigned char)(s-&gt;version &gt;&gt; 8);
-            buf[10] = (unsigned char)(s-&gt;version);
-            buf[11] = rec-&gt;length &gt;&gt; 8;
-            buf[12] = rec-&gt;length &amp; 0xff;
-            pad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD, 13, buf);
-            if (send) {
-                l += pad;
-                rec-&gt;length += pad;
-            }
-        } else if ((bs != 1) &amp;&amp; send) {
-            i = bs - ((int)l % bs);
-
-            /* Add weird padding of upto 256 bytes */
-
-            /* we need to add 'i' padding bytes of value j */
-            j = i - 1;
-            if (s-&gt;options &amp; SSL_OP_TLS_BLOCK_PADDING_BUG) {
-                if (s-&gt;s3-&gt;flags &amp; TLS1_FLAGS_TLS_PADDING_BUG)
-                    j++;
-            }
-            for (k = (int)l; k &lt; (int)(l + i); k++)
-                rec-&gt;input[k] = j;
-            l += i;
-            rec-&gt;length += i;
-        }
-#ifdef KSSL_DEBUG
-        {
-            unsigned long ui;
-            fprintf(stderr,
-                    &quot;EVP_Cipher(ds=%p,rec-&gt;data=%p,rec-&gt;input=%p,l=%ld) ==&gt;\n&quot;,
-                    ds, rec-&gt;data, rec-&gt;input, l);
-            fprintf(stderr,
-                    &quot;\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%lu %lu], %d iv_len\n&quot;,
-                    ds-&gt;buf_len, ds-&gt;cipher-&gt;key_len, DES_KEY_SZ,
-                    DES_SCHEDULE_SZ, ds-&gt;cipher-&gt;iv_len);
-            fprintf(stderr, &quot;\t\tIV: &quot;);
-            for (i = 0; i &lt; ds-&gt;cipher-&gt;iv_len; i++)
-                fprintf(stderr, &quot;%02X&quot;, ds-&gt;iv[i]);
-            fprintf(stderr, &quot;\n&quot;);
-            fprintf(stderr, &quot;\trec-&gt;input=&quot;);
-            for (ui = 0; ui &lt; l; ui++)
-                fprintf(stderr, &quot; %02x&quot;, rec-&gt;input[ui]);
-            fprintf(stderr, &quot;\n&quot;);
-        }
-#endif                          /* KSSL_DEBUG */
-
-        if (!send) {
-            if (l == 0 || l % bs != 0)
-                return 0;
-        }
-
-        i = EVP_Cipher(ds, rec-&gt;data, rec-&gt;input, l);
-        if ((EVP_CIPHER_flags(ds-&gt;cipher) &amp; EVP_CIPH_FLAG_CUSTOM_CIPHER)
-            ? (i &lt; 0)
-            : (i == 0))
-            return -1;          /* AEAD can fail to verify MAC */
-        if (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE &amp;&amp; !send) {
-            rec-&gt;data += EVP_GCM_TLS_EXPLICIT_IV_LEN;
-            rec-&gt;input += EVP_GCM_TLS_EXPLICIT_IV_LEN;
-            rec-&gt;length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
-        }
-#ifdef KSSL_DEBUG
-        {
-            unsigned long i;
-            fprintf(stderr, &quot;\trec-&gt;data=&quot;);
-            for (i = 0; i &lt; l; i++)
-                fprintf(stderr, &quot; %02x&quot;, rec-&gt;data[i]);
-            fprintf(stderr, &quot;\n&quot;);
-        }
-#endif                          /* KSSL_DEBUG */
-
-        ret = 1;
-        if (!SSL_USE_ETM(s) &amp;&amp; EVP_MD_CTX_md(s-&gt;read_hash) != NULL)
-            mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
-        if ((bs != 1) &amp;&amp; !send)
-            ret = tls1_cbc_remove_padding(s, rec, bs, mac_size);
-        if (pad &amp;&amp; !send)
-            rec-&gt;length -= pad;
-    }
-    return ret;
-}
 
 int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *out)
 {
@@ -959,121 +780,6 @@ int tls1_final_finish_mac(SSL *s, const char *str, int slen,
     return sizeof buf2;
 }
 
-int tls1_mac(SSL *ssl, unsigned char *md, int send)
-{
-    SSL3_RECORD *rec;
-    unsigned char *seq;
-    EVP_MD_CTX *hash;
-    size_t md_size;
-    int i;
-    EVP_MD_CTX hmac, *mac_ctx;
-    unsigned char header[13];
-    int stream_mac = (send ? (ssl-&gt;mac_flags &amp; SSL_MAC_FLAG_WRITE_MAC_STREAM)
-                      : (ssl-&gt;mac_flags &amp; SSL_MAC_FLAG_READ_MAC_STREAM));
-    int t;
-
-    if (send) {
-        rec = &amp;(ssl-&gt;s3-&gt;wrec);
-        seq = &amp;(ssl-&gt;s3-&gt;write_sequence[0]);
-        hash = ssl-&gt;write_hash;
-    } else {
-        rec = &amp;(ssl-&gt;s3-&gt;rrec);
-        seq = &amp;(ssl-&gt;s3-&gt;read_sequence[0]);
-        hash = ssl-&gt;read_hash;
-    }
-
-    t = EVP_MD_CTX_size(hash);
-    OPENSSL_assert(t &gt;= 0);
-    md_size = t;
-
-    /* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */
-    if (stream_mac) {
-        mac_ctx = hash;
-    } else {
-        if (!EVP_MD_CTX_copy(&amp;hmac, hash))
-            return -1;
-        mac_ctx = &hmac;
-    }
-
-    if (SSL_IS_DTLS(ssl)) {
-        unsigned char dtlsseq[8], *p = dtlsseq;
-
-        s2n(send ? ssl-&gt;d1-&gt;w_epoch : ssl-&gt;d1-&gt;r_epoch, p);
-        memcpy(p, &amp;seq[2], 6);
-
-        memcpy(header, dtlsseq, 8);
-    } else
-        memcpy(header, seq, 8);
-
-    header[8] = rec-&gt;type;
-    header[9] = (unsigned char)(ssl-&gt;version &gt;&gt; 8);
-    header[10] = (unsigned char)(ssl-&gt;version);
-    header[11] = (rec-&gt;length) &gt;&gt; 8;
-    header[12] = (rec-&gt;length) &amp; 0xff;
-
-    if (!send &amp;&amp; !SSL_USE_ETM(ssl) &amp;&amp;
-        EVP_CIPHER_CTX_mode(ssl-&gt;enc_read_ctx) == EVP_CIPH_CBC_MODE &amp;&amp;
-        ssl3_cbc_record_digest_supported(mac_ctx)) {
-        /*
-         * This is a CBC-encrypted record. We must avoid leaking any
-         * timing-side channel information about how many blocks of data we
-         * are hashing because that gives an attacker a timing-oracle.
-         */
-        /* Final param == not SSLv3 */
-        ssl3_cbc_digest_record(mac_ctx,
-                               md, &amp;md_size,
-                               header, rec-&gt;input,
-                               rec-&gt;length + md_size, rec-&gt;orig_len,
-                               ssl-&gt;s3-&gt;read_mac_secret,
-                               ssl-&gt;s3-&gt;read_mac_secret_size, 0);
-    } else {
-        EVP_DigestSignUpdate(mac_ctx, header, sizeof(header));
-        EVP_DigestSignUpdate(mac_ctx, rec-&gt;input, rec-&gt;length);
-        t = EVP_DigestSignFinal(mac_ctx, md, &amp;md_size);
-        OPENSSL_assert(t &gt; 0);
-        if (!send &amp;&amp; !SSL_USE_ETM(ssl) &amp;&amp; FIPS_mode())
-            tls_fips_digest_extra(ssl-&gt;enc_read_ctx,
-                                  mac_ctx, rec-&gt;input,
-                                  rec-&gt;length, rec-&gt;orig_len);
-    }
-
-    if (!stream_mac)
-        EVP_MD_CTX_cleanup(&amp;hmac);
-#ifdef TLS_DEBUG
-    fprintf(stderr, &quot;seq=&quot;);
-    {
-        int z;
-        for (z = 0; z &lt; 8; z++)
-            fprintf(stderr, &quot;%02X &quot;, seq[z]);
-        fprintf(stderr, &quot;\n&quot;);
-    }
-    fprintf(stderr, &quot;rec=&quot;);
-    {
-        unsigned int z;
-        for (z = 0; z &lt; rec-&gt;length; z++)
-            fprintf(stderr, &quot;%02X &quot;, rec-&gt;data[z]);
-        fprintf(stderr, &quot;\n&quot;);
-    }
-#endif
-
-    if (!SSL_IS_DTLS(ssl)) {
-        for (i = 7; i &gt;= 0; i--) {
-            ++seq[i];
-            if (seq[i] != 0)
-                break;
-        }
-    }
-#ifdef TLS_DEBUG
-    {
-        unsigned int z;
-        for (z = 0; z &lt; md_size; z++)
-            fprintf(stderr, &quot;%02X &quot;, md[z]);
-        fprintf(stderr, &quot;\n&quot;);
-    }
-#endif
-    return (md_size);
-}
-
 int tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
                                 int len)
 {
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index 40d6490..aef0ef6 100644
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -3592,24 +3592,24 @@ int SSL_get_shared_sigalgs(SSL *s, int idx,
 }
 
 # ifndef OPENSSL_NO_HEARTBEATS
-int tls1_process_heartbeat(SSL *s)
+int tls1_process_heartbeat(SSL *s, unsigned char *p, unsigned int length)
 {
-    unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl;
+    unsigned char *pl;
     unsigned short hbtype;
     unsigned int payload;
     unsigned int padding = 16;  /* Use minimum padding */
 
     if (s-&gt;msg_callback)
         s-&gt;msg_callback(0, s-&gt;version, TLS1_RT_HEARTBEAT,
-                        &amp;s-&gt;s3-&gt;rrec.data[0], s-&gt;s3-&gt;rrec.length,
+                        p, length,
                         s, s-&gt;msg_callback_arg);
 
     /* Read type and payload length first */
-    if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length)
+    if (1 + 2 + 16 &gt; length)
         return 0;               /* silently discard */
     hbtype = *p++;
     n2s(p, payload);
-    if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length)
+    if (1 + 2 + payload + 16 &gt; length)
         return 0;               /* silently discard per RFC 6520 sec. 4 */
     pl = p;
 
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000806.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="000808.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#807">[ date ]</a>
              <a href="thread.html#807">[ thread ]</a>
              <a href="subject.html#807">[ subject ]</a>
              <a href="author.html#807">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
