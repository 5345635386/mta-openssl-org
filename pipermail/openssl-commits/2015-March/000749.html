<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2015-March/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1427116564.024409.27013.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000747.html">
   <LINK REL="Next"  HREF="000750.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Dr. Stephen Henson</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1427116564.024409.27013.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">steve at openssl.org
       </A><BR>
    <I>Mon Mar 23 13:16:04 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="000747.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="000750.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#749">[ date ]</a>
              <a href="thread.html#749">[ thread ]</a>
              <a href="subject.html#749">[ subject ]</a>
              <a href="author.html#749">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  564df0ddead0fbac0bf2eeec6164a81bc3fa8882 (commit)
       via  f422a51486a3ab415153eccdc3c3746c53da01f4 (commit)
      from  2ecd32a1f8f0643ae7b38f59bbaf9f0d6ef326fe (commit)


- Log -----------------------------------------------------------------
commit 564df0ddead0fbac0bf2eeec6164a81bc3fa8882
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Sat Mar 14 18:06:59 2015 +0000

    Remove {i2d,d2i}_ASN1_BOOLEAN
    
    Remove {i2d,d2i}_ASN1_BOOLEAN.
    
    Rewrite single occurrence of d2i_ASN1_BOOLEAN in asn1_parse2
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit f422a51486a3ab415153eccdc3c3746c53da01f4
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Sat Mar 14 04:16:42 2015 +0000

    Remove old ASN.1 code.
    
    Remove old M_ASN1_ macros and replace any occurences with the corresponding
    function.
    
    Remove d2i_ASN1_bytes, d2i_ASN1_SET, i2d_ASN1_SET: no longer used internally.
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 crypto/asn1/Makefile     |  28 +----
 crypto/asn1/a_bitstr.c   |   6 +-
 crypto/asn1/a_bool.c     | 111 -----------------
 crypto/asn1/a_bytes.c    | 306 -----------------------------------------------
 crypto/asn1/a_enum.c     |   4 +-
 crypto/asn1/a_gentm.c    |   2 +-
 crypto/asn1/a_int.c      |  14 +--
 crypto/asn1/a_octet.c    |   6 +-
 crypto/asn1/a_set.c      | 239 ------------------------------------
 crypto/asn1/a_utctm.c    |   4 +-
 crypto/asn1/asn1.h       | 183 ----------------------------
 crypto/asn1/asn1_lib.c   |   9 +-
 crypto/asn1/asn1_par.c   |  16 +--
 crypto/asn1/asn_pack.c   | 100 ----------------
 crypto/asn1/evp_asn1.c   |  30 ++---
 crypto/asn1/p5_pbev2.c   |   4 +-
 crypto/asn1/t_req.c      |   2 +-
 crypto/asn1/x_pkey.c     |   4 +-
 crypto/ec/ec_asn1.c      |  18 +--
 crypto/ocsp/v3_ocsp.c    |   4 +-
 crypto/pkcs12/p12_add.c  |   4 +-
 crypto/pkcs12/p12_decr.c |   2 +-
 crypto/pkcs12/p12_init.c |   2 +-
 crypto/pkcs12/p12_mutl.c |   4 +-
 crypto/pkcs12/p12_p8e.c  |   2 +-
 crypto/pkcs7/pk7_doit.c  |  12 +-
 crypto/pkcs7/pk7_lib.c   |  14 +--
 crypto/rsa/rsa_saos.c    |   2 +-
 crypto/ts/ts_lib.c       |   8 +-
 crypto/ts/ts_rsp_sign.c  |   2 +-
 crypto/ts/ts_rsp_utils.c |   2 +-
 crypto/x509/x509_cmp.c   |   2 +-
 crypto/x509/x509_r2x.c   |   2 +-
 crypto/x509/x509_set.c   |  16 +--
 crypto/x509/x509_v3.c    |   2 +-
 crypto/x509/x509cset.c   |  18 +--
 crypto/x509v3/v3_akey.c  |   6 +-
 crypto/x509v3/v3_alt.c   |   6 +-
 crypto/x509v3/v3_bitst.c |   6 +-
 crypto/x509v3/v3_conf.c  |  10 +-
 crypto/x509v3/v3_cpols.c |   4 +-
 crypto/x509v3/v3_ia5.c   |   4 +-
 crypto/x509v3/v3_prn.c   |   2 +-
 crypto/x509v3/v3_skey.c  |  10 +-
 crypto/x509v3/v3_sxnet.c |  18 +--
 45 files changed, 145 insertions(+), 1105 deletions(-)
 delete mode 100644 crypto/asn1/a_bool.c
 delete mode 100644 crypto/asn1/a_bytes.c
 delete mode 100644 crypto/asn1/a_set.c

diff --git a/crypto/asn1/Makefile b/crypto/asn1/Makefile
index 3009bbf..cb143b3 100644
--- a/crypto/asn1/Makefile
+++ b/crypto/asn1/Makefile
@@ -18,7 +18,7 @@ APPS=
 
 LIB=$(TOP)/libcrypto.a
 LIBSRC=	a_object.c a_bitstr.c a_utctm.c a_gentm.c a_time.c a_int.c a_octet.c \
-	a_print.c a_type.c a_set.c a_dup.c a_d2i_fp.c a_i2d_fp.c \
+	a_print.c a_type.c a_dup.c a_d2i_fp.c a_i2d_fp.c \
 	a_enum.c a_utf8.c a_sign.c a_digest.c a_verify.c a_mbstr.c a_strex.c \
 	x_algor.c x_val.c x_pubkey.c x_sig.c x_req.c x_bignum.c \
 	x_long.c x_name.c x_x509.c x_x509a.c x_crl.c x_info.c x_spki.c nsseq.c \
@@ -27,12 +27,12 @@ LIBSRC=	a_object.c a_bitstr.c a_utctm.c a_gentm.c a_time.c a_int.c a_octet.c \
 	tasn_new.c tasn_fre.c tasn_enc.c tasn_dec.c tasn_utl.c tasn_typ.c \
 	tasn_prn.c tasn_scn.c ameth_lib.c \
 	f_int.c f_string.c n_pkey.c \
-	f_enum.c x_pkey.c a_bool.c x_exten.c bio_asn1.c bio_ndef.c asn_mime.c \
-	asn1_gen.c asn1_par.c asn1_lib.c asn1_err.c a_bytes.c a_strnid.c \
+	f_enum.c x_pkey.c x_exten.c bio_asn1.c bio_ndef.c asn_mime.c \
+	asn1_gen.c asn1_par.c asn1_lib.c asn1_err.c a_strnid.c \
 	evp_asn1.c asn_pack.c p5_pbe.c p5_pbev2.c p8_pkey.c asn_moid.c \
 	asn_mstbl.c
 LIBOBJ= a_object.o a_bitstr.o a_utctm.o a_gentm.o a_time.o a_int.o a_octet.o \
-	a_print.o a_type.o a_set.o a_dup.o a_d2i_fp.o a_i2d_fp.o \
+	a_print.o a_type.o a_dup.o a_d2i_fp.o a_i2d_fp.o \
 	a_enum.o a_utf8.o a_sign.o a_digest.o a_verify.o a_mbstr.o a_strex.o \
 	x_algor.o x_val.o x_pubkey.o x_sig.o x_req.o x_bignum.o \
 	x_long.o x_name.o x_x509.o x_x509a.o x_crl.o x_info.o x_spki.o nsseq.o \
@@ -41,8 +41,8 @@ LIBOBJ= a_object.o a_bitstr.o a_utctm.o a_gentm.o a_time.o a_int.o a_octet.o \
 	tasn_new.o tasn_fre.o tasn_enc.o tasn_dec.o tasn_utl.o tasn_typ.o \
 	tasn_prn.o tasn_scn.o ameth_lib.o \
 	f_int.o f_string.o n_pkey.o \
-	f_enum.o x_pkey.o a_bool.o x_exten.o bio_asn1.o bio_ndef.o asn_mime.o \
-	asn1_gen.o asn1_par.o asn1_lib.o asn1_err.o a_bytes.o a_strnid.o \
+	f_enum.o x_pkey.o x_exten.o bio_asn1.o bio_ndef.o asn_mime.o \
+	asn1_gen.o asn1_par.o asn1_lib.o asn1_err.o a_strnid.o \
 	evp_asn1.o asn_pack.o p5_pbe.o p5_pbev2.o p8_pkey.o asn_moid.o \
 	asn_mstbl.o
 
@@ -125,14 +125,6 @@ a_bool.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
 a_bool.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
 a_bool.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
 a_bool.o: ../../include/openssl/symhacks.h ../cryptlib.h a_bool.c
-a_bytes.o: ../../e_os.h ../../include/openssl/asn1.h
-a_bytes.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
-a_bytes.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
-a_bytes.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
-a_bytes.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
-a_bytes.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
-a_bytes.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-a_bytes.o: ../cryptlib.h a_bytes.c
 a_d2i_fp.o: ../../e_os.h ../../include/openssl/asn1.h
 a_d2i_fp.o: ../../include/openssl/asn1_mac.h ../../include/openssl/bio.h
 a_d2i_fp.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
@@ -226,14 +218,6 @@ a_print.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
 a_print.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
 a_print.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
 a_print.o: ../cryptlib.h a_print.c
-a_set.o: ../../e_os.h ../../include/openssl/asn1.h
-a_set.o: ../../include/openssl/asn1_mac.h ../../include/openssl/bio.h
-a_set.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
-a_set.o: ../../include/openssl/e_os2.h ../../include/openssl/err.h
-a_set.o: ../../include/openssl/lhash.h ../../include/openssl/opensslconf.h
-a_set.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-a_set.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
-a_set.o: ../../include/openssl/symhacks.h ../cryptlib.h a_set.c
 a_sign.o: ../../e_os.h ../../include/openssl/asn1.h ../../include/openssl/bio.h
 a_sign.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
 a_sign.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
diff --git a/crypto/asn1/a_bitstr.c b/crypto/asn1/a_bitstr.c
index 1b2f608..5a5cc23 100644
--- a/crypto/asn1/a_bitstr.c
+++ b/crypto/asn1/a_bitstr.c
@@ -62,7 +62,7 @@
 
 int ASN1_BIT_STRING_set(ASN1_BIT_STRING *x, unsigned char *d, int len)
 {
-    return M_ASN1_BIT_STRING_set(x, d, len);
+    return ASN1_STRING_set(x, d, len);
 }
 
 int i2c_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned char **pp)
@@ -136,7 +136,7 @@ ASN1_BIT_STRING *c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a,
     }
 
     if ((a == NULL) || ((*a) == NULL)) {
-        if ((ret = M_ASN1_BIT_STRING_new()) == NULL)
+        if ((ret = ASN1_BIT_STRING_new()) == NULL)
             return (NULL);
     } else
         ret = (*a);
@@ -178,7 +178,7 @@ ASN1_BIT_STRING *c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a,
  err:
     ASN1err(ASN1_F_C2I_ASN1_BIT_STRING, i);
     if ((ret != NULL) &amp;&amp; ((a == NULL) || (*a != ret)))
-        M_ASN1_BIT_STRING_free(ret);
+        ASN1_BIT_STRING_free(ret);
     return (NULL);
 }
 
diff --git a/crypto/asn1/a_bool.c b/crypto/asn1/a_bool.c
deleted file mode 100644
index 1b85bc9..0000000
--- a/crypto/asn1/a_bool.c
+++ /dev/null
@@ -1,111 +0,0 @@
-/* crypto/asn1/a_bool.c */
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include &lt;stdio.h&gt;
-#include &quot;cryptlib.h&quot;
-#include &lt;openssl/asn1t.h&gt;
-
-int i2d_ASN1_BOOLEAN(int a, unsigned char **pp)
-{
-    int r;
-    unsigned char *p;
-
-    r = ASN1_object_size(0, 1, V_ASN1_BOOLEAN);
-    if (pp == NULL)
-        return (r);
-    p = *pp;
-
-    ASN1_put_object(&amp;p, 0, 1, V_ASN1_BOOLEAN, V_ASN1_UNIVERSAL);
-    *(p++) = (unsigned char)a;
-    *pp = p;
-    return (r);
-}
-
-int d2i_ASN1_BOOLEAN(int *a, const unsigned char **pp, long length)
-{
-    int ret = -1;
-    const unsigned char *p;
-    long len;
-    int inf, tag, xclass;
-    int i = 0;
-
-    p = *pp;
-    inf = ASN1_get_object(&amp;p, &amp;len, &amp;tag, &amp;xclass, length);
-    if (inf &amp; 0x80) {
-        i = ASN1_R_BAD_OBJECT_HEADER;
-        goto err;
-    }
-
-    if (tag != V_ASN1_BOOLEAN) {
-        i = ASN1_R_EXPECTING_A_BOOLEAN;
-        goto err;
-    }
-
-    if (len != 1) {
-        i = ASN1_R_BOOLEAN_IS_WRONG_LENGTH;
-        goto err;
-    }
-    ret = (int)*(p++);
-    if (a != NULL)
-        (*a) = ret;
-    *pp = p;
-    return (ret);
- err:
-    ASN1err(ASN1_F_D2I_ASN1_BOOLEAN, i);
-    return (ret);
-}
diff --git a/crypto/asn1/a_bytes.c b/crypto/asn1/a_bytes.c
deleted file mode 100644
index 12715a7..0000000
--- a/crypto/asn1/a_bytes.c
+++ /dev/null
@@ -1,306 +0,0 @@
-/* crypto/asn1/a_bytes.c */
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include &lt;stdio.h&gt;
-#include &quot;cryptlib.h&quot;
-#include &lt;openssl/asn1.h&gt;
-
-static int asn1_collate_primitive(ASN1_STRING *a, ASN1_const_CTX *c);
-/*
- * type is a 'bitmap' of acceptable string types.
- */
-ASN1_STRING *d2i_ASN1_type_bytes(ASN1_STRING **a, const unsigned char **pp,
-                                 long length, int type)
-{
-    ASN1_STRING *ret = NULL;
-    const unsigned char *p;
-    unsigned char *s;
-    long len;
-    int inf, tag, xclass;
-    int i = 0;
-
-    p = *pp;
-    inf = ASN1_get_object(&amp;p, &amp;len, &amp;tag, &amp;xclass, length);
-    if (inf &amp; 0x80)
-        goto err;
-
-    if (tag &gt;= 32) {
-        i = ASN1_R_TAG_VALUE_TOO_HIGH;
-        goto err;
-    }
-    if (!(ASN1_tag2bit(tag) &amp; type)) {
-        i = ASN1_R_WRONG_TYPE;
-        goto err;
-    }
-
-    /* If a bit-string, exit early */
-    if (tag == V_ASN1_BIT_STRING)
-        return (d2i_ASN1_BIT_STRING(a, pp, length));
-
-    if ((a == NULL) || ((*a) == NULL)) {
-        if ((ret = ASN1_STRING_new()) == NULL)
-            return (NULL);
-    } else
-        ret = (*a);
-
-    if (len != 0) {
-        s = (unsigned char *)OPENSSL_malloc((int)len + 1);
-        if (s == NULL) {
-            i = ERR_R_MALLOC_FAILURE;
-            goto err;
-        }
-        memcpy(s, p, (int)len);
-        s[len] = '\0';
-        p += len;
-    } else
-        s = NULL;
-
-    if (ret-&gt;data != NULL)
-        OPENSSL_free(ret-&gt;data);
-    ret-&gt;length = (int)len;
-    ret-&gt;data = s;
-    ret-&gt;type = tag;
-    if (a != NULL)
-        (*a) = ret;
-    *pp = p;
-    return (ret);
- err:
-    ASN1err(ASN1_F_D2I_ASN1_TYPE_BYTES, i);
-    if ((ret != NULL) &amp;&amp; ((a == NULL) || (*a != ret)))
-        ASN1_STRING_free(ret);
-    return (NULL);
-}
-
-int i2d_ASN1_bytes(ASN1_STRING *a, unsigned char **pp, int tag, int xclass)
-{
-    int ret, r, constructed;
-    unsigned char *p;
-
-    if (a == NULL)
-        return (0);
-
-    if (tag == V_ASN1_BIT_STRING)
-        return (i2d_ASN1_BIT_STRING(a, pp));
-
-    ret = a-&gt;length;
-    r = ASN1_object_size(0, ret, tag);
-    if (pp == NULL)
-        return (r);
-    p = *pp;
-
-    if ((tag == V_ASN1_SEQUENCE) || (tag == V_ASN1_SET))
-        constructed = 1;
-    else
-        constructed = 0;
-    ASN1_put_object(&amp;p, constructed, ret, tag, xclass);
-    memcpy(p, a-&gt;data, a-&gt;length);
-    p += a-&gt;length;
-    *pp = p;
-    return (r);
-}
-
-ASN1_STRING *d2i_ASN1_bytes(ASN1_STRING **a, const unsigned char **pp,
-                            long length, int Ptag, int Pclass)
-{
-    ASN1_STRING *ret = NULL;
-    const unsigned char *p;
-    unsigned char *s;
-    long len;
-    int inf, tag, xclass;
-    int i = 0;
-
-    if ((a == NULL) || ((*a) == NULL)) {
-        if ((ret = ASN1_STRING_new()) == NULL)
-            return (NULL);
-    } else
-        ret = (*a);
-
-    p = *pp;
-    inf = ASN1_get_object(&amp;p, &amp;len, &amp;tag, &amp;xclass, length);
-    if (inf &amp; 0x80) {
-        i = ASN1_R_BAD_OBJECT_HEADER;
-        goto err;
-    }
-
-    if (tag != Ptag) {
-        i = ASN1_R_WRONG_TAG;
-        goto err;
-    }
-
-    if (inf &amp; V_ASN1_CONSTRUCTED) {
-        ASN1_const_CTX c;
-
-        c.pp = pp;
-        c.p = p;
-        c.inf = inf;
-        c.slen = len;
-        c.tag = Ptag;
-        c.xclass = Pclass;
-        c.max = (length == 0) ? 0 : (p + length);
-        if (!asn1_collate_primitive(ret, &amp;c))
-            goto err;
-        else {
-            p = c.p;
-        }
-    } else {
-        if (len != 0) {
-            if ((ret-&gt;length &lt; len) || (ret-&gt;data == NULL)) {
-                if (ret-&gt;data != NULL)
-                    OPENSSL_free(ret-&gt;data);
-                s = (unsigned char *)OPENSSL_malloc((int)len + 1);
-                if (s == NULL) {
-                    i = ERR_R_MALLOC_FAILURE;
-                    goto err;
-                }
-            } else
-                s = ret-&gt;data;
-            memcpy(s, p, (int)len);
-            s[len] = '\0';
-            p += len;
-        } else {
-            s = NULL;
-            if (ret-&gt;data != NULL)
-                OPENSSL_free(ret-&gt;data);
-        }
-
-        ret-&gt;length = (int)len;
-        ret-&gt;data = s;
-        ret-&gt;type = Ptag;
-    }
-
-    if (a != NULL)
-        (*a) = ret;
-    *pp = p;
-    return (ret);
- err:
-    if ((ret != NULL) &amp;&amp; ((a == NULL) || (*a != ret)))
-        ASN1_STRING_free(ret);
-    ASN1err(ASN1_F_D2I_ASN1_BYTES, i);
-    return (NULL);
-}
-
-/*
- * We are about to parse 0..n d2i_ASN1_bytes objects, we are to collapse them
- * into the one structure that is then returned
- */
-/*
- * There have been a few bug fixes for this function from Paul Keogh
- * &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.keogh at sse.ie</A>&gt;, many thanks to him
- */
-static int asn1_collate_primitive(ASN1_STRING *a, ASN1_const_CTX *c)
-{
-    ASN1_STRING *os = NULL;
-    BUF_MEM b;
-    int num;
-
-    b.length = 0;
-    b.max = 0;
-    b.data = NULL;
-
-    if (a == NULL) {
-        c-&gt;error = ERR_R_PASSED_NULL_PARAMETER;
-        goto err;
-    }
-
-    num = 0;
-    for (;;) {
-        if (c-&gt;inf &amp; 1) {
-            c-&gt;eos = ASN1_const_check_infinite_end(&amp;c-&gt;p,
-                                                   (long)(c-&gt;max - c-&gt;p));
-            if (c-&gt;eos)
-                break;
-        } else {
-            if (c-&gt;slen &lt;= 0)
-                break;
-        }
-
-        c-&gt;q = c-&gt;p;
-        if (d2i_ASN1_bytes(&amp;os, &amp;c-&gt;p, c-&gt;max - c-&gt;p, c-&gt;tag, c-&gt;xclass)
-            == NULL) {
-            c-&gt;error = ERR_R_ASN1_LIB;
-            goto err;
-        }
-
-        if (!BUF_MEM_grow_clean(&amp;b, num + os-&gt;length)) {
-            c-&gt;error = ERR_R_BUF_LIB;
-            goto err;
-        }
-        memcpy(&amp;(b.data[num]), os-&gt;data, os-&gt;length);
-        if (!(c-&gt;inf &amp; 1))
-            c-&gt;slen -= (c-&gt;p - c-&gt;q);
-        num += os-&gt;length;
-    }
-
-    if (!asn1_const_Finish(c))
-        goto err;
-
-    a-&gt;length = num;
-    if (a-&gt;data != NULL)
-        OPENSSL_free(a-&gt;data);
-    a-&gt;data = (unsigned char *)b.data;
-    if (os != NULL)
-        ASN1_STRING_free(os);
-    return (1);
- err:
-    ASN1err(ASN1_F_ASN1_COLLATE_PRIMITIVE, c-&gt;error);
-    if (os != NULL)
-        ASN1_STRING_free(os);
-    if (b.data != NULL)
-        OPENSSL_free(b.data);
-    return (0);
-}
diff --git a/crypto/asn1/a_enum.c b/crypto/asn1/a_enum.c
index c3498ac..00312b0 100644
--- a/crypto/asn1/a_enum.c
+++ b/crypto/asn1/a_enum.c
@@ -139,7 +139,7 @@ ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai)
     int len, j;
 
     if (ai == NULL)
-        ret = M_ASN1_ENUMERATED_new();
+        ret = ASN1_ENUMERATED_new();
     else
         ret = ai;
     if (ret == NULL) {
@@ -165,7 +165,7 @@ ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai)
     return (ret);
  err:
     if (ret != ai)
-        M_ASN1_ENUMERATED_free(ret);
+        ASN1_ENUMERATED_free(ret);
     return (NULL);
 }
 
diff --git a/crypto/asn1/a_gentm.c b/crypto/asn1/a_gentm.c
index 97011f8..0e9149a 100644
--- a/crypto/asn1/a_gentm.c
+++ b/crypto/asn1/a_gentm.c
@@ -223,7 +223,7 @@ ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s,
     size_t len = 20;
 
     if (s == NULL)
-        s = M_ASN1_GENERALIZEDTIME_new();
+        s = ASN1_GENERALIZEDTIME_new();
     if (s == NULL)
         return (NULL);
 
diff --git a/crypto/asn1/a_int.c b/crypto/asn1/a_int.c
index 7f11859..a33e3fd 100644
--- a/crypto/asn1/a_int.c
+++ b/crypto/asn1/a_int.c
@@ -63,7 +63,7 @@
 
 ASN1_INTEGER *ASN1_INTEGER_dup(const ASN1_INTEGER *x)
 {
-    return M_ASN1_INTEGER_dup(x);
+    return ASN1_STRING_dup(x);
 }
 
 int ASN1_INTEGER_cmp(const ASN1_INTEGER *x, const ASN1_INTEGER *y)
@@ -190,7 +190,7 @@ ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,
     int i;
 
     if ((a == NULL) || ((*a) == NULL)) {
-        if ((ret = M_ASN1_INTEGER_new()) == NULL)
+        if ((ret = ASN1_INTEGER_new()) == NULL)
             return (NULL);
         ret-&gt;type = V_ASN1_INTEGER;
     } else
@@ -266,7 +266,7 @@ ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,
  err:
     ASN1err(ASN1_F_C2I_ASN1_INTEGER, i);
     if ((ret != NULL) &amp;&amp; ((a == NULL) || (*a != ret)))
-        M_ASN1_INTEGER_free(ret);
+        ASN1_INTEGER_free(ret);
     return (NULL);
 }
 
@@ -287,7 +287,7 @@ ASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned char **pp,
     int i;
 
     if ((a == NULL) || ((*a) == NULL)) {
-        if ((ret = M_ASN1_INTEGER_new()) == NULL)
+        if ((ret = ASN1_INTEGER_new()) == NULL)
             return (NULL);
         ret-&gt;type = V_ASN1_INTEGER;
     } else
@@ -335,7 +335,7 @@ ASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned char **pp,
  err:
     ASN1err(ASN1_F_D2I_ASN1_UINTEGER, i);
     if ((ret != NULL) &amp;&amp; ((a == NULL) || (*a != ret)))
-        M_ASN1_INTEGER_free(ret);
+        ASN1_INTEGER_free(ret);
     return (NULL);
 }
 
@@ -410,7 +410,7 @@ ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai)
     int len, j;
 
     if (ai == NULL)
-        ret = M_ASN1_INTEGER_new();
+        ret = ASN1_INTEGER_new();
     else
         ret = ai;
     if (ret == NULL) {
@@ -440,7 +440,7 @@ ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai)
     return (ret);
  err:
     if (ret != ai)
-        M_ASN1_INTEGER_free(ret);
+        ASN1_INTEGER_free(ret);
     return (NULL);
 }
 
diff --git a/crypto/asn1/a_octet.c b/crypto/asn1/a_octet.c
index 1a6e9ca..f6fd622 100644
--- a/crypto/asn1/a_octet.c
+++ b/crypto/asn1/a_octet.c
@@ -62,17 +62,17 @@
 
 ASN1_OCTET_STRING *ASN1_OCTET_STRING_dup(const ASN1_OCTET_STRING *x)
 {
-    return M_ASN1_OCTET_STRING_dup(x);
+    return ASN1_STRING_dup(x);
 }
 
 int ASN1_OCTET_STRING_cmp(const ASN1_OCTET_STRING *a,
                           const ASN1_OCTET_STRING *b)
 {
-    return M_ASN1_OCTET_STRING_cmp(a, b);
+    return ASN1_STRING_cmp(a, b);
 }
 
 int ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *x, const unsigned char *d,
                           int len)
 {
-    return M_ASN1_OCTET_STRING_set(x, d, len);
+    return ASN1_STRING_set(x, d, len);
 }
diff --git a/crypto/asn1/a_set.c b/crypto/asn1/a_set.c
deleted file mode 100644
index 453100b..0000000
--- a/crypto/asn1/a_set.c
+++ /dev/null
@@ -1,239 +0,0 @@
-/* crypto/asn1/a_set.c */
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include &lt;stdio.h&gt;
-#include &quot;cryptlib.h&quot;
-#include &lt;openssl/asn1_mac.h&gt;
-
-#ifndef NO_ASN1_OLD
-
-typedef struct {
-    unsigned char *pbData;
-    int cbData;
-} MYBLOB;
-
-/*
- * SetBlobCmp This function compares two elements of SET_OF block
- */
-static int SetBlobCmp(const void *elem1, const void *elem2)
-{
-    const MYBLOB *b1 = (const MYBLOB *)elem1;
-    const MYBLOB *b2 = (const MYBLOB *)elem2;
-    int r;
-
-    r = memcmp(b1-&gt;pbData, b2-&gt;pbData,
-               b1-&gt;cbData &lt; b2-&gt;cbData ? b1-&gt;cbData : b2-&gt;cbData);
-    if (r != 0)
-        return r;
-    return b1-&gt;cbData - b2-&gt;cbData;
-}
-
-/*
- * int is_set: if TRUE, then sort the contents (i.e. it isn't a SEQUENCE)
- */
-int i2d_ASN1_SET(STACK_OF(OPENSSL_BLOCK) *a, unsigned char **pp,
-                 i2d_of_void *i2d, int ex_tag, int ex_class, int is_set)
-{
-    int ret = 0, r;
-    int i;
-    unsigned char *p;
-    unsigned char *pStart, *pTempMem;
-    MYBLOB *rgSetBlob;
-    int totSize;
-
-    if (a == NULL)
-        return (0);
-    for (i = sk_OPENSSL_BLOCK_num(a) - 1; i &gt;= 0; i--)
-        ret += i2d(sk_OPENSSL_BLOCK_value(a, i), NULL);
-    r = ASN1_object_size(1, ret, ex_tag);
-    if (pp == NULL)
-        return (r);
-
-    p = *pp;
-    ASN1_put_object(&amp;p, 1, ret, ex_tag, ex_class);
-
-/* Modified by <A HREF="../../../mailman/listinfo/openssl-commits.html">gp at nsj.co.jp</A> */
-    /* And then again by Ben */
-    /* And again by Steve */
-
-    if (!is_set || (sk_OPENSSL_BLOCK_num(a) &lt; 2)) {
-        for (i = 0; i &lt; sk_OPENSSL_BLOCK_num(a); i++)
-            i2d(sk_OPENSSL_BLOCK_value(a, i), &amp;p);
-
-        *pp = p;
-        return (r);
-    }
-
-    pStart = p;                 /* Catch the beg of Setblobs */
-    /* In this array we will store the SET blobs */
-    rgSetBlob = OPENSSL_malloc(sk_OPENSSL_BLOCK_num(a) * sizeof(MYBLOB));
-    if (rgSetBlob == NULL) {
-        ASN1err(ASN1_F_I2D_ASN1_SET, ERR_R_MALLOC_FAILURE);
-        return (0);
-    }
-
-    for (i = 0; i &lt; sk_OPENSSL_BLOCK_num(a); i++) {
-        rgSetBlob[i].pbData = p; /* catch each set encode blob */
-        i2d(sk_OPENSSL_BLOCK_value(a, i), &amp;p);
-        rgSetBlob[i].cbData = p - rgSetBlob[i].pbData; /* Length of this
-                                                        * SetBlob */
-    }
-    *pp = p;
-    totSize = p - pStart;       /* This is the total size of all set blobs */
-
-    /*
-     * Now we have to sort the blobs. I am using a simple algo. *Sort ptrs
-     * *Copy to temp-mem *Copy from temp-mem to user-mem
-     */
-    qsort(rgSetBlob, sk_OPENSSL_BLOCK_num(a), sizeof(MYBLOB), SetBlobCmp);
-    if (!(pTempMem = OPENSSL_malloc(totSize))) {
-        OPENSSL_free(rgSetBlob);
-        ASN1err(ASN1_F_I2D_ASN1_SET, ERR_R_MALLOC_FAILURE);
-        return (0);
-    }
-
-/* Copy to temp mem */
-    p = pTempMem;
-    for (i = 0; i &lt; sk_OPENSSL_BLOCK_num(a); ++i) {
-        memcpy(p, rgSetBlob[i].pbData, rgSetBlob[i].cbData);
-        p += rgSetBlob[i].cbData;
-    }
-
-/* Copy back to user mem*/
-    memcpy(pStart, pTempMem, totSize);
-    OPENSSL_free(pTempMem);
-    OPENSSL_free(rgSetBlob);
-
-    return (r);
-}
-
-STACK_OF(OPENSSL_BLOCK) *d2i_ASN1_SET(STACK_OF(OPENSSL_BLOCK) **a,
-                                      const unsigned char **pp,
-                                      long length, d2i_of_void *d2i,
-                                      void (*free_func) (OPENSSL_BLOCK),
-                                      int ex_tag, int ex_class)
-{
-    ASN1_const_CTX c;
-    STACK_OF(OPENSSL_BLOCK) *ret = NULL;
-
-    if ((a == NULL) || ((*a) == NULL)) {
-        if ((ret = sk_OPENSSL_BLOCK_new_null()) == NULL) {
-            ASN1err(ASN1_F_D2I_ASN1_SET, ERR_R_MALLOC_FAILURE);
-            goto err;
-        }
-    } else
-        ret = (*a);
-
-    c.p = *pp;
-    c.max = (length == 0) ? 0 : (c.p + length);
-
-    c.inf = ASN1_get_object(&amp;c.p, &amp;c.slen, &amp;c.tag, &amp;c.xclass, c.max - c.p);
-    if (c.inf &amp; 0x80)
-        goto err;
-    if (ex_class != c.xclass) {
-        ASN1err(ASN1_F_D2I_ASN1_SET, ASN1_R_BAD_CLASS);
-        goto err;
-    }
-    if (ex_tag != c.tag) {
-        ASN1err(ASN1_F_D2I_ASN1_SET, ASN1_R_BAD_TAG);
-        goto err;
-    }
-    if ((c.slen + c.p) &gt; c.max) {
-        ASN1err(ASN1_F_D2I_ASN1_SET, ASN1_R_LENGTH_ERROR);
-        goto err;
-    }
-    /*
-     * check for infinite constructed - it can be as long as the amount of
-     * data passed to us
-     */
-    if (c.inf == (V_ASN1_CONSTRUCTED + 1))
-        c.slen = length + *pp - c.p;
-    c.max = c.p + c.slen;
-
-    while (c.p &lt; c.max) {
-        char *s;
-
-        if (M_ASN1_D2I_end_sequence())
-            break;
-        /*
-         * XXX: This was called with 4 arguments, incorrectly, it seems if
-         * ((s=func(NULL,&amp;c.p,c.slen,c.max-c.p)) == NULL)
-         */
-        if ((s = d2i(NULL, &amp;c.p, c.slen)) == NULL) {
-            ASN1err(ASN1_F_D2I_ASN1_SET, ASN1_R_ERROR_PARSING_SET_ELEMENT);
-            asn1_add_error(*pp, (int)(c.p - *pp));
-            goto err;
-        }
-        if (!sk_OPENSSL_BLOCK_push(ret, s))
-            goto err;
-    }
-    if (a != NULL)
-        (*a) = ret;
-    *pp = c.p;
-    return (ret);
- err:
-    if ((ret != NULL) &amp;&amp; ((a == NULL) || (*a != ret))) {
-        if (free_func != NULL)
-            sk_OPENSSL_BLOCK_pop_free(ret, free_func);
-        else
-            sk_OPENSSL_BLOCK_free(ret);
-    }
-    return (NULL);
-}
-
-#endif
diff --git a/crypto/asn1/a_utctm.c b/crypto/asn1/a_utctm.c
index e56cbbc..2dac3b5 100644
--- a/crypto/asn1/a_utctm.c
+++ b/crypto/asn1/a_utctm.c
@@ -194,7 +194,7 @@ ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,
 
     if (s == NULL) {
         free_s = 1;
-        s = M_ASN1_UTCTIME_new();
+        s = ASN1_UTCTIME_new();
     }
     if (s == NULL)
         goto err;
@@ -234,7 +234,7 @@ ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,
     return (s);
  err:
     if (free_s &amp;&amp; s)
-        M_ASN1_UTCTIME_free(s);
+        ASN1_UTCTIME_free(s);
     return NULL;
 }
 
diff --git a/crypto/asn1/asn1.h b/crypto/asn1/asn1.h
index 66e1fac..392143c 100644
--- a/crypto/asn1/asn1.h
+++ b/crypto/asn1/asn1.h
@@ -572,50 +572,6 @@ typedef struct BIT_STRING_BITNAME_st {
     const char *sname;
 } BIT_STRING_BITNAME;
 
-# define M_ASN1_STRING_length(x) ((x)-&gt;length)
-# define M_ASN1_STRING_length_set(x, n)  ((x)-&gt;length = (n))
-# define M_ASN1_STRING_type(x)   ((x)-&gt;type)
-# define M_ASN1_STRING_data(x)   ((x)-&gt;data)
-
-/* Macros for string operations */
-# define M_ASN1_BIT_STRING_new() (ASN1_BIT_STRING *)\
-                ASN1_STRING_type_new(V_ASN1_BIT_STRING)
-# define M_ASN1_BIT_STRING_free(a)       ASN1_STRING_free((ASN1_STRING *)a)
-# define M_ASN1_BIT_STRING_dup(a) (ASN1_BIT_STRING *)\
-                ASN1_STRING_dup((const ASN1_STRING *)a)
-# define M_ASN1_BIT_STRING_cmp(a,b) ASN1_STRING_cmp(\
-                (const ASN1_STRING *)a,(const ASN1_STRING *)b)
-# define M_ASN1_BIT_STRING_set(a,b,c) ASN1_STRING_set((ASN1_STRING *)a,b,c)
-
-# define M_ASN1_INTEGER_new()    (ASN1_INTEGER *)\
-                ASN1_STRING_type_new(V_ASN1_INTEGER)
-# define M_ASN1_INTEGER_free(a)          ASN1_STRING_free((ASN1_STRING *)a)
-# define M_ASN1_INTEGER_dup(a) (ASN1_INTEGER *)\
-                ASN1_STRING_dup((const ASN1_STRING *)a)
-# define M_ASN1_INTEGER_cmp(a,b) ASN1_STRING_cmp(\
-                (const ASN1_STRING *)a,(const ASN1_STRING *)b)
-
-# define M_ASN1_ENUMERATED_new() (ASN1_ENUMERATED *)\
-                ASN1_STRING_type_new(V_ASN1_ENUMERATED)
-# define M_ASN1_ENUMERATED_free(a)       ASN1_STRING_free((ASN1_STRING *)a)
-# define M_ASN1_ENUMERATED_dup(a) (ASN1_ENUMERATED *)\
-                ASN1_STRING_dup((const ASN1_STRING *)a)
-# define M_ASN1_ENUMERATED_cmp(a,b)      ASN1_STRING_cmp(\
-                (const ASN1_STRING *)a,(const ASN1_STRING *)b)
-
-# define M_ASN1_OCTET_STRING_new()       (ASN1_OCTET_STRING *)\
-                ASN1_STRING_type_new(V_ASN1_OCTET_STRING)
-# define M_ASN1_OCTET_STRING_free(a)     ASN1_STRING_free((ASN1_STRING *)a)
-# define M_ASN1_OCTET_STRING_dup(a) (ASN1_OCTET_STRING *)\
-                ASN1_STRING_dup((const ASN1_STRING *)a)
-# define M_ASN1_OCTET_STRING_cmp(a,b) ASN1_STRING_cmp(\
-                (const ASN1_STRING *)a,(const ASN1_STRING *)b)
-# define M_ASN1_OCTET_STRING_set(a,b,c)  ASN1_STRING_set((ASN1_STRING *)a,b,c)
-# define M_ASN1_OCTET_STRING_print(a,b)  ASN1_STRING_print(a,(ASN1_STRING *)b)
-# define M_i2d_ASN1_OCTET_STRING(a,pp) \
-                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_OCTET_STRING,\
-                V_ASN1_UNIVERSAL)
-
 # define B_ASN1_TIME \
                         B_ASN1_UTCTIME | \
                         B_ASN1_GENERALIZEDTIME
@@ -645,134 +601,6 @@ typedef struct BIT_STRING_BITNAME_st {
                         B_ASN1_BMPSTRING|\
                         B_ASN1_UTF8STRING
 
-# define M_ASN1_PRINTABLE_new()  ASN1_STRING_type_new(V_ASN1_T61STRING)
-# define M_ASN1_PRINTABLE_free(a)        ASN1_STRING_free((ASN1_STRING *)a)
-# define M_i2d_ASN1_PRINTABLE(a,pp) i2d_ASN1_bytes((ASN1_STRING *)a,\
-                pp,a-&gt;type,V_ASN1_UNIVERSAL)
-# define M_d2i_ASN1_PRINTABLE(a,pp,l) \
-                d2i_ASN1_type_bytes((ASN1_STRING **)a,pp,l, \
-                        B_ASN1_PRINTABLE)
-
-# define M_DIRECTORYSTRING_new() ASN1_STRING_type_new(V_ASN1_PRINTABLESTRING)
-# define M_DIRECTORYSTRING_free(a)       ASN1_STRING_free((ASN1_STRING *)a)
-# define M_i2d_DIRECTORYSTRING(a,pp) i2d_ASN1_bytes((ASN1_STRING *)a,\
-                                                pp,a-&gt;type,V_ASN1_UNIVERSAL)
-# define M_d2i_DIRECTORYSTRING(a,pp,l) \
-                d2i_ASN1_type_bytes((ASN1_STRING **)a,pp,l, \
-                        B_ASN1_DIRECTORYSTRING)
-
-# define M_DISPLAYTEXT_new() ASN1_STRING_type_new(V_ASN1_VISIBLESTRING)
-# define M_DISPLAYTEXT_free(a) ASN1_STRING_free((ASN1_STRING *)a)
-# define M_i2d_DISPLAYTEXT(a,pp) i2d_ASN1_bytes((ASN1_STRING *)a,\
-                                                pp,a-&gt;type,V_ASN1_UNIVERSAL)
-# define M_d2i_DISPLAYTEXT(a,pp,l) \
-                d2i_ASN1_type_bytes((ASN1_STRING **)a,pp,l, \
-                        B_ASN1_DISPLAYTEXT)
-
-# define M_ASN1_PRINTABLESTRING_new() (ASN1_PRINTABLESTRING *)\
-                ASN1_STRING_type_new(V_ASN1_PRINTABLESTRING)
-# define M_ASN1_PRINTABLESTRING_free(a)  ASN1_STRING_free((ASN1_STRING *)a)
-# define M_i2d_ASN1_PRINTABLESTRING(a,pp) \
-                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_PRINTABLESTRING,\
-                V_ASN1_UNIVERSAL)
-# define M_d2i_ASN1_PRINTABLESTRING(a,pp,l) \
-                (ASN1_PRINTABLESTRING *)d2i_ASN1_type_bytes\
-                ((ASN1_STRING **)a,pp,l,B_ASN1_PRINTABLESTRING)
-
-# define M_ASN1_T61STRING_new()  (ASN1_T61STRING *)\
-                ASN1_STRING_type_new(V_ASN1_T61STRING)
-# define M_ASN1_T61STRING_free(a)        ASN1_STRING_free((ASN1_STRING *)a)
-# define M_i2d_ASN1_T61STRING(a,pp) \
-                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_T61STRING,\
-                V_ASN1_UNIVERSAL)
-# define M_d2i_ASN1_T61STRING(a,pp,l) \
-                (ASN1_T61STRING *)d2i_ASN1_type_bytes\
-                ((ASN1_STRING **)a,pp,l,B_ASN1_T61STRING)
-
-# define M_ASN1_IA5STRING_new()  (ASN1_IA5STRING *)\
-                ASN1_STRING_type_new(V_ASN1_IA5STRING)
-# define M_ASN1_IA5STRING_free(a)        ASN1_STRING_free((ASN1_STRING *)a)
-# define M_ASN1_IA5STRING_dup(a) \
-                (ASN1_IA5STRING *)ASN1_STRING_dup((const ASN1_STRING *)a)
-# define M_i2d_ASN1_IA5STRING(a,pp) \
-                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_IA5STRING,\
-                        V_ASN1_UNIVERSAL)
-# define M_d2i_ASN1_IA5STRING(a,pp,l) \
-                (ASN1_IA5STRING *)d2i_ASN1_type_bytes((ASN1_STRING **)a,pp,l,\
-                        B_ASN1_IA5STRING)
-
-# define M_ASN1_UTCTIME_new()    (ASN1_UTCTIME *)\
-                ASN1_STRING_type_new(V_ASN1_UTCTIME)
-# define M_ASN1_UTCTIME_free(a)  ASN1_STRING_free((ASN1_STRING *)a)
-# define M_ASN1_UTCTIME_dup(a) (ASN1_UTCTIME *)\
-                ASN1_STRING_dup((const ASN1_STRING *)a)
-
-# define M_ASN1_GENERALIZEDTIME_new()    (ASN1_GENERALIZEDTIME *)\
-                ASN1_STRING_type_new(V_ASN1_GENERALIZEDTIME)
-# define M_ASN1_GENERALIZEDTIME_free(a)  ASN1_STRING_free((ASN1_STRING *)a)
-# define M_ASN1_GENERALIZEDTIME_dup(a) (ASN1_GENERALIZEDTIME *)ASN1_STRING_dup(\
-        (const ASN1_STRING *)a)
-
-# define M_ASN1_TIME_new()       (ASN1_TIME *)\
-                ASN1_STRING_type_new(V_ASN1_UTCTIME)
-# define M_ASN1_TIME_free(a)     ASN1_STRING_free((ASN1_STRING *)a)
-# define M_ASN1_TIME_dup(a) (ASN1_TIME *)\
-        ASN1_STRING_dup((const ASN1_STRING *)a)
-
-# define M_ASN1_GENERALSTRING_new()      (ASN1_GENERALSTRING *)\
-                ASN1_STRING_type_new(V_ASN1_GENERALSTRING)
-# define M_ASN1_GENERALSTRING_free(a)    ASN1_STRING_free((ASN1_STRING *)a)
-# define M_i2d_ASN1_GENERALSTRING(a,pp) \
-                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_GENERALSTRING,\
-                        V_ASN1_UNIVERSAL)
-# define M_d2i_ASN1_GENERALSTRING(a,pp,l) \
-                (ASN1_GENERALSTRING *)d2i_ASN1_type_bytes\
-                ((ASN1_STRING **)a,pp,l,B_ASN1_GENERALSTRING)
-
-# define M_ASN1_UNIVERSALSTRING_new()    (ASN1_UNIVERSALSTRING *)\
-                ASN1_STRING_type_new(V_ASN1_UNIVERSALSTRING)
-# define M_ASN1_UNIVERSALSTRING_free(a)  ASN1_STRING_free((ASN1_STRING *)a)
-# define M_i2d_ASN1_UNIVERSALSTRING(a,pp) \
-                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_UNIVERSALSTRING,\
-                        V_ASN1_UNIVERSAL)
-# define M_d2i_ASN1_UNIVERSALSTRING(a,pp,l) \
-                (ASN1_UNIVERSALSTRING *)d2i_ASN1_type_bytes\
-                ((ASN1_STRING **)a,pp,l,B_ASN1_UNIVERSALSTRING)
-
-# define M_ASN1_BMPSTRING_new()  (ASN1_BMPSTRING *)\
-                ASN1_STRING_type_new(V_ASN1_BMPSTRING)
-# define M_ASN1_BMPSTRING_free(a)        ASN1_STRING_free((ASN1_STRING *)a)
-# define M_i2d_ASN1_BMPSTRING(a,pp) \
-                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_BMPSTRING,\
-                        V_ASN1_UNIVERSAL)
-# define M_d2i_ASN1_BMPSTRING(a,pp,l) \
-                (ASN1_BMPSTRING *)d2i_ASN1_type_bytes\
-                ((ASN1_STRING **)a,pp,l,B_ASN1_BMPSTRING)
-
-# define M_ASN1_VISIBLESTRING_new()      (ASN1_VISIBLESTRING *)\
-                ASN1_STRING_type_new(V_ASN1_VISIBLESTRING)
-# define M_ASN1_VISIBLESTRING_free(a)    ASN1_STRING_free((ASN1_STRING *)a)
-# define M_i2d_ASN1_VISIBLESTRING(a,pp) \
-                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_VISIBLESTRING,\
-                        V_ASN1_UNIVERSAL)
-# define M_d2i_ASN1_VISIBLESTRING(a,pp,l) \
-                (ASN1_VISIBLESTRING *)d2i_ASN1_type_bytes\
-                ((ASN1_STRING **)a,pp,l,B_ASN1_VISIBLESTRING)
-
-# define M_ASN1_UTF8STRING_new() (ASN1_UTF8STRING *)\
-                ASN1_STRING_type_new(V_ASN1_UTF8STRING)
-# define M_ASN1_UTF8STRING_free(a)       ASN1_STRING_free((ASN1_STRING *)a)
-# define M_i2d_ASN1_UTF8STRING(a,pp) \
-                i2d_ASN1_bytes((ASN1_STRING *)a,pp,V_ASN1_UTF8STRING,\
-                        V_ASN1_UNIVERSAL)
-# define M_d2i_ASN1_UTF8STRING(a,pp,l) \
-                (ASN1_UTF8STRING *)d2i_ASN1_type_bytes\
-                ((ASN1_STRING **)a,pp,l,B_ASN1_UTF8STRING)
-
-  /* for the is_set parameter to i2d_ASN1_SET */
-# define IS_SEQUENCE     0
-# define IS_SET          1
-
 DECLARE_ASN1_FUNCTIONS_fname(ASN1_TYPE, ASN1_ANY, ASN1_TYPE)
 
 int ASN1_TYPE_get(ASN1_TYPE *a);
@@ -826,9 +654,6 @@ int ASN1_BIT_STRING_num_asc(char *name, BIT_STRING_BITNAME *tbl);
 int ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs, char *name, int value,
                             BIT_STRING_BITNAME *tbl);
 
-int i2d_ASN1_BOOLEAN(int a, unsigned char **pp);
-int d2i_ASN1_BOOLEAN(int *a, const unsigned char **pp, long length);
-
 DECLARE_ASN1_FUNCTIONS(ASN1_INTEGER)
 int i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp);
 ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,
@@ -895,14 +720,6 @@ ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t, ASN1_GENERALIZE
                                                    **out);
 int ASN1_TIME_set_string(ASN1_TIME *s, const char *str);
 
-int i2d_ASN1_SET(STACK_OF(OPENSSL_BLOCK) *a, unsigned char **pp,
-                 i2d_of_void *i2d, int ex_tag, int ex_class, int is_set);
-STACK_OF(OPENSSL_BLOCK) *d2i_ASN1_SET(STACK_OF(OPENSSL_BLOCK) **a,
-                                      const unsigned char **pp,
-                                      long length, d2i_of_void *d2i,
-                                      void (*free_func) (OPENSSL_BLOCK),
-                                      int ex_tag, int ex_class);
-
 int i2a_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *a);
 int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size);
 int i2a_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *a);
diff --git a/crypto/asn1/asn1_lib.c b/crypto/asn1/asn1_lib.c
index 1586aaf..fe63b62 100644
--- a/crypto/asn1/asn1_lib.c
+++ b/crypto/asn1/asn1_lib.c
@@ -460,21 +460,20 @@ void asn1_add_error(const unsigned char *address, int offset)
 
 int ASN1_STRING_length(const ASN1_STRING *x)
 {
-    return M_ASN1_STRING_length(x);
+    return x-&gt;length;
 }
 
 void ASN1_STRING_length_set(ASN1_STRING *x, int len)
 {
-    M_ASN1_STRING_length_set(x, len);
-    return;
+    x-&gt;length = len;
 }
 
 int ASN1_STRING_type(ASN1_STRING *x)
 {
-    return M_ASN1_STRING_type(x);
+    return x-&gt;type;
 }
 
 unsigned char *ASN1_STRING_data(ASN1_STRING *x)
 {
-    return M_ASN1_STRING_data(x);
+    return x-&gt;data;
 }
diff --git a/crypto/asn1/asn1_par.c b/crypto/asn1/asn1_par.c
index b12edf9..20f3a88 100644
--- a/crypto/asn1/asn1_par.c
+++ b/crypto/asn1/asn1_par.c
@@ -215,15 +215,11 @@ static int asn1_parse2(BIO *bp, const unsigned char **pp, long length,
                         goto end;
                 }
             } else if (tag == V_ASN1_BOOLEAN) {
-                int ii;
-
-                opp = op;
-                ii = d2i_ASN1_BOOLEAN(NULL, &amp;opp, len + hl);
-                if (ii &lt; 0) {
+                if (len != 1) {
                     if (BIO_write(bp, &quot;Bad boolean\n&quot;, 12) &lt;= 0)
                         goto end;
                 }
-                BIO_printf(bp, &quot;:%d&quot;, ii);
+                BIO_printf(bp, &quot;:%u&quot;, p[0]);
             } else if (tag == V_ASN1_BMPSTRING) {
                 /* do the BMP thang */
             } else if (tag == V_ASN1_OCTET_STRING) {
@@ -281,7 +277,7 @@ static int asn1_parse2(BIO *bp, const unsigned char **pp, long length,
                     }
                 }
                 if (os != NULL) {
-                    M_ASN1_OCTET_STRING_free(os);
+                    ASN1_OCTET_STRING_free(os);
                     os = NULL;
                 }
             } else if (tag == V_ASN1_INTEGER) {
@@ -308,7 +304,7 @@ static int asn1_parse2(BIO *bp, const unsigned char **pp, long length,
                     if (BIO_write(bp, &quot;BAD INTEGER&quot;, 11) &lt;= 0)
                         goto end;
                 }
-                M_ASN1_INTEGER_free(bs);
+                ASN1_INTEGER_free(bs);
             } else if (tag == V_ASN1_ENUMERATED) {
                 ASN1_ENUMERATED *bs;
                 int i;
@@ -333,7 +329,7 @@ static int asn1_parse2(BIO *bp, const unsigned char **pp, long length,
                     if (BIO_write(bp, &quot;BAD ENUMERATED&quot;, 14) &lt;= 0)
                         goto end;
                 }
-                M_ASN1_ENUMERATED_free(bs);
+                ASN1_ENUMERATED_free(bs);
             } else if (len &gt; 0 &amp;&amp; dump) {
                 if (!nl) {
                     if (BIO_write(bp, &quot;\n&quot;, 1) &lt;= 0)
@@ -363,7 +359,7 @@ static int asn1_parse2(BIO *bp, const unsigned char **pp, long length,
     if (o != NULL)
         ASN1_OBJECT_free(o);
     if (os != NULL)
-        M_ASN1_OCTET_STRING_free(os);
+        ASN1_OCTET_STRING_free(os);
     *pp = p;
     return (ret);
 }
diff --git a/crypto/asn1/asn_pack.c b/crypto/asn1/asn_pack.c
index 366caf0..8d0f0b0 100644
--- a/crypto/asn1/asn_pack.c
+++ b/crypto/asn1/asn_pack.c
@@ -61,108 +61,8 @@
 #include &quot;cryptlib.h&quot;
 #include &lt;openssl/asn1.h&gt;
 
-#ifndef NO_ASN1_OLD
-
 /* ASN1 packing and unpacking functions */
 
-/* Turn an ASN1 encoded SEQUENCE OF into a STACK of structures */
-
-STACK_OF(OPENSSL_BLOCK) *ASN1_seq_unpack(const unsigned char *buf, int len,
-                                         d2i_of_void *d2i,
-                                         void (*free_func) (OPENSSL_BLOCK))
-{
-    STACK_OF(OPENSSL_BLOCK) *sk;
-    const unsigned char *pbuf;
-    pbuf = buf;
-    if (!(sk = d2i_ASN1_SET(NULL, &amp;pbuf, len, d2i, free_func,
-                            V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL)))
-        ASN1err(ASN1_F_ASN1_SEQ_UNPACK, ASN1_R_DECODE_ERROR);
-    return sk;
-}
-
-/*
- * Turn a STACK structures into an ASN1 encoded SEQUENCE OF structure in a
- * OPENSSL_malloc'ed buffer
- */
-
-unsigned char *ASN1_seq_pack(STACK_OF(OPENSSL_BLOCK) *safes, i2d_of_void *i2d,
-                             unsigned char **buf, int *len)
-{
-    int safelen;
-    unsigned char *safe, *p;
-    if (!(safelen = i2d_ASN1_SET(safes, NULL, i2d, V_ASN1_SEQUENCE,
-                                 V_ASN1_UNIVERSAL, IS_SEQUENCE))) {
-        ASN1err(ASN1_F_ASN1_SEQ_PACK, ASN1_R_ENCODE_ERROR);
-        return NULL;
-    }
-    if (!(safe = OPENSSL_malloc(safelen))) {
-        ASN1err(ASN1_F_ASN1_SEQ_PACK, ERR_R_MALLOC_FAILURE);
-        return NULL;
-    }
-    p = safe;
-    i2d_ASN1_SET(safes, &amp;p, i2d, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL,
-                 IS_SEQUENCE);
-    if (len)
-        *len = safelen;
-    if (buf)
-        *buf = safe;
-    return safe;
-}
-
-/* Extract an ASN1 object from an ASN1_STRING */
-
-void *ASN1_unpack_string(ASN1_STRING *oct, d2i_of_void *d2i)
-{
-    const unsigned char *p;
-    char *ret;
-
-    p = oct-&gt;data;
-    if (!(ret = d2i(NULL, &amp;p, oct-&gt;length)))
-        ASN1err(ASN1_F_ASN1_UNPACK_STRING, ASN1_R_DECODE_ERROR);
-    return ret;
-}
-
-/* Pack an ASN1 object into an ASN1_STRING */
-
-ASN1_STRING *ASN1_pack_string(void *obj, i2d_of_void *i2d, ASN1_STRING **oct)
-{
-    unsigned char *p;
-    ASN1_STRING *octmp;
-
-    if (!oct || !*oct) {
-        if (!(octmp = ASN1_STRING_new())) {
-            ASN1err(ASN1_F_ASN1_PACK_STRING, ERR_R_MALLOC_FAILURE);
-            return NULL;
-        }
-        if (oct)
-            *oct = octmp;
-    } else
-        octmp = *oct;
-
-    if (!(octmp-&gt;length = i2d(obj, NULL))) {
-        ASN1err(ASN1_F_ASN1_PACK_STRING, ASN1_R_ENCODE_ERROR);
-        goto err;
-    }
-    if (!(p = OPENSSL_malloc(octmp-&gt;length))) {
-        ASN1err(ASN1_F_ASN1_PACK_STRING, ERR_R_MALLOC_FAILURE);
-        goto err;
-    }
-    octmp-&gt;data = p;
-    i2d(obj, &amp;p);
-    return octmp;
- err:
-    if (!oct || !*oct) {
-        ASN1_STRING_free(octmp);
-        if (oct)
-            *oct = NULL;
-    }
-    return NULL;
-}
-
-#endif
-
-/* ASN1_ITEM versions of the above */
-
 ASN1_STRING *ASN1_item_pack(void *obj, const ASN1_ITEM *it, ASN1_STRING **oct)
 {
     ASN1_STRING *octmp;
diff --git a/crypto/asn1/evp_asn1.c b/crypto/asn1/evp_asn1.c
index 5876afa..3664576 100644
--- a/crypto/asn1/evp_asn1.c
+++ b/crypto/asn1/evp_asn1.c
@@ -65,10 +65,10 @@ int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned char *data, int len)
 {
     ASN1_STRING *os;
 
-    if ((os = M_ASN1_OCTET_STRING_new()) == NULL)
+    if ((os = ASN1_OCTET_STRING_new()) == NULL)
         return (0);
-    if (!M_ASN1_OCTET_STRING_set(os, data, len)) {
-        M_ASN1_OCTET_STRING_free(os);
+    if (!ASN1_OCTET_STRING_set(os, data, len)) {
+        ASN1_OCTET_STRING_free(os);
         return 0;
     }
     ASN1_TYPE_set(a, V_ASN1_OCTET_STRING, os);
@@ -85,8 +85,8 @@ int ASN1_TYPE_get_octetstring(ASN1_TYPE *a, unsigned char *data, int max_len)
         ASN1err(ASN1_F_ASN1_TYPE_GET_OCTETSTRING, ASN1_R_DATA_IS_WRONG);
         return (-1);
     }
-    p = M_ASN1_STRING_data(a-&gt;value.octet_string);
-    ret = M_ASN1_STRING_length(a-&gt;value.octet_string);
+    p = ASN1_STRING_data(a-&gt;value.octet_string);
+    ret = ASN1_STRING_length(a-&gt;value.octet_string);
     if (ret &lt; max_len)
         num = ret;
     else
@@ -111,7 +111,7 @@ int ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num, unsigned char *data,
     os.length = len;
     ASN1_INTEGER_set(&amp;in, num);
     n = i2d_ASN1_INTEGER(&amp;in, NULL);
-    n += M_i2d_ASN1_OCTET_STRING(&amp;os, NULL);
+    n += i2d_ASN1_OCTET_STRING(&amp;os, NULL);
 
     size = ASN1_object_size(1, n, V_ASN1_SEQUENCE);
 
@@ -123,12 +123,12 @@ int ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num, unsigned char *data,
         return (0);
     }
 
-    M_ASN1_STRING_length_set(osp, size);
-    p = M_ASN1_STRING_data(osp);
+    ASN1_STRING_length_set(osp, size);
+    p = ASN1_STRING_data(osp);
 
     ASN1_put_object(&amp;p, 1, n, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);
     i2d_ASN1_INTEGER(&amp;in, &amp;p);
-    M_i2d_ASN1_OCTET_STRING(&amp;os, &amp;p);
+    i2d_ASN1_OCTET_STRING(&amp;os, &amp;p);
 
     ASN1_TYPE_set(a, V_ASN1_SEQUENCE, osp);
     return (1);
@@ -152,8 +152,8 @@ int ASN1_TYPE_get_int_octetstring(ASN1_TYPE *a, long *num,
     if ((a-&gt;type != V_ASN1_SEQUENCE) || (a-&gt;value.sequence == NULL)) {
         goto err;
     }
-    p = M_ASN1_STRING_data(a-&gt;value.sequence);
-    length = M_ASN1_STRING_length(a-&gt;value.sequence);
+    p = ASN1_STRING_data(a-&gt;value.sequence);
+    length = ASN1_STRING_length(a-&gt;value.sequence);
 
     c.pp = &p;
     c.p = p;
@@ -175,21 +175,21 @@ int ASN1_TYPE_get_int_octetstring(ASN1_TYPE *a, long *num,
     if (num != NULL)
         *num = ASN1_INTEGER_get(ai);
 
-    ret = M_ASN1_STRING_length(os);
+    ret = ASN1_STRING_length(os);
     if (max_len &gt; ret)
         n = ret;
     else
         n = max_len;
 
     if (data != NULL)
-        memcpy(data, M_ASN1_STRING_data(os), n);
+        memcpy(data, ASN1_STRING_data(os), n);
     if (0) {
  err:
         ASN1err(ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING, ASN1_R_DATA_IS_WRONG);
     }
     if (os != NULL)
-        M_ASN1_OCTET_STRING_free(os);
+        ASN1_OCTET_STRING_free(os);
     if (ai != NULL)
-        M_ASN1_INTEGER_free(ai);
+        ASN1_INTEGER_free(ai);
     return (ret);
 }
diff --git a/crypto/asn1/p5_pbev2.c b/crypto/asn1/p5_pbev2.c
index 73ba4a3..c56d850 100644
--- a/crypto/asn1/p5_pbev2.c
+++ b/crypto/asn1/p5_pbev2.c
@@ -210,7 +210,7 @@ X509_ALGOR *PKCS5_pbkdf2_set(int iter, unsigned char *salt, int saltlen,
 
     if (!(kdf = PBKDF2PARAM_new()))
         goto merr;
-    if (!(osalt = M_ASN1_OCTET_STRING_new()))
+    if (!(osalt = ASN1_OCTET_STRING_new()))
         goto merr;
 
     kdf-&gt;salt-&gt;value.octet_string = osalt;
@@ -237,7 +237,7 @@ X509_ALGOR *PKCS5_pbkdf2_set(int iter, unsigned char *salt, int saltlen,
     /* If have a key len set it up */
 
     if (keylen &gt; 0) {
-        if (!(kdf-&gt;keylength = M_ASN1_INTEGER_new()))
+        if (!(kdf-&gt;keylength = ASN1_INTEGER_new()))
             goto merr;
         if (!ASN1_INTEGER_set(kdf-&gt;keylength, keylen))
             goto merr;
diff --git a/crypto/asn1/t_req.c b/crypto/asn1/t_req.c
index 2a88958..bd76950 100644
--- a/crypto/asn1/t_req.c
+++ b/crypto/asn1/t_req.c
@@ -216,7 +216,7 @@ int X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflags,
                     goto err;
                 if (!X509V3_EXT_print(bp, ex, cflag, 16)) {
                     BIO_printf(bp, &quot;%16s&quot;, &quot;&quot;);
-                    M_ASN1_OCTET_STRING_print(bp, ex-&gt;value);
+                    ASN1_STRING_print(bp, ex-&gt;value);
                 }
                 if (BIO_write(bp, &quot;\n&quot;, 1) &lt;= 0)
                     goto err;
diff --git a/crypto/asn1/x_pkey.c b/crypto/asn1/x_pkey.c
index 2da23e4..cf5fd80 100644
--- a/crypto/asn1/x_pkey.c
+++ b/crypto/asn1/x_pkey.c
@@ -109,7 +109,7 @@ X509_PKEY *X509_PKEY_new(void)
     M_ASN1_New_Malloc(ret, X509_PKEY);
     ret-&gt;version = 0;
     M_ASN1_New(ret-&gt;enc_algor, X509_ALGOR_new);
-    M_ASN1_New(ret-&gt;enc_pkey, M_ASN1_OCTET_STRING_new);
+    M_ASN1_New(ret-&gt;enc_pkey, ASN1_OCTET_STRING_new);
     ret-&gt;dec_pkey = NULL;
     ret-&gt;key_length = 0;
     ret-&gt;key_data = NULL;
@@ -144,7 +144,7 @@ void X509_PKEY_free(X509_PKEY *x)
     if (x-&gt;enc_algor != NULL)
         X509_ALGOR_free(x-&gt;enc_algor);
     if (x-&gt;enc_pkey != NULL)
-        M_ASN1_OCTET_STRING_free(x-&gt;enc_pkey);
+        ASN1_OCTET_STRING_free(x-&gt;enc_pkey);
     if (x-&gt;dec_pkey != NULL)
         EVP_PKEY_free(x-&gt;dec_pkey);
     if ((x-&gt;key_data != NULL) &amp;&amp; (x-&gt;key_free))
diff --git a/crypto/ec/ec_asn1.c b/crypto/ec/ec_asn1.c
index b4b0e9f..87cc334 100644
--- a/crypto/ec/ec_asn1.c
+++ b/crypto/ec/ec_asn1.c
@@ -499,8 +499,8 @@ static int ec_asn1_group2curve(const EC_GROUP *group, X9_62_CURVE *curve)
     }
 
     /* set a and b */
-    if (!M_ASN1_OCTET_STRING_set(curve-&gt;a, a_buf, len_1) ||
-        !M_ASN1_OCTET_STRING_set(curve-&gt;b, b_buf, len_2)) {
+    if (!ASN1_OCTET_STRING_set(curve-&gt;a, a_buf, len_1) ||
+        !ASN1_OCTET_STRING_set(curve-&gt;b, b_buf, len_2)) {
         ECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);
         goto err;
     }
@@ -1044,8 +1044,8 @@ EC_KEY *d2i_ECPrivateKey(EC_KEY **a, const unsigned char **in, long len)
     ret-&gt;version = priv_key-&gt;version;
 
     if (priv_key-&gt;privateKey) {
-        ret-&gt;priv_key = BN_bin2bn(M_ASN1_STRING_data(priv_key-&gt;privateKey),
-                                  M_ASN1_STRING_length(priv_key-&gt;privateKey),
+        ret-&gt;priv_key = BN_bin2bn(ASN1_STRING_data(priv_key-&gt;privateKey),
+                                  ASN1_STRING_length(priv_key-&gt;privateKey),
                                   ret-&gt;priv_key);
         if (ret-&gt;priv_key == NULL) {
             ECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_BN_LIB);
@@ -1068,8 +1068,8 @@ EC_KEY *d2i_ECPrivateKey(EC_KEY **a, const unsigned char **in, long len)
         const unsigned char *pub_oct;
         int pub_oct_len;
 
-        pub_oct = M_ASN1_STRING_data(priv_key-&gt;publicKey);
-        pub_oct_len = M_ASN1_STRING_length(priv_key-&gt;publicKey);
+        pub_oct = ASN1_STRING_data(priv_key-&gt;publicKey);
+        pub_oct_len = ASN1_STRING_length(priv_key-&gt;publicKey);
         /*
          * The first byte - point conversion form - must be present.
          */
@@ -1142,7 +1142,7 @@ int i2d_ECPrivateKey(EC_KEY *a, unsigned char **out)
         goto err;
     }
 
-    if (!M_ASN1_OCTET_STRING_set(priv_key-&gt;privateKey, buffer, buf_len)) {
+    if (!ASN1_OCTET_STRING_set(priv_key-&gt;privateKey, buffer, buf_len)) {
         ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_ASN1_LIB);
         goto err;
     }
@@ -1157,7 +1157,7 @@ int i2d_ECPrivateKey(EC_KEY *a, unsigned char **out)
     }
 
     if (!(a-&gt;enc_flag &amp; EC_PKEY_NO_PUBKEY)) {
-        priv_key-&gt;publicKey = M_ASN1_BIT_STRING_new();
+        priv_key-&gt;publicKey = ASN1_BIT_STRING_new();
         if (priv_key-&gt;publicKey == NULL) {
             ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);
             goto err;
@@ -1184,7 +1184,7 @@ int i2d_ECPrivateKey(EC_KEY *a, unsigned char **out)
 
         priv_key-&gt;publicKey-&gt;flags &amp;= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
         priv_key-&gt;publicKey-&gt;flags |= ASN1_STRING_FLAG_BITS_LEFT;
-        if (!M_ASN1_BIT_STRING_set(priv_key-&gt;publicKey, buffer, buf_len)) {
+        if (!ASN1_BIT_STRING_set(priv_key-&gt;publicKey, buffer, buf_len)) {
             ECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_ASN1_LIB);
             goto err;
         }
diff --git a/crypto/ocsp/v3_ocsp.c b/crypto/ocsp/v3_ocsp.c
index 006db17..6558116 100644
--- a/crypto/ocsp/v3_ocsp.c
+++ b/crypto/ocsp/v3_ocsp.c
@@ -248,14 +248,14 @@ static void *d2i_ocsp_nonce(void *a, const unsigned char **pp, long length)
 
  err:
     if (os &amp;&amp; (!pos || (*pos != os)))
-        M_ASN1_OCTET_STRING_free(os);
+        ASN1_OCTET_STRING_free(os);
     OCSPerr(OCSP_F_D2I_OCSP_NONCE, ERR_R_MALLOC_FAILURE);
     return NULL;
 }
 
 static void ocsp_nonce_free(void *a)
 {
-    M_ASN1_OCTET_STRING_free(a);
+    ASN1_OCTET_STRING_free(a);
 }
 
 static int i2r_ocsp_nonce(const X509V3_EXT_METHOD *method, void *nonce,
diff --git a/crypto/pkcs12/p12_add.c b/crypto/pkcs12/p12_add.c
index 982805d..51ea42a 100644
--- a/crypto/pkcs12/p12_add.c
+++ b/crypto/pkcs12/p12_add.c
@@ -142,7 +142,7 @@ PKCS7 *PKCS12_pack_p7data(STACK_OF(PKCS12_SAFEBAG) *sk)
         return NULL;
     }
     p7-&gt;type = OBJ_nid2obj(NID_pkcs7_data);
-    if (!(p7-&gt;d.data = M_ASN1_OCTET_STRING_new())) {
+    if (!(p7-&gt;d.data = ASN1_OCTET_STRING_new())) {
         PKCS12err(PKCS12_F_PKCS12_PACK_P7DATA, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
@@ -197,7 +197,7 @@ PKCS7 *PKCS12_pack_p7encdata(int pbe_nid, const char *pass, int passlen,
     }
     X509_ALGOR_free(p7-&gt;d.encrypted-&gt;enc_data-&gt;algorithm);
     p7-&gt;d.encrypted-&gt;enc_data-&gt;algorithm = pbe;
-    M_ASN1_OCTET_STRING_free(p7-&gt;d.encrypted-&gt;enc_data-&gt;enc_data);
+    ASN1_OCTET_STRING_free(p7-&gt;d.encrypted-&gt;enc_data-&gt;enc_data);
     if (!(p7-&gt;d.encrypted-&gt;enc_data-&gt;enc_data =
           PKCS12_item_i2d_encrypt(pbe, ASN1_ITEM_rptr(PKCS12_SAFEBAGS), pass,
                                   passlen, bags, 1))) {
diff --git a/crypto/pkcs12/p12_decr.c b/crypto/pkcs12/p12_decr.c
index 6780b4f..7a9d3ca 100644
--- a/crypto/pkcs12/p12_decr.c
+++ b/crypto/pkcs12/p12_decr.c
@@ -174,7 +174,7 @@ ASN1_OCTET_STRING *PKCS12_item_i2d_encrypt(X509_ALGOR *algor,
     ASN1_OCTET_STRING *oct = NULL;
     unsigned char *in = NULL;
     int inlen;
-    if (!(oct = M_ASN1_OCTET_STRING_new())) {
+    if (!(oct = ASN1_OCTET_STRING_new())) {
         PKCS12err(PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT, ERR_R_MALLOC_FAILURE);
         goto err;
     }
diff --git a/crypto/pkcs12/p12_init.c b/crypto/pkcs12/p12_init.c
index 0322df9..34710e9 100644
--- a/crypto/pkcs12/p12_init.c
+++ b/crypto/pkcs12/p12_init.c
@@ -74,7 +74,7 @@ PKCS12 *PKCS12_init(int mode)
     pkcs12-&gt;authsafes-&gt;type = OBJ_nid2obj(mode);
     switch (mode) {
     case NID_pkcs7_data:
-        if (!(pkcs12-&gt;authsafes-&gt;d.data = M_ASN1_OCTET_STRING_new())) {
+        if (!(pkcs12-&gt;authsafes-&gt;d.data = ASN1_OCTET_STRING_new())) {
             PKCS12err(PKCS12_F_PKCS12_INIT, ERR_R_MALLOC_FAILURE);
             goto err;
         }
diff --git a/crypto/pkcs12/p12_mutl.c b/crypto/pkcs12/p12_mutl.c
index 4138a4d..d5eb8ff 100644
--- a/crypto/pkcs12/p12_mutl.c
+++ b/crypto/pkcs12/p12_mutl.c
@@ -146,7 +146,7 @@ int PKCS12_set_mac(PKCS12 *p12, const char *pass, int passlen,
         PKCS12err(PKCS12_F_PKCS12_SET_MAC, PKCS12_R_MAC_GENERATION_ERROR);
         return 0;
     }
-    if (!(M_ASN1_OCTET_STRING_set(p12-&gt;mac-&gt;dinfo-&gt;digest, mac, maclen))) {
+    if (!(ASN1_OCTET_STRING_set(p12-&gt;mac-&gt;dinfo-&gt;digest, mac, maclen))) {
         PKCS12err(PKCS12_F_PKCS12_SET_MAC, PKCS12_R_MAC_STRING_SET_ERROR);
         return 0;
     }
@@ -160,7 +160,7 @@ int PKCS12_setup_mac(PKCS12 *p12, int iter, unsigned char *salt, int saltlen,
     if (!(p12-&gt;mac = PKCS12_MAC_DATA_new()))
         return PKCS12_ERROR;
     if (iter &gt; 1) {
-        if (!(p12-&gt;mac-&gt;iter = M_ASN1_INTEGER_new())) {
+        if (!(p12-&gt;mac-&gt;iter = ASN1_INTEGER_new())) {
             PKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);
             return 0;
         }
diff --git a/crypto/pkcs12/p12_p8e.c b/crypto/pkcs12/p12_p8e.c
index 861a087..0275742 100644
--- a/crypto/pkcs12/p12_p8e.c
+++ b/crypto/pkcs12/p12_p8e.c
@@ -88,7 +88,7 @@ X509_SIG *PKCS8_encrypt(int pbe_nid, const EVP_CIPHER *cipher,
     }
     X509_ALGOR_free(p8-&gt;algor);
     p8-&gt;algor = pbe;
-    M_ASN1_OCTET_STRING_free(p8-&gt;digest);
+    ASN1_OCTET_STRING_free(p8-&gt;digest);
     p8-&gt;digest =
         PKCS12_item_i2d_encrypt(pbe, ASN1_ITEM_rptr(PKCS8_PRIV_KEY_INFO),
                                 pass, passlen, p8inf, 1);
diff --git a/crypto/pkcs7/pk7_doit.c b/crypto/pkcs7/pk7_doit.c
index 25ac2df..0200b3b 100644
--- a/crypto/pkcs7/pk7_doit.c
+++ b/crypto/pkcs7/pk7_doit.c
@@ -409,7 +409,7 @@ static int pkcs7_cmp_ri(PKCS7_RECIP_INFO *ri, X509 *pcert)
                         pcert-&gt;cert_info-&gt;issuer);
     if (ret)
         return ret;
-    return M_ASN1_INTEGER_cmp(pcert-&gt;cert_info-&gt;serialNumber,
+    return ASN1_INTEGER_cmp(pcert-&gt;cert_info-&gt;serialNumber,
                               ri-&gt;issuer_and_serial-&gt;serial);
 }
 
@@ -735,7 +735,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
         si_sk = p7-&gt;d.signed_and_enveloped-&gt;signer_info;
         os = p7-&gt;d.signed_and_enveloped-&gt;enc_data-&gt;enc_data;
         if (!os) {
-            os = M_ASN1_OCTET_STRING_new();
+            os = ASN1_OCTET_STRING_new();
             if (!os) {
                 PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);
                 goto err;
@@ -747,7 +747,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
         /* XXXXXXXXXXXXXXXX */
         os = p7-&gt;d.enveloped-&gt;enc_data-&gt;enc_data;
         if (!os) {
-            os = M_ASN1_OCTET_STRING_new();
+            os = ASN1_OCTET_STRING_new();
             if (!os) {
                 PKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);
                 goto err;
@@ -760,7 +760,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
         os = PKCS7_get_octet_string(p7-&gt;d.sign-&gt;contents);
         /* If detached data then the content is excluded */
         if (PKCS7_type_is_data(p7-&gt;d.sign-&gt;contents) &amp;&amp; p7-&gt;detached) {
-            M_ASN1_OCTET_STRING_free(os);
+            ASN1_OCTET_STRING_free(os);
             os = NULL;
             p7-&gt;d.sign-&gt;contents-&gt;d.data = NULL;
         }
@@ -770,7 +770,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
         os = PKCS7_get_octet_string(p7-&gt;d.digest-&gt;contents);
         /* If detached data then the content is excluded */
         if (PKCS7_type_is_data(p7-&gt;d.digest-&gt;contents) &amp;&amp; p7-&gt;detached) {
-            M_ASN1_OCTET_STRING_free(os);
+            ASN1_OCTET_STRING_free(os);
             os = NULL;
             p7-&gt;d.digest-&gt;contents-&gt;d.data = NULL;
         }
@@ -834,7 +834,7 @@ int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
             goto err;
         if (!EVP_DigestFinal_ex(mdc, md_data, &amp;md_len))
             goto err;
-        M_ASN1_OCTET_STRING_set(p7-&gt;d.digest-&gt;digest, md_data, md_len);
+        ASN1_OCTET_STRING_set(p7-&gt;d.digest-&gt;digest, md_data, md_len);
     }
 
     if (!PKCS7_is_detached(p7)) {
diff --git a/crypto/pkcs7/pk7_lib.c b/crypto/pkcs7/pk7_lib.c
index 0c5fcaa..511ae8c 100644
--- a/crypto/pkcs7/pk7_lib.c
+++ b/crypto/pkcs7/pk7_lib.c
@@ -177,7 +177,7 @@ int PKCS7_set_type(PKCS7 *p7, int type)
         break;
     case NID_pkcs7_data:
         p7-&gt;type = obj;
-        if ((p7-&gt;d.data = M_ASN1_OCTET_STRING_new()) == NULL)
+        if ((p7-&gt;d.data = ASN1_OCTET_STRING_new()) == NULL)
             goto err;
         break;
     case NID_pkcs7_signedAndEnveloped:
@@ -368,9 +368,9 @@ int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,
      * because ASN1_INTEGER_set is used to set a 'long' we will do things the
      * ugly way.
      */
-    M_ASN1_INTEGER_free(p7i-&gt;issuer_and_serial-&gt;serial);
+    ASN1_INTEGER_free(p7i-&gt;issuer_and_serial-&gt;serial);
     if (!(p7i-&gt;issuer_and_serial-&gt;serial =
-          M_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))
+          ASN1_INTEGER_dup(X509_get_serialNumber(x509))))
         goto err;
 
     /* lets keep the pkey around for a while */
@@ -523,9 +523,9 @@ int PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509)
                        X509_get_issuer_name(x509)))
         return 0;
 
-    M_ASN1_INTEGER_free(p7i-&gt;issuer_and_serial-&gt;serial);
+    ASN1_INTEGER_free(p7i-&gt;issuer_and_serial-&gt;serial);
     if (!(p7i-&gt;issuer_and_serial-&gt;serial =
-          M_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))
+          ASN1_INTEGER_dup(X509_get_serialNumber(x509))))
         return 0;
 
     pkey = X509_get_pubkey(x509);
@@ -614,7 +614,7 @@ int PKCS7_stream(unsigned char ***boundary, PKCS7 *p7)
     case NID_pkcs7_signedAndEnveloped:
         os = p7-&gt;d.signed_and_enveloped-&gt;enc_data-&gt;enc_data;
         if (os == NULL) {
-            os = M_ASN1_OCTET_STRING_new();
+            os = ASN1_OCTET_STRING_new();
             p7-&gt;d.signed_and_enveloped-&gt;enc_data-&gt;enc_data = os;
         }
         break;
@@ -622,7 +622,7 @@ int PKCS7_stream(unsigned char ***boundary, PKCS7 *p7)
     case NID_pkcs7_enveloped:
         os = p7-&gt;d.enveloped-&gt;enc_data-&gt;enc_data;
         if (os == NULL) {
-            os = M_ASN1_OCTET_STRING_new();
+            os = ASN1_OCTET_STRING_new();
             p7-&gt;d.enveloped-&gt;enc_data-&gt;enc_data = os;
         }
         break;
diff --git a/crypto/rsa/rsa_saos.c b/crypto/rsa/rsa_saos.c
index e400236..6ebab3d 100644
--- a/crypto/rsa/rsa_saos.c
+++ b/crypto/rsa/rsa_saos.c
@@ -139,7 +139,7 @@ int RSA_verify_ASN1_OCTET_STRING(int dtype,
         ret = 1;
  err:
     if (sig != NULL)
-        M_ASN1_OCTET_STRING_free(sig);
+        ASN1_OCTET_STRING_free(sig);
     if (s != NULL) {
         OPENSSL_cleanse(s, (unsigned int)siglen);
         OPENSSL_free(s);
diff --git a/crypto/ts/ts_lib.c b/crypto/ts/ts_lib.c
index 089d5ea..6ec1f0c 100644
--- a/crypto/ts/ts_lib.c
+++ b/crypto/ts/ts_lib.c
@@ -115,7 +115,7 @@ int TS_ext_print_bio(BIO *bio, const STACK_OF(X509_EXTENSION) *extensions)
         BIO_printf(bio, &quot;: %s\n&quot;, critical ? &quot;critical&quot; : &quot;&quot;);
         if (!X509V3_EXT_print(bio, ex, 0, 4)) {
             BIO_printf(bio, &quot;%4s&quot;, &quot;&quot;);
-            M_ASN1_OCTET_STRING_print(bio, ex-&gt;value);
+            ASN1_STRING_print(bio, ex-&gt;value);
         }
         BIO_write(bio, &quot;\n&quot;, 1);
     }
@@ -132,14 +132,14 @@ int TS_X509_ALGOR_print_bio(BIO *bio, const X509_ALGOR *alg)
 
 int TS_MSG_IMPRINT_print_bio(BIO *bio, TS_MSG_IMPRINT *a)
 {
-    const ASN1_OCTET_STRING *msg;
+    ASN1_OCTET_STRING *msg;
 
     TS_X509_ALGOR_print_bio(bio, TS_MSG_IMPRINT_get_algo(a));
 
     BIO_printf(bio, &quot;Message data:\n&quot;);
     msg = TS_MSG_IMPRINT_get_msg(a);
-    BIO_dump_indent(bio, (const char *)M_ASN1_STRING_data(msg),
-                    M_ASN1_STRING_length(msg), 4);
+    BIO_dump_indent(bio, (const char *)ASN1_STRING_data(msg),
+                    ASN1_STRING_length(msg), 4);
 
     return 1;
 }
diff --git a/crypto/ts/ts_rsp_sign.c b/crypto/ts/ts_rsp_sign.c
index db6ce32..b510ceb 100644
--- a/crypto/ts/ts_rsp_sign.c
+++ b/crypto/ts/ts_rsp_sign.c
@@ -1006,7 +1006,7 @@ static ASN1_GENERALIZEDTIME
     *p++ = '\0';
 
     /* Now call OpenSSL to check and set our genTime value */
-    if (!asn1_time &amp;&amp; !(asn1_time = M_ASN1_GENERALIZEDTIME_new()))
+    if (!asn1_time &amp;&amp; !(asn1_time = ASN1_GENERALIZEDTIME_new()))
         goto err;
     if (!ASN1_GENERALIZEDTIME_set_string(asn1_time, genTime_str)) {
         ASN1_GENERALIZEDTIME_free(asn1_time);
diff --git a/crypto/ts/ts_rsp_utils.c b/crypto/ts/ts_rsp_utils.c
index f6f6332..72d9f63 100644
--- a/crypto/ts/ts_rsp_utils.c
+++ b/crypto/ts/ts_rsp_utils.c
@@ -186,7 +186,7 @@ int TS_TST_INFO_set_time(TS_TST_INFO *a, const ASN1_GENERALIZEDTIME *gtime)
 
     if (a-&gt;time == gtime)
         return 1;
-    new_time = M_ASN1_GENERALIZEDTIME_dup(gtime);
+    new_time = ASN1_STRING_dup(gtime);
     if (new_time == NULL) {
         TSerr(TS_F_TS_TST_INFO_SET_TIME, ERR_R_MALLOC_FAILURE);
         return 0;
diff --git a/crypto/x509/x509_cmp.c b/crypto/x509/x509_cmp.c
index 04cecad..eb46a67 100644
--- a/crypto/x509/x509_cmp.c
+++ b/crypto/x509/x509_cmp.c
@@ -71,7 +71,7 @@ int X509_issuer_and_serial_cmp(const X509 *a, const X509 *b)
 
     ai = a-&gt;cert_info;
     bi = b-&gt;cert_info;
-    i = M_ASN1_INTEGER_cmp(ai-&gt;serialNumber, bi-&gt;serialNumber);
+    i = ASN1_INTEGER_cmp(ai-&gt;serialNumber, bi-&gt;serialNumber);
     if (i)
         return (i);
     return (X509_NAME_cmp(ai-&gt;issuer, bi-&gt;issuer));
diff --git a/crypto/x509/x509_r2x.c b/crypto/x509/x509_r2x.c
index 0ff439c..3cd7280 100644
--- a/crypto/x509/x509_r2x.c
+++ b/crypto/x509/x509_r2x.c
@@ -80,7 +80,7 @@ X509 *X509_REQ_to_X509(X509_REQ *r, int days, EVP_PKEY *pkey)
     xi = ret-&gt;cert_info;
 
     if (sk_X509_ATTRIBUTE_num(r-&gt;req_info-&gt;attributes) != 0) {
-        if ((xi-&gt;version = M_ASN1_INTEGER_new()) == NULL)
+        if ((xi-&gt;version = ASN1_INTEGER_new()) == NULL)
             goto err;
         if (!ASN1_INTEGER_set(xi-&gt;version, 2))
             goto err;
diff --git a/crypto/x509/x509_set.c b/crypto/x509/x509_set.c
index 5b802bd..6ddbabf 100644
--- a/crypto/x509/x509_set.c
+++ b/crypto/x509/x509_set.c
@@ -68,12 +68,12 @@ int X509_set_version(X509 *x, long version)
     if (x == NULL)
         return (0);
     if (version == 0) {
-        M_ASN1_INTEGER_free(x-&gt;cert_info-&gt;version);
+        ASN1_INTEGER_free(x-&gt;cert_info-&gt;version);
         x-&gt;cert_info-&gt;version = NULL;
         return (1);
     }
     if (x-&gt;cert_info-&gt;version == NULL) {
-        if ((x-&gt;cert_info-&gt;version = M_ASN1_INTEGER_new()) == NULL)
+        if ((x-&gt;cert_info-&gt;version = ASN1_INTEGER_new()) == NULL)
             return (0);
     }
     return (ASN1_INTEGER_set(x-&gt;cert_info-&gt;version, version));
@@ -87,9 +87,9 @@ int X509_set_serialNumber(X509 *x, ASN1_INTEGER *serial)
         return (0);
     in = x-&gt;cert_info-&gt;serialNumber;
     if (in != serial) {
-        in = M_ASN1_INTEGER_dup(serial);
+        in = ASN1_INTEGER_dup(serial);
         if (in != NULL) {
-            M_ASN1_INTEGER_free(x-&gt;cert_info-&gt;serialNumber);
+            ASN1_INTEGER_free(x-&gt;cert_info-&gt;serialNumber);
             x-&gt;cert_info-&gt;serialNumber = in;
         }
     }
@@ -118,9 +118,9 @@ int X509_set_notBefore(X509 *x, const ASN1_TIME *tm)
         return (0);
     in = x-&gt;cert_info-&gt;validity-&gt;notBefore;
     if (in != tm) {
-        in = M_ASN1_TIME_dup(tm);
+        in = ASN1_STRING_dup(tm);
         if (in != NULL) {
-            M_ASN1_TIME_free(x-&gt;cert_info-&gt;validity-&gt;notBefore);
+            ASN1_TIME_free(x-&gt;cert_info-&gt;validity-&gt;notBefore);
             x-&gt;cert_info-&gt;validity-&gt;notBefore = in;
         }
     }
@@ -135,9 +135,9 @@ int X509_set_notAfter(X509 *x, const ASN1_TIME *tm)
         return (0);
     in = x-&gt;cert_info-&gt;validity-&gt;notAfter;
     if (in != tm) {
-        in = M_ASN1_TIME_dup(tm);
+        in = ASN1_STRING_dup(tm);
         if (in != NULL) {
-            M_ASN1_TIME_free(x-&gt;cert_info-&gt;validity-&gt;notAfter);
+            ASN1_TIME_free(x-&gt;cert_info-&gt;validity-&gt;notAfter);
             x-&gt;cert_info-&gt;validity-&gt;notAfter = in;
         }
     }
diff --git a/crypto/x509/x509_v3.c b/crypto/x509/x509_v3.c
index 4a03445..0a6247d 100644
--- a/crypto/x509/x509_v3.c
+++ b/crypto/x509/x509_v3.c
@@ -254,7 +254,7 @@ int X509_EXTENSION_set_data(X509_EXTENSION *ex, ASN1_OCTET_STRING *data)
 
     if (ex == NULL)
         return (0);
-    i = M_ASN1_OCTET_STRING_set(ex-&gt;value, data-&gt;data, data-&gt;length);
+    i = ASN1_OCTET_STRING_set(ex-&gt;value, data-&gt;data, data-&gt;length);
     if (!i)
         return (0);
     return (1);
diff --git a/crypto/x509/x509cset.c b/crypto/x509/x509cset.c
index 24ca35b..042c90d 100644
--- a/crypto/x509/x509cset.c
+++ b/crypto/x509/x509cset.c
@@ -69,7 +69,7 @@ int X509_CRL_set_version(X509_CRL *x, long version)
     if (x == NULL)
         return (0);
     if (x-&gt;crl-&gt;version == NULL) {
-        if ((x-&gt;crl-&gt;version = M_ASN1_INTEGER_new()) == NULL)
+        if ((x-&gt;crl-&gt;version = ASN1_INTEGER_new()) == NULL)
             return (0);
     }
     return (ASN1_INTEGER_set(x-&gt;crl-&gt;version, version));
@@ -90,9 +90,9 @@ int X509_CRL_set_lastUpdate(X509_CRL *x, const ASN1_TIME *tm)
         return (0);
     in = x-&gt;crl-&gt;lastUpdate;
     if (in != tm) {
-        in = M_ASN1_TIME_dup(tm);
+        in = ASN1_STRING_dup(tm);
         if (in != NULL) {
-            M_ASN1_TIME_free(x-&gt;crl-&gt;lastUpdate);
+            ASN1_TIME_free(x-&gt;crl-&gt;lastUpdate);
             x-&gt;crl-&gt;lastUpdate = in;
         }
     }
@@ -107,9 +107,9 @@ int X509_CRL_set_nextUpdate(X509_CRL *x, const ASN1_TIME *tm)
         return (0);
     in = x-&gt;crl-&gt;nextUpdate;
     if (in != tm) {
-        in = M_ASN1_TIME_dup(tm);
+        in = ASN1_STRING_dup(tm);
         if (in != NULL) {
-            M_ASN1_TIME_free(x-&gt;crl-&gt;nextUpdate);
+            ASN1_TIME_free(x-&gt;crl-&gt;nextUpdate);
             x-&gt;crl-&gt;nextUpdate = in;
         }
     }
@@ -140,9 +140,9 @@ int X509_REVOKED_set_revocationDate(X509_REVOKED *x, ASN1_TIME *tm)
         return (0);
     in = x-&gt;revocationDate;
     if (in != tm) {
-        in = M_ASN1_TIME_dup(tm);
+        in = ASN1_STRING_dup(tm);
         if (in != NULL) {
-            M_ASN1_TIME_free(x-&gt;revocationDate);
+            ASN1_TIME_free(x-&gt;revocationDate);
             x-&gt;revocationDate = in;
         }
     }
@@ -157,9 +157,9 @@ int X509_REVOKED_set_serialNumber(X509_REVOKED *x, ASN1_INTEGER *serial)
         return (0);
     in = x-&gt;serialNumber;
     if (in != serial) {
-        in = M_ASN1_INTEGER_dup(serial);
+        in = ASN1_INTEGER_dup(serial);
         if (in != NULL) {
-            M_ASN1_INTEGER_free(x-&gt;serialNumber);
+            ASN1_INTEGER_free(x-&gt;serialNumber);
             x-&gt;serialNumber = in;
         }
     }
diff --git a/crypto/x509v3/v3_akey.c b/crypto/x509v3/v3_akey.c
index e920270..7369af1 100644
--- a/crypto/x509v3/v3_akey.c
+++ b/crypto/x509v3/v3_akey.c
@@ -169,7 +169,7 @@ static AUTHORITY_KEYID *v2i_AUTHORITY_KEYID(X509V3_EXT_METHOD *method,
 
     if ((issuer &amp;&amp; !ikeyid) || (issuer == 2)) {
         isname = X509_NAME_dup(X509_get_issuer_name(cert));
-        serial = M_ASN1_INTEGER_dup(X509_get_serialNumber(cert));
+        serial = ASN1_INTEGER_dup(X509_get_serialNumber(cert));
         if (!isname || !serial) {
             X509V3err(X509V3_F_V2I_AUTHORITY_KEYID,
                       X509V3_R_UNABLE_TO_GET_ISSUER_DETAILS);
@@ -199,7 +199,7 @@ static AUTHORITY_KEYID *v2i_AUTHORITY_KEYID(X509V3_EXT_METHOD *method,
 
  err:
     X509_NAME_free(isname);
-    M_ASN1_INTEGER_free(serial);
-    M_ASN1_OCTET_STRING_free(ikeyid);
+    ASN1_INTEGER_free(serial);
+    ASN1_OCTET_STRING_free(ikeyid);
     return NULL;
 }
diff --git a/crypto/x509v3/v3_alt.c b/crypto/x509v3/v3_alt.c
index e16d2b6..50cb6b2 100644
--- a/crypto/x509v3/v3_alt.c
+++ b/crypto/x509v3/v3_alt.c
@@ -367,7 +367,7 @@ static int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p)
     while ((i = X509_NAME_get_index_by_NID(nm,
                                            NID_pkcs9_emailAddress, i)) &gt;= 0) {
         ne = X509_NAME_get_entry(nm, i);
-        email = M_ASN1_IA5STRING_dup(X509_NAME_ENTRY_get_data(ne));
+        email = ASN1_STRING_dup(X509_NAME_ENTRY_get_data(ne));
         if (move_p) {
             X509_NAME_delete_entry(nm, i);
             X509_NAME_ENTRY_free(ne);
@@ -391,7 +391,7 @@ static int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p)
 
  err:
     GENERAL_NAME_free(gen);
-    M_ASN1_IA5STRING_free(email);
+    ASN1_IA5STRING_free(email);
     return 0;
 
 }
@@ -498,7 +498,7 @@ GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out,
     }
 
     if (is_string) {
-        if (!(gen-&gt;d.ia5 = M_ASN1_IA5STRING_new()) ||
+        if (!(gen-&gt;d.ia5 = ASN1_IA5STRING_new()) ||
             !ASN1_STRING_set(gen-&gt;d.ia5, (unsigned char *)value,
                              strlen(value))) {
             X509V3err(X509V3_F_A2I_GENERAL_NAME, ERR_R_MALLOC_FAILURE);
diff --git a/crypto/x509v3/v3_bitst.c b/crypto/x509v3/v3_bitst.c
index b7bb3b5..bf0d7bc 100644
--- a/crypto/x509v3/v3_bitst.c
+++ b/crypto/x509v3/v3_bitst.c
@@ -112,7 +112,7 @@ ASN1_BIT_STRING *v2i_ASN1_BIT_STRING(X509V3_EXT_METHOD *method,
     ASN1_BIT_STRING *bs;
     int i;
     BIT_STRING_BITNAME *bnam;
-    if (!(bs = M_ASN1_BIT_STRING_new())) {
+    if (!(bs = ASN1_BIT_STRING_new())) {
         X509V3err(X509V3_F_V2I_ASN1_BIT_STRING, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
@@ -124,7 +124,7 @@ ASN1_BIT_STRING *v2i_ASN1_BIT_STRING(X509V3_EXT_METHOD *method,
                 if (!ASN1_BIT_STRING_set_bit(bs, bnam-&gt;bitnum, 1)) {
                     X509V3err(X509V3_F_V2I_ASN1_BIT_STRING,
                               ERR_R_MALLOC_FAILURE);
-                    M_ASN1_BIT_STRING_free(bs);
+                    ASN1_BIT_STRING_free(bs);
                     return NULL;
                 }
                 break;
@@ -134,7 +134,7 @@ ASN1_BIT_STRING *v2i_ASN1_BIT_STRING(X509V3_EXT_METHOD *method,
             X509V3err(X509V3_F_V2I_ASN1_BIT_STRING,
                       X509V3_R_UNKNOWN_BIT_STRING_ARGUMENT);
             X509V3_conf_err(val);
-            M_ASN1_BIT_STRING_free(bs);
+            ASN1_BIT_STRING_free(bs);
             return NULL;
         }
     }
diff --git a/crypto/x509v3/v3_conf.c b/crypto/x509v3/v3_conf.c
index 7af3aec..9631e57 100644
--- a/crypto/x509v3/v3_conf.c
+++ b/crypto/x509v3/v3_conf.c
@@ -195,7 +195,7 @@ static X509_EXTENSION *do_ext_i2d(const X509V3_EXT_METHOD *method,
         p = ext_der;
         method-&gt;i2d(ext_struc, &amp;p);
     }
-    if (!(ext_oct = M_ASN1_OCTET_STRING_new()))
+    if (!(ext_oct = ASN1_OCTET_STRING_new()))
         goto merr;
     ext_oct-&gt;data = ext_der;
     ext_der = NULL;
@@ -204,7 +204,7 @@ static X509_EXTENSION *do_ext_i2d(const X509V3_EXT_METHOD *method,
     ext = X509_EXTENSION_create_by_NID(NULL, ext_nid, crit, ext_oct);
     if (!ext)
         goto merr;
-    M_ASN1_OCTET_STRING_free(ext_oct);
+    ASN1_OCTET_STRING_free(ext_oct);
 
     return ext;
 
@@ -213,7 +213,7 @@ static X509_EXTENSION *do_ext_i2d(const X509V3_EXT_METHOD *method,
     if (ext_der != NULL)
         OPENSSL_free(ext_der);
     if (ext_oct != NULL)
-        M_ASN1_OCTET_STRING_free(ext_oct);
+        ASN1_OCTET_STRING_free(ext_oct);
     return NULL;
 
 }
@@ -292,7 +292,7 @@ static X509_EXTENSION *v3_generic_extension(const char *ext, char *value,
         goto err;
     }
 
-    if (!(oct = M_ASN1_OCTET_STRING_new())) {
+    if (!(oct = ASN1_OCTET_STRING_new())) {
         X509V3err(X509V3_F_V3_GENERIC_EXTENSION, ERR_R_MALLOC_FAILURE);
         goto err;
     }
@@ -305,7 +305,7 @@ static X509_EXTENSION *v3_generic_extension(const char *ext, char *value,
 
  err:
     ASN1_OBJECT_free(obj);
-    M_ASN1_OCTET_STRING_free(oct);
+    ASN1_OCTET_STRING_free(oct);
     if (ext_der)
         OPENSSL_free(ext_der);
     return extension;
diff --git a/crypto/x509v3/v3_cpols.c b/crypto/x509v3/v3_cpols.c
index 9826859..66d486f 100644
--- a/crypto/x509v3/v3_cpols.c
+++ b/crypto/x509v3/v3_cpols.c
@@ -234,7 +234,7 @@ static POLICYINFO *policy_section(X509V3_CTX *ctx,
                 X509V3err(X509V3_F_POLICY_SECTION, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
-            if(!(qual-&gt;d.cpsuri = M_ASN1_IA5STRING_new()))
+            if(!(qual-&gt;d.cpsuri = ASN1_IA5STRING_new()))
                 goto merr;
             if (!ASN1_STRING_set(qual-&gt;d.cpsuri, cnf-&gt;value,
                                  strlen(cnf-&gt;value)))
@@ -304,7 +304,7 @@ static POLICYQUALINFO *notice_section(X509V3_CTX *ctx,
     for (i = 0; i &lt; sk_CONF_VALUE_num(unot); i++) {
         cnf = sk_CONF_VALUE_value(unot, i);
         if (!strcmp(cnf-&gt;name, &quot;explicitText&quot;)) {
-            if(!(not-&gt;exptext = M_ASN1_VISIBLESTRING_new()))
+            if(!(not-&gt;exptext = ASN1_VISIBLESTRING_new()))
                 goto merr;
             if (!ASN1_STRING_set(not-&gt;exptext, cnf-&gt;value,
                                  strlen(cnf-&gt;value)))
diff --git a/crypto/x509v3/v3_ia5.c b/crypto/x509v3/v3_ia5.c
index 642171f..42a0d86 100644
--- a/crypto/x509v3/v3_ia5.c
+++ b/crypto/x509v3/v3_ia5.c
@@ -97,11 +97,11 @@ ASN1_IA5STRING *s2i_ASN1_IA5STRING(X509V3_EXT_METHOD *method,
                   X509V3_R_INVALID_NULL_ARGUMENT);
         return NULL;
     }
-    if (!(ia5 = M_ASN1_IA5STRING_new()))
+    if (!(ia5 = ASN1_IA5STRING_new()))
         goto err;
     if (!ASN1_STRING_set((ASN1_STRING *)ia5, (unsigned char *)str,
                          strlen(str))) {
-        M_ASN1_IA5STRING_free(ia5);
+        ASN1_IA5STRING_free(ia5);
         goto err;
     }
 #ifdef CHARSET_EBCDIC
diff --git a/crypto/x509v3/v3_prn.c b/crypto/x509v3/v3_prn.c
index a760794..7fd3231 100644
--- a/crypto/x509v3/v3_prn.c
+++ b/crypto/x509v3/v3_prn.c
@@ -209,7 +209,7 @@ int X509V3_extensions_print(BIO *bp, char *title,
             return 0;
         if (!X509V3_EXT_print(bp, ex, flag, indent + 4)) {
             BIO_printf(bp, &quot;%*s&quot;, indent + 4, &quot;&quot;);
-            M_ASN1_OCTET_STRING_print(bp, ex-&gt;value);
+            ASN1_STRING_print(bp, ex-&gt;value);
         }
         if (BIO_write(bp, &quot;\n&quot;, 1) &lt;= 0)
             return 0;
diff --git a/crypto/x509v3/v3_skey.c b/crypto/x509v3/v3_skey.c
index 1cede04..705d86c 100644
--- a/crypto/x509v3/v3_skey.c
+++ b/crypto/x509v3/v3_skey.c
@@ -83,13 +83,13 @@ ASN1_OCTET_STRING *s2i_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method,
     ASN1_OCTET_STRING *oct;
     long length;
 
-    if (!(oct = M_ASN1_OCTET_STRING_new())) {
+    if (!(oct = ASN1_OCTET_STRING_new())) {
         X509V3err(X509V3_F_S2I_ASN1_OCTET_STRING, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
 
     if (!(oct-&gt;data = string_to_hex(str, &amp;length))) {
-        M_ASN1_OCTET_STRING_free(oct);
+        ASN1_OCTET_STRING_free(oct);
         return NULL;
     }
 
@@ -110,7 +110,7 @@ static ASN1_OCTET_STRING *s2i_skey_id(X509V3_EXT_METHOD *method,
     if (strcmp(str, &quot;hash&quot;))
         return s2i_ASN1_OCTET_STRING(method, ctx, str);
 
-    if (!(oct = M_ASN1_OCTET_STRING_new())) {
+    if (!(oct = ASN1_OCTET_STRING_new())) {
         X509V3err(X509V3_F_S2I_SKEY_ID, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
@@ -137,7 +137,7 @@ static ASN1_OCTET_STRING *s2i_skey_id(X509V3_EXT_METHOD *method,
         (pk-&gt;data, pk-&gt;length, pkey_dig, &amp;diglen, EVP_sha1(), NULL))
         goto err;
 
-    if (!M_ASN1_OCTET_STRING_set(oct, pkey_dig, diglen)) {
+    if (!ASN1_OCTET_STRING_set(oct, pkey_dig, diglen)) {
         X509V3err(X509V3_F_S2I_SKEY_ID, ERR_R_MALLOC_FAILURE);
         goto err;
     }
@@ -145,6 +145,6 @@ static ASN1_OCTET_STRING *s2i_skey_id(X509V3_EXT_METHOD *method,
     return oct;
 
  err:
-    M_ASN1_OCTET_STRING_free(oct);
+    ASN1_OCTET_STRING_free(oct);
     return NULL;
 }
diff --git a/crypto/x509v3/v3_sxnet.c b/crypto/x509v3/v3_sxnet.c
index df1384a..ecd1ec6 100644
--- a/crypto/x509v3/v3_sxnet.c
+++ b/crypto/x509v3/v3_sxnet.c
@@ -117,7 +117,7 @@ static int sxnet_i2r(X509V3_EXT_METHOD *method, SXNET *sx, BIO *out,
         tmp = i2s_ASN1_INTEGER(NULL, id-&gt;zone);
         BIO_printf(out, &quot;\n%*sZone: %s, User: &quot;, indent, &quot;&quot;, tmp);
         OPENSSL_free(tmp);
-        M_ASN1_OCTET_STRING_print(out, id-&gt;user);
+        ASN1_STRING_print(out, id-&gt;user);
     }
     return 1;
 }
@@ -166,9 +166,9 @@ int SXNET_add_id_ulong(SXNET **psx, unsigned long lzone, char *user,
                        int userlen)
 {
     ASN1_INTEGER *izone = NULL;
-    if (!(izone = M_ASN1_INTEGER_new()) || !ASN1_INTEGER_set(izone, lzone)) {
+    if (!(izone = ASN1_INTEGER_new()) || !ASN1_INTEGER_set(izone, lzone)) {
         X509V3err(X509V3_F_SXNET_ADD_ID_ULONG, ERR_R_MALLOC_FAILURE);
-        M_ASN1_INTEGER_free(izone);
+        ASN1_INTEGER_free(izone);
         return 0;
     }
     return SXNET_add_id_INTEGER(psx, izone, user, userlen);
@@ -214,7 +214,7 @@ int SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, char *user,
     if (userlen == -1)
         userlen = strlen(user);
 
-    if (!M_ASN1_OCTET_STRING_set(id-&gt;user, user, userlen))
+    if (!ASN1_OCTET_STRING_set(id-&gt;user, (unsigned char *)user, userlen))
         goto err;
     if (!sk_SXNETID_push(sx-&gt;ids, id))
         goto err;
@@ -238,7 +238,7 @@ ASN1_OCTET_STRING *SXNET_get_id_asc(SXNET *sx, char *zone)
         return NULL;
     }
     oct = SXNET_get_id_INTEGER(sx, izone);
-    M_ASN1_INTEGER_free(izone);
+    ASN1_INTEGER_free(izone);
     return oct;
 }
 
@@ -246,13 +246,13 @@ ASN1_OCTET_STRING *SXNET_get_id_ulong(SXNET *sx, unsigned long lzone)
 {
     ASN1_INTEGER *izone = NULL;
     ASN1_OCTET_STRING *oct;
-    if (!(izone = M_ASN1_INTEGER_new()) || !ASN1_INTEGER_set(izone, lzone)) {
+    if (!(izone = ASN1_INTEGER_new()) || !ASN1_INTEGER_set(izone, lzone)) {
         X509V3err(X509V3_F_SXNET_GET_ID_ULONG, ERR_R_MALLOC_FAILURE);
-        M_ASN1_INTEGER_free(izone);
+        ASN1_INTEGER_free(izone);
         return NULL;
     }
     oct = SXNET_get_id_INTEGER(sx, izone);
-    M_ASN1_INTEGER_free(izone);
+    ASN1_INTEGER_free(izone);
     return oct;
 }
 
@@ -262,7 +262,7 @@ ASN1_OCTET_STRING *SXNET_get_id_INTEGER(SXNET *sx, ASN1_INTEGER *zone)
     int i;
     for (i = 0; i &lt; sk_SXNETID_num(sx-&gt;ids); i++) {
         id = sk_SXNETID_value(sx-&gt;ids, i);
-        if (!M_ASN1_INTEGER_cmp(id-&gt;zone, zone))
+        if (!ASN1_INTEGER_cmp(id-&gt;zone, zone))
             return id-&gt;user;
     }
     return NULL;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000747.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="000750.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#749">[ date ]</a>
              <a href="thread.html#749">[ thread ]</a>
              <a href="subject.html#749">[ subject ]</a>
              <a href="author.html#749">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
