<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [tools]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2018-February/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Btools%5D%20%20master%20update&In-Reply-To=%3C1517700249.074535.13354.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017907.html">
   <LINK REL="Next"  HREF="017920.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [tools]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Btools%5D%20%20master%20update&In-Reply-To=%3C1517700249.074535.13354.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [tools]  master update">rsalz at openssl.org
       </A><BR>
    <I>Sat Feb  3 23:24:09 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="017907.html">[openssl-commits] Passed: openssl/openssl#16047 (master - 22da44f)
</A></li>
        <LI>Next message: <A HREF="017920.html">[openssl-commits] [tools]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17911">[ date ]</a>
              <a href="thread.html#17911">[ thread ]</a>
              <a href="subject.html#17911">[ subject ]</a>
              <a href="author.html#17911">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  27296557068a17464f17533d89d4fa6f3555b909 (commit)
      from  bb40e3e6bcd68b3ba9ba4e71751d9f8e630f63cf (commit)


- Log -----------------------------------------------------------------
commit 27296557068a17464f17533d89d4fa6f3555b909
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at akamai.com</A>&gt;
Date:   Sat Feb 3 18:23:50 2018 -0500

    Add our release tools

-----------------------------------------------------------------------

Summary of changes:
 release-tools/MKRELEASE.md       | 168 +++++++++++++++
 release-tools/README.md          | 320 +++++++++++++++++++++++++++++
 release-tools/do-copyright-year  |  40 ++++
 release-tools/do-release.pl      | 209 +++++++++++++++++++
 release-tools/mkrelease.pl       | 427 +++++++++++++++++++++++++++++++++++++++
 release-tools/release-check.pl   | 215 ++++++++++++++++++++
 release-tools/release-date.pl    |  64 ++++++
 release-tools/release-git.pl     | 164 +++++++++++++++
 release-tools/release-update.pl  | 153 ++++++++++++++
 release-tools/release-version.pl | 179 ++++++++++++++++
 10 files changed, 1939 insertions(+)
 create mode 100644 release-tools/MKRELEASE.md
 create mode 100644 release-tools/README.md
 create mode 100755 release-tools/do-copyright-year
 create mode 100644 release-tools/do-release.pl
 create mode 100644 release-tools/mkrelease.pl
 create mode 100644 release-tools/release-check.pl
 create mode 100644 release-tools/release-date.pl
 create mode 100644 release-tools/release-git.pl
 create mode 100644 release-tools/release-update.pl
 create mode 100644 release-tools/release-version.pl

diff --git a/release-tools/MKRELEASE.md b/release-tools/MKRELEASE.md
new file mode 100644
index 0000000..04d6dc7
--- /dev/null
+++ b/release-tools/MKRELEASE.md
@@ -0,0 +1,168 @@
+# Documentation on the mkrelease.pl script
+
+This file provides an overview of the mkrelease.pl script, and how to
+configure some of its parameters (by setting environment variables).
+It is normally run by following the process in README.md and should be
+run in a pristine directgory of the branch to be released, which must
+be a stable branch.
+
+The script handles most of the processes involved in making a release
+including:
+
+1. Doing `make update`
+2. Changing version numbers in various files
+3. Tagging release
+4. Making the tarballs, .md5, .sha1, .sha256 and .gpg files
+5. Creating the signed email announcement, including hashes of release
+6. Uploading files to dev.openssl.org
+7. Updating the version for next release
+
+If you plan to make an actual release make sure your GPG key is included
+in the [OMC list](<A HREF="https://www.openssl.org/community/omc.html">https://www.openssl.org/community/omc.html</A>) on the website
+and in the file doc/fingerprints.txt of *all* active branches.
+
+The script mkrelease.pl calls the files release-check.pl, release-date.pl,
+release-git.pl, release-update.pl and release-version.pl, which are expected
+to all be in the same directory.
+
+You are advised to clone a fresh repository. Unless you specify `--no-clean`
+the release process will run `git clean -x -d -f`
+*WARNING* this will delete ALL untracked files from the current branch.
+
+From the branch directory if you run:
+
+        perl /path/to/mkrelease.pl --reviewer=name
+
+It should perform all of the above steps and commit changes locally. You can
+then sanity check these with `git log` before pushing them to the public repo.
+
+## Environment Variables
+
+- OPENSSL&lt;br&gt;
+  Path to openssl utility to use. Default is `openssl`.
+
+- OPENSSL_TAR&lt;br&gt;
+  The tar command to use when creating the tarball. Default is `tar`.
+
+- OPENSSL_GPG&lt;br&gt;
+  The gpg command to use when signing a tarball or announcement.
+  The default is `gpg` which will use gpg with the default key.
+  If you wish to use a different, key set OPENSSL_GPG to include
+  appropriate options.
+
+- OPENSSL_GPG_TAR&lt;br&gt;
+  Command to use to sign a tarball.
+  The default is: `$OPENSSL_GPG --use-agent -sba`
+
+- OPENSSL_GPG_ANNOUNCE&lt;br&gt;
+  The command to use to sign a tarball.
+  The default is: `$OPENSSL_GPG --use-agent -sta --clearsign`
+
+- OPENSSL_SCP&lt;br&gt;
+  The command to use to upload files.
+  The default is `scp`
+
+- OPENSSL_SCP_HOST&lt;br&gt;
+  The host (and optional username) needed to upload files.
+  The default is `dev.openssl.org`, but you might want to change this to
+  `<A HREF="../../../mailman/listinfo/openssl-commits.html">username at dev.openssl.org</A>`
+
+- OPENSSL_SCP_DIR&lt;br&gt;
+  The directory to upload files to.
+  Normally this wont be changed from the default which is
+  `$OPENSSL_SCP_HOST:~openssl/dist/new`
+  This is a holding area on dev.openssl.org where distributions are uploaded
+  temporarily before being moved to the web and ftp directories.
+
+For local testing, you can do something like this:
+
+        export OPENSSL_SCP=cp
+        export OPENSSL_SCP_DIR=&quot;$HOME/testdir&quot;
+
+## Options
+
+- `--revert`&lt;br&gt;
+  Remove all local changes from repository and delete any release tag. This
+  returns the local tree to the same state as before a release attempt was
+  made.
+
+- `--reviewer=name`&lt;br&gt;
+  Add reviewer `name` to list of reviewers in commit message. Any valid
+  name for checking OMC membership will work.
+  This option may be used multiple times; at least one is required.
+
+- `--enter-pre`&lt;br&gt;
+  Instead of making a full release enter pre-release state. This by itself
+  will not produce a release it will just change version numbers and commit
+  the changes. Subsequent releases on this branch will be pre-release
+  versions. This option should NOT be used if the branch is already in
+  pre-release state.
+
+- `--leave-pre`&lt;br&gt;
+  For a branch in pre-release state, leave pre-release and make a full release.
+
+- `--label=label`&lt;br&gt;
+   Add the textual label `label` to the version string, where `label` must be
+   one of `alpha` or `beta`. While in pre-release state a label *must* be
+   provided.
+
+- `--no-upload`&lt;br&gt;
+  Do not attempt to upload release files to dev.openssl.org
+
+- `--no-clean`&lt;br&gt;
+  Do not clean untracked files from directory. Warning: if you use this option
+  you can end up with extraneous files in the distribution tarball.
+
+- `--no-update`&lt;br&gt;
+  Do not perform a `make update`.
+
+- `--verbose`&lt;br&gt;
+  Be more verbose at what is going on
+
+- `--debug`&lt;br&gt;
+  Include debug output to describe all actions in detail
+
+- `--git-info`&lt;br&gt;
+  Just print out details of all git branch information and exit
+
+- `--git-branch-info`&lt;br&gt;
+  Print out details of the currently detected branch and exit
+
+- `--branch-version=version`&lt;br&gt;
+  Use branch `version` instead of the one autodetected for the current branch.
+  This option is not normally needed.
+
+# The do-release script
+
+The do-release.pl script copies distributions from the temporary holding area
+to the http and ftp areas. It it intended to be run as the `openssl` user on
+dev.openssl.org.
+
+It does the following:
+
+1. Copy OpenSSL release files from the holding area to the http and ftp
+   locations: currently /v/openssl/www/source and /v/openssl/ftp/source
+2. Move OpenSSL release files from holding area to ~openssl/dist/old By
+   doing this the script wont try and make a release again with old files.
+3. Mail the release message. This is sent to openssl-dev openssl-users and
+   openssl-announce (it needs to be approved in openssl-announce). The
+   subject line is `OpenSSL version xxx released`.
+
+## do-release options
+
+- `--copy`&lt;br&gt;
+  Copy files to http and ftp directories.  **You will have to manually move
+  the OLD files to old/&lt;SUBDIR&gt; directories.**
+
+- `--move`&lt;br&gt;
+  Move files from holding area to ~openssl/dist/old
+
+- `--mail`&lt;br&gt;
+  Send out announcement email: if this option is not given, the command you
+  need to call to send the release mail will be printed out.
+
+- `--full-release`&lt;br&gt;
+  Perform all operations for a release (copy, move and mail).
+
+Note: because several of these options are irreversible they have to be
+explicitly included.
diff --git a/release-tools/README.md b/release-tools/README.md
new file mode 100644
index 0000000..7b3767e
--- /dev/null
+++ b/release-tools/README.md
@@ -0,0 +1,320 @@
+# HOW TO MAKE A RELEASE
+
+This file documents how to make an OpenSSL release.  Please fix any
+errors you find while doing, or just after, your next release!
+
+Releases are done by one person, with a second person acting as the
+reviewer and additional tester.
+
+## Pre-requisites
+
+Have a local clone of the website repo:
+
+        <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-git at git.openssl.org</A>:openssl-web.git
+
+Make sure you can sudo to the openssl user on dev.openssl.org; this is
+usually done by being in the openssl group.  For example, ssh to the
+server and run this command:
+
+        sudo -u openssl id
+
+## Setup
+
+The day before the release, freeze the main repository.  This locks out
+everyone but the named user, who is doing the release, from doing any pushes.
+Someone other than the person doing the release should run the command.
+For example:
+
+        ssh <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-git at git.openssl.org</A> freeze openssl NAME
+
+## Making the tarball and announcements
+
+This section generates the tarball and announcements locally.  It makes
+no changes which cannot be easily undone.  You will have to repeat this
+section for each version being released, so it is often easier to have
+separate copies:
+
+        git clone <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-git at git.openssl.org</A>:openssl.git rel-102
+        cd rel-102
+        git branch --track OpenSSL_1_0_2-stable origin/OpenSSL_1_0_2-stable
+        git checkout OpenSSL_1_0_2-stable
+
+Make sure that the CHANGES and NEWS files have been updated and reviewed.
+NEWS should contain a summary of any changes for the release, and for a
+security release is (often just a list of the CVEs addressed. You should also
+update NEWS in the master branch to include details of all releases. Just
+update the NEWS bullet points - do not change the release date, keep it as
+**under development**.
+
+Add any security fixes to the tree. Commit them but *do not push*.
+
+Make sure that the copyrights are updated.  This script will update
+the copyright markers and commit the changes (where $HERE stands for
+the directory where this README is):
+
+        $HERE/do-copyright-year
+
+Perform the local automated release steps. This can normally be done with:
+
+        perl $HERE/mkrelease.pl --reviewer=NAME
+
+Alternatively, to use the openssl-team PGP key:
+
+        export OPENSSL_GPG_KEYID=8B3D79F5
+        perl $HERE/mkrelease.pl --reviewer=NAME
+
+See $HERE/MKRELEASE.md for details of the options to mkrelease.pl.
+This will leave a handful of files in the parent directory of where
+you extracted the release.
+See below for details of how to do perform this step manually if you want
+to or have to.
+
+Verify that the results of the script are sensible. Check
+the commits the automated release process has performed, using for example
+`git log`. Check the signed announcement RELEASE.asc file. Maybe check
+that the tarball length and hashes match in the .md5, .sha1, and review
+the announcment file. *Do not push* changes to the public repo at this stage.
+
+Both the person doing the release and the reviewer should sanity-check the
+release at this point. Checks to consider include the following:
+
+- Builds and make test passes on multiple plaforms - Linux, Windows, etc.
+- Builds from tarball
+
+Send the auto-generated commits to the reviewer and await their +1.
+Repeat from the begining of this section if you need to release
+multiple versions.
+
+## Website updates
+
+The changes in this section should be made in your copy of the web repo.
+
+Update the news/newsflash.txt file. This normally is one or two lines. Just
+copy and paste existing announcements making minor changes for the date and
+version number as necessary.
+
+Update the news/vulnerabilities.xml file if appropriate.
+
+If there is a Security Advisory then copy it into the news/secadv directory.
+
+Commit your changes, but *do not push* them to the website.
+
+## Publishing the release
+
+*BE CAREFUL*  This section makes everything visible and is therefore
+largely irreversible. If you are performing a dry run then DO NOT
+perform any steps in this section.
+
+Check that release has been uploaded properly. The release tarballs and
+associated files should be in ~openssl/dist/new.  They should be owned by the
+openssl userid and world-readable.
+
+Copy the tarballs to appropriate directories. This can be
+done using the do-release.pl script.  See MKRELEASE.md for a description of
+the options. For example:
+
+        sudo -u openssl perl ~openssl/do-release.pl --copy --move
+
+This will copy the relevant files to the website and move them from
+~openssl/dist/new to ~openssl/dist/old so they will not seen by a subsequent
+release. Alternatively if you want to perform one release at a time or copy/move
+the files manually, see below.
+
+The do-release.pl script will display the commands you will need to issue to
+send the announcement emails later. Keep a note of those commands for future
+reference.
+
+Verify that the tarballs are available via FTP:
+
+        <A HREF="ftp://ftp.openssl.org/source/">ftp://ftp.openssl.org/source/</A>
+
+And that they are ready for the website:
+
+        ls /var/www/openssl/source
+
+Push your local changes made above to the public repo. You will
+typically want to sanity check this with:
+
+        git push -n
+
+Push new tags to public repo. Again sanity check with:
+
+        git push --tags -n
+
+to make sure no local tags were pushed.
+
+##  Updating the website
+
+Push the website changes you made earlier to the OpenSSL website repo.  When
+you do this, the website will get updated and a script to flush the Akamai CDN
+cache will be run.  You can look at things on www-origin.openssl.org; the
+CDN-hosted www.openssl.org should only be a few minutes delayed.
+
+Verify that the release notes, which are built from the CHANGES file in the
+release, have been updated. This is done automatically by the commit-hook, but
+if you see a problem, try the following steps:
+
+        cd /var/www/openssl
+        sudo -u openssl -H make relupd
+        sudo -u openssl ./bin/purge-one-hour
+
+Wait for a while for the Akamai flush to work (normally within a few minutes).
+Have a look at the website and news announcement at:
+
+        <A HREF="https://www.openssl.org/">https://www.openssl.org/</A>
+        <A HREF="https://www.openssl.org/news/">https://www.openssl.org/news/</A>
+
+Check the download page has updated properly:
+
+        <A HREF="https://www.openssl.org/source/">https://www.openssl.org/source/</A>
+
+Check the notes look sensible at:
+
+        <A HREF="https://www.openssl.org/news/news.html">https://www.openssl.org/news/news.html</A>
+
+Also check the notes here:
+
+        <A HREF="https://www.openssl.org/news/openssl-1.0.2-notes.html">https://www.openssl.org/news/openssl-1.0.2-notes.html</A>
+        <A HREF="https://www.openssl.org/news/openssl-1.1.0-notes.html">https://www.openssl.org/news/openssl-1.1.0-notes.html</A>
+
+## Send the announcement mail
+
+Send out the announcements. Generic release announcement messages will be
+created automatically by the build script and the commands you need to use to
+send them were displayed when you executed do-release.pl above.
+These should normally be sent from the openssl account. These are sent to
+openssl-users, openssl-project, and openssl-announce.
+
+If do-release.pl was used with `--move` be sure to move the
+announcement text files away from the staging directory after they have been
+sent.  This is done as follows (with VERSION replaced with the version of
+OpenSSL to announce):
+
+        sudo -u openssl \
+            mv ~openssl/dist/new/openssl-VERSION.txt.asc ~openssl/dist/old
+
+Send out the Security Advisory if there is one. Copy the file to the
+openssl user home directory, and then do the following
+
+        sudo -u openssl gpg -u 8B3D79F5 --clearsign secadv_FILENAME
+        sudo -u openssl mutt -s &quot;OpenSSL Security Advisory&quot; \
+                openssl-project openssl-users openssl-announce
+                &lt;~openssl/secadv_FILENAME.txt.asc
+
+Approve the openssl-announce email.  Go to
+&lt;<A HREF="https://mta.openssl.org/mailman/admindb/openssl-announce">https://mta.openssl.org/mailman/admindb/openssl-announce</A>&gt;
+and approve the messages.
+The administration password needed for approval is held in /opt/mailman/README
+on mta.openssl.org
+
+Check the mailing list messages have arrived.
+
+## Finish
+
+Unfreeze the repository.
+
+        ssh <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-git at git.openssl.org</A> unfreeze openssl
+
+If this release includes security fixes with a CVE then you should inform
+MITRE about them. See the instructions at the top of cvepool.txt in bureau.
+
+Check mailing lists over the next few hours for reports of any success
+or failure. If necessary fix these and in the worst case make another
+release.
+
+# MANUAL PROCESS
+
+If for some reason you cannot use, or do not trust, release script
+mkrelease.pl then you can perform the release manually.  This is difficult to
+get right so you should avoid it if possible.
+
+Check what the automated release did for previous releases. This is the best
+way to get a feel for what happens. You can do this by checking the commit
+logs before a release tag for example:
+
+        git log --reverse 0d7717f..ebe2219
+
+The first two commits are security fixes. The third commit is (as the log
+message implies) an update of the NEWS file. The next commit which has the
+automated log message &quot;Prepare for 1.0.1g release&quot; includes the steps
+necessary to make the release.
+
+## Manually building the release files
+
+Do a `make update`. If necessary commit. You can push this commit to
+the repo so you have as few local changes as possible. Note that even if
+&quot;make update&quot; does not make any visible changes it can still update timestamps
+on some files which avoid some problems with builds (e.g. if the source files
+are all made read only).
+
+Update NEWS, README and CHANGES. These should contain the date and
+the correct version in the appropriate format.
+
+Update crypto/opensslv.h which contains the version. This contains the
+version number in the appropriate formats. For OPENSSL_VERSION_NUMBER and
+normal (not pre) releases you change the last digit from 0 (meaning -dev)
+to f (meaning release). Change the text forms in OPENSSL_VERSION_TEXT for
+normal and FIPS builds.
+
+Double-check that the version is right. If you mess up the syntax you can end
+up with the wrong release number or worse break compilation.
+
+Commit the changes you made so far, and check that the logs look sensible.
+
+Make a local tag; the public repo requires annotated tags:
+
+        git tag -s -m &quot;OpenSSL 1.0.2L release tag&quot; OpenSSL_1_0_2L
+
+or if you want to use the openssl-team key:
+
+        git tag -u 8B3D79F5 -m &quot;OpenSSL 1.0.2L release tag&quot; OpenSSL_1_0_2L
+
+Make the release tarball. You do this with:
+
+        make dist
+
+Create .sha1, .sha256 and .asc files manually. You can use:
+
+        openssl sha1
+        openssl sha256
+
+Create .sha1, .sha256 and .asc files manually. You can use the openssl sha1 and
+sha256 commands, obviously. Sign the tarball:
+
+        gpg -sba opensslversion.tar.gz
+
+or if you want to use the openssl-team key:
+
+        gpg -u 8B3D79F5 -sba opensslversion.tar.gz
+
+Create an announcement file. You can use an existing one as a
+template for example something in ~openssl/dist/old/ update the version
+numbers, tarball size and hashes. Sign announcement with:
+
+        gpg -sta --clearsign announce.txt
+
+or if you want to use the openssl-team key:
+
+        gpg -u 8B3D79F5 -sta --clearsign announce.txt
+
+Prepare for next development version by updating CHANGES, NEWS, README
+crypto/opensslv.h and openssl.spec. The automated scripts use the comment
+message `Prepare for 1.0.1h-dev`.
+
+Be absolutely *certain* you did not make any mistakes, so check
+several times preferably by different people.
+
+Upload tarballs to dev.openssl.org
+
+## Manually releasing the files
+
+If you do not want to use do-release.pl, you can manually perform
+the steps necessary for the release. This is (fortunately) much simpler
+than the manual release process above.
+
+Copy release files to web source directory. The four files (tarball,
+sha1, .sha256 and .asc) need to be manually copied to /var/www/openssl/source
+Also move any outdated releases to /var/www/openssl/source/old/SUBDIR
+
+Copy files to ftp source directory, /srv/ftp/source.
+Also move any oudated releases to /srv/ftp/source/old/SUBDIR
diff --git a/release-tools/do-copyright-year b/release-tools/do-copyright-year
new file mode 100755
index 0000000..59b9235
--- /dev/null
+++ b/release-tools/do-copyright-year
@@ -0,0 +1,40 @@
+#!/usr/bin/env bash
+#
+# Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+this_year=`date +%Y`
+some_year=&quot;[12][0-9][0-9][0-9]&quot;
+year_range=&quot;(${some_year})(-${some_year})?&quot;
+
+copyright_owner=&quot;The OpenSSL Project&quot;
+copyright=&quot;Copyright .*${year_range} .*${copyright_owner}&quot;
+
+# sed_script:
+#   for all lines that contain ${copyright} : {
+#     replace years yyyy-zzzz (or year yyyy) by yyyy-${this_year}
+#     replace repeated years yyyy-yyyy by yyyy
+#   }
+ss=/tmp/sed$$
+cat &lt;&lt;EOF &gt;$ss
+/${copyright}/ {
+s|${year_range}|\1-${this_year}|
+s|(${some_year})-\1|\1|
+}
+EOF
+
+NYD=`date +%Y-01-01`
+echo Updating copryight
+git diff-tree -r --name-only `git rev-list -1 --before=$NYD HEAD`..HEAD \
+	| while read FILE ; do
+    sed -E -f /tmp/sed$$ &quot;$FILE&quot; &gt;/tmp/$$
+    mv /tmp/$$ &quot;$FILE&quot;
+    git add &quot;$FILE&quot;
+done
+echo Committing change locally.
+git commit -m 'Update copyright year'
+rm -f $ss
diff --git a/release-tools/do-release.pl b/release-tools/do-release.pl
new file mode 100644
index 0000000..1725055
--- /dev/null
+++ b/release-tools/do-release.pl
@@ -0,0 +1,209 @@
+#! /usr/bin/env perl
+# Copyright 2010-2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+use strict;
+use warnings;
+
+my $homedir = glob(&quot;~openssl&quot;);
+my $tmpdir  = $ENV{&quot;OPENSSL_TMP_DIR&quot;} // $homedir . &quot;/dist/new&quot;;
+my $olddir  = $ENV{&quot;OPENSSL_OLD_DIR&quot;} // $homedir . &quot;/dist/old&quot;;
+my $srcdir  = $ENV{&quot;OPENSSL_SRC_DIR&quot;} // &quot;/var/www/openssl/source&quot;;
+my $ftpdir  = $ENV{&quot;OPENSSL_FTP_DIR&quot;} // &quot;/srv/ftp/source&quot;;
+my $mail    = $ENV{&quot;OPENSSL_MAIL&quot;} // &quot;mutt -s SUBJECT RECIP &lt; BODY&quot;;
+
+my $do_mail   = 0;
+my $do_copy   = 0;
+my $do_move   = 0;
+my $mail_only = 0;
+
+foreach (@ARGV) {
+    if (/--tmpdir=(.*)$/) {
+        $tmpdir = $1;
+    } elsif (/^--copy$/) {
+        $do_copy = 1;
+    }
+    elsif (/^--move$/) {
+        $do_move = 1;
+    } elsif (/^--mail$/) {
+        $do_mail = 1;
+    } elsif (/^--mail-only$/) {
+        $mail_only = 1;
+        $do_mail   = 1;
+    } elsif (/^--full-release$/) {
+        $do_mail = 1;
+        $do_copy = 1;
+        $do_move = 1;
+    } else {
+        print STDERR &quot;Unknown command line argument $_&quot;;
+        exit 1;
+    }
+}
+
+if ( getpwuid($&lt;) ne &quot;openssl&quot; &amp;&amp; !exists $ENV{&quot;OPENSSL_RELEASE_TEST&quot;} ) {
+    print &quot;This script must be run as the \&quot;openssl\&quot; user\n&quot;;
+    exit 1;
+}
+
+die &quot;Can't find distribution directory $tmpdir&quot;     unless -d $tmpdir;
+die &quot;Can't find old distribution directory $olddir&quot; unless -d $olddir;
+die &quot;Can't find source directory $srcdir&quot;           unless -d $srcdir;
+die &quot;Can't find ftp directory $ftpdir&quot;              unless -d $ftpdir;
+
+my @versions;
+my @series;
+my @files = glob(&quot;$tmpdir/*.txt.asc&quot;);
+
+foreach (@files) {
+    if (/^.*\/openssl-(\d+\.\d+\.\d+[a-z]*-pre\d+)\..*$/) {
+        push @versions, $1;
+    } elsif (/^.*\/openssl-(\d+\.\d+\.\d+[a-z]*)\..*$/) {
+        push @versions, $1;
+    } else {
+        die &quot;Unexpected filename $_&quot;;
+    }
+}
+foreach (@versions) {
+    if (/^(\d+\.\d+\.\d+)[a-z]*$/) {
+        my $serie = $1;
+        push @series, $serie unless grep /^$serie/, @series;
+    }
+}
+die &quot;No distribution in temp directory!&quot; if ( scalar @versions == 0 );
+print &quot;OpenSSL versions to be released:\n&quot;;
+foreach (@versions) {
+    print &quot;$_\n&quot;;
+}
+print &quot;OK? (y/n)\n&quot;;
+$_ = &lt;STDIN&gt;;
+exit 1 unless /^y/i;
+
+my @distfiles;
+my @announce;
+
+foreach (@versions) {
+    push @distfiles, &quot;openssl-$_.tar.gz&quot;;
+    push @distfiles, &quot;openssl-$_.tar.gz.sha1&quot;;
+    push @distfiles, &quot;openssl-$_.tar.gz.sha256&quot;;
+    push @distfiles, &quot;openssl-$_.tar.gz.asc&quot;;
+    push @announce,  &quot;openssl-$_.txt.asc&quot;;
+}
+
+$do_copy = 0 if $mail_only;
+
+my $bad = 0;
+if ($do_copy) {
+    foreach (@distfiles) {
+        if ( !-f &quot;$tmpdir/$_&quot; ) {
+            print STDERR &quot;File $_ not found in temp directory!\n&quot;;
+            $bad = 1;
+        }
+        if ( -e &quot;$srcdir/$_&quot; ) {
+            print STDERR &quot;File $_ already present in source directory!\n&quot;;
+            $bad = 1;
+        }
+        if ( -e &quot;$ftpdir/$_&quot; ) {
+            print STDERR &quot;File $_ already present in ftp directory!\n&quot;;
+            $bad = 1;
+        }
+        if ( -e &quot;$olddir/$_&quot; ) {
+            print STDERR
+              &quot;File $_ already present in old distributions directory!\n&quot;;
+            $bad = 1;
+        }
+    }
+}
+
+exit 1 if $bad;
+
+print &quot;Directory sanity check OK\n&quot;;
+
+print &quot;Starting release for OpenSSL @versions\n&quot;;
+
+if ($do_copy) {
+    foreach (@distfiles) {
+        system(&quot;cp $tmpdir/$_ $srcdir/$_&quot;);
+        die &quot;Error copying $_ to source directory!&quot; if $?;
+        system(&quot;cp $tmpdir/$_ $ftpdir/$_&quot;);
+        die &quot;Error copying $_ to ftp directory!&quot; if $?;
+    }
+    print &quot;Copied distributions files to source and ftp directories\n&quot;;
+    foreach my $serie (@series) {
+        my $tomove_oldsrc = &quot;$srcdir/old/$serie&quot;;
+        my @tomove_src =
+          map {
+            my $x = $_;
+            $x =~ s|.*/||g;
+            grep( /^$x$/, @distfiles ) ? () : $x
+          }
+          grep { -f $_ }
+          glob(&quot;$srcdir/openssl-$serie.tar.gz $srcdir/openssl-$serie?.tar.gz&quot;);
+        my $tomove_oldftp = &quot;$ftpdir/old/$serie&quot;;
+        my @tomove_ftp =
+          map {
+            my $x = $_;
+            $x =~ s|.*/||g;
+            grep( /^$x$/, @distfiles ) ? () : $x
+          }
+          grep { -f $_ }
+          glob(&quot;$ftpdir/openssl-$serie.tar.gz $ftpdir/openssl-$serie?.tar.gz&quot;);
+
+        mkdir $tomove_oldsrc
+          or die &quot;Couldn't mkdir $tomove_oldsrc : $!&quot;
+          if !-d $tomove_oldsrc;
+        mkdir $tomove_oldftp
+          or die &quot;Couldn't mkdir $tomove_oldftp : $!&quot;
+          if !-d $tomove_oldftp;
+        foreach (@tomove_src) {
+            system(&quot;mv $srcdir/$_* $tomove_oldsrc/&quot;);
+            die &quot;Error moving $_* to old source directory!&quot; if $?;
+        }
+        foreach (@tomove_ftp) {
+            system(&quot;mv $ftpdir/$_* $tomove_oldftp/&quot;);
+            die &quot;Error moving $_* to old ftp directory!&quot; if $?;
+        }
+    }
+    print
+      &quot;Moved old distributions files to source/old and ftp/old directories\n&quot;;
+}
+else {
+    print &quot;Test mode: no files copied\n&quot;;
+}
+
+foreach (@versions) {
+    my $announce   = &quot;openssl-$_.txt.asc&quot;;
+    my $annversion = $_;
+    $annversion =~ s/-pre(\d+$)/ pre release $1/;
+    my $annmail = $mail;
+    $annmail =~ s/SUBJECT/&quot;OpenSSL version $annversion published&quot;/;
+    $annmail =~ s/RECIP/openssl-project openssl-users openssl-announce/;
+    $annmail =~ s|BODY|$tmpdir/$announce|;
+
+    if ($do_mail) {
+        print &quot;Sending announcement email for OpenSSL $_...\n&quot;;
+        system(&quot;$annmail&quot;);
+        die &quot;Error sending announcement email!&quot; if $?;
+        print &quot;Don't forget to authorise the openssl-announce email.\n&quot;;
+        push @distfiles, $announce if $do_move;
+    } else {
+        print &quot;Announcement email not sent automatically\n&quot;;
+        print &quot;\nSend announcement mail manually with command:\n\n$annmail\n\n&quot;;
+        print
+&quot;When done, move the announcement file away with command:\n\nmv $tmpdir/$announce $olddir/$announce\n\n&quot;
+          if $do_move;
+    }
+}
+
+if ($do_move) {
+    foreach (@distfiles) {
+        rename( &quot;$tmpdir/$_&quot;, &quot;$olddir/$_&quot; ) || die &quot;Can't move $_: $!&quot;;
+    }
+    print &quot;Moved distribution files to old directory\n&quot;;
+}
+
+print &quot;Successful!\n&quot;;
+
diff --git a/release-tools/mkrelease.pl b/release-tools/mkrelease.pl
new file mode 100644
index 0000000..4012e4d
--- /dev/null
+++ b/release-tools/mkrelease.pl
@@ -0,0 +1,427 @@
+#! /usr/bin/env perl
+# Copyright 2010-2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+# OpenSSL release generation script.
+
+use strict;
+use warnings;
+use File::Basename;
+use lib dirname(__FILE__);
+use Module::Load::Conditional qw(can_load);
+can_load(modules =&gt; { 'OpenSSL::Query::DB' =&gt; undef });
+use OpenSSL::Query::REST;
+
+require &quot;release-check.pl&quot;;
+require &quot;release-date.pl&quot;;
+require &quot;release-git.pl&quot;;
+require &quot;release-update.pl&quot;;
+require &quot;release-version.pl&quot;;
+
+our $debug   = 0;
+our $verbose = 0;
+my @reviewers;
+my @openssl_branches;
+my $revert;
+my $pre;
+my $info_only;
+my $branch_info_only;
+my $no_clean;
+my $no_update;
+my $no_release;
+my $no_upload;
+my $bversion;
+my $ok;
+my $label;
+
+#Determine include path
+our $includepath;
+if ( -e &quot;crypto/opensslv.h&quot; ) {
+    $includepath = &quot;crypto&quot;;
+}
+else {
+    $includepath = &quot;include/openssl&quot;;
+}
+
+sub print_git_info {
+    my ( $rinfo, $branch, $s ) = @_;
+    my $version = openssl_git_expected_version( $rinfo, $branch );
+    my $last = openssl_git_last_release( $rinfo, $branch );
+    my $last_full = openssl_git_last_release( $rinfo, $branch, 1, 1 );
+
+    # Auto detect pre release if we haven't forced it.
+    $pre = $version =~ /-pre/ unless defined $pre;
+    my $next = openssl_version_next( $version, $pre );
+
+    print &quot;${s}Branch version:    $branch\n&quot;;
+    print &quot;${s}Last release:      $last\n&quot;;
+    print &quot;${s}Last full release: $last_full\n&quot;;
+    print &quot;${s}Current version:   $version\n&quot;;
+    print &quot;${s}Next release:      $next\n&quot;;
+}
+
+sub print_branch_info {
+    my ($rinfo) = @_;
+    my ( $rtags, $rbranches ) = @$rinfo;
+    print &quot;All Branch details:\n&quot;;
+    foreach (@$rbranches) {
+        print &quot;\n&quot;;
+        print_git_info( $rinfo, $_, &quot;\t&quot; );
+    }
+    print &quot;\n&quot;;
+}
+
+# Initialise git version tables, OMC database.
+my $gitinfo = openssl_git_init();
+my $query = OpenSSL::Query-&gt;new();
+
+foreach (@ARGV) {
+    if (/^--git-info$/) {
+        $info_only = 1;
+    } elsif (/^--branch-version=(.*)$/) {
+        $bversion = $1;
+    } elsif (/^--git-branch-info/) {
+        $branch_info_only = 1;
+    } elsif (/^--no-clean/) {
+        $no_clean = 1;
+    } elsif (/^--no-release/) {
+        $no_release = 1;
+    } elsif (/^--no-update/) {
+        $no_update = 1;
+    } elsif (/^--no-upload/) {
+        $no_upload = 1;
+    } elsif (/^--revert/) {
+        $revert = 1;
+    } elsif (/^--leave-pre/) {
+        $pre = 0;
+    } elsif (/^--enter-pre/) {
+        $pre = 1;
+    } elsif (/^--debug/) {
+        $debug   = 1;
+        $verbose = 1;
+    } elsif (/^--verbose/) {
+        $verbose = 1;
+    } elsif (/^--reviewer=(.*)$/) {
+	my $r = $1;
+	my $rname = $query-&gt;find_person_tag($r, 'rev');
+        die &quot;Unknown reviewer $1&quot; unless $rname;
+        push @reviewers, $rname;
+    } elsif (/^--label=(.*)$/) {
+        $label = $1;
+        if ( $label ne &quot;alpha&quot; &amp;&amp; $label ne &quot;beta&quot; ) {
+            die &quot;Invalid label&quot;;
+        }
+    } else {
+        print &quot;Uknown option $_\n&quot;;
+        exit 1;
+    }
+}
+
+if ($revert) {
+    $_ = openssl_git_current_branch();
+    print &quot;Reverting to repository version for $_\n&quot;;
+    system(&quot;git reset --hard origin/$_&quot;);
+    die &quot;Error reverting!!&quot; if $?;
+    openssl_git_delete_local_tags($_);
+    exit 0;
+}
+
+$bversion = openssl_git_branch_version() unless defined $bversion;
+
+if ($info_only) {
+    print_git_info( $gitinfo, $bversion, &quot;&quot; );
+    exit 0;
+}
+
+if ($branch_info_only) {
+    print_branch_info($gitinfo);
+    exit 0;
+}
+
+die &quot;No reviewer set!&quot; unless @reviewers;
+
+print &quot;Current branch version is $bversion\n&quot;;
+
+if ( openssl_git_check_changes() ) {
+    print &quot;ERROR: unstaged changes in current branch!\n&quot;;
+    exit 1;
+}
+
+my $expected_version = openssl_git_expected_version( $gitinfo, $bversion );
+
+# If this is first pre release there will be no releases from this branch
+# So set expected version to pre1-dev as we can't detect this from
+# tags.
+
+if ( $expected_version !~ /-pre/ &amp;&amp; openssl_check_first_pre() ) {
+    $expected_version =~ s/-dev/-pre1-dev/;
+}
+
+# Auto detect pre release if we haven't forced it.
+$pre = $expected_version =~ /-pre/ unless defined $pre;
+
+if ( !$pre &amp;&amp; defined $label ) {
+    die &quot;Not a pre-release but a label has been defined&quot;;
+}
+if ( $pre &amp;&amp; !defined $label ) {
+    die &quot;This is a pre-release but a label has not been defined&quot;;
+}
+
+my $last_version = openssl_git_last_release( $gitinfo, $bversion, 1, 1 );
+my $last_branch_release = openssl_git_last_release( $gitinfo, $bversion, 1 );
+my $next_version = openssl_version_next( $expected_version, $pre );
+
+print &quot;Branch feature version:      $bversion\n&quot;;
+print &quot;Last release on this branch: $last_branch_release\n&quot;;
+print &quot;Current branch version       $expected_version\n&quot;;
+print &quot;Next release version         $next_version\n&quot;;
+print &quot;Last full release version    $last_version\n&quot;;
+
+$ok = openssl_check_all( $expected_version, $last_version );
+
+print &quot;Branch sanity check: &quot; . ( $ok ? &quot;OK&quot; : &quot;NOT OK&quot; ) . &quot;\n&quot;;
+
+if ( $ok == 0 ) {
+    print &quot;Sanity check failed, cannot continue\n&quot;;
+    exit 1;
+}
+
+if ( !$no_clean ) {
+    print &quot;Cleaning directory\n&quot;;
+    system(&quot;git clean -x -d -f&quot;);
+    die &quot;Error cleaning directory&quot; if $?;
+}
+
+openssl_git_make_update(@reviewers) unless $no_update;
+
+$expected_version = openssl_version_next( $expected_version, $pre );
+
+my $date = openssl_current_date() unless $expected_version =~ /-pre1-dev/;
+
+print &quot;Updating versions to $expected_version\n&quot;;
+
+openssl_update_all( $expected_version, $date, $label );
+
+$ok = openssl_check_all( $expected_version, $last_version, $date );
+
+print &quot;Changes sanity check: &quot; . ( $ok ? &quot;OK&quot; : &quot;NOT OK&quot; ) . &quot;\n&quot;;
+
+if ( $ok == 0 ) {
+    print &quot;Release sanity check failed, cannot continue\n&quot;;
+    exit 1;
+}
+
+print &quot;Committing changes:\n&quot;;
+
+# If we changed from -dev to -pre1-dev a dev version is
+# entering pre release. Just commit changes without a release.
+
+if ( $expected_version =~ /pre1-dev/ ) {
+    my $main_version = $expected_version;
+    $main_version =~ s/-pre1-dev//;
+    openssl_git_commit( &quot;OpenSSL $main_version is now in pre release&quot;,
+        @reviewers );
+    die &quot;Error comitting changes!&quot; if $?;
+    print &quot;Version set to $expected_version, exiting\n&quot;;
+    exit 0;
+}
+
+openssl_git_commit( &quot;Prepare for $expected_version release&quot;, @reviewers );
+die &quot;Error comitting release changes!&quot; if $?;
+
+my $tag = &quot;OpenSSL_$expected_version&quot;;
+my $tagkey =
+  defined( $ENV{OPENSSL_GPG_KEYID} ) ? &quot; -u $ENV{OPENSSL_GPG_KEYID}&quot; : &quot; -s&quot;;
+
+$tag =~ tr/\./_/;
+
+print
+  &quot;Tagging release with tag $tag (you will need to provide a pass phrase)\n&quot;;
+
+system(&quot;git tag$tagkey -m \&quot;OpenSSL $expected_version release tag\&quot; $tag&quot;);
+die &quot;Error tagging release!&quot; if $?;
+
+my $TAR = defined( $ENV{OPENSSL_TAR} ) ? &quot;TAR=$ENV{OPENSSL_TAR}&quot; : &quot;&quot;;
+
+if ( !$no_release ) {
+    print &quot;Generating release tarball.\n&quot;;
+    my $openssl = $ENV{&quot;OPENSSL&quot;} // &quot;openssl&quot;;
+    my $gpgkeyid =
+      defined( $ENV{OPENSSL_GPG_KEYID} ) ? &quot; -u $ENV{OPENSSL_GPG_KEYID}&quot; : &quot;&quot;;
+    my $gpg    = $ENV{&quot;OPENSSL_GPG&quot;}     // &quot;gpg$gpgkeyid&quot;;
+    my $gpgtar = $ENV{&quot;OPENSSL_GPG_TAR&quot;} // &quot;$gpg --use-agent -sba&quot;;
+    my $gpgann = $ENV{&quot;OPENSSL_GPG_ANNOUNCE&quot;}
+      // &quot;$gpg --use-agent -sta --clearsign&quot;;
+    my $tarfile = &quot;openssl-${expected_version}.tar.gz&quot;;
+    system(&quot;(./config; make $TAR dist) &gt;../$tarfile.log 2&gt;&amp;1&quot;);
+    die &quot;Error generating release!&quot; if $?;
+    die &quot;Can't find tarball!!&quot; unless -f &quot;../$tarfile&quot;;
+
+    my $length = -s &quot;../$tarfile&quot;;
+    print &quot;Creating hash files\n&quot;;
+    my $sha1hash = `$openssl sha1 &lt; ../$tarfile`;
+    chomp $sha1hash;
+    $sha1hash =~ s/^.*=\s//;
+    die &quot;invalid hash&quot; unless $sha1hash =~ /[0-9a-f]{20}/;
+    my $sha256hash = `$openssl sha256 &lt; ../$tarfile`;
+    chomp $sha256hash;
+    $sha256hash =~ s/^.*=\s//;
+    die &quot;invalid hash&quot; unless $sha256hash =~ /[0-9a-f]{20}/;
+    open OUT, &quot;&gt;../$tarfile.sha1&quot;;
+    print OUT $sha1hash . &quot;\n&quot;;
+    close OUT;
+    open OUT, &quot;&gt;../$tarfile.sha256&quot;;
+    print OUT $sha256hash . &quot;\n&quot;;
+    close OUT;
+    print &quot;Creating PGP signature:\n&quot;;
+    unlink(&quot;../${tarfile}.asc&quot;);
+    system(&quot;$gpgtar ../$tarfile&quot;);
+    die &quot;Error creating signature&quot; if $?;
+
+    my $anntxt = &quot;../openssl-${expected_version}.txt&quot;;
+
+    open OUT, &quot;&gt;$anntxt&quot;;
+    if ( $expected_version =~ /-pre/ ) {
+
+        # Note the variable name is the same length as the real
+        # version so the announcement can be made to look pretty.
+        # If we ever go to pre10 it will be one character longer...
+        my $openssl_ver = $expected_version;
+        $openssl_ver =~ s/^(.*)-pre(\d+)$/$1 pre release $2/;
+        my $fvers = $expected_version;
+        $fvers =~ s/-pre\d+//;
+        print OUT &lt;&lt;EOF;
+
+   OpenSSL version $openssl_ver ($label)
+   ===========================================
+
+   OpenSSL - The Open Source toolkit for SSL/TLS
+   <A HREF="https://www.openssl.org/">https://www.openssl.org/</A>
+
+   OpenSSL $fvers is currently in $label. OpenSSL $openssl_ver has now
+   been made available. For details of changes and known issues see the
+   release notes at:
+
+        <A HREF="https://www.openssl.org/news/openssl-$bversion-notes.html">https://www.openssl.org/news/openssl-$bversion-notes.html</A>
+
+   Note: This OpenSSL pre-release has been provided for testing ONLY.
+   It should NOT be used for security critical purposes.
+
+   The $label release is available for download via HTTP and FTP from the
+   following master locations (you can find the various FTP mirrors under
+   <A HREF="https://www.openssl.org/source/mirror.html">https://www.openssl.org/source/mirror.html</A>):
+
+     * <A HREF="https://www.openssl.org/source/">https://www.openssl.org/source/</A>
+     * <A HREF="ftp://ftp.openssl.org/source/">ftp://ftp.openssl.org/source/</A>
+
+   The distribution file name is:
+
+    o $tarfile
+      Size: $length
+      SHA1 checksum: $sha1hash
+      SHA256 checksum: $sha256hash
+
+   The checksums were calculated using the following commands:
+
+    openssl sha1 $tarfile
+    openssl sha256 $tarfile
+
+   Please download and check this $label release as soon as possible.
+   To report a bug, open an issue on GitHub:
+
+    <A HREF="ttps://github.com/openssl/openssl/issues">ttps://github.com/openssl/openssl/issues</A>
+
+   Please check the release notes and mailing lists to avoid duplicate
+   reports of known issues.
+
+   Yours,
+
+   The OpenSSL Project Team.
+
+EOF
+    } else {
+        # Using $avers so its length is similar to a real version
+        # length so it's easier to make the announcement look pretty.
+        my $avers = $expected_version;
+        print OUT &lt;&lt;EOF;
+
+   OpenSSL version $avers released
+   ===============================
+
+   OpenSSL - The Open Source toolkit for SSL/TLS
+   <A HREF="https://www.openssl.org/">https://www.openssl.org/</A>
+
+   The OpenSSL project team is pleased to announce the release of
+   version $avers of our open source toolkit for SSL/TLS. For details
+   of changes and known issues see the release notes at:
+
+        <A HREF="https://www.openssl.org/news/openssl-$bversion-notes.html">https://www.openssl.org/news/openssl-$bversion-notes.html</A>
+
+   OpenSSL $avers is available for download via HTTP and FTP from the
+   following master locations (you can find the various FTP mirrors under
+   <A HREF="https://www.openssl.org/source/mirror.html">https://www.openssl.org/source/mirror.html</A>):
+
+     * <A HREF="https://www.openssl.org/source/">https://www.openssl.org/source/</A>
+     * <A HREF="ftp://ftp.openssl.org/source/">ftp://ftp.openssl.org/source/</A>
+
+   The distribution file name is:
+
+    o $tarfile
+      Size: $length
+      SHA1 checksum: $sha1hash
+      SHA256 checksum: $sha256hash
+
+   The checksums were calculated using the following commands:
+
+    openssl sha1 $tarfile
+    openssl sha256 $tarfile
+
+   Yours,
+
+   The OpenSSL Project Team.
+
+EOF
+
+    }
+
+    close OUT;
+    unlink(&quot;${anntxt}.asc&quot;);
+    system(&quot;$gpgann $anntxt&quot;);
+    die &quot;Cannot sign announcement file!&quot; if $?;
+    die &quot;Signature file not found!&quot; unless -f &quot;$anntxt.asc&quot;;
+
+    if ( !$no_upload ) {
+        my $scp     = $ENV{OPENSSL_SCP}      // &quot;scp&quot;;
+        my $scphost = $ENV{OPENSSL_SCP_HOST} // &quot;dev.openssl.org&quot;;
+        my $scpdir  = $ENV{OPENSSL_SCP_DIR}  // &quot;$scphost:~openssl/dist/new&quot;;
+        print &quot;Uploading release files\n&quot;;
+        system(
+&quot;$scp ../$tarfile ../$tarfile.sha1 ../$tarfile.sha256 ../$tarfile.asc $anntxt.asc ${scpdir}&quot;
+        );
+        die &quot;Error uploading release files&quot; if $?;
+    }
+
+}
+
+$last_version = $expected_version unless $pre;
+$expected_version = openssl_version_next( $expected_version, $pre );
+
+print &quot;Updating versions to $expected_version\n&quot;;
+
+openssl_update_all($expected_version);
+
+$ok = openssl_check_all( $expected_version, $last_version );
+
+print &quot;Sanity check: &quot; . ( $ok ? &quot;OK&quot; : &quot;NOT OK&quot; ) . &quot;\n&quot;;
+
+if ( $ok == 0 ) {
+    print &quot;Sanity check failed, cannot continue\n&quot;;
+    exit 1;
+}
+
+openssl_git_commit( &quot;Prepare for $expected_version&quot;, @reviewers );
+die &quot;Error comitting release changes!&quot; if $?;
diff --git a/release-tools/release-check.pl b/release-tools/release-check.pl
new file mode 100644
index 0000000..91ee7c0
--- /dev/null
+++ b/release-tools/release-check.pl
@@ -0,0 +1,215 @@
+#! /usr/bin/env perl
+# Copyright 2010-2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+use strict;
+
+sub check_str {
+    my ( $message, $expected, $value, $pok ) = @_;
+    die &quot;Bad checkstr values for $message&quot;
+      if !defined $value || !defined $expected;
+    if ( $value ne $expected ) {
+        print
+          &quot;$message: check failed, expecting \&quot;$expected\&quot;, got \&quot;$value\&quot;!!\n&quot;;
+        $$pok = 0;
+    } elsif ($main::debug) {
+        print &quot;$message: checking \&quot;$value\&quot; against \&quot;$expected\&quot;\n&quot;;
+    }
+}
+
+# Check syntax of README file.
+
+sub openssl_check_README {
+    my ( $version, $indate ) = @_;
+    my $ok   = 1;
+    my $date = openssl_date($indate);
+    open( IN, &quot;README&quot; ) || die &quot;Can't open README&quot;;
+    while (&lt;IN&gt;) {
+        if (/^.*OpenSSL\s+(\S+)\s+(\([[:alpha:]]+\)\s+)?(.*)$/) {
+            check_str( &quot;README version&quot;, $version, $1, \$ok );
+            if ( defined $indate ) {
+                check_str( &quot;README date&quot;, $date, $3, \$ok );
+            }
+            close IN;
+            return $ok;
+        }
+    }
+    close IN;
+    print STDERR &quot;Invalid syntax in README\n&quot;;
+    return 0;
+}
+
+sub openssl_check_NEWS {
+    my ( $version, $prev, $indate ) = @_;
+    my $date = openssl_date( $version =~ /-pre/ ? undef : $indate );
+    my $ok = 1;
+    if ( $date =~ /XXX/ ) {
+        if ( $version =~ /-pre/ ) {
+            $date = &quot;in pre-release&quot;;
+        } else {
+            $date = &quot;under development&quot;;
+        }
+    }
+    $version =~ s/-dev$//;
+    $version =~ s/-pre.*$//;
+    open( IN, &quot;NEWS&quot; ) || die &quot;Can't open NEWS&quot;;
+
+    while (&lt;IN&gt;) {
+        if (
+/^  Major changes between OpenSSL (\S+) and OpenSSL (\S+)\s+\[0?(.*)\]/
+          )
+        {
+            check_str( &quot;NEWS previous version&quot;, $prev,    $1, \$ok );
+            check_str( &quot;NEWS version&quot;,          $version, $2, \$ok );
+            check_str( &quot;NEWS date&quot;,             $date,    $3, \$ok );
+            close IN;
+            return $ok;
+        }
+    }
+    close IN;
+    print STDERR &quot;Invalid syntax in NEWS\n&quot;;
+    return 0;
+}
+
+sub openssl_check_CHANGES {
+    my ( $version, $prev, $indate ) = @_;
+    my $date = openssl_date( $version =~ /-pre/ ? undef : $indate );
+    my $ok = 1;
+    $version =~ s/-dev$//;
+    $version =~ s/-pre.*$//;
+    open( IN, &quot;CHANGES&quot; ) || die &quot;Can't open CHANGES&quot;;
+
+    while (&lt;IN&gt;) {
+        if (/^ Changes between (\S+) and (\S+)\s+\[0?(.*)\]/) {
+            check_str( &quot;CHANGES previous version&quot;, $prev,    $1, \$ok );
+            check_str( &quot;CHANGES version&quot;,          $version, $2, \$ok );
+            check_str( &quot;CHANGES date&quot;,             $date,    $3, \$ok );
+            close IN;
+            return $ok;
+        }
+    }
+    close IN;
+    print STDERR &quot;Invalid syntax in CHANGES\n&quot;;
+    return 0;
+}
+
+sub openssl_check_version_h {
+    my ( $version, $indate ) = @_;
+    my ( $hex_done, $fips_done, $version_done );
+    my $hexversion   = openssl_version_hex($version);
+    my $ok           = 1;
+    my $version_fips = $version . &quot;-fips&quot;;
+    $version_fips =~ s/-dev-fips/-fips-dev/;
+    my $date = openssl_date($indate);
+    open( IN, &quot;$main::includepath/opensslv.h&quot; ) || die &quot;Can't open opensslv.h&quot;;
+
+    while (&lt;IN&gt;) {
+        if (/OPENSSL_VERSION_NUMBER\s+(0x[0-9a-f]+)L/) {
+            check_str( &quot;opensslv.h: HEX version&quot;, $hexversion, $1, \$ok );
+            $hex_done = 1;
+        } elsif (
+/OPENSSL_VERSION_TEXT\s+\&quot;OpenSSL (\S*fips\S*)\s+(\([[:alpha:]]+\)\s+)?(.*)\&quot;/
+          )
+        {
+            check_str( &quot;opensslv.h: FIPS version&quot;, $version_fips, $1, \$ok );
+            check_str( &quot;opensslv.h: FIPS date&quot;,    $date,         $3, \$ok );
+            $fips_done = 1;
+        } elsif (
+/OPENSSL_VERSION_TEXT\s+\&quot;OpenSSL (\S*)\s+(\([[:alpha:]]+\)\s+)?(.*)\&quot;/
+          )
+        {
+            check_str( &quot;opensslv.h: version&quot;, $version, $1, \$ok );
+            check_str( &quot;opensslv.h: date&quot;,    $date,    $3, \$ok );
+            $version_done = 1;
+        }
+        if ( $hex_done &amp;&amp; $fips_done &amp;&amp; $version_done ) {
+            close IN;
+            return $ok;
+        }
+    }
+    print STDERR &quot;Invalid syntax in opensslv.h\n&quot;;
+    close IN;
+    return 0;
+}
+
+sub openssl_check_spec {
+    my ($version) = @_;
+    my $ok = 1;
+    $version =~ s/-dev$//;
+    $version =~ s/-pre.*$//;
+    open( IN, &quot;openssl.spec&quot; ) || die &quot;Can't open openssl.spec&quot;;
+    while (&lt;IN&gt;) {
+        if (/^Version:\s+(\S+)$/) {
+            check_str( &quot;openssl.spec version&quot;, $version, $1, \$ok );
+            close IN;
+            return $ok;
+        }
+    }
+    close IN;
+    print STDERR &quot;Invalid syntax in README\n&quot;;
+    return 0;
+}
+
+sub print_ok {
+    my ( $file, $ok ) = @_;
+    print &quot;File: $file &quot; . ( $ok ? &quot;OK&quot; : &quot;NOT OK!!&quot; ) . &quot;\n&quot;
+      if ($main::verbose);
+}
+
+sub openssl_check_all {
+    my ( $version, $last_version, $date ) = @_;
+
+    my $readme_ok = openssl_check_README( $version, $date );
+
+    print_ok( &quot;README&quot;, $readme_ok );
+
+    my $changes_ok = openssl_check_CHANGES( $version, $last_version, $date );
+
+    print_ok( &quot;CHANGES&quot;, $changes_ok );
+
+    my $news_ok = openssl_check_NEWS( $version, $last_version, $date );
+
+    print_ok( &quot;NEWS&quot;, $news_ok );
+
+    my $v_h_ok = openssl_check_version_h( $version, $date );
+
+    print_ok( &quot;opensslv.h&quot;, $v_h_ok );
+
+    # Newer versions don't have openssl.spec
+    my $spec_ok = 1;
+    if ( -f &quot;openssl.spec&quot; ) {
+        $spec_ok = openssl_check_spec($version);
+
+        print_ok( &quot;openssl.spec&quot;, $spec_ok );
+    }
+
+    return $readme_ok &amp;&amp; $changes_ok &amp;&amp; $news_ok &amp;&amp; $v_h_ok &amp;&amp; $spec_ok;
+}
+
+# If there are no tagged releases for the current version
+# and we are in pre release mode then either we are just entering
+# pre release and the next version will be pre1-dev or we are already
+# at pre1-dev and we need to do a release of pre1.
+# Check opensslv.h to determine which
+
+sub openssl_check_first_pre {
+    open( IN, &quot;$main::includepath/opensslv.h&quot; ) || die &quot;Can't open opensslv.h&quot;;
+
+    while (&lt;IN&gt;) {
+        if (/OPENSSL_VERSION_TEXT\s+\&quot;OpenSSL \S*\s+.*\&quot;/) {
+            close IN;
+
+            # Ignore -fips in string
+            s/-fips//;
+            return /pre1-dev/;
+        }
+    }
+    close IN;
+    die &quot;Invalid sysntax in opensslv.h&quot;;
+}
+
+return 1;
diff --git a/release-tools/release-date.pl b/release-tools/release-date.pl
new file mode 100644
index 0000000..c5b5c38
--- /dev/null
+++ b/release-tools/release-date.pl
@@ -0,0 +1,64 @@
+#! /usr/bin/env perl
+# Copyright 2010-2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+# Return date into a form suitable for the FAQ, version file and
+# CHANGES file entries. Optionally can be passed date in the form
+# mm/dd/yyyy
+
+sub openssl_date {
+    my ($datestr) = @_;
+    my ( $mday, $mon, $year );
+
+    if ( defined $datestr ) {
+        if ( $datestr =~ /(\d+)\/(\d+)\/(\d+)/ ) {
+            $mday = $1;
+            $mon  = $2;
+            $year = $3;
+            $mon--;
+        } else {
+            die &quot;Invalid date syntax $datestr, expecting mm/dd/yyyy&quot;;
+        }
+    } else {
+        return ( &quot;xx XXX xxxx&quot;, undef, undef ) if wantarray;
+        return &quot;xx XXX xxxx&quot;;
+    }
+
+    my $mdsuff;
+    if ( $mday % 10 &gt; 0 &amp;&amp; $mday % 10 &lt;= 3 &amp;&amp; ( $mday &lt; 10 || $mday &gt; 20 ) ) {
+        my @mday_ord = qw(st nd rd);
+        $mdsuff = $mday_ord[ $mday % 10 - 1 ];
+    } else {
+        $mdsuff = &quot;th&quot;;
+    }
+
+    my @mnames =
+      qw(January February March April May June July August September October November December);
+
+    my $mname = $mnames[$mon];
+    my $mname_short = substr $mname, 0, 3;
+
+    my $date_ch = sprintf &quot;%d %s %d&quot;, $mday, $mname_short, $year;
+    return $date_ch unless wantarray;
+    my $date_ab = sprintf &quot;%s %d%s, %d&quot;, $mname_short, $mday, $mdsuff, $year;
+    my $date_full = sprintf &quot;%-9s %2d%s, %d&quot;, $mname, $mday, $mdsuff, $year;
+
+    return ( $date_ch, $date_ab, $date_full );
+
+}
+
+# Return current date in dd/mm/yyyy format suitable to passing into
+# openssl_date().
+
+sub openssl_current_date {
+    my ( $mday, $mon, $year ) = (localtime)[ 3 .. 5 ];
+    $year += 1900;
+    $mon++;
+    return &quot;$mday/$mon/$year&quot;;
+}
+
+return 1;
diff --git a/release-tools/release-git.pl b/release-tools/release-git.pl
new file mode 100644
index 0000000..2b6ac1a
--- /dev/null
+++ b/release-tools/release-git.pl
@@ -0,0 +1,164 @@
+#! /usr/bin/env perl
+# Copyright 2010-2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+use strict;
+use warnings;
+
+# OpenSSL git version utilities.
+
+# Retrieve list of branches and release tags in a reference usable by other
+# functions.
+
+sub openssl_git_init {
+    my @tmpbranches =
+      grep { chomp; s|^\s+origin/OpenSSL_(\w*\d)-stable$|$1|; } `git branch -r`;
+    die &quot;Error retrieving branch details!&quot; if $?;
+
+    # Create initial dev version entry: lowest possible version for
+    # branch which will be accurate if no releases have take place.
+    my @branches;
+    foreach ( sort @tmpbranches ) {
+        tr/_/\./;
+        next if /^0/ &amp;&amp; $_ ne &quot;0.9.8&quot;;
+        push @branches, $_;
+    }
+
+    # Create list of tags
+    my @rtags = grep { chomp; s/OpenSSL_(\d.*)$/$1/; } `git tag`;
+    die &quot;Error retrieving tag details!&quot; if $?;
+    my @tags;
+    foreach (@rtags) {
+
+        # Skip if tag has - and it isn't pre
+        next if ( /-/ &amp;&amp; !/-pre\d+$/ );
+        tr/_/\./;
+        next if /^0/ &amp;&amp; !/^0.9.8/;
+        push @tags, $_;
+    }
+    my $aref = [ \@tags, \@branches ];
+    return $aref;
+}
+
+# Return last release number on supplied branch.
+# If $nopre is set, skip pre releases, if $prev set
+# return last release on previous branch if no release
+# on current branch.
+
+sub openssl_git_last_release {
+    my ( $rinfo, $branch, $nopre, $prev ) = @_;
+    my ( $rtag, $rbranch ) = @$rinfo;
+    my $brhex = openssl_version_branch_hex($branch);
+    my $rv    = &quot;&quot;;
+    my $rvhex = &quot;&quot;;
+    foreach (@$rtag) {
+        next if ( $nopre &amp;&amp; /-pre/ );
+        my $taghex  = openssl_version_hex($_);
+        my $tagbhex = openssl_version_branch_hex($_);
+
+        # Is tag for current branch?
+        if ( $tagbhex ne $brhex ) {
+
+            # Discard if only want current branch or greater
+            # than current branch
+            next if ( !$prev || $tagbhex gt $brhex );
+        }
+
+        # If release is later than last value replace.
+        if ( $taghex gt $rvhex ) {
+            $rv    = $_;
+            $rvhex = openssl_version_hex($rv);
+        }
+    }
+    return $rv eq &quot;&quot; ? &quot;none&quot; : $rv;
+}
+
+sub openssl_git_current_branch {
+
+    # Current branch
+    $_ = `git rev-parse --abbrev-ref HEAD`;
+    die &quot;Can't get current branch!&quot; if $?;
+    chomp;
+    return $_;
+}
+
+sub openssl_git_branch_version {
+    ($_) = @_;
+    $_ = openssl_git_current_branch() unless defined $_;
+    die &quot;Unexpected  branch name $_&quot; unless s/OpenSSL_//;
+    tr /_/\./;
+    die &quot;Unexpected  branch name $_&quot; unless s/-stable$//;
+    return $_;
+}
+
+sub openssl_git_expected_version {
+    my ( $rinfo, $branch ) = @_;
+    $branch = openssl_git_major_version() unless defined $branch;
+    my $rv = openssl_git_last_release( $rinfo, $branch );
+    return $branch .= &quot;-dev&quot; if $rv eq &quot;none&quot;;
+    return openssl_version_next($rv);
+}
+
+sub openssl_git_check_changes {
+
+    # For some reason this is unreliable if you use --quiet ...
+    system(&quot;git diff --exit-code &gt;/dev/null&quot;);
+    return 0 if $? == 0;
+    return 1 if $? == 256;
+    die &quot;Unexpected status $?&quot;;
+}
+
+sub openssl_git_make_update {
+    print &quot;Configuring system\n&quot;;
+    system(&quot;perl Configure gcc &gt;/dev/null 2&gt;&amp;1&quot;);
+    die &quot;Error configuring system&quot; if $?;
+
+    print &quot;Doing make update\n&quot;;
+    system(&quot;make update &gt;/dev/null 2&gt;&amp;1&quot;);
+    die &quot;make update error&quot; if $?;
+    if ( openssl_git_check_changes() ) {
+        print &quot;Source modified, committing changes\n&quot;;
+        openssl_git_commit( &quot;make update&quot;, @_ );
+        die &quot;Error committing update&quot; if $?;
+    } else {
+        print &quot;No changes\n&quot;;
+    }
+    system(&quot;find . -name Makefile.save -exec rm \\\{\\\} \\\;&quot;);
+    die &quot;Error removing Makefile.save files&quot; if $?;
+}
+
+sub openssl_git_delete_local_tags {
+    my ($branch) = @_;
+    $branch =~ s/-stable//;
+    my @tags = grep { chomp; } `git tag -l $branch\*`;
+    my @rtags =
+      grep { chomp; s|^.*refs/tags/||; } `git ls-remote --tags origin`;
+    my %rtaghash;
+    foreach (@rtags) {
+        $rtaghash{$_} = 1;
+    }
+    foreach (@tags) {
+        if ( !defined $rtaghash{$_} ) {
+            print &quot;Deleting local tag $_\n&quot; if $main::verbose;
+            system(&quot;git tag -d $_&quot;);
+        }
+    }
+}
+
+sub openssl_git_commit {
+    my @args = ( &quot;git&quot;, &quot;commit&quot;, &quot;-a&quot; );
+    my ( $message, @reviewers ) = @_;
+    $message .= &quot;\n\n&quot;;
+    foreach (@reviewers) {
+        $message .= &quot;Reviewed-by: $_\n&quot;;
+    }
+    push @args, &quot;-m&quot;, &quot;$message&quot;;
+    system(@args);
+    die &quot;Error committing update&quot; if $?;
+}
+
+return 1;
diff --git a/release-tools/release-update.pl b/release-tools/release-update.pl
new file mode 100644
index 0000000..a8d5687
--- /dev/null
+++ b/release-tools/release-update.pl
@@ -0,0 +1,153 @@
+#! /usr/bin/env perl
+# Copyright 2010-2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+use strict;
+use warnings;
+
+sub openssl_update_file {
+    my $fref     = pop @_;
+    my $file     = pop @_;
+    my $file_new = $file . &quot;.new&quot;;
+    my $finished = 0;
+    open( IN,  &quot;$file&quot; )      || die &quot;Can't open $file&quot;;
+    open( OUT, &quot;&gt;$file_new&quot; ) || die &quot;Can't open $file_new&quot;;
+    while (&lt;IN&gt;) {
+        $finished = &amp;$fref(@_) unless $finished;
+        print OUT;
+    }
+    close IN;
+    close OUT;
+    unlink $file;
+    rename $file_new, $file;
+    print &quot;Updated $file\n&quot; if $main::verbose;
+}
+
+sub openssl_update_README {
+    my ( $version, $indate, $label ) = @_;
+    my $date   = openssl_date($indate);
+    my $update = sub {
+        if (/^.*OpenSSL/) {
+            $_ = &quot; OpenSSL $version&quot;;
+            $_ .= &quot; $label&quot; if ( defined $label );
+            $_ .= &quot; $date&quot;  if ( defined $indate );
+            $_ .= &quot;\n&quot;;
+            return 1;
+        }
+        return 0;
+    };
+    openssl_update_file( @_, &quot;README&quot;, $update );
+}
+
+sub openssl_update_CHANGES {
+    my ( $version, $indate ) = @_;
+    my $date = openssl_date($indate);
+    $version =~ s/-dev//;
+    my $update = sub {
+        if (/^ Changes between \S+ and (\S+)\s+\[0?(.*)\]/) {
+            my $chversion = $1;
+            my $chdate    = $2;
+            if ( defined $indate ) {
+                s/$chdate/$date/;
+            } else {
+                my $newchanges = &lt;&lt;END;
+ Changes between $chversion and $version [xx XXX xxxx]
+
+  *)
+
+END
+                $_ = $newchanges . $_;
+            }
+            return 1;
+        }
+        return 0;
+    };
+    openssl_update_file( @_, &quot;CHANGES&quot;, $update );
+}
+
+sub openssl_update_NEWS {
+    my ( $version, $indate ) = @_;
+    my $date;
+    if ( $version =~ /-pre1-dev/ ) {
+        $date   = &quot;in pre-release&quot;;
+        $indate = &quot;&quot;;
+    } elsif ( $version =~ /-pre/ ) {
+        return 1;
+    } else {
+        $date = openssl_date($indate);
+    }
+    $version =~ s/-dev//;
+    my $update = sub {
+        if (
+/^  Major changes between OpenSSL \S+ and OpenSSL (\S+)\s+\[0?(.*)\]/
+          )
+        {
+            my $chversion = $1;
+            my $chdate    = $2;
+            if ( defined $indate ) {
+                s/$chdate/$date/;
+            } else {
+                my $newchanges = &lt;&lt;END;
+  Major changes between OpenSSL $chversion and OpenSSL $version [under development]
+
+      o
+
+END
+                $_ = $newchanges . $_;
+            }
+            return 1;
+        }
+        return 0;
+    };
+    openssl_update_file( @_, &quot;NEWS&quot;, $update );
+}
+
+sub openssl_update_version_h {
+    my ( $version, $indate, $label ) = @_;
+    my $hexversion   = openssl_version_hex($version);
+    my $date         = openssl_date($indate);
+    my $version_fips = $version . &quot;-fips&quot;;
+    $version_fips =~ s/-dev-fips/-fips-dev/;
+    if ( !defined $label ) {
+        $label = &quot;&quot;;
+    }
+    my $update = sub {
+        if (/(#\s*define\s+OPENSSL_VERSION_NUMBER\s+)/) {
+            $_ = &quot;${1}${hexversion}L\n&quot;;
+        } elsif (/(#\s*define\s+OPENSSL_VERSION_TEXT\s+).*fips/) {
+            $_ = &quot;${1}\&quot;OpenSSL $version_fips $label $date\&quot;\n&quot;;
+        } elsif (/(#\s*define\s+OPENSSL_VERSION_TEXT\s+)/) {
+            $_ = &quot;${1}\&quot;OpenSSL $version $label $date\&quot;\n&quot;;
+        }
+        return 0;
+    };
+    openssl_update_file( @_, &quot;$main::includepath/opensslv.h&quot;, $update );
+}
+
+sub openssl_update_spec {
+    my ($version) = @_;
+    $version =~ s/-dev$//;
+    my $update = sub {
+        s/^Version:\s+(\S+)$/Version: $version/;
+    };
+    openssl_update_file( @_, &quot;openssl.spec&quot;, $update );
+}
+
+sub openssl_update_all {
+    my ( $version, $date, $label ) = @_;
+    my $ispre = $version =~ /-pre/;
+    if ( defined $label ) {
+        $label = &quot;($label)&quot;;
+    }
+    openssl_update_version_h( $version, $date, $label );
+    openssl_update_spec($version) if ( !$ispre &amp;&amp; -f &quot;openssl.spec&quot; );
+    openssl_update_README( $version, $date, $label );
+    openssl_update_CHANGES( $version, $date ) unless $ispre;
+    openssl_update_NEWS( $version, $date );
+}
+
+return 1;
diff --git a/release-tools/release-version.pl b/release-tools/release-version.pl
new file mode 100644
index 0000000..3e163b0
--- /dev/null
+++ b/release-tools/release-version.pl
@@ -0,0 +1,179 @@
+#! /usr/bin/env perl
+# Copyright 2010-2018 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+use strict;
+use warnings;
+
+# OpenSSL version utility functions.
+
+# Convert string version to hex format
+# usage is version_hex($version_string, $tag)
+# where &quot;tag&quot; is 1 if the version comes from a git tag.
+# Return version in hex format.
+
+sub openssl_version_hex {
+    my ( $version, $tag ) = @_;
+    my $ov = $version;
+    $tag = $version =~ /_/ unless defined $tag;
+    $version =~ tr/_/\./ if $tag;
+
+    # Separate version string into fields and convert each one.
+
+    if ( !( $version =~ /([\d])\.([\d]+).([\d]+)(.*)$/ ) ) {
+        die &quot;Invalid version syntax \&quot;$version\&quot;&quot;;
+    }
+    my $M    = $1;
+    my $NN   = sprintf &quot;%02x&quot;, $2;
+    my $FF   = sprintf &quot;%02x&quot;, $3;
+    my $rest = $4;
+
+    if ( length $M &gt; 1 || length $NN &gt; 2 || length $FF &gt; 2 ) {
+        die &quot;Invalid version syntax&quot;;
+    }
+
+    my ( $PP, $S );
+
+    if ( $rest eq &quot;&quot; ) {
+        $PP = &quot;00&quot;;
+        $S  = &quot;f&quot;;
+    } else {
+        $S = &quot;&quot;;
+        if ( $rest =~ s/-dev$// ) {
+            $S = &quot;0&quot;;
+        }
+
+        # Note pre release development versions of the form -preX-dev
+        # version is same for pre release and development versions
+        # So check for -preX after we have stripped off any
+        # -dev above.
+        if ( $rest =~ s/-pre([\d]+)$// ) {
+            $S = sprintf &quot;%x&quot;, $1;
+        }
+
+        # No -dev or -pre, must be release
+        $S = &quot;f&quot; if $S eq &quot;&quot;;
+
+        if ( $rest eq &quot;&quot; ) {
+            $PP = &quot;00&quot;;
+        } elsif ( $rest =~ /^z([a-z]$)/ ) {
+            $PP = sprintf &quot;%02x&quot;, ord($1) - ord(&quot;a&quot;) + 26;
+        } elsif ( $rest =~ /(^[a-z]$)/ ) {
+            $PP = sprintf &quot;%02x&quot;, ord($1) - ord(&quot;a&quot;) + 1;
+        } else {
+            die &quot;Invalid version syntax: \&quot;$ov\&quot;&quot;;
+        }
+    }
+
+    if ( length $S &gt; 1 || length $PP &gt; 2 ) {
+        die &quot;Invalid version syntax&quot;;
+    }
+
+    return &quot;0x$M$NN$FF$PP$S&quot;;
+
+}
+
+# Convert hex format to string
+# Usage is version_str($hex_version), returns version as a string.
+
+sub openssl_version_str {
+    my ($hexversion) = @_;
+    my ( $chk, $M, $NN, $FF, $PP, $S ) = unpack &quot;A2AA2A2A2A&quot;, $hexversion;
+    die &quot;Bad hex version $hexversion&quot; if $chk ne &quot;0x&quot; || $S eq &quot;&quot;;
+    my $version_str = hex($M) . &quot;.&quot; . hex($NN) . &quot;.&quot; . hex($FF);
+
+    if ( $PP ne &quot;00&quot; ) {
+        my $hex_PP = hex($PP);
+        if ( $hex_PP &gt; 25 ) {
+            $version_str .= &quot;z&quot;;
+            $hex_PP -= 25;
+        }
+        $version_str .= chr( $hex_PP + ord(&quot;a&quot;) - 1 );
+    }
+
+    if ( $S eq &quot;0&quot; ) {
+        $version_str .= &quot;-dev&quot;;
+    } elsif ( $S ne &quot;f&quot; ) {
+        $version_str .= &quot;-pre&quot; . hex($S);
+    }
+
+    return $version_str;
+
+}
+
+# Given a hex number work out the next version.
+# Usage is openssl_next_version($version, $pre, $dev)
+# $pre indicates whether we should use pre releases
+# $dev indicates we should use a development version.
+
+sub openssl_version_next {
+    my ( $version, $pre, $dev ) = @_;
+    my $hexversion = openssl_version_hex($version);
+    my ( $chk, $M, $NN, $FF, $PP, $S ) = unpack &quot;A2AA2A2A2A&quot;, $hexversion;
+    die &quot;Invalid syntax $version&quot; if $S eq &quot;&quot;;
+
+    # If $pre or $dev not set work out what we want.
+    $dev = $version !~ /-dev/ unless defined $dev;
+    $pre = $version =~ /-pre/ unless defined $pre;
+
+    # If we want a release then just need to get rid of &quot;-dev&quot; part.
+    #
+    if ( $dev == 0 ) {
+        die &quot;Expecting a development version!!&quot; if $version !~ /-dev/;
+
+        # NB version number is identical for pre and pre development.
+        # So just strip out &quot;-dev&quot; part.
+        $version =~ s/-dev//;
+
+        # Special case: if we are going from X.Y.Z-dev and using pre releases
+        # next version is X.Y.Z-pre1-dev and this wont be a release,
+        # just changing version numbers for beginning of pre releases.
+        $version .= &quot;-pre1-dev&quot; if $pre &amp;&amp; $S eq &quot;0&quot;;
+
+        # If moving out of pre release return full release
+        $version =~ s/-pre.*$// unless $pre;
+        return $version;
+    }
+    die &quot;Not expecting a development version!!&quot; if $version =~ /-dev/;
+
+    # If a pre release we need to increment the pre release portion
+    if ( $pre != 0 ) {
+
+        # Hex version can only handle 14 pre releases.
+        die &quot;Can't go past pre release 14!!&quot; if ( $S eq &quot;e&quot; );
+
+        # Must be a pre release or development version.
+        die &quot;Can't go from release to pre release!!&quot; if $S eq &quot;f&quot;;
+        $S = sprintf &quot;%x&quot;, hex($S) + 1;
+        $hexversion =~ s/.$/$S/;
+        $version = openssl_version_str($hexversion);
+        $version .= &quot;-dev&quot; if $dev;
+        return $version;
+    }
+
+   # If last version pre release and not doing pre releases any more then switch
+   # to full release.
+    return openssl_version_str(&quot;0x$M$NN$FF${PP}f&quot;) if ( $version =~ /pre/ );
+
+    # Otherwise need to increment letter value if not a pre release.
+    $PP = sprintf &quot;%02x&quot;, hex($PP) + 1;
+    die &quot;Invalid letter version!!&quot; if ( length $PP &gt; 2 );
+    return openssl_version_str(&quot;0x$M$NN$FF${PP}0&quot;);
+}
+
+# Return hex branch version belongs to.
+# So &quot;1.0.1a-pre2-dev&quot; returns hex of &quot;1.0.1&quot; for example.
+
+sub openssl_version_branch_hex {
+    my ($version) = @_;
+    my $hexversion = openssl_version_hex($version);
+    my ( $chk, $M, $NN, $FF, $PP, $S ) = unpack &quot;A2AA2A2A2A&quot;, $hexversion;
+    die &quot;Invalid syntax $version&quot; if $S eq &quot;&quot;;
+    return &quot;0x$M$NN${FF}00F&quot;;
+}
+
+return 1;
</PRE>



















































































































































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017907.html">[openssl-commits] Passed: openssl/openssl#16047 (master - 22da44f)
</A></li>
	<LI>Next message: <A HREF="017920.html">[openssl-commits] [tools]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17911">[ date ]</a>
              <a href="thread.html#17911">[ thread ]</a>
              <a href="subject.html#17911">[ subject ]</a>
              <a href="author.html#17911">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
