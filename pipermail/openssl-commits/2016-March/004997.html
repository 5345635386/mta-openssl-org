<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-March/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1457380641.317954.20959.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004996.html">
   <LINK REL="Next"  HREF="004999.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1457380641.317954.20959.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Mon Mar  7 19:57:21 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="004996.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="004999.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4997">[ date ]</a>
              <a href="thread.html#4997">[ thread ]</a>
              <a href="subject.html#4997">[ subject ]</a>
              <a href="author.html#4997">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  ec59112a822e16a539bc5dd1b8bed12afbcb82b8 (commit)
      from  691064c47fd6a7d11189df00a0d1b94d8051cbe0 (commit)


- Log -----------------------------------------------------------------
commit ec59112a822e16a539bc5dd1b8bed12afbcb82b8
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at akamai.com</A>&gt;
Date:   Mon Mar 7 14:55:44 2016 -0500

    Remove really old demo's
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 demos/easy_tls/Makefile.in                       |  124 --
 demos/easy_tls/README                            |   65 -
 demos/easy_tls/cacerts.pem                       |   18 -
 demos/easy_tls/cert.pem                          |   31 -
 demos/easy_tls/easy-tls.c                        | 1293 ----------------
 demos/easy_tls/easy-tls.h                        |   59 -
 demos/easy_tls/test.c                            |  247 ---
 demos/easy_tls/test.h                            |    9 -
 demos/engines/cluster_labs/Makefile.in           |   93 --
 demos/engines/cluster_labs/cluster_labs.h        |   33 -
 demos/engines/cluster_labs/hw_cluster_labs.c     |  684 ---------
 demos/engines/cluster_labs/hw_cluster_labs.ec    |    8 -
 demos/engines/cluster_labs/hw_cluster_labs_err.c |  151 --
 demos/engines/cluster_labs/hw_cluster_labs_err.h |  100 --
 demos/engines/ibmca/Makefile.in                  |   93 --
 demos/engines/ibmca/hw_ibmca.c                   |  896 -----------
 demos/engines/ibmca/hw_ibmca.ec                  |    8 -
 demos/engines/ibmca/hw_ibmca_err.c               |  148 --
 demos/engines/ibmca/hw_ibmca_err.h               |  103 --
 demos/engines/ibmca/ica_openssl_api.h            |  183 ---
 demos/engines/rsaref/Makefile.in                 |  114 --
 demos/engines/rsaref/README                      |   22 -
 demos/engines/rsaref/build.com                   |  105 --
 demos/engines/rsaref/rsaref.c                    |  658 --------
 demos/engines/rsaref/rsaref.ec                   |    8 -
 demos/engines/rsaref/rsaref_err.c                |  157 --
 demos/engines/rsaref/rsaref_err.h                |  109 --
 demos/engines/zencod/Makefile.in                 |   93 --
 demos/engines/zencod/hw_zencod.c                 | 1785 ----------------------
 demos/engines/zencod/hw_zencod.ec                |    8 -
 demos/engines/zencod/hw_zencod.h                 |  158 --
 demos/engines/zencod/hw_zencod_err.c             |  146 --
 demos/engines/zencod/hw_zencod_err.h             |  100 --
 demos/privkey.pem                                |    9 -
 demos/selfsign.c                                 |  169 --
 demos/sign/Makefile.in                           |   16 -
 demos/sign/cert.pem                              |   14 -
 demos/sign/key.pem                               |    9 -
 demos/sign/sig.txt                               |  158 --
 demos/sign/sign.c                                |  159 --
 demos/sign/sign.txt                              |  170 ---
 demos/spkigen.c                                  |  171 ---
 demos/ssl/cli.cpp                                |  108 --
 demos/ssl/inetdsrv.cpp                           |   98 --
 demos/ssl/serv.cpp                               |  152 --
 demos/ssltest-ecc/ECC-RSAcertgen.sh              |   98 --
 demos/ssltest-ecc/ECCcertgen.sh                  |  164 --
 demos/ssltest-ecc/README                         |   15 -
 demos/ssltest-ecc/RSAcertgen.sh                  |  121 --
 demos/ssltest-ecc/ssltest.sh                     |  188 ---
 demos/state_machine/Makefile.in                  |   10 -
 demos/state_machine/state_machine.c              |  405 -----
 demos/threads/README                             |    7 -
 demos/threads/mttest.c                           |  773 ----------
 demos/threads/pthread.sh                         |    6 -
 demos/threads/th-lock.c                          |  194 ---
 demos/threads/win32.bat                          |    4 -
 demos/x509/README                                |    3 -
 demos/x509/mkcert.c                              |  169 --
 demos/x509/mkreq.c                               |  168 --
 60 files changed, 11367 deletions(-)
 delete mode 100644 demos/easy_tls/Makefile.in
 delete mode 100644 demos/easy_tls/README
 delete mode 100644 demos/easy_tls/cacerts.pem
 delete mode 100644 demos/easy_tls/cert.pem
 delete mode 100644 demos/easy_tls/easy-tls.c
 delete mode 100644 demos/easy_tls/easy-tls.h
 delete mode 100644 demos/easy_tls/test.c
 delete mode 100644 demos/easy_tls/test.h
 delete mode 100644 demos/engines/cluster_labs/Makefile.in
 delete mode 100644 demos/engines/cluster_labs/cluster_labs.h
 delete mode 100644 demos/engines/cluster_labs/hw_cluster_labs.c
 delete mode 100644 demos/engines/cluster_labs/hw_cluster_labs.ec
 delete mode 100644 demos/engines/cluster_labs/hw_cluster_labs_err.c
 delete mode 100644 demos/engines/cluster_labs/hw_cluster_labs_err.h
 delete mode 100644 demos/engines/ibmca/Makefile.in
 delete mode 100644 demos/engines/ibmca/hw_ibmca.c
 delete mode 100644 demos/engines/ibmca/hw_ibmca.ec
 delete mode 100644 demos/engines/ibmca/hw_ibmca_err.c
 delete mode 100644 demos/engines/ibmca/hw_ibmca_err.h
 delete mode 100644 demos/engines/ibmca/ica_openssl_api.h
 delete mode 100644 demos/engines/rsaref/Makefile.in
 delete mode 100644 demos/engines/rsaref/README
 delete mode 100644 demos/engines/rsaref/build.com
 delete mode 100644 demos/engines/rsaref/rsaref.c
 delete mode 100644 demos/engines/rsaref/rsaref.ec
 delete mode 100644 demos/engines/rsaref/rsaref_err.c
 delete mode 100644 demos/engines/rsaref/rsaref_err.h
 delete mode 100644 demos/engines/zencod/Makefile.in
 delete mode 100644 demos/engines/zencod/hw_zencod.c
 delete mode 100644 demos/engines/zencod/hw_zencod.ec
 delete mode 100644 demos/engines/zencod/hw_zencod.h
 delete mode 100644 demos/engines/zencod/hw_zencod_err.c
 delete mode 100644 demos/engines/zencod/hw_zencod_err.h
 delete mode 100644 demos/privkey.pem
 delete mode 100644 demos/selfsign.c
 delete mode 100644 demos/sign/Makefile.in
 delete mode 100644 demos/sign/cert.pem
 delete mode 100644 demos/sign/key.pem
 delete mode 100644 demos/sign/sig.txt
 delete mode 100644 demos/sign/sign.c
 delete mode 100644 demos/sign/sign.txt
 delete mode 100644 demos/spkigen.c
 delete mode 100644 demos/ssl/cli.cpp
 delete mode 100644 demos/ssl/inetdsrv.cpp
 delete mode 100644 demos/ssl/serv.cpp
 delete mode 100755 demos/ssltest-ecc/ECC-RSAcertgen.sh
 delete mode 100755 demos/ssltest-ecc/ECCcertgen.sh
 delete mode 100644 demos/ssltest-ecc/README
 delete mode 100755 demos/ssltest-ecc/RSAcertgen.sh
 delete mode 100755 demos/ssltest-ecc/ssltest.sh
 delete mode 100644 demos/state_machine/Makefile.in
 delete mode 100644 demos/state_machine/state_machine.c
 delete mode 100644 demos/threads/README
 delete mode 100644 demos/threads/mttest.c
 delete mode 100644 demos/threads/pthread.sh
 delete mode 100644 demos/threads/th-lock.c
 delete mode 100644 demos/threads/win32.bat
 delete mode 100644 demos/x509/README
 delete mode 100644 demos/x509/mkcert.c
 delete mode 100644 demos/x509/mkreq.c

diff --git a/demos/easy_tls/Makefile.in b/demos/easy_tls/Makefile.in
deleted file mode 100644
index 087caa8..0000000
--- a/demos/easy_tls/Makefile.in
+++ /dev/null
@@ -1,124 +0,0 @@
-# Makefile for easy-tls example application (rudimentary client and server)
-# $Id: Makefile,v 1.2 2001/09/18 09:15:40 bodo Exp $
-
-SOLARIS_CFLAGS=-Wall -pedantic -g -O2
-SOLARIS_LIBS=-lxnet
-
-LINUX_CFLAGS=-Wall -pedantic -g -O2
-LINUX_LIBS=
-
-
-auto-all:
-	case `uname -s` in \
-	SunOS) echo Using SunOS configuration; \
-	  make SYSCFLAGS=&quot;$(SOLARIS_CFLAGS)&quot; SYSLIBS=&quot;$(SOLARIS_LIBS)&quot; all;; \
-	Linux) echo Using Linux configuration; \
-	  make SYSCFLAGS=&quot;$(LINUX_CFLAGS)&quot; SYSLIBS=&quot;$(LINUX_LIBS)&quot; all;; \
-	*) echo &quot;unknown system&quot;; exit 1;; \
-	esac
-
-all: test TAGS
-
-# For adapting this Makefile to a different system, only the following
-# definitions should need customizing:
-
-OPENSSLDIR=../..
-CC=gcc
-
-SYSCFLAGS=whatever
-SYSLIBS=whatever
-
-
-#############################################################################
-#
-# SSLeay/OpenSSL imports
-#
-# OPENSSLDIR (set above) can be either the directory where OpenSSL is
-# installed or the directory where it was compiled.
-
-# We rely on having a new OpenSSL release where include files
-# have names like &lt;openssl/ssl.h&gt; (not just &lt;ssl.h&gt;).
-OPENSSLINCLUDES=-I$(OPENSSLDIR)/include
-
-# libcrypto.a and libssl.a are directly in $(OPENSSLDIR) if this is
-# the compile directory, or in $(OPENSSLDIR)/lib if we use an installed
-# library.  With the following definition, we can handle either case.
-OPENSSLLIBS=-L$(OPENSSLDIR) -L$(OPENSSLDIR)/lib -lssl -lcrypto
-
-
-#############################################################################
-#
-# Stuff for handling the source files
-#
-
-SOURCES=easy-tls.c test.c
-HEADERS=easy-tls.h test.h
-DOCSandEXAMPLESetc=Makefile cert.pem cacerts.pem
-EVERYTHING=$(SOURCES) $(HEADERS) $(DOCSandEXAMPLESetc)
-
-ls: ls-l
-ls-l:
-	ls -l $(EVERYTHING)
-# For RCS:
-tag:
-	-rcs -n_`date +%y%m%d`: $(EVERYTHING)
-	rcs -nMYTAG $(EVERYTHING)
-	rcs -nMYTAG: $(EVERYTHING)
-diff:
-	-rcsdiff -rMYTAG -u $(EVERYTHING)
-today:
-	-rcsdiff -r_`date +%y%m%d` -u $(EVERYTHING)
-ident:
-	for a in $(EVERYTHING); do ident $$a; done
-
-# Distribution .tar:
-easy-tls.tar.gz: $(EVERYTHING)
-	tar cvf - $(EVERYTHING) | \
-	gzip -9 &gt; easy-tls.tar.gz
-
-# Working .tar:
-tls.tgz: $(EVERYTHING)
-	tar cfv - `find . -type f -a ! -name '*.tgz' -a ! -name '*.tar.gz'` | \
-	gzip -9 &gt; tls.tgz
-
-# For emacs:
-etags: TAGS
-TAGS: $(SOURCES) $(HEADERS)
-	-etags $(SOURCES) $(HEADERS)
-
-
-#############################################################################
-#
-# Compilation
-#
-# The following definitions are system dependent (and hence defined
-# at the beginning of this Makefile, where they are more easily found):
-
-### CC=gcc
-### SYSCFLAGS=-Wall -pedantic -g -O2
-### SYSLIBS=-lxnet
-
-EXTRACFLAGS=-DTLS_APP=\&quot;test.h\&quot;
-# EXTRACFLAGS=-DTLS_APP=\&quot;test.h\&quot; -DDEBUG_TLS
-
-#
-# The rest shouldn't need to be touched.
-#
-LDFLAGS=$(SYSLIBS) $(OPENSSLLIBS)
-INCLUDES=$(OPENSSLINCLUDES)
-CFLAGS=$(SYSCFLAGS) $(EXTRACFLAGS) $(INCLUDES)
-
-OBJS=easy-tls.o test.o
-
-clean:
-	@rm -f test
-	@rm -f TAGS
-	@rm -f *.o
-	@rm -f core
-
-test: $(OBJS)
-	$(CC) $(OBJS) $(LDFLAGS) -o test
-
-test.o: $(HEADERS)
-easy-tls.o: $(HEADERS)
-# DO NOT DELETE THIS LINE -- make depend depends on it.
diff --git a/demos/easy_tls/README b/demos/easy_tls/README
deleted file mode 100644
index ee89dfb..0000000
--- a/demos/easy_tls/README
+++ /dev/null
@@ -1,65 +0,0 @@
-easy_tls - generic SSL/TLS proxy
-========
-
-(... and example for non-blocking SSL/TLS I/O multiplexing.)
-
-
-  easy_tls.c, easy_tls.h:
-
-     Small generic SSL/TLS proxy library: With a few function calls,
-     an application socket will be replaced by a pipe handled by a
-     separate SSL/TLS proxy process.  This allows easily adding
-     SSL/TLS support to many programs not originally designed for it.
-
-     [Actually easy_tls.c is not a proper library: Customization
-     requires defining preprocessor macros while compiling it.
-     This is quite confusing, so I'll probably change it.]
-
-     These files may be used under the OpenSSL license.
-
-
-
-  test.c, test.h, Makefile, cert.pem, cacerts.pem:
-
-     Rudimentary example program using the easy_tls library, and
-     example key and certificates for it.  Usage examples:
-
-       $ ./test 8443     # create server listening at port 8443
-       $ ./test 127.0.0.1 8443  # create client, connect to port 8443
-                                # at IP address 127.0.0.1
-
-     'test' will not automatically do SSL/TLS, or even read or write
-     data -- it must be told to do so on input lines starting
-     with a command letter.  'W' means write a line, 'R' means
-     read a line, 'C' means close the connection, 'T' means
-     start an SSL/TLS proxy.  E.g. (user input tagged with '*'):
-
-     * R
-       &lt;&lt;&lt; 220 mail.example.net
-     * WSTARTTLS
-       &gt;&gt;&gt; STARTTLS
-     * R
-       &lt;&lt;&lt; 220 Ready to start TLS
-     * T
-       test_process_init(fd = 3, client_p = 1, apparg = (nil))
-       +++ `E:self signed certificate in certificate chain'
-       +++ `&lt;... certificate info ...&gt;'
-     * WHELO localhost
-       &gt;&gt;&gt; HELO localhost
-       R
-       &lt;&lt;&lt; 250 mail.example.net
-
-     You can even do SSL/TLS over SSL/TLS over SSL/TLS ... by using
-     'T' multiple times.  I have no idea why you would want to though.
-
-
-This code is rather old.  When I find time I will update anything that
-should be changed, and improve code comments.  To compile the sample
-program 'test' on platforms other then Linux or Solaris, you will have
-to edit the Makefile.
-
-As noted above, easy_tls.c will be changed to become a library one
-day, which means that future revisions will not be fully compatible to
-the current version.
-
-Bodo M&#246;ller &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">bodo at openssl.org</A>&gt;
diff --git a/demos/easy_tls/cacerts.pem b/demos/easy_tls/cacerts.pem
deleted file mode 100644
index acc70ba..0000000
--- a/demos/easy_tls/cacerts.pem
+++ /dev/null
@@ -1,18 +0,0 @@
-$Id: cacerts.pem,v 1.1 2001/09/17 19:06:57 bodo Exp $
-
-issuer= /C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Test PCA (1024 bit)
-subject=/C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Test CA (1024 bit)
------BEGIN CERTIFICATE-----
-MIICJjCCAY8CAQAwDQYJKoZIhvcNAQEEBQAwXDELMAkGA1UEBhMCQVUxEzARBgNV
-BAgTClF1ZWVuc2xhbmQxGjAYBgNVBAoTEUNyeXB0U29mdCBQdHkgTHRkMRwwGgYD
-VQQDExNUZXN0IFBDQSAoMTAyNCBiaXQpMB4XDTk3MDYwOTEzNTc0M1oXDTAxMDYw
-OTEzNTc0M1owWzELMAkGA1UEBhMCQVUxEzARBgNVBAgTClF1ZWVuc2xhbmQxGjAY
-BgNVBAoTEUNyeXB0U29mdCBQdHkgTHRkMRswGQYDVQQDExJUZXN0IENBICgxMDI0
-IGJpdCkwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKO7o8t116VP6cgybTsZ
-DCZhr95nYlZuya3aCi1IKoztqwWnjbmDFIriOqGFPrZQ+moMETC9D59iRW/dFXSv
-1F65ka/XY2hLh9exCCo7XuUcDs53Qp3bI3AmMqHjgzE8oO3ajyJAzJkTTOUecQU2
-mw/gI4tMM0LqWMQS7luTy4+xAgMBAAEwDQYJKoZIhvcNAQEEBQADgYEAM7achv3v
-hLQJcv/65eGEpBXM40ZDVoFQFFJWaY5p883HTqLB1x4FdzsXHH0QKBTcKpWwqyu4
-YDm3fb8oDugw72bCzfyZK/zVZPR/hVlqI/fvU109Qoc+7oPvIXWky71HfcK6ZBCA
-q30KIqGM/uoM60INq97qjDmCJapagcNBGQs=
------END CERTIFICATE-----
diff --git a/demos/easy_tls/cert.pem b/demos/easy_tls/cert.pem
deleted file mode 100644
index 364fe10..0000000
--- a/demos/easy_tls/cert.pem
+++ /dev/null
@@ -1,31 +0,0 @@
-$Id: cert.pem,v 1.1 2001/09/17 19:06:57 bodo Exp $
-
-Example certificate and key.
-
------BEGIN CERTIFICATE-----
-MIIB1jCCAT8CAQEwDQYJKoZIhvcNAQEEBQAwRTELMAkGA1UEBhMCQVUxEzARBgNV
-BAgTClNvbWUtU3RhdGUxITAfBgNVBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0
-ZDAeFw05OTA1MDEwMTI2MzVaFw05OTA1MzEwMTI2MzVaMCIxCzAJBgNVBAYTAkRF
-MRMwEQYDVQQDEwpUZXN0c2VydmVyMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB
-gQD6I3oDKiexwwlkzjar69AIFnVUaG85LtCege2R+CtIDlkQYw68/8MbT3ou0pdF
-AcL9IGiYY3Y0SHM9PqF00RO1MCtNpqTnF3ScLpbmggGjKilmWYn2ai7emdjMjXVL
-tzWW2xGgIGATWQN32KgfJng4jXi1UjEiyLhkw0Zf1I/ggwIDAQABMA0GCSqGSIb3
-DQEBBAUAA4GBAMgM+sbAk8DfjSfa+Rf2gcGXmbrvZAzKzC+5RU3kaq/NyxIXAGco
-9dZjozzWfN/xuGup5boFk+KrP+xdgsaqGHsyzlgEoqz4ekqLjQeVbnoj339hVFU9
-MhPi6JULPxjXKumjfX2LLNkikW5puz8Df3UiX0EiaJvd7EwP8J75tiUT
------END CERTIFICATE-----
------BEGIN RSA PRIVATE KEY-----
-MIICXQIBAAKBgQD6I3oDKiexwwlkzjar69AIFnVUaG85LtCege2R+CtIDlkQYw68
-/8MbT3ou0pdFAcL9IGiYY3Y0SHM9PqF00RO1MCtNpqTnF3ScLpbmggGjKilmWYn2
-ai7emdjMjXVLtzWW2xGgIGATWQN32KgfJng4jXi1UjEiyLhkw0Zf1I/ggwIDAQAB
-AoGANST8c1etf1MU19oIO5aqaE19OCXIG7oakNLCCtVTPMfvnE+vffBJH7BPIUuU
-4BBzwRv1nQrkvk72TPjVjOAu81B1SStKQueun2flVuYxp9NyupNWCBley4QdohlP
-I92ml2tzTSPmNIoA6jdGyNzFcGchapRRmejsC39F1RUbHQECQQD9KX81Wt8ZOrri
-dWiEXja1L3X8Bkb9vvUjVMQDTJJPxBJjehC6eurgE6PP6SJD5p/f3RHPCcLr8tSM
-D4P/OpKhAkEA/PFNlhIZUDKK6aTvG2mn7qQ5phbadOoyN1Js3ttWG5OMOZ6b/QlC
-Wvp84h44506BIlv+Tg2YAI0AdBUrf7oEowJAM4joAVd/ROaEtqbJ4PBA2L9RmD06
-5FqkEk4mHLnQqvYx/BgUIbH18ClvVlqSBBqFfw/EmU3WZSuogt6Bs0ocIQJBAOxB
-AoPiYcxbeQ5kZIVJOXaX49SzUdaUDNVJYrEBUzsspHQJJo/Avz606kJVkjbSR6Ft
-JWmIHuqcyMikIV4KxFsCQQCU2evoVjVsqkkbHi7W28f73PGBsyu0KIwlK7nu4h08
-Daf7TAI+A6jW/WRUsJ6dFhUYi7/Jvkcdrlnbgm2fxziX
------END RSA PRIVATE KEY-----
diff --git a/demos/easy_tls/easy-tls.c b/demos/easy_tls/easy-tls.c
deleted file mode 100644
index deef1fd..0000000
--- a/demos/easy_tls/easy-tls.c
+++ /dev/null
@@ -1,1293 +0,0 @@
-/* */
-/*-
- * easy-tls.c -- generic TLS proxy.
- * $Id: easy-tls.c,v 1.4 2002/03/05 09:07:16 bodo Exp $
- */
-/*-
- (c) Copyright 1999 Bodo Moeller.  All rights reserved.
-
- This is free software; you can redistributed and/or modify it
- unter the terms of either
-   -  the GNU General Public License as published by the
-      Free Software Foundation, version 1, or (at your option)
-      any later version,
- or
-   -  the following license:
-*/
-/*-
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that each of the following
- * conditions is met:
- *
- * 1. Redistributions qualify as &quot;freeware&quot; or &quot;Open Source Software&quot; under
- *    one of the following terms:
- *
- *    (a) Redistributions are made at no charge beyond the reasonable cost of
- *        materials and delivery.
- *
- *    (b) Redistributions are accompanied by a copy of the Source Code
- *        or by an irrevocable offer to provide a copy of the Source Code
- *        for up to three years at the cost of materials and delivery.
- *        Such redistributions must allow further use, modification, and
- *        redistribution of the Source Code under substantially the same
- *        terms as this license.
- *
- * 2. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 3. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 4. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by Bodo Moeller.&quot;
- *    (If available, substitute umlauted o for oe.)
- *
- * 5. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by Bodo Moeller.&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY BODO MOELLER ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL BODO MOELLER OR
- * HIS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-/*-
- * Attribution for OpenSSL library:
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- * This product includes software developed by the OpenSSL Project
- * for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)
- */
-
-static char const rcsid[] =
-    &quot;$Id: easy-tls.c,v 1.4 2002/03/05 09:07:16 bodo Exp $&quot;;
-
-#include &lt;assert.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;limits.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;sys/select.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/utsname.h&gt;
-#include &lt;unistd.h&gt;
-
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/dh.h&gt;
-#include &lt;openssl/dsa.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &lt;openssl/evp.h&gt;
-#include &lt;openssl/opensslv.h&gt;
-#include &lt;openssl/pem.h&gt;
-#include &lt;openssl/rand.h&gt;
-#ifndef NO_RSA
-# include &lt;openssl/rsa.h&gt;
-#endif
-#include &lt;openssl/ssl.h&gt;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/x509_vfy.h&gt;
-
-#if OPENSSL_VERSION_NUMBER &lt; 0x00904000L /* 0.9.4-dev */
-# error &quot;This program needs OpenSSL 0.9.4 or later.&quot;
-#endif
-
-#include &quot;easy-tls.h&quot;           /* include after &lt;openssl/ssl.h&gt; if both are
-                                 * needed */
-
-#if TLS_INFO_SIZE &gt; PIPE_BUF
-# if PIPE_BUF &lt; 512
-#  error &quot;PIPE_BUF &lt; 512&quot;       /* non-POSIX */
-# endif
-# error &quot;TLS_INFO_SIZE &gt; PIPE_BUF&quot;
-#endif
-
-/*****************************************************************************/
-
-#ifdef TLS_APP
-# include TLS_APP
-#endif
-
-/*-
- * Applications can define:
- *   TLS_APP_PROCESS_INIT -- void ...(int fd, int client_p, void *apparg)
- *   TLS_CUMULATE_ERRORS
- *   TLS_ERROR_BUFSIZ
- *   TLS_APP_ERRFLUSH -- void ...(int child_p, char *, size_t, void *apparg)
- */
-
-#ifndef TLS_APP_PROCESS_INIT
-# define TLS_APP_PROCESS_INIT(fd, client_p, apparg) ((void) 0)
-#endif
-
-#ifndef TLS_ERROR_BUFSIZ
-# define TLS_ERROR_BUFSIZ (10*160)
-#endif
-#if TLS_ERROR_BUFSIZ &lt; 2        /* {'\n',0} */
-# error &quot;TLS_ERROR_BUFSIZE is too small.&quot;
-#endif
-
-#ifndef TLS_APP_ERRFLUSH
-# define TLS_APP_ERRFLUSH tls_app_errflush
-static void
-tls_app_errflush(int child_p, char *errbuf, size_t num, void *apparg)
-{
-    fputs(errbuf, stderr);
-}
-#endif
-
-/*****************************************************************************/
-
-#ifdef DEBUG_TLS
-# define DEBUG_MSG(x) fprintf(stderr,&quot;  %s\n&quot;,x)
-# define DEBUG_MSG2(x,y) fprintf(stderr, &quot;  %s: %d\n&quot;,x,y)
-static int tls_loop_count = 0;
-static int tls_select_count = 0;
-#else
-# define DEBUG_MSG(x) (void)0
-# define DEBUG_MSG2(x,y) (void)0
-#endif
-
-static void tls_rand_seed_uniquely(void);
-static void tls_proxy(int clear_fd, int tls_fd, int info_fd, SSL_CTX *ctx,
-                      int client_p);
-static int tls_socket_nonblocking(int fd);
-
-static int tls_child_p = 0;
-static void *tls_child_apparg;
-
-struct tls_start_proxy_args tls_start_proxy_defaultargs(void)
-{
-    struct tls_start_proxy_args ret;
-
-    ret.fd = -1;
-    ret.client_p = -1;
-    ret.ctx = NULL;
-    ret.pid = NULL;
-    ret.infofd = NULL;
-
-    return ret;
-}
-
-/*-
- * Slice in TLS proxy process at fd.
- * Return value:
- *   0    ok  (*pid is set to child's PID if pid != NULL),
- *   &lt; 0  look at errno
- *   &gt; 0  other error
- *   (return value encodes place of error)
- *
- */
-int tls_start_proxy(struct tls_start_proxy_args a, void *apparg)
-{
-    int fds[2] = { -1, -1 };
-    int infofds[2] = { -1, -1 };
-    int r, getfd, getfl;
-    int ret;
-
-    DEBUG_MSG2(&quot;tls_start_proxy fd&quot;, a.fd);
-    DEBUG_MSG2(&quot;tls_start_proxy client_p&quot;, a.client_p);
-
-    if (a.fd == -1 || a.client_p == -1 || a.ctx == NULL)
-        return 1;
-
-    if (a.pid != NULL) {
-        *a.pid = 0;
-    }
-    if (a.infofd != NULL) {
-        *a.infofd = -1;
-    }
-
-    r = socketpair(AF_UNIX, SOCK_STREAM, 0, fds);
-    if (r == -1)
-        return -1;
-    if (a.fd &gt;= FD_SETSIZE || fds[0] &gt;= FD_SETSIZE) {
-        ret = 2;
-        goto err;
-    }
-    if (a.infofd != NULL) {
-        r = pipe(infofds);
-        if (r == -1) {
-            ret = -3;
-            goto err;
-        }
-    }
-
-    r = fork();
-    if (r == -1) {
-        ret = -4;
-        goto err;
-    }
-    if (r == 0) {
-        DEBUG_MSG(&quot;fork&quot;);
-        tls_child_p = 1;
-        tls_child_apparg = apparg;
-        close(fds[1]);
-        if (infofds[0] != -1)
-            close(infofds[0]);
-        TLS_APP_PROCESS_INIT(a.fd, a.client_p, apparg);
-        DEBUG_MSG(&quot;TLS_APP_PROCESS_INIT&quot;);
-        tls_proxy(fds[0], a.fd, infofds[1], a.ctx, a.client_p);
-        exit(0);
-    }
-    if (a.pid != NULL)
-        *a.pid = r;
-    if (infofds[1] != -1) {
-        close(infofds[1]);
-        infofds[1] = -1;
-    }
-    /* install fds[1] in place of fd: */
-    close(fds[0]);
-    fds[0] = -1;
-    getfd = fcntl(a.fd, F_GETFD);
-    getfl = fcntl(a.fd, F_GETFL);
-    r = dup2(fds[1], a.fd);
-    close(fds[1]);
-    fds[1] = -1;
-    if (r == -1) {
-        ret = -5;
-        goto err;
-    }
-    if (getfd != 1)
-        fcntl(a.fd, F_SETFD, getfd);
-    if (getfl &amp; O_NONBLOCK)
-        (void)tls_socket_nonblocking(a.fd);
-    if (a.infofd != NULL)
-        *a.infofd = infofds[0];
-    return 0;
-
- err:
-    if (fds[0] != -1)
-        close(fds[0]);
-    if (fds[1] != -1)
-        close(fds[1]);
-    if (infofds[0] != -1)
-        close(infofds[0]);
-    if (infofds[1] != -1)
-        close(infofds[1]);
-    return ret;
-}
-
-/*****************************************************************************/
-
-static char errbuf[TLS_ERROR_BUFSIZ];
-static size_t errbuf_i = 0;
-
-static void tls_errflush(void *apparg)
-{
-    if (errbuf_i == 0)
-        return;
-
-    assert(errbuf_i &lt; sizeof errbuf);
-    assert(errbuf[errbuf_i] == 0);
-    if (errbuf_i == sizeof errbuf - 1) {
-        /* make sure we have a newline, even if string has been truncated */
-        errbuf[errbuf_i - 1] = '\n';
-    }
-
-    /*
-     * TLS_APP_ERRFLUSH may modify the string as needed, e.g. substitute
-     * other characters for \n for convenience
-     */
-    TLS_APP_ERRFLUSH(tls_child_p, errbuf, errbuf_i, apparg);
-
-    errbuf_i = 0;
-}
-
-static void tls_errprintf(int flush, void *apparg, const char *fmt, ...)
-{
-    va_list args;
-    int r;
-
-    if (errbuf_i &lt; sizeof errbuf - 1) {
-        size_t n;
-
-        va_start(args, fmt);
-        n = (sizeof errbuf) - errbuf_i;
-        r = vsnprintf(errbuf + errbuf_i, n, fmt, args);
-        if (r &gt;= n)
-            r = n - 1;
-        if (r &gt;= 0) {
-            errbuf_i += r;
-        } else {
-            errbuf_i = sizeof errbuf - 1;
-            errbuf[errbuf_i] = '\0';
-        }
-        assert(errbuf_i &lt; sizeof errbuf);
-        assert(errbuf[errbuf_i] == 0);
-    }
-#ifndef TLS_CUMULATE_ERRORS
-    tls_errflush(apparg);
-#else
-    if (flush)
-        tls_errflush(apparg);
-#endif
-}
-
-/*
- * app_prefix.. are for additional information provided by caller. If OpenSSL
- * error queue is empty, print default_text (&quot;???&quot; if NULL).
- */
-static char *tls_openssl_errors(const char *app_prefix_1,
-                                const char *app_prefix_2,
-                                const char *default_text, void *apparg)
-{
-    static char reasons[255];
-    size_t reasons_i;
-    unsigned long err;
-    const char *file;
-    int line;
-    const char *data;
-    int flags;
-    char *errstring;
-    int printed_something = 0;
-
-    reasons_i = 0;
-
-    assert(app_prefix_1 != NULL);
-    assert(app_prefix_2 != NULL);
-
-    if (default_text == NULL)
-        default_text = &quot;?&quot; &quot;?&quot; &quot;?&quot;;
-
-    while ((err = ERR_get_error_line_data(&amp;file, &amp;line, &amp;data, &amp;flags)) != 0) {
-        if (reasons_i &lt; sizeof reasons) {
-            size_t n;
-            int r;
-
-            n = (sizeof reasons) - reasons_i;
-            r = snprintf(reasons + reasons_i, n, &quot;%s%s&quot;,
-                         (reasons_i &gt; 0 ? &quot;, &quot; : &quot;&quot;),
-                         ERR_reason_error_string(err));
-            if (r &gt;= n)
-                r = n - 1;
-            if (r &gt;= 0) {
-                reasons_i += r;
-            } else {
-                reasons_i = sizeof reasons;
-            }
-            assert(reasons_i &lt;= sizeof reasons);
-        }
-
-        errstring = ERR_error_string(err, NULL);
-        assert(errstring != NULL);
-        tls_errprintf(0, apparg, &quot;OpenSSL error%s%s: %s:%s:%d:%s\n&quot;,
-                      app_prefix_1, app_prefix_2, errstring, file, line,
-                      (flags &amp; ERR_TXT_STRING) ? data : &quot;&quot;);
-        printed_something = 1;
-    }
-
-    if (!printed_something) {
-        assert(reasons_i == 0);
-        snprintf(reasons, sizeof reasons, &quot;%s&quot;, default_text);
-        tls_errprintf(0, apparg, &quot;OpenSSL error%s%s: %s\n&quot;, app_prefix_1,
-                      app_prefix_2, default_text);
-    }
-#ifdef TLS_CUMULATE_ERRORS
-    tls_errflush(apparg);
-#endif
-    assert(errbuf_i == 0);
-
-    return reasons;
-}
-
-/*****************************************************************************/
-
-static int tls_init_done = 0;
-
-static int tls_init(void *apparg)
-{
-    if (tls_init_done)
-        return 0;
-
-    SSL_load_error_strings();
-    if (!SSL_library_init()) {
-        tls_errprintf(1, apparg, &quot;SSL_library_init failed.\n&quot;);
-        return -1;
-    }
-    tls_init_done = 1;
-    tls_rand_seed();
-    return 0;
-}
-
-/*****************************************************************************/
-
-static void tls_rand_seed_uniquely(void)
-{
-    struct {
-        pid_t pid;
-        time_t time;
-        void *stack;
-    } data;
-
-    data.pid = getpid();
-    data.time = time(NULL);
-    data.stack = (void *)&data;
-
-    RAND_seed((const void *)&amp;data, sizeof data);
-}
-
-void tls_rand_seed(void)
-{
-    struct {
-        struct utsname uname;
-        int uname_1;
-        int uname_2;
-        uid_t uid;
-        uid_t euid;
-        gid_t gid;
-        gid_t egid;
-    } data;
-
-    data.uname_1 = uname(&amp;data.uname);
-    data.uname_2 = errno;       /* Let's hope that uname fails randomly :-) */
-
-    data.uid = getuid();
-    data.euid = geteuid();
-    data.gid = getgid();
-    data.egid = getegid();
-
-    RAND_seed((const void *)&amp;data, sizeof data);
-    tls_rand_seed_uniquely();
-}
-
-static int tls_rand_seeded_p = 0;
-
-#define my_MIN_SEED_BYTES 256   /* struct stat can be larger than 128 */
-int tls_rand_seed_from_file(const char *filename, size_t n, void *apparg)
-{
-    /*
-     * Seed OpenSSL's random number generator from file. Try to read n bytes
-     * if n &gt; 0, whole file if n == 0.
-     */
-
-    int r;
-
-    if (tls_init(apparg) == -1)
-        return -1;
-    tls_rand_seed();
-
-    r = RAND_load_file(filename,
-                       (n &gt; 0 &amp;&amp; n &lt; LONG_MAX) ? (long)n : LONG_MAX);
-    /*
-     * r is the number of bytes filled into the random number generator,
-     * which are taken from &quot;stat(filename, ...)&quot; in addition to the file
-     * contents.
-     */
-    assert(1 &lt; my_MIN_SEED_BYTES);
-    /*
-     * We need to detect at least those cases when the file does not exist at
-     * all.  With current versions of OpenSSL, this should do it:
-     */
-    if (n == 0)
-        n = my_MIN_SEED_BYTES;
-    if (r &lt; n) {
-        tls_errprintf(1, apparg,
-                      &quot;rand_seed_from_file: could not read %d bytes from %s.\n&quot;,
-                      n, filename);
-        return -1;
-    } else {
-        tls_rand_seeded_p = 1;
-        return 0;
-    }
-}
-
-void tls_rand_seed_from_memory(const void *buf, size_t n)
-{
-    size_t i = 0;
-
-    while (i &lt; n) {
-        size_t rest = n - i;
-        int chunk = rest &lt; INT_MAX ? (int)rest : INT_MAX;
-        RAND_seed((const char *)buf + i, chunk);
-        i += chunk;
-    }
-    tls_rand_seeded_p = 1;
-}
-
-/*****************************************************************************/
-
-struct tls_x509_name_string {
-    char str[100];
-};
-
-static void
-tls_get_x509_subject_name_oneline(X509 *cert,
-                                  struct tls_x509_name_string *namestring)
-{
-    X509_NAME *name;
-
-    if (cert == NULL) {
-        namestring-&gt;str[0] = '\0';
-        return;
-    }
-
-    name = X509_get_subject_name(cert); /* does not increment any reference
-                                         * counter */
-
-    assert(sizeof namestring-&gt;str &gt;= 4); /* &quot;?&quot; or &quot;...&quot;, plus 0 */
-
-    if (name == NULL) {
-        namestring-&gt;str[0] = '?';
-        namestring-&gt;str[1] = 0;
-    } else {
-        size_t len;
-
-        X509_NAME_oneline(name, namestring-&gt;str, sizeof namestring-&gt;str);
-        len = strlen(namestring-&gt;str);
-        assert(namestring-&gt;str[len] == 0);
-        assert(len &lt; sizeof namestring-&gt;str);
-
-        if (len + 1 == sizeof namestring-&gt;str) {
-            /*
-             * (Probably something was cut off.) Does not really work --
-             * X509_NAME_oneline truncates after name components, we cannot
-             * tell from the result whether anything is missing.
-             */
-
-            assert(namestring-&gt;str[len] == 0);
-            namestring-&gt;str[--len] = '.';
-            namestring-&gt;str[--len] = '.';
-            namestring-&gt;str[--len] = '.';
-        }
-    }
-}
-
-/*****************************************************************************/
-
-/* to hinder OpenSSL from asking for passphrases */
-static int no_passphrase_callback(char *buf, int num, int w, void *arg)
-{
-    return -1;
-}
-
-#if OPENSSL_VERSION_NUMBER &gt;= 0x00907000L
-static int verify_dont_fail_cb(X509_STORE_CTX *c, void *unused_arg)
-#else
-static int verify_dont_fail_cb(X509_STORE_CTX *c)
-#endif
-{
-    int i;
-
-    i = X509_verify_cert(c);    /* sets c-&gt;error */
-#if OPENSSL_VERSION_NUMBER &gt;= 0x00905000L /* don't allow unverified
-                                           * certificates -- they could
-                                           * survive session reuse, but
-                                           * OpenSSL &lt; 0.9.5-dev does not
-                                           * preserve their verify_result */
-    if (i == 0)
-        return 1;
-    else
-#endif
-        return i;
-}
-
-static DH *tls_dhe1024 = NULL;  /* generating these takes a while, so do it
-                                 * just once */
-
-void tls_set_dhe1024(int i, void *apparg)
-{
-    DSA *dsaparams;
-    DH *dhparams;
-    const char *seed[] = { &quot;;-)  :-(  :-)  :-(  &quot;,
-        &quot;;-)  :-(  :-)  :-(  &quot;,
-        &quot;Random String no. 12&quot;,
-        &quot;;-)  :-(  :-)  :-(  &quot;,
-        &quot;hackers have even mo&quot;, /* from jargon file */
-    };
-    unsigned char seedbuf[20];
-
-    tls_init(apparg);
-    if (i &gt;= 0) {
-        i %= sizeof seed / sizeof seed[0];
-        assert(strlen(seed[i]) == 20);
-        memcpy(seedbuf, seed[i], 20);
-        dsaparams =
-            DSA_generate_parameters(1024, seedbuf, 20, NULL, NULL, 0, NULL);
-    } else {
-        /* random parameters (may take a while) */
-        dsaparams =
-            DSA_generate_parameters(1024, NULL, 0, NULL, NULL, 0, NULL);
-    }
-
-    if (dsaparams == NULL) {
-        tls_openssl_errors(&quot;&quot;, &quot;&quot;, NULL, apparg);
-        return;
-    }
-    dhparams = DSA_dup_DH(dsaparams);
-    DSA_free(dsaparams);
-    if (dhparams == NULL) {
-        tls_openssl_errors(&quot;&quot;, &quot;&quot;, NULL, apparg);
-        return;
-    }
-    DH_free(tls_dhe1024);
-    tls_dhe1024 = dhparams;
-}
-
-struct tls_create_ctx_args tls_create_ctx_defaultargs(void)
-{
-    struct tls_create_ctx_args ret;
-
-    ret.client_p = 0;
-    ret.certificate_file = NULL;
-    ret.key_file = NULL;
-    ret.ca_file = NULL;
-    ret.verify_depth = -1;
-    ret.fail_unless_verified = 0;
-
-    return ret;
-}
-
-SSL_CTX *tls_create_ctx(struct tls_create_ctx_args a, void *apparg)
-{
-    int r;
-    static long context_num = 0;
-    SSL_CTX *ret;
-    const char *err_pref_1 = &quot;&quot;, *err_pref_2 = &quot;&quot;;
-
-    if (tls_init(apparg) == -1)
-        return NULL;
-
-    ret =
-        SSL_CTX_new((a.client_p ? TLS_client_method :
-                     TLS_server_method) ());
-
-    if (ret == NULL)
-        goto err;
-
-    SSL_CTX_set_default_passwd_cb(ret, no_passphrase_callback);
-    SSL_CTX_set_mode(ret, SSL_MODE_ENABLE_PARTIAL_WRITE);
-
-    if ((a.certificate_file != NULL) || (a.key_file != NULL)) {
-        if (a.key_file == NULL) {
-            tls_errprintf(1, apparg, &quot;Need a key file.\n&quot;);
-            goto err_return;
-        }
-        if (a.certificate_file == NULL) {
-            tls_errprintf(1, apparg, &quot;Need a certificate chain file.\n&quot;);
-            goto err_return;
-        }
-
-        if (!SSL_CTX_use_PrivateKey_file(ret, a.key_file, SSL_FILETYPE_PEM))
-            goto err;
-        if (!tls_rand_seeded_p) {
-            /*
-             * particularly paranoid people may not like this -- so provide
-             * your own random seeding before calling this
-             */
-            if (tls_rand_seed_from_file(a.key_file, 0, apparg) == -1)
-                goto err_return;
-        }
-        if (!SSL_CTX_use_certificate_chain_file(ret, a.certificate_file))
-            goto err;
-        if (!SSL_CTX_check_private_key(ret)) {
-            tls_errprintf(1, apparg,
-                          &quot;Private key \&quot;%s\&quot; does not match certificate \&quot;%s\&quot;.\n&quot;,
-                          a.key_file, a.certificate_file);
-            goto err_peek;
-        }
-    }
-
-    if ((a.ca_file != NULL) || (a.verify_depth &gt; 0)) {
-        context_num++;
-        r = SSL_CTX_set_session_id_context(ret, (const void *)&amp;context_num,
-                                           (unsigned int)sizeof context_num);
-        if (!r)
-            goto err;
-
-        SSL_CTX_set_verify(ret,
-                           SSL_VERIFY_PEER | (a.fail_unless_verified ?
-                                              SSL_VERIFY_FAIL_IF_NO_PEER_CERT
-                                              : 0), 0);
-        if (!a.fail_unless_verified)
-            SSL_CTX_set_cert_verify_callback(ret, verify_dont_fail_cb, NULL);
-
-        if (a.verify_depth &gt; 0)
-            SSL_CTX_set_verify_depth(ret, a.verify_depth);
-
-        if (a.ca_file != NULL) {
-            /* does not report failure if file does not exist ... */
-            /* NULL argument means no CA-directory */
-            r = SSL_CTX_load_verify_locations(ret, a.ca_file, NULL);
-            if (!r) {
-                err_pref_1 = &quot; while processing certificate file &quot;;
-                err_pref_2 = a.ca_file;
-                goto err;
-            }
-
-            if (!a.client_p) {
-                /*
-                 * SSL_load_client_CA_file is a misnomer, it just creates a
-                 * list of CNs.
-                 */
-                SSL_CTX_set_client_CA_list(ret,
-                                           SSL_load_client_CA_file
-                                           (a.ca_file));
-                /*
-                 * SSL_CTX_set_client_CA_list does not have a return value;
-                 * it does not really need one, but make sure (we really test
-                 * if SSL_load_client_CA_file worked)
-                 */
-                if (SSL_CTX_get_client_CA_list(ret) == NULL) {
-                    tls_errprintf(1, apparg,
-                                  &quot;Could not set client CA list from \&quot;%s\&quot;.\n&quot;,
-                                  a.ca_file);
-                    goto err_peek;
-                }
-            }
-        }
-    }
-
-    if (!a.client_p) {
-        if (tls_dhe1024 == NULL) {
-            int i;
-
-            if (RAND_bytes((unsigned char *)&amp;i, sizeof i) &lt;= 0)
-                goto err_return;
-            /*
-             * make sure that i is non-negative -- pick one of the provided
-             * seeds
-             */
-            if (i &lt; 0)
-                i = -i;
-            if (i &lt; 0)
-                i = 0;
-            tls_set_dhe1024(i, apparg);
-            if (tls_dhe1024 == NULL)
-                goto err_return;
-        }
-
-        if (!SSL_CTX_set_tmp_dh(ret, tls_dhe1024))
-            goto err;
-
-        /* avoid small subgroup attacks: */
-        SSL_CTX_set_options(ret, SSL_OP_SINGLE_DH_USE);
-    }
-
-    return ret;
-
- err_peek:
-    if (!ERR_peek_error())
-        goto err_return;
- err:
-    tls_openssl_errors(err_pref_1, err_pref_2, NULL, apparg);
- err_return:
-    SSL_CTX_free(ret);
-    return NULL;
-}
-
-/*****************************************************************************/
-
-static int tls_socket_nonblocking(int fd)
-{
-    int v, r;
-
-    v = fcntl(fd, F_GETFL, 0);
-    if (v == -1) {
-        if (errno == EINVAL)
-            return 0;           /* already shut down -- ignore */
-        return -1;
-    }
-    r = fcntl(fd, F_SETFL, v | O_NONBLOCK);
-    if (r == -1) {
-        if (errno == EINVAL)
-            return 0;           /* already shut down -- ignore */
-        return -1;
-    }
-    return 0;
-}
-
-static int max(int a, int b)
-{
-    return a &gt; b ? a : b;
-}
-
-/* timeout, -1 means no timeout */
-static void
-tls_sockets_select(int read_select_1, int read_select_2, int write_select_1,
-                   int write_select_2, int seconds)
-{
-    int maxfd, n;
-    fd_set reads, writes;
-    struct timeval timeout;
-    struct timeval *timeout_p;
-
-    assert(read_select_1 &gt;= -1 &amp;&amp; read_select_2 &gt;= -1 &amp;&amp; write_select_1 &gt;= -1
-           &amp;&amp; write_select_2 &gt;= -1);
-    assert(read_select_1 &lt; FD_SETSIZE &amp;&amp; read_select_2 &lt; FD_SETSIZE - 1
-           &amp;&amp; write_select_1 &lt; FD_SETSIZE - 1
-           &amp;&amp; write_select_2 &lt; FD_SETSIZE - 1);
-
-    maxfd =
-        max(max(read_select_1, read_select_2),
-            max(write_select_1, write_select_2));
-    assert(maxfd &gt;= 0);
-
-    FD_ZERO(&amp;reads);
-    FD_ZERO(&amp;writes);
-
-    for (n = 0; n &lt; 4; ++n) {
-        int i = n % 2;
-        int w = n &gt;= 2;
-        /* loop over all (i, w) in {0,1}x{0,1} */
-        int fd;
-
-        if (i == 0 &amp;&amp; w == 0)
-            fd = read_select_1;
-        else if (i == 1 &amp;&amp; w == 0)
-            fd = read_select_2;
-        else if (i == 0 &amp;&amp; w == 1)
-            fd = write_select_1;
-        else {
-            assert(i == 1 &amp;&amp; w == 1);
-            fd = write_select_2;
-        }
-
-        if (fd &gt;= 0) {
-            if (w == 0)
-                FD_SET(fd, &amp;reads);
-            else                /* w == 1 */
-                FD_SET(fd, &amp;writes);
-        }
-    }
-
-    if (seconds &gt;= 0) {
-        timeout.tv_sec = seconds;
-        timeout.tv_usec = 0;
-        timeout_p = &timeout;
-    } else
-        timeout_p = NULL;
-
-    DEBUG_MSG2(&quot;select no.&quot;, ++tls_select_count);
-    select(maxfd + 1, &amp;reads, &amp;writes, (fd_set *) NULL, timeout_p);
-    DEBUG_MSG(&quot;cont.&quot;);
-}
-
-/*****************************************************************************/
-
-#define TUNNELBUFSIZE (16*1024)
-struct tunnelbuf {
-    char buf[TUNNELBUFSIZE];
-    size_t len;
-    size_t offset;
-};
-
-static int tls_connect_attempt(SSL *, int *write_select, int *read_select,
-                               int *closed, int *progress,
-                               const char **err_pref);
-
-static int tls_accept_attempt(SSL *, int *write_select, int *read_select,
-                              int *closed, int *progress,
-                              const char **err_pref);
-
-static int tls_write_attempt(SSL *, struct tunnelbuf *, int *write_select,
-                             int *read_select, int *closed, int *progress,
-                             const char **err_pref);
-
-static int tls_read_attempt(SSL *, struct tunnelbuf *, int *write_select,
-                            int *read_select, int *closed, int *progress,
-                            const char **err_pref);
-
-static int write_attempt(int fd, struct tunnelbuf *, int *select, int *closed,
-                         int *progress);
-
-static int read_attempt(int fd, struct tunnelbuf *, int *select, int *closed,
-                        int *progress);
-
-static void write_info(SSL *ssl, int *info_fd)
-{
-    if (*info_fd != -1) {
-        long v;
-        int v_ok;
-        struct tls_x509_name_string peer;
-        char infobuf[TLS_INFO_SIZE];
-        int r;
-
-        DEBUG_MSG(&quot;write_info&quot;);
-        v = SSL_get_verify_result(ssl);
-        v_ok = (v == X509_V_OK) ? 'A' : 'E'; /* Auth./Error */
-        {
-            X509 *peercert;
-
-            peercert = SSL_get_peer_certificate(ssl);
-            tls_get_x509_subject_name_oneline(peercert, &amp;peer);
-            X509_free(peercert);
-        }
-        if (peer.str[0] == '\0')
-            v_ok = '0';         /* no cert at all */
-        else if (strchr(peer.str, '\n')) {
-            /* should not happen, but make sure */
-            *strchr(peer.str, '\n') = '\0';
-        }
-        r = snprintf(infobuf, sizeof infobuf, &quot;%c:%s\n%s\n&quot;, v_ok,
-                     X509_verify_cert_error_string(v), peer.str);
-        DEBUG_MSG2(&quot;snprintf&quot;, r);
-        if (r == -1 || r &gt;= sizeof infobuf)
-            r = sizeof infobuf - 1;
-        write(*info_fd, infobuf, r);
-        close(*info_fd);
-        *info_fd = -1;
-    }
-}
-
-/* tls_proxy expects that all fds are closed after return */
-static void
-tls_proxy(int clear_fd, int tls_fd, int info_fd, SSL_CTX *ctx, int client_p)
-{
-    struct tunnelbuf clear_to_tls, tls_to_clear;
-    SSL *ssl;
-    BIO *rbio, *wbio;
-    int closed, in_handshake;
-    const char *err_pref_1 = &quot;&quot;, *err_pref_2 = &quot;&quot;;
-    const char *err_def = NULL;
-
-    assert(clear_fd != -1);
-    assert(tls_fd != -1);
-    assert(clear_fd &lt; FD_SETSIZE);
-    assert(tls_fd &lt; FD_SETSIZE);
-    /* info_fd may be -1 */
-    assert(ctx != NULL);
-
-    tls_rand_seed_uniquely();
-
-    tls_socket_nonblocking(clear_fd);
-    DEBUG_MSG2(&quot;clear_fd&quot;, clear_fd);
-    tls_socket_nonblocking(tls_fd);
-    DEBUG_MSG2(&quot;tls_fd&quot;, tls_fd);
-
-    ssl = SSL_new(ctx);
-    if (ssl == NULL)
-        goto err;
-    DEBUG_MSG(&quot;SSL_new&quot;);
-    if (!SSL_set_fd(ssl, tls_fd))
-        goto err;
-    rbio = SSL_get_rbio(ssl);
-    wbio = SSL_get_wbio(ssl);   /* should be the same, but who cares */
-    assert(rbio != NULL);
-    assert(wbio != NULL);
-    if (client_p)
-        SSL_set_connect_state(ssl);
-    else
-        SSL_set_accept_state(ssl);
-
-    closed = 0;
-    in_handshake = 1;
-    tls_to_clear.len = 0;
-    tls_to_clear.offset = 0;
-    clear_to_tls.len = 0;
-    clear_to_tls.offset = 0;
-
-    err_def = &quot;I/O error&quot;;
-
-    /*
-     * loop finishes as soon as we detect that one side closed; when all
-     * (program and OS) buffers have enough space, the data from the last
-     * successful read in each direction is transferred before close
-     */
-    do {
-        int clear_read_select = 0, clear_write_select = 0,
-            tls_read_select = 0, tls_write_select = 0, progress = 0;
-        int r;
-        uint64_t num_read = BIO_number_read(rbio),
-            num_written = BIO_number_written(wbio);
-
-        DEBUG_MSG2(&quot;loop iteration&quot;, ++tls_loop_count);
-
-        if (in_handshake) {
-            DEBUG_MSG(&quot;in_handshake&quot;);
-            if (client_p)
-                r = tls_connect_attempt(ssl, &amp;tls_write_select,
-                                        &amp;tls_read_select, &amp;closed, &amp;progress,
-                                        &amp;err_pref_1);
-            else
-                r = tls_accept_attempt(ssl, &amp;tls_write_select,
-                                       &amp;tls_read_select, &amp;closed, &amp;progress,
-                                       &amp;err_pref_1);
-            if (r != 0) {
-                write_info(ssl, &amp;info_fd);
-                goto err;
-            }
-            if (closed)
-                goto err_return;
-            if (!SSL_in_init(ssl)) {
-                in_handshake = 0;
-                write_info(ssl, &amp;info_fd);
-            }
-        }
-
-        if (clear_to_tls.len != 0 &amp;&amp; !in_handshake) {
-            assert(!closed);
-
-            r = tls_write_attempt(ssl, &amp;clear_to_tls, &amp;tls_write_select,
-                                  &amp;tls_read_select, &amp;closed, &amp;progress,
-                                  &amp;err_pref_1);
-            if (r != 0)
-                goto err;
-            if (closed) {
-                assert(progress);
-                tls_to_clear.offset = 0;
-                tls_to_clear.len = 0;
-            }
-        }
-
-        if (tls_to_clear.len != 0) {
-            assert(!closed);
-
-            r = write_attempt(clear_fd, &amp;tls_to_clear, &amp;clear_write_select,
-                              &amp;closed, &amp;progress);
-            if (r != 0)
-                goto err_return;
-            if (closed) {
-                assert(progress);
-                clear_to_tls.offset = 0;
-                clear_to_tls.len = 0;
-            }
-        }
-
-        if (!closed) {
-            if (clear_to_tls.offset + clear_to_tls.len &lt;
-                sizeof clear_to_tls.buf) {
-                r = read_attempt(clear_fd, &amp;clear_to_tls, &amp;clear_read_select,
-                                 &amp;closed, &amp;progress);
-                if (r != 0)
-                    goto err_return;
-                if (closed) {
-                    r = SSL_shutdown(ssl);
-                    DEBUG_MSG2(&quot;SSL_shutdown&quot;, r);
-                }
-            }
-        }
-
-        if (!closed &amp;&amp; !in_handshake) {
-            if (tls_to_clear.offset + tls_to_clear.len &lt;
-                sizeof tls_to_clear.buf) {
-                r = tls_read_attempt(ssl, &amp;tls_to_clear, &amp;tls_write_select,
-                                     &amp;tls_read_select, &amp;closed, &amp;progress,
-                                     &amp;err_pref_1);
-                if (r != 0)
-                    goto err;
-                if (closed) {
-                    r = SSL_shutdown(ssl);
-                    DEBUG_MSG2(&quot;SSL_shutdown&quot;, r);
-                }
-            }
-        }
-
-        if (!progress) {
-            DEBUG_MSG(&quot;!progress?&quot;);
-            if (num_read != BIO_number_read(rbio)
-                || num_written != BIO_number_written(wbio))
-                progress = 1;
-
-            if (!progress) {
-                DEBUG_MSG(&quot;!progress&quot;);
-                assert(clear_read_select || tls_read_select
-                       || clear_write_select || tls_write_select);
-                tls_sockets_select(clear_read_select ? clear_fd : -1,
-                                   tls_read_select ? tls_fd : -1,
-                                   clear_write_select ? clear_fd : -1,
-                                   tls_write_select ? tls_fd : -1, -1);
-            }
-        }
-    } while (!closed);
-    return;
-
- err:
-    tls_openssl_errors(err_pref_1, err_pref_2, err_def, tls_child_apparg);
- err_return:
-    return;
-}
-
-static int
-tls_get_error(SSL *ssl, int r, int *write_select, int *read_select,
-              int *closed, int *progress)
-{
-    int err = SSL_get_error(ssl, r);
-
-    if (err == SSL_ERROR_NONE) {
-        assert(r &gt; 0);
-        *progress = 1;
-        return 0;
-    }
-
-    assert(r &lt;= 0);
-
-    switch (err) {
-    case SSL_ERROR_ZERO_RETURN:
-        assert(r == 0);
-        *closed = 1;
-        *progress = 1;
-        return 0;
-
-    case SSL_ERROR_WANT_WRITE:
-        *write_select = 1;
-        return 0;
-
-    case SSL_ERROR_WANT_READ:
-        *read_select = 1;
-        return 0;
-    }
-
-    return -1;
-}
-
-static int
-tls_connect_attempt(SSL *ssl, int *write_select, int *read_select,
-                    int *closed, int *progress, const char **err_pref)
-{
-    int n, r;
-
-    DEBUG_MSG(&quot;tls_connect_attempt&quot;);
-    n = SSL_connect(ssl);
-    DEBUG_MSG2(&quot;SSL_connect&quot;, n);
-    r = tls_get_error(ssl, n, write_select, read_select, closed, progress);
-    if (r == -1)
-        *err_pref = &quot; during SSL_connect&quot;;
-    return r;
-}
-
-static int
-tls_accept_attempt(SSL *ssl, int *write_select, int *read_select, int *closed,
-                   int *progress, const char **err_pref)
-{
-    int n, r;
-
-    DEBUG_MSG(&quot;tls_accept_attempt&quot;);
-    n = SSL_accept(ssl);
-    DEBUG_MSG2(&quot;SSL_accept&quot;, n);
-    r = tls_get_error(ssl, n, write_select, read_select, closed, progress);
-    if (r == -1)
-        *err_pref = &quot; during SSL_accept&quot;;
-    return r;
-}
-
-static int
-tls_write_attempt(SSL *ssl, struct tunnelbuf *buf, int *write_select,
-                  int *read_select, int *closed, int *progress,
-                  const char **err_pref)
-{
-    int n, r;
-
-    DEBUG_MSG(&quot;tls_write_attempt&quot;);
-    n = SSL_write(ssl, buf-&gt;buf + buf-&gt;offset, buf-&gt;len);
-    DEBUG_MSG2(&quot;SSL_write&quot;, n);
-    r = tls_get_error(ssl, n, write_select, read_select, closed, progress);
-    if (n &gt; 0) {
-        buf-&gt;len -= n;
-        assert(buf-&gt;len &gt;= 0);
-        if (buf-&gt;len == 0)
-            buf-&gt;offset = 0;
-        else
-            buf-&gt;offset += n;
-    }
-    if (r == -1)
-        *err_pref = &quot; during SSL_write&quot;;
-    return r;
-}
-
-static int
-tls_read_attempt(SSL *ssl, struct tunnelbuf *buf, int *write_select,
-                 int *read_select, int *closed, int *progress,
-                 const char **err_pref)
-{
-    int n, r;
-    size_t total;
-
-    DEBUG_MSG(&quot;tls_read_attempt&quot;);
-    total = buf-&gt;offset + buf-&gt;len;
-    assert(total &lt; sizeof buf-&gt;buf);
-    n = SSL_read(ssl, buf-&gt;buf + total, (sizeof buf-&gt;buf) - total);
-    DEBUG_MSG2(&quot;SSL_read&quot;, n);
-    r = tls_get_error(ssl, n, write_select, read_select, closed, progress);
-    if (n &gt; 0) {
-        buf-&gt;len += n;
-        assert(buf-&gt;offset + buf-&gt;len &lt;= sizeof buf-&gt;buf);
-    }
-    if (r == -1)
-        *err_pref = &quot; during SSL_read&quot;;
-    return r;
-}
-
-static int get_error(int r, int *select, int *closed, int *progress)
-{
-    if (r &gt;= 0) {
-        *progress = 1;
-        if (r == 0)
-            *closed = 1;
-        return 0;
-    } else {
-        assert(r == -1);
-        if (errno == EAGAIN || errno == EWOULDBLOCK) {
-            *select = 1;
-            return 0;
-        } else if (errno == EPIPE) {
-            *progress = 1;
-            *closed = 1;
-            return 0;
-        } else
-            return -1;
-    }
-}
-
-static int write_attempt(int fd, struct tunnelbuf *buf, int *select,
-                         int *closed, int *progress)
-{
-    int n, r;
-
-    DEBUG_MSG(&quot;write_attempt&quot;);
-    n = write(fd, buf-&gt;buf + buf-&gt;offset, buf-&gt;len);
-    DEBUG_MSG2(&quot;write&quot;, n);
-    r = get_error(n, select, closed, progress);
-    if (n &gt; 0) {
-        buf-&gt;len -= n;
-        assert(buf-&gt;len &gt;= 0);
-        if (buf-&gt;len == 0)
-            buf-&gt;offset = 0;
-        else
-            buf-&gt;offset += n;
-    }
-    if (r == -1)
-        tls_errprintf(1, tls_child_apparg, &quot;write error: %s\n&quot;,
-                      strerror(errno));
-    return r;
-}
-
-static int
-read_attempt(int fd, struct tunnelbuf *buf, int *select, int *closed,
-             int *progress)
-{
-    int n, r;
-    size_t total;
-
-    DEBUG_MSG(&quot;read_attempt&quot;);
-    total = buf-&gt;offset + buf-&gt;len;
-    assert(total &lt; sizeof buf-&gt;buf);
-    n = read(fd, buf-&gt;buf + total, (sizeof buf-&gt;buf) - total);
-    DEBUG_MSG2(&quot;read&quot;, n);
-    r = get_error(n, select, closed, progress);
-    if (n &gt; 0) {
-        buf-&gt;len += n;
-        assert(buf-&gt;offset + buf-&gt;len &lt;= sizeof buf-&gt;buf);
-    }
-    if (r == -1)
-        tls_errprintf(1, tls_child_apparg, &quot;read error: %s\n&quot;,
-                      strerror(errno));
-    return r;
-}
diff --git a/demos/easy_tls/easy-tls.h b/demos/easy_tls/easy-tls.h
deleted file mode 100644
index 3ec8d63..0000000
--- a/demos/easy_tls/easy-tls.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/* */
-/*-
- * easy-tls.h -- generic TLS proxy.
- * $Id: easy-tls.h,v 1.1 2001/09/17 19:06:59 bodo Exp $
- */
-/*
- * (c) Copyright 1999 Bodo Moeller.  All rights reserved.
- */
-
-#ifndef HEADER_TLS_H
-# define HEADER_TLS_H
-
-# ifndef HEADER_SSL_H
-typedef struct ssl_ctx_st SSL_CTX;
-# endif
-
-# define TLS_INFO_SIZE 512      /* max. # of bytes written to infofd */
-
-void tls_set_dhe1024(int i, void *apparg);
-/*
- * Generate DHE parameters: i &gt;= 0 deterministic (i selects seed), i &lt; 0
- * random (may take a while). tls_create_ctx calls this with random
- * non-negative i if the application has never called it.
- */
-
-void tls_rand_seed(void);
-int tls_rand_seed_from_file(const char *filename, size_t n, void *apparg);
-void tls_rand_seed_from_memory(const void *buf, size_t n);
-
-struct tls_create_ctx_args {
-    int client_p;
-    const char *certificate_file;
-    const char *key_file;
-    const char *ca_file;
-    int verify_depth;
-    int fail_unless_verified;
-};
-struct tls_create_ctx_args tls_create_ctx_defaultargs(void);
-/*
- * struct tls_create_ctx_args is similar to a conventional argument list, but
- * it can provide default values and allows for future extension.
- */
-SSL_CTX *tls_create_ctx(struct tls_create_ctx_args, void *apparg);
-
-struct tls_start_proxy_args {
-    int fd;
-    int client_p;
-    SSL_CTX *ctx;
-    pid_t *pid;
-    int *infofd;
-};
-struct tls_start_proxy_args tls_start_proxy_defaultargs(void);
-/*
- * tls_start_proxy return value *MUST* be checked! 0 means ok, otherwise
- * we've probably run out of some resources.
- */
-int tls_start_proxy(struct tls_start_proxy_args, void *apparg);
-
-#endif
diff --git a/demos/easy_tls/test.c b/demos/easy_tls/test.c
deleted file mode 100644
index 713da09..0000000
--- a/demos/easy_tls/test.c
+++ /dev/null
@@ -1,247 +0,0 @@
-/* $Id: test.c,v 1.1 2001/09/17 19:06:59 bodo Exp $ */
-
-#define L_PORT 9999
-#define C_PORT 443
-
-#include &lt;arpa/inet.h&gt;
-#include &lt;assert.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;netinet/in.h&gt;
-#include &lt;netinet/tcp.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;sys/select.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;unistd.h&gt;
-
-#include &quot;test.h&quot;
-#include &quot;easy-tls.h&quot;
-
-void test_process_init(int fd, int client_p, void *apparg)
-{
-    fprintf(stderr,
-            &quot;test_process_init(fd = %d, client_p = %d, apparg = %p)\n&quot;, fd,
-            client_p, apparg);
-}
-
-void test_errflush(int child_p, char *errbuf, size_t num, void *apparg)
-{
-    fputs(errbuf, stderr);
-}
-
-int main(int argc, char *argv[])
-{
-    int s, fd, r;
-    FILE *conn_in;
-    FILE *conn_out;
-    char buf[256];
-    SSL_CTX *ctx;
-    int client_p = 0;
-    int port;
-    int tls = 0;
-    char infobuf[TLS_INFO_SIZE + 1];
-
-    if (argc &gt; 1 &amp;&amp; argv[1][0] == '-') {
-        fputs(&quot;Usage: test [port]                   -- server\n&quot;
-              &quot;       test num.num.num.num [port]   -- client\n&quot;, stderr);
-        exit(1);
-    }
-
-    if (argc &gt; 1) {
-        if (strchr(argv[1], '.')) {
-            client_p = 1;
-        }
-    }
-
-    fputs(client_p ? &quot;Client\n&quot; : &quot;Server\n&quot;, stderr);
-
-    {
-        struct tls_create_ctx_args a = tls_create_ctx_defaultargs();
-        a.client_p = client_p;
-        a.certificate_file = &quot;cert.pem&quot;;
-        a.key_file = &quot;cert.pem&quot;;
-        a.ca_file = &quot;cacerts.pem&quot;;
-
-        ctx = tls_create_ctx(a, NULL);
-        if (ctx == NULL)
-            exit(1);
-    }
-
-    s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
-    if (s == -1) {
-        perror(&quot;socket&quot;);
-        exit(1);
-    }
-
-    if (client_p) {
-        struct sockaddr_in addr;
-        size_t addr_len = sizeof addr;
-
-        addr.sin_family = AF_INET;
-        assert(argc &gt; 1);
-        if (argc &gt; 2)
-            sscanf(argv[2], &quot;%d&quot;, &amp;port);
-        else
-            port = C_PORT;
-        addr.sin_port = htons(port);
-        addr.sin_addr.s_addr = inet_addr(argv[1]);
-
-        r = connect(s, &amp;addr, addr_len);
-        if (r != 0) {
-            perror(&quot;connect&quot;);
-            exit(1);
-        }
-        fd = s;
-        fprintf(stderr, &quot;Connect (fd = %d).\n&quot;, fd);
-    } else {
-        /* server */
-        {
-            int i = 1;
-
-            r = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;i, sizeof i);
-            if (r == -1) {
-                perror(&quot;setsockopt&quot;);
-                exit(1);
-            }
-        }
-
-        {
-            struct sockaddr_in addr;
-            size_t addr_len = sizeof addr;
-
-            if (argc &gt; 1)
-                sscanf(argv[1], &quot;%d&quot;, &amp;port);
-            else
-                port = L_PORT;
-            addr.sin_family = AF_INET;
-            addr.sin_port = htons(port);
-            addr.sin_addr.s_addr = INADDR_ANY;
-
-            r = bind(s, &amp;addr, addr_len);
-            if (r != 0) {
-                perror(&quot;bind&quot;);
-                exit(1);
-            }
-        }
-
-        r = listen(s, 1);
-        if (r == -1) {
-            perror(&quot;listen&quot;);
-            exit(1);
-        }
-
-        fprintf(stderr, &quot;Listening at port %i.\n&quot;, port);
-
-        fd = accept(s, NULL, 0);
-        if (fd == -1) {
-            perror(&quot;accept&quot;);
-            exit(1);
-        }
-
-        fprintf(stderr, &quot;Accept (fd = %d).\n&quot;, fd);
-    }
-
-    conn_in = fdopen(fd, &quot;r&quot;);
-    if (conn_in == NULL) {
-        perror(&quot;fdopen&quot;);
-        exit(1);
-    }
-    conn_out = fdopen(fd, &quot;w&quot;);
-    if (conn_out == NULL) {
-        perror(&quot;fdopen&quot;);
-        exit(1);
-    }
-
-    setvbuf(conn_in, NULL, _IOLBF, 256);
-    setvbuf(conn_out, NULL, _IOLBF, 256);
-
-    while (fgets(buf, sizeof buf, stdin) != NULL) {
-        if (buf[0] == 'W') {
-            fprintf(conn_out, &quot;%.*s\r\n&quot;, (int)(strlen(buf + 1) - 1),
-                    buf + 1);
-            fprintf(stderr, &quot;&gt;&gt;&gt; %.*s\n&quot;, (int)(strlen(buf + 1) - 1),
-                    buf + 1);
-        } else if (buf[0] == 'C') {
-            fprintf(stderr, &quot;Closing.\n&quot;);
-            fclose(conn_in);
-            fclose(conn_out);
-            exit(0);
-        } else if (buf[0] == 'R') {
-            int lines = 0;
-
-            sscanf(buf + 1, &quot;%d&quot;, &amp;lines);
-            do {
-                if (fgets(buf, sizeof buf, conn_in) == NULL) {
-                    if (ferror(conn_in)) {
-                        fprintf(stderr, &quot;ERROR\n&quot;);
-                        exit(1);
-                    }
-                    fprintf(stderr, &quot;CLOSED\n&quot;);
-                    return 0;
-                }
-                fprintf(stderr, &quot;&lt;&lt;&lt; %s&quot;, buf);
-            } while (--lines &gt; 0);
-        } else if (buf[0] == 'T') {
-            int infofd;
-
-            tls++;
-            {
-                struct tls_start_proxy_args a = tls_start_proxy_defaultargs();
-                a.fd = fd;
-                a.client_p = client_p;
-                a.ctx = ctx;
-                a.infofd = &infofd;
-                r = tls_start_proxy(a, NULL);
-            }
-            assert(r != 1);
-            if (r != 0) {
-                fprintf(stderr, &quot;tls_start_proxy failed: %d\n&quot;, r);
-                switch (r) {
-                case -1:
-                    fputs(&quot;socketpair&quot;, stderr);
-                    break;
-                case 2:
-                    fputs(&quot;FD_SETSIZE exceeded&quot;, stderr);
-                    break;
-                case -3:
-                    fputs(&quot;pipe&quot;, stderr);
-                    break;
-                case -4:
-                    fputs(&quot;fork&quot;, stderr);
-                    break;
-                case -5:
-                    fputs(&quot;dup2&quot;, stderr);
-                    break;
-                default:
-                    fputs(&quot;?&quot;, stderr);
-                }
-                if (r &lt; 0)
-                    perror(&quot;&quot;);
-                else
-                    fputc('\n', stderr);
-                exit(1);
-            }
-
-            r = read(infofd, infobuf, sizeof infobuf - 1);
-            if (r &gt; 0) {
-                const char *info = infobuf;
-                const char *eol;
-
-                infobuf[r] = '\0';
-                while ((eol = strchr(info, '\n')) != NULL) {
-                    fprintf(stderr, &quot;+++ `%.*s'\n&quot;, eol - info, info);
-                    info = eol + 1;
-                }
-                close(infofd);
-            }
-        } else {
-            fprintf(stderr, &quot;W...  write line to network\n&quot;
-                    &quot;R[n]  read line (n lines) from network\n&quot;
-                    &quot;C     close\n&quot;
-                    &quot;T     start %sTLS proxy\n&quot;, tls ? &quot;another &quot; : &quot;&quot;);
-        }
-    }
-    return 0;
-}
diff --git a/demos/easy_tls/test.h b/demos/easy_tls/test.h
deleted file mode 100644
index b30a605..0000000
--- a/demos/easy_tls/test.h
+++ /dev/null
@@ -1,9 +0,0 @@
-/* $Id: test.h,v 1.1 2001/09/17 19:07:00 bodo Exp $ */
-
-void test_process_init(int fd, int client_p, void *apparg);
-#define TLS_APP_PROCESS_INIT test_process_init
-
-#undef TLS_CUMULATE_ERRORS
-
-void test_errflush(int child_p, char *errbuf, size_t num, void *apparg);
-#define TLS_APP_ERRFLUSH test_errflush
diff --git a/demos/engines/cluster_labs/Makefile.in b/demos/engines/cluster_labs/Makefile.in
deleted file mode 100644
index af84275..0000000
--- a/demos/engines/cluster_labs/Makefile.in
+++ /dev/null
@@ -1,93 +0,0 @@
-LIBNAME=	libclabs
-SRC=		hw_cluster_labs.c
-OBJ=		hw_cluster_labs.o
-HEADER=		hw_cluster_labs.h
-
-CC=		gcc
-PIC=		-fPIC
-CFLAGS=		-g -I../../../include $(PIC) -DENGINE_DYNAMIC_SUPPORT -DFLAT_INC
-AR=		ar r
-RANLIB=		ranlib
-
-LIB=		$(LIBNAME).a
-SHLIB=		$(LIBNAME).so
-
-all:
-		@echo 'Please choose a system to build on:'
-		@echo ''
-		@echo 'tru64:    Tru64 Unix, Digital Unix, Digital OSF/1'
-		@echo 'solaris:  Solaris'
-		@echo 'irix:     IRIX'
-		@echo 'hpux32:   32-bit HP/UX'
-		@echo 'hpux64:   64-bit HP/UX'
-		@echo 'aix:      AIX'
-		@echo 'gnu:      Generic GNU-based system (gcc and GNU ld)'
-		@echo ''
-
-generate:
-		perl ../../../util/mkerr.pl -conf hw_cluster_labs.ec \
-			-nostatic -staticloader -write hw_cluster_labs.c
-
-gnu:		$(SHLIB).gnu
-tru64:		$(SHLIB).tru64
-solaris:	$(SHLIB).solaris
-irix:		$(SHLIB).irix
-hpux32:		$(SHLIB).hpux32
-hpux64:		$(SHLIB).hpux64
-aix:		$(SHLIB).aix
-
-$(LIB):		$(OBJ)
-		$(AR) $(LIB) $(OBJ)
-		- $(RANLIB) $(LIB)
-
-LINK_SO=	\
-  ld -r -o $(LIBNAME).o $$ALLSYMSFLAGS $(LIB) &amp;&amp; \
-  (nm -Pg $(LIBNAME).o | grep ' [BDT] ' | cut -f1 -d' ' &gt; $(LIBNAME).exp; \
-   $$SHAREDCMD $$SHAREDFLAGS -o $(SHLIB) $(LIBNAME).o -L ../../.. -lcrypto -lc)
-
-$(SHLIB).gnu:	$(LIB)
-		ALLSYMSFLAGS='--whole-archive' \
-		SHAREDFLAGS='-shared -Wl,-soname=$(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).gnu
-$(SHLIB).tru64:	$(LIB)
-		ALLSYMSFLAGS='-all' \
-		SHAREDFLAGS='-shared' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).tru64
-$(SHLIB).solaris:	$(LIB)
-		ALLSYMSFLAGS='-z allextract' \
-		SHAREDFLAGS='-G -h $(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).solaris
-$(SHLIB).irix:	$(LIB)
-		ALLSYMSFLAGS='-all' \
-		SHAREDFLAGS='-shared -Wl,-soname,$(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).irix
-$(SHLIB).hpux32:	$(LIB)
-		ALLSYMSFLAGS='-Fl' \
-		SHAREDFLAGS='+vnocompatwarnings -b -z +s +h $(SHLIB)' \
-		SHAREDCMD='/usr/ccs/bin/ld'; \
-		$(LINK_SO)
-		touch $(SHLIB).hpux32
-$(SHLIB).hpux64:	$(LIB)
-		ALLSYMSFLAGS='+forceload' \
-		SHAREDFLAGS='-b -z +h $(SHLIB)' \
-		SHAREDCMD='/usr/ccs/bin/ld'; \
-		$(LINK_SO)
-		touch $(SHLIB).hpux64
-$(SHLIB).aix:	$(LIB)
-		ALLSYMSFLAGS='-bnogc' \
-		SHAREDFLAGS='-G -bE:$(LIBNAME).exp -bM:SRE' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).aix
-
-depend:
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
diff --git a/demos/engines/cluster_labs/cluster_labs.h b/demos/engines/cluster_labs/cluster_labs.h
deleted file mode 100644
index d024d91..0000000
--- a/demos/engines/cluster_labs/cluster_labs.h
+++ /dev/null
@@ -1,33 +0,0 @@
-typedef int cl_engine_init(void);
-typedef int cl_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                       const BIGNUM *m, BN_CTX *cgx);
-typedef int cl_mod_exp_crt(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
-                           const BIGNUM *q, const BIGNUM *dmp1,
-                           const BIGNUM *dmq1, const BIGNUM *iqmp,
-                           BN_CTX *ctx);
-typedef int cl_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa);
-typedef int cl_rsa_pub_enc(int flen, const unsigned char *from,
-                           unsigned char *to, RSA *rsa, int padding);
-typedef int cl_rsa_pub_dec(int flen, const unsigned char *from,
-                           unsigned char *to, RSA *rsa, int padding);
-typedef int cl_rsa_priv_enc(int flen, const unsigned char *from,
-                            unsigned char *to, RSA *rsa, int padding);
-typedef int cl_rsa_priv_dec(int flen, const unsigned char *from,
-                            unsigned char *to, RSA *rsa, int padding);
-typedef int cl_rand_bytes(unsigned char *buf, int num);
-typedef DSA_SIG *cl_dsa_sign(const unsigned char *dgst, int dlen, DSA *dsa);
-typedef int cl_dsa_verify(const unsigned char *dgst, int dgst_len,
-                          DSA_SIG *sig, DSA *dsa);
-
-static const char *CLUSTER_LABS_LIB_NAME = &quot;cluster_labs&quot;;
-static const char *CLUSTER_LABS_F1 = &quot;hw_engine_init&quot;;
-static const char *CLUSTER_LABS_F2 = &quot;hw_mod_exp&quot;;
-static const char *CLUSTER_LABS_F3 = &quot;hw_mod_exp_crt&quot;;
-static const char *CLUSTER_LABS_F4 = &quot;hw_rsa_mod_exp&quot;;
-static const char *CLUSTER_LABS_F5 = &quot;hw_rsa_priv_enc&quot;;
-static const char *CLUSTER_LABS_F6 = &quot;hw_rsa_priv_dec&quot;;
-static const char *CLUSTER_LABS_F7 = &quot;hw_rsa_pub_enc&quot;;
-static const char *CLUSTER_LABS_F8 = &quot;hw_rsa_pub_dec&quot;;
-static const char *CLUSTER_LABS_F20 = &quot;hw_rand_bytes&quot;;
-static const char *CLUSTER_LABS_F30 = &quot;hw_dsa_sign&quot;;
-static const char *CLUSTER_LABS_F31 = &quot;hw_dsa_verify&quot;;
diff --git a/demos/engines/cluster_labs/hw_cluster_labs.c b/demos/engines/cluster_labs/hw_cluster_labs.c
deleted file mode 100644
index 8353dd9..0000000
--- a/demos/engines/cluster_labs/hw_cluster_labs.c
+++ /dev/null
@@ -1,684 +0,0 @@
-/*
- * Written by Jan Tschirschwitz (<A HREF="../../../mailman/listinfo/openssl-commits.html">jan.tschirschwitz at cluster-labs.com</A> for the
- * OpenSSL project 2000.
- */
-/* ====================================================================
- * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">licensing at OpenSSL.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-#define MSC_VER                 /* only used cryptic.h */
-
-#include &lt;stdio.h&gt;
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/dso.h&gt;
-#include &lt;openssl/des.h&gt;
-#include &lt;openssl/engine.h&gt;
-
-#ifndef NO_HW
-# ifndef NO_HW_CLUSTER_LABS
-
-#  ifdef FLAT_INC
-#   include &quot;cluster_labs.h&quot;
-#  else
-#   include &quot;vendor_defns/cluster_labs.h&quot;
-#  endif
-
-#  define CL_LIB_NAME &quot;cluster_labs engine&quot;
-#  include &quot;hw_cluster_labs_err.c&quot;
-
-static int cluster_labs_destroy(ENGINE *e);
-static int cluster_labs_init(ENGINE *e);
-static int cluster_labs_finish(ENGINE *e);
-static int cluster_labs_ctrl(ENGINE *e, int cmd, long i, void *p,
-                             void (*f) ());
-
-/* BIGNUM stuff */
-/* This function is aliased to mod_exp (with the mont stuff dropped). */
-static int cluster_labs_mod_exp_mont(BIGNUM *r, const BIGNUM *a,
-                                     const BIGNUM *p, const BIGNUM *m,
-                                     BN_CTX *ctx, BN_MONT_CTX *m_ctx);
-
-/* RSA stuff */
-#  ifndef OPENSSL_NO_RSA
-static int cluster_labs_rsa_pub_enc(int flen, const unsigned char *from,
-                                    unsigned char *to, RSA *rsa, int padding);
-static int cluster_labs_rsa_pub_dec(int flen, const unsigned char *from,
-                                    unsigned char *to, RSA *rsa, int padding);
-static int cluster_labs_rsa_priv_enc(int flen, const unsigned char *from,
-                                     unsigned char *to, RSA *rsa,
-                                     int padding);
-static int cluster_labs_rsa_priv_dec(int flen, const unsigned char *from,
-                                     unsigned char *to, RSA *rsa,
-                                     int padding);
-static int cluster_labs_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa);
-#  endif
-
-/* DSA stuff */
-#  ifndef OPENSSL_NO_DSA
-static DSA_SIG *cluster_labs_dsa_sign(const unsigned char *dgst, int dlen,
-                                      DSA *dsa);
-static int cluster_labs_dsa_verify(const unsigned char *dgst, int dgst_len,
-                                   DSA_SIG *sig, DSA *dsa);
-static int cluster_labs_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,
-                                    BIGNUM *p1, BIGNUM *a2, BIGNUM *p2,
-                                    BIGNUM *m, BN_CTX *ctx,
-                                    BN_MONT_CTX *in_mont);
-static int cluster_labs_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,
-                                    const BIGNUM *p, const BIGNUM *m,
-                                    BN_CTX *ctx, BN_MONT_CTX *m_ctx);
-#  endif
-
-/* DH stuff */
-#  ifndef OPENSSL_NO_DH
-/* This function is alised to mod_exp (with the DH and mont dropped). */
-static int cluster_labs_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,
-                                   const BIGNUM *p, const BIGNUM *m,
-                                   BN_CTX *ctx, BN_MONT_CTX *m_ctx);
-#  endif
-
-/* RANDOM stuff */
-static int cluster_labs_rand_bytes(unsigned char *buf, int num);
-
-/* The definitions for control commands specific to this engine */
-#  define CLUSTER_LABS_CMD_SO_PATH                ENGINE_CMD_BASE
-static const ENGINE_CMD_DEFN cluster_labs_cmd_defns[] = {
-    {CLUSTER_LABS_CMD_SO_PATH,
-     &quot;SO_PATH&quot;,
-     &quot;Specifies the path to the 'cluster labs' shared library&quot;,
-     ENGINE_CMD_FLAG_STRING},
-    {0, NULL, NULL, 0}
-};
-
-/* Our internal RSA_METHOD that we provide pointers to */
-#  ifndef OPENSSL_NO_RSA
-static RSA_METHOD cluster_labs_rsa = {
-    &quot;Cluster Labs RSA method&quot;,
-    cluster_labs_rsa_pub_enc,   /* rsa_pub_enc */
-    cluster_labs_rsa_pub_dec,   /* rsa_pub_dec */
-    cluster_labs_rsa_priv_enc,  /* rsa_priv_enc */
-    cluster_labs_rsa_priv_dec,  /* rsa_priv_dec */
-    cluster_labs_rsa_mod_exp,   /* rsa_mod_exp */
-    cluster_labs_mod_exp_mont,  /* bn_mod_exp */
-    NULL,                       /* init */
-    NULL,                       /* finish */
-    0,                          /* flags */
-    NULL,                       /* apps_data */
-    NULL,                       /* rsa_sign */
-    NULL                        /* rsa_verify */
-};
-#  endif
-
-/* Our internal DSA_METHOD that we provide pointers to */
-#  ifndef OPENSSL_NO_DSA
-static DSA_METHOD cluster_labs_dsa = {
-    &quot;Cluster Labs DSA method&quot;,
-    cluster_labs_dsa_sign,      /* dsa_do_sign */
-    NULL,                       /* dsa_sign_setup */
-    cluster_labs_dsa_verify,    /* dsa_do_verify */
-    cluster_labs_dsa_mod_exp,   /* dsa_mod_exp */
-    cluster_labs_mod_exp_dsa,   /* bn_mod_exp */
-    NULL,                       /* init */
-    NULL,                       /* finish */
-    0,                          /* flags */
-    NULL                        /* app_data */
-};
-#  endif
-
-/* Our internal DH_METHOD that we provide pointers to */
-#  ifndef OPENSSL_NO_DH
-static DH_METHOD cluster_labs_dh = {
-    &quot;Cluster Labs DH method&quot;,
-    NULL,                       /* generate key */
-    NULL,                       /* compute key */
-    cluster_labs_mod_exp_dh,    /* bn_mod_exp */
-    NULL,                       /* init */
-    NULL,                       /* finish */
-    0,                          /* flags */
-    NULL                        /* app_data */
-};
-#  endif
-
-static RAND_METHOD cluster_labs_rand = {
-    /* &quot;Cluster Labs RAND method&quot;, */
-    NULL,                       /* seed */
-    cluster_labs_rand_bytes,    /* bytes */
-    NULL,                       /* cleanup */
-    NULL,                       /* add */
-    cluster_labs_rand_bytes,    /* pseudorand */
-    NULL,                       /* status */
-};
-
-static const char *engine_cluster_labs_id = &quot;cluster_labs&quot;;
-static const char *engine_cluster_labs_name =
-    &quot;Cluster Labs hardware engine support&quot;;
-
-/* engine implementation */
-/* ---------------------*/
-static int bind_helper(ENGINE *e)
-{
-
-    if (!ENGINE_set_id(e, engine_cluster_labs_id) ||
-        !ENGINE_set_name(e, engine_cluster_labs_name) ||
-#  ifndef OPENSSL_NO_RSA
-        !ENGINE_set_RSA(e, &amp;cluster_labs_rsa) ||
-#  endif
-#  ifndef OPENSSL_NO_DSA
-        !ENGINE_set_DSA(e, &amp;cluster_labs_dsa) ||
-#  endif
-#  ifndef OPENSSL_NO_DH
-        !ENGINE_set_DH(e, &amp;cluster_labs_dh) ||
-#  endif
-        !ENGINE_set_RAND(e, &amp;cluster_labs_rand) ||
-        !ENGINE_set_destroy_function(e, cluster_labs_destroy) ||
-        !ENGINE_set_init_function(e, cluster_labs_init) ||
-        !ENGINE_set_finish_function(e, cluster_labs_finish) ||
-        !ENGINE_set_ctrl_function(e, cluster_labs_ctrl) ||
-        !ENGINE_set_cmd_defns(e, cluster_labs_cmd_defns))
-        return 0;
-    /* Ensure the error handling is set up */
-    ERR_load_CL_strings();
-    return 1;
-}
-
-#  ifndef ENGINE_DYNAMIC_SUPPORT
-static ENGINE *engine_cluster_labs(void)
-{
-    ENGINE *ret = ENGINE_new();
-
-    if (!ret)
-        return NULL;
-    if (!bind_helper(ret)) {
-        ENGINE_free(ret);
-        return NULL;
-    }
-    return ret;
-}
-
-#   ifdef ENGINE_DYNAMIC_SUPPORT
-static
-#   endif
-void ENGINE_load_cluster_labs(void)
-{
-
-    ENGINE *cluster_labs = engine_cluster_labs();
-
-    if (!cluster_labs)
-        return;
-    ENGINE_add(cluster_labs);
-    ENGINE_free(cluster_labs);
-    ERR_clear_error();
-}
-#  endif                        /* !ENGINE_DYNAMIC_SUPPORT */
-
-static int cluster_labs_destroy(ENGINE *e)
-{
-
-    ERR_unload_CL_strings();
-    return 1;
-}
-
-/*
- * This is a process-global DSO handle used for loading and unloading the
- * Cluster Labs library. NB: This is only set (or unset) during an init() or
- * finish() call (reference counts permitting) and they're operating with
- * global locks, so this should be thread-safe implicitly.
- */
-static DSO *cluster_labs_dso = NULL;
-
-/*
- * These are the function pointers that are (un)set when the library has
- * successfully (un)loaded.
- */
-static cl_engine_init *p_cl_engine_init = NULL;
-static cl_mod_exp *p_cl_mod_exp = NULL;
-static cl_mod_exp_crt *p_cl_mod_exp_crt = NULL;
-static cl_rsa_mod_exp *p_cl_rsa_mod_exp = NULL;
-static cl_rsa_priv_enc *p_cl_rsa_priv_enc = NULL;
-static cl_rsa_priv_dec *p_cl_rsa_priv_dec = NULL;
-static cl_rsa_pub_enc *p_cl_rsa_pub_enc = NULL;
-static cl_rsa_pub_dec *p_cl_rsa_pub_dec = NULL;
-static cl_rand_bytes *p_cl_rand_bytes = NULL;
-static cl_dsa_sign *p_cl_dsa_sign = NULL;
-static cl_dsa_verify *p_cl_dsa_verify = NULL;
-
-int cluster_labs_init(ENGINE *e)
-{
-
-    cl_engine_init *p1;
-    cl_mod_exp *p2;
-    cl_mod_exp_crt *p3;
-    cl_rsa_mod_exp *p4;
-    cl_rsa_priv_enc *p5;
-    cl_rsa_priv_dec *p6;
-    cl_rsa_pub_enc *p7;
-    cl_rsa_pub_dec *p8;
-    cl_rand_bytes *p20;
-    cl_dsa_sign *p30;
-    cl_dsa_verify *p31;
-
-    /* engine already loaded */
-    if (cluster_labs_dso != NULL) {
-        CLerr(CL_F_CLUSTER_LABS_INIT, CL_R_ALREADY_LOADED);
-        goto err;
-    }
-    /* try to load engine    */
-    cluster_labs_dso = DSO_load(NULL, CLUSTER_LABS_LIB_NAME, NULL, 0);
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_INIT, CL_R_DSO_FAILURE);
-        goto err;
-    }
-    /* bind functions */
-#define BINDIT(t, name) (t *)DSO_bind_func(cluster_labs_dso, name)
-    if ((p1 = (cl_engine_init, CLUSTER_LABS_F1)) == NULL
-        || (p2 = BINDIT(cl_mod_exp, CLUSTER_LABS_F2)) == NULL
-        || (p3 = BINDIT(cl_mod_exp_crt, CLUSTER_LABS_F3)) == NULL
-        || (p4 = BINDIT(cl_rsa_mod_exp, CLUSTER_LABS_F4)) == NULL
-        || (p5 = BINDIT(cl_rsa_priv_enc, CLUSTER_LABS_F5)) == NULL
-        || (p6 = BINDIT(cl_rsa_priv_dec, CLUSTER_LABS_F6)) == NULL
-        || (p7 = BINDIT(cl_rsa_pub_enc, CLUSTER_LABS_F7)) == NULL
-        || (p8 = BINDIT(cl_rsa_pub_dec, CLUSTER_LABS_F8)) == NULL
-        || (p20 = BINDIT(cl_rand_bytes, CLUSTER_LABS_F20)) == NULL
-        || (p30 = BINDIT(cl_dsa_sign, CLUSTER_LABS_F30)) == NULL
-        || (p31 = BINDIT(cl_dsa_verify, CLUSTER_LABS_F31)) == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_INIT, CL_R_DSO_FAILURE);
-        goto err;
-    }
-
-    /* copy function pointers */
-    p_cl_engine_init = p1;
-    p_cl_mod_exp = p2;
-    p_cl_mod_exp_crt = p3;
-    p_cl_rsa_mod_exp = p4;
-    p_cl_rsa_priv_enc = p5;
-    p_cl_rsa_priv_dec = p6;
-    p_cl_rsa_pub_enc = p7;
-    p_cl_rsa_pub_dec = p8;
-    p_cl_rand_bytes = p20;
-    p_cl_dsa_sign = p30;
-    p_cl_dsa_verify = p31;
-
-    /* cluster labs engine init */
-    if (p_cl_engine_init() == 0) {
-        CLerr(CL_F_CLUSTER_LABS_INIT, CL_R_INIT_FAILED);
-        goto err;
-    }
-
-    return (1);
-
- err:
-    /* reset all pointers */
-    DSO_free(cluster_labs_dso);
-    cluster_labs_dso = NULL;
-    p_cl_engine_init = NULL;
-    p_cl_mod_exp = NULL;
-    p_cl_mod_exp_crt = NULL;
-    p_cl_rsa_mod_exp = NULL;
-    p_cl_rsa_priv_enc = NULL;
-    p_cl_rsa_priv_dec = NULL;
-    p_cl_rsa_pub_enc = NULL;
-    p_cl_rsa_pub_dec = NULL;
-    p_cl_rand_bytes = NULL;
-    p_cl_dsa_sign = NULL;
-    p_cl_dsa_verify = NULL;
-
-    return (0);
-}
-
-static int cluster_labs_finish(ENGINE *e)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_FINISH, CL_R_NOT_LOADED);
-        return 0;
-    }
-    if (!DSO_free(cluster_labs_dso)) {
-        CLerr(CL_F_CLUSTER_LABS_FINISH, CL_R_DSO_FAILURE);
-        return 0;
-    }
-
-    cluster_labs_dso = NULL;
-    p_cl_engine_init = NULL;
-    p_cl_mod_exp = NULL;
-    p_cl_rsa_mod_exp = NULL;
-    p_cl_mod_exp_crt = NULL;
-    p_cl_rsa_priv_enc = NULL;
-    p_cl_rsa_priv_dec = NULL;
-    p_cl_rsa_pub_enc = NULL;
-    p_cl_rsa_pub_dec = NULL;
-    p_cl_rand_bytes = NULL;
-    p_cl_dsa_sign = NULL;
-    p_cl_dsa_verify = NULL;
-
-    return (1);
-
-}
-
-static int cluster_labs_ctrl(ENGINE *e, int cmd, long i, void *p,
-                             void (*f) ())
-{
-    int initialised = ((cluster_labs_dso == NULL) ? 0 : 1);
-
-    switch (cmd) {
-    case CLUSTER_LABS_CMD_SO_PATH:
-        if (p == NULL) {
-            CLerr(CL_F_CLUSTER_LABS_CTRL, ERR_R_PASSED_NULL_PARAMETER);
-            return 0;
-        }
-        if (initialised) {
-            CLerr(CL_F_CLUSTER_LABS_CTRL, CL_R_ALREADY_LOADED);
-            return 0;
-        }
-        CLUSTER_LABS_LIB_NAME = (const char *)p;
-        return 1;
-    default:
-        break;
-    }
-    CLerr(CL_F_CLUSTER_LABS_CTRL, CL_R_COMMAND_NOT_IMPLEMENTED);
-    return 0;
-}
-
-static int cluster_labs_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                                const BIGNUM *m, BN_CTX *ctx)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_MOD_EXP, CL_R_NOT_LOADED);
-        return 0;
-    }
-    if (p_cl_mod_exp == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_MOD_EXP, CL_R_FUNCTION_NOT_BINDED);
-        return 0;
-    }
-
-    return p_cl_mod_exp(r, a, p, m, ctx);
-
-}
-
-static int cluster_labs_mod_exp_crt(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
-                                    const BIGNUM *q, const BIGNUM *dmp1,
-                                    const BIGNUM *dmq1, const BIGNUM *iqmp,
-                                    BN_CTX *ctx)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_MOD_EXP_CRT, CL_R_NOT_LOADED);
-        return 0;
-    }
-    if (p_cl_mod_exp_crt == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_MOD_EXP_CRT, CL_R_FUNCTION_NOT_BINDED);
-        return 0;
-    }
-
-    return p_cl_mod_exp_crt(r, a, p, q, dmp1, dmq1, iqmp, ctx);
-
-}
-
-static int cluster_labs_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RSA_MOD_EXP, CL_R_NOT_LOADED);
-        return 0;
-    }
-    if (p_cl_rsa_mod_exp == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RSA_MOD_EXP, CL_R_FUNCTION_NOT_BINDED);
-        return 0;
-    }
-
-    return p_cl_rsa_mod_exp(r0, I, rsa);
-
-}
-
-static DSA_SIG *cluster_labs_dsa_sign(const unsigned char *dgst, int dlen,
-                                      DSA *dsa)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_DSA_SIGN, CL_R_NOT_LOADED);
-        return 0;
-    }
-    if (p_cl_dsa_sign == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_DSA_SIGN, CL_R_FUNCTION_NOT_BINDED);
-        return 0;
-    }
-
-    return p_cl_dsa_sign(dgst, dlen, dsa);
-
-}
-
-static int cluster_labs_dsa_verify(const unsigned char *dgst, int dgst_len,
-                                   DSA_SIG *sig, DSA *dsa)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_DSA_VERIFY, CL_R_NOT_LOADED);
-        return 0;
-    }
-
-    if (p_cl_dsa_verify == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_DSA_VERIFY, CL_R_FUNCTION_NOT_BINDED);
-        return 0;
-    }
-
-    return p_cl_dsa_verify(dgst, dgst_len, sig, dsa);
-
-}
-
-static int cluster_labs_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,
-                                    BIGNUM *p1, BIGNUM *a2, BIGNUM *p2,
-                                    BIGNUM *m, BN_CTX *ctx,
-                                    BN_MONT_CTX *in_mont)
-{
-    BIGNUM t;
-    int status = 0;
-
-    BN_init(&amp;t);
-    /* let rr = a1 ^ p1 mod m */
-    if (!cluster_labs_mod_exp(rr, a1, p1, m, ctx))
-        goto end;
-    /* let t = a2 ^ p2 mod m */
-    if (!cluster_labs_mod_exp(&amp;t, a2, p2, m, ctx))
-        goto end;
-    /* let rr = rr * t mod m */
-    if (!BN_mod_mul(rr, rr, &amp;t, m, ctx))
-        goto end;
-    status = 1;
- end:
-    BN_free(&amp;t);
-
-    return (1);
-
-}
-
-static int cluster_labs_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,
-                                    const BIGNUM *p, const BIGNUM *m,
-                                    BN_CTX *ctx, BN_MONT_CTX *m_ctx)
-{
-    return cluster_labs_mod_exp(r, a, p, m, ctx);
-}
-
-/* This function is aliased to mod_exp (with the mont stuff dropped). */
-static int cluster_labs_mod_exp_mont(BIGNUM *r, const BIGNUM *a,
-                                     const BIGNUM *p, const BIGNUM *m,
-                                     BN_CTX *ctx, BN_MONT_CTX *m_ctx)
-{
-    return cluster_labs_mod_exp(r, a, p, m, ctx);
-}
-
-/* This function is aliased to mod_exp (with the dh and mont dropped). */
-static int cluster_labs_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,
-                                   const BIGNUM *p, const BIGNUM *m,
-                                   BN_CTX *ctx, BN_MONT_CTX *m_ctx)
-{
-    return cluster_labs_mod_exp(r, a, p, m, ctx);
-}
-
-static int cluster_labs_rsa_pub_enc(int flen, const unsigned char *from,
-                                    unsigned char *to, RSA *rsa, int padding)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RSA_PUB_ENC, CL_R_NOT_LOADED);
-        return 0;
-    }
-    if (p_cl_rsa_priv_enc == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RSA_PUB_ENC, CL_R_FUNCTION_NOT_BINDED);
-        return 0;
-    }
-
-    return p_cl_rsa_pub_enc(flen, from, to, rsa, padding);
-
-}
-
-static int cluster_labs_rsa_pub_dec(int flen, const unsigned char *from,
-                                    unsigned char *to, RSA *rsa, int padding)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RSA_PUB_DEC, CL_R_NOT_LOADED);
-        return 0;
-    }
-    if (p_cl_rsa_priv_enc == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RSA_PUB_DEC, CL_R_FUNCTION_NOT_BINDED);
-        return 0;
-    }
-
-    return p_cl_rsa_pub_dec(flen, from, to, rsa, padding);
-
-}
-
-static int cluster_labs_rsa_priv_enc(int flen, const unsigned char *from,
-                                     unsigned char *to, RSA *rsa, int padding)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RSA_PRIV_ENC, CL_R_NOT_LOADED);
-        return 0;
-    }
-
-    if (p_cl_rsa_priv_enc == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RSA_PRIV_ENC, CL_R_FUNCTION_NOT_BINDED);
-        return 0;
-    }
-
-    return p_cl_rsa_priv_enc(flen, from, to, rsa, padding);
-
-}
-
-static int cluster_labs_rsa_priv_dec(int flen, const unsigned char *from,
-                                     unsigned char *to, RSA *rsa, int padding)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RSA_PRIV_DEC, CL_R_NOT_LOADED);
-        return 0;
-    }
-    if (p_cl_rsa_priv_dec == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RSA_PRIV_DEC, CL_R_FUNCTION_NOT_BINDED);
-        return 0;
-    }
-
-    return p_cl_rsa_priv_dec(flen, from, to, rsa, padding);
-
-}
-
-/************************************************************************************
-* Symmetric algorithms
-************************************************************************************/
-/* this will be come soon! */
-
-/************************************************************************************
-* Random generator
-************************************************************************************/
-
-static int cluster_labs_rand_bytes(unsigned char *buf, int num)
-{
-
-    if (cluster_labs_dso == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RAND_BYTES, CL_R_NOT_LOADED);
-        return 0;
-    }
-    if (p_cl_mod_exp_crt == NULL) {
-        CLerr(CL_F_CLUSTER_LABS_RAND_BYTES, CL_R_FUNCTION_NOT_BINDED);
-        return 0;
-    }
-
-    return p_cl_rand_bytes(buf, num);
-
-}
-
-/*
- * This stuff is needed if this ENGINE is being compiled into a
- * self-contained shared-library.
- */
-#  ifdef ENGINE_DYNAMIC_SUPPORT
-static int bind_fn(ENGINE *e, const char *id)
-{
-    fprintf(stderr, &quot;bind_fn CLUSTER_LABS\n&quot;);
-    if (id &amp;&amp; (strcmp(id, engine_cluster_labs_id) != 0)) {
-        fprintf(stderr, &quot;bind_fn return(0) first\n&quot;);
-        return 0;
-    }
-    if (!bind_helper(e)) {
-        fprintf(stderr, &quot;bind_fn return(1) first\n&quot;);
-        return 0;
-    }
-    fprintf(stderr, &quot;bind_fn return(1)\n&quot;);
-    return 1;
-}
-
-IMPLEMENT_DYNAMIC_CHECK_FN()
-    IMPLEMENT_DYNAMIC_BIND_FN(bind_fn)
-#  endif                        /* ENGINE_DYNAMIC_SUPPORT */
-# endif                         /* !NO_HW_CLUSTER_LABS */
-#endif                          /* !NO_HW */
diff --git a/demos/engines/cluster_labs/hw_cluster_labs.ec b/demos/engines/cluster_labs/hw_cluster_labs.ec
deleted file mode 100644
index 1f64786..0000000
--- a/demos/engines/cluster_labs/hw_cluster_labs.ec
+++ /dev/null
@@ -1,8 +0,0 @@
-# configuration file for util/mkerr.pl
-#
-# use like this:
-#
-#	perl ../../../util/mkerr.pl -conf hw_cluster_labs.ec \
-#		-nostatic -staticloader -write *.c
-
-L CL		hw_cluster_labs_err.h		hw_cluster_labs_err.c
diff --git a/demos/engines/cluster_labs/hw_cluster_labs_err.c b/demos/engines/cluster_labs/hw_cluster_labs_err.c
deleted file mode 100644
index b2cfdd3..0000000
--- a/demos/engines/cluster_labs/hw_cluster_labs_err.c
+++ /dev/null
@@ -1,151 +0,0 @@
-/* ====================================================================
- * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at OpenSSL.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-/*
- * NOTE: this file was auto generated by the mkerr.pl script: any changes
- * made to it will be overwritten when the script next updates this file,
- * only reason strings will be preserved.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &quot;hw_cluster_labs_err.h&quot;
-
-/* BEGIN ERROR CODES */
-#ifndef OPENSSL_NO_ERR
-static ERR_STRING_DATA CL_str_functs[] = {
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_CTRL, 0), &quot;CLUSTER_LABS_CTRL&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_DSA_SIGN, 0), &quot;CLUSTER_LABS_DSA_SIGN&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_DSA_VERIFY, 0), &quot;CLUSTER_LABS_DSA_VERIFY&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_FINISH, 0), &quot;CLUSTER_LABS_FINISH&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_INIT, 0), &quot;CLUSTER_LABS_INIT&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_MOD_EXP, 0), &quot;CLUSTER_LABS_MOD_EXP&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_MOD_EXP_CRT, 0),
-     &quot;CLUSTER_LABS_MOD_EXP_CRT&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_RAND_BYTES, 0), &quot;CLUSTER_LABS_RAND_BYTES&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_RSA_MOD_EXP, 0),
-     &quot;CLUSTER_LABS_RSA_MOD_EXP&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_RSA_PRIV_DEC, 0),
-     &quot;CLUSTER_LABS_RSA_PRIV_DEC&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_RSA_PRIV_ENC, 0),
-     &quot;CLUSTER_LABS_RSA_PRIV_ENC&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_RSA_PUB_DEC, 0),
-     &quot;CLUSTER_LABS_RSA_PUB_DEC&quot;},
-    {ERR_PACK(0, CL_F_CLUSTER_LABS_RSA_PUB_ENC, 0),
-     &quot;CLUSTER_LABS_RSA_PUB_ENC&quot;},
-    {0, NULL}
-};
-
-static ERR_STRING_DATA CL_str_reasons[] = {
-    {CL_R_ALREADY_LOADED, &quot;already loaded&quot;},
-    {CL_R_COMMAND_NOT_IMPLEMENTED, &quot;command not implemented&quot;},
-    {CL_R_DSO_FAILURE, &quot;dso failure&quot;},
-    {CL_R_FUNCTION_NOT_BINDED, &quot;function not binded&quot;},
-    {CL_R_INIT_FAILED, &quot;init failed&quot;},
-    {CL_R_NOT_LOADED, &quot;not loaded&quot;},
-    {0, NULL}
-};
-
-#endif
-
-#ifdef CL_LIB_NAME
-static ERR_STRING_DATA CL_lib_name[] = {
-    {0, CL_LIB_NAME},
-    {0, NULL}
-};
-#endif
-
-static int CL_lib_error_code = 0;
-static int CL_error_init = 1;
-
-static void ERR_load_CL_strings(void)
-{
-    if (CL_lib_error_code == 0)
-        CL_lib_error_code = ERR_get_next_error_library();
-
-    if (CL_error_init) {
-        CL_error_init = 0;
-#ifndef OPENSSL_NO_ERR
-        ERR_load_strings(CL_lib_error_code, CL_str_functs);
-        ERR_load_strings(CL_lib_error_code, CL_str_reasons);
-#endif
-
-#ifdef CL_LIB_NAME
-        CL_lib_name-&gt;error = ERR_PACK(CL_lib_error_code, 0, 0);
-        ERR_load_strings(0, CL_lib_name);
-#endif
-    }
-}
-
-static void ERR_unload_CL_strings(void)
-{
-    if (CL_error_init == 0) {
-#ifndef OPENSSL_NO_ERR
-        ERR_unload_strings(CL_lib_error_code, CL_str_functs);
-        ERR_unload_strings(CL_lib_error_code, CL_str_reasons);
-#endif
-
-#ifdef CL_LIB_NAME
-        ERR_unload_strings(0, CL_lib_name);
-#endif
-        CL_error_init = 1;
-    }
-}
-
-static void ERR_CL_error(int function, int reason, char *file, int line)
-{
-    if (CL_lib_error_code == 0)
-        CL_lib_error_code = ERR_get_next_error_library();
-    ERR_PUT_error(CL_lib_error_code, function, reason, file, line);
-}
diff --git a/demos/engines/cluster_labs/hw_cluster_labs_err.h b/demos/engines/cluster_labs/hw_cluster_labs_err.h
deleted file mode 100644
index e9e58d5..0000000
--- a/demos/engines/cluster_labs/hw_cluster_labs_err.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/* ====================================================================
- * Copyright (c) 2001-2002 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-#ifndef HEADER_CL_ERR_H
-# define HEADER_CL_ERR_H
-
-#ifdef  __cplusplus
-extern &quot;C&quot; {
-#endif
-
-/* BEGIN ERROR CODES */
-/*
- * The following lines are auto generated by the script mkerr.pl. Any changes
- * made after this point may be overwritten when the script is next run.
- */
-static void ERR_load_CL_strings(void);
-static void ERR_unload_CL_strings(void);
-static void ERR_CL_error(int function, int reason, char *file, int line);
-# define CLerr(f,r) ERR_CL_error((f),(r),OPENSSL_FILE,OPENSSL_LINE)
-
-/* Error codes for the CL functions. */
-
-/* Function codes. */
-# define CL_F_CLUSTER_LABS_CTRL                           100
-# define CL_F_CLUSTER_LABS_DSA_SIGN                       101
-# define CL_F_CLUSTER_LABS_DSA_VERIFY                     102
-# define CL_F_CLUSTER_LABS_FINISH                         103
-# define CL_F_CLUSTER_LABS_INIT                           104
-# define CL_F_CLUSTER_LABS_MOD_EXP                        105
-# define CL_F_CLUSTER_LABS_MOD_EXP_CRT                    106
-# define CL_F_CLUSTER_LABS_RAND_BYTES                     107
-# define CL_F_CLUSTER_LABS_RSA_MOD_EXP                    108
-# define CL_F_CLUSTER_LABS_RSA_PRIV_DEC                   109
-# define CL_F_CLUSTER_LABS_RSA_PRIV_ENC                   110
-# define CL_F_CLUSTER_LABS_RSA_PUB_DEC                    111
-# define CL_F_CLUSTER_LABS_RSA_PUB_ENC                    112
-
-/* Reason codes. */
-# define CL_R_ALREADY_LOADED                              100
-# define CL_R_COMMAND_NOT_IMPLEMENTED                     101
-# define CL_R_DSO_FAILURE                                 102
-# define CL_R_FUNCTION_NOT_BINDED                         103
-# define CL_R_INIT_FAILED                                 104
-# define CL_R_NOT_LOADED                                  105
-
-#ifdef  __cplusplus
-}
-#endif
-#endif
diff --git a/demos/engines/ibmca/Makefile.in b/demos/engines/ibmca/Makefile.in
deleted file mode 100644
index 3f3d327..0000000
--- a/demos/engines/ibmca/Makefile.in
+++ /dev/null
@@ -1,93 +0,0 @@
-LIBNAME=	libibmca
-SRC=		hw_ibmca.c
-OBJ=		hw_ibmca.o
-HEADER=		hw_ibmca.h
-
-CC=		gcc
-PIC=		-fPIC
-CFLAGS=		-g -I../../../include $(PIC) -DENGINE_DYNAMIC_SUPPORT -DFLAT_INC
-AR=		ar r
-RANLIB=		ranlib
-
-LIB=		$(LIBNAME).a
-SHLIB=		$(LIBNAME).so
-
-all:
-		@echo 'Please choose a system to build on:'
-		@echo ''
-		@echo 'tru64:    Tru64 Unix, Digital Unix, Digital OSF/1'
-		@echo 'solaris:  Solaris'
-		@echo 'irix:     IRIX'
-		@echo 'hpux32:   32-bit HP/UX'
-		@echo 'hpux64:   64-bit HP/UX'
-		@echo 'aix:      AIX'
-		@echo 'gnu:      Generic GNU-based system (gcc and GNU ld)'
-		@echo ''
-
-generate:
-		perl ../../../util/mkerr.pl -conf hw_ibmca.ec \
-			-nostatic -staticloader -write hw_ibmca.c
-
-gnu:		$(SHLIB).gnu
-tru64:		$(SHLIB).tru64
-solaris:	$(SHLIB).solaris
-irix:		$(SHLIB).irix
-hpux32:		$(SHLIB).hpux32
-hpux64:		$(SHLIB).hpux64
-aix:		$(SHLIB).aix
-
-$(LIB):		$(OBJ)
-		$(AR) $(LIB) $(OBJ)
-		- $(RANLIB) $(LIB)
-
-LINK_SO=	\
-  ld -r -o $(LIBNAME).o $$ALLSYMSFLAGS $(LIB) &amp;&amp; \
-  (nm -Pg $(LIBNAME).o | grep ' [BDT] ' | cut -f1 -d' ' &gt; $(LIBNAME).exp; \
-   $$SHAREDCMD $$SHAREDFLAGS -o $(SHLIB) $(LIBNAME).o -L ../../.. -lcrypto -lc)
-
-$(SHLIB).gnu:	$(LIB)
-		ALLSYMSFLAGS='--whole-archive' \
-		SHAREDFLAGS='-shared -Wl,-soname=$(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).gnu
-$(SHLIB).tru64:	$(LIB)
-		ALLSYMSFLAGS='-all' \
-		SHAREDFLAGS='-shared' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).tru64
-$(SHLIB).solaris:	$(LIB)
-		ALLSYMSFLAGS='-z allextract' \
-		SHAREDFLAGS='-G -h $(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).solaris
-$(SHLIB).irix:	$(LIB)
-		ALLSYMSFLAGS='-all' \
-		SHAREDFLAGS='-shared -Wl,-soname,$(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).irix
-$(SHLIB).hpux32:	$(LIB)
-		ALLSYMSFLAGS='-Fl' \
-		SHAREDFLAGS='+vnocompatwarnings -b -z +s +h $(SHLIB)' \
-		SHAREDCMD='/usr/ccs/bin/ld'; \
-		$(LINK_SO)
-		touch $(SHLIB).hpux32
-$(SHLIB).hpux64:	$(LIB)
-		ALLSYMSFLAGS='+forceload' \
-		SHAREDFLAGS='-b -z +h $(SHLIB)' \
-		SHAREDCMD='/usr/ccs/bin/ld'; \
-		$(LINK_SO)
-		touch $(SHLIB).hpux64
-$(SHLIB).aix:	$(LIB)
-		ALLSYMSFLAGS='-bnogc' \
-		SHAREDFLAGS='-G -bE:$(LIBNAME).exp -bM:SRE' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).aix
-
-depend:
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
diff --git a/demos/engines/ibmca/hw_ibmca.c b/demos/engines/ibmca/hw_ibmca.c
deleted file mode 100644
index 0f065b2..0000000
--- a/demos/engines/ibmca/hw_ibmca.c
+++ /dev/null
@@ -1,896 +0,0 @@
-/*
- * Written by Geoff Thorpe (<A HREF="../../../mailman/listinfo/openssl-commits.html">geoff at geoffthorpe.net</A>) for the OpenSSL project
- * 2000.
- */
-/* ====================================================================
- * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">licensing at OpenSSL.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-/* (C) COPYRIGHT International Business Machines Corp. 2001 */
-
-#include &lt;stdio.h&gt;
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/dso.h&gt;
-#include &lt;openssl/engine.h&gt;
-
-#ifndef OPENSSL_NO_HW
-# ifndef OPENSSL_NO_HW_IBMCA
-
-#  ifdef FLAT_INC
-#   include &quot;ica_openssl_api.h&quot;
-#  else
-#   include &quot;vendor_defns/ica_openssl_api.h&quot;
-#  endif
-
-#  define IBMCA_LIB_NAME &quot;ibmca engine&quot;
-#  include &quot;hw_ibmca_err.c&quot;
-
-static int ibmca_destroy(ENGINE *e);
-static int ibmca_init(ENGINE *e);
-static int ibmca_finish(ENGINE *e);
-static int ibmca_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) ());
-
-static const char *IBMCA_F1 = &quot;icaOpenAdapter&quot;;
-static const char *IBMCA_F2 = &quot;icaCloseAdapter&quot;;
-static const char *IBMCA_F3 = &quot;icaRsaModExpo&quot;;
-static const char *IBMCA_F4 = &quot;icaRandomNumberGenerate&quot;;
-static const char *IBMCA_F5 = &quot;icaRsaCrt&quot;;
-
-ICA_ADAPTER_HANDLE handle = 0;
-
-/* BIGNUM stuff */
-static int ibmca_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                         const BIGNUM *m, BN_CTX *ctx);
-
-static int ibmca_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                             const BIGNUM *q, const BIGNUM *dmp1,
-                             const BIGNUM *dmq1, const BIGNUM *iqmp,
-                             BN_CTX *ctx);
-
-#  ifndef OPENSSL_NO_RSA
-/* RSA stuff */
-static int ibmca_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa);
-#  endif
-
-/* This function is aliased to mod_exp (with the mont stuff dropped). */
-static int ibmca_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                              const BIGNUM *m, BN_CTX *ctx,
-                              BN_MONT_CTX *m_ctx);
-
-#  ifndef OPENSSL_NO_DSA
-/* DSA stuff */
-static int ibmca_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,
-                             BIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,
-                             BN_CTX *ctx, BN_MONT_CTX *in_mont);
-static int ibmca_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,
-                             const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
-                             BN_MONT_CTX *m_ctx);
-#  endif
-
-#  ifndef OPENSSL_NO_DH
-/* DH stuff */
-/* This function is alised to mod_exp (with the DH and mont dropped). */
-static int ibmca_mod_exp_dh(const DH *dh, BIGNUM *r,
-                            const BIGNUM *a, const BIGNUM *p,
-                            const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
-#  endif
-
-/* RAND stuff */
-static int ibmca_rand_bytes(unsigned char *buf, int num);
-static int ibmca_rand_status(void);
-
-/* WJH - check for more commands, like in nuron */
-
-/* The definitions for control commands specific to this engine */
-#  define IBMCA_CMD_SO_PATH               ENGINE_CMD_BASE
-static const ENGINE_CMD_DEFN ibmca_cmd_defns[] = {
-    {IBMCA_CMD_SO_PATH,
-     &quot;SO_PATH&quot;,
-     &quot;Specifies the path to the 'atasi' shared library&quot;,
-     ENGINE_CMD_FLAG_STRING},
-    {0, NULL, NULL, 0}
-};
-
-#  ifndef OPENSSL_NO_RSA
-/* Our internal RSA_METHOD that we provide pointers to */
-static RSA_METHOD ibmca_rsa = {
-    &quot;Ibmca RSA method&quot;,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    ibmca_rsa_mod_exp,
-    ibmca_mod_exp_mont,
-    NULL,
-    NULL,
-    0,
-    NULL,
-    NULL,
-    NULL
-};
-#  endif
-
-#  ifndef OPENSSL_NO_DSA
-/* Our internal DSA_METHOD that we provide pointers to */
-static DSA_METHOD ibmca_dsa = {
-    &quot;Ibmca DSA method&quot;,
-    NULL,                       /* dsa_do_sign */
-    NULL,                       /* dsa_sign_setup */
-    NULL,                       /* dsa_do_verify */
-    ibmca_dsa_mod_exp,          /* dsa_mod_exp */
-    ibmca_mod_exp_dsa,          /* bn_mod_exp */
-    NULL,                       /* init */
-    NULL,                       /* finish */
-    0,                          /* flags */
-    NULL                        /* app_data */
-};
-#  endif
-
-#  ifndef OPENSSL_NO_DH
-/* Our internal DH_METHOD that we provide pointers to */
-static DH_METHOD ibmca_dh = {
-    &quot;Ibmca DH method&quot;,
-    NULL,
-    NULL,
-    ibmca_mod_exp_dh,
-    NULL,
-    NULL,
-    0,
-    NULL
-};
-#  endif
-
-static RAND_METHOD ibmca_rand = {
-    /* &quot;IBMCA RAND method&quot;, */
-    NULL,
-    ibmca_rand_bytes,
-    NULL,
-    NULL,
-    ibmca_rand_bytes,
-    ibmca_rand_status,
-};
-
-/* Constants used when creating the ENGINE */
-static const char *engine_ibmca_id = &quot;ibmca&quot;;
-static const char *engine_ibmca_name = &quot;Ibmca hardware engine support&quot;;
-
-/*
- * This internal function is used by ENGINE_ibmca() and possibly by the
- * &quot;dynamic&quot; ENGINE support too
- */
-static int bind_helper(ENGINE *e)
-{
-#  ifndef OPENSSL_NO_RSA
-    const RSA_METHOD *meth1;
-#  endif
-#  ifndef OPENSSL_NO_DSA
-    const DSA_METHOD *meth2;
-#  endif
-#  ifndef OPENSSL_NO_DH
-    const DH_METHOD *meth3;
-#  endif
-    if (!ENGINE_set_id(e, engine_ibmca_id) ||
-        !ENGINE_set_name(e, engine_ibmca_name) ||
-#  ifndef OPENSSL_NO_RSA
-        !ENGINE_set_RSA(e, &amp;ibmca_rsa) ||
-#  endif
-#  ifndef OPENSSL_NO_DSA
-        !ENGINE_set_DSA(e, &amp;ibmca_dsa) ||
-#  endif
-#  ifndef OPENSSL_NO_DH
-        !ENGINE_set_DH(e, &amp;ibmca_dh) ||
-#  endif
-        !ENGINE_set_RAND(e, &amp;ibmca_rand) ||
-        !ENGINE_set_destroy_function(e, ibmca_destroy) ||
-        !ENGINE_set_init_function(e, ibmca_init) ||
-        !ENGINE_set_finish_function(e, ibmca_finish) ||
-        !ENGINE_set_ctrl_function(e, ibmca_ctrl) ||
-        !ENGINE_set_cmd_defns(e, ibmca_cmd_defns))
-        return 0;
-
-#  ifndef OPENSSL_NO_RSA
-    /*
-     * We know that the &quot;PKCS1_OpenSSL()&quot; functions hook properly to the
-     * ibmca-specific mod_exp and mod_exp_crt so we use those functions. NB:
-     * We don't use ENGINE_openssl() or anything &quot;more generic&quot; because
-     * something like the RSAref code may not hook properly, and if you own
-     * one of these cards then you have the right to do RSA operations on it
-     * anyway!
-     */
-    meth1 = RSA_PKCS1_OpenSSL();
-    ibmca_rsa.rsa_pub_enc = meth1-&gt;rsa_pub_enc;
-    ibmca_rsa.rsa_pub_dec = meth1-&gt;rsa_pub_dec;
-    ibmca_rsa.rsa_priv_enc = meth1-&gt;rsa_priv_enc;
-    ibmca_rsa.rsa_priv_dec = meth1-&gt;rsa_priv_dec;
-#  endif
-
-#  ifndef OPENSSL_NO_DSA
-    /*
-     * Use the DSA_OpenSSL() method and just hook the mod_exp-ish bits.
-     */
-    meth2 = DSA_OpenSSL();
-    ibmca_dsa.dsa_do_sign = meth2-&gt;dsa_do_sign;
-    ibmca_dsa.dsa_sign_setup = meth2-&gt;dsa_sign_setup;
-    ibmca_dsa.dsa_do_verify = meth2-&gt;dsa_do_verify;
-#  endif
-
-#  ifndef OPENSSL_NO_DH
-    /* Much the same for Diffie-Hellman */
-    meth3 = DH_OpenSSL();
-    ibmca_dh.generate_key = meth3-&gt;generate_key;
-    ibmca_dh.compute_key = meth3-&gt;compute_key;
-#  endif
-
-    /* Ensure the ibmca error handling is set up */
-    ERR_load_IBMCA_strings();
-    return 1;
-}
-
-static ENGINE *engine_ibmca(void)
-{
-    ENGINE *ret = ENGINE_new();
-    if (!ret)
-        return NULL;
-    if (!bind_helper(ret)) {
-        ENGINE_free(ret);
-        return NULL;
-    }
-    return ret;
-}
-
-#  ifdef ENGINE_DYNAMIC_SUPPORT
-static
-#  endif
-void ENGINE_load_ibmca(void)
-{
-    /* Copied from eng_[openssl|dyn].c */
-    ENGINE *toadd = engine_ibmca();
-    if (!toadd)
-        return;
-    ENGINE_add(toadd);
-    ENGINE_free(toadd);
-    ERR_clear_error();
-}
-
-/* Destructor (complements the &quot;ENGINE_ibmca()&quot; constructor) */
-static int ibmca_destroy(ENGINE *e)
-{
-    /*
-     * Unload the ibmca error strings so any error state including our functs
-     * or reasons won't lead to a segfault (they simply get displayed without
-     * corresponding string data because none will be found).
-     */
-    ERR_unload_IBMCA_strings();
-    return 1;
-}
-
-/*
- * This is a process-global DSO handle used for loading and unloading the
- * Ibmca library. NB: This is only set (or unset) during an init() or
- * finish() call (reference counts permitting) and they're operating with
- * global locks, so this should be thread-safe implicitly.
- */
-
-static DSO *ibmca_dso = NULL;
-
-/*
- * These are the function pointers that are (un)set when the library has
- * successfully (un)loaded.
- */
-
-static unsigned int (ICA_CALL * p_icaOpenAdapter) ();
-static unsigned int (ICA_CALL * p_icaCloseAdapter) ();
-static unsigned int (ICA_CALL * p_icaRsaModExpo) ();
-static unsigned int (ICA_CALL * p_icaRandomNumberGenerate) ();
-static unsigned int (ICA_CALL * p_icaRsaCrt) ();
-
-/* utility function to obtain a context */
-static int get_context(ICA_ADAPTER_HANDLE * p_handle)
-{
-    unsigned int status = 0;
-
-    status = p_icaOpenAdapter(0, p_handle);
-    if (status != 0)
-        return 0;
-    return 1;
-}
-
-/* similarly to release one. */
-static void release_context(ICA_ADAPTER_HANDLE handle)
-{
-    p_icaCloseAdapter(handle);
-}
-
-/* (de)initialisation functions. */
-static int ibmca_init(ENGINE *e)
-{
-
-    void (*p1) ();
-    void (*p2) ();
-    void (*p3) ();
-    void (*p4) ();
-    void (*p5) ();
-
-    if (ibmca_dso != NULL) {
-        IBMCAerr(IBMCA_F_IBMCA_INIT, IBMCA_R_ALREADY_LOADED);
-        goto err;
-    }
-    /*
-     * Attempt to load libatasi.so/atasi.dll/whatever. Needs to be changed
-     * unfortunately because the Ibmca drivers don't have standard library
-     * names that can be platform-translated well.
-     */
-    /*
-     * TODO: Work out how to actually map to the names the Ibmca drivers
-     * really use - for now a symbollic link needs to be created on the host
-     * system from libatasi.so to atasi.so on unix variants.
-     */
-
-    /* WJH XXX check name translation */
-
-    ibmca_dso = DSO_load(NULL, IBMCA_LIBNAME, NULL,
-                         /*
-                          * DSO_FLAG_NAME_TRANSLATION
-                          */ 0);
-    if (ibmca_dso == NULL) {
-        IBMCAerr(IBMCA_F_IBMCA_INIT, IBMCA_R_DSO_FAILURE);
-        goto err;
-    }
-
-    if ((p1 = DSO_bind_func(ibmca_dso, IBMCA_F1)) == NULL
-        || (p2 = DSO_bind_func(ibmca_dso, IBMCA_F2)) == NULL
-        || (p3 = DSO_bind_func(ibmca_dso, IBMCA_F3)) == NULL
-        || (p4 = DSO_bind_func(ibmca_dso, IBMCA_F4)) == NULL
-        || (p5 = DSO_bind_func(ibmca_dso, IBMCA_F5)) == NULL) {
-        IBMCAerr(IBMCA_F_IBMCA_INIT, IBMCA_R_DSO_FAILURE);
-        goto err;
-    }
-
-    /* Copy the pointers */
-
-    p_icaOpenAdapter = (unsigned int (ICA_CALL *) ())p1;
-    p_icaCloseAdapter = (unsigned int (ICA_CALL *) ())p2;
-    p_icaRsaModExpo = (unsigned int (ICA_CALL *) ())p3;
-    p_icaRandomNumberGenerate = (unsigned int (ICA_CALL *) ())p4;
-    p_icaRsaCrt = (unsigned int (ICA_CALL *) ())p5;
-
-    if (!get_context(&amp;handle)) {
-        IBMCAerr(IBMCA_F_IBMCA_INIT, IBMCA_R_UNIT_FAILURE);
-        goto err;
-    }
-
-    return 1;
- err:
-    DSO_free(ibmca_dso);
-    p_icaOpenAdapter = NULL;
-    p_icaCloseAdapter = NULL;
-    p_icaRsaModExpo = NULL;
-    p_icaRandomNumberGenerate = NULL;
-
-    return 0;
-}
-
-static int ibmca_finish(ENGINE *e)
-{
-    if (ibmca_dso == NULL) {
-        IBMCAerr(IBMCA_F_IBMCA_FINISH, IBMCA_R_NOT_LOADED);
-        return 0;
-    }
-    release_context(handle);
-    if (!DSO_free(ibmca_dso)) {
-        IBMCAerr(IBMCA_F_IBMCA_FINISH, IBMCA_R_DSO_FAILURE);
-        return 0;
-    }
-    ibmca_dso = NULL;
-
-    return 1;
-}
-
-static int ibmca_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) ())
-{
-    int initialised = ((ibmca_dso == NULL) ? 0 : 1);
-    switch (cmd) {
-    case IBMCA_CMD_SO_PATH:
-        if (p == NULL) {
-            IBMCAerr(IBMCA_F_IBMCA_CTRL, ERR_R_PASSED_NULL_PARAMETER);
-            return 0;
-        }
-        if (initialised) {
-            IBMCAerr(IBMCA_F_IBMCA_CTRL, IBMCA_R_ALREADY_LOADED);
-            return 0;
-        }
-        IBMCA_LIBNAME = (const char *)p;
-        return 1;
-    default:
-        break;
-    }
-    IBMCAerr(IBMCA_F_IBMCA_CTRL, IBMCA_R_CTRL_COMMAND_NOT_IMPLEMENTED);
-    return 0;
-}
-
-static int ibmca_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                         const BIGNUM *m, BN_CTX *ctx)
-{
-    /*
-     * I need somewhere to store temporary serialised values for use with the
-     * Ibmca API calls. A neat cheat - I'll use BIGNUMs from the BN_CTX but
-     * access their arrays directly as byte arrays &lt;grin&gt;. This way I don't
-     * have to clean anything up.
-     */
-
-    BIGNUM *argument = NULL;
-    BIGNUM *result = NULL;
-    BIGNUM *key = NULL;
-    int to_return;
-    int inLen, outLen, tmpLen;
-
-    ICA_KEY_RSA_MODEXPO *publKey = NULL;
-    unsigned int rc;
-
-    to_return = 0;              /* expect failure */
-
-    if (!ibmca_dso) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP, IBMCA_R_NOT_LOADED);
-        goto err;
-    }
-    /* Prepare the params */
-    BN_CTX_start(ctx);
-    argument = BN_CTX_get(ctx);
-    result = BN_CTX_get(ctx);
-    key = BN_CTX_get(ctx);
-
-    if (!argument || !result || !key) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP, IBMCA_R_BN_CTX_FULL);
-        goto err;
-    }
-
-    if (!bn_wexpand(argument, m-&gt;top) || !bn_wexpand(result, m-&gt;top) ||
-        !bn_wexpand(key, sizeof(*publKey) / BN_BYTES)) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP, IBMCA_R_BN_EXPAND_FAIL);
-        goto err;
-    }
-
-    publKey = (ICA_KEY_RSA_MODEXPO *)key-&gt;d;
-
-    if (publKey == NULL) {
-        goto err;
-    }
-    memset(publKey, 0, sizeof(*publKey));
-
-    publKey-&gt;keyType = CORRECT_ENDIANNESS(ME_KEY_TYPE);
-    publKey-&gt;keyLength = CORRECT_ENDIANNESS(sizeof(ICA_KEY_RSA_MODEXPO));
-    publKey-&gt;expOffset = (char *)publKey-&gt;keyRecord - (char *)publKey;
-
-    /*
-     * A quirk of the card: the exponent length has to be the same as the
-     * modulus (key) length
-     */
-
-    outLen = BN_num_bytes(m);
-
-/* check for modulus length SAB*/
-    if (outLen &gt; 256) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP, IBMCA_R_MEXP_LENGTH_TO_LARGE);
-        goto err;
-    }
-/* check for modulus length SAB*/
-
-    publKey-&gt;expLength = publKey-&gt;nLength = outLen;
-    /*
-     * SAB Check for underflow condition the size of the exponent is less
-     * than the size of the parameter then we have a big problem and will
-     * underflow the keyRecord buffer.  Bad stuff could happen then
-     */
-    if (outLen &lt; BN_num_bytes(p)) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP, IBMCA_R_UNDERFLOW_KEYRECORD);
-        goto err;
-    }
-/* SAB End check for underflow */
-
-    BN_bn2bin(p, &amp;publKey-&gt;keyRecord[publKey-&gt;expLength - BN_num_bytes(p)]);
-    BN_bn2bin(m, &amp;publKey-&gt;keyRecord[publKey-&gt;expLength]);
-
-    publKey-&gt;modulusBitLength = CORRECT_ENDIANNESS(publKey-&gt;nLength * 8);
-    publKey-&gt;nOffset = CORRECT_ENDIANNESS(publKey-&gt;expOffset +
-                                          publKey-&gt;expLength);
-
-    publKey-&gt;expOffset = CORRECT_ENDIANNESS((char *)publKey-&gt;keyRecord -
-                                            (char *)publKey);
-
-    tmpLen = outLen;
-    publKey-&gt;expLength = publKey-&gt;nLength = CORRECT_ENDIANNESS(tmpLen);
-
-    /* Prepare the argument */
-
-    memset(argument-&gt;d, 0, outLen);
-    BN_bn2bin(a, (unsigned char *)argument-&gt;d + outLen - BN_num_bytes(a));
-
-    inLen = outLen;
-
-    /* Perform the operation */
-
-    if ((rc = p_icaRsaModExpo(handle, inLen, (unsigned char *)argument-&gt;d,
-                              publKey, &amp;outLen, (unsigned char *)result-&gt;d))
-        != 0) {
-        printf(&quot;rc = %d\n&quot;, rc);
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP, IBMCA_R_REQUEST_FAILED);
-        goto err;
-    }
-
-    /* Convert the response */
-    BN_bin2bn((unsigned char *)result-&gt;d, outLen, r);
-    to_return = 1;
- err:
-    BN_CTX_end(ctx);
-    return to_return;
-}
-
-#  ifndef OPENSSL_NO_RSA
-static int ibmca_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)
-{
-    BN_CTX *ctx;
-    int to_return = 0;
-
-    if ((ctx = BN_CTX_new()) == NULL)
-        goto err;
-    if (!rsa-&gt;p || !rsa-&gt;q || !rsa-&gt;dmp1 || !rsa-&gt;dmq1 || !rsa-&gt;iqmp) {
-        if (!rsa-&gt;d || !rsa-&gt;n) {
-            IBMCAerr(IBMCA_F_IBMCA_RSA_MOD_EXP,
-                     IBMCA_R_MISSING_KEY_COMPONENTS);
-            goto err;
-        }
-        to_return = ibmca_mod_exp(r0, I, rsa-&gt;d, rsa-&gt;n, ctx);
-    } else {
-        to_return = ibmca_mod_exp_crt(r0, I, rsa-&gt;p, rsa-&gt;q, rsa-&gt;dmp1,
-                                      rsa-&gt;dmq1, rsa-&gt;iqmp, ctx);
-    }
- err:
-    BN_CTX_free(ctx);
-    return to_return;
-}
-#  endif
-
-/* Ein kleines chinesisches &quot;Restessen&quot;  */
-static int ibmca_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                             const BIGNUM *q, const BIGNUM *dmp1,
-                             const BIGNUM *dmq1, const BIGNUM *iqmp,
-                             BN_CTX *ctx)
-{
-
-    BIGNUM *argument = NULL;
-    BIGNUM *result = NULL;
-    BIGNUM *key = NULL;
-
-    int to_return = 0;          /* expect failure */
-
-    char *pkey = NULL;
-    ICA_KEY_RSA_CRT *privKey = NULL;
-    int inLen, outLen;
-
-    int rc;
-    unsigned int offset, pSize, qSize;
-/* SAB New variables */
-    unsigned int keyRecordSize;
-    unsigned int pbytes = BN_num_bytes(p);
-    unsigned int qbytes = BN_num_bytes(q);
-    unsigned int dmp1bytes = BN_num_bytes(dmp1);
-    unsigned int dmq1bytes = BN_num_bytes(dmq1);
-    unsigned int iqmpbytes = BN_num_bytes(iqmp);
-
-    /* Prepare the params */
-
-    BN_CTX_start(ctx);
-    argument = BN_CTX_get(ctx);
-    result = BN_CTX_get(ctx);
-    key = BN_CTX_get(ctx);
-
-    if (!argument || !result || !key) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_BN_CTX_FULL);
-        goto err;
-    }
-
-    if (!bn_wexpand(argument, p-&gt;top + q-&gt;top) ||
-        !bn_wexpand(result, p-&gt;top + q-&gt;top) ||
-        !bn_wexpand(key, sizeof(*privKey) / BN_BYTES)) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_BN_EXPAND_FAIL);
-        goto err;
-    }
-
-    privKey = (ICA_KEY_RSA_CRT *)key-&gt;d;
-    /*
-     * SAB Add check for total size in bytes of the parms does not exceed the
-     * buffer space we have do this first
-     */
-    keyRecordSize = pbytes + qbytes + dmp1bytes + dmq1bytes + iqmpbytes;
-    if (keyRecordSize &gt; sizeof(privKey-&gt;keyRecord)) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_OPERANDS_TO_LARGE);
-        goto err;
-    }
-
-    if ((qbytes + dmq1bytes) &gt; 256) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_OPERANDS_TO_LARGE);
-        goto err;
-    }
-
-    if (pbytes + dmp1bytes &gt; 256) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_OPERANDS_TO_LARGE);
-        goto err;
-    }
-
-/* end SAB additions */
-
-    memset(privKey, 0, sizeof(*privKey));
-    privKey-&gt;keyType = CORRECT_ENDIANNESS(CRT_KEY_TYPE);
-    privKey-&gt;keyLength = CORRECT_ENDIANNESS(sizeof(ICA_KEY_RSA_CRT));
-    privKey-&gt;modulusBitLength = CORRECT_ENDIANNESS(BN_num_bytes(q) * 2 * 8);
-
-    /*
-     * p,dp &amp; qInv are 1 QWORD Larger
-     */
-    privKey-&gt;pLength = CORRECT_ENDIANNESS(BN_num_bytes(p) + 8);
-    privKey-&gt;qLength = CORRECT_ENDIANNESS(BN_num_bytes(q));
-    privKey-&gt;dpLength = CORRECT_ENDIANNESS(BN_num_bytes(dmp1) + 8);
-    privKey-&gt;dqLength = CORRECT_ENDIANNESS(BN_num_bytes(dmq1));
-    privKey-&gt;qInvLength = CORRECT_ENDIANNESS(BN_num_bytes(iqmp) + 8);
-
-    offset = (char *)privKey-&gt;keyRecord - (char *)privKey;
-
-    qSize = BN_num_bytes(q);
-    pSize = qSize + 8;          /* 1 QWORD larger */
-
-    /*
-     * SAB probably aittle redundant, but we'll verify that each of the
-     * components which make up a key record sent ot the card does not exceed
-     * the space that is allocated for it.  this handles the case where even
-     * if the total length does not exceed keyrecord zied, if the operands are
-     * funny sized they could cause potential side affects on either the card
-     * or the result
-     */
-
-    if ((pbytes &gt; pSize) || (dmp1bytes &gt; pSize) ||
-        (iqmpbytes &gt; pSize) || (qbytes &gt; qSize) || (dmq1bytes &gt; qSize)) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_OPERANDS_TO_LARGE);
-        goto err;
-
-    }
-
-    privKey-&gt;dpOffset = CORRECT_ENDIANNESS(offset);
-
-    offset += pSize;
-    privKey-&gt;dqOffset = CORRECT_ENDIANNESS(offset);
-
-    offset += qSize;
-    privKey-&gt;pOffset = CORRECT_ENDIANNESS(offset);
-
-    offset += pSize;
-    privKey-&gt;qOffset = CORRECT_ENDIANNESS(offset);
-
-    offset += qSize;
-    privKey-&gt;qInvOffset = CORRECT_ENDIANNESS(offset);
-
-    pkey = (char *)privKey-&gt;keyRecord;
-
-/* SAB first check that we don;t under flow the buffer */
-    if (pSize &lt; pbytes) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_UNDERFLOW_CONDITION);
-        goto err;
-    }
-
-    /* pkey += pSize - BN_num_bytes(p); WROING this should be dmp1) */
-    pkey += pSize - BN_num_bytes(dmp1);
-    BN_bn2bin(dmp1, pkey);
-    pkey += BN_num_bytes(dmp1); /* move the pointer */
-
-    BN_bn2bin(dmq1, pkey);      /* Copy over dmq1 */
-
-    pkey += qSize;              /* move pointer */
-    /* set up for zero padding of next field */
-    pkey += pSize - BN_num_bytes(p);
-
-    BN_bn2bin(p, pkey);
-    /* increment pointer by number of bytes moved  */
-    pkey += BN_num_bytes(p);
-
-    BN_bn2bin(q, pkey);
-    pkey += qSize;              /* move the pointer */
-    pkey += pSize - BN_num_bytes(iqmp); /* Adjust for padding */
-    BN_bn2bin(iqmp, pkey);
-
-    /* Prepare the argument and response */
-
-    /*
-     * Correct endianess is used because the fields were converted above
-     */
-    outLen = CORRECT_ENDIANNESS(privKey-&gt;qLength) * 2;
-
-    if (outLen &gt; 256) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_OUTLEN_TO_LARGE);
-        goto err;
-    }
-
-    /* SAB check for underflow here on the argeument */
-    if (outLen &lt; BN_num_bytes(a)) {
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_UNDERFLOW_CONDITION);
-        goto err;
-    }
-
-    BN_bn2bin(a, (unsigned char *)argument-&gt;d + outLen - BN_num_bytes(a));
-    inLen = outLen;
-
-    memset(result-&gt;d, 0, outLen);
-
-    /* Perform the operation */
-
-    if ((rc = p_icaRsaCrt(handle, inLen, (unsigned char *)argument-&gt;d,
-                          privKey, &amp;outLen, (unsigned char *)result-&gt;d)) != 0)
-    {
-        printf(&quot;rc = %d\n&quot;, rc);
-        IBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_REQUEST_FAILED);
-        goto err;
-    }
-
-    /* Convert the response */
-
-    BN_bin2bn((unsigned char *)result-&gt;d, outLen, r);
-    to_return = 1;
-
- err:
-    BN_CTX_end(ctx);
-    return to_return;
-
-}
-
-#  ifndef OPENSSL_NO_DSA
-/*
- * This code was liberated and adapted from the commented-out code in
- * dsa_ossl.c. Because of the unoptimised form of the Ibmca acceleration (it
- * doesn't have a CRT form for RSA), this function means that an Ibmca system
- * running with a DSA server certificate can handshake around 5 or 6 times
- * faster/more than an equivalent system running with RSA. Just check out the
- * &quot;signs&quot; statistics from the RSA and DSA parts of &quot;openssl speed -engine
- * ibmca dsa1024 rsa1024&quot;.
- */
-static int ibmca_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,
-                             BIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,
-                             BN_CTX *ctx, BN_MONT_CTX *in_mont)
-{
-    BIGNUM t;
-    int to_return = 0;
-
-    BN_init(&amp;t);
-    /* let rr = a1 ^ p1 mod m */
-    if (!ibmca_mod_exp(rr, a1, p1, m, ctx))
-        goto end;
-    /* let t = a2 ^ p2 mod m */
-    if (!ibmca_mod_exp(&amp;t, a2, p2, m, ctx))
-        goto end;
-    /* let rr = rr * t mod m */
-    if (!BN_mod_mul(rr, rr, &amp;t, m, ctx))
-        goto end;
-    to_return = 1;
- end:
-    BN_free(&amp;t);
-    return to_return;
-}
-
-static int ibmca_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,
-                             const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
-                             BN_MONT_CTX *m_ctx)
-{
-    return ibmca_mod_exp(r, a, p, m, ctx);
-}
-#  endif
-
-/* This function is aliased to mod_exp (with the mont stuff dropped). */
-static int ibmca_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                              const BIGNUM *m, BN_CTX *ctx,
-                              BN_MONT_CTX *m_ctx)
-{
-    return ibmca_mod_exp(r, a, p, m, ctx);
-}
-
-#  ifndef OPENSSL_NO_DH
-/* This function is aliased to mod_exp (with the dh and mont dropped). */
-static int ibmca_mod_exp_dh(DH const *dh, BIGNUM *r,
-                            const BIGNUM *a, const BIGNUM *p,
-                            const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
-{
-    return ibmca_mod_exp(r, a, p, m, ctx);
-}
-#  endif
-
-/* Random bytes are good */
-static int ibmca_rand_bytes(unsigned char *buf, int num)
-{
-    int to_return = 0;          /* assume failure */
-    unsigned int ret;
-
-    if (handle == 0) {
-        IBMCAerr(IBMCA_F_IBMCA_RAND_BYTES, IBMCA_R_NOT_INITIALISED);
-        goto err;
-    }
-
-    ret = p_icaRandomNumberGenerate(handle, num, buf);
-    if (ret &lt; 0) {
-        IBMCAerr(IBMCA_F_IBMCA_RAND_BYTES, IBMCA_R_REQUEST_FAILED);
-        goto err;
-    }
-    to_return = 1;
- err:
-    return to_return;
-}
-
-static int ibmca_rand_status(void)
-{
-    return 1;
-}
-
-/*
- * This stuff is needed if this ENGINE is being compiled into a
- * self-contained shared-library.
- */
-#  ifdef ENGINE_DYNAMIC_SUPPORT
-static int bind_fn(ENGINE *e, const char *id)
-{
-    if (id &amp;&amp; (strcmp(id, engine_ibmca_id) != 0)) /* WJH XXX */
-        return 0;
-    if (!bind_helper(e))
-        return 0;
-    return 1;
-}
-
-IMPLEMENT_DYNAMIC_CHECK_FN()
-    IMPLEMENT_DYNAMIC_BIND_FN(bind_fn)
-#  endif                        /* ENGINE_DYNAMIC_SUPPORT */
-# endif                         /* !OPENSSL_NO_HW_IBMCA */
-#endif                          /* !OPENSSL_NO_HW */
diff --git a/demos/engines/ibmca/hw_ibmca.ec b/demos/engines/ibmca/hw_ibmca.ec
deleted file mode 100644
index f68646d..0000000
--- a/demos/engines/ibmca/hw_ibmca.ec
+++ /dev/null
@@ -1,8 +0,0 @@
-# configuration file for util/mkerr.pl
-#
-# use like this:
-#
-#	perl ../../../util/mkerr.pl -conf hw_ibmca.ec \
-#		-nostatic -staticloader -write *.c
-
-L IBMCA		hw_ibmca_err.h			hw_ibmca_err.c
diff --git a/demos/engines/ibmca/hw_ibmca_err.c b/demos/engines/ibmca/hw_ibmca_err.c
deleted file mode 100644
index 5b1911d..0000000
--- a/demos/engines/ibmca/hw_ibmca_err.c
+++ /dev/null
@@ -1,148 +0,0 @@
-/* ====================================================================
- * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at OpenSSL.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-/*
- * NOTE: this file was auto generated by the mkerr.pl script: any changes
- * made to it will be overwritten when the script next updates this file,
- * only reason strings will be preserved.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &quot;hw_ibmca_err.h&quot;
-
-/* BEGIN ERROR CODES */
-#ifndef OPENSSL_NO_ERR
-static ERR_STRING_DATA IBMCA_str_functs[] = {
-    {ERR_PACK(0, IBMCA_F_IBMCA_CTRL, 0), &quot;IBMCA_CTRL&quot;},
-    {ERR_PACK(0, IBMCA_F_IBMCA_FINISH, 0), &quot;IBMCA_FINISH&quot;},
-    {ERR_PACK(0, IBMCA_F_IBMCA_INIT, 0), &quot;IBMCA_INIT&quot;},
-    {ERR_PACK(0, IBMCA_F_IBMCA_MOD_EXP, 0), &quot;IBMCA_MOD_EXP&quot;},
-    {ERR_PACK(0, IBMCA_F_IBMCA_MOD_EXP_CRT, 0), &quot;IBMCA_MOD_EXP_CRT&quot;},
-    {ERR_PACK(0, IBMCA_F_IBMCA_RAND_BYTES, 0), &quot;IBMCA_RAND_BYTES&quot;},
-    {ERR_PACK(0, IBMCA_F_IBMCA_RSA_MOD_EXP, 0), &quot;IBMCA_RSA_MOD_EXP&quot;},
-    {0, NULL}
-};
-
-static ERR_STRING_DATA IBMCA_str_reasons[] = {
-    {IBMCA_R_ALREADY_LOADED, &quot;already loaded&quot;},
-    {IBMCA_R_BN_CTX_FULL, &quot;bn ctx full&quot;},
-    {IBMCA_R_BN_EXPAND_FAIL, &quot;bn expand fail&quot;},
-    {IBMCA_R_CTRL_COMMAND_NOT_IMPLEMENTED, &quot;ctrl command not implemented&quot;},
-    {IBMCA_R_DSO_FAILURE, &quot;dso failure&quot;},
-    {IBMCA_R_MEXP_LENGTH_TO_LARGE, &quot;mexp length to large&quot;},
-    {IBMCA_R_MISSING_KEY_COMPONENTS, &quot;missing key components&quot;},
-    {IBMCA_R_NOT_INITIALISED, &quot;not initialised&quot;},
-    {IBMCA_R_NOT_LOADED, &quot;not loaded&quot;},
-    {IBMCA_R_OPERANDS_TO_LARGE, &quot;operands to large&quot;},
-    {IBMCA_R_OUTLEN_TO_LARGE, &quot;outlen to large&quot;},
-    {IBMCA_R_REQUEST_FAILED, &quot;request failed&quot;},
-    {IBMCA_R_UNDERFLOW_CONDITION, &quot;underflow condition&quot;},
-    {IBMCA_R_UNDERFLOW_KEYRECORD, &quot;underflow keyrecord&quot;},
-    {IBMCA_R_UNIT_FAILURE, &quot;unit failure&quot;},
-    {0, NULL}
-};
-
-#endif
-
-#ifdef IBMCA_LIB_NAME
-static ERR_STRING_DATA IBMCA_lib_name[] = {
-    {0, IBMCA_LIB_NAME},
-    {0, NULL}
-};
-#endif
-
-static int IBMCA_lib_error_code = 0;
-static int IBMCA_error_init = 1;
-
-static void ERR_load_IBMCA_strings(void)
-{
-    if (IBMCA_lib_error_code == 0)
-        IBMCA_lib_error_code = ERR_get_next_error_library();
-
-    if (IBMCA_error_init) {
-        IBMCA_error_init = 0;
-#ifndef OPENSSL_NO_ERR
-        ERR_load_strings(IBMCA_lib_error_code, IBMCA_str_functs);
-        ERR_load_strings(IBMCA_lib_error_code, IBMCA_str_reasons);
-#endif
-
-#ifdef IBMCA_LIB_NAME
-        IBMCA_lib_name-&gt;error = ERR_PACK(IBMCA_lib_error_code, 0, 0);
-        ERR_load_strings(0, IBMCA_lib_name);
-#endif
-    }
-}
-
-static void ERR_unload_IBMCA_strings(void)
-{
-    if (IBMCA_error_init == 0) {
-#ifndef OPENSSL_NO_ERR
-        ERR_unload_strings(IBMCA_lib_error_code, IBMCA_str_functs);
-        ERR_unload_strings(IBMCA_lib_error_code, IBMCA_str_reasons);
-#endif
-
-#ifdef IBMCA_LIB_NAME
-        ERR_unload_strings(0, IBMCA_lib_name);
-#endif
-        IBMCA_error_init = 1;
-    }
-}
-
-static void ERR_IBMCA_error(int function, int reason, char *file, int line)
-{
-    if (IBMCA_lib_error_code == 0)
-        IBMCA_lib_error_code = ERR_get_next_error_library();
-    ERR_PUT_error(IBMCA_lib_error_code, function, reason, file, line);
-}
diff --git a/demos/engines/ibmca/hw_ibmca_err.h b/demos/engines/ibmca/hw_ibmca_err.h
deleted file mode 100644
index 10d0212..0000000
--- a/demos/engines/ibmca/hw_ibmca_err.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/* ====================================================================
- * Copyright (c) 2001-2002 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-#ifndef HEADER_IBMCA_ERR_H
-# define HEADER_IBMCA_ERR_H
-
-#ifdef  __cplusplus
-extern &quot;C&quot; {
-#endif
-
-/* BEGIN ERROR CODES */
-/*
- * The following lines are auto generated by the script mkerr.pl. Any changes
- * made after this point may be overwritten when the script is next run.
- */
-static void ERR_load_IBMCA_strings(void);
-static void ERR_unload_IBMCA_strings(void);
-static void ERR_IBMCA_error(int function, int reason, char *file, int line);
-# define IBMCAerr(f,r) ERR_IBMCA_error((f),(r),OPENSSL_FILE,OPENSSL_LINE)
-
-/* Error codes for the IBMCA functions. */
-
-/* Function codes. */
-# define IBMCA_F_IBMCA_CTRL                               100
-# define IBMCA_F_IBMCA_FINISH                             101
-# define IBMCA_F_IBMCA_INIT                               102
-# define IBMCA_F_IBMCA_MOD_EXP                            103
-# define IBMCA_F_IBMCA_MOD_EXP_CRT                        104
-# define IBMCA_F_IBMCA_RAND_BYTES                         105
-# define IBMCA_F_IBMCA_RSA_MOD_EXP                        106
-
-/* Reason codes. */
-# define IBMCA_R_ALREADY_LOADED                           100
-# define IBMCA_R_BN_CTX_FULL                              101
-# define IBMCA_R_BN_EXPAND_FAIL                           102
-# define IBMCA_R_CTRL_COMMAND_NOT_IMPLEMENTED             103
-# define IBMCA_R_DSO_FAILURE                              104
-# define IBMCA_R_MEXP_LENGTH_TO_LARGE                     105
-# define IBMCA_R_MISSING_KEY_COMPONENTS                   106
-# define IBMCA_R_NOT_INITIALISED                          107
-# define IBMCA_R_NOT_LOADED                               108
-# define IBMCA_R_OPERANDS_TO_LARGE                        109
-# define IBMCA_R_OUTLEN_TO_LARGE                          110
-# define IBMCA_R_REQUEST_FAILED                           111
-# define IBMCA_R_UNDERFLOW_CONDITION                      112
-# define IBMCA_R_UNDERFLOW_KEYRECORD                      113
-# define IBMCA_R_UNIT_FAILURE                             114
-
-#ifdef  __cplusplus
-}
-#endif
-#endif
diff --git a/demos/engines/ibmca/ica_openssl_api.h b/demos/engines/ibmca/ica_openssl_api.h
deleted file mode 100644
index 715bb92..0000000
--- a/demos/engines/ibmca/ica_openssl_api.h
+++ /dev/null
@@ -1,183 +0,0 @@
-
-#ifndef __ICA_OPENSSL_API_H__
-# define __ICA_OPENSSL_API_H__
-
-/**
- ** abstract data types for API
- **/
-
-# define ICA_ADAPTER_HANDLE int
-
-# if defined(linux) || defined (_AIX)
-#  define ICA_CALL
-# endif
-
-# if defined(WIN32) || defined(_WIN32)
-#  define ICA_CALL  __stdcall
-# endif
-
-/* -----------------------------------------------*
- | RSA defines and typedefs                       |
- *------------------------------------------------*/
- /*
-  * All data elements of the RSA key are in big-endian format
-  * Modulus-Exponent form of key
-  *
-  */
-# define MAX_EXP_SIZE 256
-# define MAX_MODULUS_SIZE 256
-# define MAX_MODEXP_SIZE  (MAX_EXP_SIZE + MAX_MODULUS_SIZE)
-
-# define MAX_OPERAND_SIZE  MAX_EXP_SIZE
-
-typedef unsigned char ICA_KEY_RSA_MODEXPO_REC[MAX_MODEXP_SIZE];
- /*
-  * All data elements of the RSA key are in big-endian format
-  * Chinese Remainder Thereom(CRT) form of key
-  * Used only for Decrypt, the encrypt form is typically Modulus-Exponent
-  *
-  */
-# define MAX_BP_SIZE 136
-# define MAX_BQ_SIZE 128
-# define MAX_NP_SIZE 136
-# define MAX_NQ_SIZE 128
-# define MAX_QINV_SIZE 136
-# define MAX_RSACRT_SIZE (MAX_BP_SIZE+MAX_BQ_SIZE+MAX_NP_SIZE+MAX_NQ_SIZE+MAX_QINV_SIZE)
-
-# define RSA_GEN_OPERAND_MAX   256/* bytes */
-
-typedef unsigned char ICA_KEY_RSA_CRT_REC[MAX_RSACRT_SIZE];
-/* -----------------------------------------------*
- | RSA key token types                            |
- *------------------------------------------------*/
-
-# define  RSA_PUBLIC_MODULUS_EXPONENT        3
-# define  RSA_PKCS_PRIVATE_CHINESE_REMAINDER 6
-
-# define KEYTYPE_MODEXPO         1
-# define KEYTYPE_PKCSCRT         2
-
-/* -----------------------------------------------*
- | RSA Key Token format                           |
- *------------------------------------------------*/
-
-/*-
- * NOTE:  All the fields in the ICA_KEY_RSA_MODEXPO structure
- *        (lengths, offsets, exponents, modulus, etc.) are
- *        stored in big-endian format
- */
-
-typedef struct _ICA_KEY_RSA_MODEXPO {
-    unsigned int keyType;       /* RSA key type.  */
-    unsigned int keyLength;     /* Total length of the token.  */
-    unsigned int modulusBitLength; /* Modulus n bit length.  */
-    /* -- Start of the data length. */
-    unsigned int nLength;       /* Modulus n = p * q */
-    unsigned int expLength;     /* exponent (public or private) */
-    /*   e = 1/d * mod(p-1)(q-1)   */
-    /* -- Start of the data offsets */
-    unsigned int nOffset;       /* Modulus n .  */
-    unsigned int expOffset;     /* exponent (public or private) */
-    unsigned char reserved[112]; /* reserved area */
-    /* -- Start of the variable -- */
-    /* -- length token data.    -- */
-    ICA_KEY_RSA_MODEXPO_REC keyRecord;
-} ICA_KEY_RSA_MODEXPO;
-# define SZ_HEADER_MODEXPO (sizeof(ICA_KEY_RSA_MODEXPO) - sizeof(ICA_KEY_RSA_MODEXPO_REC))
-
-/*-
- * NOTE:  All the fields in the ICA_KEY_RSA_CRT structure
- *        (lengths, offsets, exponents, modulus, etc.) are
- *        stored in big-endian format
- */
-
-typedef struct _ICA_KEY_RSA_CRT {
-    unsigned int keyType;       /* RSA key type.  */
-    unsigned int keyLength;     /* Total length of the token.  */
-    unsigned int modulusBitLength; /* Modulus n bit length.  */
-    /* -- Start of the data length. */
-# if _AIX
-    unsigned int nLength;       /* Modulus n = p * q */
-# endif
-    unsigned int pLength;       /* Prime number p .  */
-    unsigned int qLength;       /* Prime number q .  */
-    unsigned int dpLength;      /* dp = d * mod(p-1) .  */
-    unsigned int dqLength;      /* dq = d * mod(q-1) .  */
-    unsigned int qInvLength;    /* PKCS: qInv = Ap/q */
-    /* -- Start of the data offsets */
-# if _AIX
-    unsigned int nOffset;       /* Modulus n .  */
-# endif
-    unsigned int pOffset;       /* Prime number p .  */
-    unsigned int qOffset;       /* Prime number q .  */
-    unsigned int dpOffset;      /* dp .  */
-    unsigned int dqOffset;      /* dq .  */
-    unsigned int qInvOffset;    /* qInv for PKCS */
-# if _AIX
-    unsigned char reserved[80]; /* reserved area */
-# else
-    unsigned char reserved[88]; /* reserved area */
-# endif
-    /* -- Start of the variable -- */
-    /* -- length token data.    -- */
-    ICA_KEY_RSA_CRT_REC keyRecord;
-} ICA_KEY_RSA_CRT;
-# define SZ_HEADER_CRT (sizeof(ICA_KEY_RSA_CRT) - sizeof(ICA_KEY_RSA_CRT_REC))
-
-unsigned int
-icaOpenAdapter(unsigned int adapterId, ICA_ADAPTER_HANDLE * pAdapterHandle);
-
-unsigned int icaCloseAdapter(ICA_ADAPTER_HANDLE adapterHandle);
-
-unsigned int
-icaRsaModExpo(ICA_ADAPTER_HANDLE hAdapterHandle,
-              unsigned int inputDataLength,
-              unsigned char *pInputData,
-              ICA_KEY_RSA_MODEXPO *pKeyModExpo,
-              unsigned int *pOutputDataLength, unsigned char *pOutputData);
-
-unsigned int
-icaRsaCrt(ICA_ADAPTER_HANDLE hAdapterHandle,
-          unsigned int inputDataLength,
-          unsigned char *pInputData,
-          ICA_KEY_RSA_CRT *pKeyCrt,
-          unsigned int *pOutputDataLength, unsigned char *pOutputData);
-
-unsigned int
-icaRandomNumberGenerate(ICA_ADAPTER_HANDLE hAdapterHandle,
-                        unsigned int outputDataLength,
-                        unsigned char *pOutputData);
-
-/*
- * Specific macros and definitions to not have IFDEF;s all over the main code
- */
-
-# if (_AIX)
-static const char *IBMCA_LIBNAME = &quot;/lib/libica.a(shr.o)&quot;;
-# elif (WIN32)
-static const char *IBMCA_LIBNAME = &quot;cryptica&quot;;
-# else
-static const char *IBMCA_LIBNAME = &quot;ica&quot;;
-# endif
-
-# if (WIN32)
-/*
- * The ICA_KEY_RSA_MODEXPO &amp; ICA_KEY_RSA_CRT lengths and offsets must be in
- * big-endian format.
- *
- */
-#  define CORRECT_ENDIANNESS(b) (  \
-                             (((unsigned long) (b) &amp; 0x000000ff) &lt;&lt; 24) |  \
-                             (((unsigned long) (b) &amp; 0x0000ff00) &lt;&lt;  8) |  \
-                             (((unsigned long) (b) &amp; 0x00ff0000) &gt;&gt;  8) |  \
-                             (((unsigned long) (b) &amp; 0xff000000) &gt;&gt; 24)    \
-                             )
-#  define CRT_KEY_TYPE   RSA_PKCS_PRIVATE_CHINESE_REMAINDER
-#  define ME_KEY_TYPE    RSA_PUBLIC_MODULUS_EXPONENT
-# else
-#  define CORRECT_ENDIANNESS(b) (b)
-#  define CRT_KEY_TYPE       KEYTYPE_PKCSCRT
-#  define ME_KEY_TYPE        KEYTYPE_MODEXPO
-# endif
-
-#endif                          /* __ICA_OPENSSL_API_H__ */
diff --git a/demos/engines/rsaref/Makefile.in b/demos/engines/rsaref/Makefile.in
deleted file mode 100644
index fea17a4..0000000
--- a/demos/engines/rsaref/Makefile.in
+++ /dev/null
@@ -1,114 +0,0 @@
-LIBNAME=	librsaref
-SRC=		rsaref.c
-OBJ=		rsaref.o
-HEADER=		rsaref.h
-
-CC=		gcc
-PIC=		-fPIC
-CFLAGS=		-g -I../../../include $(PIC) -DENGINE_DYNAMIC_SUPPORT
-AR=		ar r
-RANLIB=		ranlib
-
-LIB=		$(LIBNAME).a
-SHLIB=		$(LIBNAME).so
-
-all:
-		@echo 'Please choose a system to build on:'
-		@echo ''
-		@echo 'tru64:    Tru64 Unix, Digital Unix, Digital OSF/1'
-		@echo 'solaris:  Solaris'
-		@echo 'irix:     IRIX'
-		@echo 'hpux32:   32-bit HP/UX'
-		@echo 'hpux64:   64-bit HP/UX'
-		@echo 'aix:      AIX'
-		@echo 'gnu:      Generic GNU-based system (gcc and GNU ld)'
-		@echo ''
-
-FORCE.install:
-install:	FORCE.install
-		cd install; \
-			make -f unix/makefile CFLAGS='-I. -DPROTOTYPES=1 -O -c' RSAREFLIB=librsaref.a librsaref.a
-
-generate:
-		perl ../../../util/mkerr.pl -conf rsaref.ec \
-			-nostatic -staticloader -write rsaref.c
-
-darwin:		install $(SHLIB).darwin
-cygwin:		install $(SHLIB).cygwin
-gnu:		install $(SHLIB).gnu
-alpha-osf1:	install $(SHLIB).alpha-osf1
-tru64:		install $(SHLIB).tru64
-solaris:	install $(SHLIB).solaris
-irix:		install $(SHLIB).irix
-hpux32:		install $(SHLIB).hpux32
-hpux64:		install $(SHLIB).hpux64
-aix:		install $(SHLIB).aix
-reliantunix:	install $(SHLIB).reliantunix
-
-$(LIB):		$(OBJ)
-		$(AR) $(LIB) $(OBJ)
-		- $(RANLIB) $(LIB)
-
-LINK_SO=	\
-  ld -r -o $(LIBNAME).o $$ALLSYMSFLAGS $(LIB) install/librsaref.a &amp;&amp; \
-  (nm -Pg $(LIBNAME).o | grep ' [BDT] ' | cut -f1 -d' ' &gt; $(LIBNAME).exp; \
-   $$SHAREDCMD $$SHAREDFLAGS -o $(SHLIB) $(LIBNAME).o -L ../../.. -lcrypto -lc)
-
-$(SHLIB).darwin:	$(LIB) install/librsaref.a
-		ALLSYMSFLAGS='-all_load' \
-		SHAREDFLAGS='-dynamiclib -install_name $(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).darwin
-$(SHLIB).cygwin:	$(LIB) install/librsaref.a
-		ALLSYMSFLAGS='--whole-archive' \
-		SHAREDFLAGS='-shared -Wl,-Bsymbolic -Wl,--out-implib,$(LIBNAME).dll.a' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).cygwin
-$(SHLIB).gnu:	$(LIB) install/librsaref.a
-		ALLSYMSFLAGS='--whole-archive' \
-		SHAREDFLAGS='-shared -Wl,-soname=$(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).gnu
-$(SHLIB).tru64:	$(LIB) install/librsaref.a
-		ALLSYMSFLAGS='-all' \
-		SHAREDFLAGS='-shared' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).tru64
-$(SHLIB).solaris:	$(LIB) install/librsaref.a
-		ALLSYMSFLAGS='-z allextract' \
-		SHAREDFLAGS='-G -h $(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).solaris
-$(SHLIB).irix:	$(LIB) install/librsaref.a
-		ALLSYMSFLAGS='-all' \
-		SHAREDFLAGS='-shared -Wl,-soname,$(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).irix
-$(SHLIB).hpux32:	$(LIB) install/librsaref.a
-		ALLSYMSFLAGS='-Fl' \
-		SHAREDFLAGS='+vnocompatwarnings -b -z +s +h $(SHLIB)' \
-		SHAREDCMD='/usr/ccs/bin/ld'; \
-		$(LINK_SO)
-		touch $(SHLIB).hpux32
-$(SHLIB).hpux64:	$(LIB) install/librsaref.a
-		ALLSYMSFLAGS='+forceload' \
-		SHAREDFLAGS='-b -z +h $(SHLIB)' \
-		SHAREDCMD='/usr/ccs/bin/ld'; \
-		$(LINK_SO)
-		touch $(SHLIB).hpux64
-$(SHLIB).aix:	$(LIB) install/librsaref.a
-		ALLSYMSFLAGS='-bnogc' \
-		SHAREDFLAGS='-G -bE:$(LIBNAME).exp -bM:SRE' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).aix
-
-depend:
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
diff --git a/demos/engines/rsaref/README b/demos/engines/rsaref/README
deleted file mode 100644
index 00b1f74..0000000
--- a/demos/engines/rsaref/README
+++ /dev/null
@@ -1,22 +0,0 @@
-librsaref.so is a demonstration dynamic engine that does RSA
-operations using the old RSAref 2.0 implementation.
-
-To make proper use of this engine, you must download RSAref 2.0
-(search the web for rsaref.tar.Z for example) and unpack it in this
-directory, so you'll end up having the subdirectories &quot;install&quot; and
-&quot;source&quot; among others.
-
-To build, do the following:
-
-	make
-
-This will list a number of available targets to choose from.  Most of
-them are architecture-specific.  The exception is &quot;gnu&quot; which is to be
-used on systems where GNU ld and gcc have been installed in such a way
-that gcc uses GNU ld to link together programs and shared libraries.
-
-The make file assumes you use gcc.  To change that, just reassign CC:
-
-	make CC=cc
-
-The result is librsaref.so, which you can copy to any place you wish.
diff --git a/demos/engines/rsaref/build.com b/demos/engines/rsaref/build.com
deleted file mode 100644
index 72b013d..0000000
--- a/demos/engines/rsaref/build.com
+++ /dev/null
@@ -1,105 +0,0 @@
-$! BUILD.COM -- Building procedure for the RSAref engine
-$
-$	if f$search(&quot;source.dir&quot;) .eqs. &quot;&quot; -
-	   .or. f$search(&quot;install.dir&quot;) .eqs. &quot;&quot;
-$	then
-$	    write sys$error &quot;RSAref 2.0 hasn't been properly extracted.&quot;
-$	    exit
-$	endif
-$
-$	if (f$getsyi(&quot;cpu&quot;).lt.128)
-$	then
-$	    arch := vax
-$	else
-$	    arch = f$edit( f$getsyi( &quot;ARCH_NAME&quot;), &quot;UPCASE&quot;)
-$	    if (arch .eqs. &quot;&quot;) then arch = &quot;UNK&quot;
-$	endif
-$
-$	_save_default = f$environment(&quot;default&quot;)
-$	set default [.install]
-$	files := desc,digit,md2c,md5c,nn,prime,-
-		rsa,r_encode,r_dh,r_enhanc,r_keygen,r_random,-
-		r_stdlib
-$	delete rsaref.olb;*
-$	library/create/object rsaref.olb
-$	files_i = 0
-$ rsaref_loop:
-$	files_e = f$edit(f$element(files_i,&quot;,&quot;,files),&quot;trim&quot;)
-$	files_i = files_i + 1
-$	if files_e .eqs. &quot;,&quot; then goto rsaref_loop_end
-$	cc/include=([-.source],[])/define=PROTOTYPES=1/object=[]'files_e'.obj -
-		[-.source]'files_e'.c
-$	library/replace/object rsaref.olb 'files_e'.obj
-$	goto rsaref_loop
-$ rsaref_loop_end:
-$
-$	set default [-]
-$	define/user openssl [---.include.openssl]
-$	cc/define=ENGINE_DYNAMIC_SUPPORT rsaref.c
-$
-$	if arch .eqs. &quot;VAX&quot;
-$	then
-$	    macro/object=rsaref_vec.obj sys$input:
-;
-; Transfer vector for VAX shareable image
-;
-	.TITLE librsaref
-;
-; Define macro to assist in building transfer vector entries.  Each entry
-; should take no more than 8 bytes.
-;
-	.MACRO FTRANSFER_ENTRY routine
-	.ALIGN QUAD
-	.TRANSFER routine
-	.MASK	routine
-	JMP	routine+2
-	.ENDM FTRANSFER_ENTRY
-;
-; Place entries in own program section.
-;
-	.PSECT $$LIBRSAREF,QUAD,PIC,USR,CON,REL,LCL,SHR,EXE,RD,NOWRT
-
-LIBRSAREF_xfer:
-	FTRANSFER_ENTRY bind_engine
-	FTRANSFER_ENTRY v_check
-
-;
-; Allocate extra storage at end of vector to allow for expansion.
-;
-	.BLKB 512-&lt;.-LIBRSAREF_xfer&gt;	; 1 page.
-	.END
-$	    link/share=librsaref.exe sys$input:/option
-!
-! Ensure transfer vector is at beginning of image
-!
-CLUSTER=FIRST
-COLLECT=FIRST,$$LIBRSAREF
-!
-! make psects nonshareable so image can be installed.
-!
-PSECT_ATTR=$CHAR_STRING_CONSTANTS,NOWRT
-[]rsaref_vec.obj
-[]rsaref.obj
-[.install]rsaref.olb/lib
-[---.vax.exe.crypto]libcrypto.olb/lib
-$	else
-$	    if arch_name .eqs. &quot;ALPHA&quot;
-$	    then
-$		link/share=librsaref.exe sys$input:/option
-[]rsaref.obj
-[.install]rsaref.olb/lib
-[---.alpha.exe.crypto]libcrypto.olb/lib
-symbol_vector=(bind_engine=procedure,v_check=procedure)
-$	    else
-$		if arch_name .eqs. &quot;IA64&quot;
-$		then
-$		    link /shareable=librsaref.exe sys$input: /options
-[]rsaref.obj
-[.install]rsaref.olb/lib
-[---.ia64.exe.crypto]libcrypto.olb/lib
-symbol_vector=(bind_engine=procedure,v_check=procedure)
-$		endif
-$	    endif
-$	endif
-$
-$	set default '_save_default'
diff --git a/demos/engines/rsaref/rsaref.c b/demos/engines/rsaref/rsaref.c
deleted file mode 100644
index d5a6e6c..0000000
--- a/demos/engines/rsaref/rsaref.c
+++ /dev/null
@@ -1,658 +0,0 @@
-/*
- * Demo of how to construct your own engine and using it.  The basis of this
- * engine is RSAref, an old reference of the RSA algorithm which can still be
- * found a little here and there.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &quot;./source/global.h&quot;
-#include &quot;./source/rsaref.h&quot;
-#include &quot;./source/rsa.h&quot;
-#include &quot;./source/des.h&quot;
-#include &lt;openssl/err.h&gt;
-#define OPENSSL_NO_MD2
-#define OPENSSL_NO_MD5
-#include &lt;openssl/evp.h&gt;
-#include &lt;openssl/bn.h&gt;
-#include &lt;openssl/engine.h&gt;
-
-#define RSAREF_LIB_NAME &quot;rsaref engine&quot;
-#include &quot;rsaref_err.c&quot;
-
-/*****************************************************************************
- *** Function declarations and global variable definitions                 ***
- *****************************************************************************/
-
-/*****************************************************************************
- * Constants used when creating the ENGINE
- **/
-static const char *engine_rsaref_id = &quot;rsaref&quot;;
-static const char *engine_rsaref_name = &quot;RSAref engine support&quot;;
-
-/*****************************************************************************
- * Functions to handle the engine
- **/
-static int rsaref_destroy(ENGINE *e);
-static int rsaref_init(ENGINE *e);
-static int rsaref_finish(ENGINE *e);
-
-/*****************************************************************************
- * Engine commands
- **/
-static const ENGINE_CMD_DEFN rsaref_cmd_defns[] = {
-    {0, NULL, NULL, 0}
-};
-
-/*****************************************************************************
- * RSA functions
- **/
-static int rsaref_private_decrypt(int len, const unsigned char *from,
-                                  unsigned char *to, RSA *rsa, int padding);
-static int rsaref_private_encrypt(int len, const unsigned char *from,
-                                  unsigned char *to, RSA *rsa, int padding);
-static int rsaref_public_encrypt(int len, const unsigned char *from,
-                                 unsigned char *to, RSA *rsa, int padding);
-static int rsaref_public_decrypt(int len, const unsigned char *from,
-                                 unsigned char *to, RSA *rsa, int padding);
-static int bnref_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
-static int rsaref_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa);
-
-/*****************************************************************************
- * Our RSA method
- **/
-static RSA_METHOD rsaref_rsa = {
-    &quot;RSAref PKCS#1 RSA&quot;,
-    rsaref_public_encrypt,
-    rsaref_public_decrypt,
-    rsaref_private_encrypt,
-    rsaref_private_decrypt,
-    rsaref_mod_exp,
-    bnref_mod_exp,
-    NULL,
-    NULL,
-    0,
-    NULL,
-    NULL,
-    NULL
-};
-
-/*****************************************************************************
- * Symetric cipher and digest function registrars
- **/
-static int rsaref_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
-                          const int **nids, int nid);
-static int rsaref_digests(ENGINE *e, const EVP_MD **digest,
-                          const int **nids, int nid);
-
-static int rsaref_cipher_nids[] =
-    { NID_des_cbc, NID_des_ede3_cbc, NID_desx_cbc, 0 };
-static int rsaref_digest_nids[] = { NID_md2, NID_md5, 0 };
-
-/*****************************************************************************
- * DES functions
- **/
-static int cipher_des_cbc_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
-                               const unsigned char *iv, int enc);
-static int cipher_des_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                               const unsigned char *in, unsigned int inl);
-static int cipher_des_cbc_clean(EVP_CIPHER_CTX *);
-static int cipher_des_ede3_cbc_init(EVP_CIPHER_CTX *ctx,
-                                    const unsigned char *key,
-                                    const unsigned char *iv, int enc);
-static int cipher_des_ede3_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                                    const unsigned char *in,
-                                    unsigned int inl);
-static int cipher_des_ede3_cbc_clean(EVP_CIPHER_CTX *);
-static int cipher_desx_cbc_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
-                                const unsigned char *iv, int enc);
-static int cipher_desx_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                                const unsigned char *in, unsigned int inl);
-static int cipher_desx_cbc_clean(EVP_CIPHER_CTX *);
-
-/*****************************************************************************
- * Our DES ciphers
- **/
-static const EVP_CIPHER cipher_des_cbc = {
-    NID_des_cbc,
-    8, 8, 8,
-    0 | EVP_CIPH_CBC_MODE,
-    cipher_des_cbc_init,
-    cipher_des_cbc_code,
-    cipher_des_cbc_clean,
-    sizeof(DES_CBC_CTX),
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
-
-static const EVP_CIPHER cipher_des_ede3_cbc = {
-    NID_des_ede3_cbc,
-    8, 24, 8,
-    0 | EVP_CIPH_CBC_MODE,
-    cipher_des_ede3_cbc_init,
-    cipher_des_ede3_cbc_code,
-    cipher_des_ede3_cbc_clean,
-    sizeof(DES3_CBC_CTX),
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
-
-static const EVP_CIPHER cipher_desx_cbc = {
-    NID_desx_cbc,
-    8, 24, 8,
-    0 | EVP_CIPH_CBC_MODE,
-    cipher_desx_cbc_init,
-    cipher_desx_cbc_code,
-    cipher_desx_cbc_clean,
-    sizeof(DESX_CBC_CTX),
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
-
-/*****************************************************************************
- * MD functions
- **/
-static int digest_md2_init(EVP_MD_CTX *ctx);
-static int digest_md2_update(EVP_MD_CTX *ctx, const void *data,
-                             unsigned long count);
-static int digest_md2_final(EVP_MD_CTX *ctx, unsigned char *md);
-static int digest_md5_init(EVP_MD_CTX *ctx);
-static int digest_md5_update(EVP_MD_CTX *ctx, const void *data,
-                             unsigned long count);
-static int digest_md5_final(EVP_MD_CTX *ctx, unsigned char *md);
-
-/*****************************************************************************
- * Our MD digests
- **/
-static const EVP_MD digest_md2 = {
-    NID_md2,
-    NID_md2WithRSAEncryption,
-    16,
-    0,
-    digest_md2_init,
-    digest_md2_update,
-    digest_md2_final,
-    NULL,
-    NULL,
-    EVP_PKEY_RSA_method,
-    16,
-    sizeof(MD2_CTX)
-};
-
-static const EVP_MD digest_md5 = {
-    NID_md5,
-    NID_md5WithRSAEncryption,
-    16,
-    0,
-    digest_md5_init,
-    digest_md5_update,
-    digest_md5_final,
-    NULL,
-    NULL,
-    EVP_PKEY_RSA_method,
-    64,
-    sizeof(MD5_CTX)
-};
-
-/*****************************************************************************
- *** Function definitions                                                  ***
- *****************************************************************************/
-
-/*****************************************************************************
- * Functions to handle the engine
- **/
-
-static int bind_rsaref(ENGINE *e)
-{
-    const RSA_METHOD *meth1;
-    if (!ENGINE_set_id(e, engine_rsaref_id)
-        || !ENGINE_set_name(e, engine_rsaref_name)
-        || !ENGINE_set_RSA(e, &amp;rsaref_rsa)
-        || !ENGINE_set_ciphers(e, rsaref_ciphers)
-        || !ENGINE_set_digests(e, rsaref_digests)
-        || !ENGINE_set_destroy_function(e, rsaref_destroy)
-        || !ENGINE_set_init_function(e, rsaref_init)
-        || !ENGINE_set_finish_function(e, rsaref_finish)
-        /* || !ENGINE_set_ctrl_function(e, rsaref_ctrl) */
-        /*
-         * || !ENGINE_set_cmd_defns(e, rsaref_cmd_defns)
-         */ )
-        return 0;
-
-    /* Ensure the rsaref error handling is set up */
-    ERR_load_RSAREF_strings();
-    return 1;
-}
-
-#ifdef ENGINE_DYNAMIC_SUPPORT
-static int bind_helper(ENGINE *e, const char *id)
-{
-    if (id &amp;&amp; (strcmp(id, engine_rsaref_id) != 0))
-        return 0;
-    if (!bind_rsaref(e))
-        return 0;
-    return 1;
-}
-
-IMPLEMENT_DYNAMIC_CHECK_FN()
-    IMPLEMENT_DYNAMIC_BIND_FN(bind_helper)
-#else
-static ENGINE *engine_rsaref(void)
-{
-    ENGINE *ret = ENGINE_new();
-    if (!ret)
-        return NULL;
-    if (!bind_rsaref(ret)) {
-        ENGINE_free(ret);
-        return NULL;
-    }
-    return ret;
-}
-
-void ENGINE_load_rsaref(void)
-{
-    /* Copied from eng_[openssl|dyn].c */
-    ENGINE *toadd = engine_rsaref();
-    if (!toadd)
-        return;
-    ENGINE_add(toadd);
-    ENGINE_free(toadd);
-    ERR_clear_error();
-}
-#endif
-
-/* Initiator which is only present to make sure this engine looks available */
-static int rsaref_init(ENGINE *e)
-{
-    return 1;
-}
-
-/* Finisher which is only present to make sure this engine looks available */
-static int rsaref_finish(ENGINE *e)
-{
-    return 1;
-}
-
-/* Destructor (complements the &quot;ENGINE_ncipher()&quot; constructor) */
-static int rsaref_destroy(ENGINE *e)
-{
-    ERR_unload_RSAREF_strings();
-    return 1;
-}
-
-/*****************************************************************************
- * RSA functions
- **/
-
-static int rsaref_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)
-{
-    RSAREFerr(RSAREF_F_RSAREF_MOD_EXP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
-    return (0);
-}
-
-static int bnref_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
-{
-    RSAREFerr(RSAREF_F_BNREF_MOD_EXP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
-    return (0);
-}
-
-/* unsigned char *to:  [max]    */
-static int RSAref_bn2bin(BIGNUM *from, unsigned char *to, int max)
-{
-    int i;
-
-    i = BN_num_bytes(from);
-    if (i &gt; max) {
-        RSAREFerr(RSAREF_F_RSAREF_BN2BIN, RSAREF_R_LEN);
-        return (0);
-    }
-
-    memset(to, 0, (unsigned int)max);
-    if (!BN_bn2bin(from, &amp;(to[max - i])))
-        return (0);
-    return (1);
-}
-
-static int RSAref_Public_eay2ref(RSA *from, R_RSA_PUBLIC_KEY * to)
-{
-    to-&gt;bits = BN_num_bits(from-&gt;n);
-    if (!RSAref_bn2bin(from-&gt;n, to-&gt;modulus, MAX_RSA_MODULUS_LEN))
-        return (0);
-    if (!RSAref_bn2bin(from-&gt;e, to-&gt;exponent, MAX_RSA_MODULUS_LEN))
-        return (0);
-    return (1);
-}
-
-static int RSAref_Private_eay2ref(RSA *from, R_RSA_PRIVATE_KEY * to)
-{
-    to-&gt;bits = BN_num_bits(from-&gt;n);
-    if (!RSAref_bn2bin(from-&gt;n, to-&gt;modulus, MAX_RSA_MODULUS_LEN))
-        return (0);
-    if (!RSAref_bn2bin(from-&gt;e, to-&gt;publicExponent, MAX_RSA_MODULUS_LEN))
-        return (0);
-    if (!RSAref_bn2bin(from-&gt;d, to-&gt;exponent, MAX_RSA_MODULUS_LEN))
-        return (0);
-    if (!RSAref_bn2bin(from-&gt;p, to-&gt;prime[0], MAX_RSA_PRIME_LEN))
-        return (0);
-    if (!RSAref_bn2bin(from-&gt;q, to-&gt;prime[1], MAX_RSA_PRIME_LEN))
-        return (0);
-    if (!RSAref_bn2bin(from-&gt;dmp1, to-&gt;primeExponent[0], MAX_RSA_PRIME_LEN))
-        return (0);
-    if (!RSAref_bn2bin(from-&gt;dmq1, to-&gt;primeExponent[1], MAX_RSA_PRIME_LEN))
-        return (0);
-    if (!RSAref_bn2bin(from-&gt;iqmp, to-&gt;coefficient, MAX_RSA_PRIME_LEN))
-        return (0);
-    return (1);
-}
-
-static int rsaref_private_decrypt(int len, const unsigned char *from,
-                                  unsigned char *to, RSA *rsa, int padding)
-{
-    int i, outlen = -1;
-    R_RSA_PRIVATE_KEY RSAkey;
-
-    if (!RSAref_Private_eay2ref(rsa, &amp;RSAkey))
-        goto err;
-    if ((i =
-         RSAPrivateDecrypt(to, (unsigned int *)&amp;outlen, (unsigned char *)from,
-                           len, &amp;RSAkey)) != 0) {
-        RSAREFerr(RSAREF_F_RSAREF_PRIVATE_DECRYPT, i);
-        outlen = -1;
-    }
- err:
-    memset(&amp;RSAkey, 0, sizeof(RSAkey));
-    return (outlen);
-}
-
-static int rsaref_private_encrypt(int len, const unsigned char *from,
-                                  unsigned char *to, RSA *rsa, int padding)
-{
-    int i, outlen = -1;
-    R_RSA_PRIVATE_KEY RSAkey;
-
-    if (padding != RSA_PKCS1_PADDING) {
-        RSAREFerr(RSAREF_F_RSAREF_PRIVATE_ENCRYPT,
-                  RSA_R_UNKNOWN_PADDING_TYPE);
-        goto err;
-    }
-    if (!RSAref_Private_eay2ref(rsa, &amp;RSAkey))
-        goto err;
-    if ((i =
-         RSAPrivateEncrypt(to, (unsigned int *)&amp;outlen, (unsigned char *)from,
-                           len, &amp;RSAkey)) != 0) {
-        RSAREFerr(RSAREF_F_RSAREF_PRIVATE_ENCRYPT, i);
-        outlen = -1;
-    }
- err:
-    memset(&amp;RSAkey, 0, sizeof(RSAkey));
-    return (outlen);
-}
-
-static int rsaref_public_decrypt(int len, const unsigned char *from,
-                                 unsigned char *to, RSA *rsa, int padding)
-{
-    int i, outlen = -1;
-    R_RSA_PUBLIC_KEY RSAkey;
-
-    if (!RSAref_Public_eay2ref(rsa, &amp;RSAkey))
-        goto err;
-    if ((i =
-         RSAPublicDecrypt(to, (unsigned int *)&amp;outlen, (unsigned char *)from,
-                          len, &amp;RSAkey)) != 0) {
-        RSAREFerr(RSAREF_F_RSAREF_PUBLIC_DECRYPT, i);
-        outlen = -1;
-    }
- err:
-    memset(&amp;RSAkey, 0, sizeof(RSAkey));
-    return (outlen);
-}
-
-static int rsaref_public_encrypt(int len, const unsigned char *from,
-                                 unsigned char *to, RSA *rsa, int padding)
-{
-    int outlen = -1;
-    int i;
-    R_RSA_PUBLIC_KEY RSAkey;
-    R_RANDOM_STRUCT rnd;
-    unsigned char buf[16];
-
-    if (padding != RSA_PKCS1_PADDING &amp;&amp; padding != RSA_SSLV23_PADDING) {
-        RSAREFerr(RSAREF_F_RSAREF_PUBLIC_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
-        goto err;
-    }
-
-    R_RandomInit(&amp;rnd);
-    R_GetRandomBytesNeeded((unsigned int *)&amp;i, &amp;rnd);
-    while (i &gt; 0) {
-        if (RAND_bytes(buf, 16) &lt;= 0)
-            goto err;
-        R_RandomUpdate(&amp;rnd, buf, (unsigned int)((i &gt; 16) ? 16 : i));
-        i -= 16;
-    }
-
-    if (!RSAref_Public_eay2ref(rsa, &amp;RSAkey))
-        goto err;
-    if ((i =
-         RSAPublicEncrypt(to, (unsigned int *)&amp;outlen, (unsigned char *)from,
-                          len, &amp;RSAkey, &amp;rnd)) != 0) {
-        RSAREFerr(RSAREF_F_RSAREF_PUBLIC_ENCRYPT, i);
-        outlen = -1;
-        goto err;
-    }
- err:
-    memset(&amp;RSAkey, 0, sizeof(RSAkey));
-    R_RandomFinal(&amp;rnd);
-    memset(&amp;rnd, 0, sizeof(rnd));
-    return (outlen);
-}
-
-/*****************************************************************************
- * Symetric cipher and digest function registrars
- **/
-static int rsaref_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
-                          const int **nids, int nid)
-{
-    int ok = 1;
-    if (!cipher) {
-        /* We are returning a list of supported nids */
-        *nids = rsaref_cipher_nids;
-        return (sizeof(rsaref_cipher_nids) -
-                1) / sizeof(rsaref_cipher_nids[0]);
-    }
-    /* We are being asked for a specific cipher */
-    switch (nid) {
-    case NID_des_cbc:
-        *cipher = &amp;cipher_des_cbc;
-        break;
-    case NID_des_ede3_cbc:
-        *cipher = &amp;cipher_des_ede3_cbc;
-        break;
-    case NID_desx_cbc:
-        *cipher = &amp;cipher_desx_cbc;
-        break;
-    default:
-        ok = 0;
-        *cipher = NULL;
-        break;
-    }
-    return ok;
-}
-
-static int rsaref_digests(ENGINE *e, const EVP_MD **digest,
-                          const int **nids, int nid)
-{
-    int ok = 1;
-    if (!digest) {
-        /* We are returning a list of supported nids */
-        *nids = rsaref_digest_nids;
-        return (sizeof(rsaref_digest_nids) -
-                1) / sizeof(rsaref_digest_nids[0]);
-    }
-    /* We are being asked for a specific digest */
-    switch (nid) {
-    case NID_md2:
-        *digest = &amp;digest_md2;
-        break;
-    case NID_md5:
-        *digest = &amp;digest_md5;
-        break;
-    default:
-        ok = 0;
-        *digest = NULL;
-        break;
-    }
-    return ok;
-}
-
-/*****************************************************************************
- * DES functions
- **/
-#undef data
-#define data(ctx) ((DES_CBC_CTX *)(ctx)-&gt;cipher_data)
-static int cipher_des_cbc_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
-                               const unsigned char *iv, int enc)
-{
-    DES_CBCInit(data(ctx), (unsigned char *)key, (unsigned char *)iv, enc);
-    return 1;
-}
-
-static int cipher_des_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                               const unsigned char *in, unsigned int inl)
-{
-    int ret = DES_CBCUpdate(data(ctx), out, (unsigned char *)in, inl);
-    switch (ret) {
-    case RE_LEN:
-        RSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,
-                  RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED);
-        break;
-    case 0:
-        break;
-    default:
-        RSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE, RSAREF_R_UNKNOWN_FAULT);
-    }
-    return !ret;
-}
-
-static int cipher_des_cbc_clean(EVP_CIPHER_CTX *ctx)
-{
-    memset(data(ctx), 0, ctx-&gt;cipher-&gt;ctx_size);
-    return 1;
-}
-
-#undef data
-#define data(ctx) ((DES3_CBC_CTX *)(ctx)-&gt;cipher_data)
-static int cipher_des_ede3_cbc_init(EVP_CIPHER_CTX *ctx,
-                                    const unsigned char *key,
-                                    const unsigned char *iv, int enc)
-{
-    DES3_CBCInit(data(ctx), (unsigned char *)key, (unsigned char *)iv, enc);
-    return 1;
-}
-
-static int cipher_des_ede3_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                                    const unsigned char *in, unsigned int inl)
-{
-    int ret = DES3_CBCUpdate(data(ctx), out, (unsigned char *)in, inl);
-    switch (ret) {
-    case RE_LEN:
-        RSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,
-                  RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED);
-        break;
-    case 0:
-        break;
-    default:
-        RSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE, RSAREF_R_UNKNOWN_FAULT);
-    }
-    return !ret;
-}
-
-static int cipher_des_ede3_cbc_clean(EVP_CIPHER_CTX *ctx)
-{
-    memset(data(ctx), 0, ctx-&gt;cipher-&gt;ctx_size);
-    return 1;
-}
-
-#undef data
-#define data(ctx) ((DESX_CBC_CTX *)(ctx)-&gt;cipher_data)
-static int cipher_desx_cbc_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
-                                const unsigned char *iv, int enc)
-{
-    DESX_CBCInit(data(ctx), (unsigned char *)key, (unsigned char *)iv, enc);
-    return 1;
-}
-
-static int cipher_desx_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                                const unsigned char *in, unsigned int inl)
-{
-    int ret = DESX_CBCUpdate(data(ctx), out, (unsigned char *)in, inl);
-    switch (ret) {
-    case RE_LEN:
-        RSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,
-                  RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED);
-        break;
-    case 0:
-        break;
-    default:
-        RSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE, RSAREF_R_UNKNOWN_FAULT);
-    }
-    return !ret;
-}
-
-static int cipher_desx_cbc_clean(EVP_CIPHER_CTX *ctx)
-{
-    memset(data(ctx), 0, ctx-&gt;cipher-&gt;ctx_size);
-    return 1;
-}
-
-/*****************************************************************************
- * MD functions
- **/
-#undef data
-#define data(ctx) ((MD2_CTX *)(ctx)-&gt;md_data)
-static int digest_md2_init(EVP_MD_CTX *ctx)
-{
-    MD2Init(data(ctx));
-    return 1;
-}
-
-static int digest_md2_update(EVP_MD_CTX *ctx, const void *data,
-                             unsigned long count)
-{
-    MD2Update(data(ctx), (unsigned char *)data, (unsigned int)count);
-    return 1;
-}
-
-static int digest_md2_final(EVP_MD_CTX *ctx, unsigned char *md)
-{
-    MD2Final(md, data(ctx));
-    return 1;
-}
-
-#undef data
-#define data(ctx) ((MD5_CTX *)(ctx)-&gt;md_data)
-static int digest_md5_init(EVP_MD_CTX *ctx)
-{
-    MD5Init(data(ctx));
-    return 1;
-}
-
-static int digest_md5_update(EVP_MD_CTX *ctx, const void *data,
-                             unsigned long count)
-{
-    MD5Update(data(ctx), (unsigned char *)data, (unsigned int)count);
-    return 1;
-}
-
-static int digest_md5_final(EVP_MD_CTX *ctx, unsigned char *md)
-{
-    MD5Final(md, data(ctx));
-    return 1;
-}
diff --git a/demos/engines/rsaref/rsaref.ec b/demos/engines/rsaref/rsaref.ec
deleted file mode 100644
index c690ae3..0000000
--- a/demos/engines/rsaref/rsaref.ec
+++ /dev/null
@@ -1,8 +0,0 @@
-# configuration file for util/mkerr.pl
-#
-# use like this:
-#
-#	perl ../../../util/mkerr.pl -conf rsaref.ec \
-#		-nostatic -staticloader -write *.c
-
-L RSAREF	rsaref_err.h			rsaref_err.c
diff --git a/demos/engines/rsaref/rsaref_err.c b/demos/engines/rsaref/rsaref_err.c
deleted file mode 100644
index 377dcdd..0000000
--- a/demos/engines/rsaref/rsaref_err.c
+++ /dev/null
@@ -1,157 +0,0 @@
-/* ====================================================================
- * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at OpenSSL.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-/*
- * NOTE: this file was auto generated by the mkerr.pl script: any changes
- * made to it will be overwritten when the script next updates this file,
- * only reason strings will be preserved.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &quot;rsaref_err.h&quot;
-
-/* BEGIN ERROR CODES */
-#ifndef OPENSSL_NO_ERR
-static ERR_STRING_DATA RSAREF_str_functs[] = {
-    {ERR_PACK(0, RSAREF_F_BNREF_MOD_EXP, 0), &quot;BNREF_MOD_EXP&quot;},
-    {ERR_PACK(0, RSAREF_F_CIPHER_DES_CBC_CODE, 0), &quot;CIPHER_DES_CBC_CODE&quot;},
-    {ERR_PACK(0, RSAREF_F_RSAREF_BN2BIN, 0), &quot;RSAREF_BN2BIN&quot;},
-    {ERR_PACK(0, RSAREF_F_RSAREF_MOD_EXP, 0), &quot;RSAREF_MOD_EXP&quot;},
-    {ERR_PACK(0, RSAREF_F_RSAREF_PRIVATE_DECRYPT, 0),
-     &quot;RSAREF_PRIVATE_DECRYPT&quot;},
-    {ERR_PACK(0, RSAREF_F_RSAREF_PRIVATE_ENCRYPT, 0),
-     &quot;RSAREF_PRIVATE_ENCRYPT&quot;},
-    {ERR_PACK(0, RSAREF_F_RSAREF_PUBLIC_DECRYPT, 0), &quot;RSAREF_PUBLIC_DECRYPT&quot;},
-    {ERR_PACK(0, RSAREF_F_RSAREF_PUBLIC_ENCRYPT, 0), &quot;RSAREF_PUBLIC_ENCRYPT&quot;},
-    {ERR_PACK(0, RSAREF_F_RSA_BN2BIN, 0), &quot;RSA_BN2BIN&quot;},
-    {ERR_PACK(0, RSAREF_F_RSA_PRIVATE_DECRYPT, 0), &quot;RSA_PRIVATE_DECRYPT&quot;},
-    {ERR_PACK(0, RSAREF_F_RSA_PRIVATE_ENCRYPT, 0), &quot;RSA_PRIVATE_ENCRYPT&quot;},
-    {ERR_PACK(0, RSAREF_F_RSA_PUBLIC_DECRYPT, 0), &quot;RSA_PUBLIC_DECRYPT&quot;},
-    {ERR_PACK(0, RSAREF_F_RSA_PUBLIC_ENCRYPT, 0), &quot;RSA_PUBLIC_ENCRYPT&quot;},
-    {0, NULL}
-};
-
-static ERR_STRING_DATA RSAREF_str_reasons[] = {
-    {RSAREF_R_CONTENT_ENCODING, &quot;content encoding&quot;},
-    {RSAREF_R_DATA, &quot;data&quot;},
-    {RSAREF_R_DIGEST_ALGORITHM, &quot;digest algorithm&quot;},
-    {RSAREF_R_ENCODING, &quot;encoding&quot;},
-    {RSAREF_R_ENCRYPTION_ALGORITHM, &quot;encryption algorithm&quot;},
-    {RSAREF_R_KEY, &quot;key&quot;},
-    {RSAREF_R_KEY_ENCODING, &quot;key encoding&quot;},
-    {RSAREF_R_LEN, &quot;len&quot;},
-    {RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED, &quot;length not block aligned&quot;},
-    {RSAREF_R_MODULUS_LEN, &quot;modulus len&quot;},
-    {RSAREF_R_NEED_RANDOM, &quot;need random&quot;},
-    {RSAREF_R_PRIVATE_KEY, &quot;private key&quot;},
-    {RSAREF_R_PUBLIC_KEY, &quot;public key&quot;},
-    {RSAREF_R_SIGNATURE, &quot;signature&quot;},
-    {RSAREF_R_SIGNATURE_ENCODING, &quot;signature encoding&quot;},
-    {RSAREF_R_UNKNOWN_FAULT, &quot;unknown fault&quot;},
-    {0, NULL}
-};
-
-#endif
-
-#ifdef RSAREF_LIB_NAME
-static ERR_STRING_DATA RSAREF_lib_name[] = {
-    {0, RSAREF_LIB_NAME},
-    {0, NULL}
-};
-#endif
-
-static int RSAREF_lib_error_code = 0;
-static int RSAREF_error_init = 1;
-
-static void ERR_load_RSAREF_strings(void)
-{
-    if (RSAREF_lib_error_code == 0)
-        RSAREF_lib_error_code = ERR_get_next_error_library();
-
-    if (RSAREF_error_init) {
-        RSAREF_error_init = 0;
-#ifndef OPENSSL_NO_ERR
-        ERR_load_strings(RSAREF_lib_error_code, RSAREF_str_functs);
-        ERR_load_strings(RSAREF_lib_error_code, RSAREF_str_reasons);
-#endif
-
-#ifdef RSAREF_LIB_NAME
-        RSAREF_lib_name-&gt;error = ERR_PACK(RSAREF_lib_error_code, 0, 0);
-        ERR_load_strings(0, RSAREF_lib_name);
-#endif
-    }
-}
-
-static void ERR_unload_RSAREF_strings(void)
-{
-    if (RSAREF_error_init == 0) {
-#ifndef OPENSSL_NO_ERR
-        ERR_unload_strings(RSAREF_lib_error_code, RSAREF_str_functs);
-        ERR_unload_strings(RSAREF_lib_error_code, RSAREF_str_reasons);
-#endif
-
-#ifdef RSAREF_LIB_NAME
-        ERR_unload_strings(0, RSAREF_lib_name);
-#endif
-        RSAREF_error_init = 1;
-    }
-}
-
-static void ERR_RSAREF_error(int function, int reason, char *file, int line)
-{
-    if (RSAREF_lib_error_code == 0)
-        RSAREF_lib_error_code = ERR_get_next_error_library();
-    ERR_PUT_error(RSAREF_lib_error_code, function, reason, file, line);
-}
diff --git a/demos/engines/rsaref/rsaref_err.h b/demos/engines/rsaref/rsaref_err.h
deleted file mode 100644
index d230503..0000000
--- a/demos/engines/rsaref/rsaref_err.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/* ====================================================================
- * Copyright (c) 1998-2001 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-#ifndef HEADER_RSAREF_ERR_H
-# define HEADER_RSAREF_ERR_H
-
-#ifdef  __cplusplus
-extern &quot;C&quot; {
-#endif
-
-/* BEGIN ERROR CODES */
-/*
- * The following lines are auto generated by the script mkerr.pl. Any changes
- * made after this point may be overwritten when the script is next run.
- */
-static void ERR_load_RSAREF_strings(void);
-static void ERR_unload_RSAREF_strings(void);
-static void ERR_RSAREF_error(int function, int reason, char *file, int line);
-# define RSAREFerr(f,r) ERR_RSAREF_error((f),(r),OPENSSL_FILE,OPENSSL_LINE)
-/* Error codes for the RSAREF functions. */
-
-/* Function codes. */
-# define RSAREF_F_BNREF_MOD_EXP                           100
-# define RSAREF_F_CIPHER_DES_CBC_CODE                     112
-# define RSAREF_F_RSAREF_BN2BIN                           101
-# define RSAREF_F_RSAREF_MOD_EXP                          102
-# define RSAREF_F_RSAREF_PRIVATE_DECRYPT                  103
-# define RSAREF_F_RSAREF_PRIVATE_ENCRYPT                  104
-# define RSAREF_F_RSAREF_PUBLIC_DECRYPT                   105
-# define RSAREF_F_RSAREF_PUBLIC_ENCRYPT                   106
-# define RSAREF_F_RSA_BN2BIN                              107
-# define RSAREF_F_RSA_PRIVATE_DECRYPT                     108
-# define RSAREF_F_RSA_PRIVATE_ENCRYPT                     109
-# define RSAREF_F_RSA_PUBLIC_DECRYPT                      110
-# define RSAREF_F_RSA_PUBLIC_ENCRYPT                      111
-
-/* Reason codes. */
-# define RSAREF_R_CONTENT_ENCODING                        100
-# define RSAREF_R_DATA                                    101
-# define RSAREF_R_DIGEST_ALGORITHM                        102
-# define RSAREF_R_ENCODING                                103
-# define RSAREF_R_ENCRYPTION_ALGORITHM                    104
-# define RSAREF_R_KEY                                     105
-# define RSAREF_R_KEY_ENCODING                            106
-# define RSAREF_R_LEN                                     107
-# define RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED                114
-# define RSAREF_R_MODULUS_LEN                             108
-# define RSAREF_R_NEED_RANDOM                             109
-# define RSAREF_R_PRIVATE_KEY                             110
-# define RSAREF_R_PUBLIC_KEY                              111
-# define RSAREF_R_SIGNATURE                               112
-# define RSAREF_R_SIGNATURE_ENCODING                      113
-# define RSAREF_R_UNKNOWN_FAULT                           115
-
-#ifdef  __cplusplus
-}
-#endif
-#endif
diff --git a/demos/engines/zencod/Makefile.in b/demos/engines/zencod/Makefile.in
deleted file mode 100644
index f4dd7c8..0000000
--- a/demos/engines/zencod/Makefile.in
+++ /dev/null
@@ -1,93 +0,0 @@
-LIBNAME=	libzencod
-SRC=		hw_zencod.c
-OBJ=		hw_zencod.o
-HEADER=		hw_zencod.h
-
-CC=		gcc
-PIC=		-fPIC
-CFLAGS=		-g -I../../../include $(PIC) -DENGINE_DYNAMIC_SUPPORT -DFLAT_INC
-AR=		ar r
-RANLIB=		ranlib
-
-LIB=		$(LIBNAME).a
-SHLIB=		$(LIBNAME).so
-
-all:
-		@echo 'Please choose a system to build on:'
-		@echo ''
-		@echo 'tru64:    Tru64 Unix, Digital Unix, Digital OSF/1'
-		@echo 'solaris:  Solaris'
-		@echo 'irix:     IRIX'
-		@echo 'hpux32:   32-bit HP/UX'
-		@echo 'hpux64:   64-bit HP/UX'
-		@echo 'aix:      AIX'
-		@echo 'gnu:      Generic GNU-based system (gcc and GNU ld)'
-		@echo ''
-
-generate:
-		perl ../../../util/mkerr.pl -conf hw_zencod.ec \
-			-nostatic -staticloader -write hw_zencod.c
-
-gnu:		$(SHLIB).gnu
-tru64:		$(SHLIB).tru64
-solaris:	$(SHLIB).solaris
-irix:		$(SHLIB).irix
-hpux32:		$(SHLIB).hpux32
-hpux64:		$(SHLIB).hpux64
-aix:		$(SHLIB).aix
-
-$(LIB):		$(OBJ)
-		$(AR) $(LIB) $(OBJ)
-		- $(RANLIB) $(LIB)
-
-LINK_SO=	\
-  ld -r -o $(LIBNAME).o $$ALLSYMSFLAGS $(LIB) &amp;&amp; \
-  (nm -Pg $(LIBNAME).o | grep ' [BDT] ' | cut -f1 -d' ' &gt; $(LIBNAME).exp; \
-   $$SHAREDCMD $$SHAREDFLAGS -o $(SHLIB) $(LIBNAME).o -L ../../.. -lcrypto -lc)
-
-$(SHLIB).gnu:	$(LIB)
-		ALLSYMSFLAGS='--whole-archive' \
-		SHAREDFLAGS='-shared -Wl,-soname=$(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).gnu
-$(SHLIB).tru64:	$(LIB)
-		ALLSYMSFLAGS='-all' \
-		SHAREDFLAGS='-shared' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).tru64
-$(SHLIB).solaris:	$(LIB)
-		ALLSYMSFLAGS='-z allextract' \
-		SHAREDFLAGS='-G -h $(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).solaris
-$(SHLIB).irix:	$(LIB)
-		ALLSYMSFLAGS='-all' \
-		SHAREDFLAGS='-shared -Wl,-soname,$(SHLIB)' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).irix
-$(SHLIB).hpux32:	$(LIB)
-		ALLSYMSFLAGS='-Fl' \
-		SHAREDFLAGS='+vnocompatwarnings -b -z +s +h $(SHLIB)' \
-		SHAREDCMD='/usr/ccs/bin/ld'; \
-		$(LINK_SO)
-		touch $(SHLIB).hpux32
-$(SHLIB).hpux64:	$(LIB)
-		ALLSYMSFLAGS='+forceload' \
-		SHAREDFLAGS='-b -z +h $(SHLIB)' \
-		SHAREDCMD='/usr/ccs/bin/ld'; \
-		$(LINK_SO)
-		touch $(SHLIB).hpux64
-$(SHLIB).aix:	$(LIB)
-		ALLSYMSFLAGS='-bnogc' \
-		SHAREDFLAGS='-G -bE:$(LIBNAME).exp -bM:SRE' \
-		SHAREDCMD='$(CC)'; \
-		$(LINK_SO)
-		touch $(SHLIB).aix
-
-depend:
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
diff --git a/demos/engines/zencod/hw_zencod.c b/demos/engines/zencod/hw_zencod.c
deleted file mode 100644
index 1c34677..0000000
--- a/demos/engines/zencod/hw_zencod.c
+++ /dev/null
@@ -1,1785 +0,0 @@
- /*
-  * Written by Fred Donnat (<A HREF="../../../mailman/listinfo/openssl-commits.html">frederic.donnat at zencod.com</A>) for &quot;zencod&quot; * engine
-  * integration in order to redirect crypto computing on a crypto * hardware
-  * accelerator zenssl32 ;-) * * Date : 25 jun 2002 * Revision : 17 Ju7 2002
-  * * Version : zencod_engine-0.9.7
-  */
-
-/* ====================================================================
- * Copyright (c) 1999-2001 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">licensing at OpenSSL.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-/* ENGINE general include */
-#include &lt;stdio.h&gt;
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/dso.h&gt;
-#include &lt;openssl/engine.h&gt;
-
-#ifndef OPENSSL_NO_HW
-# ifndef OPENSSL_NO_HW_ZENCOD
-
-#  ifdef FLAT_INC
-#   include &quot;hw_zencod.h&quot;
-#  else
-#   include &quot;vendor_defns/hw_zencod.h&quot;
-#  endif
-
-#  define ZENCOD_LIB_NAME &quot;zencod engine&quot;
-#  include &quot;hw_zencod_err.c&quot;
-
-#  define FAIL_TO_SOFTWARE                -15
-
-#  define ZEN_LIBRARY     &quot;zenbridge&quot;
-
-#  ifdef ZENCOD_TRACING
-#   define PERROR(s)     perror(s)
-#   define CHEESE()      fputs(&quot;## [ZenEngine] ## &quot; __FUNCTION__ &quot;\n&quot;, stderr)
-#  else
-#   define PERROR(s)
-#   define CHEESE()
-#  endif
-
-/* Sorry ;) */
-#  ifndef WIN32
-static inline void esrever(unsigned char *d, int l)
-{
-    for (; --l &gt; 0; --l, d++) {
-        *d ^= *(d + l);
-        *(d + l) ^= *d;
-        *d ^= *(d + l);
-    }
-}
-
-static inline void ypcmem(unsigned char *d, const unsigned char *s, int l)
-{
-    for (d += l; l--;)
-        *--d = *s++;
-}
-#  else
-static __inline void esrever(unsigned char *d, int l)
-{
-    for (; --l &gt; 0; --l, d++) {
-        *d ^= *(d + l);
-        *(d + l) ^= *d;
-        *d ^= *(d + l);
-    }
-}
-
-static __inline void ypcmem(unsigned char *d, const unsigned char *s, int l)
-{
-    for (d += l; l--;)
-        *--d = *s++;
-}
-#  endif
-
-#  define BIGNUM2ZEN(n, bn)       (ptr_zencod_init_number((n), \
-                                        (unsigned long) ((bn)-&gt;top * BN_BITS2), \
-                                        (unsigned char *) ((bn)-&gt;d)))
-
-#  define ZEN_BITS(n, bytes)      (ptr_zencod_bytes2bits((unsigned char *) (n), (unsigned long) (bytes)))
-#  define ZEN_BYTES(bits) (ptr_zencod_bits2bytes((unsigned long) (bits)))
-
-/* Function for ENGINE detection and control */
-static int zencod_destroy(ENGINE *e);
-static int zencod_init(ENGINE *e);
-static int zencod_finish(ENGINE *e);
-static int zencod_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) ());
-
-/* BIGNUM stuff */
-static int zencod_bn_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                             const BIGNUM *m, BN_CTX *ctx);
-
-/* RSA stuff */
-#  ifndef OPENSSL_NO_RSA
-static int RSA_zencod_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa);
-static int RSA_zencod_bn_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                                 const BIGNUM *m, BN_CTX *ctx,
-                                 BN_MONT_CTX *m_ctx);
-#  endif
-
-/* DSA stuff */
-#  ifndef OPENSSL_NO_DSA
-static int DSA_zencod_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a,
-                                 const BIGNUM *p, const BIGNUM *m,
-                                 BN_CTX *ctx, BN_MONT_CTX *m_ctx);
-
-static DSA_SIG *DSA_zencod_do_sign(const unsigned char *dgst, int dlen,
-                                   DSA *dsa);
-static int DSA_zencod_do_verify(const unsigned char *dgst, int dgst_len,
-                                DSA_SIG *sig, DSA *dsa);
-#  endif
-
-/* DH stuff */
-#  ifndef OPENSSL_NO_DH
-static int DH_zencod_bn_mod_exp(const DH *dh, BIGNUM *r, const BIGNUM *a,
-                                const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
-                                BN_MONT_CTX *m_ctx);
-static int DH_zencod_generate_key(DH *dh);
-static int DH_zencod_compute_key(unsigned char *key, const BIGNUM *pub_key,
-                                 DH *dh);
-#  endif
-
-/* Rand stuff */
-static void RAND_zencod_seed(const void *buf, int num);
-static int RAND_zencod_rand_bytes(unsigned char *buf, int num);
-static int RAND_zencod_rand_status(void);
-
-/* Digest Stuff */
-static int engine_digests(ENGINE *e, const EVP_MD **digest, const int **nids,
-                          int nid);
-
-/* Cipher Stuff */
-static int engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
-                          const int **nids, int nid);
-
-#  define ZENCOD_CMD_SO_PATH                      ENGINE_CMD_BASE
-static const ENGINE_CMD_DEFN zencod_cmd_defns[] = {
-    {ZENCOD_CMD_SO_PATH,
-     &quot;SO_PATH&quot;,
-     &quot;Specifies the path to the 'zenbridge' shared library&quot;,
-     ENGINE_CMD_FLAG_STRING},
-    {0, NULL, NULL, 0}
-};
-
-#  ifndef OPENSSL_NO_RSA
-/*
- * Our internal RSA_METHOD specific to zencod ENGINE providing pointers to
- * our function
- */
-static RSA_METHOD zencod_rsa = {
-    &quot;ZENCOD RSA method&quot;,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    RSA_zencod_rsa_mod_exp,
-    RSA_zencod_bn_mod_exp,
-    NULL,
-    NULL,
-    0,
-    NULL,
-    NULL,
-    NULL
-};
-#  endif
-
-#  ifndef OPENSSL_NO_DSA
-/*
- * Our internal DSA_METHOD specific to zencod ENGINE providing pointers to
- * our function
- */
-static DSA_METHOD zencod_dsa = {
-    &quot;ZENCOD DSA method&quot;,
-    DSA_zencod_do_sign,
-    NULL,
-    DSA_zencod_do_verify,
-    NULL,
-    DSA_zencod_bn_mod_exp,
-    NULL,
-    NULL,
-    0,
-    NULL
-};
-#  endif
-
-#  ifndef OPENSSL_NO_DH
-/*
- * Our internal DH_METHOD specific to zencod ENGINE providing pointers to our
- * function
- */
-static DH_METHOD zencod_dh = {
-    &quot;ZENCOD DH method&quot;,
-    DH_zencod_generate_key,
-    DH_zencod_compute_key,
-    DH_zencod_bn_mod_exp,
-    NULL,
-    NULL,
-    0,
-    NULL
-};
-#  endif
-
-/*
- * Our internal RAND_meth specific to zencod ZNGINE providing pointers to our
- * function
- */
-static RAND_METHOD zencod_rand = {
-    RAND_zencod_seed,
-    RAND_zencod_rand_bytes,
-    NULL,
-    NULL,
-    RAND_zencod_rand_bytes,
-    RAND_zencod_rand_status
-};
-
-/* Constants used when creating the ENGINE */
-static const char *engine_zencod_id = &quot;zencod&quot;;
-static const char *engine_zencod_name = &quot;ZENCOD hardware engine support&quot;;
-
-/*
- * This internal function is used by ENGINE_zencod () and possibly by the
- * &quot;dynamic&quot; ENGINE support too ;-)
- */
-static int bind_helper(ENGINE *e)
-{
-
-#  ifndef OPENSSL_NO_RSA
-    const RSA_METHOD *meth_rsa;
-#  endif
-#  ifndef OPENSSL_NO_DSA
-    const DSA_METHOD *meth_dsa;
-#  endif
-#  ifndef OPENSSL_NO_DH
-    const DH_METHOD *meth_dh;
-#  endif
-
-    const RAND_METHOD *meth_rand;
-
-    if (!ENGINE_set_id(e, engine_zencod_id) ||
-        !ENGINE_set_name(e, engine_zencod_name) ||
-#  ifndef OPENSSL_NO_RSA
-        !ENGINE_set_RSA(e, &amp;zencod_rsa) ||
-#  endif
-#  ifndef OPENSSL_NO_DSA
-        !ENGINE_set_DSA(e, &amp;zencod_dsa) ||
-#  endif
-#  ifndef OPENSSL_NO_DH
-        !ENGINE_set_DH(e, &amp;zencod_dh) ||
-#  endif
-        !ENGINE_set_RAND(e, &amp;zencod_rand) ||
-        !ENGINE_set_destroy_function(e, zencod_destroy) ||
-        !ENGINE_set_init_function(e, zencod_init) ||
-        !ENGINE_set_finish_function(e, zencod_finish) ||
-        !ENGINE_set_ctrl_function(e, zencod_ctrl) ||
-        !ENGINE_set_cmd_defns(e, zencod_cmd_defns) ||
-        !ENGINE_set_digests(e, engine_digests) ||
-        !ENGINE_set_ciphers(e, engine_ciphers)) {
-        return 0;
-    }
-#  ifndef OPENSSL_NO_RSA
-    /*
-     * We know that the &quot;PKCS1_OpenSSL()&quot; functions hook properly to the
-     * Zencod-specific mod_exp and mod_exp_crt so we use those functions. NB:
-     * We don't use ENGINE_openssl() or anything &quot;more generic&quot; because
-     * something like the RSAref code may not hook properly, and if you own
-     * one of these cards then you have the right to do RSA operations on it
-     * anyway!
-     */
-    meth_rsa = RSA_PKCS1_OpenSSL();
-
-    zencod_rsa.rsa_pub_enc = meth_rsa-&gt;rsa_pub_enc;
-    zencod_rsa.rsa_pub_dec = meth_rsa-&gt;rsa_pub_dec;
-    zencod_rsa.rsa_priv_enc = meth_rsa-&gt;rsa_priv_enc;
-    zencod_rsa.rsa_priv_dec = meth_rsa-&gt;rsa_priv_dec;
-    /* meth_rsa-&gt;rsa_mod_exp */
-    /* meth_rsa-&gt;bn_mod_exp */
-    zencod_rsa.init = meth_rsa-&gt;init;
-    zencod_rsa.finish = meth_rsa-&gt;finish;
-#  endif
-
-#  ifndef OPENSSL_NO_DSA
-    /*
-     * We use OpenSSL meth to supply what we don't provide ;-*)
-     */
-    meth_dsa = DSA_OpenSSL();
-
-    /* meth_dsa-&gt;dsa_do_sign */
-    zencod_dsa.dsa_sign_setup = meth_dsa-&gt;dsa_sign_setup;
-    /* meth_dsa-&gt;dsa_do_verify */
-    zencod_dsa.dsa_mod_exp = meth_dsa-&gt;dsa_mod_exp;
-    /* zencod_dsa.bn_mod_exp = meth_dsa-&gt;bn_mod_exp ; */
-    zencod_dsa.init = meth_dsa-&gt;init;
-    zencod_dsa.finish = meth_dsa-&gt;finish;
-#  endif
-
-#  ifndef OPENSSL_NO_DH
-    /*
-     * We use OpenSSL meth to supply what we don't provide ;-*)
-     */
-    meth_dh = DH_OpenSSL();
-
-    /* zencod_dh.generate_key = meth_dh-&gt;generate_key ; */
-    /* zencod_dh.compute_key = meth_dh-&gt;compute_key ; */
-    /* zencod_dh.bn_mod_exp = meth_dh-&gt;bn_mod_exp ; */
-    zencod_dh.init = meth_dh-&gt;init;
-    zencod_dh.finish = meth_dh-&gt;finish;
-
-#  endif
-
-    /*
-     * We use OpenSSL meth to supply what we don't provide ;-*)
-     */
-    meth_rand = RAND_OpenSSL();
-
-    /* meth_rand-&gt;seed ; */
-    /* zencod_rand.seed = meth_rand-&gt;seed ; */
-    /* meth_rand-&gt;bytes ; */
-    /* zencod_rand.bytes = meth_rand-&gt;bytes ; */
-    zencod_rand.cleanup = meth_rand-&gt;cleanup;
-    zencod_rand.add = meth_rand-&gt;add;
-    /* meth_rand-&gt;pseudorand ; */
-    /* zencod_rand.pseudorand = meth_rand-&gt;pseudorand ; */
-    /* zencod_rand.status = meth_rand-&gt;status ; */
-    /* meth_rand-&gt;status ; */
-
-    /* Ensure the zencod error handling is set up */
-    ERR_load_ZENCOD_strings();
-    return 1;
-}
-
-/*
- * As this is only ever called once, there's no need for locking (indeed -
- * the lock will already be held by our caller!!!)
- */
-static ENGINE *ENGINE_zencod(void)
-{
-
-    ENGINE *eng = ENGINE_new();
-
-    if (!eng) {
-        return NULL;
-    }
-    if (!bind_helper(eng)) {
-        ENGINE_free(eng);
-        return NULL;
-    }
-
-    return eng;
-}
-
-#  ifdef ENGINE_DYNAMIC_SUPPORT
-static
-#  endif
-void ENGINE_load_zencod(void)
-{
-    /* Copied from eng_[openssl|dyn].c */
-    ENGINE *toadd = ENGINE_zencod();
-    if (!toadd)
-        return;
-    ENGINE_add(toadd);
-    ENGINE_free(toadd);
-    ERR_clear_error();
-}
-
-/*
- * This is a process-global DSO handle used for loading and unloading the
- * ZENBRIDGE library. NB: This is only set (or unset) during an * init () or
- * finish () call (reference counts permitting) and they're * operating with
- * global locks, so this should be thread-safe * implicitly.
- */
-static DSO *zencod_dso = NULL;
-
-static t_zencod_test *ptr_zencod_test = NULL;
-static t_zencod_bytes2bits *ptr_zencod_bytes2bits = NULL;
-static t_zencod_bits2bytes *ptr_zencod_bits2bytes = NULL;
-static t_zencod_new_number *ptr_zencod_new_number = NULL;
-static t_zencod_init_number *ptr_zencod_init_number = NULL;
-
-static t_zencod_rsa_mod_exp *ptr_zencod_rsa_mod_exp = NULL;
-static t_zencod_rsa_mod_exp_crt *ptr_zencod_rsa_mod_exp_crt = NULL;
-static t_zencod_dsa_do_sign *ptr_zencod_dsa_do_sign = NULL;
-static t_zencod_dsa_do_verify *ptr_zencod_dsa_do_verify = NULL;
-static t_zencod_dh_generate_key *ptr_zencod_dh_generate_key = NULL;
-static t_zencod_dh_compute_key *ptr_zencod_dh_compute_key = NULL;
-static t_zencod_rand_bytes *ptr_zencod_rand_bytes = NULL;
-static t_zencod_math_mod_exp *ptr_zencod_math_mod_exp = NULL;
-
-static t_zencod_md5_init *ptr_zencod_md5_init = NULL;
-static t_zencod_md5_update *ptr_zencod_md5_update = NULL;
-static t_zencod_md5_do_final *ptr_zencod_md5_do_final = NULL;
-static t_zencod_sha1_init *ptr_zencod_sha1_init = NULL;
-static t_zencod_sha1_update *ptr_zencod_sha1_update = NULL;
-static t_zencod_sha1_do_final *ptr_zencod_sha1_do_final = NULL;
-
-static t_zencod_xdes_cipher *ptr_zencod_xdes_cipher = NULL;
-static t_zencod_rc4_cipher *ptr_zencod_rc4_cipher = NULL;
-
-/*
- * These are the static string constants for the DSO file name and the
- * function symbol names to bind to.
- */
-static const char *ZENCOD_LIBNAME = ZEN_LIBRARY;
-
-static const char *ZENCOD_Fct_0 = &quot;test_device&quot;;
-static const char *ZENCOD_Fct_1 = &quot;zenbridge_bytes2bits&quot;;
-static const char *ZENCOD_Fct_2 = &quot;zenbridge_bits2bytes&quot;;
-static const char *ZENCOD_Fct_3 = &quot;zenbridge_new_number&quot;;
-static const char *ZENCOD_Fct_4 = &quot;zenbridge_init_number&quot;;
-
-static const char *ZENCOD_Fct_exp_1 = &quot;zenbridge_rsa_mod_exp&quot;;
-static const char *ZENCOD_Fct_exp_2 = &quot;zenbridge_rsa_mod_exp_crt&quot;;
-static const char *ZENCOD_Fct_dsa_1 = &quot;zenbridge_dsa_do_sign&quot;;
-static const char *ZENCOD_Fct_dsa_2 = &quot;zenbridge_dsa_do_verify&quot;;
-static const char *ZENCOD_Fct_dh_1 = &quot;zenbridge_dh_generate_key&quot;;
-static const char *ZENCOD_Fct_dh_2 = &quot;zenbridge_dh_compute_key&quot;;
-static const char *ZENCOD_Fct_rand_1 = &quot;zenbridge_rand_bytes&quot;;
-static const char *ZENCOD_Fct_math_1 = &quot;zenbridge_math_mod_exp&quot;;
-
-static const char *ZENCOD_Fct_md5_1 = &quot;zenbridge_md5_init&quot;;
-static const char *ZENCOD_Fct_md5_2 = &quot;zenbridge_md5_update&quot;;
-static const char *ZENCOD_Fct_md5_3 = &quot;zenbridge_md5_do_final&quot;;
-static const char *ZENCOD_Fct_sha1_1 = &quot;zenbridge_sha1_init&quot;;
-static const char *ZENCOD_Fct_sha1_2 = &quot;zenbridge_sha1_update&quot;;
-static const char *ZENCOD_Fct_sha1_3 = &quot;zenbridge_sha1_do_final&quot;;
-
-static const char *ZENCOD_Fct_xdes_1 = &quot;zenbridge_xdes_cipher&quot;;
-static const char *ZENCOD_Fct_rc4_1 = &quot;zenbridge_rc4_cipher&quot;;
-
-/*
- * Destructor (complements the &quot;ENGINE_zencod ()&quot; constructor)
- */
-static int zencod_destroy(ENGINE *e)
-{
-
-    ERR_unload_ZENCOD_strings();
-
-    return 1;
-}
-
-/*
- * (de)initialisation functions. Control Function
- */
-static int zencod_init(ENGINE *e)
-{
-
-    t_zencod_test *ptr_0;
-    t_zencod_bytes2bits *ptr_1;
-    t_zencod_bits2bytes *ptr_2;
-    t_zencod_new_number *ptr_3;
-    t_zencod_init_number *ptr_4;
-    t_zencod_rsa_mod_exp *ptr_exp_1;
-    t_zencod_rsa_mod_exp_crt *ptr_exp_2;
-    t_zencod_dsa_do_sign *ptr_dsa_1;
-    t_zencod_dsa_do_verify *ptr_dsa_2;
-    t_zencod_dh_generate_key *ptr_dh_1;
-    t_zencod_dh_compute_key *ptr_dh_2;
-    t_zencod_rand_bytes *ptr_rand_1;
-    t_zencod_math_mod_exp *ptr_math_1;
-    t_zencod_md5_init *ptr_md5_1;
-    t_zencod_md5_update *ptr_md5_2;
-    t_zencod_md5_do_final *ptr_md5_3;
-    t_zencod_sha1_init *ptr_sha1_1;
-    t_zencod_sha1_update *ptr_sha1_2;
-    t_zencod_sha1_do_final *ptr_sha1_3;
-    t_zencod_xdes_cipher *ptr_xdes_1;
-    t_zencod_rc4_cipher *ptr_rc4_1;
-
-    CHEESE();
-
-    /*
-     * We Should add some tests for non NULL parameters or bad value !!
-     * Stuff to be done ...
-     */
-
-    if (zencod_dso != NULL) {
-        ZENCODerr(ZENCOD_F_ZENCOD_INIT, ZENCOD_R_ALREADY_LOADED);
-        goto err;
-    }
-    /*
-     * Trying to load the Library &quot;cryptozen&quot;
-     */
-    zencod_dso = DSO_load(NULL, ZENCOD_LIBNAME, NULL, 0);
-    if (zencod_dso == NULL) {
-        ZENCODerr(ZENCOD_F_ZENCOD_INIT, ZENCOD_R_DSO_FAILURE);
-        goto err;
-    }
-
-    /*
-     * Trying to load Function from the Library
-     */
-#define BINDIT(t, name) (t*)DSO_bindfunc(zencod_dso, name)
-    if ((ptr_1 = BINDIT(t_zencod_bytes2bits ZENCOD_Fct_1)) == NULL
-    || (ptr_2 = BINDIT(t_zencod_bits2bytes ZENCOD_Fct_2)) == NULL
-    || (ptr_3 = BINDIT(t_zencod_new_number ZENCOD_Fct_3)) == NULL
-    || (ptr_4 = BINDIT(t_zencod_init_number ZENCOD_Fct_4)) == NULL
-    || (ptr_exp_1 = BINDIT(t_zencod_rsa_mod_exp, ZENCOD_Fct_exp_1)) == NULL
-    || (ptr_exp_2 = BINDIT(t_zencod_rsa_mod_exp_crt, ZENCOD_Fct_exp_2)) == NULL
-    || (ptr_dsa_1 = BINDIT(t_zencod_dsa_do_sign, ZENCOD_Fct_dsa_1)) == NULL
-    || (ptr_dsa_2 = BINDIT(t_zencod_dsa_do_verify, ZENCOD_Fct_dsa_2)) == NULL
-    || (ptr_dh_1 = BINDIT(t_zencod_dh_generate_key, ZENCOD_Fct_dh_1)) == NULL
-    || (ptr_dh_2 = BINDIT(t_zencod_dh_compute_key, ZENCOD_Fct_dh_2)) == NULL
-    || (ptr_rand_1 = BINDIT(t_zencod_rand_bytes, ZENCOD_Fct_rand_1)) == NULL
-    || (ptr_math_1 = BINDIT(t_zencod_math_mod_exp, ZENCOD_Fct_math_1)) == NULL
-    || (ptr_0 = BINDIT(t_zencod_test, ZENCOD_Fct_0)) == NULL
-    || (ptr_md5_1 = BINDIT(t_zencod_md5_init, ZENCOD_Fct_md5_1)) == NULL
-    || (ptr_md5_2 = BINDIT(t_zencod_md5_update, ZENCOD_Fct_md5_2)) == NULL
-    || (ptr_md5_3 = BINDIT(t_zencod_md5_do_final, ZENCOD_Fct_md5_3)) == NULL
-    || (ptr_sha1_1 = BINDIT(t_zencod_sha1_init, ZENCOD_Fct_sha1_1)) == NULL
-    || (ptr_sha1_2 = BINDIT(t_zencod_sha1_update, ZENCOD_Fct_sha1_2)) == NULL
-    || (ptr_sha1_3 = BINDIT(t_zencod_sha1_do_final, ZENCOD_Fct_sha1_3)) == NULL
-    || (ptr_xdes_1 = BINDIT(t_zencod_xdes_cipher, ZENCOD_Fct_xdes_1)) == NULL
-    || (ptr_rc4_1 = BINDIT(t_zencod_rc4_cipher, ZENCOD_Fct_rc4_1)) == NULL) {
-        ZENCODerr(ZENCOD_F_ZENCOD_INIT, ZENCOD_R_DSO_FAILURE);
-        goto err;
-    }
-
-    /*
-     * The function from &quot;cryptozen&quot; Library have been correctly loaded so
-     * copy them
-     */
-    ptr_zencod_test = ptr_0;
-    ptr_zencod_bytes2bits = ptr_1;
-    ptr_zencod_bits2bytes = ptr_2;
-    ptr_zencod_new_number = ptr_3;
-    ptr_zencod_init_number = ptr_4;
-    ptr_zencod_rsa_mod_exp = ptr_exp_1;
-    ptr_zencod_rsa_mod_exp_crt = ptr_exp_2;
-    ptr_zencod_dsa_do_sign = ptr_dsa_1;
-    ptr_zencod_dsa_do_verify = ptr_dsa_2;
-    ptr_zencod_dh_generate_key = ptr_dh_1;
-    ptr_zencod_dh_compute_key = ptr_dh_2;
-    ptr_zencod_rand_bytes = ptr_rand_1;
-    ptr_zencod_math_mod_exp = ptr_math_1;
-    ptr_zencod_test = ptr_0;
-    ptr_zencod_md5_init = ptr_md5_1;
-    ptr_zencod_md5_update = ptr_md5_2;
-    ptr_zencod_md5_do_final = ptr_md5_3;
-    ptr_zencod_sha1_init = ptr_sha1_1;
-    ptr_zencod_sha1_update = ptr_sha1_2;
-    ptr_zencod_sha1_do_final = ptr_sha1_3;
-    ptr_zencod_xdes_cipher = ptr_xdes_1;
-    ptr_zencod_rc4_cipher = ptr_rc4_1;
-
-    /*
-     * We should perform a test to see if there is actually any unit runnig on
-     * the system ... Even if the cryptozen library is loaded the module coul
-     * not be loaded on the system ... For now we may just open and close the
-     * device !!
-     */
-
-    if (ptr_zencod_test() != 0) {
-        ZENCODerr(ZENCOD_F_ZENCOD_INIT, ZENCOD_R_UNIT_FAILURE);
-        goto err;
-    }
-
-    return 1;
- err:
-    DSO_free(zencod_dso);
-    zencod_dso = NULL;
-    ptr_zencod_bytes2bits = NULL;
-    ptr_zencod_bits2bytes = NULL;
-    ptr_zencod_new_number = NULL;
-    ptr_zencod_init_number = NULL;
-    ptr_zencod_rsa_mod_exp = NULL;
-    ptr_zencod_rsa_mod_exp_crt = NULL;
-    ptr_zencod_dsa_do_sign = NULL;
-    ptr_zencod_dsa_do_verify = NULL;
-    ptr_zencod_dh_generate_key = NULL;
-    ptr_zencod_dh_compute_key = NULL;
-    ptr_zencod_rand_bytes = NULL;
-    ptr_zencod_math_mod_exp = NULL;
-    ptr_zencod_test = NULL;
-    ptr_zencod_md5_init = NULL;
-    ptr_zencod_md5_update = NULL;
-    ptr_zencod_md5_do_final = NULL;
-    ptr_zencod_sha1_init = NULL;
-    ptr_zencod_sha1_update = NULL;
-    ptr_zencod_sha1_do_final = NULL;
-    ptr_zencod_xdes_cipher = NULL;
-    ptr_zencod_rc4_cipher = NULL;
-
-    return 0;
-}
-
-static int zencod_finish(ENGINE *e)
-{
-
-    CHEESE();
-
-    /*
-     * We Should add some tests for non NULL parameters or bad value !!
-     * Stuff to be done ...
-     */
-    if (zencod_dso == NULL) {
-        ZENCODerr(ZENCOD_F_ZENCOD_FINISH, ZENCOD_R_NOT_LOADED);
-        return 0;
-    }
-    if (!DSO_free(zencod_dso)) {
-        ZENCODerr(ZENCOD_F_ZENCOD_FINISH, ZENCOD_R_DSO_FAILURE);
-        return 0;
-    }
-
-    zencod_dso = NULL;
-
-    ptr_zencod_bytes2bits = NULL;
-    ptr_zencod_bits2bytes = NULL;
-    ptr_zencod_new_number = NULL;
-    ptr_zencod_init_number = NULL;
-    ptr_zencod_rsa_mod_exp = NULL;
-    ptr_zencod_rsa_mod_exp_crt = NULL;
-    ptr_zencod_dsa_do_sign = NULL;
-    ptr_zencod_dsa_do_verify = NULL;
-    ptr_zencod_dh_generate_key = NULL;
-    ptr_zencod_dh_compute_key = NULL;
-    ptr_zencod_rand_bytes = NULL;
-    ptr_zencod_math_mod_exp = NULL;
-    ptr_zencod_test = NULL;
-    ptr_zencod_md5_init = NULL;
-    ptr_zencod_md5_update = NULL;
-    ptr_zencod_md5_do_final = NULL;
-    ptr_zencod_sha1_init = NULL;
-    ptr_zencod_sha1_update = NULL;
-    ptr_zencod_sha1_do_final = NULL;
-    ptr_zencod_xdes_cipher = NULL;
-    ptr_zencod_rc4_cipher = NULL;
-
-    return 1;
-}
-
-static int zencod_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) ())
-{
-
-    int initialised = ((zencod_dso == NULL) ? 0 : 1);
-
-    CHEESE();
-
-    /*
-     * We Should add some tests for non NULL parameters or bad value !!
-     * Stuff to be done ...
-     */
-    switch (cmd) {
-    case ZENCOD_CMD_SO_PATH:
-        if (p == NULL) {
-            ZENCODerr(ZENCOD_F_ZENCOD_CTRL, ERR_R_PASSED_NULL_PARAMETER);
-            return 0;
-        }
-        if (initialised) {
-            ZENCODerr(ZENCOD_F_ZENCOD_CTRL, ZENCOD_R_ALREADY_LOADED);
-            return 0;
-        }
-        ZENCOD_LIBNAME = (const char *)p;
-        return 1;
-    default:
-        break;
-    }
-
-    ZENCODerr(ZENCOD_F_ZENCOD_CTRL, ZENCOD_R_CTRL_COMMAND_NOT_IMPLEMENTED);
-
-    return 0;
-}
-
-/*
- * BIGNUM stuff Functions
- */
-static int zencod_bn_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                             const BIGNUM *m, BN_CTX *ctx)
-{
-    zen_nb_t y, x, e, n;
-    int ret;
-
-    CHEESE();
-
-    if (!zencod_dso) {
-        ENGINEerr(ZENCOD_F_ZENCOD_BN_MOD_EXP, ZENCOD_R_NOT_LOADED);
-        return 0;
-    }
-
-    if (!bn_wexpand(r, m-&gt;top + 1)) {
-        ENGINEerr(ZENCOD_F_ZENCOD_BN_MOD_EXP, ZENCOD_R_BN_EXPAND_FAIL);
-        return 0;
-    }
-
-    memset(r-&gt;d, 0, BN_num_bytes(m));
-
-    ptr_zencod_init_number(&amp;y, (r-&gt;dmax - 1) * sizeof(BN_ULONG) * 8,
-                           (unsigned char *)r-&gt;d);
-    BIGNUM2ZEN(&amp;x, a);
-    BIGNUM2ZEN(&amp;e, p);
-    BIGNUM2ZEN(&amp;n, m);
-
-    /* Must invert x and e parameter due to BN mod exp prototype ... */
-    ret = ptr_zencod_math_mod_exp(&amp;y, &amp;e, &amp;x, &amp;n);
-
-    if (ret) {
-        PERROR(&quot;zenbridge_math_mod_exp&quot;);
-        ENGINEerr(ZENCOD_F_ZENCOD_BN_MOD_EXP, ZENCOD_R_REQUEST_FAILED);
-        return 0;
-    }
-
-    r-&gt;top = (BN_num_bits(m) + BN_BITS2 - 1) / BN_BITS2;
-
-    return 1;
-}
-
-/*
- * RSA stuff Functions
- */
-#  ifndef OPENSSL_NO_RSA
-static int RSA_zencod_rsa_mod_exp(BIGNUM *r0, const BIGNUM *i, RSA *rsa)
-{
-
-    CHEESE();
-
-    if (!zencod_dso) {
-        ENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT, ZENCOD_R_NOT_LOADED);
-        return 0;
-    }
-
-    if (!rsa-&gt;p || !rsa-&gt;q || !rsa-&gt;dmp1 || !rsa-&gt;dmq1 || !rsa-&gt;iqmp) {
-        ENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT,
-                  ZENCOD_R_BAD_KEY_COMPONENTS);
-        return 0;
-    }
-
-    /* Do in software if argument is too large for hardware */
-    if (RSA_size(rsa) * 8 &gt; ZENBRIDGE_MAX_KEYSIZE_RSA_CRT) {
-        const RSA_METHOD *meth;
-
-        meth = RSA_PKCS1_OpenSSL();
-        return meth-&gt;rsa_mod_exp(r0, i, rsa);
-    } else {
-        zen_nb_t y, x, p, q, dmp1, dmq1, iqmp;
-
-        if (!bn_expand(r0, RSA_size(rsa) * 8)) {
-            ENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT,
-                      ZENCOD_R_BN_EXPAND_FAIL);
-            return 0;
-        }
-        r0-&gt;top = (RSA_size(rsa) * 8 + BN_BITS2 - 1) / BN_BITS2;
-
-        BIGNUM2ZEN(&amp;x, i);
-        BIGNUM2ZEN(&amp;y, r0);
-        BIGNUM2ZEN(&amp;p, rsa-&gt;p);
-        BIGNUM2ZEN(&amp;q, rsa-&gt;q);
-        BIGNUM2ZEN(&amp;dmp1, rsa-&gt;dmp1);
-        BIGNUM2ZEN(&amp;dmq1, rsa-&gt;dmq1);
-        BIGNUM2ZEN(&amp;iqmp, rsa-&gt;iqmp);
-
-        if (ptr_zencod_rsa_mod_exp_crt(&amp;y, &amp;x, &amp;p, &amp;q, &amp;dmp1, &amp;dmq1, &amp;iqmp) &lt;
-            0) {
-            PERROR(&quot;zenbridge_rsa_mod_exp_crt&quot;);
-            ENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT,
-                      ZENCOD_R_REQUEST_FAILED);
-            return 0;
-        }
-
-        return 1;
-    }
-}
-
-/*
- * This function is aliased to RSA_mod_exp (with the mont stuff dropped).
- */
-static int RSA_zencod_bn_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-                                 const BIGNUM *m, BN_CTX *ctx,
-                                 BN_MONT_CTX *m_ctx)
-{
-
-    CHEESE();
-
-    if (!zencod_dso) {
-        ENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP, ZENCOD_R_NOT_LOADED);
-        return 0;
-    }
-
-    /* Do in software if argument is too large for hardware */
-    if (BN_num_bits(m) &gt; ZENBRIDGE_MAX_KEYSIZE_RSA) {
-        const RSA_METHOD *meth;
-
-        meth = RSA_PKCS1_OpenSSL();
-        return meth-&gt;bn_mod_exp(r, a, p, m, ctx, m_ctx);
-    } else {
-        zen_nb_t y, x, e, n;
-
-        if (!bn_expand(r, BN_num_bits(m))) {
-            ENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP, ZENCOD_R_BN_EXPAND_FAIL);
-            return 0;
-        }
-        r-&gt;top = (BN_num_bits(m) + BN_BITS2 - 1) / BN_BITS2;
-
-        BIGNUM2ZEN(&amp;x, a);
-        BIGNUM2ZEN(&amp;y, r);
-        BIGNUM2ZEN(&amp;e, p);
-        BIGNUM2ZEN(&amp;n, m);
-
-        if (ptr_zencod_rsa_mod_exp(&amp;y, &amp;x, &amp;n, &amp;e) &lt; 0) {
-            PERROR(&quot;zenbridge_rsa_mod_exp&quot;);
-            ENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP, ZENCOD_R_REQUEST_FAILED);
-            return 0;
-        }
-
-        return 1;
-    }
-}
-#  endif                        /* !OPENSSL_NO_RSA */
-
-#  ifndef OPENSSL_NO_DSA
-/*
- * DSA stuff Functions
- */
-static DSA_SIG *DSA_zencod_do_sign(const unsigned char *dgst, int dlen,
-                                   DSA *dsa)
-{
-    zen_nb_t p, q, g, x, y, r, s, data;
-    DSA_SIG *sig;
-    BIGNUM *bn_r = NULL;
-    BIGNUM *bn_s = NULL;
-    char msg[20];
-
-    CHEESE();
-
-    if (!zencod_dso) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_NOT_LOADED);
-        goto FAILED;
-    }
-
-    if (dlen &gt; 160) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);
-        goto FAILED;
-    }
-
-    /* Do in software if argument is too large for hardware */
-    if (BN_num_bits(dsa-&gt;p) &gt; ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN ||
-        BN_num_bits(dsa-&gt;g) &gt; ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN) {
-        const DSA_METHOD *meth;
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BAD_KEY_COMPONENTS);
-        meth = DSA_OpenSSL();
-        return meth-&gt;dsa_do_sign(dgst, dlen, dsa);
-    }
-
-    if ((bn_s = BN_new()) == NULL || (bn_r = BN_new()) == NULL) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BAD_KEY_COMPONENTS);
-        goto FAILED;
-    }
-
-    if (!bn_expand(bn_r, 160) || !bn_expand(bn_s, 160)) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BN_EXPAND_FAIL);
-        goto FAILED;
-    }
-
-    bn_r-&gt;top = bn_s-&gt;top = (160 + BN_BITS2 - 1) / BN_BITS2;
-    BIGNUM2ZEN(&amp;p, dsa-&gt;p);
-    BIGNUM2ZEN(&amp;q, dsa-&gt;q);
-    BIGNUM2ZEN(&amp;g, dsa-&gt;g);
-    BIGNUM2ZEN(&amp;x, dsa-&gt;priv_key);
-    BIGNUM2ZEN(&amp;y, dsa-&gt;pub_key);
-    BIGNUM2ZEN(&amp;r, bn_r);
-    BIGNUM2ZEN(&amp;s, bn_s);
-    q.len = x.len = 160;
-
-    ypcmem(msg, dgst, 20);
-    ptr_zencod_init_number(&amp;data, 160, msg);
-
-    if (ptr_zencod_dsa_do_sign(0, &amp;data, &amp;y, &amp;p, &amp;q, &amp;g, &amp;x, &amp;r, &amp;s) &lt; 0) {
-        PERROR(&quot;zenbridge_dsa_do_sign&quot;);
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);
-        goto FAILED;
-    }
-
-    if ((sig = DSA_SIG_new()) == NULL) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);
-        goto FAILED;
-    }
-    sig-&gt;r = bn_r;
-    sig-&gt;s = bn_s;
-    return sig;
-
- FAILED:
-    BN_free(bn_r);
-    BN_free(bn_s);
-    return NULL;
-}
-
-static int DSA_zencod_do_verify(const unsigned char *dgst, int dlen,
-                                DSA_SIG *sig, DSA *dsa)
-{
-    zen_nb_t data, p, q, g, y, r, s, v;
-    char msg[20];
-    char v_data[20];
-    int ret;
-
-    CHEESE();
-
-    if (!zencod_dso) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_VERIFY, ZENCOD_R_NOT_LOADED);
-        return 0;
-    }
-
-    if (dlen &gt; 160) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);
-        return 0;
-    }
-
-    /* Do in software if argument is too large for hardware */
-    if (BN_num_bits(dsa-&gt;p) &gt; ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN ||
-        BN_num_bits(dsa-&gt;g) &gt; ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN) {
-        const DSA_METHOD *meth;
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BAD_KEY_COMPONENTS);
-        meth = DSA_OpenSSL();
-        return meth-&gt;dsa_do_verify(dgst, dlen, sig, dsa);
-    }
-
-    BIGNUM2ZEN(&amp;p, dsa-&gt;p);
-    BIGNUM2ZEN(&amp;q, dsa-&gt;q);
-    BIGNUM2ZEN(&amp;g, dsa-&gt;g);
-    BIGNUM2ZEN(&amp;y, dsa-&gt;pub_key);
-    BIGNUM2ZEN(&amp;r, sig-&gt;r);
-    BIGNUM2ZEN(&amp;s, sig-&gt;s);
-    ptr_zencod_init_number(&amp;v, 160, v_data);
-    ypcmem(msg, dgst, 20);
-    ptr_zencod_init_number(&amp;data, 160, msg);
-
-    if ((ret =
-         ptr_zencod_dsa_do_verify(0, &amp;data, &amp;p, &amp;q, &amp;g, &amp;y, &amp;r, &amp;s,
-                                  &amp;v)) &lt; 0) {
-        PERROR(&quot;zenbridge_dsa_do_verify&quot;);
-        ENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_VERIFY, ZENCOD_R_REQUEST_FAILED);
-        return 0;
-    }
-
-    return ((ret == 0) ? 1 : ret);
-}
-
-static int DSA_zencod_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a,
-                                 const BIGNUM *p, const BIGNUM *m,
-                                 BN_CTX *ctx, BN_MONT_CTX *m_ctx)
-{
-    CHEESE();
-
-    return zencod_bn_mod_exp(r, a, p, m, ctx);
-}
-#  endif                        /* !OPENSSL_NO_DSA */
-
-#  ifndef OPENSSl_NO_DH
-/*
- * DH stuff Functions
- */
-static int DH_zencod_generate_key(DH *dh)
-{
-    BIGNUM *bn_prv = NULL;
-    BIGNUM *bn_pub = NULL;
-    zen_nb_t y, x, g, p;
-    int generate_x;
-
-    CHEESE();
-
-    if (!zencod_dso) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_NOT_LOADED);
-        return 0;
-    }
-
-    /* Private key */
-    if (dh-&gt;priv_key) {
-        bn_prv = dh-&gt;priv_key;
-        generate_x = 0;
-    } else {
-        if ((bn_prv = BN_new()) == NULL) {
-            ENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_BN_EXPAND_FAIL);
-            goto FAILED;
-        }
-        generate_x = 1;
-    }
-
-    /* Public key */
-    if (dh-&gt;pub_key)
-        bn_pub = dh-&gt;pub_key;
-    else if ((bn_pub = BN_new()) == NULL) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_BN_EXPAND_FAIL);
-        goto FAILED;
-    }
-
-    /* Expand */
-    if (!bn_wexpand(bn_prv, dh-&gt;p-&gt;dmax) || !bn_wexpand(bn_pub, dh-&gt;p-&gt;dmax)) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_BN_EXPAND_FAIL);
-        goto FAILED;
-    }
-    bn_prv-&gt;top = dh-&gt;p-&gt;top;
-    bn_pub-&gt;top = dh-&gt;p-&gt;top;
-
-    /* Convert all keys */
-    BIGNUM2ZEN(&amp;p, dh-&gt;p);
-    BIGNUM2ZEN(&amp;g, dh-&gt;g);
-    BIGNUM2ZEN(&amp;y, bn_pub);
-    BIGNUM2ZEN(&amp;x, bn_prv);
-    x.len = DH_size(dh) * 8;
-
-    /* Adjust the lengths of P and G */
-    p.len = ptr_zencod_bytes2bits(p.data, ZEN_BYTES(p.len));
-    g.len = ptr_zencod_bytes2bits(g.data, ZEN_BYTES(g.len));
-
-    /* Send the request to the driver */
-    if (ptr_zencod_dh_generate_key(&amp;y, &amp;x, &amp;g, &amp;p, generate_x) &lt; 0) {
-        perror(&quot;zenbridge_dh_generate_key&quot;);
-        ENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_REQUEST_FAILED);
-        goto FAILED;
-    }
-
-    dh-&gt;priv_key = bn_prv;
-    dh-&gt;pub_key = bn_pub;
-
-    return 1;
-
- FAILED:
-    if (!dh-&gt;priv_key)
-        BN_free(bn_prv);
-    if (!dh-&gt;pub_key)
-        BN_free(bn_pub);
-
-    return 0;
-}
-
-static int DH_zencod_compute_key(unsigned char *key, const BIGNUM *pub_key,
-                                 DH *dh)
-{
-    zen_nb_t y, x, p, k;
-
-    CHEESE();
-
-    if (!zencod_dso) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DH_COMPUTE, ZENCOD_R_NOT_LOADED);
-        return 0;
-    }
-
-    if (!dh-&gt;priv_key) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DH_COMPUTE, ZENCOD_R_BAD_KEY_COMPONENTS);
-        return 0;
-    }
-
-    /* Convert all keys */
-    BIGNUM2ZEN(&amp;y, pub_key);
-    BIGNUM2ZEN(&amp;x, dh-&gt;priv_key);
-    BIGNUM2ZEN(&amp;p, dh-&gt;p);
-    ptr_zencod_init_number(&amp;k, p.len, key);
-
-    /* Adjust the lengths */
-    p.len = ptr_zencod_bytes2bits(p.data, ZEN_BYTES(p.len));
-    y.len = ptr_zencod_bytes2bits(y.data, ZEN_BYTES(y.len));
-    x.len = ptr_zencod_bytes2bits(x.data, ZEN_BYTES(x.len));
-
-    /* Call the hardware */
-    if (ptr_zencod_dh_compute_key(&amp;k, &amp;y, &amp;x, &amp;p) &lt; 0) {
-        ENGINEerr(ZENCOD_F_ZENCOD_DH_COMPUTE, ZENCOD_R_REQUEST_FAILED);
-        return 0;
-    }
-
-    /* The key must be written MSB -&gt; LSB */
-    k.len = ptr_zencod_bytes2bits(k.data, ZEN_BYTES(k.len));
-    esrever(key, ZEN_BYTES(k.len));
-
-    return ZEN_BYTES(k.len);
-}
-
-static int DH_zencod_bn_mod_exp(const DH *dh, BIGNUM *r, const BIGNUM *a,
-                                const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,
-                                BN_MONT_CTX *m_ctx)
-{
-    CHEESE();
-
-    return zencod_bn_mod_exp(r, a, p, m, ctx);
-}
-#  endif                        /* !OPENSSL_NO_DH */
-
-/*
- * RAND stuff Functions
- */
-static void RAND_zencod_seed(const void *buf, int num)
-{
-    /*
-     * Nothing to do cause our crypto accelerator provide a true random
-     * generator
-     */
-}
-
-static int RAND_zencod_rand_bytes(unsigned char *buf, int num)
-{
-    zen_nb_t r;
-
-    CHEESE();
-
-    if (!zencod_dso) {
-        ENGINEerr(ZENCOD_F_ZENCOD_RAND, ZENCOD_R_NOT_LOADED);
-        return 0;
-    }
-
-    ptr_zencod_init_number(&amp;r, num * 8, buf);
-
-    if (ptr_zencod_rand_bytes(&amp;r, ZENBRIDGE_RNG_DIRECT) &lt; 0) {
-        PERROR(&quot;zenbridge_rand_bytes&quot;);
-        ENGINEerr(ZENCOD_F_ZENCOD_RAND, ZENCOD_R_REQUEST_FAILED);
-        return 0;
-    }
-
-    return 1;
-}
-
-static int RAND_zencod_rand_status(void)
-{
-    CHEESE();
-
-    return 1;
-}
-
-/*
- * This stuff is needed if this ENGINE is being compiled into a
- * self-contained shared-library.
- */
-#  ifdef ENGINE_DYNAMIC_SUPPORT
-static int bind_fn(ENGINE *e, const char *id)
-{
-
-    if (id &amp;&amp; (strcmp(id, engine_zencod_id) != 0)) {
-        return 0;
-    }
-    if (!bind_helper(e)) {
-        return 0;
-    }
-
-    return 1;
-}
-
-IMPLEMENT_DYNAMIC_CHECK_FN()
-    IMPLEMENT_DYNAMIC_BIND_FN(bind_fn)
-#  endif                        /* ENGINE_DYNAMIC_SUPPORT */
-    /*
-     * Adding &quot;Digest&quot; and &quot;Cipher&quot; tools ...
-     * This is in development ... ;-)
-     * In orfer to code this, i refer to hw_openbsd_dev_crypto and openssl engine made by Geoff Thorpe (if i'm rigth),
-     * and evp, sha md5 definitions etc ...
-     */
-/* First add some include ... */
-#  include &lt;openssl/evp.h&gt;
-#  include &lt;openssl/sha.h&gt;
-#  include &lt;openssl/md5.h&gt;
-#  include &lt;openssl/rc4.h&gt;
-#  include &lt;openssl/des.h&gt;
-/* Some variables declaration ... */
-    /*
-     * DONS: Disable symetric computation except DES and 3DES, but let part
-     * of the code
-     */
-/* static int engine_digest_nids [ ] = { NID_sha1, NID_md5 } ; */
-static int engine_digest_nids[] = { };
-
-static int engine_digest_nids_num = 0;
-/*
- * static int engine_cipher_nids [ ] = { NID_rc4, NID_rc4_40, NID_des_cbc,
- * NID_des_ede3_cbc } ;
- */
-static int engine_cipher_nids[] = { NID_des_cbc, NID_des_ede3_cbc };
-
-static int engine_cipher_nids_num = 2;
-
-/* Function prototype ... */
-/*  SHA stuff */
-static int engine_sha1_init(EVP_MD_CTX *ctx);
-static int engine_sha1_update(EVP_MD_CTX *ctx, const void *data,
-                              unsigned long count);
-static int engine_sha1_final(EVP_MD_CTX *ctx, unsigned char *md);
-
-/*  MD5 stuff */
-static int engine_md5_init(EVP_MD_CTX *ctx);
-static int engine_md5_update(EVP_MD_CTX *ctx, const void *data,
-                             unsigned long count);
-static int engine_md5_final(EVP_MD_CTX *ctx, unsigned char *md);
-
-static int engine_md_cleanup(EVP_MD_CTX *ctx);
-static int engine_md_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from);
-
-/* RC4 Stuff */
-static int engine_rc4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
-                               const unsigned char *iv, int enc);
-static int engine_rc4_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                             const unsigned char *in, unsigned int inl);
-
-/* DES Stuff */
-static int engine_des_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
-                               const unsigned char *iv, int enc);
-static int engine_des_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                                 const unsigned char *in, unsigned int inl);
-
-/*  3DES Stuff */
-static int engine_des_ede3_init_key(EVP_CIPHER_CTX *ctx,
-                                    const unsigned char *key,
-                                    const unsigned char *iv, int enc);
-static int engine_des_ede3_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                                      const unsigned char *in,
-                                      unsigned int inl);
-
-static int engine_cipher_cleanup(EVP_CIPHER_CTX *ctx); /* cleanup ctx */
-
-/* The one for SHA ... */
-static const EVP_MD engine_sha1_md = {
-    NID_sha1,
-    NID_sha1WithRSAEncryption,
-    SHA_DIGEST_LENGTH,
-    EVP_MD_FLAG_ONESHOT,
-    /*
-     * 0,
-     *//*
-     * EVP_MD_FLAG_ONESHOT = x0001 digest can only handle a single block *
-     * XXX: set according to device info ...
-     */
-    engine_sha1_init,
-    engine_sha1_update,
-    engine_sha1_final,
-    engine_md_copy,             /* dev_crypto_sha_copy */
-    engine_md_cleanup,          /* dev_crypto_sha_cleanup */
-    EVP_PKEY_RSA_method,
-    SHA_CBLOCK,
-    /* sizeof ( EVP_MD * ) + sizeof ( SHA_CTX ) */
-    sizeof(ZEN_MD_DATA)
-        /*
-         * sizeof ( MD_CTX_DATA ) The message digest data structure ...
-         */
-};
-
-/* The one for MD5 ... */
-static const EVP_MD engine_md5_md = {
-    NID_md5,
-    NID_md5WithRSAEncryption,
-    MD5_DIGEST_LENGTH,
-    EVP_MD_FLAG_ONESHOT,
-    /*
-     * 0,
-     *//*
-     * EVP_MD_FLAG_ONESHOT = x0001 digest can only handle a single block *
-     * XXX: set according to device info ...
-     */
-    engine_md5_init,
-    engine_md5_update,
-    engine_md5_final,
-    engine_md_copy,             /* dev_crypto_md5_copy */
-    engine_md_cleanup,          /* dev_crypto_md5_cleanup */
-    EVP_PKEY_RSA_method,
-    MD5_CBLOCK,
-    /* sizeof ( EVP_MD * ) + sizeof ( MD5_CTX ) */
-    sizeof(ZEN_MD_DATA)
-        /*
-         * sizeof ( MD_CTX_DATA ) The message digest data structure ...
-         */
-};
-
-/* The one for RC4 ... */
-#  define EVP_RC4_KEY_SIZE                        16
-
-/* Try something static ... */
-typedef struct {
-    unsigned int len;
-    unsigned int first;
-    unsigned char rc4_state[260];
-} NEW_ZEN_RC4_KEY;
-
-#  define rc4_data(ctx)                           ( (EVP_RC4_KEY *) ( ctx )-&gt;cipher_data )
-
-static const EVP_CIPHER engine_rc4 = {
-    NID_rc4,
-    1,
-    16,                         /* EVP_RC4_KEY_SIZE should be 128 bits */
-    0,                          /* FIXME: key should be up to 256 bytes */
-    EVP_CIPH_VARIABLE_LENGTH,
-    engine_rc4_init_key,
-    engine_rc4_cipher,
-    engine_cipher_cleanup,
-    sizeof(NEW_ZEN_RC4_KEY),
-    NULL,
-    NULL,
-    NULL
-};
-
-/* The one for RC4_40 ... */
-static const EVP_CIPHER engine_rc4_40 = {
-    NID_rc4_40,
-    1,
-    5,                          /* 40 bits */
-    0,
-    EVP_CIPH_VARIABLE_LENGTH,
-    engine_rc4_init_key,
-    engine_rc4_cipher,
-    engine_cipher_cleanup,
-    sizeof(NEW_ZEN_RC4_KEY),
-    NULL,
-    NULL,
-    NULL
-};
-
-/* The one for DES ... */
-
-/* Try something static ... */
-typedef struct {
-    unsigned char des_key[24];
-    unsigned char des_iv[8];
-} ZEN_DES_KEY;
-
-static const EVP_CIPHER engine_des_cbc = {
-    NID_des_cbc,
-    8, 8, 8,
-    0 | EVP_CIPH_CBC_MODE,
-    engine_des_init_key,
-    engine_des_cbc_cipher,
-    engine_cipher_cleanup,
-    sizeof(ZEN_DES_KEY),
-    EVP_CIPHER_set_asn1_iv,
-    EVP_CIPHER_get_asn1_iv,
-    NULL,
-    NULL
-};
-
-/* The one for 3DES ... */
-
-/* Try something static ... */
-typedef struct {
-    unsigned char des3_key[24];
-    unsigned char des3_iv[8];
-} ZEN_3DES_KEY;
-
-#  define des_data(ctx)                            ( (DES_EDE_KEY *) ( ctx )-&gt;cipher_data )
-
-static const EVP_CIPHER engine_des_ede3_cbc = {
-    NID_des_ede3_cbc,
-    8, 8, 8,
-    0 | EVP_CIPH_CBC_MODE,
-    engine_des_ede3_init_key,
-    engine_des_ede3_cbc_cipher,
-    engine_cipher_cleanup,
-    sizeof(ZEN_3DES_KEY),
-    EVP_CIPHER_set_asn1_iv,
-    EVP_CIPHER_get_asn1_iv,
-    NULL,
-    NULL
-};
-
-/* General function cloned on hw_openbsd_dev_crypto one ... */
-static int engine_digests(ENGINE *e, const EVP_MD **digest, const int **nids,
-                          int nid)
-{
-
-#  ifdef DEBUG_ZENCOD_MD
-    fprintf(stderr, &quot;\t=&gt;Function : static int engine_digests () called !\n&quot;);
-#  endif
-
-    if (!digest) {
-        /* We are returning a list of supported nids */
-        *nids = engine_digest_nids;
-        return engine_digest_nids_num;
-    }
-    /* We are being asked for a specific digest */
-    if (nid == NID_md5) {
-        *digest = &amp;engine_md5_md;
-    } else if (nid == NID_sha1) {
-        *digest = &amp;engine_sha1_md;
-    } else {
-        *digest = NULL;
-        return 0;
-    }
-    return 1;
-}
-
-/*
- * SHA stuff Functions
- */
-static int engine_sha1_init(EVP_MD_CTX *ctx)
-{
-
-    int to_return = 0;
-
-    /* Test with zenbridge library ... */
-    to_return = ptr_zencod_sha1_init((ZEN_MD_DATA *)ctx-&gt;md_data);
-    to_return = !to_return;
-
-    return to_return;
-}
-
-static int engine_sha1_update(EVP_MD_CTX *ctx, const void *data,
-                              unsigned long count)
-{
-
-    zen_nb_t input;
-    int to_return = 0;
-
-    /* Convert parameters ... */
-    input.len = count;
-    input.data = (unsigned char *)data;
-
-    /* Test with zenbridge library ... */
-    to_return =
-        ptr_zencod_sha1_update((ZEN_MD_DATA *)ctx-&gt;md_data,
-                               (const zen_nb_t *)&amp;input);
-    to_return = !to_return;
-
-    return to_return;
-}
-
-static int engine_sha1_final(EVP_MD_CTX *ctx, unsigned char *md)
-{
-
-    zen_nb_t output;
-    int to_return = 0;
-
-    /* Convert parameters ... */
-    output.len = SHA_DIGEST_LENGTH;
-    output.data = md;
-
-    /* Test with zenbridge library ... */
-    to_return =
-        ptr_zencod_sha1_do_final((ZEN_MD_DATA *)ctx-&gt;md_data,
-                                 (zen_nb_t *) &amp; output);
-    to_return = !to_return;
-
-    return to_return;
-}
-
-/*
- * MD5 stuff Functions
- */
-static int engine_md5_init(EVP_MD_CTX *ctx)
-{
-
-    int to_return = 0;
-
-    /* Test with zenbridge library ... */
-    to_return = ptr_zencod_md5_init((ZEN_MD_DATA *)ctx-&gt;md_data);
-    to_return = !to_return;
-
-    return to_return;
-}
-
-static int engine_md5_update(EVP_MD_CTX *ctx, const void *data,
-                             unsigned long count)
-{
-
-    zen_nb_t input;
-    int to_return = 0;
-
-    /* Convert parameters ... */
-    input.len = count;
-    input.data = (unsigned char *)data;
-
-    /* Test with zenbridge library ... */
-    to_return =
-        ptr_zencod_md5_update((ZEN_MD_DATA *)ctx-&gt;md_data,
-                              (const zen_nb_t *)&amp;input);
-    to_return = !to_return;
-
-    return to_return;
-}
-
-static int engine_md5_final(EVP_MD_CTX *ctx, unsigned char *md)
-{
-
-    zen_nb_t output;
-    int to_return = 0;
-
-    /* Convert parameters ... */
-    output.len = MD5_DIGEST_LENGTH;
-    output.data = md;
-
-    /* Test with zenbridge library ... */
-    to_return =
-        ptr_zencod_md5_do_final((ZEN_MD_DATA *)ctx-&gt;md_data,
-                                (zen_nb_t *) &amp; output);
-    to_return = !to_return;
-
-    return to_return;
-}
-
-static int engine_md_cleanup(EVP_MD_CTX *ctx)
-{
-
-    ZEN_MD_DATA *zen_md_data = (ZEN_MD_DATA *)ctx-&gt;md_data;
-
-    OPENSSL_free(zen_md_data-&gt;HashBuffer);
-    zen_md_data-&gt;HashBufferSize = 0;
-    ctx-&gt;md_data = NULL;
-    return 1;
-}
-
-static int engine_md_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from)
-{
-    const ZEN_MD_DATA *from_md = (ZEN_MD_DATA *)from-&gt;md_data;
-    ZEN_MD_DATA *to_md = (ZEN_MD_DATA *)to-&gt;md_data;
-
-    to_md-&gt;HashBuffer = OPENSSL_malloc(from_md-&gt;HashBufferSize);
-    if (to_md-&gt;HashBuffer == NULL)
-        return 0;
-    memcpy(to_md-&gt;HashBuffer, from_md-&gt;HashBuffer, from_md-&gt;HashBufferSize);
-
-    return 1;
-}
-
-/* General function cloned on hw_openbsd_dev_crypto one ... */
-static int engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
-                          const int **nids, int nid)
-{
-
-    if (!cipher) {
-        /* We are returning a list of supported nids */
-        *nids = engine_cipher_nids;
-        return engine_cipher_nids_num;
-    }
-    /* We are being asked for a specific cipher */
-    if (nid == NID_rc4) {
-        *cipher = &amp;engine_rc4;
-    } else if (nid == NID_rc4_40) {
-        *cipher = &amp;engine_rc4_40;
-    } else if (nid == NID_des_cbc) {
-        *cipher = &amp;engine_des_cbc;
-    } else if (nid == NID_des_ede3_cbc) {
-        *cipher = &amp;engine_des_ede3_cbc;
-    } else {
-        *cipher = NULL;
-        return 0;
-    }
-
-    return 1;
-}
-
-static int engine_rc4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
-                               const unsigned char *iv, int enc)
-{
-    int to_return = 0;
-    int i = 0;
-    int nb = 0;
-    NEW_ZEN_RC4_KEY *tmp_rc4_key = NULL;
-
-    tmp_rc4_key = (NEW_ZEN_RC4_KEY *) (ctx-&gt;cipher_data);
-    tmp_rc4_key-&gt;first = 0;
-    tmp_rc4_key-&gt;len = ctx-&gt;key_len;
-    tmp_rc4_key-&gt;rc4_state[0] = 0x00;
-    tmp_rc4_key-&gt;rc4_state[2] = 0x00;
-    nb = 256 / ctx-&gt;key_len;
-    for (i = 0; i &lt; nb; i++) {
-        memcpy(&amp;(tmp_rc4_key-&gt;rc4_state[4 + i * ctx-&gt;key_len]), key,
-               ctx-&gt;key_len);
-    }
-
-    to_return = 1;
-
-    return to_return;
-}
-
-static int engine_rc4_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                             const unsigned char *in, unsigned int in_len)
-{
-
-    zen_nb_t output, input;
-    zen_nb_t rc4key;
-    int to_return = 0;
-    NEW_ZEN_RC4_KEY *tmp_rc4_key = NULL;
-
-    /* Convert parameters ... */
-    input.len = in_len;
-    input.data = (unsigned char *)in;
-    output.len = in_len;
-    output.data = (unsigned char *)out;
-
-    tmp_rc4_key = ((NEW_ZEN_RC4_KEY *) (ctx-&gt;cipher_data));
-    rc4key.len = 260;
-    rc4key.data = &amp;(tmp_rc4_key-&gt;rc4_state[0]);
-
-    /* Test with zenbridge library ... */
-    to_return =
-        ptr_zencod_rc4_cipher(&amp;output, &amp;input, (const zen_nb_t *)&amp;rc4key,
-                              &amp;(tmp_rc4_key-&gt;rc4_state[0]),
-                              &amp;(tmp_rc4_key-&gt;rc4_state[3]),
-                              !tmp_rc4_key-&gt;first);
-    to_return = !to_return;
-
-    /* Update encryption state ... */
-    tmp_rc4_key-&gt;first = 1;
-    tmp_rc4_key = NULL;
-
-    return to_return;
-}
-
-static int engine_des_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
-                               const unsigned char *iv, int enc)
-{
-
-    ZEN_DES_KEY *tmp_des_key = NULL;
-    int to_return = 0;
-
-    tmp_des_key = (ZEN_DES_KEY *) (ctx-&gt;cipher_data);
-    memcpy(&amp;(tmp_des_key-&gt;des_key[0]), key, 8);
-    memcpy(&amp;(tmp_des_key-&gt;des_key[8]), key, 8);
-    memcpy(&amp;(tmp_des_key-&gt;des_key[16]), key, 8);
-    memcpy(&amp;(tmp_des_key-&gt;des_iv[0]), iv, 8);
-
-    to_return = 1;
-
-    return to_return;
-}
-
-static int engine_des_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                                 const unsigned char *in, unsigned int inl)
-{
-
-    zen_nb_t output, input;
-    zen_nb_t deskey_1, deskey_2, deskey_3, iv;
-    int to_return = 0;
-
-    /* Convert parameters ... */
-    input.len = inl;
-    input.data = (unsigned char *)in;
-    output.len = inl;
-    output.data = out;
-
-    /* Set key parameters ... */
-    deskey_1.len = 8;
-    deskey_2.len = 8;
-    deskey_3.len = 8;
-    deskey_1.data =
-        (unsigned char *)((ZEN_DES_KEY *) (ctx-&gt;cipher_data))-&gt;des_key;
-    deskey_2.data =
-        (unsigned char *)&amp;((ZEN_DES_KEY *) (ctx-&gt;cipher_data))-&gt;des_key[8];
-    deskey_3.data =
-        (unsigned char *)&amp;((ZEN_DES_KEY *) (ctx-&gt;cipher_data))-&gt;des_key[16];
-
-    /* Key correct iv ... */
-    memcpy(((ZEN_DES_KEY *) (ctx-&gt;cipher_data))-&gt;des_iv, ctx-&gt;iv, 8);
-    iv.len = 8;
-    iv.data = (unsigned char *)((ZEN_DES_KEY *) (ctx-&gt;cipher_data))-&gt;des_iv;
-
-    if (ctx-&gt;encrypt == 0) {
-        memcpy(ctx-&gt;iv, &amp;(input.data[input.len - 8]), 8);
-    }
-
-    /* Test with zenbridge library ... */
-    to_return = ptr_zencod_xdes_cipher(&amp;output, &amp;input,
-                                       (zen_nb_t *) &amp; deskey_1,
-                                       (zen_nb_t *) &amp; deskey_2,
-                                       (zen_nb_t *) &amp; deskey_3, &amp;iv,
-                                       ctx-&gt;encrypt);
-    to_return = !to_return;
-
-    /*
-     * But we need to set up the rigth iv ... Test ENCRYPT or DECRYPT mode to
-     * set iv ...
-     */
-    if (ctx-&gt;encrypt == 1) {
-        memcpy(ctx-&gt;iv, &amp;(output.data[output.len - 8]), 8);
-    }
-
-    return to_return;
-}
-
-static int engine_des_ede3_init_key(EVP_CIPHER_CTX *ctx,
-                                    const unsigned char *key,
-                                    const unsigned char *iv, int enc)
-{
-
-    ZEN_3DES_KEY *tmp_3des_key = NULL;
-    int to_return = 0;
-
-    tmp_3des_key = (ZEN_3DES_KEY *) (ctx-&gt;cipher_data);
-    memcpy(&amp;(tmp_3des_key-&gt;des3_key[0]), key, 24);
-    memcpy(&amp;(tmp_3des_key-&gt;des3_iv[0]), iv, 8);
-
-    to_return = 1;
-
-    return to_return;
-}
-
-static int engine_des_ede3_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
-                                      const unsigned char *in,
-                                      unsigned int in_len)
-{
-
-    zen_nb_t output, input;
-    zen_nb_t deskey_1, deskey_2, deskey_3, iv;
-    int to_return = 0;
-
-    /* Convert parameters ... */
-    input.len = in_len;
-    input.data = (unsigned char *)in;
-    output.len = in_len;
-    output.data = out;
-
-    /* Set key ... */
-    deskey_1.len = 8;
-    deskey_2.len = 8;
-    deskey_3.len = 8;
-    deskey_1.data =
-        (unsigned char *)((ZEN_3DES_KEY *) (ctx-&gt;cipher_data))-&gt;des3_key;
-    deskey_2.data =
-        (unsigned char *)&amp;((ZEN_3DES_KEY *) (ctx-&gt;cipher_data))-&gt;des3_key[8];
-    deskey_3.data =
-        (unsigned char *)&amp;((ZEN_3DES_KEY *) (ctx-&gt;cipher_data))-&gt;des3_key[16];
-
-    /* Key correct iv ... */
-    memcpy(((ZEN_3DES_KEY *) (ctx-&gt;cipher_data))-&gt;des3_iv, ctx-&gt;iv, 8);
-    iv.len = 8;
-    iv.data = (unsigned char *)((ZEN_3DES_KEY *) (ctx-&gt;cipher_data))-&gt;des3_iv;
-
-    if (ctx-&gt;encrypt == 0) {
-        memcpy(ctx-&gt;iv, &amp;(input.data[input.len - 8]), 8);
-    }
-
-    /* Test with zenbridge library ... */
-    to_return = ptr_zencod_xdes_cipher(&amp;output, &amp;input,
-                                       (zen_nb_t *) &amp; deskey_1,
-                                       (zen_nb_t *) &amp; deskey_2,
-                                       (zen_nb_t *) &amp; deskey_3, &amp;iv,
-                                       ctx-&gt;encrypt);
-    to_return = !to_return;
-
-    if (ctx-&gt;encrypt == 1) {
-        memcpy(ctx-&gt;iv, &amp;(output.data[output.len - 8]), 8);
-    }
-
-    return to_return;
-}
-
-static int engine_cipher_cleanup(EVP_CIPHER_CTX *ctx)
-{
-
-    /* Set the key pointer ... */
-    if (ctx-&gt;cipher-&gt;nid == NID_rc4 || ctx-&gt;cipher-&gt;nid == NID_rc4_40) {
-    } else if (ctx-&gt;cipher-&gt;nid == NID_des_cbc) {
-    } else if (ctx-&gt;cipher-&gt;nid == NID_des_ede3_cbc) {
-    }
-
-    return 1;
-}
-
-# endif                         /* !OPENSSL_NO_HW_ZENCOD */
-#endif                          /* !OPENSSL_NO_HW */
diff --git a/demos/engines/zencod/hw_zencod.ec b/demos/engines/zencod/hw_zencod.ec
deleted file mode 100644
index 1552c79..0000000
--- a/demos/engines/zencod/hw_zencod.ec
+++ /dev/null
@@ -1,8 +0,0 @@
-# configuration file for util/mkerr.pl
-#
-# use like this:
-#
-#	perl ../../../util/mkerr.pl -conf hw_zencod.ec \
-#		-nostatic -staticloader -write *.c
-
-L ZENCOD	hw_zencod_err.h			hw_zencod_err.c
diff --git a/demos/engines/zencod/hw_zencod.h b/demos/engines/zencod/hw_zencod.h
deleted file mode 100644
index 633a61a..0000000
--- a/demos/engines/zencod/hw_zencod.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/* ====================================================================
- * Written by Donnat Frederic (<A HREF="../../../mailman/listinfo/openssl-commits.html">frederic.donnat at zencod.com</A>) from ZENCOD
- * for &quot;zencod&quot; ENGINE integration in OpenSSL project.
- */
-
-#ifndef        _HW_ZENCOD_H_
-# define _HW_ZENCOD_H_
-
-# include &lt;stdio.h&gt;
-
-# ifdef  __cplusplus
-extern &quot;C&quot; {
-# endif                         /* __cplusplus */
-
-# define ZENBRIDGE_MAX_KEYSIZE_RSA       2048
-# define ZENBRIDGE_MAX_KEYSIZE_RSA_CRT   1024
-# define ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN  1024
-# define ZENBRIDGE_MAX_KEYSIZE_DSA_VRFY  1024
-
-/* Library version computation */
-# define ZENBRIDGE_VERSION_MAJOR(x)      (((x) &gt;&gt; 16) | 0xff)
-# define ZENBRIDGE_VERSION_MINOR(x)      (((x) &gt;&gt;  8) | 0xff)
-# define ZENBRIDGE_VERSION_PATCH(x)      (((x) &gt;&gt;  0) | 0xff)
-# define ZENBRIDGE_VERSION(x, y, z)              ((x) &lt;&lt; 16 | (y) &lt;&lt; 8 | (z))
-
-    /*
-     * Memory type
-     */
-    typedef struct zencod_number_s {
-        unsigned long len;
-        unsigned char *data;
-    } zen_nb_t;
-
-# define KEY     zen_nb_t
-
-    /*
-     * Misc
-     */
-    typedef int t_zencod_lib_version(void);
-    typedef int t_zencod_hw_version(void);
-    typedef int t_zencod_test(void);
-    typedef int t_zencod_dump_key(FILE *stream, char *msg, KEY * key);
-
-    /*
-     * Key management tools
-     */
-    typedef KEY *t_zencod_new_number(unsigned long len, unsigned char *data);
-    typedef int t_zencod_init_number(KEY * n, unsigned long len,
-                                     unsigned char *data);
-    typedef unsigned long t_zencod_bytes2bits(unsigned char *n,
-                                              unsigned long bytes);
-    typedef unsigned long t_zencod_bits2bytes(unsigned long bits);
-
-    /*
-     * RSA API
-     */
-/* Compute modular exponential : y = x**e | n */
-    typedef int t_zencod_rsa_mod_exp(KEY * y, KEY * x, KEY * n, KEY * e);
-    /*
-     * Compute modular exponential : y1 = (x | p)**edp | p, y2 = (x | p)**edp
-     * | p, y = y2 + (qinv * (y1 - y2) | p) * q
-     */
-    typedef int t_zencod_rsa_mod_exp_crt(KEY * y, KEY * x, KEY * p, KEY * q,
-                                         KEY * edp, KEY * edq, KEY * qinv);
-
-    /*
-     * DSA API
-     */
-    typedef int t_zencod_dsa_do_sign(unsigned int hash, KEY * data,
-                                     KEY * random, KEY * p, KEY * q, KEY * g,
-                                     KEY * x, KEY * r, KEY * s);
-    typedef int t_zencod_dsa_do_verify(unsigned int hash, KEY * data, KEY * p,
-                                       KEY * q, KEY * g, KEY * y, KEY * r,
-                                       KEY * s, KEY * v);
-
-    /*
-     * DH API
-     */
-    /* Key generation : compute public value y = g**x | n */
-    typedef int t_zencod_dh_generate_key(KEY * y, KEY * x, KEY * g, KEY * n,
-                                         int gen_x);
-    typedef int t_zencod_dh_compute_key(KEY * k, KEY * y, KEY * x, KEY * n);
-
-    /*
-     * RNG API
-     */
-# define ZENBRIDGE_RNG_DIRECT            0
-# define ZENBRIDGE_RNG_SHA1              1
-    typedef int t_zencod_rand_bytes(KEY * rand, unsigned int flags);
-
-    /*
-     * Math API
-     */
-    typedef int t_zencod_math_mod_exp(KEY * r, KEY * a, KEY * e, KEY * n);
-
-    /*
-     * Symetric API
-     */
-/* Define a data structure for digests operations */
-    typedef struct ZEN_data_st {
-        unsigned int HashBufferSize;
-        unsigned char *HashBuffer;
-    } ZEN_MD_DATA;
-
-    /*
-     * Functions for Digest (MD5, SHA1) stuff
-     */
-    /* output : output data buffer */
-    /* input : input data buffer */
-    /* algo : hash algorithm, MD5 or SHA1 */
-    /*-
-     * typedef int t_zencod_hash ( KEY *output, const KEY *input, int algo ) ;
-     * typedef int t_zencod_sha_hash ( KEY *output, const KEY *input, int algo ) ;
-     */
-    /* For now separate this stuff that mad it easier to test */
-    typedef int t_zencod_md5_init(ZEN_MD_DATA *data);
-    typedef int t_zencod_md5_update(ZEN_MD_DATA *data, const KEY * input);
-    typedef int t_zencod_md5_do_final(ZEN_MD_DATA *data, KEY * output);
-
-    typedef int t_zencod_sha1_init(ZEN_MD_DATA *data);
-    typedef int t_zencod_sha1_update(ZEN_MD_DATA *data, const KEY * input);
-    typedef int t_zencod_sha1_do_final(ZEN_MD_DATA *data, KEY * output);
-
-    /*
-     * Functions for Cipher (RC4, DES, 3DES) stuff
-     */
-/* output : output data buffer */
-/* input : input data buffer */
-/* key : rc4 key data */
-/* index_1 : value of index x from RC4 key structure */
-/* index_2 : value of index y from RC4 key structure */
-    /*
-     * Be careful : RC4 key should be expanded before calling this method
-     * (Should we provide an expand function ??)
-     */
-    typedef int t_zencod_rc4_cipher(KEY * output, const KEY * input,
-                                    const KEY * key, unsigned char *index_1,
-                                    unsigned char *index_2, int mode);
-
-/* output : output data buffer */
-/* input : input data buffer */
-/* key_1 : des first key data */
-/* key_2 : des second key data */
-/* key_3 : des third key data */
-/* iv : initial vector */
-/* mode : xdes mode (encrypt or decrypt) */
-/* Be careful : In DES mode key_1 = key_2 = key_3 (as far as i can see !!) */
-    typedef int t_zencod_xdes_cipher(KEY * output, const KEY * input,
-                                     const KEY * key_1, const KEY * key_2,
-                                     const KEY * key_3, const KEY * iv,
-                                     int mode);
-
-# undef KEY
-
-# ifdef  __cplusplus
-}
-# endif                         /* __cplusplus */
-#endif                          /* !_HW_ZENCOD_H_ */
diff --git a/demos/engines/zencod/hw_zencod_err.c b/demos/engines/zencod/hw_zencod_err.c
deleted file mode 100644
index db33cc8..0000000
--- a/demos/engines/zencod/hw_zencod_err.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/* ====================================================================
- * Copyright (c) 1999-2002 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at OpenSSL.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-/*
- * NOTE: this file was auto generated by the mkerr.pl script: any changes
- * made to it will be overwritten when the script next updates this file,
- * only reason strings will be preserved.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &quot;hw_zencod_err.h&quot;
-
-/* BEGIN ERROR CODES */
-#ifndef OPENSSL_NO_ERR
-static ERR_STRING_DATA ZENCOD_str_functs[] = {
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_BN_MOD_EXP, 0), &quot;ZENCOD_BN_MOD_EXP&quot;},
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_CTRL, 0), &quot;ZENCOD_CTRL&quot;},
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_DH_COMPUTE, 0), &quot;ZENCOD_DH_COMPUTE&quot;},
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_DH_GENERATE, 0), &quot;ZENCOD_DH_GENERATE&quot;},
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_DSA_DO_SIGN, 0), &quot;ZENCOD_DSA_DO_SIGN&quot;},
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_DSA_DO_VERIFY, 0), &quot;ZENCOD_DSA_DO_VERIFY&quot;},
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_FINISH, 0), &quot;ZENCOD_FINISH&quot;},
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_INIT, 0), &quot;ZENCOD_INIT&quot;},
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_RAND, 0), &quot;ZENCOD_RAND&quot;},
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_RSA_MOD_EXP, 0), &quot;ZENCOD_RSA_MOD_EXP&quot;},
-    {ERR_PACK(0, ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT, 0),
-     &quot;ZENCOD_RSA_MOD_EXP_CRT&quot;},
-    {0, NULL}
-};
-
-static ERR_STRING_DATA ZENCOD_str_reasons[] = {
-    {ZENCOD_R_ALREADY_LOADED, &quot;already loaded&quot;},
-    {ZENCOD_R_BAD_KEY_COMPONENTS, &quot;bad key components&quot;},
-    {ZENCOD_R_BN_EXPAND_FAIL, &quot;bn expand fail&quot;},
-    {ZENCOD_R_CTRL_COMMAND_NOT_IMPLEMENTED, &quot;ctrl command not implemented&quot;},
-    {ZENCOD_R_DSO_FAILURE, &quot;dso failure&quot;},
-    {ZENCOD_R_NOT_LOADED, &quot;not loaded&quot;},
-    {ZENCOD_R_REQUEST_FAILED, &quot;request failed&quot;},
-    {ZENCOD_R_UNIT_FAILURE, &quot;unit failure&quot;},
-    {0, NULL}
-};
-
-#endif
-
-#ifdef ZENCOD_LIB_NAME
-static ERR_STRING_DATA ZENCOD_lib_name[] = {
-    {0, ZENCOD_LIB_NAME},
-    {0, NULL}
-};
-#endif
-
-static int ZENCOD_lib_error_code = 0;
-static int ZENCOD_error_init = 1;
-
-static void ERR_load_ZENCOD_strings(void)
-{
-    if (ZENCOD_lib_error_code == 0)
-        ZENCOD_lib_error_code = ERR_get_next_error_library();
-
-    if (ZENCOD_error_init) {
-        ZENCOD_error_init = 0;
-#ifndef OPENSSL_NO_ERR
-        ERR_load_strings(ZENCOD_lib_error_code, ZENCOD_str_functs);
-        ERR_load_strings(ZENCOD_lib_error_code, ZENCOD_str_reasons);
-#endif
-
-#ifdef ZENCOD_LIB_NAME
-        ZENCOD_lib_name-&gt;error = ERR_PACK(ZENCOD_lib_error_code, 0, 0);
-        ERR_load_strings(0, ZENCOD_lib_name);
-#endif
-    }
-}
-
-static void ERR_unload_ZENCOD_strings(void)
-{
-    if (ZENCOD_error_init == 0) {
-#ifndef OPENSSL_NO_ERR
-        ERR_unload_strings(ZENCOD_lib_error_code, ZENCOD_str_functs);
-        ERR_unload_strings(ZENCOD_lib_error_code, ZENCOD_str_reasons);
-#endif
-
-#ifdef ZENCOD_LIB_NAME
-        ERR_unload_strings(0, ZENCOD_lib_name);
-#endif
-        ZENCOD_error_init = 1;
-    }
-}
-
-static void ERR_ZENCOD_error(int function, int reason, char *file, int line)
-{
-    if (ZENCOD_lib_error_code == 0)
-        ZENCOD_lib_error_code = ERR_get_next_error_library();
-    ERR_PUT_error(ZENCOD_lib_error_code, function, reason, file, line);
-}
diff --git a/demos/engines/zencod/hw_zencod_err.h b/demos/engines/zencod/hw_zencod_err.h
deleted file mode 100644
index 94d3293..0000000
--- a/demos/engines/zencod/hw_zencod_err.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/* ====================================================================
- * Copyright (c) 2001-2002 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-#ifndef HEADER_ZENCOD_ERR_H
-# define HEADER_ZENCOD_ERR_H
-
-#ifdef  __cplusplus
-extern &quot;C&quot; {
-#endif
-
-/* BEGIN ERROR CODES */
-/*
- * The following lines are auto generated by the script mkerr.pl. Any changes
- * made after this point may be overwritten when the script is next run.
- */
-static void ERR_load_ZENCOD_strings(void);
-static void ERR_unload_ZENCOD_strings(void);
-static void ERR_ZENCOD_error(int function, int reason, char *file, int line);
-# define ZENCODerr(f,r) ERR_ZENCOD_error((f),(r),OPENSSL_FILE,OPENSSL_LINE)
-
-/* Error codes for the ZENCOD functions. */
-
-/* Function codes. */
-# define ZENCOD_F_ZENCOD_BN_MOD_EXP                       100
-# define ZENCOD_F_ZENCOD_CTRL                             101
-# define ZENCOD_F_ZENCOD_DH_COMPUTE                       102
-# define ZENCOD_F_ZENCOD_DH_GENERATE                      103
-# define ZENCOD_F_ZENCOD_DSA_DO_SIGN                      104
-# define ZENCOD_F_ZENCOD_DSA_DO_VERIFY                    105
-# define ZENCOD_F_ZENCOD_FINISH                           106
-# define ZENCOD_F_ZENCOD_INIT                             107
-# define ZENCOD_F_ZENCOD_RAND                             108
-# define ZENCOD_F_ZENCOD_RSA_MOD_EXP                      109
-# define ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT                  110
-
-/* Reason codes. */
-# define ZENCOD_R_ALREADY_LOADED                          100
-# define ZENCOD_R_BAD_KEY_COMPONENTS                      101
-# define ZENCOD_R_BN_EXPAND_FAIL                          102
-# define ZENCOD_R_CTRL_COMMAND_NOT_IMPLEMENTED            103
-# define ZENCOD_R_DSO_FAILURE                             104
-# define ZENCOD_R_NOT_LOADED                              105
-# define ZENCOD_R_REQUEST_FAILED                          106
-# define ZENCOD_R_UNIT_FAILURE                            107
-
-#ifdef  __cplusplus
-}
-#endif
-#endif
diff --git a/demos/privkey.pem b/demos/privkey.pem
deleted file mode 100644
index ddae240..0000000
--- a/demos/privkey.pem
+++ /dev/null
@@ -1,9 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIIBPAIBAAJBAN+FmbxmHVOp/RxtpMGz0DvQEBz1sDktHp19hIoMSu0YZift5MAu
-4xAEJYvWVCshDiyOTWsUBXwZkrkt87FyctkCAwEAAQJAG/vxBGpQb6IPo1iC0RF/
-F430BnwoBPCGLbeCOXpSgx5X+19vuTSdEqMgeNB6+aNb+XY/7mvVfCjyD6WZ0oxs
-JQIhAPO+uL9cP40lFs62pdL3QSWsh3VNDByvOtr9LpeaxBm/AiEA6sKVfXsDQ5hd
-SHt9U61r2r8Lcxmzi9Kw6JNqjMmzqWcCIQCKoRy+aZ8Tjdas9yDVHh+FZ90bEBkl
-b1xQFNOdEj8aTQIhAOJWrO6INYNsWTPS6+hLYZtLamyUsQj0H+B8kNQge/mtAiEA
-nBfvUl243qbqN8gF7Az1u33uc9FsPVvQPiBzLxZ4ixw=
------END RSA PRIVATE KEY-----
diff --git a/demos/selfsign.c b/demos/selfsign.c
deleted file mode 100644
index f0adba5..0000000
--- a/demos/selfsign.c
+++ /dev/null
@@ -1,169 +0,0 @@
-/* NOCW */
-/* cc -o ssdemo -I../include selfsign.c ../libcrypto.a */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-
-#include &lt;openssl/pem.h&gt;
-#include &lt;openssl/conf.h&gt;
-#include &lt;openssl/x509v3.h&gt;
-
-int mkit(X509 **x509p, EVP_PKEY **pkeyp, int bits, int serial, int days);
-
-int main()
-{
-    BIO *bio_err;
-    X509 *x509 = NULL;
-    EVP_PKEY *pkey = NULL;
-
-    CRYPTO_set_mem_debug(1);
-    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
-
-    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
-
-    mkit(&amp;x509, &amp;pkey, 512, 0, 365);
-
-    RSA_print_fp(stdout, pkey-&gt;pkey.rsa, 0);
-    X509_print_fp(stdout, x509);
-
-    PEM_write_PrivateKey(stdout, pkey, NULL, NULL, 0, NULL, NULL);
-    PEM_write_X509(stdout, x509);
-
-    X509_free(x509);
-    EVP_PKEY_free(pkey);
-
-#ifdef CUSTOM_EXT
-    /* Only needed if we add objects or custom extensions */
-    X509V3_EXT_cleanup();
-    OBJ_cleanup();
-#endif
-
-    CRYPTO_mem_leaks(bio_err);
-    BIO_free(bio_err);
-    return (0);
-}
-
-static void callback(p, n, arg)
-int p;
-int n;
-void *arg;
-{
-    char c = 'B';
-
-    if (p == 0)
-        c = '.';
-    if (p == 1)
-        c = '+';
-    if (p == 2)
-        c = '*';
-    if (p == 3)
-        c = '\n';
-    fputc(c, stderr);
-}
-
-int mkit(x509p, pkeyp, bits, serial, days)
-X509 **x509p;
-EVP_PKEY **pkeyp;
-int bits;
-int serial;
-int days;
-{
-    X509 *x;
-    EVP_PKEY *pk;
-    RSA *rsa;
-    X509_NAME *name = NULL;
-    X509_NAME_ENTRY *ne = NULL;
-    X509_EXTENSION *ex = NULL;
-
-    if ((pkeyp == NULL) || (*pkeyp == NULL)) {
-        if ((pk = EVP_PKEY_new()) == NULL) {
-            abort();
-            return (0);
-        }
-    } else
-        pk = *pkeyp;
-
-    if ((x509p == NULL) || (*x509p == NULL)) {
-        if ((x = X509_new()) == NULL)
-            goto err;
-    } else
-        x = *x509p;
-
-    rsa = RSA_generate_key(bits, RSA_F4, callback, NULL);
-    if (!EVP_PKEY_assign_RSA(pk, rsa)) {
-        abort();
-        goto err;
-    }
-    rsa = NULL;
-
-    X509_set_version(x, 3);
-    ASN1_INTEGER_set(X509_get_serialNumber(x), serial);
-    X509_gmtime_adj(X509_get_notBefore(x), 0);
-    X509_gmtime_adj(X509_get_notAfter(x), (long)60 * 60 * 24 * days);
-    X509_set_pubkey(x, pk);
-
-    name = X509_get_subject_name(x);
-
-    /*
-     * This function creates and adds the entry, working out the correct
-     * string type and performing checks on its length. Normally we'd check
-     * the return value for errors...
-     */
-    X509_NAME_add_entry_by_txt(name, &quot;C&quot;, MBSTRING_ASC, &quot;UK&quot;, -1, -1, 0);
-    X509_NAME_add_entry_by_txt(name, &quot;CN&quot;,
-                               MBSTRING_ASC, &quot;OpenSSL Group&quot;, -1, -1, 0);
-
-    X509_set_issuer_name(x, name);
-
-    /*
-     * Add extension using V3 code: we can set the config file as NULL
-     * because we wont reference any other sections. We can also set the
-     * context to NULL because none of these extensions below will need to
-     * access it.
-     */
-
-    ex = X509V3_EXT_conf_nid(NULL, NULL, NID_netscape_cert_type, &quot;server&quot;);
-    X509_add_ext(x, ex, -1);
-    X509_EXTENSION_free(ex);
-
-    ex = X509V3_EXT_conf_nid(NULL, NULL, NID_netscape_comment,
-                             &quot;example comment extension&quot;);
-    X509_add_ext(x, ex, -1);
-    X509_EXTENSION_free(ex);
-
-    ex = X509V3_EXT_conf_nid(NULL, NULL, NID_netscape_ssl_server_name,
-                             &quot;www.openssl.org&quot;);
-
-    X509_add_ext(x, ex, -1);
-    X509_EXTENSION_free(ex);
-
-#ifdef ADD_CA_CONSTRAINT
-    /* might want something like this too.... */
-    ex = X509V3_EXT_conf_nid(NULL, NULL, NID_basic_constraints,
-                             &quot;critical,CA:TRUE&quot;);
-
-    X509_add_ext(x, ex, -1);
-    X509_EXTENSION_free(ex);
-#endif
-
-#ifdef ADD_A_CUSTOM_EXTENSION
-    /* Maybe even add our own extension based on existing */
-    {
-        int nid;
-        nid = OBJ_create(&quot;1.2.3.4&quot;, &quot;MyAlias&quot;, &quot;My Test Alias Extension&quot;);
-        X509V3_EXT_add_alias(nid, NID_netscape_comment);
-        ex = X509V3_EXT_conf_nid(NULL, NULL, nid, &quot;example comment alias&quot;);
-        X509_add_ext(x, ex, -1);
-        X509_EXTENSION_free(ex);
-    }
-#endif
-
-    if (!X509_sign(x, pk, EVP_md5()))
-        goto err;
-
-    *x509p = x;
-    *pkeyp = pk;
-    return (1);
- err:
-    return (0);
-}
diff --git a/demos/sign/Makefile.in b/demos/sign/Makefile.in
deleted file mode 100644
index f6afeb7..0000000
--- a/demos/sign/Makefile.in
+++ /dev/null
@@ -1,16 +0,0 @@
-CC=cc
-CFLAGS= -g -I../../include -Wall
-LIBS=  -L../.. -lcrypto
-EXAMPLES=sign
-
-all: $(EXAMPLES) 
-
-sign: sign.o
-	$(CC) -o sign sign.o $(LIBS)
-
-clean:	
-	rm -f $(EXAMPLES) *.o
-
-test: all
-	./sign
-# DO NOT DELETE THIS LINE -- make depend depends on it.
diff --git a/demos/sign/cert.pem b/demos/sign/cert.pem
deleted file mode 100644
index 9d7ac23..0000000
--- a/demos/sign/cert.pem
+++ /dev/null
@@ -1,14 +0,0 @@
------BEGIN CERTIFICATE-----
-MIICLDCCAdYCAQAwDQYJKoZIhvcNAQEEBQAwgaAxCzAJBgNVBAYTAlBUMRMwEQYD
-VQQIEwpRdWVlbnNsYW5kMQ8wDQYDVQQHEwZMaXNib2ExFzAVBgNVBAoTDk5ldXJv
-bmlvLCBMZGEuMRgwFgYDVQQLEw9EZXNlbnZvbHZpbWVudG8xGzAZBgNVBAMTEmJy
-dXR1cy5uZXVyb25pby5wdDEbMBkGCSqGSIb3DQEJARYMc2FtcG9AaWtpLmZpMB4X
-DTk2MDkwNTAzNDI0M1oXDTk2MTAwNTAzNDI0M1owgaAxCzAJBgNVBAYTAlBUMRMw
-EQYDVQQIEwpRdWVlbnNsYW5kMQ8wDQYDVQQHEwZMaXNib2ExFzAVBgNVBAoTDk5l
-dXJvbmlvLCBMZGEuMRgwFgYDVQQLEw9EZXNlbnZvbHZpbWVudG8xGzAZBgNVBAMT
-EmJydXR1cy5uZXVyb25pby5wdDEbMBkGCSqGSIb3DQEJARYMc2FtcG9AaWtpLmZp
-MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAL7+aty3S1iBA/+yxjxv4q1MUTd1kjNw
-L4lYKbpzzlmC5beaQXeQ2RmGMTXU+mDvuqItjVHOK3DvPK7lTcSGftUCAwEAATAN
-BgkqhkiG9w0BAQQFAANBAFqPEKFjk6T6CKTHvaQeEAsX0/8YHPHqH/9AnhSjrwuX
-9EBc0n6bVGhN7XaXd6sJ7dym9sbsWxb+pJdurnkxjx4=
------END CERTIFICATE-----
diff --git a/demos/sign/key.pem b/demos/sign/key.pem
deleted file mode 100644
index 239ad66..0000000
--- a/demos/sign/key.pem
+++ /dev/null
@@ -1,9 +0,0 @@
------BEGIN RSA PRIVATE KEY-----
-MIIBPAIBAAJBAL7+aty3S1iBA/+yxjxv4q1MUTd1kjNwL4lYKbpzzlmC5beaQXeQ
-2RmGMTXU+mDvuqItjVHOK3DvPK7lTcSGftUCAwEAAQJBALjkK+jc2+iihI98riEF
-oudmkNziSRTYjnwjx8mCoAjPWviB3c742eO3FG4/soi1jD9A5alihEOXfUzloenr
-8IECIQD3B5+0l+68BA/6d76iUNqAAV8djGTzvxnCxycnxPQydQIhAMXt4trUI3nc
-a+U8YL2HPFA3gmhBsSICbq2OptOCnM7hAiEA6Xi3JIQECob8YwkRj29DU3/4WYD7
-WLPgsQpwo1GuSpECICGsnWH5oaeD9t9jbFoSfhJvv0IZmxdcLpRcpslpeWBBAiEA
-6/5B8J0GHdJq89FHwEG/H2eVVUYu5y/aD6sgcm+0Avg=
------END RSA PRIVATE KEY-----
diff --git a/demos/sign/sig.txt b/demos/sign/sig.txt
deleted file mode 100644
index 5613c0e..0000000
--- a/demos/sign/sig.txt
+++ /dev/null
@@ -1,158 +0,0 @@
-From <A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-lists-owner at mincom.com</A> Mon Sep 30 02:37:40 1996
-Received: from cygnus.mincom.oz.au by orb.mincom.oz.au with SMTP id AA11782
-  (5.65c/IDA-1.4.4 for eay); Mon, 30 Sep 1996 11:46:21 +1000
-Received: (from <A HREF="../../../mailman/listinfo/openssl-commits.html">daemon at localhost</A>) by cygnus.mincom.oz.au (8.7.5/8.7.3) id LAA18980 for ssl-users-outgoing; Mon, 30 Sep 1996 11:44:56 +1000 (EST)
-Received: from minbne.mincom.oz.au (minbne.mincom.oz.au [192.55.196.247]) by cygnus.mincom.oz.au (8.7.5/8.7.3) with SMTP id LAA18962 for &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-users at listserv.mincom.oz.au</A>&gt;; Mon, 30 Sep 1996 11:44:51 +1000 (EST)
-Received: by minbne.mincom.oz.au id AA22230
-  (5.65c/IDA-1.4.4 for <A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-users at listserv.mincom.oz.au</A>); Mon, 30 Sep 1996 11:38:41 +1000
-Received: from brutus.neuronio.pt (brutus.neuronio.pt [193.126.253.2]) by bunyip.cc.uq.oz.au (8.7.6/8.7.3) with SMTP id LAA15824 for &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-users at mincom.com</A>&gt;; Mon, 30 Sep 1996 11:40:07 +1000
-Received: (from <A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at localhost</A>) by brutus.neuronio.pt (8.6.11/8.6.11) id BAA08729; Mon, 30 Sep 1996 01:37:40 +0100
-Date: Mon, 30 Sep 1996 01:37:40 +0100
-Message-Id: &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">199609300037.BAA08729 at brutus.neuronio.pt</A>&gt;
-From: Sampo Kellomaki &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at neuronio.pt</A>&gt;
-To: <A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-users at mincom.com</A>
-Cc: <A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at brutus.neuronio.pt</A>
-Subject: Signing with envelope routines
-Sender: <A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-lists-owner at mincom.com</A>
-Precedence: bulk
-Status: RO
-X-Status: D
-
-
-I have been trying to figure out how to produce signatures with EVP_
-routines. I seem to be able to read in private key and sign some
-data ok, but I can't figure out how I am supposed to read in
-public key so that I could verify my signature. I use self signed
-certificate.
-
-I figured I should use
-	EVP_PKEY* pkey = PEM_ASN1_read(d2i_PrivateKey, PEM_STRING_EVP_PKEY,
-	                               fp, NULL, NULL);
-to read in private key and this seems to work Ok.
-
-However when I try analogous
-	EVP_PKEY* pkey = PEM_ASN1_read(d2i_PublicKey, PEM_STRING_X509,
-	                               fp, NULL, NULL);
-the program fails with
-
-error:0D09508D:asn1 encoding routines:D2I_PUBLICKEY:unknown public key type:d2i_pu.c:93
-error:0906700D:PEM routines:PEM_ASN1_read_bio:ASN1 lib:pem_lib.c:232
-
-I figured that the second argument to PEM_ASN1_read should match the
-name in my PEM encoded object, hence PEM_STRING_X509.
-PEM_STRING_EVP_PKEY seems to be somehow magical
-because it matches whatever private key there happens to be. I could
-not find a similar constant to use with getting the certificate, however.
-
-Is my approach of using PEM_ASN1_read correct? What should I pass in
-as name?  Can I use normal (or even self signed) X509 certificate for
-verifying the signature?
-
-When will SSLeay documentation be written ;-)? If I would contribute
-comments to the code, would Eric take time to review them and include
-them in distribution?
-
-I'm using SSLeay-0.6.4. My program is included below along with the
-key and cert that I use.
-
---Sampo
-
------------------------------------
-/* sign-it.cpp  -  Simple test app using SSLeay envelopes to sign data
-   29.9.1996, Sampo Kellomaki &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at iki.fi</A>&gt; */
-
-#include &lt;stdio.h&gt;
-#include &quot;rsa.h&quot;
-#include &quot;evp.h&quot;
-#include &quot;objects.h&quot;
-#include &quot;x509.h&quot;
-#include &quot;err.h&quot;
-#include &quot;pem.h&quot;
-#include &quot;ssl.h&quot;
-
-void main ()
-{
-  int err;
-  int sig_len;
-  unsigned char sig_buf [4096];
-  const char certfile[] = &quot;plain-cert.pem&quot;;
-  const char keyfile[]  = &quot;plain-key.pem&quot;;
-  const char data[]     = &quot;I owe you...&quot;;
-  EVP_MD_CTX     md_ctx;
-  EVP_PKEY*      pkey;
-  FILE*          fp;
-
-  SSL_load_error_strings();
-  
-  /* Read private key */
-  
-  fp = fopen (keyfile, &quot;r&quot;);   if (fp == NULL) exit (1);
-  pkey = (EVP_PKEY*)PEM_ASN1_read ((char *(*)())d2i_PrivateKey,
-				   PEM_STRING_EVP_PKEY,
-				   fp,
-				   NULL, NULL);
-  if (pkey == NULL) {  ERR_print_errors_fp (stderr);    exit (1);  }
-  fclose (fp);
-  
-  /* Do the signature */
-  
-  EVP_SignInit   (&amp;md_ctx, EVP_md5());
-  EVP_SignUpdate (&amp;md_ctx, data, strlen(data));
-  sig_len = sizeof(sig_buf);
-  err = EVP_SignFinal (&amp;md_ctx,
-		       sig_buf, 
-		       &amp;sig_len,
-		       pkey);
-  if (err != 1) {  ERR_print_errors_fp (stderr);    exit (1);  }
-  EVP_PKEY_free (pkey);
-  
-  /* Read public key */
-  
-  fp = fopen (certfile, &quot;r&quot;);   if (fp == NULL) exit (1);
-  pkey = (EVP_PKEY*)PEM_ASN1_read ((char *(*)())d2i_PublicKey,
-				   PEM_STRING_X509,
-				   fp,
-				   NULL, NULL);
-  if (pkey == NULL) {  ERR_print_errors_fp (stderr);    exit (1);  }
-  fclose (fp);
-  
-  /* Verify the signature */
-  
-  EVP_VerifyInit   (&amp;md_ctx, EVP_md5());
-  EVP_VerifyUpdate (&amp;md_ctx, data, strlen((char*)data));
-  err = EVP_VerifyFinal (&amp;md_ctx,
-			 sig_buf,
-			 sig_len,
-			 pkey);
-  if (err != 1) {  ERR_print_errors_fp (stderr);    exit (1);  }
-  EVP_PKEY_free (pkey);
-  printf (&quot;Signature Verified Ok.\n&quot;);
-}
-/* EOF */
---------------- plain-cert.pem -----------------
------BEGIN CERTIFICATE-----
-MIICLDCCAdYCAQAwDQYJKoZIhvcNAQEEBQAwgaAxCzAJBgNVBAYTAlBUMRMwEQYD
-VQQIEwpRdWVlbnNsYW5kMQ8wDQYDVQQHEwZMaXNib2ExFzAVBgNVBAoTDk5ldXJv
-bmlvLCBMZGEuMRgwFgYDVQQLEw9EZXNlbnZvbHZpbWVudG8xGzAZBgNVBAMTEmJy
-dXR1cy5uZXVyb25pby5wdDEbMBkGCSqGSIb3DQEJARYMc2FtcG9AaWtpLmZpMB4X
-DTk2MDkwNTAzNDI0M1oXDTk2MTAwNTAzNDI0M1owgaAxCzAJBgNVBAYTAlBUMRMw
-EQYDVQQIEwpRdWVlbnNsYW5kMQ8wDQYDVQQHEwZMaXNib2ExFzAVBgNVBAoTDk5l
-dXJvbmlvLCBMZGEuMRgwFgYDVQQLEw9EZXNlbnZvbHZpbWVudG8xGzAZBgNVBAMT
-EmJydXR1cy5uZXVyb25pby5wdDEbMBkGCSqGSIb3DQEJARYMc2FtcG9AaWtpLmZp
-MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAL7+aty3S1iBA/+yxjxv4q1MUTd1kjNw
-L4lYKbpzzlmC5beaQXeQ2RmGMTXU+mDvuqItjVHOK3DvPK7lTcSGftUCAwEAATAN
-BgkqhkiG9w0BAQQFAANBAFqPEKFjk6T6CKTHvaQeEAsX0/8YHPHqH/9AnhSjrwuX
-9EBc0n6bVGhN7XaXd6sJ7dym9sbsWxb+pJdurnkxjx4=
------END CERTIFICATE-----
----------------- plain-key.pem -----------------
------BEGIN RSA PRIVATE KEY-----
-MIIBPAIBAAJBAL7+aty3S1iBA/+yxjxv4q1MUTd1kjNwL4lYKbpzzlmC5beaQXeQ
-2RmGMTXU+mDvuqItjVHOK3DvPK7lTcSGftUCAwEAAQJBALjkK+jc2+iihI98riEF
-oudmkNziSRTYjnwjx8mCoAjPWviB3c742eO3FG4/soi1jD9A5alihEOXfUzloenr
-8IECIQD3B5+0l+68BA/6d76iUNqAAV8djGTzvxnCxycnxPQydQIhAMXt4trUI3nc
-a+U8YL2HPFA3gmhBsSICbq2OptOCnM7hAiEA6Xi3JIQECob8YwkRj29DU3/4WYD7
-WLPgsQpwo1GuSpECICGsnWH5oaeD9t9jbFoSfhJvv0IZmxdcLpRcpslpeWBBAiEA
-6/5B8J0GHdJq89FHwEG/H2eVVUYu5y/aD6sgcm+0Avg=
------END RSA PRIVATE KEY-----
-------------------------------------------------
-
diff --git a/demos/sign/sign.c b/demos/sign/sign.c
deleted file mode 100644
index fb0e038..0000000
--- a/demos/sign/sign.c
+++ /dev/null
@@ -1,159 +0,0 @@
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-/*
- * sign-it.cpp - Simple test app using EVP envelopes to sign data
- * 29.9.1996, Sampo Kellomaki &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at iki.fi</A>&gt;
- */
-
-/* converted to C - eay :-) */
-
-/*
- * reformated a bit and converted to use the more common functions: this was
- * initially written at the dawn of time :-) - Steve.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;openssl/rsa.h&gt;
-#include &lt;openssl/evp.h&gt;
-#include &lt;openssl/objects.h&gt;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &lt;openssl/pem.h&gt;
-#include &lt;openssl/ssl.h&gt;
-
-int main()
-{
-    int err;
-    int sig_len;
-    unsigned char sig_buf[4096];
-    static char certfile[] = &quot;cert.pem&quot;;
-    static char keyfile[] = &quot;key.pem&quot;;
-    static char data[] = &quot;I owe you...&quot;;
-    EVP_MD_CTX md_ctx;
-    EVP_PKEY *pkey;
-    FILE *fp;
-    X509 *x509;
-
-    /*
-     * Just load the crypto library error strings, SSL_load_error_strings()
-     * loads the crypto AND the SSL ones
-     */
-    /* SSL_load_error_strings(); */
-    ERR_load_crypto_strings();
-
-    /* Read private key */
-
-    fp = fopen(keyfile, &quot;r&quot;);
-    if (fp == NULL)
-        exit(1);
-    pkey = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
-    fclose(fp);
-
-    if (pkey == NULL) {
-        ERR_print_errors_fp(stderr);
-        exit(1);
-    }
-
-    /* Do the signature */
-
-    EVP_SignInit(&amp;md_ctx, EVP_sha1());
-    EVP_SignUpdate(&amp;md_ctx, data, strlen(data));
-    sig_len = sizeof(sig_buf);
-    err = EVP_SignFinal(&amp;md_ctx, sig_buf, &amp;sig_len, pkey);
-
-    if (err != 1) {
-        ERR_print_errors_fp(stderr);
-        exit(1);
-    }
-
-    EVP_PKEY_free(pkey);
-
-    /* Read public key */
-
-    fp = fopen(certfile, &quot;r&quot;);
-    if (fp == NULL)
-        exit(1);
-    x509 = PEM_read_X509(fp, NULL, NULL, NULL);
-    fclose(fp);
-
-    if (x509 == NULL) {
-        ERR_print_errors_fp(stderr);
-        exit(1);
-    }
-
-    /* Get public key - eay */
-    pkey = X509_get_pubkey(x509);
-    if (pkey == NULL) {
-        ERR_print_errors_fp(stderr);
-        exit(1);
-    }
-
-    /* Verify the signature */
-
-    EVP_VerifyInit(&amp;md_ctx, EVP_sha1());
-    EVP_VerifyUpdate(&amp;md_ctx, data, strlen((char *)data));
-    err = EVP_VerifyFinal(&amp;md_ctx, sig_buf, sig_len, pkey);
-    EVP_PKEY_free(pkey);
-
-    if (err != 1) {
-        ERR_print_errors_fp(stderr);
-        exit(1);
-    }
-    printf(&quot;Signature Verified Ok.\n&quot;);
-    return (0);
-}
diff --git a/demos/sign/sign.txt b/demos/sign/sign.txt
deleted file mode 100644
index 2aa2b46..0000000
--- a/demos/sign/sign.txt
+++ /dev/null
@@ -1,170 +0,0 @@
-From <A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-lists-owner at mincom.com</A> Mon Sep 30 22:43:15 1996
-Received: from cygnus.mincom.oz.au by orb.mincom.oz.au with SMTP id AA12802
-  (5.65c/IDA-1.4.4 for eay); Mon, 30 Sep 1996 12:45:43 +1000
-Received: (from <A HREF="../../../mailman/listinfo/openssl-commits.html">daemon at localhost</A>) by cygnus.mincom.oz.au (8.7.5/8.7.3) id MAA25922 for ssl-users-outgoing; Mon, 30 Sep 1996 12:43:43 +1000 (EST)
-Received: from orb.mincom.oz.au (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at orb.mincom.oz.au</A> [192.55.197.1]) by cygnus.mincom.oz.au (8.7.5/8.7.3) with SMTP id MAA25900 for &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-users at listserv.mincom.oz.au</A>&gt;; Mon, 30 Sep 1996 12:43:39 +1000 (EST)
-Received: by orb.mincom.oz.au id AA12688
-  (5.65c/IDA-1.4.4 for <A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-users at listserv.mincom.oz.au</A>); Mon, 30 Sep 1996 12:43:16 +1000
-Date: Mon, 30 Sep 1996 12:43:15 +1000 (EST)
-From: Eric Young &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at mincom.com</A>&gt;
-X-Sender: <A HREF="../../../mailman/listinfo/openssl-commits.html">eay at orb</A>
-To: Sampo Kellomaki &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at neuronio.pt</A>&gt;
-Cc: <A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-users at mincom.com</A>, <A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at brutus.neuronio.pt</A>
-Subject: Re: Signing with envelope routines
-In-Reply-To: &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">199609300037.BAA08729 at brutus.neuronio.pt</A>&gt;
-Message-Id: &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Pine.SOL.3.91.960930121504.11800Y-100000 at orb</A>&gt;
-Mime-Version: 1.0
-Content-Type: TEXT/PLAIN; charset=US-ASCII
-Sender: <A HREF="../../../mailman/listinfo/openssl-commits.html">ssl-lists-owner at mincom.com</A>
-Precedence: bulk
-Status: O
-X-Status: 
-
-
-On Mon, 30 Sep 1996, Sampo Kellomaki wrote:
-&gt; I have been trying to figure out how to produce signatures with EVP_
-&gt; routines. I seem to be able to read in private key and sign some
-&gt; data ok, but I can't figure out how I am supposed to read in
-&gt; public key so that I could verify my signature. I use self signed
-&gt; certificate.
-
-hmm... a rather poorly documented are of the library at this point in time.
-
-&gt; I figured I should use
-&gt; 	EVP_PKEY* pkey = PEM_ASN1_read(d2i_PrivateKey, PEM_STRING_EVP_PKEY,
-&gt; 	                               fp, NULL, NULL);
-&gt; to read in private key and this seems to work Ok.
-&gt; 
-&gt; However when I try analogous
-&gt; 	EVP_PKEY* pkey = PEM_ASN1_read(d2i_PublicKey, PEM_STRING_X509,
-&gt; 	                               fp, NULL, NULL);
-
-What you should do is 
-	X509 *x509=PEM_read_X509(fp,NULL,NULL);
-	/* which is the same as PEM_ASN1_read(d2i_X509,PEM_STRING_X509,fp,
-	 * NULL,NULL); */
-Then
-	EVP_PKEY *pkey=X509_extract_key(x509);
-
-There is also a X509_REQ_extract_key(req);
-which gets the public key from a certificate request.
-
-I re-worked quite a bit of this when I cleaned up the dependancy on
-RSA as the private key.
-
-&gt; I figured that the second argument to PEM_ASN1_read should match the
-&gt; name in my PEM encoded object, hence PEM_STRING_X509.
-&gt; PEM_STRING_EVP_PKEY seems to be somehow magical
-&gt; because it matches whatever private key there happens to be. I could
-&gt; not find a similar constant to use with getting the certificate, however.
-
-:-), PEM_STRING_EVP_PKEY is 'magical' :-).  In theory I should be using a
-standard such as PKCS#8 to store the private key so that the type is 
-encoded in the asn.1 encoding of the object.
-
-&gt; Is my approach of using PEM_ASN1_read correct? What should I pass in
-&gt; as name?  Can I use normal (or even self signed) X509 certificate for
-&gt; verifying the signature?
-
-The actual public key is kept in the certificate, so basically you have 
-to load the certificate and then 'unpack' the public key from the 
-certificate.
-
-&gt; When will SSLeay documentation be written ;-)? If I would contribute
-&gt; comments to the code, would Eric take time to review them and include
-&gt; them in distribution?
-
-:-) After SSLv3 and PKCS#7 :-).  I actually started doing a function list 
-but what I really need to do is do quite a few 'this is how you do xyz' 
-type documents.  I suppose the current method is to post to ssl-users and 
-I'll respond :-).
-
-I'll add a 'demo' directory for the next release, I've appended a 
-modified version of your program that works, you were very close :-).
-
-eric
-
-/* sign-it.cpp  -  Simple test app using SSLeay envelopes to sign data
-   29.9.1996, Sampo Kellomaki &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at iki.fi</A>&gt; */
-
-/* converted to C - eay :-) */
-
-#include &lt;stdio.h&gt;
-#include &quot;rsa.h&quot;
-#include &quot;evp.h&quot;
-#include &quot;objects.h&quot;
-#include &quot;x509.h&quot;
-#include &quot;err.h&quot;
-#include &quot;pem.h&quot;
-#include &quot;ssl.h&quot;
-
-void main ()
-{
-  int err;
-  int sig_len;
-  unsigned char sig_buf [4096];
-  static char certfile[] = &quot;plain-cert.pem&quot;;
-  static char keyfile[]  = &quot;plain-key.pem&quot;;
-  static char data[]     = &quot;I owe you...&quot;;
-  EVP_MD_CTX     md_ctx;
-  EVP_PKEY *      pkey;
-  FILE *          fp;
-  X509 *	x509;
-
-  /* Just load the crypto library error strings,
-   * SSL_load_error_strings() loads the crypto AND the SSL ones */
-  /* SSL_load_error_strings();*/
-  ERR_load_crypto_strings();
-  
-  /* Read private key */
-  
-  fp = fopen (keyfile, &quot;r&quot;);   if (fp == NULL) exit (1);
-  pkey = (EVP_PKEY*)PEM_ASN1_read ((char *(*)())d2i_PrivateKey,
-				   PEM_STRING_EVP_PKEY,
-				   fp,
-				   NULL, NULL);
-  if (pkey == NULL) {  ERR_print_errors_fp (stderr);    exit (1);  }
-  fclose (fp);
-  
-  /* Do the signature */
-  
-  EVP_SignInit   (&amp;md_ctx, EVP_md5());
-  EVP_SignUpdate (&amp;md_ctx, data, strlen(data));
-  sig_len = sizeof(sig_buf);
-  err = EVP_SignFinal (&amp;md_ctx,
-		       sig_buf, 
-		       &amp;sig_len,
-		       pkey);
-  if (err != 1) {  ERR_print_errors_fp (stderr);    exit (1);  }
-  EVP_PKEY_free (pkey);
-  
-  /* Read public key */
-  
-  fp = fopen (certfile, &quot;r&quot;);   if (fp == NULL) exit (1);
-  x509 = (X509 *)PEM_ASN1_read ((char *(*)())d2i_X509,
-				   PEM_STRING_X509,
-				   fp, NULL, NULL);
-  if (x509 == NULL) {  ERR_print_errors_fp (stderr);    exit (1);  }
-  fclose (fp);
-  
-  /* Get public key - eay */
-  pkey=X509_extract_key(x509);
-  if (pkey == NULL) {  ERR_print_errors_fp (stderr);    exit (1);  }
-
-  /* Verify the signature */
-  
-  EVP_VerifyInit   (&amp;md_ctx, EVP_md5());
-  EVP_VerifyUpdate (&amp;md_ctx, data, strlen((char*)data));
-  err = EVP_VerifyFinal (&amp;md_ctx,
-			 sig_buf,
-			 sig_len,
-			 pkey);
-  if (err != 1) {  ERR_print_errors_fp (stderr);    exit (1);  }
-  EVP_PKEY_free (pkey);
-  printf (&quot;Signature Verified Ok.\n&quot;);
-}
-
-
-
-
-
diff --git a/demos/spkigen.c b/demos/spkigen.c
deleted file mode 100644
index 7df8f34..0000000
--- a/demos/spkigen.c
+++ /dev/null
@@ -1,171 +0,0 @@
-/* NOCW */
-/*-
- * demos/spkigen.c
- * 18-Mar-1997 - eay - A quick hack :-)
- *              version 1.1, it would probably help to save or load the
- *              private key :-)
- */
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &lt;openssl/asn1.h&gt;
-#include &lt;openssl/objects.h&gt;
-#include &lt;openssl/evp.h&gt;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/pem.h&gt;
-
-/*
- * The following two don't exist in SSLeay but they are in here as examples
- */
-#define PEM_write_SPKI(fp,x) \
-        PEM_ASN1_write((int (*)())i2d_NETSCAPE_SPKI,&quot;SPKI&quot;,fp,\
-                        (char *)x,NULL,NULL,0,NULL)
-int SPKI_set_pubkey(NETSCAPE_SPKI *x, EVP_PKEY *pkey);
-
-/* These are defined in the next version of SSLeay */
-int EVP_PKEY_assign(EVP_PKEY *pkey, int type, char *key);
-#define RSA_F4  0x10001
-#define EVP_PKEY_assign_RSA(pkey,rsa) EVP_PKEY_assign((pkey),EVP_PKEY_RSA,\
-                                        (char *)(rsa))
-
-int main(argc, argv)
-int argc;
-char *argv[];
-{
-    RSA *rsa = NULL;
-    NETSCAPE_SPKI *spki = NULL;
-    EVP_PKEY *pkey = NULL;
-    char buf[128];
-    int ok = 0, i;
-    FILE *fp;
-
-    pkey = EVP_PKEY_new();
-
-    if (argc &lt; 2) {
-        /*
-         * Generate an RSA key, the random state should have been seeded with
-         * lots of calls to RAND_seed(....)
-         */
-        fprintf(stderr, &quot;generating RSA key, could take some time...\n&quot;);
-        if ((rsa = RSA_generate_key(512, RSA_F4, NULL)) == NULL)
-            goto err;
-    } else {
-        if ((fp = fopen(argv[1], &quot;r&quot;)) == NULL) {
-            perror(argv[1]);
-            goto err;
-        }
-        if ((rsa = PEM_read_RSAPrivateKey(fp, NULL, NULL)) == NULL)
-            goto err;
-        fclose(fp);
-    }
-
-    if (!EVP_PKEY_assign_RSA(pkey, rsa))
-        goto err;
-    rsa = NULL;
-
-    /* lets make the spki and set the public key and challenge */
-    if ((spki = NETSCAPE_SPKI_new()) == NULL)
-        goto err;
-
-    if (!SPKI_set_pubkey(spki, pkey))
-        goto err;
-
-    fprintf(stderr, &quot;please enter challenge string:&quot;);
-    fflush(stderr);
-    buf[0] = '\0';
-    fgets(buf, sizeof buf, stdin);
-    i = strlen(buf);
-    if (i &gt; 0)
-        buf[--i] = '\0';
-    if (!ASN1_STRING_set((ASN1_STRING *)spki-&gt;spkac-&gt;challenge, buf, i))
-        goto err;
-
-    if (!NETSCAPE_SPKI_sign(spki, pkey, EVP_md5()))
-        goto err;
-    PEM_write_SPKI(stdout, spki);
-    if (argc &lt; 2)
-        PEM_write_RSAPrivateKey(stdout, pkey-&gt;pkey.rsa, NULL, NULL, 0, NULL);
-
-    ok = 1;
- err:
-    if (!ok) {
-        fprintf(stderr, &quot;something bad happened....&quot;);
-        ERR_print_errors_fp(stderr);
-    }
-    NETSCAPE_SPKI_free(spki);
-    EVP_PKEY_free(pkey);
-    exit(!ok);
-}
-
-/* This function is in the next version of SSLeay */
-int EVP_PKEY_assign(pkey, type, key)
-EVP_PKEY *pkey;
-int type;
-char *key;
-{
-    if (pkey == NULL)
-        return (0);
-    if (pkey-&gt;pkey.ptr != NULL) {
-        if (pkey-&gt;type == EVP_PKEY_RSA)
-            RSA_free(pkey-&gt;pkey.rsa);
-        /* else memory leak */
-    }
-    pkey-&gt;type = type;
-    pkey-&gt;pkey.ptr = key;
-    return (1);
-}
-
-/*
- * While I have a X509_set_pubkey() and X509_REQ_set_pubkey(),
- * SPKI_set_pubkey() does not currently exist so here is a version of it. The
- * next SSLeay release will probably have X509_set_pubkey(),
- * X509_REQ_set_pubkey() and NETSCAPE_SPKI_set_pubkey() as macros calling the
- * same function
- */
-int SPKI_set_pubkey(x, pkey)
-NETSCAPE_SPKI *x;
-EVP_PKEY *pkey;
-{
-    int ok = 0;
-    X509_PUBKEY *pk;
-    X509_ALGOR *a;
-    ASN1_OBJECT *o;
-    unsigned char *s, *p;
-    int i;
-
-    if (x == NULL)
-        return (0);
-
-    if ((pk = X509_PUBKEY_new()) == NULL)
-        goto err;
-    a = pk-&gt;algor;
-
-    /* set the algorithm id */
-    if ((o = OBJ_nid2obj(pkey-&gt;type)) == NULL)
-        goto err;
-    ASN1_OBJECT_free(a-&gt;algorithm);
-    a-&gt;algorithm = o;
-
-    /* Set the parameter list */
-    if ((a-&gt;parameter == NULL) || (a-&gt;parameter-&gt;type != V_ASN1_NULL)) {
-        ASN1_TYPE_free(a-&gt;parameter);
-        a-&gt;parameter = ASN1_TYPE_new();
-        a-&gt;parameter-&gt;type = V_ASN1_NULL;
-    }
-    i = i2d_PublicKey(pkey, NULL);
-    if ((s = (unsigned char *)malloc(i + 1)) == NULL)
-        goto err;
-    p = s;
-    i2d_PublicKey(pkey, &amp;p);
-    if (!ASN1_BIT_STRING_set(pk-&gt;public_key, s, i))
-        goto err;
-    free(s);
-
-    X509_PUBKEY_free(x-&gt;spkac-&gt;pubkey);
-    x-&gt;spkac-&gt;pubkey = pk;
-    pk = NULL;
-    ok = 1;
- err:
-    X509_PUBKEY_free(pk);
-    return (ok);
-}
diff --git a/demos/ssl/cli.cpp b/demos/ssl/cli.cpp
deleted file mode 100644
index fcc4d9d..0000000
--- a/demos/ssl/cli.cpp
+++ /dev/null
@@ -1,108 +0,0 @@
-/* cli.cpp  -  Minimal ssleay client for Unix
-   30.9.1996, Sampo Kellomaki &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at iki.fi</A>&gt; */
-
-/* mangled to work with OpenSSL 0.9.2b
-   Simplified to be even more minimal
-   12/98 - 4/99 Wade Scholine &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">wades at mail.cybg.com</A>&gt; */
-
-#include &lt;stdio.h&gt;
-#include &lt;memory.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;netinet/in.h&gt;
-#include &lt;arpa/inet.h&gt;
-#include &lt;netdb.h&gt;
-
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/pem.h&gt;
-#include &lt;openssl/ssl.h&gt;
-#include &lt;openssl/err.h&gt;
-
-
-#define CHK_NULL(x) if ((x)==NULL) exit (1)
-#define CHK_ERR(err,s) if ((err)==-1) { perror(s); exit(1); }
-#define CHK_SSL(err) if ((err)==-1) { ERR_print_errors_fp(stderr); exit(2); }
-
-void main ()
-{
-  int err;
-  int sd;
-  struct sockaddr_in sa;
-  SSL_CTX* ctx;
-  SSL*     ssl;
-  X509*    server_cert;
-  char*    str;
-  char     buf [4096];
-  SSL_METHOD *meth;
-
-  OpenSSL_add_ssl_algorithms();
-  meth = TLS_client_method();
-  SSL_load_error_strings();
-  ctx = SSL_CTX_new (meth);                        CHK_NULL(ctx);
-
-  /* ----------------------------------------------- */
-  /* Create a socket and connect to server using normal socket calls. */
-  
-  sd = socket (AF_INET, SOCK_STREAM, 0);       CHK_ERR(sd, &quot;socket&quot;);
- 
-  memset(&amp;sa, 0, sizeof(sa));
-  sa.sin_family      = AF_INET;
-  sa.sin_addr.s_addr = inet_addr (&quot;127.0.0.1&quot;);   /* Server IP */
-  sa.sin_port        = htons     (1111);          /* Server Port number */
-  
-  err = connect(sd, (struct sockaddr*) &amp;sa,
-		sizeof(sa));                   CHK_ERR(err, &quot;connect&quot;);
-
-  /* ----------------------------------------------- */
-  /* Now we have TCP conncetion. Start SSL negotiation. */
-  
-  ssl = SSL_new (ctx);                         CHK_NULL(ssl);    
-  SSL_set_fd (ssl, sd);
-  err = SSL_connect (ssl);                     CHK_SSL(err);
-    
-  /* Following two steps are optional and not required for
-     data exchange to be successful. */
-  
-  /* Get the cipher - opt */
-
-  printf (&quot;SSL connection using %s\n&quot;, SSL_get_cipher (ssl));
-  
-  /* Get server's certificate (note: beware of dynamic allocation) - opt */
-
-  server_cert = SSL_get_peer_certificate (ssl);       CHK_NULL(server_cert);
-  printf (&quot;Server certificate:\n&quot;);
-  
-  str = X509_NAME_oneline (X509_get_subject_name (server_cert),0,0);
-  CHK_NULL(str);
-  printf (&quot;\t subject: %s\n&quot;, str);
-  OPENSSL_free (str);
-
-  str = X509_NAME_oneline (X509_get_issuer_name  (server_cert),0,0);
-  CHK_NULL(str);
-  printf (&quot;\t issuer: %s\n&quot;, str);
-  OPENSSL_free (str);
-
-  /* We could do all sorts of certificate verification stuff here before
-     deallocating the certificate. */
-
-  X509_free (server_cert);
-  
-  /* --------------------------------------------------- */
-  /* DATA EXCHANGE - Send a message and receive a reply. */
-
-  err = SSL_write (ssl, &quot;Hello World!&quot;, strlen(&quot;Hello World!&quot;));  CHK_SSL(err);
-  
-  err = SSL_read (ssl, buf, sizeof(buf) - 1);                     CHK_SSL(err);
-  buf[err] = '\0';
-  printf (&quot;Got %d chars:'%s'\n&quot;, err, buf);
-  SSL_shutdown (ssl);  /* send SSL/TLS close_notify */
-
-  /* Clean up. */
-
-  close (sd);
-  SSL_free (ssl);
-  SSL_CTX_free (ctx);
-}
-/* EOF - cli.cpp */
diff --git a/demos/ssl/inetdsrv.cpp b/demos/ssl/inetdsrv.cpp
deleted file mode 100644
index 7434030..0000000
--- a/demos/ssl/inetdsrv.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-/* inetdserv.cpp  -  Minimal ssleay server for Unix inetd.conf
- * 30.9.1996, Sampo Kellomaki &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at iki.fi</A>&gt;
- * From /etc/inetd.conf:
- *     1111 stream tcp nowait sampo /usr/users/sampo/demo/inetdserv inetdserv
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;errno.h&gt;
-
-#include &quot;rsa.h&quot;
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/pem.h&gt;
-#include &lt;openssl/ssl.h&gt;
-#include &lt;openssl/err.h&gt;
-
-#define HOME &quot;/usr/users/sampo/demo/&quot;
-#define CERTF HOME &quot;plain-cert.pem&quot;
-#define KEYF  HOME &quot;plain-key.pem&quot;
-
-#define CHK_NULL(x) if ((x)==NULL) exit (1)
-#define CHK_ERR(err,s) if ((err)==-1) \
-                         { fprintf(log, &quot;%s %d\n&quot;, (s), errno); exit(1); }
-#define CHK_SSL(err) if ((err)==-1) { ERR_print_errors_fp(log); exit(2); }
-
-void main ()
-{
-  int err;
-  SSL_CTX* ctx;
-  SSL*     ssl;
-  X509*    client_cert;
-  char*    str;
-  char     buf [4096];
-  FILE* log;
-  
-  log = fopen (&quot;/dev/console&quot;, &quot;a&quot;);                     CHK_NULL(log);
-  fprintf (log, &quot;inetdserv %ld\n&quot;, (long)getpid());
-  
-  SSL_load_error_strings();
-  ctx = SSL_CTX_new (); CHK_NULL(ctx);
-  
-  err = SSL_CTX_use_RSAPrivateKey_file (ctx, KEYF,  SSL_FILETYPE_PEM);
-  CHK_SSL (err);
-  
-  err = SSL_CTX_use_certificate_file   (ctx, CERTF, SSL_FILETYPE_PEM);
-  CHK_SSL (err);
-
-  /* inetd has already opened the TCP connection, so we can get right
-     down to business. */
-  
-  ssl = SSL_new (ctx);  CHK_NULL(ssl);
-  SSL_set_fd (ssl,  fileno(stdin));
-  err = SSL_accept (ssl);                                CHK_SSL(err);
-  
-  /* Get the cipher - opt */
-  
-  fprintf (log, &quot;SSL connection using %s\n&quot;, SSL_get_cipher (ssl));
-  
-  /* Get client's certificate (note: beware of dynamic allocation) - opt */
-
-  client_cert = SSL_get_peer_certificate (ssl);
-  if (client_cert != NULL) {
-    fprintf (log, &quot;Client certificate:\n&quot;);
-    
-    str = X509_NAME_oneline (X509_get_subject_name (client_cert));
-    CHK_NULL(str);
-    fprintf (log, &quot;\t subject: %s\n&quot;, str);
-    OPENSSL_free (str);
-    
-    str = X509_NAME_oneline (X509_get_issuer_name  (client_cert));
-    CHK_NULL(str);
-    fprintf (log, &quot;\t issuer: %s\n&quot;, str);
-    OPENSSL_free (str);
-    
-    /* We could do all sorts of certificate verification stuff here before
-       deallocating the certificate. */
-    
-    X509_free (client_cert);
-  } else
-    fprintf (log, &quot;Client doe not have certificate.\n&quot;);
-
-  /* ------------------------------------------------- */
-  /* DATA EXCHANGE: Receive message and send reply  */
-  
-  err = SSL_read (ssl, buf, sizeof(buf) - 1);  CHK_SSL(err);
-  buf[err] = '\0';
-  fprintf (log, &quot;Got %d chars:'%s'\n&quot;, err, buf);
-  
-  err = SSL_write (ssl, &quot;Loud and clear.&quot;, strlen(&quot;Loud and clear.&quot;));
-  CHK_SSL(err);
-
-  /* Clean up. */
-
-  fclose (log);
-  SSL_free (ssl);
-  SSL_CTX_free (ctx);
-}
-/* EOF - inetdserv.cpp */
diff --git a/demos/ssl/serv.cpp b/demos/ssl/serv.cpp
deleted file mode 100644
index 43ff88e..0000000
--- a/demos/ssl/serv.cpp
+++ /dev/null
@@ -1,152 +0,0 @@
-/* serv.cpp  -  Minimal ssleay server for Unix
-   30.9.1996, Sampo Kellomaki &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">sampo at iki.fi</A>&gt; */
-
-
-/* mangled to work with OpenSSL 0.9.2b
-   Simplified to be even more minimal
-   12/98 - 4/99 Wade Scholine &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">wades at mail.cybg.com</A>&gt; */
-
-#include &lt;stdio.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;memory.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;netinet/in.h&gt;
-#include &lt;arpa/inet.h&gt;
-#include &lt;netdb.h&gt;
-
-#include &lt;openssl/rsa.h&gt;
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/pem.h&gt;
-#include &lt;openssl/ssl.h&gt;
-#include &lt;openssl/err.h&gt;
-
-
-/* define HOME to be dir for key and cert files... */
-#define HOME &quot;./&quot;
-/* Make these what you want for cert &amp; key files */
-#define CERTF  HOME &quot;foo-cert.pem&quot;
-#define KEYF  HOME  &quot;foo-cert.pem&quot;
-
-
-#define CHK_NULL(x) if ((x)==NULL) exit (1)
-#define CHK_ERR(err,s) if ((err)==-1) { perror(s); exit(1); }
-#define CHK_SSL(err) if ((err)==-1) { ERR_print_errors_fp(stderr); exit(2); }
-
-void main ()
-{
-  int err;
-  int listen_sd;
-  int sd;
-  struct sockaddr_in sa_serv;
-  struct sockaddr_in sa_cli;
-  size_t client_len;
-  SSL_CTX* ctx;
-  SSL*     ssl;
-  X509*    client_cert;
-  char*    str;
-  char     buf [4096];
-  SSL_METHOD *meth;
-  
-  /* SSL preliminaries. We keep the certificate and key with the context. */
-
-  SSL_load_error_strings();
-  OpenSSL_add_ssl_algorithms();
-  meth = TLS_server_method();
-  ctx = SSL_CTX_new (meth);
-  if (!ctx) {
-    ERR_print_errors_fp(stderr);
-    exit(2);
-  }
-  
-  if (SSL_CTX_use_certificate_file(ctx, CERTF, SSL_FILETYPE_PEM) &lt;= 0) {
-    ERR_print_errors_fp(stderr);
-    exit(3);
-  }
-  if (SSL_CTX_use_PrivateKey_file(ctx, KEYF, SSL_FILETYPE_PEM) &lt;= 0) {
-    ERR_print_errors_fp(stderr);
-    exit(4);
-  }
-
-  if (!SSL_CTX_check_private_key(ctx)) {
-    fprintf(stderr,&quot;Private key does not match the certificate public key\n&quot;);
-    exit(5);
-  }
-
-  /* ----------------------------------------------- */
-  /* Prepare TCP socket for receiving connections */
-
-  listen_sd = socket (AF_INET, SOCK_STREAM, 0);   CHK_ERR(listen_sd, &quot;socket&quot;);
-  
-  memset(&amp;sa_serv, 0, sizeof(sa_serv));
-  sa_serv.sin_family      = AF_INET;
-  sa_serv.sin_addr.s_addr = INADDR_ANY;
-  sa_serv.sin_port        = htons (1111);          /* Server Port number */
-  
-  err = bind(listen_sd, (struct sockaddr*) &amp;sa_serv,
-	     sizeof (sa_serv));                   CHK_ERR(err, &quot;bind&quot;);
-	     
-  /* Receive a TCP connection. */
-	     
-  err = listen (listen_sd, 5);                    CHK_ERR(err, &quot;listen&quot;);
-  
-  client_len = sizeof(sa_cli);
-  sd = accept (listen_sd, (struct sockaddr*) &amp;sa_cli, &amp;client_len);
-  CHK_ERR(sd, &quot;accept&quot;);
-  close (listen_sd);
-
-  printf (&quot;Connection from %lx, port %x\n&quot;,
-	  sa_cli.sin_addr.s_addr, sa_cli.sin_port);
-  
-  /* ----------------------------------------------- */
-  /* TCP connection is ready. Do server side SSL. */
-
-  ssl = SSL_new (ctx);                           CHK_NULL(ssl);
-  SSL_set_fd (ssl, sd);
-  err = SSL_accept (ssl);                        CHK_SSL(err);
-  
-  /* Get the cipher - opt */
-  
-  printf (&quot;SSL connection using %s\n&quot;, SSL_get_cipher (ssl));
-  
-  /* Get client's certificate (note: beware of dynamic allocation) - opt */
-
-  client_cert = SSL_get_peer_certificate (ssl);
-  if (client_cert != NULL) {
-    printf (&quot;Client certificate:\n&quot;);
-    
-    str = X509_NAME_oneline (X509_get_subject_name (client_cert), 0, 0);
-    CHK_NULL(str);
-    printf (&quot;\t subject: %s\n&quot;, str);
-    OPENSSL_free (str);
-    
-    str = X509_NAME_oneline (X509_get_issuer_name  (client_cert), 0, 0);
-    CHK_NULL(str);
-    printf (&quot;\t issuer: %s\n&quot;, str);
-    OPENSSL_free (str);
-    
-    /* We could do all sorts of certificate verification stuff here before
-       deallocating the certificate. */
-    
-    X509_free (client_cert);
-  } else
-    printf (&quot;Client does not have certificate.\n&quot;);
-
-  /* DATA EXCHANGE - Receive message and send reply. */
-
-  err = SSL_read (ssl, buf, sizeof(buf) - 1);                   CHK_SSL(err);
-  buf[err] = '\0';
-  printf (&quot;Got %d chars:'%s'\n&quot;, err, buf);
-  
-  err = SSL_write (ssl, &quot;I hear you.&quot;, strlen(&quot;I hear you.&quot;));  CHK_SSL(err);
-
-  /* Clean up. */
-
-  close (sd);
-  SSL_free (ssl);
-  SSL_CTX_free (ctx);
-}
-/* EOF - serv.cpp */
diff --git a/demos/ssltest-ecc/ECC-RSAcertgen.sh b/demos/ssltest-ecc/ECC-RSAcertgen.sh
deleted file mode 100755
index b31a4f1..0000000
--- a/demos/ssltest-ecc/ECC-RSAcertgen.sh
+++ /dev/null
@@ -1,98 +0,0 @@
-#!/bin/sh
-
-# For a list of supported curves, use &quot;apps/openssl ecparam -list_curves&quot;.
-
-# Path to the openssl distribution
-OPENSSL_DIR=../..
-# Path to the openssl program
-OPENSSL_CMD=$OPENSSL_DIR/apps/openssl
-# Option to find configuration file
-OPENSSL_CNF=&quot;-config $OPENSSL_DIR/apps/openssl.cnf&quot;
-# Directory where certificates are stored
-CERTS_DIR=./Certs
-# Directory where private key files are stored
-KEYS_DIR=$CERTS_DIR
-# Directory where combo files (containing a certificate and corresponding
-# private key together) are stored
-COMBO_DIR=$CERTS_DIR
-# cat command
-CAT=/bin/cat
-# rm command
-RM=/bin/rm
-# mkdir command
-MKDIR=/bin/mkdir
-# The certificate will expire these many days after the issue date.
-DAYS=1500
-TEST_CA_FILE=rsa1024TestCA
-
-TEST_SERVER_CURVE=sect163r1
-TEST_SERVER_FILE=sect163r1-rsaTestServer
-TEST_SERVER_DN=&quot;/C=US/ST=CA/L=Mountain View/O=Sun Microsystems, Inc./OU=Sun Microsystems Laboratories/CN=Test Server (sect163r1 key signed with RSA)&quot;
-
-TEST_CLIENT_CURVE=sect163r1
-TEST_CLIENT_FILE=sect163r1-rsaTestClient
-TEST_CLIENT_DN=&quot;/C=US/ST=CA/L=Mountain View/O=Sun Microsystems, Inc./OU=Sun Microsystems Laboratories/CN=Test Client (sect163r1 key signed with RSA)&quot;
-
-# Generating an EC certificate involves the following main steps
-# 1. Generating curve parameters (if needed)
-# 2. Generating a certificate request
-# 3. Signing the certificate request 
-# 4. [Optional] One can combine the cert and private key into a single
-#    file and also delete the certificate request
-
-$MKDIR -p $CERTS_DIR
-$MKDIR -p $KEYS_DIR
-$MKDIR -p $COMBO_DIR
-
-echo &quot;GENERATING A TEST SERVER CERTIFICATE (ECC key signed with RSA)&quot;
-echo &quot;==============================================================&quot;
-$OPENSSL_CMD ecparam -name $TEST_SERVER_CURVE -out $TEST_SERVER_CURVE.pem
-
-$OPENSSL_CMD req $OPENSSL_CNF -nodes -subj &quot;$TEST_SERVER_DN&quot; \
-    -keyout $KEYS_DIR/$TEST_SERVER_FILE.key.pem \
-    -newkey ec:$TEST_SERVER_CURVE.pem -new \
-    -out $CERTS_DIR/$TEST_SERVER_FILE.req.pem
-
-$OPENSSL_CMD x509 -req -days $DAYS \
-    -in $CERTS_DIR/$TEST_SERVER_FILE.req.pem \
-    -CA $CERTS_DIR/$TEST_CA_FILE.cert.pem \
-    -CAkey $KEYS_DIR/$TEST_CA_FILE.key.pem \
-    -out $CERTS_DIR/$TEST_SERVER_FILE.cert.pem -CAcreateserial
-
-# Display the certificate 
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_SERVER_FILE.cert.pem -text
-
-# Place the certificate and key in a common file
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_SERVER_FILE.cert.pem -issuer -subject \
-	 &gt; $COMBO_DIR/$TEST_SERVER_FILE.pem
-$CAT $KEYS_DIR/$TEST_SERVER_FILE.key.pem &gt;&gt; $COMBO_DIR/$TEST_SERVER_FILE.pem
-
-# Remove the cert request file (no longer needed)
-$RM $CERTS_DIR/$TEST_SERVER_FILE.req.pem
-
-echo &quot;GENERATING A TEST CLIENT CERTIFICATE (ECC key signed with RSA)&quot;
-echo &quot;==============================================================&quot;
-$OPENSSL_CMD ecparam -name $TEST_CLIENT_CURVE -out $TEST_CLIENT_CURVE.pem
-
-$OPENSSL_CMD req $OPENSSL_CNF -nodes -subj &quot;$TEST_CLIENT_DN&quot; \
-	     -keyout $KEYS_DIR/$TEST_CLIENT_FILE.key.pem \
-	     -newkey ec:$TEST_CLIENT_CURVE.pem -new \
-	     -out $CERTS_DIR/$TEST_CLIENT_FILE.req.pem
-
-$OPENSSL_CMD x509 -req -days $DAYS \
-    -in $CERTS_DIR/$TEST_CLIENT_FILE.req.pem \
-    -CA $CERTS_DIR/$TEST_CA_FILE.cert.pem \
-    -CAkey $KEYS_DIR/$TEST_CA_FILE.key.pem \
-    -out $CERTS_DIR/$TEST_CLIENT_FILE.cert.pem -CAcreateserial
-
-# Display the certificate 
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_CLIENT_FILE.cert.pem -text
-
-# Place the certificate and key in a common file
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_CLIENT_FILE.cert.pem -issuer -subject \
-	 &gt; $COMBO_DIR/$TEST_CLIENT_FILE.pem
-$CAT $KEYS_DIR/$TEST_CLIENT_FILE.key.pem &gt;&gt; $COMBO_DIR/$TEST_CLIENT_FILE.pem
-
-# Remove the cert request file (no longer needed)
-$RM $CERTS_DIR/$TEST_CLIENT_FILE.req.pem
-
diff --git a/demos/ssltest-ecc/ECCcertgen.sh b/demos/ssltest-ecc/ECCcertgen.sh
deleted file mode 100755
index a47b8bb..0000000
--- a/demos/ssltest-ecc/ECCcertgen.sh
+++ /dev/null
@@ -1,164 +0,0 @@
-#!/bin/sh
-
-# For a list of supported curves, use &quot;apps/openssl ecparam -list_curves&quot;.
-
-# Path to the openssl distribution
-OPENSSL_DIR=../..
-# Path to the openssl program
-OPENSSL_CMD=$OPENSSL_DIR/apps/openssl
-# Option to find configuration file
-OPENSSL_CNF=&quot;-config $OPENSSL_DIR/apps/openssl.cnf&quot;
-# Directory where certificates are stored
-CERTS_DIR=./Certs
-# Directory where private key files are stored
-KEYS_DIR=$CERTS_DIR
-# Directory where combo files (containing a certificate and corresponding
-# private key together) are stored
-COMBO_DIR=$CERTS_DIR
-# cat command
-CAT=/bin/cat
-# rm command
-RM=/bin/rm
-# mkdir command
-MKDIR=/bin/mkdir
-# The certificate will expire these many days after the issue date.
-DAYS=1500
-TEST_CA_CURVE=secp160r1
-TEST_CA_FILE=secp160r1TestCA
-TEST_CA_DN=&quot;/C=US/ST=CA/L=Mountain View/O=Sun Microsystems, Inc./OU=Sun Microsystems Laboratories/CN=Test CA (Elliptic curve secp160r1)&quot;
-
-TEST_SERVER_CURVE=secp160r2
-TEST_SERVER_FILE=secp160r2TestServer
-TEST_SERVER_DN=&quot;/C=US/ST=CA/L=Mountain View/O=Sun Microsystems, Inc./OU=Sun Microsystems Laboratories/CN=Test Server (Elliptic curve secp160r2)&quot;
-
-TEST_CLIENT_CURVE=secp160r2
-TEST_CLIENT_FILE=secp160r2TestClient
-TEST_CLIENT_DN=&quot;/C=US/ST=CA/L=Mountain View/O=Sun Microsystems, Inc./OU=Sun Microsystems Laboratories/CN=Test Client (Elliptic curve secp160r2)&quot;
-
-# Generating an EC certificate involves the following main steps
-# 1. Generating curve parameters (if needed)
-# 2. Generating a certificate request
-# 3. Signing the certificate request 
-# 4. [Optional] One can combine the cert and private key into a single
-#    file and also delete the certificate request
-
-$MKDIR -p $CERTS_DIR
-$MKDIR -p $KEYS_DIR
-$MKDIR -p $COMBO_DIR
-
-echo &quot;Generating self-signed CA certificate (on curve $TEST_CA_CURVE)&quot;
-echo &quot;===============================================================&quot;
-$OPENSSL_CMD ecparam -name $TEST_CA_CURVE -out $TEST_CA_CURVE.pem
-
-# Generate a new certificate request in $TEST_CA_FILE.req.pem. A 
-# new ecdsa (actually ECC) key pair is generated on the parameters in
-# $TEST_CA_CURVE.pem and the private key is saved in $TEST_CA_FILE.key.pem
-# WARNING: By using the -nodes option, we force the private key to be 
-# stored in the clear (rather than encrypted with a password).
-$OPENSSL_CMD req $OPENSSL_CNF -nodes -subj &quot;$TEST_CA_DN&quot; \
-    -keyout $KEYS_DIR/$TEST_CA_FILE.key.pem \
-    -newkey ec:$TEST_CA_CURVE.pem -new \
-    -out $CERTS_DIR/$TEST_CA_FILE.req.pem
-
-# Sign the certificate request in $TEST_CA_FILE.req.pem using the
-# private key in $TEST_CA_FILE.key.pem and include the CA extension.
-# Make the certificate valid for 1500 days from the time of signing.
-# The certificate is written into $TEST_CA_FILE.cert.pem
-$OPENSSL_CMD x509 -req -days $DAYS \
-    -in $CERTS_DIR/$TEST_CA_FILE.req.pem \
-    -extfile $OPENSSL_DIR/apps/openssl.cnf \
-    -extensions v3_ca \
-    -signkey $KEYS_DIR/$TEST_CA_FILE.key.pem \
-    -out $CERTS_DIR/$TEST_CA_FILE.cert.pem
-
-# Display the certificate
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_CA_FILE.cert.pem -text
-
-# Place the certificate and key in a common file
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_CA_FILE.cert.pem -issuer -subject \
-	 &gt; $COMBO_DIR/$TEST_CA_FILE.pem
-$CAT $KEYS_DIR/$TEST_CA_FILE.key.pem &gt;&gt; $COMBO_DIR/$TEST_CA_FILE.pem
-
-# Remove the cert request file (no longer needed)
-$RM $CERTS_DIR/$TEST_CA_FILE.req.pem
-
-echo &quot;GENERATING A TEST SERVER CERTIFICATE (on elliptic curve $TEST_SERVER_CURVE)&quot;
-echo &quot;==========================================================================&quot;
-# Generate parameters for curve $TEST_SERVER_CURVE, if needed
-$OPENSSL_CMD ecparam -name $TEST_SERVER_CURVE -out $TEST_SERVER_CURVE.pem
-
-# Generate a new certificate request in $TEST_SERVER_FILE.req.pem. A 
-# new ecdsa (actually ECC) key pair is generated on the parameters in
-# $TEST_SERVER_CURVE.pem and the private key is saved in 
-# $TEST_SERVER_FILE.key.pem
-# WARNING: By using the -nodes option, we force the private key to be 
-# stored in the clear (rather than encrypted with a password).
-$OPENSSL_CMD req $OPENSSL_CNF -nodes -subj &quot;$TEST_SERVER_DN&quot; \
-    -keyout $KEYS_DIR/$TEST_SERVER_FILE.key.pem \
-    -newkey ec:$TEST_SERVER_CURVE.pem -new \
-    -out $CERTS_DIR/$TEST_SERVER_FILE.req.pem
-
-# Sign the certificate request in $TEST_SERVER_FILE.req.pem using the
-# CA certificate in $TEST_CA_FILE.cert.pem and the CA private key in
-# $TEST_CA_FILE.key.pem. Since we do not have an existing serial number
-# file for this CA, create one. Make the certificate valid for $DAYS days
-# from the time of signing. The certificate is written into 
-# $TEST_SERVER_FILE.cert.pem
-$OPENSSL_CMD x509 -req -days $DAYS \
-    -in $CERTS_DIR/$TEST_SERVER_FILE.req.pem \
-    -CA $CERTS_DIR/$TEST_CA_FILE.cert.pem \
-    -CAkey $KEYS_DIR/$TEST_CA_FILE.key.pem \
-    -out $CERTS_DIR/$TEST_SERVER_FILE.cert.pem -CAcreateserial
-
-# Display the certificate 
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_SERVER_FILE.cert.pem -text
-
-# Place the certificate and key in a common file
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_SERVER_FILE.cert.pem -issuer -subject \
-	 &gt; $COMBO_DIR/$TEST_SERVER_FILE.pem
-$CAT $KEYS_DIR/$TEST_SERVER_FILE.key.pem &gt;&gt; $COMBO_DIR/$TEST_SERVER_FILE.pem
-
-# Remove the cert request file (no longer needed)
-$RM $CERTS_DIR/$TEST_SERVER_FILE.req.pem
-
-echo &quot;GENERATING A TEST CLIENT CERTIFICATE (on elliptic curve $TEST_CLIENT_CURVE)&quot;
-echo &quot;==========================================================================&quot;
-# Generate parameters for curve $TEST_CLIENT_CURVE, if needed
-$OPENSSL_CMD ecparam -name $TEST_CLIENT_CURVE -out $TEST_CLIENT_CURVE.pem
-
-# Generate a new certificate request in $TEST_CLIENT_FILE.req.pem. A 
-# new ecdsa (actually ECC) key pair is generated on the parameters in
-# $TEST_CLIENT_CURVE.pem and the private key is saved in 
-# $TEST_CLIENT_FILE.key.pem
-# WARNING: By using the -nodes option, we force the private key to be 
-# stored in the clear (rather than encrypted with a password).
-$OPENSSL_CMD req $OPENSSL_CNF -nodes -subj &quot;$TEST_CLIENT_DN&quot; \
-	     -keyout $KEYS_DIR/$TEST_CLIENT_FILE.key.pem \
-	     -newkey ec:$TEST_CLIENT_CURVE.pem -new \
-	     -out $CERTS_DIR/$TEST_CLIENT_FILE.req.pem
-
-# Sign the certificate request in $TEST_CLIENT_FILE.req.pem using the
-# CA certificate in $TEST_CA_FILE.cert.pem and the CA private key in
-# $TEST_CA_FILE.key.pem. Since we do not have an existing serial number
-# file for this CA, create one. Make the certificate valid for $DAYS days
-# from the time of signing. The certificate is written into 
-# $TEST_CLIENT_FILE.cert.pem
-$OPENSSL_CMD x509 -req -days $DAYS \
-    -in $CERTS_DIR/$TEST_CLIENT_FILE.req.pem \
-    -CA $CERTS_DIR/$TEST_CA_FILE.cert.pem \
-    -CAkey $KEYS_DIR/$TEST_CA_FILE.key.pem \
-    -out $CERTS_DIR/$TEST_CLIENT_FILE.cert.pem -CAcreateserial
-
-# Display the certificate 
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_CLIENT_FILE.cert.pem -text
-
-# Place the certificate and key in a common file
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_CLIENT_FILE.cert.pem -issuer -subject \
-	 &gt; $COMBO_DIR/$TEST_CLIENT_FILE.pem
-$CAT $KEYS_DIR/$TEST_CLIENT_FILE.key.pem &gt;&gt; $COMBO_DIR/$TEST_CLIENT_FILE.pem
-
-# Remove the cert request file (no longer needed)
-$RM $CERTS_DIR/$TEST_CLIENT_FILE.req.pem
-
-
-
diff --git a/demos/ssltest-ecc/README b/demos/ssltest-ecc/README
deleted file mode 100644
index 71c070a..0000000
--- a/demos/ssltest-ecc/README
+++ /dev/null
@@ -1,15 +0,0 @@
-Scripts for using ECC ciphersuites with test/testssl
-(these ciphersuites are described in the Internet Draft available at
-<A HREF="http://www.ietf.org/internet-drafts/draft-ietf-tls-ecc-03.txt">http://www.ietf.org/internet-drafts/draft-ietf-tls-ecc-03.txt</A>).
-
-Use ECCcertgen.sh, RSAcertgen.sh, ECC-RSAcertgen.sh to generate
-root, client and server certs of the following types:
-
-     ECC certs signed with ECDSA
-     RSA certs signed with RSA
-     ECC certs signed with RSA
-
-Afterwards, you can use ssltest.sh to run the various tests;
-specify one of the following options:
-
-     aecdh, ecdh-ecdsa, ecdhe-ecdsa, ecdh-rsa, ecdhe-rsa
diff --git a/demos/ssltest-ecc/RSAcertgen.sh b/demos/ssltest-ecc/RSAcertgen.sh
deleted file mode 100755
index 0cb0153..0000000
--- a/demos/ssltest-ecc/RSAcertgen.sh
+++ /dev/null
@@ -1,121 +0,0 @@
-#!/bin/sh
-
-# For a list of supported curves, use &quot;apps/openssl ecparam -list_curves&quot;.
-
-# Path to the openssl distribution
-OPENSSL_DIR=../..
-# Path to the openssl program
-OPENSSL_CMD=$OPENSSL_DIR/apps/openssl
-# Option to find configuration file
-OPENSSL_CNF=&quot;-config $OPENSSL_DIR/apps/openssl.cnf&quot;
-# Directory where certificates are stored
-CERTS_DIR=./Certs
-# Directory where private key files are stored
-KEYS_DIR=$CERTS_DIR
-# Directory where combo files (containing a certificate and corresponding
-# private key together) are stored
-COMBO_DIR=$CERTS_DIR
-# cat command
-CAT=/bin/cat
-# rm command
-RM=/bin/rm
-# mkdir command
-MKDIR=/bin/mkdir
-# The certificate will expire these many days after the issue date.
-DAYS=1500
-TEST_CA_FILE=rsa1024TestCA
-TEST_CA_DN=&quot;/C=US/ST=CA/L=Mountain View/O=Sun Microsystems, Inc./OU=Sun Microsystems Laboratories/CN=Test CA (1024 bit RSA)&quot;
-
-TEST_SERVER_FILE=rsa1024TestServer
-TEST_SERVER_DN=&quot;/C=US/ST=CA/L=Mountain View/O=Sun Microsystems, Inc./OU=Sun Microsystems Laboratories/CN=Test Server (1024 bit RSA)&quot;
-
-TEST_CLIENT_FILE=rsa1024TestClient
-TEST_CLIENT_DN=&quot;/C=US/ST=CA/L=Mountain View/O=Sun Microsystems, Inc./OU=Sun Microsystems Laboratories/CN=Test Client (1024 bit RSA)&quot;
-
-# Generating an EC certificate involves the following main steps
-# 1. Generating curve parameters (if needed)
-# 2. Generating a certificate request
-# 3. Signing the certificate request 
-# 4. [Optional] One can combine the cert and private key into a single
-#    file and also delete the certificate request
-
-$MKDIR -p $CERTS_DIR
-$MKDIR -p $KEYS_DIR
-$MKDIR -p $COMBO_DIR
-
-echo &quot;Generating self-signed CA certificate (RSA)&quot;
-echo &quot;===========================================&quot;
-
-$OPENSSL_CMD req $OPENSSL_CNF -nodes -subj &quot;$TEST_CA_DN&quot; \
-    -keyout $KEYS_DIR/$TEST_CA_FILE.key.pem \
-    -newkey rsa:1024 -new \
-    -out $CERTS_DIR/$TEST_CA_FILE.req.pem
-
-$OPENSSL_CMD x509 -req -days $DAYS \
-    -in $CERTS_DIR/$TEST_CA_FILE.req.pem \
-    -extfile $OPENSSL_DIR/apps/openssl.cnf \
-    -extensions v3_ca \
-    -signkey $KEYS_DIR/$TEST_CA_FILE.key.pem \
-    -out $CERTS_DIR/$TEST_CA_FILE.cert.pem
-
-# Display the certificate
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_CA_FILE.cert.pem -text
-
-# Place the certificate and key in a common file
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_CA_FILE.cert.pem -issuer -subject \
-	 &gt; $COMBO_DIR/$TEST_CA_FILE.pem
-$CAT $KEYS_DIR/$TEST_CA_FILE.key.pem &gt;&gt; $COMBO_DIR/$TEST_CA_FILE.pem
-
-# Remove the cert request file (no longer needed)
-$RM $CERTS_DIR/$TEST_CA_FILE.req.pem
-
-echo &quot;GENERATING A TEST SERVER CERTIFICATE (RSA)&quot;
-echo &quot;==========================================&quot;
-
-$OPENSSL_CMD req $OPENSSL_CNF -nodes -subj &quot;$TEST_SERVER_DN&quot; \
-    -keyout $KEYS_DIR/$TEST_SERVER_FILE.key.pem \
-    -newkey rsa:1024 -new \
-    -out $CERTS_DIR/$TEST_SERVER_FILE.req.pem
-
-$OPENSSL_CMD x509 -req -days $DAYS \
-    -in $CERTS_DIR/$TEST_SERVER_FILE.req.pem \
-    -CA $CERTS_DIR/$TEST_CA_FILE.cert.pem \
-    -CAkey $KEYS_DIR/$TEST_CA_FILE.key.pem \
-    -out $CERTS_DIR/$TEST_SERVER_FILE.cert.pem -CAcreateserial
-
-# Display the certificate 
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_SERVER_FILE.cert.pem -text
-
-# Place the certificate and key in a common file
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_SERVER_FILE.cert.pem -issuer -subject \
-	 &gt; $COMBO_DIR/$TEST_SERVER_FILE.pem
-$CAT $KEYS_DIR/$TEST_SERVER_FILE.key.pem &gt;&gt; $COMBO_DIR/$TEST_SERVER_FILE.pem
-
-# Remove the cert request file (no longer needed)
-$RM $CERTS_DIR/$TEST_SERVER_FILE.req.pem
-
-echo &quot;GENERATING A TEST CLIENT CERTIFICATE (RSA)&quot;
-echo &quot;==========================================&quot;
-
-$OPENSSL_CMD req $OPENSSL_CNF -nodes -subj &quot;$TEST_CLIENT_DN&quot; \
-	     -keyout $KEYS_DIR/$TEST_CLIENT_FILE.key.pem \
-	     -newkey rsa:1024 -new \
-	     -out $CERTS_DIR/$TEST_CLIENT_FILE.req.pem
-
-$OPENSSL_CMD x509 -req -days $DAYS \
-    -in $CERTS_DIR/$TEST_CLIENT_FILE.req.pem \
-    -CA $CERTS_DIR/$TEST_CA_FILE.cert.pem \
-    -CAkey $KEYS_DIR/$TEST_CA_FILE.key.pem \
-    -out $CERTS_DIR/$TEST_CLIENT_FILE.cert.pem -CAcreateserial
-
-# Display the certificate 
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_CLIENT_FILE.cert.pem -text
-
-# Place the certificate and key in a common file
-$OPENSSL_CMD x509 -in $CERTS_DIR/$TEST_CLIENT_FILE.cert.pem -issuer -subject \
-	 &gt; $COMBO_DIR/$TEST_CLIENT_FILE.pem
-$CAT $KEYS_DIR/$TEST_CLIENT_FILE.key.pem &gt;&gt; $COMBO_DIR/$TEST_CLIENT_FILE.pem
-
-# Remove the cert request file (no longer needed)
-$RM $CERTS_DIR/$TEST_CLIENT_FILE.req.pem
-
diff --git a/demos/ssltest-ecc/ssltest.sh b/demos/ssltest-ecc/ssltest.sh
deleted file mode 100755
index 923ca43..0000000
--- a/demos/ssltest-ecc/ssltest.sh
+++ /dev/null
@@ -1,188 +0,0 @@
-#! /bin/sh
-# Tests ECC cipher suites using ssltest. Requires one argument which could
-# be aecdh or ecdh-ecdsa or ecdhe-ecdsa or ecdh-rsa or ecdhe-rsa.
-# A second optional argument can be one of ssl2 ssl3 or tls1
-
-if [ &quot;$1&quot; = &quot;&quot; ]; then
-  (echo &quot;Usage: $0 test [ protocol ]&quot;
-   echo &quot;   where test is one of aecdh, ecdh-ecdsa, ecdhe-ecdsa, ecdh-rsa, ecdhe-rsa&quot;
-   echo &quot;   and protocol (optional) is one of ssl2, ssl3, tls1&quot;
-   echo &quot;Run RSAcertgen.sh, ECC-RSAcertgen.sh, ECCcertgen.sh first.&quot;
-  ) &gt;&amp;2
-  exit 1
-fi
-
-
-OPENSSL_DIR=../..
-CERTS_DIR=./Certs
-SSLTEST=$OPENSSL_DIR/test/ssltest
-# SSL protocol version to test (one of ssl2 ssl3 or tls1)&quot;
-SSLVERSION=
-
-# These don't really require any certificates
-AECDH_CIPHER_LIST=&quot;AECDH-AES256-SHA AECDH-AES128-SHA AECDH-DES-CBC3-SHA AECDH-RC4-SHA AECDH-NULL-SHA&quot;
-
-# These require ECC certificates signed with ECDSA
-# The EC public key must be authorized for key agreement.
-ECDH_ECDSA_CIPHER_LIST=&quot;ECDH-ECDSA-AES256-SHA ECDH-ECDSA-AES128-SHA ECDH-ECDSA-DES-CBC3-SHA ECDH-ECDSA-RC4-SHA ECDH-ECDSA-NULL-SHA&quot;
-
-# These require ECC certificates.
-# The EC public key must be authorized for digital signature.
-ECDHE_ECDSA_CIPHER_LIST=&quot;ECDHE-ECDSA-AES256-SHA ECDHE-ECDSA-AES128-SHA ECDHE-ECDSA-DES-CBC3-SHA ECDHE-ECDSA-RC4-SHA ECDHE-ECDSA-NULL-SHA&quot;
-
-# These require ECC certificates signed with RSA.
-# The EC public key must be authorized for key agreement.
-ECDH_RSA_CIPHER_LIST=&quot;ECDH-RSA-AES256-SHA ECDH-RSA-AES128-SHA ECDH-RSA-DES-CBC3-SHA ECDH-RSA-RC4-SHA ECDH-RSA-NULL-SHA&quot;
-
-# These require RSA certificates.
-# The RSA public key must be authorized for digital signature.
-ECDHE_RSA_CIPHER_LIST=&quot;ECDHE-RSA-AES256-SHA ECDHE-RSA-AES128-SHA ECDHE-RSA-DES-CBC3-SHA ECDHE-RSA-RC4-SHA ECDHE-RSA-NULL-SHA&quot;
-
-# List of Elliptic curves over which we wish to test generation of
-# ephemeral ECDH keys when using AECDH or ECDHE ciphers
-# NOTE: secp192r1 = prime192v1 and secp256r1 = prime256v1
-#ELLIPTIC_CURVE_LIST=&quot;secp112r1 sect113r2 secp128r1 sect131r1 secp160k1 sect163r2 wap-wsg-idm-ecid-wtls7 c2pnb163v3 c2pnb176v3 c2tnb191v3 secp192r1 prime192v3 sect193r2 secp224r1 wap-wsg-idm-ecid-wtls10 sect239k1 prime239v2 secp256r1 prime256v1 sect283k1 secp384r1 sect409r1 secp521r1 sect571r1&quot;
-ELLIPTIC_CURVE_LIST=&quot;sect163k1 sect163r1 sect163r2 sect193r1 sect193r2 sect233k1 sect233r1 sect239k1 sect283k1 sect283r1 sect409k1 sect409r1 sect571k1 sect571r1 secp160k1 secp160r1 secp160r2 secp192k1 prime192v1 secp224k1 secp224r1 secp256k1 prime256v1 secp384r1 secp521r1&quot;
-
-DEFAULT_CURVE=&quot;sect163r2&quot;
-
-if [ &quot;$2&quot; = &quot;&quot; ]; then
-    if [ &quot;$SSL_VERSION&quot; = &quot;&quot; ]; then
-	SSL_VERSION=&quot;&quot;
-    else
-	SSL_VERSION=&quot;-$SSL_VERSION&quot;
-    fi
-else
-    SSL_VERSION=&quot;-$2&quot;
-fi
-
-#==============================================================
-# Anonymous cipher suites do not require key or certificate files
-# but ssltest expects a cert file and complains if it can't
-# open the default one.
-SERVER_PEM=$OPENSSL_DIR/apps/server.pem
-
-if [ &quot;$1&quot; = &quot;aecdh&quot; ]; then
-for cipher in $AECDH_CIPHER_LIST
-do
-    echo &quot;Testing $cipher&quot;
-    $SSLTEST $SSL_VERSION -cert $SERVER_PEM -cipher $cipher 
-done
-#--------------------------------------------------------------
-for curve in $ELLIPTIC_CURVE_LIST
-do
-    echo &quot;Testing AECDH-NULL-SHA (with $curve)&quot;
-    $SSLTEST $SSL_VERSION -cert $SERVER_PEM \
-	-named_curve $curve -cipher AECDH-NULL-SHA
-done
-
-for curve in $ELLIPTIC_CURVE_LIST
-do
-    echo &quot;Testing AECDH-RC4-SHA (with $curve)&quot;
-    $SSLTEST $SSL_VERSION -cert $SERVER_PEM \
-	-named_curve $curve -cipher AECDH-RC4-SHA
-done
-fi
-
-#==============================================================
-# Both ECDH-ECDSA and ECDHE-ECDSA cipher suites require 
-# the server to have an ECC certificate signed with ECDSA.
-CA_PEM=$CERTS_DIR/secp160r1TestCA.pem
-SERVER_PEM=$CERTS_DIR/secp160r2TestServer.pem
-CLIENT_PEM=$CERTS_DIR/secp160r2TestClient.pem
-
-if [ &quot;$1&quot; = &quot;ecdh-ecdsa&quot; ]; then
-for cipher in $ECDH_ECDSA_CIPHER_LIST
-do
-    echo &quot;Testing $cipher (with server authentication)&quot;
-    $SSLTEST $SSL_VERSION -CAfile $CA_PEM \
-	-cert $SERVER_PEM -server_auth \
-	-cipher $cipher
-
-    echo &quot;Testing $cipher (with server and client authentication)&quot;
-    $SSLTEST $SSL_VERSION -CAfile $CA_PEM \
-	-cert $SERVER_PEM -server_auth \
-	-c_cert $CLIENT_PEM -client_auth \
-	-cipher $cipher
-done
-fi
-
-#==============================================================
-if [ &quot;$1&quot; = &quot;ecdhe-ecdsa&quot; ]; then
-for cipher in $ECDHE_ECDSA_CIPHER_LIST
-do
-    echo &quot;Testing $cipher (with server authentication)&quot;
-    $SSLTEST $SSL_VERSION -CAfile $CA_PEM \
-	-cert $SERVER_PEM -server_auth \
-	-cipher $cipher -named_curve $DEFAULT_CURVE
-
-    echo &quot;Testing $cipher (with server and client authentication)&quot;
-    $SSLTEST $SSL_VERSION -CAfile $CA_PEM \
-	-cert $SERVER_PEM -server_auth \
-	-c_cert $CLIENT_PEM -client_auth \
-	-cipher $cipher -named_curve $DEFAULT_CURVE
-done
-
-#--------------------------------------------------------------
-for curve in $ELLIPTIC_CURVE_LIST
-do
-    echo &quot;Testing ECDHE-ECDSA-AES128-SHA (2-way auth with $curve)&quot;
-    $SSLTEST $SSL_VERSION -CAfile $CA_PEM \
-	-cert $SERVER_PEM -server_auth \
-	-c_cert $CLIENT_PEM -client_auth \
-	-cipher ECDHE-ECDSA-AES128-SHA -named_curve $curve 
-done
-fi
-
-#==============================================================
-# ECDH-RSA cipher suites require the server to have an ECC
-# certificate signed with RSA.
-CA_PEM=$CERTS_DIR/rsa1024TestCA.pem
-SERVER_PEM=$CERTS_DIR/sect163r1-rsaTestServer.pem
-CLIENT_PEM=$CERTS_DIR/sect163r1-rsaTestClient.pem
-
-if [ &quot;$1&quot; = &quot;ecdh-rsa&quot; ]; then
-for cipher in $ECDH_RSA_CIPHER_LIST
-do
-    echo &quot;Testing $cipher (with server authentication)&quot;
-    $SSLTEST $SSL_VERSION -CAfile $CA_PEM \
-	-cert $SERVER_PEM -server_auth \
-	-cipher $cipher
-
-    echo &quot;Testing $cipher (with server and client authentication)&quot;
-    $SSLTEST $SSL_VERSION -CAfile $CA_PEM \
-	-cert $SERVER_PEM -server_auth \
-	-c_cert $CLIENT_PEM -client_auth \
-	-cipher $cipher
-done
-fi
-
-#==============================================================
-# ECDHE-RSA cipher suites require the server to have an RSA cert.
-CA_PEM=$CERTS_DIR/rsa1024TestCA.pem
-SERVER_PEM=$CERTS_DIR/rsa1024TestServer.pem
-CLIENT_PEM=$CERTS_DIR/rsa1024TestClient.pem
-
-if [ &quot;$1&quot; = &quot;ecdhe-rsa&quot; ]; then
-for cipher in $ECDHE_RSA_CIPHER_LIST
-do
-    echo &quot;Testing $cipher (with server authentication)&quot;
-    echo $SSLTEST $SSL_VERSION -CAfile $CA_PEM \
-	-cert $SERVER_PEM -server_auth \
-	-cipher $cipher -named_curve $DEFAULT_CURVE
-    $SSLTEST $SSL_VERSION -CAfile $CA_PEM \
-	-cert $SERVER_PEM -server_auth \
-	-cipher $cipher -named_curve $DEFAULT_CURVE
-
-    echo &quot;Testing $cipher (with server and client authentication)&quot;
-    $SSLTEST $SSL_VERSION -CAfile $CA_PEM \
-	-cert $SERVER_PEM -server_auth \
-	-c_cert $CLIENT_PEM -client_auth \
-	-cipher $cipher -named_curve $DEFAULT_CURVE
-done
-fi
-#==============================================================
-
-
-
-
diff --git a/demos/state_machine/Makefile.in b/demos/state_machine/Makefile.in
deleted file mode 100644
index fde4474..0000000
--- a/demos/state_machine/Makefile.in
+++ /dev/null
@@ -1,10 +0,0 @@
-CFLAGS=-I../../include -Wall -Werror -g
-
-all: state_machine
-
-state_machine: state_machine.o
-	$(CC) -o state_machine state_machine.o -L../.. -lssl -lcrypto
-
-test: state_machine
-	./state_machine 10000 ../../apps/server.pem ../../apps/server.pem
-# DO NOT DELETE THIS LINE -- make depend depends on it.
diff --git a/demos/state_machine/state_machine.c b/demos/state_machine/state_machine.c
deleted file mode 100644
index 98802a1..0000000
--- a/demos/state_machine/state_machine.c
+++ /dev/null
@@ -1,405 +0,0 @@
-/* ====================================================================
- * Copyright (c) 2000 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-/*
- * Nuron, a leader in hardware encryption technology, generously
- * sponsored the development of this demo by Ben Laurie.
- *
- * See <A HREF="http://www.nuron.com/.">http://www.nuron.com/.</A>
- */
-
-/*
- * the aim of this demo is to provide a fully working state-machine
- * style SSL implementation, i.e. one where the main loop acquires
- * some data, then converts it from or to SSL by feeding it into the
- * SSL state machine. It then does any I/O required by the state machine
- * and loops.
- *
- * In order to keep things as simple as possible, this implementation
- * listens on a TCP socket, which it expects to get an SSL connection
- * on (for example, from s_client) and from then on writes decrypted
- * data to stdout and encrypts anything arriving on stdin. Verbose
- * commentary is written to stderr.
- *
- * This implementation acts as a server, but it can also be done for a client.  */
-
-#include &lt;openssl/ssl.h&gt;
-#include &lt;assert.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;string.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;netinet/in.h&gt;
-
-/*
- * die_unless is intended to work like assert, except that it happens always,
- * even if NDEBUG is defined. Use assert as a stopgap.
- */
-
-#define die_unless(x)   assert(x)
-
-typedef struct {
-    SSL_CTX *pCtx;
-    BIO *pbioRead;
-    BIO *pbioWrite;
-    SSL *pSSL;
-} SSLStateMachine;
-
-void SSLStateMachine_print_error(SSLStateMachine * pMachine,
-                                 const char *szErr)
-{
-    unsigned long l;
-
-    fprintf(stderr, &quot;%s\n&quot;, szErr);
-    while ((l = ERR_get_error())) {
-        char buf[1024];
-
-        ERR_error_string_n(l, buf, sizeof buf);
-        fprintf(stderr, &quot;Error %lx: %s\n&quot;, l, buf);
-    }
-}
-
-SSLStateMachine *SSLStateMachine_new(const char *szCertificateFile,
-                                     const char *szKeyFile)
-{
-    SSLStateMachine *pMachine = malloc(sizeof(*pMachine));
-    int n;
-
-    die_unless(pMachine);
-
-    pMachine-&gt;pCtx = SSL_CTX_new(TLS_server_method());
-    die_unless(pMachine-&gt;pCtx);
-
-    n = SSL_CTX_use_certificate_file(pMachine-&gt;pCtx, szCertificateFile,
-                                     SSL_FILETYPE_PEM);
-    die_unless(n &gt; 0);
-
-    n = SSL_CTX_use_PrivateKey_file(pMachine-&gt;pCtx, szKeyFile,
-                                    SSL_FILETYPE_PEM);
-    die_unless(n &gt; 0);
-
-    pMachine-&gt;pSSL = SSL_new(pMachine-&gt;pCtx);
-    die_unless(pMachine-&gt;pSSL);
-
-    pMachine-&gt;pbioRead = BIO_new(BIO_s_mem());
-
-    pMachine-&gt;pbioWrite = BIO_new(BIO_s_mem());
-
-    SSL_set_bio(pMachine-&gt;pSSL, pMachine-&gt;pbioRead, pMachine-&gt;pbioWrite);
-
-    SSL_set_accept_state(pMachine-&gt;pSSL);
-
-    return pMachine;
-}
-
-void SSLStateMachine_read_inject(SSLStateMachine * pMachine,
-                                 const unsigned char *aucBuf, int nBuf)
-{
-    int n = BIO_write(pMachine-&gt;pbioRead, aucBuf, nBuf);
-    /*
-     * If it turns out this assert fails, then buffer the data here and just
-     * feed it in in churn instead. Seems to me that it should be guaranteed
-     * to succeed, though.
-     */
-    assert(n == nBuf);
-    fprintf(stderr, &quot;%d bytes of encrypted data fed to state machine\n&quot;, n);
-}
-
-int SSLStateMachine_read_extract(SSLStateMachine * pMachine,
-                                 unsigned char *aucBuf, int nBuf)
-{
-    int n;
-
-    if (!SSL_is_init_finished(pMachine-&gt;pSSL)) {
-        fprintf(stderr, &quot;Doing SSL_accept\n&quot;);
-        n = SSL_accept(pMachine-&gt;pSSL);
-        if (n == 0)
-            fprintf(stderr, &quot;SSL_accept returned zero\n&quot;);
-        if (n &lt; 0) {
-            int err;
-
-            if ((err =
-                 SSL_get_error(pMachine-&gt;pSSL, n)) == SSL_ERROR_WANT_READ) {
-                fprintf(stderr, &quot;SSL_accept wants more data\n&quot;);
-                return 0;
-            }
-
-            SSLStateMachine_print_error(pMachine, &quot;SSL_accept error&quot;);
-            exit(7);
-        }
-        return 0;
-    }
-
-    n = SSL_read(pMachine-&gt;pSSL, aucBuf, nBuf);
-    if (n &lt; 0) {
-        int err = SSL_get_error(pMachine-&gt;pSSL, n);
-
-        if (err == SSL_ERROR_WANT_READ) {
-            fprintf(stderr, &quot;SSL_read wants more data\n&quot;);
-            return 0;
-        }
-
-        SSLStateMachine_print_error(pMachine, &quot;SSL_read error&quot;);
-        exit(8);
-    }
-
-    fprintf(stderr, &quot;%d bytes of decrypted data read from state machine\n&quot;,
-            n);
-    return n;
-}
-
-int SSLStateMachine_write_can_extract(SSLStateMachine * pMachine)
-{
-    int n = BIO_pending(pMachine-&gt;pbioWrite);
-    if (n)
-        fprintf(stderr, &quot;There is encrypted data available to write\n&quot;);
-    else
-        fprintf(stderr, &quot;There is no encrypted data available to write\n&quot;);
-
-    return n;
-}
-
-int SSLStateMachine_write_extract(SSLStateMachine * pMachine,
-                                  unsigned char *aucBuf, int nBuf)
-{
-    int n;
-
-    n = BIO_read(pMachine-&gt;pbioWrite, aucBuf, nBuf);
-    fprintf(stderr, &quot;%d bytes of encrypted data read from state machine\n&quot;,
-            n);
-    return n;
-}
-
-void SSLStateMachine_write_inject(SSLStateMachine * pMachine,
-                                  const unsigned char *aucBuf, int nBuf)
-{
-    int n = SSL_write(pMachine-&gt;pSSL, aucBuf, nBuf);
-    /*
-     * If it turns out this assert fails, then buffer the data here and just
-     * feed it in in churn instead. Seems to me that it should be guaranteed
-     * to succeed, though.
-     */
-    assert(n == nBuf);
-    fprintf(stderr, &quot;%d bytes of unencrypted data fed to state machine\n&quot;, n);
-}
-
-int OpenSocket(int nPort)
-{
-    int nSocket;
-    struct sockaddr_in saServer;
-    struct sockaddr_in saClient;
-    int one = 1;
-    int nSize;
-    int nFD;
-    int nLen;
-
-    nSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
-    if (nSocket &lt; 0) {
-        perror(&quot;socket&quot;);
-        exit(1);
-    }
-
-    if (setsockopt
-        (nSocket, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;one, sizeof one) &lt; 0) {
-        perror(&quot;setsockopt&quot;);
-        exit(2);
-    }
-
-    memset(&amp;saServer, 0, sizeof(saServer));
-    saServer.sin_family = AF_INET;
-    saServer.sin_port = htons(nPort);
-    nSize = sizeof saServer;
-    if (bind(nSocket, (struct sockaddr *)&amp;saServer, nSize) &lt; 0) {
-        perror(&quot;bind&quot;);
-        exit(3);
-    }
-
-    if (listen(nSocket, 512) &lt; 0) {
-        perror(&quot;listen&quot;);
-        exit(4);
-    }
-
-    nLen = sizeof saClient;
-    nFD = accept(nSocket, (struct sockaddr *)&amp;saClient, &amp;nLen);
-    if (nFD &lt; 0) {
-        perror(&quot;accept&quot;);
-        exit(5);
-    }
-
-    fprintf(stderr, &quot;Incoming accepted on port %d\n&quot;, nPort);
-
-    return nFD;
-}
-
-int main(int argc, char **argv)
-{
-    SSLStateMachine *pMachine;
-    int nPort;
-    int nFD;
-    const char *szCertificateFile;
-    const char *szKeyFile;
-    char rbuf[1];
-    int nrbuf = 0;
-
-    if (argc != 4) {
-        fprintf(stderr, &quot;%s &lt;port&gt; &lt;certificate file&gt; &lt;key file&gt;\n&quot;, argv[0]);
-        exit(6);
-    }
-
-    nPort = atoi(argv[1]);
-    szCertificateFile = argv[2];
-    szKeyFile = argv[3];
-
-    OpenSSL_add_ssl_algorithms();
-    SSL_load_error_strings();
-
-    nFD = OpenSocket(nPort);
-
-    pMachine = SSLStateMachine_new(szCertificateFile, szKeyFile);
-
-    for (;;) {
-        fd_set rfds, wfds;
-        unsigned char buf[1024];
-        int n;
-
-        FD_ZERO(&amp;rfds);
-        FD_ZERO(&amp;wfds);
-
-        /* Select socket for input */
-        FD_SET(nFD, &amp;rfds);
-
-        /* check whether there's decrypted data */
-        if (!nrbuf)
-            nrbuf = SSLStateMachine_read_extract(pMachine, rbuf, 1);
-
-        /* if there's decrypted data, check whether we can write it */
-        if (nrbuf)
-            FD_SET(1, &amp;wfds);
-
-        /* Select socket for output */
-        if (SSLStateMachine_write_can_extract(pMachine))
-            FD_SET(nFD, &amp;wfds);
-
-        /* Select stdin for input */
-        FD_SET(0, &amp;rfds);
-
-        /* Wait for something to do something */
-        n = select(nFD + 1, &amp;rfds, &amp;wfds, NULL, NULL);
-        assert(n &gt; 0);
-
-        /* Socket is ready for input */
-        if (FD_ISSET(nFD, &amp;rfds)) {
-            n = read(nFD, buf, sizeof buf);
-            if (n == 0) {
-                fprintf(stderr, &quot;Got EOF on socket\n&quot;);
-                exit(0);
-            }
-            assert(n &gt; 0);
-
-            SSLStateMachine_read_inject(pMachine, buf, n);
-        }
-
-        /* stdout is ready for output (and hence we have some to send it) */
-        if (FD_ISSET(1, &amp;wfds)) {
-            assert(nrbuf == 1);
-            buf[0] = rbuf[0];
-            nrbuf = 0;
-
-            n = SSLStateMachine_read_extract(pMachine, buf + 1,
-                                             sizeof buf - 1);
-            if (n &lt; 0) {
-                SSLStateMachine_print_error(pMachine, &quot;read extract failed&quot;);
-                break;
-            }
-            assert(n &gt;= 0);
-            ++n;
-            if (n &gt; 0) {        /* FIXME: has to be true now */
-                int w;
-
-                w = write(1, buf, n);
-                /* FIXME: we should push back any unwritten data */
-                assert(w == n);
-            }
-        }
-
-        /*
-         * Socket is ready for output (and therefore we have output to send)
-         */
-        if (FD_ISSET(nFD, &amp;wfds)) {
-            int w;
-
-            n = SSLStateMachine_write_extract(pMachine, buf, sizeof buf);
-            assert(n &gt; 0);
-
-            w = write(nFD, buf, n);
-            /* FIXME: we should push back any unwritten data */
-            assert(w == n);
-        }
-
-        /* Stdin is ready for input */
-        if (FD_ISSET(0, &amp;rfds)) {
-            n = read(0, buf, sizeof buf);
-            if (n == 0) {
-                fprintf(stderr, &quot;Got EOF on stdin\n&quot;);
-                exit(0);
-            }
-            assert(n &gt; 0);
-
-            SSLStateMachine_write_inject(pMachine, buf, n);
-        }
-    }
-    /* not reached */
-    return 0;
-}
diff --git a/demos/threads/README b/demos/threads/README
deleted file mode 100644
index d8f358b..0000000
--- a/demos/threads/README
+++ /dev/null
@@ -1,7 +0,0 @@
-This shows how to set up the OpenSSL callbacks for use in
-multi-threaded programs.
-
-Two implementations, one for Win32 native and one for pthreads, are provided
-in th-lock.c  A test program is in mttest.c
-
-Build scripts are in pthread.sh and win32.bat
diff --git a/demos/threads/mttest.c b/demos/threads/mttest.c
deleted file mode 100644
index 797a2ca..0000000
--- a/demos/threads/mttest.c
+++ /dev/null
@@ -1,773 +0,0 @@
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-#ifdef LINUX
-# include &lt;typedefs.h&gt;
-#endif
-#ifdef OPENSSL_SYS_WIN32
-# include &lt;windows.h&gt;
-#endif
-#ifdef PTHREADS
-# include &lt;pthread.h&gt;
-#endif
-#include &lt;openssl/lhash.h&gt;
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/buffer.h&gt;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/ssl.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &lt;openssl/rand.h&gt;
-
-#define TEST_SERVER_CERT &quot;../../apps/server.pem&quot;
-#define TEST_CLIENT_CERT &quot;../../apps/client.pem&quot;
-
-#define MAX_THREAD_NUMBER       100
-
-int verify_callback(int ok, X509_STORE_CTX *xs);
-void thread_setup(void);
-void thread_cleanup(void);
-void do_threads(SSL_CTX *s_ctx, SSL_CTX *c_ctx);
-
-void win32_locking_callback(int mode, int type, const char *file, int line);
-void pthreads_locking_callback(int mode, int type, const char *file, int line);
-
-void irix_thread_id(CRYPTO_THREADID *tid);
-void pthreads_thread_id(CRYPTO_THREADID *tid);
-
-BIO *bio_err = NULL;
-BIO *bio_stdout = NULL;
-
-static char *cipher = NULL;
-int verbose = 0;
-#ifdef FIONBIO
-static int s_nbio = 0;
-#endif
-
-int thread_number = 10;
-int number_of_loops = 10;
-int reconnect = 0;
-int cache_stats = 0;
-
-static const char rnd_seed[] =
-    &quot;string to make the random number generator think it has entropy&quot;;
-
-int doit(char *ctx[4]);
-static void print_stats(BIO *bio, SSL_CTX *ctx)
-{
-    BIO_printf(bio, &quot;%4ld items in the session cache\n&quot;,
-	       SSL_CTX_sess_number(ctx));
-    BIO_printf(bio, &quot;%4d client connects (SSL_connect())\n&quot;,
-	       SSL_CTX_sess_connect(ctx));
-    BIO_printf(bio, &quot;%4d client connects that finished\n&quot;,
-	       SSL_CTX_sess_connect_good(ctx));
-    BIO_printf(bio, &quot;%4d server connects (SSL_accept())\n&quot;,
-	       SSL_CTX_sess_accept(ctx));
-    BIO_printf(bio, &quot;%4d server connects that finished\n&quot;,
-	       SSL_CTX_sess_accept_good(ctx));
-    BIO_printf(bio, &quot;%4d session cache hits\n&quot;, SSL_CTX_sess_hits(ctx));
-    BIO_printf(bio, &quot;%4d session cache misses\n&quot;, SSL_CTX_sess_misses(ctx));
-    BIO_printf(bio, &quot;%4d session cache timeouts\n&quot;, SSL_CTX_sess_timeouts(ctx));
-}
-
-static void sv_usage(void)
-{
-    BIO_printf(bio_err, &quot;usage: ssltest [args ...]\n&quot;);
-    BIO_printf(bio_err, &quot;\n&quot;);
-    BIO_printf(bio_err, &quot; -server_auth  - check server certificate\n&quot;);
-    BIO_printf(bio_err, &quot; -client_auth  - do client authentication\n&quot;);
-    BIO_printf(bio_err, &quot; -v            - more output\n&quot;);
-    BIO_printf(bio_err, &quot; -CApath arg   - PEM format directory of CA's\n&quot;);
-    BIO_printf(bio_err, &quot; -CAfile arg   - PEM format file of CA's\n&quot;);
-    BIO_printf(bio_err, &quot; -threads arg  - number of threads\n&quot;);
-    BIO_printf(bio_err, &quot; -loops arg    - number of 'connections', per thread\n&quot;);
-    BIO_printf(bio_err, &quot; -reconnect    - reuse session-id's\n&quot;);
-    BIO_printf(bio_err, &quot; -stats        - server session-id cache stats\n&quot;);
-    BIO_printf(bio_err, &quot; -cert arg     - server certificate/key\n&quot;);
-    BIO_printf(bio_err, &quot; -ccert arg    - client certificate/key\n&quot;);
-    BIO_printf(bio_err, &quot; -ssl3         - just SSLv3n\n&quot;);
-}
-
-int main(int argc, char *argv[])
-{
-    char *CApath = NULL, *CAfile = NULL;
-    int badop = 0;
-    int ret = 1;
-    int client_auth = 0;
-    int server_auth = 0;
-    SSL_CTX *s_ctx = NULL;
-    SSL_CTX *c_ctx = NULL;
-    char *scert = TEST_SERVER_CERT;
-    char *ccert = TEST_CLIENT_CERT;
-    const SSL_METHOD *ssl_method = TLS_method();
-
-    RAND_seed(rnd_seed, sizeof rnd_seed);
-
-    if (bio_err == NULL)
-        bio_err = BIO_new_fd(2, BIO_NOCLOSE);
-    if (bio_stdout == NULL)
-        bio_stdout = BIO_new_fd(1, BIO_NOCLOSE);
-    argc--;
-    argv++;
-
-    while (argc &gt;= 1) {
-        if (strcmp(*argv, &quot;-server_auth&quot;) == 0)
-            server_auth = 1;
-        else if (strcmp(*argv, &quot;-client_auth&quot;) == 0)
-            client_auth = 1;
-        else if (strcmp(*argv, &quot;-reconnect&quot;) == 0)
-            reconnect = 1;
-        else if (strcmp(*argv, &quot;-stats&quot;) == 0)
-            cache_stats = 1;
-        else if (strcmp(*argv, &quot;-ssl3&quot;) == 0)
-            ssl_method = SSLv3_method();
-        else if (strcmp(*argv, &quot;-CApath&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            CApath = *(++argv);
-        } else if (strcmp(*argv, &quot;-CAfile&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            CAfile = *(++argv);
-        } else if (strcmp(*argv, &quot;-cert&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            scert = *(++argv);
-        } else if (strcmp(*argv, &quot;-ccert&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            ccert = *(++argv);
-        } else if (strcmp(*argv, &quot;-threads&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            thread_number = atoi(*(++argv));
-            if (thread_number == 0)
-                thread_number = 1;
-            if (thread_number &gt; MAX_THREAD_NUMBER)
-                thread_number = MAX_THREAD_NUMBER;
-        } else if (strcmp(*argv, &quot;-loops&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            number_of_loops = atoi(*(++argv));
-            if (number_of_loops == 0)
-                number_of_loops = 1;
-        } else {
-            BIO_printf(bio_err, &quot;unknown option %s\n&quot;, *argv);
-            badop = 1;
-            break;
-        }
-        argc--;
-        argv++;
-    }
-    if (badop) {
- bad:
-        sv_usage();
-        goto end;
-    }
-
-    if (cipher == NULL &amp;&amp; OPENSSL_issetugid() == 0)
-        cipher = getenv(&quot;SSL_CIPHER&quot;);
-
-    SSL_load_error_strings();
-    OpenSSL_add_ssl_algorithms();
-
-    c_ctx = SSL_CTX_new(ssl_method);
-    s_ctx = SSL_CTX_new(ssl_method);
-    if ((c_ctx == NULL) || (s_ctx == NULL)) {
-        ERR_print_errors(bio_err);
-        goto end;
-    }
-
-    SSL_CTX_set_session_cache_mode(s_ctx,
-                                   SSL_SESS_CACHE_NO_AUTO_CLEAR |
-                                   SSL_SESS_CACHE_SERVER);
-    SSL_CTX_set_session_cache_mode(c_ctx,
-                                   SSL_SESS_CACHE_NO_AUTO_CLEAR |
-                                   SSL_SESS_CACHE_SERVER);
-
-    if (!SSL_CTX_use_certificate_file(s_ctx, scert, SSL_FILETYPE_PEM)) {
-        BIO_printf(bio_err, &quot;SSL_CTX_use_certificate_file (%s)\n&quot;, scert);
-        ERR_print_errors(bio_err);
-        goto end;
-    } else
-        if (!SSL_CTX_use_RSAPrivateKey_file(s_ctx, scert, SSL_FILETYPE_PEM)) {
-        BIO_printf(bio_err, &quot;SSL_CTX_use_RSAPrivateKey_file (%s)\n&quot;, scert);
-        ERR_print_errors(bio_err);
-        goto end;
-    }
-
-    if (client_auth) {
-        SSL_CTX_use_certificate_file(c_ctx, ccert, SSL_FILETYPE_PEM);
-        SSL_CTX_use_RSAPrivateKey_file(c_ctx, ccert, SSL_FILETYPE_PEM);
-    }
-
-    if ((!SSL_CTX_load_verify_locations(s_ctx, CAfile, CApath)) ||
-        (!SSL_CTX_set_default_verify_paths(s_ctx)) ||
-        (!SSL_CTX_load_verify_locations(c_ctx, CAfile, CApath)) ||
-        (!SSL_CTX_set_default_verify_paths(c_ctx))) {
-        BIO_printf(bio_err, &quot;SSL_load_verify_locations\n&quot;);
-        ERR_print_errors(bio_err);
-        goto end;
-    }
-
-    if (client_auth) {
-        BIO_printf(bio_err, &quot;client authentication\n&quot;);
-        SSL_CTX_set_verify(s_ctx,
-                           SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
-                           verify_callback);
-    }
-    if (server_auth) {
-        BIO_printf(bio_err, &quot;server authentication\n&quot;);
-        SSL_CTX_set_verify(c_ctx, SSL_VERIFY_PEER, verify_callback);
-    }
-
-    thread_setup();
-    do_threads(s_ctx, c_ctx);
-    thread_cleanup();
- end:
-
-    if (c_ctx != NULL) {
-        BIO_printf(bio_err, &quot;Client SSL_CTX stats then free it\n&quot;);
-        print_stats(bio_err, c_ctx);
-        SSL_CTX_free(c_ctx);
-    }
-    if (s_ctx != NULL) {
-        BIO_printf(bio_err, &quot;Server SSL_CTX stats then free it\n&quot;);
-        print_stats(bio_err, s_ctx);
-        if (cache_stats) {
-            BIO_printf(bio_err, &quot;-----\n&quot;);
-            lh_SSL_SESSION_stats_bio(SSL_CTX_sessions(s_ctx), bio_err);
-            BIO_printf(bio_err, &quot;-----\n&quot;);
-    /*-     lh_SSL_SESSION_node_stats_bio(SSL_CTX_sessions(s_ctx),bio_err);
-            BIO_printf(bio_err,&quot;-----\n&quot;); */
-            lh_SSL_SESSION_node_usage_stats_bio(SSL_CTX_sessions(s_ctx), bio_err);
-            BIO_printf(bio_err, &quot;-----\n&quot;);
-        }
-        SSL_CTX_free(s_ctx);
-        BIO_printf(bio_err, &quot;done free\n&quot;);
-    }
-    exit(ret);
-    return (0);
-}
-
-#define W_READ  1
-#define W_WRITE 2
-#define C_DONE  1
-#define S_DONE  2
-
-int ndoit(SSL_CTX *ssl_ctx[2])
-{
-    int i;
-    int ret;
-    char *ctx[4];
-    CRYPTO_THREADID thread_id;
-
-    ctx[0] = (char *)ssl_ctx[0];
-    ctx[1] = (char *)ssl_ctx[1];
-
-    if (reconnect) {
-        ctx[2] = (char *)SSL_new(ssl_ctx[0]);
-        ctx[3] = (char *)SSL_new(ssl_ctx[1]);
-    } else {
-        ctx[2] = NULL;
-        ctx[3] = NULL;
-    }
-
-    CRYPTO_THREADID_current(&amp;thread_id);
-    BIO_printf(bio_stdout, &quot;started thread %lu\n&quot;,
-	       CRYPTO_THREADID_hash(&amp;thread_id));
-    for (i = 0; i &lt; number_of_loops; i++) {
-/*-     BIO_printf(bio_err,&quot;%4d %2d ctx-&gt;ref (%3d,%3d)\n&quot;,
-                   CRYPTO_THREADID_hash(&amp;thread_id),i,
-                   ssl_ctx[0]-&gt;references,
-                   ssl_ctx[1]-&gt;references); */
-/*      pthread_delay_np(&amp;tm); */
-
-        ret = doit(ctx);
-        if (ret != 0) {
-            BIO_printf(bio_stdout, &quot;error[%d] %lu - %d\n&quot;,
-                       i, CRYPTO_THREADID_hash(&amp;thread_id), ret);
-            return (ret);
-        }
-    }
-    BIO_printf(bio_stdout, &quot;DONE %lu\n&quot;, CRYPTO_THREADID_hash(&amp;thread_id));
-    if (reconnect) {
-        SSL_free((SSL *)ctx[2]);
-        SSL_free((SSL *)ctx[3]);
-    }
-    return (0);
-}
-
-int doit(char *ctx[4])
-{
-    SSL_CTX *s_ctx, *c_ctx;
-    static char cbuf[200], sbuf[200];
-    SSL *c_ssl = NULL;
-    SSL *s_ssl = NULL;
-    BIO *c_to_s = NULL;
-    BIO *s_to_c = NULL;
-    BIO *c_bio = NULL;
-    BIO *s_bio = NULL;
-    int c_r, c_w, s_r, s_w;
-    int c_want, s_want;
-    int i;
-    int done = 0;
-    int c_write, s_write;
-    int do_server = 0, do_client = 0;
-
-    s_ctx = (SSL_CTX *)ctx[0];
-    c_ctx = (SSL_CTX *)ctx[1];
-
-    if (ctx[2] != NULL)
-        s_ssl = (SSL *)ctx[2];
-    else
-        s_ssl = SSL_new(s_ctx);
-
-    if (ctx[3] != NULL)
-        c_ssl = (SSL *)ctx[3];
-    else
-        c_ssl = SSL_new(c_ctx);
-
-    if ((s_ssl == NULL) || (c_ssl == NULL))
-        goto err;
-
-    c_to_s = BIO_new(BIO_s_mem());
-    s_to_c = BIO_new(BIO_s_mem());
-    if ((s_to_c == NULL) || (c_to_s == NULL))
-        goto err;
-
-    c_bio = BIO_new(BIO_f_ssl());
-    s_bio = BIO_new(BIO_f_ssl());
-    if ((c_bio == NULL) || (s_bio == NULL))
-        goto err;
-
-    SSL_set_connect_state(c_ssl);
-    SSL_set_bio(c_ssl, s_to_c, c_to_s);
-    BIO_set_ssl(c_bio, c_ssl, (ctx[2] == NULL) ? BIO_CLOSE : BIO_NOCLOSE);
-
-    SSL_set_accept_state(s_ssl);
-    SSL_set_bio(s_ssl, c_to_s, s_to_c);
-    BIO_set_ssl(s_bio, s_ssl, (ctx[3] == NULL) ? BIO_CLOSE : BIO_NOCLOSE);
-
-    c_r = 0;
-    s_r = 1;
-    c_w = 1;
-    s_w = 0;
-    c_want = W_WRITE;
-    s_want = 0;
-    c_write = 1, s_write = 0;
-
-    /* We can always do writes */
-    for (;;) {
-        do_server = 0;
-        do_client = 0;
-
-        i = (int)BIO_pending(s_bio);
-        if ((i &amp;&amp; s_r) || s_w)
-            do_server = 1;
-
-        i = (int)BIO_pending(c_bio);
-        if ((i &amp;&amp; c_r) || c_w)
-            do_client = 1;
-
-        if (do_server &amp;&amp; verbose) {
-            if (SSL_in_init(s_ssl))
-                BIO_printf(bio_stdout, &quot;server waiting in SSL_accept - %s\n&quot;,
-                           SSL_state_string_long(s_ssl));
-            else if (s_write)
-                BIO_printf(bio_stdout, &quot;server:SSL_write()\n&quot;);
-            else
-                BIO_printf(bio_stdout, &quot;server:SSL_read()\n&quot;);
-        }
-
-        if (do_client &amp;&amp; verbose) {
-            if (SSL_in_init(c_ssl))
-                BIO_printf(bio_stdout, &quot;client waiting in SSL_connect - %s\n&quot;,
-                           SSL_state_string_long(c_ssl));
-            else if (c_write)
-                BIO_printf(bio_stdout, &quot;client:SSL_write()\n&quot;);
-            else
-                BIO_printf(bio_stdout, &quot;client:SSL_read()\n&quot;);
-        }
-
-        if (!do_client &amp;&amp; !do_server) {
-            BIO_printf(bio_stdout, &quot;ERROR IN STARTUP\n&quot;);
-            break;
-        }
-        if (do_client &amp;&amp; !(done &amp; C_DONE)) {
-            if (c_write) {
-                i = BIO_write(c_bio, &quot;hello from client\n&quot;, 18);
-                if (i &lt; 0) {
-                    c_r = 0;
-                    c_w = 0;
-                    if (BIO_should_retry(c_bio)) {
-                        if (BIO_should_read(c_bio))
-                            c_r = 1;
-                        if (BIO_should_write(c_bio))
-                            c_w = 1;
-                    } else {
-                        BIO_printf(bio_err, &quot;ERROR in CLIENT\n&quot;);
-                        ERR_print_errors_fp(stderr);
-                        return (1);
-                    }
-                } else if (i == 0) {
-                    BIO_printf(bio_err, &quot;SSL CLIENT STARTUP FAILED\n&quot;);
-                    return (1);
-                } else {
-                    /* ok */
-                    c_write = 0;
-                }
-            } else {
-                i = BIO_read(c_bio, cbuf, 100);
-                if (i &lt; 0) {
-                    c_r = 0;
-                    c_w = 0;
-                    if (BIO_should_retry(c_bio)) {
-                        if (BIO_should_read(c_bio))
-                            c_r = 1;
-                        if (BIO_should_write(c_bio))
-                            c_w = 1;
-                    } else {
-                        BIO_printf(bio_err, &quot;ERROR in CLIENT\n&quot;);
-                        ERR_print_errors_fp(stderr);
-                        return (1);
-                    }
-                } else if (i == 0) {
-                    BIO_printf(bio_err, &quot;SSL CLIENT STARTUP FAILED\n&quot;);
-                    return (1);
-                } else {
-                    done |= C_DONE;
-                }
-            }
-        }
-
-        if (do_server &amp;&amp; !(done &amp; S_DONE)) {
-            if (!s_write) {
-                i = BIO_read(s_bio, sbuf, 100);
-                if (i &lt; 0) {
-                    s_r = 0;
-                    s_w = 0;
-                    if (BIO_should_retry(s_bio)) {
-                        if (BIO_should_read(s_bio))
-                            s_r = 1;
-                        if (BIO_should_write(s_bio))
-                            s_w = 1;
-                    } else {
-                        BIO_printf(bio_err, &quot;ERROR in SERVER\n&quot;);
-                        ERR_print_errors_fp(stderr);
-                        return (1);
-                    }
-                } else if (i == 0) {
-                    BIO_printf(bio_err, &quot;SSL SERVER STARTUP FAILED\n&quot;);
-                    return (1);
-                } else {
-                    s_write = 1;
-                    s_w = 1;
-                }
-            } else {
-                i = BIO_write(s_bio, &quot;hello from server\n&quot;, 18);
-                if (i &lt; 0) {
-                    s_r = 0;
-                    s_w = 0;
-                    if (BIO_should_retry(s_bio)) {
-                        if (BIO_should_read(s_bio))
-                            s_r = 1;
-                        if (BIO_should_write(s_bio))
-                            s_w = 1;
-                    } else {
-                        BIO_printf(bio_err, &quot;ERROR in SERVER\n&quot;);
-                        ERR_print_errors_fp(stderr);
-                        return (1);
-                    }
-                } else if (i == 0) {
-                    BIO_printf(bio_err, &quot;SSL SERVER STARTUP FAILED\n&quot;);
-                    return (1);
-                } else {
-                    s_write = 0;
-                    s_r = 1;
-                    done |= S_DONE;
-                }
-            }
-        }
-
-        if ((done &amp; S_DONE) &amp;&amp; (done &amp; C_DONE))
-            break;
-    }
-
-    SSL_set_shutdown(c_ssl, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
-    SSL_set_shutdown(s_ssl, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
-
- err:
-#if 0
-    /*
-     * We have to set the BIO's to NULL otherwise they will be free()ed
-     * twice.  Once when th s_ssl is SSL_free()ed and again when c_ssl is
-     * SSL_free()ed. This is a hack required because s_ssl and c_ssl are
-     * sharing the same BIO structure and SSL_set_bio() and SSL_free()
-     * automatically BIO_free non NULL entries. You should not normally do
-     * this or be required to do this
-     */
-
-    if (s_ssl != NULL) {
-        s_ssl-&gt;rbio = NULL;
-        s_ssl-&gt;wbio = NULL;
-    }
-    if (c_ssl != NULL) {
-        c_ssl-&gt;rbio = NULL;
-        c_ssl-&gt;wbio = NULL;
-    }
-
-    /* The SSL's are optionally freed in the following calls */
-    BIO_free(c_to_s);
-    BIO_free(s_to_c);
-#endif
-
-    BIO_free(c_bio);
-    BIO_free(s_bio);
-    return (0);
-}
-
-int verify_callback(int ok, X509_STORE_CTX *ctx)
-{
-    char *s, buf[256];
-
-    if (verbose) {
-        s = X509_NAME_oneline(X509_get_subject_name(ctx-&gt;current_cert),
-                              buf, 256);
-        if (s != NULL) {
-            if (ok)
-                BIO_printf(bio_err, &quot;depth=%d %s\n&quot;, ctx-&gt;error_depth, buf);
-            else
-                BIO_printf(bio_err, &quot;depth=%d error=%d %s\n&quot;,
-                        ctx-&gt;error_depth, ctx-&gt;error, buf);
-        }
-    }
-    return (ok);
-}
-
-#define THREAD_STACK_SIZE (16*1024)
-
-#ifdef OPENSSL_SYS_WIN32
-
-static HANDLE *lock_cs;
-
-void thread_setup(void)
-{
-    int i;
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(HANDLE));
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_cs[i] = CreateMutex(NULL, FALSE, NULL);
-    }
-
-    CRYPTO_set_locking_callback((void (*)(int, int, char *, int))
-                                win32_locking_callback);
-    /* id callback defined */
-}
-
-void thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++)
-        CloseHandle(lock_cs[i]);
-    OPENSSL_free(lock_cs);
-}
-
-void win32_locking_callback(int mode, int type, const char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        WaitForSingleObject(lock_cs[type], INFINITE);
-    } else {
-        ReleaseMutex(lock_cs[type]);
-    }
-}
-
-void do_threads(SSL_CTX *s_ctx, SSL_CTX *c_ctx)
-{
-    double ret;
-    SSL_CTX *ssl_ctx[2];
-    DWORD thread_id[MAX_THREAD_NUMBER];
-    HANDLE thread_handle[MAX_THREAD_NUMBER];
-    int i;
-    SYSTEMTIME start, end;
-
-    ssl_ctx[0] = s_ctx;
-    ssl_ctx[1] = c_ctx;
-
-    GetSystemTime(&amp;start);
-    for (i = 0; i &lt; thread_number; i++) {
-        thread_handle[i] = CreateThread(NULL,
-                                        THREAD_STACK_SIZE,
-                                        (LPTHREAD_START_ROUTINE) ndoit,
-                                        (void *)ssl_ctx, 0L, &amp;(thread_id[i]));
-    }
-
-    BIO_printf(bio_stdout, &quot;reaping\n&quot;);
-    for (i = 0; i &lt; thread_number; i += 50) {
-        int j;
-
-        j = (thread_number &lt; (i + 50)) ? (thread_number - i) : 50;
-
-        if (WaitForMultipleObjects(j,
-                                   (CONST HANDLE *) &amp; (thread_handle[i]),
-                                   TRUE, INFINITE)
-            == WAIT_FAILED) {
-            BIO_printf(bio_err, &quot;WaitForMultipleObjects failed:%d\n&quot;,
-                    GetLastError());
-            exit(1);
-        }
-    }
-    GetSystemTime(&amp;end);
-
-    if (start.wDayOfWeek &gt; end.wDayOfWeek)
-        end.wDayOfWeek += 7;
-    ret = (end.wDayOfWeek - start.wDayOfWeek) * 24;
-
-    ret = (ret + end.wHour - start.wHour) * 60;
-    ret = (ret + end.wMinute - start.wMinute) * 60;
-    ret = (ret + end.wSecond - start.wSecond);
-    ret += (end.wMilliseconds - start.wMilliseconds) / 1000.0;
-
-    BIO_printf(bio_stdout, &quot;win32 threads done - %.3f seconds\n&quot;, ret);
-}
-
-#endif                          /* OPENSSL_SYS_WIN32 */
-
-
-#ifdef PTHREADS
-
-static pthread_mutex_t *lock_cs;
-static long *lock_count;
-
-void thread_setup(void)
-{
-    int i;
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));
-    lock_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_count[i] = 0;
-        pthread_mutex_init(&amp;(lock_cs[i]), NULL);
-    }
-
-    CRYPTO_THREADID_set_callback(pthreads_thread_id);
-    CRYPTO_set_locking_callback(pthreads_locking_callback);
-}
-
-void thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    BIO_printf(bio_err, &quot;cleanup\n&quot;);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        pthread_mutex_destroy(&amp;(lock_cs[i]));
-        BIO_printf(bio_err, &quot;%8ld:%s\n&quot;, lock_count[i], CRYPTO_get_lock_name(i));
-    }
-    OPENSSL_free(lock_cs);
-    OPENSSL_free(lock_count);
-
-    BIO_printf(bio_err, &quot;done cleanup\n&quot;);
-}
-
-void pthreads_locking_callback(int mode, int type, const char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        pthread_mutex_lock(&amp;(lock_cs[type]));
-        lock_count[type]++;
-    } else {
-        pthread_mutex_unlock(&amp;(lock_cs[type]));
-    }
-}
-
-void do_threads(SSL_CTX *s_ctx, SSL_CTX *c_ctx)
-{
-    SSL_CTX *ssl_ctx[2];
-    pthread_t thread_ctx[MAX_THREAD_NUMBER];
-    int i;
-
-    ssl_ctx[0] = s_ctx;
-    ssl_ctx[1] = c_ctx;
-
-    for (i = 0; i &lt; thread_number; i++) {
-        pthread_create(&amp;(thread_ctx[i]), NULL,
-                       (void *(*)())ndoit, (void *)ssl_ctx);
-    }
-
-    BIO_printf(bio_stdout, &quot;reaping\n&quot;);
-    for (i = 0; i &lt; thread_number; i++) {
-        pthread_join(thread_ctx[i], NULL);
-    }
-
-#if 0 /* We can't currently find out the reference amount */
-    BIO_printf(bio_stdout, &quot;pthreads threads done (%d,%d)\n&quot;,
-               s_ctx-&gt;references, c_ctx-&gt;references);
-#else
-    BIO_printf(bio_stdout, &quot;pthreads threads done\n&quot;);
-#endif
-}
-
-void pthreads_thread_id(CRYPTO_THREADID *tid)
-{
-    CRYPTO_THREADID_set_numeric(tid, (unsigned long)pthread_self());
-}
-
-#endif                          /* PTHREADS */
diff --git a/demos/threads/pthread.sh b/demos/threads/pthread.sh
deleted file mode 100644
index ec945c4..0000000
--- a/demos/threads/pthread.sh
+++ /dev/null
@@ -1,6 +0,0 @@
-#!/bin/sh
-#
-# build using pthreads where it's already built into the system
-#
-/bin/rm -f mttest
-gcc -DPTHREADS -I../../include -g mttest.c -o mttest -L../.. -lssl -lcrypto -lpthread -ldl
diff --git a/demos/threads/th-lock.c b/demos/threads/th-lock.c
deleted file mode 100644
index dc58cb2..0000000
--- a/demos/threads/th-lock.c
+++ /dev/null
@@ -1,194 +0,0 @@
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-#ifdef LINUX
-# include &lt;typedefs.h&gt;
-#endif
-#ifdef OPENSSL_SYS_WIN32
-# include &lt;windows.h&gt;
-#endif
-#ifdef PTHREADS
-# include &lt;pthread.h&gt;
-#endif
-#include &lt;openssl/lhash.h&gt;
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/buffer.h&gt;
-#include &quot;../../e_os.h&quot;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/ssl.h&gt;
-#include &lt;openssl/err.h&gt;
-
-void CRYPTO_thread_setup(void);
-void CRYPTO_thread_cleanup(void);
-
-static void win32_locking_callback(int mode, int type, char *file, int line);
-static void pthreads_locking_callback(int mode, int type, char *file, int line);
-static unsigned long pthreads_thread_id(void);
-
-/*-
- * usage:
- * CRYPTO_thread_setup();
- * application code
- * CRYPTO_thread_cleanup();
- */
-
-#ifdef OPENSSL_SYS_WIN32
-
-static HANDLE *lock_cs;
-
-void CRYPTO_thread_setup(void)
-{
-    int i;
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(HANDLE));
-    if (!lock_cs) {
-        /* Nothing we can do about this...void function! */
-        return;
-    }
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_cs[i] = CreateMutex(NULL, FALSE, NULL);
-    }
-
-    CRYPTO_set_locking_callback((void (*)(int, int, char *, int))
-                                win32_locking_callback);
-    /* id callback defined */
-    return (1);
-}
-
-static void CRYPTO_thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++)
-        CloseHandle(lock_cs[i]);
-    OPENSSL_free(lock_cs);
-}
-
-void win32_locking_callback(int mode, int type, char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        WaitForSingleObject(lock_cs[type], INFINITE);
-    } else {
-        ReleaseMutex(lock_cs[type]);
-    }
-}
-
-#endif                          /* OPENSSL_SYS_WIN32 */
-
-/* Linux and a few others */
-#ifdef PTHREADS
-
-static pthread_mutex_t *lock_cs;
-static long *lock_count;
-
-void CRYPTO_thread_setup(void)
-{
-    int i;
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));
-    lock_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));
-    if (!lock_cs || !lock_count) {
-        /* Nothing we can do about this...void function! */
-        OPENSSL_free(lock_cs);
-        OPENSSL_free(lock_count);
-        return;
-    }
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_count[i] = 0;
-        pthread_mutex_init(&amp;(lock_cs[i]), NULL);
-    }
-
-    CRYPTO_set_id_callback((unsigned long (*)())pthreads_thread_id);
-    CRYPTO_set_locking_callback((void (*)())pthreads_locking_callback);
-}
-
-void thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        pthread_mutex_destroy(&amp;(lock_cs[i]));
-    }
-    OPENSSL_free(lock_cs);
-    OPENSSL_free(lock_count);
-}
-
-void pthreads_locking_callback(int mode, int type, char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        pthread_mutex_lock(&amp;(lock_cs[type]));
-        lock_count[type]++;
-    } else {
-        pthread_mutex_unlock(&amp;(lock_cs[type]));
-    }
-}
-
-unsigned long pthreads_thread_id(void)
-{
-    unsigned long ret;
-
-    ret = (unsigned long)pthread_self();
-    return (ret);
-}
-
-#endif                          /* PTHREADS */
diff --git a/demos/threads/win32.bat b/demos/threads/win32.bat
deleted file mode 100644
index ee6da80..0000000
--- a/demos/threads/win32.bat
+++ /dev/null
@@ -1,4 +0,0 @@
-del mttest.exe
-
-cl /O2 -DWIN32 /MD -I..\..\out mttest.c /Femttest ..\..\out\ssleay32.lib ..\..\out\libeay32.lib
-
diff --git a/demos/x509/README b/demos/x509/README
deleted file mode 100644
index b9e66e7..0000000
--- a/demos/x509/README
+++ /dev/null
@@ -1,3 +0,0 @@
-This directory contains examples of how to construct
-various X509 structures. Certificates, certificate requests
-and CRLs.
diff --git a/demos/x509/mkcert.c b/demos/x509/mkcert.c
deleted file mode 100644
index 1e62146..0000000
--- a/demos/x509/mkcert.c
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Certificate creation. Demonstrates some certificate related operations.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-
-#include &lt;openssl/pem.h&gt;
-#include &lt;openssl/conf.h&gt;
-#include &lt;openssl/x509v3.h&gt;
-#ifndef OPENSSL_NO_ENGINE
-# include &lt;openssl/engine.h&gt;
-#endif
-
-int mkcert(X509 **x509p, EVP_PKEY **pkeyp, int bits, int serial, int days);
-int add_ext(X509 *cert, int nid, char *value);
-
-int main(int argc, char **argv)
-{
-    BIO *bio_err;
-    X509 *x509 = NULL;
-    EVP_PKEY *pkey = NULL;
-
-    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
-
-    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
-
-    mkcert(&amp;x509, &amp;pkey, 512, 0, 365);
-
-    RSA_print_fp(stdout, pkey-&gt;pkey.rsa, 0);
-    X509_print_fp(stdout, x509);
-
-    PEM_write_PrivateKey(stdout, pkey, NULL, NULL, 0, NULL, NULL);
-    PEM_write_X509(stdout, x509);
-
-    X509_free(x509);
-    EVP_PKEY_free(pkey);
-
-#ifndef OPENSSL_NO_ENGINE
-    ENGINE_cleanup();
-#endif
-    CRYPTO_cleanup_all_ex_data();
-
-    CRYPTO_mem_leaks(bio_err);
-    BIO_free(bio_err);
-    return (0);
-}
-
-static void callback(int p, int n, void *arg)
-{
-    char c = 'B';
-
-    if (p == 0)
-        c = '.';
-    if (p == 1)
-        c = '+';
-    if (p == 2)
-        c = '*';
-    if (p == 3)
-        c = '\n';
-    fputc(c, stderr);
-}
-
-int mkcert(X509 **x509p, EVP_PKEY **pkeyp, int bits, int serial, int days)
-{
-    X509 *x;
-    EVP_PKEY *pk;
-    RSA *rsa;
-    X509_NAME *name = NULL;
-
-    if ((pkeyp == NULL) || (*pkeyp == NULL)) {
-        if ((pk = EVP_PKEY_new()) == NULL) {
-            abort();
-            return (0);
-        }
-    } else
-        pk = *pkeyp;
-
-    if ((x509p == NULL) || (*x509p == NULL)) {
-        if ((x = X509_new()) == NULL)
-            goto err;
-    } else
-        x = *x509p;
-
-    rsa = RSA_generate_key(bits, RSA_F4, callback, NULL);
-    if (!EVP_PKEY_assign_RSA(pk, rsa)) {
-        abort();
-        goto err;
-    }
-    rsa = NULL;
-
-    X509_set_version(x, 2);
-    ASN1_INTEGER_set(X509_get_serialNumber(x), serial);
-    X509_gmtime_adj(X509_get_notBefore(x), 0);
-    X509_gmtime_adj(X509_get_notAfter(x), (long)60 * 60 * 24 * days);
-    X509_set_pubkey(x, pk);
-
-    name = X509_get_subject_name(x);
-
-    /*
-     * This function creates and adds the entry, working out the correct
-     * string type and performing checks on its length. Normally we'd check
-     * the return value for errors...
-     */
-    X509_NAME_add_entry_by_txt(name, &quot;C&quot;, MBSTRING_ASC, &quot;UK&quot;, -1, -1, 0);
-    X509_NAME_add_entry_by_txt(name, &quot;CN&quot;,
-                               MBSTRING_ASC, &quot;OpenSSL Group&quot;, -1, -1, 0);
-
-    /*
-     * Its self signed so set the issuer name to be the same as the subject.
-     */
-    X509_set_issuer_name(x, name);
-
-    /* Add various extensions: standard extensions */
-    add_ext(x, NID_basic_constraints, &quot;critical,CA:TRUE&quot;);
-    add_ext(x, NID_key_usage, &quot;critical,keyCertSign,cRLSign&quot;);
-
-    add_ext(x, NID_subject_key_identifier, &quot;hash&quot;);
-
-    /* Some Netscape specific extensions */
-    add_ext(x, NID_netscape_cert_type, &quot;sslCA&quot;);
-
-    add_ext(x, NID_netscape_comment, &quot;example comment extension&quot;);
-
-#ifdef CUSTOM_EXT
-    /* Maybe even add our own extension based on existing */
-    {
-        int nid;
-        nid = OBJ_create(&quot;1.2.3.4&quot;, &quot;MyAlias&quot;, &quot;My Test Alias Extension&quot;);
-        X509V3_EXT_add_alias(nid, NID_netscape_comment);
-        add_ext(x, nid, &quot;example comment alias&quot;);
-    }
-#endif
-
-    if (!X509_sign(x, pk, EVP_sha1()))
-        goto err;
-
-    *x509p = x;
-    *pkeyp = pk;
-    return (1);
- err:
-    return (0);
-}
-
-/*
- * Add extension using V3 code: we can set the config file as NULL because we
- * wont reference any other sections.
- */
-
-int add_ext(X509 *cert, int nid, char *value)
-{
-    X509_EXTENSION *ex;
-    X509V3_CTX ctx;
-    /* This sets the 'context' of the extensions. */
-    /* No configuration database */
-    X509V3_set_ctx_nodb(&amp;ctx);
-    /*
-     * Issuer and subject certs: both the target since it is self signed, no
-     * request and no CRL
-     */
-    X509V3_set_ctx(&amp;ctx, cert, cert, NULL, NULL, 0);
-    ex = X509V3_EXT_conf_nid(NULL, &amp;ctx, nid, value);
-    if (!ex)
-        return 0;
-
-    X509_add_ext(cert, ex, -1);
-    X509_EXTENSION_free(ex);
-    return 1;
-}
diff --git a/demos/x509/mkreq.c b/demos/x509/mkreq.c
deleted file mode 100644
index 4d2ad79..0000000
--- a/demos/x509/mkreq.c
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Certificate request creation. Demonstrates some request related
- * operations.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-
-#include &lt;openssl/pem.h&gt;
-#include &lt;openssl/conf.h&gt;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/x509v3.h&gt;
-#ifndef OPENSSL_NO_ENGINE
-# include &lt;openssl/engine.h&gt;
-#endif
-
-int mkreq(X509_REQ **x509p, EVP_PKEY **pkeyp, int bits, int serial, int days);
-int add_ext(STACK_OF(X509_EXTENSION) *sk, int nid, char *value);
-
-int main(int argc, char **argv)
-{
-    BIO *bio_err;
-    X509_REQ *req = NULL;
-    EVP_PKEY *pkey = NULL;
-
-    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
-
-    bio_err = BIO_new_fp(stderr, BIO_NOCLOSE);
-
-    mkreq(&amp;req, &amp;pkey, 512, 0, 365);
-
-    RSA_print_fp(stdout, pkey-&gt;pkey.rsa, 0);
-    X509_REQ_print_fp(stdout, req);
-
-    PEM_write_X509_REQ(stdout, req);
-
-    X509_REQ_free(req);
-    EVP_PKEY_free(pkey);
-
-#ifndef OPENSSL_NO_ENGINE
-    ENGINE_cleanup();
-#endif
-    CRYPTO_cleanup_all_ex_data();
-
-    CRYPTO_mem_leaks(bio_err);
-    BIO_free(bio_err);
-    return (0);
-}
-
-static void callback(int p, int n, void *arg)
-{
-    char c = 'B';
-
-    if (p == 0)
-        c = '.';
-    if (p == 1)
-        c = '+';
-    if (p == 2)
-        c = '*';
-    if (p == 3)
-        c = '\n';
-    fputc(c, stderr);
-}
-
-int mkreq(X509_REQ **req, EVP_PKEY **pkeyp, int bits, int serial, int days)
-{
-    X509_REQ *x;
-    EVP_PKEY *pk;
-    RSA *rsa;
-    X509_NAME *name = NULL;
-    STACK_OF(X509_EXTENSION) *exts = NULL;
-
-    if ((pk = EVP_PKEY_new()) == NULL)
-        goto err;
-
-    if ((x = X509_REQ_new()) == NULL)
-        goto err;
-
-    rsa = RSA_generate_key(bits, RSA_F4, callback, NULL);
-    if (!EVP_PKEY_assign_RSA(pk, rsa))
-        goto err;
-
-    rsa = NULL;
-
-    X509_REQ_set_pubkey(x, pk);
-
-    name = X509_REQ_get_subject_name(x);
-
-    /*
-     * This function creates and adds the entry, working out the correct
-     * string type and performing checks on its length. Normally we'd check
-     * the return value for errors...
-     */
-    X509_NAME_add_entry_by_txt(name, &quot;C&quot;, MBSTRING_ASC, &quot;UK&quot;, -1, -1, 0);
-    X509_NAME_add_entry_by_txt(name, &quot;CN&quot;,
-                               MBSTRING_ASC, &quot;OpenSSL Group&quot;, -1, -1, 0);
-
-#ifdef REQUEST_EXTENSIONS
-    /*
-     * Certificate requests can contain extensions, which can be used to
-     * indicate the extensions the requestor would like added to their
-     * certificate. CAs might ignore them however or even choke if they are
-     * present.
-     */
-
-    /*
-     * For request extensions they are all packed in a single attribute. We
-     * save them in a STACK and add them all at once later...
-     */
-
-    exts = sk_X509_EXTENSION_new_null();
-    /* Standard extenions */
-
-    add_ext(exts, NID_key_usage, &quot;critical,digitalSignature,keyEncipherment&quot;);
-
-    /*
-     * This is a typical use for request extensions: requesting a value for
-     * subject alternative name.
-     */
-
-    add_ext(exts, NID_subject_alt_name, &quot;email:<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&quot;);
-
-    /* Some Netscape specific extensions */
-    add_ext(exts, NID_netscape_cert_type, &quot;client,email&quot;);
-
-# ifdef CUSTOM_EXT
-    /* Maybe even add our own extension based on existing */
-    {
-        int nid;
-        nid = OBJ_create(&quot;1.2.3.4&quot;, &quot;MyAlias&quot;, &quot;My Test Alias Extension&quot;);
-        X509V3_EXT_add_alias(nid, NID_netscape_comment);
-        add_ext(x, nid, &quot;example comment alias&quot;);
-    }
-# endif
-
-    /* Now we've created the extensions we add them to the request */
-
-    X509_REQ_add_extensions(x, exts);
-
-    sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);
-
-#endif
-
-    if (!X509_REQ_sign(x, pk, EVP_sha1()))
-        goto err;
-
-    *req = x;
-    *pkeyp = pk;
-    return (1);
- err:
-    return (0);
-}
-
-/*
- * Add extension using V3 code: we can set the config file as NULL because we
- * wont reference any other sections.
- */
-
-int add_ext(STACK_OF(X509_EXTENSION) *sk, int nid, char *value)
-{
-    X509_EXTENSION *ex;
-    ex = X509V3_EXT_conf_nid(NULL, NULL, nid, value);
-    if (!ex)
-        return 0;
-    sk_X509_EXTENSION_push(sk, ex);
-
-    return 1;
-}
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004996.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="004999.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4997">[ date ]</a>
              <a href="thread.html#4997">[ thread ]</a>
              <a href="subject.html#4997">[ subject ]</a>
              <a href="author.html#4997">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
