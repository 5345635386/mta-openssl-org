<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1558388615.013621.21289.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023131.html">
   <LINK REL="Next"  HREF="023136.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Dr. Paul Dale</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1558388615.013621.21289.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">pauli at openssl.org
       </A><BR>
    <I>Mon May 20 21:43:35 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="023131.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="023136.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23133">[ date ]</a>
              <a href="thread.html#23133">[ thread ]</a>
              <a href="subject.html#23133">[ subject ]</a>
              <a href="author.html#23133">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  9830e7ea42b9c0f95ea1f4b09aa2e60fa7d3115f (commit)
      from  538f38db50e4ead178025689d28bda316b15c242 (commit)


- Log -----------------------------------------------------------------
commit 9830e7ea42b9c0f95ea1f4b09aa2e60fa7d3115f
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Tue May 21 07:42:26 2019 +1000

    Params conversion tests.
    
    Add ranged checked OSSL_PARAM conversions between the native types.  A
    conversion is legal only if the given value can be exactly represented
    by the target type.
    
    Includes a test case that reads a stanza test case file and verified that param
    conversions are processed properly.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8733">https://github.com/openssl/openssl/pull/8733</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/params.c                                    | 475 +++++++++++++++++----
 doc/man3/OSSL_PARAM_TYPE.pod                       |   3 +-
 test/build.info                                    |   6 +-
 test/params_conversion_test.c                      | 334 +++++++++++++++
 ...test_provider.t =&gt; 04-test_params_conversion.t} |  17 +-
 .../native_types.txt                               | 343 +++++++++++++++
 6 files changed, 1088 insertions(+), 90 deletions(-)
 create mode 100644 test/params_conversion_test.c
 copy test/recipes/{04-test_provider.t =&gt; 04-test_params_conversion.t} (54%)
 create mode 100644 test/recipes/04-test_params_conversion_data/native_types.txt

diff --git a/crypto/params.c b/crypto/params.c
index bdb1fa9..183884f 100644
--- a/crypto/params.c
+++ b/crypto/params.c
@@ -156,12 +156,54 @@ OSSL_PARAM OSSL_PARAM_construct_ulong(const char *key, unsigned long int *buf,
 
 int OSSL_PARAM_get_int32(const OSSL_PARAM *p, int32_t *val)
 {
-    if (val == NULL || p == NULL || (p-&gt;data_type != OSSL_PARAM_INTEGER))
+    int64_t i64;
+    uint32_t u32;
+    uint64_t u64;
+    double d;
+
+    if (val == NULL || p == NULL )
         return 0;
 
-    if (p-&gt;data_size == sizeof(int32_t)) {
-        *val = *(const int32_t *)p-&gt;data;
-        return 1;
+    if (p-&gt;data_type == OSSL_PARAM_INTEGER) {
+        switch (p-&gt;data_size) {
+        case sizeof(int32_t):
+            *val = *(const int32_t *)p-&gt;data;
+            return 1;
+        case sizeof(int64_t):
+            i64 = *(const int64_t *)p-&gt;data;
+            if (i64 &gt;= INT32_MIN &amp;&amp; i64 &lt;= INT32_MAX) {
+                *val = (int32_t)i64;
+                return 1;
+            }
+            break;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_UNSIGNED_INTEGER) {
+        switch (p-&gt;data_size) {
+        case sizeof(uint32_t):
+            u32 = *(const uint32_t *)p-&gt;data;
+            if (u32 &lt;= INT32_MAX) {
+                *val = (int32_t)u32;
+                return 1;
+            }
+            break;
+        case sizeof(uint64_t):
+            u64 = *(const uint64_t *)p-&gt;data;
+            if (u64 &lt;= INT32_MAX) {
+                *val = (int32_t)u64;
+                return 1;
+            }
+            break;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_REAL) {
+        switch (p-&gt;data_size) {
+        case sizeof(double):
+            d = *(const double *)p-&gt;data;
+            if (d &gt;= INT32_MIN &amp;&amp; d &lt;= INT32_MAX &amp;&amp; d == (int32_t)d) {
+                *val = (int32_t)d;
+                return 1;
+            }
+            break;
+        }
     }
     return 0;
 }
@@ -171,19 +213,35 @@ int OSSL_PARAM_set_int32(const OSSL_PARAM *p, int32_t val)
     if (p == NULL)
         return 0;
     SET_RETURN_SIZE(p, 0);
-    if (p-&gt;data_type != OSSL_PARAM_INTEGER)
-        return 0;
-
-    SET_RETURN_SIZE(p, sizeof(int32_t)); /* Minimum expected size */
-    switch (p-&gt;data_size) {
-    case sizeof(int32_t):
-        SET_RETURN_SIZE(p, sizeof(int32_t));
-        *(int32_t *)p-&gt;data = val;
-        return 1;
-    case sizeof(int64_t):
-        SET_RETURN_SIZE(p, sizeof(int64_t));
-        *(int64_t *)p-&gt;data = (int64_t)val;
-        return 1;
+    if (p-&gt;data_type == OSSL_PARAM_INTEGER) {
+        SET_RETURN_SIZE(p, sizeof(int32_t)); /* Minimum expected size */
+        switch (p-&gt;data_size) {
+        case sizeof(int32_t):
+            *(int32_t *)p-&gt;data = val;
+            return 1;
+        case sizeof(int64_t):
+            SET_RETURN_SIZE(p, sizeof(int64_t));
+            *(int64_t *)p-&gt;data = (int64_t)val;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_UNSIGNED_INTEGER &amp;&amp; val &gt;= 0) {
+        SET_RETURN_SIZE(p, sizeof(uint32_t)); /* Minimum expected size */
+        switch (p-&gt;data_size) {
+        case sizeof(uint32_t):
+            *(uint32_t *)p-&gt;data = (uint32_t)val;
+            return 1;
+        case sizeof(uint64_t):
+            SET_RETURN_SIZE(p, sizeof(uint64_t));
+            *(uint64_t *)p-&gt;data = (uint64_t)val;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_REAL) {
+        SET_RETURN_SIZE(p, sizeof(double));
+        switch (p-&gt;data_size) {
+        case sizeof(double):
+            *(double *)p-&gt;data = (double)val;
+            return 1;
+        }
     }
     return 0;
 }
@@ -197,35 +255,96 @@ OSSL_PARAM OSSL_PARAM_construct_int32(const char *key, int32_t *buf,
 
 int OSSL_PARAM_get_uint32(const OSSL_PARAM *p, uint32_t *val)
 {
-    if (val == NULL
-        || p == NULL
-        || (p-&gt;data_type != OSSL_PARAM_UNSIGNED_INTEGER))
+    int32_t i32;
+    int64_t i64;
+    uint64_t u64;
+    double d;
+
+    if (val == NULL || p == NULL)
         return 0;
 
-    if (p-&gt;data_size == sizeof(uint32_t)) {
-        *val = *(const uint32_t *)p-&gt;data;
-        return 1;
+    if (p-&gt;data_type == OSSL_PARAM_UNSIGNED_INTEGER) {
+        switch (p-&gt;data_size) {
+        case sizeof(uint32_t):
+            *val = *(const uint32_t *)p-&gt;data;
+            return 1;
+        case sizeof(uint64_t):
+            u64 = *(const uint64_t *)p-&gt;data;
+            if (u64 &lt;= UINT32_MAX) {
+                *val = (uint32_t)u64;
+                return 1;
+            }
+            break;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_INTEGER) {
+        switch (p-&gt;data_size) {
+        case sizeof(int32_t):
+            i32 = *(const int32_t *)p-&gt;data;
+            if (i32 &gt;= 0) {
+                *val = i32;
+                return 1;
+            }
+            break;
+        case sizeof(int64_t):
+            i64 = *(const int64_t *)p-&gt;data;
+            if (i64 &gt;= 0 &amp;&amp; i64 &lt;= UINT32_MAX) {
+                *val = (uint32_t)i64;
+                return 1;
+            }
+            break;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_REAL) {
+        switch (p-&gt;data_size) {
+        case sizeof(double):
+            d = *(const double *)p-&gt;data;
+            if (d &gt;= 0 &amp;&amp; d &lt;= UINT32_MAX &amp;&amp; d == (uint32_t)d) {
+                *val = (uint32_t)d;
+                return 1;
+            }
+            break;
+        }
     }
     return 0;
 }
 
 int OSSL_PARAM_set_uint32(const OSSL_PARAM *p, uint32_t val)
 {
-    if (p == NULL) return 0;
-    SET_RETURN_SIZE(p, 0);
-    if (p-&gt;data_type != OSSL_PARAM_UNSIGNED_INTEGER)
+    if (p == NULL)
         return 0;
+    SET_RETURN_SIZE(p, 0);
 
-    SET_RETURN_SIZE(p, sizeof(uint32_t)); /* Minimum expected size */
-    switch (p-&gt;data_size) {
-    case sizeof(uint32_t):
-        SET_RETURN_SIZE(p, sizeof(uint32_t));
-        *(uint32_t *)p-&gt;data = val;
-        return 1;
-    case sizeof(uint64_t):
-        SET_RETURN_SIZE(p, sizeof(uint64_t));
-        *(uint64_t *)p-&gt;data = (uint64_t)val;
-        return 1;
+    if (p-&gt;data_type == OSSL_PARAM_UNSIGNED_INTEGER) {
+        SET_RETURN_SIZE(p, sizeof(uint32_t)); /* Minimum expected size */
+        switch (p-&gt;data_size) {
+        case sizeof(uint32_t):
+            *(uint32_t *)p-&gt;data = val;
+            return 1;
+        case sizeof(uint64_t):
+            SET_RETURN_SIZE(p, sizeof(uint64_t));
+            *(uint64_t *)p-&gt;data = val;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_INTEGER) {
+        SET_RETURN_SIZE(p, sizeof(int32_t)); /* Minimum expected size */
+        switch (p-&gt;data_size) {
+        case sizeof(int32_t):
+            if (val &lt;= INT32_MAX) {
+                *(int32_t *)p-&gt;data = (int32_t)val;
+                return 1;
+            }
+            break;
+        case sizeof(int64_t):
+            SET_RETURN_SIZE(p, sizeof(int64_t));
+            *(int64_t *)p-&gt;data = (int64_t)val;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_REAL) {
+        SET_RETURN_SIZE(p, sizeof(double));
+        switch (p-&gt;data_size) {
+        case sizeof(double):
+            *(double *)p-&gt;data = (double)val;
+            return 1;
+        }
     }
     return 0;
 }
@@ -239,34 +358,94 @@ OSSL_PARAM OSSL_PARAM_construct_uint32(const char *key, uint32_t *buf,
 
 int OSSL_PARAM_get_int64(const OSSL_PARAM *p, int64_t *val)
 {
-    if (val == NULL || p == NULL || (p-&gt;data_type != OSSL_PARAM_INTEGER))
+    uint64_t u64;
+    double d;
+
+    if (val == NULL || p == NULL )
         return 0;
 
-    switch (p-&gt;data_size) {
-    case sizeof(int32_t):
-        *val = (int64_t)*(const int32_t *)p-&gt;data;
-        return 1;
-    case sizeof(int64_t):
-        *val = *(const int64_t *)p-&gt;data;
-        return 1;
+    if (p-&gt;data_type == OSSL_PARAM_INTEGER) {
+        switch (p-&gt;data_size) {
+        case sizeof(int32_t):
+            *val = *(const int32_t *)p-&gt;data;
+            return 1;
+        case sizeof(int64_t):
+            *val = *(const int64_t *)p-&gt;data;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_UNSIGNED_INTEGER) {
+        switch (p-&gt;data_size) {
+        case sizeof(uint32_t):
+            *val = *(const uint32_t *)p-&gt;data;
+            return 1;
+        case sizeof(uint64_t):
+            u64 = *(const uint64_t *)p-&gt;data;
+            if (u64 &lt;= INT64_MAX) {
+                *val = (int64_t)u64;
+                return 1;
+            }
+            break;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_REAL) {
+        switch (p-&gt;data_size) {
+        case sizeof(double):
+            d = *(const double *)p-&gt;data;
+            if (d &gt;= INT64_MIN &amp;&amp; d &lt;= INT64_MAX &amp;&amp; d == (int64_t)d) {
+                *val = (int64_t)d;
+                return 1;
+            }
+            break;
+        }
     }
     return 0;
 }
 
 int OSSL_PARAM_set_int64(const OSSL_PARAM *p, int64_t val)
 {
+    uint64_t u64;
+
     if (p == NULL)
         return 0;
     SET_RETURN_SIZE(p, 0);
-    if (p-&gt;data_type != OSSL_PARAM_INTEGER)
-        return 0;
-
-    SET_RETURN_SIZE(p, sizeof(int64_t)); /* Minimum expected size */
-    switch (p-&gt;data_size) {
-    case sizeof(int64_t):
-        SET_RETURN_SIZE(p, sizeof(int64_t));
-        *(int64_t *)p-&gt;data = val;
-        return 1;
+    if (p-&gt;data_type == OSSL_PARAM_INTEGER) {
+        SET_RETURN_SIZE(p, sizeof(int64_t)); /* Expected size */
+        switch (p-&gt;data_size) {
+        case sizeof(int32_t):
+            if (val &gt;= INT32_MIN &amp;&amp; val &lt;= INT32_MAX) {
+                SET_RETURN_SIZE(p, sizeof(int32_t));
+                *(int32_t *)p-&gt;data = (int32_t)val;
+                return 1;
+            }
+            break;
+        case sizeof(int64_t):
+            *(int64_t *)p-&gt;data = val;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_UNSIGNED_INTEGER &amp;&amp; val &gt;= 0) {
+        SET_RETURN_SIZE(p, sizeof(uint64_t)); /* Expected size */
+        switch (p-&gt;data_size) {
+        case sizeof(uint32_t):
+            if (val &lt;= UINT32_MAX) {
+                SET_RETURN_SIZE(p, sizeof(uint32_t));
+                *(uint32_t *)p-&gt;data = (uint32_t)val;
+                return 1;
+            }
+            break;
+        case sizeof(uint64_t):
+            *(uint64_t *)p-&gt;data = (uint64_t)val;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_REAL) {
+        SET_RETURN_SIZE(p, sizeof(double));
+        switch (p-&gt;data_size) {
+        case sizeof(double):
+            u64 = val &lt; 0 ? -val : val;
+            if ((u64 &gt;&gt; 53) == 0) { /* 53 significant bits in the mantissa */
+                *(double *)p-&gt;data = (double)val;
+                return 1;
+            }
+            break;
+        }
     }
     return 0;
 }
@@ -280,18 +459,49 @@ OSSL_PARAM OSSL_PARAM_construct_int64(const char *key, int64_t *buf,
 
 int OSSL_PARAM_get_uint64(const OSSL_PARAM *p, uint64_t *val)
 {
-    if (val == NULL
-        || p == NULL
-        || (p-&gt;data_type != OSSL_PARAM_UNSIGNED_INTEGER))
+    int32_t i32;
+    int64_t i64;
+    double d;
+
+    if (val == NULL || p == NULL)
         return 0;
 
-    switch (p-&gt;data_size) {
-    case sizeof(uint32_t):
-        *val = (uint64_t)*(const uint32_t *)p-&gt;data;
-        return 1;
-    case sizeof(uint64_t):
-        *val = *(const uint64_t *)p-&gt;data;
-        return 1;
+    if (p-&gt;data_type == OSSL_PARAM_UNSIGNED_INTEGER) {
+        switch (p-&gt;data_size) {
+        case sizeof(uint32_t):
+            *val = *(const uint32_t *)p-&gt;data;
+            return 1;
+        case sizeof(uint64_t):
+            *val = *(const uint64_t *)p-&gt;data;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_INTEGER) {
+        switch (p-&gt;data_size) {
+        case sizeof(int32_t):
+            i32 = *(const int32_t *)p-&gt;data;
+            if (i32 &gt;= 0) {
+                *val = (uint64_t)i32;
+                return 1;
+            }
+            break;
+        case sizeof(int64_t):
+            i64 = *(const int64_t *)p-&gt;data;
+            if (i64 &gt;= 0) {
+                *val = (uint64_t)i64;
+                return 1;
+            }
+            break;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_REAL) {
+        switch (p-&gt;data_size) {
+        case sizeof(double):
+            d = *(const double *)p-&gt;data;
+            if (d &gt;= 0 &amp;&amp; d &lt;= INT64_MAX &amp;&amp; d == (uint64_t)d) {
+                *val = (uint64_t)d;
+                return 1;
+            }
+            break;
+        }
     }
     return 0;
 }
@@ -301,15 +511,48 @@ int OSSL_PARAM_set_uint64(const OSSL_PARAM *p, uint64_t val)
     if (p == NULL)
         return 0;
     SET_RETURN_SIZE(p, 0);
-    if (p-&gt;data_type != OSSL_PARAM_UNSIGNED_INTEGER)
-        return 0;
 
-    SET_RETURN_SIZE(p, sizeof(uint64_t)); /* Minimum expected size */
-    switch (p-&gt;data_size) {
-    case sizeof(uint64_t):
-        SET_RETURN_SIZE(p, sizeof(uint64_t));
-        *(uint64_t *)p-&gt;data = val;
-        return 1;
+    if (p-&gt;data_type == OSSL_PARAM_UNSIGNED_INTEGER) {
+        SET_RETURN_SIZE(p, sizeof(uint64_t)); /* Expected size */
+        switch (p-&gt;data_size) {
+        case sizeof(uint32_t):
+            if (val &lt;= UINT32_MAX) {
+                SET_RETURN_SIZE(p, sizeof(uint32_t));
+                *(uint32_t *)p-&gt;data = (uint32_t)val;
+                return 1;
+            }
+            break;
+        case sizeof(uint64_t):
+            *(uint64_t *)p-&gt;data = val;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_INTEGER) {
+        SET_RETURN_SIZE(p, sizeof(int64_t)); /* Expected size */
+        switch (p-&gt;data_size) {
+        case sizeof(int32_t):
+            if (val &lt;= INT32_MAX) {
+                SET_RETURN_SIZE(p, sizeof(int32_t));
+                *(int32_t *)p-&gt;data = (int32_t)val;
+                return 1;
+            }
+            break;
+        case sizeof(int64_t):
+            if (val &lt;= INT64_MAX) {
+                *(int64_t *)p-&gt;data = (int64_t)val;
+                return 1;
+            }
+            break;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_REAL) {
+        SET_RETURN_SIZE(p, sizeof(double));
+        switch (p-&gt;data_size) {
+        case sizeof(double):
+            if ((val &gt;&gt; 53) == 0) { /* 53 significant bits in the mantissa */
+                *(double *)p-&gt;data = (double)val;
+                return 1;
+            }
+            break;
+        }
     }
     return 0;
 }
@@ -402,13 +645,45 @@ OSSL_PARAM OSSL_PARAM_construct_BN(const char *key, unsigned char *buf,
 
 int OSSL_PARAM_get_double(const OSSL_PARAM *p, double *val)
 {
-    if (val == NULL || p == NULL || p-&gt;data_type != OSSL_PARAM_REAL)
+    int64_t i64;
+    uint64_t u64;
+
+    if (val == NULL || p == NULL)
         return 0;
 
-    switch (p-&gt;data_size) {
-    case sizeof(double):
-        *val = *(const double *)p-&gt;data;
-        return 1;
+    if (p-&gt;data_type == OSSL_PARAM_REAL) {
+        switch (p-&gt;data_size) {
+        case sizeof(double):
+            *val = *(const double *)p-&gt;data;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_UNSIGNED_INTEGER) {
+        switch (p-&gt;data_size) {
+        case sizeof(uint32_t):
+            *val = *(const uint32_t *)p-&gt;data;
+            return 1;
+        case sizeof(uint64_t):
+            u64 = *(const uint64_t *)p-&gt;data;
+            if ((u64 &gt;&gt; 53) == 0) { /* 53 significant bits in the mantissa */
+                *val = (double)u64;
+                return 1;
+            }
+            break;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_INTEGER) {
+        switch (p-&gt;data_size) {
+        case sizeof(int32_t):
+            *val = *(const int32_t *)p-&gt;data;
+            return 1;
+        case sizeof(int64_t):
+            i64 = *(const int64_t *)p-&gt;data;
+            u64 = i64 &lt; 0 ? -i64 : i64;
+            if ((u64 &gt;&gt; 53) == 0) { /* 53 significant bits in the mantissa */
+                *val = 0.0 + i64;
+                return 1;
+            }
+            break;
+        }
     }
     return 0;
 }
@@ -418,14 +693,50 @@ int OSSL_PARAM_set_double(const OSSL_PARAM *p, double val)
     if (p == NULL)
         return 0;
     SET_RETURN_SIZE(p, 0);
-    if (p-&gt;data_type != OSSL_PARAM_REAL)
-        return 0;
 
-    switch (p-&gt;data_size) {
-    case sizeof(double):
+    if (p-&gt;data_type == OSSL_PARAM_REAL) {
         SET_RETURN_SIZE(p, sizeof(double));
-        *(double *)p-&gt;data = val;
-        return 1;
+        switch (p-&gt;data_size) {
+        case sizeof(double):
+            *(double *)p-&gt;data = val;
+            return 1;
+        }
+    } else if (p-&gt;data_type == OSSL_PARAM_UNSIGNED_INTEGER
+               &amp;&amp; val == (uintmax_t)val) {
+        SET_RETURN_SIZE(p, sizeof(double));
+        switch (p-&gt;data_size) {
+        case sizeof(uint32_t):
+            if (val &gt;= 0 &amp;&amp; val &lt;= UINT32_MAX) {
+                SET_RETURN_SIZE(p, sizeof(uint32_t));
+                *(uint32_t *)p-&gt;data = (uint32_t)val;
+                return 1;
+            }
+            break;
+        case sizeof(uint64_t):
+            if (val &gt;= 0 &amp;&amp; val &lt;= UINT64_MAX) {
+                SET_RETURN_SIZE(p, sizeof(uint64_t));
+                *(uint64_t *)p-&gt;data = (uint64_t)val;
+                return 1;
+            }
+            break;            }
+    } else if (p-&gt;data_type == OSSL_PARAM_INTEGER &amp;&amp; val == (intmax_t)val) {
+        SET_RETURN_SIZE(p, sizeof(double));
+        switch (p-&gt;data_size) {
+        case sizeof(int32_t):
+            if (val &gt;= INT32_MIN &amp;&amp; val &lt;= INT32_MAX) {
+                SET_RETURN_SIZE(p, sizeof(int32_t));
+                *(int32_t *)p-&gt;data = (int32_t)val;
+                return 1;
+            }
+            break;
+        case sizeof(int64_t):
+            if (val &gt;= INT64_MIN &amp;&amp; val &lt;= INT64_MAX) {
+                SET_RETURN_SIZE(p, sizeof(int64_t));
+                *(int64_t *)p-&gt;data = (int64_t)val;
+                return 1;
+            }
+            break;
+        }
     }
     return 0;
 }
diff --git a/doc/man3/OSSL_PARAM_TYPE.pod b/doc/man3/OSSL_PARAM_TYPE.pod
index 4585f25..1b750b2 100644
--- a/doc/man3/OSSL_PARAM_TYPE.pod
+++ b/doc/man3/OSSL_PARAM_TYPE.pod
@@ -250,7 +250,8 @@ All other functions return B&lt;1&gt; on success and B&lt;0&gt; on failure.
 
 =head1 NOTES
 
-Integral types will be widened and sign extended as required.
+Native types will be converted as required only if the value is exactly
+representable by the target type or parameter.
 Apart from that, the functions must be used appropriately for the
 expected type of the parameter.
 
diff --git a/test/build.info b/test/build.info
index 2800c71..5d8448f 100644
--- a/test/build.info
+++ b/test/build.info
@@ -34,7 +34,7 @@ IF[{- !$disabled{tests} -}]
           bftest ssltest_old dsatest dsa_no_digest_size_test exptest rsa_test \
           evp_test evp_extra_test igetest v3nametest v3ext \
           crltest danetest bad_dtls_test lhash_test sparse_array_test \
-          conf_include_test params_api_test \
+          conf_include_test params_api_test params_conversion_test \
           constant_time_test verify_extra_test clienthellotest \
           packettest asynctest secmemtest srptest memleaktest stack_test \
           dtlsv1listentest ct_test threadstest afalgtest d2i_test \
@@ -314,6 +314,10 @@ IF[{- !$disabled{tests} -}]
   INCLUDE[params_api_test]=../include ../apps/include
   DEPEND[params_api_test]=../libcrypto libtestutil.a
 
+  SOURCE[params_conversion_test]=params_conversion_test.c
+  INCLUDE[params_conversion_test]=../include ../apps/include
+  DEPEND[params_conversion_test]=../libcrypto libtestutil.a
+
   SOURCE[sslapitest]=sslapitest.c ssltestlib.c
   INCLUDE[sslapitest]=../include ../apps/include ..
   DEPEND[sslapitest]=../libcrypto ../libssl libtestutil.a
diff --git a/test/params_conversion_test.c b/test/params_conversion_test.c
new file mode 100644
index 0000000..96d0aaa
--- /dev/null
+++ b/test/params_conversion_test.c
@@ -0,0 +1,334 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright (c) 2019, Oracle and/or its affiliates.  All rights reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;string.h&gt;
+#include &lt;inttypes.h&gt;
+#include &lt;openssl/params.h&gt;
+#include &quot;testutil.h&quot;
+
+#ifdef OPENSSL_SYS_WINDOWS
+# define strcasecmp _stricmp
+#endif
+
+typedef struct {
+    const OSSL_PARAM *param;
+    int32_t i32;
+    int64_t i64;
+    uint32_t u32;
+    uint64_t u64;
+    double d;
+    int valid_i32, valid_i64, valid_u32, valid_u64, valid_d;
+    void *ref, *datum;
+    size_t size;
+} PARAM_CONVERSION;
+
+static int param_conversion_load_stanza(PARAM_CONVERSION *pc, const STANZA *s)
+{
+
+    static int32_t datum_i32, ref_i32;
+    static int64_t datum_i64, ref_i64;
+    static uint32_t datum_u32, ref_u32;
+    static uint64_t datum_u64, ref_u64;
+    static double datum_d, ref_d;
+    static const OSSL_PARAM params[] = {
+        OSSL_PARAM_int32(&quot;int32&quot;,   &amp;datum_i32),
+        OSSL_PARAM_int64(&quot;int64&quot;,   &amp;datum_i64),
+        OSSL_PARAM_uint32(&quot;uint32&quot;, &amp;datum_u32),
+        OSSL_PARAM_uint64(&quot;uint64&quot;, &amp;datum_u64),
+        OSSL_PARAM_double(&quot;double&quot;, &amp;datum_d),
+        OSSL_PARAM_END
+    };
+    int def_i32 = 0, def_i64 = 0, def_u32 = 0, def_u64 = 0, def_d = 0;
+    const PAIR *pp = s-&gt;pairs;
+    const char *type = NULL;
+    char *p;
+    int i;
+
+    memset(pc, 0, sizeof(*pc));
+
+    for (i = 0; i &lt; s-&gt;numpairs; i++, pp++) {
+        p = &quot;&quot;;
+        if (strcasecmp(pp-&gt;key, &quot;type&quot;) == 0) {
+            if (type != NULL) {
+                TEST_info(&quot;Line %d: multiple type lines&quot;, s-&gt;curr);
+                return 0;
+            }
+            pc-&gt;param = OSSL_PARAM_locate(params, type = pp-&gt;value);
+            if (pc-&gt;param == NULL) {
+                TEST_info(&quot;Line %d: unknown type line&quot;, s-&gt;curr);
+                return 0;
+            }
+        } else if (strcasecmp(pp-&gt;key, &quot;int32&quot;) == 0) {
+            if (def_i32++) {
+                TEST_info(&quot;Line %d: multiple int32 lines&quot;, s-&gt;curr);
+                return 0;
+            }
+            if (strcasecmp(pp-&gt;value, &quot;invalid&quot;) != 0) {
+                pc-&gt;valid_i32 = 1;
+                pc-&gt;i32 = (int32_t)strtoimax(pp-&gt;value, &amp;p, 10);
+            }
+        } else if (strcasecmp(pp-&gt;key, &quot;int64&quot;) == 0) {
+            if (def_i64++) {
+                TEST_info(&quot;Line %d: multiple int64 lines&quot;, s-&gt;curr);
+                return 0;
+            }
+            if (strcasecmp(pp-&gt;value, &quot;invalid&quot;) != 0) {
+                pc-&gt;valid_i64 = 1;
+                pc-&gt;i64 = (int64_t)strtoimax(pp-&gt;value, &amp;p, 10);
+            }
+        } else if (strcasecmp(pp-&gt;key, &quot;uint32&quot;) == 0) {
+            if (def_u32++) {
+                TEST_info(&quot;Line %d: multiple uint32 lines&quot;, s-&gt;curr);
+                return 0;
+            }
+            if (strcasecmp(pp-&gt;value, &quot;invalid&quot;) != 0) {
+                pc-&gt;valid_u32 = 1;
+                pc-&gt;u32 = (uint32_t)strtoumax(pp-&gt;value, &amp;p, 10);
+            }
+        } else if (strcasecmp(pp-&gt;key, &quot;uint64&quot;) == 0) {
+            if (def_u64++) {
+                TEST_info(&quot;Line %d: multiple uint64 lines&quot;, s-&gt;curr);
+                return 0;
+            }
+            if (strcasecmp(pp-&gt;value, &quot;invalid&quot;) != 0) {
+                pc-&gt;valid_u64 = 1;
+                pc-&gt;u64 = (uint64_t)strtoumax(pp-&gt;value, &amp;p, 10);
+            }
+        } else if (strcasecmp(pp-&gt;key, &quot;double&quot;) == 0) {
+            if (def_d++) {
+                TEST_info(&quot;Line %d: multiple double lines&quot;, s-&gt;curr);
+                return 0;
+            }
+            if (strcasecmp(pp-&gt;value, &quot;invalid&quot;) != 0) {
+                pc-&gt;valid_d = 1;
+                pc-&gt;d = strtod(pp-&gt;value, &amp;p);
+            }
+        } else {
+            TEST_info(&quot;Line %d: unknown keyword %s&quot;, s-&gt;curr, pp-&gt;key);
+            return 0;
+        }
+        if (*p != '\0') {
+            TEST_info(&quot;Line %d: extra characters at end '%s' for %s&quot;,
+                      s-&gt;curr, p, pp-&gt;key);
+            return 0;
+        }
+    }
+
+    if (!TEST_ptr(type)) {
+        TEST_info(&quot;Line %d: type not found&quot;, s-&gt;curr);
+        return 0;
+    }
+
+    if (strcasecmp(type, &quot;int32&quot;) == 0) {
+        if (!TEST_true(def_i32) || !TEST_true(pc-&gt;valid_i32)) {
+            TEST_note(&quot;errant int32 on line %d&quot;, s-&gt;curr);
+            return 0;
+        }
+        datum_i32 = ref_i32 = pc-&gt;i32;
+        pc-&gt;datum = &amp;datum_i32;
+        pc-&gt;ref = &amp;ref_i32;
+        pc-&gt;size = sizeof(ref_i32);
+    } else if (strcasecmp(type, &quot;int64&quot;) == 0) {
+        if (!TEST_true(def_i64) || !TEST_true(pc-&gt;valid_i64)) {
+            TEST_note(&quot;errant int64 on line %d&quot;, s-&gt;curr);
+            return 0;
+        }
+        datum_i64 = ref_i64 = pc-&gt;i64;
+        pc-&gt;datum = &amp;datum_i64;
+        pc-&gt;ref = &amp;ref_i64;
+        pc-&gt;size = sizeof(ref_i64);
+    } else if (strcasecmp(type, &quot;uint32&quot;) == 0) {
+        if (!TEST_true(def_u32) || !TEST_true(pc-&gt;valid_u32)) {
+            TEST_note(&quot;errant uint32 on line %d&quot;, s-&gt;curr);
+            return 0;
+        }
+        datum_u32 = ref_u32 = pc-&gt;u32;
+        pc-&gt;datum = &amp;datum_u32;
+        pc-&gt;ref = &amp;ref_u32;
+        pc-&gt;size = sizeof(ref_u32);
+    } else if (strcasecmp(type, &quot;uint64&quot;) == 0) {
+        if (!TEST_true(def_u64) || !TEST_true(pc-&gt;valid_u64)) {
+            TEST_note(&quot;errant uint64 on line %d&quot;, s-&gt;curr);
+            return 0;
+        }
+        datum_u64 = ref_u64 = pc-&gt;u64;
+        pc-&gt;datum = &amp;datum_u64;
+        pc-&gt;ref = &amp;ref_u64;
+        pc-&gt;size = sizeof(ref_u64);
+    } else if (strcasecmp(type, &quot;double&quot;) == 0) {
+        if (!TEST_true(def_d) || !TEST_true(pc-&gt;valid_d)) {
+            TEST_note(&quot;errant double on line %d&quot;, s-&gt;curr);
+            return 0;
+        }
+        datum_d = ref_d = pc-&gt;d;
+        pc-&gt;datum = &amp;datum_d;
+        pc-&gt;ref = &amp;ref_d;
+        pc-&gt;size = sizeof(ref_d);
+    } else {
+        TEST_error(&quot;type unknown at line %d&quot;, s-&gt;curr);
+        return 0;
+    }
+    return 1;
+}
+
+static int param_conversion_test(const PARAM_CONVERSION *pc, int line)
+{
+    int32_t i32;
+    int64_t i64;
+    uint32_t u32;
+    uint64_t u64;
+    double d;
+
+    if (!pc-&gt;valid_i32) {
+        if (!TEST_false(OSSL_PARAM_get_int32(pc-&gt;param, &amp;i32))) {
+            TEST_note(&quot;unexpected valid conversion to int32 on line %d&quot;, line);
+            return 0;
+        }
+    } else {
+        if (!TEST_true(OSSL_PARAM_get_int32(pc-&gt;param, &amp;i32))
+            || !TEST_true(i32 == pc-&gt;i32)) {
+            TEST_note(&quot;unexpected conversion to int32 on line %d&quot;, line);
+            return 0;
+        }
+        memset(pc-&gt;datum, 44, pc-&gt;size);
+        if (!TEST_true(OSSL_PARAM_set_int32(pc-&gt;param, i32))
+            || !TEST_mem_eq(pc-&gt;datum, pc-&gt;size, pc-&gt;ref, pc-&gt;size)) {
+            TEST_note(&quot;unexpected valid conversion from int32 on line %d&quot;,
+                      line);
+            return 0;
+        }
+    }
+
+    if (!pc-&gt;valid_i64) {
+        if (!TEST_false(OSSL_PARAM_get_int64(pc-&gt;param, &amp;i64))) {
+            TEST_note(&quot;unexpected valid conversion to int64 on line %d&quot;, line);
+            return 0;
+        }
+    } else {
+        if (!TEST_true(OSSL_PARAM_get_int64(pc-&gt;param, &amp;i64))
+            || !TEST_true(i64 == pc-&gt;i64)) {
+            TEST_note(&quot;unexpected conversion to int64 on line %d&quot;, line);
+            return 0;
+        }
+        memset(pc-&gt;datum, 44, pc-&gt;size);
+        if (!TEST_true(OSSL_PARAM_set_int64(pc-&gt;param, i64))
+            || !TEST_mem_eq(pc-&gt;datum, pc-&gt;size, pc-&gt;ref, pc-&gt;size)) {
+            TEST_note(&quot;unexpected valid conversion from int64 on line %d&quot;,
+                      line);
+            return 0;
+        }
+    }
+
+    if (!pc-&gt;valid_u32) {
+        if (!TEST_false(OSSL_PARAM_get_uint32(pc-&gt;param, &amp;u32))) {
+            TEST_note(&quot;unexpected valid conversion to uint32 on line %d&quot;, line);
+            return 0;
+        }
+    } else {
+        if (!TEST_true(OSSL_PARAM_get_uint32(pc-&gt;param, &amp;u32))
+            || !TEST_true(u32 == pc-&gt;u32)) {
+            TEST_note(&quot;unexpected conversion to uint32 on line %d&quot;, line);
+            return 0;
+        }
+        memset(pc-&gt;datum, 44, pc-&gt;size);
+        if (!TEST_true(OSSL_PARAM_set_uint32(pc-&gt;param, u32))
+            || !TEST_mem_eq(pc-&gt;datum, pc-&gt;size, pc-&gt;ref, pc-&gt;size)) {
+            TEST_note(&quot;unexpected valid conversion from uint32 on line %d&quot;,
+                      line);
+            return 0;
+        }
+    }
+
+    if (!pc-&gt;valid_u64) {
+        if (!TEST_false(OSSL_PARAM_get_uint64(pc-&gt;param, &amp;u64))) {
+            TEST_note(&quot;unexpected valid conversion to uint64 on line %d&quot;, line);
+            return 0;
+        }
+    } else {
+        if (!TEST_true(OSSL_PARAM_get_uint64(pc-&gt;param, &amp;u64))
+            || !TEST_true(u64 == pc-&gt;u64)) {
+            TEST_note(&quot;unexpected conversion to uint64 on line %d&quot;, line);
+            return 0;
+        }
+        memset(pc-&gt;datum, 44, pc-&gt;size);
+        if (!TEST_true(OSSL_PARAM_set_uint64(pc-&gt;param, u64))
+            || !TEST_mem_eq(pc-&gt;datum, pc-&gt;size, pc-&gt;ref, pc-&gt;size)) {
+            TEST_note(&quot;unexpected valid conversion from uint64 on line %d&quot;,
+                      line);
+            return 0;
+        }
+    }
+
+    if (!pc-&gt;valid_d) {
+        if (!TEST_false(OSSL_PARAM_get_double(pc-&gt;param, &amp;d))) {
+            TEST_note(&quot;unexpected valid conversion to double on line %d&quot;, line);
+            return 0;
+        }
+    } else {
+        if (!TEST_true(OSSL_PARAM_get_double(pc-&gt;param, &amp;d))
+            || !TEST_true(d == pc-&gt;d)) {
+            TEST_note(&quot;unexpected conversion to double on line %d&quot;, line);
+            return 0;
+        }
+        memset(pc-&gt;datum, 44, pc-&gt;size);
+        if (!TEST_true(OSSL_PARAM_set_double(pc-&gt;param, d))
+            || !TEST_mem_eq(pc-&gt;datum, pc-&gt;size, pc-&gt;ref, pc-&gt;size)) {
+            TEST_note(&quot;unexpected valid conversion from double on line %d&quot;,
+                      line);
+            return 0;
+        }
+    }
+
+    return 1;
+}
+
+static int run_param_file_tests(int i)
+{
+    STANZA *s;
+    PARAM_CONVERSION pc;
+    const char *testfile = test_get_argument(i);
+    int res = 1;
+
+    if (!TEST_ptr(s = OPENSSL_zalloc(sizeof(*s))))
+        return 0;
+    if (!test_start_file(s, testfile)) {
+        OPENSSL_free(s);
+        return 0;
+    }
+
+    while (!BIO_eof(s-&gt;fp)) {
+        if (!test_readstanza(s)) {
+            res = 0;
+            goto end;
+        }
+        if (s-&gt;numpairs != 0)
+            if (!param_conversion_load_stanza(&amp;pc, s)
+                || !param_conversion_test(&amp;pc, s-&gt;curr))
+                res = 0;
+        test_clearstanza(s);
+    }
+end:
+    test_end_file(s);
+    OPENSSL_free(s);
+    return res;
+}
+
+OPT_TEST_DECLARE_USAGE(&quot;file...\n&quot;)
+
+int setup_tests(void)
+{
+    size_t n = test_get_argument_count();
+
+    if (n == 0)
+        return 0;
+
+    ADD_ALL_TESTS(run_param_file_tests, n);
+    return 1;
+}
diff --git a/test/recipes/04-test_provider.t b/test/recipes/04-test_params_conversion.t
similarity index 54%
copy from test/recipes/04-test_provider.t
copy to test/recipes/04-test_params_conversion.t
index 9195a42..d15df84 100644
--- a/test/recipes/04-test_provider.t
+++ b/test/recipes/04-test_params_conversion.t
@@ -7,12 +7,17 @@
 # <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
 
 use strict;
-use OpenSSL::Test qw(:DEFAULT bldtop_dir);
-use OpenSSL::Test::Simple;
-use OpenSSL::Test::Utils;
+use warnings;
 
-setup(&quot;test_provider&quot;);
+use OpenSSL::Test qw/:DEFAULT data_file/;
 
-$ENV{&quot;OPENSSL_MODULES&quot;} = bldtop_dir(&quot;test&quot;);
+setup(&quot;test_params_conversion&quot;);
 
-simple_test(&quot;test_provider&quot;, &quot;provider_test&quot;);
+my @files = ( &quot;native_types.txt&quot; );
+
+plan tests =&gt; scalar(@files);
+
+foreach my $f ( @files ) {
+    ok(run(test([&quot;params_conversion_test&quot;, data_file(&quot;$f&quot;)])),
+       &quot;running params_conversion_test $f&quot;);
+}
diff --git a/test/recipes/04-test_params_conversion_data/native_types.txt b/test/recipes/04-test_params_conversion_data/native_types.txt
new file mode 100644
index 0000000..233a584
--- /dev/null
+++ b/test/recipes/04-test_params_conversion_data/native_types.txt
@@ -0,0 +1,343 @@
+type=int32
+int32=0
+int64=0
+uint32=0
+uint64=0
+double=0
+
+type=int32
+int32=6
+int64=6
+uint32=6
+uint64=6
+double=6
+
+type=int32
+int32=-6
+int64=-6
+uint32=invalid
+uint64=invalid
+double=-6
+
+
+type=uint32
+int32=0
+int64=0
+uint32=0
+uint64=0
+double=0
+
+type=uint32
+int32=6
+int64=6
+uint32=6
+uint64=6
+double=6
+
+# 2^31-1
+type=uint32
+int32=2147483647
+int64=2147483647
+uint32=2147483647
+uint64=2147483647
+double=2147483647
+
+# 2^31
+type=uint32
+int32=invalid
+int64=2147483648
+uint32=2147483648
+uint64=2147483648
+double=2147483648
+
+
+type=int64
+int32=6
+int64=6
+uint32=6
+uint64=6
+double=6
+
+type=int64
+int32=-6
+int64=-6
+uint32=invalid
+uint64=invalid
+double=-6
+
+# 2^31-1
+type=int64
+int32=2147483647
+int64=2147483647
+uint32=2147483647
+uint64=2147483647
+double=2147483647
+
+# 2^31
+type=int64
+int32=invalid
+int64=2147483648
+uint32=2147483648
+uint64=2147483648
+double=2147483648
+
+# -2^31+1
+type=int64
+int32=-2147483647
+int64=-2147483647
+uint32=invalid
+uint64=invalid
+double=-2147483647
+
+# -2^31
+type=int64
+int32=-2147483648
+int64=-2147483648
+uint32=invalid
+uint64=invalid
+double=-2147483648
+
+# -2^31-1
+type=int64
+int32=invalid
+int64=-2147483649
+uint32=invalid
+uint64=invalid
+double=-2147483649
+
+# 2^32-1
+type=int64
+int32=invalid
+int64=4294967295
+uint32=4294967295
+uint64=4294967295
+double=4294967295
+
+# 2^32
+type=int64
+int32=invalid
+int64=4294967296
+uint32=invalid
+uint64=4294967296
+double=4294967296
+
+# -2^32
+type=int64
+int32=invalid
+int64=-4294967296
+uint32=invalid
+uint64=invalid
+double=-4294967296
+
+# 2^53-1
+type=int64
+int32=invalid
+int64=9007199254740991
+uint32=invalid
+uint64=9007199254740991
+double=9007199254740991
+
+# 2^53
+type=int64
+int32=invalid
+int64=9007199254740992
+uint32=invalid
+uint64=9007199254740992
+double=invalid
+
+# -2^53-1
+type=int64
+int32=invalid
+int64=-9007199254740991
+uint32=invalid
+uint64=invalid
+double=-9007199254740991
+
+# -2^53
+type=int64
+int32=invalid
+int64=-9007199254740992
+uint32=invalid
+uint64=invalid
+double=invalid
+
+
+type=uint64
+int32=6
+int64=6
+uint32=6
+uint64=6
+double=6
+
+# 2^31-1
+type=uint64
+int32=2147483647
+int64=2147483647
+uint32=2147483647
+uint64=2147483647
+double=2147483647
+
+# 2^31
+type=uint64
+int32=invalid
+int64=2147483648
+uint32=2147483648
+uint64=2147483648
+double=2147483648
+
+# 2^32-1
+type=uint64
+int32=invalid
+int64=4294967295
+uint32=4294967295
+uint64=4294967295
+double=4294967295
+
+# 2^32
+type=uint64
+int32=invalid
+int64=4294967296
+uint32=invalid
+uint64=4294967296
+double=4294967296
+
+# 2^53-1
+type=uint64
+int32=invalid
+int64=9007199254740991
+uint32=invalid
+uint64=9007199254740991
+double=9007199254740991
+
+# 2^53
+type=uint64
+int32=invalid
+int64=9007199254740992
+uint32=invalid
+uint64=9007199254740992
+double=invalid
+
+# 2^63-1
+type=uint64
+int32=invalid
+int64=9223372036854775807
+uint32=invalid
+uint64=9223372036854775807
+double=invalid
+
+# 2^63-1
+type=uint64
+int32=invalid
+int64=invalid
+uint32=invalid
+uint64=9223372036854775808
+double=invalid
+
+type=double
+int32=0
+int64=0
+uint32=0
+uint64=0
+double=0
+
+type=double
+int32=6
+int64=6
+uint32=6
+uint64=6
+double=6
+
+type=double
+int32=-6
+int64=-6
+uint32=invalid
+uint64=invalid
+double=-6
+
+# -2^31
+type=double
+int32=-2147483648
+int64=-2147483648
+uint32=invalid
+uint64=invalid
+double=-2147483648
+
+# -2^31-1
+type=double
+int32=invalid
+int64=-2147483649
+uint32=invalid
+uint64=invalid
+double=-2147483649
+
+# 2^32-1
+type=double
+int32=invalid
+int64=4294967295
+uint32=4294967295
+uint64=4294967295
+double=4294967295
+
+# 2^32
+type=double
+int32=invalid
+int64=4294967296
+uint32=invalid
+uint64=4294967296
+double=4294967296
+
+# -2^32
+type=double
+int32=invalid
+int64=-4294967296
+uint32=invalid
+uint64=invalid
+double=-4294967296
+
+# 2^53-1
+type=double
+int32=invalid
+int64=9007199254740991
+uint32=invalid
+uint64=9007199254740991
+double=9007199254740991
+
+# -2^53+1
+type=double
+int32=invalid
+int64=-9007199254740991
+uint32=invalid
+uint64=invalid
+double=-9007199254740991
+
+# big
+type=double
+int32=invalid
+int64=invalid
+uint32=invalid
+uint64=invalid
+double=1e100
+
+# big
+type=double
+int32=invalid
+int64=invalid
+uint32=invalid
+uint64=invalid
+double=-1e100
+
+# infinite
+type=double
+int32=invalid
+int64=invalid
+uint32=invalid
+uint64=invalid
+double=inf
+
+# fractional
+type=double
+int32=invalid
+int64=invalid
+uint32=invalid
+uint64=invalid
+double=0.5
</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023131.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="023136.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23133">[ date ]</a>
              <a href="thread.html#23133">[ thread ]</a>
              <a href="subject.html#23133">[ subject ]</a>
              <a href="author.html#23133">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
