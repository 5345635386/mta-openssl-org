<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2017-June/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1497644758.503773.22400.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015070.html">
   <LINK REL="Next"  HREF="015073.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1497644758.503773.22400.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Fri Jun 16 20:25:58 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="015070.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="015073.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15071">[ date ]</a>
              <a href="thread.html#15071">[ thread ]</a>
              <a href="subject.html#15071">[ subject ]</a>
              <a href="author.html#15071">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  3791646202bb4da21992b0aecae253d394507a9e (commit)
      from  5511101ad86fdd5bc3ad4f27143e93ae14737bfe (commit)


- Log -----------------------------------------------------------------
commit 3791646202bb4da21992b0aecae253d394507a9e
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Mon Jun 12 10:01:17 2017 +1000

    Add output routines to allow consistent formatting of memory, strings
    and bignums.  These have been refactored into their own file, along with
    their error displays.  The formatting follows the output format used
    on error, except that bignums of sixty four bits or less are displayed
    in a more compact one line form.
    
    Added a TEST_note function for producing output without file and line
    information.
    
    Update the three tests that call BN_print so they use the new test
    infrastructure instead.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3655">https://github.com/openssl/openssl/pull/3655</A>)

-----------------------------------------------------------------------

Summary of changes:
 test/build.info               |   1 +
 test/ectest.c                 | 199 ++++++----------
 test/exptest.c                |  16 +-
 test/igetest.c                |  33 +--
 test/srptest.c                |  50 ++--
 test/test_test.c              |  34 +++
 test/testutil.h               |  10 +
 test/testutil/driver.c        |   1 +
 test/testutil/format_output.c | 528 ++++++++++++++++++++++++++++++++++++++++++
 test/testutil/tests.c         | 450 +++--------------------------------
 test/testutil/tu_local.h      |  30 +++
 11 files changed, 745 insertions(+), 607 deletions(-)
 create mode 100644 test/testutil/format_output.c

diff --git a/test/build.info b/test/build.info
index fc09fcb..eba52cc 100644
--- a/test/build.info
+++ b/test/build.info
@@ -11,6 +11,7 @@ IF[{- !$disabled{tests} -}]
   LIBS_NO_INST=libtestutil.a
   SOURCE[libtestutil.a]=testutil/basic_output.c testutil/output_helpers.c \
           testutil/driver.c testutil/tests.c testutil/cb.c testutil/stanza.c \
+          testutil/format_output.c \
           {- rebase_files(&quot;../apps&quot;, $target{apps_aux_src}) -} \
           testutil/test_main.c testutil/main.c
   INCLUDE[libtestutil.a]=.. ../include
diff --git a/test/ectest.c b/test/ectest.c
index 8e311e5..37bffc6 100644
--- a/test/ectest.c
+++ b/test/ectest.c
@@ -161,7 +161,7 @@ static int prime_field_tests(void)
     const EC_POINT *points[4];
     const BIGNUM *scalars[4];
     unsigned char buf[100];
-    size_t i, len, r = 0;
+    size_t len, r = 0;
     int k;
 
     if (!TEST_ptr(ctx = BN_CTX_new())
@@ -187,15 +187,11 @@ static int prime_field_tests(void)
     if (!TEST_true(EC_GROUP_get_curve_GFp(group, p, a, b, ctx)))
         goto err;
 
-    BIO_printf(bio_out,
-            &quot;Curve defined by Weierstrass equation\n&quot;
-            &quot;     y^2 = x^3 + a*x + b  (mod 0x&quot;);
-    BN_print(bio_out, p);
-    BIO_printf(bio_out, &quot;)\n     a = 0x&quot;);
-    BN_print(bio_out, a);
-    BIO_printf(bio_out, &quot;\n     b = 0x&quot;);
-    BN_print(bio_out, b);
-    BIO_printf(bio_out, &quot;\n&quot;);
+    TEST_info(&quot;Curve defined by Weierstrass equation&quot;);
+    TEST_note(&quot;     y^2 = x^3 + a*x + b (mod p)&quot;);
+    test_output_bignum(&quot;a&quot;, a);
+    test_output_bignum(&quot;b&quot;, b);
+    test_output_bignum(&quot;p&quot;, p);
 
     buf[0] = 0;
     if (!TEST_ptr(P = EC_POINT_new(group))
@@ -219,32 +215,27 @@ static int prime_field_tests(void)
         if (!TEST_true(EC_POINT_get_affine_coordinates_GFp(group, Q, x, y,
                                                            ctx)))
             goto err;
-        BIO_printf(bio_err, &quot;Point is not on curve: x = 0x&quot;);
-        BN_print_fp(stderr, x);
-        BIO_printf(bio_err, &quot;, y = 0x&quot;);
-        BN_print_fp(stderr, y);
-        BIO_printf(bio_err, &quot;\n&quot;);
+        TEST_info(&quot;Point is not on curve&quot;);
+        test_output_bignum(&quot;x&quot;, x);
+        test_output_bignum(&quot;y&quot;, y);
         goto err;
     }
 
-    BIO_printf(bio_out, &quot;A cyclic subgroup:\n&quot;);
+    TEST_note(&quot;A cyclic subgroup:&quot;);
     k = 100;
     do {
         if (!TEST_int_ne(k--, 0))
             goto err;
 
         if (EC_POINT_is_at_infinity(group, P)) {
-            BIO_printf(bio_out, &quot;     point at infinity\n&quot;);
+            TEST_note(&quot;     point at infinity&quot;);
         } else {
             if (!TEST_true(EC_POINT_get_affine_coordinates_GFp(group, P, x, y,
                                                                ctx)))
                 goto err;
 
-            BIO_printf(bio_out, &quot;     x = 0x&quot;);
-            BN_print(bio_out, x);
-            BIO_printf(bio_out, &quot;, y = 0x&quot;);
-            BN_print(bio_out, y);
-            BIO_printf(bio_out, &quot;\n&quot;);
+            test_output_bignum(&quot;x&quot;, x);
+            test_output_bignum(&quot;y&quot;, y);
         }
 
         if (!TEST_true(EC_POINT_copy(R, P))
@@ -264,9 +255,8 @@ static int prime_field_tests(void)
         || !TEST_true(EC_POINT_oct2point(group, P, buf, len, ctx))
         || !TEST_int_eq(0, EC_POINT_cmp(group, P, Q, ctx)))
         goto err;
-    BIO_printf(bio_out, &quot;Generator as octet string, compressed form:\n     &quot;);
-    for (i = 0; i &lt; len; i++)
-        BIO_printf(bio_out, &quot;%02X&quot;, buf[i]);
+    test_output_memory(&quot;Generator as octet string, compressed form:&quot;,
+                       buf, len);
 
     len = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED,
                              buf, sizeof buf, ctx);
@@ -274,10 +264,8 @@ static int prime_field_tests(void)
         || !TEST_true(EC_POINT_oct2point(group, P, buf, len, ctx))
         || !TEST_int_eq(0, EC_POINT_cmp(group, P, Q, ctx)))
         goto err;
-    BIO_printf(bio_out, &quot;\nGenerator as octet string, uncompressed form:\n&quot;
-                        &quot;     &quot;);
-    for (i = 0; i &lt; len; i++)
-        BIO_printf(bio_out, &quot;%02X&quot;, buf[i]);
+    test_output_memory(&quot;Generator as octet string, uncompressed form:&quot;,
+                       buf, len);
 
     len = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID,
                              buf, sizeof buf, ctx);
@@ -285,23 +273,17 @@ static int prime_field_tests(void)
         || !TEST_true(EC_POINT_oct2point(group, P, buf, len, ctx))
         || !TEST_int_eq(0, EC_POINT_cmp(group, P, Q, ctx)))
         goto err;
-    BIO_printf(bio_out, &quot;\nGenerator as octet string, hybrid form:\n     &quot;);
-    for (i = 0; i &lt; len; i++)
-        BIO_printf(bio_out, &quot;%02X&quot;, buf[i]);
+    test_output_memory(&quot;Generator as octet string, hybrid form:&quot;,
+                       buf, len);
 
     if (!TEST_true(EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z,
                                                             ctx)))
         goto err;
-    BIO_printf(bio_out,
-               &quot;\nA representation of the inverse of that generator in\n&quot;
-               &quot;Jacobian projective coordinates:\n&quot;
-               &quot;     X = 0x&quot;);
-    BN_print(bio_out, x);
-    BIO_printf(bio_out, &quot;, Y = 0x&quot;);
-    BN_print(bio_out, y);
-    BIO_printf(bio_out, &quot;, Z = 0x&quot;);
-    BN_print(bio_out, z);
-    BIO_printf(bio_out, &quot;\n&quot;);
+    TEST_info(&quot;A representation of the inverse of that generator in&quot;);
+    TEST_note(&quot;Jacobian projective coordinates&quot;);
+    test_output_bignum(&quot;x&quot;, x);
+    test_output_bignum(&quot;y&quot;, y);
+    test_output_bignum(&quot;z&quot;, z);
 
     if (!TEST_true(EC_POINT_invert(group, P, ctx))
         || !TEST_int_eq(0, EC_POINT_cmp(group, P, R, ctx))
@@ -337,11 +319,9 @@ static int prime_field_tests(void)
         || !TEST_true(EC_GROUP_set_generator(group, P, z, BN_value_one()))
         || !TEST_true(EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)))
         goto err;
-    BIO_printf(bio_out, &quot;\nSEC2 curve secp160r1 -- Generator:\n     x = 0x&quot;);
-    BN_print(bio_out, x);
-    BIO_printf(bio_out, &quot;\n     y = 0x&quot;);
-    BN_print(bio_out, y);
-    BIO_printf(bio_out, &quot;\n&quot;);
+    TEST_info(&quot;SEC2 curve secp160r1 -- Generator&quot;);
+    test_output_bignum(&quot;x&quot;, x);
+    test_output_bignum(&quot;y&quot;, y);
     /* G_y value taken from the standard: */
     if (!TEST_true(BN_hex2bn(&amp;z,                         &quot;23a62855&quot;
                                  &quot;3168947d59dcc912042351377ac5fb32&quot;))
@@ -372,11 +352,9 @@ static int prime_field_tests(void)
         || !TEST_true(EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)))
         goto err;
 
-    BIO_printf(bio_out, &quot;\nNIST curve P-192 -- Generator:\n     x = 0x&quot;);
-    BN_print(bio_out, x);
-    BIO_printf(bio_out, &quot;\n     y = 0x&quot;);
-    BN_print(bio_out, y);
-    BIO_printf(bio_out, &quot;\n&quot;);
+    TEST_info(&quot;NIST curve P-192 -- Generator&quot;);
+    test_output_bignum(&quot;x&quot;, x);
+    test_output_bignum(&quot;y&quot;, y);
     /* G_y value taken from the standard: */
     if (!TEST_true(BN_hex2bn(&amp;z,                 &quot;07192B95FFC8DA78&quot;
                                  &quot;631011ED6B24CDD573F977A11E794811&quot;))
@@ -414,11 +392,9 @@ static int prime_field_tests(void)
         || !TEST_true(EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)))
         goto err;
 
-    BIO_printf(bio_out, &quot;\nNIST curve P-224 -- Generator:\n     x = 0x&quot;);
-    BN_print(bio_out, x);
-    BIO_printf(bio_out, &quot;\n     y = 0x&quot;);
-    BN_print(bio_out, y);
-    BIO_printf(bio_out, &quot;\n&quot;);
+    TEST_info(&quot;NIST curve P-224 -- Generator&quot;);
+    test_output_bignum(&quot;x&quot;, x);
+    test_output_bignum(&quot;y&quot;, y);
     /* G_y value taken from the standard: */
     if (!TEST_true(BN_hex2bn(&amp;z,         &quot;BD376388B5F723FB4C22DFE6&quot;
                                  &quot;CD4375A05A07476444D5819985007E34&quot;))
@@ -457,11 +433,9 @@ static int prime_field_tests(void)
         || !TEST_true(EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)))
         goto err;
 
-    BIO_printf(bio_out, &quot;\nNIST curve P-256 -- Generator:\n     x = 0x&quot;);
-    BN_print(bio_out, x);
-    BIO_printf(bio_out, &quot;\n     y = 0x&quot;);
-    BN_print(bio_out, y);
-    BIO_printf(bio_out, &quot;\n&quot;);
+    TEST_info(&quot;NIST curve P-256 -- Generator&quot;);
+    test_output_bignum(&quot;x&quot;, x);
+    test_output_bignum(&quot;y&quot;, y);
     /* G_y value taken from the standard: */
     if (!TEST_true(BN_hex2bn(&amp;z, &quot;4FE342E2FE1A7F9B8EE7EB4A7C0F9E16&quot;
                                  &quot;2BCE33576B315ECECBB6406837BF51F5&quot;))
@@ -505,11 +479,9 @@ static int prime_field_tests(void)
         || !TEST_true(EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)))
         goto err;
 
-    BIO_printf(bio_out, &quot;\nNIST curve P-384 -- Generator:\n     x = 0x&quot;);
-    BN_print(bio_out, x);
-    BIO_printf(bio_out, &quot;\n     y = 0x&quot;);
-    BN_print(bio_out, y);
-    BIO_printf(bio_out, &quot;\n&quot;);
+    TEST_info(&quot;NIST curve P-384 -- Generator&quot;);
+    test_output_bignum(&quot;x&quot;, x);
+    test_output_bignum(&quot;y&quot;, y);
     /* G_y value taken from the standard: */
     if (!TEST_true(BN_hex2bn(&amp;z, &quot;3617DE4A96262C6F5D9E98BF9292DC29&quot;
                                  &quot;F8F41DBD289A147CE9DA3113B5F0B8C0&quot;
@@ -562,11 +534,9 @@ static int prime_field_tests(void)
         || !TEST_true(EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)))
         goto err;
 
-    BIO_printf(bio_out, &quot;\nNIST curve P-521 -- Generator:\n     x = 0x&quot;);
-    BN_print(bio_out, x);
-    BIO_printf(bio_out, &quot;\n     y = 0x&quot;);
-    BN_print(bio_out, y);
-    BIO_printf(bio_out, &quot;\n&quot;);
+    TEST_info(&quot;NIST curve P-521 -- Generator&quot;);
+    test_output_bignum(&quot;x&quot;, x);
+    test_output_bignum(&quot;y&quot;, y);
     /* G_y value taken from the standard: */
     if (!TEST_true(BN_hex2bn(&amp;z,                              &quot;118&quot;
                                  &quot;39296A789A3BC0045C8A5FB42C7D1BD9&quot;
@@ -613,7 +583,7 @@ static int prime_field_tests(void)
     scalars[0] = y;         /* (group order + 1)/2, so y*Q + y*Q = Q */
     scalars[1] = y;
 
-    BIO_printf(bio_out, &quot;combined multiplication ...&quot;);
+    TEST_note(&quot;combined multiplication ...&quot;);
 
     /* z is still the group order */
     if (!TEST_true(EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx))
@@ -646,7 +616,7 @@ static int prime_field_tests(void)
         || !TEST_true(EC_POINT_is_at_infinity(group, P)))
         goto err;
 
-    BIO_printf(bio_out, &quot; ok\n\n&quot;);
+    TEST_note(&quot; ok\n&quot;);
 
 
     r = 1;
@@ -898,11 +868,9 @@ static int char2_curve_test(int n)
         || !TEST_true(EC_POINT_get_affine_coordinates_GF2m(group, P, x, y,
                                                            ctx)))
         goto err;
-    BIO_printf(bio_out, &quot;\n%s -- Generator:\n     x = 0x&quot;, test-&gt;name);
-    BN_print(bio_out, x);
-    BIO_printf(bio_out, &quot;\n     y = 0x&quot;);
-    BN_print(bio_out, y);
-    BIO_printf(bio_out, &quot;\n&quot;);
+    TEST_info(&quot;%s -- Generator&quot;, test-&gt;name);
+    test_output_bignum(&quot;x&quot;, x);
+    test_output_bignum(&quot;y&quot;, y);
     /* G_y value taken from the standard: */
     if (!TEST_true(BN_hex2bn(&amp;z, test-&gt;y))
         || !TEST_BN_eq(y, z))
@@ -920,11 +888,9 @@ static int char2_curve_test(int n)
         || !TEST_true(BN_hex2bn(&amp;cof, test-&gt;cof))
         || !TEST_true(EC_GROUP_set_generator(group, P, z, cof)))
         goto err;
-    BIO_printf(bio_out, &quot;\n%s -- Generator:\n     x = 0x&quot;, test-&gt;name); \
-    BN_print(bio_out, x); \
-    BIO_printf(bio_out, &quot;\n     y = 0x&quot;); \
-    BN_print(bio_out, y); \
-    BIO_printf(bio_out, &quot;\n&quot;);
+    TEST_info(&quot;%s -- Generator:&quot;, test-&gt;name);
+    test_output_bignum(&quot;x&quot;, x);
+    test_output_bignum(&quot;y&quot;, y);
 # endif
 
     if (!TEST_int_eq(EC_GROUP_get_degree(group), test-&gt;degree)
@@ -959,7 +925,7 @@ static int char2_curve_test(int n)
         scalars[0] = y;         /* (group order + 1)/2, so y*Q + y*Q = Q */
         scalars[1] = y;
 
-        BIO_printf(bio_out, &quot;combined multiplication ...&quot;);
+        TEST_note(&quot;combined multiplication ...&quot;);
 
         /* z is still the group order */
         if (!TEST_true(EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx))
@@ -1019,7 +985,7 @@ static int char2_field_tests(void)
     EC_POINT *P = NULL, *Q = NULL, *R = NULL;
     BIGNUM *x = NULL, *y = NULL, *z = NULL, *cof = NULL, *yplusone = NULL;
     unsigned char buf[100];
-    size_t i, len;
+    size_t len;
     int k, r = 0;
 
     if (!TEST_ptr(ctx = BN_CTX_new())
@@ -1047,15 +1013,11 @@ static int char2_field_tests(void)
     if (!TEST_true(EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)))
         goto err;
 
-    BIO_printf(bio_out,
-            &quot;Curve defined by Weierstrass equation\n&quot;
-            &quot;     y^2 + x*y = x^3 + a*x^2 + b  (mod 0x&quot;);
-    BN_print(bio_out, p);
-    BIO_printf(bio_out, &quot;)\n     a = 0x&quot;);
-    BN_print(bio_out, a);
-    BIO_printf(bio_out, &quot;\n     b = 0x&quot;);
-    BN_print(bio_out, b);
-    BIO_printf(bio_out, &quot;\n(0x... means binary polynomial)\n&quot;);
+    TEST_info(&quot;Curve defined by Weierstrass equation&quot;);
+    TEST_note(&quot;     y^2 + x*y = x^3 + a*x^2 + b (mod p)&quot;);
+    test_output_bignum(&quot;a&quot;, a);
+    test_output_bignum(&quot;b&quot;, b);
+    test_output_bignum(&quot;p&quot;, p);
 
      if (!TEST_ptr(P = EC_POINT_new(group))
         || !TEST_ptr(Q = EC_POINT_new(group))
@@ -1091,32 +1053,27 @@ static int char2_field_tests(void)
                                                             ctx)))
             goto err;
 #  endif
-        BIO_printf(bio_err, &quot;Point is not on curve: x = 0x&quot;);
-        BN_print_fp(stderr, x);
-        BIO_printf(bio_err, &quot;, y = 0x&quot;);
-        BN_print_fp(stderr, y);
-        BIO_printf(bio_err, &quot;\n&quot;);
+        TEST_info(&quot;Point is not on curve&quot;);
+        test_output_bignum(&quot;x&quot;, x);
+        test_output_bignum(&quot;y&quot;, y);
         goto err;
     }
 
-    BIO_printf(bio_out, &quot;A cyclic subgroup:\n&quot;);
+    TEST_note(&quot;A cyclic subgroup:&quot;);
     k = 100;
     do {
         if (!TEST_int_ne(k--, 0))
             goto err;
 
         if (EC_POINT_is_at_infinity(group, P))
-            BIO_printf(bio_out, &quot;     point at infinity\n&quot;);
+            TEST_note(&quot;     point at infinity&quot;);
         else {
             if (!TEST_true(EC_POINT_get_affine_coordinates_GF2m(group, P, x, y,
                                                                 ctx)))
                 goto err;
 
-            BIO_printf(bio_out, &quot;     x = 0x&quot;);
-            BN_print(bio_out, x);
-            BIO_printf(bio_out, &quot;, y = 0x&quot;);
-            BN_print(bio_out, y);
-            BIO_printf(bio_out, &quot;\n&quot;);
+            test_output_bignum(&quot;x&quot;, x);
+            test_output_bignum(&quot;y&quot;, y);
         }
 
         if (!TEST_true(EC_POINT_copy(R, P))
@@ -1137,9 +1094,8 @@ static int char2_field_tests(void)
         || !TEST_true(EC_POINT_oct2point(group, P, buf, len, ctx))
         || !TEST_int_eq(0, EC_POINT_cmp(group, P, Q, ctx)))
         goto err;
-    BIO_printf(bio_out, &quot;Generator as octet string, compressed form:\n     &quot;);
-    for (i = 0; i &lt; len; i++)
-        BIO_printf(bio_out, &quot;%02X&quot;, buf[i]);
+    test_output_memory(&quot;Generator as octet string, compressed form:&quot;,
+                       buf, len);
 #  endif
 
     len = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED,
@@ -1148,10 +1104,8 @@ static int char2_field_tests(void)
         || !TEST_true(EC_POINT_oct2point(group, P, buf, len, ctx))
         || !TEST_int_eq(0, EC_POINT_cmp(group, P, Q, ctx)))
         goto err;
-    BIO_printf(bio_out, &quot;\nGenerator as octet string, uncompressed form:\n&quot;
-                        &quot;     &quot;);
-    for (i = 0; i &lt; len; i++)
-        BIO_printf(bio_out, &quot;%02X&quot;, buf[i]);
+    test_output_memory(&quot;Generator as octet string, uncompressed form:&quot;,
+                       buf, len);
 
 /* Change test based on whether binary point compression is enabled or not. */
 #  ifdef OPENSSL_EC_BIN_PT_COMP
@@ -1162,20 +1116,15 @@ static int char2_field_tests(void)
         || !TEST_true(EC_POINT_oct2point(group, P, buf, len, ctx))
         || !TEST_int_eq(0, EC_POINT_cmp(group, P, Q, ctx)))
         goto err;
-    BIO_printf(bio_out, &quot;\nGenerator as octet string, hybrid form:\n     &quot;);
-    for (i = 0; i &lt; len; i++)
-        BIO_printf(bio_out, &quot;%02X&quot;, buf[i]);
+    test_output_memory(&quot;Generator as octet string, hybrid form:&quot;,
+                       buf, len);
 #  endif
-    BIO_printf(bio_out, &quot;\n&quot;);
 
     if (!TEST_true(EC_POINT_invert(group, P, ctx))
         || !TEST_int_eq(0, EC_POINT_cmp(group, P, R, ctx)))
         goto err;
 
-
-#if 0
-#endif
-    BIO_printf(bio_out, &quot;\n\n&quot;);
+    TEST_note(&quot;\n&quot;);
 
     r = 1;
 err:
@@ -1352,8 +1301,8 @@ static int nistp_single_test(int idx)
     EC_POINT *G = NULL, *P = NULL, *Q = NULL, *Q_CHECK = NULL;
     int r = 0;
 
-    BIO_printf(bio_out, &quot;\nNIST curve P-%d (optimised implementation):\n&quot;,
-            test-&gt;degree);
+    TEST_note(&quot;NIST curve P-%d (optimised implementation):&quot;,
+              test-&gt;degree);
     if (!TEST_ptr(ctx = BN_CTX_new())
         || !TEST_ptr(p = BN_new())
         || !TEST_ptr(a = BN_new())
@@ -1394,7 +1343,7 @@ static int nistp_single_test(int idx)
         || !TEST_int_eq(EC_GROUP_get_degree(NISTP), test-&gt;degree))
         goto err;
 
-    BIO_printf(bio_out, &quot;NIST test vectors ... &quot;);
+    TEST_note(&quot;NIST test vectors ... &quot;);
     if (!TEST_true(BN_hex2bn(&amp;n, test-&gt;d)))
         goto err;
     /* fixed point multiplication */
diff --git a/test/exptest.c b/test/exptest.c
index ee1bff1..e6f5213 100644
--- a/test/exptest.c
+++ b/test/exptest.c
@@ -22,14 +22,7 @@
 
 #define NUM_BITS        (BN_BITS2 * 4)
 
-#define BN_print_var(v) bn_print_var(#v, v)
-
-static void bn_print_var(const char *var, const BIGNUM *bn)
-{
-    fprintf(stderr, &quot;%s (%3d) = &quot;, var, BN_num_bits(bn));
-    BN_print_fp(stderr, bn);
-    fprintf(stderr, &quot;\n&quot;);
-}
+#define BN_print_var(v) test_output_bignum(#v, v)
 
 /*
  * Test that r == 0 in test_exp_mod_zero(). Returns one on success,
@@ -39,8 +32,7 @@ static int a_is_zero_mod_one(const char *method, const BIGNUM *r,
                              const BIGNUM *a)
 {
     if (!BN_is_zero(r)) {
-        fprintf(stderr, &quot;%s failed:\n&quot;, method);
-        fprintf(stderr, &quot;a ** 0 mod 1 = r (should be 0)\n&quot;);
+        TEST_error(&quot;%s failed: a ** 0 mod 1 = r (should be 0)&quot;, method);
         BN_print_var(a);
         BN_print_var(r);
         return 0;
@@ -110,8 +102,8 @@ static int test_mod_exp_zero()
         goto err;
 
     if (!TEST_BN_eq_zero(r)) {
-        fprintf(stderr, &quot;BN_mod_exp_mont_word failed:\n&quot;);
-        fprintf(stderr, &quot;1 ** 0 mod 1 = r (should be 0)\n&quot;);
+        TEST_error(&quot;BN_mod_exp_mont_word failed: &quot;
+                   &quot;1 ** 0 mod 1 = r (should be 0)&quot;);
         BN_print_var(r);
         goto err;
     }
diff --git a/test/igetest.c b/test/igetest.c
index f6972b6..a0fc623 100644
--- a/test/igetest.c
+++ b/test/igetest.c
@@ -27,19 +27,6 @@ static unsigned char rkey2[16];
 static unsigned char plaintext[BIG_TEST_SIZE];
 static unsigned char saved_iv[AES_BLOCK_SIZE * 4];
 
-static void hexdump(FILE *f, const char *title, const unsigned char *s, int l)
-{
-    int n = 0;
-
-    fprintf(f, &quot;%s&quot;, title);
-    for (; n &lt; l; ++n) {
-        if ((n % 16) == 0)
-            fprintf(f, &quot;\n%04x&quot;, n);
-        fprintf(f, &quot; %02x&quot;, s[n]);
-    }
-    fprintf(f, &quot;\n&quot;);
-}
-
 #define MAX_VECTOR_SIZE 64
 
 struct ige_test {
@@ -174,9 +161,9 @@ static int test_ige_vectors(int n)
 
     if (!TEST_mem_eq(v-&gt;out, v-&gt;length, buf, v-&gt;length)) {
         TEST_info(&quot;IGE test vector %d failed&quot;, n);
-        hexdump(stderr, &quot;key&quot;, v-&gt;key, sizeof v-&gt;key);
-        hexdump(stderr, &quot;iv&quot;, v-&gt;iv, sizeof v-&gt;iv);
-        hexdump(stderr, &quot;in&quot;, v-&gt;in, v-&gt;length);
+        test_output_memory(&quot;key&quot;, v-&gt;key, sizeof v-&gt;key);
+        test_output_memory(&quot;iv&quot;, v-&gt;iv, sizeof v-&gt;iv);
+        test_output_memory(&quot;in&quot;, v-&gt;in, v-&gt;length);
         testresult = 0;
     }
 
@@ -187,9 +174,9 @@ static int test_ige_vectors(int n)
 
     if (!TEST_mem_eq(v-&gt;out, v-&gt;length, buf, v-&gt;length)) {
         TEST_info(&quot;IGE test vector %d failed (with in == out)&quot;, n);
-        hexdump(stderr, &quot;key&quot;, v-&gt;key, sizeof v-&gt;key);
-        hexdump(stderr, &quot;iv&quot;, v-&gt;iv, sizeof v-&gt;iv);
-        hexdump(stderr, &quot;in&quot;, v-&gt;in, v-&gt;length);
+        test_output_memory(&quot;key&quot;, v-&gt;key, sizeof v-&gt;key);
+        test_output_memory(&quot;iv&quot;, v-&gt;iv, sizeof v-&gt;iv);
+        test_output_memory(&quot;in&quot;, v-&gt;in, v-&gt;length);
         testresult = 0;
     }
 
@@ -218,10 +205,10 @@ static int test_bi_ige_vectors(int n)
                        v-&gt;encrypt);
 
     if (!TEST_mem_eq(v-&gt;out, v-&gt;length, buf, v-&gt;length)) {
-        hexdump(stderr, &quot;key 1&quot;, v-&gt;key1, sizeof v-&gt;key1);
-        hexdump(stderr, &quot;key 2&quot;, v-&gt;key2, sizeof v-&gt;key2);
-        hexdump(stderr, &quot;iv&quot;, v-&gt;iv, sizeof v-&gt;iv);
-        hexdump(stderr, &quot;in&quot;, v-&gt;in, v-&gt;length);
+        test_output_memory(&quot;key 1&quot;, v-&gt;key1, sizeof v-&gt;key1);
+        test_output_memory(&quot;key 2&quot;, v-&gt;key2, sizeof v-&gt;key2);
+        test_output_memory(&quot;iv&quot;, v-&gt;iv, sizeof v-&gt;iv);
+        test_output_memory(&quot;in&quot;, v-&gt;in, v-&gt;length);
         return 0;
     }
 
diff --git a/test/srptest.c b/test/srptest.c
index 3e3b589..ed5bf61 100644
--- a/test/srptest.c
+++ b/test/srptest.c
@@ -18,22 +18,6 @@
 # include &lt;openssl/rand.h&gt;
 # include &lt;openssl/err.h&gt;
 
-static void showbn(const char *name, const BIGNUM *bn)
-{
-    BIO *b;
-    const char *text;
-
-    if (!TEST_ptr(b = BIO_new(BIO_s_mem())))
-        return;
-    BIO_write(b, name, strlen(name));
-    BIO_write(b, &quot; = &quot;, 3);
-    BN_print(b, bn);
-    BIO_write(b, &quot;\0&quot;, 1);
-    BIO_get_mem_data(b, &amp;text);
-    TEST_info(&quot;%s&quot;, text);
-    BIO_free(b);
-}
-
 # define RANDOM_SIZE 32         /* use 256 bits on each side */
 
 static int run_srp(const char *username, const char *client_pass,
@@ -62,21 +46,21 @@ static int run_srp(const char *username, const char *client_pass,
                                           &amp;s, &amp;v, GN-&gt;N, GN-&gt;g)))
         goto end;
 
-    showbn(&quot;N&quot;, GN-&gt;N);
-    showbn(&quot;g&quot;, GN-&gt;g);
-    showbn(&quot;Salt&quot;, s);
-    showbn(&quot;Verifier&quot;, v);
+    test_output_bignum(&quot;N&quot;, GN-&gt;N);
+    test_output_bignum(&quot;g&quot;, GN-&gt;g);
+    test_output_bignum(&quot;Salt&quot;, s);
+    test_output_bignum(&quot;Verifier&quot;, v);
 
     /* Server random */
     RAND_bytes(rand_tmp, sizeof(rand_tmp));
     b = BN_bin2bn(rand_tmp, sizeof(rand_tmp), NULL);
     if (!TEST_BN_ne_zero(b))
         goto end;
-    showbn(&quot;b&quot;, b);
+    test_output_bignum(&quot;b&quot;, b);
 
     /* Server's first message */
     Bpub = SRP_Calc_B(b, GN-&gt;N, GN-&gt;g, v);
-    showbn(&quot;B&quot;, Bpub);
+    test_output_bignum(&quot;B&quot;, Bpub);
 
     if (!TEST_true(SRP_Verify_B_mod_N(Bpub, GN-&gt;N)))
         goto end;
@@ -86,11 +70,11 @@ static int run_srp(const char *username, const char *client_pass,
     a = BN_bin2bn(rand_tmp, sizeof(rand_tmp), NULL);
     if (!TEST_BN_ne_zero(a))
         goto end;
-    showbn(&quot;a&quot;, a);
+    test_output_bignum(&quot;a&quot;, a);
 
     /* Client's response */
     Apub = SRP_Calc_A(a, GN-&gt;N, GN-&gt;g);
-    showbn(&quot;A&quot;, Apub);
+    test_output_bignum(&quot;A&quot;, Apub);
 
     if (!TEST_true(SRP_Verify_A_mod_N(Apub, GN-&gt;N)))
         goto end;
@@ -101,11 +85,11 @@ static int run_srp(const char *username, const char *client_pass,
     /* Client's key */
     x = SRP_Calc_x(s, username, client_pass);
     Kclient = SRP_Calc_client_key(GN-&gt;N, Bpub, GN-&gt;g, x, a, u);
-    showbn(&quot;Client's key&quot;, Kclient);
+    test_output_bignum(&quot;Client's key&quot;, Kclient);
 
     /* Server's key */
     Kserver = SRP_Calc_server_key(Apub, v, u, b, GN-&gt;N);
-    showbn(&quot;Server's key&quot;, Kserver);
+    test_output_bignum(&quot;Server's key&quot;, Kserver);
 
     if (!TEST_BN_eq(Kclient, Kserver))
         goto end;
@@ -164,9 +148,10 @@ static int run_srp_kat(void)
     BN_hex2bn(&amp;s, &quot;BEB25379D1A8581EB5A727673A2441EE&quot;);
     /* Set up server's password entry */
     if (!TEST_true(SRP_create_verifier_BN(&quot;alice&quot;, &quot;password123&quot;, &amp;s, &amp;v, GN-&gt;N,
-                                GN-&gt;g)))
+                                          GN-&gt;g)))
         goto err;
 
+    TEST_info(&quot;checking v&quot;);
     if (!TEST_true(check_bn(&quot;v&quot;, v,
                  &quot;7E273DE8696FFC4F4E337D05B4B375BEB0DDE1569E8FA00A9886D812&quot;
                  &quot;9BADA1F1822223CA1A605B530E379BA4729FDC59F105B4787E5186F5&quot;
@@ -174,6 +159,7 @@ static int run_srp_kat(void)
                  &quot;EA53D15C1AFF87B2B9DA6E04E058AD51CC72BFC9033B564E26480D78&quot;
                  &quot;E955A5E29E7AB245DB2BE315E2099AFB&quot;)))
         goto err;
+    TEST_note(&quot;    okay&quot;);
 
     /* Server random */
     BN_hex2bn(&amp;b, &quot;E487CB59D31AC550471E81F00F6928E01DDA08E974A004F49E61F5D1&quot;
@@ -184,6 +170,7 @@ static int run_srp_kat(void)
     if (!TEST_true(SRP_Verify_B_mod_N(Bpub, GN-&gt;N)))
         goto err;
 
+    TEST_info(&quot;checking B&quot;);
     if (!TEST_true(check_bn(&quot;B&quot;, Bpub,
                   &quot;BD0C61512C692C0CB6D041FA01BB152D4916A1E77AF46AE105393011&quot;
                   &quot;BAF38964DC46A0670DD125B95A981652236F99D9B681CBF87837EC99&quot;
@@ -191,6 +178,7 @@ static int run_srp_kat(void)
                   &quot;37089E6F9C6059F388838E7A00030B331EB76840910440B1B27AAEAE&quot;
                   &quot;EB4012B7D7665238A8E3FB004B117B58&quot;)))
         goto err;
+    TEST_note(&quot;    okay&quot;);
 
     /* Client random */
     BN_hex2bn(&amp;a, &quot;60975527035CF2AD1989806F0407210BC81EDC04E2762A56AFD529DD&quot;
@@ -201,6 +189,7 @@ static int run_srp_kat(void)
     if (!TEST_true(SRP_Verify_A_mod_N(Apub, GN-&gt;N)))
         goto err;
 
+    TEST_info(&quot;checking A&quot;);
     if (!TEST_true(check_bn(&quot;A&quot;, Apub,
                   &quot;61D5E490F6F1B79547B0704C436F523DD0E560F0C64115BB72557EC4&quot;
                   &quot;4352E8903211C04692272D8B2D1A5358A2CF1B6E0BFCF99F921530EC&quot;
@@ -208,6 +197,7 @@ static int run_srp_kat(void)
                   &quot;BE087EF06530E69F66615261EEF54073CA11CF5858F0EDFDFE15EFEA&quot;
                   &quot;B349EF5D76988A3672FAC47B0769447B&quot;)))
         goto err;
+    TEST_note(&quot;    okay&quot;);
 
     /* Both sides calculate u */
     u = SRP_Calc_u(Apub, Bpub, GN-&gt;N);
@@ -219,6 +209,7 @@ static int run_srp_kat(void)
     /* Client's key */
     x = SRP_Calc_x(s, &quot;alice&quot;, &quot;password123&quot;);
     Kclient = SRP_Calc_client_key(GN-&gt;N, Bpub, GN-&gt;g, x, a, u);
+    TEST_info(&quot;checking client's key&quot;);
     if (!TEST_true(check_bn(&quot;Client's key&quot;, Kclient,
                   &quot;B0DC82BABCF30674AE450C0287745E7990A3381F63B387AAF271A10D&quot;
                   &quot;233861E359B48220F7C4693C9AE12B0A6F67809F0876E2D013800D6C&quot;
@@ -226,9 +217,11 @@ static int run_srp_kat(void)
                   &quot;3499B200210DCC1F10EB33943CD67FC88A2F39A4BE5BEC4EC0A3212D&quot;
                   &quot;C346D7E474B29EDE8A469FFECA686E5A&quot;)))
         goto err;
+    TEST_note(&quot;    okay&quot;);
 
     /* Server's key */
     Kserver = SRP_Calc_server_key(Apub, v, u, b, GN-&gt;N);
+    TEST_info(&quot;checking server's key&quot;);
     if (!TEST_true(check_bn(&quot;Server's key&quot;, Kserver,
                   &quot;B0DC82BABCF30674AE450C0287745E7990A3381F63B387AAF271A10D&quot;
                   &quot;233861E359B48220F7C4693C9AE12B0A6F67809F0876E2D013800D6C&quot;
@@ -236,6 +229,7 @@ static int run_srp_kat(void)
                   &quot;3499B200210DCC1F10EB33943CD67FC88A2F39A4BE5BEC4EC0A3212D&quot;
                   &quot;C346D7E474B29EDE8A469FFECA686E5A&quot;)))
         goto err;
+    TEST_note(&quot;    okay&quot;);
 
     ret = 1;
 
@@ -257,10 +251,12 @@ err:
 static int run_srp_tests(void)
 {
     /* &quot;Negative&quot; test, expect a mismatch */
+    TEST_info(&quot;run_srp: expecting a mismatch&quot;);
     if (!TEST_false(run_srp(&quot;alice&quot;, &quot;password1&quot;, &quot;password2&quot;)))
         return 0;
 
     /* &quot;Positive&quot; test, should pass */
+    TEST_info(&quot;run_srp: expecting a match&quot;);
     if (!TEST_true(run_srp(&quot;alice&quot;, &quot;password&quot;, &quot;password&quot;)))
         return 0;
 
diff --git a/test/test_test.c b/test/test_test.c
index a1b0456..051058f 100644
--- a/test/test_test.c
+++ b/test/test_test.c
@@ -477,6 +477,38 @@ static int test_single_eval(void)
            &amp;&amp; TEST_mem_eq(p--, sizeof(&quot;456&quot;), &quot;456&quot;, sizeof(&quot;456&quot;));
 }
 
+static int test_output(void)
+{
+    const char s[] = &quot;1234567890123456789012345678901234567890123456789012&quot;
+                     &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
+
+    test_output_string(&quot;test&quot;, s, sizeof(s) - 1);
+    test_output_memory(&quot;test&quot;, (const unsigned char *)s, sizeof(s));
+    return 1;
+}
+
+static const char *bn_output_tests[] = {
+    NULL,
+    &quot;0&quot;,
+    &quot;-12345678&quot;,
+    &quot;1234567890123456789012345678901234567890123456789012&quot;
+    &quot;1234567890123456789012345678901234567890123456789013&quot;
+    &quot;987657&quot;
+};
+
+static int test_bn_output(int n)
+{
+    BIGNUM *b = NULL;
+
+    if (bn_output_tests[n] != NULL
+            &amp;&amp; !TEST_true(BN_hex2bn(&amp;b, bn_output_tests[n])))
+        return 0;
+    test_output_bignum(bn_output_tests[n], b);
+    BN_free(b);
+    return 1;
+}
+
+
 void register_tests(void)
 {
     ADD_TEST(test_int);
@@ -496,4 +528,6 @@ void register_tests(void)
     ADD_TEST(test_long_output);
     ADD_TEST(test_messages);
     ADD_TEST(test_single_eval);
+    ADD_TEST(test_output);
+    ADD_ALL_TESTS(test_bn_output, OSSL_NELEM(bn_output_tests));
 }
diff --git a/test/testutil.h b/test/testutil.h
index 0975e2b..027c706 100644
--- a/test/testutil.h
+++ b/test/testutil.h
@@ -271,6 +271,7 @@ void test_error_c90(const char *desc, ...) PRINTF_FORMAT(1, 2);
 void test_info(const char *file, int line, const char *desc, ...)
     PRINTF_FORMAT(3, 4);
 void test_info_c90(const char *desc, ...) PRINTF_FORMAT(1, 2);
+void test_note(const char *desc, ...) PRINTF_FORMAT(1, 2);
 void test_openssl_errors(void);
 
 /*
@@ -384,6 +385,7 @@ void test_openssl_errors(void);
 #  define TEST_error(...)    test_error(__FILE__, __LINE__, __VA_ARGS__)
 #  define TEST_info(...)     test_info(__FILE__, __LINE__, __VA_ARGS__)
 # endif
+# define TEST_note           test_note
 # define TEST_openssl_errors test_openssl_errors
 
 /*
@@ -403,6 +405,14 @@ extern BIO *bio_out;
 extern BIO *bio_err;
 
 /*
+ * Formatted output for strings, memory and bignums.
+ */
+void test_output_string(const char *name, const char *m, size_t l);
+void test_output_bignum(const char *name, const BIGNUM *bn);
+void test_output_memory(const char *name, const unsigned char *m, size_t l);
+
+
+/*
  * Utilities to parse a test file.
  */
 #define TESTMAXPAIRS        20
diff --git a/test/testutil/driver.c b/test/testutil/driver.c
index 3b62e59..dc236b7 100644
--- a/test/testutil/driver.c
+++ b/test/testutil/driver.c
@@ -196,6 +196,7 @@ int run_tests(const char *test_prog_name)
             test_printf_stdout(&quot;%*s%s %d - %s\n&quot;, level, &quot;&quot;, verdict, ii + 1,
                                test_title);
             test_flush_stdout();
+            test_flush_stderr();
             finalize(ret);
         } else {
             int num_failed_inner = 0;
diff --git a/test/testutil/format_output.c b/test/testutil/format_output.c
new file mode 100644
index 0000000..ae5fdc9
--- /dev/null
+++ b/test/testutil/format_output.c
@@ -0,0 +1,528 @@
+#include &quot;../testutil.h&quot;
+#include &quot;output.h&quot;
+#include &quot;tu_local.h&quot;
+
+#include &lt;string.h&gt;
+#include &lt;ctype.h&gt;
+#include &quot;../../e_os.h&quot;
+
+/* The size of memory buffers to display on failure */
+#define MEM_BUFFER_SIZE     (2000)
+#define MAX_STRING_WIDTH    (80)
+#define BN_OUTPUT_SIZE      (8)
+
+/* Output a diff header */
+static void test_diff_header(const char *left, const char *right)
+{
+    test_printf_stderr(&quot;%*s# --- %s\n&quot;, subtest_level(), &quot;&quot;, left);
+    test_printf_stderr(&quot;%*s# +++ %s\n&quot;, subtest_level(), &quot;&quot;, right);
+}
+
+/* Formatted string output routines */
+static void test_string_null_empty(const char *m, char c)
+{
+    if (m == NULL)
+        test_printf_stderr(&quot;%*s# % 4s %c NULL\n&quot;, subtest_level(), &quot;&quot;, &quot;&quot;, c);
+    else
+        test_printf_stderr(&quot;%*s# % 4u:%c ''\n&quot;, subtest_level(), &quot;&quot;, 0u, c);
+}
+
+static void test_fail_string_common(const char *prefix, const char *file,
+                                    int line, const char *type,
+                                    const char *left, const char *right,
+                                    const char *op, const char *m1, size_t l1,
+                                    const char *m2, size_t l2)
+{
+    const int indent = subtest_level();
+    const size_t width = (MAX_STRING_WIDTH - indent - 12) / 16 * 16;
+    char b1[MAX_STRING_WIDTH + 1], b2[MAX_STRING_WIDTH + 1];
+    char bdiff[MAX_STRING_WIDTH + 1];
+    size_t n1, n2, i;
+    unsigned int cnt = 0, diff;
+
+    test_fail_message_prefix(prefix, file, line, type, left, right, op);
+    if (m1 == NULL)
+        l1 = 0;
+    if (m2 == NULL)
+        l2 = 0;
+    if (l1 == 0 &amp;&amp; l2 == 0) {
+        if ((m1 == NULL) == (m2 == NULL)) {
+            test_string_null_empty(m1, ' ');
+        } else {
+            test_diff_header(left, right);
+            test_string_null_empty(m1, '-');
+            test_string_null_empty(m2, '+');
+        }
+        goto fin;
+    }
+
+    if (l1 != l2 || strcmp(m1, m2) != 0)
+        test_diff_header(left, right);
+
+    while (l1 &gt; 0 || l2 &gt; 0) {
+        n1 = n2 = 0;
+        if (l1 &gt; 0) {
+            b1[n1 = l1 &gt; width ? width : l1] = 0;
+            for (i = 0; i &lt; n1; i++)
+                b1[i] = isprint(m1[i]) ? m1[i] : '.';
+        }
+        if (l2 &gt; 0) {
+            b2[n2 = l2 &gt; width ? width : l2] = 0;
+            for (i = 0; i &lt; n2; i++)
+                b2[i] = isprint(m2[i]) ? m2[i] : '.';
+        }
+        diff = 0;
+        i = 0;
+        if (n1 &gt; 0 &amp;&amp; n2 &gt; 0) {
+            const size_t j = n1 &lt; n2 ? n1 : n2;
+
+            for (; i &lt; j; i++)
+                if (m1[i] == m2[i]) {
+                    bdiff[i] = ' ';
+                } else {
+                    bdiff[i] = '^';
+                    diff = 1;
+                }
+            bdiff[i] = '\0';
+        }
+        if (n1 == n2 &amp;&amp; !diff) {
+            test_printf_stderr(&quot;%*s# % 4u:  '%s'\n&quot;, indent, &quot;&quot;, cnt,
+                               n2 &gt; n1 ? b2 : b1);
+        } else {
+            if (cnt == 0 &amp;&amp; (m1 == NULL || *m1 == '\0'))
+                test_string_null_empty(m1, '-');
+            else if (n1 &gt; 0)
+                test_printf_stderr(&quot;%*s# % 4u:- '%s'\n&quot;, indent, &quot;&quot;, cnt, b1);
+            if (cnt == 0 &amp;&amp; (m2 == NULL || *m2 == '\0'))
+               test_string_null_empty(m2, '+');
+            else if (n2 &gt; 0)
+                test_printf_stderr(&quot;%*s# % 4u:+ '%s'\n&quot;, indent, &quot;&quot;, cnt, b2);
+            if (diff &amp;&amp; i &gt; 0)
+                test_printf_stderr(&quot;%*s# % 4s    %s\n&quot;, indent, &quot;&quot;, &quot;&quot;, bdiff);
+        }
+        m1 += n1;
+        m2 += n2;
+        l1 -= n1;
+        l2 -= n2;
+        cnt += width;
+    }
+fin:
+    test_flush_stderr();
+}
+
+/*
+ * Wrapper routines so that the underlying code can be shared.
+ * The first is the call from inside the test utilities when a conditional
+ * fails.  The second is the user's call to dump a string.
+ */
+void test_fail_string_message(const char *prefix, const char *file,
+                              int line, const char *type,
+                              const char *left, const char *right,
+                              const char *op, const char *m1, size_t l1,
+                              const char *m2, size_t l2)
+{
+    test_fail_string_common(prefix, file, line, type, left, right, op,
+                            m1, l1, m2, l2);
+    test_printf_stderr(&quot;\n&quot;);
+}
+
+void test_output_string(const char *name, const char *m, size_t l)
+{
+    test_fail_string_common(&quot;string&quot;, NULL, 0, NULL, NULL, NULL, name,
+                            m, l, m, l);
+}
+
+/* BIGNUM formatted output routines */
+
+/*
+ * A basic memory byte to hex digit converter with allowance for spacing
+ * every so often.
+ */
+static void hex_convert_memory(const unsigned char *m, size_t n, char *b,
+                               size_t width)
+{
+    size_t i;
+
+    for (i = 0; i &lt; n; i++) {
+        const unsigned char c = *m++;
+
+        *b++ = &quot;0123456789abcdef&quot;[c &gt;&gt; 4];
+        *b++ = &quot;0123456789abcdef&quot;[c &amp; 15];
+        if (i % width == width - 1 &amp;&amp; i != n - 1)
+            *b++ = ' ';
+    }
+    *b = '\0';
+}
+
+/*
+ * Constants to define the number of bytes to display per line and the number
+ * of characters these take.
+ */
+static const int bn_bytes = (MAX_STRING_WIDTH - 9) / (BN_OUTPUT_SIZE * 2 + 1)
+                            * BN_OUTPUT_SIZE;
+static const int bn_chars = (MAX_STRING_WIDTH - 9) / (BN_OUTPUT_SIZE * 2 + 1)
+                            * (BN_OUTPUT_SIZE * 2 + 1) - 1;
+
+/*
+ * Output the header line for the bignum
+ */
+static void test_bignum_header_line(void)
+{
+    test_printf_stderr(&quot;%*s#  %*s\n&quot;, subtest_level(), &quot;&quot;, bn_chars + 6,
+                       &quot;bit position&quot;);
+}
+
+static const char *test_bignum_zero_null(const BIGNUM *bn)
+{
+    if (bn != NULL)
+        return BN_is_negative(bn) ? &quot;-0&quot; : &quot;0&quot;;
+    return &quot;NULL&quot;;
+}
+
+/*
+ * Print a bignum zero taking care to include the correct sign.
+ * This routine correctly deals with a NULL bignum pointer as input.
+ */
+static void test_bignum_zero_print(const BIGNUM *bn, char sep)
+{
+    const char *v = test_bignum_zero_null(bn);
+    const char *suf = bn != NULL ? &quot;:    0&quot; : &quot;&quot;;
+
+    test_printf_stderr(&quot;%*s# %c%*s%s\n&quot;, subtest_level(), &quot;&quot;, sep, bn_chars,
+                       v, suf);
+}
+
+/*
+ * Convert a section of memory from inside a bignum into a displayable
+ * string with appropriate visual aid spaces inserted.
+ */
+static int convert_bn_memory(const unsigned char *in, size_t bytes,
+                             char *out, int *lz, const BIGNUM *bn)
+{
+    int n = bytes * 2, i;
+    char *p = out, *q = NULL;
+
+    if (bn != NULL &amp;&amp; !BN_is_zero(bn)) {
+        hex_convert_memory(in, bytes, out, BN_OUTPUT_SIZE);
+        if (*lz) {
+            for (; *p == '0' || *p == ' '; p++)
+                if (*p == '0') {
+                    q = p;
+                    *p = ' ';
+                    n--;
+                }
+            if (*p == '\0') {
+                /*
+                 * in[bytes] is defined because we're converting a non-zero
+                 * number and we've not seen a non-zero yet.
+                 */
+                if ((in[bytes] &amp; 0xf0) != 0 &amp;&amp; BN_is_negative(bn)) {
+                    *lz = 0;
+                    *q = '-';
+                    n++;
+                }
+            } else {
+                *lz = 0;
+                if (BN_is_negative(bn)) {
+                    /*
+                     * This is valid because we always convert more digits than
+                     * the number holds.
+                     */
+                    *q = '-';
+                    n++;
+                }
+            }
+        }
+       return n;
+    }
+
+    for (i = 0; i &lt; n; i++) {
+        *p++ = ' ';
+        if (i % (2 * BN_OUTPUT_SIZE) == 2 * BN_OUTPUT_SIZE - 1 &amp;&amp; i != n - 1)
+            *p++ = ' ';
+    }
+    *p = '\0';
+    if (bn == NULL)
+        q = &quot;NULL&quot;;
+    else
+        q = BN_is_negative(bn) ? &quot;-0&quot; : &quot;0&quot;;
+    strcpy(p - strlen(q), q);
+    return 0;
+}
+
+/*
+ * Common code to display either one or two bignums, including the diff
+ * pointers for changes (only when there are two).
+ */
+static void test_fail_bignum_common(const char *prefix, const char *file,
+                                    int line, const char *type,
+                                    const char *left, const char *right,
+                                    const char *op,
+                                    const BIGNUM *bn1, const BIGNUM *bn2)
+{
+    const int indent = subtest_level();
+    const size_t bytes = bn_bytes;
+    char b1[MAX_STRING_WIDTH + 1], b2[MAX_STRING_WIDTH + 1];
+    char *p, bdiff[MAX_STRING_WIDTH + 1];
+    size_t l1, l2, n1, n2, i, len;
+    unsigned int cnt, diff, real_diff;
+    unsigned char *m1 = NULL, *m2 = NULL;
+    int lz1 = 1, lz2 = 1;
+    unsigned char buffer[MEM_BUFFER_SIZE * 2], *bufp = buffer;
+
+    test_fail_message_prefix(prefix, file, line, type, left, right, op);
+    l1 = bn1 == NULL ? 0 : (BN_num_bytes(bn1) + (BN_is_negative(bn1) ? 1 : 0));
+    l2 = bn2 == NULL ? 0 : (BN_num_bytes(bn2) + (BN_is_negative(bn2) ? 1 : 0));
+    if (l1 == 0 &amp;&amp; l2 == 0) {
+        if ((bn1 == NULL) == (bn2 == NULL)) {
+            test_bignum_header_line();
+            test_bignum_zero_print(bn1, ' ');
+        } else {
+            test_diff_header(left, right);
+            test_bignum_header_line();
+            test_bignum_zero_print(bn1, '-');
+            test_bignum_zero_print(bn2, '+');
+        }
+        goto fin;
+    }
+
+    if (l1 != l2 || bn1 == NULL || bn2 == NULL || BN_cmp(bn1, bn2) != 0)
+        test_diff_header(left, right);
+    test_bignum_header_line();
+
+    len = ((l1 &gt; l2 ? l1 : l2) + bytes - 1) / bytes * bytes;
+
+    if (len &gt; MEM_BUFFER_SIZE &amp;&amp; (bufp = OPENSSL_malloc(len * 2)) == NULL) {
+        bufp = buffer;
+        len = MEM_BUFFER_SIZE;
+        test_printf_stderr(&quot;%*s# WARNING: these BIGNUMs have been truncated&quot;,
+                           indent, &quot;&quot;);
+    }
+
+    if (bn1 != NULL) {
+        m1 = bufp;
+        BN_bn2binpad(bn1, m1, len);
+    }
+    if (bn2 != NULL) {
+        m2 = bufp + len;
+        BN_bn2binpad(bn2, m2, len);
+    }
+
+    while (len &gt; 0) {
+        cnt = 8 * (len - bytes);
+        n1 = convert_bn_memory(m1, bytes, b1, &amp;lz1, bn1);
+        n2 = convert_bn_memory(m2, bytes, b2, &amp;lz2, bn2);
+
+        diff = real_diff = 0;
+        i = 0;
+        p = bdiff;
+        for (i=0; b1[i] != '\0'; i++)
+            if (b1[i] == b2[i] || b1[i] == ' ' || b2[i] == ' ') {
+                *p++ = ' ';
+                diff |= b1[i] != b2[i];
+            } else {
+                *p++ = '^';
+                real_diff = diff = 1;
+            }
+        *p++ = '\0';
+        if (!diff) {
+            test_printf_stderr(&quot;%*s#  %s:% 5d\n&quot;, indent, &quot;&quot;,
+                               n2 &gt; n1 ? b2 : b1, cnt);
+        } else {
+            if (cnt == 0 &amp;&amp; bn1 == NULL)
+                test_printf_stderr(&quot;%*s# -%s\n&quot;, indent, &quot;&quot;, b1);
+            else if (cnt == 0 || n1 &gt; 0)
+                test_printf_stderr(&quot;%*s# -%s:% 5d\n&quot;, indent, &quot;&quot;, b1, cnt);
+            if (cnt == 0 &amp;&amp; bn2 == NULL)
+                test_printf_stderr(&quot;%*s# +%s\n&quot;, indent, &quot;&quot;, b2);
+            else if (cnt == 0 || n2 &gt; 0)
+                test_printf_stderr(&quot;%*s# +%s:% 5d\n&quot;, indent, &quot;&quot;, b2, cnt);
+            if (real_diff &amp;&amp; (cnt == 0 || (n1 &gt; 0 &amp;&amp; n2 &gt; 0))
+                    &amp;&amp; bn1 != NULL &amp;&amp; bn2 != NULL)
+                test_printf_stderr(&quot;%*s#  %s\n&quot;, indent, &quot;&quot;, bdiff);
+        }
+        if (m1 != NULL)
+            m1 += bytes;
+        if (m2 != NULL)
+            m2 += bytes;
+        len -= bytes;
+    }
+fin:
+    test_flush_stderr();
+    if (bufp != buffer)
+        OPENSSL_free(bufp);
+}
+
+/*
+ * Wrapper routines so that the underlying code can be shared.
+ * The first two are calls from inside the test utilities when a conditional
+ * fails.  The third is the user's call to dump a bignum.
+ */
+void test_fail_bignum_message(const char *prefix, const char *file,
+                              int line, const char *type,
+                              const char *left, const char *right,
+                              const char *op,
+                              const BIGNUM *bn1, const BIGNUM *bn2)
+{
+    test_fail_bignum_common(prefix, file, line, type, left, right, op, bn1, bn2);
+    test_printf_stderr(&quot;\n&quot;);
+}
+
+void test_fail_bignum_mono_message(const char *prefix, const char *file,
+                                   int line, const char *type,
+                                   const char *left, const char *right,
+                                   const char *op, const BIGNUM *bn)
+{
+    test_fail_bignum_common(prefix, file, line, type, left, right, op, bn, bn);
+    test_printf_stderr(&quot;\n&quot;);
+}
+
+void test_output_bignum(const char *name, const BIGNUM *bn)
+{
+    if (bn == NULL || BN_is_zero(bn)) {
+        test_printf_stderr(&quot;%*s# bignum: '%s' = %s\n&quot;, subtest_level(), &quot;&quot;,
+                           name, test_bignum_zero_null(bn));
+    } else if (BN_num_bytes(bn) &lt;= BN_OUTPUT_SIZE) {
+        unsigned char buf[BN_OUTPUT_SIZE];
+        char out[2 * sizeof(buf) + 1];
+        char *p = out;
+        int n = BN_bn2bin(bn, buf);
+
+        hex_convert_memory(buf, n, p, BN_OUTPUT_SIZE);
+        while (*p == '0' &amp;&amp; *++p != '\0')
+            ;
+        test_printf_stderr(&quot;%*s# bignum: '%s' = %s0x%s\n&quot;, subtest_level(), &quot;&quot;,
+                           name, BN_is_negative(bn) ? &quot;-&quot; : &quot;&quot;, p);
+    } else {
+        test_fail_bignum_common(&quot;bignum&quot;, NULL, 0, NULL, NULL, NULL, name,
+                                bn, bn);
+    }
+}
+
+/* Memory output routines */
+
+/*
+ * Handle zero length blocks of memory or NULL pointers to memory
+ */
+static void test_memory_null_empty(const unsigned char *m, int indent, char c)
+{
+    if (m == NULL)
+        test_printf_stderr(&quot;%*s# % 4s %c%s\n&quot;, indent, &quot;&quot;, &quot;&quot;, c, &quot;NULL&quot;);
+    else
+        test_printf_stderr(&quot;%*s# %04x %c%s\n&quot;, indent, &quot;&quot;, 0u, c, &quot;empty&quot;);
+}
+
+/*
+ * Common code to display one or two blocks of memory.
+ */
+static void test_fail_memory_common(const char *prefix, const char *file,
+                                    int line, const char *type,
+                                    const char *left, const char *right,
+                                    const char *op,
+                                    const unsigned char *m1, size_t l1,
+                                    const unsigned char *m2, size_t l2)
+{
+    const int indent = subtest_level();
+    const size_t bytes = (MAX_STRING_WIDTH - 9) / 17 * 8;
+    char b1[MAX_STRING_WIDTH + 1], b2[MAX_STRING_WIDTH + 1];
+    char *p, bdiff[MAX_STRING_WIDTH + 1];
+    size_t n1, n2, i;
+    unsigned int cnt = 0, diff;
+
+    test_fail_message_prefix(prefix, file, line, type, left, right, op);
+    if (m1 == NULL)
+        l1 = 0;
+    if (m2 == NULL)
+        l2 = 0;
+    if (l1 == 0 &amp;&amp; l2 == 0) {
+        if ((m1 == NULL) == (m2 == NULL)) {
+            test_memory_null_empty(m1, indent, ' ');
+        } else {
+            test_diff_header(left, right);
+            test_memory_null_empty(m1, indent, '-');
+            test_memory_null_empty(m2, indent, '+');
+        }
+        goto fin;
+    }
+
+    if (l1 != l2 || (m1 != m2 &amp;&amp; memcmp(m1, m2, l1) != 0))
+        test_diff_header(left, right);
+
+    while (l1 &gt; 0 || l2 &gt; 0) {
+        n1 = n2 = 0;
+        if (l1 &gt; 0) {
+            n1 = l1 &gt; bytes ? bytes : l1;
+            hex_convert_memory(m1, n1, b1, 8);
+        }
+        if (l2 &gt; 0) {
+            n2 = l2 &gt; bytes ? bytes : l2;
+            hex_convert_memory(m2, n2, b2, 8);
+        }
+
+        diff = 0;
+        i = 0;
+        p = bdiff;
+        if (n1 &gt; 0 &amp;&amp; n2 &gt; 0) {
+            const size_t j = n1 &lt; n2 ? n1 : n2;
+
+            for (; i &lt; j; i++) {
+                if (m1[i] == m2[i]) {
+                    *p++ = ' ';
+                    *p++ = ' ';
+                } else {
+                    *p++ = '^';
+                    *p++ = '^';
+                    diff = 1;
+                }
+                if (i % 8 == 7 &amp;&amp; i != j - 1)
+                    *p++ = ' ';
+            }
+            *p++ = '\0';
+        }
+
+        if (n1 == n2 &amp;&amp; !diff) {
+            test_printf_stderr(&quot;%*s# %04x: %s\n&quot;, indent, &quot;&quot;, cnt, b1);
+        } else {
+            if (cnt == 0 &amp;&amp; (m1 == NULL || l1 == 0))
+                test_memory_null_empty(m1, indent, '-');
+            else if (n1 &gt; 0)
+                test_printf_stderr(&quot;%*s# %04x:-%s\n&quot;, indent, &quot;&quot;, cnt, b1);
+            if (cnt == 0 &amp;&amp; (m2 == NULL || l2 == 0))
+                test_memory_null_empty(m2, indent, '+');
+            else if (n2 &gt; 0)
+                test_printf_stderr(&quot;%*s# %04x:+%s\n&quot;, indent, &quot;&quot;, cnt, b2);
+            if (diff &amp;&amp; i &gt; 0)
+                test_printf_stderr(&quot;%*s# % 4s  %s\n&quot;, indent, &quot;&quot;, &quot;&quot;, bdiff);
+        }
+        m1 += n1;
+        m2 += n2;
+        l1 -= n1;
+        l2 -= n2;
+        cnt += bytes;
+    }
+fin:
+    test_flush_stderr();
+}
+
+/*
+ * Wrapper routines so that the underlying code can be shared.
+ * The first is the call from inside the test utilities when a conditional
+ * fails.  The second is the user's call to dump memory.
+ */
+void test_fail_memory_message(const char *prefix, const char *file,
+                              int line, const char *type,
+                              const char *left, const char *right,
+                              const char *op,
+                              const unsigned char *m1, size_t l1,
+                              const unsigned char *m2, size_t l2)
+{
+    test_fail_memory_common(prefix, file, line, type, left, right, op,
+                            m1, l1, m2, l2);
+    test_printf_stderr(&quot;\n&quot;);
+}
+
+void test_output_memory(const char *name, const unsigned char *m, size_t l)
+{
+    test_fail_memory_common(&quot;memory&quot;, NULL, 0, NULL, NULL, NULL, name,
+                            m, l, m, l);
+}
diff --git a/test/testutil/tests.c b/test/testutil/tests.c
index a5538e7..3f66b3e 100644
--- a/test/testutil/tests.c
+++ b/test/testutil/tests.c
@@ -15,36 +15,33 @@
 #include &lt;ctype.h&gt;
 #include &quot;../../e_os.h&quot;
 
-/* The size of memory buffers to display on failure */
-#define MEM_BUFFER_SIZE     (2000)
-#define MAX_STRING_WIDTH    (80)
-#define BN_OUTPUT_SIZE      (8)
-
-/* Output a failed test first line */
-static void test_fail_message_prefix(const char *prefix, const char *file,
-                                     int line, const char *type,
-                                     const char *left, const char *right,
-                                     const char *op)
+/*
+ * Output a failed test first line.
+ * All items are optional are generally not preinted if passed as NULL.
+ * The special cases are for prefix where &quot;ERROR&quot; is assumed and for left
+ * and right where a non-failure message is produced if either is NULL.
+ */
+void test_fail_message_prefix(const char *prefix, const char *file,
+                              int line, const char *type,
+                              const char *left, const char *right,
+                              const char *op)
 {
     test_printf_stderr(&quot;%*s# %s: &quot;, subtest_level(), &quot;&quot;,
                        prefix != NULL ? prefix : &quot;ERROR&quot;);
     if (type)
         test_printf_stderr(&quot;(%s) &quot;, type);
-    if (op != NULL)
-        test_printf_stderr(&quot;'%s %s %s' failed&quot;, left, op, right);
+    if (op != NULL) {
+        if (left != NULL &amp;&amp; right != NULL)
+            test_printf_stderr(&quot;'%s %s %s' failed&quot;, left, op, right);
+        else
+            test_printf_stderr(&quot;'%s'&quot;, op);
+    }
     if (file != NULL) {
         test_printf_stderr(&quot; @ %s:%d&quot;, file, line);
     }
     test_printf_stderr(&quot;\n&quot;);
 }
 
-/* Output a diff header */
-static void test_diff_header(const char *left, const char *right)
-{
-    test_printf_stderr(&quot;%*s# --- %s\n&quot;, subtest_level(), &quot;&quot;, left);
-    test_printf_stderr(&quot;%*s# +++ %s\n&quot;, subtest_level(), &quot;&quot;, right);
-}
-
 /*
  * A common routine to output test failure messages.  Generally this should not
  * be called directly, rather it should be called by the following functions.
@@ -85,407 +82,6 @@ static void test_fail_message_va(const char *prefix, const char *file,
         test_vprintf_stderr(fmt, ap);
         test_printf_stderr(&quot;\n&quot;);
     }
-    test_printf_stderr(&quot;\n&quot;);
-    test_flush_stderr();
-}
-
-static void test_string_null_empty(const char *m, int indent, char c)
-{
-    if (m == NULL)
-        test_printf_stderr(&quot;%*s# % 4s %c NULL\n&quot;, indent, &quot;&quot;, &quot;&quot;, c);
-    else
-        test_printf_stderr(&quot;%*s# % 4u:%c ''\n&quot;, indent, &quot;&quot;, 0u, c);
-}
-
-static void test_fail_string_message(const char *prefix, const char *file,
-                                     int line, const char *type,
-                                     const char *left, const char *right,
-                                     const char *op, const char *m1, size_t l1,
-                                     const char *m2, size_t l2)
-{
-    const int indent = subtest_level();
-    const size_t width = (MAX_STRING_WIDTH - indent - 12) / 16 * 16;
-    char b1[MAX_STRING_WIDTH + 1], b2[MAX_STRING_WIDTH + 1];
-    char bdiff[MAX_STRING_WIDTH + 1];
-    size_t n1, n2, i;
-    unsigned int cnt = 0, diff;
-
-    test_fail_message_prefix(prefix, file, line, type, left, right, op);
-    if (m1 == NULL)
-        l1 = 0;
-    if (m2 == NULL)
-        l2 = 0;
-    if (l1 == 0 &amp;&amp; l2 == 0) {
-        if ((m1 == NULL) == (m2 == NULL)) {
-            test_string_null_empty(m1, indent, ' ');
-        } else {
-            test_diff_header(left, right);
-            test_string_null_empty(m1, indent, '-');
-            test_string_null_empty(m2, indent, '+');
-        }
-        goto fin;
-    }
-
-    if (l1 != l2 || strcmp(m1, m2) != 0)
-        test_diff_header(left, right);
-
-    while (l1 &gt; 0 || l2 &gt; 0) {
-        n1 = n2 = 0;
-        if (l1 &gt; 0) {
-            b1[n1 = l1 &gt; width ? width : l1] = 0;
-            for (i = 0; i &lt; n1; i++)
-                b1[i] = isprint(m1[i]) ? m1[i] : '.';
-        }
-        if (l2 &gt; 0) {
-            b2[n2 = l2 &gt; width ? width : l2] = 0;
-            for (i = 0; i &lt; n2; i++)
-                b2[i] = isprint(m2[i]) ? m2[i] : '.';
-        }
-        diff = 0;
-        i = 0;
-        if (n1 &gt; 0 &amp;&amp; n2 &gt; 0) {
-            const size_t j = n1 &lt; n2 ? n1 : n2;
-
-            for (; i &lt; j; i++)
-                if (m1[i] == m2[i]) {
-                    bdiff[i] = ' ';
-                } else {
-                    bdiff[i] = '^';
-                    diff = 1;
-                }
-            bdiff[i] = '\0';
-        }
-        if (n1 == n2 &amp;&amp; !diff) {
-            test_printf_stderr(&quot;%*s# % 4u:  '%s'\n&quot;, indent, &quot;&quot;, cnt,
-                               n2 &gt; n1 ? b2 : b1);
-        } else {
-            if (cnt == 0 &amp;&amp; (m1 == NULL || *m1 == '\0'))
-                test_string_null_empty(m1, indent, '-');
-            else if (n1 &gt; 0)
-                test_printf_stderr(&quot;%*s# % 4u:- '%s'\n&quot;, indent, &quot;&quot;, cnt, b1);
-            if (cnt == 0 &amp;&amp; (m2 == NULL || *m2 == '\0'))
-               test_string_null_empty(m2, indent, '+');
-            else if (n2 &gt; 0)
-                test_printf_stderr(&quot;%*s# % 4u:+ '%s'\n&quot;, indent, &quot;&quot;, cnt, b2);
-            if (diff &amp;&amp; i &gt; 0)
-                test_printf_stderr(&quot;%*s# % 4s    %s\n&quot;, indent, &quot;&quot;, &quot;&quot;, bdiff);
-        }
-        m1 += n1;
-        m2 += n2;
-        l1 -= n1;
-        l2 -= n2;
-        cnt += width;
-    }
-fin:
-    test_printf_stderr(&quot;\n&quot;);
-    test_flush_stderr();
-}
-
-static void hex_convert_memory(const unsigned char *m, size_t n, char *b,
-                               size_t width)
-{
-    size_t i;
-
-    for (i = 0; i &lt; n; i++) {
-        const unsigned char c = *m++;
-
-        *b++ = &quot;0123456789abcdef&quot;[c &gt;&gt; 4];
-        *b++ = &quot;0123456789abcdef&quot;[c &amp; 15];
-        if (i % width == width - 1 &amp;&amp; i != n - 1)
-            *b++ = ' ';
-    }
-    *b = '\0';
-}
-
-static const int bn_bytes = (MAX_STRING_WIDTH - 9) / (BN_OUTPUT_SIZE * 2 + 1)
-                            * BN_OUTPUT_SIZE;
-static const int bn_chars = (MAX_STRING_WIDTH - 9) / (BN_OUTPUT_SIZE * 2 + 1)
-                            * (BN_OUTPUT_SIZE * 2 + 1) - 1;
-
-static void test_bignum_header_line(void)
-{
-    test_printf_stderr(&quot;%*s#  %*s\n&quot;, subtest_level(), &quot;&quot;, bn_chars + 6,
-                       &quot;bit position&quot;);
-}
-
-static void test_bignum_zero_print(const BIGNUM *bn, char sep)
-{
-    const char *v = &quot;NULL&quot;, *suf = &quot;&quot;;
-    if (bn != NULL) {
-        suf = &quot;:    0&quot;;
-        v = BN_is_negative(bn) ? &quot;-0&quot; : &quot;0&quot;;
-    }
-    test_printf_stderr(&quot;%*s# %c%*s%s\n&quot;, subtest_level(), &quot;&quot;, sep, bn_chars,
-                       v, suf);
-}
-
-static int convert_bn_memory(const unsigned char *in, size_t bytes,
-                             char *out, int *lz, const BIGNUM *bn)
-{
-    int n = bytes * 2, i;
-    char *p = out, *q = NULL;
-
-    if (bn != NULL &amp;&amp; !BN_is_zero(bn)) {
-        hex_convert_memory(in, bytes, out, BN_OUTPUT_SIZE);
-        if (*lz) {
-            for (; *p == '0' || *p == ' '; p++)
-                if (*p == '0') {
-                    q = p;
-                    *p = ' ';
-                    n--;
-                }
-            if (*p == '\0') {
-                /*
-                 * in[bytes] is defined because we're converting a non-zero
-                 * number and we've not seen a non-zero yet.
-                 */
-                if ((in[bytes] &amp; 0xf0) != 0 &amp;&amp; BN_is_negative(bn)) {
-                    *lz = 0;
-                    *q = '-';
-                    n++;
-                }
-            } else {
-                *lz = 0;
-                if (BN_is_negative(bn)) {
-                    /*
-                     * This is valid because we always convert more digits than
-                     * the number holds.
-                     */
-                    *q = '-';
-                    n++;
-                }
-            }
-        }
-       return n;
-    }
-
-    for (i = 0; i &lt; n; i++) {
-        *p++ = ' ';
-        if (i % (2 * BN_OUTPUT_SIZE) == 2 * BN_OUTPUT_SIZE - 1 &amp;&amp; i != n - 1)
-            *p++ = ' ';
-    }
-    *p = '\0';
-    if (bn == NULL)
-        q = &quot;NULL&quot;;
-    else
-        q = BN_is_negative(bn) ? &quot;-0&quot; : &quot;0&quot;;
-    strcpy(p - strlen(q), q);
-    return 0;
-}
-
-static void test_fail_bignum_common(const char *prefix, const char *file,
-                                    int line, const char *type,
-                                    const char *left, const char *right,
-                                    const char *op,
-                                    const BIGNUM *bn1, const BIGNUM *bn2)
-{
-    const int indent = subtest_level();
-    const size_t bytes = bn_bytes;
-    char b1[MAX_STRING_WIDTH + 1], b2[MAX_STRING_WIDTH + 1];
-    char *p, bdiff[MAX_STRING_WIDTH + 1];
-    size_t l1, l2, n1, n2, i, len;
-    unsigned int cnt, diff, real_diff;
-    unsigned char *m1 = NULL, *m2 = NULL;
-    int lz1 = 1, lz2 = 1;
-    unsigned char buffer[MEM_BUFFER_SIZE * 2], *bufp = buffer;
-
-    l1 = bn1 == NULL ? 0 : (BN_num_bytes(bn1) + (BN_is_negative(bn1) ? 1 : 0));
-    l2 = bn2 == NULL ? 0 : (BN_num_bytes(bn2) + (BN_is_negative(bn2) ? 1 : 0));
-    if (l1 == 0 &amp;&amp; l2 == 0) {
-        if ((bn1 == NULL) == (bn2 == NULL)) {
-            test_bignum_header_line();
-            test_bignum_zero_print(bn1, ' ');
-        } else {
-            test_diff_header(left, right);
-            test_bignum_header_line();
-            test_bignum_zero_print(bn1, '-');
-            test_bignum_zero_print(bn2, '+');
-        }
-        goto fin;
-    }
-
-    if (l1 != l2 || bn1 == NULL || bn2 == NULL || BN_cmp(bn1, bn2) != 0)
-        test_diff_header(left, right);
-    test_bignum_header_line();
-
-    len = ((l1 &gt; l2 ? l1 : l2) + bytes - 1) / bytes * bytes;
-
-    if (len &gt; MEM_BUFFER_SIZE &amp;&amp; (bufp = OPENSSL_malloc(len * 2)) == NULL) {
-        bufp = buffer;
-        len = MEM_BUFFER_SIZE;
-        test_printf_stderr(&quot;%*s# WARNING: these BIGNUMs have been truncated&quot;,
-                           indent, &quot;&quot;);
-    }
-
-    if (bn1 != NULL) {
-        m1 = bufp;
-        BN_bn2binpad(bn1, m1, len);
-    }
-    if (bn2 != NULL) {
-        m2 = bufp + len;
-        BN_bn2binpad(bn2, m2, len);
-    }
-
-    while (len &gt; 0) {
-        cnt = 8 * (len - bytes);
-        n1 = convert_bn_memory(m1, bytes, b1, &amp;lz1, bn1);
-        n2 = convert_bn_memory(m2, bytes, b2, &amp;lz2, bn2);
-
-        diff = real_diff = 0;
-        i = 0;
-        p = bdiff;
-        for (i=0; b1[i] != '\0'; i++)
-            if (b1[i] == b2[i] || b1[i] == ' ' || b2[i] == ' ') {
-                *p++ = ' ';
-                diff |= b1[i] != b2[i];
-            } else {
-                *p++ = '^';
-                real_diff = diff = 1;
-            }
-        *p++ = '\0';
-        if (!diff) {
-            test_printf_stderr(&quot;%*s#  %s:% 5d\n&quot;, indent, &quot;&quot;,
-                               n2 &gt; n1 ? b2 : b1, cnt);
-        } else {
-            if (cnt == 0 &amp;&amp; bn1 == NULL)
-                test_printf_stderr(&quot;%*s# -%s\n&quot;, indent, &quot;&quot;, b1);
-            else if (cnt == 0 || n1 &gt; 0)
-                test_printf_stderr(&quot;%*s# -%s:% 5d\n&quot;, indent, &quot;&quot;, b1, cnt);
-            if (cnt == 0 &amp;&amp; bn2 == NULL)
-                test_printf_stderr(&quot;%*s# +%s\n&quot;, indent, &quot;&quot;, b2);
-            else if (cnt == 0 || n2 &gt; 0)
-                test_printf_stderr(&quot;%*s# +%s:% 5d\n&quot;, indent, &quot;&quot;, b2, cnt);
-            if (real_diff &amp;&amp; (cnt == 0 || (n1 &gt; 0 &amp;&amp; n2 &gt; 0))
-                    &amp;&amp; bn1 != NULL &amp;&amp; bn2 != NULL)
-                test_printf_stderr(&quot;%*s#  %s\n&quot;, indent, &quot;&quot;, bdiff);
-        }
-        if (m1 != NULL)
-            m1 += bytes;
-        if (m2 != NULL)
-            m2 += bytes;
-        len -= bytes;
-    }
-fin:
-    test_printf_stderr(&quot;\n&quot;);
-    test_flush_stderr();
-    if (bufp != buffer)
-        OPENSSL_free(bufp);
-}
-
-static void test_fail_bignum_message(const char *prefix, const char *file,
-                                     int line, const char *type,
-                                     const char *left, const char *right,
-                                     const char *op,
-                                     const BIGNUM *bn1, const BIGNUM *bn2)
-{
-    test_fail_message_prefix(prefix, file, line, type, left, right, op);
-    test_fail_bignum_common(prefix, file, line, type, left, right, op, bn1, bn2);
-}
-
-static void test_fail_bignum_mono_message(const char *prefix, const char *file,
-                                          int line, const char *type,
-                                          const char *left, const char *right,
-                                          const char *op, const BIGNUM *bn)
-{
-    test_fail_message_prefix(prefix, file, line, type, left, right, op);
-    test_fail_bignum_common(prefix, file, line, type, left, right, op, bn, bn);
-}
-
-static void test_memory_null_empty(const unsigned char *m, int indent, char c)
-{
-    if (m == NULL)
-        test_printf_stderr(&quot;%*s# % 4s %c%s\n&quot;, indent, &quot;&quot;, &quot;&quot;, c, &quot;NULL&quot;);
-    else
-        test_printf_stderr(&quot;%*s# %04x %c%s\n&quot;, indent, &quot;&quot;, 0u, c, &quot;empty&quot;);
-}
-
-static void test_fail_memory_message(const char *prefix, const char *file,
-                                     int line, const char *type,
-                                     const char *left, const char *right,
-                                     const char *op,
-                                     const unsigned char *m1, size_t l1,
-                                     const unsigned char *m2, size_t l2)
-{
-    const int indent = subtest_level();
-    const size_t bytes = (MAX_STRING_WIDTH - 9) / 17 * 8;
-    char b1[MAX_STRING_WIDTH + 1], b2[MAX_STRING_WIDTH + 1];
-    char *p, bdiff[MAX_STRING_WIDTH + 1];
-    size_t n1, n2, i;
-    unsigned int cnt = 0, diff;
-
-    test_fail_message_prefix(prefix, file, line, type, left, right, op);
-    if (m1 == NULL)
-        l1 = 0;
-    if (m2 == NULL)
-        l2 = 0;
-    if (l1 == 0 &amp;&amp; l2 == 0) {
-        if ((m1 == NULL) == (m2 == NULL)) {
-            test_memory_null_empty(m1, indent, ' ');
-        } else {
-            test_diff_header(left, right);
-            test_memory_null_empty(m1, indent, '-');
-            test_memory_null_empty(m2, indent, '+');
-        }
-        goto fin;
-    }
-
-    if (l1 != l2 || memcmp(m1, m2, l1) != 0)
-        test_diff_header(left, right);
-
-    while (l1 &gt; 0 || l2 &gt; 0) {
-        n1 = n2 = 0;
-        if (l1 &gt; 0) {
-            n1 = l1 &gt; bytes ? bytes : l1;
-            hex_convert_memory(m1, n1, b1, 8);
-        }
-        if (l2 &gt; 0) {
-            n2 = l2 &gt; bytes ? bytes : l2;
-            hex_convert_memory(m2, n2, b2, 8);
-        }
-
-        diff = 0;
-        i = 0;
-        p = bdiff;
-        if (n1 &gt; 0 &amp;&amp; n2 &gt; 0) {
-            const size_t j = n1 &lt; n2 ? n1 : n2;
-
-            for (; i &lt; j; i++) {
-                if (m1[i] == m2[i]) {
-                    *p++ = ' ';
-                    *p++ = ' ';
-                } else {
-                    *p++ = '^';
-                    *p++ = '^';
-                    diff = 1;
-                }
-                if (i % 8 == 7 &amp;&amp; i != j - 1)
-                    *p++ = ' ';
-            }
-            *p++ = '\0';
-        }
-
-        if (n1 == n2 &amp;&amp; !diff) {
-            test_printf_stderr(&quot;%*s# %04x: %s\n&quot;, indent, &quot;&quot;, cnt, b1);
-        } else {
-            if (cnt == 0 &amp;&amp; (m1 == NULL || l1 == 0))
-                test_memory_null_empty(m1, indent, '-');
-            else if (n1 &gt; 0)
-                test_printf_stderr(&quot;%*s# %04x:-%s\n&quot;, indent, &quot;&quot;, cnt, b1);
-            if (cnt == 0 &amp;&amp; (m2 == NULL || l2 == 0))
-                test_memory_null_empty(m2, indent, '+');
-            else if (n2 &gt; 0)
-                test_printf_stderr(&quot;%*s# %04x:+%s\n&quot;, indent, &quot;&quot;, cnt, b2);
-            if (diff &amp;&amp; i &gt; 0)
-                test_printf_stderr(&quot;%*s# % 4s  %s\n&quot;, indent, &quot;&quot;, &quot;&quot;, bdiff);
-        }
-        m1 += n1;
-        m2 += n2;
-        l1 -= n1;
-        l2 -= n2;
-        cnt += bytes;
-    }
-fin:
-    test_printf_stderr(&quot;\n&quot;);
     test_flush_stderr();
 }
 
@@ -526,6 +122,7 @@ void test_error_c90(const char *desc, ...)
     va_start(ap, desc);
     test_fail_message_va(NULL, NULL, -1, NULL, NULL, NULL, NULL, desc, ap);
     va_end(ap);
+    test_printf_stderr(&quot;\n&quot;);
 }
 
 void test_error(const char *file, int line, const char *desc, ...)
@@ -535,6 +132,19 @@ void test_error(const char *file, int line, const char *desc, ...)
     va_start(ap, desc);
     test_fail_message_va(NULL, file, line, NULL, NULL, NULL, NULL, desc, ap);
     va_end(ap);
+    test_printf_stderr(&quot;\n&quot;);
+}
+
+void test_note(const char *fmt, ...)
+{
+    va_list ap;
+
+    if (fmt != NULL) {
+        test_printf_stderr(&quot;%*s# &quot;, subtest_level(), &quot;&quot;);
+        test_vprintf_stderr(fmt, ap);
+        test_printf_stderr(&quot;\n&quot;);
+    }
+    test_flush_stderr();
 }
 
 void test_openssl_errors(void)
diff --git a/test/testutil/tu_local.h b/test/testutil/tu_local.h
index ad50fca..a42f2c3 100644
--- a/test/testutil/tu_local.h
+++ b/test/testutil/tu_local.h
@@ -8,6 +8,36 @@
  */
 
 #include &lt;stdlib.h&gt;              /* size_t */
+#include &lt;openssl/bn.h&gt;
 
 int subtest_level(void);
 int openssl_error_cb(const char *str, size_t len, void *u);
+
+void test_fail_message_prefix(const char *prefix, const char *file,
+                              int line, const char *type,
+                              const char *left, const char *right,
+                              const char *op);
+
+void test_fail_string_message(const char *prefix, const char *file,
+                              int line, const char *type,
+                              const char *left, const char *right,
+                              const char *op, const char *m1, size_t l1,
+                              const char *m2, size_t l2);
+
+void test_fail_bignum_message(const char *prefix, const char *file,
+                              int line, const char *type,
+                              const char *left, const char *right,
+                              const char *op,
+                              const BIGNUM *bn1, const BIGNUM *bn2);
+void test_fail_bignum_mono_message(const char *prefix, const char *file,
+                                   int line, const char *type,
+                                   const char *left, const char *right,
+                                   const char *op, const BIGNUM *bn);
+
+void test_fail_memory_message(const char *prefix, const char *file,
+                              int line, const char *type,
+                              const char *left, const char *right,
+                              const char *op,
+                              const unsigned char *m1, size_t l1,
+                              const unsigned char *m2, size_t l2);
+
</PRE>





















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015070.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="015073.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15071">[ date ]</a>
              <a href="thread.html#15071">[ thread ]</a>
              <a href="subject.html#15071">[ subject ]</a>
              <a href="author.html#15071">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
