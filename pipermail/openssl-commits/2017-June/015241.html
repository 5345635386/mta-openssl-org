<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2017-June/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1498647355.932278.25515.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015238.html">
   <LINK REL="Next"  HREF="015242.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1498647355.932278.25515.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Wed Jun 28 10:55:55 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="015238.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="015242.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15241">[ date ]</a>
              <a href="thread.html#15241">[ thread ]</a>
              <a href="subject.html#15241">[ subject ]</a>
              <a href="author.html#15241">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  e041f3b8baf3b9a2d57f5eb818a6b0aebd96e953 (commit)
       via  8bd2c65fbb25c4d64c1fd098e02bdef40b3d9773 (commit)
       via  4f79affb05717243d3d041f3448156c35cabf0a2 (commit)
       via  619eb33a0c3dc488ba2bcc366633220813b701c7 (commit)
       via  9a32dcf42e2f728018a02b27df9734be480b7f3c (commit)
      from  f367ac2b2664df272aa1903c7650f0c64f539d28 (commit)


- Log -----------------------------------------------------------------
commit e041f3b8baf3b9a2d57f5eb818a6b0aebd96e953
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Jun 21 22:03:29 2017 +0200

    Document the added devcrypto engine in CHANGES
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3744">https://github.com/openssl/openssl/pull/3744</A>)

commit 8bd2c65fbb25c4d64c1fd098e02bdef40b3d9773
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu May 11 12:52:47 2017 +0200

    Comment on the lack of documentation for asymmetric ciphers
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3744">https://github.com/openssl/openssl/pull/3744</A>)

commit 4f79affb05717243d3d041f3448156c35cabf0a2
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Apr 18 08:51:51 2017 +0200

    Adapt for BSD cryptodev.h differences
    
    The BSD cryptodev.h doesn't have things like COP_FLAG_WRITE_IV and
    COP_FLAG_UPDATE.  In that case, we need to implement that
    functionality ourselves.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3744">https://github.com/openssl/openssl/pull/3744</A>)

commit 619eb33a0c3dc488ba2bcc366633220813b701c7
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Mar 24 16:19:00 2017 +0100

    Add new /dev/crypto engine
    
    Based on cryptodev-linux
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3744">https://github.com/openssl/openssl/pull/3744</A>)

commit 9a32dcf42e2f728018a02b27df9734be480b7f3c
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Jun 27 16:05:12 2017 +0200

    Add the common error ERR_R_OPERATION_FAIL
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3744">https://github.com/openssl/openssl/pull/3744</A>)

-----------------------------------------------------------------------

Summary of changes:
 CHANGES                          |   6 +
 Configurations/10-main.conf      |   1 +
 Configure                        |   4 +-
 crypto/engine/build.info         |   3 +
 crypto/engine/eng_devcrypto.c    | 679 +++++++++++++++++++++++++++++++++++++++
 crypto/engine/eng_err.c          |   1 +
 crypto/err/err.c                 |   4 +
 crypto/err/openssl.txt           |   1 +
 crypto/include/internal/engine.h |   1 +
 crypto/init.c                    |  17 +
 include/openssl/engineerr.h      |   1 +
 include/openssl/err.h            |   4 +
 12 files changed, 721 insertions(+), 1 deletion(-)
 create mode 100644 crypto/engine/eng_devcrypto.c

diff --git a/CHANGES b/CHANGES
index 29afc21..bda8e22 100644
--- a/CHANGES
+++ b/CHANGES
@@ -9,6 +9,12 @@
 
  Changes between 1.1.0f and 1.1.1 [xx XXX xxxx]
 
+  *) Add devcrypto engine.  This has been implemented against cryptodev-linux,
+     then adjusted to work on FreeBSD 8.4 as well.
+     Enable by configuring with 'enable-devcryptoeng'.  This is done by default
+     on BSD implementations, as cryptodev.h is assumed to exist on all of them.
+     [Richard Levitte]
+
   *) Module names can prefixed with OSSL_ or OPENSSL_.  This affects
      util/mkerr.pl, which is adapted to allow those prefixes, leading to
      error code calls like this:
diff --git a/Configurations/10-main.conf b/Configurations/10-main.conf
index 6a86b35..e728200 100644
--- a/Configurations/10-main.conf
+++ b/Configurations/10-main.conf
@@ -984,6 +984,7 @@ sub vms_info {
                                            debug   =&gt; &quot;-O0 -g&quot;,
                                            release =&gt; &quot;-O3&quot;),
                                     threads(&quot;-pthread -D_THREAD_SAFE -D_REENTRANT&quot;)),
+        enable           =&gt; add(&quot;devcryptoeng&quot;),
         bn_ops           =&gt; &quot;BN_LLONG&quot;,
         thread_scheme    =&gt; &quot;pthreads&quot;,
         dso_scheme       =&gt; &quot;dlfcn&quot;,
diff --git a/Configure b/Configure
index 65fcea0..2eacb23 100755
--- a/Configure
+++ b/Configure
@@ -345,6 +345,7 @@ my @disablables = (
     &quot;ct&quot;,
     &quot;deprecated&quot;,
     &quot;des&quot;,
+    &quot;devcryptoeng&quot;,
     &quot;dgram&quot;,
     &quot;dh&quot;,
     &quot;dsa&quot;,
@@ -431,6 +432,7 @@ our %disabled = ( # &quot;what&quot;         =&gt; &quot;comment&quot;
                   &quot;asan&quot;		=&gt; &quot;default&quot;,
 		  &quot;crypto-mdebug&quot;       =&gt; &quot;default&quot;,
 		  &quot;crypto-mdebug-backtrace&quot; =&gt; &quot;default&quot;,
+		  &quot;devcryptoeng&quot;	=&gt; &quot;default&quot;,
 		  &quot;ec_nistp_64_gcc_128&quot; =&gt; &quot;default&quot;,
 		  &quot;egd&quot;                 =&gt; &quot;default&quot;,
 		  &quot;external-tests&quot;	=&gt; &quot;default&quot;,
@@ -504,7 +506,7 @@ my @disable_cascades = (
     # Without position independent code, there can be no shared libraries or DSOs
     &quot;pic&quot;               =&gt; [ &quot;shared&quot; ],
     &quot;shared&quot;            =&gt; [ &quot;dynamic-engine&quot; ],
-    &quot;engine&quot;            =&gt; [ &quot;afalgeng&quot; ],
+    &quot;engine&quot;            =&gt; [ &quot;afalgeng&quot;, &quot;devcryptoeng&quot; ],
 
     # no-autoalginit is only useful when building non-shared
     &quot;autoalginit&quot;       =&gt; [ &quot;shared&quot;, &quot;apps&quot; ],
diff --git a/crypto/engine/build.info b/crypto/engine/build.info
index 47fe948..e00802a 100644
--- a/crypto/engine/build.info
+++ b/crypto/engine/build.info
@@ -6,3 +6,6 @@ SOURCE[../../libcrypto]=\
         tb_cipher.c tb_digest.c tb_pkmeth.c tb_asnmth.c tb_eckey.c \
         eng_openssl.c eng_cnf.c eng_dyn.c \
         eng_rdrand.c
+IF[{- !$disabled{devcryptoeng} -}]
+  SOURCE[../../libcrypto]=eng_devcrypto.c
+ENDIF
diff --git a/crypto/engine/eng_devcrypto.c b/crypto/engine/eng_devcrypto.c
new file mode 100644
index 0000000..19781b8
--- /dev/null
+++ b/crypto/engine/eng_devcrypto.c
@@ -0,0 +1,679 @@
+/*
+ * Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;string.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;sys/ioctl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;assert.h&gt;
+
+#include &quot;e_os.h&quot;
+
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/err.h&gt;
+#include &lt;openssl/engine.h&gt;
+#include &lt;openssl/objects.h&gt;
+#include &lt;crypto/cryptodev.h&gt;
+
+#include &quot;internal/engine.h&quot;
+
+#ifdef CRYPTO_ALGORITHM_MIN
+# define CHECK_BSD_STYLE_MACROS
+#endif
+
+/******************************************************************************
+ *
+ * Ciphers
+ *
+ * Because they all do the same basic operation, we have only one set of
+ * method functions for them all to share, and a mapping table between
+ * NIDs and cryptodev IDs, with all the necessary size data.
+ *
+ *****/
+
+struct cipher_ctx {
+    int cfd;
+    struct session_op sess;
+
+    /* to pass from init to do_cipher */
+    const unsigned char *iv;
+    int op;                      /* COP_ENCRYPT or COP_DECRYPT */
+};
+
+static const struct cipher_data_st {
+    int nid;
+    int blocksize;
+    int keylen;
+    int ivlen;
+    int flags;
+    int devcryptoid;
+} cipher_data[] = {
+#ifndef OPENSSL_NO_DES
+    { NID_des_cbc, 8, 8, 8, EVP_CIPH_CBC_MODE, CRYPTO_DES_CBC },
+    { NID_des_ede3_cbc, 8, 24, 8, EVP_CIPH_CBC_MODE, CRYPTO_3DES_CBC },
+#endif
+#ifndef OPENSSL_NO_BF
+    { NID_bf_cbc, 8, 16, 8, EVP_CIPH_CBC_MODE, CRYPTO_BLF_CBC },
+#endif
+#ifndef OPENSSL_NO_CAST
+    { NID_cast5_cbc, 8, 16, 8, EVP_CIPH_CBC_MODE, CRYPTO_CAST_CBC },
+#endif
+    { NID_aes_128_cbc, 16, 128 / 8, 16, EVP_CIPH_CBC_MODE, CRYPTO_AES_CBC },
+    { NID_aes_192_cbc, 16, 192 / 8, 16, EVP_CIPH_CBC_MODE, CRYPTO_AES_CBC },
+    { NID_aes_256_cbc, 16, 256 / 8, 16, EVP_CIPH_CBC_MODE, CRYPTO_AES_CBC },
+#ifndef OPENSSL_NO_RC4
+    { NID_rc4, 1, 16, 0, CRYPTO_ARC4 },
+#endif
+#if !defined(CHECK_BSD_STYLE_MACROS) || defined(CRYPTO_AES_CTR)
+    { NID_aes_128_ctr, 16, 128 / 8, 16, EVP_CIPH_CTR_MODE, CRYPTO_AES_CTR },
+    { NID_aes_192_ctr, 16, 192 / 8, 16, EVP_CIPH_CTR_MODE, CRYPTO_AES_CTR },
+    { NID_aes_256_ctr, 16, 256 / 8, 16, EVP_CIPH_CTR_MODE, CRYPTO_AES_CTR },
+#endif
+#if 0                            /* Not yet supported */
+    { NID_aes_128_xts, 16, 128 / 8 * 2, 16, EVP_CIPH_XTS_MODE, CRYPTO_AES_XTS },
+    { NID_aes_256_xts, 16, 256 / 8 * 2, 16, EVP_CIPH_XTS_MODE, CRYPTO_AES_XTS },
+#endif
+#if !defined(CHECK_BSD_STYLE_MACROS) || defined(CRYPTO_AES_ECB)
+    { NID_aes_128_ecb, 16, 128 / 8, 16, EVP_CIPH_ECB_MODE, CRYPTO_AES_ECB },
+    { NID_aes_192_ecb, 16, 192 / 8, 16, EVP_CIPH_ECB_MODE, CRYPTO_AES_ECB },
+    { NID_aes_256_ecb, 16, 256 / 8, 16, EVP_CIPH_ECB_MODE, CRYPTO_AES_ECB },
+#endif
+#if 0                            /* Not yet supported */
+    { NID_aes_128_gcm, 16, 128 / 8, 16, EVP_CIPH_GCM_MODE, CRYPTO_AES_GCM },
+    { NID_aes_192_gcm, 16, 192 / 8, 16, EVP_CIPH_GCM_MODE, CRYPTO_AES_GCM },
+    { NID_aes_256_gcm, 16, 256 / 8, 16, EVP_CIPH_GCM_MODE, CRYPTO_AES_GCM },
+#endif
+#ifndef OPENSSL_NO_CAMELLIA
+    { NID_camellia_128_cbc, 16, 128 / 8, 16, EVP_CIPH_CBC_MODE,
+      CRYPTO_CAMELLIA_CBC },
+    { NID_camellia_192_cbc, 16, 192 / 8, 16, EVP_CIPH_CBC_MODE,
+      CRYPTO_CAMELLIA_CBC },
+    { NID_camellia_256_cbc, 16, 256 / 8, 16, EVP_CIPH_CBC_MODE,
+      CRYPTO_CAMELLIA_CBC },
+#endif
+};
+
+static size_t get_cipher_data_index(int nid)
+{
+    size_t i;
+
+    for (i = 0; i &lt; OSSL_NELEM(cipher_data); i++)
+        if (nid == cipher_data[i].nid)
+            return i;
+
+    /*
+     * Code further down must make sure that only NIDs in the table above
+     * are used.  If any other NID reaches this function, there's a grave
+     * coding error further down.
+     */
+    assert(&quot;Code that never should be reached&quot; == NULL);
+    return -1;
+}
+
+static const struct cipher_data_st *get_cipher_data(int nid)
+{
+    return &amp;cipher_data[get_cipher_data_index(nid)];
+}
+
+/*
+ * Following are the three necessary functions to map OpenSSL functionality
+ * with cryptodev.
+ */
+
+static int cipher_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+                       const unsigned char *iv, int enc)
+{
+    struct cipher_ctx *cipher_ctx =
+        (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
+    const struct cipher_data_st *cipher_d =
+        get_cipher_data(EVP_CIPHER_CTX_nid(ctx));
+
+    if ((cipher_ctx-&gt;cfd = open(&quot;/dev/crypto&quot;, O_RDWR, 0)) &lt; 0) {
+        SYSerr(SYS_F_OPEN, errno);
+        return 0;
+    }
+
+    memset(&amp;cipher_ctx-&gt;sess, 0, sizeof(cipher_ctx-&gt;sess));
+    cipher_ctx-&gt;sess.cipher = cipher_d-&gt;devcryptoid;
+    cipher_ctx-&gt;sess.keylen = cipher_d-&gt;keylen;
+    cipher_ctx-&gt;sess.key = (void *)key;
+    cipher_ctx-&gt;op = enc ? COP_ENCRYPT : COP_DECRYPT;
+    if (ioctl(cipher_ctx-&gt;cfd, CIOCGSESSION, &amp;cipher_ctx-&gt;sess) &lt; 0) {
+        SYSerr(SYS_F_IOCTL, errno);
+        close(cipher_ctx-&gt;cfd);
+        return 0;
+    }
+
+    return 1;
+}
+
+static int cipher_do_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                            const unsigned char *in, size_t inl)
+{
+    struct cipher_ctx *cipher_ctx =
+        (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
+    struct crypt_op cryp;
+#if !defined(COP_FLAG_WRITE_IV)
+    unsigned char saved_iv[EVP_MAX_IV_LENGTH];
+#endif
+
+    memset(&amp;cryp, 0, sizeof(cryp));
+    cryp.ses = cipher_ctx-&gt;sess.ses;
+    cryp.len = inl;
+    cryp.src = (void *)in;
+    cryp.dst = (void *)out;
+    cryp.iv = (void *)EVP_CIPHER_CTX_iv_noconst(ctx);
+    cryp.op = cipher_ctx-&gt;op;
+#if !defined(COP_FLAG_WRITE_IV)
+    cryp.flags = 0;
+
+    if (EVP_CIPHER_CTX_iv_length(ctx) &gt; 0) {
+        assert(inl &gt;= EVP_CIPHER_CTX_iv_length(ctx));
+        if (!EVP_CIPHER_CTX_encrypting(ctx)) {
+            unsigned char *ivptr = in + inl - EVP_CIPHER_CTX_iv_length(ctx);
+
+            memcpy(saved_iv, ivptr, EVP_CIPHER_CTX_iv_length(ctx));
+        }
+    }
+#else
+    cryp.flags = COP_FLAG_WRITE_IV;
+#endif
+
+    if (ioctl(cipher_ctx-&gt;cfd, CIOCCRYPT, &amp;cryp) &lt; 0) {
+        SYSerr(SYS_F_IOCTL, errno);
+        return 0;
+    }
+
+#if !defined(COP_FLAG_WRITE_IV)
+    if (EVP_CIPHER_CTX_iv_length(ctx) &gt; 0) {
+        unsigned char *ivptr = saved_iv;
+
+        assert(inl &gt;= EVP_CIPHER_CTX_iv_length(ctx));
+        if (!EVP_CIPHER_CTX_encrypting(ctx))
+            ivptr = out + inl - EVP_CIPHER_CTX_iv_length(ctx);
+
+        memcpy(EVP_CIPHER_CTX_iv_noconst(ctx), ivptr,
+               EVP_CIPHER_CTX_iv_length(ctx));
+    }
+#endif
+
+    return 1;
+}
+
+static int cipher_cleanup(EVP_CIPHER_CTX *ctx)
+{
+    struct cipher_ctx *cipher_ctx =
+        (struct cipher_ctx *)EVP_CIPHER_CTX_get_cipher_data(ctx);
+
+    if (ioctl(cipher_ctx-&gt;cfd, CIOCFSESSION, &amp;cipher_ctx-&gt;sess) &lt; 0) {
+        SYSerr(SYS_F_IOCTL, errno);
+        return 0;
+    }
+    if (close(cipher_ctx-&gt;cfd) &lt; 0) {
+        SYSerr(SYS_F_CLOSE, errno);
+        return 0;
+    }
+
+    return 1;
+}
+
+/*
+ * Keep a table of known nids and associated methods.
+ * Note that known_cipher_nids[] isn't necessarely indexed the same way as
+ * cipher_data[] above, which known_cipher_methods[] is.
+ */
+static int known_cipher_nids[OSSL_NELEM(cipher_data)];
+static int known_cipher_nids_amount = -1; /* -1 indicates not yet initialised */
+static EVP_CIPHER *known_cipher_methods[OSSL_NELEM(cipher_data)] = { NULL, };
+
+static void prepare_cipher_methods()
+{
+    size_t i;
+    struct session_op sess;
+    int cfd;
+
+    if ((cfd = open(&quot;/dev/crypto&quot;, O_RDWR, 0)) &lt; 0)
+        return;
+
+    memset(&amp;sess, 0, sizeof(sess));
+    sess.key = (void *)&quot;01234567890123456789012345678901234567890123456789&quot;;
+
+    for (i = 0, known_cipher_nids_amount = 0;
+         i &lt; OSSL_NELEM(cipher_data); i++) {
+
+        /*
+         * Check that the algo is really availably by trying to open and close
+         * a session.
+         */
+        sess.cipher = cipher_data[i].devcryptoid;
+        sess.keylen = cipher_data[i].keylen;
+        if (ioctl(cfd, CIOCGSESSION, &amp;sess) &lt; 0
+            || ioctl(cfd, CIOCFSESSION, &amp;sess) &lt; 0)
+            continue;
+
+        if ((known_cipher_methods[i] =
+                 EVP_CIPHER_meth_new(cipher_data[i].nid,
+                                     cipher_data[i].blocksize,
+                                     cipher_data[i].keylen)) == NULL
+            || !EVP_CIPHER_meth_set_iv_length(known_cipher_methods[i],
+                                              cipher_data[i].ivlen)
+            || !EVP_CIPHER_meth_set_flags(known_cipher_methods[i],
+                                          cipher_data[i].flags
+                                          | EVP_CIPH_FLAG_DEFAULT_ASN1)
+            || !EVP_CIPHER_meth_set_init(known_cipher_methods[i], cipher_init)
+            || !EVP_CIPHER_meth_set_do_cipher(known_cipher_methods[i],
+                                              cipher_do_cipher)
+            || !EVP_CIPHER_meth_set_cleanup(known_cipher_methods[i],
+                                            cipher_cleanup)
+            || !EVP_CIPHER_meth_set_impl_ctx_size(known_cipher_methods[i],
+                                                  sizeof(struct cipher_ctx))) {
+            EVP_CIPHER_meth_free(known_cipher_methods[i]);
+            known_cipher_methods[i] = NULL;
+        } else {
+            known_cipher_nids[known_cipher_nids_amount++] =
+                cipher_data[i].nid;
+        }
+    }
+
+    close(cfd);
+}
+
+static const EVP_CIPHER *get_cipher_method(int nid)
+{
+    size_t i = get_cipher_data_index(nid);
+
+    if (i == (size_t)-1)
+        return NULL;
+    return known_cipher_methods[i];
+}
+
+static int get_cipher_nids(const int **nids)
+{
+    *nids = known_cipher_nids;
+    return known_cipher_nids_amount;
+}
+
+static void destroy_cipher_method(int nid)
+{
+    size_t i = get_cipher_data_index(nid);
+
+    EVP_CIPHER_meth_free(known_cipher_methods[i]);
+    known_cipher_methods[i] = NULL;
+}
+
+static void destroy_all_cipher_methods()
+{
+    size_t i;
+
+    for (i = 0; i &lt; OSSL_NELEM(cipher_data); i++)
+        destroy_cipher_method(cipher_data[i].nid);
+}
+
+static int devcrypto_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
+                             const int **nids, int nid)
+{
+    if (cipher == NULL)
+        return get_cipher_nids(nids);
+
+    *cipher = get_cipher_method(nid);
+
+    return *cipher != NULL;
+}
+
+/*
+ * We only support digests if the cryptodev implementation supports multiple
+ * data updates.  Otherwise, we would be forced to maintain a cache, which is
+ * perilous if there's a lot of data coming in (if someone wants to checksum
+ * an OpenSSL tarball, for example).
+ */
+#if defined(COP_FLAG_UPDATE) &amp;&amp; defined(COP_FLAG_FINAL)
+
+/******************************************************************************
+ *
+ * Digests
+ *
+ * Because they all do the same basic operation, we have only one set of
+ * method functions for them all to share, and a mapping table between
+ * NIDs and cryptodev IDs, with all the necessary size data.
+ *
+ *****/
+
+struct digest_ctx {
+    int cfd;
+    struct session_op sess;
+    int init;
+};
+
+static const struct digest_data_st {
+    int nid;
+    int digestlen;
+    int devcryptoid;
+} digest_data[] = {
+#ifndef OPENSSL_NO_MD5
+    { NID_md5, 16, CRYPTO_MD5 },
+#endif
+    { NID_sha1, 20, CRYPTO_SHA1 },
+#ifndef OPENSSL_NO_RMD160
+# if !defined(CHECK_BSD_STYLE_MACROS) &amp;&amp; defined(CRYPTO_RIPEMD160)
+    { NID_ripemd160, 20, CRYPTO_RIPEMD160 },
+# endif
+#endif
+#if !defined(CHECK_BSD_STYLE_MACROS) &amp;&amp; defined(CRYPTO_SHA2_224)
+    { NID_sha224, 224 / 8, CRYPTO_SHA2_224 },
+#endif
+#if !defined(CHECK_BSD_STYLE_MACROS) &amp;&amp; defined(CRYPTO_SHA2_256)
+    { NID_sha256, 256 / 8, CRYPTO_SHA2_256 },
+#endif
+#if !defined(CHECK_BSD_STYLE_MACROS) &amp;&amp; defined(CRYPTO_SHA2_384)
+    { NID_sha384, 384 / 8, CRYPTO_SHA2_384 },
+#endif
+#if !defined(CHECK_BSD_STYLE_MACROS) &amp;&amp; defined(CRYPTO_SHA2_512)
+    { NID_sha512, 512 / 8, CRYPTO_SHA2_512 },
+#endif
+};
+
+static size_t get_digest_data_index(int nid)
+{
+    size_t i;
+
+    for (i = 0; i &lt; OSSL_NELEM(digest_data); i++)
+        if (nid == digest_data[i].nid)
+            return i;
+
+    /*
+     * Code further down must make sure that only NIDs in the table above
+     * are used.  If any other NID reaches this function, there's a grave
+     * coding error further down.
+     */
+    assert(&quot;Code that never should be reached&quot; == NULL);
+    return -1;
+}
+
+static const struct digest_data_st *get_digest_data(int nid)
+{
+    return &amp;digest_data[get_digest_data_index(nid)];
+}
+
+/*
+ * Following are the four necessary functions to map OpenSSL functionality
+ * with cryptodev.
+ */
+
+static int digest_init(EVP_MD_CTX *ctx)
+{
+    struct digest_ctx *digest_ctx =
+        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+    const struct digest_data_st *digest_d =
+        get_digest_data(EVP_MD_CTX_type(ctx));
+
+    if (digest_ctx-&gt;init == 0
+        &amp;&amp; (digest_ctx-&gt;cfd = open(&quot;/dev/crypto&quot;, O_RDWR, 0)) &lt; 0) {
+        SYSerr(SYS_F_OPEN, errno);
+        return 0;
+    }
+
+    digest_ctx-&gt;init = 1;
+
+    memset(&amp;digest_ctx-&gt;sess, 0, sizeof(digest_ctx-&gt;sess));
+    digest_ctx-&gt;sess.mac = digest_d-&gt;devcryptoid;
+    if (ioctl(digest_ctx-&gt;cfd, CIOCGSESSION, &amp;digest_ctx-&gt;sess) &lt; 0) {
+        SYSerr(SYS_F_IOCTL, errno);
+        close(digest_ctx-&gt;cfd);
+        return 0;
+    }
+
+    return 1;
+}
+
+static int digest_op(struct digest_ctx *ctx, const void *src, size_t srclen,
+                     void *res, unsigned int flags)
+{
+    struct crypt_op cryp;
+
+    memset(&amp;cryp, 0, sizeof(cryp));
+    cryp.ses = ctx-&gt;sess.ses;
+    cryp.len = srclen;
+    cryp.src = (void *)src;
+    cryp.dst = NULL;
+    cryp.mac = res;
+    cryp.flags = flags;
+    return ioctl(ctx-&gt;cfd, CIOCCRYPT, &amp;cryp);
+}
+
+static int digest_update(EVP_MD_CTX *ctx, const void *data, size_t count)
+{
+    struct digest_ctx *digest_ctx =
+        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+
+    if (count == 0)
+        return 1;
+
+    if (digest_op(digest_ctx, data, count, NULL, COP_FLAG_UPDATE) &lt; 0) {
+        SYSerr(SYS_F_IOCTL, errno);
+        return 0;
+    }
+
+    return 1;
+}
+
+static int digest_final(EVP_MD_CTX *ctx, unsigned char *md)
+{
+    struct digest_ctx *digest_ctx =
+        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+
+    if (digest_op(digest_ctx, NULL, 0, md, COP_FLAG_FINAL) &lt; 0) {
+        SYSerr(SYS_F_IOCTL, errno);
+        return 0;
+    }
+    if (ioctl(digest_ctx-&gt;cfd, CIOCFSESSION, &amp;digest_ctx-&gt;sess) &lt; 0) {
+        SYSerr(SYS_F_IOCTL, errno);
+        return 0;
+    }
+
+    return 1;
+}
+
+static int digest_cleanup(EVP_MD_CTX *ctx)
+{
+    struct digest_ctx *digest_ctx =
+        (struct digest_ctx *)EVP_MD_CTX_md_data(ctx);
+
+    if (close(digest_ctx-&gt;cfd) &lt; 0) {
+        SYSerr(SYS_F_CLOSE, errno);
+        return 0;
+    }
+
+    return 1;
+}
+
+/*
+ * Keep a table of known nids and associated methods.
+ * Note that known_digest_nids[] isn't necessarely indexed the same way as
+ * digest_data[] above, which known_digest_methods[] is.
+ */
+static int known_digest_nids[OSSL_NELEM(digest_data)];
+static int known_digest_nids_amount = -1; /* -1 indicates not yet initialised */
+static EVP_MD *known_digest_methods[OSSL_NELEM(digest_data)] = { NULL, };
+
+static void prepare_digest_methods()
+{
+    size_t i;
+    struct session_op sess;
+    int cfd;
+
+    if ((cfd = open(&quot;/dev/crypto&quot;, O_RDWR, 0)) &lt; 0)
+        return;
+
+    memset(&amp;sess, 0, sizeof(sess));
+
+    for (i = 0, known_digest_nids_amount = 0; i &lt; OSSL_NELEM(digest_data);
+         i++) {
+
+        /*
+         * Check that the algo is really availably by trying to open and close
+         * a session.
+         */
+        sess.mac = digest_data[i].devcryptoid;
+        if (ioctl(cfd, CIOCGSESSION, &amp;sess) &lt; 0
+            || ioctl(cfd, CIOCFSESSION, &amp;sess) &lt; 0)
+            continue;
+
+        if ((known_digest_methods[i] = EVP_MD_meth_new(digest_data[i].nid,
+                                                       NID_undef)) == NULL
+            || !EVP_MD_meth_set_result_size(known_digest_methods[i],
+                                            digest_data[i].digestlen)
+            || !EVP_MD_meth_set_init(known_digest_methods[i], digest_init)
+            || !EVP_MD_meth_set_update(known_digest_methods[i], digest_update)
+            || !EVP_MD_meth_set_final(known_digest_methods[i], digest_final)
+            || !EVP_MD_meth_set_cleanup(known_digest_methods[i], digest_cleanup)
+            || !EVP_MD_meth_set_app_datasize(known_digest_methods[i],
+                                             sizeof(struct digest_ctx))) {
+            EVP_MD_meth_free(known_digest_methods[i]);
+            known_digest_methods[i] = NULL;
+        } else {
+            known_digest_nids[known_digest_nids_amount++] = digest_data[i].nid;
+        }
+    }
+
+    close(cfd);
+}
+
+static const EVP_MD *get_digest_method(int nid)
+{
+    size_t i = get_digest_data_index(nid);
+
+    if (i == (size_t)-1)
+        return NULL;
+    return known_digest_methods[i];
+}
+
+static int get_digest_nids(const int **nids)
+{
+    *nids = known_digest_nids;
+    return known_digest_nids_amount;
+}
+
+static void destroy_digest_method(int nid)
+{
+    size_t i = get_digest_data_index(nid);
+
+    EVP_MD_meth_free(known_digest_methods[i]);
+    known_digest_methods[i] = NULL;
+}
+
+static void destroy_all_digest_methods()
+{
+    size_t i;
+
+    for (i = 0; i &lt; OSSL_NELEM(digest_data); i++)
+        destroy_digest_method(digest_data[i].nid);
+}
+
+static int devcrypto_digests(ENGINE *e, const EVP_MD **digest,
+                             const int **nids, int nid)
+{
+    if (digest == NULL)
+        return get_digest_nids(nids);
+
+    *digest = get_digest_method(nid);
+
+    return *digest != NULL;
+}
+
+#endif
+
+/******************************************************************************
+ *
+ * LOAD / UNLOAD
+ *
+ *****/
+
+static int devcrypto_unload(ENGINE *e)
+{
+    destroy_all_cipher_methods();
+#if defined(COP_FLAG_UPDATE) &amp;&amp; defined(COP_FLAG_FINAL)
+    destroy_all_digest_methods();
+#endif
+    return 1;
+}
+/*
+ * This engine is always built into libcrypto, so it doesn't offer any
+ * ability to be dynamically loadable.
+ */
+void engine_load_devcrypto_int()
+{
+    ENGINE *e = NULL;
+
+    if (access(&quot;/dev/crypto&quot;, R_OK | W_OK) &lt; 0) {
+        fprintf(stderr,
+                &quot;/dev/crypto not present, not enabling devcrypto engine\n&quot;);
+        return;
+    }
+
+    prepare_cipher_methods();
+#if defined(COP_FLAG_UPDATE) &amp;&amp; defined(COP_FLAG_FINAL)
+    prepare_digest_methods();
+#endif
+
+    if ((e = ENGINE_new()) == NULL)
+        return;
+
+    if (!ENGINE_set_id(e, &quot;devcrypto&quot;)
+        || !ENGINE_set_name(e, &quot;/dev/crypto engine&quot;)
+        || !ENGINE_set_destroy_function(e, devcrypto_unload)
+
+/*
+ * Asymmetric ciphers aren't well supported with /dev/crypto.  Among the BSD
+ * implementations, it seems to only exist in FreeBSD, and regarding the
+ * parameters in its crypt_kop, the manual crypto(4) has this to say:
+ *
+ *    The semantics of these arguments are currently undocumented.
+ *
+ * Reading through the FreeBSD source code doesn't give much more than
+ * their CRK_MOD_EXP implementation for ubsec.
+ *
+ * It doesn't look much better with cryptodev-linux.  They have the crypt_kop
+ * structure as well as the command (CRK_*) in cryptodev.h, but no support
+ * seems to be implemented at all for the moment.
+ *
+ * At the time of writing, it seems impossible to write proper support for
+ * FreeBSD's asym features without some very deep knowledge and access to
+ * specific kernel modules.
+ *
+ * /Richard Levitte, 2017-05-11
+ */
+#if 0
+# ifndef OPENSSL_NO_RSA
+        || !ENGINE_set_RSA(e, devcrypto_rsa)
+# endif
+# ifndef OPENSSL_NO_DSA
+        || !ENGINE_set_DSA(e, devcrypto_dsa)
+# endif
+# ifndef OPENSSL_NO_DH
+        || !ENGINE_set_DH(e, devcrypto_dh)
+# endif
+# ifndef OPENSSL_NO_EC
+        || !ENGINE_set_EC(e, devcrypto_ec)
+# endif
+#endif
+        || !ENGINE_set_ciphers(e, devcrypto_ciphers)
+#if defined(COP_FLAG_UPDATE) &amp;&amp; defined(COP_FLAG_FINAL)
+        || !ENGINE_set_digests(e, devcrypto_digests)
+#endif
+        ) {
+        ENGINE_free(e);
+        return;
+    }
+
+    ENGINE_add(e);
+    ENGINE_free(e);          /* Loose our local reference */
+    ERR_clear_error();
+}
diff --git a/crypto/engine/eng_err.c b/crypto/engine/eng_err.c
index ec783be..5f24e99 100644
--- a/crypto/engine/eng_err.c
+++ b/crypto/engine/eng_err.c
@@ -14,6 +14,7 @@
 #ifndef OPENSSL_NO_ERR
 
 static const ERR_STRING_DATA ENGINE_str_functs[] = {
+    {ERR_PACK(ERR_LIB_ENGINE, ENGINE_F_DIGEST_UPDATE, 0), &quot;digest_update&quot;},
     {ERR_PACK(ERR_LIB_ENGINE, ENGINE_F_DYNAMIC_CTRL, 0), &quot;dynamic_ctrl&quot;},
     {ERR_PACK(ERR_LIB_ENGINE, ENGINE_F_DYNAMIC_GET_DATA_CTX, 0),
      &quot;dynamic_get_data_ctx&quot;},
diff --git a/crypto/err/err.c b/crypto/err/err.c
index 1c5d9e7..37637a7 100644
--- a/crypto/err/err.c
+++ b/crypto/err/err.c
@@ -84,6 +84,9 @@ static ERR_STRING_DATA ERR_str_functs[] = {
     {ERR_PACK(0, SYS_F_GETSOCKNAME, 0), &quot;getsockname&quot;},
     {ERR_PACK(0, SYS_F_GETHOSTBYNAME, 0), &quot;gethostbyname&quot;},
     {ERR_PACK(0, SYS_F_FFLUSH, 0), &quot;fflush&quot;},
+    {ERR_PACK(0, SYS_F_OPEN, 0), &quot;open&quot;},
+    {ERR_PACK(0, SYS_F_CLOSE, 0), &quot;close&quot;},
+    {ERR_PACK(0, SYS_F_IOCTL, 0), &quot;ioctl&quot;},
     {0, NULL},
 };
 
@@ -117,6 +120,7 @@ static ERR_STRING_DATA ERR_str_reasons[] = {
     {ERR_R_INTERNAL_ERROR, &quot;internal error&quot;},
     {ERR_R_DISABLED, &quot;called a function that was disabled at compile-time&quot;},
     {ERR_R_INIT_FAIL, &quot;init fail&quot;},
+    {ERR_R_OPERATION_FAIL, &quot;operation fail&quot;},
 
     {0, NULL},
 };
diff --git a/crypto/err/openssl.txt b/crypto/err/openssl.txt
index 813ca74..d9fa3d3 100644
--- a/crypto/err/openssl.txt
+++ b/crypto/err/openssl.txt
@@ -589,6 +589,7 @@ EC_F_PKEY_EC_DERIVE:217:pkey_ec_derive
 EC_F_PKEY_EC_KEYGEN:199:pkey_ec_keygen
 EC_F_PKEY_EC_PARAMGEN:219:pkey_ec_paramgen
 EC_F_PKEY_EC_SIGN:218:pkey_ec_sign
+ENGINE_F_DIGEST_UPDATE:198:digest_update
 ENGINE_F_DYNAMIC_CTRL:180:dynamic_ctrl
 ENGINE_F_DYNAMIC_GET_DATA_CTX:181:dynamic_get_data_ctx
 ENGINE_F_DYNAMIC_LOAD:182:dynamic_load
diff --git a/crypto/include/internal/engine.h b/crypto/include/internal/engine.h
index b02e4c6..f80ae3e 100644
--- a/crypto/include/internal/engine.h
+++ b/crypto/include/internal/engine.h
@@ -10,6 +10,7 @@
 #include &lt;openssl/engine.h&gt;
 
 void engine_load_openssl_int(void);
+void engine_load_devcrypto_int(void);
 void engine_load_rdrand_int(void);
 void engine_load_dynamic_int(void);
 void engine_load_padlock_int(void);
diff --git a/crypto/init.c b/crypto/init.c
index 5f7e907..2d2b07d 100644
--- a/crypto/init.c
+++ b/crypto/init.c
@@ -241,6 +241,18 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_engine_openssl)
     engine_load_openssl_int();
     return 1;
 }
+# ifndef OPENSSL_NO_DEVCRYPTOENG
+static CRYPTO_ONCE engine_devcrypto = CRYPTO_ONCE_STATIC_INIT;
+DEFINE_RUN_ONCE_STATIC(ossl_init_engine_devcrypto)
+{
+#  ifdef OPENSSL_INIT_DEBUG
+    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_engine_devcrypto: &quot;
+                    &quot;engine_load_devcrypto_int()\n&quot;);
+#  endif
+    engine_load_devcrypto_int();
+    return 1;
+}
+# endif
 
 # ifndef OPENSSL_NO_RDRAND
 static CRYPTO_ONCE engine_rdrand = CRYPTO_ONCE_STATIC_INIT;
@@ -560,6 +572,11 @@ int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings)
     if ((opts &amp; OPENSSL_INIT_ENGINE_OPENSSL)
             &amp;&amp; !RUN_ONCE(&amp;engine_openssl, ossl_init_engine_openssl))
         return 0;
+# if !defined(OPENSSL_NO_HW) &amp;&amp; !defined(OPENSSL_NO_DEVCRYPTOENG)
+    if ((opts &amp; OPENSSL_INIT_ENGINE_CRYPTODEV)
+            &amp;&amp; !RUN_ONCE(&amp;engine_devcrypto, ossl_init_engine_devcrypto))
+        return 0;
+# endif
 # ifndef OPENSSL_NO_RDRAND
     if ((opts &amp; OPENSSL_INIT_ENGINE_RDRAND)
             &amp;&amp; !RUN_ONCE(&amp;engine_rdrand, ossl_init_engine_rdrand))
diff --git a/include/openssl/engineerr.h b/include/openssl/engineerr.h
index 2f35887..c3e3844 100644
--- a/include/openssl/engineerr.h
+++ b/include/openssl/engineerr.h
@@ -22,6 +22,7 @@ int ERR_load_ENGINE_strings(void);
 /*
  * ENGINE function codes.
  */
+# define ENGINE_F_DIGEST_UPDATE                           198
 # define ENGINE_F_DYNAMIC_CTRL                            180
 # define ENGINE_F_DYNAMIC_GET_DATA_CTX                    181
 # define ENGINE_F_DYNAMIC_LOAD                            182
diff --git a/include/openssl/err.h b/include/openssl/err.h
index 6661945..e60640b 100644
--- a/include/openssl/err.h
+++ b/include/openssl/err.h
@@ -160,6 +160,9 @@ typedef struct err_state_st {
 # define SYS_F_GETSOCKNAME       16
 # define SYS_F_GETHOSTBYNAME     17
 # define SYS_F_FFLUSH            18
+# define SYS_F_OPEN              19
+# define SYS_F_CLOSE             20
+# define SYS_F_IOCTL             21
 
 /* reasons */
 # define ERR_R_SYS_LIB   ERR_LIB_SYS/* 2 */
@@ -192,6 +195,7 @@ typedef struct err_state_st {
 # define ERR_R_DISABLED                          (5|ERR_R_FATAL)
 # define ERR_R_INIT_FAIL                         (6|ERR_R_FATAL)
 # define ERR_R_PASSED_INVALID_ARGUMENT           (7)
+# define ERR_R_OPERATION_FAIL                    (8|ERR_R_FATAL)
 
 /*
  * 99 is the maximum possible ERR_R_... code, higher values are reserved for
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015238.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="015242.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15241">[ date ]</a>
              <a href="thread.html#15241">[ thread ]</a>
              <a href="subject.html#15241">[ subject ]</a>
              <a href="author.html#15241">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
