<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2017-June/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1498730169.913414.8274.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015258.html">
   <LINK REL="Next"  HREF="015262.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1498730169.913414.8274.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Thu Jun 29 09:56:09 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="015258.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="015262.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15260">[ date ]</a>
              <a href="thread.html#15260">[ thread ]</a>
              <a href="subject.html#15260">[ subject ]</a>
              <a href="author.html#15260">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  6fc1d33c90015d3ad5738ec99aaa12fdb9640295 (commit)
       via  f95c439804bc227818b4290939569b515d730a63 (commit)
       via  2fad1dd26ac11dd3b4e2a87a2b19665b132f7edc (commit)
       via  8f507bc5d5fa3b848acb3db8618b55b5f643f6b3 (commit)
       via  e2e603fe7c5b35d8dadb1eec4696307d16665731 (commit)
       via  fa66949c26ad4381cbc90746c71597f2311f90a3 (commit)
       via  f91ded1fc40bbe3950ae3e971d4c84a2edf039f8 (commit)
       via  d32e10d6fadd39bf01282922a8ed3543173de440 (commit)
       via  970f467ac32af4fb5680eb5bc845f35618468bed (commit)
       via  7ad2ef366c3e96747dabee232a10b33d8fd2262a (commit)
       via  1aabc2445b126f951707b287db9a9145b003f2ca (commit)
       via  50ecedda40d0e57c635d673c1e66cb688ed9719e (commit)
       via  6d737ea09ba62b15df00cd99c4728a4dc55086df (commit)
       via  a09003ea22fd99511cc0153314c8751a84d95496 (commit)
       via  e61ec2d9babf30da3a4d94554e576bf10c1fc92c (commit)
       via  e1613d9f253329e033c62d1ed7d0b7826bf82965 (commit)
       via  c403a1ddff475ae5346ba1b9ee431a5b995a1584 (commit)
       via  9c6da42d0c61fafcf860c8a6c03efd3c33826f99 (commit)
       via  dc10560eba147b1b6484153b424d8f715c055e2f (commit)
       via  86f7b042124b3395a9c9b8dacc02dbba579ca0e8 (commit)
       via  71a5516dcc8a91a9c4fbb724ea7e3658e85f2ad2 (commit)
       via  c785fd48e68611c837f4e30027c02b84525501af (commit)
      from  a599574be17579496877bcdcc5e1eeaf5b014cf3 (commit)


- Log -----------------------------------------------------------------
commit 6fc1d33c90015d3ad5738ec99aaa12fdb9640295
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Jun 27 23:08:54 2017 +0200

    STORE 'file' scheme loader: refactor the treatment of matches
    
    Sometimes, 'file_load' couldn't really distinguish if a file handler
    matched the data and produced an error or if it didn't match the data
    at all.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit f95c439804bc227818b4290939569b515d730a63
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri May 26 18:36:26 2017 +0200

    STORE: Add an entry in NEWS and CHANGES
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit 2fad1dd26ac11dd3b4e2a87a2b19665b132f7edc
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu May 18 16:07:15 2017 +0200

    STORE test recipe: Remove comment refering to OpenConnect
    
    These tests were inspired by OpenConnect and incorporated
    by permission of David Woodhouse under CLA
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit 8f507bc5d5fa3b848acb3db8618b55b5f643f6b3
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Dec 13 13:47:13 2016 +0100

    Add documentation for the storeutl app
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit e2e603fe7c5b35d8dadb1eec4696307d16665731
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Dec 13 13:46:53 2016 +0100

    Add documentation for STORE functions
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit fa66949c26ad4381cbc90746c71597f2311f90a3
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sun Dec 11 07:06:13 2016 +0100

    engine app: print out information on STORE loaders and STORE FILE handlers
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit f91ded1fc40bbe3950ae3e971d4c84a2edf039f8
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sun Dec 11 07:02:06 2016 +0100

    STORE: add ENGINE information to loaders
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit d32e10d6fadd39bf01282922a8ed3543173de440
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Feb 7 16:30:31 2017 +0100

    Test that storeutl with a directory path works as expected
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit 970f467ac32af4fb5680eb5bc845f35618468bed
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Feb 7 16:19:40 2017 +0100

    STORE 'file' scheme loader: Add directory listing capability
    
    This has it recognised when the given path is a directory.  In that
    case, the file loader will give back a series of names, all as URI
    formatted as possible given the incoming URI.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit 7ad2ef366c3e96747dabee232a10b33d8fd2262a
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Feb 11 01:18:29 2017 +0100

    STORE 'file' scheme loader: Add handler for encrypted PKCS#8 data
    
    Add a separate handler for encrypted PKCS#8 data.  This uses the new
    restart functionality.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit 1aabc2445b126f951707b287db9a9145b003f2ca
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Feb 11 01:17:50 2017 +0100

    STORE 'file' scheme loader: refactor file_load to support decoding restart
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit 50ecedda40d0e57c635d673c1e66cb688ed9719e
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 8 14:28:42 2016 +0100

    STORE: Add a OSSL_STORE_INFO type to help support file handler restarts
    
    Some containers might very simply decode into something new that
    deserves to be considered as new (embedded) data.  With the help of a
    special OSSL_STORE_INFO type, make that new data available to the
    loader functions so they can start over.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit 6d737ea09ba62b15df00cd99c4728a4dc55086df
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon Dec 5 15:13:01 2016 +0100

    STORE tests: add PKCS#12 tests
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit a09003ea22fd99511cc0153314c8751a84d95496
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Feb 11 01:16:07 2017 +0100

    STORE 'file' scheme loader: add support for the PKCS#12 container
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit e61ec2d9babf30da3a4d94554e576bf10c1fc92c
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon Dec 5 23:15:58 2016 +0100

    STORE 'file' scheme loader: add support for containers
    
    Containers are objects that are containers for a bunch of other
    objects with types we recognise but aren't readable in a stream.  Such
    containers are read and parsed, and their content is cached, to be
    served one object at a time.
    
    This extends the FILE_HANDLER type to include a function to destroy
    the cache and a function to simulate the EOF check.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit e1613d9f253329e033c62d1ed7d0b7826bf82965
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Nov 19 20:24:17 2016 +0100

    Add a test that checks the store utility
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit c403a1ddff475ae5346ba1b9ee431a5b995a1584
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Nov 19 19:38:23 2016 +0100

    Add a simple store utility command
    
    This command can be used to view the contents of any supported type of
    information fetched from a URI, and output them in PEM format.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit 9c6da42d0c61fafcf860c8a6c03efd3c33826f99
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon Nov 28 17:30:21 2016 +0100

    Add a STORE loader for the &quot;file&quot; scheme
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit dc10560eba147b1b6484153b424d8f715c055e2f
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Nov 18 18:18:37 2016 +0100

    Make it possible to peek at BIO data through BIO_f_buffer()
    
    This is needed for the upcoming &quot;file&quot; scheme STORE loader.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit 86f7b042124b3395a9c9b8dacc02dbba579ca0e8
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Nov 18 18:17:20 2016 +0100

    Make asn1_d2i_read_bio accessible from STORE
    
    This is needed for the upcoming &quot;file&quot; scheme STORE loader.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit 71a5516dcc8a91a9c4fbb724ea7e3658e85f2ad2
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 8 15:51:31 2016 +0100

    Add the STORE module
    
    This STORE module adds the following functionality:
    
    - A function OSSL_STORE_open(), OSSL_STORE_load() and OSSL_STORE_close()
      that accesses a URI and helps loading the supported objects (PKEYs,
      CERTs and CRLs for the moment) from it.
    - An opaque type OSSL_STORE_INFO that holds information on each loaded
      object.
    - A few functions to retrieve desired data from a OSSL_STORE_INFO
      reference.
    - Functions to register and unregister loaders for different URI
      schemes.  This enables dynamic addition of loaders from applications
      or from engines.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

commit c785fd48e68611c837f4e30027c02b84525501af
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Dec 6 04:29:08 2016 +0100

    Make it possible to refer to ERR_R_UI_LIB
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3542">https://github.com/openssl/openssl/pull/3542</A>)

-----------------------------------------------------------------------

Summary of changes:
 CHANGES                                  |    9 +
 Configure                                |    2 +-
 NEWS                                     |    2 +
 apps/build.info                          |    2 +-
 apps/engine.c                            |   32 +
 apps/storeutl.c                          |  199 ++++++
 crypto/asn1/a_d2i_fp.c                   |    5 +-
 crypto/bio/bf_buff.c                     |   16 +
 crypto/err/err.c                         |    4 +
 crypto/err/err_all.c                     |    4 +-
 crypto/err/openssl.ec                    |    1 +
 crypto/err/openssl.txt                   |   48 ++
 crypto/include/internal/asn1_int.h       |    1 +
 crypto/include/internal/store.h          |   10 +
 crypto/init.c                            |    2 +
 crypto/store/build.info                  |    4 +
 crypto/store/loader_file.c               | 1140 ++++++++++++++++++++++++++++++
 crypto/store/store_err.c                 |  116 +++
 crypto/store/store_init.c                |   33 +
 crypto/store/store_lib.c                 |  409 +++++++++++
 crypto/store/store_locl.h                |   94 +++
 crypto/store/store_register.c            |  278 ++++++++
 crypto/store/store_strings.c             |   28 +
 doc/man1/storeutl.pod                    |   76 ++
 doc/man3/OSSL_STORE_INFO.pod             |  196 +++++
 doc/man3/OSSL_STORE_LOADER.pod           |  229 ++++++
 doc/man3/OSSL_STORE_open.pod             |  145 ++++
 doc/man7/ossl_store.pod                  |  103 +++
 include/openssl/bio.h                    |    2 +
 include/openssl/err.h                    |    8 +-
 include/openssl/ossl_typ.h               |    2 +
 include/openssl/store.h                  |  214 ++++++
 include/openssl/storeerr.h               |   74 ++
 test/recipes/90-test_store.t             |  349 +++++++++
 test/recipes/90-test_store_data/ca.cnf   |   56 ++
 test/recipes/90-test_store_data/user.cnf |   19 +
 util/libcrypto.num                       |   42 ++
 util/private.num                         |   11 +
 38 files changed, 3957 insertions(+), 8 deletions(-)
 create mode 100644 apps/storeutl.c
 create mode 100644 crypto/include/internal/store.h
 create mode 100644 crypto/store/build.info
 create mode 100644 crypto/store/loader_file.c
 create mode 100644 crypto/store/store_err.c
 create mode 100644 crypto/store/store_init.c
 create mode 100644 crypto/store/store_lib.c
 create mode 100644 crypto/store/store_locl.h
 create mode 100644 crypto/store/store_register.c
 create mode 100644 crypto/store/store_strings.c
 create mode 100644 doc/man1/storeutl.pod
 create mode 100644 doc/man3/OSSL_STORE_INFO.pod
 create mode 100644 doc/man3/OSSL_STORE_LOADER.pod
 create mode 100644 doc/man3/OSSL_STORE_open.pod
 create mode 100644 doc/man7/ossl_store.pod
 create mode 100644 include/openssl/store.h
 create mode 100644 include/openssl/storeerr.h
 create mode 100644 test/recipes/90-test_store.t
 create mode 100644 test/recipes/90-test_store_data/ca.cnf
 create mode 100644 test/recipes/90-test_store_data/user.cnf

diff --git a/CHANGES b/CHANGES
index bda8e22..4500fbd 100644
--- a/CHANGES
+++ b/CHANGES
@@ -9,6 +9,15 @@
 
  Changes between 1.1.0f and 1.1.1 [xx XXX xxxx]
 
+  *) Add a STORE module, which implements a uniform and URI based reader of
+     stores that can contain keys, certificates, CRLs and numerous other
+     objects.  The main API is loosely based on a few stdio functions,
+     and includes OSSL_STORE_open, OSSL_STORE_load, OSSL_STORE_eof,
+     OSSL_STORE_error and OSSL_STORE_close.
+     The implementation uses backends called &quot;loaders&quot; to implement arbitrary
+     URI schemes.  There is one built in &quot;loader&quot; for the 'file' scheme.
+     [Richard Levitte]
+
   *) Add devcrypto engine.  This has been implemented against cryptodev-linux,
      then adjusted to work on FreeBSD 8.4 as well.
      Enable by configuring with 'enable-devcryptoeng'.  This is done by default
diff --git a/Configure b/Configure
index 2eacb23..e302a58 100755
--- a/Configure
+++ b/Configure
@@ -310,7 +310,7 @@ $config{sdirs} = [
     &quot;bn&quot;, &quot;ec&quot;, &quot;rsa&quot;, &quot;dsa&quot;, &quot;dh&quot;, &quot;dso&quot;, &quot;engine&quot;,
     &quot;buffer&quot;, &quot;bio&quot;, &quot;stack&quot;, &quot;lhash&quot;, &quot;rand&quot;, &quot;err&quot;,
     &quot;evp&quot;, &quot;asn1&quot;, &quot;pem&quot;, &quot;x509&quot;, &quot;x509v3&quot;, &quot;conf&quot;, &quot;txt_db&quot;, &quot;pkcs7&quot;, &quot;pkcs12&quot;, &quot;comp&quot;, &quot;ocsp&quot;, &quot;ui&quot;,
-    &quot;cms&quot;, &quot;ts&quot;, &quot;srp&quot;, &quot;cmac&quot;, &quot;ct&quot;, &quot;async&quot;, &quot;kdf&quot;
+    &quot;cms&quot;, &quot;ts&quot;, &quot;srp&quot;, &quot;cmac&quot;, &quot;ct&quot;, &quot;async&quot;, &quot;kdf&quot;, &quot;store&quot;
     ];
 # test/ subdirectories to build
 $config{tdirs} = [ &quot;ossl_shim&quot; ];
diff --git a/NEWS b/NEWS
index 4c582fc..846ca1d 100644
--- a/NEWS
+++ b/NEWS
@@ -7,6 +7,8 @@
 
   Major changes between OpenSSL 1.1.0f and OpenSSL 1.1.1 [under development]
 
+      o 
+      o Add a STORE module (OSSL_STORE)
       o Claim the namespaces OSSL and OPENSSL, represented as symbol prefixes
 
   Major changes between OpenSSL 1.1.0e and OpenSSL 1.1.0f [25 May 2017]
diff --git a/apps/build.info b/apps/build.info
index e2ddd2b..996e5a6 100644
--- a/apps/build.info
+++ b/apps/build.info
@@ -6,7 +6,7 @@
             genpkey.c genrsa.c nseq.c ocsp.c passwd.c pkcs12.c pkcs7.c pkcs8.c
             pkey.c pkeyparam.c pkeyutl.c prime.c rand.c req.c rsa.c rsautl.c
             s_client.c s_server.c s_time.c sess_id.c smime.c speed.c spkac.c
-            srp.c ts.c verify.c version.c x509.c rehash.c
+            srp.c ts.c verify.c version.c x509.c rehash.c storeutl.c
             apps.c opt.c s_cb.c s_socket.c
             app_rand.c),
           split(/\s+/, $target{apps_aux_src}) );
diff --git a/apps/engine.c b/apps/engine.c
index 49f53ee..7724084 100644
--- a/apps/engine.c
+++ b/apps/engine.c
@@ -19,6 +19,7 @@ NON_EMPTY_TRANSLATION_UNIT
 # include &lt;openssl/err.h&gt;
 # include &lt;openssl/engine.h&gt;
 # include &lt;openssl/ssl.h&gt;
+# include &lt;openssl/store.h&gt;
 
 typedef enum OPTION_choice {
     OPT_ERR = -1, OPT_EOF = 0, OPT_HELP,
@@ -258,6 +259,25 @@ static void util_do_cmds(ENGINE *e, STACK_OF(OPENSSL_STRING) *cmds,
     }
 }
 
+struct util_store_cap_data {
+    ENGINE *engine;
+    char **cap_buf;
+    int *cap_size;
+    int ok;
+};
+static void util_store_cap(const OSSL_STORE_LOADER *loader, void *arg)
+{
+    struct util_store_cap_data *ctx = arg;
+
+    if (OSSL_STORE_LOADER_get0_engine(loader) == ctx-&gt;engine) {
+        char buf[256];
+        BIO_snprintf(buf, sizeof(buf), &quot;STORE(%s)&quot;,
+                     OSSL_STORE_LOADER_get0_scheme(loader));
+        if (!append_buf(ctx-&gt;cap_buf, ctx-&gt;cap_size, buf))
+            ctx-&gt;ok = 0;
+    }
+}
+
 int engine_main(int argc, char **argv)
 {
     int ret = 1, i;
@@ -405,6 +425,18 @@ int engine_main(int argc, char **argv)
                     if (!append_buf(&amp;cap_buf, &amp;cap_size, OBJ_nid2sn(nids[k])))
                         goto end;
  skip_pmeths:
+                {
+                    struct util_store_cap_data store_ctx;
+
+                    store_ctx.engine = e;
+                    store_ctx.cap_buf = &amp;cap_buf;
+                    store_ctx.cap_size = &amp;cap_size;
+                    store_ctx.ok = 1;
+
+                    OSSL_STORE_do_all_loaders(util_store_cap, &amp;store_ctx);
+                    if (!store_ctx.ok)
+                        goto end;
+                }
                 if (cap_buf != NULL &amp;&amp; (*cap_buf != '\0'))
                     BIO_printf(out, &quot; [%s]\n&quot;, cap_buf);
 
diff --git a/apps/storeutl.c b/apps/storeutl.c
new file mode 100644
index 0000000..dd2f60b
--- /dev/null
+++ b/apps/storeutl.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/opensslconf.h&gt;
+
+#include &quot;apps.h&quot;
+#include &lt;openssl/err.h&gt;
+#include &lt;openssl/pem.h&gt;
+#include &lt;openssl/store.h&gt;
+
+typedef enum OPTION_choice {
+    OPT_ERR = -1, OPT_EOF = 0, OPT_HELP, OPT_ENGINE, OPT_OUT, OPT_PASSIN,
+    OPT_NOOUT, OPT_TEXT
+} OPTION_CHOICE;
+
+const OPTIONS storeutl_options[] = {
+    {OPT_HELP_STR, 1, '-', &quot;Usage: %s [options] uri\nValid options are:\n&quot;},
+    {&quot;help&quot;, OPT_HELP, '-', &quot;Display this summary&quot;},
+    {&quot;out&quot;, OPT_OUT, '&gt;', &quot;Output file - default stdout&quot;},
+    {&quot;passin&quot;, OPT_PASSIN, 's', &quot;Input file pass phrase source&quot;},
+    {&quot;text&quot;, OPT_TEXT, '-', &quot;Print a text form of the objects&quot;},
+    {&quot;noout&quot;, OPT_NOOUT, '-', &quot;No PEM output, just status&quot;},
+#ifndef OPENSSL_NO_ENGINE
+    {&quot;engine&quot;, OPT_ENGINE, 's', &quot;Use engine, possibly a hardware device&quot;},
+#endif
+    {NULL}
+};
+
+int storeutl_main(int argc, char *argv[])
+{
+    OSSL_STORE_CTX *store_ctx = NULL;
+    int ret = 1, noout = 0, text = 0, items = 0;
+    char *outfile = NULL, *passin = NULL, *passinarg = NULL;
+    BIO *out = NULL;
+    ENGINE *e = NULL;
+    OPTION_CHOICE o;
+    char *prog = opt_init(argc, argv, storeutl_options);
+    PW_CB_DATA pw_cb_data;
+
+    while ((o = opt_next()) != OPT_EOF) {
+        switch (o) {
+        case OPT_EOF:
+        case OPT_ERR:
+ opthelp:
+            BIO_printf(bio_err, &quot;%s: Use -help for summary.\n&quot;, prog);
+            goto end;
+        case OPT_HELP:
+            opt_help(storeutl_options);
+            ret = 0;
+            goto end;
+        case OPT_OUT:
+            outfile = opt_arg();
+            break;
+        case OPT_PASSIN:
+            passinarg = opt_arg();
+            break;
+        case OPT_NOOUT:
+            noout = 1;
+            break;
+        case OPT_TEXT:
+            text = 1;
+            break;
+        case OPT_ENGINE:
+            e = setup_engine(opt_arg(), 0);
+            break;
+        }
+    }
+    argc = opt_num_rest();
+    argv = opt_rest();
+
+    if (argc == 0) {
+        BIO_printf(bio_err, &quot;%s: No URI given, nothing to do...\n&quot;, prog);
+        goto opthelp;
+    }
+    if (argc &gt; 1) {
+        BIO_printf(bio_err, &quot;%s: Unknown extra parameters after URI\n&quot;, prog);
+        goto opthelp;
+    }
+
+    if (!app_passwd(passinarg, NULL, &amp;passin, NULL)) {
+        BIO_printf(bio_err, &quot;Error getting passwords\n&quot;);
+        goto end;
+    }
+    pw_cb_data.password = passin;
+    pw_cb_data.prompt_info = argv[0];
+
+    out = bio_open_default(outfile, 'w', FORMAT_TEXT);
+    if (out == NULL)
+        goto end;
+
+    if ((store_ctx = OSSL_STORE_open(argv[0], get_ui_method(), &amp;pw_cb_data,
+                                     NULL, NULL)) == NULL) {
+        BIO_printf(bio_err, &quot;Couldn't open file or uri %s\n&quot;, argv[0]);
+        ERR_print_errors(bio_err);
+        goto end;
+    }
+
+    /* From here on, we count errors, and we'll return the count at the end */
+    ret = 0;
+
+    for (;;) {
+        OSSL_STORE_INFO *info = OSSL_STORE_load(store_ctx);
+        int type = info == NULL ? 0 : OSSL_STORE_INFO_get_type(info);
+        const char *infostr =
+            info == NULL ? NULL : OSSL_STORE_INFO_type_string(type);
+
+        if (info == NULL) {
+            if (OSSL_STORE_eof(store_ctx))
+                break;
+
+            if (OSSL_STORE_error(store_ctx)) {
+                ERR_print_errors(bio_err);
+                ret++;
+                continue;
+            }
+
+            BIO_printf(bio_err,
+                       &quot;ERROR: OSSL_STORE_load() returned NULL without &quot;
+                       &quot;eof or error indications\n&quot;);
+            BIO_printf(bio_err, &quot;       This is an error in the loader\n&quot;);
+            ERR_print_errors(bio_err);
+            ret++;
+            break;
+        }
+
+        if (type == OSSL_STORE_INFO_NAME) {
+            const char *name = OSSL_STORE_INFO_get0_NAME(info);
+            const char *desc = OSSL_STORE_INFO_get0_NAME_description(info);
+            BIO_printf(bio_out, &quot;%d: %s: %s\n&quot;, items, infostr, name);
+            if (desc != NULL)
+                BIO_printf(bio_out, &quot;%s\n&quot;, desc);
+        } else {
+            BIO_printf(bio_out, &quot;%d: %s\n&quot;, items, infostr);
+        }
+
+        /*
+         * Unfortunately, PEM_X509_INFO_write_bio() is sorely lacking in
+         * functionality, so we must figure out how exactly to write things
+         * ourselves...
+         */
+        switch (type) {
+        case OSSL_STORE_INFO_NAME:
+            break;
+        case OSSL_STORE_INFO_PARAMS:
+            if (text)
+                EVP_PKEY_print_params(out, OSSL_STORE_INFO_get0_PARAMS(info),
+                                      0, NULL);
+            if (!noout)
+                PEM_write_bio_Parameters(out,
+                                         OSSL_STORE_INFO_get0_PARAMS(info));
+            break;
+        case OSSL_STORE_INFO_PKEY:
+            if (text)
+                EVP_PKEY_print_private(out, OSSL_STORE_INFO_get0_PKEY(info),
+                                       0, NULL);
+            if (!noout)
+                PEM_write_bio_PrivateKey(out, OSSL_STORE_INFO_get0_PKEY(info),
+                                         NULL, NULL, 0, NULL, NULL);
+            break;
+        case OSSL_STORE_INFO_CERT:
+            if (text)
+                X509_print(out, OSSL_STORE_INFO_get0_CERT(info));
+            if (!noout)
+                PEM_write_bio_X509(out, OSSL_STORE_INFO_get0_CERT(info));
+            break;
+        case OSSL_STORE_INFO_CRL:
+            if (text)
+                X509_CRL_print(out, OSSL_STORE_INFO_get0_CRL(info));
+            if (!noout)
+                PEM_write_bio_X509_CRL(out, OSSL_STORE_INFO_get0_CRL(info));
+            break;
+        default:
+            BIO_printf(bio_err, &quot;!!! Unknown code\n&quot;);
+            ret++;
+            break;
+        }
+        items++;
+        OSSL_STORE_INFO_free(info);
+    }
+    BIO_printf(out, &quot;Total found: %d\n&quot;, items);
+
+    if (!OSSL_STORE_close(store_ctx)) {
+        ERR_print_errors(bio_err);
+        ret++;
+        goto end;
+    }
+
+ end:
+    BIO_free_all(out);
+    OPENSSL_free(passin);
+    release_engine(e);
+    return ret;
+}
diff --git a/crypto/asn1/a_d2i_fp.c b/crypto/asn1/a_d2i_fp.c
index e5c1d0e..5fa4d0f 100644
--- a/crypto/asn1/a_d2i_fp.c
+++ b/crypto/asn1/a_d2i_fp.c
@@ -13,8 +13,7 @@
 #include &quot;internal/numbers.h&quot;
 #include &lt;openssl/buffer.h&gt;
 #include &lt;openssl/asn1.h&gt;
-
-static int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb);
+#include &quot;internal/asn1_int.h&quot;
 
 #ifndef NO_OLD_ASN1
 # ifndef OPENSSL_NO_STDIO
@@ -92,7 +91,7 @@ void *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x)
 
 #define HEADER_SIZE   8
 #define ASN1_CHUNK_INITIAL_SIZE (16 * 1024)
-static int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
+int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
 {
     BUF_MEM *b;
     unsigned char *p;
diff --git a/crypto/bio/bf_buff.c b/crypto/bio/bf_buff.c
index 7a73095..255a4d4 100644
--- a/crypto/bio/bf_buff.c
+++ b/crypto/bio/bf_buff.c
@@ -255,6 +255,11 @@ static long buffer_ctrl(BIO *b, int cmd, long num, void *ptr)
             return (0);
         ret = BIO_ctrl(b-&gt;next_bio, cmd, num, ptr);
         break;
+    case BIO_CTRL_EOF:
+        if (ctx-&gt;ibuf_len &gt; 0)
+            return 0;
+        ret = BIO_ctrl(b-&gt;next_bio, cmd, num, ptr);
+        break;
     case BIO_CTRL_INFO:
         ret = (long)ctx-&gt;obuf_len;
         break;
@@ -380,6 +385,17 @@ static long buffer_ctrl(BIO *b, int cmd, long num, void *ptr)
             !BIO_set_write_buffer_size(dbio, ctx-&gt;obuf_size))
             ret = 0;
         break;
+    case BIO_CTRL_PEEK:
+        /* Ensure there's stuff in the input buffer */
+        {
+            char fake_buf[1];
+            (void)buffer_read(b, fake_buf, 0);
+        }
+        if (num &gt; ctx-&gt;ibuf_len)
+            num = ctx-&gt;ibuf_len;
+        memcpy(ptr, &amp;(ctx-&gt;ibuf[ctx-&gt;ibuf_off]), num);
+        ret = num;
+        break;
     default:
         if (b-&gt;next_bio == NULL)
             return (0);
diff --git a/crypto/err/err.c b/crypto/err/err.c
index 37637a7..adbd41e 100644
--- a/crypto/err/err.c
+++ b/crypto/err/err.c
@@ -60,6 +60,7 @@ static ERR_STRING_DATA ERR_str_libraries[] = {
     {ERR_PACK(ERR_LIB_CT, 0, 0), &quot;CT routines&quot;},
     {ERR_PACK(ERR_LIB_ASYNC, 0, 0), &quot;ASYNC routines&quot;},
     {ERR_PACK(ERR_LIB_KDF, 0, 0), &quot;KDF routines&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, 0), &quot;STORE routines&quot;},
     {0, NULL},
 };
 
@@ -87,6 +88,7 @@ static ERR_STRING_DATA ERR_str_functs[] = {
     {ERR_PACK(0, SYS_F_OPEN, 0), &quot;open&quot;},
     {ERR_PACK(0, SYS_F_CLOSE, 0), &quot;close&quot;},
     {ERR_PACK(0, SYS_F_IOCTL, 0), &quot;ioctl&quot;},
+    {ERR_PACK(0, SYS_F_STAT, 0), &quot;stat&quot;},
     {0, NULL},
 };
 
@@ -107,6 +109,8 @@ static ERR_STRING_DATA ERR_str_reasons[] = {
     {ERR_R_PKCS7_LIB, &quot;PKCS7 lib&quot;},
     {ERR_R_X509V3_LIB, &quot;X509V3 lib&quot;},
     {ERR_R_ENGINE_LIB, &quot;ENGINE lib&quot;},
+    {ERR_R_UI_LIB, &quot;UI lib&quot;},
+    {ERR_R_OSSL_STORE_LIB, &quot;STORE lib&quot;},
     {ERR_R_ECDSA_LIB, &quot;ECDSA lib&quot;},
 
     {ERR_R_NESTED_ASN1_ERROR, &quot;nested asn1 error&quot;},
diff --git a/crypto/err/err_all.c b/crypto/err/err_all.c
index 6cc8c8f..3fff594 100644
--- a/crypto/err/err_all.c
+++ b/crypto/err/err_all.c
@@ -36,6 +36,7 @@
 #include &lt;openssl/ct.h&gt;
 #include &lt;openssl/async.h&gt;
 #include &lt;openssl/kdf.h&gt;
+#include &lt;openssl/store.h&gt;
 
 int err_load_crypto_strings_int(void)
 {
@@ -93,7 +94,8 @@ int err_load_crypto_strings_int(void)
 # endif
         ERR_load_ASYNC_strings() == 0 ||
 #endif
-        ERR_load_KDF_strings() == 0)
+        ERR_load_KDF_strings() == 0 ||
+        ERR_load_OSSL_STORE_strings() == 0)
         return 0;
 
     return 1;
diff --git a/crypto/err/openssl.ec b/crypto/err/openssl.ec
index 20b6b4a..be84c7c 100644
--- a/crypto/err/openssl.ec
+++ b/crypto/err/openssl.ec
@@ -32,6 +32,7 @@ L CMS           include/openssl/cms.h           crypto/cms/cms_err.c
 L CT            include/openssl/ct.h            crypto/ct/ct_err.c
 L ASYNC         include/openssl/async.h         crypto/async/async_err.c
 L KDF           include/openssl/kdf.h           crypto/kdf/kdf_err.c
+L OSSL_STORE    include/openssl/store.h         crypto/store/store_err.c
 
 # additional header files to be scanned for function names
 L NONE          include/openssl/x509_vfy.h      NONE
diff --git a/crypto/err/openssl.txt b/crypto/err/openssl.txt
index d9fa3d3..e539302 100644
--- a/crypto/err/openssl.txt
+++ b/crypto/err/openssl.txt
@@ -724,6 +724,37 @@ OCSP_F_OCSP_REQUEST_SIGN:110:OCSP_request_sign
 OCSP_F_OCSP_REQUEST_VERIFY:116:OCSP_request_verify
 OCSP_F_OCSP_RESPONSE_GET1_BASIC:111:OCSP_response_get1_basic
 OCSP_F_PARSE_HTTP_LINE1:118:parse_http_line1
+OSSL_STORE_F_FILE_GET_PASS:118:file_get_pass
+OSSL_STORE_F_FILE_LOAD:119:file_load
+OSSL_STORE_F_FILE_LOAD_TRY_DECODE:124:file_load_try_decode
+OSSL_STORE_F_FILE_NAME_TO_URI:126:file_name_to_uri
+OSSL_STORE_F_FILE_OPEN:120:file_open
+OSSL_STORE_F_OSSL_STORE_GET0_LOADER_INT:100:ossl_store_get0_loader_int
+OSSL_STORE_F_OSSL_STORE_INFO_GET1_CERT:101:OSSL_STORE_INFO_get1_CERT
+OSSL_STORE_F_OSSL_STORE_INFO_GET1_CRL:102:OSSL_STORE_INFO_get1_CRL
+OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME:103:OSSL_STORE_INFO_get1_NAME
+OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME_DESCRIPTION:135:\
+	OSSL_STORE_INFO_get1_NAME_description
+OSSL_STORE_F_OSSL_STORE_INFO_GET1_PARAMS:104:OSSL_STORE_INFO_get1_PARAMS
+OSSL_STORE_F_OSSL_STORE_INFO_GET1_PKEY:105:OSSL_STORE_INFO_get1_PKEY
+OSSL_STORE_F_OSSL_STORE_INFO_NEW_CERT:106:OSSL_STORE_INFO_new_CERT
+OSSL_STORE_F_OSSL_STORE_INFO_NEW_CRL:107:OSSL_STORE_INFO_new_CRL
+OSSL_STORE_F_OSSL_STORE_INFO_NEW_EMBEDDED:123:ossl_store_info_new_EMBEDDED
+OSSL_STORE_F_OSSL_STORE_INFO_NEW_NAME:109:OSSL_STORE_INFO_new_NAME
+OSSL_STORE_F_OSSL_STORE_INFO_NEW_PARAMS:110:OSSL_STORE_INFO_new_PARAMS
+OSSL_STORE_F_OSSL_STORE_INFO_NEW_PKEY:111:OSSL_STORE_INFO_new_PKEY
+OSSL_STORE_F_OSSL_STORE_INFO_SET0_NAME_DESCRIPTION:134:\
+	OSSL_STORE_INFO_set0_NAME_description
+OSSL_STORE_F_OSSL_STORE_INIT_ONCE:112:ossl_store_init_once
+OSSL_STORE_F_OSSL_STORE_LOADER_NEW:113:OSSL_STORE_LOADER_new
+OSSL_STORE_F_OSSL_STORE_OPEN:114:OSSL_STORE_open
+OSSL_STORE_F_OSSL_STORE_OPEN_INT:115:*
+OSSL_STORE_F_OSSL_STORE_REGISTER_LOADER_INT:117:ossl_store_register_loader_int
+OSSL_STORE_F_OSSL_STORE_UNREGISTER_LOADER_INT:116:\
+	ossl_store_unregister_loader_int
+OSSL_STORE_F_TRY_DECODE_PARAMS:121:try_decode_params
+OSSL_STORE_F_TRY_DECODE_PKCS12:122:try_decode_PKCS12
+OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED:125:try_decode_PKCS8Encrypted
 PEM_F_B2I_DSS:127:b2i_dss
 PEM_F_B2I_PVK_BIO:128:b2i_PVK_bio
 PEM_F_B2I_RSA:129:b2i_rsa
@@ -1950,6 +1981,23 @@ OCSP_R_STATUS_TOO_OLD:127:status too old
 OCSP_R_UNKNOWN_MESSAGE_DIGEST:119:unknown message digest
 OCSP_R_UNKNOWN_NID:120:unknown nid
 OCSP_R_UNSUPPORTED_REQUESTORNAME_TYPE:129:unsupported requestorname type
+OSSL_STORE_R_AMBIGUOUS_CONTENT_TYPE:107:ambiguous content type
+OSSL_STORE_R_BAD_PASSWORD_READ:115:bad password read
+OSSL_STORE_R_ERROR_VERIFYING_PKCS12_MAC:113:error verifying pkcs12 mac
+OSSL_STORE_R_INVALID_SCHEME:106:invalid scheme
+OSSL_STORE_R_IS_NOT_A:112:is not a
+OSSL_STORE_R_NOT_A_CERTIFICATE:100:not a certificate
+OSSL_STORE_R_NOT_A_CRL:101:not a crl
+OSSL_STORE_R_NOT_A_KEY:102:not a key
+OSSL_STORE_R_NOT_A_NAME:103:not a name
+OSSL_STORE_R_NOT_PARAMETERS:104:not parameters
+OSSL_STORE_R_PASSPHRASE_CALLBACK_ERROR:114:passphrase callback error
+OSSL_STORE_R_PATH_MUST_BE_ABSOLUTE:108:path must be absolute
+OSSL_STORE_R_UI_PROCESS_INTERRUPTED_OR_CANCELLED:109:\
+	ui process interrupted or cancelled
+OSSL_STORE_R_UNREGISTERED_SCHEME:105:unregistered scheme
+OSSL_STORE_R_UNSUPPORTED_CONTENT_TYPE:110:unsupported content type
+OSSL_STORE_R_URI_AUTHORITY_UNSUPPORED:111:uri authority unsuppored
 PEM_R_BAD_BASE64_DECODE:100:bad base64 decode
 PEM_R_BAD_DECRYPT:101:bad decrypt
 PEM_R_BAD_END_LINE:102:bad end line
diff --git a/crypto/include/internal/asn1_int.h b/crypto/include/internal/asn1_int.h
index a2e2b17..8ff919c 100644
--- a/crypto/include/internal/asn1_int.h
+++ b/crypto/include/internal/asn1_int.h
@@ -99,3 +99,4 @@ struct asn1_pctx_st {
 } /* ASN1_PCTX */ ;
 
 int asn1_valid_host(const ASN1_STRING *host);
+int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb);
diff --git a/crypto/include/internal/store.h b/crypto/include/internal/store.h
new file mode 100644
index 0000000..f5013dc
--- /dev/null
+++ b/crypto/include/internal/store.h
@@ -0,0 +1,10 @@
+/*
+ * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+void ossl_store_cleanup_int(void);
diff --git a/crypto/init.c b/crypto/init.c
index 2d2b07d..e159a3d 100644
--- a/crypto/init.c
+++ b/crypto/init.c
@@ -24,6 +24,7 @@
 #include &lt;assert.h&gt;
 #include &lt;internal/thread_once.h&gt;
 #include &lt;internal/dso.h&gt;
+#include &lt;internal/store.h&gt;
 
 static int stopped = 0;
 
@@ -491,6 +492,7 @@ void OPENSSL_cleanup(void)
 #ifndef OPENSSL_NO_ENGINE
     engine_cleanup_int();
 #endif
+    ossl_store_cleanup_int();
     crypto_cleanup_all_ex_data_int();
     bio_cleanup();
     evp_cleanup_int();
diff --git a/crypto/store/build.info b/crypto/store/build.info
new file mode 100644
index 0000000..7d882f3
--- /dev/null
+++ b/crypto/store/build.info
@@ -0,0 +1,4 @@
+LIBS=../../libcrypto
+SOURCE[../../libcrypto]=\
+        store_err.c store_init.c store_lib.c store_register.c store_strings.c \
+        loader_file.c
diff --git a/crypto/store/loader_file.c b/crypto/store/loader_file.c
new file mode 100644
index 0000000..ea2ec8b
--- /dev/null
+++ b/crypto/store/loader_file.c
@@ -0,0 +1,1140 @@
+/*
+ * Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;string.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;assert.h&gt;
+
+#include &lt;openssl/bio.h&gt;
+#include &lt;openssl/dsa.h&gt;         /* For d2i_DSAPrivateKey */
+#include &lt;openssl/err.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/pem.h&gt;
+#include &lt;openssl/pkcs12.h&gt;      /* For the PKCS8 stuff o.O */
+#include &lt;openssl/rsa.h&gt;         /* For d2i_RSAPrivateKey */
+#include &lt;openssl/safestack.h&gt;
+#include &lt;openssl/store.h&gt;
+#include &lt;openssl/ui.h&gt;
+#include &lt;openssl/x509.h&gt;        /* For the PKCS8 stuff o.O */
+#include &quot;internal/asn1_int.h&quot;
+#include &quot;internal/o_dir.h&quot;
+#include &quot;internal/cryptlib.h&quot;
+#include &quot;store_locl.h&quot;
+
+#include &quot;e_os.h&quot;
+
+/*
+ *  Password prompting
+ */
+
+static char *file_get_pass(const UI_METHOD *ui_method, char *pass,
+                           size_t maxsize, const char *prompt_info, void *data)
+{
+    UI *ui = UI_new();
+    char *prompt = NULL;
+
+    if (ui == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_FILE_GET_PASS, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+
+    if (ui_method != NULL)
+        UI_set_method(ui, ui_method);
+    UI_add_user_data(ui, data);
+
+    if ((prompt = UI_construct_prompt(ui, &quot;pass phrase&quot;,
+                                      prompt_info)) == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_FILE_GET_PASS, ERR_R_MALLOC_FAILURE);
+        pass = NULL;
+    } else if (!UI_add_input_string(ui, prompt, UI_INPUT_FLAG_DEFAULT_PWD,
+                                    pass, 0, maxsize - 1)) {
+        OSSL_STOREerr(OSSL_STORE_F_FILE_GET_PASS, ERR_R_UI_LIB);
+        pass = NULL;
+    } else {
+        switch (UI_process(ui)) {
+        case -2:
+            OSSL_STOREerr(OSSL_STORE_F_FILE_GET_PASS,
+                          OSSL_STORE_R_UI_PROCESS_INTERRUPTED_OR_CANCELLED);
+            pass = NULL;
+            break;
+        case -1:
+            OSSL_STOREerr(OSSL_STORE_F_FILE_GET_PASS, ERR_R_UI_LIB);
+            pass = NULL;
+            break;
+        default:
+            break;
+        }
+    }
+
+    OPENSSL_free(prompt);
+    UI_free(ui);
+    return pass;
+}
+
+struct pem_pass_data {
+    const UI_METHOD *ui_method;
+    void *data;
+    const char *prompt_info;
+};
+static int file_fill_pem_pass_data(struct pem_pass_data *pass_data,
+                                   const char *prompt_info,
+                                   const UI_METHOD *ui_method, void *ui_data)
+{
+    if (pass_data == NULL)
+        return 0;
+    pass_data-&gt;ui_method = ui_method;
+    pass_data-&gt;data = ui_data;
+    pass_data-&gt;prompt_info = prompt_info;
+    return 1;
+}
+static int file_get_pem_pass(char *buf, int num, int w, void *data)
+{
+    struct pem_pass_data *pass_data = data;
+    char *pass = file_get_pass(pass_data-&gt;ui_method, buf, num,
+                               pass_data-&gt;prompt_info, pass_data-&gt;data);
+
+    return pass == NULL ? 0 : strlen(pass);
+}
+
+/*
+ *  The file scheme handlers
+ */
+
+/*-
+ * The try_decode function is called to check if the blob of data can
+ * be used by this handler, and if it can, decodes it into a supported
+ * OpenSSL type and returns a OSSL_STORE_INFO with the decoded data.
+ * Input:
+ *    pem_name:     If this blob comes from a PEM file, this holds
+ *                  the PEM name.  If it comes from another type of
+ *                  file, this is NULL.
+ *    pem_header:   If this blob comes from a PEM file, this holds
+ *                  the PEM headers.  If it comes from another type of
+ *                  file, this is NULL.
+ *    blob:         The blob of data to match with what this handler
+ *                  can use.
+ *    len:          The length of the blob.
+ *    handler_ctx:  For a handler marked repeatable, this pointer can
+ *                  be used to create a context for the handler.  IT IS
+ *                  THE HANDLER'S RESPONSIBILITY TO CREATE AND DESTROY
+ *                  THIS CONTEXT APPROPRIATELY, i.e. create on first call
+ *                  and destroy when about to return NULL.
+ *    matchcount:   A pointer to an int to count matches for this data.
+ *                  Usually becomes 0 (no match) or 1 (match!), but may
+ *                  be higher in the (unlikely) event that the data matches
+ *                  more than one possibility.  The int will always be
+ *                  zero when the function is called.
+ *    ui_method:    Application UI method for getting a password, pin
+ *                  or any other interactive data.
+ *    ui_data:      Application data to be passed to ui_method when
+ *                  it's called.
+ * Output:
+ *    a OSSL_STORE_INFO
+ */
+typedef OSSL_STORE_INFO *(*file_try_decode_fn)(const char *pem_name,
+                                               const char *pem_header,
+                                               const unsigned char *blob,
+                                               size_t len, void **handler_ctx,
+                                               int *matchcount,
+                                               const UI_METHOD *ui_method,
+                                               void *ui_data);
+/*
+ * The eof function should return 1 if there's no more data to be found
+ * with the handler_ctx, otherwise 0.  This is only used when the handler is
+ * marked repeatable.
+ */
+typedef int (*file_eof_fn)(void *handler_ctx);
+/*
+ * The destroy_ctx function is used to destroy the handler_ctx that was
+ * intiated by a repeatable try_decode fuction.  This is only used when
+ * the handler is marked repeatable.
+ */
+typedef void (*file_destroy_ctx_fn)(void **handler_ctx);
+
+typedef struct file_handler_st {
+    const char *name;
+    file_try_decode_fn try_decode;
+    file_eof_fn eof;
+    file_destroy_ctx_fn destroy_ctx;
+
+    /* flags */
+    int repeatable;
+} FILE_HANDLER;
+
+static OSSL_STORE_INFO *try_decode_PKCS12(const char *pem_name,
+                                          const char *pem_header,
+                                          const unsigned char *blob,
+                                          size_t len, void **pctx,
+                                          int *matchcount,
+                                          const UI_METHOD *ui_method,
+                                          void *ui_data)
+{
+    OSSL_STORE_INFO *store_info = NULL;
+    STACK_OF(OSSL_STORE_INFO) *ctx = *pctx;
+
+    if (ctx == NULL) {
+        /* Initial parsing */
+        PKCS12 *p12;
+        int ok = 0;
+
+        if (pem_name != NULL)
+            /* No match, there is no PEM PKCS12 tag */
+            return NULL;
+
+        if ((p12 = d2i_PKCS12(NULL, &amp;blob, len)) != NULL) {
+            char *pass = NULL;
+            char tpass[PEM_BUFSIZE];
+            EVP_PKEY *pkey = NULL;
+            X509 *cert = NULL;
+            STACK_OF(X509) *chain = NULL;
+
+            *matchcount = 1;
+
+            if (PKCS12_verify_mac(p12, &quot;&quot;, 0)
+                || PKCS12_verify_mac(p12, NULL, 0)) {
+                pass = &quot;&quot;;
+            } else {
+                if ((pass = file_get_pass(ui_method, tpass, PEM_BUFSIZE,
+                                          &quot;PKCS12 import password&quot;,
+                                          ui_data)) == NULL) {
+                    OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PKCS12,
+                                  OSSL_STORE_R_PASSPHRASE_CALLBACK_ERROR);
+                    goto p12_end;
+                }
+                if (!PKCS12_verify_mac(p12, pass, strlen(pass))) {
+                    OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PKCS12,
+                                  OSSL_STORE_R_ERROR_VERIFYING_PKCS12_MAC);
+                    goto p12_end;
+                }
+            }
+
+            if (PKCS12_parse(p12, pass, &amp;pkey, &amp;cert, &amp;chain)) {
+                OSSL_STORE_INFO *si_pkey = NULL;
+                OSSL_STORE_INFO *si_cert = NULL;
+                OSSL_STORE_INFO *si_ca = NULL;
+
+                if ((ctx = sk_OSSL_STORE_INFO_new_null()) != NULL
+                    &amp;&amp; (si_pkey = OSSL_STORE_INFO_new_PKEY(pkey)) != NULL
+                    &amp;&amp; sk_OSSL_STORE_INFO_push(ctx, si_pkey) != 0
+                    &amp;&amp; (si_cert = OSSL_STORE_INFO_new_CERT(cert)) != NULL
+                    &amp;&amp; sk_OSSL_STORE_INFO_push(ctx, si_cert) != 0) {
+                    ok = 1;
+                    si_pkey = NULL;
+                    si_cert = NULL;
+
+                    while(sk_X509_num(chain) &gt; 0) {
+                        X509 *ca = sk_X509_value(chain, 0);
+
+                        if ((si_ca = OSSL_STORE_INFO_new_CERT(ca)) == NULL
+                            || sk_OSSL_STORE_INFO_push(ctx, si_ca) == 0) {
+                            ok = 0;
+                            break;
+                        }
+                        si_ca = NULL;
+                        (void)sk_X509_shift(chain);
+                    }
+                }
+                if (!ok) {
+                    OSSL_STORE_INFO_free(si_ca);
+                    OSSL_STORE_INFO_free(si_cert);
+                    OSSL_STORE_INFO_free(si_pkey);
+                    sk_OSSL_STORE_INFO_pop_free(ctx, OSSL_STORE_INFO_free);
+                    EVP_PKEY_free(pkey);
+                    X509_free(cert);
+                    sk_X509_pop_free(chain, X509_free);
+                    ctx = NULL;
+                }
+                *pctx = ctx;
+            }
+        }
+     p12_end:
+        PKCS12_free(p12);
+        if (!ok)
+            return NULL;
+    }
+
+    if (ctx != NULL) {
+        *matchcount = 1;
+        store_info = sk_OSSL_STORE_INFO_shift(ctx);
+    }
+
+    return store_info;
+}
+static int eof_PKCS12(void *ctx_)
+{
+    STACK_OF(OSSL_STORE_INFO) *ctx = ctx_;
+
+    return ctx == NULL || sk_OSSL_STORE_INFO_num(ctx) == 0;
+}
+static void destroy_ctx_PKCS12(void **pctx)
+{
+    STACK_OF(OSSL_STORE_INFO) *ctx = *pctx;
+
+    sk_OSSL_STORE_INFO_pop_free(ctx, OSSL_STORE_INFO_free);
+    *pctx = NULL;
+}
+static FILE_HANDLER PKCS12_handler = {
+    &quot;PKCS12&quot;,
+    try_decode_PKCS12,
+    eof_PKCS12,
+    destroy_ctx_PKCS12,
+    1                            /* repeatable */
+};
+
+static OSSL_STORE_INFO *try_decode_PKCS8Encrypted(const char *pem_name,
+                                                  const char *pem_header,
+                                                  const unsigned char *blob,
+                                                  size_t len, void **pctx,
+                                                  int *matchcount,
+                                                  const UI_METHOD *ui_method,
+                                                  void *ui_data)
+{
+    X509_SIG *p8 = NULL;
+    char kbuf[PEM_BUFSIZE];
+    char *pass = NULL;
+    const X509_ALGOR *dalg = NULL;
+    const ASN1_OCTET_STRING *doct = NULL;
+    OSSL_STORE_INFO *store_info = NULL;
+    BUF_MEM *mem = NULL;
+    unsigned char *new_data = NULL;
+    int new_data_len;
+
+    if (pem_name != NULL) {
+        if (strcmp(pem_name, PEM_STRING_PKCS8) != 0)
+            return NULL;
+        *matchcount = 1;
+    }
+
+    if ((p8 = d2i_X509_SIG(NULL, &amp;blob, len)) == NULL)
+        return NULL;
+
+    *matchcount = 1;
+
+    if ((mem = BUF_MEM_new()) == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED,
+                      ERR_R_MALLOC_FAILURE);
+        goto nop8;
+    }
+
+    if ((pass = file_get_pass(ui_method, kbuf, PEM_BUFSIZE,
+                              &quot;PKCS8 decrypt password&quot;, ui_data)) == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED,
+                      OSSL_STORE_R_BAD_PASSWORD_READ);
+        goto nop8;
+    }
+
+    X509_SIG_get0(p8, &amp;dalg, &amp;doct);
+    if (!PKCS12_pbe_crypt(dalg, pass, strlen(pass), doct-&gt;data, doct-&gt;length,
+                          &amp;new_data, &amp;new_data_len, 0))
+        goto nop8;
+
+    mem-&gt;data = (char *)new_data;
+    mem-&gt;max = mem-&gt;length = (size_t)new_data_len;
+    X509_SIG_free(p8);
+
+    store_info = ossl_store_info_new_EMBEDDED(PEM_STRING_PKCS8INF, mem);
+    if (store_info == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED,
+                      ERR_R_MALLOC_FAILURE);
+        goto nop8;
+    }
+
+    return store_info;
+ nop8:
+    X509_SIG_free(p8);
+    BUF_MEM_free(mem);
+    return NULL;
+}
+static FILE_HANDLER PKCS8Encrypted_handler = {
+    &quot;PKCS8Encrypted&quot;,
+    try_decode_PKCS8Encrypted
+};
+
+int pem_check_suffix(const char *pem_str, const char *suffix);
+static OSSL_STORE_INFO *try_decode_PrivateKey(const char *pem_name,
+                                              const char *pem_header,
+                                              const unsigned char *blob,
+                                              size_t len, void **pctx,
+                                              int *matchcount,
+                                              const UI_METHOD *ui_method,
+                                              void *ui_data)
+{
+    OSSL_STORE_INFO *store_info = NULL;
+    EVP_PKEY *pkey = NULL;
+    const EVP_PKEY_ASN1_METHOD *ameth = NULL;
+
+    if (pem_name != NULL) {
+        if (strcmp(pem_name, PEM_STRING_PKCS8INF) == 0) {
+            PKCS8_PRIV_KEY_INFO *p8inf =
+                d2i_PKCS8_PRIV_KEY_INFO(NULL, &amp;blob, len);
+
+            *matchcount = 1;
+            if (p8inf != NULL)
+                pkey = EVP_PKCS82PKEY(p8inf);
+            PKCS8_PRIV_KEY_INFO_free(p8inf);
+        } else {
+            int slen;
+
+            if ((slen = pem_check_suffix(pem_name, &quot;PRIVATE KEY&quot;)) &gt; 0
+                &amp;&amp; (ameth = EVP_PKEY_asn1_find_str(NULL, pem_name,
+                                                   slen)) != NULL) {
+                *matchcount = 1;
+                pkey = d2i_PrivateKey(ameth-&gt;pkey_id, NULL, &amp;blob, len);
+            }
+        }
+    } else {
+        int i;
+
+        for (i = 0; i &lt; EVP_PKEY_asn1_get_count(); i++) {
+            EVP_PKEY *tmp_pkey = NULL;
+            const unsigned char *tmp_blob = blob;
+
+            ameth = EVP_PKEY_asn1_get0(i);
+            if (ameth-&gt;pkey_flags &amp; ASN1_PKEY_ALIAS)
+                continue;
+
+            tmp_pkey = d2i_PrivateKey(ameth-&gt;pkey_id, NULL, &amp;tmp_blob, len);
+            if (tmp_pkey != NULL) {
+                if (pkey != NULL)
+                    EVP_PKEY_free(tmp_pkey);
+                else
+                    pkey = tmp_pkey;
+                (*matchcount)++;
+            }
+        }
+
+        if (*matchcount &gt; 1) {
+            EVP_PKEY_free(pkey);
+            pkey = NULL;
+        }
+    }
+    if (pkey == NULL)
+        /* No match */
+        return NULL;
+
+    store_info = OSSL_STORE_INFO_new_PKEY(pkey);
+    if (store_info == NULL)
+        EVP_PKEY_free(pkey);
+
+    return store_info;
+}
+static FILE_HANDLER PrivateKey_handler = {
+    &quot;PrivateKey&quot;,
+    try_decode_PrivateKey
+};
+
+static OSSL_STORE_INFO *try_decode_PUBKEY(const char *pem_name,
+                                          const char *pem_header,
+                                          const unsigned char *blob,
+                                          size_t len, void **pctx,
+                                          int *matchcount,
+                                          const UI_METHOD *ui_method,
+                                          void *ui_data)
+{
+    OSSL_STORE_INFO *store_info = NULL;
+    EVP_PKEY *pkey = NULL;
+
+    if (pem_name != NULL) {
+        if (strcmp(pem_name, PEM_STRING_PUBLIC) != 0)
+            /* No match */
+            return NULL;
+        *matchcount = 1;
+    }
+
+    if ((pkey = d2i_PUBKEY(NULL, &amp;blob, len)) != NULL) {
+        *matchcount = 1;
+        store_info = OSSL_STORE_INFO_new_PKEY(pkey);
+    }
+
+    return store_info;
+}
+static FILE_HANDLER PUBKEY_handler = {
+    &quot;PUBKEY&quot;,
+    try_decode_PUBKEY
+};
+
+static OSSL_STORE_INFO *try_decode_params(const char *pem_name,
+                                          const char *pem_header,
+                                          const unsigned char *blob,
+                                          size_t len, void **pctx,
+                                          int *matchcount,
+                                          const UI_METHOD *ui_method,
+                                          void *ui_data)
+{
+    OSSL_STORE_INFO *store_info = NULL;
+    int slen = 0;
+    EVP_PKEY *pkey = NULL;
+    const EVP_PKEY_ASN1_METHOD *ameth = NULL;
+    int ok = 0;
+
+    if (pem_name != NULL) {
+        if ((slen = pem_check_suffix(pem_name, &quot;PARAMETERS&quot;)) == 0)
+            return NULL;
+        *matchcount = 1;
+    }
+
+    if ((pkey = EVP_PKEY_new()) == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_TRY_DECODE_PARAMS, ERR_R_EVP_LIB);
+        return NULL;
+    }
+
+    if (slen &gt; 0) {
+        if (EVP_PKEY_set_type_str(pkey, pem_name, slen)
+            &amp;&amp; (ameth = EVP_PKEY_get0_asn1(pkey)) != NULL
+            &amp;&amp; ameth-&gt;param_decode != NULL
+            &amp;&amp; ameth-&gt;param_decode(pkey, &amp;blob, len))
+            ok = 1;
+    } else {
+        int i;
+
+        for (i = 0; i &lt; EVP_PKEY_asn1_get_count(); i++) {
+            const unsigned char *tmp_blob = blob;
+
+            ameth = EVP_PKEY_asn1_get0(i);
+            if (ameth-&gt;pkey_flags &amp; ASN1_PKEY_ALIAS)
+                continue;
+            if (EVP_PKEY_set_type(pkey, ameth-&gt;pkey_id)
+                &amp;&amp; (ameth = EVP_PKEY_get0_asn1(pkey)) != NULL
+                &amp;&amp; ameth-&gt;param_decode != NULL
+                &amp;&amp; ameth-&gt;param_decode(pkey, &amp;tmp_blob, len)) {
+                (*matchcount)++;
+                ok = 1;
+                break;
+            }
+        }
+    }
+
+    if (ok)
+        store_info = OSSL_STORE_INFO_new_PARAMS(pkey);
+    if (store_info == NULL)
+        EVP_PKEY_free(pkey);
+
+    return store_info;
+}
+static FILE_HANDLER params_handler = {
+    &quot;params&quot;,
+    try_decode_params
+};
+
+static OSSL_STORE_INFO *try_decode_X509Certificate(const char *pem_name,
+                                                   const char *pem_header,
+                                                   const unsigned char *blob,
+                                                   size_t len, void **pctx,
+                                                   int *matchcount,
+                                                   const UI_METHOD *ui_method,
+                                                   void *ui_data)
+{
+    OSSL_STORE_INFO *store_info = NULL;
+    X509 *cert = NULL;
+
+    /*
+     * In most cases, we can try to interpret the serialized data as a trusted
+     * cert (X509 + X509_AUX) and fall back to reading it as a normal cert
+     * (just X509), but if the PEM name specifically declares it as a trusted
+     * cert, then no fallback should be engaged.  |ignore_trusted| tells if
+     * the fallback can be used (1) or not (0).
+     */
+    int ignore_trusted = 1;
+
+    if (pem_name != NULL) {
+        if (strcmp(pem_name, PEM_STRING_X509_TRUSTED) == 0)
+            ignore_trusted = 0;
+        else if (strcmp(pem_name, PEM_STRING_X509_OLD) != 0
+                 &amp;&amp; strcmp(pem_name, PEM_STRING_X509) != 0)
+            /* No match */
+            return NULL;
+        *matchcount = 1;
+    }
+
+    if ((cert = d2i_X509_AUX(NULL, &amp;blob, len)) != NULL
+        || (ignore_trusted &amp;&amp; (cert = d2i_X509(NULL, &amp;blob, len)) != NULL)) {
+        *matchcount = 1;
+        store_info = OSSL_STORE_INFO_new_CERT(cert);
+    }
+
+    if (store_info == NULL)
+        X509_free(cert);
+
+    return store_info;
+}
+static FILE_HANDLER X509Certificate_handler = {
+    &quot;X509Certificate&quot;,
+    try_decode_X509Certificate
+};
+
+static OSSL_STORE_INFO *try_decode_X509CRL(const char *pem_name,
+                                           const char *pem_header,
+                                           const unsigned char *blob,
+                                           size_t len, void **pctx,
+                                           int *matchcount,
+                                           const UI_METHOD *ui_method,
+                                           void *ui_data)
+{
+    OSSL_STORE_INFO *store_info = NULL;
+    X509_CRL *crl = NULL;
+
+    if (pem_name != NULL) {
+        if (strcmp(pem_name, PEM_STRING_X509_CRL) != 0)
+            /* No match */
+            return NULL;
+        *matchcount = 1;
+    }
+
+    if ((crl = d2i_X509_CRL(NULL, &amp;blob, len)) != NULL) {
+        *matchcount = 1;
+        store_info = OSSL_STORE_INFO_new_CRL(crl);
+    }
+
+    if (store_info == NULL)
+        X509_CRL_free(crl);
+
+    return store_info;
+}
+static FILE_HANDLER X509CRL_handler = {
+    &quot;X509CRL&quot;,
+    try_decode_X509CRL
+};
+
+static const FILE_HANDLER *file_handlers[] = {
+    &amp;PKCS12_handler,
+    &amp;PKCS8Encrypted_handler,
+    &amp;X509Certificate_handler,
+    &amp;X509CRL_handler,
+    &amp;params_handler,
+    &amp;PUBKEY_handler,
+    &amp;PrivateKey_handler,
+};
+
+
+/*
+ *  The loader itself
+ */
+
+struct ossl_store_loader_ctx_st {
+    enum {
+        is_raw = 0,
+        is_pem,
+        is_dir
+    } type;
+    int errcnt;
+    union {
+        struct {                 /* Used with is_raw and is_pem */
+            BIO *file;
+
+            /*
+             * The following are used when the handler is marked as
+             * repeatable
+             */
+            const FILE_HANDLER *last_handler;
+            void *last_handler_ctx;
+        } file;
+        struct {                 /* Used with is_dir */
+            OPENSSL_DIR_CTX *ctx;
+            int end_reached;
+            char *uri;
+
+            /*
+             * The directory reading utility we have combines opening with
+             * reading the first name.  To make sure we can detect the end
+             * at the right time, we read early and cache the name.
+             */
+            const char *last_entry;
+            int last_errno;
+        } dir;
+    } _;
+};
+
+static void OSSL_STORE_LOADER_CTX_free(OSSL_STORE_LOADER_CTX *ctx)
+{
+    if (ctx-&gt;type == is_dir) {
+        OPENSSL_free(ctx-&gt;_.dir.uri);
+    } else {
+        if (ctx-&gt;_.file.last_handler != NULL) {
+            ctx-&gt;_.file.last_handler-&gt;destroy_ctx(&amp;ctx-&gt;_.file.last_handler_ctx);
+            ctx-&gt;_.file.last_handler_ctx = NULL;
+            ctx-&gt;_.file.last_handler = NULL;
+        }
+    }
+    OPENSSL_free(ctx);
+}
+
+static OSSL_STORE_LOADER_CTX *file_open(const OSSL_STORE_LOADER *loader,
+                                        const char *uri,
+                                        const UI_METHOD *ui_method,
+                                        void *ui_data)
+{
+    OSSL_STORE_LOADER_CTX *ctx = NULL;
+    struct stat st;
+    const char *path = NULL;
+
+    if (strncasecmp(uri, &quot;file:&quot;, 5) == 0) {
+        if (strncmp(&amp;uri[5], &quot;//localhost/&quot;, 12) == 0) {
+            path = &amp;uri[16];
+        } else if (strncmp(&amp;uri[5], &quot;///&quot;, 3) == 0) {
+            path = &amp;uri[7];
+        } else if (strncmp(&amp;uri[5], &quot;//&quot;, 2) != 0) {
+            path = &amp;uri[5];
+        } else {
+            OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN,
+                          OSSL_STORE_R_URI_AUTHORITY_UNSUPPORED);
+            return NULL;
+        }
+
+        /*
+         * If the scheme &quot;file&quot; was an explicit part of the URI, the path must
+         * be absolute.  So says RFC 8089
+         */
+        if (path[0] != '/') {
+            OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN,
+                          OSSL_STORE_R_PATH_MUST_BE_ABSOLUTE);
+            return NULL;
+        }
+
+#ifdef _WIN32
+        /* Windows file: URIs with a drive letter start with a / */
+        if (path[0] == '/' &amp;&amp; path[2] == ':' &amp;&amp; path[3] == '/')
+            path++;
+#endif
+    } else {
+        path = uri;
+    }
+
+
+    if (stat(path, &amp;st) &lt; 0) {
+        SYSerr(SYS_F_STAT, errno);
+        ERR_add_error_data(1, path);
+        return NULL;
+    }
+
+    ctx = OPENSSL_zalloc(sizeof(*ctx));
+    if (ctx == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+
+    if ((st.st_mode &amp; S_IFDIR) == S_IFDIR) {
+        /*
+         * Try to copy everything, even if we know that some of them must be
+         * NULL for the moment.  This prevents errors in the future, when more
+         * components may be used.
+         */
+        ctx-&gt;_.dir.uri = OPENSSL_strdup(uri);
+        ctx-&gt;type = is_dir;
+
+        if (ctx-&gt;_.dir.uri == NULL)
+            goto err;
+
+        ctx-&gt;_.dir.last_entry = OPENSSL_DIR_read(&amp;ctx-&gt;_.dir.ctx, path);
+        ctx-&gt;_.dir.last_errno = errno;
+        if (ctx-&gt;_.dir.last_entry == NULL) {
+            if (ctx-&gt;_.dir.last_errno != 0) {
+                char errbuf[256];
+                errno = ctx-&gt;_.dir.last_errno;
+                openssl_strerror_r(errno, errbuf, sizeof(errbuf));
+                OSSL_STOREerr(OSSL_STORE_F_FILE_OPEN, ERR_R_SYS_LIB);
+                ERR_add_error_data(1, errbuf);
+                goto err;
+            }
+            ctx-&gt;_.dir.end_reached = 1;
+        }
+    } else {
+        BIO *buff = NULL;
+        char peekbuf[4096];
+
+        if ((buff = BIO_new(BIO_f_buffer())) == NULL
+            || (ctx-&gt;_.file.file = BIO_new_file(path, &quot;rb&quot;)) == NULL) {
+            BIO_free_all(buff);
+            goto err;
+        }
+
+        ctx-&gt;_.file.file = BIO_push(buff, ctx-&gt;_.file.file);
+        if (BIO_buffer_peek(ctx-&gt;_.file.file, peekbuf, sizeof(peekbuf)-1) &gt; 0) {
+            peekbuf[sizeof(peekbuf)-1] = '\0';
+            if (strstr(peekbuf, &quot;-----BEGIN &quot;) != NULL)
+                ctx-&gt;type = is_pem;
+        }
+    }
+
+    return ctx;
+ err:
+    OSSL_STORE_LOADER_CTX_free(ctx);
+    return NULL;
+}
+
+static OSSL_STORE_INFO *file_load_try_decode(OSSL_STORE_LOADER_CTX *ctx,
+                                             const char *pem_name,
+                                             const char *pem_header,
+                                             unsigned char *data, size_t len,
+                                             const UI_METHOD *ui_method,
+                                             void *ui_data, int *matchcount)
+{
+    OSSL_STORE_INFO *result = NULL;
+    BUF_MEM *new_mem = NULL;
+    char *new_pem_name = NULL;
+    int t = 0;
+
+ again:
+    {
+        size_t i = 0;
+        void *handler_ctx = NULL;
+        const FILE_HANDLER **matching_handlers =
+            OPENSSL_zalloc(sizeof(*matching_handlers)
+                           * OSSL_NELEM(file_handlers));
+
+        if (matching_handlers == NULL) {
+            OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD_TRY_DECODE,
+                          ERR_R_MALLOC_FAILURE);
+            goto err;
+        }
+
+        *matchcount = 0;
+        for (i = 0; i &lt; OSSL_NELEM(file_handlers); i++) {
+            const FILE_HANDLER *handler = file_handlers[i];
+            int try_matchcount = 0;
+            void *tmp_handler_ctx = NULL;
+            OSSL_STORE_INFO *tmp_result =
+                handler-&gt;try_decode(pem_name, pem_header, data, len,
+                                    &amp;tmp_handler_ctx, &amp;try_matchcount,
+                                    ui_method, ui_data);
+
+            if (try_matchcount &gt; 0) {
+                if (matching_handlers)
+                    matching_handlers[*matchcount] = handler;
+
+                if (handler_ctx)
+                    handler-&gt;destroy_ctx(&amp;handler_ctx);
+                handler_ctx = tmp_handler_ctx;
+
+                if ((*matchcount += try_matchcount) &gt; 1) {
+                    /* more than one match =&gt; ambiguous, kill any result */
+                    OSSL_STORE_INFO_free(result);
+                    OSSL_STORE_INFO_free(tmp_result);
+                    if (handler-&gt;destroy_ctx != NULL)
+                        handler-&gt;destroy_ctx(&amp;handler_ctx);
+                    handler_ctx = NULL;
+                    tmp_result = NULL;
+                    result = NULL;
+                }
+                if (result == NULL)
+                    result = tmp_result;
+            }
+        }
+
+        if (*matchcount == 1 &amp;&amp; matching_handlers[0]-&gt;repeatable) {
+            ctx-&gt;_.file.last_handler = matching_handlers[0];
+            ctx-&gt;_.file.last_handler_ctx = handler_ctx;
+        }
+
+        OPENSSL_free(matching_handlers);
+    }
+
+ err:
+    OPENSSL_free(new_pem_name);
+    BUF_MEM_free(new_mem);
+
+    if (result != NULL
+        &amp;&amp; (t = OSSL_STORE_INFO_get_type(result)) == OSSL_STORE_INFO_EMBEDDED) {
+        pem_name = new_pem_name =
+            ossl_store_info_get0_EMBEDDED_pem_name(result);
+        new_mem = ossl_store_info_get0_EMBEDDED_buffer(result);
+        data = (unsigned char *)new_mem-&gt;data;
+        len = new_mem-&gt;length;
+        OPENSSL_free(result);
+        result = NULL;
+        goto again;
+    }
+
+    if (result != NULL)
+        ERR_clear_error();
+
+    return result;
+}
+
+static OSSL_STORE_INFO *file_load_try_repeat(OSSL_STORE_LOADER_CTX *ctx,
+                                             const UI_METHOD *ui_method,
+                                             void *ui_data)
+{
+    OSSL_STORE_INFO *result = NULL;
+    int try_matchcount = 0;
+
+    if (ctx-&gt;_.file.last_handler != NULL) {
+        result =
+            ctx-&gt;_.file.last_handler-&gt;try_decode(NULL, NULL, NULL, 0,
+                                                 &amp;ctx-&gt;_.file.last_handler_ctx,
+                                                 &amp;try_matchcount,
+                                                 ui_method, ui_data);
+
+        if (result == NULL) {
+            ctx-&gt;_.file.last_handler-&gt;destroy_ctx(&amp;ctx-&gt;_.file.last_handler_ctx);
+            ctx-&gt;_.file.last_handler_ctx = NULL;
+            ctx-&gt;_.file.last_handler = NULL;
+        }
+    }
+    return result;
+}
+
+static int file_read_pem(BIO *bp, char **pem_name, char **pem_header,
+                         unsigned char **data, long *len,
+                         const UI_METHOD *ui_method,
+                         void *ui_data)
+{
+    int i = PEM_read_bio(bp, pem_name, pem_header, data, len);
+
+    if (i &lt;= 0)
+        return 0;
+
+    /*
+     * 10 is the number of characters in &quot;Proc-Type:&quot;, which
+     * PEM_get_EVP_CIPHER_INFO() requires to be present.
+     * If the PEM header has less characters than that, it's
+     * not worth spending cycles on it.
+     */
+    if (strlen(*pem_header) &gt; 10) {
+        EVP_CIPHER_INFO cipher;
+        struct pem_pass_data pass_data;
+
+        if (!PEM_get_EVP_CIPHER_INFO(*pem_header, &amp;cipher)
+            || !file_fill_pem_pass_data(&amp;pass_data, &quot;PEM&quot;, ui_method, ui_data)
+            || !PEM_do_header(&amp;cipher, *data, len, file_get_pem_pass,
+                              &amp;pass_data)) {
+            return 0;
+        }
+    }
+    return 1;
+}
+
+static int file_read_asn1(BIO *bp, unsigned char **data, long *len)
+{
+    BUF_MEM *mem = NULL;
+
+    if (asn1_d2i_read_bio(bp, &amp;mem) &lt; 0)
+        return 0;
+
+    *data = (unsigned char *)mem-&gt;data;
+    *len = (long)mem-&gt;length;
+    OPENSSL_free(mem);
+
+    return 1;
+}
+
+static int ends_with_dirsep(const char *uri)
+{
+    if (*uri != '\0')
+        uri += strlen(uri) - 1;
+#if defined __VMS
+    if (*uri == ']' || *uri == '&gt;' || *uri == ':')
+        return 1;
+#elif defined _WIN32
+    if (*uri == '\\')
+        return 1;
+#endif
+    return *uri == '/';
+}
+
+static int file_name_to_uri(OSSL_STORE_LOADER_CTX *ctx, const char *name,
+                            char **data)
+{
+    assert(name != NULL);
+    assert(data != NULL);
+    {
+        const char *pathsep = ends_with_dirsep(ctx-&gt;_.dir.uri) ? &quot;&quot; : &quot;/&quot;;
+        long calculated_length = strlen(ctx-&gt;_.dir.uri) + strlen(pathsep)
+            + strlen(name) + 1 /* \0 */;
+
+        *data = OPENSSL_zalloc(calculated_length);
+        if (*data == NULL) {
+            OSSL_STOREerr(OSSL_STORE_F_FILE_NAME_TO_URI, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+
+        OPENSSL_strlcat(*data, ctx-&gt;_.dir.uri, calculated_length);
+        OPENSSL_strlcat(*data, pathsep, calculated_length);
+        OPENSSL_strlcat(*data, name, calculated_length);
+    }
+    return 1;
+}
+
+static int file_eof(OSSL_STORE_LOADER_CTX *ctx);
+static int file_error(OSSL_STORE_LOADER_CTX *ctx);
+static OSSL_STORE_INFO *file_load(OSSL_STORE_LOADER_CTX *ctx,
+                                  const UI_METHOD *ui_method, void *ui_data)
+{
+    OSSL_STORE_INFO *result = NULL;
+
+    ctx-&gt;errcnt = 0;
+    ERR_clear_error();
+
+    if (ctx-&gt;type == is_dir) {
+        do {
+            char *newname = NULL;
+
+            if (ctx-&gt;_.dir.last_entry == NULL) {
+                if (!ctx-&gt;_.dir.end_reached) {
+                    char errbuf[256];
+                    assert(ctx-&gt;_.dir.last_errno != 0);
+                    errno = ctx-&gt;_.dir.last_errno;
+                    ctx-&gt;errcnt++;
+                    openssl_strerror_r(errno, errbuf, sizeof(errbuf));
+                    OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD, ERR_R_SYS_LIB);
+                    ERR_add_error_data(1, errbuf);
+                }
+                return NULL;
+            }
+
+            if (ctx-&gt;_.dir.last_entry[0] != '.'
+                &amp;&amp; !file_name_to_uri(ctx, ctx-&gt;_.dir.last_entry, &amp;newname))
+                return NULL;
+
+            /*
+             * On the first call (with a NULL context), OPENSSL_DIR_read()
+             * cares about the second argument.  On the following calls, it
+             * only cares that it isn't NULL.  Therefore, we can safely give
+             * it our URI here.
+             */
+            ctx-&gt;_.dir.last_entry = OPENSSL_DIR_read(&amp;ctx-&gt;_.dir.ctx,
+                                                     ctx-&gt;_.dir.uri);
+            ctx-&gt;_.dir.last_errno = errno;
+            if (ctx-&gt;_.dir.last_entry == NULL &amp;&amp; ctx-&gt;_.dir.last_errno == 0)
+                ctx-&gt;_.dir.end_reached = 1;
+
+            if (newname != NULL
+                &amp;&amp; (result = OSSL_STORE_INFO_new_NAME(newname)) == NULL) {
+                OPENSSL_free(newname);
+                OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD, ERR_R_OSSL_STORE_LIB);
+                return NULL;
+            }
+        } while (result == NULL &amp;&amp; !file_eof(ctx));
+    } else {
+        int matchcount = -1;
+
+        result = file_load_try_repeat(ctx, ui_method, ui_data);
+        if (result != NULL)
+            return result;
+
+        if (file_eof(ctx))
+            return NULL;
+
+        do {
+            char *pem_name = NULL;      /* PEM record name */
+            char *pem_header = NULL;    /* PEM record header */
+            unsigned char *data = NULL; /* DER encoded data */
+            long len = 0;               /* DER encoded data length */
+
+            matchcount = -1;
+            if (ctx-&gt;type == is_pem) {
+                if (!file_read_pem(ctx-&gt;_.file.file, &amp;pem_name, &amp;pem_header,
+                                   &amp;data, &amp;len, ui_method, ui_data)) {
+                    ctx-&gt;errcnt++;
+                    goto endloop;
+                }
+            } else {
+                if (!file_read_asn1(ctx-&gt;_.file.file, &amp;data, &amp;len)) {
+                    ctx-&gt;errcnt++;
+                    goto endloop;
+                }
+            }
+
+            result = file_load_try_decode(ctx, pem_name, pem_header, data, len,
+                                          ui_method, ui_data, &amp;matchcount);
+
+            if (result != NULL)
+                goto endloop;
+
+            /*
+             * If a PEM name matches more than one handler, the handlers are
+             * badly coded.
+             */
+            if (!ossl_assert(pem_name == NULL || matchcount &lt;= 1)) {
+                ctx-&gt;errcnt++;
+                goto endloop;
+            }
+
+            if (matchcount &gt; 1) {
+                OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD,
+                              OSSL_STORE_R_AMBIGUOUS_CONTENT_TYPE);
+            } else if (matchcount == 1) {
+                /*
+                 * If there are other errors on the stack, they already show
+                 * what the problem is.
+                 */
+                if (ERR_peek_error() == 0) {
+                    OSSL_STOREerr(OSSL_STORE_F_FILE_LOAD,
+                                  OSSL_STORE_R_UNSUPPORTED_CONTENT_TYPE);
+                    if (pem_name != NULL)
+                        ERR_add_error_data(3, &quot;PEM type is '&quot;, pem_name, &quot;'&quot;);
+                }
+            }
+            if (matchcount &gt; 0)
+                ctx-&gt;errcnt++;
+
+         endloop:
+            OPENSSL_free(pem_name);
+            OPENSSL_free(pem_header);
+            OPENSSL_free(data);
+        } while (matchcount == 0 &amp;&amp; !file_eof(ctx) &amp;&amp; !file_error(ctx));
+
+        /* We bail out on ambiguity */
+        if (matchcount &gt; 1)
+            return NULL;
+    }
+
+    return result;
+}
+
+static int file_error(OSSL_STORE_LOADER_CTX *ctx)
+{
+    return ctx-&gt;errcnt &gt; 0;
+}
+
+static int file_eof(OSSL_STORE_LOADER_CTX *ctx)
+{
+    if (ctx-&gt;type == is_dir)
+        return ctx-&gt;_.dir.end_reached;
+
+    if (ctx-&gt;_.file.last_handler != NULL
+        &amp;&amp; !ctx-&gt;_.file.last_handler-&gt;eof(ctx-&gt;_.file.last_handler_ctx))
+        return 0;
+    return BIO_eof(ctx-&gt;_.file.file);
+}
+
+static int file_close(OSSL_STORE_LOADER_CTX *ctx)
+{
+    if (ctx-&gt;type == is_dir) {
+        OPENSSL_DIR_end(&amp;ctx-&gt;_.dir.ctx);
+    } else {
+        BIO_free_all(ctx-&gt;_.file.file);
+    }
+    OSSL_STORE_LOADER_CTX_free(ctx);
+    return 1;
+}
+
+static OSSL_STORE_LOADER file_loader =
+    {
+        &quot;file&quot;,
+        NULL,
+        file_open,
+        NULL,
+        file_load,
+        file_eof,
+        file_error,
+        file_close
+    };
+
+static void store_file_loader_deinit(void)
+{
+    ossl_store_unregister_loader_int(file_loader.scheme);
+}
+
+int ossl_store_file_loader_init(void)
+{
+    int ret = ossl_store_register_loader_int(&amp;file_loader);
+
+    OPENSSL_atexit(store_file_loader_deinit);
+    return ret;
+}
diff --git a/crypto/store/store_err.c b/crypto/store/store_err.c
new file mode 100644
index 0000000..681c9ff
--- /dev/null
+++ b/crypto/store/store_err.c
@@ -0,0 +1,116 @@
+/*
+ * Generated by util/mkerr.pl DO NOT EDIT
+ * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/err.h&gt;
+#include &lt;openssl/storeerr.h&gt;
+
+#ifndef OPENSSL_NO_ERR
+
+static const ERR_STRING_DATA OSSL_STORE_str_functs[] = {
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_FILE_GET_PASS, 0),
+     &quot;file_get_pass&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_FILE_LOAD, 0), &quot;file_load&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_FILE_LOAD_TRY_DECODE, 0),
+     &quot;file_load_try_decode&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_FILE_NAME_TO_URI, 0),
+     &quot;file_name_to_uri&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_FILE_OPEN, 0), &quot;file_open&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_GET0_LOADER_INT, 0),
+     &quot;ossl_store_get0_loader_int&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_GET1_CERT, 0),
+     &quot;OSSL_STORE_INFO_get1_CERT&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_GET1_CRL, 0),
+     &quot;OSSL_STORE_INFO_get1_CRL&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME, 0),
+     &quot;OSSL_STORE_INFO_get1_NAME&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME_DESCRIPTION, 0),
+     &quot;OSSL_STORE_INFO_get1_NAME_description&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_GET1_PARAMS, 0),
+     &quot;OSSL_STORE_INFO_get1_PARAMS&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_GET1_PKEY, 0),
+     &quot;OSSL_STORE_INFO_get1_PKEY&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_NEW_CERT, 0),
+     &quot;OSSL_STORE_INFO_new_CERT&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_NEW_CRL, 0),
+     &quot;OSSL_STORE_INFO_new_CRL&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_NEW_EMBEDDED, 0),
+     &quot;ossl_store_info_new_EMBEDDED&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_NEW_NAME, 0),
+     &quot;OSSL_STORE_INFO_new_NAME&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_NEW_PARAMS, 0),
+     &quot;OSSL_STORE_INFO_new_PARAMS&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_NEW_PKEY, 0),
+     &quot;OSSL_STORE_INFO_new_PKEY&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INFO_SET0_NAME_DESCRIPTION, 0),
+     &quot;OSSL_STORE_INFO_set0_NAME_description&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_INIT_ONCE, 0),
+     &quot;ossl_store_init_once&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_LOADER_NEW, 0),
+     &quot;OSSL_STORE_LOADER_new&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_OPEN, 0),
+     &quot;OSSL_STORE_open&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_OPEN_INT, 0), &quot;&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_REGISTER_LOADER_INT, 0),
+     &quot;ossl_store_register_loader_int&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_OSSL_STORE_UNREGISTER_LOADER_INT, 0),
+     &quot;ossl_store_unregister_loader_int&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_TRY_DECODE_PARAMS, 0),
+     &quot;try_decode_params&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_TRY_DECODE_PKCS12, 0),
+     &quot;try_decode_PKCS12&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED, 0),
+     &quot;try_decode_PKCS8Encrypted&quot;},
+    {0, NULL}
+};
+
+static const ERR_STRING_DATA OSSL_STORE_str_reasons[] = {
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_AMBIGUOUS_CONTENT_TYPE),
+    &quot;ambiguous content type&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_BAD_PASSWORD_READ),
+    &quot;bad password read&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_ERROR_VERIFYING_PKCS12_MAC),
+    &quot;error verifying pkcs12 mac&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_INVALID_SCHEME),
+    &quot;invalid scheme&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_IS_NOT_A), &quot;is not a&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_NOT_A_CERTIFICATE),
+    &quot;not a certificate&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_NOT_A_CRL), &quot;not a crl&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_NOT_A_KEY), &quot;not a key&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_NOT_A_NAME), &quot;not a name&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_NOT_PARAMETERS),
+    &quot;not parameters&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_PASSPHRASE_CALLBACK_ERROR),
+    &quot;passphrase callback error&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_PATH_MUST_BE_ABSOLUTE),
+    &quot;path must be absolute&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_UI_PROCESS_INTERRUPTED_OR_CANCELLED),
+    &quot;ui process interrupted or cancelled&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_UNREGISTERED_SCHEME),
+    &quot;unregistered scheme&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_UNSUPPORTED_CONTENT_TYPE),
+    &quot;unsupported content type&quot;},
+    {ERR_PACK(ERR_LIB_OSSL_STORE, 0, OSSL_STORE_R_URI_AUTHORITY_UNSUPPORED),
+    &quot;uri authority unsuppored&quot;},
+    {0, NULL}
+};
+
+#endif
+
+int ERR_load_OSSL_STORE_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+    if (ERR_func_error_string(OSSL_STORE_str_functs[0].error) == NULL) {
+        ERR_load_strings_const(OSSL_STORE_str_functs);
+        ERR_load_strings_const(OSSL_STORE_str_reasons);
+    }
+#endif
+    return 1;
+}
diff --git a/crypto/store/store_init.c b/crypto/store/store_init.c
new file mode 100644
index 0000000..4b53108
--- /dev/null
+++ b/crypto/store/store_init.c
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/err.h&gt;
+#include &quot;internal/store.h&quot;
+#include &quot;store_locl.h&quot;
+
+static CRYPTO_ONCE store_init = CRYPTO_ONCE_STATIC_INIT;
+DEFINE_RUN_ONCE_STATIC(do_store_init)
+{
+    return OPENSSL_init_crypto(0, NULL)
+        &amp;&amp; ossl_store_file_loader_init();
+}
+
+int ossl_store_init_once()
+{
+    if (!RUN_ONCE(&amp;store_init, do_store_init)) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INIT_ONCE, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    return 1;
+}
+
+void ossl_store_cleanup_int(void)
+{
+    ossl_store_destroy_loaders_int();
+}
diff --git a/crypto/store/store_lib.c b/crypto/store/store_lib.c
new file mode 100644
index 0000000..2c8ce86
--- /dev/null
+++ b/crypto/store/store_lib.c
@@ -0,0 +1,409 @@
+/*
+ * Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;openssl/crypto.h&gt;
+#include &lt;openssl/err.h&gt;
+#include &lt;openssl/store.h&gt;
+#include &quot;internal/thread_once.h&quot;
+#include &quot;store_locl.h&quot;
+
+struct ossl_store_ctx_st {
+    const OSSL_STORE_LOADER *loader;
+    OSSL_STORE_LOADER_CTX *loader_ctx;
+    const UI_METHOD *ui_method;
+    void *ui_data;
+    OSSL_STORE_post_process_info_fn post_process;
+    void *post_process_data;
+};
+
+OSSL_STORE_CTX *OSSL_STORE_open(const char *uri, const UI_METHOD *ui_method,
+                                void *ui_data,
+                                OSSL_STORE_post_process_info_fn post_process,
+                                void *post_process_data)
+{
+    const OSSL_STORE_LOADER *loader;
+    OSSL_STORE_LOADER_CTX *loader_ctx = NULL;
+    OSSL_STORE_CTX *ctx = NULL;
+    char scheme_copy[256], *p;
+
+    OPENSSL_strlcpy(scheme_copy, uri, sizeof(scheme_copy));
+    if ((p = strchr(scheme_copy, ':')) != NULL) {
+        *p = '\0';
+        p = scheme_copy;
+    } else {
+        p = &quot;file&quot;;
+    }
+
+    if ((loader = ossl_store_get0_loader_int(p)) == NULL
+        || (loader_ctx = loader-&gt;open(loader, uri, ui_method, ui_data)) == NULL)
+        goto done;
+    if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_OPEN, ERR_R_MALLOC_FAILURE);
+        goto done;
+    }
+
+    ctx-&gt;loader = loader;
+    ctx-&gt;loader_ctx = loader_ctx;
+    loader_ctx = NULL;
+    ctx-&gt;ui_method = ui_method;
+    ctx-&gt;ui_data = ui_data;
+    ctx-&gt;post_process = post_process;
+    ctx-&gt;post_process_data = post_process_data;
+
+ done:
+    if (loader_ctx != NULL) {
+        /*
+         * We ignore a returned error because we will return NULL anyway in
+         * this case, so if something goes wrong when closing, that'll simply
+         * just add another entry on the error stack.
+         */
+        (void)loader-&gt;close(loader_ctx);
+    }
+    return ctx;
+}
+
+int OSSL_STORE_ctrl(OSSL_STORE_CTX *ctx, int cmd, ...)
+{
+    va_list args;
+    int ret = 0;
+
+    va_start(args, cmd);
+    if (ctx-&gt;loader-&gt;ctrl != NULL)
+        ret = ctx-&gt;loader-&gt;ctrl(ctx-&gt;loader_ctx, cmd, args);
+    va_end(args);
+
+    return ret;
+}
+
+OSSL_STORE_INFO *OSSL_STORE_load(OSSL_STORE_CTX *ctx)
+{
+    OSSL_STORE_INFO *v = NULL;
+
+ again:
+    v = ctx-&gt;loader-&gt;load(ctx-&gt;loader_ctx, ctx-&gt;ui_method, ctx-&gt;ui_data);
+
+    if (ctx-&gt;post_process != NULL &amp;&amp; v != NULL) {
+        v = ctx-&gt;post_process(v, ctx-&gt;post_process_data);
+
+        /*
+         * By returning NULL, the callback decides that this object should
+         * be ignored.
+         */
+        if (v == NULL)
+            goto again;
+    }
+
+    return v;
+}
+
+int OSSL_STORE_error(OSSL_STORE_CTX *ctx)
+{
+    return ctx-&gt;loader-&gt;error(ctx-&gt;loader_ctx);
+}
+
+int OSSL_STORE_eof(OSSL_STORE_CTX *ctx)
+{
+    return ctx-&gt;loader-&gt;eof(ctx-&gt;loader_ctx);
+}
+
+int OSSL_STORE_close(OSSL_STORE_CTX *ctx)
+{
+    int loader_ret = ctx-&gt;loader-&gt;close(ctx-&gt;loader_ctx);
+
+    OPENSSL_free(ctx);
+    return loader_ret;
+}
+
+/*
+ * Functions to generate OSSL_STORE_INFOs, one function for each type we
+ * support having in them.  Along with each of them, one macro that
+ * can be used to determine what types are supported.
+ *
+ * In all cases, ownership of the object is transfered to the OSSL_STORE_INFO
+ * and will therefore be freed when the OSSL_STORE_INFO is freed.
+ */
+static OSSL_STORE_INFO *store_info_new(int type, void *data)
+{
+    OSSL_STORE_INFO *info = OPENSSL_zalloc(sizeof(*info));
+
+    if (info == NULL)
+        return NULL;
+
+    info-&gt;type = type;
+    info-&gt;_.data = data;
+    return info;
+}
+
+OSSL_STORE_INFO *OSSL_STORE_INFO_new_NAME(char *name)
+{
+    OSSL_STORE_INFO *info = store_info_new(OSSL_STORE_INFO_NAME, NULL);
+
+    if (info == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_NEW_NAME,
+                      ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+
+    info-&gt;_.name.name = name;
+    info-&gt;_.name.desc = NULL;
+
+    return info;
+}
+
+int OSSL_STORE_INFO_set0_NAME_description(OSSL_STORE_INFO *info, char *desc)
+{
+    if (info-&gt;type != OSSL_STORE_INFO_NAME) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_SET0_NAME_DESCRIPTION,
+                      ERR_R_PASSED_INVALID_ARGUMENT);
+        return 0;
+    }
+
+    info-&gt;_.name.desc = desc;
+
+    return 1;
+}
+OSSL_STORE_INFO *OSSL_STORE_INFO_new_PARAMS(EVP_PKEY *params)
+{
+    OSSL_STORE_INFO *info = store_info_new(OSSL_STORE_INFO_PARAMS, params);
+
+    if (info == NULL)
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_NEW_PARAMS,
+                      ERR_R_MALLOC_FAILURE);
+    return info;
+}
+
+OSSL_STORE_INFO *OSSL_STORE_INFO_new_PKEY(EVP_PKEY *pkey)
+{
+    OSSL_STORE_INFO *info = store_info_new(OSSL_STORE_INFO_PKEY, pkey);
+
+    if (info == NULL)
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_NEW_PKEY,
+                      ERR_R_MALLOC_FAILURE);
+    return info;
+}
+
+OSSL_STORE_INFO *OSSL_STORE_INFO_new_CERT(X509 *x509)
+{
+    OSSL_STORE_INFO *info = store_info_new(OSSL_STORE_INFO_CERT, x509);
+
+    if (info == NULL)
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_NEW_CERT,
+                      ERR_R_MALLOC_FAILURE);
+    return info;
+}
+
+OSSL_STORE_INFO *OSSL_STORE_INFO_new_CRL(X509_CRL *crl)
+{
+    OSSL_STORE_INFO *info = store_info_new(OSSL_STORE_INFO_CRL, crl);
+
+    if (info == NULL)
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_NEW_CRL,
+                      ERR_R_MALLOC_FAILURE);
+    return info;
+}
+
+/*
+ * Functions to try to extract data from a OSSL_STORE_INFO.
+ */
+int OSSL_STORE_INFO_get_type(const OSSL_STORE_INFO *info)
+{
+    return info-&gt;type;
+}
+
+const char *OSSL_STORE_INFO_get0_NAME(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_NAME)
+        return info-&gt;_.name.name;
+    return NULL;
+}
+
+char *OSSL_STORE_INFO_get1_NAME(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_NAME) {
+        char *ret = OPENSSL_strdup(info-&gt;_.name.name);
+
+        if (ret == NULL)
+            OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME,
+                          ERR_R_MALLOC_FAILURE);
+        return ret;
+    }
+    OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME,
+                  OSSL_STORE_R_NOT_A_NAME);
+    return NULL;
+}
+
+const char *OSSL_STORE_INFO_get0_NAME_description(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_NAME)
+        return info-&gt;_.name.desc;
+    return NULL;
+}
+
+char *OSSL_STORE_INFO_get1_NAME_description(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_NAME) {
+        char *ret = OPENSSL_strdup(info-&gt;_.name.desc
+                                   ? info-&gt;_.name.desc : &quot;&quot;);
+
+        if (ret == NULL)
+            OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME_DESCRIPTION,
+                     ERR_R_MALLOC_FAILURE);
+        return ret;
+    }
+    OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME_DESCRIPTION,
+                  OSSL_STORE_R_NOT_A_NAME);
+    return NULL;
+}
+
+EVP_PKEY *OSSL_STORE_INFO_get0_PARAMS(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_PARAMS)
+        return info-&gt;_.params;
+    return NULL;
+}
+
+EVP_PKEY *OSSL_STORE_INFO_get1_PARAMS(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_PARAMS) {
+        EVP_PKEY_up_ref(info-&gt;_.params);
+        return info-&gt;_.params;
+    }
+    OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_GET1_PARAMS,
+                  OSSL_STORE_R_NOT_PARAMETERS);
+    return NULL;
+}
+
+EVP_PKEY *OSSL_STORE_INFO_get0_PKEY(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_PKEY)
+        return info-&gt;_.pkey;
+    return NULL;
+}
+
+EVP_PKEY *OSSL_STORE_INFO_get1_PKEY(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_PKEY) {
+        EVP_PKEY_up_ref(info-&gt;_.pkey);
+        return info-&gt;_.pkey;
+    }
+    OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_GET1_PKEY,
+                  OSSL_STORE_R_NOT_A_KEY);
+    return NULL;
+}
+
+X509 *OSSL_STORE_INFO_get0_CERT(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_CERT)
+        return info-&gt;_.x509;
+    return NULL;
+}
+
+X509 *OSSL_STORE_INFO_get1_CERT(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_CERT) {
+        X509_up_ref(info-&gt;_.x509);
+        return info-&gt;_.x509;
+    }
+    OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_GET1_CERT,
+                  OSSL_STORE_R_NOT_A_CERTIFICATE);
+    return NULL;
+}
+
+X509_CRL *OSSL_STORE_INFO_get0_CRL(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_CRL)
+        return info-&gt;_.crl;
+    return NULL;
+}
+
+X509_CRL *OSSL_STORE_INFO_get1_CRL(const OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_CRL) {
+        X509_CRL_up_ref(info-&gt;_.crl);
+        return info-&gt;_.crl;
+    }
+    OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_GET1_CRL,
+                  OSSL_STORE_R_NOT_A_CRL);
+    return NULL;
+}
+
+/*
+ * Free the OSSL_STORE_INFO
+ */
+void OSSL_STORE_INFO_free(OSSL_STORE_INFO *info)
+{
+    if (info != NULL) {
+        switch (info-&gt;type) {
+        case OSSL_STORE_INFO_EMBEDDED:
+            BUF_MEM_free(info-&gt;_.embedded.blob);
+            OPENSSL_free(info-&gt;_.embedded.pem_name);
+            break;
+        case OSSL_STORE_INFO_NAME:
+            OPENSSL_free(info-&gt;_.name.name);
+            OPENSSL_free(info-&gt;_.name.desc);
+            break;
+        case OSSL_STORE_INFO_PARAMS:
+            EVP_PKEY_free(info-&gt;_.params);
+            break;
+        case OSSL_STORE_INFO_PKEY:
+            EVP_PKEY_free(info-&gt;_.pkey);
+            break;
+        case OSSL_STORE_INFO_CERT:
+            X509_free(info-&gt;_.x509);
+            break;
+        case OSSL_STORE_INFO_CRL:
+            X509_CRL_free(info-&gt;_.crl);
+            break;
+        }
+        OPENSSL_free(info);
+    }
+}
+
+/* Internal functions */
+OSSL_STORE_INFO *ossl_store_info_new_EMBEDDED(const char *new_pem_name,
+                                              BUF_MEM *embedded)
+{
+    OSSL_STORE_INFO *info = store_info_new(OSSL_STORE_INFO_EMBEDDED, NULL);
+
+    if (info == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_NEW_EMBEDDED,
+                      ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+
+    info-&gt;_.embedded.blob = embedded;
+    info-&gt;_.embedded.pem_name =
+        new_pem_name == NULL ? NULL : OPENSSL_strdup(new_pem_name);
+
+    if (new_pem_name != NULL &amp;&amp; info-&gt;_.embedded.pem_name == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_INFO_NEW_EMBEDDED,
+                      ERR_R_MALLOC_FAILURE);
+        OSSL_STORE_INFO_free(info);
+        info = NULL;
+    }
+
+    return info;
+}
+
+BUF_MEM *ossl_store_info_get0_EMBEDDED_buffer(OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_EMBEDDED)
+        return info-&gt;_.embedded.blob;
+    return NULL;
+}
+
+char *ossl_store_info_get0_EMBEDDED_pem_name(OSSL_STORE_INFO *info)
+{
+    if (info-&gt;type == OSSL_STORE_INFO_EMBEDDED)
+        return info-&gt;_.embedded.pem_name;
+    return NULL;
+}
diff --git a/crypto/store/store_locl.h b/crypto/store/store_locl.h
new file mode 100644
index 0000000..a954c57
--- /dev/null
+++ b/crypto/store/store_locl.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &quot;internal/thread_once.h&quot;
+#include &lt;openssl/dsa.h&gt;
+#include &lt;openssl/engine.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/lhash.h&gt;
+#include &lt;openssl/x509.h&gt;
+#include &lt;openssl/store.h&gt;
+
+/*-
+ *  OSSL_STORE_INFO stuff
+ *  ---------------------
+ */
+
+struct ossl_store_info_st {
+    int type;
+    union {
+        void *data;              /* used internally as generic pointer */
+
+        struct {
+            BUF_MEM *blob;
+            char *pem_name;
+        } embedded;              /* when type == OSSL_STORE_INFO_EMBEDDED */
+
+        struct {
+            char *name;
+            char *desc;
+        } name;                  /* when type == OSSL_STORE_INFO_NAME */
+
+        EVP_PKEY *params;        /* when type == OSSL_STORE_INFO_PARAMS */
+        EVP_PKEY *pkey;          /* when type == OSSL_STORE_INFO_PKEY */
+        X509 *x509;              /* when type == OSSL_STORE_INFO_CERT */
+        X509_CRL *crl;           /* when type == OSSL_STORE_INFO_CRL */
+    } _;
+};
+
+DEFINE_STACK_OF(OSSL_STORE_INFO)
+
+/*
+ * EMBEDDED is a special type of OSSL_STORE_INFO, specially for the file
+ * handlers.  It should never reach a calling application or any engine.
+ * However, it can be used by a FILE_HANDLER's try_decode function to signal
+ * that it has decoded the incoming blob into a new blob, and that the
+ * attempted decoding should be immediately restarted with the new blob, using
+ * the new PEM name.
+ */
+/*
+ * Because this is an internal type, we don't make it public.
+ */
+#define OSSL_STORE_INFO_EMBEDDED       -1
+OSSL_STORE_INFO *ossl_store_info_new_EMBEDDED(const char *new_pem_name,
+                                              BUF_MEM *embedded);
+BUF_MEM *ossl_store_info_get0_EMBEDDED_buffer(OSSL_STORE_INFO *info);
+char *ossl_store_info_get0_EMBEDDED_pem_name(OSSL_STORE_INFO *info);
+
+/*-
+ *  OSSL_STORE_LOADER stuff
+ *  -----------------------
+ */
+
+int ossl_store_register_loader_int(OSSL_STORE_LOADER *loader);
+OSSL_STORE_LOADER *ossl_store_unregister_loader_int(const char *scheme);
+
+/* loader stuff */
+struct ossl_store_loader_st {
+    const char *scheme;
+    ENGINE *engine;
+    OSSL_STORE_open_fn open;
+    OSSL_STORE_ctrl_fn ctrl;
+    OSSL_STORE_load_fn load;
+    OSSL_STORE_eof_fn eof;
+    OSSL_STORE_error_fn error;
+    OSSL_STORE_close_fn close;
+};
+DEFINE_LHASH_OF(OSSL_STORE_LOADER);
+
+const OSSL_STORE_LOADER *ossl_store_get0_loader_int(const char *scheme);
+void ossl_store_destroy_loaders_int(void);
+
+/*-
+ *  OSSL_STORE init stuff
+ *  ---------------------
+ */
+
+int ossl_store_init_once(void);
+int ossl_store_file_loader_init(void);
diff --git a/crypto/store/store_register.c b/crypto/store/store_register.c
new file mode 100644
index 0000000..bde190e
--- /dev/null
+++ b/crypto/store/store_register.c
@@ -0,0 +1,278 @@
+/*
+ * Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;string.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;assert.h&gt;
+
+#include &lt;openssl/err.h&gt;
+#include &lt;openssl/lhash.h&gt;
+#include &quot;store_locl.h&quot;
+
+static CRYPTO_RWLOCK *registry_lock;
+static CRYPTO_ONCE registry_init = CRYPTO_ONCE_STATIC_INIT;
+
+DEFINE_RUN_ONCE_STATIC(do_registry_init)
+{
+    registry_lock = CRYPTO_THREAD_lock_new();
+    return registry_lock != NULL;
+}
+
+/*
+ *  Functions for manipulating OSSL_STORE_LOADERs
+ */
+
+OSSL_STORE_LOADER *OSSL_STORE_LOADER_new(ENGINE *e, const char *scheme)
+{
+    OSSL_STORE_LOADER *res = OPENSSL_zalloc(sizeof(*res));
+
+    if (res == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+
+    /*
+     * We usually don't check NULL arguments.  For loaders, though, the
+     * scheme is crucial and must never be NULL, or the user will get
+     * mysterious errors when trying to register the created loader
+     * later on.
+     */
+    if (scheme == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW,
+                      OSSL_STORE_R_INVALID_SCHEME);
+        return NULL;
+    }
+
+    res-&gt;engine = e;
+    res-&gt;scheme = scheme;
+    return res;
+}
+
+const ENGINE *OSSL_STORE_LOADER_get0_engine(const OSSL_STORE_LOADER *loader)
+{
+    return loader-&gt;engine;
+}
+
+const char *OSSL_STORE_LOADER_get0_scheme(const OSSL_STORE_LOADER *loader)
+{
+    return loader-&gt;scheme;
+}
+
+int OSSL_STORE_LOADER_set_open(OSSL_STORE_LOADER *loader,
+                               OSSL_STORE_open_fn open_function)
+{
+    loader-&gt;open = open_function;
+    return 1;
+}
+
+int OSSL_STORE_LOADER_set_ctrl(OSSL_STORE_LOADER *loader,
+                               OSSL_STORE_ctrl_fn ctrl_function)
+{
+    loader-&gt;ctrl = ctrl_function;
+    return 1;
+}
+
+int OSSL_STORE_LOADER_set_load(OSSL_STORE_LOADER *loader,
+                               OSSL_STORE_load_fn load_function)
+{
+    loader-&gt;load = load_function;
+    return 1;
+}
+
+int OSSL_STORE_LOADER_set_eof(OSSL_STORE_LOADER *loader,
+                              OSSL_STORE_eof_fn eof_function)
+{
+    loader-&gt;eof = eof_function;
+    return 1;
+}
+
+int OSSL_STORE_LOADER_set_error(OSSL_STORE_LOADER *loader,
+                                OSSL_STORE_error_fn error_function)
+{
+    loader-&gt;error = error_function;
+    return 1;
+}
+
+int OSSL_STORE_LOADER_set_close(OSSL_STORE_LOADER *loader,
+                                OSSL_STORE_close_fn close_function)
+{
+    loader-&gt;close = close_function;
+    return 1;
+}
+
+void OSSL_STORE_LOADER_free(OSSL_STORE_LOADER *loader)
+{
+    OPENSSL_free(loader);
+}
+
+/*
+ *  Functions for registering OSSL_STORE_LOADERs
+ */
+
+static unsigned long store_loader_hash(const OSSL_STORE_LOADER *v)
+{
+    return OPENSSL_LH_strhash(v-&gt;scheme);
+}
+
+static int store_loader_cmp(const OSSL_STORE_LOADER *a,
+                            const OSSL_STORE_LOADER *b)
+{
+    if (a-&gt;scheme != NULL &amp;&amp; b-&gt;scheme != NULL)
+        return strcmp(a-&gt;scheme, b-&gt;scheme);
+    else if (a-&gt;scheme == b-&gt;scheme)
+        return 0;
+    return a-&gt;scheme == NULL ? -1 : 1;
+}
+
+static LHASH_OF(OSSL_STORE_LOADER) *loader_register = NULL;
+
+int ossl_store_register_loader_int(OSSL_STORE_LOADER *loader)
+{
+    const char *scheme = loader-&gt;scheme;
+    int ok = 0;
+
+    /*
+     * Check that the given scheme conforms to correct scheme syntax as per
+     * RFC 3986:
+     *
+     * scheme        = ALPHA *( ALPHA / DIGIT / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; )
+     */
+    if (isalpha(*scheme))
+        while (*scheme != '\0'
+               &amp;&amp; (isalpha(*scheme)
+                   || isdigit(*scheme)
+                   || strchr(&quot;+-.&quot;, *scheme) != NULL))
+            scheme++;
+    if (*scheme != '\0') {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_REGISTER_LOADER_INT,
+                      OSSL_STORE_R_INVALID_SCHEME);
+        ERR_add_error_data(4, &quot;scheme=&quot;, loader-&gt;scheme);
+        return 0;
+    }
+
+    if (!RUN_ONCE(&amp;registry_init, do_registry_init)) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_REGISTER_LOADER_INT,
+                      ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+    CRYPTO_THREAD_write_lock(registry_lock);
+
+    if (loader_register == NULL) {
+        loader_register = lh_OSSL_STORE_LOADER_new(store_loader_hash,
+                                                   store_loader_cmp);
+    }
+
+    if (loader_register != NULL
+        &amp;&amp; (lh_OSSL_STORE_LOADER_insert(loader_register, loader) != NULL
+            || lh_OSSL_STORE_LOADER_error(loader_register) == 0))
+        ok = 1;
+
+    CRYPTO_THREAD_unlock(registry_lock);
+
+    return ok;
+}
+int OSSL_STORE_register_loader(OSSL_STORE_LOADER *loader)
+{
+    if (!ossl_store_init_once())
+        return 0;
+    return ossl_store_register_loader_int(loader);
+}
+
+const OSSL_STORE_LOADER *ossl_store_get0_loader_int(const char *scheme)
+{
+    OSSL_STORE_LOADER template;
+    OSSL_STORE_LOADER *loader = NULL;
+
+    template.scheme = scheme;
+    template.open = NULL;
+    template.load = NULL;
+    template.eof = NULL;
+    template.close = NULL;
+
+    if (!ossl_store_init_once())
+        return NULL;
+
+    if (!RUN_ONCE(&amp;registry_init, do_registry_init)) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_GET0_LOADER_INT,
+                      ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+    CRYPTO_THREAD_write_lock(registry_lock);
+
+    loader = lh_OSSL_STORE_LOADER_retrieve(loader_register, &amp;template);
+
+    if (loader == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_GET0_LOADER_INT,
+                      OSSL_STORE_R_UNREGISTERED_SCHEME);
+        ERR_add_error_data(2, &quot;scheme=&quot;, scheme);
+    }
+
+    CRYPTO_THREAD_unlock(registry_lock);
+
+    return loader;
+}
+
+OSSL_STORE_LOADER *ossl_store_unregister_loader_int(const char *scheme)
+{
+    OSSL_STORE_LOADER template;
+    OSSL_STORE_LOADER *loader = NULL;
+
+    template.scheme = scheme;
+    template.open = NULL;
+    template.load = NULL;
+    template.eof = NULL;
+    template.close = NULL;
+
+    if (!RUN_ONCE(&amp;registry_init, do_registry_init)) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_UNREGISTER_LOADER_INT,
+                      ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+    CRYPTO_THREAD_write_lock(registry_lock);
+
+    loader = lh_OSSL_STORE_LOADER_delete(loader_register, &amp;template);
+
+    if (loader == NULL) {
+        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_UNREGISTER_LOADER_INT,
+                      OSSL_STORE_R_UNREGISTERED_SCHEME);
+        ERR_add_error_data(2, &quot;scheme=&quot;, scheme);
+    }
+
+    CRYPTO_THREAD_unlock(registry_lock);
+
+    return loader;
+}
+OSSL_STORE_LOADER *OSSL_STORE_unregister_loader(const char *scheme)
+{
+    if (!ossl_store_init_once())
+        return 0;
+    return ossl_store_unregister_loader_int(scheme);
+}
+
+void ossl_store_destroy_loaders_int(void)
+{
+    assert(lh_OSSL_STORE_LOADER_num_items(loader_register) == 0);
+    lh_OSSL_STORE_LOADER_free(loader_register);
+    loader_register = NULL;
+    CRYPTO_THREAD_lock_free(registry_lock);
+    registry_lock = NULL;
+}
+
+/*
+ *  Functions to list OSSL_STORE loaders
+ */
+
+IMPLEMENT_LHASH_DOALL_ARG_CONST(OSSL_STORE_LOADER, void);
+int OSSL_STORE_do_all_loaders(void (*do_function) (const OSSL_STORE_LOADER
+                                                   *loader, void *do_arg),
+                              void *do_arg)
+{
+    lh_OSSL_STORE_LOADER_doall_void(loader_register, do_function, do_arg);
+    return 1;
+}
diff --git a/crypto/store/store_strings.c b/crypto/store/store_strings.c
new file mode 100644
index 0000000..76cf316
--- /dev/null
+++ b/crypto/store/store_strings.c
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/store.h&gt;
+
+static char *type_strings[] = {
+    &quot;Name&quot;,                      /* OSSL_STORE_INFO_NAME */
+    &quot;Parameters&quot;,                /* OSSL_STORE_INFO_PARAMS */
+    &quot;Pkey&quot;,                      /* OSSL_STORE_INFO_PKEY */
+    &quot;Certificate&quot;,               /* OSSL_STORE_INFO_CERT */
+    &quot;CRL&quot;                        /* OSSL_STORE_INFO_CRL */
+};
+
+const char *OSSL_STORE_INFO_type_string(int type)
+{
+    int types = sizeof(type_strings) / sizeof(type_strings[0]);
+
+    if (type &lt; 1 || type &gt; types)
+        return NULL;
+
+    return type_strings[type - 1];
+}
diff --git a/doc/man1/storeutl.pod b/doc/man1/storeutl.pod
new file mode 100644
index 0000000..8874f34
--- /dev/null
+++ b/doc/man1/storeutl.pod
@@ -0,0 +1,76 @@
+=pod
+
+=head1 NAME
+
+storeutl - STORE utility
+
+=head1 SYNOPSIS
+
+B&lt;openssl&gt; B&lt;storeutl&gt;
+[B&lt;-help&gt;]
+[B&lt;-out file&gt;]
+[B&lt;-noout&gt;]
+[B&lt;-passin arg&gt;]
+[B&lt;-text arg&gt;]
+[B&lt;-engine id&gt;]
+B&lt;uri&gt; ...
+
+=head1 DESCRIPTION
+
+The B&lt;storeutl&gt; command can be used to display the contents (after decryption
+as the case may be) fetched from the given URIs.
+
+=head1 COMMAND OPTIONS
+
+=over 4
+
+=item B&lt;-help&gt;
+
+Print out a usage message.
+
+=item B&lt;-out filename&gt;
+
+specifies the output filename to write to or standard output by
+default.
+
+=item B&lt;-noout&gt;
+
+this option prevents output of the PEM data.
+
+=item B&lt;-passin arg&gt;
+
+the key password source. For more information about the format of B&lt;arg&gt;
+see the B&lt;PASS PHRASE ARGUMENTS&gt; section in L&lt;openssl(1)&gt;.
+
+=item B&lt;-text&gt;
+
+Prints out the objects in text form, similarly to the B&lt;-text&gt; output from
+B&lt;openssl x509&gt;, B&lt;openssl pkey&gt;, etc.
+
+=item B&lt;-engine id&gt;
+
+specifying an engine (by its unique B&lt;id&gt; string) will cause B&lt;storeutl&gt;
+to attempt to obtain a functional reference to the specified engine,
+thus initialising it if needed.
+The engine will then be set as the default for all available algorithms.
+
+=back
+
+=head1 SEE ALSO
+
+L&lt;openssl(1)&gt;
+
+=head1 HISTORY
+
+B&lt;openssl&gt; B&lt;storeutl&gt; was added to OpenSSL 1.1.1.
+
+=head1 COPYRIGHT
+
+Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man3/OSSL_STORE_INFO.pod b/doc/man3/OSSL_STORE_INFO.pod
new file mode 100644
index 0000000..22ab666
--- /dev/null
+++ b/doc/man3/OSSL_STORE_INFO.pod
@@ -0,0 +1,196 @@
+=pod
+
+=head1 NAME
+
+OSSL_STORE_INFO, OSSL_STORE_INFO_get_type, OSSL_STORE_INFO_get0_NAME,
+OSSL_STORE_INFO_get0_NAME_description, OSSL_STORE_INFO_get0_PARAMS,
+OSSL_STORE_INFO_get0_PKEY, OSSL_STORE_INFO_get0_CERT, OSSL_STORE_INFO_get0_CRL,
+OSSL_STORE_INFO_get1_NAME, OSSL_STORE_INFO_get1_NAME_description,
+OSSL_STORE_INFO_get1_PARAMS, OSSL_STORE_INFO_get1_PKEY,
+OSSL_STORE_INFO_get1_CERT,
+OSSL_STORE_INFO_get1_CRL, OSSL_STORE_INFO_type_string, OSSL_STORE_INFO_free, 
+OSSL_STORE_INFO_new_NAME, OSSL_STORE_INFO_set0_NAME_description,
+OSSL_STORE_INFO_new_PARAMS, OSSL_STORE_INFO_new_PKEY, OSSL_STORE_INFO_new_CERT,
+OSSL_STORE_INFO_new_CRL - Functions to manipulate OSSL_STORE_INFO objects 
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/store.h&gt;
+ 
+ typedef struct ossl_store_info_st OSSL_STORE_INFO;
+
+ int OSSL_STORE_INFO_get_type(const OSSL_STORE_INFO *store_info);
+ const char *OSSL_STORE_INFO_get0_NAME(const OSSL_STORE_INFO *store_info);
+ char *OSSL_STORE_INFO_get1_NAME(const OSSL_STORE_INFO *store_info);
+ const char *OSSL_STORE_INFO_get0_NAME_description(const OSSL_STORE_INFO
+                                                   *store_info);
+ char *OSSL_STORE_INFO_get1_NAME_description(const OSSL_STORE_INFO *store_info);
+ EVP_PKEY *OSSL_STORE_INFO_get0_PARAMS(const OSSL_STORE_INFO *store_info);
+ EVP_PKEY *OSSL_STORE_INFO_get1_PARAMS(const OSSL_STORE_INFO *store_info);
+ EVP_PKEY *OSSL_STORE_INFO_get0_PKEY(const OSSL_STORE_INFO *store_info);
+ EVP_PKEY *OSSL_STORE_INFO_get1_PKEY(const OSSL_STORE_INFO *store_info);
+ X509 *OSSL_STORE_INFO_get0_CERT(const OSSL_STORE_INFO *store_info);
+ X509 *OSSL_STORE_INFO_get1_CERT(const OSSL_STORE_INFO *store_info);
+ X509_CRL *OSSL_STORE_INFO_get0_CRL(const OSSL_STORE_INFO *store_info);
+ X509_CRL *OSSL_STORE_INFO_get1_CRL(const OSSL_STORE_INFO *store_info);
+
+ const char *OSSL_STORE_INFO_type_string(int type);
+
+ void OSSL_STORE_INFO_free(OSSL_STORE_INFO *store_info);
+
+ OSSL_STORE_INFO *OSSL_STORE_INFO_new_NAME(char *name);
+ int OSSL_STORE_INFO_set0_NAME_description(OSSL_STORE_INFO *info, char *desc);
+ OSSL_STORE_INFO *OSSL_STORE_INFO_new_PARAMS(DSA *dsa_params);
+ OSSL_STORE_INFO *OSSL_STORE_INFO_new_PKEY(EVP_PKEY *pkey);
+ OSSL_STORE_INFO *OSSL_STORE_INFO_new_CERT(X509 *x509);
+ OSSL_STORE_INFO *OSSL_STORE_INFO_new_CRL(X509_CRL *crl);
+
+=head1 DESCRIPTION
+
+These functions are primarly useful for applications to retrieve
+supported objects from B&lt;OSSL_STORE_INFO&gt; objects and for scheme specific
+loaders to create B&lt;OSSL_STORE_INFO&gt; holders.
+
+=head2 Types
+
+B&lt;OSSL_STORE_INFO&gt; is an opaque type that's just an intermediary holder for
+the objects that have been retrieved by OSSL_STORE_load() and similar
+functions.
+Supported OpenSSL type object can be extracted using one of
+STORE_INFO_get0_TYPE().
+The life time of this extracted object is as long as the life time of
+the B&lt;OSSL_STORE_INFO&gt; it was extracted from, so care should be taken not
+to free the latter too early.
+As an alternative, STORE_INFO_get1_TYPE() extracts a duplicate (or the
+same object with its reference count increased), which can be used
+after the containing B&lt;OSSL_STORE_INFO&gt; has been freed.
+The object returned by STORE_INFO_get1_TYPE() must be freed separately
+by the caller.
+See L&lt;/SUPPORTED OBJECTS&gt; for more information on the types that are
+supported.
+
+=head2 Functions
+
+OSSL_STORE_INFO_get_type() takes a B&lt;OSSL_STORE_INFO&gt; and returns the STORE
+type number for the object inside.
+STORE_INFO_get_type_string() takes a STORE type number and returns a
+short string describing it.
+
+OSSL_STORE_INFO_get0_NAME(), OSSL_STORE_INFO_get0_NAME_description(),
+OSSL_STORE_INFO_get0_PARAMS(), OSSL_STORE_INFO_get0_PKEY(),
+OSSL_STORE_INFO_get0_CERT() and OSSL_STORE_INFO_get0_CRL() all take a
+B&lt;OSSL_STORE_INFO&gt; and return the held object of the appropriate OpenSSL
+type provided that's what's held.
+
+OSSL_STORE_INFO_get1_NAME(), OSSL_STORE_INFO_get1_NAME_description(),
+OSSL_STORE_INFO_get1_PARAMS(), OSSL_STORE_INFO_get1_PKEY(),
+OSSL_STORE_INFO_get1_CERT() and OSSL_STORE_INFO_get1_CRL() all take a
+B&lt;OSSL_STORE_INFO&gt; and return a duplicate of the held object of the
+appropriate OpenSSL type provided that's what's held.
+
+OSSL_STORE_INFO_free() frees a B&lt;OSSL_STORE_INFO&gt; and its contained type.
+
+OSSL_STORE_INFO_new_NAME() , OSSL_STORE_INFO_new_PARAMS(),
+OSSL_STORE_INFO_new_PKEY(), OSSL_STORE_INFO_new_CERT() and
+OSSL_STORE_INFO_new_CRL() create a B&lt;OSSL_STORE_INFO&gt;
+object to hold the given input object.
+Additionally, for B&lt;OSSL_STORE_INFO_NAME&gt;` objects,
+OSSL_STORE_INFO_set0_NAME_description() can be used to add an extra
+description.
+This description is meant to be human readable and should be used for
+information printout.
+
+=head1 SUPPORTED OBJECTS
+
+Currently supported object types are:
+
+=over 4
+
+=item OSSL_STORE_INFO_NAME
+
+A name is exactly that, a name.
+It's like a name in a directory, but formatted as a complete URI.
+For example, the path in URI C&lt;file:/foo/bar/&gt; could include a file
+named C&lt;cookie.pem&gt;, and in that case, the returned B&lt;OSSL_STORE_INFO_NAME&gt;
+object would have the URI C&lt;file:/foo/bar/cookie.pem&gt;, which can be
+used by the application to get the objects in that file.
+This can be applied to all schemes that can somehow support a listing
+of object URIs.
+
+For C&lt;file:&gt; URIs that are used without the explicit scheme, or paths
+given to L&lt;OSSL_STORE_open_file(3)&gt;, the returned name will be the path of
+each object, so if C&lt;/foo/bar&gt; was given and that path has the file
+C&lt;cookie.pem&gt;, the name C&lt;/foo/bar/cookie.pem&gt; will be returned.
+
+At the discretion of the loader that was used to get these names, an
+extra description may be attached as well.
+
+=item OSSL_STORE_INFO_PARAMS
+
+Key parameters.
+
+=item OSSL_STORE_INFO_PKEY
+
+A private/public key of some sort.
+
+=item OSSL_STORE_INFO_CERT
+
+An X.509 certificate.
+
+=item OSSL_STORE_INFO_CRL
+
+A X.509 certificate reocation list.
+
+=back
+
+=head1 RETURN VALUES
+
+OSSL_STORE_INFO_get_type() returns the STORE type number of the given
+B&lt;OSSL_STORE_INFO&gt;.
+There is no error value.
+
+OSSL_STORE_INFO_get0_NAME(), OSSL_STORE_INFO_get0_NAME_description(),
+OSSL_STORE_INFO_get0_PARAMS(), OSSL_STORE_INFO_get0_PKEY(),
+OSSL_STORE_INFO_get0_CERT() and OSSL_STORE_INFO_get0_CRL() all return
+a pointer to the OpenSSL object on success, NULL otherwise.
+
+OSSL_STORE_INFO_get0_NAME(), OSSL_STORE_INFO_get0_NAME_description(),
+OSSL_STORE_INFO_get0_PARAMS(), OSSL_STORE_INFO_get0_PKEY(),
+OSSL_STORE_INFO_get0_CERT() and OSSL_STORE_INFO_get0_CRL() all return
+a pointer to a duplicate of the OpenSSL object on success, NULL otherwise.
+
+OSSL_STORE_INFO_type_string() returns a string on success, or B&lt;NULL&gt; on
+failure.
+
+OSSL_STORE_INFO_new_NAME(), OSSL_STORE_INFO_new_PARAMS(),
+OSSL_STORE_INFO_new_PKEY(), OSSL_STORE_INFO_new_CERT() and
+OSSL_STORE_INFO_new_CRL() return a B&lt;OSSL_STORE_INFO&gt;
+pointer on success, or B&lt;NULL&gt; on failure.
+
+OSSL_STORE_INFO_set0_NAME_description() returns 1 on success, or 0 on
+failure.
+
+=head1 SEE ALSO
+
+L&lt;ossl_store(7)&gt;, L&lt;OSSL_STORE_open(3)&gt;, L&lt;OSSL_STORE_register_loader(3)&gt;
+
+=head1 HISTORY
+
+OSSL_STORE_INFO(), OSSL_STORE_INFO_get_type(), OSSL_STORE_INFO_get0_NAME(),
+OSSL_STORE_INFO_get0_PARAMS(), OSSL_STORE_INFO_get0_PKEY(),
+OSSL_STORE_INFO_get0_CERT(), OSSL_STORE_INFO_get0_CRL(),
+OSSL_STORE_INFO_type_string(), OSSL_STORE_INFO_free(), OSSL_STORE_INFO_new_NAME(),
+OSSL_STORE_INFO_new_PARAMS(), OSSL_STORE_INFO_new_PKEY(),
+OSSL_STORE_INFO_new_CERT() and OSSL_STORE_INFO_new_CRL()
+were added to OpenSSL 1.1.1.
+
+=head1 COPYRIGHT
+
+Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man3/OSSL_STORE_LOADER.pod b/doc/man3/OSSL_STORE_LOADER.pod
new file mode 100644
index 0000000..4386c28
--- /dev/null
+++ b/doc/man3/OSSL_STORE_LOADER.pod
@@ -0,0 +1,229 @@
+=pod
+
+=head1 NAME
+
+OSSL_STORE_LOADER, OSSL_STORE_LOADER_CTX, OSSL_STORE_LOADER_new,
+OSSL_STORE_LOADER_get0_engine, OSSL_STORE_LOADER_get0_scheme,
+OSSL_STORE_LOADER_set_open, OSSL_STORE_LOADER_set_ctrl,
+OSSL_STORE_LOADER_set_load, OSSL_STORE_LOADER_set_eof,
+OSSL_STORE_LOADER_set_error, OSSL_STORE_LOADER_set_close,
+OSSL_STORE_LOADER_free, OSSL_STORE_register_loader,
+OSSL_STORE_unregister_loader, OSSL_STORE_open_fn, OSSL_STORE_ctrl_fn,
+OSSL_STORE_load_fn, OSSL_STORE_eof_fn, OSSL_STORE_error_fn,
+OSSL_STORE_close_fn - Types and functions to manipulate, register and
+unregister STORE loaders for different URI schemes
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/store.h&gt;
+
+ typedef struct ossl_store_loader_st OSSL_STORE_LOADER;
+
+ OSSL_STORE_LOADER *OSSL_STORE_LOADER_new(ENGINE *e, const char *scheme);
+ const ENGINE *OSSL_STORE_LOADER_get0_engine(const OSSL_STORE_LOADER
+                                             *store_loader);
+ const char *OSSL_STORE_LOADER_get0_scheme(const OSSL_STORE_LOADER
+                                           *store_loader);
+
+ /* struct ossl_store_loader_ctx_st is defined differently by each loader */
+ typedef struct ossl_store_loader_ctx_st OSSL_STORE_LOADER_CTX;
+
+ typedef OSSL_STORE_LOADER_CTX *(*OSSL_STORE_open_fn)(const char *uri,
+                                                      const UI_METHOD *ui_method,
+                                                      void *ui_data);
+ int OSSL_STORE_LOADER_set_open(OSSL_STORE_LOADER *store_loader,
+                                OSSL_STORE_open_fn store_open_function);
+ typedef int (*OSSL_STORE_ctrl_fn)(OSSL_STORE_LOADER_CTX *ctx, int cmd,
+                                   va_list args);
+ int OSSL_STORE_LOADER_set_ctrl(OSSL_STORE_LOADER *store_loader,
+                                OSSL_STORE_ctrl_fn store_ctrl_function);
+ typedef OSSL_STORE_INFO *(*OSSL_STORE_load_fn)(OSSL_STORE_LOADER_CTX *ctx,
+                                                UI_METHOD *ui_method,
+                                                void *ui_data);
+ int OSSL_STORE_LOADER_set_load(OSSL_STORE_LOADER *store_loader,
+                                OSSL_STORE_load_fn store_load_function);
+ typedef int (*OSSL_STORE_eof_fn)(OSSL_STORE_LOADER_CTX *ctx);
+ int OSSL_STORE_LOADER_set_eof(OSSL_STORE_LOADER *store_loader,
+                               OSSL_STORE_eof_fn store_eof_function);
+ typedef int (*OSSL_STORE_error_fn)(OSSL_STORE_LOADER_CTX *ctx);
+ int OSSL_STORE_LOADER_set_error(OSSL_STORE_LOADER *store_loader,
+                                 OSSL_STORE_error_fn store_error_function);
+ typedef int (*OSSL_STORE_close_fn)(OSSL_STORE_LOADER_CTX *ctx);
+ int OSSL_STORE_LOADER_set_close(OSSL_STORE_LOADER *store_loader,
+                                 OSSL_STORE_close_fn store_close_function);
+ void OSSL_STORE_LOADER_free(OSSL_STORE_LOADER *store_loader);
+ 
+ int OSSL_STORE_register_loader(OSSL_STORE_LOADER *loader);
+ OSSL_STORE_LOADER *OSSL_STORE_unregister_loader(const char *scheme);
+
+=head1 DESCRIPTION
+
+These functions help applications and engines to create loaders for
+schemes they support.
+
+=head2 Types
+
+B&lt;OSSL_STORE_LOADER&gt; is the type to hold a loader.
+It contains a scheme and the functions needed to implement
+OSSL_STORE_open(), OSSL_STORE_load(), OSSL_STORE_eof(), OSSL_STORE_error() and
+OSSL_STORE_close() for this scheme.
+
+B&lt;OSSL_STORE_LOADER_CTX&gt; is a type template, to be defined by each loader
+using B&lt;struct ossl_store_loader_ctx_st { ... }&gt;.
+
+B&lt;OSSL_STORE_open_fn&gt;, B&lt;OSSL_STORE_ctrl_fn&gt;, B&lt;OSSL_STORE_load_fn&gt;,
+B&lt;OSSL_STORE_eof_fn&gt; and B&lt;OSSL_STORE_close_fn&gt; are the function pointer
+types used within a STORE loader.
+The functions pointed at define the functionality of the given loader.
+
+=over 4
+
+=item B&lt;OSSL_STORE_open_fn&gt;
+
+This function takes a URI and is expected to interpret it in the best
+manner possible according to the scheme the loader implements, it also
+takes a B&lt;UI_METHOD&gt; and associated data, to be used any time
+something needs to be prompted for.
+Furthermore, this function is expected to initialize what needs to be
+initialized, to create a privata data store (B&lt;OSSL_STORE_LOADER_CTX&gt;, see
+above), and to return it.
+If something goes wrong, this function is expected to return NULL.
+
+=item B&lt;OSSL_STORE_ctrl_fn&gt;
+
+This function takes a B&lt;OSSL_STORE_LOADER_CTX&gt; pointer, a command number
+B&lt;cmd&gt; and a B&lt;va_list&gt; B&lt;args&gt; and is used to manipulate loader
+specific parameters.
+
+=begin comment
+
+Globally known command numbers are documented in L&lt;OSSL_STORE_ctrl(3)&gt;,
+along with what B&lt;args&gt; are expected with each of them.
+
+=end comment
+
+Loader specific command numbers must begin at B&lt;OSSL_STORE_C_CUSTOM_START&gt;.
+Any number below that is reserved for future globally known command
+numbers.
+
+This function is expected to return 1 on success, 0 on error.
+
+=item B&lt;OSSL_STORE_load_fn&gt;
+
+This function takes a B&lt;OSSL_STORE_LOADER_CTX&gt; pointer and a B&lt;UI_METHOD&gt;
+with associated data.
+It's expected to load the next available data, mold it into a data
+structure that can be wrapped in a B&lt;OSSL_STORE_INFO&gt; using one of the
+L&lt;OSSL_STORE_INFO(3)&gt; functions.
+If no more data is available or an error occurs, this function is
+expected to return NULL.
+The B&lt;OSSL_STORE_eof_fn&gt; and B&lt;OSSL_STORE_error_fn&gt; functions must indicate if
+it was in fact the end of data or if an error occured.
+
+Note that this function retrives I&lt;one&gt; data item only.
+
+=item B&lt;OSSL_STORE_eof_fn&gt;
+
+This function takes a B&lt;OSSL_STORE_LOADER_CTX&gt; pointer and is expected to
+return 1 to indicate that the end of available data has been reached.
+It is otherwise expected to return 0.
+
+=item B&lt;OSSL_STORE_error_fn&gt;
+
+This function takes a B&lt;OSSL_STORE_LOADER_CTX&gt; pointer and is expected to
+return 1 to indicate that an error occured in a previous call to the
+B&lt;OSSL_STORE_load_fn&gt; function.
+It is otherwise expected to return 0.
+
+=item B&lt;OSSL_STORE_close_fn&gt;
+
+This function takes a B&lt;OSSL_STORE_LOADER_CTX&gt; pointer and is expected to
+close or shut down what needs to be closed, and finally free the
+contents of the B&lt;OSSL_STORE_LOADER_CTX&gt; pointer.
+It returns 1 on success and 0 on error.
+
+=back
+
+=head2 Functions
+
+OSSL_STORE_LOADER_new() creates a new B&lt;OSSL_STORE_LOADER&gt;.
+It takes an B&lt;ENGINE&gt; B&lt;e&gt; and a string B&lt;scheme&gt;.
+B&lt;scheme&gt; must I&lt;always&gt; be set.
+Both B&lt;e&gt; and B&lt;scheme&gt; are used as is and must therefore be alive as
+long as the created loader is.
+
+OSSL_STORE_LOADER_get0_engine() returns the engine of the B&lt;store_loader&gt;.
+OSSL_STORE_LOADER_get0_scheme() returns the scheme of the B&lt;store_loader&gt;.
+
+OSSL_STORE_LOADER_set_open() sets the opener function for the
+B&lt;store_loader&gt;.
+
+OSSL_STORE_LOADER_set_ctrl() sets the control function for the
+B&lt;store_loader&gt;.
+
+OSSL_STORE_LOADER_set_load() sets the loader function for the
+B&lt;store_loader&gt;.
+
+OSSL_STORE_LOADER_set_eof() sets the end of file checker function for the
+B&lt;store_loader&gt;.
+
+OSSL_STORE_LOADER_set_close() sets the closing function for the
+B&lt;store_loader&gt;.
+
+OSSL_STORE_LOADER_free() frees the given B&lt;store_loader&gt;.
+
+OSSL_STORE_register_loader() register the given B&lt;store_loader&gt; and thereby
+makes it available for use with OSSL_STORE_open(), OSSL_STORE_load(),
+OSSL_STORE_eof() and OSSL_STORE_close().
+
+OSSL_STORE_unregister_loader() unregister the store loader for the given
+B&lt;scheme&gt;.
+
+=head1 NOTES
+
+The B&lt;file:&gt; scheme has built in support.
+
+=head1 RETURN VALUES
+
+The functions with the types B&lt;OSSL_STORE_open_fn&gt;, B&lt;OSSL_STORE_ctrl_fn&gt;,
+B&lt;OSSL_STORE_load_fn&gt;, B&lt;OSSL_STORE_eof_fn&gt; and B&lt;OSSL_STORE_close_fn&gt; have the
+same return values as OSSL_STORE_open(), OSSL_STORE_load(), OSSL_STORE_eof() and
+OSSL_STORE_close(), respectively.
+
+OSSL_STORE_LOADER_new() returns a pointer to a B&lt;OSSL_STORE_LOADER&gt; on success,
+or B&lt;NULL&gt; on failure.
+
+OSSL_STORE_LOADER_set_open(), OSSL_STORE_LOADER_set_ctrl(),
+OSSL_STORE_LOADER_set_load(), OSSL_STORE_LOADER_set_eof() and
+OSSL_STORE_LOADER_set_close() return 1 on success, or 0 on failure.
+
+OSSL_STORE_register_loader() returns 1 on success, or 0 on failure.
+
+OSSL_STORE_unregister_loader() returns the unregistered loader on success,
+or B&lt;NULL&gt; on failure.
+
+=head1 SEE ALSO
+
+L&lt;ossl_store(7)&gt;, L&lt;OSSL_STORE_open(3)&gt;
+
+=head1 HISTORY
+
+OSSL_STORE_LOADER(), OSSL_STORE_LOADER_CTX(), OSSL_STORE_LOADER_new(),
+OSSL_STORE_LOADER_set0_scheme(), OSSL_STORE_LOADER_set_open(),
+OSSL_STORE_LOADER_set_ctrl(), OSSL_STORE_LOADER_set_load(),
+OSSL_STORE_LOADER_set_eof(), OSSL_STORE_LOADER_set_close(),
+OSSL_STORE_LOADER_free(), OSSL_STORE_register_loader(),
+OSSL_STORE_unregister_loader(), OSSL_STORE_open_fn(), OSSL_STORE_ctrl_fn(),
+OSSL_STORE_load_fn(), OSSL_STORE_eof_fn() and OSSL_STORE_close_fn()
+were added to OpenSSL 1.1.1.
+
+=head1 COPYRIGHT
+
+Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man3/OSSL_STORE_open.pod b/doc/man3/OSSL_STORE_open.pod
new file mode 100644
index 0000000..9a05443
--- /dev/null
+++ b/doc/man3/OSSL_STORE_open.pod
@@ -0,0 +1,145 @@
+=pod
+
+=head1 NAME
+
+OSSL_STORE_CTX, OSSL_STORE_post_process_info_fn, OSSL_STORE_open,
+OSSL_STORE_ctrl, OSSL_STORE_load, OSSL_STORE_eof, OSSL_STORE_error,
+OSSL_STORE_close - Types and functions to read objects from a URI
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/store.h&gt;
+ 
+ typedef struct ossl_store_ctx_st OSSL_STORE_CTX;
+
+ typedef OSSL_STORE_INFO *(*OSSL_STORE_post_process_info_fn)(OSSL_STORE_INFO *,
+                                                             void *);
+
+ OSSL_STORE_CTX *OSSL_STORE_open(const char *uri, const UI_METHOD *ui_method,
+                                 void *ui_data,
+                                 OSSL_STORE_post_process_info_fn post_process,
+                                 void *post_process_data);
+ int OSSL_STORE_ctrl(OSSL_STORE_CTX *ctx, int cmd, ... /* args */);
+ OSSL_STORE_INFO *OSSL_STORE_load(OSSL_STORE_CTX *ctx);
+ int OSSL_STORE_eof(OSSL_STORE_CTX *ctx);
+ int OSSL_STORE_error(OSSL_STORE_CTX *ctx);
+ int OSSL_STORE_close(OSSL_STORE_CTX *ctx);
+
+=head1 DESCRIPTION
+
+These functions help the application to fetch supported objects (see
+L&lt;OSSL_STORE_INFO(3)/SUPPORTED OBJECTS&gt; for information on which those are)
+from a given URI (see L&lt;/SUPPORTED SCHEMES&gt; for more information on
+the supported URI schemes).
+The general method to do so is to &quot;open&quot; the URI using OSSL_STORE_open(),
+read each available and supported object using OSSL_STORE_load() as long as
+OSSL_STORE_eof() hasn't been reached, and finish it off with OSSL_STORE_close().
+
+The retrieved information is stored in a B&lt;OSSL_STORE_INFO&gt;, which is further
+described in L&lt;OSSL_STORE_INFO(3)&gt;.
+
+=head2 Types
+
+B&lt;OSSL_STORE_CTX&gt; is a context variable that holds all the internal
+information for OSSL_STORE_open(), OSSL_STORE_load(), OSSL_STORE_eof() and
+OSSL_STORE_close() to work together.
+
+=head2 Functions
+
+OSSL_STORE_open() takes a uri or path B&lt;uri&gt;, password UI method
+B&lt;ui_method&gt; with associated data B&lt;ui_data&gt;, and post processing
+callback B&lt;post_process&gt; with associated data B&lt;post_process_data&gt;,
+opens a channel to the data located at that URI and returns a
+B&lt;OSSL_STORE_CTX&gt; with all necessary internal information.
+The given B&lt;ui_method&gt; and B&lt;ui_data_data&gt; will be reused by all
+functions that use B&lt;OSSL_STORE_CTX&gt; when interaction is needed.
+The given B&lt;post_process&gt; and B&lt;post_process_data&gt; will be reused by
+OSSL_STORE_load() to manipulate or drop the value to be returned.
+
+OSSL_STORE_ctrl() takes a B&lt;OSSL_STORE_CTX&gt;, and command number B&lt;cmd&gt; and
+more arguments not specified here.
+The available command numbers and arguments they each take depends on
+the loader that's used and is documented together with that loader.
+
+OSSL_STORE_load() takes a B&lt;OSSL_STORE_CTX&gt;, tries to load the next available
+object and return it wrapped with  B&lt;OSSL_STORE_INFO&gt;.
+
+OSSL_STORE_eof() takes a B&lt;OSSL_STORE_CTX&gt; and checks if we've reached the end
+of data.
+
+OSSL_STORE_error() takes a B&lt;OSSL_STORE_CTX&gt; and checks if an error occured in
+the last OSSL_STORE_load() call.
+Note that it may still be meaningful to try and load more objects, unless
+OSSL_STORE_eof() shows that the end of data has been reached.
+
+OSSL_STORE_close() takes a B&lt;OSSL_STORE_CTX&gt;, closes the channel that was opened
+by OSSL_STORE_open() and frees all other information that was stored in the
+B&lt;OSSL_STORE_CTX&gt;, as well as the B&lt;OSSL_STORE_CTX&gt; itself.
+
+=head1 SUPPORTED SCHEMES
+
+The basic supported scheme is B&lt;file:&gt;.
+Any other scheme can be added dynamically, using
+OSSL_STORE_register_loader().
+
+=head1 NOTES
+
+When unsure whether a given string contains a simple file or directory
+reference, or if it's a full blown URI, the question is how to figure
+that out.
+One way is to try OSSL_STORE_open_file() and if that fails, try
+OSSL_STORE_open().
+The other way is the other way around.
+Either way you choose, there are corner cases,
+F&lt;file:/foo/bar/cookie.txt&gt; might very will be a simple file reference
+on a system that supports the notion of volumes.
+
+This manual won't tell you which way is better, that's up to each
+application developer to decide on their own.
+However, there are some tools that can be used together with
+OSSL_STORE_open() to determine if any failure is caused by an unparsable
+URI, or if it's a different error (such as memory allocation
+failures); if the URI was parsable but the scheme unregistered, the
+top error will have the reason C&lt;OSSL_STORE_R_UNREGISTERED_SCHEME&gt;.
+If you decide to use OSSL_STORE_open() with OSSL_STORE_open_file() as a
+fallback, those reasons can be good tools to decide if the fallback
+should be taken or not.
+
+=head1 RETURN VALUES
+
+OSSL_STORE_open() returns a pointer to a B&lt;OSSL_STORE_CTX&gt; on success, or
+B&lt;NULL&gt; on failure.
+
+OSSL_STORE_load() returns a pointer to a B&lt;OSSL_STORE_INFO&gt; on success, or
+B&lt;NULL&gt; on error or when end of data is reached.
+Use OSSL_STORE_error() and OSSL_STORE_eof() to determine the meaning of a
+returned B&lt;NULL&gt;.
+
+OSSL_STORE_eof() returns 1 if the end of data has been reached, otherwise
+0.
+
+OSSL_STORE_error() returns 1 if an error occured in a OSSL_STORE_load() call,
+otherwise 0.
+
+OSSL_STORE_ctrl() and OSSL_STORE_close() returns 1 on success, or 0 on failure.
+
+=head1 SEE ALSO
+
+L&lt;ossl_store(7)&gt;, L&lt;OSSL_STORE_INFO(3)&gt;, L&lt;OSSL_STORE_register_loader(3)&gt;
+
+=head1 HISTORY
+
+OSSL_STORE_CTX(), OSSL_STORE_post_process_info_fn(), OSSL_STORE_open(),
+OSSL_STORE_ctrl(), OSSL_STORE_load(), OSSL_STORE_eof() and OSSL_STORE_close()
+were added to OpenSSL 1.1.1.
+
+=head1 COPYRIGHT
+
+Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man7/ossl_store.pod b/doc/man7/ossl_store.pod
new file mode 100644
index 0000000..b4b76dd
--- /dev/null
+++ b/doc/man7/ossl_store.pod
@@ -0,0 +1,103 @@
+=pod
+
+=head1 NAME
+
+ossl_store - Store retrieval functions
+
+=head1 SYNOPSIS
+
+=for comment generic
+
+#include &lt;openssl/store.h&gt;
+
+=head1 DESCRIPTION
+
+=head2 General
+
+A STORE is a layer of functionality to retrieve a number of supported
+objects from a repository of any kind, addressable as a file name or
+as a URI.
+
+The functionality supports the pattern &quot;open a channel to the
+repository&quot;, &quot;loop and retrieve one object at a time&quot;, and &quot;finish up
+by closing the channel&quot;.
+
+The retrieved objects are returned as a wrapper type B&lt;OSSL_STORE_INFO&gt;,
+from which an OpenSSL type can be retrieved.
+
+=head2 URI schemes and loaders
+
+Support for a URI scheme is called a STORE &quot;loader&quot;, and can be added
+dynamically from the calling application or from a loadable engine.
+
+=head2 The 'file' scheme
+
+Support for the 'file' scheme is already built into C&lt;libcrypto&gt;.
+Since files come in all kinds of formats and content types, the 'file'
+scheme has its own layer of functionality called &quot;file handlers&quot;,
+which are used to try to decode diverse types of file contents.
+
+In case a file is formatted as PEM, each called file handler receives
+the PEM name (everything following any 'C&lt;-----BEGIN &gt;') as well as
+possible PEM headers, together with the decoded PEM body.  Since PEM
+formatted files can contain more than one object, the file handlers
+are called upon for each such object.
+
+If the file isn't determined to be formatted as PEM, the content is
+loaded in raw form in its entirety and passed to the available file
+handlers as is, with no PEM name or headers.
+
+Each file handler is expected to handle PEM and non-PEM content as
+appropriate.  Some may refuse non-PEM content for the sake of
+determinism (for example, there are keys out in the wild that are
+represented as an ASN.1 OCTET STRING.  In raw form, it's not easily
+possible to distinguish those from any other data coming as an ASN.1
+OCTET STRING, so such keys would naturally be accepted as PEM files
+only).
+
+=head1 EXAMPLES
+
+=head2 A generic call
+
+ /*
+  * There is also a OSSL_STORE_open_file() that can be used for file paths
+  * that can't be represented as URIs, such as Windows backslashes
+  */
+ OSSL_STORE_CTX *ctx = OSSL_STORE_open(&quot;file:/foo/bar/data.pem&quot;);
+
+ /*
+  * OSSL_STORE_eof() simulates file semantics for any repository to signal
+  * that no more data can be expected
+  */ 
+ while (!OSSL_STORE_eof(ctx)) {
+     OSSL_STORE_INFO *info = OSSL_STORE_load(ctx);
+
+     /*
+      * Do whatever is necessary with the OSSL_STORE_INFO,
+      * here just one example
+      */
+     switch (OSSL_STORE_INFO_get_type(info)) {
+     case OSSL_STORE_INFO_X509:
+         /* Print the X.509 certificate text */
+         X509_print_fp(stdout, OSSL_STORE_INFO_get0_CERT(info));
+         /* Print the X.509 certificate PEM output */
+         PEM_write_X509(stdout, OSSL_STORE_INFO_get0_CERT(info));
+         break;
+     }
+ }
+
+ OSSL_STORE_close(ctx);
+
+=head1 SEE ALSO
+L&lt;OSSL_STORE_open(3)&gt;, L&lt;OSSL_STORE_INFO(3)&gt;, L&lt;OSSL_STORE_LOADER(3)&gt;
+
+=head1 COPYRIGHT
+
+Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/include/openssl/bio.h b/include/openssl/bio.h
index 5f8f83a..75aa884 100644
--- a/include/openssl/bio.h
+++ b/include/openssl/bio.h
@@ -88,6 +88,7 @@ extern &quot;C&quot; {
 # define BIO_CTRL_SET_CALLBACK   14/* opt - set callback function */
 # define BIO_CTRL_GET_CALLBACK   15/* opt - set callback function */
 
+# define BIO_CTRL_PEEK           29/* BIO_f_buffer special */
 # define BIO_CTRL_SET_FILENAME   30/* BIO_s_file special */
 
 /* dgram BIO stuff */
@@ -494,6 +495,7 @@ size_t BIO_ctrl_wpending(BIO *b);
 
 /* For the BIO_f_buffer() type */
 # define BIO_buffer_get_num_lines(b) BIO_ctrl(b,BIO_CTRL_GET,0,NULL)
+# define BIO_buffer_peek(b,s,l) BIO_ctrl(b,BIO_CTRL_PEEK,(l),(s))
 
 /* For BIO_s_bio() */
 # define BIO_set_write_buf_size(b,size) (int)BIO_ctrl(b,BIO_C_SET_WRITE_BUF_SIZE,size,NULL)
diff --git a/include/openssl/err.h b/include/openssl/err.h
index e60640b..d518d60 100644
--- a/include/openssl/err.h
+++ b/include/openssl/err.h
@@ -84,7 +84,7 @@ typedef struct err_state_st {
 # define ERR_LIB_COMP            41
 # define ERR_LIB_ECDSA           42
 # define ERR_LIB_ECDH            43
-# define ERR_LIB_STORE           44
+# define ERR_LIB_OSSL_STORE      44
 # define ERR_LIB_FIPS            45
 # define ERR_LIB_CMS             46
 # define ERR_LIB_TS              47
@@ -123,7 +123,7 @@ typedef struct err_state_st {
 # define COMPerr(f,r) ERR_PUT_error(ERR_LIB_COMP,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 # define ECDSAerr(f,r)  ERR_PUT_error(ERR_LIB_ECDSA,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 # define ECDHerr(f,r)  ERR_PUT_error(ERR_LIB_ECDH,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
-# define STOREerr(f,r) ERR_PUT_error(ERR_LIB_STORE,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
+# define OSSL_STOREerr(f,r) ERR_PUT_error(ERR_LIB_OSSL_STORE,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 # define FIPSerr(f,r) ERR_PUT_error(ERR_LIB_FIPS,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 # define CMSerr(f,r) ERR_PUT_error(ERR_LIB_CMS,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 # define TSerr(f,r) ERR_PUT_error(ERR_LIB_TS,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
@@ -131,6 +131,7 @@ typedef struct err_state_st {
 # define CTerr(f,r) ERR_PUT_error(ERR_LIB_CT,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 # define ASYNCerr(f,r) ERR_PUT_error(ERR_LIB_ASYNC,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 # define KDFerr(f,r) ERR_PUT_error(ERR_LIB_KDF,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
+# define OSSL_STOREerr(f,r) ERR_PUT_error(ERR_LIB_OSSL_STORE,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 
 # define ERR_PACK(l,f,r) ( \
         (((unsigned int)(l) &amp; 0x0FF) &lt;&lt; 24L) | \
@@ -163,6 +164,7 @@ typedef struct err_state_st {
 # define SYS_F_OPEN              19
 # define SYS_F_CLOSE             20
 # define SYS_F_IOCTL             21
+# define SYS_F_STAT              22
 
 /* reasons */
 # define ERR_R_SYS_LIB   ERR_LIB_SYS/* 2 */
@@ -181,7 +183,9 @@ typedef struct err_state_st {
 # define ERR_R_PKCS7_LIB ERR_LIB_PKCS7/* 33 */
 # define ERR_R_X509V3_LIB ERR_LIB_X509V3/* 34 */
 # define ERR_R_ENGINE_LIB ERR_LIB_ENGINE/* 38 */
+# define ERR_R_UI_LIB    ERR_LIB_UI/* 40 */
 # define ERR_R_ECDSA_LIB ERR_LIB_ECDSA/* 42 */
+# define ERR_R_OSSL_STORE_LIB ERR_LIB_OSSL_STORE/* 44 */
 
 # define ERR_R_NESTED_ASN1_ERROR                 58
 # define ERR_R_MISSING_ASN1_EOS                  63
diff --git a/include/openssl/ossl_typ.h b/include/openssl/ossl_typ.h
index deea038..173a42d 100644
--- a/include/openssl/ossl_typ.h
+++ b/include/openssl/ossl_typ.h
@@ -171,6 +171,8 @@ typedef struct ctlog_st CTLOG;
 typedef struct ctlog_store_st CTLOG_STORE;
 typedef struct ct_policy_eval_ctx_st CT_POLICY_EVAL_CTX;
 
+typedef struct ossl_store_info_st OSSL_STORE_INFO;
+
 #if defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L &amp;&amp; \
     defined(INTMAX_MAX) &amp;&amp; defined(UINTMAX_MAX)
 typedef intmax_t ossl_intmax_t;
diff --git a/include/openssl/store.h b/include/openssl/store.h
new file mode 100644
index 0000000..d3947df
--- /dev/null
+++ b/include/openssl/store.h
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2016-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef HEADER_OSSL_STORE_H
+# define HEADER_OSSL_STORE_H
+
+# include &lt;stdarg.h&gt;
+# include &lt;openssl/ossl_typ.h&gt;
+# include &lt;openssl/pem.h&gt;
+# include &lt;openssl/storeerr.h&gt;
+
+# ifdef  __cplusplus
+extern &quot;C&quot; {
+# endif
+
+/*-
+ *  The main OSSL_STORE functions.
+ *  ------------------------------
+ *
+ *  These allow applications to open a channel to a resource with supported
+ *  data (keys, certs, crls, ...), read the data a piece at a time and decide
+ *  what to do with it, and finally close.
+ */
+
+typedef struct ossl_store_ctx_st OSSL_STORE_CTX;
+
+/*
+ * Typedef for the OSSL_STORE_INFO post processing callback.  This can be used
+ * to massage the given OSSL_STORE_INFO, or to drop it entirely (by returning
+ * NULL).
+ */
+typedef OSSL_STORE_INFO *(*OSSL_STORE_post_process_info_fn)(OSSL_STORE_INFO *,
+                                                            void *);
+
+/*
+ * Open a channel given a URI.  The given UI method will be used any time the
+ * loader needs extra input, for example when a password or pin is needed, and
+ * will be passed the same user data every time it's needed in this context.
+ *
+ * Returns a context reference which represents the channel to communicate
+ * through.
+ */
+OSSL_STORE_CTX *OSSL_STORE_open(const char *uri, const UI_METHOD *ui_method,
+                                void *ui_data,
+                                OSSL_STORE_post_process_info_fn post_process,
+                                void *post_process_data);
+
+/*
+ * Control / fine tune the OSSL_STORE channel.  |cmd| determines what is to be
+ * done, and depends on the underlying loader (use OSSL_STORE_get0_scheme to
+ * determine which loader is used), except for common commands (see below).
+ * Each command takes different arguments.
+ */
+int OSSL_STORE_ctrl(OSSL_STORE_CTX *ctx, int cmd, ... /* args */);
+
+/*
+ * Common ctrl commands that different loaders may choose to support.
+ */
+/* Where custom commands start */
+# define OSSL_STORE_C_CUSTOM_START    100
+
+/*
+ * Read one data item (a key, a cert, a CRL) that is supported by the OSSL_STORE
+ * functionality, given a context.
+ * Returns a OSSL_STORE_INFO pointer, from which OpenSSL typed data can be
+ * extracted with OSSL_STORE_INFO_get0_PKEY(), OSSL_STORE_INFO_get0_CERT(), ...
+ * NULL is returned on error, which may include that the data found at the URI
+ * can't be figured out for certain or is ambiguous.
+ */
+OSSL_STORE_INFO *OSSL_STORE_load(OSSL_STORE_CTX *ctx);
+
+/*
+ * Check if end of data (end of file) is reached
+ * Returns 1 on end, 0 otherwise.
+ */
+int OSSL_STORE_eof(OSSL_STORE_CTX *ctx);
+
+/*
+ * Check if an error occured
+ * Returns 1 if it did, 0 otherwise.
+ */
+int OSSL_STORE_error(OSSL_STORE_CTX *ctx);
+
+/*
+ * Close the channel
+ * Returns 1 on success, 0 on error.
+ */
+int OSSL_STORE_close(OSSL_STORE_CTX *ctx);
+
+
+/*-
+ *  Extracting OpenSSL types from and creating new OSSL_STORE_INFOs
+ *  ---------------------------------------------------------------
+ */
+
+/*
+ * Types of data that can be ossl_stored in a OSSL_STORE_INFO.
+ * OSSL_STORE_INFO_NAME is typically found when getting a listing of
+ * available &quot;files&quot; / &quot;tokens&quot; / what have you.
+ */
+# define OSSL_STORE_INFO_NAME           1   /* char * */
+# define OSSL_STORE_INFO_PARAMS         2   /* EVP_PKEY * */
+# define OSSL_STORE_INFO_PKEY           3   /* EVP_PKEY * */
+# define OSSL_STORE_INFO_CERT           4   /* X509 * */
+# define OSSL_STORE_INFO_CRL            5   /* X509_CRL * */
+
+/*
+ * Functions to generate OSSL_STORE_INFOs, one function for each type we
+ * support having in them.  Along with each of them, one macro that
+ * can be used to determine what types are supported.
+ *
+ * In all cases, ownership of the object is transfered to the OSSL_STORE_INFO
+ * and will therefore be freed when the OSSL_STORE_INFO is freed.
+ */
+OSSL_STORE_INFO *OSSL_STORE_INFO_new_NAME(char *name);
+int OSSL_STORE_INFO_set0_NAME_description(OSSL_STORE_INFO *info, char *desc);
+OSSL_STORE_INFO *OSSL_STORE_INFO_new_PARAMS(EVP_PKEY *params);
+OSSL_STORE_INFO *OSSL_STORE_INFO_new_PKEY(EVP_PKEY *pkey);
+OSSL_STORE_INFO *OSSL_STORE_INFO_new_CERT(X509 *x509);
+OSSL_STORE_INFO *OSSL_STORE_INFO_new_CRL(X509_CRL *crl);
+
+/*
+ * Functions to try to extract data from a OSSL_STORE_INFO.
+ */
+int OSSL_STORE_INFO_get_type(const OSSL_STORE_INFO *info);
+const char *OSSL_STORE_INFO_get0_NAME(const OSSL_STORE_INFO *info);
+char *OSSL_STORE_INFO_get1_NAME(const OSSL_STORE_INFO *info);
+const char *OSSL_STORE_INFO_get0_NAME_description(const OSSL_STORE_INFO *info);
+char *OSSL_STORE_INFO_get1_NAME_description(const OSSL_STORE_INFO *info);
+EVP_PKEY *OSSL_STORE_INFO_get0_PARAMS(const OSSL_STORE_INFO *info);
+EVP_PKEY *OSSL_STORE_INFO_get1_PARAMS(const OSSL_STORE_INFO *info);
+EVP_PKEY *OSSL_STORE_INFO_get0_PKEY(const OSSL_STORE_INFO *info);
+EVP_PKEY *OSSL_STORE_INFO_get1_PKEY(const OSSL_STORE_INFO *info);
+X509 *OSSL_STORE_INFO_get0_CERT(const OSSL_STORE_INFO *info);
+X509 *OSSL_STORE_INFO_get1_CERT(const OSSL_STORE_INFO *info);
+X509_CRL *OSSL_STORE_INFO_get0_CRL(const OSSL_STORE_INFO *info);
+X509_CRL *OSSL_STORE_INFO_get1_CRL(const OSSL_STORE_INFO *info);
+
+const char *OSSL_STORE_INFO_type_string(int type);
+
+/*
+ * Free the OSSL_STORE_INFO
+ */
+void OSSL_STORE_INFO_free(OSSL_STORE_INFO *info);
+
+
+/*-
+ *  Function to register a loader for the given URI scheme.
+ *  -------------------------------------------------------
+ *
+ *  The loader receives all the main components of an URI except for the
+ *  scheme.
+ */
+
+typedef struct ossl_store_loader_st OSSL_STORE_LOADER;
+OSSL_STORE_LOADER *OSSL_STORE_LOADER_new(ENGINE *e, const char *scheme);
+const ENGINE *OSSL_STORE_LOADER_get0_engine(const OSSL_STORE_LOADER *loader);
+const char *OSSL_STORE_LOADER_get0_scheme(const OSSL_STORE_LOADER *loader);
+/* struct ossl_store_loader_ctx_st is defined differently by each loader */
+typedef struct ossl_store_loader_ctx_st OSSL_STORE_LOADER_CTX;
+typedef OSSL_STORE_LOADER_CTX *(*OSSL_STORE_open_fn)(const OSSL_STORE_LOADER
+                                                     *loader,
+                                                     const char *uri,
+                                                     const UI_METHOD *ui_method,
+                                                     void *ui_data);
+int OSSL_STORE_LOADER_set_open(OSSL_STORE_LOADER *loader,
+                               OSSL_STORE_open_fn open_function);
+typedef int (*OSSL_STORE_ctrl_fn)(OSSL_STORE_LOADER_CTX *ctx, int cmd,
+                                  va_list args);
+int OSSL_STORE_LOADER_set_ctrl(OSSL_STORE_LOADER *loader,
+                               OSSL_STORE_ctrl_fn ctrl_function);
+typedef OSSL_STORE_INFO *(*OSSL_STORE_load_fn)(OSSL_STORE_LOADER_CTX *ctx,
+                                               const UI_METHOD *ui_method,
+                                               void *ui_data);
+int OSSL_STORE_LOADER_set_load(OSSL_STORE_LOADER *loader,
+                               OSSL_STORE_load_fn load_function);
+typedef int (*OSSL_STORE_eof_fn)(OSSL_STORE_LOADER_CTX *ctx);
+int OSSL_STORE_LOADER_set_eof(OSSL_STORE_LOADER *loader,
+                              OSSL_STORE_eof_fn eof_function);
+typedef int (*OSSL_STORE_error_fn)(OSSL_STORE_LOADER_CTX *ctx);
+int OSSL_STORE_LOADER_set_error(OSSL_STORE_LOADER *loader,
+                                OSSL_STORE_error_fn error_function);
+typedef int (*OSSL_STORE_close_fn)(OSSL_STORE_LOADER_CTX *ctx);
+int OSSL_STORE_LOADER_set_close(OSSL_STORE_LOADER *loader,
+                                OSSL_STORE_close_fn close_function);
+void OSSL_STORE_LOADER_free(OSSL_STORE_LOADER *loader);
+
+int OSSL_STORE_register_loader(OSSL_STORE_LOADER *loader);
+OSSL_STORE_LOADER *OSSL_STORE_unregister_loader(const char *scheme);
+
+/*-
+ *  Functions to list STORE loaders
+ *  -------------------------------
+ */
+int OSSL_STORE_do_all_loaders(void (*do_function) (const OSSL_STORE_LOADER
+                                                   *loader, void *do_arg),
+                              void *do_arg);
+
+
+/*
+ * Error strings
+ */
+int ERR_load_OSSL_STORE_strings(void);
+
+# ifdef  __cplusplus
+}
+# endif
+#endif
diff --git a/include/openssl/storeerr.h b/include/openssl/storeerr.h
new file mode 100644
index 0000000..1e0d23c
--- /dev/null
+++ b/include/openssl/storeerr.h
@@ -0,0 +1,74 @@
+/*
+ * Generated by util/mkerr.pl DO NOT EDIT
+ * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef HEADER_OSSL_STOREERR_H
+# define HEADER_OSSL_STOREERR_H
+
+# ifdef  __cplusplus
+extern &quot;C&quot; {
+# endif
+int ERR_load_OSSL_STORE_strings(void);
+# ifdef  __cplusplus
+}
+# endif
+
+/*
+ * OSSL_STORE function codes.
+ */
+# define OSSL_STORE_F_FILE_GET_PASS                       118
+# define OSSL_STORE_F_FILE_LOAD                           119
+# define OSSL_STORE_F_FILE_LOAD_TRY_DECODE                124
+# define OSSL_STORE_F_FILE_NAME_TO_URI                    126
+# define OSSL_STORE_F_FILE_OPEN                           120
+# define OSSL_STORE_F_OSSL_STORE_GET0_LOADER_INT          100
+# define OSSL_STORE_F_OSSL_STORE_INFO_GET1_CERT           101
+# define OSSL_STORE_F_OSSL_STORE_INFO_GET1_CRL            102
+# define OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME           103
+# define OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME_DESCRIPTION 135
+# define OSSL_STORE_F_OSSL_STORE_INFO_GET1_PARAMS         104
+# define OSSL_STORE_F_OSSL_STORE_INFO_GET1_PKEY           105
+# define OSSL_STORE_F_OSSL_STORE_INFO_NEW_CERT            106
+# define OSSL_STORE_F_OSSL_STORE_INFO_NEW_CRL             107
+# define OSSL_STORE_F_OSSL_STORE_INFO_NEW_EMBEDDED        123
+# define OSSL_STORE_F_OSSL_STORE_INFO_NEW_NAME            109
+# define OSSL_STORE_F_OSSL_STORE_INFO_NEW_PARAMS          110
+# define OSSL_STORE_F_OSSL_STORE_INFO_NEW_PKEY            111
+# define OSSL_STORE_F_OSSL_STORE_INFO_SET0_NAME_DESCRIPTION 134
+# define OSSL_STORE_F_OSSL_STORE_INIT_ONCE                112
+# define OSSL_STORE_F_OSSL_STORE_LOADER_NEW               113
+# define OSSL_STORE_F_OSSL_STORE_OPEN                     114
+# define OSSL_STORE_F_OSSL_STORE_OPEN_INT                 115
+# define OSSL_STORE_F_OSSL_STORE_REGISTER_LOADER_INT      117
+# define OSSL_STORE_F_OSSL_STORE_UNREGISTER_LOADER_INT    116
+# define OSSL_STORE_F_TRY_DECODE_PARAMS                   121
+# define OSSL_STORE_F_TRY_DECODE_PKCS12                   122
+# define OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED           125
+
+/*
+ * OSSL_STORE reason codes.
+ */
+# define OSSL_STORE_R_AMBIGUOUS_CONTENT_TYPE              107
+# define OSSL_STORE_R_BAD_PASSWORD_READ                   115
+# define OSSL_STORE_R_ERROR_VERIFYING_PKCS12_MAC          113
+# define OSSL_STORE_R_INVALID_SCHEME                      106
+# define OSSL_STORE_R_IS_NOT_A                            112
+# define OSSL_STORE_R_NOT_A_CERTIFICATE                   100
+# define OSSL_STORE_R_NOT_A_CRL                           101
+# define OSSL_STORE_R_NOT_A_KEY                           102
+# define OSSL_STORE_R_NOT_A_NAME                          103
+# define OSSL_STORE_R_NOT_PARAMETERS                      104
+# define OSSL_STORE_R_PASSPHRASE_CALLBACK_ERROR           114
+# define OSSL_STORE_R_PATH_MUST_BE_ABSOLUTE               108
+# define OSSL_STORE_R_UI_PROCESS_INTERRUPTED_OR_CANCELLED 109
+# define OSSL_STORE_R_UNREGISTERED_SCHEME                 105
+# define OSSL_STORE_R_UNSUPPORTED_CONTENT_TYPE            110
+# define OSSL_STORE_R_URI_AUTHORITY_UNSUPPORED            111
+
+#endif
diff --git a/test/recipes/90-test_store.t b/test/recipes/90-test_store.t
new file mode 100644
index 0000000..65cf9fb
--- /dev/null
+++ b/test/recipes/90-test_store.t
@@ -0,0 +1,349 @@
+#! /usr/bin/env perl
+# Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+use File::Spec;
+use MIME::Base64;
+use OpenSSL::Test qw(:DEFAULT srctop_file srctop_dir bldtop_file data_file);
+
+my $test_name = &quot;test_store&quot;;
+setup($test_name);
+
+my @noexist_files =
+    ( &quot;test/blahdiblah.pem&quot;,
+      &quot;test/blahdibleh.der&quot; );
+my @src_files =
+    ( &quot;test/testx509.pem&quot;,
+      &quot;test/testrsa.pem&quot;,
+      &quot;test/testrsapub.pem&quot;,
+      &quot;test/testcrl.pem&quot;,
+      &quot;apps/server.pem&quot; );
+my @generated_files =
+    (
+     ### generated from the source files
+
+     &quot;testx509.der&quot;,
+     &quot;testrsa.der&quot;,
+     &quot;testrsapub.der&quot;,
+     &quot;testcrl.der&quot;,
+
+     ### generated locally
+
+     &quot;rsa-key-pkcs1.pem&quot;, &quot;rsa-key-pkcs1.der&quot;,
+     &quot;rsa-key-pkcs1-aes128.pem&quot;,
+     &quot;rsa-key-pkcs8.pem&quot;, &quot;rsa-key-pkcs8.der&quot;,
+     &quot;rsa-key-pkcs8-pbes1-sha1-3des.pem&quot;, &quot;rsa-key-pkcs8-pbes1-sha1-3des.der&quot;,
+     &quot;rsa-key-pkcs8-pbes2-sha1.pem&quot;, &quot;rsa-key-pkcs8-pbes2-sha1.der&quot;,
+     &quot;rsa-key-sha1-3des-sha1.p12&quot;, &quot;rsa-key-sha1-3des-sha256.p12&quot;,
+     &quot;rsa-key-aes256-cbc-sha256.p12&quot;,
+     &quot;rsa-key-md5-des-sha1.p12&quot;,
+     &quot;rsa-key-aes256-cbc-md5-des-sha256.p12&quot;,
+     &quot;rsa-key-pkcs8-pbes2-sha256.pem&quot;, &quot;rsa-key-pkcs8-pbes2-sha256.der&quot;,
+     &quot;rsa-key-pkcs8-pbes1-md5-des.pem&quot;, &quot;rsa-key-pkcs8-pbes1-md5-des.der&quot;,
+     &quot;dsa-key-pkcs1.pem&quot;, &quot;dsa-key-pkcs1.der&quot;,
+     &quot;dsa-key-pkcs1-aes128.pem&quot;,
+     &quot;dsa-key-pkcs8.pem&quot;, &quot;dsa-key-pkcs8.der&quot;,
+     &quot;dsa-key-pkcs8-pbes2-sha1.pem&quot;, &quot;dsa-key-pkcs8-pbes2-sha1.der&quot;,
+     &quot;dsa-key-aes256-cbc-sha256.p12&quot;,
+     &quot;ec-key-pkcs1.pem&quot;, &quot;ec-key-pkcs1.der&quot;,
+     &quot;ec-key-pkcs1-aes128.pem&quot;,
+     &quot;ec-key-pkcs8.pem&quot;, &quot;ec-key-pkcs8.der&quot;,
+     &quot;ec-key-pkcs8-pbes2-sha1.pem&quot;, &quot;ec-key-pkcs8-pbes2-sha1.der&quot;,
+     &quot;ec-key-aes256-cbc-sha256.p12&quot;,
+    );
+
+my $n = (2 * scalar @noexist_files)
+    + (5 * scalar @src_files)
+    + (3 * scalar @generated_files)
+    + 2;
+
+plan tests =&gt; $n;
+
+indir &quot;store_$$&quot; =&gt; sub {
+ SKIP:
+    {
+        skip &quot;failed initialisation&quot;, $n unless init();
+
+        foreach (@noexist_files) {
+            my $file = srctop_file($_);
+            ok(!run(app([&quot;openssl&quot;, &quot;storeutl&quot;, $file])));
+            ok(!run(app([&quot;openssl&quot;, &quot;storeutl&quot;, to_file_uri($file)])));
+        }
+        foreach (@src_files) {
+            my $file = srctop_file($_);
+            ok(run(app([&quot;openssl&quot;, &quot;storeutl&quot;, $file])));
+            ok(run(app([&quot;openssl&quot;, &quot;storeutl&quot;, to_file_uri($file)])));
+            ok(run(app([&quot;openssl&quot;, &quot;storeutl&quot;, to_file_uri($file, 0,
+                                                           &quot;&quot;)])));
+            ok(run(app([&quot;openssl&quot;, &quot;storeutl&quot;, to_file_uri($file, 0,
+                                                           &quot;localhost&quot;)])));
+            ok(!run(app([&quot;openssl&quot;, &quot;storeutl&quot;, to_file_uri($file, 0,
+                                                            &quot;dummy&quot;)])));
+        }
+        foreach (@generated_files) {
+            ok(run(app([&quot;openssl&quot;, &quot;storeutl&quot;, &quot;-passin&quot;, &quot;pass:password&quot;,
+                        $_])));
+            ok(run(app([&quot;openssl&quot;, &quot;storeutl&quot;, &quot;-passin&quot;, &quot;pass:password&quot;,
+                        to_file_uri($_)])));
+            ok(!run(app([&quot;openssl&quot;, &quot;storeutl&quot;, &quot;-passin&quot;, &quot;pass:password&quot;,
+                         to_rel_file_uri($_)])));
+        }
+        {
+            my $dir = srctop_dir(&quot;test&quot;, &quot;certs&quot;);
+            ok(run(app([&quot;openssl&quot;, &quot;storeutl&quot;, $dir])));
+            ok(run(app([&quot;openssl&quot;, &quot;storeutl&quot;, to_file_uri($dir, 1)])));
+        }
+    }
+}, create =&gt; 1, cleanup =&gt; 1;
+
+sub init {
+    return (
+            # rsa-key-pkcs1.pem
+            run(app([&quot;openssl&quot;, &quot;genrsa&quot;,
+                     &quot;-out&quot;, &quot;rsa-key-pkcs1.pem&quot;, &quot;2432&quot;]))
+            # dsa-key-pkcs1.pem
+            &amp;&amp; run(app([&quot;openssl&quot;, &quot;dsaparam&quot;, &quot;-genkey&quot;,
+                        &quot;-out&quot;, &quot;dsa-key-pkcs1.pem&quot;, &quot;1024&quot;]))
+            # ec-key-pkcs1.pem (one might think that 'genec' would be practical)
+            &amp;&amp; run(app([&quot;openssl&quot;, &quot;ecparam&quot;, &quot;-genkey&quot;, &quot;-name&quot;, &quot;prime256v1&quot;,
+                        &quot;-out&quot;, &quot;ec-key-pkcs1.pem&quot;]))
+            # rsa-key-pkcs1-aes128.pem
+            &amp;&amp; run(app([&quot;openssl&quot;, &quot;rsa&quot;, &quot;-passout&quot;, &quot;pass:password&quot;, &quot;-aes128&quot;,
+                        &quot;-in&quot;, &quot;rsa-key-pkcs1.pem&quot;,
+                        &quot;-out&quot;, &quot;rsa-key-pkcs1-aes128.pem&quot;]))
+            # dsa-key-pkcs1-aes128.pem
+            &amp;&amp; run(app([&quot;openssl&quot;, &quot;dsa&quot;, &quot;-passout&quot;, &quot;pass:password&quot;, &quot;-aes128&quot;,
+                        &quot;-in&quot;, &quot;dsa-key-pkcs1.pem&quot;,
+                        &quot;-out&quot;, &quot;dsa-key-pkcs1-aes128.pem&quot;]))
+            # ec-key-pkcs1-aes128.pem
+            &amp;&amp; run(app([&quot;openssl&quot;, &quot;ec&quot;, &quot;-passout&quot;, &quot;pass:password&quot;, &quot;-aes128&quot;,
+                        &quot;-in&quot;, &quot;ec-key-pkcs1.pem&quot;,
+                        &quot;-out&quot;, &quot;ec-key-pkcs1-aes128.pem&quot;]))
+            # *-key-pkcs8.pem
+            &amp;&amp; runall(sub {
+                          my $dstfile = shift;
+                          (my $srcfile = $dstfile)
+                              =~ s/-key-pkcs8\.pem$/-key-pkcs1.pem/i;
+                          run(app([&quot;openssl&quot;, &quot;pkcs8&quot;, &quot;-topk8&quot;, &quot;-nocrypt&quot;,
+                                   &quot;-in&quot;, $srcfile, &quot;-out&quot;, $dstfile]));
+                      }, grep(/-key-pkcs8\.pem$/, @generated_files))
+            # *-key-pkcs8-pbes1-sha1-3des.pem
+            &amp;&amp; runall(sub {
+                          my $dstfile = shift;
+                          (my $srcfile = $dstfile)
+                              =~ s/-key-pkcs8-pbes1-sha1-3des\.pem$
+                                  /-key-pkcs8.pem/ix;
+                          run(app([&quot;openssl&quot;, &quot;pkcs8&quot;, &quot;-topk8&quot;,
+                                   &quot;-passout&quot;, &quot;pass:password&quot;,
+                                   &quot;-v1&quot;, &quot;pbeWithSHA1And3-KeyTripleDES-CBC&quot;,
+                                   &quot;-in&quot;, $srcfile, &quot;-out&quot;, $dstfile]));
+                      }, grep(/-key-pkcs8-pbes1-sha1-3des\.pem$/, @generated_files))
+            # *-key-pkcs8-pbes1-md5-des.pem
+            &amp;&amp; runall(sub {
+                          my $dstfile = shift;
+                          (my $srcfile = $dstfile)
+                              =~ s/-key-pkcs8-pbes1-md5-des\.pem$
+                                  /-key-pkcs8.pem/ix;
+                          run(app([&quot;openssl&quot;, &quot;pkcs8&quot;, &quot;-topk8&quot;,
+                                   &quot;-passout&quot;, &quot;pass:password&quot;,
+                                   &quot;-v1&quot;, &quot;pbeWithSHA1And3-KeyTripleDES-CBC&quot;,
+                                   &quot;-in&quot;, $srcfile, &quot;-out&quot;, $dstfile]));
+                      }, grep(/-key-pkcs8-pbes1-md5-des\.pem$/, @generated_files))
+            # *-key-pkcs8-pbes2-sha1.pem
+            &amp;&amp; runall(sub {
+                          my $dstfile = shift;
+                          (my $srcfile = $dstfile)
+                              =~ s/-key-pkcs8-pbes2-sha1\.pem$
+                                  /-key-pkcs8.pem/ix;
+                          run(app([&quot;openssl&quot;, &quot;pkcs8&quot;, &quot;-topk8&quot;,
+                                   &quot;-passout&quot;, &quot;pass:password&quot;,
+                                   &quot;-v2&quot;, &quot;aes256&quot;, &quot;-v2prf&quot;, &quot;hmacWithSHA1&quot;,
+                                   &quot;-in&quot;, $srcfile, &quot;-out&quot;, $dstfile]));
+                      }, grep(/-key-pkcs8-pbes2-sha1\.pem$/, @generated_files))
+            # *-key-pkcs8-pbes2-sha1.pem
+            &amp;&amp; runall(sub {
+                          my $dstfile = shift;
+                          (my $srcfile = $dstfile)
+                              =~ s/-key-pkcs8-pbes2-sha256\.pem$
+                                  /-key-pkcs8.pem/ix;
+                          run(app([&quot;openssl&quot;, &quot;pkcs8&quot;, &quot;-topk8&quot;,
+                                   &quot;-passout&quot;, &quot;pass:password&quot;,
+                                   &quot;-v2&quot;, &quot;aes256&quot;, &quot;-v2prf&quot;, &quot;hmacWithSHA256&quot;,
+                                   &quot;-in&quot;, $srcfile, &quot;-out&quot;, $dstfile]));
+                      }, grep(/-key-pkcs8-pbes2-sha256\.pem$/, @generated_files))
+            # *-cert.pem (intermediary for the .p12 inits)
+            &amp;&amp; run(app([&quot;openssl&quot;, &quot;req&quot;, &quot;-x509&quot;,
+                        &quot;-config&quot;, data_file(&quot;ca.cnf&quot;), &quot;-nodes&quot;,
+                        &quot;-out&quot;, &quot;cacert.pem&quot;, &quot;-keyout&quot;, &quot;cakey.pem&quot;]))
+            &amp;&amp; runall(sub {
+                          my $srckey = shift;
+                          (my $dstfile = $srckey) =~ s|-key-pkcs8\.|-cert.|;
+                          (my $csr = $dstfile) =~ s|\.pem|.csr|;
+
+                          (run(app([&quot;openssl&quot;, &quot;req&quot;, &quot;-new&quot;,
+                                    &quot;-config&quot;, data_file(&quot;user.cnf&quot;),
+                                    &quot;-key&quot;, $srckey, &quot;-out&quot;, $csr]))
+                           &amp;&amp;
+                           run(app([&quot;openssl&quot;, &quot;x509&quot;, &quot;-days&quot;, &quot;3650&quot;,
+                                    &quot;-CA&quot;, &quot;cacert.pem&quot;,
+                                    &quot;-CAkey&quot;, &quot;cakey.pem&quot;,
+                                    &quot;-set_serial&quot;, time(), &quot;-req&quot;,
+                                    &quot;-in&quot;, $csr, &quot;-out&quot;, $dstfile])));
+                      }, grep(/-key-pkcs8\.pem$/, @generated_files))
+            # *.p12
+            &amp;&amp; runall(sub {
+                          my $dstfile = shift;
+                          my ($type, $certpbe_index, $keypbe_index,
+                              $macalg_index) =
+                              $dstfile =~ m{^(.*)-key-(?|
+                                                # cert and key PBE are same
+                                                ()             #
+                                                ([^-]*-[^-]*)- # key &amp; cert PBE
+                                                ([^-]*)        # MACalg
+                                            |
+                                                # cert and key PBE are not same
+                                                ([^-]*-[^-]*)- # cert PBE
+                                                ([^-]*-[^-]*)- # key PBE
+                                                ([^-]*)        # MACalg
+                                            )\.}x;
+                          if (!$certpbe_index) {
+                              $certpbe_index = $keypbe_index;
+                          }
+                          my $srckey = &quot;$type-key-pkcs8.pem&quot;;
+                          my $srccert = &quot;$type-cert.pem&quot;;
+                          my %pbes =
+                              (
+                               &quot;sha1-3des&quot; =&gt; &quot;pbeWithSHA1And3-KeyTripleDES-CBC&quot;,
+                               &quot;md5-des&quot; =&gt; &quot;pbeWithMD5AndDES-CBC&quot;,
+                               &quot;aes256-cbc&quot; =&gt; &quot;AES-256-CBC&quot;,
+                              );
+                          my %macalgs =
+                              (
+                               &quot;sha1&quot; =&gt; &quot;SHA1&quot;,
+                               &quot;sha256&quot; =&gt; &quot;SHA256&quot;,
+                              );
+                          my $certpbe = $pbes{$certpbe_index};
+                          my $keypbe = $pbes{$keypbe_index};
+                          my $macalg = $macalgs{$macalg_index};
+                          if (!defined($certpbe) || !defined($keypbe)
+                              || !defined($macalg)) {
+                              print STDERR &quot;Cert PBE for $pbe_index not defined\n&quot;
+                                  unless defined $certpbe;
+                              print STDERR &quot;Key PBE for $pbe_index not defined\n&quot;
+                                  unless defined $keypbe;
+                              print STDERR &quot;MACALG for $macalg_index not defined\n&quot;
+                                  unless defined $macalg;
+                              print STDERR &quot;(destination file was $dstfile)\n&quot;;
+                              return 0;
+                          }
+                          run(app([&quot;openssl&quot;, &quot;pkcs12&quot;, &quot;-inkey&quot;, $srckey,
+                                   &quot;-in&quot;, $srccert, &quot;-passout&quot;, &quot;pass:password&quot;,
+                                   &quot;-export&quot;, &quot;-macalg&quot;, $macalg,
+                                   &quot;-certpbe&quot;, $certpbe, &quot;-keypbe&quot;, $keypbe,
+                                   &quot;-out&quot;, $dstfile]));
+                      }, grep(/\.p12/, @generated_files))
+            # *.der (the end all init)
+            &amp;&amp; runall(sub {
+                          my $dstfile = shift;
+                          (my $srcfile = $dstfile) =~ s/\.der$/.pem/i;
+                          if (! -f $srcfile) {
+                              $srcfile = srctop_file(&quot;test&quot;, $srcfile);
+                          }
+                          my $infh;
+                          unless (open $infh, $srcfile) {
+                              return 0;
+                          }
+                          my $l;
+                          while (($l = &lt;$infh&gt;) !~ /^-----BEGIN\s/
+                                 || $l =~ /^-----BEGIN.*PARAMETERS-----/) {
+                          }
+                          my $b64 = &quot;&quot;;
+                          while (($l = &lt;$infh&gt;) !~ /^-----END\s/) {
+                              $l =~ s|\R$||;
+                              $b64 .= $l unless $l =~ /:/;
+                          }
+                          close $infh;
+                          my $der = decode_base64($b64);
+                          unless (length($b64) / 4 * 3 - length($der) &lt; 3) {
+                              print STDERR &quot;Length error, &quot;,length($b64),
+                                  &quot; bytes of base64 became &quot;,length($der),
+                                  &quot; bytes of der? ($srcfile =&gt; $dstfile)\n&quot;;
+                              return 0;
+                          }
+                          my $outfh;
+                          unless (open $outfh, &quot;&gt;:raw&quot;, $dstfile) {
+                              return 0;
+                          }
+                          print $outfh $der;
+                          close $outfh;
+                          return 1;
+                      }, grep(/\.der$/, @generated_files))
+           );
+}
+
+sub runall {
+    my ($function, @items) = @_;
+
+    foreach (@items) {
+        return 0 unless $function-&gt;($_);
+    }
+    return 1;
+}
+
+# According to RFC8089, a relative file: path is invalid.  We still produce
+# them for testing purposes.
+sub to_rel_file_uri {
+    my ($file, $isdir, $authority) = @_;
+    my $vol;
+    my $dir;
+
+    die &quot;to_rel_file_uri: No file given\n&quot; if !defined($file) || $file eq '';
+
+    ($vol, $dir, $file) = File::Spec-&gt;splitpath($file, $isdir // 0);
+
+    # Make sure we have a Unix style directory.
+    $dir = join('/', File::Spec-&gt;splitdir($dir));
+    # Canonicalise it (note: it seems to be only needed on Unix)
+    while (1) {
+        my $newdir = $dir;
+        $newdir =~ s|/[^/]*[^/\.]+[^/]*/\.\./|/|g;
+        last if $newdir eq $dir;
+        $dir = $newdir;
+    }
+    # Take care of the corner cases the loop can't handle, and that $dir
+    # ends with a / unless it's empty
+    $dir =~ s|/[^/]*[^/\.]+[^/]*/\.\.$|/|;
+    $dir =~ s|^[^/]*[^/\.]+[^/]*/\.\./|/|;
+    $dir =~ s|^[^/]*[^/\.]+[^/]*/\.\.$||;
+    if ($isdir // 0) {
+        $dir =~ s|/$|| if $dir ne '/';
+    } else {
+        $dir .= '/' if $dir ne '' &amp;&amp; $dir !~ m|/$|;
+    }
+
+    # If the file system has separate volumes (at present, Windows and VMS)
+    # we need to handle them.  In URIs, they are invariably the first
+    # component of the path, which is always absolute.
+    # On VMS, user:[foo.bar] translates to /user/foo/bar
+    # On Windows, c:\Users\Foo translates to /c:/Users/Foo
+    if ($vol ne '') {
+        $vol =~ s|:||g if ($^O eq &quot;VMS&quot;);
+        $dir = '/' . $dir if $dir ne '' &amp;&amp; $dir !~ m|^/|;
+        $dir = '/' . $vol . $dir;
+    }
+    $file = $dir . $file;
+
+    return &quot;<A HREF="file://$authority$file">file://$authority$file</A>&quot; if defined $authority;
+    return &quot;file:$file&quot;;
+}
+
+sub to_file_uri {
+    my ($file, $isdir, $authority) = @_;
+
+    die &quot;to_file_uri: No file given\n&quot; if !defined($file) || $file eq '';
+    return to_rel_file_uri(File::Spec-&gt;rel2abs($file), $isdir, $authority);
+}
diff --git a/test/recipes/90-test_store_data/ca.cnf b/test/recipes/90-test_store_data/ca.cnf
new file mode 100644
index 0000000..bda6eec
--- /dev/null
+++ b/test/recipes/90-test_store_data/ca.cnf
@@ -0,0 +1,56 @@
+####################################################################
+[ req ]
+default_bits		= 2432
+default_keyfile 	= cakey.pem
+default_md	        = sha256
+distinguished_name	= req_DN
+string_mask             = utf8only
+x509_extensions         = v3_selfsign
+
+[ req_DN ]
+commonName                      = &quot;Common Name&quot;
+commonName_value              = &quot;CA&quot;
+
+[ v3_selfsign ]
+basicConstraints = critical,CA:true
+keyUsage = keyCertSign
+subjectKeyIdentifier=hash
+
+####################################################################
+[ ca ]
+default_ca      = CA_default            # The default ca section
+
+####################################################################
+[ CA_default ]
+
+dir             = ./demoCA
+certificate	= ./demoCA/cacert.pem
+serial		= ./demoCA/serial
+private_key	= ./demoCA/private/cakey.pem
+new_certs_dir   = ./demoCA/newcerts
+
+certificate     = cacert.pem
+private_key     = cakey.pem
+
+x509_extensions = v3_user
+
+name_opt        = ca_default            # Subject Name options
+cert_opt        = ca_default            # Certificate field options
+
+policy          = policy_anything
+
+[ policy_anything ]
+countryName             = optional
+stateOrProvinceName     = optional
+localityName            = optional
+organizationName        = optional
+organizationalUnitName  = optional
+commonName              = supplied
+emailAddress            = optional
+
+[ v3_user ]
+basicConstraints=critical,CA:FALSE
+subjectKeyIdentifier=hash
+authorityKeyIdentifier=keyid,issuer
+issuerAltName=issuer:copy
+
diff --git a/test/recipes/90-test_store_data/user.cnf b/test/recipes/90-test_store_data/user.cnf
new file mode 100644
index 0000000..91f7969
--- /dev/null
+++ b/test/recipes/90-test_store_data/user.cnf
@@ -0,0 +1,19 @@
+####################################################################
+[ req ]
+default_bits            = 2432
+default_md	        = sha256
+distinguished_name	= req_DN
+string_mask = utf8only
+
+req_extensions = v3_req # The extensions to add to a certificate request
+
+[ req_DN ]
+commonName                      = &quot;Common Name&quot;
+commonName_value              = &quot;A user&quot;
+userId = &quot;User ID&quot;
+userId_value = &quot;test&quot;
+
+[ v3_req ]
+extendedKeyUsage = clientAuth
+subjectKeyIdentifier = hash
+basicConstraints = CA:false
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 523a281..d734461 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4300,3 +4300,45 @@ ERR_load_strings_const                  4242	1_1_1	EXIST::FUNCTION:
 ASN1_TIME_to_tm                         4243	1_1_1	EXIST::FUNCTION:
 ASN1_TIME_set_string_X509               4244	1_1_1	EXIST::FUNCTION:
 OCSP_resp_get1_id                       4245	1_1_1	EXIST::FUNCTION:OCSP
+OSSL_STORE_register_loader              4246	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_LOADER_set_error             4247	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get0_PKEY               4248	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get_type                4249	1_1_1	EXIST::FUNCTION:
+ERR_load_OSSL_STORE_strings             4250	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_LOADER_free                  4251	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get1_PKEY               4252	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_free                    4253	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_open_file                    4254	1_1_1	NOEXIST::FUNCTION:
+OSSL_STORE_LOADER_set_eof               4255	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_LOADER_new                   4256	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get0_CERT               4257	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_LOADER_set_close             4258	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_new_PARAMS              4259	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_new_PKEY                4260	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get1_PARAMS             4261	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get1_CRL                4262	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_error                        4263	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get1_CERT               4264	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get0_PARAMS             4265	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_type_string             4266	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get1_NAME               4267	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_LOADER_set_load              4268	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_LOADER_get0_scheme           4269	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_open                         4270	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_close                        4271	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_new_CERT                4272	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get0_CRL                4273	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_load                         4274	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get0_NAME               4275	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_unregister_loader            4276	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_new_CRL                 4277	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_new_NAME                4278	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_eof                          4279	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_LOADER_set_open              4280	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_LOADER_set_ctrl              4281	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_ctrl                         4282	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get0_NAME_description   4283	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_set0_NAME_description   4284	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_INFO_get1_NAME_description   4285	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_do_all_loaders               4286	1_1_1	EXIST::FUNCTION:
+OSSL_STORE_LOADER_get0_engine           4287	1_1_1	EXIST::FUNCTION:
diff --git a/util/private.num b/util/private.num
index 2ad754f..203b531 100644
--- a/util/private.num
+++ b/util/private.num
@@ -20,6 +20,17 @@ CRYPTO_EX_new                           datatype
 EVP_PKEY_gen_cb                         datatype
 GEN_SESSION_CB                          datatype
 OPENSSL_Applink                         external
+OSSL_STORE_CTX                          datatype
+OSSL_STORE_INFO                         datatype
+OSSL_STORE_LOADER                       datatype
+OSSL_STORE_LOADER_CTX                   datatype
+OSSL_STORE_close_fn                     datatype
+OSSL_STORE_ctrl_fn                      datatype
+OSSL_STORE_eof_fn                       datatype
+OSSL_STORE_error_fn                     datatype
+OSSL_STORE_load_fn                      datatype
+OSSL_STORE_open_fn                      datatype
+OSSL_STORE_post_process_info_fn         datatype
 SSL_CTX_keylog_cb_func                  datatype
 SSL_early_cb_fn                         datatype
 SSL_psk_client_cb_func                  datatype
</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015258.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="015262.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15260">[ date ]</a>
              <a href="thread.html#15260">[ thread ]</a>
              <a href="subject.html#15260">[ subject ]</a>
              <a href="author.html#15260">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
