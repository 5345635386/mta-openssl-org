<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2017-June/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1496684495.385409.5333.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014908.html">
   <LINK REL="Next"  HREF="014910.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1496684495.385409.5333.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Mon Jun  5 17:41:35 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="014908.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="014910.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14909">[ date ]</a>
              <a href="thread.html#14909">[ thread ]</a>
              <a href="subject.html#14909">[ subject ]</a>
              <a href="author.html#14909">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  ae269dd8b72dbed1f2c5f92dbe0fbf5b7b905e7b (commit)
      from  71dd3b6464df1ba524601c3705e1d1e3c7c5406d (commit)


- Log -----------------------------------------------------------------
commit ae269dd8b72dbed1f2c5f92dbe0fbf5b7b905e7b
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
Date:   Mon Jun 5 13:32:05 2017 -0400

    Use common STANZA for bn and exp tests
    
    Standardize file:line messages
    Reduce buff size; move to end of STANZA
    Add some Title entries (with blank line after)
    Add Title to some BN test files.
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3608">https://github.com/openssl/openssl/pull/3608</A>)

-----------------------------------------------------------------------

Summary of changes:
 test/bnmod.txt         |  15 +--
 test/bnmul.txt         |   8 +-
 test/bnshift.txt       |  12 +-
 test/bntest.c          | 131 +++----------------
 test/build.info        |   2 +-
 test/evp_test.c        | 339 ++++++++++++++++---------------------------------
 test/evpciph.txt       |   1 +
 test/evppkey.txt       |  13 +-
 test/testutil.h        |  44 +++++++
 test/testutil/stanza.c | 157 +++++++++++++++++++++++
 10 files changed, 360 insertions(+), 362 deletions(-)
 create mode 100644 test/testutil/stanza.c

diff --git a/test/bnmod.txt b/test/bnmod.txt
index ad4dd3d..5ea4d03 100644
--- a/test/bnmod.txt
+++ b/test/bnmod.txt
@@ -5,12 +5,11 @@
 # in the file LICENSE in the source distribution or at
 # <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
 
-# Modulus tests.
-
-# ModMul tests.
-#
 # These test vectors satisfy A * B = ModMul (mod M) and 0 &lt;= ModMul &lt; M.
 
+Title = ModMul tests
+
+
 ModMul = ae2ca2ce7addaee2e2b7752e286b2bb6a58b51cfbed5c924f00398e59ec36fe6341cd83da43a33a12410f45f6228079c4aeb3912be87e2e81fa1799151bfa0fea29873097475b2c3efa312145d0bf7e51b2a7c9bc961a4f4dcf0c883ff90b919b87c21099fba40257645be31f95a3a277
 A = 6b18497fed9befdf22a01d988d34213f6687d8a96e86c188dea4172e7c6095a0d18d3c86c0f5a1af9c6e3aaeb6baac2a510930b3ed06ec78ec2e12b
 B = 1a058d99397db0d209f01212dd4023ae01b15da04fe62d1f76f21622b2695558c67d706c535ca7f19b36f8ef2d508ffd6cf6fcf25e5
@@ -2012,10 +2011,10 @@ B = 8bdfa8fe5ef3b2ad02bc63c4d
 M = 84daecf412b8c50ad6dfdb546c3eb783dcc6f32003eda914bb
 
 
-# ModExp tests.
-#
 # These test vectors satisfy A ^ E = ModExp (mod M) and 0 &lt;= ModExp &lt; M.
 
+Title = ModExp tests
+
 # Regression test for carry propagation bug in sqr8x_reduction.
 ModExp = 19324b647d967d644b3219
 A = 050505050505
@@ -2476,11 +2475,11 @@ E = d7e6df5d755284929b986cd9b61c9c2c8843f24c711fbdbae1a468edcae15940094372557072
 M = e4e784aa1fa88625a43ba0185a153a929663920be7fe674a4d33c943d3b898cff051482e7050a070cede53be5e89f31515772c7aea637576f99f82708f89d9e244f6ad3a24a02cbe5c0ff7bcf2dad5491f53db7c3f2698a7c41b44f086652f17bb05fe4c5c0a92433c34086b49d7e1825b28bab6c5a9bd0bc95b53d659afa0d7
 
 
-# ModSqrt tests.
-#
 # These test vectors satisfy (ModSqrt * ModSqrt) mod P = A mod P with P a prime.
 # ModSqrt is in [0, (P-1)/2].
 
+Title = ModSqrt
+
 ModSqrt = 1
 A = 1
 P = 2
diff --git a/test/bnmul.txt b/test/bnmul.txt
index c2d02b0..dc13a92 100644
--- a/test/bnmul.txt
+++ b/test/bnmul.txt
@@ -5,10 +5,10 @@
 # in the file LICENSE in the source distribution or at
 # <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
 
-# Square tests.
-#
 # These test vectors satisfy A^2 = Square.
 
+Title = Square tests.
+
 # Regression test for a BN_sqr overflow bug.
 Square = 4000000000000000800000000000000240000000000000000000000000000001fffffffffffffff8000000000000000400000000000000000000000000000000
 A = 80000000000000008000000000000001fffffffffffffffe0000000000000000
@@ -318,10 +318,10 @@ Square = eea8028b26e0df090504d54da714a6f5f2695202e53cff479c78aedd47a8dc676243ec5
 A = -3dcb44be1e54c5a5d7db48055ca9afa1ebe2ae648aa6e16ac497502a7deee09ffa124720fad0ab163ce8b3ea6a90f110ea52b67dbc424d0cf1e8c9726dfd9e45bebcefaa5cd5706edeed27896525f31c6bbea3d67ee97badefabf3e2532470b66e3ae3100f66ddf50cf02fc3a8e3f44c304251d3b6a7ca3a6e4bd5d16a41bd97a4
 
 
-# Product tests.
-#
 # These test vectors satisfy A * B = Product.
 
+Title = Product tests
+
 Product = 5befab3320f8f90542f3120235abd926aac3805a19e343f690
 A = b057af553afb120db6b7764f8
 B = 857734c4c27a1d17f7cf59dee
diff --git a/test/bnshift.txt b/test/bnshift.txt
index c6c1da4..db30a24 100644
--- a/test/bnshift.txt
+++ b/test/bnshift.txt
@@ -5,10 +5,10 @@
 # in the file LICENSE in the source distribution or at
 # <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
 
-# LShift1 tests.
-#
 # These test vectors satisfy A * 2 = LShift1
 
+Title = Lshift1 tests
+
 LShift1 = 0
 A = 0
 
@@ -1213,10 +1213,10 @@ LShift1 = -ab4e80e4b56556d99108eb3cb35f17d1ae83da33b4138619070000000000000000000
 A = -55a740725ab2ab6cc884759e59af8be8d741ed19da09c30c838000000000000000000000000
 
 
-# LShift tests
-#
 # These test vectors satisfy A * 2^N = LShift.
 
+Title = LShift tests
+
 LShift = 18c9e860855d594dcb06d00b7d1933608ba906d85fa2d92c9e0
 A = c64f43042aeaca6e5836805be8c99b045d4836c2fd16c964f0
 N = 1
@@ -2018,10 +2018,10 @@ A = e8e7c5ae65d7333de82bcbfdd7cea60ffb11e600aa3088ec8e
 N = 64
 
 
-# RShift tests
-#
 # These test vectors satisfy A / 2^N = RShift, rounding towards zero.
 
+Title = RShift tests
+
 Rshift = 0
 A = -1
 N = 1
diff --git a/test/bntest.c b/test/bntest.c
index ccedd7a..00bdf3f 100644
--- a/test/bntest.c
+++ b/test/bntest.c
@@ -35,26 +35,12 @@ BIGNUM *bn_expand2(BIGNUM *b, int words);
 BIGNUM *bn_expand2(BIGNUM *b, int words) { return NULL; }
 #include &quot;../crypto/bn/bn_lcl.h&quot;
 
-#define MAXPAIRS        20
-
 /*
  * Things in boring, not in openssl.  TODO we should add them.
  */
 #define HAVE_BN_PADDED 0
 #define HAVE_BN_SQRT 0
 
-typedef struct pair_st {
-    char *key;
-    char *value;
-} PAIR;
-
-typedef struct stanza_st {
-    int curr;                           /* Current line in file */
-    int start;                          /* Line where test starts */
-    int numpairs;
-    PAIR pairs[MAXPAIRS];
-} STANZA;
-
 typedef struct filetest_st {
     const char *name;
     int (*func)(STANZA *s);
@@ -68,7 +54,6 @@ typedef struct mpitest_st {
 
 static const int NUM0 = 100;           /* number of tests */
 static const int NUM1 = 50;            /* additional tests for some functions */
-static BIO *fp;
 static BN_CTX *ctx;
 
 /*
@@ -113,7 +98,7 @@ static BIGNUM *getBN(STANZA *s, const char *attribute)
     BIGNUM *ret = NULL;
 
     if ((hex = findattr(s, attribute)) == NULL) {
-        TEST_error(&quot;Can't find %s in test at line %d&quot;, attribute, s-&gt;start);
+        TEST_error(&quot;%s:%d: Can't find %s&quot;, s-&gt;test_file, s-&gt;start, attribute);
         return NULL;
     }
 
@@ -1986,85 +1971,6 @@ err:
     return ret;
 }
 
-
-/* Delete leading and trailing spaces from a string */
-static char *strip_spaces(char *p)
-{
-    char *q;
-
-    /* Skip over leading spaces */
-    while (*p &amp;&amp; isspace(*p))
-        p++;
-    if (!*p)
-        return NULL;
-
-    for (q = p + strlen(p) - 1; q != p &amp;&amp; isspace(*q); )
-        *q-- = '\0';
-    return *p ? p : NULL;
-}
-
-/*
- * Read next test stanza; return 1 if found, 0 on EOF or error.
- */
-static int readstanza(STANZA *s)
-{
-    PAIR *pp = s-&gt;pairs;
-    char *p, *equals, *key, *value;
-    char buff[1024];
-
-    while (BIO_gets(fp, buff, sizeof(buff))) {
-        s-&gt;curr++;
-        if (!TEST_ptr(p = strchr(buff, '\n'))) {
-            TEST_info(&quot;Line %d too long&quot;, s-&gt;curr);
-            return 0;
-        }
-        *p = '\0';
-
-        /* Blank line marks end of tests. */
-        if (buff[0] == '\0')
-            break;
-
-        /* Lines starting with a pound sign are ignored. */
-        if (buff[0] == '#')
-            continue;
-
-        if (!TEST_ptr(equals = strchr(buff, '='))) {
-            TEST_info(&quot;Missing = at line %d\n&quot;, s-&gt;curr);
-            return 0;
-        }
-        *equals++ = '\0';
-        if (s-&gt;numpairs == 0)
-            s-&gt;start = s-&gt;curr;
-
-        if (!TEST_ptr(key = strip_spaces(buff))
-                || !TEST_ptr(value = strip_spaces(equals))
-                || !TEST_int_lt(s-&gt;numpairs++, MAXPAIRS)
-                || !TEST_ptr(pp-&gt;key = OPENSSL_strdup(key))
-                || !TEST_ptr(pp-&gt;value = OPENSSL_strdup(value)))
-            return 0;
-        pp++;
-    }
-
-    /* If we read anything, return ok. */
-    return 1;
-}
-
-static void clearstanza(STANZA *s)
-{
-    PAIR *pp = s-&gt;pairs;
-    int i = s-&gt;numpairs;
-    int start = s-&gt;start;
-    int curr = s-&gt;curr;
-
-    for ( ; --i &gt;= 0; pp++) {
-        OPENSSL_free(pp-&gt;key);
-        OPENSSL_free(pp-&gt;value);
-    }
-    memset(s, 0, sizeof(*s));
-    s-&gt;curr = curr;
-    s-&gt;start = start;
-}
-
 static int file_test_run(STANZA *s)
 {
     static const FILETEST filetests[] = {
@@ -2086,13 +1992,14 @@ static int file_test_run(STANZA *s)
     for ( ; --numtests &gt;= 0; tp++) {
         if (findattr(s, tp-&gt;name) != NULL) {
             if (!tp-&gt;func(s)) {
-                TEST_info(&quot;Failed %s test at %d&quot;, tp-&gt;name, s-&gt;start);
+                TEST_info(&quot;%s:%d: Failed %s test&quot;,
+                          s-&gt;test_file, s-&gt;start, tp-&gt;name);
                 return 0;
             }
             return 1;
         }
     }
-    TEST_info(&quot;Unknown test at %d&quot;, s-&gt;start);
+    TEST_info(&quot;%s:%d: Unknown test&quot;, s-&gt;test_file, s-&gt;start);
     return 0;
 }
 
@@ -2100,26 +2007,30 @@ static char * const *testfiles;
 
 static int run_file_tests(int i)
 {
-    STANZA s;
-    int errcnt = 0;
+    STANZA *s = NULL;
+    int c;
 
-    if (!TEST_ptr(fp = BIO_new_file(testfiles[i], &quot;rb&quot;)))
+    if (!TEST_ptr(s = OPENSSL_zalloc(sizeof(*s))))
         return 0;
+    if (!test_start_file(s, testfiles[i])) {
+        OPENSSL_free(s);
+        return 0;
+    }
 
     /* Read test file. */
-    set_test_title(testfiles[i]);
-    memset(&amp;s, 0, sizeof(s));
-    while (!BIO_eof(fp) &amp;&amp; readstanza(&amp;s)) {
-        if (s.numpairs == 0)
+    while (!BIO_eof(s-&gt;fp) &amp;&amp; test_readstanza(s)) {
+        if (s-&gt;numpairs == 0)
             continue;
-        if (!file_test_run(&amp;s)) {
-            errcnt++;
-        }
-        clearstanza(&amp;s);
+        if (!file_test_run(s))
+            s-&gt;errors++;
+        s-&gt;numtests++;
+        test_clearstanza(s);
     }
-    BIO_free(fp);
+    test_end_file(s);
+    c = s-&gt;errors;
+    OPENSSL_free(s);
 
-    return errcnt == 0;
+    return c == 0;
 }
 
 
diff --git a/test/build.info b/test/build.info
index 8e94dca..3dd7590 100644
--- a/test/build.info
+++ b/test/build.info
@@ -10,7 +10,7 @@
 IF[{- !$disabled{tests} -}]
   LIBS_NO_INST=libtestutil.a
   SOURCE[libtestutil.a]=testutil/basic_output.c testutil/output_helpers.c \
-          testutil/driver.c testutil/tests.c testutil/cb.c \
+          testutil/driver.c testutil/tests.c testutil/cb.c testutil/stanza.c \
           {- rebase_files(&quot;../apps&quot;, $target{apps_aux_src}) -} \
           testutil/test_main.c testutil/main.c
   INCLUDE[libtestutil.a]=.. ../include
diff --git a/test/evp_test.c b/test/evp_test.c
index 501a9fd..81232ed 100644
--- a/test/evp_test.c
+++ b/test/evp_test.c
@@ -28,15 +28,9 @@ typedef struct evp_test_method_st EVP_TEST_METHOD;
  * Structure holding test information
  */
 typedef struct evp_test_st {
-    BIO *in;                      /* file being read */
-    int line;                     /* current line being processed */
-    int start_line;               /* start line of current test */
-    int ntests;                   /* Number of tests */
-    int errors;                   /* Error count */
+    STANZA s;                     /* Common test stanza */
+    char *name;
     int skip;                     /* Current test should be skipped */
-    int nskip;                    /* Number of tests skipped */
-    char buf[10240];              /* Input buffer */
-    BIO *key;                     /* temp memory BIO for reading in keys */
     const EVP_TEST_METHOD *meth;  /* method for this test */
     const char *err, *aux_err;    /* Error string for test */
     char *expected_err;           /* Expected error value of test */
@@ -80,8 +74,6 @@ static int find_key(EVP_PKEY **ppk, const char *name, KEY_LIST *lst);
 
 static int parse_bin(const char *value, unsigned char **buf, size_t *buflen);
 
-static const char *current_test_file = &quot;???&quot;;
-
 /*
  * Structure used to hold a list of blocks of memory to test
  * calls to &quot;update&quot; like functions.
@@ -2110,6 +2102,7 @@ static const EVP_TEST_METHOD *find_test(const char *name)
 
 static void clear_test(EVP_TEST *t)
 {
+    test_clearstanza(&amp;t-&gt;s);
     ERR_clear_error();
     if (t-&gt;data != NULL) {
         if (t-&gt;meth != NULL)
@@ -2123,6 +2116,7 @@ static void clear_test(EVP_TEST *t)
     t-&gt;func = NULL;
     OPENSSL_free(t-&gt;reason);
     t-&gt;reason = NULL;
+
     /* Text literal. */
     t-&gt;err = NULL;
     t-&gt;skip = 0;
@@ -2142,25 +2136,23 @@ static int check_test_error(EVP_TEST *t)
         return 1;
     if (t-&gt;err != NULL &amp;&amp; t-&gt;expected_err == NULL) {
         if (t-&gt;aux_err != NULL) {
-            TEST_info(&quot;Above error from the test at %s:%d &quot;
-                      &quot;(%s) unexpected error %s&quot;,
-                      current_test_file, t-&gt;start_line, t-&gt;aux_err, t-&gt;err);
+            TEST_info(&quot;%s:%d: Source of above error (%s); unexpected error %s&quot;,
+                      t-&gt;s.test_file, t-&gt;s.start, t-&gt;aux_err, t-&gt;err);
         } else {
-            TEST_info(&quot;Above error from the test at %s:%d &quot;
-                      &quot;unexpected error %s&quot;,
-                      current_test_file, t-&gt;start_line, t-&gt;err);
+            TEST_info(&quot;%s:%d: Source of above error; unexpected error %s&quot;,
+                      t-&gt;s.test_file, t-&gt;s.start, t-&gt;err);
         }
         return 0;
     }
     if (t-&gt;err == NULL &amp;&amp; t-&gt;expected_err != NULL) {
-        TEST_info(&quot;Test line %d: succeeded but was expecting %s&quot;,
-                  t-&gt;start_line, t-&gt;expected_err);
+        TEST_info(&quot;%s:%d: Succeeded but was expecting %s&quot;,
+                  t-&gt;s.test_file, t-&gt;s.start, t-&gt;expected_err);
         return 0;
     }
 
     if (strcmp(t-&gt;err, t-&gt;expected_err) != 0) {
-        TEST_info(&quot;Test line %d: expecting %s got %s&quot;,
-                  t-&gt;start_line, t-&gt;expected_err, t-&gt;err);
+        TEST_info(&quot;%s:%d: Expected %s got %s&quot;,
+                  t-&gt;s.test_file, t-&gt;s.start, t-&gt;expected_err, t-&gt;err);
         return 0;
     }
 
@@ -2168,32 +2160,32 @@ static int check_test_error(EVP_TEST *t)
         return 1;
 
     if (t-&gt;func == NULL || t-&gt;reason == NULL) {
-        TEST_info(&quot;Test line %d: missing function or reason code&quot;,
-                  t-&gt;start_line);
+        TEST_info(&quot;%s:%d: Test is missing function or reason code&quot;,
+                  t-&gt;s.test_file, t-&gt;s.start);
         return 0;
     }
 
     err = ERR_peek_error();
     if (err == 0) {
-        TEST_info(&quot;Test line %d, expected error \&quot;%s:%s\&quot; not set&quot;,
-                  t-&gt;start_line, t-&gt;func, t-&gt;reason);
+        TEST_info(&quot;%s:%d: Expected error \&quot;%s:%s\&quot; not set&quot;,
+                  t-&gt;s.test_file, t-&gt;s.start, t-&gt;func, t-&gt;reason);
         return 0;
     }
 
     func = ERR_func_error_string(err);
     reason = ERR_reason_error_string(err);
     if (func == NULL &amp;&amp; reason == NULL) {
-        TEST_info(&quot;Test line %d: expected error \&quot;%s:%s\&quot;,&quot;
-                  &quot; no strings available.  Skipping...\n&quot;,
-                  t-&gt;start_line, t-&gt;func, t-&gt;reason);
+        TEST_info(&quot;%s:%d: Expected error \&quot;%s:%s\&quot;, no strings available.&quot;
+                  &quot; Assuming ok.&quot;,
+                  t-&gt;s.test_file, t-&gt;s.start, t-&gt;func, t-&gt;reason);
         return 1;
     }
 
     if (strcmp(func, t-&gt;func) == 0 &amp;&amp; strcmp(reason, t-&gt;reason) == 0)
         return 1;
 
-    TEST_info(&quot;Test line %d: expected error \&quot;%s:%s\&quot;, got \&quot;%s:%s\&quot;&quot;,
-              t-&gt;start_line, t-&gt;func, t-&gt;reason, func, reason);
+    TEST_info(&quot;%s:%d: Expected error \&quot;%s:%s\&quot;, got \&quot;%s:%s\&quot;&quot;,
+              t-&gt;s.test_file, t-&gt;s.start, t-&gt;func, t-&gt;reason, func, reason);
 
     return 0;
 }
@@ -2205,18 +2197,19 @@ static int run_test(EVP_TEST *t)
 {
     if (t-&gt;meth == NULL)
         return 1;
-    t-&gt;ntests++;
+    t-&gt;s.numtests++;
     if (t-&gt;skip) {
-        t-&gt;nskip++;
+        t-&gt;s.numskip++;
     } else {
         /* run the test */
         if (t-&gt;err == NULL &amp;&amp; t-&gt;meth-&gt;run_test(t) != 1) {
-            TEST_info(&quot;Line %d error %s&quot;, t-&gt;start_line, t-&gt;meth-&gt;name);
+            TEST_info(&quot;%s:%d %s error&quot;,
+                      t-&gt;s.test_file, t-&gt;s.start, t-&gt;meth-&gt;name);
             return 0;
         }
         if (!check_test_error(t)) {
             test_openssl_errors();
-            t-&gt;errors++;
+            t-&gt;s.errors++;
         }
     }
 
@@ -2248,90 +2241,6 @@ static void free_key_list(KEY_LIST *lst)
     }
 }
 
-
-/*
- * Read a line, remove the newline, return EOF or first char.
- * Comment lines are treated like empty lines.
- */
-static int read_line(EVP_TEST *t)
-{
-    char *p;
-
-    if (!BIO_gets(t-&gt;in, t-&gt;buf, sizeof(t-&gt;buf)))
-        return EOF;
-    t-&gt;line++;
-    if ((p = strchr(t-&gt;buf, '\n')) != NULL)
-        *p = '\0';
-    if (t-&gt;buf[0] == '#')
-        t-&gt;buf[0] = '\0';
-    return t-&gt;buf[0];
-}
-
-/*
- * Skip leading spaces and remove trailing spaces from string.
- */
-static char *strip_spaces(char *pval)
-{
-    char *p, *start;
-
-    for (start = pval; isspace(*start); )
-        start++;
-    if (*start == '\0')
-        return start;
-
-    for (p = start + strlen(start); --p &gt;= start &amp;&amp; isspace(*p); )
-        *p = '\0';
-    return start;
-}
-
-/*
- * Split line into 'key = value'; return 1 if okay, 0 on error.
- */
-static int split_line(EVP_TEST *t, char **keyword, char **value)
-{
-    char *p;
-
-    /* Look for = sign */
-    if ((p = strchr(t-&gt;buf, '=')) == NULL) {
-        TEST_error(&quot;Line %d: Missing '=' in test file&quot;, t-&gt;line);
-        return 0;
-    }
-    *p++ = '\0';
-    *keyword = strip_spaces(t-&gt;buf);
-    *value = strip_spaces(p);
-    if (**keyword == '\0') {
-        TEST_error(&quot;Line %d: Missing key; malformed input line&quot;, t-&gt;line);
-        return 0;
-    }
-    return 1;
-}
-
-/*
- * Read a PEM block.  Return 1 if okay, 0 on error.
- */
-static int read_key(EVP_TEST *t)
-{
-    char tmpbuf[128];
-
-    if (t-&gt;key == NULL) {
-        if (!TEST_ptr(t-&gt;key = BIO_new(BIO_s_mem())))
-            return 0;
-    } else if (!TEST_int_gt(BIO_reset(t-&gt;key), 0)) {
-        return 0;
-    }
-
-    /* Read to PEM end line and place content in memory BIO */
-    while (BIO_gets(t-&gt;in, tmpbuf, sizeof(tmpbuf))) {
-        t-&gt;line++;
-        if (!TEST_int_gt(BIO_puts(t-&gt;key, tmpbuf), 0))
-            return 0;
-        if (strncmp(tmpbuf, &quot;-----END&quot;, 8) == 0)
-            return 1;
-    }
-    TEST_error(&quot;Can't find key end&quot;);
-    return 0;
-}
-
 /*
  * Is the key type an unsupported algorithm?
  */
@@ -2360,54 +2269,52 @@ static int key_unsupported()
 }
 
 /*
- * Read, parse, and execute one test.  Return EOF; 0 if failure, 1 if okay.
+ * NULL out the value from |pp| but return it.  This &quot;steals&quot; a pointer.
  */
-static int read_stanza(EVP_TEST *t)
+static char *take_value(PAIR *pp)
 {
-    int c;
-    char *keyword, *value;
-    KEY_LIST **klist, *key;
+    char *p = pp-&gt;value;
+
+    pp-&gt;value = NULL;
+    return p;
+}
+
+/*
+ * Read and parse one test.  Return 0 if failure, 1 if okay.
+ */
+static int parse(EVP_TEST *t)
+{
+    KEY_LIST *key, **klist;
     EVP_PKEY *pkey;
+    PAIR *pp;
+    int i;
 
-    clear_test(t);
 top:
-    /* Find the first line of a stanza. */
-    for ( ; ; ) {
-        c = read_line(t);
-        if (c == EOF)
+    do {
+        if (BIO_eof(t-&gt;s.fp))
             return EOF;
-        if (c == '\0')
-            continue;
-        break;
-    }
-    if (!split_line(t, &amp;keyword, &amp;value))
-        return 0;
-
-    /* Handle a few special cases here. */
-    if (strcmp(keyword, &quot;Title&quot;) == 0) {
-        TEST_info(&quot;Starting \&quot;%s\&quot; tests&quot;, value);
-        goto top;
-    }
+        clear_test(t);
+        if (!test_readstanza(&amp;t-&gt;s))
+            return 0;
+    } while (t-&gt;s.numpairs == 0);
+    pp = &amp;t-&gt;s.pairs[0];
 
+    /* Are we adding a key? */
     klist = NULL;
     pkey = NULL;
-    if (strcmp(keyword, &quot;PrivateKey&quot;) == 0) {
-        if (!read_key(t))
-            return 0;
-        pkey = PEM_read_bio_PrivateKey(t-&gt;key, NULL, 0, NULL);
+    if (strcmp(pp-&gt;key, &quot;PrivateKey&quot;) == 0) {
+        pkey = PEM_read_bio_PrivateKey(t-&gt;s.key, NULL, 0, NULL);
         if (pkey == NULL &amp;&amp; !key_unsupported()) {
-            TEST_info(&quot;Can't read private key %s&quot;, value);
+            TEST_info(&quot;Can't read private key %s&quot;, pp-&gt;value);
             ERR_print_errors_fp(stderr);
             return 0;
         }
         klist = &amp;private_keys;
     }
-    else if (strcmp(keyword, &quot;PublicKey&quot;) == 0) {
-        if (!read_key(t))
-            return 0;
-        pkey = PEM_read_bio_PUBKEY(t-&gt;key, NULL, 0, NULL);
+    else if (strcmp(pp-&gt;key, &quot;PublicKey&quot;) == 0) {
+        pkey = PEM_read_bio_PUBKEY(t-&gt;s.key, NULL, 0, NULL);
         if (pkey == NULL &amp;&amp; !key_unsupported()) {
-            TEST_info(&quot;Can't read public key %s&quot;, value);
+            TEST_info(&quot;Can't read public key %s&quot;, pp-&gt;value);
             ERR_print_errors_fp(stderr);
             return 0;
         }
@@ -2416,135 +2323,105 @@ top:
 
     /* If we have a key add to list */
     if (klist != NULL) {
-        if (find_key(NULL, value, *klist)) {
-            TEST_info(&quot;Duplicate key %s&quot;, value);
+        if (find_key(NULL, pp-&gt;value, *klist)) {
+            TEST_info(&quot;Duplicate key %s&quot;, pp-&gt;value);
             return 0;
         }
-        if (!TEST_ptr(key = OPENSSL_malloc(sizeof(*key)))
-                || !TEST_ptr(key-&gt;name = OPENSSL_strdup(value)))
+        if (!TEST_ptr(key = OPENSSL_malloc(sizeof(*key))))
             return 0;
+        key-&gt;name = take_value(pp);
         key-&gt;key = pkey;
         key-&gt;next = *klist;
         *klist = key;
 
         /* Go back and start a new stanza. */
+        if (t-&gt;s.numpairs != 1)
+            TEST_info(&quot;Line %d: missing blank line\n&quot;, t-&gt;s.curr);
         goto top;
     }
 
-    /* Start of a new text.  Look it up. */
-    if (!TEST_ptr(t-&gt;meth = find_test(keyword)))
-        goto skiptoend;
-    t-&gt;start_line = t-&gt;line;
-    if (!t-&gt;meth-&gt;init(t, value)) {
-        TEST_error(&quot;unknown %s: %s\n&quot;, keyword, value);
-        goto skiptoend;
+    /* Find the test, based on first keyword. */
+    if (!TEST_ptr(t-&gt;meth = find_test(pp-&gt;key)))
+        return 0;
+    if (!t-&gt;meth-&gt;init(t, pp-&gt;value)) {
+        TEST_error(&quot;unknown %s: %s\n&quot;, pp-&gt;key, pp-&gt;value);
+        return 0;
     }
     if (t-&gt;skip == 1) {
-        /* TEST_info(&quot;skipping %s %s&quot;, keyword, value); */
-        goto skiptoend;
+        /* TEST_info(&quot;skipping %s %s&quot;, pp-&gt;key, pp-&gt;value); */
+        return 0;
     }
 
-    /* Read rest of stanza. */
-    for ( ; ; ) {
-        c = read_line(t);
-        if (c == EOF)
-            return c;
-        if (c == '\0')
-            break;
-        if (!split_line(t, &amp;keyword, &amp;value))
-            goto skiptoend;
-        if (strcmp(keyword, &quot;Result&quot;) == 0) {
+    for (pp++, i = 1; i &lt; t-&gt;s.numpairs; pp++, i++) {
+        if (strcmp(pp-&gt;key, &quot;Result&quot;) == 0) {
             if (t-&gt;expected_err != NULL) {
-                TEST_info(&quot;Line %d: multiple result lines&quot;, t-&gt;line);
-                goto skiptoend;
+                TEST_info(&quot;Line %d: multiple result lines&quot;, t-&gt;s.curr);
+                return 0;
             }
-            if (!TEST_ptr(t-&gt;expected_err = OPENSSL_strdup(value)))
-                goto skiptoend;
-        } else if (strcmp(keyword, &quot;Function&quot;) == 0) {
+            t-&gt;expected_err = take_value(pp);
+        } else if (strcmp(pp-&gt;key, &quot;Function&quot;) == 0) {
             if (t-&gt;func != NULL) {
-                TEST_info(&quot;Line %d: multiple function lines\n&quot;, t-&gt;line);
-                goto skiptoend;
+                TEST_info(&quot;Line %d: multiple function lines\n&quot;, t-&gt;s.curr);
+                return 0;
             }
-            if (!TEST_ptr(t-&gt;func = OPENSSL_strdup(value)))
-                goto skiptoend;
-        } else if (strcmp(keyword, &quot;Reason&quot;) == 0) {
+            t-&gt;func = take_value(pp);
+        } else if (strcmp(pp-&gt;key, &quot;Reason&quot;) == 0) {
             if (t-&gt;reason != NULL) {
-                TEST_info(&quot;Line %d: multiple reason lines&quot;, t-&gt;line);
-                goto skiptoend;
+                TEST_info(&quot;Line %d: multiple reason lines&quot;, t-&gt;s.curr);
+                return 0;
             }
-            if (!TEST_ptr(t-&gt;reason = OPENSSL_strdup(value)))
-                goto skiptoend;
+            t-&gt;reason = take_value(pp);
         } else {
             /* Must be test specific line: try to parse it */
-            int rv = t-&gt;meth-&gt;parse(t, keyword, value);
+            int rv = t-&gt;meth-&gt;parse(t, pp-&gt;key, pp-&gt;value);
 
             if (rv == 0) {
-                TEST_info(&quot;Line %d: unknown keyword %s&quot;, t-&gt;line, keyword);
-                goto skiptoend;
+                TEST_info(&quot;Line %d: unknown keyword %s&quot;, t-&gt;s.curr, pp-&gt;key);
+                return 0;
             }
             if (rv &lt; 0) {
                 TEST_info(&quot;Line %d: error processing keyword %s\n&quot;,
-                        t-&gt;line, keyword);
-                goto skiptoend;
+                        t-&gt;s.curr, pp-&gt;key);
+                return 0;
             }
         }
     }
 
     return 1;
-
-skiptoend:
-    /* Read to end of stanza and return failure */
-    for ( ; ; ) {
-        c = read_line(t);
-        if (c == EOF)
-            return EOF;
-        if (c == '\0')
-            break;
-    }
-    return 0;
 }
 
-static int do_test_file(const char *testfile)
+static char * const *testfiles;
+
+static int run_file_tests(int i)
 {
-    BIO *in;
-    EVP_TEST t;
+    EVP_TEST *t;
     int c;
 
-    set_test_title(testfile);
-    current_test_file = testfile;
-    if (!TEST_ptr(in = BIO_new_file(testfile, &quot;rb&quot;)))
+    if (!TEST_ptr(t = OPENSSL_zalloc(sizeof(*t))))
         return 0;
-    memset(&amp;t, 0, sizeof(t));
-    t.in = in;
+    if (!test_start_file(&amp;t-&gt;s, testfiles[i])) {
+        OPENSSL_free(t);
+        return 0;
+    }
 
-    TEST_info(&quot;Reading %s&quot;, testfile);
-    for ( ; ; ) {
-        c = read_stanza(&amp;t);
-        if (t.skip)
+    while (!BIO_eof(t-&gt;s.fp)) {
+        c = parse(t);
+        if (t-&gt;skip)
             continue;
-        if (c == 0 || !run_test(&amp;t)) {
-            t.errors++;
+        if (c == 0 || !run_test(t)) {
+            t-&gt;s.errors++;
             break;
         }
-        if (c == EOF)
-            break;
     }
-    clear_test(&amp;t);
+    test_end_file(&amp;t-&gt;s);
+    clear_test(t);
 
-    TEST_info(&quot;Completed %d tests with %d errors and %d skipped&quot;,
-              t.ntests, t.errors, t.nskip);
     free_key_list(public_keys);
     free_key_list(private_keys);
-    BIO_free(t.key);
-    BIO_free(in);
-    return t.errors == 0;
-}
-
-static char * const *testfiles;
-
-static int run_file_tests(int i)
-{
-    return do_test_file(testfiles[i]);
+    BIO_free(t-&gt;s.key);
+    c = t-&gt;s.errors;
+    OPENSSL_free(t);
+    return c == 0;
 }
 
 int test_main(int argc, char *argv[])
diff --git a/test/evpciph.txt b/test/evpciph.txt
index a662cd4..33eede2 100644
--- a/test/evpciph.txt
+++ b/test/evpciph.txt
@@ -1178,6 +1178,7 @@ Operation = DECRYPT
 Result = CIPHERFINAL_ERROR
 
 Title = AES XTS test vectors from IEEE Std 1619-2007
+
 Cipher = aes-128-xts
 Key = 0000000000000000000000000000000000000000000000000000000000000000
 IV = 00000000000000000000000000000000
diff --git a/test/evppkey.txt b/test/evppkey.txt
index 6a69fab..3c3d090 100644
--- a/test/evppkey.txt
+++ b/test/evppkey.txt
@@ -708,6 +708,7 @@ PrivateKey=Alice-25519
 -----BEGIN PRIVATE KEY-----
 MC4CAQAwBQYDK2VuBCIEIHcHbQpzGKV9PBbBclGyZkXfTC+H68CZKrF3+6UduSwq
 -----END PRIVATE KEY-----
+
 PublicKey=Alice-25519-PUBLIC
 -----BEGIN PUBLIC KEY-----
 MCowBQYDK2VuAyEAhSDwCYkwp1R0i33ctD73Wg2/Og0mOBr066SpjqqbTmo=
@@ -719,6 +720,7 @@ PrivateKey=Bob-25519
 -----BEGIN PRIVATE KEY-----
 MC4CAQAwBQYDK2VuBCIEIF2rCH5iSopLeeF/i4OADuZvO7EpJhi2/Rwviyf/iODr
 -----END PRIVATE KEY-----
+
 PublicKey=Bob-25519-PUBLIC
 -----BEGIN PUBLIC KEY-----
 MCowBQYDK2VuAyEA3p7bfXt9wbTTW2HC7OQ1Nz+DQ8hbeGdNrfx+FG+IK08=
@@ -747,9 +749,9 @@ Function = EVP_PKEY_verify_init
 Reason = operation not supported for this keytype
 
 
-Title = RSA PSS/OAEP (from RSASecurity FTP)
 # Additional RSA-PSS and RSA-OAEP tests converted from
 # <A HREF="ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1-vec.zip">ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1-vec.zip</A>
+Title = RSA PSS/OAEP (from RSASecurity FTP)
 
 PublicKey=RSA-PSS-1
 -----BEGIN PUBLIC KEY-----
@@ -5811,7 +5813,6 @@ SharedSecret=A7927098655F1F9976FA50A9D566865DC530331846381C87256BAF3226244B76D36
 #     456068d3f8aad8ac62a03d19ed3173f00ad51f42b51aeab4753c20f30c01cf23 #
 Title = ECDH KATs (from NIST SP800-56A co-factor ECDH KATs
 
-
 PrivateKey=KAS-ECC-CDH_P-192_C0
 -----BEGIN PRIVATE KEY-----
 MG8CAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQEEVTBTAgEBBBjxfT/qNnt000CFHKQn
@@ -17327,18 +17328,22 @@ PrivateKey=ED25519-1
 -----BEGIN PRIVATE KEY-----
 MC4CAQAwBQYDK2VwBCIEIJ1hsZ3v/VpguoRK9JLsLMREScVpezJpGXA7rAMcrn9g
 -----END PRIVATE KEY-----
+
 PrivateKey=ED25519-2
 -----BEGIN PRIVATE KEY-----
 MC4CAQAwBQYDK2VwBCIEIEzNCJso/5banbbDRuwRTg9bijGfNaumJNqM9u1PuKb7
 -----END PRIVATE KEY-----
+
 PrivateKey=ED25519-3
 -----BEGIN PRIVATE KEY-----
 MC4CAQAwBQYDK2VwBCIEIMWqjfQ/n4N77bdELzHct7Fm04U1B28JS4XOOi4LRFj3
 -----END PRIVATE KEY-----
+
 PrivateKey=ED25519-4
 -----BEGIN PRIVATE KEY-----
 MC4CAQAwBQYDK2VwBCIEIPXldnzxUzGVF2MPImh2uGyBYMxYO8ATdExr8lX1zA7l
 -----END PRIVATE KEY-----
+
 PrivateKey=ED25519-5
 -----BEGIN PRIVATE KEY-----
 MC4CAQAwBQYDK2VwBCIEIIM/5iQJI3udYux3WHUgkR6adZzsHRl1W32pAbltyj1C
@@ -17348,18 +17353,22 @@ PublicKey=ED25519-1-PUBLIC
 -----BEGIN PUBLIC KEY-----
 MCowBQYDK2VwAyEA11qYAYKxCrfVS/7TyWQHOg7hcvPapiMlrwIaaPcHURo=
 -----END PUBLIC KEY-----
+
 PublicKey=ED25519-2-PUBLIC
 -----BEGIN PUBLIC KEY-----
 MCowBQYDK2VwAyEAPUAXw+hDiVqStwqnTRt+vJyYLM8uxJaMwM1V8Sr0Zgw=
 -----END PUBLIC KEY-----
+
 PublicKey=ED25519-3-PUBLIC
 -----BEGIN PUBLIC KEY-----
 MCowBQYDK2VwAyEA/FHNjmIYoaONpH7QAjDwWAgW7RO6MwOsXeuRFUiQgCU=
 -----END PUBLIC KEY-----
+
 PublicKey=ED25519-4-PUBLIC
 -----BEGIN PUBLIC KEY-----
 MCowBQYDK2VwAyEAJ4EX/BRMcjQPZ9DyMW6Dhs7/vyskKMnFH+98WX8dQm4=
 -----END PUBLIC KEY-----
+
 PublicKey=ED25519-5-PUBLIC
 -----BEGIN PUBLIC KEY-----
 MCowBQYDK2VwAyEA7Bcrk61eVjv0kyxw4SRQNMNUZ+8u/U1k6/gZaDRn4r8=
diff --git a/test/testutil.h b/test/testutil.h
index d8acd73..48c4eb3 100644
--- a/test/testutil.h
+++ b/test/testutil.h
@@ -402,4 +402,48 @@ void test_openssl_errors(void);
 extern BIO *bio_out;
 extern BIO *bio_err;
 
+/*
+ * Utilities to parse a test file.
+ */
+#define TESTMAXPAIRS        20
+
+typedef struct pair_st {
+    char *key;
+    char *value;
+} PAIR;
+
+typedef struct stanza_st {
+    const char *test_file;      /* Input file name */
+    BIO *fp;                    /* Input file */
+    int curr;                   /* Current line in file */
+    int start;                  /* Line where test starts */
+    int errors;                 /* Error count */
+    int numtests;               /* Number of tests */
+    int numskip;                /* Number of skipped tests */
+    int numpairs;
+    PAIR pairs[TESTMAXPAIRS];
+    BIO *key;                   /* temp memory BIO for reading in keys */
+    char buff[4096];            /* Input buffer for a single key/value */
+} STANZA;
+
+/*
+ * Prepare to start reading the file |testfile| as input.
+ */
+int test_start_file(STANZA *s, const char *testfile);
+int test_end_file(STANZA *s);
+
+/*
+ * Read a stanza from the test file.  A stanza consists of a block
+ * of lines of the form 
+ *      key = value
+ * The block is terminated by EOF or a blank line.
+ * Return 1 if found, 0 on EOF or error.
+ */
+int test_readstanza(STANZA *s);
+
+/*
+ * Clear a stanza, release all allocated memory.
+ */
+void test_clearstanza(STANZA *s);
+
 #endif                          /* HEADER_TESTUTIL_H */
diff --git a/test/testutil/stanza.c b/test/testutil/stanza.c
new file mode 100644
index 0000000..46b1e77
--- /dev/null
+++ b/test/testutil/stanza.c
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+#include &lt;assert.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ctype.h&gt;
+
+#include &quot;e_os.h&quot;
+#include &quot;../testutil.h&quot;
+
+int test_start_file(STANZA *s, const char *testfile)
+{
+    TEST_info(&quot;Reading %s&quot;, testfile);
+    set_test_title(testfile);
+    memset(s, 0, sizeof(*s));
+    if (!TEST_ptr(s-&gt;fp = BIO_new_file(testfile, &quot;rb&quot;)))
+        return 0;
+    s-&gt;test_file = testfile;
+    return 1;
+}
+
+int test_end_file(STANZA *s)
+{
+    TEST_info(&quot;Completed %d tests with %d errors and %d skipped&quot;,
+              s-&gt;numtests, s-&gt;errors, s-&gt;numskip);
+    BIO_free(s-&gt;fp);
+    return 1;
+}
+
+/*
+ * Read a PEM block.  Return 1 if okay, 0 on error.
+ */
+static int read_key(STANZA *s)
+{
+    char tmpbuf[128];
+
+    if (s-&gt;key == NULL) {
+        if (!TEST_ptr(s-&gt;key = BIO_new(BIO_s_mem())))
+            return 0;
+    } else if (!TEST_int_gt(BIO_reset(s-&gt;key), 0)) {
+        return 0;
+    }
+
+    /* Read to PEM end line and place content in memory BIO */
+    while (BIO_gets(s-&gt;fp, tmpbuf, sizeof(tmpbuf))) {
+        s-&gt;curr++;
+        if (!TEST_int_gt(BIO_puts(s-&gt;key, tmpbuf), 0))
+            return 0;
+        if (strncmp(tmpbuf, &quot;-----END&quot;, 8) == 0)
+            return 1;
+    }
+    TEST_error(&quot;Can't find key end&quot;);
+    return 0;
+}
+
+
+/*
+ * Delete leading and trailing spaces from a string
+ */
+static char *strip_spaces(char *p)
+{
+    char *q;
+
+    /* Skip over leading spaces */
+    while (*p &amp;&amp; isspace(*p))
+        p++;
+    if (!*p)
+        return NULL;
+
+    for (q = p + strlen(p) - 1; q != p &amp;&amp; isspace(*q); )
+        *q-- = '\0';
+    return *p ? p : NULL;
+}
+
+/*
+ * Read next test stanza; return 1 if found, 0 on EOF or error.
+ */
+int test_readstanza(STANZA *s)
+{
+    PAIR *pp = s-&gt;pairs;
+    char *p, *equals, *key, *value;
+
+    for (s-&gt;numpairs = 0; BIO_gets(s-&gt;fp, s-&gt;buff, sizeof(s-&gt;buff)); ) {
+        s-&gt;curr++;
+        if (!TEST_ptr(p = strchr(s-&gt;buff, '\n'))) {
+            TEST_info(&quot;Line %d too long&quot;, s-&gt;curr);
+            return 0;
+        }
+        *p = '\0';
+
+        /* Blank line marks end of tests. */
+        if (s-&gt;buff[0] == '\0')
+            break;
+
+        /* Lines starting with a pound sign are ignored. */
+        if (s-&gt;buff[0] == '#')
+            continue;
+
+        /* Parse into key=value */
+        if (!TEST_ptr(equals = strchr(s-&gt;buff, '='))) {
+            TEST_info(&quot;Missing = at line %d\n&quot;, s-&gt;curr);
+            return 0;
+        }
+        *equals++ = '\0';
+        if (!TEST_ptr(key = strip_spaces(s-&gt;buff))) {
+            TEST_info(&quot;Empty field at line %d\n&quot;, s-&gt;curr);
+            return 0;
+        }
+        if ((value = strip_spaces(equals)) == NULL)
+            value = &quot;&quot;;
+
+        if (strcmp(key, &quot;Title&quot;) == 0) {
+            TEST_info(&quot;Starting \&quot;%s\&quot; tests at line %d&quot;, value, s-&gt;curr);
+            continue;
+        }
+
+        if (s-&gt;numpairs == 0)
+            s-&gt;start = s-&gt;curr;
+
+        if (strcmp(key, &quot;PrivateKey&quot;) == 0) {
+            if (!read_key(s))
+                return 0;
+        }
+        if (strcmp(key, &quot;PublicKey&quot;) == 0) {
+            if (!read_key(s))
+                return 0;
+        }
+
+        if (!TEST_int_lt(s-&gt;numpairs++, TESTMAXPAIRS)
+                || !TEST_ptr(pp-&gt;key = OPENSSL_strdup(key))
+                || !TEST_ptr(pp-&gt;value = OPENSSL_strdup(value)))
+            return 0;
+        pp++;
+    }
+
+    /* If we read anything, return ok. */
+    return 1;
+}
+
+void test_clearstanza(STANZA *s)
+{
+    PAIR *pp = s-&gt;pairs;
+    int i = s-&gt;numpairs;
+
+    for ( ; --i &gt;= 0; pp++) {
+        OPENSSL_free(pp-&gt;key);
+        OPENSSL_free(pp-&gt;value);
+    }
+    s-&gt;numpairs = 0;
+}
</PRE>

































































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014908.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="014910.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14909">[ date ]</a>
              <a href="thread.html#14909">[ thread ]</a>
              <a href="subject.html#14909">[ subject ]</a>
              <a href="author.html#14909">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
