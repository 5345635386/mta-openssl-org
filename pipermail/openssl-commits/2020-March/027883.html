<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-March/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1584006369.471716.20146.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027881.html">
   <LINK REL="Next"  HREF="027885.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1584006369.471716.20146.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Thu Mar 12 09:46:09 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="027881.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="027885.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27883">[ date ]</a>
              <a href="thread.html#27883">[ thread ]</a>
              <a href="subject.html#27883">[ subject ]</a>
              <a href="author.html#27883">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  f11a74ef79d3944844593d8d76d43f048bdb709d (commit)
       via  88af1ebb04bf9db0da9bb3949b407dc46e5d6644 (commit)
       via  2972af109e10c5ce30e548190e3eee28327d6043 (commit)
       via  6292475573367434f91f7526301388d50c6d0d67 (commit)
       via  1a5632e0dcc5cdc2b3440694cb50e04994bb1391 (commit)
      from  1c725f463edf0a5b33a2a93e9a43a9ab682af7db (commit)


- Log -----------------------------------------------------------------
commit f11a74ef79d3944844593d8d76d43f048bdb709d
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Feb 18 15:37:08 2020 +0100

    test/recipes/30-test_evp_data/evppkey.txt: Change an expected KeyGen result
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10289">https://github.com/openssl/openssl/pull/10289</A>)

commit 88af1ebb04bf9db0da9bb3949b407dc46e5d6644
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Feb 18 15:35:24 2020 +0100

    test/evp_test.c: fix keygen_test_run()
    
    There was a misunderstanding what it should return.  It should return
    0 on internal error, but 1 even if the thing it tests fails (the error
    is determined by |t-&gt;err|).
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10289">https://github.com/openssl/openssl/pull/10289</A>)

commit 2972af109e10c5ce30e548190e3eee28327d6043
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sun Oct 27 15:28:29 2019 +0100

    PROV: Add RSA functionality for key generation
    
    This includes added support in legacy controls
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10289">https://github.com/openssl/openssl/pull/10289</A>)

commit 6292475573367434f91f7526301388d50c6d0d67
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sun Oct 27 15:09:26 2019 +0100

    EVP: Add new domparams and key generation functionality
    
    The following functions are added:
    
    EVP_PKEY_gen_set_params(), replacing the older EVP_PKEY_CTX_ctrl()
    EVP_PKEY_gen(), replacing both EVP_PKEY_keygen() and EVP_PKEY_paramgen()
    
    These functions are made to work together with already existing domparams
    and key generation functionality: EVP_PKEY_CTX_new_provided(),
    EVP_PKEY_paramgen_init(), EVP_PKEY_keygen_init(), etc.
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10289">https://github.com/openssl/openssl/pull/10289</A>)

commit 1a5632e0dcc5cdc2b3440694cb50e04994bb1391
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Oct 26 13:00:56 2019 +0200

    CORE: Add the key object generator libcrypto&lt;-&gt;provider interface
    
    We introduce these dispatched functions:
    
    -   OP_keymgmt_gen_init() to initialize the key object generation.
    -   OP_keymgmt_gen_set_template() to set a template for key object
        generation.  The template is another key object, for example one
        with domain parameters.
    -   OP_keymgmt_gen_set_params() to set other key object generation
        parameters.
    -   OP_keymgmt_gen_settable_params() to find out what settable
        parameters there are.
    -   OP_keymgmt_gen() to perform the key object generation.
    -   OP_keymgmt_gen_cleanup() to clean up the key object generation.
    
    Internal function for easy and consistent use of these ddispatched
    functions are added.
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10289">https://github.com/openssl/openssl/pull/10289</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/evp/evp_local.h                             |   8 +
 crypto/evp/keymgmt_lib.c                           |  20 ++
 crypto/evp/keymgmt_meth.c                          |  90 +++++++-
 crypto/evp/p_lib.c                                 |   2 +-
 crypto/evp/pmeth_gn.c                              | 254 ++++++++++++++++-----
 crypto/evp/pmeth_lib.c                             |  33 ++-
 crypto/rsa/rsa_lib.c                               |  91 ++++++++
 doc/man3/{EVP_PKEY_keygen.pod =&gt; EVP_PKEY_gen.pod} |  79 +++++--
 doc/man7/provider-keymgmt.pod                      |  53 ++++-
 include/crypto/evp.h                               |  38 ++-
 include/openssl/core_names.h                       |   7 +
 include/openssl/core_numbers.h                     |  25 +-
 include/openssl/evp.h                              |   1 +
 include/openssl/rsa.h                              |  16 +-
 providers/implementations/keymgmt/rsa_kmgmt.c      | 124 ++++++++++
 test/evp_test.c                                    |   9 +-
 test/recipes/30-test_evp_data/evppkey.txt          |   2 +-
 util/libcrypto.num                                 |   4 +
 18 files changed, 734 insertions(+), 122 deletions(-)
 rename doc/man3/{EVP_PKEY_keygen.pod =&gt; EVP_PKEY_gen.pod} (65%)

diff --git a/crypto/evp/evp_local.h b/crypto/evp/evp_local.h
index 858f1c49d6..836dc33e26 100644
--- a/crypto/evp/evp_local.h
+++ b/crypto/evp/evp_local.h
@@ -81,6 +81,14 @@ struct evp_keymgmt_st {
     OSSL_OP_keymgmt_set_params_fn *set_params;
     OSSL_OP_keymgmt_settable_params_fn *settable_params;
 
+    /* Generation, a complex constructor */
+    OSSL_OP_keymgmt_gen_init_fn *gen_init;
+    OSSL_OP_keymgmt_gen_set_template_fn *gen_set_template;
+    OSSL_OP_keymgmt_gen_set_params_fn *gen_set_params;
+    OSSL_OP_keymgmt_gen_settable_params_fn *gen_settable_params;
+    OSSL_OP_keymgmt_gen_fn *gen;
+    OSSL_OP_keymgmt_gen_cleanup_fn *gen_cleanup;
+
     /* Key object checking */
     OSSL_OP_keymgmt_query_operation_name_fn *query_operation_name;
     OSSL_OP_keymgmt_has_fn *has;
diff --git a/crypto/evp/keymgmt_lib.c b/crypto/evp/keymgmt_lib.c
index 68ccdbb8ee..94be3c2a9c 100644
--- a/crypto/evp/keymgmt_lib.c
+++ b/crypto/evp/keymgmt_lib.c
@@ -350,3 +350,23 @@ int evp_keymgmt_util_copy(EVP_PKEY *to, EVP_PKEY *from, int selection)
 
     return 1;
 }
+
+void *evp_keymgmt_util_gen(EVP_PKEY *target, EVP_KEYMGMT *keymgmt,
+                           void *genctx, OSSL_CALLBACK *cb, void *cbarg)
+{
+    void *keydata = evp_keymgmt_gen(keymgmt, genctx, cb, cbarg);
+
+    if (keydata != NULL) {
+        if (!EVP_KEYMGMT_up_ref(keymgmt)) {
+            evp_keymgmt_freedata(keymgmt, keydata);
+            return NULL;
+        }
+
+        evp_keymgmt_util_clear_operation_cache(target);
+        target-&gt;keymgmt = keymgmt;
+        target-&gt;keydata = keydata;
+        evp_keymgmt_util_cache_keyinfo(target);
+    }
+
+    return keydata;
+}
diff --git a/crypto/evp/keymgmt_meth.c b/crypto/evp/keymgmt_meth.c
index f80e6e29b5..07d52ebf68 100644
--- a/crypto/evp/keymgmt_meth.c
+++ b/crypto/evp/keymgmt_meth.c
@@ -38,7 +38,8 @@ static void *keymgmt_from_dispatch(int name_id,
                                    OSSL_PROVIDER *prov)
 {
     EVP_KEYMGMT *keymgmt = NULL;
-    int setparamfncnt = 0, getparamfncnt = 0, importfncnt = 0, exportfncnt = 0;
+    int setparamfncnt = 0, getparamfncnt = 0, setgenparamfncnt = 0;
+    int importfncnt = 0, exportfncnt = 0;
 
     if ((keymgmt = keymgmt_new()) == NULL) {
         EVP_KEYMGMT_free(keymgmt);
@@ -52,6 +53,37 @@ static void *keymgmt_from_dispatch(int name_id,
             if (keymgmt-&gt;new == NULL)
                 keymgmt-&gt;new = OSSL_get_OP_keymgmt_new(fns);
             break;
+        case OSSL_FUNC_KEYMGMT_GEN_INIT:
+            if (keymgmt-&gt;gen_init == NULL)
+                keymgmt-&gt;gen_init = OSSL_get_OP_keymgmt_gen_init(fns);
+            break;
+        case OSSL_FUNC_KEYMGMT_GEN_SET_TEMPLATE:
+            if (keymgmt-&gt;gen_set_template == NULL)
+                keymgmt-&gt;gen_set_template =
+                    OSSL_get_OP_keymgmt_gen_set_template(fns);
+            break;
+        case OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS:
+            if (keymgmt-&gt;gen_set_params == NULL) {
+                setgenparamfncnt++;
+                keymgmt-&gt;gen_set_params =
+                    OSSL_get_OP_keymgmt_gen_set_params(fns);
+            }
+            break;
+        case OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS:
+            if (keymgmt-&gt;gen_settable_params == NULL) {
+                setgenparamfncnt++;
+                keymgmt-&gt;gen_settable_params =
+                    OSSL_get_OP_keymgmt_gen_settable_params(fns);
+            }
+            break;
+        case OSSL_FUNC_KEYMGMT_GEN:
+            if (keymgmt-&gt;gen == NULL)
+                keymgmt-&gt;gen = OSSL_get_OP_keymgmt_gen(fns);
+            break;
+        case OSSL_FUNC_KEYMGMT_GEN_CLEANUP:
+            if (keymgmt-&gt;gen_cleanup == NULL)
+                keymgmt-&gt;gen_cleanup = OSSL_get_OP_keymgmt_gen_cleanup(fns);
+            break;
         case OSSL_FUNC_KEYMGMT_FREE:
             if (keymgmt-&gt;free == NULL)
                 keymgmt-&gt;free = OSSL_get_OP_keymgmt_free(fns);
@@ -134,12 +166,16 @@ static void *keymgmt_from_dispatch(int name_id,
      * export if you can't import or export.
      */
     if (keymgmt-&gt;free == NULL
-        || keymgmt-&gt;new == NULL
+        || (keymgmt-&gt;new == NULL &amp;&amp; keymgmt-&gt;gen == NULL)
         || keymgmt-&gt;has == NULL
         || (getparamfncnt != 0 &amp;&amp; getparamfncnt != 2)
         || (setparamfncnt != 0 &amp;&amp; setparamfncnt != 2)
+        || (setgenparamfncnt != 0 &amp;&amp; setgenparamfncnt != 2)
         || (importfncnt != 0 &amp;&amp; importfncnt != 2)
-        || (exportfncnt != 0 &amp;&amp; exportfncnt != 2)) {
+        || (exportfncnt != 0 &amp;&amp; exportfncnt != 2)
+        || (keymgmt-&gt;gen != NULL
+            &amp;&amp; (keymgmt-&gt;gen_init == NULL
+                || keymgmt-&gt;gen_cleanup == NULL))) {
         EVP_KEYMGMT_free(keymgmt);
         EVPerr(0, EVP_R_INVALID_PROVIDER_FUNCTIONS);
         return NULL;
@@ -249,6 +285,54 @@ void evp_keymgmt_freedata(const EVP_KEYMGMT *keymgmt, void *keydata)
     keymgmt-&gt;free(keydata);
 }
 
+void *evp_keymgmt_gen_init(const EVP_KEYMGMT *keymgmt, int selection)
+{
+    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_provider(keymgmt));
+
+    if (keymgmt-&gt;gen_init == NULL)
+        return NULL;
+    return keymgmt-&gt;gen_init(provctx, selection);
+}
+
+int evp_keymgmt_gen_set_template(const EVP_KEYMGMT *keymgmt, void *genctx,
+                                 void *template)
+{
+    if (keymgmt-&gt;gen_set_template == NULL)
+        return 0;
+    return keymgmt-&gt;gen_set_template(genctx, template);
+}
+
+int evp_keymgmt_gen_set_params(const EVP_KEYMGMT *keymgmt, void *genctx,
+                               const OSSL_PARAM params[])
+{
+    if (keymgmt-&gt;gen_set_params == NULL)
+        return 0;
+    return keymgmt-&gt;gen_set_params(genctx, params);
+}
+
+const OSSL_PARAM *evp_keymgmt_gen_settable_params(const EVP_KEYMGMT *keymgmt)
+{
+    void *provctx = ossl_provider_ctx(EVP_KEYMGMT_provider(keymgmt));
+
+    if (keymgmt-&gt;gen_settable_params == NULL)
+        return NULL;
+    return keymgmt-&gt;gen_settable_params(provctx);
+}
+
+void *evp_keymgmt_gen(const EVP_KEYMGMT *keymgmt, void *genctx,
+                      OSSL_CALLBACK *cb, void *cbarg)
+{
+    if (keymgmt-&gt;gen == NULL)
+        return NULL;
+    return keymgmt-&gt;gen(genctx, cb, cbarg);
+}
+
+void evp_keymgmt_gen_cleanup(const EVP_KEYMGMT *keymgmt, void *genctx)
+{
+    if (keymgmt-&gt;gen != NULL)
+        keymgmt-&gt;gen_cleanup(genctx);
+}
+
 int evp_keymgmt_get_params(const EVP_KEYMGMT *keymgmt, void *keydata,
                            OSSL_PARAM params[])
 {
diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
index 586ffaf041..3012790cee 100644
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -1012,7 +1012,7 @@ int EVP_PKEY_up_ref(EVP_PKEY *pkey)
 }
 
 #ifndef FIPS_MODE
-static void evp_pkey_free_legacy(EVP_PKEY *x)
+void evp_pkey_free_legacy(EVP_PKEY *x)
 {
     if (x-&gt;ameth != NULL) {
         if (x-&gt;ameth-&gt;pkey_free != NULL)
diff --git a/crypto/evp/pmeth_gn.c b/crypto/evp/pmeth_gn.c
index 84149fabd7..03f1426d85 100644
--- a/crypto/evp/pmeth_gn.c
+++ b/crypto/evp/pmeth_gn.c
@@ -9,7 +9,10 @@
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
+#include &lt;openssl/core.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &quot;internal/cryptlib.h&quot;
+#include &quot;internal/core.h&quot;
 #include &lt;openssl/objects.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &quot;crypto/bn.h&quot;
@@ -17,102 +20,225 @@
 #include &quot;crypto/evp.h&quot;
 #include &quot;evp_local.h&quot;
 
-#ifndef FIPS_MODE
-int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx)
+static int gen_init(EVP_PKEY_CTX *ctx, int operation)
 {
-    int ret;
-    if (!ctx || !ctx-&gt;pmeth || !ctx-&gt;pmeth-&gt;paramgen) {
-        EVPerr(EVP_F_EVP_PKEY_PARAMGEN_INIT,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
-        return -2;
+    int ret = 0;
+
+    if (ctx == NULL)
+        goto not_supported;
+
+    evp_pkey_ctx_free_old_ops(ctx);
+    ctx-&gt;operation = operation;
+
+    if (ctx-&gt;engine != NULL || ctx-&gt;keytype == NULL)
+        goto legacy;
+
+    if (ctx-&gt;keymgmt == NULL) {
+        ctx-&gt;keymgmt =
+            EVP_KEYMGMT_fetch(ctx-&gt;libctx, ctx-&gt;keytype, ctx-&gt;propquery);
+        if (ctx-&gt;keymgmt == NULL
+            || ctx-&gt;keymgmt-&gt;gen_init == NULL) {
+            EVP_KEYMGMT_free(ctx-&gt;keymgmt);
+            ctx-&gt;keymgmt = NULL;
+            goto legacy;
+        }
+    }
+    if (ctx-&gt;keymgmt-&gt;gen_init == NULL)
+        goto not_supported;
+
+    switch (operation) {
+    case EVP_PKEY_OP_PARAMGEN:
+        ctx-&gt;op.keymgmt.genctx =
+            evp_keymgmt_gen_init(ctx-&gt;keymgmt,
+                                 OSSL_KEYMGMT_SELECT_ALL_PARAMETERS);
+        break;
+    case EVP_PKEY_OP_KEYGEN:
+        ctx-&gt;op.keymgmt.genctx =
+            evp_keymgmt_gen_init(ctx-&gt;keymgmt, OSSL_KEYMGMT_SELECT_KEYPAIR);
+        break;
+    }
+
+    if (ctx-&gt;op.keymgmt.genctx == NULL)
+        ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
+    else
+        ret = 1;
+    goto end;
+
+ legacy:
+#ifdef FIPS_MODE
+    goto not_supported;
+#else
+    if (ctx-&gt;pmeth == NULL
+        || (operation == EVP_PKEY_OP_PARAMGEN
+            &amp;&amp; ctx-&gt;pmeth-&gt;paramgen == NULL)
+        || (operation == EVP_PKEY_OP_KEYGEN
+            &amp;&amp; ctx-&gt;pmeth-&gt;keygen == NULL))
+        goto not_supported;
+
+    ret = 1;
+    switch (operation) {
+    case EVP_PKEY_OP_PARAMGEN:
+        if (ctx-&gt;pmeth-&gt;paramgen_init != NULL)
+            ret = ctx-&gt;pmeth-&gt;paramgen_init(ctx);
+        break;
+    case EVP_PKEY_OP_KEYGEN:
+        if (ctx-&gt;pmeth-&gt;keygen_init != NULL)
+            ret = ctx-&gt;pmeth-&gt;keygen_init(ctx);
+        break;
     }
-    ctx-&gt;operation = EVP_PKEY_OP_PARAMGEN;
-    if (!ctx-&gt;pmeth-&gt;paramgen_init)
-        return 1;
-    ret = ctx-&gt;pmeth-&gt;paramgen_init(ctx);
+#endif
+
+ end:
     if (ret &lt;= 0)
         ctx-&gt;operation = EVP_PKEY_OP_UNDEFINED;
     return ret;
+
+ not_supported:
+    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+    ret = -2;
+    goto end;
 }
 
-int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
+int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx)
 {
-    int ret;
-    if (!ctx || !ctx-&gt;pmeth || !ctx-&gt;pmeth-&gt;paramgen) {
-        EVPerr(EVP_F_EVP_PKEY_PARAMGEN,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
-        return -2;
-    }
+    return gen_init(ctx, EVP_PKEY_OP_PARAMGEN);
+}
 
-    if (ctx-&gt;operation != EVP_PKEY_OP_PARAMGEN) {
-        EVPerr(EVP_F_EVP_PKEY_PARAMGEN, EVP_R_OPERATON_NOT_INITIALIZED);
-        return -1;
-    }
+int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx)
+{
+    return gen_init(ctx, EVP_PKEY_OP_KEYGEN);
+}
+
+static int ossl_callback_to_pkey_gencb(const OSSL_PARAM params[], void *arg)
+{
+    EVP_PKEY_CTX *ctx = arg;
+    const OSSL_PARAM *param = NULL;
+    int p = -1, n = -1;
+
+    if (ctx-&gt;pkey_gencb == NULL)
+        return 1;                /* No callback?  That's fine */
+
+    if ((param = OSSL_PARAM_locate_const(params, OSSL_GEN_PARAM_POTENTIAL))
+        == NULL
+        || !OSSL_PARAM_get_int(param, &amp;p))
+        return 0;
+    if ((param = OSSL_PARAM_locate_const(params, OSSL_GEN_PARAM_ITERATION))
+        == NULL
+        || !OSSL_PARAM_get_int(param, &amp;n))
+        return 0;
+
+    ctx-&gt;keygen_info[0] = p;
+    ctx-&gt;keygen_info[1] = n;
+
+    return ctx-&gt;pkey_gencb(ctx);
+}
+
+int EVP_PKEY_gen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
+{
+    int ret = 0;
+    OSSL_CALLBACK cb;
+    EVP_PKEY *allocated_pkey = NULL;
 
     if (ppkey == NULL)
         return -1;
 
+    if (ctx == NULL)
+        goto not_supported;
+
+    if ((ctx-&gt;operation &amp; EVP_PKEY_OP_TYPE_GEN) == 0)
+        goto not_initialized;
+
     if (*ppkey == NULL)
-        *ppkey = EVP_PKEY_new();
+        *ppkey = allocated_pkey = EVP_PKEY_new();
 
     if (*ppkey == NULL) {
-        EVPerr(EVP_F_EVP_PKEY_PARAMGEN, ERR_R_MALLOC_FAILURE);
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         return -1;
     }
 
-    ret = ctx-&gt;pmeth-&gt;paramgen(ctx, *ppkey);
+    if (ctx-&gt;keymgmt == NULL)
+        goto legacy;
+
+    ret = 1;
+    if (ctx-&gt;pkey != NULL) {
+        EVP_KEYMGMT *tmp_keymgmt = ctx-&gt;keymgmt;
+        void *keydata =
+            evp_pkey_export_to_provider(ctx-&gt;pkey, ctx-&gt;libctx,
+                                        &amp;tmp_keymgmt, ctx-&gt;propquery);
+
+        if (keydata == NULL)
+            goto not_supported;
+        ret = evp_keymgmt_gen_set_template(ctx-&gt;keymgmt,
+                                           ctx-&gt;op.keymgmt.genctx, keydata);
+    }
+
+    /*
+     * the returned value from evp_keymgmt_util_gen() is cached in *ppkey,
+     * so we so not need to save it, just check it.
+     */
+    ret = ret
+        &amp;&amp; (evp_keymgmt_util_gen(*ppkey, ctx-&gt;keymgmt, ctx-&gt;op.keymgmt.genctx,
+                                 ossl_callback_to_pkey_gencb, ctx)
+            != NULL);
+
+#ifndef FIPS_MODE
+    /* In case |*ppkey| was originally a legacy key */
+    if (ret)
+        evp_pkey_free_legacy(*ppkey);
+#endif
+
+    goto end;
+
+ legacy:
+#ifdef FIPS_MODE
+    goto not_supported;
+#else
+    switch (ctx-&gt;operation) {
+    case EVP_PKEY_OP_PARAMGEN:
+        ret = ctx-&gt;pmeth-&gt;paramgen(ctx, *ppkey);
+        break;
+    case EVP_PKEY_OP_KEYGEN:
+        ret = ctx-&gt;pmeth-&gt;keygen(ctx, *ppkey);
+        break;
+    default:
+        goto not_supported;
+    }
+#endif
+
+ end:
     if (ret &lt;= 0) {
-        EVP_PKEY_free(*ppkey);
-        *ppkey = NULL;
+        if (allocated_pkey != NULL)
+            *ppkey = NULL;
+        EVP_PKEY_free(allocated_pkey);
     }
     return ret;
+
+ not_supported:
+    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
+    ret = -2;
+    goto end;
+ not_initialized:
+    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
+    ret = -1;
+    goto end;
 }
 
-int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx)
+int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
 {
-    int ret;
-    if (!ctx || !ctx-&gt;pmeth || !ctx-&gt;pmeth-&gt;keygen) {
-        EVPerr(EVP_F_EVP_PKEY_KEYGEN_INIT,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
-        return -2;
+    if (ctx-&gt;operation != EVP_PKEY_OP_PARAMGEN) {
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
+        return -1;
     }
-    ctx-&gt;operation = EVP_PKEY_OP_KEYGEN;
-    if (!ctx-&gt;pmeth-&gt;keygen_init)
-        return 1;
-    ret = ctx-&gt;pmeth-&gt;keygen_init(ctx);
-    if (ret &lt;= 0)
-        ctx-&gt;operation = EVP_PKEY_OP_UNDEFINED;
-    return ret;
+    return EVP_PKEY_gen(ctx, ppkey);
 }
 
 int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)
 {
-    int ret;
-
-    if (!ctx || !ctx-&gt;pmeth || !ctx-&gt;pmeth-&gt;keygen) {
-        EVPerr(EVP_F_EVP_PKEY_KEYGEN,
-               EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
-        return -2;
-    }
     if (ctx-&gt;operation != EVP_PKEY_OP_KEYGEN) {
-        EVPerr(EVP_F_EVP_PKEY_KEYGEN, EVP_R_OPERATON_NOT_INITIALIZED);
+        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATON_NOT_INITIALIZED);
         return -1;
     }
-
-    if (ppkey == NULL)
-        return -1;
-
-    if (*ppkey == NULL)
-        *ppkey = EVP_PKEY_new();
-    if (*ppkey == NULL)
-        return -1;
-
-    ret = ctx-&gt;pmeth-&gt;keygen(ctx, *ppkey);
-    if (ret &lt;= 0) {
-        EVP_PKEY_free(*ppkey);
-        *ppkey = NULL;
-    }
-    return ret;
+    return EVP_PKEY_gen(ctx, ppkey);
 }
 
 void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb)
@@ -152,6 +278,8 @@ int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx)
     return ctx-&gt;keygen_info[idx];
 }
 
+#ifndef FIPS_MODE
+
 EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,
                                const unsigned char *key, int keylen)
 {
diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index 906b08156f..a81908a962 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -292,6 +292,9 @@ void evp_pkey_ctx_free_old_ops(EVP_PKEY_CTX *ctx)
         EVP_ASYM_CIPHER_free(ctx-&gt;op.ciph.cipher);
         ctx-&gt;op.ciph.ciphprovctx = NULL;
         ctx-&gt;op.ciph.cipher = NULL;
+    } else if (EVP_PKEY_CTX_IS_GEN_OP(ctx)) {
+        if (ctx-&gt;op.keymgmt.genctx != NULL &amp;&amp; ctx-&gt;keymgmt != NULL)
+            evp_keymgmt_gen_cleanup(ctx-&gt;keymgmt, ctx-&gt;op.keymgmt.genctx);
     }
 #endif
 }
@@ -569,6 +572,12 @@ int EVP_PKEY_CTX_set_params(EVP_PKEY_CTX *ctx, OSSL_PARAM *params)
             &amp;&amp; ctx-&gt;op.ciph.cipher-&gt;set_ctx_params != NULL)
         return ctx-&gt;op.ciph.cipher-&gt;set_ctx_params(ctx-&gt;op.ciph.ciphprovctx,
                                                      params);
+    if (EVP_PKEY_CTX_IS_GEN_OP(ctx)
+        &amp;&amp; ctx-&gt;op.keymgmt.genctx != NULL
+        &amp;&amp; ctx-&gt;keymgmt != NULL
+        &amp;&amp; ctx-&gt;keymgmt-&gt;gen_set_params != NULL)
+        return evp_keymgmt_gen_set_params(ctx-&gt;keymgmt, ctx-&gt;op.keymgmt.genctx,
+                                          params);
     return 0;
 }
 
@@ -629,6 +638,10 @@ const OSSL_PARAM *EVP_PKEY_CTX_settable_params(EVP_PKEY_CTX *ctx)
             &amp;&amp; ctx-&gt;op.ciph.cipher != NULL
             &amp;&amp; ctx-&gt;op.ciph.cipher-&gt;settable_ctx_params != NULL)
         return ctx-&gt;op.ciph.cipher-&gt;settable_ctx_params();
+    if (EVP_PKEY_CTX_IS_GEN_OP(ctx)
+            &amp;&amp; ctx-&gt;keymgmt != NULL
+            &amp;&amp; ctx-&gt;keymgmt-&gt;gen_settable_params != NULL)
+        return evp_keymgmt_gen_settable_params(ctx-&gt;keymgmt);
 
     return NULL;
 }
@@ -859,6 +872,12 @@ static int legacy_ctrl_to_param(EVP_PKEY_CTX *ctx, int keytype, int optype,
             ERR_raise(ERR_LIB_EVP,
                       EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
             return -2;
+        case EVP_PKEY_CTRL_RSA_KEYGEN_BITS:
+            return EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, p1);
+        case EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP:
+            return EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, p2);
+        case EVP_PKEY_CTRL_RSA_KEYGEN_PRIMES:
+            return EVP_PKEY_CTX_set_rsa_keygen_primes(ctx, p1);
         }
     }
     return 0;
@@ -878,7 +897,9 @@ int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
             || (EVP_PKEY_CTX_IS_SIGNATURE_OP(ctx)
                 &amp;&amp; ctx-&gt;op.sig.sigprovctx != NULL)
             || (EVP_PKEY_CTX_IS_ASYM_CIPHER_OP(ctx)
-                &amp;&amp; ctx-&gt;op.ciph.ciphprovctx != NULL))
+                &amp;&amp; ctx-&gt;op.ciph.ciphprovctx != NULL)
+            || (EVP_PKEY_CTX_IS_GEN_OP(ctx)
+                &amp;&amp; ctx-&gt;op.keymgmt.genctx != NULL))
         return legacy_ctrl_to_param(ctx, keytype, optype, cmd, p1, p2);
 
     if (ctx-&gt;pmeth == NULL || ctx-&gt;pmeth-&gt;ctrl == NULL) {
@@ -930,6 +951,12 @@ static int legacy_ctrl_str_to_param(EVP_PKEY_CTX *ctx, const char *name,
         name = OSSL_ASYM_CIPHER_PARAM_OAEP_LABEL;
     else if (strcmp(name, &quot;rsa_pss_saltlen&quot;) == 0)
         name = OSSL_SIGNATURE_PARAM_PSS_SALTLEN;
+    else if (strcmp(name, &quot;rsa_keygen_bits&quot;) == 0)
+        name = OSSL_PKEY_PARAM_RSA_BITS;
+    else if (strcmp(name, &quot;rsa_keygen_pubexp&quot;) == 0)
+        name = OSSL_PKEY_PARAM_RSA_E;
+    else if (strcmp(name, &quot;rsa_keygen_primes&quot;) == 0)
+        name = OSSL_PKEY_PARAM_RSA_PRIMES;
 # ifndef OPENSSL_NO_DH
     else if (strcmp(name, &quot;dh_pad&quot;) == 0)
         name = OSSL_EXCHANGE_PARAM_PAD;
@@ -979,7 +1006,9 @@ int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx,
             || (EVP_PKEY_CTX_IS_SIGNATURE_OP(ctx)
                 &amp;&amp; ctx-&gt;op.sig.sigprovctx != NULL)
             || (EVP_PKEY_CTX_IS_ASYM_CIPHER_OP(ctx)
-                &amp;&amp; ctx-&gt;op.ciph.ciphprovctx != NULL))
+                &amp;&amp; ctx-&gt;op.ciph.ciphprovctx != NULL)
+            || (EVP_PKEY_CTX_IS_GEN_OP(ctx)
+                &amp;&amp; ctx-&gt;op.keymgmt.genctx != NULL))
         return legacy_ctrl_str_to_param(ctx, name, value);
 
     if (!ctx || !ctx-&gt;pmeth || !ctx-&gt;pmeth-&gt;ctrl_str) {
diff --git a/crypto/rsa/rsa_lib.c b/crypto/rsa/rsa_lib.c
index ada5388bb2..0a0d3e84db 100644
--- a/crypto/rsa/rsa_lib.c
+++ b/crypto/rsa/rsa_lib.c
@@ -20,6 +20,7 @@
 #include &lt;openssl/evp.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;internal/refcount.h&quot;
+#include &quot;internal/param_build.h&quot;
 #include &quot;crypto/bn.h&quot;
 #include &quot;crypto/evp.h&quot;
 #include &quot;crypto/rsa.h&quot;
@@ -1266,4 +1267,94 @@ int EVP_PKEY_CTX_get_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int *saltlen)
     return 1;
 
 }
+
+int EVP_PKEY_CTX_set_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int bits)
+{
+    OSSL_PARAM params[2], *p = params;
+    size_t bits2 = bits;
+
+    if (ctx == NULL || !EVP_PKEY_CTX_IS_GEN_OP(ctx)) {
+        ERR_raise(ERR_LIB_EVP, EVP_R_COMMAND_NOT_SUPPORTED);
+        /* Uses the same return values as EVP_PKEY_CTX_ctrl */
+        return -2;
+    }
+
+    /* If key type not RSA return error */
+    if (ctx-&gt;pmeth != NULL &amp;&amp; ctx-&gt;pmeth-&gt;pkey_id != EVP_PKEY_RSA)
+        return -1;
+
+    /* TODO(3.0): Remove this eventually when no more legacy */
+    if (ctx-&gt;op.keymgmt.genctx == NULL)
+        return EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_KEYGEN,
+                                 EVP_PKEY_CTRL_RSA_KEYGEN_BITS, bits, NULL);
+
+    *p++ = OSSL_PARAM_construct_size_t(OSSL_PKEY_PARAM_RSA_BITS, &amp;bits2);
+    *p++ = OSSL_PARAM_construct_end();
+
+    if (!EVP_PKEY_CTX_set_params(ctx, params))
+        return 0;
+
+    return 1;
+}
+
+int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx, BIGNUM *pubexp)
+{
+    OSSL_PARAM_BLD tmpl;
+    OSSL_PARAM *params;
+    int ret;
+
+    if (ctx == NULL || !EVP_PKEY_CTX_IS_GEN_OP(ctx)) {
+        ERR_raise(ERR_LIB_EVP, EVP_R_COMMAND_NOT_SUPPORTED);
+        /* Uses the same return values as EVP_PKEY_CTX_ctrl */
+        return -2;
+    }
+
+    /* If key type not RSA return error */
+    if (ctx-&gt;pmeth != NULL &amp;&amp; ctx-&gt;pmeth-&gt;pkey_id != EVP_PKEY_RSA)
+        return -1;
+
+    /* TODO(3.0): Remove this eventually when no more legacy */
+    if (ctx-&gt;op.keymgmt.genctx == NULL)
+        return EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_KEYGEN,
+                                 EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP, 0, pubexp);
+
+    ossl_param_bld_init(&amp;tmpl);
+    if (!ossl_param_bld_push_BN(&amp;tmpl, OSSL_PKEY_PARAM_RSA_E, pubexp)
+        || (params = ossl_param_bld_to_param(&amp;tmpl)) == NULL)
+        return 0;
+
+    ret = EVP_PKEY_CTX_set_params(ctx, params);
+    ossl_param_bld_free(params);
+    return ret;
+}
+
+int EVP_PKEY_CTX_set_rsa_keygen_primes(EVP_PKEY_CTX *ctx, int primes)
+{
+    OSSL_PARAM params[2], *p = params;
+    size_t primes2 = primes;
+
+    if (ctx == NULL || !EVP_PKEY_CTX_IS_GEN_OP(ctx)) {
+        ERR_raise(ERR_LIB_EVP, EVP_R_COMMAND_NOT_SUPPORTED);
+        /* Uses the same return values as EVP_PKEY_CTX_ctrl */
+        return -2;
+    }
+
+    /* If key type not RSA return error */
+    if (ctx-&gt;pmeth != NULL &amp;&amp; ctx-&gt;pmeth-&gt;pkey_id != EVP_PKEY_RSA)
+        return -1;
+
+    /* TODO(3.0): Remove this eventually when no more legacy */
+    if (ctx-&gt;op.keymgmt.genctx == NULL)
+        return EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_KEYGEN,
+                                 EVP_PKEY_CTRL_RSA_KEYGEN_PRIMES, primes,
+                                 NULL);
+
+    *p++ = OSSL_PARAM_construct_size_t(OSSL_PKEY_PARAM_RSA_PRIMES, &amp;primes2);
+    *p++ = OSSL_PARAM_construct_end();
+
+    if (!EVP_PKEY_CTX_set_params(ctx, params))
+        return 0;
+
+    return 1;
+}
 #endif
diff --git a/doc/man3/EVP_PKEY_keygen.pod b/doc/man3/EVP_PKEY_gen.pod
similarity index 65%
rename from doc/man3/EVP_PKEY_keygen.pod
rename to doc/man3/EVP_PKEY_gen.pod
index e326b82ffa..212ea2a742 100644
--- a/doc/man3/EVP_PKEY_keygen.pod
+++ b/doc/man3/EVP_PKEY_gen.pod
@@ -2,11 +2,12 @@
 
 =head1 NAME
 
-EVP_PKEY_keygen_init, EVP_PKEY_keygen, EVP_PKEY_paramgen_init,
-EVP_PKEY_paramgen, EVP_PKEY_CTX_set_cb, EVP_PKEY_CTX_get_cb,
+EVP_PKEY_keygen_init, EVP_PKEY_paramgen_init, EVP_PKEY_gen,
+EVP_PKEY_CTX_set_cb, EVP_PKEY_CTX_get_cb,
 EVP_PKEY_CTX_get_keygen_info, EVP_PKEY_CTX_set_app_data,
 EVP_PKEY_CTX_get_app_data,
-EVP_PKEY_gen_cb
+EVP_PKEY_gen_cb,
+EVP_PKEY_paramgen, EVP_PKEY_keygen
 - key and parameter generation and check functions
 
 =head1 SYNOPSIS
@@ -14,9 +15,10 @@ EVP_PKEY_gen_cb
  #include &lt;openssl/evp.h&gt;
 
  int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);
- int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
  int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);
+ int EVP_PKEY_gen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
  int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
+ int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
 
  typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);
 
@@ -30,24 +32,51 @@ EVP_PKEY_gen_cb
 
 =head1 DESCRIPTION
 
-The EVP_PKEY_keygen_init() function initializes a public key algorithm
-context using key B&lt;pkey&gt; for a key generation operation.
+Generating keys is sometimes straight forward, just generate the key's
+numbers and be done with it.  However, there are certain key types that need
+key parameters, often called domain parameters but not necessarily limited
+to that, that also need to be generated.  In addition to this, the caller
+may want to set user provided generation parameters that further affect key
+parameter or key generation, such as the desired key size.
+
+To flexibly allow all that's just been described, key parameter and key
+generation is divided into an initialization of a key algorithm context,
+functions to set user provided parameters, and finally the key parameter or
+key generation function itself.
+
+The key algorithm context must be created using L&lt;EVP_PKEY_CTX_new(3)&gt; or
+variants thereof, see that manual for details.
+
+EVP_PKEY_keygen_init() initializes a public key algorithm context using key
+I&lt;pkey&gt; for a key generation operation.
+
+EVP_PKEY_paramgen_init() is similar to EVP_PKEY_keygen_init() except key
+parameters are generated.
 
-The EVP_PKEY_keygen() function performs a key generation operation, the
-generated key is written to B&lt;ppkey&gt;.
+After initialization, generation parameters may be provided with
+L&lt;EVP_PKEY_CTX_ctrl(3)&gt; or L&lt;EVP_PKEY_CTX_set_params(3)&gt;, or any other
+function described in those manuals.
 
-The functions EVP_PKEY_paramgen_init() and EVP_PKEY_paramgen() are similar
-except parameters are generated.
+EVP_PKEY_gen() performs the generation operation, the resulting key
+parameters or key are written to I&lt;*ppkey&gt;.  If I&lt;*ppkey&gt; is NULL when this
+function is called, it will be allocated, and should be freed by the caller
+when no longer useful, using L&lt;EVP_PKEY_free(3)&gt;.
+
+EVP_PKEY_paramgen() and EVP_PKEY_keygen() do exactly the same thing as
+EVP_PKEY_gen(), after checking that the corresponding EVP_PKEY_paramgen_init()
+or EVP_PKEY_keygen_init() was used to initialize I&lt;ctx&gt;.
+These are older functions that are kept for backward compatibility.
+It is safe to use EVP_PKEY_gen() instead.
 
 The function EVP_PKEY_set_cb() sets the key or parameter generation callback
-to B&lt;cb&gt;. The function EVP_PKEY_CTX_get_cb() returns the key or parameter
+to I&lt;cb&gt;. The function EVP_PKEY_CTX_get_cb() returns the key or parameter
 generation callback.
 
 The function EVP_PKEY_CTX_get_keygen_info() returns parameters associated
-with the generation operation. If B&lt;idx&gt; is -1 the total number of
+with the generation operation. If I&lt;idx&gt; is -1 the total number of
 parameters available is returned. Any non negative value returns the value of
 that parameter. EVP_PKEY_CTX_gen_keygen_info() with a non-negative value for
-B&lt;idx&gt; should only be called within the generation callback.
+I&lt;idx&gt; should only be called within the generation callback.
 
 If the callback returns 0 then the key generation operation is aborted and an
 error occurs. This might occur during a time consuming operation where
@@ -58,6 +87,13 @@ and retrieve an opaque pointer. This can be used to set some application
 defined value which can be retrieved in the callback: for example a handle
 which is used to update a &quot;progress dialog&quot;.
 
+=head1 RETURN VALUES
+
+EVP_PKEY_keygen_init(), EVP_PKEY_paramgen_init(), EVP_PKEY_keygen() and
+EVP_PKEY_paramgen() return 1 for success and 0 or a negative value for failure.
+In particular a return value of -2 indicates the operation is not supported by
+the public key algorithm.
+
 =head1 NOTES
 
 After the call to EVP_PKEY_keygen_init() or EVP_PKEY_paramgen_init() algorithm
@@ -82,13 +118,6 @@ public key components and parameters (if any). An OpenSSL private key is
 equivalent to what some libraries call a &quot;key pair&quot;. A private key can be used
 in functions which require the use of a public key or parameters.
 
-=head1 RETURN VALUES
-
-EVP_PKEY_keygen_init(), EVP_PKEY_paramgen_init(), EVP_PKEY_keygen() and
-EVP_PKEY_paramgen() return 1 for success and 0 or a negative value for failure.
-In particular a return value of -2 indicates the operation is not supported by
-the public key algorithm.
-
 =head1 EXAMPLES
 
 Generate a 2048 bit RSA key:
@@ -168,11 +197,17 @@ L&lt;EVP_PKEY_derive(3)&gt;
 
 =head1 HISTORY
 
-These functions were added in OpenSSL 1.0.0.
+EVP_PKEY_keygen_init(), int EVP_PKEY_paramgen_init(), EVP_PKEY_keygen(),
+EVP_PKEY_paramgen(), EVP_PKEY_gen_cb(), EVP_PKEY_CTX_set_cb(),
+EVP_PKEY_CTX_get_cb(), EVP_PKEY_CTX_get_keygen_info(),
+EVP_PKEY_CTX_set_app_data() and EVP_PKEY_CTX_get_app_data() were added in
+OpenSSL 1.0.0.
+
+EVP_PKEY_gen() was added in OpenSSL 3.0.
 
 =head1 COPYRIGHT
 
-Copyright 2006-2018 The OpenSSL Project Authors. All Rights Reserved.
+Copyright 2006-2020 The OpenSSL Project Authors. All Rights Reserved.
 
 Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
 this file except in compliance with the License.  You can obtain a copy
diff --git a/doc/man7/provider-keymgmt.pod b/doc/man7/provider-keymgmt.pod
index 0a2768b5db..59e538dbac 100644
--- a/doc/man7/provider-keymgmt.pod
+++ b/doc/man7/provider-keymgmt.pod
@@ -18,6 +18,13 @@ provider-keymgmt - The KEYMGMT library E&lt;lt&gt;-E&lt;gt&gt; provider functions
  void *OP_keymgmt_new(void *provctx);
  void OP_keymgmt_free(void *keydata);
 
+ void *OP_keymgmt_gen_init(void *provctx, int selection);
+ int OP_keymgmt_gen_set_template(void *genctx, void *template);
+ int OP_keymgmt_gen_set_params(void *genctx, const OSSL_PARAM params[]);
+ const OSSL_PARAM *OP_keymgmt_gen_settable_params(void *provctx);
+ void *OP_keymgmt_gen(void *genctx, OSSL_CALLBACK *cb, void *cbarg);
+ void OP_keymgmt_gen_cleanup(void *genctx);
+
  /* Key object information */
  int OP_keymgmt_get_params(void *keydata, OSSL_PARAM params[]);
  const OSSL_PARAM *OP_keymgmt_gettable_params(void);
@@ -80,6 +87,13 @@ macros in L&lt;openssl-core_numbers.h(7)&gt;, as follows:
  OP_keymgmt_new                  OSSL_FUNC_KEYMGMT_NEW
  OP_keymgmt_free                 OSSL_FUNC_KEYMGMT_FREE
 
+ OP_keymgmt_gen_init             OSSL_FUNC_KEYMGMT_GEN_INIT
+ OP_keymgmt_gen_set_template     OSSL_FUNC_KEYMGMT_GEN_SET_TEMPLATE
+ OP_keymgmt_gen_set_params       OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS
+ OP_keymgmt_gen_settable_params  OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS
+ OP_keymgmt_gen                  OSSL_FUNC_KEYMGMT_GEN
+ OP_keymgmt_gen_cleanup          OSSL_FUNC_KEYMGMT_GEN_CLEANUP
+
  OP_keymgmt_get_params           OSSL_FUNC_KEYMGMT_GET_PARAMS
  OP_keymgmt_gettable_params      OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS
  OP_keymgmt_set_params           OSSL_FUNC_KEYMGMT_SET_PARAMS
@@ -193,12 +207,41 @@ key object, but that is not mandatory.
 
 OP_keymgmt_free() should free the passed I&lt;keydata&gt;.
 
-The constructor and destructor are mandatory, a KEYMGMT implementation
-without them will not be accepted.
+OP_keymgmt_gen_init(), OP_keymgmt_gen_set_template(),
+OP_keymgmt_gen_set_params(), OP_keymgmt_gen_settable_params(),
+OP_keymgmt_gen() and OP_keymgmt_gen_cleanup() work together as a more
+elaborate context based key object constructor.
+
+OP_keymgmt_gen_init() should create the key object generation context
+and initialize it with I&lt;selections&gt;, which will determine what kind
+of contents the key object to be generated should get.
+
+OP_keymgmt_gen_set_template() should add I&lt;template&gt; to the context
+I&lt;genctx&gt;.  The I&lt;template&gt; is assumed to be a key object constructed
+with the same KEYMGMT, and from which content that the implementation
+chooses can be used as a template for the key object to be generated.
+Typically, the generation of a DSA or DH key would get the domain
+parameters from this I&lt;template&gt;.
+
+OP_keymgmt_gen_set_params() should set additional parameters from
+I&lt;params&gt; in the key object generation context I&lt;genctx&gt;.
+
+OP_keymgmt_gen_settable_params() should return a constant array of
+descriptor B&lt;OSSL_PARAM&gt;, for parameters that OP_keymgmt_gen_set_params() 
+can handle.
+
+OP_keymgmt_gen() should perform the key object generation itself, and
+return the result.  The callback I&lt;cb&gt; should be called at regular
+intervals with indications on how the key object generation
+progresses.
+
+OP_keymgmt_gen_cleanup() should clean up and free the key object
+generation context I&lt;genctx&gt;
 
-=for comment when new constructors appear, it's sufficient if only one
-of them is present.  The remark above will have to change to reflect
-that.
+At least one of OP_keymgmt_new() and OP_keymgmt_gen() are mandatory,
+as well as OP_keymgmt_free().  Additionally, if OP_keymgmt_gen() is
+present, OP_keymgmt_gen_init() and OP_keymgmt_gen_cleanup() must be
+present as well.
 
 =head2 Key Object Information Functions
 
diff --git a/include/crypto/evp.h b/include/crypto/evp.h
index 7da0258279..744731aefe 100644
--- a/include/crypto/evp.h
+++ b/include/crypto/evp.h
@@ -34,6 +34,10 @@ struct evp_pkey_ctx_st {
     EVP_KEYMGMT *keymgmt;
 
     union {
+        struct {
+            void *genctx;
+        } keymgmt;
+
         struct {
             EVP_KEYEXCH *exchange;
             void *exchprovctx;
@@ -50,6 +54,14 @@ struct evp_pkey_ctx_st {
         } ciph;
     } op;
 
+    /* Application specific data, usually used by the callback */
+    void *app_data;
+    /* Keygen callback */
+    EVP_PKEY_gen_cb *pkey_gencb;
+    /* implementation specific keygen data */
+    int *keygen_info;
+    int keygen_info_count;
+
     /* Legacy fields below */
 
     /* Method associated with this operation */
@@ -62,13 +74,6 @@ struct evp_pkey_ctx_st {
     EVP_PKEY *peerkey;
     /* Algorithm specific data */
     void *data;
-    /* Application specific data */
-    void *app_data;
-    /* Keygen callback */
-    EVP_PKEY_gen_cb *pkey_gencb;
-    /* implementation specific keygen data */
-    int *keygen_info;
-    int keygen_info_count;
 } /* EVP_PKEY_CTX */ ;
 
 #define EVP_PKEY_FLAG_DYNAMIC   1
@@ -596,6 +601,10 @@ struct evp_pkey_st {
     ((ctx)-&gt;operation == EVP_PKEY_OP_ENCRYPT \
      || (ctx)-&gt;operation == EVP_PKEY_OP_DECRYPT)
 
+#define EVP_PKEY_CTX_IS_GEN_OP(ctx) \
+    ((ctx)-&gt;operation == EVP_PKEY_OP_PARAMGEN \
+     || (ctx)-&gt;operation == EVP_PKEY_OP_KEYGEN)
+
 void openssl_add_all_ciphers_int(void);
 void openssl_add_all_digests_int(void);
 void evp_cleanup_int(void);
@@ -606,6 +615,9 @@ void *evp_pkey_export_to_provider(EVP_PKEY *pk, OPENSSL_CTX *libctx,
 void *evp_pkey_upgrade_to_provider(EVP_PKEY *pk, OPENSSL_CTX *libctx,
                                    EVP_KEYMGMT **keymgmt,
                                    const char *propquery);
+#ifndef FIPS_MODE
+void evp_pkey_free_legacy(EVP_PKEY *x);
+#endif
 
 /*
  * KEYMGMT utility functions
@@ -622,6 +634,8 @@ void *evp_keymgmt_util_fromdata(EVP_PKEY *target, EVP_KEYMGMT *keymgmt,
 int evp_keymgmt_util_has(EVP_PKEY *pk, int selection);
 int evp_keymgmt_util_match(EVP_PKEY *pk1, EVP_PKEY *pk2, int selection);
 int evp_keymgmt_util_copy(EVP_PKEY *to, EVP_PKEY *from, int selection);
+void *evp_keymgmt_util_gen(EVP_PKEY *target, EVP_KEYMGMT *keymgmt,
+                           void *genctx, OSSL_CALLBACK *cb, void *cbarg);
 
 
 /*
@@ -636,6 +650,16 @@ int evp_keymgmt_set_params(const EVP_KEYMGMT *keymgmt,
                            void *keydata, const OSSL_PARAM params[]);
 const OSSL_PARAM *evp_keymgmt_settable_params(const EVP_KEYMGMT *keymgmt);
 
+void *evp_keymgmt_gen_init(const EVP_KEYMGMT *keymgmt, int selection);
+int evp_keymgmt_gen_set_template(const EVP_KEYMGMT *keymgmt, void *genctx,
+                                 void *template);
+int evp_keymgmt_gen_set_params(const EVP_KEYMGMT *keymgmt, void *genctx,
+                               const OSSL_PARAM params[]);
+const OSSL_PARAM *
+evp_keymgmt_gen_settable_params(const EVP_KEYMGMT *keymgmt);
+void *evp_keymgmt_gen(const EVP_KEYMGMT *keymgmt, void *genctx,
+                      OSSL_CALLBACK *cb, void *cbarg);
+void evp_keymgmt_gen_cleanup(const EVP_KEYMGMT *keymgmt, void *genctx);
 
 int evp_keymgmt_has(const EVP_KEYMGMT *keymgmt, void *keyddata, int selection);
 int evp_keymgmt_validate(const EVP_KEYMGMT *keymgmt, void *keydata,
diff --git a/include/openssl/core_names.h b/include/openssl/core_names.h
index 5e3a13a34b..1f67475a9a 100644
--- a/include/openssl/core_names.h
+++ b/include/openssl/core_names.h
@@ -220,6 +220,9 @@ extern &quot;C&quot; {
 #define OSSL_PKEY_PARAM_RSA_FACTOR      &quot;rsa-factor&quot;
 #define OSSL_PKEY_PARAM_RSA_EXPONENT    &quot;rsa-exponent&quot;
 #define OSSL_PKEY_PARAM_RSA_COEFFICIENT &quot;rsa-coefficient&quot;
+/* Key generation parameters */
+#define OSSL_PKEY_PARAM_RSA_BITS        OSSL_PKEY_PARAM_BITS
+#define OSSL_PKEY_PARAM_RSA_PRIMES      &quot;primes&quot;
 
 /* Key Exchange parameters */
 
@@ -279,6 +282,10 @@ extern &quot;C&quot; {
 /* Passphrase callback parameters */
 #define OSSL_PASSPHRASE_PARAM_INFO              &quot;info&quot;
 
+/* Keygen callback parameters, from provider to libcrypto */
+#define OSSL_GEN_PARAM_POTENTIAL            &quot;potential&quot; /* integer */
+#define OSSL_GEN_PARAM_ITERATION            &quot;iteration&quot; /* integer */
+
 # ifdef __cplusplus
 }
 # endif
diff --git a/include/openssl/core_numbers.h b/include/openssl/core_numbers.h
index c65041894a..dfca646c73 100644
--- a/include/openssl/core_numbers.h
+++ b/include/openssl/core_numbers.h
@@ -380,10 +380,31 @@ OSSL_CORE_MAKE_FUNC(int, OP_kdf_set_ctx_params,
 # define OSSL_KEYMGMT_SELECT_ALL                \
     ( OSSL_KEYMGMT_SELECT_KEYPAIR | OSSL_KEYMGMT_SELECT_ALL_PARAMETERS )
 
-/* Basic key object creation, destruction */
+/* Basic key object creation */
 # define OSSL_FUNC_KEYMGMT_NEW                         1
-# define OSSL_FUNC_KEYMGMT_FREE                        9
 OSSL_CORE_MAKE_FUNC(void *, OP_keymgmt_new, (void *provctx))
+
+/* Generation, a more complex constructor */
+# define OSSL_FUNC_KEYMGMT_GEN_INIT                    3
+# define OSSL_FUNC_KEYMGMT_GEN_SET_TEMPLATE            4
+# define OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS              5
+# define OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS         6
+# define OSSL_FUNC_KEYMGMT_GEN                         7
+# define OSSL_FUNC_KEYMGMT_GEN_CLEANUP                 8
+OSSL_CORE_MAKE_FUNC(void *, OP_keymgmt_gen_init,
+                    (void *provctx, int selection))
+OSSL_CORE_MAKE_FUNC(int, OP_keymgmt_gen_set_template,
+                    (void *genctx, void *templ))
+OSSL_CORE_MAKE_FUNC(int, OP_keymgmt_gen_set_params,
+                    (void *genctx, const OSSL_PARAM params[]))
+OSSL_CORE_MAKE_FUNC(const OSSL_PARAM *,
+                    OP_keymgmt_gen_settable_params, (void *provctx))
+OSSL_CORE_MAKE_FUNC(void *, OP_keymgmt_gen,
+                    (void *genctx, OSSL_CALLBACK *cb, void *cbarg))
+OSSL_CORE_MAKE_FUNC(void, OP_keymgmt_gen_cleanup, (void *genctx))
+
+/* Basic key object destruction */
+# define OSSL_FUNC_KEYMGMT_FREE                        9
 OSSL_CORE_MAKE_FUNC(void, OP_keymgmt_free, (void *keydata))
 
 /* Key object information, with discovery */
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 202675cc70..a3e0581913 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -1596,6 +1596,7 @@ int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
 int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
+int EVP_PKEY_gen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
 int EVP_PKEY_check(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_public_check(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_param_check(EVP_PKEY_CTX *ctx);
diff --git a/include/openssl/rsa.h b/include/openssl/rsa.h
index 1f0687df24..49040bf7e6 100644
--- a/include/openssl/rsa.h
+++ b/include/openssl/rsa.h
@@ -111,6 +111,10 @@ int EVP_PKEY_CTX_get_rsa_padding(EVP_PKEY_CTX *ctx, int *pad_mode);
 int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int saltlen);
 int EVP_PKEY_CTX_get_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int *saltlen);
 
+int EVP_PKEY_CTX_set_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int bits);
+int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx, BIGNUM *pubexp);
+int EVP_PKEY_CTX_set_rsa_keygen_primes(EVP_PKEY_CTX *ctx, int primes);
+
 /* Salt length matches digest */
 #  define RSA_PSS_SALTLEN_DIGEST -1
 /* Verify only: auto detect salt length */
@@ -124,18 +128,6 @@ int EVP_PKEY_CTX_get_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int *saltlen);
         EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA_PSS, EVP_PKEY_OP_KEYGEN, \
                           EVP_PKEY_CTRL_RSA_PSS_SALTLEN, len, NULL)
 
-#  define EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, bits) \
-        RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_KEYGEN, \
-                          EVP_PKEY_CTRL_RSA_KEYGEN_BITS, bits, NULL)
-
-#  define EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, pubexp) \
-        RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_KEYGEN, \
-                          EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP, 0, pubexp)
-
-#  define EVP_PKEY_CTX_set_rsa_keygen_primes(ctx, primes) \
-        RSA_pkey_ctx_ctrl(ctx, EVP_PKEY_OP_KEYGEN, \
-                          EVP_PKEY_CTRL_RSA_KEYGEN_PRIMES, primes, NULL)
-
 int EVP_PKEY_CTX_set_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
 int EVP_PKEY_CTX_set_rsa_mgf1_md_name(EVP_PKEY_CTX *ctx, const char *mdname,
                                       const char *mdprops);
diff --git a/providers/implementations/keymgmt/rsa_kmgmt.c b/providers/implementations/keymgmt/rsa_kmgmt.c
index 8c7673ad49..4e77f5c4a7 100644
--- a/providers/implementations/keymgmt/rsa_kmgmt.c
+++ b/providers/implementations/keymgmt/rsa_kmgmt.c
@@ -28,6 +28,11 @@
 #include &quot;crypto/rsa.h&quot;
 
 static OSSL_OP_keymgmt_new_fn rsa_newdata;
+static OSSL_OP_keymgmt_gen_init_fn rsa_gen_init;
+static OSSL_OP_keymgmt_gen_set_params_fn rsa_gen_set_params;
+static OSSL_OP_keymgmt_gen_settable_params_fn rsa_gen_settable_params;
+static OSSL_OP_keymgmt_gen_fn rsa_gen;
+static OSSL_OP_keymgmt_gen_cleanup_fn rsa_gen_cleanup;
 static OSSL_OP_keymgmt_free_fn rsa_freedata;
 static OSSL_OP_keymgmt_get_params_fn rsa_get_params;
 static OSSL_OP_keymgmt_gettable_params_fn rsa_gettable_params;
@@ -409,8 +414,127 @@ static int rsa_validate(void *keydata, int selection)
     return ok;
 }
 
+struct rsa_gen_ctx {
+    OPENSSL_CTX *libctx;
+
+    size_t nbits;
+    BIGNUM *pub_exp;
+    size_t primes;
+
+    /* For generation callback */
+    OSSL_CALLBACK *cb;
+    void *cbarg;
+};
+
+static int rsa_gencb(int p, int n, BN_GENCB *cb)
+{
+    struct rsa_gen_ctx *gctx = BN_GENCB_get_arg(cb);
+    OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END, OSSL_PARAM_END };
+
+    params[0] = OSSL_PARAM_construct_int(OSSL_GEN_PARAM_POTENTIAL, &amp;p);
+    params[1] = OSSL_PARAM_construct_int(OSSL_GEN_PARAM_ITERATION, &amp;n);
+
+    return gctx-&gt;cb(params, gctx-&gt;cbarg);
+}
+
+static void *rsa_gen_init(void *provctx, int selection)
+{
+    OPENSSL_CTX *libctx = PROV_LIBRARY_CONTEXT_OF(provctx);
+    struct rsa_gen_ctx *gctx = NULL;
+
+    if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR) == 0)
+        return NULL;
+
+    if ((gctx = OPENSSL_zalloc(sizeof(*gctx))) != NULL) {
+        gctx-&gt;libctx = libctx;
+        if ((gctx-&gt;pub_exp = BN_new()) == NULL
+            || !BN_set_word(gctx-&gt;pub_exp, RSA_F4)) {
+            BN_free(gctx-&gt;pub_exp);
+            gctx = NULL;
+        } else {
+            gctx-&gt;nbits = 2048;
+            gctx-&gt;primes = RSA_DEFAULT_PRIME_NUM;
+        }
+    }
+    return gctx;
+}
+
+static int rsa_gen_set_params(void *genctx, const OSSL_PARAM params[])
+{
+    struct rsa_gen_ctx *gctx = genctx;
+    const OSSL_PARAM *p;
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_BITS)) != NULL
+        &amp;&amp; !OSSL_PARAM_get_size_t(p, &amp;gctx-&gt;nbits))
+        return 0;
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_PRIMES)) != NULL
+        &amp;&amp; !OSSL_PARAM_get_size_t(p, &amp;gctx-&gt;primes))
+        return 0;
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_E)) != NULL
+        &amp;&amp; !OSSL_PARAM_get_BN(p, &amp;gctx-&gt;pub_exp))
+        return 0;
+    return 1;
+}
+
+static const OSSL_PARAM *rsa_gen_settable_params(void *provctx)
+{
+    static OSSL_PARAM settable[] = {
+        OSSL_PARAM_size_t(OSSL_PKEY_PARAM_RSA_BITS, NULL),
+        OSSL_PARAM_size_t(OSSL_PKEY_PARAM_RSA_PRIMES, NULL),
+        OSSL_PARAM_BN(OSSL_PKEY_PARAM_RSA_E, NULL, 0),
+        OSSL_PARAM_END
+    };
+
+    return settable;
+}
+
+static void *rsa_gen(void *genctx, OSSL_CALLBACK *osslcb, void *cbarg)
+{
+    struct rsa_gen_ctx *gctx = genctx;
+    RSA *rsa = NULL;
+    BN_GENCB *gencb = NULL;
+
+    if (gctx == NULL
+        || (rsa = rsa_new_with_ctx(gctx-&gt;libctx)) == NULL)
+        return NULL;
+
+    gctx-&gt;cb = osslcb;
+    gctx-&gt;cbarg = cbarg;
+    gencb = BN_GENCB_new();
+    if (gencb != NULL)
+        BN_GENCB_set(gencb, rsa_gencb, genctx);
+
+    if (!RSA_generate_multi_prime_key(rsa, (int)gctx-&gt;nbits, (int)gctx-&gt;primes,
+                                      gctx-&gt;pub_exp, gencb)) {
+        RSA_free(rsa);
+        rsa = NULL;
+    }
+
+    BN_GENCB_free(gencb);
+
+    return rsa;
+}
+
+static void rsa_gen_cleanup(void *genctx)
+{
+    struct rsa_gen_ctx *gctx = genctx;
+
+    if (gctx == NULL)
+        return;
+
+    BN_clear_free(gctx-&gt;pub_exp);
+    OPENSSL_free(gctx);
+}
+
 const OSSL_DISPATCH rsa_keymgmt_functions[] = {
     { OSSL_FUNC_KEYMGMT_NEW, (void (*)(void))rsa_newdata },
+    { OSSL_FUNC_KEYMGMT_GEN_INIT, (void (*)(void))rsa_gen_init },
+    { OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS,
+      (void (*)(void))rsa_gen_set_params },
+    { OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS,
+      (void (*)(void))rsa_gen_settable_params },
+    { OSSL_FUNC_KEYMGMT_GEN, (void (*)(void))rsa_gen },
+    { OSSL_FUNC_KEYMGMT_GEN_CLEANUP, (void (*)(void))rsa_gen_cleanup },
     { OSSL_FUNC_KEYMGMT_FREE, (void (*)(void))rsa_freedata },
     { OSSL_FUNC_KEYMGMT_GET_PARAMS, (void (*) (void))rsa_get_params },
     { OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS, (void (*) (void))rsa_gettable_params },
diff --git a/test/evp_test.c b/test/evp_test.c
index 63ae144920..0f2720807a 100644
--- a/test/evp_test.c
+++ b/test/evp_test.c
@@ -2504,8 +2504,8 @@ static int keygen_test_run(EVP_TEST *t)
 {
     KEYGEN_TEST_DATA *keygen = t-&gt;data;
     EVP_PKEY *pkey = NULL;
+    int rv = 1;
 
-    t-&gt;err = NULL;
     if (EVP_PKEY_keygen(keygen-&gt;genctx, &amp;pkey) &lt;= 0) {
         t-&gt;err = &quot;KEYGEN_GENERATE_ERROR&quot;;
         goto err;
@@ -2514,6 +2514,7 @@ static int keygen_test_run(EVP_TEST *t)
     if (keygen-&gt;keyname != NULL) {
         KEY_LIST *key;
 
+        rv = 0;
         if (find_key(NULL, keygen-&gt;keyname, private_keys)) {
             TEST_info(&quot;Duplicate key %s&quot;, keygen-&gt;keyname);
             goto err;
@@ -2526,15 +2527,15 @@ static int keygen_test_run(EVP_TEST *t)
         key-&gt;key = pkey;
         key-&gt;next = private_keys;
         private_keys = key;
+        rv = 1;
     } else {
         EVP_PKEY_free(pkey);
     }
 
-    return 1;
+    t-&gt;err = NULL;
 
 err:
-    EVP_PKEY_free(pkey);
-    return 0;
+    return rv;
 }
 
 static const EVP_TEST_METHOD keygen_test_method = {
diff --git a/test/recipes/30-test_evp_data/evppkey.txt b/test/recipes/30-test_evp_data/evppkey.txt
index e649e92c3f..8429213d25 100644
--- a/test/recipes/30-test_evp_data/evppkey.txt
+++ b/test/recipes/30-test_evp_data/evppkey.txt
@@ -18563,7 +18563,7 @@ KeyGen = rsaEncryption
 Availablein = default
 Ctrl = rsa_keygen_bits:128
 KeyName = tmprsa
-Result = PKEY_CTRL_INVALID
+Result = KEYGEN_GENERATE_ERROR
 Reason = key size too small
 
 # RSA-PSS with restrictions, should succeed.
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 15dd512a49..30978d2fb0 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4980,3 +4980,7 @@ OSSL_CMP_SRV_CTX_set_send_unprotected_errors ?	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_SRV_CTX_set_accept_unprotected ?	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_SRV_CTX_set_accept_raverified  ?	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_SRV_CTX_set_grant_implicit_confirm ?	3_0_0	EXIST::FUNCTION:CMP
+EVP_PKEY_gen                            ?	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_CTX_set_rsa_keygen_bits        ?	3_0_0	EXIST::FUNCTION:RSA
+EVP_PKEY_CTX_set_rsa_keygen_pubexp      ?	3_0_0	EXIST::FUNCTION:RSA
+EVP_PKEY_CTX_set_rsa_keygen_primes      ?	3_0_0	EXIST::FUNCTION:RSA
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027881.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="027885.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27883">[ date ]</a>
              <a href="thread.html#27883">[ thread ]</a>
              <a href="subject.html#27883">[ subject ]</a>
              <a href="author.html#27883">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
