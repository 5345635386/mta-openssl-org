<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-March/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1583748229.011453.26304.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="027847.html">
   <LINK REL="Next"  HREF="027857.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>dev at ddvo.net</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1583748229.011453.26304.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">dev at ddvo.net
       </A><BR>
    <I>Mon Mar  9 10:03:49 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="027847.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="027857.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27848">[ date ]</a>
              <a href="thread.html#27848">[ thread ]</a>
              <a href="subject.html#27848">[ subject ]</a>
              <a href="author.html#27848">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  99a16e0459e5089c2cfb92ee775f1221a51b8d05 (commit)
      from  c518117b99bc4aad62990e8a31b7bc1dae06d16c (commit)


- Log -----------------------------------------------------------------
commit 99a16e0459e5089c2cfb92ee775f1221a51b8d05
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Mon Mar 9 11:03:21 2020 +0100

    Renew and extend the tool for checking adherence to C coding style rules
    
    aims at checking most of <A HREF="https://www.openssl.org/policies/codingstyle.html">https://www.openssl.org/policies/codingstyle.html</A>
    and various requirements not yet explicitly stated there - see also #10725
    
    add util/check-format.pl and its self-tests in
    util/check-format-test-{positives,negatives}.c
    remove util/openssl-format-source
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">david.von.oheimb at siemens.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10363">https://github.com/openssl/openssl/pull/10363</A>)

-----------------------------------------------------------------------

Summary of changes:
 util/check-format-test-negatives.c |  678 ++++++++++++++++++++++
 util/check-format-test-positives.c |  345 +++++++++++
 util/check-format.pl               | 1118 ++++++++++++++++++++++++++++++++++++
 util/openssl-format-source         |  175 ------
 4 files changed, 2141 insertions(+), 175 deletions(-)
 create mode 100644 util/check-format-test-negatives.c
 create mode 100644 util/check-format-test-positives.c
 create mode 100644 util/check-format.pl
 delete mode 100755 util/openssl-format-source

diff --git a/util/check-format-test-negatives.c b/util/check-format-test-negatives.c
new file mode 100644
index 0000000000..c9f781e06b
--- /dev/null
+++ b/util/check-format-test-negatives.c
@@ -0,0 +1,678 @@
+/*
+ * Copyright 2007-2019 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright Nokia 2007-2019
+ * Copyright Siemens AG 2015-2019
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+/*
+ * A collection of test cases where check-format.pl should not report issues.
+ * There are some known false positives, though, which are marked below.
+ */
+
+/*-
+ * allow double space  in format-tagged multi-line comment
+ */
+int f(void) /*
+             * trailing multi-line comment
+             */
+{
+    if (ctx == NULL) { /* non-leading intra-line comment */
+        if (pem_name != NULL)
+            /* entire-line comment indent usually like for the following line */
+            return NULL; /* hanging indent also for this line after comment */
+        /* leading comment has same indentation as normal code */ stmt;
+        /* entire-line comment may have same indent as normal code */
+    }
+
+#if X
+    if (1) /* bad style: just part of control structure depends on #if */
+#else
+    if (2) /*@ resulting false positive */
+#endif
+        c; /*@ resulting false positive */
+
+    if (1)
+        if (2)
+            c;
+        else
+            e;
+    else
+        f;
+    do
+        do
+            2;
+        while (1);
+    while (2);
+
+    if (1)
+        f(a, b);
+    do
+        1; while (2); /*@ more than one stmt just to construct case */
+    if (1)
+        f(a, b);
+    else
+        do
+            1;
+        while (2);
+    if (1)
+        f(a, b);
+    else do /*@ (non-brace) code before 'do' just to construct case */
+             1;
+        while (2);
+    f1234(a,
+          b); do /*@ (non-brace) code before 'do' just to construct case */
+                  1;
+    while (2);
+    if (1)
+        f(a,
+          b); do /*@ (non-brace) code before 'do' just to construct case */
+                  1;
+    while (2);
+    if (1)
+        f(a, b);
+    else
+        do f(c, c); /*@ (non-brace) code after 'do' just to construct case */
+        while (2);
+
+    if (1)
+        f(a, b);
+    else
+        return;
+    if (1)
+        f(a,
+          b); else /*@ (non-brace) code before 'else' just to construct case */
+        do
+            1;
+        while (2);
+
+    if (1)
+    { /*@ brace after 'if' not on same line just to construct case */
+        c;
+        d;
+    }
+    /* this comment is correctly indented if it refers to the following line */
+    d;
+
+    if (1) {
+        2;
+    } else /*@ no brace after 'else' just to construct case */
+        3;
+    do {
+    } while (x);
+    if (1) {
+        2;
+    } else {
+        3;
+    }
+    if (4)
+        5;
+    else
+        6;
+}
+typedef * d(int)
+    x;
+typedef (int)
+x;
+typedef (int)*()
+    x;
+typedef *int *
+x;
+typedef OSSL_CMP_MSG *(*cmp_srv_process_cb_t)
+    (OSSL_CMP_SRV_CTX *ctx, OSSL_CMP_MSG *msg)
+    xx;
+int f()
+{
+    c;
+    if (1) {
+        c;
+    }
+    c;
+    if (1)
+        if (2)
+        { /*@ brace after 'if' not on same line just to construct case */
+            c;
+        }
+    e;
+    const usign = {
+                   0xDF,
+                   {
+                    dd
+                   },
+                   dd
+    };
+    const unsign = {
+                    0xDF, {
+                           dd
+                    },
+                    dd
+    };
+}
+const unsigned char trans_id[OSSL_CMP_TRANSACTIONID_LENGTH] = {
+                                                               0xDF,
+};
+const unsigned char trans_id[OSSL_CMP_TRANSACTIONID_LENGTH] =
+    {
+     0xDF,
+    };
+typedef
+int
+a;
+
+typedef
+struct
+{
+    int a;
+} b;
+typedef enum {
+              w = 0
+} e_type;
+typedef struct {
+    enum {
+          w = 0
+    } e_type;
+    enum {
+          w = 0
+    } e_type;
+} e;
+struct s_type {
+    enum e_type {
+                 w = 0
+    };
+};
+struct s_type
+{
+    enum e_type {
+                 w = 0
+    };
+    enum e2_type {
+                  w = 0
+    };
+};
+
+#define X  1          + 1
+#define Y  /* .. */ 2 + 2
+#define Z  3          + 3
+
+static varref cmp_vars[] = { /* comment */
+    {&amp;opt_config}, {&amp;opt_section},
+
+    {&amp;opt_server}, {&amp;opt_proxy}, {&amp;opt_path},
+};
+
+#define SWITCH(x)                               \
+    switch (x) {                                \
+    case 0:                                     \
+        break;                                  \
+    default:                                    \
+        break;                                  \
+    }
+
+#define DEFINE_SET_GET_BASE_TEST(PREFIX, SETN, GETN, DUP, FIELD, TYPE, ERR, \
+                                 DEFAULT, NEW, FREE) \
+    static int execute_CTX_##SETN##_##GETN##_##FIELD( \
+                                                     TEST_FIXTURE *fixture) \
+    { \
+        CTX *ctx = fixture-&gt;ctx; \
+        int (*set_fn)(CTX *ctx, TYPE) = \
+            (int (*)(CTX *ctx, TYPE))PREFIX##_##SETN##_##FIELD; \
+        /* comment */ \
+    }
+
+/* 'struct' in function header */
+static int f(struct pem_pass_data *pass_data)
+{
+    if (pass_data == NULL)
+        return 0;
+}
+
+static void *fun(void)
+{
+    if (pem_name != NULL)
+        /* comment */
+        return NULL;
+
+    do {
+        size_t available_len, data_len;
+        const char *curr = txt, *next = txt;
+        char *tmp;
+    } while (1);
+
+    char *intraline_string_with_comment_delimiters_and_dbl_space = &quot;1  /*1&quot;;
+    char *multiline_string_with_comment_delimiters_and_dbl_space = &quot;1  /*1\
+2222222\'22222222222222222\&quot;222222222&quot; &quot;33333  /*3333333333&quot; &quot;44  /*44444444444\
+55555555555555\
+6666&quot;;
+}
+
+ASN1_CHOICE(OSSL_CRMF_POPO) = {
+    ASN1_IMP(OSSL_CRMF_POPO, value.raVerified, ASN1_NULL, 0),
+    ASN1_EXP(OSSL_CRMF_POPO, value.keyAgreement, OSSL_CRMF_POPOPRIVKEY, 3)
+} ASN1_CHOICE_END(OSSL_CRMF_POPO)
+IMPLEMENT_ASN1_FUNCTIONS(OSSL_CRMF_POPO)
+
+ASN1_ADB(OSSL_CRMF_ATTRIBUTETYPEANDVALUE) = {
+    ADB_ENTRY(NID_id_regCtrl_regToken,
+              ASN1_SIMPLE(OSSL_CRMF_ATTRIBUTETYPEANDVALUE,
+                          value.regToken, ASN1_UTF8STRING)),
+} ASN1_ADB_END(OSSL_CRMF_ATTRIBUTETYPEANDVALUE, 0, type, 0,
+               &amp;attributetypeandvalue_default_tt, NULL);
+
+ASN1_ITEM_TEMPLATE(OSSL_CRMF_MSGS) =
+    ASN1_EX_TEMPLATE_TYPE(ASN1_TFLG_SEQUENCE_OF, 0,
+                          OSSL_CRMF_MSGS, OSSL_CRMF_MSG)
+ASN1_ITEM_TEMPLATE_END(OSSL_CRMF_MSGS)
+
+void f_looong_body_200()
+{ /* function body length up to 200 lines accepted */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}
+
+void f_looong_body_201()
+{ /* function body length &gt; 200 lines, but LONG BODY marker present */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}
diff --git a/util/check-format-test-positives.c b/util/check-format-test-positives.c
new file mode 100644
index 0000000000..d14ceb375b
--- /dev/null
+++ b/util/check-format-test-positives.c
@@ -0,0 +1,345 @@
+/*
+ * Copyright 2007-2019 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright Nokia 2007-2019
+ * Copyright Siemens AG 2015-2019
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+/*
+ * This demonstrates/tests cases where check-format.pl should report issues.
+ * Some of the reports are due to sanity checks for proper nesting of comment
+ * delimiters and parenthesis-like symbols, e.g., on unexpected/unclosed braces.
+ */
+
+/*
+ * The '@'s after '*' are used for self-tests: they mark lines containing
+ * a single flaw that should be reported. Normally it should be reported
+ * while handling the given line, but in case of delayed checks there is a
+ * following digit indicating the number of reports expected for this line.
+ */
+
+/* For each of the following set of lines the tool should complain once */
+/*@ tab character: 	 */
+/*@ intra-line carriage return character: 
 */
+/*@ non-printable ASCII character:  */
+/*@ non-ASCII character: &#228; */
+/*@ whitespace at EOL: */ 
+// /*@ end-of-line comment style not allowed (for C90 compatibility) */
+ /*@0 intra-line comment indent off by 1, reported unless sloppy-cmt */
+/*X */ /*@2 no space nor '*' after comment start, reported unless sloppy-spc */
+/* X*/ /*@ no space before comment end , reported unless sloppy-spc */
+/*@ comment starting delimiter: /* inside intra-line comment */
+ /*@0
+  *@ above multi-line comment start indent off by 1, reported unless sloppy-cmt; this comment line is too long
+   *@ multi-line comment indent further off by 1 relative to comment start
+  *@ multi-line comment ending with text on last line */
+/*@2 multi-line comment starting with text on first line
+ *@ comment starting delimiter: /* inside multi-line comment
+*@ multi-line comment indent off by -1
+ *X*@ no spc after leading '*' in multi-line comment, reported unless sloppy-spc
+ *@0 more than two spaces after .   in comment, reported unless sloppy-spc
+*/ /*@2 multi-line comment end indent off by -1 (relative to comment start) */
+*/ /*@ unexpected comment ending delimiter outside comment */
+/*@ comment line is 4 columns tooooooooooooooooo wide, reported unless sloppy-len */
+/*@ comment line is 5 columns toooooooooooooooooooooooooooooooooooooooooooooo wide */
+#define X   1       /*@0 double space false negative due to coincidence */
+ #define Y  2       /*@ indent of preprocessor directive off by 1 (must be 0) */
+typedef struct  {   /*@0 double space in code, reported unless sloppy-spc */
+    enum {          /*@1 double space  in comment, reported unless sloppy-spc */
+           w = 0 /*@2 hanging expr indent off by 1, or 3 for lines after '{' */
+             &amp;&amp; 1,  /*@ hanging expr indent off by 3, or -1 for leading '&amp;&amp;' */
+         x = 1,     /*@ hanging expr indent off by -1 */
+          y,z       /*@ no space after ',', reported unless sloppy-spc */
+    } e_member ;    /*@ space before ';', reported unless sloppy-spc */
+    int v[1;        /*@ unclosed bracket in type declaration */
+   union {          /*@ statement/type declaration indent off by -1 */
+        struct{} s; /*@ no space before '{', reported unless sloppy-spc */
+    }u_member;      /*@ no space after '}', reported unless sloppy-spc */
+    } s_type;       /*@ statement/type declaration indent off by 4 */
+int* somefunc();    /*@ no space before '*' in type decl, r unless sloppy-spc */
+void main(int n) {  /*@ opening brace at end of function definition header */
+    for (;;n++) {   /*@ no space after ';', reported unless sloppy-spc */
+        return;     /*@0 (1-line) single statement in braces */
+    }}              /*@2 code after '}' outside expr */
+}                   /*@ unexpected closing brace (too many '}') outside expr */
+)                   /*@ unexpected closing paren outside expr */
+#endif              /*@ unexpected #endif */
+int f (int a,       /*@ space after fn before '(', reported unless sloppy-spc */
+      int b,        /*@ hanging expr indent off by -1 */
+       long l)      /*@ one-letter name 'l' */
+{ int               /*@ code after '{' opening a block */
+    xx = 1) +       /*@ unexpected closing parenthesis */
+        2] -        /*@ unexpected closing bracket */
+        3: *        /*@ unexpected ':' (without preceding '?') within expr */
+        4};         /*@ unexpected closing brace within expression */
+    char y[] = {    /*@0 unclosed brace within initializer/enum expression */
+        1* 1,       /*@ no space etc. before '*', reported unless sloppy-spc */
+         2,         /*@ hanging expr indent (for lines after '{') off by 1 */
+        (xx         /*@0 unclosed parenthesis in expression */
+         ? y        /*@0 unclosed '? (conditional expression) */
+         [0;        /*@4 unclosed bracket in expression */
+   s_type s;        /*@ local variable declaration indent off by -1 */
+   somefunc(a,      /*@ statement indent off by -1 */
+          &quot;aligned&quot; /*@ expr indent off by -2 accepted if sloppy-hang */ &quot;right&quot;
+           , b,     /*@ expr indent off by -1 */
+           b,       /*@ expr indent as on line above, accepted if sloppy-hang */
+    b, /*@ expr indent off -8 but @ extra indent accepted if sloppy-hang */
+   &quot;again aligned&quot; /*@ expr indent off by -9 (left of stmt indent, */ &quot;right&quot;,
+            123 == /*@ .. so reported also with sloppy-hang; this line is too long */ 456
+# define MAC(A) (A) /*@ nesting indent of preprocessor directive off by 1 */
+             ? 1    /*@ hanging expr indent off by 1 */
+              : 2); /*@ hanging expr indent off by 2, or 1 for leading ':' */
+    if(a            /*@ no space after 'if', reported unless sloppy-spc */
+          /*@0 intra-line comment indent off by -1 (not: by 3 due to '&amp;&amp;') */
+           &amp;&amp; ! 0   /*@2 space after '!', reported unless sloppy-spc */
+         || b ==    /*@ hanging expr indent off by 2, or -2 for leading '||' */
+       (xx+= 2) +   /*@ no space before '+=', reported unless sloppy-spc */
+       (a^ 1) +     /*@ no space before '^', reported unless sloppy-spc */
+       a %2 /       /*@ no space after '%', reported unless sloppy-spc */
+       1 +/* */     /*@ no space before comment, reported unless sloppy-spc */
+       /* */+       /*@ no space after comment, reported unless sloppy-spc */
+       s. e_member) /*@ space after '.', reported unless sloppy-spc */
+         xx = a + b /*@ extra single-statement indent off by 1 */
+               + 0; /*@ two times extra single-statement indent off by 3 */
+    if (a ++)       /*@ space before postfix '++', reported unless sloppy-spc */
+    {               /*@ {' not on same line as preceding 'if' */
+        c;          /*@0 single stmt in braces, reported on 1-stmt */
+    } else          /*@ no '{' on same line after '} else' */
+      {             /*@ statement indent off by 2 */
+        d;          /*@0 single stmt in braces, reported on 1-stmt */
+          }         /*@ statement indent off by 6 */
+    if (1) f(a,     /*@ (non-brace) code after end of 'if' condition */
+             b); else /*@ (non-brace) code before 'else' */
+        do f(c, c); /*@ (non-brace) code after 'do' */
+        while ( 2); /*@ space after '(', reported unless sloppy-spc */
+    b; c;           /*@ more than one statement per line */
+    do{             /*@ no space before '{', reported unless sloppy-spc */
+        f (3,       /*@ space after fn before '(', reported unless sloppy-spc */
+           4);      /*@0 false negative: should report single stmt in braces */
+    }               /*@0 'while' not on same line as preceding '}' */
+    while (a+ 0);   /*@2 no space before '+', reported unless sloppy-spc */
+    switch (b ) {   /*@ space before ')', reported unless sloppy-spc */
+   case 1:          /*@ 'case' special statement indent off by -1 */
+    case(2):        /*@ no space after 'case', reported unless sloppy-spc */
+    default: ;      /*@ code after 'default:' */
+}                   /*@ statement indent off by -4 */
+  label:            /*@ label special statement indent off by 1 */
+    return(         /*@ no space after 'return', reported unless sloppy-spc */
+           x); }    /*@ code before block-level '}' */
+/* Here the tool should stop complaining apart from the below issues at EOF */
+
+void f_looong_body()
+{
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}                   /*@ function body length &gt; 200 lines */
+
+#if 0               /*@0 unclosed #if */
+struct t {          /*@0 unclosed brace at decl/block level */
+    enum {          /*@0 unclosed brace at enum/expression level */
+          v = (1    /*@0 unclosed parenthesis */
+               etyp /*@0 empty line follows just before EOF: */
+
diff --git a/util/check-format.pl b/util/check-format.pl
new file mode 100644
index 0000000000..af77d20920
--- /dev/null
+++ b/util/check-format.pl
@@ -0,0 +1,1118 @@
+#!/usr/bin/perl
+#
+# Copyright 2020 The OpenSSL Project Authors. All Rights Reserved.
+# Copyright Siemens AG 2019-2020
+#
+# Licensed under the Apache License 2.0 (the &quot;License&quot;).
+# You may not use this file except in compliance with the License.
+# You can obtain a copy in the file LICENSE in the source distribution
+# or at <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+#
+# check-format.pl
+# - check formatting of C source according to OpenSSL coding style
+#
+# usage:
+#   check-format.pl [-l|--sloppy-len] [-l|--sloppy-bodylen]
+#                   [-s|--sloppy-spc] [-c|--sloppy-cmt] [-m|--sloppy-macro]
+#                   [-h|--sloppy-hang] [-1|--1-stmt]
+#                   &lt;files&gt;
+#
+# checks adherence to the formatting rules of the OpenSSL coding guidelines
+# assuming that the input files contain syntactically correct C code.
+# This pragmatic tool is incomplete and yields some false positives.
+# Still it should be useful for detecting most typical glitches.
+#
+# options:
+#  -l | --sloppy-len   increase accepted max line length from 80 to 84
+#  -l | --sloppy-bodylen do not report function body length &gt; 200
+#  -s | --sloppy-spc   do not report whitespace nits
+#  -c | --sloppy-cmt   do not report indentation of comments
+#                      Otherwise for each multi-line comment the indentation of
+#                      its lines is checked for consistency. For each comment
+#                      that does not begin to the right of normal code its
+#                      indentation must be as for normal code, while in case it
+#                      also has no normal code to its right it is considered to
+#                      refer to the following line and may be indented equally.
+#  -m | --sloppy-macro allow missing extra indentation of macro bodies
+#  -h | --sloppy-hang  when checking hanging indentation, do not report
+#                      * same indentation as on line before
+#                      * same indentation as non-hanging indent level
+#                      * indentation moved left (not beyond non-hanging indent)
+#                        just to fit contents within the line length limit
+#  -1 | --1-stmt       do more aggressive checks for { 1 stmt } - see below
+#
+# There are non-trivial false positives and negatives such as the following.
+#
+# * When a line contains several issues of the same kind only one is reported.
+#
+# * When a line contains more than one statement this is (correctly) reported
+#   but in some situations the indentation checks for subsequent lines go wrong.
+#
+# * There is the special OpenSSL rule not to unnecessarily use braces around
+#   single statements:
+#   {
+#       stmt;
+#   }
+#   except within if ... else constructs where some branch contains more than one
+#   statement. Since the exception is hard to recognize when such branches occur
+#   after the current position (such that false positives would be reported)
+#   the tool by checks for this rule by defaul only for do/while/for bodies.
+#   Yet with the --1-stmt option false positives are preferred over negatives.
+#   False negatives occur if the braces are more than two non-empty lines apart.
+#
+# * Use of multiple consecutive spaces is regarded a coding style nit except
+#   when done in order to align certain columns over multiple lines, e.g.:
+#   # define AB  1
+#   # define CDE 22
+#   # define F   3333
+#   This pattern is recognized - and consequently double space not reported -
+#   for a given line if in the nonempty line before or after (if existing)
+#   for each occurrence of &quot;  \S&quot; (where \S means non-space) in the given line
+#   there is &quot; \S&quot; in the other line in the respective column position.
+#   This may lead to both false negatives (in case of coincidental &quot; \S&quot;)
+#   and false positives (in case of more complex multi-column alignment).
+#
+# * When just part of control structures depend on #if(n)(def), which can be
+#   considered bad programming style, indentation false positives occur, e.g.:
+#   #if X
+#       if (1) /* bad style */
+#   #else
+#       if (2) /* bad style resulting in false positive */
+#   #endif
+#           c; /* resulting further false positive */
+
+use strict;
+# use List::Util qw[min max];
+use POSIX;
+
+use constant INDENT_LEVEL =&gt; 4;
+use constant MAX_LINE_LENGTH =&gt; 80;
+use constant MAX_BODY_LENGTH =&gt; 200;
+
+# global variables @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+# command-line options
+my $max_length = MAX_LINE_LENGTH;
+my $sloppy_bodylen = 0;
+my $sloppy_SPC = 0;
+my $sloppy_hang = 0;
+my $sloppy_cmt = 0;
+my $sloppy_macro = 0;
+my $extended_1_stmt = 0;
+
+while ($ARGV[0] =~ m/^-(\w|-[\w\-]+)$/) {
+    my $arg = $1; shift;
+    if ($arg =~ m/^(l|-sloppy-len)$/) {
+        $max_length += INDENT_LEVEL;
+    } elsif ($arg =~ m/^(b|-sloppy-bodylen)$/) {
+        $sloppy_bodylen = 1;
+    } elsif ($arg =~ m/^(s|-sloppy-spc)$/) {
+        $sloppy_SPC = 1;
+    } elsif ($arg =~ m/^(c|-sloppy-cmt)$/) {
+        $sloppy_cmt = 1;
+    } elsif ($arg =~ m/^(m|-sloppy-macro)$/) {
+        $sloppy_macro = 1;
+    } elsif ($arg =~ m/^(h|-sloppy-hang)$/) {
+        $sloppy_hang = 1;
+    } elsif ($arg =~ m/^(1|-1-stmt)$/) {
+        $extended_1_stmt = 1;
+    } else {
+        die(&quot;unknown option: -$arg&quot;);
+    }
+}
+
+# status variables
+my $self_test;             # whether the current input file is regarded to contain (positive/negative) self-tests
+my $line;                  # current line number
+my $line_before;           # number of previous not essentially empty line (containing at most whitespace and '\')
+my $line_before2;          # number of not essentially empty line before previous not essentially empty line
+my $contents;              # contents of current line
+my $contents_before;       # contents of $line_before, if $line_before &gt; 0
+my $contents_before_;      # contents of $line_before after blinding comments etc., if $line_before &gt; 0
+my $contents_before2;      # contents of $line_before2, if $line_before2 &gt; 0
+my $contents_before_2;     # contents of $line_before2 after blinding comments etc., if $line_before2 &gt; 0
+my $in_multiline_string;   # line starts within multi-line string literal
+my $count;                 # -1 or number of leading whitespace characters (except newline) in current line,
+                           # which should be $block_indent + $hanging_offset + $local_offset or $expr_indent
+my $count_before;          # number of leading whitespace characters (except line ending chars) in $contents_before
+my $has_label;             # current line contains label
+my $local_offset;          # current extra indent due to label, switch case/default, or leading closing brace(s)
+my $line_body_start;       # number of line where last function body started, or 0
+my $line_function_start;   # number of line where last function definition started, used if $line_body_start != 0
+my $last_function_header;  # header containing name of last function defined, used if $line_function_start != 0
+my $line_opening_brace;    # number of previous line with opening brace after do/while/for, optionally for if/else
+
+my $keyword_opening_brace; # name of previous keyword, used if $line_opening_brace != 0
+my $ifdef__cplusplus;      # line before contained '#ifdef __cplusplus' (used in header files)
+my $block_indent;          # currently required normal indentation at block/statement level
+my $hanging_offset;        # extra indent, which may be nested, for just one hanging statement or expr or typedef
+my @in_do_hanging_offsets; # stack of hanging offsets for nested 'do' ... 'while'
+my @in_if_hanging_offsets; # stack of hanging offsets for nested 'if' (but not its potential 'else' branch)
+my $if_maybe_terminated;   # 'if' ends and $hanging_offset should be reset unless the next line starts with 'else'
+my @nested_block_indents;  # stack of indentations at block/statement level, needed due to hanging statements
+my @nested_hanging_offsets;# stack of nested $hanging_offset values, in parallel to @nested_block_indents
+my @nested_in_typedecl;    # stack of nested $in_typedecl values, partly in parallel to @nested_block_indents
+my @nested_indents;        # stack of hanging indents due to parentheses, braces, brackets, or conditionals
+my @nested_symbols;        # stack of hanging symbols '(', '{', '[', or '?', in parallel to @nested_indents
+my @nested_conds_indents;  # stack of hanging indents due to conditionals ('?' ... ':')
+my $expr_indent;           # resulting hanging indent within (multi-line) expressions including type exprs, else 0
+my $hanging_symbol;        # character ('(', '{', '[', not: '?') responsible for $expr_indent, if $expr_indent != 0
+my $in_expr;               # in expression after if/while/for/switch/return/enum/LHS of assignment
+my $in_paren_expr;         # in parenthesized if/while/for condition and switch expression, if $expr_indent != 0
+my $in_typedecl;           # nesting level of typedef/struct/union/enum
+my $in_directive;          # number of lines so far within preprocessor directive, e.g., macro definition
+my $directive_nesting;     # currently required indentation of preprocessor directive according to #if(n)(def)
+my $directive_offset;      # indent offset within multi-line preprocessor directive, if $in_directive &gt; 0
+my $in_macro_header;       # number of open parentheses + 1 in (multi-line) header of #define, if $in_directive &gt; 0
+my $in_comment;            # number of lines so far within multi-line comment, or &lt; 0 when end is on current line
+my $leading_comment;       # multi-line comment has no code before its beginning delimiter
+my $formatted_comment;     # multi-line comment beginning with &quot;/*-&quot;, which indicates/allows special formatting
+my $comment_indent;        # comment indent, if $in_comment != 0
+my $num_reports_line = 0;  # number of issues found on current line
+my $num_reports = 0;       # total number of issues found
+my $num_indent_reports = 0;# total number of indentation issues found
+my $num_nesting_issues = 0;# total number of directive nesting issues found
+my $num_syntax_issues = 0; # total number of syntax issues found during sanity checks
+my $num_SPC_reports = 0;   # total number of whitespace issues found
+my $num_length_reports = 0;# total number of line length issues found
+
+sub reset_file_state {
+    $line = 0;
+    $line_before = 0;
+    $line_before2 = 0;
+    @nested_block_indents = ();
+    @nested_hanging_offsets = ();
+    @nested_in_typedecl = ();
+    @nested_symbols = ();
+    @nested_indents = ();
+    @nested_conds_indents = ();
+    $expr_indent = 0;
+    $in_paren_expr = 0;
+    $in_expr = 0;
+    $hanging_offset = 0;
+    @in_do_hanging_offsets = ();
+    @in_if_hanging_offsets = ();
+    $if_maybe_terminated = 0;
+    $block_indent = 0;
+    $ifdef__cplusplus = 0;
+    $in_multiline_string = 0;
+    $line_body_start = 0;
+    $line_opening_brace = 0;
+    $in_typedecl = 0;
+    $in_directive = 0;
+    $directive_nesting = 0;
+    $in_comment = 0;
+}
+
+# auxiliary submodules @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+sub report_flexibly {
+    my $line = shift;
+    my $msg = shift;
+    my $contents = shift;
+    my $report_SPC = $msg =~ /SPC/;
+    return if $report_SPC &amp;&amp; $sloppy_SPC;
+
+    print &quot;$ARGV:$line:$msg:$contents&quot; unless $self_test;
+    $num_reports_line++;
+    $num_reports++;
+    $num_indent_reports++ if $msg =~ m/indent/;
+    $num_nesting_issues++ if $msg =~ m/directive nesting/;
+    $num_syntax_issues++  if $msg =~ m/unclosed|unexpected/;
+    $num_SPC_reports++    if $report_SPC;
+    $num_length_reports++ if $msg =~ m/length/;
+}
+
+sub report {
+    my $msg = shift;
+    report_flexibly($line, $msg, $contents);
+}
+
+sub parens_balance { # count balance of opening parentheses - closing parentheses
+    my $str = shift;
+    return $str =~ tr/\(// - $str =~ tr/\)//;
+}
+
+sub blind_nonspace { # blind non-space text of comment as @, preserving length and spaces
+    # the @ character is used because it cannot occur in normal program code so there is no confusion
+    # comment text is not blinded to whitespace in order to be able to check double SPC also in comments
+    my $comment_text = shift;
+    $comment_text =~ s/\.\s\s/.. /g; # in double SPC checks allow one extra space after period '.' in comments
+    return $comment_text =~ tr/ /@/cr;
+}
+
+# submodule for indentation checking/reporting @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+sub check_indent { # used for lines outside multi-line string literals
+    my $stmt_indent = $block_indent + $hanging_offset + $local_offset;
+    $stmt_indent = 0 if $stmt_indent &lt; 0; # TODO maybe give warning/error
+    my $stmt_desc = $contents =~
+        m/^\s*\/\*/ ? &quot;intra-line comment&quot; :
+        $has_label ? &quot;label&quot; :
+        ($hanging_offset != 0 ? &quot;hanging &quot; : &quot;&quot;).
+        ($hanging_offset != 0 ? &quot;stmt/expr&quot; : &quot;stmt/decl&quot;); # $in_typedecl is not fully to the point here
+    my ($ref_desc, $ref_indent) = $expr_indent == 0 ? ($stmt_desc, $stmt_indent)
+                                                    : (&quot;hanging '$hanging_symbol'&quot;, $expr_indent);
+    my ($alt_desc, $alt_indent) = (&quot;&quot;, $ref_indent);
+
+    # allow indent 1 for labels - this cannot happen for leading ':'
+    ($alt_desc, $alt_indent) = (&quot;outermost position&quot;, 1) if $expr_indent == 0 &amp;&amp; $has_label;
+
+    if (@nested_conds_indents != 0 &amp;&amp; substr($_, $count, 1) eq &quot;:&quot;) {
+        # leading ':' within stmt/expr/decl - this cannot happen for labels nor leading  '&amp;&amp;' or '||'
+        # allow special indent at level of corresponding &quot;?&quot;
+        ($alt_desc, $alt_indent) = (&quot;leading ':'&quot;, @nested_conds_indents[-1]);
+    }
+    # allow extra indent offset leading '&amp;&amp;' or '||' - this cannot happen for leading &quot;:&quot;
+    ($alt_desc, $alt_indent) = (&quot;leading '$1'&quot;, $ref_indent + INDENT_LEVEL) if $contents =~ m/^[\s@]*(\&amp;\&amp;|\|\|)/;
+
+    if ($expr_indent &lt; 0) { # implies @nested_symbols != 0 &amp;&amp; @nested_symbols[0] eq &quot;{&quot; &amp;&amp; @nested_indents[-1] &lt; 0
+        # allow normal stmt indentation level for hanging initializer/enum expressions after trailing '{'
+        # this cannot happen for labels and overrides special treatment of ':', '&amp;&amp;' and '||' for this line
+        ($alt_desc, $alt_indent) = (&quot;lines after '{'&quot;, $stmt_indent);
+        # decide depending on current actual indentation, preventing forth and back
+        @nested_indents[-1] = $count == $stmt_indent ? $stmt_indent : <A HREF="../../../mailman/listinfo/openssl-commits.html">- at nested_indents</A>[-1]; # allow $stmt_indent
+        $ref_indent = $expr_indent = @nested_indents[-1];
+    }
+
+    # check consistency of indentation within multi-line comment (i.e., between its first, inner, and last lines)
+    if ($in_comment != 0 &amp;&amp; $in_comment != 1) { # in multi-line comment but not on its first line
+        if (!$sloppy_cmt) {
+            if ($in_comment &gt; 0) { # not at its end
+                report(&quot;indent = $count != $comment_indent within multi-line comment&quot;)
+                    if $count != $comment_indent;
+            } else {
+                my $tweak = $in_comment == -2 ? 1 : 0;
+                report(&quot;indent = &quot;.($count + $tweak).&quot; != $comment_indent at end of multi-line comment&quot;)
+                    if $count + $tweak != $comment_indent;
+            }
+        }
+        # do not check indentation of last line of non-leading multi-line comment
+        if ($in_comment &lt; 0 &amp;&amp; !$leading_comment) {
+            s/^(\s*)@/$1*/; # blind first '@' as '*' to prevent below delayed check for the line before
+            return;
+        }
+        return if $in_comment &gt; 0; # not on its last line
+        # $comment_indent will be checked by the below checks for end of multi-line comment
+    }
+
+    # else check indentation of entire-line comment or entire-line end of multi-line comment
+    # ... w.r.t. indent of the following line by delayed check for the line before
+    if (($in_comment == 0 || $in_comment == 1) # no comment, intra-line comment, or begin of multi-line comment
+        &amp;&amp; $line_before &gt; 0 # there is a line before
+        &amp;&amp; $contents_before_ =~ m/^(\s*)@[\s@]*$/) { # line before begins with '@', no code follows (except '\')
+        report_flexibly($line_before, &quot;entire-line comment indent = $count_before != $count (of following line)&quot;,
+            $contents_before) if !$sloppy_cmt &amp;&amp; $count_before != $count;
+    }
+    # ... but allow normal indentation for the current line, else above check will be done for the line before
+    if (($in_comment == 0 || $in_comment &lt; 0) # (no commment,) intra-line comment or end of multi-line comment
+        &amp;&amp; m/^(\s*)@[\s@]*$/) { # line begins with '@', no code follows (except '\')
+        if ($count == $ref_indent) { # indentation is like for (normal) code in this line
+            s/^(\s*)@/$1*/; # blind first '@' as '*' to prevent above delayed check for the line before
+            return;
+        }
+        return if !eof; # defer check of entire-line comment to next line
+    }
+
+    # else check indentation of leading intra-line comment or end of multi-line comment
+    if (m/^(\s*)@/) { # line begins with '@', i.e., any (remaining type of) comment
+        if (!$sloppy_cmt &amp;&amp; $count != $ref_indent) {
+            report(&quot;intra-line comment indent = $count != $ref_indent&quot;) if $in_comment == 0;
+            report(&quot;multi-line comment indent = $count != $ref_indent&quot;) if $in_comment &lt; 0;
+        }
+        return;
+    }
+
+    if ($sloppy_hang &amp;&amp; ($hanging_offset != 0 || $expr_indent != 0)) {
+        # do not report same indentation as on the line before (potentially due to same violations)
+        return if $line_before &gt; 0 &amp;&amp; $count == $count_before;
+
+        # do not report indentation at normal indentation level while hanging expression indent would be required
+        return if $expr_indent != 0 &amp;&amp; $count == $stmt_indent;
+
+        # do not report if contents have been shifted left of nested expr indent (but not as far as stmt indent)
+        # apparently aligned to the right in order to fit within line length limit
+        return if $stmt_indent &lt; $count &amp;&amp; $count &lt; $expr_indent &amp;&amp;
+            length($contents) == MAX_LINE_LENGTH + length(&quot;\n&quot;);
+    }
+
+    report(&quot;indent = $count != $ref_indent for $ref_desc&quot;.
+           ($alt_desc eq &quot;&quot;
+            || $alt_indent == $ref_indent # prevent showing alternative that happens to have equal value
+            ? &quot;&quot; : &quot; or $alt_indent for $alt_desc&quot;))
+        if $count != $ref_indent &amp;&amp; $count != $alt_indent;
+}
+
+# submodules handling indentation within expressions @@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+sub update_nested_indents { # may reset $in_paren_expr and in this case also resets $in_expr
+    my $str = shift;
+    my $start = shift; # defaults to 0
+    my $terminator_position = -1;
+    for (my $i = $start; $i &lt; length($str); $i++) {
+        my $c;
+        my $curr = substr($str, $i);
+        if ($curr =~ m/^(.*?)([{}()?:;\[\]])(.*)$/) { # match from position $i the first {}()?:;[]
+            $c = $2;
+        } else {
+            last;
+        }
+        my ($head, $tail) = (substr($str, 0, $i).$1, $3);
+        $i += length($1) + length($2) - 1;
+
+        # stop at terminator outside 'for(..;..;..)', assuming that 'for' is followed by '('
+        return $i if $c eq &quot;;&quot; &amp;&amp; (!$in_paren_expr || @nested_indents == 0);
+
+        my $in_stmt = $in_expr || @nested_symbols != 0; # not: || $in_typedecl != 0
+        if ($c =~ m/[{([?]/) { # $c is '{', '(', '[', or '?'
+            if ($c eq &quot;{&quot;) { # '{' in any context
+                # cancel newly hanging_offset if opening brace '{' is after non-whitespace non-comment:
+                $hanging_offset -= INDENT_LEVEL if $hanging_offset &gt; 0 &amp;&amp; $head =~ m/[^\s\@]/;
+                push @nested_block_indents, $block_indent;
+                push @nested_hanging_offsets, $in_expr ? $hanging_offset : 0;
+                push @nested_in_typedecl, $in_typedecl if $in_typedecl != 0;
+                $block_indent += INDENT_LEVEL + $hanging_offset;
+                $hanging_offset = 0;
+            }
+            if ($c ne &quot;{&quot; || $in_stmt) { # for '{' inside stmt/expr (not: decl), for '(', '[', or '?' anywhere
+                $tail =~ m/^([\s@]*)([^\s\@])/;
+                push @nested_indents, defined $2
+                    ? $i + 1 + length($1) # actual indentation of following non-space non-comment
+                    : $c ne &quot;{&quot; ? +($i + 1)  # just after '(' or '[' if only whitespace thereafter
+                                : -($i + 1); # allow also $stmt_indent if '{' with only whitespace thereafter
+                push @nested_symbols, $c; # done also for '?' to be able to check correct nesting
+                push @nested_conds_indents, $i if $c eq &quot;?&quot;; # remember special alternative indent for ':'
+            }
+        } elsif ($c =~ m/[})\]:]/) { # $c is '}', ')', ']', or ':'
+            my $opening_c = ($c =~ tr/})]:/{([/r);
+            if (($c ne &quot;:&quot; || $in_stmt    # ignore ':' outside stmt/expr/decl
+                # in the presence of ':', one could add this sanity check:
+                # &amp;&amp; !(# ':' after initial label/case/default
+                #      $head =~ m/^([\s@]*)(case\W.*$|\w+$)/ || # this matching would not work for
+                #                                               # multi-line expr after 'case'
+                #      # bitfield length within unsigned type decl
+                #      $tail =~ m/^[\s@]*\d+/                   # this matching would need improvement
+                #     )
+                )) {
+                if ($c ne &quot;}&quot; || $in_stmt) { # for '}' inside stmt/expr/decl, ')', ']', or ':'
+                    if (@nested_symbols != 0 &amp;&amp;
+                        @nested_symbols[-1] == $opening_c) { # for $c there was a corresponding $opening_c
+                        pop @nested_indents;
+                        pop @nested_symbols;
+                        pop @nested_conds_indents if $opening_c eq &quot;?&quot;;
+                    } else {
+                        report(&quot;unexpected '$c' @ &quot;.($in_paren_expr ? &quot;(expr)&quot; : &quot;expr&quot;));
+                        next;
+                    }
+                }
+                if ($c eq &quot;}&quot;) { # '}' at block level but also inside stmt/expr/decl
+                    if (@nested_block_indents == 0) {
+                        report(&quot;unexpected '}'&quot;);
+                    } else {
+                        $block_indent = pop @nested_block_indents;
+                        $hanging_offset = pop @nested_hanging_offsets;
+                        $in_typedecl = pop @nested_in_typedecl if @nested_in_typedecl != 0;
+                    }
+                }
+                if ($in_paren_expr &amp;&amp; !grep(/\(/, @nested_symbols)) { # end of (expr)
+                    check_nested_nonblock_indents(&quot;(expr)&quot;);
+                    $in_paren_expr = $in_expr = 0;
+                    report(&quot;code after (expr)&quot;)
+                        if $tail =~ m/^([^{]*)/ &amp;&amp; $1 =~ m/[^\s\@;]/; # non-space non-';' before any '{'
+                }
+            }
+        }
+    }
+    return -1;
+}
+
+sub check_nested_nonblock_indents {
+    my $position = shift;
+    while (@nested_symbols != 0) {
+        my $symbol = pop @nested_symbols;
+        report(&quot;unclosed '$symbol' in $position&quot;);
+        if ($symbol eq &quot;{&quot;) { # repair stack of blocks
+            $block_indent = pop @nested_block_indents;
+            $hanging_offset = pop @nested_hanging_offsets;
+            $in_typedecl = pop @nested_in_typedecl if @nested_in_typedecl != 0;
+        }
+    }
+    @nested_indents = ();
+    @nested_conds_indents = ();
+}
+
+# start of main program @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+reset_file_state();
+
+while (&lt;&gt;) { # loop over all lines of all input files
+    $self_test = $ARGV =~ m/check-format-test/;
+    $line++;
+    s/\r$//; # strip any trailing CR '\r' (which are typical on Windows systems)
+    $contents = $_;
+
+    # check for illegal characters
+    if (m/(.*?)([\x00-\x09\x0B-\x1F\x7F-\xFF])/) {
+        my $col = length($1);
+        report(($2 eq &quot;\x09&quot; ? &quot;TAB&quot; : $2 eq &quot;\x0D&quot; ? &quot;CR &quot; : $2 =~ m/[\x00-\x1F]/ ? &quot;non-printable&quot;
+                : &quot;non-7bit char&quot;) . &quot; at column $col&quot;) ;
+    }
+
+    # check for whitespace at EOL
+    report(&quot;trailing whitespace at EOL&quot;) if m/\s\n$/;
+
+    # assign to $count the actual indentation level of the current line
+    chomp; # remove trailing NL '\n'
+    m/^(\s*)/;
+    $count = length($1); # actual indentation
+    $has_label = 0;
+    $local_offset = 0;
+
+    # character/string literals @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+    s/\\[&quot;']/@@/g; # blind all '&quot;' and &quot;'&quot; escaped by '\' (typically within character literals or string literals)
+
+    # handle multi-line string literals to avoid confusion on starting/ending '&quot;' and trailing '\'
+    if ($in_multiline_string) {
+        if (s#^([^&quot;]*)&quot;#($1 =~ tr/&quot;/@/cr).'@'#e) { # string literal terminated by '&quot;'
+            # string contents and its terminating '&quot;' have been blinded as '@'
+            $count = -1; # do not check indentation
+        } else {
+            report(&quot;multi-line string literal not terminated by '\&quot;' and trailing '\' is missing&quot;)
+                unless s#^([^\\]*)\s*\\\s*$#$1#; # strip trailing '\' plus any whitespace around
+            goto LINE_FINISHED;
+        }
+    }
+
+    # blind contents of character and string literals as @, preserving length (but not spaces)
+    # this prevents confusing any of the matching below, e.g., of whitespace and comment delimiters
+    s#('[^']*')#$1 =~ tr/'/@/cr#eg; # handle all intra-line character literals
+    s#(&quot;[^&quot;]*&quot;)#$1 =~ tr/&quot;/@/cr#eg; # handle all intra-line string literals
+    $in_multiline_string =          # handle trailing string literal terminated by '\'
+        s#^(([^&quot;]*&quot;[^&quot;]*&quot;)*[^&quot;]*)(&quot;[^&quot;]*)\\(\s*)$#$1.($3 =~ tr/&quot;/@/cr).'&quot;'.$4#e;
+        # its contents have been blinded and the trailing '\' replaced by '&quot;'
+
+    # strip any other trailing '\' along with any whitespace around it such that it does not interfere with various
+    # matching below; the later handling of multi-line macro definitions uses $contents where it is not stripped
+    s#^(.*?)\s*\\\s*$#$1#; # trailing '\' possibly preceded and/or followed by whitespace
+
+    # comments @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+    # do/prepare checks within multi-line comments
+    my $self_test_exception = $self_test ? &quot;@&quot; : &quot;&quot;;
+    if ($in_comment &gt; 0) { # this still includes the last line of multi-line commment
+        my ($head, $any_symbol, $cmt_text) = m/^(\s*)(.?)(.*)$/;
+        if ($any_symbol eq &quot;*&quot;) {
+            report(&quot;no SPC after leading '*' in multi-line comment&quot;) if $cmt_text =~ m|^[^/\s$self_test_exception]|;
+        } else {
+            report(&quot;no leading '*' in multi-line comment&quot;);
+        }
+        $in_comment++;
+    }
+
+    # detect end of comment, must be within multi-line comment, check if it is preceded by non-whitespace text
+    if ((my ($head, $tail) = m|^(.*?)\*/(.*)$|) &amp;&amp; $1 ne '/') { # ending comment: '*/'
+        report(&quot;no SPC nor '*' before '*/'&quot;) if $head =~ m/[^*\s]$/;
+        report(&quot;no SPC after '*/'&quot;) if $tail =~ m/^[^\s,;)}\]]/; # no space or ,;)}] after '*/'
+        if (!($head =~ m|/\*|)) { # not begin of comment '/*', which is is handled below
+            if ($in_comment == 0) {
+                report(&quot;unexpected '*/' outside comment&quot;);
+                $_ = &quot;$head@@&quot;.$tail; # blind the &quot;*/&quot;
+            } else {
+                report(&quot;text before '*/' in multi-line comment&quot;) if ($head =~ m/\S/); # non-SPC before '*/'
+                $in_comment = -1; # indicate that multi-line comment ends on current line
+                if ($count &gt; 0) {
+                    # make indentation of end of multi-line comment appear like of leading intra-line comment
+                    $head =~ s/^(\s*)\s/$1@/; # replace the last leading space by '@'
+                    $count--;
+                    $in_comment = -2; # indicate that multi-line comment ends on current line, with tweak
+                }
+                my $cmt_text = $head;
+                $_ = blind_nonspace($cmt_text).&quot;@@&quot;.$tail;
+            }
+        }
+    }
+
+    # detect begin of comment, check if it is followed by non-space text
+  MATCH_COMMENT:
+    if (my ($head, $opt_minus, $tail) = m|^(.*?)/\*(-?)(.*)$|) { # begin of comment: '/*'
+        report(&quot;no SPC before '/*'&quot;)
+            if $head =~ m/[^\s\*]$/; # no space (nor '*', needed to allow '*/' here) before comment delimiter
+        report(&quot;no SPC nor '*' after '/*' or '/*-'&quot;) if $tail =~ m/^[^\s*$self_test_exception]/;
+        my $cmt_text = $opt_minus.$tail; # preliminary
+        if ($in_comment &gt; 0) {
+            report(&quot;unexpected '/*' inside multi-line comment&quot;);
+        } elsif ($tail =~ m|^(.*?)\*/(.*)$|) { # comment end: */ on same line
+            report(&quot;unexpected '/*' inside intra-line comment&quot;) if $1 =~ /\/\*/;
+            # blind comment text, preserving length and spaces
+            ($cmt_text, my $rest) = ($opt_minus.$1, $2);
+            $_ = &quot;$head@@&quot;.blind_nonspace($cmt_text).&quot;@@&quot;.$rest;
+            goto MATCH_COMMENT;
+        } else { # begin of multi-line comment
+            my $self_test_exception = $self_test ? &quot;(@\d?)?&quot; : &quot;&quot;;
+            report(&quot;text after '/*' in multi-line comment&quot;)
+                unless $tail =~ m/^$self_test_exception.?\s*$/;
+            # tail not essentially empty, first char already checked
+            # adapt to actual indentation of first line
+            $comment_indent = length($head) + 1;
+            $_ = &quot;$head@@&quot;.blind_nonspace($cmt_text);
+            $in_comment = 1;
+            $leading_comment = $head =~ m/^\s*$/; # there is code before beginning delimiter
+            $formatted_comment = $opt_minus eq &quot;-&quot;;
+        }
+    }
+
+    if ($in_comment &gt; 1) { # still inside multi-line comment (not at its begin or end)
+        m/^(\s*)\*?(\s*)(.*)$/;
+        $_ = $1.&quot;@&quot;.$2.blind_nonspace($3);
+    }
+
+    # handle special case of line after '#ifdef __cplusplus' (which typically appears in header files)
+    if ($ifdef__cplusplus) {
+        $ifdef__cplusplus = 0;
+        $_ = &quot;$1 $2&quot; if $contents =~ m/^(\s*extern\s*&quot;C&quot;\s*)\{(\s*)$/; # ignore opening brace in 'extern &quot;C&quot; {'
+        goto LINE_FINISHED if m/^\s*\}\s*$/; # ignore closing brace '}'
+    }
+
+    # check for over-long lines,
+    # while allowing trailing (also multi-line) string literals to go past $max_length
+    my $len = length; # total line length (without trailing '\n')
+    if ($len &gt; $max_length &amp;&amp;
+        !(m/^(.*)&quot;[^&quot;]*&quot;\s*[\)\}\]]*[,;]?\s*$/ # string literal terminated by '&quot;' (or '\'), then maybe )}],;
+          &amp;&amp; length($1) &lt; $max_length)
+        # this allows over-long trailing string literals with beginning col before $max_length
+        ) {
+        report(&quot;line length = $len &gt; &quot;.MAX_LINE_LENGTH);
+    }
+
+    # handle C++ / C99 - style end-of-line comments
+    if (my ($head, $cmt_text) = m|^(.*?)//(.*$)|) {
+        report(&quot;'//' end-of-line comment&quot;);  # the '//' comment style is not allowed for C90
+        # blind comment text, preserving length and spaces
+        $_ = &quot;$head@@&quot;.blind_nonspace($cmt_text);
+    }
+
+    # at this point all non-space portions of any types of comments have been blinded as @
+
+    goto LINE_FINISHED if m/^\s*$/; # essentially empty line: just whitespace (and maybe a trailing '\')
+
+    # intra-line whitespace nits @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+    my $in_multiline_comment = ($in_comment &gt; 1 || $in_comment &lt; 0); # $in_multiline_comment refers to line before
+    if (!$sloppy_SPC &amp;&amp; !($in_multiline_comment &amp;&amp; $formatted_comment)) {
+        sub dbl_SPC {
+            my $intra_line = shift;
+            return &quot;double SPC&quot;.($intra_line =~ m/@\s\s/ ?
+                                 $in_comment != 0 ? &quot; in multi-line comment&quot;
+                                                  : &quot; in intra-line comment&quot; : &quot;&quot;);
+        }
+        sub split_line_head {
+            my $comment_symbol =
+                $in_comment != 0 ? &quot;@&quot; : &quot;&quot;; # '@' will match the blinded leading '*' in multi-line comment
+                                             # $in_comment may pertain to the following line due to delayed check
+            # do not check for double SPC in leading spaces including any '#' (or '*' within multi-line comment)
+            shift =~ m/^(\s*([#$comment_symbol]\s*)?)(.*?)\s*$/;
+            return ($1, $3);
+        }
+        my ($head , $intra_line ) = split_line_head($_);
+        my ($head1, $intra_line1) = split_line_head($contents_before_ ) if $line_before &gt; 0;
+        my ($head2, $intra_line2) = split_line_head($contents_before_2) if $line_before2 &gt; 0;
+        if ($line_before &gt; 0) { # check with one line delay, such that at least $contents_before is available
+            sub column_alignments_only {
+                my $head = shift;
+                my $intra = shift;
+                my $contents = shift;
+                # check if all double SPC in $intra is used only for multi-line column alignment with $contents
+                my $offset = length($head);
+                for (my $col = 0; $col &lt; length($intra) - 2; $col++) {
+                   return 0 if substr($intra   , $col, 3) =~ m/\s\s\S/ # double space (after leading space)
+                          &amp;&amp; !(substr($contents, $col + $offset + 1, 2) =~ m/\s\S/)
+                }
+                return 1;
+            }
+            report_flexibly($line_before, dbl_SPC($intra_line1), $contents_before) if $intra_line1 =~ m/\s\s\S/ &amp;&amp;
+               !(    column_alignments_only($head1, $intra_line1, $_                )    # compare with $line
+                 || ($line_before2 &gt; 0 &amp;&amp;
+                     column_alignments_only($head1, $intra_line1, $contents_before_2))); # compare w/ $line_before2
+            report(dbl_SPC($intra_line)) if $intra_line  =~ m/\s\s\S/ &amp;&amp; eof
+                &amp;&amp; ! column_alignments_only($head , $intra_line , $contents_before_ )  ; # compare w/ $line_before
+        } elsif (eof) { # special case: just one line exists
+            report(dbl_SPC($intra_line)) if $intra_line  =~ m/\s\s\S/;
+        }
+        # ignore paths in #include
+        $intra_line =~ s/^(include\s*)(&quot;.*?&quot;|&lt;.*?&gt;)/$1/e if $head =~ m/#/;
+        # treat op= and comparison operators as simple '=', simplifying matching below
+        $intra_line =~ s/([\+\-\*\/\/%\&amp;\|\^\!&lt;&gt;=]|&lt;&lt;|&gt;&gt;)=/=/g;
+        # treat (type) variables within macro, indicated by trailing '\', as 'int' simplifying matching below
+        $intra_line =~ s/[A-Z_]+/int/g if $contents =~ m/^(.*?)\s*\\\s*$/;
+        # treat double &amp;&amp;, ||, &lt;&lt;, and &gt;&gt; as single ones, simplifying matching below
+        $intra_line =~ s/(&amp;&amp;|\|\||&lt;&lt;|&gt;&gt;)/substr($1, 0, 1)/eg;
+        # remove blinded comments etc. directly before ,;)}
+        while ($intra_line =~ s/\s*@+([,;)}\]])/$1/e) {} # /g does not work here
+        # treat remaining blinded comments and string literal contents as (single) space during matching below
+        $intra_line =~ s/@+/ /g;                     # note that double SPC has already been handled above
+        $intra_line =~ s/\s+$//;                     # strip any (resulting) space at EOL
+        $intra_line =~ s/(for\s*\();;(\))/&quot;$1$2&quot;/eg; # strip ';;' in for (;;)
+        $intra_line =~ s/(=\s*)\{ /&quot;$1@ &quot;/eg;        # do not report {SPC in initializers such as ' = { 0, };'
+        $intra_line =~ s/, \};/, @;/g;               # do not report SPC} in initializers such as ' = { 0, };'
+        report(&quot;SPC before '$1'&quot;) if $intra_line =~ m/[\w)\]]\s+(\+\+|--)/;  # postfix ++/-- with preceding space
+        report(&quot;SPC after '$1'&quot;)  if $intra_line =~ m/(\+\+|--)\s+[a-zA-Z_(]/; # prefix ++/-- with following space
+        $intra_line =~ s/\.\.\./@/g;                 # blind '...'
+        report(&quot;SPC before '$1'&quot;) if $intra_line =~ m/\s(\.|-&gt;)/;            # '.' or '-&gt;' with preceding space
+        report(&quot;SPC after '$1'&quot;)  if $intra_line =~ m/(\.|-&gt;)\s/;            # '.' or '-&gt;' with following space
+        $intra_line =~ s/\-\&gt;|\+\+|\-\-/@/g;         # blind '-&gt;,', '++', and '--'
+        report(&quot;SPC before '$2'&quot;)     if $intra_line =~ m/[^:]\s+(;)/;       # space before ';' but not after ':'
+        report(&quot;SPC before '$1'&quot;)     if $intra_line =~ m/\s([,)\]])/;       # space before ,)]
+        report(&quot;SPC after '$1'&quot;)      if $intra_line =~ m/([(\[~!])\s/;      # space after ([~!
+        report(&quot;SPC after '$1'&quot;)      if $intra_line =~ m/(defined)\s/;      # space after 'defined'
+        report(&quot;no SPC before '=' or '&lt;op&gt;='&quot;) if $intra_line =~ m/\S(=)/;   # '=' etc. without preceding space
+        report(&quot;no SPC before '$1'&quot;)  if $intra_line =~ m/\S([|\/%&lt;&gt;^\?])/;  # |/%&lt;&gt;^? without preceding space
+        # TODO ternary ':' without preceding SPC, while allowing no SPC before ':' after 'case'
+        report(&quot;no SPC before '$1'&quot;)  if $intra_line =~ m/[^\s{()\[]([+\-])/;# +/- without preceding space or {()[
+                                                                             # or ')' (which is used f type casts)
+        report(&quot;no SPC before '$1'&quot;)  if $intra_line =~ m/[^\s{()\[*]([*])/; # '*' without preceding space or {()[*
+        report(&quot;no SPC before '$1'&quot;)  if $intra_line =~ m/[^\s{()\[]([&amp;])/;  # '&amp;' without preceding space or {()[
+        report(&quot;no SPC after ternary '$1'&quot;) if $intra_line =~ m/(:)[^\s\d]/; # ':' without following space or digit
+        report(&quot;no SPC after '$1'&quot;)   if $intra_line =~ m/([,;=|\/%&lt;&gt;^\?])\S/; # ,;=|/%&lt;&gt;^? without following space
+        report(&quot;no SPC after binary '$1'&quot;) if $intra_line=~m/([*])[^\sa-zA-Z_(),*]/;# '*' w/o space or \w(),* after
+        # TODO unary '*' must not be followed by SPC
+        report(&quot;no SPC after binary '$1'&quot;) if $intra_line=~m/([&amp;])[^\sa-zA-Z_(]/;  # '&amp;' w/o following space or \w(
+        # TODO unary '&amp;' must not be followed by SPC
+        report(&quot;no SPC after binary '$1'&quot;) if $intra_line=~m/([+\-])[^\s\d(]/;  # +/- w/o following space or \d(
+        # TODO unary '+' and '-' must not be followed by SPC
+        report(&quot;no SPC after '$2'&quot;)   if $intra_line =~ m/(^|\W)(if|while|for|switch|case)[^\w\s]/; # kw w/o SPC
+        report(&quot;no SPC after '$2'&quot;)   if $intra_line =~ m/(^|\W)(return)[^\w\s;]/;  # return w/o SPC or ';'
+        report(&quot;SPC after function/macro name&quot;)
+                                      if $intra_line =~ m/(\w+)\s+\(/        # fn/macro name with space before '('
+       &amp;&amp; !($1 =~ m/^(if|while|for|switch|return|typedef|void|char|unsigned|int|long|float|double)$/) # not keyword
+                                    &amp;&amp; !(m/^\s*#\s*define\s/); # we skip macro definitions here because macros
+                                    # without parameters but with body beginning with '(', e.g., '#define X (1)',
+                                    # would lead to false positives - TODO also check for macros with parameters
+        report(&quot;no SPC before '{'&quot;)   if $intra_line =~ m/[^\s{(\[]\{/;      # '{' without preceding space or {([
+        report(&quot;no SPC after '}'&quot;)    if $intra_line =~ m/\}[^\s,;\])}]/;    # '}' without following space or ,;])}
+    }
+
+    # preprocessor directives @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+    # handle preprocessor directives
+    if (m/^\s*#(\s*)(\w+)/) { # line beginning with '#'
+        my $space_count = length($1); # maybe could also use indentation before '#'
+        my $directive = $2;
+        report(&quot;indent = $count != 0 for '#'&quot;) if $count != 0;
+        $directive_nesting-- if $directive =~ m/^(else|elif|endif)$/;
+        if ($directive_nesting &lt; 0) {
+            $directive_nesting = 0;
+            report(&quot;unexpected '#$directive'&quot;);
+        }
+        report(&quot;'#' directive nesting = $space_count != $directive_nesting&quot;) if $space_count != $directive_nesting;
+        $directive_nesting++ if $directive =~ m/^if|ifdef|ifndef|else|elif$/;
+        $ifdef__cplusplus = m/^\s*#\s*ifdef\s+__cplusplus\s*$/;
+        goto POSTPROCESS_DIRECTIVE unless $directive =~ m/^define$/; # skip normal code handling except for #define
+        # TODO improve handling of indents of preprocessor directives ('\', $in_directive != 0) vs. normal C code
+        $count = -1; # do not check indentation of #define
+    }
+
+    # adapt required indentation @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+    s/(\w*ASN1_[A-Z_]+END\w*([^(]|\(.*?\)|$))/$1;/g; # treat *ASN1_*END*(..) macro calls as if followed by ';'
+
+    my $nested_indents_position = 0;
+
+    # update indents according to leading closing brace(s) '}' or label or switch case
+    my $in_stmt = $in_expr || @nested_symbols != 0 || $in_typedecl != 0;
+    if ($in_stmt) { # expr/stmt/type decl/var def/fn hdr, i.e., not at block level
+        if (m/^([\s@]*\})/) { # leading '}', any preceding blinded comment must not be matched
+            my $head = $1;
+            update_nested_indents($head);
+            $nested_indents_position = length($head);
+            if (@nested_symbols &gt;= 1) {
+                $hanging_symbol = @nested_symbols[-1];
+                $expr_indent = @nested_indents[-1];
+            } else { # typically end of initialiizer expr or enum
+                $expr_indent = 0;
+            }
+        } elsif (m/^([\s@]*)(static_)?ASN1_ITEM_TEMPLATE_END(\W|$)/) { # workaround for ASN1 macro indented as '}'
+            $local_offset = -INDENT_LEVEL;
+            $expr_indent = 0;
+        } elsif (m/;.*?\}/) { # expr ends with ';' before '}'
+            report(&quot;code before '}'&quot;);
+        }
+    }
+    if (@in_do_hanging_offsets != 0 &amp;&amp; # note there is nothing like &quot;unexpected 'while'&quot;
+        m/^[\s@]*while(\W|$)/) { # leading 'while'
+        $hanging_offset = pop @in_do_hanging_offsets;
+    }
+    if ($if_maybe_terminated) {
+        if (m/(^|\W)else(\W|$)/) { # (not necessarily leading) 'else'
+            if (@in_if_hanging_offsets == 0) {
+                report(&quot;unexpected 'else'&quot;);
+            } else {
+                $hanging_offset = pop @in_if_hanging_offsets;
+            }
+        } else {
+            @in_if_hanging_offsets = (); # note there is nothing like &quot;unclosed 'if'&quot;
+            $hanging_offset = 0;
+        }
+    }
+    if (!$in_stmt) { # at block level, i.e., outside expr/stmt/type decl/var def/fn hdr
+        $if_maybe_terminated = 0;
+        if (my ($head, $before, $tail) = m/^([\s@]*([^{}]*)\})[\s@]*(.*)$/) { # leading closing '}', but possibly
+                                                                              # with non-whitespace non-'{' before
+            report(&quot;code after '}'&quot;) unless $tail eq &quot;&quot; || $tail =~ m/(else|while|OSSL_TRACE_END)(\W|$)/;
+            my $outermost_level = @nested_block_indents == 1 &amp;&amp; @nested_block_indents[0] == 0;
+            if (!$sloppy_bodylen &amp;&amp; $outermost_level &amp;&amp; $line_body_start != 0) {
+                my $body_len = $line - $line_body_start - 1;
+                report_flexibly($line_function_start, &quot;function body length = $body_len &gt; &quot;.MAX_BODY_LENGTH.&quot; lines&quot;,
+                    $last_function_header) if $body_len &gt; MAX_BODY_LENGTH;
+                $line_body_start = 0;
+            }
+            if ($before ne &quot;&quot;) { # non-whitespace non-'{' before '}'
+                report(&quot;code before '}'&quot;);
+            } else { # leading '}', any preceding blinded comment must not be matched
+                $local_offset = $block_indent + $hanging_offset - INDENT_LEVEL;
+                update_nested_indents($head);
+                $nested_indents_position = length($head);
+                $local_offset -= ($block_indent + $hanging_offset);
+                # in effect $local_offset = -INDENT_LEVEL relative to $block_indent + $hanging_offset values before
+            }
+        }
+
+        # handle opening brace '{' after if/else/while/for/switch/do on line before
+        if ($hanging_offset &gt; 0 &amp;&amp; m/^[\s@]*{/ &amp;&amp; # leading opening '{'
+            $line_before &gt; 0 &amp;&amp;
+            $contents_before_ =~ m/(^|^.*\W)(if|else|while|for|switch|do)(\W.*$|$)/) {
+            $keyword_opening_brace = $1;
+            $hanging_offset -= INDENT_LEVEL; # cancel newly hanging_offset
+        }
+
+        if (m/^[\s@]*(case|default)(\W.*$|$)/) { # leading 'case' or 'default'
+            my $keyword = $1;
+            report(&quot;code after $keyword: &quot;) if $2 =~ /:.*[^\s@].*$/;
+            $local_offset = -INDENT_LEVEL;
+        } else {
+            if (m/^([\s@]*)(\w+):/) { # (leading) label, cannot be &quot;default&quot;
+                $local_offset = -INDENT_LEVEL + 1 ;
+                $has_label = 1;
+            }
+        }
+    }
+
+    # potential adaptations of indent in first line of macro body in multi-line macro definition
+    if ($in_directive &gt; 0 &amp;&amp; $in_macro_header &gt; 0) {
+        if ($in_macro_header &gt; 1) { # still in macro definition header
+            $in_macro_header += parens_balance($_);
+        } else { # begin of macro body
+            $in_macro_header = 0;
+            if ($count == $block_indent - $directive_offset # body began with same indentation as preceding code
+                &amp;&amp; $sloppy_macro) { # workaround for this situation is enabled
+                $block_indent -= $directive_offset;
+                $directive_offset = 0;
+            }
+        }
+    }
+
+    # check required indentation @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+    check_indent() if $count &gt;= 0; # not for #define and not if multi-line string literal is continued
+
+    $in_comment = 0 if $in_comment &lt; 0; # multi-line comment has ended
+
+    # do some further checks @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+    my $outermost_level = $block_indent == 0 + ($in_directive &gt; 0 ? $directive_offset : 0);
+
+    report(&quot;more than one stmt&quot;) if !m/(^|\W)for(\W.*|$)/ &amp;&amp; # no 'for' - TODO improve matching
+        m/;.*;/; # two or more terminators ';', so more than one statement
+
+    # check for code block containing a single line/statement
+    if ($line_before2 &gt; 0 &amp;&amp; !$outermost_level &amp;&amp; # within function body
+        $in_typedecl == 0 &amp;&amp; @nested_indents == 0 &amp;&amp; # not within type declaration nor inside stmt/expr
+        m/^[\s@]*\}/) { # leading closing brace '}', any preceding blinded comment must not be matched
+        # TODO extend detection from single-line to potentially multi-line statement
+        if ($line_opening_brace &gt; 0 &amp;&amp;
+            ($line_opening_brace == $line_before2 ||
+             $line_opening_brace == $line_before)
+            &amp;&amp; $contents_before =~ m/;/) { # there is at least one terminator ';', so there is some stmt
+            # TODO do not report cases where a further else branch
+            # follows with a block containg more than one line/statement
+            report_flexibly($line_before, &quot;'$keyword_opening_brace' { 1 stmt }&quot;, $contents_before);
+        }
+    }
+
+    report(&quot;one-letter name '$2'&quot;) if (m/(^|.*\W)([lIO])(\W.*|$)/); # single-letter name 'l', 'I', or 'O'
+
+    # TODO report empty line within local variable definitions
+
+    # TODO report missing empty line after local variable definitions
+
+    # TODO report needless use of parentheses, while
+    #      macro parameters should always be in parens (except when passed on), e.g., '#define ID(x) (x)'
+
+    # adapt required indentation for following lines @@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+    # set $in_expr, $in_paren_expr, and $hanging_offset for if/while/for/switch, return/enum, and assignment RHS
+    my $paren_expr_start = 0;
+    my $return_enum_start = 0;
+    my $assignment_start = 0;
+    my $tmp = $_;
+    $tmp =~ s/[\!&lt;&gt;=]=/@@/g; # blind (in-)equality symbols like '&lt;=' as '@@' to prevent matching them as '=' below
+    if      (m/^((^|.*\W)(if|while|for|switch))(\W.*|$)$/) { # (last) if/for/while/switch
+        $paren_expr_start = 1;
+    } elsif (m/^((^|.*\W)(return|enum))(\W.*|$)/             # (last) return/enum
+        &amp;&amp; !$in_expr &amp;&amp; @nested_indents == 0 &amp;&amp; parens_balance($1) == 0) { # not nested enum
+        $return_enum_start = 1;
+    } elsif ($tmp =~ m/^(([^=]*)(=))(.*)$/                   # (last) '=', i.e., assignment
+        &amp;&amp; !$in_expr &amp;&amp; @nested_indents == 0 &amp;&amp; parens_balance($1) == 0) { # not nested assignment
+        $assignment_start = 1;
+    }
+    if ($paren_expr_start || $return_enum_start || $assignment_start)
+    {
+        my ($head, $mid, $tail) = ($1, $3, $4);
+        $keyword_opening_brace = $mid if $mid ne &quot;=&quot; &amp;&amp; $tail =~ m/\{/;
+        push @in_if_hanging_offsets, $hanging_offset if $mid eq &quot;if&quot;;
+
+        # already handle $head, i.e., anything before expression
+        update_nested_indents($head, $nested_indents_position);
+        $nested_indents_position = length($head);
+        # now can set $in_expr and $in_paren_expr
+        $in_expr = 1;
+        $in_paren_expr = 1 if $paren_expr_start;
+        if ($mid eq &quot;while&quot; &amp;&amp; @in_do_hanging_offsets != 0) {
+            $hanging_offset = pop @in_do_hanging_offsets;
+        } else {
+            $hanging_offset += INDENT_LEVEL; # tentatively set hanging_offset, may be canceled by following '{'
+        }
+    }
+
+    # set $hanging_offset and $keyword_opening_brace for do/else
+    if (my ($head, $mid, $tail) = m/(^|^.*\W)(else|do)(\W.*|$)$/) { # last else/do, where 'do' is preferred
+        my $code_before = $head =~ m/[^\s\@}]/; # leading non-whitespace non-comment non-'}'
+        report(&quot;code before '$mid'&quot;) if $code_before;
+        report(&quot;code after '$mid'&quot; ) if $tail =~ m/[^\s\@{]/# trailing non-whitespace non-comment non-'{' (non-'\')
+                                                    &amp;&amp; !($mid eq &quot;else&quot; &amp;&amp; $tail =~ m/[\s@]*if(\W|$)/);
+        if ($mid eq &quot;do&quot;) { # workarounds for code before 'do'
+            if ($head =~ m/(^|^.*\W)(else)(\W.*$|$)/) { # 'else' ... 'do'
+                $hanging_offset += INDENT_LEVEL; # tentatively set hanging_offset, may be canceled by following '{'
+            }
+            if ($head =~ m/;/) { # terminator ';' ... 'do'
+                @in_if_hanging_offsets = (); # note there is nothing like &quot;unclosed 'if'&quot;
+                $hanging_offset = 0;
+            }
+        }
+        push @in_do_hanging_offsets, $hanging_offset if $mid eq &quot;do&quot;;
+        if ($code_before &amp;&amp; $mid eq &quot;do&quot;) {
+            $hanging_offset = length($head) - $block_indent;
+        }
+        if (!$in_paren_expr) {
+            $keyword_opening_brace = $mid if $tail =~ m/\{/;
+            $hanging_offset += INDENT_LEVEL;
+        }
+    }
+
+    # set $in_typedecl and potentially $hanging_offset for type declaration
+    if (!$in_expr &amp;&amp; @nested_indents == 0 &amp;&amp; # not in expression
+        m/(^|^.*\W)(typedef|struct|union|enum)(\W.*|$)$/ &amp;&amp;
+        parens_balance($1) == 0) { # not in newly started expression
+        # not needed: $keyword_opening_brace = $2 if $3 =~ m/\{/;
+        $in_typedecl++;
+        $hanging_offset += INDENT_LEVEL if m/\*.*\(/; # '*' followed by '(' - seems consistent with Emacs C mode
+    }
+
+    my $bak_in_expr = $in_expr;
+    my $terminator_position = update_nested_indents($_, $nested_indents_position);
+
+    if ($bak_in_expr) {
+        # on end of non-if/while/for/switch (multi-line) expression (i.e., return/enum/assignment) and
+        # on end of statement/type declaration/variable definition/function header
+        if ($terminator_position &gt;= 0 &amp;&amp; ($in_typedecl == 0 || @nested_indents == 0)) {
+            check_nested_nonblock_indents(&quot;expr&quot;);
+            $in_expr = 0;
+        }
+    } else {
+        check_nested_nonblock_indents($in_typedecl == 0 ? &quot;stmt&quot; : &quot;decl&quot;) if $terminator_position &gt;= 0;
+    }
+
+    # on ';', which terminates the current statement/type declaration/variable definition/function declaration
+    if ($terminator_position &gt;= 0) {
+        my $tail = substr($_, $terminator_position + 1);
+        if (@in_if_hanging_offsets != 0) {
+            if ($tail =~ m/\s*else(\W|$)/) {
+                pop @in_if_hanging_offsets;
+                $hanging_offset -= INDENT_LEVEL;
+            } elsif ($tail =~ m/[^\s@]/) { # code (not just comment) follows
+                @in_if_hanging_offsets = (); # note there is nothing like &quot;unclosed 'if'&quot;
+                $hanging_offset = 0;
+            } else {
+                $if_maybe_terminated = 1;
+            }
+        } elsif ($tail =~ m/^[\s@]*$/) { # ';' has been trailing, i.e. there is nothing but whitespace and comments
+            $hanging_offset = 0; # reset in case of terminated assignment ('=') etc.
+        }
+        $in_typedecl-- if $in_typedecl != 0 &amp;&amp; @nested_in_typedecl == 0; # TODO handle multiple type decls per line
+        m/(;[^;]*)$/; # match last ';'
+        $terminator_position = length($_) - length($1) if $1;
+        # new $terminator_position value may be after the earlier one in case multiple terminators on current line
+        # TODO check treatment in case of multiple terminators on current line
+        update_nested_indents($_, $terminator_position + 1);
+    }
+
+    # set hanging expression indent according to nested indents - TODO maybe do better in update_nested_indents()
+    # also if $in_expr is 0: in statement/type declaration/variable definition/function header
+    $expr_indent = 0;
+    for (my $i = -1; $i &gt;= <A HREF="../../../mailman/listinfo/openssl-commits.html">- at nested_symbols</A>; $i--) {
+        if (@nested_symbols[$i] ne &quot;?&quot;) { # conditionals '?' ... ':' are treated specially in check_indent()
+            $hanging_symbol = @nested_symbols[$i];
+            $expr_indent = $nested_indents[$i];
+            # $expr_indent is guaranteed to be != 0 unless @nested_indents contains just outer conditionals
+            last;
+        }
+    }
+
+    # remember line number and header containing name of last function defined for reports w.r.t. MAX_BODY_LENGTH
+    if ($outermost_level &amp;&amp; m/(\w+)\s*\(/ &amp;&amp; $1 ne &quot;STACK_OF&quot;) {
+        $line_function_start = $line;
+        $last_function_header = $contents;
+    }
+
+    # special checks for last, typically trailing opening brace '{' in line
+    if (my ($head, $tail) = m/^(.*)\{(.*)$/) { # match last ... '{'
+        if ($in_directive == 0 &amp;&amp; !$in_expr &amp;&amp; $in_typedecl == 0) {
+            if ($outermost_level) {
+                if (!$assignment_start &amp;&amp; !$bak_in_expr) {
+                    # at end of function definition header (or stmt or var definition)
+                    report(&quot;'{' not at beginning&quot;) if $head ne &quot;&quot;;
+                    $line_body_start = $contents =~ m/LONG BODY/ ? 0 : $line;
+                }
+            } else {
+                $line_opening_brace = $line if $keyword_opening_brace =~ m/do|while|for/;
+                # using, not assigning, $keyword_opening_brace here because it could be on an earlier line
+                $line_opening_brace = $line if $keyword_opening_brace =~ m/if|else/ &amp;&amp; $extended_1_stmt &amp;&amp;
+                # TODO prevent false positives for if/else where braces around single-statement branches
+                # should be avoided but only if all branches have just single statements
+                # The following helps detecting the exception when handling multiple 'if ... else' branches:
+                    !($keyword_opening_brace eq &quot;else&quot; &amp;&amp; $line_opening_brace &lt; $line_before2);
+            }
+            report(&quot;code after '{'&quot;) if $tail=~ m/[^\s\@]/ &amp;&amp; # trailing non-whitespace non-comment (non-'\')
+                                      !($tail=~ m/\}/);  # no '}' after last '{'
+        }
+    }
+
+    # check for opening brace after if/while/for/switch/do not on same line
+    # note that &quot;no '{' on same line after '} else'&quot; is handled further below
+    if (/^[\s@]*{/ &amp;&amp; # leading '{'
+        $line_before &gt; 0 &amp;&amp;
+        (my ($head, $mid, $tail) = ($contents_before_ =~ m/(^|^.*\W)(if|while|for|switch|do)(\W.*$|$)/))) {
+        my $brace_after  = $tail =~ /^[\s@]*{/; # any whitespace or comments then '{'
+        report(&quot;'{' not on same line as preceding '$mid'&quot;) if !$brace_after;
+    }
+    # check for closing brace on line before 'else' not followed by leading '{'
+    elsif (my ($head, $tail) = m/(^|^.*\W)else(\W.*$|$)/) {
+        if (parens_balance($tail) == 0 &amp;&amp;  # avoid false positive due to unfinished expr on current line
+            !($tail =~ m/{/) &amp;&amp; # after 'else' no '{' on same line
+            !($head =~ m/}[\s@]*$/) &amp;&amp; # not: '}' then any whitespace or comments before 'else'
+            $line_before &gt; 0 &amp;&amp; $contents_before_ =~ /}[\s@]*$/) { # trailing '}' on line before
+            report(&quot;no '{' after '} else'&quot;);
+        }
+    }
+
+    # check for closing brace before 'while' not on same line
+    if (my ($head, $tail) = m/(^|^.*\W)while(\W.*$|$)/) {
+        my $brace_before = $head =~ m/}[\s@]*$/; # '}' then any whitespace or comments
+        # possibly 'if (...)' (with potentially inner '(' and ')') then any whitespace or comments then '{'
+        if (!$brace_before &amp;&amp;
+            # does not work here: @in_do_hanging_offsets != 0 &amp;&amp; #'while' terminates loop
+            parens_balance($tail) == 0 &amp;&amp;  # avoid false positive due to unfinished expr on current line
+            $tail =~ /;/ &amp;&amp; # 'while' terminates loop (by ';')
+            $line_before &gt; 0 &amp;&amp;
+            $contents_before_ =~ /}[\s@]*$/) { # on line before: '}' then any whitespace or comments
+                report(&quot;'while' not on same line as preceding '}'&quot;);
+            }
+    }
+
+    # check for missing brace on same line before or after 'else'
+    if (my ($head, $tail) = m/(^|^.*\W)else(\W.*$|$)/) {
+        my $brace_before = $head =~ /}[\s@]*$/; # '}' then any whitespace or comments
+        my $brace_after  = $tail =~ /^[\s@]*if[\s@]*\(.*\)[\s@]*{|[\s@]*{/;
+        # possibly 'if (...)' (with potentially inner '(' and ')') then any whitespace or comments then '{'
+        if (!$brace_before) {
+            if ($line_before &gt; 0 &amp;&amp; $contents_before_ =~ /}[\s@]*$/) {
+                report(&quot;'else' not on same line as preceding '}'&quot;);
+            } elsif (parens_balance($tail) == 0) { # avoid false positive due to unfinished expr on current line
+                report(&quot;no '}' on same line before 'else ... {'&quot;) if $brace_after;
+            }
+        } elsif (parens_balance($tail) == 0) { # avoid false positive due to unfinished expr on current line
+            report(&quot;no '{' on same line after '} else'&quot;) if $brace_before &amp;&amp; !$brace_after;
+        }
+    }
+
+  POSTPROCESS_DIRECTIVE:
+    # on begin of multi-line preprocessor directive, adapt indent
+    # need to use original line contents because trailing '\' may have been stripped above
+    if ($contents =~ m/^(.*?)[\s@]*\\[\s@]*$/) { # trailing '\' (which is not stripped from $contents),
+        # typically used in macro definitions (or other preprocessor directives)
+        if ($in_directive == 0) {
+            $in_macro_header = m/^\s*#\s*define(\W|$)?(.*)/ ? 1 + parens_balance($2) : 0; # '#define' is beginning
+            $directive_offset = INDENT_LEVEL;
+            $block_indent += $directive_offset;
+        }
+        $in_directive += 1;
+    }
+
+    # post-processing at end of line @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+  LINE_FINISHED:
+    # on end of multi-line preprocessor directive, adapt indent
+    if ($in_directive &gt; 0 &amp;&amp;
+        # need to use original line contents because trailing \ may have been stripped
+        !($contents =~ m/^(.*?)[\s@]*\\[\s@]*$/)) { # no trailing '\'
+        $block_indent -= $directive_offset;
+        $in_directive = 0;
+        # macro body typically does not include terminating ';'
+        $hanging_offset = 0; # compensate for this in case macro ends, e.g., as 'while (0)'
+    }
+
+    unless (m/^\s*$/) { # essentially empty line: just whitespace (and maybe a '\')
+        $line_before2      = $line_before;
+        $contents_before2  = $contents_before;
+        $contents_before_2 = $contents_before_;
+        $line_before       = $line;
+        $contents_before   = $contents;
+        $contents_before_  = $_;
+        $count_before      = $count;
+    }
+
+    if ($self_test) { # debugging
+        my $should_report = $contents =~ m/\*@(\d)?/ ? 1 : 0;
+        $should_report = +$1 if $should_report != 0 &amp;&amp; defined $1;
+        print(&quot;$ARGV:$line:$num_reports_line reports on:$contents&quot;)
+            if $num_reports_line != $should_report;
+    }
+    $num_reports_line = 0;
+
+    # post-processing at end of file @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+    if (eof) {
+        # check for essentially empty line (which may include a '\') just before EOF
+        report(($1 eq &quot;\n&quot; ? &quot;empty line&quot; : $2 ne &quot;&quot; ? &quot;'\\'&quot; : &quot;whitespace&quot;).&quot; at EOF&quot;)
+            if $contents =~ m/^(\s*(\\?)\s*)$/;
+
+        # report unclosed expression-level nesting
+        check_nested_nonblock_indents(&quot;expr at EOF&quot;); # also adapts @nested_block_indents
+
+        # sanity-check balance of block-level { ... } via final $block_indent at end of file
+        report_flexibly($line, <A HREF="../../../mailman/listinfo/openssl-commits.html">+ at nested_block_indents.</A>&quot; unclosed '{'&quot;, &quot;(EOF)\n&quot;) if @nested_block_indents != 0;
+
+        # sanity-check balance of #if ... #endif via final preprocessor directive indent at end of file
+        report_flexibly($line, &quot;$directive_nesting unclosed '#if'&quot;, &quot;(EOF)\n&quot;) if $directive_nesting != 0;
+
+        reset_file_state();
+    }
+}
+
+# final summary report @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+my $num_other_reports = $num_reports - $num_indent_reports - $num_nesting_issues
+    - $num_syntax_issues - $num_SPC_reports - $num_length_reports;
+print &quot;$num_reports ($num_indent_reports indentation, $num_nesting_issues directive nesting, &quot;.
+    &quot;$num_syntax_issues syntax, $num_SPC_reports whitespace, $num_length_reports length, $num_other_reports other)&quot;.
+    &quot; issues have been found by $0\n&quot; if $num_reports != 0 &amp;&amp; !$self_test;
diff --git a/util/openssl-format-source b/util/openssl-format-source
deleted file mode 100755
index dc6a65d30e..0000000000
--- a/util/openssl-format-source
+++ /dev/null
@@ -1,175 +0,0 @@
-#!/bin/sh
-#
-# Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
-
-#
-# openssl-format-source
-# - format source tree according to OpenSSL coding style using indent
-#
-# usage:
-#   openssl-format-source [-v] [-n] [file|directory] ...
-#
-# note: the indent options assume GNU indent v2.2.10 which was released
-#       Feb-2009 so if you have an older indent the options may not
-#	match what is expected
-#
-# any marked block comment blocks have to be moved to align manually after
-# the reformatting has been completed as marking a block causes indent to
-# not move it at all ...
-#
-
-PATH=/usr/local/bin:/bin:/usr/bin:$PATH
-export PATH
-HERE=&quot;`dirname $0`&quot;
-
-set -e
-
-INDENT=indent
-uname -s | grep BSD &gt; /dev/null &amp;&amp; type gindent &gt; /dev/null 2&gt;&amp;1 &amp;&amp; INDENT=gindent
-
-if [ $# -eq 0 ]; then
-  echo &quot;usage: $0 [-v] [-n] [-c] [sourcefile|sourcedir] ...&quot; &gt;&amp;2
-  exit 1
-fi
-
-VERBOSE=false
-DONT=false
-STOPARGS=false
-COMMENTS=false
-CHANGED=false
-DEBUG=&quot;&quot;
-
-# for this exercise, we want to force the openssl style, so we roll
-# our own indent profile, which is at a well known location
-INDENT_PROFILE=&quot;$HERE/indent.pro&quot;
-export INDENT_PROFILE
-if [ ! -f &quot;$INDENT_PROFILE&quot; ]; then
-  echo &quot;$0: unable to locate the openssl indent.pro file&quot; &gt;&amp;2
-  exit 1
-fi
-
-# Extra arguments; for adding the comment-formatting
-INDENT_ARGS=&quot;&quot;
-for i
-do
-  if [ &quot;$STOPARGS&quot; != &quot;true&quot; ]; then
-    case $i in
-      --) STOPARGS=&quot;true&quot;; continue;;
-      -n) DONT=&quot;true&quot;; continue;;
-      -v) VERBOSE=&quot;true&quot;;
-	  echo &quot;INDENT_PROFILE=$INDENT_PROFILE&quot;;
-	  continue;;
-      -c) COMMENTS=&quot;true&quot;;
-      	  INDENT_ARGS=&quot;-fc1 -fca -cdb -sc&quot;;
-	  continue;;
-      -nc) COMMENTS=&quot;true&quot;;
-	  continue;;
-      -d) DEBUG='eval tee &quot;$j.pre&quot; |'
-	  continue;;
-    esac
-  fi
-
-  if [ -d &quot;$i&quot; ]; then
-    LIST=`find &quot;$i&quot; -name '*.[ch]' -print`
-  else
-    if [ ! -f &quot;$i&quot; ]; then
-      echo &quot;$0: source file not found: $i&quot; &gt;&amp;2
-      exit 1
-    fi
-    LIST=&quot;$i&quot;
-  fi
-
-  for j in $LIST
-  do
-    # ignore symlinks - we only ever process the base file - so if we
-    # expand a directory tree we need to ignore any located symlinks
-    if [ -d &quot;$i&quot; ]; then
-      if [ -h &quot;$j&quot; ]; then
-	continue;
-      fi
-    fi
-
-    if [ &quot;$DONT&quot; = &quot;false&quot; ]; then
-      tmp=$(mktemp /tmp/indent.XXXXXX)
-      trap 'rm -f &quot;$tmp&quot;' HUP INT TERM EXIT
-
-      case `basename $j` in
-	# the list of files that indent is unable to handle correctly
-	# that we simply leave alone for manual formatting now
-	obj_dat.h|aes_core.c|aes_x86core.c|ecp_nistz256.c)
-	  echo &quot;skipping $j&quot;
-	  ;;
-	*)
-	  if [ &quot;$COMMENTS&quot; = &quot;true&quot; ]; then
-	    # we have to mark single line comments as /*- ...*/ to stop indent
-	    # messing with them, run expand then indent as usual but with the
-	    # the process-comments options and then undo that marking, and then
-	    # finally re-run indent without process-comments so the marked-to-
-	    # be-ignored comments we did automatically end up getting moved
-	    # into the right position within the code as indent leaves marked
-	    # comments entirely untouched - we appear to have no way to avoid
-	    # the double processing and get the desired output
-	    cat &quot;$j&quot; | \
-	    expand | \
-	    perl -0 -np \
-	      -e 's/(\n#[ \t]*ifdef[ \t]+__cplusplus\n[^\n]*\n#[ \t]*endif\n)/\n\/**INDENT-OFF**\/$1\/**INDENT-ON**\/\n/g;' \
-	      -e 's/(\n\/\*\!)/\n\/**/g;' \
-	      -e 's/(STACK_OF|LHASH_OF)\(([^ \t,\)]+)\)( |\n)/$1_$2_$3/g;' \
-	      | \
-	    perl -np \
-	      -e 's/^([ \t]*)\/\*([ \t]+.*)\*\/[ \t]*$/my ($x1,$x2) = ($1, $2); if (length(&quot;$x1$x2&quot;)&lt;75 &amp;&amp; $x2 !~ m#^\s*\*INDENT-(ON|OFF)\*\s*$#) {$c=&quot;-&quot;}else{$c=&quot;&quot;}; &quot;$x1\/*$c$x2*\/&quot;/e;' \
-	      -e 's/^\/\* ((Copyright|=|----).*)$/\/*-$1/;' \
-	      -e 's/^((DECLARE|IMPLEMENT)_.*)$/\/**INDENT-OFF**\/\n$1\n\/**INDENT-ON**\//;' \
-	      -e 's/^([ \t]*(make_dh|make_dh_bn|make_rfc5114_td)\(.*\)[ \t,]*)$/\/**INDENT-OFF**\/\n$1\n\/**INDENT-ON**\//;' \
-	      -e 's/^(ASN1_ADB_TEMPLATE\(.*)$/\/**INDENT-OFF**\/\n$1\n\/**INDENT-ON**\//;' \
-	      -e 's/^((ASN1|ADB)_.*_(end|END)\(.*[\){=,;]+[ \t]*)$/$1\n\/**INDENT-ON**\//;' \
-	      -e '/ASN1_(ITEM_ref|ITEM_ptr|ITEM_rptr|PCTX)/ || s/^((ASN1|ADB)_[^\*]*[){=,]+[ \t]*)$/\/**INDENT-OFF**\/\n$1/;' \
-	      -e 's/^(} (ASN1|ADB)_[^\*]*[\){=,;]+)$/$1\n\/**INDENT-ON**\//;' \
-	      | \
-	      $DEBUG $INDENT $INDENT_ARGS | \
-	      perl -np \
-		-e 's/^([ \t]*)\/\*-(.*)\*\/[ \t]*$/$1\/*$2*\//;' \
-		-e 's/^\/\*-((Copyright|=|----).*)$/\/* $1/;' \
-	      | $INDENT | \
-	      perl -0 -np \
-		-e 's/\/\*\*INDENT-(ON|OFF)\*\*\/\n//g;' \
-	      | perl -np \
-	        -e 's/(STACK_OF|LHASH_OF)_([^ \t,]+)_( |\/)/$1($2)$3/g;' \
-	        -e 's/(STACK_OF|LHASH_OF)_([^ \t,]+)_$/$1($2)/g;' \
-	      | perl &quot;$HERE&quot;/su-filter.pl \
-	      &gt; &quot;$tmp&quot;
-	  else
-	    expand &quot;$j&quot; | $INDENT $INDENT_ARGS &gt; &quot;$tmp&quot;
-	  fi;
-	  if cmp -s &quot;$tmp&quot; &quot;$j&quot;; then
-	    if [ &quot;$VERBOSE&quot; = &quot;true&quot; ]; then
-	      echo &quot;$j unchanged&quot;
-	    fi
-	    rm &quot;$tmp&quot;
-	  else
-	    if [ &quot;$VERBOSE&quot; = &quot;true&quot; ]; then
-	      echo &quot;$j changed&quot;
-	    fi
-	    CHANGED=true
-	    mv &quot;$tmp&quot; &quot;$j&quot;
-	  fi
-	  ;;
-      esac
-    fi
-  done
-done
-
-
-if [ &quot;$VERBOSE&quot; = &quot;true&quot; ]; then
-  echo
-  if [ &quot;$CHANGED&quot; = &quot;true&quot; ]; then
-    echo &quot;SOURCE WAS MODIFIED&quot;
-  else
-    echo &quot;SOURCE WAS NOT MODIFIED&quot;
-  fi
-fi
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="027847.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="027857.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#27848">[ date ]</a>
              <a href="thread.html#27848">[ thread ]</a>
              <a href="subject.html#27848">[ subject ]</a>
              <a href="author.html#27848">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
