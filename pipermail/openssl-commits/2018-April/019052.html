<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2018-April/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1524074603.216593.2321.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019050.html">
   <LINK REL="Next"  HREF="019053.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Andy Polyakov</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1524074603.216593.2321.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">appro at openssl.org
       </A><BR>
    <I>Wed Apr 18 18:03:23 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="019050.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="019053.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19052">[ date ]</a>
              <a href="thread.html#19052">[ thread ]</a>
              <a href="subject.html#19052">[ subject ]</a>
              <a href="author.html#19052">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  f3d3b362553d95047d93608edd15d20aa6e6e0fd (commit)
       via  c4220c0f9a8c944c31450b0cd6e01014687f28db (commit)
       via  3f1f62b97b795d973d40c32735eedee70140731c (commit)
       via  17cde9c2e404a0ada05601fb726dbaed6c532112 (commit)
       via  3f473b936a292262a020353e99f896cabfedc947 (commit)
      from  5bb1cd2292b388263a0cc05392bb99141212aa53 (commit)


- Log -----------------------------------------------------------------
commit f3d3b362553d95047d93608edd15d20aa6e6e0fd
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Wed Apr 18 10:42:23 2018 +0200

    TLSProxy/Proxy.pm: preclude output intermix.
    
    s_server -rev emits info output on stderr, i.e. unbufferred, which
    risks intermixing with output from TLSProxy itself on non-line
    boundaries, which in turn is confusing to TAP parser.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/5975">https://github.com/openssl/openssl/pull/5975</A>)

commit c4220c0f9a8c944c31450b0cd6e01014687f28db
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon Apr 16 22:32:10 2018 +0200

    recipes/70-test_ssl{cbcpadding,extension,records}: make it work w/fragmentation.
    
    This fixes only those tests that were failing when network data was
    fragmented. Remaining ones might succeed for &quot;wrong reasons&quot;. Bunch
    of tests have to fail to be considered successful and when data is
    fragmented they might fail for reasons other than originally intended.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/5975">https://github.com/openssl/openssl/pull/5975</A>)

commit 3f1f62b97b795d973d40c32735eedee70140731c
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon Apr 16 14:08:35 2018 +0200

    TLSProxy/Record.pm: add is_fatal_alert method.
    
    (resolve uninitialized variable warning and harmonize output).
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/5975">https://github.com/openssl/openssl/pull/5975</A>)

commit 17cde9c2e404a0ada05601fb726dbaed6c532112
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon Apr 16 14:13:07 2018 +0200

    TLSProxy/Proxy.pm: refine NewSessionTicket detection.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/5975">https://github.com/openssl/openssl/pull/5975</A>)

commit 3f473b936a292262a020353e99f896cabfedc947
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon Apr 16 14:10:39 2018 +0200

    TLSProxy/Message.pm: refine end-of-conversation detection logic.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/5975">https://github.com/openssl/openssl/pull/5975</A>)

-----------------------------------------------------------------------

Summary of changes:
 test/recipes/70-test_sslcbcpadding.t |  31 +++++++--
 test/recipes/70-test_sslextension.t  |  49 +++++++++++---
 test/recipes/70-test_sslrecords.t    | 126 ++++++++++++++++++++++++-----------
 util/perl/TLSProxy/Message.pm        |   7 +-
 util/perl/TLSProxy/Proxy.pm          |  21 ++++--
 util/perl/TLSProxy/Record.pm         |  22 ++++--
 6 files changed, 184 insertions(+), 72 deletions(-)

diff --git a/test/recipes/70-test_sslcbcpadding.t b/test/recipes/70-test_sslcbcpadding.t
index 85b26b8..5594376 100644
--- a/test/recipes/70-test_sslcbcpadding.t
+++ b/test/recipes/70-test_sslcbcpadding.t
@@ -7,6 +7,8 @@
 # <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
 
 use strict;
+use feature 'state';
+
 use OpenSSL::Test qw/:DEFAULT cmdstr srctop_file bldtop_dir/;
 use OpenSSL::Test::Utils;
 use TLSProxy::Proxy;
@@ -41,26 +43,31 @@ my @test_offsets = (0, 128, 254, 255);
 # Test that maximally-padded records are accepted.
 my $bad_padding_offset = -1;
 $proxy-&gt;serverflags(&quot;-tls1_2&quot;);
+$proxy-&gt;serverconnects(1 + scalar(@test_offsets));
 $proxy-&gt;start() or plan skip_all =&gt; &quot;Unable to start up Proxy for tests&quot;;
 plan tests =&gt; 1 + scalar(@test_offsets);
 ok(TLSProxy::Message-&gt;success(), &quot;Maximally-padded record test&quot;);
 
 # Test that invalid padding is rejected.
+my $fatal_alert;    # set by add_maximal_padding_filter on client's fatal alert
+
 foreach my $offset (@test_offsets) {
-    $proxy-&gt;clear();
-    $proxy-&gt;serverflags(&quot;-tls1_2&quot;);
     $bad_padding_offset = $offset;
-    $proxy-&gt;start();
-    ok(TLSProxy::Message-&gt;fail(), &quot;Invalid padding byte $bad_padding_offset&quot;);
+    $fatal_alert = 0;
+    $proxy-&gt;clearClient();
+    $proxy-&gt;clientstart();
+    ok($fatal_alert, &quot;Invalid padding byte $bad_padding_offset&quot;);
 }
 
 sub add_maximal_padding_filter
 {
     my $proxy = shift;
+    my $messages = $proxy-&gt;message_list;
+    state $sent_corrupted_payload;
 
     if ($proxy-&gt;flight == 0) {
         # Disable Encrypt-then-MAC.
-        foreach my $message (@{$proxy-&gt;message_list}) {
+        foreach my $message (@{$messages}) {
             if ($message-&gt;mt != TLSProxy::Message::MT_CLIENT_HELLO) {
                 next;
             }
@@ -69,9 +76,16 @@ sub add_maximal_padding_filter
             $message-&gt;process_extensions();
             $message-&gt;repack();
         }
+        $sent_corrupted_payload = 0;
+        return;
     }
 
-    if ($proxy-&gt;flight == 3) {
+    my $last_message = @{$messages}[-1];
+    if (defined($last_message)
+        &amp;&amp; $last_message-&gt;server
+        &amp;&amp; $last_message-&gt;mt == TLSProxy::Message::MT_FINISHED
+        &amp;&amp; !@{$last_message-&gt;records}[0]-&gt;{sent}) {
+
         # Insert a maximally-padded record. Assume a block size of 16 (AES) and
         # a MAC length of 20 (SHA-1).
         my $block_size = 16;
@@ -88,6 +102,7 @@ sub add_maximal_padding_filter
         # Add padding.
         for (my $i = 0; $i &lt; 256; $i++) {
             if ($i == $bad_padding_offset) {
+                $sent_corrupted_payload = 1;
                 $data .= &quot;\xfe&quot;;
             } else {
                 $data .= &quot;\xff&quot;;
@@ -108,5 +123,9 @@ sub add_maximal_padding_filter
 
         # Send the record immediately after the server Finished.
         push @{$proxy-&gt;record_list}, $record;
+    } elsif ($sent_corrupted_payload) {
+        # Check for bad_record_mac from client
+        my $last_record = @{$proxy-&gt;record_list}[-1];
+        $fatal_alert = 1 if $last_record-&gt;is_fatal_alert(0) == 20;
     }
 }
diff --git a/test/recipes/70-test_sslextension.t b/test/recipes/70-test_sslextension.t
index 142ce0e..20e1933 100644
--- a/test/recipes/70-test_sslextension.t
+++ b/test/recipes/70-test_sslextension.t
@@ -7,6 +7,8 @@
 # <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
 
 use strict;
+use feature 'state';
+
 use OpenSSL::Test qw/:DEFAULT cmdstr srctop_file bldtop_dir/;
 use OpenSSL::Test::Utils;
 use TLSProxy::Proxy;
@@ -37,6 +39,7 @@ use constant {
 };
 
 my $testtype;
+my $fatal_alert = 0;    # set by filter on fatal alert
 
 $ENV{OPENSSL_ia32cap} = '~0x200000200000000';
 my $proxy = TLSProxy::Proxy-&gt;new(
@@ -98,11 +101,13 @@ sub inject_duplicate_extension_clienthello
     my $proxy = shift;
 
     # We're only interested in the initial ClientHello
-    if ($proxy-&gt;flight != 0) {
+    if ($proxy-&gt;flight == 0) {
+        inject_duplicate_extension($proxy, TLSProxy::Message::MT_CLIENT_HELLO);
         return;
     }
 
-    inject_duplicate_extension($proxy, TLSProxy::Message::MT_CLIENT_HELLO);
+    my $last_record = @{$proxy-&gt;{record_list}}[-1];
+    $fatal_alert = 1 if $last_record-&gt;is_fatal_alert(1);
 }
 
 sub inject_duplicate_extension_serverhello
@@ -110,26 +115,43 @@ sub inject_duplicate_extension_serverhello
     my $proxy = shift;
 
     # We're only interested in the initial ServerHello
-    if ($proxy-&gt;flight != 1) {
+    if ($proxy-&gt;flight == 0) {
+        return;
+    } elsif ($proxy-&gt;flight == 1) {
+        inject_duplicate_extension($proxy, TLSProxy::Message::MT_SERVER_HELLO);
         return;
     }
 
-    inject_duplicate_extension($proxy, TLSProxy::Message::MT_SERVER_HELLO);
+    my $last_record = @{$proxy-&gt;{record_list}}[-1];
+    $fatal_alert = 1 if $last_record-&gt;is_fatal_alert(0);
 }
 
 sub inject_unsolicited_extension
 {
     my $proxy = shift;
     my $message;
+    state $sent_unsolisited_extension;
+
+    if ($proxy-&gt;flight == 0) {
+        $sent_unsolisited_extension = 0;
+        return;
+    }
 
     # We're only interested in the initial ServerHello/EncryptedExtensions
     if ($proxy-&gt;flight != 1) {
+        if ($sent_unsolisited_extension) {
+            my $last_record = @{$proxy-&gt;record_list}[-1];
+            $fatal_alert = 1 if $last_record-&gt;is_fatal_alert(0);
+        }
         return;
     }
 
     if ($testtype == UNSOLICITED_SERVER_NAME_TLS13) {
-        $message = ${$proxy-&gt;message_list}[2];
-        die &quot;Expecting EE message &quot;.($message-&gt;mt).&quot;, &quot;.${$proxy-&gt;message_list}[1]-&gt;mt.&quot;, &quot;.${$proxy-&gt;message_list}[3]-&gt;mt if $message-&gt;mt != TLSProxy::Message::MT_ENCRYPTED_EXTENSIONS;
+        return if (!defined($message = ${$proxy-&gt;message_list}[2]));
+        die &quot;Expecting EE message &quot;.($message-&gt;mt).&quot;,&quot;
+                                   .${$proxy-&gt;message_list}[1]-&gt;mt.&quot;, &quot;
+                                   .${$proxy-&gt;message_list}[3]-&gt;mt
+            if $message-&gt;mt != TLSProxy::Message::MT_ENCRYPTED_EXTENSIONS;
     } else {
         $message = ${$proxy-&gt;message_list}[1];
     }
@@ -148,17 +170,19 @@ sub inject_unsolicited_extension
     }
     $message-&gt;set_extension($type, $ext);
     $message-&gt;repack();
+    $sent_unsolisited_extension = 1;
 }
 
 # Test 1-2: Sending a duplicate extension should fail.
 $proxy-&gt;start() or plan skip_all =&gt; &quot;Unable to start up Proxy for tests&quot;;
 plan tests =&gt; 7;
-ok(TLSProxy::Message-&gt;fail(), &quot;Duplicate ClientHello extension&quot;);
+ok($fatal_alert, &quot;Duplicate ClientHello extension&quot;);
 
+$fatal_alert = 0;
 $proxy-&gt;clear();
 $proxy-&gt;filter(\&amp;inject_duplicate_extension_serverhello);
 $proxy-&gt;start();
-ok(TLSProxy::Message-&gt;fail(), &quot;Duplicate ServerHello extension&quot;);
+ok($fatal_alert, &quot;Duplicate ServerHello extension&quot;);
 
 SKIP: {
     skip &quot;TLS &lt;= 1.2 disabled&quot;, 3 if $no_below_tls13;
@@ -170,12 +194,13 @@ SKIP: {
     ok(TLSProxy::Message-&gt;success, &quot;Zero extension length test&quot;);
 
     #Test 4: Inject an unsolicited extension (&lt;= TLSv1.2)
+    $fatal_alert = 0;
     $proxy-&gt;clear();
     $proxy-&gt;filter(\&amp;inject_unsolicited_extension);
     $testtype = UNSOLICITED_SERVER_NAME;
     $proxy-&gt;clientflags(&quot;-no_tls1_3 -noservername&quot;);
     $proxy-&gt;start();
-    ok(TLSProxy::Message-&gt;fail(), &quot;Unsolicited server name extension&quot;);
+    ok($fatal_alert, &quot;Unsolicited server name extension&quot;);
 
     #Test 5: Inject a noncompliant supported_groups extension (&lt;= TLSv1.2)
     $proxy-&gt;clear();
@@ -190,20 +215,22 @@ SKIP: {
     skip &quot;TLS &lt;= 1.2 or CT disabled&quot;, 1
         if $no_below_tls13 || disabled(&quot;ct&quot;);
     #Test 6: Same as above for the SCT extension which has special handling
+    $fatal_alert = 0;
     $proxy-&gt;clear();
     $testtype = UNSOLICITED_SCT;
     $proxy-&gt;clientflags(&quot;-no_tls1_3&quot;);
     $proxy-&gt;start();
-    ok(TLSProxy::Message-&gt;fail(), &quot;Unsolicited sct extension&quot;);
+    ok($fatal_alert, &quot;Unsolicited sct extension&quot;);
 }
 
 SKIP: {
     skip &quot;TLS 1.3 disabled&quot;, 1 if disabled(&quot;tls1_3&quot;);
     #Test 7: Inject an unsolicited extension (TLSv1.3)
+    $fatal_alert = 0;
     $proxy-&gt;clear();
     $proxy-&gt;filter(\&amp;inject_unsolicited_extension);
     $testtype = UNSOLICITED_SERVER_NAME_TLS13;
     $proxy-&gt;clientflags(&quot;-noservername&quot;);
     $proxy-&gt;start();
-    ok(TLSProxy::Message-&gt;fail(), &quot;Unsolicited server name extension (TLSv1.3)&quot;);
+    ok($fatal_alert, &quot;Unsolicited server name extension (TLSv1.3)&quot;);
 }
diff --git a/test/recipes/70-test_sslrecords.t b/test/recipes/70-test_sslrecords.t
index 88cb022..1233028 100644
--- a/test/recipes/70-test_sslrecords.t
+++ b/test/recipes/70-test_sslrecords.t
@@ -7,6 +7,8 @@
 # <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
 
 use strict;
+use feature 'state';
+
 use OpenSSL::Test qw/:DEFAULT cmdstr srctop_file bldtop_dir/;
 use OpenSSL::Test::Utils;
 use TLSProxy::Proxy;
@@ -35,6 +37,7 @@ my $proxy = TLSProxy::Proxy-&gt;new(
 );
 
 my $boundary_test_type;
+my $fatal_alert = 0;    # set by filters at expected fatal alerts
 
 #Test 1: Injecting out of context empty records should fail
 my $content_type = TLSProxy::Record::RT_APPLICATION_DATA;
@@ -42,7 +45,7 @@ my $inject_recs_num = 1;
 $proxy-&gt;serverflags(&quot;-tls1_2&quot;);
 $proxy-&gt;start() or plan skip_all =&gt; &quot;Unable to start up Proxy for tests&quot;;
 plan tests =&gt; 18;
-ok(TLSProxy::Message-&gt;fail(), &quot;Out of context empty records test&quot;);
+ok($fatal_alert, &quot;Out of context empty records test&quot;);
 
 #Test 2: Injecting in context empty records should succeed
 $proxy-&gt;clear();
@@ -52,21 +55,23 @@ $proxy-&gt;start();
 ok(TLSProxy::Message-&gt;success(), &quot;In context empty records test&quot;);
 
 #Test 3: Injecting too many in context empty records should fail
+$fatal_alert = 0;
 $proxy-&gt;clear();
 #We allow 32 consecutive in context empty records
 $inject_recs_num = 33;
 $proxy-&gt;serverflags(&quot;-tls1_2&quot;);
 $proxy-&gt;start();
-ok(TLSProxy::Message-&gt;fail(), &quot;Too many in context empty records test&quot;);
+ok($fatal_alert, &quot;Too many in context empty records test&quot;);
 
 #Test 4: Injecting a fragmented fatal alert should fail. We expect the server to
 #        send back an alert of its own because it cannot handle fragmented
 #        alerts
+$fatal_alert = 0;
 $proxy-&gt;clear();
 $proxy-&gt;filter(\&amp;add_frag_alert_filter);
 $proxy-&gt;serverflags(&quot;-tls1_2&quot;);
 $proxy-&gt;start();
-ok(TLSProxy::Message-&gt;fail(), &quot;Fragmented alert records test&quot;);
+ok($fatal_alert, &quot;Fragmented alert records test&quot;);
 
 #Run some SSLv2 ClientHello tests
 
@@ -122,28 +127,31 @@ ok(TLSProxy::Message-&gt;fail(), &quot;Alert before SSLv2 ClientHello test&quot;);
 #Unrecognised record type tests
 
 #Test 10: Sending an unrecognised record type in TLS1.2 should fail
+$fatal_alert = 0;
 $proxy-&gt;clear();
 $proxy-&gt;serverflags(&quot;-tls1_2&quot;);
 $proxy-&gt;filter(\&amp;add_unknown_record_type);
 $proxy-&gt;start();
-ok(TLSProxy::Message-&gt;fail(), &quot;Unrecognised record type in TLS1.2&quot;);
+ok($fatal_alert, &quot;Unrecognised record type in TLS1.2&quot;);
 
 SKIP: {
     skip &quot;TLSv1.1 disabled&quot;, 1 if disabled(&quot;tls1_1&quot;);
 
     #Test 11: Sending an unrecognised record type in TLS1.1 should fail
+    $fatal_alert = 0;
     $proxy-&gt;clear();
     $proxy-&gt;clientflags(&quot;-tls1_1&quot;);
     $proxy-&gt;start();
-    ok(TLSProxy::Message-&gt;fail(), &quot;Unrecognised record type in TLS1.1&quot;);
+    ok($fatal_alert, &quot;Unrecognised record type in TLS1.1&quot;);
 }
 
 #Test 12: Sending a different record version in TLS1.2 should fail
+$fatal_alert = 0;
 $proxy-&gt;clear();
 $proxy-&gt;clientflags(&quot;-tls1_2&quot;);
 $proxy-&gt;filter(\&amp;change_version);
 $proxy-&gt;start();
-ok(TLSProxy::Message-&gt;fail(), &quot;Changed record version in TLS1.2&quot;);
+ok($fatal_alert, &quot;Changed record version in TLS1.2&quot;);
 
 #TLS1.3 specific tests
 SKIP: {
@@ -156,17 +164,19 @@ SKIP: {
     ok(TLSProxy::Message-&gt;fail(), &quot;Changed record version in TLS1.3&quot;);
 
     #Test 14: Sending an unrecognised record type in TLS1.3 should fail
+    $fatal_alert = 0;
     $proxy-&gt;clear();
     $proxy-&gt;filter(\&amp;add_unknown_record_type);
     $proxy-&gt;start();
-    ok(TLSProxy::Message-&gt;fail(), &quot;Unrecognised record type in TLS1.3&quot;);
+    ok($fatal_alert, &quot;Unrecognised record type in TLS1.3&quot;);
 
     #Test 15: Sending an outer record type other than app data once encrypted
     #should fail
+    $fatal_alert = 0;
     $proxy-&gt;clear();
     $proxy-&gt;filter(\&amp;change_outer_record_type);
     $proxy-&gt;start();
-    ok(TLSProxy::Message-&gt;fail(), &quot;Wrong outer record type in TLS1.3&quot;);
+    ok($fatal_alert, &quot;Wrong outer record type in TLS1.3&quot;);
 
     use constant {
         DATA_AFTER_SERVER_HELLO =&gt; 0,
@@ -176,36 +186,41 @@ SKIP: {
 
     #Test 16: Sending a ServerHello which doesn't end on a record boundary
     #         should fail
+    $fatal_alert = 0;
     $proxy-&gt;clear();
     $boundary_test_type = DATA_AFTER_SERVER_HELLO;
     $proxy-&gt;filter(\&amp;not_on_record_boundary);
     $proxy-&gt;start();
-    ok(TLSProxy::Message-&gt;fail(), &quot;Record not on boundary in TLS1.3 (ServerHello)&quot;);
+    ok($fatal_alert, &quot;Record not on boundary in TLS1.3 (ServerHello)&quot;);
 
     #Test 17: Sending a Finished which doesn't end on a record boundary
     #         should fail
+    $fatal_alert = 0;
     $proxy-&gt;clear();
     $boundary_test_type = DATA_AFTER_FINISHED;
     $proxy-&gt;filter(\&amp;not_on_record_boundary);
     $proxy-&gt;start();
-    ok(TLSProxy::Message-&gt;fail(), &quot;Record not on boundary in TLS1.3 (Finished)&quot;);
+    ok($fatal_alert, &quot;Record not on boundary in TLS1.3 (Finished)&quot;);
 
     #Test 18: Sending a KeyUpdate which doesn't end on a record boundary
     #         should fail
+    $fatal_alert = 0;
     $proxy-&gt;clear();
     $boundary_test_type = DATA_AFTER_KEY_UPDATE;
     $proxy-&gt;filter(\&amp;not_on_record_boundary);
     $proxy-&gt;start();
-    ok(TLSProxy::Message-&gt;fail(), &quot;Record not on boundary in TLS1.3 (KeyUpdate)&quot;);
+    ok($fatal_alert, &quot;Record not on boundary in TLS1.3 (KeyUpdate)&quot;);
  }
 
 
 sub add_empty_recs_filter
 {
     my $proxy = shift;
+    my $records = $proxy-&gt;record_list;
 
     # We're only interested in the initial ClientHello
     if ($proxy-&gt;flight != 0) {
+        $fatal_alert = 1 if @{$records}[-1]-&gt;is_fatal_alert(1) == 10;
         return;
     }
 
@@ -221,18 +236,19 @@ sub add_empty_recs_filter
             &quot;&quot;,
             &quot;&quot;
         );
-
-        push @{$proxy-&gt;record_list}, $record;
+        push @{$records}, $record;
     }
 }
 
 sub add_frag_alert_filter
 {
     my $proxy = shift;
+    my $records = $proxy-&gt;record_list;
     my $byte;
 
     # We're only interested in the initial ClientHello
     if ($proxy-&gt;flight != 0) {
+        $fatal_alert = 1 if @{$records}[-1]-&gt;is_fatal_alert(1) == 10;
         return;
     }
 
@@ -262,7 +278,7 @@ sub add_frag_alert_filter
         $byte,
         $byte
     );
-    push @{$proxy-&gt;record_list}, $record;
+    push @{$records}, $record;
 
     # And finally the description (Unexpected message) in a third record
     $byte = pack('C', TLSProxy::Message::AL_DESC_UNEXPECTED_MESSAGE);
@@ -277,7 +293,7 @@ sub add_frag_alert_filter
         $byte,
         $byte
     );
-    push @{$proxy-&gt;record_list}, $record;
+    push @{$records}, $record;
 }
 
 sub add_sslv2_filter
@@ -430,17 +446,22 @@ sub add_sslv2_filter
 sub add_unknown_record_type
 {
     my $proxy = shift;
+    my $records = $proxy-&gt;record_list;
+    state $added_record;
 
     # We'll change a record after the initial version neg has taken place
-    if ($proxy-&gt;flight != 1) {
+    if ($proxy-&gt;flight == 0) {
+        $added_record = 0;
+        return;
+    } elsif ($proxy-&gt;flight != 1 || $added_record) {
+        $fatal_alert = 1 if @{$records}[-1]-&gt;is_fatal_alert(0) == 10;
         return;
     }
 
-    my $lastrec = ${$proxy-&gt;record_list}[-1];
     my $record = TLSProxy::Record-&gt;new(
         1,
         TLSProxy::Record::RT_UNKNOWN,
-        $lastrec-&gt;version(),
+        @{$records}[-1]-&gt;version(),
         1,
         0,
         1,
@@ -457,64 +478,86 @@ sub add_unknown_record_type
     $i++;
 
     splice @{$proxy-&gt;record_list}, $i, 0, $record;
+    $added_record = 1;
 }
 
 sub change_version
 {
     my $proxy = shift;
+    my $records = $proxy-&gt;record_list;
 
     # We'll change a version after the initial version neg has taken place
     if ($proxy-&gt;flight != 1) {
+        $fatal_alert = 1 if @{$records}[-1]-&gt;is_fatal_alert(0) == 70;
         return;
     }
 
-    (${$proxy-&gt;record_list}[-1])-&gt;version(TLSProxy::Record::VERS_TLS_1_1);
+    if ($#{$records} &gt; 1) {
+        # ... typically in ServerHelloDone
+        @{$records}[-1]-&gt;version(TLSProxy::Record::VERS_TLS_1_1);
+    }
 }
 
 sub change_outer_record_type
 {
     my $proxy = shift;
+    my $records = $proxy-&gt;record_list;
 
     # We'll change a record after the initial version neg has taken place
     if ($proxy-&gt;flight != 1) {
+        $fatal_alert = 1 if @{$records}[-1]-&gt;is_fatal_alert(0) == 10;
         return;
     }
 
-    #Find ServerHello record and change record after that
-    my $i;
-    for ($i = 0; ${$proxy-&gt;record_list}[$i]-&gt;flight() &lt; 1; $i++) {
-        next;
+    # Find CCS record and change record after that
+    my $i = 0;
+    foreach my $record (@{$records}) {
+        last if $record-&gt;content_type == TLSProxy::Record::RT_CCS;
+        $i++;
+    }
+    if (defined(${$records}[++$i])) {
+        ${$records}[$i]-&gt;outer_content_type(TLSProxy::Record::RT_HANDSHAKE);
     }
-    #Skip CCS and ServerHello
-    $i += 2;
-    ${$proxy-&gt;record_list}[$i]-&gt;outer_content_type(TLSProxy::Record::RT_HANDSHAKE);
 }
 
 sub not_on_record_boundary
 {
     my $proxy = shift;
+    my $records = $proxy-&gt;record_list;
     my $data;
 
     #Find server's first flight
     if ($proxy-&gt;flight != 1) {
+        $fatal_alert = 1 if @{$records}[-1]-&gt;is_fatal_alert(0) == 10;
         return;
     }
 
     if ($boundary_test_type == DATA_AFTER_SERVER_HELLO) {
         #Merge the ServerHello and EncryptedExtensions records into one
-        my $i;
-        for ($i = 0; ${$proxy-&gt;record_list}[$i]-&gt;flight() &lt; 1; $i++) {
-            next;
+        my $i = 0;
+        foreach my $record (@{$records}) {
+            if ($record-&gt;content_type == TLSProxy::Record::RT_HANDSHAKE) {
+                $record-&gt;{sent} = 1;    # pretend it's sent already
+                last;
+            }
+            $i++;
         }
-        $data = ${$proxy-&gt;record_list}[$i]-&gt;data();
-        $data .= ${$proxy-&gt;record_list}[$i + 1]-&gt;decrypt_data();
-        ${$proxy-&gt;record_list}[$i]-&gt;data($data);
-        ${$proxy-&gt;record_list}[$i]-&gt;len(length $data);
 
-        #Delete the old EncryptedExtensions record
-        splice @{$proxy-&gt;record_list}, $i + 1, 1;
+        if (defined(${$records}[$i+1])) {
+            $data = ${$records}[$i]-&gt;data();
+            $data .= ${$records}[$i+1]-&gt;decrypt_data();
+            ${$records}[$i+1]-&gt;data($data);
+            ${$records}[$i+1]-&gt;len(length $data);
+
+            #Delete the old ServerHello record
+            splice @{$records}, $i, 1;
+        }
     } elsif ($boundary_test_type == DATA_AFTER_FINISHED) {
-        $data = ${$proxy-&gt;record_list}[-1]-&gt;decrypt_data;
+        return if @{$proxy-&gt;{message_list}}[-1]-&gt;{mt}
+                  != TLSProxy::Message::MT_FINISHED;
+
+        my $last_record = @{$records}[-1];
+        $data = $last_record-&gt;decrypt_data;
 
         #Add a KeyUpdate message onto the end of the Finished record
         my $keyupdate = pack &quot;C5&quot;,
@@ -528,15 +571,18 @@ sub not_on_record_boundary
         $data .= pack(&quot;C&quot;, TLSProxy::Record::RT_HANDSHAKE).(&quot;\0&quot;x16);
 
         #Update the record
-        ${$proxy-&gt;record_list}[-1]-&gt;data($data);
-        ${$proxy-&gt;record_list}[-1]-&gt;len(length $data);
+        $last_record-&gt;data($data);
+        $last_record-&gt;len(length $data);
     } else {
+        return if @{$proxy-&gt;{message_list}}[-1]-&gt;{mt}
+                  != TLSProxy::Message::MT_FINISHED;
+
         #KeyUpdates must end on a record boundary
 
         my $record = TLSProxy::Record-&gt;new(
             1,
             TLSProxy::Record::RT_APPLICATION_DATA,
-            TLSProxy::Record::VERS_TLS_1_0,
+            TLSProxy::Record::VERS_TLS_1_2,
             0,
             0,
             0,
@@ -558,6 +604,6 @@ sub not_on_record_boundary
 
         $record-&gt;data($data);
         $record-&gt;len(length $data);
-        push @{$proxy-&gt;record_list}, $record;
+        push @{$records}, $record;
     }
 }
diff --git a/util/perl/TLSProxy/Message.pm b/util/perl/TLSProxy/Message.pm
index 68179d9..4a60ba0 100644
--- a/util/perl/TLSProxy/Message.pm
+++ b/util/perl/TLSProxy/Message.pm
@@ -267,14 +267,17 @@ sub get_messages
         }
     } elsif ($record-&gt;content_type == TLSProxy::Record::RT_ALERT) {
         my ($alertlev, $alertdesc) = unpack('CC', $record-&gt;decrypt_data);
+        print &quot;  [$alertlev, $alertdesc]\n&quot;;
         #A CloseNotify from the client indicates we have finished successfully
         #(we assume)
         if (!$end &amp;&amp; !$server &amp;&amp; $alertlev == AL_LEVEL_WARN
             &amp;&amp; $alertdesc == AL_DESC_CLOSE_NOTIFY) {
             $success = 1;
         }
-        #All alerts end the test
-        $end = 1;
+        #Fatal or close notify alerts end the test
+        if ($alertlev == AL_LEVEL_FATAL || $alertdesc == AL_DESC_CLOSE_NOTIFY) {
+            $end = 1;
+        }
     }
 
     return @messages;
diff --git a/util/perl/TLSProxy/Proxy.pm b/util/perl/TLSProxy/Proxy.pm
index 9e9764d..de6d2fd 100644
--- a/util/perl/TLSProxy/Proxy.pm
+++ b/util/perl/TLSProxy/Proxy.pm
@@ -239,7 +239,7 @@ sub start
     open(my $savedin, &quot;&lt;&amp;STDIN&quot;);
 
     # Temporarily replace STDIN so that sink process can inherit it...
-    $pid = open(STDIN, &quot;$execcmd |&quot;) or die &quot;Failed to $execcmd: $!\n&quot;;
+    $pid = open(STDIN, &quot;$execcmd 2&gt;&amp;1 |&quot;) or die &quot;Failed to $execcmd: $!\n&quot;;
     $self-&gt;{real_serverpid} = $pid;
 
     # Process the output from s_server until we find the ACCEPT line, which
@@ -369,13 +369,14 @@ sub clientstart
     $fdset = IO::Select-&gt;new($server_sock, $client_sock);
     my @ready;
     my $ctr = 0;
-    my $sessionfile = $self-&gt;{sessionfile};
     local $SIG{PIPE} = &quot;IGNORE&quot;;
+    $self-&gt;{saw_session_ticket} = undef;
     while($fdset-&gt;count &amp;&amp; $ctr &lt; 10) {
-        if (defined($sessionfile)) {
+        if (defined($self-&gt;{sessionfile})) {
             # s_client got -ign_eof and won't be exiting voluntarily, so we
-            # look for data *and* check on session file...
-            last if TLSProxy::Message-&gt;success() &amp;&amp; -s $sessionfile;
+            # look for data *and* session ticket...
+            last if TLSProxy::Message-&gt;success()
+                    &amp;&amp; $self-&gt;{saw_session_ticket};
         }
         if (!(@ready = $fdset-&gt;can_read(1))) {
             $ctr++;
@@ -449,7 +450,7 @@ sub clientstart
         $self-&gt;connect_to_server();
     }
     $pid = $self-&gt;{clientpid};
-    print &quot;Waiting for client process to close: $pid...\n&quot;;
+    print &quot;Waiting for s_client process to close: $pid...\n&quot;;
     waitpid($pid, 0);
 
     return 1;
@@ -496,6 +497,14 @@ sub process_packet
         $self-&gt;filter-&gt;($self);
     }
 
+    #Take a note on NewSessionTicket
+    foreach my $message (reverse @{$self-&gt;{message_list}}) {
+        if ($message-&gt;{mt} == TLSProxy::Message::MT_NEW_SESSION_TICKET) {
+            $self-&gt;{saw_session_ticket} = 1;
+            last;
+        }
+    }
+
     #Reconstruct the packet
     $packet = &quot;&quot;;
     foreach my $record (@{$self-&gt;record_list}) {
diff --git a/util/perl/TLSProxy/Record.pm b/util/perl/TLSProxy/Record.pm
index 49a0084..8ff948b 100644
--- a/util/perl/TLSProxy/Record.pm
+++ b/util/perl/TLSProxy/Record.pm
@@ -67,17 +67,13 @@ sub get_records
 
     my $recnum = 1;
     while (length ($packet) &gt; 0) {
-        print &quot; Record $recnum&quot;;
-        if ($server) {
-            print &quot; (server -&gt; client)\n&quot;;
-        } else {
-            print &quot; (client -&gt; server)\n&quot;;
-        }
+        print &quot; Record $recnum &quot;, $server ? &quot;(server -&gt; client)\n&quot;
+                                          : &quot;(client -&gt; server)\n&quot;;
 
         #Get the record header (unpack can't fail if $packet is too short)
         my ($content_type, $version, $len) = unpack('Cnn', $packet);
 
-        if (length($packet) &lt; TLS_RECORD_HEADER_LENGTH + $len) {
+        if (length($packet) &lt; TLS_RECORD_HEADER_LENGTH + ($len // 0)) {
             print &quot;Partial data : &quot;.length($packet).&quot; bytes\n&quot;;
             $partial = $packet;
             last;
@@ -389,4 +385,16 @@ sub outer_content_type
     }
     return $self-&gt;{outer_content_type};
 }
+sub is_fatal_alert
+{
+    my $self = shift;
+    my $server = shift;
+
+    if (($self-&gt;{flight} &amp; 1) == $server
+        &amp;&amp; $self-&gt;{content_type} == TLSProxy::Record::RT_ALERT) {
+        my ($level, $alert) = unpack('CC', $self-&gt;decrypt_data);
+        return $alert if ($level == 2);
+    }
+    return 0;
+}
 1;
</PRE>





































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019050.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="019053.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19052">[ date ]</a>
              <a href="thread.html#19052">[ thread ]</a>
              <a href="subject.html#19052">[ subject ]</a>
              <a href="author.html#19052">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
