<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2018-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1525769078.512176.17263.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="019275.html">
   <LINK REL="Next"  HREF="019281.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1525769078.512176.17263.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Tue May  8 08:44:38 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="019275.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="019281.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19278">[ date ]</a>
              <a href="thread.html#19278">[ thread ]</a>
              <a href="subject.html#19278">[ subject ]</a>
              <a href="author.html#19278">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  61e96557f9eae0258074c9cec7ad6aa1b9dde1df (commit)
       via  f7506416b1311e65d5c440defdbcfe176f633c50 (commit)
       via  ad962252857aac4350139fdbb6c8e3e6b0bdad7b (commit)
       via  6f6da2fe1710842c37c73ed2b114cf6942221db6 (commit)
       via  f20404fce90919b614b737d07cc75d9e1c019fb8 (commit)
      from  e15e92dbd5248bc8dbd95d2c0af33a6daf8f7255 (commit)


- Log -----------------------------------------------------------------
commit 61e96557f9eae0258074c9cec7ad6aa1b9dde1df
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu May 3 12:06:38 2018 +0100

    Add a DTLS test for dropped records
    
    Drop a record from a handshake and check that we can still complete the
    handshake. Repeat for all records in the handshake.
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6170">https://github.com/openssl/openssl/pull/6170</A>)

commit f7506416b1311e65d5c440defdbcfe176f633c50
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu May 3 16:00:51 2018 +0100

    Keep the DTLS timer running after the end of the handshake if appropriate
    
    During a full handshake the server is the last one to &quot;speak&quot;. The timer
    should continue to run until we know that the client has received our last
    flight (e.g. because we receive some application data).
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6170">https://github.com/openssl/openssl/pull/6170</A>)

commit ad962252857aac4350139fdbb6c8e3e6b0bdad7b
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu May 3 16:00:05 2018 +0100

    Only auto-retry for DTLS if configured to do so
    
    Otherwise we may end up in a hang when using blocking sockets
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6170">https://github.com/openssl/openssl/pull/6170</A>)

commit 6f6da2fe1710842c37c73ed2b114cf6942221db6
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu May 3 15:59:31 2018 +0100

    Fix s_client and s_server so that they correctly handle the DTLS timer
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6170">https://github.com/openssl/openssl/pull/6170</A>)

commit f20404fce90919b614b737d07cc75d9e1c019fb8
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu May 3 12:07:47 2018 +0100

    Don't fail on an out-of-order CCS in DTLS
    
    Fixes #4929
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/6170">https://github.com/openssl/openssl/pull/6170</A>)

-----------------------------------------------------------------------

Summary of changes:
 apps/s_client.c           |   7 +--
 apps/s_server.c           |   7 +--
 ssl/record/rec_layer_d1.c |  25 ++++++++++
 ssl/statem/statem.c       |   4 +-
 ssl/statem/statem_clnt.c  |  14 ++++++
 ssl/statem/statem_lib.c   |  18 +++++++
 ssl/statem/statem_srvr.c  |  14 ++++++
 test/dtlstest.c           | 121 +++++++++++++++++++++++++++++++++++++++++++++-
 test/ssltestlib.c         |  83 ++++++++++++++++++++++++++++---
 test/ssltestlib.h         |   8 +++
 10 files changed, 281 insertions(+), 20 deletions(-)

diff --git a/apps/s_client.c b/apps/s_client.c
index 9d463f6..96f9da6 100644
--- a/apps/s_client.c
+++ b/apps/s_client.c
@@ -2703,8 +2703,7 @@ int s_client_main(int argc, char **argv)
         FD_ZERO(&amp;readfds);
         FD_ZERO(&amp;writefds);
 
-        if ((SSL_version(con) == DTLS1_VERSION) &amp;&amp;
-            DTLSv1_get_timeout(con, &amp;timeout))
+        if (SSL_is_dtls(con) &amp;&amp; DTLSv1_get_timeout(con, &amp;timeout))
             timeoutp = &timeout;
         else
             timeoutp = NULL;
@@ -2815,10 +2814,8 @@ int s_client_main(int argc, char **argv)
             }
         }
 
-        if ((SSL_version(con) == DTLS1_VERSION)
-            &amp;&amp; DTLSv1_handle_timeout(con) &gt; 0) {
+        if (SSL_is_dtls(con) &amp;&amp; DTLSv1_handle_timeout(con) &gt; 0)
             BIO_printf(bio_err, &quot;TIMEOUT occurred\n&quot;);
-        }
 
         if (!ssl_pending &amp;&amp; FD_ISSET(SSL_get_fd(con), &amp;writefds)) {
             k = SSL_write(con, &amp;(cbuf[cbuf_off]), (unsigned int)cbuf_len);
diff --git a/apps/s_server.c b/apps/s_server.c
index ef39a4f..b0e9659 100644
--- a/apps/s_server.c
+++ b/apps/s_server.c
@@ -2398,18 +2398,15 @@ static int sv_body(int s, int stype, int prot, unsigned char *context)
             if ((i &lt; 0) || (!i &amp;&amp; !read_from_terminal))
                 continue;
 #else
-            if ((SSL_version(con) == DTLS1_VERSION) &amp;&amp;
-                DTLSv1_get_timeout(con, &amp;timeout))
+            if (SSL_is_dtls(con) &amp;&amp; DTLSv1_get_timeout(con, &amp;timeout))
                 timeoutp = &timeout;
             else
                 timeoutp = NULL;
 
             i = select(width, (void *)&amp;readfds, NULL, NULL, timeoutp);
 
-            if ((SSL_version(con) == DTLS1_VERSION)
-                &amp;&amp; DTLSv1_handle_timeout(con) &gt; 0) {
+            if ((SSL_is_dtls(con)) &amp;&amp; DTLSv1_handle_timeout(con) &gt; 0)
                 BIO_printf(bio_err, &quot;TIMEOUT occurred\n&quot;);
-            }
 
             if (i &lt;= 0)
                 continue;
diff --git a/ssl/record/rec_layer_d1.c b/ssl/record/rec_layer_d1.c
index 97943d4..37a2eb1 100644
--- a/ssl/record/rec_layer_d1.c
+++ b/ssl/record/rec_layer_d1.c
@@ -444,6 +444,19 @@ int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
             &amp;&amp; SSL3_RECORD_get_length(rr) != 0)
         s-&gt;rlayer.alert_count = 0;
 
+    if (SSL3_RECORD_get_type(rr) != SSL3_RT_HANDSHAKE
+            &amp;&amp; SSL3_RECORD_get_type(rr) != SSL3_RT_CHANGE_CIPHER_SPEC
+            &amp;&amp; !SSL_in_init(s)
+            &amp;&amp; (s-&gt;d1-&gt;next_timeout.tv_sec != 0
+                || s-&gt;d1-&gt;next_timeout.tv_usec != 0)) {
+        /*
+         * The timer is still running but we've received something that isn't
+         * handshake data - so the peer must have finished processing our
+         * last handshake flight. Stop the timer.
+         */
+        dtls1_stop_timer(s);
+    }
+
     /* we now have a packet which can be read and processed */
 
     if (s-&gt;s3-&gt;change_cipher_spec /* set when we receive ChangeCipherSpec,
@@ -664,6 +677,18 @@ int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
                     return -1;
             }
             SSL3_RECORD_set_length(rr, 0);
+            if (!(s-&gt;mode &amp; SSL_MODE_AUTO_RETRY)) {
+                if (SSL3_BUFFER_get_left(&amp;s-&gt;rlayer.rbuf) == 0) {
+                    /* no read-ahead left? */
+                    BIO *bio;
+
+                    s-&gt;rwstate = SSL_READING;
+                    bio = SSL_get_rbio(s);
+                    BIO_clear_retry_flags(bio);
+                    BIO_set_retry_read(bio);
+                    return -1;
+                }
+            }
             goto start;
         }
 
diff --git a/ssl/statem/statem.c b/ssl/statem/statem.c
index 1f221e7..e836769 100644
--- a/ssl/statem/statem.c
+++ b/ssl/statem/statem.c
@@ -589,10 +589,8 @@ static SUB_STATE_RETURN read_state_machine(SSL *s)
              * Validate that we are allowed to move to the new state and move
              * to that state if so
              */
-            if (!transition(s, mt)) {
-                check_fatal(s, SSL_F_READ_STATE_MACHINE);
+            if (!transition(s, mt))
                 return SUB_STATE_ERROR;
-            }
 
             if (s-&gt;s3-&gt;tmp.message_size &gt; max_message_size(s)) {
                 SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_READ_STATE_MACHINE,
diff --git a/ssl/statem/statem_clnt.c b/ssl/statem/statem_clnt.c
index 91b986f..60e987a 100644
--- a/ssl/statem/statem_clnt.c
+++ b/ssl/statem/statem_clnt.c
@@ -375,6 +375,20 @@ int ossl_statem_client_read_transition(SSL *s, int mt)
 
  err:
     /* No valid transition found */
+    if (SSL_IS_DTLS(s) &amp;&amp; mt == SSL3_MT_CHANGE_CIPHER_SPEC) {
+        BIO *rbio;
+
+        /*
+         * CCS messages don't have a message sequence number so this is probably
+         * because of an out-of-order CCS. We'll just drop it.
+         */
+        s-&gt;init_num = 0;
+        s-&gt;rwstate = SSL_READING;
+        rbio = SSL_get_rbio(s);
+        BIO_clear_retry_flags(rbio);
+        BIO_set_retry_read(rbio);
+        return 0;
+    }
     SSLfatal(s, SSL3_AD_UNEXPECTED_MESSAGE,
              SSL_F_OSSL_STATEM_CLIENT_READ_TRANSITION,
              SSL_R_UNEXPECTED_MESSAGE);
diff --git a/ssl/statem/statem_lib.c b/ssl/statem/statem_lib.c
index 49b4443..74ad6e8 100644
--- a/ssl/statem/statem_lib.c
+++ b/ssl/statem/statem_lib.c
@@ -1057,6 +1057,15 @@ WORK_STATE tls_finish_handshake(SSL *s, WORK_STATE wst, int clearbufs, int stop)
             CRYPTO_atomic_add(&amp;s-&gt;ctx-&gt;stats.sess_accept_good, 1, &amp;discard,
                               s-&gt;ctx-&gt;lock);
             s-&gt;handshake_func = ossl_statem_accept;
+
+            if (SSL_IS_DTLS(s) &amp;&amp; !s-&gt;hit) {
+                /*
+                 * We are finishing after the client. We start the timer going
+                 * in case there are any retransmits of our final flight
+                 * required.
+                 */
+                dtls1_start_timer(s);
+            }
         } else {
             /*
              * In TLSv1.3 we update the cache as part of processing the
@@ -1071,6 +1080,15 @@ WORK_STATE tls_finish_handshake(SSL *s, WORK_STATE wst, int clearbufs, int stop)
             s-&gt;handshake_func = ossl_statem_connect;
             CRYPTO_atomic_add(&amp;s-&gt;session_ctx-&gt;stats.sess_connect_good, 1,
                               &amp;discard, s-&gt;session_ctx-&gt;lock);
+
+            if (SSL_IS_DTLS(s) &amp;&amp; s-&gt;hit) {
+                /*
+                 * We are finishing after the server. We start the timer going
+                 * in case there are any retransmits of our final flight
+                 * required.
+                 */
+                dtls1_start_timer(s);
+            }
         }
 
         if (SSL_IS_DTLS(s)) {
diff --git a/ssl/statem/statem_srvr.c b/ssl/statem/statem_srvr.c
index aa38fad..018daaa 100644
--- a/ssl/statem/statem_srvr.c
+++ b/ssl/statem/statem_srvr.c
@@ -277,6 +277,20 @@ int ossl_statem_server_read_transition(SSL *s, int mt)
 
  err:
     /* No valid transition found */
+    if (SSL_IS_DTLS(s) &amp;&amp; mt == SSL3_MT_CHANGE_CIPHER_SPEC) {
+        BIO *rbio;
+
+        /*
+         * CCS messages don't have a message sequence number so this is probably
+         * because of an out-of-order CCS. We'll just drop it.
+         */
+        s-&gt;init_num = 0;
+        s-&gt;rwstate = SSL_READING;
+        rbio = SSL_get_rbio(s);
+        BIO_clear_retry_flags(rbio);
+        BIO_set_retry_read(rbio);
+        return 0;
+    }
     SSLfatal(s, SSL3_AD_UNEXPECTED_MESSAGE,
              SSL_F_OSSL_STATEM_SERVER_READ_TRANSITION,
              SSL_R_UNEXPECTED_MESSAGE);
diff --git a/test/dtlstest.c b/test/dtlstest.c
index 16d4e0f..859ec6b 100644
--- a/test/dtlstest.c
+++ b/test/dtlstest.c
@@ -46,7 +46,7 @@ static unsigned int timer_cb(SSL *s, unsigned int timer_us)
     ++timer_cb_count;
 
     if (timer_us == 0)
-        return 1000000;
+        return 50000;
     else
         return 2 * timer_us;
 }
@@ -114,6 +114,123 @@ static int test_dtls_unprocessed(int testidx)
     return testresult;
 }
 
+#define CLI_TO_SRV_EPOCH_0_RECS 3
+#define CLI_TO_SRV_EPOCH_1_RECS 1
+#define SRV_TO_CLI_EPOCH_0_RECS 12
+#define SRV_TO_CLI_EPOCH_1_RECS 1
+#define TOTAL_FULL_HAND_RECORDS \
+            (CLI_TO_SRV_EPOCH_0_RECS + CLI_TO_SRV_EPOCH_1_RECS + \
+             SRV_TO_CLI_EPOCH_0_RECS + SRV_TO_CLI_EPOCH_1_RECS)
+
+#define CLI_TO_SRV_RESUME_EPOCH_0_RECS 3
+#define CLI_TO_SRV_RESUME_EPOCH_1_RECS 1
+#define SRV_TO_CLI_RESUME_EPOCH_0_RECS 2
+#define SRV_TO_CLI_RESUME_EPOCH_1_RECS 1
+#define TOTAL_RESUME_HAND_RECORDS \
+            (CLI_TO_SRV_RESUME_EPOCH_0_RECS + CLI_TO_SRV_RESUME_EPOCH_1_RECS + \
+             SRV_TO_CLI_RESUME_EPOCH_0_RECS + SRV_TO_CLI_RESUME_EPOCH_1_RECS)
+
+#define TOTAL_RECORDS (TOTAL_FULL_HAND_RECORDS + TOTAL_RESUME_HAND_RECORDS)
+
+static int test_dtls_drop_records(int idx)
+{
+    SSL_CTX *sctx = NULL, *cctx = NULL;
+    SSL *serverssl = NULL, *clientssl = NULL;
+    BIO *c_to_s_fbio, *mempackbio;
+    int testresult = 0;
+    int epoch = 0;
+    SSL_SESSION *sess = NULL;
+    int cli_to_srv_epoch0, cli_to_srv_epoch1, srv_to_cli_epoch0;
+
+    if (!TEST_true(create_ssl_ctx_pair(DTLS_server_method(),
+                                       DTLS_client_method(),
+                                       DTLS1_VERSION, DTLS_MAX_VERSION,
+                                       &amp;sctx, &amp;cctx, cert, privkey)))
+        return 0;
+
+    if (idx &gt;= TOTAL_FULL_HAND_RECORDS) {
+        /* We're going to do a resumption handshake. Get a session first. */
+        if (!TEST_true(create_ssl_objects(sctx, cctx, &amp;serverssl, &amp;clientssl,
+                                          NULL, NULL))
+                || !TEST_true(create_ssl_connection(serverssl, clientssl,
+                              SSL_ERROR_NONE))
+                || !TEST_ptr(sess = SSL_get1_session(clientssl)))
+            goto end;
+
+        SSL_shutdown(clientssl);
+        SSL_shutdown(serverssl);
+        SSL_free(serverssl);
+        SSL_free(clientssl);
+        serverssl = clientssl = NULL;
+
+        cli_to_srv_epoch0 = CLI_TO_SRV_RESUME_EPOCH_0_RECS;
+        cli_to_srv_epoch1 = CLI_TO_SRV_RESUME_EPOCH_1_RECS;
+        srv_to_cli_epoch0 = SRV_TO_CLI_RESUME_EPOCH_0_RECS;
+        idx -= TOTAL_FULL_HAND_RECORDS;
+    } else {
+        cli_to_srv_epoch0 = CLI_TO_SRV_EPOCH_0_RECS;
+        cli_to_srv_epoch1 = CLI_TO_SRV_EPOCH_1_RECS;
+        srv_to_cli_epoch0 = SRV_TO_CLI_EPOCH_0_RECS;
+    }
+
+    c_to_s_fbio = BIO_new(bio_f_tls_dump_filter());
+    if (!TEST_ptr(c_to_s_fbio))
+        goto end;
+
+    /* BIO is freed by create_ssl_connection on error */
+    if (!TEST_true(create_ssl_objects(sctx, cctx, &amp;serverssl, &amp;clientssl,
+                                      NULL, c_to_s_fbio)))
+        goto end;
+
+    if (sess != NULL) {
+        if (!TEST_true(SSL_set_session(clientssl, sess)))
+            goto end;
+    }
+
+    DTLS_set_timer_cb(clientssl, timer_cb);
+    DTLS_set_timer_cb(serverssl, timer_cb);
+
+    /* Work out which record to drop based on the test number */
+    if (idx &gt;= cli_to_srv_epoch0 + cli_to_srv_epoch1) {
+        mempackbio = SSL_get_wbio(serverssl);
+        idx -= cli_to_srv_epoch0 + cli_to_srv_epoch1;
+        if (idx &gt;= srv_to_cli_epoch0) {
+            epoch = 1;
+            idx -= srv_to_cli_epoch0;
+        }
+    } else {
+        mempackbio = SSL_get_wbio(clientssl);
+        if (idx &gt;= cli_to_srv_epoch0) {
+            epoch = 1;
+            idx -= cli_to_srv_epoch0;
+        }
+         mempackbio = BIO_next(mempackbio);
+    }
+    BIO_ctrl(mempackbio, MEMPACKET_CTRL_SET_DROP_EPOCH, epoch, NULL);
+    BIO_ctrl(mempackbio, MEMPACKET_CTRL_SET_DROP_REC, idx, NULL);
+
+    if (!TEST_true(create_ssl_connection(serverssl, clientssl, SSL_ERROR_NONE)))
+        goto end;
+
+    if (sess != NULL &amp;&amp; !TEST_true(SSL_session_reused(clientssl)))
+        goto end;
+
+    /* If the test did what we planned then it should have dropped a record */
+    if (!TEST_int_eq((int)BIO_ctrl(mempackbio, MEMPACKET_CTRL_GET_DROP_REC, 0,
+                                   NULL), -1))
+        goto end;
+
+    testresult = 1;
+ end:
+    SSL_SESSION_free(sess);
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+
+    return testresult;
+}
+
 int setup_tests(void)
 {
     if (!TEST_ptr(cert = test_get_argument(0))
@@ -121,6 +238,8 @@ int setup_tests(void)
         return 0;
 
     ADD_ALL_TESTS(test_dtls_unprocessed, NUM_TESTS);
+    ADD_ALL_TESTS(test_dtls_drop_records, TOTAL_RECORDS);
+
     return 1;
 }
 
diff --git a/test/ssltestlib.c b/test/ssltestlib.c
index 959e329..041ae26 100644
--- a/test/ssltestlib.c
+++ b/test/ssltestlib.c
@@ -12,6 +12,34 @@
 #include &quot;internal/nelem.h&quot;
 #include &quot;ssltestlib.h&quot;
 #include &quot;testutil.h&quot;
+#include &quot;e_os.h&quot;
+
+#ifdef OPENSSL_SYS_UNIX
+# include &lt;unistd.h&gt;
+
+static ossl_inline void ossl_sleep(unsigned int millis) {
+    usleep(millis * 1000);
+}
+#elif defined(_WIN32)
+# include &lt;windows.h&gt;
+
+static ossl_inline void ossl_sleep(unsigned int millis) {
+    Sleep(millis);
+}
+#else
+/* Fallback to a busy wait */
+static ossl_inline void ossl_sleep(unsigned int millis) {
+    struct timeval start, now;
+    unsigned int elapsedms;
+
+    gettimeofday(&amp;start, NULL);
+    do {
+        gettimeofday(&amp;now, NULL);
+        elapsedms = (((now.tv_sec - start.tv_sec) * 1000000)
+                     + now.tv_usec - start.tv_usec) / 1000;
+    } while (elapsedms &lt; millis);
+}
+#endif
 
 static int tls_dump_new(BIO *bi);
 static int tls_dump_free(BIO *a);
@@ -252,7 +280,10 @@ typedef struct mempacket_test_ctx_st {
     unsigned int currrec;
     unsigned int currpkt;
     unsigned int lastpkt;
+    unsigned int injected;
     unsigned int noinject;
+    unsigned int dropepoch;
+    int droprec;
 } MEMPACKET_TEST_CTX;
 
 static int mempacket_test_new(BIO *bi);
@@ -295,6 +326,8 @@ static int mempacket_test_new(BIO *bio)
         OPENSSL_free(ctx);
         return 0;
     }
+    ctx-&gt;dropepoch = 0;
+    ctx-&gt;droprec = -1;
     BIO_set_init(bio, 1);
     BIO_set_data(bio, ctx);
     return 1;
@@ -312,8 +345,8 @@ static int mempacket_test_free(BIO *bio)
 }
 
 /* Record Header values */
-#define EPOCH_HI        4
-#define EPOCH_LO        5
+#define EPOCH_HI        3
+#define EPOCH_LO        4
 #define RECORD_SEQUENCE 10
 #define RECORD_LEN_HI   11
 #define RECORD_LEN_LO   12
@@ -341,15 +374,15 @@ static int mempacket_test_read(BIO *bio, char *out, int outl)
     if (outl &gt; thispkt-&gt;len)
         outl = thispkt-&gt;len;
 
-    if (thispkt-&gt;type != INJECT_PACKET_IGNORE_REC_SEQ) {
+    if (thispkt-&gt;type != INJECT_PACKET_IGNORE_REC_SEQ
+            &amp;&amp; (ctx-&gt;injected || ctx-&gt;droprec &gt;= 0)) {
         /*
          * Overwrite the record sequence number. We strictly number them in
          * the order received. Since we are actually a reliable transport
          * we know that there won't be any re-ordering. We overwrite to deal
          * with any packets that have been injected
          */
-        for (rem = thispkt-&gt;len, rec = thispkt-&gt;data
-                ; rem &gt; 0; rec += len, rem -= len) {
+        for (rem = thispkt-&gt;len, rec = thispkt-&gt;data; rem &gt; 0; rem -= len) {
             if (rem &lt; DTLS1_RT_HEADER_LENGTH)
                 return -1;
             epoch = (rec[EPOCH_HI] &lt;&lt; 8) | rec[EPOCH_LO];
@@ -364,10 +397,23 @@ static int mempacket_test_read(BIO *bio, char *out, int outl)
                 seq &gt;&gt;= 8;
                 offset++;
             } while (seq &gt; 0);
-            ctx-&gt;currrec++;
 
             len = ((rec[RECORD_LEN_HI] &lt;&lt; 8) | rec[RECORD_LEN_LO])
                   + DTLS1_RT_HEADER_LENGTH;
+            if (rem &lt; (int)len)
+                return -1;
+            if (ctx-&gt;droprec == (int)ctx-&gt;currrec &amp;&amp; ctx-&gt;dropepoch == epoch) {
+                if (rem &gt; (int)len)
+                    memmove(rec, rec + len, rem - len);
+                outl -= len;
+                ctx-&gt;droprec = -1;
+                if (outl == 0)
+                    BIO_set_retry_read(bio);
+            } else {
+                rec += len;
+            }
+
+            ctx-&gt;currrec++;
         }
     }
 
@@ -390,6 +436,7 @@ int mempacket_test_inject(BIO *bio, const char *in, int inl, int pktnum,
     if (pktnum &gt;= 0) {
         if (ctx-&gt;noinject)
             return -1;
+        ctx-&gt;injected  = 1;
     } else {
         ctx-&gt;noinject = 1;
     }
@@ -488,6 +535,15 @@ static long mempacket_test_ctrl(BIO *bio, int cmd, long num, void *ptr)
     case BIO_CTRL_FLUSH:
         ret = 1;
         break;
+    case MEMPACKET_CTRL_SET_DROP_EPOCH:
+        ctx-&gt;dropepoch = (unsigned int)num;
+        break;
+    case MEMPACKET_CTRL_SET_DROP_REC:
+        ctx-&gt;droprec = (int)num;
+        break;
+    case MEMPACKET_CTRL_GET_DROP_REC:
+        ret = ctx-&gt;droprec;
+        break;
     case BIO_CTRL_RESET:
     case BIO_CTRL_DUP:
     case BIO_CTRL_PUSH:
@@ -627,6 +683,7 @@ int create_ssl_connection(SSL *serverssl, SSL *clientssl, int want)
     int clienterr = 0, servererr = 0;
     unsigned char buf;
     size_t readbytes;
+    int isdtls = SSL_is_dtls(serverssl);
 
     do {
         err = SSL_ERROR_WANT_WRITE;
@@ -658,10 +715,24 @@ int create_ssl_connection(SSL *serverssl, SSL *clientssl, int want)
             return 0;
         if (clienterr &amp;&amp; servererr)
             return 0;
+        if (isdtls) {
+            if (rets &gt; 0 &amp;&amp; retc &lt;= 0)
+                DTLSv1_handle_timeout(serverssl);
+            if (retc &gt; 0 &amp;&amp; rets &lt;= 0)
+                DTLSv1_handle_timeout(clientssl);
+        }
         if (++abortctr == MAXLOOPS) {
             TEST_info(&quot;No progress made&quot;);
             return 0;
         }
+        if (isdtls &amp;&amp; abortctr &lt;= 50 &amp;&amp; (abortctr % 10) == 0) {
+            /*
+             * It looks like we're just spinning. Pause for a short period to
+             * give the DTLS timer a chance to do something. We only do this for
+             * the first few times to prevent hangs.
+             */
+            ossl_sleep(50);
+        }
     } while (retc &lt;=0 || rets &lt;= 0);
 
     /*
diff --git a/test/ssltestlib.h b/test/ssltestlib.h
index 353699d..c96dff5 100644
--- a/test/ssltestlib.h
+++ b/test/ssltestlib.h
@@ -32,6 +32,14 @@ void bio_s_mempacket_test_free(void);
 #define INJECT_PACKET                   1
 #define INJECT_PACKET_IGNORE_REC_SEQ    2
 
+/*
+ * Mempacket BIO ctrls. We make them large enough to not clash with standard BIO
+ * ctrl codes.
+ */
+#define MEMPACKET_CTRL_SET_DROP_EPOCH  (1 &lt;&lt; 15)
+#define MEMPACKET_CTRL_SET_DROP_REC    (2 &lt;&lt; 15)
+#define MEMPACKET_CTRL_GET_DROP_REC    (3 &lt;&lt; 15)
+
 int mempacket_test_inject(BIO *bio, const char *in, int inl, int pktnum,
                           int type);
 
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="019275.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="019281.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#19278">[ date ]</a>
              <a href="thread.html#19278">[ thread ]</a>
              <a href="subject.html#19278">[ subject ]</a>
              <a href="author.html#19278">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
