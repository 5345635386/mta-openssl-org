<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1589391900.114424.30114.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="028745.html">
   <LINK REL="Next"  HREF="028749.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>dev at ddvo.net</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1589391900.114424.30114.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">dev at ddvo.net
       </A><BR>
    <I>Wed May 13 17:45:00 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="028745.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="028749.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28746">[ date ]</a>
              <a href="thread.html#28746">[ thread ]</a>
              <a href="subject.html#28746">[ subject ]</a>
              <a href="author.html#28746">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  63f1883dca7a42949e8b9db5b035c17fc160f998 (commit)
       via  143be4748e49ff0181964affcbf422a895c48e85 (commit)
       via  6b326fc396d203d84f5461a0025495dfef88e1e8 (commit)
       via  8d9a4d833f12b0669f053a504268d13a46c079ad (commit)
       via  3c38fa4b797848a76b83f91e423de470adbb3b61 (commit)
       via  d3d0784e4147d2253ed4a13b7eafea4eeeaf38fb (commit)
       via  05f920db3982b867c3d640e7d424a1cb5608bb85 (commit)
      from  f55838f34dd5c65420662f7eacf6c6ffd7f261a2 (commit)


- Log -----------------------------------------------------------------
commit 63f1883dca7a42949e8b9db5b035c17fc160f998
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Fri May 8 13:30:44 2020 +0200

    Rename OSSL_CMP_CTX_set1_clCert() to OSSL_CMP_CTX_set1_cert()
    
    Also update documentation and example code in openssl-cmp.pod.in
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    Reviewed-by: David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">david.von.oheimb at siemens.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11470">https://github.com/openssl/openssl/pull/11470</A>)

commit 143be4748e49ff0181964affcbf422a895c48e85
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Wed Apr 29 18:06:43 2020 +0200

    Add -reqin_new_tid option to apps/cmp.c and OSSL_CMP_MSG_update_transactionID()
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    Reviewed-by: David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">david.von.oheimb at siemens.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11470">https://github.com/openssl/openssl/pull/11470</A>)

commit 6b326fc396d203d84f5461a0025495dfef88e1e8
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Thu Apr 30 19:38:58 2020 +0200

    Improve CMP documentation regarding use of untrusted certs
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    Reviewed-by: David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">david.von.oheimb at siemens.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11470">https://github.com/openssl/openssl/pull/11470</A>)

commit 8d9a4d833f12b0669f053a504268d13a46c079ad
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Fri Apr 3 10:43:58 2020 +0200

    Chunk 11 of CMP contribution to OpenSSL: CMP command-line interface
    
    Certificate Management Protocol (CMP, RFC 4210) extension to OpenSSL
    Also includes CRMF (RFC 4211) and HTTP transfer (RFC 6712).
    Adds the CMP and CRMF API to libcrypto and the &quot;cmp&quot; app to the CLI.
    Adds extensive documentation and tests.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    Reviewed-by: David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">david.von.oheimb at siemens.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11470">https://github.com/openssl/openssl/pull/11470</A>)

commit 3c38fa4b797848a76b83f91e423de470adbb3b61
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Tue May 12 10:14:00 2020 +0200

    Preliminary fix of memory leak in try_decode_PKCS12() - full fix is in #11733
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    Reviewed-by: David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">david.von.oheimb at siemens.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11470">https://github.com/openssl/openssl/pull/11470</A>)

commit d3d0784e4147d2253ed4a13b7eafea4eeeaf38fb
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Tue Apr 28 11:00:07 2020 +0200

    Improve description of algorithm NIDs in doc/man3/OSSL_CMP_CTX_new.pod
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    Reviewed-by: David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">david.von.oheimb at siemens.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11470">https://github.com/openssl/openssl/pull/11470</A>)

commit 05f920db3982b867c3d640e7d424a1cb5608bb85
Author: Dr. David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">David.von.Oheimb at siemens.com</A>&gt;
Date:   Fri Apr 3 19:54:45 2020 +0200

    Reflect constifications of 62dcd2aa in doc/man3/OSSL_CRMF_MSG_get0_tmpl.pod
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    Reviewed-by: David von Oheimb &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">david.von.oheimb at siemens.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/11470">https://github.com/openssl/openssl/pull/11470</A>)

-----------------------------------------------------------------------

Summary of changes:
 CHANGES.md                                         |    6 +-
 NEWS.md                                            |    2 +-
 apps/build.info                                    |    2 +-
 apps/cmp.c                                         | 3332 ++++++++++++++++++++
 apps/openssl-vms.cnf                               |   56 +
 apps/openssl.cnf                                   |   56 +
 crypto/cmp/cmp_asn.c                               |    9 +-
 crypto/cmp/cmp_client.c                            |    5 +-
 crypto/cmp/cmp_ctx.c                               |    6 +-
 crypto/cmp/cmp_hdr.c                               |   46 +-
 crypto/cmp/cmp_local.h                             |   13 +-
 crypto/cmp/cmp_msg.c                               |   20 +-
 crypto/cmp/cmp_protect.c                           |  132 +-
 crypto/cmp/cmp_server.c                            |    3 +-
 crypto/store/loader_file.c                         |    1 +
 doc/internal/man3/ossl_cmp_msg_protect.pod         |    4 +-
 doc/man1/build.info                                |    3 +
 doc/man1/openssl-cmp.pod.in                        | 1165 +++++++
 doc/man3/OSSL_CMP_CTX_new.pod                      |  122 +-
 doc/man3/OSSL_CMP_MSG_get0_header.pod              |   15 +-
 doc/man3/OSSL_CRMF_MSG_get0_tmpl.pod               |   12 +-
 include/openssl/cmp.h                              |   19 +-
 test/cmp_client_test.c                             |    2 +-
 test/cmp_ctx_test.c                                |    4 +-
 test/cmp_msg_test.c                                |    2 +-
 test/cmp_protect_test.c                            |    2 +-
 .../65-test_cmp_vfy_data =&gt; }/insta.priv.pem       |    0
 .../65-test_cmp_vfy_data =&gt; }/insta_ca.cert.pem    |    0
 util/libcrypto.num                                 |    3 +-
 29 files changed, 4844 insertions(+), 198 deletions(-)
 create mode 100644 apps/cmp.c
 create mode 100644 doc/man1/openssl-cmp.pod.in
 copy test/{recipes/65-test_cmp_vfy_data =&gt; }/insta.priv.pem (100%)
 copy test/{recipes/65-test_cmp_vfy_data =&gt; }/insta_ca.cert.pem (100%)

diff --git a/CHANGES.md b/CHANGES.md
index 51ed264cb0..6ee0b1efde 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -93,10 +93,10 @@ OpenSSL 3.0
    *Richard Levitte*
 
  * Added an implementation of CMP and CRMF (RFC 4210, RFC 4211 RFC 6712).
-   This adds crypto/cmp/, crpyto/crmf/, and test/cmp_*.
-   See L&lt;OSSL_CMP_exec_IR_ses(3)&gt; as starting point.
+   This adds crypto/cmp/, crpyto/crmf/, apps/cmp.c, and test/cmp_*.
+   See L&lt;openssl-cmp(1)&gt; and L&lt;OSSL_CMP_exec_IR_ses(3)&gt; as starting points.
 
-   *David von Oheimb*
+   *David von Oheimb, Martin Peylo*
 
  * Generalized the HTTP client code from crypto/ocsp/ into crpyto/http/.
    The legacy OCSP-focused and only partly documented API is retained.
diff --git a/NEWS.md b/NEWS.md
index ec5e754e0b..c09e9599a4 100644
--- a/NEWS.md
+++ b/NEWS.md
@@ -34,7 +34,7 @@ OpenSSL 3.0
     disabled; the project uses address sanitize/leak-detect instead.
   * Added a Certificate Management Protocol (CMP, RFC 4210) implementation
     also covering CRMF (RFC 4211) and HTTP transfer (RFC 6712).
-    It is part of the crypto lib, while a 'cmp' app using it is in preparation.
+    It is part of the crypto lib and adds a 'cmp' app with a demo configuration.
     All widely used CMP features are supported for both clients and servers.
   * Added a proper HTTP(S) client to libcrypto supporting GET and POST,
     redirection, plain and ASN.1-encoded contents, proxies, and timeouts.
diff --git a/apps/build.info b/apps/build.info
index f2c62c94dc..d51e825bc5 100644
--- a/apps/build.info
+++ b/apps/build.info
@@ -52,7 +52,7 @@ IF[{- !$disabled{'deprecated-3.0'} -}]
   ENDIF
 ENDIF
 IF[{- !$disabled{'cmp'} -}]
-  $OPENSSLSRC=$OPENSSLSRC cmp_mock_srv.c
+  $OPENSSLSRC=$OPENSSLSRC cmp.c cmp_mock_srv.c
 ENDIF
 
 IF[{- !$disabled{apps} -}]
diff --git a/apps/cmp.c b/apps/cmp.c
new file mode 100644
index 0000000000..9e40534995
--- /dev/null
+++ b/apps/cmp.c
@@ -0,0 +1,3332 @@
+/*
+ * Copyright 2007-2019 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright Nokia 2007-2019
+ * Copyright Siemens AG 2015-2019
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;string.h&gt;
+#include &lt;ctype.h&gt;
+
+#include &quot;apps.h&quot;
+#include &quot;http_server.h&quot;
+#include &quot;s_apps.h&quot;
+#include &quot;progs.h&quot;
+
+#include &quot;cmp_mock_srv.h&quot;
+
+/* tweaks needed due to missing unistd.h on Windows */
+#ifdef _WIN32
+# define access _access
+#endif
+#ifndef F_OK
+# define F_OK 0
+#endif
+
+#include &lt;openssl/ui.h&gt;
+#include &lt;openssl/pkcs12.h&gt;
+#include &lt;openssl/ssl.h&gt;
+
+/* explicit #includes not strictly needed since implied by the above: */
+#include &lt;stdlib.h&gt;
+#include &lt;openssl/cmp.h&gt;
+#include &lt;openssl/cmp_util.h&gt;
+#include &lt;openssl/crmf.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &lt;openssl/err.h&gt;
+#include &lt;openssl/store.h&gt;
+#include &lt;openssl/objects.h&gt;
+#include &lt;openssl/x509.h&gt;
+
+DEFINE_STACK_OF(X509)
+DEFINE_STACK_OF(X509_EXTENSION)
+DEFINE_STACK_OF(OSSL_CMP_ITAV)
+
+/* start TODO remove when PR #11755 is merged */
+static char *get_passwd(const char *pass, const char *desc)
+{
+    char *result = NULL;
+
+    app_passwd(pass, NULL, &amp;result, NULL);
+    return result;
+}
+
+static void cleanse(char *str)
+{
+    if (str != NULL)
+        OPENSSL_cleanse(str, strlen(str));
+}
+
+static void clear_free(char *str)
+{
+    if (str != NULL)
+        OPENSSL_clear_free(str, strlen(str));
+}
+
+static int load_key_cert_crl(const char *uri, int maybe_stdin,
+                             const char *pass, const char *desc,
+                             EVP_PKEY **ppkey, X509 **pcert, X509_CRL **pcrl)
+{
+    PW_CB_DATA uidata;
+    OSSL_STORE_CTX *ctx = NULL;
+    int ret = 0;
+
+    if (ppkey != NULL)
+        *ppkey = NULL;
+    if (pcert != NULL)
+        *pcert = NULL;
+    if (pcrl != NULL)
+        *pcrl = NULL;
+
+    uidata.password = pass;
+    uidata.prompt_info = uri;
+
+    ctx = OSSL_STORE_open(uri, get_ui_method(), &amp;uidata, NULL, NULL);
+    if (ctx == NULL) {
+        BIO_printf(bio_err, &quot;Could not open file or uri %s for loading %s\n&quot;,
+                   uri, desc);
+        goto end;
+    }
+
+    for (;;) {
+        OSSL_STORE_INFO *info = OSSL_STORE_load(ctx);
+        int type = info == NULL ? 0 : OSSL_STORE_INFO_get_type(info);
+        const char *infostr =
+            info == NULL ? NULL : OSSL_STORE_INFO_type_string(type);
+        int err = 0;
+
+        if (info == NULL) {
+            if (OSSL_STORE_eof(ctx))
+                ret = 1;
+            break;
+        }
+
+        switch (type) {
+        case OSSL_STORE_INFO_PKEY:
+            if (ppkey != NULL &amp;&amp; *ppkey == NULL)
+                err = ((*ppkey = OSSL_STORE_INFO_get1_PKEY(info)) == NULL);
+            break;
+        case OSSL_STORE_INFO_CERT:
+            if (pcert != NULL &amp;&amp; *pcert == NULL)
+                err = ((*pcert = OSSL_STORE_INFO_get1_CERT(info)) == NULL);
+            break;
+        case OSSL_STORE_INFO_CRL:
+            if (pcrl != NULL &amp;&amp; *pcrl == NULL)
+                err = ((*pcrl = OSSL_STORE_INFO_get1_CRL(info)) == NULL);
+            break;
+        default:
+            /* skip any other type */
+            break;
+        }
+        OSSL_STORE_INFO_free(info);
+        if (err) {
+            BIO_printf(bio_err, &quot;Could not read %s of %s from %s\n&quot;,
+                       infostr, desc, uri);
+            break;
+        }
+    }
+
+ end:
+    if (ctx != NULL)
+        OSSL_STORE_close(ctx);
+    if (!ret)
+        ERR_print_errors(bio_err);
+    return ret;
+}
+
+static
+EVP_PKEY *load_key_preliminary(const char *uri, int format, int may_stdin,
+                               const char *pass, ENGINE *e, const char *desc)
+{
+    EVP_PKEY *pkey = NULL;
+
+    if (desc == NULL)
+        desc = &quot;private key&quot;;
+
+    if (format == FORMAT_ENGINE) {
+        if (e == NULL) {
+            BIO_printf(bio_err, &quot;No engine specified for loading %s\n&quot;, desc);
+        } else {
+#ifndef OPENSSL_NO_ENGINE
+            PW_CB_DATA cb_data;
+
+            cb_data.password = pass;
+            cb_data.prompt_info = uri;
+            if (ENGINE_init(e)) {
+                pkey = ENGINE_load_private_key(e, uri,
+                                               (UI_METHOD *)get_ui_method(),
+                                               &amp;cb_data);
+                ENGINE_finish(e);
+            }
+            if (pkey == NULL) {
+                BIO_printf(bio_err, &quot;Cannot load %s from engine\n&quot;, desc);
+                ERR_print_errors(bio_err);
+            }
+#else
+            BIO_printf(bio_err, &quot;Engines not supported for loading %s\n&quot;, desc);
+#endif
+        }
+    } else {
+        (void)load_key_cert_crl(uri, may_stdin, pass, desc, &amp;pkey, NULL, NULL);
+    }
+
+    if (pkey == NULL) {
+        BIO_printf(bio_err, &quot;Unable to load %s\n&quot;, desc);
+        ERR_print_errors(bio_err);
+    }
+    return pkey;
+}
+
+static X509 *load_cert_pass(const char *uri, int maybe_stdin,
+                            const char *pass, const char *desc)
+{
+    X509 *cert = NULL;
+
+    if (desc == NULL)
+        desc = &quot;certificate&quot;;
+    (void)load_key_cert_crl(uri, maybe_stdin, pass, desc, NULL, &amp;cert, NULL);
+    if (cert == NULL) {
+        BIO_printf(bio_err, &quot;Unable to load %s\n&quot;, desc);
+        ERR_print_errors(bio_err);
+    }
+    return cert;
+}
+/* end TODO remove when PR #11755 is merged */
+
+static char *opt_config = NULL;
+#define CMP_SECTION &quot;cmp&quot;
+#define SECTION_NAME_MAX 40 /* max length of section name */
+#define DEFAULT_SECTION &quot;default&quot;
+static char *opt_section = CMP_SECTION;
+
+#undef PROG
+#define PROG cmp_main
+static char *prog = &quot;cmp&quot;;
+
+static int read_config(void);
+
+static CONF *conf = NULL; /* OpenSSL config file context structure */
+static OSSL_CMP_CTX *cmp_ctx = NULL; /* the client-side CMP context */
+
+/* TODO remove when new setup_engine_flags() is in apps/lib/apps.c (PR #4277) */
+static
+ENGINE *setup_engine_flags(const char *engine, unsigned int flags, int debug)
+{
+    return setup_engine(engine, debug);
+}
+
+/* the type of cmp command we want to send */
+typedef enum {
+    CMP_IR,
+    CMP_KUR,
+    CMP_CR,
+    CMP_P10CR,
+    CMP_RR,
+    CMP_GENM
+} cmp_cmd_t;
+
+/* message transfer */
+static char *opt_server = NULL;
+static char server_port_s[32] = { '\0' };
+static int server_port = 0;
+static char *opt_proxy = NULL;
+static char *opt_no_proxy = NULL;
+static char *opt_path = &quot;/&quot;;
+static int opt_msg_timeout = -1;
+static int opt_total_timeout = -1;
+
+/* server authentication */
+static char *opt_trusted = NULL;
+static char *opt_untrusted = NULL;
+static char *opt_srvcert = NULL;
+static char *opt_recipient = NULL;
+static char *opt_expect_sender = NULL;
+static int opt_ignore_keyusage = 0;
+static int opt_unprotected_errors = 0;
+static char *opt_extracertsout = NULL;
+static char *opt_cacertsout = NULL;
+
+/* client authentication */
+static char *opt_ref = NULL;
+static char *opt_secret = NULL;
+static char *opt_cert = NULL;
+static char *opt_key = NULL;
+static char *opt_keypass = NULL;
+static char *opt_digest = NULL;
+static char *opt_mac = NULL;
+static char *opt_extracerts = NULL;
+static int opt_unprotected_requests = 0;
+
+/* generic message */
+static char *opt_cmd_s = NULL;
+static int opt_cmd = -1;
+static char *opt_geninfo = NULL;
+static char *opt_infotype_s = NULL;
+static int opt_infotype = NID_undef;
+
+/* certificate enrollment */
+static char *opt_newkey = NULL;
+static char *opt_newkeypass = NULL;
+static char *opt_subject = NULL;
+static char *opt_issuer = NULL;
+static int opt_days = 0;
+static char *opt_reqexts = NULL;
+static char *opt_sans = NULL;
+static int opt_san_nodefault = 0;
+static char *opt_policies = NULL;
+static char *opt_policy_oids = NULL;
+static int opt_policy_oids_critical = 0;
+static int opt_popo = OSSL_CRMF_POPO_NONE - 1;
+static char *opt_csr = NULL;
+static char *opt_out_trusted = NULL;
+static int opt_implicit_confirm = 0;
+static int opt_disable_confirm = 0;
+static char *opt_certout = NULL;
+
+/* certificate enrollment and revocation */
+static char *opt_oldcert = NULL;
+static int opt_revreason = CRL_REASON_NONE;
+
+/* credentials format */
+static char *opt_certform_s = &quot;PEM&quot;;
+static int opt_certform = FORMAT_PEM;
+static char *opt_keyform_s = &quot;PEM&quot;;
+static int opt_keyform = FORMAT_PEM;
+static char *opt_certsform_s = &quot;PEM&quot;;
+static int opt_certsform = FORMAT_PEM;
+static char *opt_otherpass = NULL;
+static char *opt_engine = NULL;
+
+/* TLS connection */
+static int opt_tls_used = 0;
+static char *opt_tls_cert = NULL;
+static char *opt_tls_key = NULL;
+static char *opt_tls_keypass = NULL;
+static char *opt_tls_extra = NULL;
+static char *opt_tls_trusted = NULL;
+static char *opt_tls_host = NULL;
+
+/* client-side debugging */
+static int opt_batch = 0;
+static int opt_repeat = 1;
+static char *opt_reqin = NULL;
+static int opt_reqin_new_tid = 0;
+static char *opt_reqout = NULL;
+static char *opt_rspin = NULL;
+static char *opt_rspout = NULL;
+static int opt_use_mock_srv = 0;
+
+/* server-side debugging */
+static char *opt_port = NULL;
+static int opt_max_msgs = 0;
+
+static char *opt_srv_ref = NULL;
+static char *opt_srv_secret = NULL;
+static char *opt_srv_cert = NULL;
+static char *opt_srv_key = NULL;
+static char *opt_srv_keypass = NULL;
+
+static char *opt_srv_trusted = NULL;
+static char *opt_srv_untrusted = NULL;
+static char *opt_rsp_cert = NULL;
+static char *opt_rsp_extracerts = NULL;
+static char *opt_rsp_capubs = NULL;
+static int opt_poll_count = 0;
+static int opt_check_after = 1;
+static int opt_grant_implicitconf = 0;
+
+static int opt_pkistatus = OSSL_CMP_PKISTATUS_accepted;
+static int opt_failure = INT_MIN;
+static int opt_failurebits = 0;
+static char *opt_statusstring = NULL;
+static int opt_send_error = 0;
+static int opt_send_unprotected = 0;
+static int opt_send_unprot_err = 0;
+static int opt_accept_unprotected = 0;
+static int opt_accept_unprot_err = 0;
+static int opt_accept_raverified = 0;
+
+static X509_VERIFY_PARAM *vpm = NULL;
+
+typedef enum OPTION_choice {
+    OPT_ERR = -1, OPT_EOF = 0, OPT_HELP,
+    OPT_CONFIG, OPT_SECTION,
+
+    OPT_CMD, OPT_INFOTYPE, OPT_GENINFO,
+
+    OPT_NEWKEY, OPT_NEWKEYPASS, OPT_SUBJECT, OPT_ISSUER,
+    OPT_DAYS, OPT_REQEXTS,
+    OPT_SANS, OPT_SAN_NODEFAULT,
+    OPT_POLICIES, OPT_POLICY_OIDS, OPT_POLICY_OIDS_CRITICAL,
+    OPT_POPO, OPT_CSR,
+    OPT_OUT_TRUSTED, OPT_IMPLICIT_CONFIRM, OPT_DISABLE_CONFIRM,
+    OPT_CERTOUT,
+
+    OPT_OLDCERT, OPT_REVREASON,
+
+    OPT_SERVER, OPT_PROXY, OPT_NO_PROXY, OPT_PATH,
+    OPT_MSG_TIMEOUT, OPT_TOTAL_TIMEOUT,
+
+    OPT_TRUSTED, OPT_UNTRUSTED, OPT_SRVCERT,
+    OPT_RECIPIENT, OPT_EXPECT_SENDER,
+    OPT_IGNORE_KEYUSAGE, OPT_UNPROTECTED_ERRORS,
+    OPT_EXTRACERTSOUT, OPT_CACERTSOUT,
+
+    OPT_REF, OPT_SECRET, OPT_CERT, OPT_KEY, OPT_KEYPASS,
+    OPT_DIGEST, OPT_MAC, OPT_EXTRACERTS,
+    OPT_UNPROTECTED_REQUESTS,
+
+    OPT_CERTFORM, OPT_KEYFORM, OPT_CERTSFORM,
+    OPT_OTHERPASS,
+#ifndef OPENSSL_NO_ENGINE
+    OPT_ENGINE,
+#endif
+    OPT_PROV_ENUM,
+
+    OPT_TLS_USED, OPT_TLS_CERT, OPT_TLS_KEY,
+    OPT_TLS_KEYPASS,
+    OPT_TLS_EXTRA, OPT_TLS_TRUSTED, OPT_TLS_HOST,
+
+    OPT_BATCH, OPT_REPEAT,
+    OPT_REQIN, OPT_REQIN_NEW_TID, OPT_REQOUT, OPT_RSPIN, OPT_RSPOUT,
+
+    OPT_USE_MOCK_SRV, OPT_PORT, OPT_MAX_MSGS,
+    OPT_SRV_REF, OPT_SRV_SECRET,
+    OPT_SRV_CERT, OPT_SRV_KEY, OPT_SRV_KEYPASS,
+    OPT_SRV_TRUSTED, OPT_SRV_UNTRUSTED,
+    OPT_RSP_CERT, OPT_RSP_EXTRACERTS, OPT_RSP_CAPUBS,
+    OPT_POLL_COUNT, OPT_CHECK_AFTER,
+    OPT_GRANT_IMPLICITCONF,
+    OPT_PKISTATUS, OPT_FAILURE,
+    OPT_FAILUREBITS, OPT_STATUSSTRING,
+    OPT_SEND_ERROR, OPT_SEND_UNPROTECTED,
+    OPT_SEND_UNPROT_ERR, OPT_ACCEPT_UNPROTECTED,
+    OPT_ACCEPT_UNPROT_ERR, OPT_ACCEPT_RAVERIFIED,
+
+    OPT_V_ENUM
+} OPTION_CHOICE;
+
+const OPTIONS cmp_options[] = {
+    /* entries must be in the same order as enumerated above!! */
+    {&quot;help&quot;, OPT_HELP, '-', &quot;Display this summary&quot;},
+    {&quot;config&quot;, OPT_CONFIG, 's',
+     &quot;Configuration file to use. \&quot;\&quot; = none. Default from env variable OPENSSL_CONF&quot;},
+    {&quot;section&quot;, OPT_SECTION, 's',
+     &quot;Section(s) in config file to get options from. \&quot;\&quot; = 'default'. Default 'cmp'&quot;},
+
+    OPT_SECTION(&quot;Generic message&quot;),
+    {&quot;cmd&quot;, OPT_CMD, 's', &quot;CMP request to send: ir/cr/kur/p10cr/rr/genm&quot;},
+    {&quot;infotype&quot;, OPT_INFOTYPE, 's',
+     &quot;InfoType name for requesting specific info in genm, e.g. 'signKeyPairTypes'&quot;},
+    {&quot;geninfo&quot;, OPT_GENINFO, 's',
+     &quot;generalInfo integer values to place in request PKIHeader with given OID&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;specified in the form &lt;OID&gt;:int:&lt;n&gt;, e.g. \&quot;1.2.3:int:987\&quot;&quot;},
+
+    OPT_SECTION(&quot;Certificate enrollment&quot;),
+    {&quot;newkey&quot;, OPT_NEWKEY, 's',
+     &quot;Private or public key for the requested cert. Default: CSR key or client key&quot;},
+    {&quot;newkeypass&quot;, OPT_NEWKEYPASS, 's', &quot;New private key pass phrase source&quot;},
+    {&quot;subject&quot;, OPT_SUBJECT, 's',
+     &quot;Distinguished Name (DN) of subject to use in the requested cert template&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;For kur, default is the subject DN of the reference cert (see -oldcert);&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;this default is used for ir and cr only if no Subject Alt Names are set&quot;},
+    {&quot;issuer&quot;, OPT_ISSUER, 's',
+     &quot;DN of the issuer to place in the requested certificate template&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;also used as recipient if neither -recipient nor -srvcert are given&quot;},
+    {&quot;days&quot;, OPT_DAYS, 'n',
+     &quot;Requested validity time of the new certificate in number of days&quot;},
+    {&quot;reqexts&quot;, OPT_REQEXTS, 's',
+     &quot;Name of config file section defining certificate request extensions&quot;},
+    {&quot;sans&quot;, OPT_SANS, 's',
+     &quot;Subject Alt Names (IPADDR/DNS/URI) to add as (critical) cert req extension&quot;},
+    {&quot;san_nodefault&quot;, OPT_SAN_NODEFAULT, '-',
+     &quot;Do not take default SANs from reference certificate (see -oldcert)&quot;},
+    {&quot;policies&quot;, OPT_POLICIES, 's',
+     &quot;Name of config file section defining policies certificate request extension&quot;},
+    {&quot;policy_oids&quot;, OPT_POLICY_OIDS, 's',
+     &quot;Policy OID(s) to add as policies certificate request extension&quot;},
+    {&quot;policy_oids_critical&quot;, OPT_POLICY_OIDS_CRITICAL, '-',
+     &quot;Flag the policy OID(s) given with -policy_oids as critical&quot;},
+    {&quot;popo&quot;, OPT_POPO, 'n',
+     &quot;Proof-of-Possession (POPO) method to use for ir/cr/kur where&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;-1 = NONE, 0 = RAVERIFIED, 1 = SIGNATURE (default), 2 = KEYENC&quot;},
+    {&quot;csr&quot;, OPT_CSR, 's',
+     &quot;CSR file in PKCS#10 format to use in p10cr for legacy support&quot;},
+    {&quot;out_trusted&quot;, OPT_OUT_TRUSTED, 's',
+     &quot;Certificates to trust when verifying newly enrolled certificates&quot;},
+    {&quot;implicit_confirm&quot;, OPT_IMPLICIT_CONFIRM, '-',
+     &quot;Request implicit confirmation of newly enrolled certificates&quot;},
+    {&quot;disable_confirm&quot;, OPT_DISABLE_CONFIRM, '-',
+     &quot;Do not confirm newly enrolled certificate w/o requesting implicit&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;confirmation. WARNING: This leads to behavior violating RFC 4210&quot;},
+    {&quot;certout&quot;, OPT_CERTOUT, 's',
+     &quot;File to save newly enrolled certificate&quot;},
+
+    OPT_SECTION(&quot;Certificate enrollment and revocation&quot;),
+
+    {&quot;oldcert&quot;, OPT_OLDCERT, 's',
+     &quot;Certificate to be updated (defaulting to -cert) or to be revoked in rr;&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;also used as reference (defaulting to -cert) for subject DN and SANs.&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;Its issuer is used as recipient unless -srvcert, -recipient or -issuer given&quot;},
+    {&quot;revreason&quot;, OPT_REVREASON, 'n',
+     &quot;Reason code to include in revocation request (rr); possible values:&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;0..6, 8..10 (see RFC5280, 5.3.1) or -1. Default -1 = none included&quot;},
+
+    OPT_SECTION(&quot;Message transfer&quot;),
+    {&quot;server&quot;, OPT_SERVER, 's',
+     &quot;[http[s]://]address[:port] of CMP server. Default port 80 or 443.&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;The address may be a DNS name or an IP address&quot;},
+    {&quot;proxy&quot;, OPT_PROXY, 's',
+     &quot;[http[s]://]address[:port][/path] of HTTP(S) proxy to use; path is ignored&quot;},
+    {&quot;no_proxy&quot;, OPT_NO_PROXY, 's',
+     &quot;List of addresses of servers not to use HTTP(S) proxy for&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;Default from environment variable 'no_proxy', else 'NO_PROXY', else none&quot;},
+    {&quot;path&quot;, OPT_PATH, 's',
+     &quot;HTTP path (aka CMP alias) at the CMP server. Default \&quot;/\&quot;&quot;},
+    {&quot;msg_timeout&quot;, OPT_MSG_TIMEOUT, 'n',
+     &quot;Timeout per CMP message round trip (or 0 for none). Default 120 seconds&quot;},
+    {&quot;total_timeout&quot;, OPT_TOTAL_TIMEOUT, 'n',
+     &quot;Overall time an enrollment incl. polling may take. Default 0 = infinite&quot;},
+
+    OPT_SECTION(&quot;Server authentication&quot;),
+    {&quot;trusted&quot;, OPT_TRUSTED, 's',
+     &quot;Trusted certs used for CMP server authentication when verifying responses&quot;},
+    {OPT_MORE_STR, 0, 0, &quot;unless -srvcert is given&quot;},
+    {&quot;untrusted&quot;, OPT_UNTRUSTED, 's',
+     &quot;Intermediate certs for chain construction verifying CMP/TLS/enrolled certs&quot;},
+    {&quot;srvcert&quot;, OPT_SRVCERT, 's',
+     &quot;Specific CMP server cert to use and trust directly when verifying responses&quot;},
+    {&quot;recipient&quot;, OPT_RECIPIENT, 's',
+     &quot;Distinguished Name (DN) of the recipient to use unless -srvcert is given&quot;},
+    {&quot;expect_sender&quot;, OPT_EXPECT_SENDER, 's',
+     &quot;DN of expected response sender. Defaults to DN of -srvcert, if provided&quot;},
+    {&quot;ignore_keyusage&quot;, OPT_IGNORE_KEYUSAGE, '-',
+     &quot;Ignore CMP signer cert key usage, else 'digitalSignature' must be allowed&quot;},
+    {&quot;unprotected_errors&quot;, OPT_UNPROTECTED_ERRORS, '-',
+     &quot;Accept missing or invalid protection of regular error messages and negative&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;certificate responses (ip/cp/kup), revocation responses (rp), and PKIConf&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;WARNING: This setting leads to behavior allowing violation of RFC 4210&quot;},
+    {&quot;extracertsout&quot;, OPT_EXTRACERTSOUT, 's',
+     &quot;File to save extra certificates received in the extraCerts field&quot;},
+    {&quot;cacertsout&quot;, OPT_CACERTSOUT, 's',
+     &quot;File to save CA certificates received in the caPubs field of 'ip' messages&quot;},
+
+    OPT_SECTION(&quot;Client authentication&quot;),
+    {&quot;ref&quot;, OPT_REF, 's',
+     &quot;Reference value to use as senderKID in case no -cert is given&quot;},
+    {&quot;secret&quot;, OPT_SECRET, 's',
+     &quot;Password source for client authentication with a pre-shared key (secret)&quot;},
+    {&quot;cert&quot;, OPT_CERT, 's',
+     &quot;Client's current certificate (needed unless using -secret for PBM);&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;any further certs included are appended in extraCerts field&quot;},
+    {&quot;key&quot;, OPT_KEY, 's', &quot;Private key for the client's current certificate&quot;},
+    {&quot;keypass&quot;, OPT_KEYPASS, 's',
+     &quot;Client private key (and cert and old cert file) pass phrase source&quot;},
+    {&quot;digest&quot;, OPT_DIGEST, 's',
+     &quot;Digest to use in message protection and POPO signatures. Default \&quot;sha256\&quot;&quot;},
+    {&quot;mac&quot;, OPT_MAC, 's',
+     &quot;MAC algorithm to use in PBM-based message protection. Default \&quot;hmac-sha1\&quot;&quot;},
+    {&quot;extracerts&quot;, OPT_EXTRACERTS, 's',
+     &quot;Certificates to append in extraCerts field of outgoing messages&quot;},
+    {&quot;unprotected_requests&quot;, OPT_UNPROTECTED_REQUESTS, '-',
+     &quot;Send messages without CMP-level protection&quot;},
+
+    OPT_SECTION(&quot;Credentials format&quot;),
+    {&quot;certform&quot;, OPT_CERTFORM, 's',
+     &quot;Format (PEM or DER) to use when saving a certificate to a file. Default PEM&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;This also determines format to use for writing (not supported for P12)&quot;},
+    {&quot;keyform&quot;, OPT_KEYFORM, 's',
+     &quot;Format to assume when reading key files. Default PEM&quot;},
+    {&quot;certsform&quot;, OPT_CERTSFORM, 's',
+     &quot;Format (PEM/DER/P12) to try first reading multiple certs. Default PEM&quot;},
+    {&quot;otherpass&quot;, OPT_OTHERPASS, 's',
+     &quot;Pass phrase source potentially needed for loading certificates of others&quot;},
+#ifndef OPENSSL_NO_ENGINE
+    {&quot;engine&quot;, OPT_ENGINE, 's',
+     &quot;Use crypto engine with given identifier, possibly a hardware device.&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;Engines may be defined in OpenSSL config file engine section.&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;Options like -key specifying keys held in the engine can give key IDs&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;prefixed by 'engine:', e.g. '-key engine:pkcs11:object=mykey;pin-value=1234'&quot;},
+#endif
+    OPT_PROV_OPTIONS,
+
+    OPT_SECTION(&quot;TLS connection&quot;),
+    {&quot;tls_used&quot;, OPT_TLS_USED, '-',
+     &quot;Enable using TLS (also when other TLS options are not set)&quot;},
+    {&quot;tls_cert&quot;, OPT_TLS_CERT, 's',
+     &quot;Client's TLS certificate. May include chain to be provided to TLS server&quot;},
+    {&quot;tls_key&quot;, OPT_TLS_KEY, 's',
+     &quot;Private key for the client's TLS certificate&quot;},
+    {&quot;tls_keypass&quot;, OPT_TLS_KEYPASS, 's',
+     &quot;Pass phrase source for the client's private TLS key (and TLS cert file)&quot;},
+    {&quot;tls_extra&quot;, OPT_TLS_EXTRA, 's',
+     &quot;Extra certificates to provide to TLS server during TLS handshake&quot;},
+    {&quot;tls_trusted&quot;, OPT_TLS_TRUSTED, 's',
+     &quot;Trusted certificates to use for verifying the TLS server certificate;&quot;},
+    {OPT_MORE_STR, 0, 0, &quot;this implies host name validation&quot;},
+    {&quot;tls_host&quot;, OPT_TLS_HOST, 's',
+     &quot;Address to be checked (rather than -server) during TLS host name validation&quot;},
+
+    OPT_SECTION(&quot;Client-side debugging&quot;),
+    {&quot;batch&quot;, OPT_BATCH, '-',
+     &quot;Do not interactively prompt for input when a password is required etc.&quot;},
+    {&quot;repeat&quot;, OPT_REPEAT, 'n',
+     &quot;Invoke the transaction the given number of times. Default 1&quot;},
+    {&quot;reqin&quot;, OPT_REQIN, 's', &quot;Take sequence of CMP requests from file(s)&quot;},
+    {&quot;reqin_new_tid&quot;, OPT_REQIN_NEW_TID, '-',
+     &quot;Use fresh transactionID for CMP requests read from -reqin&quot;},
+    {&quot;reqout&quot;, OPT_REQOUT, 's', &quot;Save sequence of CMP requests to file(s)&quot;},
+    {&quot;rspin&quot;, OPT_RSPIN, 's',
+     &quot;Process sequence of CMP responses provided in file(s), skipping server&quot;},
+    {&quot;rspout&quot;, OPT_RSPOUT, 's', &quot;Save sequence of CMP responses to file(s)&quot;},
+
+    {&quot;use_mock_srv&quot;, OPT_USE_MOCK_SRV, '-', &quot;Use mock server at API level, bypassing HTTP&quot;},
+
+    OPT_SECTION(&quot;Mock server&quot;),
+    {&quot;port&quot;, OPT_PORT, 's', &quot;Act as HTTP mock server listening on given port&quot;},
+    {&quot;max_msgs&quot;, OPT_MAX_MSGS, 'n',
+     &quot;max number of messages handled by HTTP mock server. Default: 0 = unlimited&quot;},
+
+    {&quot;srv_ref&quot;, OPT_SRV_REF, 's',
+     &quot;Reference value to use as senderKID of server in case no -srv_cert is given&quot;},
+    {&quot;srv_secret&quot;, OPT_SRV_SECRET, 's',
+     &quot;Password source for server authentication with a pre-shared key (secret)&quot;},
+    {&quot;srv_cert&quot;, OPT_SRV_CERT, 's', &quot;Certificate of the server&quot;},
+    {&quot;srv_key&quot;, OPT_SRV_KEY, 's',
+     &quot;Private key used by the server for signing messages&quot;},
+    {&quot;srv_keypass&quot;, OPT_SRV_KEYPASS, 's',
+     &quot;Server private key (and cert) file pass phrase source&quot;},
+
+    {&quot;srv_trusted&quot;, OPT_SRV_TRUSTED, 's',
+     &quot;Trusted certificates for client authentication&quot;},
+    {&quot;srv_untrusted&quot;, OPT_SRV_UNTRUSTED, 's',
+     &quot;Intermediate certs that may be useful for verifying CMP protection&quot;},
+    {&quot;rsp_cert&quot;, OPT_RSP_CERT, 's',
+     &quot;Certificate to be returned as mock enrollment result&quot;},
+    {&quot;rsp_extracerts&quot;, OPT_RSP_EXTRACERTS, 's',
+     &quot;Extra certificates to be included in mock certification responses&quot;},
+    {&quot;rsp_capubs&quot;, OPT_RSP_CAPUBS, 's',
+     &quot;CA certificates to be included in mock ip response&quot;},
+    {&quot;poll_count&quot;, OPT_POLL_COUNT, 'n',
+     &quot;Number of times the client must poll before receiving a certificate&quot;},
+    {&quot;check_after&quot;, OPT_CHECK_AFTER, 'n',
+     &quot;The check_after value (time to wait) to include in poll response&quot;},
+    {&quot;grant_implicitconf&quot;, OPT_GRANT_IMPLICITCONF, '-',
+     &quot;Grant implicit confirmation of newly enrolled certificate&quot;},
+
+    {&quot;pkistatus&quot;, OPT_PKISTATUS, 'n',
+     &quot;PKIStatus to be included in server response. Possible values: 0..6&quot;},
+    {&quot;failure&quot;, OPT_FAILURE, 'n',
+     &quot;A single failure info bit number to include in server response, 0..26&quot;},
+    {&quot;failurebits&quot;, OPT_FAILUREBITS, 'n',
+     &quot;Number representing failure bits to include in server response, 0..2^27 - 1&quot;},
+    {&quot;statusstring&quot;, OPT_STATUSSTRING, 's',
+     &quot;Status string to be included in server response&quot;},
+    {&quot;send_error&quot;, OPT_SEND_ERROR, '-',
+     &quot;Force server to reply with error message&quot;},
+    {&quot;send_unprotected&quot;, OPT_SEND_UNPROTECTED, '-',
+     &quot;Send response messages without CMP-level protection&quot;},
+    {&quot;send_unprot_err&quot;, OPT_SEND_UNPROT_ERR, '-',
+     &quot;In case of negative responses, server shall send unprotected error messages,&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;certificate responses (ip/cp/kup), and revocation responses (rp).&quot;},
+    {OPT_MORE_STR, 0, 0,
+     &quot;WARNING: This setting leads to behavior violating RFC 4210&quot;},
+    {&quot;accept_unprotected&quot;, OPT_ACCEPT_UNPROTECTED, '-',
+     &quot;Accept missing or invalid protection of requests&quot;},
+    {&quot;accept_unprot_err&quot;, OPT_ACCEPT_UNPROT_ERR, '-',
+     &quot;Accept unprotected error messages from client&quot;},
+    {&quot;accept_raverified&quot;, OPT_ACCEPT_RAVERIFIED, '-',
+     &quot;Accept RAVERIFIED as proof-of-possession (POPO)&quot;},
+
+    OPT_V_OPTIONS,
+    {NULL}
+};
+
+typedef union {
+    char **txt;
+    int *num;
+    long *num_long;
+} varref;
+static varref cmp_vars[] = { /* must be in same order as enumerated above! */
+    {&amp;opt_config}, {&amp;opt_section},
+
+    {&amp;opt_cmd_s}, {&amp;opt_infotype_s}, {&amp;opt_geninfo},
+
+    {&amp;opt_newkey}, {&amp;opt_newkeypass}, {&amp;opt_subject}, {&amp;opt_issuer},
+    {(char **)&amp;opt_days}, {&amp;opt_reqexts},
+    {&amp;opt_sans}, {(char **)&amp;opt_san_nodefault},
+    {&amp;opt_policies}, {&amp;opt_policy_oids}, {(char **)&amp;opt_policy_oids_critical},
+    {(char **)&amp;opt_popo}, {&amp;opt_csr},
+    {&amp;opt_out_trusted},
+    {(char **)&amp;opt_implicit_confirm}, {(char **)&amp;opt_disable_confirm},
+    {&amp;opt_certout},
+
+    {&amp;opt_oldcert}, {(char **)&amp;opt_revreason},
+
+    {&amp;opt_server}, {&amp;opt_proxy}, {&amp;opt_no_proxy}, {&amp;opt_path},
+    {(char **)&amp;opt_msg_timeout}, {(char **)&amp;opt_total_timeout},
+
+    {&amp;opt_trusted}, {&amp;opt_untrusted}, {&amp;opt_srvcert},
+    {&amp;opt_recipient}, {&amp;opt_expect_sender},
+    {(char **)&amp;opt_ignore_keyusage}, {(char **)&amp;opt_unprotected_errors},
+    {&amp;opt_extracertsout}, {&amp;opt_cacertsout},
+
+    {&amp;opt_ref}, {&amp;opt_secret}, {&amp;opt_cert}, {&amp;opt_key}, {&amp;opt_keypass},
+    {&amp;opt_digest}, {&amp;opt_mac}, {&amp;opt_extracerts},
+    {(char **)&amp;opt_unprotected_requests},
+
+    {&amp;opt_certform_s}, {&amp;opt_keyform_s}, {&amp;opt_certsform_s},
+    {&amp;opt_otherpass},
+#ifndef OPENSSL_NO_ENGINE
+    {&amp;opt_engine},
+#endif
+
+    {(char **)&amp;opt_tls_used}, {&amp;opt_tls_cert}, {&amp;opt_tls_key},
+    {&amp;opt_tls_keypass},
+    {&amp;opt_tls_extra}, {&amp;opt_tls_trusted}, {&amp;opt_tls_host},
+
+    {(char **)&amp;opt_batch}, {(char **)&amp;opt_repeat},
+    {&amp;opt_reqin}, {(char **)&amp;opt_reqin_new_tid},
+    {&amp;opt_reqout}, {&amp;opt_rspin}, {&amp;opt_rspout},
+
+    {(char **)&amp;opt_use_mock_srv}, {&amp;opt_port}, {(char **)&amp;opt_max_msgs},
+    {&amp;opt_srv_ref}, {&amp;opt_srv_secret},
+    {&amp;opt_srv_cert}, {&amp;opt_srv_key}, {&amp;opt_srv_keypass},
+    {&amp;opt_srv_trusted}, {&amp;opt_srv_untrusted},
+    {&amp;opt_rsp_cert}, {&amp;opt_rsp_extracerts}, {&amp;opt_rsp_capubs},
+    {(char **)&amp;opt_poll_count}, {(char **)&amp;opt_check_after},
+    {(char **)&amp;opt_grant_implicitconf},
+    {(char **)&amp;opt_pkistatus}, {(char **)&amp;opt_failure},
+    {(char **)&amp;opt_failurebits}, {&amp;opt_statusstring},
+    {(char **)&amp;opt_send_error}, {(char **)&amp;opt_send_unprotected},
+    {(char **)&amp;opt_send_unprot_err}, {(char **)&amp;opt_accept_unprotected},
+    {(char **)&amp;opt_accept_unprot_err}, {(char **)&amp;opt_accept_raverified},
+
+    {NULL}
+};
+
+#ifndef NDEBUG
+# define FUNC (strcmp(OPENSSL_FUNC, &quot;(unknown function)&quot;) == 0  \
+               ? &quot;CMP&quot; : &quot;OPENSSL_FUNC&quot;)
+# define PRINT_LOCATION(bio) BIO_printf(bio, &quot;%s:%s:%d:&quot;, \
+                                        FUNC, OPENSSL_FILE, OPENSSL_LINE)
+#else
+# define PRINT_LOCATION(bio) ((void)0)
+#endif
+#define CMP_print(bio, prefix, msg, a1, a2, a3) \
+    (PRINT_LOCATION(bio), \
+     BIO_printf(bio, &quot;CMP %s: &quot; msg &quot;\n&quot;, prefix, a1, a2, a3))
+#define CMP_INFO(msg, a1, a2, a3)  CMP_print(bio_out, &quot;info&quot;, msg, a1, a2, a3)
+#define CMP_info(msg)              CMP_INFO(msg&quot;%s%s%s&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;)
+#define CMP_info1(msg, a1)         CMP_INFO(msg&quot;%s%s&quot;,   a1, &quot;&quot;, &quot;&quot;)
+#define CMP_info2(msg, a1, a2)     CMP_INFO(msg&quot;%s&quot;,     a1, a2, &quot;&quot;)
+#define CMP_info3(msg, a1, a2, a3) CMP_INFO(msg,         a1, a2, a3)
+#define CMP_WARN(m, a1, a2, a3)    CMP_print(bio_out, &quot;warning&quot;, m, a1, a2, a3)
+#define CMP_warn(msg)              CMP_WARN(msg&quot;%s%s%s&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;)
+#define CMP_warn1(msg, a1)         CMP_WARN(msg&quot;%s%s&quot;,   a1, &quot;&quot;, &quot;&quot;)
+#define CMP_warn2(msg, a1, a2)     CMP_WARN(msg&quot;%s&quot;,     a1, a2, &quot;&quot;)
+#define CMP_warn3(msg, a1, a2, a3) CMP_WARN(msg,         a1, a2, a3)
+#define CMP_ERR(msg, a1, a2, a3)   CMP_print(bio_err, &quot;error&quot;, msg, a1, a2, a3)
+#define CMP_err(msg)               CMP_ERR(msg&quot;%s%s%s&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;)
+#define CMP_err1(msg, a1)          CMP_ERR(msg&quot;%s%s&quot;,   a1, &quot;&quot;, &quot;&quot;)
+#define CMP_err2(msg, a1, a2)      CMP_ERR(msg&quot;%s&quot;,     a1, a2, &quot;&quot;)
+#define CMP_err3(msg, a1, a2, a3)  CMP_ERR(msg,         a1, a2, a3)
+
+static int print_to_bio_out(const char *func, const char *file, int line,
+                            OSSL_CMP_severity level, const char *msg)
+{
+    return OSSL_CMP_print_to_bio(bio_out, func, file, line, level, msg);
+}
+
+/* code duplicated from crypto/cmp/cmp_util.c */
+static int sk_X509_add1_cert(STACK_OF(X509) *sk, X509 *cert,
+                             int no_dup, int prepend)
+{
+    if (no_dup) {
+        /*
+         * not using sk_X509_set_cmp_func() and sk_X509_find()
+         * because this re-orders the certs on the stack
+         */
+        int i;
+
+        for (i = 0; i &lt; sk_X509_num(sk); i++) {
+            if (X509_cmp(sk_X509_value(sk, i), cert) == 0)
+                return 1;
+        }
+    }
+    if (!X509_up_ref(cert))
+        return 0;
+    if (!sk_X509_insert(sk, cert, prepend ? 0 : -1)) {
+        X509_free(cert);
+        return 0;
+    }
+    return 1;
+}
+
+/* code duplicated from crypto/cmp/cmp_util.c */
+static int sk_X509_add1_certs(STACK_OF(X509) *sk, STACK_OF(X509) *certs,
+                              int no_self_signed, int no_dups, int prepend)
+/* compiler would allow 'const' for the list of certs, yet they are up-ref'ed */
+{
+    int i;
+
+    if (sk == NULL)
+        return 0;
+    if (certs == NULL)
+        return 1;
+    for (i = 0; i &lt; sk_X509_num(certs); i++) {
+        X509 *cert = sk_X509_value(certs, i);
+
+        if (!no_self_signed || X509_check_issued(cert, cert) != X509_V_OK) {
+            if (!sk_X509_add1_cert(sk, cert, no_dups, prepend))
+                return 0;
+        }
+    }
+    return 1;
+}
+
+/* TODO potentially move to apps/lib/apps.c */
+static char *next_item(char *opt) /* in list separated by comma and/or space */
+{
+    /* advance to separator (comma or whitespace), if any */
+    while (*opt != ',' &amp;&amp; !isspace(*opt) &amp;&amp; *opt != '\0') {
+        if (*opt == '\\' &amp;&amp; opt[1] != '\0')
+            /* skip and unescape '\' escaped char */
+            memmove(opt, opt + 1, strlen(opt));
+        opt++;
+    }
+    if (*opt != '\0') {
+        /* terminate current item */
+        *opt++ = '\0';
+        /* skip over any whitespace after separator */
+        while (isspace(*opt))
+            opt++;
+    }
+    return *opt == '\0' ? NULL : opt; /* NULL indicates end of input */
+}
+
+static EVP_PKEY *load_key_pwd(const char *uri, int format,
+                              const char *pass, ENGINE *e, const char *desc)
+{
+    char *pass_string = get_passwd(pass, desc);
+    EVP_PKEY *pkey = load_key_preliminary(uri, format, 0, pass_string, e, desc);
+
+    clear_free(pass_string);
+    return pkey;
+}
+
+static X509 *load_cert_pwd(const char *uri, const char *pass, const char *desc)
+{
+    X509 *cert;
+    char *pass_string = get_passwd(pass, desc);
+
+    cert = load_cert_pass(uri, 0, pass_string, desc);
+    clear_free(pass_string);
+    return cert;
+}
+
+/* TODO remove when PR #4930 is merged */
+static int load_pkcs12(BIO *in, const char *desc,
+                       pem_password_cb *pem_cb, void *cb_data,
+                       EVP_PKEY **pkey, X509 **cert, STACK_OF(X509) **ca)
+{
+    const char *pass;
+    char tpass[PEM_BUFSIZE];
+    int len;
+    int ret = 0;
+    PKCS12 *p12 = d2i_PKCS12_bio(in, NULL);
+
+    if (desc == NULL)
+        desc = &quot;PKCS12 input&quot;;
+    if (p12 == NULL) {
+        BIO_printf(bio_err, &quot;error loading PKCS12 file for %s\n&quot;, desc);
+        goto die;
+    }
+
+    /* See if an empty password will do */
+    if (PKCS12_verify_mac(p12, &quot;&quot;, 0) || PKCS12_verify_mac(p12, NULL, 0)) {
+        pass = &quot;&quot;;
+    } else {
+        if (pem_cb == NULL)
+            pem_cb = wrap_password_callback;
+        len = pem_cb(tpass, PEM_BUFSIZE, 0, cb_data);
+        if (len &lt; 0) {
+            BIO_printf(bio_err, &quot;passphrase callback error for %s\n&quot;, desc);
+            goto die;
+        }
+        if (len &lt; PEM_BUFSIZE)
+            tpass[len] = 0;
+        if (!PKCS12_verify_mac(p12, tpass, len)) {
+            BIO_printf(bio_err,
+                       &quot;mac verify error (wrong password?) in PKCS12 file for %s\n&quot;,
+                       desc);
+            goto die;
+        }
+        pass = tpass;
+    }
+    ret = PKCS12_parse(p12, pass, pkey, cert, ca);
+ die:
+    PKCS12_free(p12);
+    return ret;
+}
+
+/* TODO potentially move this and related functions to apps/lib/apps.c */
+static int adjust_format(const char **infile, int format, int engine_ok)
+{
+    if (!strncasecmp(*infile, &quot;<A HREF="http://">http://</A>&quot;, 7)
+            || !strncasecmp(*infile, &quot;<A HREF="https://">https://</A>&quot;, 8)) {
+        format = FORMAT_HTTP;
+    } else if (engine_ok &amp;&amp; strncasecmp(*infile, &quot;engine:&quot;, 7) == 0) {
+        *infile += 7;
+        format = FORMAT_ENGINE;
+    } else {
+        if (strncasecmp(*infile, &quot;file:&quot;, 5) == 0)
+            *infile += 5;
+        /*
+         * the following is a heuristic whether first to try PEM or DER
+         * or PKCS12 as the input format for files
+         */
+        if (strlen(*infile) &gt;= 4) {
+            const char *extension = *infile + strlen(*infile) - 4;
+
+            if (strncasecmp(extension, &quot;.crt&quot;, 4) == 0
+                    || strncasecmp(extension, &quot;.pem&quot;, 4) == 0)
+                /* weak recognition of PEM format */
+                format = FORMAT_PEM;
+            else if (strncasecmp(extension, &quot;.cer&quot;, 4) == 0
+                         || strncasecmp(extension, &quot;.der&quot;, 4) == 0)
+                /* weak recognition of DER format */
+                format = FORMAT_ASN1;
+            else if (strncasecmp(extension, &quot;.p12&quot;, 4) == 0)
+                /* weak recognition of PKCS#12 format */
+                format = FORMAT_PKCS12;
+            /* else retain given format */
+        }
+    }
+    return format;
+}
+
+/*
+ * TODO potentially move this and related functions to apps/lib/
+ * or even better extend OSSL_STORE with type OSSL_STORE_INFO_CRL
+ */
+static X509_REQ *load_csr_autofmt(const char *infile, const char *desc)
+{
+    X509_REQ *csr;
+    BIO *bio_bak = bio_err;
+    int can_retry;
+    int format = adjust_format(&amp;infile, FORMAT_PEM, 0);
+
+    can_retry = format == FORMAT_PEM || format == FORMAT_ASN1;
+    if (can_retry)
+        bio_err = NULL; /* do not show errors on more than one try */
+    csr = load_csr(infile, format, desc);
+    bio_err = bio_bak;
+    if (csr == NULL &amp;&amp; can_retry) {
+        ERR_clear_error();
+        format = (format == FORMAT_PEM ? FORMAT_ASN1 : FORMAT_PEM);
+        csr = load_csr(infile, format, desc);
+    }
+    if (csr == NULL) {
+        ERR_print_errors(bio_err);
+        BIO_printf(bio_err, &quot;error: unable to load %s from file '%s'\n&quot;, desc,
+                   infile);
+    }
+    return csr;
+}
+
+/* TODO replace by calling generalized load_certs() when PR #4930 is merged */
+static int load_certs_preliminary(const char *file, STACK_OF(X509) **certs,
+                                  int format, const char *pass,
+                                  const char *desc)
+{
+    X509 *cert = NULL;
+    int ret = 0;
+
+    if (format == FORMAT_PKCS12) {
+        BIO *bio = bio_open_default(file, 'r', format);
+
+        if (bio != NULL) {
+            EVP_PKEY *pkey = NULL; /* pkey is needed until PR #4930 is merged */
+            PW_CB_DATA cb_data;
+
+            cb_data.password = pass;
+            cb_data.prompt_info = file;
+            ret = load_pkcs12(bio, desc, wrap_password_callback,
+                              &amp;cb_data, &amp;pkey, &amp;cert, certs);
+            EVP_PKEY_free(pkey);
+            BIO_free(bio);
+        }
+    } else if (format == FORMAT_ASN1) { /* load only one cert in this case */
+        CMP_warn1(&quot;can load only one certificate in DER format from %s&quot;, file);
+        cert = load_cert_pass(file, 0, pass, desc);
+    }
+    if (format == FORMAT_PKCS12 || format == FORMAT_ASN1) {
+        if (cert) {
+            if (*certs == NULL)
+                *certs = sk_X509_new_null();
+            if (*certs != NULL)
+                ret = sk_X509_insert(*certs, cert, 0);
+            else
+                X509_free(cert);
+        }
+    } else {
+        ret = load_certs(file, certs, format, pass, desc);
+    }
+    return ret;
+}
+
+static void warn_certs_expired(const char *file, STACK_OF(X509) **certs)
+{
+    int i, res;
+    X509 *cert;
+    char *subj;
+
+    for (i = 0; i &lt; sk_X509_num(*certs); i++) {
+        cert = sk_X509_value(*certs, i);
+        res = X509_cmp_timeframe(vpm, X509_get0_notBefore(cert),
+                                 X509_get0_notAfter(cert));
+        if (res != 0) {
+            subj = X509_NAME_oneline(X509_get_subject_name(cert), NULL, 0);
+            CMP_warn3(&quot;certificate from '%s' with subject '%s' %s&quot;, file, subj,
+                      res &gt; 0 ? &quot;has expired&quot; : &quot;not yet valid&quot;);
+            OPENSSL_free(subj);
+        }
+    }
+}
+
+/*
+ * TODO potentially move this and related functions to apps/lib/
+ * or even better extend OSSL_STORE with type OSSL_STORE_INFO_CERTS
+ */
+static int load_certs_autofmt(const char *infile, STACK_OF(X509) **certs,
+                              int exclude_http, const char *pass,
+                              const char *desc)
+{
+    int ret = 0;
+    char *pass_string;
+    BIO *bio_bak = bio_err;
+    int format = adjust_format(&amp;infile, opt_certsform, 0);
+
+    if (exclude_http &amp;&amp; format == FORMAT_HTTP) {
+        BIO_printf(bio_err, &quot;error: HTTP retrieval not allowed for %s\n&quot;, desc);
+        return ret;
+    }
+    pass_string = get_passwd(pass, desc);
+    if (format != FORMAT_HTTP)
+        bio_err = NULL; /* do not show errors on more than one try */
+    ret = load_certs_preliminary(infile, certs, format, pass_string, desc);
+    bio_err = bio_bak;
+    if (!ret &amp;&amp; format != FORMAT_HTTP) {
+        int format2 = format == FORMAT_PEM ? FORMAT_ASN1 : FORMAT_PEM;
+
+        ERR_clear_error();
+        ret = load_certs_preliminary(infile, certs, format2, pass_string, desc);
+    }
+    clear_free(pass_string);
+
+    if (ret)
+        warn_certs_expired(infile, certs);
+    return ret;
+}
+
+/* set expected host name/IP addr and clears the email addr in the given ts */
+static int truststore_set_host_etc(X509_STORE *ts, char *host)
+{
+    X509_VERIFY_PARAM *ts_vpm = X509_STORE_get0_param(ts);
+
+    /* first clear any host names, IP, and email addresses */
+    if (!X509_VERIFY_PARAM_set1_host(ts_vpm, NULL, 0)
+            || !X509_VERIFY_PARAM_set1_ip(ts_vpm, NULL, 0)
+            || !X509_VERIFY_PARAM_set1_email(ts_vpm, NULL, 0))
+        return 0;
+    X509_VERIFY_PARAM_set_hostflags(ts_vpm,
+                                    X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT |
+                                    X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS);
+    return (host != NULL &amp;&amp; X509_VERIFY_PARAM_set1_ip_asc(ts_vpm, host))
+        || X509_VERIFY_PARAM_set1_host(ts_vpm, host, 0);
+}
+
+static X509_STORE *sk_X509_to_store(X509_STORE *store /* may be NULL */,
+                                    const STACK_OF(X509) *certs /* may NULL */)
+{
+    int i;
+
+    if (store == NULL)
+        store = X509_STORE_new();
+    if (store == NULL)
+        return NULL;
+    for (i = 0; i &lt; sk_X509_num(certs); i++) {
+        if (!X509_STORE_add_cert(store, sk_X509_value(certs, i))) {
+            X509_STORE_free(store);
+            return NULL;
+        }
+    }
+    return store;
+}
+
+/* write OSSL_CMP_MSG DER-encoded to the specified file name item */
+static int write_PKIMESSAGE(const OSSL_CMP_MSG *msg, char **filenames)
+{
+    char *file;
+    BIO *bio;
+
+    if (msg == NULL || filenames == NULL) {
+        CMP_err(&quot;NULL arg to write_PKIMESSAGE&quot;);
+        return 0;
+    }
+    if (*filenames == NULL) {
+        CMP_err(&quot;Not enough file names provided for writing PKIMessage&quot;);
+        return 0;
+    }
+
+    file = *filenames;
+    *filenames = next_item(file);
+    bio = BIO_new_file(file, &quot;wb&quot;);
+    if (bio == NULL) {
+        CMP_err1(&quot;Cannot open file '%s' for writing&quot;, file);
+        return 0;
+    }
+    if (i2d_OSSL_CMP_MSG_bio(bio, msg) &lt; 0) {
+        CMP_err1(&quot;Cannot write PKIMessage to file '%s'&quot;, file);
+        BIO_free(bio);
+        return 0;
+    }
+    BIO_free(bio);
+    return 1;
+}
+
+/* read DER-encoded OSSL_CMP_MSG from the specified file name item */
+static OSSL_CMP_MSG *read_PKIMESSAGE(char **filenames)
+{
+    char *file;
+    BIO *bio;
+    OSSL_CMP_MSG *ret;
+
+    if (filenames == NULL) {
+        CMP_err(&quot;NULL arg to read_PKIMESSAGE&quot;);
+        return NULL;
+    }
+    if (*filenames == NULL) {
+        CMP_err(&quot;Not enough file names provided for reading PKIMessage&quot;);
+        return NULL;
+    }
+
+    file = *filenames;
+    *filenames = next_item(file);
+    bio = BIO_new_file(file, &quot;rb&quot;);
+    if (bio == NULL) {
+        CMP_err1(&quot;Cannot open file '%s' for reading&quot;, file);
+        return NULL;
+    }
+    ret = d2i_OSSL_CMP_MSG_bio(bio, NULL);
+    if (ret == NULL)
+        CMP_err1(&quot;Cannot read PKIMessage from file '%s'&quot;, file);
+    BIO_free(bio);
+    return ret;
+}
+
+/*-
+ * Sends the PKIMessage req and on success place the response in *res
+ * basically like OSSL_CMP_MSG_http_perform(), but in addition allows
+ * to dump the sequence of requests and responses to files and/or
+ * to take the sequence of requests and responses from files.
+ */
+static OSSL_CMP_MSG *read_write_req_resp(OSSL_CMP_CTX *ctx,
+                                         const OSSL_CMP_MSG *req)
+{
+    OSSL_CMP_MSG *req_new = NULL;
+    OSSL_CMP_MSG *res = NULL;
+    OSSL_CMP_PKIHEADER *hdr;
+
+    if (req != NULL &amp;&amp; opt_reqout != NULL
+            &amp;&amp; !write_PKIMESSAGE(req, &amp;opt_reqout))
+        goto err;
+    if (opt_reqin != NULL &amp;&amp; opt_rspin == NULL) {
+        if ((req_new = read_PKIMESSAGE(&amp;opt_reqin)) == NULL)
+            goto err;
+        /*-
+         * The transaction ID in req_new read from opt_reqin may not be fresh.
+         * In this case the server may complain &quot;Transaction id already in use.&quot;
+         * The following workaround unfortunately requires re-protection.
+         */
+        if (opt_reqin_new_tid
+                &amp;&amp; !OSSL_CMP_MSG_update_transactionID(ctx, req_new))
+            goto err;
+    }
+
+    if (opt_rspin != NULL) {
+        res = read_PKIMESSAGE(&amp;opt_rspin);
+    } else {
+        const OSSL_CMP_MSG *actual_req = opt_reqin != NULL ? req_new : req;
+
+        res = opt_use_mock_srv
+            ? OSSL_CMP_CTX_server_perform(ctx, actual_req)
+            : OSSL_CMP_MSG_http_perform(ctx, actual_req);
+    }
+    if (res == NULL)
+        goto err;
+
+    if (opt_reqin != NULL || opt_rspin != NULL) {
+        /* need to satisfy nonce and transactionID checks */
+        ASN1_OCTET_STRING *nonce;
+        ASN1_OCTET_STRING *tid;
+
+        hdr = OSSL_CMP_MSG_get0_header(res);
+        nonce = OSSL_CMP_HDR_get0_recipNonce(hdr);
+        tid = OSSL_CMP_HDR_get0_transactionID(hdr);
+        if (!OSSL_CMP_CTX_set1_senderNonce(ctx, nonce)
+                || !OSSL_CMP_CTX_set1_transactionID(ctx, tid)) {
+            OSSL_CMP_MSG_free(res);
+            res = NULL;
+            goto err;
+        }
+    }
+
+    if (opt_rspout != NULL &amp;&amp; !write_PKIMESSAGE(res, &amp;opt_rspout)) {
+        OSSL_CMP_MSG_free(res);
+        res = NULL;
+    }
+
+ err:
+    OSSL_CMP_MSG_free(req_new);
+    return res;
+}
+
+/*
+ * parse string as integer value, not allowing trailing garbage, see also
+ * <A HREF="https://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html">https://www.gnu.org/software/libc/manual/html_node/Parsing-of-Integers.html</A>
+ *
+ * returns integer value, or INT_MIN on error
+ */
+static int atoint(const char *str)
+{
+    char *tailptr;
+    long res = strtol(str, &amp;tailptr, 10);
+
+    if  ((*tailptr != '\0') || (res &lt; INT_MIN) || (res &gt; INT_MAX))
+        return INT_MIN;
+    else
+        return (int)res;
+}
+
+static int parse_addr(char **opt_string, int port, const char *name)
+{
+    char *port_string;
+
+    if (strncasecmp(*opt_string, OSSL_HTTP_PREFIX,
+                    strlen(OSSL_HTTP_PREFIX)) == 0) {
+        *opt_string += strlen(OSSL_HTTP_PREFIX);
+    } else if (strncasecmp(*opt_string, OSSL_HTTPS_PREFIX,
+                           strlen(OSSL_HTTPS_PREFIX)) == 0) {
+        *opt_string += strlen(OSSL_HTTPS_PREFIX);
+        if (port == 0)
+            port = 443; /* == integer value of OSSL_HTTPS_PORT */
+    }
+
+    if ((port_string = strrchr(*opt_string, ':')) == NULL)
+        return port; /* using default */
+    *(port_string++) = '\0';
+    port = atoint(port_string);
+    if ((port &lt;= 0) || (port &gt; 65535)) {
+        CMP_err2(&quot;invalid %s port '%s' given, sane range 1-65535&quot;,
+                 name, port_string);
+        return -1;
+    }
+    return port;
+}
+
+static int set1_store_parameters(X509_STORE *ts)
+{
+    if (ts == NULL)
+        return 0;
+
+    /* copy vpm to store */
+    if (!X509_STORE_set1_param(ts, vpm /* may be NULL */)) {
+        BIO_printf(bio_err, &quot;error setting verification parameters\n&quot;);
+        OSSL_CMP_CTX_print_errors(cmp_ctx);
+        return 0;
+    }
+
+    X509_STORE_set_verify_cb(ts, X509_STORE_CTX_print_verify_cb);
+
+    return 1;
+}
+
+static int set_name(const char *str,
+                    int (*set_fn) (OSSL_CMP_CTX *ctx, const X509_NAME *name),
+                    OSSL_CMP_CTX *ctx, const char *desc)
+{
+    if (str != NULL) {
+        X509_NAME *n = parse_name(str, MBSTRING_ASC, 0);
+
+        if (n == NULL) {
+            CMP_err2(&quot;cannot parse %s DN '%s'&quot;, desc, str);
+            return 0;
+        }
+        if (!(*set_fn) (ctx, n)) {
+            X509_NAME_free(n);
+            CMP_err(&quot;out of memory&quot;);
+            return 0;
+        }
+        X509_NAME_free(n);
+    }
+    return 1;
+}
+
+static int set_gennames(OSSL_CMP_CTX *ctx, char *names, const char *desc)
+{
+    char *next;
+
+    for (; names != NULL; names = next) {
+        GENERAL_NAME *n;
+
+        next = next_item(names);
+        if (strcmp(names, &quot;critical&quot;) == 0) {
+            (void)OSSL_CMP_CTX_set_option(ctx,
+                                          OSSL_CMP_OPT_SUBJECTALTNAME_CRITICAL,
+                                          1);
+            continue;
+        }
+
+        /* try IP address first, then URI or domain name */
+        (void)ERR_set_mark();
+        n = a2i_GENERAL_NAME(NULL, NULL, NULL, GEN_IPADD, names, 0);
+        if (n == NULL)
+            n = a2i_GENERAL_NAME(NULL, NULL, NULL,
+                                 strchr(names, ':') != NULL ? GEN_URI : GEN_DNS,
+                                 names, 0);
+        (void)ERR_pop_to_mark();
+
+        if (n == NULL) {
+            CMP_err2(&quot;bad syntax of %s '%s'&quot;, desc, names);
+            return 0;
+        }
+        if (!OSSL_CMP_CTX_push1_subjectAltName(ctx, n)) {
+            GENERAL_NAME_free(n);
+            CMP_err(&quot;out of memory&quot;);
+            return 0;
+        }
+        GENERAL_NAME_free(n);
+    }
+    return 1;
+}
+
+/* TODO potentially move to apps/lib/apps.c */
+/*
+ * create cert store structure with certificates read from given file(s)
+ * returns pointer to created X509_STORE on success, NULL on error
+ */
+static X509_STORE *load_certstore(char *input, const char *desc)
+{
+    X509_STORE *store = NULL;
+    STACK_OF(X509) *certs = NULL;
+
+    if (input == NULL)
+        goto err;
+
+    while (input != NULL) {
+        char *next = next_item(input);           \
+
+        if (!load_certs_autofmt(input, &amp;certs, 1, opt_otherpass, desc)
+                || !(store = sk_X509_to_store(store, certs))) {
+            /* CMP_err(&quot;out of memory&quot;); */
+            X509_STORE_free(store);
+            store = NULL;
+            goto err;
+        }
+        sk_X509_pop_free(certs, X509_free);
+        certs = NULL;
+        input = next;
+    }
+ err:
+    sk_X509_pop_free(certs, X509_free);
+    return store;
+}
+
+/* TODO potentially move to apps/lib/apps.c */
+static STACK_OF(X509) *load_certs_multifile(char *files,
+                                            const char *pass, const char *desc)
+{
+    STACK_OF(X509) *certs = NULL;
+    STACK_OF(X509) *result = sk_X509_new_null();
+
+    if (files == NULL)
+        goto err;
+    if (result == NULL)
+        goto oom;
+
+    while (files != NULL) {
+        char *next = next_item(files);
+
+        if (!load_certs_autofmt(files, &amp;certs, 0, pass, desc))
+            goto err;
+        if (!sk_X509_add1_certs(result, certs, 0, 1 /* no dups */, 0))
+            goto oom;
+        sk_X509_pop_free(certs, X509_free);
+        certs = NULL;
+        files = next;
+    }
+    return result;
+
+ oom:
+    BIO_printf(bio_err, &quot;out of memory\n&quot;);
+ err:
+    sk_X509_pop_free(certs, X509_free);
+    sk_X509_pop_free(result, X509_free);
+    return NULL;
+}
+
+typedef int (*add_X509_stack_fn_t)(void *ctx, const STACK_OF(X509) *certs);
+typedef int (*add_X509_fn_t)(void *ctx, const X509 *cert);
+
+static int setup_certs(char *files, const char *desc, void *ctx,
+                       add_X509_stack_fn_t addn_fn, add_X509_fn_t add1_fn)
+{
+    int ret = 1;
+
+    if (files != NULL) {
+        STACK_OF(X509) *certs = load_certs_multifile(files, opt_otherpass,
+                                                     desc);
+        if (certs == NULL) {
+            ret = 0;
+        } else {
+            if (addn_fn != NULL) {
+                ret = (*addn_fn)(ctx, certs);
+            } else {
+                int i;
+
+                for (i = 0; i &lt; sk_X509_num(certs /* may be NULL */); i++)
+                    ret &amp;= (*add1_fn)(ctx, sk_X509_value(certs, i));
+            }
+            sk_X509_pop_free(certs, X509_free);
+        }
+    }
+    return ret;
+}
+
+
+/*
+ * parse and transform some options, checking their syntax.
+ * Returns 1 on success, 0 on error
+ */
+static int transform_opts(void)
+{
+    if (opt_cmd_s != NULL) {
+        if (!strcmp(opt_cmd_s, &quot;ir&quot;)) {
+            opt_cmd = CMP_IR;
+        } else if (!strcmp(opt_cmd_s, &quot;kur&quot;)) {
+            opt_cmd = CMP_KUR;
+        } else if (!strcmp(opt_cmd_s, &quot;cr&quot;)) {
+            opt_cmd = CMP_CR;
+        } else if (!strcmp(opt_cmd_s, &quot;p10cr&quot;)) {
+            opt_cmd = CMP_P10CR;
+        } else if (!strcmp(opt_cmd_s, &quot;rr&quot;)) {
+            opt_cmd = CMP_RR;
+        } else if (!strcmp(opt_cmd_s, &quot;genm&quot;)) {
+            opt_cmd = CMP_GENM;
+        } else {
+            CMP_err1(&quot;unknown cmp command '%s'&quot;, opt_cmd_s);
+            return 0;
+        }
+    } else {
+        CMP_err(&quot;no cmp command to execute&quot;);
+        return 0;
+    }
+
+#ifdef OPENSSL_NO_ENGINE
+# define FORMAT_OPTIONS (OPT_FMT_PEMDER | OPT_FMT_PKCS12 | OPT_FMT_ENGINE)
+#else
+# define FORMAT_OPTIONS (OPT_FMT_PEMDER | OPT_FMT_PKCS12)
+#endif
+
+    if (opt_keyform_s != NULL
+            &amp;&amp; !opt_format(opt_keyform_s, FORMAT_OPTIONS, &amp;opt_keyform)) {
+        CMP_err(&quot;unknown option given for key loading format&quot;);
+        return 0;
+    }
+
+#undef FORMAT_OPTIONS
+
+    if (opt_certform_s != NULL
+            &amp;&amp; !opt_format(opt_certform_s, OPT_FMT_PEMDER, &amp;opt_certform)) {
+        CMP_err(&quot;unknown option given for certificate storing format&quot;);
+        return 0;
+    }
+
+    if (opt_certsform_s != NULL
+            &amp;&amp; !opt_format(opt_certsform_s, OPT_FMT_PEMDER | OPT_FMT_PKCS12,
+                           &amp;opt_certsform)) {
+        CMP_err(&quot;unknown option given for certificate list loading format&quot;);
+        return 0;
+    }
+
+    return 1;
+}
+
+static OSSL_CMP_SRV_CTX *setup_srv_ctx(ENGINE *e)
+{
+    OSSL_CMP_CTX *ctx; /* extra CMP (client) ctx partly used by server */
+    OSSL_CMP_SRV_CTX *srv_ctx = ossl_cmp_mock_srv_new();
+
+    if (srv_ctx == NULL)
+        return NULL;
+    ctx = OSSL_CMP_SRV_CTX_get0_cmp_ctx(srv_ctx);
+
+    if (opt_srv_ref == NULL) {
+        if (opt_srv_cert == NULL) {
+            /* opt_srv_cert should determine the sender */
+            CMP_err(&quot;must give -srv_ref for server if no -srv_cert given&quot;);
+            goto err;
+        }
+    } else {
+        if (!OSSL_CMP_CTX_set1_referenceValue(ctx, (unsigned char *)opt_srv_ref,
+                                              strlen(opt_srv_ref)))
+            goto err;
+    }
+
+    if (opt_srv_secret != NULL) {
+        int res;
+        char *pass_str = get_passwd(opt_srv_secret, &quot;PBMAC secret of server&quot;);
+
+        if (pass_str != NULL) {
+            cleanse(opt_srv_secret);
+            res = OSSL_CMP_CTX_set1_secretValue(ctx, (unsigned char *)pass_str,
+                                                strlen(pass_str));
+            clear_free(pass_str);
+            if (res == 0)
+                goto err;
+        }
+    } else if (opt_srv_cert == NULL) {
+        CMP_err(&quot;server credentials must be given if -use_mock_srv or -port is used&quot;);
+        goto err;
+    } else {
+        CMP_warn(&quot;server will not be able to handle PBM-protected requests since -srv_secret is not given&quot;);
+    }
+
+    if (opt_srv_secret == NULL
+            &amp;&amp; ((opt_srv_cert == NULL) != (opt_srv_key == NULL))) {
+        CMP_err(&quot;must give both -srv_cert and -srv_key options or neither&quot;);
+        goto err;
+    }
+    if (opt_srv_cert != NULL) {
+        X509 *srv_cert = load_cert_pwd(opt_srv_cert, opt_srv_keypass,
+                                       &quot;certificate of the server&quot;);
+
+        if (srv_cert == NULL || !OSSL_CMP_CTX_set1_cert(ctx, srv_cert)) {
+            X509_free(srv_cert);
+            goto err;
+        }
+        X509_free(srv_cert);
+    }
+    if (opt_srv_key != NULL) {
+        EVP_PKEY *pkey = load_key_pwd(opt_srv_key, opt_keyform,
+                                      opt_srv_keypass,
+                                      e, &quot;private key for server cert&quot;);
+
+        if (pkey == NULL || !OSSL_CMP_CTX_set1_pkey(ctx, pkey)) {
+            EVP_PKEY_free(pkey);
+            goto err;
+        }
+        EVP_PKEY_free(pkey);
+    }
+    cleanse(opt_srv_keypass);
+
+    if (opt_srv_trusted != NULL) {
+        X509_STORE *ts =
+            load_certstore(opt_srv_trusted, &quot;certificates trusted by server&quot;);
+
+        if (ts == NULL)
+            goto err;
+        if (!set1_store_parameters(ts)
+                || !truststore_set_host_etc(ts, NULL)
+                || !OSSL_CMP_CTX_set0_trustedStore(ctx, ts)) {
+            X509_STORE_free(ts);
+            goto err;
+        }
+    } else {
+        CMP_warn(&quot;server will not be able to handle signature-protected requests since -srv_trusted is not given&quot;);
+    }
+    if (!setup_certs(opt_srv_untrusted, &quot;untrusted certificates&quot;, ctx,
+                     (add_X509_stack_fn_t)OSSL_CMP_CTX_set1_untrusted_certs,
+                     NULL))
+        goto err;
+
+    if (opt_rsp_cert == NULL) {
+        CMP_err(&quot;must give -rsp_cert for mock server&quot;);
+        goto err;
+    } else {
+        X509 *cert = load_cert_pwd(opt_rsp_cert, opt_keypass,
+                                   &quot;cert to be returned by the mock server&quot;);
+
+        if (cert == NULL)
+            goto err;
+        /* from server perspective the server is the client */
+        if (!ossl_cmp_mock_srv_set1_certOut(srv_ctx, cert)) {
+            X509_free(cert);
+            goto err;
+        }
+        X509_free(cert);
+    }
+    /* TODO find a cleaner solution not requiring type casts */
+    if (!setup_certs(opt_rsp_extracerts,
+                     &quot;CMP extra certificates for mock server&quot;, srv_ctx,
+                     (add_X509_stack_fn_t)ossl_cmp_mock_srv_set1_chainOut,
+                     NULL))
+        goto err;
+    if (!setup_certs(opt_rsp_capubs, &quot;caPubs for mock server&quot;, srv_ctx,
+                     (add_X509_stack_fn_t)ossl_cmp_mock_srv_set1_caPubsOut,
+                     NULL))
+        goto err;
+    (void)ossl_cmp_mock_srv_set_pollCount(srv_ctx, opt_poll_count);
+    (void)ossl_cmp_mock_srv_set_checkAfterTime(srv_ctx, opt_check_after);
+    if (opt_grant_implicitconf)
+        (void)OSSL_CMP_SRV_CTX_set_grant_implicit_confirm(srv_ctx, 1);
+
+    if (opt_failure != INT_MIN) { /* option has been set explicity */
+        if (opt_failure &lt; 0 || OSSL_CMP_PKIFAILUREINFO_MAX &lt; opt_failure) {
+            CMP_err1(&quot;-failure out of range, should be &gt;= 0 and &lt;= %d&quot;,
+                     OSSL_CMP_PKIFAILUREINFO_MAX);
+            goto err;
+        }
+        if (opt_failurebits != 0)
+            CMP_warn(&quot;-failurebits overrides -failure&quot;);
+        else
+            opt_failurebits = 1 &lt;&lt; opt_failure;
+    }
+    if ((unsigned)opt_failurebits &gt; OSSL_CMP_PKIFAILUREINFO_MAX_BIT_PATTERN) {
+        CMP_err(&quot;-failurebits out of range&quot;);
+        goto err;
+    }
+    if (!ossl_cmp_mock_srv_set_statusInfo(srv_ctx, opt_pkistatus,
+                                          opt_failurebits, opt_statusstring))
+        goto err;
+
+    if (opt_send_error)
+        (void)ossl_cmp_mock_srv_set_send_error(srv_ctx, 1);
+
+    if (opt_send_unprotected)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_UNPROTECTED_SEND, 1);
+    if (opt_send_unprot_err)
+        (void)OSSL_CMP_SRV_CTX_set_send_unprotected_errors(srv_ctx, 1);
+    if (opt_accept_unprotected)
+        (void)OSSL_CMP_SRV_CTX_set_accept_unprotected(srv_ctx, 1);
+    if (opt_accept_unprot_err)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_UNPROTECTED_ERRORS, 1);
+    if (opt_accept_raverified)
+        (void)OSSL_CMP_SRV_CTX_set_accept_raverified(srv_ctx, 1);
+
+    return srv_ctx;
+
+ err:
+    ossl_cmp_mock_srv_free(srv_ctx);
+    return NULL;
+}
+
+/*
+ * set up verification aspects of OSSL_CMP_CTX w.r.t. opts from config file/CLI.
+ * Returns pointer on success, NULL on error
+ */
+static int setup_verification_ctx(OSSL_CMP_CTX *ctx)
+{
+    if (!setup_certs(opt_untrusted, &quot;untrusted certificates&quot;, ctx,
+                     (add_X509_stack_fn_t)OSSL_CMP_CTX_set1_untrusted_certs,
+                     NULL))
+        goto err;
+
+    if (opt_srvcert != NULL || opt_trusted != NULL) {
+        X509_STORE *ts = NULL;
+
+        if (opt_srvcert != NULL) {
+            X509 *srvcert;
+
+            if (opt_trusted != NULL) {
+                CMP_warn(&quot;-trusted option is ignored since -srvcert option is present&quot;);
+                opt_trusted = NULL;
+            }
+            if (opt_recipient != NULL) {
+                CMP_warn(&quot;-recipient option is ignored since -srvcert option is present&quot;);
+                opt_recipient = NULL;
+            }
+            srvcert = load_cert_pwd(opt_srvcert, opt_otherpass,
+                                    &quot;directly trusted CMP server certificate&quot;);
+            if (srvcert == NULL)
+                /*
+                 * opt_otherpass is needed in case
+                 * opt_srvcert is an encrypted PKCS#12 file
+                 */
+                goto err;
+            if (!OSSL_CMP_CTX_set1_srvCert(ctx, srvcert)) {
+                X509_free(srvcert);
+                goto oom;
+            }
+            X509_free(srvcert);
+            if ((ts = X509_STORE_new()) == NULL)
+                goto oom;
+        }
+        if (opt_trusted != NULL
+                &amp;&amp; (ts = load_certstore(opt_trusted, &quot;trusted certificates&quot;))
+            == NULL)
+            goto err;
+        if (!set1_store_parameters(ts) /* also copies vpm */
+                /*
+                 * clear any expected host/ip/email address;
+                 * opt_expect_sender is used instead
+                 */
+                || !truststore_set_host_etc(ts, NULL)
+                || !OSSL_CMP_CTX_set0_trustedStore(ctx, ts)) {
+            X509_STORE_free(ts);
+            goto oom;
+        }
+    }
+
+    if (opt_ignore_keyusage)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_IGNORE_KEYUSAGE, 1);
+
+    if (opt_unprotected_errors)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_UNPROTECTED_ERRORS, 1);
+
+    if (opt_out_trusted != NULL) { /* for use in OSSL_CMP_certConf_cb() */
+        X509_VERIFY_PARAM *out_vpm = NULL;
+        X509_STORE *out_trusted =
+            load_certstore(opt_out_trusted,
+                           &quot;trusted certs for verifying newly enrolled cert&quot;);
+
+        if (out_trusted == NULL)
+            goto err;
+        /* any -verify_hostname, -verify_ip, and -verify_email apply here */
+        if (!set1_store_parameters(out_trusted))
+            goto oom;
+        /* ignore any -attime here, new certs are current anyway */
+        out_vpm = X509_STORE_get0_param(out_trusted);
+        X509_VERIFY_PARAM_clear_flags(out_vpm, X509_V_FLAG_USE_CHECK_TIME);
+
+        (void)OSSL_CMP_CTX_set_certConf_cb_arg(ctx, out_trusted);
+    }
+
+    if (opt_disable_confirm)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_DISABLE_CONFIRM, 1);
+
+    if (opt_implicit_confirm)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_IMPLICIT_CONFIRM, 1);
+
+    (void)OSSL_CMP_CTX_set_certConf_cb(ctx, OSSL_CMP_certConf_cb);
+
+    return 1;
+
+ oom:
+    CMP_err(&quot;out of memory&quot;);
+ err:
+    return 0;
+}
+
+#ifndef OPENSSL_NO_SOCK
+/*
+ * set up ssl_ctx for the OSSL_CMP_CTX based on options from config file/CLI.
+ * Returns pointer on success, NULL on error
+ */
+static SSL_CTX *setup_ssl_ctx(OSSL_CMP_CTX *ctx, ENGINE *e)
+{
+    STACK_OF(X509) *untrusted_certs = OSSL_CMP_CTX_get0_untrusted_certs(ctx);
+    EVP_PKEY *pkey = NULL;
+    X509_STORE *trust_store = NULL;
+    SSL_CTX *ssl_ctx;
+    int i;
+
+    ssl_ctx = SSL_CTX_new(TLS_client_method());
+    if (ssl_ctx == NULL)
+        return NULL;
+
+    SSL_CTX_set_mode(ssl_ctx, SSL_MODE_AUTO_RETRY);
+
+    if (opt_tls_trusted != NULL) {
+        if ((trust_store = load_certstore(opt_tls_trusted,
+                                          &quot;trusted TLS certificates&quot;)) == NULL)
+            goto err;
+        SSL_CTX_set_cert_store(ssl_ctx, trust_store);
+        /* for improved diagnostics on SSL_CTX_build_cert_chain() errors: */
+        X509_STORE_set_verify_cb(trust_store, X509_STORE_CTX_print_verify_cb);
+    }
+
+    if (opt_tls_cert != NULL &amp;&amp; opt_tls_key != NULL) {
+        X509 *cert;
+        STACK_OF(X509) *certs = NULL;
+
+        if (!load_certs_autofmt(opt_tls_cert, &amp;certs, 0, opt_tls_keypass,
+                                &quot;TLS client certificate (optionally with chain)&quot;))
+            /*
+             * opt_tls_keypass is needed in case opt_tls_cert is an encrypted
+             * PKCS#12 file
+             */
+            goto err;
+
+        cert = sk_X509_delete(certs, 0);
+        if (cert == NULL || SSL_CTX_use_certificate(ssl_ctx, cert) &lt;= 0) {
+            CMP_err1(&quot;unable to use client TLS certificate file '%s'&quot;,
+                     opt_tls_cert);
+            X509_free(cert);
+            sk_X509_pop_free(certs, X509_free);
+            goto err;
+        }
+        X509_free(cert); /* we do not need the handle any more */
+
+        /*
+         * Any further certs and any untrusted certs are used for constructing
+         * the client cert chain to be provided along with the TLS client cert
+         * to the TLS server.
+         */
+        if (!SSL_CTX_set0_chain(ssl_ctx, certs)) {
+            CMP_err(&quot;could not set TLS client cert chain&quot;);
+            sk_X509_pop_free(certs, X509_free);
+            goto err;
+        }
+        for (i = 0; i &lt; sk_X509_num(untrusted_certs); i++) {
+            cert = sk_X509_value(untrusted_certs, i);
+            if (!SSL_CTX_add1_chain_cert(ssl_ctx, cert)) {
+                CMP_err(&quot;could not add untrusted cert to TLS client cert chain&quot;);
+                goto err;
+            }
+        }
+        if (!SSL_CTX_build_cert_chain(ssl_ctx,
+                                      SSL_BUILD_CHAIN_FLAG_UNTRUSTED |
+                                      SSL_BUILD_CHAIN_FLAG_NO_ROOT)) {
+            CMP_warn(&quot;could not build cert chain for own TLS cert&quot;);
+            OSSL_CMP_CTX_print_errors(ctx);
+        }
+
+        /* If present we append to the list also the certs from opt_tls_extra */
+        if (opt_tls_extra != NULL) {
+            STACK_OF(X509) *tls_extra = load_certs_multifile(opt_tls_extra,
+                                                             opt_otherpass,
+                                                             &quot;extra certificates for TLS&quot;);
+            int res = 1;
+
+            if (tls_extra == NULL)
+                goto err;
+            for (i = 0; i &lt; sk_X509_num(tls_extra); i++) {
+                cert = sk_X509_value(tls_extra, i);
+                if (res != 0)
+                    res = SSL_CTX_add_extra_chain_cert(ssl_ctx, cert);
+                if (res == 0)
+                    X509_free(cert);
+            }
+            sk_X509_free(tls_extra);
+            if (res == 0) {
+                BIO_printf(bio_err, &quot;error: unable to add TLS extra certs\n&quot;);
+                goto err;
+            }
+        }
+
+        pkey = load_key_pwd(opt_tls_key, opt_keyform, opt_tls_keypass,
+                            e, &quot;TLS client private key&quot;);
+        cleanse(opt_tls_keypass);
+        if (pkey == NULL)
+            goto err;
+        /*
+         * verify the key matches the cert,
+         * not using SSL_CTX_check_private_key(ssl_ctx)
+         * because it gives poor and sometimes misleading diagnostics
+         */
+        if (!X509_check_private_key(SSL_CTX_get0_certificate(ssl_ctx),
+                                    pkey)) {
+            CMP_err2(&quot;TLS private key '%s' does not match the TLS certificate '%s'\n&quot;,
+                     opt_tls_key, opt_tls_cert);
+            EVP_PKEY_free(pkey);
+            pkey = NULL; /* otherwise, for some reason double free! */
+            goto err;
+        }
+        if (SSL_CTX_use_PrivateKey(ssl_ctx, pkey) &lt;= 0) {
+            CMP_err1(&quot;unable to use TLS client private key '%s'&quot;, opt_tls_key);
+            EVP_PKEY_free(pkey);
+            pkey = NULL; /* otherwise, for some reason double free! */
+            goto err;
+        }
+        EVP_PKEY_free(pkey); /* we do not need the handle any more */
+    }
+    if (opt_tls_trusted != NULL) {
+        /* enable and parameterize server hostname/IP address check */
+        if (!truststore_set_host_etc(trust_store,
+                                     opt_tls_host != NULL ?
+                                     opt_tls_host : opt_server))
+            /* TODO: is the server host name correct for TLS via proxy? */
+            goto err;
+        SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);
+    }
+    return ssl_ctx;
+ err:
+    SSL_CTX_free(ssl_ctx);
+    return NULL;
+}
+#endif
+
+/*
+ * set up protection aspects of OSSL_CMP_CTX based on options from config
+ * file/CLI while parsing options and checking their consistency.
+ * Returns 1 on success, 0 on error
+ */
+static int setup_protection_ctx(OSSL_CMP_CTX *ctx, ENGINE *e)
+{
+    if (!opt_unprotected_requests &amp;&amp; opt_secret == NULL &amp;&amp; opt_cert == NULL) {
+        CMP_err(&quot;must give client credentials unless -unprotected_requests is set&quot;);
+        goto err;
+    }
+
+    if (opt_ref == NULL &amp;&amp; opt_cert == NULL &amp;&amp; opt_subject == NULL) {
+        /* cert or subject should determine the sender */
+        CMP_err(&quot;must give -ref if no -cert and no -subject given&quot;);
+        goto err;
+    }
+    if (!opt_secret &amp;&amp; ((opt_cert == NULL) != (opt_key == NULL))) {
+        CMP_err(&quot;must give both -cert and -key options or neither&quot;);
+        goto err;
+    }
+    if (opt_secret != NULL) {
+        char *pass_string = get_passwd(opt_secret, &quot;PBMAC&quot;);
+        int res;
+
+        if (pass_string != NULL) {
+            cleanse(opt_secret);
+            res = OSSL_CMP_CTX_set1_secretValue(ctx,
+                                                (unsigned char *)pass_string,
+                                                strlen(pass_string));
+            clear_free(pass_string);
+            if (res == 0)
+                goto err;
+        }
+        if (opt_cert != NULL || opt_key != NULL)
+            CMP_warn(&quot;no signature-based protection used since -secret is given&quot;);
+    }
+    if (opt_ref != NULL
+            &amp;&amp; !OSSL_CMP_CTX_set1_referenceValue(ctx, (unsigned char *)opt_ref,
+                                                 strlen(opt_ref)))
+        goto err;
+
+    if (opt_key != NULL) {
+        EVP_PKEY *pkey = load_key_pwd(opt_key, opt_keyform, opt_keypass, e,
+                                      &quot;private key for CMP client certificate&quot;);
+
+        if (pkey == NULL || !OSSL_CMP_CTX_set1_pkey(ctx, pkey)) {
+            EVP_PKEY_free(pkey);
+            goto err;
+        }
+        EVP_PKEY_free(pkey);
+    }
+    if (opt_secret == NULL &amp;&amp; opt_srvcert == NULL &amp;&amp; opt_trusted == NULL) {
+        CMP_err(&quot;missing -secret or -srvcert or -trusted&quot;);
+        goto err;
+    }
+
+    if (opt_cert != NULL) {
+        X509 *cert;
+        STACK_OF(X509) *certs = NULL;
+        int ok;
+
+        if (!load_certs_autofmt(opt_cert, &amp;certs, 0, opt_keypass,
+                                &quot;CMP client certificate (and optionally extra certs)&quot;))
+            /* opt_keypass is needed if opt_cert is an encrypted PKCS#12 file */
+            goto err;
+
+        cert = sk_X509_delete(certs, 0);
+        if (cert == NULL) {
+            CMP_err(&quot;no client certificate found&quot;);
+            sk_X509_pop_free(certs, X509_free);
+            goto err;
+        }
+        ok = OSSL_CMP_CTX_set1_cert(ctx, cert);
+        X509_free(cert);
+
+        if (ok) {
+            /* add any remaining certs to the list of untrusted certs */
+            STACK_OF(X509) *untrusted = OSSL_CMP_CTX_get0_untrusted_certs(ctx);
+            ok = untrusted != NULL ?
+                sk_X509_add1_certs(untrusted, certs, 0, 1 /* no dups */, 0) :
+                OSSL_CMP_CTX_set1_untrusted_certs(ctx, certs);
+        }
+        sk_X509_pop_free(certs, X509_free);
+        if (!ok)
+            goto oom;
+    }
+
+    if (!setup_certs(opt_extracerts, &quot;extra certificates for CMP&quot;, ctx,
+                     (add_X509_stack_fn_t)OSSL_CMP_CTX_set1_extraCertsOut,
+                     NULL))
+        goto err;
+    cleanse(opt_otherpass);
+
+    if (opt_unprotected_requests)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_UNPROTECTED_SEND, 1);
+
+    if (opt_digest != NULL) {
+        int digest = OBJ_ln2nid(opt_digest);
+
+        if (digest == NID_undef) {
+            CMP_err1(&quot;digest algorithm name not recognized: '%s'&quot;, opt_digest);
+            goto err;
+        }
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_DIGEST_ALGNID, digest);
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_OWF_ALGNID, digest);
+    }
+
+    if (opt_mac != NULL) {
+        int mac = OBJ_ln2nid(opt_mac);
+        if (mac == NID_undef) {
+            CMP_err1(&quot;MAC algorithm name not recognized: '%s'&quot;, opt_mac);
+            goto err;
+        }
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_MAC_ALGNID, mac);
+    }
+    return 1;
+
+ oom:
+    CMP_err(&quot;out of memory&quot;);
+ err:
+    return 0;
+}
+
+/*
+ * set up IR/CR/KUR/CertConf/RR specific parts of the OSSL_CMP_CTX
+ * based on options from config file/CLI.
+ * Returns pointer on success, NULL on error
+ */
+static int setup_request_ctx(OSSL_CMP_CTX *ctx, ENGINE *e)
+{
+    if (opt_subject == NULL &amp;&amp; opt_oldcert == NULL &amp;&amp; opt_cert == NULL)
+        CMP_warn(&quot;no -subject given, neither -oldcert nor -cert available as default&quot;);
+    if (!set_name(opt_subject, OSSL_CMP_CTX_set1_subjectName, ctx, &quot;subject&quot;)
+            || !set_name(opt_issuer, OSSL_CMP_CTX_set1_issuer, ctx, &quot;issuer&quot;))
+        goto err;
+
+    if (opt_newkey != NULL) {
+        const char *file = opt_newkey;
+        const int format = opt_keyform;
+        const char *pass = opt_newkeypass;
+        const char *desc = &quot;new private or public key for cert to be enrolled&quot;;
+        EVP_PKEY *pkey = load_key_pwd(file, format, pass, e, NULL);
+        int priv = 1;
+
+        if (pkey == NULL) {
+            ERR_clear_error();
+            pkey = load_pubkey(file, format, 0, pass, e, desc);
+            priv = 0;
+        }
+        cleanse(opt_newkeypass);
+        if (pkey == NULL || !OSSL_CMP_CTX_set0_newPkey(ctx, priv, pkey)) {
+            EVP_PKEY_free(pkey);
+            goto err;
+        }
+    }
+
+    if (opt_days &gt; 0)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_VALIDITY_DAYS,
+                                      opt_days);
+
+    if (opt_policies != NULL &amp;&amp; opt_policy_oids != NULL) {
+        CMP_err(&quot;cannot have policies both via -policies and via -policy_oids&quot;);
+        goto err;
+    }
+
+    if (opt_reqexts != NULL || opt_policies != NULL) {
+        X509V3_CTX ext_ctx;
+        X509_EXTENSIONS *exts = sk_X509_EXTENSION_new_null();
+
+        if (exts == NULL)
+            goto err;
+        X509V3_set_ctx(&amp;ext_ctx, NULL, NULL, NULL, NULL, 0);
+        X509V3_set_nconf(&amp;ext_ctx, conf);
+        if (opt_reqexts != NULL
+            &amp;&amp; !X509V3_EXT_add_nconf_sk(conf, &amp;ext_ctx, opt_reqexts, &amp;exts)) {
+            CMP_err1(&quot;cannot load certificate request extension section '%s'&quot;,
+                     opt_reqexts);
+            sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);
+            goto err;
+        }
+        if (opt_policies != NULL
+            &amp;&amp; !X509V3_EXT_add_nconf_sk(conf, &amp;ext_ctx, opt_policies, &amp;exts)) {
+            CMP_err1(&quot;cannot load policy cert request extension section '%s'&quot;,
+                     opt_policies);
+            sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);
+            goto err;
+        }
+        OSSL_CMP_CTX_set0_reqExtensions(ctx, exts);
+    }
+    if (OSSL_CMP_CTX_reqExtensions_have_SAN(ctx) &amp;&amp; opt_sans != NULL) {
+        CMP_err(&quot;cannot have Subject Alternative Names both via -reqexts and via -sans&quot;);
+        goto err;
+    }
+
+    if (!set_gennames(ctx, opt_sans, &quot;Subject Alternative Name&quot;))
+        goto err;
+
+    if (opt_san_nodefault) {
+        if (opt_sans != NULL)
+            CMP_warn(&quot;-opt_san_nodefault has no effect when -sans is used&quot;);
+        (void)OSSL_CMP_CTX_set_option(ctx,
+                                      OSSL_CMP_OPT_SUBJECTALTNAME_NODEFAULT, 1);
+    }
+
+    if (opt_policy_oids_critical) {
+        if (opt_policy_oids == NULL)
+            CMP_warn(&quot;-opt_policy_oids_critical has no effect unless -policy_oids is given&quot;);
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_POLICIES_CRITICAL, 1);
+    }
+
+    while (opt_policy_oids != NULL) {
+        ASN1_OBJECT *policy;
+        POLICYINFO *pinfo;
+        char *next = next_item(opt_policy_oids);
+
+        if ((policy = OBJ_txt2obj(opt_policy_oids, 1)) == 0) {
+            CMP_err1(&quot;unknown policy OID '%s'&quot;, opt_policy_oids);
+            goto err;
+        }
+
+        if ((pinfo = POLICYINFO_new()) == NULL) {
+            ASN1_OBJECT_free(policy);
+            goto err;
+        }
+        pinfo-&gt;policyid = policy;
+
+        if (!OSSL_CMP_CTX_push0_policy(ctx, pinfo)) {
+            CMP_err1(&quot;cannot add policy with OID '%s'&quot;, opt_policy_oids);
+            POLICYINFO_free(pinfo);
+            goto err;
+        }
+        opt_policy_oids = next;
+    }
+
+    if (opt_popo &gt;= OSSL_CRMF_POPO_NONE)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_POPO_METHOD, opt_popo);
+
+    if (opt_csr != NULL) {
+        if (opt_cmd != CMP_P10CR) {
+            CMP_warn(&quot;-csr option is ignored for command other than p10cr&quot;);
+        } else {
+            X509_REQ *csr =
+                load_csr_autofmt(opt_csr, &quot;PKCS#10 CSR for p10cr&quot;);
+
+            if (csr == NULL)
+                goto err;
+            if (!OSSL_CMP_CTX_set1_p10CSR(ctx, csr)) {
+                X509_REQ_free(csr);
+                goto oom;
+            }
+            X509_REQ_free(csr);
+        }
+    }
+
+    if (opt_oldcert != NULL) {
+        X509 *oldcert = load_cert_pwd(opt_oldcert, opt_keypass,
+                                      &quot;certificate to be updated/revoked&quot;);
+        /* opt_keypass is needed if opt_oldcert is an encrypted PKCS#12 file */
+
+        if (oldcert == NULL)
+            goto err;
+        if (!OSSL_CMP_CTX_set1_oldCert(ctx, oldcert)) {
+            X509_free(oldcert);
+            goto oom;
+        }
+        X509_free(oldcert);
+    }
+    cleanse(opt_keypass);
+    if (opt_revreason &gt; CRL_REASON_NONE)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_REVOCATION_REASON,
+                                      opt_revreason);
+
+    return 1;
+
+ oom:
+    CMP_err(&quot;out of memory&quot;);
+ err:
+    return 0;
+}
+
+static int handle_opt_geninfo(OSSL_CMP_CTX *ctx)
+{
+    long value;
+    ASN1_OBJECT *type;
+    ASN1_INTEGER *aint;
+    ASN1_TYPE *val;
+    OSSL_CMP_ITAV *itav;
+    char *endstr;
+    char *valptr = strchr(opt_geninfo, ':');
+
+    if (valptr == NULL) {
+        CMP_err(&quot;missing ':' in -geninfo option&quot;);
+        return 0;
+    }
+    valptr[0] = '\0';
+    valptr++;
+
+    if (strncasecmp(valptr, &quot;int:&quot;, 4) != 0) {
+        CMP_err(&quot;missing 'int:' in -geninfo option&quot;);
+        return 0;
+    }
+    valptr += 4;
+
+    value = strtol(valptr, &amp;endstr, 10);
+    if (endstr == valptr || *endstr != '\0') {
+        CMP_err(&quot;cannot parse int in -geninfo option&quot;);
+        return 0;
+    }
+
+    type = OBJ_txt2obj(opt_geninfo, 1);
+    if (type == NULL) {
+        CMP_err(&quot;cannot parse OID in -geninfo option&quot;);
+        return 0;
+    }
+
+    aint = ASN1_INTEGER_new();
+    if (aint == NULL || !ASN1_INTEGER_set(aint, value))
+        goto oom;
+
+    val = ASN1_TYPE_new();
+    if (val == NULL) {
+        ASN1_INTEGER_free(aint);
+        goto oom;
+    }
+    ASN1_TYPE_set(val, V_ASN1_INTEGER, aint);
+    itav = OSSL_CMP_ITAV_create(type, val);
+    if (itav == NULL) {
+        ASN1_TYPE_free(val);
+        goto oom;
+    }
+
+    if (!OSSL_CMP_CTX_push0_geninfo_ITAV(ctx, itav)) {
+        OSSL_CMP_ITAV_free(itav);
+        return 0;
+    }
+    return 1;
+
+ oom:
+    CMP_err(&quot;out of memory&quot;);
+    return 0;
+}
+
+
+/*
+ * set up the client-side OSSL_CMP_CTX based on options from config file/CLI
+ * while parsing options and checking their consistency.
+ * Prints reason for error to bio_err.
+ * Returns 1 on success, 0 on error
+ */
+static int setup_client_ctx(OSSL_CMP_CTX *ctx, ENGINE *e)
+{
+    int ret = 0;
+    char server_buf[200] = { '\0' };
+    char proxy_buf[200] = { '\0' };
+    char *proxy_host = NULL;
+    char *proxy_port_str = NULL;
+
+    if (opt_server == NULL) {
+        CMP_err(&quot;missing server address[:port]&quot;);
+        goto err;
+    } else if ((server_port =
+                parse_addr(&amp;opt_server, server_port, &quot;server&quot;)) &lt; 0) {
+        goto err;
+    }
+    if (server_port != 0)
+        BIO_snprintf(server_port_s, sizeof(server_port_s), &quot;%d&quot;, server_port);
+    if (!OSSL_CMP_CTX_set1_server(ctx, opt_server)
+            || !OSSL_CMP_CTX_set_serverPort(ctx, server_port)
+            || !OSSL_CMP_CTX_set1_serverPath(ctx, opt_path))
+        goto oom;
+    if (opt_proxy != NULL &amp;&amp; !OSSL_CMP_CTX_set1_proxy(ctx, opt_proxy))
+        goto oom;
+    (void)BIO_snprintf(server_buf, sizeof(server_buf), &quot;http%<A HREF="s://%s%s%s/%s">s://%s%s%s/%s</A>&quot;,
+                       opt_tls_used ? &quot;s&quot; : &quot;&quot;, opt_server,
+                       server_port == 0 ? &quot;&quot; : &quot;:&quot;, server_port_s,
+                       opt_path[0] == '/' ? opt_path + 1 : opt_path);
+
+    if (opt_proxy != NULL)
+        (void)BIO_snprintf(proxy_buf, sizeof(proxy_buf), &quot; via %s&quot;, opt_proxy);
+    CMP_info2(&quot;will contact %s%s&quot;, server_buf, proxy_buf);
+
+    if (!transform_opts())
+        goto err;
+
+    if (opt_cmd == CMP_IR || opt_cmd == CMP_CR || opt_cmd == CMP_KUR) {
+        if (opt_newkey == NULL &amp;&amp; opt_key == NULL &amp;&amp; opt_csr == NULL) {
+            CMP_err(&quot;missing -newkey (or -key) to be certified&quot;);
+            goto err;
+        }
+        if (opt_certout == NULL) {
+            CMP_err(&quot;-certout not given, nowhere to save certificate&quot;);
+            goto err;
+        }
+    }
+    if (opt_cmd == CMP_KUR) {
+        char *ref_cert = opt_oldcert != NULL ? opt_oldcert : opt_cert;
+
+        if (ref_cert == NULL) {
+            CMP_err(&quot;missing -oldcert option for certificate to be updated&quot;);
+            goto err;
+        }
+        if (opt_subject != NULL)
+            CMP_warn2(&quot;-subject '%s' given, which overrides the subject of '%s' in KUR&quot;,
+                      opt_subject, ref_cert);
+    }
+    if (opt_cmd == CMP_RR &amp;&amp; opt_oldcert == NULL) {
+        CMP_err(&quot;missing certificate to be revoked&quot;);
+        goto err;
+    }
+    if (opt_cmd == CMP_P10CR &amp;&amp; opt_csr == NULL) {
+        CMP_err(&quot;missing PKCS#10 CSR for p10cr&quot;);
+        goto err;
+    }
+
+    if (opt_recipient == NULL &amp;&amp; opt_srvcert == NULL &amp;&amp; opt_issuer == NULL
+            &amp;&amp; opt_oldcert == NULL &amp;&amp; opt_cert == NULL)
+        CMP_warn(&quot;missing -recipient, -srvcert, -issuer, -oldcert or -cert; recipient will be set to \&quot;NULL-DN\&quot;&quot;);
+
+    if (opt_infotype_s != NULL) {
+        char id_buf[100] = &quot;id-it-&quot;;
+
+        strncat(id_buf, opt_infotype_s, sizeof(id_buf) - strlen(id_buf) - 1);
+        if ((opt_infotype = OBJ_sn2nid(id_buf)) == NID_undef) {
+            CMP_err(&quot;unknown OID name in -infotype option&quot;);
+            goto err;
+        }
+    }
+
+    if (!setup_verification_ctx(ctx))
+        goto err;
+
+    if (opt_msg_timeout &gt;= 0) /* must do this before setup_ssl_ctx() */
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_MSG_TIMEOUT,
+                                      opt_msg_timeout);
+    if (opt_total_timeout &gt;= 0)
+        (void)OSSL_CMP_CTX_set_option(ctx, OSSL_CMP_OPT_TOTAL_TIMEOUT,
+                                      opt_total_timeout);
+
+    if (opt_reqin != NULL &amp;&amp; opt_rspin != NULL)
+        CMP_warn(&quot;-reqin is ignored since -rspin is present&quot;);
+    if (opt_reqin_new_tid &amp;&amp; opt_reqin == NULL)
+        CMP_warn(&quot;-reqin_new_tid is ignored since -reqin is not present&quot;);
+    if (opt_reqin != NULL || opt_reqout != NULL
+            || opt_rspin != NULL || opt_rspout != NULL || opt_use_mock_srv)
+        (void)OSSL_CMP_CTX_set_transfer_cb(ctx, read_write_req_resp);
+
+    if ((opt_tls_cert != NULL || opt_tls_key != NULL
+         || opt_tls_keypass != NULL || opt_tls_extra != NULL
+         || opt_tls_trusted != NULL || opt_tls_host != NULL)
+            &amp;&amp; !opt_tls_used)
+        CMP_warn(&quot;TLS options(s) given but not -tls_used&quot;);
+    if (opt_tls_used) {
+#ifdef OPENSSL_NO_SOCK
+        BIO_printf(bio_err, &quot;Cannot use TLS - sockets not supported\n&quot;);
+        goto err;
+#else
+        APP_HTTP_TLS_INFO *info;
+
+        if (opt_tls_cert != NULL
+            || opt_tls_key != NULL || opt_tls_keypass != NULL) {
+            if (opt_tls_key == NULL) {
+                CMP_err(&quot;missing -tls_key option&quot;);
+                goto err;
+            } else if (opt_tls_cert == NULL) {
+                CMP_err(&quot;missing -tls_cert option&quot;);
+                goto err;
+            }
+        }
+        if (opt_use_mock_srv) {
+            CMP_err(&quot;cannot use TLS options together with -use_mock_srv&quot;);
+            goto err;
+        }
+        if ((info = OPENSSL_zalloc(sizeof(*info))) == NULL)
+            goto err;
+        (void)OSSL_CMP_CTX_set_http_cb_arg(ctx, info);
+        /* info will be freed along with CMP ctx */
+        info-&gt;server = opt_server;
+        info-&gt;port = server_port_s;
+        info-&gt;use_proxy = opt_proxy != NULL;
+        info-&gt;timeout = OSSL_CMP_CTX_get_option(ctx, OSSL_CMP_OPT_MSG_TIMEOUT);
+        info-&gt;ssl_ctx = setup_ssl_ctx(ctx, e);
+        if (info-&gt;ssl_ctx == NULL)
+            goto err;
+        (void)OSSL_CMP_CTX_set_http_cb(ctx, app_http_tls_cb);
+#endif
+    }
+
+    if (!setup_protection_ctx(ctx, e))
+        goto err;
+
+    if (!setup_request_ctx(ctx, e))
+        goto err;
+
+    if (!set_name(opt_recipient, OSSL_CMP_CTX_set1_recipient, ctx, &quot;recipient&quot;)
+            || !set_name(opt_expect_sender, OSSL_CMP_CTX_set1_expected_sender,
+                         ctx, &quot;expected sender&quot;))
+        goto oom;
+
+    if (opt_geninfo != NULL &amp;&amp; !handle_opt_geninfo(ctx))
+        goto err;
+
+    ret = 1;
+
+ err:
+    OPENSSL_free(proxy_host);
+    OPENSSL_free(proxy_port_str);
+    return ret;
+ oom:
+    CMP_err(&quot;out of memory&quot;);
+    goto err;
+}
+
+/*
+ * write out the given certificate to the output specified by bio.
+ * Depending on options use either PEM or DER format.
+ * Returns 1 on success, 0 on error
+ */
+static int write_cert(BIO *bio, X509 *cert)
+{
+    if ((opt_certform == FORMAT_PEM &amp;&amp; PEM_write_bio_X509(bio, cert))
+            || (opt_certform == FORMAT_ASN1 &amp;&amp; i2d_X509_bio(bio, cert)))
+        return 1;
+    if (opt_certform != FORMAT_PEM &amp;&amp; opt_certform != FORMAT_ASN1)
+        BIO_printf(bio_err,
+                   &quot;error: unsupported type '%s' for writing certificates\n&quot;,
+                   opt_certform_s);
+    return 0;
+}
+
+/*
+ * writes out a stack of certs to the given file.
+ * Depending on options use either PEM or DER format,
+ * where DER does not make much sense for writing more than one cert!
+ * Returns number of written certificates on success, 0 on error.
+ */
+static int save_certs(OSSL_CMP_CTX *ctx,
+                      STACK_OF(X509) *certs, char *destFile, char *desc)
+{
+    BIO *bio = NULL;
+    int i;
+    int n = sk_X509_num(certs);
+
+    CMP_info3(&quot;received %d %s certificate(s), saving to file '%s'&quot;,
+              n, desc, destFile);
+    if (n &gt; 1 &amp;&amp; opt_certform != FORMAT_PEM)
+        CMP_warn(&quot;saving more than one certificate in non-PEM format&quot;);
+
+    if (destFile == NULL || (bio = BIO_new(BIO_s_file())) == NULL
+            || !BIO_write_filename(bio, (char *)destFile)) {
+        CMP_err1(&quot;could not open file '%s' for writing&quot;, destFile);
+        n = -1;
+        goto err;
+    }
+
+    for (i = 0; i &lt; n; i++) {
+        if (!write_cert(bio, sk_X509_value(certs, i))) {
+            CMP_err1(&quot;cannot write certificate to file '%s'&quot;, destFile);
+            n = -1;
+            goto err;
+        }
+    }
+
+ err:
+    BIO_free(bio);
+    return n;
+}
+
+static void print_itavs(STACK_OF(OSSL_CMP_ITAV) *itavs)
+{
+    OSSL_CMP_ITAV *itav = NULL;
+    char buf[128];
+    int i;
+    int n = sk_OSSL_CMP_ITAV_num(itavs); /* itavs == NULL leads to 0 */
+
+    if (n == 0) {
+        CMP_info(&quot;genp contains no ITAV&quot;);
+        return;
+    }
+
+    for (i = 0; i &lt; n; i++) {
+        itav = sk_OSSL_CMP_ITAV_value(itavs, i);
+        OBJ_obj2txt(buf, 128, OSSL_CMP_ITAV_get0_type(itav), 0);
+        CMP_info1(&quot;genp contains ITAV of type: %s&quot;, buf);
+    }
+}
+
+static char opt_item[SECTION_NAME_MAX + 1];
+/* get previous name from a comma-separated list of names */
+static const char *prev_item(const char *opt, const char *end)
+{
+    const char *beg;
+    size_t len;
+
+    if (end == opt)
+        return NULL;
+    beg = end;
+    while (beg != opt &amp;&amp; beg[-1] != ',' &amp;&amp; !isspace(beg[-1]))
+        beg--;
+    len = end - beg;
+    if (len &gt; SECTION_NAME_MAX)
+        len = SECTION_NAME_MAX;
+    strncpy(opt_item, beg, len);
+    opt_item[SECTION_NAME_MAX] = '\0'; /* avoid gcc v8 O3 stringop-truncation */
+    opt_item[len] = '\0';
+    if (len &gt; SECTION_NAME_MAX)
+        CMP_warn2(&quot;using only first %d characters of section name starting with \&quot;%s\&quot;&quot;,
+                  SECTION_NAME_MAX, opt_item);
+    while (beg != opt &amp;&amp; (beg[-1] == ',' || isspace(beg[-1])))
+        beg--;
+    return beg;
+}
+
+/* get str value for name from a comma-separated hierarchy of config sections */
+static char *conf_get_string(const CONF *src_conf, const char *groups,
+                             const char *name)
+{
+    char *res = NULL;
+    const char *end = groups + strlen(groups);
+
+    while ((end = prev_item(groups, end)) != NULL) {
+        if ((res = NCONF_get_string(src_conf, opt_item, name)) != NULL)
+            return res;
+    }
+    return res;
+}
+
+/* get long val for name from a comma-separated hierarchy of config sections */
+static int conf_get_number_e(const CONF *conf_, const char *groups,
+                             const char *name, long *result)
+{
+    char *str = conf_get_string(conf_, groups, name);
+    char *tailptr;
+    long res;
+
+    if (str == NULL || *str == '\0')
+        return 0;
+
+    res = strtol(str, &amp;tailptr, 10);
+    if (res == LONG_MIN || res == LONG_MAX || *tailptr != '\0')
+        return 0;
+
+    *result = res;
+    return 1;
+}
+
+/*
+ * use the command line option table to read values from the CMP section
+ * of openssl.cnf.  Defaults are taken from the config file, they can be
+ * overwritten on the command line.
+ */
+static int read_config(void)
+{
+    unsigned int i;
+    long num = 0;
+    char *txt = NULL;
+    const OPTIONS *opt;
+    int provider_option;
+    int verification_option;
+
+    /*
+     * starting with offset OPT_SECTION because OPT_CONFIG and OPT_SECTION would
+     * not make sense within the config file. They have already been handled.
+     */
+    for (i = OPT_SECTION - OPT_HELP, opt = &amp;cmp_options[OPT_SECTION];
+         opt-&gt;name; i++, opt++) {
+        if (!strcmp(opt-&gt;name, OPT_SECTION_STR)
+                || !strcmp(opt-&gt;name, OPT_MORE_STR)) {
+            i--;
+            continue;
+        }
+        provider_option = (OPT_PROV__FIRST &lt;= opt-&gt;retval
+                               &amp;&amp; opt-&gt;retval &lt; OPT_PROV__LAST);
+        verification_option = (OPT_V__FIRST &lt;= opt-&gt;retval
+                                   &amp;&amp; opt-&gt;retval &lt; OPT_V__LAST);
+        if (provider_option || verification_option)
+            i--;
+        if (cmp_vars[i].txt == NULL) {
+            CMP_err1(&quot;internal: cmp_vars array too short, i=%d&quot;, i);
+            return 0;
+        }
+        switch (opt-&gt;valtype) {
+        case '-':
+        case 'n':
+        case 'l':
+            if (!conf_get_number_e(conf, opt_section, opt-&gt;name, &amp;num)) {
+                ERR_clear_error();
+                continue; /* option not provided */
+            }
+            break;
+            /*
+             * do not use '&lt;' in cmp_options. Incorrect treatment
+             * somewhere in args_verify() can wrongly set badarg = 1
+             */
+        case '&lt;':
+        case 's':
+        case 'M':
+            txt = conf_get_string(conf, opt_section, opt-&gt;name);
+            if (txt == NULL) {
+                ERR_clear_error();
+                continue; /* option not provided */
+            }
+            break;
+        default:
+            CMP_err2(&quot;internal: unsupported type '%c' for option '%s'&quot;,
+                     opt-&gt;valtype, opt-&gt;name);
+            return 0;
+            break;
+        }
+        if (provider_option || verification_option) {
+            int conf_argc = 1;
+            char *conf_argv[3];
+            char arg1[82];
+
+            BIO_snprintf(arg1, 81, &quot;-%s&quot;, (char *)opt-&gt;name);
+            conf_argv[0] = prog;
+            conf_argv[1] = arg1;
+            if (opt-&gt;valtype == '-') {
+                if (num != 0)
+                    conf_argc = 2;
+            } else {
+                conf_argc = 3;
+                conf_argv[2] = conf_get_string(conf, opt_section, opt-&gt;name);
+                /* not NULL */
+            }
+            if (conf_argc &gt; 1) {
+                (void)opt_init(conf_argc, conf_argv, cmp_options);
+
+                if (provider_option
+                    ? !opt_provider(opt_next())
+                    : !opt_verify(opt_next(), vpm)) {
+                    CMP_err2(&quot;for option '%s' in config file section '%s'&quot;,
+                             opt-&gt;name, opt_section);
+                    return 0;
+                }
+            }
+        } else {
+            switch (opt-&gt;valtype) {
+            case '-':
+            case 'n':
+                if (num &lt; INT_MIN || INT_MAX &lt; num) {
+                    BIO_printf(bio_err,
+                               &quot;integer value out of range for option '%s'\n&quot;,
+                               opt-&gt;name);
+                    return 0;
+                }
+                *cmp_vars[i].num = (int)num;
+                break;
+            case 'l':
+                *cmp_vars[i].num_long = num;
+                break;
+            default:
+                if (txt != NULL &amp;&amp; txt[0] == '\0')
+                    txt = NULL; /* reset option on empty string input */
+                *cmp_vars[i].txt = txt;
+                break;
+            }
+        }
+    }
+
+    return 1;
+}
+
+static char *opt_str(char *opt)
+{
+    char *arg = opt_arg();
+
+    if (arg[0] == '\0') {
+        CMP_warn1(&quot;argument of -%s option is empty string, resetting option&quot;,
+                  opt);
+        arg = NULL;
+    } else if (arg[0] == '-') {
+        CMP_warn1(&quot;argument of -%s option starts with hyphen&quot;, opt);
+    }
+    return arg;
+}
+
+static int opt_nat(void)
+{
+    int result = -1;
+
+    if (opt_int(opt_arg(), &amp;result) &amp;&amp; result &lt; 0)
+        BIO_printf(bio_err, &quot;error: argument '%s' must not be negative\n&quot;,
+                   opt_arg());
+    return result;
+}
+
+/* returns 1 on success, 0 on error, -1 on -help (i.e., stop with success) */
+static int get_opts(int argc, char **argv)
+{
+    OPTION_CHOICE o;
+
+    prog = opt_init(argc, argv, cmp_options);
+
+    while ((o = opt_next()) != OPT_EOF) {
+        switch (o) {
+        case OPT_EOF:
+        case OPT_ERR:
+            goto opt_err;
+        case OPT_HELP:
+            opt_help(cmp_options);
+            return -1;
+        case OPT_CONFIG: /* has already been handled */
+            break;
+        case OPT_SECTION: /* has already been handled */
+            break;
+        case OPT_SERVER:
+            opt_server = opt_str(&quot;server&quot;);
+            break;
+        case OPT_PROXY:
+            opt_proxy = opt_str(&quot;proxy&quot;);
+            break;
+        case OPT_NO_PROXY:
+            opt_no_proxy = opt_str(&quot;no_proxy&quot;);
+            break;
+        case OPT_PATH:
+            opt_path = opt_str(&quot;path&quot;);
+            break;
+        case OPT_MSG_TIMEOUT:
+            if ((opt_msg_timeout = opt_nat()) &lt; 0)
+                goto opt_err;
+            break;
+        case OPT_TOTAL_TIMEOUT:
+            if ((opt_total_timeout = opt_nat()) &lt; 0)
+                goto opt_err;
+            break;
+        case OPT_TLS_USED:
+            opt_tls_used = 1;
+            break;
+        case OPT_TLS_CERT:
+            opt_tls_cert = opt_str(&quot;tls_cert&quot;);
+            break;
+        case OPT_TLS_KEY:
+            opt_tls_key = opt_str(&quot;tls_key&quot;);
+            break;
+        case OPT_TLS_KEYPASS:
+            opt_tls_keypass = opt_str(&quot;tls_keypass&quot;);
+            break;
+        case OPT_TLS_EXTRA:
+            opt_tls_extra = opt_str(&quot;tls_extra&quot;);
+            break;
+        case OPT_TLS_TRUSTED:
+            opt_tls_trusted = opt_str(&quot;tls_trusted&quot;);
+            break;
+        case OPT_TLS_HOST:
+            opt_tls_host = opt_str(&quot;tls_host&quot;);
+            break;
+        case OPT_REF:
+            opt_ref = opt_str(&quot;ref&quot;);
+            break;
+        case OPT_SECRET:
+            opt_secret = opt_str(&quot;secret&quot;);
+            break;
+        case OPT_CERT:
+            opt_cert = opt_str(&quot;cert&quot;);
+            break;
+        case OPT_KEY:
+            opt_key = opt_str(&quot;key&quot;);
+            break;
+        case OPT_KEYPASS:
+            opt_keypass = opt_str(&quot;keypass&quot;);
+            break;
+        case OPT_DIGEST:
+            opt_digest = opt_str(&quot;digest&quot;);
+            break;
+        case OPT_MAC:
+            opt_mac = opt_str(&quot;mac&quot;);
+            break;
+        case OPT_EXTRACERTS:
+            opt_extracerts = opt_str(&quot;extracerts&quot;);
+            break;
+        case OPT_UNPROTECTED_REQUESTS:
+            opt_unprotected_requests = 1;
+            break;
+
+        case OPT_TRUSTED:
+            opt_trusted = opt_str(&quot;trusted&quot;);
+            break;
+        case OPT_UNTRUSTED:
+            opt_untrusted = opt_str(&quot;untrusted&quot;);
+            break;
+        case OPT_SRVCERT:
+            opt_srvcert = opt_str(&quot;srvcert&quot;);
+            break;
+        case OPT_RECIPIENT:
+            opt_recipient = opt_str(&quot;recipient&quot;);
+            break;
+        case OPT_EXPECT_SENDER:
+            opt_expect_sender = opt_str(&quot;expect_sender&quot;);
+            break;
+        case OPT_IGNORE_KEYUSAGE:
+            opt_ignore_keyusage = 1;
+            break;
+        case OPT_UNPROTECTED_ERRORS:
+            opt_unprotected_errors = 1;
+            break;
+        case OPT_EXTRACERTSOUT:
+            opt_extracertsout = opt_str(&quot;extracertsout&quot;);
+            break;
+        case OPT_CACERTSOUT:
+            opt_cacertsout = opt_str(&quot;cacertsout&quot;);
+            break;
+
+        case OPT_V_CASES:
+            if (!opt_verify(o, vpm))
+                goto opt_err;
+            break;
+        case OPT_CMD:
+            opt_cmd_s = opt_str(&quot;cmd&quot;);
+            break;
+        case OPT_INFOTYPE:
+            opt_infotype_s = opt_str(&quot;infotype&quot;);
+            break;
+        case OPT_GENINFO:
+            opt_geninfo = opt_str(&quot;geninfo&quot;);
+            break;
+
+        case OPT_NEWKEY:
+            opt_newkey = opt_str(&quot;newkey&quot;);
+            break;
+        case OPT_NEWKEYPASS:
+            opt_newkeypass = opt_str(&quot;newkeypass&quot;);
+            break;
+        case OPT_SUBJECT:
+            opt_subject = opt_str(&quot;subject&quot;);
+            break;
+        case OPT_ISSUER:
+            opt_issuer = opt_str(&quot;issuer&quot;);
+            break;
+        case OPT_DAYS:
+            if ((opt_days = opt_nat()) &lt; 0)
+                goto opt_err;
+            break;
+        case OPT_REQEXTS:
+            opt_reqexts = opt_str(&quot;reqexts&quot;);
+            break;
+        case OPT_SANS:
+            opt_sans = opt_str(&quot;sans&quot;);
+            break;
+        case OPT_SAN_NODEFAULT:
+            opt_san_nodefault = 1;
+            break;
+        case OPT_POLICIES:
+            opt_policies = opt_str(&quot;policies&quot;);
+            break;
+        case OPT_POLICY_OIDS:
+            opt_policy_oids = opt_str(&quot;policy_oids&quot;);
+            break;
+        case OPT_POLICY_OIDS_CRITICAL:
+            opt_policy_oids_critical = 1;
+            break;
+        case OPT_POPO:
+            if (!opt_int(opt_arg(), &amp;opt_popo)
+                    || opt_popo &lt; OSSL_CRMF_POPO_NONE
+                    || opt_popo &gt; OSSL_CRMF_POPO_KEYENC) {
+                CMP_err(&quot;invalid popo spec. Valid values are -1 .. 2&quot;);
+                goto opt_err;
+            }
+            break;
+        case OPT_CSR:
+            opt_csr = opt_arg();
+            break;
+        case OPT_OUT_TRUSTED:
+            opt_out_trusted = opt_str(&quot;out_trusted&quot;);
+            break;
+        case OPT_IMPLICIT_CONFIRM:
+            opt_implicit_confirm = 1;
+            break;
+        case OPT_DISABLE_CONFIRM:
+            opt_disable_confirm = 1;
+            break;
+        case OPT_CERTOUT:
+            opt_certout = opt_str(&quot;certout&quot;);
+            break;
+        case OPT_OLDCERT:
+            opt_oldcert = opt_str(&quot;oldcert&quot;);
+            break;
+        case OPT_REVREASON:
+            if (!opt_int(opt_arg(), &amp;opt_revreason)
+                    || opt_revreason &lt; CRL_REASON_NONE
+                    || opt_revreason &gt; CRL_REASON_AA_COMPROMISE
+                    || opt_revreason == 7) {
+                CMP_err(&quot;invalid revreason. Valid values are -1 .. 6, 8 .. 10&quot;);
+                goto opt_err;
+            }
+            break;
+        case OPT_CERTFORM:
+            opt_certform_s = opt_str(&quot;certform&quot;);
+            break;
+        case OPT_KEYFORM:
+            opt_keyform_s = opt_str(&quot;keyform&quot;);
+            break;
+        case OPT_CERTSFORM:
+            opt_certsform_s = opt_str(&quot;certsform&quot;);
+            break;
+        case OPT_OTHERPASS:
+            opt_otherpass = opt_str(&quot;otherpass&quot;);
+            break;
+#ifndef OPENSSL_NO_ENGINE
+        case OPT_ENGINE:
+            opt_engine = opt_str(&quot;engine&quot;);
+            break;
+#endif
+        case OPT_PROV_CASES:
+            if (!opt_provider(o))
+                goto opt_err;
+            break;
+
+        case OPT_BATCH:
+            opt_batch = 1;
+            break;
+        case OPT_REPEAT:
+            opt_repeat = opt_nat();
+            break;
+        case OPT_REQIN:
+            opt_reqin = opt_str(&quot;reqin&quot;);
+            break;
+        case OPT_REQIN_NEW_TID:
+            opt_reqin_new_tid = 1;
+            break;
+        case OPT_REQOUT:
+            opt_reqout = opt_str(&quot;reqout&quot;);
+            break;
+        case OPT_RSPIN:
+            opt_rspin = opt_str(&quot;rspin&quot;);
+            break;
+        case OPT_RSPOUT:
+            opt_rspout = opt_str(&quot;rspout&quot;);
+            break;
+        case OPT_USE_MOCK_SRV:
+            opt_use_mock_srv = 1;
+            break;
+        case OPT_PORT:
+            opt_port = opt_str(&quot;port&quot;);
+            break;
+        case OPT_MAX_MSGS:
+            if ((opt_max_msgs = opt_nat()) &lt; 0)
+                goto opt_err;
+            break;
+        case OPT_SRV_REF:
+            opt_srv_ref = opt_str(&quot;srv_ref&quot;);
+            break;
+        case OPT_SRV_SECRET:
+            opt_srv_secret = opt_str(&quot;srv_secret&quot;);
+            break;
+        case OPT_SRV_CERT:
+            opt_srv_cert = opt_str(&quot;srv_cert&quot;);
+            break;
+        case OPT_SRV_KEY:
+            opt_srv_key = opt_str(&quot;srv_key&quot;);
+            break;
+        case OPT_SRV_KEYPASS:
+            opt_srv_keypass = opt_str(&quot;srv_keypass&quot;);
+            break;
+        case OPT_SRV_TRUSTED:
+            opt_srv_trusted = opt_str(&quot;srv_trusted&quot;);
+            break;
+        case OPT_SRV_UNTRUSTED:
+            opt_srv_untrusted = opt_str(&quot;srv_untrusted&quot;);
+            break;
+        case OPT_RSP_CERT:
+            opt_rsp_cert = opt_str(&quot;rsp_cert&quot;);
+            break;
+        case OPT_RSP_EXTRACERTS:
+            opt_rsp_extracerts = opt_str(&quot;rsp_extracerts&quot;);
+            break;
+        case OPT_RSP_CAPUBS:
+            opt_rsp_capubs = opt_str(&quot;rsp_capubs&quot;);
+            break;
+        case OPT_POLL_COUNT:
+            opt_poll_count = opt_nat();
+            break;
+        case OPT_CHECK_AFTER:
+            opt_check_after = opt_nat();
+            break;
+        case OPT_GRANT_IMPLICITCONF:
+            opt_grant_implicitconf = 1;
+            break;
+        case OPT_PKISTATUS:
+            opt_pkistatus = opt_nat();
+            break;
+        case OPT_FAILURE:
+            opt_failure = opt_nat();
+            break;
+        case OPT_FAILUREBITS:
+            opt_failurebits = opt_nat();
+            break;
+        case OPT_STATUSSTRING:
+            opt_statusstring = opt_str(&quot;statusstring&quot;);
+            break;
+        case OPT_SEND_ERROR:
+            opt_send_error = 1;
+            break;
+        case OPT_SEND_UNPROTECTED:
+            opt_send_unprotected = 1;
+            break;
+        case OPT_SEND_UNPROT_ERR:
+            opt_send_unprot_err = 1;
+            break;
+        case OPT_ACCEPT_UNPROTECTED:
+            opt_accept_unprotected = 1;
+            break;
+        case OPT_ACCEPT_UNPROT_ERR:
+            opt_accept_unprot_err = 1;
+            break;
+        case OPT_ACCEPT_RAVERIFIED:
+            opt_accept_raverified = 1;
+            break;
+        }
+    }
+    argc = opt_num_rest();
+    argv = opt_rest();
+    if (argc != 0) {
+        CMP_err1(&quot;unknown parameter %s&quot;, argv[0]);
+        goto opt_err;
+    }
+    return 1;
+
+ opt_err:
+    CMP_err1(&quot;use -help for summary of '%s' options&quot;, prog);
+    return 0;
+}
+
+int cmp_main(int argc, char **argv)
+{
+    char *configfile = NULL;
+    int i;
+    X509 *newcert = NULL;
+    ENGINE *e = NULL;
+    char mock_server[] = &quot;mock server:1&quot;;
+    int ret = 0; /* default: failure */
+
+    if (argc &lt;= 1) {
+        opt_help(cmp_options);
+        goto err;
+    }
+
+    /*
+     * handle OPT_CONFIG and OPT_SECTION upfront to take effect for other opts
+     */
+    for (i = 1; i &lt; argc - 1; i++) {
+        if (*argv[i] == '-') {
+            if (!strcmp(argv[i] + 1, cmp_options[OPT_CONFIG - OPT_HELP].name))
+                opt_config = argv[i + 1];
+            else if (!strcmp(argv[i] + 1,
+                             cmp_options[OPT_SECTION - OPT_HELP].name))
+                opt_section = argv[i + 1];
+        }
+    }
+    if (opt_section[0] == '\0') /* empty string */
+        opt_section = DEFAULT_SECTION;
+
+    vpm = X509_VERIFY_PARAM_new();
+    if (vpm == NULL) {
+        CMP_err(&quot;out of memory&quot;);
+        goto err;
+    }
+
+    /* read default values for options from config file */
+    configfile = opt_config != NULL ? opt_config : default_config_file;
+    if (configfile &amp;&amp; configfile[0] != '\0' /* non-empty string */
+            &amp;&amp; (configfile != default_config_file
+                    || access(configfile, F_OK) != -1)) {
+        CMP_info1(&quot;using OpenSSL configuration file '%s'&quot;, configfile);
+        conf = app_load_config(configfile);
+        if (conf == NULL) {
+            goto err;
+        } else {
+            if (strcmp(opt_section, CMP_SECTION) == 0) { /* default */
+                if (!NCONF_get_section(conf, opt_section))
+                    CMP_info2(&quot;no [%s] section found in config file '%s';&quot;
+                              &quot; will thus use just [default] and unnamed section if present&quot;,
+                              opt_section, configfile);
+            } else {
+                const char *end = opt_section + strlen(opt_section);
+                while ((end = prev_item(opt_section, end)) != NULL) {
+                    if (!NCONF_get_section(conf, opt_item)) {
+                        CMP_err2(&quot;no [%s] section found in config file '%s'&quot;,
+                                 opt_item, configfile);
+                        goto err;
+                    }
+                }
+            }
+            if (!read_config())
+                goto err;
+        }
+    }
+    (void)BIO_flush(bio_err); /* prevent interference with opt_help() */
+
+    ret = get_opts(argc, argv);
+    if (ret &lt;= 0)
+        goto err;
+    ret = 0;
+
+    if (opt_batch) {
+#ifndef OPENSSL_NO_ENGINE
+        UI_METHOD *ui_fallback_method;
+# ifndef OPENSSL_NO_UI_CONSOLE
+        ui_fallback_method = UI_OpenSSL();
+# else
+        ui_fallback_method = (UI_METHOD *)UI_null();
+# endif
+        UI_method_set_reader(ui_fallback_method, NULL);
+#endif
+    }
+
+    if (opt_engine != NULL)
+        e = setup_engine_flags(opt_engine, 0 /* not: ENGINE_METHOD_ALL */, 0);
+
+    if (opt_port != NULL) {
+        if (opt_use_mock_srv) {
+            CMP_err(&quot;cannot use both -port and -use_mock_srv options&quot;);
+            goto err;
+        }
+        if (opt_server != NULL) {
+            CMP_err(&quot;cannot use both -port and -server options&quot;);
+            goto err;
+        }
+    }
+
+    if ((cmp_ctx = OSSL_CMP_CTX_new()) == NULL) {
+        CMP_err(&quot;out of memory&quot;);
+        goto err;
+    }
+    if (!OSSL_CMP_CTX_set_log_cb(cmp_ctx, print_to_bio_out)) {
+        CMP_err1(&quot;cannot set up error reporting and logging for %s&quot;, prog);
+        goto err;
+    }
+    if ((opt_use_mock_srv || opt_port != NULL)) {
+        OSSL_CMP_SRV_CTX *srv_ctx;
+
+        if ((srv_ctx = setup_srv_ctx(e)) == NULL)
+            goto err;
+        OSSL_CMP_CTX_set_transfer_cb_arg(cmp_ctx, srv_ctx);
+        if (!OSSL_CMP_CTX_set_log_cb(OSSL_CMP_SRV_CTX_get0_cmp_ctx(srv_ctx),
+                                     print_to_bio_out)) {
+            CMP_err1(&quot;cannot set up error reporting and logging for %s&quot;, prog);
+            goto err;
+        }
+    }
+
+
+    if (opt_port != NULL) { /* act as very basic CMP HTTP server */
+#ifdef OPENSSL_NO_SOCK
+        BIO_printf(bio_err, &quot;Cannot act as server - sockets not supported\n&quot;);
+#else
+        BIO *acbio;
+        BIO *cbio = NULL;
+        int msgs = 0;
+
+        if ((acbio = http_server_init_bio(prog, opt_port)) == NULL)
+            goto err;
+        while (opt_max_msgs &lt;= 0 || msgs &lt; opt_max_msgs) {
+            OSSL_CMP_MSG *req = NULL;
+            OSSL_CMP_MSG *resp = NULL;
+
+            ret = http_server_get_asn1_req(ASN1_ITEM_rptr(OSSL_CMP_MSG),
+                                           (ASN1_VALUE **)&amp;req, &amp;cbio, acbio,
+                                           prog, 0, 0);
+            if (ret == 0)
+                continue;
+            if (ret++ == -1)
+                break; /* fatal error */
+
+            ret = 0;
+            msgs++;
+            if (req != NULL) {
+                resp = OSSL_CMP_CTX_server_perform(cmp_ctx, req);
+                OSSL_CMP_MSG_free(req);
+                if (resp == NULL)
+                    break; /* treated as fatal error */
+                ret = http_server_send_asn1_resp(cbio, &quot;application/pkixcmp&quot;,
+                                                 ASN1_ITEM_rptr(OSSL_CMP_MSG),
+                                                 (const ASN1_VALUE *)resp);
+                OSSL_CMP_MSG_free(resp);
+                if (!ret)
+                    break; /* treated as fatal error */
+            }
+            BIO_free_all(cbio);
+            cbio = NULL;
+        }
+        BIO_free_all(cbio);
+        BIO_free_all(acbio);
+#endif
+        goto err;
+    }
+    /* else act as CMP client */
+
+    if (opt_use_mock_srv) {
+        if (opt_server != NULL) {
+            CMP_err(&quot;cannot use both -use_mock_srv and -server options&quot;);
+            goto err;
+        }
+        if (opt_proxy != NULL) {
+            CMP_err(&quot;cannot use both -use_mock_srv and -proxy options&quot;);
+            goto err;
+        }
+        opt_server = mock_server;
+        opt_proxy = &quot;API&quot;;
+    } else {
+        if (opt_server == NULL) {
+            CMP_err(&quot;missing -server option&quot;);
+            goto err;
+        }
+    }
+
+    if (!setup_client_ctx(cmp_ctx, e)) {
+        CMP_err(&quot;cannot set up CMP context&quot;);
+        goto err;
+    }
+    for (i = 0; i &lt; opt_repeat; i++) {
+        /* everything is ready, now connect and perform the command! */
+        switch (opt_cmd) {
+        case CMP_IR:
+            newcert = OSSL_CMP_exec_IR_ses(cmp_ctx);
+            if (newcert == NULL)
+                goto err;
+            break;
+        case CMP_KUR:
+            newcert = OSSL_CMP_exec_KUR_ses(cmp_ctx);
+            if (newcert == NULL)
+                goto err;
+            break;
+        case CMP_CR:
+            newcert = OSSL_CMP_exec_CR_ses(cmp_ctx);
+            if (newcert == NULL)
+                goto err;
+            break;
+        case CMP_P10CR:
+            newcert = OSSL_CMP_exec_P10CR_ses(cmp_ctx);
+            if (newcert == NULL)
+                goto err;
+            break;
+        case CMP_RR:
+            if (OSSL_CMP_exec_RR_ses(cmp_ctx) == NULL)
+                goto err;
+            break;
+        case CMP_GENM:
+            {
+                STACK_OF(OSSL_CMP_ITAV) *itavs;
+
+                if (opt_infotype != NID_undef) {
+                    OSSL_CMP_ITAV *itav =
+                        OSSL_CMP_ITAV_create(OBJ_nid2obj(opt_infotype), NULL);
+                    if (itav == NULL)
+                        goto err;
+                    OSSL_CMP_CTX_push0_genm_ITAV(cmp_ctx, itav);
+                }
+
+                if ((itavs = OSSL_CMP_exec_GENM_ses(cmp_ctx)) == NULL)
+                    goto err;
+                print_itavs(itavs);
+                sk_OSSL_CMP_ITAV_pop_free(itavs, OSSL_CMP_ITAV_free);
+                break;
+            }
+        default:
+            break;
+        }
+
+        {
+            /* print PKIStatusInfo (this is in case there has been no error) */
+            int status = OSSL_CMP_CTX_get_status(cmp_ctx);
+            char *buf = app_malloc(OSSL_CMP_PKISI_BUFLEN, &quot;PKIStatusInfo buf&quot;);
+            const char *string =
+                OSSL_CMP_CTX_snprint_PKIStatus(cmp_ctx, buf,
+                                               OSSL_CMP_PKISI_BUFLEN);
+
+            CMP_print(bio_err,
+                      status == OSSL_CMP_PKISTATUS_accepted ? &quot;info&quot; :
+                      status == OSSL_CMP_PKISTATUS_rejection ? &quot;server error&quot; :
+                      status == OSSL_CMP_PKISTATUS_waiting ? &quot;internal error&quot;
+                                                           : &quot;warning&quot;,
+                      &quot;received from %s %s %s&quot;, opt_server,
+                      string != NULL ? string : &quot;&lt;unknown PKIStatus&gt;&quot;, &quot;&quot;);
+            OPENSSL_free(buf);
+        }
+
+        if (opt_cacertsout != NULL) {
+            STACK_OF(X509) *certs = OSSL_CMP_CTX_get1_caPubs(cmp_ctx);
+
+            if (sk_X509_num(certs) &gt; 0
+                    &amp;&amp; save_certs(cmp_ctx, certs, opt_cacertsout, &quot;CA&quot;) &lt; 0) {
+                sk_X509_pop_free(certs, X509_free);
+                goto err;
+            }
+            sk_X509_pop_free(certs, X509_free);
+        }
+
+        if (opt_extracertsout != NULL) {
+            STACK_OF(X509) *certs = OSSL_CMP_CTX_get1_extraCertsIn(cmp_ctx);
+            if (sk_X509_num(certs) &gt; 0
+                    &amp;&amp; save_certs(cmp_ctx, certs, opt_extracertsout,
+                                  &quot;extra&quot;) &lt; 0) {
+                sk_X509_pop_free(certs, X509_free);
+                goto err;
+            }
+            sk_X509_pop_free(certs, X509_free);
+        }
+
+        if (opt_certout != NULL &amp;&amp; newcert != NULL) {
+            STACK_OF(X509) *certs = sk_X509_new_null();
+
+            if (certs == NULL || !sk_X509_push(certs, newcert)
+                    || save_certs(cmp_ctx, certs, opt_certout,
+                                  &quot;enrolled&quot;) &lt; 0) {
+                sk_X509_free(certs);
+                goto err;
+            }
+            sk_X509_free(certs);
+        }
+        if (!OSSL_CMP_CTX_reinit(cmp_ctx))
+            goto err;
+    }
+    ret = 1;
+
+ err:
+    /* in case we ended up here on error without proper cleaning */
+    cleanse(opt_keypass);
+    cleanse(opt_newkeypass);
+    cleanse(opt_otherpass);
+    cleanse(opt_tls_keypass);
+    cleanse(opt_secret);
+    cleanse(opt_srv_keypass);
+    cleanse(opt_srv_secret);
+
+    if (ret != 1)
+        OSSL_CMP_CTX_print_errors(cmp_ctx);
+
+    ossl_cmp_mock_srv_free(OSSL_CMP_CTX_get_transfer_cb_arg(cmp_ctx));
+    {
+        APP_HTTP_TLS_INFO *http_tls_info =
+            OSSL_CMP_CTX_get_http_cb_arg(cmp_ctx);
+
+        if (http_tls_info != NULL) {
+            SSL_CTX_free(http_tls_info-&gt;ssl_ctx);
+            OPENSSL_free(http_tls_info);
+        }
+    }
+    X509_STORE_free(OSSL_CMP_CTX_get_certConf_cb_arg(cmp_ctx));
+    OSSL_CMP_CTX_free(cmp_ctx);
+    X509_VERIFY_PARAM_free(vpm);
+    release_engine(e);
+
+    NCONF_free(conf); /* must not do as long as opt_... variables are used */
+    OSSL_CMP_log_close();
+
+    return ret == 0 ? EXIT_FAILURE : EXIT_SUCCESS;
+}
diff --git a/apps/openssl-vms.cnf b/apps/openssl-vms.cnf
index e64cc9f3a6..c7e7abe994 100644
--- a/apps/openssl-vms.cnf
+++ b/apps/openssl-vms.cnf
@@ -348,3 +348,59 @@ ess_cert_id_chain	= no	# Must the ESS cert id chain be included?
 				# (optional, default: no)
 ess_cert_id_alg		= sha1	# algorithm to compute certificate
 				# identifier (optional, default: sha1)
+
+[insta] # CMP using Insta Demo CA
+# Message transfer
+server = pki.certificate.fi:8700
+# proxy = # set this as far as needed, e.g., <A HREF="http://192.168.1.1:8080">http://192.168.1.1:8080</A>
+# tls_use = 0
+path = pkix/
+
+# Server authentication
+recipient = &quot;/C=FI/O=Insta Demo/CN=Insta Demo CA&quot; # or set srvcert or issuer
+ignore_keyusage = 1 # potentially needed quirk
+unprotected_errors = 1 # potentially needed quirk
+extracertsout = insta.extracerts.pem
+
+# Client authentication
+ref = 3078 # user identification
+secret = pass:insta # can be used for both client and server side
+
+# Generic message options
+cmd = ir # default operation, can be overridden on cmd line with, e.g., kur
+
+# Certificate enrollment
+subject = &quot;/CN=openssl-cmp-test&quot;
+newkey = insta.priv.pem
+out_trusted = insta.ca.crt
+certout = insta.cert.pem
+
+[pbm] # Password-based protection for Insta CA
+# Server and client authentication
+ref = $insta::ref # 3078
+secret = $insta::secret # pass:insta
+
+[signature] # Signature-based protection for Insta CA
+# Server authentication
+trusted = insta.ca.crt # does not include keyUsage digitalSignature
+
+# Client authentication
+secret = # disable PBM
+key = $insta::newkey # insta.priv.pem
+cert = $insta::certout # insta.cert.pem
+
+[ir]
+cmd = ir
+
+[cr]
+cmd = cr
+
+[kur]
+# Certificate update
+cmd = kur
+oldcert = $insta::certout # insta.cert.pem
+
+[rr]
+# Certificate revocation
+cmd = rr
+oldcert = $insta::certout # insta.cert.pem
diff --git a/apps/openssl.cnf b/apps/openssl.cnf
index 4acca4b044..52706ae166 100644
--- a/apps/openssl.cnf
+++ b/apps/openssl.cnf
@@ -348,3 +348,59 @@ ess_cert_id_chain	= no	# Must the ESS cert id chain be included?
 				# (optional, default: no)
 ess_cert_id_alg		= sha1	# algorithm to compute certificate
 				# identifier (optional, default: sha1)
+
+[insta] # CMP using Insta Demo CA
+# Message transfer
+server = pki.certificate.fi:8700
+# proxy = # set this as far as needed, e.g., <A HREF="http://192.168.1.1:8080">http://192.168.1.1:8080</A>
+# tls_use = 0
+path = pkix/
+
+# Server authentication
+recipient = &quot;/C=FI/O=Insta Demo/CN=Insta Demo CA&quot; # or set srvcert or issuer
+ignore_keyusage = 1 # potentially needed quirk
+unprotected_errors = 1 # potentially needed quirk
+extracertsout = insta.extracerts.pem
+
+# Client authentication
+ref = 3078 # user identification
+secret = pass:insta # can be used for both client and server side
+
+# Generic message options
+cmd = ir # default operation, can be overridden on cmd line with, e.g., kur
+
+# Certificate enrollment
+subject = &quot;/CN=openssl-cmp-test&quot;
+newkey = insta.priv.pem
+out_trusted = insta.ca.crt
+certout = insta.cert.pem
+
+[pbm] # Password-based protection for Insta CA
+# Server and client authentication
+ref = $insta::ref # 3078
+secret = $insta::secret # pass:insta
+
+[signature] # Signature-based protection for Insta CA
+# Server authentication
+trusted = insta.ca.crt # does not include keyUsage digitalSignature
+
+# Client authentication
+secret = # disable PBM
+key = $insta::newkey # insta.priv.pem
+cert = $insta::certout # insta.cert.pem
+
+[ir]
+cmd = ir
+
+[cr]
+cmd = cr
+
+[kur]
+# Certificate update
+cmd = kur
+oldcert = $insta::certout # insta.cert.pem
+
+[rr]
+# Certificate revocation
+cmd = rr
+oldcert = $insta::certout # insta.cert.pem
diff --git a/crypto/cmp/cmp_asn.c b/crypto/cmp/cmp_asn.c
index 703bd8cded..f109af0502 100644
--- a/crypto/cmp/cmp_asn.c
+++ b/crypto/cmp/cmp_asn.c
@@ -70,7 +70,8 @@ ASN1_SEQUENCE(OSSL_CMP_ERRORMSGCONTENT) = {
      * so it is used directly
      *
      */
-    ASN1_SEQUENCE_OF_OPT(OSSL_CMP_ERRORMSGCONTENT, errorDetails, ASN1_UTF8STRING)
+    ASN1_SEQUENCE_OF_OPT(OSSL_CMP_ERRORMSGCONTENT, errorDetails,
+                         ASN1_UTF8STRING)
 } ASN1_SEQUENCE_END(OSSL_CMP_ERRORMSGCONTENT)
 IMPLEMENT_ASN1_FUNCTIONS(OSSL_CMP_ERRORMSGCONTENT)
 
@@ -352,8 +353,10 @@ ASN1_CHOICE(OSSL_CMP_PKIBODY) = {
     ASN1_EXP(OSSL_CMP_PKIBODY, value.cr, OSSL_CRMF_MSGS, 2),
     ASN1_EXP(OSSL_CMP_PKIBODY, value.cp, OSSL_CMP_CERTREPMESSAGE, 3),
     ASN1_EXP(OSSL_CMP_PKIBODY, value.p10cr, X509_REQ, 4),
-    ASN1_EXP(OSSL_CMP_PKIBODY, value.popdecc, OSSL_CMP_POPODECKEYCHALLCONTENT, 5),
-    ASN1_EXP(OSSL_CMP_PKIBODY, value.popdecr, OSSL_CMP_POPODECKEYRESPCONTENT, 6),
+    ASN1_EXP(OSSL_CMP_PKIBODY, value.popdecc,
+             OSSL_CMP_POPODECKEYCHALLCONTENT, 5),
+    ASN1_EXP(OSSL_CMP_PKIBODY, value.popdecr,
+             OSSL_CMP_POPODECKEYRESPCONTENT, 6),
     ASN1_EXP(OSSL_CMP_PKIBODY, value.kur, OSSL_CRMF_MSGS, 7),
     ASN1_EXP(OSSL_CMP_PKIBODY, value.kup, OSSL_CMP_CERTREPMESSAGE, 8),
     ASN1_EXP(OSSL_CMP_PKIBODY, value.krr, OSSL_CRMF_MSGS, 9),
diff --git a/crypto/cmp/cmp_client.c b/crypto/cmp/cmp_client.c
index f561f72eb1..d309f84a78 100644
--- a/crypto/cmp/cmp_client.c
+++ b/crypto/cmp/cmp_client.c
@@ -176,7 +176,7 @@ static int send_receive_check(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *req,
 
     if (*rep == NULL) {
         CMPerr(0, CMP_R_TRANSFER_ERROR); /* or receiving response */
-        ERR_add_error_data(1, req_type_str);
+        ERR_add_error_data(2, &quot;request sent: &quot;, req_type_str);
         ERR_add_error_data(2, &quot;, expected response: &quot;, expected_type_str);
         return 0;
     }
@@ -211,7 +211,8 @@ static int send_receive_check(OSSL_CMP_CTX *ctx, const OSSL_CMP_MSG *req,
         char buf[OSSL_CMP_PKISI_BUFLEN];
 
         if (save_statusInfo(ctx, si)
-                &amp;&amp; OSSL_CMP_CTX_snprint_PKIStatus(ctx, buf, sizeof(buf)) != NULL)
+                &amp;&amp; OSSL_CMP_CTX_snprint_PKIStatus(ctx, buf,
+                                                  sizeof(buf)) != NULL)
             ERR_add_error_data(1, buf);
         if (emc-&gt;errorCode != NULL
                 &amp;&amp; BIO_snprintf(buf, sizeof(buf), &quot;; errorCode: %ld&quot;,
diff --git a/crypto/cmp/cmp_ctx.c b/crypto/cmp/cmp_ctx.c
index aa18338db5..9aeee7f5dd 100644
--- a/crypto/cmp/cmp_ctx.c
+++ b/crypto/cmp/cmp_ctx.c
@@ -164,7 +164,7 @@ void OSSL_CMP_CTX_free(OSSL_CMP_CTX *ctx)
     X509_STORE_free(ctx-&gt;trusted);
     sk_X509_pop_free(ctx-&gt;untrusted_certs, X509_free);
 
-    X509_free(ctx-&gt;clCert);
+    X509_free(ctx-&gt;cert);
     EVP_PKEY_free(ctx-&gt;pkey);
     ASN1_OCTET_STRING_free(ctx-&gt;referenceValue);
     if (ctx-&gt;secretValue != NULL)
@@ -676,12 +676,12 @@ int OSSL_CMP_CTX_push1_subjectAltName(OSSL_CMP_CTX *ctx,
  * Set our own client certificate, used for example in KUR and when
  * doing the IR with existing certificate.
  */
-DEFINE_OSSL_CMP_CTX_set1_up_ref(clCert, X509)
+DEFINE_OSSL_CMP_CTX_set1_up_ref(cert, X509)
 
 /*
  * Set the old certificate that we are updating in KUR
  * or the certificate to be revoked in RR, respectively.
- * Also used as reference cert (defaulting to clCert) for deriving subject DN
+ * Also used as reference cert (defaulting to cert) for deriving subject DN
  * and SANs. Its issuer is used as default recipient in the CMP message header.
  */
 DEFINE_OSSL_CMP_CTX_set1_up_ref(oldCert, X509)
diff --git a/crypto/cmp/cmp_hdr.c b/crypto/cmp/cmp_hdr.c
index c2493420f8..b07bf031bf 100644
--- a/crypto/cmp/cmp_hdr.c
+++ b/crypto/cmp/cmp_hdr.c
@@ -41,7 +41,8 @@ int ossl_cmp_hdr_get_pvno(const OSSL_CMP_PKIHEADER *hdr)
     return (int)pvno;
 }
 
-ASN1_OCTET_STRING *OSSL_CMP_HDR_get0_transactionID(const OSSL_CMP_PKIHEADER *hdr)
+ASN1_OCTET_STRING *OSSL_CMP_HDR_get0_transactionID(const
+                                                   OSSL_CMP_PKIHEADER *hdr)
 {
     if (hdr == NULL) {
         CMPerr(0, CMP_R_NULL_ARGUMENT);
@@ -266,6 +267,25 @@ int ossl_cmp_hdr_has_implicitConfirm(const OSSL_CMP_PKIHEADER *hdr)
     return 0;
 }
 
+/*
+ * set ctx-&gt;transactionID in CMP header
+ * if ctx-&gt;transactionID is NULL, a random one is created with 128 bit
+ * according to section 5.1.1:
+ *
+ * It is RECOMMENDED that the clients fill the transactionID field with
+ * 128 bits of (pseudo-) random data for the start of a transaction to
+ * reduce the probability of having the transactionID in use at the server.
+ */
+int ossl_cmp_hdr_set_transactionID(OSSL_CMP_CTX *ctx, OSSL_CMP_PKIHEADER *hdr)
+{
+    if (ctx-&gt;transactionID == NULL
+            &amp;&amp; !set1_aostr_else_random(&amp;ctx-&gt;transactionID, NULL,
+                                       OSSL_CMP_TRANSACTIONID_LENGTH))
+        return 0;
+    return ossl_cmp_asn1_octet_string_set1(&amp;hdr-&gt;transactionID,
+                                           ctx-&gt;transactionID);
+}
+
 /* fill in all fields of the hdr according to the info given in ctx */
 int ossl_cmp_hdr_init(OSSL_CMP_CTX *ctx, OSSL_CMP_PKIHEADER *hdr)
 {
@@ -283,8 +303,8 @@ int ossl_cmp_hdr_init(OSSL_CMP_CTX *ctx, OSSL_CMP_PKIHEADER *hdr)
      * The sender name is copied from the subject of the client cert, if any,
      * or else from the subject name provided for certification requests.
      */
-    sender = ctx-&gt;clCert != NULL ?
-        X509_get_subject_name(ctx-&gt;clCert) : ctx-&gt;subjectName;
+    sender = ctx-&gt;cert != NULL ?
+        X509_get_subject_name(ctx-&gt;cert) : ctx-&gt;subjectName;
     if (!ossl_cmp_hdr_set1_sender(hdr, sender))
         return 0;
 
@@ -301,8 +321,8 @@ int ossl_cmp_hdr_init(OSSL_CMP_CTX *ctx, OSSL_CMP_PKIHEADER *hdr)
         rcp = ctx-&gt;issuer;
     } else if (ctx-&gt;oldCert != NULL) {
         rcp = X509_get_issuer_name(ctx-&gt;oldCert);
-    } else if (ctx-&gt;clCert != NULL) {
-        rcp = X509_get_issuer_name(ctx-&gt;clCert);
+    } else if (ctx-&gt;cert != NULL) {
+        rcp = X509_get_issuer_name(ctx-&gt;cert);
     }
     if (!ossl_cmp_hdr_set1_recipient(hdr, rcp))
         return 0;
@@ -316,21 +336,7 @@ int ossl_cmp_hdr_init(OSSL_CMP_CTX *ctx, OSSL_CMP_PKIHEADER *hdr)
                                                 ctx-&gt;recipNonce))
         return 0;
 
-    /*
-     * set ctx-&gt;transactionID in CMP header
-     * if ctx-&gt;transactionID is NULL, a random one is created with 128 bit
-     * according to section 5.1.1:
-     *
-     * It is RECOMMENDED that the clients fill the transactionID field with
-     * 128 bits of (pseudo-) random data for the start of a transaction to
-     * reduce the probability of having the transactionID in use at the server.
-     */
-    if (ctx-&gt;transactionID == NULL
-            &amp;&amp; !set1_aostr_else_random(&amp;ctx-&gt;transactionID, NULL,
-                                       OSSL_CMP_TRANSACTIONID_LENGTH))
-        return 0;
-    if (!ossl_cmp_asn1_octet_string_set1(&amp;hdr-&gt;transactionID,
-                                         ctx-&gt;transactionID))
+    if (!ossl_cmp_hdr_set_transactionID(ctx, hdr))
         return 0;
 
     /*-
diff --git a/crypto/cmp/cmp_local.h b/crypto/cmp/cmp_local.h
index 9acafbae89..04abcf5084 100644
--- a/crypto/cmp/cmp_local.h
+++ b/crypto/cmp/cmp_local.h
@@ -68,8 +68,8 @@ struct ossl_cmp_ctx_st {
 
     /* client authentication */
     int unprotectedSend; /* send unprotected PKI messages */
-    X509 *clCert; /* client cert used to identify and sign for MSG_SIG_ALG */
-    EVP_PKEY *pkey; /* the key pair corresponding to clCert */
+    X509 *cert; /* protection cert used to identify and sign for MSG_SIG_ALG */
+    EVP_PKEY *pkey; /* the key pair corresponding to cert */
     ASN1_OCTET_STRING *referenceValue; /* optional user name for MSG_MAC_ALG */
     ASN1_OCTET_STRING *secretValue; /* password/shared secret for MSG_MAC_ALG */
     /* PBMParameters for MSG_MAC_ALG */
@@ -790,7 +790,7 @@ int ossl_cmp_ctx_set1_recipNonce(OSSL_CMP_CTX *ctx,
 /* from cmp_status.c */
 int ossl_cmp_pkisi_get_status(const OSSL_CMP_PKISI *si);
 const char *ossl_cmp_PKIStatus_to_string(int status);
-OSSL_CMP_PKIFREETEXT *ossl_cmp_pkisi_get0_statusString(const OSSL_CMP_PKISI *si);
+OSSL_CMP_PKIFREETEXT *ossl_cmp_pkisi_get0_statusString(const OSSL_CMP_PKISI *s);
 int ossl_cmp_pkisi_get_pkifailureinfo(const OSSL_CMP_PKISI *si);
 int ossl_cmp_pkisi_check_pkifailureinfo(const OSSL_CMP_PKISI *si, int index);
 
@@ -814,6 +814,7 @@ int ossl_cmp_hdr_set_implicitConfirm(OSSL_CMP_PKIHEADER *hdr);
 int ossl_cmp_hdr_has_implicitConfirm(const OSSL_CMP_PKIHEADER *hdr);
 # define OSSL_CMP_TRANSACTIONID_LENGTH 16
 # define OSSL_CMP_SENDERNONCE_LENGTH 16
+int ossl_cmp_hdr_set_transactionID(OSSL_CMP_CTX *ctx, OSSL_CMP_PKIHEADER *hdr);
 int ossl_cmp_hdr_init(OSSL_CMP_CTX *ctx, OSSL_CMP_PKIHEADER *hdr);
 
 /* from cmp_msg.c */
@@ -885,13 +886,13 @@ OSSL_CMP_MSG *ossl_cmp_pollRep_new(OSSL_CMP_CTX *ctx, int crid,
                                    int64_t poll_after);
 OSSL_CMP_PKISI *
 ossl_cmp_revrepcontent_get_pkisi(OSSL_CMP_REVREPCONTENT *rrep, int rsid);
-OSSL_CRMF_CERTID *ossl_cmp_revrepcontent_get_CertId(OSSL_CMP_REVREPCONTENT *rrep,
+OSSL_CRMF_CERTID *ossl_cmp_revrepcontent_get_CertId(OSSL_CMP_REVREPCONTENT *rc,
                                                     int rsid);
 OSSL_CMP_POLLREP *
 ossl_cmp_pollrepcontent_get0_pollrep(const OSSL_CMP_POLLREPCONTENT *prc,
                                      int rid);
 OSSL_CMP_CERTRESPONSE *
-ossl_cmp_certrepmessage_get0_certresponse(const OSSL_CMP_CERTREPMESSAGE *crepmsg,
+ossl_cmp_certrepmessage_get0_certresponse(const OSSL_CMP_CERTREPMESSAGE *crm,
                                           int rid);
 X509 *ossl_cmp_certresponse_get1_certificate(EVP_PKEY *privkey,
                                              const OSSL_CMP_CERTRESPONSE *crep);
@@ -916,6 +917,6 @@ int ossl_cmp_verify_popo(const OSSL_CMP_MSG *msg, int accept_RAVerified);
 int ossl_cmp_exchange_certConf(OSSL_CMP_CTX *ctx, int fail_info,
                                const char *txt);
 int ossl_cmp_exchange_error(OSSL_CMP_CTX *ctx, int status, int fail_info,
-                            const char *txt, int errorCode, const char *details);
+                            const char *txt, int errorCode, const char *detail);
 
 #endif /* !defined(OSSL_CRYPTO_CMP_LOCAL_H) */
diff --git a/crypto/cmp/cmp_msg.c b/crypto/cmp/cmp_msg.c
index dc11b54d2b..7b338b2b01 100644
--- a/crypto/cmp/cmp_msg.c
+++ b/crypto/cmp/cmp_msg.c
@@ -218,7 +218,7 @@ static const X509_NAME *determine_subj(OSSL_CMP_CTX *ctx, X509 *refcert,
 static OSSL_CRMF_MSG *crm_new(OSSL_CMP_CTX *ctx, int bodytype, int rid)
 {
     OSSL_CRMF_MSG *crm = NULL;
-    X509 *refcert = ctx-&gt;oldCert != NULL ? ctx-&gt;oldCert : ctx-&gt;clCert;
+    X509 *refcert = ctx-&gt;oldCert != NULL ? ctx-&gt;oldCert : ctx-&gt;cert;
     /* refcert defaults to current client cert */
     EVP_PKEY *rkey = OSSL_CMP_CTX_get0_newPkey(ctx, 0);
     STACK_OF(GENERAL_NAME) *default_sans = NULL;
@@ -584,9 +584,9 @@ int ossl_cmp_msg_gen_push1_ITAVs(OSSL_CMP_MSG *msg,
         return 0;
 
     for (i = 0; i &lt; sk_OSSL_CMP_ITAV_num(itavs); i++) {
-        if ((itav = OSSL_CMP_ITAV_dup(sk_OSSL_CMP_ITAV_value(itavs, i))) == NULL)
-            return 0;
-        if (!ossl_cmp_msg_gen_push0_ITAV(msg, itav)) {
+        itav = OSSL_CMP_ITAV_dup(sk_OSSL_CMP_ITAV_value(itavs, i));
+        if (itav == NULL
+                || !ossl_cmp_msg_gen_push0_ITAV(msg, itav)) {
             OSSL_CMP_ITAV_free(itav);
             return 0;
         }
@@ -982,6 +982,18 @@ X509 *ossl_cmp_certresponse_get1_certificate(EVP_PKEY *privkey,
     return crt;
 }
 
+int OSSL_CMP_MSG_update_transactionID(OSSL_CMP_CTX *ctx, OSSL_CMP_MSG *msg)
+{
+    if (ctx == NULL || msg == NULL) {
+        CMPerr(0, CMP_R_NULL_ARGUMENT);
+        return 0;
+    }
+    if (!ossl_cmp_hdr_set_transactionID(ctx, msg-&gt;header))
+        return 0;
+    return msg-&gt;header-&gt;protectionAlg == NULL
+            || ossl_cmp_msg_protect(ctx, msg);
+}
+
 OSSL_CMP_MSG *ossl_cmp_msg_load(const char *file)
 {
     OSSL_CMP_MSG *msg = NULL;
diff --git a/crypto/cmp/cmp_protect.c b/crypto/cmp/cmp_protect.c
index 3e0c22bb80..97600a7266 100644
--- a/crypto/cmp/cmp_protect.c
+++ b/crypto/cmp/cmp_protect.c
@@ -145,21 +145,18 @@ int ossl_cmp_msg_add_extraCerts(OSSL_CMP_CTX *ctx, OSSL_CMP_MSG *msg)
             &amp;&amp; (msg-&gt;extraCerts = sk_X509_new_null()) == NULL)
         return 0;
 
-    if (ctx-&gt;clCert != NULL) {
-        /* Make sure that our own cert gets sent, in the first position */
-        if (!X509_up_ref(ctx-&gt;clCert))
+    if (ctx-&gt;cert != NULL &amp;&amp; ctx-&gt;pkey != NULL) {
+        /* make sure that our own cert is included in the first position */
+        if (!ossl_cmp_sk_X509_add1_cert(msg-&gt;extraCerts, ctx-&gt;cert, 1, 1))
             return 0;
-        if (!sk_X509_push(msg-&gt;extraCerts, ctx-&gt;clCert)) {
-            X509_free(ctx-&gt;clCert);
-            return 0;
-        }
-        /* if we have untrusted store, try to add intermediate certs */
+        /* if we have untrusted certs, try to add intermediate certs */
         if (ctx-&gt;untrusted_certs != NULL) {
             STACK_OF(X509) *chain =
-                ossl_cmp_build_cert_chain(ctx-&gt;untrusted_certs, ctx-&gt;clCert);
+                ossl_cmp_build_cert_chain(ctx-&gt;untrusted_certs, ctx-&gt;cert);
             int res = ossl_cmp_sk_X509_add1_certs(msg-&gt;extraCerts, chain,
                                                   1 /* no self-issued */,
                                                   1 /* no duplicates */, 0);
+
             sk_X509_pop_free(chain, X509_free);
             if (res == 0)
                 return 0;
@@ -227,6 +224,15 @@ int ossl_cmp_msg_protect(OSSL_CMP_CTX *ctx, OSSL_CMP_MSG *msg)
     if (!ossl_assert(ctx != NULL &amp;&amp; msg != NULL))
         return 0;
 
+    /*
+     * For the case of re-protection remove pre-existing protection.
+     * TODO: Consider also removing any pre-existing extraCerts.
+     */
+    X509_ALGOR_free(msg-&gt;header-&gt;protectionAlg);
+    msg-&gt;header-&gt;protectionAlg = NULL;
+    ASN1_BIT_STRING_free(msg-&gt;protection);
+    msg-&gt;protection = NULL;
+
     if (ctx-&gt;unprotectedSend)
         return 1;
 
@@ -238,84 +244,70 @@ int ossl_cmp_msg_protect(OSSL_CMP_CTX *ctx, OSSL_CMP_MSG *msg)
                 &amp;&amp; !ossl_cmp_hdr_set1_senderKID(msg-&gt;header,
                                                 ctx-&gt;referenceValue))
             goto err;
-
-        /*
-         * add any additional certificates from ctx-&gt;extraCertsOut
-         * while not needed to validate the signing cert, the option to do
-         * this might be handy for certain use cases
-         */
-        if (!ossl_cmp_msg_add_extraCerts(ctx, msg))
-            goto err;
-
-        if ((msg-&gt;protection =
-             ossl_cmp_calc_protection(msg, ctx-&gt;secretValue, NULL)) == NULL)
-            goto err;
-    } else {
+    } else if (ctx-&gt;cert != NULL &amp;&amp; ctx-&gt;pkey != NULL) {
         /*
          * use MSG_SIG_ALG according to 5.1.3.3 if client Certificate and
          * private key is given
          */
-        if (ctx-&gt;clCert != NULL &amp;&amp; ctx-&gt;pkey != NULL) {
-            const ASN1_OCTET_STRING *subjKeyIDStr = NULL;
-            int algNID = 0;
-            ASN1_OBJECT *alg = NULL;
-
-            /* make sure that key and certificate match */
-            if (!X509_check_private_key(ctx-&gt;clCert, ctx-&gt;pkey)) {
-                CMPerr(0, CMP_R_CERT_AND_KEY_DO_NOT_MATCH);
-                goto err;
-            }
-
-            if (msg-&gt;header-&gt;protectionAlg == NULL)
-                if ((msg-&gt;header-&gt;protectionAlg = X509_ALGOR_new()) == NULL)
-                    goto err;
+        const ASN1_OCTET_STRING *subjKeyIDStr = NULL;
+        int algNID = 0;
+        ASN1_OBJECT *alg = NULL;
 
-            if (!OBJ_find_sigid_by_algs(&amp;algNID, ctx-&gt;digest,
-                                        EVP_PKEY_id(ctx-&gt;pkey))) {
-                CMPerr(0, CMP_R_UNSUPPORTED_KEY_TYPE);
-                goto err;
-            }
-            if ((alg = OBJ_nid2obj(algNID)) == NULL)
-                goto err;
-            if (!X509_ALGOR_set0(msg-&gt;header-&gt;protectionAlg,
-                                 alg, V_ASN1_UNDEF, NULL)) {
-                ASN1_OBJECT_free(alg);
-                goto err;
-            }
-
-            /*
-             * set senderKID to keyIdentifier of the used certificate according
-             * to section 5.1.1
-             */
-            subjKeyIDStr = X509_get0_subject_key_id(ctx-&gt;clCert);
-            if (subjKeyIDStr == NULL)
-                subjKeyIDStr = ctx-&gt;referenceValue; /* fallback */
-            if (subjKeyIDStr != NULL
-                    &amp;&amp; !ossl_cmp_hdr_set1_senderKID(msg-&gt;header, subjKeyIDStr))
-                goto err;
+        /* make sure that key and certificate match */
+        if (!X509_check_private_key(ctx-&gt;cert, ctx-&gt;pkey)) {
+            CMPerr(0, CMP_R_CERT_AND_KEY_DO_NOT_MATCH);
+            goto err;
+        }
 
-            /*
-             * Add ctx-&gt;clCert followed, if possible, by its chain built
-             * from ctx-&gt;untrusted_certs, and then ctx-&gt;extraCertsOut
-             */
-            if (!ossl_cmp_msg_add_extraCerts(ctx, msg))
+        if (msg-&gt;header-&gt;protectionAlg == NULL)
+            if ((msg-&gt;header-&gt;protectionAlg = X509_ALGOR_new()) == NULL)
                 goto err;
 
-            if ((msg-&gt;protection =
-                 ossl_cmp_calc_protection(msg, NULL, ctx-&gt;pkey)) == NULL)
-                goto err;
-        } else {
-            CMPerr(0, CMP_R_MISSING_KEY_INPUT_FOR_CREATING_PROTECTION);
+        if (!OBJ_find_sigid_by_algs(&amp;algNID, ctx-&gt;digest,
+                                    EVP_PKEY_id(ctx-&gt;pkey))) {
+            CMPerr(0, CMP_R_UNSUPPORTED_KEY_TYPE);
             goto err;
         }
+        if ((alg = OBJ_nid2obj(algNID)) == NULL)
+            goto err;
+        if (!X509_ALGOR_set0(msg-&gt;header-&gt;protectionAlg, alg,
+                             V_ASN1_UNDEF, NULL)) {
+            ASN1_OBJECT_free(alg);
+            goto err;
+        }
+
+        /*
+         * set senderKID to keyIdentifier of the used certificate according
+         * to section 5.1.1
+         */
+        subjKeyIDStr = X509_get0_subject_key_id(ctx-&gt;cert);
+        if (subjKeyIDStr == NULL)
+            subjKeyIDStr = ctx-&gt;referenceValue; /* fallback */
+        if (subjKeyIDStr != NULL
+                &amp;&amp; !ossl_cmp_hdr_set1_senderKID(msg-&gt;header, subjKeyIDStr))
+            goto err;
+    } else {
+        CMPerr(0, CMP_R_MISSING_KEY_INPUT_FOR_CREATING_PROTECTION);
+        goto err;
     }
+    if ((msg-&gt;protection =
+         ossl_cmp_calc_protection(msg, ctx-&gt;secretValue, ctx-&gt;pkey)) == NULL)
+        goto err;
+
+    /*
+     * If present, add ctx-&gt;cert followed by its chain as far as possible.
+     * Finally add any additional certificates from ctx-&gt;extraCertsOut;
+     * even if not needed to validate the protection
+     * the option to do this might be handy for certain use cases.
+     */
+    if (!ossl_cmp_msg_add_extraCerts(ctx, msg))
+        goto err;
 
     /*
      * As required by RFC 4210 section 5.1.1., if the sender name is not known
      * to the client it set to NULL-DN. In this case for identification at least
      * the senderKID must be set, where we took the referenceValue as fallback.
      */
-
     if (ossl_cmp_general_name_is_NULL_DN(msg-&gt;header-&gt;sender)
             &amp;&amp; msg-&gt;header-&gt;senderKID == NULL)
         CMPerr(0, CMP_R_MISSING_SENDER_IDENTIFICATION);
diff --git a/crypto/cmp/cmp_server.c b/crypto/cmp/cmp_server.c
index 8bd3b56a26..b805dc8bcb 100644
--- a/crypto/cmp/cmp_server.c
+++ b/crypto/cmp/cmp_server.c
@@ -221,7 +221,8 @@ static OSSL_CMP_MSG *process_cert_request(OSSL_CMP_SRV_CTX *srv_ctx,
         if (si == NULL)
             goto err;
         /* set OSSL_CMP_OPT_IMPLICIT_CONFIRM if and only if transaction ends */
-        if (!OSSL_CMP_CTX_set_option(srv_ctx-&gt;ctx, OSSL_CMP_OPT_IMPLICIT_CONFIRM,
+        if (!OSSL_CMP_CTX_set_option(srv_ctx-&gt;ctx,
+                                     OSSL_CMP_OPT_IMPLICIT_CONFIRM,
                                      ossl_cmp_hdr_has_implicitConfirm(hdr)
                                          &amp;&amp; srv_ctx-&gt;grantImplicitConfirm
                                          /* do not set if polling starts: */
diff --git a/crypto/store/loader_file.c b/crypto/store/loader_file.c
index 9f6158ff79..320c527a65 100644
--- a/crypto/store/loader_file.c
+++ b/crypto/store/loader_file.c
@@ -278,6 +278,7 @@ static OSSL_STORE_INFO *try_decode_PKCS12(const char *pem_name,
                         (void)sk_X509_shift(chain);
                     }
                 }
+                sk_X509_free(chain);
                 if (!ok) {
                     OSSL_STORE_INFO_free(osi_ca);
                     OSSL_STORE_INFO_free(osi_cert);
diff --git a/doc/internal/man3/ossl_cmp_msg_protect.pod b/doc/internal/man3/ossl_cmp_msg_protect.pod
index a931d3caf2..bf859cdbda 100644
--- a/doc/internal/man3/ossl_cmp_msg_protect.pod
+++ b/doc/internal/man3/ossl_cmp_msg_protect.pod
@@ -15,9 +15,9 @@ ossl_cmp_msg_add_extraCerts
 
 =head1 DESCRIPTION
 
-ossl_cmp_msg_protect() protects the given message B&lt;msg&gt; using an algorithm
+ossl_cmp_msg_protect() (re-)protects the given message B&lt;msg&gt; using an algorithm
 depending on the available context information given in the B&lt;ctx&gt;.
-If there is a secretValue it selects PBMAC. Else if there is a clCert
+If there is a secretValue it selects PBMAC, else if there is a protection cert
 it selects Signature and uses B&lt;ossl_cmp_msg_add_extraCerts()&gt;.
 It also sets the protectionAlg field in the message header accordingly.
 
diff --git a/doc/man1/build.info b/doc/man1/build.info
index c48ff0acbe..5b0b4eb6fd 100644
--- a/doc/man1/build.info
+++ b/doc/man1/build.info
@@ -4,6 +4,7 @@ DEPEND[]= \
          openssl-ca.pod \
          openssl-ciphers.pod \
          openssl-cmds.pod \
+         openssl-cmp.pod \
          openssl-cms.pod \
          openssl-crl2pkcs7.pod \
          openssl-crl.pod \
@@ -58,6 +59,7 @@ DEPEND[openssl-asn1parse.pod]=../perlvars.pm
 DEPEND[openssl-ca.pod]=../perlvars.pm
 DEPEND[openssl-ciphers.pod]=../perlvars.pm
 DEPEND[openssl-cmds.pod]=../perlvars.pm
+DEPEND[openssl-cmp.pod]=../perlvars.pm
 DEPEND[openssl-cms.pod]=../perlvars.pm
 DEPEND[openssl-crl2pkcs7.pod]=../perlvars.pm
 DEPEND[openssl-crl.pod]=../perlvars.pm
@@ -112,6 +114,7 @@ GENERATE[openssl-asn1parse.pod]=openssl-asn1parse.pod.in
 GENERATE[openssl-ca.pod]=openssl-ca.pod.in
 GENERATE[openssl-ciphers.pod]=openssl-ciphers.pod.in
 GENERATE[openssl-cmds.pod]=openssl-cmds.pod.in
+GENERATE[openssl-cmp.pod]=openssl-cmp.pod.in
 GENERATE[openssl-cms.pod]=openssl-cms.pod.in
 GENERATE[openssl-crl2pkcs7.pod]=openssl-crl2pkcs7.pod.in
 GENERATE[openssl-crl.pod]=openssl-crl.pod.in
diff --git a/doc/man1/openssl-cmp.pod.in b/doc/man1/openssl-cmp.pod.in
new file mode 100644
index 0000000000..cf7f6aa418
--- /dev/null
+++ b/doc/man1/openssl-cmp.pod.in
@@ -0,0 +1,1165 @@
+=pod
+{- OpenSSL::safe::output_do_not_edit_headers(); -}
+
+=head1 NAME
+
+openssl-cmp - client for the Certificate Management Protocol (CMP, RFC 4210)
+
+=head1 SYNOPSIS
+
+B&lt;openssl&gt; B&lt;cmp&gt;
+[B&lt;-help&gt;]
+[B&lt;-config&gt; I&lt;filename&gt;]
+[B&lt;-section&gt; I&lt;names&gt;]
+
+[B&lt;-server&gt; I&lt;address[:port]&gt;]
+[B&lt;-proxy&gt; I&lt;[http[s]://]address[:port][/path]&gt;]
+[B&lt;-no_proxy&gt; I&lt;addresses&gt;]
+[B&lt;-path&gt; I&lt;remote_path&gt;]
+[B&lt;-msg_timeout&gt; I&lt;seconds&gt;]
+[B&lt;-total_timeout&gt; I&lt;seconds&gt;]
+
+[B&lt;-trusted&gt; I&lt;filenames&gt;]
+[B&lt;-untrusted&gt; I&lt;sources&gt;]
+[B&lt;-srvcert&gt; I&lt;filename&gt;]
+[B&lt;-recipient&gt; I&lt;name&gt;]
+[B&lt;-expect_sender&gt; I&lt;name&gt;]
+[B&lt;-ignore_keyusage&gt;]
+[B&lt;-unprotected_errors&gt;]
+[B&lt;-extracertsout&gt; I&lt;filename&gt;]
+[B&lt;-cacertsout&gt; I&lt;filename&gt;]
+
+[B&lt;-ref&gt; I&lt;value&gt;]
+[B&lt;-secret&gt; I&lt;arg&gt;]
+[B&lt;-cert&gt; I&lt;filename&gt;]
+[B&lt;-key&gt; I&lt;filename&gt;]
+[B&lt;-keypass&gt; I&lt;arg&gt;]
+[B&lt;-digest&gt; I&lt;name&gt;]
+[B&lt;-mac&gt; I&lt;name&gt;]
+[B&lt;-extracerts&gt; I&lt;sources&gt;]
+[B&lt;-unprotected_requests&gt;]
+
+[B&lt;-cmd&gt; I&lt;ir|cr|kur|p10cr|rr|genm&gt;]
+[B&lt;-infotype&gt; I&lt;name&gt;]
+[B&lt;-geninfo&gt; I&lt;OID:int:N&gt;]
+
+[B&lt;-newkey&gt; I&lt;filename&gt;]
+[B&lt;-newkeypass&gt; I&lt;arg&gt;]
+[B&lt;-subject&gt; I&lt;name&gt;]
+[B&lt;-issuer&gt; I&lt;name&gt;]
+[B&lt;-days&gt; I&lt;number&gt;]
+[B&lt;-reqexts&gt; I&lt;name&gt;]
+[B&lt;-sans&gt; I&lt;spec&gt;]
+[B&lt;-san_nodefault&gt;]
+[B&lt;-policies&gt; I&lt;name&gt;]
+[B&lt;-policy_oids&gt; I&lt;names&gt;]
+[B&lt;-policy_oids_critical&gt;]
+[B&lt;-popo&gt; I&lt;number&gt;]
+[B&lt;-csr&gt; I&lt;filename&gt;]
+[B&lt;-out_trusted&gt; I&lt;filenames&gt;]
+[B&lt;-verify_hostname&gt; I&lt;cn&gt;]
+[B&lt;-verify_ip&gt; I&lt;ip&gt;]
+[B&lt;-verify_email&gt; I&lt;email&gt;]
+[B&lt;-implicit_confirm&gt;]
+[B&lt;-disable_confirm&gt;]
+[B&lt;-certout&gt; I&lt;filename&gt;]
+
+[B&lt;-oldcert&gt; I&lt;filename&gt;]
+[B&lt;-revreason&gt; I&lt;number&gt;]
+
+[B&lt;-certform&gt; I&lt;PEM|DER&gt;]
+[B&lt;-keyform&gt; I&lt;PEM|DER|P12|ENGINE&gt;]
+[B&lt;-certsform&gt; I&lt;PEM|DER|P12&gt;]
+[B&lt;-otherpass&gt; I&lt;arg&gt;]
+[B&lt;-engine&gt; I&lt;id&gt;]
+{- $OpenSSL::safe::opt_provider_synopsis -}
+
+[B&lt;-tls_used&gt;]
+[B&lt;-tls_cert&gt; I&lt;filename&gt;]
+[B&lt;-tls_key&gt; I&lt;filename&gt;]
+[B&lt;-tls_keypass&gt; I&lt;arg&gt;]
+[B&lt;-tls_extra&gt; I&lt;filenames&gt;]
+[B&lt;-tls_trusted&gt; I&lt;filenames&gt;]
+[B&lt;-tls_host&gt; I&lt;name&gt;]
+
+[B&lt;-batch&gt;]
+[B&lt;-repeat&gt; I&lt;number&gt;]
+[B&lt;-reqin&gt;] I&lt;filenames&gt;
+[B&lt;-reqin_new_tid&gt;]
+[B&lt;-reqout&gt;] I&lt;filenames&gt;
+[B&lt;-rspin&gt;] I&lt;filenames&gt;
+[B&lt;-rspout&gt;] I&lt;filenames&gt;
+[B&lt;-use_mock_srv&gt;]
+
+[B&lt;-policy&gt; I&lt;arg&gt;]
+[B&lt;-purpose&gt; I&lt;purpose&gt;]
+[B&lt;-verify_name&gt; I&lt;name&gt;]
+[B&lt;-verify_depth&gt; I&lt;num&gt;]
+[B&lt;-auth_level&gt; I&lt;level&gt;]
+[B&lt;-attime&gt; I&lt;timestamp&gt;]
+[B&lt;-ignore_critical&gt;]
+[B&lt;-issuer_checks&gt;]
+[B&lt;-policy_check&gt;]
+[B&lt;-explicit_policy&gt;]
+[B&lt;-inhibit_any&gt;]
+[B&lt;-inhibit_map&gt;]
+[B&lt;-x509_strict&gt;]
+[B&lt;-extended_crl&gt;]
+[B&lt;-use_deltas&gt;]
+[B&lt;-policy_print&gt;]
+[B&lt;-check_ss_sig&gt;]
+[B&lt;-crl_check&gt;]
+[B&lt;-crl_check_all&gt;]
+[B&lt;-trusted_first&gt;]
+[B&lt;-suiteB_128_only&gt;]
+[B&lt;-suiteB_128&gt;]
+[B&lt;-suiteB_192&gt;]
+[B&lt;-partial_chain&gt;]
+[B&lt;-no_alt_chains&gt;]
+[B&lt;-no_check_time&gt;]
+[B&lt;-allow_proxy_certs&gt;]
+
+[B&lt;-port&gt; I&lt;number&gt;]
+[B&lt;-max_msgs&gt; I&lt;number&gt;]
+[B&lt;-srv_ref&gt; I&lt;value&gt;]
+[B&lt;-srv_secret&gt; I&lt;arg&gt;]
+[B&lt;-srv_cert&gt; I&lt;filename&gt;]
+[B&lt;-srv_key&gt; I&lt;filename&gt;]
+[B&lt;-srv_keypass&gt; I&lt;arg&gt;]
+[B&lt;-srv_trusted&gt; I&lt;filenames&gt;]
+[B&lt;-srv_untrusted&gt; I&lt;filenames&gt;]
+[B&lt;-rsp_cert&gt; I&lt;filename&gt;]
+[B&lt;-rsp_extracerts&gt; I&lt;filenames&gt;]
+[B&lt;-rsp_capubs&gt; I&lt;filenames&gt;]
+[B&lt;-poll_count&gt; I&lt;number&gt;]
+[B&lt;-check_after&gt; I&lt;number&gt;]
+[B&lt;-grant_implicitconf&gt;]
+[B&lt;-pkistatus&gt; I&lt;number&gt;]
+[B&lt;-failure&gt; I&lt;number&gt;]
+[B&lt;-failurebits&gt; I&lt;number&gt;]
+[B&lt;-statusstring&gt; I&lt;arg&gt;]
+[B&lt;-send_error&gt;]
+[B&lt;-send_unprotected&gt;]
+[B&lt;-send_unprot_err&gt;]
+[B&lt;-accept_unprotected&gt;]
+[B&lt;-accept_unprot_err&gt;]
+[B&lt;-accept_raverified&gt;]
+
+=head1 DESCRIPTION
+
+The B&lt;cmp&gt; command is a client implementation for the Certificate
+Management Protocol (CMP) as defined in RFC4210.
+It can be used to request certificates from a CA server,
+update their certificates,
+request certificates to be revoked, and perform other CMP requests.
+
+=head1 OPTIONS
+
+=over 4
+
+=item B&lt;-help&gt;
+
+Display a summary of all options
+
+=item B&lt;-config&gt; I&lt;filename&gt;
+
+Configuration file to use.
+An empty string C&lt;&quot;&quot;&gt; means none.
+Default filename is from the environment variable C&lt;OPENSSL_CONF&gt;.
+
+=item B&lt;-section&gt; I&lt;names&gt;
+
+Section(s) to use within config file defining CMP options.
+An empty string C&lt;&quot;&quot;&gt; means no specific section.
+Default is C&lt;cmp&gt;.
+Multiple section names may be given, separated by commas and/or whitespace
+(where in the latter case the whole argument must be enclosed in &quot;...&quot;).
+Contents of sections named later may override contents of sections named before.
+In any case, as usual, the C&lt;[default]&gt; section and finally the unnamed
+section (as far as present) can provide per-option fallback values.
+
+=back
+
+
+=head2 Generic message options
+
+=over 4
+
+=item B&lt;-cmd&gt; I&lt;ir|cr|kur|p10cr|rr|genm&gt;
+
+CMP command to execute.
+Currently implemented commands are:
+
+=over 8
+
+=item  ir E&lt;nbsp&gt;  - Initialization Request
+
+=item  cr E&lt;nbsp&gt;  - Certificate Request
+
+=item  p10cr - PKCS#10 Certification Request (for legacy support)
+
+=item  kur E&lt;nbsp&gt;E&lt;nbsp&gt;- Key Update Request
+
+=item  rr E&lt;nbsp&gt;  - Revocation Request
+
+=item  genm  - General Message
+
+=back
+
+B&lt;ir&gt; requests initialization of an End Entity into a PKI hierarchy by means of
+issuance of a first certificate.
+
+B&lt;cr&gt; requests issuance of an additional certificate for an End Entity already
+initialized to the PKI hierarchy.
+
+B&lt;p10cr&gt; requests issuance of an additional certificate similarly to B&lt;cr&gt;
+but uses PKCS#10 CSR format.
+
+B&lt;kur&gt; requests (key) update for an existing, given certificate.
+
+B&lt;rr&gt; requests revocation of an existing, given certificate.
+
+B&lt;genm&gt; requests information using a General Message, where optionally
+included B&lt;InfoTypeAndValue&gt;s may be used to state which info is of interest.
+Upon receipt of the General Response, information about all received
+ITAV B&lt;infoType&gt;s is printed to stdout.
+
+=item B&lt;-infotype&gt; I&lt;name&gt;
+
+Set InfoType name to use for requesting specific info in B&lt;genm&gt;,
+e.g., C&lt;signKeyPairTypes&gt;.
+
+=item B&lt;-geninfo&gt; I&lt;OID:int:N&gt;
+
+generalInfo integer values to place in request PKIHeader with given OID,
+e.g., C&lt;1.2.3:int:987&gt;.
+
+=back
+
+
+=head2 Certificate request options
+
+=over 4
+
+=item B&lt;-newkey&gt; I&lt;filename&gt;
+
+The file containing the private or public key for the certificate requested
+in Initialization Request (IR), Certification Request(CR), or
+Key Update Request (KUR).
+Default is the public key in the PKCS#10 CSR given with the B&lt;-csr&gt; option,
+if any, or else the current client key, if given.
+
+=item B&lt;-newkeypass&gt; I&lt;arg&gt;
+
+Pass phrase source for the key given with the B&lt;-newkey&gt; option.
+If not given here, the password will be prompted for if needed.
+
+For more information about the format of B&lt;arg&gt; see the
+B&lt;PASS PHRASE ARGUMENTS&gt; section in L&lt;openssl(1)&gt;.
+
+=item B&lt;-subject&gt; I&lt;name&gt;
+
+X509 Distinguished Name (DN) of subject to use in the requested certificate
+template.
+For KUR, it defaults to the subject DN of the reference certificate
+(see B&lt;-oldcert&gt;).
+This default is used for IR and CR only if no SANs are set.
+
+The argument must be formatted as I&lt;/type0=value0/type1=value1/type2=...&gt;,
+characters may be escaped by C&lt;\&gt;E&lt;nbsp&gt;(backslash), no spaces are skipped.
+
+In case B&lt;-cert&gt; is not set, for instance when using MSG_MAC_ALG,
+the subject DN is also used as sender of the PKI message.
+
+=item B&lt;-issuer&gt; I&lt;name&gt;
+
+X509 issuer Distinguished Name (DN) of the CA server
+to place in the requested certificate template in IR/CR/KUR.
+
+The argument must be formatted as I&lt;/type0=value0/type1=value1/type2=...&gt;,
+characters may be escaped by C&lt;\&gt;E&lt;nbsp&gt;(backslash), no spaces are skipped.
+
+If neither B&lt;-srvcert&gt; nor B&lt;-recipient&gt; is available,
+the name given in this option is also set as the recipient of the CMP message.
+
+=item B&lt;-days&gt; I&lt;number&gt;
+
+Number of days the new certificate is requested to be valid for, counting from
+the current time of the host.
+Also triggers the explicit request that the
+validity period starts from the current time (as seen by the host).
+
+=item B&lt;-reqexts&gt; I&lt;name&gt;
+
+Name of section in OpenSSL config file defining certificate request extensions.
+
+=item B&lt;-sans&gt; I&lt;spec&gt;
+
+One or more IP addresses, DNS names, or URIs separated by commas or whitespace
+(where in the latter case the whole argument must be enclosed in &quot;...&quot;)
+to add as Subject Alternative Name(s) (SAN) certificate request extension.
+If the special element &quot;critical&quot; is given the SANs are flagged as critical.
+Cannot be used if any Subject Alternative Name extension is set via B&lt;-reqexts&gt;.
+
+=item B&lt;-san_nodefault&gt;
+
+When Subject Alternative Names are not given via B&lt;-sans&gt;
+nor defined via B&lt;-reqexts&gt;,
+they are copied by default from the reference certificate (see B&lt;-oldcert&gt;).
+This can be disabled by giving the B&lt;-san_nodefault&gt; option.
+
+=item B&lt;-policies&gt; I&lt;name&gt;
+
+Name of section in OpenSSL config file defining policies to be set
+as certificate request extension.
+This option cannot be used together with B&lt;-policy_oids&gt;.
+
+=item B&lt;-policy_oids&gt; I&lt;names&gt;
+
+One or more OID(s), separated by commas and/or whitespace
+(where in the latter case the whole argument must be enclosed in &quot;...&quot;)
+to add as certificate policies request extension.
+This option cannot be used together with B&lt;-policies&gt;.
+
+=item B&lt;-policy_oids_critical&gt;
+
+Flag the policies given with B&lt;-policy_oids&gt; as critical.
+
+=item B&lt;-popo&gt; I&lt;number&gt;
+
+Proof-of-Possession (POPO) method to use for IR/CR/KUR; values: C&lt;-1&gt;..&lt;2&gt; where
+C&lt;-1&gt; = NONE, C&lt;0&gt; = RAVERIFIED, C&lt;1&gt; = SIGNATURE (default), C&lt;2&gt; = KEYENC.
+
+Note that a signature-based POPO can only be produced if a private key
+is provided via the B&lt;-newkey&gt; or B&lt;-key&gt; options.
+
+=item B&lt;-csr&gt; I&lt;filename&gt;
+
+CSR in PKCS#10 format to use in legacy P10CR messages.
+
+=item B&lt;-out_trusted&gt; I&lt;filenames&gt;
+
+Trusted certificate(s) to use for verifying the newly enrolled certificate.
+
+Multiple filenames may be given, separated by commas and/or whitespace
+(where in the latter case the whole argument must be enclosed in &quot;...&quot;).
+Each source may contain multiple certificates.
+
+=item B&lt;-verify_hostname&gt; I&lt;name&gt;
+
+When verification of the newly enrolled certificate is enabled (with the
+B&lt;-out_trusted&gt; option), check if any DNS Subject Alternative Name (or if no
+DNS SAN is included, the Common Name in the subject) equals the given B&lt;name&gt;.
+
+=item B&lt;-verify_ip&gt; I&lt;ip&gt;
+
+When verification of the newly enrolled certificate is enabled (with the
+B&lt;-out_trusted&gt; option), check if there is
+an IP address Subject Alternative Name matching the given IP address.
+
+=item B&lt;-verify_email&gt; I&lt;email&gt;
+
+When verification of the newly enrolled certificate is enabled (with the
+B&lt;-out_trusted&gt; option), check if there is
+an email address Subject Alternative Name matching the given email address.
+
+=item B&lt;-implicit_confirm&gt;
+
+Request implicit confirmation of newly enrolled certificates.
+
+=item B&lt;-disable_confirm&gt;
+
+Do not send certificate confirmation message for newly enrolled certificate
+without requesting implicit confirmation
+to cope with broken servers not supporting implicit confirmation correctly.
+B&lt;WARNING:&gt; This leads to behavior violating RFC 4210.
+
+=item B&lt;-certout&gt; I&lt;filename&gt;
+
+The file where the newly enrolled certificate should be saved.
+
+=back
+
+
+=head2 Certificate revocation options
+
+=over 4
+
+=item B&lt;-oldcert&gt; I&lt;filename&gt;
+
+The certificate to be updated (i.e., renewed or re-keyed) in Key Update Request
+(KUR) messages or to be revoked in Revocation Request (RR) messages.
+It must be given for RR, while for KUR it defaults to B&lt;-cert&gt;.
+
+The reference certificate determined in this way, if any, is also used for
+deriving default subject DN and Subject Alternative Names for IR, CR, and KUR.
+Its issuer, if any, is used as default recipient in the CMP message header
+if neither B&lt;-srvcert&gt;, B&lt;-recipient&gt;, nor B&lt;-issuer&gt; is available.
+
+=item B&lt;-revreason&gt; I&lt;number&gt;
+
+Set CRLReason to be included in revocation request (RR); values: C&lt;0&gt;..C&lt;10&gt;
+or C&lt;-1&gt; for none (which is the default).
+
+Reason numbers defined in RFC 5280 are:
+
+   CRLReason ::= ENUMERATED {
+        unspecified             (0),
+        keyCompromise           (1),
+        cACompromise            (2),
+        affiliationChanged      (3),
+        superseded              (4),
+        cessationOfOperation    (5),
+        certificateHold         (6),
+        -- value 7 is not used
+        removeFromCRL           (8),
+        privilegeWithdrawn      (9),
+        aACompromise           (10)
+    }
+
+=back
+
+
+=head2 Message transfer options
+
+=over 4
+
+=item B&lt;-server&gt; I&lt;[http[s]://]address[:port]&gt;
+
+The IP address or DNS hostname and optionally port (defaulting to 80 or 443)
+of the CMP server to connect to using HTTP(S) transport.
+The optional &quot;<A HREF="http://">http://</A>&quot; or &quot;<A HREF="https://">https://</A>&quot; prefix is ignored.
+
+=item B&lt;-proxy&gt; I&lt;[http[s]://]address[:port][/path]&gt;
+
+The HTTP(S) proxy server to use for reaching the CMP server unless B&lt;no_proxy&gt;
+applies, see below.
+The optional &quot;<A HREF="http://">http://</A>&quot; or &quot;<A HREF="https://">https://</A>&quot; prefix and any trailing path are ignored.
+Defaults to the environment variable C&lt;http_proxy&gt; if set, else C&lt;HTTP_PROXY&gt;
+in case no TLS is used, otherwise C&lt;https_proxy&gt; if set, else C&lt;HTTPS_PROXY&gt;.
+
+=item B&lt;-no_proxy&gt; I&lt;addresses&gt;
+List of IP addresses and/or DNS names of servers
+not to use an HTTP(S) proxy for, separated by commas and/or whitespace
+(where in the latter case the whole argument must be enclosed in &quot;...&quot;).
+Default is from the environment variable C&lt;no_proxy&gt; if set, else C&lt;NO_PROXY&gt;.
+
+=item B&lt;-path&gt; I&lt;remote_path&gt;
+
+HTTP path at the CMP server (aka CMP alias) to use for POST requests.
+Defaults to &quot;/&quot;.
+
+=item B&lt;-msg_timeout&gt; I&lt;seconds&gt;
+
+Number of seconds (or 0 for infinite) a CMP request-response message round trip
+is allowed to take before a timeout error is returned.
+Default is 120.
+
+=item B&lt;-total_timeout&gt; I&lt;seconds&gt;
+
+Maximum number seconds an overall enrollment transaction may take,
+including attempts polling for certificates on C&lt;waiting&gt; PKIStatus.
+Default is 0 (infinite).
+
+=back
+
+
+=head2 Server authentication options
+
+=over 4
+
+=item B&lt;-trusted&gt; I&lt;filenames&gt;
+
+When verifying signature-based protection of CMP response messages,
+these are the CA certificate(s) to trust while checking certificate chains
+during CMP server authentication.
+This option gives more flexibility than the B&lt;-srvcert&gt; option because
+it does not pin down the expected CMP server by allowing only one certificate.
+
+Multiple filenames may be given, separated by commas and/or whitespace
+(where in the latter case the whole argument must be enclosed in &quot;...&quot;).
+Each source may contain multiple certificates.
+
+=item B&lt;-untrusted&gt; I&lt;sources&gt;
+
+Non-trusted intermediate certificate(s) that may be useful
+for constructing the TLS client certificate chain (if TLS is enabled) and
+for building certificate chains while verifying the CMP server certificate
+(when checking signature-based CMP message protection)
+and while verifying the newly enrolled certificate.
+These may get added to the extraCerts field sent in requests as far as needed.
+
+Multiple filenames may be given, separated by commas and/or whitespace.
+Each file may contain multiple certificates.
+
+=item B&lt;-srvcert&gt; I&lt;filename&gt;
+
+The specific CMP server certificate to use and directly trust (even if it is
+expired) when verifying signature-based protection of CMP response messages.
+May be set alternatively to the B&lt;-trusted&gt; option
+if the certificate is available and only this one shall be accepted.
+
+If set, the issuer of the certificate is also used as the recipient of the CMP
+request and as the expected sender of the CMP response,
+overriding any potential B&lt;-recipient&gt; option.
+
+=item B&lt;-recipient&gt; I&lt;name&gt;
+
+This option may be used to explicitly set the Distinguished Name (DN)
+of the CMP message recipient, i.e., the CMP server (usually a CA or RA entity).
+
+The argument must be formatted as I&lt;/type0=value0/type1=value1/type2=...&gt;,
+characters may be escaped by C&lt;\&gt;E&lt;nbsp&gt;(backslash), no spaces are skipped.
+
+If a CMP server certificate is given with the B&lt;-srvcert&gt; option, its subject
+name is taken as the recipient name and the B&lt;-recipient&gt; option is ignored.
+If neither of the two are given, the recipient of the PKI message is
+determined in the following order: from the B&lt;-issuer&gt; option if present,
+the issuer of old cert given with the B&lt;-oldcert&gt; option if present,
+the issuer of the client certificate (B&lt;-cert&gt; option) if present.
+
+The recipient field in the header of CMP messagese is mandatory.
+If none of the options that enable the derivation of the recipient name are
+given, no suitable value for the recipient in the PKIHeader is available.
+As a last resort it is set to NULL-DN.
+
+When a response is received, its sender must match the recipient of the request.
+
+=item B&lt;-expect_sender&gt; I&lt;name&gt;
+
+Distinguished Name (DN) of the expected sender of CMP response messages when
+MSG_SIG_ALG is used for protection.
+This can be used to ensure that only a particular entity is accepted
+as the CMP server, and attackers are not able to use arbitrary certificates
+of a trusted PKI hierarchy to fraudulently pose as a CMP server.
+Note that this option gives slightly more freedom than B&lt;-srvcert&gt;,
+which pins down the server to a particular certificate,
+while B&lt;-expect_sender&gt; I&lt;name&gt; will continue to match after updates of the
+server cert.
+
+The argument must be formatted as I&lt;/type0=value0/type1=value1/type2=...&gt;,
+characters may be escaped by C&lt;\&gt;E&lt;nbsp&gt;(backslash), no spaces are skipped.
+
+If not given, the subject DN of B&lt;-srvcert&gt;, if provided, will be used.
+
+=item B&lt;-ignore_keyusage&gt;
+
+Ignore key usage restrictions in CMP signer certificates when verifying
+signature-based protection of incoming CMP messages,
+else C&lt;digitalSignature&gt; must be allowed for signer certificate.
+
+=item B&lt;-unprotected_errors&gt;
+
+Accept missing or invalid protection of negative responses from the server.
+This applies to the following message types and contents:
+
+=over 4
+
+=item * error messages
+
+=item * negative certificate responses (IP/CP/KUP)
+
+=item * negative revocation responses (RP)
+
+=item * negative PKIConf messages
+
+=back
+
+B&lt;WARNING:&gt; This setting leads to unspecified behavior and it is meant
+exclusively to allow interoperability with server implementations violating
+RFC 4210, e.g.:
+
+=over 4
+
+=item * section 5.1.3.1 allows exceptions from protecting only for special
+cases:
+&quot;There MAY be cases in which the PKIProtection BIT STRING is deliberately not
+used to protect a message [...] because other protection, external to PKIX, will
+be applied instead.&quot;
+
+=item * section 5.3.21 is clear on ErrMsgContent: &quot;The CA MUST always sign it
+with a signature key.&quot;
+
+=item * appendix D.4 shows PKIConf message having protection
+
+=back
+
+=item B&lt;-extracertsout&gt; I&lt;filename&gt;
+
+The file where to save any extra certificates received in the extraCerts field
+of response messages.
+
+=item B&lt;-cacertsout&gt; I&lt;filename&gt;
+
+The file where to save any CA certificates received in the caPubs field of
+Initializiation Response (IP) messages.
+
+=back
+
+
+=head2 Client authentication options
+
+=over 4
+
+=item B&lt;-ref&gt; I&lt;value&gt;
+
+Reference number/string/value to use as fallback senderKID; this is required
+if no sender name can be determined from the B&lt;-cert&gt; or &lt;-subject&gt; options and
+is typically used when authenticating with pre-shared key (password-based MAC).
+
+=item B&lt;-secret&gt; I&lt;arg&gt;
+
+Source of secret value to use for creating PBM-based protection of outgoing
+messages and for verifying any PBM-based protection of incoming messages.
+PBM stands for Password-Based Message Authentication Code.
+This takes precedence over the B&lt;-cert&gt; option.
+
+For more information about the format of B&lt;arg&gt; see the
+B&lt;PASS PHRASE ARGUMENTS&gt; section in L&lt;openssl(1)&gt;.
+
+=item B&lt;-cert&gt; I&lt;filename&gt;
+
+The client's current certificate.
+Requires the corresponding key to be given with B&lt;-key&gt;.
+The subject of this certificate will be used as the &quot;sender&quot; field
+of outgoing CMP messages, while B&lt;-subjectName&gt; may provide a fallback value.
+When using signature-based message protection, this &quot;protection certificate&quot;
+will be included first in the extraCerts field of outgoing messages.
+In Initialization Request (IR) messages this can be used for authenticating
+using an external entity certificate as defined in appendix E.7 of RFC 4210.
+For Key Update Request (KUR) messages this is also used as
+the certificate to be updated if the B&lt;-oldcert&gt; option is not given.
+If the file includes further certs, they are appended to the untrusted certs.
+These may get added to the extraCerts field sent in requests as far as needed.
+
+=item B&lt;-key&gt; I&lt;filename&gt;
+
+The corresponding private key file for the client's current certificate given in
+the B&lt;-cert&gt; option.
+This will be used for signature-based message protection unless
+the B&lt;-secret&gt; option indicating PBM or B&lt;-unprotected_requests&gt; is given.
+
+=item B&lt;-keypass&gt; I&lt;arg&gt;
+
+Pass phrase source for the private key given with the B&lt;-key&gt; option.
+Also used for B&lt;-cert&gt; and B&lt;-oldcert&gt; in case it is an encrypted PKCS#12 file.
+If not given here, the password will be prompted for if needed.
+
+For more information about the format of B&lt;arg&gt; see the
+B&lt;PASS PHRASE ARGUMENTS&gt; section in L&lt;openssl(1)&gt;.
+
+=item B&lt;-digest&gt; I&lt;name&gt;
+
+Specifies name of supported digest to use in RFC 4210's MSG_SIG_ALG
+and as the one-way function (OWF) in MSG_MAC_ALG.
+If applicable, this is used for message protection and
+Proof-of-Possession (POPO) signatures.
+To see the list of supported digests, use B&lt;openssl list -digest-commands&gt;.
+Defaults to C&lt;sha256&gt;.
+
+=item B&lt;-mac&gt; I&lt;name&gt;
+
+Specifies the name of the MAC algorithm in MSG_MAC_ALG.
+To get the names of supported MAC algorithms use B&lt;openssl list -mac-algorithms&gt;
+and possibly combine such a name with the name of a supported digest algorithm,
+e.g., hmacWithSHA256.
+Defaults to C&lt;hmac-sha1&gt; as per RFC 4210.
+
+=item B&lt;-extracerts&gt; I&lt;sources&gt;
+
+Certificates to append in the extraCerts field when sending messages.
+
+Multiple filenames or URLs may be given, separated by commas and/or whitespace
+(where in the latter case the whole argument must be enclosed in &quot;...&quot;).
+Each source may contain multiple certificates.
+
+=item B&lt;-unprotected_requests&gt;
+
+Send messages without CMP-level protection.
+
+=back
+
+
+=head2 Credentials format options
+
+=over 4
+
+=item B&lt;-certform&gt; I&lt;PEM|DER&gt;
+
+File format to use when saving a certificate to a file.
+Default value is PEM.
+
+=item B&lt;-keyform&gt; I&lt;PEM|DER|P12&gt;
+
+Format to assume when reading key files.
+Default value is PEM.
+
+=item B&lt;-certsform&gt; I&lt;PEM|DER|P12&gt;
+
+Format to try first when reading multiple certificates from file(s).
+Default value is PEM.
+
+=item B&lt;-otherpass&gt; I&lt;arg&gt;
+
+Pass phrase source for certificate given with the B&lt;-trusted&gt;, B&lt;-untrusted&gt;,
+B&lt;-out_trusted&gt;, B&lt;-extracerts&gt;, B&lt;-tls_extra&gt;, or B&lt;-tls_trusted&gt; options.
+If not given here, the password will be prompted for if needed.
+
+For more information about the format of B&lt;arg&gt; see the
+B&lt;PASS PHRASE ARGUMENTS&gt; section in L&lt;openssl(1)&gt;.
+
+=item B&lt;-engine&gt; I&lt;id&gt;
+
+Specifying a crypto engine B&lt;id&gt; will lead to obtaining a functional
+reference to the specified engine, initializing it if needed.
+The engine will be used for all algorithms supported for keys
+prefixed by C&lt;engine:&gt;.
+Engines may be defined in the OpenSSL config file as usual in an engine section.
+
+Options specifying keys, like B&lt;-key&gt;, B&lt;-newkey&gt;, B&lt;-tls_key&gt; can prefix
+C&lt;engine:&gt; to engine-specific identifiers for security tokens objects held by
+the engine.
+ The following example utilizes the RFC 7512 PKCS #11 URI scheme
+as supported, e.g., by libp11:
+C&lt;-key engine:pkcs11:object=my-private-key;type=private;pin-value=1234&gt;
+
+{- $OpenSSL::safe::opt_provider_item -}
+
+=back
+
+
+=head2 TLS options
+
+=over 4
+
+=item B&lt;-tls_used&gt;
+
+Enable using TLS (even when other TLS_related options are not set)
+when connecting to CMP server.
+
+=item B&lt;-tls_cert&gt; I&lt;filename&gt;
+
+Client's TLS certificate.
+If the file includes further certificates,
+they are used for constructing the client cert chain provided to the TLS server.
+
+=item B&lt;-tls_key&gt; I&lt;filename&gt;
+
+Private key for the client's TLS certificate.
+
+=item B&lt;-tls_keypass&gt; I&lt;arg&gt;
+
+Pass phrase source for client's private TLS key B&lt;tls_key&gt;.
+Also used for B&lt;-tls_cert&gt; in case it is an encrypted PKCS#12 file.
+If not given here, the password will be prompted for if needed.
+
+For more information about the format of B&lt;arg&gt; see the
+B&lt;PASS PHRASE ARGUMENTS&gt; section in L&lt;openssl(1)&gt;.
+
+=item B&lt;-tls_extra&gt; I&lt;filenames&gt;
+
+Extra certificates to provide to TLS server during TLS handshake
+
+=item B&lt;-tls_trusted&gt; I&lt;filenames&gt;
+
+Trusted certificate(s) to use for verifying the TLS server certificate.
+This implies hostname validation.
+
+Multiple filenames may be given, separated by commas and/or whitespace
+(where in the latter case the whole argument must be enclosed in &quot;...&quot;).
+Each source may contain multiple certificates.
+
+=item B&lt;-tls_host&gt; I&lt;name&gt;
+
+Address to be checked during hostname validation. 
+This may be a DNS name or an IP address.
+If not given it defaults to the B&lt;-server&gt; address.
+
+=back
+
+
+=head2 Client-side debugging options
+
+=over 4
+
+=item B&lt;-batch&gt;
+
+Do not interactively prompt for input, for instance when a password is needed.
+This can be useful for batch processing and testing.
+
+=item B&lt;-repeat&gt; I&lt;number&gt;
+
+Invoke the command the given number of times with the same parameters.
+Default is one invocation.
+
+=item B&lt;-reqin&gt; I&lt;filenames&gt;
+
+Take sequence of CMP requests from file(s).
+Multiple filenames may be given, separated by commas and/or whitespace
+(where in the latter case the whole argument must be enclosed in &quot;...&quot;).
+As many files are read as needed for a complete transaction.
+
+=item B&lt;-reqin_new_tid&gt;
+
+Use a fresh transactionID for CMP request messages read using B&lt;-reqin&gt;,
+which requires re-protecting them as far as they were protected before.
+This may be needed in case the sequence of requests is reused
+and the CMP server complains that the transaction ID has already been used.
+
+=item B&lt;-reqout&gt; I&lt;filenames&gt;
+
+Save sequence of CMP requests to file(s).
+Multiple filenames may be given, separated by commas and/or whitespace.
+As many files are written as needed to store the complete transaction.
+
+=item B&lt;-rspin&gt; I&lt;filenames&gt;
+
+Process sequence of CMP responses provided in file(s), skipping server.
+Multiple filenames may be given, separated by commas and/or whitespace.
+As many files are read as needed for the complete transaction.
+
+=item B&lt;-rspout&gt; I&lt;filenames&gt;
+
+Save sequence of CMP responses to file(s).
+Multiple filenames may be given, separated by commas and/or whitespace.
+As many files are written as needed to store the complete transaction.
+
+=item B&lt;-use_mock_srv&gt;
+
+Use the internal mock server for testing the client.
+This works at API level, bypassing HTTP transport.
+
+=back
+
+
+=head2 Certificate verification options, for both CMP and TLS
+
+=over 4
+
+=item B&lt;-policy&gt;, B&lt;-purpose&gt;, B&lt;-verify_name&gt;, B&lt;-verify_depth&gt;,
+B&lt;-attime&gt;,
+B&lt;-ignore_critical&gt;, B&lt;-issuer_checks&gt;,
+B&lt;-policy_check&gt;,
+B&lt;-explicit_policy&gt;, B&lt;-inhibit_any&gt;, B&lt;-inhibit_map&gt;,
+B&lt;-x509_strict&gt;, B&lt;-extended_crl&gt;, B&lt;-use_deltas&gt;,
+B&lt;-policy_print&gt;, B&lt;-check_ss_sig&gt;, B&lt;-crl_check&gt;, B&lt;-crl_check_all&gt;,
+B&lt;-trusted_first&gt;,
+B&lt;-suiteB_128_only&gt;, B&lt;-suiteB_128&gt;, B&lt;-suiteB_192&gt;,
+B&lt;-partial_chain&gt;, B&lt;-no_alt_chains&gt;, B&lt;-no_check_time&gt;,
+B&lt;-auth_level&gt;,
+B&lt;-allow_proxy_certs&gt;
+
+Set various options of certificate chain verification.
+See L&lt;openssl(1)/Verification Options&gt; for details.
+
+=back
+
+
+=head2 Mock server options, for testing purposes only
+
+=over 4
+
+=item B&lt;-port&gt; I&lt;number&gt;
+
+Act as CMP HTTP server mock-up listening on the given port.
+
+=item B&lt;-max_msgs&gt; I&lt;number&gt;
+
+Maximum number of CMP (request) messages the CMP HTTP server mock-up
+should handle, which must be non-negative.
+The default value is 0, which means that no limit is imposed.
+In any case the server terminates on internal errors, but not when it
+detects a CMP-level error that it can successfully answer with an error message.
+
+=item B&lt;-srv_ref&gt; I&lt;value&gt;
+
+Reference value to use as senderKID of server in case no B&lt;-srv_cert&gt; is given.
+
+=item B&lt;-srv_secret&gt; I&lt;arg&gt;
+
+Password source for server authentication with a pre-shared key (secret).
+
+=item B&lt;-srv_cert&gt; I&lt;filename&gt;
+
+Certificate of the server.
+
+=item B&lt;-srv_key&gt; I&lt;filename&gt;
+
+Private key used by the server for signing messages.
+
+=item B&lt;-srv_keypass&gt; I&lt;arg&gt;
+
+Server private key (and cert) file pass phrase source.
+
+=item B&lt;-srv_trusted&gt; I&lt;filenames&gt;
+
+Trusted certificates for client authentication.
+
+=item B&lt;-srv_untrusted&gt; I&lt;filenames&gt;
+
+Intermediate CA certs that may be useful when verifying client certificates.
+
+=item B&lt;-rsp_cert&gt; I&lt;filename&gt;
+
+Certificate to be returned as mock enrollment result.
+
+=item B&lt;-rsp_extracerts&gt; I&lt;filenames&gt;
+
+Extra certificates to be included in mock certification responses.
+
+=item B&lt;-rsp_capubs&gt; I&lt;filenames&gt;
+
+CA certificates to be included in mock Initialization Response (IP) message.
+
+=item B&lt;-poll_count&gt; I&lt;number&gt;
+
+Number of times the client must poll before receiving a certificate.
+
+=item B&lt;-check_after&gt; I&lt;number&gt;
+
+The checkAfter value (number of seconds to wait) to include in poll response.
+
+
+=item B&lt;-grant_implicitconf&gt;
+
+Grant implicit confirmation of newly enrolled certificate.
+
+=item B&lt;-pkistatus&gt; I&lt;number&gt;
+
+PKIStatus to be included in server response.
+Valid range is 0 (accepted) .. 6 (keyUpdateWarning).
+
+=item B&lt;-failure&gt; I&lt;number&gt;
+
+A single failure info bit number to be included in server response.
+Valid range is 0 (badAlg) .. 26 (duplicateCertReq).
+
+=item B&lt;-failurebits&gt; I&lt;number&gt;
+Number representing failure bits to be included in server response.
+Valid range is 0 .. 2^27 - 1.
+
+=item B&lt;-statusstring&gt; I&lt;arg&gt;
+
+Text to be included as status string in server response.
+
+=item B&lt;-send_error&gt;
+
+Force server to reply with error message.
+
+=item B&lt;-send_unprotected&gt;
+
+Send response messages without CMP-level protection.
+
+=item B&lt;-send_unprot_err&gt;
+
+In case of negative responses, server shall send unprotected error messages,
+certificate responses (IP/CP/KUP), and revocation responses (RP).
+WARNING: This setting leads to behavior violating RFC 4210.
+
+=item B&lt;-accept_unprotected&gt;
+
+Accept missing or invalid protection of requests.
+
+=item B&lt;-accept_unprot_err&gt;
+
+Accept unprotected error messages from client.
+
+=item B&lt;-accept_raverified&gt;
+
+Accept RAVERIFED as proof-of-possession (POPO).
+
+=back
+
+
+=head1 NOTES
+
+When setting up CMP configurations and experimenting with enrollment options
+typically various errors occur until the configuration is correct and complete.
+When the CMP server reports an error the client will by default
+check the protection of the CMP response message.
+Yet some CMP services tend not to protect negative responses.
+In this case the client will reject them, and thus their contents are not shown
+although they usually contain hints that would be helpful for diagnostics.
+For assisting in such cases the CMP client offers a workaround via the
+B&lt;-unprotected_errors&gt; option, which allows accepting such negative messages.
+
+
+=head1 EXAMPLES
+
+=head2 Simple examples using the default OpenSSL configuration file
+
+This CMP client implementation comes with demonstrative CMP sections
+in the example configuration file F&lt;openssl/apps/openssl.cnf&gt;,
+which can be used to interact conveniently with the Insta Demo CA.
+
+In order to enroll an initial certificate from that CA it is sufficient
+to issue the following shell commands.
+
+  cd /path/to/openssl
+  export OPENSSL_CONF=openssl.cnf
+  wget '<A HREF="http://pki.certificate.fi:8080/install-ca-cert.html/ca-certificate.crt\">http://pki.certificate.fi:8080/install-ca-cert.html/ca-certificate.crt\</A>
+        ?ca-id=632&amp;download-certificate=1' -O insta.ca.crt
+  openssl genrsa -out insta.priv.pem
+  openssl cmp -section insta
+
+This should produce the file F&lt;insta.cert.pem&gt; containing a new certificate
+for the private key held in F&lt;insta.priv.pem&gt;.
+It can be viewed using, e.g.,
+
+  openssl x509 -noout -text -in insta.cert.pem
+
+In case the network setup requires using an HTTP proxy it may be given as usual
+via the environment variable B&lt;http_proxy&gt; or via the B&lt;proxy&gt; option or
+the CMP command-line argument B&lt;-proxy&gt;, for example
+
+  -proxy <A HREF="http://192.168.1.1:8080">http://192.168.1.1:8080</A>
+
+In the Insta Demo CA scenario both clients and the server may use the pre-shared
+secret &quot;insta&quot; and the reference value &quot;3078&quot; to authenticate to each other.
+
+Alternatively, CMP messages may be protected in signature-based manner,
+where the trust anchor in this case is F&lt;insta.ca.crt&gt;
+and the client may use any certificate already obtained from that CA,
+as specified in the B&lt;[signature]&gt; section of the example configuration.
+This can be used in combination with the B&lt;[insta]&gt; section simply by
+
+  openssl cmp -section insta,signature
+
+By default the CMP IR message type is used, yet CR works equally here.
+This may be specified directly at the command line:
+
+  openssl cmp -section insta -cmd cr
+
+or by referencing in addition the B&lt;[cr]&gt; section of the example configuration:
+
+  openssl cmp -section insta,cr
+
+In order to update the enrolled certificate one may call
+
+  openssl cmp -section insta,kur
+
+using with PBM-based protection or
+
+  openssl cmp -section insta,kur,signature
+
+using signature-based protection.
+
+In a similar way any previously enrolled certificate may be revoked by
+
+  openssl cmp -section insta,rr -trusted insta.ca.crt
+
+or
+
+  openssl cmp -section insta,rr,signature
+
+Many more options can be used in the configuration file
+and/or on the command line.
+
+
+=head2 Certificate enrollment
+
+The following examples at first do not make use of a configuration file.
+They assume that a CMP server can be contacted on the local TCP port 80
+and accepts requests under the alias &quot;/pkix/&quot;.
+
+For enrolling its very first certificate the client generates a first client key
+and sends an initial request message to the local CMP server
+using a pre-shared secret key for mutual authentication.
+In this example the client does not have the CA certificate yet,
+so we specify the name of the CA with the B&lt;-recipient&gt; option
+and save any CA certificates that we may receive in the C&lt;capubs.pem&gt; file.
+
+In below command line usage examples the C&lt;\&gt; at line ends is just used
+for formatting; each of the command invocations should be on a single line.
+
+  openssl genrsa -out cl_key.pem
+  openssl cmp -cmd ir -server 127.0.0.1:80 -path pkix/ \
+    -ref 1234 -secret pass:1234-5678-1234-5678 \
+    -recipient &quot;/CN=CMPserver&quot; \
+    -newkey cl_key.pem -subject &quot;/CN=MyName&quot; \
+    -cacertsout capubs.pem -certout cl_cert.pem
+
+
+=head2 Certificate update
+
+Then, when the client certificate and its related key pair needs to be updated,
+the client can send a key update request taking the certs in C&lt;capubs.pem&gt;
+as trusted for authenticating the server and using the previous cert and key
+for its own authentication.
+Then it can start using the new cert and key.
+
+  openssl genrsa -out cl_key_new.pem
+  openssl cmp -cmd kur -server 127.0.0.1:80 -path pkix/ \
+    -trusted capubs.pem \
+    -cert cl_cert.pem -key cl_key.pem \
+    -newkey cl_key_new.pem -certout cl_cert.pem
+  cp cl_key_new.pem cl_key.pem
+
+This command sequence can be repated as often as needed.
+
+
+=head2 Requesting information from CMP server
+
+Requesting &quot;all relevant information&quot; with an empty General Message.
+This prints information about all received ITAV B&lt;infoType&gt;s to stdout.
+
+  openssl cmp -cmd genm -server 127.0.0.1 -path pkix/ \
+    -ref 1234 -secret pass:1234-5678-1234-5678 \
+    -recipient &quot;/CN=CMPserver&quot;
+
+
+=head2 Using a custom configuration file
+
+For CMP client invocations, in particular for certificate enrollment,
+usually many parameters need to be set, which is tedious and error-prone to do
+on the command line.
+Therefore the client offers the possibility to read
+options from sections of the OpenSSL config file, usually called B&lt;openssl.cnf&gt;.
+The values found there can still be extended and even overridden by any
+subsequently loaded sections and on the command line.
+
+After including in the configuration file the following sections:
+
+  [cmp]
+  server = 127.0.0.1
+  path = pkix/
+  trusted = capubs.pem
+  cert = cl_cert.pem
+  key = cl_key.pem
+  newkey = cl_key.pem
+  certout = cl_cert.pem
+
+  [cmp-init]
+  recipient = &quot;/CN=CMPserver&quot;
+  trusted =
+  cert =
+  key =
+  ref = 1234
+  secret = pass:1234-5678-1234-567
+  subject = &quot;/CN=MyName&quot;
+  cacertsout = capubs.pem
+
+the above enrollment invocations reduce to
+
+  openssl cmp -section cmp,cmp-init
+  openssl cmp -cmd kur -newkey cl_key_new.pem
+
+and the above genm call reduces to
+
+  openssl cmp -section cmp,cmp-init -cmd genm
+
+=head1 SEE ALSO
+
+L&lt;openssl-genrsa(1)&gt;, L&lt;openssl-ecparam(1)&gt;, L&lt;openssl-list(1)&gt;,
+L&lt;openssl-req(1)&gt;, L&lt;openssl-x509(1)&gt;, L&lt;x509v3_config(5)&gt;
+
+=head1 COPYRIGHT
+
+Copyright 2007-2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man3/OSSL_CMP_CTX_new.pod b/doc/man3/OSSL_CMP_CTX_new.pod
index 354965b7d4..c8eacfc3d9 100644
--- a/doc/man3/OSSL_CMP_CTX_new.pod
+++ b/doc/man3/OSSL_CMP_CTX_new.pod
@@ -28,7 +28,7 @@ OSSL_CMP_CTX_set0_trustedStore,
 OSSL_CMP_CTX_get0_trustedStore,
 OSSL_CMP_CTX_set1_untrusted_certs,
 OSSL_CMP_CTX_get0_untrusted_certs,
-OSSL_CMP_CTX_set1_clCert,
+OSSL_CMP_CTX_set1_cert,
 OSSL_CMP_CTX_set1_pkey,
 OSSL_CMP_CTX_set1_referenceValue,
 OSSL_CMP_CTX_set1_secretValue,
@@ -102,7 +102,7 @@ OSSL_CMP_CTX_set1_senderNonce
  STACK_OF(X509) *OSSL_CMP_CTX_get0_untrusted_certs(const OSSL_CMP_CTX *ctx);
 
  /* client authentication: */
- int OSSL_CMP_CTX_set1_clCert(OSSL_CMP_CTX *ctx, X509 *cert);
+ int OSSL_CMP_CTX_set1_cert(OSSL_CMP_CTX *ctx, X509 *cert);
  int OSSL_CMP_CTX_set1_pkey(OSSL_CMP_CTX *ctx, EVP_PKEY *pkey);
  int OSSL_CMP_CTX_set1_referenceValue(OSSL_CMP_CTX *ctx,
                                       const unsigned char *ref, int len);
@@ -226,18 +226,18 @@ The following options can be set:
 
 =item B&lt;OSSL_CMP_OPT_DIGEST_ALGNID&gt;
 
-        The digest algorithm NID to be used in RFC 4210's MSG_SIG_ALG,
-        if applicable used for message protection and Proof-of-Possession.
+        The NID of the digest algorithm to be used in RFC 4210's MSG_SIG_ALG
+        for signature-based message protection and Proof-of-Possession (POPO).
         Default is SHA256.
 
-    OSSL_CMP_OPT_OWF_ALGNID
-        The digest algorithm NID to be used as one-way function (OWF)
-        in RFC 4210's MSG_MAC_ALG, if applicable used for message protection.
+=item B&lt;OSSL_CMP_OPT_OWF_ALGNID&gt;
+        The NID of the digest algorithm to be used as one-way function (OWF)
+        in RFC 4210's MSG_MAC_ALG for PBM-based message protection.
         Default is SHA256.
 
-    OSSL_CMP_OPT_MAC_ALGNID
-        The MAC algorithm NID to be used in RFC 4210's MSG_MAC_ALG,
-        if applicable used for message protection.
+=item B&lt;OSSL_CMP_OPT_MAC_ALGNID&gt;
+        The NID of the MAC algorithm to be used in RFC 4210's MSG_MAC_ALG
+        for PBM-based message protection.
         Default is HMAC-SHA1 as per RFC 4210.
 
 =item B&lt;OSSL_CMP_OPT_REVOCATION_REASON&gt;
@@ -403,26 +403,26 @@ parameter the entry is cleared.
 OSSL_CMP_CTX_get0_trustedStore() returns a pointer to the certificate store
 containing trusted root CA certificates, which may be empty if unset.
 
-OSSL_CMP_CTX_set1_untrusted_certs() takes over a list of certificates containing
-non-trusted intermediate certs used for path construction in authentication
-of the CMP server and potentially others (TLS server, newly enrolled cert).
+OSSL_CMP_CTX_set1_untrusted_certs() sets up a list of non-trusted certificates
+of intermediate CAs that may be useful for path construction when authenticating
+the CMP server and when verifying newly enrolled certificates.
 The reference counts of those certificates handled successfully are increased.
 
 OSSL_CMP_CTX_get0_untrusted_certs(OSSL_CMP_CTX *ctx) returns a pointer to the
-list of untrusted certs, which my be empty if unset.
+list of untrusted certs, which may be empty if unset.
 
-OSSL_CMP_CTX_set1_clCert() sets the client certificate in the given B&lt;ctx&gt;.
-The public key of this B&lt;clCert&gt; must correspond to
+OSSL_CMP_CTX_set1_cert() sets the certificate used for CMP message protection.
+The public key of this B&lt;cert&gt; must correspond to
 the private key set via B&lt;OSSL_CMP_CTX_set1_pkey()&gt;.
 When using signature-based protection of CMP request messages
 this &quot;protection certificate&quot; will be included first in the extraCerts field.
-The subject of this B&lt;clCert&gt; will be used as the &quot;sender&quot; field
+The subject of this B&lt;cert&gt; will be used as the &quot;sender&quot; field
 of outgoing CMP messages, with the fallback being
 the B&lt;subjectName&gt; set via B&lt;OSSL_CMP_CTX_set1_subjectName()&gt;.
 The B&lt;cert&gt; argument may be NULL to clear the entry.
 
-OSSL_CMP_CTX_set1_pkey() sets the private key corresponding to
-the client certificate B&lt;clCert&gt; set via B&lt;OSSL_CMP_CTX_set1_clCert()&gt;.
+OSSL_CMP_CTX_set1_pkey() sets the private key corresponding to the
+protecting certificate B&lt;cert&gt; set via B&lt;OSSL_CMP_CTX_set1_cert()&gt;.
 This key is used create signature-based protection (protectionAlg = MSG_SIG_ALG)
 of outgoing messages
 unless a PBM secret has been set via  B&lt;OSSL_CMP_CTX_set1_secretValue()&gt;.
@@ -438,11 +438,11 @@ PBM-based protection takes precedence over signature-based protection.
 OSSL_CMP_CTX_set1_referenceValue() sets the given referenceValue B&lt;ref&gt; with
 length B&lt;len&gt; in the given B&lt;ctx&gt; or clears it if the B&lt;ref&gt; argument is NULL.
 According to RFC 4210 section 5.1.1, if no value for the &quot;sender&quot; field in
-CMP message headers can be determined (i.e., no B&lt;clCert&gt; and no B&lt;subjectName&gt;
-is given) then the &quot;sender&quot; field will contain the NULL-DN
+CMP message headers can be determined (i.e., no protecting certificate B&lt;cert&gt;
+and no B&lt;subjectName&gt; is given) then the &quot;sender&quot; field will contain the NULL-DN
 and the senderKID field of the CMP message header must be set.
 When signature-based protection is used the senderKID will be set to
-the subjectKeyIdentifier of the &lt;clCert&gt; as far as present.
+the subjectKeyIdentifier of the protecting B&lt;cert&gt; as far as present.
 If not present or when PBM-based protection is used
 the B&lt;ref&gt; value is taken as the fallback value for the senderKID.
 
@@ -451,7 +451,7 @@ PKIHeader of a request message, i.e. the X509 name of the (CA) server.
 Setting is overruled by subject of B&lt;srvCert&gt; if set.
 If neither B&lt;srvCert&gt; nor recipient are set, the recipient of the PKI message is
 determined in the following order: issuer, issuer of old cert (oldCert),
-issuer of client cert (B&lt;clCert&gt;), else NULL-DN.
+issuer of protecting certificate (B&lt;cert&gt;), else NULL-DN.
 When a response is received, its sender must match the recipient of the request.
 
 OSSL_CMP_CTX_push0_geninfo_ITAV() adds B&lt;itav&gt; to the stack in the B&lt;ctx&gt; to be
@@ -481,7 +481,7 @@ the CertTemplate structure when requesting a new cert. For Key Update Requests
 see B&lt;OSSL_CMP_CTX_set1_oldCert()&gt;. This default is used for Initialization
 Requests (IR) and Certification Requests (CR) only if no SANs are set.
 The B&lt;subjectName&gt; is also used as the &quot;sender&quot; field for outgoing CMP messages
-if no B&lt;clCert&gt; has been set (e.g., in case requests are protected using PBM).
+if no B&lt;cert&gt; has been set (e.g., in case requests are protected using PBM).
 
 OSSL_CMP_CTX_push1_subjectAltName() adds the given X509 name to the list of
 alternate names on the certificate template request. This cannot be used if
@@ -507,7 +507,7 @@ to the X509_EXTENSIONS of the requested certificate template.
 
 OSSL_CMP_CTX_set1_oldCert() sets the old certificate to be updated in
 Key Update Requests (KUR) or to be revoked in Revocation Requests (RR).
-It must be given for RR, else it defaults to B&lt;clCert&gt;.
+It must be given for RR, else it defaults to the protecting B&lt;cert&gt;.
 The B&lt;reference certificate&gt; determined in this way, if any, is also used for
 deriving default subject DN and Subject Alternative Names for IR, CR, and KUR.
 Its issuer, if any, is used as default recipient in the CMP message header.
@@ -608,52 +608,56 @@ All other functions return 1 on success, 0 on error.
 
 =head1 EXAMPLES
 
-The following code does an Initialization Request:
+The following code omits error handling.
 
-        cmp_ctx = OSSL_CMP_CTX_new();
-        OSSL_CMP_CTX_set1_server(cmp_ctx, address);
-        OSSL_CMP_CTX_set1_referenceValue(cmp_ctx, ref, ref_len);
-        OSSL_CMP_CTX_set1_secretValue(cmp_ctx, sec, sec_len);
-        OSSL_CMP_CTX_set0_newPkey(cmp_ctx, new_pkey, 1);
-        OSSL_CMP_CTX_set1_caCert(cmp_ctx, ca_cert);
+Set up a CMP client context for sending requests and verifying responses:
 
-        initialClCert = OSSL_CMP_exec_IR_ses(cmp_ctx);
+    cmp_ctx = OSSL_CMP_CTX_new();
+    OSSL_CMP_CTX_set1_server(cmp_ctx, name_or_address);
+    OSSL_CMP_CTX_set1_serverPort(cmp_ctx, port_string);
+    OSSL_CMP_CTX_set1_serverPath(cmp_ctx, path_or_alias);
+    OSSL_CMP_CTX_set0_trustedStore(cmp_ctx, ts);
 
-The following code does an Initialization Request using an
-external identity certificate (RFC 4210, Appendix E.7):
+Set up client credentials for password-based protection (PBM):
 
-        cmp_ctx = OSSL_CMP_CTX_new();
-        OSSL_CMP_CTX_set1_server(cmp_ctx, sname);
-        OSSL_CMP_CTX_set1_clCert(cmp_ctx, cl_cert);
-        OSSL_CMP_CTX_set1_pkey(cmp_ctx, pkey);
-        OSSL_CMP_CTX_set0_newPkey(cmp_ctx, new_pkey, 1);
-        OSSL_CMP_CTX_set1_caCert(cmp_ctx, ca_cert);
+    OSSL_CMP_CTX_set1_referenceValue(cmp_ctx, ref, ref_len);
+    OSSL_CMP_CTX_set1_secretValue(cmp_ctx, sec, sec_len);
 
-        initialClCert = OSSL_CMP_exec_IR_ses(cmp_ctx);
+Set up the details for certificate requests:
 
-Here externalCert is an X509 certificate granted to the EE by another CA
-which is trusted by the current CA the code will connect to.
+    OSSL_CMP_CTX_set1_subjectName(cmp_ctx, name);
+    OSSL_CMP_CTX_set0_newPkey(cmp_ctx, 1, initialKey);
 
+Perform an Initialization Request transaction:
 
-The following code does a Key Update Request:
+    initialCert = OSSL_CMP_exec_IR_ses(cmp_ctx);
 
-        cmp_ctx = OSSL_CMP_CTX_new();
-        OSSL_CMP_CTX_set1_server(cmp_ctx, url);
-        OSSL_CMP_CTX_set1_pkey(cmp_ctx, pkey);
-        OSSL_CMP_CTX_set0_newPkey(cmp_ctx, new_pkey, 1);
-        OSSL_CMP_CTX_set1_clCert(cmp_ctx, cl_cert);
-        OSSL_CMP_CTX_set1_caCert(cmp_ctx, ca_cert);
+Reset the transaction state of the CMP context and the credentials:
 
-        updatedClCert = OSSL_CMP_exec_KUR_ses(cmp_ctx);
+    OSSL_CMP_CTX_reinit(cmp_ctx);
+    OSSL_CMP_CTX_set1_referenceValue(cmp_ctx, NULL, 0);
+    OSSL_CMP_CTX_set1_secretValue(cmp_ctx, NULL, 0);
 
-The following code (which omits error handling) sends a General Message
-including, as an example, the id-it-signKeyPairTypes OID and prints info on
-the General Response contents.
+Perform a Certification Request transaction, making use of the new credentials:
 
-    cmp_ctx = OSSL_CMP_CTX_new();
-    OSSL_CMP_CTX_set1_server(cmp_ctx, sname);
-    OSSL_CMP_CTX_set1_referenceValue(cmp_ctx, ref, ref_len);
-    OSSL_CMP_CTX_set1_secretValue(cmp_ctx, sec, sec_len);
+    OSSL_CMP_CTX_set1_cert(cmp_ctx, initialCert);
+    OSSL_CMP_CTX_set1_pkey(cmp_ctx, initialKey);
+    OSSL_CMP_CTX_set0_newPkey(cmp_ctx, 1, curentKey);
+    currentCert = OSSL_CMP_exec_CR_ses(cmp_ctx);
+
+Perform a Key Update Request, signed using the cert (and key) to be updated:
+
+    OSSL_CMP_CTX_reinit(cmp_ctx);
+    OSSL_CMP_CTX_set1_cert(cmp_ctx, currentCert);
+    OSSL_CMP_CTX_set1_pkey(cmp_ctx, currentKey);
+    OSSL_CMP_CTX_set0_newPkey(cmp_ctx, 1, updatedKey);
+    currentCert = OSSL_CMP_exec_KUR_ses(cmp_ctx);
+    currentKey = updatedKey;
+
+Perform a General Message transaction including, as an example,
+the id-it-signKeyPairTypes OID and prints info on the General Response contents:
+
+    OSSL_CMP_CTX_reinit(cmp_ctx);
 
     ASN1_OBJECT *type = OBJ_txt2obj(&quot;1.3.6.1.5.5.7.4.2&quot;, 1);
     OSSL_CMP_ITAV *itav = OSSL_CMP_ITAV_new(type, NULL);
diff --git a/doc/man3/OSSL_CMP_MSG_get0_header.pod b/doc/man3/OSSL_CMP_MSG_get0_header.pod
index bd51eb5598..3ab76c14df 100644
--- a/doc/man3/OSSL_CMP_MSG_get0_header.pod
+++ b/doc/man3/OSSL_CMP_MSG_get0_header.pod
@@ -3,6 +3,7 @@
 =head1 NAME
 
 OSSL_CMP_MSG_get0_header,
+OSSL_CMP_MSG_update_transactionID,
 d2i_OSSL_CMP_MSG_bio,
 i2d_OSSL_CMP_MSG_bio
 - function(s) manipulating CMP messages
@@ -12,17 +13,22 @@ i2d_OSSL_CMP_MSG_bio
   #include &lt;openssl/cmp.h&gt;
 
   OSSL_CMP_PKIHEADER *OSSL_CMP_MSG_get0_header(const OSSL_CMP_MSG *msg);
+  int OSSL_CMP_MSG_update_transactionID(OSSL_CMP_CTX *ctx, OSSL_CMP_MSG *msg);
   OSSL_CMP_MSG *d2i_OSSL_CMP_MSG_bio(BIO *bio, OSSL_CMP_MSG **msg);
   int i2d_OSSL_CMP_MSG_bio(BIO *bio, const OSSL_CMP_MSG *msg);
 
 =head1 DESCRIPTION
 
-OSSL_CMP_MSG_get0_header returns the header of the given CMP message.
+OSSL_CMP_MSG_get0_header() returns the header of the given CMP message.
 
-d2i_OSSL_CMP_MSG_bio parses an ASN.1-encoded OSSL_CMP_MSG from the BIO I&lt;bio&gt;.
+OSSL_CMP_MSG_update_transactionID() updates the transactionID field
+in the header of the given message according to the CMP_CTX.
+This requires re-protecting the message (if it was protected).
+
+d2i_OSSL_CMP_MSG_bio() parses an ASN.1-encoded OSSL_CMP_MSG from the BIO I&lt;bio&gt;.
 It assigns a pointer to the new structure to I&lt;*msg&gt; if I&lt;msg&gt; is not NULL.
 
-i2d_OSSL_CMP_MSG_bio writes the OSSL_CMP_MSG I&lt;msg&gt; in ASN.1 encoding
+i2d_OSSL_CMP_MSG_bio() writes the OSSL_CMP_MSG I&lt;msg&gt; in ASN.1 encoding
 to BIO I&lt;bio&gt;.
 
 =head1 NOTES
@@ -36,7 +42,8 @@ or NULL if the respective entry does not exist and on error.
 
 d2i_OSSL_CMP_MSG_bio() returns the parsed message or NULL on error.
 
-i2d_OSSL_CMP_MSG_bio() returns 1 on success or 0 on error.
+i2d_OSSL_CMP_MSG_bio() and OSSL_CMP_MSG_update_transactionID()
+return 1 on success, 0 on error.
 
 =head1 HISTORY
 
diff --git a/doc/man3/OSSL_CRMF_MSG_get0_tmpl.pod b/doc/man3/OSSL_CRMF_MSG_get0_tmpl.pod
index f8c58dfc53..b760db1983 100644
--- a/doc/man3/OSSL_CRMF_MSG_get0_tmpl.pod
+++ b/doc/man3/OSSL_CRMF_MSG_get0_tmpl.pod
@@ -17,16 +17,18 @@ OSSL_CRMF_MSG_get_certReqId
 
  OSSL_CRMF_CERTTEMPLATE *OSSL_CRMF_MSG_get0_tmpl(const OSSL_CRMF_MSG *crm);
  ASN1_INTEGER
-     *OSSL_CRMF_CERTTEMPLATE_get0_serialNumber(OSSL_CRMF_CERTTEMPLATE *tmpl);
- X509_NAME *OSSL_CRMF_CERTTEMPLATE_get0_issuer(OSSL_CRMF_CERTTEMPLATE *tmpl);
+ *OSSL_CRMF_CERTTEMPLATE_get0_serialNumber(const OSSL_CRMF_CERTTEMPLATE *tmpl);
+ X509_NAME
+ *OSSL_CRMF_CERTTEMPLATE_get0_issuer(const OSSL_CRMF_CERTTEMPLATE *tmpl);
 
  ASN1_INTEGER *OSSL_CRMF_CERTID_get0_serialNumber(const OSSL_CRMF_CERTID *cid);
  const X509_NAME *OSSL_CRMF_CERTID_get0_issuer(const OSSL_CRMF_CERTID *cid);
 
- X509 *OSSL_CRMF_ENCRYPTEDVALUE_get1_encCert(OSSL_CRMF_ENCRYPTEDVALUE *ecert,
-                                             EVP_PKEY *pkey);
+ X509
+ *OSSL_CRMF_ENCRYPTEDVALUE_get1_encCert(const OSSL_CRMF_ENCRYPTEDVALUE *ecert,
+                                        EVP_PKEY *pkey);
 
- int OSSL_CRMF_MSG_get_certReqId(OSSL_CRMF_MSG *crm);
+ int OSSL_CRMF_MSG_get_certReqId(const OSSL_CRMF_MSG *crm);
 
 
 =head1 DESCRIPTION
diff --git a/include/openssl/cmp.h b/include/openssl/cmp.h
index 66e3f40860..e06fba9b7f 100644
--- a/include/openssl/cmp.h
+++ b/include/openssl/cmp.h
@@ -294,7 +294,7 @@ X509_STORE *OSSL_CMP_CTX_get0_trustedStore(const OSSL_CMP_CTX *ctx);
 int OSSL_CMP_CTX_set1_untrusted_certs(OSSL_CMP_CTX *ctx, STACK_OF(X509) *certs);
 STACK_OF(X509) *OSSL_CMP_CTX_get0_untrusted_certs(const OSSL_CMP_CTX *ctx);
 /* client authentication: */
-int OSSL_CMP_CTX_set1_clCert(OSSL_CMP_CTX *ctx, X509 *cert);
+int OSSL_CMP_CTX_set1_cert(OSSL_CMP_CTX *ctx, X509 *cert);
 int OSSL_CMP_CTX_set1_pkey(OSSL_CMP_CTX *ctx, EVP_PKEY *pkey);
 int OSSL_CMP_CTX_set1_referenceValue(OSSL_CMP_CTX *ctx,
                                      const unsigned char *ref, int len);
@@ -310,7 +310,8 @@ int OSSL_CMP_CTX_set0_newPkey(OSSL_CMP_CTX *ctx, int priv, EVP_PKEY *pkey);
 EVP_PKEY *OSSL_CMP_CTX_get0_newPkey(const OSSL_CMP_CTX *ctx, int priv);
 int OSSL_CMP_CTX_set1_issuer(OSSL_CMP_CTX *ctx, const X509_NAME *name);
 int OSSL_CMP_CTX_set1_subjectName(OSSL_CMP_CTX *ctx, const X509_NAME *name);
-int OSSL_CMP_CTX_push1_subjectAltName(OSSL_CMP_CTX *ctx, const GENERAL_NAME *name);
+int OSSL_CMP_CTX_push1_subjectAltName(OSSL_CMP_CTX *ctx,
+                                      const GENERAL_NAME *name);
 int OSSL_CMP_CTX_set0_reqExtensions(OSSL_CMP_CTX *ctx, X509_EXTENSIONS *exts);
 int OSSL_CMP_CTX_reqExtensions_have_SAN(OSSL_CMP_CTX *ctx);
 int OSSL_CMP_CTX_push0_policy(OSSL_CMP_CTX *ctx, POLICYINFO *pinfo);
@@ -346,11 +347,13 @@ OSSL_CMP_PKISI *
 OSSL_CMP_STATUSINFO_new(int status, int fail_info, const char *text);
 
 /* from cmp_hdr.c */
-ASN1_OCTET_STRING *OSSL_CMP_HDR_get0_transactionID(const OSSL_CMP_PKIHEADER *hdr);
+ASN1_OCTET_STRING *OSSL_CMP_HDR_get0_transactionID(const
+                                                   OSSL_CMP_PKIHEADER *hdr);
 ASN1_OCTET_STRING *OSSL_CMP_HDR_get0_recipNonce(const OSSL_CMP_PKIHEADER *hdr);
 
 /* from cmp_msg.c */
 OSSL_CMP_PKIHEADER *OSSL_CMP_MSG_get0_header(const OSSL_CMP_MSG *msg);
+int OSSL_CMP_MSG_update_transactionID(OSSL_CMP_CTX *ctx, OSSL_CMP_MSG *msg);
 OSSL_CMP_MSG *d2i_OSSL_CMP_MSG_bio(BIO *bio, OSSL_CMP_MSG **msg);
 int i2d_OSSL_CMP_MSG_bio(BIO *bio, const OSSL_CMP_MSG *msg);
 
@@ -387,7 +390,7 @@ typedef void (*OSSL_CMP_SRV_error_cb_t)(OSSL_CMP_SRV_CTX *srv_ctx,
                                         const OSSL_CMP_MSG *req,
                                         const OSSL_CMP_PKISI *statusInfo,
                                         const ASN1_INTEGER *errorCode,
-                                        const OSSL_CMP_PKIFREETEXT *errorDetails);
+                                        const OSSL_CMP_PKIFREETEXT *errDetails);
 typedef int (*OSSL_CMP_SRV_certConf_cb_t)(OSSL_CMP_SRV_CTX *srv_ctx,
                                           const OSSL_CMP_MSG *req,
                                           int certReqId,
@@ -418,10 +421,10 @@ X509 *OSSL_CMP_exec_IR_ses(OSSL_CMP_CTX *ctx);
 X509 *OSSL_CMP_exec_CR_ses(OSSL_CMP_CTX *ctx);
 X509 *OSSL_CMP_exec_P10CR_ses(OSSL_CMP_CTX *ctx);
 X509 *OSSL_CMP_exec_KUR_ses(OSSL_CMP_CTX *ctx);
-# define OSSL_CMP_IR    OSSL_CMP_PKIBODY_IR
-# define OSSL_CMP_CR    OSSL_CMP_PKIBODY_CR
-# define OSSL_CMP_P10CR OSSL_CMP_PKIBODY_P10CR
-# define OSSL_CMP_KUR   OSSL_CMP_PKIBODY_KUR
+#  define OSSL_CMP_IR    OSSL_CMP_PKIBODY_IR
+#  define OSSL_CMP_CR    OSSL_CMP_PKIBODY_CR
+#  define OSSL_CMP_P10CR OSSL_CMP_PKIBODY_P10CR
+#  define OSSL_CMP_KUR   OSSL_CMP_PKIBODY_KUR
 int OSSL_CMP_try_certreq(OSSL_CMP_CTX *ctx, int req_type, int *checkAfter);
 int OSSL_CMP_certConf_cb(OSSL_CMP_CTX *ctx, X509 *cert, int fail_info,
                          const char **text);
diff --git a/test/cmp_client_test.c b/test/cmp_client_test.c
index b10662349c..ab2b930277 100644
--- a/test/cmp_client_test.c
+++ b/test/cmp_client_test.c
@@ -67,7 +67,7 @@ static CMP_SES_TEST_FIXTURE *set_up(const char *const test_case_name)
             || !ossl_cmp_mock_srv_set1_certOut(fixture-&gt;srv_ctx, client_cert)
             || (srv_cmp_ctx =
                 OSSL_CMP_SRV_CTX_get0_cmp_ctx(fixture-&gt;srv_ctx)) == NULL
-            || !OSSL_CMP_CTX_set1_clCert(srv_cmp_ctx, server_cert)
+            || !OSSL_CMP_CTX_set1_cert(srv_cmp_ctx, server_cert)
             || !OSSL_CMP_CTX_set1_pkey(srv_cmp_ctx, server_key))
         goto err;
     if (!TEST_ptr(fixture-&gt;cmp_ctx = ctx = OSSL_CMP_CTX_new())
diff --git a/test/cmp_ctx_test.c b/test/cmp_ctx_test.c
index 6f6a13673c..898053424e 100644
--- a/test/cmp_ctx_test.c
+++ b/test/cmp_ctx_test.c
@@ -746,7 +746,7 @@ DEFINE_SET_GET_BASE_TEST(OSSL_CMP_CTX, set0, get0, 0, trustedStore,
                          DEFAULT_STORE, X509_STORE_new_1(), X509_STORE_free)
 DEFINE_SET_GET_SK_X509_TEST(OSSL_CMP, CTX, 1, 0, untrusted_certs)
 
-DEFINE_SET_TEST(OSSL_CMP, CTX, 1, 0, clCert, X509)
+DEFINE_SET_TEST(OSSL_CMP, CTX, 1, 0, cert, X509)
 DEFINE_SET_TEST(OSSL_CMP, CTX, 1, 0, pkey, EVP_PKEY)
 
 DEFINE_SET_TEST(OSSL_CMP, CTX, 1, 1, recipient, X509_NAME)
@@ -829,7 +829,7 @@ int setup_tests(void)
     ADD_TEST(test_CTX_set0_get0_trustedStore);
     ADD_TEST(test_CTX_set1_get0_untrusted_certs);
     /* client authentication: */
-    ADD_TEST(test_CTX_set1_get0_clCert);
+    ADD_TEST(test_CTX_set1_get0_cert);
     ADD_TEST(test_CTX_set1_get0_pkey);
     /* the following two also test ossl_cmp_asn1_octet_string_set1_bytes(): */
     ADD_TEST(test_CTX_set1_get1_referenceValue_str);
diff --git a/test/cmp_msg_test.c b/test/cmp_msg_test.c
index 413e284fcc..ca03dc23e3 100644
--- a/test/cmp_msg_test.c
+++ b/test/cmp_msg_test.c
@@ -165,7 +165,7 @@ static int test_cmp_create_ir_protection_fails(void)
     if (!TEST_true(OSSL_CMP_CTX_set1_pkey(fixture-&gt;cmp_ctx, newkey))
             || !TEST_true(SET_OPT_UNPROTECTED_SEND(fixture-&gt;cmp_ctx, 0))
             /* newkey used by default for signing does not match cert: */
-            || !TEST_true(OSSL_CMP_CTX_set1_clCert(fixture-&gt;cmp_ctx, cert))) {
+            || !TEST_true(OSSL_CMP_CTX_set1_cert(fixture-&gt;cmp_ctx, cert))) {
         tear_down(fixture);
         fixture = NULL;
     }
diff --git a/test/cmp_protect_test.c b/test/cmp_protect_test.c
index ce5a6cb420..1d1e009aca 100644
--- a/test/cmp_protect_test.c
+++ b/test/cmp_protect_test.c
@@ -242,7 +242,7 @@ static int test_MSG_protect_with_certificate_and_key(void)
                   OSSL_CMP_MSG_dup(ir_unprotected))
             || !TEST_true(SET_OPT_UNPROTECTED_SEND(fixture-&gt;cmp_ctx, 0))
             || !TEST_true(OSSL_CMP_CTX_set1_pkey(fixture-&gt;cmp_ctx, loadedkey))
-            || !TEST_true(OSSL_CMP_CTX_set1_clCert(fixture-&gt;cmp_ctx, cert))) {
+            || !TEST_true(OSSL_CMP_CTX_set1_cert(fixture-&gt;cmp_ctx, cert))) {
         tear_down(fixture);
         fixture = NULL;
     }
diff --git a/test/recipes/65-test_cmp_vfy_data/insta.priv.pem b/test/insta.priv.pem
similarity index 100%
copy from test/recipes/65-test_cmp_vfy_data/insta.priv.pem
copy to test/insta.priv.pem
diff --git a/test/recipes/65-test_cmp_vfy_data/insta_ca.cert.pem b/test/insta_ca.cert.pem
similarity index 100%
copy from test/recipes/65-test_cmp_vfy_data/insta_ca.cert.pem
copy to test/insta_ca.cert.pem
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 590157fe8b..ec6acaefd4 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4771,7 +4771,7 @@ OSSL_CMP_CTX_set0_trustedStore          ?	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_CTX_get0_trustedStore          ?	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_CTX_set1_untrusted_certs       ?	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_CTX_get0_untrusted_certs       ?	3_0_0	EXIST::FUNCTION:CMP
-OSSL_CMP_CTX_set1_clCert                ?	3_0_0	EXIST::FUNCTION:CMP
+OSSL_CMP_CTX_set1_cert                  ?	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_CTX_set1_pkey                  ?	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_CTX_set1_referenceValue        ?	3_0_0	EXIST::FUNCTION:CMP
 OSSL_CMP_CTX_set1_secretValue           ?	3_0_0	EXIST::FUNCTION:CMP
@@ -4902,6 +4902,7 @@ i2d_X509_PUBKEY_bio                     ?	3_0_0	EXIST::FUNCTION:
 RSA_get0_pss_params                     ?	3_0_0	EXIST::FUNCTION:DEPRECATEDIN_3_0,RSA
 X509_cmp_timeframe                      ?	3_0_0	EXIST::FUNCTION:
 OSSL_CMP_MSG_get0_header                ?	3_0_0	EXIST::FUNCTION:CMP
+OSSL_CMP_MSG_update_transactionID       ?	3_0_0	EXIST::FUNCTION:CMP
 BIO_f_prefix                            ?	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_new_from_name              ?	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_new_from_pkey              ?	3_0_0	EXIST::FUNCTION:
</PRE>









<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="028745.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="028749.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#28746">[ date ]</a>
              <a href="thread.html#28746">[ thread ]</a>
              <a href="subject.html#28746">[ subject ]</a>
              <a href="author.html#28746">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
