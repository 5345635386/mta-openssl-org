<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-June/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1560765767.363953.11361.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="023553.html">
   <LINK REL="Next"  HREF="023557.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1560765767.363953.11361.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Mon Jun 17 10:02:47 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="023553.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="023557.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23554">[ date ]</a>
              <a href="thread.html#23554">[ thread ]</a>
              <a href="subject.html#23554">[ subject ]</a>
              <a href="author.html#23554">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  65dc5c3cc10af7c6f24ecd922adb7b6d17a9fe65 (commit)
       via  dbc6268f68e50b2e49d7c5b1157b4f6bcea5d6f9 (commit)
      from  8013a933dacc80096e2bfca06c00f9ec29adb35b (commit)


- Log -----------------------------------------------------------------
commit 65dc5c3cc10af7c6f24ecd922adb7b6d17a9fe65
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Jun 13 19:34:37 2019 +0100

    Fix no-ec with no-dh
    
    Make sure that the combination of no-ec with no-dh builds successfully.
    If neither ec or dh are available then TLSv1.3 is not possible.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9156">https://github.com/openssl/openssl/pull/9156</A>)

commit dbc6268f68e50b2e49d7c5b1157b4f6bcea5d6f9
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Jun 13 11:06:12 2019 +0100

    Allow TLSv1.3 in a no-ec build
    
    Now that we have TLSv1.3 FFDHE support there is no reason why we should
    not allow TLSv1.3 to be used in a no-ec build. This commit enables that
    to happen.
    
    It also fixes no-ec which was previously broken.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9156">https://github.com/openssl/openssl/pull/9156</A>)

-----------------------------------------------------------------------

Summary of changes:
 Configure                            |   6 +-
 ssl/s3_lib.c                         |  12 ++-
 ssl/ssl_lib.c                        |   3 +-
 ssl/ssl_locl.h                       |  14 +--
 ssl/statem/extensions.c              |  14 ++-
 ssl/statem/extensions_clnt.c         |  48 +++++++--
 ssl/statem/extensions_srvr.c         |   6 +-
 ssl/statem/statem_lib.c              |   4 +-
 ssl/statem/statem_locl.h             |   5 +-
 ssl/t1_lib.c                         | 200 +++++++++++++++++++++--------------
 test/recipes/70-test_clienthello.t   |   4 +
 test/recipes/70-test_key_share.t     |  92 ++++++++++++----
 test/recipes/70-test_sslextension.t  |   5 +-
 test/recipes/70-test_tls13cookie.t   |  18 +++-
 test/recipes/70-test_tls13hrr.t      |  12 ++-
 test/recipes/70-test_tls13kexmodes.t |   3 +
 test/recipes/70-test_tls13messages.t |   3 +
 test/recipes/70-test_tls13psk.t      |  12 ++-
 test/recipes/80-test_ssl_new.t       |   2 +-
 test/recipes/90-test_gost.t          |   4 +
 test/ssl-tests/protocol_version.pm   |   2 +-
 test/sslapitest.c                    |  64 ++++++-----
 test/tls13ccstest.c                  |   7 ++
 23 files changed, 363 insertions(+), 177 deletions(-)

diff --git a/Configure b/Configure
index 69a06d6..c3f4f99 100755
--- a/Configure
+++ b/Configure
@@ -482,8 +482,9 @@ my @disable_cascades = (
     &quot;ssl3-method&quot;       =&gt; [ &quot;ssl3&quot; ],
     &quot;zlib&quot;              =&gt; [ &quot;zlib-dynamic&quot; ],
     &quot;des&quot;               =&gt; [ &quot;mdc2&quot; ],
-    &quot;ec&quot;                =&gt; [ &quot;ecdsa&quot;, &quot;ecdh&quot; ],
-
+    &quot;ec&quot;                =&gt; [ &quot;ecdsa&quot;, &quot;ecdh&quot;, &quot;sm2&quot; ],
+    sub { $disabled{&quot;ec&quot;} &amp;&amp; $disabled{&quot;dh&quot;} }
+                        =&gt; [ &quot;tls1_3&quot; ],
     &quot;dgram&quot;             =&gt; [ &quot;dtls&quot;, &quot;sctp&quot; ],
     &quot;sock&quot;              =&gt; [ &quot;dgram&quot; ],
     &quot;dtls&quot;              =&gt; [ @dtls ],
@@ -526,7 +527,6 @@ my @disable_cascades = (
     &quot;apps&quot;              =&gt; [ &quot;tests&quot; ],
     &quot;tests&quot;             =&gt; [ &quot;external-tests&quot; ],
     &quot;comp&quot;              =&gt; [ &quot;zlib&quot; ],
-    &quot;ec&quot;                =&gt; [ &quot;tls1_3&quot;, &quot;sm2&quot; ],
     &quot;sm3&quot;               =&gt; [ &quot;sm2&quot; ],
     sub { !$disabled{&quot;unit-test&quot;} } =&gt; [ &quot;heartbeats&quot; ],
 
diff --git a/ssl/s3_lib.c b/ssl/s3_lib.c
index 358142e..6c3f04d 100644
--- a/ssl/s3_lib.c
+++ b/ssl/s3_lib.c
@@ -3578,7 +3578,7 @@ long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg)
         }
         return ssl_cert_set_current(s-&gt;cert, larg);
 
-#ifndef OPENSSL_NO_EC
+#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)
     case SSL_CTRL_GET_GROUPS:
         {
             uint16_t *clist;
@@ -3623,7 +3623,8 @@ long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg)
             }
             return id;
         }
-#endif
+#endif /* !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) */
+
     case SSL_CTRL_SET_SIGALGS:
         return tls1_set_sigalgs(s-&gt;cert, parg, larg, 0);
 
@@ -3899,7 +3900,7 @@ long ssl3_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)
         break;
 #endif
 
-#ifndef OPENSSL_NO_EC
+#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)
     case SSL_CTRL_SET_GROUPS:
         return tls1_set_groups(&amp;ctx-&gt;ext.supportedgroups,
                                &amp;ctx-&gt;ext.supportedgroups_len,
@@ -3909,7 +3910,8 @@ long ssl3_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)
         return tls1_set_groups_list(&amp;ctx-&gt;ext.supportedgroups,
                                     &amp;ctx-&gt;ext.supportedgroups_len,
                                     parg);
-#endif
+#endif /* !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) */
+
     case SSL_CTRL_SET_SIGALGS:
         return tls1_set_sigalgs(ctx-&gt;cert, parg, larg, 0);
 
@@ -4680,6 +4682,7 @@ EVP_PKEY *ssl_generate_pkey(EVP_PKEY *pm)
 }
 
 /* Generate a private key from a group ID */
+#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_EC)
 EVP_PKEY *ssl_generate_pkey_group(SSL *s, uint16_t id)
 {
     const TLS_GROUP_INFO *ginf = tls1_group_id_lookup(id);
@@ -4766,6 +4769,7 @@ EVP_PKEY *ssl_generate_pkey_group(SSL *s, uint16_t id)
     EVP_PKEY_CTX_free(pctx);
     return pkey;
 }
+#endif
 
 /*
  * Generate parameters from a group ID
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index cf79ac5..4e4477d 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -780,6 +780,7 @@ SSL *SSL_new(SSL_CTX *ctx)
         s-&gt;ext.ecpointformats_len =
             ctx-&gt;ext.ecpointformats_len;
     }
+#endif
     if (ctx-&gt;ext.supportedgroups) {
         s-&gt;ext.supportedgroups =
             OPENSSL_memdup(ctx-&gt;ext.supportedgroups,
@@ -789,7 +790,7 @@ SSL *SSL_new(SSL_CTX *ctx)
             goto err;
         s-&gt;ext.supportedgroups_len = ctx-&gt;ext.supportedgroups_len;
     }
-#endif
+
 #ifndef OPENSSL_NO_NEXTPROTONEG
     s-&gt;ext.npn = NULL;
 #endif
diff --git a/ssl/ssl_locl.h b/ssl/ssl_locl.h
index 0e661d0..e521152 100644
--- a/ssl/ssl_locl.h
+++ b/ssl/ssl_locl.h
@@ -959,9 +959,10 @@ struct ssl_ctx_st {
         /* EC extension values inherited by SSL structure */
         size_t ecpointformats_len;
         unsigned char *ecpointformats;
+# endif                         /* OPENSSL_NO_EC */
+
         size_t supportedgroups_len;
         uint16_t *supportedgroups;
-# endif                         /* OPENSSL_NO_EC */
 
         /*
          * ALPN information (we are in the process of transitioning from NPN to
@@ -2525,8 +2526,6 @@ __owur int ssl_check_srvr_ecc_cert_and_alg(X509 *x, SSL *s);
 
 SSL_COMP *ssl3_comp_find(STACK_OF(SSL_COMP) *sk, int n);
 
-#  ifndef OPENSSL_NO_EC
-
 __owur const TLS_GROUP_INFO *tls1_group_id_lookup(uint16_t curve_id);
 __owur int tls1_check_group_id(SSL *s, uint16_t group_id, int check_own_curves);
 __owur uint16_t tls1_shared_group(SSL *s, int nmatch);
@@ -2534,15 +2533,16 @@ __owur int tls1_set_groups(uint16_t **pext, size_t *pextlen,
                            int *curves, size_t ncurves);
 __owur int tls1_set_groups_list(uint16_t **pext, size_t *pextlen,
                                 const char *str);
-void tls1_get_formatlist(SSL *s, const unsigned char **pformats,
-                         size_t *num_formats);
-__owur int tls1_check_ec_tmp_key(SSL *s, unsigned long id);
 __owur EVP_PKEY *ssl_generate_pkey_group(SSL *s, uint16_t id);
 __owur int tls_valid_group(SSL *s, uint16_t group_id, int version);
 __owur EVP_PKEY *ssl_generate_param_group(uint16_t id);
+#  ifndef OPENSSL_NO_EC
+void tls1_get_formatlist(SSL *s, const unsigned char **pformats,
+                         size_t *num_formats);
+__owur int tls1_check_ec_tmp_key(SSL *s, unsigned long id);
 #  endif                        /* OPENSSL_NO_EC */
 
-__owur int tls_curve_allowed(SSL *s, uint16_t curve, int op);
+__owur int tls_group_allowed(SSL *s, uint16_t curve, int op);
 void tls1_get_supported_groups(SSL *s, const uint16_t **pgroups,
                                size_t *pgroupslen);
 
diff --git a/ssl/statem/extensions.c b/ssl/statem/extensions.c
index 2e51aab..eacc721 100644
--- a/ssl/statem/extensions.c
+++ b/ssl/statem/extensions.c
@@ -46,9 +46,7 @@ static int init_etm(SSL *s, unsigned int context);
 static int init_ems(SSL *s, unsigned int context);
 static int final_ems(SSL *s, unsigned int context, int sent);
 static int init_psk_kex_modes(SSL *s, unsigned int context);
-#ifndef OPENSSL_NO_EC
 static int final_key_share(SSL *s, unsigned int context, int sent);
-#endif
 #ifndef OPENSSL_NO_SRTP
 static int init_srtp(SSL *s, unsigned int context);
 #endif
@@ -162,6 +160,10 @@ static const EXTENSION_DEFINITION ext_defs[] = {
         tls_construct_stoc_ec_pt_formats, tls_construct_ctos_ec_pt_formats,
         final_ec_pt_formats
     },
+#else
+    INVALID_EXTENSION,
+#endif
+#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)
     {
         /*
          * &quot;supported_groups&quot; is spread across several specifications.
@@ -197,7 +199,6 @@ static const EXTENSION_DEFINITION ext_defs[] = {
     },
 #else
     INVALID_EXTENSION,
-    INVALID_EXTENSION,
 #endif
     {
         TLSEXT_TYPE_session_ticket,
@@ -322,7 +323,6 @@ static const EXTENSION_DEFINITION ext_defs[] = {
         init_psk_kex_modes, tls_parse_ctos_psk_kex_modes, NULL, NULL,
         tls_construct_ctos_psk_kex_modes, NULL
     },
-#ifndef OPENSSL_NO_EC
     {
         /*
          * Must be in this list after supported_groups. We need that to have
@@ -336,7 +336,6 @@ static const EXTENSION_DEFINITION ext_defs[] = {
         tls_construct_stoc_key_share, tls_construct_ctos_key_share,
         final_key_share
     },
-#endif
     {
         /* Must be after key_share */
         TLSEXT_TYPE_cookie,
@@ -1266,9 +1265,9 @@ static int final_sig_algs(SSL *s, unsigned int context, int sent)
     return 1;
 }
 
-#ifndef OPENSSL_NO_EC
 static int final_key_share(SSL *s, unsigned int context, int sent)
 {
+#if !defined(OPENSSL_NO_TLS1_3)
     if (!SSL_IS_TLS13(s))
         return 1;
 
@@ -1426,10 +1425,9 @@ static int final_key_share(SSL *s, unsigned int context, int sent)
             return 0;
         }
     }
-
+#endif /* !defined(OPENSSL_NO_TLS1_3) */
     return 1;
 }
-#endif
 
 static int init_psk_kex_modes(SSL *s, unsigned int context)
 {
diff --git a/ssl/statem/extensions_clnt.c b/ssl/statem/extensions_clnt.c
index a29b7c0..b12361f 100644
--- a/ssl/statem/extensions_clnt.c
+++ b/ssl/statem/extensions_clnt.c
@@ -113,11 +113,13 @@ EXT_RETURN tls_construct_ctos_srp(SSL *s, WPACKET *pkt, unsigned int context,
 #endif
 
 #ifndef OPENSSL_NO_EC
-static int use_ecc(SSL *s)
+static int use_ecc(SSL *s, int max_version)
 {
     int i, end, ret = 0;
     unsigned long alg_k, alg_a;
     STACK_OF(SSL_CIPHER) *cipher_stack = NULL;
+    const uint16_t *pgroups = NULL;
+    size_t num_groups, j;
 
     /* See if we support any ECC ciphersuites */
     if (s-&gt;version == SSL3_VERSION)
@@ -137,9 +139,21 @@ static int use_ecc(SSL *s)
             break;
         }
     }
-
     sk_SSL_CIPHER_free(cipher_stack);
-    return ret;
+    if (!ret)
+        return 0;
+
+    /* Check we have at least one EC supported group */
+    tls1_get_supported_groups(s, &amp;pgroups, &amp;num_groups);
+    for (j = 0; j &lt; num_groups; j++) {
+        uint16_t ctmp = pgroups[j];
+
+        if (tls_valid_group(s, ctmp, max_version)
+                &amp;&amp; tls_group_allowed(s, ctmp, SSL_SECOP_CURVE_SUPPORTED))
+            return 1;
+    }
+
+    return 0;
 }
 
 EXT_RETURN tls_construct_ctos_ec_pt_formats(SSL *s, WPACKET *pkt,
@@ -148,8 +162,15 @@ EXT_RETURN tls_construct_ctos_ec_pt_formats(SSL *s, WPACKET *pkt,
 {
     const unsigned char *pformats;
     size_t num_formats;
+    int reason, min_version, max_version;
 
-    if (!use_ecc(s))
+    reason = ssl_get_min_max_version(s, &amp;min_version, &amp;max_version, NULL);
+    if (reason != 0) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR,
+                 SSL_F_TLS_CONSTRUCT_CTOS_EC_PT_FORMATS, reason);
+        return EXT_RETURN_FAIL;
+    }
+    if (!use_ecc(s, max_version))
         return EXT_RETURN_NOT_SENT;
 
     /* Add TLS extension ECPointFormats to the ClientHello message */
@@ -167,7 +188,9 @@ EXT_RETURN tls_construct_ctos_ec_pt_formats(SSL *s, WPACKET *pkt,
 
     return EXT_RETURN_SENT;
 }
+#endif
 
+#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_EC)
 EXT_RETURN tls_construct_ctos_supported_groups(SSL *s, WPACKET *pkt,
                                                unsigned int context, X509 *x,
                                                size_t chainidx)
@@ -176,9 +199,6 @@ EXT_RETURN tls_construct_ctos_supported_groups(SSL *s, WPACKET *pkt,
     size_t num_groups = 0, i;
     int min_version, max_version, reason;
 
-    if (!use_ecc(s))
-        return EXT_RETURN_NOT_SENT;
-
     reason = ssl_get_min_max_version(s, &amp;min_version, &amp;max_version, NULL);
     if (reason != 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR,
@@ -186,6 +206,14 @@ EXT_RETURN tls_construct_ctos_supported_groups(SSL *s, WPACKET *pkt,
         return EXT_RETURN_FAIL;
     }
 
+#if defined(OPENSSL_NO_EC)
+    if (max_version &lt; TLS1_3_VERSION)
+        return EXT_RETURN_NOT_SENT;
+#else
+    if (!use_ecc(s, max_version) &amp;&amp; max_version &lt; TLS1_3_VERSION)
+        return EXT_RETURN_NOT_SENT;
+#endif
+
     /*
      * Add TLS extension supported_groups to the ClientHello message
      */
@@ -206,7 +234,7 @@ EXT_RETURN tls_construct_ctos_supported_groups(SSL *s, WPACKET *pkt,
         uint16_t ctmp = pgroups[i];
 
         if (tls_valid_group(s, ctmp, max_version)
-                &amp;&amp; tls_curve_allowed(s, ctmp, SSL_SECOP_CURVE_SUPPORTED)) {
+                &amp;&amp; tls_group_allowed(s, ctmp, SSL_SECOP_CURVE_SUPPORTED)) {
             if (!WPACKET_put_bytes_u16(pkt, ctmp)) {
                 SSLfatal(s, SSL_AD_INTERNAL_ERROR,
                          SSL_F_TLS_CONSTRUCT_CTOS_SUPPORTED_GROUPS,
@@ -683,7 +711,7 @@ EXT_RETURN tls_construct_ctos_key_share(SSL *s, WPACKET *pkt,
     } else {
         for (i = 0; i &lt; num_groups; i++) {
 
-            if (!tls_curve_allowed(s, pgroups[i], SSL_SECOP_CURVE_SUPPORTED))
+            if (!tls_group_allowed(s, pgroups[i], SSL_SECOP_CURVE_SUPPORTED))
                 continue;
 
             curve_id = pgroups[i];
@@ -1843,7 +1871,7 @@ int tls_parse_stoc_key_share(SSL *s, PACKET *pkt, unsigned int context, X509 *x,
                 break;
         }
         if (i &gt;= num_groups
-                || !tls_curve_allowed(s, group_id, SSL_SECOP_CURVE_SUPPORTED)) {
+                || !tls_group_allowed(s, group_id, SSL_SECOP_CURVE_SUPPORTED)) {
             SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,
                      SSL_F_TLS_PARSE_STOC_KEY_SHARE, SSL_R_BAD_KEY_SHARE);
             return 0;
diff --git a/ssl/statem/extensions_srvr.c b/ssl/statem/extensions_srvr.c
index 37f5819..6181f3f 100644
--- a/ssl/statem/extensions_srvr.c
+++ b/ssl/statem/extensions_srvr.c
@@ -946,7 +946,7 @@ int tls_parse_ctos_cookie(SSL *s, PACKET *pkt, unsigned int context, X509 *x,
     return 1;
 }
 
-#ifndef OPENSSL_NO_EC
+#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)
 int tls_parse_ctos_supported_groups(SSL *s, PACKET *pkt, unsigned int context,
                                     X509 *x, size_t chainidx)
 {
@@ -1400,7 +1400,7 @@ EXT_RETURN tls_construct_stoc_ec_pt_formats(SSL *s, WPACKET *pkt,
 }
 #endif
 
-#ifndef OPENSSL_NO_EC
+#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)
 EXT_RETURN tls_construct_stoc_supported_groups(SSL *s, WPACKET *pkt,
                                                unsigned int context, X509 *x,
                                                size_t chainidx)
@@ -1425,7 +1425,7 @@ EXT_RETURN tls_construct_stoc_supported_groups(SSL *s, WPACKET *pkt,
         uint16_t group = groups[i];
 
         if (tls_valid_group(s, group, SSL_version(s))
-                &amp;&amp; tls_curve_allowed(s, group, SSL_SECOP_CURVE_SUPPORTED)) {
+                &amp;&amp; tls_group_allowed(s, group, SSL_SECOP_CURVE_SUPPORTED)) {
             if (first) {
                 /*
                  * Check if the client is already using our preferred group. If
diff --git a/ssl/statem/statem_lib.c b/ssl/statem/statem_lib.c
index e6d2478..292f99c 100644
--- a/ssl/statem/statem_lib.c
+++ b/ssl/statem/statem_lib.c
@@ -2137,7 +2137,6 @@ int ssl_set_client_hello_version(SSL *s)
  * used. Returns 1 if the group is in the list (and allowed if |checkallow| is
  * 1) or 0 otherwise.
  */
-#ifndef OPENSSL_NO_EC
 int check_in_list(SSL *s, uint16_t group_id, const uint16_t *groups,
                   size_t num_groups, int checkallow)
 {
@@ -2151,14 +2150,13 @@ int check_in_list(SSL *s, uint16_t group_id, const uint16_t *groups,
 
         if (group_id == group
                 &amp;&amp; (!checkallow
-                    || tls_curve_allowed(s, group, SSL_SECOP_CURVE_CHECK))) {
+                    || tls_group_allowed(s, group, SSL_SECOP_CURVE_CHECK))) {
             return 1;
         }
     }
 
     return 0;
 }
-#endif
 
 /* Replace ClientHello1 in the transcript hash with a synthetic message */
 int create_synthetic_message_hash(SSL *s, const unsigned char *hashval,
diff --git a/ssl/statem/statem_locl.h b/ssl/statem/statem_locl.h
index 8f27deb..f4242fa 100644
--- a/ssl/statem/statem_locl.h
+++ b/ssl/statem/statem_locl.h
@@ -199,9 +199,9 @@ int tls_parse_ctos_early_data(SSL *s, PACKET *pkt, unsigned int context,
 #ifndef OPENSSL_NO_EC
 int tls_parse_ctos_ec_pt_formats(SSL *s, PACKET *pkt, unsigned int context,
                                  X509 *x, size_t chainidx);
+#endif
 int tls_parse_ctos_supported_groups(SSL *s, PACKET *pkt, unsigned int context,
                                     X509 *x, size_t chainidxl);
-#endif
 int tls_parse_ctos_session_ticket(SSL *s, PACKET *pkt, unsigned int context,
                                   X509 *x, size_t chainidx);
 int tls_parse_ctos_sig_algs_cert(SSL *s, PACKET *pkt, unsigned int context,
@@ -314,10 +314,11 @@ EXT_RETURN tls_construct_ctos_srp(SSL *s, WPACKET *pkt, unsigned int context, X5
 EXT_RETURN tls_construct_ctos_ec_pt_formats(SSL *s, WPACKET *pkt,
                                             unsigned int context, X509 *x,
                                             size_t chainidx);
+#endif
 EXT_RETURN tls_construct_ctos_supported_groups(SSL *s, WPACKET *pkt,
                                                unsigned int context, X509 *x,
                                                size_t chainidx);
-#endif
+
 EXT_RETURN tls_construct_ctos_early_data(SSL *s, WPACKET *pkt,
                                          unsigned int context, X509 *x,
                                          size_t chainidx);
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index 52e6d54..dcae274 100644
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -128,12 +128,12 @@ int tls1_clear(SSL *s)
     return 1;
 }
 
-#ifndef OPENSSL_NO_EC
-
 /*
- * Table of curve information.
+ * Table of group information.
  */
+#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_EC)
 static const TLS_GROUP_INFO nid_list[] = {
+# ifndef OPENSSL_NO_EC
     {NID_sect163k1, 80, TLS_GROUP_CURVE_CHAR2, 0x0001}, /* sect163k1 (1) */
     {NID_sect163r1, 80, TLS_GROUP_CURVE_CHAR2, 0x0002}, /* sect163r1 (2) */
     {NID_sect163r2, 80, TLS_GROUP_CURVE_CHAR2, 0x0003}, /* sect163r2 (3) */
@@ -164,41 +164,56 @@ static const TLS_GROUP_INFO nid_list[] = {
     {NID_brainpoolP512r1, 256, TLS_GROUP_CURVE_PRIME, 0x001C}, /* brainpool512r1 (28) */
     {EVP_PKEY_X25519, 128, TLS_GROUP_CURVE_CUSTOM, 0x001D}, /* X25519 (29) */
     {EVP_PKEY_X448, 224, TLS_GROUP_CURVE_CUSTOM, 0x001E}, /* X448 (30) */
+# endif /* OPENSSL_NO_EC */
+# ifndef OPENSSL_NO_DH
     /* Security bit values for FFDHE groups are updated as per RFC 7919 */
     {NID_ffdhe2048, 103, TLS_GROUP_FFDHE_FOR_TLS1_3, 0x0100}, /* ffdhe2048 (0x0100) */
     {NID_ffdhe3072, 125, TLS_GROUP_FFDHE_FOR_TLS1_3, 0x0101}, /* ffdhe3072 (0x0101) */
     {NID_ffdhe4096, 150, TLS_GROUP_FFDHE_FOR_TLS1_3, 0x0102}, /* ffdhe4096 (0x0102) */
     {NID_ffdhe6144, 175, TLS_GROUP_FFDHE_FOR_TLS1_3, 0x0103}, /* ffdhe6144 (0x0103) */
     {NID_ffdhe8192, 192, TLS_GROUP_FFDHE_FOR_TLS1_3, 0x0104}, /* ffdhe8192 (0x0104) */
+# endif /* OPENSSL_NO_DH */
 };
+#endif
 
+#ifndef OPENSSL_NO_EC
 static const unsigned char ecformats_default[] = {
     TLSEXT_ECPOINTFORMAT_uncompressed,
     TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime,
     TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2
 };
+#endif /* !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) */
 
 /* The default curves */
+#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_EC)
 static const uint16_t supported_groups_default[] = {
+# ifndef OPENSSL_NO_EC
     29,                      /* X25519 (29) */
     23,                      /* secp256r1 (23) */
     30,                      /* X448 (30) */
     25,                      /* secp521r1 (25) */
     24,                      /* secp384r1 (24) */
+# endif
+# ifndef OPENSSL_NO_DH
     0x100,                   /* ffdhe2048 (0x100) */
     0x101,                   /* ffdhe3072 (0x101) */
     0x102,                   /* ffdhe4096 (0x102) */
     0x103,                   /* ffdhe6144 (0x103) */
     0x104,                   /* ffdhe8192 (0x104) */
+# endif
 };
+#endif /* !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) */
 
+#ifndef OPENSSL_NO_EC
 static const uint16_t suiteb_curves[] = {
     TLSEXT_curve_P_256,
     TLSEXT_curve_P_384
 };
+#endif
 
 const TLS_GROUP_INFO *tls1_group_id_lookup(uint16_t group_id)
 {
+#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_EC)
     size_t i;
 
     /* ECC curves from RFC 4492 and RFC 7027 FFDHE group from RFC 8446 */
@@ -206,9 +221,11 @@ const TLS_GROUP_INFO *tls1_group_id_lookup(uint16_t group_id)
         if (nid_list[i].group_id == group_id)
             return &amp;nid_list[i];
     }
+#endif /* !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_EC) */
     return NULL;
 }
 
+#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_EC)
 static uint16_t tls1_nid2group_id(int nid)
 {
     size_t i;
@@ -219,6 +236,7 @@ static uint16_t tls1_nid2group_id(int nid)
     }
     return 0;
 }
+#endif /* !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) */
 
 /*
  * Set *pgroups to the supported groups list and *pgroupslen to
@@ -227,9 +245,10 @@ static uint16_t tls1_nid2group_id(int nid)
 void tls1_get_supported_groups(SSL *s, const uint16_t **pgroups,
                                size_t *pgroupslen)
 {
-
+#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)
     /* For Suite B mode only include P-256, P-384 */
     switch (tls1_suiteb(s)) {
+# ifndef OPENSSL_NO_EC
     case SSL_CERT_FLAG_SUITEB_128_LOS:
         *pgroups = suiteb_curves;
         *pgroupslen = OSSL_NELEM(suiteb_curves);
@@ -244,6 +263,7 @@ void tls1_get_supported_groups(SSL *s, const uint16_t **pgroups,
         *pgroups = suiteb_curves + 1;
         *pgroupslen = 1;
         break;
+# endif
 
     default:
         if (s-&gt;ext.supportedgroups == NULL) {
@@ -255,6 +275,10 @@ void tls1_get_supported_groups(SSL *s, const uint16_t **pgroups,
         }
         break;
     }
+#else
+    *pgroups = NULL;
+    *pgroupslen = 0;
+#endif /* !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) */
 }
 
 int tls_valid_group(SSL *s, uint16_t group_id, int version)
@@ -268,25 +292,25 @@ int tls_valid_group(SSL *s, uint16_t group_id, int version)
     return 1;
 }
 
-/* See if curve is allowed by security callback */
-int tls_curve_allowed(SSL *s, uint16_t curve, int op)
+/* See if group is allowed by security callback */
+int tls_group_allowed(SSL *s, uint16_t group, int op)
 {
-    const TLS_GROUP_INFO *cinfo = tls1_group_id_lookup(curve);
-    unsigned char ctmp[2];
+    const TLS_GROUP_INFO *ginfo = tls1_group_id_lookup(group);
+    unsigned char gtmp[2];
 
-    if (cinfo == NULL)
+    if (ginfo == NULL)
         return 0;
-# ifdef OPENSSL_NO_EC2M
-    if (cinfo-&gt;flags &amp; TLS_GROUP_CURVE_CHAR2)
+#ifdef OPENSSL_NO_EC2M
+    if (ginfo-&gt;flags &amp; TLS_GROUP_CURVE_CHAR2)
         return 0;
-# endif
-# ifdef OPENSSL_NO_DH
-    if (cinfo-&gt;flags &amp; TLS_GROUP_FFDHE)
+#endif
+#ifdef OPENSSL_NO_DH
+    if (ginfo-&gt;flags &amp; TLS_GROUP_FFDHE)
         return 0;
-# endif
-    ctmp[0] = curve &gt;&gt; 8;
-    ctmp[1] = curve &amp; 0xff;
-    return ssl_security(s, op, cinfo-&gt;secbits, cinfo-&gt;nid, (void *)ctmp);
+#endif
+    gtmp[0] = group &gt;&gt; 8;
+    gtmp[1] = group &amp; 0xff;
+    return ssl_security(s, op, ginfo-&gt;secbits, ginfo-&gt;nid, (void *)gtmp);
 }
 
 /* Return 1 if &quot;id&quot; is in &quot;list&quot; */
@@ -349,7 +373,7 @@ uint16_t tls1_shared_group(SSL *s, int nmatch)
         uint16_t id = pref[i];
 
         if (!tls1_in_list(id, supp, num_supp)
-            || !tls_curve_allowed(s, id, SSL_SECOP_CURVE_SHARED))
+            || !tls_group_allowed(s, id, SSL_SECOP_CURVE_SHARED))
                     continue;
         if (nmatch == k)
             return id;
@@ -364,6 +388,7 @@ uint16_t tls1_shared_group(SSL *s, int nmatch)
 int tls1_set_groups(uint16_t **pext, size_t *pextlen,
                     int *groups, size_t ngroups)
 {
+#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)
     uint16_t *glist;
     size_t i;
     /*
@@ -402,30 +427,36 @@ int tls1_set_groups(uint16_t **pext, size_t *pextlen,
 err:
     OPENSSL_free(glist);
     return 0;
+#else
+    return 0;
+#endif /* !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) */
 }
 
-# define MAX_CURVELIST   OSSL_NELEM(nid_list)
+#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)
+# define MAX_GROUPLIST   OSSL_NELEM(nid_list)
 
 typedef struct {
     size_t nidcnt;
-    int nid_arr[MAX_CURVELIST];
+    int nid_arr[MAX_GROUPLIST];
 } nid_cb_st;
 
 static int nid_cb(const char *elem, int len, void *arg)
 {
     nid_cb_st *narg = arg;
     size_t i;
-    int nid;
+    int nid = NID_undef;
     char etmp[20];
     if (elem == NULL)
         return 0;
-    if (narg-&gt;nidcnt == MAX_CURVELIST)
+    if (narg-&gt;nidcnt == MAX_GROUPLIST)
         return 0;
     if (len &gt; (int)(sizeof(etmp) - 1))
         return 0;
     memcpy(etmp, elem, len);
     etmp[len] = 0;
+# ifndef OPENSSL_NO_EC
     nid = EC_curve_nist2nid(etmp);
+# endif
     if (nid == NID_undef)
         nid = OBJ_sn2nid(etmp);
     if (nid == NID_undef)
@@ -438,10 +469,12 @@ static int nid_cb(const char *elem, int len, void *arg)
     narg-&gt;nid_arr[narg-&gt;nidcnt++] = nid;
     return 1;
 }
+#endif /* !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH) */
 
 /* Set groups based on a colon separate list */
 int tls1_set_groups_list(uint16_t **pext, size_t *pextlen, const char *str)
 {
+#if !defined(OPENSSL_NO_EC) || !defined(OPENSSL_NO_DH)
     nid_cb_st ncb;
     ncb.nidcnt = 0;
     if (!CONF_parse_list(str, ':', 1, nid_cb, &amp;ncb))
@@ -449,64 +482,9 @@ int tls1_set_groups_list(uint16_t **pext, size_t *pextlen, const char *str)
     if (pext == NULL)
         return 1;
     return tls1_set_groups(pext, pextlen, ncb.nid_arr, ncb.nidcnt);
-}
-/* Return group id of a key */
-static uint16_t tls1_get_group_id(EVP_PKEY *pkey)
-{
-    EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);
-    const EC_GROUP *grp;
-
-    if (ec == NULL)
-        return 0;
-    grp = EC_KEY_get0_group(ec);
-    return tls1_nid2group_id(EC_GROUP_get_curve_name(grp));
-}
-
-/* Check a key is compatible with compression extension */
-static int tls1_check_pkey_comp(SSL *s, EVP_PKEY *pkey)
-{
-    const EC_KEY *ec;
-    const EC_GROUP *grp;
-    unsigned char comp_id;
-    size_t i;
-
-    /* If not an EC key nothing to check */
-    if (EVP_PKEY_id(pkey) != EVP_PKEY_EC)
-        return 1;
-    ec = EVP_PKEY_get0_EC_KEY(pkey);
-    grp = EC_KEY_get0_group(ec);
-
-    /* Get required compression id */
-    if (EC_KEY_get_conv_form(ec) == POINT_CONVERSION_UNCOMPRESSED) {
-            comp_id = TLSEXT_ECPOINTFORMAT_uncompressed;
-    } else if (SSL_IS_TLS13(s)) {
-            /*
-             * ec_point_formats extension is not used in TLSv1.3 so we ignore
-             * this check.
-             */
-            return 1;
-    } else {
-        int field_type = EC_METHOD_get_field_type(EC_GROUP_method_of(grp));
-
-        if (field_type == NID_X9_62_prime_field)
-            comp_id = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime;
-        else if (field_type == NID_X9_62_characteristic_two_field)
-            comp_id = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2;
-        else
-            return 0;
-    }
-    /*
-     * If point formats extension present check it, otherwise everything is
-     * supported (see RFC4492).
-     */
-    if (s-&gt;session-&gt;ext.ecpointformats == NULL)
-        return 1;
-
-    for (i = 0; i &lt; s-&gt;session-&gt;ext.ecpointformats_len; i++) {
-        if (s-&gt;session-&gt;ext.ecpointformats[i] == comp_id)
-            return 1;
-    }
+#else
     return 0;
+#endif
 }
 
 /* Check a group id matches preferences */
@@ -541,7 +519,7 @@ int tls1_check_group_id(SSL *s, uint16_t group_id, int check_own_groups)
             return 0;
     }
 
-    if (!tls_curve_allowed(s, group_id, SSL_SECOP_CURVE_CHECK))
+    if (!tls_group_allowed(s, group_id, SSL_SECOP_CURVE_CHECK))
         return 0;
 
     /* For clients, nothing more to check */
@@ -562,6 +540,7 @@ int tls1_check_group_id(SSL *s, uint16_t group_id, int check_own_groups)
     return tls1_in_list(group_id, groups, groups_len);
 }
 
+#ifndef OPENSSL_NO_EC
 void tls1_get_formatlist(SSL *s, const unsigned char **pformats,
                          size_t *num_formats)
 {
@@ -581,6 +560,65 @@ void tls1_get_formatlist(SSL *s, const unsigned char **pformats,
     }
 }
 
+/* Check a key is compatible with compression extension */
+static int tls1_check_pkey_comp(SSL *s, EVP_PKEY *pkey)
+{
+    const EC_KEY *ec;
+    const EC_GROUP *grp;
+    unsigned char comp_id;
+    size_t i;
+
+    /* If not an EC key nothing to check */
+    if (EVP_PKEY_id(pkey) != EVP_PKEY_EC)
+        return 1;
+    ec = EVP_PKEY_get0_EC_KEY(pkey);
+    grp = EC_KEY_get0_group(ec);
+
+    /* Get required compression id */
+    if (EC_KEY_get_conv_form(ec) == POINT_CONVERSION_UNCOMPRESSED) {
+            comp_id = TLSEXT_ECPOINTFORMAT_uncompressed;
+    } else if (SSL_IS_TLS13(s)) {
+            /*
+             * ec_point_formats extension is not used in TLSv1.3 so we ignore
+             * this check.
+             */
+            return 1;
+    } else {
+        int field_type = EC_METHOD_get_field_type(EC_GROUP_method_of(grp));
+
+        if (field_type == NID_X9_62_prime_field)
+            comp_id = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime;
+        else if (field_type == NID_X9_62_characteristic_two_field)
+            comp_id = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2;
+        else
+            return 0;
+    }
+    /*
+     * If point formats extension present check it, otherwise everything is
+     * supported (see RFC4492).
+     */
+    if (s-&gt;session-&gt;ext.ecpointformats == NULL)
+        return 1;
+
+    for (i = 0; i &lt; s-&gt;session-&gt;ext.ecpointformats_len; i++) {
+        if (s-&gt;session-&gt;ext.ecpointformats[i] == comp_id)
+            return 1;
+    }
+    return 0;
+}
+
+/* Return group id of a key */
+static uint16_t tls1_get_group_id(EVP_PKEY *pkey)
+{
+    EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);
+    const EC_GROUP *grp;
+
+    if (ec == NULL)
+        return 0;
+    grp = EC_KEY_get0_group(ec);
+    return tls1_nid2group_id(EC_GROUP_get_curve_name(grp));
+}
+
 /*
  * Check cert parameters compatible with extensions: currently just checks EC
  * certificates have compatible curves and compression.
diff --git a/test/recipes/70-test_clienthello.t b/test/recipes/70-test_clienthello.t
index a6b812a..0ccbc8e 100644
--- a/test/recipes/70-test_clienthello.t
+++ b/test/recipes/70-test_clienthello.t
@@ -15,6 +15,10 @@ setup(&quot;test_clienthello&quot;);
 plan skip_all =&gt; &quot;No TLS/SSL protocols are supported by this OpenSSL build&quot;
     if alldisabled(grep { $_ ne &quot;ssl3&quot; } available_protocols(&quot;tls&quot;));
 
+#No EC with TLSv1.3 confuses the padding calculations in this test
+plan skip_all =&gt; &quot;No EC with TLSv1.3 is not supported by this test&quot;
+    if disabled(&quot;ec&quot;) &amp;&amp; !disabled(&quot;tls1_3&quot;);
+
 plan tests =&gt; 1;
 
 ok(run(test([&quot;clienthellotest&quot;, srctop_file(&quot;test&quot;, &quot;session.pem&quot;)])),
diff --git a/test/recipes/70-test_key_share.t b/test/recipes/70-test_key_share.t
index eeec055..b5b0190 100644
--- a/test/recipes/70-test_key_share.t
+++ b/test/recipes/70-test_key_share.t
@@ -36,7 +36,9 @@ use constant {
 
 use constant {
     X25519 =&gt; 0x1d,
-    P_256 =&gt; 0x17
+    P_256 =&gt; 0x17,
+    FFDHE2048 =&gt; 0x0100,
+    FFDHE3072 =&gt; 0x0101
 };
 
 my $testtype;
@@ -74,7 +76,11 @@ my $proxy = TLSProxy::Proxy-&gt;new(
 $testtype = EMPTY_EXTENSION;
 $direction = CLIENT_TO_SERVER;
 $proxy-&gt;filter(\&amp;modify_key_shares_filter);
-$proxy-&gt;serverflags(&quot;-curves P-256&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;serverflags(&quot;-groups ffdhe3072&quot;);
+} else {
+    $proxy-&gt;serverflags(&quot;-groups P-256&quot;);
+}
 $proxy-&gt;start() or plan skip_all =&gt; &quot;Unable to start up Proxy for tests&quot;;
 plan tests =&gt; 22;
 ok(TLSProxy::Message-&gt;success(), &quot;Success after HRR&quot;);
@@ -95,31 +101,52 @@ ok(TLSProxy::Message-&gt;fail(), &quot;Missing key_shares extension&quot;);
 #        HelloRetryRequest
 $proxy-&gt;clear();
 $proxy-&gt;filter(undef);
-$proxy-&gt;serverflags(&quot;-curves P-256&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;serverflags(&quot;-groups ffdhe3072&quot;);
+} else {
+    $proxy-&gt;serverflags(&quot;-groups P-256&quot;);
+}
 $proxy-&gt;start();
 ok(TLSProxy::Message-&gt;success(), &quot;No initial acceptable key_shares&quot;);
 
 #Test 5: No acceptable key_shares and no shared groups should fail
 $proxy-&gt;clear();
 $proxy-&gt;filter(undef);
-$proxy-&gt;serverflags(&quot;-curves P-256&quot;);
-$proxy-&gt;clientflags(&quot;-curves P-384&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;serverflags(&quot;-groups ffdhe2048&quot;);
+} else {
+    $proxy-&gt;serverflags(&quot;-groups P-256&quot;);
+}
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;clientflags(&quot;-groups ffdhe3072&quot;);
+} else {
+    $proxy-&gt;clientflags(&quot;-groups P-384&quot;);
+}
 $proxy-&gt;start();
 ok(TLSProxy::Message-&gt;fail(), &quot;No acceptable key_shares&quot;);
 
 #Test 6: A non preferred but acceptable key_share should succeed
 $proxy-&gt;clear();
 $proxy-&gt;clientflags(&quot;-curves P-256&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;clientflags(&quot;-groups ffdhe3072&quot;);
+} else {
+    $proxy-&gt;clientflags(&quot;-groups P-256&quot;);
+}
 $proxy-&gt;start();
 ok(TLSProxy::Message-&gt;success(), &quot;Non preferred key_share&quot;);
 $proxy-&gt;filter(\&amp;modify_key_shares_filter);
 
-#Test 7: An acceptable key_share after a list of non-acceptable ones should
-#succeed
-$proxy-&gt;clear();
-$testtype = ACCEPTABLE_AT_END;
-$proxy-&gt;start();
-ok(TLSProxy::Message-&gt;success(), &quot;Acceptable key_share at end of list&quot;);
+SKIP: {
+    skip &quot;No ec support in this OpenSSL build&quot;, 1 if disabled(&quot;ec&quot;);
+
+    #Test 7: An acceptable key_share after a list of non-acceptable ones should
+    #succeed
+    $proxy-&gt;clear();
+    $testtype = ACCEPTABLE_AT_END;
+    $proxy-&gt;start();
+    ok(TLSProxy::Message-&gt;success(), &quot;Acceptable key_share at end of list&quot;);
+}
 
 #Test 8: An acceptable key_share but for a group not in supported_groups should
 #fail
@@ -156,22 +183,45 @@ ok(TLSProxy::Message-&gt;fail(), &quot;key_share list trailing data&quot;);
 $proxy-&gt;clear();
 $direction = SERVER_TO_CLIENT;
 $testtype = LOOK_ONLY;
-$proxy-&gt;clientflags(&quot;-curves P-256:X25519&quot;);
+$selectedgroupid = 0;
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;clientflags(&quot;-groups ffdhe3072:ffdhe2048&quot;);
+} else {
+    $proxy-&gt;clientflags(&quot;-groups P-256:X25519&quot;);
+}
 $proxy-&gt;start();
-ok(TLSProxy::Message-&gt;success() &amp;&amp; ($selectedgroupid == P_256),
-   &quot;Multiple acceptable key_shares&quot;);
+if (disabled(&quot;ec&quot;)) {
+    ok(TLSProxy::Message-&gt;success() &amp;&amp; ($selectedgroupid == FFDHE3072),
+       &quot;Multiple acceptable key_shares&quot;);
+} else {
+    ok(TLSProxy::Message-&gt;success() &amp;&amp; ($selectedgroupid == P_256),
+       &quot;Multiple acceptable key_shares&quot;);
+}
 
 #Test 14: Multiple acceptable key_shares - we choose the first one (part 2)
 $proxy-&gt;clear();
-$proxy-&gt;clientflags(&quot;-curves X25519:P-256&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;clientflags(&quot;-curves ffdhe2048:ffdhe3072&quot;);
+} else {
+    $proxy-&gt;clientflags(&quot;-curves X25519:P-256&quot;);
+}
 $proxy-&gt;start();
-ok(TLSProxy::Message-&gt;success() &amp;&amp; ($selectedgroupid == X25519),
-   &quot;Multiple acceptable key_shares (part 2)&quot;);
+if (disabled(&quot;ec&quot;)) {
+    ok(TLSProxy::Message-&gt;success() &amp;&amp; ($selectedgroupid == FFDHE2048),
+       &quot;Multiple acceptable key_shares (part 2)&quot;);
+} else {
+    ok(TLSProxy::Message-&gt;success() &amp;&amp; ($selectedgroupid == X25519),
+       &quot;Multiple acceptable key_shares (part 2)&quot;);
+}
 
 #Test 15: Server sends key_share that wasn't offered should fail
 $proxy-&gt;clear();
 $testtype = SELECT_X25519;
-$proxy-&gt;clientflags(&quot;-curves P-256&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;clientflags(&quot;-groups ffdhe3072&quot;);
+} else {
+    $proxy-&gt;clientflags(&quot;-groups P-256&quot;);
+}
 $proxy-&gt;start();
 ok(TLSProxy::Message-&gt;fail(), &quot;Non offered key_share&quot;);
 
@@ -229,7 +279,11 @@ SKIP: {
 $proxy-&gt;clear();
 $direction = SERVER_TO_CLIENT;
 $testtype = NO_KEY_SHARES_IN_HRR;
-$proxy-&gt;serverflags(&quot;-curves X25519&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;serverflags(&quot;-groups ffdhe2048&quot;);
+} else {
+    $proxy-&gt;serverflags(&quot;-groups X25519&quot;);
+}
 $proxy-&gt;start();
 ok(TLSProxy::Message-&gt;fail(), &quot;Server sends HRR with no key_shares&quot;);
 
diff --git a/test/recipes/70-test_sslextension.t b/test/recipes/70-test_sslextension.t
index e725b44..93d7f47 100644
--- a/test/recipes/70-test_sslextension.t
+++ b/test/recipes/70-test_sslextension.t
@@ -217,7 +217,10 @@ SKIP: {
     $proxy-&gt;clientflags(&quot;-no_tls1_3 -noservername&quot;);
     $proxy-&gt;start();
     ok($fatal_alert, &quot;Unsolicited server name extension&quot;);
-
+}
+SKIP: {
+    skip &quot;TLS &lt;= 1.2 disabled or EC disabled&quot;, 1
+        if $no_below_tls13 || disabled(&quot;ec&quot;);
     #Test 5: Inject a noncompliant supported_groups extension (&lt;= TLSv1.2)
     $proxy-&gt;clear();
     $proxy-&gt;filter(\&amp;inject_unsolicited_extension);
diff --git a/test/recipes/70-test_tls13cookie.t b/test/recipes/70-test_tls13cookie.t
index 3f324e3..aef2cf8 100644
--- a/test/recipes/70-test_tls13cookie.t
+++ b/test/recipes/70-test_tls13cookie.t
@@ -46,17 +46,27 @@ my $testtype;
 #Test 1: Inserting a cookie into an HRR should see it echoed in the ClientHello
 $testtype = COOKIE_ONLY;
 $proxy-&gt;filter(\&amp;cookie_filter);
-$proxy-&gt;serverflags(&quot;-curves X25519&quot;);
+$proxy-&gt;serverflags(&quot;-curves X25519&quot;) if !disabled(&quot;ec&quot;);
 $proxy-&gt;start() or plan skip_all =&gt; &quot;Unable to start up Proxy for tests&quot;;
 plan tests =&gt; 2;
-ok(TLSProxy::Message-&gt;success() &amp;&amp; $cookieseen == 1, &quot;Cookie seen&quot;);
+SKIP: {
+    skip &quot;EC disabled&quot;, 1, if disabled(&quot;ec&quot;);
+    ok(TLSProxy::Message-&gt;success() &amp;&amp; $cookieseen == 1, &quot;Cookie seen&quot;);
+}
+
+
 
 #Test 2: Same as test 1 but should also work where a new key_share is also
 #        required
 $testtype = COOKIE_AND_KEY_SHARE;
 $proxy-&gt;clear();
-$proxy-&gt;clientflags(&quot;-curves P-256:X25519&quot;);
-$proxy-&gt;serverflags(&quot;-curves X25519&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;clientflags(&quot;-curves ffdhe3072:ffdhe2048&quot;);
+    $proxy-&gt;serverflags(&quot;-curves ffdhe2048&quot;);
+} else {
+    $proxy-&gt;clientflags(&quot;-curves P-256:X25519&quot;);
+    $proxy-&gt;serverflags(&quot;-curves X25519&quot;);
+}
 $proxy-&gt;start();
 ok(TLSProxy::Message-&gt;success() &amp;&amp; $cookieseen == 1, &quot;Cookie seen&quot;);
 
diff --git a/test/recipes/70-test_tls13hrr.t b/test/recipes/70-test_tls13hrr.t
index 44ca041..8f6e54e 100644
--- a/test/recipes/70-test_tls13hrr.t
+++ b/test/recipes/70-test_tls13hrr.t
@@ -43,7 +43,11 @@ use constant {
 #Test 1: A client should fail if the server changes the ciphersuite between the
 #        HRR and the SH
 $proxy-&gt;filter(\&amp;hrr_filter);
-$proxy-&gt;serverflags(&quot;-curves P-256&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;serverflags(&quot;-curves ffdhe3072&quot;);
+} else {
+    $proxy-&gt;serverflags(&quot;-curves P-256&quot;);
+}
 my $testtype = CHANGE_HRR_CIPHERSUITE;
 $proxy-&gt;start() or plan skip_all =&gt; &quot;Unable to start up Proxy for tests&quot;;
 plan tests =&gt; 2;
@@ -52,7 +56,11 @@ ok(TLSProxy::Message-&gt;fail(), &quot;Server ciphersuite changes&quot;);
 #Test 2: It is an error if the client changes the offered ciphersuites so that
 #        we end up selecting a different ciphersuite between HRR and the SH
 $proxy-&gt;clear();
-$proxy-&gt;serverflags(&quot;-curves P-256&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;serverflags(&quot;-curves ffdhe3072&quot;);
+} else {
+    $proxy-&gt;serverflags(&quot;-curves P-256&quot;);
+}
 $proxy-&gt;ciphersuitess(&quot;TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384&quot;);
 $testtype = CHANGE_CH1_CIPHERSUITE;
 $proxy-&gt;start();
diff --git a/test/recipes/70-test_tls13kexmodes.t b/test/recipes/70-test_tls13kexmodes.t
index 3650601..069d614 100644
--- a/test/recipes/70-test_tls13kexmodes.t
+++ b/test/recipes/70-test_tls13kexmodes.t
@@ -28,6 +28,9 @@ plan skip_all =&gt; &quot;$test_name needs the sock feature enabled&quot;
 plan skip_all =&gt; &quot;$test_name needs TLSv1.3 enabled&quot;
     if disabled(&quot;tls1_3&quot;);
 
+plan skip_all =&gt; &quot;$test_name needs EC enabled&quot;
+    if disabled(&quot;ec&quot;);
+
 $ENV{OPENSSL_ia32cap} = '~0x200000200000000';
 $ENV{CTLOG_FILE} = srctop_file(&quot;test&quot;, &quot;ct&quot;, &quot;log_list.conf&quot;);
 
diff --git a/test/recipes/70-test_tls13messages.t b/test/recipes/70-test_tls13messages.t
index e961528..a3fc35e4 100644
--- a/test/recipes/70-test_tls13messages.t
+++ b/test/recipes/70-test_tls13messages.t
@@ -28,6 +28,9 @@ plan skip_all =&gt; &quot;$test_name needs the sock feature enabled&quot;
 plan skip_all =&gt; &quot;$test_name needs TLSv1.3 enabled&quot;
     if disabled(&quot;tls1_3&quot;);
 
+plan skip_all =&gt; &quot;$test_name needs EC enabled&quot;
+    if disabled(&quot;ec&quot;);
+
 $ENV{OPENSSL_ia32cap} = '~0x200000200000000';
 $ENV{CTLOG_FILE} = srctop_file(&quot;test&quot;, &quot;ct&quot;, &quot;log_list.conf&quot;);
 
diff --git a/test/recipes/70-test_tls13psk.t b/test/recipes/70-test_tls13psk.t
index 40e6ed1..11031f3f 100644
--- a/test/recipes/70-test_tls13psk.t
+++ b/test/recipes/70-test_tls13psk.t
@@ -66,7 +66,11 @@ ok(TLSProxy::Message-&gt;fail(), &quot;PSK not last&quot;);
 #        ciphersuite. Should see PSK on second ClientHello
 $proxy-&gt;clear();
 $proxy-&gt;clientflags(&quot;-sess_in &quot;.$session);
-$proxy-&gt;serverflags(&quot;-curves P-256&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;serverflags(&quot;-curves ffdhe3072&quot;);
+} else {
+    $proxy-&gt;serverflags(&quot;-curves P-256&quot;);
+}
 $proxy-&gt;filter(undef);
 $proxy-&gt;start();
 #Check if the PSK is present in the second ClientHello
@@ -81,7 +85,11 @@ ok($pskseen, &quot;PSK hash matches&quot;);
 $proxy-&gt;clear();
 $proxy-&gt;clientflags(&quot;-sess_in &quot;.$session);
 $proxy-&gt;filter(\&amp;modify_psk_filter);
-$proxy-&gt;serverflags(&quot;-curves P-256&quot;);
+if (disabled(&quot;ec&quot;)) {
+    $proxy-&gt;serverflags(&quot;-curves ffdhe3072&quot;);
+} else {
+    $proxy-&gt;serverflags(&quot;-curves P-256&quot;);
+}
 $proxy-&gt;ciphersuitesc(&quot;TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384&quot;);
 $proxy-&gt;ciphersuitess(&quot;TLS_AES_256_GCM_SHA384&quot;);
 #We force an early failure because TLS Proxy doesn't actually support
diff --git a/test/recipes/80-test_ssl_new.t b/test/recipes/80-test_ssl_new.t
index 31c4399..04a0c13 100644
--- a/test/recipes/80-test_ssl_new.t
+++ b/test/recipes/80-test_ssl_new.t
@@ -59,7 +59,7 @@ my %conf_dependent_tests = (
                            || !disabled(&quot;sctp&quot;),
   &quot;05-sni.conf&quot; =&gt; disabled(&quot;tls1_1&quot;),
   &quot;07-dtls-protocol-version.conf&quot; =&gt; !$is_default_dtls || !disabled(&quot;sctp&quot;),
-  &quot;10-resumption.conf&quot; =&gt; !$is_default_tls,
+  &quot;10-resumption.conf&quot; =&gt; !$is_default_tls || $no_ec,
   &quot;11-dtls_resumption.conf&quot; =&gt; !$is_default_dtls || !disabled(&quot;sctp&quot;),
   &quot;16-dtls-certstatus.conf&quot; =&gt; !$is_default_dtls || !disabled(&quot;sctp&quot;),
   &quot;17-renegotiate.conf&quot; =&gt; disabled(&quot;tls1_2&quot;),
diff --git a/test/recipes/90-test_gost.t b/test/recipes/90-test_gost.t
index d4f27b8..b01243f 100644
--- a/test/recipes/90-test_gost.t
+++ b/test/recipes/90-test_gost.t
@@ -21,6 +21,10 @@ plan skip_all =&gt; &quot;GOST support is disabled in this OpenSSL build&quot;
 plan skip_all =&gt; &quot;TLSv1.3 or TLSv1.2 are disabled in this OpenSSL build&quot;
     if disabled(&quot;tls1_3&quot;) || disabled(&quot;tls1_2&quot;);
 
+plan skip_all =&gt; &quot;EC is disabled in this OpenSSL build&quot;
+    if disabled(&quot;ec&quot;);
+
+
 plan skip_all =&gt; &quot;No test GOST engine found&quot;
     if !$ENV{OPENSSL_GOST_ENGINE_SO};
 
diff --git a/test/ssl-tests/protocol_version.pm b/test/ssl-tests/protocol_version.pm
index 6c2e778..6923e21 100644
--- a/test/ssl-tests/protocol_version.pm
+++ b/test/ssl-tests/protocol_version.pm
@@ -252,7 +252,7 @@ sub generate_resumption_tests {
             &quot;client&quot; =&gt; {
             },
             &quot;server&quot; =&gt; {
-                &quot;Curves&quot; =&gt; &quot;P-256&quot;
+                &quot;Curves&quot; =&gt; disabled(&quot;ec&quot;) ? &quot;ffdhe3072&quot; : &quot;P-256&quot;
             },
             &quot;resume_client&quot; =&gt; {
             },
diff --git a/test/sslapitest.c b/test/sslapitest.c
index efa42a0..9a993f7 100644
--- a/test/sslapitest.c
+++ b/test/sslapitest.c
@@ -2960,8 +2960,13 @@ static int early_data_skip_helper(int testtype, int idx)
 
     if (testtype == 1 || testtype == 2) {
         /* Force an HRR to occur */
+#if defined(OPENSSL_NO_EC)
+        if (!TEST_true(SSL_set1_groups_list(serverssl, &quot;ffdhe3072&quot;)))
+            goto end;
+#else
         if (!TEST_true(SSL_set1_groups_list(serverssl, &quot;P-256&quot;)))
             goto end;
+#endif
     } else if (idx == 2) {
         /*
          * We force early_data rejection by ensuring the PSK identity is
@@ -3738,8 +3743,8 @@ static int test_ciphersuite_change(void)
 /*
  * Test TLSv1.3 Key exchange
  * Test 0 = Test ECDHE Key exchange
- * Test 1 = Test FFDHE Key exchange
- * Test 2 = Test ECDHE with TLSv1.2 client and TLSv1.2 server
+ * Test 1 = Test ECDHE with TLSv1.2 client and TLSv1.2 server
+ * Test 2 = Test FFDHE Key exchange
  * Test 3 = Test FFDHE with TLSv1.2 client and TLSv1.2 server
  */
 static int test_tls13_key_exchange(int idx)
@@ -3747,8 +3752,10 @@ static int test_tls13_key_exchange(int idx)
     SSL_CTX *sctx = NULL, *cctx = NULL;
     SSL *serverssl = NULL, *clientssl = NULL;
     int testresult = 0;
+#ifndef OPENSSL_NO_EC
     int ecdhe_kexch_groups[] = {NID_X9_62_prime256v1, NID_secp384r1, NID_secp521r1,
                                 NID_X25519, NID_X448};
+#endif
 #ifndef OPENSSL_NO_DH
     int ffdhe_kexch_groups[] = {NID_ffdhe2048, NID_ffdhe3072, NID_ffdhe4096,
                                 NID_ffdhe6144, NID_ffdhe8192};
@@ -3761,32 +3768,22 @@ static int test_tls13_key_exchange(int idx)
     int expected_err_reason = 0;
 
     switch (idx) {
-        case 0:
-            kexch_groups = ecdhe_kexch_groups;
-            kexch_groups_size = OSSL_NELEM(ecdhe_kexch_groups);
-            break;
 #ifndef OPENSSL_NO_DH
-        case 1:
+        case 3:
+            max_version = TLS1_2_VERSION;
+            /* Fall through */
+        case 2:
             kexch_groups = ffdhe_kexch_groups;
             kexch_groups_size = OSSL_NELEM(ffdhe_kexch_groups);
             break;
 #endif
-        case 2:
+#ifndef OPENSSL_NO_EC
+        case 1:
+            max_version = TLS1_2_VERSION;
+            /* Fall through */
+        case 0:
             kexch_groups = ecdhe_kexch_groups;
             kexch_groups_size = OSSL_NELEM(ecdhe_kexch_groups);
-            max_version = TLS1_2_VERSION;
-            expected_err_func = SSL_F_TLS_POST_PROCESS_CLIENT_HELLO;
-            expected_err_reason = SSL_R_NO_SHARED_CIPHER;
-            want_err = SSL_ERROR_SSL;
-            break;
-#ifndef OPENSSL_NO_DH
-        case 3:
-            kexch_groups = ffdhe_kexch_groups;
-            kexch_groups_size = OSSL_NELEM(ffdhe_kexch_groups);
-            max_version = TLS1_2_VERSION;
-            want_err = SSL_ERROR_SSL;
-            expected_err_func = SSL_F_TLS_CONSTRUCT_CTOS_SUPPORTED_GROUPS;
-            expected_err_reason = ERR_R_INTERNAL_ERROR;
             break;
 #endif
         default:
@@ -3805,10 +3802,16 @@ static int test_tls13_key_exchange(int idx)
     if (!TEST_true(SSL_CTX_set_ciphersuites(cctx, TLS1_3_RFC_AES_128_GCM_SHA256)))
         goto end;
 
-    if (!TEST_true(SSL_CTX_set_cipher_list(sctx, TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM)))
+    if (!TEST_true(SSL_CTX_set_cipher_list(sctx, TLS1_TXT_RSA_WITH_AES_128_SHA)))
         goto end;
 
-    if (!TEST_true(SSL_CTX_set_cipher_list(cctx, TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM)))
+    /*
+     * Must include an EC ciphersuite so that we send supported groups in
+     * TLSv1.2
+     */
+    if (!TEST_true(SSL_CTX_set_cipher_list(cctx,
+                   TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM &quot;:&quot;
+                   TLS1_TXT_RSA_WITH_AES_128_SHA)))
         goto end;
 
     if (!TEST_true(create_ssl_objects(sctx, cctx, &amp;serverssl, &amp;clientssl,
@@ -3828,14 +3831,20 @@ static int test_tls13_key_exchange(int idx)
     /* Fail if expected error is not happening for failure testcases */
     if (expected_err_func) {
         unsigned long err_code = ERR_get_error();
+        ERR_print_errors_fp(stdout);
         if (TEST_int_eq(ERR_GET_FUNC(err_code), expected_err_func)
                 &amp;&amp; TEST_int_eq(ERR_GET_REASON(err_code), expected_err_reason))
             testresult = 1;
         goto end;
     }
 
-    /* If Handshake succeeds the negotiated kexch alg should the first one in configured */
-    if (!TEST_int_eq(SSL_get_shared_group(serverssl, 0), kexch_groups[0]))
+    /*
+     * If Handshake succeeds the negotiated kexch alg should the first one in
+     * configured, except in the case of FFDHE groups which are TLSv1.3 only
+     * so we expect no shared group to exist.
+     */
+    if (!TEST_int_eq(SSL_get_shared_group(serverssl, 0),
+                     idx == 3 ? 0 : kexch_groups[0]))
         goto end;
 
     testresult = 1;
@@ -3990,8 +3999,13 @@ static int test_tls13_psk(int idx)
         goto end;
 
     /* Force an HRR */
+#if defined(OPENSSL_NO_EC)
+    if (!TEST_true(SSL_set1_groups_list(serverssl, &quot;ffdhe3072&quot;)))
+        goto end;
+#else
     if (!TEST_true(SSL_set1_groups_list(serverssl, &quot;P-256&quot;)))
         goto end;
+#endif
 
     /*
      * Check we can create a connection, the PSK is used and the callbacks are
diff --git a/test/tls13ccstest.c b/test/tls13ccstest.c
index d89354c..1d0a268 100644
--- a/test/tls13ccstest.c
+++ b/test/tls13ccstest.c
@@ -315,8 +315,15 @@ static int test_tls13ccs(int tst)
 
     if ((tst &gt;= 3 &amp;&amp; tst &lt;= 5) || tst &gt;= 9) {
         /* HRR handshake */
+#if defined(OPENSSL_NO_EC)
+# if !defined(OPENSSL_NO_DH)
+        if (!TEST_true(SSL_CTX_set1_groups_list(sctx, &quot;ffdhe3072&quot;)))
+            goto err;
+# endif
+#else
         if (!TEST_true(SSL_CTX_set1_groups_list(sctx, &quot;P-256&quot;)))
             goto err;
+#endif
     }
 
     s_to_c_fbio = BIO_new(bio_f_watchccs_filter());
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="023553.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="023557.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23554">[ date ]</a>
              <a href="thread.html#23554">[ thread ]</a>
              <a href="subject.html#23554">[ subject ]</a>
              <a href="author.html#23554">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
