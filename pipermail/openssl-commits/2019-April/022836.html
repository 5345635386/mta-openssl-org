<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-April/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1555408831.916678.14491.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022831.html">
   <LINK REL="Next"  HREF="022845.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1555408831.916678.14491.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Tue Apr 16 10:00:31 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="022831.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="022845.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22836">[ date ]</a>
              <a href="thread.html#22836">[ thread ]</a>
              <a href="subject.html#22836">[ subject ]</a>
              <a href="author.html#22836">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  06add280d90de9625e9c18985f376ef8d0419a46 (commit)
       via  3d42833d389134b7b05b655c264e4dba5a2179e9 (commit)
       via  d34bce03acc53c583df954bbed65d4800751563a (commit)
       via  c9dc22bc3d7f2df670dff66f04935e540e1b931a (commit)
       via  b238fb79709a180ba9b4d837101c9f75e2978dc0 (commit)
      from  3e3dcf9ab8a2fc0214502dad56d94fd95bcbbfd5 (commit)


- Log -----------------------------------------------------------------
commit 06add280d90de9625e9c18985f376ef8d0419a46
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
Date:   Thu Apr 4 09:49:36 2019 +0200

    Add test for the BIO_s_mem rdwr-&gt;rdonly-&gt;rdwr use-case
    
    Reviewed-by: Bernd Edlinger &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">bernd.edlinger at hotmail.de</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8649">https://github.com/openssl/openssl/pull/8649</A>)

commit 3d42833d389134b7b05b655c264e4dba5a2179e9
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
Date:   Thu Apr 4 09:48:47 2019 +0200

    Add documentation for the BIO_s_mem pecularities
    
    Reviewed-by: Bernd Edlinger &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">bernd.edlinger at hotmail.de</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8649">https://github.com/openssl/openssl/pull/8649</A>)

commit d34bce03acc53c583df954bbed65d4800751563a
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
Date:   Wed Apr 3 19:07:00 2019 +0200

    Add testing of RDONLY memory BIOs
    
    Reviewed-by: Bernd Edlinger &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">bernd.edlinger at hotmail.de</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8649">https://github.com/openssl/openssl/pull/8649</A>)

commit c9dc22bc3d7f2df670dff66f04935e540e1b931a
Author: Bernd Edlinger &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">bernd.edlinger at hotmail.de</A>&gt;
Date:   Fri Mar 1 01:55:38 2019 +0100

    Add test for the BIO_get_mem_ptr() regression
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8649">https://github.com/openssl/openssl/pull/8649</A>)

commit b238fb79709a180ba9b4d837101c9f75e2978dc0
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
Date:   Wed Apr 3 12:31:32 2019 +0200

    Fix for BIO_get_mem_ptr and related regressions
    
    Reviewed-by: Bernd Edlinger &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">bernd.edlinger at hotmail.de</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8649">https://github.com/openssl/openssl/pull/8649</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/bio/bss_mem.c    |  41 +++++++++----
 doc/man3/BIO_s_mem.pod  |  16 +++++
 test/bio_memleak_test.c | 158 ++++++++++++++++++++++++++++++++++++++++++++++--
 3 files changed, 197 insertions(+), 18 deletions(-)

diff --git a/crypto/bio/bss_mem.c b/crypto/bio/bss_mem.c
index 89c54b2..a7f2bfb 100644
--- a/crypto/bio/bss_mem.c
+++ b/crypto/bio/bss_mem.c
@@ -57,7 +57,12 @@ static const BIO_METHOD secmem_method = {
     NULL,                      /* mem_callback_ctrl */
 };
 
-/* BIO memory stores buffer and read pointer  */
+/*
+ * BIO memory stores buffer and read pointer
+ * however the roles are different for read only BIOs.
+ * In that case the readp just stores the original state
+ * to be used for reset.
+ */
 typedef struct bio_buf_mem_st {
     struct buf_mem_st *buf;   /* allocated buffer */
     struct buf_mem_st *readp; /* read pointer */
@@ -192,11 +197,14 @@ static int mem_read(BIO *b, char *out, int outl)
     BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)b-&gt;ptr;
     BUF_MEM *bm = bbm-&gt;readp;
 
+    if (b-&gt;flags &amp; BIO_FLAGS_MEM_RDONLY)
+        bm = bbm-&gt;buf;
     BIO_clear_retry_flags(b);
     ret = (outl &gt;= 0 &amp;&amp; (size_t)outl &gt; bm-&gt;length) ? (int)bm-&gt;length : outl;
     if ((out != NULL) &amp;&amp; (ret &gt; 0)) {
         memcpy(out, bm-&gt;data, ret);
         bm-&gt;length -= ret;
+        bm-&gt;max -= ret;
         bm-&gt;data += ret;
     } else if (bm-&gt;length == 0) {
         ret = b-&gt;num;
@@ -241,29 +249,36 @@ static long mem_ctrl(BIO *b, int cmd, long num, void *ptr)
     BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)b-&gt;ptr;
     BUF_MEM *bm;
 
+    if (b-&gt;flags &amp; BIO_FLAGS_MEM_RDONLY)
+        bm = bbm-&gt;buf;
+    else
+        bm = bbm-&gt;readp;
+
     switch (cmd) {
     case BIO_CTRL_RESET:
         bm = bbm-&gt;buf;
         if (bm-&gt;data != NULL) {
-            /* For read only case reset to the start again */
-            if ((b-&gt;flags &amp; BIO_FLAGS_MEM_RDONLY) || (b-&gt;flags &amp; BIO_FLAGS_NONCLEAR_RST)) {
-                bm-&gt;length = bm-&gt;max;
+            if (!(b-&gt;flags &amp; BIO_FLAGS_MEM_RDONLY)) {
+                if (b-&gt;flags &amp; BIO_FLAGS_NONCLEAR_RST) {
+                    bm-&gt;length = bm-&gt;max;
+                } else {
+                    memset(bm-&gt;data, 0, bm-&gt;max);
+                    bm-&gt;length = 0;
+                }
+                *bbm-&gt;readp = *bbm-&gt;buf;
             } else {
-                memset(bm-&gt;data, 0, bm-&gt;max);
-                bm-&gt;length = 0;
+                /* For read only case just reset to the start again */
+                *bbm-&gt;buf = *bbm-&gt;readp;
             }
-            *bbm-&gt;readp = *bbm-&gt;buf;
         }
         break;
     case BIO_CTRL_EOF:
-        bm = bbm-&gt;readp;
         ret = (long)(bm-&gt;length == 0);
         break;
     case BIO_C_SET_BUF_MEM_EOF_RETURN:
         b-&gt;num = (int)num;
         break;
     case BIO_CTRL_INFO:
-        bm = bbm-&gt;readp;
         ret = (long)bm-&gt;length;
         if (ptr != NULL) {
             pptr = (char **)ptr;
@@ -278,8 +293,9 @@ static long mem_ctrl(BIO *b, int cmd, long num, void *ptr)
         break;
     case BIO_C_GET_BUF_MEM_PTR:
         if (ptr != NULL) {
-            mem_buf_sync(b);
-            bm = bbm-&gt;readp;
+            if (!(b-&gt;flags &amp; BIO_FLAGS_MEM_RDONLY))
+                mem_buf_sync(b);
+            bm = bbm-&gt;buf;
             pptr = (char **)ptr;
             *pptr = (char *)bm;
         }
@@ -294,7 +310,6 @@ static long mem_ctrl(BIO *b, int cmd, long num, void *ptr)
         ret = 0L;
         break;
     case BIO_CTRL_PENDING:
-        bm = bbm-&gt;readp;
         ret = (long)bm-&gt;length;
         break;
     case BIO_CTRL_DUP:
@@ -318,6 +333,8 @@ static int mem_gets(BIO *bp, char *buf, int size)
     BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)bp-&gt;ptr;
     BUF_MEM *bm = bbm-&gt;readp;
 
+    if (bp-&gt;flags &amp; BIO_FLAGS_MEM_RDONLY)
+        bm = bbm-&gt;buf;
     BIO_clear_retry_flags(bp);
     j = bm-&gt;length;
     if ((size - 1) &lt; j)
diff --git a/doc/man3/BIO_s_mem.pod b/doc/man3/BIO_s_mem.pod
index bd0824a..6d9e747 100644
--- a/doc/man3/BIO_s_mem.pod
+++ b/doc/man3/BIO_s_mem.pod
@@ -88,6 +88,22 @@ a buffering BIO to the chain will speed up the process.
 Calling BIO_set_mem_buf() on a BIO created with BIO_new_secmem() will
 give undefined results, including perhaps a program crash.
 
+Switching the memory BIO from read write to read only is not supported and
+can give undefined results including a program crash. There are two notable
+exceptions to the rule. The first one is to assign a static memory buffer
+immediately after BIO creation and set the BIO as read only.
+
+The other supported sequence is to start with read write BIO then temporarily
+switch it to read only and call BIO_reset() on the read only BIO immediately
+before switching it back to read write. Before the BIO is freed it must be
+switched back to the read write mode.
+
+Calling BIO_get_mem_ptr() on read only BIO will return a BUF_MEM that
+contains only the remaining data to be read. If the close status of the
+BIO is set to BIO_NOCLOSE, before freeing the BUF_MEM the data pointer
+in it must be set to NULL as the data pointer does not point to an
+allocated memory.
+
 =head1 BUGS
 
 There should be an option to set the maximum size of a memory BIO.
diff --git a/test/bio_memleak_test.c b/test/bio_memleak_test.c
index 36680e3..fab5ce7 100644
--- a/test/bio_memleak_test.c
+++ b/test/bio_memleak_test.c
@@ -18,28 +18,170 @@ static int test_bio_memleak(void)
     int ok = 0;
     BIO *bio;
     BUF_MEM bufmem;
-    const char *str = &quot;BIO test\n&quot;;
+    static const char str[] = &quot;BIO test\n&quot;;
     char buf[100];
 
     bio = BIO_new(BIO_s_mem());
-    if (bio == NULL)
+    if (!TEST_ptr(bio))
         goto finish;
-    bufmem.length = strlen(str) + 1;
+    bufmem.length = sizeof(str);
     bufmem.data = (char *) str;
     bufmem.max = bufmem.length;
     BIO_set_mem_buf(bio, &amp;bufmem, BIO_NOCLOSE);
     BIO_set_flags(bio, BIO_FLAGS_MEM_RDONLY);
+    if (!TEST_int_eq(BIO_read(bio, buf, sizeof(buf)), sizeof(str)))
+        goto finish;
+    if (!TEST_mem_eq(buf, sizeof(str), str, sizeof(str)))
+        goto finish;
+    ok = 1;
 
-    if (BIO_read(bio, buf, sizeof(buf)) &lt;= 0)
-	goto finish;
+finish:
+    BIO_free(bio);
+    return ok;
+}
 
-    ok = strcmp(buf, str) == 0;
+static int test_bio_get_mem(void)
+{
+    int ok = 0;
+    BIO *bio = NULL;
+    BUF_MEM *bufmem = NULL;
+
+    bio = BIO_new(BIO_s_mem());
+    if (!TEST_ptr(bio))
+        goto finish;
+    if (!TEST_int_eq(BIO_puts(bio, &quot;Hello World\n&quot;), 12))
+        goto finish;
+    BIO_get_mem_ptr(bio, &amp;bufmem);
+    if (!TEST_ptr(bufmem))
+        goto finish;
+    if (!TEST_int_gt(BIO_set_close(bio, BIO_NOCLOSE), 0))
+        goto finish;
+    BIO_free(bio);
+    bio = NULL;
+    if (!TEST_mem_eq(bufmem-&gt;data, bufmem-&gt;length, &quot;Hello World\n&quot;, 12))
+        goto finish;
+    ok = 1;
 
 finish:
     BIO_free(bio);
+    BUF_MEM_free(bufmem);
     return ok;
 }
 
+static int test_bio_new_mem_buf(void)
+{
+    int ok = 0;
+    BIO *bio;
+    BUF_MEM *bufmem;
+    char data[16];
+
+    bio = BIO_new_mem_buf(&quot;Hello World\n&quot;, 12);
+    if (!TEST_ptr(bio))
+        goto finish;
+    if (!TEST_int_eq(BIO_read(bio, data, 5), 5))
+        goto finish;
+    if (!TEST_mem_eq(data, 5, &quot;Hello&quot;, 5))
+        goto finish;
+    if (!TEST_int_gt(BIO_get_mem_ptr(bio, &amp;bufmem), 0))
+        goto finish;
+    if (!TEST_int_lt(BIO_write(bio, &quot;test&quot;, 4), 0))
+        goto finish;
+    if (!TEST_int_eq(BIO_read(bio, data, 16), 7))
+        goto finish;
+    if (!TEST_mem_eq(data, 7, &quot; World\n&quot;, 7))
+        goto finish;
+    if (!TEST_int_gt(BIO_reset(bio), 0))
+        goto finish;
+    if (!TEST_int_eq(BIO_read(bio, data, 16), 12))
+        goto finish;
+    if (!TEST_mem_eq(data, 12, &quot;Hello World\n&quot;, 12))
+        goto finish;
+    ok = 1;
+
+finish:
+    BIO_free(bio);
+    return ok;
+}
+
+static int test_bio_rdonly_mem_buf(void)
+{
+    int ok = 0;
+    BIO *bio, *bio2 = NULL;
+    BUF_MEM *bufmem;
+    char data[16];
+
+    bio = BIO_new_mem_buf(&quot;Hello World\n&quot;, 12);
+    if (!TEST_ptr(bio))
+        goto finish;
+    if (!TEST_int_eq(BIO_read(bio, data, 5), 5))
+        goto finish;
+    if (!TEST_mem_eq(data, 5, &quot;Hello&quot;, 5))
+        goto finish;
+    if (!TEST_int_gt(BIO_get_mem_ptr(bio, &amp;bufmem), 0))
+        goto finish;
+    (void)BIO_set_close(bio, BIO_NOCLOSE);
+
+    bio2 = BIO_new(BIO_s_mem());
+    if (!TEST_ptr(bio2))
+        goto finish;
+    BIO_set_mem_buf(bio2, bufmem, BIO_CLOSE);
+    BIO_set_flags(bio2, BIO_FLAGS_MEM_RDONLY);
+
+    if (!TEST_int_eq(BIO_read(bio2, data, 16), 7))
+        goto finish;
+    if (!TEST_mem_eq(data, 7, &quot; World\n&quot;, 7))
+        goto finish;
+    if (!TEST_int_gt(BIO_reset(bio2), 0))
+        goto finish;
+    if (!TEST_int_eq(BIO_read(bio2, data, 16), 7))
+        goto finish;
+    if (!TEST_mem_eq(data, 7, &quot; World\n&quot;, 7))
+        goto finish;
+    ok = 1;
+
+finish:
+    BIO_free(bio);
+    BIO_free(bio2);
+    return ok;
+}
+
+static int test_bio_rdwr_rdonly(void)
+{
+    int ok = 0;
+    BIO *bio = NULL;
+    char data[16];
+
+    bio = BIO_new(BIO_s_mem());
+    if (!TEST_ptr(bio))
+        goto finish;
+    if (!TEST_int_eq(BIO_puts(bio, &quot;Hello World\n&quot;), 12))
+        goto finish;
+
+    BIO_set_flags(bio, BIO_FLAGS_MEM_RDONLY);
+    if (!TEST_int_eq(BIO_read(bio, data, 16), 12))
+        goto finish;
+    if (!TEST_mem_eq(data, 12, &quot;Hello World\n&quot;, 12))
+        goto finish;
+    if (!TEST_int_gt(BIO_reset(bio), 0))
+        goto finish;
+
+    BIO_clear_flags(bio, BIO_FLAGS_MEM_RDONLY);
+    if (!TEST_int_eq(BIO_puts(bio, &quot;Hi!\n&quot;), 4))
+        goto finish;
+    if (!TEST_int_eq(BIO_read(bio, data, 16), 16))
+        goto finish;
+
+    if (!TEST_mem_eq(data, 16, &quot;Hello World\nHi!\n&quot;, 16))
+        goto finish;
+
+    ok = 1;
+
+finish:
+    BIO_free(bio);
+    return ok;
+}
+
+
 int global_init(void)
 {
     CRYPTO_set_mem_debug(1);
@@ -50,5 +192,9 @@ int global_init(void)
 int setup_tests(void)
 {
     ADD_TEST(test_bio_memleak);
+    ADD_TEST(test_bio_get_mem);
+    ADD_TEST(test_bio_new_mem_buf);
+    ADD_TEST(test_bio_rdonly_mem_buf);
+    ADD_TEST(test_bio_rdwr_rdonly);
     return 1;
 }
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022831.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="022845.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22836">[ date ]</a>
              <a href="thread.html#22836">[ thread ]</a>
              <a href="subject.html#22836">[ subject ]</a>
              <a href="author.html#22836">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
