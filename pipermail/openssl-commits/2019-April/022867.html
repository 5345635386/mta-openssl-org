<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-April/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1555662984.609842.12941.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022866.html">
   <LINK REL="Next"  HREF="022868.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1555662984.609842.12941.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Fri Apr 19 08:36:24 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="022866.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="022868.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22867">[ date ]</a>
              <a href="thread.html#22867">[ thread ]</a>
              <a href="subject.html#22867">[ subject ]</a>
              <a href="author.html#22867">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  6caf7f3aec5484ee65067e9671299d3411565dc1 (commit)
       via  64adf9aac765f0872c33d225c57e5c128f5d7c69 (commit)
       via  3a7b15e484f950d4cb4061d93839802ecb74f8e5 (commit)
       via  dcd446f1005f5c99768965a11c10dd6c7b6aee59 (commit)
       via  3b94944cf2d6476d1b8ac7949bf8b28abb644426 (commit)
       via  344cfa34e5b07f8b8b7f1e70f47f5d265c9c1185 (commit)
       via  819a7ae9fc7721f675757c0925821f91b20dfc8f (commit)
       via  75dd6d64f1f3afd6fda024d8d91bc2a216bbfcf9 (commit)
       via  ed98df51c69717529dd7d775b35430c036216339 (commit)
       via  718b133a5328108099ecac0bf40d8fd4886e7b64 (commit)
       via  f4a129bb8dc26488e29b06e06e96a76c93f966be (commit)
       via  861b8f8747965bf98d9dd328196b8092e709c99d (commit)
       via  aab26e6f7b437f7d4bace03cd855a33d7a34d927 (commit)
       via  df05f2ce6d496232f3c86acb299a128d0eb3ef42 (commit)
      from  1393722af384cdf310645c598bbd06a3bbaa2f31 (commit)


- Log -----------------------------------------------------------------
commit 6caf7f3aec5484ee65067e9671299d3411565dc1
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Apr 18 17:43:05 2019 +0100

    Create provider errors and use them
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit 64adf9aac765f0872c33d225c57e5c128f5d7c69
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Apr 16 15:37:23 2019 +0100

    Fix the S390X support for the basic AES ciphers
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit 3a7b15e484f950d4cb4061d93839802ecb74f8e5
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Apr 15 15:33:58 2019 +0100

    Add forward declarations of the AES dispatch table functions
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit dcd446f1005f5c99768965a11c10dd6c7b6aee59
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 10 13:54:38 2019 +0100

    Make implementation of blocksize, iv_length and key_length mandatory
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit 3b94944cf2d6476d1b8ac7949bf8b28abb644426
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 10 13:43:45 2019 +0100

    Add a maximum output length to update and final calls
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit 344cfa34e5b07f8b8b7f1e70f47f5d265c9c1185
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 10 13:23:58 2019 +0100

    Add iv length and key length params to the cipher init calls
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit 819a7ae9fc7721f675757c0925821f91b20dfc8f
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Apr 8 17:19:59 2019 +0100

    Implement AES CTR ciphers in the default provider
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit 75dd6d64f1f3afd6fda024d8d91bc2a216bbfcf9
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Apr 8 17:13:01 2019 +0100

    Implement AES CFB ciphers in the default provider
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit ed98df51c69717529dd7d775b35430c036216339
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon Apr 8 16:55:34 2019 +0100

    Implement AES OFB ciphers in the default provider
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit 718b133a5328108099ecac0bf40d8fd4886e7b64
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 3 18:01:21 2019 +0100

    Implement AES CBC ciphers in the default provider
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit f4a129bb8dc26488e29b06e06e96a76c93f966be
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 3 16:53:22 2019 +0100

    Add support in the default provider for 192/128 bit AES ECB
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit 861b8f8747965bf98d9dd328196b8092e709c99d
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 3 16:39:34 2019 +0100

    Add the provider_algs.h internal header file
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit aab26e6f7b437f7d4bace03cd855a33d7a34d927
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 3 15:34:08 2019 +0100

    Implement support for AES-256-ECB in the default provider
    
    We also lay the ground work for various of other the basic AES ciphers.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

commit df05f2ce6d496232f3c86acb299a128d0eb3ef42
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Apr 3 15:38:07 2019 +0100

    Make EVP_Encrypt*/EVP_Decrypt* and EVP_Cipher* provider aware
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8700">https://github.com/openssl/openssl/pull/8700</A>)

-----------------------------------------------------------------------

Summary of changes:
 build.info                                         |   2 +-
 crypto/err/err.c                                   |   1 +
 crypto/err/err_all.c                               |   4 +-
 crypto/err/openssl.ec                              |   1 +
 crypto/err/openssl.txt                             |  27 +
 crypto/evp/cmeth_lib.c                             |  32 +-
 crypto/evp/digest.c                                |   2 +-
 crypto/evp/evp_enc.c                               | 531 ++++++++++++-
 crypto/evp/evp_err.c                               |   7 +
 crypto/evp/evp_lib.c                               | 133 +++-
 crypto/evp/evp_locl.h                              |   4 +
 crypto/include/internal/evp_int.h                  |  24 +
 include/openssl/core_names.h                       |   6 +
 include/openssl/core_numbers.h                     |  55 +-
 include/openssl/err.h                              |   2 +
 include/openssl/evp.h                              |   5 +-
 include/openssl/evperr.h                           |   4 +
 providers/build.info                               |   2 +-
 providers/common/build.info                        |   5 +-
 providers/common/ciphers/aes.c                     | 470 +++++++++++
 providers/common/ciphers/aes_basic.c               | 866 +++++++++++++++++++++
 providers/common/ciphers/block.c                   | 118 +++
 providers/common/ciphers/build.info                |   4 +
 providers/common/ciphers/ciphers_locl.h            | 107 +++
 providers/common/digests/sha2.c                    |   4 +-
 providers/common/include/internal/provider_algs.h  |  34 +
 .../common/include/internal/providercommon.h       |   0
 .../common/include/internal/providercommonerr.h    |  54 ++
 providers/common/provider_err.c                    |  67 ++
 providers/default/defltprov.c                      |  30 +-
 providers/legacy/digests/md2.c                     |   2 +-
 util/ck_errf.pl                                    |   3 +-
 util/libcrypto.num                                 |   3 +
 util/mkerr.pl                                      |   3 +-
 34 files changed, 2550 insertions(+), 62 deletions(-)
 create mode 100644 providers/common/ciphers/aes.c
 create mode 100644 providers/common/ciphers/aes_basic.c
 create mode 100644 providers/common/ciphers/block.c
 create mode 100644 providers/common/ciphers/build.info
 create mode 100644 providers/common/ciphers/ciphers_locl.h
 create mode 100644 providers/common/include/internal/provider_algs.h
 copy fuzz/corpora/ct/e53301b7bba90f14da5195be2e47ec3f88924694 =&gt; providers/common/include/internal/providercommon.h (100%)
 create mode 100644 providers/common/include/internal/providercommonerr.h
 create mode 100644 providers/common/provider_err.c

diff --git a/build.info b/build.info
index a0ecb21..ce5dfd0 100644
--- a/build.info
+++ b/build.info
@@ -3,7 +3,7 @@
 SUBDIRS=crypto ssl apps test util tools fuzz engines providers
 
 LIBS=libcrypto libssl
-INCLUDE[libcrypto]=. crypto/include include
+INCLUDE[libcrypto]=. crypto/include include providers/common/include
 INCLUDE[libssl]=. include
 DEPEND[libssl]=libcrypto
 
diff --git a/crypto/err/err.c b/crypto/err/err.c
index 4548854..345d230 100644
--- a/crypto/err/err.c
+++ b/crypto/err/err.c
@@ -66,6 +66,7 @@ static ERR_STRING_DATA ERR_str_libraries[] = {
     {ERR_PACK(ERR_LIB_OSSL_STORE, 0, 0), &quot;STORE routines&quot;},
     {ERR_PACK(ERR_LIB_SM2, 0, 0), &quot;SM2 routines&quot;},
     {ERR_PACK(ERR_LIB_ESS, 0, 0), &quot;ESS routines&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, 0), &quot;Provider routines&quot;},
     {0, NULL},
 };
 
diff --git a/crypto/err/err_all.c b/crypto/err/err_all.c
index 1166b01..af44467 100644
--- a/crypto/err/err_all.c
+++ b/crypto/err/err_all.c
@@ -41,6 +41,7 @@
 #include &lt;openssl/storeerr.h&gt;
 #include &lt;openssl/esserr.h&gt;
 #include &quot;internal/propertyerr.h&quot;
+#include &quot;internal/providercommonerr.h&quot;
 
 int err_load_crypto_strings_int(void)
 {
@@ -102,7 +103,8 @@ int err_load_crypto_strings_int(void)
 #endif
         ERR_load_KDF_strings() == 0 ||
         ERR_load_OSSL_STORE_strings() == 0 ||
-        ERR_load_PROP_strings() == 0)
+        ERR_load_PROP_strings() == 0 ||
+        ERR_load_PROV_strings() == 0)
         return 0;
 
     return 1;
diff --git a/crypto/err/openssl.ec b/crypto/err/openssl.ec
index a204434..b28aa49 100644
--- a/crypto/err/openssl.ec
+++ b/crypto/err/openssl.ec
@@ -37,6 +37,7 @@ L SM2           crypto/include/internal/sm2.h   crypto/sm2/sm2_err.c
 L OSSL_STORE    include/openssl/store.h         crypto/store/store_err.c
 L ESS           include/openssl/ess.h           crypto/ess/ess_err.c
 L PROP          include/internal/property.h     crypto/property/property_err.c
+L PROV          providers/common/include/internal/providercommon.h providers/common/provider_err.c
 
 # additional header files to be scanned for function names
 L NONE          include/openssl/x509_vfy.h      NONE
diff --git a/crypto/err/openssl.txt b/crypto/err/openssl.txt
index 18aa16c..5c444f5 100644
--- a/crypto/err/openssl.txt
+++ b/crypto/err/openssl.txt
@@ -785,6 +785,9 @@ EVP_F_EVP_CIPHER_ASN1_TO_PARAM:204:EVP_CIPHER_asn1_to_param
 EVP_F_EVP_CIPHER_CTX_COPY:163:EVP_CIPHER_CTX_copy
 EVP_F_EVP_CIPHER_CTX_CTRL:124:EVP_CIPHER_CTX_ctrl
 EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH:122:EVP_CIPHER_CTX_set_key_length
+EVP_F_EVP_CIPHER_CTX_SET_PADDING:237:EVP_CIPHER_CTX_set_padding
+EVP_F_EVP_CIPHER_FROM_DISPATCH:238:evp_cipher_from_dispatch
+EVP_F_EVP_CIPHER_MODE:239:EVP_CIPHER_mode
 EVP_F_EVP_CIPHER_PARAM_TO_ASN1:205:EVP_CIPHER_param_to_asn1
 EVP_F_EVP_DECRYPTFINAL_EX:101:EVP_DecryptFinal_ex
 EVP_F_EVP_DECRYPTUPDATE:166:EVP_DecryptUpdate
@@ -1102,6 +1105,21 @@ PROP_F_PARSE_NUMBER:104:parse_number
 PROP_F_PARSE_OCT:105:parse_oct
 PROP_F_PARSE_STRING:106:parse_string
 PROP_F_PARSE_UNQUOTED:107:parse_unquoted
+PROV_F_AESNI_INIT_KEY:101:aesni_init_key
+PROV_F_AES_BLOCK_FINAL:102:aes_block_final
+PROV_F_AES_BLOCK_UPDATE:103:aes_block_update
+PROV_F_AES_CIPHER:104:aes_cipher
+PROV_F_AES_CTX_GET_PARAMS:105:aes_ctx_get_params
+PROV_F_AES_CTX_SET_PARAMS:106:aes_ctx_set_params
+PROV_F_AES_DINIT:107:aes_dinit
+PROV_F_AES_DUPCTX:108:aes_dupctx
+PROV_F_AES_EINIT:109:aes_einit
+PROV_F_AES_INIT_KEY:110:aes_init_key
+PROV_F_AES_STREAM_UPDATE:111:aes_stream_update
+PROV_F_AES_T4_INIT_KEY:112:aes_t4_init_key
+PROV_F_PROV_AES_KEY_GENERIC_INIT:113:PROV_AES_KEY_generic_init
+PROV_F_TRAILINGDATA:114:trailingdata
+PROV_F_UNPADBLOCK:100:unpadblock
 RAND_F_DRBG_BYTES:101:drbg_bytes
 RAND_F_DRBG_CTR_INIT:125:drbg_ctr_init
 RAND_F_DRBG_GET_ENTROPY:105:drbg_get_entropy
@@ -2381,6 +2399,7 @@ EVP_R_INVALID_FIPS_MODE:168:invalid fips mode
 EVP_R_INVALID_KEY:163:invalid key
 EVP_R_INVALID_KEY_LENGTH:130:invalid key length
 EVP_R_INVALID_OPERATION:148:invalid operation
+EVP_R_INVALID_PROVIDER_FUNCTIONS:193:invalid provider functions
 EVP_R_INVALID_SALT_LENGTH:186:invalid salt length
 EVP_R_KEYGEN_FAILURE:120:keygen failure
 EVP_R_KEY_SETUP_FAILED:180:key setup failed
@@ -2604,6 +2623,14 @@ PROP_R_NO_VALUE:107:no value
 PROP_R_PARSE_FAILED:108:parse failed
 PROP_R_STRING_TOO_LONG:109:string too long
 PROP_R_TRAILING_CHARACTERS:110:trailing characters
+PROV_R_AES_KEY_SETUP_FAILED:101:aes key setup failed
+PROV_R_BAD_DECRYPT:100:bad decrypt
+PROV_R_CIPHER_OPERATION_FAILED:102:cipher operation failed
+PROV_R_FAILED_TO_GET_PARAMETER:103:failed to get parameter
+PROV_R_FAILED_TO_SET_PARAMETER:104:failed to set parameter
+PROV_R_INVALID_KEYLEN:105:invalid keylen
+PROV_R_OUTPUT_BUFFER_TOO_SMALL:106:output buffer too small
+PROV_R_WRONG_FINAL_BLOCK_LENGTH:107:wrong final block length
 RAND_R_ADDITIONAL_INPUT_TOO_LONG:102:additional input too long
 RAND_R_ALREADY_INSTANTIATED:103:already instantiated
 RAND_R_ARGUMENT_OUT_OF_RANGE:105:argument out of range
diff --git a/crypto/evp/cmeth_lib.c b/crypto/evp/cmeth_lib.c
index 6c328c0..0520157 100644
--- a/crypto/evp/cmeth_lib.c
+++ b/crypto/evp/cmeth_lib.c
@@ -11,6 +11,7 @@
 
 #include &lt;openssl/evp.h&gt;
 #include &quot;internal/evp_int.h&quot;
+#include &quot;internal/provider.h&quot;
 #include &quot;evp_locl.h&quot;
 
 EVP_CIPHER *EVP_CIPHER_meth_new(int cipher_type, int block_size, int key_len)
@@ -21,6 +22,12 @@ EVP_CIPHER *EVP_CIPHER_meth_new(int cipher_type, int block_size, int key_len)
         cipher-&gt;nid = cipher_type;
         cipher-&gt;block_size = block_size;
         cipher-&gt;key_len = key_len;
+        cipher-&gt;lock = CRYPTO_THREAD_lock_new();
+        if (cipher-&gt;lock == NULL) {
+            OPENSSL_free(cipher);
+            return NULL;
+        }
+        cipher-&gt;refcnt = 1;
     }
     return cipher;
 }
@@ -30,14 +37,35 @@ EVP_CIPHER *EVP_CIPHER_meth_dup(const EVP_CIPHER *cipher)
     EVP_CIPHER *to = EVP_CIPHER_meth_new(cipher-&gt;nid, cipher-&gt;block_size,
                                          cipher-&gt;key_len);
 
-    if (to != NULL)
+    if (to != NULL) {
+        CRYPTO_RWLOCK *lock = to-&gt;lock;
+
         memcpy(to, cipher, sizeof(*to));
+        to-&gt;lock = lock;
+    }
     return to;
 }
 
 void EVP_CIPHER_meth_free(EVP_CIPHER *cipher)
 {
-    OPENSSL_free(cipher);
+    if (cipher != NULL) {
+        int i;
+
+        CRYPTO_DOWN_REF(&amp;cipher-&gt;refcnt, &amp;i, cipher-&gt;lock);
+        if (i &gt; 0)
+            return;
+        ossl_provider_free(cipher-&gt;prov);
+        CRYPTO_THREAD_lock_free(cipher-&gt;lock);
+        OPENSSL_free(cipher);
+    }
+}
+
+int EVP_CIPHER_upref(EVP_CIPHER *cipher)
+{
+    int ref = 0;
+
+    CRYPTO_UP_REF(&amp;cipher-&gt;refcnt, &amp;ref, cipher-&gt;lock);
+    return 1;
 }
 
 int EVP_CIPHER_meth_set_iv_length(EVP_CIPHER *cipher, int iv_len)
diff --git a/crypto/evp/digest.c b/crypto/evp/digest.c
index e4787e6..043e456 100644
--- a/crypto/evp/digest.c
+++ b/crypto/evp/digest.c
@@ -517,7 +517,7 @@ static void *evp_md_from_dispatch(int mdtype, const OSSL_DISPATCH *fns,
             md-&gt;dinit = OSSL_get_OP_digest_init(fns);
             fncnt++;
             break;
-        case OSSL_FUNC_DIGEST_UPDDATE:
+        case OSSL_FUNC_DIGEST_UPDATE:
             if (md-&gt;dupdate != NULL)
                 break;
             md-&gt;dupdate = OSSL_get_OP_digest_update(fns);
diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
index 641ad19..4426a81 100644
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -15,25 +15,46 @@
 #include &lt;openssl/rand.h&gt;
 #include &lt;openssl/rand_drbg.h&gt;
 #include &lt;openssl/engine.h&gt;
+#include &lt;openssl/params.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &quot;internal/evp_int.h&quot;
+#include &quot;internal/provider.h&quot;
 #include &quot;evp_locl.h&quot;
 
-int EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *c)
+int EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *ctx)
 {
-    if (c == NULL)
+    if (ctx == NULL)
         return 1;
-    if (c-&gt;cipher != NULL) {
-        if (c-&gt;cipher-&gt;cleanup &amp;&amp; !c-&gt;cipher-&gt;cleanup(c))
+
+    if (ctx-&gt;cipher == NULL || ctx-&gt;cipher-&gt;prov == NULL)
+        goto legacy;
+
+    if (ctx-&gt;provctx != NULL) {
+        if (ctx-&gt;cipher-&gt;freectx != NULL)
+            ctx-&gt;cipher-&gt;freectx(ctx-&gt;provctx);
+        ctx-&gt;provctx = NULL;
+    }
+    if (ctx-&gt;fetched_cipher != NULL)
+        EVP_CIPHER_meth_free(ctx-&gt;fetched_cipher);
+    memset(ctx, 0, sizeof(*ctx));
+
+    return 1;
+
+    /* TODO(3.0): Remove legacy code below */
+ legacy:
+
+    if (ctx-&gt;cipher != NULL) {
+        if (ctx-&gt;cipher-&gt;cleanup &amp;&amp; !ctx-&gt;cipher-&gt;cleanup(ctx))
             return 0;
         /* Cleanse cipher context data */
-        if (c-&gt;cipher_data &amp;&amp; c-&gt;cipher-&gt;ctx_size)
-            OPENSSL_cleanse(c-&gt;cipher_data, c-&gt;cipher-&gt;ctx_size);
+        if (ctx-&gt;cipher_data &amp;&amp; ctx-&gt;cipher-&gt;ctx_size)
+            OPENSSL_cleanse(ctx-&gt;cipher_data, ctx-&gt;cipher-&gt;ctx_size);
     }
-    OPENSSL_free(c-&gt;cipher_data);
+    OPENSSL_free(ctx-&gt;cipher_data);
 #ifndef OPENSSL_NO_ENGINE
-    ENGINE_finish(c-&gt;engine);
+    ENGINE_finish(ctx-&gt;engine);
 #endif
-    memset(c, 0, sizeof(*c));
+    memset(ctx, 0, sizeof(*ctx));
     return 1;
 }
 
@@ -60,13 +81,30 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                       ENGINE *impl, const unsigned char *key,
                       const unsigned char *iv, int enc)
 {
-    if (enc == -1)
+    EVP_CIPHER *provciph = NULL;
+    ENGINE *tmpimpl = NULL;
+    const EVP_CIPHER *tmpcipher;
+
+    /*
+     * enc == 1 means we are encrypting.
+     * enc == 0 means we are decrypting.
+     * enc == -1 means, use the previously initialised value for encrypt/decrypt
+     */
+    if (enc == -1) {
         enc = ctx-&gt;encrypt;
-    else {
+    } else {
         if (enc)
             enc = 1;
         ctx-&gt;encrypt = enc;
     }
+
+    if (cipher == NULL &amp;&amp; ctx-&gt;cipher == NULL) {
+        EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_NO_CIPHER_SET);
+        return 0;
+    }
+
+    /* TODO(3.0): Legacy work around code below. Remove this */
+
 #ifndef OPENSSL_NO_ENGINE
     /*
      * Whether it's nice or not, &quot;Inits&quot; can be used on &quot;Final&quot;'d contexts so
@@ -77,11 +115,157 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
     if (ctx-&gt;engine &amp;&amp; ctx-&gt;cipher
         &amp;&amp; (cipher == NULL || cipher-&gt;nid == ctx-&gt;cipher-&gt;nid))
         goto skip_to_init;
+
+    if (cipher != NULL &amp;&amp; impl == NULL) {
+         /* Ask if an ENGINE is reserved for this job */
+        tmpimpl = ENGINE_get_cipher_engine(cipher-&gt;nid);
+    }
 #endif
-    if (cipher) {
+
+    /*
+     * If there are engines involved then we should use legacy handling for now.
+     */
+    if (ctx-&gt;engine != NULL
+            || impl != NULL
+            || tmpimpl != NULL) {
+        if (ctx-&gt;cipher == ctx-&gt;fetched_cipher)
+            ctx-&gt;cipher = NULL;
+        EVP_CIPHER_meth_free(ctx-&gt;fetched_cipher);
+        ctx-&gt;fetched_cipher = NULL;
+        goto legacy;
+    }
+
+    tmpcipher = (cipher == NULL) ? ctx-&gt;cipher : cipher;
+
+    if (tmpcipher-&gt;prov == NULL) {
+        switch(tmpcipher-&gt;nid) {
+        case NID_aes_256_ecb:
+        case NID_aes_192_ecb:
+        case NID_aes_128_ecb:
+        case NID_aes_256_cbc:
+        case NID_aes_192_cbc:
+        case NID_aes_128_cbc:
+        case NID_aes_256_ofb128:
+        case NID_aes_192_ofb128:
+        case NID_aes_128_ofb128:
+        case NID_aes_256_cfb128:
+        case NID_aes_192_cfb128:
+        case NID_aes_128_cfb128:
+        case NID_aes_256_cfb1:
+        case NID_aes_192_cfb1:
+        case NID_aes_128_cfb1:
+        case NID_aes_256_cfb8:
+        case NID_aes_192_cfb8:
+        case NID_aes_128_cfb8:
+        case NID_aes_256_ctr:
+        case NID_aes_192_ctr:
+        case NID_aes_128_ctr:
+            break;
+        default:
+            goto legacy;
+        }
+    }
+
+    /*
+     * Ensure a context left lying around from last time is cleared
+     * (legacy code)
+     */
+    if (cipher != NULL &amp;&amp; ctx-&gt;cipher != NULL) {
+        OPENSSL_clear_free(ctx-&gt;cipher_data, ctx-&gt;cipher-&gt;ctx_size);
+        ctx-&gt;cipher_data = NULL;
+    }
+
+
+    /* TODO(3.0): Start of non-legacy code below */
+
+    /* Ensure a context left lying around from last time is cleared */
+    if (cipher != NULL &amp;&amp; ctx-&gt;cipher != NULL) {
+        unsigned long flags = ctx-&gt;flags;
+
+        EVP_CIPHER_CTX_reset(ctx);
+        /* Restore encrypt and flags */
+        ctx-&gt;encrypt = enc;
+        ctx-&gt;flags = flags;
+    }
+
+    if (cipher != NULL)
+        ctx-&gt;cipher = cipher;
+    else
+        cipher = ctx-&gt;cipher;
+
+    if (cipher-&gt;prov == NULL) {
+        provciph = EVP_CIPHER_fetch(NULL, OBJ_nid2sn(cipher-&gt;nid), &quot;&quot;);
+        if (provciph == NULL) {
+            EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+            return 0;
+        }
+        cipher = provciph;
+        EVP_CIPHER_meth_free(ctx-&gt;fetched_cipher);
+        ctx-&gt;fetched_cipher = provciph;
+    }
+
+    ctx-&gt;cipher = cipher;
+    if (ctx-&gt;provctx == NULL) {
+        ctx-&gt;provctx = ctx-&gt;cipher-&gt;newctx();
+        if (ctx-&gt;provctx == NULL) {
+            EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+            return 0;
+        }
+    }
+
+    if ((ctx-&gt;flags &amp; EVP_CIPH_NO_PADDING) != 0) {
+        /*
+         * If this ctx was already set up for no padding then we need to tell
+         * the new cipher about it.
+         */
+        if (!EVP_CIPHER_CTX_set_padding(ctx, 0))
+            return 0;
+    }
+
+    switch (EVP_CIPHER_mode(ctx-&gt;cipher)) {
+    case EVP_CIPH_CFB_MODE:
+    case EVP_CIPH_OFB_MODE:
+    case EVP_CIPH_CBC_MODE:
+        /* For these modes we remember the original IV for later use */
+        if (!ossl_assert(EVP_CIPHER_CTX_iv_length(ctx) &lt;= (int)sizeof(ctx-&gt;oiv))) {
+            EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+            return 0;
+        }
+        if (iv != NULL)
+            memcpy(ctx-&gt;oiv, iv, EVP_CIPHER_CTX_iv_length(ctx));
+    }
+
+    if (enc) {
+        if (ctx-&gt;cipher-&gt;einit == NULL) {
+            EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+            return 0;
+        }
+
+        return ctx-&gt;cipher-&gt;einit(ctx-&gt;provctx,
+                                  key,
+                                  EVP_CIPHER_CTX_key_length(ctx),
+                                  iv,
+                                  EVP_CIPHER_CTX_iv_length(ctx));
+    }
+
+    if (ctx-&gt;cipher-&gt;dinit == NULL) {
+        EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
+        return 0;
+    }
+
+    return ctx-&gt;cipher-&gt;dinit(ctx-&gt;provctx,
+                              key,
+                              EVP_CIPHER_CTX_key_length(ctx),
+                              iv,
+                              EVP_CIPHER_CTX_iv_length(ctx));
+
+    /* TODO(3.0): Remove legacy code below */
+ legacy:
+
+    if (cipher != NULL) {
         /*
-         * Ensure a context left lying around from last time is cleared (the
-         * previous check attempted to avoid this if the same ENGINE and
+         * Ensure a context left lying around from last time is cleared (we
+         * previously attempted to avoid this if the same ENGINE and
          * EVP_CIPHER could be used).
          */
         if (ctx-&gt;cipher) {
@@ -92,18 +276,19 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
             ctx-&gt;flags = flags;
         }
 #ifndef OPENSSL_NO_ENGINE
-        if (impl) {
+        if (impl != NULL) {
             if (!ENGINE_init(impl)) {
                 EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);
                 return 0;
             }
-        } else
-            /* Ask if an ENGINE is reserved for this job */
-            impl = ENGINE_get_cipher_engine(cipher-&gt;nid);
-        if (impl) {
+        } else {
+            impl = tmpimpl;
+        }
+        if (impl != NULL) {
             /* There's an ENGINE for this job ... (apparently) */
             const EVP_CIPHER *c = ENGINE_get_cipher(impl, cipher-&gt;nid);
-            if (!c) {
+
+            if (c == NULL) {
                 /*
                  * One positive side-effect of US's export control history,
                  * is that we should at least be able to avoid using US
@@ -119,8 +304,9 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
              * from an ENGINE and we need to release it when done.
              */
             ctx-&gt;engine = impl;
-        } else
+        } else {
             ctx-&gt;engine = NULL;
+        }
 #endif
 
         ctx-&gt;cipher = cipher;
@@ -144,9 +330,6 @@ int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                 return 0;
             }
         }
-    } else if (!ctx-&gt;cipher) {
-        EVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_NO_CIPHER_SET);
-        return 0;
     }
 #ifndef OPENSSL_NO_ENGINE
  skip_to_init:
@@ -377,12 +560,39 @@ static int evp_EncryptDecryptUpdate(EVP_CIPHER_CTX *ctx,
 int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
                       const unsigned char *in, int inl)
 {
+    int ret;
+    size_t soutl;
+    int blocksize;
+
     /* Prevent accidental use of decryption context when encrypting */
     if (!ctx-&gt;encrypt) {
         EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_INVALID_OPERATION);
         return 0;
     }
 
+    if (ctx-&gt;cipher == NULL || ctx-&gt;cipher-&gt;prov == NULL)
+        goto legacy;
+
+    blocksize = EVP_CIPHER_CTX_block_size(ctx);
+
+    if (ctx-&gt;cipher-&gt;cupdate == NULL  || blocksize &lt; 1) {
+        EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_UPDATE_ERROR);
+        return 0;
+    }
+    ret = ctx-&gt;cipher-&gt;cupdate(ctx-&gt;provctx, out, &amp;soutl,
+                               inl + (blocksize == 1 ? 0 : blocksize), in,
+                               (size_t)inl);
+
+    if (soutl &gt; INT_MAX) {
+        EVPerr(EVP_F_EVP_ENCRYPTUPDATE, EVP_R_UPDATE_ERROR);
+        return 0;
+    }
+    *outl = soutl;
+    return ret;
+
+    /* TODO(3.0): Remove legacy code below */
+ legacy:
+
     return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);
 }
 
@@ -397,6 +607,8 @@ int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
 {
     int n, ret;
     unsigned int i, b, bl;
+    size_t soutl;
+    int blocksize;
 
     /* Prevent accidental use of decryption context when encrypting */
     if (!ctx-&gt;encrypt) {
@@ -404,6 +616,30 @@ int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
         return 0;
     }
 
+    if (ctx-&gt;cipher == NULL || ctx-&gt;cipher-&gt;prov == NULL)
+        goto legacy;
+
+    blocksize = EVP_CIPHER_CTX_block_size(ctx);
+
+    if (blocksize &lt; 1 || ctx-&gt;cipher-&gt;cfinal == NULL) {
+        EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, EVP_R_FINAL_ERROR);
+        return 0;
+    }
+
+    ret = ctx-&gt;cipher-&gt;cfinal(ctx-&gt;provctx, out, &amp;soutl,
+                              blocksize == 1 ? 0 : blocksize);
+
+    if (soutl &gt; INT_MAX) {
+        EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX, EVP_R_FINAL_ERROR);
+        return 0;
+    }
+    *outl = soutl;
+
+    return ret;
+
+    /* TODO(3.0): Remove legacy code below */
+ legacy:
+
     if (ctx-&gt;cipher-&gt;flags &amp; EVP_CIPH_FLAG_CUSTOM_CIPHER) {
         ret = ctx-&gt;cipher-&gt;do_cipher(ctx, out, NULL, 0);
         if (ret &lt; 0)
@@ -444,8 +680,10 @@ int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
 int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
                       const unsigned char *in, int inl)
 {
-    int fix_len, cmpl = inl;
+    int fix_len, cmpl = inl, ret;
     unsigned int b;
+    size_t soutl;
+    int blocksize;
 
     /* Prevent accidental use of encryption context when decrypting */
     if (ctx-&gt;encrypt) {
@@ -453,6 +691,32 @@ int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,
         return 0;
     }
 
+    if (ctx-&gt;cipher == NULL || ctx-&gt;cipher-&gt;prov == NULL)
+        goto legacy;
+
+    blocksize = EVP_CIPHER_CTX_block_size(ctx);
+
+    if (ctx-&gt;cipher-&gt;cupdate == NULL || blocksize &lt; 1) {
+        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_UPDATE_ERROR);
+        return 0;
+    }
+    ret = ctx-&gt;cipher-&gt;cupdate(ctx-&gt;provctx, out, &amp;soutl,
+                               inl + (blocksize == 1 ? 0 : blocksize), in,
+                               (size_t)inl);
+
+    if (ret) {
+        if (soutl &gt; INT_MAX) {
+            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_UPDATE_ERROR);
+            return 0;
+        }
+        *outl = soutl;
+    }
+
+    return ret;
+
+    /* TODO(3.0): Remove legacy code below */
+ legacy:
+
     b = ctx-&gt;cipher-&gt;block_size;
 
     if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))
@@ -527,6 +791,9 @@ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
 {
     int i, n;
     unsigned int b;
+    size_t soutl;
+    int ret;
+    int blocksize;
 
     /* Prevent accidental use of encryption context when decrypting */
     if (ctx-&gt;encrypt) {
@@ -534,6 +801,32 @@ int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
         return 0;
     }
 
+    if (ctx-&gt;cipher == NULL || ctx-&gt;cipher-&gt;prov == NULL)
+        goto legacy;
+
+    blocksize = EVP_CIPHER_CTX_block_size(ctx);
+
+    if (blocksize &lt; 1 || ctx-&gt;cipher-&gt;cfinal == NULL) {
+        EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_FINAL_ERROR);
+        return 0;
+    }
+
+    ret = ctx-&gt;cipher-&gt;cfinal(ctx-&gt;provctx, out, &amp;soutl,
+                              blocksize == 1 ? 0 : blocksize);
+
+    if (ret) {
+        if (soutl &gt; INT_MAX) {
+            EVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_FINAL_ERROR);
+            return 0;
+        }
+        *outl = soutl;
+    }
+
+    return ret;
+
+    /* TODO(3.0): Remove legacy code below */
+ legacy:
+
     *outl = 0;
 
     if (ctx-&gt;cipher-&gt;flags &amp; EVP_CIPH_FLAG_CUSTOM_CIPHER) {
@@ -590,7 +883,7 @@ int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)
 {
     if (c-&gt;cipher-&gt;flags &amp; EVP_CIPH_CUSTOM_KEY_LENGTH)
         return EVP_CIPHER_CTX_ctrl(c, EVP_CTRL_SET_KEY_LENGTH, keylen, NULL);
-    if (c-&gt;key_len == keylen)
+    if (EVP_CIPHER_CTX_key_length(c) == keylen)
         return 1;
     if ((keylen &gt; 0) &amp;&amp; (c-&gt;cipher-&gt;flags &amp; EVP_CIPH_VARIABLE_LENGTH)) {
         c-&gt;key_len = keylen;
@@ -606,6 +899,24 @@ int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *ctx, int pad)
         ctx-&gt;flags &amp;= ~EVP_CIPH_NO_PADDING;
     else
         ctx-&gt;flags |= EVP_CIPH_NO_PADDING;
+
+    if (ctx-&gt;cipher != NULL &amp;&amp; ctx-&gt;cipher-&gt;prov != NULL) {
+        OSSL_PARAM params[] = {
+            OSSL_PARAM_int(OSSL_CIPHER_PARAM_PADDING, NULL),
+            OSSL_PARAM_END
+        };
+
+        params[0].data = &pad;
+
+        if (ctx-&gt;cipher-&gt;ctx_set_params == NULL) {
+            EVPerr(EVP_F_EVP_CIPHER_CTX_SET_PADDING, EVP_R_CTRL_NOT_IMPLEMENTED);
+            return 0;
+        }
+
+        if (!ctx-&gt;cipher-&gt;ctx_set_params(ctx-&gt;provctx, params))
+            return 0;
+    }
+
     return 1;
 }
 
@@ -647,6 +958,36 @@ int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
         EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_INPUT_NOT_INITIALIZED);
         return 0;
     }
+
+    if (in-&gt;cipher-&gt;prov == NULL)
+        goto legacy;
+
+    if (in-&gt;cipher-&gt;dupctx == NULL) {
+        EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_NOT_ABLE_TO_COPY_CTX);
+        return 0;
+    }
+
+    EVP_CIPHER_CTX_reset(out);
+
+    *out = *in;
+    out-&gt;provctx = NULL;
+
+    if (in-&gt;fetched_cipher != NULL &amp;&amp; !EVP_CIPHER_upref(in-&gt;fetched_cipher)) {
+        out-&gt;fetched_cipher = NULL;
+        return 0;
+    }
+
+    out-&gt;provctx = in-&gt;cipher-&gt;dupctx(in-&gt;provctx);
+    if (out-&gt;provctx == NULL) {
+        EVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_NOT_ABLE_TO_COPY_CTX);
+        return 0;
+    }
+
+    return 1;
+
+    /* TODO(3.0): Remove legacy code below */
+ legacy:
+
 #ifndef OPENSSL_NO_ENGINE
     /* Make sure it's safe to copy a cipher context using an ENGINE */
     if (in-&gt;engine &amp;&amp; !ENGINE_init(in-&gt;engine)) {
@@ -676,3 +1017,141 @@ int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)
         }
     return 1;
 }
+
+static void *evp_cipher_from_dispatch(int nid, const OSSL_DISPATCH *fns,
+                                      OSSL_PROVIDER *prov)
+{
+    EVP_CIPHER *cipher = NULL;
+    int fnciphcnt = 0, fnctxcnt = 0;
+
+    if ((cipher = EVP_CIPHER_meth_new(nid, 0, 0)) == NULL)
+        return NULL;
+
+    for (; fns-&gt;function_id != 0; fns++) {
+        switch (fns-&gt;function_id) {
+        case OSSL_FUNC_CIPHER_NEWCTX:
+            if (cipher-&gt;newctx != NULL)
+                break;
+            cipher-&gt;newctx = OSSL_get_OP_cipher_newctx(fns);
+            fnctxcnt++;
+            break;
+        case OSSL_FUNC_CIPHER_ENCRYPT_INIT:
+            if (cipher-&gt;einit != NULL)
+                break;
+            cipher-&gt;einit = OSSL_get_OP_cipher_encrypt_init(fns);
+            fnciphcnt++;
+            break;
+        case OSSL_FUNC_CIPHER_DECRYPT_INIT:
+            if (cipher-&gt;dinit != NULL)
+                break;
+            cipher-&gt;dinit = OSSL_get_OP_cipher_decrypt_init(fns);
+            fnciphcnt++;
+            break;
+        case OSSL_FUNC_CIPHER_UPDATE:
+            if (cipher-&gt;cupdate != NULL)
+                break;
+            cipher-&gt;cupdate = OSSL_get_OP_cipher_update(fns);
+            fnciphcnt++;
+            break;
+        case OSSL_FUNC_CIPHER_FINAL:
+            if (cipher-&gt;cfinal != NULL)
+                break;
+            cipher-&gt;cfinal = OSSL_get_OP_cipher_final(fns);
+            fnciphcnt++;
+            break;
+        case OSSL_FUNC_CIPHER_CIPHER:
+            if (cipher-&gt;ccipher != NULL)
+                break;
+            cipher-&gt;ccipher = OSSL_get_OP_cipher_cipher(fns);
+            break;
+        case OSSL_FUNC_CIPHER_FREECTX:
+            if (cipher-&gt;freectx != NULL)
+                break;
+            cipher-&gt;freectx = OSSL_get_OP_cipher_freectx(fns);
+            fnctxcnt++;
+            break;
+        case OSSL_FUNC_CIPHER_DUPCTX:
+            if (cipher-&gt;dupctx != NULL)
+                break;
+            cipher-&gt;dupctx = OSSL_get_OP_cipher_dupctx(fns);
+            break;
+        case OSSL_FUNC_CIPHER_KEY_LENGTH:
+            if (cipher-&gt;key_length != NULL)
+                break;
+            cipher-&gt;key_length = OSSL_get_OP_cipher_key_length(fns);
+            break;
+        case OSSL_FUNC_CIPHER_IV_LENGTH:
+            if (cipher-&gt;iv_length != NULL)
+                break;
+            cipher-&gt;iv_length = OSSL_get_OP_cipher_iv_length(fns);
+            break;
+        case OSSL_FUNC_CIPHER_BLOCK_SIZE:
+            if (cipher-&gt;blocksize != NULL)
+                break;
+            cipher-&gt;blocksize = OSSL_get_OP_cipher_block_size(fns);
+            break;
+        case OSSL_FUNC_CIPHER_GET_PARAMS:
+            if (cipher-&gt;get_params != NULL)
+                break;
+            cipher-&gt;get_params = OSSL_get_OP_cipher_get_params(fns);
+            break;
+        case OSSL_FUNC_CIPHER_CTX_GET_PARAMS:
+            if (cipher-&gt;ctx_get_params != NULL)
+                break;
+            cipher-&gt;ctx_get_params = OSSL_get_OP_cipher_ctx_get_params(fns);
+            break;
+        case OSSL_FUNC_CIPHER_CTX_SET_PARAMS:
+            if (cipher-&gt;ctx_set_params != NULL)
+                break;
+            cipher-&gt;ctx_set_params = OSSL_get_OP_cipher_ctx_set_params(fns);
+            break;
+        }
+    }
+    if ((fnciphcnt != 0 &amp;&amp; fnciphcnt != 3 &amp;&amp; fnciphcnt != 4)
+            || (fnciphcnt == 0 &amp;&amp; cipher-&gt;ccipher == NULL)
+            || fnctxcnt != 2
+            || cipher-&gt;blocksize == NULL
+            || cipher-&gt;iv_length == NULL
+            || cipher-&gt;key_length == NULL) {
+        /*
+         * In order to be a consistent set of functions we must have at least
+         * a complete set of &quot;encrypt&quot; functions, or a complete set of &quot;decrypt&quot;
+         * functions, or a single &quot;cipher&quot; function. In all cases we need a
+         * complete set of context management functions, as well as the
+         * blocksize, iv_length and key_length functions.
+         */
+        EVP_CIPHER_meth_free(cipher);
+        EVPerr(EVP_F_EVP_CIPHER_FROM_DISPATCH, EVP_R_INVALID_PROVIDER_FUNCTIONS);
+        return NULL;
+    }
+    cipher-&gt;prov = prov;
+    if (prov != NULL)
+        ossl_provider_upref(prov);
+
+    return cipher;
+}
+
+static int evp_cipher_upref(void *cipher)
+{
+    return EVP_CIPHER_upref(cipher);
+}
+
+static void evp_cipher_free(void *cipher)
+{
+    EVP_CIPHER_meth_free(cipher);
+}
+
+static int evp_cipher_nid(void *vcipher)
+{
+    EVP_CIPHER *cipher = vcipher;
+
+    return cipher-&gt;nid;
+}
+
+EVP_CIPHER *EVP_CIPHER_fetch(OPENSSL_CTX *ctx, const char *algorithm,
+                             const char *properties)
+{
+    return evp_generic_fetch(ctx, OSSL_OP_CIPHER, algorithm, properties,
+                             evp_cipher_from_dispatch, evp_cipher_upref,
+                             evp_cipher_free, evp_cipher_nid);
+}
diff --git a/crypto/evp/evp_err.c b/crypto/evp/evp_err.c
index a9f8800..3555c0e 100644
--- a/crypto/evp/evp_err.c
+++ b/crypto/evp/evp_err.c
@@ -53,6 +53,11 @@ static const ERR_STRING_DATA EVP_str_functs[] = {
      &quot;EVP_CIPHER_CTX_ctrl&quot;},
     {ERR_PACK(ERR_LIB_EVP, EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH, 0),
      &quot;EVP_CIPHER_CTX_set_key_length&quot;},
+    {ERR_PACK(ERR_LIB_EVP, EVP_F_EVP_CIPHER_CTX_SET_PADDING, 0),
+     &quot;EVP_CIPHER_CTX_set_padding&quot;},
+    {ERR_PACK(ERR_LIB_EVP, EVP_F_EVP_CIPHER_FROM_DISPATCH, 0),
+     &quot;evp_cipher_from_dispatch&quot;},
+    {ERR_PACK(ERR_LIB_EVP, EVP_F_EVP_CIPHER_MODE, 0), &quot;EVP_CIPHER_mode&quot;},
     {ERR_PACK(ERR_LIB_EVP, EVP_F_EVP_CIPHER_PARAM_TO_ASN1, 0),
      &quot;EVP_CIPHER_param_to_asn1&quot;},
     {ERR_PACK(ERR_LIB_EVP, EVP_F_EVP_DECRYPTFINAL_EX, 0),
@@ -246,6 +251,8 @@ static const ERR_STRING_DATA EVP_str_reasons[] = {
     {ERR_PACK(ERR_LIB_EVP, 0, EVP_R_INVALID_KEY), &quot;invalid key&quot;},
     {ERR_PACK(ERR_LIB_EVP, 0, EVP_R_INVALID_KEY_LENGTH), &quot;invalid key length&quot;},
     {ERR_PACK(ERR_LIB_EVP, 0, EVP_R_INVALID_OPERATION), &quot;invalid operation&quot;},
+    {ERR_PACK(ERR_LIB_EVP, 0, EVP_R_INVALID_PROVIDER_FUNCTIONS),
+    &quot;invalid provider functions&quot;},
     {ERR_PACK(ERR_LIB_EVP, 0, EVP_R_INVALID_SALT_LENGTH),
     &quot;invalid salt length&quot;},
     {ERR_PACK(ERR_LIB_EVP, 0, EVP_R_KEYGEN_FAILURE), &quot;keygen failure&quot;},
diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
index 914a19c..189c953 100644
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -11,6 +11,8 @@
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/objects.h&gt;
+#include &lt;openssl/params.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &quot;internal/evp_int.h&quot;
 #include &quot;internal/provider.h&quot;
 #include &quot;evp_locl.h&quot;
@@ -18,13 +20,28 @@
 int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
 {
     int ret;
+    const EVP_CIPHER *cipher = c-&gt;cipher;
+
+    if (cipher-&gt;prov != NULL) {
+        /*
+         * The cipher has come from a provider and won't have the default flags.
+         * Find the implicit form so we can check the flags.
+         * TODO(3.0): This won't work for 3rd party ciphers we know nothing about
+         * We'll need to think of something else for those.
+         */
+        cipher = EVP_get_cipherbynid(cipher-&gt;nid);
+        if (cipher == NULL) {
+            EVPerr(EVP_F_EVP_CIPHER_PARAM_TO_ASN1, ASN1_R_UNSUPPORTED_CIPHER);
+            return -1;
+        }
+    }
 
-    if (c-&gt;cipher-&gt;set_asn1_parameters != NULL)
-        ret = c-&gt;cipher-&gt;set_asn1_parameters(c, type);
-    else if (c-&gt;cipher-&gt;flags &amp; EVP_CIPH_FLAG_DEFAULT_ASN1) {
-        switch (EVP_CIPHER_CTX_mode(c)) {
+    if (cipher-&gt;set_asn1_parameters != NULL)
+        ret = cipher-&gt;set_asn1_parameters(c, type);
+    else if (cipher-&gt;flags &amp; EVP_CIPH_FLAG_DEFAULT_ASN1) {
+        switch (EVP_CIPHER_mode(cipher)) {
         case EVP_CIPH_WRAP_MODE:
-            if (EVP_CIPHER_CTX_nid(c) == NID_id_smime_alg_CMS3DESwrap)
+            if (EVP_CIPHER_nid(cipher) == NID_id_smime_alg_CMS3DESwrap)
                 ASN1_TYPE_set(type, V_ASN1_NULL, NULL);
             ret = 1;
             break;
@@ -53,11 +70,22 @@ int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
 int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
 {
     int ret;
+    const EVP_CIPHER *cipher = c-&gt;cipher;
+
+    if (cipher-&gt;prov != NULL) {
+        /*
+         * The cipher has come from a provider and won't have the default flags.
+         * Find the implicit form so we can check the flags.
+         */
+        cipher = EVP_get_cipherbynid(cipher-&gt;nid);
+        if (cipher == NULL)
+            return -1;
+    }
 
-    if (c-&gt;cipher-&gt;get_asn1_parameters != NULL)
-        ret = c-&gt;cipher-&gt;get_asn1_parameters(c, type);
-    else if (c-&gt;cipher-&gt;flags &amp; EVP_CIPH_FLAG_DEFAULT_ASN1) {
-        switch (EVP_CIPHER_CTX_mode(c)) {
+    if (cipher-&gt;get_asn1_parameters != NULL)
+        ret = cipher-&gt;get_asn1_parameters(c, type);
+    else if (cipher-&gt;flags &amp; EVP_CIPH_FLAG_DEFAULT_ASN1) {
+        switch (EVP_CIPHER_mode(cipher)) {
 
         case EVP_CIPH_WRAP_MODE:
             ret = 1;
@@ -85,19 +113,23 @@ int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
     return ret;
 }
 
-int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
+int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *ctx, ASN1_TYPE *type)
 {
     int i = 0;
     unsigned int l;
 
     if (type != NULL) {
-        l = EVP_CIPHER_CTX_iv_length(c);
-        OPENSSL_assert(l &lt;= sizeof(c-&gt;iv));
-        i = ASN1_TYPE_get_octetstring(type, c-&gt;oiv, l);
+        unsigned char iv[EVP_MAX_IV_LENGTH];
+
+        l = EVP_CIPHER_CTX_iv_length(ctx);
+        if (!ossl_assert(l &lt;= sizeof(iv)))
+            return -1;
+        i = ASN1_TYPE_get_octetstring(type, iv, l);
         if (i != (int)l)
             return -1;
-        else if (i &gt; 0)
-            memcpy(c-&gt;iv, c-&gt;oiv, l);
+
+        if (!EVP_CipherInit_ex(ctx, NULL, NULL, NULL, iv, -1))
+            return -1;
     }
     return i;
 }
@@ -175,14 +207,20 @@ int EVP_CIPHER_type(const EVP_CIPHER *ctx)
     }
 }
 
-int EVP_CIPHER_block_size(const EVP_CIPHER *e)
+int EVP_CIPHER_block_size(const EVP_CIPHER *cipher)
 {
-    return e-&gt;block_size;
+    if (cipher-&gt;prov != NULL) {
+        if (cipher-&gt;blocksize != NULL)
+            return cipher-&gt;blocksize();
+        /* We default to a block size of 1 */
+        return 1;
+    }
+    return cipher-&gt;block_size;
 }
 
 int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx)
 {
-    return ctx-&gt;cipher-&gt;block_size;
+    return EVP_CIPHER_block_size(ctx-&gt;cipher);
 }
 
 int EVP_CIPHER_impl_ctx_size(const EVP_CIPHER *e)
@@ -193,6 +231,12 @@ int EVP_CIPHER_impl_ctx_size(const EVP_CIPHER *e)
 int EVP_Cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
                const unsigned char *in, unsigned int inl)
 {
+    if (ctx-&gt;cipher-&gt;prov != NULL) {
+        if (ctx-&gt;cipher-&gt;ccipher != NULL)
+            return ctx-&gt;cipher-&gt;ccipher(ctx-&gt;provctx, out, in, (size_t)inl);
+        return 0;
+    }
+
     return ctx-&gt;cipher-&gt;do_cipher(ctx, out, in, inl);
 }
 
@@ -238,12 +282,18 @@ void *EVP_CIPHER_CTX_set_cipher_data(EVP_CIPHER_CTX *ctx, void *cipher_data)
 
 int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher)
 {
+    if (cipher-&gt;prov != NULL) {
+        if (cipher-&gt;iv_length != NULL)
+            return (int)cipher-&gt;iv_length();
+        return 0;
+    }
+
     return cipher-&gt;iv_len;
 }
 
 int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx)
 {
-    return ctx-&gt;cipher-&gt;iv_len;
+    return EVP_CIPHER_iv_length(ctx-&gt;cipher);
 }
 
 const unsigned char *EVP_CIPHER_CTX_original_iv(const EVP_CIPHER_CTX *ctx)
@@ -278,11 +328,23 @@ void EVP_CIPHER_CTX_set_num(EVP_CIPHER_CTX *ctx, int num)
 
 int EVP_CIPHER_key_length(const EVP_CIPHER *cipher)
 {
+    if (cipher-&gt;prov != NULL) {
+        if (cipher-&gt;key_length != NULL)
+            return (int)cipher-&gt;key_length();
+        return -1;
+    }
+
     return cipher-&gt;key_len;
 }
 
 int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx)
 {
+    /*
+     * TODO(3.0): This may need to change if/when we introduce variable length
+     * key ciphers into the providers.
+     */
+    if (ctx-&gt;cipher != NULL &amp;&amp; ctx-&gt;cipher-&gt;prov != NULL)
+        return EVP_CIPHER_key_length(ctx-&gt;cipher);
     return ctx-&gt;key_len;
 }
 
@@ -296,6 +358,33 @@ int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx)
     return ctx-&gt;cipher-&gt;nid;
 }
 
+int EVP_CIPHER_mode(const EVP_CIPHER *cipher)
+{
+    if (cipher-&gt;prov != NULL) {
+        int mode;
+
+        /* Cipher comes from a provider - so ask the provider for the mode */
+        OSSL_PARAM params[] = {
+            OSSL_PARAM_int(OSSL_CIPHER_PARAM_MODE, NULL),
+            OSSL_PARAM_END
+        };
+
+        params[0].data = &mode;
+
+        if (cipher-&gt;get_params == NULL) {
+            EVPerr(EVP_F_EVP_CIPHER_MODE, EVP_R_CTRL_NOT_IMPLEMENTED);
+            return 0;
+        }
+
+        if (!cipher-&gt;get_params(params))
+            return 0;
+
+        return mode;
+    }
+    return EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_MODE;
+}
+
+
 int EVP_MD_block_size(const EVP_MD *md)
 {
     if (md == NULL) {
@@ -353,12 +442,16 @@ EVP_MD *EVP_MD_meth_new(int md_type, int pkey_type)
     }
     return md;
 }
+
 EVP_MD *EVP_MD_meth_dup(const EVP_MD *md)
 {
     EVP_MD *to = EVP_MD_meth_new(md-&gt;type, md-&gt;pkey_type);
 
-    if (to != NULL)
+    if (to != NULL) {
+        CRYPTO_RWLOCK *lock = to-&gt;lock;
         memcpy(to, md, sizeof(*to));
+        to-&gt;lock = lock;
+    }
     return to;
 }
 
diff --git a/crypto/evp/evp_locl.h b/crypto/evp/evp_locl.h
index efa2db8..3172c49 100644
--- a/crypto/evp/evp_locl.h
+++ b/crypto/evp/evp_locl.h
@@ -44,6 +44,10 @@ struct evp_cipher_ctx_st {
     int final_used;
     int block_mask;
     unsigned char final[EVP_MAX_BLOCK_LENGTH]; /* possible final block */
+
+    /* Provider ctx */
+    void *provctx;
+    EVP_CIPHER *fetched_cipher;
 } /* EVP_CIPHER_CTX */ ;
 
 struct evp_mac_ctx_st {
diff --git a/crypto/include/internal/evp_int.h b/crypto/include/internal/evp_int.h
index c932898..b3d9694 100644
--- a/crypto/include/internal/evp_int.h
+++ b/crypto/include/internal/evp_int.h
@@ -210,10 +210,14 @@ struct evp_md_st {
 
 struct evp_cipher_st {
     int nid;
+
     int block_size;
     /* Default value for variable length ciphers */
     int key_len;
     int iv_len;
+
+    /* Legacy structure members */
+    /* TODO(3.0): Remove these */
     /* Various flags */
     unsigned long flags;
     /* init key */
@@ -234,6 +238,26 @@ struct evp_cipher_st {
     int (*ctrl) (EVP_CIPHER_CTX *, int type, int arg, void *ptr);
     /* Application data */
     void *app_data;
+
+    /* New structure members */
+    /* TODO(3.0): Remove above comment when legacy has gone */
+    OSSL_PROVIDER *prov;
+    CRYPTO_REF_COUNT refcnt;
+    CRYPTO_RWLOCK *lock;
+    OSSL_OP_cipher_newctx_fn *newctx;
+    OSSL_OP_cipher_encrypt_init_fn *einit;
+    OSSL_OP_cipher_decrypt_init_fn *dinit;
+    OSSL_OP_cipher_update_fn *cupdate;
+    OSSL_OP_cipher_final_fn *cfinal;
+    OSSL_OP_cipher_cipher_fn *ccipher;
+    OSSL_OP_cipher_freectx_fn *freectx;
+    OSSL_OP_cipher_dupctx_fn *dupctx;
+    OSSL_OP_cipher_key_length_fn *key_length;
+    OSSL_OP_cipher_iv_length_fn *iv_length;
+    OSSL_OP_cipher_block_size_fn *blocksize;
+    OSSL_OP_cipher_get_params_fn *get_params;
+    OSSL_OP_cipher_ctx_get_params_fn *ctx_get_params;
+    OSSL_OP_cipher_ctx_set_params_fn *ctx_set_params;
 } /* EVP_CIPHER */ ;
 
 /* Macros to code block cipher wrappers */
diff --git a/include/openssl/core_names.h b/include/openssl/core_names.h
index be4a647..35a23d7 100644
--- a/include/openssl/core_names.h
+++ b/include/openssl/core_names.h
@@ -34,6 +34,12 @@ extern &quot;C&quot; {
  */
 #define OSSL_PROV_PARAM_BUILDINFO   &quot;buildinfo&quot;
 
+
+/* Well known cipher parameters */
+
+#define OSSL_CIPHER_PARAM_PADDING   &quot;padding&quot;
+#define OSSL_CIPHER_PARAM_MODE      &quot;mode&quot;
+
 # ifdef __cplusplus
 }
 # endif
diff --git a/include/openssl/core_numbers.h b/include/openssl/core_numbers.h
index 2054381..d588886 100644
--- a/include/openssl/core_numbers.h
+++ b/include/openssl/core_numbers.h
@@ -78,7 +78,7 @@ OSSL_CORE_MAKE_FUNC(const OSSL_ALGORITHM *,provider_query_operation,
 
 # define OSSL_FUNC_DIGEST_NEWCTX            1
 # define OSSL_FUNC_DIGEST_INIT              2
-# define OSSL_FUNC_DIGEST_UPDDATE           3
+# define OSSL_FUNC_DIGEST_UPDATE            3
 # define OSSL_FUNC_DIGEST_FINAL             4
 # define OSSL_FUNC_DIGEST_DIGEST            5
 # define OSSL_FUNC_DIGEST_FREECTX           6
@@ -86,6 +86,7 @@ OSSL_CORE_MAKE_FUNC(const OSSL_ALGORITHM *,provider_query_operation,
 # define OSSL_FUNC_DIGEST_SIZE              8
 # define OSSL_FUNC_DIGEST_BLOCK_SIZE        9
 
+
 OSSL_CORE_MAKE_FUNC(void *, OP_digest_newctx, (void))
 OSSL_CORE_MAKE_FUNC(int, OP_digest_init, (void *vctx))
 OSSL_CORE_MAKE_FUNC(int, OP_digest_update,
@@ -95,12 +96,64 @@ OSSL_CORE_MAKE_FUNC(int, OP_digest_final,
 OSSL_CORE_MAKE_FUNC(int, OP_digest_digest,
                     (const unsigned char *in, size_t inl, unsigned char *out,
                      size_t *out_l, size_t outsz))
+
 OSSL_CORE_MAKE_FUNC(void, OP_digest_cleanctx, (void *vctx))
 OSSL_CORE_MAKE_FUNC(void, OP_digest_freectx, (void *vctx))
 OSSL_CORE_MAKE_FUNC(void *, OP_digest_dupctx, (void *vctx))
 OSSL_CORE_MAKE_FUNC(size_t, OP_digest_size, (void))
 OSSL_CORE_MAKE_FUNC(size_t, OP_digest_block_size, (void))
 
+
+/* Symmetric Ciphers */
+
+# define OSSL_OP_CIPHER                              2
+
+# define OSSL_FUNC_CIPHER_NEWCTX                     1
+# define OSSL_FUNC_CIPHER_ENCRYPT_INIT               2
+# define OSSL_FUNC_CIPHER_DECRYPT_INIT               3
+# define OSSL_FUNC_CIPHER_UPDATE                     4
+# define OSSL_FUNC_CIPHER_FINAL                      5
+# define OSSL_FUNC_CIPHER_CIPHER                     6
+# define OSSL_FUNC_CIPHER_FREECTX                    7
+# define OSSL_FUNC_CIPHER_DUPCTX                     8
+# define OSSL_FUNC_CIPHER_KEY_LENGTH                 9
+# define OSSL_FUNC_CIPHER_IV_LENGTH                 10
+# define OSSL_FUNC_CIPHER_BLOCK_SIZE                11
+# define OSSL_FUNC_CIPHER_GET_PARAMS                12
+# define OSSL_FUNC_CIPHER_CTX_GET_PARAMS            13
+# define OSSL_FUNC_CIPHER_CTX_SET_PARAMS            14
+
+OSSL_CORE_MAKE_FUNC(void *, OP_cipher_newctx, (void))
+OSSL_CORE_MAKE_FUNC(int, OP_cipher_encrypt_init, (void *vctx,
+                                                  const unsigned char *key,
+                                                  size_t keylen,
+                                                  const unsigned char *iv,
+                                                  size_t ivlen))
+OSSL_CORE_MAKE_FUNC(int, OP_cipher_decrypt_init, (void *vctx,
+                                                  const unsigned char *key,
+                                                  size_t keylen,
+                                                  const unsigned char *iv,
+                                                  size_t ivlen))
+OSSL_CORE_MAKE_FUNC(int, OP_cipher_update,
+                    (void *, unsigned char *out, size_t *outl, size_t outsize,
+                     const unsigned char *in, size_t inl))
+OSSL_CORE_MAKE_FUNC(int, OP_cipher_final,
+                    (void *, unsigned char *out, size_t *outl, size_t outsize))
+OSSL_CORE_MAKE_FUNC(int, OP_cipher_cipher,
+                    (void *, unsigned char *out, const unsigned char *in,
+                     size_t inl))
+OSSL_CORE_MAKE_FUNC(void, OP_cipher_freectx, (void *vctx))
+OSSL_CORE_MAKE_FUNC(void *, OP_cipher_dupctx, (void *vctx))
+OSSL_CORE_MAKE_FUNC(size_t, OP_cipher_key_length, (void))
+OSSL_CORE_MAKE_FUNC(size_t, OP_cipher_iv_length, (void))
+OSSL_CORE_MAKE_FUNC(size_t, OP_cipher_block_size, (void))
+OSSL_CORE_MAKE_FUNC(int, OP_cipher_get_params, (const OSSL_PARAM params[]))
+OSSL_CORE_MAKE_FUNC(int, OP_cipher_ctx_get_params, (void *vctx,
+                                                    const OSSL_PARAM params[]))
+OSSL_CORE_MAKE_FUNC(int, OP_cipher_ctx_set_params, (void *vctx,
+                                                    const OSSL_PARAM params[]))
+
+
 # ifdef __cplusplus
 }
 # endif
diff --git a/include/openssl/err.h b/include/openssl/err.h
index 136b000..8fcdfb4 100644
--- a/include/openssl/err.h
+++ b/include/openssl/err.h
@@ -98,6 +98,7 @@ typedef struct err_state_st {
 # define ERR_LIB_ESS             54
 # define ERR_LIB_PROP            55
 # define ERR_LIB_CRMF            56
+# define ERR_LIB_PROV            57
 
 # define ERR_LIB_USER            128
 
@@ -140,6 +141,7 @@ typedef struct err_state_st {
 # define SM2err(f,r) ERR_PUT_error(ERR_LIB_SM2,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 # define ESSerr(f,r) ERR_PUT_error(ERR_LIB_ESS,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 # define PROPerr(f,r) ERR_PUT_error(ERR_LIB_PROP,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
+# define PROVerr(f,r) ERR_PUT_error(ERR_LIB_PROV,(f),(r),OPENSSL_FILE,OPENSSL_LINE)
 
 # define ERR_PACK(l,f,r) ( \
         (((unsigned int)(l) &amp; 0x0FF) &lt;&lt; 24L) | \
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index a903b29..6fc0f35 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -190,6 +190,7 @@ int (*EVP_MD_meth_get_ctrl(const EVP_MD *md))(EVP_MD_CTX *ctx, int cmd,
 EVP_CIPHER *EVP_CIPHER_meth_new(int cipher_type, int block_size, int key_len);
 EVP_CIPHER *EVP_CIPHER_meth_dup(const EVP_CIPHER *cipher);
 void EVP_CIPHER_meth_free(EVP_CIPHER *cipher);
+int EVP_CIPHER_upref(EVP_CIPHER *cipher);
 
 int EVP_CIPHER_meth_set_iv_length(EVP_CIPHER *cipher, int iv_len);
 int EVP_CIPHER_meth_set_flags(EVP_CIPHER *cipher, unsigned long flags);
@@ -473,7 +474,9 @@ int EVP_CIPHER_impl_ctx_size(const EVP_CIPHER *cipher);
 int EVP_CIPHER_key_length(const EVP_CIPHER *cipher);
 int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher);
 unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher);
-# define EVP_CIPHER_mode(e)              (EVP_CIPHER_flags(e) &amp; EVP_CIPH_MODE)
+int EVP_CIPHER_mode(const EVP_CIPHER *cipher);
+EVP_CIPHER *EVP_CIPHER_fetch(OPENSSL_CTX *ctx, const char *algorithm,
+                             const char *properties);
 
 const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
 int EVP_CIPHER_CTX_encrypting(const EVP_CIPHER_CTX *ctx);
diff --git a/include/openssl/evperr.h b/include/openssl/evperr.h
index e62cfb3..d88d4a8 100644
--- a/include/openssl/evperr.h
+++ b/include/openssl/evperr.h
@@ -55,6 +55,9 @@ int ERR_load_EVP_strings(void);
 # define EVP_F_EVP_CIPHER_CTX_COPY                        163
 # define EVP_F_EVP_CIPHER_CTX_CTRL                        124
 # define EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH              122
+# define EVP_F_EVP_CIPHER_CTX_SET_PADDING                 237
+# define EVP_F_EVP_CIPHER_FROM_DISPATCH                   238
+# define EVP_F_EVP_CIPHER_MODE                            239
 # define EVP_F_EVP_CIPHER_PARAM_TO_ASN1                   205
 # define EVP_F_EVP_DECRYPTFINAL_EX                        101
 # define EVP_F_EVP_DECRYPTUPDATE                          166
@@ -190,6 +193,7 @@ int ERR_load_EVP_strings(void);
 # define EVP_R_INVALID_KEY                                163
 # define EVP_R_INVALID_KEY_LENGTH                         130
 # define EVP_R_INVALID_OPERATION                          148
+# define EVP_R_INVALID_PROVIDER_FUNCTIONS                 193
 # define EVP_R_INVALID_SALT_LENGTH                        186
 # define EVP_R_KEYGEN_FAILURE                             120
 # define EVP_R_KEY_SETUP_FAILED                           180
diff --git a/providers/build.info b/providers/build.info
index 1628e1f..ef107a7 100644
--- a/providers/build.info
+++ b/providers/build.info
@@ -7,7 +7,7 @@ IF[{- !$disabled{fips} -}]
     SOURCE[fips]=fips.ld
     GENERATE[fips.ld]=../util/providers.num
   ENDIF
-  INCLUDE[fips]=.. ../include ../crypto/include
+  INCLUDE[fips]=.. ../include ../crypto/include common/include
   DEFINE[fips]=FIPS_MODE
 ENDIF
 
diff --git a/providers/common/build.info b/providers/common/build.info
index 5cb7e43..1617467 100644
--- a/providers/common/build.info
+++ b/providers/common/build.info
@@ -1 +1,4 @@
-SUBDIRS=digests
+SUBDIRS=digests ciphers
+
+SOURCE[../../libcrypto]=\
+        provider_err.c
diff --git a/providers/common/ciphers/aes.c b/providers/common/ciphers/aes.c
new file mode 100644
index 0000000..5c6e670
--- /dev/null
+++ b/providers/common/ciphers/aes.c
@@ -0,0 +1,470 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;string.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &lt;openssl/core_numbers.h&gt;
+#include &lt;openssl/core_names.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/params.h&gt;
+#include &quot;internal/cryptlib.h&quot;
+#include &quot;internal/provider_algs.h&quot;
+#include &quot;ciphers_locl.h&quot;
+#include &quot;internal/providercommonerr.h&quot;
+
+static OSSL_OP_cipher_encrypt_init_fn aes_einit;
+static OSSL_OP_cipher_decrypt_init_fn aes_dinit;
+static OSSL_OP_cipher_update_fn aes_block_update;
+static OSSL_OP_cipher_final_fn aes_block_final;
+static OSSL_OP_cipher_update_fn aes_stream_update;
+static OSSL_OP_cipher_final_fn aes_stream_final;
+static OSSL_OP_cipher_cipher_fn aes_cipher;
+static OSSL_OP_cipher_freectx_fn aes_freectx;
+static OSSL_OP_cipher_dupctx_fn aes_dupctx;
+static OSSL_OP_cipher_key_length_fn key_length_256;
+static OSSL_OP_cipher_key_length_fn key_length_192;
+static OSSL_OP_cipher_key_length_fn key_length_128;
+static OSSL_OP_cipher_iv_length_fn iv_length_16;
+static OSSL_OP_cipher_iv_length_fn iv_length_0;
+static OSSL_OP_cipher_block_size_fn block_size_16;
+static OSSL_OP_cipher_block_size_fn block_size_1;
+static OSSL_OP_cipher_ctx_get_params_fn aes_ctx_get_params;
+static OSSL_OP_cipher_ctx_set_params_fn aes_ctx_set_params;
+
+static int PROV_AES_KEY_generic_init(PROV_AES_KEY *ctx,
+                                      const unsigned char *iv,
+                                      size_t ivlen,
+                                      int enc)
+{
+    if (iv != NULL &amp;&amp; ctx-&gt;mode != EVP_CIPH_ECB_MODE) {
+        if (ivlen != AES_BLOCK_SIZE) {
+            PROVerr(PROV_F_PROV_AES_KEY_GENERIC_INIT, ERR_R_INTERNAL_ERROR);
+            return 0;
+        }
+        memcpy(ctx-&gt;iv, iv, AES_BLOCK_SIZE);
+    }
+    ctx-&gt;enc = enc;
+
+    return 1;
+}
+
+static int aes_einit(void *vctx, const unsigned char *key, size_t keylen,
+                           const unsigned char *iv, size_t ivlen)
+{
+    PROV_AES_KEY *ctx = (PROV_AES_KEY *)vctx;
+
+    if (!PROV_AES_KEY_generic_init(ctx, iv, ivlen, 1)) {
+        /* PROVerr already called */
+        return 0;
+    }
+    if (key != NULL) {
+        if (keylen != ctx-&gt;keylen) {
+            PROVerr(PROV_F_AES_EINIT, PROV_R_INVALID_KEYLEN);
+            return 0;
+        }
+        return ctx-&gt;ciph-&gt;init(ctx, key, ctx-&gt;keylen);
+    }
+
+    return 1;
+}
+
+static int aes_dinit(void *vctx, const unsigned char *key, size_t keylen,
+                     const unsigned char *iv, size_t ivlen)
+{
+    PROV_AES_KEY *ctx = (PROV_AES_KEY *)vctx;
+
+    if (!PROV_AES_KEY_generic_init(ctx, iv, ivlen, 0)) {
+        /* PROVerr already called */
+        return 0;
+    }
+    if (key != NULL) {
+        if (keylen != ctx-&gt;keylen) {
+            PROVerr(PROV_F_AES_DINIT, PROV_R_INVALID_KEYLEN);
+            return 0;
+        }
+        return ctx-&gt;ciph-&gt;init(ctx, key, ctx-&gt;keylen);
+    }
+
+    return 1;
+}
+
+static int aes_block_update(void *vctx, unsigned char *out, size_t *outl,
+                            size_t outsize, const unsigned char *in, size_t inl)
+{
+    PROV_AES_KEY *ctx = (PROV_AES_KEY *)vctx;
+    size_t nextblocks = fillblock(ctx-&gt;buf, &amp;ctx-&gt;bufsz, AES_BLOCK_SIZE, &amp;in,
+                                  &amp;inl);
+    size_t outlint = 0;
+
+    /*
+     * If we're decrypting and we end an update on a block boundary we hold
+     * the last block back in case this is the last update call and the last
+     * block is padded.
+     */
+    if (ctx-&gt;bufsz == AES_BLOCK_SIZE
+            &amp;&amp; (ctx-&gt;enc || inl &gt; 0 || !ctx-&gt;pad)) {
+        if (outsize &lt; AES_BLOCK_SIZE) {
+            PROVerr(PROV_F_AES_BLOCK_UPDATE, PROV_R_OUTPUT_BUFFER_TOO_SMALL);
+            return 0;
+        }
+        if (!ctx-&gt;ciph-&gt;cipher(ctx, out, ctx-&gt;buf, AES_BLOCK_SIZE)) {
+            PROVerr(PROV_F_AES_BLOCK_UPDATE, PROV_R_CIPHER_OPERATION_FAILED);
+            return 0;
+        }
+        ctx-&gt;bufsz = 0;
+        outlint = AES_BLOCK_SIZE;
+        out += AES_BLOCK_SIZE;
+    }
+    if (nextblocks &gt; 0) {
+        if (!ctx-&gt;enc &amp;&amp; ctx-&gt;pad &amp;&amp; nextblocks == inl) {
+            if (!ossl_assert(inl &gt;= AES_BLOCK_SIZE)) {
+                PROVerr(PROV_F_AES_BLOCK_UPDATE, PROV_R_OUTPUT_BUFFER_TOO_SMALL);
+                return 0;
+            }
+            nextblocks -= AES_BLOCK_SIZE;
+        }
+        outlint += nextblocks;
+        if (outsize &lt; outlint) {
+            PROVerr(PROV_F_AES_BLOCK_UPDATE, PROV_R_OUTPUT_BUFFER_TOO_SMALL);
+            return 0;
+        }
+        if (!ctx-&gt;ciph-&gt;cipher(ctx, out, in, nextblocks)) {
+            PROVerr(PROV_F_AES_BLOCK_UPDATE, PROV_R_CIPHER_OPERATION_FAILED);
+            return 0;
+        }
+        in += nextblocks;
+        inl -= nextblocks;
+    }
+    if (!trailingdata(ctx-&gt;buf, &amp;ctx-&gt;bufsz, AES_BLOCK_SIZE, &amp;in, &amp;inl)) {
+        /* PROVerr already called */
+        return 0;
+    }
+
+    *outl = outlint;
+    return inl == 0;
+}
+
+static int aes_block_final(void *vctx, unsigned char *out, size_t *outl,
+                           size_t outsize)
+{
+    PROV_AES_KEY *ctx = (PROV_AES_KEY *)vctx;
+
+    if (ctx-&gt;enc) {
+        if (ctx-&gt;pad) {
+            padblock(ctx-&gt;buf, &amp;ctx-&gt;bufsz, AES_BLOCK_SIZE);
+        } else if (ctx-&gt;bufsz == 0) {
+            *outl = 0;
+            return 1;
+        } else if (ctx-&gt;bufsz != AES_BLOCK_SIZE) {
+            PROVerr(PROV_F_AES_BLOCK_FINAL, PROV_R_WRONG_FINAL_BLOCK_LENGTH);
+            return 0;
+        }
+
+        if (outsize &lt; AES_BLOCK_SIZE) {
+            PROVerr(PROV_F_AES_BLOCK_FINAL, PROV_R_OUTPUT_BUFFER_TOO_SMALL);
+            return 0;
+        }
+        if (!ctx-&gt;ciph-&gt;cipher(ctx, out, ctx-&gt;buf, AES_BLOCK_SIZE)) {
+            PROVerr(PROV_F_AES_BLOCK_FINAL, PROV_R_CIPHER_OPERATION_FAILED);
+            return 0;
+        }
+        ctx-&gt;bufsz = 0;
+        *outl = AES_BLOCK_SIZE;
+        return 1;
+    }
+
+    /* Decrypting */
+    if (ctx-&gt;bufsz != AES_BLOCK_SIZE) {
+        if (ctx-&gt;bufsz == 0 &amp;&amp; !ctx-&gt;pad) {
+            *outl = 0;
+            return 1;
+        }
+        PROVerr(PROV_F_AES_BLOCK_FINAL, PROV_R_WRONG_FINAL_BLOCK_LENGTH);
+        return 0;
+    }
+
+    if (!ctx-&gt;ciph-&gt;cipher(ctx, ctx-&gt;buf, ctx-&gt;buf, AES_BLOCK_SIZE)) {
+        PROVerr(PROV_F_AES_BLOCK_FINAL, PROV_R_CIPHER_OPERATION_FAILED);
+        return 0;
+    }
+
+    if (ctx-&gt;pad &amp;&amp; !unpadblock(ctx-&gt;buf, &amp;ctx-&gt;bufsz, AES_BLOCK_SIZE)) {
+        /* PROVerr already called */
+        return 0;
+    }
+
+    if (outsize &lt; ctx-&gt;bufsz) {
+        PROVerr(PROV_F_AES_BLOCK_FINAL, PROV_R_OUTPUT_BUFFER_TOO_SMALL);
+        return 0;
+    }
+    memcpy(out, ctx-&gt;buf, ctx-&gt;bufsz);
+    *outl = ctx-&gt;bufsz;
+    ctx-&gt;bufsz = 0;
+    return 1;
+}
+
+static int aes_stream_update(void *vctx, unsigned char *out, size_t *outl,
+                             size_t outsize, const unsigned char *in,
+                             size_t inl)
+{
+    PROV_AES_KEY *ctx = (PROV_AES_KEY *)vctx;
+
+    if (outsize &lt; inl) {
+        PROVerr(PROV_F_AES_STREAM_UPDATE, PROV_R_OUTPUT_BUFFER_TOO_SMALL);
+        return 0;
+    }
+
+    if (!ctx-&gt;ciph-&gt;cipher(ctx, out, in, inl)) {
+        PROVerr(PROV_F_AES_STREAM_UPDATE, PROV_R_CIPHER_OPERATION_FAILED);
+        return 0;
+    }
+
+    *outl = inl;
+    return 1;
+}
+static int aes_stream_final(void *vctx, unsigned char *out, size_t *outl,
+                            size_t outsize)
+{
+    *outl = 0;
+    return 1;
+}
+
+static int aes_cipher(void *vctx, unsigned char *out, const unsigned char *in,
+                      size_t inl)
+{
+    PROV_AES_KEY *ctx = (PROV_AES_KEY *)vctx;
+
+    if (!ctx-&gt;ciph-&gt;cipher(ctx, out, in, inl)) {
+        PROVerr(PROV_F_AES_CIPHER, PROV_R_CIPHER_OPERATION_FAILED);
+        return 0;
+    }
+
+    return 1;
+}
+
+#define IMPLEMENT_new_params(lcmode, UCMODE) \
+    static OSSL_OP_cipher_get_params_fn aes_##lcmode##_get_params; \
+    static int aes_##lcmode##_get_params(const OSSL_PARAM params[]) \
+    { \
+        const OSSL_PARAM *p; \
+    \
+        p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_MODE); \
+        if (p != NULL &amp;&amp; !OSSL_PARAM_set_int(p, EVP_CIPH_##UCMODE##_MODE)) \
+            return 0; \
+    \
+        return 1; \
+    }
+
+#define IMPLEMENT_new_ctx(lcmode, UCMODE, len) \
+    static OSSL_OP_cipher_newctx_fn aes_##len##_##lcmode##_newctx; \
+    static void *aes_##len##_##lcmode##_newctx(void) \
+    { \
+        PROV_AES_KEY *ctx = OPENSSL_zalloc(sizeof(*ctx)); \
+    \
+        ctx-&gt;pad = 1; \
+        ctx-&gt;keylen = (len / 8); \
+        ctx-&gt;ciph = PROV_AES_CIPHER_##lcmode(ctx-&gt;keylen); \
+        ctx-&gt;mode = EVP_CIPH_##UCMODE##_MODE; \
+        return ctx; \
+    }
+
+/* ECB */
+IMPLEMENT_new_params(ecb, ECB)
+IMPLEMENT_new_ctx(ecb, ECB, 256)
+IMPLEMENT_new_ctx(ecb, ECB, 192)
+IMPLEMENT_new_ctx(ecb, ECB, 128)
+
+/* CBC */
+IMPLEMENT_new_params(cbc, CBC)
+IMPLEMENT_new_ctx(cbc, CBC, 256)
+IMPLEMENT_new_ctx(cbc, CBC, 192)
+IMPLEMENT_new_ctx(cbc, CBC, 128)
+
+/* OFB */
+IMPLEMENT_new_params(ofb, OFB)
+IMPLEMENT_new_ctx(ofb, OFB, 256)
+IMPLEMENT_new_ctx(ofb, OFB, 192)
+IMPLEMENT_new_ctx(ofb, OFB, 128)
+
+/* CFB */
+IMPLEMENT_new_params(cfb, CFB)
+IMPLEMENT_new_params(cfb1, CFB)
+IMPLEMENT_new_params(cfb8, CFB)
+IMPLEMENT_new_ctx(cfb, CFB, 256)
+IMPLEMENT_new_ctx(cfb, CFB, 192)
+IMPLEMENT_new_ctx(cfb, CFB, 128)
+IMPLEMENT_new_ctx(cfb1, CFB, 256)
+IMPLEMENT_new_ctx(cfb1, CFB, 192)
+IMPLEMENT_new_ctx(cfb1, CFB, 128)
+IMPLEMENT_new_ctx(cfb8, CFB, 256)
+IMPLEMENT_new_ctx(cfb8, CFB, 192)
+IMPLEMENT_new_ctx(cfb8, CFB, 128)
+
+/* CTR */
+IMPLEMENT_new_params(ctr, CTR)
+IMPLEMENT_new_ctx(ctr, CTR, 256)
+IMPLEMENT_new_ctx(ctr, CTR, 192)
+IMPLEMENT_new_ctx(ctr, CTR, 128)
+
+static void aes_freectx(void *vctx)
+{
+    PROV_AES_KEY *ctx = (PROV_AES_KEY *)vctx;
+
+    OPENSSL_clear_free(ctx,  sizeof(*ctx));
+}
+
+static void *aes_dupctx(void *ctx)
+{
+    PROV_AES_KEY *in = (PROV_AES_KEY *)ctx;
+    PROV_AES_KEY *ret = OPENSSL_malloc(sizeof(*ret));
+
+    if (ret == NULL) {
+        PROVerr(PROV_F_AES_DUPCTX, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+    *ret = *in;
+
+    return ret;
+}
+
+static size_t key_length_256(void)
+{
+    return 256 / 8;
+}
+
+static size_t key_length_192(void)
+{
+    return 192 / 8;
+}
+
+static size_t key_length_128(void)
+{
+    return 128 / 8;
+}
+
+static size_t iv_length_16(void)
+{
+    return 16;
+}
+
+static size_t iv_length_0(void)
+{
+    return 0;
+}
+
+static size_t block_size_16(void)
+{
+    return 16;
+}
+
+static size_t block_size_1(void)
+{
+    return 1;
+}
+
+static int aes_ctx_get_params(void *vctx, const OSSL_PARAM params[])
+{
+    PROV_AES_KEY *ctx = (PROV_AES_KEY *)vctx;
+    const OSSL_PARAM *p;
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_PADDING);
+    if (p != NULL &amp;&amp; !OSSL_PARAM_set_int(p, ctx-&gt;pad)) {
+        PROVerr(PROV_F_AES_CTX_GET_PARAMS, PROV_R_FAILED_TO_SET_PARAMETER);
+        return 0;
+    }
+
+    return 1;
+}
+
+static int aes_ctx_set_params(void *vctx, const OSSL_PARAM params[])
+{
+    PROV_AES_KEY *ctx = (PROV_AES_KEY *)vctx;
+    const OSSL_PARAM *p;
+
+    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_PADDING);
+    if (p != NULL) {
+        int pad;
+
+        if (!OSSL_PARAM_get_int(p, &amp;pad)) {
+        PROVerr(PROV_F_AES_CTX_SET_PARAMS, PROV_R_FAILED_TO_GET_PARAMETER);
+            return 0;
+        }
+        ctx-&gt;pad = pad ? 1 : 0;
+    }
+    return 1;
+}
+
+#define IMPLEMENT_block_funcs(mode, keylen, ivlen) \
+    const OSSL_DISPATCH aes##keylen##mode##_functions[] = { \
+        { OSSL_FUNC_CIPHER_NEWCTX, (void (*)(void))aes_##keylen##_##mode##_newctx }, \
+        { OSSL_FUNC_CIPHER_ENCRYPT_INIT, (void (*)(void))aes_einit }, \
+        { OSSL_FUNC_CIPHER_DECRYPT_INIT, (void (*)(void))aes_dinit }, \
+        { OSSL_FUNC_CIPHER_UPDATE, (void (*)(void))aes_block_update }, \
+        { OSSL_FUNC_CIPHER_FINAL, (void (*)(void))aes_block_final }, \
+        { OSSL_FUNC_CIPHER_CIPHER, (void (*)(void))aes_cipher }, \
+        { OSSL_FUNC_CIPHER_FREECTX, (void (*)(void))aes_freectx }, \
+        { OSSL_FUNC_CIPHER_DUPCTX, (void (*)(void))aes_dupctx }, \
+        { OSSL_FUNC_CIPHER_KEY_LENGTH, (void (*)(void))key_length_##keylen }, \
+        { OSSL_FUNC_CIPHER_IV_LENGTH, (void (*)(void))iv_length_##ivlen }, \
+        { OSSL_FUNC_CIPHER_BLOCK_SIZE, (void (*)(void))block_size_16 }, \
+        { OSSL_FUNC_CIPHER_GET_PARAMS, (void (*)(void))aes_##mode##_get_params }, \
+        { OSSL_FUNC_CIPHER_CTX_GET_PARAMS, (void (*)(void))aes_ctx_get_params }, \
+        { OSSL_FUNC_CIPHER_CTX_SET_PARAMS, (void (*)(void))aes_ctx_set_params }, \
+        { 0, NULL } \
+    };
+
+#define IMPLEMENT_stream_funcs(mode, keylen, ivlen) \
+    const OSSL_DISPATCH aes##keylen##mode##_functions[] = { \
+        { OSSL_FUNC_CIPHER_NEWCTX, (void (*)(void))aes_##keylen##_##mode##_newctx }, \
+        { OSSL_FUNC_CIPHER_ENCRYPT_INIT, (void (*)(void))aes_einit }, \
+        { OSSL_FUNC_CIPHER_DECRYPT_INIT, (void (*)(void))aes_dinit }, \
+        { OSSL_FUNC_CIPHER_UPDATE, (void (*)(void))aes_stream_update }, \
+        { OSSL_FUNC_CIPHER_FINAL, (void (*)(void))aes_stream_final }, \
+        { OSSL_FUNC_CIPHER_CIPHER, (void (*)(void))aes_cipher }, \
+        { OSSL_FUNC_CIPHER_FREECTX, (void (*)(void))aes_freectx }, \
+        { OSSL_FUNC_CIPHER_DUPCTX, (void (*)(void))aes_dupctx }, \
+        { OSSL_FUNC_CIPHER_KEY_LENGTH, (void (*)(void))key_length_##keylen }, \
+        { OSSL_FUNC_CIPHER_IV_LENGTH, (void (*)(void))iv_length_##ivlen }, \
+        { OSSL_FUNC_CIPHER_BLOCK_SIZE, (void (*)(void))block_size_1 }, \
+        { OSSL_FUNC_CIPHER_GET_PARAMS, (void (*)(void))aes_##mode##_get_params }, \
+        { OSSL_FUNC_CIPHER_CTX_GET_PARAMS, (void (*)(void))aes_ctx_get_params }, \
+        { OSSL_FUNC_CIPHER_CTX_SET_PARAMS, (void (*)(void))aes_ctx_set_params }, \
+        { 0, NULL } \
+    };
+
+/* ECB */
+IMPLEMENT_block_funcs(ecb, 256, 0)
+IMPLEMENT_block_funcs(ecb, 192, 0)
+IMPLEMENT_block_funcs(ecb, 128, 0)
+
+/* CBC */
+IMPLEMENT_block_funcs(cbc, 256, 16)
+IMPLEMENT_block_funcs(cbc, 192, 16)
+IMPLEMENT_block_funcs(cbc, 128, 16)
+
+/* OFB */
+IMPLEMENT_stream_funcs(ofb, 256, 16)
+IMPLEMENT_stream_funcs(ofb, 192, 16)
+IMPLEMENT_stream_funcs(ofb, 128, 16)
+
+/* CFB */
+IMPLEMENT_stream_funcs(cfb, 256, 16)
+IMPLEMENT_stream_funcs(cfb, 192, 16)
+IMPLEMENT_stream_funcs(cfb, 128, 16)
+IMPLEMENT_stream_funcs(cfb1, 256, 16)
+IMPLEMENT_stream_funcs(cfb1, 192, 16)
+IMPLEMENT_stream_funcs(cfb1, 128, 16)
+IMPLEMENT_stream_funcs(cfb8, 256, 16)
+IMPLEMENT_stream_funcs(cfb8, 192, 16)
+IMPLEMENT_stream_funcs(cfb8, 128, 16)
+
+/* CTR */
+IMPLEMENT_stream_funcs(ctr, 256, 16)
+IMPLEMENT_stream_funcs(ctr, 192, 16)
+IMPLEMENT_stream_funcs(ctr, 128, 16)
diff --git a/providers/common/ciphers/aes_basic.c b/providers/common/ciphers/aes_basic.c
new file mode 100644
index 0000000..0f64296
--- /dev/null
+++ b/providers/common/ciphers/aes_basic.c
@@ -0,0 +1,866 @@
+/*
+ * Copyright 2001-2018 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/opensslconf.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &lt;openssl/err.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;openssl/aes.h&gt;
+#include &quot;internal/evp_int.h&quot;
+#include &lt;openssl/rand.h&gt;
+#include &lt;openssl/cmac.h&gt;
+#include &quot;ciphers_locl.h&quot;
+#include &quot;internal/providercommonerr.h&quot;
+
+#define MAXBITCHUNK     ((size_t)1 &lt;&lt; (sizeof(size_t) * 8 - 4))
+
+#ifdef VPAES_ASM
+int vpaes_set_encrypt_key(const unsigned char *userKey, int bits,
+                          AES_KEY *key);
+int vpaes_set_decrypt_key(const unsigned char *userKey, int bits,
+                          AES_KEY *key);
+
+void vpaes_encrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+void vpaes_decrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+
+void vpaes_cbc_encrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length,
+                       const AES_KEY *key, unsigned char *ivec, int enc);
+#endif
+#ifdef BSAES_ASM
+void bsaes_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                       size_t length, const AES_KEY *key,
+                       unsigned char ivec[16], int enc);
+void bsaes_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
+                                size_t len, const AES_KEY *key,
+                                const unsigned char ivec[16]);
+#endif
+#ifdef AES_CTR_ASM
+void AES_ctr32_encrypt(const unsigned char *in, unsigned char *out,
+                       size_t blocks, const AES_KEY *key,
+                       const unsigned char ivec[AES_BLOCK_SIZE]);
+#endif
+
+
+#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; (defined(__powerpc__) || defined(__ppc__) || defined(_ARCH_PPC))
+# include &quot;ppc_arch.h&quot;
+# ifdef VPAES_ASM
+#  define VPAES_CAPABLE (OPENSSL_ppccap_P &amp; PPC_ALTIVEC)
+# endif
+# define HWAES_CAPABLE  (OPENSSL_ppccap_P &amp; PPC_CRYPTO207)
+# define HWAES_set_encrypt_key aes_p8_set_encrypt_key
+# define HWAES_set_decrypt_key aes_p8_set_decrypt_key
+# define HWAES_encrypt aes_p8_encrypt
+# define HWAES_decrypt aes_p8_decrypt
+# define HWAES_cbc_encrypt aes_p8_cbc_encrypt
+# define HWAES_ctr32_encrypt_blocks aes_p8_ctr32_encrypt_blocks
+# define HWAES_xts_encrypt aes_p8_xts_encrypt
+# define HWAES_xts_decrypt aes_p8_xts_decrypt
+#endif
+
+#if     defined(AES_ASM) &amp;&amp; !defined(I386_ONLY) &amp;&amp;      (  \
+        ((defined(__i386)       || defined(__i386__)    || \
+          defined(_M_IX86)) &amp;&amp; defined(OPENSSL_IA32_SSE2))|| \
+        defined(__x86_64)       || defined(__x86_64__)  || \
+        defined(_M_AMD64)       || defined(_M_X64)      )
+
+extern unsigned int OPENSSL_ia32cap_P[];
+
+# ifdef VPAES_ASM
+#  define VPAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
+# endif
+# ifdef BSAES_ASM
+#  define BSAES_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(41-32)))
+# endif
+/*
+ * AES-NI section
+ */
+# define AESNI_CAPABLE   (OPENSSL_ia32cap_P[1]&amp;(1&lt;&lt;(57-32)))
+
+int aesni_set_encrypt_key(const unsigned char *userKey, int bits,
+                          AES_KEY *key);
+int aesni_set_decrypt_key(const unsigned char *userKey, int bits,
+                          AES_KEY *key);
+
+void aesni_encrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+void aesni_decrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+
+void aesni_ecb_encrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length, const AES_KEY *key, int enc);
+void aesni_cbc_encrypt(const unsigned char *in,
+                       unsigned char *out,
+                       size_t length,
+                       const AES_KEY *key, unsigned char *ivec, int enc);
+
+void aesni_ctr32_encrypt_blocks(const unsigned char *in,
+                                unsigned char *out,
+                                size_t blocks,
+                                const void *key, const unsigned char *ivec);
+
+static int aesni_init_key(PROV_AES_KEY *dat, const unsigned char *key,
+                          size_t keylen)
+{
+    int ret;
+
+    if ((dat-&gt;mode == EVP_CIPH_ECB_MODE || dat-&gt;mode == EVP_CIPH_CBC_MODE)
+        &amp;&amp; !dat-&gt;enc) {
+        ret = aesni_set_decrypt_key(key, keylen * 8, &amp;dat-&gt;ks.ks);
+        dat-&gt;block = (block128_f) aesni_decrypt;
+        dat-&gt;stream.cbc = dat-&gt;mode == EVP_CIPH_CBC_MODE ?
+            (cbc128_f) aesni_cbc_encrypt : NULL;
+    } else {
+        ret = aesni_set_encrypt_key(key, keylen * 8, &amp;dat-&gt;ks.ks);
+        dat-&gt;block = (block128_f) aesni_encrypt;
+        if (dat-&gt;mode == EVP_CIPH_CBC_MODE)
+            dat-&gt;stream.cbc = (cbc128_f) aesni_cbc_encrypt;
+        else if (dat-&gt;mode == EVP_CIPH_CTR_MODE)
+            dat-&gt;stream.ctr = (ctr128_f) aesni_ctr32_encrypt_blocks;
+        else
+            dat-&gt;stream.cbc = NULL;
+    }
+
+    if (ret &lt; 0) {
+        PROVerr(PROV_F_AESNI_INIT_KEY, PROV_R_AES_KEY_SETUP_FAILED);
+        return 0;
+    }
+
+    return 1;
+}
+
+static int aesni_cbc_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                            const unsigned char *in, size_t len)
+{
+    aesni_cbc_encrypt(in, out, len, &amp;ctx-&gt;ks.ks, ctx-&gt;iv, ctx-&gt;enc);
+
+    return 1;
+}
+
+static int aesni_ecb_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                            const unsigned char *in, size_t len)
+{
+    if (len &lt; AES_BLOCK_SIZE)
+        return 1;
+
+    aesni_ecb_encrypt(in, out, len, &amp;ctx-&gt;ks.ks, ctx-&gt;enc);
+
+    return 1;
+}
+
+# define aesni_ofb_cipher aes_ofb_cipher
+static int aesni_ofb_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                            const unsigned char *in, size_t len);
+
+# define aesni_cfb_cipher aes_cfb_cipher
+static int aesni_cfb_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                            const unsigned char *in, size_t len);
+
+# define aesni_cfb8_cipher aes_cfb8_cipher
+static int aesni_cfb8_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                             const unsigned char *in, size_t len);
+
+# define aesni_cfb1_cipher aes_cfb1_cipher
+static int aesni_cfb1_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                             const unsigned char *in, size_t len);
+
+# define aesni_ctr_cipher aes_ctr_cipher
+static int aesni_ctr_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                            const unsigned char *in, size_t len);
+
+# define BLOCK_CIPHER_generic_prov(mode) \
+static const PROV_AES_CIPHER aesni_##mode = { \
+        aesni_init_key,                 \
+        aesni_##mode##_cipher};         \
+static const PROV_AES_CIPHER aes_##mode = { \
+        aes_init_key,                   \
+        aes_##mode##_cipher}; \
+const PROV_AES_CIPHER *PROV_AES_CIPHER_##mode(size_t keylen) \
+{ return AESNI_CAPABLE?&amp;aesni_##mode:&amp;aes_##mode; }
+
+
+#elif   defined(AES_ASM) &amp;&amp; (defined(__sparc) || defined(__sparc__))
+
+# include &quot;sparc_arch.h&quot;
+
+extern unsigned int OPENSSL_sparcv9cap_P[];
+
+/*
+ * Fujitsu SPARC64 X support
+ */
+# define HWAES_CAPABLE           (OPENSSL_sparcv9cap_P[0] &amp; SPARCV9_FJAESX)
+# define HWAES_set_encrypt_key aes_fx_set_encrypt_key
+# define HWAES_set_decrypt_key aes_fx_set_decrypt_key
+# define HWAES_encrypt aes_fx_encrypt
+# define HWAES_decrypt aes_fx_decrypt
+# define HWAES_cbc_encrypt aes_fx_cbc_encrypt
+# define HWAES_ctr32_encrypt_blocks aes_fx_ctr32_encrypt_blocks
+
+# define SPARC_AES_CAPABLE       (OPENSSL_sparcv9cap_P[1] &amp; CFR_AES)
+
+void aes_t4_set_encrypt_key(const unsigned char *key, int bits, AES_KEY *ks);
+void aes_t4_set_decrypt_key(const unsigned char *key, int bits, AES_KEY *ks);
+void aes_t4_encrypt(const unsigned char *in, unsigned char *out,
+                    const AES_KEY *key);
+void aes_t4_decrypt(const unsigned char *in, unsigned char *out,
+                    const AES_KEY *key);
+/*
+ * Key-length specific subroutines were chosen for following reason.
+ * Each SPARC T4 core can execute up to 8 threads which share core's
+ * resources. Loading as much key material to registers allows to
+ * minimize references to shared memory interface, as well as amount
+ * of instructions in inner loops [much needed on T4]. But then having
+ * non-key-length specific routines would require conditional branches
+ * either in inner loops or on subroutines' entries. Former is hardly
+ * acceptable, while latter means code size increase to size occupied
+ * by multiple key-length specific subroutines, so why fight?
+ */
+void aes128_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes128_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes192_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes192_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes256_t4_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes256_t4_cbc_decrypt(const unsigned char *in, unsigned char *out,
+                           size_t len, const AES_KEY *key,
+                           unsigned char *ivec);
+void aes128_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
+                             size_t blocks, const AES_KEY *key,
+                             unsigned char *ivec);
+void aes192_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
+                             size_t blocks, const AES_KEY *key,
+                             unsigned char *ivec);
+void aes256_t4_ctr32_encrypt(const unsigned char *in, unsigned char *out,
+                             size_t blocks, const AES_KEY *key,
+                             unsigned char *ivec);
+
+static int aes_t4_init_key(PROV_AES_KEY *dat, const unsigned char *key,
+                           size_t keylen)
+{
+    int ret, bits;
+
+    bits = keylen * 8;
+    if ((dat-&gt;mode == EVP_CIPH_ECB_MODE || dat-&gt;mode == EVP_CIPH_CBC_MODE)
+        &amp;&amp; !dat-&gt;enc) {
+        ret = 0;
+        aes_t4_set_decrypt_key(key, bits, &amp;dat-&gt;ks.ks);
+        dat-&gt;block = (block128_f) aes_t4_decrypt;
+        switch (bits) {
+        case 128:
+            dat-&gt;stream.cbc = dat-&gt;mode == EVP_CIPH_CBC_MODE ?
+                (cbc128_f) aes128_t4_cbc_decrypt : NULL;
+            break;
+        case 192:
+            dat-&gt;stream.cbc = dat-&gt;mode == EVP_CIPH_CBC_MODE ?
+                (cbc128_f) aes192_t4_cbc_decrypt : NULL;
+            break;
+        case 256:
+            dat-&gt;stream.cbc = dat-&gt;mode == EVP_CIPH_CBC_MODE ?
+                (cbc128_f) aes256_t4_cbc_decrypt : NULL;
+            break;
+        default:
+            ret = -1;
+        }
+    } else {
+        ret = 0;
+        aes_t4_set_encrypt_key(key, bits, &amp;dat-&gt;ks.ks);
+        dat-&gt;block = (block128_f)aes_t4_encrypt;
+        switch (bits) {
+        case 128:
+            if (dat-&gt;mode == EVP_CIPH_CBC_MODE)
+                dat-&gt;stream.cbc = (cbc128_f)aes128_t4_cbc_encrypt;
+            else if (dat-&gt;mode == EVP_CIPH_CTR_MODE)
+                dat-&gt;stream.ctr = (ctr128_f)aes128_t4_ctr32_encrypt;
+            else
+                dat-&gt;stream.cbc = NULL;
+            break;
+        case 192:
+            if (dat-&gt;mode == EVP_CIPH_CBC_MODE)
+                dat-&gt;stream.cbc = (cbc128_f)aes192_t4_cbc_encrypt;
+            else if (dat-&gt;mode == EVP_CIPH_CTR_MODE)
+                dat-&gt;stream.ctr = (ctr128_f)aes192_t4_ctr32_encrypt;
+            else
+                dat-&gt;stream.cbc = NULL;
+            break;
+        case 256:
+            if (dat-&gt;mode == EVP_CIPH_CBC_MODE)
+                dat-&gt;stream.cbc = (cbc128_f)aes256_t4_cbc_encrypt;
+            else if (dat-&gt;mode == EVP_CIPH_CTR_MODE)
+                dat-&gt;stream.ctr = (ctr128_f)aes256_t4_ctr32_encrypt;
+            else
+                dat-&gt;stream.cbc = NULL;
+            break;
+        default:
+            ret = -1;
+        }
+    }
+
+    if (ret &lt; 0) {
+        PROVerr(PROV_F_AES_T4_INIT_KEY, PROV_R_AES_KEY_SETUP_FAILED);
+        return 0;
+    }
+
+    return 1;
+}
+
+# define aes_t4_cbc_cipher aes_cbc_cipher
+static int aes_t4_cbc_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                             const unsigned char *in, size_t len);
+
+# define aes_t4_ecb_cipher aes_ecb_cipher
+static int aes_t4_ecb_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                             const unsigned char *in, size_t len);
+
+# define aes_t4_ofb_cipher aes_ofb_cipher
+static int aes_t4_ofb_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                             const unsigned char *in, size_t len);
+
+# define aes_t4_cfb_cipher aes_cfb_cipher
+static int aes_t4_cfb_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                             const unsigned char *in, size_t len);
+
+# define aes_t4_cfb8_cipher aes_cfb8_cipher
+static int aes_t4_cfb8_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                              const unsigned char *in, size_t len);
+
+# define aes_t4_cfb1_cipher aes_cfb1_cipher
+static int aes_t4_cfb1_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                              const unsigned char *in, size_t len);
+
+# define aes_t4_ctr_cipher aes_ctr_cipher
+static int aes_t4_ctr_cipher(PROV_AES_KEY *ctx, unsigned char *out,
+                             const unsigned char *in, size_t len);
+
+# define BLOCK_CIPHER_generic_prov(mode) \
+static const PROV_AES_CIPHER aes_t4_##mode = { \
+        aes_t4_init_key,                 \
+        aes_t4_##mode##_cipher};         \
+static const PROV_AES_CIPHER aes_##mode = { \
+        aes_init_key,                   \
+        aes_##mode##_cipher}; \
+const PROV_AES_CIPHER *PROV_AES_CIPHER_##mode(size_t keylen) \
+{ return SPARC_AES_CAPABLE?&amp;aes_t4_##mode:&amp;aes_##mode; }
+
+
+#elif defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__)
+/*
+ * IBM S390X support
+ */
+# include &quot;s390x_arch.h&quot;
+
+/* Convert key size to function code: [16,24,32] -&gt; [18,19,20]. */
+# define S390X_AES_FC(keylen)  (S390X_AES_128 + ((((keylen) &lt;&lt; 3) - 128) &gt;&gt; 6))
+
+/* Most modes of operation need km for partial block processing. */
+# define S390X_aes_128_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;	\
+                                S390X_CAPBIT(S390X_AES_128))
+# define S390X_aes_192_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;	\
+                                S390X_CAPBIT(S390X_AES_192))
+# define S390X_aes_256_CAPABLE (OPENSSL_s390xcap_P.km[0] &amp;	\
+                                S390X_CAPBIT(S390X_AES_256))
+
+# define s390x_aes_init_key aes_init_key
+static int s390x_aes_init_key(PROV_AES_KEY *dat, const unsigned char *key,
+                              size_t keylen);
+
+# define S390X_aes_128_cbc_CAPABLE  1	/* checked by callee */
+# define S390X_aes_192_cbc_CAPABLE  1
+# define S390X_aes_256_cbc_CAPABLE  1
+# define S390X_AES_CBC_CTX          PROV_AES_KEY
+
+# define s390x_aes_cbc_init_key aes_init_key
+
+# define s390x_aes_cbc_cipher aes_cbc_cipher
+static int s390x_aes_cbc_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                                const unsigned char *in, size_t len);
+
+# define S390X_aes_128_ecb_CAPABLE  S390X_aes_128_CAPABLE
+# define S390X_aes_192_ecb_CAPABLE  S390X_aes_192_CAPABLE
+# define S390X_aes_256_ecb_CAPABLE  S390X_aes_256_CAPABLE
+
+static int s390x_aes_ecb_init_key(PROV_AES_KEY *dat, const unsigned char *key,
+                                  size_t keylen)
+{
+    dat-&gt;plat.s390x.fc = S390X_AES_FC(keylen);
+    if (!dat-&gt;enc)
+        dat-&gt;plat.s390x.fc |= S390X_DECRYPT;
+
+    memcpy(dat-&gt;plat.s390x.param.km.k, key, keylen);
+    return 1;
+}
+
+static int s390x_aes_ecb_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                                const unsigned char *in, size_t len)
+{
+    s390x_km(in, len, out, dat-&gt;plat.s390x.fc,
+             &amp;dat-&gt;plat.s390x.param.km);
+    return 1;
+}
+
+# define S390X_aes_128_ofb_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;        \
+                                    (OPENSSL_s390xcap_P.kmo[0] &amp;    \
+                                     S390X_CAPBIT(S390X_AES_128)))
+# define S390X_aes_192_ofb_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;        \
+                                    (OPENSSL_s390xcap_P.kmo[0] &amp;    \
+                                     S390X_CAPBIT(S390X_AES_192)))
+# define S390X_aes_256_ofb_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;        \
+                                    (OPENSSL_s390xcap_P.kmo[0] &amp;    \
+                                     S390X_CAPBIT(S390X_AES_256)))
+
+static int s390x_aes_ofb_init_key(PROV_AES_KEY *dat, const unsigned char *key,
+                                  size_t keylen)
+{
+    memcpy(dat-&gt;plat.s390x.param.kmo_kmf.cv, dat-&gt;iv, AES_BLOCK_SIZE);
+    memcpy(dat-&gt;plat.s390x.param.kmo_kmf.k, key, keylen);
+    dat-&gt;plat.s390x.fc = S390X_AES_FC(keylen);
+    dat-&gt;plat.s390x.res = 0;
+    return 1;
+}
+
+static int s390x_aes_ofb_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                                const unsigned char *in, size_t len)
+{
+    int n = dat-&gt;plat.s390x.res;
+    int rem;
+
+    while (n &amp;&amp; len) {
+        *out = *in ^ dat-&gt;plat.s390x.param.kmo_kmf.cv[n];
+        n = (n + 1) &amp; 0xf;
+        --len;
+        ++in;
+        ++out;
+    }
+
+    rem = len &amp; 0xf;
+
+    len &amp;= ~(size_t)0xf;
+    if (len) {
+        s390x_kmo(in, len, out, dat-&gt;plat.s390x.fc,
+                  &amp;dat-&gt;plat.s390x.param.kmo_kmf);
+
+        out += len;
+        in += len;
+    }
+
+    if (rem) {
+        s390x_km(dat-&gt;plat.s390x.param.kmo_kmf.cv, 16,
+                 dat-&gt;plat.s390x.param.kmo_kmf.cv, dat-&gt;plat.s390x.fc,
+                 dat-&gt;plat.s390x.param.kmo_kmf.k);
+
+        while (rem--) {
+            out[n] = in[n] ^ dat-&gt;plat.s390x.param.kmo_kmf.cv[n];
+            ++n;
+        }
+    }
+
+    dat-&gt;plat.s390x.res = n;
+    return 1;
+}
+
+# define S390X_aes_128_cfb_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;        \
+                                    (OPENSSL_s390xcap_P.kmf[0] &amp;    \
+                                     S390X_CAPBIT(S390X_AES_128)))
+# define S390X_aes_192_cfb_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;        \
+                                    (OPENSSL_s390xcap_P.kmf[0] &amp;    \
+                                     S390X_CAPBIT(S390X_AES_192)))
+# define S390X_aes_256_cfb_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;        \
+                                    (OPENSSL_s390xcap_P.kmf[0] &amp;    \
+                                     S390X_CAPBIT(S390X_AES_256)))
+
+static int s390x_aes_cfb_init_key(PROV_AES_KEY *dat, const unsigned char *key,
+                                  size_t keylen)
+{
+    dat-&gt;plat.s390x.fc = S390X_AES_FC(keylen);
+    dat-&gt;plat.s390x.fc |= 16 &lt;&lt; 24;   /* 16 bytes cipher feedback */
+    if (!dat-&gt;enc)
+        dat-&gt;plat.s390x.fc |= S390X_DECRYPT;
+
+    dat-&gt;plat.s390x.res = 0;
+    memcpy(dat-&gt;plat.s390x.param.kmo_kmf.cv, dat-&gt;iv, AES_BLOCK_SIZE);
+    memcpy(dat-&gt;plat.s390x.param.kmo_kmf.k, key, keylen);
+    return 1;
+}
+
+static int s390x_aes_cfb_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                                const unsigned char *in, size_t len)
+{
+    int n = dat-&gt;plat.s390x.res;
+    int rem;
+    unsigned char tmp;
+
+    while (n &amp;&amp; len) {
+        tmp = *in;
+        *out = dat-&gt;plat.s390x.param.kmo_kmf.cv[n] ^ tmp;
+        dat-&gt;plat.s390x.param.kmo_kmf.cv[n] = dat-&gt;enc ? *out : tmp;
+        n = (n + 1) &amp; 0xf;
+        --len;
+        ++in;
+        ++out;
+    }
+
+    rem = len &amp; 0xf;
+
+    len &amp;= ~(size_t)0xf;
+    if (len) {
+        s390x_kmf(in, len, out, dat-&gt;plat.s390x.fc,
+                  &amp;dat-&gt;plat.s390x.param.kmo_kmf);
+
+        out += len;
+        in += len;
+    }
+
+    if (rem) {
+        s390x_km(dat-&gt;plat.s390x.param.kmo_kmf.cv, 16,
+                 dat-&gt;plat.s390x.param.kmo_kmf.cv,
+                 S390X_AES_FC(dat-&gt;keylen), dat-&gt;plat.s390x.param.kmo_kmf.k);
+
+        while (rem--) {
+            tmp = in[n];
+            out[n] = dat-&gt;plat.s390x.param.kmo_kmf.cv[n] ^ tmp;
+            dat-&gt;plat.s390x.param.kmo_kmf.cv[n] = dat-&gt;enc ? out[n] : tmp;
+            ++n;
+        }
+    }
+
+    dat-&gt;plat.s390x.res = n;
+    return 1;
+}
+
+# define S390X_aes_128_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;    \
+                                     S390X_CAPBIT(S390X_AES_128))
+# define S390X_aes_192_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;    \
+                                     S390X_CAPBIT(S390X_AES_192))
+# define S390X_aes_256_cfb8_CAPABLE (OPENSSL_s390xcap_P.kmf[0] &amp;    \
+                                     S390X_CAPBIT(S390X_AES_256))
+
+static int s390x_aes_cfb8_init_key(PROV_AES_KEY *dat, const unsigned char *key,
+                                  size_t keylen)
+{
+    dat-&gt;plat.s390x.fc = S390X_AES_FC(keylen);
+    dat-&gt;plat.s390x.fc |= 1 &lt;&lt; 24;   /* 1 byte cipher feedback */
+    if (!dat-&gt;enc)
+        dat-&gt;plat.s390x.fc |= S390X_DECRYPT;
+
+    memcpy(dat-&gt;plat.s390x.param.kmo_kmf.cv, dat-&gt;iv, AES_BLOCK_SIZE);
+    memcpy(dat-&gt;plat.s390x.param.kmo_kmf.k, key, keylen);
+    return 1;
+}
+
+static int s390x_aes_cfb8_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                                 const unsigned char *in, size_t len)
+{
+    s390x_kmf(in, len, out, dat-&gt;plat.s390x.fc,
+              &amp;dat-&gt;plat.s390x.param.kmo_kmf);
+    return 1;
+}
+
+# define S390X_aes_128_cfb1_CAPABLE 0
+# define S390X_aes_192_cfb1_CAPABLE 0
+# define S390X_aes_256_cfb1_CAPABLE 0
+
+# define s390x_aes_cfb1_init_key aes_init_key
+
+# define s390x_aes_cfb1_cipher aes_cfb1_cipher
+static int s390x_aes_cfb1_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                                 const unsigned char *in, size_t len);
+
+# define S390X_aes_128_ctr_CAPABLE  1	/* checked by callee */
+# define S390X_aes_192_ctr_CAPABLE  1
+# define S390X_aes_256_ctr_CAPABLE  1
+# define S390X_AES_CTR_CTX          PROV_AES_KEY
+
+# define s390x_aes_ctr_init_key aes_init_key
+
+# define s390x_aes_ctr_cipher aes_ctr_cipher
+static int s390x_aes_ctr_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                                const unsigned char *in, size_t len);
+
+# define BLOCK_CIPHER_generic_prov(mode) \
+static const PROV_AES_CIPHER s390x_aes_##mode = { \
+        s390x_aes_##mode##_init_key,    \
+        s390x_aes_##mode##_cipher       \
+};  \
+static const PROV_AES_CIPHER aes_##mode = { \
+        aes_init_key,           \
+        aes_##mode##_cipher     \
+}; \
+const PROV_AES_CIPHER *PROV_AES_CIPHER_##mode(size_t keylen) \
+{   \
+    if ((keylen == 128 &amp;&amp; S390X_aes_128_##mode##_CAPABLE)           \
+            || (keylen == 192 &amp;&amp; S390X_aes_192_##mode##_CAPABLE)    \
+            || (keylen == 256 &amp;&amp; S390X_aes_256_##mode##_CAPABLE))   \
+        return &amp;s390x_aes_##mode;   \
+    \
+    return &amp;aes_##mode; \
+}
+
+#else
+
+# define BLOCK_CIPHER_generic_prov(mode) \
+static const PROV_AES_CIPHER aes_##mode = { \
+        aes_init_key,                   \
+        aes_##mode##_cipher}; \
+const PROV_AES_CIPHER *PROV_AES_CIPHER_##mode(size_t keylen) \
+{ return &amp;aes_##mode; }
+
+#endif
+
+#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; (defined(__arm__) || defined(__arm) || defined(__aarch64__))
+# include &quot;arm_arch.h&quot;
+# if __ARM_MAX_ARCH__&gt;=7
+#  if defined(BSAES_ASM)
+#   define BSAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
+#  endif
+#  if defined(VPAES_ASM)
+#   define VPAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV7_NEON)
+#  endif
+#  define HWAES_CAPABLE (OPENSSL_armcap_P &amp; ARMV8_AES)
+#  define HWAES_set_encrypt_key aes_v8_set_encrypt_key
+#  define HWAES_set_decrypt_key aes_v8_set_decrypt_key
+#  define HWAES_encrypt aes_v8_encrypt
+#  define HWAES_decrypt aes_v8_decrypt
+#  define HWAES_cbc_encrypt aes_v8_cbc_encrypt
+#  define HWAES_ctr32_encrypt_blocks aes_v8_ctr32_encrypt_blocks
+# endif
+#endif
+
+#if defined(HWAES_CAPABLE)
+int HWAES_set_encrypt_key(const unsigned char *userKey, const int bits,
+                          AES_KEY *key);
+int HWAES_set_decrypt_key(const unsigned char *userKey, const int bits,
+                          AES_KEY *key);
+void HWAES_encrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+void HWAES_decrypt(const unsigned char *in, unsigned char *out,
+                   const AES_KEY *key);
+void HWAES_cbc_encrypt(const unsigned char *in, unsigned char *out,
+                       size_t length, const AES_KEY *key,
+                       unsigned char *ivec, const int enc);
+void HWAES_ctr32_encrypt_blocks(const unsigned char *in, unsigned char *out,
+                                size_t len, const AES_KEY *key,
+                                const unsigned char ivec[16]);
+#endif
+
+static int aes_init_key(PROV_AES_KEY *dat, const unsigned char *key,
+                        size_t keylen)
+{
+    int ret;
+
+    if ((dat-&gt;mode == EVP_CIPH_ECB_MODE || dat-&gt;mode == EVP_CIPH_CBC_MODE)
+        &amp;&amp; !dat-&gt;enc) {
+#ifdef HWAES_CAPABLE
+        if (HWAES_CAPABLE) {
+            ret = HWAES_set_decrypt_key(key, keylen * 8, &amp;dat-&gt;ks.ks);
+            dat-&gt;block = (block128_f)HWAES_decrypt;
+            dat-&gt;stream.cbc = NULL;
+# ifdef HWAES_cbc_encrypt
+            if (dat-&gt;mode == EVP_CIPH_CBC_MODE)
+                dat-&gt;stream.cbc = (cbc128_f)HWAES_cbc_encrypt;
+# endif
+        } else
+#endif
+#ifdef BSAES_CAPABLE
+        if (BSAES_CAPABLE &amp;&amp; dat-&gt;mode == EVP_CIPH_CBC_MODE) {
+            ret = AES_set_decrypt_key(key, keylen * 8, &amp;dat-&gt;ks.ks);
+            dat-&gt;block = (block128_f)AES_decrypt;
+            dat-&gt;stream.cbc = (cbc128_f)bsaes_cbc_encrypt;
+        } else
+#endif
+#ifdef VPAES_CAPABLE
+        if (VPAES_CAPABLE) {
+            ret = vpaes_set_decrypt_key(key, keylen * 8, &amp;dat-&gt;ks.ks);
+            dat-&gt;block = (block128_f)vpaes_decrypt;
+            dat-&gt;stream.cbc = (dat-&gt;mode == EVP_CIPH_CBC_MODE)
+                              ?(cbc128_f)vpaes_cbc_encrypt : NULL;
+        } else
+#endif
+        {
+            ret = AES_set_decrypt_key(key, keylen * 8, &amp;dat-&gt;ks.ks);
+            dat-&gt;block = (block128_f)AES_decrypt;
+            dat-&gt;stream.cbc = (dat-&gt;mode == EVP_CIPH_CBC_MODE)
+                              ? (cbc128_f)AES_cbc_encrypt : NULL;
+        }
+    } else
+#ifdef HWAES_CAPABLE
+    if (HWAES_CAPABLE) {
+        ret = HWAES_set_encrypt_key(key, keylen * 8, &amp;dat-&gt;ks.ks);
+        dat-&gt;block = (block128_f)HWAES_encrypt;
+        dat-&gt;stream.cbc = NULL;
+# ifdef HWAES_cbc_encrypt
+        if (dat-&gt;mode == EVP_CIPH_CBC_MODE)
+            dat-&gt;stream.cbc = (cbc128_f)HWAES_cbc_encrypt;
+        else
+# endif
+# ifdef HWAES_ctr32_encrypt_blocks
+        if (dat-&gt;mode == EVP_CIPH_CTR_MODE)
+            dat-&gt;stream.ctr = (ctr128_f)HWAES_ctr32_encrypt_blocks;
+        else
+# endif
+            (void)0;            /* terminate potentially open 'else' */
+    } else
+#endif
+#ifdef BSAES_CAPABLE
+    if (BSAES_CAPABLE &amp;&amp; dat-&gt;mode == EVP_CIPH_CTR_MODE) {
+        ret = AES_set_encrypt_key(key, keylen * 8, &amp;dat-&gt;ks.ks);
+        dat-&gt;block = (block128_f)AES_encrypt;
+        dat-&gt;stream.ctr = (ctr128_f)bsaes_ctr32_encrypt_blocks;
+    } else
+#endif
+#ifdef VPAES_CAPABLE
+    if (VPAES_CAPABLE) {
+        ret = vpaes_set_encrypt_key(key, keylen * 8, &amp;dat-&gt;ks.ks);
+        dat-&gt;block = (block128_f)vpaes_encrypt;
+        dat-&gt;stream.cbc = (dat-&gt;mode == EVP_CIPH_CBC_MODE)
+                          ? (cbc128_f)vpaes_cbc_encrypt : NULL;
+    } else
+#endif
+    {
+        ret = AES_set_encrypt_key(key, keylen * 8, &amp;dat-&gt;ks.ks);
+        dat-&gt;block = (block128_f)AES_encrypt;
+        dat-&gt;stream.cbc = (dat-&gt;mode == EVP_CIPH_CBC_MODE)
+                          ? (cbc128_f)AES_cbc_encrypt : NULL;
+#ifdef AES_CTR_ASM
+        if (dat-&gt;mode == EVP_CIPH_CTR_MODE)
+            dat-&gt;stream.ctr = (ctr128_f)AES_ctr32_encrypt;
+#endif
+    }
+
+    if (ret &lt; 0) {
+        PROVerr(PROV_F_AES_INIT_KEY, PROV_R_AES_KEY_SETUP_FAILED);
+        return 0;
+    }
+
+    return 1;
+}
+
+static int aes_cbc_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                          const unsigned char *in, size_t len)
+{
+    if (dat-&gt;stream.cbc)
+        (*dat-&gt;stream.cbc) (in, out, len, &amp;dat-&gt;ks, dat-&gt;iv, dat-&gt;enc);
+    else if (dat-&gt;enc)
+        CRYPTO_cbc128_encrypt(in, out, len, &amp;dat-&gt;ks, dat-&gt;iv, dat-&gt;block);
+    else
+        CRYPTO_cbc128_decrypt(in, out, len, &amp;dat-&gt;ks, dat-&gt;iv, dat-&gt;block);
+
+    return 1;
+}
+
+static int aes_ecb_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                          const unsigned char *in, size_t len)
+{
+    size_t i;
+
+    if (len &lt; AES_BLOCK_SIZE)
+        return 1;
+
+    for (i = 0, len -= AES_BLOCK_SIZE; i &lt;= len; i += AES_BLOCK_SIZE)
+        (*dat-&gt;block) (in + i, out + i, &amp;dat-&gt;ks);
+
+    return 1;
+}
+
+static int aes_ofb_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                          const unsigned char *in, size_t len)
+{
+    int num = dat-&gt;num;
+    CRYPTO_ofb128_encrypt(in, out, len, &amp;dat-&gt;ks, dat-&gt;iv, &amp;num, dat-&gt;block);
+    dat-&gt;num = num;
+
+    return 1;
+}
+
+static int aes_cfb_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                          const unsigned char *in, size_t len)
+{
+    int num = dat-&gt;num;
+    CRYPTO_cfb128_encrypt(in, out, len, &amp;dat-&gt;ks, dat-&gt;iv, &amp;num, dat-&gt;enc,
+                          dat-&gt;block);
+    dat-&gt;num = num;
+
+    return 1;
+}
+
+static int aes_cfb8_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                           const unsigned char *in, size_t len)
+{
+    int num = dat-&gt;num;
+    CRYPTO_cfb128_8_encrypt(in, out, len, &amp;dat-&gt;ks, dat-&gt;iv, &amp;num, dat-&gt;enc,
+                            dat-&gt;block);
+    dat-&gt;num = num;
+
+    return 1;
+}
+
+static int aes_cfb1_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                           const unsigned char *in, size_t len)
+{
+    int num = dat-&gt;num;
+
+    if ((dat-&gt;flags &amp; EVP_CIPH_FLAG_LENGTH_BITS) != 0) {
+        CRYPTO_cfb128_1_encrypt(in, out, len, &amp;dat-&gt;ks, dat-&gt;iv, &amp;num,
+                                dat-&gt;enc, dat-&gt;block);
+        dat-&gt;num = num;
+        return 1;
+    }
+
+    while (len &gt;= MAXBITCHUNK) {
+        CRYPTO_cfb128_1_encrypt(in, out, MAXBITCHUNK * 8, &amp;dat-&gt;ks,
+                                dat-&gt;iv, &amp;num, dat-&gt;enc, dat-&gt;block);
+        len -= MAXBITCHUNK;
+        out += MAXBITCHUNK;
+        in  += MAXBITCHUNK;
+    }
+    if (len)
+        CRYPTO_cfb128_1_encrypt(in, out, len * 8, &amp;dat-&gt;ks, dat-&gt;iv, &amp;num,
+                                dat-&gt;enc, dat-&gt;block);
+
+    dat-&gt;num = num;
+
+    return 1;
+}
+
+static int aes_ctr_cipher(PROV_AES_KEY *dat, unsigned char *out,
+                          const unsigned char *in, size_t len)
+{
+    unsigned int num = dat-&gt;num;
+
+    if (dat-&gt;stream.ctr)
+        CRYPTO_ctr128_encrypt_ctr32(in, out, len, &amp;dat-&gt;ks, dat-&gt;iv, dat-&gt;buf,
+                                    &amp;num, dat-&gt;stream.ctr);
+    else
+        CRYPTO_ctr128_encrypt(in, out, len, &amp;dat-&gt;ks, dat-&gt;iv, dat-&gt;buf,
+                              &amp;num, dat-&gt;block);
+    dat-&gt;num = num;
+
+    return 1;
+}
+
+BLOCK_CIPHER_generic_prov(cbc)
+BLOCK_CIPHER_generic_prov(ecb)
+BLOCK_CIPHER_generic_prov(ofb)
+BLOCK_CIPHER_generic_prov(cfb)
+BLOCK_CIPHER_generic_prov(cfb1)
+BLOCK_CIPHER_generic_prov(cfb8)
+BLOCK_CIPHER_generic_prov(ctr)
+
diff --git a/providers/common/ciphers/block.c b/providers/common/ciphers/block.c
new file mode 100644
index 0000000..03aa429
--- /dev/null
+++ b/providers/common/ciphers/block.c
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;string.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/err.h&gt;
+#include &quot;ciphers_locl.h&quot;
+#include &lt;assert.h&gt;
+#include &quot;internal/providercommonerr.h&quot;
+
+/*
+ * Fills a single block of buffered data from the input, and returns the amount
+ * of data remaining in the input that is a multiple of the blocksize. The buffer
+ * is only filled if it already has some data in it, isn't full already or we
+ * don't have at least one block in the input.
+ *
+ * buf: a buffer of blocksize bytes
+ * buflen: contains the amount of data already in buf on entry. Updated with the
+ *         amount of data in buf at the end. On entry *buflen must always be
+ *         less than the blocksize
+ * blocksize: size of a block. Must be greater than 0 and a power of 2
+ * in: pointer to a pointer containing the input data
+ * inlen: amount of input data available
+ *
+ * On return buf is filled with as much data as possible up to a full block,
+ * *buflen is updated containing the amount of data in buf. *in is updated to
+ * the new location where input data should be read from, *inlen is updated with
+ * the remaining amount of data in *in. Returns the largest value &lt;= *inlen
+ * which is a multiple of the blocksize.
+ */
+size_t fillblock(unsigned char *buf, size_t *buflen, size_t blocksize,
+                 const unsigned char **in, size_t *inlen)
+{
+    size_t blockmask = ~(blocksize - 1);
+
+    assert(*buflen &lt;= blocksize);
+    assert(blocksize &gt; 0 &amp;&amp; (blocksize &amp; (blocksize - 1)) == 0);
+
+    if (*buflen != blocksize &amp;&amp; (*buflen != 0 || *inlen &lt; blocksize)) {
+        size_t bufremain = blocksize - *buflen;
+
+        if (*inlen &lt; bufremain)
+            bufremain = *inlen;
+        memcpy(buf + *buflen, *in, bufremain);
+        *in += bufremain;
+        *inlen -= bufremain;
+        *buflen += bufremain;
+    }
+
+    return *inlen &amp; blockmask;
+}
+
+/*
+ * Fills the buffer with trailing data from an encryption/decryption that didn't
+ * fit into a full block.
+ */
+int trailingdata(unsigned char *buf, size_t *buflen, size_t blocksize,
+                 const unsigned char **in, size_t *inlen)
+{
+    if (*inlen == 0)
+        return 1;
+
+    if (*buflen + *inlen &gt; blocksize) {
+        PROVerr(PROV_F_TRAILINGDATA, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    memcpy(buf + *buflen, *in, *inlen);
+    *buflen += *inlen;
+    *inlen = 0;
+
+    return 1;
+}
+
+/* Pad the final block for encryption */
+void padblock(unsigned char *buf, size_t *buflen, size_t blocksize)
+{
+    size_t i;
+    unsigned char pad = (unsigned char)(blocksize - *buflen);
+
+    for (i = *buflen; i &lt; blocksize; i++)
+        buf[i] = pad;
+}
+
+int unpadblock(unsigned char *buf, size_t *buflen, size_t blocksize)
+{
+    size_t pad, i;
+    size_t len = *buflen;
+
+    if(len != blocksize) {
+        PROVerr(PROV_F_UNPADBLOCK, ERR_R_INTERNAL_ERROR);
+        return 0;
+    }
+
+    /*
+     * The following assumes that the ciphertext has been authenticated.
+     * Otherwise it provides a padding oracle.
+     */
+    pad = buf[blocksize - 1];
+    if (pad == 0 || pad &gt; blocksize) {
+        PROVerr(PROV_F_UNPADBLOCK, PROV_R_BAD_DECRYPT);
+        return 0;
+    }
+    for (i = 0; i &lt; pad; i++) {
+        if (buf[--len] != pad) {
+            PROVerr(PROV_F_UNPADBLOCK, PROV_R_BAD_DECRYPT);
+            return 0;
+        }
+    }
+    *buflen = len;
+    return 1;
+}
diff --git a/providers/common/ciphers/build.info b/providers/common/ciphers/build.info
new file mode 100644
index 0000000..f4ff2ce
--- /dev/null
+++ b/providers/common/ciphers/build.info
@@ -0,0 +1,4 @@
+LIBS=../../../libcrypto
+SOURCE[../../../libcrypto]=\
+        block.c aes.c aes_basic.c
+INCLUDE[../../../libcrypto]=. ../../../crypto
diff --git a/providers/common/ciphers/ciphers_locl.h b/providers/common/ciphers/ciphers_locl.h
new file mode 100644
index 0000000..a874bbf
--- /dev/null
+++ b/providers/common/ciphers/ciphers_locl.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/aes.h&gt;
+#include &lt;openssl/modes.h&gt;
+
+typedef struct prov_aes_cipher_st PROV_AES_CIPHER;
+
+typedef struct prov_aes_key_st {
+    union {
+        double align;
+        AES_KEY ks;
+    } ks;
+    block128_f block;
+    union {
+        cbc128_f cbc;
+        ctr128_f ctr;
+    } stream;
+
+    /* Platform specific data */
+    union {
+        int dummy;
+#if defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__)
+        struct {
+            union {
+                double align;
+                /*-
+                 * KM-AES parameter block - begin
+                 * (see z/Architecture Principles of Operation &gt;= SA22-7832-06)
+                 */
+                struct {
+                    unsigned char k[32];
+                } km;
+                /* KM-AES parameter block - end */
+                /*-
+                 * KMO-AES/KMF-AES parameter block - begin
+                 * (see z/Architecture Principles of Operation &gt;= SA22-7832-08)
+                 */
+                struct {
+                    unsigned char cv[16];
+                    unsigned char k[32];
+                } kmo_kmf;
+                /* KMO-AES/KMF-AES parameter block - end */
+            } param;
+            unsigned int fc;
+            int res;
+        } s390x;
+#endif /* defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__) */
+    } plat;
+
+    /* The cipher functions we are going to use */
+    const PROV_AES_CIPHER *ciph;
+
+    /* The mode that we are using */
+    int mode;
+
+    /* Set to 1 if we are encrypting or 0 otherwise */
+    int enc;
+
+    unsigned char iv[AES_BLOCK_SIZE];
+
+    /*
+     * num contains the number of bytes of |iv| which are valid for modes that
+     * manage partial blocks themselves.
+     */
+    size_t num;
+
+    /* Buffer of partial blocks processed via update calls */
+    unsigned char buf[AES_BLOCK_SIZE];
+
+    /* Number of bytes in buf */
+    size_t bufsz;
+
+    uint64_t flags;
+
+    size_t keylen;
+
+    /* Whether padding should be used or not */
+    unsigned int pad : 1;
+} PROV_AES_KEY;
+
+struct prov_aes_cipher_st {
+  int (*init)(PROV_AES_KEY *dat, const uint8_t *key, size_t keylen);
+  int (*cipher)(PROV_AES_KEY *dat, uint8_t *out, const uint8_t *in,
+                size_t inl);
+};
+
+const PROV_AES_CIPHER *PROV_AES_CIPHER_ecb(size_t keylen);
+const PROV_AES_CIPHER *PROV_AES_CIPHER_cbc(size_t keylen);
+const PROV_AES_CIPHER *PROV_AES_CIPHER_ofb(size_t keylen);
+const PROV_AES_CIPHER *PROV_AES_CIPHER_cfb(size_t keylen);
+const PROV_AES_CIPHER *PROV_AES_CIPHER_cfb1(size_t keylen);
+const PROV_AES_CIPHER *PROV_AES_CIPHER_cfb8(size_t keylen);
+const PROV_AES_CIPHER *PROV_AES_CIPHER_ctr(size_t keylen);
+
+size_t fillblock(unsigned char *buf, size_t *buflen, size_t blocksize,
+                 const unsigned char **in, size_t *inlen);
+int trailingdata(unsigned char *buf, size_t *buflen, size_t blocksize,
+                 const unsigned char **in, size_t *inlen);
+void padblock(unsigned char *buf, size_t *buflen, size_t blocksize);
+int unpadblock(unsigned char *buf, size_t *buflen, size_t blocksize);
diff --git a/providers/common/digests/sha2.c b/providers/common/digests/sha2.c
index 3698046..c9f616d 100644
--- a/providers/common/digests/sha2.c
+++ b/providers/common/digests/sha2.c
@@ -10,6 +10,7 @@
 #include &lt;openssl/sha.h&gt;
 #include &lt;openssl/crypto.h&gt;
 #include &lt;openssl/core_numbers.h&gt;
+#include &quot;internal/provider_algs.h&quot;
 
 /*
  * Forward declaration of everything implemented here.  This is not strictly
@@ -73,11 +74,10 @@ static size_t sha256_block_size(void)
     return SHA256_CBLOCK;
 }
 
-extern const OSSL_DISPATCH sha256_functions[];
 const OSSL_DISPATCH sha256_functions[] = {
     { OSSL_FUNC_DIGEST_NEWCTX, (void (*)(void))sha256_newctx },
     { OSSL_FUNC_DIGEST_INIT, (void (*)(void))SHA256_Init },
-    { OSSL_FUNC_DIGEST_UPDDATE, (void (*)(void))SHA256_Update },
+    { OSSL_FUNC_DIGEST_UPDATE, (void (*)(void))SHA256_Update },
     { OSSL_FUNC_DIGEST_FINAL, (void (*)(void))sha256_final },
     { OSSL_FUNC_DIGEST_FREECTX, (void (*)(void))sha256_freectx },
     { OSSL_FUNC_DIGEST_DUPCTX, (void (*)(void))sha256_dupctx },
diff --git a/providers/common/include/internal/provider_algs.h b/providers/common/include/internal/provider_algs.h
new file mode 100644
index 0000000..dd9211b
--- /dev/null
+++ b/providers/common/include/internal/provider_algs.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+/* Digests */
+extern const OSSL_DISPATCH sha256_functions[];
+
+/* Ciphers */
+extern const OSSL_DISPATCH aes256ecb_functions[];
+extern const OSSL_DISPATCH aes192ecb_functions[];
+extern const OSSL_DISPATCH aes128ecb_functions[];
+extern const OSSL_DISPATCH aes256cbc_functions[];
+extern const OSSL_DISPATCH aes192cbc_functions[];
+extern const OSSL_DISPATCH aes128cbc_functions[];
+extern const OSSL_DISPATCH aes256ofb_functions[];
+extern const OSSL_DISPATCH aes192ofb_functions[];
+extern const OSSL_DISPATCH aes128ofb_functions[];
+extern const OSSL_DISPATCH aes256cfb_functions[];
+extern const OSSL_DISPATCH aes192cfb_functions[];
+extern const OSSL_DISPATCH aes128cfb_functions[];
+extern const OSSL_DISPATCH aes256cfb1_functions[];
+extern const OSSL_DISPATCH aes192cfb1_functions[];
+extern const OSSL_DISPATCH aes128cfb1_functions[];
+extern const OSSL_DISPATCH aes256cfb8_functions[];
+extern const OSSL_DISPATCH aes192cfb8_functions[];
+extern const OSSL_DISPATCH aes128cfb8_functions[];
+extern const OSSL_DISPATCH aes256ctr_functions[];
+extern const OSSL_DISPATCH aes192ctr_functions[];
+extern const OSSL_DISPATCH aes128ctr_functions[];
diff --git a/fuzz/corpora/ct/e53301b7bba90f14da5195be2e47ec3f88924694 b/providers/common/include/internal/providercommon.h
similarity index 100%
copy from fuzz/corpora/ct/e53301b7bba90f14da5195be2e47ec3f88924694
copy to providers/common/include/internal/providercommon.h
diff --git a/providers/common/include/internal/providercommonerr.h b/providers/common/include/internal/providercommonerr.h
new file mode 100644
index 0000000..609fd5b
--- /dev/null
+++ b/providers/common/include/internal/providercommonerr.h
@@ -0,0 +1,54 @@
+/*
+ * Generated by util/mkerr.pl DO NOT EDIT
+ * Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef HEADER_PROVERR_H
+# define HEADER_PROVERR_H
+
+# ifndef HEADER_SYMHACKS_H
+#  include &lt;openssl/symhacks.h&gt;
+# endif
+
+# ifdef  __cplusplus
+extern &quot;C&quot;
+# endif
+int ERR_load_PROV_strings(void);
+
+/*
+ * PROV function codes.
+ */
+# define PROV_F_AESNI_INIT_KEY                            101
+# define PROV_F_AES_BLOCK_FINAL                           102
+# define PROV_F_AES_BLOCK_UPDATE                          103
+# define PROV_F_AES_CIPHER                                104
+# define PROV_F_AES_CTX_GET_PARAMS                        105
+# define PROV_F_AES_CTX_SET_PARAMS                        106
+# define PROV_F_AES_DINIT                                 107
+# define PROV_F_AES_DUPCTX                                108
+# define PROV_F_AES_EINIT                                 109
+# define PROV_F_AES_INIT_KEY                              110
+# define PROV_F_AES_STREAM_UPDATE                         111
+# define PROV_F_AES_T4_INIT_KEY                           112
+# define PROV_F_PROV_AES_KEY_GENERIC_INIT                 113
+# define PROV_F_TRAILINGDATA                              114
+# define PROV_F_UNPADBLOCK                                100
+
+/*
+ * PROV reason codes.
+ */
+# define PROV_R_AES_KEY_SETUP_FAILED                      101
+# define PROV_R_BAD_DECRYPT                               100
+# define PROV_R_CIPHER_OPERATION_FAILED                   102
+# define PROV_R_FAILED_TO_GET_PARAMETER                   103
+# define PROV_R_FAILED_TO_SET_PARAMETER                   104
+# define PROV_R_INVALID_KEYLEN                            105
+# define PROV_R_OUTPUT_BUFFER_TOO_SMALL                   106
+# define PROV_R_WRONG_FINAL_BLOCK_LENGTH                  107
+
+#endif
diff --git a/providers/common/provider_err.c b/providers/common/provider_err.c
new file mode 100644
index 0000000..e6b577f
--- /dev/null
+++ b/providers/common/provider_err.c
@@ -0,0 +1,67 @@
+/*
+ * Generated by util/mkerr.pl DO NOT EDIT
+ * Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/err.h&gt;
+#include &quot;internal/providercommonerr.h&quot;
+
+#ifndef OPENSSL_NO_ERR
+
+static const ERR_STRING_DATA PROV_str_functs[] = {
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AESNI_INIT_KEY, 0), &quot;aesni_init_key&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_BLOCK_FINAL, 0), &quot;aes_block_final&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_BLOCK_UPDATE, 0), &quot;aes_block_update&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_CIPHER, 0), &quot;aes_cipher&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_CTX_GET_PARAMS, 0),
+     &quot;aes_ctx_get_params&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_CTX_SET_PARAMS, 0),
+     &quot;aes_ctx_set_params&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_DINIT, 0), &quot;aes_dinit&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_DUPCTX, 0), &quot;aes_dupctx&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_EINIT, 0), &quot;aes_einit&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_INIT_KEY, 0), &quot;aes_init_key&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_STREAM_UPDATE, 0), &quot;aes_stream_update&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_AES_T4_INIT_KEY, 0), &quot;aes_t4_init_key&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_PROV_AES_KEY_GENERIC_INIT, 0),
+     &quot;PROV_AES_KEY_generic_init&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_TRAILINGDATA, 0), &quot;trailingdata&quot;},
+    {ERR_PACK(ERR_LIB_PROV, PROV_F_UNPADBLOCK, 0), &quot;unpadblock&quot;},
+    {0, NULL}
+};
+
+static const ERR_STRING_DATA PROV_str_reasons[] = {
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_AES_KEY_SETUP_FAILED),
+    &quot;aes key setup failed&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_BAD_DECRYPT), &quot;bad decrypt&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_CIPHER_OPERATION_FAILED),
+    &quot;cipher operation failed&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_FAILED_TO_GET_PARAMETER),
+    &quot;failed to get parameter&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_FAILED_TO_SET_PARAMETER),
+    &quot;failed to set parameter&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_KEYLEN), &quot;invalid keylen&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_OUTPUT_BUFFER_TOO_SMALL),
+    &quot;output buffer too small&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_WRONG_FINAL_BLOCK_LENGTH),
+    &quot;wrong final block length&quot;},
+    {0, NULL}
+};
+
+#endif
+
+int ERR_load_PROV_strings(void)
+{
+#ifndef OPENSSL_NO_ERR
+    if (ERR_func_error_string(PROV_str_functs[0].error) == NULL) {
+        ERR_load_strings_const(PROV_str_functs);
+        ERR_load_strings_const(PROV_str_reasons);
+    }
+#endif
+    return 1;
+}
diff --git a/providers/default/defltprov.c b/providers/default/defltprov.c
index 9b52429..cba2dcc 100644
--- a/providers/default/defltprov.c
+++ b/providers/default/defltprov.c
@@ -13,6 +13,7 @@
 #include &lt;openssl/core_numbers.h&gt;
 #include &lt;openssl/core_names.h&gt;
 #include &lt;openssl/params.h&gt;
+#include &quot;internal/provider_algs.h&quot;
 
 /* Functions provided by the core */
 static OSSL_core_get_param_types_fn *c_get_param_types = NULL;
@@ -49,13 +50,36 @@ static int deflt_get_params(const OSSL_PROVIDER *prov,
     return 1;
 }
 
-extern const OSSL_DISPATCH sha256_functions[];
-
 static const OSSL_ALGORITHM deflt_digests[] = {
     { &quot;SHA256&quot;, &quot;default=yes&quot;, sha256_functions },
     { NULL, NULL, NULL }
 };
 
+static const OSSL_ALGORITHM deflt_ciphers[] = {
+    { &quot;AES-256-ECB&quot;, &quot;default=yes&quot;, aes256ecb_functions },
+    { &quot;AES-192-ECB&quot;, &quot;default=yes&quot;, aes192ecb_functions },
+    { &quot;AES-128-ECB&quot;, &quot;default=yes&quot;, aes128ecb_functions },
+    { &quot;AES-256-CBC&quot;, &quot;default=yes&quot;, aes256cbc_functions },
+    { &quot;AES-192-CBC&quot;, &quot;default=yes&quot;, aes192cbc_functions },
+    { &quot;AES-128-CBC&quot;, &quot;default=yes&quot;, aes128cbc_functions },
+    { &quot;AES-256-OFB&quot;, &quot;default=yes&quot;, aes256ofb_functions },
+    { &quot;AES-192-OFB&quot;, &quot;default=yes&quot;, aes192ofb_functions },
+    { &quot;AES-128-OFB&quot;, &quot;default=yes&quot;, aes128ofb_functions },
+    { &quot;AES-256-CFB&quot;, &quot;default=yes&quot;, aes256cfb_functions },
+    { &quot;AES-192-CFB&quot;, &quot;default=yes&quot;, aes192cfb_functions },
+    { &quot;AES-128-CFB&quot;, &quot;default=yes&quot;, aes128cfb_functions },
+    { &quot;AES-256-CFB1&quot;, &quot;default=yes&quot;, aes256cfb1_functions },
+    { &quot;AES-192-CFB1&quot;, &quot;default=yes&quot;, aes192cfb1_functions },
+    { &quot;AES-128-CFB1&quot;, &quot;default=yes&quot;, aes128cfb1_functions },
+    { &quot;AES-256-CFB8&quot;, &quot;default=yes&quot;, aes256cfb8_functions },
+    { &quot;AES-192-CFB8&quot;, &quot;default=yes&quot;, aes192cfb8_functions },
+    { &quot;AES-128-CFB8&quot;, &quot;default=yes&quot;, aes128cfb8_functions },
+    { &quot;AES-256-CTR&quot;, &quot;default=yes&quot;, aes256ctr_functions },
+    { &quot;AES-192-CTR&quot;, &quot;default=yes&quot;, aes192ctr_functions },
+    { &quot;AES-128-CTR&quot;, &quot;default=yes&quot;, aes128ctr_functions },
+    { NULL, NULL, NULL }
+};
+
 static const OSSL_ALGORITHM *deflt_query(OSSL_PROVIDER *prov,
                                          int operation_id,
                                          int *no_cache)
@@ -64,6 +88,8 @@ static const OSSL_ALGORITHM *deflt_query(OSSL_PROVIDER *prov,
     switch (operation_id) {
     case OSSL_OP_DIGEST:
         return deflt_digests;
+    case OSSL_OP_CIPHER:
+        return deflt_ciphers;
     }
     return NULL;
 }
diff --git a/providers/legacy/digests/md2.c b/providers/legacy/digests/md2.c
index c941dd7..017a511 100644
--- a/providers/legacy/digests/md2.c
+++ b/providers/legacy/digests/md2.c
@@ -54,7 +54,7 @@ extern const OSSL_DISPATCH md2_functions[];
 const OSSL_DISPATCH md2_functions[] = {
     { OSSL_FUNC_DIGEST_NEWCTX, (void (*)(void))md2_newctx },
     { OSSL_FUNC_DIGEST_INIT, (void (*)(void))MD2_Init },
-    { OSSL_FUNC_DIGEST_UPDDATE, (void (*)(void))MD2_Update },
+    { OSSL_FUNC_DIGEST_UPDATE, (void (*)(void))MD2_Update },
     { OSSL_FUNC_DIGEST_FINAL, (void (*)(void))md2_final },
     { OSSL_FUNC_DIGEST_FREECTX, (void (*)(void))md2_freectx },
     { OSSL_FUNC_DIGEST_DUPCTX, (void (*)(void))md2_dupctx },
diff --git a/util/ck_errf.pl b/util/ck_errf.pl
index cc7224a..681535e 100755
--- a/util/ck_errf.pl
+++ b/util/ck_errf.pl
@@ -72,7 +72,8 @@ if ( $internal ) {
     die &quot;Extra parameters given.\n&quot; if @ARGV;
     $config = &quot;crypto/err/openssl.ec&quot; unless defined $config;
     @source = ( glob('crypto/*.c'), glob('crypto/*/*.c'),
-                glob('ssl/*.c'), glob('ssl/*/*.c') );
+                glob('ssl/*.c'), glob('ssl/*/*.c'), glob('providers/*.c'),
+                glob('providers/*/*.c'), glob('providers/*/*/*.c') );
 } else {
     die &quot;Configuration file not given.\nSee '$0 -help' for information\n&quot;
         unless defined $config;
diff --git a/util/libcrypto.num b/util/libcrypto.num
index c14523e..b9be349 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4796,3 +4796,6 @@ EVP_MD_fetch                            4743	3_0_0	EXIST::FUNCTION:
 EVP_set_default_properties              4744	3_0_0	EXIST::FUNCTION:
 OSSL_PARAM_construct_end                4745	3_0_0	EXIST::FUNCTION:
 EC_GROUP_check_named_curve              4746	3_0_0	EXIST::FUNCTION:EC
+EVP_CIPHER_upref                        4747	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_fetch                        4748	3_0_0	EXIST::FUNCTION:
+EVP_CIPHER_mode                         4749	3_0_0	EXIST::FUNCTION:
diff --git a/util/mkerr.pl b/util/mkerr.pl
index 7139ee3..f1d9b39 100755
--- a/util/mkerr.pl
+++ b/util/mkerr.pl
@@ -114,7 +114,8 @@ if ( $internal ) {
     die &quot;Cannot mix -internal and -static\n&quot; if $static;
     die &quot;Extra parameters given.\n&quot; if @ARGV;
     @source = ( glob('crypto/*.c'), glob('crypto/*/*.c'),
-                glob('ssl/*.c'), glob('ssl/*/*.c') );
+                glob('ssl/*.c'), glob('ssl/*/*.c'), glob('providers/*.c'),
+                glob('providers/*/*.c'), glob('providers/*/*/*.c') );
 } else {
     die &quot;-module isn't useful without -internal\n&quot; if scalar keys %modules &gt; 0;
     @source = @ARGV;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022866.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="022868.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22867">[ date ]</a>
              <a href="thread.html#22867">[ thread ]</a>
              <a href="subject.html#22867">[ subject ]</a>
              <a href="author.html#22867">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
