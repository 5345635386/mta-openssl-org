<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  OpenSSL_1_1_1-stable update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-September/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20OpenSSL_1_1_1-stable%20update&In-Reply-To=%3C1567844911.574627.16881.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024893.html">
   <LINK REL="Next"  HREF="024901.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  OpenSSL_1_1_1-stable update</H1>
    <B>bernd.edlinger at hotmail.de</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20OpenSSL_1_1_1-stable%20update&In-Reply-To=%3C1567844911.574627.16881.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  OpenSSL_1_1_1-stable update">bernd.edlinger at hotmail.de
       </A><BR>
    <I>Sat Sep  7 08:28:31 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="024893.html">[openssl]  OpenSSL_1_1_1-stable update
</A></li>
        <LI>Next message: <A HREF="024901.html">[openssl]  OpenSSL_1_1_1-stable update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24897">[ date ]</a>
              <a href="thread.html#24897">[ thread ]</a>
              <a href="subject.html#24897">[ subject ]</a>
              <a href="author.html#24897">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch OpenSSL_1_1_1-stable has been updated
       via  87bea6550ae0dda7c40937cff2e86cc2b0b09491 (commit)
      from  a6186f39802f94937a46f7a41ef0c86b6334b592 (commit)


- Log -----------------------------------------------------------------
commit 87bea6550ae0dda7c40937cff2e86cc2b0b09491
Author: Bernd Edlinger &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">bernd.edlinger at hotmail.de</A>&gt;
Date:   Fri Aug 23 10:17:31 2019 +0200

    Remove x86/x86_64 BSAES and AES_ASM support
    
    This leaves VPAES and AESNI support.
    The VPAES performance is comparable but BSAES is not
    completely constant time. There are table lookups
    using secret key data in AES_set_encrypt/decrypt_key
    and in ctr mode short data uses the non-constant
    time AES_encrypt function instead of bit-slicing.
    Furthermore the AES_ASM is by far outperformed
    by recent GCC versions.
    Since BSAES calls back to AES_ASM for short
    data blocks the performance on those is also
    worse than the pure software implementaion.
    
    Fixes: #9640
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9675">https://github.com/openssl/openssl/pull/9675</A>)

-----------------------------------------------------------------------

Summary of changes:
 Configurations/00-base-templates.conf |    4 +-
 crypto/aes/asm/aes-586.pl             | 3000 ------------------------------
 crypto/aes/asm/aes-x86_64.pl          | 2916 -----------------------------
 crypto/aes/asm/bsaes-x86_64.pl        | 3239 ---------------------------------
 crypto/evp/e_aes.c                    |    2 +-
 5 files changed, 3 insertions(+), 9158 deletions(-)
 delete mode 100755 crypto/aes/asm/aes-586.pl
 delete mode 100755 crypto/aes/asm/aes-x86_64.pl
 delete mode 100644 crypto/aes/asm/bsaes-x86_64.pl

diff --git a/Configurations/00-base-templates.conf b/Configurations/00-base-templates.conf
index 5fd995cb33..e01dc63a8b 100644
--- a/Configurations/00-base-templates.conf
+++ b/Configurations/00-base-templates.conf
@@ -198,7 +198,7 @@ my %targets=(
 	bn_asm_src	=&gt; &quot;bn-586.s co-586.s x86-mont.s x86-gf2m.s&quot;,
 	ec_asm_src	=&gt; &quot;ecp_nistz256.c ecp_nistz256-x86.s&quot;,
 	des_asm_src	=&gt; &quot;des-586.s crypt586.s&quot;,
-	aes_asm_src	=&gt; &quot;aes-586.s vpaes-x86.s aesni-x86.s&quot;,
+	aes_asm_src	=&gt; &quot;aes_core.c aes_cbc.c vpaes-x86.s aesni-x86.s&quot;,
 	bf_asm_src	=&gt; &quot;bf-586.s&quot;,
 	md5_asm_src	=&gt; &quot;md5-586.s&quot;,
 	cast_asm_src	=&gt; &quot;cast-586.s&quot;,
@@ -223,7 +223,7 @@ my %targets=(
 	cpuid_asm_src   =&gt; &quot;x86_64cpuid.s&quot;,
 	bn_asm_src      =&gt; &quot;asm/x86_64-gcc.c x86_64-mont.s x86_64-mont5.s x86_64-gf2m.s rsaz_exp.c rsaz-x86_64.s rsaz-avx2.s&quot;,
 	ec_asm_src      =&gt; &quot;ecp_nistz256.c ecp_nistz256-x86_64.s x25519-x86_64.s&quot;,
-	aes_asm_src     =&gt; &quot;aes-x86_64.s vpaes-x86_64.s bsaes-x86_64.s aesni-x86_64.s aesni-sha1-x86_64.s aesni-sha256-x86_64.s aesni-mb-x86_64.s&quot;,
+	aes_asm_src     =&gt; &quot;aes_core.c aes_cbc.c vpaes-x86_64.s aesni-x86_64.s aesni-sha1-x86_64.s aesni-sha256-x86_64.s aesni-mb-x86_64.s&quot;,
 	md5_asm_src     =&gt; &quot;md5-x86_64.s&quot;,
 	sha1_asm_src    =&gt; &quot;sha1-x86_64.s sha256-x86_64.s sha512-x86_64.s sha1-mb-x86_64.s sha256-mb-x86_64.s&quot;,
 	rc4_asm_src     =&gt; &quot;rc4-x86_64.s rc4-md5-x86_64.s&quot;,
diff --git a/crypto/aes/asm/aes-586.pl b/crypto/aes/asm/aes-586.pl
deleted file mode 100755
index 29059edf8b..0000000000
--- a/crypto/aes/asm/aes-586.pl
+++ /dev/null
@@ -1,3000 +0,0 @@
-#! /usr/bin/env perl
-# Copyright 2004-2016 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
-
-#
-# ====================================================================
-# Written by Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt; for the OpenSSL
-# project. The module is, however, dual licensed under OpenSSL and
-# CRYPTOGAMS licenses depending on where you obtain it. For further
-# details see <A HREF="http://www.openssl.org/~appro/cryptogams/.">http://www.openssl.org/~appro/cryptogams/.</A>
-# ====================================================================
-#
-# Version 4.3.
-#
-# You might fail to appreciate this module performance from the first
-# try. If compared to &quot;vanilla&quot; linux-ia32-icc target, i.e. considered
-# to be *the* best Intel C compiler without -KPIC, performance appears
-# to be virtually identical... But try to re-configure with shared
-# library support... Aha! Intel compiler &quot;suddenly&quot; lags behind by 30%
-# [on P4, more on others]:-) And if compared to position-independent
-# code generated by GNU C, this code performs *more* than *twice* as
-# fast! Yes, all this buzz about PIC means that unlike other hand-
-# coded implementations, this one was explicitly designed to be safe
-# to use even in shared library context... This also means that this
-# code isn't necessarily absolutely fastest &quot;ever,&quot; because in order
-# to achieve position independence an extra register has to be
-# off-loaded to stack, which affects the benchmark result.
-#
-# Special note about instruction choice. Do you recall RC4_INT code
-# performing poorly on P4? It might be the time to figure out why.
-# RC4_INT code implies effective address calculations in base+offset*4
-# form. Trouble is that it seems that offset scaling turned to be
-# critical path... At least eliminating scaling resulted in 2.8x RC4
-# performance improvement [as you might recall]. As AES code is hungry
-# for scaling too, I [try to] avoid the latter by favoring off-by-2
-# shifts and masking the result with 0xFF&lt;&lt;2 instead of &quot;boring&quot; 0xFF.
-#
-# As was shown by Dean Gaudet, the above note turned out to be
-# void. Performance improvement with off-by-2 shifts was observed on
-# intermediate implementation, which was spilling yet another register
-# to stack... Final offset*4 code below runs just a tad faster on P4,
-# but exhibits up to 10% improvement on other cores.
-#
-# Second version is &quot;monolithic&quot; replacement for aes_core.c, which in
-# addition to AES_[de|en]crypt implements AES_set_[de|en]cryption_key.
-# This made it possible to implement little-endian variant of the
-# algorithm without modifying the base C code. Motivating factor for
-# the undertaken effort was that it appeared that in tight IA-32
-# register window little-endian flavor could achieve slightly higher
-# Instruction Level Parallelism, and it indeed resulted in up to 15%
-# better performance on most recent &#181;-archs...
-#
-# Third version adds AES_cbc_encrypt implementation, which resulted in
-# up to 40% performance improvement of CBC benchmark results. 40% was
-# observed on P4 core, where &quot;overall&quot; improvement coefficient, i.e. if
-# compared to PIC generated by GCC and in CBC mode, was observed to be
-# as large as 4x:-) CBC performance is virtually identical to ECB now
-# and on some platforms even better, e.g. 17.6 &quot;small&quot; cycles/byte on
-# Opteron, because certain function prologues and epilogues are
-# effectively taken out of the loop...
-#
-# Version 3.2 implements compressed tables and prefetch of these tables
-# in CBC[!] mode. Former means that 3/4 of table references are now
-# misaligned, which unfortunately has negative impact on elder IA-32
-# implementations, Pentium suffered 30% penalty, PIII - 10%.
-#
-# Version 3.3 avoids L1 cache aliasing between stack frame and
-# S-boxes, and 3.4 - L1 cache aliasing even between key schedule. The
-# latter is achieved by copying the key schedule to controlled place in
-# stack. This unfortunately has rather strong impact on small block CBC
-# performance, ~2x deterioration on 16-byte block if compared to 3.3.
-#
-# Version 3.5 checks if there is L1 cache aliasing between user-supplied
-# key schedule and S-boxes and abstains from copying the former if
-# there is no. This allows end-user to consciously retain small block
-# performance by aligning key schedule in specific manner.
-#
-# Version 3.6 compresses Td4 to 256 bytes and prefetches it in ECB.
-#
-# Current ECB performance numbers for 128-bit key in CPU cycles per
-# processed byte [measure commonly used by AES benchmarkers] are:
-#
-#		small footprint		fully unrolled
-# P4		24			22
-# AMD K8	20			19
-# PIII		25			23
-# Pentium	81			78
-#
-# Version 3.7 reimplements outer rounds as &quot;compact.&quot; Meaning that
-# first and last rounds reference compact 256 bytes S-box. This means
-# that first round consumes a lot more CPU cycles and that encrypt
-# and decrypt performance becomes asymmetric. Encrypt performance
-# drops by 10-12%, while decrypt - by 20-25%:-( 256 bytes S-box is
-# aggressively pre-fetched.
-#
-# Version 4.0 effectively rolls back to 3.6 and instead implements
-# additional set of functions, _[x86|sse]_AES_[en|de]crypt_compact,
-# which use exclusively 256 byte S-box. These functions are to be
-# called in modes not concealing plain text, such as ECB, or when
-# we're asked to process smaller amount of data [or unconditionally
-# on hyper-threading CPU]. Currently it's called unconditionally from
-# AES_[en|de]crypt, which affects all modes, but CBC. CBC routine
-# still needs to be modified to switch between slower and faster
-# mode when appropriate... But in either case benchmark landscape
-# changes dramatically and below numbers are CPU cycles per processed
-# byte for 128-bit key.
-#
-#		ECB encrypt	ECB decrypt	CBC large chunk
-# P4		52[54]		83[95]		23
-# AMD K8	46[41]		66[70]		18
-# PIII		41[50]		60[77]		24
-# Core 2	31[36]		45[64]		18.5
-# Atom		76[100]		96[138]		60
-# Pentium	115		150		77
-#
-# Version 4.1 switches to compact S-box even in key schedule setup.
-#
-# Version 4.2 prefetches compact S-box in every SSE round or in other
-# words every cache-line is *guaranteed* to be accessed within ~50
-# cycles window. Why just SSE? Because it's needed on hyper-threading
-# CPU! Which is also why it's prefetched with 64 byte stride. Best
-# part is that it has no negative effect on performance:-)
-#
-# Version 4.3 implements switch between compact and non-compact block
-# functions in AES_cbc_encrypt depending on how much data was asked
-# to be processed in one stroke.
-#
-######################################################################
-# Timing attacks are classified in two classes: synchronous when
-# attacker consciously initiates cryptographic operation and collects
-# timing data of various character afterwards, and asynchronous when
-# malicious code is executed on same CPU simultaneously with AES,
-# instruments itself and performs statistical analysis of this data.
-#
-# As far as synchronous attacks go the root to the AES timing
-# vulnerability is twofold. Firstly, of 256 S-box elements at most 160
-# are referred to in single 128-bit block operation. Well, in C
-# implementation with 4 distinct tables it's actually as little as 40
-# references per 256 elements table, but anyway... Secondly, even
-# though S-box elements are clustered into smaller amount of cache-
-# lines, smaller than 160 and even 40, it turned out that for certain
-# plain-text pattern[s] or simply put chosen plain-text and given key
-# few cache-lines remain unaccessed during block operation. Now, if
-# attacker can figure out this access pattern, he can deduct the key
-# [or at least part of it]. The natural way to mitigate this kind of
-# attacks is to minimize the amount of cache-lines in S-box and/or
-# prefetch them to ensure that every one is accessed for more uniform
-# timing. But note that *if* plain-text was concealed in such way that
-# input to block function is distributed *uniformly*, then attack
-# wouldn't apply. Now note that some encryption modes, most notably
-# CBC, do mask the plain-text in this exact way [secure cipher output
-# is distributed uniformly]. Yes, one still might find input that
-# would reveal the information about given key, but if amount of
-# candidate inputs to be tried is larger than amount of possible key
-# combinations then attack becomes infeasible. This is why revised
-# AES_cbc_encrypt &quot;dares&quot; to switch to larger S-box when larger chunk
-# of data is to be processed in one stroke. The current size limit of
-# 512 bytes is chosen to provide same [diminishingly low] probability
-# for cache-line to remain untouched in large chunk operation with
-# large S-box as for single block operation with compact S-box and
-# surely needs more careful consideration...
-#
-# As for asynchronous attacks. There are two flavours: attacker code
-# being interleaved with AES on hyper-threading CPU at *instruction*
-# level, and two processes time sharing single core. As for latter.
-# Two vectors. 1. Given that attacker process has higher priority,
-# yield execution to process performing AES just before timer fires
-# off the scheduler, immediately regain control of CPU and analyze the
-# cache state. For this attack to be efficient attacker would have to
-# effectively slow down the operation by several *orders* of magnitude,
-# by ratio of time slice to duration of handful of AES rounds, which
-# unlikely to remain unnoticed. Not to mention that this also means
-# that he would spend correspondingly more time to collect enough
-# statistical data to mount the attack. It's probably appropriate to
-# say that if adversary reckons that this attack is beneficial and
-# risks to be noticed, you probably have larger problems having him
-# mere opportunity. In other words suggested code design expects you
-# to preclude/mitigate this attack by overall system security design.
-# 2. Attacker manages to make his code interrupt driven. In order for
-# this kind of attack to be feasible, interrupt rate has to be high
-# enough, again comparable to duration of handful of AES rounds. But
-# is there interrupt source of such rate? Hardly, not even 1Gbps NIC
-# generates interrupts at such raging rate...
-#
-# And now back to the former, hyper-threading CPU or more specifically
-# Intel P4. Recall that asynchronous attack implies that malicious
-# code instruments itself. And naturally instrumentation granularity
-# has be noticeably lower than duration of codepath accessing S-box.
-# Given that all cache-lines are accessed during that time that is.
-# Current implementation accesses *all* cache-lines within ~50 cycles
-# window, which is actually *less* than RDTSC latency on Intel P4!
-
-$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
-push(@INC,&quot;${dir}&quot;,&quot;${dir}../../perlasm&quot;);
-require &quot;x86asm.pl&quot;;
-
-$output = pop;
-open OUT,&quot;&gt;$output&quot;;
-*STDOUT=*OUT;
-
-&amp;asm_init($ARGV[0],$x86only = $ARGV[$#ARGV] eq &quot;386&quot;);
-&amp;static_label(&quot;AES_Te&quot;);
-&amp;static_label(&quot;AES_Td&quot;);
-
-$s0=&quot;eax&quot;;
-$s1=&quot;ebx&quot;;
-$s2=&quot;ecx&quot;;
-$s3=&quot;edx&quot;;
-$key=&quot;edi&quot;;
-$acc=&quot;esi&quot;;
-$tbl=&quot;ebp&quot;;
-
-# stack frame layout in _[x86|sse]_AES_* routines, frame is allocated
-# by caller
-$__ra=&amp;DWP(0,&quot;esp&quot;);	# return address
-$__s0=&amp;DWP(4,&quot;esp&quot;);	# s0 backing store
-$__s1=&amp;DWP(8,&quot;esp&quot;);	# s1 backing store
-$__s2=&amp;DWP(12,&quot;esp&quot;);	# s2 backing store
-$__s3=&amp;DWP(16,&quot;esp&quot;);	# s3 backing store
-$__key=&amp;DWP(20,&quot;esp&quot;);	# pointer to key schedule
-$__end=&amp;DWP(24,&quot;esp&quot;);	# pointer to end of key schedule
-$__tbl=&amp;DWP(28,&quot;esp&quot;);	# %ebp backing store
-
-# stack frame layout in AES_[en|crypt] routines, which differs from
-# above by 4 and overlaps by %ebp backing store
-$_tbl=&amp;DWP(24,&quot;esp&quot;);
-$_esp=&amp;DWP(28,&quot;esp&quot;);
-
-sub _data_word() { my $i; while(defined($i=shift)) { &amp;data_word($i,$i); } }
-
-$speed_limit=512;	# chunks smaller than $speed_limit are
-			# processed with compact routine in CBC mode
-$small_footprint=1;	# $small_footprint=1 code is ~5% slower [on
-			# recent &#181;-archs], but ~5 times smaller!
-			# I favor compact code to minimize cache
-			# contention and in hope to &quot;collect&quot; 5% back
-			# in real-life applications...
-
-$vertical_spin=0;	# shift &quot;vertically&quot; defaults to 0, because of
-			# its proof-of-concept status...
-# Note that there is no decvert(), as well as last encryption round is
-# performed with &quot;horizontal&quot; shifts. This is because this &quot;vertical&quot;
-# implementation [one which groups shifts on a given $s[i] to form a
-# &quot;column,&quot; unlike &quot;horizontal&quot; one, which groups shifts on different
-# $s[i] to form a &quot;row&quot;] is work in progress. It was observed to run
-# few percents faster on Intel cores, but not AMD. On AMD K8 core it's
-# whole 12% slower:-( So we face a trade-off... Shall it be resolved
-# some day? Till then the code is considered experimental and by
-# default remains dormant...
-
-sub encvert()
-{ my ($<A HREF="../../../mailman/listinfo/openssl-commits.html">te, at s</A>) = @_;
-  my ($v0,$v1) = ($acc,$key);
-
-	&amp;mov	($v0,$s[3]);				# copy s3
-	&amp;mov	(&amp;DWP(4,&quot;esp&quot;),$s[2]);			# save s2
-	&amp;mov	($v1,$s[0]);				# copy s0
-	&amp;mov	(&amp;DWP(8,&quot;esp&quot;),$s[1]);			# save s1
-
-	&amp;movz	($s[2],&amp;HB($s[0]));
-	&amp;and	($s[0],0xFF);
-	&amp;mov	($s[0],&amp;DWP(0,$te,$s[0],8));		# s0&gt;&gt;0
-	&amp;shr	($v1,16);
-	&amp;mov	($s[3],&amp;DWP(3,$te,$s[2],8));		# s0&gt;&gt;8
-	&amp;movz	($s[1],&amp;HB($v1));
-	&amp;and	($v1,0xFF);
-	&amp;mov	($s[2],&amp;DWP(2,$te,$v1,8));		# s0&gt;&gt;16
-	 &amp;mov	($v1,$v0);
-	&amp;mov	($s[1],&amp;DWP(1,$te,$s[1],8));		# s0&gt;&gt;24
-
-	&amp;and	($v0,0xFF);
-	&amp;xor	($s[3],&amp;DWP(0,$te,$v0,8));		# s3&gt;&gt;0
-	&amp;movz	($v0,&amp;HB($v1));
-	&amp;shr	($v1,16);
-	&amp;xor	($s[2],&amp;DWP(3,$te,$v0,8));		# s3&gt;&gt;8
-	&amp;movz	($v0,&amp;HB($v1));
-	&amp;and	($v1,0xFF);
-	&amp;xor	($s[1],&amp;DWP(2,$te,$v1,8));		# s3&gt;&gt;16
-	 &amp;mov	($v1,&amp;DWP(4,&quot;esp&quot;));			# restore s2
-	&amp;xor	($s[0],&amp;DWP(1,$te,$v0,8));		# s3&gt;&gt;24
-
-	&amp;mov	($v0,$v1);
-	&amp;and	($v1,0xFF);
-	&amp;xor	($s[2],&amp;DWP(0,$te,$v1,8));		# s2&gt;&gt;0
-	&amp;movz	($v1,&amp;HB($v0));
-	&amp;shr	($v0,16);
-	&amp;xor	($s[1],&amp;DWP(3,$te,$v1,8));		# s2&gt;&gt;8
-	&amp;movz	($v1,&amp;HB($v0));
-	&amp;and	($v0,0xFF);
-	&amp;xor	($s[0],&amp;DWP(2,$te,$v0,8));		# s2&gt;&gt;16
-	 &amp;mov	($v0,&amp;DWP(8,&quot;esp&quot;));			# restore s1
-	&amp;xor	($s[3],&amp;DWP(1,$te,$v1,8));		# s2&gt;&gt;24
-
-	&amp;mov	($v1,$v0);
-	&amp;and	($v0,0xFF);
-	&amp;xor	($s[1],&amp;DWP(0,$te,$v0,8));		# s1&gt;&gt;0
-	&amp;movz	($v0,&amp;HB($v1));
-	&amp;shr	($v1,16);
-	&amp;xor	($s[0],&amp;DWP(3,$te,$v0,8));		# s1&gt;&gt;8
-	&amp;movz	($v0,&amp;HB($v1));
-	&amp;and	($v1,0xFF);
-	&amp;xor	($s[3],&amp;DWP(2,$te,$v1,8));		# s1&gt;&gt;16
-	 &amp;mov	($key,$__key);				# reincarnate v1 as key
-	&amp;xor	($s[2],&amp;DWP(1,$te,$v0,8));		# s1&gt;&gt;24
-}
-
-# Another experimental routine, which features &quot;horizontal spin,&quot; but
-# eliminates one reference to stack. Strangely enough runs slower...
-sub enchoriz()
-{ my ($v0,$v1) = ($key,$acc);
-
-	&amp;movz	($v0,&amp;LB($s0));			#  3, 2, 1, 0*
-	&amp;rotr	($s2,8);			#  8,11,10, 9
-	&amp;mov	($v1,&amp;DWP(0,$te,$v0,8));	#  0
-	&amp;movz	($v0,&amp;HB($s1));			#  7, 6, 5*, 4
-	&amp;rotr	($s3,16);			# 13,12,15,14
-	&amp;xor	($v1,&amp;DWP(3,$te,$v0,8));	#  5
-	&amp;movz	($v0,&amp;HB($s2));			#  8,11,10*, 9
-	&amp;rotr	($s0,16);			#  1, 0, 3, 2
-	&amp;xor	($v1,&amp;DWP(2,$te,$v0,8));	# 10
-	&amp;movz	($v0,&amp;HB($s3));			# 13,12,15*,14
-	&amp;xor	($v1,&amp;DWP(1,$te,$v0,8));	# 15, t[0] collected
-	&amp;mov	($__s0,$v1);			# t[0] saved
-
-	&amp;movz	($v0,&amp;LB($s1));			#  7, 6, 5, 4*
-	&amp;shr	($s1,16);			#  -, -, 7, 6
-	&amp;mov	($v1,&amp;DWP(0,$te,$v0,8));	#  4
-	&amp;movz	($v0,&amp;LB($s3));			# 13,12,15,14*
-	&amp;xor	($v1,&amp;DWP(2,$te,$v0,8));	# 14
-	&amp;movz	($v0,&amp;HB($s0));			#  1, 0, 3*, 2
-	&amp;and	($s3,0xffff0000);		# 13,12, -, -
-	&amp;xor	($v1,&amp;DWP(1,$te,$v0,8));	#  3
-	&amp;movz	($v0,&amp;LB($s2));			#  8,11,10, 9*
-	&amp;or	($s3,$s1);			# 13,12, 7, 6
-	&amp;xor	($v1,&amp;DWP(3,$te,$v0,8));	#  9, t[1] collected
-	&amp;mov	($s1,$v1);			#  s[1]=t[1]
-
-	&amp;movz	($v0,&amp;LB($s0));			#  1, 0, 3, 2*
-	&amp;shr	($s2,16);			#  -, -, 8,11
-	&amp;mov	($v1,&amp;DWP(2,$te,$v0,8));	#  2
-	&amp;movz	($v0,&amp;HB($s3));			# 13,12, 7*, 6
-	&amp;xor	($v1,&amp;DWP(1,$te,$v0,8));	#  7
-	&amp;movz	($v0,&amp;HB($s2));			#  -, -, 8*,11
-	&amp;xor	($v1,&amp;DWP(0,$te,$v0,8));	#  8
-	&amp;mov	($v0,$s3);
-	&amp;shr	($v0,24);			# 13
-	&amp;xor	($v1,&amp;DWP(3,$te,$v0,8));	# 13, t[2] collected
-
-	&amp;movz	($v0,&amp;LB($s2));			#  -, -, 8,11*
-	&amp;shr	($s0,24);			#  1*
-	&amp;mov	($s2,&amp;DWP(1,$te,$v0,8));	# 11
-	&amp;xor	($s2,&amp;DWP(3,$te,$s0,8));	#  1
-	&amp;mov	($s0,$__s0);			# s[0]=t[0]
-	&amp;movz	($v0,&amp;LB($s3));			# 13,12, 7, 6*
-	&amp;shr	($s3,16);			#   ,  ,13,12
-	&amp;xor	($s2,&amp;DWP(2,$te,$v0,8));	#  6
-	&amp;mov	($key,$__key);			# reincarnate v0 as key
-	&amp;and	($s3,0xff);			#   ,  ,13,12*
-	&amp;mov	($s3,&amp;DWP(0,$te,$s3,8));	# 12
-	&amp;xor	($s3,$s2);			# s[2]=t[3] collected
-	&amp;mov	($s2,$v1);			# s[2]=t[2]
-}
-
-# More experimental code... SSE one... Even though this one eliminates
-# *all* references to stack, it's not faster...
-sub sse_encbody()
-{
-	&amp;movz	($acc,&amp;LB(&quot;eax&quot;));		#  0
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(0,$tbl,$acc,8));	#  0
-	&amp;pshufw	(&quot;mm2&quot;,&quot;mm0&quot;,0x0d);		#  7, 6, 3, 2
-	&amp;movz	(&quot;edx&quot;,&amp;HB(&quot;eax&quot;));		#  1
-	&amp;mov	(&quot;edx&quot;,&amp;DWP(3,$tbl,&quot;edx&quot;,8));	#  1
-	&amp;shr	(&quot;eax&quot;,16);			#  5, 4
-
-	&amp;movz	($acc,&amp;LB(&quot;ebx&quot;));		# 10
-	&amp;xor	(&quot;ecx&quot;,&amp;DWP(2,$tbl,$acc,8));	# 10
-	&amp;pshufw	(&quot;mm6&quot;,&quot;mm4&quot;,0x08);		# 13,12, 9, 8
-	&amp;movz	($acc,&amp;HB(&quot;ebx&quot;));		# 11
-	&amp;xor	(&quot;edx&quot;,&amp;DWP(1,$tbl,$acc,8));	# 11
-	&amp;shr	(&quot;ebx&quot;,16);			# 15,14
-
-	&amp;movz	($acc,&amp;HB(&quot;eax&quot;));		#  5
-	&amp;xor	(&quot;ecx&quot;,&amp;DWP(3,$tbl,$acc,8));	#  5
-	&amp;movq	(&quot;mm3&quot;,QWP(16,$key));
-	&amp;movz	($acc,&amp;HB(&quot;ebx&quot;));		# 15
-	&amp;xor	(&quot;ecx&quot;,&amp;DWP(1,$tbl,$acc,8));	# 15
-	&amp;movd	(&quot;mm0&quot;,&quot;ecx&quot;);			# t[0] collected
-
-	&amp;movz	($acc,&amp;LB(&quot;eax&quot;));		#  4
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(0,$tbl,$acc,8));	#  4
-	&amp;movd	(&quot;eax&quot;,&quot;mm2&quot;);			#  7, 6, 3, 2
-	&amp;movz	($acc,&amp;LB(&quot;ebx&quot;));		# 14
-	&amp;xor	(&quot;ecx&quot;,&amp;DWP(2,$tbl,$acc,8));	# 14
-	&amp;movd	(&quot;ebx&quot;,&quot;mm6&quot;);			# 13,12, 9, 8
-
-	&amp;movz	($acc,&amp;HB(&quot;eax&quot;));		#  3
-	&amp;xor	(&quot;ecx&quot;,&amp;DWP(1,$tbl,$acc,8));	#  3
-	&amp;movz	($acc,&amp;HB(&quot;ebx&quot;));		#  9
-	&amp;xor	(&quot;ecx&quot;,&amp;DWP(3,$tbl,$acc,8));	#  9
-	&amp;movd	(&quot;mm1&quot;,&quot;ecx&quot;);			# t[1] collected
-
-	&amp;movz	($acc,&amp;LB(&quot;eax&quot;));		#  2
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(2,$tbl,$acc,8));	#  2
-	&amp;shr	(&quot;eax&quot;,16);			#  7, 6
-	&amp;punpckldq	(&quot;mm0&quot;,&quot;mm1&quot;);		# t[0,1] collected
-	&amp;movz	($acc,&amp;LB(&quot;ebx&quot;));		#  8
-	&amp;xor	(&quot;ecx&quot;,&amp;DWP(0,$tbl,$acc,8));	#  8
-	&amp;shr	(&quot;ebx&quot;,16);			# 13,12
-
-	&amp;movz	($acc,&amp;HB(&quot;eax&quot;));		#  7
-	&amp;xor	(&quot;ecx&quot;,&amp;DWP(1,$tbl,$acc,8));	#  7
-	&amp;pxor	(&quot;mm0&quot;,&quot;mm3&quot;);
-	&amp;movz	(&quot;eax&quot;,&amp;LB(&quot;eax&quot;));		#  6
-	&amp;xor	(&quot;edx&quot;,&amp;DWP(2,$tbl,&quot;eax&quot;,8));	#  6
-	&amp;pshufw	(&quot;mm1&quot;,&quot;mm0&quot;,0x08);		#  5, 4, 1, 0
-	&amp;movz	($acc,&amp;HB(&quot;ebx&quot;));		# 13
-	&amp;xor	(&quot;ecx&quot;,&amp;DWP(3,$tbl,$acc,8));	# 13
-	&amp;xor	(&quot;ecx&quot;,&amp;DWP(24,$key));		# t[2]
-	&amp;movd	(&quot;mm4&quot;,&quot;ecx&quot;);			# t[2] collected
-	&amp;movz	(&quot;ebx&quot;,&amp;LB(&quot;ebx&quot;));		# 12
-	&amp;xor	(&quot;edx&quot;,&amp;DWP(0,$tbl,&quot;ebx&quot;,8));	# 12
-	&amp;shr	(&quot;ecx&quot;,16);
-	&amp;movd	(&quot;eax&quot;,&quot;mm1&quot;);			#  5, 4, 1, 0
-	&amp;mov	(&quot;ebx&quot;,&amp;DWP(28,$key));		# t[3]
-	&amp;xor	(&quot;ebx&quot;,&quot;edx&quot;);
-	&amp;movd	(&quot;mm5&quot;,&quot;ebx&quot;);			# t[3] collected
-	&amp;and	(&quot;ebx&quot;,0xffff0000);
-	&amp;or	(&quot;ebx&quot;,&quot;ecx&quot;);
-
-	&amp;punpckldq	(&quot;mm4&quot;,&quot;mm5&quot;);		# t[2,3] collected
-}
-
-######################################################################
-# &quot;Compact&quot; block function
-######################################################################
-
-sub enccompact()
-{ my $Fn = \&mov;
-  while ($#_&gt;5) { pop(@_); $Fn=sub{}; }
-  my ($i,$<A HREF="../../../mailman/listinfo/openssl-commits.html">te, at s</A>)=@_;
-  my $tmp = $key;
-  my $out = $i==3?$s[0]:$acc;
-
-	# $Fn is used in first compact round and its purpose is to
-	# void restoration of some values from stack, so that after
-	# 4xenccompact with extra argument $key value is left there...
-	if ($i==3)  {	&amp;$Fn	($key,$__key);			}##%edx
-	else        {	&amp;mov	($out,$s[0]);			}
-			&amp;and	($out,0xFF);
-	if ($i==1)  {	&amp;shr	($s[0],16);			}#%ebx[1]
-	if ($i==2)  {	&amp;shr	($s[0],24);			}#%ecx[2]
-			&amp;movz	($out,&amp;BP(-128,$te,$out,1));
-
-	if ($i==3)  {	$tmp=$s[1];				}##%eax
-			&amp;movz	($tmp,&amp;HB($s[1]));
-			&amp;movz	($tmp,&amp;BP(-128,$te,$tmp,1));
-			&amp;shl	($tmp,8);
-			&amp;xor	($out,$tmp);
-
-	if ($i==3)  {	$tmp=$s[2]; &amp;mov ($s[1],$__s0);		}##%ebx
-	else        {	&amp;mov	($tmp,$s[2]);
-			&amp;shr	($tmp,16);			}
-	if ($i==2)  {	&amp;and	($s[1],0xFF);			}#%edx[2]
-			&amp;and	($tmp,0xFF);
-			&amp;movz	($tmp,&amp;BP(-128,$te,$tmp,1));
-			&amp;shl	($tmp,16);
-			&amp;xor	($out,$tmp);
-
-	if ($i==3)  {	$tmp=$s[3]; &amp;mov ($s[2],$__s1);		}##%ecx
-	elsif($i==2){	&amp;movz	($tmp,&amp;HB($s[3]));		}#%ebx[2]
-	else        {	&amp;mov	($tmp,$s[3]);
-			&amp;shr	($tmp,24);			}
-			&amp;movz	($tmp,&amp;BP(-128,$te,$tmp,1));
-			&amp;shl	($tmp,24);
-			&amp;xor	($out,$tmp);
-	if ($i&lt;2)   {	&amp;mov	(&amp;DWP(4+4*$i,&quot;esp&quot;),$out);	}
-	if ($i==3)  {	&amp;mov	($s[3],$acc);			}
-	&amp;comment();
-}
-
-sub enctransform()
-{ my @s = ($s0,$s1,$s2,$s3);
-  my $i = shift;
-  my $tmp = $tbl;
-  my $r2  = $key ;
-
-	&amp;and	($tmp,$s[$i]);
-	&amp;lea	($r2,&amp;DWP(0,$s[$i],$s[$i]));
-	&amp;mov	($acc,$tmp);
-	&amp;shr	($tmp,7);
-	&amp;and	($r2,0xfefefefe);
-	&amp;sub	($acc,$tmp);
-	&amp;mov	($tmp,$s[$i]);
-	&amp;and	($acc,0x1b1b1b1b);
-	&amp;rotr	($tmp,16);
-	&amp;xor	($acc,$r2);	# r2
-	&amp;mov	($r2,$s[$i]);
-
-	&amp;xor	($s[$i],$acc);	# r0 ^ r2
-	&amp;rotr	($r2,16+8);
-	&amp;xor	($acc,$tmp);
-	&amp;rotl	($s[$i],24);
-	&amp;xor	($acc,$r2);
-	&amp;mov	($tmp,0x80808080)	if ($i!=1);
-	&amp;xor	($s[$i],$acc);	# ROTATE(r2^r0,24) ^ r2
-}
-
-&amp;function_begin_B(&quot;_x86_AES_encrypt_compact&quot;);
-	# note that caller is expected to allocate stack frame for me!
-	&amp;mov	($__key,$key);			# save key
-
-	&amp;xor	($s0,&amp;DWP(0,$key));		# xor with key
-	&amp;xor	($s1,&amp;DWP(4,$key));
-	&amp;xor	($s2,&amp;DWP(8,$key));
-	&amp;xor	($s3,&amp;DWP(12,$key));
-
-	&amp;mov	($acc,&amp;DWP(240,$key));		# load key-&gt;rounds
-	&amp;lea	($acc,&amp;DWP(-2,$acc,$acc));
-	&amp;lea	($acc,&amp;DWP(0,$key,$acc,8));
-	&amp;mov	($__end,$acc);			# end of key schedule
-
-	# prefetch Te4
-	&amp;mov	($key,&amp;DWP(0-128,$tbl));
-	&amp;mov	($acc,&amp;DWP(32-128,$tbl));
-	&amp;mov	($key,&amp;DWP(64-128,$tbl));
-	&amp;mov	($acc,&amp;DWP(96-128,$tbl));
-	&amp;mov	($key,&amp;DWP(128-128,$tbl));
-	&amp;mov	($acc,&amp;DWP(160-128,$tbl));
-	&amp;mov	($key,&amp;DWP(192-128,$tbl));
-	&amp;mov	($acc,&amp;DWP(224-128,$tbl));
-
-	&amp;set_label(&quot;loop&quot;,16);
-
-		&amp;enccompact(0,$tbl,$s0,$s1,$s2,$s3,1);
-		&amp;enccompact(1,$tbl,$s1,$s2,$s3,$s0,1);
-		&amp;enccompact(2,$tbl,$s2,$s3,$s0,$s1,1);
-		&amp;enccompact(3,$tbl,$s3,$s0,$s1,$s2,1);
-		&amp;mov	($tbl,0x80808080);
-		&amp;enctransform(2);
-		&amp;enctransform(3);
-		&amp;enctransform(0);
-		&amp;enctransform(1);
-		&amp;mov 	($key,$__key);
-		&amp;mov	($tbl,$__tbl);
-		&amp;add	($key,16);		# advance rd_key
-		&amp;xor	($s0,&amp;DWP(0,$key));
-		&amp;xor	($s1,&amp;DWP(4,$key));
-		&amp;xor	($s2,&amp;DWP(8,$key));
-		&amp;xor	($s3,&amp;DWP(12,$key));
-
-	&amp;cmp	($key,$__end);
-	&amp;mov	($__key,$key);
-	&amp;jb	(&amp;label(&quot;loop&quot;));
-
-	&amp;enccompact(0,$tbl,$s0,$s1,$s2,$s3);
-	&amp;enccompact(1,$tbl,$s1,$s2,$s3,$s0);
-	&amp;enccompact(2,$tbl,$s2,$s3,$s0,$s1);
-	&amp;enccompact(3,$tbl,$s3,$s0,$s1,$s2);
-
-	&amp;xor	($s0,&amp;DWP(16,$key));
-	&amp;xor	($s1,&amp;DWP(20,$key));
-	&amp;xor	($s2,&amp;DWP(24,$key));
-	&amp;xor	($s3,&amp;DWP(28,$key));
-
-	&amp;ret	();
-&amp;function_end_B(&quot;_x86_AES_encrypt_compact&quot;);
-
-######################################################################
-# &quot;Compact&quot; SSE block function.
-######################################################################
-#
-# Performance is not actually extraordinary in comparison to pure
-# x86 code. In particular encrypt performance is virtually the same.
-# Decrypt performance on the other hand is 15-20% better on newer
-# &#181;-archs [but we're thankful for *any* improvement here], and ~50%
-# better on PIII:-) And additionally on the pros side this code
-# eliminates redundant references to stack and thus relieves/
-# minimizes the pressure on the memory bus.
-#
-# MMX register layout                           lsb
-# +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
-# |          mm4          |          mm0          |
-# +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
-# |     s3    |     s2    |     s1    |     s0    |
-# +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
-# |15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
-# +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
-#
-# Indexes translate as s[N/4]&gt;&gt;(8*(N%4)), e.g. 5 means s1&gt;&gt;8.
-# In this terms encryption and decryption &quot;compact&quot; permutation
-# matrices can be depicted as following:
-#
-# encryption              lsb	# decryption              lsb
-# +----++----+----+----+----+	# +----++----+----+----+----+
-# | t0 || 15 | 10 |  5 |  0 |	# | t0 ||  7 | 10 | 13 |  0 |
-# +----++----+----+----+----+	# +----++----+----+----+----+
-# | t1 ||  3 | 14 |  9 |  4 |	# | t1 || 11 | 14 |  1 |  4 |
-# +----++----+----+----+----+	# +----++----+----+----+----+
-# | t2 ||  7 |  2 | 13 |  8 |	# | t2 || 15 |  2 |  5 |  8 |
-# +----++----+----+----+----+	# +----++----+----+----+----+
-# | t3 || 11 |  6 |  1 | 12 |	# | t3 ||  3 |  6 |  9 | 12 |
-# +----++----+----+----+----+	# +----++----+----+----+----+
-#
-######################################################################
-# Why not xmm registers? Short answer. It was actually tested and
-# was not any faster, but *contrary*, most notably on Intel CPUs.
-# Longer answer. Main advantage of using mm registers is that movd
-# latency is lower, especially on Intel P4. While arithmetic
-# instructions are twice as many, they can be scheduled every cycle
-# and not every second one when they are operating on xmm register,
-# so that &quot;arithmetic throughput&quot; remains virtually the same. And
-# finally the code can be executed even on elder SSE-only CPUs:-)
-
-sub sse_enccompact()
-{
-	&amp;pshufw	(&quot;mm1&quot;,&quot;mm0&quot;,0x08);		#  5, 4, 1, 0
-	&amp;pshufw	(&quot;mm5&quot;,&quot;mm4&quot;,0x0d);		# 15,14,11,10
-	&amp;movd	(&quot;eax&quot;,&quot;mm1&quot;);			#  5, 4, 1, 0
-	&amp;movd	(&quot;ebx&quot;,&quot;mm5&quot;);			# 15,14,11,10
-	&amp;mov	($__key,$key);
-
-	&amp;movz	($acc,&amp;LB(&quot;eax&quot;));		#  0
-	&amp;movz	(&quot;edx&quot;,&amp;HB(&quot;eax&quot;));		#  1
-	&amp;pshufw	(&quot;mm2&quot;,&quot;mm0&quot;,0x0d);		#  7, 6, 3, 2
-	&amp;movz	(&quot;ecx&quot;,&amp;BP(-128,$tbl,$acc,1));	#  0
-	&amp;movz	($key,&amp;LB(&quot;ebx&quot;));		# 10
-	&amp;movz	(&quot;edx&quot;,&amp;BP(-128,$tbl,&quot;edx&quot;,1));	#  1
-	&amp;shr	(&quot;eax&quot;,16);			#  5, 4
-	&amp;shl	(&quot;edx&quot;,8);			#  1
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	# 10
-	&amp;movz	($key,&amp;HB(&quot;ebx&quot;));		# 11
-	&amp;shl	($acc,16);			# 10
-	&amp;pshufw	(&quot;mm6&quot;,&quot;mm4&quot;,0x08);		# 13,12, 9, 8
-	&amp;or	(&quot;ecx&quot;,$acc);			# 10
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	# 11
-	&amp;movz	($key,&amp;HB(&quot;eax&quot;));		#  5
-	&amp;shl	($acc,24);			# 11
-	&amp;shr	(&quot;ebx&quot;,16);			# 15,14
-	&amp;or	(&quot;edx&quot;,$acc);			# 11
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  5
-	&amp;movz	($key,&amp;HB(&quot;ebx&quot;));		# 15
-	&amp;shl	($acc,8);			#  5
-	&amp;or	(&quot;ecx&quot;,$acc);			#  5
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	# 15
-	&amp;movz	($key,&amp;LB(&quot;eax&quot;));		#  4
-	&amp;shl	($acc,24);			# 15
-	&amp;or	(&quot;ecx&quot;,$acc);			# 15
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  4
-	&amp;movz	($key,&amp;LB(&quot;ebx&quot;));		# 14
-	&amp;movd	(&quot;eax&quot;,&quot;mm2&quot;);			#  7, 6, 3, 2
-	&amp;movd	(&quot;mm0&quot;,&quot;ecx&quot;);			# t[0] collected
-	&amp;movz	(&quot;ecx&quot;,&amp;BP(-128,$tbl,$key,1));	# 14
-	&amp;movz	($key,&amp;HB(&quot;eax&quot;));		#  3
-	&amp;shl	(&quot;ecx&quot;,16);			# 14
-	&amp;movd	(&quot;ebx&quot;,&quot;mm6&quot;);			# 13,12, 9, 8
-	&amp;or	(&quot;ecx&quot;,$acc);			# 14
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  3
-	&amp;movz	($key,&amp;HB(&quot;ebx&quot;));		#  9
-	&amp;shl	($acc,24);			#  3
-	&amp;or	(&quot;ecx&quot;,$acc);			#  3
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  9
-	&amp;movz	($key,&amp;LB(&quot;ebx&quot;));		#  8
-	&amp;shl	($acc,8);			#  9
-	&amp;shr	(&quot;ebx&quot;,16);			# 13,12
-	&amp;or	(&quot;ecx&quot;,$acc);			#  9
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  8
-	&amp;movz	($key,&amp;LB(&quot;eax&quot;));		#  2
-	&amp;shr	(&quot;eax&quot;,16);			#  7, 6
-	&amp;movd	(&quot;mm1&quot;,&quot;ecx&quot;);			# t[1] collected
-	&amp;movz	(&quot;ecx&quot;,&amp;BP(-128,$tbl,$key,1));	#  2
-	&amp;movz	($key,&amp;HB(&quot;eax&quot;));		#  7
-	&amp;shl	(&quot;ecx&quot;,16);			#  2
-	&amp;and	(&quot;eax&quot;,0xff);			#  6
-	&amp;or	(&quot;ecx&quot;,$acc);			#  2
-
-	&amp;punpckldq	(&quot;mm0&quot;,&quot;mm1&quot;);		# t[0,1] collected
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  7
-	&amp;movz	($key,&amp;HB(&quot;ebx&quot;));		# 13
-	&amp;shl	($acc,24);			#  7
-	&amp;and	(&quot;ebx&quot;,0xff);			# 12
-	&amp;movz	(&quot;eax&quot;,&amp;BP(-128,$tbl,&quot;eax&quot;,1));	#  6
-	&amp;or	(&quot;ecx&quot;,$acc);			#  7
-	&amp;shl	(&quot;eax&quot;,16);			#  6
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	# 13
-	&amp;or	(&quot;edx&quot;,&quot;eax&quot;);			#  6
-	&amp;shl	($acc,8);			# 13
-	&amp;movz	(&quot;ebx&quot;,&amp;BP(-128,$tbl,&quot;ebx&quot;,1));	# 12
-	&amp;or	(&quot;ecx&quot;,$acc);			# 13
-	&amp;or	(&quot;edx&quot;,&quot;ebx&quot;);			# 12
-	&amp;mov	($key,$__key);
-	&amp;movd	(&quot;mm4&quot;,&quot;ecx&quot;);			# t[2] collected
-	&amp;movd	(&quot;mm5&quot;,&quot;edx&quot;);			# t[3] collected
-
-	&amp;punpckldq	(&quot;mm4&quot;,&quot;mm5&quot;);		# t[2,3] collected
-}
-
-					if (!$x86only) {
-&amp;function_begin_B(&quot;_sse_AES_encrypt_compact&quot;);
-	&amp;pxor	(&quot;mm0&quot;,&amp;QWP(0,$key));	#  7, 6, 5, 4, 3, 2, 1, 0
-	&amp;pxor	(&quot;mm4&quot;,&amp;QWP(8,$key));	# 15,14,13,12,11,10, 9, 8
-
-	# note that caller is expected to allocate stack frame for me!
-	&amp;mov	($acc,&amp;DWP(240,$key));		# load key-&gt;rounds
-	&amp;lea	($acc,&amp;DWP(-2,$acc,$acc));
-	&amp;lea	($acc,&amp;DWP(0,$key,$acc,8));
-	&amp;mov	($__end,$acc);			# end of key schedule
-
-	&amp;mov	($s0,0x1b1b1b1b);		# magic constant
-	&amp;mov	(&amp;DWP(8,&quot;esp&quot;),$s0);
-	&amp;mov	(&amp;DWP(12,&quot;esp&quot;),$s0);
-
-	# prefetch Te4
-	&amp;mov	($s0,&amp;DWP(0-128,$tbl));
-	&amp;mov	($s1,&amp;DWP(32-128,$tbl));
-	&amp;mov	($s2,&amp;DWP(64-128,$tbl));
-	&amp;mov	($s3,&amp;DWP(96-128,$tbl));
-	&amp;mov	($s0,&amp;DWP(128-128,$tbl));
-	&amp;mov	($s1,&amp;DWP(160-128,$tbl));
-	&amp;mov	($s2,&amp;DWP(192-128,$tbl));
-	&amp;mov	($s3,&amp;DWP(224-128,$tbl));
-
-	&amp;set_label(&quot;loop&quot;,16);
-		&amp;sse_enccompact();
-		&amp;add	($key,16);
-		&amp;cmp	($key,$__end);
-		&amp;ja	(&amp;label(&quot;out&quot;));
-
-		&amp;movq	(&quot;mm2&quot;,&amp;QWP(8,&quot;esp&quot;));
-		&amp;pxor	(&quot;mm3&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm7&quot;,&quot;mm7&quot;);
-		&amp;movq	(&quot;mm1&quot;,&quot;mm0&quot;);		&amp;movq	(&quot;mm5&quot;,&quot;mm4&quot;);	# r0
-		&amp;pcmpgtb(&quot;mm3&quot;,&quot;mm0&quot;);		&amp;pcmpgtb(&quot;mm7&quot;,&quot;mm4&quot;);
-		&amp;pand	(&quot;mm3&quot;,&quot;mm2&quot;);		&amp;pand	(&quot;mm7&quot;,&quot;mm2&quot;);
-		&amp;pshufw	(&quot;mm2&quot;,&quot;mm0&quot;,0xb1);	&amp;pshufw	(&quot;mm6&quot;,&quot;mm4&quot;,0xb1);# ROTATE(r0,16)
-		&amp;paddb	(&quot;mm0&quot;,&quot;mm0&quot;);		&amp;paddb	(&quot;mm4&quot;,&quot;mm4&quot;);
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm7&quot;);	# = r2
-		&amp;pshufw	(&quot;mm3&quot;,&quot;mm2&quot;,0xb1);	&amp;pshufw	(&quot;mm7&quot;,&quot;mm6&quot;,0xb1);# r0
-		&amp;pxor	(&quot;mm1&quot;,&quot;mm0&quot;);		&amp;pxor	(&quot;mm5&quot;,&quot;mm4&quot;);	# r0^r2
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm2&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm6&quot;);	# ^= ROTATE(r0,16)
-
-		&amp;movq	(&quot;mm2&quot;,&quot;mm3&quot;);		&amp;movq	(&quot;mm6&quot;,&quot;mm7&quot;);
-		&amp;pslld	(&quot;mm3&quot;,8);		&amp;pslld	(&quot;mm7&quot;,8);
-		&amp;psrld	(&quot;mm2&quot;,24);		&amp;psrld	(&quot;mm6&quot;,24);
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm7&quot;);	# ^= r0&lt;&lt;8
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm2&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm6&quot;);	# ^= r0&gt;&gt;24
-
-		&amp;movq	(&quot;mm3&quot;,&quot;mm1&quot;);		&amp;movq	(&quot;mm7&quot;,&quot;mm5&quot;);
-		&amp;movq	(&quot;mm2&quot;,&amp;QWP(0,$key));	&amp;movq	(&quot;mm6&quot;,&amp;QWP(8,$key));
-		&amp;psrld	(&quot;mm1&quot;,8);		&amp;psrld	(&quot;mm5&quot;,8);
-		&amp;mov	($s0,&amp;DWP(0-128,$tbl));
-		&amp;pslld	(&quot;mm3&quot;,24);		&amp;pslld	(&quot;mm7&quot;,24);
-		&amp;mov	($s1,&amp;DWP(64-128,$tbl));
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm1&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm5&quot;);	# ^= (r2^r0)&lt;&lt;8
-		&amp;mov	($s2,&amp;DWP(128-128,$tbl));
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm7&quot;);	# ^= (r2^r0)&gt;&gt;24
-		&amp;mov	($s3,&amp;DWP(192-128,$tbl));
-
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm2&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm6&quot;);
-	&amp;jmp	(&amp;label(&quot;loop&quot;));
-
-	&amp;set_label(&quot;out&quot;,16);
-	&amp;pxor	(&quot;mm0&quot;,&amp;QWP(0,$key));
-	&amp;pxor	(&quot;mm4&quot;,&amp;QWP(8,$key));
-
-	&amp;ret	();
-&amp;function_end_B(&quot;_sse_AES_encrypt_compact&quot;);
-					}
-
-######################################################################
-# Vanilla block function.
-######################################################################
-
-sub encstep()
-{ my ($i,$<A HREF="../../../mailman/listinfo/openssl-commits.html">te, at s</A>) = @_;
-  my $tmp = $key;
-  my $out = $i==3?$s[0]:$acc;
-
-	# lines marked with #%e?x[i] denote &quot;reordered&quot; instructions...
-	if ($i==3)  {	&amp;mov	($key,$__key);			}##%edx
-	else        {	&amp;mov	($out,$s[0]);
-			&amp;and	($out,0xFF);			}
-	if ($i==1)  {	&amp;shr	($s[0],16);			}#%ebx[1]
-	if ($i==2)  {	&amp;shr	($s[0],24);			}#%ecx[2]
-			&amp;mov	($out,&amp;DWP(0,$te,$out,8));
-
-	if ($i==3)  {	$tmp=$s[1];				}##%eax
-			&amp;movz	($tmp,&amp;HB($s[1]));
-			&amp;xor	($out,&amp;DWP(3,$te,$tmp,8));
-
-	if ($i==3)  {	$tmp=$s[2]; &amp;mov ($s[1],$__s0);		}##%ebx
-	else        {	&amp;mov	($tmp,$s[2]);
-			&amp;shr	($tmp,16);			}
-	if ($i==2)  {	&amp;and	($s[1],0xFF);			}#%edx[2]
-			&amp;and	($tmp,0xFF);
-			&amp;xor	($out,&amp;DWP(2,$te,$tmp,8));
-
-	if ($i==3)  {	$tmp=$s[3]; &amp;mov ($s[2],$__s1);		}##%ecx
-	elsif($i==2){	&amp;movz	($tmp,&amp;HB($s[3]));		}#%ebx[2]
-	else        {	&amp;mov	($tmp,$s[3]);
-			&amp;shr	($tmp,24)			}
-			&amp;xor	($out,&amp;DWP(1,$te,$tmp,8));
-	if ($i&lt;2)   {	&amp;mov	(&amp;DWP(4+4*$i,&quot;esp&quot;),$out);	}
-	if ($i==3)  {	&amp;mov	($s[3],$acc);			}
-			&amp;comment();
-}
-
-sub enclast()
-{ my ($i,$<A HREF="../../../mailman/listinfo/openssl-commits.html">te, at s</A>)=@_;
-  my $tmp = $key;
-  my $out = $i==3?$s[0]:$acc;
-
-	if ($i==3)  {	&amp;mov	($key,$__key);			}##%edx
-	else        {	&amp;mov	($out,$s[0]);			}
-			&amp;and	($out,0xFF);
-	if ($i==1)  {	&amp;shr	($s[0],16);			}#%ebx[1]
-	if ($i==2)  {	&amp;shr	($s[0],24);			}#%ecx[2]
-			&amp;mov	($out,&amp;DWP(2,$te,$out,8));
-			&amp;and	($out,0x000000ff);
-
-	if ($i==3)  {	$tmp=$s[1];				}##%eax
-			&amp;movz	($tmp,&amp;HB($s[1]));
-			&amp;mov	($tmp,&amp;DWP(0,$te,$tmp,8));
-			&amp;and	($tmp,0x0000ff00);
-			&amp;xor	($out,$tmp);
-
-	if ($i==3)  {	$tmp=$s[2]; &amp;mov ($s[1],$__s0);		}##%ebx
-	else        {	&amp;mov	($tmp,$s[2]);
-			&amp;shr	($tmp,16);			}
-	if ($i==2)  {	&amp;and	($s[1],0xFF);			}#%edx[2]
-			&amp;and	($tmp,0xFF);
-			&amp;mov	($tmp,&amp;DWP(0,$te,$tmp,8));
-			&amp;and	($tmp,0x00ff0000);
-			&amp;xor	($out,$tmp);
-
-	if ($i==3)  {	$tmp=$s[3]; &amp;mov ($s[2],$__s1);		}##%ecx
-	elsif($i==2){	&amp;movz	($tmp,&amp;HB($s[3]));		}#%ebx[2]
-	else        {	&amp;mov	($tmp,$s[3]);
-			&amp;shr	($tmp,24);			}
-			&amp;mov	($tmp,&amp;DWP(2,$te,$tmp,8));
-			&amp;and	($tmp,0xff000000);
-			&amp;xor	($out,$tmp);
-	if ($i&lt;2)   {	&amp;mov	(&amp;DWP(4+4*$i,&quot;esp&quot;),$out);	}
-	if ($i==3)  {	&amp;mov	($s[3],$acc);			}
-}
-
-&amp;function_begin_B(&quot;_x86_AES_encrypt&quot;);
-	if ($vertical_spin) {
-		# I need high parts of volatile registers to be accessible...
-		&amp;exch	($s1=&quot;edi&quot;,$key=&quot;ebx&quot;);
-		&amp;mov	($s2=&quot;esi&quot;,$acc=&quot;ecx&quot;);
-	}
-
-	# note that caller is expected to allocate stack frame for me!
-	&amp;mov	($__key,$key);			# save key
-
-	&amp;xor	($s0,&amp;DWP(0,$key));		# xor with key
-	&amp;xor	($s1,&amp;DWP(4,$key));
-	&amp;xor	($s2,&amp;DWP(8,$key));
-	&amp;xor	($s3,&amp;DWP(12,$key));
-
-	&amp;mov	($acc,&amp;DWP(240,$key));		# load key-&gt;rounds
-
-	if ($small_footprint) {
-	    &amp;lea	($acc,&amp;DWP(-2,$acc,$acc));
-	    &amp;lea	($acc,&amp;DWP(0,$key,$acc,8));
-	    &amp;mov	($__end,$acc);		# end of key schedule
-
-	    &amp;set_label(&quot;loop&quot;,16);
-		if ($vertical_spin) {
-		    &amp;encvert($tbl,$s0,$s1,$s2,$s3);
-		} else {
-		    &amp;encstep(0,$tbl,$s0,$s1,$s2,$s3);
-		    &amp;encstep(1,$tbl,$s1,$s2,$s3,$s0);
-		    &amp;encstep(2,$tbl,$s2,$s3,$s0,$s1);
-		    &amp;encstep(3,$tbl,$s3,$s0,$s1,$s2);
-		}
-		&amp;add	($key,16);		# advance rd_key
-		&amp;xor	($s0,&amp;DWP(0,$key));
-		&amp;xor	($s1,&amp;DWP(4,$key));
-		&amp;xor	($s2,&amp;DWP(8,$key));
-		&amp;xor	($s3,&amp;DWP(12,$key));
-	    &amp;cmp	($key,$__end);
-	    &amp;mov	($__key,$key);
-	    &amp;jb		(&amp;label(&quot;loop&quot;));
-	}
-	else {
-	    &amp;cmp	($acc,10);
-	    &amp;jle	(&amp;label(&quot;10rounds&quot;));
-	    &amp;cmp	($acc,12);
-	    &amp;jle	(&amp;label(&quot;12rounds&quot;));
-
-	&amp;set_label(&quot;14rounds&quot;,4);
-	    for ($i=1;$i&lt;3;$i++) {
-		if ($vertical_spin) {
-		    &amp;encvert($tbl,$s0,$s1,$s2,$s3);
-		} else {
-		    &amp;encstep(0,$tbl,$s0,$s1,$s2,$s3);
-		    &amp;encstep(1,$tbl,$s1,$s2,$s3,$s0);
-		    &amp;encstep(2,$tbl,$s2,$s3,$s0,$s1);
-		    &amp;encstep(3,$tbl,$s3,$s0,$s1,$s2);
-		}
-		&amp;xor	($s0,&amp;DWP(16*$i+0,$key));
-		&amp;xor	($s1,&amp;DWP(16*$i+4,$key));
-		&amp;xor	($s2,&amp;DWP(16*$i+8,$key));
-		&amp;xor	($s3,&amp;DWP(16*$i+12,$key));
-	    }
-	    &amp;add	($key,32);
-	    &amp;mov	($__key,$key);		# advance rd_key
-	&amp;set_label(&quot;12rounds&quot;,4);
-	    for ($i=1;$i&lt;3;$i++) {
-		if ($vertical_spin) {
-		    &amp;encvert($tbl,$s0,$s1,$s2,$s3);
-		} else {
-		    &amp;encstep(0,$tbl,$s0,$s1,$s2,$s3);
-		    &amp;encstep(1,$tbl,$s1,$s2,$s3,$s0);
-		    &amp;encstep(2,$tbl,$s2,$s3,$s0,$s1);
-		    &amp;encstep(3,$tbl,$s3,$s0,$s1,$s2);
-		}
-		&amp;xor	($s0,&amp;DWP(16*$i+0,$key));
-		&amp;xor	($s1,&amp;DWP(16*$i+4,$key));
-		&amp;xor	($s2,&amp;DWP(16*$i+8,$key));
-		&amp;xor	($s3,&amp;DWP(16*$i+12,$key));
-	    }
-	    &amp;add	($key,32);
-	    &amp;mov	($__key,$key);		# advance rd_key
-	&amp;set_label(&quot;10rounds&quot;,4);
-	    for ($i=1;$i&lt;10;$i++) {
-		if ($vertical_spin) {
-		    &amp;encvert($tbl,$s0,$s1,$s2,$s3);
-		} else {
-		    &amp;encstep(0,$tbl,$s0,$s1,$s2,$s3);
-		    &amp;encstep(1,$tbl,$s1,$s2,$s3,$s0);
-		    &amp;encstep(2,$tbl,$s2,$s3,$s0,$s1);
-		    &amp;encstep(3,$tbl,$s3,$s0,$s1,$s2);
-		}
-		&amp;xor	($s0,&amp;DWP(16*$i+0,$key));
-		&amp;xor	($s1,&amp;DWP(16*$i+4,$key));
-		&amp;xor	($s2,&amp;DWP(16*$i+8,$key));
-		&amp;xor	($s3,&amp;DWP(16*$i+12,$key));
-	    }
-	}
-
-	if ($vertical_spin) {
-	    # &quot;reincarnate&quot; some registers for &quot;horizontal&quot; spin...
-	    &amp;mov	($s1=&quot;ebx&quot;,$key=&quot;edi&quot;);
-	    &amp;mov	($s2=&quot;ecx&quot;,$acc=&quot;esi&quot;);
-	}
-	&amp;enclast(0,$tbl,$s0,$s1,$s2,$s3);
-	&amp;enclast(1,$tbl,$s1,$s2,$s3,$s0);
-	&amp;enclast(2,$tbl,$s2,$s3,$s0,$s1);
-	&amp;enclast(3,$tbl,$s3,$s0,$s1,$s2);
-
-	&amp;add	($key,$small_footprint?16:160);
-	&amp;xor	($s0,&amp;DWP(0,$key));
-	&amp;xor	($s1,&amp;DWP(4,$key));
-	&amp;xor	($s2,&amp;DWP(8,$key));
-	&amp;xor	($s3,&amp;DWP(12,$key));
-
-	&amp;ret	();
-
-&amp;set_label(&quot;AES_Te&quot;,64);	# Yes! I keep it in the code segment!
-	&amp;_data_word(0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6);
-	&amp;_data_word(0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591);
-	&amp;_data_word(0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56);
-	&amp;_data_word(0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec);
-	&amp;_data_word(0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa);
-	&amp;_data_word(0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb);
-	&amp;_data_word(0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45);
-	&amp;_data_word(0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b);
-	&amp;_data_word(0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c);
-	&amp;_data_word(0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83);
-	&amp;_data_word(0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9);
-	&amp;_data_word(0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a);
-	&amp;_data_word(0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d);
-	&amp;_data_word(0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f);
-	&amp;_data_word(0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df);
-	&amp;_data_word(0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea);
-	&amp;_data_word(0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34);
-	&amp;_data_word(0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b);
-	&amp;_data_word(0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d);
-	&amp;_data_word(0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413);
-	&amp;_data_word(0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1);
-	&amp;_data_word(0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6);
-	&amp;_data_word(0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972);
-	&amp;_data_word(0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85);
-	&amp;_data_word(0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed);
-	&amp;_data_word(0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511);
-	&amp;_data_word(0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe);
-	&amp;_data_word(0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b);
-	&amp;_data_word(0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05);
-	&amp;_data_word(0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1);
-	&amp;_data_word(0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142);
-	&amp;_data_word(0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf);
-	&amp;_data_word(0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3);
-	&amp;_data_word(0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e);
-	&amp;_data_word(0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a);
-	&amp;_data_word(0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6);
-	&amp;_data_word(0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3);
-	&amp;_data_word(0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b);
-	&amp;_data_word(0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428);
-	&amp;_data_word(0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad);
-	&amp;_data_word(0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14);
-	&amp;_data_word(0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8);
-	&amp;_data_word(0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4);
-	&amp;_data_word(0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2);
-	&amp;_data_word(0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda);
-	&amp;_data_word(0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949);
-	&amp;_data_word(0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf);
-	&amp;_data_word(0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810);
-	&amp;_data_word(0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c);
-	&amp;_data_word(0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697);
-	&amp;_data_word(0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e);
-	&amp;_data_word(0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f);
-	&amp;_data_word(0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc);
-	&amp;_data_word(0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c);
-	&amp;_data_word(0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969);
-	&amp;_data_word(0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27);
-	&amp;_data_word(0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122);
-	&amp;_data_word(0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433);
-	&amp;_data_word(0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9);
-	&amp;_data_word(0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5);
-	&amp;_data_word(0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a);
-	&amp;_data_word(0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0);
-	&amp;_data_word(0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e);
-	&amp;_data_word(0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c);
-
-#Te4	# four copies of Te4 to choose from to avoid L1 aliasing
-	&amp;data_byte(0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5);
-	&amp;data_byte(0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76);
-	&amp;data_byte(0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0);
-	&amp;data_byte(0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0);
-	&amp;data_byte(0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc);
-	&amp;data_byte(0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15);
-	&amp;data_byte(0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a);
-	&amp;data_byte(0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75);
-	&amp;data_byte(0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0);
-	&amp;data_byte(0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84);
-	&amp;data_byte(0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b);
-	&amp;data_byte(0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf);
-	&amp;data_byte(0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85);
-	&amp;data_byte(0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8);
-	&amp;data_byte(0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5);
-	&amp;data_byte(0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2);
-	&amp;data_byte(0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17);
-	&amp;data_byte(0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73);
-	&amp;data_byte(0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88);
-	&amp;data_byte(0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb);
-	&amp;data_byte(0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c);
-	&amp;data_byte(0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79);
-	&amp;data_byte(0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9);
-	&amp;data_byte(0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08);
-	&amp;data_byte(0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6);
-	&amp;data_byte(0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a);
-	&amp;data_byte(0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e);
-	&amp;data_byte(0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e);
-	&amp;data_byte(0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94);
-	&amp;data_byte(0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf);
-	&amp;data_byte(0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68);
-	&amp;data_byte(0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16);
-
-	&amp;data_byte(0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5);
-	&amp;data_byte(0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76);
-	&amp;data_byte(0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0);
-	&amp;data_byte(0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0);
-	&amp;data_byte(0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc);
-	&amp;data_byte(0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15);
-	&amp;data_byte(0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a);
-	&amp;data_byte(0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75);
-	&amp;data_byte(0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0);
-	&amp;data_byte(0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84);
-	&amp;data_byte(0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b);
-	&amp;data_byte(0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf);
-	&amp;data_byte(0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85);
-	&amp;data_byte(0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8);
-	&amp;data_byte(0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5);
-	&amp;data_byte(0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2);
-	&amp;data_byte(0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17);
-	&amp;data_byte(0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73);
-	&amp;data_byte(0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88);
-	&amp;data_byte(0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb);
-	&amp;data_byte(0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c);
-	&amp;data_byte(0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79);
-	&amp;data_byte(0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9);
-	&amp;data_byte(0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08);
-	&amp;data_byte(0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6);
-	&amp;data_byte(0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a);
-	&amp;data_byte(0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e);
-	&amp;data_byte(0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e);
-	&amp;data_byte(0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94);
-	&amp;data_byte(0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf);
-	&amp;data_byte(0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68);
-	&amp;data_byte(0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16);
-
-	&amp;data_byte(0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5);
-	&amp;data_byte(0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76);
-	&amp;data_byte(0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0);
-	&amp;data_byte(0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0);
-	&amp;data_byte(0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc);
-	&amp;data_byte(0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15);
-	&amp;data_byte(0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a);
-	&amp;data_byte(0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75);
-	&amp;data_byte(0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0);
-	&amp;data_byte(0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84);
-	&amp;data_byte(0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b);
-	&amp;data_byte(0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf);
-	&amp;data_byte(0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85);
-	&amp;data_byte(0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8);
-	&amp;data_byte(0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5);
-	&amp;data_byte(0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2);
-	&amp;data_byte(0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17);
-	&amp;data_byte(0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73);
-	&amp;data_byte(0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88);
-	&amp;data_byte(0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb);
-	&amp;data_byte(0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c);
-	&amp;data_byte(0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79);
-	&amp;data_byte(0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9);
-	&amp;data_byte(0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08);
-	&amp;data_byte(0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6);
-	&amp;data_byte(0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a);
-	&amp;data_byte(0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e);
-	&amp;data_byte(0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e);
-	&amp;data_byte(0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94);
-	&amp;data_byte(0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf);
-	&amp;data_byte(0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68);
-	&amp;data_byte(0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16);
-
-	&amp;data_byte(0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5);
-	&amp;data_byte(0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76);
-	&amp;data_byte(0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0);
-	&amp;data_byte(0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0);
-	&amp;data_byte(0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc);
-	&amp;data_byte(0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15);
-	&amp;data_byte(0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a);
-	&amp;data_byte(0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75);
-	&amp;data_byte(0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0);
-	&amp;data_byte(0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84);
-	&amp;data_byte(0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b);
-	&amp;data_byte(0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf);
-	&amp;data_byte(0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85);
-	&amp;data_byte(0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8);
-	&amp;data_byte(0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5);
-	&amp;data_byte(0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2);
-	&amp;data_byte(0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17);
-	&amp;data_byte(0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73);
-	&amp;data_byte(0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88);
-	&amp;data_byte(0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb);
-	&amp;data_byte(0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c);
-	&amp;data_byte(0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79);
-	&amp;data_byte(0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9);
-	&amp;data_byte(0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08);
-	&amp;data_byte(0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6);
-	&amp;data_byte(0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a);
-	&amp;data_byte(0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e);
-	&amp;data_byte(0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e);
-	&amp;data_byte(0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94);
-	&amp;data_byte(0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf);
-	&amp;data_byte(0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68);
-	&amp;data_byte(0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16);
-#rcon:
-	&amp;data_word(0x00000001, 0x00000002, 0x00000004, 0x00000008);
-	&amp;data_word(0x00000010, 0x00000020, 0x00000040, 0x00000080);
-	&amp;data_word(0x0000001b, 0x00000036, 0x00000000, 0x00000000);
-	&amp;data_word(0x00000000, 0x00000000, 0x00000000, 0x00000000);
-&amp;function_end_B(&quot;_x86_AES_encrypt&quot;);
-
-# void AES_encrypt (const void *inp,void *out,const AES_KEY *key);
-&amp;function_begin(&quot;AES_encrypt&quot;);
-	&amp;mov	($acc,&amp;wparam(0));		# load inp
-	&amp;mov	($key,&amp;wparam(2));		# load key
-
-	&amp;mov	($s0,&quot;esp&quot;);
-	&amp;sub	(&quot;esp&quot;,36);
-	&amp;and	(&quot;esp&quot;,-64);			# align to cache-line
-
-	# place stack frame just &quot;above&quot; the key schedule
-	&amp;lea	($s1,&amp;DWP(-64-63,$key));
-	&amp;sub	($s1,&quot;esp&quot;);
-	&amp;neg	($s1);
-	&amp;and	($s1,0x3C0);	# modulo 1024, but aligned to cache-line
-	&amp;sub	(&quot;esp&quot;,$s1);
-	&amp;add	(&quot;esp&quot;,4);	# 4 is reserved for caller's return address
-	&amp;mov	($_esp,$s0);			# save stack pointer
-
-	&amp;call   (&amp;label(&quot;pic_point&quot;));          # make it PIC!
-	&amp;set_label(&quot;pic_point&quot;);
-	&amp;blindpop($tbl);
-	&amp;picmeup($s0,&quot;OPENSSL_ia32cap_P&quot;,$tbl,&amp;label(&quot;pic_point&quot;)) if (!$x86only);
-	&amp;lea    ($tbl,&amp;DWP(&amp;label(&quot;AES_Te&quot;).&quot;-&quot;.&amp;label(&quot;pic_point&quot;),$tbl));
-
-	# pick Te4 copy which can't &quot;overlap&quot; with stack frame or key schedule
-	&amp;lea	($s1,&amp;DWP(768-4,&quot;esp&quot;));
-	&amp;sub	($s1,$tbl);
-	&amp;and	($s1,0x300);
-	&amp;lea	($tbl,&amp;DWP(2048+128,$tbl,$s1));
-
-					if (!$x86only) {
-	&amp;bt	(&amp;DWP(0,$s0),25);	# check for SSE bit
-	&amp;jnc	(&amp;label(&quot;x86&quot;));
-
-	&amp;movq	(&quot;mm0&quot;,&amp;QWP(0,$acc));
-	&amp;movq	(&quot;mm4&quot;,&amp;QWP(8,$acc));
-	&amp;call	(&quot;_sse_AES_encrypt_compact&quot;);
-	&amp;mov	(&quot;esp&quot;,$_esp);			# restore stack pointer
-	&amp;mov	($acc,&amp;wparam(1));		# load out
-	&amp;movq	(&amp;QWP(0,$acc),&quot;mm0&quot;);		# write output data
-	&amp;movq	(&amp;QWP(8,$acc),&quot;mm4&quot;);
-	&amp;emms	();
-	&amp;function_end_A();
-					}
-	&amp;set_label(&quot;x86&quot;,16);
-	&amp;mov	($_tbl,$tbl);
-	&amp;mov	($s0,&amp;DWP(0,$acc));		# load input data
-	&amp;mov	($s1,&amp;DWP(4,$acc));
-	&amp;mov	($s2,&amp;DWP(8,$acc));
-	&amp;mov	($s3,&amp;DWP(12,$acc));
-	&amp;call	(&quot;_x86_AES_encrypt_compact&quot;);
-	&amp;mov	(&quot;esp&quot;,$_esp);			# restore stack pointer
-	&amp;mov	($acc,&amp;wparam(1));		# load out
-	&amp;mov	(&amp;DWP(0,$acc),$s0);		# write output data
-	&amp;mov	(&amp;DWP(4,$acc),$s1);
-	&amp;mov	(&amp;DWP(8,$acc),$s2);
-	&amp;mov	(&amp;DWP(12,$acc),$s3);
-&amp;function_end(&quot;AES_encrypt&quot;);
-
-#--------------------------------------------------------------------#
-
-######################################################################
-# &quot;Compact&quot; block function
-######################################################################
-
-sub deccompact()
-{ my $Fn = \&mov;
-  while ($#_&gt;5) { pop(@_); $Fn=sub{}; }
-  my ($i,$<A HREF="../../../mailman/listinfo/openssl-commits.html">td, at s</A>)=@_;
-  my $tmp = $key;
-  my $out = $i==3?$s[0]:$acc;
-
-	# $Fn is used in first compact round and its purpose is to
-	# void restoration of some values from stack, so that after
-	# 4xdeccompact with extra argument $key, $s0 and $s1 values
-	# are left there...
-	if($i==3)   {	&amp;$Fn	($key,$__key);			}
-	else        {	&amp;mov	($out,$s[0]);			}
-			&amp;and	($out,0xFF);
-			&amp;movz	($out,&amp;BP(-128,$td,$out,1));
-
-	if ($i==3)  {	$tmp=$s[1];				}
-			&amp;movz	($tmp,&amp;HB($s[1]));
-			&amp;movz	($tmp,&amp;BP(-128,$td,$tmp,1));
-			&amp;shl	($tmp,8);
-			&amp;xor	($out,$tmp);
-
-	if ($i==3)  {	$tmp=$s[2]; &amp;mov ($s[1],$acc);		}
-	else        {	mov	($tmp,$s[2]);			}
-			&amp;shr	($tmp,16);
-			&amp;and	($tmp,0xFF);
-			&amp;movz	($tmp,&amp;BP(-128,$td,$tmp,1));
-			&amp;shl	($tmp,16);
-			&amp;xor	($out,$tmp);
-
-	if ($i==3)  {	$tmp=$s[3]; &amp;$Fn ($s[2],$__s1);		}
-	else        {	&amp;mov	($tmp,$s[3]);			}
-			&amp;shr	($tmp,24);
-			&amp;movz	($tmp,&amp;BP(-128,$td,$tmp,1));
-			&amp;shl	($tmp,24);
-			&amp;xor	($out,$tmp);
-	if ($i&lt;2)   {	&amp;mov	(&amp;DWP(4+4*$i,&quot;esp&quot;),$out);	}
-	if ($i==3)  {	&amp;$Fn	($s[3],$__s0);			}
-}
-
-# must be called with 2,3,0,1 as argument sequence!!!
-sub dectransform()
-{ my @s = ($s0,$s1,$s2,$s3);
-  my $i = shift;
-  my $tmp = $key;
-  my $tp2 = @s[($i+2)%4]; $tp2 = @s[2] if ($i==1);
-  my $tp4 = @s[($i+3)%4]; $tp4 = @s[3] if ($i==1);
-  my $tp8 = $tbl;
-
-	&amp;mov	($tmp,0x80808080);
-	&amp;and	($tmp,$s[$i]);
-	&amp;mov	($acc,$tmp);
-	&amp;shr	($tmp,7);
-	&amp;lea	($tp2,&amp;DWP(0,$s[$i],$s[$i]));
-	&amp;sub	($acc,$tmp);
-	&amp;and	($tp2,0xfefefefe);
-	&amp;and	($acc,0x1b1b1b1b);
-	&amp;xor	($tp2,$acc);
-	&amp;mov	($tmp,0x80808080);
-
-	&amp;and	($tmp,$tp2);
-	&amp;mov	($acc,$tmp);
-	&amp;shr	($tmp,7);
-	&amp;lea	($tp4,&amp;DWP(0,$tp2,$tp2));
-	&amp;sub	($acc,$tmp);
-	&amp;and	($tp4,0xfefefefe);
-	&amp;and	($acc,0x1b1b1b1b);
-	 &amp;xor	($tp2,$s[$i]);	# tp2^tp1
-	&amp;xor	($tp4,$acc);
-	&amp;mov	($tmp,0x80808080);
-
-	&amp;and	($tmp,$tp4);
-	&amp;mov	($acc,$tmp);
-	&amp;shr	($tmp,7);
-	&amp;lea	($tp8,&amp;DWP(0,$tp4,$tp4));
-	&amp;sub	($acc,$tmp);
-	&amp;and	($tp8,0xfefefefe);
-	&amp;and	($acc,0x1b1b1b1b);
-	 &amp;xor	($tp4,$s[$i]);	# tp4^tp1
-	 &amp;rotl	($s[$i],8);	# = ROTATE(tp1,8)
-	&amp;xor	($tp8,$acc);
-
-	&amp;xor	($s[$i],$tp2);
-	&amp;xor	($tp2,$tp8);
-	&amp;xor	($s[$i],$tp4);
-	&amp;xor	($tp4,$tp8);
-	&amp;rotl	($tp2,24);
-	&amp;xor	($s[$i],$tp8);	# ^= tp8^(tp4^tp1)^(tp2^tp1)
-	&amp;rotl	($tp4,16);
-	&amp;xor	($s[$i],$tp2);	# ^= ROTATE(tp8^tp2^tp1,24)
-	&amp;rotl	($tp8,8);
-	&amp;xor	($s[$i],$tp4);	# ^= ROTATE(tp8^tp4^tp1,16)
-	 &amp;mov	($s[0],$__s0)			if($i==2); #prefetch $s0
-	 &amp;mov	($s[1],$__s1)			if($i==3); #prefetch $s1
-	 &amp;mov	($s[2],$__s2)			if($i==1);
-	&amp;xor	($s[$i],$tp8);	# ^= ROTATE(tp8,8)
-
-	&amp;mov	($s[3],$__s3)			if($i==1);
-	&amp;mov	(&amp;DWP(4+4*$i,&quot;esp&quot;),$s[$i])	if($i&gt;=2);
-}
-
-&amp;function_begin_B(&quot;_x86_AES_decrypt_compact&quot;);
-	# note that caller is expected to allocate stack frame for me!
-	&amp;mov	($__key,$key);			# save key
-
-	&amp;xor	($s0,&amp;DWP(0,$key));		# xor with key
-	&amp;xor	($s1,&amp;DWP(4,$key));
-	&amp;xor	($s2,&amp;DWP(8,$key));
-	&amp;xor	($s3,&amp;DWP(12,$key));
-
-	&amp;mov	($acc,&amp;DWP(240,$key));		# load key-&gt;rounds
-
-	&amp;lea	($acc,&amp;DWP(-2,$acc,$acc));
-	&amp;lea	($acc,&amp;DWP(0,$key,$acc,8));
-	&amp;mov	($__end,$acc);			# end of key schedule
-
-	# prefetch Td4
-	&amp;mov	($key,&amp;DWP(0-128,$tbl));
-	&amp;mov	($acc,&amp;DWP(32-128,$tbl));
-	&amp;mov	($key,&amp;DWP(64-128,$tbl));
-	&amp;mov	($acc,&amp;DWP(96-128,$tbl));
-	&amp;mov	($key,&amp;DWP(128-128,$tbl));
-	&amp;mov	($acc,&amp;DWP(160-128,$tbl));
-	&amp;mov	($key,&amp;DWP(192-128,$tbl));
-	&amp;mov	($acc,&amp;DWP(224-128,$tbl));
-
-	&amp;set_label(&quot;loop&quot;,16);
-
-		&amp;deccompact(0,$tbl,$s0,$s3,$s2,$s1,1);
-		&amp;deccompact(1,$tbl,$s1,$s0,$s3,$s2,1);
-		&amp;deccompact(2,$tbl,$s2,$s1,$s0,$s3,1);
-		&amp;deccompact(3,$tbl,$s3,$s2,$s1,$s0,1);
-		&amp;dectransform(2);
-		&amp;dectransform(3);
-		&amp;dectransform(0);
-		&amp;dectransform(1);
-		&amp;mov 	($key,$__key);
-		&amp;mov	($tbl,$__tbl);
-		&amp;add	($key,16);		# advance rd_key
-		&amp;xor	($s0,&amp;DWP(0,$key));
-		&amp;xor	($s1,&amp;DWP(4,$key));
-		&amp;xor	($s2,&amp;DWP(8,$key));
-		&amp;xor	($s3,&amp;DWP(12,$key));
-
-	&amp;cmp	($key,$__end);
-	&amp;mov	($__key,$key);
-	&amp;jb	(&amp;label(&quot;loop&quot;));
-
-	&amp;deccompact(0,$tbl,$s0,$s3,$s2,$s1);
-	&amp;deccompact(1,$tbl,$s1,$s0,$s3,$s2);
-	&amp;deccompact(2,$tbl,$s2,$s1,$s0,$s3);
-	&amp;deccompact(3,$tbl,$s3,$s2,$s1,$s0);
-
-	&amp;xor	($s0,&amp;DWP(16,$key));
-	&amp;xor	($s1,&amp;DWP(20,$key));
-	&amp;xor	($s2,&amp;DWP(24,$key));
-	&amp;xor	($s3,&amp;DWP(28,$key));
-
-	&amp;ret	();
-&amp;function_end_B(&quot;_x86_AES_decrypt_compact&quot;);
-
-######################################################################
-# &quot;Compact&quot; SSE block function.
-######################################################################
-
-sub sse_deccompact()
-{
-	&amp;pshufw	(&quot;mm1&quot;,&quot;mm0&quot;,0x0c);		#  7, 6, 1, 0
-	&amp;pshufw	(&quot;mm5&quot;,&quot;mm4&quot;,0x09);		# 13,12,11,10
-	&amp;movd	(&quot;eax&quot;,&quot;mm1&quot;);			#  7, 6, 1, 0
-	&amp;movd	(&quot;ebx&quot;,&quot;mm5&quot;);			# 13,12,11,10
-	&amp;mov	($__key,$key);
-
-	&amp;movz	($acc,&amp;LB(&quot;eax&quot;));		#  0
-	&amp;movz	(&quot;edx&quot;,&amp;HB(&quot;eax&quot;));		#  1
-	&amp;pshufw	(&quot;mm2&quot;,&quot;mm0&quot;,0x06);		#  3, 2, 5, 4
-	&amp;movz	(&quot;ecx&quot;,&amp;BP(-128,$tbl,$acc,1));	#  0
-	&amp;movz	($key,&amp;LB(&quot;ebx&quot;));		# 10
-	&amp;movz	(&quot;edx&quot;,&amp;BP(-128,$tbl,&quot;edx&quot;,1));	#  1
-	&amp;shr	(&quot;eax&quot;,16);			#  7, 6
-	&amp;shl	(&quot;edx&quot;,8);			#  1
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	# 10
-	&amp;movz	($key,&amp;HB(&quot;ebx&quot;));		# 11
-	&amp;shl	($acc,16);			# 10
-	&amp;pshufw	(&quot;mm6&quot;,&quot;mm4&quot;,0x03);		# 9, 8,15,14
-	&amp;or	(&quot;ecx&quot;,$acc);			# 10
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	# 11
-	&amp;movz	($key,&amp;HB(&quot;eax&quot;));		#  7
-	&amp;shl	($acc,24);			# 11
-	&amp;shr	(&quot;ebx&quot;,16);			# 13,12
-	&amp;or	(&quot;edx&quot;,$acc);			# 11
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  7
-	&amp;movz	($key,&amp;HB(&quot;ebx&quot;));		# 13
-	&amp;shl	($acc,24);			#  7
-	&amp;or	(&quot;ecx&quot;,$acc);			#  7
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	# 13
-	&amp;movz	($key,&amp;LB(&quot;eax&quot;));		#  6
-	&amp;shl	($acc,8);			# 13
-	&amp;movd	(&quot;eax&quot;,&quot;mm2&quot;);			#  3, 2, 5, 4
-	&amp;or	(&quot;ecx&quot;,$acc);			# 13
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  6
-	&amp;movz	($key,&amp;LB(&quot;ebx&quot;));		# 12
-	&amp;shl	($acc,16);			#  6
-	&amp;movd	(&quot;ebx&quot;,&quot;mm6&quot;);			#  9, 8,15,14
-	&amp;movd	(&quot;mm0&quot;,&quot;ecx&quot;);			# t[0] collected
-	&amp;movz	(&quot;ecx&quot;,&amp;BP(-128,$tbl,$key,1));	# 12
-	&amp;movz	($key,&amp;LB(&quot;eax&quot;));		#  4
-	&amp;or	(&quot;ecx&quot;,$acc);			# 12
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  4
-	&amp;movz	($key,&amp;LB(&quot;ebx&quot;));		# 14
-	&amp;or	(&quot;edx&quot;,$acc);			#  4
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	# 14
-	&amp;movz	($key,&amp;HB(&quot;eax&quot;));		#  5
-	&amp;shl	($acc,16);			# 14
-	&amp;shr	(&quot;eax&quot;,16);			#  3, 2
-	&amp;or	(&quot;edx&quot;,$acc);			# 14
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  5
-	&amp;movz	($key,&amp;HB(&quot;ebx&quot;));		# 15
-	&amp;shr	(&quot;ebx&quot;,16);			#  9, 8
-	&amp;shl	($acc,8);			#  5
-	&amp;movd	(&quot;mm1&quot;,&quot;edx&quot;);			# t[1] collected
-	&amp;movz	(&quot;edx&quot;,&amp;BP(-128,$tbl,$key,1));	# 15
-	&amp;movz	($key,&amp;HB(&quot;ebx&quot;));		#  9
-	&amp;shl	(&quot;edx&quot;,24);			# 15
-	&amp;and	(&quot;ebx&quot;,0xff);			#  8
-	&amp;or	(&quot;edx&quot;,$acc);			# 15
-
-	&amp;punpckldq	(&quot;mm0&quot;,&quot;mm1&quot;);		# t[0,1] collected
-
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  9
-	&amp;movz	($key,&amp;LB(&quot;eax&quot;));		#  2
-	&amp;shl	($acc,8);			#  9
-	&amp;movz	(&quot;eax&quot;,&amp;HB(&quot;eax&quot;));		#  3
-	&amp;movz	(&quot;ebx&quot;,&amp;BP(-128,$tbl,&quot;ebx&quot;,1));	#  8
-	&amp;or	(&quot;ecx&quot;,$acc);			#  9
-	&amp;movz	($acc,&amp;BP(-128,$tbl,$key,1));	#  2
-	&amp;or	(&quot;edx&quot;,&quot;ebx&quot;);			#  8
-	&amp;shl	($acc,16);			#  2
-	&amp;movz	(&quot;eax&quot;,&amp;BP(-128,$tbl,&quot;eax&quot;,1));	#  3
-	&amp;or	(&quot;edx&quot;,$acc);			#  2
-	&amp;shl	(&quot;eax&quot;,24);			#  3
-	&amp;or	(&quot;ecx&quot;,&quot;eax&quot;);			#  3
-	&amp;mov	($key,$__key);
-	&amp;movd	(&quot;mm4&quot;,&quot;edx&quot;);			# t[2] collected
-	&amp;movd	(&quot;mm5&quot;,&quot;ecx&quot;);			# t[3] collected
-
-	&amp;punpckldq	(&quot;mm4&quot;,&quot;mm5&quot;);		# t[2,3] collected
-}
-
-					if (!$x86only) {
-&amp;function_begin_B(&quot;_sse_AES_decrypt_compact&quot;);
-	&amp;pxor	(&quot;mm0&quot;,&amp;QWP(0,$key));	#  7, 6, 5, 4, 3, 2, 1, 0
-	&amp;pxor	(&quot;mm4&quot;,&amp;QWP(8,$key));	# 15,14,13,12,11,10, 9, 8
-
-	# note that caller is expected to allocate stack frame for me!
-	&amp;mov	($acc,&amp;DWP(240,$key));		# load key-&gt;rounds
-	&amp;lea	($acc,&amp;DWP(-2,$acc,$acc));
-	&amp;lea	($acc,&amp;DWP(0,$key,$acc,8));
-	&amp;mov	($__end,$acc);			# end of key schedule
-
-	&amp;mov	($s0,0x1b1b1b1b);		# magic constant
-	&amp;mov	(&amp;DWP(8,&quot;esp&quot;),$s0);
-	&amp;mov	(&amp;DWP(12,&quot;esp&quot;),$s0);
-
-	# prefetch Td4
-	&amp;mov	($s0,&amp;DWP(0-128,$tbl));
-	&amp;mov	($s1,&amp;DWP(32-128,$tbl));
-	&amp;mov	($s2,&amp;DWP(64-128,$tbl));
-	&amp;mov	($s3,&amp;DWP(96-128,$tbl));
-	&amp;mov	($s0,&amp;DWP(128-128,$tbl));
-	&amp;mov	($s1,&amp;DWP(160-128,$tbl));
-	&amp;mov	($s2,&amp;DWP(192-128,$tbl));
-	&amp;mov	($s3,&amp;DWP(224-128,$tbl));
-
-	&amp;set_label(&quot;loop&quot;,16);
-		&amp;sse_deccompact();
-		&amp;add	($key,16);
-		&amp;cmp	($key,$__end);
-		&amp;ja	(&amp;label(&quot;out&quot;));
-
-		# ROTATE(x^y,N) == ROTATE(x,N)^ROTATE(y,N)
-		&amp;movq	(&quot;mm3&quot;,&quot;mm0&quot;);		&amp;movq	(&quot;mm7&quot;,&quot;mm4&quot;);
-		&amp;movq	(&quot;mm2&quot;,&quot;mm0&quot;,1);	&amp;movq	(&quot;mm6&quot;,&quot;mm4&quot;,1);
-		&amp;movq	(&quot;mm1&quot;,&quot;mm0&quot;);		&amp;movq	(&quot;mm5&quot;,&quot;mm4&quot;);
-		&amp;pshufw	(&quot;mm0&quot;,&quot;mm0&quot;,0xb1);	&amp;pshufw	(&quot;mm4&quot;,&quot;mm4&quot;,0xb1);# = ROTATE(tp0,16)
-		&amp;pslld	(&quot;mm2&quot;,8);		&amp;pslld	(&quot;mm6&quot;,8);
-		&amp;psrld	(&quot;mm3&quot;,8);		&amp;psrld	(&quot;mm7&quot;,8);
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm2&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm6&quot;);	# ^= tp0&lt;&lt;8
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm7&quot;);	# ^= tp0&gt;&gt;8
-		&amp;pslld	(&quot;mm2&quot;,16);		&amp;pslld	(&quot;mm6&quot;,16);
-		&amp;psrld	(&quot;mm3&quot;,16);		&amp;psrld	(&quot;mm7&quot;,16);
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm2&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm6&quot;);	# ^= tp0&lt;&lt;24
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm7&quot;);	# ^= tp0&gt;&gt;24
-
-		&amp;movq	(&quot;mm3&quot;,&amp;QWP(8,&quot;esp&quot;));
-		&amp;pxor	(&quot;mm2&quot;,&quot;mm2&quot;);		&amp;pxor	(&quot;mm6&quot;,&quot;mm6&quot;);
-		&amp;pcmpgtb(&quot;mm2&quot;,&quot;mm1&quot;);		&amp;pcmpgtb(&quot;mm6&quot;,&quot;mm5&quot;);
-		&amp;pand	(&quot;mm2&quot;,&quot;mm3&quot;);		&amp;pand	(&quot;mm6&quot;,&quot;mm3&quot;);
-		&amp;paddb	(&quot;mm1&quot;,&quot;mm1&quot;);		&amp;paddb	(&quot;mm5&quot;,&quot;mm5&quot;);
-		&amp;pxor	(&quot;mm1&quot;,&quot;mm2&quot;);		&amp;pxor	(&quot;mm5&quot;,&quot;mm6&quot;);	# tp2
-		&amp;movq	(&quot;mm3&quot;,&quot;mm1&quot;);		&amp;movq	(&quot;mm7&quot;,&quot;mm5&quot;);
-		&amp;movq	(&quot;mm2&quot;,&quot;mm1&quot;);		&amp;movq	(&quot;mm6&quot;,&quot;mm5&quot;);
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm1&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm5&quot;);	# ^= tp2
-		&amp;pslld	(&quot;mm3&quot;,24);		&amp;pslld	(&quot;mm7&quot;,24);
-		&amp;psrld	(&quot;mm2&quot;,8);		&amp;psrld	(&quot;mm6&quot;,8);
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm7&quot;);	# ^= tp2&lt;&lt;24
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm2&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm6&quot;);	# ^= tp2&gt;&gt;8
-
-		&amp;movq	(&quot;mm2&quot;,&amp;QWP(8,&quot;esp&quot;));
-		&amp;pxor	(&quot;mm3&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm7&quot;,&quot;mm7&quot;);
-		&amp;pcmpgtb(&quot;mm3&quot;,&quot;mm1&quot;);		&amp;pcmpgtb(&quot;mm7&quot;,&quot;mm5&quot;);
-		&amp;pand	(&quot;mm3&quot;,&quot;mm2&quot;);		&amp;pand	(&quot;mm7&quot;,&quot;mm2&quot;);
-		&amp;paddb	(&quot;mm1&quot;,&quot;mm1&quot;);		&amp;paddb	(&quot;mm5&quot;,&quot;mm5&quot;);
-		&amp;pxor	(&quot;mm1&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm5&quot;,&quot;mm7&quot;);	# tp4
-		&amp;pshufw	(&quot;mm3&quot;,&quot;mm1&quot;,0xb1);	&amp;pshufw	(&quot;mm7&quot;,&quot;mm5&quot;,0xb1);
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm1&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm5&quot;);	# ^= tp4
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm7&quot;);	# ^= ROTATE(tp4,16)
-
-		&amp;pxor	(&quot;mm3&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm7&quot;,&quot;mm7&quot;);
-		&amp;pcmpgtb(&quot;mm3&quot;,&quot;mm1&quot;);		&amp;pcmpgtb(&quot;mm7&quot;,&quot;mm5&quot;);
-		&amp;pand	(&quot;mm3&quot;,&quot;mm2&quot;);		&amp;pand	(&quot;mm7&quot;,&quot;mm2&quot;);
-		&amp;paddb	(&quot;mm1&quot;,&quot;mm1&quot;);		&amp;paddb	(&quot;mm5&quot;,&quot;mm5&quot;);
-		&amp;pxor	(&quot;mm1&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm5&quot;,&quot;mm7&quot;);	# tp8
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm1&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm5&quot;);	# ^= tp8
-		&amp;movq	(&quot;mm3&quot;,&quot;mm1&quot;);		&amp;movq	(&quot;mm7&quot;,&quot;mm5&quot;);
-		&amp;pshufw	(&quot;mm2&quot;,&quot;mm1&quot;,0xb1);	&amp;pshufw	(&quot;mm6&quot;,&quot;mm5&quot;,0xb1);
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm2&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm6&quot;);	# ^= ROTATE(tp8,16)
-		&amp;pslld	(&quot;mm1&quot;,8);		&amp;pslld	(&quot;mm5&quot;,8);
-		&amp;psrld	(&quot;mm3&quot;,8);		&amp;psrld	(&quot;mm7&quot;,8);
-		&amp;movq	(&quot;mm2&quot;,&amp;QWP(0,$key));	&amp;movq	(&quot;mm6&quot;,&amp;QWP(8,$key));
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm1&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm5&quot;);	# ^= tp8&lt;&lt;8
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm7&quot;);	# ^= tp8&gt;&gt;8
-		&amp;mov	($s0,&amp;DWP(0-128,$tbl));
-		&amp;pslld	(&quot;mm1&quot;,16);		&amp;pslld	(&quot;mm5&quot;,16);
-		&amp;mov	($s1,&amp;DWP(64-128,$tbl));
-		&amp;psrld	(&quot;mm3&quot;,16);		&amp;psrld	(&quot;mm7&quot;,16);
-		&amp;mov	($s2,&amp;DWP(128-128,$tbl));
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm1&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm5&quot;);	# ^= tp8&lt;&lt;24
-		&amp;mov	($s3,&amp;DWP(192-128,$tbl));
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm3&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm7&quot;);	# ^= tp8&gt;&gt;24
-
-		&amp;pxor	(&quot;mm0&quot;,&quot;mm2&quot;);		&amp;pxor	(&quot;mm4&quot;,&quot;mm6&quot;);
-	&amp;jmp	(&amp;label(&quot;loop&quot;));
-
-	&amp;set_label(&quot;out&quot;,16);
-	&amp;pxor	(&quot;mm0&quot;,&amp;QWP(0,$key));
-	&amp;pxor	(&quot;mm4&quot;,&amp;QWP(8,$key));
-
-	&amp;ret	();
-&amp;function_end_B(&quot;_sse_AES_decrypt_compact&quot;);
-					}
-
-######################################################################
-# Vanilla block function.
-######################################################################
-
-sub decstep()
-{ my ($i,$<A HREF="../../../mailman/listinfo/openssl-commits.html">td, at s</A>) = @_;
-  my $tmp = $key;
-  my $out = $i==3?$s[0]:$acc;
-
-	# no instructions are reordered, as performance appears
-	# optimal... or rather that all attempts to reorder didn't
-	# result in better performance [which by the way is not a
-	# bit lower than encryption].
-	if($i==3)   {	&amp;mov	($key,$__key);			}
-	else        {	&amp;mov	($out,$s[0]);			}
-			&amp;and	($out,0xFF);
-			&amp;mov	($out,&amp;DWP(0,$td,$out,8));
-
-	if ($i==3)  {	$tmp=$s[1];				}
-			&amp;movz	($tmp,&amp;HB($s[1]));
-			&amp;xor	($out,&amp;DWP(3,$td,$tmp,8));
-
-	if ($i==3)  {	$tmp=$s[2]; &amp;mov ($s[1],$acc);		}
-	else        {	&amp;mov	($tmp,$s[2]);			}
-			&amp;shr	($tmp,16);
-			&amp;and	($tmp,0xFF);
-			&amp;xor	($out,&amp;DWP(2,$td,$tmp,8));
-
-	if ($i==3)  {	$tmp=$s[3]; &amp;mov ($s[2],$__s1);		}
-	else        {	&amp;mov	($tmp,$s[3]);			}
-			&amp;shr	($tmp,24);
-			&amp;xor	($out,&amp;DWP(1,$td,$tmp,8));
-	if ($i&lt;2)   {	&amp;mov	(&amp;DWP(4+4*$i,&quot;esp&quot;),$out);	}
-	if ($i==3)  {	&amp;mov	($s[3],$__s0);			}
-			&amp;comment();
-}
-
-sub declast()
-{ my ($i,$<A HREF="../../../mailman/listinfo/openssl-commits.html">td, at s</A>)=@_;
-  my $tmp = $key;
-  my $out = $i==3?$s[0]:$acc;
-
-	if($i==0)   {	&amp;lea	($td,&amp;DWP(2048+128,$td));
-			&amp;mov	($tmp,&amp;DWP(0-128,$td));
-			&amp;mov	($acc,&amp;DWP(32-128,$td));
-			&amp;mov	($tmp,&amp;DWP(64-128,$td));
-			&amp;mov	($acc,&amp;DWP(96-128,$td));
-			&amp;mov	($tmp,&amp;DWP(128-128,$td));
-			&amp;mov	($acc,&amp;DWP(160-128,$td));
-			&amp;mov	($tmp,&amp;DWP(192-128,$td));
-			&amp;mov	($acc,&amp;DWP(224-128,$td));
-			&amp;lea	($td,&amp;DWP(-128,$td));		}
-	if($i==3)   {	&amp;mov	($key,$__key);			}
-	else        {	&amp;mov	($out,$s[0]);			}
-			&amp;and	($out,0xFF);
-			&amp;movz	($out,&amp;BP(0,$td,$out,1));
-
-	if ($i==3)  {	$tmp=$s[1];				}
-			&amp;movz	($tmp,&amp;HB($s[1]));
-			&amp;movz	($tmp,&amp;BP(0,$td,$tmp,1));
-			&amp;shl	($tmp,8);
-			&amp;xor	($out,$tmp);
-
-	if ($i==3)  {	$tmp=$s[2]; &amp;mov ($s[1],$acc);		}
-	else        {	mov	($tmp,$s[2]);			}
-			&amp;shr	($tmp,16);
-			&amp;and	($tmp,0xFF);
-			&amp;movz	($tmp,&amp;BP(0,$td,$tmp,1));
-			&amp;shl	($tmp,16);
-			&amp;xor	($out,$tmp);
-
-	if ($i==3)  {	$tmp=$s[3]; &amp;mov ($s[2],$__s1);		}
-	else        {	&amp;mov	($tmp,$s[3]);			}
-			&amp;shr	($tmp,24);
-			&amp;movz	($tmp,&amp;BP(0,$td,$tmp,1));
-			&amp;shl	($tmp,24);
-			&amp;xor	($out,$tmp);
-	if ($i&lt;2)   {	&amp;mov	(&amp;DWP(4+4*$i,&quot;esp&quot;),$out);	}
-	if ($i==3)  {	&amp;mov	($s[3],$__s0);
-			&amp;lea	($td,&amp;DWP(-2048,$td));		}
-}
-
-&amp;function_begin_B(&quot;_x86_AES_decrypt&quot;);
-	# note that caller is expected to allocate stack frame for me!
-	&amp;mov	($__key,$key);			# save key
-
-	&amp;xor	($s0,&amp;DWP(0,$key));		# xor with key
-	&amp;xor	($s1,&amp;DWP(4,$key));
-	&amp;xor	($s2,&amp;DWP(8,$key));
-	&amp;xor	($s3,&amp;DWP(12,$key));
-
-	&amp;mov	($acc,&amp;DWP(240,$key));		# load key-&gt;rounds
-
-	if ($small_footprint) {
-	    &amp;lea	($acc,&amp;DWP(-2,$acc,$acc));
-	    &amp;lea	($acc,&amp;DWP(0,$key,$acc,8));
-	    &amp;mov	($__end,$acc);		# end of key schedule
-	    &amp;set_label(&quot;loop&quot;,16);
-		&amp;decstep(0,$tbl,$s0,$s3,$s2,$s1);
-		&amp;decstep(1,$tbl,$s1,$s0,$s3,$s2);
-		&amp;decstep(2,$tbl,$s2,$s1,$s0,$s3);
-		&amp;decstep(3,$tbl,$s3,$s2,$s1,$s0);
-		&amp;add	($key,16);		# advance rd_key
-		&amp;xor	($s0,&amp;DWP(0,$key));
-		&amp;xor	($s1,&amp;DWP(4,$key));
-		&amp;xor	($s2,&amp;DWP(8,$key));
-		&amp;xor	($s3,&amp;DWP(12,$key));
-	    &amp;cmp	($key,$__end);
-	    &amp;mov	($__key,$key);
-	    &amp;jb		(&amp;label(&quot;loop&quot;));
-	}
-	else {
-	    &amp;cmp	($acc,10);
-	    &amp;jle	(&amp;label(&quot;10rounds&quot;));
-	    &amp;cmp	($acc,12);
-	    &amp;jle	(&amp;label(&quot;12rounds&quot;));
-
-	&amp;set_label(&quot;14rounds&quot;,4);
-	    for ($i=1;$i&lt;3;$i++) {
-		&amp;decstep(0,$tbl,$s0,$s3,$s2,$s1);
-		&amp;decstep(1,$tbl,$s1,$s0,$s3,$s2);
-		&amp;decstep(2,$tbl,$s2,$s1,$s0,$s3);
-		&amp;decstep(3,$tbl,$s3,$s2,$s1,$s0);
-		&amp;xor	($s0,&amp;DWP(16*$i+0,$key));
-		&amp;xor	($s1,&amp;DWP(16*$i+4,$key));
-		&amp;xor	($s2,&amp;DWP(16*$i+8,$key));
-		&amp;xor	($s3,&amp;DWP(16*$i+12,$key));
-	    }
-	    &amp;add	($key,32);
-	    &amp;mov	($__key,$key);		# advance rd_key
-	&amp;set_label(&quot;12rounds&quot;,4);
-	    for ($i=1;$i&lt;3;$i++) {
-		&amp;decstep(0,$tbl,$s0,$s3,$s2,$s1);
-		&amp;decstep(1,$tbl,$s1,$s0,$s3,$s2);
-		&amp;decstep(2,$tbl,$s2,$s1,$s0,$s3);
-		&amp;decstep(3,$tbl,$s3,$s2,$s1,$s0);
-		&amp;xor	($s0,&amp;DWP(16*$i+0,$key));
-		&amp;xor	($s1,&amp;DWP(16*$i+4,$key));
-		&amp;xor	($s2,&amp;DWP(16*$i+8,$key));
-		&amp;xor	($s3,&amp;DWP(16*$i+12,$key));
-	    }
-	    &amp;add	($key,32);
-	    &amp;mov	($__key,$key);		# advance rd_key
-	&amp;set_label(&quot;10rounds&quot;,4);
-	    for ($i=1;$i&lt;10;$i++) {
-		&amp;decstep(0,$tbl,$s0,$s3,$s2,$s1);
-		&amp;decstep(1,$tbl,$s1,$s0,$s3,$s2);
-		&amp;decstep(2,$tbl,$s2,$s1,$s0,$s3);
-		&amp;decstep(3,$tbl,$s3,$s2,$s1,$s0);
-		&amp;xor	($s0,&amp;DWP(16*$i+0,$key));
-		&amp;xor	($s1,&amp;DWP(16*$i+4,$key));
-		&amp;xor	($s2,&amp;DWP(16*$i+8,$key));
-		&amp;xor	($s3,&amp;DWP(16*$i+12,$key));
-	    }
-	}
-
-	&amp;declast(0,$tbl,$s0,$s3,$s2,$s1);
-	&amp;declast(1,$tbl,$s1,$s0,$s3,$s2);
-	&amp;declast(2,$tbl,$s2,$s1,$s0,$s3);
-	&amp;declast(3,$tbl,$s3,$s2,$s1,$s0);
-
-	&amp;add	($key,$small_footprint?16:160);
-	&amp;xor	($s0,&amp;DWP(0,$key));
-	&amp;xor	($s1,&amp;DWP(4,$key));
-	&amp;xor	($s2,&amp;DWP(8,$key));
-	&amp;xor	($s3,&amp;DWP(12,$key));
-
-	&amp;ret	();
-
-&amp;set_label(&quot;AES_Td&quot;,64);	# Yes! I keep it in the code segment!
-	&amp;_data_word(0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a);
-	&amp;_data_word(0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b);
-	&amp;_data_word(0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5);
-	&amp;_data_word(0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5);
-	&amp;_data_word(0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d);
-	&amp;_data_word(0x02752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b);
-	&amp;_data_word(0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295);
-	&amp;_data_word(0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e);
-	&amp;_data_word(0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927);
-	&amp;_data_word(0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d);
-	&amp;_data_word(0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362);
-	&amp;_data_word(0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9);
-	&amp;_data_word(0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52);
-	&amp;_data_word(0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566);
-	&amp;_data_word(0x0728ebb2, 0x03c2b52f, 0x9a7bc586, 0xa50837d3);
-	&amp;_data_word(0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed);
-	&amp;_data_word(0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e);
-	&amp;_data_word(0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4);
-	&amp;_data_word(0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4);
-	&amp;_data_word(0x39ec830b, 0xaaef6040, 0x069f715e, 0x51106ebd);
-	&amp;_data_word(0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d);
-	&amp;_data_word(0xb58d5491, 0x055dc471, 0x6fd40604, 0xff155060);
-	&amp;_data_word(0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967);
-	&amp;_data_word(0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879);
-	&amp;_data_word(0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x00000000);
-	&amp;_data_word(0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c);
-	&amp;_data_word(0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36);
-	&amp;_data_word(0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624);
-	&amp;_data_word(0xb1670a0c, 0x0fe75793, 0xd296eeb4, 0x9e919b1b);
-	&amp;_data_word(0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c);
-	&amp;_data_word(0x0aba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12);
-	&amp;_data_word(0x0b0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14);
-	&amp;_data_word(0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3);
-	&amp;_data_word(0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b);
-	&amp;_data_word(0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8);
-	&amp;_data_word(0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684);
-	&amp;_data_word(0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7);
-	&amp;_data_word(0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177);
-	&amp;_data_word(0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947);
-	&amp;_data_word(0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322);
-	&amp;_data_word(0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498);
-	&amp;_data_word(0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f);
-	&amp;_data_word(0xe49d3a2c, 0x0d927850, 0x9bcc5f6a, 0x62467e54);
-	&amp;_data_word(0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382);
-	&amp;_data_word(0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf);
-	&amp;_data_word(0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb);
-	&amp;_data_word(0x097826cd, 0xf418596e, 0x01b79aec, 0xa89a4f83);
-	&amp;_data_word(0x656e95e6, 0x7ee6ffaa, 0x08cfbc21, 0xe6e815ef);
-	&amp;_data_word(0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029);
-	&amp;_data_word(0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235);
-	&amp;_data_word(0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733);
-	&amp;_data_word(0x4a9804f1, 0xf7daec41, 0x0e50cd7f, 0x2ff69117);
-	&amp;_data_word(0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4);
-	&amp;_data_word(0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546);
-	&amp;_data_word(0x04ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb);
-	&amp;_data_word(0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d);
-	&amp;_data_word(0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb);
-	&amp;_data_word(0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a);
-	&amp;_data_word(0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773);
-	&amp;_data_word(0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478);
-	&amp;_data_word(0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2);
-	&amp;_data_word(0x72c31d16, 0x0c25e2bc, 0x8b493c28, 0x41950dff);
-	&amp;_data_word(0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664);
-	&amp;_data_word(0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0);
-
-#Td4:	# four copies of Td4 to choose from to avoid L1 aliasing
-	&amp;data_byte(0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38);
-	&amp;data_byte(0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb);
-	&amp;data_byte(0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87);
-	&amp;data_byte(0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb);
-	&amp;data_byte(0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d);
-	&amp;data_byte(0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e);
-	&amp;data_byte(0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2);
-	&amp;data_byte(0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25);
-	&amp;data_byte(0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16);
-	&amp;data_byte(0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92);
-	&amp;data_byte(0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda);
-	&amp;data_byte(0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84);
-	&amp;data_byte(0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a);
-	&amp;data_byte(0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06);
-	&amp;data_byte(0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02);
-	&amp;data_byte(0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b);
-	&amp;data_byte(0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea);
-	&amp;data_byte(0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73);
-	&amp;data_byte(0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85);
-	&amp;data_byte(0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e);
-	&amp;data_byte(0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89);
-	&amp;data_byte(0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b);
-	&amp;data_byte(0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20);
-	&amp;data_byte(0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4);
-	&amp;data_byte(0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31);
-	&amp;data_byte(0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f);
-	&amp;data_byte(0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d);
-	&amp;data_byte(0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef);
-	&amp;data_byte(0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0);
-	&amp;data_byte(0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61);
-	&amp;data_byte(0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26);
-	&amp;data_byte(0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d);
-
-	&amp;data_byte(0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38);
-	&amp;data_byte(0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb);
-	&amp;data_byte(0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87);
-	&amp;data_byte(0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb);
-	&amp;data_byte(0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d);
-	&amp;data_byte(0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e);
-	&amp;data_byte(0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2);
-	&amp;data_byte(0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25);
-	&amp;data_byte(0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16);
-	&amp;data_byte(0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92);
-	&amp;data_byte(0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda);
-	&amp;data_byte(0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84);
-	&amp;data_byte(0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a);
-	&amp;data_byte(0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06);
-	&amp;data_byte(0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02);
-	&amp;data_byte(0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b);
-	&amp;data_byte(0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea);
-	&amp;data_byte(0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73);
-	&amp;data_byte(0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85);
-	&amp;data_byte(0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e);
-	&amp;data_byte(0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89);
-	&amp;data_byte(0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b);
-	&amp;data_byte(0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20);
-	&amp;data_byte(0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4);
-	&amp;data_byte(0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31);
-	&amp;data_byte(0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f);
-	&amp;data_byte(0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d);
-	&amp;data_byte(0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef);
-	&amp;data_byte(0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0);
-	&amp;data_byte(0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61);
-	&amp;data_byte(0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26);
-	&amp;data_byte(0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d);
-
-	&amp;data_byte(0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38);
-	&amp;data_byte(0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb);
-	&amp;data_byte(0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87);
-	&amp;data_byte(0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb);
-	&amp;data_byte(0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d);
-	&amp;data_byte(0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e);
-	&amp;data_byte(0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2);
-	&amp;data_byte(0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25);
-	&amp;data_byte(0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16);
-	&amp;data_byte(0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92);
-	&amp;data_byte(0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda);
-	&amp;data_byte(0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84);
-	&amp;data_byte(0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a);
-	&amp;data_byte(0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06);
-	&amp;data_byte(0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02);
-	&amp;data_byte(0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b);
-	&amp;data_byte(0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea);
-	&amp;data_byte(0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73);
-	&amp;data_byte(0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85);
-	&amp;data_byte(0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e);
-	&amp;data_byte(0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89);
-	&amp;data_byte(0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b);
-	&amp;data_byte(0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20);
-	&amp;data_byte(0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4);
-	&amp;data_byte(0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31);
-	&amp;data_byte(0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f);
-	&amp;data_byte(0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d);
-	&amp;data_byte(0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef);
-	&amp;data_byte(0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0);
-	&amp;data_byte(0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61);
-	&amp;data_byte(0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26);
-	&amp;data_byte(0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d);
-
-	&amp;data_byte(0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38);
-	&amp;data_byte(0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb);
-	&amp;data_byte(0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87);
-	&amp;data_byte(0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb);
-	&amp;data_byte(0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d);
-	&amp;data_byte(0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e);
-	&amp;data_byte(0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2);
-	&amp;data_byte(0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25);
-	&amp;data_byte(0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16);
-	&amp;data_byte(0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92);
-	&amp;data_byte(0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda);
-	&amp;data_byte(0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84);
-	&amp;data_byte(0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a);
-	&amp;data_byte(0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06);
-	&amp;data_byte(0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02);
-	&amp;data_byte(0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b);
-	&amp;data_byte(0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea);
-	&amp;data_byte(0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73);
-	&amp;data_byte(0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85);
-	&amp;data_byte(0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e);
-	&amp;data_byte(0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89);
-	&amp;data_byte(0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b);
-	&amp;data_byte(0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20);
-	&amp;data_byte(0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4);
-	&amp;data_byte(0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31);
-	&amp;data_byte(0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f);
-	&amp;data_byte(0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d);
-	&amp;data_byte(0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef);
-	&amp;data_byte(0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0);
-	&amp;data_byte(0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61);
-	&amp;data_byte(0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26);
-	&amp;data_byte(0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d);
-&amp;function_end_B(&quot;_x86_AES_decrypt&quot;);
-
-# void AES_decrypt (const void *inp,void *out,const AES_KEY *key);
-&amp;function_begin(&quot;AES_decrypt&quot;);
-	&amp;mov	($acc,&amp;wparam(0));		# load inp
-	&amp;mov	($key,&amp;wparam(2));		# load key
-
-	&amp;mov	($s0,&quot;esp&quot;);
-	&amp;sub	(&quot;esp&quot;,36);
-	&amp;and	(&quot;esp&quot;,-64);			# align to cache-line
-
-	# place stack frame just &quot;above&quot; the key schedule
-	&amp;lea	($s1,&amp;DWP(-64-63,$key));
-	&amp;sub	($s1,&quot;esp&quot;);
-	&amp;neg	($s1);
-	&amp;and	($s1,0x3C0);	# modulo 1024, but aligned to cache-line
-	&amp;sub	(&quot;esp&quot;,$s1);
-	&amp;add	(&quot;esp&quot;,4);	# 4 is reserved for caller's return address
-	&amp;mov	($_esp,$s0);	# save stack pointer
-
-	&amp;call   (&amp;label(&quot;pic_point&quot;));          # make it PIC!
-	&amp;set_label(&quot;pic_point&quot;);
-	&amp;blindpop($tbl);
-	&amp;picmeup($s0,&quot;OPENSSL_ia32cap_P&quot;,$tbl,&amp;label(&quot;pic_point&quot;)) if(!$x86only);
-	&amp;lea    ($tbl,&amp;DWP(&amp;label(&quot;AES_Td&quot;).&quot;-&quot;.&amp;label(&quot;pic_point&quot;),$tbl));
-
-	# pick Td4 copy which can't &quot;overlap&quot; with stack frame or key schedule
-	&amp;lea	($s1,&amp;DWP(768-4,&quot;esp&quot;));
-	&amp;sub	($s1,$tbl);
-	&amp;and	($s1,0x300);
-	&amp;lea	($tbl,&amp;DWP(2048+128,$tbl,$s1));
-
-					if (!$x86only) {
-	&amp;bt	(&amp;DWP(0,$s0),25);	# check for SSE bit
-	&amp;jnc	(&amp;label(&quot;x86&quot;));
-
-	&amp;movq	(&quot;mm0&quot;,&amp;QWP(0,$acc));
-	&amp;movq	(&quot;mm4&quot;,&amp;QWP(8,$acc));
-	&amp;call	(&quot;_sse_AES_decrypt_compact&quot;);
-	&amp;mov	(&quot;esp&quot;,$_esp);			# restore stack pointer
-	&amp;mov	($acc,&amp;wparam(1));		# load out
-	&amp;movq	(&amp;QWP(0,$acc),&quot;mm0&quot;);		# write output data
-	&amp;movq	(&amp;QWP(8,$acc),&quot;mm4&quot;);
-	&amp;emms	();
-	&amp;function_end_A();
-					}
-	&amp;set_label(&quot;x86&quot;,16);
-	&amp;mov	($_tbl,$tbl);
-	&amp;mov	($s0,&amp;DWP(0,$acc));		# load input data
-	&amp;mov	($s1,&amp;DWP(4,$acc));
-	&amp;mov	($s2,&amp;DWP(8,$acc));
-	&amp;mov	($s3,&amp;DWP(12,$acc));
-	&amp;call	(&quot;_x86_AES_decrypt_compact&quot;);
-	&amp;mov	(&quot;esp&quot;,$_esp);			# restore stack pointer
-	&amp;mov	($acc,&amp;wparam(1));		# load out
-	&amp;mov	(&amp;DWP(0,$acc),$s0);		# write output data
-	&amp;mov	(&amp;DWP(4,$acc),$s1);
-	&amp;mov	(&amp;DWP(8,$acc),$s2);
-	&amp;mov	(&amp;DWP(12,$acc),$s3);
-&amp;function_end(&quot;AES_decrypt&quot;);
-
-# void AES_cbc_encrypt (const void char *inp, unsigned char *out,
-#			size_t length, const AES_KEY *key,
-#			unsigned char *ivp,const int enc);
-{
-# stack frame layout
-#             -4(%esp)		# return address	 0(%esp)
-#              0(%esp)		# s0 backing store	 4(%esp)
-#              4(%esp)		# s1 backing store	 8(%esp)
-#              8(%esp)		# s2 backing store	12(%esp)
-#             12(%esp)		# s3 backing store	16(%esp)
-#             16(%esp)		# key backup		20(%esp)
-#             20(%esp)		# end of key schedule	24(%esp)
-#             24(%esp)		# %ebp backup		28(%esp)
-#             28(%esp)		# %esp backup
-my $_inp=&amp;DWP(32,&quot;esp&quot;);	# copy of wparam(0)
-my $_out=&amp;DWP(36,&quot;esp&quot;);	# copy of wparam(1)
-my $_len=&amp;DWP(40,&quot;esp&quot;);	# copy of wparam(2)
-my $_key=&amp;DWP(44,&quot;esp&quot;);	# copy of wparam(3)
-my $_ivp=&amp;DWP(48,&quot;esp&quot;);	# copy of wparam(4)
-my $_tmp=&amp;DWP(52,&quot;esp&quot;);	# volatile variable
-#
-my $ivec=&amp;DWP(60,&quot;esp&quot;);	# ivec[16]
-my $aes_key=&amp;DWP(76,&quot;esp&quot;);	# copy of aes_key
-my $mark=&amp;DWP(76+240,&quot;esp&quot;);	# copy of aes_key-&gt;rounds
-
-&amp;function_begin(&quot;AES_cbc_encrypt&quot;);
-	&amp;mov	($s2 eq &quot;ecx&quot;? $s2 : &quot;&quot;,&amp;wparam(2));	# load len
-	&amp;cmp	($s2,0);
-	&amp;je	(&amp;label(&quot;drop_out&quot;));
-
-	&amp;call   (&amp;label(&quot;pic_point&quot;));		# make it PIC!
-	&amp;set_label(&quot;pic_point&quot;);
-	&amp;blindpop($tbl);
-	&amp;picmeup($s0,&quot;OPENSSL_ia32cap_P&quot;,$tbl,&amp;label(&quot;pic_point&quot;)) if(!$x86only);
-
-	&amp;cmp	(&amp;wparam(5),0);
-	&amp;lea    ($tbl,&amp;DWP(&amp;label(&quot;AES_Te&quot;).&quot;-&quot;.&amp;label(&quot;pic_point&quot;),$tbl));
-	&amp;jne	(&amp;label(&quot;picked_te&quot;));
-	&amp;lea	($tbl,&amp;DWP(&amp;label(&quot;AES_Td&quot;).&quot;-&quot;.&amp;label(&quot;AES_Te&quot;),$tbl));
-	&amp;set_label(&quot;picked_te&quot;);
-
-	# one can argue if this is required
-	&amp;pushf	();
-	&amp;cld	();
-
-	&amp;cmp	($s2,$speed_limit);
-	&amp;jb	(&amp;label(&quot;slow_way&quot;));
-	&amp;test	($s2,15);
-	&amp;jnz	(&amp;label(&quot;slow_way&quot;));
-					if (!$x86only) {
-	&amp;bt	(&amp;DWP(0,$s0),28);	# check for hyper-threading bit
-	&amp;jc	(&amp;label(&quot;slow_way&quot;));
-					}
-	# pre-allocate aligned stack frame...
-	&amp;lea	($acc,&amp;DWP(-80-244,&quot;esp&quot;));
-	&amp;and	($acc,-64);
-
-	# ... and make sure it doesn't alias with $tbl modulo 4096
-	&amp;mov	($s0,$tbl);
-	&amp;lea	($s1,&amp;DWP(2048+256,$tbl));
-	&amp;mov	($s3,$acc);
-	&amp;and	($s0,0xfff);		# s = %ebp&amp;0xfff
-	&amp;and	($s1,0xfff);		# e = (%ebp+2048+256)&amp;0xfff
-	&amp;and	($s3,0xfff);		# p = %esp&amp;0xfff
-
-	&amp;cmp	($s3,$s1);		# if (p&gt;=e) %esp =- (p-e);
-	&amp;jb	(&amp;label(&quot;tbl_break_out&quot;));
-	&amp;sub	($s3,$s1);
-	&amp;sub	($acc,$s3);
-	&amp;jmp	(&amp;label(&quot;tbl_ok&quot;));
-	&amp;set_label(&quot;tbl_break_out&quot;,4);	# else %esp -= (p-s)&amp;0xfff + framesz;
-	&amp;sub	($s3,$s0);
-	&amp;and	($s3,0xfff);
-	&amp;add	($s3,384);
-	&amp;sub	($acc,$s3);
-	&amp;set_label(&quot;tbl_ok&quot;,4);
-
-	&amp;lea	($s3,&amp;wparam(0));	# obtain pointer to parameter block
-	&amp;exch	(&quot;esp&quot;,$acc);		# allocate stack frame
-	&amp;add	(&quot;esp&quot;,4);		# reserve for return address!
-	&amp;mov	($_tbl,$tbl);		# save %ebp
-	&amp;mov	($_esp,$acc);		# save %esp
-
-	&amp;mov	($s0,&amp;DWP(0,$s3));	# load inp
-	&amp;mov	($s1,&amp;DWP(4,$s3));	# load out
-	#&amp;mov	($s2,&amp;DWP(8,$s3));	# load len
-	&amp;mov	($key,&amp;DWP(12,$s3));	# load key
-	&amp;mov	($acc,&amp;DWP(16,$s3));	# load ivp
-	&amp;mov	($s3,&amp;DWP(20,$s3));	# load enc flag
-
-	&amp;mov	($_inp,$s0);		# save copy of inp
-	&amp;mov	($_out,$s1);		# save copy of out
-	&amp;mov	($_len,$s2);		# save copy of len
-	&amp;mov	($_key,$key);		# save copy of key
-	&amp;mov	($_ivp,$acc);		# save copy of ivp
-
-	&amp;mov	($mark,0);		# copy of aes_key-&gt;rounds = 0;
-	# do we copy key schedule to stack?
-	&amp;mov	($s1 eq &quot;ebx&quot; ? $s1 : &quot;&quot;,$key);
-	&amp;mov	($s2 eq &quot;ecx&quot; ? $s2 : &quot;&quot;,244/4);
-	&amp;sub	($s1,$tbl);
-	&amp;mov	(&quot;esi&quot;,$key);
-	&amp;and	($s1,0xfff);
-	&amp;lea	(&quot;edi&quot;,$aes_key);
-	&amp;cmp	($s1,2048+256);
-	&amp;jb	(&amp;label(&quot;do_copy&quot;));
-	&amp;cmp	($s1,4096-244);
-	&amp;jb	(&amp;label(&quot;skip_copy&quot;));
-	&amp;set_label(&quot;do_copy&quot;,4);
-		&amp;mov	($_key,&quot;edi&quot;);
-		&amp;data_word(0xA5F3F689);	# rep movsd
-	&amp;set_label(&quot;skip_copy&quot;);
-
-	&amp;mov	($key,16);
-	&amp;set_label(&quot;prefetch_tbl&quot;,4);
-		&amp;mov	($s0,&amp;DWP(0,$tbl));
-		&amp;mov	($s1,&amp;DWP(32,$tbl));
-		&amp;mov	($s2,&amp;DWP(64,$tbl));
-		&amp;mov	($acc,&amp;DWP(96,$tbl));
-		&amp;lea	($tbl,&amp;DWP(128,$tbl));
-		&amp;sub	($key,1);
-	&amp;jnz	(&amp;label(&quot;prefetch_tbl&quot;));
-	&amp;sub	($tbl,2048);
-
-	&amp;mov	($acc,$_inp);
-	&amp;mov	($key,$_ivp);
-
-	&amp;cmp	($s3,0);
-	&amp;je	(&amp;label(&quot;fast_decrypt&quot;));
-
-#----------------------------- ENCRYPT -----------------------------#
-	&amp;mov	($s0,&amp;DWP(0,$key));		# load iv
-	&amp;mov	($s1,&amp;DWP(4,$key));
-
-	&amp;set_label(&quot;fast_enc_loop&quot;,16);
-		&amp;mov	($s2,&amp;DWP(8,$key));
-		&amp;mov	($s3,&amp;DWP(12,$key));
-
-		&amp;xor	($s0,&amp;DWP(0,$acc));	# xor input data
-		&amp;xor	($s1,&amp;DWP(4,$acc));
-		&amp;xor	($s2,&amp;DWP(8,$acc));
-		&amp;xor	($s3,&amp;DWP(12,$acc));
-
-		&amp;mov	($key,$_key);		# load key
-		&amp;call	(&quot;_x86_AES_encrypt&quot;);
-
-		&amp;mov	($acc,$_inp);		# load inp
-		&amp;mov	($key,$_out);		# load out
-
-		&amp;mov	(&amp;DWP(0,$key),$s0);	# save output data
-		&amp;mov	(&amp;DWP(4,$key),$s1);
-		&amp;mov	(&amp;DWP(8,$key),$s2);
-		&amp;mov	(&amp;DWP(12,$key),$s3);
-
-		&amp;lea	($acc,&amp;DWP(16,$acc));	# advance inp
-		&amp;mov	($s2,$_len);		# load len
-		&amp;mov	($_inp,$acc);		# save inp
-		&amp;lea	($s3,&amp;DWP(16,$key));	# advance out
-		&amp;mov	($_out,$s3);		# save out
-		&amp;sub	($s2,16);		# decrease len
-		&amp;mov	($_len,$s2);		# save len
-	&amp;jnz	(&amp;label(&quot;fast_enc_loop&quot;));
-	&amp;mov	($acc,$_ivp);		# load ivp
-	&amp;mov	($s2,&amp;DWP(8,$key));	# restore last 2 dwords
-	&amp;mov	($s3,&amp;DWP(12,$key));
-	&amp;mov	(&amp;DWP(0,$acc),$s0);	# save ivec
-	&amp;mov	(&amp;DWP(4,$acc),$s1);
-	&amp;mov	(&amp;DWP(8,$acc),$s2);
-	&amp;mov	(&amp;DWP(12,$acc),$s3);
-
-	&amp;cmp	($mark,0);		# was the key schedule copied?
-	&amp;mov	(&quot;edi&quot;,$_key);
-	&amp;je	(&amp;label(&quot;skip_ezero&quot;));
-	# zero copy of key schedule
-	&amp;mov	(&quot;ecx&quot;,240/4);
-	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);
-	&amp;align	(4);
-	&amp;data_word(0xABF3F689);		# rep stosd
-	&amp;set_label(&quot;skip_ezero&quot;);
-	&amp;mov	(&quot;esp&quot;,$_esp);
-	&amp;popf	();
-    &amp;set_label(&quot;drop_out&quot;);
-	&amp;function_end_A();
-	&amp;pushf	();			# kludge, never executed
-
-#----------------------------- DECRYPT -----------------------------#
-&amp;set_label(&quot;fast_decrypt&quot;,16);
-
-	&amp;cmp	($acc,$_out);
-	&amp;je	(&amp;label(&quot;fast_dec_in_place&quot;));	# in-place processing...
-
-	&amp;mov	($_tmp,$key);
-
-	&amp;align	(4);
-	&amp;set_label(&quot;fast_dec_loop&quot;,16);
-		&amp;mov	($s0,&amp;DWP(0,$acc));	# read input
-		&amp;mov	($s1,&amp;DWP(4,$acc));
-		&amp;mov	($s2,&amp;DWP(8,$acc));
-		&amp;mov	($s3,&amp;DWP(12,$acc));
-
-		&amp;mov	($key,$_key);		# load key
-		&amp;call	(&quot;_x86_AES_decrypt&quot;);
-
-		&amp;mov	($key,$_tmp);		# load ivp
-		&amp;mov	($acc,$_len);		# load len
-		&amp;xor	($s0,&amp;DWP(0,$key));	# xor iv
-		&amp;xor	($s1,&amp;DWP(4,$key));
-		&amp;xor	($s2,&amp;DWP(8,$key));
-		&amp;xor	($s3,&amp;DWP(12,$key));
-
-		&amp;mov	($key,$_out);		# load out
-		&amp;mov	($acc,$_inp);		# load inp
-
-		&amp;mov	(&amp;DWP(0,$key),$s0);	# write output
-		&amp;mov	(&amp;DWP(4,$key),$s1);
-		&amp;mov	(&amp;DWP(8,$key),$s2);
-		&amp;mov	(&amp;DWP(12,$key),$s3);
-
-		&amp;mov	($s2,$_len);		# load len
-		&amp;mov	($_tmp,$acc);		# save ivp
-		&amp;lea	($acc,&amp;DWP(16,$acc));	# advance inp
-		&amp;mov	($_inp,$acc);		# save inp
-		&amp;lea	($key,&amp;DWP(16,$key));	# advance out
-		&amp;mov	($_out,$key);		# save out
-		&amp;sub	($s2,16);		# decrease len
-		&amp;mov	($_len,$s2);		# save len
-	&amp;jnz	(&amp;label(&quot;fast_dec_loop&quot;));
-	&amp;mov	($key,$_tmp);		# load temp ivp
-	&amp;mov	($acc,$_ivp);		# load user ivp
-	&amp;mov	($s0,&amp;DWP(0,$key));	# load iv
-	&amp;mov	($s1,&amp;DWP(4,$key));
-	&amp;mov	($s2,&amp;DWP(8,$key));
-	&amp;mov	($s3,&amp;DWP(12,$key));
-	&amp;mov	(&amp;DWP(0,$acc),$s0);	# copy back to user
-	&amp;mov	(&amp;DWP(4,$acc),$s1);
-	&amp;mov	(&amp;DWP(8,$acc),$s2);
-	&amp;mov	(&amp;DWP(12,$acc),$s3);
-	&amp;jmp	(&amp;label(&quot;fast_dec_out&quot;));
-
-    &amp;set_label(&quot;fast_dec_in_place&quot;,16);
-	&amp;set_label(&quot;fast_dec_in_place_loop&quot;);
-		&amp;mov	($s0,&amp;DWP(0,$acc));	# read input
-		&amp;mov	($s1,&amp;DWP(4,$acc));
-		&amp;mov	($s2,&amp;DWP(8,$acc));
-		&amp;mov	($s3,&amp;DWP(12,$acc));
-
-		&amp;lea	($key,$ivec);
-		&amp;mov	(&amp;DWP(0,$key),$s0);	# copy to temp
-		&amp;mov	(&amp;DWP(4,$key),$s1);
-		&amp;mov	(&amp;DWP(8,$key),$s2);
-		&amp;mov	(&amp;DWP(12,$key),$s3);
-
-		&amp;mov	($key,$_key);		# load key
-		&amp;call	(&quot;_x86_AES_decrypt&quot;);
-
-		&amp;mov	($key,$_ivp);		# load ivp
-		&amp;mov	($acc,$_out);		# load out
-		&amp;xor	($s0,&amp;DWP(0,$key));	# xor iv
-		&amp;xor	($s1,&amp;DWP(4,$key));
-		&amp;xor	($s2,&amp;DWP(8,$key));
-		&amp;xor	($s3,&amp;DWP(12,$key));
-
-		&amp;mov	(&amp;DWP(0,$acc),$s0);	# write output
-		&amp;mov	(&amp;DWP(4,$acc),$s1);
-		&amp;mov	(&amp;DWP(8,$acc),$s2);
-		&amp;mov	(&amp;DWP(12,$acc),$s3);
-
-		&amp;lea	($acc,&amp;DWP(16,$acc));	# advance out
-		&amp;mov	($_out,$acc);		# save out
-
-		&amp;lea	($acc,$ivec);
-		&amp;mov	($s0,&amp;DWP(0,$acc));	# read temp
-		&amp;mov	($s1,&amp;DWP(4,$acc));
-		&amp;mov	($s2,&amp;DWP(8,$acc));
-		&amp;mov	($s3,&amp;DWP(12,$acc));
-
-		&amp;mov	(&amp;DWP(0,$key),$s0);	# copy iv
-		&amp;mov	(&amp;DWP(4,$key),$s1);
-		&amp;mov	(&amp;DWP(8,$key),$s2);
-		&amp;mov	(&amp;DWP(12,$key),$s3);
-
-		&amp;mov	($acc,$_inp);		# load inp
-		&amp;mov	($s2,$_len);		# load len
-		&amp;lea	($acc,&amp;DWP(16,$acc));	# advance inp
-		&amp;mov	($_inp,$acc);		# save inp
-		&amp;sub	($s2,16);		# decrease len
-		&amp;mov	($_len,$s2);		# save len
-	&amp;jnz	(&amp;label(&quot;fast_dec_in_place_loop&quot;));
-
-    &amp;set_label(&quot;fast_dec_out&quot;,4);
-	&amp;cmp	($mark,0);		# was the key schedule copied?
-	&amp;mov	(&quot;edi&quot;,$_key);
-	&amp;je	(&amp;label(&quot;skip_dzero&quot;));
-	# zero copy of key schedule
-	&amp;mov	(&quot;ecx&quot;,240/4);
-	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);
-	&amp;align	(4);
-	&amp;data_word(0xABF3F689);		# rep stosd
-	&amp;set_label(&quot;skip_dzero&quot;);
-	&amp;mov	(&quot;esp&quot;,$_esp);
-	&amp;popf	();
-	&amp;function_end_A();
-	&amp;pushf	();			# kludge, never executed
-
-#--------------------------- SLOW ROUTINE ---------------------------#
-&amp;set_label(&quot;slow_way&quot;,16);
-
-	&amp;mov	($s0,&amp;DWP(0,$s0)) if (!$x86only);# load OPENSSL_ia32cap
-	&amp;mov	($key,&amp;wparam(3));	# load key
-
-	# pre-allocate aligned stack frame...
-	&amp;lea	($acc,&amp;DWP(-80,&quot;esp&quot;));
-	&amp;and	($acc,-64);
-
-	# ... and make sure it doesn't alias with $key modulo 1024
-	&amp;lea	($s1,&amp;DWP(-80-63,$key));
-	&amp;sub	($s1,$acc);
-	&amp;neg	($s1);
-	&amp;and	($s1,0x3C0);	# modulo 1024, but aligned to cache-line
-	&amp;sub	($acc,$s1);
-
-	# pick S-box copy which can't overlap with stack frame or $key
-	&amp;lea	($s1,&amp;DWP(768,$acc));
-	&amp;sub	($s1,$tbl);
-	&amp;and	($s1,0x300);
-	&amp;lea	($tbl,&amp;DWP(2048+128,$tbl,$s1));
-
-	&amp;lea	($s3,&amp;wparam(0));	# pointer to parameter block
-
-	&amp;exch	(&quot;esp&quot;,$acc);
-	&amp;add	(&quot;esp&quot;,4);		# reserve for return address!
-	&amp;mov	($_tbl,$tbl);		# save %ebp
-	&amp;mov	($_esp,$acc);		# save %esp
-	&amp;mov	($_tmp,$s0);		# save OPENSSL_ia32cap
-
-	&amp;mov	($s0,&amp;DWP(0,$s3));	# load inp
-	&amp;mov	($s1,&amp;DWP(4,$s3));	# load out
-	#&amp;mov	($s2,&amp;DWP(8,$s3));	# load len
-	#&amp;mov	($key,&amp;DWP(12,$s3));	# load key
-	&amp;mov	($acc,&amp;DWP(16,$s3));	# load ivp
-	&amp;mov	($s3,&amp;DWP(20,$s3));	# load enc flag
-
-	&amp;mov	($_inp,$s0);		# save copy of inp
-	&amp;mov	($_out,$s1);		# save copy of out
-	&amp;mov	($_len,$s2);		# save copy of len
-	&amp;mov	($_key,$key);		# save copy of key
-	&amp;mov	($_ivp,$acc);		# save copy of ivp
-
-	&amp;mov	($key,$acc);
-	&amp;mov	($acc,$s0);
-
-	&amp;cmp	($s3,0);
-	&amp;je	(&amp;label(&quot;slow_decrypt&quot;));
-
-#--------------------------- SLOW ENCRYPT ---------------------------#
-	&amp;cmp	($s2,16);
-	&amp;mov	($s3,$s1);
-	&amp;jb	(&amp;label(&quot;slow_enc_tail&quot;));
-
-					if (!$x86only) {
-	&amp;bt	($_tmp,25);		# check for SSE bit
-	&amp;jnc	(&amp;label(&quot;slow_enc_x86&quot;));
-
-	&amp;movq	(&quot;mm0&quot;,&amp;QWP(0,$key));	# load iv
-	&amp;movq	(&quot;mm4&quot;,&amp;QWP(8,$key));
-
-	&amp;set_label(&quot;slow_enc_loop_sse&quot;,16);
-		&amp;pxor	(&quot;mm0&quot;,&amp;QWP(0,$acc));	# xor input data
-		&amp;pxor	(&quot;mm4&quot;,&amp;QWP(8,$acc));
-
-		&amp;mov	($key,$_key);
-		&amp;call	(&quot;_sse_AES_encrypt_compact&quot;);
-
-		&amp;mov	($acc,$_inp);		# load inp
-		&amp;mov	($key,$_out);		# load out
-		&amp;mov	($s2,$_len);		# load len
-
-		&amp;movq	(&amp;QWP(0,$key),&quot;mm0&quot;);	# save output data
-		&amp;movq	(&amp;QWP(8,$key),&quot;mm4&quot;);
-
-		&amp;lea	($acc,&amp;DWP(16,$acc));	# advance inp
-		&amp;mov	($_inp,$acc);		# save inp
-		&amp;lea	($s3,&amp;DWP(16,$key));	# advance out
-		&amp;mov	($_out,$s3);		# save out
-		&amp;sub	($s2,16);		# decrease len
-		&amp;cmp	($s2,16);
-		&amp;mov	($_len,$s2);		# save len
-	&amp;jae	(&amp;label(&quot;slow_enc_loop_sse&quot;));
-	&amp;test	($s2,15);
-	&amp;jnz	(&amp;label(&quot;slow_enc_tail&quot;));
-	&amp;mov	($acc,$_ivp);		# load ivp
-	&amp;movq	(&amp;QWP(0,$acc),&quot;mm0&quot;);	# save ivec
-	&amp;movq	(&amp;QWP(8,$acc),&quot;mm4&quot;);
-	&amp;emms	();
-	&amp;mov	(&quot;esp&quot;,$_esp);
-	&amp;popf	();
-	&amp;function_end_A();
-	&amp;pushf	();			# kludge, never executed
-					}
-    &amp;set_label(&quot;slow_enc_x86&quot;,16);
-	&amp;mov	($s0,&amp;DWP(0,$key));	# load iv
-	&amp;mov	($s1,&amp;DWP(4,$key));
-
-	&amp;set_label(&quot;slow_enc_loop_x86&quot;,4);
-		&amp;mov	($s2,&amp;DWP(8,$key));
-		&amp;mov	($s3,&amp;DWP(12,$key));
-
-		&amp;xor	($s0,&amp;DWP(0,$acc));	# xor input data
-		&amp;xor	($s1,&amp;DWP(4,$acc));
-		&amp;xor	($s2,&amp;DWP(8,$acc));
-		&amp;xor	($s3,&amp;DWP(12,$acc));
-
-		&amp;mov	($key,$_key);		# load key
-		&amp;call	(&quot;_x86_AES_encrypt_compact&quot;);
-
-		&amp;mov	($acc,$_inp);		# load inp
-		&amp;mov	($key,$_out);		# load out
-
-		&amp;mov	(&amp;DWP(0,$key),$s0);	# save output data
-		&amp;mov	(&amp;DWP(4,$key),$s1);
-		&amp;mov	(&amp;DWP(8,$key),$s2);
-		&amp;mov	(&amp;DWP(12,$key),$s3);
-
-		&amp;mov	($s2,$_len);		# load len
-		&amp;lea	($acc,&amp;DWP(16,$acc));	# advance inp
-		&amp;mov	($_inp,$acc);		# save inp
-		&amp;lea	($s3,&amp;DWP(16,$key));	# advance out
-		&amp;mov	($_out,$s3);		# save out
-		&amp;sub	($s2,16);		# decrease len
-		&amp;cmp	($s2,16);
-		&amp;mov	($_len,$s2);		# save len
-	&amp;jae	(&amp;label(&quot;slow_enc_loop_x86&quot;));
-	&amp;test	($s2,15);
-	&amp;jnz	(&amp;label(&quot;slow_enc_tail&quot;));
-	&amp;mov	($acc,$_ivp);		# load ivp
-	&amp;mov	($s2,&amp;DWP(8,$key));	# restore last dwords
-	&amp;mov	($s3,&amp;DWP(12,$key));
-	&amp;mov	(&amp;DWP(0,$acc),$s0);	# save ivec
-	&amp;mov	(&amp;DWP(4,$acc),$s1);
-	&amp;mov	(&amp;DWP(8,$acc),$s2);
-	&amp;mov	(&amp;DWP(12,$acc),$s3);
-
-	&amp;mov	(&quot;esp&quot;,$_esp);
-	&amp;popf	();
-	&amp;function_end_A();
-	&amp;pushf	();			# kludge, never executed
-
-    &amp;set_label(&quot;slow_enc_tail&quot;,16);
-	&amp;emms	()	if (!$x86only);
-	&amp;mov	($key eq &quot;edi&quot;? $key:&quot;&quot;,$s3);	# load out to edi
-	&amp;mov	($s1,16);
-	&amp;sub	($s1,$s2);
-	&amp;cmp	($key,$acc eq &quot;esi&quot;? $acc:&quot;&quot;);	# compare with inp
-	&amp;je	(&amp;label(&quot;enc_in_place&quot;));
-	&amp;align	(4);
-	&amp;data_word(0xA4F3F689);	# rep movsb	# copy input
-	&amp;jmp	(&amp;label(&quot;enc_skip_in_place&quot;));
-    &amp;set_label(&quot;enc_in_place&quot;);
-	&amp;lea	($key,&amp;DWP(0,$key,$s2));
-    &amp;set_label(&quot;enc_skip_in_place&quot;);
-	&amp;mov	($s2,$s1);
-	&amp;xor	($s0,$s0);
-	&amp;align	(4);
-	&amp;data_word(0xAAF3F689);	# rep stosb	# zero tail
-
-	&amp;mov	($key,$_ivp);			# restore ivp
-	&amp;mov	($acc,$s3);			# output as input
-	&amp;mov	($s0,&amp;DWP(0,$key));
-	&amp;mov	($s1,&amp;DWP(4,$key));
-	&amp;mov	($_len,16);			# len=16
-	&amp;jmp	(&amp;label(&quot;slow_enc_loop_x86&quot;));	# one more spin...
-
-#--------------------------- SLOW DECRYPT ---------------------------#
-&amp;set_label(&quot;slow_decrypt&quot;,16);
-					if (!$x86only) {
-	&amp;bt	($_tmp,25);		# check for SSE bit
-	&amp;jnc	(&amp;label(&quot;slow_dec_loop_x86&quot;));
-
-	&amp;set_label(&quot;slow_dec_loop_sse&quot;,4);
-		&amp;movq	(&quot;mm0&quot;,&amp;QWP(0,$acc));	# read input
-		&amp;movq	(&quot;mm4&quot;,&amp;QWP(8,$acc));
-
-		&amp;mov	($key,$_key);
-		&amp;call	(&quot;_sse_AES_decrypt_compact&quot;);
-
-		&amp;mov	($acc,$_inp);		# load inp
-		&amp;lea	($s0,$ivec);
-		&amp;mov	($s1,$_out);		# load out
-		&amp;mov	($s2,$_len);		# load len
-		&amp;mov	($key,$_ivp);		# load ivp
-
-		&amp;movq	(&quot;mm1&quot;,&amp;QWP(0,$acc));	# re-read input
-		&amp;movq	(&quot;mm5&quot;,&amp;QWP(8,$acc));
-
-		&amp;pxor	(&quot;mm0&quot;,&amp;QWP(0,$key));	# xor iv
-		&amp;pxor	(&quot;mm4&quot;,&amp;QWP(8,$key));
-
-		&amp;movq	(&amp;QWP(0,$key),&quot;mm1&quot;);	# copy input to iv
-		&amp;movq	(&amp;QWP(8,$key),&quot;mm5&quot;);
-
-		&amp;sub	($s2,16);		# decrease len
-		&amp;jc	(&amp;label(&quot;slow_dec_partial_sse&quot;));
-
-		&amp;movq	(&amp;QWP(0,$s1),&quot;mm0&quot;);	# write output
-		&amp;movq	(&amp;QWP(8,$s1),&quot;mm4&quot;);
-
-		&amp;lea	($s1,&amp;DWP(16,$s1));	# advance out
-		&amp;mov	($_out,$s1);		# save out
-		&amp;lea	($acc,&amp;DWP(16,$acc));	# advance inp
-		&amp;mov	($_inp,$acc);		# save inp
-		&amp;mov	($_len,$s2);		# save len
-	&amp;jnz	(&amp;label(&quot;slow_dec_loop_sse&quot;));
-	&amp;emms	();
-	&amp;mov	(&quot;esp&quot;,$_esp);
-	&amp;popf	();
-	&amp;function_end_A();
-	&amp;pushf	();			# kludge, never executed
-
-    &amp;set_label(&quot;slow_dec_partial_sse&quot;,16);
-	&amp;movq	(&amp;QWP(0,$s0),&quot;mm0&quot;);	# save output to temp
-	&amp;movq	(&amp;QWP(8,$s0),&quot;mm4&quot;);
-	&amp;emms	();
-
-	&amp;add	($s2 eq &quot;ecx&quot; ? &quot;ecx&quot;:&quot;&quot;,16);
-	&amp;mov	(&quot;edi&quot;,$s1);		# out
-	&amp;mov	(&quot;esi&quot;,$s0);		# temp
-	&amp;align	(4);
-	&amp;data_word(0xA4F3F689);		# rep movsb # copy partial output
-
-	&amp;mov	(&quot;esp&quot;,$_esp);
-	&amp;popf	();
-	&amp;function_end_A();
-	&amp;pushf	();			# kludge, never executed
-					}
-	&amp;set_label(&quot;slow_dec_loop_x86&quot;,16);
-		&amp;mov	($s0,&amp;DWP(0,$acc));	# read input
-		&amp;mov	($s1,&amp;DWP(4,$acc));
-		&amp;mov	($s2,&amp;DWP(8,$acc));
-		&amp;mov	($s3,&amp;DWP(12,$acc));
-
-		&amp;lea	($key,$ivec);
-		&amp;mov	(&amp;DWP(0,$key),$s0);	# copy to temp
-		&amp;mov	(&amp;DWP(4,$key),$s1);
-		&amp;mov	(&amp;DWP(8,$key),$s2);
-		&amp;mov	(&amp;DWP(12,$key),$s3);
-
-		&amp;mov	($key,$_key);		# load key
-		&amp;call	(&quot;_x86_AES_decrypt_compact&quot;);
-
-		&amp;mov	($key,$_ivp);		# load ivp
-		&amp;mov	($acc,$_len);		# load len
-		&amp;xor	($s0,&amp;DWP(0,$key));	# xor iv
-		&amp;xor	($s1,&amp;DWP(4,$key));
-		&amp;xor	($s2,&amp;DWP(8,$key));
-		&amp;xor	($s3,&amp;DWP(12,$key));
-
-		&amp;sub	($acc,16);
-		&amp;jc	(&amp;label(&quot;slow_dec_partial_x86&quot;));
-
-		&amp;mov	($_len,$acc);		# save len
-		&amp;mov	($acc,$_out);		# load out
-
-		&amp;mov	(&amp;DWP(0,$acc),$s0);	# write output
-		&amp;mov	(&amp;DWP(4,$acc),$s1);
-		&amp;mov	(&amp;DWP(8,$acc),$s2);
-		&amp;mov	(&amp;DWP(12,$acc),$s3);
-
-		&amp;lea	($acc,&amp;DWP(16,$acc));	# advance out
-		&amp;mov	($_out,$acc);		# save out
-
-		&amp;lea	($acc,$ivec);
-		&amp;mov	($s0,&amp;DWP(0,$acc));	# read temp
-		&amp;mov	($s1,&amp;DWP(4,$acc));
-		&amp;mov	($s2,&amp;DWP(8,$acc));
-		&amp;mov	($s3,&amp;DWP(12,$acc));
-
-		&amp;mov	(&amp;DWP(0,$key),$s0);	# copy it to iv
-		&amp;mov	(&amp;DWP(4,$key),$s1);
-		&amp;mov	(&amp;DWP(8,$key),$s2);
-		&amp;mov	(&amp;DWP(12,$key),$s3);
-
-		&amp;mov	($acc,$_inp);		# load inp
-		&amp;lea	($acc,&amp;DWP(16,$acc));	# advance inp
-		&amp;mov	($_inp,$acc);		# save inp
-	&amp;jnz	(&amp;label(&quot;slow_dec_loop_x86&quot;));
-	&amp;mov	(&quot;esp&quot;,$_esp);
-	&amp;popf	();
-	&amp;function_end_A();
-	&amp;pushf	();			# kludge, never executed
-
-    &amp;set_label(&quot;slow_dec_partial_x86&quot;,16);
-	&amp;lea	($acc,$ivec);
-	&amp;mov	(&amp;DWP(0,$acc),$s0);	# save output to temp
-	&amp;mov	(&amp;DWP(4,$acc),$s1);
-	&amp;mov	(&amp;DWP(8,$acc),$s2);
-	&amp;mov	(&amp;DWP(12,$acc),$s3);
-
-	&amp;mov	($acc,$_inp);
-	&amp;mov	($s0,&amp;DWP(0,$acc));	# re-read input
-	&amp;mov	($s1,&amp;DWP(4,$acc));
-	&amp;mov	($s2,&amp;DWP(8,$acc));
-	&amp;mov	($s3,&amp;DWP(12,$acc));
-
-	&amp;mov	(&amp;DWP(0,$key),$s0);	# copy it to iv
-	&amp;mov	(&amp;DWP(4,$key),$s1);
-	&amp;mov	(&amp;DWP(8,$key),$s2);
-	&amp;mov	(&amp;DWP(12,$key),$s3);
-
-	&amp;mov	(&quot;ecx&quot;,$_len);
-	&amp;mov	(&quot;edi&quot;,$_out);
-	&amp;lea	(&quot;esi&quot;,$ivec);
-	&amp;align	(4);
-	&amp;data_word(0xA4F3F689);		# rep movsb # copy partial output
-
-	&amp;mov	(&quot;esp&quot;,$_esp);
-	&amp;popf	();
-&amp;function_end(&quot;AES_cbc_encrypt&quot;);
-}
-
-#------------------------------------------------------------------#
-
-sub enckey()
-{
-	&amp;movz	(&quot;esi&quot;,&amp;LB(&quot;edx&quot;));		# rk[i]&gt;&gt;0
-	&amp;movz	(&quot;ebx&quot;,&amp;BP(-128,$tbl,&quot;esi&quot;,1));
-	&amp;movz	(&quot;esi&quot;,&amp;HB(&quot;edx&quot;));		# rk[i]&gt;&gt;8
-	&amp;shl	(&quot;ebx&quot;,24);
-	&amp;xor	(&quot;eax&quot;,&quot;ebx&quot;);
-
-	&amp;movz	(&quot;ebx&quot;,&amp;BP(-128,$tbl,&quot;esi&quot;,1));
-	&amp;shr	(&quot;edx&quot;,16);
-	&amp;movz	(&quot;esi&quot;,&amp;LB(&quot;edx&quot;));		# rk[i]&gt;&gt;16
-	&amp;xor	(&quot;eax&quot;,&quot;ebx&quot;);
-
-	&amp;movz	(&quot;ebx&quot;,&amp;BP(-128,$tbl,&quot;esi&quot;,1));
-	&amp;movz	(&quot;esi&quot;,&amp;HB(&quot;edx&quot;));		# rk[i]&gt;&gt;24
-	&amp;shl	(&quot;ebx&quot;,8);
-	&amp;xor	(&quot;eax&quot;,&quot;ebx&quot;);
-
-	&amp;movz	(&quot;ebx&quot;,&amp;BP(-128,$tbl,&quot;esi&quot;,1));
-	&amp;shl	(&quot;ebx&quot;,16);
-	&amp;xor	(&quot;eax&quot;,&quot;ebx&quot;);
-
-	&amp;xor	(&quot;eax&quot;,&amp;DWP(1024-128,$tbl,&quot;ecx&quot;,4));	# rcon
-}
-
-&amp;function_begin(&quot;_x86_AES_set_encrypt_key&quot;);
-	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));		# user supplied key
-	&amp;mov	(&quot;edi&quot;,&amp;wparam(3));		# private key schedule
-
-	&amp;test	(&quot;esi&quot;,-1);
-	&amp;jz	(&amp;label(&quot;badpointer&quot;));
-	&amp;test	(&quot;edi&quot;,-1);
-	&amp;jz	(&amp;label(&quot;badpointer&quot;));
-
-	&amp;call	(&amp;label(&quot;pic_point&quot;));
-	&amp;set_label(&quot;pic_point&quot;);
-	&amp;blindpop($tbl);
-	&amp;lea	($tbl,&amp;DWP(&amp;label(&quot;AES_Te&quot;).&quot;-&quot;.&amp;label(&quot;pic_point&quot;),$tbl));
-	&amp;lea	($tbl,&amp;DWP(2048+128,$tbl));
-
-	# prefetch Te4
-	&amp;mov	(&quot;eax&quot;,&amp;DWP(0-128,$tbl));
-	&amp;mov	(&quot;ebx&quot;,&amp;DWP(32-128,$tbl));
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(64-128,$tbl));
-	&amp;mov	(&quot;edx&quot;,&amp;DWP(96-128,$tbl));
-	&amp;mov	(&quot;eax&quot;,&amp;DWP(128-128,$tbl));
-	&amp;mov	(&quot;ebx&quot;,&amp;DWP(160-128,$tbl));
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(192-128,$tbl));
-	&amp;mov	(&quot;edx&quot;,&amp;DWP(224-128,$tbl));
-
-	&amp;mov	(&quot;ecx&quot;,&amp;wparam(2));		# number of bits in key
-	&amp;cmp	(&quot;ecx&quot;,128);
-	&amp;je	(&amp;label(&quot;10rounds&quot;));
-	&amp;cmp	(&quot;ecx&quot;,192);
-	&amp;je	(&amp;label(&quot;12rounds&quot;));
-	&amp;cmp	(&quot;ecx&quot;,256);
-	&amp;je	(&amp;label(&quot;14rounds&quot;));
-	&amp;mov	(&quot;eax&quot;,-2);			# invalid number of bits
-	&amp;jmp	(&amp;label(&quot;exit&quot;));
-
-    &amp;set_label(&quot;10rounds&quot;);
-	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;esi&quot;));		# copy first 4 dwords
-	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;esi&quot;));
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;esi&quot;));
-	&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;esi&quot;));
-	&amp;mov	(&amp;DWP(0,&quot;edi&quot;),&quot;eax&quot;);
-	&amp;mov	(&amp;DWP(4,&quot;edi&quot;),&quot;ebx&quot;);
-	&amp;mov	(&amp;DWP(8,&quot;edi&quot;),&quot;ecx&quot;);
-	&amp;mov	(&amp;DWP(12,&quot;edi&quot;),&quot;edx&quot;);
-
-	&amp;xor	(&quot;ecx&quot;,&quot;ecx&quot;);
-	&amp;jmp	(&amp;label(&quot;10shortcut&quot;));
-
-	&amp;align	(4);
-	&amp;set_label(&quot;10loop&quot;);
-		&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;edi&quot;));		# rk[0]
-		&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;edi&quot;));		# rk[3]
-	&amp;set_label(&quot;10shortcut&quot;);
-		&amp;enckey	();
-
-		&amp;mov	(&amp;DWP(16,&quot;edi&quot;),&quot;eax&quot;);		# rk[4]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(4,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(20,&quot;edi&quot;),&quot;eax&quot;);		# rk[5]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(8,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(24,&quot;edi&quot;),&quot;eax&quot;);		# rk[6]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(12,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(28,&quot;edi&quot;),&quot;eax&quot;);		# rk[7]
-		&amp;inc	(&quot;ecx&quot;);
-		&amp;add	(&quot;edi&quot;,16);
-		&amp;cmp	(&quot;ecx&quot;,10);
-	&amp;jl	(&amp;label(&quot;10loop&quot;));
-
-	&amp;mov	(&amp;DWP(80,&quot;edi&quot;),10);		# setup number of rounds
-	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);
-	&amp;jmp	(&amp;label(&quot;exit&quot;));
-
-    &amp;set_label(&quot;12rounds&quot;);
-	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;esi&quot;));		# copy first 6 dwords
-	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;esi&quot;));
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;esi&quot;));
-	&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;esi&quot;));
-	&amp;mov	(&amp;DWP(0,&quot;edi&quot;),&quot;eax&quot;);
-	&amp;mov	(&amp;DWP(4,&quot;edi&quot;),&quot;ebx&quot;);
-	&amp;mov	(&amp;DWP(8,&quot;edi&quot;),&quot;ecx&quot;);
-	&amp;mov	(&amp;DWP(12,&quot;edi&quot;),&quot;edx&quot;);
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(16,&quot;esi&quot;));
-	&amp;mov	(&quot;edx&quot;,&amp;DWP(20,&quot;esi&quot;));
-	&amp;mov	(&amp;DWP(16,&quot;edi&quot;),&quot;ecx&quot;);
-	&amp;mov	(&amp;DWP(20,&quot;edi&quot;),&quot;edx&quot;);
-
-	&amp;xor	(&quot;ecx&quot;,&quot;ecx&quot;);
-	&amp;jmp	(&amp;label(&quot;12shortcut&quot;));
-
-	&amp;align	(4);
-	&amp;set_label(&quot;12loop&quot;);
-		&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;edi&quot;));		# rk[0]
-		&amp;mov	(&quot;edx&quot;,&amp;DWP(20,&quot;edi&quot;));		# rk[5]
-	&amp;set_label(&quot;12shortcut&quot;);
-		&amp;enckey	();
-
-		&amp;mov	(&amp;DWP(24,&quot;edi&quot;),&quot;eax&quot;);		# rk[6]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(4,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(28,&quot;edi&quot;),&quot;eax&quot;);		# rk[7]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(8,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(32,&quot;edi&quot;),&quot;eax&quot;);		# rk[8]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(12,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(36,&quot;edi&quot;),&quot;eax&quot;);		# rk[9]
-
-		&amp;cmp	(&quot;ecx&quot;,7);
-		&amp;je	(&amp;label(&quot;12break&quot;));
-		&amp;inc	(&quot;ecx&quot;);
-
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(16,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(40,&quot;edi&quot;),&quot;eax&quot;);		# rk[10]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(20,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(44,&quot;edi&quot;),&quot;eax&quot;);		# rk[11]
-
-		&amp;add	(&quot;edi&quot;,24);
-	&amp;jmp	(&amp;label(&quot;12loop&quot;));
-
-	&amp;set_label(&quot;12break&quot;);
-	&amp;mov	(&amp;DWP(72,&quot;edi&quot;),12);		# setup number of rounds
-	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);
-	&amp;jmp	(&amp;label(&quot;exit&quot;));
-
-    &amp;set_label(&quot;14rounds&quot;);
-	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;esi&quot;));		# copy first 8 dwords
-	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;esi&quot;));
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;esi&quot;));
-	&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;esi&quot;));
-	&amp;mov	(&amp;DWP(0,&quot;edi&quot;),&quot;eax&quot;);
-	&amp;mov	(&amp;DWP(4,&quot;edi&quot;),&quot;ebx&quot;);
-	&amp;mov	(&amp;DWP(8,&quot;edi&quot;),&quot;ecx&quot;);
-	&amp;mov	(&amp;DWP(12,&quot;edi&quot;),&quot;edx&quot;);
-	&amp;mov	(&quot;eax&quot;,&amp;DWP(16,&quot;esi&quot;));
-	&amp;mov	(&quot;ebx&quot;,&amp;DWP(20,&quot;esi&quot;));
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(24,&quot;esi&quot;));
-	&amp;mov	(&quot;edx&quot;,&amp;DWP(28,&quot;esi&quot;));
-	&amp;mov	(&amp;DWP(16,&quot;edi&quot;),&quot;eax&quot;);
-	&amp;mov	(&amp;DWP(20,&quot;edi&quot;),&quot;ebx&quot;);
-	&amp;mov	(&amp;DWP(24,&quot;edi&quot;),&quot;ecx&quot;);
-	&amp;mov	(&amp;DWP(28,&quot;edi&quot;),&quot;edx&quot;);
-
-	&amp;xor	(&quot;ecx&quot;,&quot;ecx&quot;);
-	&amp;jmp	(&amp;label(&quot;14shortcut&quot;));
-
-	&amp;align	(4);
-	&amp;set_label(&quot;14loop&quot;);
-		&amp;mov	(&quot;edx&quot;,&amp;DWP(28,&quot;edi&quot;));		# rk[7]
-	&amp;set_label(&quot;14shortcut&quot;);
-		&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;edi&quot;));		# rk[0]
-
-		&amp;enckey	();
-
-		&amp;mov	(&amp;DWP(32,&quot;edi&quot;),&quot;eax&quot;);		# rk[8]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(4,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(36,&quot;edi&quot;),&quot;eax&quot;);		# rk[9]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(8,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(40,&quot;edi&quot;),&quot;eax&quot;);		# rk[10]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(12,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(44,&quot;edi&quot;),&quot;eax&quot;);		# rk[11]
-
-		&amp;cmp	(&quot;ecx&quot;,6);
-		&amp;je	(&amp;label(&quot;14break&quot;));
-		&amp;inc	(&quot;ecx&quot;);
-
-		&amp;mov	(&quot;edx&quot;,&quot;eax&quot;);
-		&amp;mov	(&quot;eax&quot;,&amp;DWP(16,&quot;edi&quot;));		# rk[4]
-		&amp;movz	(&quot;esi&quot;,&amp;LB(&quot;edx&quot;));		# rk[11]&gt;&gt;0
-		&amp;movz	(&quot;ebx&quot;,&amp;BP(-128,$tbl,&quot;esi&quot;,1));
-		&amp;movz	(&quot;esi&quot;,&amp;HB(&quot;edx&quot;));		# rk[11]&gt;&gt;8
-		&amp;xor	(&quot;eax&quot;,&quot;ebx&quot;);
-
-		&amp;movz	(&quot;ebx&quot;,&amp;BP(-128,$tbl,&quot;esi&quot;,1));
-		&amp;shr	(&quot;edx&quot;,16);
-		&amp;shl	(&quot;ebx&quot;,8);
-		&amp;movz	(&quot;esi&quot;,&amp;LB(&quot;edx&quot;));		# rk[11]&gt;&gt;16
-		&amp;xor	(&quot;eax&quot;,&quot;ebx&quot;);
-
-		&amp;movz	(&quot;ebx&quot;,&amp;BP(-128,$tbl,&quot;esi&quot;,1));
-		&amp;movz	(&quot;esi&quot;,&amp;HB(&quot;edx&quot;));		# rk[11]&gt;&gt;24
-		&amp;shl	(&quot;ebx&quot;,16);
-		&amp;xor	(&quot;eax&quot;,&quot;ebx&quot;);
-
-		&amp;movz	(&quot;ebx&quot;,&amp;BP(-128,$tbl,&quot;esi&quot;,1));
-		&amp;shl	(&quot;ebx&quot;,24);
-		&amp;xor	(&quot;eax&quot;,&quot;ebx&quot;);
-
-		&amp;mov	(&amp;DWP(48,&quot;edi&quot;),&quot;eax&quot;);		# rk[12]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(20,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(52,&quot;edi&quot;),&quot;eax&quot;);		# rk[13]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(24,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(56,&quot;edi&quot;),&quot;eax&quot;);		# rk[14]
-		&amp;xor	(&quot;eax&quot;,&amp;DWP(28,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(60,&quot;edi&quot;),&quot;eax&quot;);		# rk[15]
-
-		&amp;add	(&quot;edi&quot;,32);
-	&amp;jmp	(&amp;label(&quot;14loop&quot;));
-
-	&amp;set_label(&quot;14break&quot;);
-	&amp;mov	(&amp;DWP(48,&quot;edi&quot;),14);		# setup number of rounds
-	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);
-	&amp;jmp	(&amp;label(&quot;exit&quot;));
-
-    &amp;set_label(&quot;badpointer&quot;);
-	&amp;mov	(&quot;eax&quot;,-1);
-    &amp;set_label(&quot;exit&quot;);
-&amp;function_end(&quot;_x86_AES_set_encrypt_key&quot;);
-
-# int AES_set_encrypt_key(const unsigned char *userKey, const int bits,
-#                        AES_KEY *key)
-&amp;function_begin_B(&quot;AES_set_encrypt_key&quot;);
-	&amp;call	(&quot;_x86_AES_set_encrypt_key&quot;);
-	&amp;ret	();
-&amp;function_end_B(&quot;AES_set_encrypt_key&quot;);
-
-sub deckey()
-{ my ($i,$key,$tp1,$tp2,$tp4,$tp8) = @_;
-  my $tmp = $tbl;
-
-	&amp;mov	($tmp,0x80808080);
-	&amp;and	($tmp,$tp1);
-	&amp;lea	($tp2,&amp;DWP(0,$tp1,$tp1));
-	&amp;mov	($acc,$tmp);
-	&amp;shr	($tmp,7);
-	&amp;sub	($acc,$tmp);
-	&amp;and	($tp2,0xfefefefe);
-	&amp;and	($acc,0x1b1b1b1b);
-	&amp;xor	($tp2,$acc);
-	&amp;mov	($tmp,0x80808080);
-
-	&amp;and	($tmp,$tp2);
-	&amp;lea	($tp4,&amp;DWP(0,$tp2,$tp2));
-	&amp;mov	($acc,$tmp);
-	&amp;shr	($tmp,7);
-	&amp;sub	($acc,$tmp);
-	&amp;and	($tp4,0xfefefefe);
-	&amp;and	($acc,0x1b1b1b1b);
-	 &amp;xor	($tp2,$tp1);	# tp2^tp1
-	&amp;xor	($tp4,$acc);
-	&amp;mov	($tmp,0x80808080);
-
-	&amp;and	($tmp,$tp4);
-	&amp;lea	($tp8,&amp;DWP(0,$tp4,$tp4));
-	&amp;mov	($acc,$tmp);
-	&amp;shr	($tmp,7);
-	 &amp;xor	($tp4,$tp1);	# tp4^tp1
-	&amp;sub	($acc,$tmp);
-	&amp;and	($tp8,0xfefefefe);
-	&amp;and	($acc,0x1b1b1b1b);
-	 &amp;rotl	($tp1,8);	# = ROTATE(tp1,8)
-	&amp;xor	($tp8,$acc);
-
-	&amp;mov	($tmp,&amp;DWP(4*($i+1),$key));	# modulo-scheduled load
-
-	&amp;xor	($tp1,$tp2);
-	&amp;xor	($tp2,$tp8);
-	&amp;xor	($tp1,$tp4);
-	&amp;rotl	($tp2,24);
-	&amp;xor	($tp4,$tp8);
-	&amp;xor	($tp1,$tp8);	# ^= tp8^(tp4^tp1)^(tp2^tp1)
-	&amp;rotl	($tp4,16);
-	&amp;xor	($tp1,$tp2);	# ^= ROTATE(tp8^tp2^tp1,24)
-	&amp;rotl	($tp8,8);
-	&amp;xor	($tp1,$tp4);	# ^= ROTATE(tp8^tp4^tp1,16)
-	&amp;mov	($tp2,$tmp);
-	&amp;xor	($tp1,$tp8);	# ^= ROTATE(tp8,8)
-
-	&amp;mov	(&amp;DWP(4*$i,$key),$tp1);
-}
-
-# int AES_set_decrypt_key(const unsigned char *userKey, const int bits,
-#                        AES_KEY *key)
-&amp;function_begin_B(&quot;AES_set_decrypt_key&quot;);
-	&amp;call	(&quot;_x86_AES_set_encrypt_key&quot;);
-	&amp;cmp	(&quot;eax&quot;,0);
-	&amp;je	(&amp;label(&quot;proceed&quot;));
-	&amp;ret	();
-
-    &amp;set_label(&quot;proceed&quot;);
-	&amp;push	(&quot;ebp&quot;);
-	&amp;push	(&quot;ebx&quot;);
-	&amp;push	(&quot;esi&quot;);
-	&amp;push	(&quot;edi&quot;);
-
-	&amp;mov	(&quot;esi&quot;,&amp;wparam(2));
-	&amp;mov	(&quot;ecx&quot;,&amp;DWP(240,&quot;esi&quot;));	# pull number of rounds
-	&amp;lea	(&quot;ecx&quot;,&amp;DWP(0,&quot;&quot;,&quot;ecx&quot;,4));
-	&amp;lea	(&quot;edi&quot;,&amp;DWP(0,&quot;esi&quot;,&quot;ecx&quot;,4));	# pointer to last chunk
-
-	&amp;set_label(&quot;invert&quot;,4);			# invert order of chunks
-		&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;esi&quot;));
-		&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;esi&quot;));
-		&amp;mov	(&quot;ecx&quot;,&amp;DWP(0,&quot;edi&quot;));
-		&amp;mov	(&quot;edx&quot;,&amp;DWP(4,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(0,&quot;edi&quot;),&quot;eax&quot;);
-		&amp;mov	(&amp;DWP(4,&quot;edi&quot;),&quot;ebx&quot;);
-		&amp;mov	(&amp;DWP(0,&quot;esi&quot;),&quot;ecx&quot;);
-		&amp;mov	(&amp;DWP(4,&quot;esi&quot;),&quot;edx&quot;);
-		&amp;mov	(&quot;eax&quot;,&amp;DWP(8,&quot;esi&quot;));
-		&amp;mov	(&quot;ebx&quot;,&amp;DWP(12,&quot;esi&quot;));
-		&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;edi&quot;));
-		&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;edi&quot;));
-		&amp;mov	(&amp;DWP(8,&quot;edi&quot;),&quot;eax&quot;);
-		&amp;mov	(&amp;DWP(12,&quot;edi&quot;),&quot;ebx&quot;);
-		&amp;mov	(&amp;DWP(8,&quot;esi&quot;),&quot;ecx&quot;);
-		&amp;mov	(&amp;DWP(12,&quot;esi&quot;),&quot;edx&quot;);
-		&amp;add	(&quot;esi&quot;,16);
-		&amp;sub	(&quot;edi&quot;,16);
-		&amp;cmp	(&quot;esi&quot;,&quot;edi&quot;);
-	&amp;jne	(&amp;label(&quot;invert&quot;));
-
-	&amp;mov	($key,&amp;wparam(2));
-	&amp;mov	($acc,&amp;DWP(240,$key));		# pull number of rounds
-	&amp;lea	($acc,&amp;DWP(-2,$acc,$acc));
-	&amp;lea	($acc,&amp;DWP(0,$key,$acc,8));
-	&amp;mov	(&amp;wparam(2),$acc);
-
-	&amp;mov	($s0,&amp;DWP(16,$key));		# modulo-scheduled load
-	&amp;set_label(&quot;permute&quot;,4);		# permute the key schedule
-		&amp;add	($key,16);
-		&amp;deckey	(0,$key,$s0,$s1,$s2,$s3);
-		&amp;deckey	(1,$key,$s1,$s2,$s3,$s0);
-		&amp;deckey	(2,$key,$s2,$s3,$s0,$s1);
-		&amp;deckey	(3,$key,$s3,$s0,$s1,$s2);
-		&amp;cmp	($key,&amp;wparam(2));
-	&amp;jb	(&amp;label(&quot;permute&quot;));
-
-	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);			# return success
-&amp;function_end(&quot;AES_set_decrypt_key&quot;);
-&amp;asciz(&quot;AES for x86, CRYPTOGAMS by &lt;appro\@openssl.org&gt;&quot;);
-
-&amp;asm_finish();
-
-close STDOUT;
diff --git a/crypto/aes/asm/aes-x86_64.pl b/crypto/aes/asm/aes-x86_64.pl
deleted file mode 100755
index d87e201147..0000000000
--- a/crypto/aes/asm/aes-x86_64.pl
+++ /dev/null
@@ -1,2916 +0,0 @@
-#! /usr/bin/env perl
-# Copyright 2005-2019 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
-
-#
-# ====================================================================
-# Written by Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt; for the OpenSSL
-# project. The module is, however, dual licensed under OpenSSL and
-# CRYPTOGAMS licenses depending on where you obtain it. For further
-# details see <A HREF="http://www.openssl.org/~appro/cryptogams/.">http://www.openssl.org/~appro/cryptogams/.</A>
-# ====================================================================
-#
-# Version 2.1.
-#
-# aes-*-cbc benchmarks are improved by &gt;70% [compared to gcc 3.3.2 on
-# Opteron 240 CPU] plus all the bells-n-whistles from 32-bit version
-# [you'll notice a lot of resemblance], such as compressed S-boxes
-# in little-endian byte order, prefetch of these tables in CBC mode,
-# as well as avoiding L1 cache aliasing between stack frame and key
-# schedule and already mentioned tables, compressed Td4...
-#
-# Performance in number of cycles per processed byte for 128-bit key:
-#
-#		ECB encrypt	ECB decrypt	CBC large chunk
-# AMD64		33		43		13.0
-# EM64T		38		56		18.6(*)
-# Core 2	30		42		14.5(*)
-# Atom		65		86		32.1(*)
-#
-# (*) with hyper-threading off
-
-$flavour = shift;
-$output  = shift;
-if ($flavour =~ /\./) { $output = $flavour; undef $flavour; }
-
-$win64=0; $win64=1 if ($flavour =~ /[nm]asm|mingw64/ || $output =~ /\.asm$/);
-
-$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
-( $xlate=&quot;${dir}x86_64-xlate.pl&quot; and -f $xlate ) or
-( $xlate=&quot;${dir}../../perlasm/x86_64-xlate.pl&quot; and -f $xlate) or
-die &quot;can't locate x86_64-xlate.pl&quot;;
-
-open OUT,&quot;| \&quot;$^X\&quot; \&quot;$xlate\&quot; $flavour \&quot;$output\&quot;&quot;;
-*STDOUT=*OUT;
-
-$verticalspin=1;	# unlike 32-bit version $verticalspin performs
-			# ~15% better on both AMD and Intel cores
-$speed_limit=512;	# see aes-586.pl for details
-
-$code=&quot;.text\n&quot;;
-
-$s0=&quot;%eax&quot;;
-$s1=&quot;%ebx&quot;;
-$s2=&quot;%ecx&quot;;
-$s3=&quot;%edx&quot;;
-$acc0=&quot;%esi&quot;;	$mask80=&quot;%rsi&quot;;
-$acc1=&quot;%edi&quot;;	$maskfe=&quot;%rdi&quot;;
-$acc2=&quot;%ebp&quot;;	$mask1b=&quot;%rbp&quot;;
-$inp=&quot;%r8&quot;;
-$out=&quot;%r9&quot;;
-$t0=&quot;%r10d&quot;;
-$t1=&quot;%r11d&quot;;
-$t2=&quot;%r12d&quot;;
-$rnds=&quot;%r13d&quot;;
-$sbox=&quot;%r14&quot;;
-$key=&quot;%r15&quot;;
-
-sub hi() { my $r=shift;	$r =~ s/%[er]([a-d])x/%\1h/;	$r; }
-sub lo() { my $r=shift;	$r =~ s/%[er]([a-d])x/%\1l/;
-			$r =~ s/%[er]([sd]i)/%\1l/;
-			$r =~ s/%(r[0-9]+)[d]?/%\1b/;	$r; }
-sub LO() { my $r=shift; $r =~ s/%r([a-z]+)/%e\1/;
-			$r =~ s/%r([0-9]+)/%r\1d/;	$r; }
-sub _data_word()
-{ my $i;
-    while(defined($i=shift)) { $code.=sprintf&quot;.long\t0x%08x,0x%08x\n&quot;,$i,$i; }
-}
-sub data_word()
-{ my $i;
-  my $last=pop(@_);
-    $code.=&quot;.long\t&quot;;
-    while(defined($i=shift)) { $code.=sprintf&quot;0x%08x,&quot;,$i; }
-    $code.=sprintf&quot;0x%08x\n&quot;,$last;
-}
-
-sub data_byte()
-{ my $i;
-  my $last=pop(@_);
-    $code.=&quot;.byte\t&quot;;
-    while(defined($i=shift)) { $code.=sprintf&quot;0x%02x,&quot;,$i&amp;0xff; }
-    $code.=sprintf&quot;0x%02x\n&quot;,$last&amp;0xff;
-}
-
-sub encvert()
-{ my $t3=&quot;%r8d&quot;;	# zaps $inp!
-
-$code.=&lt;&lt;___;
-	# favor 3-way issue Opteron pipeline...
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$acc0
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$acc2
-	mov	0($sbox,$acc0,8),$t0
-	mov	0($sbox,$acc1,8),$t1
-	mov	0($sbox,$acc2,8),$t2
-
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$acc2
-	xor	3($sbox,$acc0,8),$t0
-	xor	3($sbox,$acc1,8),$t1
-	mov	0($sbox,$acc2,8),$t3
-
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc0
-	shr	\$16,$s2
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc2
-	xor	3($sbox,$acc0,8),$t2
-	shr	\$16,$s3
-	xor	3($sbox,$acc2,8),$t3
-
-	shr	\$16,$s1
-	lea	16($key),$key
-	shr	\$16,$s0
-
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$acc0
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$acc2
-	xor	2($sbox,$acc0,8),$t0
-	xor	2($sbox,$acc1,8),$t1
-	xor	2($sbox,$acc2,8),$t2
-
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$acc2
-	xor	1($sbox,$acc0,8),$t0
-	xor	1($sbox,$acc1,8),$t1
-	xor	2($sbox,$acc2,8),$t3
-
-	mov	12($key),$s3
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc1
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc2
-	mov	0($key),$s0
-	xor	1($sbox,$acc1,8),$t2
-	xor	1($sbox,$acc2,8),$t3
-
-	mov	4($key),$s1
-	mov	8($key),$s2
-	xor	$t0,$s0
-	xor	$t1,$s1
-	xor	$t2,$s2
-	xor	$t3,$s3
-___
-}
-
-sub enclastvert()
-{ my $t3=&quot;%r8d&quot;;	# zaps $inp!
-
-$code.=&lt;&lt;___;
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$acc0
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$acc2
-	movzb	2($sbox,$acc0,8),$t0
-	movzb	2($sbox,$acc1,8),$t1
-	movzb	2($sbox,$acc2,8),$t2
-
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc1
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc2
-	movzb	2($sbox,$acc0,8),$t3
-	mov	0($sbox,$acc1,8),$acc1	#$t0
-	mov	0($sbox,$acc2,8),$acc2	#$t1
-
-	and	\$0x0000ff00,$acc1
-	and	\$0x0000ff00,$acc2
-
-	xor	$acc1,$t0
-	xor	$acc2,$t1
-	shr	\$16,$s2
-
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc1
-	shr	\$16,$s3
-	mov	0($sbox,$acc0,8),$acc0	#$t2
-	mov	0($sbox,$acc1,8),$acc1	#$t3
-
-	and	\$0x0000ff00,$acc0
-	and	\$0x0000ff00,$acc1
-	shr	\$16,$s1
-	xor	$acc0,$t2
-	xor	$acc1,$t3
-	shr	\$16,$s0
-
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$acc0
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$acc2
-	mov	0($sbox,$acc0,8),$acc0	#$t0
-	mov	0($sbox,$acc1,8),$acc1	#$t1
-	mov	0($sbox,$acc2,8),$acc2	#$t2
-
-	and	\$0x00ff0000,$acc0
-	and	\$0x00ff0000,$acc1
-	and	\$0x00ff0000,$acc2
-
-	xor	$acc0,$t0
-	xor	$acc1,$t1
-	xor	$acc2,$t2
-
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc1
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc2
-	mov	0($sbox,$acc0,8),$acc0	#$t3
-	mov	2($sbox,$acc1,8),$acc1	#$t0
-	mov	2($sbox,$acc2,8),$acc2	#$t1
-
-	and	\$0x00ff0000,$acc0
-	and	\$0xff000000,$acc1
-	and	\$0xff000000,$acc2
-
-	xor	$acc0,$t3
-	xor	$acc1,$t0
-	xor	$acc2,$t1
-
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc1
-	mov	16+12($key),$s3
-	mov	2($sbox,$acc0,8),$acc0	#$t2
-	mov	2($sbox,$acc1,8),$acc1	#$t3
-	mov	16+0($key),$s0
-
-	and	\$0xff000000,$acc0
-	and	\$0xff000000,$acc1
-
-	xor	$acc0,$t2
-	xor	$acc1,$t3
-
-	mov	16+4($key),$s1
-	mov	16+8($key),$s2
-	xor	$t0,$s0
-	xor	$t1,$s1
-	xor	$t2,$s2
-	xor	$t3,$s3
-___
-}
-
-sub encstep()
-{ my ($<A HREF="../../../mailman/listinfo/openssl-commits.html">i, at s</A>) = @_;
-  my $tmp0=$acc0;
-  my $tmp1=$acc1;
-  my $tmp2=$acc2;
-  my $out=($t0,$t1,$t2,$s[0])[$i];
-
-	if ($i==3) {
-		$tmp0=$s[1];
-		$tmp1=$s[2];
-		$tmp2=$s[3];
-	}
-	$code.=&quot;	movzb	&quot;.&amp;lo($s[0]).&quot;,$out\n&quot;;
-	$code.=&quot;	mov	$s[2],$tmp1\n&quot;		if ($i!=3);
-	$code.=&quot;	lea	16($key),$key\n&quot;	if ($i==0);
-
-	$code.=&quot;	movzb	&quot;.&amp;hi($s[1]).&quot;,$tmp0\n&quot;;
-	$code.=&quot;	mov	0($sbox,$out,8),$out\n&quot;;
-
-	$code.=&quot;	shr	\$16,$tmp1\n&quot;;
-	$code.=&quot;	mov	$s[3],$tmp2\n&quot;		if ($i!=3);
-	$code.=&quot;	xor	3($sbox,$tmp0,8),$out\n&quot;;
-
-	$code.=&quot;	movzb	&quot;.&amp;lo($tmp1).&quot;,$tmp1\n&quot;;
-	$code.=&quot;	shr	\$24,$tmp2\n&quot;;
-	$code.=&quot;	xor	4*$i($key),$out\n&quot;;
-
-	$code.=&quot;	xor	2($sbox,$tmp1,8),$out\n&quot;;
-	$code.=&quot;	xor	1($sbox,$tmp2,8),$out\n&quot;;
-
-	$code.=&quot;	mov	$t0,$s[1]\n&quot;		if ($i==3);
-	$code.=&quot;	mov	$t1,$s[2]\n&quot;		if ($i==3);
-	$code.=&quot;	mov	$t2,$s[3]\n&quot;		if ($i==3);
-	$code.=&quot;\n&quot;;
-}
-
-sub enclast()
-{ my ($<A HREF="../../../mailman/listinfo/openssl-commits.html">i, at s</A>)=@_;
-  my $tmp0=$acc0;
-  my $tmp1=$acc1;
-  my $tmp2=$acc2;
-  my $out=($t0,$t1,$t2,$s[0])[$i];
-
-	if ($i==3) {
-		$tmp0=$s[1];
-		$tmp1=$s[2];
-		$tmp2=$s[3];
-	}
-	$code.=&quot;	movzb	&quot;.&amp;lo($s[0]).&quot;,$out\n&quot;;
-	$code.=&quot;	mov	$s[2],$tmp1\n&quot;		if ($i!=3);
-
-	$code.=&quot;	mov	2($sbox,$out,8),$out\n&quot;;
-	$code.=&quot;	shr	\$16,$tmp1\n&quot;;
-	$code.=&quot;	mov	$s[3],$tmp2\n&quot;		if ($i!=3);
-
-	$code.=&quot;	and	\$0x000000ff,$out\n&quot;;
-	$code.=&quot;	movzb	&quot;.&amp;hi($s[1]).&quot;,$tmp0\n&quot;;
-	$code.=&quot;	movzb	&quot;.&amp;lo($tmp1).&quot;,$tmp1\n&quot;;
-	$code.=&quot;	shr	\$24,$tmp2\n&quot;;
-
-	$code.=&quot;	mov	0($sbox,$tmp0,8),$tmp0\n&quot;;
-	$code.=&quot;	mov	0($sbox,$tmp1,8),$tmp1\n&quot;;
-	$code.=&quot;	mov	2($sbox,$tmp2,8),$tmp2\n&quot;;
-
-	$code.=&quot;	and	\$0x0000ff00,$tmp0\n&quot;;
-	$code.=&quot;	and	\$0x00ff0000,$tmp1\n&quot;;
-	$code.=&quot;	and	\$0xff000000,$tmp2\n&quot;;
-
-	$code.=&quot;	xor	$tmp0,$out\n&quot;;
-	$code.=&quot;	mov	$t0,$s[1]\n&quot;		if ($i==3);
-	$code.=&quot;	xor	$tmp1,$out\n&quot;;
-	$code.=&quot;	mov	$t1,$s[2]\n&quot;		if ($i==3);
-	$code.=&quot;	xor	$tmp2,$out\n&quot;;
-	$code.=&quot;	mov	$t2,$s[3]\n&quot;		if ($i==3);
-	$code.=&quot;\n&quot;;
-}
-
-$code.=&lt;&lt;___;
-.type	_x86_64_AES_encrypt,\@abi-omnipotent
-.align	16
-_x86_64_AES_encrypt:
-	xor	0($key),$s0			# xor with key
-	xor	4($key),$s1
-	xor	8($key),$s2
-	xor	12($key),$s3
-
-	mov	240($key),$rnds			# load key-&gt;rounds
-	sub	\$1,$rnds
-	jmp	.Lenc_loop
-.align	16
-.Lenc_loop:
-___
-	if ($verticalspin) { &amp;encvert(); }
-	else {	&amp;encstep(0,$s0,$s1,$s2,$s3);
-		&amp;encstep(1,$s1,$s2,$s3,$s0);
-		&amp;encstep(2,$s2,$s3,$s0,$s1);
-		&amp;encstep(3,$s3,$s0,$s1,$s2);
-	}
-$code.=&lt;&lt;___;
-	sub	\$1,$rnds
-	jnz	.Lenc_loop
-___
-	if ($verticalspin) { &amp;enclastvert(); }
-	else {	&amp;enclast(0,$s0,$s1,$s2,$s3);
-		&amp;enclast(1,$s1,$s2,$s3,$s0);
-		&amp;enclast(2,$s2,$s3,$s0,$s1);
-		&amp;enclast(3,$s3,$s0,$s1,$s2);
-		$code.=&lt;&lt;___;
-		xor	16+0($key),$s0		# xor with key
-		xor	16+4($key),$s1
-		xor	16+8($key),$s2
-		xor	16+12($key),$s3
-___
-	}
-$code.=&lt;&lt;___;
-	.byte	0xf3,0xc3			# rep ret
-.size	_x86_64_AES_encrypt,.-_x86_64_AES_encrypt
-___
-
-# it's possible to implement this by shifting tN by 8, filling least
-# significant byte with byte load and finally bswap-ing at the end,
-# but such partial register load kills Core 2...
-sub enccompactvert()
-{ my ($t3,$t4,$t5)=(&quot;%r8d&quot;,&quot;%r9d&quot;,&quot;%r13d&quot;);
-
-$code.=&lt;&lt;___;
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$t0
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$t1
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$t2
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$t3
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc1
-	shr	\$16,$s2
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc2
-	movzb	($sbox,$t0,1),$t0
-	movzb	($sbox,$t1,1),$t1
-	movzb	($sbox,$t2,1),$t2
-	movzb	($sbox,$t3,1),$t3
-
-	movzb	($sbox,$acc0,1),$t4	#$t0
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc0
-	movzb	($sbox,$acc1,1),$t5	#$t1
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$acc1
-	movzb	($sbox,$acc2,1),$acc2	#$t2
-	movzb	($sbox,$acc0,1),$acc0	#$t3
-
-	shl	\$8,$t4
-	shr	\$16,$s3
-	shl	\$8,$t5
-	xor	$t4,$t0
-	shr	\$16,$s0
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$t4
-	shr	\$16,$s1
-	xor	$t5,$t1
-	shl	\$8,$acc2
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$t5
-	movzb	($sbox,$acc1,1),$acc1	#$t0
-	xor	$acc2,$t2
-
-	shl	\$8,$acc0
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$acc2
-	shl	\$16,$acc1
-	xor	$acc0,$t3
-	movzb	($sbox,$t4,1),$t4	#$t1
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc0
-	movzb	($sbox,$t5,1),$t5	#$t2
-	xor	$acc1,$t0
-
-	shr	\$8,$s2
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc1
-	shl	\$16,$t4
-	shr	\$8,$s1
-	shl	\$16,$t5
-	xor	$t4,$t1
-	movzb	($sbox,$acc2,1),$acc2	#$t3
-	movzb	($sbox,$acc0,1),$acc0	#$t0
-	movzb	($sbox,$acc1,1),$acc1	#$t1
-	movzb	($sbox,$s2,1),$s3	#$t3
-	movzb	($sbox,$s1,1),$s2	#$t2
-
-	shl	\$16,$acc2
-	xor	$t5,$t2
-	shl	\$24,$acc0
-	xor	$acc2,$t3
-	shl	\$24,$acc1
-	xor	$acc0,$t0
-	shl	\$24,$s3
-	xor	$acc1,$t1
-	shl	\$24,$s2
-	mov	$t0,$s0
-	mov	$t1,$s1
-	xor	$t2,$s2
-	xor	$t3,$s3
-___
-}
-
-sub enctransform_ref()
-{ my $sn = shift;
-  my ($acc,$r2,$tmp)=(&quot;%r8d&quot;,&quot;%r9d&quot;,&quot;%r13d&quot;);
-
-$code.=&lt;&lt;___;
-	mov	$sn,$acc
-	and	\$0x80808080,$acc
-	mov	$acc,$tmp
-	shr	\$7,$tmp
-	lea	($sn,$sn),$r2
-	sub	$tmp,$acc
-	and	\$0xfefefefe,$r2
-	and	\$0x1b1b1b1b,$acc
-	mov	$sn,$tmp
-	xor	$acc,$r2
-
-	xor	$r2,$sn
-	rol	\$24,$sn
-	xor	$r2,$sn
-	ror	\$16,$tmp
-	xor	$tmp,$sn
-	ror	\$8,$tmp
-	xor	$tmp,$sn
-___
-}
-
-# unlike decrypt case it does not pay off to parallelize enctransform
-sub enctransform()
-{ my ($t3,$r20,$r21)=($acc2,&quot;%r8d&quot;,&quot;%r9d&quot;);
-
-$code.=&lt;&lt;___;
-	mov	\$0x80808080,$t0
-	mov	\$0x80808080,$t1
-	and	$s0,$t0
-	and	$s1,$t1
-	mov	$t0,$acc0
-	mov	$t1,$acc1
-	shr	\$7,$t0
-	lea	($s0,$s0),$r20
-	shr	\$7,$t1
-	lea	($s1,$s1),$r21
-	sub	$t0,$acc0
-	sub	$t1,$acc1
-	and	\$0xfefefefe,$r20
-	and	\$0xfefefefe,$r21
-	and	\$0x1b1b1b1b,$acc0
-	and	\$0x1b1b1b1b,$acc1
-	mov	$s0,$t0
-	mov	$s1,$t1
-	xor	$acc0,$r20
-	xor	$acc1,$r21
-
-	xor	$r20,$s0
-	xor	$r21,$s1
-	 mov	\$0x80808080,$t2
-	rol	\$24,$s0
-	 mov	\$0x80808080,$t3
-	rol	\$24,$s1
-	 and	$s2,$t2
-	 and	$s3,$t3
-	xor	$r20,$s0
-	xor	$r21,$s1
-	 mov	$t2,$acc0
-	ror	\$16,$t0
-	 mov	$t3,$acc1
-	ror	\$16,$t1
-	 lea	($s2,$s2),$r20
-	 shr	\$7,$t2
-	xor	$t0,$s0
-	 shr	\$7,$t3
-	xor	$t1,$s1
-	ror	\$8,$t0
-	 lea	($s3,$s3),$r21
-	ror	\$8,$t1
-	 sub	$t2,$acc0
-	 sub	$t3,$acc1
-	xor	$t0,$s0
-	xor	$t1,$s1
-
-	and	\$0xfefefefe,$r20
-	and	\$0xfefefefe,$r21
-	and	\$0x1b1b1b1b,$acc0
-	and	\$0x1b1b1b1b,$acc1
-	mov	$s2,$t2
-	mov	$s3,$t3
-	xor	$acc0,$r20
-	xor	$acc1,$r21
-
-	ror	\$16,$t2
-	xor	$r20,$s2
-	ror	\$16,$t3
-	xor	$r21,$s3
-	rol	\$24,$s2
-	mov	0($sbox),$acc0			# prefetch Te4
-	rol	\$24,$s3
-	xor	$r20,$s2
-	mov	64($sbox),$acc1
-	xor	$r21,$s3
-	mov	128($sbox),$r20
-	xor	$t2,$s2
-	ror	\$8,$t2
-	xor	$t3,$s3
-	ror	\$8,$t3
-	xor	$t2,$s2
-	mov	192($sbox),$r21
-	xor	$t3,$s3
-___
-}
-
-$code.=&lt;&lt;___;
-.type	_x86_64_AES_encrypt_compact,\@abi-omnipotent
-.align	16
-_x86_64_AES_encrypt_compact:
-.cfi_startproc
-	lea	128($sbox),$inp			# size optimization
-	mov	0-128($inp),$acc1		# prefetch Te4
-	mov	32-128($inp),$acc2
-	mov	64-128($inp),$t0
-	mov	96-128($inp),$t1
-	mov	128-128($inp),$acc1
-	mov	160-128($inp),$acc2
-	mov	192-128($inp),$t0
-	mov	224-128($inp),$t1
-	jmp	.Lenc_loop_compact
-.align	16
-.Lenc_loop_compact:
-		xor	0($key),$s0		# xor with key
-		xor	4($key),$s1
-		xor	8($key),$s2
-		xor	12($key),$s3
-		lea	16($key),$key
-___
-		&amp;enccompactvert();
-$code.=&lt;&lt;___;
-		cmp	16(%rsp),$key
-		je	.Lenc_compact_done
-___
-		&amp;enctransform();
-$code.=&lt;&lt;___;
-	jmp	.Lenc_loop_compact
-.align	16
-.Lenc_compact_done:
-	xor	0($key),$s0
-	xor	4($key),$s1
-	xor	8($key),$s2
-	xor	12($key),$s3
-	.byte	0xf3,0xc3			# rep ret
-.cfi_endproc
-.size	_x86_64_AES_encrypt_compact,.-_x86_64_AES_encrypt_compact
-___
-
-# void AES_encrypt (const void *inp,void *out,const AES_KEY *key);
-$code.=&lt;&lt;___;
-.globl	AES_encrypt
-.type	AES_encrypt,\@function,3
-.align	16
-.globl	asm_AES_encrypt
-.hidden	asm_AES_encrypt
-asm_AES_encrypt:
-AES_encrypt:
-.cfi_startproc
-	mov	%rsp,%rax
-.cfi_def_cfa_register	%rax
-	push	%rbx
-.cfi_push	%rbx
-	push	%rbp
-.cfi_push	%rbp
-	push	%r12
-.cfi_push	%r12
-	push	%r13
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-
-	# allocate frame &quot;above&quot; key schedule
-	lea	-63(%rdx),%rcx	# %rdx is key argument
-	and	\$-64,%rsp
-	sub	%rsp,%rcx
-	neg	%rcx
-	and	\$0x3c0,%rcx
-	sub	%rcx,%rsp
-	sub	\$32,%rsp
-
-	mov	%rsi,16(%rsp)	# save out
-	mov	%rax,24(%rsp)	# save original stack pointer
-.cfi_cfa_expression	%rsp+24,deref,+8
-.Lenc_prologue:
-
-	mov	%rdx,$key
-	mov	240($key),$rnds	# load rounds
-
-	mov	0(%rdi),$s0	# load input vector
-	mov	4(%rdi),$s1
-	mov	8(%rdi),$s2
-	mov	12(%rdi),$s3
-
-	shl	\$4,$rnds
-	lea	($key,$rnds),%rbp
-	mov	$key,(%rsp)	# key schedule
-	mov	%rbp,8(%rsp)	# end of key schedule
-
-	# pick Te4 copy which can't &quot;overlap&quot; with stack frame or key schedule
-	lea	.LAES_Te+2048(%rip),$sbox
-	lea	768(%rsp),%rbp
-	sub	$sbox,%rbp
-	and	\$0x300,%rbp
-	lea	($sbox,%rbp),$sbox
-
-	call	_x86_64_AES_encrypt_compact
-
-	mov	16(%rsp),$out	# restore out
-	mov	24(%rsp),%rsi	# restore saved stack pointer
-.cfi_def_cfa	%rsi,8
-	mov	$s0,0($out)	# write output vector
-	mov	$s1,4($out)
-	mov	$s2,8($out)
-	mov	$s3,12($out)
-
-	mov	-48(%rsi),%r15
-.cfi_restore	%r15
-	mov	-40(%rsi),%r14
-.cfi_restore	%r14
-	mov	-32(%rsi),%r13
-.cfi_restore	%r13
-	mov	-24(%rsi),%r12
-.cfi_restore	%r12
-	mov	-16(%rsi),%rbp
-.cfi_restore	%rbp
-	mov	-8(%rsi),%rbx
-.cfi_restore	%rbx
-	lea	(%rsi),%rsp
-.cfi_def_cfa_register	%rsp
-.Lenc_epilogue:
-	ret
-.cfi_endproc
-.size	AES_encrypt,.-AES_encrypt
-___
-
-#------------------------------------------------------------------#
-
-sub decvert()
-{ my $t3=&quot;%r8d&quot;;	# zaps $inp!
-
-$code.=&lt;&lt;___;
-	# favor 3-way issue Opteron pipeline...
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$acc0
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$acc2
-	mov	0($sbox,$acc0,8),$t0
-	mov	0($sbox,$acc1,8),$t1
-	mov	0($sbox,$acc2,8),$t2
-
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$acc2
-	xor	3($sbox,$acc0,8),$t0
-	xor	3($sbox,$acc1,8),$t1
-	mov	0($sbox,$acc2,8),$t3
-
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc0
-	shr	\$16,$s0
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc2
-	xor	3($sbox,$acc0,8),$t2
-	shr	\$16,$s3
-	xor	3($sbox,$acc2,8),$t3
-
-	shr	\$16,$s1
-	lea	16($key),$key
-	shr	\$16,$s2
-
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$acc0
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$acc2
-	xor	2($sbox,$acc0,8),$t0
-	xor	2($sbox,$acc1,8),$t1
-	xor	2($sbox,$acc2,8),$t2
-
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$acc2
-	xor	1($sbox,$acc0,8),$t0
-	xor	1($sbox,$acc1,8),$t1
-	xor	2($sbox,$acc2,8),$t3
-
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc0
-	mov	12($key),$s3
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc2
-	xor	1($sbox,$acc0,8),$t2
-	mov	0($key),$s0
-	xor	1($sbox,$acc2,8),$t3
-
-	xor	$t0,$s0
-	mov	4($key),$s1
-	mov	8($key),$s2
-	xor	$t2,$s2
-	xor	$t1,$s1
-	xor	$t3,$s3
-___
-}
-
-sub declastvert()
-{ my $t3=&quot;%r8d&quot;;	# zaps $inp!
-
-$code.=&lt;&lt;___;
-	lea	2048($sbox),$sbox	# size optimization
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$acc0
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$acc2
-	movzb	($sbox,$acc0,1),$t0
-	movzb	($sbox,$acc1,1),$t1
-	movzb	($sbox,$acc2,1),$t2
-
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc1
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc2
-	movzb	($sbox,$acc0,1),$t3
-	movzb	($sbox,$acc1,1),$acc1	#$t0
-	movzb	($sbox,$acc2,1),$acc2	#$t1
-
-	shl	\$8,$acc1
-	shl	\$8,$acc2
-
-	xor	$acc1,$t0
-	xor	$acc2,$t1
-	shr	\$16,$s3
-
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc1
-	shr	\$16,$s0
-	movzb	($sbox,$acc0,1),$acc0	#$t2
-	movzb	($sbox,$acc1,1),$acc1	#$t3
-
-	shl	\$8,$acc0
-	shl	\$8,$acc1
-	shr	\$16,$s1
-	xor	$acc0,$t2
-	xor	$acc1,$t3
-	shr	\$16,$s2
-
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$acc0
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$acc1
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$acc2
-	movzb	($sbox,$acc0,1),$acc0	#$t0
-	movzb	($sbox,$acc1,1),$acc1	#$t1
-	movzb	($sbox,$acc2,1),$acc2	#$t2
-
-	shl	\$16,$acc0
-	shl	\$16,$acc1
-	shl	\$16,$acc2
-
-	xor	$acc0,$t0
-	xor	$acc1,$t1
-	xor	$acc2,$t2
-
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc1
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc2
-	movzb	($sbox,$acc0,1),$acc0	#$t3
-	movzb	($sbox,$acc1,1),$acc1	#$t0
-	movzb	($sbox,$acc2,1),$acc2	#$t1
-
-	shl	\$16,$acc0
-	shl	\$24,$acc1
-	shl	\$24,$acc2
-
-	xor	$acc0,$t3
-	xor	$acc1,$t0
-	xor	$acc2,$t1
-
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc1
-	mov	16+12($key),$s3
-	movzb	($sbox,$acc0,1),$acc0	#$t2
-	movzb	($sbox,$acc1,1),$acc1	#$t3
-	mov	16+0($key),$s0
-
-	shl	\$24,$acc0
-	shl	\$24,$acc1
-
-	xor	$acc0,$t2
-	xor	$acc1,$t3
-
-	mov	16+4($key),$s1
-	mov	16+8($key),$s2
-	lea	-2048($sbox),$sbox
-	xor	$t0,$s0
-	xor	$t1,$s1
-	xor	$t2,$s2
-	xor	$t3,$s3
-___
-}
-
-sub decstep()
-{ my ($<A HREF="../../../mailman/listinfo/openssl-commits.html">i, at s</A>) = @_;
-  my $tmp0=$acc0;
-  my $tmp1=$acc1;
-  my $tmp2=$acc2;
-  my $out=($t0,$t1,$t2,$s[0])[$i];
-
-	$code.=&quot;	mov	$s[0],$out\n&quot;		if ($i!=3);
-			$tmp1=$s[2]			if ($i==3);
-	$code.=&quot;	mov	$s[2],$tmp1\n&quot;		if ($i!=3);
-	$code.=&quot;	and	\$0xFF,$out\n&quot;;
-
-	$code.=&quot;	mov	0($sbox,$out,8),$out\n&quot;;
-	$code.=&quot;	shr	\$16,$tmp1\n&quot;;
-			$tmp2=$s[3]			if ($i==3);
-	$code.=&quot;	mov	$s[3],$tmp2\n&quot;		if ($i!=3);
-
-			$tmp0=$s[1]			if ($i==3);
-	$code.=&quot;	movzb	&quot;.&amp;hi($s[1]).&quot;,$tmp0\n&quot;;
-	$code.=&quot;	and	\$0xFF,$tmp1\n&quot;;
-	$code.=&quot;	shr	\$24,$tmp2\n&quot;;
-
-	$code.=&quot;	xor	3($sbox,$tmp0,8),$out\n&quot;;
-	$code.=&quot;	xor	2($sbox,$tmp1,8),$out\n&quot;;
-	$code.=&quot;	xor	1($sbox,$tmp2,8),$out\n&quot;;
-
-	$code.=&quot;	mov	$t2,$s[1]\n&quot;		if ($i==3);
-	$code.=&quot;	mov	$t1,$s[2]\n&quot;		if ($i==3);
-	$code.=&quot;	mov	$t0,$s[3]\n&quot;		if ($i==3);
-	$code.=&quot;\n&quot;;
-}
-
-sub declast()
-{ my ($<A HREF="../../../mailman/listinfo/openssl-commits.html">i, at s</A>)=@_;
-  my $tmp0=$acc0;
-  my $tmp1=$acc1;
-  my $tmp2=$acc2;
-  my $out=($t0,$t1,$t2,$s[0])[$i];
-
-	$code.=&quot;	mov	$s[0],$out\n&quot;		if ($i!=3);
-			$tmp1=$s[2]			if ($i==3);
-	$code.=&quot;	mov	$s[2],$tmp1\n&quot;		if ($i!=3);
-	$code.=&quot;	and	\$0xFF,$out\n&quot;;
-
-	$code.=&quot;	movzb	2048($sbox,$out,1),$out\n&quot;;
-	$code.=&quot;	shr	\$16,$tmp1\n&quot;;
-			$tmp2=$s[3]			if ($i==3);
-	$code.=&quot;	mov	$s[3],$tmp2\n&quot;		if ($i!=3);
-
-			$tmp0=$s[1]			if ($i==3);
-	$code.=&quot;	movzb	&quot;.&amp;hi($s[1]).&quot;,$tmp0\n&quot;;
-	$code.=&quot;	and	\$0xFF,$tmp1\n&quot;;
-	$code.=&quot;	shr	\$24,$tmp2\n&quot;;
-
-	$code.=&quot;	movzb	2048($sbox,$tmp0,1),$tmp0\n&quot;;
-	$code.=&quot;	movzb	2048($sbox,$tmp1,1),$tmp1\n&quot;;
-	$code.=&quot;	movzb	2048($sbox,$tmp2,1),$tmp2\n&quot;;
-
-	$code.=&quot;	shl	\$8,$tmp0\n&quot;;
-	$code.=&quot;	shl	\$16,$tmp1\n&quot;;
-	$code.=&quot;	shl	\$24,$tmp2\n&quot;;
-
-	$code.=&quot;	xor	$tmp0,$out\n&quot;;
-	$code.=&quot;	mov	$t2,$s[1]\n&quot;		if ($i==3);
-	$code.=&quot;	xor	$tmp1,$out\n&quot;;
-	$code.=&quot;	mov	$t1,$s[2]\n&quot;		if ($i==3);
-	$code.=&quot;	xor	$tmp2,$out\n&quot;;
-	$code.=&quot;	mov	$t0,$s[3]\n&quot;		if ($i==3);
-	$code.=&quot;\n&quot;;
-}
-
-$code.=&lt;&lt;___;
-.type	_x86_64_AES_decrypt,\@abi-omnipotent
-.align	16
-_x86_64_AES_decrypt:
-	xor	0($key),$s0			# xor with key
-	xor	4($key),$s1
-	xor	8($key),$s2
-	xor	12($key),$s3
-
-	mov	240($key),$rnds			# load key-&gt;rounds
-	sub	\$1,$rnds
-	jmp	.Ldec_loop
-.align	16
-.Ldec_loop:
-___
-	if ($verticalspin) { &amp;decvert(); }
-	else {	&amp;decstep(0,$s0,$s3,$s2,$s1);
-		&amp;decstep(1,$s1,$s0,$s3,$s2);
-		&amp;decstep(2,$s2,$s1,$s0,$s3);
-		&amp;decstep(3,$s3,$s2,$s1,$s0);
-		$code.=&lt;&lt;___;
-		lea	16($key),$key
-		xor	0($key),$s0			# xor with key
-		xor	4($key),$s1
-		xor	8($key),$s2
-		xor	12($key),$s3
-___
-	}
-$code.=&lt;&lt;___;
-	sub	\$1,$rnds
-	jnz	.Ldec_loop
-___
-	if ($verticalspin) { &amp;declastvert(); }
-	else {	&amp;declast(0,$s0,$s3,$s2,$s1);
-		&amp;declast(1,$s1,$s0,$s3,$s2);
-		&amp;declast(2,$s2,$s1,$s0,$s3);
-		&amp;declast(3,$s3,$s2,$s1,$s0);
-		$code.=&lt;&lt;___;
-		xor	16+0($key),$s0			# xor with key
-		xor	16+4($key),$s1
-		xor	16+8($key),$s2
-		xor	16+12($key),$s3
-___
-	}
-$code.=&lt;&lt;___;
-	.byte	0xf3,0xc3			# rep ret
-.size	_x86_64_AES_decrypt,.-_x86_64_AES_decrypt
-___
-
-sub deccompactvert()
-{ my ($t3,$t4,$t5)=(&quot;%r8d&quot;,&quot;%r9d&quot;,&quot;%r13d&quot;);
-
-$code.=&lt;&lt;___;
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$t0
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$t1
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$t2
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$t3
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc0
-	movzb	`&amp;hi(&quot;$s0&quot;)`,$acc1
-	shr	\$16,$s3
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc2
-	movzb	($sbox,$t0,1),$t0
-	movzb	($sbox,$t1,1),$t1
-	movzb	($sbox,$t2,1),$t2
-	movzb	($sbox,$t3,1),$t3
-
-	movzb	($sbox,$acc0,1),$t4	#$t0
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc0
-	movzb	($sbox,$acc1,1),$t5	#$t1
-	movzb	($sbox,$acc2,1),$acc2	#$t2
-	movzb	($sbox,$acc0,1),$acc0	#$t3
-
-	shr	\$16,$s2
-	shl	\$8,$t5
-	shl	\$8,$t4
-	movzb	`&amp;lo(&quot;$s2&quot;)`,$acc1
-	shr	\$16,$s0
-	xor	$t4,$t0
-	shr	\$16,$s1
-	movzb	`&amp;lo(&quot;$s3&quot;)`,$t4
-
-	shl	\$8,$acc2
-	xor	$t5,$t1
-	shl	\$8,$acc0
-	movzb	`&amp;lo(&quot;$s0&quot;)`,$t5
-	movzb	($sbox,$acc1,1),$acc1	#$t0
-	xor	$acc2,$t2
-	movzb	`&amp;lo(&quot;$s1&quot;)`,$acc2
-
-	shl	\$16,$acc1
-	xor	$acc0,$t3
-	movzb	($sbox,$t4,1),$t4	#$t1
-	movzb	`&amp;hi(&quot;$s1&quot;)`,$acc0
-	movzb	($sbox,$acc2,1),$acc2	#$t3
-	xor	$acc1,$t0
-	movzb	($sbox,$t5,1),$t5	#$t2
-	movzb	`&amp;hi(&quot;$s2&quot;)`,$acc1
-
-	shl	\$16,$acc2
-	shl	\$16,$t4
-	shl	\$16,$t5
-	xor	$acc2,$t3
-	movzb	`&amp;hi(&quot;$s3&quot;)`,$acc2
-	xor	$t4,$t1
-	shr	\$8,$s0
-	xor	$t5,$t2
-
-	movzb	($sbox,$acc0,1),$acc0	#$t0
-	movzb	($sbox,$acc1,1),$s1	#$t1
-	movzb	($sbox,$acc2,1),$s2	#$t2
-	movzb	($sbox,$s0,1),$s3	#$t3
-
-	mov	$t0,$s0
-	shl	\$24,$acc0
-	shl	\$24,$s1
-	shl	\$24,$s2
-	xor	$acc0,$s0
-	shl	\$24,$s3
-	xor	$t1,$s1
-	xor	$t2,$s2
-	xor	$t3,$s3
-___
-}
-
-# parallelized version! input is pair of 64-bit values: %rax=s1.s0
-# and %rcx=s3.s2, output is four 32-bit values in %eax=s0, %ebx=s1,
-# %ecx=s2 and %edx=s3.
-sub dectransform()
-{ my ($tp10,$tp20,$tp40,$tp80,$acc0)=(&quot;%rax&quot;,&quot;%r8&quot;, &quot;%r9&quot;, &quot;%r10&quot;,&quot;%rbx&quot;);
-  my ($tp18,$tp28,$tp48,$tp88,$acc8)=(&quot;%rcx&quot;,&quot;%r11&quot;,&quot;%r12&quot;,&quot;%r13&quot;,&quot;%rdx&quot;);
-  my $prefetch = shift;
-
-$code.=&lt;&lt;___;
-	mov	$mask80,$tp40
-	mov	$mask80,$tp48
-	and	$tp10,$tp40
-	and	$tp18,$tp48
-	mov	$tp40,$acc0
-	mov	$tp48,$acc8
-	shr	\$7,$tp40
-	lea	($tp10,$tp10),$tp20
-	shr	\$7,$tp48
-	lea	($tp18,$tp18),$tp28
-	sub	$tp40,$acc0
-	sub	$tp48,$acc8
-	and	$maskfe,$tp20
-	and	$maskfe,$tp28
-	and	$mask1b,$acc0
-	and	$mask1b,$acc8
-	xor	$acc0,$tp20
-	xor	$acc8,$tp28
-	mov	$mask80,$tp80
-	mov	$mask80,$tp88
-
-	and	$tp20,$tp80
-	and	$tp28,$tp88
-	mov	$tp80,$acc0
-	mov	$tp88,$acc8
-	shr	\$7,$tp80
-	lea	($tp20,$tp20),$tp40
-	shr	\$7,$tp88
-	lea	($tp28,$tp28),$tp48
-	sub	$tp80,$acc0
-	sub	$tp88,$acc8
-	and	$maskfe,$tp40
-	and	$maskfe,$tp48
-	and	$mask1b,$acc0
-	and	$mask1b,$acc8
-	xor	$acc0,$tp40
-	xor	$acc8,$tp48
-	mov	$mask80,$tp80
-	mov	$mask80,$tp88
-
-	and	$tp40,$tp80
-	and	$tp48,$tp88
-	mov	$tp80,$acc0
-	mov	$tp88,$acc8
-	shr	\$7,$tp80
-	 xor	$tp10,$tp20		# tp2^=tp1
-	shr	\$7,$tp88
-	 xor	$tp18,$tp28		# tp2^=tp1
-	sub	$tp80,$acc0
-	sub	$tp88,$acc8
-	lea	($tp40,$tp40),$tp80
-	lea	($tp48,$tp48),$tp88
-	 xor	$tp10,$tp40		# tp4^=tp1
-	 xor	$tp18,$tp48		# tp4^=tp1
-	and	$maskfe,$tp80
-	and	$maskfe,$tp88
-	and	$mask1b,$acc0
-	and	$mask1b,$acc8
-	xor	$acc0,$tp80
-	xor	$acc8,$tp88
-
-	xor	$tp80,$tp10		# tp1^=tp8
-	xor	$tp88,$tp18		# tp1^=tp8
-	xor	$tp80,$tp20		# tp2^tp1^=tp8
-	xor	$tp88,$tp28		# tp2^tp1^=tp8
-	mov	$tp10,$acc0
-	mov	$tp18,$acc8
-	xor	$tp80,$tp40		# tp4^tp1^=tp8
-	shr	\$32,$acc0
-	xor	$tp88,$tp48		# tp4^tp1^=tp8
-	shr	\$32,$acc8
-	xor	$tp20,$tp80		# tp8^=tp8^tp2^tp1=tp2^tp1
-	rol	\$8,`&amp;LO(&quot;$tp10&quot;)`	# ROTATE(tp1^tp8,8)
-	xor	$tp28,$tp88		# tp8^=tp8^tp2^tp1=tp2^tp1
-	rol	\$8,`&amp;LO(&quot;$tp18&quot;)`	# ROTATE(tp1^tp8,8)
-	xor	$tp40,$tp80		# tp2^tp1^=tp8^tp4^tp1=tp8^tp4^tp2
-	rol	\$8,`&amp;LO(&quot;$acc0&quot;)`	# ROTATE(tp1^tp8,8)
-	xor	$tp48,$tp88		# tp2^tp1^=tp8^tp4^tp1=tp8^tp4^tp2
-
-	rol	\$8,`&amp;LO(&quot;$acc8&quot;)`	# ROTATE(tp1^tp8,8)
-	xor	`&amp;LO(&quot;$tp80&quot;)`,`&amp;LO(&quot;$tp10&quot;)`
-	shr	\$32,$tp80
-	xor	`&amp;LO(&quot;$tp88&quot;)`,`&amp;LO(&quot;$tp18&quot;)`
-	shr	\$32,$tp88
-	xor	`&amp;LO(&quot;$tp80&quot;)`,`&amp;LO(&quot;$acc0&quot;)`
-	xor	`&amp;LO(&quot;$tp88&quot;)`,`&amp;LO(&quot;$acc8&quot;)`
-
-	mov	$tp20,$tp80
-	rol	\$24,`&amp;LO(&quot;$tp20&quot;)`	# ROTATE(tp2^tp1^tp8,24)
-	mov	$tp28,$tp88
-	rol	\$24,`&amp;LO(&quot;$tp28&quot;)`	# ROTATE(tp2^tp1^tp8,24)
-	shr	\$32,$tp80
-	xor	`&amp;LO(&quot;$tp20&quot;)`,`&amp;LO(&quot;$tp10&quot;)`
-	shr	\$32,$tp88
-	xor	`&amp;LO(&quot;$tp28&quot;)`,`&amp;LO(&quot;$tp18&quot;)`
-	rol	\$24,`&amp;LO(&quot;$tp80&quot;)`	# ROTATE(tp2^tp1^tp8,24)
-	mov	$tp40,$tp20
-	rol	\$24,`&amp;LO(&quot;$tp88&quot;)`	# ROTATE(tp2^tp1^tp8,24)
-	mov	$tp48,$tp28
-	shr	\$32,$tp20
-	xor	`&amp;LO(&quot;$tp80&quot;)`,`&amp;LO(&quot;$acc0&quot;)`
-	shr	\$32,$tp28
-	xor	`&amp;LO(&quot;$tp88&quot;)`,`&amp;LO(&quot;$acc8&quot;)`
-
-	`&quot;mov	0($sbox),$mask80&quot;	if ($prefetch)`
-	rol	\$16,`&amp;LO(&quot;$tp40&quot;)`	# ROTATE(tp4^tp1^tp8,16)
-	`&quot;mov	64($sbox),$maskfe&quot;	if ($prefetch)`
-	rol	\$16,`&amp;LO(&quot;$tp48&quot;)`	# ROTATE(tp4^tp1^tp8,16)
-	`&quot;mov	128($sbox),$mask1b&quot;	if ($prefetch)`
-	rol	\$16,`&amp;LO(&quot;$tp20&quot;)`	# ROTATE(tp4^tp1^tp8,16)
-	`&quot;mov	192($sbox),$tp80&quot;	if ($prefetch)`
-	xor	`&amp;LO(&quot;$tp40&quot;)`,`&amp;LO(&quot;$tp10&quot;)`
-	rol	\$16,`&amp;LO(&quot;$tp28&quot;)`	# ROTATE(tp4^tp1^tp8,16)
-	xor	`&amp;LO(&quot;$tp48&quot;)`,`&amp;LO(&quot;$tp18&quot;)`
-	`&quot;mov	256($sbox),$tp88&quot;	if ($prefetch)`
-	xor	`&amp;LO(&quot;$tp20&quot;)`,`&amp;LO(&quot;$acc0&quot;)`
-	xor	`&amp;LO(&quot;$tp28&quot;)`,`&amp;LO(&quot;$acc8&quot;)`
-___
-}
-
-$code.=&lt;&lt;___;
-.type	_x86_64_AES_decrypt_compact,\@abi-omnipotent
-.align	16
-_x86_64_AES_decrypt_compact:
-.cfi_startproc
-	lea	128($sbox),$inp			# size optimization
-	mov	0-128($inp),$acc1		# prefetch Td4
-	mov	32-128($inp),$acc2
-	mov	64-128($inp),$t0
-	mov	96-128($inp),$t1
-	mov	128-128($inp),$acc1
-	mov	160-128($inp),$acc2
-	mov	192-128($inp),$t0
-	mov	224-128($inp),$t1
-	jmp	.Ldec_loop_compact
-
-.align	16
-.Ldec_loop_compact:
-		xor	0($key),$s0		# xor with key
-		xor	4($key),$s1
-		xor	8($key),$s2
-		xor	12($key),$s3
-		lea	16($key),$key
-___
-		&amp;deccompactvert();
-$code.=&lt;&lt;___;
-		cmp	16(%rsp),$key
-		je	.Ldec_compact_done
-
-		mov	256+0($sbox),$mask80
-		shl	\$32,%rbx
-		shl	\$32,%rdx
-		mov	256+8($sbox),$maskfe
-		or	%rbx,%rax
-		or	%rdx,%rcx
-		mov	256+16($sbox),$mask1b
-___
-		&amp;dectransform(1);
-$code.=&lt;&lt;___;
-	jmp	.Ldec_loop_compact
-.align	16
-.Ldec_compact_done:
-	xor	0($key),$s0
-	xor	4($key),$s1
-	xor	8($key),$s2
-	xor	12($key),$s3
-	.byte	0xf3,0xc3			# rep ret
-.cfi_endproc
-.size	_x86_64_AES_decrypt_compact,.-_x86_64_AES_decrypt_compact
-___
-
-# void AES_decrypt (const void *inp,void *out,const AES_KEY *key);
-$code.=&lt;&lt;___;
-.globl	AES_decrypt
-.type	AES_decrypt,\@function,3
-.align	16
-.globl	asm_AES_decrypt
-.hidden	asm_AES_decrypt
-asm_AES_decrypt:
-AES_decrypt:
-.cfi_startproc
-	mov	%rsp,%rax
-.cfi_def_cfa_register	%rax
-	push	%rbx
-.cfi_push	%rbx
-	push	%rbp
-.cfi_push	%rbp
-	push	%r12
-.cfi_push	%r12
-	push	%r13
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-
-	# allocate frame &quot;above&quot; key schedule
-	lea	-63(%rdx),%rcx	# %rdx is key argument
-	and	\$-64,%rsp
-	sub	%rsp,%rcx
-	neg	%rcx
-	and	\$0x3c0,%rcx
-	sub	%rcx,%rsp
-	sub	\$32,%rsp
-
-	mov	%rsi,16(%rsp)	# save out
-	mov	%rax,24(%rsp)	# save original stack pointer
-.cfi_cfa_expression	%rsp+24,deref,+8
-.Ldec_prologue:
-
-	mov	%rdx,$key
-	mov	240($key),$rnds	# load rounds
-
-	mov	0(%rdi),$s0	# load input vector
-	mov	4(%rdi),$s1
-	mov	8(%rdi),$s2
-	mov	12(%rdi),$s3
-
-	shl	\$4,$rnds
-	lea	($key,$rnds),%rbp
-	mov	$key,(%rsp)	# key schedule
-	mov	%rbp,8(%rsp)	# end of key schedule
-
-	# pick Td4 copy which can't &quot;overlap&quot; with stack frame or key schedule
-	lea	.LAES_Td+2048(%rip),$sbox
-	lea	768(%rsp),%rbp
-	sub	$sbox,%rbp
-	and	\$0x300,%rbp
-	lea	($sbox,%rbp),$sbox
-	shr	\$3,%rbp	# recall &quot;magic&quot; constants!
-	add	%rbp,$sbox
-
-	call	_x86_64_AES_decrypt_compact
-
-	mov	16(%rsp),$out	# restore out
-	mov	24(%rsp),%rsi	# restore saved stack pointer
-.cfi_def_cfa	%rsi,8
-	mov	$s0,0($out)	# write output vector
-	mov	$s1,4($out)
-	mov	$s2,8($out)
-	mov	$s3,12($out)
-
-	mov	-48(%rsi),%r15
-.cfi_restore	%r15
-	mov	-40(%rsi),%r14
-.cfi_restore	%r14
-	mov	-32(%rsi),%r13
-.cfi_restore	%r13
-	mov	-24(%rsi),%r12
-.cfi_restore	%r12
-	mov	-16(%rsi),%rbp
-.cfi_restore	%rbp
-	mov	-8(%rsi),%rbx
-.cfi_restore	%rbx
-	lea	(%rsi),%rsp
-.cfi_def_cfa_register	%rsp
-.Ldec_epilogue:
-	ret
-.cfi_endproc
-.size	AES_decrypt,.-AES_decrypt
-___
-#------------------------------------------------------------------#
-
-sub enckey()
-{
-$code.=&lt;&lt;___;
-	movz	%dl,%esi		# rk[i]&gt;&gt;0
-	movzb	-128(%rbp,%rsi),%ebx
-	movz	%dh,%esi		# rk[i]&gt;&gt;8
-	shl	\$24,%ebx
-	xor	%ebx,%eax
-
-	movzb	-128(%rbp,%rsi),%ebx
-	shr	\$16,%edx
-	movz	%dl,%esi		# rk[i]&gt;&gt;16
-	xor	%ebx,%eax
-
-	movzb	-128(%rbp,%rsi),%ebx
-	movz	%dh,%esi		# rk[i]&gt;&gt;24
-	shl	\$8,%ebx
-	xor	%ebx,%eax
-
-	movzb	-128(%rbp,%rsi),%ebx
-	shl	\$16,%ebx
-	xor	%ebx,%eax
-
-	xor	1024-128(%rbp,%rcx,4),%eax		# rcon
-___
-}
-
-# int AES_set_encrypt_key(const unsigned char *userKey, const int bits,
-#                        AES_KEY *key)
-$code.=&lt;&lt;___;
-.globl	AES_set_encrypt_key
-.type	AES_set_encrypt_key,\@function,3
-.align	16
-AES_set_encrypt_key:
-.cfi_startproc
-	push	%rbx
-.cfi_push	%rbx
-	push	%rbp
-.cfi_push	%rbp
-	push	%r12			# redundant, but allows to share
-.cfi_push	%r12
-	push	%r13			# exception handler...
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-	sub	\$8,%rsp
-.cfi_adjust_cfa_offset	8
-.Lenc_key_prologue:
-
-	call	_x86_64_AES_set_encrypt_key
-
-	mov	40(%rsp),%rbp
-.cfi_restore	%rbp
-	mov	48(%rsp),%rbx
-.cfi_restore	%rbx
-	add	\$56,%rsp
-.cfi_adjust_cfa_offset	-56
-.Lenc_key_epilogue:
-	ret
-.cfi_endproc
-.size	AES_set_encrypt_key,.-AES_set_encrypt_key
-
-.type	_x86_64_AES_set_encrypt_key,\@abi-omnipotent
-.align	16
-_x86_64_AES_set_encrypt_key:
-.cfi_startproc
-	mov	%esi,%ecx			# %ecx=bits
-	mov	%rdi,%rsi			# %rsi=userKey
-	mov	%rdx,%rdi			# %rdi=key
-
-	test	\$-1,%rsi
-	jz	.Lbadpointer
-	test	\$-1,%rdi
-	jz	.Lbadpointer
-
-	lea	.LAES_Te(%rip),%rbp
-	lea	2048+128(%rbp),%rbp
-
-	# prefetch Te4
-	mov	0-128(%rbp),%eax
-	mov	32-128(%rbp),%ebx
-	mov	64-128(%rbp),%r8d
-	mov	96-128(%rbp),%edx
-	mov	128-128(%rbp),%eax
-	mov	160-128(%rbp),%ebx
-	mov	192-128(%rbp),%r8d
-	mov	224-128(%rbp),%edx
-
-	cmp	\$128,%ecx
-	je	.L10rounds
-	cmp	\$192,%ecx
-	je	.L12rounds
-	cmp	\$256,%ecx
-	je	.L14rounds
-	mov	\$-2,%rax			# invalid number of bits
-	jmp	.Lexit
-
-.L10rounds:
-	mov	0(%rsi),%rax			# copy first 4 dwords
-	mov	8(%rsi),%rdx
-	mov	%rax,0(%rdi)
-	mov	%rdx,8(%rdi)
-
-	shr	\$32,%rdx
-	xor	%ecx,%ecx
-	jmp	.L10shortcut
-.align	4
-.L10loop:
-		mov	0(%rdi),%eax			# rk[0]
-		mov	12(%rdi),%edx			# rk[3]
-.L10shortcut:
-___
-		&amp;enckey	();
-$code.=&lt;&lt;___;
-		mov	%eax,16(%rdi)			# rk[4]
-		xor	4(%rdi),%eax
-		mov	%eax,20(%rdi)			# rk[5]
-		xor	8(%rdi),%eax
-		mov	%eax,24(%rdi)			# rk[6]
-		xor	12(%rdi),%eax
-		mov	%eax,28(%rdi)			# rk[7]
-		add	\$1,%ecx
-		lea	16(%rdi),%rdi
-		cmp	\$10,%ecx
-	jl	.L10loop
-
-	movl	\$10,80(%rdi)			# setup number of rounds
-	xor	%rax,%rax
-	jmp	.Lexit
-
-.L12rounds:
-	mov	0(%rsi),%rax			# copy first 6 dwords
-	mov	8(%rsi),%rbx
-	mov	16(%rsi),%rdx
-	mov	%rax,0(%rdi)
-	mov	%rbx,8(%rdi)
-	mov	%rdx,16(%rdi)
-
-	shr	\$32,%rdx
-	xor	%ecx,%ecx
-	jmp	.L12shortcut
-.align	4
-.L12loop:
-		mov	0(%rdi),%eax			# rk[0]
-		mov	20(%rdi),%edx			# rk[5]
-.L12shortcut:
-___
-		&amp;enckey	();
-$code.=&lt;&lt;___;
-		mov	%eax,24(%rdi)			# rk[6]
-		xor	4(%rdi),%eax
-		mov	%eax,28(%rdi)			# rk[7]
-		xor	8(%rdi),%eax
-		mov	%eax,32(%rdi)			# rk[8]
-		xor	12(%rdi),%eax
-		mov	%eax,36(%rdi)			# rk[9]
-
-		cmp	\$7,%ecx
-		je	.L12break
-		add	\$1,%ecx
-
-		xor	16(%rdi),%eax
-		mov	%eax,40(%rdi)			# rk[10]
-		xor	20(%rdi),%eax
-		mov	%eax,44(%rdi)			# rk[11]
-
-		lea	24(%rdi),%rdi
-	jmp	.L12loop
-.L12break:
-	movl	\$12,72(%rdi)		# setup number of rounds
-	xor	%rax,%rax
-	jmp	.Lexit
-
-.L14rounds:
-	mov	0(%rsi),%rax			# copy first 8 dwords
-	mov	8(%rsi),%rbx
-	mov	16(%rsi),%rcx
-	mov	24(%rsi),%rdx
-	mov	%rax,0(%rdi)
-	mov	%rbx,8(%rdi)
-	mov	%rcx,16(%rdi)
-	mov	%rdx,24(%rdi)
-
-	shr	\$32,%rdx
-	xor	%ecx,%ecx
-	jmp	.L14shortcut
-.align	4
-.L14loop:
-		mov	0(%rdi),%eax			# rk[0]
-		mov	28(%rdi),%edx			# rk[4]
-.L14shortcut:
-___
-		&amp;enckey	();
-$code.=&lt;&lt;___;
-		mov	%eax,32(%rdi)			# rk[8]
-		xor	4(%rdi),%eax
-		mov	%eax,36(%rdi)			# rk[9]
-		xor	8(%rdi),%eax
-		mov	%eax,40(%rdi)			# rk[10]
-		xor	12(%rdi),%eax
-		mov	%eax,44(%rdi)			# rk[11]
-
-		cmp	\$6,%ecx
-		je	.L14break
-		add	\$1,%ecx
-
-		mov	%eax,%edx
-		mov	16(%rdi),%eax			# rk[4]
-		movz	%dl,%esi			# rk[11]&gt;&gt;0
-		movzb	-128(%rbp,%rsi),%ebx
-		movz	%dh,%esi			# rk[11]&gt;&gt;8
-		xor	%ebx,%eax
-
-		movzb	-128(%rbp,%rsi),%ebx
-		shr	\$16,%edx
-		shl	\$8,%ebx
-		movz	%dl,%esi			# rk[11]&gt;&gt;16
-		xor	%ebx,%eax
-
-		movzb	-128(%rbp,%rsi),%ebx
-		movz	%dh,%esi			# rk[11]&gt;&gt;24
-		shl	\$16,%ebx
-		xor	%ebx,%eax
-
-		movzb	-128(%rbp,%rsi),%ebx
-		shl	\$24,%ebx
-		xor	%ebx,%eax
-
-		mov	%eax,48(%rdi)			# rk[12]
-		xor	20(%rdi),%eax
-		mov	%eax,52(%rdi)			# rk[13]
-		xor	24(%rdi),%eax
-		mov	%eax,56(%rdi)			# rk[14]
-		xor	28(%rdi),%eax
-		mov	%eax,60(%rdi)			# rk[15]
-
-		lea	32(%rdi),%rdi
-	jmp	.L14loop
-.L14break:
-	movl	\$14,48(%rdi)		# setup number of rounds
-	xor	%rax,%rax
-	jmp	.Lexit
-
-.Lbadpointer:
-	mov	\$-1,%rax
-.Lexit:
-	.byte	0xf3,0xc3			# rep ret
-.cfi_endproc
-.size	_x86_64_AES_set_encrypt_key,.-_x86_64_AES_set_encrypt_key
-___
-
-sub deckey_ref()
-{ my ($i,$ptr,$te,$td) = @_;
-  my ($tp1,$tp2,$tp4,$tp8,$acc)=(&quot;%eax&quot;,&quot;%ebx&quot;,&quot;%edi&quot;,&quot;%edx&quot;,&quot;%r8d&quot;);
-$code.=&lt;&lt;___;
-	mov	$i($ptr),$tp1
-	mov	$tp1,$acc
-	and	\$0x80808080,$acc
-	mov	$acc,$tp4
-	shr	\$7,$tp4
-	lea	0($tp1,$tp1),$tp2
-	sub	$tp4,$acc
-	and	\$0xfefefefe,$tp2
-	and	\$0x1b1b1b1b,$acc
-	xor	$tp2,$acc
-	mov	$acc,$tp2
-
-	and	\$0x80808080,$acc
-	mov	$acc,$tp8
-	shr	\$7,$tp8
-	lea	0($tp2,$tp2),$tp4
-	sub	$tp8,$acc
-	and	\$0xfefefefe,$tp4
-	and	\$0x1b1b1b1b,$acc
-	 xor	$tp1,$tp2		# tp2^tp1
-	xor	$tp4,$acc
-	mov	$acc,$tp4
-
-	and	\$0x80808080,$acc
-	mov	$acc,$tp8
-	shr	\$7,$tp8
-	sub	$tp8,$acc
-	lea	0($tp4,$tp4),$tp8
-	 xor	$tp1,$tp4		# tp4^tp1
-	and	\$0xfefefefe,$tp8
-	and	\$0x1b1b1b1b,$acc
-	xor	$acc,$tp8
-
-	xor	$tp8,$tp1		# tp1^tp8
-	rol	\$8,$tp1		# ROTATE(tp1^tp8,8)
-	xor	$tp8,$tp2		# tp2^tp1^tp8
-	xor	$tp8,$tp4		# tp4^tp1^tp8
-	xor	$tp2,$tp8
-	xor	$tp4,$tp8		# tp8^(tp8^tp4^tp1)^(tp8^tp2^tp1)=tp8^tp4^tp2
-
-	xor	$tp8,$tp1
-	rol	\$24,$tp2		# ROTATE(tp2^tp1^tp8,24)
-	xor	$tp2,$tp1
-	rol	\$16,$tp4		# ROTATE(tp4^tp1^tp8,16)
-	xor	$tp4,$tp1
-
-	mov	$tp1,$i($ptr)
-___
-}
-
-# int AES_set_decrypt_key(const unsigned char *userKey, const int bits,
-#                        AES_KEY *key)
-$code.=&lt;&lt;___;
-.globl	AES_set_decrypt_key
-.type	AES_set_decrypt_key,\@function,3
-.align	16
-AES_set_decrypt_key:
-.cfi_startproc
-	push	%rbx
-.cfi_push	%rbx
-	push	%rbp
-.cfi_push	%rbp
-	push	%r12
-.cfi_push	%r12
-	push	%r13
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-	push	%rdx			# save key schedule
-.cfi_adjust_cfa_offset	8
-.Ldec_key_prologue:
-
-	call	_x86_64_AES_set_encrypt_key
-	mov	(%rsp),%r8		# restore key schedule
-	cmp	\$0,%eax
-	jne	.Labort
-
-	mov	240(%r8),%r14d		# pull number of rounds
-	xor	%rdi,%rdi
-	lea	(%rdi,%r14d,4),%rcx
-	mov	%r8,%rsi
-	lea	(%r8,%rcx,4),%rdi	# pointer to last chunk
-.align	4
-.Linvert:
-		mov	0(%rsi),%rax
-		mov	8(%rsi),%rbx
-		mov	0(%rdi),%rcx
-		mov	8(%rdi),%rdx
-		mov	%rax,0(%rdi)
-		mov	%rbx,8(%rdi)
-		mov	%rcx,0(%rsi)
-		mov	%rdx,8(%rsi)
-		lea	16(%rsi),%rsi
-		lea	-16(%rdi),%rdi
-		cmp	%rsi,%rdi
-	jne	.Linvert
-
-	lea	.LAES_Te+2048+1024(%rip),%rax	# rcon
-
-	mov	40(%rax),$mask80
-	mov	48(%rax),$maskfe
-	mov	56(%rax),$mask1b
-
-	mov	%r8,$key
-	sub	\$1,%r14d
-.align	4
-.Lpermute:
-		lea	16($key),$key
-		mov	0($key),%rax
-		mov	8($key),%rcx
-___
-		&amp;dectransform ();
-$code.=&lt;&lt;___;
-		mov	%eax,0($key)
-		mov	%ebx,4($key)
-		mov	%ecx,8($key)
-		mov	%edx,12($key)
-		sub	\$1,%r14d
-	jnz	.Lpermute
-
-	xor	%rax,%rax
-.Labort:
-	mov	8(%rsp),%r15
-.cfi_restore	%r15
-	mov	16(%rsp),%r14
-.cfi_restore	%r14
-	mov	24(%rsp),%r13
-.cfi_restore	%r13
-	mov	32(%rsp),%r12
-.cfi_restore	%r12
-	mov	40(%rsp),%rbp
-.cfi_restore	%rbp
-	mov	48(%rsp),%rbx
-.cfi_restore	%rbx
-	add	\$56,%rsp
-.cfi_adjust_cfa_offset	-56
-.Ldec_key_epilogue:
-	ret
-.cfi_endproc
-.size	AES_set_decrypt_key,.-AES_set_decrypt_key
-___
-
-# void AES_cbc_encrypt (const void char *inp, unsigned char *out,
-#			size_t length, const AES_KEY *key,
-#			unsigned char *ivp,const int enc);
-{
-# stack frame layout
-# -8(%rsp)		return address
-my $keyp=&quot;0(%rsp)&quot;;		# one to pass as $key
-my $keyend=&quot;8(%rsp)&quot;;		# &amp;(keyp-&gt;rd_key[4*keyp-&gt;rounds])
-my $_rsp=&quot;16(%rsp)&quot;;		# saved %rsp
-my $_inp=&quot;24(%rsp)&quot;;		# copy of 1st parameter, inp
-my $_out=&quot;32(%rsp)&quot;;		# copy of 2nd parameter, out
-my $_len=&quot;40(%rsp)&quot;;		# copy of 3rd parameter, length
-my $_key=&quot;48(%rsp)&quot;;		# copy of 4th parameter, key
-my $_ivp=&quot;56(%rsp)&quot;;		# copy of 5th parameter, ivp
-my $ivec=&quot;64(%rsp)&quot;;		# ivec[16]
-my $aes_key=&quot;80(%rsp)&quot;;		# copy of aes_key
-my $mark=&quot;80+240(%rsp)&quot;;	# copy of aes_key-&gt;rounds
-
-$code.=&lt;&lt;___;
-.globl	AES_cbc_encrypt
-.type	AES_cbc_encrypt,\@function,6
-.align	16
-.extern	OPENSSL_ia32cap_P
-.globl	asm_AES_cbc_encrypt
-.hidden	asm_AES_cbc_encrypt
-asm_AES_cbc_encrypt:
-AES_cbc_encrypt:
-.cfi_startproc
-	cmp	\$0,%rdx	# check length
-	je	.Lcbc_epilogue
-	pushfq
-# This could be .cfi_push 49, but libunwind fails on registers it does not
-# recognize. See <A HREF="https://bugzilla.redhat.com/show_bug.cgi?id=217087.">https://bugzilla.redhat.com/show_bug.cgi?id=217087.</A>
-.cfi_adjust_cfa_offset	8
-	push	%rbx
-.cfi_push	%rbx
-	push	%rbp
-.cfi_push	%rbp
-	push	%r12
-.cfi_push	%r12
-	push	%r13
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-.Lcbc_prologue:
-
-	cld
-	mov	%r9d,%r9d	# clear upper half of enc
-
-	lea	.LAES_Te(%rip),$sbox
-	lea	.LAES_Td(%rip),%r10
-	cmp	\$0,%r9
-	cmoveq	%r10,$sbox
-
-.cfi_remember_state
-	mov	OPENSSL_ia32cap_P(%rip),%r10d
-	cmp	\$$speed_limit,%rdx
-	jb	.Lcbc_slow_prologue
-	test	\$15,%rdx
-	jnz	.Lcbc_slow_prologue
-	bt	\$28,%r10d
-	jc	.Lcbc_slow_prologue
-
-	# allocate aligned stack frame...
-	lea	-88-248(%rsp),$key
-	and	\$-64,$key
-
-	# ... and make sure it doesn't alias with AES_T[ed] modulo 4096
-	mov	$sbox,%r10
-	lea	2304($sbox),%r11
-	mov	$key,%r12
-	and	\$0xFFF,%r10	# s = $sbox&amp;0xfff
-	and	\$0xFFF,%r11	# e = ($sbox+2048)&amp;0xfff
-	and	\$0xFFF,%r12	# p = %rsp&amp;0xfff
-
-	cmp	%r11,%r12	# if (p=&gt;e) %rsp =- (p-e);
-	jb	.Lcbc_te_break_out
-	sub	%r11,%r12
-	sub	%r12,$key
-	jmp	.Lcbc_te_ok
-.Lcbc_te_break_out:		# else %rsp -= (p-s)&amp;0xfff + framesz
-	sub	%r10,%r12
-	and	\$0xFFF,%r12
-	add	\$320,%r12
-	sub	%r12,$key
-.align	4
-.Lcbc_te_ok:
-
-	xchg	%rsp,$key
-.cfi_def_cfa_register	$key
-	#add	\$8,%rsp	# reserve for return address!
-	mov	$key,$_rsp	# save %rsp
-.cfi_cfa_expression	$_rsp,deref,+64
-.Lcbc_fast_body:
-	mov	%rdi,$_inp	# save copy of inp
-	mov	%rsi,$_out	# save copy of out
-	mov	%rdx,$_len	# save copy of len
-	mov	%rcx,$_key	# save copy of key
-	mov	%r8,$_ivp	# save copy of ivp
-	movl	\$0,$mark	# copy of aes_key-&gt;rounds = 0;
-	mov	%r8,%rbp	# rearrange input arguments
-	mov	%r9,%rbx
-	mov	%rsi,$out
-	mov	%rdi,$inp
-	mov	%rcx,$key
-
-	mov	240($key),%eax		# key-&gt;rounds
-	# do we copy key schedule to stack?
-	mov	$key,%r10
-	sub	$sbox,%r10
-	and	\$0xfff,%r10
-	cmp	\$2304,%r10
-	jb	.Lcbc_do_ecopy
-	cmp	\$4096-248,%r10
-	jb	.Lcbc_skip_ecopy
-.align	4
-.Lcbc_do_ecopy:
-		mov	$key,%rsi
-		lea	$aes_key,%rdi
-		lea	$aes_key,$key
-		mov	\$240/8,%ecx
-		.long	0x90A548F3	# rep movsq
-		mov	%eax,(%rdi)	# copy aes_key-&gt;rounds
-.Lcbc_skip_ecopy:
-	mov	$key,$keyp	# save key pointer
-
-	mov	\$18,%ecx
-.align	4
-.Lcbc_prefetch_te:
-		mov	0($sbox),%r10
-		mov	32($sbox),%r11
-		mov	64($sbox),%r12
-		mov	96($sbox),%r13
-		lea	128($sbox),$sbox
-		sub	\$1,%ecx
-	jnz	.Lcbc_prefetch_te
-	lea	-2304($sbox),$sbox
-
-	cmp	\$0,%rbx
-	je	.LFAST_DECRYPT
-
-#----------------------------- ENCRYPT -----------------------------#
-	mov	0(%rbp),$s0		# load iv
-	mov	4(%rbp),$s1
-	mov	8(%rbp),$s2
-	mov	12(%rbp),$s3
-
-.align	4
-.Lcbc_fast_enc_loop:
-		xor	0($inp),$s0
-		xor	4($inp),$s1
-		xor	8($inp),$s2
-		xor	12($inp),$s3
-		mov	$keyp,$key	# restore key
-		mov	$inp,$_inp	# if ($verticalspin) save inp
-
-		call	_x86_64_AES_encrypt
-
-		mov	$_inp,$inp	# if ($verticalspin) restore inp
-		mov	$_len,%r10
-		mov	$s0,0($out)
-		mov	$s1,4($out)
-		mov	$s2,8($out)
-		mov	$s3,12($out)
-
-		lea	16($inp),$inp
-		lea	16($out),$out
-		sub	\$16,%r10
-		test	\$-16,%r10
-		mov	%r10,$_len
-	jnz	.Lcbc_fast_enc_loop
-	mov	$_ivp,%rbp	# restore ivp
-	mov	$s0,0(%rbp)	# save ivec
-	mov	$s1,4(%rbp)
-	mov	$s2,8(%rbp)
-	mov	$s3,12(%rbp)
-
-	jmp	.Lcbc_fast_cleanup
-
-#----------------------------- DECRYPT -----------------------------#
-.align	16
-.LFAST_DECRYPT:
-	cmp	$inp,$out
-	je	.Lcbc_fast_dec_in_place
-
-	mov	%rbp,$ivec
-.align	4
-.Lcbc_fast_dec_loop:
-		mov	0($inp),$s0	# read input
-		mov	4($inp),$s1
-		mov	8($inp),$s2
-		mov	12($inp),$s3
-		mov	$keyp,$key	# restore key
-		mov	$inp,$_inp	# if ($verticalspin) save inp
-
-		call	_x86_64_AES_decrypt
-
-		mov	$ivec,%rbp	# load ivp
-		mov	$_inp,$inp	# if ($verticalspin) restore inp
-		mov	$_len,%r10	# load len
-		xor	0(%rbp),$s0	# xor iv
-		xor	4(%rbp),$s1
-		xor	8(%rbp),$s2
-		xor	12(%rbp),$s3
-		mov	$inp,%rbp	# current input, next iv
-
-		sub	\$16,%r10
-		mov	%r10,$_len	# update len
-		mov	%rbp,$ivec	# update ivp
-
-		mov	$s0,0($out)	# write output
-		mov	$s1,4($out)
-		mov	$s2,8($out)
-		mov	$s3,12($out)
-
-		lea	16($inp),$inp
-		lea	16($out),$out
-	jnz	.Lcbc_fast_dec_loop
-	mov	$_ivp,%r12		# load user ivp
-	mov	0(%rbp),%r10		# load iv
-	mov	8(%rbp),%r11
-	mov	%r10,0(%r12)		# copy back to user
-	mov	%r11,8(%r12)
-	jmp	.Lcbc_fast_cleanup
-
-.align	16
-.Lcbc_fast_dec_in_place:
-	mov	0(%rbp),%r10		# copy iv to stack
-	mov	8(%rbp),%r11
-	mov	%r10,0+$ivec
-	mov	%r11,8+$ivec
-.align	4
-.Lcbc_fast_dec_in_place_loop:
-		mov	0($inp),$s0	# load input
-		mov	4($inp),$s1
-		mov	8($inp),$s2
-		mov	12($inp),$s3
-		mov	$keyp,$key	# restore key
-		mov	$inp,$_inp	# if ($verticalspin) save inp
-
-		call	_x86_64_AES_decrypt
-
-		mov	$_inp,$inp	# if ($verticalspin) restore inp
-		mov	$_len,%r10
-		xor	0+$ivec,$s0
-		xor	4+$ivec,$s1
-		xor	8+$ivec,$s2
-		xor	12+$ivec,$s3
-
-		mov	0($inp),%r11	# load input
-		mov	8($inp),%r12
-		sub	\$16,%r10
-		jz	.Lcbc_fast_dec_in_place_done
-
-		mov	%r11,0+$ivec	# copy input to iv
-		mov	%r12,8+$ivec
-
-		mov	$s0,0($out)	# save output [zaps input]
-		mov	$s1,4($out)
-		mov	$s2,8($out)
-		mov	$s3,12($out)
-
-		lea	16($inp),$inp
-		lea	16($out),$out
-		mov	%r10,$_len
-	jmp	.Lcbc_fast_dec_in_place_loop
-.Lcbc_fast_dec_in_place_done:
-	mov	$_ivp,%rdi
-	mov	%r11,0(%rdi)	# copy iv back to user
-	mov	%r12,8(%rdi)
-
-	mov	$s0,0($out)	# save output [zaps input]
-	mov	$s1,4($out)
-	mov	$s2,8($out)
-	mov	$s3,12($out)
-
-.align	4
-.Lcbc_fast_cleanup:
-	cmpl	\$0,$mark	# was the key schedule copied?
-	lea	$aes_key,%rdi
-	je	.Lcbc_exit
-		mov	\$240/8,%ecx
-		xor	%rax,%rax
-		.long	0x90AB48F3	# rep stosq
-
-	jmp	.Lcbc_exit
-
-#--------------------------- SLOW ROUTINE ---------------------------#
-.align	16
-.Lcbc_slow_prologue:
-.cfi_restore_state
-	# allocate aligned stack frame...
-	lea	-88(%rsp),%rbp
-	and	\$-64,%rbp
-	# ... just &quot;above&quot; key schedule
-	lea	-88-63(%rcx),%r10
-	sub	%rbp,%r10
-	neg	%r10
-	and	\$0x3c0,%r10
-	sub	%r10,%rbp
-
-	xchg	%rsp,%rbp
-.cfi_def_cfa_register	%rbp
-	#add	\$8,%rsp	# reserve for return address!
-	mov	%rbp,$_rsp	# save %rsp
-.cfi_cfa_expression	$_rsp,deref,+64
-.Lcbc_slow_body:
-	#mov	%rdi,$_inp	# save copy of inp
-	#mov	%rsi,$_out	# save copy of out
-	#mov	%rdx,$_len	# save copy of len
-	#mov	%rcx,$_key	# save copy of key
-	mov	%r8,$_ivp	# save copy of ivp
-	mov	%r8,%rbp	# rearrange input arguments
-	mov	%r9,%rbx
-	mov	%rsi,$out
-	mov	%rdi,$inp
-	mov	%rcx,$key
-	mov	%rdx,%r10
-
-	mov	240($key),%eax
-	mov	$key,$keyp	# save key pointer
-	shl	\$4,%eax
-	lea	($key,%rax),%rax
-	mov	%rax,$keyend
-
-	# pick Te4 copy which can't &quot;overlap&quot; with stack frame or key schedule
-	lea	2048($sbox),$sbox
-	lea	768-8(%rsp),%rax
-	sub	$sbox,%rax
-	and	\$0x300,%rax
-	lea	($sbox,%rax),$sbox
-
-	cmp	\$0,%rbx
-	je	.LSLOW_DECRYPT
-
-#--------------------------- SLOW ENCRYPT ---------------------------#
-	test	\$-16,%r10		# check upon length
-	mov	0(%rbp),$s0		# load iv
-	mov	4(%rbp),$s1
-	mov	8(%rbp),$s2
-	mov	12(%rbp),$s3
-	jz	.Lcbc_slow_enc_tail	# short input...
-
-.align	4
-.Lcbc_slow_enc_loop:
-		xor	0($inp),$s0
-		xor	4($inp),$s1
-		xor	8($inp),$s2
-		xor	12($inp),$s3
-		mov	$keyp,$key	# restore key
-		mov	$inp,$_inp	# save inp
-		mov	$out,$_out	# save out
-		mov	%r10,$_len	# save len
-
-		call	_x86_64_AES_encrypt_compact
-
-		mov	$_inp,$inp	# restore inp
-		mov	$_out,$out	# restore out
-		mov	$_len,%r10	# restore len
-		mov	$s0,0($out)
-		mov	$s1,4($out)
-		mov	$s2,8($out)
-		mov	$s3,12($out)
-
-		lea	16($inp),$inp
-		lea	16($out),$out
-		sub	\$16,%r10
-		test	\$-16,%r10
-	jnz	.Lcbc_slow_enc_loop
-	test	\$15,%r10
-	jnz	.Lcbc_slow_enc_tail
-	mov	$_ivp,%rbp	# restore ivp
-	mov	$s0,0(%rbp)	# save ivec
-	mov	$s1,4(%rbp)
-	mov	$s2,8(%rbp)
-	mov	$s3,12(%rbp)
-
-	jmp	.Lcbc_exit
-
-.align	4
-.Lcbc_slow_enc_tail:
-	mov	%rax,%r11
-	mov	%rcx,%r12
-	mov	%r10,%rcx
-	mov	$inp,%rsi
-	mov	$out,%rdi
-	.long	0x9066A4F3		# rep movsb
-	mov	\$16,%rcx		# zero tail
-	sub	%r10,%rcx
-	xor	%rax,%rax
-	.long	0x9066AAF3		# rep stosb
-	mov	$out,$inp		# this is not a mistake!
-	mov	\$16,%r10		# len=16
-	mov	%r11,%rax
-	mov	%r12,%rcx
-	jmp	.Lcbc_slow_enc_loop	# one more spin...
-#--------------------------- SLOW DECRYPT ---------------------------#
-.align	16
-.LSLOW_DECRYPT:
-	shr	\$3,%rax
-	add	%rax,$sbox		# recall &quot;magic&quot; constants!
-
-	mov	0(%rbp),%r11		# copy iv to stack
-	mov	8(%rbp),%r12
-	mov	%r11,0+$ivec
-	mov	%r12,8+$ivec
-
-.align	4
-.Lcbc_slow_dec_loop:
-		mov	0($inp),$s0	# load input
-		mov	4($inp),$s1
-		mov	8($inp),$s2
-		mov	12($inp),$s3
-		mov	$keyp,$key	# restore key
-		mov	$inp,$_inp	# save inp
-		mov	$out,$_out	# save out
-		mov	%r10,$_len	# save len
-
-		call	_x86_64_AES_decrypt_compact
-
-		mov	$_inp,$inp	# restore inp
-		mov	$_out,$out	# restore out
-		mov	$_len,%r10
-		xor	0+$ivec,$s0
-		xor	4+$ivec,$s1
-		xor	8+$ivec,$s2
-		xor	12+$ivec,$s3
-
-		mov	0($inp),%r11	# load input
-		mov	8($inp),%r12
-		sub	\$16,%r10
-		jc	.Lcbc_slow_dec_partial
-		jz	.Lcbc_slow_dec_done
-
-		mov	%r11,0+$ivec	# copy input to iv
-		mov	%r12,8+$ivec
-
-		mov	$s0,0($out)	# save output [can zap input]
-		mov	$s1,4($out)
-		mov	$s2,8($out)
-		mov	$s3,12($out)
-
-		lea	16($inp),$inp
-		lea	16($out),$out
-	jmp	.Lcbc_slow_dec_loop
-.Lcbc_slow_dec_done:
-	mov	$_ivp,%rdi
-	mov	%r11,0(%rdi)		# copy iv back to user
-	mov	%r12,8(%rdi)
-
-	mov	$s0,0($out)		# save output [can zap input]
-	mov	$s1,4($out)
-	mov	$s2,8($out)
-	mov	$s3,12($out)
-
-	jmp	.Lcbc_exit
-
-.align	4
-.Lcbc_slow_dec_partial:
-	mov	$_ivp,%rdi
-	mov	%r11,0(%rdi)		# copy iv back to user
-	mov	%r12,8(%rdi)
-
-	mov	$s0,0+$ivec		# save output to stack
-	mov	$s1,4+$ivec
-	mov	$s2,8+$ivec
-	mov	$s3,12+$ivec
-
-	mov	$out,%rdi
-	lea	$ivec,%rsi
-	lea	16(%r10),%rcx
-	.long	0x9066A4F3	# rep movsb
-	jmp	.Lcbc_exit
-
-.align	16
-.Lcbc_exit:
-	mov	$_rsp,%rsi
-.cfi_def_cfa	%rsi,64
-	mov	(%rsi),%r15
-.cfi_restore	%r15
-	mov	8(%rsi),%r14
-.cfi_restore	%r14
-	mov	16(%rsi),%r13
-.cfi_restore	%r13
-	mov	24(%rsi),%r12
-.cfi_restore	%r12
-	mov	32(%rsi),%rbp
-.cfi_restore	%rbp
-	mov	40(%rsi),%rbx
-.cfi_restore	%rbx
-	lea	48(%rsi),%rsp
-.cfi_def_cfa	%rsp,16
-.Lcbc_popfq:
-	popfq
-# This could be .cfi_pop 49, but libunwind fails on registers it does not
-# recognize. See <A HREF="https://bugzilla.redhat.com/show_bug.cgi?id=217087.">https://bugzilla.redhat.com/show_bug.cgi?id=217087.</A>
-.cfi_adjust_cfa_offset	-8
-.Lcbc_epilogue:
-	ret
-.cfi_endproc
-.size	AES_cbc_encrypt,.-AES_cbc_encrypt
-___
-}
-
-$code.=&lt;&lt;___;
-.align	64
-.LAES_Te:
-___
-	&amp;_data_word(0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6);
-	&amp;_data_word(0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591);
-	&amp;_data_word(0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56);
-	&amp;_data_word(0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec);
-	&amp;_data_word(0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa);
-	&amp;_data_word(0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb);
-	&amp;_data_word(0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45);
-	&amp;_data_word(0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b);
-	&amp;_data_word(0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c);
-	&amp;_data_word(0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83);
-	&amp;_data_word(0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9);
-	&amp;_data_word(0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a);
-	&amp;_data_word(0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d);
-	&amp;_data_word(0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f);
-	&amp;_data_word(0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df);
-	&amp;_data_word(0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea);
-	&amp;_data_word(0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34);
-	&amp;_data_word(0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b);
-	&amp;_data_word(0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d);
-	&amp;_data_word(0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413);
-	&amp;_data_word(0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1);
-	&amp;_data_word(0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6);
-	&amp;_data_word(0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972);
-	&amp;_data_word(0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85);
-	&amp;_data_word(0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed);
-	&amp;_data_word(0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511);
-	&amp;_data_word(0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe);
-	&amp;_data_word(0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b);
-	&amp;_data_word(0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05);
-	&amp;_data_word(0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1);
-	&amp;_data_word(0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142);
-	&amp;_data_word(0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf);
-	&amp;_data_word(0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3);
-	&amp;_data_word(0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e);
-	&amp;_data_word(0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a);
-	&amp;_data_word(0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6);
-	&amp;_data_word(0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3);
-	&amp;_data_word(0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b);
-	&amp;_data_word(0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428);
-	&amp;_data_word(0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad);
-	&amp;_data_word(0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14);
-	&amp;_data_word(0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8);
-	&amp;_data_word(0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4);
-	&amp;_data_word(0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2);
-	&amp;_data_word(0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda);
-	&amp;_data_word(0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949);
-	&amp;_data_word(0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf);
-	&amp;_data_word(0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810);
-	&amp;_data_word(0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c);
-	&amp;_data_word(0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697);
-	&amp;_data_word(0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e);
-	&amp;_data_word(0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f);
-	&amp;_data_word(0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc);
-	&amp;_data_word(0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c);
-	&amp;_data_word(0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969);
-	&amp;_data_word(0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27);
-	&amp;_data_word(0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122);
-	&amp;_data_word(0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433);
-	&amp;_data_word(0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9);
-	&amp;_data_word(0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5);
-	&amp;_data_word(0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a);
-	&amp;_data_word(0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0);
-	&amp;_data_word(0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e);
-	&amp;_data_word(0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c);
-
-#Te4	# four copies of Te4 to choose from to avoid L1 aliasing
-	&amp;data_byte(0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5);
-	&amp;data_byte(0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76);
-	&amp;data_byte(0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0);
-	&amp;data_byte(0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0);
-	&amp;data_byte(0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc);
-	&amp;data_byte(0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15);
-	&amp;data_byte(0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a);
-	&amp;data_byte(0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75);
-	&amp;data_byte(0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0);
-	&amp;data_byte(0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84);
-	&amp;data_byte(0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b);
-	&amp;data_byte(0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf);
-	&amp;data_byte(0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85);
-	&amp;data_byte(0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8);
-	&amp;data_byte(0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5);
-	&amp;data_byte(0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2);
-	&amp;data_byte(0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17);
-	&amp;data_byte(0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73);
-	&amp;data_byte(0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88);
-	&amp;data_byte(0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb);
-	&amp;data_byte(0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c);
-	&amp;data_byte(0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79);
-	&amp;data_byte(0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9);
-	&amp;data_byte(0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08);
-	&amp;data_byte(0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6);
-	&amp;data_byte(0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a);
-	&amp;data_byte(0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e);
-	&amp;data_byte(0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e);
-	&amp;data_byte(0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94);
-	&amp;data_byte(0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf);
-	&amp;data_byte(0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68);
-	&amp;data_byte(0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16);
-
-	&amp;data_byte(0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5);
-	&amp;data_byte(0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76);
-	&amp;data_byte(0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0);
-	&amp;data_byte(0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0);
-	&amp;data_byte(0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc);
-	&amp;data_byte(0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15);
-	&amp;data_byte(0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a);
-	&amp;data_byte(0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75);
-	&amp;data_byte(0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0);
-	&amp;data_byte(0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84);
-	&amp;data_byte(0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b);
-	&amp;data_byte(0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf);
-	&amp;data_byte(0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85);
-	&amp;data_byte(0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8);
-	&amp;data_byte(0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5);
-	&amp;data_byte(0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2);
-	&amp;data_byte(0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17);
-	&amp;data_byte(0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73);
-	&amp;data_byte(0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88);
-	&amp;data_byte(0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb);
-	&amp;data_byte(0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c);
-	&amp;data_byte(0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79);
-	&amp;data_byte(0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9);
-	&amp;data_byte(0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08);
-	&amp;data_byte(0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6);
-	&amp;data_byte(0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a);
-	&amp;data_byte(0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e);
-	&amp;data_byte(0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e);
-	&amp;data_byte(0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94);
-	&amp;data_byte(0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf);
-	&amp;data_byte(0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68);
-	&amp;data_byte(0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16);
-
-	&amp;data_byte(0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5);
-	&amp;data_byte(0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76);
-	&amp;data_byte(0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0);
-	&amp;data_byte(0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0);
-	&amp;data_byte(0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc);
-	&amp;data_byte(0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15);
-	&amp;data_byte(0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a);
-	&amp;data_byte(0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75);
-	&amp;data_byte(0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0);
-	&amp;data_byte(0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84);
-	&amp;data_byte(0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b);
-	&amp;data_byte(0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf);
-	&amp;data_byte(0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85);
-	&amp;data_byte(0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8);
-	&amp;data_byte(0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5);
-	&amp;data_byte(0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2);
-	&amp;data_byte(0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17);
-	&amp;data_byte(0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73);
-	&amp;data_byte(0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88);
-	&amp;data_byte(0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb);
-	&amp;data_byte(0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c);
-	&amp;data_byte(0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79);
-	&amp;data_byte(0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9);
-	&amp;data_byte(0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08);
-	&amp;data_byte(0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6);
-	&amp;data_byte(0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a);
-	&amp;data_byte(0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e);
-	&amp;data_byte(0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e);
-	&amp;data_byte(0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94);
-	&amp;data_byte(0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf);
-	&amp;data_byte(0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68);
-	&amp;data_byte(0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16);
-
-	&amp;data_byte(0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5);
-	&amp;data_byte(0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76);
-	&amp;data_byte(0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0);
-	&amp;data_byte(0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0);
-	&amp;data_byte(0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc);
-	&amp;data_byte(0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15);
-	&amp;data_byte(0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a);
-	&amp;data_byte(0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75);
-	&amp;data_byte(0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0);
-	&amp;data_byte(0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84);
-	&amp;data_byte(0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b);
-	&amp;data_byte(0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf);
-	&amp;data_byte(0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85);
-	&amp;data_byte(0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8);
-	&amp;data_byte(0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5);
-	&amp;data_byte(0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2);
-	&amp;data_byte(0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17);
-	&amp;data_byte(0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73);
-	&amp;data_byte(0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88);
-	&amp;data_byte(0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb);
-	&amp;data_byte(0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c);
-	&amp;data_byte(0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79);
-	&amp;data_byte(0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9);
-	&amp;data_byte(0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08);
-	&amp;data_byte(0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6);
-	&amp;data_byte(0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a);
-	&amp;data_byte(0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e);
-	&amp;data_byte(0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e);
-	&amp;data_byte(0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94);
-	&amp;data_byte(0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf);
-	&amp;data_byte(0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68);
-	&amp;data_byte(0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16);
-#rcon:
-$code.=&lt;&lt;___;
-	.long	0x00000001, 0x00000002, 0x00000004, 0x00000008
-	.long	0x00000010, 0x00000020, 0x00000040, 0x00000080
-	.long	0x0000001b, 0x00000036, 0x80808080, 0x80808080
-	.long	0xfefefefe, 0xfefefefe, 0x1b1b1b1b, 0x1b1b1b1b
-___
-$code.=&lt;&lt;___;
-.align	64
-.LAES_Td:
-___
-	&amp;_data_word(0x50a7f451, 0x5365417e, 0xc3a4171a, 0x965e273a);
-	&amp;_data_word(0xcb6bab3b, 0xf1459d1f, 0xab58faac, 0x9303e34b);
-	&amp;_data_word(0x55fa3020, 0xf66d76ad, 0x9176cc88, 0x254c02f5);
-	&amp;_data_word(0xfcd7e54f, 0xd7cb2ac5, 0x80443526, 0x8fa362b5);
-	&amp;_data_word(0x495ab1de, 0x671bba25, 0x980eea45, 0xe1c0fe5d);
-	&amp;_data_word(0x02752fc3, 0x12f04c81, 0xa397468d, 0xc6f9d36b);
-	&amp;_data_word(0xe75f8f03, 0x959c9215, 0xeb7a6dbf, 0xda595295);
-	&amp;_data_word(0x2d83bed4, 0xd3217458, 0x2969e049, 0x44c8c98e);
-	&amp;_data_word(0x6a89c275, 0x78798ef4, 0x6b3e5899, 0xdd71b927);
-	&amp;_data_word(0xb64fe1be, 0x17ad88f0, 0x66ac20c9, 0xb43ace7d);
-	&amp;_data_word(0x184adf63, 0x82311ae5, 0x60335197, 0x457f5362);
-	&amp;_data_word(0xe07764b1, 0x84ae6bbb, 0x1ca081fe, 0x942b08f9);
-	&amp;_data_word(0x58684870, 0x19fd458f, 0x876cde94, 0xb7f87b52);
-	&amp;_data_word(0x23d373ab, 0xe2024b72, 0x578f1fe3, 0x2aab5566);
-	&amp;_data_word(0x0728ebb2, 0x03c2b52f, 0x9a7bc586, 0xa50837d3);
-	&amp;_data_word(0xf2872830, 0xb2a5bf23, 0xba6a0302, 0x5c8216ed);
-	&amp;_data_word(0x2b1ccf8a, 0x92b479a7, 0xf0f207f3, 0xa1e2694e);
-	&amp;_data_word(0xcdf4da65, 0xd5be0506, 0x1f6234d1, 0x8afea6c4);
-	&amp;_data_word(0x9d532e34, 0xa055f3a2, 0x32e18a05, 0x75ebf6a4);
-	&amp;_data_word(0x39ec830b, 0xaaef6040, 0x069f715e, 0x51106ebd);
-	&amp;_data_word(0xf98a213e, 0x3d06dd96, 0xae053edd, 0x46bde64d);
-	&amp;_data_word(0xb58d5491, 0x055dc471, 0x6fd40604, 0xff155060);
-	&amp;_data_word(0x24fb9819, 0x97e9bdd6, 0xcc434089, 0x779ed967);
-	&amp;_data_word(0xbd42e8b0, 0x888b8907, 0x385b19e7, 0xdbeec879);
-	&amp;_data_word(0x470a7ca1, 0xe90f427c, 0xc91e84f8, 0x00000000);
-	&amp;_data_word(0x83868009, 0x48ed2b32, 0xac70111e, 0x4e725a6c);
-	&amp;_data_word(0xfbff0efd, 0x5638850f, 0x1ed5ae3d, 0x27392d36);
-	&amp;_data_word(0x64d90f0a, 0x21a65c68, 0xd1545b9b, 0x3a2e3624);
-	&amp;_data_word(0xb1670a0c, 0x0fe75793, 0xd296eeb4, 0x9e919b1b);
-	&amp;_data_word(0x4fc5c080, 0xa220dc61, 0x694b775a, 0x161a121c);
-	&amp;_data_word(0x0aba93e2, 0xe52aa0c0, 0x43e0223c, 0x1d171b12);
-	&amp;_data_word(0x0b0d090e, 0xadc78bf2, 0xb9a8b62d, 0xc8a91e14);
-	&amp;_data_word(0x8519f157, 0x4c0775af, 0xbbdd99ee, 0xfd607fa3);
-	&amp;_data_word(0x9f2601f7, 0xbcf5725c, 0xc53b6644, 0x347efb5b);
-	&amp;_data_word(0x7629438b, 0xdcc623cb, 0x68fcedb6, 0x63f1e4b8);
-	&amp;_data_word(0xcadc31d7, 0x10856342, 0x40229713, 0x2011c684);
-	&amp;_data_word(0x7d244a85, 0xf83dbbd2, 0x1132f9ae, 0x6da129c7);
-	&amp;_data_word(0x4b2f9e1d, 0xf330b2dc, 0xec52860d, 0xd0e3c177);
-	&amp;_data_word(0x6c16b32b, 0x99b970a9, 0xfa489411, 0x2264e947);
-	&amp;_data_word(0xc48cfca8, 0x1a3ff0a0, 0xd82c7d56, 0xef903322);
-	&amp;_data_word(0xc74e4987, 0xc1d138d9, 0xfea2ca8c, 0x360bd498);
-	&amp;_data_word(0xcf81f5a6, 0x28de7aa5, 0x268eb7da, 0xa4bfad3f);
-	&amp;_data_word(0xe49d3a2c, 0x0d927850, 0x9bcc5f6a, 0x62467e54);
-	&amp;_data_word(0xc2138df6, 0xe8b8d890, 0x5ef7392e, 0xf5afc382);
-	&amp;_data_word(0xbe805d9f, 0x7c93d069, 0xa92dd56f, 0xb31225cf);
-	&amp;_data_word(0x3b99acc8, 0xa77d1810, 0x6e639ce8, 0x7bbb3bdb);
-	&amp;_data_word(0x097826cd, 0xf418596e, 0x01b79aec, 0xa89a4f83);
-	&amp;_data_word(0x656e95e6, 0x7ee6ffaa, 0x08cfbc21, 0xe6e815ef);
-	&amp;_data_word(0xd99be7ba, 0xce366f4a, 0xd4099fea, 0xd67cb029);
-	&amp;_data_word(0xafb2a431, 0x31233f2a, 0x3094a5c6, 0xc066a235);
-	&amp;_data_word(0x37bc4e74, 0xa6ca82fc, 0xb0d090e0, 0x15d8a733);
-	&amp;_data_word(0x4a9804f1, 0xf7daec41, 0x0e50cd7f, 0x2ff69117);
-	&amp;_data_word(0x8dd64d76, 0x4db0ef43, 0x544daacc, 0xdf0496e4);
-	&amp;_data_word(0xe3b5d19e, 0x1b886a4c, 0xb81f2cc1, 0x7f516546);
-	&amp;_data_word(0x04ea5e9d, 0x5d358c01, 0x737487fa, 0x2e410bfb);
-	&amp;_data_word(0x5a1d67b3, 0x52d2db92, 0x335610e9, 0x1347d66d);
-	&amp;_data_word(0x8c61d79a, 0x7a0ca137, 0x8e14f859, 0x893c13eb);
-	&amp;_data_word(0xee27a9ce, 0x35c961b7, 0xede51ce1, 0x3cb1477a);
-	&amp;_data_word(0x59dfd29c, 0x3f73f255, 0x79ce1418, 0xbf37c773);
-	&amp;_data_word(0xeacdf753, 0x5baafd5f, 0x146f3ddf, 0x86db4478);
-	&amp;_data_word(0x81f3afca, 0x3ec468b9, 0x2c342438, 0x5f40a3c2);
-	&amp;_data_word(0x72c31d16, 0x0c25e2bc, 0x8b493c28, 0x41950dff);
-	&amp;_data_word(0x7101a839, 0xdeb30c08, 0x9ce4b4d8, 0x90c15664);
-	&amp;_data_word(0x6184cb7b, 0x70b632d5, 0x745c6c48, 0x4257b8d0);
-
-#Td4:	# four copies of Td4 to choose from to avoid L1 aliasing
-	&amp;data_byte(0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38);
-	&amp;data_byte(0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb);
-	&amp;data_byte(0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87);
-	&amp;data_byte(0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb);
-	&amp;data_byte(0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d);
-	&amp;data_byte(0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e);
-	&amp;data_byte(0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2);
-	&amp;data_byte(0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25);
-	&amp;data_byte(0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16);
-	&amp;data_byte(0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92);
-	&amp;data_byte(0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda);
-	&amp;data_byte(0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84);
-	&amp;data_byte(0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a);
-	&amp;data_byte(0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06);
-	&amp;data_byte(0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02);
-	&amp;data_byte(0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b);
-	&amp;data_byte(0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea);
-	&amp;data_byte(0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73);
-	&amp;data_byte(0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85);
-	&amp;data_byte(0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e);
-	&amp;data_byte(0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89);
-	&amp;data_byte(0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b);
-	&amp;data_byte(0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20);
-	&amp;data_byte(0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4);
-	&amp;data_byte(0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31);
-	&amp;data_byte(0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f);
-	&amp;data_byte(0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d);
-	&amp;data_byte(0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef);
-	&amp;data_byte(0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0);
-	&amp;data_byte(0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61);
-	&amp;data_byte(0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26);
-	&amp;data_byte(0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d);
-$code.=&lt;&lt;___;
-	.long	0x80808080, 0x80808080, 0xfefefefe, 0xfefefefe
-	.long	0x1b1b1b1b, 0x1b1b1b1b, 0, 0
-___
-	&amp;data_byte(0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38);
-	&amp;data_byte(0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb);
-	&amp;data_byte(0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87);
-	&amp;data_byte(0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb);
-	&amp;data_byte(0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d);
-	&amp;data_byte(0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e);
-	&amp;data_byte(0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2);
-	&amp;data_byte(0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25);
-	&amp;data_byte(0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16);
-	&amp;data_byte(0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92);
-	&amp;data_byte(0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda);
-	&amp;data_byte(0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84);
-	&amp;data_byte(0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a);
-	&amp;data_byte(0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06);
-	&amp;data_byte(0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02);
-	&amp;data_byte(0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b);
-	&amp;data_byte(0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea);
-	&amp;data_byte(0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73);
-	&amp;data_byte(0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85);
-	&amp;data_byte(0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e);
-	&amp;data_byte(0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89);
-	&amp;data_byte(0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b);
-	&amp;data_byte(0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20);
-	&amp;data_byte(0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4);
-	&amp;data_byte(0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31);
-	&amp;data_byte(0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f);
-	&amp;data_byte(0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d);
-	&amp;data_byte(0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef);
-	&amp;data_byte(0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0);
-	&amp;data_byte(0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61);
-	&amp;data_byte(0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26);
-	&amp;data_byte(0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d);
-$code.=&lt;&lt;___;
-	.long	0x80808080, 0x80808080, 0xfefefefe, 0xfefefefe
-	.long	0x1b1b1b1b, 0x1b1b1b1b, 0, 0
-___
-	&amp;data_byte(0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38);
-	&amp;data_byte(0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb);
-	&amp;data_byte(0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87);
-	&amp;data_byte(0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb);
-	&amp;data_byte(0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d);
-	&amp;data_byte(0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e);
-	&amp;data_byte(0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2);
-	&amp;data_byte(0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25);
-	&amp;data_byte(0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16);
-	&amp;data_byte(0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92);
-	&amp;data_byte(0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda);
-	&amp;data_byte(0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84);
-	&amp;data_byte(0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a);
-	&amp;data_byte(0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06);
-	&amp;data_byte(0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02);
-	&amp;data_byte(0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b);
-	&amp;data_byte(0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea);
-	&amp;data_byte(0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73);
-	&amp;data_byte(0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85);
-	&amp;data_byte(0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e);
-	&amp;data_byte(0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89);
-	&amp;data_byte(0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b);
-	&amp;data_byte(0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20);
-	&amp;data_byte(0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4);
-	&amp;data_byte(0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31);
-	&amp;data_byte(0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f);
-	&amp;data_byte(0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d);
-	&amp;data_byte(0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef);
-	&amp;data_byte(0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0);
-	&amp;data_byte(0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61);
-	&amp;data_byte(0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26);
-	&amp;data_byte(0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d);
-$code.=&lt;&lt;___;
-	.long	0x80808080, 0x80808080, 0xfefefefe, 0xfefefefe
-	.long	0x1b1b1b1b, 0x1b1b1b1b, 0, 0
-___
-	&amp;data_byte(0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38);
-	&amp;data_byte(0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb);
-	&amp;data_byte(0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87);
-	&amp;data_byte(0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb);
-	&amp;data_byte(0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d);
-	&amp;data_byte(0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e);
-	&amp;data_byte(0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2);
-	&amp;data_byte(0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25);
-	&amp;data_byte(0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16);
-	&amp;data_byte(0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92);
-	&amp;data_byte(0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda);
-	&amp;data_byte(0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84);
-	&amp;data_byte(0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a);
-	&amp;data_byte(0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06);
-	&amp;data_byte(0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02);
-	&amp;data_byte(0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b);
-	&amp;data_byte(0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea);
-	&amp;data_byte(0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73);
-	&amp;data_byte(0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85);
-	&amp;data_byte(0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e);
-	&amp;data_byte(0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89);
-	&amp;data_byte(0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b);
-	&amp;data_byte(0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20);
-	&amp;data_byte(0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4);
-	&amp;data_byte(0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31);
-	&amp;data_byte(0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f);
-	&amp;data_byte(0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d);
-	&amp;data_byte(0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef);
-	&amp;data_byte(0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0);
-	&amp;data_byte(0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61);
-	&amp;data_byte(0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26);
-	&amp;data_byte(0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d);
-$code.=&lt;&lt;___;
-	.long	0x80808080, 0x80808080, 0xfefefefe, 0xfefefefe
-	.long	0x1b1b1b1b, 0x1b1b1b1b, 0, 0
-.asciz  &quot;AES for x86_64, CRYPTOGAMS by &lt;appro\@openssl.org&gt;&quot;
-.align	64
-___
-
-# EXCEPTION_DISPOSITION handler (EXCEPTION_RECORD *rec,ULONG64 frame,
-#		CONTEXT *context,DISPATCHER_CONTEXT *disp)
-if ($win64) {
-$rec=&quot;%rcx&quot;;
-$frame=&quot;%rdx&quot;;
-$context=&quot;%r8&quot;;
-$disp=&quot;%r9&quot;;
-
-$code.=&lt;&lt;___;
-.extern	__imp_RtlVirtualUnwind
-.type	block_se_handler,\@abi-omnipotent
-.align	16
-block_se_handler:
-	push	%rsi
-	push	%rdi
-	push	%rbx
-	push	%rbp
-	push	%r12
-	push	%r13
-	push	%r14
-	push	%r15
-	pushfq
-	sub	\$64,%rsp
-
-	mov	120($context),%rax	# pull context-&gt;Rax
-	mov	248($context),%rbx	# pull context-&gt;Rip
-
-	mov	8($disp),%rsi		# disp-&gt;ImageBase
-	mov	56($disp),%r11		# disp-&gt;HandlerData
-
-	mov	0(%r11),%r10d		# HandlerData[0]
-	lea	(%rsi,%r10),%r10	# prologue label
-	cmp	%r10,%rbx		# context-&gt;Rip&lt;prologue label
-	jb	.Lin_block_prologue
-
-	mov	152($context),%rax	# pull context-&gt;Rsp
-
-	mov	4(%r11),%r10d		# HandlerData[1]
-	lea	(%rsi,%r10),%r10	# epilogue label
-	cmp	%r10,%rbx		# context-&gt;Rip&gt;=epilogue label
-	jae	.Lin_block_prologue
-
-	mov	24(%rax),%rax		# pull saved real stack pointer
-
-	mov	-8(%rax),%rbx
-	mov	-16(%rax),%rbp
-	mov	-24(%rax),%r12
-	mov	-32(%rax),%r13
-	mov	-40(%rax),%r14
-	mov	-48(%rax),%r15
-	mov	%rbx,144($context)	# restore context-&gt;Rbx
-	mov	%rbp,160($context)	# restore context-&gt;Rbp
-	mov	%r12,216($context)	# restore context-&gt;R12
-	mov	%r13,224($context)	# restore context-&gt;R13
-	mov	%r14,232($context)	# restore context-&gt;R14
-	mov	%r15,240($context)	# restore context-&gt;R15
-
-.Lin_block_prologue:
-	mov	8(%rax),%rdi
-	mov	16(%rax),%rsi
-	mov	%rax,152($context)	# restore context-&gt;Rsp
-	mov	%rsi,168($context)	# restore context-&gt;Rsi
-	mov	%rdi,176($context)	# restore context-&gt;Rdi
-
-	jmp	.Lcommon_seh_exit
-.size	block_se_handler,.-block_se_handler
-
-.type	key_se_handler,\@abi-omnipotent
-.align	16
-key_se_handler:
-	push	%rsi
-	push	%rdi
-	push	%rbx
-	push	%rbp
-	push	%r12
-	push	%r13
-	push	%r14
-	push	%r15
-	pushfq
-	sub	\$64,%rsp
-
-	mov	120($context),%rax	# pull context-&gt;Rax
-	mov	248($context),%rbx	# pull context-&gt;Rip
-
-	mov	8($disp),%rsi		# disp-&gt;ImageBase
-	mov	56($disp),%r11		# disp-&gt;HandlerData
-
-	mov	0(%r11),%r10d		# HandlerData[0]
-	lea	(%rsi,%r10),%r10	# prologue label
-	cmp	%r10,%rbx		# context-&gt;Rip&lt;prologue label
-	jb	.Lin_key_prologue
-
-	mov	152($context),%rax	# pull context-&gt;Rsp
-
-	mov	4(%r11),%r10d		# HandlerData[1]
-	lea	(%rsi,%r10),%r10	# epilogue label
-	cmp	%r10,%rbx		# context-&gt;Rip&gt;=epilogue label
-	jae	.Lin_key_prologue
-
-	lea	56(%rax),%rax
-
-	mov	-8(%rax),%rbx
-	mov	-16(%rax),%rbp
-	mov	-24(%rax),%r12
-	mov	-32(%rax),%r13
-	mov	-40(%rax),%r14
-	mov	-48(%rax),%r15
-	mov	%rbx,144($context)	# restore context-&gt;Rbx
-	mov	%rbp,160($context)	# restore context-&gt;Rbp
-	mov	%r12,216($context)	# restore context-&gt;R12
-	mov	%r13,224($context)	# restore context-&gt;R13
-	mov	%r14,232($context)	# restore context-&gt;R14
-	mov	%r15,240($context)	# restore context-&gt;R15
-
-.Lin_key_prologue:
-	mov	8(%rax),%rdi
-	mov	16(%rax),%rsi
-	mov	%rax,152($context)	# restore context-&gt;Rsp
-	mov	%rsi,168($context)	# restore context-&gt;Rsi
-	mov	%rdi,176($context)	# restore context-&gt;Rdi
-
-	jmp	.Lcommon_seh_exit
-.size	key_se_handler,.-key_se_handler
-
-.type	cbc_se_handler,\@abi-omnipotent
-.align	16
-cbc_se_handler:
-	push	%rsi
-	push	%rdi
-	push	%rbx
-	push	%rbp
-	push	%r12
-	push	%r13
-	push	%r14
-	push	%r15
-	pushfq
-	sub	\$64,%rsp
-
-	mov	120($context),%rax	# pull context-&gt;Rax
-	mov	248($context),%rbx	# pull context-&gt;Rip
-
-	lea	.Lcbc_prologue(%rip),%r10
-	cmp	%r10,%rbx		# context-&gt;Rip&lt;.Lcbc_prologue
-	jb	.Lin_cbc_prologue
-
-	lea	.Lcbc_fast_body(%rip),%r10
-	cmp	%r10,%rbx		# context-&gt;Rip&lt;.Lcbc_fast_body
-	jb	.Lin_cbc_frame_setup
-
-	lea	.Lcbc_slow_prologue(%rip),%r10
-	cmp	%r10,%rbx		# context-&gt;Rip&lt;.Lcbc_slow_prologue
-	jb	.Lin_cbc_body
-
-	lea	.Lcbc_slow_body(%rip),%r10
-	cmp	%r10,%rbx		# context-&gt;Rip&lt;.Lcbc_slow_body
-	jb	.Lin_cbc_frame_setup
-
-.Lin_cbc_body:
-	mov	152($context),%rax	# pull context-&gt;Rsp
-
-	lea	.Lcbc_epilogue(%rip),%r10
-	cmp	%r10,%rbx		# context-&gt;Rip&gt;=.Lcbc_epilogue
-	jae	.Lin_cbc_prologue
-
-	lea	8(%rax),%rax
-
-	lea	.Lcbc_popfq(%rip),%r10
-	cmp	%r10,%rbx		# context-&gt;Rip&gt;=.Lcbc_popfq
-	jae	.Lin_cbc_prologue
-
-	mov	`16-8`(%rax),%rax	# biased $_rsp
-	lea	56(%rax),%rax
-
-.Lin_cbc_frame_setup:
-	mov	-16(%rax),%rbx
-	mov	-24(%rax),%rbp
-	mov	-32(%rax),%r12
-	mov	-40(%rax),%r13
-	mov	-48(%rax),%r14
-	mov	-56(%rax),%r15
-	mov	%rbx,144($context)	# restore context-&gt;Rbx
-	mov	%rbp,160($context)	# restore context-&gt;Rbp
-	mov	%r12,216($context)	# restore context-&gt;R12
-	mov	%r13,224($context)	# restore context-&gt;R13
-	mov	%r14,232($context)	# restore context-&gt;R14
-	mov	%r15,240($context)	# restore context-&gt;R15
-
-.Lin_cbc_prologue:
-	mov	8(%rax),%rdi
-	mov	16(%rax),%rsi
-	mov	%rax,152($context)	# restore context-&gt;Rsp
-	mov	%rsi,168($context)	# restore context-&gt;Rsi
-	mov	%rdi,176($context)	# restore context-&gt;Rdi
-
-.Lcommon_seh_exit:
-
-	mov	40($disp),%rdi		# disp-&gt;ContextRecord
-	mov	$context,%rsi		# context
-	mov	\$`1232/8`,%ecx		# sizeof(CONTEXT)
-	.long	0xa548f3fc		# cld; rep movsq
-
-	mov	$disp,%rsi
-	xor	%rcx,%rcx		# arg1, UNW_FLAG_NHANDLER
-	mov	8(%rsi),%rdx		# arg2, disp-&gt;ImageBase
-	mov	0(%rsi),%r8		# arg3, disp-&gt;ControlPc
-	mov	16(%rsi),%r9		# arg4, disp-&gt;FunctionEntry
-	mov	40(%rsi),%r10		# disp-&gt;ContextRecord
-	lea	56(%rsi),%r11		# &amp;disp-&gt;HandlerData
-	lea	24(%rsi),%r12		# &amp;disp-&gt;EstablisherFrame
-	mov	%r10,32(%rsp)		# arg5
-	mov	%r11,40(%rsp)		# arg6
-	mov	%r12,48(%rsp)		# arg7
-	mov	%rcx,56(%rsp)		# arg8, (NULL)
-	call	*__imp_RtlVirtualUnwind(%rip)
-
-	mov	\$1,%eax		# ExceptionContinueSearch
-	add	\$64,%rsp
-	popfq
-	pop	%r15
-	pop	%r14
-	pop	%r13
-	pop	%r12
-	pop	%rbp
-	pop	%rbx
-	pop	%rdi
-	pop	%rsi
-	ret
-.size	cbc_se_handler,.-cbc_se_handler
-
-.section	.pdata
-.align	4
-	.rva	.LSEH_begin_AES_encrypt
-	.rva	.LSEH_end_AES_encrypt
-	.rva	.LSEH_info_AES_encrypt
-
-	.rva	.LSEH_begin_AES_decrypt
-	.rva	.LSEH_end_AES_decrypt
-	.rva	.LSEH_info_AES_decrypt
-
-	.rva	.LSEH_begin_AES_set_encrypt_key
-	.rva	.LSEH_end_AES_set_encrypt_key
-	.rva	.LSEH_info_AES_set_encrypt_key
-
-	.rva	.LSEH_begin_AES_set_decrypt_key
-	.rva	.LSEH_end_AES_set_decrypt_key
-	.rva	.LSEH_info_AES_set_decrypt_key
-
-	.rva	.LSEH_begin_AES_cbc_encrypt
-	.rva	.LSEH_end_AES_cbc_encrypt
-	.rva	.LSEH_info_AES_cbc_encrypt
-
-.section	.xdata
-.align	8
-.LSEH_info_AES_encrypt:
-	.byte	9,0,0,0
-	.rva	block_se_handler
-	.rva	.Lenc_prologue,.Lenc_epilogue	# HandlerData[]
-.LSEH_info_AES_decrypt:
-	.byte	9,0,0,0
-	.rva	block_se_handler
-	.rva	.Ldec_prologue,.Ldec_epilogue	# HandlerData[]
-.LSEH_info_AES_set_encrypt_key:
-	.byte	9,0,0,0
-	.rva	key_se_handler
-	.rva	.Lenc_key_prologue,.Lenc_key_epilogue	# HandlerData[]
-.LSEH_info_AES_set_decrypt_key:
-	.byte	9,0,0,0
-	.rva	key_se_handler
-	.rva	.Ldec_key_prologue,.Ldec_key_epilogue	# HandlerData[]
-.LSEH_info_AES_cbc_encrypt:
-	.byte	9,0,0,0
-	.rva	cbc_se_handler
-___
-}
-
-$code =~ s/\`([^\`]*)\`/eval($1)/gem;
-
-print $code;
-
-close STDOUT;
diff --git a/crypto/aes/asm/bsaes-x86_64.pl b/crypto/aes/asm/bsaes-x86_64.pl
deleted file mode 100644
index e62342729e..0000000000
--- a/crypto/aes/asm/bsaes-x86_64.pl
+++ /dev/null
@@ -1,3239 +0,0 @@
-#! /usr/bin/env perl
-# Copyright 2011-2019 The OpenSSL Project Authors. All Rights Reserved.
-#
-# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
-# this file except in compliance with the License.  You can obtain a copy
-# in the file LICENSE in the source distribution or at
-# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
-
-
-###################################################################
-### AES-128 [originally in CTR mode]				###
-### bitsliced implementation for Intel Core 2 processors	###
-### requires support of SSE extensions up to SSSE3		###
-### Author: Emilia K&#228;sper and Peter Schwabe			###
-### Date: 2009-03-19						###
-### Public domain						###
-###								###
-### See <A HREF="http://homes.esat.kuleuven.be/~ekasper/#software">http://homes.esat.kuleuven.be/~ekasper/#software</A> for	###
-### further information.					###
-###################################################################
-#
-# September 2011.
-#
-# Started as transliteration to &quot;perlasm&quot; the original code has
-# undergone following changes:
-#
-# - code was made position-independent;
-# - rounds were folded into a loop resulting in &gt;5x size reduction
-#   from 12.5KB to 2.2KB;
-# - above was possibile thanks to mixcolumns() modification that
-#   allowed to feed its output back to aesenc[last], this was
-#   achieved at cost of two additional inter-registers moves;
-# - some instruction reordering and interleaving;
-# - this module doesn't implement key setup subroutine, instead it
-#   relies on conversion of &quot;conventional&quot; key schedule as returned
-#   by AES_set_encrypt_key (see discussion below);
-# - first and last round keys are treated differently, which allowed
-#   to skip one shiftrows(), reduce bit-sliced key schedule and
-#   speed-up conversion by 22%;
-# - support for 192- and 256-bit keys was added;
-#
-# Resulting performance in CPU cycles spent to encrypt one byte out
-# of 4096-byte buffer with 128-bit key is:
-#
-#		Emilia's	this(*)		difference
-#
-# Core 2    	9.30		8.69		+7%
-# Nehalem(**) 	7.63		6.88		+11%
-# Atom	    	17.1		16.4		+4%
-# Silvermont	-		12.9
-# Goldmont	-		8.85
-#
-# (*)	Comparison is not completely fair, because &quot;this&quot; is ECB,
-#	i.e. no extra processing such as counter values calculation
-#	and xor-ing input as in Emilia's CTR implementation is
-#	performed. However, the CTR calculations stand for not more
-#	than 1% of total time, so comparison is *rather* fair.
-#
-# (**)	Results were collected on Westmere, which is considered to
-#	be equivalent to Nehalem for this code.
-#
-# As for key schedule conversion subroutine. Interface to OpenSSL
-# relies on per-invocation on-the-fly conversion. This naturally
-# has impact on performance, especially for short inputs. Conversion
-# time in CPU cycles and its ratio to CPU cycles spent in 8x block
-# function is:
-#
-# 		conversion	conversion/8x block
-# Core 2	240		0.22
-# Nehalem	180		0.20
-# Atom		430		0.20
-#
-# The ratio values mean that 128-byte blocks will be processed
-# 16-18% slower, 256-byte blocks - 9-10%, 384-byte blocks - 6-7%,
-# etc. Then keep in mind that input sizes not divisible by 128 are
-# *effectively* slower, especially shortest ones, e.g. consecutive
-# 144-byte blocks are processed 44% slower than one would expect,
-# 272 - 29%, 400 - 22%, etc. Yet, despite all these &quot;shortcomings&quot;
-# it's still faster than [&quot;hyper-threading-safe&quot; code path in]
-# aes-x86_64.pl on all lengths above 64 bytes...
-#
-# October 2011.
-#
-# Add decryption procedure. Performance in CPU cycles spent to decrypt
-# one byte out of 4096-byte buffer with 128-bit key is:
-#
-# Core 2	9.98
-# Nehalem	7.80
-# Atom		17.9
-# Silvermont	14.0
-# Goldmont	10.2
-#
-# November 2011.
-#
-# Add bsaes_xts_[en|de]crypt. Less-than-80-bytes-block performance is
-# suboptimal, but XTS is meant to be used with larger blocks...
-#
-#						&lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
-
-$flavour = shift;
-$output  = shift;
-if ($flavour =~ /\./) { $output = $flavour; undef $flavour; }
-
-$win64=0; $win64=1 if ($flavour =~ /[nm]asm|mingw64/ || $output =~ /\.asm$/);
-
-$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
-( $xlate=&quot;${dir}x86_64-xlate.pl&quot; and -f $xlate ) or
-( $xlate=&quot;${dir}../../perlasm/x86_64-xlate.pl&quot; and -f $xlate) or
-die &quot;can't locate x86_64-xlate.pl&quot;;
-
-open OUT,&quot;| \&quot;$^X\&quot; \&quot;$xlate\&quot; $flavour \&quot;$output\&quot;&quot;;
-*STDOUT=*OUT;
-
-my ($inp,$out,$len,$key,$ivp)=(&quot;%rdi&quot;,&quot;%rsi&quot;,&quot;%rdx&quot;,&quot;%rcx&quot;);
-my @XMM=map(&quot;%xmm$_&quot;,(15,0..14));	# best on Atom, +10% over (0..15)
-my $ecb=0;	# suppress unreferenced ECB subroutines, spare some space...
-
-{
-my ($key,$rounds,$const)=(&quot;%rax&quot;,&quot;%r10d&quot;,&quot;%r11&quot;);
-
-sub Sbox {
-# input in  lsb &gt; [b0, b1, b2, b3, b4, b5, b6, b7] &lt; msb
-# output in lsb &gt; [b0, b1, b4, b6, b3, b7, b2, b5] &lt; msb
-my @b=@_[0..7];
-my @t=@_[8..11];
-my @s=@_[12..15];
-	&amp;InBasisChange	(@b);
-	&amp;Inv_GF256	(@b[6,5,0,3,7,1,4,2]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at t</A><A HREF="../../../mailman/listinfo/openssl-commits.html">, at s</A>);
-	&amp;OutBasisChange	(@b[7,1,4,2,6,5,0,3]);
-}
-
-sub InBasisChange {
-# input in  lsb &gt; [b0, b1, b2, b3, b4, b5, b6, b7] &lt; msb
-# output in lsb &gt; [b6, b5, b0, b3, b7, b1, b4, b2] &lt; msb
-my @b=@_[0..7];
-$code.=&lt;&lt;___;
-	pxor	@b[6], @b[5]
-	pxor	@b[1], @b[2]
-	pxor	@b[0], @b[3]
-	pxor	@b[2], @b[6]
-	pxor 	@b[0], @b[5]
-
-	pxor	@b[3], @b[6]
-	pxor	@b[7], @b[3]
-	pxor	@b[5], @b[7]
-	pxor	@b[4], @b[3]
-	pxor	@b[5], @b[4]
-	pxor	@b[1], @b[3]
-
-	pxor	@b[7], @b[2]
-	pxor	@b[5], @b[1]
-___
-}
-
-sub OutBasisChange {
-# input in  lsb &gt; [b0, b1, b2, b3, b4, b5, b6, b7] &lt; msb
-# output in lsb &gt; [b6, b1, b2, b4, b7, b0, b3, b5] &lt; msb
-my @b=@_[0..7];
-$code.=&lt;&lt;___;
-	pxor	@b[6], @b[0]
-	pxor	@b[4], @b[1]
-	pxor	@b[0], @b[2]
-	pxor	@b[6], @b[4]
-	pxor	@b[1], @b[6]
-
-	pxor	@b[5], @b[1]
-	pxor	@b[3], @b[5]
-	pxor	@b[7], @b[3]
-	pxor	@b[5], @b[7]
-	pxor	@b[5], @b[2]
-
-	pxor	@b[7], @b[4]
-___
-}
-
-sub InvSbox {
-# input in lsb 	&gt; [b0, b1, b2, b3, b4, b5, b6, b7] &lt; msb
-# output in lsb	&gt; [b0, b1, b6, b4, b2, b7, b3, b5] &lt; msb
-my @b=@_[0..7];
-my @t=@_[8..11];
-my @s=@_[12..15];
-	&amp;InvInBasisChange	(@b);
-	&amp;Inv_GF256		(@b[5,1,2,6,3,7,0,4]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at t</A><A HREF="../../../mailman/listinfo/openssl-commits.html">, at s</A>);
-	&amp;InvOutBasisChange	(@b[3,7,0,4,5,1,2,6]);
-}
-
-sub InvInBasisChange {		# OutBasisChange in reverse
-my @b=@_[5,1,2,6,3,7,0,4];
-$code.=&lt;&lt;___
-	pxor	@b[7], @b[4]
-
-	pxor	@b[5], @b[7]
-	pxor	@b[5], @b[2]
-	pxor	@b[7], @b[3]
-	pxor	@b[3], @b[5]
-	pxor	@b[5], @b[1]
-
-	pxor	@b[1], @b[6]
-	pxor	@b[0], @b[2]
-	pxor	@b[6], @b[4]
-	pxor	@b[6], @b[0]
-	pxor	@b[4], @b[1]
-___
-}
-
-sub InvOutBasisChange {		# InBasisChange in reverse
-my @b=@_[2,5,7,3,6,1,0,4];
-$code.=&lt;&lt;___;
-	pxor	@b[5], @b[1]
-	pxor	@b[7], @b[2]
-
-	pxor	@b[1], @b[3]
-	pxor	@b[5], @b[4]
-	pxor	@b[5], @b[7]
-	pxor	@b[4], @b[3]
-	 pxor 	@b[0], @b[5]
-	pxor	@b[7], @b[3]
-	 pxor	@b[2], @b[6]
-	 pxor	@b[1], @b[2]
-	pxor	@b[3], @b[6]
-
-	pxor	@b[0], @b[3]
-	pxor	@b[6], @b[5]
-___
-}
-
-sub Mul_GF4 {
-#;*************************************************************
-#;* Mul_GF4: Input x0-x1,y0-y1 Output x0-x1 Temp t0 (8) *
-#;*************************************************************
-my ($x0,$x1,$y0,$y1,$t0)=@_;
-$code.=&lt;&lt;___;
-	movdqa	$y0, $t0
-	pxor 	$y1, $t0
-	pand	$x0, $t0
-	pxor	$x1, $x0
-	pand	$y0, $x1
-	pand	$y1, $x0
-	pxor	$x1, $x0
-	pxor	$t0, $x1
-___
-}
-
-sub Mul_GF4_N {				# not used, see next subroutine
-# multiply and scale by N
-my ($x0,$x1,$y0,$y1,$t0)=@_;
-$code.=&lt;&lt;___;
-	movdqa	$y0, $t0
-	pxor	$y1, $t0
-	pand	$x0, $t0
-	pxor	$x1, $x0
-	pand	$y0, $x1
-	pand	$y1, $x0
-	pxor	$x0, $x1
-	pxor	$t0, $x0
-___
-}
-
-sub Mul_GF4_N_GF4 {
-# interleaved Mul_GF4_N and Mul_GF4
-my ($x0,$x1,$y0,$y1,$t0,
-    $x2,$x3,$y2,$y3,$t1)=@_;
-$code.=&lt;&lt;___;
-	movdqa	$y0, $t0
-	 movdqa	$y2, $t1
-	pxor	$y1, $t0
-	 pxor 	$y3, $t1
-	pand	$x0, $t0
-	 pand	$x2, $t1
-	pxor	$x1, $x0
-	 pxor	$x3, $x2
-	pand	$y0, $x1
-	 pand	$y2, $x3
-	pand	$y1, $x0
-	 pand	$y3, $x2
-	pxor	$x0, $x1
-	 pxor	$x3, $x2
-	pxor	$t0, $x0
-	 pxor	$t1, $x3
-___
-}
-sub Mul_GF16_2 {
-my @x=@_[0..7];
-my @y=@_[8..11];
-my @t=@_[12..15];
-$code.=&lt;&lt;___;
-	movdqa	@x[0], @t[0]
-	movdqa	@x[1], @t[1]
-___
-	&amp;Mul_GF4  	(@x[0], @x[1], @y[0], @y[1], @t[2]);
-$code.=&lt;&lt;___;
-	pxor	@x[2], @t[0]
-	pxor	@x[3], @t[1]
-	pxor	@y[2], @y[0]
-	pxor	@y[3], @y[1]
-___
-	Mul_GF4_N_GF4	(@t[0], @t[1], @y[0], @y[1], @t[3],
-			 @x[2], @x[3], @y[2], @y[3], @t[2]);
-$code.=&lt;&lt;___;
-	pxor	@t[0], @x[0]
-	pxor	@t[0], @x[2]
-	pxor	@t[1], @x[1]
-	pxor	@t[1], @x[3]
-
-	movdqa	@x[4], @t[0]
-	movdqa	@x[5], @t[1]
-	pxor	@x[6], @t[0]
-	pxor	@x[7], @t[1]
-___
-	&amp;Mul_GF4_N_GF4	(@t[0], @t[1], @y[0], @y[1], @t[3],
-			 @x[6], @x[7], @y[2], @y[3], @t[2]);
-$code.=&lt;&lt;___;
-	pxor	@y[2], @y[0]
-	pxor	@y[3], @y[1]
-___
-	&amp;Mul_GF4  	(@x[4], @x[5], @y[0], @y[1], @t[3]);
-$code.=&lt;&lt;___;
-	pxor	@t[0], @x[4]
-	pxor	@t[0], @x[6]
-	pxor	@t[1], @x[5]
-	pxor	@t[1], @x[7]
-___
-}
-sub Inv_GF256 {
-#;********************************************************************
-#;* Inv_GF256: Input x0-x7 Output x0-x7 Temp t0-t3,s0-s3 (144)       *
-#;********************************************************************
-my @x=@_[0..7];
-my @t=@_[8..11];
-my @s=@_[12..15];
-# direct optimizations from hardware
-$code.=&lt;&lt;___;
-	movdqa	@x[4], @t[3]
-	movdqa	@x[5], @t[2]
-	movdqa	@x[1], @t[1]
-	movdqa	@x[7], @s[1]
-	movdqa	@x[0], @s[0]
-
-	pxor	@x[6], @t[3]
-	pxor	@x[7], @t[2]
-	pxor	@x[3], @t[1]
-	 movdqa	@t[3], @s[2]
-	pxor	@x[6], @s[1]
-	 movdqa	@t[2], @t[0]
-	pxor	@x[2], @s[0]
-	 movdqa	@t[3], @s[3]
-
-	por	@t[1], @t[2]
-	por	@s[0], @t[3]
-	pxor	@t[0], @s[3]
-	pand	@s[0], @s[2]
-	pxor	@t[1], @s[0]
-	pand	@t[1], @t[0]
-	pand	@s[0], @s[3]
-	movdqa	@x[3], @s[0]
-	pxor	@x[2], @s[0]
-	pand	@s[0], @s[1]
-	pxor	@s[1], @t[3]
-	pxor	@s[1], @t[2]
-	movdqa	@x[4], @s[1]
-	movdqa	@x[1], @s[0]
-	pxor	@x[5], @s[1]
-	pxor	@x[0], @s[0]
-	movdqa	@s[1], @t[1]
-	pand	@s[0], @s[1]
-	por	@s[0], @t[1]
-	pxor	@s[1], @t[0]
-	pxor	@s[3], @t[3]
-	pxor	@s[2], @t[2]
-	pxor	@s[3], @t[1]
-	movdqa	@x[7], @s[0]
-	pxor	@s[2], @t[0]
-	movdqa	@x[6], @s[1]
-	pxor	@s[2], @t[1]
-	movdqa	@x[5], @s[2]
-	pand	@x[3], @s[0]
-	movdqa	@x[4], @s[3]
-	pand	@x[2], @s[1]
-	pand	@x[1], @s[2]
-	por	@x[0], @s[3]
-	pxor	@s[0], @t[3]
-	pxor	@s[1], @t[2]
-	pxor	@s[2], @t[1]
-	pxor	@s[3], @t[0]
-
-	#Inv_GF16 \t0, \t1, \t2, \t3, \s0, \s1, \s2, \s3
-
-	# new smaller inversion
-
-	movdqa	@t[3], @s[0]
-	pand	@t[1], @t[3]
-	pxor	@t[2], @s[0]
-
-	movdqa	@t[0], @s[2]
-	movdqa	@s[0], @s[3]
-	pxor	@t[3], @s[2]
-	pand	@s[2], @s[3]
-
-	movdqa	@t[1], @s[1]
-	pxor	@t[2], @s[3]
-	pxor	@t[0], @s[1]
-
-	pxor	@t[2], @t[3]
-
-	pand	@t[3], @s[1]
-
-	movdqa	@s[2], @t[2]
-	pxor	@t[0], @s[1]
-
-	pxor	@s[1], @t[2]
-	pxor	@s[1], @t[1]
-
-	pand	@t[0], @t[2]
-
-	pxor	@t[2], @s[2]
-	pxor	@t[2], @t[1]
-
-	pand	@s[3], @s[2]
-
-	pxor	@s[0], @s[2]
-___
-# output in s3, s2, s1, t1
-
-# Mul_GF16_2 \x0, \x1, \x2, \x3, \x4, \x5, \x6, \x7, \t2, \t3, \t0, \t1, \s0, \s1, \s2, \s3
-
-# Mul_GF16_2 \x0, \x1, \x2, \x3, \x4, \x5, \x6, \x7, \s3, \s2, \s1, \t1, \s0, \t0, \t2, \t3
-	&amp;Mul_GF16_2(@<A HREF="../../../mailman/listinfo/openssl-commits.html">x, at s</A>[3,2,1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at t</A>[1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at s</A>[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at t</A>[0,2,3]);
-
-### output msb &gt; [x3,x2,x1,x0,x7,x6,x5,x4] &lt; lsb
-}
-
-# AES linear components
-
-sub ShiftRows {
-my @x=@_[0..7];
-my $mask=pop;
-$code.=&lt;&lt;___;
-	pxor	0x00($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at x</A>[0]
-	pxor	0x10($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at x</A>[1]
-	pxor	0x20($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at x</A>[2]
-	pxor	0x30($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at x</A>[3]
-	pshufb	$<A HREF="../../../mailman/listinfo/openssl-commits.html">mask, at x</A>[0]
-	pshufb	$<A HREF="../../../mailman/listinfo/openssl-commits.html">mask, at x</A>[1]
-	pxor	0x40($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at x</A>[4]
-	pxor	0x50($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at x</A>[5]
-	pshufb	$<A HREF="../../../mailman/listinfo/openssl-commits.html">mask, at x</A>[2]
-	pshufb	$<A HREF="../../../mailman/listinfo/openssl-commits.html">mask, at x</A>[3]
-	pxor	0x60($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at x</A>[6]
-	pxor	0x70($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at x</A>[7]
-	pshufb	$<A HREF="../../../mailman/listinfo/openssl-commits.html">mask, at x</A>[4]
-	pshufb	$<A HREF="../../../mailman/listinfo/openssl-commits.html">mask, at x</A>[5]
-	pshufb	$<A HREF="../../../mailman/listinfo/openssl-commits.html">mask, at x</A>[6]
-	pshufb	$<A HREF="../../../mailman/listinfo/openssl-commits.html">mask, at x</A>[7]
-	lea	0x80($key),$key
-___
-}
-
-sub MixColumns {
-# modified to emit output in order suitable for feeding back to aesenc[last]
-my @x=@_[0..7];
-my @t=@_[8..15];
-my $inv=@_[16];	# optional
-$code.=&lt;&lt;___;
-	pshufd	\$0x93, @x[0], @t[0]	# x0 &lt;&lt;&lt; 32
-	pshufd	\$0x93, @x[1], @t[1]
-	 pxor	@t[0], @x[0]		# x0 ^ (x0 &lt;&lt;&lt; 32)
-	pshufd	\$0x93, @x[2], @t[2]
-	 pxor	@t[1], @x[1]
-	pshufd	\$0x93, @x[3], @t[3]
-	 pxor	@t[2], @x[2]
-	pshufd	\$0x93, @x[4], @t[4]
-	 pxor	@t[3], @x[3]
-	pshufd	\$0x93, @x[5], @t[5]
-	 pxor	@t[4], @x[4]
-	pshufd	\$0x93, @x[6], @t[6]
-	 pxor	@t[5], @x[5]
-	pshufd	\$0x93, @x[7], @t[7]
-	 pxor	@t[6], @x[6]
-	 pxor	@t[7], @x[7]
-
-	pxor	@x[0], @t[1]
-	pxor	@x[7], @t[0]
-	pxor	@x[7], @t[1]
-	 pshufd	\$0x4E, @x[0], @x[0] 	# (x0 ^ (x0 &lt;&lt;&lt; 32)) &lt;&lt;&lt; 64)
-	pxor	@x[1], @t[2]
-	 pshufd	\$0x4E, @x[1], @x[1]
-	pxor	@x[4], @t[5]
-	 pxor	@t[0], @x[0]
-	pxor	@x[5], @t[6]
-	 pxor	@t[1], @x[1]
-	pxor	@x[3], @t[4]
-	 pshufd	\$0x4E, @x[4], @t[0]
-	pxor	@x[6], @t[7]
-	 pshufd	\$0x4E, @x[5], @t[1]
-	pxor	@x[2], @t[3]
-	 pshufd	\$0x4E, @x[3], @x[4]
-	pxor	@x[7], @t[3]
-	 pshufd	\$0x4E, @x[7], @x[5]
-	pxor	@x[7], @t[4]
-	 pshufd	\$0x4E, @x[6], @x[3]
-	pxor	@t[4], @t[0]
-	 pshufd	\$0x4E, @x[2], @x[6]
-	pxor	@t[5], @t[1]
-___
-$code.=&lt;&lt;___ if (!$inv);
-	pxor	@t[3], @x[4]
-	pxor	@t[7], @x[5]
-	pxor	@t[6], @x[3]
-	 movdqa	@t[0], @x[2]
-	pxor	@t[2], @x[6]
-	 movdqa	@t[1], @x[7]
-___
-$code.=&lt;&lt;___ if ($inv);
-	pxor	@x[4], @t[3]
-	pxor	@t[7], @x[5]
-	pxor	@x[3], @t[6]
-	 movdqa	@t[0], @x[3]
-	pxor	@t[2], @x[6]
-	 movdqa	@t[6], @x[2]
-	 movdqa	@t[1], @x[7]
-	 movdqa	@x[6], @x[4]
-	 movdqa	@t[3], @x[6]
-___
-}
-
-sub InvMixColumns_orig {
-my @x=@_[0..7];
-my @t=@_[8..15];
-
-$code.=&lt;&lt;___;
-	# multiplication by 0x0e
-	pshufd	\$0x93, @x[7], @t[7]
-	movdqa	@x[2], @t[2]
-	pxor	@x[5], @x[7]		# 7 5
-	pxor	@x[5], @x[2]		# 2 5
-	pshufd	\$0x93, @x[0], @t[0]
-	movdqa	@x[5], @t[5]
-	pxor	@x[0], @x[5]		# 5 0		[1]
-	pxor	@x[1], @x[0]		# 0 1
-	pshufd	\$0x93, @x[1], @t[1]
-	pxor	@x[2], @x[1]		# 1 25
-	pxor	@x[6], @x[0]		# 01 6		[2]
-	pxor	@x[3], @x[1]		# 125 3		[4]
-	pshufd	\$0x93, @x[3], @t[3]
-	pxor	@x[0], @x[2]		# 25 016	[3]
-	pxor	@x[7], @x[3]		# 3 75
-	pxor	@x[6], @x[7]		# 75 6		[0]
-	pshufd	\$0x93, @x[6], @t[6]
-	movdqa	@x[4], @t[4]
-	pxor	@x[4], @x[6]		# 6 4
-	pxor	@x[3], @x[4]		# 4 375		[6]
-	pxor	@x[7], @x[3]		# 375 756=36
-	pxor	@t[5], @x[6]		# 64 5		[7]
-	pxor	@t[2], @x[3]		# 36 2
-	pxor	@t[4], @x[3]		# 362 4		[5]
-	pshufd	\$0x93, @t[5], @t[5]
-___
-					my @y = @x[7,5,0,2,1,3,4,6];
-$code.=&lt;&lt;___;
-	# multiplication by 0x0b
-	pxor	@y[0], @y[1]
-	pxor	@t[0], @y[0]
-	pxor	@t[1], @y[1]
-	pshufd	\$0x93, @t[2], @t[2]
-	pxor	@t[5], @y[0]
-	pxor	@t[6], @y[1]
-	pxor	@t[7], @y[0]
-	pshufd	\$0x93, @t[4], @t[4]
-	pxor	@t[6], @t[7]		# clobber t[7]
-	pxor	@y[0], @y[1]
-
-	pxor	@t[0], @y[3]
-	pshufd	\$0x93, @t[0], @t[0]
-	pxor	@t[1], @y[2]
-	pxor	@t[1], @y[4]
-	pxor	@t[2], @y[2]
-	pshufd	\$0x93, @t[1], @t[1]
-	pxor	@t[2], @y[3]
-	pxor	@t[2], @y[5]
-	pxor	@t[7], @y[2]
-	pshufd	\$0x93, @t[2], @t[2]
-	pxor	@t[3], @y[3]
-	pxor	@t[3], @y[6]
-	pxor	@t[3], @y[4]
-	pshufd	\$0x93, @t[3], @t[3]
-	pxor	@t[4], @y[7]
-	pxor	@t[4], @y[5]
-	pxor	@t[7], @y[7]
-	pxor	@t[5], @y[3]
-	pxor	@t[4], @y[4]
-	pxor	@t[5], @t[7]		# clobber t[7] even more
-
-	pxor	@t[7], @y[5]
-	pshufd	\$0x93, @t[4], @t[4]
-	pxor	@t[7], @y[6]
-	pxor	@t[7], @y[4]
-
-	pxor	@t[5], @t[7]
-	pshufd	\$0x93, @t[5], @t[5]
-	pxor	@t[6], @t[7]		# restore t[7]
-
-	# multiplication by 0x0d
-	pxor	@y[7], @y[4]
-	pxor	@t[4], @y[7]
-	pshufd	\$0x93, @t[6], @t[6]
-	pxor	@t[0], @y[2]
-	pxor	@t[5], @y[7]
-	pxor	@t[2], @y[2]
-	pshufd	\$0x93, @t[7], @t[7]
-
-	pxor	@y[1], @y[3]
-	pxor	@t[1], @y[1]
-	pxor	@t[0], @y[0]
-	pxor	@t[0], @y[3]
-	pxor	@t[5], @y[1]
-	pxor	@t[5], @y[0]
-	pxor	@t[7], @y[1]
-	pshufd	\$0x93, @t[0], @t[0]
-	pxor	@t[6], @y[0]
-	pxor	@y[1], @y[3]
-	pxor	@t[1], @y[4]
-	pshufd	\$0x93, @t[1], @t[1]
-
-	pxor	@t[7], @y[7]
-	pxor	@t[2], @y[4]
-	pxor	@t[2], @y[5]
-	pshufd	\$0x93, @t[2], @t[2]
-	pxor	@t[6], @y[2]
-	pxor	@t[3], @t[6]		# clobber t[6]
-	pxor	@y[7], @y[4]
-	pxor	@t[6], @y[3]
-
-	pxor	@t[6], @y[6]
-	pxor	@t[5], @y[5]
-	pxor	@t[4], @y[6]
-	pshufd	\$0x93, @t[4], @t[4]
-	pxor	@t[6], @y[5]
-	pxor	@t[7], @y[6]
-	pxor	@t[3], @t[6]		# restore t[6]
-
-	pshufd	\$0x93, @t[5], @t[5]
-	pshufd	\$0x93, @t[6], @t[6]
-	pshufd	\$0x93, @t[7], @t[7]
-	pshufd	\$0x93, @t[3], @t[3]
-
-	# multiplication by 0x09
-	pxor	@y[1], @y[4]
-	pxor	@y[1], @t[1]		# t[1]=y[1]
-	pxor	@t[5], @t[0]		# clobber t[0]
-	pxor	@t[5], @t[1]
-	pxor	@t[0], @y[3]
-	pxor	@y[0], @t[0]		# t[0]=y[0]
-	pxor	@t[6], @t[1]
-	pxor	@t[7], @t[6]		# clobber t[6]
-	pxor	@t[1], @y[4]
-	pxor	@t[4], @y[7]
-	pxor	@y[4], @t[4]		# t[4]=y[4]
-	pxor	@t[3], @y[6]
-	pxor	@y[3], @t[3]		# t[3]=y[3]
-	pxor	@t[2], @y[5]
-	pxor	@y[2], @t[2]		# t[2]=y[2]
-	pxor	@t[7], @t[3]
-	pxor	@y[5], @t[5]		# t[5]=y[5]
-	pxor	@t[6], @t[2]
-	pxor	@t[6], @t[5]
-	pxor	@y[6], @t[6]		# t[6]=y[6]
-	pxor	@y[7], @t[7]		# t[7]=y[7]
-
-	movdqa	@t[0]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at XMM</A>[0]
-	movdqa	@t[1]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at XMM</A>[1]
-	movdqa	@t[2]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at XMM</A>[2]
-	movdqa	@t[3]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at XMM</A>[3]
-	movdqa	@t[4]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at XMM</A>[4]
-	movdqa	@t[5]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at XMM</A>[5]
-	movdqa	@t[6]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at XMM</A>[6]
-	movdqa	@t[7]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at XMM</A>[7]
-___
-}
-
-sub InvMixColumns {
-my @x=@_[0..7];
-my @t=@_[8..15];
-
-# Thanks to Jussi Kivilinna for providing pointer to
-#
-# | 0e 0b 0d 09 |   | 02 03 01 01 |   | 05 00 04 00 |
-# | 09 0e 0b 0d | = | 01 02 03 01 | x | 00 05 00 04 |
-# | 0d 09 0e 0b |   | 01 01 02 03 |   | 04 00 05 00 |
-# | 0b 0d 09 0e |   | 03 01 01 02 |   | 00 04 00 05 |
-
-$code.=&lt;&lt;___;
-	# multiplication by 0x05-0x00-0x04-0x00
-	pshufd	\$0x4E, @x[0], @t[0]
-	pshufd	\$0x4E, @x[6], @t[6]
-	pxor	@x[0], @t[0]
-	pshufd	\$0x4E, @x[7], @t[7]
-	pxor	@x[6], @t[6]
-	pshufd	\$0x4E, @x[1], @t[1]
-	pxor	@x[7], @t[7]
-	pshufd	\$0x4E, @x[2], @t[2]
-	pxor	@x[1], @t[1]
-	pshufd	\$0x4E, @x[3], @t[3]
-	pxor	@x[2], @t[2]
-	 pxor	@t[6], @x[0]
-	 pxor	@t[6], @x[1]
-	pshufd	\$0x4E, @x[4], @t[4]
-	pxor	@x[3], @t[3]
-	 pxor	@t[0], @x[2]
-	 pxor	@t[1], @x[3]
-	pshufd	\$0x4E, @x[5], @t[5]
-	pxor	@x[4], @t[4]
-	 pxor	@t[7], @x[1]
-	 pxor	@t[2], @x[4]
-	pxor	@x[5], @t[5]
-
-	 pxor	@t[7], @x[2]
-	 pxor	@t[6], @x[3]
-	 pxor	@t[6], @x[4]
-	 pxor	@t[3], @x[5]
-	 pxor	@t[4], @x[6]
-	 pxor	@t[7], @x[4]
-	 pxor	@t[7], @x[5]
-	 pxor	@t[5], @x[7]
-___
-	&amp;MixColumns	(@<A HREF="../../../mailman/listinfo/openssl-commits.html">x, at t</A>,1);	# flipped 2&lt;-&gt;3 and 4&lt;-&gt;6
-}
-
-sub aesenc {				# not used
-my @b=@_[0..7];
-my @t=@_[8..15];
-$code.=&lt;&lt;___;
-	movdqa	0x30($const)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at t</A>[0]	# .LSR
-___
-	&amp;ShiftRows	(@<A HREF="../../../mailman/listinfo/openssl-commits.html">b, at t</A>[0]);
-	&amp;Sbox		(@<A HREF="../../../mailman/listinfo/openssl-commits.html">b, at t</A>);
-	&amp;MixColumns	(@b[0,1,4,6,3,7,2,5]<A HREF="../../../mailman/listinfo/openssl-commits.html">, at t</A>);
-}
-
-sub aesenclast {			# not used
-my @b=@_[0..7];
-my @t=@_[8..15];
-$code.=&lt;&lt;___;
-	movdqa	0x40($const)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at t</A>[0]	# .LSRM0
-___
-	&amp;ShiftRows	(@<A HREF="../../../mailman/listinfo/openssl-commits.html">b, at t</A>[0]);
-	&amp;Sbox		(@<A HREF="../../../mailman/listinfo/openssl-commits.html">b, at t</A>);
-$code.=&lt;&lt;___
-	pxor	0x00($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at b</A>[0]
-	pxor	0x10($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at b</A>[1]
-	pxor	0x20($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at b</A>[4]
-	pxor	0x30($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at b</A>[6]
-	pxor	0x40($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at b</A>[3]
-	pxor	0x50($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at b</A>[7]
-	pxor	0x60($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at b</A>[2]
-	pxor	0x70($key)<A HREF="../../../mailman/listinfo/openssl-commits.html">, at b</A>[5]
-___
-}
-
-sub swapmove {
-my ($a,$b,$n,$mask,$t)=@_;
-$code.=&lt;&lt;___;
-	movdqa	$b,$t
-	psrlq	\$$n,$b
-	pxor  	$a,$b
-	pand	$mask,$b
-	pxor	$b,$a
-	psllq	\$$n,$b
-	pxor	$t,$b
-___
-}
-sub swapmove2x {
-my ($a0,$b0,$a1,$b1,$n,$mask,$t0,$t1)=@_;
-$code.=&lt;&lt;___;
-	movdqa	$b0,$t0
-	psrlq	\$$n,$b0
-	 movdqa	$b1,$t1
-	 psrlq	\$$n,$b1
-	pxor  	$a0,$b0
-	 pxor  	$a1,$b1
-	pand	$mask,$b0
-	 pand	$mask,$b1
-	pxor	$b0,$a0
-	psllq	\$$n,$b0
-	 pxor	$b1,$a1
-	 psllq	\$$n,$b1
-	pxor	$t0,$b0
-	 pxor	$t1,$b1
-___
-}
-
-sub bitslice {
-my @x=reverse(@_[0..7]);
-my ($t0,$t1,$t2,$t3)=@_[8..11];
-$code.=&lt;&lt;___;
-	movdqa	0x00($const),$t0	# .LBS0
-	movdqa	0x10($const),$t1	# .LBS1
-___
-	&amp;swapmove2x(@x[0,1,2,3],1,$t0,$t2,$t3);
-	&amp;swapmove2x(@x[4,5,6,7],1,$t0,$t2,$t3);
-$code.=&lt;&lt;___;
-	movdqa	0x20($const),$t0	# .LBS2
-___
-	&amp;swapmove2x(@x[0,2,1,3],2,$t1,$t2,$t3);
-	&amp;swapmove2x(@x[4,6,5,7],2,$t1,$t2,$t3);
-
-	&amp;swapmove2x(@x[0,4,1,5],4,$t0,$t2,$t3);
-	&amp;swapmove2x(@x[2,6,3,7],4,$t0,$t2,$t3);
-}
-
-$code.=&lt;&lt;___;
-.text
-
-.extern	asm_AES_encrypt
-.extern	asm_AES_decrypt
-
-.type	_bsaes_encrypt8,\@abi-omnipotent
-.align	64
-_bsaes_encrypt8:
-.cfi_startproc
-	lea	.LBS0(%rip), $const	# constants table
-
-	movdqa	($key), @XMM[9]		# round 0 key
-	lea	0x10($key), $key
-	movdqa	0x50($const), @XMM[8]	# .LM0SR
-	pxor	@XMM[9], @XMM[0]	# xor with round0 key
-	pxor	@XMM[9], @XMM[1]
-	pxor	@XMM[9], @XMM[2]
-	pxor	@XMM[9], @XMM[3]
-	 pshufb	@XMM[8], @XMM[0]
-	 pshufb	@XMM[8], @XMM[1]
-	pxor	@XMM[9], @XMM[4]
-	pxor	@XMM[9], @XMM[5]
-	 pshufb	@XMM[8], @XMM[2]
-	 pshufb	@XMM[8], @XMM[3]
-	pxor	@XMM[9], @XMM[6]
-	pxor	@XMM[9], @XMM[7]
-	 pshufb	@XMM[8], @XMM[4]
-	 pshufb	@XMM[8], @XMM[5]
-	 pshufb	@XMM[8], @XMM[6]
-	 pshufb	@XMM[8], @XMM[7]
-_bsaes_encrypt8_bitslice:
-___
-	&amp;bitslice	(@XMM[0..7, 8..11]);
-$code.=&lt;&lt;___;
-	dec	$rounds
-	jmp	.Lenc_sbox
-.align	16
-.Lenc_loop:
-___
-	&amp;ShiftRows	(@XMM[0..7, 8]);
-$code.=&quot;.Lenc_sbox:\n&quot;;
-	&amp;Sbox		(@XMM[0..7, 8..15]);
-$code.=&lt;&lt;___;
-	dec	$rounds
-	jl	.Lenc_done
-___
-	&amp;MixColumns	(@XMM[0,1,4,6,3,7,2,5, 8..15]);
-$code.=&lt;&lt;___;
-	movdqa	0x30($const), @XMM[8]	# .LSR
-	jnz	.Lenc_loop
-	movdqa	0x40($const), @XMM[8]	# .LSRM0
-	jmp	.Lenc_loop
-.align	16
-.Lenc_done:
-___
-	# output in lsb &gt; [t0, t1, t4, t6, t3, t7, t2, t5] &lt; msb
-	&amp;bitslice	(@XMM[0,1,4,6,3,7,2,5, 8..11]);
-$code.=&lt;&lt;___;
-	movdqa	($key), @XMM[8]		# last round key
-	pxor	@XMM[8], @XMM[4]
-	pxor	@XMM[8], @XMM[6]
-	pxor	@XMM[8], @XMM[3]
-	pxor	@XMM[8], @XMM[7]
-	pxor	@XMM[8], @XMM[2]
-	pxor	@XMM[8], @XMM[5]
-	pxor	@XMM[8], @XMM[0]
-	pxor	@XMM[8], @XMM[1]
-	ret
-.cfi_endproc
-.size	_bsaes_encrypt8,.-_bsaes_encrypt8
-
-.type	_bsaes_decrypt8,\@abi-omnipotent
-.align	64
-_bsaes_decrypt8:
-.cfi_startproc
-	lea	.LBS0(%rip), $const	# constants table
-
-	movdqa	($key), @XMM[9]		# round 0 key
-	lea	0x10($key), $key
-	movdqa	-0x30($const), @XMM[8]	# .LM0ISR
-	pxor	@XMM[9], @XMM[0]	# xor with round0 key
-	pxor	@XMM[9], @XMM[1]
-	pxor	@XMM[9], @XMM[2]
-	pxor	@XMM[9], @XMM[3]
-	 pshufb	@XMM[8], @XMM[0]
-	 pshufb	@XMM[8], @XMM[1]
-	pxor	@XMM[9], @XMM[4]
-	pxor	@XMM[9], @XMM[5]
-	 pshufb	@XMM[8], @XMM[2]
-	 pshufb	@XMM[8], @XMM[3]
-	pxor	@XMM[9], @XMM[6]
-	pxor	@XMM[9], @XMM[7]
-	 pshufb	@XMM[8], @XMM[4]
-	 pshufb	@XMM[8], @XMM[5]
-	 pshufb	@XMM[8], @XMM[6]
-	 pshufb	@XMM[8], @XMM[7]
-___
-	&amp;bitslice	(@XMM[0..7, 8..11]);
-$code.=&lt;&lt;___;
-	dec	$rounds
-	jmp	.Ldec_sbox
-.align	16
-.Ldec_loop:
-___
-	&amp;ShiftRows	(@XMM[0..7, 8]);
-$code.=&quot;.Ldec_sbox:\n&quot;;
-	&amp;InvSbox	(@XMM[0..7, 8..15]);
-$code.=&lt;&lt;___;
-	dec	$rounds
-	jl	.Ldec_done
-___
-	&amp;InvMixColumns	(@XMM[0,1,6,4,2,7,3,5, 8..15]);
-$code.=&lt;&lt;___;
-	movdqa	-0x10($const), @XMM[8]	# .LISR
-	jnz	.Ldec_loop
-	movdqa	-0x20($const), @XMM[8]	# .LISRM0
-	jmp	.Ldec_loop
-.align	16
-.Ldec_done:
-___
-	&amp;bitslice	(@XMM[0,1,6,4,2,7,3,5, 8..11]);
-$code.=&lt;&lt;___;
-	movdqa	($key), @XMM[8]		# last round key
-	pxor	@XMM[8], @XMM[6]
-	pxor	@XMM[8], @XMM[4]
-	pxor	@XMM[8], @XMM[2]
-	pxor	@XMM[8], @XMM[7]
-	pxor	@XMM[8], @XMM[3]
-	pxor	@XMM[8], @XMM[5]
-	pxor	@XMM[8], @XMM[0]
-	pxor	@XMM[8], @XMM[1]
-	ret
-.cfi_endproc
-.size	_bsaes_decrypt8,.-_bsaes_decrypt8
-___
-}
-{
-my ($out,$inp,$rounds,$const)=(&quot;%rax&quot;,&quot;%rcx&quot;,&quot;%r10d&quot;,&quot;%r11&quot;);
-
-sub bitslice_key {
-my @x=reverse(@_[0..7]);
-my ($bs0,$bs1,$bs2,$t2,$t3)=@_[8..12];
-
-	&amp;swapmove	(@x[0,1],1,$bs0,$t2,$t3);
-$code.=&lt;&lt;___;
-	#&amp;swapmove(@x[2,3],1,$t0,$t2,$t3);
-	movdqa	@x[0], @x[2]
-	movdqa	@x[1], @x[3]
-___
-	#&amp;swapmove2x(@x[4,5,6,7],1,$t0,$t2,$t3);
-
-	&amp;swapmove2x	(@x[0,2,1,3],2,$bs1,$t2,$t3);
-$code.=&lt;&lt;___;
-	#&amp;swapmove2x(@x[4,6,5,7],2,$t1,$t2,$t3);
-	movdqa	@x[0], @x[4]
-	movdqa	@x[2], @x[6]
-	movdqa	@x[1], @x[5]
-	movdqa	@x[3], @x[7]
-___
-	&amp;swapmove2x	(@x[0,4,1,5],4,$bs2,$t2,$t3);
-	&amp;swapmove2x	(@x[2,6,3,7],4,$bs2,$t2,$t3);
-}
-
-$code.=&lt;&lt;___;
-.type	_bsaes_key_convert,\@abi-omnipotent
-.align	16
-_bsaes_key_convert:
-.cfi_startproc
-	lea	.Lmasks(%rip), $const
-	movdqu	($inp), %xmm7		# load round 0 key
-	lea	0x10($inp), $inp
-	movdqa	0x00($const), %xmm0	# 0x01...
-	movdqa	0x10($const), %xmm1	# 0x02...
-	movdqa	0x20($const), %xmm2	# 0x04...
-	movdqa	0x30($const), %xmm3	# 0x08...
-	movdqa	0x40($const), %xmm4	# .LM0
-	pcmpeqd	%xmm5, %xmm5		# .LNOT
-
-	movdqu	($inp), %xmm6		# load round 1 key
-	movdqa	%xmm7, ($out)		# save round 0 key
-	lea	0x10($out), $out
-	dec	$rounds
-	jmp	.Lkey_loop
-.align	16
-.Lkey_loop:
-	pshufb	%xmm4, %xmm6		# .LM0
-
-	movdqa	%xmm0,	%xmm8
-	movdqa	%xmm1,	%xmm9
-
-	pand	%xmm6,	%xmm8
-	pand	%xmm6,	%xmm9
-	movdqa	%xmm2,	%xmm10
-	pcmpeqb	%xmm0,	%xmm8
-	psllq	\$4,	%xmm0		# 0x10...
-	movdqa	%xmm3,	%xmm11
-	pcmpeqb	%xmm1,	%xmm9
-	psllq	\$4,	%xmm1		# 0x20...
-
-	pand	%xmm6,	%xmm10
-	pand	%xmm6,	%xmm11
-	movdqa	%xmm0,	%xmm12
-	pcmpeqb	%xmm2,	%xmm10
-	psllq	\$4,	%xmm2		# 0x40...
-	movdqa	%xmm1,	%xmm13
-	pcmpeqb	%xmm3,	%xmm11
-	psllq	\$4,	%xmm3		# 0x80...
-
-	movdqa	%xmm2,	%xmm14
-	movdqa	%xmm3,	%xmm15
-	 pxor	%xmm5,	%xmm8		# &quot;pnot&quot;
-	 pxor	%xmm5,	%xmm9
-
-	pand	%xmm6,	%xmm12
-	pand	%xmm6,	%xmm13
-	 movdqa	%xmm8, 0x00($out)	# write bit-sliced round key
-	pcmpeqb	%xmm0,	%xmm12
-	psrlq	\$4,	%xmm0		# 0x01...
-	 movdqa	%xmm9, 0x10($out)
-	pcmpeqb	%xmm1,	%xmm13
-	psrlq	\$4,	%xmm1		# 0x02...
-	 lea	0x10($inp), $inp
-
-	pand	%xmm6,	%xmm14
-	pand	%xmm6,	%xmm15
-	 movdqa	%xmm10, 0x20($out)
-	pcmpeqb	%xmm2,	%xmm14
-	psrlq	\$4,	%xmm2		# 0x04...
-	 movdqa	%xmm11, 0x30($out)
-	pcmpeqb	%xmm3,	%xmm15
-	psrlq	\$4,	%xmm3		# 0x08...
-	 movdqu	($inp), %xmm6		# load next round key
-
-	pxor	%xmm5, %xmm13		# &quot;pnot&quot;
-	pxor	%xmm5, %xmm14
-	movdqa	%xmm12, 0x40($out)
-	movdqa	%xmm13, 0x50($out)
-	movdqa	%xmm14, 0x60($out)
-	movdqa	%xmm15, 0x70($out)
-	lea	0x80($out),$out
-	dec	$rounds
-	jnz	.Lkey_loop
-
-	movdqa	0x50($const), %xmm7	# .L63
-	#movdqa	%xmm6, ($out)		# don't save last round key
-	ret
-.cfi_endproc
-.size	_bsaes_key_convert,.-_bsaes_key_convert
-___
-}
-
-if (0 &amp;&amp; !$win64) {	# following four functions are unsupported interface
-			# used for benchmarking...
-$code.=&lt;&lt;___;
-.globl	bsaes_enc_key_convert
-.type	bsaes_enc_key_convert,\@function,2
-.align	16
-bsaes_enc_key_convert:
-	mov	240($inp),%r10d		# pass rounds
-	mov	$inp,%rcx		# pass key
-	mov	$out,%rax		# pass key schedule
-	call	_bsaes_key_convert
-	pxor	%xmm6,%xmm7		# fix up last round key
-	movdqa	%xmm7,(%rax)		# save last round key
-	ret
-.size	bsaes_enc_key_convert,.-bsaes_enc_key_convert
-
-.globl	bsaes_encrypt_128
-.type	bsaes_encrypt_128,\@function,4
-.align	16
-bsaes_encrypt_128:
-.Lenc128_loop:
-	movdqu	0x00($inp), @XMM[0]	# load input
-	movdqu	0x10($inp), @XMM[1]
-	movdqu	0x20($inp), @XMM[2]
-	movdqu	0x30($inp), @XMM[3]
-	movdqu	0x40($inp), @XMM[4]
-	movdqu	0x50($inp), @XMM[5]
-	movdqu	0x60($inp), @XMM[6]
-	movdqu	0x70($inp), @XMM[7]
-	mov	$key, %rax		# pass the $key
-	lea	0x80($inp), $inp
-	mov	\$10,%r10d
-
-	call	_bsaes_encrypt8
-
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[4], 0x20($out)
-	movdqu	@XMM[6], 0x30($out)
-	movdqu	@XMM[3], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	movdqu	@XMM[2], 0x60($out)
-	movdqu	@XMM[5], 0x70($out)
-	lea	0x80($out), $out
-	sub	\$0x80,$len
-	ja	.Lenc128_loop
-	ret
-.size	bsaes_encrypt_128,.-bsaes_encrypt_128
-
-.globl	bsaes_dec_key_convert
-.type	bsaes_dec_key_convert,\@function,2
-.align	16
-bsaes_dec_key_convert:
-	mov	240($inp),%r10d		# pass rounds
-	mov	$inp,%rcx		# pass key
-	mov	$out,%rax		# pass key schedule
-	call	_bsaes_key_convert
-	pxor	($out),%xmm7		# fix up round 0 key
-	movdqa	%xmm6,(%rax)		# save last round key
-	movdqa	%xmm7,($out)
-	ret
-.size	bsaes_dec_key_convert,.-bsaes_dec_key_convert
-
-.globl	bsaes_decrypt_128
-.type	bsaes_decrypt_128,\@function,4
-.align	16
-bsaes_decrypt_128:
-.Ldec128_loop:
-	movdqu	0x00($inp), @XMM[0]	# load input
-	movdqu	0x10($inp), @XMM[1]
-	movdqu	0x20($inp), @XMM[2]
-	movdqu	0x30($inp), @XMM[3]
-	movdqu	0x40($inp), @XMM[4]
-	movdqu	0x50($inp), @XMM[5]
-	movdqu	0x60($inp), @XMM[6]
-	movdqu	0x70($inp), @XMM[7]
-	mov	$key, %rax		# pass the $key
-	lea	0x80($inp), $inp
-	mov	\$10,%r10d
-
-	call	_bsaes_decrypt8
-
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	movdqu	@XMM[2], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	movdqu	@XMM[3], 0x60($out)
-	movdqu	@XMM[5], 0x70($out)
-	lea	0x80($out), $out
-	sub	\$0x80,$len
-	ja	.Ldec128_loop
-	ret
-.size	bsaes_decrypt_128,.-bsaes_decrypt_128
-___
-}
-{
-######################################################################
-#
-# OpenSSL interface
-#
-my ($arg1,$arg2,$arg3,$arg4,$arg5,$arg6)=$win64	? (&quot;%rcx&quot;,&quot;%rdx&quot;,&quot;%r8&quot;,&quot;%r9&quot;,&quot;%r10&quot;,&quot;%r11d&quot;)
-						: (&quot;%rdi&quot;,&quot;%rsi&quot;,&quot;%rdx&quot;,&quot;%rcx&quot;,&quot;%r8&quot;,&quot;%r9d&quot;);
-my ($inp,$out,$len,$key)=(&quot;%r12&quot;,&quot;%r13&quot;,&quot;%r14&quot;,&quot;%r15&quot;);
-
-if ($ecb) {
-$code.=&lt;&lt;___;
-.globl	bsaes_ecb_encrypt_blocks
-.type	bsaes_ecb_encrypt_blocks,\@abi-omnipotent
-.align	16
-bsaes_ecb_encrypt_blocks:
-.cfi_startproc
-	mov	%rsp, %rax
-.Lecb_enc_prologue:
-	push	%rbp
-.cfi_push	%rbp
-	push	%rbx
-.cfi_push	%rbx
-	push	%r12
-.cfi_push	%r12
-	push	%r13
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-	lea	-0x48(%rsp),%rsp
-.cfi_adjust_cfa_offset	0x48
-___
-$code.=&lt;&lt;___ if ($win64);
-	lea	-0xa0(%rsp), %rsp
-	movaps	%xmm6, 0x40(%rsp)
-	movaps	%xmm7, 0x50(%rsp)
-	movaps	%xmm8, 0x60(%rsp)
-	movaps	%xmm9, 0x70(%rsp)
-	movaps	%xmm10, 0x80(%rsp)
-	movaps	%xmm11, 0x90(%rsp)
-	movaps	%xmm12, 0xa0(%rsp)
-	movaps	%xmm13, 0xb0(%rsp)
-	movaps	%xmm14, 0xc0(%rsp)
-	movaps	%xmm15, 0xd0(%rsp)
-.Lecb_enc_body:
-___
-$code.=&lt;&lt;___;
-	mov	%rsp,%rbp		# backup %rsp
-.cfi_def_cfa_register	%rbp
-	mov	240($arg4),%eax		# rounds
-	mov	$arg1,$inp		# backup arguments
-	mov	$arg2,$out
-	mov	$arg3,$len
-	mov	$arg4,$key
-	cmp	\$8,$arg3
-	jb	.Lecb_enc_short
-
-	mov	%eax,%ebx		# backup rounds
-	shl	\$7,%rax		# 128 bytes per inner round key
-	sub	\$`128-32`,%rax		# size of bit-sliced key schedule
-	sub	%rax,%rsp
-	mov	%rsp,%rax		# pass key schedule
-	mov	$key,%rcx		# pass key
-	mov	%ebx,%r10d		# pass rounds
-	call	_bsaes_key_convert
-	pxor	%xmm6,%xmm7		# fix up last round key
-	movdqa	%xmm7,(%rax)		# save last round key
-
-	sub	\$8,$len
-.Lecb_enc_loop:
-	movdqu	0x00($inp), @XMM[0]	# load input
-	movdqu	0x10($inp), @XMM[1]
-	movdqu	0x20($inp), @XMM[2]
-	movdqu	0x30($inp), @XMM[3]
-	movdqu	0x40($inp), @XMM[4]
-	movdqu	0x50($inp), @XMM[5]
-	mov	%rsp, %rax		# pass key schedule
-	movdqu	0x60($inp), @XMM[6]
-	mov	%ebx,%r10d		# pass rounds
-	movdqu	0x70($inp), @XMM[7]
-	lea	0x80($inp), $inp
-
-	call	_bsaes_encrypt8
-
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[4], 0x20($out)
-	movdqu	@XMM[6], 0x30($out)
-	movdqu	@XMM[3], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	movdqu	@XMM[2], 0x60($out)
-	movdqu	@XMM[5], 0x70($out)
-	lea	0x80($out), $out
-	sub	\$8,$len
-	jnc	.Lecb_enc_loop
-
-	add	\$8,$len
-	jz	.Lecb_enc_done
-
-	movdqu	0x00($inp), @XMM[0]	# load input
-	mov	%rsp, %rax		# pass key schedule
-	mov	%ebx,%r10d		# pass rounds
-	cmp	\$2,$len
-	jb	.Lecb_enc_one
-	movdqu	0x10($inp), @XMM[1]
-	je	.Lecb_enc_two
-	movdqu	0x20($inp), @XMM[2]
-	cmp	\$4,$len
-	jb	.Lecb_enc_three
-	movdqu	0x30($inp), @XMM[3]
-	je	.Lecb_enc_four
-	movdqu	0x40($inp), @XMM[4]
-	cmp	\$6,$len
-	jb	.Lecb_enc_five
-	movdqu	0x50($inp), @XMM[5]
-	je	.Lecb_enc_six
-	movdqu	0x60($inp), @XMM[6]
-	call	_bsaes_encrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[4], 0x20($out)
-	movdqu	@XMM[6], 0x30($out)
-	movdqu	@XMM[3], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	movdqu	@XMM[2], 0x60($out)
-	jmp	.Lecb_enc_done
-.align	16
-.Lecb_enc_six:
-	call	_bsaes_encrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[4], 0x20($out)
-	movdqu	@XMM[6], 0x30($out)
-	movdqu	@XMM[3], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	jmp	.Lecb_enc_done
-.align	16
-.Lecb_enc_five:
-	call	_bsaes_encrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[4], 0x20($out)
-	movdqu	@XMM[6], 0x30($out)
-	movdqu	@XMM[3], 0x40($out)
-	jmp	.Lecb_enc_done
-.align	16
-.Lecb_enc_four:
-	call	_bsaes_encrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[4], 0x20($out)
-	movdqu	@XMM[6], 0x30($out)
-	jmp	.Lecb_enc_done
-.align	16
-.Lecb_enc_three:
-	call	_bsaes_encrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[4], 0x20($out)
-	jmp	.Lecb_enc_done
-.align	16
-.Lecb_enc_two:
-	call	_bsaes_encrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	jmp	.Lecb_enc_done
-.align	16
-.Lecb_enc_one:
-	call	_bsaes_encrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	jmp	.Lecb_enc_done
-.align	16
-.Lecb_enc_short:
-	lea	($inp), $arg1
-	lea	($out), $arg2
-	lea	($key), $arg3
-	call	asm_AES_encrypt
-	lea	16($inp), $inp
-	lea	16($out), $out
-	dec	$len
-	jnz	.Lecb_enc_short
-
-.Lecb_enc_done:
-	lea	(%rsp),%rax
-	pxor	%xmm0, %xmm0
-.Lecb_enc_bzero:			# wipe key schedule [if any]
-	movdqa	%xmm0, 0x00(%rax)
-	movdqa	%xmm0, 0x10(%rax)
-	lea	0x20(%rax), %rax
-	cmp	%rax, %rbp
-	jb	.Lecb_enc_bzero
-
-	lea	0x78(%rbp),%rax
-.cfi_def_cfa	%rax,8
-___
-$code.=&lt;&lt;___ if ($win64);
-	movaps	0x40(%rbp), %xmm6
-	movaps	0x50(%rbp), %xmm7
-	movaps	0x60(%rbp), %xmm8
-	movaps	0x70(%rbp), %xmm9
-	movaps	0x80(%rbp), %xmm10
-	movaps	0x90(%rbp), %xmm11
-	movaps	0xa0(%rbp), %xmm12
-	movaps	0xb0(%rbp), %xmm13
-	movaps	0xc0(%rbp), %xmm14
-	movaps	0xd0(%rbp), %xmm15
-	lea	0xa0(%rax), %rax
-.Lecb_enc_tail:
-___
-$code.=&lt;&lt;___;
-	mov	-48(%rax), %r15
-.cfi_restore	%r15
-	mov	-40(%rax), %r14
-.cfi_restore	%r14
-	mov	-32(%rax), %r13
-.cfi_restore	%r13
-	mov	-24(%rax), %r12
-.cfi_restore	%r12
-	mov	-16(%rax), %rbx
-.cfi_restore	%rbx
-	mov	-8(%rax), %rbp
-.cfi_restore	%rbp
-	lea	(%rax), %rsp		# restore %rsp
-.cfi_def_cfa_register	%rsp
-.Lecb_enc_epilogue:
-	ret
-.cfi_endproc
-.size	bsaes_ecb_encrypt_blocks,.-bsaes_ecb_encrypt_blocks
-
-.globl	bsaes_ecb_decrypt_blocks
-.type	bsaes_ecb_decrypt_blocks,\@abi-omnipotent
-.align	16
-bsaes_ecb_decrypt_blocks:
-.cfi_startproc
-	mov	%rsp, %rax
-.Lecb_dec_prologue:
-	push	%rbp
-.cfi_push	%rbp
-	push	%rbx
-.cfi_push	%rbx
-	push	%r12
-.cfi_push	%r12
-	push	%r13
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-	lea	-0x48(%rsp),%rsp
-.cfi_adjust_cfa_offset	0x48
-___
-$code.=&lt;&lt;___ if ($win64);
-	lea	-0xa0(%rsp), %rsp
-	movaps	%xmm6, 0x40(%rsp)
-	movaps	%xmm7, 0x50(%rsp)
-	movaps	%xmm8, 0x60(%rsp)
-	movaps	%xmm9, 0x70(%rsp)
-	movaps	%xmm10, 0x80(%rsp)
-	movaps	%xmm11, 0x90(%rsp)
-	movaps	%xmm12, 0xa0(%rsp)
-	movaps	%xmm13, 0xb0(%rsp)
-	movaps	%xmm14, 0xc0(%rsp)
-	movaps	%xmm15, 0xd0(%rsp)
-.Lecb_dec_body:
-___
-$code.=&lt;&lt;___;
-	mov	%rsp,%rbp		# backup %rsp
-.cfi_def_cfa_register	%rbp
-	mov	240($arg4),%eax		# rounds
-	mov	$arg1,$inp		# backup arguments
-	mov	$arg2,$out
-	mov	$arg3,$len
-	mov	$arg4,$key
-	cmp	\$8,$arg3
-	jb	.Lecb_dec_short
-
-	mov	%eax,%ebx		# backup rounds
-	shl	\$7,%rax		# 128 bytes per inner round key
-	sub	\$`128-32`,%rax		# size of bit-sliced key schedule
-	sub	%rax,%rsp
-	mov	%rsp,%rax		# pass key schedule
-	mov	$key,%rcx		# pass key
-	mov	%ebx,%r10d		# pass rounds
-	call	_bsaes_key_convert
-	pxor	(%rsp),%xmm7		# fix up 0 round key
-	movdqa	%xmm6,(%rax)		# save last round key
-	movdqa	%xmm7,(%rsp)
-
-	sub	\$8,$len
-.Lecb_dec_loop:
-	movdqu	0x00($inp), @XMM[0]	# load input
-	movdqu	0x10($inp), @XMM[1]
-	movdqu	0x20($inp), @XMM[2]
-	movdqu	0x30($inp), @XMM[3]
-	movdqu	0x40($inp), @XMM[4]
-	movdqu	0x50($inp), @XMM[5]
-	mov	%rsp, %rax		# pass key schedule
-	movdqu	0x60($inp), @XMM[6]
-	mov	%ebx,%r10d		# pass rounds
-	movdqu	0x70($inp), @XMM[7]
-	lea	0x80($inp), $inp
-
-	call	_bsaes_decrypt8
-
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	movdqu	@XMM[2], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	movdqu	@XMM[3], 0x60($out)
-	movdqu	@XMM[5], 0x70($out)
-	lea	0x80($out), $out
-	sub	\$8,$len
-	jnc	.Lecb_dec_loop
-
-	add	\$8,$len
-	jz	.Lecb_dec_done
-
-	movdqu	0x00($inp), @XMM[0]	# load input
-	mov	%rsp, %rax		# pass key schedule
-	mov	%ebx,%r10d		# pass rounds
-	cmp	\$2,$len
-	jb	.Lecb_dec_one
-	movdqu	0x10($inp), @XMM[1]
-	je	.Lecb_dec_two
-	movdqu	0x20($inp), @XMM[2]
-	cmp	\$4,$len
-	jb	.Lecb_dec_three
-	movdqu	0x30($inp), @XMM[3]
-	je	.Lecb_dec_four
-	movdqu	0x40($inp), @XMM[4]
-	cmp	\$6,$len
-	jb	.Lecb_dec_five
-	movdqu	0x50($inp), @XMM[5]
-	je	.Lecb_dec_six
-	movdqu	0x60($inp), @XMM[6]
-	call	_bsaes_decrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	movdqu	@XMM[2], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	movdqu	@XMM[3], 0x60($out)
-	jmp	.Lecb_dec_done
-.align	16
-.Lecb_dec_six:
-	call	_bsaes_decrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	movdqu	@XMM[2], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	jmp	.Lecb_dec_done
-.align	16
-.Lecb_dec_five:
-	call	_bsaes_decrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	movdqu	@XMM[2], 0x40($out)
-	jmp	.Lecb_dec_done
-.align	16
-.Lecb_dec_four:
-	call	_bsaes_decrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	jmp	.Lecb_dec_done
-.align	16
-.Lecb_dec_three:
-	call	_bsaes_decrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	jmp	.Lecb_dec_done
-.align	16
-.Lecb_dec_two:
-	call	_bsaes_decrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	jmp	.Lecb_dec_done
-.align	16
-.Lecb_dec_one:
-	call	_bsaes_decrypt8
-	movdqu	@XMM[0], 0x00($out)	# write output
-	jmp	.Lecb_dec_done
-.align	16
-.Lecb_dec_short:
-	lea	($inp), $arg1
-	lea	($out), $arg2
-	lea	($key), $arg3
-	call	asm_AES_decrypt
-	lea	16($inp), $inp
-	lea	16($out), $out
-	dec	$len
-	jnz	.Lecb_dec_short
-
-.Lecb_dec_done:
-	lea	(%rsp),%rax
-	pxor	%xmm0, %xmm0
-.Lecb_dec_bzero:			# wipe key schedule [if any]
-	movdqa	%xmm0, 0x00(%rax)
-	movdqa	%xmm0, 0x10(%rax)
-	lea	0x20(%rax), %rax
-	cmp	%rax, %rbp
-	jb	.Lecb_dec_bzero
-
-	lea	0x78(%rbp),%rax
-.cfi_def_cfa	%rax,8
-___
-$code.=&lt;&lt;___ if ($win64);
-	movaps	0x40(%rbp), %xmm6
-	movaps	0x50(%rbp), %xmm7
-	movaps	0x60(%rbp), %xmm8
-	movaps	0x70(%rbp), %xmm9
-	movaps	0x80(%rbp), %xmm10
-	movaps	0x90(%rbp), %xmm11
-	movaps	0xa0(%rbp), %xmm12
-	movaps	0xb0(%rbp), %xmm13
-	movaps	0xc0(%rbp), %xmm14
-	movaps	0xd0(%rbp), %xmm15
-	lea	0xa0(%rax), %rax
-.Lecb_dec_tail:
-___
-$code.=&lt;&lt;___;
-	mov	-48(%rax), %r15
-.cfi_restore	%r15
-	mov	-40(%rax), %r14
-.cfi_restore	%r14
-	mov	-32(%rax), %r13
-.cfi_restore	%r13
-	mov	-24(%rax), %r12
-.cfi_restore	%r12
-	mov	-16(%rax), %rbx
-.cfi_restore	%rbx
-	mov	-8(%rax), %rbp
-.cfi_restore	%rbp
-	lea	(%rax), %rsp		# restore %rsp
-.cfi_def_cfa_register	%rsp
-.Lecb_dec_epilogue:
-	ret
-.cfi_endproc
-.size	bsaes_ecb_decrypt_blocks,.-bsaes_ecb_decrypt_blocks
-___
-}
-$code.=&lt;&lt;___;
-.extern	asm_AES_cbc_encrypt
-.globl	bsaes_cbc_encrypt
-.type	bsaes_cbc_encrypt,\@abi-omnipotent
-.align	16
-bsaes_cbc_encrypt:
-.cfi_startproc
-___
-$code.=&lt;&lt;___ if ($win64);
-	mov	48(%rsp),$arg6		# pull direction flag
-___
-$code.=&lt;&lt;___;
-	cmp	\$0,$arg6
-	jne	asm_AES_cbc_encrypt
-	cmp	\$128,$arg3
-	jb	asm_AES_cbc_encrypt
-
-	mov	%rsp, %rax
-.Lcbc_dec_prologue:
-	push	%rbp
-.cfi_push	%rbp
-	push	%rbx
-.cfi_push	%rbx
-	push	%r12
-.cfi_push	%r12
-	push	%r13
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-	lea	-0x48(%rsp), %rsp
-.cfi_adjust_cfa_offset	0x48
-___
-$code.=&lt;&lt;___ if ($win64);
-	mov	0xa0(%rsp),$arg5	# pull ivp
-	lea	-0xa0(%rsp), %rsp
-	movaps	%xmm6, 0x40(%rsp)
-	movaps	%xmm7, 0x50(%rsp)
-	movaps	%xmm8, 0x60(%rsp)
-	movaps	%xmm9, 0x70(%rsp)
-	movaps	%xmm10, 0x80(%rsp)
-	movaps	%xmm11, 0x90(%rsp)
-	movaps	%xmm12, 0xa0(%rsp)
-	movaps	%xmm13, 0xb0(%rsp)
-	movaps	%xmm14, 0xc0(%rsp)
-	movaps	%xmm15, 0xd0(%rsp)
-.Lcbc_dec_body:
-___
-$code.=&lt;&lt;___;
-	mov	%rsp, %rbp		# backup %rsp
-.cfi_def_cfa_register	%rbp
-	mov	240($arg4), %eax	# rounds
-	mov	$arg1, $inp		# backup arguments
-	mov	$arg2, $out
-	mov	$arg3, $len
-	mov	$arg4, $key
-	mov	$arg5, %rbx
-	shr	\$4, $len		# bytes to blocks
-
-	mov	%eax, %edx		# rounds
-	shl	\$7, %rax		# 128 bytes per inner round key
-	sub	\$`128-32`, %rax	# size of bit-sliced key schedule
-	sub	%rax, %rsp
-
-	mov	%rsp, %rax		# pass key schedule
-	mov	$key, %rcx		# pass key
-	mov	%edx, %r10d		# pass rounds
-	call	_bsaes_key_convert
-	pxor	(%rsp),%xmm7		# fix up 0 round key
-	movdqa	%xmm6,(%rax)		# save last round key
-	movdqa	%xmm7,(%rsp)
-
-	movdqu	(%rbx), @XMM[15]	# load IV
-	sub	\$8,$len
-.Lcbc_dec_loop:
-	movdqu	0x00($inp), @XMM[0]	# load input
-	movdqu	0x10($inp), @XMM[1]
-	movdqu	0x20($inp), @XMM[2]
-	movdqu	0x30($inp), @XMM[3]
-	movdqu	0x40($inp), @XMM[4]
-	movdqu	0x50($inp), @XMM[5]
-	mov	%rsp, %rax		# pass key schedule
-	movdqu	0x60($inp), @XMM[6]
-	mov	%edx,%r10d		# pass rounds
-	movdqu	0x70($inp), @XMM[7]
-	movdqa	@XMM[15], 0x20(%rbp)	# put aside IV
-
-	call	_bsaes_decrypt8
-
-	pxor	0x20(%rbp), @XMM[0]	# ^= IV
-	movdqu	0x00($inp), @XMM[8]	# re-load input
-	movdqu	0x10($inp), @XMM[9]
-	pxor	@XMM[8], @XMM[1]
-	movdqu	0x20($inp), @XMM[10]
-	pxor	@XMM[9], @XMM[6]
-	movdqu	0x30($inp), @XMM[11]
-	pxor	@XMM[10], @XMM[4]
-	movdqu	0x40($inp), @XMM[12]
-	pxor	@XMM[11], @XMM[2]
-	movdqu	0x50($inp), @XMM[13]
-	pxor	@XMM[12], @XMM[7]
-	movdqu	0x60($inp), @XMM[14]
-	pxor	@XMM[13], @XMM[3]
-	movdqu	0x70($inp), @XMM[15]	# IV
-	pxor	@XMM[14], @XMM[5]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	lea	0x80($inp), $inp
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	movdqu	@XMM[2], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	movdqu	@XMM[3], 0x60($out)
-	movdqu	@XMM[5], 0x70($out)
-	lea	0x80($out), $out
-	sub	\$8,$len
-	jnc	.Lcbc_dec_loop
-
-	add	\$8,$len
-	jz	.Lcbc_dec_done
-
-	movdqu	0x00($inp), @XMM[0]	# load input
-	mov	%rsp, %rax		# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-	cmp	\$2,$len
-	jb	.Lcbc_dec_one
-	movdqu	0x10($inp), @XMM[1]
-	je	.Lcbc_dec_two
-	movdqu	0x20($inp), @XMM[2]
-	cmp	\$4,$len
-	jb	.Lcbc_dec_three
-	movdqu	0x30($inp), @XMM[3]
-	je	.Lcbc_dec_four
-	movdqu	0x40($inp), @XMM[4]
-	cmp	\$6,$len
-	jb	.Lcbc_dec_five
-	movdqu	0x50($inp), @XMM[5]
-	je	.Lcbc_dec_six
-	movdqu	0x60($inp), @XMM[6]
-	movdqa	@XMM[15], 0x20(%rbp)	# put aside IV
-	call	_bsaes_decrypt8
-	pxor	0x20(%rbp), @XMM[0]	# ^= IV
-	movdqu	0x00($inp), @XMM[8]	# re-load input
-	movdqu	0x10($inp), @XMM[9]
-	pxor	@XMM[8], @XMM[1]
-	movdqu	0x20($inp), @XMM[10]
-	pxor	@XMM[9], @XMM[6]
-	movdqu	0x30($inp), @XMM[11]
-	pxor	@XMM[10], @XMM[4]
-	movdqu	0x40($inp), @XMM[12]
-	pxor	@XMM[11], @XMM[2]
-	movdqu	0x50($inp), @XMM[13]
-	pxor	@XMM[12], @XMM[7]
-	movdqu	0x60($inp), @XMM[15]	# IV
-	pxor	@XMM[13], @XMM[3]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	movdqu	@XMM[2], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	movdqu	@XMM[3], 0x60($out)
-	jmp	.Lcbc_dec_done
-.align	16
-.Lcbc_dec_six:
-	movdqa	@XMM[15], 0x20(%rbp)	# put aside IV
-	call	_bsaes_decrypt8
-	pxor	0x20(%rbp), @XMM[0]	# ^= IV
-	movdqu	0x00($inp), @XMM[8]	# re-load input
-	movdqu	0x10($inp), @XMM[9]
-	pxor	@XMM[8], @XMM[1]
-	movdqu	0x20($inp), @XMM[10]
-	pxor	@XMM[9], @XMM[6]
-	movdqu	0x30($inp), @XMM[11]
-	pxor	@XMM[10], @XMM[4]
-	movdqu	0x40($inp), @XMM[12]
-	pxor	@XMM[11], @XMM[2]
-	movdqu	0x50($inp), @XMM[15]	# IV
-	pxor	@XMM[12], @XMM[7]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	movdqu	@XMM[2], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	jmp	.Lcbc_dec_done
-.align	16
-.Lcbc_dec_five:
-	movdqa	@XMM[15], 0x20(%rbp)	# put aside IV
-	call	_bsaes_decrypt8
-	pxor	0x20(%rbp), @XMM[0]	# ^= IV
-	movdqu	0x00($inp), @XMM[8]	# re-load input
-	movdqu	0x10($inp), @XMM[9]
-	pxor	@XMM[8], @XMM[1]
-	movdqu	0x20($inp), @XMM[10]
-	pxor	@XMM[9], @XMM[6]
-	movdqu	0x30($inp), @XMM[11]
-	pxor	@XMM[10], @XMM[4]
-	movdqu	0x40($inp), @XMM[15]	# IV
-	pxor	@XMM[11], @XMM[2]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	movdqu	@XMM[2], 0x40($out)
-	jmp	.Lcbc_dec_done
-.align	16
-.Lcbc_dec_four:
-	movdqa	@XMM[15], 0x20(%rbp)	# put aside IV
-	call	_bsaes_decrypt8
-	pxor	0x20(%rbp), @XMM[0]	# ^= IV
-	movdqu	0x00($inp), @XMM[8]	# re-load input
-	movdqu	0x10($inp), @XMM[9]
-	pxor	@XMM[8], @XMM[1]
-	movdqu	0x20($inp), @XMM[10]
-	pxor	@XMM[9], @XMM[6]
-	movdqu	0x30($inp), @XMM[15]	# IV
-	pxor	@XMM[10], @XMM[4]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	jmp	.Lcbc_dec_done
-.align	16
-.Lcbc_dec_three:
-	movdqa	@XMM[15], 0x20(%rbp)	# put aside IV
-	call	_bsaes_decrypt8
-	pxor	0x20(%rbp), @XMM[0]	# ^= IV
-	movdqu	0x00($inp), @XMM[8]	# re-load input
-	movdqu	0x10($inp), @XMM[9]
-	pxor	@XMM[8], @XMM[1]
-	movdqu	0x20($inp), @XMM[15]	# IV
-	pxor	@XMM[9], @XMM[6]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	jmp	.Lcbc_dec_done
-.align	16
-.Lcbc_dec_two:
-	movdqa	@XMM[15], 0x20(%rbp)	# put aside IV
-	call	_bsaes_decrypt8
-	pxor	0x20(%rbp), @XMM[0]	# ^= IV
-	movdqu	0x00($inp), @XMM[8]	# re-load input
-	movdqu	0x10($inp), @XMM[15]	# IV
-	pxor	@XMM[8], @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	jmp	.Lcbc_dec_done
-.align	16
-.Lcbc_dec_one:
-	lea	($inp), $arg1
-	lea	0x20(%rbp), $arg2	# buffer output
-	lea	($key), $arg3
-	call	asm_AES_decrypt		# doesn't touch %xmm
-	pxor	0x20(%rbp), @XMM[15]	# ^= IV
-	movdqu	@XMM[15], ($out)	# write output
-	movdqa	@XMM[0], @XMM[15]	# IV
-
-.Lcbc_dec_done:
-	movdqu	@XMM[15], (%rbx)	# return IV
-	lea	(%rsp), %rax
-	pxor	%xmm0, %xmm0
-.Lcbc_dec_bzero:			# wipe key schedule [if any]
-	movdqa	%xmm0, 0x00(%rax)
-	movdqa	%xmm0, 0x10(%rax)
-	lea	0x20(%rax), %rax
-	cmp	%rax, %rbp
-	ja	.Lcbc_dec_bzero
-
-	lea	0x78(%rbp),%rax
-.cfi_def_cfa	%rax,8
-___
-$code.=&lt;&lt;___ if ($win64);
-	movaps	0x40(%rbp), %xmm6
-	movaps	0x50(%rbp), %xmm7
-	movaps	0x60(%rbp), %xmm8
-	movaps	0x70(%rbp), %xmm9
-	movaps	0x80(%rbp), %xmm10
-	movaps	0x90(%rbp), %xmm11
-	movaps	0xa0(%rbp), %xmm12
-	movaps	0xb0(%rbp), %xmm13
-	movaps	0xc0(%rbp), %xmm14
-	movaps	0xd0(%rbp), %xmm15
-	lea	0xa0(%rax), %rax
-.Lcbc_dec_tail:
-___
-$code.=&lt;&lt;___;
-	mov	-48(%rax), %r15
-.cfi_restore	%r15
-	mov	-40(%rax), %r14
-.cfi_restore	%r14
-	mov	-32(%rax), %r13
-.cfi_restore	%r13
-	mov	-24(%rax), %r12
-.cfi_restore	%r12
-	mov	-16(%rax), %rbx
-.cfi_restore	%rbx
-	mov	-8(%rax), %rbp
-.cfi_restore	%rbp
-	lea	(%rax), %rsp		# restore %rsp
-.cfi_def_cfa_register	%rsp
-.Lcbc_dec_epilogue:
-	ret
-.cfi_endproc
-.size	bsaes_cbc_encrypt,.-bsaes_cbc_encrypt
-
-.globl	bsaes_ctr32_encrypt_blocks
-.type	bsaes_ctr32_encrypt_blocks,\@abi-omnipotent
-.align	16
-bsaes_ctr32_encrypt_blocks:
-.cfi_startproc
-	mov	%rsp, %rax
-.Lctr_enc_prologue:
-	push	%rbp
-.cfi_push	%rbp
-	push	%rbx
-.cfi_push	%rbx
-	push	%r12
-.cfi_push	%r12
-	push	%r13
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-	lea	-0x48(%rsp), %rsp
-.cfi_adjust_cfa_offset	0x48
-___
-$code.=&lt;&lt;___ if ($win64);
-	mov	0xa0(%rsp),$arg5	# pull ivp
-	lea	-0xa0(%rsp), %rsp
-	movaps	%xmm6, 0x40(%rsp)
-	movaps	%xmm7, 0x50(%rsp)
-	movaps	%xmm8, 0x60(%rsp)
-	movaps	%xmm9, 0x70(%rsp)
-	movaps	%xmm10, 0x80(%rsp)
-	movaps	%xmm11, 0x90(%rsp)
-	movaps	%xmm12, 0xa0(%rsp)
-	movaps	%xmm13, 0xb0(%rsp)
-	movaps	%xmm14, 0xc0(%rsp)
-	movaps	%xmm15, 0xd0(%rsp)
-.Lctr_enc_body:
-___
-$code.=&lt;&lt;___;
-	mov	%rsp, %rbp		# backup %rsp
-.cfi_def_cfa_register	%rbp
-	movdqu	($arg5), %xmm0		# load counter
-	mov	240($arg4), %eax	# rounds
-	mov	$arg1, $inp		# backup arguments
-	mov	$arg2, $out
-	mov	$arg3, $len
-	mov	$arg4, $key
-	movdqa	%xmm0, 0x20(%rbp)	# copy counter
-	cmp	\$8, $arg3
-	jb	.Lctr_enc_short
-
-	mov	%eax, %ebx		# rounds
-	shl	\$7, %rax		# 128 bytes per inner round key
-	sub	\$`128-32`, %rax	# size of bit-sliced key schedule
-	sub	%rax, %rsp
-
-	mov	%rsp, %rax		# pass key schedule
-	mov	$key, %rcx		# pass key
-	mov	%ebx, %r10d		# pass rounds
-	call	_bsaes_key_convert
-	pxor	%xmm6,%xmm7		# fix up last round key
-	movdqa	%xmm7,(%rax)		# save last round key
-
-	movdqa	(%rsp), @XMM[9]		# load round0 key
-	lea	.LADD1(%rip), %r11
-	movdqa	0x20(%rbp), @XMM[0]	# counter copy
-	movdqa	-0x20(%r11), @XMM[8]	# .LSWPUP
-	pshufb	@XMM[8], @XMM[9]	# byte swap upper part
-	pshufb	@XMM[8], @XMM[0]
-	movdqa	@XMM[9], (%rsp)		# save adjusted round0 key
-	jmp	.Lctr_enc_loop
-.align	16
-.Lctr_enc_loop:
-	movdqa	@XMM[0], 0x20(%rbp)	# save counter
-	movdqa	@XMM[0], @XMM[1]	# prepare 8 counter values
-	movdqa	@XMM[0], @XMM[2]
-	paddd	0x00(%r11), @XMM[1]	# .LADD1
-	movdqa	@XMM[0], @XMM[3]
-	paddd	0x10(%r11), @XMM[2]	# .LADD2
-	movdqa	@XMM[0], @XMM[4]
-	paddd	0x20(%r11), @XMM[3]	# .LADD3
-	movdqa	@XMM[0], @XMM[5]
-	paddd	0x30(%r11), @XMM[4]	# .LADD4
-	movdqa	@XMM[0], @XMM[6]
-	paddd	0x40(%r11), @XMM[5]	# .LADD5
-	movdqa	@XMM[0], @XMM[7]
-	paddd	0x50(%r11), @XMM[6]	# .LADD6
-	paddd	0x60(%r11), @XMM[7]	# .LADD7
-
-	# Borrow prologue from _bsaes_encrypt8 to use the opportunity
-	# to flip byte order in 32-bit counter
-	movdqa	(%rsp), @XMM[9]		# round 0 key
-	lea	0x10(%rsp), %rax	# pass key schedule
-	movdqa	-0x10(%r11), @XMM[8]	# .LSWPUPM0SR
-	pxor	@XMM[9], @XMM[0]	# xor with round0 key
-	pxor	@XMM[9], @XMM[1]
-	pxor	@XMM[9], @XMM[2]
-	pxor	@XMM[9], @XMM[3]
-	 pshufb	@XMM[8], @XMM[0]
-	 pshufb	@XMM[8], @XMM[1]
-	pxor	@XMM[9], @XMM[4]
-	pxor	@XMM[9], @XMM[5]
-	 pshufb	@XMM[8], @XMM[2]
-	 pshufb	@XMM[8], @XMM[3]
-	pxor	@XMM[9], @XMM[6]
-	pxor	@XMM[9], @XMM[7]
-	 pshufb	@XMM[8], @XMM[4]
-	 pshufb	@XMM[8], @XMM[5]
-	 pshufb	@XMM[8], @XMM[6]
-	 pshufb	@XMM[8], @XMM[7]
-	lea	.LBS0(%rip), %r11	# constants table
-	mov	%ebx,%r10d		# pass rounds
-
-	call	_bsaes_encrypt8_bitslice
-
-	sub	\$8,$len
-	jc	.Lctr_enc_loop_done
-
-	movdqu	0x00($inp), @XMM[8]	# load input
-	movdqu	0x10($inp), @XMM[9]
-	movdqu	0x20($inp), @XMM[10]
-	movdqu	0x30($inp), @XMM[11]
-	movdqu	0x40($inp), @XMM[12]
-	movdqu	0x50($inp), @XMM[13]
-	movdqu	0x60($inp), @XMM[14]
-	movdqu	0x70($inp), @XMM[15]
-	lea	0x80($inp),$inp
-	pxor	@XMM[0], @XMM[8]
-	movdqa	0x20(%rbp), @XMM[0]	# load counter
-	pxor	@XMM[9], @XMM[1]
-	movdqu	@XMM[8], 0x00($out)	# write output
-	pxor	@XMM[10], @XMM[4]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	@XMM[11], @XMM[6]
-	movdqu	@XMM[4], 0x20($out)
-	pxor	@XMM[12], @XMM[3]
-	movdqu	@XMM[6], 0x30($out)
-	pxor	@XMM[13], @XMM[7]
-	movdqu	@XMM[3], 0x40($out)
-	pxor	@XMM[14], @XMM[2]
-	movdqu	@XMM[7], 0x50($out)
-	pxor	@XMM[15], @XMM[5]
-	movdqu	@XMM[2], 0x60($out)
-	lea	.LADD1(%rip), %r11
-	movdqu	@XMM[5], 0x70($out)
-	lea	0x80($out), $out
-	paddd	0x70(%r11), @XMM[0]	# .LADD8
-	jnz	.Lctr_enc_loop
-
-	jmp	.Lctr_enc_done
-.align	16
-.Lctr_enc_loop_done:
-	add	\$8, $len
-	movdqu	0x00($inp), @XMM[8]	# load input
-	pxor	@XMM[8], @XMM[0]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	cmp	\$2,$len
-	jb	.Lctr_enc_done
-	movdqu	0x10($inp), @XMM[9]
-	pxor	@XMM[9], @XMM[1]
-	movdqu	@XMM[1], 0x10($out)
-	je	.Lctr_enc_done
-	movdqu	0x20($inp), @XMM[10]
-	pxor	@XMM[10], @XMM[4]
-	movdqu	@XMM[4], 0x20($out)
-	cmp	\$4,$len
-	jb	.Lctr_enc_done
-	movdqu	0x30($inp), @XMM[11]
-	pxor	@XMM[11], @XMM[6]
-	movdqu	@XMM[6], 0x30($out)
-	je	.Lctr_enc_done
-	movdqu	0x40($inp), @XMM[12]
-	pxor	@XMM[12], @XMM[3]
-	movdqu	@XMM[3], 0x40($out)
-	cmp	\$6,$len
-	jb	.Lctr_enc_done
-	movdqu	0x50($inp), @XMM[13]
-	pxor	@XMM[13], @XMM[7]
-	movdqu	@XMM[7], 0x50($out)
-	je	.Lctr_enc_done
-	movdqu	0x60($inp), @XMM[14]
-	pxor	@XMM[14], @XMM[2]
-	movdqu	@XMM[2], 0x60($out)
-	jmp	.Lctr_enc_done
-
-.align	16
-.Lctr_enc_short:
-	lea	0x20(%rbp), $arg1
-	lea	0x30(%rbp), $arg2
-	lea	($key), $arg3
-	call	asm_AES_encrypt
-	movdqu	($inp), @XMM[1]
-	lea	16($inp), $inp
-	mov	0x2c(%rbp), %eax	# load 32-bit counter
-	bswap	%eax
-	pxor	0x30(%rbp), @XMM[1]
-	inc	%eax			# increment
-	movdqu	@XMM[1], ($out)
-	bswap	%eax
-	lea	16($out), $out
-	mov	%eax, 0x2c(%rsp)	# save 32-bit counter
-	dec	$len
-	jnz	.Lctr_enc_short
-
-.Lctr_enc_done:
-	lea	(%rsp), %rax
-	pxor	%xmm0, %xmm0
-.Lctr_enc_bzero:			# wipe key schedule [if any]
-	movdqa	%xmm0, 0x00(%rax)
-	movdqa	%xmm0, 0x10(%rax)
-	lea	0x20(%rax), %rax
-	cmp	%rax, %rbp
-	ja	.Lctr_enc_bzero
-
-	lea	0x78(%rbp),%rax
-.cfi_def_cfa	%rax,8
-___
-$code.=&lt;&lt;___ if ($win64);
-	movaps	0x40(%rbp), %xmm6
-	movaps	0x50(%rbp), %xmm7
-	movaps	0x60(%rbp), %xmm8
-	movaps	0x70(%rbp), %xmm9
-	movaps	0x80(%rbp), %xmm10
-	movaps	0x90(%rbp), %xmm11
-	movaps	0xa0(%rbp), %xmm12
-	movaps	0xb0(%rbp), %xmm13
-	movaps	0xc0(%rbp), %xmm14
-	movaps	0xd0(%rbp), %xmm15
-	lea	0xa0(%rax), %rax
-.Lctr_enc_tail:
-___
-$code.=&lt;&lt;___;
-	mov	-48(%rax), %r15
-.cfi_restore	%r15
-	mov	-40(%rax), %r14
-.cfi_restore	%r14
-	mov	-32(%rax), %r13
-.cfi_restore	%r13
-	mov	-24(%rax), %r12
-.cfi_restore	%r12
-	mov	-16(%rax), %rbx
-.cfi_restore	%rbx
-	mov	-8(%rax), %rbp
-.cfi_restore	%rbp
-	lea	(%rax), %rsp		# restore %rsp
-.cfi_def_cfa_register	%rsp
-.Lctr_enc_epilogue:
-	ret
-.cfi_endproc
-.size	bsaes_ctr32_encrypt_blocks,.-bsaes_ctr32_encrypt_blocks
-___
-######################################################################
-# void bsaes_xts_[en|de]crypt(const char *inp,char *out,size_t len,
-#	const AES_KEY *key1, const AES_KEY *key2,
-#	const unsigned char iv[16]);
-#
-my ($twmask,$twres,$twtmp)=@XMM[13..15];
-$arg6=~s/d$//;
-
-$code.=&lt;&lt;___;
-.globl	bsaes_xts_encrypt
-.type	bsaes_xts_encrypt,\@abi-omnipotent
-.align	16
-bsaes_xts_encrypt:
-.cfi_startproc
-	mov	%rsp, %rax
-.Lxts_enc_prologue:
-	push	%rbp
-.cfi_push	%rbp
-	push	%rbx
-.cfi_push	%rbx
-	push	%r12
-.cfi_push	%r12
-	push	%r13
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-	lea	-0x48(%rsp), %rsp
-.cfi_adjust_cfa_offset	0x48
-___
-$code.=&lt;&lt;___ if ($win64);
-	mov	0xa0(%rsp),$arg5	# pull key2
-	mov	0xa8(%rsp),$arg6	# pull ivp
-	lea	-0xa0(%rsp), %rsp
-	movaps	%xmm6, 0x40(%rsp)
-	movaps	%xmm7, 0x50(%rsp)
-	movaps	%xmm8, 0x60(%rsp)
-	movaps	%xmm9, 0x70(%rsp)
-	movaps	%xmm10, 0x80(%rsp)
-	movaps	%xmm11, 0x90(%rsp)
-	movaps	%xmm12, 0xa0(%rsp)
-	movaps	%xmm13, 0xb0(%rsp)
-	movaps	%xmm14, 0xc0(%rsp)
-	movaps	%xmm15, 0xd0(%rsp)
-.Lxts_enc_body:
-___
-$code.=&lt;&lt;___;
-	mov	%rsp, %rbp		# backup %rsp
-.cfi_def_cfa_register	%rbp
-	mov	$arg1, $inp		# backup arguments
-	mov	$arg2, $out
-	mov	$arg3, $len
-	mov	$arg4, $key
-
-	lea	($arg6), $arg1
-	lea	0x20(%rbp), $arg2
-	lea	($arg5), $arg3
-	call	asm_AES_encrypt		# generate initial tweak
-
-	mov	240($key), %eax		# rounds
-	mov	$len, %rbx		# backup $len
-
-	mov	%eax, %edx		# rounds
-	shl	\$7, %rax		# 128 bytes per inner round key
-	sub	\$`128-32`, %rax	# size of bit-sliced key schedule
-	sub	%rax, %rsp
-
-	mov	%rsp, %rax		# pass key schedule
-	mov	$key, %rcx		# pass key
-	mov	%edx, %r10d		# pass rounds
-	call	_bsaes_key_convert
-	pxor	%xmm6, %xmm7		# fix up last round key
-	movdqa	%xmm7, (%rax)		# save last round key
-
-	and	\$-16, $len
-	sub	\$0x80, %rsp		# place for tweak[8]
-	movdqa	0x20(%rbp), @XMM[7]	# initial tweak
-
-	pxor	$twtmp, $twtmp
-	movdqa	.Lxts_magic(%rip), $twmask
-	pcmpgtd	@XMM[7], $twtmp		# broadcast upper bits
-
-	sub	\$0x80, $len
-	jc	.Lxts_enc_short
-	jmp	.Lxts_enc_loop
-
-.align	16
-.Lxts_enc_loop:
-___
-    for ($i=0;$i&lt;7;$i++) {
-    $code.=&lt;&lt;___;
-	pshufd	\$0x13, $twtmp, $twres
-	pxor	$twtmp, $twtmp
-	movdqa	@XMM[7], @XMM[$i]
-	movdqa	@XMM[7], `0x10*$i`(%rsp)# save tweak[$i]
-	paddq	@XMM[7], @XMM[7]	# psllq	1,$tweak
-	pand	$twmask, $twres		# isolate carry and residue
-	pcmpgtd	@XMM[7], $twtmp		# broadcast upper bits
-	pxor	$twres, @XMM[7]
-___
-    $code.=&lt;&lt;___ if ($i&gt;=1);
-	movdqu	`0x10*($i-1)`($inp), @XMM[8+$i-1]
-___
-    $code.=&lt;&lt;___ if ($i&gt;=2);
-	pxor	@XMM[8+$i-2], @XMM[$i-2]# input[] ^ tweak[]
-___
-    }
-$code.=&lt;&lt;___;
-	movdqu	0x60($inp), @XMM[8+6]
-	pxor	@XMM[8+5], @XMM[5]
-	movdqu	0x70($inp), @XMM[8+7]
-	lea	0x80($inp), $inp
-	movdqa	@XMM[7], 0x70(%rsp)
-	pxor	@XMM[8+6], @XMM[6]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	pxor	@XMM[8+7], @XMM[7]
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_encrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[4]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	0x30(%rsp), @XMM[6]
-	movdqu	@XMM[4], 0x20($out)
-	pxor	0x40(%rsp), @XMM[3]
-	movdqu	@XMM[6], 0x30($out)
-	pxor	0x50(%rsp), @XMM[7]
-	movdqu	@XMM[3], 0x40($out)
-	pxor	0x60(%rsp), @XMM[2]
-	movdqu	@XMM[7], 0x50($out)
-	pxor	0x70(%rsp), @XMM[5]
-	movdqu	@XMM[2], 0x60($out)
-	movdqu	@XMM[5], 0x70($out)
-	lea	0x80($out), $out
-
-	movdqa	0x70(%rsp), @XMM[7]	# prepare next iteration tweak
-	pxor	$twtmp, $twtmp
-	movdqa	.Lxts_magic(%rip), $twmask
-	pcmpgtd	@XMM[7], $twtmp
-	pshufd	\$0x13, $twtmp, $twres
-	pxor	$twtmp, $twtmp
-	paddq	@XMM[7], @XMM[7]	# psllq	1,$tweak
-	pand	$twmask, $twres		# isolate carry and residue
-	pcmpgtd	@XMM[7], $twtmp		# broadcast upper bits
-	pxor	$twres, @XMM[7]
-
-	sub	\$0x80,$len
-	jnc	.Lxts_enc_loop
-
-.Lxts_enc_short:
-	add	\$0x80, $len
-	jz	.Lxts_enc_done
-___
-    for ($i=0;$i&lt;7;$i++) {
-    $code.=&lt;&lt;___;
-	pshufd	\$0x13, $twtmp, $twres
-	pxor	$twtmp, $twtmp
-	movdqa	@XMM[7], @XMM[$i]
-	movdqa	@XMM[7], `0x10*$i`(%rsp)# save tweak[$i]
-	paddq	@XMM[7], @XMM[7]	# psllq	1,$tweak
-	pand	$twmask, $twres		# isolate carry and residue
-	pcmpgtd	@XMM[7], $twtmp		# broadcast upper bits
-	pxor	$twres, @XMM[7]
-___
-    $code.=&lt;&lt;___ if ($i&gt;=1);
-	movdqu	`0x10*($i-1)`($inp), @XMM[8+$i-1]
-	cmp	\$`0x10*$i`,$len
-	je	.Lxts_enc_$i
-___
-    $code.=&lt;&lt;___ if ($i&gt;=2);
-	pxor	@XMM[8+$i-2], @XMM[$i-2]# input[] ^ tweak[]
-___
-    }
-$code.=&lt;&lt;___;
-	movdqu	0x60($inp), @XMM[8+6]
-	pxor	@XMM[8+5], @XMM[5]
-	movdqa	@XMM[7], 0x70(%rsp)
-	lea	0x70($inp), $inp
-	pxor	@XMM[8+6], @XMM[6]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_encrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[4]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	0x30(%rsp), @XMM[6]
-	movdqu	@XMM[4], 0x20($out)
-	pxor	0x40(%rsp), @XMM[3]
-	movdqu	@XMM[6], 0x30($out)
-	pxor	0x50(%rsp), @XMM[7]
-	movdqu	@XMM[3], 0x40($out)
-	pxor	0x60(%rsp), @XMM[2]
-	movdqu	@XMM[7], 0x50($out)
-	movdqu	@XMM[2], 0x60($out)
-	lea	0x70($out), $out
-
-	movdqa	0x70(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_enc_done
-.align	16
-.Lxts_enc_6:
-	pxor	@XMM[8+4], @XMM[4]
-	lea	0x60($inp), $inp
-	pxor	@XMM[8+5], @XMM[5]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_encrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[4]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	0x30(%rsp), @XMM[6]
-	movdqu	@XMM[4], 0x20($out)
-	pxor	0x40(%rsp), @XMM[3]
-	movdqu	@XMM[6], 0x30($out)
-	pxor	0x50(%rsp), @XMM[7]
-	movdqu	@XMM[3], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	lea	0x60($out), $out
-
-	movdqa	0x60(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_enc_done
-.align	16
-.Lxts_enc_5:
-	pxor	@XMM[8+3], @XMM[3]
-	lea	0x50($inp), $inp
-	pxor	@XMM[8+4], @XMM[4]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_encrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[4]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	0x30(%rsp), @XMM[6]
-	movdqu	@XMM[4], 0x20($out)
-	pxor	0x40(%rsp), @XMM[3]
-	movdqu	@XMM[6], 0x30($out)
-	movdqu	@XMM[3], 0x40($out)
-	lea	0x50($out), $out
-
-	movdqa	0x50(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_enc_done
-.align	16
-.Lxts_enc_4:
-	pxor	@XMM[8+2], @XMM[2]
-	lea	0x40($inp), $inp
-	pxor	@XMM[8+3], @XMM[3]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_encrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[4]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	0x30(%rsp), @XMM[6]
-	movdqu	@XMM[4], 0x20($out)
-	movdqu	@XMM[6], 0x30($out)
-	lea	0x40($out), $out
-
-	movdqa	0x40(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_enc_done
-.align	16
-.Lxts_enc_3:
-	pxor	@XMM[8+1], @XMM[1]
-	lea	0x30($inp), $inp
-	pxor	@XMM[8+2], @XMM[2]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_encrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[4]
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[4], 0x20($out)
-	lea	0x30($out), $out
-
-	movdqa	0x30(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_enc_done
-.align	16
-.Lxts_enc_2:
-	pxor	@XMM[8+0], @XMM[0]
-	lea	0x20($inp), $inp
-	pxor	@XMM[8+1], @XMM[1]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_encrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	lea	0x20($out), $out
-
-	movdqa	0x20(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_enc_done
-.align	16
-.Lxts_enc_1:
-	pxor	@XMM[0], @XMM[8]
-	lea	0x10($inp), $inp
-	movdqa	@XMM[8], 0x20(%rbp)
-	lea	0x20(%rbp), $arg1
-	lea	0x20(%rbp), $arg2
-	lea	($key), $arg3
-	call	asm_AES_encrypt		# doesn't touch %xmm
-	pxor	0x20(%rbp), @XMM[0]	# ^= tweak[]
-	#pxor	@XMM[8], @XMM[0]
-	#lea	0x80(%rsp), %rax	# pass key schedule
-	#mov	%edx, %r10d		# pass rounds
-	#call	_bsaes_encrypt8
-	#pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	lea	0x10($out), $out
-
-	movdqa	0x10(%rsp), @XMM[7]	# next iteration tweak
-
-.Lxts_enc_done:
-	and	\$15, %ebx
-	jz	.Lxts_enc_ret
-	mov	$out, %rdx
-
-.Lxts_enc_steal:
-	movzb	($inp), %eax
-	movzb	-16(%rdx), %ecx
-	lea	1($inp), $inp
-	mov	%al, -16(%rdx)
-	mov	%cl, 0(%rdx)
-	lea	1(%rdx), %rdx
-	sub	\$1,%ebx
-	jnz	.Lxts_enc_steal
-
-	movdqu	-16($out), @XMM[0]
-	lea	0x20(%rbp), $arg1
-	pxor	@XMM[7], @XMM[0]
-	lea	0x20(%rbp), $arg2
-	movdqa	@XMM[0], 0x20(%rbp)
-	lea	($key), $arg3
-	call	asm_AES_encrypt		# doesn't touch %xmm
-	pxor	0x20(%rbp), @XMM[7]
-	movdqu	@XMM[7], -16($out)
-
-.Lxts_enc_ret:
-	lea	(%rsp), %rax
-	pxor	%xmm0, %xmm0
-.Lxts_enc_bzero:			# wipe key schedule [if any]
-	movdqa	%xmm0, 0x00(%rax)
-	movdqa	%xmm0, 0x10(%rax)
-	lea	0x20(%rax), %rax
-	cmp	%rax, %rbp
-	ja	.Lxts_enc_bzero
-
-	lea	0x78(%rbp),%rax
-.cfi_def_cfa	%rax,8
-___
-$code.=&lt;&lt;___ if ($win64);
-	movaps	0x40(%rbp), %xmm6
-	movaps	0x50(%rbp), %xmm7
-	movaps	0x60(%rbp), %xmm8
-	movaps	0x70(%rbp), %xmm9
-	movaps	0x80(%rbp), %xmm10
-	movaps	0x90(%rbp), %xmm11
-	movaps	0xa0(%rbp), %xmm12
-	movaps	0xb0(%rbp), %xmm13
-	movaps	0xc0(%rbp), %xmm14
-	movaps	0xd0(%rbp), %xmm15
-	lea	0xa0(%rax), %rax
-.Lxts_enc_tail:
-___
-$code.=&lt;&lt;___;
-	mov	-48(%rax), %r15
-.cfi_restore	%r15
-	mov	-40(%rax), %r14
-.cfi_restore	%r14
-	mov	-32(%rax), %r13
-.cfi_restore	%r13
-	mov	-24(%rax), %r12
-.cfi_restore	%r12
-	mov	-16(%rax), %rbx
-.cfi_restore	%rbx
-	mov	-8(%rax), %rbp
-.cfi_restore	%rbp
-	lea	(%rax), %rsp		# restore %rsp
-.cfi_def_cfa_register	%rsp
-.Lxts_enc_epilogue:
-	ret
-.cfi_endproc
-.size	bsaes_xts_encrypt,.-bsaes_xts_encrypt
-
-.globl	bsaes_xts_decrypt
-.type	bsaes_xts_decrypt,\@abi-omnipotent
-.align	16
-bsaes_xts_decrypt:
-.cfi_startproc
-	mov	%rsp, %rax
-.Lxts_dec_prologue:
-	push	%rbp
-.cfi_push	%rbp
-	push	%rbx
-.cfi_push	%rbx
-	push	%r12
-.cfi_push	%r12
-	push	%r13
-.cfi_push	%r13
-	push	%r14
-.cfi_push	%r14
-	push	%r15
-.cfi_push	%r15
-	lea	-0x48(%rsp), %rsp
-.cfi_adjust_cfa_offset	0x48
-___
-$code.=&lt;&lt;___ if ($win64);
-	mov	0xa0(%rsp),$arg5	# pull key2
-	mov	0xa8(%rsp),$arg6	# pull ivp
-	lea	-0xa0(%rsp), %rsp
-	movaps	%xmm6, 0x40(%rsp)
-	movaps	%xmm7, 0x50(%rsp)
-	movaps	%xmm8, 0x60(%rsp)
-	movaps	%xmm9, 0x70(%rsp)
-	movaps	%xmm10, 0x80(%rsp)
-	movaps	%xmm11, 0x90(%rsp)
-	movaps	%xmm12, 0xa0(%rsp)
-	movaps	%xmm13, 0xb0(%rsp)
-	movaps	%xmm14, 0xc0(%rsp)
-	movaps	%xmm15, 0xd0(%rsp)
-.Lxts_dec_body:
-___
-$code.=&lt;&lt;___;
-	mov	%rsp, %rbp		# backup %rsp
-	mov	$arg1, $inp		# backup arguments
-	mov	$arg2, $out
-	mov	$arg3, $len
-	mov	$arg4, $key
-
-	lea	($arg6), $arg1
-	lea	0x20(%rbp), $arg2
-	lea	($arg5), $arg3
-	call	asm_AES_encrypt		# generate initial tweak
-
-	mov	240($key), %eax		# rounds
-	mov	$len, %rbx		# backup $len
-
-	mov	%eax, %edx		# rounds
-	shl	\$7, %rax		# 128 bytes per inner round key
-	sub	\$`128-32`, %rax	# size of bit-sliced key schedule
-	sub	%rax, %rsp
-
-	mov	%rsp, %rax		# pass key schedule
-	mov	$key, %rcx		# pass key
-	mov	%edx, %r10d		# pass rounds
-	call	_bsaes_key_convert
-	pxor	(%rsp), %xmm7		# fix up round 0 key
-	movdqa	%xmm6, (%rax)		# save last round key
-	movdqa	%xmm7, (%rsp)
-
-	xor	%eax, %eax		# if ($len%16) len-=16;
-	and	\$-16, $len
-	test	\$15, %ebx
-	setnz	%al
-	shl	\$4, %rax
-	sub	%rax, $len
-
-	sub	\$0x80, %rsp		# place for tweak[8]
-	movdqa	0x20(%rbp), @XMM[7]	# initial tweak
-
-	pxor	$twtmp, $twtmp
-	movdqa	.Lxts_magic(%rip), $twmask
-	pcmpgtd	@XMM[7], $twtmp		# broadcast upper bits
-
-	sub	\$0x80, $len
-	jc	.Lxts_dec_short
-	jmp	.Lxts_dec_loop
-
-.align	16
-.Lxts_dec_loop:
-___
-    for ($i=0;$i&lt;7;$i++) {
-    $code.=&lt;&lt;___;
-	pshufd	\$0x13, $twtmp, $twres
-	pxor	$twtmp, $twtmp
-	movdqa	@XMM[7], @XMM[$i]
-	movdqa	@XMM[7], `0x10*$i`(%rsp)# save tweak[$i]
-	paddq	@XMM[7], @XMM[7]	# psllq	1,$tweak
-	pand	$twmask, $twres		# isolate carry and residue
-	pcmpgtd	@XMM[7], $twtmp		# broadcast upper bits
-	pxor	$twres, @XMM[7]
-___
-    $code.=&lt;&lt;___ if ($i&gt;=1);
-	movdqu	`0x10*($i-1)`($inp), @XMM[8+$i-1]
-___
-    $code.=&lt;&lt;___ if ($i&gt;=2);
-	pxor	@XMM[8+$i-2], @XMM[$i-2]# input[] ^ tweak[]
-___
-    }
-$code.=&lt;&lt;___;
-	movdqu	0x60($inp), @XMM[8+6]
-	pxor	@XMM[8+5], @XMM[5]
-	movdqu	0x70($inp), @XMM[8+7]
-	lea	0x80($inp), $inp
-	movdqa	@XMM[7], 0x70(%rsp)
-	pxor	@XMM[8+6], @XMM[6]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	pxor	@XMM[8+7], @XMM[7]
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_decrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[6]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	0x30(%rsp), @XMM[4]
-	movdqu	@XMM[6], 0x20($out)
-	pxor	0x40(%rsp), @XMM[2]
-	movdqu	@XMM[4], 0x30($out)
-	pxor	0x50(%rsp), @XMM[7]
-	movdqu	@XMM[2], 0x40($out)
-	pxor	0x60(%rsp), @XMM[3]
-	movdqu	@XMM[7], 0x50($out)
-	pxor	0x70(%rsp), @XMM[5]
-	movdqu	@XMM[3], 0x60($out)
-	movdqu	@XMM[5], 0x70($out)
-	lea	0x80($out), $out
-
-	movdqa	0x70(%rsp), @XMM[7]	# prepare next iteration tweak
-	pxor	$twtmp, $twtmp
-	movdqa	.Lxts_magic(%rip), $twmask
-	pcmpgtd	@XMM[7], $twtmp
-	pshufd	\$0x13, $twtmp, $twres
-	pxor	$twtmp, $twtmp
-	paddq	@XMM[7], @XMM[7]	# psllq	1,$tweak
-	pand	$twmask, $twres		# isolate carry and residue
-	pcmpgtd	@XMM[7], $twtmp		# broadcast upper bits
-	pxor	$twres, @XMM[7]
-
-	sub	\$0x80,$len
-	jnc	.Lxts_dec_loop
-
-.Lxts_dec_short:
-	add	\$0x80, $len
-	jz	.Lxts_dec_done
-___
-    for ($i=0;$i&lt;7;$i++) {
-    $code.=&lt;&lt;___;
-	pshufd	\$0x13, $twtmp, $twres
-	pxor	$twtmp, $twtmp
-	movdqa	@XMM[7], @XMM[$i]
-	movdqa	@XMM[7], `0x10*$i`(%rsp)# save tweak[$i]
-	paddq	@XMM[7], @XMM[7]	# psllq	1,$tweak
-	pand	$twmask, $twres		# isolate carry and residue
-	pcmpgtd	@XMM[7], $twtmp		# broadcast upper bits
-	pxor	$twres, @XMM[7]
-___
-    $code.=&lt;&lt;___ if ($i&gt;=1);
-	movdqu	`0x10*($i-1)`($inp), @XMM[8+$i-1]
-	cmp	\$`0x10*$i`,$len
-	je	.Lxts_dec_$i
-___
-    $code.=&lt;&lt;___ if ($i&gt;=2);
-	pxor	@XMM[8+$i-2], @XMM[$i-2]# input[] ^ tweak[]
-___
-    }
-$code.=&lt;&lt;___;
-	movdqu	0x60($inp), @XMM[8+6]
-	pxor	@XMM[8+5], @XMM[5]
-	movdqa	@XMM[7], 0x70(%rsp)
-	lea	0x70($inp), $inp
-	pxor	@XMM[8+6], @XMM[6]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_decrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[6]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	0x30(%rsp), @XMM[4]
-	movdqu	@XMM[6], 0x20($out)
-	pxor	0x40(%rsp), @XMM[2]
-	movdqu	@XMM[4], 0x30($out)
-	pxor	0x50(%rsp), @XMM[7]
-	movdqu	@XMM[2], 0x40($out)
-	pxor	0x60(%rsp), @XMM[3]
-	movdqu	@XMM[7], 0x50($out)
-	movdqu	@XMM[3], 0x60($out)
-	lea	0x70($out), $out
-
-	movdqa	0x70(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_dec_done
-.align	16
-.Lxts_dec_6:
-	pxor	@XMM[8+4], @XMM[4]
-	lea	0x60($inp), $inp
-	pxor	@XMM[8+5], @XMM[5]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_decrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[6]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	0x30(%rsp), @XMM[4]
-	movdqu	@XMM[6], 0x20($out)
-	pxor	0x40(%rsp), @XMM[2]
-	movdqu	@XMM[4], 0x30($out)
-	pxor	0x50(%rsp), @XMM[7]
-	movdqu	@XMM[2], 0x40($out)
-	movdqu	@XMM[7], 0x50($out)
-	lea	0x60($out), $out
-
-	movdqa	0x60(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_dec_done
-.align	16
-.Lxts_dec_5:
-	pxor	@XMM[8+3], @XMM[3]
-	lea	0x50($inp), $inp
-	pxor	@XMM[8+4], @XMM[4]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_decrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[6]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	0x30(%rsp), @XMM[4]
-	movdqu	@XMM[6], 0x20($out)
-	pxor	0x40(%rsp), @XMM[2]
-	movdqu	@XMM[4], 0x30($out)
-	movdqu	@XMM[2], 0x40($out)
-	lea	0x50($out), $out
-
-	movdqa	0x50(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_dec_done
-.align	16
-.Lxts_dec_4:
-	pxor	@XMM[8+2], @XMM[2]
-	lea	0x40($inp), $inp
-	pxor	@XMM[8+3], @XMM[3]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_decrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[6]
-	movdqu	@XMM[1], 0x10($out)
-	pxor	0x30(%rsp), @XMM[4]
-	movdqu	@XMM[6], 0x20($out)
-	movdqu	@XMM[4], 0x30($out)
-	lea	0x40($out), $out
-
-	movdqa	0x40(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_dec_done
-.align	16
-.Lxts_dec_3:
-	pxor	@XMM[8+1], @XMM[1]
-	lea	0x30($inp), $inp
-	pxor	@XMM[8+2], @XMM[2]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_decrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	pxor	0x20(%rsp), @XMM[6]
-	movdqu	@XMM[1], 0x10($out)
-	movdqu	@XMM[6], 0x20($out)
-	lea	0x30($out), $out
-
-	movdqa	0x30(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_dec_done
-.align	16
-.Lxts_dec_2:
-	pxor	@XMM[8+0], @XMM[0]
-	lea	0x20($inp), $inp
-	pxor	@XMM[8+1], @XMM[1]
-	lea	0x80(%rsp), %rax	# pass key schedule
-	mov	%edx, %r10d		# pass rounds
-
-	call	_bsaes_decrypt8
-
-	pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	pxor	0x10(%rsp), @XMM[1]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	movdqu	@XMM[1], 0x10($out)
-	lea	0x20($out), $out
-
-	movdqa	0x20(%rsp), @XMM[7]	# next iteration tweak
-	jmp	.Lxts_dec_done
-.align	16
-.Lxts_dec_1:
-	pxor	@XMM[0], @XMM[8]
-	lea	0x10($inp), $inp
-	movdqa	@XMM[8], 0x20(%rbp)
-	lea	0x20(%rbp), $arg1
-	lea	0x20(%rbp), $arg2
-	lea	($key), $arg3
-	call	asm_AES_decrypt		# doesn't touch %xmm
-	pxor	0x20(%rbp), @XMM[0]	# ^= tweak[]
-	#pxor	@XMM[8], @XMM[0]
-	#lea	0x80(%rsp), %rax	# pass key schedule
-	#mov	%edx, %r10d		# pass rounds
-	#call	_bsaes_decrypt8
-	#pxor	0x00(%rsp), @XMM[0]	# ^= tweak[]
-	movdqu	@XMM[0], 0x00($out)	# write output
-	lea	0x10($out), $out
-
-	movdqa	0x10(%rsp), @XMM[7]	# next iteration tweak
-
-.Lxts_dec_done:
-	and	\$15, %ebx
-	jz	.Lxts_dec_ret
-
-	pxor	$twtmp, $twtmp
-	movdqa	.Lxts_magic(%rip), $twmask
-	pcmpgtd	@XMM[7], $twtmp
-	pshufd	\$0x13, $twtmp, $twres
-	movdqa	@XMM[7], @XMM[6]
-	paddq	@XMM[7], @XMM[7]	# psllq 1,$tweak
-	pand	$twmask, $twres		# isolate carry and residue
-	movdqu	($inp), @XMM[0]
-	pxor	$twres, @XMM[7]
-
-	lea	0x20(%rbp), $arg1
-	pxor	@XMM[7], @XMM[0]
-	lea	0x20(%rbp), $arg2
-	movdqa	@XMM[0], 0x20(%rbp)
-	lea	($key), $arg3
-	call	asm_AES_decrypt		# doesn't touch %xmm
-	pxor	0x20(%rbp), @XMM[7]
-	mov	$out, %rdx
-	movdqu	@XMM[7], ($out)
-
-.Lxts_dec_steal:
-	movzb	16($inp), %eax
-	movzb	(%rdx), %ecx
-	lea	1($inp), $inp
-	mov	%al, (%rdx)
-	mov	%cl, 16(%rdx)
-	lea	1(%rdx), %rdx
-	sub	\$1,%ebx
-	jnz	.Lxts_dec_steal
-
-	movdqu	($out), @XMM[0]
-	lea	0x20(%rbp), $arg1
-	pxor	@XMM[6], @XMM[0]
-	lea	0x20(%rbp), $arg2
-	movdqa	@XMM[0], 0x20(%rbp)
-	lea	($key), $arg3
-	call	asm_AES_decrypt		# doesn't touch %xmm
-	pxor	0x20(%rbp), @XMM[6]
-	movdqu	@XMM[6], ($out)
-
-.Lxts_dec_ret:
-	lea	(%rsp), %rax
-	pxor	%xmm0, %xmm0
-.Lxts_dec_bzero:			# wipe key schedule [if any]
-	movdqa	%xmm0, 0x00(%rax)
-	movdqa	%xmm0, 0x10(%rax)
-	lea	0x20(%rax), %rax
-	cmp	%rax, %rbp
-	ja	.Lxts_dec_bzero
-
-	lea	0x78(%rbp),%rax
-.cfi_def_cfa	%rax,8
-___
-$code.=&lt;&lt;___ if ($win64);
-	movaps	0x40(%rbp), %xmm6
-	movaps	0x50(%rbp), %xmm7
-	movaps	0x60(%rbp), %xmm8
-	movaps	0x70(%rbp), %xmm9
-	movaps	0x80(%rbp), %xmm10
-	movaps	0x90(%rbp), %xmm11
-	movaps	0xa0(%rbp), %xmm12
-	movaps	0xb0(%rbp), %xmm13
-	movaps	0xc0(%rbp), %xmm14
-	movaps	0xd0(%rbp), %xmm15
-	lea	0xa0(%rax), %rax
-.Lxts_dec_tail:
-___
-$code.=&lt;&lt;___;
-	mov	-48(%rax), %r15
-.cfi_restore	%r15
-	mov	-40(%rax), %r14
-.cfi_restore	%r14
-	mov	-32(%rax), %r13
-.cfi_restore	%r13
-	mov	-24(%rax), %r12
-.cfi_restore	%r12
-	mov	-16(%rax), %rbx
-.cfi_restore	%rbx
-	mov	-8(%rax), %rbp
-.cfi_restore	%rbp
-	lea	(%rax), %rsp		# restore %rsp
-.cfi_def_cfa_register	%rsp
-.Lxts_dec_epilogue:
-	ret
-.cfi_endproc
-.size	bsaes_xts_decrypt,.-bsaes_xts_decrypt
-___
-}
-$code.=&lt;&lt;___;
-.type	_bsaes_const,\@object
-.align	64
-_bsaes_const:
-.LM0ISR:	# InvShiftRows constants
-	.quad	0x0a0e0206070b0f03, 0x0004080c0d010509
-.LISRM0:
-	.quad	0x01040b0e0205080f, 0x0306090c00070a0d
-.LISR:
-	.quad	0x0504070602010003, 0x0f0e0d0c080b0a09
-.LBS0:		# bit-slice constants
-	.quad	0x5555555555555555, 0x5555555555555555
-.LBS1:
-	.quad	0x3333333333333333, 0x3333333333333333
-.LBS2:
-	.quad	0x0f0f0f0f0f0f0f0f, 0x0f0f0f0f0f0f0f0f
-.LSR:		# shiftrows constants
-	.quad	0x0504070600030201, 0x0f0e0d0c0a09080b
-.LSRM0:
-	.quad	0x0304090e00050a0f, 0x01060b0c0207080d
-.LM0SR:
-	.quad	0x0a0e02060f03070b, 0x0004080c05090d01
-.LSWPUP:	# byte-swap upper dword
-	.quad	0x0706050403020100, 0x0c0d0e0f0b0a0908
-.LSWPUPM0SR:
-	.quad	0x0a0d02060c03070b, 0x0004080f05090e01
-.LADD1:		# counter increment constants
-	.quad	0x0000000000000000, 0x0000000100000000
-.LADD2:
-	.quad	0x0000000000000000, 0x0000000200000000
-.LADD3:
-	.quad	0x0000000000000000, 0x0000000300000000
-.LADD4:
-	.quad	0x0000000000000000, 0x0000000400000000
-.LADD5:
-	.quad	0x0000000000000000, 0x0000000500000000
-.LADD6:
-	.quad	0x0000000000000000, 0x0000000600000000
-.LADD7:
-	.quad	0x0000000000000000, 0x0000000700000000
-.LADD8:
-	.quad	0x0000000000000000, 0x0000000800000000
-.Lxts_magic:
-	.long	0x87,0,1,0
-.Lmasks:
-	.quad	0x0101010101010101, 0x0101010101010101
-	.quad	0x0202020202020202, 0x0202020202020202
-	.quad	0x0404040404040404, 0x0404040404040404
-	.quad	0x0808080808080808, 0x0808080808080808
-.LM0:
-	.quad	0x02060a0e03070b0f, 0x0004080c0105090d
-.L63:
-	.quad	0x6363636363636363, 0x6363636363636363
-.asciz	&quot;Bit-sliced AES for x86_64/SSSE3, Emilia K&#228;sper, Peter Schwabe, Andy Polyakov&quot;
-.align	64
-.size	_bsaes_const,.-_bsaes_const
-___
-
-# EXCEPTION_DISPOSITION handler (EXCEPTION_RECORD *rec,ULONG64 frame,
-#		CONTEXT *context,DISPATCHER_CONTEXT *disp)
-if ($win64) {
-$rec=&quot;%rcx&quot;;
-$frame=&quot;%rdx&quot;;
-$context=&quot;%r8&quot;;
-$disp=&quot;%r9&quot;;
-
-$code.=&lt;&lt;___;
-.extern	__imp_RtlVirtualUnwind
-.type	se_handler,\@abi-omnipotent
-.align	16
-se_handler:
-	push	%rsi
-	push	%rdi
-	push	%rbx
-	push	%rbp
-	push	%r12
-	push	%r13
-	push	%r14
-	push	%r15
-	pushfq
-	sub	\$64,%rsp
-
-	mov	120($context),%rax	# pull context-&gt;Rax
-	mov	248($context),%rbx	# pull context-&gt;Rip
-
-	mov	8($disp),%rsi		# disp-&gt;ImageBase
-	mov	56($disp),%r11		# disp-&gt;HandlerData
-
-	mov	0(%r11),%r10d		# HandlerData[0]
-	lea	(%rsi,%r10),%r10	# prologue label
-	cmp	%r10,%rbx		# context-&gt;Rip&lt;=prologue label
-	jbe	.Lin_prologue
-
-	mov	4(%r11),%r10d		# HandlerData[1]
-	lea	(%rsi,%r10),%r10	# epilogue label
-	cmp	%r10,%rbx		# context-&gt;Rip&gt;=epilogue label
-	jae	.Lin_prologue
-
-	mov	8(%r11),%r10d		# HandlerData[2]
-	lea	(%rsi,%r10),%r10	# epilogue label
-	cmp	%r10,%rbx		# context-&gt;Rip&gt;=tail label
-	jae	.Lin_tail
-
-	mov	160($context),%rax	# pull context-&gt;Rbp
-
-	lea	0x40(%rax),%rsi		# %xmm save area
-	lea	512($context),%rdi	# &amp;context.Xmm6
-	mov	\$20,%ecx		# 10*sizeof(%xmm0)/sizeof(%rax)
-	.long	0xa548f3fc		# cld; rep movsq
-	lea	0xa0+0x78(%rax),%rax	# adjust stack pointer
-
-.Lin_tail:
-	mov	-48(%rax),%rbp
-	mov	-40(%rax),%rbx
-	mov	-32(%rax),%r12
-	mov	-24(%rax),%r13
-	mov	-16(%rax),%r14
-	mov	-8(%rax),%r15
-	mov	%rbx,144($context)	# restore context-&gt;Rbx
-	mov	%rbp,160($context)	# restore context-&gt;Rbp
-	mov	%r12,216($context)	# restore context-&gt;R12
-	mov	%r13,224($context)	# restore context-&gt;R13
-	mov	%r14,232($context)	# restore context-&gt;R14
-	mov	%r15,240($context)	# restore context-&gt;R15
-
-.Lin_prologue:
-	mov	%rax,152($context)	# restore context-&gt;Rsp
-
-	mov	40($disp),%rdi		# disp-&gt;ContextRecord
-	mov	$context,%rsi		# context
-	mov	\$`1232/8`,%ecx		# sizeof(CONTEXT)
-	.long	0xa548f3fc		# cld; rep movsq
-
-	mov	$disp,%rsi
-	xor	%rcx,%rcx		# arg1, UNW_FLAG_NHANDLER
-	mov	8(%rsi),%rdx		# arg2, disp-&gt;ImageBase
-	mov	0(%rsi),%r8		# arg3, disp-&gt;ControlPc
-	mov	16(%rsi),%r9		# arg4, disp-&gt;FunctionEntry
-	mov	40(%rsi),%r10		# disp-&gt;ContextRecord
-	lea	56(%rsi),%r11		# &amp;disp-&gt;HandlerData
-	lea	24(%rsi),%r12		# &amp;disp-&gt;EstablisherFrame
-	mov	%r10,32(%rsp)		# arg5
-	mov	%r11,40(%rsp)		# arg6
-	mov	%r12,48(%rsp)		# arg7
-	mov	%rcx,56(%rsp)		# arg8, (NULL)
-	call	*__imp_RtlVirtualUnwind(%rip)
-
-	mov	\$1,%eax		# ExceptionContinueSearch
-	add	\$64,%rsp
-	popfq
-	pop	%r15
-	pop	%r14
-	pop	%r13
-	pop	%r12
-	pop	%rbp
-	pop	%rbx
-	pop	%rdi
-	pop	%rsi
-	ret
-.size	se_handler,.-se_handler
-
-.section	.pdata
-.align	4
-___
-$code.=&lt;&lt;___ if ($ecb);
-	.rva	.Lecb_enc_prologue
-	.rva	.Lecb_enc_epilogue
-	.rva	.Lecb_enc_info
-
-	.rva	.Lecb_dec_prologue
-	.rva	.Lecb_dec_epilogue
-	.rva	.Lecb_dec_info
-___
-$code.=&lt;&lt;___;
-	.rva	.Lcbc_dec_prologue
-	.rva	.Lcbc_dec_epilogue
-	.rva	.Lcbc_dec_info
-
-	.rva	.Lctr_enc_prologue
-	.rva	.Lctr_enc_epilogue
-	.rva	.Lctr_enc_info
-
-	.rva	.Lxts_enc_prologue
-	.rva	.Lxts_enc_epilogue
-	.rva	.Lxts_enc_info
-
-	.rva	.Lxts_dec_prologue
-	.rva	.Lxts_dec_epilogue
-	.rva	.Lxts_dec_info
-
-.section	.xdata
-.align	8
-___
-$code.=&lt;&lt;___ if ($ecb);
-.Lecb_enc_info:
-	.byte	9,0,0,0
-	.rva	se_handler
-	.rva	.Lecb_enc_body,.Lecb_enc_epilogue	# HandlerData[]
-	.rva	.Lecb_enc_tail
-	.long	0
-.Lecb_dec_info:
-	.byte	9,0,0,0
-	.rva	se_handler
-	.rva	.Lecb_dec_body,.Lecb_dec_epilogue	# HandlerData[]
-	.rva	.Lecb_dec_tail
-	.long	0
-___
-$code.=&lt;&lt;___;
-.Lcbc_dec_info:
-	.byte	9,0,0,0
-	.rva	se_handler
-	.rva	.Lcbc_dec_body,.Lcbc_dec_epilogue	# HandlerData[]
-	.rva	.Lcbc_dec_tail
-	.long	0
-.Lctr_enc_info:
-	.byte	9,0,0,0
-	.rva	se_handler
-	.rva	.Lctr_enc_body,.Lctr_enc_epilogue	# HandlerData[]
-	.rva	.Lctr_enc_tail
-	.long	0
-.Lxts_enc_info:
-	.byte	9,0,0,0
-	.rva	se_handler
-	.rva	.Lxts_enc_body,.Lxts_enc_epilogue	# HandlerData[]
-	.rva	.Lxts_enc_tail
-	.long	0
-.Lxts_dec_info:
-	.byte	9,0,0,0
-	.rva	se_handler
-	.rva	.Lxts_dec_body,.Lxts_dec_epilogue	# HandlerData[]
-	.rva	.Lxts_dec_tail
-	.long	0
-___
-}
-
-$code =~ s/\`([^\`]*)\`/eval($1)/gem;
-
-print $code;
-
-close STDOUT;
diff --git a/crypto/evp/e_aes.c b/crypto/evp/e_aes.c
index 90a410b00d..1db346fc86 100644
--- a/crypto/evp/e_aes.c
+++ b/crypto/evp/e_aes.c
@@ -176,7 +176,7 @@ static void ctr64_inc(unsigned char *counter)
 # define HWAES_xts_decrypt aes_p8_xts_decrypt
 #endif
 
-#if     defined(AES_ASM) &amp;&amp; !defined(I386_ONLY) &amp;&amp;      (  \
+#if     !defined(OPENSSL_NO_ASM) &amp;&amp;                     (  \
         ((defined(__i386)       || defined(__i386__)    || \
           defined(_M_IX86)) &amp;&amp; defined(OPENSSL_IA32_SSE2))|| \
         defined(__x86_64)       || defined(__x86_64__)  || \
</PRE>

























































































































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024893.html">[openssl]  OpenSSL_1_1_1-stable update
</A></li>
	<LI>Next message: <A HREF="024901.html">[openssl]  OpenSSL_1_1_1-stable update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24897">[ date ]</a>
              <a href="thread.html#24897">[ thread ]</a>
              <a href="subject.html#24897">[ subject ]</a>
              <a href="author.html#24897">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
