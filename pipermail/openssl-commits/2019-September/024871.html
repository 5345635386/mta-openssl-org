<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-September/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1567762643.844889.16294.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="024869.html">
   <LINK REL="Next"  HREF="024877.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Dr. Paul Dale</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1567762643.844889.16294.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">pauli at openssl.org
       </A><BR>
    <I>Fri Sep  6 09:37:23 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="024869.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="024877.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24871">[ date ]</a>
              <a href="thread.html#24871">[ thread ]</a>
              <a href="subject.html#24871">[ subject ]</a>
              <a href="author.html#24871">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  c7bfb138acf6103ae6fd178eb212b110bfb39c0d (commit)
       via  ad1700c706517704e0ba2204ed317a365099cbef (commit)
       via  d4496dc129363153f3d887ab8d2b0c01d3f93f0e (commit)
       via  f575bd2af73e19b8f317a2a857ba6d1eb0ca0c14 (commit)
       via  232ac89ce20ee7fa466680d0da9e2514b23f7ca8 (commit)
       via  65ce7e65531942fe9d55c12496b843d3db3bb2d3 (commit)
       via  b4dca02940ce040305a9ca95896ccb65f43ec29c (commit)
       via  ccd7115a4158a34008975ae83c3a733ba0be9911 (commit)
       via  53598b22987faead115463bf8bd027cd8f794cf3 (commit)
       via  ea643c959f626fd3860b8aa49b42fd0b96e71492 (commit)
       via  ff756eedb3b28964ac8e7a7825198ac1b26dfb98 (commit)
       via  b1f15129933fdc98134ef2fcafb1ecea710f5920 (commit)
       via  df2f8af4cb3e19fe5a1ed41582d1659aa6c4ef50 (commit)
       via  a941920514995b520e7666897347fdcdcb5bf358 (commit)
       via  6d1c31540fa9453e6e31d4008c3b5ed18f7532ae (commit)
       via  1f9eac279b9f70adc63437db84f0f986933c5792 (commit)
       via  185ce3d93e25effe3c8f8992339c177ea4883d4f (commit)
       via  9d8e1569aa2adee724497ab016c5086ccbccad33 (commit)
       via  d6c5d7f3de5e56f467631ee2e4866cf8a523bc02 (commit)
       via  59cba5ac8591dba5113fb674ad001d45450e59d1 (commit)
       via  a308acb2c2809cb9ac30e8e987b2bdfb21f096e0 (commit)
       via  fe6ec26b204a056aee2a24b79df09a45b2308603 (commit)
       via  37ed62107112d95f7b7c9bf75602a6ac40883a89 (commit)
       via  fb9e6dd6f8b1de99c880ff3b458d6bc0dec907bb (commit)
       via  55accfd2f11d02cf4cfdc6077216ae59f1748f6a (commit)
       via  f05b53a36821e8d34c094e0435e1625f32ae7102 (commit)
       via  2f7557016c8fa9a8ad2d0ba7d7b927a189d0369e (commit)
       via  bf5739a0263ced7c70d94fbd73e8a840dabaf077 (commit)
       via  492939e5ef67441e87c66de2b13c79ba03f0fc5b (commit)
       via  e3405a4a9a5334cd636940a547a25c09ffc76009 (commit)
       via  7707526b8dfa8063c4537c11199c15ad7a3cab1c (commit)
       via  b50ca330cb02cad70bfb11401c47074e8e7d8a48 (commit)
       via  ce3b1bb481d0e079c6f06963e91c285c7cbdb4df (commit)
       via  5eb43d382b3eb3fb6950cc8e0dce82886e23e984 (commit)
      from  dc5bcb88d819de55eb37460c122e02fec91c6d86 (commit)


- Log -----------------------------------------------------------------
commit c7bfb138acf6103ae6fd178eb212b110bfb39c0d
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Thu Sep 5 08:11:48 2019 +1000

    libcrypto.num entries for KDFs
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit ad1700c706517704e0ba2204ed317a365099cbef
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Tue Sep 3 14:30:53 2019 +1000

    Move OSSL_OP_KDF into its rightful place amongst the other OSSL_OP_ definitions
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit d4496dc129363153f3d887ab8d2b0c01d3f93f0e
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Tue Sep 3 14:29:46 2019 +1000

    Remove reference to legacy aliases for MAC and KDF
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit f575bd2af73e19b8f317a2a857ba6d1eb0ca0c14
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Tue Sep 3 14:28:47 2019 +1000

    Clear collected_seed after freeing it
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 232ac89ce20ee7fa466680d0da9e2514b23f7ca8
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Tue Sep 3 14:26:19 2019 +1000

    Lowercase command line 'N' argument since params have lower case names
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 65ce7e65531942fe9d55c12496b843d3db3bb2d3
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Mon Sep 2 14:23:50 2019 +1000

    Update KDF documentation (section 3)
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit b4dca02940ce040305a9ca95896ccb65f43ec29c
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Mon Sep 2 13:58:42 2019 +1000

    Update KDF documentation (section 1)
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit ccd7115a4158a34008975ae83c3a733ba0be9911
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Mon Sep 2 13:58:22 2019 +1000

    Update KDF documentation (section 7)
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 53598b22987faead115463bf8bd027cd8f794cf3
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Aug 30 16:54:47 2019 +0200

    Deal with BUF_MEM_grow ambiguity
    
    BUF_MEM_grow() returns the passed length, but also zero on error.  If
    the passed length was zero, an extra check to see if a returned zero
    was an error or not is needed.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit ea643c959f626fd3860b8aa49b42fd0b96e71492
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Aug 30 16:34:27 2019 +0200

    crypto/evp/pkey_kdf.c: further special treatment of &quot;seed&quot; and &quot;info&quot;
    
    pkey_kdf_ctrl_str() has to do the same kind of special treatment as
    pkey_kdf_ctrl() does.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit ff756eedb3b28964ac8e7a7825198ac1b26dfb98
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Aug 30 15:36:20 2019 +0200

    More KDF cleanup
    
    The EVP_KDF_ definitions are no longer needed, and neither is
    EVP_get_kdfbyname()
    
    test/evp_kdf_test.c tried to use a EVP_get_kdfbyname() that was rewritten
    to use EVP_KDF_fetch() without ever freeing the resulting KDF method.
    It's better to refactor the test to use EVP_KDF_fetch directly.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit b1f15129933fdc98134ef2fcafb1ecea710f5920
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Aug 30 15:11:08 2019 +0200

    PBKDF2 implementation: refactor to avoid memleak
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit df2f8af4cb3e19fe5a1ed41582d1659aa6c4ef50
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Aug 30 14:35:43 2019 +0200

    Fix memleaks in KDF implementations
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit a941920514995b520e7666897347fdcdcb5bf358
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Aug 30 14:32:55 2019 +0200

    crypto/evp/pkey_kdf.c: Redo parameter processing
    
    Undo the caching scheme, pass through most controls as parameters, except
    for SEED and INFO, where we keep supporting adding data through additional
    ctrl calls by collecting the data, and only passing it to the EVP_KDF
    before calling its derive function.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 6d1c31540fa9453e6e31d4008c3b5ed18f7532ae
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Aug 30 14:32:33 2019 +0200

    crypto/evp/kdf_meth.c: Add the reset function to the method
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 1f9eac279b9f70adc63437db84f0f986933c5792
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Thu Aug 29 15:07:55 2019 +1000

    Update private.num for KDFs/PRFs
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 185ce3d93e25effe3c8f8992339c177ea4883d4f
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Thu Aug 29 13:02:54 2019 +1000

    ossl_provider_library_context(NULL) returns NULL.
    
    This will only be required until everything is moved to providers and a NULL
    provider pointer won't be possible.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 9d8e1569aa2adee724497ab016c5086ccbccad33
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Tue Aug 27 15:48:39 2019 +1000

    Params from text to allow zero length value fields
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit d6c5d7f3de5e56f467631ee2e4866cf8a523bc02
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Tue Aug 27 15:23:09 2019 +1000

    Update EVP test data for KDFs and PRFs.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 59cba5ac8591dba5113fb674ad001d45450e59d1
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Sat Aug 24 20:14:51 2019 +1000

    KDF error codes reworked
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit a308acb2c2809cb9ac30e8e987b2bdfb21f096e0
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Sat Aug 24 19:50:46 2019 +1000

    Cleanse KDF missing crypto files
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit fe6ec26b204a056aee2a24b79df09a45b2308603
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Sat Aug 24 19:50:21 2019 +1000

    Cleanse KDF error files
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 37ed62107112d95f7b7c9bf75602a6ac40883a89
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Sat Aug 24 19:49:46 2019 +1000

    Cleanse crypto/kdf directory
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit fb9e6dd6f8b1de99c880ff3b458d6bc0dec907bb
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 18:54:35 2019 +1000

    KDF/PRF updates to libcrypto
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 55accfd2f11d02cf4cfdc6077216ae59f1748f6a
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 18:53:45 2019 +1000

    App updates for KDF provider conversion.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit f05b53a36821e8d34c094e0435e1625f32ae7102
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 18:53:07 2019 +1000

    KDF provider conversion error updates - generated
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 2f7557016c8fa9a8ad2d0ba7d7b927a189d0369e
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 18:52:32 2019 +1000

    KDF additons to names and numbers
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit bf5739a0263ced7c70d94fbd73e8a840dabaf077
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 18:52:04 2019 +1000

    Test updates in light of the KDF switchover
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 492939e5ef67441e87c66de2b13c79ba03f0fc5b
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 18:51:34 2019 +1000

    Documentation updates in light of the KDF conversion
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit e3405a4a9a5334cd636940a547a25c09ffc76009
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 13:09:10 2019 +1000

    Add KDFs to providers
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 7707526b8dfa8063c4537c11199c15ad7a3cab1c
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 08:06:29 2019 +1000

    Fix users of KDFs to use params not ctls
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit b50ca330cb02cad70bfb11401c47074e8e7d8a48
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 08:04:27 2019 +1000

    Remove old KDF initialisation
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit ce3b1bb481d0e079c6f06963e91c285c7cbdb4df
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 08:01:08 2019 +1000

    Fix TLS/SSL PRF usages.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

commit 5eb43d382b3eb3fb6950cc8e0dce82886e23e984
Author: Pauli &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
Date:   Wed Aug 21 08:00:12 2019 +1000

    Move KDFs to the provider.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/9662">https://github.com/openssl/openssl/pull/9662</A>)

-----------------------------------------------------------------------

Summary of changes:
 apps/kdf.c                                         |  49 ++-
 apps/list.c                                        |  61 +++-
 crypto/build.info                                  |   2 +-
 crypto/dh/dh_kdf.c                                 |  32 +-
 crypto/ec/ec_err.c                                 |   2 +
 crypto/ec/ecdh_kdf.c                               |  28 +-
 crypto/err/err.c                                   |   1 -
 crypto/err/err_all.c                               |   2 -
 crypto/err/openssl.txt                             |  84 ++---
 crypto/evp/build.info                              |   6 +-
 crypto/evp/c_allkdf.c                              |  27 --
 crypto/evp/evp_locl.h                              |   4 +-
 crypto/evp/kdf_lib.c                               | 140 +++++---
 crypto/evp/kdf_meth.c                              | 197 ++++++++++
 crypto/evp/names.c                                 |  29 --
 crypto/evp/p5_crpt2.c                              |  26 +-
 crypto/evp/pbe_scrypt.c                            |  25 +-
 crypto/evp/pkey_kdf.c                              | 264 +++++++++++---
 crypto/include/internal/evp_int.h                  |  37 +-
 crypto/init.c                                      |  29 --
 crypto/kdf/build.info                              |   4 -
 crypto/kdf/kdf_err.c                               |  63 ----
 crypto/kdf/kdf_local.h                             |  22 --
 crypto/kdf/kdf_util.c                              |  73 ----
 crypto/kdf/pbkdf2.c                                | 324 -----------------
 crypto/kdf/sshkdf.c                                | 292 ---------------
 crypto/params_from_text.c                          |  85 ++---
 crypto/provider_core.c                             |   3 +-
 doc/man1/openssl-kdf.pod                           |  14 +-
 doc/man1/openssl-list.pod                          |  10 +-
 doc/man3/EVP_KDF.pod                               | 259 ++++++++++++++
 doc/man3/EVP_KDF_CTX.pod                           | 296 ---------------
 doc/man7/EVP_KDF-HKDF.pod                          | 154 ++++++++
 .../{EVP_KDF_PBKDF2.pod =&gt; EVP_KDF-PBKDF2.pod}     |  47 ++-
 .../{EVP_KDF_SCRYPT.pod =&gt; EVP_KDF-SCRYPT.pod}     |  91 +++--
 doc/man7/EVP_KDF-SS.pod                            | 197 ++++++++++
 .../{EVP_KDF_SSHKDF.pod =&gt; EVP_KDF-SSHKDF.pod}     | 116 +++---
 doc/man7/EVP_KDF-TLS1_PRF.pod                      | 113 ++++++
 doc/man7/EVP_KDF-X942.pod                          | 122 +++++++
 doc/man7/EVP_KDF-X963.pod                          | 111 ++++++
 doc/man7/EVP_KDF_HKDF.pod                          | 180 ----------
 doc/man7/EVP_KDF_SS.pod                            | 222 ------------
 doc/man7/EVP_KDF_TLS1_PRF.pod                      | 146 --------
 doc/man7/EVP_KDF_X942.pod                          | 150 --------
 doc/man7/EVP_KDF_X963.pod                          | 136 -------
 include/openssl/core_names.h                       |  25 ++
 include/openssl/core_numbers.h                     |  30 ++
 include/openssl/crypto.h                           |   4 +-
 include/openssl/ecerr.h                            |  10 +
 include/openssl/err.h                              |  14 +-
 include/openssl/evperr.h                           |   4 +-
 include/openssl/kdf.h                              |  73 ++--
 include/openssl/kdferr.h                           | 107 ------
 providers/common/build.info                        |   2 +-
 providers/common/include/internal/provider_algs.h  |  37 +-
 .../common/include/internal/providercommonerr.h    |  26 ++
 providers/common/kdfs/build.info                   |  13 +
 {crypto/kdf =&gt; providers/common/kdfs}/hkdf.c       | 351 ++++++++++--------
 providers/common/kdfs/pbkdf2.c                     | 355 ++++++++++++++++++
 {crypto/kdf =&gt; providers/common/kdfs}/sskdf.c      | 395 +++++++++++----------
 {crypto/kdf =&gt; providers/common/kdfs}/tls1_prf.c   | 279 +++++++++------
 providers/common/provider_err.c                    |  36 ++
 providers/default/build.info                       |   1 +
 providers/default/defltprov.c                      |  18 +
 providers/default/kdfs/build.info                  |   3 +
 {crypto/kdf =&gt; providers/default/kdfs}/scrypt.c    | 335 ++++++++---------
 providers/default/kdfs/sshkdf.c                    | 297 ++++++++++++++++
 {crypto/kdf =&gt; providers/default/kdfs}/x942kdf.c   | 285 ++++++++-------
 providers/fips/fipsprov.c                          |  15 +-
 ssl/t1_enc.c                                       |  61 ++--
 ssl/tls13_enc.c                                    |  52 ++-
 test/evp_kdf_test.c                                | 354 +++++++++++-------
 test/evp_test.c                                    |  57 +--
 test/recipes/20-test_kdf.t                         |   2 +-
 test/recipes/30-test_evp_data/evpkdf.txt           |  26 +-
 util/libcrypto.num                                 |  20 +-
 util/missingcrypto.txt                             |   1 -
 util/missingcrypto111.txt                          |   1 -
 util/private.num                                   |   2 -
 79 files changed, 3948 insertions(+), 3618 deletions(-)
 delete mode 100644 crypto/evp/c_allkdf.c
 create mode 100644 crypto/evp/kdf_meth.c
 delete mode 100644 crypto/kdf/build.info
 delete mode 100644 crypto/kdf/kdf_err.c
 delete mode 100644 crypto/kdf/kdf_local.h
 delete mode 100644 crypto/kdf/kdf_util.c
 delete mode 100644 crypto/kdf/pbkdf2.c
 delete mode 100644 crypto/kdf/sshkdf.c
 create mode 100644 doc/man3/EVP_KDF.pod
 delete mode 100644 doc/man3/EVP_KDF_CTX.pod
 create mode 100644 doc/man7/EVP_KDF-HKDF.pod
 rename doc/man7/{EVP_KDF_PBKDF2.pod =&gt; EVP_KDF-PBKDF2.pod} (63%)
 rename doc/man7/{EVP_KDF_SCRYPT.pod =&gt; EVP_KDF-SCRYPT.pod} (61%)
 create mode 100644 doc/man7/EVP_KDF-SS.pod
 rename doc/man7/{EVP_KDF_SSHKDF.pod =&gt; EVP_KDF-SSHKDF.pod} (51%)
 create mode 100644 doc/man7/EVP_KDF-TLS1_PRF.pod
 create mode 100644 doc/man7/EVP_KDF-X942.pod
 create mode 100644 doc/man7/EVP_KDF-X963.pod
 delete mode 100644 doc/man7/EVP_KDF_HKDF.pod
 delete mode 100644 doc/man7/EVP_KDF_SS.pod
 delete mode 100644 doc/man7/EVP_KDF_TLS1_PRF.pod
 delete mode 100644 doc/man7/EVP_KDF_X942.pod
 delete mode 100644 doc/man7/EVP_KDF_X963.pod
 delete mode 100644 include/openssl/kdferr.h
 create mode 100644 providers/common/kdfs/build.info
 rename {crypto/kdf =&gt; providers/common/kdfs}/hkdf.c (50%)
 create mode 100644 providers/common/kdfs/pbkdf2.c
 rename {crypto/kdf =&gt; providers/common/kdfs}/sskdf.c (58%)
 rename {crypto/kdf =&gt; providers/common/kdfs}/tls1_prf.c (57%)
 create mode 100644 providers/default/kdfs/build.info
 rename {crypto/kdf =&gt; providers/default/kdfs}/scrypt.c (56%)
 create mode 100644 providers/default/kdfs/sshkdf.c
 rename {crypto/kdf =&gt; providers/default/kdfs}/x942kdf.c (57%)

diff --git a/apps/kdf.c b/apps/kdf.c
index 684fd44cc0..c230430697 100644
--- a/apps/kdf.c
+++ b/apps/kdf.c
@@ -15,6 +15,7 @@
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/kdf.h&gt;
+#include &lt;openssl/params.h&gt;
 
 typedef enum OPTION_choice {
     OPT_ERR = -1, OPT_EOF = 0, OPT_HELP,
@@ -34,27 +35,9 @@ const OPTIONS kdf_options[] = {
     {NULL}
 };
 
-static int kdf_ctrl_string(EVP_KDF_CTX *ctx, const char *value)
-{
-    int rv;
-    char *stmp, *vtmp = NULL;
-
-    stmp = OPENSSL_strdup(value);
-    if (stmp == NULL)
-        return -1;
-    vtmp = strchr(stmp, ':');
-    if (vtmp != NULL) {
-        *vtmp = 0;
-        vtmp++;
-    }
-    rv = EVP_KDF_ctrl_str(ctx, stmp, vtmp);
-    OPENSSL_free(stmp);
-    return rv;
-}
-
 int kdf_main(int argc, char **argv)
 {
-    int ret = 1, i, id, out_bin = 0;
+    int ret = 1, out_bin = 0;
     OPTION_CHOICE o;
     STACK_OF(OPENSSL_STRING) *opts = NULL;
     char *prog, *hexout = NULL;
@@ -62,6 +45,7 @@ int kdf_main(int argc, char **argv)
     unsigned char *dkm_bytes = NULL;
     size_t dkm_len = 0;
     BIO *out = NULL;
+    EVP_KDF *kdf = NULL;
     EVP_KDF_CTX *ctx = NULL;
 
     prog = opt_init(argc, argv, kdf_options);
@@ -100,25 +84,31 @@ opthelp:
         goto opthelp;
     }
 
-    id = OBJ_sn2nid(argv[0]);
-    if (id == NID_undef) {
+    if ((kdf = EVP_KDF_fetch(NULL, argv[0], NULL)) == NULL) {
         BIO_printf(bio_err, &quot;Invalid KDF name %s\n&quot;, argv[0]);
         goto opthelp;
     }
 
-    ctx = EVP_KDF_CTX_new_id(id);
+    ctx = EVP_KDF_CTX_new(kdf);
     if (ctx == NULL)
         goto err;
 
     if (opts != NULL) {
-        for (i = 0; i &lt; sk_OPENSSL_STRING_num(opts); i++) {
-            char *opt = sk_OPENSSL_STRING_value(opts, i);
-            if (kdf_ctrl_string(ctx, opt) &lt;= 0) {
-                BIO_printf(bio_err, &quot;KDF parameter error '%s'\n&quot;, opt);
-                ERR_print_errors(bio_err);
-                goto err;
-            }
+        int ok = 1;
+        OSSL_PARAM *params =
+            app_params_new_from_opts(opts, EVP_KDF_CTX_settable_params(kdf));
+
+        if (params == NULL)
+            goto err;
+
+        if (!EVP_KDF_CTX_set_params(ctx, params)) {
+            BIO_printf(bio_err, &quot;KDF parameter error\n&quot;);
+            ERR_print_errors(bio_err);
+            ok = 0;
         }
+        app_params_free(params);
+        if (!ok)
+            goto err;
     }
 
     out = bio_open_default(outfile, 'w', out_bin ? FORMAT_BINARY : FORMAT_TEXT);
@@ -151,6 +141,7 @@ err:
         ERR_print_errors(bio_err);
     OPENSSL_clear_free(dkm_bytes, dkm_len);
     sk_OPENSSL_STRING_free(opts);
+    EVP_KDF_free(kdf);
     EVP_KDF_CTX_free(ctx);
     BIO_free(out);
     OPENSSL_free(hexout);
diff --git a/apps/list.c b/apps/list.c
index 3e34228d1e..2b44cac71b 100644
--- a/apps/list.c
+++ b/apps/list.c
@@ -12,6 +12,7 @@
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/provider.h&gt;
 #include &lt;openssl/safestack.h&gt;
+#include &lt;openssl/kdf.h&gt;
 #include &quot;apps.h&quot;
 #include &quot;app_params.h&quot;
 #include &quot;progs.h&quot;
@@ -193,6 +194,56 @@ static void list_macs(void)
     sk_EVP_MAC_pop_free(macs, EVP_MAC_free);
 }
 
+/*
+ * KDFs and PRFs
+ */
+DEFINE_STACK_OF(EVP_KDF)
+static int kdf_cmp(const EVP_KDF * const *a, const EVP_KDF * const *b)
+{
+    int ret = strcasecmp(EVP_KDF_name(*a), EVP_KDF_name(*b));
+
+    if (ret == 0)
+        ret = strcmp(OSSL_PROVIDER_name(EVP_KDF_provider(*a)),
+                     OSSL_PROVIDER_name(EVP_KDF_provider(*b)));
+
+    return ret;
+}
+
+static void collect_kdfs(EVP_KDF *kdf, void *stack)
+{
+    STACK_OF(EVP_KDF) *kdf_stack = stack;
+
+    sk_EVP_KDF_push(kdf_stack, kdf);
+    EVP_KDF_up_ref(kdf);
+}
+
+static void list_kdfs(void)
+{
+    STACK_OF(EVP_KDF) *kdfs = sk_EVP_KDF_new(kdf_cmp);
+    int i;
+
+    BIO_printf(bio_out, &quot;Provided KDFs and PDFs:\n&quot;);
+    EVP_KDF_do_all_ex(NULL, collect_kdfs, kdfs);
+    sk_EVP_KDF_sort(kdfs);
+    for (i = 0; i &lt; sk_EVP_KDF_num(kdfs); i++) {
+        const EVP_KDF *m = sk_EVP_KDF_value(kdfs, i);
+
+        BIO_printf(bio_out, &quot;  %s&quot;, EVP_KDF_name(m));
+        BIO_printf(bio_out, &quot; @ %s\n&quot;,
+                   OSSL_PROVIDER_name(EVP_KDF_provider(m)));
+
+        if (verbose) {
+            print_param_types(&quot;retrievable algorithm parameters&quot;,
+                              EVP_KDF_gettable_params(m), 4);
+            print_param_types(&quot;retrievable operation parameters&quot;,
+                              EVP_KDF_CTX_gettable_params(m), 4);
+            print_param_types(&quot;settable operation parameters&quot;,
+                              EVP_KDF_CTX_settable_params(m), 4);
+        }
+    }
+    sk_EVP_KDF_pop_free(kdfs, EVP_KDF_free);
+}
+
 static void list_missing_help(void)
 {
     const FUNCTION *fp;
@@ -527,7 +578,7 @@ typedef enum HELPLIST_CHOICE {
     OPT_COMMANDS, OPT_DIGEST_COMMANDS, OPT_MAC_ALGORITHMS, OPT_OPTIONS,
     OPT_DIGEST_ALGORITHMS, OPT_CIPHER_COMMANDS, OPT_CIPHER_ALGORITHMS,
     OPT_PK_ALGORITHMS, OPT_PK_METHOD, OPT_ENGINES, OPT_DISABLED,
-    OPT_MISSING_HELP, OPT_OBJECTS
+    OPT_KDF_ALGORITHMS, OPT_MISSING_HELP, OPT_OBJECTS
 } HELPLIST_CHOICE;
 
 const OPTIONS list_options[] = {
@@ -539,6 +590,8 @@ const OPTIONS list_options[] = {
      &quot;List of message digest commands&quot;},
     {&quot;digest-algorithms&quot;, OPT_DIGEST_ALGORITHMS, '-',
      &quot;List of message digest algorithms&quot;},
+    {&quot;kdf-algorithms&quot;, OPT_KDF_ALGORITHMS, '-',
+     &quot;List of key derivation and pseudo random function algorithms&quot;},
     {&quot;mac-algorithms&quot;, OPT_MAC_ALGORITHMS, '-',
      &quot;List of message authentication code algorithms&quot;},
     {&quot;cipher-commands&quot;, OPT_CIPHER_COMMANDS, '-', &quot;List of cipher commands&quot;},
@@ -570,6 +623,7 @@ int list_main(int argc, char **argv)
         unsigned int commands:1;
         unsigned int digest_commands:1;
         unsigned int digest_algorithms:1;
+        unsigned int kdf_algorithms:1;
         unsigned int mac_algorithms:1;
         unsigned int cipher_commands:1;
         unsigned int cipher_algorithms:1;
@@ -607,6 +661,9 @@ opthelp:
         case OPT_DIGEST_ALGORITHMS:
             todo.digest_algorithms = 1;
             break;
+        case OPT_KDF_ALGORITHMS:
+            todo.kdf_algorithms = 1;
+            break;
         case OPT_MAC_ALGORITHMS:
             todo.mac_algorithms = 1;
             break;
@@ -654,6 +711,8 @@ opthelp:
         list_type(FT_md, one);
     if (todo.digest_algorithms)
         list_digests();
+    if (todo.kdf_algorithms)
+        list_kdfs();
     if (todo.mac_algorithms)
         list_macs();
     if (todo.cipher_commands)
diff --git a/crypto/build.info b/crypto/build.info
index 96e265ff40..961bfd6f60 100644
--- a/crypto/build.info
+++ b/crypto/build.info
@@ -1,7 +1,7 @@
 # Note that these directories are filtered in Configure.  Look for %skipdir
 # there for further explanations.
 SUBDIRS=objects buffer bio stack lhash rand evp asn1 pem x509 conf \
-        txt_db pkcs7 pkcs12 ui kdf store property \
+        txt_db pkcs7 pkcs12 ui store property \
         md2 md4 md5 sha mdc2 hmac ripemd whrlpool poly1305 blake2 \
         siphash sm3 des aes rc2 rc4 rc5 idea aria bf cast camellia \
         seed sm4 chacha modes bn ec rsa dsa dh sm2 dso engine \
diff --git a/crypto/dh/dh_kdf.c b/crypto/dh/dh_kdf.c
index 03b1e4edd5..781d34a94f 100644
--- a/crypto/dh/dh_kdf.c
+++ b/crypto/dh/dh_kdf.c
@@ -11,10 +11,12 @@
 
 #ifndef OPENSSL_NO_CMS
 # include &lt;string.h&gt;
+# include &lt;openssl/core_names.h&gt;
 # include &lt;openssl/dh.h&gt;
 # include &lt;openssl/evp.h&gt;
 # include &lt;openssl/asn1.h&gt;
 # include &lt;openssl/kdf.h&gt;
+# include &lt;internal/provider.h&gt;
 
 int DH_KDF_X9_42(unsigned char *out, size_t outlen,
                  const unsigned char *Z, size_t Zlen,
@@ -23,8 +25,12 @@ int DH_KDF_X9_42(unsigned char *out, size_t outlen,
 {
     int ret = 0, nid;
     EVP_KDF_CTX *kctx = NULL;
-    const EVP_KDF *kdf = NULL;
+    EVP_KDF *kdf = NULL;
     const char *oid_sn;
+    OSSL_PARAM params[5], *p = params;
+    const char *mdname = EVP_MD_name(md);
+    const OSSL_PROVIDER *prov = EVP_MD_provider(md);
+    OPENSSL_CTX *provctx = ossl_provider_library_context(prov);
 
     nid = OBJ_obj2nid(key_oid);
     if (nid == NID_undef)
@@ -33,20 +39,24 @@ int DH_KDF_X9_42(unsigned char *out, size_t outlen,
     if (oid_sn == NULL)
         return 0;
 
-    kdf = EVP_get_kdfbyname(SN_x942kdf);
-    if (kdf == NULL)
+    kdf = EVP_KDF_fetch(provctx, SN_x942kdf, NULL);
+    if ((kctx = EVP_KDF_CTX_new(kdf)) == NULL)
         goto err;
-    kctx = EVP_KDF_CTX_new(kdf);
-    ret =
-        kctx != NULL
-        &amp;&amp; EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, md) &gt; 0
-        &amp;&amp; EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, Z, Zlen) &gt; 0
-        &amp;&amp; (ukm == NULL
-            || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_UKM, ukm, ukmlen) &gt; 0)
-        &amp;&amp; EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_CEK_ALG, oid_sn) &gt; 0
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)mdname, strlen(mdname) + 1);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
+                                             (unsigned char *)Z, Zlen);
+    if (ukm != NULL)
+        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_UKM,
+                                                 (unsigned char *)ukm, ukmlen);
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_CEK_ALG,
+                                            (char *)oid_sn, strlen(oid_sn) + 1);
+    *p = OSSL_PARAM_construct_end();
+    ret = EVP_KDF_CTX_set_params(kctx, params) &gt; 0
         &amp;&amp; EVP_KDF_derive(kctx, out, outlen) &gt; 0;
 err:
     EVP_KDF_CTX_free(kctx);
+    EVP_KDF_free(kdf);
     return ret;
 }
 #endif /* OPENSSL_NO_CMS */
diff --git a/crypto/ec/ec_err.c b/crypto/ec/ec_err.c
index d2fee0597f..566b40f13d 100644
--- a/crypto/ec/ec_err.c
+++ b/crypto/ec/ec_err.c
@@ -23,6 +23,8 @@ static const ERR_STRING_DATA EC_str_reasons[] = {
     &quot;coordinates out of range&quot;},
     {ERR_PACK(ERR_LIB_EC, 0, EC_R_CURVE_DOES_NOT_SUPPORT_ECDH),
     &quot;curve does not support ecdh&quot;},
+    {ERR_PACK(ERR_LIB_EC, 0, EC_R_CURVE_DOES_NOT_SUPPORT_ECDSA),
+    &quot;curve does not support ecdsa&quot;},
     {ERR_PACK(ERR_LIB_EC, 0, EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING),
     &quot;curve does not support signing&quot;},
     {ERR_PACK(ERR_LIB_EC, 0, EC_R_D2I_ECPKPARAMETERS_FAILURE),
diff --git a/crypto/ec/ecdh_kdf.c b/crypto/ec/ecdh_kdf.c
index f556dc66a0..55e676d20a 100644
--- a/crypto/ec/ecdh_kdf.c
+++ b/crypto/ec/ecdh_kdf.c
@@ -8,6 +8,7 @@
  */
 
 #include &lt;string.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &lt;openssl/ec.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/kdf.h&gt;
@@ -19,18 +20,27 @@ int ecdh_KDF_X9_63(unsigned char *out, size_t outlen,
                    const unsigned char *sinfo, size_t sinfolen,
                    const EVP_MD *md)
 {
-    int ret;
+    int ret = 0;
     EVP_KDF_CTX *kctx = NULL;
+    OSSL_PARAM params[4], *p = params;
+    const char *mdname = EVP_MD_name(md);
+    EVP_KDF *kdf = EVP_KDF_fetch(NULL, SN_x963kdf, NULL);
 
-    kctx = EVP_KDF_CTX_new(EVP_get_kdfbyname(SN_x963kdf));
-    ret =
-        kctx != NULL
-        &amp;&amp; EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, md) &gt; 0
-        &amp;&amp; EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, Z, Zlen) &gt; 0
-        &amp;&amp; EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SHARED_INFO, sinfo, sinfolen) &gt; 0
-        &amp;&amp; EVP_KDF_derive(kctx, out, outlen) &gt; 0;
+    if ((kctx = EVP_KDF_CTX_new(kdf)) != NULL) {
+        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                                (char *)mdname,
+                                                strlen(mdname) + 1);
+        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
+                                                 (void *)Z, Zlen);
+        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+                                                 (void *)sinfo, sinfolen);
+        *p = OSSL_PARAM_construct_end();
 
-    EVP_KDF_CTX_free(kctx);
+        ret = EVP_KDF_CTX_set_params(kctx, params) &gt; 0
+            &amp;&amp; EVP_KDF_derive(kctx, out, outlen) &gt; 0;
+        EVP_KDF_CTX_free(kctx);
+    }
+    EVP_KDF_free(kdf);
     return ret;
 }
 
diff --git a/crypto/err/err.c b/crypto/err/err.c
index daa4e6e419..25ab13509c 100644
--- a/crypto/err/err.c
+++ b/crypto/err/err.c
@@ -64,7 +64,6 @@ static ERR_STRING_DATA ERR_str_libraries[] = {
     {ERR_PACK(ERR_LIB_HMAC, 0, 0), &quot;HMAC routines&quot;},
     {ERR_PACK(ERR_LIB_CT, 0, 0), &quot;CT routines&quot;},
     {ERR_PACK(ERR_LIB_ASYNC, 0, 0), &quot;ASYNC routines&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, 0), &quot;KDF routines&quot;},
     {ERR_PACK(ERR_LIB_OSSL_STORE, 0, 0), &quot;STORE routines&quot;},
     {ERR_PACK(ERR_LIB_SM2, 0, 0), &quot;SM2 routines&quot;},
     {ERR_PACK(ERR_LIB_ESS, 0, 0), &quot;ESS routines&quot;},
diff --git a/crypto/err/err_all.c b/crypto/err/err_all.c
index 8962fe5cb2..972421f402 100644
--- a/crypto/err/err_all.c
+++ b/crypto/err/err_all.c
@@ -38,7 +38,6 @@
 #include &lt;openssl/cmperr.h&gt;
 #include &lt;openssl/cterr.h&gt;
 #include &lt;openssl/asyncerr.h&gt;
-#include &lt;openssl/kdferr.h&gt;
 #include &lt;openssl/storeerr.h&gt;
 #include &lt;openssl/esserr.h&gt;
 #include &quot;internal/propertyerr.h&quot;
@@ -103,7 +102,6 @@ int err_load_crypto_strings_int(void)
         ERR_load_ESS_strings() == 0 ||
         ERR_load_ASYNC_strings() == 0 ||
 #endif
-        ERR_load_KDF_strings() == 0 ||
         ERR_load_OSSL_STORE_strings() == 0 ||
         ERR_load_PROP_strings() == 0 ||
         ERR_load_PROV_strings() == 0)
diff --git a/crypto/err/openssl.txt b/crypto/err/openssl.txt
index 9b682d5084..f74659c599 100644
--- a/crypto/err/openssl.txt
+++ b/crypto/err/openssl.txt
@@ -825,10 +825,8 @@ EVP_F_EVP_DIGESTUPDATE:231:EVP_DigestUpdate
 EVP_F_EVP_ENCRYPTDECRYPTUPDATE:219:evp_EncryptDecryptUpdate
 EVP_F_EVP_ENCRYPTFINAL_EX:127:EVP_EncryptFinal_ex
 EVP_F_EVP_ENCRYPTUPDATE:167:EVP_EncryptUpdate
-EVP_F_EVP_KDF_CTRL:224:EVP_KDF_ctrl
-EVP_F_EVP_KDF_CTRL_STR:225:EVP_KDF_ctrl_str
-EVP_F_EVP_KDF_CTX_NEW:240:EVP_KDF_CTX_new
-EVP_F_EVP_KDF_CTX_NEW_ID:226:EVP_KDF_CTX_new_id
+EVP_F_EVP_KDF_CTX_DUP:220:
+EVP_F_EVP_KDF_CTX_NEW:221:
 EVP_F_EVP_KEYEXCH_FETCH:245:EVP_KEYEXCH_fetch
 EVP_F_EVP_KEYEXCH_FROM_DISPATCH:244:evp_keyexch_from_dispatch
 EVP_F_EVP_MAC_CTRL:209:EVP_MAC_ctrl
@@ -916,53 +914,6 @@ EVP_F_S390X_AES_GCM_CTRL:201:s390x_aes_gcm_ctrl
 EVP_F_S390X_AES_GCM_TLS_CIPHER:208:s390x_aes_gcm_tls_cipher
 EVP_F_SCRYPT_ALG:228:scrypt_alg
 EVP_F_UPDATE:173:update
-KDF_F_HKDF_EXTRACT:112:HKDF_Extract
-KDF_F_KDF_HKDF_DERIVE:113:kdf_hkdf_derive
-KDF_F_KDF_HKDF_NEW:114:kdf_hkdf_new
-KDF_F_KDF_HKDF_SIZE:115:kdf_hkdf_size
-KDF_F_KDF_MD2CTRL:116:kdf_md2ctrl
-KDF_F_KDF_PBKDF2_CTRL:140:kdf_pbkdf2_ctrl
-KDF_F_KDF_PBKDF2_CTRL_STR:117:kdf_pbkdf2_ctrl_str
-KDF_F_KDF_PBKDF2_DERIVE:118:kdf_pbkdf2_derive
-KDF_F_KDF_PBKDF2_NEW:119:kdf_pbkdf2_new
-KDF_F_KDF_SCRYPT_CTRL_STR:120:kdf_scrypt_ctrl_str
-KDF_F_KDF_SCRYPT_CTRL_UINT32:121:kdf_scrypt_ctrl_uint32
-KDF_F_KDF_SCRYPT_CTRL_UINT64:122:kdf_scrypt_ctrl_uint64
-KDF_F_KDF_SCRYPT_DERIVE:123:kdf_scrypt_derive
-KDF_F_KDF_SCRYPT_NEW:124:kdf_scrypt_new
-KDF_F_KDF_SSHKDF_CTRL:130:kdf_sshkdf_ctrl
-KDF_F_KDF_SSHKDF_CTRL_STR:131:kdf_sshkdf_ctrl_str
-KDF_F_KDF_SSHKDF_DERIVE:132:kdf_sshkdf_derive
-KDF_F_KDF_SSHKDF_NEW:133:kdf_sshkdf_new
-KDF_F_KDF_TLS1_PRF_CTRL_STR:125:kdf_tls1_prf_ctrl_str
-KDF_F_KDF_TLS1_PRF_DERIVE:126:kdf_tls1_prf_derive
-KDF_F_KDF_TLS1_PRF_NEW:127:kdf_tls1_prf_new
-KDF_F_PBKDF2_DERIVE:141:pbkdf2_derive
-KDF_F_PBKDF2_SET_MEMBUF:128:pbkdf2_set_membuf
-KDF_F_PKEY_HKDF_CTRL_STR:103:pkey_hkdf_ctrl_str
-KDF_F_PKEY_HKDF_DERIVE:102:pkey_hkdf_derive
-KDF_F_PKEY_HKDF_INIT:108:pkey_hkdf_init
-KDF_F_PKEY_SCRYPT_CTRL_STR:104:pkey_scrypt_ctrl_str
-KDF_F_PKEY_SCRYPT_CTRL_UINT64:105:pkey_scrypt_ctrl_uint64
-KDF_F_PKEY_SCRYPT_DERIVE:109:pkey_scrypt_derive
-KDF_F_PKEY_SCRYPT_INIT:106:pkey_scrypt_init
-KDF_F_PKEY_SCRYPT_SET_MEMBUF:107:pkey_scrypt_set_membuf
-KDF_F_PKEY_TLS1_PRF_CTRL_STR:100:pkey_tls1_prf_ctrl_str
-KDF_F_PKEY_TLS1_PRF_DERIVE:101:pkey_tls1_prf_derive
-KDF_F_PKEY_TLS1_PRF_INIT:110:pkey_tls1_prf_init
-KDF_F_SCRYPT_SET_MEMBUF:129:scrypt_set_membuf
-KDF_F_SSKDF_CTRL_STR:134:sskdf_ctrl_str
-KDF_F_SSKDF_DERIVE:135:sskdf_derive
-KDF_F_SSKDF_MAC2CTRL:136:sskdf_mac2ctrl
-KDF_F_SSKDF_NEW:137:sskdf_new
-KDF_F_SSKDF_SIZE:138:sskdf_size
-KDF_F_TLS1_PRF_ALG:111:tls1_prf_alg
-KDF_F_X942KDF_CTRL:142:x942kdf_ctrl
-KDF_F_X942KDF_DERIVE:143:x942kdf_derive
-KDF_F_X942KDF_HASH_KDM:144:x942kdf_hash_kdm
-KDF_F_X942KDF_NEW:145:x942kdf_new
-KDF_F_X942KDF_SIZE:146:x942kdf_size
-KDF_F_X963KDF_DERIVE:139:x963kdf_derive
 OBJ_F_OBJ_ADD_OBJECT:105:OBJ_add_object
 OBJ_F_OBJ_ADD_SIGID:107:OBJ_add_sigid
 OBJ_F_OBJ_CREATE:100:OBJ_create
@@ -2522,12 +2473,13 @@ EVP_R_XTS_DATA_UNIT_IS_TOO_LARGE:191:xts data unit is too large
 EVP_R_XTS_DUPLICATED_KEYS:192:xts duplicated keys
 KDF_R_BAD_ENCODING:122:bad encoding
 KDF_R_BAD_LENGTH:123:bad length
-KDF_R_INAVLID_UKM_LEN:124:inavlid ukm len
+KDF_R_BOTH_MODE_AND_MODE_INT:127:both mode and mode int
 KDF_R_INVALID_DIGEST:100:invalid digest
 KDF_R_INVALID_ITERATION_COUNT:119:invalid iteration count
 KDF_R_INVALID_KEY_LEN:120:invalid key len
 KDF_R_INVALID_MAC_TYPE:116:invalid mac type
-KDF_R_INVALID_SALT_LEN:121:invalid salt len
+KDF_R_INVALID_MODE:128:invalid mode
+KDF_R_INVALID_MODE_INT:129:invalid mode int
 KDF_R_MISSING_CEK_ALG:125:missing cek alg
 KDF_R_MISSING_ITERATION_COUNT:109:missing iteration count
 KDF_R_MISSING_KEY:104:missing key
@@ -2708,26 +2660,52 @@ PROP_R_STRING_TOO_LONG:109:string too long
 PROP_R_TRAILING_CHARACTERS:110:trailing characters
 PROV_R_AES_KEY_SETUP_FAILED:101:aes key setup failed
 PROV_R_BAD_DECRYPT:100:bad decrypt
+PROV_R_BAD_ENCODING:141:bad encoding
+PROV_R_BAD_LENGTH:142:bad length
+PROV_R_BOTH_MODE_AND_MODE_INT:127:both mode and mode int
 PROV_R_CIPHER_OPERATION_FAILED:102:cipher operation failed
 PROV_R_FAILED_TO_GENERATE_KEY:121:failed to generate key
 PROV_R_FAILED_TO_GET_PARAMETER:103:failed to get parameter
 PROV_R_FAILED_TO_SET_PARAMETER:104:failed to set parameter
+PROV_R_INAVLID_UKM_LENGTH:146:inavlid ukm length
 PROV_R_INVALID_AAD:108:invalid aad
 PROV_R_INVALID_CUSTOM_LENGTH:111:invalid custom length
 PROV_R_INVALID_DATA:115:invalid data
+PROV_R_INVALID_DIGEST:122:invalid digest
+PROV_R_INVALID_ITERATION_COUNT:123:invalid iteration count
 PROV_R_INVALID_IVLEN:116:invalid ivlen
 PROV_R_INVALID_IV_LENGTH:109:invalid iv length
 PROV_R_INVALID_KEYLEN:117:invalid keylen
+PROV_R_INVALID_KEY_LEN:124:invalid key len
 PROV_R_INVALID_KEY_LENGTH:105:invalid key length
+PROV_R_INVALID_MODE:125:invalid mode
+PROV_R_INVALID_MODE_INT:126:invalid mode int
 PROV_R_INVALID_SALT_LENGTH:112:invalid salt length
 PROV_R_INVALID_TAG:110:invalid tag
 PROV_R_INVALID_TAGLEN:118:invalid taglen
+PROV_R_MISSING_CEK_ALG:144:missing cek alg
+PROV_R_MISSING_KEY:128:missing key
+PROV_R_MISSING_MESSAGE_DIGEST:129:missing message digest
+PROV_R_MISSING_PASS:130:missing pass
+PROV_R_MISSING_SALT:131:missing salt
+PROV_R_MISSING_SECRET:132:missing secret
+PROV_R_MISSING_SEED:140:missing seed
+PROV_R_MISSING_SESSION_ID:133:missing session id
+PROV_R_MISSING_TYPE:134:missing type
+PROV_R_MISSING_XCGHASH:135:missing xcghash
+PROV_R_NOT_SUPPORTED:136:not supported
 PROV_R_NOT_XOF_OR_INVALID_LENGTH:113:not xof or invalid length
 PROV_R_NO_KEY_SET:114:no key set
 PROV_R_OUTPUT_BUFFER_TOO_SMALL:106:output buffer too small
 PROV_R_TAG_NOTSET:119:tag notset
 PROV_R_TAG_NOT_NEEDED:120:tag not needed
+PROV_R_UNABLE_TO_LOAD_SHA1:143:unable to load sha1
+PROV_R_UNABLE_TO_LOAD_SHA256:147:unable to load sha256
+PROV_R_UNSUPPORTED_CEK_ALG:145:unsupported cek alg
+PROV_R_UNSUPPORTED_MAC_TYPE:137:unsupported mac type
+PROV_R_VALUE_ERROR:138:value error
 PROV_R_WRONG_FINAL_BLOCK_LENGTH:107:wrong final block length
+PROV_R_WRONG_OUTPUT_BUFFER_SIZE:139:wrong output buffer size
 RAND_R_ADDITIONAL_INPUT_TOO_LONG:102:additional input too long
 RAND_R_ALREADY_INSTANTIATED:103:already instantiated
 RAND_R_ARGUMENT_OUT_OF_RANGE:105:argument out of range
diff --git a/crypto/evp/build.info b/crypto/evp/build.info
index 688e6fc94e..d9df71959c 100644
--- a/crypto/evp/build.info
+++ b/crypto/evp/build.info
@@ -1,6 +1,6 @@
 LIBS=../../libcrypto
 $COMMON=digest.c evp_enc.c evp_lib.c evp_fetch.c cmeth_lib.c evp_utils.c \
-        mac_lib.c mac_meth.c keymgmt_meth.c keymgmt_lib.c
+        mac_lib.c mac_meth.c keymgmt_meth.c keymgmt_lib.c kdf_lib.c kdf_meth.c
 SOURCE[../../libcrypto]=$COMMON\
         encode.c evp_key.c evp_cnf.c \
         e_des.c e_bf.c e_idea.c e_des3.c e_camellia.c\
@@ -11,8 +11,8 @@ SOURCE[../../libcrypto]=$COMMON\
         p_open.c p_seal.c p_sign.c p_verify.c p_lib.c p_enc.c p_dec.c \
         bio_md.c bio_b64.c bio_enc.c evp_err.c e_null.c \
         c_allc.c c_alld.c bio_ok.c \
-        evp_pkey.c kdf_lib.c evp_pbe.c p5_crpt.c p5_crpt2.c pbe_scrypt.c \
-        pkey_kdf.c c_allkdf.c \
+        evp_pkey.c evp_pbe.c p5_crpt.c p5_crpt2.c pbe_scrypt.c \
+        pkey_kdf.c \
         e_old.c pmeth_lib.c pmeth_fn.c pmeth_gn.c m_sigver.c \
         e_aes_cbc_hmac_sha1.c e_aes_cbc_hmac_sha256.c e_rc4_hmac_md5.c \
         e_chacha20_poly1305.c \
diff --git a/crypto/evp/c_allkdf.c b/crypto/evp/c_allkdf.c
deleted file mode 100644
index 860c11c5ce..0000000000
--- a/crypto/evp/c_allkdf.c
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#include &lt;openssl/evp.h&gt;
-#include &quot;internal/evp_int.h&quot;
-
-void openssl_add_all_kdfs_int(void)
-{
-    EVP_add_kdf(&amp;pbkdf2_kdf_meth);
-#ifndef OPENSSL_NO_SCRYPT
-    EVP_add_kdf(&amp;scrypt_kdf_meth);
-#endif
-    EVP_add_kdf(&amp;tls1_prf_kdf_meth);
-    EVP_add_kdf(&amp;hkdf_kdf_meth);
-    EVP_add_kdf(&amp;sshkdf_kdf_meth);
-    EVP_add_kdf(&amp;ss_kdf_meth);
-    EVP_add_kdf(&amp;x963_kdf_meth);
-#ifndef OPENSSL_NO_CMS
-    EVP_add_kdf(&amp;x942_kdf_meth);
-#endif
-}
diff --git a/crypto/evp/evp_locl.h b/crypto/evp/evp_locl.h
index 87f54bdc5f..750e593b66 100644
--- a/crypto/evp/evp_locl.h
+++ b/crypto/evp/evp_locl.h
@@ -61,8 +61,8 @@ struct evp_mac_ctx_st {
 } /* EVP_MAC_CTX */;
 
 struct evp_kdf_ctx_st {
-    const EVP_KDF *meth;         /* Method structure */
-    EVP_KDF_IMPL *impl;          /* Algorithm-specific data */
+    EVP_KDF *meth;              /* Method structure */
+    void *data;                 /* Algorithm-specific data */
 } /* EVP_KDF_CTX */ ;
 
 struct evp_keymgmt_st {
diff --git a/crypto/evp/kdf_lib.c b/crypto/evp/kdf_lib.c
index 6131d8ef77..aa0c5e341f 100644
--- a/crypto/evp/kdf_lib.c
+++ b/crypto/evp/kdf_lib.c
@@ -15,12 +15,15 @@
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/x509v3.h&gt;
 #include &lt;openssl/kdf.h&gt;
+#include &lt;openssl/core.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &quot;internal/asn1_int.h&quot;
 #include &quot;internal/evp_int.h&quot;
 #include &quot;internal/numbers.h&quot;
+#include &quot;internal/provider.h&quot;
 #include &quot;evp_locl.h&quot;
 
-EVP_KDF_CTX *EVP_KDF_CTX_new(const EVP_KDF *kdf)
+EVP_KDF_CTX *EVP_KDF_CTX_new(EVP_KDF *kdf)
 {
     EVP_KDF_CTX *ctx = NULL;
 
@@ -28,8 +31,12 @@ EVP_KDF_CTX *EVP_KDF_CTX_new(const EVP_KDF *kdf)
         return NULL;
 
     ctx = OPENSSL_zalloc(sizeof(EVP_KDF_CTX));
-    if (ctx == NULL || (ctx-&gt;impl = kdf-&gt;new()) == NULL) {
+    if (ctx == NULL
+        || (ctx-&gt;data = kdf-&gt;newctx(ossl_provider_ctx(kdf-&gt;prov))) == NULL
+        || !EVP_KDF_up_ref(kdf)) {
         EVPerr(EVP_F_EVP_KDF_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        if (ctx != NULL)
+            kdf-&gt;freectx(ctx-&gt;data);
         OPENSSL_free(ctx);
         ctx = NULL;
     } else {
@@ -38,30 +45,57 @@ EVP_KDF_CTX *EVP_KDF_CTX_new(const EVP_KDF *kdf)
     return ctx;
 }
 
-EVP_KDF_CTX *EVP_KDF_CTX_new_id(int id)
+void EVP_KDF_CTX_free(EVP_KDF_CTX *ctx)
 {
-    const EVP_KDF *kdf = EVP_get_kdfbynid(id);
-
-    return EVP_KDF_CTX_new(kdf);
+    if (ctx != NULL) {
+        ctx-&gt;meth-&gt;freectx(ctx-&gt;data);
+        ctx-&gt;data = NULL;
+        EVP_KDF_free(ctx-&gt;meth);
+        OPENSSL_free(ctx);
+    }
 }
 
-int EVP_KDF_nid(const EVP_KDF *kdf)
+EVP_KDF_CTX *EVP_KDF_CTX_dup(const EVP_KDF_CTX *src)
 {
-    return kdf-&gt;type;
+    EVP_KDF_CTX *dst;
+
+    if (src-&gt;data == NULL || src == NULL || src-&gt;meth-&gt;dupctx == NULL)
+        return NULL;
+
+    dst = OPENSSL_malloc(sizeof(*dst));
+    if (dst == NULL) {
+        EVPerr(EVP_F_EVP_KDF_CTX_DUP, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+
+    memcpy(dst, src, sizeof(*dst));
+    if (!EVP_KDF_up_ref(dst-&gt;meth)) {
+        EVPerr(EVP_F_EVP_KDF_CTX_DUP, ERR_R_MALLOC_FAILURE);
+        OPENSSL_free(dst);
+        return NULL;
+    }
+
+    dst-&gt;data = src-&gt;meth-&gt;dupctx(src-&gt;data);
+    if (dst-&gt;data == NULL) {
+        EVP_KDF_CTX_free(dst);
+        return NULL;
+    }
+    return dst;
 }
 
-const EVP_KDF *EVP_KDF_CTX_kdf(EVP_KDF_CTX *ctx)
+const char *EVP_KDF_name(const EVP_KDF *kdf)
 {
-    return ctx-&gt;meth;
+    return kdf-&gt;name;
 }
 
-void EVP_KDF_CTX_free(EVP_KDF_CTX *ctx)
+const OSSL_PROVIDER *EVP_KDF_provider(const EVP_KDF *kdf)
 {
-    if (ctx == NULL)
-        return;
+    return kdf-&gt;prov;
+}
 
-    ctx-&gt;meth-&gt;free(ctx-&gt;impl);
-    OPENSSL_free(ctx);
+const EVP_KDF *EVP_KDF_CTX_kdf(EVP_KDF_CTX *ctx)
+{
+    return ctx-&gt;meth;
 }
 
 void EVP_KDF_reset(EVP_KDF_CTX *ctx)
@@ -70,66 +104,58 @@ void EVP_KDF_reset(EVP_KDF_CTX *ctx)
         return;
 
     if (ctx-&gt;meth-&gt;reset != NULL)
-        ctx-&gt;meth-&gt;reset(ctx-&gt;impl);
+        ctx-&gt;meth-&gt;reset(ctx-&gt;data);
 }
 
-int EVP_KDF_ctrl(EVP_KDF_CTX *ctx, int cmd, ...)
+size_t EVP_KDF_size(EVP_KDF_CTX *ctx)
 {
-    int ret;
-    va_list args;
-
-    va_start(args, cmd);
-    ret = EVP_KDF_vctrl(ctx, cmd, args);
-    va_end(args);
-
-    if (ret == -2)
-        EVPerr(EVP_F_EVP_KDF_CTRL, EVP_R_COMMAND_NOT_SUPPORTED);
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
+    size_t s;
 
-    return ret;
-}
-
-int EVP_KDF_vctrl(EVP_KDF_CTX *ctx, int cmd, va_list args)
-{
     if (ctx == NULL)
         return 0;
 
-    return ctx-&gt;meth-&gt;ctrl(ctx-&gt;impl, cmd, args);
+    *params = OSSL_PARAM_construct_size_t(OSSL_KDF_PARAM_SIZE, &amp;s);
+    if (ctx-&gt;meth-&gt;get_ctx_params != NULL
+        &amp;&amp; ctx-&gt;meth-&gt;get_ctx_params(ctx, params))
+            return s;
+    if (ctx-&gt;meth-&gt;get_params != NULL
+        &amp;&amp; ctx-&gt;meth-&gt;get_params(params))
+            return s;
+    return 0;
 }
 
-int EVP_KDF_ctrl_str(EVP_KDF_CTX *ctx, const char *type, const char *value)
+int EVP_KDF_derive(EVP_KDF_CTX *ctx, unsigned char *key, size_t keylen)
 {
-    int ret;
-
     if (ctx == NULL)
         return 0;
 
-    if (ctx-&gt;meth-&gt;ctrl_str == NULL) {
-        EVPerr(EVP_F_EVP_KDF_CTRL_STR, EVP_R_COMMAND_NOT_SUPPORTED);
-        return -2;
-    }
-
-    ret = ctx-&gt;meth-&gt;ctrl_str(ctx-&gt;impl, type, value);
-    if (ret == -2)
-        EVPerr(EVP_F_EVP_KDF_CTRL_STR, EVP_R_COMMAND_NOT_SUPPORTED);
-
-    return ret;
+    return ctx-&gt;meth-&gt;derive(ctx-&gt;data, key, keylen);
 }
 
-size_t EVP_KDF_size(EVP_KDF_CTX *ctx)
+/*
+ * The {get,set}_params functions return 1 if there is no corresponding
+ * function in the implementation.  This is the same as if there was one,
+ * but it didn't recognise any of the given params, i.e. nothing in the
+ * bag of parameters was useful.
+ */
+int EVP_KDF_get_params(EVP_KDF *kdf, OSSL_PARAM params[])
 {
-    if (ctx == NULL)
-        return 0;
-
-    if (ctx-&gt;meth-&gt;size == NULL)
-        return SIZE_MAX;
-
-    return ctx-&gt;meth-&gt;size(ctx-&gt;impl);
+    if (kdf-&gt;get_params != NULL)
+        return kdf-&gt;get_params(params);
+    return 1;
 }
 
-int EVP_KDF_derive(EVP_KDF_CTX *ctx, unsigned char *key, size_t keylen)
+int EVP_KDF_CTX_get_params(EVP_KDF_CTX *ctx, OSSL_PARAM params[])
 {
-    if (ctx == NULL)
-        return 0;
+    if (ctx-&gt;meth-&gt;get_ctx_params != NULL)
+        return ctx-&gt;meth-&gt;get_ctx_params(ctx-&gt;data, params);
+    return 1;
+}
 
-    return ctx-&gt;meth-&gt;derive(ctx-&gt;impl, key, keylen);
+int EVP_KDF_CTX_set_params(EVP_KDF_CTX *ctx, const OSSL_PARAM params[])
+{
+    if (ctx-&gt;meth-&gt;set_ctx_params != NULL)
+        return ctx-&gt;meth-&gt;set_ctx_params(ctx-&gt;data, params);
+    return 1;
 }
diff --git a/crypto/evp/kdf_meth.c b/crypto/evp/kdf_meth.c
new file mode 100644
index 0000000000..c2db212710
--- /dev/null
+++ b/crypto/evp/kdf_meth.c
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/err.h&gt;
+#include &lt;openssl/core.h&gt;
+#include &lt;openssl/core_numbers.h&gt;
+#include &lt;openssl/kdf.h&gt;
+#include &quot;internal/evp_int.h&quot;
+#include &quot;internal/provider.h&quot;
+#include &quot;evp_locl.h&quot;
+
+static int evp_kdf_up_ref(void *vkdf)
+{
+    EVP_KDF *kdf = (EVP_KDF *)vkdf;
+    int ref = 0;
+
+    CRYPTO_UP_REF(&amp;kdf-&gt;refcnt, &amp;ref, kdf-&gt;lock);
+    return 1;
+}
+
+static void evp_kdf_free(void *vkdf){
+    EVP_KDF *kdf = (EVP_KDF *)vkdf;
+    int ref = 0;
+
+    if (kdf != NULL) {
+        CRYPTO_DOWN_REF(&amp;kdf-&gt;refcnt, &amp;ref, kdf-&gt;lock);
+        if (ref &lt;= 0) {
+            ossl_provider_free(kdf-&gt;prov);
+            OPENSSL_free(kdf-&gt;name);
+            CRYPTO_THREAD_lock_free(kdf-&gt;lock);
+            OPENSSL_free(kdf);
+        }
+    }
+}
+
+static void *evp_kdf_new(void)
+{
+    EVP_KDF *kdf = NULL;
+
+    if ((kdf = OPENSSL_zalloc(sizeof(*kdf))) == NULL
+        || (kdf-&gt;lock = CRYPTO_THREAD_lock_new()) == NULL) {
+        OPENSSL_free(kdf);
+        return NULL;
+    }
+    kdf-&gt;refcnt = 1;
+    return kdf;
+}
+
+static void *evp_kdf_from_dispatch(const char *name, const OSSL_DISPATCH *fns,
+                                   OSSL_PROVIDER *prov, void *method_data)
+{
+    EVP_KDF *kdf = NULL;
+    int fnkdfcnt = 0, fnctxcnt = 0;
+
+    if ((kdf = evp_kdf_new()) == NULL
+        || (kdf-&gt;name = OPENSSL_strdup(name)) == NULL) {
+        evp_kdf_free(kdf);
+        EVPerr(0, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+
+    for (; fns-&gt;function_id != 0; fns++) {
+        switch (fns-&gt;function_id) {
+        case OSSL_FUNC_KDF_NEWCTX:
+            if (kdf-&gt;newctx != NULL)
+                break;
+            kdf-&gt;newctx = OSSL_get_OP_kdf_newctx(fns);
+            fnctxcnt++;
+            break;
+        case OSSL_FUNC_KDF_DUPCTX:
+            if (kdf-&gt;dupctx != NULL)
+                break;
+            kdf-&gt;dupctx = OSSL_get_OP_kdf_dupctx(fns);
+            break;
+        case OSSL_FUNC_KDF_FREECTX:
+            if (kdf-&gt;freectx != NULL)
+                break;
+            kdf-&gt;freectx = OSSL_get_OP_kdf_freectx(fns);
+            fnctxcnt++;
+            break;
+        case OSSL_FUNC_KDF_RESET:
+            if (kdf-&gt;reset != NULL)
+                break;
+            kdf-&gt;reset = OSSL_get_OP_kdf_reset(fns);
+            break;
+        case OSSL_FUNC_KDF_DERIVE:
+            if (kdf-&gt;derive != NULL)
+                break;
+            kdf-&gt;derive = OSSL_get_OP_kdf_derive(fns);
+            fnkdfcnt++;
+            break;
+        case OSSL_FUNC_KDF_GETTABLE_PARAMS:
+            if (kdf-&gt;gettable_params != NULL)
+                break;
+            kdf-&gt;gettable_params =
+                OSSL_get_OP_kdf_gettable_params(fns);
+            break;
+        case OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS:
+            if (kdf-&gt;gettable_ctx_params != NULL)
+                break;
+            kdf-&gt;gettable_ctx_params =
+                OSSL_get_OP_kdf_gettable_ctx_params(fns);
+            break;
+        case OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS:
+            if (kdf-&gt;settable_ctx_params != NULL)
+                break;
+            kdf-&gt;settable_ctx_params =
+                OSSL_get_OP_kdf_settable_ctx_params(fns);
+            break;
+        case OSSL_FUNC_KDF_GET_PARAMS:
+            if (kdf-&gt;get_params != NULL)
+                break;
+            kdf-&gt;get_params = OSSL_get_OP_kdf_get_params(fns);
+            break;
+        case OSSL_FUNC_KDF_GET_CTX_PARAMS:
+            if (kdf-&gt;get_ctx_params != NULL)
+                break;
+            kdf-&gt;get_ctx_params = OSSL_get_OP_kdf_get_ctx_params(fns);
+            break;
+        case OSSL_FUNC_KDF_SET_CTX_PARAMS:
+            if (kdf-&gt;set_ctx_params != NULL)
+                break;
+            kdf-&gt;set_ctx_params = OSSL_get_OP_kdf_set_ctx_params(fns);
+            break;
+        }
+    }
+    if (fnkdfcnt != 1 || fnctxcnt != 2) {
+        /*
+         * In order to be a consistent set of functions we must have at least
+         * a derive function, and a complete set of context management
+         * functions.
+         */
+        evp_kdf_free(kdf);
+        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);
+        return NULL;
+    }
+    kdf-&gt;prov = prov;
+    if (prov != NULL)
+        ossl_provider_up_ref(prov);
+
+    return kdf;
+}
+
+EVP_KDF *EVP_KDF_fetch(OPENSSL_CTX *libctx, const char *algorithm,
+                       const char *properties)
+{
+    return evp_generic_fetch(libctx, OSSL_OP_KDF, algorithm, properties,
+                             evp_kdf_from_dispatch, NULL, evp_kdf_up_ref,
+                             evp_kdf_free);
+}
+
+int EVP_KDF_up_ref(EVP_KDF *kdf)
+{
+    return evp_kdf_up_ref(kdf);
+}
+
+void EVP_KDF_free(EVP_KDF *kdf)
+{
+    evp_kdf_free(kdf);
+}
+
+const OSSL_PARAM *EVP_KDF_gettable_params(const EVP_KDF *kdf)
+{
+    if (kdf-&gt;gettable_params == NULL)
+        return NULL;
+    return kdf-&gt;gettable_params();
+}
+
+const OSSL_PARAM *EVP_KDF_CTX_gettable_params(const EVP_KDF *kdf)
+{
+    if (kdf-&gt;gettable_ctx_params == NULL)
+        return NULL;
+    return kdf-&gt;gettable_ctx_params();
+}
+
+const OSSL_PARAM *EVP_KDF_CTX_settable_params(const EVP_KDF *kdf)
+{
+    if (kdf-&gt;settable_ctx_params == NULL)
+        return NULL;
+    return kdf-&gt;settable_ctx_params();
+}
+
+void EVP_KDF_do_all_ex(OPENSSL_CTX *libctx,
+                       void (*fn)(EVP_KDF *kdf, void *arg),
+                       void *arg)
+{
+    evp_generic_do_all(libctx, OSSL_OP_KDF,
+                       (void (*)(void *, void *))fn, arg,
+                       evp_kdf_from_dispatch, NULL, evp_kdf_free);
+}
diff --git a/crypto/evp/names.c b/crypto/evp/names.c
index 82db98a1f2..7c2f4f061c 100644
--- a/crypto/evp/names.c
+++ b/crypto/evp/names.c
@@ -56,23 +56,6 @@ int EVP_add_digest(const EVP_MD *md)
     return r;
 }
 
-/* TODO(3.0) Is this needed after changing to providers? */
-int EVP_add_kdf(const EVP_KDF *k)
-{
-    int r;
-
-    if (k == NULL)
-        return 0;
-
-    r = OBJ_NAME_add(OBJ_nid2sn(k-&gt;type), OBJ_NAME_TYPE_KDF_METH,
-                     (const char *)k);
-    if (r == 0)
-        return 0;
-    r = OBJ_NAME_add(OBJ_nid2ln(k-&gt;type), OBJ_NAME_TYPE_KDF_METH,
-                     (const char *)k);
-    return r;
-}
-
 const EVP_CIPHER *EVP_get_cipherbyname(const char *name)
 {
     const EVP_CIPHER *cp;
@@ -95,18 +78,6 @@ const EVP_MD *EVP_get_digestbyname(const char *name)
     return cp;
 }
 
-/* TODO(3.0) Is this API needed after implementing providers? */
-const EVP_KDF *EVP_get_kdfbyname(const char *name)
-{
-    const EVP_KDF *kdf;
-
-    if (!OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_KDFS, NULL))
-        return NULL;
-
-    kdf = (const EVP_KDF *)OBJ_NAME_get(name, OBJ_NAME_TYPE_KDF_METH);
-    return kdf;
-}
-
 void evp_cleanup_int(void)
 {
     OBJ_NAME_cleanup(OBJ_NAME_TYPE_KDF_METH);
diff --git a/crypto/evp/p5_crpt2.c b/crypto/evp/p5_crpt2.c
index a7d4cafaf9..c12d35c8ab 100644
--- a/crypto/evp/p5_crpt2.c
+++ b/crypto/evp/p5_crpt2.c
@@ -15,6 +15,7 @@
 #include &lt;openssl/kdf.h&gt;
 #include &lt;openssl/hmac.h&gt;
 #include &lt;openssl/trace.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &quot;internal/evp_int.h&quot;
 #include &quot;evp_locl.h&quot;
 
@@ -23,8 +24,11 @@ int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
                       const EVP_MD *digest, int keylen, unsigned char *out)
 {
     const char *empty = &quot;&quot;;
-    int rv = 1;
+    int rv = 1, mode = 1;
+    EVP_KDF *kdf;
     EVP_KDF_CTX *kctx;
+    const char *mdname = EVP_MD_name(digest);
+    OSSL_PARAM params[6], *p = params;
 
     /* Keep documented behaviour. */
     if (pass == NULL) {
@@ -36,15 +40,21 @@ int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
     if (salt == NULL &amp;&amp; saltlen == 0)
         salt = (unsigned char *)empty;
 
-    kctx = EVP_KDF_CTX_new_id(EVP_KDF_PBKDF2);
+    kdf = EVP_KDF_fetch(NULL, LN_id_pbkdf2, NULL);
+    kctx = EVP_KDF_CTX_new(kdf);
+    EVP_KDF_free(kdf);
     if (kctx == NULL)
         return 0;
-    if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PASS, pass, (size_t)passlen) != 1
-            || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE, 1) != 1
-            || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT,
-                            salt, (size_t)saltlen) != 1
-            || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_ITER, iter) != 1
-            || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, digest) != 1
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_PASSWORD,
+                                             (char *)pass, (size_t)passlen);
+    *p++ = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_PKCS5, &amp;mode);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                             (unsigned char *)salt, saltlen);
+    *p++ = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_ITER, &amp;iter);
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)mdname, strlen(mdname) + 1);
+    *p = OSSL_PARAM_construct_end();
+    if (EVP_KDF_CTX_set_params(kctx, params) != 1
             || EVP_KDF_derive(kctx, out, keylen) != 1)
         rv = 0;
 
diff --git a/crypto/evp/pbe_scrypt.c b/crypto/evp/pbe_scrypt.c
index c0ab238eb8..7a9f6f47a4 100644
--- a/crypto/evp/pbe_scrypt.c
+++ b/crypto/evp/pbe_scrypt.c
@@ -10,6 +10,7 @@
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/kdf.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &quot;internal/numbers.h&quot;
 
 #ifndef OPENSSL_NO_SCRYPT
@@ -40,7 +41,9 @@ int EVP_PBE_scrypt(const char *pass, size_t passlen,
 {
     const char *empty = &quot;&quot;;
     int rv = 1;
+    EVP_KDF *kdf;
     EVP_KDF_CTX *kctx;
+    OSSL_PARAM params[7], *z = params;
 
     if (r &gt; UINT32_MAX || p &gt; UINT32_MAX) {
         EVPerr(EVP_F_EVP_PBE_SCRYPT, EVP_R_PARAMETER_TOO_LARGE);
@@ -59,17 +62,23 @@ int EVP_PBE_scrypt(const char *pass, size_t passlen,
     if (maxmem == 0)
         maxmem = SCRYPT_MAX_MEM;
 
-    kctx = EVP_KDF_CTX_new_id(EVP_KDF_SCRYPT);
+    kdf = EVP_KDF_fetch(NULL, SN_id_scrypt, NULL);
+    kctx = EVP_KDF_CTX_new(kdf);
+    EVP_KDF_free(kdf);
     if (kctx == NULL)
         return 0;
 
-    if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PASS, pass, (size_t)passlen) != 1
-            || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT,
-                            salt, (size_t)saltlen) != 1
-            || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_N, N) != 1
-            || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_R, (uint32_t)r) != 1
-            || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_P, (uint32_t)p) != 1
-            || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MAXMEM_BYTES, maxmem) != 1
+    *z++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_PASSWORD,
+                                              (unsigned char *)pass,
+                                                      passlen);
+    *z++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                             (unsigned char *)salt, saltlen);
+    *z++ = OSSL_PARAM_construct_uint64(OSSL_KDF_PARAM_SCRYPT_N, &amp;N);
+    *z++ = OSSL_PARAM_construct_uint64(OSSL_KDF_PARAM_SCRYPT_R, &amp;r);
+    *z++ = OSSL_PARAM_construct_uint64(OSSL_KDF_PARAM_SCRYPT_P, &amp;p);
+    *z++ = OSSL_PARAM_construct_uint64(OSSL_KDF_PARAM_SCRYPT_MAXMEM, &amp;maxmem);
+    *z = OSSL_PARAM_construct_end();
+    if (EVP_KDF_CTX_set_params(kctx, params) != 1
             || EVP_KDF_derive(kctx, key, keylen) != 1)
         rv = 0;
 
diff --git a/crypto/evp/pkey_kdf.c b/crypto/evp/pkey_kdf.c
index f983ad2ff3..c13bb203b3 100644
--- a/crypto/evp/pkey_kdf.c
+++ b/crypto/evp/pkey_kdf.c
@@ -11,131 +11,251 @@
 #include &lt;string.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/err.h&gt;
+#include &lt;openssl/buffer.h&gt;
 #include &lt;openssl/kdf.h&gt;
+#include &lt;openssl/core.h&gt;
+#include &lt;openssl/core_names.h&gt;
+#include &lt;openssl/params.h&gt;
 #include &quot;internal/numbers.h&quot;
 #include &quot;internal/evp_int.h&quot;
 
+#define MAX_PARAM   20
+
+typedef struct {
+    EVP_KDF_CTX *kctx;
+    /*
+     * EVP_PKEY implementations collect bits of certain data
+     */
+    BUF_MEM *collected_seed;
+    BUF_MEM *collected_info;
+} EVP_PKEY_KDF_CTX;
+
+static void pkey_kdf_free_collected(EVP_PKEY_KDF_CTX *pkctx)
+{
+    BUF_MEM_free(pkctx-&gt;collected_seed);
+    pkctx-&gt;collected_seed = NULL;
+    BUF_MEM_free(pkctx-&gt;collected_info);
+    pkctx-&gt;collected_info = NULL;
+}
+
 static int pkey_kdf_init(EVP_PKEY_CTX *ctx)
 {
+    EVP_PKEY_KDF_CTX *pkctx;
     EVP_KDF_CTX *kctx;
+    const char *kdf_name = OBJ_nid2sn(ctx-&gt;pmeth-&gt;pkey_id);
+    EVP_KDF *kdf;
 
-    kctx = EVP_KDF_CTX_new_id(ctx-&gt;pmeth-&gt;pkey_id);
-    if (kctx == NULL)
+    pkctx = OPENSSL_zalloc(sizeof(*pkctx));
+    if (pkctx == NULL)
         return 0;
 
-    ctx-&gt;data = kctx;
+    kdf = EVP_KDF_fetch(NULL, kdf_name, NULL);
+    kctx = EVP_KDF_CTX_new(kdf);
+    EVP_KDF_free(kdf);
+    if (kctx == NULL) {
+        OPENSSL_free(pkctx);
+        return 0;
+    }
+
+    pkctx-&gt;kctx = kctx;
+    ctx-&gt;data = pkctx;
     return 1;
 }
 
 static void pkey_kdf_cleanup(EVP_PKEY_CTX *ctx)
 {
-    EVP_KDF_CTX *kctx = ctx-&gt;data;
+    EVP_PKEY_KDF_CTX *pkctx = ctx-&gt;data;
 
-    EVP_KDF_CTX_free(kctx);
+    EVP_KDF_CTX_free(pkctx-&gt;kctx);
+    pkey_kdf_free_collected(pkctx);
+    OPENSSL_free(pkctx);
+}
+
+static int collect(BUF_MEM **collector, void *data, size_t datalen)
+{
+    size_t i;
+
+    if (*collector == NULL)
+        *collector = BUF_MEM_new();
+    if (*collector == NULL) {
+        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+
+    i = (*collector)-&gt;length; /* BUF_MEM_grow() changes it! */
+    /*
+     * The i + datalen check is to distinguish between BUF_MEM_grow()
+     * signaling an error and BUF_MEM_grow() simply returning the (zero)
+     * length.
+     */
+    if (!BUF_MEM_grow(*collector, i + datalen)
+        &amp;&amp; i + datalen != 0)
+        return 0;
+    if (data != NULL)
+        memcpy((*collector)-&gt;data + i, data, datalen);
+    return 1;
 }
 
 static int pkey_kdf_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
 {
-    EVP_KDF_CTX *kctx = ctx-&gt;data;
-    uint64_t u64_value;
-    int cmd;
-    int ret;
+    EVP_PKEY_KDF_CTX *pkctx = ctx-&gt;data;
+    EVP_KDF_CTX *kctx = pkctx-&gt;kctx;
+    enum { T_OCTET_STRING, T_UINT64, T_DIGEST, T_INT } cmd;
+    const char *name, *mdname;
+    BUF_MEM **collector = NULL;
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
 
     switch (type) {
     case EVP_PKEY_CTRL_PASS:
-        cmd = EVP_KDF_CTRL_SET_PASS;
+        cmd = T_OCTET_STRING;
+        name = OSSL_KDF_PARAM_PASSWORD;
         break;
     case EVP_PKEY_CTRL_HKDF_SALT:
     case EVP_PKEY_CTRL_SCRYPT_SALT:
-        cmd = EVP_KDF_CTRL_SET_SALT;
+        cmd = T_OCTET_STRING;
+        name = OSSL_KDF_PARAM_SALT;
         break;
     case EVP_PKEY_CTRL_TLS_MD:
     case EVP_PKEY_CTRL_HKDF_MD:
-        cmd = EVP_KDF_CTRL_SET_MD;
+        cmd = T_DIGEST;
+        name = OSSL_KDF_PARAM_DIGEST;
         break;
     case EVP_PKEY_CTRL_TLS_SECRET:
-        cmd = EVP_KDF_CTRL_SET_TLS_SECRET;
-        ret = EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_RESET_TLS_SEED);
-        if (ret &lt; 1)
-            return ret;
+        cmd = T_OCTET_STRING;
+        name = OSSL_KDF_PARAM_SECRET;
+        /*
+         * Perform the semantics described in
+         * EVP_PKEY_CTX_add1_tls1_prf_seed(3)
+         */
+        if (ctx-&gt;pmeth-&gt;pkey_id == NID_tls1_prf) {
+            BUF_MEM_free(pkctx-&gt;collected_seed);
+            pkctx-&gt;collected_seed = NULL;
+        }
         break;
     case EVP_PKEY_CTRL_TLS_SEED:
-        cmd = EVP_KDF_CTRL_ADD_TLS_SEED;
+        cmd = T_OCTET_STRING;
+        name = OSSL_KDF_PARAM_SEED;
+        collector = &amp;pkctx-&gt;collected_seed;
         break;
     case EVP_PKEY_CTRL_HKDF_KEY:
-        cmd = EVP_KDF_CTRL_SET_KEY;
+        cmd = T_OCTET_STRING;
+        name = OSSL_KDF_PARAM_KEY;
         break;
     case EVP_PKEY_CTRL_HKDF_INFO:
-        cmd = EVP_KDF_CTRL_ADD_HKDF_INFO;
+        cmd = T_OCTET_STRING;
+        name = OSSL_KDF_PARAM_INFO;
+        collector = &amp;pkctx-&gt;collected_info;
         break;
     case EVP_PKEY_CTRL_HKDF_MODE:
-        cmd = EVP_KDF_CTRL_SET_HKDF_MODE;
+        cmd = T_INT;
+        name = OSSL_KDF_PARAM_MODE;
         break;
     case EVP_PKEY_CTRL_SCRYPT_N:
-        cmd = EVP_KDF_CTRL_SET_SCRYPT_N;
+        cmd = T_UINT64;
+        name = OSSL_KDF_PARAM_SCRYPT_N;
         break;
     case EVP_PKEY_CTRL_SCRYPT_R:
-        cmd = EVP_KDF_CTRL_SET_SCRYPT_R;
+        cmd = T_UINT64; /* Range checking occurs on the provider side */
+        name = OSSL_KDF_PARAM_SCRYPT_R;
         break;
     case EVP_PKEY_CTRL_SCRYPT_P:
-        cmd = EVP_KDF_CTRL_SET_SCRYPT_P;
+        cmd = T_UINT64; /* Range checking occurs on the provider side */
+        name = OSSL_KDF_PARAM_SCRYPT_P;
         break;
     case EVP_PKEY_CTRL_SCRYPT_MAXMEM_BYTES:
-        cmd = EVP_KDF_CTRL_SET_MAXMEM_BYTES;
+        cmd = T_UINT64;
+        name = OSSL_KDF_PARAM_SCRYPT_MAXMEM;
         break;
     default:
         return -2;
     }
 
-    switch (cmd) {
-    case EVP_KDF_CTRL_SET_PASS:
-    case EVP_KDF_CTRL_SET_SALT:
-    case EVP_KDF_CTRL_SET_KEY:
-    case EVP_KDF_CTRL_SET_TLS_SECRET:
-    case EVP_KDF_CTRL_ADD_TLS_SEED:
-    case EVP_KDF_CTRL_ADD_HKDF_INFO:
-        return EVP_KDF_ctrl(kctx, cmd, (const unsigned char *)p2, (size_t)p1);
-
-    case EVP_KDF_CTRL_SET_MD:
-        return EVP_KDF_ctrl(kctx, cmd, (const EVP_MD *)p2);
-
-    case EVP_KDF_CTRL_SET_HKDF_MODE:
-        return EVP_KDF_ctrl(kctx, cmd, (int)p1);
-
-    case EVP_KDF_CTRL_SET_SCRYPT_R:
-    case EVP_KDF_CTRL_SET_SCRYPT_P:
-        u64_value = *(uint64_t *)p2;
-        if (u64_value &gt; UINT32_MAX) {
-            EVPerr(EVP_F_PKEY_KDF_CTRL, EVP_R_PARAMETER_TOO_LARGE);
-            return 0;
+    if (collector != NULL) {
+        switch (cmd) {
+        case T_OCTET_STRING:
+            return collect(collector, p2, p1);
+        default:
+            OPENSSL_assert(&quot;You shouldn't be here&quot;);
+            break;
         }
+        return 1;
+    }
 
-        return EVP_KDF_ctrl(kctx, cmd, (uint32_t)u64_value);
+    switch (cmd) {
+    case T_OCTET_STRING:
+        params[0] =
+            OSSL_PARAM_construct_octet_string(name, (unsigned char *)p2,
+                                              (size_t)p1);
+        break;
 
-    case EVP_KDF_CTRL_SET_SCRYPT_N:
-    case EVP_KDF_CTRL_SET_MAXMEM_BYTES:
-        return EVP_KDF_ctrl(kctx, cmd, *(uint64_t *)p2);
+    case T_DIGEST:
+        mdname = EVP_MD_name((const EVP_MD *)p2);
+        params[0] = OSSL_PARAM_construct_utf8_string(name, (char *)mdname,
+                                                     strlen(mdname) + 1);
+        break;
 
-    default:
-        return 0;
+        /*
+         * These are special because the helper macros pass a pointer to the
+         * stack, so a local copy is required.
+         */
+    case T_INT:
+        params[0] = OSSL_PARAM_construct_int(name, &amp;p1);
+        break;
+
+    case T_UINT64:
+        params[0] = OSSL_PARAM_construct_uint64(name, (uint64_t *)p2);
+        break;
     }
+
+    return EVP_KDF_CTX_set_params(kctx, params);
 }
 
 static int pkey_kdf_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
                              const char *value)
 {
-    EVP_KDF_CTX *kctx = ctx-&gt;data;
-
+    EVP_PKEY_KDF_CTX *pkctx = ctx-&gt;data;
+    EVP_KDF_CTX *kctx = pkctx-&gt;kctx;
+    const EVP_KDF *kdf = EVP_KDF_CTX_kdf(kctx);
+    BUF_MEM **collector = NULL;
+    const OSSL_PARAM *defs = EVP_KDF_CTX_settable_params(kdf);
+    OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };
+    int ok = 0;
+
+    /* Deal with ctrl name aliasing */
     if (strcmp(type, &quot;md&quot;) == 0)
-        return EVP_KDF_ctrl_str(kctx, &quot;digest&quot;, value);
-    return EVP_KDF_ctrl_str(kctx, type, value);
+        type = OSSL_KDF_PARAM_DIGEST;
+    /* scrypt uses 'N', params uses 'n' */
+    if (strcmp(type, &quot;N&quot;) == 0)
+        type = OSSL_KDF_PARAM_SCRYPT_N;
+
+    if (!OSSL_PARAM_allocate_from_text(&amp;params[0], defs, type,
+                                       value, strlen(value)))
+        return 0;
+
+    /*
+     * We do the same special casing of seed and info here as in
+     * pkey_kdf_ctrl()
+     */
+    if (strcmp(params[0].key, OSSL_KDF_PARAM_SEED) == 0)
+        collector = &amp;pkctx-&gt;collected_seed;
+    else if (strcmp(params[0].key, OSSL_KDF_PARAM_INFO) == 0)
+        collector = &amp;pkctx-&gt;collected_info;
+
+    if (collector != NULL)
+        ok = collect(collector, params[0].data, params[0].data_size);
+    else
+        ok = EVP_KDF_CTX_set_params(kctx, params);
+    OPENSSL_free(params[0].data);
+    return ok;
 }
 
 static int pkey_kdf_derive_init(EVP_PKEY_CTX *ctx)
 {
-    EVP_KDF_CTX *kctx = ctx-&gt;data;
+    EVP_PKEY_KDF_CTX *pkctx = ctx-&gt;data;
 
-    EVP_KDF_reset(kctx);
+    pkey_kdf_free_collected(pkctx);
+    if (pkctx-&gt;kctx != NULL)
+        EVP_KDF_reset(pkctx-&gt;kctx);
     return 1;
 }
 
@@ -146,9 +266,37 @@ static int pkey_kdf_derive_init(EVP_PKEY_CTX *ctx)
 static int pkey_kdf_derive(EVP_PKEY_CTX *ctx, unsigned char *key,
                            size_t *keylen)
 {
-    EVP_KDF_CTX *kctx = ctx-&gt;data;
+    EVP_PKEY_KDF_CTX *pkctx = ctx-&gt;data;
+    EVP_KDF_CTX *kctx = pkctx-&gt;kctx;
     size_t outlen = EVP_KDF_size(kctx);
+    int r;
+
+    if (pkctx-&gt;collected_seed != NULL) {
+        OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };
+
+        params[0] =
+            OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SEED,
+                                              pkctx-&gt;collected_seed-&gt;data,
+                                              pkctx-&gt;collected_seed-&gt;length);
+
+        r = EVP_KDF_CTX_set_params(kctx, params);
+        pkey_kdf_free_collected(pkctx);
+        if (!r)
+            return 0;
+    }
+    if (pkctx-&gt;collected_info != NULL) {
+        OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };
+
+        params[0] =
+            OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+                                              pkctx-&gt;collected_info-&gt;data,
+                                              pkctx-&gt;collected_info-&gt;length);
 
+        r = EVP_KDF_CTX_set_params(kctx, params);
+        pkey_kdf_free_collected(pkctx);
+        if (!r)
+            return 0;
+    }
     if (outlen == 0 || outlen == SIZE_MAX) {
         /* Variable-output algorithm */
         if (key == NULL)
diff --git a/crypto/include/internal/evp_int.h b/crypto/include/internal/evp_int.h
index b86b1d1af0..d54edc78d3 100644
--- a/crypto/include/internal/evp_int.h
+++ b/crypto/include/internal/evp_int.h
@@ -140,26 +140,23 @@ struct evp_mac_st {
     OSSL_OP_mac_set_ctx_params_fn *set_ctx_params;
 };
 
-/*
- * This function is internal for now, but can be made external when needed.
- * The documentation would read:
- *
- * EVP_add_mac() adds the MAC implementation C&lt;mac&gt; to the internal
- * object database.
- */
-int EVP_add_kdf(const EVP_KDF *kdf);
-
-/* struct evp_kdf_impl_st is defined by the implementation */
-typedef struct evp_kdf_impl_st EVP_KDF_IMPL;
 struct evp_kdf_st {
-    int type;
-    EVP_KDF_IMPL *(*new) (void);
-    void (*free) (EVP_KDF_IMPL *impl);
-    void (*reset) (EVP_KDF_IMPL *impl);
-    int (*ctrl) (EVP_KDF_IMPL *impl, int cmd, va_list args);
-    int (*ctrl_str) (EVP_KDF_IMPL *impl, const char *type, const char *value);
-    size_t (*size) (EVP_KDF_IMPL *impl);
-    int (*derive) (EVP_KDF_IMPL *impl, unsigned char *key, size_t keylen);
+    OSSL_PROVIDER *prov;
+    char *name;
+    CRYPTO_REF_COUNT refcnt;
+    CRYPTO_RWLOCK *lock;
+
+    OSSL_OP_kdf_newctx_fn *newctx;
+    OSSL_OP_kdf_dupctx_fn *dupctx;
+    OSSL_OP_kdf_freectx_fn *freectx;
+    OSSL_OP_kdf_reset_fn *reset;
+    OSSL_OP_kdf_derive_fn *derive;
+    OSSL_OP_kdf_gettable_params_fn *gettable_params;
+    OSSL_OP_kdf_gettable_ctx_params_fn *gettable_ctx_params;
+    OSSL_OP_kdf_settable_ctx_params_fn *settable_ctx_params;
+    OSSL_OP_kdf_get_params_fn *get_params;
+    OSSL_OP_kdf_get_ctx_params_fn *get_ctx_params;
+    OSSL_OP_kdf_set_ctx_params_fn *set_ctx_params;
 };
 
 extern const EVP_KDF pbkdf2_kdf_meth;
@@ -553,8 +550,6 @@ struct evp_pkey_st {
 
 void openssl_add_all_ciphers_int(void);
 void openssl_add_all_digests_int(void);
-void openssl_add_all_macs_int(void);
-void openssl_add_all_kdfs_int(void);
 void evp_cleanup_int(void);
 void evp_app_cleanup_int(void);
 
diff --git a/crypto/init.c b/crypto/init.c
index d4da7b27e3..36c6333877 100644
--- a/crypto/init.c
+++ b/crypto/init.c
@@ -225,26 +225,6 @@ DEFINE_RUN_ONCE_STATIC_ALT(ossl_init_no_add_all_digests,
     return 1;
 }
 
-static CRYPTO_ONCE add_all_kdfs = CRYPTO_ONCE_STATIC_INIT;
-DEFINE_RUN_ONCE_STATIC(ossl_init_add_all_kdfs)
-{
-    /*
-     * OPENSSL_NO_AUTOALGINIT is provided here to prevent at compile time
-     * pulling in all the macs during static linking
-     */
-#ifndef OPENSSL_NO_AUTOALGINIT
-    OSSL_TRACE(INIT, &quot;openssl_add_all_kdfs_int()\n&quot;);
-    openssl_add_all_kdfs_int();
-#endif
-    return 1;
-}
-
-DEFINE_RUN_ONCE_STATIC_ALT(ossl_init_no_add_all_kdfs, ossl_init_add_all_kdfs)
-{
-    /* Do nothing */
-    return 1;
-}
-
 static CRYPTO_ONCE config = CRYPTO_ONCE_STATIC_INIT;
 static int config_inited = 0;
 static const OPENSSL_INIT_SETTINGS *conf_settings = NULL;
@@ -537,15 +517,6 @@ int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings)
             &amp;&amp; !RUN_ONCE(&amp;add_all_digests, ossl_init_add_all_digests))
         return 0;
 
-    if ((opts &amp; OPENSSL_INIT_NO_ADD_ALL_KDFS)
-            &amp;&amp; !RUN_ONCE_ALT(&amp;add_all_kdfs, ossl_init_no_add_all_kdfs,
-                             ossl_init_add_all_kdfs))
-        return 0;
-
-    if ((opts &amp; OPENSSL_INIT_ADD_ALL_KDFS)
-            &amp;&amp; !RUN_ONCE(&amp;add_all_kdfs, ossl_init_add_all_kdfs))
-        return 0;
-
     if ((opts &amp; OPENSSL_INIT_ATFORK)
             &amp;&amp; !openssl_init_fork_handlers())
         return 0;
diff --git a/crypto/kdf/build.info b/crypto/kdf/build.info
deleted file mode 100644
index 4fdaccddec..0000000000
--- a/crypto/kdf/build.info
+++ /dev/null
@@ -1,4 +0,0 @@
-LIBS=../../libcrypto
-SOURCE[../../libcrypto]=\
-        tls1_prf.c kdf_err.c kdf_util.c hkdf.c scrypt.c pbkdf2.c sshkdf.c \
-        sskdf.c x942kdf.c
diff --git a/crypto/kdf/kdf_err.c b/crypto/kdf/kdf_err.c
deleted file mode 100644
index d7d4b1e707..0000000000
--- a/crypto/kdf/kdf_err.c
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Generated by util/mkerr.pl DO NOT EDIT
- * Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#include &lt;openssl/err.h&gt;
-#include &lt;openssl/kdferr.h&gt;
-
-#ifndef OPENSSL_NO_ERR
-
-static const ERR_STRING_DATA KDF_str_reasons[] = {
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_BAD_ENCODING), &quot;bad encoding&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_BAD_LENGTH), &quot;bad length&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_INAVLID_UKM_LEN), &quot;inavlid ukm len&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_INVALID_DIGEST), &quot;invalid digest&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_INVALID_ITERATION_COUNT),
-    &quot;invalid iteration count&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_INVALID_KEY_LEN), &quot;invalid key len&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_INVALID_MAC_TYPE), &quot;invalid mac type&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_INVALID_SALT_LEN), &quot;invalid salt len&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_CEK_ALG), &quot;missing cek alg&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_ITERATION_COUNT),
-    &quot;missing iteration count&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_KEY), &quot;missing key&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_MESSAGE_DIGEST),
-    &quot;missing message digest&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_PARAMETER), &quot;missing parameter&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_PASS), &quot;missing pass&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_SALT), &quot;missing salt&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_SECRET), &quot;missing secret&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_SEED), &quot;missing seed&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_SESSION_ID), &quot;missing session id&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_TYPE), &quot;missing type&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_XCGHASH), &quot;missing xcghash&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_NOT_SUPPORTED), &quot;not supported&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_UNKNOWN_PARAMETER_TYPE),
-    &quot;unknown parameter type&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_UNSUPPORTED_CEK_ALG),
-    &quot;unsupported cek alg&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_UNSUPPORTED_MAC_TYPE),
-    &quot;unsupported mac type&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_VALUE_ERROR), &quot;value error&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_VALUE_MISSING), &quot;value missing&quot;},
-    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_WRONG_OUTPUT_BUFFER_SIZE),
-    &quot;wrong output buffer size&quot;},
-    {0, NULL}
-};
-
-#endif
-
-int ERR_load_KDF_strings(void)
-{
-#ifndef OPENSSL_NO_ERR
-    if (ERR_func_error_string(KDF_str_reasons[0].error) == NULL)
-        ERR_load_strings_const(KDF_str_reasons);
-#endif
-    return 1;
-}
diff --git a/crypto/kdf/kdf_local.h b/crypto/kdf/kdf_local.h
deleted file mode 100644
index 4956dad920..0000000000
--- a/crypto/kdf/kdf_local.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
- * Copyright (c) 2018, Oracle and/or its affiliates.  All rights reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-int call_ctrl(int (*ctrl)(EVP_KDF_IMPL *impl, int cmd, va_list args),
-              EVP_KDF_IMPL *impl, int cmd, ...);
-int kdf_str2ctrl(EVP_KDF_IMPL *impl,
-                 int (*ctrl)(EVP_KDF_IMPL *impl, int cmd, va_list args),
-                 int cmd, const char *str);
-int kdf_hex2ctrl(EVP_KDF_IMPL *impl,
-                 int (*ctrl)(EVP_KDF_IMPL *impl, int cmd, va_list args),
-                 int cmd, const char *hex);
-int kdf_md2ctrl(EVP_KDF_IMPL *impl,
-                int (*ctrl)(EVP_KDF_IMPL *impl, int cmd, va_list args),
-                int cmd, const char *md_name);
-
diff --git a/crypto/kdf/kdf_util.c b/crypto/kdf/kdf_util.c
deleted file mode 100644
index 8eb6d26b34..0000000000
--- a/crypto/kdf/kdf_util.c
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
- * Copyright (c) 2018, Oracle and/or its affiliates.  All rights reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#include &lt;string.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;openssl/kdf.h&gt;
-#include &lt;openssl/evp.h&gt;
-#include &quot;internal/cryptlib.h&quot;
-#include &quot;internal/evp_int.h&quot;
-#include &quot;internal/numbers.h&quot;
-#include &quot;kdf_local.h&quot;
-
-int call_ctrl(int (*ctrl)(EVP_KDF_IMPL *impl, int cmd, va_list args),
-              EVP_KDF_IMPL *impl, int cmd, ...)
-{
-    int ret;
-    va_list args;
-
-    va_start(args, cmd);
-    ret = ctrl(impl, cmd, args);
-    va_end(args);
-
-    return ret;
-}
-
-/* Utility functions to send a string or hex string to a ctrl */
-
-int kdf_str2ctrl(EVP_KDF_IMPL *impl,
-                 int (*ctrl)(EVP_KDF_IMPL *impl, int cmd, va_list args),
-                 int cmd, const char *str)
-{
-    return call_ctrl(ctrl, impl, cmd, (const unsigned char *)str, strlen(str));
-}
-
-int kdf_hex2ctrl(EVP_KDF_IMPL *impl,
-                 int (*ctrl)(EVP_KDF_IMPL *impl, int cmd, va_list args),
-                 int cmd, const char *hex)
-{
-    unsigned char *bin;
-    long binlen;
-    int ret = -1;
-
-    bin = OPENSSL_hexstr2buf(hex, &amp;binlen);
-    if (bin == NULL)
-        return 0;
-
-    if (binlen &lt;= INT_MAX)
-        ret = call_ctrl(ctrl, impl, cmd, bin, (size_t)binlen);
-    OPENSSL_free(bin);
-    return ret;
-}
-
-/* Pass a message digest to a ctrl */
-int kdf_md2ctrl(EVP_KDF_IMPL *impl,
-                int (*ctrl)(EVP_KDF_IMPL *impl, int cmd, va_list args),
-                int cmd, const char *md_name)
-{
-    const EVP_MD *md;
-
-    if (md_name == NULL || (md = EVP_get_digestbyname(md_name)) == NULL) {
-        KDFerr(KDF_F_KDF_MD2CTRL, KDF_R_INVALID_DIGEST);
-        return 0;
-    }
-    return call_ctrl(ctrl, impl, cmd, md);
-}
-
diff --git a/crypto/kdf/pbkdf2.c b/crypto/kdf/pbkdf2.c
deleted file mode 100644
index d41689773c..0000000000
--- a/crypto/kdf/pbkdf2.c
+++ /dev/null
@@ -1,324 +0,0 @@
-/*
- * Copyright 2018-2019 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#include &lt;stdlib.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;string.h&gt;
-#include &lt;openssl/hmac.h&gt;
-#include &lt;openssl/evp.h&gt;
-#include &lt;openssl/kdf.h&gt;
-#include &quot;internal/cryptlib.h&quot;
-#include &quot;internal/evp_int.h&quot;
-#include &quot;kdf_local.h&quot;
-
-/* Constants specified in SP800-132 */
-#define KDF_PBKDF2_MIN_KEY_LEN_BITS  112
-#define KDF_PBKDF2_MAX_KEY_LEN_DIGEST_RATIO 0xFFFFFFFF
-#define KDF_PBKDF2_MIN_ITERATIONS 1000
-#define KDF_PBKDF2_MIN_SALT_LEN   (128 / 8)
-/*
- * For backwards compatibility reasons,
- * Extra checks are done by default in fips mode only.
- */
-#ifdef FIPS_MODE
-# define KDF_PBKDF2_DEFAULT_CHECKS 1
-#else
-# define KDF_PBKDF2_DEFAULT_CHECKS 0
-#endif /* FIPS_MODE */
-
-static void kdf_pbkdf2_reset(EVP_KDF_IMPL *impl);
-static void kdf_pbkdf2_init(EVP_KDF_IMPL *impl);
-static int  pbkdf2_derive(const char *pass, size_t passlen,
-                          const unsigned char *salt, int saltlen, int iter,
-                          const EVP_MD *digest, unsigned char *key,
-                          size_t keylen, int extra_checks);
-
-struct evp_kdf_impl_st {
-    unsigned char *pass;
-    size_t pass_len;
-    unsigned char *salt;
-    size_t salt_len;
-    int iter;
-    const EVP_MD *md;
-    int lower_bound_checks;
-};
-
-static EVP_KDF_IMPL *kdf_pbkdf2_new(void)
-{
-    EVP_KDF_IMPL *impl;
-
-    impl = OPENSSL_zalloc(sizeof(*impl));
-    if (impl == NULL) {
-        KDFerr(KDF_F_KDF_PBKDF2_NEW, ERR_R_MALLOC_FAILURE);
-        return NULL;
-    }
-    kdf_pbkdf2_init(impl);
-    return impl;
-}
-
-static void kdf_pbkdf2_free(EVP_KDF_IMPL *impl)
-{
-    kdf_pbkdf2_reset(impl);
-    OPENSSL_free(impl);
-}
-
-static void kdf_pbkdf2_reset(EVP_KDF_IMPL *impl)
-{
-    OPENSSL_free(impl-&gt;salt);
-    OPENSSL_clear_free(impl-&gt;pass, impl-&gt;pass_len);
-    memset(impl, 0, sizeof(*impl));
-    kdf_pbkdf2_init(impl);
-}
-
-static void kdf_pbkdf2_init(EVP_KDF_IMPL *impl)
-{
-    impl-&gt;iter = PKCS5_DEFAULT_ITER;
-    impl-&gt;md = EVP_sha1();
-    impl-&gt;lower_bound_checks = KDF_PBKDF2_DEFAULT_CHECKS;
-}
-
-static int pbkdf2_set_membuf(unsigned char **buffer, size_t *buflen,
-                             const unsigned char *new_buffer,
-                             size_t new_buflen)
-{
-    if (new_buffer == NULL)
-        return 1;
-
-    OPENSSL_clear_free(*buffer, *buflen);
-
-    if (new_buflen &gt; 0) {
-        *buffer = OPENSSL_memdup(new_buffer, new_buflen);
-    } else {
-        *buffer = OPENSSL_malloc(1);
-    }
-    if (*buffer == NULL) {
-        KDFerr(KDF_F_PBKDF2_SET_MEMBUF, ERR_R_MALLOC_FAILURE);
-        return 0;
-    }
-
-    *buflen = new_buflen;
-    return 1;
-}
-
-static int kdf_pbkdf2_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
-{
-    int iter, pkcs5, min_iter;
-    const unsigned char *p;
-    size_t len;
-    const EVP_MD *md;
-
-    switch (cmd) {
-    case EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE:
-        pkcs5 = va_arg(args, int);
-        impl-&gt;lower_bound_checks = (pkcs5 == 0) ? 1 : 0;
-        return 1;
-    case EVP_KDF_CTRL_SET_PASS:
-        p = va_arg(args, const unsigned char *);
-        len = va_arg(args, size_t);
-        return pbkdf2_set_membuf(&amp;impl-&gt;pass, &amp;impl-&gt;pass_len, p, len);
-
-    case EVP_KDF_CTRL_SET_SALT:
-        p = va_arg(args, const unsigned char *);
-        len = va_arg(args, size_t);
-        if (impl-&gt;lower_bound_checks != 0 &amp;&amp; len &lt; KDF_PBKDF2_MIN_SALT_LEN) {
-            KDFerr(KDF_F_KDF_PBKDF2_CTRL, KDF_R_INVALID_SALT_LEN);
-            return 0;
-        }
-        return pbkdf2_set_membuf(&amp;impl-&gt;salt, &amp;impl-&gt;salt_len, p, len);
-
-    case EVP_KDF_CTRL_SET_ITER:
-        iter = va_arg(args, int);
-        min_iter = impl-&gt;lower_bound_checks != 0 ? KDF_PBKDF2_MIN_ITERATIONS : 1;
-        if (iter &lt; min_iter) {
-            KDFerr(KDF_F_KDF_PBKDF2_CTRL, KDF_R_INVALID_ITERATION_COUNT);
-            return 0;
-        }
-        impl-&gt;iter = iter;
-        return 1;
-
-    case EVP_KDF_CTRL_SET_MD:
-        md = va_arg(args, const EVP_MD *);
-        if (md == NULL) {
-            KDFerr(KDF_F_KDF_PBKDF2_CTRL, KDF_R_VALUE_MISSING);
-            return 0;
-        }
-
-        impl-&gt;md = md;
-        return 1;
-
-    default:
-        return -2;
-    }
-}
-
-static int kdf_pbkdf2_ctrl_str(EVP_KDF_IMPL *impl, const char *type,
-                               const char *value)
-{
-    if (value == NULL) {
-        KDFerr(KDF_F_KDF_PBKDF2_CTRL_STR, KDF_R_VALUE_MISSING);
-        return 0;
-    }
-
-    if (strcmp(type, &quot;pass&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_pbkdf2_ctrl, EVP_KDF_CTRL_SET_PASS,
-                            value);
-
-    if (strcmp(type, &quot;hexpass&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_pbkdf2_ctrl, EVP_KDF_CTRL_SET_PASS,
-                            value);
-
-    if (strcmp(type, &quot;salt&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_pbkdf2_ctrl, EVP_KDF_CTRL_SET_SALT,
-                            value);
-
-    if (strcmp(type, &quot;hexsalt&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_pbkdf2_ctrl, EVP_KDF_CTRL_SET_SALT,
-                            value);
-
-    if (strcmp(type, &quot;iter&quot;) == 0)
-        return call_ctrl(kdf_pbkdf2_ctrl, impl, EVP_KDF_CTRL_SET_ITER,
-                         atoi(value));
-
-    if (strcmp(type, &quot;digest&quot;) == 0)
-        return kdf_md2ctrl(impl, kdf_pbkdf2_ctrl, EVP_KDF_CTRL_SET_MD, value);
-
-    if (strcmp(type, &quot;pkcs5&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_pbkdf2_ctrl,
-                            EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE, value);
-    return -2;
-}
-
-static int kdf_pbkdf2_derive(EVP_KDF_IMPL *impl, unsigned char *key,
-                             size_t keylen)
-{
-    if (impl-&gt;pass == NULL) {
-        KDFerr(KDF_F_KDF_PBKDF2_DERIVE, KDF_R_MISSING_PASS);
-        return 0;
-    }
-
-    if (impl-&gt;salt == NULL) {
-        KDFerr(KDF_F_KDF_PBKDF2_DERIVE, KDF_R_MISSING_SALT);
-        return 0;
-    }
-
-    return pbkdf2_derive((char *)impl-&gt;pass, impl-&gt;pass_len,
-                         impl-&gt;salt, impl-&gt;salt_len, impl-&gt;iter,
-                         impl-&gt;md, key, keylen, impl-&gt;lower_bound_checks);
-}
-
-const EVP_KDF pbkdf2_kdf_meth = {
-    EVP_KDF_PBKDF2,
-    kdf_pbkdf2_new,
-    kdf_pbkdf2_free,
-    kdf_pbkdf2_reset,
-    kdf_pbkdf2_ctrl,
-    kdf_pbkdf2_ctrl_str,
-    NULL,
-    kdf_pbkdf2_derive
-};
-
-/*
- * This is an implementation of PKCS#5 v2.0 password based encryption key
- * derivation function PBKDF2. SHA1 version verified against test vectors
- * posted by Peter Gutmann to the PKCS-TNG mailing list.
- *
- * The constraints specified by SP800-132 have been added i.e.
- *  - Check the range of the key length.
- *  - Minimum iteration count of 1000.
- *  - Randomly-generated portion of the salt shall be at least 128 bits.
- */
-static int pbkdf2_derive(const char *pass, size_t passlen,
-                         const unsigned char *salt, int saltlen, int iter,
-                         const EVP_MD *digest, unsigned char *key,
-                         size_t keylen, int lower_bound_checks)
-{
-    int ret = 0;
-    unsigned char digtmp[EVP_MAX_MD_SIZE], *p, itmp[4];
-    int cplen, j, k, tkeylen, mdlen;
-    unsigned long i = 1;
-    HMAC_CTX *hctx_tpl = NULL, *hctx = NULL;
-
-    mdlen = EVP_MD_size(digest);
-    if (mdlen &lt;= 0)
-        return 0;
-
-    /*
-     * This check should always be done because keylen / mdlen &gt;= (2^32 - 1)
-     * results in an overflow of the loop counter 'i'.
-     */
-    if ((keylen / mdlen) &gt;= KDF_PBKDF2_MAX_KEY_LEN_DIGEST_RATIO) {
-        KDFerr(KDF_F_PBKDF2_DERIVE, KDF_R_INVALID_KEY_LEN);
-        return 0;
-    }
-
-    if (lower_bound_checks) {
-         if ((keylen * 8) &lt; KDF_PBKDF2_MIN_KEY_LEN_BITS) {
-             KDFerr(KDF_F_PBKDF2_DERIVE, KDF_R_INVALID_KEY_LEN);
-             return 0;
-         }
-         if (saltlen &lt; KDF_PBKDF2_MIN_SALT_LEN) {
-             KDFerr(KDF_F_PBKDF2_DERIVE, KDF_R_INVALID_SALT_LEN);
-            return 0;
-         }
-         if (iter &lt; KDF_PBKDF2_MIN_ITERATIONS) {
-             KDFerr(KDF_F_PBKDF2_DERIVE, KDF_R_INVALID_ITERATION_COUNT);
-             return 0;
-         }
-    }
-
-    hctx_tpl = HMAC_CTX_new();
-    if (hctx_tpl == NULL)
-        return 0;
-    p = key;
-    tkeylen = keylen;
-    if (!HMAC_Init_ex(hctx_tpl, pass, passlen, digest, NULL))
-        goto err;
-    hctx = HMAC_CTX_new();
-    if (hctx == NULL)
-        goto err;
-    while (tkeylen) {
-        if (tkeylen &gt; mdlen)
-            cplen = mdlen;
-        else
-            cplen = tkeylen;
-        /*
-         * We are unlikely to ever use more than 256 blocks (5120 bits!) but
-         * just in case...
-         */
-        itmp[0] = (unsigned char)((i &gt;&gt; 24) &amp; 0xff);
-        itmp[1] = (unsigned char)((i &gt;&gt; 16) &amp; 0xff);
-        itmp[2] = (unsigned char)((i &gt;&gt; 8) &amp; 0xff);
-        itmp[3] = (unsigned char)(i &amp; 0xff);
-        if (!HMAC_CTX_copy(hctx, hctx_tpl))
-            goto err;
-        if (!HMAC_Update(hctx, salt, saltlen)
-                || !HMAC_Update(hctx, itmp, 4)
-                || !HMAC_Final(hctx, digtmp, NULL))
-            goto err;
-        memcpy(p, digtmp, cplen);
-        for (j = 1; j &lt; iter; j++) {
-            if (!HMAC_CTX_copy(hctx, hctx_tpl))
-                goto err;
-            if (!HMAC_Update(hctx, digtmp, mdlen)
-                    || !HMAC_Final(hctx, digtmp, NULL))
-                goto err;
-            for (k = 0; k &lt; cplen; k++)
-                p[k] ^= digtmp[k];
-        }
-        tkeylen -= cplen;
-        i++;
-        p += cplen;
-    }
-    ret = 1;
-
-err:
-    HMAC_CTX_free(hctx);
-    HMAC_CTX_free(hctx_tpl);
-    return ret;
-}
diff --git a/crypto/kdf/sshkdf.c b/crypto/kdf/sshkdf.c
deleted file mode 100644
index 4701c9cad1..0000000000
--- a/crypto/kdf/sshkdf.c
+++ /dev/null
@@ -1,292 +0,0 @@
-/*
- * Copyright 2018-2018 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#include &lt;stdlib.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;string.h&gt;
-#include &lt;openssl/evp.h&gt;
-#include &lt;openssl/kdf.h&gt;
-#include &quot;internal/cryptlib.h&quot;
-#include &quot;internal/numbers.h&quot;
-#include &quot;internal/evp_int.h&quot;
-#include &quot;kdf_local.h&quot;
-
-/* See RFC 4253, Section 7.2 */
-
-static void kdf_sshkdf_reset(EVP_KDF_IMPL *impl);
-static int SSHKDF(const EVP_MD *evp_md,
-                  const unsigned char *key, size_t key_len,
-                  const unsigned char *xcghash, size_t xcghash_len,
-                  const unsigned char *session_id, size_t session_id_len,
-                  char type, unsigned char *okey, size_t okey_len);
-
-struct evp_kdf_impl_st {
-    const EVP_MD *md;
-    unsigned char *key; /* K */
-    size_t key_len;
-    unsigned char *xcghash; /* H */
-    size_t xcghash_len;
-    char type; /* X */
-    unsigned char *session_id;
-    size_t session_id_len;
-};
-
-static EVP_KDF_IMPL *kdf_sshkdf_new(void)
-{
-    EVP_KDF_IMPL *impl;
-
-    if ((impl = OPENSSL_zalloc(sizeof(*impl))) == NULL)
-        KDFerr(KDF_F_KDF_SSHKDF_NEW, ERR_R_MALLOC_FAILURE);
-    return impl;
-}
-
-static void kdf_sshkdf_free(EVP_KDF_IMPL *impl)
-{
-    kdf_sshkdf_reset(impl);
-    OPENSSL_free(impl);
-}
-
-static void kdf_sshkdf_reset(EVP_KDF_IMPL *impl)
-{
-    OPENSSL_clear_free(impl-&gt;key, impl-&gt;key_len);
-    OPENSSL_clear_free(impl-&gt;xcghash, impl-&gt;xcghash_len);
-    OPENSSL_clear_free(impl-&gt;session_id, impl-&gt;session_id_len);
-    memset(impl, 0, sizeof(*impl));
-}
-
-static int kdf_sshkdf_parse_buffer_arg(unsigned char **dst, size_t *dst_len,
-                                       va_list args)
-{
-    const unsigned char *p;
-    size_t len;
-
-    p = va_arg(args, const unsigned char *);
-    len = va_arg(args, size_t);
-    OPENSSL_clear_free(*dst, *dst_len);
-    *dst = OPENSSL_memdup(p, len);
-    if (*dst == NULL)
-        return 0;
-
-    *dst_len = len;
-    return 1;
-}
-
-static int kdf_sshkdf_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
-{
-    int t;
-
-    switch (cmd) {
-    case EVP_KDF_CTRL_SET_MD:
-        impl-&gt;md = va_arg(args, const EVP_MD *);
-        if (impl-&gt;md == NULL)
-            return 0;
-
-        return 1;
-
-    case EVP_KDF_CTRL_SET_KEY:
-        return kdf_sshkdf_parse_buffer_arg(&amp;impl-&gt;key,
-                                           &amp;impl-&gt;key_len, args);
-
-    case EVP_KDF_CTRL_SET_SSHKDF_XCGHASH:
-        return kdf_sshkdf_parse_buffer_arg(&amp;impl-&gt;xcghash,
-                                           &amp;impl-&gt;xcghash_len, args);
-
-    case EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID:
-        return kdf_sshkdf_parse_buffer_arg(&amp;impl-&gt;session_id,
-                                           &amp;impl-&gt;session_id_len, args);
-
-    case EVP_KDF_CTRL_SET_SSHKDF_TYPE:
-        t = va_arg(args, int);
-        if (t &lt; 65 || t &gt; 70) {
-            KDFerr(KDF_F_KDF_SSHKDF_CTRL, KDF_R_VALUE_ERROR);
-            return 0;
-        }
-
-        impl-&gt;type = (char)t;
-        return 1;
-
-    default:
-        return -2;
-
-    }
-}
-
-static int kdf_sshkdf_ctrl_str(EVP_KDF_IMPL *impl, const char *type,
-                               const char *value)
-{
-    if (value == NULL) {
-        KDFerr(KDF_F_KDF_SSHKDF_CTRL_STR, KDF_R_VALUE_MISSING);
-        return 0;
-    }
-
-    if (strcmp(type, &quot;digest&quot;) == 0)
-        return kdf_md2ctrl(impl, kdf_sshkdf_ctrl, EVP_KDF_CTRL_SET_MD, value);
-    /* alias, for historical reasons */
-    if (strcmp(type, &quot;md&quot;) == 0)
-        return kdf_md2ctrl(impl, kdf_sshkdf_ctrl, EVP_KDF_CTRL_SET_MD, value);
-
-    if (strcmp(type, &quot;key&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_sshkdf_ctrl,
-                            EVP_KDF_CTRL_SET_KEY, value);
-
-    if (strcmp(type, &quot;hexkey&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_sshkdf_ctrl,
-                            EVP_KDF_CTRL_SET_KEY, value);
-
-    if (strcmp(type, &quot;xcghash&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_sshkdf_ctrl,
-                            EVP_KDF_CTRL_SET_SSHKDF_XCGHASH, value);
-
-    if (strcmp(type, &quot;hexxcghash&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_sshkdf_ctrl,
-                            EVP_KDF_CTRL_SET_SSHKDF_XCGHASH, value);
-
-    if (strcmp(type, &quot;session_id&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_sshkdf_ctrl,
-                            EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID, value);
-
-    if (strcmp(type, &quot;hexsession_id&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_sshkdf_ctrl,
-                            EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID, value);
-
-    if (strcmp(type, &quot;type&quot;) == 0) {
-        if (strlen(value) != 1) {
-            KDFerr(KDF_F_KDF_SSHKDF_CTRL_STR, KDF_R_VALUE_ERROR);
-            return 0;
-        }
-
-        return call_ctrl(kdf_sshkdf_ctrl, impl, EVP_KDF_CTRL_SET_SSHKDF_TYPE,
-                         (int)value[0]);
-    }
-
-    KDFerr(KDF_F_KDF_SSHKDF_CTRL_STR, KDF_R_UNKNOWN_PARAMETER_TYPE);
-    return -2;
-}
-
-static size_t kdf_sshkdf_size(EVP_KDF_IMPL *impl)
-{
-    return SIZE_MAX;
-}
-
-static int kdf_sshkdf_derive(EVP_KDF_IMPL *impl, unsigned char *key,
-                             size_t keylen)
-{
-    if (impl-&gt;md == NULL) {
-        KDFerr(KDF_F_KDF_SSHKDF_DERIVE, KDF_R_MISSING_MESSAGE_DIGEST);
-        return 0;
-    }
-    if (impl-&gt;key == NULL) {
-        KDFerr(KDF_F_KDF_SSHKDF_DERIVE, KDF_R_MISSING_KEY);
-        return 0;
-    }
-    if (impl-&gt;xcghash == NULL) {
-        KDFerr(KDF_F_KDF_SSHKDF_DERIVE, KDF_R_MISSING_XCGHASH);
-        return 0;
-    }
-    if (impl-&gt;session_id == NULL) {
-        KDFerr(KDF_F_KDF_SSHKDF_DERIVE, KDF_R_MISSING_SESSION_ID);
-        return 0;
-    }
-    if (impl-&gt;type == 0) {
-        KDFerr(KDF_F_KDF_SSHKDF_DERIVE, KDF_R_MISSING_TYPE);
-        return 0;
-    }
-    return SSHKDF(impl-&gt;md, impl-&gt;key, impl-&gt;key_len,
-                  impl-&gt;xcghash, impl-&gt;xcghash_len,
-                  impl-&gt;session_id, impl-&gt;session_id_len,
-                  impl-&gt;type, key, keylen);
-}
-
-const EVP_KDF sshkdf_kdf_meth = {
-    EVP_KDF_SSHKDF,
-    kdf_sshkdf_new,
-    kdf_sshkdf_free,
-    kdf_sshkdf_reset,
-    kdf_sshkdf_ctrl,
-    kdf_sshkdf_ctrl_str,
-    kdf_sshkdf_size,
-    kdf_sshkdf_derive,
-};
-
-static int SSHKDF(const EVP_MD *evp_md,
-                  const unsigned char *key, size_t key_len,
-                  const unsigned char *xcghash, size_t xcghash_len,
-                  const unsigned char *session_id, size_t session_id_len,
-                  char type, unsigned char *okey, size_t okey_len)
-{
-    EVP_MD_CTX *md = NULL;
-    unsigned char digest[EVP_MAX_MD_SIZE];
-    unsigned int dsize = 0;
-    size_t cursize = 0;
-    int ret = 0;
-
-    md = EVP_MD_CTX_new();
-    if (md == NULL)
-        return 0;
-
-    if (!EVP_DigestInit_ex(md, evp_md, NULL))
-        goto out;
-
-    if (!EVP_DigestUpdate(md, key, key_len))
-        goto out;
-
-    if (!EVP_DigestUpdate(md, xcghash, xcghash_len))
-        goto out;
-
-    if (!EVP_DigestUpdate(md, &amp;type, 1))
-        goto out;
-
-    if (!EVP_DigestUpdate(md, session_id, session_id_len))
-        goto out;
-
-    if (!EVP_DigestFinal_ex(md, digest, &amp;dsize))
-        goto out;
-
-    if (okey_len &lt; dsize) {
-        memcpy(okey, digest, okey_len);
-        ret = 1;
-        goto out;
-    }
-
-    memcpy(okey, digest, dsize);
-
-    for (cursize = dsize; cursize &lt; okey_len; cursize += dsize) {
-
-        if (!EVP_DigestInit_ex(md, evp_md, NULL))
-            goto out;
-
-        if (!EVP_DigestUpdate(md, key, key_len))
-            goto out;
-
-        if (!EVP_DigestUpdate(md, xcghash, xcghash_len))
-            goto out;
-
-        if (!EVP_DigestUpdate(md, okey, cursize))
-            goto out;
-
-        if (!EVP_DigestFinal_ex(md, digest, &amp;dsize))
-            goto out;
-
-        if (okey_len &lt; cursize + dsize) {
-            memcpy(okey + cursize, digest, okey_len - cursize);
-            ret = 1;
-            goto out;
-        }
-
-        memcpy(okey + cursize, digest, dsize);
-    }
-
-    ret = 1;
-
-out:
-    EVP_MD_CTX_free(md);
-    OPENSSL_cleanse(digest, EVP_MAX_MD_SIZE);
-    return ret;
-}
-
diff --git a/crypto/params_from_text.c b/crypto/params_from_text.c
index 72770ddc53..053b93d2c3 100644
--- a/crypto/params_from_text.c
+++ b/crypto/params_from_text.c
@@ -107,48 +107,49 @@ static int construct_from_text(OSSL_PARAM *to, const OSSL_PARAM *paramdef,
     if (buf == NULL)
         return 0;
 
-    switch (paramdef-&gt;data_type) {
-    case OSSL_PARAM_INTEGER:
-    case OSSL_PARAM_UNSIGNED_INTEGER:
-        /*
-        {
-            if ((new_value = OPENSSL_malloc(new_value_n)) == NULL) {
-                BN_free(a);
-                break;
+    if (buf_n &gt; 0) {
+        switch (paramdef-&gt;data_type) {
+        case OSSL_PARAM_INTEGER:
+        case OSSL_PARAM_UNSIGNED_INTEGER:
+            /*
+            {
+                if ((new_value = OPENSSL_malloc(new_value_n)) == NULL) {
+                    BN_free(a);
+                    break;
+                }
+            */
+
+            BN_bn2nativepad(tmpbn, buf, buf_n);
+
+            /*
+             * 2s complement negate, part two.
+             *
+             * Because we did the first part on the BIGNUM itself, we can just
+             * invert all the bytes here and be done with it.
+             */
+            if (paramdef-&gt;data_type == OSSL_PARAM_INTEGER
+                &amp;&amp; BN_is_negative(tmpbn)) {
+                unsigned char *cp;
+                size_t i = buf_n;
+
+                for (cp = buf; i-- &gt; 0; cp++)
+                    *cp ^= 0xFF;
             }
-        */
-
-        BN_bn2nativepad(tmpbn, buf, buf_n);
-
-        /*
-         * 2s complement negate, part two.
-         *
-         * Because we did the first part on the BIGNUM itself, we can just
-         * invert all the bytes here and be done with it.
-         */
-        if (paramdef-&gt;data_type == OSSL_PARAM_INTEGER
-            &amp;&amp; BN_is_negative(tmpbn)) {
-            unsigned char *cp;
-            size_t i = buf_n;
-
-            for (cp = buf; i-- &gt; 0; cp++)
-                *cp ^= 0xFF;
-        }
-        break;
-    case OSSL_PARAM_UTF8_STRING:
-        strncpy(buf, value, buf_n);
-        break;
-    case OSSL_PARAM_OCTET_STRING:
-        if (ishex) {
-            size_t l = 0;
-
-            if (!OPENSSL_hexstr2buf_ex(buf, buf_n, &amp;l, value))
-                return 0;
-        } else {
-            memcpy(buf, value, buf_n);
-
+            break;
+        case OSSL_PARAM_UTF8_STRING:
+            strncpy(buf, value, buf_n);
+            break;
+        case OSSL_PARAM_OCTET_STRING:
+            if (ishex) {
+                size_t l = 0;
+
+                if (!OPENSSL_hexstr2buf_ex(buf, buf_n, &amp;l, value))
+                    return 0;
+            } else {
+                memcpy(buf, value, buf_n);
+            }
+            break;
         }
-        break;
     }
 
     *to = *paramdef;
@@ -209,7 +210,7 @@ int OSSL_PARAM_allocate_from_text(OSSL_PARAM *to,
                            &amp;paramdef, &amp;ishex, &amp;buf_n, &amp;tmpbn))
         return 0;
 
-    if ((buf = OPENSSL_malloc(buf_n)) == NULL) {
+    if ((buf = OPENSSL_zalloc(buf_n &gt; 0 ? buf_n : 1)) == NULL) {
         CRYPTOerr(0, ERR_R_MALLOC_FAILURE);
         return 0;
     }
@@ -217,5 +218,7 @@ int OSSL_PARAM_allocate_from_text(OSSL_PARAM *to,
     ok = construct_from_text(to, paramdef, value, value_n, ishex,
                              buf, buf_n, tmpbn);
     BN_free(tmpbn);
+    if (!ok)
+        OPENSSL_free(buf);
     return ok;
 }
diff --git a/crypto/provider_core.c b/crypto/provider_core.c
index 541a1e169b..356327f375 100644
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -709,7 +709,8 @@ const char *ossl_provider_module_path(const OSSL_PROVIDER *prov)
 
 OPENSSL_CTX *ossl_provider_library_context(const OSSL_PROVIDER *prov)
 {
-    return prov-&gt;libctx;
+    /* TODO(3.0) just: return prov-&gt;libctx; */
+    return prov != NULL ? prov-&gt;libctx : NULL;
 }
 
 /* Wrappers around calls to the provider */
diff --git a/doc/man1/openssl-kdf.pod b/doc/man1/openssl-kdf.pod
index e85157104e..a2b0f25d25 100644
--- a/doc/man1/openssl-kdf.pod
+++ b/doc/man1/openssl-kdf.pod
@@ -144,13 +144,13 @@ used when building OpenSSL.
 
 L&lt;openssl(1)&gt;,
 L&lt;openssl-pkeyutl(1)&gt;
-L&lt;EVP_KDF_CTX(3)&gt;,
-L&lt;EVP_KDF_SCRYPT(7)&gt;
-L&lt;EVP_KDF_TLS1_PRF(7)&gt;
-L&lt;EVP_KDF_PBKDF2(7)&gt;
-L&lt;EVP_KDF_HKDF(7)&gt;
-L&lt;EVP_KDF_SS(7)&gt;
-L&lt;EVP_KDF_SSHKDF(7)&gt;
+L&lt;EVP_KDF(3)&gt;,
+L&lt;EVP_KDF-SCRYPT(7)&gt;
+L&lt;EVP_KDF-TLS1_PRF(7)&gt;
+L&lt;EVP_KDF-PBKDF2(7)&gt;
+L&lt;EVP_KDF-HKDF(7)&gt;
+L&lt;EVP_KDF-SS(7)&gt;
+L&lt;EVP_KDF-SSHKDF(7)&gt;
 
 =head1 HISTORY
 
diff --git a/doc/man1/openssl-list.pod b/doc/man1/openssl-list.pod
index a098f26605..3a3c5ab4a9 100644
--- a/doc/man1/openssl-list.pod
+++ b/doc/man1/openssl-list.pod
@@ -13,6 +13,7 @@ B&lt;openssl list&gt;
 [B&lt;-commands&gt;]
 [B&lt;-digest-commands&gt;]
 [B&lt;-digest-algorithms&gt;]
+[B&lt;-kdf-algorithms&gt;]
 [B&lt;-mac-algorithms&gt;]
 [B&lt;-cipher-commands&gt;]
 [B&lt;-cipher-algorithms&gt;]
@@ -64,11 +65,13 @@ B&lt;bar&gt;.
 In verbose mode, the algorithms provided by a provider will get additional
 information on what parameters each implementation supports.
 
+=item B&lt;-kdf-algorithms&gt;
+
+Display a list of key derivation function algorithms.
+
 =item B&lt;-mac-algorithms&gt;
 
 Display a list of message authentication code algorithms.
-If a line is of the form C&lt;foo =E&lt;gt&gt; bar&gt; then B&lt;foo&gt; is an alias for the
-official algorithm name, B&lt;bar&gt;.
 
 =item B&lt;-cipher-commands&gt;
 
@@ -93,8 +96,7 @@ a block of multiple lines, all but the first are indented.
 
 =item B&lt;-public-key-methods&gt;
 
-Display a list of public key method OIDs: this also includes public key methods
-without an associated ASN.1 method, for example, KDF algorithms.
+Display a list of public key method OIDs.
 
 =item B&lt;-engines&gt;
 
diff --git a/doc/man3/EVP_KDF.pod b/doc/man3/EVP_KDF.pod
new file mode 100644
index 0000000000..fc09d5fad8
--- /dev/null
+++ b/doc/man3/EVP_KDF.pod
@@ -0,0 +1,259 @@
+=pod
+
+=head1 NAME
+
+EVP_KDF, EVP_KDF_fetch, EVP_KDF_free, EVP_KDF_provider, EVP_KDF_up_ref,
+EVP_KDF_name,
+EVP_KDF_CTX, EVP_KDF_CTX_new, EVP_KDF_CTX_free, EVP_KDF_CTX_kdf,
+EVP_KDF_reset, EVP_KDF_size, EVP_KDF_derive, EVP_KDF_CTX_dup,
+EVP_KDF_CTX_get_params, EVP_KDF_CTX_set_params, EVP_KDF_do_all_ex,
+EVP_KDF_get_params, EVP_KDF_CTX_gettable_params, EVP_KDF_CTX_settable_params,
+EVP_KDF_gettable_params - EVP KDF routines
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/kdf.h&gt;
+
+ typedef struct evp_kdf_st EVP_KDF;
+ typedef struct evp_kdf_ctx_st EVP_KDF_CTX;
+
+ EVP_KDF_CTX *EVP_KDF_CTX_new(const EVP_KDF *kdf);
+ const EVP_KDF *EVP_KDF_CTX_kdf(EVP_KDF_CTX *ctx);
+ void EVP_KDF_CTX_free(EVP_KDF_CTX *ctx);
+ EVP_KDF_CTX *EVP_KDF_CTX_dup(const EVP_KDF_CTX *src);
+ void EVP_KDF_reset(EVP_KDF_CTX *ctx);
+ size_t EVP_KDF_size(EVP_KDF_CTX *ctx);
+ int EVP_KDF_derive(EVP_KDF_CTX *ctx, unsigned char *key, size_t keylen);
+ const char *EVP_KDF_name(const EVP_KDF *kdf);
+ int EVP_KDF_up_ref(EVP_KDF *kdf);
+ void EVP_KDF_free(EVP_KDF *kdf);
+ EVP_KDF *EVP_KDF_fetch(OPENSSL_CTX *libctx, const char *algorithm,
+                        const char *properties);
+ void EVP_KDF_do_all_ex(OPENSSL_CTX *libctx,
+                        void (*fn)(EVP_KDF *kdf, void *arg),
+                        void *arg);
+ int EVP_KDF_get_params(EVP_KDF *kdf, OSSL_PARAM params[]);
+ int EVP_KDF_CTX_get_params(EVP_KDF_CTX *ctx, OSSL_PARAM params[]);
+ int EVP_KDF_CTX_set_params(EVP_KDF_CTX *ctx, const OSSL_PARAM params[]);
+ const OSSL_PARAM *EVP_KDF_gettable_params(const EVP_KDF *kdf);
+ const OSSL_PARAM *EVP_KDF_CTX_gettable_params(const EVP_KDF *kdf);
+ const OSSL_PARAM *EVP_KDF_CTX_settable_params(const EVP_KDF *kdf);
+ const OSSL_PROVIDER *EVP_KDF_provider(const EVP_KDF *kdf);
+
+=head1 DESCRIPTION
+
+The EVP KDF routines are a high level interface to Key Derivation Function
+algorithms and should be used instead of algorithm-specific functions.
+
+After creating a B&lt;EVP_KDF_CTX&gt; for the required algorithm using
+EVP_KDF_CTX_new(), inputs to the algorithm are supplied
+using calls to EVP_KDF_CTX_set_params() before
+calling EVP_KDF_derive() to derive the key.
+
+=head2 Types
+
+B&lt;EVP_KDF&gt; is a type that holds the implementation of a KDF.
+
+B&lt;EVP_KDF_CTX&gt; is a context type that holds the algorithm inputs.
+
+=head2 Algorithm implementation fetching
+
+EVP_KDF_fetch() fetches an implementation of a KDF I&lt;algorithm&gt;, given
+a library context I&lt;libctx&gt; and a set of I&lt;properties&gt;.
+See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+
+The returned value must eventually be freed with
+L&lt;EVP_KDF_free(3)&gt;.
+
+EVP_KDF_up_ref() increments the reference count of an already fetched
+KDF.
+
+EVP_KDF_free() frees a fetched algorithm.
+NULL is a valid parameter, for which this function is a no-op.
+
+=head2 Context manipulation functions
+
+EVP_KDF_CTX_new() creates a new context for the KDF implementation I&lt;kdf&gt;.
+
+EVP_KDF_CTX_free() frees up the context C&lt;ctx&gt;.  If I&lt;ctx&gt; is NULL, nothing
+is done.
+
+EVP_KDF_CTX_kdf() returns the B&lt;EVP_KDF&gt; associated with the context
+I&lt;ctx&gt;.
+
+=head2 Computing functions
+
+EVP_KDF_reset() resets the context to the default state as if the context
+had just been created.
+
+EVP_KDF_derive() derives C&lt;keylen&gt; bytes of key material and places it in the
+I&lt;key&gt; buffer.  If the algorithm produces a fixed amount of output then an
+error will occur unless the C&lt;keylen&gt; parameter is equal to that output size,
+as returned by EVP_KDF_size().
+
+EVP_KDF_get_params() retrieves details about the implementation
+I&lt;kdf&gt;.
+The set of parameters given with I&lt;params&gt; determine exactly what
+parameters should be retrieved.
+Note that a parameter that is unknown in the underlying context is
+simply ignored.
+
+EVP_KDF_CTX_get_params() retrieves chosen parameters, given the
+context I&lt;ctx&gt; and its underlying context.
+The set of parameters given with I&lt;params&gt; determine exactly what
+parameters should be retrieved.
+Note that a parameter that is unknown in the underlying context is
+simply ignored.
+
+EVP_KDF_CTX_set_params() passes chosen parameters to the underlying
+context, given a context I&lt;ctx&gt;.
+The set of parameters given with I&lt;params&gt; determine exactly what
+parameters are passed down.
+Note that a parameter that is unknown in the underlying context is
+simply ignored.
+Also, what happens when a needed parameter isn't passed down is
+defined by the implementation.
+
+EVP_KDF_gettable_params(), EVP_KDF_CTX_gettable_params() and
+EVP_KDF_CTX_settable_params() get a constant B&lt;OSSL_PARAM&gt; array that
+decribes the retrievable and settable parameters, i.e. parameters that
+can be used with EVP_KDF_get_params(), EVP_KDF_CTX_get_params()
+and EVP_KDF_CTX_set_params(), respectively.
+See L&lt;OSSL_PARAM(3)&gt; for the use of B&lt;OSSL_PARAM&gt; as parameter descriptor.
+
+=head2 Information functions
+
+EVP_KDF_size() returns the output size if the algorithm produces a fixed amount
+of output and B&lt;SIZE_MAX&gt; otherwise.  If an error occurs then 0 is returned.
+For some algorithms an error may result if input parameters necessary to
+calculate a fixed output size have not yet been supplied.
+
+EVP_KDF_name() returns the name of the given KDF implementation.
+
+EVP_KDF_provider() returns the provider that holds the implementation
+of the given I&lt;kdf&gt;.
+
+EVP_KDF_do_all_ex() traverses all KDF implemented by all activated
+providers in the given library context I&lt;libctx&gt;, and for each of the
+implementations, calls the given function I&lt;fn&gt; with the implementation method
+and the given I&lt;arg&gt; as argument.
+
+=head1 PARAMETER NAMES
+
+The standard parameter names are:
+
+=over 4
+
+=item B&lt;OSSL_KDF_PARAM_PASSWORD&gt; (&quot;pass&quot;) &lt;octet string&gt;
+
+Some KDF implementations require a password.
+For those KDF implementations that support it, this parameter sets the password.
+
+=item B&lt;OSSL_KDF_PARAM_SALT&gt; (&quot;salt&quot;) &lt;octet string&gt;
+
+Some KDF implementations can take a salt.
+For those KDF implementations that support it, this parameter sets the salt.
+
+The default value, if any, is implementation dependent.
+
+=item B&lt;OSSL_KDF_PARAM_ITER&gt; (&quot;iter&quot;) &lt;unsigned int&gt;
+
+Some KDF implementations require an iteration count.
+For those KDF implementations that support it, this parameter sets the
+iteration count.
+
+The default value, if any, is implementation dependent.
+
+=item B&lt;OSSL_KDF_PARAM_PROPERTIES&gt; (&quot;properties&quot;) &lt;UTF8 string&gt;
+
+Some KDF implementations use other cryptographic algorithms, this parameter
+sets what property query will be used to fetch the implementation.
+
+=item B&lt;OSSL_KDF_PARAM_MAC&gt; (&quot;mac&quot;) &lt;UTF8 string&gt;
+
+Some KDF implementations use a MAC as an underlying computation
+algorithm, this parameter sets what the MAC algorithm should be.
+
+=item B&lt;OSSL_KDF_PARAM_DIGEST&gt; (&quot;digest&quot;) &lt;UTF8 string&gt;
+
+For MAC implementations that use a message digest as an underlying computation
+algorithm, this parameter sets what the digest algorithm should be.
+
+=item B&lt;OSSL_KDF_PARAM_KEY&gt; (&quot;key&quot;) &lt;octet string&gt;
+
+Some KDF implementations require a key.
+For those KDF implementations that support it, this octet string parameter
+sets the key.
+
+=item B&lt;OSSL_KDF_PARAM_MAC_SIZE&gt; (&quot;maclen&quot;) &lt;size_t&gt;
+
+Used by implementations that use a MAC with a variable output size (KMAC).
+For those KDF implementations that support it, this parameter
+sets the MAC output size.
+
+The default value, if any, is implementation dependent.
+
+=item B&lt;OSSL_KDF_PARAM_SCRYPT_MAXMEM&gt; (&quot;macmaxmem_byteslen&quot;) &lt;size_t&gt;
+
+Memory-hard password-based KDF algorithms, such as scrypt, use an amount of
+memory that depends on the load factors provided as input.
+For those KDF implementations that support it, this uint64_t parameter sets
+an upper limit on the amount of memory that may be consumed while performing
+a key derivation.
+If this memory usage limit is exceeded because the load factors are chosen
+too high, the key derivation will fail.
+
+The default value is implementation dependent.
+
+=back
+
+=head1 RETURN VALUES
+
+EVP_MAC_fetch() returns a pointer to a newly fetched B&lt;EVP_KDF&gt;, or
+NULL if allocation failed.
+
+EVP_KDF_name() returns the name for the given I&lt;kdf&gt;, if it has been
+added to the object database.
+
+EVP_KDF_provider() returns a pointer to the provider for the KDF, or
+NULL on error.
+
+EVP_MAC_up_ref() returns 1 on success, 0 on error.
+
+EVP_KDF_CTX_new() returns either the newly allocated
+C&lt;EVP_KDF_CTX&gt; structure or C&lt;NULL&gt; if an error occurred.
+
+EVP_KDF_CTX_free() and EVP_KDF_reset() do not return a value.
+
+EVP_KDF_size() returns the output size.  C&lt;SIZE_MAX&gt; is returned to indicate
+that the algorithm produces a variable amount of output; 0 to indicate failure.
+
+The remaining functions return 1 for success and 0 or a negative value for
+failure.  In particular, a return value of -2 indicates the operation is not
+supported by the KDF algorithm.
+
+=head1 SEE ALSO
+
+L&lt;EVP_KDF-SCRYPT(7)&gt;
+L&lt;EVP_KDF-TLS1_PRF(7)&gt;
+L&lt;EVP_KDF-PBKDF2(7)&gt;
+L&lt;EVP_KDF-HKDF(7)&gt;
+L&lt;EVP_KDF-SS(7)&gt;
+L&lt;EVP_KDF-SSHKDF(7)&gt;
+L&lt;EVP_KDF-X963(7)&gt;
+L&lt;EVP_KDF-X942(7)&gt;
+
+=head1 HISTORY
+
+This functionality was added to OpenSSL 3.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man3/EVP_KDF_CTX.pod b/doc/man3/EVP_KDF_CTX.pod
deleted file mode 100644
index 1ae79bc1bd..0000000000
--- a/doc/man3/EVP_KDF_CTX.pod
+++ /dev/null
@@ -1,296 +0,0 @@
-=pod
-
-=head1 NAME
-
-EVP_KDF, EVP_KDF_CTX, EVP_KDF_CTX_new, EVP_KDF_CTX_new_id, EVP_KDF_CTX_free,
-EVP_KDF_CTX_kdf, EVP_KDF_reset, EVP_KDF_ctrl, EVP_KDF_vctrl, EVP_KDF_ctrl_str,
-EVP_KDF_size, EVP_KDF_derive, EVP_KDF_nid, EVP_KDF_name,
-EVP_get_kdfbyname, EVP_get_kdfbynid, EVP_get_kdfbyobj - EVP KDF routines
-
-=head1 SYNOPSIS
-
- #include &lt;openssl/kdf.h&gt;
-
- typedef struct evp_kdf_st EVP_KDF;
- typedef struct evp_kdf_ctx_st EVP_KDF_CTX;
-
- EVP_KDF_CTX *EVP_KDF_CTX_new(const EVP_KDF *kdf);
- EVP_KDF_CTX *EVP_KDF_CTX_new_id(int nid);
- const EVP_KDF *EVP_KDF_CTX_kdf(EVP_KDF_CTX *ctx);
- void EVP_KDF_CTX_free(EVP_KDF_CTX *ctx);
- void EVP_KDF_reset(EVP_KDF_CTX *ctx);
- int EVP_KDF_ctrl(EVP_KDF_CTX *ctx, int cmd, ...);
- int EVP_KDF_vctrl(EVP_KDF_CTX *ctx, int cmd, va_list args);
- int EVP_KDF_ctrl_str(EVP_KDF_CTX *ctx, const char *type, const char *value);
- size_t EVP_KDF_size(EVP_KDF_CTX *ctx);
- int EVP_KDF_derive(EVP_KDF_CTX *ctx, unsigned char *key, size_t keylen);
- int EVP_KDF_nid(const EVP_KDF *kdf);
- const char *EVP_KDF_name(const EVP_KDF *kdf);
- const EVP_KDF *EVP_get_kdfbyname(const char *name);
- const EVP_KDF *EVP_get_kdfbynid(int nid);
- const EVP_KDF *EVP_get_kdfbyobj(const ASN1_OBJECT *o);
-
-=head1 DESCRIPTION
-
-The EVP KDF routines are a high level interface to Key Derivation Function
-algorithms and should be used instead of algorithm-specific functions.
-
-After creating a C&lt;EVP_KDF_CTX&gt; for the required algorithm using either
-EVP_KDF_CTX_new() or EVP_KDF_CTX_new_id(), inputs to the algorithm are supplied
-using calls to EVP_KDF_ctrl(), EVP_KDF_vctrl() or EVP_KDF_ctrl_str() before
-calling EVP_KDF_derive() to derive the key.
-
-=head2 Types
-
-B&lt;EVP_KDF&gt; is a type that holds the implementation of a KDF.
-
-B&lt;EVP_KDF_CTX&gt; is a context type that holds the algorithm inputs.
-
-=head2 Context manipulation functions
-
-EVP_KDF_CTX_new() creates a new context for the KDF type C&lt;kdf&gt;.
-
-EVP_KDF_CTX_new_id() creates a new context for the numerical KDF identity C&lt;nid&gt;.
-
-EVP_KDF_CTX_free() frees up the context C&lt;ctx&gt;.  If C&lt;ctx&gt; is C&lt;NULL&gt;, nothing
-is done.
-
-EVP_KDF_CTX_kdf() returns the B&lt;EVP_KDF&gt; associated with the context
-C&lt;ctx&gt;.
-
-=head2 Computing functions
-
-EVP_KDF_reset() resets the context to the default state as if the context
-had just been created.
-
-EVP_KDF_ctrl() is used to provide inputs to the KDF algorithm prior to
-EVP_KDF_derive() being called.  The inputs that may be provided will vary
-depending on the KDF algorithm or its implementation.  This functions takes
-variable arguments, the exact expected arguments depend on C&lt;cmd&gt;.
-See L&lt;/CONTROLS&gt; below for a description of standard controls.
-
-EVP_KDF_vctrl() is the variant of EVP_KDF_ctrl() that takes a C&lt;va_list&gt;
-argument instead of variadic arguments.
-
-EVP_KDF_ctrl_str() allows an application to send an algorithm specific control
-operation to a context C&lt;ctx&gt; in string form.  This is intended to be used for
-options specified on the command line or in text files.
-
-EVP_KDF_derive() derives C&lt;keylen&gt; bytes of key material and places it in the
-C&lt;key&gt; buffer.  If the algorithm produces a fixed amount of output then an
-error will occur unless the C&lt;keylen&gt; parameter is equal to that output size,
-as returned by EVP_KDF_size().
-
-=head2 Information functions
-
-EVP_KDF_size() returns the output size if the algorithm produces a fixed amount
-of output and C&lt;SIZE_MAX&gt; otherwise.  If an error occurs then 0 is returned.
-For some algorithms an error may result if input parameters necessary to
-calculate a fixed output size have not yet been supplied.
-
-EVP_KDF_nid() returns the numeric identity of the given KDF implementation.
-
-EVP_KDF_name() returns the name of the given KDF implementation.
-
-=head2 Object database functions
-
-EVP_get_kdfbyname() fetches a KDF implementation from the object
-database by name.
-
-EVP_get_kdfbynid() fetches a KDF implementation from the object
-database by numeric identity.
-
-EVP_get_kdfbyobj() fetches a KDF implementation from the object
-database by ASN.1 OBJECT (i.e. an encoded OID).
-
-=head1 CONTROLS
-
-The standard controls are:
-
-=over 4
-
-=item B&lt;EVP_KDF_CTRL_SET_PASS&gt;
-
-This control expects two arguments: C&lt;unsigned char *pass&gt;, C&lt;size_t passlen&gt;
-
-Some KDF implementations require a password.  For those KDF implementations
-that support it, this control sets the password.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;pass&quot;
-
-The value string is used as is.
-
-=item &quot;hexpass&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=item B&lt;EVP_KDF_CTRL_SET_SALT&gt;
-
-This control expects two arguments: C&lt;unsigned char *salt&gt;, C&lt;size_t saltlen&gt;
-
-Some KDF implementations can take a salt.  For those KDF implementations that
-support it, this control sets the salt.
-
-The default value, if any, is implementation dependent.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;salt&quot;
-
-The value string is used as is.
-
-=item &quot;hexsalt&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=item B&lt;EVP_KDF_CTRL_SET_ITER&gt;
-
-This control expects one argument: C&lt;int iter&gt;
-
-Some KDF implementations require an iteration count. For those KDF implementations that support it, this control sets the iteration count.
-
-The default value, if any, is implementation dependent.
-
-EVP_KDF_ctrl_str() type string: &quot;iter&quot;
-
-The value string is expected to be a decimal number.
-
-=item B&lt;EVP_KDF_CTRL_SET_MAC&gt;
-
-This control expects one argument: C&lt;EVP_MAC *mac&gt;
-
-Some KDF implementations use a MAC as an underlying computation
-algorithm, this control sets what the MAC algorithm should be.
-
-EVP_KDF_ctrl_str() type string: &quot;mac&quot;
-
-The value string is expected to be the name of a MAC.
-
-=item B&lt;EVP_KDF_CTRL_SET_MD&gt;
-
-This control expects one argument: C&lt;EVP_MD *md&gt;
-
-For MAC implementations that use a message digest as an underlying computation
-algorithm, this control sets what the digest algorithm should be.
-
-EVP_KDF_ctrl_str() type string: &quot;digest&quot;
-
-The value string is expected to be the name of a digest.
-
-=item B&lt;EVP_KDF_CTRL_SET_KEY&gt;
-
-This control expects two arguments: C&lt;unsigned char *key&gt;, C&lt;size_t keylen&gt;
-
-Some KDF implementations require a key.  For those KDF implementations that
-support it, this control sets the key.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;key&quot;
-
-The value string is used as is.
-
-=item &quot;hexkey&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=item B&lt;EVP_KDF_CTRL_SET_MAC_SIZE&gt;
-
-This control expects one argument: C&lt;size_t size&gt;
-
-Used by implementations that use a MAC with a variable output size (KMAC). For
-those KDF implementations that support it, this control sets the MAC output size.
-
-The default value, if any, is implementation dependent.
-
-EVP_KDF_ctrl_str() type string: &quot;outlen&quot;
-
-The value string is expected to be a decimal number.
-
-=item B&lt;EVP_KDF_CTRL_SET_MAXMEM_BYTES&gt;
-
-This control expects one argument: C&lt;uint64_t maxmem_bytes&gt;
-
-Memory-hard password-based KDF algorithms, such as scrypt, use an amount of
-memory that depends on the load factors provided as input.  For those KDF
-implementations that support it, this control sets an upper limit on the amount
-of memory that may be consumed while performing a key derivation.  If this
-memory usage limit is exceeded because the load factors are chosen too high,
-the key derivation will fail.
-
-The default value is implementation dependent.
-
-EVP_KDF_ctrl_str() type string: &quot;maxmem_bytes&quot;
-
-The value string is expected to be a decimal number.
-
-=back
-
-=head1 RETURN VALUES
-
-EVP_KDF_CTX_new() and EVP_KDF_CTX_new_id() return either the newly allocated
-C&lt;EVP_KDF_CTX&gt; structure or C&lt;NULL&gt; if an error occurred.
-
-EVP_KDF_CTX_free() and EVP_KDF_reset() do not return a value.
-
-EVP_KDF_size() returns the output size.  C&lt;SIZE_MAX&gt; is returned to indicate
-that the algorithm produces a variable amount of output; 0 to indicate failure.
-
-EVP_KDF_nid() returns the numeric identity for the given C&lt;kdf&gt;.
-
-EVP_KDF_name() returns the name for the given C&lt;kdf&gt;, if it has been
-added to the object database.
-
-EVP_add_kdf() returns 1 if the given C&lt;kdf&gt; was successfully added to
-the object database, otherwise 0.
-
-EVP_get_kdfbyname(), EVP_get_kdfbynid() and EVP_get_kdfbyobj() return
-the requested KDF implementation, if it exists in the object database,
-otherwise B&lt;NULL&gt;.
-
-The remaining functions return 1 for success and 0 or a negative value for
-failure.  In particular, a return value of -2 indicates the operation is not
-supported by the KDF algorithm.
-
-=head1 SEE ALSO
-
-L&lt;EVP_KDF_SCRYPT(7)&gt;
-L&lt;EVP_KDF_TLS1_PRF(7)&gt;
-L&lt;EVP_KDF_PBKDF2(7)&gt;
-L&lt;EVP_KDF_HKDF(7)&gt;
-L&lt;EVP_KDF_SS(7)&gt;
-L&lt;EVP_KDF_SSHKDF(7)&gt;
-L&lt;EVP_KDF_X963(7)&gt;
-L&lt;EVP_KDF_X942(7)&gt;
-
-=head1 HISTORY
-
-This functionality was added to OpenSSL 3.0.
-
-=head1 COPYRIGHT
-
-Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
-
-Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
-this file except in compliance with the License.  You can obtain a copy
-in the file LICENSE in the source distribution or at
-L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
-
-=cut
diff --git a/doc/man7/EVP_KDF-HKDF.pod b/doc/man7/EVP_KDF-HKDF.pod
new file mode 100644
index 0000000000..746e7fb972
--- /dev/null
+++ b/doc/man7/EVP_KDF-HKDF.pod
@@ -0,0 +1,154 @@
+=pod
+
+=head1 NAME
+
+EVP_KDF-HKDF - The HKDF EVP_KDF implementation
+
+=head1 DESCRIPTION
+
+Support for computing the B&lt;HKDF&gt; KDF through the B&lt;EVP_KDF&gt; API.
+
+The EVP_KDF-HKDF algorithm implements the HKDF key derivation function.
+HKDF follows the &quot;extract-then-expand&quot; paradigm, where the KDF logically
+consists of two modules. The first stage takes the input keying material
+and &quot;extracts&quot; from it a fixed-length pseudorandom key K. The second stage
+&quot;expands&quot; the key K into several additional pseudorandom keys (the output
+of the KDF).
+
+=head2 Identity
+
+&quot;HKDF&quot; is the name for this implementation; it
+can be used with the EVP_KDF_fetch() function.
+
+=head2 Supported parameters
+
+The supported parameters are:
+
+=over 4
+
+=item B&lt;OSSL_KDF_PARAM_PROPERTIES&gt; (&quot;properties&quot;) &lt;UTF8 string&gt;
+
+=item B&lt;OSSL_KDF_PARAM_DIGEST&gt; (&quot;digest&quot;) &lt;UTF8 string&gt;
+
+=item B&lt;OSSL_KDF_PARAM_KEY&gt; (&quot;key&quot;) &lt;octet string&gt;
+
+=item B&lt;OSSL_KDF_PARAM_SALT&gt; (&quot;salt&quot;) &lt;octet string&gt;
+
+These parameters work as described in L&lt;EVP_KDF(3)/PARAMETERS&gt;.
+
+=item B&lt;OSSL_KDF_PARAM_INFO&gt; (&quot;info&quot;) &lt;octet string&gt;
+
+This parameter sets the info value.
+The length of the context info buffer cannot exceed 1024 bytes;
+this should be more than enough for any normal use of HKDF.
+
+=item B&lt;OSSL_KDF_PARAM_MODE&gt; (&quot;mode&quot;) &lt;UTF8 string&gt; or &lt;int&gt;
+
+This parameter sets the mode for the HKDF operation.
+There are three modes that are currently defined:
+
+=over 4
+
+=item B&lt;EVP_KDF_HKDF_MODE_EXTRACT_AND_EXPAND&gt; &quot;EXTRACT_AND_EXPAND&quot;
+
+This is the default mode.  Calling L&lt;EVP_KDF-derive(3)&gt; on an EVP_KDF_CTX set
+up for HKDF will perform an extract followed by an expand operation in one go.
+The derived key returned will be the result after the expand operation. The
+intermediate fixed-length pseudorandom key K is not returned.
+
+In this mode the digest, key, salt and info values must be set before a key is
+derived otherwise an error will occur.
+
+=item B&lt;EVP_KDF_HKDF_MODE_EXTRACT_ONLY&gt; &quot;EXTRACT_ONLY&quot;
+
+In this mode calling L&lt;EVP_KDF-derive(3)&gt; will just perform the extract
+operation. The value returned will be the intermediate fixed-length pseudorandom
+key K.  The C&lt;keylen&gt; parameter must match the size of K, which can be looked
+up by calling EVP_KDF_size() after setting the mode and digest.
+
+The digest, key and salt values must be set before a key is derived otherwise
+an error will occur.
+
+=item B&lt;EVP_KDF_HKDF_MODE_EXPAND_ONLY&gt; &quot;EXPAND_ONLY&quot;
+
+In this mode calling L&lt;EVP_KDF-derive(3)&gt; will just perform the expand
+operation. The input key should be set to the intermediate fixed-length
+pseudorandom key K returned from a previous extract operation.
+
+The digest, key and info values must be set before a key is derived otherwise
+an error will occur.
+
+=back
+
+=back
+
+=head1 NOTES
+
+A context for HKDF can be obtained by calling:
+
+ EVP_KDF *kdf = EVP_KDF_fetch(NULL, &quot;HKDF&quot;, NULL);
+ EVP_KDF_CTX *kctx = EVP_KDF_CTX_new(kdf);
+
+The output length of an HKDF expand operation is specified via the C&lt;keylen&gt;
+parameter to the L&lt;EVP_KDF-derive(3)&gt; function.  When using
+EVP_KDF_HKDF_MODE_EXTRACT_ONLY the C&lt;keylen&gt; parameter must equal the size of
+the intermediate fixed-length pseudorandom key otherwise an error will occur.
+For that mode, the fixed output size can be looked up by calling EVP_KDF_size()
+after setting the mode and digest on the C&lt;EVP_KDF_CTX&gt;.
+
+=head1 EXAMPLES
+
+This example derives 10 bytes using SHA-256 with the secret key &quot;secret&quot;,
+salt value &quot;salt&quot; and info value &quot;label&quot;:
+
+ EVP_KDF *kdf;
+ EVP_KDF_CTX *kctx;
+ unsigned char out[10];
+ OSSL_PARAM params[5], *p = params;
+
+ kdf = EVP_KDF_fetch(NULL, &quot;HKDF&quot;, NULL);
+ kctx = EVP_KDF_CTX_new(kdf);
+ EVP_KDF_free(kdf);
+
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                         SN_sha256, strlen(SN_sha256));
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
+                                          &quot;secret&quot;, (size_t)6);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+                                          &quot;label&quot;, (size_t)5);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                          &quot;salt&quot;, (size_t)4);
+ *p = OSSL_PARAM_construct_end();
+ if (EVP_KDF_set_params(kctx, params) &lt;= 0) {
+     error(&quot;EVP_KDF_set_params&quot;);
+ }
+ if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
+     error(&quot;EVP_KDF_derive&quot;);
+ }
+
+ EVP_KDF_CTX_free(kctx);
+
+=head1 CONFORMING TO
+
+RFC 5869
+
+=head1 SEE ALSO
+
+L&lt;EVP_KDF&gt;,
+L&lt;EVP_KDF-CTX_new_id(3)&gt;,
+L&lt;EVP_KDF-CTX_free(3)&gt;,
+L&lt;EVP_KDF-ctrl(3)&gt;,
+L&lt;EVP_KDF-size(3)&gt;,
+L&lt;EVP_KDF-derive(3)&gt;,
+L&lt;EVP_KDF-CTX(3)/PARAMETERS&gt;
+
+=head1 COPYRIGHT
+
+Copyright 2016-2018 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man7/EVP_KDF_PBKDF2.pod b/doc/man7/EVP_KDF-PBKDF2.pod
similarity index 63%
rename from doc/man7/EVP_KDF_PBKDF2.pod
rename to doc/man7/EVP_KDF-PBKDF2.pod
index e914f3713c..311e0a3769 100644
--- a/doc/man7/EVP_KDF_PBKDF2.pod
+++ b/doc/man7/EVP_KDF-PBKDF2.pod
@@ -2,46 +2,45 @@
 
 =head1 NAME
 
-EVP_KDF_PBKDF2 - The PBKDF2 EVP_KDF implementation
+EVP_KDF-PBKDF2 - The PBKDF2 EVP_KDF implementation
 
 =head1 DESCRIPTION
 
 Support for computing the B&lt;PBKDF2&gt; password-based KDF through the B&lt;EVP_KDF&gt;
 API.
 
-The EVP_KDF_PBKDF2 algorithm implements the PBKDF2 password-based key
+The EVP_KDF-PBKDF2 algorithm implements the PBKDF2 password-based key
 derivation function, as described in SP800-132; it derives a key from a password
 using a salt and iteration count.
 
-=head2 Numeric identity
+=head2 Identity
 
-B&lt;EVP_KDF_PBKDF2&gt; is the numeric identity for this implementation; it
-can be used with the EVP_KDF_CTX_new_id() function.
+&quot;PBKDF2&quot; is the name for this implementation; it
+can be used with the EVP_KDF_fetch() function.
 
-=head2 Supported controls
+=head2 Supported parameters
 
-The supported controls are:
+The supported parameters are:
 
 =over 4
 
-=item B&lt;EVP_KDF_CTRL_SET_PASS&gt;
+=item B&lt;OSSL_KDF_PARAM_PASSWORD&gt; (&quot;pass&quot;) &lt;octet string&gt;
 
-=item B&lt;EVP_KDF_CTRL_SET_SALT&gt;
+=item B&lt;OSSL_KDF_PARAM_SALT&gt; (&quot;salt&quot;) &lt;octet string&gt;
 
-=item B&lt;EVP_KDF_CTRL_SET_ITER&gt;
+=item B&lt;OSSL_KDF_PARAM_ITER&gt; (&quot;iter&quot;) &lt;unsigned int&gt;
 
-This control has a default value of 2048.
+This parameter has a default value of 2048.
 
-=item B&lt;EVP_KDF_CTRL_SET_MD&gt;
+=item B&lt;OSSL_KDF_PARAM_PROPERTIES&gt; (&quot;properties&quot;) &lt;UTF8 string&gt;
 
-These controls work as described in L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;.
+=item B&lt;OSSL_KDF_PARAM_DIGEST&gt; (&quot;digest&quot;) &lt;UTF8 string&gt;
 
-=item B&lt;EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE&gt;
+These parameters work as described in L&lt;EVP_KDF(3)/PARAMETERS&gt;.
 
-This control expects one argument: C&lt;int mode&gt;
-
-This control can be used to enable or disable SP800-132 compliance checks.
+=item B&lt;OSSL_KDF_PARAM_PKCS5&gt; (&quot;pkcs5&quot;) &lt;int&gt;
 
+This parameter can be used to enable or disable SP800-132 compliance checks.
 Setting the mode to 0 enables the compliance checks.
 
 The checks performed are:
@@ -59,8 +58,6 @@ The checks performed are:
 The default provider uses a default mode of 1 for backwards compatibility,
 and the fips provider uses a default mode of 0.
 
-EVP_KDF_ctrl_str() type string: &quot;pkcs5&quot;
-
 The value string is expected to be a decimal number 0 or 1.
 
 =back
@@ -84,12 +81,12 @@ SP800-132
 
 =head1 SEE ALSO
 
-L&lt;EVP_KDF_CTX&gt;,
-L&lt;EVP_KDF_CTX_new_id(3)&gt;,
-L&lt;EVP_KDF_CTX_free(3)&gt;,
-L&lt;EVP_KDF_ctrl(3)&gt;,
-L&lt;EVP_KDF_derive(3)&gt;,
-L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;
+L&lt;EVP_KDF&gt;,
+L&lt;EVP_KDF-CTX_new_id(3)&gt;,
+L&lt;EVP_KDF-CTX_free(3)&gt;,
+L&lt;EVP_KDF-ctrl(3)&gt;,
+L&lt;EVP_KDF-derive(3)&gt;,
+L&lt;EVP_KDF-CTX(3)/PARAMETERS&gt;
 
 =head1 HISTORY
 
diff --git a/doc/man7/EVP_KDF_SCRYPT.pod b/doc/man7/EVP_KDF-SCRYPT.pod
similarity index 61%
rename from doc/man7/EVP_KDF_SCRYPT.pod
rename to doc/man7/EVP_KDF-SCRYPT.pod
index aa50164e06..ce22aaa7ca 100644
--- a/doc/man7/EVP_KDF_SCRYPT.pod
+++ b/doc/man7/EVP_KDF-SCRYPT.pod
@@ -2,14 +2,14 @@
 
 =head1 NAME
 
-EVP_KDF_SCRYPT - The scrypt EVP_KDF implementation
+EVP_KDF-SCRYPT - The scrypt EVP_KDF implementation
 
 =head1 DESCRIPTION
 
 Support for computing the B&lt;scrypt&gt; password-based KDF through the B&lt;EVP_KDF&gt;
 API.
 
-The EVP_KDF_SCRYPT algorithm implements the scrypt password-based key
+The EVP_KDF-SCRYPT algorithm implements the scrypt password-based key
 derivation function, as described in RFC 7914.  It is memory-hard in the sense
 that it deliberately requires a significant amount of RAM for efficient
 computation. The intention of this is to render brute forcing of passwords on
@@ -32,40 +32,32 @@ GHz), this computation takes about 3 seconds. When N, r or p are not specified,
 they default to 1048576, 8, and 1, respectively. The maximum amount of RAM that
 may be used by scrypt defaults to 1025 MiB.
 
-=head2 Numeric identity
+=head2 Identity
 
-B&lt;EVP_KDF_SCRYPT&gt; is the numeric identity for this implementation; it
-can be used with the EVP_KDF_CTX_new_id() function.
+&quot;ID-SCRYPT&quot; is the name for this implementation; it
+can be used with the EVP_KDF_fetch() function.
 
-=head2 Supported controls
+=head2 Supported parameters
 
-The supported controls are:
+The supported parameters are:
 
 =over 4
 
-=item B&lt;EVP_KDF_CTRL_SET_PASS&gt;
+=item B&lt;OSSL_KDF_PARAM_PASSWORD&gt; (&quot;pass&quot;) &lt;octet string&gt;
 
-=item B&lt;EVP_KDF_CTRL_SET_SALT&gt;
+=item B&lt;OSSL_KDF_PARAM_SALT&gt; (&quot;salt&quot;) &lt;octet string&gt;
 
-These controls work as described in L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;.
+These parameters work as described in L&lt;EVP_KDF(3)/PARAMETERS&gt;.
 
-=item B&lt;EVP_KDF_CTRL_SET_SCRYPT_N&gt;
+=item B&lt;OSSL_KDF_PARAM_SCRYPT_N&gt; (&quot;n&quot;) &lt;int&gt;
 
-=item B&lt;EVP_KDF_CTRL_SET_SCRYPT_R&gt;
+=item B&lt;OSSL_KDF_PARAM_SCRYPT_R&gt; (&quot;r&quot;) &lt;int&gt;
 
-=item B&lt;EVP_KDF_CTRL_SET_SCRYPT_P&gt;
+=item B&lt;OSSL_KDF_PARAM_SCRYPT_P&gt; (&quot;p&quot;) &lt;int&gt;
 
-B&lt;EVP_KDF_CTRL_SET_SCRYPT_N&gt; expects one argument: C&lt;uint64_t N&gt;
-
-B&lt;EVP_KDF_CTRL_SET_SCRYPT_R&gt; expects one argument: C&lt;uint32_t r&gt;
-
-B&lt;EVP_KDF_CTRL_SET_SCRYPT_P&gt; expects one argument: C&lt;uint32_t p&gt;
-
-These controls configure the scrypt work factors N, r and p.
-
-EVP_KDF_ctrl_str() type strings: &quot;N&quot;, &quot;r&quot; and &quot;p&quot;, respectively.
-
-The corresponding value strings are expected to be decimal numbers.
+These parameters configure the scrypt work factors N, r and p.
+N is a parameter of type uint64_t.
+Both r and p are parameters of type uint32_t.
 
 =back
 
@@ -73,35 +65,36 @@ The corresponding value strings are expected to be decimal numbers.
 
 A context for scrypt can be obtained by calling:
 
- EVP_KDF_CTX *kctx = EVP_KDF_CTX_new_id(EVP_KDF_SCRYPT);
+ EVP_KDF *kdf = EVP_KDF_fetch(NULL, &quot;ID-SCRYPT&quot;, NULL);
+ EVP_KDF_CTX *kctx = EVP_KDF_CTX_new(kdf);
 
 The output length of an scrypt key derivation is specified via the
-B&lt;keylen&gt; parameter to the L&lt;EVP_KDF_derive(3)&gt; function.
+B&lt;keylen&gt; parameter to the L&lt;EVP_KDF-derive(3)&gt; function.
 
 =head1 EXAMPLES
 
 This example derives a 64-byte long test vector using scrypt with the password
 &quot;password&quot;, salt &quot;NaCl&quot; and N = 1024, r = 8, p = 16.
 
+ EVP_KDF *kdf;
  EVP_KDF_CTX *kctx;
  unsigned char out[64];
-
- kctx = EVP_KDF_CTX_new_id(EVP_KDF_SCRYPT);
-
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PASS, &quot;password&quot;, (size_t)8) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_SET_PASS&quot;);
- }
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT, &quot;NaCl&quot;, (size_t)4) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_SET_SALT&quot;);
- }
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_N, (uint64_t)1024) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_SET_SCRYPT_N&quot;);
- }
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_R, (uint32_t)8) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_SET_SCRYPT_R&quot;);
- }
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_P, (uint32_t)16) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_SET_SCRYPT_P&quot;);
+ OSSL_PARAM params[6], *p = params;
+
+ kdf = EVP_KDF_fetch(NULL, &quot;ID-SCRYPT&quot;, NULL);
+ kctx = EVP_KDF_CTX_new(kdf);
+ EVP_KDF_free(kdf);
+
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_PASSWORD,
+                                          &quot;password&quot;, (size_t)8);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                          &quot;NaCl&quot;, (size_t)4);
+ *p++ = OSSL_PARAM_construct_uint64(OSSL_KDF_PARAM_SCRYPT_N, (uint64_t)1024);
+ *p++ = OSSL_PARAM_construct_uint32(OSSL_KDF_PARAM_SCRYPT_R, (uint32_t)8);
+ *p++ = OSSL_PARAM_construct_uint32(OSSL_KDF_PARAM_SCRYPT_P, (uint32_t)16);
+ *p = OSSL_PARAM_construct_end();
+ if (EVP_KDF_set_params(kctx, params) &lt;= 0) {
+     error(&quot;EVP_KDF_set_params&quot;);
  }
  if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
      error(&quot;EVP_KDF_derive&quot;);
@@ -130,12 +123,12 @@ RFC 7914
 
 =head1 SEE ALSO
 
-L&lt;EVP_KDF_CTX&gt;,
-L&lt;EVP_KDF_CTX_new_id(3)&gt;,
-L&lt;EVP_KDF_CTX_free(3)&gt;,
-L&lt;EVP_KDF_ctrl(3)&gt;,
-L&lt;EVP_KDF_derive(3)&gt;,
-L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;
+L&lt;EVP_KDF&gt;,
+L&lt;EVP_KDF-CTX_new_id(3)&gt;,
+L&lt;EVP_KDF-CTX_free(3)&gt;,
+L&lt;EVP_KDF-ctrl(3)&gt;,
+L&lt;EVP_KDF-derive(3)&gt;,
+L&lt;EVP_KDF-CTX(3)/PARAMETERS&gt;
 
 =head1 COPYRIGHT
 
diff --git a/doc/man7/EVP_KDF-SS.pod b/doc/man7/EVP_KDF-SS.pod
new file mode 100644
index 0000000000..be69606701
--- /dev/null
+++ b/doc/man7/EVP_KDF-SS.pod
@@ -0,0 +1,197 @@
+=pod
+
+=head1 NAME
+
+EVP_KDF-SS - The Single Step / One Step EVP_KDF implementation
+
+=head1 DESCRIPTION
+
+The EVP_KDF-SS algorithm implements the Single Step key derivation function (SSKDF).
+SSKDF derives a key using input such as a shared secret key (that was generated
+during the execution of a key establishment scheme) and fixedinfo.
+SSKDF is also informally referred to as 'Concat KDF'.
+
+=head2 Auxiliary function
+
+The implementation uses a selectable auxiliary function H, which can be one of:
+
+=over 4
+
+=item B&lt;H(x) = hash(x, digest=md)&gt;
+
+=item B&lt;H(x) = HMAC_hash(x, key=salt, digest=md)&gt;
+
+=item B&lt;H(x) = KMACxxx(x, key=salt, custom=&quot;KDF&quot;, outlen=mac_size)&gt;
+
+=back
+
+Both the HMAC and KMAC implementations set the key using the 'salt' value.
+The hash and HMAC also require the digest to be set.
+
+=head2 Identity
+
+&quot;SSKDF&quot; is the name for this implementation; it
+can be used with the EVP_KDF_fetch() function.
+
+=head2 Supported parameters
+
+The supported parameters are:
+
+=over 4
+
+=item B&lt;OSSL_KDF_PARAM_PROPERTIES&gt; (&quot;properties&quot;) &lt;UTF8 string&gt;
+
+=item B&lt;OSSL_KDF_PARAM_DIGEST&gt; (&quot;digest&quot;) &lt;UTF8 string&gt;
+
+=item B&lt;OSSL_KDF_PARAM_MAC&gt; (&quot;mac&quot;) &lt;UTF8 string&gt;
+
+=item B&lt;OSSL_KDF_PARAM_MAC_SIZE&gt; (&quot;maclen&quot;) &lt;size_t&gt;
+
+=item B&lt;OSSL_KDF_PARAM_SALT&gt; (&quot;salt&quot;) &lt;octet string&gt;
+
+These parameters work as described in L&lt;EVP_KDF(3)/PARAMETERS&gt;.
+
+=item B&lt;EVP_KDF_CTRL_SET_KEY&gt; (&quot;key&quot;) &lt;octet string&gt;
+
+This parameter set the shared secret that is used for key derivation.
+
+=item B&lt;OSSL_KDF_PARAM_INFO&gt; (&quot;info&quot;) &lt;octet string&gt;
+
+This parameter sets an optional value for fixedinfo, also known as otherinfo.
+
+=back
+
+=head1 NOTES
+
+A context for SSKDF can be obtained by calling:
+
+ EVP_KDF *kdf = EVP_KDF_fetch(NULL, &quot;SSKDF&quot;, NULL);
+ EVP_KDF_CTX *kctx = EVP_KDF_CTX_new(kdf);
+
+The output length of an SSKDF is specified via the C&lt;keylen&gt;
+parameter to the L&lt;EVP_KDF-derive(3)&gt; function.
+
+=head1 EXAMPLES
+
+This example derives 10 bytes using H(x) = SHA-256, with the secret key &quot;secret&quot;
+and fixedinfo value &quot;label&quot;:
+
+ EVP_KDF *kdf;
+ EVP_KDF_CTX *kctx;
+ unsigned char out[10];
+ OSSL_PARAM params[4], *p = params;
+
+ kdf = EVP_KDF_fetch(NULL, &quot;SSKDF&quot;, NULL);
+ kctx = EVP_KDF_CTX_new(kdf);
+ EVP_KDF_free(kdf);
+
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                         SN_sha256, strlen(SN_sha256));
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
+                                          &quot;secret&quot;, (size_t)6);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+                                          &quot;label&quot;, (size_t)5);
+ *p = OSSL_PARAM_construct_end();
+ if (EVP_KDF_set_params(kctx, params) &lt;= 0) {
+     error(&quot;EVP_KDF_set_params&quot;);
+ }
+ if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
+     error(&quot;EVP_KDF_derive&quot;);
+ }
+
+ EVP_KDF_CTX_free(kctx);
+
+This example derives 10 bytes using H(x) = HMAC(SHA-256), with the secret key &quot;secret&quot;,
+fixedinfo value &quot;label&quot; and salt &quot;salt&quot;:
+
+ EVP_KDF *kdf;
+ EVP_KDF_CTX *kctx;
+ unsigned char out[10];
+ OSSL_PARAM params[6], *p = params;
+
+ kdf = EVP_KDF_fetch(NULL, &quot;SSKDF&quot;, NULL);
+ kctx = EVP_KDF_CTX_new(kdf);
+ EVP_KDF_free(kdf);
+
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MAC,
+                                         SN_hmac, strlen(SN_hmac));
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                         SN_sha256, strlen(SN_sha256));
+ *p++ = OSSL_PARAM_construct_octet_string(EVP_KDF_CTRL_SET_KEY,
+                                          &quot;secret&quot;, (size_t)6);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+                                          &quot;label&quot;, (size_t)5);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                          &quot;salt&quot;, (size_t)4);
+ *p = OSSL_PARAM_construct_end();
+ if (EVP_KDF_set_params(kctx, params) &lt;= 0) {
+     error(&quot;EVP_KDF_set_params&quot;);
+ }
+ if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
+     error(&quot;EVP_KDF_derive&quot;);
+ }
+
+ EVP_KDF_CTX_free(kctx);
+
+This example derives 10 bytes using H(x) = KMAC128(x,salt,outlen), with the secret key &quot;secret&quot;
+fixedinfo value &quot;label&quot;, salt of &quot;salt&quot; and KMAC outlen of 20:
+
+ EVP_KDF *kdf;
+ EVP_KDF_CTX *kctx;
+ unsigned char out[10];
+ OSSL_PARAM params[7], *p = params;
+
+ kdf = EVP_KDF_fetch(NULL, &quot;SSKDF&quot;, NULL);
+ kctx = EVP_KDF_CTX_new(kdf);
+ EVP_KDF_free(kdf);
+
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MAC,
+                                         SN_kmac128, strlen(SN_kmac128));
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                         SN_sha256, strlen(SN_sha256));
+ *p++ = OSSL_PARAM_construct_octet_string(EVP_KDF_CTRL_SET_KEY,
+                                          &quot;secret&quot;, (size_t)6);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+                                          &quot;label&quot;, (size_t)5);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                          &quot;salt&quot;, (size_t)4);
+ *p++ = OSSL_PARAM_construct_size_t(OSSL_KDF_PARAM_MAC_SIZE, (size_t)20);
+ *p = OSSL_PARAM_construct_end();
+ if (EVP_KDF_set_params(kctx, params) &lt;= 0) {
+     error(&quot;EVP_KDF_set_params&quot;);
+ }
+ if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
+     error(&quot;EVP_KDF_derive&quot;);
+ }
+
+ EVP_KDF_CTX_free(kctx);
+
+=head1 CONFORMING TO
+
+NIST SP800-56Cr1.
+
+=head1 SEE ALSO
+
+L&lt;EVP_KDF&gt;,
+L&lt;EVP_KDF-CTX_new_id(3)&gt;,
+L&lt;EVP_KDF-CTX_free(3)&gt;,
+L&lt;EVP_KDF-ctrl(3)&gt;,
+L&lt;EVP_KDF-size(3)&gt;,
+L&lt;EVP_KDF-derive(3)&gt;,
+L&lt;EVP_KDF(3)/PARAMETERS&gt;
+
+=head1 HISTORY
+
+This functionality was added to OpenSSL 3.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.  Copyright
+(c) 2019, Oracle and/or its affiliates.  All rights reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man7/EVP_KDF_SSHKDF.pod b/doc/man7/EVP_KDF-SSHKDF.pod
similarity index 51%
rename from doc/man7/EVP_KDF_SSHKDF.pod
rename to doc/man7/EVP_KDF-SSHKDF.pod
index 04a646c866..0ed57626ef 100644
--- a/doc/man7/EVP_KDF_SSHKDF.pod
+++ b/doc/man7/EVP_KDF-SSHKDF.pod
@@ -2,69 +2,49 @@
 
 =head1 NAME
 
-EVP_KDF_SSHKDF - The SSHKDF EVP_KDF implementation
+EVP_KDF-SSHKDF - The SSHKDF EVP_KDF implementation
 
 =head1 DESCRIPTION
 
 Support for computing the B&lt;SSHKDF&gt; KDF through the B&lt;EVP_KDF&gt; API.
 
-The EVP_KDF_SSHKDF algorithm implements the SSHKDF key derivation function.
+The EVP_KDF-SSHKDF algorithm implements the SSHKDF key derivation function.
 It is defined in RFC 4253, section 7.2 and is used by SSH to derive IVs,
 encryption keys and integrity keys.
 Five inputs are required to perform key derivation: The hashing function
 (for example SHA256), the Initial Key, the Exchange Hash, the Session ID,
 and the derivation key type.
 
-=head2 Numeric identity
+=head2 Identity
 
-B&lt;EVP_KDF_SSHKDF&gt; is the numeric identity for this implementation; it
-can be used with the EVP_KDF_CTX_new_id() function.
+&quot;SSHKDF&quot; is the name for this implementation; it
+can be used with the EVP_KDF_fetch() function.
 
-=head2 Supported controls
+=head2 Supported parameters
 
-The supported controls are:
+The supported parameters are:
 
 =over 4
 
-=item B&lt;EVP_KDF_CTRL_SET_MD&gt;
+=item B&lt;OSSL_KDF_PARAM_PROPERTIES&gt; (&quot;properties&quot;) &lt;UTF8 string&gt;
 
-=item B&lt;EVP_KDF_CTRL_SET_KEY&gt;
+=item B&lt;OSSL_KDF_PARAM_DIGEST&gt; (&quot;digest&quot;) &lt;UTF8 string&gt;
 
-These controls work as described in L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;.
+=item B&lt;OSSL_KDF_PARAM_KEY&gt; (&quot;key&quot;) &lt;octet string&gt;
 
-=item B&lt;EVP_KDF_CTRL_SET_SSHKDF_XCGHASH&gt;
+These parameters work as described in L&lt;EVP_KDF(3)/PARAMETERS&gt;.
 
-=item B&lt;EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID&gt;
+=item B&lt;OSSL_KDF_PARAM_SSHKDF_XCGHASH&gt; (&quot;xcghash&quot;) &lt;octet string&gt;
 
-These controls expect two arguments: C&lt;unsigned char *buffer&gt;, C&lt;size_t length&gt;
+=item B&lt;OSSL_KDF_PARAM_SSHKDF_SESSION_ID&gt; (&quot;session_id&quot;) &lt;octet string&gt;
 
-They set the respective values to the first B&lt;length&gt; bytes of the buffer
-B&lt;buffer&gt;. If a value is already set, the contents are replaced.
+These parameters set the respective values for the KDF.
+If a value is already set, the contents are replaced.
 
-EVP_KDF_ctrl_str() takes two type strings for these controls:
+=item B&lt;OSSL_KDF_PARAM_SSHKDF_TYPE&gt; (&quot;type&quot;) &lt;int&gt;
 
-=over 4
-
-=item &quot;xcghash&quot;
-
-=item &quot;session_id&quot;
-
-The value string is used as is.
-
-=item &quot;hexxcghash&quot;
-
-=item &quot;hexsession_id&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=item B&lt;EVP_KDF_CTRL_SET_SSHKDF_TYPE&gt;
-
-This control expects one argument: C&lt;int mode&gt;
-
-Sets the type for the SSHHKDF operation. There are six supported types:
+This parameter sets the type for the SSHHKDF operation.
+There are six supported types:
 
 =over 4
 
@@ -100,50 +80,54 @@ A single char of value 70 (ASCII char 'F').
 
 =back
 
-EVP_KDF_ctrl_str() type string: &quot;type&quot;
-
-The value is a string of length one character. The only valid values
-are the numerical values of the ASCII characters: &quot;A&quot; (65) to &quot;F&quot; (70).
-
 =back
 
 =head1 NOTES
 
 A context for SSHKDF can be obtained by calling:
 
- EVP_KDF_CTX *kctx = EVP_KDF_CTX_new_id(EVP_KDF_SSHKDF);
+ EVP_KDF *kdf = EVP_KDF_fetch(NULL, &quot;SSHKDF&quot;, NULL);
+ EVP_KDF_CTX *kctx = EVP_KDF_CTX_new(kdf);
 
 The output length of the SSHKDF derivation is specified via the C&lt;keylen&gt;
-parameter to the L&lt;EVP_KDF_derive(3)&gt; function.
-Since the SSHKDF output length is variable, calling L&lt;EVP_KDF_size()&gt;
+parameter to the L&lt;EVP_KDF-derive(3)&gt; function.
+Since the SSHKDF output length is variable, calling L&lt;EVP_KDF-size()&gt;
 to obtain the requisite length is not meaningful. The caller must
 allocate a buffer of the desired length, and pass that buffer to the
-L&lt;EVP_KDF_derive(3)&gt; function along with the desired length.
+L&lt;EVP_KDF-derive(3)&gt; function along with the desired length.
 
 =head1 EXAMPLES
 
 This example derives an 8 byte IV using SHA-256 with a 1K &quot;key&quot; and appropriate
 &quot;xcghash&quot; and &quot;session_id&quot; values:
 
+ EVP_KDF *kdf;
  EVP_KDF_CTX *kctx;
  unsigned char key[1024] = &quot;01234...&quot;;
  unsigned char xcghash[32] = &quot;012345...&quot;;
  unsigned char session_id[32] = &quot;012345...&quot;;
  unsigned char out[8];
  size_t outlen = sizeof(out);
- kctx = EVP_KDF_CTX_new_id(EVP_KDF_SSHKDF);
-
- if (EVP_KDF_CTX_set_md(kctx, EVP_sha256()) &lt;= 0)
-     /* Error */
- if (EVP_KDF_CTX_set1_key(kctx, key, 1024) &lt;= 0)
-     /* Error */
- if (EVP_KDF_CTX_set1_sshkdf_xcghash(kctx, xcghash, 32) &lt;= 0)
-     /* Error */
- if (EVP_KDF_CTX_set1_sshkdf_session_id(kctx, session_id, 32) &lt;= 0)
-     /* Error */
- if (EVP_KDF_CTX_set_sshkdf_type(kctx,
-                    EVP_KDF_SSHKDF_TYPE_INITIAL_IV_CLI_TO_SRV) &lt;= 0)
+ OSSL_PARAM params[6], *p = params;
+
+ kdf = EVP_KDF_fetch(NULL, &quot;SSHKDF&quot;, NULL);
+ kctx = EVP_KDF_CTX_new(kdf);
+ EVP_KDF_free(kdf);
+
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                         SN_sha256, strlen(SN_sha256));
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
+                                          key, (size_t)1024);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SSHKDF_XCGHASH,
+                                          xcghash, (size_t)32);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                          session_id, (size_t)32);
+ *p++ = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_SSHKDF_TYPE,
+                                 EVP_KDF_SSHKDF_TYPE_INITIAL_IV_CLI_TO_SRV);
+ *p = OSSL_PARAM_construct_end();
+ if (EVP_KDF_set_params(kctx, params) &lt;= 0)
      /* Error */
+
  if (EVP_KDF_derive(kctx, out, &amp;outlen) &lt;= 0)
      /* Error */
 
@@ -154,13 +138,13 @@ RFC 4253
 
 =head1 SEE ALSO
 
-L&lt;EVP_KDF_CTX&gt;,
-L&lt;EVP_KDF_CTX_new_id(3)&gt;,
-L&lt;EVP_KDF_CTX_free(3)&gt;,
-L&lt;EVP_KDF_ctrl(3)&gt;,
-L&lt;EVP_KDF_size(3)&gt;,
-L&lt;EVP_KDF_derive(3)&gt;,
-L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;
+L&lt;EVP_KDF&gt;,
+L&lt;EVP_KDF-CTX_new_id(3)&gt;,
+L&lt;EVP_KDF-CTX_free(3)&gt;,
+L&lt;EVP_KDF-ctrl(3)&gt;,
+L&lt;EVP_KDF-size(3)&gt;,
+L&lt;EVP_KDF-derive(3)&gt;,
+L&lt;EVP_KDF(3)/PARAMETERS&gt;
 
 =head1 COPYRIGHT
 
diff --git a/doc/man7/EVP_KDF-TLS1_PRF.pod b/doc/man7/EVP_KDF-TLS1_PRF.pod
new file mode 100644
index 0000000000..a04f811792
--- /dev/null
+++ b/doc/man7/EVP_KDF-TLS1_PRF.pod
@@ -0,0 +1,113 @@
+=pod
+
+=head1 NAME
+
+EVP_KDF-TLS1_PRF - The TLS1 PRF EVP_KDF implementation
+
+=head1 DESCRIPTION
+
+Support for computing the B&lt;TLS1&gt; PRF through the B&lt;EVP_KDF&gt; API.
+
+The EVP_KDF-TLS1_PRF algorithm implements the PRF used by TLS versions up to
+and including TLS 1.2.
+
+=head2 Identity
+
+&quot;TLS1-PRF&quot; is the name for this implementation; it
+can be used with the EVP_KDF_fetch() function.
+
+=head2 Supported parameters
+
+The supported parameters are:
+
+=over 4
+
+=item B&lt;OSSL_KDF_PARAM_PROPERTIES&gt; (&quot;properties&quot;) &lt;UTF8 string&gt;
+
+=item B&lt;OSSL_KDF_PARAM_DIGEST&gt; (&quot;digest&quot;) &lt;UTF8 string&gt;
+
+These parameters work as described in L&lt;EVP_KDF(3)/PARAMETERS&gt;.
+
+The C&lt;OSSL_KDF_PARAM_DIGEST&gt; parameter is used to set the message digest
+associated with the TLS PRF.
+EVP_md5_sha1() is treated as a special case which uses the
+PRF algorithm using both B&lt;MD5&gt; and B&lt;SHA1&gt; as used in TLS 1.0 and 1.1.
+
+=item B&lt;OSSL_KDF_PARAM_SECRET&gt; (&quot;secret&quot;) &lt;octet string&gt;
+
+This parameter sets the secret value of the TLS PRF.
+Any existing secret value is replaced.
+
+=item B&lt;OSSL_KDF_PARAM_SEED&gt; (&quot;seed&quot;) &lt;octet string&gt;
+
+This parameter sets the context seed.
+The length of the context seed cannot exceed 1024 bytes;
+this should be more than enough for any normal use of the TLS PRF.
+
+=back
+
+=head1 NOTES
+
+A context for the TLS PRF can be obtained by calling:
+
+ EVP_KDF *kdf = EVP_KDF_fetch(NULL, &quot;TLS1-PRF&quot;, NULL);
+ EVP_KDF_CTX *kctx = EVP_KDF_CTX_new(kdf);
+
+The digest, secret value and seed must be set before a key is derived otherwise
+an error will occur.
+
+The output length of the PRF is specified by the C&lt;keylen&gt; parameter to the
+EVP_KDF_derive() function.
+
+=head1 EXAMPLES
+
+This example derives 10 bytes using SHA-256 with the secret key &quot;secret&quot;
+and seed value &quot;seed&quot;:
+
+ EVP_KDF *kdf;
+ EVP_KDF_CTX *kctx;
+ unsigned char out[10];
+ OSSL_PARAM params[4], *p = params;
+
+ kdf = EVP_KDF_fetch(NULL, &quot;TLS1-PRF&quot;, NULL);
+ kctx = EVP_KDF_CTX_new(kdf);
+ EVP_KDF_free(kdf);
+
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                         SN_sha256, strlen(SN_sha256));
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SECRET,
+                                          &quot;secret&quot;, (size_t)6);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SEED,
+                                          &quot;seed&quot;, (size_t)4);
+ *p = OSSL_PARAM_construct_end();
+ if (EVP_KDF_set_params(kctx, params) &lt;= 0) {
+     error(&quot;EVP_KDF_set_params&quot;);
+ }
+ if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
+     error(&quot;EVP_KDF_derive&quot;);
+ }
+ EVP_KDF_CTX_free(kctx);
+
+=head1 CONFORMING TO
+
+RFC 2246, RFC 5246 and NIST SP 800-135 r1
+
+=head1 SEE ALSO
+
+L&lt;EVP_KDF&gt;,
+L&lt;EVP_KDF-CTX_new_id(3)&gt;,
+L&lt;EVP_KDF-CTX_free(3)&gt;,
+L&lt;EVP_KDF-ctrl(3)&gt;,
+L&lt;EVP_KDF-derive(3)&gt;,
+L&lt;EVP_KDF-CTX(3)/PARAMETERS&gt;
+
+=head1 COPYRIGHT
+
+Copyright 2018-2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man7/EVP_KDF-X942.pod b/doc/man7/EVP_KDF-X942.pod
new file mode 100644
index 0000000000..0b02f2d403
--- /dev/null
+++ b/doc/man7/EVP_KDF-X942.pod
@@ -0,0 +1,122 @@
+=pod
+
+=head1 NAME
+
+EVP_KDF-X942 - The X9.42-2001 asn1 EVP_KDF implementation
+
+=head1 DESCRIPTION
+
+The EVP_KDF-X942 algorithm implements the key derivation function (X942KDF).
+X942KDF is used by Cryptographic Message Syntax (CMS) for DH KeyAgreement, to
+derive a key using input such as a shared secret key and other info. The other
+info is DER encoded data that contains a 32 bit counter.
+
+=head2 Identity
+
+&quot;X942KDF&quot; is the name for this implementation; it
+can be used with the EVP_KDF_fetch() function.
+
+=head2 Supported parameters
+
+The supported parameters are:
+
+=over 4
+
+=item B&lt;OSSL_KDF_PARAM_PROPERTIES&gt; (&quot;properties&quot;) &lt;UTF8 string&gt;
+
+=item B&lt;OSSL_KDF_PARAM_DIGEST&gt; (&quot;digest&quot;) &lt;UTF8 string&gt;
+
+These parameters work as described in L&lt;EVP_KDF(3)/PARAMETERS&gt;.
+
+=item B&lt;OSSL_KDF_PARAM_KEY&gt; (&quot;key&quot;) &lt;octet string&gt;
+
+The shared secret used for key derivation.  This parameter sets the secret.
+
+=item B&lt;OSSL_KDF_PARAM_UKM&gt; (&quot;ukm&quot;) &lt;octet string&gt;
+
+This parameter is an optional random string that is provided
+by the sender called &quot;partyAInfo&quot;.
+In CMS this is the user keying material.
+
+=item B&lt;OSSL_KDF_PARAM_CEK_ALG&gt; (&quot;cekalg&quot;) &lt;UTF8 string&gt;
+
+This parameter sets the CEK wrapping algorithm name. 
+
+=back
+
+=head1 NOTES
+
+A context for X942KDF can be obtained by calling:
+
+ EVP_KDF *kdf = EVP_KDF_fetch(NULL, &quot;X942KDF&quot;, NULL);
+ EVP_KDF_CTX *kctx = EVP_KDF_CTX_new(kdf);
+
+The output length of an X942KDF is specified via the C&lt;keylen&gt;
+parameter to the L&lt;EVP_KDF-derive(3)&gt; function.
+
+=head1 EXAMPLES
+
+This example derives 24 bytes, with the secret key &quot;secret&quot; and a random user
+keying material:
+
+  EVP_KDF_CTX *kctx;
+  EVP_KDF_CTX *kctx;
+  unsigned char out[192/8];
+  unsignred char ukm[64];
+ OSSL_PARAM params[5], *p = params;
+
+  if (RAND_bytes(ukm, sizeof(ukm)) &lt;= 0)
+      error(&quot;RAND_bytes&quot;);
+
+ kdf = EVP_KDF_fetch(NULL, &quot;X942KDF&quot;, NULL);
+ if (kctx == NULL)
+     error(&quot;EVP_KDF_fetch&quot;);
+ kctx = EVP_KDF_CTX_new(kdf);
+ if (kctx == NULL)
+     error(&quot;EVP_KDF_CTX_new&quot;);
+ EVP_KDF_free(kdf);
+
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                         SN_sha256, strlen(SN_sha256));
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SECRET,
+                                          &quot;secret&quot;, (size_t)6);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_UKM, ukm, sizeof(ukm));
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_CEK_ALG,
+                                         SN_id_smime_alg_CMS3DESwrap,
+                                         strlen(SN_id_smime_alg_CMS3DESwrap));
+ *p = OSSL_PARAM_construct_end();
+ if (EVP_KDF_set_params(kctx, params) &lt;= 0)
+     error(&quot;EVP_KDF_set_params&quot;);
+ if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0)
+     error(&quot;EVP_KDF_derive&quot;);
+
+ EVP_KDF_CTX_free(kctx);
+
+=head1 CONFORMING TO
+
+RFC 2631
+
+=head1 SEE ALSO
+
+L&lt;EVP_KDF&gt;,
+L&lt;EVP_KDF-CTX_new_id(3)&gt;,
+L&lt;EVP_KDF-CTX_free(3)&gt;,
+L&lt;EVP_KDF-ctrl(3)&gt;,
+L&lt;EVP_KDF-size(3)&gt;,
+L&lt;EVP_KDF-derive(3)&gt;,
+L&lt;EVP_KDF(3)/PARAMETERS&gt;
+
+=head1 HISTORY
+
+This functionality was added to OpenSSL 3.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man7/EVP_KDF-X963.pod b/doc/man7/EVP_KDF-X963.pod
new file mode 100644
index 0000000000..537d8c5fc5
--- /dev/null
+++ b/doc/man7/EVP_KDF-X963.pod
@@ -0,0 +1,111 @@
+=pod
+
+=head1 NAME
+
+EVP_KDF-X963 - The X9.63-2001 EVP_KDF implementation
+
+=head1 DESCRIPTION
+
+The EVP_KDF-X963 algorithm implements the key derivation function (X963KDF).
+X963KDF is used by Cryptographic Message Syntax (CMS) for EC KeyAgreement, to
+derive a key using input such as a shared secret key and shared info.
+
+=head2 Identity
+
+&quot;X963KDF&quot; is the name for this implementation; it
+can be used with the EVP_KDF_fetch() function.
+
+=head2 Supported parameters
+
+The supported parameters are:
+
+=over 4
+
+=item B&lt;OSSL_KDF_PARAM_PROPERTIES&gt; (&quot;properties&quot;) &lt;UTF8 string&gt;
+
+=item B&lt;OSSL_KDF_PARAM_DIGEST&gt; (&quot;digest&quot;) &lt;UTF8 string&gt;
+
+These parameters work as described in L&lt;EVP_KDF(3)/PARAMETERS&gt;.
+
+=item B&lt;OSSL_KDF_PARAM_KEY&gt; (&quot;key&quot;) &lt;octet string&gt;
+
+The shared secret used for key derivation.
+This parameter sets the secret.
+
+=item B&lt;OSSL_KDF_PARAM_INFO&gt; (&quot;info&quot;) &lt;octet string&gt;
+
+This parameter specifies an optional value for shared info.
+
+=back
+
+=head1 NOTES
+
+X963KDF is very similar to the SSKDF that uses a digest as the auxiliary function,
+X963KDF appends the counter to the secret, whereas SSKDF prepends the counter.
+
+A context for X963KDF can be obtained by calling:
+
+ EVP_KDF *kdf = EVP_KDF_fetch(NULL, &quot;X963KDF&quot;, NULL);
+ EVP_KDF_CTX *kctx = EVP_KDF_CTX_new(kdf);
+
+The output length of an X963KDF is specified via the C&lt;keylen&gt;
+parameter to the L&lt;EVP_KDF-derive(3)&gt; function.
+
+=head1 EXAMPLES
+
+This example derives 10 bytes, with the secret key &quot;secret&quot; and sharedinfo
+value &quot;label&quot;:
+
+ EVP_KDF *kdf;
+ EVP_KDF_CTX *kctx;
+ unsigned char out[10];
+ OSSL_PARAM params[4], *p = params;
+
+ kdf = EVP_KDF_fetch(NULL, &quot;X963KDF&quot;, NULL);
+ kctx = EVP_KDF_CTX_new(kdf);
+ EVP_KDF_free(kdf);
+
+ *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                         SN_sha256, strlen(SN_sha256));
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SECRET,
+                                          &quot;secret&quot;, (size_t)6);
+ *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+                                          &quot;label&quot;, (size_t)5);
+ *p = OSSL_PARAM_construct_end();
+ if (EVP_KDF_set_params(kctx, params) &lt;= 0) {
+     error(&quot;EVP_KDF_set_params&quot;);
+ }
+ if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
+     error(&quot;EVP_KDF_derive&quot;);
+ }
+
+ EVP_KDF_CTX_free(kctx);
+
+=head1 CONFORMING TO
+
+&quot;SEC 1: Elliptic Curve Cryptography&quot;
+
+=head1 SEE ALSO
+
+L&lt;EVP_KDF&gt;,
+L&lt;EVP_KDF-CTX_new_id(3)&gt;,
+L&lt;EVP_KDF-CTX_free(3)&gt;,
+L&lt;EVP_KDF-ctrl(3)&gt;,
+L&lt;EVP_KDF-size(3)&gt;,
+L&lt;EVP_KDF-derive(3)&gt;,
+L&lt;EVP_KDF-CTX(3)/PARAMETERS&gt;
+
+=head1 HISTORY
+
+This functionality was added to OpenSSL 3.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man7/EVP_KDF_HKDF.pod b/doc/man7/EVP_KDF_HKDF.pod
deleted file mode 100644
index c511c7c705..0000000000
--- a/doc/man7/EVP_KDF_HKDF.pod
+++ /dev/null
@@ -1,180 +0,0 @@
-=pod
-
-=head1 NAME
-
-EVP_KDF_HKDF - The HKDF EVP_KDF implementation
-
-=head1 DESCRIPTION
-
-Support for computing the B&lt;HKDF&gt; KDF through the B&lt;EVP_KDF&gt; API.
-
-The EVP_KDF_HKDF algorithm implements the HKDF key derivation function.
-HKDF follows the &quot;extract-then-expand&quot; paradigm, where the KDF logically
-consists of two modules. The first stage takes the input keying material
-and &quot;extracts&quot; from it a fixed-length pseudorandom key K. The second stage
-&quot;expands&quot; the key K into several additional pseudorandom keys (the output
-of the KDF).
-
-=head2 Numeric identity
-
-B&lt;EVP_KDF_HKDF&gt; is the numeric identity for this implementation; it
-can be used with the EVP_KDF_CTX_new_id() function.
-
-=head2 Supported controls
-
-The supported controls are:
-
-=over 4
-
-=item B&lt;EVP_KDF_CTRL_SET_SALT&gt;
-
-=item B&lt;EVP_KDF_CTRL_SET_MD&gt;
-
-=item B&lt;EVP_KDF_CTRL_SET_KEY&gt;
-
-These controls work as described in L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;.
-
-=item B&lt;EVP_KDF_CTRL_RESET_HKDF_INFO&gt;
-
-This control does not expect any arguments.
-
-Resets the context info buffer to zero length.
-
-=item B&lt;EVP_KDF_CTRL_ADD_HKDF_INFO&gt;
-
-This control expects two arguments: C&lt;unsigned char *info&gt;, C&lt;size_t infolen&gt;
-
-Sets the info value to the first B&lt;infolen&gt; bytes of the buffer B&lt;info&gt;.  If a
-value is already set, the contents of the buffer are appended to the existing
-value.
-
-The total length of the context info buffer cannot exceed 1024 bytes;
-this should be more than enough for any normal use of HKDF.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;info&quot;
-
-The value string is used as is.
-
-=item &quot;hexinfo&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=item B&lt;EVP_KDF_CTRL_SET_HKDF_MODE&gt;
-
-This control expects one argument: C&lt;int mode&gt;
-
-Sets the mode for the HKDF operation. There are three modes that are currently
-defined:
-
-=over 4
-
-=item EVP_KDF_HKDF_MODE_EXTRACT_AND_EXPAND
-
-This is the default mode.  Calling L&lt;EVP_KDF_derive(3)&gt; on an EVP_KDF_CTX set
-up for HKDF will perform an extract followed by an expand operation in one go.
-The derived key returned will be the result after the expand operation. The
-intermediate fixed-length pseudorandom key K is not returned.
-
-In this mode the digest, key, salt and info values must be set before a key is
-derived otherwise an error will occur.
-
-=item EVP_KDF_HKDF_MODE_EXTRACT_ONLY
-
-In this mode calling L&lt;EVP_KDF_derive(3)&gt; will just perform the extract
-operation. The value returned will be the intermediate fixed-length pseudorandom
-key K.  The C&lt;keylen&gt; parameter must match the size of K, which can be looked
-up by calling EVP_KDF_size() after setting the mode and digest.
-
-The digest, key and salt values must be set before a key is derived otherwise
-an error will occur.
-
-=item EVP_KDF_HKDF_MODE_EXPAND_ONLY
-
-In this mode calling L&lt;EVP_KDF_derive(3)&gt; will just perform the expand
-operation. The input key should be set to the intermediate fixed-length
-pseudorandom key K returned from a previous extract operation.
-
-The digest, key and info values must be set before a key is derived otherwise
-an error will occur.
-
-=back
-
-EVP_KDF_ctrl_str() type string: &quot;mode&quot;
-
-The value string is expected to be one of: &quot;EXTRACT_AND_EXPAND&quot;, &quot;EXTRACT_ONLY&quot;
-or &quot;EXPAND_ONLY&quot;.
-
-=back
-
-=head1 NOTES
-
-A context for HKDF can be obtained by calling:
-
- EVP_KDF_CTX *kctx = EVP_KDF_CTX_new_id(EVP_KDF_HKDF);
-
-The output length of an HKDF expand operation is specified via the C&lt;keylen&gt;
-parameter to the L&lt;EVP_KDF_derive(3)&gt; function.  When using
-EVP_KDF_HKDF_MODE_EXTRACT_ONLY the C&lt;keylen&gt; parameter must equal the size of
-the intermediate fixed-length pseudorandom key otherwise an error will occur.
-For that mode, the fixed output size can be looked up by calling EVP_KDF_size()
-after setting the mode and digest on the C&lt;EVP_KDF_CTX&gt;.
-
-=head1 EXAMPLES
-
-This example derives 10 bytes using SHA-256 with the secret key &quot;secret&quot;,
-salt value &quot;salt&quot; and info value &quot;label&quot;:
-
- EVP_KDF_CTX *kctx;
- unsigned char out[10];
-
- kctx = EVP_KDF_CTX_new_id(EVP_KDF_HKDF);
-
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_SET_MD&quot;);
- }
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT, &quot;salt&quot;, (size_t)4) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_SET_SALT&quot;);
- }
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, &quot;secret&quot;, (size_t)6) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_SET_KEY&quot;);
- }
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_HKDF_INFO, &quot;label&quot;, (size_t)5) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_ADD_HKDF_INFO&quot;);
- }
- if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
-     error(&quot;EVP_KDF_derive&quot;);
- }
-
- EVP_KDF_CTX_free(kctx);
-
-=head1 CONFORMING TO
-
-RFC 5869
-
-=head1 SEE ALSO
-
-L&lt;EVP_KDF_CTX&gt;,
-L&lt;EVP_KDF_CTX_new_id(3)&gt;,
-L&lt;EVP_KDF_CTX_free(3)&gt;,
-L&lt;EVP_KDF_ctrl(3)&gt;,
-L&lt;EVP_KDF_size(3)&gt;,
-L&lt;EVP_KDF_derive(3)&gt;,
-L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;
-
-=head1 COPYRIGHT
-
-Copyright 2016-2018 The OpenSSL Project Authors. All Rights Reserved.
-
-Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
-this file except in compliance with the License.  You can obtain a copy
-in the file LICENSE in the source distribution or at
-L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
-
-=cut
diff --git a/doc/man7/EVP_KDF_SS.pod b/doc/man7/EVP_KDF_SS.pod
deleted file mode 100644
index 5c56fbd1b0..0000000000
--- a/doc/man7/EVP_KDF_SS.pod
+++ /dev/null
@@ -1,222 +0,0 @@
-=pod
-
-=head1 NAME
-
-EVP_KDF_SS - The Single Step / One Step EVP_KDF implementation
-
-=head1 DESCRIPTION
-
-The EVP_KDF_SS algorithm implements the Single Step key derivation function (SSKDF).
-SSKDF derives a key using input such as a shared secret key (that was generated
-during the execution of a key establishment scheme) and fixedinfo.
-SSKDF is also informally referred to as 'Concat KDF'.
-
-=head2 Auxiliary function
-
-The implementation uses a selectable auxiliary function H, which can be one of:
-
-=over 4
-
-=item B&lt;H(x) = hash(x, digest=md)&gt;
-
-=item B&lt;H(x) = HMAC_hash(x, key=salt, digest=md)&gt;
-
-=item B&lt;H(x) = KMACxxx(x, key=salt, custom=&quot;KDF&quot;, outlen=mac_size)&gt;
-
-=back
-
-Both the HMAC and KMAC implementations set the key using the 'salt' value.
-The hash and HMAC also require the digest to be set.
-
-=head2 Numeric identity
-
-B&lt;EVP_KDF_SS&gt; is the numeric identity for this implementation; it
-can be used with the EVP_KDF_CTX_new_id() function.
-
-=head2 Supported controls
-
-The supported controls are:
-
-=over 4
-
-=item B&lt;EVP_KDF_CTRL_SET_MD&gt;
-
-=item B&lt;EVP_KDF_CTRL_SET_MAC&gt;
-
-=item B&lt;EVP_MAC_CTRL_SET_MAC_SIZE&gt;
-
-=item B&lt;EVP_KDF_CTRL_SET_SALT&gt;
-
-These controls work as described in L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;.
-
-=item B&lt;EVP_KDF_CTRL_SET_KEY&gt;
-
-This control expects two arguments: C&lt;unsigned char *secret&gt;, C&lt;size_t secretlen&gt;
-
-The shared secret used for key derivation.  This control sets the secret.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;secret&quot;
-
-The value string is used as is.
-
-=item &quot;hexsecret&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=item B&lt;EVP_KDF_CTRL_SET_SSKDF_INFO&gt;
-
-This control expects two arguments: C&lt;unsigned char *info&gt;, C&lt;size_t infolen&gt;
-
-An optional value for fixedinfo, also known as otherinfo. This control sets the fixedinfo.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;info&quot;
-
-The value string is used as is.
-
-=item &quot;hexinfo&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=back
-
-=head1 NOTES
-
-A context for SSKDF can be obtained by calling:
-
-EVP_KDF_CTX *kctx = EVP_KDF_CTX_new_id(EVP_KDF_SS);
-
-The output length of an SSKDF is specified via the C&lt;keylen&gt;
-parameter to the L&lt;EVP_KDF_derive(3)&gt; function.
-
-=head1 EXAMPLES
-
-This example derives 10 bytes using H(x) = SHA-256, with the secret key &quot;secret&quot;
-and fixedinfo value &quot;label&quot;:
-
-  EVP_KDF_CTX *kctx;
-  unsigned char out[10];
-
-  kctx = EVP_KDF_CTX_new_id(EVP_KDF_SS);
-
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_MD&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, &quot;secret&quot;, (size_t)6) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_KEY&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SSKDF_INFO, &quot;label&quot;, (size_t)5) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_SSKDF_INFO&quot;);
-  }
-  if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
-      error(&quot;EVP_KDF_derive&quot;);
-  }
-
-  EVP_KDF_CTX_free(kctx);
-
-This example derives 10 bytes using H(x) = HMAC(SHA-256), with the secret key &quot;secret&quot;,
-fixedinfo value &quot;label&quot; and salt &quot;salt&quot;:
-
-  EVP_KDF_CTX *kctx;
-  unsigned char out[10];
-
-  kctx = EVP_KDF_CTX_new_id(EVP_KDF_SS);
-
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MAC, EVP_get_macbyname(&quot;HMAC&quot;)) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_MAC&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_MD&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, &quot;secret&quot;, (size_t)6) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_KEY&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SSKDF_INFO, &quot;label&quot;, (size_t)5) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_SSKDF_INFO&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT, &quot;salt&quot;, (size_t)4) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_SALT&quot;);
-  }
-  if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
-      error(&quot;EVP_KDF_derive&quot;);
-  }
-
-  EVP_KDF_CTX_free(kctx);
-
-This example derives 10 bytes using H(x) = KMAC128(x,salt,outlen), with the secret key &quot;secret&quot;
-fixedinfo value &quot;label&quot;, salt of &quot;salt&quot; and KMAC outlen of 20:
-
-  EVP_KDF_CTX *kctx;
-  unsigned char out[10];
-
-  kctx = EVP_KDF_CTX_new_id(EVP_KDF_SS);
-
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MAC, EVP_get_macbyname(&quot;KMAC128&quot;)) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_MAC&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_MD&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, &quot;secret&quot;, (size_t)6) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_KEY&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SSKDF_INFO, &quot;label&quot;, (size_t)5) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_SSKDF_INFO&quot;);
-  }
-  /* If not specified the salt will be set to a default value */
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT, &quot;salt&quot;, (size_t)4) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_SALT&quot;);
-  }
-  /* If not specified the default size will be the size of the derived key */
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MAC_SIZE, (size_t)20) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_MAC_SIZE&quot;);
-  }
-  if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
-      error(&quot;EVP_KDF_derive&quot;);
-  }
-
-  EVP_KDF_CTX_free(kctx);
-
-
-=head1 CONFORMING TO
-
-NIST SP800-56Cr1.
-
-=head1 SEE ALSO
-
-L&lt;EVP_KDF_CTX&gt;,
-L&lt;EVP_KDF_CTX_new_id(3)&gt;,
-L&lt;EVP_KDF_CTX_free(3)&gt;,
-L&lt;EVP_KDF_ctrl(3)&gt;,
-L&lt;EVP_KDF_size(3)&gt;,
-L&lt;EVP_KDF_derive(3)&gt;,
-L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;
-
-=head1 HISTORY
-
-This functionality was added to OpenSSL 3.0.
-
-=head1 COPYRIGHT
-
-Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.  Copyright
-(c) 2019, Oracle and/or its affiliates.  All rights reserved.
-
-Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
-this file except in compliance with the License.  You can obtain a copy
-in the file LICENSE in the source distribution or at
-L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
-
-=cut
diff --git a/doc/man7/EVP_KDF_TLS1_PRF.pod b/doc/man7/EVP_KDF_TLS1_PRF.pod
deleted file mode 100644
index 02331ece5e..0000000000
--- a/doc/man7/EVP_KDF_TLS1_PRF.pod
+++ /dev/null
@@ -1,146 +0,0 @@
-=pod
-
-=head1 NAME
-
-EVP_KDF_TLS1_PRF - The TLS1 PRF EVP_KDF implementation
-
-=head1 DESCRIPTION
-
-Support for computing the B&lt;TLS1&gt; PRF through the B&lt;EVP_KDF&gt; API.
-
-The EVP_KDF_TLS1_PRF algorithm implements the PRF used by TLS versions up to
-and including TLS 1.2.
-
-=head2 Numeric identity
-
-B&lt;EVP_KDF_TLS1_PRF&gt; is the numeric identity for this implementation; it
-can be used with the EVP_KDF_CTX_new_id() function.
-
-=head2 Supported controls
-
-The supported controls are:
-
-=over 4
-
-=item B&lt;EVP_KDF_CTRL_SET_MD&gt;
-
-This control works as described in L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;.
-
-The C&lt;EVP_KDF_CTRL_SET_MD&gt; control is used to set the message digest associated
-with the TLS PRF.  EVP_md5_sha1() is treated as a special case which uses the
-PRF algorithm using both B&lt;MD5&gt; and B&lt;SHA1&gt; as used in TLS 1.0 and 1.1.
-
-=item B&lt;EVP_KDF_CTRL_SET_TLS_SECRET&gt;
-
-This control expects two arguments: C&lt;unsigned char *sec&gt;, C&lt;size_t seclen&gt;
-
-Sets the secret value of the TLS PRF to B&lt;seclen&gt; bytes of the buffer B&lt;sec&gt;.
-Any existing secret value is replaced.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;secret&quot;
-
-The value string is used as is.
-
-=item &quot;hexsecret&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=item B&lt;EVP_KDF_CTRL_RESET_TLS_SEED&gt;
-
-This control does not expect any arguments.
-
-Resets the context seed buffer to zero length.
-
-=item B&lt;EVP_KDF_CTRL_ADD_TLS_SEED&gt;
-
-This control expects two arguments: C&lt;unsigned char *seed&gt;, C&lt;size_t seedlen&gt;
-
-Sets the seed to B&lt;seedlen&gt; bytes of B&lt;seed&gt;.  If a seed is already set it is
-appended to the existing value.
-
-The total length of the context seed buffer cannot exceed 1024 bytes;
-this should be more than enough for any normal use of the TLS PRF.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;seed&quot;
-
-The value string is used as is.
-
-=item &quot;hexseed&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=back
-
-=head1 NOTES
-
-A context for the TLS PRF can be obtained by calling:
-
- EVP_KDF_CTX *kctx = EVP_KDF_CTX_new_id(EVP_KDF_TLS1_PRF, NULL);
-
-The digest, secret value and seed must be set before a key is derived otherwise
-an error will occur.
-
-The output length of the PRF is specified by the C&lt;keylen&gt; parameter to the
-EVP_KDF_derive() function.
-
-=head1 EXAMPLES
-
-This example derives 10 bytes using SHA-256 with the secret key &quot;secret&quot;
-and seed value &quot;seed&quot;:
-
- EVP_KDF_CTX *kctx;
- unsigned char out[10];
-
- kctx = EVP_KDF_CTX_new_id(EVP_KDF_TLS1_PRF);
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_SET_MD&quot;);
- }
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_TLS_SECRET,
-                  &quot;secret&quot;, (size_t)6) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_SET_TLS_SECRET&quot;);
- }
- if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_TLS_SEED, &quot;seed&quot;, (size_t)4) &lt;= 0) {
-     error(&quot;EVP_KDF_CTRL_ADD_TLS_SEED&quot;);
- }
- if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
-     error(&quot;EVP_KDF_derive&quot;);
- }
- EVP_KDF_CTX_free(kctx);
-
-=head1 CONFORMING TO
-
-RFC 2246, RFC 5246 and NIST SP 800-135 r1
-
-=head1 SEE ALSO
-
-L&lt;EVP_KDF_CTX&gt;,
-L&lt;EVP_KDF_CTX_new_id(3)&gt;,
-L&lt;EVP_KDF_CTX_free(3)&gt;,
-L&lt;EVP_KDF_ctrl(3)&gt;,
-L&lt;EVP_KDF_derive(3)&gt;,
-L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;
-
-=head1 COPYRIGHT
-
-Copyright 2018 The OpenSSL Project Authors. All Rights Reserved.
-
-Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
-this file except in compliance with the License.  You can obtain a copy
-in the file LICENSE in the source distribution or at
-L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
-
-=cut
diff --git a/doc/man7/EVP_KDF_X942.pod b/doc/man7/EVP_KDF_X942.pod
deleted file mode 100644
index 644cad8cbe..0000000000
--- a/doc/man7/EVP_KDF_X942.pod
+++ /dev/null
@@ -1,150 +0,0 @@
-=pod
-
-=head1 NAME
-
-EVP_KDF_X942 - The X9.42-2001 asn1 EVP_KDF implementation
-
-=head1 DESCRIPTION
-
-The EVP_KDF_X942 algorithm implements the key derivation function (X942KDF).
-X942KDF is used by Cryptographic Message Syntax (CMS) for DH KeyAgreement, to
-derive a key using input such as a shared secret key and other info. The other
-info is DER encoded data that contains a 32 bit counter.
-
-=head2 Numeric identity
-
-B&lt;EVP_KDF_X942&gt; is the numeric identity for this implementation; it
-can be used with the EVP_KDF_CTX_new_id() function.
-
-=head2 Supported controls
-
-The supported controls are:
-
-=over 4
-
-=item B&lt;EVP_KDF_CTRL_SET_MD&gt;
-
-This control works as described in L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;.
-
-=item B&lt;EVP_KDF_CTRL_SET_KEY&gt;
-
-This control expects two arguments: C&lt;unsigned char *secret&gt;, C&lt;size_t secretlen&gt;
-
-The shared secret used for key derivation.  This control sets the secret.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;secret&quot;
-
-The value string is used as is.
-
-=item &quot;hexsecret&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=item B&lt;EVP_KDF_CTRL_SET_UKM&gt;
-
-This control expects two arguments: C&lt;unsigned char *ukm&gt;, C&lt;size_t ukmlen&gt;
-
-An optional random string that is provided by the sender called &quot;partyAInfo&quot;.
-In CMS this is the user keying material.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;ukm&quot;
-
-The value string is used as is.
-
-=item &quot;hexukm&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=item B&lt;EVP_KDF_CTRL_SET_CEK_ALG&gt;
-
-This control expects one argument: C&lt;char *alg&gt;
-
-The CEK wrapping algorithm name. 
-
-EVP_KDF_ctrl_str() type string: &quot;cekalg&quot;
-
-The value string is used as is.
-
-=back
-
-=head1 NOTES
-
-A context for X942KDF can be obtained by calling:
-
-EVP_KDF_CTX *kctx = EVP_KDF_CTX_new_id(EVP_KDF_X942);
-
-The output length of an X942KDF is specified via the C&lt;keylen&gt;
-parameter to the L&lt;EVP_KDF_derive(3)&gt; function.
-
-=head1 EXAMPLES
-
-This example derives 24 bytes, with the secret key &quot;secret&quot; and a random user
-keying material:
-
-  EVP_KDF_CTX *kctx;
-  unsigned char out[192/8];
-  unsignred char ukm[64];
-
-  if (RAND_bytes(ukm, sizeof(ukm)) &lt;= 0)
-      error(&quot;RAND_bytes&quot;);
-
-  kctx = EVP_KDF_CTX_new_id(EVP_KDF_X942);
-  if (kctx == NULL)
-      error(&quot;EVP_KDF_CTX_new_id&quot;);
-
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()) &lt;= 0)
-      error(&quot;EVP_KDF_CTRL_SET_MD&quot;);
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, &quot;secret&quot;, (size_t)6) &lt;= 0)
-      error(&quot;EVP_KDF_CTRL_SET_KEY&quot;);
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_UKM, ukm, sizeof(ukm)) &lt;= 0)
-      error(&quot;EVP_KDF_CTRL_SET_UKM&quot;);
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_CEK_ALG,
-                   SN_id_smime_alg_CMS3DESwrap) &lt;= 0)
-      error(&quot;EVP_KDF_CTRL_SET_CEK_ALG&quot;);
-  if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0)
-      error(&quot;EVP_KDF_derive&quot;);
-
-  EVP_KDF_CTX_free(kctx);
-
-=head1 CONFORMING TO
-
-RFC 2631
-
-=head1 SEE ALSO
-
-L&lt;EVP_KDF_CTX&gt;,
-L&lt;EVP_KDF_CTX_new_id(3)&gt;,
-L&lt;EVP_KDF_CTX_free(3)&gt;,
-L&lt;EVP_KDF_ctrl(3)&gt;,
-L&lt;EVP_KDF_size(3)&gt;,
-L&lt;EVP_KDF_derive(3)&gt;,
-L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;
-
-=head1 HISTORY
-
-This functionality was added to OpenSSL 3.0.
-
-=head1 COPYRIGHT
-
-Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
-
-Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
-this file except in compliance with the License.  You can obtain a copy
-in the file LICENSE in the source distribution or at
-L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
-
-=cut
diff --git a/doc/man7/EVP_KDF_X963.pod b/doc/man7/EVP_KDF_X963.pod
deleted file mode 100644
index 130c9235a9..0000000000
--- a/doc/man7/EVP_KDF_X963.pod
+++ /dev/null
@@ -1,136 +0,0 @@
-=pod
-
-=head1 NAME
-
-EVP_KDF_X963 - The X9.63-2001 EVP_KDF implementation
-
-=head1 DESCRIPTION
-
-The EVP_KDF_X963 algorithm implements the key derivation function (X963KDF).
-X963KDF is used by Cryptographic Message Syntax (CMS) for EC KeyAgreement, to
-derive a key using input such as a shared secret key and shared info.
-
-=head2 Numeric identity
-
-B&lt;EVP_KDF_X963&gt; is the numeric identity for this implementation; it
-can be used with the EVP_KDF_CTX_new_id() function.
-
-=head2 Supported controls
-
-The supported controls are:
-
-=over 4
-
-=item B&lt;EVP_KDF_CTRL_SET_MD&gt;
-
-This control works as described in L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;.
-
-=item B&lt;EVP_KDF_CTRL_SET_KEY&gt;
-
-This control expects two arguments: C&lt;unsigned char *secret&gt;, C&lt;size_t secretlen&gt;
-
-The shared secret used for key derivation.  This control sets the secret.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;secret&quot;
-
-The value string is used as is.
-
-=item &quot;hexsecret&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=item B&lt;EVP_KDF_CTRL_SET_SHARED_INFO&gt;
-
-This control expects two arguments: C&lt;unsigned char *info&gt;, C&lt;size_t infolen&gt;
-
-An optional value for shared info. This control sets the shared info.
-
-EVP_KDF_ctrl_str() takes two type strings for this control:
-
-=over 4
-
-=item &quot;info&quot;
-
-The value string is used as is.
-
-=item &quot;hexinfo&quot;
-
-The value string is expected to be a hexadecimal number, which will be
-decoded before being passed on as the control value.
-
-=back
-
-=back
-
-=head1 NOTES
-
-X963KDF is very similar to the SSKDF that uses a digest as the auxiliary function,
-X963KDF appends the counter to the secret, whereas SSKDF prepends the counter.
-
-A context for X963KDF can be obtained by calling:
-
-EVP_KDF_CTX *kctx = EVP_KDF_CTX_new_id(EVP_KDF_X963);
-
-The output length of an X963KDF is specified via the C&lt;keylen&gt;
-parameter to the L&lt;EVP_KDF_derive(3)&gt; function.
-
-=head1 EXAMPLES
-
-This example derives 10 bytes, with the secret key &quot;secret&quot; and sharedinfo
-value &quot;label&quot;:
-
-  EVP_KDF_CTX *kctx;
-  unsigned char out[10];
-
-  kctx = EVP_KDF_CTX_new_id(EVP_KDF_X963);
-
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_MD&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, &quot;secret&quot;, (size_t)6) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_KEY&quot;);
-  }
-  if (EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SHARED_INFO, &quot;label&quot;, (size_t)5) &lt;= 0) {
-      error(&quot;EVP_KDF_CTRL_SET_SHARED_INFO&quot;);
-  }
-  if (EVP_KDF_derive(kctx, out, sizeof(out)) &lt;= 0) {
-      error(&quot;EVP_KDF_derive&quot;);
-  }
-
-  EVP_KDF_CTX_free(kctx);
-
-=head1 CONFORMING TO
-
-&quot;SEC 1: Elliptic Curve Cryptography&quot;
-
-=head1 SEE ALSO
-
-L&lt;EVP_KDF_CTX&gt;,
-L&lt;EVP_KDF_CTX_new_id(3)&gt;,
-L&lt;EVP_KDF_CTX_free(3)&gt;,
-L&lt;EVP_KDF_ctrl(3)&gt;,
-L&lt;EVP_KDF_size(3)&gt;,
-L&lt;EVP_KDF_derive(3)&gt;,
-L&lt;EVP_KDF_CTX(3)/CONTROLS&gt;
-
-=head1 HISTORY
-
-This functionality was added to OpenSSL 3.0.
-
-=head1 COPYRIGHT
-
-Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
-
-Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
-this file except in compliance with the License.  You can obtain a copy
-in the file LICENSE in the source distribution or at
-L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
-
-=cut
diff --git a/include/openssl/core_names.h b/include/openssl/core_names.h
index 2fe06dc272..1d8857295c 100644
--- a/include/openssl/core_names.h
+++ b/include/openssl/core_names.h
@@ -92,6 +92,31 @@ extern &quot;C&quot; {
 #define OSSL_MAC_NAME_KMAC128       &quot;KMAC128&quot;
 #define OSSL_MAC_NAME_KMAC256       &quot;KMAC256&quot;
 
+/* KDF / PRF parameters */
+#define OSSL_KDF_PARAM_SECRET       &quot;secret&quot;    /* octet string */
+#define OSSL_KDF_PARAM_KEY          &quot;key&quot;       /* octet string */
+#define OSSL_KDF_PARAM_SALT         &quot;salt&quot;      /* octet string */
+#define OSSL_KDF_PARAM_PASSWORD     &quot;pass&quot;      /* octet string */
+#define OSSL_KDF_PARAM_DIGEST       &quot;digest&quot;    /* utf8 string */
+#define OSSL_KDF_PARAM_MAC          &quot;mac&quot;       /* utf8 string */
+#define OSSL_KDF_PARAM_MAC_SIZE     &quot;maclen&quot;    /* size_t */
+#define OSSL_KDF_PARAM_PROPERTIES   &quot;properties&quot; /* utf8 string */
+#define OSSL_KDF_PARAM_ITER         &quot;iter&quot;      /* unsigned int */
+#define OSSL_KDF_PARAM_MODE         &quot;mode&quot;      /* utf8 string or int */
+#define OSSL_KDF_PARAM_PKCS5        &quot;pkcs5&quot;     /* int */
+#define OSSL_KDF_PARAM_UKM          &quot;ukm&quot;       /* octet string */
+#define OSSL_KDF_PARAM_CEK_ALG      &quot;cekalg&quot;    /* utf8 string */
+#define OSSL_KDF_PARAM_SCRYPT_N     &quot;n&quot;         /* uint64_t */
+#define OSSL_KDF_PARAM_SCRYPT_R     &quot;r&quot;         /* uint32_t */
+#define OSSL_KDF_PARAM_SCRYPT_P     &quot;p&quot;         /* uint32_t */
+#define OSSL_KDF_PARAM_SCRYPT_MAXMEM &quot;maxmem_bytes&quot; /* uint64_t */
+#define OSSL_KDF_PARAM_INFO         &quot;info&quot;      /* octet string */
+#define OSSL_KDF_PARAM_SEED         &quot;seed&quot;      /* octet string */
+#define OSSL_KDF_PARAM_SSHKDF_XCGHASH &quot;xcghash&quot; /* octet string */
+#define OSSL_KDF_PARAM_SSHKDF_SESSION_ID &quot;session_id&quot; /* octet string */
+#define OSSL_KDF_PARAM_SSHKDF_TYPE  &quot;type&quot;      /* int */
+#define OSSL_KDF_PARAM_SIZE         &quot;size&quot;      /* size_t */
+
 /* PKEY parameters */
 /* Diffie-Hellman Parameters */
 #define OSSL_PKEY_PARAM_DH_P         &quot;dh-p&quot;
diff --git a/include/openssl/core_numbers.h b/include/openssl/core_numbers.h
index e39410893e..521cd8c800 100644
--- a/include/openssl/core_numbers.h
+++ b/include/openssl/core_numbers.h
@@ -153,6 +153,7 @@ OSSL_CORE_MAKE_FUNC(const OSSL_ITEM *,provider_get_reason_strings,
 # define OSSL_OP_DIGEST                              1
 # define OSSL_OP_CIPHER                              2   /* Symmetric Ciphers */
 # define OSSL_OP_MAC                                 3
+# define OSSL_OP_KDF                                 4
 # define OSSL_OP_KEYMGMT                            10
 # define OSSL_OP_KEYEXCH                            11
 /* Highest known operation number */
@@ -281,6 +282,35 @@ OSSL_CORE_MAKE_FUNC(int, OP_mac_get_ctx_params,
 OSSL_CORE_MAKE_FUNC(int, OP_mac_set_ctx_params,
                     (void *mctx, const OSSL_PARAM params[]))
 
+/* KDFs and PRFs */
+
+# define OSSL_FUNC_KDF_NEWCTX                        1
+# define OSSL_FUNC_KDF_DUPCTX                        2
+# define OSSL_FUNC_KDF_FREECTX                       3
+# define OSSL_FUNC_KDF_RESET                         4
+# define OSSL_FUNC_KDF_DERIVE                        5
+# define OSSL_FUNC_KDF_GETTABLE_PARAMS               6
+# define OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS           7
+# define OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS           8
+# define OSSL_FUNC_KDF_GET_PARAMS                    9
+# define OSSL_FUNC_KDF_GET_CTX_PARAMS               10
+# define OSSL_FUNC_KDF_SET_CTX_PARAMS               11
+
+OSSL_CORE_MAKE_FUNC(void *, OP_kdf_newctx, (void *provctx))
+OSSL_CORE_MAKE_FUNC(void *, OP_kdf_dupctx, (void *src))
+OSSL_CORE_MAKE_FUNC(void, OP_kdf_freectx, (void *kctx))
+OSSL_CORE_MAKE_FUNC(void, OP_kdf_reset, (void *kctx))
+OSSL_CORE_MAKE_FUNC(int, OP_kdf_derive, (void *kctx, unsigned char *key,
+                                          size_t keylen))
+OSSL_CORE_MAKE_FUNC(const OSSL_PARAM *, OP_kdf_gettable_params, (void))
+OSSL_CORE_MAKE_FUNC(const OSSL_PARAM *, OP_kdf_gettable_ctx_params, (void))
+OSSL_CORE_MAKE_FUNC(const OSSL_PARAM *, OP_kdf_settable_ctx_params, (void))
+OSSL_CORE_MAKE_FUNC(int, OP_kdf_get_params, (OSSL_PARAM params[]))
+OSSL_CORE_MAKE_FUNC(int, OP_kdf_get_ctx_params,
+                    (void *kctx, OSSL_PARAM params[]))
+OSSL_CORE_MAKE_FUNC(int, OP_kdf_set_ctx_params,
+                    (void *kctx, const OSSL_PARAM params[]))
+
 /*-
  * Key management
  *
diff --git a/include/openssl/crypto.h b/include/openssl/crypto.h
index da62eef1b1..60aca02849 100644
--- a/include/openssl/crypto.h
+++ b/include/openssl/crypto.h
@@ -408,8 +408,8 @@ int CRYPTO_memcmp(const void * in_a, const void * in_b, size_t len);
 /* OPENSSL_INIT flag range 0x03f00000 reserved for OPENSSL_init_ssl() */
 /* FREE: 0x04000000L */
 /* FREE: 0x08000000L */
-# define OPENSSL_INIT_NO_ADD_ALL_KDFS        0x10000000L
-# define OPENSSL_INIT_ADD_ALL_KDFS           0x20000000L
+/* FREE: 0x10000000L */
+/* FREE: 0x20000000L */
 /* FREE: 0x40000000L */
 /* FREE: 0x80000000L */
 /* Max OPENSSL_INIT flag value is 0x80000000 */
diff --git a/include/openssl/ecerr.h b/include/openssl/ecerr.h
index 43d41d8340..95723ec94b 100644
--- a/include/openssl/ecerr.h
+++ b/include/openssl/ecerr.h
@@ -39,9 +39,14 @@ int ERR_load_EC_strings(void);
 #   define EC_F_ECDH_SIMPLE_COMPUTE_KEY                     0
 #   define EC_F_ECDSA_DO_SIGN_EX                            0
 #   define EC_F_ECDSA_DO_VERIFY                             0
+#   define EC_F_ECDSA_S390X_NISTP_SIGN_SIG                  0
+#   define EC_F_ECDSA_S390X_NISTP_VERIFY_SIG                0
 #   define EC_F_ECDSA_SIGN_EX                               0
 #   define EC_F_ECDSA_SIGN_SETUP                            0
 #   define EC_F_ECDSA_SIG_NEW                               0
+#   define EC_F_ECDSA_SIMPLE_SIGN_SETUP                     0
+#   define EC_F_ECDSA_SIMPLE_SIGN_SIG                       0
+#   define EC_F_ECDSA_SIMPLE_VERIFY_SIG                     0
 #   define EC_F_ECDSA_VERIFY                                0
 #   define EC_F_ECD_ITEM_VERIFY                             0
 #   define EC_F_ECKEY_PARAM2TYPE                            0
@@ -110,6 +115,7 @@ int ERR_load_EC_strings(void);
 #   define EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES    0
 #   define EC_F_EC_GROUP_CHECK                              0
 #   define EC_F_EC_GROUP_CHECK_DISCRIMINANT                 0
+#   define EC_F_EC_GROUP_CHECK_NAMED_CURVE                  0
 #   define EC_F_EC_GROUP_COPY                               0
 #   define EC_F_EC_GROUP_GET_CURVE                          0
 #   define EC_F_EC_GROUP_GET_CURVE_GF2M                     0
@@ -121,6 +127,8 @@ int ERR_load_EC_strings(void);
 #   define EC_F_EC_GROUP_GET_TRINOMIAL_BASIS                0
 #   define EC_F_EC_GROUP_NEW                                0
 #   define EC_F_EC_GROUP_NEW_BY_CURVE_NAME                  0
+#   define EC_F_EC_GROUP_NEW_BY_CURVE_NAME_EX               0
+#   define EC_F_EC_GROUP_NEW_EX                             0
 #   define EC_F_EC_GROUP_NEW_FROM_DATA                      0
 #   define EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS              0
 #   define EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS            0
@@ -134,6 +142,7 @@ int ERR_load_EC_strings(void);
 #   define EC_F_EC_KEY_GENERATE_KEY                         0
 #   define EC_F_EC_KEY_NEW                                  0
 #   define EC_F_EC_KEY_NEW_METHOD                           0
+#   define EC_F_EC_KEY_NEW_METHOD_INT                       0
 #   define EC_F_EC_KEY_OCT2PRIV                             0
 #   define EC_F_EC_KEY_PRINT                                0
 #   define EC_F_EC_KEY_PRINT_FP                             0
@@ -186,6 +195,7 @@ int ERR_load_EC_strings(void);
 #   define EC_F_O2I_ECPUBLICKEY                             0
 #   define EC_F_OLD_EC_PRIV_DECODE                          0
 #   define EC_F_OSSL_ECDH_COMPUTE_KEY                       0
+#   define EC_F_OSSL_ECDSA_SIGN_SETUP                       0
 #   define EC_F_OSSL_ECDSA_SIGN_SIG                         0
 #   define EC_F_OSSL_ECDSA_VERIFY_SIG                       0
 #   define EC_F_PKEY_ECD_CTRL                               0
diff --git a/include/openssl/err.h b/include/openssl/err.h
index 88c8f1c83d..03c3593f34 100644
--- a/include/openssl/err.h
+++ b/include/openssl/err.h
@@ -97,13 +97,12 @@ typedef struct err_state_st {
 /* # define ERR_LIB_JPAKE       49 */
 # define ERR_LIB_CT              50
 # define ERR_LIB_ASYNC           51
-# define ERR_LIB_KDF             52
-# define ERR_LIB_SM2             53
-# define ERR_LIB_ESS             54
-# define ERR_LIB_PROP            55
-# define ERR_LIB_CRMF            56
-# define ERR_LIB_PROV            57
-# define ERR_LIB_CMP             58
+# define ERR_LIB_SM2             52
+# define ERR_LIB_ESS             53
+# define ERR_LIB_PROP            54
+# define ERR_LIB_CRMF            55
+# define ERR_LIB_PROV            56
+# define ERR_LIB_CMP             57
 
 # define ERR_LIB_USER            128
 
@@ -145,7 +144,6 @@ typedef struct err_state_st {
 # define HMACerr(f,r) ERR_raise(ERR_LIB_HMAC,(r))
 # define CTerr(f,r) ERR_raise(ERR_LIB_CT,(r))
 # define ASYNCerr(f,r) ERR_raise(ERR_LIB_ASYNC,(r))
-# define KDFerr(f,r) ERR_raise(ERR_LIB_KDF,(r))
 # define SM2err(f,r) ERR_raise(ERR_LIB_SM2,(r))
 # define ESSerr(f,r) ERR_raise(ERR_LIB_ESS,(r))
 # define PROPerr(f,r) ERR_raise(ERR_LIB_PROP,(r))
diff --git a/include/openssl/evperr.h b/include/openssl/evperr.h
index 714f170bd9..64ed5a3b95 100644
--- a/include/openssl/evperr.h
+++ b/include/openssl/evperr.h
@@ -65,10 +65,8 @@ int ERR_load_EVP_strings(void);
 #  define EVP_F_EVP_ENCRYPTDECRYPTUPDATE                   0
 #  define EVP_F_EVP_ENCRYPTFINAL_EX                        0
 #  define EVP_F_EVP_ENCRYPTUPDATE                          0
-#  define EVP_F_EVP_KDF_CTRL                               0
-#  define EVP_F_EVP_KDF_CTRL_STR                           0
+#  define EVP_F_EVP_KDF_CTX_DUP                            0
 #  define EVP_F_EVP_KDF_CTX_NEW                            0
-#  define EVP_F_EVP_KDF_CTX_NEW_ID                         0
 #  define EVP_F_EVP_KEYEXCH_FETCH                          0
 #  define EVP_F_EVP_KEYEXCH_FROM_DISPATCH                  0
 #  define EVP_F_EVP_MAC_CTRL                               0
diff --git a/include/openssl/kdf.h b/include/openssl/kdf.h
index 300cf760dc..a9ea768d1d 100644
--- a/include/openssl/kdf.h
+++ b/include/openssl/kdf.h
@@ -13,37 +13,37 @@
 # include &lt;stdarg.h&gt;
 # include &lt;stddef.h&gt;
 # include &lt;openssl/ossl_typ.h&gt;
-# include &lt;openssl/kdferr.h&gt;
+# include &lt;openssl/core.h&gt;
+
 # ifdef __cplusplus
 extern &quot;C&quot; {
 # endif
 
-# define EVP_KDF_PBKDF2     NID_id_pbkdf2
-# define EVP_KDF_SCRYPT     NID_id_scrypt
-# define EVP_KDF_TLS1_PRF   NID_tls1_prf
-# define EVP_KDF_HKDF       NID_hkdf
-# define EVP_KDF_SSHKDF     NID_sshkdf
-# define EVP_KDF_SS         NID_sskdf
-# define EVP_KDF_X963       NID_x963kdf
-# define EVP_KDF_X942       NID_x942kdf
-
-EVP_KDF_CTX *EVP_KDF_CTX_new_id(int id);
-EVP_KDF_CTX *EVP_KDF_CTX_new(const EVP_KDF *kdf);
+int EVP_KDF_up_ref(EVP_KDF *kdf);
+void EVP_KDF_free(EVP_KDF *kdf);
+EVP_KDF *EVP_KDF_fetch(OPENSSL_CTX *libctx, const char *algorithm,
+                       const char *properties);
+
+EVP_KDF_CTX *EVP_KDF_CTX_new(EVP_KDF *kdf);
 void EVP_KDF_CTX_free(EVP_KDF_CTX *ctx);
+EVP_KDF_CTX *EVP_KDF_CTX_dup(const EVP_KDF_CTX *src);
+const char *EVP_KDF_name(const EVP_KDF *kdf);
+const OSSL_PROVIDER *EVP_KDF_provider(const EVP_KDF *kdf);
 const EVP_KDF *EVP_KDF_CTX_kdf(EVP_KDF_CTX *ctx);
 
 void EVP_KDF_reset(EVP_KDF_CTX *ctx);
-int EVP_KDF_ctrl(EVP_KDF_CTX *ctx, int cmd, ...);
-int EVP_KDF_vctrl(EVP_KDF_CTX *ctx, int cmd, va_list args);
-int EVP_KDF_ctrl_str(EVP_KDF_CTX *ctx, const char *type, const char *value);
 size_t EVP_KDF_size(EVP_KDF_CTX *ctx);
 int EVP_KDF_derive(EVP_KDF_CTX *ctx, unsigned char *key, size_t keylen);
+int EVP_KDF_get_params(EVP_KDF *kdf, OSSL_PARAM params[]);
+int EVP_KDF_CTX_get_params(EVP_KDF_CTX *ctx, OSSL_PARAM params[]);
+int EVP_KDF_CTX_set_params(EVP_KDF_CTX *ctx, const OSSL_PARAM params[]);
+const OSSL_PARAM *EVP_KDF_gettable_params(const EVP_KDF *kdf);
+const OSSL_PARAM *EVP_KDF_CTX_gettable_params(const EVP_KDF *kdf);
+const OSSL_PARAM *EVP_KDF_CTX_settable_params(const EVP_KDF *kdf);
 
-int EVP_KDF_nid(const EVP_KDF *kdf);
-# define EVP_get_kdfbynid(a)    EVP_get_kdfbyname(OBJ_nid2sn(a))
-# define EVP_get_kdfbyobj(a)    EVP_get_kdfbynid(OBJ_obj2nid(a))
-# define EVP_KDF_name(o)        OBJ_nid2sn(EVP_KDF_nid(o))
-const EVP_KDF *EVP_get_kdfbyname(const char *name);
+void EVP_KDF_do_all_ex(OPENSSL_CTX *libctx,
+                       void (*fn)(EVP_KDF *kdf, void *arg),
+                       void *arg);
 
 # define EVP_KDF_CTRL_SET_PASS               0x01 /* unsigned char *, size_t */
 # define EVP_KDF_CTRL_SET_SALT               0x02 /* unsigned char *, size_t */
@@ -52,23 +52,22 @@ const EVP_KDF *EVP_get_kdfbyname(const char *name);
 # define EVP_KDF_CTRL_SET_KEY                0x05 /* unsigned char *, size_t */
 # define EVP_KDF_CTRL_SET_MAXMEM_BYTES       0x06 /* uint64_t */
 # define EVP_KDF_CTRL_SET_TLS_SECRET         0x07 /* unsigned char *, size_t */
-# define EVP_KDF_CTRL_RESET_TLS_SEED         0x08
-# define EVP_KDF_CTRL_ADD_TLS_SEED           0x09 /* unsigned char *, size_t */
-# define EVP_KDF_CTRL_RESET_HKDF_INFO        0x0a
-# define EVP_KDF_CTRL_ADD_HKDF_INFO          0x0b /* unsigned char *, size_t */
-# define EVP_KDF_CTRL_SET_HKDF_MODE          0x0c /* int */
-# define EVP_KDF_CTRL_SET_SCRYPT_N           0x0d /* uint64_t */
-# define EVP_KDF_CTRL_SET_SCRYPT_R           0x0e /* uint32_t */
-# define EVP_KDF_CTRL_SET_SCRYPT_P           0x0f /* uint32_t */
-# define EVP_KDF_CTRL_SET_SSHKDF_XCGHASH     0x10 /* unsigned char *, size_t */
-# define EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID  0x11 /* unsigned char *, size_t */
-# define EVP_KDF_CTRL_SET_SSHKDF_TYPE        0x12 /* int */
-# define EVP_KDF_CTRL_SET_MAC                0x13 /* EVP_MAC * */
-# define EVP_KDF_CTRL_SET_MAC_SIZE           0x14 /* size_t */
-# define EVP_KDF_CTRL_SET_SSKDF_INFO         0x15 /* unsigned char *, size_t */
-# define EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE  0x16 /* int */
-# define EVP_KDF_CTRL_SET_UKM                0x17 /* unsigned char *, size_t */
-# define EVP_KDF_CTRL_SET_CEK_ALG            0x18 /* char * */
+# define EVP_KDF_CTRL_ADD_TLS_SEED           0x08 /* unsigned char *, size_t */
+# define EVP_KDF_CTRL_RESET_HKDF_INFO        0x09
+# define EVP_KDF_CTRL_ADD_HKDF_INFO          0x0a /* unsigned char *, size_t */
+# define EVP_KDF_CTRL_SET_HKDF_MODE          0x0b /* int */
+# define EVP_KDF_CTRL_SET_SCRYPT_N           0x0c /* uint64_t */
+# define EVP_KDF_CTRL_SET_SCRYPT_R           0x0d /* uint32_t */
+# define EVP_KDF_CTRL_SET_SCRYPT_P           0x0e /* uint32_t */
+# define EVP_KDF_CTRL_SET_SSHKDF_XCGHASH     0x0f /* unsigned char *, size_t */
+# define EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID  0x10 /* unsigned char *, size_t */
+# define EVP_KDF_CTRL_SET_SSHKDF_TYPE        0x11 /* int */
+# define EVP_KDF_CTRL_SET_MAC                0x12 /* EVP_MAC * */
+# define EVP_KDF_CTRL_SET_MAC_SIZE           0x13 /* size_t */
+# define EVP_KDF_CTRL_SET_SSKDF_INFO         0x14 /* unsigned char *, size_t */
+# define EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE  0x15 /* int */
+# define EVP_KDF_CTRL_SET_UKM                0x16 /* unsigned char *, size_t */
+# define EVP_KDF_CTRL_SET_CEK_ALG            0x17 /* char * */
 # define EVP_KDF_CTRL_SET_SHARED_INFO        EVP_KDF_CTRL_SET_SSKDF_INFO
 
 # define EVP_KDF_HKDF_MODE_EXTRACT_AND_EXPAND  0
diff --git a/include/openssl/kdferr.h b/include/openssl/kdferr.h
deleted file mode 100644
index d28640040c..0000000000
--- a/include/openssl/kdferr.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Generated by util/mkerr.pl DO NOT EDIT
- * Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
- *
- * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
- * this file except in compliance with the License.  You can obtain a copy
- * in the file LICENSE in the source distribution or at
- * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
- */
-
-#ifndef HEADER_KDFERR_H
-# define HEADER_KDFERR_H
-
-# include &lt;openssl/opensslconf.h&gt;
-# include &lt;openssl/symhacks.h&gt;
-
-
-# ifdef  __cplusplus
-extern &quot;C&quot;
-# endif
-int ERR_load_KDF_strings(void);
-
-/*
- * KDF function codes.
- */
-# if !OPENSSL_API_3
-#  define KDF_F_HKDF_EXTRACT                               0
-#  define KDF_F_KDF_HKDF_DERIVE                            0
-#  define KDF_F_KDF_HKDF_NEW                               0
-#  define KDF_F_KDF_HKDF_SIZE                              0
-#  define KDF_F_KDF_MD2CTRL                                0
-#  define KDF_F_KDF_PBKDF2_CTRL                            0
-#  define KDF_F_KDF_PBKDF2_CTRL_STR                        0
-#  define KDF_F_KDF_PBKDF2_DERIVE                          0
-#  define KDF_F_KDF_PBKDF2_NEW                             0
-#  define KDF_F_KDF_SCRYPT_CTRL_STR                        0
-#  define KDF_F_KDF_SCRYPT_CTRL_UINT32                     0
-#  define KDF_F_KDF_SCRYPT_CTRL_UINT64                     0
-#  define KDF_F_KDF_SCRYPT_DERIVE                          0
-#  define KDF_F_KDF_SCRYPT_NEW                             0
-#  define KDF_F_KDF_SSHKDF_CTRL                            0
-#  define KDF_F_KDF_SSHKDF_CTRL_STR                        0
-#  define KDF_F_KDF_SSHKDF_DERIVE                          0
-#  define KDF_F_KDF_SSHKDF_NEW                             0
-#  define KDF_F_KDF_TLS1_PRF_CTRL_STR                      0
-#  define KDF_F_KDF_TLS1_PRF_DERIVE                        0
-#  define KDF_F_KDF_TLS1_PRF_NEW                           0
-#  define KDF_F_PBKDF2_DERIVE                              0
-#  define KDF_F_PBKDF2_SET_MEMBUF                          0
-#  define KDF_F_PKEY_HKDF_CTRL_STR                         0
-#  define KDF_F_PKEY_HKDF_DERIVE                           0
-#  define KDF_F_PKEY_HKDF_INIT                             0
-#  define KDF_F_PKEY_SCRYPT_CTRL_STR                       0
-#  define KDF_F_PKEY_SCRYPT_CTRL_UINT64                    0
-#  define KDF_F_PKEY_SCRYPT_DERIVE                         0
-#  define KDF_F_PKEY_SCRYPT_INIT                           0
-#  define KDF_F_PKEY_SCRYPT_SET_MEMBUF                     0
-#  define KDF_F_PKEY_TLS1_PRF_CTRL_STR                     0
-#  define KDF_F_PKEY_TLS1_PRF_DERIVE                       0
-#  define KDF_F_PKEY_TLS1_PRF_INIT                         0
-#  define KDF_F_SCRYPT_SET_MEMBUF                          0
-#  define KDF_F_SSKDF_CTRL_STR                             0
-#  define KDF_F_SSKDF_DERIVE                               0
-#  define KDF_F_SSKDF_MAC2CTRL                             0
-#  define KDF_F_SSKDF_NEW                                  0
-#  define KDF_F_SSKDF_SIZE                                 0
-#  define KDF_F_TLS1_PRF_ALG                               0
-#  define KDF_F_X942KDF_CTRL                               0
-#  define KDF_F_X942KDF_DERIVE                             0
-#  define KDF_F_X942KDF_HASH_KDM                           0
-#  define KDF_F_X942KDF_NEW                                0
-#  define KDF_F_X942KDF_SIZE                               0
-#  define KDF_F_X963KDF_DERIVE                             0
-# endif
-
-/*
- * KDF reason codes.
- */
-# define KDF_R_BAD_ENCODING                               122
-# define KDF_R_BAD_LENGTH                                 123
-# define KDF_R_INAVLID_UKM_LEN                            124
-# define KDF_R_INVALID_DIGEST                             100
-# define KDF_R_INVALID_ITERATION_COUNT                    119
-# define KDF_R_INVALID_KEY_LEN                            120
-# define KDF_R_INVALID_MAC_TYPE                           116
-# define KDF_R_INVALID_SALT_LEN                           121
-# define KDF_R_MISSING_CEK_ALG                            125
-# define KDF_R_MISSING_ITERATION_COUNT                    109
-# define KDF_R_MISSING_KEY                                104
-# define KDF_R_MISSING_MESSAGE_DIGEST                     105
-# define KDF_R_MISSING_PARAMETER                          101
-# define KDF_R_MISSING_PASS                               110
-# define KDF_R_MISSING_SALT                               111
-# define KDF_R_MISSING_SECRET                             107
-# define KDF_R_MISSING_SEED                               106
-# define KDF_R_MISSING_SESSION_ID                         113
-# define KDF_R_MISSING_TYPE                               114
-# define KDF_R_MISSING_XCGHASH                            115
-# define KDF_R_NOT_SUPPORTED                              118
-# define KDF_R_UNKNOWN_PARAMETER_TYPE                     103
-# define KDF_R_UNSUPPORTED_CEK_ALG                        126
-# define KDF_R_UNSUPPORTED_MAC_TYPE                       117
-# define KDF_R_VALUE_ERROR                                108
-# define KDF_R_VALUE_MISSING                              102
-# define KDF_R_WRONG_OUTPUT_BUFFER_SIZE                   112
-
-#endif
diff --git a/providers/common/build.info b/providers/common/build.info
index 4c977d3f25..4d87b15e8d 100644
--- a/providers/common/build.info
+++ b/providers/common/build.info
@@ -1,4 +1,4 @@
-SUBDIRS=digests ciphers macs exchange keymgmt
+SUBDIRS=digests ciphers macs kdfs exchange keymgmt
 
 SOURCE[../../libcrypto]=\
         provider_err.c provlib.c
diff --git a/providers/common/include/internal/provider_algs.h b/providers/common/include/internal/provider_algs.h
index e66c0523e7..b9d257649f 100644
--- a/providers/common/include/internal/provider_algs.h
+++ b/providers/common/include/internal/provider_algs.h
@@ -115,17 +115,6 @@ extern const OSSL_DISPATCH camellia192ctr_functions[];
 extern const OSSL_DISPATCH camellia128ctr_functions[];
 #endif /* OPENSSL_NO_CAMELLIA */
 
-/* MACs */
-extern const OSSL_DISPATCH blake2bmac_functions[];
-extern const OSSL_DISPATCH blake2smac_functions[];
-extern const OSSL_DISPATCH cmac_functions[];
-extern const OSSL_DISPATCH gmac_functions[];
-extern const OSSL_DISPATCH hmac_functions[];
-extern const OSSL_DISPATCH kmac128_functions[];
-extern const OSSL_DISPATCH kmac256_functions[];
-extern const OSSL_DISPATCH siphash_functions[];
-extern const OSSL_DISPATCH poly1305_functions[];
-
 extern const OSSL_DISPATCH tdes_ede3_ecb_functions[];
 extern const OSSL_DISPATCH tdes_ede3_cbc_functions[];
 
@@ -144,6 +133,32 @@ extern const OSSL_DISPATCH tdes_desx_cbc_functions[];
 extern const OSSL_DISPATCH tdes_wrap_cbc_functions[];
 #endif /* FIPS_MODE */
 
+/* MACs */
+extern const OSSL_DISPATCH blake2bmac_functions[];
+extern const OSSL_DISPATCH blake2smac_functions[];
+extern const OSSL_DISPATCH cmac_functions[];
+extern const OSSL_DISPATCH gmac_functions[];
+extern const OSSL_DISPATCH hmac_functions[];
+extern const OSSL_DISPATCH kmac128_functions[];
+extern const OSSL_DISPATCH kmac256_functions[];
+extern const OSSL_DISPATCH siphash_functions[];
+extern const OSSL_DISPATCH poly1305_functions[];
+
+/* KDFs / PRFs */
+extern const OSSL_DISPATCH kdf_pbkdf2_functions[];
+#ifndef OPENSSL_NO_SCRYPT
+extern const OSSL_DISPATCH kdf_scrypt_functions[];
+#endif
+extern const OSSL_DISPATCH kdf_tls1_prf_functions[];
+extern const OSSL_DISPATCH kdf_hkdf_functions[];
+extern const OSSL_DISPATCH kdf_sshkdf_functions[];
+extern const OSSL_DISPATCH kdf_sskdf_functions[];
+extern const OSSL_DISPATCH kdf_x963_kdf_functions[];
+#ifndef OPENSSL_NO_CMS
+extern const OSSL_DISPATCH kdf_x942_kdf_functions[];
+#endif
+
+
 /* Key management */
 extern const OSSL_DISPATCH dh_keymgmt_functions[];
 
diff --git a/providers/common/include/internal/providercommonerr.h b/providers/common/include/internal/providercommonerr.h
index c436495a5b..39f56b4950 100644
--- a/providers/common/include/internal/providercommonerr.h
+++ b/providers/common/include/internal/providercommonerr.h
@@ -51,25 +51,51 @@ int ERR_load_PROV_strings(void);
  */
 # define PROV_R_AES_KEY_SETUP_FAILED                      101
 # define PROV_R_BAD_DECRYPT                               100
+# define PROV_R_BAD_ENCODING                              141
+# define PROV_R_BAD_LENGTH                                142
+# define PROV_R_BOTH_MODE_AND_MODE_INT                    127
 # define PROV_R_CIPHER_OPERATION_FAILED                   102
 # define PROV_R_FAILED_TO_GENERATE_KEY                    121
 # define PROV_R_FAILED_TO_GET_PARAMETER                   103
 # define PROV_R_FAILED_TO_SET_PARAMETER                   104
+# define PROV_R_INAVLID_UKM_LENGTH                        146
 # define PROV_R_INVALID_AAD                               108
 # define PROV_R_INVALID_CUSTOM_LENGTH                     111
 # define PROV_R_INVALID_DATA                              115
+# define PROV_R_INVALID_DIGEST                            122
+# define PROV_R_INVALID_ITERATION_COUNT                   123
 # define PROV_R_INVALID_IVLEN                             116
 # define PROV_R_INVALID_IV_LENGTH                         109
 # define PROV_R_INVALID_KEYLEN                            117
+# define PROV_R_INVALID_KEY_LEN                           124
 # define PROV_R_INVALID_KEY_LENGTH                        105
+# define PROV_R_INVALID_MODE                              125
+# define PROV_R_INVALID_MODE_INT                          126
 # define PROV_R_INVALID_SALT_LENGTH                       112
 # define PROV_R_INVALID_TAG                               110
 # define PROV_R_INVALID_TAGLEN                            118
+# define PROV_R_MISSING_CEK_ALG                           144
+# define PROV_R_MISSING_KEY                               128
+# define PROV_R_MISSING_MESSAGE_DIGEST                    129
+# define PROV_R_MISSING_PASS                              130
+# define PROV_R_MISSING_SALT                              131
+# define PROV_R_MISSING_SECRET                            132
+# define PROV_R_MISSING_SEED                              140
+# define PROV_R_MISSING_SESSION_ID                        133
+# define PROV_R_MISSING_TYPE                              134
+# define PROV_R_MISSING_XCGHASH                           135
+# define PROV_R_NOT_SUPPORTED                             136
 # define PROV_R_NOT_XOF_OR_INVALID_LENGTH                 113
 # define PROV_R_NO_KEY_SET                                114
 # define PROV_R_OUTPUT_BUFFER_TOO_SMALL                   106
 # define PROV_R_TAG_NOTSET                                119
 # define PROV_R_TAG_NOT_NEEDED                            120
+# define PROV_R_UNABLE_TO_LOAD_SHA1                       143
+# define PROV_R_UNABLE_TO_LOAD_SHA256                     147
+# define PROV_R_UNSUPPORTED_CEK_ALG                       145
+# define PROV_R_UNSUPPORTED_MAC_TYPE                      137
+# define PROV_R_VALUE_ERROR                               138
 # define PROV_R_WRONG_FINAL_BLOCK_LENGTH                  107
+# define PROV_R_WRONG_OUTPUT_BUFFER_SIZE                  139
 
 #endif
diff --git a/providers/common/kdfs/build.info b/providers/common/kdfs/build.info
new file mode 100644
index 0000000000..a881fa00b9
--- /dev/null
+++ b/providers/common/kdfs/build.info
@@ -0,0 +1,13 @@
+$COMMON=tls1_prf.c hkdf.c pbkdf2.c sskdf.c
+
+LIBS=../../../libcrypto
+SOURCE[../../../libcrypto]=$COMMON
+INCLUDE[../../../libcrypto]=. ../../../crypto
+
+IF[{- !$disabled{fips} -}]
+  MODULES=../../fips
+  SOURCE[../../fips]=$COMMON
+  INCLUDE[../../fips]=. ../../../crypto
+ENDIF
+
+        
diff --git a/crypto/kdf/hkdf.c b/providers/common/kdfs/hkdf.c
similarity index 50%
rename from crypto/kdf/hkdf.c
rename to providers/common/kdfs/hkdf.c
index 33c74da86a..30bda90f69 100644
--- a/crypto/kdf/hkdf.c
+++ b/providers/common/kdfs/hkdf.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016-2018 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2016-2019 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -13,14 +13,26 @@
 #include &lt;openssl/hmac.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/kdf.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;internal/numbers.h&quot;
 #include &quot;internal/evp_int.h&quot;
-#include &quot;kdf_local.h&quot;
+#include &quot;internal/provider_ctx.h&quot;
+#include &quot;internal/providercommonerr.h&quot;
+#include &quot;internal/provider_algs.h&quot;
+#include &quot;e_os.h&quot;
 
 #define HKDF_MAXBUF 1024
 
-static void kdf_hkdf_reset(EVP_KDF_IMPL *impl);
+static OSSL_OP_kdf_newctx_fn kdf_hkdf_new;
+static OSSL_OP_kdf_freectx_fn kdf_hkdf_free;
+static OSSL_OP_kdf_reset_fn kdf_hkdf_reset;
+static OSSL_OP_kdf_derive_fn kdf_hkdf_derive;
+static OSSL_OP_kdf_settable_ctx_params_fn kdf_hkdf_settable_ctx_params;
+static OSSL_OP_kdf_set_ctx_params_fn kdf_hkdf_set_ctx_params;
+static OSSL_OP_kdf_gettable_ctx_params_fn kdf_hkdf_gettable_ctx_params;
+static OSSL_OP_kdf_get_ctx_params_fn kdf_hkdf_get_ctx_params;
+
 static int HKDF(const EVP_MD *evp_md,
                 const unsigned char *salt, size_t salt_len,
                 const unsigned char *key, size_t key_len,
@@ -35,209 +47,236 @@ static int HKDF_Expand(const EVP_MD *evp_md,
                        const unsigned char *info, size_t info_len,
                        unsigned char *okm, size_t okm_len);
 
-struct evp_kdf_impl_st {
+typedef struct {
+    void *provctx;
     int mode;
-    const EVP_MD *md;
+    EVP_MD *md;
     unsigned char *salt;
     size_t salt_len;
     unsigned char *key;
     size_t key_len;
     unsigned char info[HKDF_MAXBUF];
     size_t info_len;
-};
+} KDF_HKDF;
 
-static EVP_KDF_IMPL *kdf_hkdf_new(void)
+static void *kdf_hkdf_new(void *provctx)
 {
-    EVP_KDF_IMPL *impl;
+    KDF_HKDF *ctx;
 
-    if ((impl = OPENSSL_zalloc(sizeof(*impl))) == NULL)
-        KDFerr(KDF_F_KDF_HKDF_NEW, ERR_R_MALLOC_FAILURE);
-    return impl;
+    if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL)
+        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+    else
+        ctx-&gt;provctx = provctx;
+    return ctx;
 }
 
-static void kdf_hkdf_free(EVP_KDF_IMPL *impl)
+static void kdf_hkdf_free(void *vctx)
 {
-    kdf_hkdf_reset(impl);
-    OPENSSL_free(impl);
-}
+    KDF_HKDF *ctx = (KDF_HKDF *)vctx;
 
-static void kdf_hkdf_reset(EVP_KDF_IMPL *impl)
-{
-    OPENSSL_free(impl-&gt;salt);
-    OPENSSL_clear_free(impl-&gt;key, impl-&gt;key_len);
-    OPENSSL_cleanse(impl-&gt;info, impl-&gt;info_len);
-    memset(impl, 0, sizeof(*impl));
+    kdf_hkdf_reset(ctx);
+    OPENSSL_free(ctx);
 }
 
-static int kdf_hkdf_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
+static void kdf_hkdf_reset(void *vctx)
 {
-    const unsigned char *p;
-    size_t len;
-    const EVP_MD *md;
-
-    switch (cmd) {
-    case EVP_KDF_CTRL_SET_MD:
-        md = va_arg(args, const EVP_MD *);
-        if (md == NULL)
-            return 0;
-
-        impl-&gt;md = md;
-        return 1;
-
-    case EVP_KDF_CTRL_SET_HKDF_MODE:
-        impl-&gt;mode = va_arg(args, int);
-        return 1;
-
-    case EVP_KDF_CTRL_SET_SALT:
-        p = va_arg(args, const unsigned char *);
-        len = va_arg(args, size_t);
-        if (len == 0 || p == NULL)
-            return 1;
-
-        OPENSSL_free(impl-&gt;salt);
-        impl-&gt;salt = OPENSSL_memdup(p, len);
-        if (impl-&gt;salt == NULL)
-            return 0;
-
-        impl-&gt;salt_len = len;
-        return 1;
-
-    case EVP_KDF_CTRL_SET_KEY:
-        p = va_arg(args, const unsigned char *);
-        len = va_arg(args, size_t);
-        OPENSSL_clear_free(impl-&gt;key, impl-&gt;key_len);
-        impl-&gt;key = OPENSSL_memdup(p, len);
-        if (impl-&gt;key == NULL)
-            return 0;
-
-        impl-&gt;key_len  = len;
-        return 1;
-
-    case EVP_KDF_CTRL_RESET_HKDF_INFO:
-        OPENSSL_cleanse(impl-&gt;info, impl-&gt;info_len);
-        impl-&gt;info_len = 0;
-        return 1;
-
-    case EVP_KDF_CTRL_ADD_HKDF_INFO:
-        p = va_arg(args, const unsigned char *);
-        len = va_arg(args, size_t);
-        if (len == 0 || p == NULL)
-            return 1;
-
-        if (len &gt; (HKDF_MAXBUF - impl-&gt;info_len))
-            return 0;
+    KDF_HKDF *ctx = (KDF_HKDF *)vctx;
 
-        memcpy(impl-&gt;info + impl-&gt;info_len, p, len);
-        impl-&gt;info_len += len;
-        return 1;
-
-    default:
-        return -2;
-    }
+    EVP_MD_meth_free(ctx-&gt;md);
+    OPENSSL_free(ctx-&gt;salt);
+    OPENSSL_clear_free(ctx-&gt;key, ctx-&gt;key_len);
+    OPENSSL_cleanse(ctx-&gt;info, ctx-&gt;info_len);
+    memset(ctx, 0, sizeof(*ctx));
 }
 
-static int kdf_hkdf_ctrl_str(EVP_KDF_IMPL *impl, const char *type,
-                             const char *value)
-{
-    if (strcmp(type, &quot;mode&quot;) == 0) {
-        int mode;
-
-        if (strcmp(value, &quot;EXTRACT_AND_EXPAND&quot;) == 0)
-            mode = EVP_KDF_HKDF_MODE_EXTRACT_AND_EXPAND;
-        else if (strcmp(value, &quot;EXTRACT_ONLY&quot;) == 0)
-            mode = EVP_KDF_HKDF_MODE_EXTRACT_ONLY;
-        else if (strcmp(value, &quot;EXPAND_ONLY&quot;) == 0)
-            mode = EVP_KDF_HKDF_MODE_EXPAND_ONLY;
-        else
-            return 0;
-
-        return call_ctrl(kdf_hkdf_ctrl, impl, EVP_KDF_CTRL_SET_HKDF_MODE, mode);
-    }
-
-    if (strcmp(type, &quot;digest&quot;) == 0)
-        return kdf_md2ctrl(impl, kdf_hkdf_ctrl, EVP_KDF_CTRL_SET_MD, value);
-
-    if (strcmp(type, &quot;salt&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_hkdf_ctrl, EVP_KDF_CTRL_SET_SALT, value);
-
-    if (strcmp(type, &quot;hexsalt&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_hkdf_ctrl, EVP_KDF_CTRL_SET_SALT, value);
-
-    if (strcmp(type, &quot;key&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_hkdf_ctrl, EVP_KDF_CTRL_SET_KEY, value);
-
-    if (strcmp(type, &quot;hexkey&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_hkdf_ctrl, EVP_KDF_CTRL_SET_KEY, value);
-
-    if (strcmp(type, &quot;info&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_hkdf_ctrl, EVP_KDF_CTRL_ADD_HKDF_INFO,
-                            value);
-
-    if (strcmp(type, &quot;hexinfo&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_hkdf_ctrl, EVP_KDF_CTRL_ADD_HKDF_INFO,
-                            value);
-
-    return -2;
-}
-
-static size_t kdf_hkdf_size(EVP_KDF_IMPL *impl)
+static size_t kdf_hkdf_size(KDF_HKDF *ctx)
 {
     int sz;
 
-    if (impl-&gt;mode != EVP_KDF_HKDF_MODE_EXTRACT_ONLY)
+    if (ctx-&gt;mode != EVP_KDF_HKDF_MODE_EXTRACT_ONLY)
         return SIZE_MAX;
 
-    if (impl-&gt;md == NULL) {
-        KDFerr(KDF_F_KDF_HKDF_SIZE, KDF_R_MISSING_MESSAGE_DIGEST);
+    if (ctx-&gt;md == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
         return 0;
     }
-    sz = EVP_MD_size(impl-&gt;md);
+    sz = EVP_MD_size(ctx-&gt;md);
     if (sz &lt; 0)
         return 0;
 
     return sz;
 }
 
-static int kdf_hkdf_derive(EVP_KDF_IMPL *impl, unsigned char *key,
-                           size_t keylen)
+static int kdf_hkdf_derive(void *vctx, unsigned char *key, size_t keylen)
 {
-    if (impl-&gt;md == NULL) {
-        KDFerr(KDF_F_KDF_HKDF_DERIVE, KDF_R_MISSING_MESSAGE_DIGEST);
+    KDF_HKDF *ctx = (KDF_HKDF *)vctx;
+
+    if (ctx-&gt;md == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
         return 0;
     }
-    if (impl-&gt;key == NULL) {
-        KDFerr(KDF_F_KDF_HKDF_DERIVE, KDF_R_MISSING_KEY);
+    if (ctx-&gt;key == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_KEY);
         return 0;
     }
 
-    switch (impl-&gt;mode) {
+    switch (ctx-&gt;mode) {
     case EVP_KDF_HKDF_MODE_EXTRACT_AND_EXPAND:
-        return HKDF(impl-&gt;md, impl-&gt;salt, impl-&gt;salt_len, impl-&gt;key,
-                    impl-&gt;key_len, impl-&gt;info, impl-&gt;info_len, key,
+        return HKDF(ctx-&gt;md, ctx-&gt;salt, ctx-&gt;salt_len, ctx-&gt;key,
+                    ctx-&gt;key_len, ctx-&gt;info, ctx-&gt;info_len, key,
                     keylen);
 
     case EVP_KDF_HKDF_MODE_EXTRACT_ONLY:
-        return HKDF_Extract(impl-&gt;md, impl-&gt;salt, impl-&gt;salt_len, impl-&gt;key,
-                            impl-&gt;key_len, key, keylen);
+        return HKDF_Extract(ctx-&gt;md, ctx-&gt;salt, ctx-&gt;salt_len, ctx-&gt;key,
+                            ctx-&gt;key_len, key, keylen);
 
     case EVP_KDF_HKDF_MODE_EXPAND_ONLY:
-        return HKDF_Expand(impl-&gt;md, impl-&gt;key, impl-&gt;key_len, impl-&gt;info,
-                           impl-&gt;info_len, key, keylen);
+        return HKDF_Expand(ctx-&gt;md, ctx-&gt;key, ctx-&gt;key_len, ctx-&gt;info,
+                           ctx-&gt;info_len, key, keylen);
 
     default:
         return 0;
     }
 }
 
-const EVP_KDF hkdf_kdf_meth = {
-    EVP_KDF_HKDF,
-    kdf_hkdf_new,
-    kdf_hkdf_free,
-    kdf_hkdf_reset,
-    kdf_hkdf_ctrl,
-    kdf_hkdf_ctrl_str,
-    kdf_hkdf_size,
-    kdf_hkdf_derive
+static int kdf_hkdf_set_ctx_params(void *vctx, const OSSL_PARAM params[])
+{
+    const OSSL_PARAM *p;
+    KDF_HKDF *ctx = vctx;
+    EVP_MD *md;
+    int n;
+    const char *properties = NULL;
+
+    /* Grab search properties, this should be before the digest lookup */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PROPERTIES))
+        != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        properties = p-&gt;data;
+    }
+    /* Handle aliasing of digest parameter names */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_DIGEST)) != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        md = EVP_MD_fetch(PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx), p-&gt;data,
+                          properties);
+        if (md == NULL) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DIGEST);
+            return 0;
+        }
+        EVP_MD_meth_free(ctx-&gt;md);
+        ctx-&gt;md = md;
+    }
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_MODE)) != NULL) {
+        if (p-&gt;data_type == OSSL_PARAM_UTF8_STRING) {
+            if (strcasecmp(p-&gt;data, &quot;EXTRACT_AND_EXPAND&quot;) == 0) {
+                ctx-&gt;mode = EVP_KDF_HKDF_MODE_EXTRACT_AND_EXPAND;
+            } else if (strcasecmp(p-&gt;data, &quot;EXTRACT_ONLY&quot;) == 0) {
+                ctx-&gt;mode = EVP_KDF_HKDF_MODE_EXTRACT_ONLY;
+            } else if (strcasecmp(p-&gt;data, &quot;EXPAND_ONLY&quot;) == 0) {
+                ctx-&gt;mode = EVP_KDF_HKDF_MODE_EXPAND_ONLY;
+            } else {
+                ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_MODE);
+                return 0;
+            }
+        } else if (OSSL_PARAM_get_int(p, &amp;n)) {
+            if (n != EVP_KDF_HKDF_MODE_EXTRACT_AND_EXPAND
+                &amp;&amp; n != EVP_KDF_HKDF_MODE_EXTRACT_ONLY
+                &amp;&amp; n != EVP_KDF_HKDF_MODE_EXPAND_ONLY) {
+                ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_MODE);
+                return 0;
+            }
+            ctx-&gt;mode = n;
+        } else {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_MODE);
+            return 0;
+        }
+    }
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_KEY)) != NULL) {
+        OPENSSL_clear_free(ctx-&gt;key, ctx-&gt;key_len);
+        ctx-&gt;key = NULL;
+        if (!OSSL_PARAM_get_octet_string(p, (void **)&amp;ctx-&gt;key, 0,
+                                         &amp;ctx-&gt;key_len))
+            return 0;
+    }
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SALT)) != NULL) {
+        if (p-&gt;data_size != 0 &amp;&amp; p-&gt;data != NULL) {
+            OPENSSL_free(ctx-&gt;salt);
+            ctx-&gt;salt = NULL;
+            if (!OSSL_PARAM_get_octet_string(p, (void **)&amp;ctx-&gt;salt, 0,
+                                             &amp;ctx-&gt;salt_len))
+                return 0;
+        }
+    }
+    /* The info fields concatenate, so process them all */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_INFO)) != NULL) {
+        ctx-&gt;info_len = 0;
+        for (; p != NULL; p = OSSL_PARAM_locate_const(p + 1,
+                                                      OSSL_KDF_PARAM_INFO)) {
+            const void *q = ctx-&gt;info + ctx-&gt;info_len;
+            size_t sz = 0;
+
+            if (p-&gt;data_size != 0
+                &amp;&amp; p-&gt;data != NULL
+                &amp;&amp; !OSSL_PARAM_get_octet_string(p, (void **)&amp;q,
+                                                HKDF_MAXBUF - ctx-&gt;info_len,
+                                                &amp;sz))
+                return 0;
+            ctx-&gt;info_len += sz;
+        }
+    }
+    return 1;
+}
+
+static const OSSL_PARAM *kdf_hkdf_settable_ctx_params(void)
+{
+    static const OSSL_PARAM known_settable_ctx_params[] = {
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_MODE, NULL, 0),
+        OSSL_PARAM_int(OSSL_KDF_PARAM_MODE, NULL),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_PROPERTIES, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_DIGEST, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_SALT, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_KEY, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_INFO, NULL, 0),
+        OSSL_PARAM_END
+    };
+    return known_settable_ctx_params;
+}
+
+static int kdf_hkdf_get_ctx_params(void *vctx, OSSL_PARAM params[])
+{
+    KDF_HKDF *ctx = (KDF_HKDF *)vctx;
+    OSSL_PARAM *p;
+
+    if ((p = OSSL_PARAM_locate(params, OSSL_KDF_PARAM_SIZE)) != NULL)
+        return OSSL_PARAM_set_size_t(p, kdf_hkdf_size(ctx));
+    return -2;
+}
+
+static const OSSL_PARAM *kdf_hkdf_gettable_ctx_params(void)
+{
+    static const OSSL_PARAM known_gettable_ctx_params[] = {
+        OSSL_PARAM_size_t(OSSL_KDF_PARAM_SIZE, NULL),
+        OSSL_PARAM_END
+    };
+    return known_gettable_ctx_params;
+}
+
+const OSSL_DISPATCH kdf_hkdf_functions[] = {
+    { OSSL_FUNC_KDF_NEWCTX, (void(*)(void))kdf_hkdf_new },
+    { OSSL_FUNC_KDF_FREECTX, (void(*)(void))kdf_hkdf_free },
+    { OSSL_FUNC_KDF_RESET, (void(*)(void))kdf_hkdf_reset },
+    { OSSL_FUNC_KDF_DERIVE, (void(*)(void))kdf_hkdf_derive },
+    { OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS,
+      (void(*)(void))kdf_hkdf_settable_ctx_params },
+    { OSSL_FUNC_KDF_SET_CTX_PARAMS, (void(*)(void))kdf_hkdf_set_ctx_params },
+    { OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS,
+      (void(*)(void))kdf_hkdf_gettable_ctx_params },
+    { OSSL_FUNC_KDF_GET_CTX_PARAMS, (void(*)(void))kdf_hkdf_get_ctx_params },
+    { 0, NULL }
 };
 
 /*
@@ -325,7 +364,7 @@ static int HKDF_Extract(const EVP_MD *evp_md,
     if (sz &lt; 0)
         return 0;
     if (prk_len != (size_t)sz) {
-        KDFerr(KDF_F_HKDF_EXTRACT, KDF_R_WRONG_OUTPUT_BUFFER_SIZE);
+        ERR_raise(ERR_LIB_PROV, PROV_R_WRONG_OUTPUT_BUFFER_SIZE);
         return 0;
     }
     /* calc: PRK = HMAC-Hash(salt, IKM) */
diff --git a/providers/common/kdfs/pbkdf2.c b/providers/common/kdfs/pbkdf2.c
new file mode 100644
index 0000000000..e60f0126f7
--- /dev/null
+++ b/providers/common/kdfs/pbkdf2.c
@@ -0,0 +1,355 @@
+/*
+ * Copyright 2018-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;string.h&gt;
+#include &lt;openssl/hmac.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/kdf.h&gt;
+#include &lt;openssl/core_names.h&gt;
+#include &quot;internal/cryptlib.h&quot;
+#include &quot;internal/numbers.h&quot;
+#include &quot;internal/evp_int.h&quot;
+#include &quot;internal/provider_ctx.h&quot;
+#include &quot;internal/providercommonerr.h&quot;
+#include &quot;internal/provider_algs.h&quot;
+
+/* Constants specified in SP800-132 */
+#define KDF_PBKDF2_MIN_KEY_LEN_BITS  112
+#define KDF_PBKDF2_MAX_KEY_LEN_DIGEST_RATIO 0xFFFFFFFF
+#define KDF_PBKDF2_MIN_ITERATIONS 1000
+#define KDF_PBKDF2_MIN_SALT_LEN   (128 / 8)
+/*
+ * For backwards compatibility reasons,
+ * Extra checks are done by default in fips mode only.
+ */
+#ifdef FIPS_MODE
+# define KDF_PBKDF2_DEFAULT_CHECKS 1
+#else
+# define KDF_PBKDF2_DEFAULT_CHECKS 0
+#endif /* FIPS_MODE */
+
+static OSSL_OP_kdf_newctx_fn kdf_pbkdf2_new;
+static OSSL_OP_kdf_freectx_fn kdf_pbkdf2_free;
+static OSSL_OP_kdf_reset_fn kdf_pbkdf2_reset;
+static OSSL_OP_kdf_derive_fn kdf_pbkdf2_derive;
+static OSSL_OP_kdf_settable_ctx_params_fn kdf_pbkdf2_settable_ctx_params;
+static OSSL_OP_kdf_set_ctx_params_fn kdf_pbkdf2_set_ctx_params;
+
+static int  pbkdf2_derive(const char *pass, size_t passlen,
+                          const unsigned char *salt, int saltlen, uint64_t iter,
+                          const EVP_MD *digest, unsigned char *key,
+                          size_t keylen, int extra_checks);
+
+typedef struct {
+    void *provctx;
+    unsigned char *pass;
+    size_t pass_len;
+    unsigned char *salt;
+    size_t salt_len;
+    uint64_t iter;
+    EVP_MD *md;
+    int lower_bound_checks;
+} KDF_PBKDF2;
+
+static void kdf_pbkdf2_init(KDF_PBKDF2 *ctx);
+
+static void *kdf_pbkdf2_new(void *provctx)
+{
+    KDF_PBKDF2 *ctx;
+
+    ctx = OPENSSL_zalloc(sizeof(*ctx));
+    if (ctx == NULL) {
+        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+    ctx-&gt;provctx = provctx;
+    kdf_pbkdf2_init(ctx);
+    return ctx;
+}
+
+static void kdf_pbkdf2_cleanup(KDF_PBKDF2 *ctx)
+{
+    EVP_MD_meth_free(ctx-&gt;md);
+    OPENSSL_free(ctx-&gt;salt);
+    OPENSSL_clear_free(ctx-&gt;pass, ctx-&gt;pass_len);
+    memset(ctx, 0, sizeof(*ctx));
+}
+
+static void kdf_pbkdf2_free(void *vctx)
+{
+    KDF_PBKDF2 *ctx = (KDF_PBKDF2 *)vctx;
+
+    kdf_pbkdf2_cleanup(ctx);
+    OPENSSL_free(ctx);
+}
+
+static void kdf_pbkdf2_reset(void *vctx)
+{
+    KDF_PBKDF2 *ctx = (KDF_PBKDF2 *)vctx;
+
+    kdf_pbkdf2_cleanup(ctx);
+    kdf_pbkdf2_init(ctx);
+}
+
+static void kdf_pbkdf2_init(KDF_PBKDF2 *ctx)
+{
+    ctx-&gt;iter = PKCS5_DEFAULT_ITER;
+    ctx-&gt;md = EVP_MD_fetch(PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx), SN_sha1,
+                           NULL);
+    ctx-&gt;lower_bound_checks = KDF_PBKDF2_DEFAULT_CHECKS;
+}
+
+static int pbkdf2_set_membuf(unsigned char **buffer, size_t *buflen,
+                             const OSSL_PARAM *p)
+{
+    OPENSSL_clear_free(*buffer, *buflen);
+    if (p-&gt;data_size == 0) {
+        if ((*buffer = OPENSSL_malloc(1)) == NULL) {
+            ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+    } else if (p-&gt;data != NULL) {
+        *buffer = NULL;
+        if (!OSSL_PARAM_get_octet_string(p, (void **)buffer, 0, buflen))
+            return 0;
+    }
+    return 1;
+}
+
+static int kdf_pbkdf2_derive(void *vctx, unsigned char *key,
+                             size_t keylen)
+{
+    KDF_PBKDF2 *ctx = (KDF_PBKDF2 *)vctx;
+
+    if (ctx-&gt;pass == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_PASS);
+        return 0;
+    }
+
+    if (ctx-&gt;salt == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_SALT);
+        return 0;
+    }
+
+    return pbkdf2_derive((char *)ctx-&gt;pass, ctx-&gt;pass_len,
+                         ctx-&gt;salt, ctx-&gt;salt_len, ctx-&gt;iter,
+                         ctx-&gt;md, key, keylen, ctx-&gt;lower_bound_checks);
+}
+
+static int kdf_pbkdf2_set_ctx_params(void *vctx, const OSSL_PARAM params[])
+{
+    const OSSL_PARAM *p;
+    KDF_PBKDF2 *ctx = vctx;
+    EVP_MD *md;
+    int pkcs5;
+    uint64_t iter, min_iter;
+    const char *properties = NULL;
+
+    /* Grab search properties, this should be before the digest lookup */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PROPERTIES))
+        != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        properties = p-&gt;data;
+    }
+    /* Handle aliasing of digest parameter names */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_DIGEST)) != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        md = EVP_MD_fetch(PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx), p-&gt;data,
+                          properties);
+        if (md == NULL) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DIGEST);
+            return 0;
+        }
+        EVP_MD_meth_free(ctx-&gt;md);
+        ctx-&gt;md = md;
+    }
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PKCS5)) != NULL) {
+        if (!OSSL_PARAM_get_int(p, &amp;pkcs5))
+            return 0;
+        ctx-&gt;lower_bound_checks = pkcs5 == 0;
+    }
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PASSWORD)) != NULL)
+        if (!pbkdf2_set_membuf(&amp;ctx-&gt;pass, &amp;ctx-&gt;pass_len, p))
+            return 0;
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SALT)) != NULL) {
+        if (ctx-&gt;lower_bound_checks != 0
+            &amp;&amp; p-&gt;data_size &lt; KDF_PBKDF2_MIN_SALT_LEN) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_SALT_LENGTH);
+            return 0;
+        }
+        if (!pbkdf2_set_membuf(&amp;ctx-&gt;salt, &amp;ctx-&gt;salt_len,p))
+            return 0;
+    }
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_ITER)) != NULL) {
+        if (!OSSL_PARAM_get_uint64(p, &amp;iter))
+            return 0;
+        min_iter = ctx-&gt;lower_bound_checks != 0 ? KDF_PBKDF2_MIN_ITERATIONS : 1;
+        if (iter &lt; min_iter) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_ITERATION_COUNT);
+            return 0;
+        }
+        ctx-&gt;iter = iter;
+    }
+    return 1;
+}
+
+static const OSSL_PARAM *kdf_pbkdf2_settable_ctx_params(void)
+{
+    static const OSSL_PARAM known_settable_ctx_params[] = {
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_PROPERTIES, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_DIGEST, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_PASSWORD, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_SALT, NULL, 0),
+        OSSL_PARAM_uint64(OSSL_KDF_PARAM_ITER, NULL),
+        OSSL_PARAM_int(OSSL_KDF_PARAM_PKCS5, NULL),
+        OSSL_PARAM_END
+    };
+    return known_settable_ctx_params;
+}
+
+static int kdf_pbkdf2_get_ctx_params(void *vctx, OSSL_PARAM params[])
+{
+    OSSL_PARAM *p;
+
+    if ((p = OSSL_PARAM_locate(params, OSSL_KDF_PARAM_SIZE)) != NULL)
+        return OSSL_PARAM_set_size_t(p, SIZE_MAX);
+    return -2;
+}
+
+static const OSSL_PARAM *kdf_pbkdf2_gettable_ctx_params(void)
+{
+    static const OSSL_PARAM known_gettable_ctx_params[] = {
+        OSSL_PARAM_size_t(OSSL_KDF_PARAM_SIZE, NULL),
+        OSSL_PARAM_END
+    };
+    return known_gettable_ctx_params;
+}
+
+const OSSL_DISPATCH kdf_pbkdf2_functions[] = {
+    { OSSL_FUNC_KDF_NEWCTX, (void(*)(void))kdf_pbkdf2_new },
+    { OSSL_FUNC_KDF_FREECTX, (void(*)(void))kdf_pbkdf2_free },
+    { OSSL_FUNC_KDF_RESET, (void(*)(void))kdf_pbkdf2_reset },
+    { OSSL_FUNC_KDF_DERIVE, (void(*)(void))kdf_pbkdf2_derive },
+    { OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS,
+      (void(*)(void))kdf_pbkdf2_settable_ctx_params },
+    { OSSL_FUNC_KDF_SET_CTX_PARAMS, (void(*)(void))kdf_pbkdf2_set_ctx_params },
+    { OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS,
+      (void(*)(void))kdf_pbkdf2_gettable_ctx_params },
+    { OSSL_FUNC_KDF_GET_CTX_PARAMS, (void(*)(void))kdf_pbkdf2_get_ctx_params },
+    { 0, NULL }
+};
+
+/*
+ * This is an implementation of PKCS#5 v2.0 password based encryption key
+ * derivation function PBKDF2. SHA1 version verified against test vectors
+ * posted by Peter Gutmann to the PKCS-TNG mailing list.
+ *
+ * The constraints specified by SP800-132 have been added i.e.
+ *  - Check the range of the key length.
+ *  - Minimum iteration count of 1000.
+ *  - Randomly-generated portion of the salt shall be at least 128 bits.
+ */
+static int pbkdf2_derive(const char *pass, size_t passlen,
+                         const unsigned char *salt, int saltlen, uint64_t iter,
+                         const EVP_MD *digest, unsigned char *key,
+                         size_t keylen, int lower_bound_checks)
+{
+    int ret = 0;
+    unsigned char digtmp[EVP_MAX_MD_SIZE], *p, itmp[4];
+    int cplen, k, tkeylen, mdlen;
+    uint64_t j;
+    unsigned long i = 1;
+    HMAC_CTX *hctx_tpl = NULL, *hctx = NULL;
+
+    mdlen = EVP_MD_size(digest);
+    if (mdlen &lt;= 0)
+        return 0;
+
+    /*
+     * This check should always be done because keylen / mdlen &gt;= (2^32 - 1)
+     * results in an overflow of the loop counter 'i'.
+     */
+    if ((keylen / mdlen) &gt;= KDF_PBKDF2_MAX_KEY_LEN_DIGEST_RATIO) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_KEY_LEN);
+        return 0;
+    }
+
+    if (lower_bound_checks) {
+        if ((keylen * 8) &lt; KDF_PBKDF2_MIN_KEY_LEN_BITS) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_KEY_LEN);
+            return 0;
+        }
+        if (saltlen &lt; KDF_PBKDF2_MIN_SALT_LEN) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_SALT_LENGTH);
+            return 0;
+        }
+        if (iter &lt; KDF_PBKDF2_MIN_ITERATIONS) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_ITERATION_COUNT);
+            return 0;
+        }
+    }
+
+    hctx_tpl = HMAC_CTX_new();
+    if (hctx_tpl == NULL)
+        return 0;
+    p = key;
+    tkeylen = keylen;
+    if (!HMAC_Init_ex(hctx_tpl, pass, passlen, digest, NULL))
+        goto err;
+    hctx = HMAC_CTX_new();
+    if (hctx == NULL)
+        goto err;
+    while (tkeylen) {
+        if (tkeylen &gt; mdlen)
+            cplen = mdlen;
+        else
+            cplen = tkeylen;
+        /*
+         * We are unlikely to ever use more than 256 blocks (5120 bits!) but
+         * just in case...
+         */
+        itmp[0] = (unsigned char)((i &gt;&gt; 24) &amp; 0xff);
+        itmp[1] = (unsigned char)((i &gt;&gt; 16) &amp; 0xff);
+        itmp[2] = (unsigned char)((i &gt;&gt; 8) &amp; 0xff);
+        itmp[3] = (unsigned char)(i &amp; 0xff);
+        if (!HMAC_CTX_copy(hctx, hctx_tpl))
+            goto err;
+        if (!HMAC_Update(hctx, salt, saltlen)
+                || !HMAC_Update(hctx, itmp, 4)
+                || !HMAC_Final(hctx, digtmp, NULL))
+            goto err;
+        memcpy(p, digtmp, cplen);
+        for (j = 1; j &lt; iter; j++) {
+            if (!HMAC_CTX_copy(hctx, hctx_tpl))
+                goto err;
+            if (!HMAC_Update(hctx, digtmp, mdlen)
+                    || !HMAC_Final(hctx, digtmp, NULL))
+                goto err;
+            for (k = 0; k &lt; cplen; k++)
+                p[k] ^= digtmp[k];
+        }
+        tkeylen -= cplen;
+        i++;
+        p += cplen;
+    }
+    ret = 1;
+
+err:
+    HMAC_CTX_free(hctx);
+    HMAC_CTX_free(hctx_tpl);
+    return ret;
+}
diff --git a/crypto/kdf/sskdf.c b/providers/common/kdfs/sskdf.c
similarity index 58%
rename from crypto/kdf/sskdf.c
rename to providers/common/kdfs/sskdf.c
index b20eff2865..b8a41fbbaa 100644
--- a/crypto/kdf/sskdf.c
+++ b/providers/common/kdfs/sskdf.c
@@ -43,12 +43,16 @@
 #include &lt;openssl/core_names.h&gt;
 #include &lt;openssl/params.h&gt;
 #include &quot;internal/cryptlib.h&quot;
+#include &quot;internal/numbers.h&quot;
 #include &quot;internal/evp_int.h&quot;
-#include &quot;kdf_local.h&quot;
+#include &quot;internal/provider_ctx.h&quot;
+#include &quot;internal/providercommonerr.h&quot;
+#include &quot;internal/provider_algs.h&quot;
 
-struct evp_kdf_impl_st {
+typedef struct {
+    void *provctx;
     EVP_MAC *mac;       /* H(x) = HMAC_hash OR H(x) = KMAC */
-    const EVP_MD *md;   /* H(x) = hash OR when H(x) = HMAC_hash */
+    EVP_MD *md;         /* H(x) = hash OR when H(x) = HMAC_hash */
     unsigned char *secret;
     size_t secret_len;
     unsigned char *info;
@@ -56,7 +60,7 @@ struct evp_kdf_impl_st {
     unsigned char *salt;
     size_t salt_len;
     size_t out_len; /* optional KMAC parameter */
-};
+} KDF_SSKDF;
 
 #define SSKDF_MAX_INLEN (1&lt;&lt;30)
 #define SSKDF_KMAC128_DEFAULT_SALT_SIZE (168 - 4)
@@ -65,6 +69,16 @@ struct evp_kdf_impl_st {
 /* KMAC uses a Customisation string of 'KDF' */
 static const unsigned char kmac_custom_str[] = { 0x4B, 0x44, 0x46 };
 
+static OSSL_OP_kdf_newctx_fn sskdf_new;
+static OSSL_OP_kdf_freectx_fn sskdf_free;
+static OSSL_OP_kdf_reset_fn sskdf_reset;
+static OSSL_OP_kdf_derive_fn sskdf_derive;
+static OSSL_OP_kdf_derive_fn x963kdf_derive;
+static OSSL_OP_kdf_settable_ctx_params_fn sskdf_settable_ctx_params;
+static OSSL_OP_kdf_set_ctx_params_fn sskdf_set_ctx_params;
+static OSSL_OP_kdf_gettable_ctx_params_fn sskdf_gettable_ctx_params;
+static OSSL_OP_kdf_get_ctx_params_fn sskdf_get_ctx_params;
+
 /*
  * Refer to <A HREF="https://csrc.nist.gov/publications/detail/sp/800-56c/rev-1/final">https://csrc.nist.gov/publications/detail/sp/800-56c/rev-1/final</A>
  * Section 4. One-Step Key Derivation using H(x) = hash(x)
@@ -287,172 +301,68 @@ end:
     return ret;
 }
 
-static EVP_KDF_IMPL *sskdf_new(void)
+static void *sskdf_new(void *provctx)
 {
-    EVP_KDF_IMPL *impl;
-
-    if ((impl = OPENSSL_zalloc(sizeof(*impl))) == NULL)
-        KDFerr(KDF_F_SSKDF_NEW, ERR_R_MALLOC_FAILURE);
-    return impl;
-}
+    KDF_SSKDF *ctx;
 
-static void sskdf_reset(EVP_KDF_IMPL *impl)
-{
-    OPENSSL_clear_free(impl-&gt;secret, impl-&gt;secret_len);
-    OPENSSL_clear_free(impl-&gt;info, impl-&gt;info_len);
-    OPENSSL_clear_free(impl-&gt;salt, impl-&gt;salt_len);
-    EVP_MAC_free(impl-&gt;mac);
-#if 0                    /* TODO(3.0) When we switch to fetched MDs */
-    EVP_MD_meth_free(impl-&gt;md);
-#endif
-    memset(impl, 0, sizeof(*impl));
+    if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL)
+        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+    ctx-&gt;provctx = provctx;
+    return ctx;
 }
 
-static void sskdf_free(EVP_KDF_IMPL *impl)
+static void sskdf_reset(void *vctx)
 {
-    sskdf_reset(impl);
-    OPENSSL_free(impl);
+    KDF_SSKDF *ctx = (KDF_SSKDF *)vctx;
+
+    EVP_MD_meth_free(ctx-&gt;md);
+    EVP_MAC_free(ctx-&gt;mac);
+    OPENSSL_clear_free(ctx-&gt;secret, ctx-&gt;secret_len);
+    OPENSSL_clear_free(ctx-&gt;info, ctx-&gt;info_len);
+    OPENSSL_clear_free(ctx-&gt;salt, ctx-&gt;salt_len);
+    memset(ctx, 0, sizeof(*ctx));
 }
 
-static int sskdf_set_buffer(va_list args, unsigned char **out, size_t *out_len)
+static void sskdf_free(void *vctx)
 {
-    const unsigned char *p;
-    size_t len;
+    KDF_SSKDF *ctx = (KDF_SSKDF *)vctx;
 
-    p = va_arg(args, const unsigned char *);
-    len = va_arg(args, size_t);
-    if (len == 0 || p == NULL)
-        return 1;
-
-    OPENSSL_free(*out);
-    *out = OPENSSL_memdup(p, len);
-    if (*out == NULL)
-        return 0;
-
-    *out_len = len;
-    return 1;
+    sskdf_reset(ctx);
+    OPENSSL_free(ctx);
 }
 
-static int sskdf_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
+static int sskdf_set_buffer(unsigned char **out, size_t *out_len,
+                            const OSSL_PARAM *p)
 {
-    const EVP_MD *md;
-
-    switch (cmd) {
-    case EVP_KDF_CTRL_SET_KEY:
-        return sskdf_set_buffer(args, &amp;impl-&gt;secret, &amp;impl-&gt;secret_len);
-
-    case EVP_KDF_CTRL_SET_SSKDF_INFO:
-        return sskdf_set_buffer(args, &amp;impl-&gt;info, &amp;impl-&gt;info_len);
-
-    case EVP_KDF_CTRL_SET_MD:
-        md = va_arg(args, const EVP_MD *);
-        if (md == NULL)
-            return 0;
-
-#if 0                    /* TODO(3.0) When we switch to fetched MDs */
-        EVP_MD_meth_free(impl-&gt;md);
-#endif
-        impl-&gt;md = md;
+    if (p-&gt;data == NULL || p-&gt;data_size == 0)
         return 1;
-
-    case EVP_KDF_CTRL_SET_MAC:
-        {
-            const char *name;
-            EVP_MAC *mac;
-
-            name = va_arg(args, const char *);
-            if (name == NULL)
-                return 0;
-
-            EVP_MAC_free(impl-&gt;mac);
-            impl-&gt;mac = NULL;
-
-            /*
-             * TODO(3.0) add support for OPENSSL_CTX and properties in KDFs
-             */
-            mac = EVP_MAC_fetch(NULL, name, NULL);
-            if (mac == NULL)
-                return 0;
-
-            impl-&gt;mac = mac;
-            return 1;
-        }
-    case EVP_KDF_CTRL_SET_SALT:
-        return sskdf_set_buffer(args, &amp;impl-&gt;salt, &amp;impl-&gt;salt_len);
-
-    case EVP_KDF_CTRL_SET_MAC_SIZE:
-        impl-&gt;out_len = va_arg(args, size_t);
-        return 1;
-
-    default:
-        return -2;
-    }
-}
-
-static int sskdf_ctrl_str(EVP_KDF_IMPL *impl, const char *type,
-                          const char *value)
-{
-    if (strcmp(type, &quot;secret&quot;) == 0 || strcmp(type, &quot;key&quot;) == 0)
-         return kdf_str2ctrl(impl, sskdf_ctrl, EVP_KDF_CTRL_SET_KEY,
-                             value);
-
-    if (strcmp(type, &quot;hexsecret&quot;) == 0 || strcmp(type, &quot;hexkey&quot;) == 0)
-        return kdf_hex2ctrl(impl, sskdf_ctrl, EVP_KDF_CTRL_SET_KEY,
-                            value);
-
-    if (strcmp(type, &quot;info&quot;) == 0)
-        return kdf_str2ctrl(impl, sskdf_ctrl, EVP_KDF_CTRL_SET_SSKDF_INFO,
-                            value);
-
-    if (strcmp(type, &quot;hexinfo&quot;) == 0)
-        return kdf_hex2ctrl(impl, sskdf_ctrl, EVP_KDF_CTRL_SET_SSKDF_INFO,
-                            value);
-
-    if (strcmp(type, &quot;digest&quot;) == 0)
-        return kdf_md2ctrl(impl, sskdf_ctrl, EVP_KDF_CTRL_SET_MD, value);
-
-    if (strcmp(type, &quot;mac&quot;) == 0)
-        return kdf_str2ctrl(impl, sskdf_ctrl, EVP_KDF_CTRL_SET_MAC, value);
-
-    if (strcmp(type, &quot;salt&quot;) == 0)
-        return kdf_str2ctrl(impl, sskdf_ctrl, EVP_KDF_CTRL_SET_SALT, value);
-
-    if (strcmp(type, &quot;hexsalt&quot;) == 0)
-        return kdf_hex2ctrl(impl, sskdf_ctrl, EVP_KDF_CTRL_SET_SALT, value);
-
-
-    if (strcmp(type, &quot;maclen&quot;) == 0) {
-        int val = atoi(value);
-        if (val &lt; 0) {
-            KDFerr(KDF_F_SSKDF_CTRL_STR, KDF_R_VALUE_ERROR);
-            return 0;
-        }
-        return call_ctrl(sskdf_ctrl, impl, EVP_KDF_CTRL_SET_MAC_SIZE,
-                         (size_t)val);
-    }
-    return -2;
+    OPENSSL_free(*out);
+    *out = NULL;
+    return OSSL_PARAM_get_octet_string(p, (void **)out, 0, out_len);
 }
 
-static size_t sskdf_size(EVP_KDF_IMPL *impl)
+static size_t sskdf_size(KDF_SSKDF *ctx)
 {
     int len;
 
-    if (impl-&gt;md == NULL) {
-        KDFerr(KDF_F_SSKDF_SIZE, KDF_R_MISSING_MESSAGE_DIGEST);
+    if (ctx-&gt;md == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
         return 0;
     }
-    len = EVP_MD_size(impl-&gt;md);
+    len = EVP_MD_size(ctx-&gt;md);
     return (len &lt;= 0) ? 0 : (size_t)len;
 }
 
-static int sskdf_derive(EVP_KDF_IMPL *impl, unsigned char *key, size_t keylen)
+static int sskdf_derive(void *vctx, unsigned char *key, size_t keylen)
 {
-    if (impl-&gt;secret == NULL) {
-        KDFerr(KDF_F_SSKDF_DERIVE, KDF_R_MISSING_SECRET);
+    KDF_SSKDF *ctx = (KDF_SSKDF *)vctx;
+
+    if (ctx-&gt;secret == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_SECRET);
         return 0;
     }
 
-    if (impl-&gt;mac != NULL) {
+    if (ctx-&gt;mac != NULL) {
         /* H(x) = KMAC or H(x) = HMAC */
         int ret;
         const unsigned char *custom = NULL;
@@ -465,14 +375,14 @@ static int sskdf_derive(EVP_KDF_IMPL *impl, unsigned char *key, size_t keylen)
          * Why does KMAC require a salt length that's shorter than the MD
          * block size?
          */
-        macname = EVP_MAC_name(impl-&gt;mac);
+        macname = EVP_MAC_name(ctx-&gt;mac);
         if (strcmp(macname, OSSL_MAC_NAME_HMAC) == 0) {
             /* H(x) = HMAC(x, salt, hash) */
-            if (impl-&gt;md == NULL) {
-                KDFerr(KDF_F_SSKDF_DERIVE, KDF_R_MISSING_MESSAGE_DIGEST);
+            if (ctx-&gt;md == NULL) {
+                ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
                 return 0;
             }
-            default_salt_len = EVP_MD_block_size(impl-&gt;md);
+            default_salt_len = EVP_MD_block_size(ctx-&gt;md);
             if (default_salt_len &lt;= 0)
                 return 0;
         } else if (strcmp(macname, OSSL_MAC_NAME_KMAC128) == 0
@@ -485,74 +395,181 @@ static int sskdf_derive(EVP_KDF_IMPL *impl, unsigned char *key, size_t keylen)
             else
                 default_salt_len = SSKDF_KMAC256_DEFAULT_SALT_SIZE;
         } else {
-            KDFerr(KDF_F_SSKDF_DERIVE, KDF_R_UNSUPPORTED_MAC_TYPE);
+            ERR_raise(ERR_LIB_PROV, PROV_R_UNSUPPORTED_MAC_TYPE);
             return 0;
         }
         /* If no salt is set then use a default_salt of zeros */
-        if (impl-&gt;salt == NULL || impl-&gt;salt_len &lt;= 0) {
-            impl-&gt;salt = OPENSSL_zalloc(default_salt_len);
-            if (impl-&gt;salt == NULL) {
-                KDFerr(KDF_F_SSKDF_DERIVE, ERR_R_MALLOC_FAILURE);
+        if (ctx-&gt;salt == NULL || ctx-&gt;salt_len &lt;= 0) {
+            ctx-&gt;salt = OPENSSL_zalloc(default_salt_len);
+            if (ctx-&gt;salt == NULL) {
+                ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
                 return 0;
             }
-            impl-&gt;salt_len = default_salt_len;
+            ctx-&gt;salt_len = default_salt_len;
         }
-        ret = SSKDF_mac_kdm(impl-&gt;mac, impl-&gt;md,
-                            custom, custom_len, impl-&gt;out_len,
-                            impl-&gt;salt, impl-&gt;salt_len,
-                            impl-&gt;secret, impl-&gt;secret_len,
-                            impl-&gt;info, impl-&gt;info_len, key, keylen);
+        ret = SSKDF_mac_kdm(ctx-&gt;mac, ctx-&gt;md,
+                            custom, custom_len, ctx-&gt;out_len,
+                            ctx-&gt;salt, ctx-&gt;salt_len,
+                            ctx-&gt;secret, ctx-&gt;secret_len,
+                            ctx-&gt;info, ctx-&gt;info_len, key, keylen);
         return ret;
     } else {
         /* H(x) = hash */
-        if (impl-&gt;md == NULL) {
-            KDFerr(KDF_F_SSKDF_DERIVE, KDF_R_MISSING_MESSAGE_DIGEST);
+        if (ctx-&gt;md == NULL) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
             return 0;
         }
-        return SSKDF_hash_kdm(impl-&gt;md, impl-&gt;secret, impl-&gt;secret_len,
-                              impl-&gt;info, impl-&gt;info_len, 0, key, keylen);
+        return SSKDF_hash_kdm(ctx-&gt;md, ctx-&gt;secret, ctx-&gt;secret_len,
+                              ctx-&gt;info, ctx-&gt;info_len, 0, key, keylen);
     }
 }
 
-static int x963kdf_derive(EVP_KDF_IMPL *impl, unsigned char *key, size_t keylen)
+static int x963kdf_derive(void *vctx, unsigned char *key, size_t keylen)
 {
-    if (impl-&gt;secret == NULL) {
-        KDFerr(KDF_F_X963KDF_DERIVE, KDF_R_MISSING_SECRET);
+    KDF_SSKDF *ctx = (KDF_SSKDF *)vctx;
+
+    if (ctx-&gt;secret == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_SECRET);
         return 0;
     }
 
-    if (impl-&gt;mac != NULL) {
-        KDFerr(KDF_F_X963KDF_DERIVE, KDF_R_NOT_SUPPORTED);
+    if (ctx-&gt;mac != NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_NOT_SUPPORTED);
         return 0;
     } else {
         /* H(x) = hash */
-        if (impl-&gt;md == NULL) {
-            KDFerr(KDF_F_X963KDF_DERIVE, KDF_R_MISSING_MESSAGE_DIGEST);
+        if (ctx-&gt;md == NULL) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
+            return 0;
+        }
+        return SSKDF_hash_kdm(ctx-&gt;md, ctx-&gt;secret, ctx-&gt;secret_len,
+                              ctx-&gt;info, ctx-&gt;info_len, 1, key, keylen);
+    }
+}
+
+static int sskdf_set_ctx_params(void *vctx, const OSSL_PARAM params[])
+{
+    const OSSL_PARAM *p;
+    KDF_SSKDF *ctx = vctx;
+    EVP_MD *md;
+    EVP_MAC *mac;
+    size_t sz;
+    const char *properties = NULL;
+
+    /* Grab search properties, should be before the digest and mac lookups */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PROPERTIES))
+        != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        properties = p-&gt;data;
+    }
+    /* Handle aliasing of digest parameter names */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_DIGEST)) != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        md = EVP_MD_fetch(PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx), p-&gt;data,
+                          properties);
+        if (md == NULL) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DIGEST);
             return 0;
         }
-        return SSKDF_hash_kdm(impl-&gt;md, impl-&gt;secret, impl-&gt;secret_len,
-                              impl-&gt;info, impl-&gt;info_len, 1, key, keylen);
+        EVP_MD_meth_free(ctx-&gt;md);
+        ctx-&gt;md = md;
+    }
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_MAC)) != NULL) {
+        EVP_MAC_free(ctx-&gt;mac);
+        ctx-&gt;mac = NULL;
+
+        mac = EVP_MAC_fetch(PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx), p-&gt;data,
+                            properties);
+        if (mac == NULL)
+            return 0;
+        EVP_MAC_free(ctx-&gt;mac);
+        ctx-&gt;mac = mac;
+    }
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SECRET)) != NULL
+        || (p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_KEY)) != NULL)
+        if (!sskdf_set_buffer(&amp;ctx-&gt;secret, &amp;ctx-&gt;secret_len, p))
+            return 0;
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_INFO)) != NULL)
+        if (!sskdf_set_buffer(&amp;ctx-&gt;info, &amp;ctx-&gt;info_len, p))
+            return 0;
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SALT)) != NULL)
+        if (!sskdf_set_buffer(&amp;ctx-&gt;salt, &amp;ctx-&gt;salt_len, p))
+            return 0;
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_MAC_SIZE))
+        != NULL) {
+        if (!OSSL_PARAM_get_size_t(p, &amp;sz) || sz == 0)
+            return 0;
+        ctx-&gt;out_len = sz;
     }
+    return 1;
+}
+
+static const OSSL_PARAM *sskdf_settable_ctx_params(void)
+{
+    static const OSSL_PARAM known_settable_ctx_params[] = {
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_SECRET, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_KEY, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_INFO, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_PROPERTIES, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_DIGEST, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_MAC, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_SALT, NULL, 0),
+        OSSL_PARAM_size_t(OSSL_KDF_PARAM_MAC_SIZE, NULL),
+        OSSL_PARAM_END
+    };
+    return known_settable_ctx_params;
+}
+
+static int sskdf_get_ctx_params(void *vctx, OSSL_PARAM params[])
+{
+    KDF_SSKDF *ctx = (KDF_SSKDF *)vctx;
+    OSSL_PARAM *p;
+
+    if ((p = OSSL_PARAM_locate(params, OSSL_KDF_PARAM_SIZE)) != NULL)
+        return OSSL_PARAM_set_size_t(p, sskdf_size(ctx));
+    return -2;
+}
+
+static const OSSL_PARAM *sskdf_gettable_ctx_params(void)
+{
+    static const OSSL_PARAM known_gettable_ctx_params[] = {
+        OSSL_PARAM_size_t(OSSL_KDF_PARAM_SIZE, NULL),
+        OSSL_PARAM_END
+    };
+    return known_gettable_ctx_params;
 }
 
-const EVP_KDF ss_kdf_meth = {
-    EVP_KDF_SS,
-    sskdf_new,
-    sskdf_free,
-    sskdf_reset,
-    sskdf_ctrl,
-    sskdf_ctrl_str,
-    sskdf_size,
-    sskdf_derive
+const OSSL_DISPATCH kdf_sskdf_functions[] = {
+    { OSSL_FUNC_KDF_NEWCTX, (void(*)(void))sskdf_new },
+    { OSSL_FUNC_KDF_FREECTX, (void(*)(void))sskdf_free },
+    { OSSL_FUNC_KDF_RESET, (void(*)(void))sskdf_reset },
+    { OSSL_FUNC_KDF_DERIVE, (void(*)(void))sskdf_derive },
+    { OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS,
+      (void(*)(void))sskdf_settable_ctx_params },
+    { OSSL_FUNC_KDF_SET_CTX_PARAMS, (void(*)(void))sskdf_set_ctx_params },
+    { OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS,
+      (void(*)(void))sskdf_gettable_ctx_params },
+    { OSSL_FUNC_KDF_GET_CTX_PARAMS, (void(*)(void))sskdf_get_ctx_params },
+    { 0, NULL }
 };
 
-const EVP_KDF x963_kdf_meth = {
-    EVP_KDF_X963,
-    sskdf_new,
-    sskdf_free,
-    sskdf_reset,
-    sskdf_ctrl,
-    sskdf_ctrl_str,
-    sskdf_size,
-    x963kdf_derive
+const OSSL_DISPATCH kdf_x963_kdf_functions[] = {
+    { OSSL_FUNC_KDF_NEWCTX, (void(*)(void))sskdf_new },
+    { OSSL_FUNC_KDF_FREECTX, (void(*)(void))sskdf_free },
+    { OSSL_FUNC_KDF_RESET, (void(*)(void))sskdf_reset },
+    { OSSL_FUNC_KDF_DERIVE, (void(*)(void))x963kdf_derive },
+    { OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS,
+      (void(*)(void))sskdf_settable_ctx_params },
+    { OSSL_FUNC_KDF_SET_CTX_PARAMS, (void(*)(void))sskdf_set_ctx_params },
+    { OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS,
+      (void(*)(void))sskdf_gettable_ctx_params },
+    { OSSL_FUNC_KDF_GET_CTX_PARAMS, (void(*)(void))sskdf_get_ctx_params },
+    { 0, NULL }
 };
diff --git a/crypto/kdf/tls1_prf.c b/providers/common/kdfs/tls1_prf.c
similarity index 57%
rename from crypto/kdf/tls1_prf.c
rename to providers/common/kdfs/tls1_prf.c
index edd7f05ce0..38dbaddbf0 100644
--- a/crypto/kdf/tls1_prf.c
+++ b/providers/common/kdfs/tls1_prf.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016-2018 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2016-2019 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -48,16 +48,26 @@
 #include &lt;stdio.h&gt;
 #include &lt;stdarg.h&gt;
 #include &lt;string.h&gt;
-#include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/kdf.h&gt;
 #include &lt;openssl/core_names.h&gt;
 #include &lt;openssl/params.h&gt;
+#include &quot;internal/cryptlib.h&quot;
+#include &quot;internal/numbers.h&quot;
 #include &quot;internal/evp_int.h&quot;
-#include &quot;kdf_local.h&quot;
-
-static void kdf_tls1_prf_reset(EVP_KDF_IMPL *impl);
-static int tls1_prf_alg(const EVP_MD *md,
+#include &quot;internal/provider_ctx.h&quot;
+#include &quot;internal/providercommonerr.h&quot;
+#include &quot;internal/provider_algs.h&quot;
+#include &quot;e_os.h&quot;
+
+static OSSL_OP_kdf_newctx_fn kdf_tls1_prf_new;
+static OSSL_OP_kdf_freectx_fn kdf_tls1_prf_free;
+static OSSL_OP_kdf_reset_fn kdf_tls1_prf_reset;
+static OSSL_OP_kdf_derive_fn kdf_tls1_prf_derive;
+static OSSL_OP_kdf_settable_ctx_params_fn kdf_tls1_prf_settable_ctx_params;
+static OSSL_OP_kdf_set_ctx_params_fn kdf_tls1_prf_set_ctx_params;
+
+static int tls1_prf_alg(const EVP_MD *md, const EVP_MD *sha1,
                         const unsigned char *sec, size_t slen,
                         const unsigned char *seed, size_t seed_len,
                         unsigned char *out, size_t olen);
@@ -65,147 +75,184 @@ static int tls1_prf_alg(const EVP_MD *md,
 #define TLS1_PRF_MAXBUF 1024
 
 /* TLS KDF kdf context structure */
-
-struct evp_kdf_impl_st {
+typedef struct {
+    void *provctx;
     /* Digest to use for PRF */
-    const EVP_MD *md;
+    EVP_MD *md;
+    /* Second digest for the MD5/SHA-1 combined PRF */
+    EVP_MD *sha1;
     /* Secret value to use for PRF */
     unsigned char *sec;
     size_t seclen;
     /* Buffer of concatenated seed data */
     unsigned char seed[TLS1_PRF_MAXBUF];
     size_t seedlen;
-};
+} TLS1_PRF;
 
-static EVP_KDF_IMPL *kdf_tls1_prf_new(void)
+static void *kdf_tls1_prf_new(void *provctx)
 {
-    EVP_KDF_IMPL *impl;
+    TLS1_PRF *ctx;
 
-    if ((impl = OPENSSL_zalloc(sizeof(*impl))) == NULL)
-        KDFerr(KDF_F_KDF_TLS1_PRF_NEW, ERR_R_MALLOC_FAILURE);
-    return impl;
+    if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL)
+        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+    ctx-&gt;provctx = provctx;
+    return ctx;
 }
 
-static void kdf_tls1_prf_free(EVP_KDF_IMPL *impl)
+static void kdf_tls1_prf_free(void *vctx)
 {
-    kdf_tls1_prf_reset(impl);
-    OPENSSL_free(impl);
+    TLS1_PRF *ctx = (TLS1_PRF *)vctx;
+
+    kdf_tls1_prf_reset(ctx);
+    OPENSSL_free(ctx);
 }
 
-static void kdf_tls1_prf_reset(EVP_KDF_IMPL *impl)
+static void kdf_tls1_prf_reset(void *vctx)
 {
-    OPENSSL_clear_free(impl-&gt;sec, impl-&gt;seclen);
-    OPENSSL_cleanse(impl-&gt;seed, impl-&gt;seedlen);
-    memset(impl, 0, sizeof(*impl));
+    TLS1_PRF *ctx = (TLS1_PRF *)vctx;
+
+    EVP_MD_meth_free(ctx-&gt;sha1);
+    EVP_MD_meth_free(ctx-&gt;md);
+    OPENSSL_clear_free(ctx-&gt;sec, ctx-&gt;seclen);
+    OPENSSL_cleanse(ctx-&gt;seed, ctx-&gt;seedlen);
+    memset(ctx, 0, sizeof(*ctx));
 }
 
-static int kdf_tls1_prf_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
+static int kdf_tls1_prf_derive(void *vctx, unsigned char *key,
+                               size_t keylen)
 {
-    const unsigned char *p;
-    size_t len;
-    const EVP_MD *md;
-
-    switch (cmd) {
-    case EVP_KDF_CTRL_SET_MD:
-        md = va_arg(args, const EVP_MD *);
-        if (md == NULL)
-            return 0;
+    TLS1_PRF *ctx = (TLS1_PRF *)vctx;
 
-        impl-&gt;md = md;
-        return 1;
+    if (ctx-&gt;md == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
+        return 0;
+    }
+    if (ctx-&gt;sec == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_SECRET);
+        return 0;
+    }
+    if (ctx-&gt;seedlen == 0) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_SEED);
+        return 0;
+    }
+    return tls1_prf_alg(ctx-&gt;md, ctx-&gt;sha1, ctx-&gt;sec, ctx-&gt;seclen,
+                        ctx-&gt;seed, ctx-&gt;seedlen,
+                        key, keylen);
+}
 
-    case EVP_KDF_CTRL_SET_TLS_SECRET:
-        p = va_arg(args, const unsigned char *);
-        len = va_arg(args, size_t);
-        OPENSSL_clear_free(impl-&gt;sec, impl-&gt;seclen);
-        impl-&gt;sec = OPENSSL_memdup(p, len);
-        if (impl-&gt;sec == NULL)
+static int kdf_tls1_prf_set_ctx_params(void *vctx, const OSSL_PARAM params[])
+{
+    const OSSL_PARAM *p;
+    TLS1_PRF *ctx = vctx;
+    EVP_MD *md, *sha = NULL;
+    const char *properties = NULL, *name;
+
+    /* Grab search properties, this should be before the digest lookup */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PROPERTIES))
+        != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
             return 0;
-
-        impl-&gt;seclen = len;
-        return 1;
-
-    case EVP_KDF_CTRL_RESET_TLS_SEED:
-        OPENSSL_cleanse(impl-&gt;seed, impl-&gt;seedlen);
-        impl-&gt;seedlen = 0;
-        return 1;
-
-    case EVP_KDF_CTRL_ADD_TLS_SEED:
-        p = va_arg(args, const unsigned char *);
-        len = va_arg(args, size_t);
-        if (len == 0 || p == NULL)
-            return 1;
-
-        if (len &gt; (TLS1_PRF_MAXBUF - impl-&gt;seedlen))
+        properties = p-&gt;data;
+    }
+    /* Handle aliasing of digest parameter names */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_DIGEST)) != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
             return 0;
+        name = p-&gt;data;
+        if (strcasecmp(name, SN_md5_sha1) == 0) {
+            sha = EVP_MD_fetch(PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx), SN_sha1,
+                               properties);
+            if (sha == NULL) {
+                ERR_raise(ERR_LIB_PROV, PROV_R_UNABLE_TO_LOAD_SHA1);
+                return 0;
+            }
+            name = SN_md5;
+        }
+        md = EVP_MD_fetch(PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx), name,
+                          properties);
+        if (md == NULL) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DIGEST);
+            EVP_MD_meth_free(sha);
+            return 0;
+        }
+        EVP_MD_meth_free(ctx-&gt;sha1);
+        EVP_MD_meth_free(ctx-&gt;md);
+        ctx-&gt;md = md;
+        ctx-&gt;sha1 = sha;
+    }
 
-        memcpy(impl-&gt;seed + impl-&gt;seedlen, p, len);
-        impl-&gt;seedlen += len;
-        return 1;
-
-    default:
-        return -2;
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SECRET)) != NULL) {
+        OPENSSL_clear_free(ctx-&gt;sec, ctx-&gt;seclen);
+        ctx-&gt;sec = NULL;
+        if (!OSSL_PARAM_get_octet_string(p, (void **)&amp;ctx-&gt;sec, 0, &amp;ctx-&gt;seclen))
+            return 0;
     }
+    /* The seed fields concatenate, so process them all */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SEED)) != NULL) {
+        OPENSSL_cleanse(ctx-&gt;seed, ctx-&gt;seedlen);
+        ctx-&gt;seedlen = 0;
+
+        for (; p != NULL; p = OSSL_PARAM_locate_const(p + 1,
+                                                      OSSL_KDF_PARAM_SEED)) {
+            const void *q = ctx-&gt;seed + ctx-&gt;seedlen;
+            size_t sz = 0;
+
+            if (p-&gt;data_size != 0
+                &amp;&amp; p-&gt;data != NULL
+                &amp;&amp; !OSSL_PARAM_get_octet_string(p, (void **)&amp;q,
+                                                TLS1_PRF_MAXBUF - ctx-&gt;seedlen,
+                                                &amp;sz))
+                return 0;
+            ctx-&gt;seedlen += sz;
+        }
+    }
+    return 1;
 }
 
-static int kdf_tls1_prf_ctrl_str(EVP_KDF_IMPL *impl,
-                                 const char *type, const char *value)
+static const OSSL_PARAM *kdf_tls1_prf_settable_ctx_params(void)
 {
-    if (value == NULL) {
-        KDFerr(KDF_F_KDF_TLS1_PRF_CTRL_STR, KDF_R_VALUE_MISSING);
-        return 0;
-    }
-    if (strcmp(type, &quot;digest&quot;) == 0)
-        return kdf_md2ctrl(impl, kdf_tls1_prf_ctrl, EVP_KDF_CTRL_SET_MD, value);
-
-    if (strcmp(type, &quot;secret&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_tls1_prf_ctrl,
-                            EVP_KDF_CTRL_SET_TLS_SECRET, value);
-
-    if (strcmp(type, &quot;hexsecret&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_tls1_prf_ctrl,
-                            EVP_KDF_CTRL_SET_TLS_SECRET, value);
-
-    if (strcmp(type, &quot;seed&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_tls1_prf_ctrl, EVP_KDF_CTRL_ADD_TLS_SEED,
-                            value);
+    static const OSSL_PARAM known_settable_ctx_params[] = {
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_PROPERTIES, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_DIGEST, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_SECRET, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_SEED, NULL, 0),
+        OSSL_PARAM_END
+    };
+    return known_settable_ctx_params;
+}
 
-    if (strcmp(type, &quot;hexseed&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_tls1_prf_ctrl, EVP_KDF_CTRL_ADD_TLS_SEED,
-                            value);
+static int kdf_tls1_prf_get_ctx_params(void *vctx, OSSL_PARAM params[])
+{
+    OSSL_PARAM *p;
 
+    if ((p = OSSL_PARAM_locate(params, OSSL_KDF_PARAM_SIZE)) != NULL)
+        return OSSL_PARAM_set_size_t(p, SIZE_MAX);
     return -2;
 }
 
-static int kdf_tls1_prf_derive(EVP_KDF_IMPL *impl, unsigned char *key,
-                               size_t keylen)
+static const OSSL_PARAM *kdf_tls1_prf_gettable_ctx_params(void)
 {
-    if (impl-&gt;md == NULL) {
-        KDFerr(KDF_F_KDF_TLS1_PRF_DERIVE, KDF_R_MISSING_MESSAGE_DIGEST);
-        return 0;
-    }
-    if (impl-&gt;sec == NULL) {
-        KDFerr(KDF_F_KDF_TLS1_PRF_DERIVE, KDF_R_MISSING_SECRET);
-        return 0;
-    }
-    if (impl-&gt;seedlen == 0) {
-        KDFerr(KDF_F_KDF_TLS1_PRF_DERIVE, KDF_R_MISSING_SEED);
-        return 0;
-    }
-    return tls1_prf_alg(impl-&gt;md, impl-&gt;sec, impl-&gt;seclen,
-                        impl-&gt;seed, impl-&gt;seedlen,
-                        key, keylen);
+    static const OSSL_PARAM known_gettable_ctx_params[] = {
+        OSSL_PARAM_size_t(OSSL_KDF_PARAM_SIZE, NULL),
+        OSSL_PARAM_END
+    };
+    return known_gettable_ctx_params;
 }
 
-const EVP_KDF tls1_prf_kdf_meth = {
-    EVP_KDF_TLS1_PRF,
-    kdf_tls1_prf_new,
-    kdf_tls1_prf_free,
-    kdf_tls1_prf_reset,
-    kdf_tls1_prf_ctrl,
-    kdf_tls1_prf_ctrl_str,
-    NULL,
-    kdf_tls1_prf_derive
+const OSSL_DISPATCH kdf_tls1_prf_functions[] = {
+    { OSSL_FUNC_KDF_NEWCTX, (void(*)(void))kdf_tls1_prf_new },
+    { OSSL_FUNC_KDF_FREECTX, (void(*)(void))kdf_tls1_prf_free },
+    { OSSL_FUNC_KDF_RESET, (void(*)(void))kdf_tls1_prf_reset },
+    { OSSL_FUNC_KDF_DERIVE, (void(*)(void))kdf_tls1_prf_derive },
+    { OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS,
+      (void(*)(void))kdf_tls1_prf_settable_ctx_params },
+    { OSSL_FUNC_KDF_SET_CTX_PARAMS,
+      (void(*)(void))kdf_tls1_prf_set_ctx_params },
+    { OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS,
+      (void(*)(void))kdf_tls1_prf_gettable_ctx_params },
+    { OSSL_FUNC_KDF_GET_CTX_PARAMS,
+      (void(*)(void))kdf_tls1_prf_get_ctx_params },
+    { 0, NULL }
 };
 
 /*
@@ -335,12 +382,12 @@ static int tls1_prf_P_hash(const EVP_MD *md,
  *
  *   PRF(secret, label, seed) = P_&lt;hash&gt;(secret, label + seed)
  */
-static int tls1_prf_alg(const EVP_MD *md,
+static int tls1_prf_alg(const EVP_MD *md, const EVP_MD *sha1,
                         const unsigned char *sec, size_t slen,
                         const unsigned char *seed, size_t seed_len,
                         unsigned char *out, size_t olen)
 {
-    if (EVP_MD_type(md) == NID_md5_sha1) {
+    if (sha1 != NULL) {
         /* TLS v1.0 and TLS v1.1 */
         size_t i;
         unsigned char *tmp;
@@ -348,15 +395,15 @@ static int tls1_prf_alg(const EVP_MD *md,
         size_t L_S1 = (slen + 1) / 2;
         size_t L_S2 = L_S1;
 
-        if (!tls1_prf_P_hash(EVP_md5(), sec, L_S1,
+        if (!tls1_prf_P_hash(md, sec, L_S1,
                              seed, seed_len, out, olen))
             return 0;
 
         if ((tmp = OPENSSL_malloc(olen)) == NULL) {
-            KDFerr(KDF_F_TLS1_PRF_ALG, ERR_R_MALLOC_FAILURE);
+            ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
             return 0;
         }
-        if (!tls1_prf_P_hash(EVP_sha1(), sec + slen - L_S2, L_S2,
+        if (!tls1_prf_P_hash(sha1, sec + slen - L_S2, L_S2,
                              seed, seed_len, tmp, olen)) {
             OPENSSL_clear_free(tmp, olen);
             return 0;
diff --git a/providers/common/provider_err.c b/providers/common/provider_err.c
index ed1d930712..b9895593b9 100644
--- a/providers/common/provider_err.c
+++ b/providers/common/provider_err.c
@@ -17,6 +17,10 @@ static const ERR_STRING_DATA PROV_str_reasons[] = {
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_AES_KEY_SETUP_FAILED),
     &quot;aes key setup failed&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_BAD_DECRYPT), &quot;bad decrypt&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_BAD_ENCODING), &quot;bad encoding&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_BAD_LENGTH), &quot;bad length&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_BOTH_MODE_AND_MODE_INT),
+    &quot;both mode and mode int&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_CIPHER_OPERATION_FAILED),
     &quot;cipher operation failed&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_FAILED_TO_GENERATE_KEY),
@@ -25,19 +29,40 @@ static const ERR_STRING_DATA PROV_str_reasons[] = {
     &quot;failed to get parameter&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_FAILED_TO_SET_PARAMETER),
     &quot;failed to set parameter&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INAVLID_UKM_LENGTH),
+    &quot;inavlid ukm length&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_AAD), &quot;invalid aad&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_CUSTOM_LENGTH),
     &quot;invalid custom length&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_DATA), &quot;invalid data&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_DIGEST), &quot;invalid digest&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_ITERATION_COUNT),
+    &quot;invalid iteration count&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_IVLEN), &quot;invalid ivlen&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_IV_LENGTH), &quot;invalid iv length&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_KEYLEN), &quot;invalid keylen&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_KEY_LEN), &quot;invalid key len&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_KEY_LENGTH),
     &quot;invalid key length&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_MODE), &quot;invalid mode&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_MODE_INT), &quot;invalid mode int&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_SALT_LENGTH),
     &quot;invalid salt length&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_TAG), &quot;invalid tag&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_INVALID_TAGLEN), &quot;invalid taglen&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_MISSING_CEK_ALG), &quot;missing cek alg&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_MISSING_KEY), &quot;missing key&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_MISSING_MESSAGE_DIGEST),
+    &quot;missing message digest&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_MISSING_PASS), &quot;missing pass&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_MISSING_SALT), &quot;missing salt&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_MISSING_SECRET), &quot;missing secret&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_MISSING_SEED), &quot;missing seed&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_MISSING_SESSION_ID),
+    &quot;missing session id&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_MISSING_TYPE), &quot;missing type&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_MISSING_XCGHASH), &quot;missing xcghash&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_NOT_SUPPORTED), &quot;not supported&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_NOT_XOF_OR_INVALID_LENGTH),
     &quot;not xof or invalid length&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_NO_KEY_SET), &quot;no key set&quot;},
@@ -45,8 +70,19 @@ static const ERR_STRING_DATA PROV_str_reasons[] = {
     &quot;output buffer too small&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_TAG_NOTSET), &quot;tag notset&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_TAG_NOT_NEEDED), &quot;tag not needed&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_UNABLE_TO_LOAD_SHA1),
+    &quot;unable to load sha1&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_UNABLE_TO_LOAD_SHA256),
+    &quot;unable to load sha256&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_UNSUPPORTED_CEK_ALG),
+    &quot;unsupported cek alg&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_UNSUPPORTED_MAC_TYPE),
+    &quot;unsupported mac type&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_VALUE_ERROR), &quot;value error&quot;},
     {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_WRONG_FINAL_BLOCK_LENGTH),
     &quot;wrong final block length&quot;},
+    {ERR_PACK(ERR_LIB_PROV, 0, PROV_R_WRONG_OUTPUT_BUFFER_SIZE),
+    &quot;wrong output buffer size&quot;},
     {0, NULL}
 };
 
diff --git a/providers/default/build.info b/providers/default/build.info
index f0a6c5c742..ca78cce0a8 100644
--- a/providers/default/build.info
+++ b/providers/default/build.info
@@ -1,4 +1,5 @@
 SUBDIRS=digests macs ciphers
+SUBDIRS=digests kdfs macs ciphers
 LIBS=../../libcrypto
 SOURCE[../../libcrypto]=\
         defltprov.c
diff --git a/providers/default/defltprov.c b/providers/default/defltprov.c
index c481171a78..8a950482c8 100644
--- a/providers/default/defltprov.c
+++ b/providers/default/defltprov.c
@@ -211,6 +211,22 @@ static const OSSL_ALGORITHM deflt_macs[] = {
     { NULL, NULL, NULL }
 };
 
+static const OSSL_ALGORITHM deflt_kdfs[] = {
+    { &quot;HKDF&quot;, &quot;default=yes&quot;, kdf_hkdf_functions },
+    { &quot;SSKDF&quot;, &quot;default=yes&quot;, kdf_sskdf_functions },
+    { &quot;PBKDF2&quot;, &quot;default=yes&quot;, kdf_pbkdf2_functions },
+    { &quot;SSHKDF&quot;, &quot;default=yes&quot;, kdf_sshkdf_functions },
+    { &quot;X963KDF&quot;, &quot;default=yes&quot;, kdf_x963_kdf_functions },
+    { &quot;TLS1-PRF&quot;, &quot;default=yes&quot;, kdf_tls1_prf_functions },
+#ifndef OPENSSL_NO_CMS
+    { &quot;X942KDF&quot;, &quot;default=yes&quot;, kdf_x942_kdf_functions },
+#endif
+#ifndef OPENSSL_NO_SCRYPT
+    { &quot;id-scrypt&quot;, &quot;default=yes&quot;, kdf_scrypt_functions },
+#endif
+   { NULL, NULL, NULL }
+};
+
 static const OSSL_ALGORITHM deflt_keyexch[] = {
 #ifndef OPENSSL_NO_DH
     { &quot;dhKeyAgreement&quot;, &quot;default=yes&quot;, dh_keyexch_functions },
@@ -237,6 +253,8 @@ static const OSSL_ALGORITHM *deflt_query(OSSL_PROVIDER *prov,
         return deflt_ciphers;
     case OSSL_OP_MAC:
         return deflt_macs;
+    case OSSL_OP_KDF:
+        return deflt_kdfs;
     case OSSL_OP_KEYMGMT:
         return deflt_keymgmt;
     case OSSL_OP_KEYEXCH:
diff --git a/providers/default/kdfs/build.info b/providers/default/kdfs/build.info
new file mode 100644
index 0000000000..27047c5286
--- /dev/null
+++ b/providers/default/kdfs/build.info
@@ -0,0 +1,3 @@
+LIBS=../../../libcrypto
+SOURCE[../../../libcrypto]=scrypt.c sshkdf.c x942kdf.c
+INCLUDE[../../../libcrypto]=. ../../../crypto
diff --git a/crypto/kdf/scrypt.c b/providers/default/kdfs/scrypt.c
similarity index 56%
rename from crypto/kdf/scrypt.c
rename to providers/default/kdfs/scrypt.c
index 29ceeb3ad9..abb4437d70 100644
--- a/crypto/kdf/scrypt.c
+++ b/providers/default/kdfs/scrypt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017-2018 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2017-2019 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -13,115 +13,128 @@
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/kdf.h&gt;
 #include &lt;openssl/err.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &quot;internal/evp_int.h&quot;
 #include &quot;internal/numbers.h&quot;
-#include &quot;kdf_local.h&quot;
+#include &quot;internal/provider_algs.h&quot;
+#include &quot;internal/provider_ctx.h&quot;
+#include &quot;internal/providercommonerr.h&quot;
+#include &quot;internal/provider_algs.h&quot;
 
 #ifndef OPENSSL_NO_SCRYPT
 
-static void kdf_scrypt_reset(EVP_KDF_IMPL *impl);
-static void kdf_scrypt_init(EVP_KDF_IMPL *impl);
-static int atou64(const char *nptr, uint64_t *result);
+static OSSL_OP_kdf_newctx_fn kdf_scrypt_new;
+static OSSL_OP_kdf_freectx_fn kdf_scrypt_free;
+static OSSL_OP_kdf_reset_fn kdf_scrypt_reset;
+static OSSL_OP_kdf_derive_fn kdf_scrypt_derive;
+static OSSL_OP_kdf_settable_ctx_params_fn kdf_scrypt_settable_ctx_params;
+static OSSL_OP_kdf_set_ctx_params_fn kdf_scrypt_set_ctx_params;
+
 static int scrypt_alg(const char *pass, size_t passlen,
                       const unsigned char *salt, size_t saltlen,
                       uint64_t N, uint64_t r, uint64_t p, uint64_t maxmem,
-                      unsigned char *key, size_t keylen);
+                      unsigned char *key, size_t keylen, EVP_MD *sha256);
 
-struct evp_kdf_impl_st {
+typedef struct {
+    void *provctx;
     unsigned char *pass;
     size_t pass_len;
     unsigned char *salt;
     size_t salt_len;
     uint64_t N;
-    uint32_t r, p;
+    uint64_t r, p;
     uint64_t maxmem_bytes;
-};
-
-/* Custom uint64_t parser since we do not have strtoull */
-static int atou64(const char *nptr, uint64_t *result)
-{
-    uint64_t value = 0;
-
-    while (*nptr) {
-        unsigned int digit;
-        uint64_t new_value;
+    EVP_MD *sha256;
+} KDF_SCRYPT;
 
-        if ((*nptr &lt; '0') || (*nptr &gt; '9')) {
-            return 0;
-        }
-        digit = (unsigned int)(*nptr - '0');
-        new_value = (value * 10) + digit;
-        if ((new_value &lt; digit) || ((new_value - digit) / 10 != value)) {
-            /* Overflow */
-            return 0;
-        }
-        value = new_value;
-        nptr++;
-    }
-    *result = value;
-    return 1;
-}
+static void kdf_scrypt_init(KDF_SCRYPT *ctx);
 
-static EVP_KDF_IMPL *kdf_scrypt_new(void)
+static void *kdf_scrypt_new(void *provctx)
 {
-    EVP_KDF_IMPL *impl;
+    KDF_SCRYPT *ctx;
 
-    impl = OPENSSL_zalloc(sizeof(*impl));
-    if (impl == NULL) {
-        KDFerr(KDF_F_KDF_SCRYPT_NEW, ERR_R_MALLOC_FAILURE);
+    ctx = OPENSSL_zalloc(sizeof(*ctx));
+    if (ctx == NULL) {
+        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+    ctx-&gt;provctx = provctx;
+    ctx-&gt;sha256 = EVP_MD_fetch(PROV_LIBRARY_CONTEXT_OF(provctx),
+                               &quot;sha256&quot;, NULL);
+    if (ctx-&gt;sha256 == NULL) {
+        OPENSSL_free(ctx);
+        ERR_raise(ERR_LIB_PROV, PROV_R_UNABLE_TO_LOAD_SHA256);
         return NULL;
     }
-    kdf_scrypt_init(impl);
-    return impl;
+    kdf_scrypt_init(ctx);
+    return ctx;
 }
 
-static void kdf_scrypt_free(EVP_KDF_IMPL *impl)
+static void kdf_scrypt_free(void *vctx)
 {
-    kdf_scrypt_reset(impl);
-    OPENSSL_free(impl);
+    KDF_SCRYPT *ctx = (KDF_SCRYPT *)vctx;
+
+    EVP_MD_meth_free(ctx-&gt;sha256);
+    kdf_scrypt_reset(ctx);
+    OPENSSL_free(ctx);
 }
 
-static void kdf_scrypt_reset(EVP_KDF_IMPL *impl)
+static void kdf_scrypt_reset(void *vctx)
 {
-    OPENSSL_free(impl-&gt;salt);
-    OPENSSL_clear_free(impl-&gt;pass, impl-&gt;pass_len);
-    memset(impl, 0, sizeof(*impl));
-    kdf_scrypt_init(impl);
+    KDF_SCRYPT *ctx = (KDF_SCRYPT *)vctx;
+
+    OPENSSL_free(ctx-&gt;salt);
+    OPENSSL_clear_free(ctx-&gt;pass, ctx-&gt;pass_len);
+    kdf_scrypt_init(ctx);
 }
 
-static void kdf_scrypt_init(EVP_KDF_IMPL *impl)
+static void kdf_scrypt_init(KDF_SCRYPT *ctx)
 {
     /* Default values are the most conservative recommendation given in the
      * original paper of C. Percival. Derivation uses roughly 1 GiB of memory
      * for this parameter choice (approx. 128 * r * N * p bytes).
      */
-    impl-&gt;N = 1 &lt;&lt; 20;
-    impl-&gt;r = 8;
-    impl-&gt;p = 1;
-    impl-&gt;maxmem_bytes = 1025 * 1024 * 1024;
+    ctx-&gt;N = 1 &lt;&lt; 20;
+    ctx-&gt;r = 8;
+    ctx-&gt;p = 1;
+    ctx-&gt;maxmem_bytes = 1025 * 1024 * 1024;
 }
 
 static int scrypt_set_membuf(unsigned char **buffer, size_t *buflen,
-                             const unsigned char *new_buffer,
-                             size_t new_buflen)
+                             const OSSL_PARAM *p)
 {
-    if (new_buffer == NULL)
-        return 1;
-
     OPENSSL_clear_free(*buffer, *buflen);
+    if (p-&gt;data_size == 0) {
+        if ((*buffer = OPENSSL_malloc(1)) == NULL) {
+            ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+    } else if (p-&gt;data != NULL) {
+        *buffer = NULL;
+        if (!OSSL_PARAM_get_octet_string(p, (void **)buffer, 0, buflen))
+            return 0;
+    }
+    return 1;
+}
+
+static int kdf_scrypt_derive(void *vctx, unsigned char *key,
+                             size_t keylen)
+{
+    KDF_SCRYPT *ctx = (KDF_SCRYPT *)vctx;
 
-    if (new_buflen &gt; 0) {
-        *buffer = OPENSSL_memdup(new_buffer, new_buflen);
-    } else {
-        *buffer = OPENSSL_malloc(1);
+    if (ctx-&gt;pass == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_PASS);
+        return 0;
     }
-    if (*buffer == NULL) {
-        KDFerr(KDF_F_SCRYPT_SET_MEMBUF, ERR_R_MALLOC_FAILURE);
+
+    if (ctx-&gt;salt == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_SALT);
         return 0;
     }
 
-    *buflen = new_buflen;
-    return 1;
+    return scrypt_alg((char *)ctx-&gt;pass, ctx-&gt;pass_len, ctx-&gt;salt,
+                      ctx-&gt;salt_len, ctx-&gt;N, ctx-&gt;r, ctx-&gt;p,
+                      ctx-&gt;maxmem_bytes, key, keylen, ctx-&gt;sha256);
 }
 
 static int is_power_of_two(uint64_t value)
@@ -129,152 +142,96 @@ static int is_power_of_two(uint64_t value)
     return (value != 0) &amp;&amp; ((value &amp; (value - 1)) == 0);
 }
 
-static int kdf_scrypt_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
+static int kdf_scrypt_set_ctx_params(void *vctx, const OSSL_PARAM params[])
 {
+    const OSSL_PARAM *p;
+    KDF_SCRYPT *ctx = vctx;
     uint64_t u64_value;
-    uint32_t value;
-    const unsigned char *p;
-    size_t len;
-
-    switch (cmd) {
-    case EVP_KDF_CTRL_SET_PASS:
-        p = va_arg(args, const unsigned char *);
-        len = va_arg(args, size_t);
-        return scrypt_set_membuf(&amp;impl-&gt;pass, &amp;impl-&gt;pass_len, p, len);
-
-    case EVP_KDF_CTRL_SET_SALT:
-        p = va_arg(args, const unsigned char *);
-        len = va_arg(args, size_t);
-        return scrypt_set_membuf(&amp;impl-&gt;salt, &amp;impl-&gt;salt_len, p, len);
-
-    case EVP_KDF_CTRL_SET_SCRYPT_N:
-        u64_value = va_arg(args, uint64_t);
-        if ((u64_value &lt;= 1) || !is_power_of_two(u64_value))
-            return 0;
 
-        impl-&gt;N = u64_value;
-        return 1;
-
-    case EVP_KDF_CTRL_SET_SCRYPT_R:
-        value = va_arg(args, uint32_t);
-        if (value &lt; 1)
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PASSWORD)) != NULL)
+        if (!scrypt_set_membuf(&amp;ctx-&gt;pass, &amp;ctx-&gt;pass_len, p))
             return 0;
 
-        impl-&gt;r = value;
-        return 1;
-
-    case EVP_KDF_CTRL_SET_SCRYPT_P:
-        value = va_arg(args, uint32_t);
-        if (value &lt; 1)
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SALT)) != NULL)
+        if (!scrypt_set_membuf(&amp;ctx-&gt;salt, &amp;ctx-&gt;salt_len, p))
             return 0;
 
-        impl-&gt;p = value;
-        return 1;
-
-    case EVP_KDF_CTRL_SET_MAXMEM_BYTES:
-        u64_value = va_arg(args, uint64_t);
-        if (u64_value &lt; 1)
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SCRYPT_N))
+        != NULL) {
+        if (!OSSL_PARAM_get_uint64(p, &amp;u64_value)
+            || u64_value &lt;= 1
+            || !is_power_of_two(u64_value))
             return 0;
+        ctx-&gt;N = u64_value;
+    }
 
-        impl-&gt;maxmem_bytes = u64_value;
-        return 1;
-
-    default:
-        return -2;
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SCRYPT_R))
+        != NULL) {
+        if (!OSSL_PARAM_get_uint64(p, &amp;u64_value) || u64_value &lt; 1)
+            return 0;
+        ctx-&gt;r = u64_value;
     }
-}
 
-static int kdf_scrypt_ctrl_uint32(EVP_KDF_IMPL *impl, int cmd,
-                                  const char *value)
-{
-    int int_value = atoi(value);
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SCRYPT_P))
+        != NULL) {
+        if (!OSSL_PARAM_get_uint64(p, &amp;u64_value) || u64_value &lt; 1)
+            return 0;
+        ctx-&gt;p = u64_value;
+    }
 
-    if (int_value &lt; 0 || (uint64_t)int_value &gt; UINT32_MAX) {
-        KDFerr(KDF_F_KDF_SCRYPT_CTRL_UINT32, KDF_R_VALUE_ERROR);
-        return 0;
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SCRYPT_MAXMEM))
+        != NULL) {
+        if (!OSSL_PARAM_get_uint64(p, &amp;u64_value) || u64_value &lt; 1)
+            return 0;
+        ctx-&gt;maxmem_bytes = u64_value;
     }
-    return call_ctrl(kdf_scrypt_ctrl, impl, cmd, (uint32_t)int_value);
+    return 1;
 }
 
-static int kdf_scrypt_ctrl_uint64(EVP_KDF_IMPL *impl, int cmd,
-                                  const char *value)
+static const OSSL_PARAM *kdf_scrypt_settable_ctx_params(void)
 {
-    uint64_t u64_value;
-
-    if (!atou64(value, &amp;u64_value)) {
-        KDFerr(KDF_F_KDF_SCRYPT_CTRL_UINT64, KDF_R_VALUE_ERROR);
-        return 0;
-    }
-    return call_ctrl(kdf_scrypt_ctrl, impl, cmd, u64_value);
+    static const OSSL_PARAM known_settable_ctx_params[] = {
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_PASSWORD, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_SALT, NULL, 0),
+        OSSL_PARAM_uint64(OSSL_KDF_PARAM_SCRYPT_N, NULL),
+        OSSL_PARAM_uint32(OSSL_KDF_PARAM_SCRYPT_R, NULL),
+        OSSL_PARAM_uint32(OSSL_KDF_PARAM_SCRYPT_P, NULL),
+        OSSL_PARAM_uint64(OSSL_KDF_PARAM_SCRYPT_MAXMEM, NULL),
+        OSSL_PARAM_END
+    };
+    return known_settable_ctx_params;
 }
 
-static int kdf_scrypt_ctrl_str(EVP_KDF_IMPL *impl, const char *type,
-                               const char *value)
+static int kdf_scrypt_get_ctx_params(void *vctx, OSSL_PARAM params[])
 {
-    if (value == NULL) {
-        KDFerr(KDF_F_KDF_SCRYPT_CTRL_STR, KDF_R_VALUE_MISSING);
-        return 0;
-    }
-
-    if (strcmp(type, &quot;pass&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_scrypt_ctrl, EVP_KDF_CTRL_SET_PASS,
-                            value);
-
-    if (strcmp(type, &quot;hexpass&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_scrypt_ctrl, EVP_KDF_CTRL_SET_PASS,
-                            value);
-
-    if (strcmp(type, &quot;salt&quot;) == 0)
-        return kdf_str2ctrl(impl, kdf_scrypt_ctrl, EVP_KDF_CTRL_SET_SALT,
-                            value);
-
-    if (strcmp(type, &quot;hexsalt&quot;) == 0)
-        return kdf_hex2ctrl(impl, kdf_scrypt_ctrl, EVP_KDF_CTRL_SET_SALT,
-                            value);
-
-    if (strcmp(type, &quot;N&quot;) == 0)
-        return kdf_scrypt_ctrl_uint64(impl, EVP_KDF_CTRL_SET_SCRYPT_N, value);
-
-    if (strcmp(type, &quot;r&quot;) == 0)
-        return kdf_scrypt_ctrl_uint32(impl, EVP_KDF_CTRL_SET_SCRYPT_R, value);
-
-    if (strcmp(type, &quot;p&quot;) == 0)
-        return kdf_scrypt_ctrl_uint32(impl, EVP_KDF_CTRL_SET_SCRYPT_P, value);
-
-    if (strcmp(type, &quot;maxmem_bytes&quot;) == 0)
-        return kdf_scrypt_ctrl_uint64(impl, EVP_KDF_CTRL_SET_MAXMEM_BYTES,
-                                      value);
+    OSSL_PARAM *p;
 
+    if ((p = OSSL_PARAM_locate(params, OSSL_KDF_PARAM_SIZE)) != NULL)
+        return OSSL_PARAM_set_size_t(p, SIZE_MAX);
     return -2;
 }
 
-static int kdf_scrypt_derive(EVP_KDF_IMPL *impl, unsigned char *key,
-                             size_t keylen)
+static const OSSL_PARAM *kdf_scrypt_gettable_ctx_params(void)
 {
-    if (impl-&gt;pass == NULL) {
-        KDFerr(KDF_F_KDF_SCRYPT_DERIVE, KDF_R_MISSING_PASS);
-        return 0;
-    }
-
-    if (impl-&gt;salt == NULL) {
-        KDFerr(KDF_F_KDF_SCRYPT_DERIVE, KDF_R_MISSING_SALT);
-        return 0;
-    }
-
-    return scrypt_alg((char *)impl-&gt;pass, impl-&gt;pass_len, impl-&gt;salt,
-                      impl-&gt;salt_len, impl-&gt;N, impl-&gt;r, impl-&gt;p,
-                      impl-&gt;maxmem_bytes, key, keylen);
+    static const OSSL_PARAM known_gettable_ctx_params[] = {
+        OSSL_PARAM_size_t(OSSL_KDF_PARAM_SIZE, NULL),
+        OSSL_PARAM_END
+    };
+    return known_gettable_ctx_params;
 }
 
-const EVP_KDF scrypt_kdf_meth = {
-    EVP_KDF_SCRYPT,
-    kdf_scrypt_new,
-    kdf_scrypt_free,
-    kdf_scrypt_reset,
-    kdf_scrypt_ctrl,
-    kdf_scrypt_ctrl_str,
-    NULL,
-    kdf_scrypt_derive
+const OSSL_DISPATCH kdf_scrypt_functions[] = {
+    { OSSL_FUNC_KDF_NEWCTX, (void(*)(void))kdf_scrypt_new },
+    { OSSL_FUNC_KDF_FREECTX, (void(*)(void))kdf_scrypt_free },
+    { OSSL_FUNC_KDF_RESET, (void(*)(void))kdf_scrypt_reset },
+    { OSSL_FUNC_KDF_DERIVE, (void(*)(void))kdf_scrypt_derive },
+    { OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS,
+      (void(*)(void))kdf_scrypt_settable_ctx_params },
+    { OSSL_FUNC_KDF_SET_CTX_PARAMS, (void(*)(void))kdf_scrypt_set_ctx_params },
+    { OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS,
+      (void(*)(void))kdf_scrypt_gettable_ctx_params },
+    { OSSL_FUNC_KDF_GET_CTX_PARAMS, (void(*)(void))kdf_scrypt_get_ctx_params },
+    { 0, NULL }
 };
 
 #define R(a,b) (((a) &lt;&lt; (b)) | ((a) &gt;&gt; (32 - (b))))
@@ -400,7 +357,7 @@ static void scryptROMix(unsigned char *B, uint64_t r, uint64_t N,
 static int scrypt_alg(const char *pass, size_t passlen,
                       const unsigned char *salt, size_t saltlen,
                       uint64_t N, uint64_t r, uint64_t p, uint64_t maxmem,
-                      unsigned char *key, size_t keylen)
+                      unsigned char *key, size_t keylen, EVP_MD *sha256)
 {
     int rv = 0;
     unsigned char *B;
@@ -484,14 +441,14 @@ static int scrypt_alg(const char *pass, size_t passlen,
     X = (uint32_t *)(B + Blen);
     T = X + 32 * r;
     V = T + 32 * r;
-    if (PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, 1, EVP_sha256(),
+    if (PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, 1, sha256,
                           (int)Blen, B) == 0)
         goto err;
 
     for (i = 0; i &lt; p; i++)
         scryptROMix(B + 128 * r * i, r, N, X, T, V);
 
-    if (PKCS5_PBKDF2_HMAC(pass, passlen, B, (int)Blen, 1, EVP_sha256(),
+    if (PKCS5_PBKDF2_HMAC(pass, passlen, B, (int)Blen, 1, sha256,
                           keylen, key) == 0)
         goto err;
     rv = 1;
diff --git a/providers/default/kdfs/sshkdf.c b/providers/default/kdfs/sshkdf.c
new file mode 100644
index 0000000000..da59aaf861
--- /dev/null
+++ b/providers/default/kdfs/sshkdf.c
@@ -0,0 +1,297 @@
+/*
+ * Copyright 2018-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;string.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/kdf.h&gt;
+#include &lt;openssl/core_names.h&gt;
+#include &quot;internal/cryptlib.h&quot;
+#include &quot;internal/numbers.h&quot;
+#include &quot;internal/evp_int.h&quot;
+#include &quot;internal/provider_ctx.h&quot;
+#include &quot;internal/providercommonerr.h&quot;
+#include &quot;internal/provider_algs.h&quot;
+
+/* See RFC 4253, Section 7.2 */
+static OSSL_OP_kdf_newctx_fn kdf_sshkdf_new;
+static OSSL_OP_kdf_freectx_fn kdf_sshkdf_free;
+static OSSL_OP_kdf_reset_fn kdf_sshkdf_reset;
+static OSSL_OP_kdf_derive_fn kdf_sshkdf_derive;
+static OSSL_OP_kdf_settable_ctx_params_fn kdf_sshkdf_settable_ctx_params;
+static OSSL_OP_kdf_set_ctx_params_fn kdf_sshkdf_set_ctx_params;
+static OSSL_OP_kdf_gettable_ctx_params_fn kdf_sshkdf_gettable_ctx_params;
+static OSSL_OP_kdf_get_ctx_params_fn kdf_sshkdf_get_ctx_params;
+
+static int SSHKDF(const EVP_MD *evp_md,
+                  const unsigned char *key, size_t key_len,
+                  const unsigned char *xcghash, size_t xcghash_len,
+                  const unsigned char *session_id, size_t session_id_len,
+                  char type, unsigned char *okey, size_t okey_len);
+
+typedef struct {
+    void *provctx;
+    EVP_MD *md;
+    unsigned char *key; /* K */
+    size_t key_len;
+    unsigned char *xcghash; /* H */
+    size_t xcghash_len;
+    char type; /* X */
+    unsigned char *session_id;
+    size_t session_id_len;
+} KDF_SSHKDF;
+
+static void *kdf_sshkdf_new(void *provctx)
+{
+    KDF_SSHKDF *ctx;
+
+    if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL)
+        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+    ctx-&gt;provctx = provctx;
+    return ctx;
+}
+
+static void kdf_sshkdf_free(void *vctx)
+{
+    KDF_SSHKDF *ctx = (KDF_SSHKDF *)vctx;
+
+    kdf_sshkdf_reset(ctx);
+    OPENSSL_free(ctx);
+}
+
+static void kdf_sshkdf_reset(void *vctx)
+{
+    KDF_SSHKDF *ctx = (KDF_SSHKDF *)vctx;
+
+    EVP_MD_meth_free(ctx-&gt;md);
+    OPENSSL_clear_free(ctx-&gt;key, ctx-&gt;key_len);
+    OPENSSL_clear_free(ctx-&gt;xcghash, ctx-&gt;xcghash_len);
+    OPENSSL_clear_free(ctx-&gt;session_id, ctx-&gt;session_id_len);
+    memset(ctx, 0, sizeof(*ctx));
+}
+
+static int sshkdf_set_membuf(unsigned char **dst, size_t *dst_len,
+                             const OSSL_PARAM *p)
+{
+    OPENSSL_clear_free(*dst, *dst_len);
+    *dst = NULL;
+    return OSSL_PARAM_get_octet_string(p, (void **)dst, 0, dst_len);
+}
+
+static int kdf_sshkdf_derive(void *vctx, unsigned char *key,
+                             size_t keylen)
+{
+    KDF_SSHKDF *ctx = (KDF_SSHKDF *)vctx;
+
+    if (ctx-&gt;md == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
+        return 0;
+    }
+    if (ctx-&gt;key == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_KEY);
+        return 0;
+    }
+    if (ctx-&gt;xcghash == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_XCGHASH);
+        return 0;
+    }
+    if (ctx-&gt;session_id == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_SESSION_ID);
+        return 0;
+    }
+    if (ctx-&gt;type == 0) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_TYPE);
+        return 0;
+    }
+    return SSHKDF(ctx-&gt;md, ctx-&gt;key, ctx-&gt;key_len,
+                  ctx-&gt;xcghash, ctx-&gt;xcghash_len,
+                  ctx-&gt;session_id, ctx-&gt;session_id_len,
+                  ctx-&gt;type, key, keylen);
+}
+
+static int kdf_sshkdf_set_ctx_params(void *vctx, const OSSL_PARAM params[])
+{
+    const OSSL_PARAM *p;
+    KDF_SSHKDF *ctx = vctx;
+    EVP_MD *md;
+    int t;
+    const char *properties = NULL;
+
+    /* Grab search properties, this should be before the digest lookup */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PROPERTIES))
+        != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        properties = p-&gt;data;
+    }
+    /* Handle aliasing of digest parameter names */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_DIGEST)) != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        md = EVP_MD_fetch(PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx), p-&gt;data,
+                          properties);
+        if (md == NULL) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DIGEST);
+            return 0;
+        }
+        EVP_MD_meth_free(ctx-&gt;md);
+        ctx-&gt;md = md;
+    }
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_KEY)) != NULL)
+        if (!sshkdf_set_membuf(&amp;ctx-&gt;key, &amp;ctx-&gt;key_len, p))
+            return 0;
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SSHKDF_XCGHASH))
+        != NULL)
+        if (!sshkdf_set_membuf(&amp;ctx-&gt;xcghash, &amp;ctx-&gt;xcghash_len, p))
+            return 0;
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SSHKDF_SESSION_ID))
+        != NULL)
+        if (!sshkdf_set_membuf(&amp;ctx-&gt;session_id, &amp;ctx-&gt;session_id_len, p))
+            return 0;
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SSHKDF_TYPE))
+        != NULL) {
+        if (p-&gt;data == NULL || p-&gt;data_size == 0)
+            return 0;
+        t = *(unsigned char *)p-&gt;data;
+        if (t &lt; 65 || t &gt; 70) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_VALUE_ERROR);
+            return 0;
+        }
+        ctx-&gt;type = (char)t;
+    }
+    return 1;
+}
+
+static const OSSL_PARAM *kdf_sshkdf_settable_ctx_params(void)
+{
+    static const OSSL_PARAM known_settable_ctx_params[] = {
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_PROPERTIES, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_DIGEST, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_KEY, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_SSHKDF_XCGHASH, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_SSHKDF_SESSION_ID, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_SSHKDF_TYPE, NULL, 0),
+        OSSL_PARAM_END
+    };
+    return known_settable_ctx_params;
+}
+
+static int kdf_sshkdf_get_ctx_params(void *vctx, OSSL_PARAM params[])
+{
+    OSSL_PARAM *p;
+
+    if ((p = OSSL_PARAM_locate(params, OSSL_KDF_PARAM_SIZE)) != NULL)
+        return OSSL_PARAM_set_size_t(p, SIZE_MAX);
+    return -2;
+}
+
+static const OSSL_PARAM *kdf_sshkdf_gettable_ctx_params(void)
+{
+    static const OSSL_PARAM known_gettable_ctx_params[] = {
+        OSSL_PARAM_size_t(OSSL_KDF_PARAM_SIZE, NULL),
+        OSSL_PARAM_END
+    };
+    return known_gettable_ctx_params;
+}
+
+const OSSL_DISPATCH kdf_sshkdf_functions[] = {
+    { OSSL_FUNC_KDF_NEWCTX, (void(*)(void))kdf_sshkdf_new },
+    { OSSL_FUNC_KDF_FREECTX, (void(*)(void))kdf_sshkdf_free },
+    { OSSL_FUNC_KDF_RESET, (void(*)(void))kdf_sshkdf_reset },
+    { OSSL_FUNC_KDF_DERIVE, (void(*)(void))kdf_sshkdf_derive },
+    { OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS,
+      (void(*)(void))kdf_sshkdf_settable_ctx_params },
+    { OSSL_FUNC_KDF_SET_CTX_PARAMS, (void(*)(void))kdf_sshkdf_set_ctx_params },
+    { OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS,
+      (void(*)(void))kdf_sshkdf_gettable_ctx_params },
+    { OSSL_FUNC_KDF_GET_CTX_PARAMS, (void(*)(void))kdf_sshkdf_get_ctx_params },
+    { 0, NULL }
+};
+
+static int SSHKDF(const EVP_MD *evp_md,
+                  const unsigned char *key, size_t key_len,
+                  const unsigned char *xcghash, size_t xcghash_len,
+                  const unsigned char *session_id, size_t session_id_len,
+                  char type, unsigned char *okey, size_t okey_len)
+{
+    EVP_MD_CTX *md = NULL;
+    unsigned char digest[EVP_MAX_MD_SIZE];
+    unsigned int dsize = 0;
+    size_t cursize = 0;
+    int ret = 0;
+
+    md = EVP_MD_CTX_new();
+    if (md == NULL)
+        return 0;
+
+    if (!EVP_DigestInit_ex(md, evp_md, NULL))
+        goto out;
+
+    if (!EVP_DigestUpdate(md, key, key_len))
+        goto out;
+
+    if (!EVP_DigestUpdate(md, xcghash, xcghash_len))
+        goto out;
+
+    if (!EVP_DigestUpdate(md, &amp;type, 1))
+        goto out;
+
+    if (!EVP_DigestUpdate(md, session_id, session_id_len))
+        goto out;
+
+    if (!EVP_DigestFinal_ex(md, digest, &amp;dsize))
+        goto out;
+
+    if (okey_len &lt; dsize) {
+        memcpy(okey, digest, okey_len);
+        ret = 1;
+        goto out;
+    }
+
+    memcpy(okey, digest, dsize);
+
+    for (cursize = dsize; cursize &lt; okey_len; cursize += dsize) {
+
+        if (!EVP_DigestInit_ex(md, evp_md, NULL))
+            goto out;
+
+        if (!EVP_DigestUpdate(md, key, key_len))
+            goto out;
+
+        if (!EVP_DigestUpdate(md, xcghash, xcghash_len))
+            goto out;
+
+        if (!EVP_DigestUpdate(md, okey, cursize))
+            goto out;
+
+        if (!EVP_DigestFinal_ex(md, digest, &amp;dsize))
+            goto out;
+
+        if (okey_len &lt; cursize + dsize) {
+            memcpy(okey + cursize, digest, okey_len - cursize);
+            ret = 1;
+            goto out;
+        }
+
+        memcpy(okey + cursize, digest, dsize);
+    }
+
+    ret = 1;
+
+out:
+    EVP_MD_CTX_free(md);
+    OPENSSL_cleanse(digest, EVP_MAX_MD_SIZE);
+    return ret;
+}
+
diff --git a/crypto/kdf/x942kdf.c b/providers/default/kdfs/x942kdf.c
similarity index 57%
rename from crypto/kdf/x942kdf.c
rename to providers/default/kdfs/x942kdf.c
index ce9ad61035..af2b4a8db4 100644
--- a/crypto/kdf/x942kdf.c
+++ b/providers/default/kdfs/x942kdf.c
@@ -21,21 +21,35 @@
 # include &lt;openssl/kdf.h&gt;
 # include &lt;openssl/x509.h&gt;
 # include &lt;openssl/obj_mac.h&gt;
+# include &lt;openssl/core_names.h&gt;
 # include &quot;internal/cryptlib.h&quot;
+# include &quot;internal/numbers.h&quot;
 # include &quot;internal/evp_int.h&quot;
-# include &quot;kdf_local.h&quot;
+# include &quot;internal/provider_ctx.h&quot;
+# include &quot;internal/providercommonerr.h&quot;
+# include &quot;internal/provider_algs.h&quot;
 
 # define X942KDF_MAX_INLEN (1 &lt;&lt; 30)
 
-struct evp_kdf_impl_st {
-    const EVP_MD *md;
+static OSSL_OP_kdf_newctx_fn x942kdf_new;
+static OSSL_OP_kdf_freectx_fn x942kdf_free;
+static OSSL_OP_kdf_reset_fn x942kdf_reset;
+static OSSL_OP_kdf_derive_fn x942kdf_derive;
+static OSSL_OP_kdf_settable_ctx_params_fn x942kdf_settable_ctx_params;
+static OSSL_OP_kdf_set_ctx_params_fn x942kdf_set_ctx_params;
+static OSSL_OP_kdf_gettable_ctx_params_fn x942kdf_gettable_ctx_params;
+static OSSL_OP_kdf_get_ctx_params_fn x942kdf_get_ctx_params;
+
+typedef struct {
+    void *provctx;
+    EVP_MD *md;
     unsigned char *secret;
     size_t secret_len;
     int cek_nid;
     unsigned char *ukm;
     size_t ukm_len;
     size_t dkm_len;
-};
+} KDF_X942;
 
 /* A table of allowed wrapping algorithms and the associated output lengths */
 static const struct {
@@ -177,7 +191,7 @@ static int x942kdf_hash_kdm(const EVP_MD *kdf_md,
     if (z_len &gt; X942KDF_MAX_INLEN || other_len &gt; X942KDF_MAX_INLEN
             || derived_key_len &gt; X942KDF_MAX_INLEN
             || derived_key_len == 0) {
-        KDFerr(KDF_F_X942KDF_HASH_KDM, KDF_R_BAD_LENGTH);
+        ERR_raise(ERR_LIB_PROV, PROV_R_BAD_LENGTH);
         return 0;
     }
 
@@ -227,181 +241,200 @@ end:
     return ret;
 }
 
-static EVP_KDF_IMPL *x942kdf_new(void)
+static void *x942kdf_new(void *provctx)
 {
-    EVP_KDF_IMPL *impl;
+    KDF_X942 *ctx;
 
-    if ((impl = OPENSSL_zalloc(sizeof(*impl))) == NULL)
-        KDFerr(KDF_F_X942KDF_NEW, ERR_R_MALLOC_FAILURE);
-    return impl;
+    if ((ctx = OPENSSL_zalloc(sizeof(*ctx))) == NULL)
+        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+    ctx-&gt;provctx = provctx;
+    return ctx;
 }
 
-static void x942kdf_reset(EVP_KDF_IMPL *impl)
+static void x942kdf_reset(void *vctx)
 {
-    OPENSSL_clear_free(impl-&gt;secret, impl-&gt;secret_len);
-    OPENSSL_clear_free(impl-&gt;ukm, impl-&gt;ukm_len);
-    memset(impl, 0, sizeof(*impl));
-}
+    KDF_X942 *ctx = (KDF_X942 *)vctx;
 
-static void x942kdf_free(EVP_KDF_IMPL *impl)
-{
-    x942kdf_reset(impl);
-    OPENSSL_free(impl);
+    EVP_MD_meth_free(ctx-&gt;md);
+    OPENSSL_clear_free(ctx-&gt;secret, ctx-&gt;secret_len);
+    OPENSSL_clear_free(ctx-&gt;ukm, ctx-&gt;ukm_len);
+    memset(ctx, 0, sizeof(*ctx));
 }
 
-static int x942kdf_set_buffer(va_list args, unsigned char **out, size_t *out_len)
+static void x942kdf_free(void *vctx)
 {
-    const unsigned char *p;
-    size_t len;
-
-    p = va_arg(args, const unsigned char *);
-    len = va_arg(args, size_t);
-    if (len == 0 || p == NULL)
-        return 1;
-
-    OPENSSL_free(*out);
-    *out = OPENSSL_memdup(p, len);
-    if (*out == NULL)
-        return 0;
+    KDF_X942 *ctx = (KDF_X942 *)vctx;
 
-    *out_len = len;
-    return 1;
+    x942kdf_reset(ctx);
+    OPENSSL_free(ctx);
 }
 
-static int x942kdf_ctrl(EVP_KDF_IMPL *impl, int cmd, va_list args)
+static int x942kdf_set_buffer(unsigned char **out, size_t *out_len,
+                              const OSSL_PARAM *p)
 {
-    const EVP_MD *md;
-    char *alg_str = NULL;
-    size_t i;
-
-    switch (cmd) {
-    case EVP_KDF_CTRL_SET_MD:
-        md = va_arg(args, const EVP_MD *);
-        if (md == NULL)
-            return 0;
-
-        impl-&gt;md = md;
+    if (p-&gt;data_size == 0 || p-&gt;data == NULL)
         return 1;
 
-    case EVP_KDF_CTRL_SET_KEY:
-        return x942kdf_set_buffer(args, &amp;impl-&gt;secret, &amp;impl-&gt;secret_len);
-
-    case EVP_KDF_CTRL_SET_UKM:
-        return x942kdf_set_buffer(args, &amp;impl-&gt;ukm, &amp;impl-&gt;ukm_len);
-
-    case EVP_KDF_CTRL_SET_CEK_ALG:
-        alg_str = va_arg(args, char *);
-        if (alg_str == NULL)
-            return 0;
-        impl-&gt;cek_nid = OBJ_sn2nid(alg_str);
-        for (i = 0; i &lt; (size_t)OSSL_NELEM(kek_algs); ++i) {
-            if (kek_algs[i].nid == impl-&gt;cek_nid) {
-                impl-&gt;dkm_len = kek_algs[i].keklen;
-                return 1;
-            }
-        }
-        KDFerr(KDF_F_X942KDF_CTRL, KDF_R_UNSUPPORTED_CEK_ALG);
-        return 0;
-
-    default:
-        return -2;
-    }
-}
-
-static int x942kdf_ctrl_str(EVP_KDF_IMPL *impl, const char *type,
-                            const char *value)
-{
-    if (strcmp(type, &quot;digest&quot;) == 0)
-        return kdf_md2ctrl(impl, x942kdf_ctrl, EVP_KDF_CTRL_SET_MD, value);
-
-    if (strcmp(type, &quot;secret&quot;) == 0 || strcmp(type, &quot;key&quot;) == 0)
-         return kdf_str2ctrl(impl, x942kdf_ctrl, EVP_KDF_CTRL_SET_KEY,
-                             value);
-
-    if (strcmp(type, &quot;hexsecret&quot;) == 0 || strcmp(type, &quot;hexkey&quot;) == 0)
-        return kdf_hex2ctrl(impl, x942kdf_ctrl, EVP_KDF_CTRL_SET_KEY,
-                            value);
-
-    if (strcmp(type, &quot;ukm&quot;) == 0)
-        return kdf_str2ctrl(impl, x942kdf_ctrl, EVP_KDF_CTRL_SET_UKM,
-                            value);
-
-    if (strcmp(type, &quot;hexukm&quot;) == 0)
-        return kdf_hex2ctrl(impl, x942kdf_ctrl, EVP_KDF_CTRL_SET_UKM,
-                            value);
-
-    if (strcmp(type, &quot;cekalg&quot;) == 0)
-        return kdf_str2ctrl(impl, x942kdf_ctrl, EVP_KDF_CTRL_SET_CEK_ALG,
-                            value);
-
-    return -2;
+    OPENSSL_free(*out);
+    *out = NULL;
+    return OSSL_PARAM_get_octet_string(p, (void **)out, 0, out_len);
 }
 
-static size_t x942kdf_size(EVP_KDF_IMPL *impl)
+static size_t x942kdf_size(KDF_X942 *ctx)
 {
     int len;
 
-    if (impl-&gt;md == NULL) {
-        KDFerr(KDF_F_X942KDF_SIZE, KDF_R_MISSING_MESSAGE_DIGEST);
+    if (ctx-&gt;md == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
         return 0;
     }
-    len = EVP_MD_size(impl-&gt;md);
+    len = EVP_MD_size(ctx-&gt;md);
     return (len &lt;= 0) ? 0 : (size_t)len;
 }
 
-static int x942kdf_derive(EVP_KDF_IMPL *impl, unsigned char *key, size_t keylen)
+static int x942kdf_derive(void *vctx, unsigned char *key, size_t keylen)
 {
+    KDF_X942 *ctx = (KDF_X942 *)vctx;
     int ret = 0;
     unsigned char *ctr;
     unsigned char *der = NULL;
     size_t der_len = 0;
 
-    if (impl-&gt;secret == NULL) {
-        KDFerr(KDF_F_X942KDF_DERIVE, KDF_R_MISSING_SECRET);
+    if (ctx-&gt;secret == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_SECRET);
         return 0;
     }
-    if (impl-&gt;md == NULL) {
-        KDFerr(KDF_F_X942KDF_DERIVE, KDF_R_MISSING_MESSAGE_DIGEST);
+    if (ctx-&gt;md == NULL) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_MESSAGE_DIGEST);
         return 0;
     }
-    if (impl-&gt;cek_nid == NID_undef) {
-        KDFerr(KDF_F_X942KDF_DERIVE, KDF_R_MISSING_CEK_ALG);
+    if (ctx-&gt;cek_nid == NID_undef) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_CEK_ALG);
         return 0;
     }
-    if (impl-&gt;ukm != NULL &amp;&amp; impl-&gt;ukm_len &gt;= X942KDF_MAX_INLEN) {
+    if (ctx-&gt;ukm != NULL &amp;&amp; ctx-&gt;ukm_len &gt;= X942KDF_MAX_INLEN) {
         /*
          * Note the ukm length MUST be 512 bits.
          * For backwards compatibility the old check is being done.
          */
-        KDFerr(KDF_F_X942KDF_DERIVE, KDF_R_INAVLID_UKM_LEN);
+        ERR_raise(ERR_LIB_PROV, PROV_R_INAVLID_UKM_LENGTH);
         return 0;
     }
-    if (keylen != impl-&gt;dkm_len) {
-        KDFerr(KDF_F_X942KDF_DERIVE, KDF_R_MISSING_CEK_ALG);
+    if (keylen != ctx-&gt;dkm_len) {
+        ERR_raise(ERR_LIB_PROV, PROV_R_MISSING_CEK_ALG);
         return 0;
     }
     /* generate the otherinfo der */
-    if (!x942_encode_otherinfo(impl-&gt;cek_nid, impl-&gt;dkm_len,
-                               impl-&gt;ukm, impl-&gt;ukm_len,
+    if (!x942_encode_otherinfo(ctx-&gt;cek_nid, ctx-&gt;dkm_len,
+                               ctx-&gt;ukm, ctx-&gt;ukm_len,
                                &amp;der, &amp;der_len, &amp;ctr)) {
-        KDFerr(KDF_F_X942KDF_DERIVE, KDF_R_BAD_ENCODING);
+        ERR_raise(ERR_LIB_PROV, PROV_R_BAD_ENCODING);
         return 0;
     }
-    ret = x942kdf_hash_kdm(impl-&gt;md, impl-&gt;secret, impl-&gt;secret_len,
+    ret = x942kdf_hash_kdm(ctx-&gt;md, ctx-&gt;secret, ctx-&gt;secret_len,
                            der, der_len, ctr, key, keylen);
     OPENSSL_free(der);
     return ret;
 }
 
-const EVP_KDF x942_kdf_meth = {
-    EVP_KDF_X942,
-    x942kdf_new,
-    x942kdf_free,
-    x942kdf_reset,
-    x942kdf_ctrl,
-    x942kdf_ctrl_str,
-    x942kdf_size,
-    x942kdf_derive
+static int x942kdf_set_ctx_params(void *vctx, const OSSL_PARAM params[])
+{
+    const OSSL_PARAM *p;
+    KDF_X942 *ctx = vctx;
+    EVP_MD *md;
+    const char *properties = NULL;
+    size_t i;
+
+    /* Grab search properties, this should be before the digest lookup */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PROPERTIES))
+        != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        properties = p-&gt;data;
+    }
+    /* Handle aliasing of digest parameter names */
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_DIGEST)) != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        md = EVP_MD_fetch(PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx), p-&gt;data,
+                          properties);
+        if (md == NULL) {
+            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DIGEST);
+            return 0;
+        }
+        EVP_MD_meth_free(ctx-&gt;md);
+        ctx-&gt;md = md;
+    }
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_SECRET)) != NULL
+        || (p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_KEY)) != NULL)
+        if (!x942kdf_set_buffer(&amp;ctx-&gt;secret, &amp;ctx-&gt;secret_len, p))
+            return 0;
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_UKM)) != NULL)
+        if (!x942kdf_set_buffer(&amp;ctx-&gt;ukm, &amp;ctx-&gt;ukm_len, p))
+            return 0;
+
+    if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_CEK_ALG)) != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        ctx-&gt;cek_nid = OBJ_sn2nid(p-&gt;data);
+        for (i = 0; i &lt; OSSL_NELEM(kek_algs); i++)
+            if (kek_algs[i].nid == ctx-&gt;cek_nid)
+                goto cek_found;
+        ERR_raise(ERR_LIB_PROV, PROV_R_UNSUPPORTED_CEK_ALG);
+        return 0;
+cek_found:
+        ctx-&gt;dkm_len = kek_algs[i].keklen;
+    }
+    return 1;
+}
+
+static const OSSL_PARAM *x942kdf_settable_ctx_params(void)
+{
+    static const OSSL_PARAM known_settable_ctx_params[] = {
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_PROPERTIES, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_DIGEST, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_SECRET, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_KEY, NULL, 0),
+        OSSL_PARAM_octet_string(OSSL_KDF_PARAM_UKM, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_CEK_ALG, NULL, 0),
+        OSSL_PARAM_END
+    };
+    return known_settable_ctx_params;
+}
+
+static int x942kdf_get_ctx_params(void *vctx, OSSL_PARAM params[])
+{
+    KDF_X942 *ctx = (KDF_X942 *)vctx;
+    OSSL_PARAM *p;
+
+    if ((p = OSSL_PARAM_locate(params, OSSL_KDF_PARAM_SIZE)) != NULL)
+        return OSSL_PARAM_set_size_t(p, x942kdf_size(ctx));
+    return -2;
+}
+
+static const OSSL_PARAM *x942kdf_gettable_ctx_params(void)
+{
+    static const OSSL_PARAM known_gettable_ctx_params[] = {
+        OSSL_PARAM_size_t(OSSL_KDF_PARAM_SIZE, NULL),
+        OSSL_PARAM_END
+    };
+    return known_gettable_ctx_params;
+}
+
+const OSSL_DISPATCH kdf_x942_kdf_functions[] = {
+    { OSSL_FUNC_KDF_NEWCTX, (void(*)(void))x942kdf_new },
+    { OSSL_FUNC_KDF_FREECTX, (void(*)(void))x942kdf_free },
+    { OSSL_FUNC_KDF_RESET, (void(*)(void))x942kdf_reset },
+    { OSSL_FUNC_KDF_DERIVE, (void(*)(void))x942kdf_derive },
+    { OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS,
+      (void(*)(void))x942kdf_settable_ctx_params },
+    { OSSL_FUNC_KDF_SET_CTX_PARAMS, (void(*)(void))x942kdf_set_ctx_params },
+    { OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS,
+      (void(*)(void))x942kdf_gettable_ctx_params },
+    { OSSL_FUNC_KDF_GET_CTX_PARAMS, (void(*)(void))x942kdf_get_ctx_params },
+    { 0, NULL }
 };
 
 #endif /* OPENSSL_NO_CMS */
diff --git a/providers/fips/fipsprov.c b/providers/fips/fipsprov.c
index 000bf73672..59cd4080f4 100644
--- a/providers/fips/fipsprov.c
+++ b/providers/fips/fipsprov.c
@@ -15,6 +15,7 @@
 #include &lt;openssl/params.h&gt;
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/evp.h&gt;
+#include &lt;openssl/kdf.h&gt;
 
 /* TODO(3.0): Needed for dummy_evp_call(). To be removed */
 #include &lt;openssl/sha.h&gt;
@@ -121,6 +122,7 @@ static int dummy_evp_call(void *provctx)
     OPENSSL_CTX *libctx = PROV_LIBRARY_CONTEXT_OF(provctx);
     EVP_MD_CTX *ctx = EVP_MD_CTX_new();
     EVP_MD *sha256 = EVP_MD_fetch(libctx, &quot;SHA256&quot;, NULL);
+    EVP_KDF *kdf = EVP_KDF_fetch(libctx, &quot;pbkdf2&quot;, NULL);
     char msg[] = &quot;Hello World!&quot;;
     const unsigned char exptd[] = {
         0x7f, 0x83, 0xb1, 0x65, 0x7f, 0xf1, 0xfc, 0x53, 0xb9, 0x2d, 0xc1, 0x81,
@@ -138,7 +140,7 @@ static int dummy_evp_call(void *provctx)
     EC_KEY *key = NULL;
 #endif
 
-    if (ctx == NULL || sha256 == NULL || drbg == NULL)
+    if (ctx == NULL || sha256 == NULL || drbg == NULL || kdf == NULL)
         goto err;
 
     if (!EVP_DigestInit_ex(ctx, sha256, NULL))
@@ -185,6 +187,7 @@ static int dummy_evp_call(void *provctx)
     BN_CTX_end(bnctx);
     BN_CTX_free(bnctx);
 
+    EVP_KDF_free(kdf);
     EVP_MD_CTX_free(ctx);
     EVP_MD_free(sha256);
 
@@ -342,6 +345,14 @@ static const OSSL_ALGORITHM fips_macs[] = {
     { NULL, NULL, NULL }
 };
 
+static const OSSL_ALGORITHM fips_kdfs[] = {
+    { &quot;HKDF&quot;, &quot;fips=yes&quot;, kdf_hkdf_functions },
+    { &quot;SSKDF&quot;, &quot;fips=yes&quot;, kdf_sskdf_functions },
+    { &quot;PBKDF2&quot;, &quot;fips=yes&quot;, kdf_pbkdf2_functions },
+    { &quot;TLS1-PRF&quot;, &quot;fips=yes&quot;, kdf_tls1_prf_functions },
+   { NULL, NULL, NULL }
+};
+
 static const OSSL_ALGORITHM *fips_query(OSSL_PROVIDER *prov,
                                          int operation_id,
                                          int *no_cache)
@@ -354,6 +365,8 @@ static const OSSL_ALGORITHM *fips_query(OSSL_PROVIDER *prov,
         return fips_ciphers;
     case OSSL_OP_MAC:
         return fips_macs;
+    case OSSL_OP_KDF:
+        return fips_kdfs;
     }
     return NULL;
 }
diff --git a/ssl/t1_enc.c b/ssl/t1_enc.c
index 31290a409a..4419d3f10b 100644
--- a/ssl/t1_enc.c
+++ b/ssl/t1_enc.c
@@ -18,6 +18,7 @@
 #include &lt;openssl/kdf.h&gt;
 #include &lt;openssl/rand.h&gt;
 #include &lt;openssl/obj_mac.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &lt;openssl/trace.h&gt;
 
 /* seed1 through seed5 are concatenated */
@@ -31,8 +32,10 @@ static int tls1_PRF(SSL *s,
                     unsigned char *out, size_t olen, int fatal)
 {
     const EVP_MD *md = ssl_prf_md(s);
+    EVP_KDF *kdf;
     EVP_KDF_CTX *kctx = NULL;
-    int ret = 0;
+    OSSL_PARAM params[8], *p = params;
+    const char *mdname = EVP_MD_name(md);
 
     if (md == NULL) {
         /* Should never happen */
@@ -43,35 +46,43 @@ static int tls1_PRF(SSL *s,
             SSLerr(SSL_F_TLS1_PRF, ERR_R_INTERNAL_ERROR);
         return 0;
     }
-    kctx = EVP_KDF_CTX_new_id(EVP_PKEY_TLS1_PRF);
-    if (kctx == NULL
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, md) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_TLS_SECRET,
-                        sec, (size_t)slen) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_TLS_SEED,
-                        seed1, (size_t)seed1_len) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_TLS_SEED,
-                        seed2, (size_t)seed2_len) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_TLS_SEED,
-                        seed3, (size_t)seed3_len) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_TLS_SEED,
-                        seed4, (size_t)seed4_len) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_TLS_SEED,
-                        seed5, (size_t)seed5_len) &lt;= 0
-        || EVP_KDF_derive(kctx, out, olen) &lt;= 0) {
-        if (fatal)
-            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS1_PRF,
-                     ERR_R_INTERNAL_ERROR);
-        else
-            SSLerr(SSL_F_TLS1_PRF, ERR_R_INTERNAL_ERROR);
+    kdf = EVP_KDF_fetch(NULL, SN_tls1_prf, NULL);
+    if (kdf == NULL)
+        goto err;
+    kctx = EVP_KDF_CTX_new(kdf);
+    EVP_KDF_free(kdf);
+    if (kctx == NULL)
         goto err;
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)mdname, strlen(mdname) + 1);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SECRET,
+                                             (unsigned char *)sec,
+                                             (size_t)slen);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SEED,
+                                             (void *)seed1, (size_t)seed1_len);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SEED,
+                                             (void *)seed2, (size_t)seed2_len);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SEED,
+                                             (void *)seed3, (size_t)seed3_len);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SEED,
+                                             (void *)seed4, (size_t)seed4_len);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SEED,
+                                             (void *)seed5, (size_t)seed5_len);
+    *p = OSSL_PARAM_construct_end();
+    if (EVP_KDF_CTX_set_params(kctx, params)
+            &amp;&amp; EVP_KDF_derive(kctx, out, olen)) {
+        EVP_KDF_CTX_free(kctx);
+        return 1;
     }
 
-    ret = 1;
-
  err:
+    if (fatal)
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS1_PRF,
+                 ERR_R_INTERNAL_ERROR);
+    else
+        SSLerr(SSL_F_TLS1_PRF, ERR_R_INTERNAL_ERROR);
     EVP_KDF_CTX_free(kctx);
-    return ret;
+    return 0;
 }
 
 static int tls1_generate_key_block(SSL *s, unsigned char *km, size_t num)
diff --git a/ssl/tls13_enc.c b/ssl/tls13_enc.c
index a238d6e1c6..f7c472d1fb 100644
--- a/ssl/tls13_enc.c
+++ b/ssl/tls13_enc.c
@@ -12,6 +12,7 @@
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/kdf.h&gt;
+#include &lt;openssl/core_names.h&gt;
 
 #define TLS13_MAX_LABEL_LEN     249
 
@@ -35,7 +36,11 @@ int tls13_hkdf_expand(SSL *s, const EVP_MD *md, const unsigned char *secret,
 #else
     static const unsigned char label_prefix[] = &quot;tls13 &quot;;
 #endif
-    EVP_KDF_CTX *kctx = EVP_KDF_CTX_new_id(EVP_PKEY_HKDF);
+    EVP_KDF *kdf = EVP_KDF_fetch(NULL, SN_hkdf, NULL);
+    EVP_KDF_CTX *kctx;
+    OSSL_PARAM params[5], *p = params;
+    int mode = EVP_PKEY_HKDEF_MODE_EXPAND_ONLY;
+    const char *mdname = EVP_MD_name(md);
     int ret;
     size_t hkdflabellen;
     size_t hashlen;
@@ -49,6 +54,8 @@ int tls13_hkdf_expand(SSL *s, const EVP_MD *md, const unsigned char *secret,
                             + 1 + EVP_MAX_MD_SIZE];
     WPACKET pkt;
 
+    kctx = EVP_KDF_CTX_new(kdf);
+    EVP_KDF_free(kdf);
     if (kctx == NULL)
         return 0;
 
@@ -88,12 +95,16 @@ int tls13_hkdf_expand(SSL *s, const EVP_MD *md, const unsigned char *secret,
         return 0;
     }
 
-    ret = EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_HKDF_MODE,
-                       EVP_PKEY_HKDEF_MODE_EXPAND_ONLY) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, md) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, secret, hashlen) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_HKDF_INFO,
-                        hkdflabel, hkdflabellen) &lt;= 0
+    *p++ = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_MODE, &amp;mode);
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)mdname, strlen(mdname) + 1);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
+                                             (unsigned char *)secret, hashlen);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+                                             hkdflabel, hkdflabellen);
+    *p++ = OSSL_PARAM_construct_end();
+
+    ret = EVP_KDF_CTX_set_params(kctx, params) &lt;= 0
         || EVP_KDF_derive(kctx, out, outlen) &lt;= 0;
 
     EVP_KDF_CTX_free(kctx);
@@ -171,7 +182,11 @@ int tls13_generate_secret(SSL *s, const EVP_MD *md,
     size_t mdlen, prevsecretlen;
     int mdleni;
     int ret;
-    EVP_KDF_CTX *kctx = EVP_KDF_CTX_new_id(EVP_PKEY_HKDF);
+    EVP_KDF *kdf;
+    EVP_KDF_CTX *kctx;
+    OSSL_PARAM params[5], *p = params;
+    int mode = EVP_PKEY_HKDEF_MODE_EXTRACT_ONLY;
+    const char *mdname = EVP_MD_name(md);
 #ifdef CHARSET_EBCDIC
     static const char derived_secret_label[] = { 0x64, 0x65, 0x72, 0x69, 0x76, 0x65, 0x64, 0x00 };
 #else
@@ -179,6 +194,9 @@ int tls13_generate_secret(SSL *s, const EVP_MD *md,
 #endif
     unsigned char preextractsec[EVP_MAX_MD_SIZE];
 
+    kdf = EVP_KDF_fetch(NULL, SN_hkdf, NULL);
+    kctx = EVP_KDF_CTX_new(kdf);
+    EVP_KDF_free(kdf);
     if (kctx == NULL) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS13_GENERATE_SECRET,
                  ERR_R_INTERNAL_ERROR);
@@ -232,12 +250,18 @@ int tls13_generate_secret(SSL *s, const EVP_MD *md,
         prevsecretlen = mdlen;
     }
 
-    ret = EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_HKDF_MODE,
-                       EVP_PKEY_HKDEF_MODE_EXTRACT_ONLY) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, md) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, insecret, insecretlen) &lt;= 0
-        || EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT,
-                        prevsecret, prevsecretlen) &lt;= 0
+    *p++ = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_MODE, &amp;mode);
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)mdname, strlen(mdname) + 1);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
+                                             (unsigned char *)insecret,
+                                             insecretlen);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                             (unsigned char *)prevsecret,
+                                             prevsecretlen);
+    *p++ = OSSL_PARAM_construct_end();
+
+    ret = EVP_KDF_CTX_set_params(kctx, params) &lt;= 0
         || EVP_KDF_derive(kctx, outsecret, mdlen) &lt;= 0;
 
     if (ret != 0)
diff --git a/test/evp_kdf_test.c b/test/evp_kdf_test.c
index 1a131a7995..abc4dccd46 100644
--- a/test/evp_kdf_test.c
+++ b/test/evp_kdf_test.c
@@ -18,27 +18,39 @@
 #include &lt;openssl/core_names.h&gt;
 #include &quot;testutil.h&quot;
 
+static EVP_KDF_CTX *get_kdfbyname(const char *name)
+{
+    EVP_KDF *kdf = EVP_KDF_fetch(NULL, name, NULL);
+    EVP_KDF_CTX *kctx = EVP_KDF_CTX_new(kdf);
+
+    EVP_KDF_free(kdf);
+    return kctx;
+}
+
 static int test_kdf_tls1_prf(void)
 {
     int ret;
     EVP_KDF_CTX *kctx = NULL;
-    const EVP_KDF *kdf;
     unsigned char out[16];
+    OSSL_PARAM params[4], *p = params;
     static const unsigned char expected[sizeof(out)] = {
         0x8e, 0x4d, 0x93, 0x25, 0x30, 0xd7, 0x65, 0xa0,
         0xaa, 0xe9, 0x74, 0xc3, 0x04, 0x73, 0x5e, 0xcc
     };
 
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)&quot;sha256&quot;, sizeof(&quot;sha256&quot;));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SECRET,
+                                             (unsigned char *)&quot;secret&quot;,
+                                             (size_t)6);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SEED,
+                                             (unsigned char *)&quot;seed&quot;,
+                                             (size_t)4);
+    *p = OSSL_PARAM_construct_end();
+
     ret =
-        TEST_ptr(kdf = EVP_get_kdfbyname(SN_tls1_prf))
-        &amp;&amp; TEST_ptr(kctx = EVP_KDF_CTX_new(kdf))
-        &amp;&amp; TEST_ptr_eq(EVP_KDF_CTX_kdf(kctx), kdf)
-        &amp;&amp; TEST_str_eq(EVP_KDF_name(kdf), SN_tls1_prf)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_TLS_SECRET,
-                                    &quot;secret&quot;, (size_t)6), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_TLS_SEED, &quot;seed&quot;,
-                                    (size_t)4), 0)
+        TEST_ptr(kctx = get_kdfbyname(SN_tls1_prf))
+        &amp;&amp; TEST_true(EVP_KDF_CTX_set_params(kctx, params))
         &amp;&amp; TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
         &amp;&amp; TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));
 
@@ -51,19 +63,24 @@ static int test_kdf_hkdf(void)
     int ret;
     EVP_KDF_CTX *kctx;
     unsigned char out[10];
+    OSSL_PARAM params[5], *p = params;
     static const unsigned char expected[sizeof(out)] = {
         0x2a, 0xc4, 0x36, 0x9f, 0x52, 0x59, 0x96, 0xf8, 0xde, 0x13
     };
 
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)&quot;sha256&quot;, sizeof(&quot;sha256&quot;));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                             (unsigned char *)&quot;salt&quot;, 4);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,
+                                             (unsigned char *)&quot;secret&quot;, 6);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO,
+                                             (unsigned char *)&quot;label&quot;, 5);
+    *p = OSSL_PARAM_construct_end();
+
     ret =
-        TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_HKDF))
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT, &quot;salt&quot;,
-                                    (size_t)4), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, &quot;secret&quot;,
-                                    (size_t)6), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_ADD_HKDF_INFO, &quot;label&quot;,
-                                    (size_t)5), 0)
+        TEST_ptr(kctx = get_kdfbyname(SN_hkdf))
+        &amp;&amp; TEST_true(EVP_KDF_CTX_set_params(kctx, params))
         &amp;&amp; TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
         &amp;&amp; TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));
 
@@ -73,10 +90,13 @@ static int test_kdf_hkdf(void)
 
 static int test_kdf_pbkdf2(void)
 {
-    int ret;
+    int ret = 0;
     EVP_KDF_CTX *kctx;
     unsigned char out[25];
     size_t len = 0;
+    unsigned int iterations = 4096;
+    int mode = 0;
+    OSSL_PARAM params[6], *p = params;
     const unsigned char expected[sizeof(out)] = {
         0x34, 0x8c, 0x89, 0xdb, 0xcb, 0xd3, 0x2b, 0x2f,
         0x32, 0xd8, 0x14, 0xb8, 0x11, 0x6e, 0x84, 0xcf,
@@ -87,46 +107,55 @@ static int test_kdf_pbkdf2(void)
     if (sizeof(len) &gt; 32)
         len = SIZE_MAX;
 
-    ret = TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_PBKDF2))
-          &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PASS,
-                                      &quot;passwordPASSWORDpassword&quot;,
-                                      (size_t)24), 0)
-          &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT,
-                                      &quot;saltSALTsaltSALTsaltSALTsaltSALTsalt&quot;,
-                                      (size_t)36), 0)
-          &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_ITER, 4096), 0)
-          &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()),
-                         0)
-          &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE,
-                                            0), 0)
-          &amp;&amp; TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
-          &amp;&amp; TEST_mem_eq(out, sizeof(out), expected, sizeof(expected))
-          /* A key length that is too small should fail */
-          &amp;&amp; TEST_int_eq(EVP_KDF_derive(kctx, out, 112 / 8 - 1), 0)
-          /* A key length that is too large should fail */
-          &amp;&amp; (len == 0 || TEST_int_eq(EVP_KDF_derive(kctx, out, len), 0))
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_PASSWORD,
+                                             (unsigned char *)
+                                                &quot;passwordPASSWORDpassword&quot;, 24);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                             (unsigned char *)
+                                                &quot;saltSALTsaltSALTsaltSALTsaltSALTsalt&quot;,
+                                                36);
+    *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_ITER, &amp;iterations);
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                             (char *)&quot;sha256&quot;, 7);
+    *p++ = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_PKCS5, &amp;mode);
+    *p = OSSL_PARAM_construct_end();
+
+    if (!TEST_ptr(kctx = get_kdfbyname(LN_id_pbkdf2))
+        || !TEST_true(EVP_KDF_CTX_set_params(kctx, params))
+        || !TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
+        || !TEST_mem_eq(out, sizeof(out), expected, sizeof(expected))
+        || !TEST_true(EVP_KDF_CTX_set_params(kctx, params))
+        /* A key length that is too small should fail */
+        || !TEST_int_eq(EVP_KDF_derive(kctx, out, 112 / 8 - 1), 0)
+        /* A key length that is too large should fail */
+        || (len != 0 &amp;&amp; !TEST_int_eq(EVP_KDF_derive(kctx, out, len), 0)))
+        goto err;
+#if 0
+/* TODO */
           /* Salt length less than 128 bits should fail */
-          &amp;&amp; TEST_int_eq(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT,
+          || TEST_int_eq(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT,
                                       &quot;123456781234567&quot;,
                                       (size_t)15), 0)
           /* A small iteration count should fail */
-          &amp;&amp; TEST_int_eq(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_ITER, 1), 0)
-          &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE,
+          || TEST_int_eq(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_ITER, 1), 0)
+          || TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE,
                                       1), 0)
           /* Small salts will pass if the &quot;pkcs5&quot; mode is enabled */
-          &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT,
+          || TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT,
                                       &quot;123456781234567&quot;,
                                       (size_t)15), 0)
           /* A small iteration count will pass if &quot;pkcs5&quot; mode is enabled */
-          &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_ITER, 1), 0)
+          || TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_ITER, 1), 0)
           /*
            * If the &quot;pkcs5&quot; mode is disabled then the small salt and iter will
            * fail when the derive gets called.
            */
-          &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE,
+          || TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PBKDF2_PKCS5_MODE,
                                       0), 0)
-          &amp;&amp; TEST_int_eq(EVP_KDF_derive(kctx, out, sizeof(out)), 0);
-
+          || TEST_int_eq(EVP_KDF_derive(kctx, out, sizeof(out)), 0);
+#endif
+    ret = 1;
+err:
     EVP_KDF_CTX_free(kctx);
     return ret;
 }
@@ -136,7 +165,9 @@ static int test_kdf_scrypt(void)
 {
     int ret;
     EVP_KDF_CTX *kctx;
+    OSSL_PARAM params[7], *p = params;
     unsigned char out[64];
+    unsigned int nu = 1024, ru = 8, pu = 16, maxmem = 16;
     static const unsigned char expected[sizeof(out)] = {
         0xfd, 0xba, 0xbe, 0x1c, 0x9d, 0x34, 0x72, 0x00,
         0x78, 0x56, 0xe7, 0x19, 0x0d, 0x01, 0xe9, 0xfe,
@@ -148,24 +179,23 @@ static int test_kdf_scrypt(void)
         0x83, 0x60, 0xcb, 0xdf, 0xa2, 0xcc, 0x06, 0x40
     };
 
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_PASSWORD,
+                                             (char *)&quot;password&quot;, 8);
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,
+                                             (char *)&quot;NaCl&quot;, 4);
+    *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_SCRYPT_N, &amp;nu);
+    *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_SCRYPT_R, &amp;ru);
+    *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_SCRYPT_P, &amp;pu);
+    *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_SCRYPT_MAXMEM, &amp;maxmem);
+    *p = OSSL_PARAM_construct_end();
+
     ret =
-        TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_SCRYPT))
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_PASS, &quot;password&quot;,
-                                    (size_t)8), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT, &quot;NaCl&quot;,
-                                    (size_t)4), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_N,
-                                    (uint64_t)1024), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_R,
-                                    (uint32_t)8), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SCRYPT_P,
-                                    (uint32_t)16), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MAXMEM_BYTES,
-                                    (uint64_t)16), 0)
-        /* failure test */
-        &amp;&amp; TEST_int_le(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MAXMEM_BYTES,
-                                    (uint64_t)(10 * 1024 * 1024)), 0)
+        TEST_ptr(kctx = get_kdfbyname(SN_id_scrypt))
+        &amp;&amp; TEST_true(EVP_KDF_CTX_set_params(kctx, params))
+        /* failure test *//*
+        &amp;&amp; TEST_int_le(EVP_KDF_derive(kctx, out, sizeof(out)), 0)*/
+        &amp;&amp; TEST_true(OSSL_PARAM_set_uint(p - 1, 10 * 1024 * 1024))
+        &amp;&amp; TEST_true(EVP_KDF_CTX_set_params(kctx, p - 1))
         &amp;&amp; TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
         &amp;&amp; TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));
 
@@ -177,15 +207,16 @@ static int test_kdf_scrypt(void)
 static int test_kdf_ss_hash(void)
 {
     int ret;
-    EVP_KDF_CTX *kctx = NULL;
+    EVP_KDF_CTX *kctx;
+    OSSL_PARAM params[4], *p = params;
     unsigned char out[14];
-    static const unsigned char z[] = {
+    static unsigned char z[] = {
         0x6d,0xbd,0xc2,0x3f,0x04,0x54,0x88,0xe4,0x06,0x27,0x57,0xb0,0x6b,0x9e,
         0xba,0xe1,0x83,0xfc,0x5a,0x59,0x46,0xd8,0x0d,0xb9,0x3f,0xec,0x6f,0x62,
         0xec,0x07,0xe3,0x72,0x7f,0x01,0x26,0xae,0xd1,0x2c,0xe4,0xb2,0x62,0xf4,
         0x7d,0x48,0xd5,0x42,0x87,0xf8,0x1d,0x47,0x4c,0x7c,0x3b,0x18,0x50,0xe9
     };
-    static const unsigned char other[] = {
+    static unsigned char other[] = {
         0xa1,0xb2,0xc3,0xd4,0xe5,0x43,0x41,0x56,0x53,0x69,0x64,0x3c,0x83,0x2e,
         0x98,0x49,0xdc,0xdb,0xa7,0x1e,0x9a,0x31,0x39,0xe6,0x06,0xe0,0x95,0xde,
         0x3c,0x26,0x4a,0x66,0xe9,0x8a,0x16,0x58,0x54,0xcd,0x07,0x98,0x9b,0x1e,
@@ -195,12 +226,16 @@ static int test_kdf_ss_hash(void)
         0xa4,0x62,0xde,0x16,0xa8,0x9d,0xe8,0x46,0x6e,0xf5,0x46,0x0b,0x47,0xb8
     };
 
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)&quot;sha224&quot;, sizeof(&quot;sha224&quot;));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY, z, sizeof(z));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO, other,
+                                             sizeof(other));
+    *p = OSSL_PARAM_construct_end();
+
     ret =
-        TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_SS))
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha224()), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, z, sizeof(z)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SSKDF_INFO, other,
-                                    sizeof(other)), 0)
+        TEST_ptr(kctx = get_kdfbyname(SN_sskdf))
+        &amp;&amp; TEST_true(EVP_KDF_CTX_set_params(kctx, params))
         &amp;&amp; TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
         &amp;&amp; TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));
 
@@ -211,14 +246,15 @@ static int test_kdf_ss_hash(void)
 static int test_kdf_x963(void)
 {
     int ret;
-    EVP_KDF_CTX *kctx = NULL;
+    EVP_KDF_CTX *kctx;
+    OSSL_PARAM params[4], *p = params;
     unsigned char out[1024 / 8];
     /*
      * Test data from <A HREF="https://csrc.nist.gov/CSRC/media/Projects/">https://csrc.nist.gov/CSRC/media/Projects/</A>
      *  Cryptographic-Algorithm-Validation-Program/documents/components/
      *  800-135testvectors/ansx963_2001.zip
      */
-    static const unsigned char z[] = {
+    static unsigned char z[] = {
         0x00, 0xaa, 0x5b, 0xb7, 0x9b, 0x33, 0xe3, 0x89, 0xfa, 0x58, 0xce, 0xad,
         0xc0, 0x47, 0x19, 0x7f, 0x14, 0xe7, 0x37, 0x12, 0xf4, 0x52, 0xca, 0xa9,
         0xfc, 0x4c, 0x9a, 0xdb, 0x36, 0x93, 0x48, 0xb8, 0x15, 0x07, 0x39, 0x2f,
@@ -226,7 +262,7 @@ static int test_kdf_x963(void)
         0x44, 0xe4, 0x4a, 0x1b, 0x55, 0xb1, 0x40, 0x47, 0x47, 0xa9, 0xe2, 0xe7,
         0x53, 0xf5, 0x5e, 0xf0, 0x5a, 0x2d
     };
-    static const unsigned char shared[] = {
+    static unsigned char shared[] = {
         0xe3, 0xb5, 0xb4, 0xc1, 0xb0, 0xd5, 0xcf, 0x1d, 0x2b, 0x3a, 0x2f, 0x99,
         0x37, 0x89, 0x5d, 0x31
     };
@@ -244,12 +280,16 @@ static int test_kdf_x963(void)
         0xab, 0x87, 0xf9, 0x66, 0x1c, 0x3e, 0x88, 0x16
     };
 
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)&quot;sha512&quot;, sizeof(&quot;sha512&quot;));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY, z, sizeof(z));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO, shared,
+                                             sizeof(shared));
+    *p = OSSL_PARAM_construct_end();
+
     ret =
-        TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_X963))
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha512()), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, z, sizeof(z)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SHARED_INFO, shared,
-                                    sizeof(shared)), 0)
+        TEST_ptr(kctx = get_kdfbyname(SN_x963kdf))
+        &amp;&amp; TEST_true(EVP_KDF_CTX_set_params(kctx, params))
         &amp;&amp; TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
         &amp;&amp; TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));
 
@@ -261,14 +301,15 @@ static int test_kdf_ss_hmac(void)
 {
     int ret;
     EVP_KDF_CTX *kctx;
+    OSSL_PARAM params[6], *p = params;
     unsigned char out[16];
-    static const unsigned char z[] = {
+    static unsigned char z[] = {
         0xb7,0x4a,0x14,0x9a,0x16,0x15,0x46,0xf8,0xc2,0x0b,0x06,0xac,0x4e,0xd4
     };
-    static const unsigned char other[] = {
+    static unsigned char other[] = {
         0x34,0x8a,0x37,0xa2,0x7e,0xf1,0x28,0x2f,0x5f,0x02,0x0d,0xcc
     };
-    static const unsigned char salt[] = {
+    static unsigned char salt[] = {
         0x36,0x38,0x27,0x1c,0xcd,0x68,0xa2,0x5d,0xc2,0x4e,0xcd,0xdd,0x39,0xef,
         0x3f,0x89
     };
@@ -277,16 +318,21 @@ static int test_kdf_ss_hmac(void)
         0x1c,0xa3
     };
 
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MAC,
+                                            (char *)OSSL_MAC_NAME_HMAC,
+                                            sizeof(OSSL_MAC_NAME_HMAC));
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)&quot;sha256&quot;, sizeof(&quot;sha256&quot;));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY, z, sizeof(z));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO, other,
+                                             sizeof(other));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT, salt,
+                                             sizeof(salt));
+    *p = OSSL_PARAM_construct_end();
+
     ret =
-        TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_SS))
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MAC,
-                                    OSSL_MAC_NAME_HMAC), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD,  EVP_sha256()), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, z, sizeof(z)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SSKDF_INFO, other,
-                                    sizeof(other)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT, salt,
-                                    sizeof(salt)), 0)
+        TEST_ptr(kctx = get_kdfbyname(SN_sskdf))
+        &amp;&amp; TEST_true(EVP_KDF_CTX_set_params(kctx, params))
         &amp;&amp; TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
         &amp;&amp; TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));
 
@@ -298,14 +344,16 @@ static int test_kdf_ss_kmac(void)
 {
     int ret;
     EVP_KDF_CTX *kctx;
+    OSSL_PARAM params[6], *p = params;
     unsigned char out[64];
-    static const unsigned char z[] = {
+    size_t mac_size = 20;
+    static unsigned char z[] = {
         0xb7,0x4a,0x14,0x9a,0x16,0x15,0x46,0xf8,0xc2,0x0b,0x06,0xac,0x4e,0xd4
     };
-    static const unsigned char other[] = {
+    static unsigned char other[] = {
         0x34,0x8a,0x37,0xa2,0x7e,0xf1,0x28,0x2f,0x5f,0x02,0x0d,0xcc
     };
-    static const unsigned char salt[] = {
+    static unsigned char salt[] = {
         0x36,0x38,0x27,0x1c,0xcd,0x68,0xa2,0x5d,0xc2,0x4e,0xcd,0xdd,0x39,0xef,
         0x3f,0x89
     };
@@ -317,18 +365,20 @@ static int test_kdf_ss_kmac(void)
         0xae,0x15,0x7e,0x1d,0xe8,0x14,0x98,0x03
     };
 
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MAC,
+                                            (char *)OSSL_MAC_NAME_KMAC128,
+                                            sizeof(OSSL_MAC_NAME_KMAC128));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY, z, sizeof(z));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_INFO, other,
+                                             sizeof(other));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT, salt,
+                                             sizeof(salt));
+    *p++ = OSSL_PARAM_construct_size_t(OSSL_KDF_PARAM_MAC_SIZE, &amp;mac_size);
+    *p = OSSL_PARAM_construct_end();
+
     ret =
-        TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_SS))
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MAC,
-                                    OSSL_MAC_NAME_KMAC128), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, z,
-                                    sizeof(z)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SSKDF_INFO, other,
-                                    sizeof(other)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SALT, salt,
-                                    sizeof(salt)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MAC_SIZE,
-                                    (size_t)20), 0)
+        TEST_ptr(kctx = get_kdfbyname(SN_sskdf))
+        &amp;&amp; TEST_true(EVP_KDF_CTX_set_params(kctx, params))
         &amp;&amp; TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
         &amp;&amp; TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));
 
@@ -340,9 +390,11 @@ static int test_kdf_sshkdf(void)
 {
     int ret;
     EVP_KDF_CTX *kctx;
+    OSSL_PARAM params[6], *p = params;
+    char kdftype = EVP_KDF_SSHKDF_TYPE_INITIAL_IV_CLI_TO_SRV;
     unsigned char out[8];
     /* Test data from NIST CAVS 14.1 test vectors */
-    static const unsigned char key[] = {
+    static unsigned char key[] = {
         0x00, 0x00, 0x00, 0x81, 0x00, 0x87, 0x5c, 0x55, 0x1c, 0xef, 0x52, 0x6a,
         0x4a, 0x8b, 0xe1, 0xa7, 0xdf, 0x27, 0xe9, 0xed, 0x35, 0x4b, 0xac, 0x9a,
         0xfb, 0x71, 0xf5, 0x3d, 0xba, 0xe9, 0x05, 0x67, 0x9d, 0x14, 0xf9, 0xfa,
@@ -356,12 +408,12 @@ static int test_kdf_sshkdf(void)
         0xaa, 0x22, 0x76, 0x93, 0xe1, 0x41, 0xad, 0x16, 0x30, 0xce, 0x13, 0x14,
         0x4e
     };
-    static const unsigned char xcghash[] = {
+    static unsigned char xcghash[] = {
         0x0e, 0x68, 0x3f, 0xc8, 0xa9, 0xed, 0x7c, 0x2f, 0xf0, 0x2d, 0xef, 0x23,
         0xb2, 0x74, 0x5e, 0xbc, 0x99, 0xb2, 0x67, 0xda, 0xa8, 0x6a, 0x4a, 0xa7,
         0x69, 0x72, 0x39, 0x08, 0x82, 0x53, 0xf6, 0x42
     };
-    static const unsigned char sessid[] = {
+    static unsigned char sessid[] = {
         0x0e, 0x68, 0x3f, 0xc8, 0xa9, 0xed, 0x7c, 0x2f, 0xf0, 0x2d, 0xef, 0x23,
         0xb2, 0x74, 0x5e, 0xbc, 0x99, 0xb2, 0x67, 0xda, 0xa8, 0x6a, 0x4a, 0xa7,
         0x69, 0x72, 0x39, 0x08, 0x82, 0x53, 0xf6, 0x42
@@ -370,18 +422,21 @@ static int test_kdf_sshkdf(void)
         0x41, 0xff, 0x2e, 0xad, 0x16, 0x83, 0xf1, 0xe6
     };
 
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)&quot;sha256&quot;, sizeof(&quot;sha256&quot;));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY, key,
+                                             sizeof(key));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SSHKDF_XCGHASH,
+                                             xcghash, sizeof(xcghash));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SSHKDF_SESSION_ID,
+                                             sessid, sizeof(sessid));
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_SSHKDF_TYPE,
+                                            &amp;kdftype, sizeof(kdftype));
+    *p = OSSL_PARAM_construct_end();
+
     ret =
-        TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_SSHKDF))
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha256()), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, key,
-                                    sizeof(key)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SSHKDF_XCGHASH,
-                                    xcghash, sizeof(xcghash)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SSHKDF_SESSION_ID,
-                                    sessid, sizeof(sessid)), 0)
-        &amp;&amp; TEST_int_gt(
-                EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_SSHKDF_TYPE,
-                            (int)EVP_KDF_SSHKDF_TYPE_INITIAL_IV_CLI_TO_SRV), 0)
+        TEST_ptr(kctx = get_kdfbyname(SN_sshkdf))
+        &amp;&amp; TEST_true(EVP_KDF_CTX_set_params(kctx, params))
         &amp;&amp; TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
         &amp;&amp; TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));
 
@@ -391,19 +446,38 @@ static int test_kdf_sshkdf(void)
 
 static int test_kdf_get_kdf(void)
 {
-    const EVP_KDF *kdf1, *kdf2;
+    EVP_KDF *kdf1 = NULL, *kdf2 = NULL;
     ASN1_OBJECT *obj;
-
-    return
-        TEST_ptr(obj = OBJ_nid2obj(NID_id_pbkdf2))
-        &amp;&amp; TEST_ptr(kdf1 = EVP_get_kdfbyname(LN_id_pbkdf2))
-        &amp;&amp; TEST_ptr(kdf2 = EVP_get_kdfbyobj(obj))
-        &amp;&amp; TEST_ptr_eq(kdf1, kdf2)
-        &amp;&amp; TEST_ptr(kdf1 = EVP_get_kdfbyname(SN_tls1_prf))
-        &amp;&amp; TEST_ptr(kdf2 = EVP_get_kdfbyname(LN_tls1_prf))
-        &amp;&amp; TEST_ptr_eq(kdf1, kdf2)
-        &amp;&amp; TEST_ptr(kdf2 = EVP_get_kdfbynid(NID_tls1_prf))
-        &amp;&amp; TEST_ptr_eq(kdf1, kdf2);
+    int ok = 1;
+
+    if (!TEST_ptr(obj = OBJ_nid2obj(NID_id_pbkdf2))
+        || !TEST_ptr(kdf1 = EVP_KDF_fetch(NULL, LN_id_pbkdf2, NULL))
+        || !TEST_ptr(kdf2 = EVP_KDF_fetch(NULL, OBJ_nid2sn(OBJ_obj2nid(obj)),
+                                          NULL))
+        || !TEST_ptr_eq(kdf1, kdf2))
+        ok = 0;
+    EVP_KDF_free(kdf1);
+    kdf1 = NULL;
+    EVP_KDF_free(kdf2);
+    kdf2 = NULL;
+
+    if (!TEST_ptr(kdf1 = EVP_KDF_fetch(NULL, SN_tls1_prf, NULL))
+        || !TEST_ptr(kdf2 = EVP_KDF_fetch(NULL, LN_tls1_prf, NULL))
+        || !TEST_ptr_eq(kdf1, kdf2))
+        ok = 0;
+    /* kdf1 is re-used below, so don't free it here */
+    EVP_KDF_free(kdf2);
+    kdf2 = NULL;
+
+    if (!TEST_ptr(kdf2 = EVP_KDF_fetch(NULL, OBJ_nid2sn(NID_tls1_prf), NULL))
+        || !TEST_ptr_eq(kdf1, kdf2))
+        ok = 0;
+    EVP_KDF_free(kdf1);
+    kdf1 = NULL;
+    EVP_KDF_free(kdf2);
+    kdf2 = NULL;
+
+    return ok;
 }
 
 #ifndef OPENSSL_NO_CMS
@@ -411,9 +485,11 @@ static int test_kdf_x942_asn1(void)
 {
     int ret;
     EVP_KDF_CTX *kctx = NULL;
+    OSSL_PARAM params[4], *p = params;
+    const char *cek_alg = SN_id_smime_alg_CMS3DESwrap;
     unsigned char out[24];
     /* RFC2631 Section 2.1.6 Test data */
-    static const unsigned char z[] = {
+    static unsigned char z[] = {
         0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,
         0x0e,0x0f,0x10,0x11,0x12,0x13
     };
@@ -423,12 +499,18 @@ static int test_kdf_x942_asn1(void)
         0xb6,0x7f,0x5f,0x1e,0xf6,0x3e,0xb5,0xfb
     };
 
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,
+                                            (char *)&quot;sha1&quot;, sizeof(&quot;sha1&quot;));
+    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY, z,
+                                             sizeof(z));
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_CEK_ALG,
+                                            (char *)cek_alg,
+                                            strlen(cek_alg) + 1);
+    *p = OSSL_PARAM_construct_end();
+
     ret =
-        TEST_ptr(kctx = EVP_KDF_CTX_new_id(EVP_KDF_X942))
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_MD, EVP_sha1()), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_KEY, z, sizeof(z)), 0)
-        &amp;&amp; TEST_int_gt(EVP_KDF_ctrl(kctx, EVP_KDF_CTRL_SET_CEK_ALG,
-                                    SN_id_smime_alg_CMS3DESwrap), 0)
+        TEST_ptr(kctx = get_kdfbyname(SN_x942kdf))
+        &amp;&amp; TEST_true(EVP_KDF_CTX_set_params(kctx, params))
         &amp;&amp; TEST_int_gt(EVP_KDF_derive(kctx, out, sizeof(out)), 0)
         &amp;&amp; TEST_mem_eq(out, sizeof(out), expected, sizeof(expected));
 
diff --git a/test/evp_test.c b/test/evp_test.c
index b2047d591a..2f7506e6e6 100644
--- a/test/evp_test.c
+++ b/test/evp_test.c
@@ -1975,6 +1975,8 @@ typedef struct kdf_data_st {
     /* Expected output */
     unsigned char *output;
     size_t output_len;
+    OSSL_PARAM params[20];
+    OSSL_PARAM *p;
 } KDF_DATA;
 
 /*
@@ -1984,7 +1986,7 @@ typedef struct kdf_data_st {
 static int kdf_test_init(EVP_TEST *t, const char *name)
 {
     KDF_DATA *kdata;
-    const EVP_KDF *kdf;
+    EVP_KDF *kdf;
 
 #ifdef OPENSSL_NO_SCRYPT
     if (strcmp(name, &quot;scrypt&quot;) == 0) {
@@ -2000,13 +2002,16 @@ static int kdf_test_init(EVP_TEST *t, const char *name)
     }
 #endif /* OPENSSL_NO_CMS */
 
-    kdf = EVP_get_kdfbyname(name);
-    if (kdf == NULL)
+    if (!TEST_ptr(kdata = OPENSSL_zalloc(sizeof(*kdata))))
         return 0;
+    kdata-&gt;p = kdata-&gt;params;
+    *kdata-&gt;p = OSSL_PARAM_construct_end();
 
-    if (!TEST_ptr(kdata = OPENSSL_zalloc(sizeof(*kdata))))
+    kdf = EVP_KDF_fetch(NULL, name, NULL);
+    if (kdf == NULL)
         return 0;
     kdata-&gt;ctx = EVP_KDF_CTX_new(kdf);
+    EVP_KDF_free(kdf);
     if (kdata-&gt;ctx == NULL) {
         OPENSSL_free(kdata);
         return 0;
@@ -2018,6 +2023,10 @@ static int kdf_test_init(EVP_TEST *t, const char *name)
 static void kdf_test_cleanup(EVP_TEST *t)
 {
     KDF_DATA *kdata = t-&gt;data;
+    OSSL_PARAM *p;
+
+    for (p = kdata-&gt;params; p-&gt;key != NULL; p++)
+        OPENSSL_free(p-&gt;data);
     OPENSSL_free(kdata-&gt;output);
     EVP_KDF_CTX_free(kdata-&gt;ctx);
 }
@@ -2025,36 +2034,35 @@ static void kdf_test_cleanup(EVP_TEST *t)
 static int kdf_test_ctrl(EVP_TEST *t, EVP_KDF_CTX *kctx,
                          const char *value)
 {
+    KDF_DATA *kdata = t-&gt;data;
     int rv;
-    char *p, *tmpval;
+    char *p, *name;
+    const OSSL_PARAM *defs = EVP_KDF_CTX_settable_params(EVP_KDF_CTX_kdf(kctx));
 
-    if (!TEST_ptr(tmpval = OPENSSL_strdup(value)))
+    if (!TEST_ptr(name = OPENSSL_strdup(value)))
         return 0;
-    p = strchr(tmpval, ':');
+    p = strchr(name, ':');
     if (p != NULL)
         *p++ = '\0';
-    rv = EVP_KDF_ctrl_str(kctx, tmpval, p);
-    if (rv == -2) {
-        t-&gt;err = &quot;KDF_CTRL_INVALID&quot;;
-        rv = 1;
-    } else if (p != NULL &amp;&amp; rv &lt;= 0) {
+
+    rv = OSSL_PARAM_allocate_from_text(kdata-&gt;p, defs, name, p, strlen(p));
+    *++kdata-&gt;p = OSSL_PARAM_construct_end();
+    if (!rv) {
+        t-&gt;err = &quot;KDF_PARAM_ERROR&quot;;
+        OPENSSL_free(name);
+        return 0;
+    }
+    if (strcmp(name, &quot;digest&quot;) == 0 &amp;&amp; p != NULL) {
         /* If p has an OID and lookup fails assume disabled algorithm */
         int nid = OBJ_sn2nid(p);
 
         if (nid == NID_undef)
              nid = OBJ_ln2nid(p);
-        if (nid != NID_undef
-                &amp;&amp; EVP_get_digestbynid(nid) == NULL
-                &amp;&amp; EVP_get_cipherbynid(nid) == NULL) {
+        if (nid != NID_undef &amp;&amp; EVP_get_digestbynid(nid) == NULL)
             t-&gt;skip = 1;
-            rv = 1;
-        } else {
-            t-&gt;err = &quot;KDF_CTRL_ERROR&quot;;
-            rv = 1;
-        }
     }
-    OPENSSL_free(tmpval);
-    return rv &gt; 0;
+    OPENSSL_free(name);
+    return 1;
 }
 
 static int kdf_test_parse(EVP_TEST *t,
@@ -2075,6 +2083,10 @@ static int kdf_test_run(EVP_TEST *t)
     unsigned char *got = NULL;
     size_t got_len = expected-&gt;output_len;
 
+    if (!EVP_KDF_CTX_set_params(expected-&gt;ctx, expected-&gt;params)) {
+        t-&gt;err = &quot;KDF_CTRL_ERROR&quot;;
+        return 1;
+    }
     if (!TEST_ptr(got = OPENSSL_malloc(got_len))) {
         t-&gt;err = &quot;INTERNAL_ERROR&quot;;
         goto err;
@@ -2161,6 +2173,7 @@ static int pkey_kdf_test_init(EVP_TEST *t, const char *name)
 static void pkey_kdf_test_cleanup(EVP_TEST *t)
 {
     PKEY_KDF_DATA *kdata = t-&gt;data;
+
     OPENSSL_free(kdata-&gt;output);
     EVP_PKEY_CTX_free(kdata-&gt;ctx);
 }
diff --git a/test/recipes/20-test_kdf.t b/test/recipes/20-test_kdf.t
index 39fb485290..a03f6997b4 100755
--- a/test/recipes/20-test_kdf.t
+++ b/test/recipes/20-test_kdf.t
@@ -43,7 +43,7 @@ my @kdf_tests = (
 );
 
 my @scrypt_tests = (
-    { cmd =&gt; [qw{openssl kdf -keylen 64 -kdfopt pass:password -kdfopt salt:NaCl -kdfopt N:1024 -kdfopt r:8 -kdfopt p:16 -kdfopt maxmem_bytes:10485760 id-scrypt}],
+    { cmd =&gt; [qw{openssl kdf -keylen 64 -kdfopt pass:password -kdfopt salt:NaCl -kdfopt n:1024 -kdfopt r:8 -kdfopt p:16 -kdfopt maxmem_bytes:10485760 id-scrypt}],
       expected =&gt; 'fd:ba:be:1c:9d:34:72:00:78:56:e7:19:0d:01:e9:fe:7c:6a:d7:cb:c8:23:78:30:e7:73:76:63:4b:37:31:62:2e:af:30:d9:2e:22:a3:88:6f:f1:09:27:9d:98:30:da:c7:27:af:b9:4a:83:ee:6d:83:60:cb:df:a2:cc:06:40',
       desc =&gt; 'SCRYPT' },
 );
diff --git a/test/recipes/30-test_evp_data/evpkdf.txt b/test/recipes/30-test_evp_data/evpkdf.txt
index 6f7270bb9e..9c9be7552c 100644
--- a/test/recipes/30-test_evp_data/evpkdf.txt
+++ b/test/recipes/30-test_evp_data/evpkdf.txt
@@ -254,51 +254,51 @@ Output = 2c91117204d745f3500d636a62f64f0ab3bae548aa53d423b0d1f27ebba6f5e5673a081
 
 Title = id-scrypt tests (from draft-josefsson-id-scrypt-kdf-03 and others)
 
-KDF = scrypt
+KDF = id-scrypt
 Ctrl.pass = pass:
 Ctrl.salt = salt:
-Ctrl.N = N:16
+Ctrl.N = n:16
 Ctrl.r = r:1
 Ctrl.p = p:1
 Output = 77d6576238657b203b19ca42c18a0497f16b4844e3074ae8dfdffa3fede21442fcd0069ded0948f8326a753a0fc81f17e8d3e0fb2e0d3628cf35e20c38d18906
 
-KDF = scrypt
+KDF = id-scrypt
 Ctrl.pass = pass:password
 Ctrl.salt = salt:NaCl
-Ctrl.N = N:1024
+Ctrl.N = n:1024
 Ctrl.r = r:8
 Ctrl.p = p:16
 Output = fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b3731622eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640
 
-KDF = scrypt
+KDF = id-scrypt
 Ctrl.hexpass = hexpass:70617373776f7264
 Ctrl.salt = salt:NaCl
-Ctrl.N = N:1024
+Ctrl.N = n:1024
 Ctrl.r = r:8
 Ctrl.p = p:16
 Output = fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b3731622eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640
 
-KDF = scrypt
+KDF = id-scrypt
 Ctrl.pass = pass:password
 Ctrl.hexsalt = hexsalt:4e61436c
-Ctrl.N = N:1024
+Ctrl.N = n:1024
 Ctrl.r = r:8
 Ctrl.p = p:16
 Output = fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b3731622eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640
 
-KDF = scrypt
+KDF = id-scrypt
 Ctrl.pass = pass:pleaseletmein
 Ctrl.salt = salt:SodiumChloride
-Ctrl.N = N:16384
+Ctrl.N = n:16384
 Ctrl.r = r:8
 Ctrl.p = p:1
 Output = 7023bdcb3afd7348461c06cd81fd38ebfda8fbba904f8e3ea9b543f6545da1f2d5432955613f0fcf62d49705242a9af9e61e85dc0d651e40dfcf017b45575887
 
 # Out of memory
-KDF = scrypt
+KDF = id-scrypt
 Ctrl.pass = pass:pleaseletmein
 Ctrl.salt = salt:SodiumChloride
-Ctrl.N = N:1048576
+Ctrl.N = n:1048576
 Ctrl.r = r:8
 Ctrl.p = p:1
 Result = INTERNAL_ERROR
@@ -452,7 +452,7 @@ Title = SSHKDF tests (from NIST CAVS 14.1 test vectors)
 # The first one uses md instead of digest to test alias works
 
 KDF = SSHKDF
-Ctrl.md = md:SHA1
+Ctrl.digest = digest:SHA1
 Ctrl.hexkey = hexkey:0000008055bae931c07fd824bf10add1902b6fbc7c665347383498a686929ff5a25f8e40cb6645ea814fb1a5e0a11f852f86255641e5ed986e83a78bc8269480eac0b0dfd770cab92e7a28dd87ff452466d6ae867cead63b366b1c286e6c4811a9f14c27aea14c5171d49b78c06e3735d36e6a3be321dd5fc82308f34ee1cb17fba94a59
 Ctrl.hexxcghash = hexxcghash:a4ebd45934f56792b5112dcd75a1075fdc889245
 Ctrl.hexsession_id = hexsession_id:a4ebd45934f56792b5112dcd75a1075fdc889245
diff --git a/util/libcrypto.num b/util/libcrypto.num
index e6567aefe2..442a6bb02f 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -1807,7 +1807,6 @@ i2d_ASN1_bio_stream                     1849	3_0_0	EXIST::FUNCTION:
 CRYPTO_THREAD_init_local                1850	3_0_0	EXIST::FUNCTION:
 TS_RESP_CTX_set_serial_cb               1851	3_0_0	EXIST::FUNCTION:TS
 POLICY_MAPPING_it                       1852	3_0_0	EXIST::FUNCTION:
-ERR_load_KDF_strings                    1853	3_0_0	EXIST::FUNCTION:
 UI_method_set_reader                    1854	3_0_0	EXIST::FUNCTION:
 BIO_next                                1855	3_0_0	EXIST::FUNCTION:
 ASN1_STRING_set_default_mask_asc        1856	3_0_0	EXIST::FUNCTION:
@@ -4477,12 +4476,8 @@ ASYNC_WAIT_CTX_set_callback             4582	3_0_0	EXIST::FUNCTION:
 ASYNC_WAIT_CTX_set_status               4583	3_0_0	EXIST::FUNCTION:
 ASYNC_WAIT_CTX_get_status               4584	3_0_0	EXIST::FUNCTION:
 ERR_load_ESS_strings                    4589	3_0_0	EXIST::FUNCTION:
-EVP_KDF_CTX_new_id                      4590	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_free                        4591	3_0_0	EXIST::FUNCTION:
 EVP_KDF_reset                           4592	3_0_0	EXIST::FUNCTION:
-EVP_KDF_ctrl                            4593	3_0_0	EXIST::FUNCTION:
-EVP_KDF_vctrl                           4594	3_0_0	EXIST::FUNCTION:
-EVP_KDF_ctrl_str                        4595	3_0_0	EXIST::FUNCTION:
 EVP_KDF_size                            4596	3_0_0	EXIST::FUNCTION:
 EVP_KDF_derive                          4597	3_0_0	EXIST::FUNCTION:
 EC_GROUP_get0_field                     4598	3_0_0	EXIST::FUNCTION:EC
@@ -4632,8 +4627,6 @@ EVP_CIPHER_mode                         4741	3_0_0	EXIST::FUNCTION:
 OPENSSL_info                            4742	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_new                         4743	3_0_0	EXIST::FUNCTION:
 EVP_KDF_CTX_kdf                         4744	3_0_0	EXIST::FUNCTION:
-EVP_KDF_nid                             4745	3_0_0	EXIST::FUNCTION:
-EVP_get_kdfbyname                       4746	3_0_0	EXIST::FUNCTION:
 i2d_KeyParams                           4747	3_0_0	EXIST::FUNCTION:
 d2i_KeyParams                           4748	3_0_0	EXIST::FUNCTION:
 i2d_KeyParams_bio                       4749	3_0_0	EXIST::FUNCTION:
@@ -4734,3 +4727,16 @@ EVP_MAC_provider                        4843	3_0_0	EXIST::FUNCTION:
 EVP_MAC_do_all_ex                       4844	3_0_0	EXIST::FUNCTION:
 EVP_MD_free                             4845	3_0_0	EXIST::FUNCTION:
 EVP_CIPHER_free                         4846	3_0_0	EXIST::FUNCTION:
+EVP_KDF_up_ref                          4847	3_0_0	EXIST::FUNCTION:
+EVP_KDF_free                            4848	3_0_0	EXIST::FUNCTION:
+EVP_KDF_fetch                           4849	3_0_0	EXIST::FUNCTION:
+EVP_KDF_CTX_dup                         4850	3_0_0	EXIST::FUNCTION:
+EVP_KDF_name                            4851	3_0_0	EXIST::FUNCTION:
+EVP_KDF_provider                        4852	3_0_0	EXIST::FUNCTION:
+EVP_KDF_get_params                      4853	3_0_0	EXIST::FUNCTION:
+EVP_KDF_CTX_get_params                  4854	3_0_0	EXIST::FUNCTION:
+EVP_KDF_CTX_set_params                  4855	3_0_0	EXIST::FUNCTION:
+EVP_KDF_gettable_params                 4856	3_0_0	EXIST::FUNCTION:
+EVP_KDF_CTX_gettable_params             4857	3_0_0	EXIST::FUNCTION:
+EVP_KDF_CTX_settable_params             4858	3_0_0	EXIST::FUNCTION:
+EVP_KDF_do_all_ex                       4859	3_0_0	EXIST::FUNCTION:
diff --git a/util/missingcrypto.txt b/util/missingcrypto.txt
index 05eee92d27..a59c7d491c 100644
--- a/util/missingcrypto.txt
+++ b/util/missingcrypto.txt
@@ -458,7 +458,6 @@ ERR_load_ENGINE_strings
 ERR_load_ERR_strings
 ERR_load_ESS_strings
 ERR_load_EVP_strings
-ERR_load_KDF_strings
 ERR_load_OBJ_strings
 ERR_load_OCSP_strings
 ERR_load_OSSL_STORE_strings
diff --git a/util/missingcrypto111.txt b/util/missingcrypto111.txt
index e544c1b3c7..8d65057c59 100644
--- a/util/missingcrypto111.txt
+++ b/util/missingcrypto111.txt
@@ -469,7 +469,6 @@ ERR_load_EC_strings
 ERR_load_ENGINE_strings
 ERR_load_ERR_strings
 ERR_load_EVP_strings
-ERR_load_KDF_strings
 ERR_load_OBJ_strings
 ERR_load_OCSP_strings
 ERR_load_OSSL_STORE_strings
diff --git a/util/private.num b/util/private.num
index 351828268c..4d57795c5e 100644
--- a/util/private.num
+++ b/util/private.num
@@ -294,8 +294,6 @@ EVP_get_digestbynid                     define
 EVP_get_digestbyobj                     define
 EVP_get_macbynid                        define
 EVP_get_macbyobj                        define
-EVP_get_kdfbynid                        define
-EVP_get_kdfbyobj                        define
 EVP_idea_cfb                            define
 EVP_rc2_cfb                             define
 EVP_rc5_32_12_16_cfb                    define
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="024869.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="024877.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#24871">[ date ]</a>
              <a href="thread.html#24871">[ thread ]</a>
              <a href="subject.html#24871">[ subject ]</a>
              <a href="author.html#24871">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
