<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-September/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1599935254.308043.5729.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030637.html">
   <LINK REL="Next"  HREF="030640.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1599935254.308043.5729.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Sat Sep 12 18:27:34 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="030637.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="030640.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30639">[ date ]</a>
              <a href="thread.html#30639">[ thread ]</a>
              <a href="subject.html#30639">[ subject ]</a>
              <a href="author.html#30639">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  f0c62c53286b3a79cc059354a6d3425b35bb1d50 (commit)
       via  655f73cecf411737cef9debdfa4c0b8b041656df (commit)
       via  96bb4ff9b8473d01d9ac9301ec0f796898c8f459 (commit)
       via  33dd828d976fc6b1b508f090b8fd91fbf9ab7cce (commit)
       via  7229a2f4ab9b4d8cecf44be58adeb14e195ff051 (commit)
      from  4588f35b5af9bc0d250877ce22915d0cd96f320e (commit)


- Log -----------------------------------------------------------------
commit f0c62c53286b3a79cc059354a6d3425b35bb1d50
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Sep 11 08:36:54 2020 +0200

    TEST: Add a test of EC key generation with encoding spec
    
    The primary function of this test is to exercise
    EVP_PKEY_CTX_set_ec_param_enc().
    
    Reviewed-by: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12853">https://github.com/openssl/openssl/pull/12853</A>)

commit 655f73cecf411737cef9debdfa4c0b8b041656df
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Sep 11 08:35:26 2020 +0200

    EVP: Add the internal convenience function evp_keymgmt_util_export()
    
    This is purely to allow exporting without having to repeatedly specify
    the keymgmt and keydata from the EVP_PKEY.
    
    Reviewed-by: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12853">https://github.com/openssl/openssl/pull/12853</A>)

commit 96bb4ff9b8473d01d9ac9301ec0f796898c8f459
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Fri Sep 11 14:38:22 2020 +1000

    Fix EVP_PKEY_CTX_ctrl() documentation
    
    Remove references to 'macro' from EVP_PKEY_CTX_ctrl() as they are all
    functions now, and update the HISTORY section.
    
    Reviewed-by: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12853">https://github.com/openssl/openssl/pull/12853</A>)

commit 33dd828d976fc6b1b508f090b8fd91fbf9ab7cce
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Fri Sep 11 10:53:30 2020 +1000

    Update doc for EVP_PKEY_CTX_set_ec_param_enc()
    
    Reviewed-by: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12853">https://github.com/openssl/openssl/pull/12853</A>)

commit 7229a2f4ab9b4d8cecf44be58adeb14e195ff051
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Sep 10 22:06:46 2020 +0200

    EC: Reimplement EVP_PKEY_CTX_set_ec_param_enc() to support providers
    
    Fixes #12852
    
    Reviewed-by: Nicola Tuveri &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">nic.tuv at gmail.com</A>&gt;
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12853">https://github.com/openssl/openssl/pull/12853</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/ec/ec_ctrl.c                                |  40 ++++
 crypto/evp/keymgmt_lib.c                           |  16 +-
 crypto/evp/p_lib.c                                 |  16 +-
 crypto/evp/pmeth_lib.c                             |   3 +
 .../man3/evp_keymgmt_util_export_to_provider.pod   |   6 +
 doc/man3/EVP_PKEY_CTX_ctrl.pod                     | 212 ++++++++++-----------
 include/crypto/ec.h                                |   2 +
 include/crypto/evp.h                               |   2 +
 include/openssl/ec.h                               |   7 +-
 test/build.info                                    |   2 +-
 test/evp_extra_test.c                              |  78 ++++++++
 util/libcrypto.num                                 |   1 +
 12 files changed, 250 insertions(+), 135 deletions(-)

diff --git a/crypto/ec/ec_ctrl.c b/crypto/ec/ec_ctrl.c
index b47d7b606c..1465af2bec 100644
--- a/crypto/ec/ec_ctrl.c
+++ b/crypto/ec/ec_ctrl.c
@@ -443,4 +443,44 @@ int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *ctx, int nid)
 
     return EVP_PKEY_CTX_set_group_name(ctx, OBJ_nid2sn(nid));
 }
+
+int evp_pkey_ctx_set_ec_param_enc_prov(EVP_PKEY_CTX *ctx, int param_enc)
+{
+    const char *enc = NULL;
+    OSSL_PARAM params[2], *p = params;
+    int ret = -2;                /* Assume unsupported */
+
+    if (ctx == NULL
+        || !EVP_PKEY_CTX_IS_GEN_OP(ctx)
+        || ctx-&gt;op.keymgmt.genctx == NULL)
+        goto end;
+
+    switch (param_enc) {
+    case OPENSSL_EC_EXPLICIT_CURVE:
+        enc = OSSL_PKEY_EC_ENCODING_EXPLICIT;
+        break;
+    case OPENSSL_EC_NAMED_CURVE:
+        enc = OSSL_PKEY_EC_ENCODING_GROUP;
+        break;
+    default:
+        goto end;
+    }
+
+    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_EC_ENCODING,
+                                            (char *)enc, 0);
+    *p++ = OSSL_PARAM_construct_end();
+
+    ret = evp_pkey_ctx_set_params_strict(ctx, params);
+ end:
+    if (ret == -2)
+        ERR_raise(ERR_LIB_EVP, EVP_R_COMMAND_NOT_SUPPORTED);
+    return ret;
+}
+
+int EVP_PKEY_CTX_set_ec_param_enc(EVP_PKEY_CTX *ctx, int param_enc)
+{
+    return EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC,
+                             EVP_PKEY_OP_PARAMGEN|EVP_PKEY_OP_KEYGEN,
+                             EVP_PKEY_CTRL_EC_PARAM_ENC, param_enc, NULL);
+}
 #endif
diff --git a/crypto/evp/keymgmt_lib.c b/crypto/evp/keymgmt_lib.c
index 5ef4115f47..763982e58f 100644
--- a/crypto/evp/keymgmt_lib.c
+++ b/crypto/evp/keymgmt_lib.c
@@ -77,6 +77,13 @@ EVP_PKEY *evp_keymgmt_util_make_pkey(EVP_KEYMGMT *keymgmt, void *keydata)
     return pkey;
 }
 
+int evp_keymgmt_util_export(const EVP_PKEY *pk, int selection,
+                            OSSL_CALLBACK *export_cb, void *export_cbarg)
+{
+    return evp_keymgmt_export(pk-&gt;keymgmt, pk-&gt;keydata, selection,
+                              export_cb, export_cbarg);
+}
+
 void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt)
 {
     struct evp_keymgmt_util_try_import_data_st import_data;
@@ -139,8 +146,8 @@ void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt)
      * The export function calls the callback (evp_keymgmt_util_try_import),
      * which does the import for us.  If successful, we're done.
      */
-    if (!evp_keymgmt_export(pk-&gt;keymgmt, pk-&gt;keydata, OSSL_KEYMGMT_SELECT_ALL,
-                            &amp;evp_keymgmt_util_try_import, &amp;import_data)) {
+    if (!evp_keymgmt_util_export(pk, OSSL_KEYMGMT_SELECT_ALL,
+                                 &amp;evp_keymgmt_util_try_import, &amp;import_data)) {
         /* If there was an error, bail out */
         evp_keymgmt_freedata(keymgmt, import_data.keydata);
         return NULL;
@@ -392,8 +399,9 @@ int evp_keymgmt_util_copy(EVP_PKEY *to, EVP_PKEY *from, int selection)
         import_data.keydata = to_keydata;
         import_data.selection = selection;
 
-        if (!evp_keymgmt_export(from-&gt;keymgmt, from-&gt;keydata, selection,
-                                &amp;evp_keymgmt_util_try_import, &amp;import_data)) {
+        if (!evp_keymgmt_util_export(from, selection,
+                                     &amp;evp_keymgmt_util_try_import,
+                                     &amp;import_data)) {
             evp_keymgmt_freedata(to_keymgmt, alloc_keydata);
             return 0;
         }
diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
index 0f5378c4fe..cb72048f86 100644
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -527,9 +527,8 @@ int EVP_PKEY_get_raw_private_key(const EVP_PKEY *pkey, unsigned char *priv,
         raw_key.len = len;
         raw_key.selection = OSSL_KEYMGMT_SELECT_PRIVATE_KEY;
 
-        return evp_keymgmt_export(pkey-&gt;keymgmt, pkey-&gt;keydata,
-                                  OSSL_KEYMGMT_SELECT_PRIVATE_KEY,
-                                  get_raw_key_details, &amp;raw_key);
+        return evp_keymgmt_util_export(pkey, OSSL_KEYMGMT_SELECT_PRIVATE_KEY,
+                                       get_raw_key_details, &amp;raw_key);
     }
 
     if (pkey-&gt;ameth == NULL) {
@@ -560,9 +559,8 @@ int EVP_PKEY_get_raw_public_key(const EVP_PKEY *pkey, unsigned char *pub,
         raw_key.len = len;
         raw_key.selection = OSSL_KEYMGMT_SELECT_PUBLIC_KEY;
 
-        return evp_keymgmt_export(pkey-&gt;keymgmt, pkey-&gt;keydata,
-                                  OSSL_KEYMGMT_SELECT_PUBLIC_KEY,
-                                  get_raw_key_details, &amp;raw_key);
+        return evp_keymgmt_util_export(pkey, OSSL_KEYMGMT_SELECT_PUBLIC_KEY,
+                                       get_raw_key_details, &amp;raw_key);
     }
 
     if (pkey-&gt;ameth == NULL) {
@@ -1115,9 +1113,9 @@ int evp_pkey_get_EC_KEY_curve_nid(const EVP_PKEY *pkey)
     } else if (EVP_PKEY_is_a(pkey, &quot;EC&quot;) || EVP_PKEY_is_a(pkey, &quot;SM2&quot;)) {
         char *curve_name = NULL;
 
-        ret = evp_keymgmt_export(pkey-&gt;keymgmt, pkey-&gt;keydata,
-                                 OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS,
-                                 get_ec_curve_name_cb, &amp;curve_name);
+        ret = evp_keymgmt_util_export(pkey,
+                                      OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS,
+                                      get_ec_curve_name_cb, &amp;curve_name);
         if (ret)
             ret = ec_curve_name2nid(curve_name);
         OPENSSL_free(curve_name);
diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index e557e14e18..12f09ed79b 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -26,6 +26,7 @@
 #include &quot;crypto/asn1.h&quot;
 #include &quot;crypto/evp.h&quot;
 #include &quot;crypto/dh.h&quot;
+#include &quot;crypto/ec.h&quot;
 #include &quot;internal/ffc.h&quot;
 #include &quot;internal/numbers.h&quot;
 #include &quot;internal/provider.h&quot;
@@ -1248,6 +1249,8 @@ static int legacy_ctrl_to_param(EVP_PKEY_CTX *ctx, int keytype, int optype,
 # ifndef OPENSSL_NO_EC
     if (keytype == EVP_PKEY_EC) {
         switch (cmd) {
+        case EVP_PKEY_CTRL_EC_PARAM_ENC:
+            return evp_pkey_ctx_set_ec_param_enc_prov(ctx, p1);
         case EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID:
             return EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, p1);
         case EVP_PKEY_CTRL_EC_ECDH_COFACTOR:
diff --git a/doc/internal/man3/evp_keymgmt_util_export_to_provider.pod b/doc/internal/man3/evp_keymgmt_util_export_to_provider.pod
index 5fdd625987..bb2ad9ba8e 100644
--- a/doc/internal/man3/evp_keymgmt_util_export_to_provider.pod
+++ b/doc/internal/man3/evp_keymgmt_util_export_to_provider.pod
@@ -2,6 +2,7 @@
 
 =head1 NAME
 
+evp_keymgmt_util_export,
 evp_keymgmt_util_export_to_provider,
 evp_keymgmt_util_find_operation_cache_index,
 evp_keymgmt_util_clear_operation_cache,
@@ -14,6 +15,8 @@ evp_keymgmt_util_fromdata
 
  #include &quot;crypto/evp.h&quot;
 
+ int evp_keymgmt_util_export(const EVP_PKEY *pk, int selection,
+                             OSSL_CALLBACK *export_cb, void *export_cbarg);
  void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt);
  size_t evp_keymgmt_util_find_operation_cache_index(EVP_PKEY *pk,
                                                     EVP_KEYMGMT *keymgmt);
@@ -26,6 +29,9 @@ evp_keymgmt_util_fromdata
 
 =head1 DESCRIPTION
 
+evp_keymgmt_util_export() calls L&lt;evp_keymgmt_export(3)&gt; with the
+I&lt;keymgmt&gt; and I&lt;keydata&gt; from I&lt;pk&gt;.  This is a convenience function.
+
 evp_keymgmt_util_export_to_provider() exports cached key material
 (provider side key material) from the given key I&lt;pk&gt; to a provider
 via a B&lt;EVP_KEYMGMT&gt; interface, if this hasn't already been done.
diff --git a/doc/man3/EVP_PKEY_CTX_ctrl.pod b/doc/man3/EVP_PKEY_CTX_ctrl.pod
index 9e6b6de443..794ad2053a 100644
--- a/doc/man3/EVP_PKEY_CTX_ctrl.pod
+++ b/doc/man3/EVP_PKEY_CTX_ctrl.pod
@@ -176,9 +176,9 @@ EVP_PKEY_CTX_set1_id, EVP_PKEY_CTX_get1_id, EVP_PKEY_CTX_get1_id_len
 
 =head1 DESCRIPTION
 
-The function EVP_PKEY_CTX_ctrl() sends a control operation to the context
-I&lt;ctx&gt;. The key type used must match I&lt;keytype&gt; if it is not -1. The parameter
-I&lt;optype&gt; is a mask indicating which operations the control can be applied to.
+EVP_PKEY_CTX_ctrl() sends a control operation to the context I&lt;ctx&gt;. The key
+type used must match I&lt;keytype&gt; if it is not -1. The parameter I&lt;optype&gt; is a
+mask indicating which operations the control can be applied to.
 The control command is indicated in I&lt;cmd&gt; and any additional arguments in
 I&lt;p1&gt; and I&lt;p2&gt;.
 
@@ -186,39 +186,37 @@ For I&lt;cmd&gt; = B&lt;EVP_PKEY_CTRL_SET_MAC_KEY&gt;, I&lt;p1&gt; is the length of the MAC key,
 and I&lt;p2&gt; is the MAC key. This is used by Poly1305, SipHash, HMAC and CMAC.
 
 Applications will not normally call EVP_PKEY_CTX_ctrl() directly but will
-instead call one of the algorithm specific macros below.
+instead call one of the algorithm specific functions below.
 
-The function EVP_PKEY_CTX_ctrl_uint64() is a wrapper that directly passes a
+EVP_PKEY_CTX_ctrl_uint64() is a wrapper that directly passes a
 uint64 value as I&lt;p2&gt; to EVP_PKEY_CTX_ctrl().
 
-The function EVP_PKEY_CTX_ctrl_str() allows an application to send an algorithm
+EVP_PKEY_CTX_ctrl_str() allows an application to send an algorithm
 specific control operation to a context I&lt;ctx&gt; in string form. This is
 intended to be used for options specified on the command line or in text
 files. The commands supported are documented in the openssl utility
 command line pages for the option I&lt;-pkeyopt&gt; which is supported by the
 I&lt;pkeyutl&gt;, I&lt;genpkey&gt; and I&lt;req&gt; commands.
 
-The function EVP_PKEY_CTX_md() sends a message digest control operation
-to the context I&lt;ctx&gt;. The message digest is specified by its name I&lt;md&gt;.
+EVP_PKEY_CTX_md() sends a message digest control operation to the context
+I&lt;ctx&gt;. The message digest is specified by its name I&lt;md&gt;.
 
-The EVP_PKEY_CTX_set_signature_md() function sets the message digest type used
+EVP_PKEY_CTX_set_signature_md() sets the message digest type used
 in a signature. It can be used in the RSA, DSA and ECDSA algorithms.
 
-The EVP_PKEY_CTX_get_signature_md() function gets the message digest type used
+EVP_PKEY_CTX_get_signature_md()gets the message digest type used
 in a signature. It can be used in the RSA, DSA and ECDSA algorithms.
 
-All the remaining &quot;functions&quot; are implemented as macros.
-
 Key generation typically involves setting up parameters to be used and
 generating the private and public key data. Some algorithm implementations
-allow private key data to be set explicitly using the EVP_PKEY_CTX_set_mac_key()
-macro. In this case key generation is simply the process of setting up the
-parameters for the key and then setting the raw key data to the value explicitly
-provided by that macro. Normally applications would call
-L&lt;EVP_PKEY_new_raw_private_key(3)&gt; or similar functions instead of this macro.
+allow private key data to be set explicitly using EVP_PKEY_CTX_set_mac_key().
+In this case key generation is simply the process of setting up the
+parameters for the key and then setting the raw key data to the value explicitly.
+Normally applications would call L&lt;EVP_PKEY_new_raw_private_key(3)&gt; or similar
+functions instead.
 
-The EVP_PKEY_CTX_set_mac_key() macro can be used with any of the algorithms
-supported by the L&lt;EVP_PKEY_new_raw_private_key(3)&gt; function.
+EVP_PKEY_CTX_set_mac_key() can be used with any of the algorithms supported by
+the L&lt;EVP_PKEY_new_raw_private_key(3)&gt; function.
 
 EVP_PKEY_CTX_set_group_name() sets the group name to I&lt;name&gt; for parameter and
 key generation. For example for EC keys this will set the curve name and for
@@ -231,7 +229,7 @@ terminating NUL byte.
 
 =head2 RSA parameters
 
-The EVP_PKEY_CTX_set_rsa_padding() function sets the RSA padding mode for I&lt;ctx&gt;.
+EVP_PKEY_CTX_set_rsa_padding() sets the RSA padding mode for I&lt;ctx&gt;.
 The I&lt;pad&gt; parameter can take the value B&lt;RSA_PKCS1_PADDING&gt; for PKCS#1
 padding, B&lt;RSA_SSLV23_PADDING&gt; for SSLv23 padding, B&lt;RSA_NO_PADDING&gt; for
 no padding, B&lt;RSA_PKCS1_OAEP_PADDING&gt; for OAEP padding (encrypt and
@@ -241,7 +239,7 @@ B&lt;RSA_PKCS1_WITH_TLS_PADDING&gt; for TLS RSA ClientKeyExchange message padding
 (decryption only).
 
 Two RSA padding modes behave differently if EVP_PKEY_CTX_set_signature_md()
-is used. If this macro is called for PKCS#1 padding the plaintext buffer is
+is used. If this function is called for PKCS#1 padding the plaintext buffer is
 an actual digest value and is encapsulated in a DigestInfo structure according
 to PKCS#1 when signing and this structure is expected (and stripped off) when
 verifying. If this control is not used with RSA and PKCS#1 padding then the
@@ -250,13 +248,12 @@ padding for RSA the algorithm identifier byte is added or checked and removed
 if this control is called. If it is not called then the first byte of the plaintext
 buffer is expected to be the algorithm identifier byte.
 
-The EVP_PKEY_CTX_get_rsa_padding() function gets the RSA padding mode for I&lt;ctx&gt;.
+EVP_PKEY_CTX_get_rsa_padding() gets the RSA padding mode for I&lt;ctx&gt;.
 
-The EVP_PKEY_CTX_set_rsa_pss_saltlen() function sets the RSA PSS salt
-length to I&lt;saltlen&gt;. As its name implies it is only supported for PSS
-padding. If this function is not called then the maximum salt length
-is used when signing and auto detection when verifying. Three special
-values are supported:
+EVP_PKEY_CTX_set_rsa_pss_saltlen() sets the RSA PSS salt length to I&lt;saltlen&gt;.
+As its name implies it is only supported for PSS padding. If this function is
+not called then the maximum salt length is used when signing and auto detection
+when verifying. Three special values are supported:
 
 =over 4
 
@@ -276,74 +273,73 @@ meaning as B&lt;RSA_PSS_SALTLEN_MAX&gt;.
 
 =back
 
-The EVP_PKEY_CTX_get_rsa_pss_saltlen() function gets the RSA PSS salt length
-for I&lt;ctx&gt;. The padding mode must already have been set to
-B&lt;RSA_PKCS1_PSS_PADDING&gt;.
+EVP_PKEY_CTX_get_rsa_pss_saltlen() gets the RSA PSS salt length for I&lt;ctx&gt;.
+The padding mode must already have been set to B&lt;RSA_PKCS1_PSS_PADDING&gt;.
 
-The EVP_PKEY_CTX_set_rsa_keygen_bits() macro sets the RSA key length for
+EVP_PKEY_CTX_set_rsa_keygen_bits() sets the RSA key length for
 RSA key generation to I&lt;bits&gt;. If not specified 2048 bits is used.
 
-The EVP_PKEY_CTX_set_rsa_keygen_pubexp() macro sets the public exponent value
-for RSA key generation to I&lt;pubexp&gt;. Currently it should be an odd integer. The
+EVP_PKEY_CTX_set_rsa_keygen_pubexp() sets the public exponent value for RSA key
+generation to I&lt;pubexp&gt;. Currently it should be an odd integer. The
 I&lt;pubexp&gt; pointer is used internally by this function so it should not be
 modified or freed after the call. If not specified 65537 is used.
 
-The EVP_PKEY_CTX_set_rsa_keygen_primes() macro sets the number of primes for
+EVP_PKEY_CTX_set_rsa_keygen_primes() sets the number of primes for
 RSA key generation to I&lt;primes&gt;. If not specified 2 is used.
 
-The EVP_PKEY_CTX_set_rsa_mgf1_md_name() function sets the MGF1 digest for RSA
+EVP_PKEY_CTX_set_rsa_mgf1_md_name() sets the MGF1 digest for RSA
 padding schemes to the digest named I&lt;mdname&gt;. If the RSA algorithm
 implementation for the selected provider supports it then the digest will be
 fetched using the properties I&lt;mdprops&gt;. If not explicitly set the signing
 digest is used. The padding mode must have been set to B&lt;RSA_PKCS1_OAEP_PADDING&gt;
 or B&lt;RSA_PKCS1_PSS_PADDING&gt;.
 
-The EVP_PKEY_CTX_set_rsa_mgf1_md() function does the same as
+EVP_PKEY_CTX_set_rsa_mgf1_md() does the same as
 EVP_PKEY_CTX_set_rsa_mgf1_md_name() except that the name of the digest is
 inferred from the supplied I&lt;md&gt; and it is not possible to specify any
 properties.
 
-The EVP_PKEY_CTX_get_rsa_mgf1_md_name() function gets the name of the MGF1
+EVP_PKEY_CTX_get_rsa_mgf1_md_name() gets the name of the MGF1
 digest algorithm for I&lt;ctx&gt;. If not explicitly set the signing digest is used.
 The padding mode must have been set to B&lt;RSA_PKCS1_OAEP_PADDING&gt; or
 B&lt;RSA_PKCS1_PSS_PADDING&gt;.
 
-The EVP_PKEY_CTX_get_rsa_mgf1_md() function does the same as
+EVP_PKEY_CTX_get_rsa_mgf1_md() does the same as
 EVP_PKEY_CTX_get_rsa_mgf1_md_name() except that it returns a pointer to an
 EVP_MD object instead. Note that only known, built-in EVP_MD objects will be
 returned. The EVP_MD object may be NULL if the digest is not one of these (such
 as a digest only implemented in a third party provider).
 
-The EVP_PKEY_CTX_set_rsa_oaep_md_name() function sets the message digest type
+EVP_PKEY_CTX_set_rsa_oaep_md_name() sets the message digest type
 used in RSA OAEP to the digest named I&lt;mdname&gt;.  If the RSA algorithm
 implementation for the selected provider supports it then the digest will be
 fetched using the properties I&lt;mdprops&gt;. The padding mode must have been set to
 B&lt;RSA_PKCS1_OAEP_PADDING&gt;.
 
-The EVP_PKEY_CTX_set_rsa_oaep_md() function does the same as
+EVP_PKEY_CTX_set_rsa_oaep_md() does the same as
 EVP_PKEY_CTX_set_rsa_oaep_md_name() except that the name of the digest is
 inferred from the supplied I&lt;md&gt; and it is not possible to specify any
 properties.
 
-The EVP_PKEY_CTX_get_rsa_oaep_md_name() function gets the message digest
+EVP_PKEY_CTX_get_rsa_oaep_md_name() gets the message digest
 algorithm name used in RSA OAEP and stores it in the buffer I&lt;name&gt; which is of
 size I&lt;namelen&gt;. The padding mode must have been set to
 B&lt;RSA_PKCS1_OAEP_PADDING&gt;. The buffer should be sufficiently large for any
 expected digest algorithm names or the function will fail.
 
-The EVP_PKEY_CTX_get_rsa_oaep_md() function does the same as
+EVP_PKEY_CTX_get_rsa_oaep_md() does the same as
 EVP_PKEY_CTX_get_rsa_oaep_md_name() except that it returns a pointer to an
 EVP_MD object instead. Note that only known, built-in EVP_MD objects will be
 returned. The EVP_MD object may be NULL if the digest is not one of these (such
 as a digest only implemented in a third party provider).
 
-The EVP_PKEY_CTX_set0_rsa_oaep_label() function sets the RSA OAEP label to
+EVP_PKEY_CTX_set0_rsa_oaep_label() sets the RSA OAEP label to
 I&lt;label&gt; and its length to I&lt;len&gt;. If I&lt;label&gt; is NULL or I&lt;len&gt; is 0,
 the label is cleared. The library takes ownership of the label so the
 caller should not free the original memory pointed to by I&lt;label&gt;.
 The padding mode must have been set to B&lt;RSA_PKCS1_OAEP_PADDING&gt;.
 
-The EVP_PKEY_CTX_get0_rsa_oaep_label() function gets the RSA OAEP label to
+EVP_PKEY_CTX_get0_rsa_oaep_label() gets the RSA OAEP label to
 I&lt;label&gt;. The return value is the label length. The padding mode
 must have been set to B&lt;RSA_PKCS1_OAEP_PADDING&gt;. The resulting pointer is owned
 by the library and should not be freed by the caller.
@@ -405,20 +401,20 @@ generation if I&lt;name&gt; is &quot;fips186_4&quot;, or FIPS186-2 generation if I&lt;name&gt; is
 
 =head2 DH parameters
 
-The EVP_PKEY_CTX_set_dh_paramgen_prime_len() macro sets the length of the DH
-prime parameter I&lt;p&gt; for DH parameter generation. If this macro is not called
-then 2048 is used. Only accepts lengths greater than or equal to 256.
+EVP_PKEY_CTX_set_dh_paramgen_prime_len() sets the length of the DH prime
+parameter I&lt;p&gt; for DH parameter generation. If this function is not called then
+2048 is used. Only accepts lengths greater than or equal to 256.
 
-The EVP_PKEY_CTX_set_dh_paramgen_subprime_len() macro sets the length of the DH
+EVP_PKEY_CTX_set_dh_paramgen_subprime_len() sets the length of the DH
 optional subprime parameter I&lt;q&gt; for DH parameter generation. The default is
-256 if the prime is at least 2048 bits long or 160 otherwise. The DH
-paramgen type must have been set to &quot;fips186_4&quot;.
+256 if the prime is at least 2048 bits long or 160 otherwise. The DH paramgen
+type must have been set to &quot;fips186_4&quot;.
 
-The EVP_PKEY_CTX_set_dh_paramgen_generator() macro sets DH generator to I&lt;gen&gt;
-for DH parameter generation. If not specified 2 is used.
+EVP_PKEY_CTX_set_dh_paramgen_generator() sets DH generator to I&lt;gen&gt; for DH
+parameter generation. If not specified 2 is used.
 
-The EVP_PKEY_CTX_set_dh_paramgen_type() macro sets the key type for DH
-parameter generation. The supported parameters are:
+EVP_PKEY_CTX_set_dh_paramgen_type() sets the key type for DH parameter
+generation. The supported parameters are:
 
 =over 4
 
@@ -454,7 +450,7 @@ testing purposes only and can fail if the seed does not produce primes for both
 p &amp; q on its first iteration. This value must be saved if key validation of p, q,
 and verifiable g are required, since it is not part of a persisted key.
 
-The EVP_PKEY_CTX_set_dh_pad() function sets the DH padding mode.
+EVP_PKEY_CTX_set_dh_pad() sets the DH padding mode.
 If I&lt;pad&gt; is 1 the shared secret is padded with zeros up to the size of the DH
 prime I&lt;p&gt;.
 If I&lt;pad&gt; is zero (the default) then no padding is performed.
@@ -464,15 +460,14 @@ I&lt;nid&gt; as defined in RFC7919 or RFC3526. The I&lt;nid&gt; parameter must be
 B&lt;NID_ffdhe2048&gt;, B&lt;NID_ffdhe3072&gt;, B&lt;NID_ffdhe4096&gt;, B&lt;NID_ffdhe6144&gt;,
 B&lt;NID_ffdhe8192&gt;, B&lt;NID_modp_1536&gt;, B&lt;NID_modp_2048&gt;, B&lt;NID_modp_3072&gt;,
 B&lt;NID_modp_4096&gt;, B&lt;NID_modp_6144&gt;, B&lt;NID_modp_8192&gt; or B&lt;NID_undef&gt; to clear
-the stored value. This macro can be called during parameter or key generation.
+the stored value. This function can be called during parameter or key generation.
 The nid parameter and the rfc5114 parameter are mutually exclusive.
 
-The EVP_PKEY_CTX_set_dh_rfc5114() and EVP_PKEY_CTX_set_dhx_rfc5114() macros are
-synonymous. They set the DH parameters to the values defined in RFC5114. The
-I&lt;rfc5114&gt; parameter must be 1, 2 or 3 corresponding to RFC5114 sections
-2.1, 2.2 and 2.3. or 0 to clear the stored value. This macro can be called
-during parameter generation. The I&lt;ctx&gt; must have a key type of
-B&lt;EVP_PKEY_DHX&gt;.
+EVP_PKEY_CTX_set_dh_rfc5114() and EVP_PKEY_CTX_set_dhx_rfc5114() both set the
+DH parameters to the values defined in RFC5114. The I&lt;rfc5114&gt; parameter must
+be 1, 2 or 3 corresponding to RFC5114 sections 2.1, 2.2 and 2.3. or 0 to clear
+the stored value. This macro can be called during parameter generation. The
+I&lt;ctx&gt; must have a key type of B&lt;EVP_PKEY_DHX&gt;.
 The rfc5114 parameter and the nid parameter are mutually exclusive.
 
 =head2 DH key derivation function parameters
@@ -545,8 +540,8 @@ generating an EC key.
 EVP_PKEY_CTX_get_group_name() (described above) can be used to obtain the curve
 name that's currently set with I&lt;ctx&gt;.
 
-The EVP_PKEY_CTX_set_ec_param_enc() macro sets the EC parameter encoding to
-I&lt;param_enc&gt; when generating EC parameters or an EC key. The encoding can be
+EVP_PKEY_CTX_set_ec_param_enc() sets the EC parameter encoding to I&lt;param_enc&gt;
+when generating EC parameters or an EC key. The encoding can be
 B&lt;OPENSSL_EC_EXPLICIT_CURVE&gt; for explicit parameters (the default in versions
 of OpenSSL before 1.1.0) or B&lt;OPENSSL_EC_NAMED_CURVE&gt; to use named curve form.
 For maximum compatibility the named curve form should be used. Note: the
@@ -555,67 +550,67 @@ versions should use 0 instead.
 
 =head2 ECDH parameters
 
-The EVP_PKEY_CTX_set_ecdh_cofactor_mode() macro sets the cofactor mode to
-I&lt;cofactor_mode&gt; for ECDH key derivation. Possible values are 1 to enable
-cofactor key derivation, 0 to disable it and -1 to clear the stored cofactor
-mode and fallback to the private key cofactor mode.
+EVP_PKEY_CTX_set_ecdh_cofactor_mode() sets the cofactor mode to I&lt;cofactor_mode&gt;
+for ECDH key derivation. Possible values are 1 to enable cofactor
+key derivation, 0 to disable it and -1 to clear the stored cofactor mode and
+fallback to the private key cofactor mode.
 
-The EVP_PKEY_CTX_get_ecdh_cofactor_mode() macro returns the cofactor mode for
-I&lt;ctx&gt; used for ECDH key derivation. Possible values are 1 when cofactor key
-derivation is enabled and 0 otherwise.
+EVP_PKEY_CTX_get_ecdh_cofactor_mode() returns the cofactor mode for I&lt;ctx&gt; used
+for ECDH key derivation. Possible values are 1 when cofactor key derivation is
+enabled and 0 otherwise.
 
 =head2 ECDH key derivation function parameters
 
-The EVP_PKEY_CTX_set_ecdh_kdf_type() macro sets the key derivation function type
-to I&lt;kdf&gt; for ECDH key derivation. Possible values are B&lt;EVP_PKEY_ECDH_KDF_NONE&gt;
+EVP_PKEY_CTX_set_ecdh_kdf_type() sets the key derivation function type to
+I&lt;kdf&gt; for ECDH key derivation. Possible values are B&lt;EVP_PKEY_ECDH_KDF_NONE&gt;
 and B&lt;EVP_PKEY_ECDH_KDF_X9_63&gt; which uses the key derivation specified in X9.63.
 When using key derivation, the I&lt;kdf_md&gt; and I&lt;kdf_outlen&gt; parameters must
 also be specified.
 
-The EVP_PKEY_CTX_get_ecdh_kdf_type() macro returns the key derivation function
-type for I&lt;ctx&gt; used for ECDH key derivation. Possible values are
+EVP_PKEY_CTX_get_ecdh_kdf_type() returns the key derivation function type for
+I&lt;ctx&gt; used for ECDH key derivation. Possible values are
 B&lt;EVP_PKEY_ECDH_KDF_NONE&gt; and B&lt;EVP_PKEY_ECDH_KDF_X9_63&gt;.
 
-The EVP_PKEY_CTX_set_ecdh_kdf_md() macro sets the key derivation function
-message digest to I&lt;md&gt; for ECDH key derivation. Note that X9.63 specifies
-that this digest should be SHA1 but OpenSSL tolerates other digests.
+EVP_PKEY_CTX_set_ecdh_kdf_md() sets the key derivation function message digest
+to I&lt;md&gt; for ECDH key derivation. Note that X9.63 specifies that this digest
+should be SHA1 but OpenSSL tolerates other digests.
 
-The EVP_PKEY_CTX_get_ecdh_kdf_md() macro gets the key derivation function
-message digest for I&lt;ctx&gt; used for ECDH key derivation.
+EVP_PKEY_CTX_get_ecdh_kdf_md() gets the key derivation function message digest
+for I&lt;ctx&gt; used for ECDH key derivation.
 
-The EVP_PKEY_CTX_set_ecdh_kdf_outlen() macro sets the key derivation function
-output length to I&lt;len&gt; for ECDH key derivation.
+EVP_PKEY_CTX_set_ecdh_kdf_outlen() sets the key derivation function output
+length to I&lt;len&gt; for ECDH key derivation.
 
-The EVP_PKEY_CTX_get_ecdh_kdf_outlen() macro gets the key derivation function
-output length for I&lt;ctx&gt; used for ECDH key derivation.
+EVP_PKEY_CTX_get_ecdh_kdf_outlen() gets the key derivation function output
+length for I&lt;ctx&gt; used for ECDH key derivation.
 
-The EVP_PKEY_CTX_set0_ecdh_kdf_ukm() macro sets the user key material to I&lt;ukm&gt;
-for ECDH key derivation. This parameter is optional and corresponds to the
-shared info in X9.63 terms. The library takes ownership of the user key material
-so the caller should not free the original memory pointed to by I&lt;ukm&gt;.
+EVP_PKEY_CTX_set0_ecdh_kdf_ukm() sets the user key material to I&lt;ukm&gt; for ECDH
+key derivation. This parameter is optional and corresponds to the shared info in
+X9.63 terms. The library takes ownership of the user key material so the caller
+should not free the original memory pointed to by I&lt;ukm&gt;.
 
-The EVP_PKEY_CTX_get0_ecdh_kdf_ukm() macro gets the user key material for I&lt;ctx&gt;.
+EVP_PKEY_CTX_get0_ecdh_kdf_ukm() gets the user key material for I&lt;ctx&gt;.
 The return value is the user key material length. The resulting pointer is owned
 by the library and should not be freed by the caller.
 
 =head2 Other parameters
 
-The EVP_PKEY_CTX_set1_id(), EVP_PKEY_CTX_get1_id() and EVP_PKEY_CTX_get1_id_len()
-macros are used to manipulate the special identifier field for specific signature
+EVP_PKEY_CTX_set1_id(), EVP_PKEY_CTX_get1_id() and EVP_PKEY_CTX_get1_id_len()
+are used to manipulate the special identifier field for specific signature
 algorithms such as SM2. The EVP_PKEY_CTX_set1_id() sets an ID pointed by I&lt;id&gt; with
 the length I&lt;id_len&gt; to the library. The library takes a copy of the id so that
-the caller can safely free the original memory pointed to by I&lt;id&gt;. The
-EVP_PKEY_CTX_get1_id_len() macro returns the length of the ID set via a previous
-call to EVP_PKEY_CTX_set1_id(). The length is usually used to allocate adequate
-memory for further calls to EVP_PKEY_CTX_get1_id(). The EVP_PKEY_CTX_get1_id()
-macro returns the previously set ID value to caller in I&lt;id&gt;. The caller should
+the caller can safely free the original memory pointed to by I&lt;id&gt;.
+EVP_PKEY_CTX_get1_id_len() returns the length of the ID set via a previous call
+to EVP_PKEY_CTX_set1_id(). The length is usually used to allocate adequate
+memory for further calls to EVP_PKEY_CTX_get1_id(). EVP_PKEY_CTX_get1_id()
+returns the previously set ID value to caller in I&lt;id&gt;. The caller should
 allocate adequate memory space for the I&lt;id&gt; before calling EVP_PKEY_CTX_get1_id().
 
 =head1 RETURN VALUES
 
-All other functions and macros described on this page return a positive value
-for success and 0 or a negative value for failure. In particular a return value
-of -2 indicates the operation is not supported by the public key algorithm.
+All other functions described on this page return a positive value for success
+and 0 or a negative value for failure. In particular a return value of -2
+indicates the operation is not supported by the public key algorithm.
 
 =head1 SEE ALSO
 
@@ -631,22 +626,6 @@ L&lt;EVP_PKEY_keygen(3)&gt;
 
 =head1 HISTORY
 
-EVP_PKEY_CTX_get_signature_md(), EVP_PKEY_CTX_set_signature_md(),
-EVP_PKEY_CTX_set_dh_pad(), EVP_PKEY_CTX_set_rsa_padding(),
-EVP_PKEY_CTX_get_rsa_padding(), EVP_PKEY_CTX_get_rsa_mgf1_md(),
-EVP_PKEY_CTX_set_rsa_mgf1_md(), EVP_PKEY_CTX_set_rsa_oaep_md(),
-EVP_PKEY_CTX_get_rsa_oaep_md(), EVP_PKEY_CTX_set0_rsa_oaep_label(),
-EVP_PKEY_CTX_get0_rsa_oaep_label(), EVP_PKEY_CTX_set_rsa_pss_saltlen(),
-EVP_PKEY_CTX_get_rsa_pss_saltlen(), EVP_PKEY_CTX_set_dsa_paramgen_bits(),
-EVP_PKEY_CTX_set_dsa_paramgen_q_bits(), EVP_PKEY_CTX_set_dsa_paramgen_md().
-EVP_PKEY_CTX_set_dh_kdf_type(), EVP_PKEY_CTX_get_dh_kdf_type(),
-EVP_PKEY_CTX_set0_dh_kdf_oid(), EVP_PKEY_CTX_get0_dh_kdf_oid(),
-EVP_PKEY_CTX_set_dh_kdf_md(), EVP_PKEY_CTX_get_dh_kdf_md(),
-EVP_PKEY_CTX_set_dh_kdf_outlen(), EVP_PKEY_CTX_get_dh_kdf_outlen(),
-EVP_PKEY_CTX_set0_dh_kdf_ukm() and EVP_PKEY_CTX_get0_dh_kdf_ukm()
-were macros in OpenSSL 1.1.1 and below.
-From OpenSSL 3.0 they are functions.
-
 EVP_PKEY_CTX_get_rsa_oaep_md_name(), EVP_PKEY_CTX_get_rsa_mgf1_md_name(),
 EVP_PKEY_CTX_set_rsa_mgf1_md_name(), EVP_PKEY_CTX_set_rsa_oaep_md_name(),
 EVP_PKEY_CTX_set_dsa_paramgen_md_props(), EVP_PKEY_CTX_set_dsa_paramgen_gindex(),
@@ -658,6 +637,9 @@ The EVP_PKEY_CTX_set1_id(), EVP_PKEY_CTX_get1_id() and
 EVP_PKEY_CTX_get1_id_len() macros were added in 1.1.1, other functions were
 added in OpenSSL 1.0.0.
 
+In OpenSSL 1.1.1 and below the functions were mostly macros.
+From OpenSSL 3.0 they are all functions.
+
 =head1 COPYRIGHT
 
 Copyright 2006-2020 The OpenSSL Project Authors. All Rights Reserved.
diff --git a/include/crypto/ec.h b/include/crypto/ec.h
index 587f7a39fc..071fbcad19 100644
--- a/include/crypto/ec.h
+++ b/include/crypto/ec.h
@@ -68,5 +68,7 @@ int ec_key_otherparams_fromdata(EC_KEY *ec, const OSSL_PARAM params[]);
 int ec_set_ecdh_cofactor_mode(EC_KEY *ec, int mode);
 int ec_encoding_name2id(const char *name);
 
+int evp_pkey_ctx_set_ec_param_enc_prov(EVP_PKEY_CTX *ctx, int param_enc);
+
 # endif /* OPENSSL_NO_EC */
 #endif
diff --git a/include/crypto/evp.h b/include/crypto/evp.h
index bdff97f639..4912760230 100644
--- a/include/crypto/evp.h
+++ b/include/crypto/evp.h
@@ -696,6 +696,8 @@ int evp_keymgmt_util_assign_pkey(EVP_PKEY *pkey, EVP_KEYMGMT *keymgmt,
                                  void *keydata);
 EVP_PKEY *evp_keymgmt_util_make_pkey(EVP_KEYMGMT *keymgmt, void *keydata);
 
+int evp_keymgmt_util_export(const EVP_PKEY *pk, int selection,
+                            OSSL_CALLBACK *export_cb, void *export_cbarg);
 void *evp_keymgmt_util_export_to_provider(EVP_PKEY *pk, EVP_KEYMGMT *keymgmt);
 size_t evp_keymgmt_util_find_operation_cache_index(EVP_PKEY *pk,
                                                    EVP_KEYMGMT *keymgmt);
diff --git a/include/openssl/ec.h b/include/openssl/ec.h
index 9e0a6486cd..aca52e6923 100644
--- a/include/openssl/ec.h
+++ b/include/openssl/ec.h
@@ -1470,12 +1470,7 @@ DEPRECATEDIN_3_0(void EC_KEY_METHOD_get_verify
 #  endif
 
 int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *ctx, int nid);
-
-#  define EVP_PKEY_CTX_set_ec_param_enc(ctx, flag) \
-        EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_EC, \
-                          EVP_PKEY_OP_PARAMGEN|EVP_PKEY_OP_KEYGEN, \
-                          EVP_PKEY_CTRL_EC_PARAM_ENC, flag, NULL)
-
+int EVP_PKEY_CTX_set_ec_param_enc(EVP_PKEY_CTX *ctx, int param_enc);
 int EVP_PKEY_CTX_set_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx, int cofactor_mode);
 int EVP_PKEY_CTX_get_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx);
 
diff --git a/test/build.info b/test/build.info
index 0b67d49b38..51100d1418 100644
--- a/test/build.info
+++ b/test/build.info
@@ -139,7 +139,7 @@ IF[{- !$disabled{tests} -}]
 
   SOURCE[evp_extra_test]=evp_extra_test.c
   INCLUDE[evp_extra_test]=../include ../apps/include
-  DEPEND[evp_extra_test]=../libcrypto libtestutil.a
+  DEPEND[evp_extra_test]=../libcrypto.a libtestutil.a
 
   SOURCE[evp_extra_test2]=evp_extra_test2.c
   INCLUDE[evp_extra_test2]=../include ../apps/include
diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c
index 94b95eeac8..6949b13c7a 100644
--- a/test/evp_extra_test.c
+++ b/test/evp_extra_test.c
@@ -32,6 +32,7 @@
 #include &quot;internal/nelem.h&quot;
 #include &quot;internal/sizes.h&quot;
 #include &quot;crypto/evp.h&quot;
+#include &quot;../e_os.h&quot; /* strcasecmp */
 
 #ifndef OPENSSL_NO_SM2
 /*
@@ -842,6 +843,80 @@ static int test_privatekey_to_pkcs8(void)
     return ok;
 }
 
+#ifndef OPENSSL_NO_EC
+static const struct {
+    int encoding;
+    const char *encoding_name;
+} ec_encodings[] = {
+    { OPENSSL_EC_EXPLICIT_CURVE, OSSL_PKEY_EC_ENCODING_EXPLICIT },
+    { OPENSSL_EC_NAMED_CURVE,    OSSL_PKEY_EC_ENCODING_GROUP }
+};
+
+static int ec_export_get_encoding_cb(const OSSL_PARAM params[], void *arg)
+{
+    const OSSL_PARAM *p;
+    const char *enc_name = NULL;
+    int *enc = arg;
+    size_t i;
+
+    *enc = -1;
+
+    if (!TEST_ptr(p = OSSL_PARAM_locate_const(params,
+                                              OSSL_PKEY_PARAM_EC_ENCODING))
+        || !TEST_true(OSSL_PARAM_get_utf8_string_ptr(p, &amp;enc_name)))
+        return 0;
+
+    for (i = 0; i &lt; OSSL_NELEM(ec_encodings); i++) {
+        if (strcasecmp(enc_name, ec_encodings[i].encoding_name) == 0) {
+            *enc = ec_encodings[i].encoding;
+            break;
+        }
+    }
+
+    return (*enc != -1);
+}
+
+static int test_EC_keygen_with_enc(int idx)
+{
+    EVP_PKEY *params = NULL, *key = NULL;
+    EVP_PKEY_CTX *pctx = NULL, *kctx = NULL;
+    int enc;
+    int ret = 0;
+
+    enc = ec_encodings[idx].encoding;
+
+    /* Create key parameters */
+    if (!TEST_ptr(pctx = EVP_PKEY_CTX_new_from_name(testctx, &quot;EC&quot;, NULL))
+        || !TEST_true(EVP_PKEY_paramgen_init(pctx))
+        || !TEST_true(EVP_PKEY_CTX_set_group_name(pctx, &quot;P-256&quot;))
+        || !TEST_true(EVP_PKEY_CTX_set_ec_param_enc(pctx, enc))
+        || !TEST_true(EVP_PKEY_paramgen(pctx, &amp;params))
+        || !TEST_ptr(params))
+        goto done;
+
+    /* Create key */
+    if (!TEST_ptr(kctx = EVP_PKEY_CTX_new_from_pkey(testctx, params, NULL))
+        || !TEST_true(EVP_PKEY_keygen_init(kctx))
+        || !TEST_true(EVP_PKEY_keygen(kctx, &amp;key))
+        || !TEST_ptr(key))
+        goto done;
+
+    /* Check that the encoding got all the way into the key */
+    if (!TEST_true(evp_keymgmt_util_export(key, OSSL_KEYMGMT_SELECT_ALL,
+                                           ec_export_get_encoding_cb, &amp;enc))
+        || !TEST_int_eq(enc, ec_encodings[idx].encoding))
+        goto done;
+
+    ret = 1;
+ done:
+    EVP_PKEY_free(key);
+    EVP_PKEY_free(params);
+    EVP_PKEY_CTX_free(kctx);
+    EVP_PKEY_CTX_free(pctx);
+    return ret;
+}
+#endif
+
 #if !defined(OPENSSL_NO_SM2) &amp;&amp; !defined(FIPS_MODULE)
 
 static int test_EVP_SM2_verify(void)
@@ -2029,6 +2104,9 @@ int setup_tests(void)
 #ifndef OPENSSL_NO_EC
     ADD_TEST(test_EVP_PKCS82PKEY);
 #endif
+#ifndef OPENSSL_NO_EC
+    ADD_ALL_TESTS(test_EC_keygen_with_enc, OSSL_NELEM(ec_encodings));
+#endif
 #if !defined(OPENSSL_NO_SM2) &amp;&amp; !defined(FIPS_MODULE)
     ADD_TEST(test_EVP_SM2);
     ADD_TEST(test_EVP_SM2_verify);
diff --git a/util/libcrypto.num b/util/libcrypto.num
index e3ca2fe625..efadadd94b 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -5301,3 +5301,4 @@ EVP_PKEY_CTX_get1_id                    ?	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_get1_id_len                ?	3_0_0	EXIST::FUNCTION:
 CMS_AuthEnvelopedData_create            ?	3_0_0	EXIST::FUNCTION:CMS
 CMS_AuthEnvelopedData_create_with_libctx ?	3_0_0	EXIST::FUNCTION:CMS
+EVP_PKEY_CTX_set_ec_param_enc           ?	3_0_0	EXIST::FUNCTION:EC
</PRE>




















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030637.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="030640.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30639">[ date ]</a>
              <a href="thread.html#30639">[ thread ]</a>
              <a href="subject.html#30639">[ subject ]</a>
              <a href="author.html#30639">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
