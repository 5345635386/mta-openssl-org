<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-September/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1600846568.788267.6240.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030860.html">
   <LINK REL="Next"  HREF="030863.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>shane.lontis at oracle.com</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1600846568.788267.6240.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">shane.lontis at oracle.com
       </A><BR>
    <I>Wed Sep 23 07:36:08 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="030860.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="030863.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30861">[ date ]</a>
              <a href="thread.html#30861">[ thread ]</a>
              <a href="subject.html#30861">[ subject ]</a>
              <a href="author.html#30861">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  e771249c4f6bfb5b49d2c018447bcaa0039fd862 (commit)
       via  0ecec0fa081a717db49d2ae10135cf285b95409d (commit)
       via  851886b061c9c9e5574fd23ea95149ffd52e8693 (commit)
       via  c4b3ea73a7b2be5cdbfc0036ec0b1fead1fcd898 (commit)
       via  8dbef010e7e6ecc07a9c8142cf26c8768fd55dc2 (commit)
       via  7f80980fb7096ab4898e500a054a1bb8cbcaa266 (commit)
       via  26496f5a5cc44f3250198d22b353403a54f5e29b (commit)
       via  719523c76df0850ba736ede48cc86d48eed9f725 (commit)
      from  81777339e9ed62cd3b801bf225fa1f2aba4b30dd (commit)


- Log -----------------------------------------------------------------
commit e771249c4f6bfb5b49d2c018447bcaa0039fd862
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Tue Sep 22 15:57:19 2020 +1000

    Fix propq in x942kdf
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12944">https://github.com/openssl/openssl/pull/12944</A>)

commit 0ecec0fa081a717db49d2ae10135cf285b95409d
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Tue Sep 22 15:56:11 2020 +1000

    Fix missing propq in sm2
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12944">https://github.com/openssl/openssl/pull/12944</A>)

commit 851886b061c9c9e5574fd23ea95149ffd52e8693
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Tue Sep 22 15:53:58 2020 +1000

    Fix missing propq in ffc_params_generate
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12944">https://github.com/openssl/openssl/pull/12944</A>)

commit c4b3ea73a7b2be5cdbfc0036ec0b1fead1fcd898
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Tue Sep 22 15:53:27 2020 +1000

    Fix missing propq in ecdh_cms_set_shared_info()
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12944">https://github.com/openssl/openssl/pull/12944</A>)

commit 8dbef010e7e6ecc07a9c8142cf26c8768fd55dc2
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Tue Sep 22 15:51:49 2020 +1000

    Fix ecx so that is uses a settable propertyquery
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12944">https://github.com/openssl/openssl/pull/12944</A>)

commit 7f80980fb7096ab4898e500a054a1bb8cbcaa266
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Tue Sep 22 15:48:45 2020 +1000

    Fix ssl_hmac_new() so that it uses the propq
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12944">https://github.com/openssl/openssl/pull/12944</A>)

commit 26496f5a5cc44f3250198d22b353403a54f5e29b
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Tue Sep 22 15:45:17 2020 +1000

    Fix EVP_KDF_scrypt so that is uses a propq for its fetch.
    
    The parameter can be set via settable parameter OSSL_KDF_PARAM_PROPERTIES
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12944">https://github.com/openssl/openssl/pull/12944</A>)

commit 719523c76df0850ba736ede48cc86d48eed9f725
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Tue Sep 22 15:43:32 2020 +1000

    Change rsa gen so it can use the propq from OSSL_PKEY_PARAM_RSA_DIGEST
    
    rsa_pss_params_30_fromdata() now uses the OSSL_PKEY_PARAM_RSA_DIGEST_PROPS parameter also.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/12944">https://github.com/openssl/openssl/pull/12944</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/ec/curve25519.c                        |  4 +-
 crypto/ec/curve448/curve448_local.h           |  4 +-
 crypto/ec/curve448/ed448.h                    | 18 ++++---
 crypto/ec/curve448/eddsa.c                    | 63 ++++++++++++++-----------
 crypto/ec/ec_ameth.c                          |  2 +-
 crypto/ec/ecx_backend.c                       |  6 ++-
 crypto/ec/ecx_key.c                           | 19 ++++++--
 crypto/ec/ecx_meth.c                          | 45 +++++++++---------
 crypto/ffc/ffc_params_generate.c              |  4 +-
 crypto/rsa/rsa_ameth.c                        |  2 +-
 crypto/rsa/rsa_backend.c                      | 15 ++++--
 crypto/sm2/sm2_pmeth.c                        |  6 ++-
 doc/man7/EVP_KDF-SCRYPT.pod                   | 11 ++++-
 include/crypto/ecx.h                          | 12 +++--
 include/crypto/rsa.h                          |  2 +-
 include/openssl/core_names.h                  |  1 +
 providers/implementations/kdfs/scrypt.c       | 53 +++++++++++++++++----
 providers/implementations/kdfs/x942kdf.c      | 17 +++++--
 providers/implementations/keymgmt/ecx_kmgmt.c | 67 +++++++++++++++++++++------
 providers/implementations/keymgmt/rsa_kmgmt.c |  6 ++-
 providers/implementations/signature/eddsa.c   |  6 +--
 ssl/t1_lib.c                                  |  2 +-
 test/curve448_internal_test.c                 | 22 ++++-----
 23 files changed, 256 insertions(+), 131 deletions(-)

diff --git a/crypto/ec/curve25519.c b/crypto/ec/curve25519.c
index 19fdb8d74f..b945c35f29 100644
--- a/crypto/ec/curve25519.c
+++ b/crypto/ec/curve25519.c
@@ -5578,14 +5578,14 @@ err:
 }
 
 int ED25519_public_from_private(OPENSSL_CTX *ctx, uint8_t out_public_key[32],
-                                const uint8_t private_key[32])
+                                const uint8_t private_key[32], const char *propq)
 {
     uint8_t az[SHA512_DIGEST_LENGTH];
     ge_p3 A;
     int r;
     EVP_MD *sha512 = NULL;
 
-    sha512 = EVP_MD_fetch(ctx, SN_sha512, NULL);
+    sha512 = EVP_MD_fetch(ctx, SN_sha512, propq);
     if (sha512 == NULL)
         return 0;
     r = EVP_Digest(private_key, 32, az, NULL, sha512, NULL);
diff --git a/crypto/ec/curve448/curve448_local.h b/crypto/ec/curve448/curve448_local.h
index 84dd157d94..62a61fd979 100644
--- a/crypto/ec/curve448/curve448_local.h
+++ b/crypto/ec/curve448/curve448_local.h
@@ -12,10 +12,10 @@
 
 int ED448ph_sign(OPENSSL_CTX *ctx, uint8_t *out_sig, const uint8_t hash[64],
                  const uint8_t public_key[57], const uint8_t private_key[57],
-                 const uint8_t *context, size_t context_len);
+                 const uint8_t *context, size_t context_len, const char *propq);
 
 int ED448ph_verify(OPENSSL_CTX *ctx, const uint8_t hash[64],
                    const uint8_t signature[114], const uint8_t public_key[57],
-                   const uint8_t *context, size_t context_len);
+                   const uint8_t *context, size_t context_len, const char *propq);
 
 #endif              /* OSSL_CRYPTO_EC_CURVE448_LOCAL_H */
diff --git a/crypto/ec/curve448/ed448.h b/crypto/ec/curve448/ed448.h
index 4f99fe6901..16248b28cc 100644
--- a/crypto/ec/curve448/ed448.h
+++ b/crypto/ec/curve448/ed448.h
@@ -40,7 +40,8 @@
 c448_error_t c448_ed448_derive_public_key(
                         OPENSSL_CTX *ctx,
                         uint8_t pubkey [EDDSA_448_PUBLIC_BYTES],
-                        const uint8_t privkey [EDDSA_448_PRIVATE_BYTES]);
+                        const uint8_t privkey [EDDSA_448_PRIVATE_BYTES],
+                        const char *propq);
 
 /*
  * EdDSA signing.
@@ -66,7 +67,8 @@ c448_error_t c448_ed448_sign(
                         const uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],
                         const uint8_t *message, size_t message_len,
                         uint8_t prehashed, const uint8_t *context,
-                        size_t context_len);
+                        size_t context_len,
+                        const char *propq);
 
 /*
  * EdDSA signing with prehash.
@@ -91,7 +93,8 @@ c448_error_t c448_ed448_sign_prehash(
                         const uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],
                         const uint8_t hash[64],
                         const uint8_t *context,
-                        size_t context_len);
+                        size_t context_len,
+                        const char *propq);
 
 /*
  * EdDSA signature verification.
@@ -118,7 +121,8 @@ c448_error_t c448_ed448_verify(OPENSSL_CTX *ctx,
                                pubkey[EDDSA_448_PUBLIC_BYTES],
                                const uint8_t *message, size_t message_len,
                                uint8_t prehashed, const uint8_t *context,
-                               uint8_t context_len);
+                               uint8_t context_len,
+                               const char *propq);
 
 /*
  * EdDSA signature verification.
@@ -143,7 +147,8 @@ c448_error_t c448_ed448_verify_prehash(
                     const uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],
                     const uint8_t hash[64],
                     const uint8_t *context,
-                    uint8_t context_len);
+                    uint8_t context_len,
+                    const char *propq);
 
 /*
  * EdDSA point encoding.  Used internally, exposed externally.
@@ -196,6 +201,7 @@ c448_error_t curve448_point_decode_like_eddsa_and_mul_by_ratio(
 c448_error_t c448_ed448_convert_private_key_to_x448(
                             OPENSSL_CTX *ctx,
                             uint8_t x[X448_PRIVATE_BYTES],
-                            const uint8_t ed[EDDSA_448_PRIVATE_BYTES]);
+                            const uint8_t ed[EDDSA_448_PRIVATE_BYTES],
+                            const char *propq);
 
 #endif                          /* OSSL_CRYPTO_EC_CURVE448_ED448_H */
diff --git a/crypto/ec/curve448/eddsa.c b/crypto/ec/curve448/eddsa.c
index f4fbaf7539..51a14642dc 100644
--- a/crypto/ec/curve448/eddsa.c
+++ b/crypto/ec/curve448/eddsa.c
@@ -21,7 +21,8 @@
 #define COFACTOR 4
 
 static c448_error_t oneshot_hash(OPENSSL_CTX *ctx, uint8_t *out, size_t outlen,
-                                 const uint8_t *in, size_t inlen)
+                                 const uint8_t *in, size_t inlen,
+                                 const char *propq)
 {
     EVP_MD_CTX *hashctx = EVP_MD_CTX_new();
     EVP_MD *shake256 = NULL;
@@ -30,7 +31,7 @@ static c448_error_t oneshot_hash(OPENSSL_CTX *ctx, uint8_t *out, size_t outlen,
     if (hashctx == NULL)
         return C448_FAILURE;
 
-    shake256 = EVP_MD_fetch(ctx, &quot;SHAKE256&quot;, NULL);
+    shake256 = EVP_MD_fetch(ctx, &quot;SHAKE256&quot;, propq);
     if (shake256 == NULL)
         goto err;
 
@@ -57,7 +58,8 @@ static c448_error_t hash_init_with_dom(OPENSSL_CTX *ctx, EVP_MD_CTX *hashctx,
                                        uint8_t prehashed,
                                        uint8_t for_prehash,
                                        const uint8_t *context,
-                                       size_t context_len)
+                                       size_t context_len,
+                                       const char *propq)
 {
 #ifdef CHARSET_EBCDIC
     const char dom_s[] = {0x53, 0x69, 0x67, 0x45,
@@ -75,7 +77,7 @@ static c448_error_t hash_init_with_dom(OPENSSL_CTX *ctx, EVP_MD_CTX *hashctx,
                        - (for_prehash == 0 ? 1 : 0));
     dom[1] = (uint8_t)context_len;
 
-    shake256 = EVP_MD_fetch(ctx, &quot;SHAKE256&quot;, NULL);
+    shake256 = EVP_MD_fetch(ctx, &quot;SHAKE256&quot;, propq);
     if (shake256 == NULL)
         return C448_FAILURE;
 
@@ -95,18 +97,20 @@ static c448_error_t hash_init_with_dom(OPENSSL_CTX *ctx, EVP_MD_CTX *hashctx,
 c448_error_t c448_ed448_convert_private_key_to_x448(
                             OPENSSL_CTX *ctx,
                             uint8_t x[X448_PRIVATE_BYTES],
-                            const uint8_t ed [EDDSA_448_PRIVATE_BYTES])
+                            const uint8_t ed [EDDSA_448_PRIVATE_BYTES],
+                            const char *propq)
 {
     /* pass the private key through oneshot_hash function */
     /* and keep the first X448_PRIVATE_BYTES bytes */
     return oneshot_hash(ctx, x, X448_PRIVATE_BYTES, ed,
-                        EDDSA_448_PRIVATE_BYTES);
+                        EDDSA_448_PRIVATE_BYTES, propq);
 }
 
 c448_error_t c448_ed448_derive_public_key(
                         OPENSSL_CTX *ctx,
                         uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],
-                        const uint8_t privkey[EDDSA_448_PRIVATE_BYTES])
+                        const uint8_t privkey[EDDSA_448_PRIVATE_BYTES],
+                        const char *propq)
 {
     /* only this much used for keygen */
     uint8_t secret_scalar_ser[EDDSA_448_PRIVATE_BYTES];
@@ -116,7 +120,8 @@ c448_error_t c448_ed448_derive_public_key(
 
     if (!oneshot_hash(ctx, secret_scalar_ser, sizeof(secret_scalar_ser),
                       privkey,
-                      EDDSA_448_PRIVATE_BYTES))
+                      EDDSA_448_PRIVATE_BYTES,
+                      propq))
         return C448_FAILURE;
 
     clamp(secret_scalar_ser);
@@ -154,7 +159,7 @@ c448_error_t c448_ed448_sign(
                         const uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],
                         const uint8_t *message, size_t message_len,
                         uint8_t prehashed, const uint8_t *context,
-                        size_t context_len)
+                        size_t context_len, const char *propq)
 {
     curve448_scalar_t secret_scalar;
     EVP_MD_CTX *hashctx = EVP_MD_CTX_new();
@@ -175,7 +180,7 @@ c448_error_t c448_ed448_sign(
         uint8_t expanded[EDDSA_448_PRIVATE_BYTES * 2];
 
         if (!oneshot_hash(ctx, expanded, sizeof(expanded), privkey,
-                          EDDSA_448_PRIVATE_BYTES))
+                          EDDSA_448_PRIVATE_BYTES, propq))
             goto err;
         clamp(expanded);
         curve448_scalar_decode_long(secret_scalar, expanded,
@@ -183,7 +188,7 @@ c448_error_t c448_ed448_sign(
 
         /* Hash to create the nonce */
         if (!hash_init_with_dom(ctx, hashctx, prehashed, 0, context,
-                                context_len)
+                                context_len, propq)
                 || !EVP_DigestUpdate(hashctx,
                                      expanded + EDDSA_448_PRIVATE_BYTES,
                                      EDDSA_448_PRIVATE_BYTES)
@@ -224,7 +229,8 @@ c448_error_t c448_ed448_sign(
         uint8_t challenge[2 * EDDSA_448_PRIVATE_BYTES];
 
         /* Compute the challenge */
-        if (!hash_init_with_dom(ctx, hashctx, prehashed, 0, context, context_len)
+        if (!hash_init_with_dom(ctx, hashctx, prehashed, 0, context, context_len,
+                                propq)
                 || !EVP_DigestUpdate(hashctx, nonce_point, sizeof(nonce_point))
                 || !EVP_DigestUpdate(hashctx, pubkey, EDDSA_448_PUBLIC_BYTES)
                 || !EVP_DigestUpdate(hashctx, message, message_len)
@@ -260,10 +266,10 @@ c448_error_t c448_ed448_sign_prehash(
                         const uint8_t privkey[EDDSA_448_PRIVATE_BYTES],
                         const uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],
                         const uint8_t hash[64], const uint8_t *context,
-                        size_t context_len)
+                        size_t context_len, const char *propq)
 {
     return c448_ed448_sign(ctx, signature, privkey, pubkey, hash, 64, 1,
-                           context, context_len);
+                           context, context_len, propq);
 }
 
 c448_error_t c448_ed448_verify(
@@ -272,7 +278,7 @@ c448_error_t c448_ed448_verify(
                     const uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],
                     const uint8_t *message, size_t message_len,
                     uint8_t prehashed, const uint8_t *context,
-                    uint8_t context_len)
+                    uint8_t context_len, const char *propq)
 {
     curve448_point_t pk_point, r_point;
     c448_error_t error;
@@ -321,7 +327,7 @@ c448_error_t c448_ed448_verify(
 
         if (hashctx == NULL
                 || !hash_init_with_dom(ctx, hashctx, prehashed, 0, context,
-                                       context_len)
+                                       context_len, propq)
                 || !EVP_DigestUpdate(hashctx, signature, EDDSA_448_PUBLIC_BYTES)
                 || !EVP_DigestUpdate(hashctx, pubkey, EDDSA_448_PUBLIC_BYTES)
                 || !EVP_DigestUpdate(hashctx, message, message_len)
@@ -354,50 +360,51 @@ c448_error_t c448_ed448_verify_prehash(
                     const uint8_t signature[EDDSA_448_SIGNATURE_BYTES],
                     const uint8_t pubkey[EDDSA_448_PUBLIC_BYTES],
                     const uint8_t hash[64], const uint8_t *context,
-                    uint8_t context_len)
+                    uint8_t context_len, const char *propq)
 {
     return c448_ed448_verify(ctx, signature, pubkey, hash, 64, 1, context,
-                             context_len);
+                             context_len, propq);
 }
 
 int ED448_sign(OPENSSL_CTX *ctx, uint8_t *out_sig, const uint8_t *message,
                size_t message_len, const uint8_t public_key[57],
                const uint8_t private_key[57], const uint8_t *context,
-               size_t context_len)
+               size_t context_len, const char *propq)
 {
     return c448_ed448_sign(ctx, out_sig, private_key, public_key, message,
-                           message_len, 0, context, context_len)
+                           message_len, 0, context, context_len,propq)
         == C448_SUCCESS;
 }
 
 int ED448_verify(OPENSSL_CTX *ctx, const uint8_t *message, size_t message_len,
                  const uint8_t signature[114], const uint8_t public_key[57],
-                 const uint8_t *context, size_t context_len)
+                 const uint8_t *context, size_t context_len, const char *propq)
 {
     return c448_ed448_verify(ctx, signature, public_key, message, message_len,
-                             0, context, (uint8_t)context_len) == C448_SUCCESS;
+                             0, context, (uint8_t)context_len,
+                             propq) == C448_SUCCESS;
 }
 
 int ED448ph_sign(OPENSSL_CTX *ctx, uint8_t *out_sig, const uint8_t hash[64],
                  const uint8_t public_key[57], const uint8_t private_key[57],
-                 const uint8_t *context, size_t context_len)
+                 const uint8_t *context, size_t context_len, const char *propq)
 {
     return c448_ed448_sign_prehash(ctx, out_sig, private_key, public_key, hash,
-                                   context, context_len) == C448_SUCCESS;
+                                   context, context_len, propq) == C448_SUCCESS;
 
 }
 
 int ED448ph_verify(OPENSSL_CTX *ctx, const uint8_t hash[64],
                    const uint8_t signature[114], const uint8_t public_key[57],
-                   const uint8_t *context, size_t context_len)
+                   const uint8_t *context, size_t context_len, const char *propq)
 {
     return c448_ed448_verify_prehash(ctx, signature, public_key, hash, context,
-                                     (uint8_t)context_len) == C448_SUCCESS;
+                                     (uint8_t)context_len, propq) == C448_SUCCESS;
 }
 
 int ED448_public_from_private(OPENSSL_CTX *ctx, uint8_t out_public_key[57],
-                              const uint8_t private_key[57])
+                              const uint8_t private_key[57], const char *propq)
 {
-    return c448_ed448_derive_public_key(ctx, out_public_key, private_key)
+    return c448_ed448_derive_public_key(ctx, out_public_key, private_key, propq)
         == C448_SUCCESS;
 }
diff --git a/crypto/ec/ec_ameth.c b/crypto/ec/ec_ameth.c
index 67705d6fe4..75f82739ec 100644
--- a/crypto/ec/ec_ameth.c
+++ b/crypto/ec/ec_ameth.c
@@ -962,7 +962,7 @@ static int ecdh_cms_set_shared_info(EVP_PKEY_CTX *pctx, CMS_RecipientInfo *ri)
     if (kekctx == NULL)
         goto err;
     name = OBJ_nid2sn(OBJ_obj2nid(kekalg-&gt;algorithm));
-    kekcipher = EVP_CIPHER_fetch(pctx-&gt;libctx, name, NULL);
+    kekcipher = EVP_CIPHER_fetch(pctx-&gt;libctx, name, pctx-&gt;propquery);
     if (kekcipher == NULL || EVP_CIPHER_mode(kekcipher) != EVP_CIPH_WRAP_MODE)
         goto err;
     if (!EVP_EncryptInit_ex(kekctx, kekcipher, NULL, NULL, NULL))
diff --git a/crypto/ec/ecx_backend.c b/crypto/ec/ecx_backend.c
index 042f9ca8da..d1e652ae4f 100644
--- a/crypto/ec/ecx_backend.c
+++ b/crypto/ec/ecx_backend.c
@@ -27,7 +27,8 @@ int ecx_public_from_private(ECX_KEY *key)
         X25519_public_from_private(key-&gt;pubkey, key-&gt;privkey);
         break;
     case ECX_KEY_TYPE_ED25519:
-        if (!ED25519_public_from_private(key-&gt;libctx, key-&gt;pubkey, key-&gt;privkey)) {
+        if (!ED25519_public_from_private(key-&gt;libctx, key-&gt;pubkey, key-&gt;privkey,
+                                         key-&gt;propq)) {
             ECerr(0, EC_R_FAILED_MAKING_PUBLIC_KEY);
             return 0;
         }
@@ -36,7 +37,8 @@ int ecx_public_from_private(ECX_KEY *key)
         X448_public_from_private(key-&gt;pubkey, key-&gt;privkey);
         break;
     case ECX_KEY_TYPE_ED448:
-        if (!ED448_public_from_private(key-&gt;libctx, key-&gt;pubkey, key-&gt;privkey)) {
+        if (!ED448_public_from_private(key-&gt;libctx, key-&gt;pubkey, key-&gt;privkey,
+                                       key-&gt;propq)) {
             ECerr(0, EC_R_FAILED_MAKING_PUBLIC_KEY);
             return 0;
         }
diff --git a/crypto/ec/ecx_key.c b/crypto/ec/ecx_key.c
index 46abd57a74..dd4b872ab0 100644
--- a/crypto/ec/ecx_key.c
+++ b/crypto/ec/ecx_key.c
@@ -10,7 +10,8 @@
 #include &lt;openssl/err.h&gt;
 #include &quot;crypto/ecx.h&quot;
 
-ECX_KEY *ecx_key_new(OPENSSL_CTX *libctx, ECX_KEY_TYPE type, int haspubkey)
+ECX_KEY *ecx_key_new(OPENSSL_CTX *libctx, ECX_KEY_TYPE type, int haspubkey,
+                     const char *propq)
 {
     ECX_KEY *ret = OPENSSL_zalloc(sizeof(*ret));
 
@@ -36,14 +37,21 @@ ECX_KEY *ecx_key_new(OPENSSL_CTX *libctx, ECX_KEY_TYPE type, int haspubkey)
     ret-&gt;type = type;
     ret-&gt;references = 1;
 
-    ret-&gt;lock = CRYPTO_THREAD_lock_new();
-    if (ret-&gt;lock == NULL) {
+    if (propq != NULL) {
+        ret-&gt;propq = OPENSSL_strdup(propq);
         ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
-        OPENSSL_free(ret);
-        return NULL;
+        if (ret-&gt;propq == NULL)
+            goto err;
     }
 
+    ret-&gt;lock = CRYPTO_THREAD_lock_new();
+    if (ret-&gt;lock == NULL)
+        goto err;
     return ret;
+err:
+    ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
+    OPENSSL_free(ret);
+    return NULL;
 }
 
 void ecx_key_free(ECX_KEY *key)
@@ -59,6 +67,7 @@ void ecx_key_free(ECX_KEY *key)
         return;
     REF_ASSERT_ISNT(i &lt; 0);
 
+    OPENSSL_free(key-&gt;propq);
     OPENSSL_secure_clear_free(key-&gt;privkey, key-&gt;keylen);
     CRYPTO_THREAD_lock_free(key-&gt;lock);
     OPENSSL_free(key);
diff --git a/crypto/ec/ecx_meth.c b/crypto/ec/ecx_meth.c
index 75693e35f7..99f1e480c1 100644
--- a/crypto/ec/ecx_meth.c
+++ b/crypto/ec/ecx_meth.c
@@ -59,7 +59,7 @@ static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
         }
     }
 
-    key = ecx_key_new(libctx, KEYNID2TYPE(id), 1);
+    key = ecx_key_new(libctx, KEYNID2TYPE(id), 1, propq);
     if (key == NULL) {
         ECerr(EC_F_ECX_KEY_OP, ERR_R_MALLOC_FAILURE);
         return 0;
@@ -75,7 +75,7 @@ static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
             goto err;
         }
         if (op == KEY_OP_KEYGEN) {
-            if (RAND_priv_bytes(privkey, KEYLENID(id)) &lt;= 0)
+            if (RAND_priv_bytes_ex(libctx, privkey, KEYLENID(id)) &lt;= 0)
                 goto err;
             if (id == EVP_PKEY_X25519) {
                 privkey[0] &amp;= 248;
@@ -439,7 +439,8 @@ static int ecx_generic_import_from(const OSSL_PARAM params[], void *vpctx,
 {
     EVP_PKEY_CTX *pctx = vpctx;
     EVP_PKEY *pkey = EVP_PKEY_CTX_get0_pkey(pctx);
-    ECX_KEY *ecx = ecx_key_new(pctx-&gt;libctx, KEYNID2TYPE(keytype), 0);
+    ECX_KEY *ecx = ecx_key_new(pctx-&gt;libctx, KEYNID2TYPE(keytype), 0,
+                               pctx-&gt;propquery);
 
     if (ecx == NULL) {
         ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
@@ -862,12 +863,8 @@ static int pkey_ecd_digestsign448(EVP_MD_CTX *ctx, unsigned char *sig,
         return 0;
     }
 
-    /*
-     * TODO(3.0): We use NULL for the library context for now. Will need to
-     * change later.
-     */
-    if (ED448_sign(NULL, sig, tbs, tbslen, edkey-&gt;pubkey, edkey-&gt;privkey,
-                   NULL, 0) == 0)
+    if (ED448_sign(edkey-&gt;libctx, sig, tbs, tbslen, edkey-&gt;pubkey, edkey-&gt;privkey,
+                   NULL, 0, edkey-&gt;propq) == 0)
         return 0;
     *siglen = ED448_SIGSIZE;
     return 1;
@@ -882,7 +879,8 @@ static int pkey_ecd_digestverify25519(EVP_MD_CTX *ctx, const unsigned char *sig,
     if (siglen != ED25519_SIGSIZE)
         return 0;
 
-    return ED25519_verify(tbs, tbslen, sig, edkey-&gt;pubkey, NULL, NULL);
+    return ED25519_verify(tbs, tbslen, sig, edkey-&gt;pubkey,
+                          edkey-&gt;libctx, edkey-&gt;propq);
 }
 
 static int pkey_ecd_digestverify448(EVP_MD_CTX *ctx, const unsigned char *sig,
@@ -894,11 +892,8 @@ static int pkey_ecd_digestverify448(EVP_MD_CTX *ctx, const unsigned char *sig,
     if (siglen != ED448_SIGSIZE)
         return 0;
 
-    /*
-     * TODO(3.0): We send NULL for the OPENSSL_CTX for now. This will need to
-     * change.
-     */
-    return ED448_verify(NULL, tbs, tbslen, sig, edkey-&gt;pubkey, NULL, 0);
+    return ED448_verify(edkey-&gt;libctx, tbs, tbslen, sig, edkey-&gt;pubkey, NULL, 0,
+                        edkey-&gt;propq);
 }
 
 static int pkey_ecd_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
@@ -949,7 +944,8 @@ static int s390x_pkey_ecx_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
     };
-    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_X25519, 1);
+    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_X25519, 1,
+                               ctx-&gt;propquery);
     unsigned char *privkey = NULL, *pubkey;
 
     if (key == NULL) {
@@ -965,7 +961,7 @@ static int s390x_pkey_ecx_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         goto err;
     }
 
-    if (RAND_priv_bytes(privkey, X25519_KEYLEN) &lt;= 0)
+    if (RAND_priv_bytes_ex(ctx-&gt;libctx, privkey, X25519_KEYLEN) &lt;= 0)
         goto err;
 
     privkey[0] &amp;= 248;
@@ -991,7 +987,8 @@ static int s390x_pkey_ecx_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
     };
-    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_X448, 1);
+    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_X448, 1,
+                               ctx-&gt;propquery);
     unsigned char *privkey = NULL, *pubkey;
 
     if (key == NULL) {
@@ -1007,7 +1004,7 @@ static int s390x_pkey_ecx_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         goto err;
     }
 
-    if (RAND_priv_bytes(privkey, X448_KEYLEN) &lt;= 0)
+    if (RAND_priv_bytes_ex(ctx-&gt;libctx, privkey, X448_KEYLEN) &lt;= 0)
         goto err;
 
     privkey[0] &amp;= 252;
@@ -1036,7 +1033,8 @@ static int s390x_pkey_ecd_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
     };
     unsigned char x_dst[32], buff[SHA512_DIGEST_LENGTH];
-    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_ED25519, 1);
+    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_ED25519, 1,
+                               ctx-&gt;propquery);
     unsigned char *privkey = NULL, *pubkey;
     unsigned int sz;
 
@@ -1053,7 +1051,7 @@ static int s390x_pkey_ecd_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         goto err;
     }
 
-    if (RAND_priv_bytes(privkey, ED25519_KEYLEN) &lt;= 0)
+    if (RAND_priv_bytes_ex(ctx-&gt;libctx, privkey, ED25519_KEYLEN) &lt;= 0)
         goto err;
 
     if (!EVP_Digest(privkey, 32, buff, &amp;sz, EVP_sha512(), NULL))
@@ -1093,7 +1091,8 @@ static int s390x_pkey_ecd_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         0x24, 0xbc, 0xb6, 0x6e, 0x71, 0x46, 0x3f, 0x69, 0x00
     };
     unsigned char x_dst[57], buff[114];
-    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_ED448, 1);
+    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_ED448, 1,
+                               ctx-&gt;propquery);
     unsigned char *privkey = NULL, *pubkey;
     EVP_MD_CTX *hashctx = NULL;
 
@@ -1110,7 +1109,7 @@ static int s390x_pkey_ecd_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         goto err;
     }
 
-    if (RAND_priv_bytes(privkey, ED448_KEYLEN) &lt;= 0)
+    if (RAND_priv_bytes_ex(ctx-&gt;libctx, privkey, ED448_KEYLEN) &lt;= 0)
         goto err;
 
     hashctx = EVP_MD_CTX_new();
diff --git a/crypto/ffc/ffc_params_generate.c b/crypto/ffc/ffc_params_generate.c
index 1fe8e4a6a5..a289270347 100644
--- a/crypto/ffc/ffc_params_generate.c
+++ b/crypto/ffc/ffc_params_generate.c
@@ -542,7 +542,7 @@ int ffc_params_FIPS186_4_gen_verify(OPENSSL_CTX *libctx, FFC_PARAMS *params,
             *res = FFC_CHECK_INVALID_Q_VALUE;
             goto err;
         }
-        md = EVP_MD_fetch(libctx, def_name, NULL);
+        md = EVP_MD_fetch(libctx, def_name, params-&gt;mdprops);
     }
     if (md == NULL)
         goto err;
@@ -835,7 +835,7 @@ int ffc_params_FIPS186_2_gen_verify(OPENSSL_CTX *libctx, FFC_PARAMS *params,
             *res = FFC_CHECK_INVALID_Q_VALUE;
             goto err;
         }
-        md = EVP_MD_fetch(libctx, def_name, NULL);
+        md = EVP_MD_fetch(libctx, def_name, params-&gt;mdprops);
     }
     if (md == NULL)
         goto err;
diff --git a/crypto/rsa/rsa_ameth.c b/crypto/rsa/rsa_ameth.c
index 6558e1c662..814452f27d 100644
--- a/crypto/rsa/rsa_ameth.c
+++ b/crypto/rsa/rsa_ameth.c
@@ -1239,7 +1239,7 @@ static int rsa_int_export_to(const EVP_PKEY *from, int rsa_type,
             || !rsa_pss_params_30_set_hashalg(&amp;pss_params, md_nid)
             || !rsa_pss_params_30_set_maskgenhashalg(&amp;pss_params, mgf1md_nid)
             || !rsa_pss_params_30_set_saltlen(&amp;pss_params, saltlen)
-            || !rsa_pss_params_30_todata(&amp;pss_params, propq, tmpl, NULL))
+            || !rsa_pss_params_30_todata(&amp;pss_params, tmpl, NULL))
             goto err;
         selection |= OSSL_KEYMGMT_SELECT_OTHER_PARAMETERS;
     }
diff --git a/crypto/rsa/rsa_backend.c b/crypto/rsa/rsa_backend.c
index 871aa17a22..fae09d7067 100644
--- a/crypto/rsa/rsa_backend.c
+++ b/crypto/rsa/rsa_backend.c
@@ -163,7 +163,7 @@ int rsa_todata(RSA *rsa, OSSL_PARAM_BLD *bld, OSSL_PARAM params[])
     return ret;
 }
 
-int rsa_pss_params_30_todata(const RSA_PSS_PARAMS_30 *pss, const char *propq,
+int rsa_pss_params_30_todata(const RSA_PSS_PARAMS_30 *pss,
                              OSSL_PARAM_BLD *bld, OSSL_PARAM params[])
 {
     if (!rsa_pss_params_30_is_unrestricted(pss)) {
@@ -211,13 +211,16 @@ int rsa_pss_params_30_fromdata(RSA_PSS_PARAMS_30 *pss_params,
                                const OSSL_PARAM params[], OPENSSL_CTX *libctx)
 {
     const OSSL_PARAM *param_md, *param_mgf, *param_mgf1md,  *param_saltlen;
+    const OSSL_PARAM *param_propq;
+    const char *propq = NULL;
     EVP_MD *md = NULL, *mgf1md = NULL;
     int saltlen;
     int ret = 0;
 
     if (pss_params == NULL)
         return 0;
-
+    param_propq =
+        OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_DIGEST_PROPS);
     param_md =
         OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_DIGEST);
     param_mgf =
@@ -227,6 +230,10 @@ int rsa_pss_params_30_fromdata(RSA_PSS_PARAMS_30 *pss_params,
     param_saltlen =
         OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_RSA_PSS_SALTLEN);
 
+    if (param_propq != NULL) {
+        if (param_propq-&gt;data_type == OSSL_PARAM_UTF8_STRING)
+            propq = param_propq-&gt;data;
+    }
     /*
      * If we get any of the parameters, we know we have at least some
      * restrictions, so we start by setting default values, and let each
@@ -265,7 +272,7 @@ int rsa_pss_params_30_fromdata(RSA_PSS_PARAMS_30 *pss_params,
         else if (!OSSL_PARAM_get_utf8_ptr(param_mgf, &amp;mdname))
             goto err;
 
-        if ((md = EVP_MD_fetch(libctx, mdname, NULL)) == NULL
+        if ((md = EVP_MD_fetch(libctx, mdname, propq)) == NULL
             || !rsa_pss_params_30_set_hashalg(pss_params,
                                               rsa_oaeppss_md2nid(md)))
             goto err;
@@ -279,7 +286,7 @@ int rsa_pss_params_30_fromdata(RSA_PSS_PARAMS_30 *pss_params,
         else if (!OSSL_PARAM_get_utf8_ptr(param_mgf, &amp;mgf1mdname))
             goto err;
 
-        if ((mgf1md = EVP_MD_fetch(libctx, mgf1mdname, NULL)) == NULL
+        if ((mgf1md = EVP_MD_fetch(libctx, mgf1mdname, propq)) == NULL
             || !rsa_pss_params_30_set_maskgenhashalg(pss_params,
                                                      rsa_oaeppss_md2nid(mgf1md)))
             goto err;
diff --git a/crypto/sm2/sm2_pmeth.c b/crypto/sm2/sm2_pmeth.c
index 665e278d1f..32713a5ac4 100644
--- a/crypto/sm2/sm2_pmeth.c
+++ b/crypto/sm2/sm2_pmeth.c
@@ -130,6 +130,7 @@ static int pkey_sm2_encrypt(EVP_PKEY_CTX *ctx,
     SM2_PKEY_CTX *dctx = ctx-&gt;data;
     const EVP_MD *md = (dctx-&gt;md == NULL) ? EVP_sm3() : dctx-&gt;md;
     OPENSSL_CTX *libctx = ec_key_get_libctx(ec);
+    const char *propq = ec_key_get0_propq(ec);
     EVP_MD *fetched_md = NULL;
 
     if (out == NULL) {
@@ -139,7 +140,7 @@ static int pkey_sm2_encrypt(EVP_PKEY_CTX *ctx,
             return 1;
     }
 
-    fetched_md = EVP_MD_fetch(libctx, EVP_MD_name(md), 0);
+    fetched_md = EVP_MD_fetch(libctx, EVP_MD_name(md), propq);
     if (fetched_md == NULL)
         return 0;
     ret = sm2_encrypt(ec, fetched_md, in, inlen, out, outlen);
@@ -156,6 +157,7 @@ static int pkey_sm2_decrypt(EVP_PKEY_CTX *ctx,
     SM2_PKEY_CTX *dctx = ctx-&gt;data;
     const EVP_MD *md = (dctx-&gt;md == NULL) ? EVP_sm3() : dctx-&gt;md;
     OPENSSL_CTX *libctx = ec_key_get_libctx(ec);
+    const char *propq = ec_key_get0_propq(ec);
     EVP_MD *fetched_md = NULL;
 
     if (out == NULL) {
@@ -165,7 +167,7 @@ static int pkey_sm2_decrypt(EVP_PKEY_CTX *ctx,
             return 1;
     }
 
-    fetched_md = EVP_MD_fetch(libctx, EVP_MD_name(md), 0);
+    fetched_md = EVP_MD_fetch(libctx, EVP_MD_name(md), propq);
     if (fetched_md == NULL)
         return 0;
     ret = sm2_decrypt(ec, fetched_md, in, inlen, out, outlen);
diff --git a/doc/man7/EVP_KDF-SCRYPT.pod b/doc/man7/EVP_KDF-SCRYPT.pod
index 8650a8b39a..ec4eab8f1c 100644
--- a/doc/man7/EVP_KDF-SCRYPT.pod
+++ b/doc/man7/EVP_KDF-SCRYPT.pod
@@ -55,10 +55,17 @@ These parameters work as described in L&lt;EVP_KDF(3)/PARAMETERS&gt;.
 
 =item &quot;p&quot; (B&lt;OSSL_KDF_PARAM_SCRYPT_P&gt;) &lt;unsigned integer&gt;
 
-These parameters configure the scrypt work factors N, r and p.
-N is a parameter of type B&lt;uint64_t&gt;.
+=item &quot;maxmem_bytes&quot; (B&lt;OSSL_KDF_PARAM_SCRYPT_MAXMEM&gt;) &lt;unsigned integer&gt;
+
+These parameters configure the scrypt work factors N, r, maxmem and p.
+Both N and maxmem_bytes are parameters of type B&lt;uint64_t&gt;.
 Both r and p are parameters of type B&lt;uint32_t&gt;.
 
+=item &quot;properties&quot; (B&lt;OSSL_KDF_PARAM_PROPERTIES&gt;) &lt;UTF8 string&gt;
+
+This can be used to set the property query string when fetching the
+fixed digest internally. NULL is used if this value is not set.
+
 =back
 
 =head1 NOTES
diff --git a/include/crypto/ecx.h b/include/crypto/ecx.h
index 54ce5f2b7c..72cf5dd843 100644
--- a/include/crypto/ecx.h
+++ b/include/crypto/ecx.h
@@ -62,6 +62,7 @@ typedef enum {
 
 struct ecx_key_st {
     OPENSSL_CTX *libctx;
+    char *propq;
     unsigned int haspubkey:1;
     unsigned char pubkey[MAX_KEYLEN];
     unsigned char *privkey;
@@ -74,7 +75,8 @@ struct ecx_key_st {
 typedef struct ecx_key_st ECX_KEY;
 
 size_t ecx_key_length(ECX_KEY_TYPE type);
-ECX_KEY *ecx_key_new(OPENSSL_CTX *libctx, ECX_KEY_TYPE type, int haspubkey);
+ECX_KEY *ecx_key_new(OPENSSL_CTX *libctx, ECX_KEY_TYPE type, int haspubkey,
+                     const char *propq);
 unsigned char *ecx_key_allocate_privkey(ECX_KEY *key);
 void ecx_key_free(ECX_KEY *key);
 int ecx_key_up_ref(ECX_KEY *key);
@@ -85,7 +87,7 @@ void X25519_public_from_private(uint8_t out_public_value[32],
                                 const uint8_t private_key[32]);
 
 int ED25519_public_from_private(OPENSSL_CTX *ctx, uint8_t out_public_key[32],
-                                const uint8_t private_key[32]);
+                                const uint8_t private_key[32], const char *propq);
 int ED25519_sign(uint8_t *out_sig, const uint8_t *message, size_t message_len,
                  const uint8_t public_key[32], const uint8_t private_key[32],
                  OPENSSL_CTX *libctx, const char *propq);
@@ -94,15 +96,15 @@ int ED25519_verify(const uint8_t *message, size_t message_len,
                    OPENSSL_CTX *libctx, const char *propq);
 
 int ED448_public_from_private(OPENSSL_CTX *ctx, uint8_t out_public_key[57],
-                              const uint8_t private_key[57]);
+                              const uint8_t private_key[57], const char *propq);
 int ED448_sign(OPENSSL_CTX *ctx, uint8_t *out_sig, const uint8_t *message,
                size_t message_len, const uint8_t public_key[57],
                const uint8_t private_key[57], const uint8_t *context,
-               size_t context_len);
+               size_t context_len, const char *propq);
 
 int ED448_verify(OPENSSL_CTX *ctx, const uint8_t *message, size_t message_len,
                  const uint8_t signature[114], const uint8_t public_key[57],
-                 const uint8_t *context, size_t context_len);
+                 const uint8_t *context, size_t context_len, const char *propq);
 
 int X448(uint8_t out_shared_key[56], const uint8_t private_key[56],
          const uint8_t peer_public_value[56]);
diff --git a/include/crypto/rsa.h b/include/crypto/rsa.h
index 478327d231..278e215062 100644
--- a/include/crypto/rsa.h
+++ b/include/crypto/rsa.h
@@ -60,7 +60,7 @@ int rsa_get0_all_params(RSA *r, STACK_OF(BIGNUM_const) *primes,
 
 int rsa_todata(RSA *rsa, OSSL_PARAM_BLD *bld, OSSL_PARAM params[]);
 int rsa_fromdata(RSA *rsa, const OSSL_PARAM params[]);
-int rsa_pss_params_30_todata(const RSA_PSS_PARAMS_30 *pss, const char *propq,
+int rsa_pss_params_30_todata(const RSA_PSS_PARAMS_30 *pss,
                              OSSL_PARAM_BLD *bld, OSSL_PARAM params[]);
 int rsa_pss_params_30_fromdata(RSA_PSS_PARAMS_30 *pss_params,
                                const OSSL_PARAM params[], OPENSSL_CTX *libctx);
diff --git a/include/openssl/core_names.h b/include/openssl/core_names.h
index a1c73a86df..76902695f0 100644
--- a/include/openssl/core_names.h
+++ b/include/openssl/core_names.h
@@ -379,6 +379,7 @@ extern &quot;C&quot; {
 #define OSSL_PKEY_PARAM_RSA_BITS            OSSL_PKEY_PARAM_BITS
 #define OSSL_PKEY_PARAM_RSA_PRIMES          &quot;primes&quot;
 #define OSSL_PKEY_PARAM_RSA_DIGEST          OSSL_PKEY_PARAM_DIGEST
+#define OSSL_PKEY_PARAM_RSA_DIGEST_PROPS    OSSL_PKEY_PARAM_PROPERTIES
 #define OSSL_PKEY_PARAM_RSA_MASKGENFUNC     OSSL_PKEY_PARAM_MASKGENFUNC
 #define OSSL_PKEY_PARAM_RSA_MGF1_DIGEST     OSSL_PKEY_PARAM_MGF1_DIGEST
 #define OSSL_PKEY_PARAM_RSA_PSS_SALTLEN     &quot;saltlen&quot;
diff --git a/providers/implementations/kdfs/scrypt.c b/providers/implementations/kdfs/scrypt.c
index f412f1f8db..7a389e65d8 100644
--- a/providers/implementations/kdfs/scrypt.c
+++ b/providers/implementations/kdfs/scrypt.c
@@ -40,7 +40,8 @@ static int scrypt_alg(const char *pass, size_t passlen,
                       OPENSSL_CTX *libctx, const char *propq);
 
 typedef struct {
-    void *provctx;
+    OPENSSL_CTX *libctx;
+    char *propq;
     unsigned char *pass;
     size_t pass_len;
     unsigned char *salt;
@@ -65,14 +66,7 @@ static void *kdf_scrypt_new(void *provctx)
         ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
-    ctx-&gt;provctx = provctx;
-    ctx-&gt;sha256 = EVP_MD_fetch(PROV_LIBRARY_CONTEXT_OF(provctx),
-                               &quot;sha256&quot;, NULL);
-    if (ctx-&gt;sha256 == NULL) {
-        OPENSSL_free(ctx);
-        ERR_raise(ERR_LIB_PROV, PROV_R_UNABLE_TO_LOAD_SHA256);
-        return NULL;
-    }
+    ctx-&gt;libctx = PROV_LIBRARY_CONTEXT_OF(provctx);
     kdf_scrypt_init(ctx);
     return ctx;
 }
@@ -82,6 +76,7 @@ static void kdf_scrypt_free(void *vctx)
     KDF_SCRYPT *ctx = (KDF_SCRYPT *)vctx;
 
     if (ctx != NULL) {
+        OPENSSL_free(ctx-&gt;propq);
         EVP_MD_free(ctx-&gt;sha256);
         kdf_scrypt_reset(ctx);
         OPENSSL_free(ctx);
@@ -126,6 +121,32 @@ static int scrypt_set_membuf(unsigned char **buffer, size_t *buflen,
     return 1;
 }
 
+static int set_digest(KDF_SCRYPT *ctx)
+{
+    EVP_MD_free(ctx-&gt;sha256);
+    ctx-&gt;sha256 = EVP_MD_fetch(ctx-&gt;libctx, &quot;sha256&quot;, ctx-&gt;propq);
+    if (ctx-&gt;sha256 == NULL) {
+        OPENSSL_free(ctx);
+        ERR_raise(ERR_LIB_PROV, PROV_R_UNABLE_TO_LOAD_SHA256);
+        return 0;
+    }
+    return 1;
+}
+
+static int set_property_query(KDF_SCRYPT *ctx, const char *propq)
+{
+    OPENSSL_free(ctx-&gt;propq);
+    ctx-&gt;propq = NULL;
+    if (propq != NULL) {
+        ctx-&gt;propq = OPENSSL_strdup(propq);
+        if (ctx-&gt;propq == NULL) {
+            ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+    }
+    return 1;
+}
+
 static int kdf_scrypt_derive(void *vctx, unsigned char *key,
                              size_t keylen)
 {
@@ -144,10 +165,13 @@ static int kdf_scrypt_derive(void *vctx, unsigned char *key,
         return 0;
     }
 
+    if (ctx-&gt;sha256 == NULL &amp;&amp; !set_digest(ctx))
+        return 0;
+
     return scrypt_alg((char *)ctx-&gt;pass, ctx-&gt;pass_len, ctx-&gt;salt,
                       ctx-&gt;salt_len, ctx-&gt;N, ctx-&gt;r, ctx-&gt;p,
                       ctx-&gt;maxmem_bytes, key, keylen, ctx-&gt;sha256,
-                      PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx), NULL);
+                      ctx-&gt;libctx, ctx-&gt;propq);
 }
 
 static int is_power_of_two(uint64_t value)
@@ -198,6 +222,14 @@ static int kdf_scrypt_set_ctx_params(void *vctx, const OSSL_PARAM params[])
             return 0;
         ctx-&gt;maxmem_bytes = u64_value;
     }
+
+    p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PROPERTIES);
+    if (p != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING
+            || !set_property_query(ctx, p-&gt;data)
+            || !set_digest(ctx))
+            return 0;
+    }
     return 1;
 }
 
@@ -210,6 +242,7 @@ static const OSSL_PARAM *kdf_scrypt_settable_ctx_params(ossl_unused void *p_ctx)
         OSSL_PARAM_uint32(OSSL_KDF_PARAM_SCRYPT_R, NULL),
         OSSL_PARAM_uint32(OSSL_KDF_PARAM_SCRYPT_P, NULL),
         OSSL_PARAM_uint64(OSSL_KDF_PARAM_SCRYPT_MAXMEM, NULL),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_PROPERTIES, NULL, 0),
         OSSL_PARAM_END
     };
     return known_settable_ctx_params;
diff --git a/providers/implementations/kdfs/x942kdf.c b/providers/implementations/kdfs/x942kdf.c
index 9dfa8693de..4410ed8dd9 100644
--- a/providers/implementations/kdfs/x942kdf.c
+++ b/providers/implementations/kdfs/x942kdf.c
@@ -67,13 +67,14 @@ static const struct {
 #endif
 };
 
-static int find_alg_id(OPENSSL_CTX *libctx, const char *algname, size_t *id)
+static int find_alg_id(OPENSSL_CTX *libctx, const char *algname,
+                       const char *propq, size_t *id)
 {
     int ret = 1;
     size_t i;
     EVP_CIPHER *cipher;
 
-    cipher = EVP_CIPHER_fetch(libctx, algname, NULL);
+    cipher = EVP_CIPHER_fetch(libctx, algname, propq);
     if (cipher != NULL) {
         for (i = 0; i &lt; OSSL_NELEM(kek_algs); i++) {
             if (EVP_CIPHER_is_a(cipher, kek_algs[i].name)) {
@@ -381,9 +382,10 @@ static int x942kdf_derive(void *vctx, unsigned char *key, size_t keylen)
 
 static int x942kdf_set_ctx_params(void *vctx, const OSSL_PARAM params[])
 {
-    const OSSL_PARAM *p;
+    const OSSL_PARAM *p, *pq;
     KDF_X942 *ctx = vctx;
     OPENSSL_CTX *provctx = PROV_LIBRARY_CONTEXT_OF(ctx-&gt;provctx);
+    const char *propq = NULL;
     size_t id;
 
     if (!ossl_prov_digest_load_from_params(&amp;ctx-&gt;digest, params, provctx))
@@ -401,7 +403,14 @@ static int x942kdf_set_ctx_params(void *vctx, const OSSL_PARAM params[])
     if ((p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_CEK_ALG)) != NULL) {
         if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
             return 0;
-        if (find_alg_id(provctx, p-&gt;data, &amp;id) == 0)
+        pq = OSSL_PARAM_locate_const(params, OSSL_ALG_PARAM_PROPERTIES);
+        /*
+         * We already grab the properties during ossl_prov_digest_load_from_params()
+         * so there is no need to check the validity again..
+         */
+        if (pq != NULL)
+            propq = p-&gt;data;
+        if (find_alg_id(provctx, p-&gt;data, propq, &amp;id) == 0)
             return 0;
         ctx-&gt;cek_oid = kek_algs[id].oid;
         ctx-&gt;cek_oid_len = kek_algs[id].oid_len;
diff --git a/providers/implementations/keymgmt/ecx_kmgmt.c b/providers/implementations/keymgmt/ecx_kmgmt.c
index 6e1a2c91c8..b3d24e4c68 100644
--- a/providers/implementations/keymgmt/ecx_kmgmt.c
+++ b/providers/implementations/keymgmt/ecx_kmgmt.c
@@ -69,6 +69,7 @@ static OSSL_FUNC_keymgmt_export_types_fn ecx_imexport_types;
 
 struct ecx_gen_ctx {
     OPENSSL_CTX *libctx;
+    char *propq;
     ECX_KEY_TYPE type;
     int selection;
 };
@@ -84,28 +85,32 @@ static void *x25519_new_key(void *provctx)
 {
     if (!ossl_prov_is_running())
         return 0;
-    return ecx_key_new(PROV_LIBRARY_CONTEXT_OF(provctx), ECX_KEY_TYPE_X25519, 0);
+    return ecx_key_new(PROV_LIBRARY_CONTEXT_OF(provctx), ECX_KEY_TYPE_X25519, 0,
+                       NULL);
 }
 
 static void *x448_new_key(void *provctx)
 {
     if (!ossl_prov_is_running())
         return 0;
-    return ecx_key_new(PROV_LIBRARY_CONTEXT_OF(provctx), ECX_KEY_TYPE_X448, 0);
+    return ecx_key_new(PROV_LIBRARY_CONTEXT_OF(provctx), ECX_KEY_TYPE_X448, 0,
+                       NULL);
 }
 
 static void *ed25519_new_key(void *provctx)
 {
     if (!ossl_prov_is_running())
         return 0;
-    return ecx_key_new(PROV_LIBRARY_CONTEXT_OF(provctx), ECX_KEY_TYPE_ED25519, 0);
+    return ecx_key_new(PROV_LIBRARY_CONTEXT_OF(provctx), ECX_KEY_TYPE_ED25519, 0,
+                       NULL);
 }
 
 static void *ed448_new_key(void *provctx)
 {
     if (!ossl_prov_is_running())
         return 0;
-    return ecx_key_new(PROV_LIBRARY_CONTEXT_OF(provctx), ECX_KEY_TYPE_ED448, 0);
+    return ecx_key_new(PROV_LIBRARY_CONTEXT_OF(provctx), ECX_KEY_TYPE_ED448, 0,
+                       NULL);
 }
 
 static int ecx_has(void *keydata, int selection)
@@ -345,6 +350,20 @@ static const OSSL_PARAM *ed448_gettable_params(void *provctx)
     return ed_gettable_params;
 }
 
+static int set_property_query(ECX_KEY *ecxkey, const char *propq)
+{
+    OPENSSL_free(ecxkey-&gt;propq);
+    ecxkey-&gt;propq = NULL;
+    if (propq != NULL) {
+        ecxkey-&gt;propq = OPENSSL_strdup(propq);
+        if (ecxkey-&gt;propq == NULL) {
+            ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+    }
+    return 1;
+}
+
 static int ecx_set_params(void *key, const OSSL_PARAM params[])
 {
     ECX_KEY *ecxkey = key;
@@ -362,6 +381,12 @@ static int ecx_set_params(void *key, const OSSL_PARAM params[])
         ecxkey-&gt;privkey = NULL;
         ecxkey-&gt;haspubkey = 1;
     }
+    p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_PROPERTIES);
+    if (p != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING
+            || !set_property_query(ecxkey, p-&gt;data))
+            return 0;
+    }
 
     return 1;
 }
@@ -388,6 +413,7 @@ static int ed448_set_params(void *key, const OSSL_PARAM params[])
 
 static const OSSL_PARAM ecx_settable_params[] = {
     OSSL_PARAM_octet_string(OSSL_PKEY_PARAM_TLS_ENCODED_PT, NULL, 0),
+    OSSL_PARAM_utf8_string(OSSL_PKEY_PARAM_PROPERTIES, NULL, 0),
     OSSL_PARAM_END
 };
 
@@ -423,7 +449,7 @@ static void *ecx_gen_init(void *provctx, int selection, ECX_KEY_TYPE type)
     if (!ossl_prov_is_running())
         return NULL;
 
-    if ((gctx = OPENSSL_malloc(sizeof(*gctx))) != NULL) {
+    if ((gctx = OPENSSL_zalloc(sizeof(*gctx))) != NULL) {
         gctx-&gt;libctx = libctx;
         gctx-&gt;type = type;
         gctx-&gt;selection = selection;
@@ -486,6 +512,15 @@ static int ecx_gen_set_params(void *genctx, const OSSL_PARAM params[])
             return 0;
         }
     }
+    p = OSSL_PARAM_locate_const(params, OSSL_KDF_PARAM_PROPERTIES);
+    if (p != NULL) {
+        if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING)
+            return 0;
+        OPENSSL_free(gctx-&gt;propq);
+        gctx-&gt;propq = OPENSSL_strdup(p-&gt;data);
+        if (gctx-&gt;propq == NULL)
+            return 0;
+    }
 
     return 1;
 }
@@ -494,6 +529,7 @@ static const OSSL_PARAM *ecx_gen_settable_params(void *provctx)
 {
     static OSSL_PARAM settable[] = {
         OSSL_PARAM_utf8_string(OSSL_PKEY_PARAM_GROUP_NAME, NULL, 0),
+        OSSL_PARAM_utf8_string(OSSL_KDF_PARAM_PROPERTIES, NULL, 0),
         OSSL_PARAM_END
     };
     return settable;
@@ -506,7 +542,7 @@ static void *ecx_gen(struct ecx_gen_ctx *gctx)
 
     if (gctx == NULL)
         return NULL;
-    if ((key = ecx_key_new(gctx-&gt;libctx, gctx-&gt;type, 0)) == NULL) {
+    if ((key = ecx_key_new(gctx-&gt;libctx, gctx-&gt;type, 0, gctx-&gt;propq)) == NULL) {
         ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
@@ -534,11 +570,13 @@ static void *ecx_gen(struct ecx_gen_ctx *gctx)
         X448_public_from_private(key-&gt;pubkey, privkey);
         break;
     case ECX_KEY_TYPE_ED25519:
-        if (!ED25519_public_from_private(gctx-&gt;libctx, key-&gt;pubkey, privkey))
+        if (!ED25519_public_from_private(gctx-&gt;libctx, key-&gt;pubkey, privkey,
+                                         gctx-&gt;propq))
             goto err;
         break;
     case ECX_KEY_TYPE_ED448:
-        if (!ED448_public_from_private(gctx-&gt;libctx, key-&gt;pubkey, privkey))
+        if (!ED448_public_from_private(gctx-&gt;libctx, key-&gt;pubkey, privkey,
+                                       gctx-&gt;propq))
             goto err;
         break;
     }
@@ -614,6 +652,7 @@ static void ecx_gen_cleanup(void *genctx)
 {
     struct ecx_gen_ctx *gctx = genctx;
 
+    OPENSSL_free(gctx-&gt;propq);
     OPENSSL_free(gctx);
 }
 
@@ -670,7 +709,7 @@ static void *s390x_ecx_keygen25519(struct ecx_gen_ctx *gctx)
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
     };
-    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_X25519, 1);
+    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_X25519, 1, gctx-&gt;propq);
     unsigned char *privkey = NULL, *pubkey;
 
     if (key == NULL) {
@@ -715,7 +754,7 @@ static void *s390x_ecx_keygen448(struct ecx_gen_ctx *gctx)
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
     };
-    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_X448, 1);
+    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_X448, 1, gctx-&gt;propq);
     unsigned char *privkey = NULL, *pubkey;
 
     if (key == NULL) {
@@ -763,7 +802,7 @@ static void *s390x_ecd_keygen25519(struct ecx_gen_ctx *gctx)
         0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
     };
     unsigned char x_dst[32], buff[SHA512_DIGEST_LENGTH];
-    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_ED25519, 1);
+    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_ED25519, 1, gctx-&gt;propq);
     unsigned char *privkey = NULL, *pubkey;
     unsigned int sz;
     EVP_MD *sha = NULL;
@@ -789,7 +828,7 @@ static void *s390x_ecd_keygen25519(struct ecx_gen_ctx *gctx)
     if (RAND_priv_bytes_ex(gctx-&gt;libctx, privkey, ED25519_KEYLEN) &lt;= 0)
         goto err;
 
-    sha = EVP_MD_fetch(gctx-&gt;libctx, &quot;SHA512&quot;, NULL);
+    sha = EVP_MD_fetch(gctx-&gt;libctx, &quot;SHA512&quot;, gctx-&gt;propq);
     if (sha == NULL)
         goto err;
     j = EVP_Digest(privkey, 32, buff, &amp;sz, sha, NULL);
@@ -830,7 +869,7 @@ static void *s390x_ecd_keygen448(struct ecx_gen_ctx *gctx)
         0x24, 0xbc, 0xb6, 0x6e, 0x71, 0x46, 0x3f, 0x69, 0x00
     };
     unsigned char x_dst[57], buff[114];
-    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_ED448, 1);
+    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_ED448, 1, gctx-&gt;propq);
     unsigned char *privkey = NULL, *pubkey;
     EVP_MD_CTX *hashctx = NULL;
     EVP_MD *shake = NULL;
@@ -852,7 +891,7 @@ static void *s390x_ecd_keygen448(struct ecx_gen_ctx *gctx)
         goto err;
     }
 
-    shake = EVP_MD_fetch(gctx-&gt;libctx, &quot;SHAKE256&quot;, NULL);
+    shake = EVP_MD_fetch(gctx-&gt;libctx, &quot;SHAKE256&quot;, gctx-&gt;propq);
     if (shake == NULL)
         goto err;
     if (RAND_priv_bytes_ex(gctx-&gt;libctx, privkey, ED448_KEYLEN) &lt;= 0)
diff --git a/providers/implementations/keymgmt/rsa_kmgmt.c b/providers/implementations/keymgmt/rsa_kmgmt.c
index 659121c227..6bc666bcf0 100644
--- a/providers/implementations/keymgmt/rsa_kmgmt.c
+++ b/providers/implementations/keymgmt/rsa_kmgmt.c
@@ -193,7 +193,7 @@ static int rsa_export(void *keydata, int selection,
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_OTHER_PARAMETERS) != 0)
         ok = ok &amp;&amp; (rsa_pss_params_30_is_unrestricted(pss_params)
-                    || rsa_pss_params_30_todata(pss_params, NULL, tmpl, NULL));
+                    || rsa_pss_params_30_todata(pss_params, tmpl, NULL));
     if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR) != 0)
         ok = ok &amp;&amp; rsa_todata(rsa, tmpl, NULL);
 
@@ -339,7 +339,7 @@ static int rsa_get_params(void *key, OSSL_PARAM params[])
         }
     }
     return (rsa_type != RSA_FLAG_TYPE_RSASSAPSS
-            || rsa_pss_params_30_todata(pss_params, NULL, NULL, params))
+            || rsa_pss_params_30_todata(pss_params, NULL, params))
         &amp;&amp; rsa_todata(rsa, NULL, params);
 }
 
@@ -383,6 +383,7 @@ static int rsa_validate(void *keydata, int selection)
 
 struct rsa_gen_ctx {
     OPENSSL_CTX *libctx;
+    const char *propq;
 
     int rsa_type;
 
@@ -493,6 +494,7 @@ static int rsa_gen_set_params(void *genctx, const OSSL_PARAM params[])
  */
 #define rsa_gen_pss                                                     \
     OSSL_PARAM_utf8_string(OSSL_PKEY_PARAM_RSA_DIGEST, NULL, 0),        \
+    OSSL_PARAM_utf8_string(OSSL_PKEY_PARAM_RSA_DIGEST_PROPS, NULL, 0),  \
     OSSL_PARAM_utf8_string(OSSL_PKEY_PARAM_RSA_MASKGENFUNC, NULL, 0),   \
     OSSL_PARAM_utf8_string(OSSL_PKEY_PARAM_RSA_MGF1_DIGEST, NULL, 0),   \
     OSSL_PARAM_int(OSSL_PKEY_PARAM_RSA_PSS_SALTLEN, NULL)
diff --git a/providers/implementations/signature/eddsa.c b/providers/implementations/signature/eddsa.c
index 9d8ab0ad3e..19e9c62019 100644
--- a/providers/implementations/signature/eddsa.c
+++ b/providers/implementations/signature/eddsa.c
@@ -163,7 +163,7 @@ int ed448_digest_sign(void *vpeddsactx, unsigned char *sigret,
     }
 
     if (ED448_sign(peddsactx-&gt;libctx, sigret, tbs, tbslen, edkey-&gt;pubkey,
-                   edkey-&gt;privkey, NULL, 0) == 0) {
+                   edkey-&gt;privkey, NULL, 0, edkey-&gt;propq) == 0) {
         PROVerr(0, PROV_R_FAILED_TO_SIGN);
         return 0;
     }
@@ -182,7 +182,7 @@ int ed25519_digest_verify(void *vpeddsactx, const unsigned char *sig,
         return 0;
 
     return ED25519_verify(tbs, tbslen, sig, edkey-&gt;pubkey, peddsactx-&gt;libctx,
-                          NULL);
+                          edkey-&gt;propq);
 }
 
 int ed448_digest_verify(void *vpeddsactx, const unsigned char *sig,
@@ -196,7 +196,7 @@ int ed448_digest_verify(void *vpeddsactx, const unsigned char *sig,
         return 0;
 
     return ED448_verify(peddsactx-&gt;libctx, tbs, tbslen, sig, edkey-&gt;pubkey,
-                        NULL, 0);
+                        NULL, 0, edkey-&gt;propq);
 }
 
 static void eddsa_freectx(void *vpeddsactx)
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index f2043aef7e..927154fd98 100644
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -3385,7 +3385,7 @@ SSL_HMAC *ssl_hmac_new(const SSL_CTX *ctx)
         return ret;
     }
 #endif
-    mac = EVP_MAC_fetch(ctx-&gt;libctx, &quot;HMAC&quot;, NULL);
+    mac = EVP_MAC_fetch(ctx-&gt;libctx, &quot;HMAC&quot;, ctx-&gt;propq);
     if (mac == NULL || (ret-&gt;ctx = EVP_MAC_CTX_new(mac)) == NULL)
         goto err;
     EVP_MAC_free(mac);
diff --git a/test/curve448_internal_test.c b/test/curve448_internal_test.c
index 1c1510a361..b1df82e837 100644
--- a/test/curve448_internal_test.c
+++ b/test/curve448_internal_test.c
@@ -602,39 +602,39 @@ static int test_ed448(void)
 
     if (!TEST_ptr(hashctx)
             || !TEST_true(ED448_sign(NULL, outsig, NULL, 0, pubkey1, privkey1,
-                                     NULL, 0))
+                                     NULL, 0, NULL))
             || !TEST_int_eq(memcmp(sig1, outsig, sizeof(sig1)), 0)
             || !TEST_true(ED448_sign(NULL, outsig, msg2, sizeof(msg2), pubkey2,
-                                     privkey2, NULL, 0))
+                                     privkey2, NULL, 0, NULL))
             || !TEST_int_eq(memcmp(sig2, outsig, sizeof(sig2)), 0)
             || !TEST_true(ED448_sign(NULL, outsig, msg3, sizeof(msg3), pubkey3,
-                                     privkey3, context3, sizeof(context3)))
+                                     privkey3, context3, sizeof(context3), NULL))
             || !TEST_int_eq(memcmp(sig3, outsig, sizeof(sig3)), 0)
             || !TEST_true(ED448_sign(NULL, outsig, msg4, sizeof(msg4), pubkey4,
-                                     privkey4, NULL, 0))
+                                     privkey4, NULL, 0, NULL))
             || !TEST_int_eq(memcmp(sig4, outsig, sizeof(sig4)), 0)
             || !TEST_true(ED448_sign(NULL, outsig, msg5, sizeof(msg5), pubkey5,
-                                     privkey5, NULL, 0))
+                                     privkey5, NULL, 0, NULL))
             || !TEST_int_eq(memcmp(sig5, outsig, sizeof(sig5)), 0)
             || !TEST_true(ED448_sign(NULL, outsig, msg6, sizeof(msg6), pubkey6,
-                                     privkey6, NULL, 0))
+                                     privkey6, NULL, 0, NULL))
             || !TEST_int_eq(memcmp(sig6, outsig, sizeof(sig6)), 0)
             || !TEST_true(ED448_sign(NULL, outsig, msg7, sizeof(msg7), pubkey7,
-                                     privkey7, NULL, 0))
+                                     privkey7, NULL, 0, NULL))
             || !TEST_int_eq(memcmp(sig7, outsig, sizeof(sig7)), 0)
             || !TEST_true(ED448_sign(NULL, outsig, msg8, sizeof(msg8), pubkey8,
-                                     privkey8, NULL, 0))
+                                     privkey8, NULL, 0, NULL))
             || !TEST_int_eq(memcmp(sig8, outsig, sizeof(sig8)), 0)
             || !TEST_true(ED448_sign(NULL, outsig, msg9, sizeof(msg9), pubkey9,
-                                     privkey9, NULL, 0))
+                                     privkey9, NULL, 0, NULL))
             || !TEST_int_eq(memcmp(sig9, outsig, sizeof(sig9)), 0)
             || !TEST_true(ED448ph_sign(NULL, outsig, dohash(hashctx, phmsg1,
                                        sizeof(phmsg1)), phpubkey1, phprivkey1,
-                                       NULL, 0))
+                                       NULL, 0, NULL))
             || !TEST_int_eq(memcmp(phsig1, outsig, sizeof(phsig1)), 0)
             || !TEST_true(ED448ph_sign(NULL, outsig, dohash(hashctx, phmsg2,
                                        sizeof(phmsg2)), phpubkey2, phprivkey2,
-                                       phcontext2, sizeof(phcontext2)))
+                                       phcontext2, sizeof(phcontext2), NULL))
             || !TEST_int_eq(memcmp(phsig2, outsig, sizeof(phsig2)), 0)) {
         EVP_MD_CTX_free(hashctx);
         return 0;
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030860.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="030863.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30861">[ date ]</a>
              <a href="thread.html#30861">[ thread ]</a>
              <a href="subject.html#30861">[ subject ]</a>
              <a href="author.html#30861">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
