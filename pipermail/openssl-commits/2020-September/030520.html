<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2020-September/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1599572624.503013.25143.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="030519.html">
   <LINK REL="Next"  HREF="030521.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>tmraz at fedoraproject.org</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1599572624.503013.25143.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">tmraz at fedoraproject.org
       </A><BR>
    <I>Tue Sep  8 13:43:44 UTC 2020</I>
    <P><UL>
        <LI>Previous message: <A HREF="030519.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="030521.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30520">[ date ]</a>
              <a href="thread.html#30520">[ thread ]</a>
              <a href="subject.html#30520">[ subject ]</a>
              <a href="author.html#30520">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  924663c36d47066d5307937da77fed7e872730c7 (commit)
      from  d96486dc809b5d134055785bfa6d707195d95534 (commit)


- Log -----------------------------------------------------------------
commit 924663c36d47066d5307937da77fed7e872730c7
Author: Jakub Zelenka &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">jakub.openssl at gmail.com</A>&gt;
Date:   Sun Sep 6 19:11:34 2020 +0100

    Add CMS AuthEnvelopedData with AES-GCM support
    
    Add the AuthEnvelopedData as defined in RFC 5083 with AES-GCM
    parameter as defined in RFC 5084.
    
    Reviewed-by: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
    Reviewed-by: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tmraz at fedoraproject.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8024">https://github.com/openssl/openssl/pull/8024</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/asn1/evp_asn1.c                | 108 +++++++++--
 crypto/cms/cms_asn1.c                 |  12 ++
 crypto/cms/cms_enc.c                  |  32 +++-
 crypto/cms/cms_env.c                  | 345 ++++++++++++++++++++++++++--------
 crypto/cms/cms_err.c                  |   3 +
 crypto/cms/cms_kari.c                 |   4 +-
 crypto/cms/cms_lib.c                  |  24 +++
 crypto/cms/cms_local.h                |  21 ++-
 crypto/cms/cms_pwri.c                 |  16 +-
 crypto/cms/cms_smime.c                |  20 +-
 crypto/err/openssl.txt                |   3 +
 crypto/evp/evp_lib.c                  | 107 ++++++++---
 crypto/evp/evp_local.h                |   5 +
 doc/man1/openssl-cms.pod.in           |   3 +
 doc/man3/CMS_EnvelopedData_create.pod |  48 +++--
 doc/man3/CMS_decrypt.pod              |   6 +-
 doc/man3/CMS_encrypt.pod              |  22 ++-
 include/crypto/asn1.h                 |   9 +
 include/crypto/evp.h                  |  12 ++
 include/openssl/asn1err.h             |   1 +
 include/openssl/cms.h                 |   5 +
 include/openssl/cmserr.h              |   2 +
 test/cmsapitest.c                     |  29 ++-
 test/drbgtest.c                       |   1 +
 test/recipes/80-test_cms.t            |  26 ++-
 util/libcrypto.num                    |   2 +
 26 files changed, 686 insertions(+), 180 deletions(-)

diff --git a/crypto/asn1/evp_asn1.c b/crypto/asn1/evp_asn1.c
index c775a22181..844aabe603 100644
--- a/crypto/asn1/evp_asn1.c
+++ b/crypto/asn1/evp_asn1.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2020 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -11,6 +11,7 @@
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/asn1.h&gt;
 #include &lt;openssl/asn1t.h&gt;
+#include &quot;crypto/asn1.h&quot;
 
 int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned char *data, int len)
 {
@@ -46,6 +47,34 @@ int ASN1_TYPE_get_octetstring(const ASN1_TYPE *a, unsigned char *data, int max_l
     return ret;
 }
 
+static ossl_inline void asn1_type_init_oct(ASN1_OCTET_STRING *oct,
+                                           unsigned char *data, int len)
+{
+    oct-&gt;data = data;
+    oct-&gt;type = V_ASN1_OCTET_STRING;
+    oct-&gt;length = len;
+    oct-&gt;flags = 0;
+}
+
+static int asn1_type_get_int_oct(ASN1_OCTET_STRING *oct, int32_t anum,
+                                 long *num, unsigned char *data, int max_len)
+{
+    int ret = ASN1_STRING_length(oct), n;
+
+    if (num != NULL)
+        *num = anum;
+
+    if (max_len &gt; ret)
+        n = ret;
+    else
+        n = max_len;
+
+    if (data != NULL)
+        memcpy(data, ASN1_STRING_get0_data(oct), n);
+
+    return ret;
+}
+
 typedef struct {
     int32_t num;
     ASN1_OCTET_STRING *oct;
@@ -66,25 +95,18 @@ int ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num, unsigned char *data,
 
     atmp.num = num;
     atmp.oct = &oct;
-    oct.data = data;
-    oct.type = V_ASN1_OCTET_STRING;
-    oct.length = len;
-    oct.flags = 0;
+    asn1_type_init_oct(&amp;oct, data, len);
 
     if (ASN1_TYPE_pack_sequence(ASN1_ITEM_rptr(asn1_int_oct), &amp;atmp, &amp;a))
         return 1;
     return 0;
 }
 
-/*
- * we return the actual length...
- */
-/* int max_len:  for returned value    */
 int ASN1_TYPE_get_int_octetstring(const ASN1_TYPE *a, long *num,
                                   unsigned char *data, int max_len)
 {
     asn1_int_oct *atmp = NULL;
-    int ret = -1, n;
+    int ret = -1;
 
     if ((a-&gt;type != V_ASN1_SEQUENCE) || (a-&gt;value.sequence == NULL)) {
         goto err;
@@ -95,17 +117,8 @@ int ASN1_TYPE_get_int_octetstring(const ASN1_TYPE *a, long *num,
     if (atmp == NULL)
         goto err;
 
-    if (num != NULL)
-        *num = atmp-&gt;num;
+    ret = asn1_type_get_int_oct(atmp-&gt;oct, atmp-&gt;num, num, data, max_len);
 
-    ret = ASN1_STRING_length(atmp-&gt;oct);
-    if (max_len &gt; ret)
-        n = ret;
-    else
-        n = max_len;
-
-    if (data != NULL)
-        memcpy(data, ASN1_STRING_get0_data(atmp-&gt;oct), n);
     if (ret == -1) {
  err:
         ASN1err(ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING, ASN1_R_DATA_IS_WRONG);
@@ -113,3 +126,58 @@ int ASN1_TYPE_get_int_octetstring(const ASN1_TYPE *a, long *num,
     M_ASN1_free_of(atmp, asn1_int_oct);
     return ret;
 }
+
+typedef struct {
+    ASN1_OCTET_STRING *oct;
+    int32_t num;
+} asn1_oct_int;
+
+/*
+ * Defined in RFC 5084 -
+ * Section 2. &quot;Content-Authenticated Encryption Algorithms&quot;
+ */
+ASN1_SEQUENCE(asn1_oct_int) = {
+        ASN1_SIMPLE(asn1_oct_int, oct, ASN1_OCTET_STRING),
+        ASN1_EMBED(asn1_oct_int, num, INT32)
+} static_ASN1_SEQUENCE_END(asn1_oct_int)
+
+DECLARE_ASN1_ITEM(asn1_oct_int)
+
+int asn1_type_set_octetstring_int(ASN1_TYPE *a, long num, unsigned char *data,
+                                  int len)
+{
+    asn1_oct_int atmp;
+    ASN1_OCTET_STRING oct;
+
+    atmp.num = num;
+    atmp.oct = &oct;
+    asn1_type_init_oct(&amp;oct, data, len);
+
+    if (ASN1_TYPE_pack_sequence(ASN1_ITEM_rptr(asn1_oct_int), &amp;atmp, &amp;a))
+        return 1;
+    return 0;
+}
+
+int asn1_type_get_octetstring_int(const ASN1_TYPE *a, long *num,
+                                  unsigned char *data, int max_len)
+{
+    asn1_oct_int *atmp = NULL;
+    int ret = -1;
+
+    if ((a-&gt;type != V_ASN1_SEQUENCE) || (a-&gt;value.sequence == NULL))
+        goto err;
+
+    atmp = ASN1_TYPE_unpack_sequence(ASN1_ITEM_rptr(asn1_oct_int), a);
+
+    if (atmp == NULL)
+        goto err;
+
+    ret = asn1_type_get_int_oct(atmp-&gt;oct, atmp-&gt;num, num, data, max_len);
+
+    if (ret == -1) {
+ err:
+        ASN1err(ASN1_F_ASN1_TYPE_GET_OCTETSTRING_INT, ASN1_R_DATA_IS_WRONG);
+    }
+    M_ASN1_free_of(atmp, asn1_oct_int);
+    return ret;
+}
diff --git a/crypto/cms/cms_asn1.c b/crypto/cms/cms_asn1.c
index 082885dca8..8bf2f8f1cc 100644
--- a/crypto/cms/cms_asn1.c
+++ b/crypto/cms/cms_asn1.c
@@ -245,6 +245,17 @@ ASN1_NDEF_SEQUENCE(CMS_EncryptedData) = {
         ASN1_IMP_SET_OF_OPT(CMS_EncryptedData, unprotectedAttrs, X509_ATTRIBUTE, 1)
 } ASN1_NDEF_SEQUENCE_END(CMS_EncryptedData)
 
+/* Defined in RFC 5083 - Section 2.1. AuthEnvelopedData Type */
+ASN1_NDEF_SEQUENCE(CMS_AuthEnvelopedData) = {
+        ASN1_EMBED(CMS_AuthEnvelopedData, version, INT32),
+        ASN1_IMP_OPT(CMS_AuthEnvelopedData, originatorInfo, CMS_OriginatorInfo, 0),
+        ASN1_SET_OF(CMS_AuthEnvelopedData, recipientInfos, CMS_RecipientInfo),
+        ASN1_SIMPLE(CMS_AuthEnvelopedData, authEncryptedContentInfo, CMS_EncryptedContentInfo),
+        ASN1_IMP_SET_OF_OPT(CMS_AuthEnvelopedData, authAttrs, X509_ALGOR, 2),
+        ASN1_SIMPLE(CMS_AuthEnvelopedData, mac, ASN1_OCTET_STRING),
+        ASN1_IMP_SET_OF_OPT(CMS_AuthEnvelopedData, unauthAttrs, X509_ALGOR, 3)
+} ASN1_NDEF_SEQUENCE_END(CMS_AuthEnvelopedData)
+
 ASN1_NDEF_SEQUENCE(CMS_AuthenticatedData) = {
         ASN1_EMBED(CMS_AuthenticatedData, version, INT32),
         ASN1_IMP_OPT(CMS_AuthenticatedData, originatorInfo, CMS_OriginatorInfo, 0),
@@ -273,6 +284,7 @@ ASN1_ADB(CMS_ContentInfo) = {
         ADB_ENTRY(NID_pkcs7_enveloped, ASN1_NDEF_EXP(CMS_ContentInfo, d.envelopedData, CMS_EnvelopedData, 0)),
         ADB_ENTRY(NID_pkcs7_digest, ASN1_NDEF_EXP(CMS_ContentInfo, d.digestedData, CMS_DigestedData, 0)),
         ADB_ENTRY(NID_pkcs7_encrypted, ASN1_NDEF_EXP(CMS_ContentInfo, d.encryptedData, CMS_EncryptedData, 0)),
+        ADB_ENTRY(NID_id_smime_ct_authEnvelopedData, ASN1_NDEF_EXP(CMS_ContentInfo, d.authEnvelopedData, CMS_AuthEnvelopedData, 0)),
         ADB_ENTRY(NID_id_smime_ct_authData, ASN1_NDEF_EXP(CMS_ContentInfo, d.authenticatedData, CMS_AuthenticatedData, 0)),
         ADB_ENTRY(NID_id_smime_ct_compressedData, ASN1_NDEF_EXP(CMS_ContentInfo, d.compressedData, CMS_CompressedData, 0)),
 } ASN1_ADB_END(CMS_ContentInfo, 0, contentType, 0, &amp;cms_default_tt, NULL);
diff --git a/crypto/cms/cms_enc.c b/crypto/cms/cms_enc.c
index 48934ef2a1..ef87fac8ef 100644
--- a/crypto/cms/cms_enc.c
+++ b/crypto/cms/cms_enc.c
@@ -14,6 +14,7 @@
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/cms.h&gt;
 #include &lt;openssl/rand.h&gt;
+#include &quot;crypto/evp.h&quot;
 #include &quot;cms_local.h&quot;
 
 /* CMS EncryptedData Utilities */
@@ -28,9 +29,11 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
     EVP_CIPHER *fetched_ciph = NULL;
     const EVP_CIPHER *cipher = NULL;
     X509_ALGOR *calg = ec-&gt;contentEncryptionAlgorithm;
+    evp_cipher_aead_asn1_params aparams;
     unsigned char iv[EVP_MAX_IV_LENGTH], *piv = NULL;
     unsigned char *tkey = NULL;
     int len;
+    int ivlen = 0;
     size_t tkeylen = 0;
     int ok = 0;
     int enc, keep_key = 0;
@@ -76,7 +79,6 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
     }
 
     if (enc) {
-        int ivlen;
         calg-&gt;algorithm = OBJ_nid2obj(EVP_CIPHER_CTX_type(ctx));
         /* Generate a random IV if we need one */
         ivlen = EVP_CIPHER_CTX_iv_length(ctx);
@@ -85,10 +87,20 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
                 goto err;
             piv = iv;
         }
-    } else if (EVP_CIPHER_asn1_to_param(ctx, calg-&gt;parameter) &lt;= 0) {
-        CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
-               CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
-        goto err;
+    } else {
+        if (evp_cipher_asn1_to_param_ex(ctx, calg-&gt;parameter, &amp;aparams) &lt;= 0) {
+            CMSerr(0, CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
+            goto err;
+        }
+        if ((EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)) {
+            piv = aparams.iv;
+            if (ec-&gt;taglen &gt; 0
+                    &amp;&amp; EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,
+                                           ec-&gt;taglen, ec-&gt;tag) &lt;= 0) {
+                CMSerr(0, CMS_R_CIPHER_AEAD_SET_TAG_ERROR);
+                goto err;
+            }
+        }
     }
     len = EVP_CIPHER_CTX_key_length(ctx);
     if (len &lt;= 0)
@@ -150,7 +162,15 @@ BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec,
             CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO, ERR_R_MALLOC_FAILURE);
             goto err;
         }
-        if (EVP_CIPHER_param_to_asn1(ctx, calg-&gt;parameter) &lt;= 0) {
+        if ((EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)) {
+            memcpy(aparams.iv, piv, ivlen);
+            aparams.iv_len = ivlen;
+            aparams.tag_len = EVP_CIPHER_CTX_tag_length(ctx);
+            if (aparams.tag_len &lt;= 0)
+                goto err;
+        }
+
+        if (evp_cipher_param_to_asn1_ex(ctx, calg-&gt;parameter, &amp;aparams) &lt;= 0) {
             CMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,
                    CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);
             goto err;
diff --git a/crypto/cms/cms_env.c b/crypto/cms/cms_env.c
index 1fed65c442..944846ca98 100644
--- a/crypto/cms/cms_env.c
+++ b/crypto/cms/cms_env.c
@@ -24,9 +24,28 @@ DEFINE_STACK_OF(CMS_RevocationInfoChoice)
 DEFINE_STACK_OF(X509_ATTRIBUTE)
 
 /* CMS EnvelopedData Utilities */
-
 static void cms_env_set_version(CMS_EnvelopedData *env);
 
+#define CMS_ENVELOPED_STANDARD 1
+#define CMS_ENVELOPED_AUTH     2
+
+static int cms_get_enveloped_type(const CMS_ContentInfo *cms)
+{
+    int nid = OBJ_obj2nid(cms-&gt;contentType);
+
+    switch (nid) {
+    case NID_pkcs7_enveloped:
+        return CMS_ENVELOPED_STANDARD;
+
+    case NID_id_smime_ct_authEnvelopedData:
+        return CMS_ENVELOPED_AUTH;
+
+    default:
+        CMSerr(0, CMS_R_CONTENT_TYPE_NOT_ENVELOPED_DATA);
+        return 0;
+    }
+}
+
 CMS_EnvelopedData *cms_get0_enveloped(CMS_ContentInfo *cms)
 {
     if (OBJ_obj2nid(cms-&gt;contentType) != NID_pkcs7_enveloped) {
@@ -37,11 +56,20 @@ CMS_EnvelopedData *cms_get0_enveloped(CMS_ContentInfo *cms)
     return cms-&gt;d.envelopedData;
 }
 
+CMS_AuthEnvelopedData *cms_get0_auth_enveloped(CMS_ContentInfo *cms)
+{
+    if (OBJ_obj2nid(cms-&gt;contentType) != NID_id_smime_ct_authEnvelopedData) {
+        CMSerr(0, CMS_R_CONTENT_TYPE_NOT_ENVELOPED_DATA);
+        return NULL;
+    }
+    return cms-&gt;d.authEnvelopedData;
+}
+
 static CMS_EnvelopedData *cms_enveloped_data_init(CMS_ContentInfo *cms)
 {
     if (cms-&gt;d.other == NULL) {
         cms-&gt;d.envelopedData = M_ASN1_new_of(CMS_EnvelopedData);
-        if (!cms-&gt;d.envelopedData) {
+        if (cms-&gt;d.envelopedData == NULL) {
             CMSerr(CMS_F_CMS_ENVELOPED_DATA_INIT, ERR_R_MALLOC_FAILURE);
             return NULL;
         }
@@ -55,6 +83,26 @@ static CMS_EnvelopedData *cms_enveloped_data_init(CMS_ContentInfo *cms)
     return cms_get0_enveloped(cms);
 }
 
+static CMS_AuthEnvelopedData *
+cms_auth_enveloped_data_init(CMS_ContentInfo *cms)
+{
+    if (cms-&gt;d.other == NULL) {
+        cms-&gt;d.authEnvelopedData = M_ASN1_new_of(CMS_AuthEnvelopedData);
+        if (cms-&gt;d.authEnvelopedData == NULL) {
+            CMSerr(0, ERR_R_MALLOC_FAILURE);
+            return NULL;
+        }
+        /* Defined in RFC 5083 - Section 2.1. &quot;AuthEnvelopedData Type&quot; */
+        cms-&gt;d.authEnvelopedData-&gt;version = 0;
+        cms-&gt;d.authEnvelopedData-&gt;authEncryptedContentInfo-&gt;contentType =
+            OBJ_nid2obj(NID_pkcs7_data);
+        ASN1_OBJECT_free(cms-&gt;contentType);
+        cms-&gt;contentType = OBJ_nid2obj(NID_id_smime_ct_authEnvelopedData);
+        return cms-&gt;d.authEnvelopedData;
+    }
+    return cms_get0_auth_enveloped(cms);
+}
+
 int cms_env_asn1_ctrl(CMS_RecipientInfo *ri, int cmd)
 {
     EVP_PKEY *pkey;
@@ -86,13 +134,32 @@ int cms_env_asn1_ctrl(CMS_RecipientInfo *ri, int cmd)
     return 1;
 }
 
+CMS_EncryptedContentInfo* cms_get0_env_enc_content(const CMS_ContentInfo *cms)
+{
+    switch (cms_get_enveloped_type(cms)) {
+    case CMS_ENVELOPED_STANDARD:
+        return cms-&gt;d.envelopedData-&gt;encryptedContentInfo;
+
+    case CMS_ENVELOPED_AUTH:
+        return cms-&gt;d.authEnvelopedData-&gt;authEncryptedContentInfo;
+
+    default:
+        return NULL;
+    }
+}
+
 STACK_OF(CMS_RecipientInfo) *CMS_get0_RecipientInfos(CMS_ContentInfo *cms)
 {
-    CMS_EnvelopedData *env;
-    env = cms_get0_enveloped(cms);
-    if (!env)
+    switch (cms_get_enveloped_type(cms)) {
+    case CMS_ENVELOPED_STANDARD:
+        return cms-&gt;d.envelopedData-&gt;recipientInfos;
+
+    case CMS_ENVELOPED_AUTH:
+        return cms-&gt;d.authEnvelopedData-&gt;recipientInfos;
+
+    default:
         return NULL;
-    return env-&gt;recipientInfos;
+    }
 }
 
 void cms_RecipientInfos_set_cmsctx(CMS_ContentInfo *cms)
@@ -169,45 +236,34 @@ CMS_ContentInfo *CMS_EnvelopedData_create(const EVP_CIPHER *cipher)
     return CMS_EnvelopedData_create_with_libctx(cipher, NULL, NULL);
 }
 
-int cms_EnvelopedData_final(CMS_ContentInfo *cms, BIO *chain)
+CMS_ContentInfo *
+CMS_AuthEnvelopedData_create_with_libctx(const EVP_CIPHER *cipher,
+                                         OPENSSL_CTX *libctx,
+                                         const char *propq)
 {
-    CMS_EnvelopedData *env = NULL;
-    EVP_CIPHER_CTX *ctx = NULL;
-    BIO *mbio = BIO_find_type(chain, BIO_TYPE_CIPHER);
-
-    env = cms_get0_enveloped(cms);
-    if (env == NULL)
-        return 0;
-
-    if (mbio == NULL) {
-        CMSerr(CMS_F_CMS_ENVELOPEDDATA_FINAL, CMS_R_CONTENT_NOT_FOUND);
-        return 0;
-    }
-
-    BIO_get_cipher_ctx(mbio, &amp;ctx);
-
-    /*
-     * If the selected cipher supports unprotected attributes,
-     * deal with it using special ctrl function
-     */
-    if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_CIPHER_WITH_MAC) {
-        if (cms-&gt;d.envelopedData-&gt;unprotectedAttrs == NULL)
-            cms-&gt;d.envelopedData-&gt;unprotectedAttrs = sk_X509_ATTRIBUTE_new_null();
+    CMS_ContentInfo *cms;
+    CMS_AuthEnvelopedData *aenv;
 
-        if (cms-&gt;d.envelopedData-&gt;unprotectedAttrs == NULL) {
-            CMSerr(CMS_F_CMS_ENVELOPEDDATA_FINAL, ERR_R_MALLOC_FAILURE);
-            return 0;
-        }
+    cms = CMS_ContentInfo_new_with_libctx(libctx, propq);
+    if (cms == NULL)
+        goto merr;
+    aenv = cms_auth_enveloped_data_init(cms);
+    if (aenv == NULL)
+        goto merr;
+    if (!cms_EncryptedContent_init(aenv-&gt;authEncryptedContentInfo,
+                                   cipher, NULL, 0, cms_get0_cmsctx(cms)))
+        goto merr;
+    return cms;
+ merr:
+    CMS_ContentInfo_free(cms);
+    CMSerr(0, ERR_R_MALLOC_FAILURE);
+    return NULL;
+}
 
-        if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_PROCESS_UNPROTECTED,
-                                1, env-&gt;unprotectedAttrs) &lt;= 0) {
-            CMSerr(CMS_F_CMS_ENVELOPEDDATA_FINAL, CMS_R_CTRL_FAILURE);
-            return 0;
-        }
-    }
 
-    cms_env_set_version(cms-&gt;d.envelopedData);
-    return 1;
+CMS_ContentInfo *CMS_AuthEnvelopedData_create(const EVP_CIPHER *cipher)
+{
+    return CMS_AuthEnvelopedData_create_with_libctx(cipher, NULL, NULL);
 }
 
 /* Key Transport Recipient Info (KTRI) routines */
@@ -272,17 +328,17 @@ CMS_RecipientInfo *CMS_add1_recipient(CMS_ContentInfo *cms, X509 *recip,
                                       X509 *originator, unsigned int flags)
 {
     CMS_RecipientInfo *ri = NULL;
-    CMS_EnvelopedData *env;
+    STACK_OF(CMS_RecipientInfo) *ris;
     EVP_PKEY *pk = NULL;
     const CMS_CTX *ctx = cms_get0_cmsctx(cms);
 
-    env = cms_get0_enveloped(cms);
-    if (!env)
+    ris = CMS_get0_RecipientInfos(cms);
+    if (ris == NULL)
         goto err;
 
     /* Initialize recipient info */
     ri = M_ASN1_new_of(CMS_RecipientInfo);
-    if (!ri)
+    if (ri == NULL)
         goto merr;
 
     pk = X509_get0_pubkey(recip);
@@ -311,7 +367,7 @@ CMS_RecipientInfo *CMS_add1_recipient(CMS_ContentInfo *cms, X509 *recip,
 
     }
 
-    if (!sk_CMS_RecipientInfo_push(env-&gt;recipientInfos, ri))
+    if (!sk_CMS_RecipientInfo_push(ris, ri))
         goto merr;
 
     return ri;
@@ -324,8 +380,8 @@ CMS_RecipientInfo *CMS_add1_recipient(CMS_ContentInfo *cms, X509 *recip,
 
 }
 
-CMS_RecipientInfo *CMS_add1_recipient_cert(CMS_ContentInfo *cms,
-     X509 *recip, unsigned int flags)
+CMS_RecipientInfo *CMS_add1_recipient_cert(CMS_ContentInfo *cms, X509 *recip,
+                                           unsigned int flags)
 {
      return CMS_add1_recipient(cms, recip, NULL, NULL, flags);
 }
@@ -408,7 +464,7 @@ static int cms_RecipientInfo_ktri_encrypt(const CMS_ContentInfo *cms,
         return 0;
     }
     ktri = ri-&gt;d.ktri;
-    ec = cms-&gt;d.envelopedData-&gt;encryptedContentInfo;
+    ec = cms_get0_env_enc_content(cms);
 
     pctx = ktri-&gt;pctx;
 
@@ -471,7 +527,7 @@ static int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,
     CMS_EncryptedContentInfo *ec;
     const CMS_CTX *ctx = cms_get0_cmsctx(cms);
 
-    ec = cms-&gt;d.envelopedData-&gt;encryptedContentInfo;
+    ec = cms_get0_env_enc_content(cms);
 
     if (ktri-&gt;pkey == NULL) {
         CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_NO_PRIVATE_KEY);
@@ -598,10 +654,10 @@ CMS_RecipientInfo *CMS_add0_recipient_key(CMS_ContentInfo *cms, int nid,
                                           ASN1_TYPE *otherType)
 {
     CMS_RecipientInfo *ri = NULL;
-    CMS_EnvelopedData *env;
     CMS_KEKRecipientInfo *kekri;
-    env = cms_get0_enveloped(cms);
-    if (!env)
+    STACK_OF(CMS_RecipientInfo) *ris = CMS_get0_RecipientInfos(cms);
+
+    if (ris == NULL)
         goto err;
 
     if (nid == NID_undef) {
@@ -658,7 +714,7 @@ CMS_RecipientInfo *CMS_add0_recipient_key(CMS_ContentInfo *cms, int nid,
             goto merr;
     }
 
-    if (!sk_CMS_RecipientInfo_push(env-&gt;recipientInfos, ri))
+    if (!sk_CMS_RecipientInfo_push(ris, ri))
         goto merr;
 
     /* After this point no calls can fail */
@@ -774,7 +830,9 @@ static int cms_RecipientInfo_kekri_encrypt(const CMS_ContentInfo *cms,
     EVP_CIPHER_CTX *ctx = NULL;
     const CMS_CTX *cms_ctx = cms_get0_cmsctx(cms);
 
-    ec = cms-&gt;d.envelopedData-&gt;encryptedContentInfo;
+    ec = cms_get0_env_enc_content(cms);
+    if (ec == NULL)
+        return 0;
 
     kekri = ri-&gt;d.kekri;
 
@@ -843,7 +901,9 @@ static int cms_RecipientInfo_kekri_decrypt(CMS_ContentInfo *cms,
     EVP_CIPHER_CTX *ctx = NULL;
     const CMS_CTX *cms_ctx = cms_get0_cmsctx(cms);
 
-    ec = cms-&gt;d.envelopedData-&gt;encryptedContentInfo;
+    ec = cms_get0_env_enc_content(cms);
+    if (ec == NULL)
+        return 0;
 
     kekri = ri-&gt;d.kekri;
 
@@ -1013,6 +1073,28 @@ static void cms_env_set_version(CMS_EnvelopedData *env)
     env-&gt;version = 0;
 }
 
+static int cms_env_encrypt_content_key(const CMS_ContentInfo *cms,
+                                       STACK_OF(CMS_RecipientInfo) *ris)
+{
+    int i;
+    CMS_RecipientInfo *ri;
+
+    for (i = 0; i &lt; sk_CMS_RecipientInfo_num(ris); i++) {
+        ri = sk_CMS_RecipientInfo_value(ris, i);
+        if (CMS_RecipientInfo_encrypt(cms, ri) &lt;= 0)
+            return -1;
+    }
+    return 1;
+}
+
+static void cms_env_clear_ec(CMS_EncryptedContentInfo *ec)
+{
+    ec-&gt;cipher = NULL;
+    OPENSSL_clear_free(ec-&gt;key, ec-&gt;keylen);
+    ec-&gt;key = NULL;
+    ec-&gt;keylen = 0;
+}
+
 static BIO *cms_EnvelopedData_Decryption_init_bio(CMS_ContentInfo *cms)
 {
     CMS_EncryptedContentInfo *ec = cms-&gt;d.envelopedData-&gt;encryptedContentInfo;
@@ -1027,10 +1109,10 @@ static BIO *cms_EnvelopedData_Decryption_init_bio(CMS_ContentInfo *cms)
         BIO_free(contentBio);
         return NULL;
     }
-/*
- * If the selected cipher supports unprotected attributes,
- * deal with it using special ctrl function
- */
+    /*
+     * If the selected cipher supports unprotected attributes,
+     * deal with it using special ctrl function
+     */
     if ((EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_CIPHER_WITH_MAC)
          &amp;&amp; EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_PROCESS_UNPROTECTED, 0,
                                 cms-&gt;d.envelopedData-&gt;unprotectedAttrs) &lt;= 0) {
@@ -1044,13 +1126,13 @@ static BIO *cms_EnvelopedData_Encryption_init_bio(CMS_ContentInfo *cms)
 {
     CMS_EncryptedContentInfo *ec;
     STACK_OF(CMS_RecipientInfo) *rinfos;
-    CMS_RecipientInfo *ri;
-    int i, ok = 0;
+    int ok = 0;
     BIO *ret;
+    CMS_EnvelopedData *env = cms-&gt;d.envelopedData;
 
     /* Get BIO first to set up key */
 
-    ec = cms-&gt;d.envelopedData-&gt;encryptedContentInfo;
+    ec = env-&gt;encryptedContentInfo;
     ret = cms_EncryptedContent_init_bio(ec, cms_get0_cmsctx(cms));
 
     /* If error end of processing */
@@ -1058,24 +1140,20 @@ static BIO *cms_EnvelopedData_Encryption_init_bio(CMS_ContentInfo *cms)
         return ret;
 
     /* Now encrypt content key according to each RecipientInfo type */
-    rinfos = cms-&gt;d.envelopedData-&gt;recipientInfos;
-
-    for (i = 0; i &lt; sk_CMS_RecipientInfo_num(rinfos); i++) {
-         ri = sk_CMS_RecipientInfo_value(rinfos, i);
-         if (CMS_RecipientInfo_encrypt(cms, ri) &lt;= 0) {
-             CMSerr(0, CMS_R_ERROR_SETTING_RECIPIENTINFO);
-             goto err;
-         }
+    rinfos = env-&gt;recipientInfos;
+    if (cms_env_encrypt_content_key(cms, rinfos) &lt; 0) {
+        CMSerr(CMS_F_CMS_ENVELOPEDDATA_ENCRYPTION_INIT_BIO,
+               CMS_R_ERROR_SETTING_RECIPIENTINFO);
+        goto err;
     }
-    cms_env_set_version(cms-&gt;d.envelopedData);
+
+    /* And finally set the version */
+    cms_env_set_version(env);
 
     ok = 1;
 
  err:
-    ec-&gt;cipher = NULL;
-    OPENSSL_clear_free(ec-&gt;key, ec-&gt;keylen);
-    ec-&gt;key = NULL;
-    ec-&gt;keylen = 0;
+    cms_env_clear_ec(ec);
     if (ok)
         return ret;
     BIO_free(ret);
@@ -1093,6 +1171,121 @@ BIO *cms_EnvelopedData_init_bio(CMS_ContentInfo *cms)
     return cms_EnvelopedData_Decryption_init_bio(cms);
 }
 
+BIO *cms_AuthEnvelopedData_init_bio(CMS_ContentInfo *cms)
+{
+    CMS_EncryptedContentInfo *ec;
+    STACK_OF(CMS_RecipientInfo) *rinfos;
+    int ok = 0;
+    BIO *ret;
+    CMS_AuthEnvelopedData *aenv = cms-&gt;d.authEnvelopedData;
+
+    /* Get BIO first to set up key */
+    ec = aenv-&gt;authEncryptedContentInfo;
+    /* Set tag for decryption */
+    if (ec-&gt;cipher == NULL) {
+        ec-&gt;tag = aenv-&gt;mac-&gt;data;
+        ec-&gt;taglen = aenv-&gt;mac-&gt;length;
+    }
+    ret = cms_EncryptedContent_init_bio(ec, cms_get0_cmsctx(cms));
+
+    /* If error or no cipher end of processing */
+    if (ret == NULL || ec-&gt;cipher == NULL)
+        return ret;
+
+    /* Now encrypt content key according to each RecipientInfo type */
+    rinfos = aenv-&gt;recipientInfos;
+    if (cms_env_encrypt_content_key(cms, rinfos) &lt; 0) {
+        CMSerr(0, CMS_R_ERROR_SETTING_RECIPIENTINFO);
+        goto err;
+    }
+
+    /* And finally set the version */
+    aenv-&gt;version = 0;
+
+    ok = 1;
+
+ err:
+    cms_env_clear_ec(ec);
+    if (ok)
+        return ret;
+    BIO_free(ret);
+    return NULL;
+}
+
+int cms_EnvelopedData_final(CMS_ContentInfo *cms, BIO *chain)
+{
+    CMS_EnvelopedData *env = NULL;
+    EVP_CIPHER_CTX *ctx = NULL;
+    BIO *mbio = BIO_find_type(chain, BIO_TYPE_CIPHER);
+
+    env = cms_get0_enveloped(cms);
+    if (env == NULL)
+        return 0;
+
+    if (mbio == NULL) {
+        CMSerr(CMS_F_CMS_ENVELOPEDDATA_FINAL, CMS_R_CONTENT_NOT_FOUND);
+        return 0;
+    }
+
+    BIO_get_cipher_ctx(mbio, &amp;ctx);
+
+    /*
+     * If the selected cipher supports unprotected attributes,
+     * deal with it using special ctrl function
+     */
+    if (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(ctx)) &amp; EVP_CIPH_FLAG_CIPHER_WITH_MAC) {
+        if (env-&gt;unprotectedAttrs == NULL)
+            env-&gt;unprotectedAttrs = sk_X509_ATTRIBUTE_new_null();
+
+        if (env-&gt;unprotectedAttrs == NULL) {
+            CMSerr(CMS_F_CMS_ENVELOPEDDATA_FINAL, ERR_R_MALLOC_FAILURE);
+            return 0;
+        }
+
+        if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_PROCESS_UNPROTECTED,
+                                1, env-&gt;unprotectedAttrs) &lt;= 0) {
+            CMSerr(CMS_F_CMS_ENVELOPEDDATA_FINAL, CMS_R_CTRL_FAILURE);
+            return 0;
+        }
+    }
+
+    cms_env_set_version(cms-&gt;d.envelopedData);
+    return 1;
+}
+
+int cms_AuthEnvelopedData_final(CMS_ContentInfo *cms, BIO *cmsbio)
+{
+    EVP_CIPHER_CTX *ctx;
+    unsigned char *tag = NULL;
+    int taglen, ok = 0;
+
+    BIO_get_cipher_ctx(cmsbio, &amp;ctx);
+
+    /* 
+     * The tag is set only for encryption. There is nothing to do for
+     * decryption.
+     */
+    if (!EVP_CIPHER_CTX_encrypting(ctx))
+        return 1;
+
+    taglen = EVP_CIPHER_CTX_tag_length(ctx);
+    if (taglen &lt;= 0
+            || (tag = OPENSSL_malloc(taglen)) == NULL
+            || EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen,
+                                   tag) &lt;= 0) {
+        CMSerr(0, CMS_R_CIPHER_GET_TAG);
+        goto err;
+    }
+
+    if (!ASN1_OCTET_STRING_set(cms-&gt;d.authEnvelopedData-&gt;mac, tag, taglen))
+        goto err;
+
+    ok = 1;
+err:
+    OPENSSL_free(tag);
+    return ok;
+}
+
 /*
  * Get RecipientInfo type (if any) supported by a key (public or private). To
  * retain compatibility with previous behaviour if the ctrl value isn't
diff --git a/crypto/cms/cms_err.c b/crypto/cms/cms_err.c
index 16e25afc7f..da14c726c4 100644
--- a/crypto/cms/cms_err.c
+++ b/crypto/cms/cms_err.c
@@ -22,6 +22,9 @@ static const ERR_STRING_DATA CMS_str_reasons[] = {
     &quot;certificate has no keyid&quot;},
     {ERR_PACK(ERR_LIB_CMS, 0, CMS_R_CERTIFICATE_VERIFY_ERROR),
     &quot;certificate verify error&quot;},
+    {ERR_PACK(ERR_LIB_CMS, 0, CMS_R_CIPHER_AEAD_SET_TAG_ERROR),
+    &quot;cipher aead set tag error&quot;},
+    {ERR_PACK(ERR_LIB_CMS, 0, CMS_R_CIPHER_GET_TAG), &quot;cipher get tag&quot;},
     {ERR_PACK(ERR_LIB_CMS, 0, CMS_R_CIPHER_INITIALISATION_ERROR),
     &quot;cipher initialisation error&quot;},
     {ERR_PACK(ERR_LIB_CMS, 0, CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR),
diff --git a/crypto/cms/cms_kari.c b/crypto/cms/cms_kari.c
index 97b601b3bc..b5d85b7d67 100644
--- a/crypto/cms/cms_kari.c
+++ b/crypto/cms/cms_kari.c
@@ -291,7 +291,7 @@ int CMS_RecipientInfo_kari_decrypt(CMS_ContentInfo *cms,
     /* Attempt to decrypt CEK */
     if (!cms_kek_cipher(&amp;cek, &amp;ceklen, enckey, enckeylen, ri-&gt;d.kari, 0))
         goto err;
-    ec = cms-&gt;d.envelopedData-&gt;encryptedContentInfo;
+    ec = cms_get0_env_enc_content(cms);
     OPENSSL_clear_free(ec-&gt;key, ec-&gt;keylen);
     ec-&gt;key = cek;
     ec-&gt;keylen = ceklen;
@@ -533,7 +533,7 @@ int cms_RecipientInfo_kari_encrypt(const CMS_ContentInfo *cms,
     }
     kari = ri-&gt;d.kari;
     reks = kari-&gt;recipientEncryptedKeys;
-    ec = cms-&gt;d.envelopedData-&gt;encryptedContentInfo;
+    ec = cms_get0_env_enc_content(cms);
     /* Initialise wrap algorithm parameters */
     if (!cms_wrap_init(kari, ec-&gt;cipher))
         return 0;
diff --git a/crypto/cms/cms_lib.c b/crypto/cms/cms_lib.c
index 7c9b2494a2..9fc8453d99 100644
--- a/crypto/cms/cms_lib.c
+++ b/crypto/cms/cms_lib.c
@@ -189,6 +189,10 @@ BIO *CMS_dataInit(CMS_ContentInfo *cms, BIO *icont)
         cmsbio = cms_EnvelopedData_init_bio(cms);
         break;
 
+    case NID_id_smime_ct_authEnvelopedData:
+        cmsbio = cms_AuthEnvelopedData_init_bio(cms);
+        break;
+
     default:
         CMSerr(CMS_F_CMS_DATAINIT, CMS_R_UNSUPPORTED_TYPE);
         goto err;
@@ -239,6 +243,9 @@ int CMS_dataFinal(CMS_ContentInfo *cms, BIO *cmsbio)
     case NID_pkcs7_enveloped:
         return cms_EnvelopedData_final(cms, cmsbio);
 
+    case NID_id_smime_ct_authEnvelopedData:
+        return cms_AuthEnvelopedData_final(cms, cmsbio);
+
     case NID_pkcs7_signed:
         return cms_SignedData_final(cms, cmsbio);
 
@@ -275,6 +282,10 @@ ASN1_OCTET_STRING **CMS_get0_content(CMS_ContentInfo *cms)
     case NID_pkcs7_encrypted:
         return &amp;cms-&gt;d.encryptedData-&gt;encryptedContentInfo-&gt;encryptedContent;
 
+    case NID_id_smime_ct_authEnvelopedData:
+        return &amp;cms-&gt;d.authEnvelopedData-&gt;authEncryptedContentInfo
+                                        -&gt;encryptedContent;
+
     case NID_id_smime_ct_authData:
         return &amp;cms-&gt;d.authenticatedData-&gt;encapContentInfo-&gt;eContent;
 
@@ -311,6 +322,9 @@ static ASN1_OBJECT **cms_get0_econtent_type(CMS_ContentInfo *cms)
     case NID_pkcs7_encrypted:
         return &amp;cms-&gt;d.encryptedData-&gt;encryptedContentInfo-&gt;contentType;
 
+    case NID_id_smime_ct_authEnvelopedData:
+        return &amp;cms-&gt;d.authEnvelopedData-&gt;authEncryptedContentInfo
+                                        -&gt;contentType;
     case NID_id_smime_ct_authData:
         return &amp;cms-&gt;d.authenticatedData-&gt;encapContentInfo-&gt;eContentType;
 
@@ -472,6 +486,11 @@ static STACK_OF(CMS_CertificateChoices)
             return NULL;
         return &amp;cms-&gt;d.envelopedData-&gt;originatorInfo-&gt;certificates;
 
+    case NID_id_smime_ct_authEnvelopedData:
+        if (cms-&gt;d.authEnvelopedData-&gt;originatorInfo == NULL)
+            return NULL;
+        return &amp;cms-&gt;d.authEnvelopedData-&gt;originatorInfo-&gt;certificates;
+
     default:
         CMSerr(CMS_F_CMS_GET0_CERTIFICATE_CHOICES,
                CMS_R_UNSUPPORTED_CONTENT_TYPE);
@@ -551,6 +570,11 @@ static STACK_OF(CMS_RevocationInfoChoice)
             return NULL;
         return &amp;cms-&gt;d.envelopedData-&gt;originatorInfo-&gt;crls;
 
+    case NID_id_smime_ct_authEnvelopedData:
+        if (cms-&gt;d.authEnvelopedData-&gt;originatorInfo == NULL)
+            return NULL;
+        return &amp;cms-&gt;d.authEnvelopedData-&gt;originatorInfo-&gt;crls;
+
     default:
         CMSerr(CMS_F_CMS_GET0_REVOCATION_CHOICES,
                CMS_R_UNSUPPORTED_CONTENT_TYPE);
diff --git a/crypto/cms/cms_local.h b/crypto/cms/cms_local.h
index 4e85459a54..336c354655 100644
--- a/crypto/cms/cms_local.h
+++ b/crypto/cms/cms_local.h
@@ -29,6 +29,7 @@ typedef struct CMS_EnvelopedData_st CMS_EnvelopedData;
 typedef struct CMS_DigestedData_st CMS_DigestedData;
 typedef struct CMS_EncryptedData_st CMS_EncryptedData;
 typedef struct CMS_AuthenticatedData_st CMS_AuthenticatedData;
+typedef struct CMS_AuthEnvelopedData_st CMS_AuthEnvelopedData;
 typedef struct CMS_CompressedData_st CMS_CompressedData;
 typedef struct CMS_OtherCertificateFormat_st CMS_OtherCertificateFormat;
 typedef struct CMS_KeyTransRecipientInfo_st CMS_KeyTransRecipientInfo;
@@ -58,6 +59,7 @@ struct CMS_ContentInfo_st {
         CMS_EnvelopedData *envelopedData;
         CMS_DigestedData *digestedData;
         CMS_EncryptedData *encryptedData;
+        CMS_AuthEnvelopedData *authEnvelopedData;
         CMS_AuthenticatedData *authenticatedData;
         CMS_CompressedData *compressedData;
         ASN1_TYPE *other;
@@ -127,10 +129,12 @@ struct CMS_EncryptedContentInfo_st {
     ASN1_OBJECT *contentType;
     X509_ALGOR *contentEncryptionAlgorithm;
     ASN1_OCTET_STRING *encryptedContent;
-    /* Content encryption algorithm and key */
+    /* Content encryption algorithm, key and tag */
     const EVP_CIPHER *cipher;
     unsigned char *key;
     size_t keylen;
+    unsigned char *tag;
+    size_t taglen;
     /* Set to 1 if we are debugging decrypt and don't fake keys for MMA */
     int debug;
     /* Set to 1 if we have no cert and need extra safety measures for MMA */
@@ -269,6 +273,16 @@ struct CMS_AuthenticatedData_st {
     STACK_OF(X509_ATTRIBUTE) *unauthAttrs;
 };
 
+struct CMS_AuthEnvelopedData_st {
+    int32_t version;
+    CMS_OriginatorInfo *originatorInfo;
+    STACK_OF(CMS_RecipientInfo) *recipientInfos;
+    CMS_EncryptedContentInfo *authEncryptedContentInfo;
+    STACK_OF(X509_ATTRIBUTE) *authAttrs;
+    ASN1_OCTET_STRING *mac;
+    STACK_OF(X509_ATTRIBUTE) *unauthAttrs;
+};
+
 struct CMS_CompressedData_st {
     int32_t version;
     X509_ALGOR *compressionAlgorithm;
@@ -425,7 +439,11 @@ ASN1_OCTET_STRING *cms_encode_Receipt(CMS_SignerInfo *si);
 
 BIO *cms_EnvelopedData_init_bio(CMS_ContentInfo *cms);
 int cms_EnvelopedData_final(CMS_ContentInfo *cms, BIO *chain);
+BIO *cms_AuthEnvelopedData_init_bio(CMS_ContentInfo *cms);
+int cms_AuthEnvelopedData_final(CMS_ContentInfo *cms, BIO *cmsbio);
 CMS_EnvelopedData *cms_get0_enveloped(CMS_ContentInfo *cms);
+CMS_AuthEnvelopedData *cms_get0_auth_enveloped(CMS_ContentInfo *cms);
+CMS_EncryptedContentInfo* cms_get0_env_enc_content(const CMS_ContentInfo *cms);
 
 /* RecipientInfo routines */
 int cms_env_asn1_ctrl(CMS_RecipientInfo *ri, int cmd);
@@ -457,6 +475,7 @@ DECLARE_ASN1_ITEM(CMS_CertificateChoices)
 DECLARE_ASN1_ITEM(CMS_DigestedData)
 DECLARE_ASN1_ITEM(CMS_EncryptedData)
 DECLARE_ASN1_ITEM(CMS_EnvelopedData)
+DECLARE_ASN1_ITEM(CMS_AuthEnvelopedData)
 DECLARE_ASN1_ITEM(CMS_KEKRecipientInfo)
 DECLARE_ASN1_ITEM(CMS_KeyAgreeRecipientInfo)
 DECLARE_ASN1_ITEM(CMS_KeyTransRecipientInfo)
diff --git a/crypto/cms/cms_pwri.c b/crypto/cms/cms_pwri.c
index 1ca5a7ee07..e281bd72f2 100644
--- a/crypto/cms/cms_pwri.c
+++ b/crypto/cms/cms_pwri.c
@@ -44,8 +44,9 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
                                                ossl_ssize_t passlen,
                                                const EVP_CIPHER *kekciph)
 {
+    STACK_OF(CMS_RecipientInfo) *ris;
     CMS_RecipientInfo *ri = NULL;
-    CMS_EnvelopedData *env;
+    CMS_EncryptedContentInfo *ec;
     CMS_PasswordRecipientInfo *pwri;
     EVP_CIPHER_CTX *ctx = NULL;
     X509_ALGOR *encalg = NULL;
@@ -53,8 +54,11 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
     int ivlen;
     const CMS_CTX *cms_ctx = cms_get0_cmsctx(cms);
 
-    env = cms_get0_enveloped(cms);
-    if (!env)
+    ec = cms_get0_env_enc_content(cms);
+    if (ec == NULL)
+        return NULL;
+    ris = CMS_get0_RecipientInfos(cms);
+    if (ris == NULL)
         return NULL;
 
     if (wrap_nid &lt;= 0)
@@ -65,7 +69,7 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
 
     /* Get from enveloped data */
     if (kekciph == NULL)
-        kekciph = env-&gt;encryptedContentInfo-&gt;cipher;
+        kekciph = ec-&gt;cipher;
 
     if (kekciph == NULL) {
         CMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, CMS_R_NO_CIPHER);
@@ -156,7 +160,7 @@ CMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,
     CMS_RecipientInfo_set0_password(ri, pass, passlen);
     pwri-&gt;version = 0;
 
-    if (!sk_CMS_RecipientInfo_push(env-&gt;recipientInfos, ri))
+    if (!sk_CMS_RecipientInfo_push(ris, ri))
         goto merr;
 
     return ri;
@@ -292,7 +296,7 @@ int cms_RecipientInfo_pwri_crypt(const CMS_ContentInfo *cms,
     size_t keylen;
     const CMS_CTX *cms_ctx = cms_get0_cmsctx(cms);
 
-    ec = cms-&gt;d.envelopedData-&gt;encryptedContentInfo;
+    ec = cms_get0_env_enc_content(cms);
 
     pwri = ri-&gt;d.pwri;
 
diff --git a/crypto/cms/cms_smime.c b/crypto/cms/cms_smime.c
index 11c9fed1a8..92de68aa57 100644
--- a/crypto/cms/cms_smime.c
+++ b/crypto/cms/cms_smime.c
@@ -638,7 +638,10 @@ CMS_ContentInfo *CMS_encrypt_with_libctx(STACK_OF(X509) *certs,
     int i;
     X509 *recip;
 
-    cms = CMS_EnvelopedData_create_with_libctx(cipher, libctx, propq);
+
+    cms = (EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)
+          ? CMS_AuthEnvelopedData_create_with_libctx(cipher, libctx, propq)
+          : CMS_EnvelopedData_create_with_libctx(cipher, libctx, propq);
     if (cms == NULL)
         goto merr;
     for (i = 0; i &lt; sk_X509_num(certs); i++) {
@@ -711,7 +714,7 @@ int CMS_decrypt_set1_pkey_and_peer(CMS_ContentInfo *cms, EVP_PKEY *pk,
 
     ris = CMS_get0_RecipientInfos(cms);
     if (ris != NULL)
-        debug = cms-&gt;d.envelopedData-&gt;encryptedContentInfo-&gt;debug;
+        debug = cms_get0_env_enc_content(cms)-&gt;debug;
 
     cms_pkey_ri_type = cms_pkey_get_ri_type(pk);
     if (cms_pkey_ri_type == CMS_RECIPINFO_NONE) {
@@ -848,20 +851,23 @@ int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,
     int r;
     BIO *cont;
 
-    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {
+    int nid = OBJ_obj2nid(CMS_get0_type(cms));
+
+    if (nid != NID_pkcs7_enveloped
+            &amp;&amp; nid != NID_id_smime_ct_authEnvelopedData) {
         CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);
         return 0;
     }
     if (dcont == NULL &amp;&amp; !check_content(cms))
         return 0;
     if (flags &amp; CMS_DEBUG_DECRYPT)
-        cms-&gt;d.envelopedData-&gt;encryptedContentInfo-&gt;debug = 1;
+        cms_get0_env_enc_content(cms)-&gt;debug = 1;
     else
-        cms-&gt;d.envelopedData-&gt;encryptedContentInfo-&gt;debug = 0;
+        cms_get0_env_enc_content(cms)-&gt;debug = 0;
     if (cert == NULL)
-        cms-&gt;d.envelopedData-&gt;encryptedContentInfo-&gt;havenocert = 1;
+        cms_get0_env_enc_content(cms)-&gt;havenocert = 1;
     else
-        cms-&gt;d.envelopedData-&gt;encryptedContentInfo-&gt;havenocert = 0;
+        cms_get0_env_enc_content(cms)-&gt;havenocert = 0;
     if (pk == NULL &amp;&amp; cert == NULL &amp;&amp; dcont == NULL &amp;&amp; out == NULL)
         return 1;
     if (pk != NULL &amp;&amp; !CMS_decrypt_set1_pkey(cms, pk, cert))
diff --git a/crypto/err/openssl.txt b/crypto/err/openssl.txt
index 256ec35588..44e36805f6 100644
--- a/crypto/err/openssl.txt
+++ b/crypto/err/openssl.txt
@@ -63,6 +63,7 @@ ASN1_F_ASN1_TEMPLATE_NOEXP_D2I:131:asn1_template_noexp_d2i
 ASN1_F_ASN1_TIME_ADJ:217:ASN1_TIME_adj
 ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING:134:ASN1_TYPE_get_int_octetstring
 ASN1_F_ASN1_TYPE_GET_OCTETSTRING:135:ASN1_TYPE_get_octetstring
+ASN1_F_ASN1_TYPE_GET_OCTETSTRING_INT:146:
 ASN1_F_ASN1_UTCTIME_ADJ:218:ASN1_UTCTIME_adj
 ASN1_F_ASN1_VERIFY:137:ASN1_verify
 ASN1_F_B64_READ_ASN1:209:b64_read_asn1
@@ -2172,6 +2173,8 @@ CMS_R_ATTRIBUTE_ERROR:161:attribute error
 CMS_R_CERTIFICATE_ALREADY_PRESENT:175:certificate already present
 CMS_R_CERTIFICATE_HAS_NO_KEYID:160:certificate has no keyid
 CMS_R_CERTIFICATE_VERIFY_ERROR:100:certificate verify error
+CMS_R_CIPHER_AEAD_SET_TAG_ERROR:184:cipher aead set tag error
+CMS_R_CIPHER_GET_TAG:185:cipher get tag
 CMS_R_CIPHER_INITIALISATION_ERROR:101:cipher initialisation error
 CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR:102:\
 	cipher parameter initialisation error
diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
index 676461a51b..81151e4f01 100644
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -22,11 +22,59 @@
 #include &lt;openssl/dh.h&gt;
 #include &lt;openssl/ec.h&gt;
 #include &quot;crypto/evp.h&quot;
+#include &quot;crypto/asn1.h&quot;
 #include &quot;internal/provider.h&quot;
 #include &quot;evp_local.h&quot;
 
 #if !defined(FIPS_MODULE)
 int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
+{
+    return evp_cipher_param_to_asn1_ex(c, type, NULL);
+}
+
+int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
+{
+    return evp_cipher_asn1_to_param_ex(c, type, NULL);
+}
+
+int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *ctx, ASN1_TYPE *type)
+{
+    int i = 0;
+    unsigned int l;
+
+    if (type != NULL) {
+        unsigned char iv[EVP_MAX_IV_LENGTH];
+
+        l = EVP_CIPHER_CTX_iv_length(ctx);
+        if (!ossl_assert(l &lt;= sizeof(iv)))
+            return -1;
+        i = ASN1_TYPE_get_octetstring(type, iv, l);
+        if (i != (int)l)
+            return -1;
+
+        if (!EVP_CipherInit_ex(ctx, NULL, NULL, NULL, iv, -1))
+            return -1;
+    }
+    return i;
+}
+
+int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
+{
+    int i = 0;
+    unsigned int j;
+    unsigned char *oiv = NULL;
+
+    if (type != NULL) {
+        oiv = (unsigned char *)EVP_CIPHER_CTX_original_iv(c);
+        j = EVP_CIPHER_CTX_iv_length(c);
+        OPENSSL_assert(j &lt;= sizeof(c-&gt;iv));
+        i = ASN1_TYPE_set_octetstring(type, oiv, j);
+    }
+    return i;
+}
+
+int evp_cipher_param_to_asn1_ex(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
+                                evp_cipher_aead_asn1_params *asn1_params)
 {
     int ret = -1;                /* Assume the worst */
     const EVP_CIPHER *cipher = c-&gt;cipher;
@@ -58,6 +106,9 @@ int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
             break;
 
         case EVP_CIPH_GCM_MODE:
+            ret = evp_cipher_set_asn1_aead_params(c, type, asn1_params);
+            break;
+
         case EVP_CIPH_CCM_MODE:
         case EVP_CIPH_XTS_MODE:
         case EVP_CIPH_OCB_MODE:
@@ -104,15 +155,16 @@ int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
 
  err:
     if (ret == -2)
-        EVPerr(EVP_F_EVP_CIPHER_PARAM_TO_ASN1, ASN1_R_UNSUPPORTED_CIPHER);
+        EVPerr(0, EVP_R_UNSUPPORTED_CIPHER);
     else if (ret &lt;= 0)
-        EVPerr(EVP_F_EVP_CIPHER_PARAM_TO_ASN1, EVP_R_CIPHER_PARAMETER_ERROR);
+        EVPerr(0, EVP_R_CIPHER_PARAMETER_ERROR);
     if (ret &lt; -1)
         ret = -1;
     return ret;
 }
 
-int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
+int evp_cipher_asn1_to_param_ex(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
+                                evp_cipher_aead_asn1_params *asn1_params)
 {
     int ret = -1;                /* Assume the worst */
     const EVP_CIPHER *cipher = c-&gt;cipher;
@@ -142,6 +194,9 @@ int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
             break;
 
         case EVP_CIPH_GCM_MODE:
+            ret = evp_cipher_get_asn1_aead_params(c, type, asn1_params);
+            break;
+
         case EVP_CIPH_CCM_MODE:
         case EVP_CIPH_XTS_MODE:
         case EVP_CIPH_OCB_MODE:
@@ -170,47 +225,43 @@ int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
     }
 
     if (ret == -2)
-        EVPerr(EVP_F_EVP_CIPHER_ASN1_TO_PARAM, EVP_R_UNSUPPORTED_CIPHER);
+        EVPerr(0, EVP_R_UNSUPPORTED_CIPHER);
     else if (ret &lt;= 0)
-        EVPerr(EVP_F_EVP_CIPHER_ASN1_TO_PARAM, EVP_R_CIPHER_PARAMETER_ERROR);
+        EVPerr(0, EVP_R_CIPHER_PARAMETER_ERROR);
     if (ret &lt; -1)
         ret = -1;
     return ret;
 }
 
-int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *ctx, ASN1_TYPE *type)
+int evp_cipher_get_asn1_aead_params(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
+                                    evp_cipher_aead_asn1_params *asn1_params)
 {
     int i = 0;
-    unsigned int l;
+    long tl;
+    unsigned char iv[EVP_MAX_IV_LENGTH];
 
-    if (type != NULL) {
-        unsigned char iv[EVP_MAX_IV_LENGTH];
+    if (type == NULL || asn1_params == NULL)
+        return 0;
 
-        l = EVP_CIPHER_CTX_iv_length(ctx);
-        if (!ossl_assert(l &lt;= sizeof(iv)))
-            return -1;
-        i = ASN1_TYPE_get_octetstring(type, iv, l);
-        if (i != (int)l)
-            return -1;
+    i = asn1_type_get_octetstring_int(type, &amp;tl, NULL, EVP_MAX_IV_LENGTH);
+    if (i &lt;= 0)
+        return -1;
+    asn1_type_get_octetstring_int(type, &amp;tl, iv, i);
+
+    memcpy(asn1_params-&gt;iv, iv, i);
+    asn1_params-&gt;iv_len = i;
 
-        if (!EVP_CipherInit_ex(ctx, NULL, NULL, NULL, iv, -1))
-            return -1;
-    }
     return i;
 }
 
-int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
+int evp_cipher_set_asn1_aead_params(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
+                                    evp_cipher_aead_asn1_params *asn1_params)
 {
-    int i = 0;
-    unsigned int j;
-    unsigned char oiv[EVP_MAX_IV_LENGTH];
+    if (type == NULL || asn1_params == NULL)
+        return 0;
 
-    if (type != NULL &amp;&amp; EVP_CIPHER_CTX_get_iv(c, oiv, sizeof(oiv))) {
-        j = EVP_CIPHER_CTX_iv_length(c);
-        OPENSSL_assert(j &lt;= sizeof(c-&gt;iv));
-        i = ASN1_TYPE_set_octetstring(type, oiv, j);
-    }
-    return i;
+    return asn1_type_set_octetstring_int(type, asn1_params-&gt;tag_len,
+                                         asn1_params-&gt;iv, asn1_params-&gt;iv_len);
 }
 #endif /* !defined(FIPS_MODULE) */
 
diff --git a/crypto/evp/evp_local.h b/crypto/evp/evp_local.h
index 1e1d689070..e7f7643d83 100644
--- a/crypto/evp/evp_local.h
+++ b/crypto/evp/evp_local.h
@@ -240,6 +240,11 @@ EVP_KEYMGMT *evp_keymgmt_fetch_by_number(OPENSSL_CTX *ctx, int name_id,
 EVP_MD *evp_md_new(void);
 EVP_CIPHER *evp_cipher_new(void);
 
+int evp_cipher_get_asn1_aead_params(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
+                                    evp_cipher_aead_asn1_params *asn1_params);
+int evp_cipher_set_asn1_aead_params(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
+                                    evp_cipher_aead_asn1_params *asn1_params);
+
 /* Helper functions to avoid duplicating code */
 
 /*
diff --git a/doc/man1/openssl-cms.pod.in b/doc/man1/openssl-cms.pod.in
index def9766b3c..ebe3fbda8c 100644
--- a/doc/man1/openssl-cms.pod.in
+++ b/doc/man1/openssl-cms.pod.in
@@ -309,6 +309,9 @@ EVP_get_cipherbyname() function) can also be used preceded by a dash, for
 example B&lt;-aes-128-cbc&gt;. See L&lt;openssl-enc(1)&gt; for a list of ciphers
 supported by your version of OpenSSL.
 
+Currently the AES variants with GCM mode are the only supported AEAD
+algorithms.
+
 If not specified triple DES is used. Only used with B&lt;-encrypt&gt; and
 B&lt;-EncryptedData_create&gt; commands.
 
diff --git a/doc/man3/CMS_EnvelopedData_create.pod b/doc/man3/CMS_EnvelopedData_create.pod
index e6903ea3f8..6978aaabcb 100644
--- a/doc/man3/CMS_EnvelopedData_create.pod
+++ b/doc/man3/CMS_EnvelopedData_create.pod
@@ -2,25 +2,39 @@
 
 =head1 NAME
 
-CMS_EnvelopedData_create_with_libctx, CMS_EnvelopedData_create
+CMS_EnvelopedData_create_with_libctx, CMS_EnvelopedData_create,
+CMS_AuthEnvelopedData_create, CMS_AuthEnvelopedData_create_with_libctx
 - Create CMS envelope
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/cms.h&gt;
 
- CMS_ContentInfo *CMS_EnvelopedData_create_with_libctx(const EVP_CIPHER *cipher,
-                                                       OPENSSL_CTX *libctx,
-                                                       const char *propq);
+ CMS_ContentInfo *
+ CMS_EnvelopedData_create_with_libctx(const EVP_CIPHER *cipher,
+                                      OPENSSL_CTX *libctx,
+                                      const char *propq);
  CMS_ContentInfo *CMS_EnvelopedData_create(const EVP_CIPHER *cipher);
 
+ CMS_ContentInfo *
+ CMS_AuthEnvelopedData_create_with_libctx(const EVP_CIPHER *cipher,
+                                          OPENSSL_CTX *libctx,
+                                          const char *propq);
+ CMS_ContentInfo *CMS_AuthEnvelopedData_create(const EVP_CIPHER *cipher);
+
 =head1 DESCRIPTION
 
-CMS_EnvelopedData_create_with_libctx() creates a B&lt;CMS_ContentInfo&gt; structure with
-a type B&lt;NID_pkcs7_enveloped&gt;. I&lt;cipher&gt; is the symmetric cipher to use. The
-library context I&lt;libctx&gt; and the property query I&lt;propq&gt; are used when
+CMS_EnvelopedData_create_with_libctx() creates a B&lt;CMS_ContentInfo&gt; structure
+with a type B&lt;NID_pkcs7_enveloped&gt;. I&lt;cipher&gt; is the symmetric cipher to use.
+The library context I&lt;libctx&gt; and the property query I&lt;propq&gt; are used when
 retrieving algorithms from providers.
 
+CMS_AuthEnvelopedData_create_with_libctx() creates a B&lt;CMS_ContentInfo&gt;
+structure with a type B&lt;NID_id_smime_ct_authEnvelopedData&gt;. B&lt;cipher&gt; is the
+symmetric AEAD cipher to use. Currently only AES variants with GCM mode are
+supported. The library context I&lt;libctx&gt; and the property query I&lt;propq&gt; are
+used when retrieving algorithms from providers.
+
 The algorithm passed in the I&lt;cipher&gt; parameter must support ASN1 encoding of
 its parameters.
 
@@ -30,21 +44,23 @@ L&lt;CMS_add0_recipient_key(3)&gt;.
 The B&lt;CMS_ContentInfo&gt; structure needs to be finalized using L&lt;CMS_final(3)&gt;
 and then freed using L&lt;CMS_ContentInfo_free(3)&gt;.
 
-CMS_EnvelopedData_create() is similar to CMS_EnvelopedData_create_with_libctx()
-but uses default values of NULL for the library context I&lt;libctx&gt; and the
-property query I&lt;propq&gt;.
+CMS_EnvelopedData_create() and  CMS_AuthEnvelopedData_create are similar to
+CMS_EnvelopedData_create_with_libctx() and
+CMS_AuthEnvelopedData_create_with_libctx() but use default values of NULL for
+the library context I&lt;libctx&gt; and the property query I&lt;propq&gt;.
 
 =head1 NOTES
 
-Although CMS_EnvelopedData_create() allocates a new B&lt;CMS_ContentInfo&gt;
-structure it is usually not used in applications. The wrappers
-L&lt;CMS_encrypt(3)&gt; and L&lt;CMS_decrypt(3)&gt; are often used instead.
+Although CMS_EnvelopedData_create() and CMS_AuthEnvelopedData_create() allocate
+a new B&lt;CMS_ContentInfo&gt; structure, they are not usually used in applications.
+The wrappers L&lt;CMS_encrypt(3)&gt; and L&lt;CMS_decrypt(3)&gt; are often used instead.
 
 =head1 RETURN VALUES
 
-If the allocation fails, CMS_EnvelopedData_create() returns NULL and sets
-an error code that can be obtained by L&lt;ERR_get_error(3)&gt;.
-Otherwise it returns a pointer to the newly allocated structure.
+If the allocation fails, CMS_EnvelopedData_create() and
+CMS_AuthEnvelopedData_create() return NULL and set an error code that can be
+obtained by L&lt;ERR_get_error(3)&gt;. Otherwise they return a pointer to the newly
+allocated structure.
 
 =head1 SEE ALSO
 
diff --git a/doc/man3/CMS_decrypt.pod b/doc/man3/CMS_decrypt.pod
index 3124fa8394..4f8d32fbbb 100644
--- a/doc/man3/CMS_decrypt.pod
+++ b/doc/man3/CMS_decrypt.pod
@@ -18,9 +18,9 @@ content from a CMS envelopedData structure
 =head1 DESCRIPTION
 
 CMS_decrypt() extracts and decrypts the content from a CMS EnvelopedData
-structure. B&lt;pkey&gt; is the private key of the recipient, B&lt;cert&gt; is the
-recipient's certificate, B&lt;out&gt; is a BIO to write the content to and
-B&lt;flags&gt; is an optional set of flags.
+or AuthEnvelopedData structure. B&lt;pkey&gt; is the private key of the recipient,
+B&lt;cert&gt; is the recipient's certificate, B&lt;out&gt; is a BIO to write the content to
+and B&lt;flags&gt; is an optional set of flags.
 
 The B&lt;dcont&gt; parameter is used in the rare case where the encrypted content
 is detached. It will normally be set to NULL.
diff --git a/doc/man3/CMS_encrypt.pod b/doc/man3/CMS_encrypt.pod
index 211ec18d36..9fe92e3ee6 100644
--- a/doc/man3/CMS_encrypt.pod
+++ b/doc/man3/CMS_encrypt.pod
@@ -11,17 +11,19 @@ CMS_encrypt_with_libctx, CMS_encrypt - create a CMS envelopedData structure
  CMS_ContentInfo *CMS_encrypt_with_libctx(STACK_OF(X509) *certs,
                                           BIO *in, const EVP_CIPHER *cipher,
                                           unsigned int flags,
-                                          OPENSSL_CTX *libctx, const char *propq);
+                                          OPENSSL_CTX *libctx,
+                                          const char *propq);
  CMS_ContentInfo *CMS_encrypt(STACK_OF(X509) *certs, BIO *in,
                               const EVP_CIPHER *cipher, unsigned int flags);
 
 =head1 DESCRIPTION
 
-CMS_encrypt_with_libctx() creates and returns a CMS EnvelopedData structure.
-I&lt;certs&gt; is a list of recipient certificates. I&lt;in&gt; is the content to be
-encrypted. I&lt;cipher&gt; is the symmetric cipher to use. I&lt;flags&gt; is an optional set
-of flags. The library context I&lt;libctx&gt; and the property query I&lt;propq&gt; are used
-internally when retrieving algorithms from providers.
+CMS_encrypt_with_libctx() creates and returns a CMS EnvelopedData or
+AuthEnvelopedData structure. I&lt;certs&gt; is a list of recipient certificates.
+I&lt;in&gt; is the content to be encrypted. I&lt;cipher&gt; is the symmetric cipher to use.
+I&lt;flags&gt; is an optional set of flags. The library context I&lt;libctx&gt; and the
+property query I&lt;propq&gt; are used internally when retrieving algorithms from
+providers.
 
 Only certificates carrying RSA, Diffie-Hellman or EC keys are supported by this
 function.
@@ -30,7 +32,9 @@ EVP_des_ede3_cbc() (triple DES) is the algorithm of choice for S/MIME use
 because most clients will support it.
 
 The algorithm passed in the B&lt;cipher&gt; parameter must support ASN1 encoding of
-its parameters.
+its parameters. If the cipher mode is GCM, then an AuthEnvelopedData structure
+containing MAC is used. Otherwise an EnvelopedData structure is used. Currently
+the AES variants with GCM mode are the only supported AEAD algorithms.
 
 Many browsers implement a &quot;sign and encrypt&quot; option which is simply an S/MIME
 envelopedData containing an S/MIME signed message. This can be readily produced
@@ -81,8 +85,8 @@ and CMS_add0_recipient_key().
 The parameter B&lt;certs&gt; may be NULL if B&lt;CMS_PARTIAL&gt; is set and recipients
 added later using CMS_add1_recipient_cert() or CMS_add0_recipient_key().
 
-CMS_encrypt() is similar to CMS_encrypt_with_libctx() but uses default values of
-NULL for the library context I&lt;libctx&gt; and the property query I&lt;propq&gt;.
+CMS_encrypt() is similar to CMS_encrypt_with_libctx() but uses default values
+of NULL for the library context I&lt;libctx&gt; and the property query I&lt;propq&gt;.
 
 =head1 RETURN VALUES
 
diff --git a/include/crypto/asn1.h b/include/crypto/asn1.h
index 624df3cb05..6e1d396851 100644
--- a/include/crypto/asn1.h
+++ b/include/crypto/asn1.h
@@ -7,6 +7,8 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
+#include &lt;openssl/asn1.h&gt;
+
 /* Internal ASN1 structures and functions: not for application use */
 
 /* ASN1 public key method structure */
@@ -124,3 +126,10 @@ struct asn1_pctx_st {
     unsigned long oid_flags;
     unsigned long str_flags;
 } /* ASN1_PCTX */ ;
+
+/* ASN1 type functions */
+
+int asn1_type_set_octetstring_int(ASN1_TYPE *a, long num,
+                                  unsigned char *data, int len);
+int asn1_type_get_octetstring_int(const ASN1_TYPE *a, long *num,
+                                  unsigned char *data, int max_len);
diff --git a/include/crypto/evp.h b/include/crypto/evp.h
index 7008e490e8..c488834511 100644
--- a/include/crypto/evp.h
+++ b/include/crypto/evp.h
@@ -511,6 +511,18 @@ const EVP_CIPHER *EVP_##cname##_ecb(void) { return &amp;cname##_ecb; }
                              (fl)|EVP_CIPH_FLAG_DEFAULT_ASN1, \
                              cipher##_init_key, NULL, NULL, NULL, NULL)
 
+typedef struct {
+    unsigned char iv[EVP_MAX_IV_LENGTH];
+    unsigned int iv_len;
+    unsigned int tag_len;
+} evp_cipher_aead_asn1_params;
+
+int evp_cipher_param_to_asn1_ex(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
+                                evp_cipher_aead_asn1_params *params);
+
+int evp_cipher_asn1_to_param_ex(EVP_CIPHER_CTX *c, ASN1_TYPE *type,
+                                evp_cipher_aead_asn1_params *params);
+
 /*
  * An EVP_PKEY can have the following states:
  *
diff --git a/include/openssl/asn1err.h b/include/openssl/asn1err.h
index f610d8816d..b58339ba47 100644
--- a/include/openssl/asn1err.h
+++ b/include/openssl/asn1err.h
@@ -82,6 +82,7 @@ int ERR_load_ASN1_strings(void);
 #  define ASN1_F_ASN1_TIME_ADJ                             0
 #  define ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING             0
 #  define ASN1_F_ASN1_TYPE_GET_OCTETSTRING                 0
+#  define ASN1_F_ASN1_TYPE_GET_OCTETSTRING_INT             0
 #  define ASN1_F_ASN1_UTCTIME_ADJ                          0
 #  define ASN1_F_ASN1_VERIFY                               0
 #  define ASN1_F_B64_READ_ASN1                             0
diff --git a/include/openssl/cms.h b/include/openssl/cms.h
index 7397008fcb..ad6718dd6f 100644
--- a/include/openssl/cms.h
+++ b/include/openssl/cms.h
@@ -189,6 +189,11 @@ int CMS_decrypt_set1_password(CMS_ContentInfo *cms,
 STACK_OF(CMS_RecipientInfo) *CMS_get0_RecipientInfos(CMS_ContentInfo *cms);
 int CMS_RecipientInfo_type(CMS_RecipientInfo *ri);
 EVP_PKEY_CTX *CMS_RecipientInfo_get0_pkey_ctx(CMS_RecipientInfo *ri);
+CMS_ContentInfo *CMS_AuthEnvelopedData_create(const EVP_CIPHER *cipher);
+CMS_ContentInfo *
+CMS_AuthEnvelopedData_create_with_libctx(const EVP_CIPHER *cipher,
+                                         OPENSSL_CTX *ctx,
+                                         const char *propq);
 CMS_ContentInfo *CMS_EnvelopedData_create(const EVP_CIPHER *cipher);
 CMS_ContentInfo *CMS_EnvelopedData_create_with_libctx(const EVP_CIPHER *cipher,
                                                       OPENSSL_CTX *ctx,
diff --git a/include/openssl/cmserr.h b/include/openssl/cmserr.h
index 97704bfa52..1e7daf044b 100644
--- a/include/openssl/cmserr.h
+++ b/include/openssl/cmserr.h
@@ -131,6 +131,8 @@ int ERR_load_CMS_strings(void);
 #  define CMS_R_CERTIFICATE_ALREADY_PRESENT                175
 #  define CMS_R_CERTIFICATE_HAS_NO_KEYID                   160
 #  define CMS_R_CERTIFICATE_VERIFY_ERROR                   100
+#  define CMS_R_CIPHER_AEAD_SET_TAG_ERROR                  184
+#  define CMS_R_CIPHER_GET_TAG                             185
 #  define CMS_R_CIPHER_INITIALISATION_ERROR                101
 #  define CMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR      102
 #  define CMS_R_CMS_DATAFINAL_ERROR                        103
diff --git a/test/cmsapitest.c b/test/cmsapitest.c
index 697daa814d..f90200e9ac 100644
--- a/test/cmsapitest.c
+++ b/test/cmsapitest.c
@@ -21,7 +21,7 @@ DEFINE_STACK_OF(X509)
 static X509 *cert = NULL;
 static EVP_PKEY *privkey = NULL;
 
-static int test_encrypt_decrypt(void)
+static int test_encrypt_decrypt(const EVP_CIPHER *cipher)
 {
     int testresult = 0;
     STACK_OF(X509) *certstack = sk_X509_new_null();
@@ -37,7 +37,7 @@ static int test_encrypt_decrypt(void)
     if (!TEST_int_gt(sk_X509_push(certstack, cert), 0))
         goto end;
 
-    content = CMS_encrypt(certstack, msgbio, EVP_aes_128_cbc(), CMS_TEXT);
+    content = CMS_encrypt(certstack, msgbio, cipher, CMS_TEXT);
     if (!TEST_ptr(content))
         goto end;
 
@@ -60,6 +60,26 @@ static int test_encrypt_decrypt(void)
     return testresult;
 }
 
+static int test_encrypt_decrypt_aes_cbc(void)
+{
+    return test_encrypt_decrypt(EVP_aes_128_cbc());
+}
+
+static int test_encrypt_decrypt_aes_128_gcm(void)
+{
+    return test_encrypt_decrypt(EVP_aes_128_gcm());
+}
+
+static int test_encrypt_decrypt_aes_192_gcm(void)
+{
+    return test_encrypt_decrypt(EVP_aes_192_gcm());
+}
+
+static int test_encrypt_decrypt_aes_256_gcm(void)
+{
+    return test_encrypt_decrypt(EVP_aes_256_gcm());
+}
+
 OPT_TEST_DECLARE_USAGE(&quot;certfile privkeyfile\n&quot;)
 
 int setup_tests(void)
@@ -99,7 +119,10 @@ int setup_tests(void)
     }
     BIO_free(privkeybio);
 
-    ADD_TEST(test_encrypt_decrypt);
+    ADD_TEST(test_encrypt_decrypt_aes_cbc);
+    ADD_TEST(test_encrypt_decrypt_aes_128_gcm);
+    ADD_TEST(test_encrypt_decrypt_aes_192_gcm);
+    ADD_TEST(test_encrypt_decrypt_aes_256_gcm);
 
     return 1;
 }
diff --git a/test/drbgtest.c b/test/drbgtest.c
index eeb71f0227..d069460cd5 100644
--- a/test/drbgtest.c
+++ b/test/drbgtest.c
@@ -23,6 +23,7 @@
 #include &lt;openssl/aes.h&gt;
 #include &quot;../crypto/rand/rand_local.h&quot;
 #include &quot;../include/crypto/rand.h&quot;
+#include &quot;../include/crypto/evp.h&quot;
 #include &quot;../providers/implementations/rands/drbg_local.h&quot;
 #include &quot;../crypto/evp/evp_local.h&quot;
 
diff --git a/test/recipes/80-test_cms.t b/test/recipes/80-test_cms.t
index 1edddb2a82..65a8e14574 100644
--- a/test/recipes/80-test_cms.t
+++ b/test/recipes/80-test_cms.t
@@ -298,7 +298,7 @@ my @smime_cms_tests = (
       \&amp;final_compare
     ],
 
-    [ &quot;enveloped content test streaming PEM format, KEK&quot;,
+    [ &quot;enveloped content test streaming PEM format, AES-256-CBC cipher, KEK&quot;,
       [ &quot;{cmd1}&quot;, @prov, &quot;-encrypt&quot;, &quot;-in&quot;, $smcont, &quot;-outform&quot;, &quot;PEM&quot;, &quot;-aes128&quot;,
         &quot;-stream&quot;, &quot;-out&quot;, &quot;{output}.cms&quot;,
         &quot;-secretkey&quot;, &quot;000102030405060708090A0B0C0D0E0F&quot;,
@@ -310,6 +310,18 @@ my @smime_cms_tests = (
       \&amp;final_compare
     ],
 
+    [ &quot;enveloped content test streaming PEM format, AES-256-GCM cipher, KEK&quot;,
+      [ &quot;{cmd1}&quot;, @prov, &quot;-encrypt&quot;, &quot;-in&quot;, $smcont, &quot;-outform&quot;, &quot;PEM&quot;, &quot;-aes-128-gcm&quot;,
+        &quot;-stream&quot;, &quot;-out&quot;, &quot;{output}.cms&quot;,
+        &quot;-secretkey&quot;, &quot;000102030405060708090A0B0C0D0E0F&quot;,
+        &quot;-secretkeyid&quot;, &quot;C0FEE0&quot; ],
+      [ &quot;{cmd2}&quot;, &quot;-decrypt&quot;, &quot;-in&quot;, &quot;{output}.cms&quot;, &quot;-out&quot;, &quot;{output}.txt&quot;,
+        &quot;-inform&quot;, &quot;PEM&quot;,
+        &quot;-secretkey&quot;, &quot;000102030405060708090A0B0C0D0E0F&quot;,
+        &quot;-secretkeyid&quot;, &quot;C0FEE0&quot; ],
+      \&amp;final_compare
+    ],
+
     [ &quot;enveloped content test streaming PEM format, KEK, key only&quot;,
       [ &quot;{cmd1}&quot;, @prov, &quot;-encrypt&quot;, &quot;-in&quot;, $smcont, &quot;-outform&quot;, &quot;PEM&quot;, &quot;-aes128&quot;,
         &quot;-stream&quot;, &quot;-out&quot;, &quot;{output}.cms&quot;,
@@ -373,7 +385,6 @@ my @smime_cms_tests = (
         &quot;-out&quot;, &quot;{output}.txt&quot; ],
       \&amp;final_compare
     ],
-
 );
 
 my @smime_cms_cades_tests = (
@@ -560,7 +571,7 @@ my @smime_cms_param_tests = (
       \&amp;final_compare
     ],
 
-    [ &quot;enveloped content test streaming S/MIME format, ECDH, AES128, SHA256 KDF&quot;,
+    [ &quot;enveloped content test streaming S/MIME format, ECDH, AES-128-CBC, SHA256 KDF&quot;,
       [ &quot;{cmd1}&quot;, @prov, &quot;-encrypt&quot;, &quot;-in&quot;, $smcont,
         &quot;-stream&quot;, &quot;-out&quot;, &quot;{output}.cms&quot;,
         &quot;-recip&quot;, catfile($smdir, &quot;smec1.pem&quot;), &quot;-aes128&quot;,
@@ -570,6 +581,15 @@ my @smime_cms_param_tests = (
       \&amp;final_compare
     ],
 
+    [ &quot;enveloped content test streaming S/MIME format, ECDH, AES-128-GCM cipher, SHA256 KDF&quot;,
+      [ &quot;{cmd1}&quot;, @prov, &quot;-encrypt&quot;, &quot;-in&quot;, $smcont,
+        &quot;-stream&quot;, &quot;-out&quot;, &quot;{output}.cms&quot;,
+        &quot;-recip&quot;, catfile($smdir, &quot;smec1.pem&quot;), &quot;-aes-128-gcm&quot;, &quot;-keyopt&quot;, &quot;ecdh_kdf_md:sha256&quot; ],
+      [ &quot;{cmd2}&quot;, &quot;-decrypt&quot;, &quot;-recip&quot;, catfile($smdir, &quot;smec1.pem&quot;),
+	      &quot;-in&quot;, &quot;{output}.cms&quot;, &quot;-out&quot;, &quot;{output}.txt&quot; ],
+      \&amp;final_compare
+    ],
+
     [ &quot;enveloped content test streaming S/MIME format, ECDH, K-283, cofactor DH&quot;,
       [ &quot;{cmd1}&quot;, @prov, &quot;-encrypt&quot;, &quot;-in&quot;, $smcont,
         &quot;-stream&quot;, &quot;-out&quot;, &quot;{output}.cms&quot;,
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 4982a7f93c..777d8ce8a8 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -5299,3 +5299,5 @@ ossl_b2i_bio                            ?	3_0_0	EXIST::FUNCTION:DSA
 EVP_PKEY_CTX_set1_id                    ?	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_get1_id                    ?	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_get1_id_len                ?	3_0_0	EXIST::FUNCTION:
+CMS_AuthEnvelopedData_create            ?	3_0_0	EXIST::FUNCTION:CMS
+CMS_AuthEnvelopedData_create_with_libctx ?	3_0_0	EXIST::FUNCTION:CMS
</PRE>


























<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="030519.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="030521.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#30520">[ date ]</a>
              <a href="thread.html#30520">[ thread ]</a>
              <a href="subject.html#30520">[ subject ]</a>
              <a href="author.html#30520">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
