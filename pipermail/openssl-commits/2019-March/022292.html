<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-March/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1552333248.309728.21372.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022285.html">
   <LINK REL="Next"  HREF="022295.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1552333248.309728.21372.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Mon Mar 11 19:40:48 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="022285.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="022295.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22292">[ date ]</a>
              <a href="thread.html#22292">[ thread ]</a>
              <a href="subject.html#22292">[ subject ]</a>
              <a href="author.html#22292">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  c453283421299b7f8e0db6d6069c68369294a9f7 (commit)
       via  021a65527735af2ddc063d9300138660e3782a15 (commit)
       via  16c2f1bdb5f051ee2c0ac96182a0fb5bad7daa68 (commit)
       via  3374dc03edda56cbfd2a558fc62b7970eb0b9ad1 (commit)
       via  4c2883a9bf59c5ee31e8e2e101b3894a16c06950 (commit)
       via  3f4e8d6604842db4f416d029e9bbeddf90976c00 (commit)
      from  98f29466dc1ed7f80b9b8750309a41b5a1150d25 (commit)


- Log -----------------------------------------------------------------
commit c453283421299b7f8e0db6d6069c68369294a9f7
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Feb 21 21:20:53 2019 +0100

    Add documentation
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8287">https://github.com/openssl/openssl/pull/8287</A>)

commit 021a65527735af2ddc063d9300138660e3782a15
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Feb 20 22:55:43 2019 +0100

    Add provider tests
    
    Two tests are added, one that tests the internal API, the other tests
    the public API.  Those two tests both test the same provider, which
    acts both as a built-in provider and as a loadable provider module.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8287">https://github.com/openssl/openssl/pull/8287</A>)

commit 16c2f1bdb5f051ee2c0ac96182a0fb5bad7daa68
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Feb 20 22:55:29 2019 +0100

    Add provider module infrastructure
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8287">https://github.com/openssl/openssl/pull/8287</A>)

commit 3374dc03edda56cbfd2a558fc62b7970eb0b9ad1
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Feb 19 23:07:57 2019 +0100

    Replumbing: New public API to load or add providers
    
    Adding a provider means creating an internal provier object and adding
    it to the store.  This allows the addition of built in providers, be it
    in the OpenSSL libraries or in any application.
    
    &quot;Loading&quot; a provider is defined broadly.  A built in provider is already
    &quot;loaded&quot; in essence and only needs activating, while a provider in a
    dynamically loadable module requires actually loading the module itself.
    In this API, &quot;loading&quot; a provider does both.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8287">https://github.com/openssl/openssl/pull/8287</A>)

commit 4c2883a9bf59c5ee31e8e2e101b3894a16c06950
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sun Jan 20 13:14:58 2019 +0100

    Replumbing: Add the Provider Object, type OSSL_PROVIDER
    
    The OSSL_PROVIDER is the core object involved in loading a provider
    module, initialize a provider and do the initial communication of
    provider wide and core wide dispatch tables.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8287">https://github.com/openssl/openssl/pull/8287</A>)

commit 3f4e8d6604842db4f416d029e9bbeddf90976c00
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Feb 5 23:18:50 2019 +0100

    Replumbing: Add MODULESDIR macro and OPENSSL_MODULES environment variable
    
    These will be used to point out general OpenSSL modules directory.
    ENGINE modules are kept apart for backward compatibility.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8287">https://github.com/openssl/openssl/pull/8287</A>)

-----------------------------------------------------------------------

Summary of changes:
 Configurations/descrip.mms.tmpl          |   5 +-
 Configurations/unix-Makefile.tmpl        |   4 +-
 Configurations/windows-makefile.tmpl     |  26 +-
 crypto/build.info                        |   6 +-
 crypto/cpt_err.c                         |  12 +-
 crypto/err/openssl.txt                   |   5 +
 crypto/provider.c                        |  70 ++++++
 crypto/provider_core.c                   | 418 +++++++++++++++++++++++++++++++
 doc/internal/man3/ossl_provider_new.pod  | 196 +++++++++++++++
 doc/man3/OSSL_PROVIDER.pod               | 112 +++++++++
 include/internal/provider.h              |  61 +++++
 include/internal/symhacks.h              |  26 ++
 include/openssl/core.h                   |  20 ++
 include/openssl/core_numbers.h           |  76 ++++++
 include/openssl/cryptoerr.h              |   5 +
 include/openssl/ossl_typ.h               |   2 +
 include/openssl/provider.h               |  34 +++
 test/build.info                          |  23 ++
 test/p_test.c                            | 110 ++++++++
 test/provider_internal_test.c            |  79 ++++++
 test/provider_test.c                     |  69 +++++
 test/recipes/02-test_internal_provider.t |  18 ++
 test/recipes/04-test_provider.t          |  18 ++
 util/libcrypto.num                       |   5 +
 util/perl/OpenSSL/ParseC.pm              |   9 +
 util/private.num                         |   1 +
 util/providers.num                       |   1 +
 27 files changed, 1401 insertions(+), 10 deletions(-)
 create mode 100644 crypto/provider.c
 create mode 100644 crypto/provider_core.c
 create mode 100644 doc/internal/man3/ossl_provider_new.pod
 create mode 100644 doc/man3/OSSL_PROVIDER.pod
 create mode 100644 include/internal/provider.h
 create mode 100644 include/internal/symhacks.h
 create mode 100644 include/openssl/core_numbers.h
 create mode 100644 include/openssl/provider.h
 create mode 100644 test/p_test.c
 create mode 100644 test/provider_internal_test.c
 create mode 100644 test/provider_test.c
 create mode 100644 test/recipes/02-test_internal_provider.t
 create mode 100644 test/recipes/04-test_provider.t
 create mode 100644 util/providers.num

diff --git a/Configurations/descrip.mms.tmpl b/Configurations/descrip.mms.tmpl
index 8efdeb7..2f74756 100644
--- a/Configurations/descrip.mms.tmpl
+++ b/Configurations/descrip.mms.tmpl
@@ -167,6 +167,8 @@ OPENSSLDIR={- catdir($config{openssldir}) or
 OPENSSLDIR_C={- platform-&gt;osslprefix() -}DATAROOT:[000000]
 # Where installed ENGINE modules reside, for C
 ENGINESDIR_C={- platform-&gt;osslprefix() -}ENGINES{- $sover_dirname.$target{pointer_size} -}:
+# Where modules reside, for C
+MODULESDIR_C={- platform-&gt;osslprefix() -}MODULES{- $sover_dirname.$target{pointer_size} -}:
 
 ##### User defined commands and flags ################################
 
@@ -226,7 +228,8 @@ LIB_DEFINES={- our $lib_defines =
                                        @{$config{shared_defines}}));
                join('', $lib_defines,
                         (map { &quot;,$_&quot; } 'OPENSSLDIR=&quot;&quot;&quot;$(OPENSSLDIR_C)&quot;&quot;&quot;',
-                                       'ENGINESDIR=&quot;&quot;&quot;$(ENGINESDIR_C)&quot;&quot;&quot;'),
+                                       'ENGINESDIR=&quot;&quot;&quot;$(ENGINESDIR_C)&quot;&quot;&quot;',
+                                       'MODULESDIR=&quot;&quot;&quot;$(MODULESDIR_C)&quot;&quot;&quot;'),
                         '$(CNF_DEFINES)', '$(DEFINES)') -}
 LIB_INCLUDES={- our $lib_includes =
                 join(',', @{$target{lib_includes}},
diff --git a/Configurations/unix-Makefile.tmpl b/Configurations/unix-Makefile.tmpl
index dfae9af..2561c47 100644
--- a/Configurations/unix-Makefile.tmpl
+++ b/Configurations/unix-Makefile.tmpl
@@ -142,6 +142,7 @@ LIBDIR={- our $libdir = $config{libdir};
 libdir={- file_name_is_absolute($libdir)
           ? $libdir : '$(INSTALLTOP)/$(LIBDIR)' -}
 ENGINESDIR=$(libdir)/engines-{- $sover_dirname -}
+MODULESDIR=$(libdir)/ossl-modules
 
 # Convenience variable for those who want to set the rpath in shared
 # libraries and applications
@@ -238,7 +239,8 @@ LIB_CPPFLAGS={- our $lib_cppflags =
                 join(' ', $lib_cppflags,
                           (map { '-D'.$_ }
                                'OPENSSLDIR=&quot;\&quot;$(OPENSSLDIR)\&quot;&quot;',
-                               'ENGINESDIR=&quot;\&quot;$(ENGINESDIR)\&quot;&quot;'),
+                               'ENGINESDIR=&quot;\&quot;$(ENGINESDIR)\&quot;&quot;',
+                               'MODULESDIR=&quot;\&quot;$(MODULESDIR)\&quot;&quot;'),
                           '$(CNF_CPPFLAGS)', '$(CPPFLAGS)') -}
 LIB_CFLAGS={- join(' ', $target{lib_cflags} || (),
                         $target{shared_cflag} || (),
diff --git a/Configurations/windows-makefile.tmpl b/Configurations/windows-makefile.tmpl
index 6d38cfe..f327169 100644
--- a/Configurations/windows-makefile.tmpl
+++ b/Configurations/windows-makefile.tmpl
@@ -148,20 +148,33 @@ OPENSSLDIR_dev={- #
 OPENSSLDIR_dir={- canonpath($openssldir_dir) -}
 LIBDIR={- our $libdir = $config{libdir} || &quot;lib&quot;;
           file_name_is_absolute($libdir) ? &quot;&quot; : $libdir -}
-ENGINESDIR_dev={- use File::Spec::Functions qw(:DEFAULT splitpath);
-                  our $enginesdir = catdir($prefix,$libdir,&quot;engines-$sover_dirname&quot;);
-                  our ($enginesdir_dev, $enginesdir_dir, $enginesdir_file) =
-                      splitpath($enginesdir, 1);
-                  $enginesdir_dev -}
+MODULESDIR_dev={- use File::Spec::Functions qw(:DEFAULT splitpath);
+                  our $modulesprefix = catdir($prefix,$libdir);
+                  our ($modulesprefix_dev, $modulesprefix_dir,
+                       $modulesprefix_file) =
+                      splitpath($modulesprefix, 1);
+                  our $modulesdir_dev = $modulesprefix_dev;
+                  our $modulesdir_dir =
+                      catdir($modulesprefix_dir, &quot;ossl-modules&quot;);
+                  our $modulesdir = catpath($modulesdir_dev, $modulesdir_dir);
+                  our $enginesdir_dev = $modulesprefix_dev;
+                  out $enginesdir_dir =
+                      catdir($modulesprefix_dir, &quot;engines-$sover_dirname&quot;);
+                  our $enginesdir = catpath($enginesdir_dev, $enginesdir_dir);
+                  $modulesdir_dev -}
+MODULESDIR_dir={- canonpath($modulesdir_dir) -}
+ENGINESDIR_dev={- $enginesdir_dev -}
 ENGINESDIR_dir={- canonpath($enginesdir_dir) -}
 !IF &quot;$(DESTDIR)&quot; != &quot;&quot;
 INSTALLTOP=$(DESTDIR)$(INSTALLTOP_dir)
 OPENSSLDIR=$(DESTDIR)$(OPENSSLDIR_dir)
 ENGINESDIR=$(DESTDIR)$(ENGINESDIR_dir)
+MODULESDIR=$(DESTDIR)$(MODULESDIR_dir)
 !ELSE
 INSTALLTOP=$(INSTALLTOP_dev)$(INSTALLTOP_dir)
 OPENSSLDIR=$(OPENSSLDIR_dev)$(OPENSSLDIR_dir)
 ENGINESDIR=$(ENGINESDIR_dev)$(ENGINESDIR_dir)
+MODULESDIR=$(MODULESDIR_dev)$(MODULESDIR_dir)
 !ENDIF
 
 # $(libdir) is chosen to be compatible with the GNU coding standards
@@ -255,7 +268,8 @@ LIB_CPPFLAGS={- our $lib_cppflags =
                 join(' ', $lib_cppflags,
                           (map { '-D'.quotify1($_) }
                                &quot;OPENSSLDIR=\&quot;$openssldir\&quot;&quot;,
-                               &quot;ENGINESDIR=\&quot;$enginesdir\&quot;&quot;),
+                               &quot;ENGINESDIR=\&quot;$enginesdir\&quot;&quot;,
+                               &quot;MODULESDIR=\&quot;$modulesdir\&quot;&quot;),
                           '$(CNF_CPPFLAGS)', '$(CPPFLAGS)') -}
 LIB_CFLAGS={- join(' ', $target{lib_cflags} || (),
                         $target{shared_cflag} || (),
diff --git a/crypto/build.info b/crypto/build.info
index e3e9cee..0cca6ab 100644
--- a/crypto/build.info
+++ b/crypto/build.info
@@ -8,12 +8,16 @@ SUBDIRS=objects buffer bio stack lhash rand evp asn1 pem x509 x509v3 conf \
         err comp ocsp cms ts srp cmac ct async kmac ess
 
 LIBS=../libcrypto
+# The Core
+SOURCE[../libcrypto]=provider_core.c
+
+# Central utilities
 SOURCE[../libcrypto]=\
         cryptlib.c mem.c mem_dbg.c cversion.c ex_data.c cpt_err.c \
         ebcdic.c uid.c o_time.c o_str.c o_dir.c o_fopen.c ctype.c \
         threads_pthread.c threads_win.c threads_none.c getenv.c \
         o_init.c o_fips.c mem_sec.c init.c context.c sparse_array.c \
-        trace.c \
+        trace.c provider.c \
         {- $target{cpuid_asm_src} -} {- $target{uplink_aux_src} -}
 
 DEPEND[cversion.o]=buildinf.h
diff --git a/crypto/cpt_err.c b/crypto/cpt_err.c
index 8c11da8..bf7985c 100644
--- a/crypto/cpt_err.c
+++ b/crypto/cpt_err.c
@@ -1,6 +1,6 @@
 /*
  * Generated by util/mkerr.pl DO NOT EDIT
- * Copyright 1995-2018 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -32,6 +32,8 @@ static const ERR_STRING_DATA CRYPTO_str_functs[] = {
      &quot;CRYPTO_set_ex_data&quot;},
     {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_FIPS_MODE_SET, 0), &quot;FIPS_mode_set&quot;},
     {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_GET_AND_LOCK, 0), &quot;get_and_lock&quot;},
+    {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_GET_PROVIDER_STORE, 0),
+     &quot;get_provider_store&quot;},
     {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_OPENSSL_ATEXIT, 0), &quot;OPENSSL_atexit&quot;},
     {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_OPENSSL_BUF2HEXSTR, 0),
      &quot;OPENSSL_buf2hexstr&quot;},
@@ -44,6 +46,12 @@ static const ERR_STRING_DATA CRYPTO_str_functs[] = {
     {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_OPENSSL_SK_DEEP_COPY, 0),
      &quot;OPENSSL_sk_deep_copy&quot;},
     {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_OPENSSL_SK_DUP, 0), &quot;OPENSSL_sk_dup&quot;},
+    {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_OSSL_PROVIDER_ADD_BUILTIN, 0),
+     &quot;OSSL_PROVIDER_add_builtin&quot;},
+    {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_OSSL_PROVIDER_ACTIVATE, 0),
+     &quot;ossl_provider_activate&quot;},
+    {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_OSSL_PROVIDER_NEW, 0),
+     &quot;ossl_provider_new&quot;},
     {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_PKEY_HMAC_INIT, 0), &quot;pkey_hmac_init&quot;},
     {ERR_PACK(ERR_LIB_CRYPTO, CRYPTO_F_PKEY_POLY1305_INIT, 0),
      &quot;pkey_poly1305_init&quot;},
@@ -60,6 +68,8 @@ static const ERR_STRING_DATA CRYPTO_str_reasons[] = {
     &quot;illegal hex digit&quot;},
     {ERR_PACK(ERR_LIB_CRYPTO, 0, CRYPTO_R_ODD_NUMBER_OF_DIGITS),
     &quot;odd number of digits&quot;},
+    {ERR_PACK(ERR_LIB_CRYPTO, 0, CRYPTO_R_PROVIDER_ALREADY_EXISTS),
+    &quot;provider already exists&quot;},
     {0, NULL}
 };
 
diff --git a/crypto/err/openssl.txt b/crypto/err/openssl.txt
index aec6a8d..3b3f761 100644
--- a/crypto/err/openssl.txt
+++ b/crypto/err/openssl.txt
@@ -359,6 +359,7 @@ CRYPTO_F_CRYPTO_OCB128_INIT:122:CRYPTO_ocb128_init
 CRYPTO_F_CRYPTO_SET_EX_DATA:102:CRYPTO_set_ex_data
 CRYPTO_F_FIPS_MODE_SET:109:FIPS_mode_set
 CRYPTO_F_GET_AND_LOCK:113:get_and_lock
+CRYPTO_F_GET_PROVIDER_STORE:133:get_provider_store
 CRYPTO_F_OPENSSL_ATEXIT:114:OPENSSL_atexit
 CRYPTO_F_OPENSSL_BUF2HEXSTR:117:OPENSSL_buf2hexstr
 CRYPTO_F_OPENSSL_FOPEN:119:openssl_fopen
@@ -367,6 +368,9 @@ CRYPTO_F_OPENSSL_INIT_CRYPTO:116:OPENSSL_init_crypto
 CRYPTO_F_OPENSSL_LH_NEW:126:OPENSSL_LH_new
 CRYPTO_F_OPENSSL_SK_DEEP_COPY:127:OPENSSL_sk_deep_copy
 CRYPTO_F_OPENSSL_SK_DUP:128:OPENSSL_sk_dup
+CRYPTO_F_OSSL_PROVIDER_ADD_BUILTIN:132:OSSL_PROVIDER_add_builtin
+CRYPTO_F_OSSL_PROVIDER_ACTIVATE:130:ossl_provider_activate
+CRYPTO_F_OSSL_PROVIDER_NEW:131:ossl_provider_new
 CRYPTO_F_PKEY_HMAC_INIT:123:pkey_hmac_init
 CRYPTO_F_PKEY_POLY1305_INIT:124:pkey_poly1305_init
 CRYPTO_F_PKEY_SIPHASH_INIT:125:pkey_siphash_init
@@ -2097,6 +2101,7 @@ CONF_R_VARIABLE_HAS_NO_VALUE:104:variable has no value
 CRYPTO_R_FIPS_MODE_NOT_SUPPORTED:101:fips mode not supported
 CRYPTO_R_ILLEGAL_HEX_DIGIT:102:illegal hex digit
 CRYPTO_R_ODD_NUMBER_OF_DIGITS:103:odd number of digits
+CRYPTO_R_PROVIDER_ALREADY_EXISTS:104:provider already exists
 CT_R_BASE64_DECODE_ERROR:108:base64 decode error
 CT_R_INVALID_LOG_ID_LENGTH:100:invalid log id length
 CT_R_LOG_CONF_INVALID:109:log conf invalid
diff --git a/crypto/provider.c b/crypto/provider.c
new file mode 100644
index 0000000..823d5dd
--- /dev/null
+++ b/crypto/provider.c
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/err.h&gt;
+#include &lt;openssl/cryptoerr.h&gt;
+#include &lt;openssl/provider.h&gt;
+#include &quot;internal/provider.h&quot;
+
+OSSL_PROVIDER *OSSL_PROVIDER_load(OPENSSL_CTX *libctx, const char *name)
+{
+    OSSL_PROVIDER *prov = NULL;
+
+    /* Find it or create it */
+    if ((prov = ossl_provider_find(libctx, name)) == NULL
+        &amp;&amp; (prov = ossl_provider_new(libctx, name, NULL)) == NULL)
+        return NULL;
+
+    if (!ossl_provider_activate(prov)) {
+        ossl_provider_free(prov);
+        return NULL;
+    }
+
+    return prov;
+}
+
+int OSSL_PROVIDER_unload(OSSL_PROVIDER *prov)
+{
+    ossl_provider_free(prov);
+    return 1;
+}
+
+const OSSL_ITEM *OSSL_PROVIDER_get_param_types(OSSL_PROVIDER *prov)
+{
+    return ossl_provider_get_param_types(prov);
+}
+
+int OSSL_PROVIDER_get_params(OSSL_PROVIDER *prov, const OSSL_PARAM params[])
+{
+    return ossl_provider_get_params(prov, params);
+}
+
+int OSSL_PROVIDER_add_builtin(OPENSSL_CTX *libctx, const char *name,
+                              OSSL_provider_init_fn *init_fn)
+{
+    OSSL_PROVIDER *prov = NULL;
+
+    if (name == NULL || init_fn == NULL) {
+        CRYPTOerr(CRYPTO_F_OSSL_PROVIDER_ADD_BUILTIN,
+                  ERR_R_PASSED_NULL_PARAMETER);
+        return 0;
+    }
+
+    /* Create it */
+    if ((prov = ossl_provider_new(libctx, name, init_fn)) == NULL)
+        return 0;
+
+    /*
+     * It's safely stored in the internal store at this point,
+     * free the returned extra reference
+     */
+    ossl_provider_free(prov);
+
+    return 1;
+}
diff --git a/crypto/provider_core.c b/crypto/provider_core.c
new file mode 100644
index 0000000..b3d44f1
--- /dev/null
+++ b/crypto/provider_core.c
@@ -0,0 +1,418 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/core.h&gt;
+#include &lt;openssl/core_numbers.h&gt;
+#include &lt;openssl/opensslv.h&gt;
+#include &quot;internal/cryptlib.h&quot;
+#include &quot;internal/thread_once.h&quot;
+#include &quot;internal/provider.h&quot;
+#include &quot;internal/refcount.h&quot;
+
+/*-
+ * Provider Object structure
+ * =========================
+ */
+
+struct provider_store_st;        /* Forward declaration */
+
+struct ossl_provider_st {
+    /* Flag bits */
+    unsigned int flag_initialized:1;
+
+    /* OpenSSL library side data */
+    CRYPTO_REF_COUNT refcnt;
+#ifndef HAVE_ATOMICS
+    CRYPTO_RWLOCK refcnt_lock;   /* For the ref counter */
+#endif
+    char *name;
+    DSO *module;
+    OSSL_provider_init_fn *init_function;
+
+    /* Provider side functions */
+    OSSL_provider_teardown_fn *teardown;
+    OSSL_provider_get_param_types_fn *get_param_types;
+    OSSL_provider_get_params_fn *get_params;
+};
+DEFINE_STACK_OF(OSSL_PROVIDER)
+
+static int ossl_provider_cmp(const OSSL_PROVIDER * const *a,
+                             const OSSL_PROVIDER * const *b)
+{
+    return strcmp((*a)-&gt;name, (*b)-&gt;name);
+}
+
+/*-
+ * Provider Object store
+ * =====================
+ *
+ * The Provider Object store is a library context object, and therefore needs
+ * an index.
+ */
+
+struct provider_store_st {
+    STACK_OF(OSSL_PROVIDER) *providers;
+    CRYPTO_RWLOCK *lock;
+};
+static int provider_store_index = -1;
+
+static void provider_store_free(void *vstore)
+{
+    struct provider_store_st *store = vstore;
+
+    if (store == NULL)
+        return;
+    sk_OSSL_PROVIDER_pop_free(store-&gt;providers, ossl_provider_free);
+    CRYPTO_THREAD_lock_free(store-&gt;lock);
+    OPENSSL_free(store);
+}
+
+static void *provider_store_new(void)
+{
+    struct provider_store_st *store = OPENSSL_zalloc(sizeof(*store));
+
+    if (store == NULL
+        || (store-&gt;providers = sk_OSSL_PROVIDER_new(ossl_provider_cmp)) == NULL
+        || (store-&gt;lock = CRYPTO_THREAD_lock_new()) == NULL) {
+        provider_store_free(store);
+        store = NULL;
+    }
+    return store;
+}
+
+static const OPENSSL_CTX_METHOD provider_store_method = {
+    provider_store_new,
+    provider_store_free,
+};
+
+static CRYPTO_ONCE provider_store_init_flag = CRYPTO_ONCE_STATIC_INIT;
+DEFINE_RUN_ONCE_STATIC(do_provider_store_init)
+{
+    return OPENSSL_init_crypto(0, NULL)
+        &amp;&amp; (provider_store_index =
+            openssl_ctx_new_index(&amp;provider_store_method)) != -1;
+}
+
+
+static struct provider_store_st *get_provider_store(OPENSSL_CTX *libctx)
+{
+    struct provider_store_st *store = NULL;
+
+    if (!RUN_ONCE(&amp;provider_store_init_flag, do_provider_store_init))
+        return NULL;
+
+    store = openssl_ctx_get_data(libctx, provider_store_index);
+    if (store == NULL)
+        CRYPTOerr(CRYPTO_F_GET_PROVIDER_STORE, ERR_R_INTERNAL_ERROR);
+    return store;
+}
+
+/*-
+ * Provider Object methods
+ * =======================
+ */
+
+int ossl_provider_upref(OSSL_PROVIDER *prov)
+{
+    int ref = 0;
+
+#ifndef HAVE_ATOMICS
+    CRYPTO_UP_REF(&amp;prov-&gt;refcnt, &amp;ref, prov-&gt;refcnt_lock);
+#else
+    CRYPTO_UP_REF(&amp;prov-&gt;refcnt, &amp;ref, NULL);
+#endif
+    return ref;
+}
+
+/* Finder, constructor and destructor */
+OSSL_PROVIDER *ossl_provider_find(OPENSSL_CTX *libctx, const char *name)
+{
+    struct provider_store_st *store = NULL;
+    OSSL_PROVIDER *prov = NULL;
+
+    if ((store = get_provider_store(libctx)) != NULL) {
+        OSSL_PROVIDER tmpl = { 0, };
+        int i;
+
+        tmpl.name = (char *)name;
+        CRYPTO_THREAD_write_lock(store-&gt;lock);
+        if ((i = sk_OSSL_PROVIDER_find(store-&gt;providers, &amp;tmpl)) == -1
+            || (prov = sk_OSSL_PROVIDER_value(store-&gt;providers, i)) == NULL
+            || !ossl_provider_upref(prov))
+            prov = NULL;
+        CRYPTO_THREAD_unlock(store-&gt;lock);
+    }
+
+    return prov;
+}
+
+OSSL_PROVIDER *ossl_provider_new(OPENSSL_CTX *libctx, const char *name,
+                                 OSSL_provider_init_fn *init_function)
+{
+    struct provider_store_st *store = NULL;
+    OSSL_PROVIDER *prov = NULL;
+
+    if ((store = get_provider_store(libctx)) == NULL)
+        return NULL;
+
+    if ((prov = ossl_provider_find(libctx, name)) != NULL) { /* refcount +1 */
+        ossl_provider_free(prov); /* refcount -1 */
+        CRYPTOerr(CRYPTO_F_OSSL_PROVIDER_NEW,
+                  CRYPTO_R_PROVIDER_ALREADY_EXISTS);
+        ERR_add_error_data(2, &quot;name=&quot;, name);
+        return NULL;
+    }
+
+    if ((prov = OPENSSL_zalloc(sizeof(*prov))) == NULL
+        || !ossl_provider_upref(prov) /* +1 One reference to be returned */
+        || (prov-&gt;name = OPENSSL_strdup(name)) == NULL) {
+        ossl_provider_free(prov);
+        CRYPTOerr(CRYPTO_F_OSSL_PROVIDER_NEW, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+
+    prov-&gt;init_function = init_function;
+
+    CRYPTO_THREAD_write_lock(store-&gt;lock);
+    if (!ossl_provider_upref(prov)) { /* +1 One reference for the store */
+        ossl_provider_free(prov); /* -1 Reference that was to be returned */
+        prov = NULL;
+    } else if (sk_OSSL_PROVIDER_push(store-&gt;providers, prov) == 0) {
+        ossl_provider_free(prov); /* -1 Store reference */
+        ossl_provider_free(prov); /* -1 Reference that was to be returned */
+        prov = NULL;
+    }
+    CRYPTO_THREAD_unlock(store-&gt;lock);
+
+    if (prov == NULL)
+        CRYPTOerr(CRYPTO_F_OSSL_PROVIDER_NEW, ERR_R_MALLOC_FAILURE);
+
+    /*
+     * At this point, the provider is only partially &quot;loaded&quot;.  To be
+     * fully &quot;loaded&quot;, ossl_provider_activate() must also be called.
+     */
+
+    return prov;
+}
+
+void ossl_provider_free(OSSL_PROVIDER *prov)
+{
+    if (prov != NULL) {
+        int ref = 0;
+
+#ifndef HAVE_ATOMICS
+        CRYPTO_DOWN_REF(&amp;prov-&gt;refcnt, &amp;ref, provider_lock);
+#else
+        CRYPTO_DOWN_REF(&amp;prov-&gt;refcnt, &amp;ref, NULL);
+#endif
+
+        /*
+         * When the refcount drops down to one, there is only one reference,
+         * the store.
+         * When that happens, the provider is inactivated.
+         */
+        if (ref == 1 &amp;&amp; prov-&gt;flag_initialized) {
+            if (prov-&gt;teardown != NULL)
+                prov-&gt;teardown();
+            prov-&gt;flag_initialized = 0;
+        }
+
+        /*
+         * When the refcount drops to zero, it has been taken out of
+         * the store.  All we have to do here is clean it out.
+         */
+        if (ref == 0) {
+            DSO_free(prov-&gt;module);
+            OPENSSL_free(prov-&gt;name);
+            OPENSSL_free(prov);
+        }
+    }
+}
+
+/*
+ * Provider activation.
+ *
+ * What &quot;activation&quot; means depends on the provider form; for built in
+ * providers (in the library or the application alike), the provider
+ * can already be considered to be loaded, all that's needed is to
+ * initialize it.  However, for dynamically loadable provider modules,
+ * we must first load that module.
+ *
+ * Built in modules are distinguished from dynamically loaded modules
+ * with an already assigned init function.
+ */
+static const OSSL_DISPATCH *core_dispatch; /* Define further down */
+
+int ossl_provider_activate(OSSL_PROVIDER *prov)
+{
+    const OSSL_DISPATCH *provider_dispatch = NULL;
+
+    if (prov-&gt;flag_initialized)
+        return 1;
+
+    /*
+     * If the init function isn't set, it indicates that this provider is
+     * a loadable module.
+     */
+    if (prov-&gt;init_function == NULL) {
+        if (prov-&gt;module == NULL) {
+            char *platform_module_name = NULL;
+            char *module_path = NULL;
+            const char *load_dir = ossl_safe_getenv(&quot;OPENSSL_MODULES&quot;);
+
+            if ((prov-&gt;module = DSO_new()) == NULL) {
+                /* DSO_new() generates an error already */
+                return 0;
+            }
+
+            if (load_dir == NULL)
+                load_dir = MODULESDIR;
+
+            DSO_ctrl(prov-&gt;module, DSO_CTRL_SET_FLAGS,
+                     DSO_FLAG_NAME_TRANSLATION_EXT_ONLY, NULL);
+            if ((platform_module_name =
+                 DSO_convert_filename(prov-&gt;module, prov-&gt;name)) == NULL
+                || (module_path =
+                    DSO_merge(prov-&gt;module, platform_module_name,
+                              load_dir)) == NULL
+                || DSO_load(prov-&gt;module, module_path, NULL,
+                            DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == NULL) {
+                DSO_free(prov-&gt;module);
+                prov-&gt;module = NULL;
+            }
+
+            OPENSSL_free(platform_module_name);
+            OPENSSL_free(module_path);
+        }
+
+        if (prov-&gt;module != NULL)
+            prov-&gt;init_function = (OSSL_provider_init_fn *)
+                DSO_bind_func(prov-&gt;module, &quot;OSSL_provider_init&quot;);
+    }
+
+    if (prov-&gt;init_function == NULL
+        || !prov-&gt;init_function(prov, core_dispatch, &amp;provider_dispatch)) {
+        CRYPTOerr(CRYPTO_F_OSSL_PROVIDER_ACTIVATE, ERR_R_INIT_FAIL);
+        ERR_add_error_data(2, &quot;name=&quot;, prov-&gt;name);
+        DSO_free(prov-&gt;module);
+        prov-&gt;module = NULL;
+        return 0;
+    }
+
+    for (; provider_dispatch-&gt;function_id != 0; provider_dispatch++) {
+        switch (provider_dispatch-&gt;function_id) {
+        case OSSL_FUNC_PROVIDER_TEARDOWN:
+            prov-&gt;teardown =
+                OSSL_get_provider_teardown(provider_dispatch);
+            break;
+        case OSSL_FUNC_PROVIDER_GET_PARAM_TYPES:
+            prov-&gt;get_param_types =
+                OSSL_get_provider_get_param_types(provider_dispatch);
+            break;
+        case OSSL_FUNC_PROVIDER_GET_PARAMS:
+            prov-&gt;get_params =
+                OSSL_get_provider_get_params(provider_dispatch);
+            break;
+        }
+    }
+
+    /* With this flag set, this provider has become fully &quot;loaded&quot;. */
+    prov-&gt;flag_initialized = 1;
+
+    return 1;
+}
+
+/* Getters of Provider Object data */
+const char *ossl_provider_name(OSSL_PROVIDER *prov)
+{
+    return prov-&gt;name;
+}
+
+const DSO *ossl_provider_dso(OSSL_PROVIDER *prov)
+{
+    return prov-&gt;module;
+}
+
+const char *ossl_provider_module_name(OSSL_PROVIDER *prov)
+{
+    return DSO_get_filename(prov-&gt;module);
+}
+
+const char *ossl_provider_module_path(OSSL_PROVIDER *prov)
+{
+    /* FIXME: Ensure it's a full path */
+    return DSO_get_filename(prov-&gt;module);
+}
+
+/* Wrappers around calls to the provider */
+void ossl_provider_teardown(const OSSL_PROVIDER *prov)
+{
+    if (prov-&gt;teardown != NULL)
+        prov-&gt;teardown();
+}
+
+const OSSL_ITEM *ossl_provider_get_param_types(const OSSL_PROVIDER *prov)
+{
+    return prov-&gt;get_param_types == NULL ? NULL : prov-&gt;get_param_types(prov);
+}
+
+int ossl_provider_get_params(const OSSL_PROVIDER *prov,
+                             const OSSL_PARAM params[])
+{
+    return prov-&gt;get_params == NULL ? 0 : prov-&gt;get_params(prov, params);
+}
+
+/*-
+ * Core functions for the provider
+ * ===============================
+ *
+ * This is the set of functions that the core makes available to the provider
+ */
+
+/*
+ * This returns a list of Provider Object parameters with their types, for
+ * discovery.  We do not expect that many providers will use this, but one
+ * never knows.
+ */
+static const OSSL_ITEM param_types[] = {
+    { OSSL_PARAM_UTF8_STRING_PTR, &quot;openssl-version&quot; },
+    { OSSL_PARAM_UTF8_STRING_PTR, &quot;provider-name&quot; },
+    { 0, NULL }
+};
+
+static const OSSL_ITEM *core_get_param_types(const OSSL_PROVIDER *prov)
+{
+    return param_types;
+}
+
+static int core_get_params(const OSSL_PROVIDER *prov, const OSSL_PARAM params[])
+{
+    int i;
+
+    for (i = 0; params[i].key != NULL; i++) {
+        if (strcmp(params[i].key, &quot;openssl-version&quot;) == 0) {
+            *(void **)params[i].buffer = OPENSSL_VERSION_STR;
+            if (params[i].return_size)
+                *params[i].return_size = sizeof(OPENSSL_VERSION_STR);
+        } else if (strcmp(params[i].key, &quot;provider-name&quot;) == 0) {
+            *(void **)params[i].buffer = prov-&gt;name;
+            if (params[i].return_size)
+                *params[i].return_size = strlen(prov-&gt;name) + 1;
+        }
+    }
+
+    return 1;
+}
+
+static const OSSL_DISPATCH core_dispatch_[] = {
+    { OSSL_FUNC_CORE_GET_PARAM_TYPES, (void (*)(void))core_get_param_types },
+    { OSSL_FUNC_CORE_GET_PARAMS, (void (*)(void))core_get_params },
+    { 0, NULL }
+};
+static const OSSL_DISPATCH *core_dispatch = core_dispatch_;
diff --git a/doc/internal/man3/ossl_provider_new.pod b/doc/internal/man3/ossl_provider_new.pod
new file mode 100644
index 0000000..79964d6
--- /dev/null
+++ b/doc/internal/man3/ossl_provider_new.pod
@@ -0,0 +1,196 @@
+=pod
+
+=head1 NAME
+
+ossl_provider_find, ossl_provider_new, ossl_provider_upref,
+ossl_provider_free, ossl_provider_add_module_location,
+ossl_provider_activate, ossl_provider_name, ossl_provider_dso,
+ossl_provider_module_name, ossl_provider_module_path,
+ossl_provider_teardown, ossl_provider_get_param_types,
+ossl_provider_get_params - internal provider routines
+
+=head1 SYNOPSIS
+
+ #include &quot;internal/provider.h&quot;
+
+ OSSL_PROVIDER *ossl_provider_find(OPENSSL_CTX *libctx, const char *name);
+ OSSL_PROVIDER *ossl_provider_new(OPENSSL_CTX *libctx, const char *name,
+                                  ossl_provider_init_fn *init_function);
+ int ossl_provider_upref(OSSL_PROVIDER *prov);
+ void ossl_provider_free(OSSL_PROVIDER *prov);
+
+ /* Setters */
+ int ossl_provider_add_module_location(OSSL_PROVIDER *prov, const char *loc);
+
+ /* Load and initialize the Provider */
+ int ossl_provider_activate(OSSL_PROVIDER *prov);
+
+ /* Getters for other library functions */
+ const char *ossl_provider_name(OSSL_PROVIDER *prov);
+ const DSO *ossl_provider_dso(OSSL_PROVIDER *prov);
+ const char *ossl_provider_module_name(OSSL_PROVIDER *prov);
+ const char *ossl_provider_module_path(OSSL_PROVIDER *prov);
+
+ /* Thin wrappers around calls to the provider */
+ void ossl_provider_teardown(const OSSL_PROVIDER *prov);
+ const OSSL_ITEM *ossl_provider_get_param_types(const OSSL_PROVIDER *prov);
+ int ossl_provider_get_params(const OSSL_PROVIDER *prov,
+                              const OSSL_PARAM params[]);
+
+=head1 DESCRIPTION
+
+C&lt;OSSL_PROVIDER&gt; is a type that holds all the necessary information
+to handle a provider, regardless of if it's built in to the
+application or the OpenSSL libraries, or if it's a loadable provider
+module.
+Instances of this type are commonly refered to as I&lt;provider object&gt;s.
+
+A I&lt;provider object&gt; is always stored in a set of I&lt;provider object&gt;s
+in the library context.
+
+I&lt;provider object&gt;s are reference counted.
+
+I&lt;provider object&gt;s are initially inactive, i.e. they are only
+recorded in the store, but are not used.
+They are activated with the first call to ossl_provider_activate(),
+and are inactivated when ossl_provider_free() has been called as many
+times as ossl_provider_activate() has.
+
+=head2 Functions
+
+ossl_provider_find() finds an existing I&lt;provider object&gt; in the
+I&lt;provider object&gt; store by C&lt;name&gt;.
+The I&lt;provider object&gt; it finds gets it's reference count
+incremented.
+
+ossl_provider_new() creates a new I&lt;provider object&gt; and stores it in
+the I&lt;provider object&gt; store, unless there already is one there with
+the same name.
+The reference counter of a newly created I&lt;provider object&gt; will
+always be 2; one for being added to the store, and one for the
+returned reference.
+To indicate a built-in provider, the C&lt;init_function&gt; argument must
+point at the provider initialization function for that provider.
+
+ossl_provider_free() decrements a I&lt;provider object&gt;'s reference
+counter; if it drops to one, the I&lt;provider object&gt; will be
+inactivated (it's teardown function is called) but kept in the store;
+if it drops down to zero, the associated module will be unloaded if
+one was loaded, and the I&lt;provider object&gt; will be freed.
+
+ossl_provider_add_module_location() adds a location to look for a
+provider module.
+
+ossl_provider_activate() &quot;activates&quot; the provider for the given
+I&lt;provider object&gt;.
+What &quot;activates&quot; means depends on what type of I&lt;provider object&gt; it
+is:
+
+=over 4
+
+=item *
+
+If an initialization function was given with ossl_provider_new(), that
+function will get called.
+
+=item *
+
+If no intialization function was given with ossl_provider_new(), a
+loadable module with the C&lt;name&gt; that was given to ossl_provider_new()
+will be located and loaded, then the symbol C&lt;OSSL_provider_init&gt; will
+be located in that module, and called.
+
+=back
+
+ossl_provider_name() returns the name that was given with
+ossl_provider_new().
+
+ossl_provider_dso() returns a reference to the module, for providers
+that come in the form of loadable modules.
+
+ossl_provider_module_name() returns the file name of the module, for
+providers that come in the form of loadable modules.
+
+ossl_provider_module_path() returns the full path of the module file,
+for providers that come in the form of loadable modules.
+
+ossl_provider_teardown() calls the provider's C&lt;teardown&gt; function, if
+the provider has one.
+
+ossl_provider_get_param_types() calls the provider's C&lt;get_param_types&gt;
+function, if the provider has one.
+It should return an array of C&lt;OSSL_ITEM&gt; to describe all the
+parameters that the provider has for the I&lt;provider object&gt;.
+
+ossl_provider_get_params() calls the provider's parameter request
+responder.
+It should treat the given C&lt;OSSL_PARAM&gt; array as described in
+L&lt;OSSL_PARAM(3)&gt;.
+
+=head1 NOTES
+
+Locating a provider module happens as follows:
+
+=over 4
+
+=item 1.
+
+Look in each directory given by ossl_provider_add_module_location().
+
+=item 2.
+
+Look in the directory given by the environment variable
+B&lt;OPENSSL_MODULES&gt;.
+
+=item 3.
+
+Look in the directory given by the OpenSSL built in macro
+B&lt;MODULESDIR&gt;.
+
+=back
+
+=head1 RETURN VALUES
+
+ossl_provider_find() and ossl_provider_new() return a pointer to a
+I&lt;provider object&gt; (C&lt;OSSL_PROVIDER&gt;) on success, or B&lt;NULL&gt; on error.
+
+ossl_provider_upref() returns the value of the reference counter after
+it has been incremented.
+
+ossl_provider_free() doesn't return any value.
+
+ossl_provider_add_module_location() and ossl_provider_activate()
+return 1 on success, or 0 on error.
+
+ossl_provider_name(), ossl_provider_dso(),
+ossl_provider_module_name(), and ossl_provider_module_path() return a
+pointer to their respective data if it's available, otherwise B&lt;NULL&gt;
+is returned.
+
+ossl_provider_teardown() doesnt't return any value.
+
+ossl_provider_get_param_types() returns a pointer to an C&lt;OSSL_ITEM&gt;
+array if this function is available in the provider, otherwise
+B&lt;NULL&gt;.
+
+ossl_provider_get_params() returns 1 on success, or 0 on error.
+If this function isn't available in the provider, 0 is returned.
+
+=head1 SEE ALSO
+
+L&lt;OSSL_PROVIDER(3)&gt;, L&lt;provider(7)&gt;
+
+=head1 HISTORY
+
+The functions described here were all added in OpenSSL 3.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man3/OSSL_PROVIDER.pod b/doc/man3/OSSL_PROVIDER.pod
new file mode 100644
index 0000000..e365366
--- /dev/null
+++ b/doc/man3/OSSL_PROVIDER.pod
@@ -0,0 +1,112 @@
+=pod
+
+=head1 NAME
+
+OSSL_PROVIDER, OSSL_PROVIDER_load, OSSL_PROVIDER_unload,
+OSSL_PROVIDER_get_param_types, OSSL_PROVIDER_get_params,
+OSSL_PROVIDER_add_builtin - provider routines
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/provider.h&gt;
+
+ typedef struct ossl_provider_st OSSL_PROVIDER;
+
+ OSSL_PROVIDER *OSSL_PROVIDER_load(OPENSSL_CTX *, const char *name);
+ int OSSL_PROVIDER_unload(OSSL_PROVIDER *prov);
+
+ const OSSL_ITEM *OSSL_PROVIDER_get_param_types(OSSL_PROVIDER *prov);
+ int OSSL_PROVIDER_get_params(OSSL_PROVIDER *prov, const OSSL_PARAM params[]);
+
+ int OSSL_PROVIDER_add_builtin(OPENSSL_CTX *, const char *name,
+                               ossl_provider_init_fn *init_fn);
+
+=head1 DESCRIPTION
+
+B&lt;OSSL_PROVIDER&gt; is a type that holds internal information about
+implementation providers (see L&lt;provider(7)&gt; for information on what a
+provider is).
+A provider can be built in to the application or the OpenSSL
+libraries, or can be a loadable module.
+The functions described here handle both forms.
+
+=head2 Functions
+
+OSSL_PROVIDER_add_builtin() is used to add a built in provider to
+B&lt;OSSL_PROVIDER&gt; store in the given library context, by associating a
+provider name with a provider initialization function.
+This name can then be used with OSSL_PROVIDER_load().
+
+OSSL_PROVIDER_load() loads and initializes a provider.
+This may simply initialize a provider that was previously added with
+OSSL_PROVIDER_add_builtin() and run its given initialization function,
+or load a provider module with the given name and run its provider
+entry point, C&lt;OSSL_provider_init&gt;.
+
+OSSL_PROVIDER_unload() unloads the given provider.
+For a provider added with OSSL_PROVIDER_add_builtin(), this simply
+runs its teardown function.
+
+OSSL_PROVIDER_get_param_types() is used to get a provider parameter
+descriptor set as an B&lt;OSSL_ITEM&gt; array.
+Each element is a tuple of an B&lt;OSSL_PARAM&gt; parameter type and a name
+in form of a C string.
+See L&lt;openssl-core.h(7)&gt; for more information on B&lt;OSSL_ITEM&gt; and
+parameter types.
+
+OSSL_PROVIDER_get_params() is used to get provider parameter values.
+The caller must prepare the B&lt;OSSL_PARAM&gt; array before calling this
+function, and the variables acting as buffers for this parameter array
+should be filled with data when it returns successfully.
+
+=head1 RETURN VALUES
+
+OSSL_PROVIDER_add() returns 1 on success, or 0 on error.
+
+OSSL_PROVIDER_load() returns a pointer to a provider object on
+success, or B&lt;NULL&gt; on error.
+
+OSSL_PROVIDER_unload() returns 1 on success, or 0 on error.
+
+OSSL_PROVIDER_get_param_types() returns a pointer to a constant array
+of B&lt;OSSL_ITEM&gt;, or NULL if none is provided.
+
+OSSL_PROVIDER_get_params() returns 1 on success, or 0 on error.
+
+=head1 EXAMPLES
+
+This demonstrates how to load the provider module &quot;foo&quot; and ask for
+its build number.
+
+ OSSL_PROVIDER *prov = NULL;
+ const char *build = NULL;
+ size_t built_l = 0;
+ const OSSL_PARAM request[] = {
+     { &quot;build&quot;, OSSL_PARAM_UTF8_STRING_PTR, &amp;build, 0, &amp;build_l },
+     { NULL, 0, NULL, 0, NULL }
+ };
+
+ if ((prov = OSSL_PROVIDER_load(NULL, &quot;foo&quot;)) != NULL
+     &amp;&amp; OSSL_PROVIDER_get_params(prov, request))
+     printf(&quot;Provider 'foo' build %s\n&quot;, build);
+ else
+     ERR_print_errors_fp(stderr);
+
+=head1 SEE ALSO
+
+L&lt;openssl-core.h(7)&gt;, L&lt;provider(7)&gt;
+
+=head1 HISTORY
+
+The type and functions described here were added in OpenSSL 3.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/include/internal/provider.h b/include/internal/provider.h
new file mode 100644
index 0000000..44d1d70
--- /dev/null
+++ b/include/internal/provider.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef OSSL_INTERNAL_PROVIDER_H
+# define OSSL_INTERNAL_PROVIDER_H
+
+# include &lt;openssl/core.h&gt;
+# include &quot;internal/dso.h&quot;
+# include &quot;internal/symhacks.h&quot;
+
+# ifdef __cplusplus
+extern &quot;C&quot; {
+# endif
+
+/*
+ * namespaces:
+ *
+ * ossl_provider_       Provider Object internal API
+ * OSSL_PROVIDER        Provider Object
+ */
+
+/* Provider Object finder, constructor and destructor */
+OSSL_PROVIDER *ossl_provider_find(OPENSSL_CTX *libctx, const char *name);
+OSSL_PROVIDER *ossl_provider_new(OPENSSL_CTX *libctx, const char *name,
+                                 OSSL_provider_init_fn *init_function);
+int ossl_provider_upref(OSSL_PROVIDER *prov);
+void ossl_provider_free(OSSL_PROVIDER *prov);
+
+/* Setters */
+int ossl_provider_add_module_location(OSSL_PROVIDER *prov, const char *loc);
+
+/*
+ * Activate the Provider
+ * If the Provider is a module, the module will be loaded
+ * Inactivation is done by freeing the Provider
+ */
+int ossl_provider_activate(OSSL_PROVIDER *prov);
+
+/* Getters for other library functions */
+const char *ossl_provider_name(OSSL_PROVIDER *prov);
+const DSO *ossl_provider_dso(OSSL_PROVIDER *prov);
+const char *ossl_provider_module_name(OSSL_PROVIDER *prov);
+const char *ossl_provider_module_path(OSSL_PROVIDER *prov);
+
+/* Thin wrappers around calls to the provider */
+void ossl_provider_teardown(const OSSL_PROVIDER *prov);
+const OSSL_ITEM *ossl_provider_get_param_types(const OSSL_PROVIDER *prov);
+int ossl_provider_get_params(const OSSL_PROVIDER *prov,
+                             const OSSL_PARAM params[]);
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif
diff --git a/include/internal/symhacks.h b/include/internal/symhacks.h
new file mode 100644
index 0000000..2b09604
--- /dev/null
+++ b/include/internal/symhacks.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef OSSL_INTERNAL_SYMHACKS_H
+# define OSSL_INTERNAL_SYMHACKS_H
+
+# include &lt;openssl/e_os2.h&gt;
+
+# if defined(OPENSSL_SYS_VMS)
+
+/* ossl_provider_get_param_types vs OSSL_PROVIDER_get_param_types */
+#  undef ossl_provider_get_param_types
+#  define ossl_provider_get_param_types           ossl_int_prov_get_param_types
+/* ossl_provider_get_params vs OSSL_PROVIDER_get_params */
+#  undef ossl_provider_get_params
+#  define ossl_provider_get_params                ossl_int_prov_get_params
+
+# endif
+
+#endif                          /* ! defined HEADER_VMS_IDHACKS_H */
diff --git a/include/openssl/core.h b/include/openssl/core.h
index 98b58be..15e8843 100644
--- a/include/openssl/core.h
+++ b/include/openssl/core.h
@@ -136,6 +136,26 @@ struct ossl_param_st {
 # define OSSL_PARAM_OCTET_STRING_PTR                    \
     (OSSL_PARAM_OCTET_STRING|OSSL_PARAM_POINTER_FLAG)
 
+/*-
+ * Provider entry point
+ * --------------------
+ *
+ * This function is expected to be present in any dynamically loadable
+ * provider module.  By definition, if this function doesn't exist in a
+ * module, that module is not an OpenSSL provider module.
+ */
+/*-
+ * |provider|   pointer to opaque type OSSL_PROVIDER.  This can be used
+ *              together with some functions passed via |in| to query data.
+ * |in|         is the array of functions that the Core passes to the provider.
+ * |out|        will be the array of base functions that the provider passes
+ *              back to the Core.
+ */
+typedef int (OSSL_provider_init_fn)(const OSSL_PROVIDER *provider,
+                                    const OSSL_DISPATCH *in,
+                                    const OSSL_DISPATCH **out);
+extern OSSL_provider_init_fn OSSL_provider_init;
+
 # ifdef __cplusplus
 }
 # endif
diff --git a/include/openssl/core_numbers.h b/include/openssl/core_numbers.h
new file mode 100644
index 0000000..cd10938
--- /dev/null
+++ b/include/openssl/core_numbers.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef OSSL_CORE_NUMBERS_H
+# define OSSL_CORE_NUMBERS_H
+
+# include &lt;openssl/core.h&gt;
+
+# ifdef __cplusplus
+extern &quot;C&quot; {
+# endif
+
+/*-
+ * Identities
+ * ----------
+ *
+ * All series start with 1, to allow 0 to be an array terminator.
+ * For any FUNC identity, we also provide a function signature typedef
+ * and a static inline function to extract a function pointer from a
+ * OSSL_DISPATCH element in a type safe manner.
+ *
+ * Names:
+ * for any function base name 'foo' (uppercase form 'FOO'), we will have
+ * the following:
+ * - a macro for the identity with the name OSSL_FUNC_'FOO' or derivates
+ *   thereof (to be specified further down)
+ * - a function signature typedef with the name OSSL_'foo'_fn
+ * - a function pointer extractor function with the name OSSL_'foo'
+ */
+
+/* Helper macro to create the function signature typedef and the extractor */
+#define OSSL_CORE_MAKE_FUNC(type,name,args)                             \
+    typedef type (OSSL_##name##_fn)args;                                \
+    static ossl_inline \
+    OSSL_##name##_fn *OSSL_get_##name(const OSSL_DISPATCH *opf)         \
+    {                                                                   \
+        return (OSSL_##name##_fn *)opf-&gt;function;                       \
+    }
+
+/*
+ * Core function identities, for the two OSSL_DISPATCH tables being passed
+ * in the OSSL_provider_init call.
+ *
+ * 0 serves as a marker for the end of the OSSL_DISPATCH array, and must
+ * therefore NEVER be used as a function identity.
+ */
+/* Functions provided by the Core to the provider, reserved numbers 1-1023 */
+# define OSSL_FUNC_CORE_GET_PARAM_TYPES        1
+OSSL_CORE_MAKE_FUNC(const OSSL_ITEM *,
+                    core_get_param_types,(const OSSL_PROVIDER *prov))
+# define OSSL_FUNC_CORE_GET_PARAMS             2
+OSSL_CORE_MAKE_FUNC(int,core_get_params,(const OSSL_PROVIDER *prov,
+                                         const OSSL_PARAM params[]))
+
+/* Functions provided by the provider to the Core, reserved numbers 1024-1535 */
+# define OSSL_FUNC_PROVIDER_TEARDOWN         1024
+OSSL_CORE_MAKE_FUNC(void,provider_teardown,(void))
+# define OSSL_FUNC_PROVIDER_GET_PARAM_TYPES  1025
+OSSL_CORE_MAKE_FUNC(const OSSL_ITEM *,
+                    provider_get_param_types,(const OSSL_PROVIDER *prov))
+# define OSSL_FUNC_PROVIDER_GET_PARAMS       1026
+OSSL_CORE_MAKE_FUNC(int,provider_get_params,(const OSSL_PROVIDER *prov,
+                                             const OSSL_PARAM params[]))
+
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif
diff --git a/include/openssl/cryptoerr.h b/include/openssl/cryptoerr.h
index f07d07e..c27f05c 100644
--- a/include/openssl/cryptoerr.h
+++ b/include/openssl/cryptoerr.h
@@ -34,6 +34,7 @@ int ERR_load_CRYPTO_strings(void);
 # define CRYPTO_F_CRYPTO_SET_EX_DATA                      102
 # define CRYPTO_F_FIPS_MODE_SET                           109
 # define CRYPTO_F_GET_AND_LOCK                            113
+# define CRYPTO_F_GET_PROVIDER_STORE                      133
 # define CRYPTO_F_OPENSSL_ATEXIT                          114
 # define CRYPTO_F_OPENSSL_BUF2HEXSTR                      117
 # define CRYPTO_F_OPENSSL_FOPEN                           119
@@ -42,6 +43,9 @@ int ERR_load_CRYPTO_strings(void);
 # define CRYPTO_F_OPENSSL_LH_NEW                          126
 # define CRYPTO_F_OPENSSL_SK_DEEP_COPY                    127
 # define CRYPTO_F_OPENSSL_SK_DUP                          128
+# define CRYPTO_F_OSSL_PROVIDER_ADD_BUILTIN               132
+# define CRYPTO_F_OSSL_PROVIDER_ACTIVATE                  130
+# define CRYPTO_F_OSSL_PROVIDER_NEW                       131
 # define CRYPTO_F_PKEY_HMAC_INIT                          123
 # define CRYPTO_F_PKEY_POLY1305_INIT                      124
 # define CRYPTO_F_PKEY_SIPHASH_INIT                       125
@@ -53,5 +57,6 @@ int ERR_load_CRYPTO_strings(void);
 # define CRYPTO_R_FIPS_MODE_NOT_SUPPORTED                 101
 # define CRYPTO_R_ILLEGAL_HEX_DIGIT                       102
 # define CRYPTO_R_ODD_NUMBER_OF_DIGITS                    103
+# define CRYPTO_R_PROVIDER_ALREADY_EXISTS                 104
 
 #endif
diff --git a/include/openssl/ossl_typ.h b/include/openssl/ossl_typ.h
index 9b97e3d..07e5f02 100644
--- a/include/openssl/ossl_typ.h
+++ b/include/openssl/ossl_typ.h
@@ -18,6 +18,8 @@ extern &quot;C&quot; {
 
 # include &lt;openssl/e_os2.h&gt;
 
+typedef struct ossl_provider_st OSSL_PROVIDER; /* Provider Object */
+
 # ifdef NO_ASN1_TYPEDEFS
 #  define ASN1_INTEGER            ASN1_STRING
 #  define ASN1_ENUMERATED         ASN1_STRING
diff --git a/include/openssl/provider.h b/include/openssl/provider.h
new file mode 100644
index 0000000..7dc5b8a
--- /dev/null
+++ b/include/openssl/provider.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef OSSL_PROVIDER_H
+# define OSSL_PROVIDER_H
+
+# include &lt;openssl/core.h&gt;
+
+# ifdef __cplusplus
+extern &quot;C&quot; {
+# endif
+
+/* Load and unload a provider */
+OSSL_PROVIDER *OSSL_PROVIDER_load(OPENSSL_CTX *, const char *name);
+int OSSL_PROVIDER_unload(OSSL_PROVIDER *prov);
+
+const OSSL_ITEM *OSSL_PROVIDER_get_param_types(OSSL_PROVIDER *prov);
+int OSSL_PROVIDER_get_params(OSSL_PROVIDER *prov, const OSSL_PARAM params[]);
+
+/* Add a built in providers */
+int OSSL_PROVIDER_add_builtin(OPENSSL_CTX *, const char *name,
+                              OSSL_provider_init_fn *init_fn);
+
+# ifdef __cplusplus
+}
+# endif
+
+#endif
diff --git a/test/build.info b/test/build.info
index 4dd400f..f7ec8a2 100644
--- a/test/build.info
+++ b/test/build.info
@@ -578,6 +578,29 @@ IF[{- !$disabled{tests} -}]
   SOURCE[context_internal_test]=context_internal_test.c
   INCLUDE[context_internal_test]=.. ../include ../apps/include
   DEPEND[context_internal_test]=../libcrypto.a libtestutil.a
+
+  PROGRAMS{noinst}=provider_internal_test
+  DEFINE[provider_internal_test]=PROVIDER_INIT_FUNCTION_NAME=p_test_init
+  SOURCE[provider_internal_test]=provider_internal_test.c p_test.c
+  INCLUDE[provider_internal_test]=../include ../apps/include
+  DEPEND[provider_internal_test]=../libcrypto.a libtestutil.a
+  PROGRAMS{noinst}=provider_test
+  DEFINE[provider_test]=PROVIDER_INIT_FUNCTION_NAME=p_test_init
+  SOURCE[provider_test]=provider_test.c p_test.c
+  INCLUDE[provider_test]=../include ../apps/include
+  DEPEND[provider_test]=../libcrypto.a libtestutil.a
+  IF[{- !$disabled{shared} -}]
+    MODULES{noinst}=p_test
+    SOURCE[p_test]=p_test.c
+    INCLUDE[p_test]=../include
+    IF[{- defined $target{shared_defflag} -}]
+      SOURCE[p_test]=p_test.ld
+      GENERATE[p_test.ld]=../util/providers.num
+    ENDIF
+  ELSE
+    DEFINE[provider_test]=OPENSSL_NO_SHARED
+    DEFINE[provider_internal_test]=OPENSSL_NO_SHARED
+  ENDIF
 ENDIF
 
 {-
diff --git a/test/p_test.c b/test/p_test.c
new file mode 100644
index 0000000..6dc0410
--- /dev/null
+++ b/test/p_test.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+/*
+ * This is a very simple provider that does absolutely nothing except respond
+ * to provider global parameter requests.  It does this by simply echoing back
+ * a parameter request it makes to the loading library.
+ */
+
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+
+/*
+ * When built as an object file to link the application with, we get the
+ * init function name through the macro PROVIDER_INIT_FUNCTION_NAME.  If
+ * not defined, we use the standard init function name for the shared
+ * object form.
+ */
+#ifdef PROVIDER_INIT_FUNCTION_NAME
+# define OSSL_provider_init PROVIDER_INIT_FUNCTION_NAME
+#endif
+
+#include &lt;openssl/core.h&gt;
+#include &lt;openssl/core_numbers.h&gt;
+
+static OSSL_core_get_param_types_fn *c_get_param_types = NULL;
+static OSSL_core_get_params_fn *c_get_params = NULL;
+
+/* Tell the core what params we provide and what type they are */
+static const OSSL_ITEM p_param_types[] = {
+    { OSSL_PARAM_UTF8_STRING, &quot;greeting&quot; },
+    { 0, NULL }
+};
+
+static const OSSL_ITEM *p_get_param_types(const OSSL_PROVIDER *_)
+{
+    return p_param_types;
+}
+
+static int p_get_params(const OSSL_PROVIDER *prov, OSSL_PARAM params[])
+{
+    const OSSL_PARAM *p = params;
+    int ok = 1;
+
+    for (; ok &amp;&amp; p-&gt;key != NULL; p++) {
+        if (strcmp(p-&gt;key, &quot;greeting&quot;) == 0) {
+            static char *opensslv = NULL;
+            static char *provname = NULL;
+            static OSSL_PARAM counter_request[] = {
+                { &quot;openssl-version&quot;, OSSL_PARAM_UTF8_STRING_PTR,
+                  &amp;opensslv, sizeof(&amp;opensslv), NULL },
+                { &quot;provider-name&quot;, OSSL_PARAM_UTF8_STRING_PTR,
+                  &amp;provname, sizeof(&amp;provname), NULL},
+                { NULL, 0, NULL, 0, NULL }
+            };
+            char buf[256];
+            size_t buf_l;
+
+            if (c_get_params(prov, counter_request)) {
+                const char *versionp = *(void **)counter_request[0].buffer;
+                const char *namep = *(void **)counter_request[1].buffer;
+                sprintf(buf, &quot;Hello OpenSSL %.20s, greetings from %s!&quot;,
+                        versionp, namep);
+            } else {
+                sprintf(buf, &quot;Howdy stranger...&quot;);
+            }
+
+            *p-&gt;return_size = buf_l = strlen(buf) + 1;
+            if (p-&gt;buffer_size &gt;= buf_l)
+                strncpy(p-&gt;buffer, buf, buf_l);
+            else
+                ok = 0;
+        }
+    }
+    return ok;
+}
+
+static const OSSL_DISPATCH p_test_table[] = {
+    { OSSL_FUNC_PROVIDER_GET_PARAM_TYPES, (void (*)(void))p_get_param_types },
+    { OSSL_FUNC_PROVIDER_GET_PARAMS, (void (*)(void))p_get_params },
+    { 0, NULL }
+};
+
+int OSSL_provider_init(const OSSL_PROVIDER *provider,
+                       const OSSL_DISPATCH *in,
+                       const OSSL_DISPATCH **out)
+{
+    for (; in-&gt;function_id != 0; in++) {
+        switch (in-&gt;function_id) {
+        case OSSL_FUNC_CORE_GET_PARAM_TYPES:
+            c_get_param_types = OSSL_get_core_get_param_types(in);
+            break;
+        case OSSL_FUNC_CORE_GET_PARAMS:
+            c_get_params = OSSL_get_core_get_params(in);
+            break;
+        default:
+            /* Just ignore anything we don't understand */
+            break;
+        }
+    }
+
+    *out = p_test_table;
+    return 1;
+}
diff --git a/test/provider_internal_test.c b/test/provider_internal_test.c
new file mode 100644
index 0000000..c423808
--- /dev/null
+++ b/test/provider_internal_test.c
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;stddef.h&gt;
+#include &quot;internal/provider.h&quot;
+#include &quot;testutil.h&quot;
+
+extern OSSL_provider_init_fn PROVIDER_INIT_FUNCTION_NAME;
+
+static char buf[256];
+static size_t buf_l = 0;
+static OSSL_PARAM greeting_request[] = {
+    { &quot;greeting&quot;, OSSL_PARAM_UTF8_STRING, buf, sizeof(buf), &amp;buf_l },
+    { NULL, 0, NULL, 0, NULL }
+};
+
+static int test_provider(OSSL_PROVIDER *prov)
+{
+    const char *name = NULL;
+    const char *greeting = NULL;
+    char expected_greeting[256];
+    int ret = 0;
+
+    if (!TEST_ptr(name = ossl_provider_name(prov)))
+        return 0;
+
+    snprintf(expected_greeting, sizeof(expected_greeting),
+             &quot;Hello OpenSSL %.20s, greetings from %s!&quot;,
+             OPENSSL_VERSION_STR, name);
+
+    ret =
+        TEST_true(ossl_provider_activate(prov))
+        &amp;&amp; TEST_true(ossl_provider_get_params(prov, greeting_request))
+        &amp;&amp; TEST_ptr(greeting = greeting_request[0].buffer)
+        &amp;&amp; TEST_size_t_gt(greeting_request[0].buffer_size, 0)
+        &amp;&amp; TEST_str_eq(greeting, expected_greeting);
+
+    ossl_provider_free(prov);
+    return ret;
+}
+
+static int test_builtin_provider(void)
+{
+    const char *name = &quot;p_test_builtin&quot;;
+    OSSL_PROVIDER *prov = NULL;
+
+    return
+        TEST_ptr(prov =
+                 ossl_provider_new(NULL, name, PROVIDER_INIT_FUNCTION_NAME))
+        &amp;&amp; test_provider(prov);
+}
+
+#ifndef OPENSSL_NO_SHARED
+static int test_loaded_provider(void)
+{
+    const char *name = &quot;p_test&quot;;
+    OSSL_PROVIDER *prov = NULL;
+
+    return
+        TEST_ptr(prov = ossl_provider_new(NULL, name, NULL))
+        &amp;&amp; test_provider(prov);
+}
+#endif
+
+int setup_tests(void)
+{
+    ADD_TEST(test_builtin_provider);
+#ifndef OPENSSL_NO_SHARED
+    ADD_TEST(test_loaded_provider);
+#endif
+    return 1;
+}
+
diff --git a/test/provider_test.c b/test/provider_test.c
new file mode 100644
index 0000000..738cd7b
--- /dev/null
+++ b/test/provider_test.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;stddef.h&gt;
+#include &lt;openssl/provider.h&gt;
+#include &quot;testutil.h&quot;
+
+extern OSSL_provider_init_fn PROVIDER_INIT_FUNCTION_NAME;
+
+static char buf[256];
+static size_t buf_l = 0;
+static OSSL_PARAM greeting_request[] = {
+    { &quot;greeting&quot;, OSSL_PARAM_UTF8_STRING, buf, sizeof(buf), &amp;buf_l },
+    { NULL, 0, NULL, 0, NULL }
+};
+
+static int test_provider(const char *name)
+{
+    OSSL_PROVIDER *prov = NULL;
+    const char *greeting = NULL;
+    char expected_greeting[256];
+
+    snprintf(expected_greeting, sizeof(expected_greeting),
+             &quot;Hello OpenSSL %.20s, greetings from %s!&quot;,
+             OPENSSL_VERSION_STR, name);
+
+    return
+        TEST_ptr(prov = OSSL_PROVIDER_load(NULL, name))
+        &amp;&amp; TEST_true(OSSL_PROVIDER_get_params(prov, greeting_request))
+        &amp;&amp; TEST_ptr(greeting = greeting_request[0].buffer)
+        &amp;&amp; TEST_size_t_gt(greeting_request[0].buffer_size, 0)
+        &amp;&amp; TEST_str_eq(greeting, expected_greeting)
+        &amp;&amp; TEST_true(OSSL_PROVIDER_unload(prov));
+}
+
+static int test_builtin_provider(void)
+{
+    const char *name = &quot;p_test_builtin&quot;;
+
+    return
+        TEST_true(OSSL_PROVIDER_add_builtin(NULL, name,
+					    PROVIDER_INIT_FUNCTION_NAME))
+        &amp;&amp; test_provider(name);
+}
+
+#ifndef OPENSSL_NO_SHARED
+static int test_loaded_provider(void)
+{
+    const char *name = &quot;p_test&quot;;
+
+    return test_provider(name);
+}
+#endif
+
+int setup_tests(void)
+{
+    ADD_TEST(test_builtin_provider);
+#ifndef OPENSSL_NO_SHARED
+    ADD_TEST(test_loaded_provider);
+#endif
+    return 1;
+}
+
diff --git a/test/recipes/02-test_internal_provider.t b/test/recipes/02-test_internal_provider.t
new file mode 100644
index 0000000..8275eb2
--- /dev/null
+++ b/test/recipes/02-test_internal_provider.t
@@ -0,0 +1,18 @@
+#! /usr/bin/env perl
+# Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+use strict;
+use OpenSSL::Test qw(:DEFAULT bldtop_dir);
+use OpenSSL::Test::Simple;
+use OpenSSL::Test::Utils;
+
+setup(&quot;test_internal_provider&quot;);
+
+$ENV{&quot;OPENSSL_MODULES&quot;} = bldtop_dir(&quot;test&quot;);
+
+simple_test(&quot;test_internal_provider&quot;, &quot;provider_internal_test&quot;);
diff --git a/test/recipes/04-test_provider.t b/test/recipes/04-test_provider.t
new file mode 100644
index 0000000..9195a42
--- /dev/null
+++ b/test/recipes/04-test_provider.t
@@ -0,0 +1,18 @@
+#! /usr/bin/env perl
+# Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+use strict;
+use OpenSSL::Test qw(:DEFAULT bldtop_dir);
+use OpenSSL::Test::Simple;
+use OpenSSL::Test::Utils;
+
+setup(&quot;test_provider&quot;);
+
+$ENV{&quot;OPENSSL_MODULES&quot;} = bldtop_dir(&quot;test&quot;);
+
+simple_test(&quot;test_provider&quot;, &quot;provider_test&quot;);
diff --git a/util/libcrypto.num b/util/libcrypto.num
index cb0cb22..4243593 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4655,3 +4655,8 @@ OSSL_trace_set_callback                 4610	3_0_0	EXIST::FUNCTION:
 OSSL_trace_enabled                      4611	3_0_0	EXIST::FUNCTION:
 OSSL_trace_begin                        4612	3_0_0	EXIST::FUNCTION:
 OSSL_trace_end                          4613	3_0_0	EXIST::FUNCTION:
+OSSL_PROVIDER_load                      4614	3_0_0	EXIST::FUNCTION:
+OSSL_PROVIDER_unload                    4615	3_0_0	EXIST::FUNCTION:
+OSSL_PROVIDER_add_builtin               4616	3_0_0	EXIST::FUNCTION:
+OSSL_PROVIDER_get_param_types           4617	3_0_0	EXIST::FUNCTION:
+OSSL_PROVIDER_get_params                4618	3_0_0	EXIST::FUNCTION:
diff --git a/util/perl/OpenSSL/ParseC.pm b/util/perl/OpenSSL/ParseC.pm
index 7a13930..59b08e8 100644
--- a/util/perl/OpenSSL/ParseC.pm
+++ b/util/perl/OpenSSL/ParseC.pm
@@ -578,6 +578,15 @@ my @chandlers = (
     { regexp   =&gt; qr/extern &quot;C&quot; (.*;)/,
       massager =&gt; sub { return ($1); },
     },
+    # any other extern is just ignored
+    { regexp   =&gt; qr/^\s*                       # Any spaces before
+                     extern                     # The keyword we look for
+                     \b                         # word to non-word boundary
+                     .*                         # Anything after
+                     ;
+                    /x,
+      massager =&gt; sub { return (); },
+    },
     # union, struct and enum definitions
     # Because this one might appear a little everywhere within type
     # definitions, we take it out and replace it with just
diff --git a/util/private.num b/util/private.num
index ad1865f..cb1997a 100644
--- a/util/private.num
+++ b/util/private.num
@@ -33,6 +33,7 @@ OPENSSL_Applink                         external
 OPENSSL_CTX                             datatype
 NAMING_AUTHORITY                        datatype
 OSSL_PARAM                              datatype
+OSSL_PROVIDER                           datatype
 OSSL_STORE_CTX                          datatype
 OSSL_STORE_INFO                         datatype
 OSSL_STORE_LOADER                       datatype
diff --git a/util/providers.num b/util/providers.num
new file mode 100644
index 0000000..4e2fa81
--- /dev/null
+++ b/util/providers.num
@@ -0,0 +1 @@
+OSSL_provider_init                     1	*	EXIST::FUNCTION:
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022285.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="022295.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22292">[ date ]</a>
              <a href="thread.html#22292">[ thread ]</a>
              <a href="subject.html#22292">[ subject ]</a>
              <a href="author.html#22292">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
