<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-March/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1551867499.041728.7178.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="022207.html">
   <LINK REL="Next"  HREF="022213.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1551867499.041728.7178.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Wed Mar  6 10:18:19 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="022207.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="022213.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22210">[ date ]</a>
              <a href="thread.html#22210">[ thread ]</a>
              <a href="subject.html#22210">[ subject ]</a>
              <a href="author.html#22210">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  18e1e302452e6dea4500b6f981cee7e151294dea (commit)
       via  c699712fa329ce1ce1b4756a50a78ab2f47909e1 (commit)
       via  0b836c2168fee1689ab1ea3bb785e38b9f85ef0f (commit)
       via  3b9e1a3902068baa55ecd16b264891cbcc7549ab (commit)
       via  6e810f2dcab6d27a7158a23888c81882a3501b7f (commit)
       via  5f8a5f46e4e83735bb5ad384d8d7df771d2aa4b3 (commit)
       via  b9ce85f631cf376cd781fd3dfdc80e927d88ee77 (commit)
       via  a902e43d7d34dd3d2cb0a3fe0fe7ae23d9021b40 (commit)
       via  3a9b3d2d93017014032d1bbed3e4193bb423eaae (commit)
       via  f518e3e802d8dcad283be6cb4913dd7cfc6f11fd (commit)
       via  f272be676b5462db641897057a4feaa9e8f35c1d (commit)
       via  f4db05df0e0bc665b98e7cda33d4572071884d03 (commit)
       via  5c64173586386a7c73e6431166c96eb43ae0baa2 (commit)
       via  77359d22c97d1636eccf1fa583dc295228835144 (commit)
       via  49b26f54f4c182d6a860c91d01994bdf2bba20de (commit)
       via  16a9d3746ef7e03207cc3cd290356613556959a5 (commit)
       via  682b444f8a78b8902a3521cd6486bdecb766e5e5 (commit)
       via  2390c573aa598b715eb592c9b4da50a71453347a (commit)
      from  8ab53b193a8e95bb2998744bc184146eb1ddcc23 (commit)


- Log -----------------------------------------------------------------
commit 18e1e302452e6dea4500b6f981cee7e151294dea
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sun Feb 10 15:16:20 2019 +0100

    apps/openssl.c: avoid memory leaks
    
    The trace API doesn't know that the BIOs we give it, let alone those
    we attach to callbacks as 'void *data', need to be cleaned up.  This
    must be done in the application.
    
    To ensure this cleanup is done as late as possible, use atexit().
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit c699712fa329ce1ce1b4756a50a78ab2f47909e1
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Dec 14 17:18:00 2018 +0100

    Add a log about the tracing functionality
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 0b836c2168fee1689ab1ea3bb785e38b9f85ef0f
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Dec 14 17:17:22 2018 +0100

    Document the tracing functionality
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 3b9e1a3902068baa55ecd16b264891cbcc7549ab
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Sat Feb 9 12:37:49 2019 +0100

    Make it possible to trace the trace functionality itself
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 6e810f2dcab6d27a7158a23888c81882a3501b7f
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 13 12:35:48 2018 +0100

    Adapt BN_CTX_DEBUG to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 5f8a5f46e4e83735bb5ad384d8d7df771d2aa4b3
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 13 12:04:26 2018 +0100

    Adapt OPENSSL_DEBUG_DECRYPT to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit b9ce85f631cf376cd781fd3dfdc80e927d88ee77
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 13 08:19:08 2018 +0100

    Adapt OPENSSL_POLICY_DEBUG to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit a902e43d7d34dd3d2cb0a3fe0fe7ae23d9021b40
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 13 08:07:25 2018 +0100

    Adapt OPENSSL_DEBUG_KEYGEN to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 3a9b3d2d93017014032d1bbed3e4193bb423eaae
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 13 01:53:13 2018 +0100

    Adapt OPENSSL_DEBUG_PKCS5V2 to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit f518e3e802d8dcad283be6cb4913dd7cfc6f11fd
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 13 01:42:46 2018 +0100

    Adapt ENGINE_REF_COUNT_DEBUG to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit f272be676b5462db641897057a4feaa9e8f35c1d
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 13 01:42:07 2018 +0100

    Adapt ENGINE_TABLE_DEBUG to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit f4db05df0e0bc665b98e7cda33d4572071884d03
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 13 01:37:10 2018 +0100

    Adapt ENGINE_CONF_DEBUG to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 5c64173586386a7c73e6431166c96eb43ae0baa2
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Dec 13 00:32:57 2018 +0100

    Adapt OPENSSL_INIT_DEBUG to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 77359d22c97d1636eccf1fa583dc295228835144
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Dec 12 23:57:48 2018 +0100

    Adapt CIPHER_DEBUG to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 49b26f54f4c182d6a860c91d01994bdf2bba20de
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Dec 12 00:04:44 2018 +0100

    Adapt SSL_DEBUG to the new generic trace API
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 16a9d3746ef7e03207cc3cd290356613556959a5
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Dec 12 21:31:36 2018 +0100

    Make it possible to disable the TRACE API
    
    This disabled the tracing functionality by making functions do
    nothing, and making convenience macros produce dead code.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 682b444f8a78b8902a3521cd6486bdecb766e5e5
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Fri Dec 14 15:48:53 2018 +0100

    apps/openssl.c: Adapt to enable tracing output
    
    Use the environment variables OPENSSL_TRACE to determine what's going
    to be enabled.  The value of this variables is a comma separated list
    of trace and debugging names, which correspond to the trace category
    macros defined in include/openssl/trace.h.
    
    For example, setting OPENSSL_DEBUG=TRACE,SSL will enable debugging output
    for the types OSSL_TRACE_CATEGORY_TRACE and OSSL_TRACE_CATEGORY_SSL.
    
    This also slightly changes the handling of the prefix method in
    apps/apps.c.  This is for the better, as the prefix method pointer was
    unneccessarily stored in two places.
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

commit 2390c573aa598b715eb592c9b4da50a71453347a
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Tue Dec 11 23:58:29 2018 +0100

    Add generic trace API
    
    The idea is that the application shall be able to register output
    channels or callbacks to print tracing output as it sees fit.
    
    OpenSSL internals, on the other hand, want to print thoses texts using
    normal printing routines, such as BIO_printf() or BIO_dump() through
    well defined BIOs.
    
    When the application registers callbacks, the tracing functionality
    sets up an internal BIO that simply forwards received text to the
    appropriate application provided callback.
    
    Co-authored-by: Dr. Matthias St. Pierre &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">Matthias.St.Pierre at ncp-e.com</A>&gt;
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/8198">https://github.com/openssl/openssl/pull/8198</A>)

-----------------------------------------------------------------------

Summary of changes:
 CHANGES                                  |   9 +
 Configure                                |   1 +
 NEWS                                     |   2 +
 apps/apps.c                              |  14 +-
 apps/openssl.c                           | 115 ++++++-
 apps/s_client.c                          |   6 +-
 crypto/bn/bn_ctx.c                       |  72 ++---
 crypto/build.info                        |   1 +
 crypto/engine/eng_cnf.c                  |  19 +-
 crypto/engine/eng_int.h                  |  51 ++--
 crypto/engine/eng_table.c                |  57 ++--
 crypto/evp/p5_crpt2.c                    |  41 +--
 crypto/include/internal/cryptlib_int.h   |   2 +
 crypto/init.c                            | 198 +++++--------
 crypto/pkcs12/p12_decr.c                 |  23 +-
 crypto/pkcs12/p12_key.c                  |  48 +--
 crypto/trace.c                           | 495 +++++++++++++++++++++++++++++++
 crypto/x509v3/pcy_tree.c                 |  67 ++---
 doc/man1/openssl.pod                     |  68 +++++
 doc/man3/OSSL_trace_enabled.pod          | 183 ++++++++++++
 doc/man3/OSSL_trace_get_category_num.pod |  44 +++
 doc/man3/OSSL_trace_set_channel.pod      | 288 ++++++++++++++++++
 include/openssl/trace.h                  | 291 ++++++++++++++++++
 ssl/record/ssl3_record.c                 |  61 ++--
 ssl/s3_lib.c                             |  36 +--
 ssl/ssl_ciph.c                           |  45 +--
 ssl/ssl_init.c                           |  33 +--
 ssl/ssl_lib.c                            |   7 +-
 ssl/statem/statem_clnt.c                 |   7 +-
 ssl/statem/statem_lib.c                  |  14 +-
 ssl/statem/statem_srvr.c                 |  17 +-
 ssl/t1_enc.c                             | 114 +++----
 util/libcrypto.num                       |   9 +
 util/private.num                         |   1 +
 34 files changed, 1869 insertions(+), 570 deletions(-)
 create mode 100644 crypto/trace.c
 create mode 100644 doc/man3/OSSL_trace_enabled.pod
 create mode 100644 doc/man3/OSSL_trace_get_category_num.pod
 create mode 100644 doc/man3/OSSL_trace_set_channel.pod
 create mode 100644 include/openssl/trace.h

diff --git a/CHANGES b/CHANGES
index ff61ff4..d977c76 100644
--- a/CHANGES
+++ b/CHANGES
@@ -9,6 +9,15 @@
 
  Changes between 1.1.1 and 3.0.0 [xx XXX xxxx]
 
+  *) Added support for enabling instrumentation through trace output.
+     This is left to application control, by allowing it to register BIOs as
+     channels for a number of tracing and debugging categories.
+
+     The 'openssl' application has been expanded to enable any of the types
+     available via environment variables defined by the user, and serves as
+     one possible example on how to use this functionality.
+     [Richard Levitte &amp; Matthias St. Pierre]
+
   *) Added build tests for C++.  These are generated files that only do one
      thing, to include one public OpenSSL head file each.  This tests that
      the public header files can be usefully included in a C++ application.
diff --git a/Configure b/Configure
index 707e8b9..b2410a2 100755
--- a/Configure
+++ b/Configure
@@ -417,6 +417,7 @@ my @disablables = (
     &quot;tests&quot;,
     &quot;threads&quot;,
     &quot;tls&quot;,
+    &quot;trace&quot;,
     &quot;ts&quot;,
     &quot;ubsan&quot;,
     &quot;ui-console&quot;,
diff --git a/NEWS b/NEWS
index 7ac249e..c743dbc 100644
--- a/NEWS
+++ b/NEWS
@@ -7,6 +7,8 @@
 
   Major changes between OpenSSL 1.1.1 and OpenSSL 3.0.0 [under development]
 
+      o Add support for enabling instrumentation through trace and debug
+        output.
       o Changed our version number scheme and set the next major release to
         3.0.0
       o Added EVP_MAC, an EVP layer MAC API, and a generic EVP_PKEY to EVP_MAC
diff --git a/apps/apps.c b/apps/apps.c
index 44a90a3..d095dee 100644
--- a/apps/apps.c
+++ b/apps/apps.c
@@ -2243,8 +2243,6 @@ BIO *dup_bio_in(int format)
                       BIO_NOCLOSE | (FMT_istext(format) ? BIO_FP_TEXT : 0));
 }
 
-static BIO_METHOD *prefix_method = NULL;
-
 BIO *dup_bio_out(int format)
 {
     BIO *b = BIO_new_fp(stdout,
@@ -2256,10 +2254,9 @@ BIO *dup_bio_out(int format)
         b = BIO_push(BIO_new(BIO_f_linebuffer()), b);
 #endif
 
-    if (FMT_istext(format) &amp;&amp; (prefix = getenv(&quot;HARNESS_OSSL_PREFIX&quot;)) != NULL) {
-        if (prefix_method == NULL)
-            prefix_method = apps_bf_prefix();
-        b = BIO_push(BIO_new(prefix_method), b);
+    if (FMT_istext(format)
+        &amp;&amp; (prefix = getenv(&quot;HARNESS_OSSL_PREFIX&quot;)) != NULL) {
+        b = BIO_push(BIO_new(apps_bf_prefix()), b);
         BIO_ctrl(b, PREFIX_CTRL_SET_PREFIX, 0, prefix);
     }
 
@@ -2277,8 +2274,13 @@ BIO *dup_bio_err(int format)
     return b;
 }
 
+/*
+ * Because the prefix method is created dynamically, we must also be able
+ * to destroy it.
+ */
 void destroy_prefix_method(void)
 {
+    BIO_METHOD *prefix_method = apps_bf_prefix();
     BIO_meth_free(prefix_method);
     prefix_method = NULL;
 }
diff --git a/apps/openssl.c b/apps/openssl.c
index 6b63b36..854f943 100644
--- a/apps/openssl.c
+++ b/apps/openssl.c
@@ -13,6 +13,7 @@
 #include &lt;stdlib.h&gt;
 #include &lt;openssl/bio.h&gt;
 #include &lt;openssl/crypto.h&gt;
+#include &lt;openssl/trace.h&gt;
 #include &lt;openssl/lhash.h&gt;
 #include &lt;openssl/conf.h&gt;
 #include &lt;openssl/x509.h&gt;
@@ -93,7 +94,6 @@ static int apps_startup(void)
 static void apps_shutdown(void)
 {
     destroy_ui_method();
-    destroy_prefix_method();
 }
 
 static char *make_config_name(void)
@@ -117,6 +117,110 @@ static char *make_config_name(void)
     return p;
 }
 
+typedef struct tracedata_st {
+    BIO *bio;
+    unsigned int ingroup:1;
+} tracedata;
+
+static size_t internal_trace_cb(const char *buf, size_t cnt,
+                                int category, int cmd, void *vdata)
+{
+    int ret;
+    tracedata *trace_data = vdata;
+    int set_prefix = 0;
+
+    switch (cmd) {
+    case OSSL_TRACE_CTRL_BEGIN:
+        trace_data-&gt;ingroup = 1;
+        set_prefix = 1;
+        break;
+    case OSSL_TRACE_CTRL_DURING:
+        if (!trace_data-&gt;ingroup)
+            set_prefix = 1;
+        break;
+    case OSSL_TRACE_CTRL_END:
+        trace_data-&gt;ingroup = 0;
+        break;
+    }
+
+    if (set_prefix) {
+        union {
+            CRYPTO_THREAD_ID tid;
+            unsigned long ltid;
+        } tid;
+        char buffer[256];
+
+        tid.ltid = 0;
+        tid.tid = CRYPTO_THREAD_get_current_id();
+
+        BIO_snprintf(buffer, sizeof(buffer), &quot;TRACE[%lx]:%s: &quot;, tid.ltid,
+                     OSSL_trace_get_category_name(category));
+        BIO_ctrl(trace_data-&gt;bio, PREFIX_CTRL_SET_PREFIX,
+                 strlen(buffer), buffer);
+    }
+    ret = BIO_write(trace_data-&gt;bio, buf, cnt);
+
+    return ret &lt; 0 ? 0 : ret;
+}
+
+DEFINE_STACK_OF(tracedata)
+static STACK_OF(tracedata) *trace_data_stack;
+
+static void tracedata_free(tracedata *data)
+{
+    BIO_free_all(data-&gt;bio);
+    OPENSSL_free(data);
+}
+
+static STACK_OF(tracedata) *trace_data_stack;
+
+static void cleanup_trace(void)
+{
+    sk_tracedata_pop_free(trace_data_stack, tracedata_free);
+}
+
+static void setup_trace(const char *str)
+{
+    char *val;
+
+    trace_data_stack = sk_tracedata_new_null();
+    val = OPENSSL_strdup(str);
+
+    if (val != NULL) {
+        char *valp = val;
+        char *item;
+
+        for (valp = val; (item = strtok(valp, &quot;,&quot;)) != NULL; valp = NULL) {
+            int category = OSSL_trace_get_category_num(item);
+
+            if (category &gt;= 0) {
+                BIO *channel = BIO_push(BIO_new(apps_bf_prefix()),
+                                        dup_bio_err(FORMAT_TEXT));
+                tracedata *trace_data = OPENSSL_zalloc(sizeof(*trace_data));
+
+                if (trace_data == NULL
+                    || (trace_data-&gt;bio = channel) == NULL
+                    || OSSL_trace_set_callback(category, internal_trace_cb,
+                                               trace_data) == 0
+                    || sk_tracedata_push(trace_data_stack, trace_data) == 0) {
+                    OSSL_trace_set_callback(category, NULL, NULL);
+                    BIO_free_all(channel);
+                    fprintf(stderr,
+                            &quot;warning: unable to setup trace callback for category '%s'.\n&quot;,
+                            item);
+                }
+            } else {
+                fprintf(stderr,
+                        &quot;warning: unknown trace category: '%s'.\n&quot;,
+                        item);
+            }
+        }
+    }
+
+    OPENSSL_free(val);
+    atexit(cleanup_trace);
+}
+
 int main(int argc, char *argv[])
 {
     FUNCTION f, *fp;
@@ -145,6 +249,15 @@ int main(int argc, char *argv[])
     win32_utf8argv(&amp;argc, &amp;argv);
 #endif
 
+    /*
+     * We use the prefix method to get the trace output we want.  Since some
+     * trace outputs happen with OPENSSL_cleanup(), which is run automatically
+     * after exit(), we need to destroy the prefix method as late as possible.
+     */
+    atexit(destroy_prefix_method);
+
+    setup_trace(getenv(&quot;OPENSSL_TRACE&quot;));
+
     p = getenv(&quot;OPENSSL_DEBUG_MEMORY&quot;);
     if (p != NULL &amp;&amp; strcmp(p, &quot;on&quot;) == 0)
         CRYPTO_set_mem_debug(1);
diff --git a/apps/s_client.c b/apps/s_client.c
index 687e755..7a41d83 100644
--- a/apps/s_client.c
+++ b/apps/s_client.c
@@ -38,6 +38,7 @@ typedef unsigned int u_int;
 #include &lt;openssl/rand.h&gt;
 #include &lt;openssl/ocsp.h&gt;
 #include &lt;openssl/bn.h&gt;
+#include &lt;openssl/trace.h&gt;
 #include &lt;openssl/async.h&gt;
 #ifndef OPENSSL_NO_SRP
 # include &lt;openssl/srp.h&gt;
@@ -1521,6 +1522,7 @@ int s_client_main(int argc, char **argv)
             break;
         }
     }
+
     if (count4or6 &gt;= 2) {
         BIO_printf(bio_err, &quot;%s: Can't use both -4 and -6\n&quot;, prog);
         goto opthelp;
@@ -3321,8 +3323,7 @@ static void print_stuff(BIO *bio, SSL *s, int full)
         BIO_printf(bio_err, &quot;Using Kernel TLS for sending\n&quot;);
 #endif
 
-#ifdef SSL_DEBUG
-    {
+    if (OSSL_TRACE_ENABLED(TLS)) {
         /* Print out local port of connection: useful for debugging */
         int sock;
         union BIO_sock_info_u info;
@@ -3335,7 +3336,6 @@ static void print_stuff(BIO *bio, SSL *s, int full)
         }
         BIO_ADDR_free(info.addr);
     }
-#endif
 
 #if !defined(OPENSSL_NO_NEXTPROTONEG)
     if (next_proto.status != -1) {
diff --git a/crypto/bn/bn_ctx.c b/crypto/bn/bn_ctx.c
index d6e7605..9e908bf 100644
--- a/crypto/bn/bn_ctx.c
+++ b/crypto/bn/bn_ctx.c
@@ -7,6 +7,7 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
+#include &lt;openssl/trace.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;bn_lcl.h&quot;
 
@@ -87,48 +88,38 @@ struct bignum_ctx {
     int flags;
 };
 
-/* Enable this to find BN_CTX bugs */
-#ifdef BN_CTX_DEBUG
-static const char *ctxdbg_cur = NULL;
-static void ctxdbg(BN_CTX *ctx)
+/* Debugging functionality */
+static void ctxdbg(BIO *channel, const char *text, BN_CTX *ctx)
 {
     unsigned int bnidx = 0, fpidx = 0;
     BN_POOL_ITEM *item = ctx-&gt;pool.head;
     BN_STACK *stack = &amp;ctx-&gt;stack;
-    fprintf(stderr, &quot;(%16p): &quot;, ctx);
+
+    BIO_printf(channel, &quot;%s\n&quot;, text);
+    BIO_printf(channel, &quot;  (%16p): &quot;, (void*)ctx);
     while (bnidx &lt; ctx-&gt;used) {
-        fprintf(stderr, &quot;%03x &quot;, item-&gt;vals[bnidx++ % BN_CTX_POOL_SIZE].dmax);
+        BIO_printf(channel, &quot;%03x &quot;,
+                   item-&gt;vals[bnidx++ % BN_CTX_POOL_SIZE].dmax);
         if (!(bnidx % BN_CTX_POOL_SIZE))
             item = item-&gt;next;
     }
-    fprintf(stderr, &quot;\n&quot;);
+    BIO_printf(channel, &quot;\n&quot;);
     bnidx = 0;
-    fprintf(stderr, &quot;          : &quot;);
+    BIO_printf(channel, &quot;   %16s : &quot;, &quot;&quot;);
     while (fpidx &lt; stack-&gt;depth) {
         while (bnidx++ &lt; stack-&gt;indexes[fpidx])
-            fprintf(stderr, &quot;    &quot;);
-        fprintf(stderr, &quot;^^^ &quot;);
+            BIO_printf(channel, &quot;    &quot;);
+        BIO_printf(channel, &quot;^^^ &quot;);
         bnidx++;
         fpidx++;
     }
-    fprintf(stderr, &quot;\n&quot;);
+    BIO_printf(channel, &quot;\n&quot;);
 }
 
-# define CTXDBG_ENTRY(str, ctx)  do { \
-                                ctxdbg_cur = (str); \
-                                fprintf(stderr,&quot;Starting %s\n&quot;, ctxdbg_cur); \
-                                ctxdbg(ctx); \
-                                } while(0)
-# define CTXDBG_EXIT(ctx)        do { \
-                                fprintf(stderr,&quot;Ending %s\n&quot;, ctxdbg_cur); \
-                                ctxdbg(ctx); \
-                                } while(0)
-# define CTXDBG_RET(ctx,ret)
-#else
-# define CTXDBG_ENTRY(str, ctx)
-# define CTXDBG_EXIT(ctx)
-# define CTXDBG_RET(ctx,ret)
-#endif
+#define CTXDBG(str, ctx)            \
+    OSSL_TRACE_BEGIN(BN_CTX) {      \
+        ctxdbg(trc_out, str, ctx);  \
+    } OSSL_TRACE_END(BN_CTX)
 
 
 BN_CTX *BN_CTX_new(void)
@@ -158,21 +149,20 @@ void BN_CTX_free(BN_CTX *ctx)
 {
     if (ctx == NULL)
         return;
-#ifdef BN_CTX_DEBUG
-    {
+    OSSL_TRACE_BEGIN(BN_CTX) {
         BN_POOL_ITEM *pool = ctx-&gt;pool.head;
-        fprintf(stderr, &quot;BN_CTX_free, stack-size=%d, pool-bignums=%d\n&quot;,
-                ctx-&gt;stack.size, ctx-&gt;pool.size);
-        fprintf(stderr, &quot;dmaxs: &quot;);
+        BIO_printf(trc_out,
+                   &quot;BN_CTX_free(): stack-size=%d, pool-bignums=%d\n&quot;,
+                   ctx-&gt;stack.size, ctx-&gt;pool.size);
+        BIO_printf(trc_out, &quot;  dmaxs: &quot;);
         while (pool) {
             unsigned loop = 0;
             while (loop &lt; BN_CTX_POOL_SIZE)
-                fprintf(stderr, &quot;%02x &quot;, pool-&gt;vals[loop++].dmax);
+                BIO_printf(trc_out, &quot;%02x &quot;, pool-&gt;vals[loop++].dmax);
             pool = pool-&gt;next;
         }
-        fprintf(stderr, &quot;\n&quot;);
-    }
-#endif
+        BIO_printf(trc_out, &quot;\n&quot;);
+    } OSSL_TRACE_END(BN_CTX);
     BN_STACK_finish(&amp;ctx-&gt;stack);
     BN_POOL_finish(&amp;ctx-&gt;pool);
     OPENSSL_free(ctx);
@@ -180,7 +170,7 @@ void BN_CTX_free(BN_CTX *ctx)
 
 void BN_CTX_start(BN_CTX *ctx)
 {
-    CTXDBG_ENTRY(&quot;BN_CTX_start&quot;, ctx);
+    CTXDBG(&quot;ENTER BN_CTX_start()&quot;, ctx);
     /* If we're already overflowing ... */
     if (ctx-&gt;err_stack || ctx-&gt;too_many)
         ctx-&gt;err_stack++;
@@ -189,12 +179,12 @@ void BN_CTX_start(BN_CTX *ctx)
         BNerr(BN_F_BN_CTX_START, BN_R_TOO_MANY_TEMPORARY_VARIABLES);
         ctx-&gt;err_stack++;
     }
-    CTXDBG_EXIT(ctx);
+    CTXDBG(&quot;LEAVE BN_CTX_start()&quot;, ctx);
 }
 
 void BN_CTX_end(BN_CTX *ctx)
 {
-    CTXDBG_ENTRY(&quot;BN_CTX_end&quot;, ctx);
+    CTXDBG(&quot;ENTER BN_CTX_end()&quot;, ctx);
     if (ctx-&gt;err_stack)
         ctx-&gt;err_stack--;
     else {
@@ -206,14 +196,14 @@ void BN_CTX_end(BN_CTX *ctx)
         /* Unjam &quot;too_many&quot; in case &quot;get&quot; had failed */
         ctx-&gt;too_many = 0;
     }
-    CTXDBG_EXIT(ctx);
+    CTXDBG(&quot;LEAVE BN_CTX_end()&quot;, ctx);
 }
 
 BIGNUM *BN_CTX_get(BN_CTX *ctx)
 {
     BIGNUM *ret;
 
-    CTXDBG_ENTRY(&quot;BN_CTX_get&quot;, ctx);
+    CTXDBG(&quot;ENTER BN_CTX_get()&quot;, ctx);
     if (ctx-&gt;err_stack || ctx-&gt;too_many)
         return NULL;
     if ((ret = BN_POOL_get(&amp;ctx-&gt;pool, ctx-&gt;flags)) == NULL) {
@@ -230,7 +220,7 @@ BIGNUM *BN_CTX_get(BN_CTX *ctx)
     /* clear BN_FLG_CONSTTIME if leaked from previous frames */
     ret-&gt;flags &amp;= (~BN_FLG_CONSTTIME);
     ctx-&gt;used++;
-    CTXDBG_RET(ctx, ret);
+    CTXDBG(&quot;LEAVE BN_CTX_get()&quot;, ctx);
     return ret;
 }
 
diff --git a/crypto/build.info b/crypto/build.info
index 94ed06e..e3e9cee 100644
--- a/crypto/build.info
+++ b/crypto/build.info
@@ -13,6 +13,7 @@ SOURCE[../libcrypto]=\
         ebcdic.c uid.c o_time.c o_str.c o_dir.c o_fopen.c ctype.c \
         threads_pthread.c threads_win.c threads_none.c getenv.c \
         o_init.c o_fips.c mem_sec.c init.c context.c sparse_array.c \
+        trace.c \
         {- $target{cpuid_asm_src} -} {- $target{uplink_aux_src} -}
 
 DEPEND[cversion.o]=buildinf.h
diff --git a/crypto/engine/eng_cnf.c b/crypto/engine/eng_cnf.c
index bece327..c87a8a1 100644
--- a/crypto/engine/eng_cnf.c
+++ b/crypto/engine/eng_cnf.c
@@ -9,8 +9,7 @@
 
 #include &quot;eng_int.h&quot;
 #include &lt;openssl/conf.h&gt;
-
-/* #define ENGINE_CONF_DEBUG */
+#include &lt;openssl/trace.h&gt;
 
 /* ENGINE config module */
 
@@ -50,9 +49,7 @@ static int int_engine_configure(const char *name, const char *value, const CONF
     int soft = 0;
 
     name = skip_dot(name);
-#ifdef ENGINE_CONF_DEBUG
-    fprintf(stderr, &quot;Configuring engine %s\n&quot;, name);
-#endif
+    OSSL_TRACE1(ENGINE_CONF, &quot;Configuring engine %s\n&quot;, name);
     /* Value is a section containing ENGINE commands */
     ecmds = NCONF_get_section(cnf, value);
 
@@ -66,10 +63,8 @@ static int int_engine_configure(const char *name, const char *value, const CONF
         ecmd = sk_CONF_VALUE_value(ecmds, i);
         ctrlname = skip_dot(ecmd-&gt;name);
         ctrlvalue = ecmd-&gt;value;
-#ifdef ENGINE_CONF_DEBUG
-        fprintf(stderr, &quot;ENGINE conf: doing ctrl(%s,%s)\n&quot;, ctrlname,
-                ctrlvalue);
-#endif
+        OSSL_TRACE2(ENGINE_CONF, &quot;ENGINE conf: doing ctrl(%s,%s)\n&quot;,
+                    ctrlname, ctrlvalue);
 
         /* First handle some special pseudo ctrls */
 
@@ -153,10 +148,8 @@ static int int_engine_module_init(CONF_IMODULE *md, const CONF *cnf)
     STACK_OF(CONF_VALUE) *elist;
     CONF_VALUE *cval;
     int i;
-#ifdef ENGINE_CONF_DEBUG
-    fprintf(stderr, &quot;Called engine module: name %s, value %s\n&quot;,
-            CONF_imodule_get_name(md), CONF_imodule_get_value(md));
-#endif
+    OSSL_TRACE2(ENGINE_CONF, &quot;Called engine module: name %s, value %s\n&quot;,
+                CONF_imodule_get_name(md), CONF_imodule_get_value(md));
     /* Value is a section containing ENGINEs to configure */
     elist = NCONF_get_section(cnf, CONF_imodule_get_value(md));
 
diff --git a/crypto/engine/eng_int.h b/crypto/engine/eng_int.h
index 2a32411..d456175 100644
--- a/crypto/engine/eng_int.h
+++ b/crypto/engine/eng_int.h
@@ -11,6 +11,7 @@
 #ifndef HEADER_ENGINE_INT_H
 # define HEADER_ENGINE_INT_H
 
+# include &lt;openssl/trace.h&gt;
 # include &quot;internal/cryptlib.h&quot;
 # include &quot;internal/engine.h&quot;
 # include &quot;internal/thread_once.h&quot;
@@ -19,27 +20,20 @@
 extern CRYPTO_RWLOCK *global_engine_lock;
 
 /*
- * If we compile with this symbol defined, then both reference counts in the
- * ENGINE structure will be monitored with a line of output on stderr for
- * each change. This prints the engine's pointer address (truncated to
- * unsigned int), &quot;struct&quot; or &quot;funct&quot; to indicate the reference type, the
- * before and after reference count, and the file:line-number pair. The
- * &quot;engine_ref_debug&quot; statements must come *after* the change.
+ * This prints the engine's pointer address (truncated to unsigned int),
+ * &quot;struct&quot; or &quot;funct&quot; to indicate the reference type, the before and after
+ * reference count, and the file:line-number pair. The &quot;engine_ref_debug&quot;
+ * statements must come *after* the change.
  */
-# ifdef ENGINE_REF_COUNT_DEBUG
-
-#  define engine_ref_debug(e, isfunct, diff) \
-        fprintf(stderr, &quot;engine: %08x %s from %d to %d (%s:%d)\n&quot;, \
-                (unsigned int)(e), (isfunct ? &quot;funct&quot; : &quot;struct&quot;), \
-                ((isfunct) ? ((e)-&gt;funct_ref - (diff)) : ((e)-&gt;struct_ref - (diff))), \
-                ((isfunct) ? (e)-&gt;funct_ref : (e)-&gt;struct_ref), \
-                (OPENSSL_FILE), (OPENSSL_LINE))
-
-# else
-
-#  define engine_ref_debug(e, isfunct, diff)
-
-# endif
+# define engine_ref_debug(e, isfunct, diff)                             \
+    OSSL_TRACE6(ENGINE_REF_COUNT,                                       \
+               &quot;engine: %p %s from %d to %d (%s:%d)\n&quot;,               \
+               (void *)(e), (isfunct ? &quot;funct&quot; : &quot;struct&quot;),             \
+               ((isfunct)                                               \
+                ? ((e)-&gt;funct_ref - (diff))                             \
+                : ((e)-&gt;struct_ref - (diff))),                          \
+               ((isfunct) ? (e)-&gt;funct_ref : (e)-&gt;struct_ref),          \
+               (OPENSSL_FILE), (OPENSSL_LINE))
 
 /*
  * Any code that will need cleanup operations should use these functions to
@@ -59,14 +53,6 @@ void engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb);
 DEFINE_STACK_OF(ENGINE)
 
 /*
- * If this symbol is defined then engine_table_select(), the function that is
- * used by RSA, DSA (etc) code to select registered ENGINEs, cache defaults
- * and functional references (etc), will display debugging summaries to
- * stderr.
- */
-/* #define ENGINE_TABLE_DEBUG */
-
-/*
  * This represents an implementation table. Dependent code should instantiate
  * it as a (ENGINE_TABLE *) pointer value set initially to NULL.
  */
@@ -76,13 +62,10 @@ int engine_table_register(ENGINE_TABLE **table, ENGINE_CLEANUP_CB *cleanup,
                           int setdefault);
 void engine_table_unregister(ENGINE_TABLE **table, ENGINE *e);
 void engine_table_cleanup(ENGINE_TABLE **table);
-# ifndef ENGINE_TABLE_DEBUG
-ENGINE *engine_table_select(ENGINE_TABLE **table, int nid);
-# else
-ENGINE *engine_table_select_tmp(ENGINE_TABLE **table, int nid, const char *f,
+ENGINE *engine_table_select_int(ENGINE_TABLE **table, int nid, const char *f,
                                 int l);
-#  define engine_table_select(t,n) engine_table_select_tmp(t,n,OPENSSL_FILE,OPENSSL_LINE)
-# endif
+# define engine_table_select(t,n)                               \
+    engine_table_select_int(t,n,OPENSSL_FILE,OPENSSL_LINE)
 typedef void (engine_table_doall_cb) (int nid, STACK_OF(ENGINE) *sk,
                                       ENGINE *def, void *arg);
 void engine_table_doall(ENGINE_TABLE *table, engine_table_doall_cb *cb,
diff --git a/crypto/engine/eng_table.c b/crypto/engine/eng_table.c
index b0e3ebb..c3afa58 100644
--- a/crypto/engine/eng_table.c
+++ b/crypto/engine/eng_table.c
@@ -10,6 +10,7 @@
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/lhash.h&gt;
+#include &lt;openssl/trace.h&gt;
 #include &quot;eng_int.h&quot;
 
 /* The type of the items in the table */
@@ -189,29 +190,24 @@ void engine_table_cleanup(ENGINE_TABLE **table)
 }
 
 /* return a functional reference for a given 'nid' */
-#ifndef ENGINE_TABLE_DEBUG
-ENGINE *engine_table_select(ENGINE_TABLE **table, int nid)
-#else
-ENGINE *engine_table_select_tmp(ENGINE_TABLE **table, int nid, const char *f,
+ENGINE *engine_table_select_int(ENGINE_TABLE **table, int nid, const char *f,
                                 int l)
-#endif
 {
     ENGINE *ret = NULL;
     ENGINE_PILE tmplate, *fnd = NULL;
     int initres, loop = 0;
 
     if (!(*table)) {
-#ifdef ENGINE_TABLE_DEBUG
-        fprintf(stderr, &quot;engine_table_dbg: %s:%d, nid=%d, nothing &quot;
-                &quot;registered!\n&quot;, f, l, nid);
-#endif
+        OSSL_TRACE3(ENGINE_TABLE,
+                   &quot;%s:%d, nid=%d, nothing registered!\n&quot;,
+                   f, l, nid);
         return NULL;
     }
     ERR_set_mark();
     CRYPTO_THREAD_write_lock(global_engine_lock);
     /*
      * Check again inside the lock otherwise we could race against cleanup
-     * operations. But don't worry about a fprintf(stderr).
+     * operations. But don't worry about a debug printout
      */
     if (!int_table_check(table, 0))
         goto end;
@@ -220,10 +216,9 @@ ENGINE *engine_table_select_tmp(ENGINE_TABLE **table, int nid, const char *f,
     if (!fnd)
         goto end;
     if (fnd-&gt;funct &amp;&amp; engine_unlocked_init(fnd-&gt;funct)) {
-#ifdef ENGINE_TABLE_DEBUG
-        fprintf(stderr, &quot;engine_table_dbg: %s:%d, nid=%d, using &quot;
-                &quot;ENGINE '%s' cached\n&quot;, f, l, nid, fnd-&gt;funct-&gt;id);
-#endif
+        OSSL_TRACE4(ENGINE_TABLE,
+                   &quot;%s:%d, nid=%d, using ENGINE '%s' cached\n&quot;,
+                   f, l, nid, fnd-&gt;funct-&gt;id);
         ret = fnd-&gt;funct;
         goto end;
     }
@@ -234,10 +229,10 @@ ENGINE *engine_table_select_tmp(ENGINE_TABLE **table, int nid, const char *f,
  trynext:
     ret = sk_ENGINE_value(fnd-&gt;sk, loop++);
     if (!ret) {
-#ifdef ENGINE_TABLE_DEBUG
-        fprintf(stderr, &quot;engine_table_dbg: %s:%d, nid=%d, no &quot;
-                &quot;registered implementations would initialise\n&quot;, f, l, nid);
-#endif
+        OSSL_TRACE3(ENGINE_TABLE,
+                    &quot;%s:%d, nid=%d, &quot;
+                    &quot;no registered implementations would initialise\n&quot;,
+                    f, l, nid);
         goto end;
     }
     /* Try to initialise the ENGINE? */
@@ -252,15 +247,13 @@ ENGINE *engine_table_select_tmp(ENGINE_TABLE **table, int nid, const char *f,
             if (fnd-&gt;funct)
                 engine_unlocked_finish(fnd-&gt;funct, 0);
             fnd-&gt;funct = ret;
-#ifdef ENGINE_TABLE_DEBUG
-            fprintf(stderr, &quot;engine_table_dbg: %s:%d, nid=%d, &quot;
-                    &quot;setting default to '%s'\n&quot;, f, l, nid, ret-&gt;id);
-#endif
+            OSSL_TRACE4(ENGINE_TABLE,
+                        &quot;%s:%d, nid=%d, setting default to '%s'\n&quot;,
+                        f, l, nid, ret-&gt;id);
         }
-#ifdef ENGINE_TABLE_DEBUG
-        fprintf(stderr, &quot;engine_table_dbg: %s:%d, nid=%d, using &quot;
-                &quot;newly initialised '%s'\n&quot;, f, l, nid, ret-&gt;id);
-#endif
+        OSSL_TRACE4(ENGINE_TABLE,
+                    &quot;%s:%d, nid=%d, using newly initialised '%s'\n&quot;,
+                    f, l, nid, ret-&gt;id);
         goto end;
     }
     goto trynext;
@@ -271,14 +264,14 @@ ENGINE *engine_table_select_tmp(ENGINE_TABLE **table, int nid, const char *f,
      */
     if (fnd)
         fnd-&gt;uptodate = 1;
-#ifdef ENGINE_TABLE_DEBUG
     if (ret)
-        fprintf(stderr, &quot;engine_table_dbg: %s:%d, nid=%d, caching &quot;
-                &quot;ENGINE '%s'\n&quot;, f, l, nid, ret-&gt;id);
+        OSSL_TRACE4(ENGINE_TABLE,
+                   &quot;%s:%d, nid=%d, caching ENGINE '%s'\n&quot;,
+                   f, l, nid, ret-&gt;id);
     else
-        fprintf(stderr, &quot;engine_table_dbg: %s:%d, nid=%d, caching &quot;
-                &quot;'no matching ENGINE'\n&quot;, f, l, nid);
-#endif
+        OSSL_TRACE3(ENGINE_TABLE,
+                    &quot;%s:%d, nid=%d, caching 'no matching ENGINE'\n&quot;,
+                    f, l, nid);
     CRYPTO_THREAD_unlock(global_engine_lock);
     /*
      * Whatever happened, any failed init()s are not failures in this
diff --git a/crypto/evp/p5_crpt2.c b/crypto/evp/p5_crpt2.c
index 4210e51..ac5b974 100644
--- a/crypto/evp/p5_crpt2.c
+++ b/crypto/evp/p5_crpt2.c
@@ -14,16 +14,10 @@
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/kdf.h&gt;
 #include &lt;openssl/hmac.h&gt;
+#include &lt;openssl/trace.h&gt;
 #include &quot;internal/evp_int.h&quot;
 #include &quot;evp_locl.h&quot;
 
-/* set this to print out info about the keygen algorithm */
-/* #define OPENSSL_DEBUG_PKCS5V2 */
-
-#ifdef OPENSSL_DEBUG_PKCS5V2
-static void h__dump(const unsigned char *p, int len);
-#endif
-
 int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
                       const unsigned char *salt, int saltlen, int iter,
                       const EVP_MD *digest, int keylen, unsigned char *out)
@@ -55,15 +49,21 @@ int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
 
     EVP_KDF_CTX_free(kctx);
 
-# ifdef OPENSSL_DEBUG_PKCS5V2
-    fprintf(stderr, &quot;Password:\n&quot;);
-    h__dump(pass, passlen);
-    fprintf(stderr, &quot;Salt:\n&quot;);
-    h__dump(salt, saltlen);
-    fprintf(stderr, &quot;Iteration count %d\n&quot;, iter);
-    fprintf(stderr, &quot;Key:\n&quot;);
-    h__dump(out, keylen);
-# endif
+    OSSL_TRACE_BEGIN(PKCS5V2) {
+        BIO_printf(trc_out, &quot;Password:\n&quot;);
+        BIO_hex_string(trc_out,
+                       0, passlen, pass, passlen);
+        BIO_printf(trc_out, &quot;\n&quot;);
+        BIO_printf(trc_out, &quot;Salt:\n&quot;);
+        BIO_hex_string(trc_out,
+                       0, saltlen, salt, saltlen);
+        BIO_printf(trc_out, &quot;\n&quot;);
+        BIO_printf(trc_out, &quot;Iteration count %d\n&quot;, iter);
+        BIO_printf(trc_out, &quot;Key:\n&quot;);
+        BIO_hex_string(trc_out,
+                       0, keylen, out, keylen);
+        BIO_printf(trc_out, &quot;\n&quot;);
+    } OSSL_TRACE_END(PKCS5V2);
     return rv;
 }
 
@@ -200,12 +200,3 @@ int PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,
     PBKDF2PARAM_free(kdf);
     return rv;
 }
-
-# ifdef OPENSSL_DEBUG_PKCS5V2
-static void h__dump(const unsigned char *p, int len)
-{
-    for (; len--; p++)
-        fprintf(stderr, &quot;%02X &quot;, *p);
-    fprintf(stderr, &quot;\n&quot;);
-}
-# endif
diff --git a/crypto/include/internal/cryptlib_int.h b/crypto/include/internal/cryptlib_int.h
index 618dadb..422ef01 100644
--- a/crypto/include/internal/cryptlib_int.h
+++ b/crypto/include/internal/cryptlib_int.h
@@ -32,4 +32,6 @@ int ossl_init_thread_start(uint64_t opts);
 # define OPENSSL_INIT_THREAD_ERR_STATE       0x02
 # define OPENSSL_INIT_THREAD_RAND            0x04
 
+int ossl_trace_init(void);
+void ossl_trace_cleanup(void);
 void ossl_malloc_setup_failures(void);
diff --git a/crypto/init.c b/crypto/init.c
index ef9c043..12c9d62 100644
--- a/crypto/init.c
+++ b/crypto/init.c
@@ -27,6 +27,7 @@
 #include &quot;internal/dso_conf.h&quot;
 #include &quot;internal/dso.h&quot;
 #include &quot;internal/store.h&quot;
+#include &lt;openssl/trace.h&gt;
 
 static int stopped = 0;
 
@@ -90,9 +91,10 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_base)
 {
     CRYPTO_THREAD_LOCAL key;
 
-#ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_base: Setting up stop handlers\n&quot;);
-#endif
+    if (ossl_trace_init() == 0)
+        return 0;
+
+    OSSL_TRACE(INIT, &quot;ossl_init_base: setting up stop handlers\n&quot;);
 #ifndef OPENSSL_NO_CRYPTO_MDEBUG
     ossl_malloc_setup_failures();
 #endif
@@ -107,9 +109,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_base)
     return 1;
 
 err:
-#ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_base not ok!\n&quot;);
-#endif
+    OSSL_TRACE(INIT, &quot;ossl_init_base failed!\n&quot;);
     CRYPTO_THREAD_lock_free(init_lock);
     init_lock = NULL;
 
@@ -158,9 +158,8 @@ DEFINE_RUN_ONCE_STATIC_ALT(ossl_init_no_register_atexit,
 static CRYPTO_ONCE load_crypto_nodelete = CRYPTO_ONCE_STATIC_INIT;
 DEFINE_RUN_ONCE_STATIC(ossl_init_load_crypto_nodelete)
 {
-#ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_load_crypto_nodelete()\n&quot;);
-#endif
+    OSSL_TRACE(INIT, &quot;ossl_init_load_crypto_nodelete()\n&quot;);
+
 #if !defined(OPENSSL_NO_DSO) \
     &amp;&amp; !defined(OPENSSL_USE_NODELETE) \
     &amp;&amp; !defined(OPENSSL_NO_PINSHARED)
@@ -174,10 +173,10 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_load_crypto_nodelete)
                                 | GET_MODULE_HANDLE_EX_FLAG_PIN,
                                 (void *)&amp;base_inited, &amp;handle);
 
-#  ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: obtained DSO reference? %s\n&quot;,
-                (ret == TRUE ? &quot;No!&quot; : &quot;Yes.&quot;));
-#  endif
+        OSSL_TRACE1(INIT,
+                    &quot;ossl_init_load_crypto_nodelete: &quot;
+                    &quot;obtained DSO reference? %s\n&quot;,
+                    (ret == TRUE ? &quot;No!&quot; : &quot;Yes.&quot;));
         return (ret == TRUE) ? 1 : 0;
     }
 # else
@@ -193,15 +192,13 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_load_crypto_nodelete)
             return 0;
 
         dso = DSO_dsobyaddr(&amp;base_inited, DSO_FLAG_NO_UNLOAD_ON_FREE);
-#  ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: obtained DSO reference? %s\n&quot;,
-                (dso == NULL ? &quot;No!&quot; : &quot;Yes.&quot;));
         /*
          * In case of No!, it is uncertain our exit()-handlers can still be
          * called. After dlclose() the whole library might have been unloaded
          * already.
          */
-#  endif
+        OSSL_TRACE1(INIT, &quot;obtained DSO reference? %s\n&quot;,
+                    (dso == NULL ? &quot;No!&quot; : &quot;Yes.&quot;));
         DSO_free(dso);
         err_unshelve_state(err);
     }
@@ -221,10 +218,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_load_crypto_strings)
      * pulling in all the error strings during static linking
      */
 #if !defined(OPENSSL_NO_ERR) &amp;&amp; !defined(OPENSSL_NO_AUTOERRINIT)
-# ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_load_crypto_strings: &quot;
-                    &quot;err_load_crypto_strings_int()\n&quot;);
-# endif
+    OSSL_TRACE(INIT, &quot;err_load_crypto_strings_int()\n&quot;);
     ret = err_load_crypto_strings_int();
     load_crypto_strings_inited = 1;
 #endif
@@ -246,10 +240,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_add_all_ciphers)
      * pulling in all the ciphers during static linking
      */
 #ifndef OPENSSL_NO_AUTOALGINIT
-# ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_add_all_ciphers: &quot;
-                    &quot;openssl_add_all_ciphers_int()\n&quot;);
-# endif
+    OSSL_TRACE(INIT, &quot;openssl_add_all_ciphers_int()\n&quot;);
     openssl_add_all_ciphers_int();
 #endif
     return 1;
@@ -270,10 +261,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_add_all_digests)
      * pulling in all the ciphers during static linking
      */
 #ifndef OPENSSL_NO_AUTOALGINIT
-# ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_add_all_digests: &quot;
-                    &quot;openssl_add_all_digests()\n&quot;);
-# endif
+    OSSL_TRACE(INIT, &quot;openssl_add_all_digests()\n&quot;);
     openssl_add_all_digests_int();
 #endif
     return 1;
@@ -294,10 +282,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_add_all_macs)
      * pulling in all the macs during static linking
      */
 #ifndef OPENSSL_NO_AUTOALGINIT
-# ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_add_all_macs: &quot;
-                    &quot;openssl_add_all_macs_int()\n&quot;);
-# endif
+    OSSL_TRACE(INIT, &quot;openssl_add_all_macs_int()\n&quot;);
     openssl_add_all_macs_int();
 #endif
     return 1;
@@ -320,10 +305,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_config)
 }
 DEFINE_RUN_ONCE_STATIC_ALT(ossl_init_no_config, ossl_init_config)
 {
-#ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr,
-            &quot;OPENSSL_INIT: ossl_init_config: openssl_no_config_int()\n&quot;);
-#endif
+    OSSL_TRACE(INIT, &quot;openssl_no_config_int()\n&quot;);
     openssl_no_config_int();
     config_inited = 1;
     return 1;
@@ -333,9 +315,7 @@ static CRYPTO_ONCE async = CRYPTO_ONCE_STATIC_INIT;
 static int async_inited = 0;
 DEFINE_RUN_ONCE_STATIC(ossl_init_async)
 {
-#ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_async: async_init()\n&quot;);
-#endif
+    OSSL_TRACE(INIT, &quot;async_init()\n&quot;);
     if (!async_init())
         return 0;
     async_inited = 1;
@@ -346,22 +326,15 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_async)
 static CRYPTO_ONCE engine_openssl = CRYPTO_ONCE_STATIC_INIT;
 DEFINE_RUN_ONCE_STATIC(ossl_init_engine_openssl)
 {
-# ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_engine_openssl: &quot;
-                    &quot;engine_load_openssl_int()\n&quot;);
-# endif
+    OSSL_TRACE(INIT, &quot;engine_load_openssl_int()\n&quot;);
     engine_load_openssl_int();
     return 1;
 }
-
 # ifndef OPENSSL_NO_RDRAND
 static CRYPTO_ONCE engine_rdrand = CRYPTO_ONCE_STATIC_INIT;
 DEFINE_RUN_ONCE_STATIC(ossl_init_engine_rdrand)
 {
-#  ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_engine_rdrand: &quot;
-                    &quot;engine_load_rdrand_int()\n&quot;);
-#  endif
+    OSSL_TRACE(INIT, &quot;engine_load_rdrand_int()\n&quot;);
     engine_load_rdrand_int();
     return 1;
 }
@@ -369,10 +342,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_engine_rdrand)
 static CRYPTO_ONCE engine_dynamic = CRYPTO_ONCE_STATIC_INIT;
 DEFINE_RUN_ONCE_STATIC(ossl_init_engine_dynamic)
 {
-# ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_engine_dynamic: &quot;
-                    &quot;engine_load_dynamic_int()\n&quot;);
-# endif
+    OSSL_TRACE(INIT, &quot;engine_load_dynamic_int()\n&quot;);
     engine_load_dynamic_int();
     return 1;
 }
@@ -381,10 +351,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_engine_dynamic)
 static CRYPTO_ONCE engine_devcrypto = CRYPTO_ONCE_STATIC_INIT;
 DEFINE_RUN_ONCE_STATIC(ossl_init_engine_devcrypto)
 {
-#   ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_engine_devcrypto: &quot;
-                    &quot;engine_load_devcrypto_int()\n&quot;);
-#   endif
+    OSSL_TRACE(INIT, &quot;engine_load_devcrypto_int()\n&quot;);
     engine_load_devcrypto_int();
     return 1;
 }
@@ -393,10 +360,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_engine_devcrypto)
 static CRYPTO_ONCE engine_padlock = CRYPTO_ONCE_STATIC_INIT;
 DEFINE_RUN_ONCE_STATIC(ossl_init_engine_padlock)
 {
-#   ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_engine_padlock: &quot;
-                    &quot;engine_load_padlock_int()\n&quot;);
-#   endif
+    OSSL_TRACE(INIT, &quot;engine_load_padlock_int()\n&quot;);
     engine_load_padlock_int();
     return 1;
 }
@@ -405,10 +369,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_engine_padlock)
 static CRYPTO_ONCE engine_capi = CRYPTO_ONCE_STATIC_INIT;
 DEFINE_RUN_ONCE_STATIC(ossl_init_engine_capi)
 {
-#   ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_engine_capi: &quot;
-                    &quot;engine_load_capi_int()\n&quot;);
-#   endif
+    OSSL_TRACE(INIT, &quot;engine_load_capi_int()\n&quot;);
     engine_load_capi_int();
     return 1;
 }
@@ -417,10 +378,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_engine_capi)
 static CRYPTO_ONCE engine_afalg = CRYPTO_ONCE_STATIC_INIT;
 DEFINE_RUN_ONCE_STATIC(ossl_init_engine_afalg)
 {
-#   ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_engine_afalg: &quot;
-                    &quot;engine_load_afalg_int()\n&quot;);
-#   endif
+    OSSL_TRACE(INIT, &quot;engine_load_afalg_int()\n&quot;);
     engine_load_afalg_int();
     return 1;
 }
@@ -447,26 +405,17 @@ static void ossl_init_thread_stop(struct thread_local_inits_st *locals)
         return;
 
     if (locals-&gt;async) {
-#ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_thread_stop: &quot;
-                        &quot;async_delete_thread_state()\n&quot;);
-#endif
+        OSSL_TRACE(INIT, &quot;async_delete_thread_state()\n&quot;);
         async_delete_thread_state();
     }
 
     if (locals-&gt;err_state) {
-#ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_thread_stop: &quot;
-                        &quot;err_delete_thread_state()\n&quot;);
-#endif
+        OSSL_TRACE(INIT, &quot;err_delete_thread_state()\n&quot;);
         err_delete_thread_state();
     }
 
     if (locals-&gt;rand) {
-#ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_thread_stop: &quot;
-                        &quot;drbg_delete_thread_state()\n&quot;);
-#endif
+        OSSL_TRACE(INIT, &quot;drbg_delete_thread_state()\n&quot;);
         drbg_delete_thread_state();
     }
 
@@ -492,26 +441,23 @@ int ossl_init_thread_start(uint64_t opts)
         return 0;
 
     if (opts &amp; OPENSSL_INIT_THREAD_ASYNC) {
-#ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_thread_start: &quot;
-                        &quot;marking thread for async\n&quot;);
-#endif
+        OSSL_TRACE(INIT,
+                   &quot;ossl_init_thread_start: &quot;
+                   &quot;marking thread for async\n&quot;);
         locals-&gt;async = 1;
     }
 
     if (opts &amp; OPENSSL_INIT_THREAD_ERR_STATE) {
-#ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_thread_start: &quot;
-                        &quot;marking thread for err_state\n&quot;);
-#endif
+        OSSL_TRACE(INIT,
+                   &quot;ossl_init_thread_start: &quot;
+                   &quot;marking thread for err_state\n&quot;);
         locals-&gt;err_state = 1;
     }
 
     if (opts &amp; OPENSSL_INIT_THREAD_RAND) {
-#ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_thread_start: &quot;
-                        &quot;marking thread for rand\n&quot;);
-#endif
+        OSSL_TRACE(INIT,
+                   &quot;ossl_init_thread_start: &quot;
+                   &quot;marking thread for rand\n&quot;);
         locals-&gt;rand = 1;
     }
 
@@ -557,27 +503,18 @@ void OPENSSL_cleanup(void)
 
 #ifndef OPENSSL_NO_COMP
     if (zlib_inited) {
-#ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                        &quot;comp_zlib_cleanup_int()\n&quot;);
-#endif
+        OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: comp_zlib_cleanup_int()\n&quot;);
         comp_zlib_cleanup_int();
     }
 #endif
 
     if (async_inited) {
-# ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                        &quot;async_deinit()\n&quot;);
-# endif
+        OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: async_deinit()\n&quot;);
         async_deinit();
     }
 
     if (load_crypto_strings_inited) {
-#ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                        &quot;err_free_strings_int()\n&quot;);
-#endif
+        OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: err_free_strings_int()\n&quot;);
         err_free_strings_int();
     }
 
@@ -585,28 +522,6 @@ void OPENSSL_cleanup(void)
     destructor_key.sane = -1;
     CRYPTO_THREAD_cleanup_local(&amp;key);
 
-#ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                    &quot;rand_cleanup_int()\n&quot;);
-    fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                    &quot;conf_modules_free_int()\n&quot;);
-#ifndef OPENSSL_NO_ENGINE
-    fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                    &quot;engine_cleanup_int()\n&quot;);
-#endif
-    fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                    &quot;crypto_cleanup_all_ex_data_int()\n&quot;);
-    fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                    &quot;bio_sock_cleanup_int()\n&quot;);
-    fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                    &quot;bio_cleanup()\n&quot;);
-    fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                    &quot;evp_cleanup_int()\n&quot;);
-    fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                    &quot;obj_cleanup_int()\n&quot;);
-    fprintf(stderr, &quot;OPENSSL_INIT: OPENSSL_cleanup: &quot;
-                    &quot;err_cleanup()\n&quot;);
-#endif
     /*
      * Note that cleanup order is important:
      * - rand_cleanup_int could call an ENGINE's RAND cleanup function so
@@ -618,21 +533,42 @@ void OPENSSL_cleanup(void)
      * - ENGINEs and additional EVP algorithms might use added OIDs names so
      * obj_cleanup_int() must be called last
      */
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: rand_cleanup_int()\n&quot;);
     rand_cleanup_int();
+
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: rand_drbg_cleanup_int()\n&quot;);
     rand_drbg_cleanup_int();
+
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: conf_modules_free_int()\n&quot;);
     conf_modules_free_int();
 #ifndef OPENSSL_NO_ENGINE
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: engine_cleanup_int()\n&quot;);
     engine_cleanup_int();
 #endif
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: ossl_store_cleanup_int()\n&quot;);
     ossl_store_cleanup_int();
+
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: crypto_cleanup_all_ex_data_int()\n&quot;);
     crypto_cleanup_all_ex_data_int();
+
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: bio_cleanup()\n&quot;);
     bio_cleanup();
+
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: evp_cleanup_int()\n&quot;);
     evp_cleanup_int();
+
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: obj_cleanup_int()\n&quot;);
     obj_cleanup_int();
+
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: err_int()\n&quot;);
     err_cleanup();
 
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: CRYPTO_secure_malloc_done()\n&quot;);
     CRYPTO_secure_malloc_done();
 
+    OSSL_TRACE(INIT, &quot;OPENSSL_cleanup: ossl_trace_cleanup()\n&quot;);
+    ossl_trace_cleanup();
+
     base_inited = 0;
 }
 
@@ -835,12 +771,10 @@ int OPENSSL_atexit(void (*handler)(void))
 
             ERR_set_mark();
             dso = DSO_dsobyaddr(handlersym.sym, DSO_FLAG_NO_UNLOAD_ON_FREE);
-#  ifdef OPENSSL_INIT_DEBUG
-            fprintf(stderr,
-                    &quot;OPENSSL_INIT: OPENSSL_atexit: obtained DSO reference? %s\n&quot;,
-                    (dso == NULL ? &quot;No!&quot; : &quot;Yes.&quot;));
             /* See same code above in ossl_init_base() for an explanation. */
-#  endif
+            OSSL_TRACE1(INIT,
+                       &quot;atexit: obtained DSO reference? %s\n&quot;,
+                       (dso == NULL ? &quot;No!&quot; : &quot;Yes.&quot;));
             DSO_free(dso);
             ERR_pop_to_mark();
         }
diff --git a/crypto/pkcs12/p12_decr.c b/crypto/pkcs12/p12_decr.c
index 67a9305..b9d13d9 100644
--- a/crypto/pkcs12/p12_decr.c
+++ b/crypto/pkcs12/p12_decr.c
@@ -10,11 +10,7 @@
 #include &lt;stdio.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/pkcs12.h&gt;
-
-/* Define this to dump decrypted output to files called DERnnn */
-/*
- * #define OPENSSL_DEBUG_DECRYPT
- */
+#include &lt;openssl/trace.h&gt;
 
 /*
  * Encrypt/Decrypt a buffer based on password and algor, result in a
@@ -95,18 +91,11 @@ void *PKCS12_item_decrypt_d2i(const X509_ALGOR *algor, const ASN1_ITEM *it,
         return NULL;
     }
     p = out;
-#ifdef OPENSSL_DEBUG_DECRYPT
-    {
-        FILE *op;
-
-        char fname[30];
-        static int fnm = 1;
-        sprintf(fname, &quot;DER%d&quot;, fnm++);
-        op = fopen(fname, &quot;wb&quot;);
-        fwrite(p, 1, outlen, op);
-        fclose(op);
-    }
-#endif
+    OSSL_TRACE_BEGIN(PKCS12_DECRYPT) {
+        BIO_printf(trc_out, &quot;\n&quot;);
+        BIO_dump(trc_out, out, outlen);
+        BIO_printf(trc_out, &quot;\n&quot;);
+    } OSSL_TRACE_END(PKCS12_DECRYPT);
     ret = ASN1_item_d2i(NULL, &amp;p, outlen, it);
     if (zbuf)
         OPENSSL_cleanse(out, outlen);
diff --git a/crypto/pkcs12/p12_key.c b/crypto/pkcs12/p12_key.c
index 9e9fb17..3580754 100644
--- a/crypto/pkcs12/p12_key.c
+++ b/crypto/pkcs12/p12_key.c
@@ -11,16 +11,7 @@
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/pkcs12.h&gt;
 #include &lt;openssl/bn.h&gt;
-
-/* Uncomment out this line to get debugging info about key generation */
-/*
- * #define OPENSSL_DEBUG_KEYGEN
- */
-#ifdef OPENSSL_DEBUG_KEYGEN
-# include &lt;openssl/bio.h&gt;
-extern BIO *bio_err;
-void h__dump(unsigned char *p, int len);
-#endif
+#include &lt;openssl/trace.h&gt;
 
 /* PKCS12 compatible key/IV generation */
 #ifndef min
@@ -82,23 +73,22 @@ int PKCS12_key_gen_uni(unsigned char *pass, int passlen, unsigned char *salt,
     int i, j, u, v;
     int ret = 0;
     EVP_MD_CTX *ctx = NULL;
-#ifdef  OPENSSL_DEBUG_KEYGEN
     unsigned char *tmpout = out;
     int tmpn = n;
-#endif
 
     ctx = EVP_MD_CTX_new();
     if (ctx == NULL)
         goto err;
 
-#ifdef  OPENSSL_DEBUG_KEYGEN
-    fprintf(stderr, &quot;KEYGEN DEBUG\n&quot;);
-    fprintf(stderr, &quot;ID %d, ITER %d\n&quot;, id, iter);
-    fprintf(stderr, &quot;Password (length %d):\n&quot;, passlen);
-    h__dump(pass, passlen);
-    fprintf(stderr, &quot;Salt (length %d):\n&quot;, saltlen);
-    h__dump(salt, saltlen);
-#endif
+    OSSL_TRACE_BEGIN(PKCS12_KEYGEN) {
+        BIO_printf(trc_out, &quot;PKCS12_key_gen_uni(): ID %d, ITER %d\n&quot;, id, iter);
+        BIO_printf(trc_out, &quot;Password (length %d):\n&quot;, passlen);
+        BIO_hex_string(trc_out, 0, passlen, pass, passlen);
+        BIO_printf(trc_out, &quot;\n&quot;);
+        BIO_printf(trc_out, &quot;Salt (length %d):\n&quot;, saltlen);
+        BIO_hex_string(trc_out, 0, saltlen, salt, saltlen);
+        BIO_printf(trc_out, &quot;\n&quot;);
+    } OSSL_TRACE_END(PKCS12_KEYGEN);
     v = EVP_MD_block_size(md_type);
     u = EVP_MD_size(md_type);
     if (u &lt; 0 || v &lt;= 0)
@@ -136,10 +126,11 @@ int PKCS12_key_gen_uni(unsigned char *pass, int passlen, unsigned char *salt,
         }
         memcpy(out, Ai, min(n, u));
         if (u &gt;= n) {
-#ifdef OPENSSL_DEBUG_KEYGEN
-            fprintf(stderr, &quot;Output KEY (length %d)\n&quot;, tmpn);
-            h__dump(tmpout, tmpn);
-#endif
+            OSSL_TRACE_BEGIN(PKCS12_KEYGEN) {
+                BIO_printf(trc_out, &quot;Output KEY (length %d)\n&quot;, tmpn);
+                BIO_hex_string(trc_out, 0, tmpn, tmpout, tmpn);
+                BIO_printf(trc_out, &quot;\n&quot;);
+            } OSSL_TRACE_END(PKCS12_KEYGEN);
             ret = 1;
             goto end;
         }
@@ -172,12 +163,3 @@ int PKCS12_key_gen_uni(unsigned char *pass, int passlen, unsigned char *salt,
     EVP_MD_CTX_free(ctx);
     return ret;
 }
-
-#ifdef OPENSSL_DEBUG_KEYGEN
-void h__dump(unsigned char *p, int len)
-{
-    for (; len--; p++)
-        fprintf(stderr, &quot;%02X&quot;, *p);
-    fprintf(stderr, &quot;\n&quot;);
-}
-#endif
diff --git a/crypto/trace.c b/crypto/trace.c
new file mode 100644
index 0000000..8ead944
--- /dev/null
+++ b/crypto/trace.c
@@ -0,0 +1,495 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;openssl/bio.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &lt;openssl/trace.h&gt;
+#include &quot;internal/bio.h&quot;
+#include &quot;internal/nelem.h&quot;
+#include &quot;internal/cryptlib_int.h&quot;
+
+#include &quot;e_os.h&quot;                /* strcasecmp for Windows */
+
+#ifndef OPENSSL_NO_TRACE
+
+static CRYPTO_RWLOCK *trace_lock = NULL;
+
+static const BIO  *current_channel = NULL;
+
+/*-
+ * INTERNAL TRACE CHANNEL IMPLEMENTATION
+ *
+ * For our own flexibility, all trace categories are associated with a
+ * BIO sink object, also called the trace channel. Instead of a BIO object,
+ * the application can also provide a callback function, in which case an
+ * internal trace channel is attached, which simply calls the registered
+ * callback function.
+ */
+static int trace_write(BIO *b, const char *buf,
+                               size_t num, size_t *written);
+static int trace_puts(BIO *b, const char *str);
+static long trace_ctrl(BIO *channel, int cmd, long argl, void *argp);
+static int trace_free(BIO *b);
+
+static const BIO_METHOD trace_method = {
+    BIO_TYPE_SOURCE_SINK,
+    &quot;trace&quot;,
+    trace_write,
+    NULL,                        /* old write */
+    NULL,                        /* read_ex */
+    NULL,                        /* read */
+    trace_puts,
+    NULL,                        /* gets */
+    trace_ctrl,                  /* ctrl */
+    NULL,                        /* create */
+    trace_free,                  /* free */
+    NULL,                        /* callback_ctrl */
+};
+
+struct trace_data_st {
+    OSSL_trace_cb callback;
+    int category;
+    void *data;
+};
+
+static int trace_write(BIO *channel,
+                       const char *buf, size_t num, size_t *written)
+{
+    struct trace_data_st *ctx = BIO_get_data(channel);
+    size_t cnt = ctx-&gt;callback(buf, num, ctx-&gt;category, OSSL_TRACE_CTRL_DURING,
+                               ctx-&gt;data);
+
+    *written = cnt;
+    return cnt != 0;
+}
+
+static int trace_puts(BIO *channel, const char *str)
+{
+    size_t written;
+
+    if (trace_write(channel, str, strlen(str), &amp;written))
+        return (int)written;
+
+    return EOF;
+}
+
+static long trace_ctrl(BIO *channel, int cmd, long argl, void *argp)
+{
+    struct trace_data_st *ctx = BIO_get_data(channel);
+
+    switch (cmd) {
+    case OSSL_TRACE_CTRL_BEGIN:
+    case OSSL_TRACE_CTRL_END:
+        /* We know that the callback is likely to return 0 here */
+        ctx-&gt;callback(&quot;&quot;, 0, ctx-&gt;category, cmd, ctx-&gt;data);
+        return 1;
+    default:
+        break;
+    }
+    return -2;                   /* Unsupported */
+}
+
+static int trace_free(BIO *channel)
+{
+    if (channel == NULL)
+        return 0;
+    OPENSSL_free(BIO_get_data(channel));
+    return 1;
+}
+#endif
+
+/*-
+ * TRACE
+ */
+
+/* Helper struct and macro to get name string to number mapping */
+struct trace_category_st {
+    const char * const name;
+    const int num;
+};
+#define TRACE_CATEGORY_(name)       { #name, OSSL_TRACE_CATEGORY_##name }
+
+static const struct trace_category_st trace_categories[] = {
+    TRACE_CATEGORY_(ANY),
+    TRACE_CATEGORY_(TRACE),
+    TRACE_CATEGORY_(INIT),
+    TRACE_CATEGORY_(TLS),
+    TRACE_CATEGORY_(TLS_CIPHER),
+    TRACE_CATEGORY_(ENGINE_CONF),
+    TRACE_CATEGORY_(ENGINE_TABLE),
+    TRACE_CATEGORY_(ENGINE_REF_COUNT),
+    TRACE_CATEGORY_(PKCS5V2),
+    TRACE_CATEGORY_(PKCS12_KEYGEN),
+    TRACE_CATEGORY_(PKCS12_DECRYPT),
+    TRACE_CATEGORY_(X509V3_POLICY),
+    TRACE_CATEGORY_(BN_CTX),
+};
+
+const char *OSSL_trace_get_category_name(int num)
+{
+    size_t i;
+
+    for (i = 0; i &lt; OSSL_NELEM(trace_categories); i++)
+        if (trace_categories[i].num == num)
+            return trace_categories[i].name;
+    return NULL; /* not found */
+}
+
+int OSSL_trace_get_category_num(const char *name)
+{
+    size_t i;
+
+    for (i = 0; i &lt; OSSL_NELEM(trace_categories); i++)
+        if (strcasecmp(name, trace_categories[i].name) == 0)
+            return trace_categories[i].num;
+    return -1; /* not found */
+}
+
+#ifndef OPENSSL_NO_TRACE
+
+/* We use one trace channel for each trace category */
+static struct {
+    enum { t_channel, t_callback } type;
+    BIO *bio;
+    char *prefix;
+    char *suffix;
+} trace_channels[OSSL_TRACE_CATEGORY_NUM] = {
+    { 0, NULL, NULL, NULL },
+};
+
+#endif
+
+#ifndef OPENSSL_NO_TRACE
+static int trace_attach_cb(int category, int type, const void *data)
+{
+    switch (type) {
+    case 0:                      /* Channel */
+        OSSL_TRACE2(TRACE, &quot;Attach channel %p to category '%s'\n&quot;,
+                    data, trace_categories[category].name);
+        break;
+    case 1:                      /* Prefix */
+        OSSL_TRACE2(TRACE, &quot;Attach prefix \&quot;%s\&quot; to category '%s'\n&quot;,
+                    (const char *)data, trace_categories[category].name);
+        break;
+    case 2:                      /* Suffix */
+        OSSL_TRACE2(TRACE, &quot;Attach suffix \&quot;%s\&quot; to category '%s'\n&quot;,
+                    (const char *)data, trace_categories[category].name);
+        break;
+    default:                     /* No clue */
+        break;
+    }
+    return 1;
+}
+
+static int trace_detach_cb(int category, int type, const void *data)
+{
+    switch (type) {
+    case 0:                      /* Channel */
+        OSSL_TRACE2(TRACE, &quot;Detach channel %p from category '%s'\n&quot;,
+                    data, trace_categories[category].name);
+        break;
+    case 1:                      /* Prefix */
+        OSSL_TRACE2(TRACE, &quot;Detach prefix \&quot;%s\&quot; from category '%s'\n&quot;,
+                    (const char *)data, trace_categories[category].name);
+        break;
+    case 2:                      /* Suffix */
+        OSSL_TRACE2(TRACE, &quot;Detach suffix \&quot;%s\&quot; from category '%s'\n&quot;,
+                    (const char *)data, trace_categories[category].name);
+        break;
+    default:                     /* No clue */
+        break;
+    }
+    return 1;
+}
+
+static int set_trace_data(int category, BIO **channel,
+                          const char **prefix, const char **suffix,
+                          int (*attach_cb)(int, int, const void *),
+                          int (*detach_cb)(int, int, const void *))
+{
+    BIO *curr_channel = trace_channels[category].bio;
+    char *curr_prefix = trace_channels[category].prefix;
+    char *curr_suffix = trace_channels[category].suffix;
+
+    /* Make sure to run the detach callback first on all data */
+    if (prefix != NULL &amp;&amp; curr_prefix != NULL) {
+        detach_cb(category, 1, curr_prefix);
+    }
+
+    if (suffix != NULL &amp;&amp; curr_suffix != NULL) {
+        detach_cb(category, 2, curr_suffix);
+    }
+
+    if (channel != NULL &amp;&amp; curr_channel != NULL) {
+        detach_cb(category, 0, curr_channel);
+    }
+
+    /* After detach callbacks are done, clear data where appropriate */
+    if (prefix != NULL &amp;&amp; curr_prefix != NULL) {
+        OPENSSL_free(curr_prefix);
+        trace_channels[category].prefix = NULL;
+    }
+
+    if (suffix != NULL &amp;&amp; curr_suffix != NULL) {
+        OPENSSL_free(curr_suffix);
+        trace_channels[category].suffix = NULL;
+    }
+
+    if (channel != NULL &amp;&amp; curr_channel != NULL) {
+        BIO_free(curr_channel);
+        trace_channels[category].bio = NULL;
+    }
+
+    /* Before running callbacks are done, set new data where appropriate */
+    if (channel != NULL &amp;&amp; *channel != NULL) {
+        trace_channels[category].bio = *channel;
+    }
+
+    if (prefix != NULL &amp;&amp; *prefix != NULL) {
+        if ((curr_prefix = OPENSSL_strdup(*prefix)) == NULL)
+            return 0;
+        trace_channels[category].prefix = curr_prefix;
+    }
+
+    if (suffix != NULL &amp;&amp; *suffix != NULL) {
+        if ((curr_suffix = OPENSSL_strdup(*suffix)) == NULL)
+            return 0;
+        trace_channels[category].suffix = curr_suffix;
+    }
+
+    /* Finally, run the attach callback on the new data */
+    if (channel != NULL &amp;&amp; *channel != NULL) {
+        attach_cb(category, 0, *channel);
+    }
+
+    if (prefix != NULL &amp;&amp; *prefix != NULL) {
+        attach_cb(category, 1, *prefix);
+    }
+
+    if (suffix != NULL &amp;&amp; *suffix != NULL) {
+        attach_cb(category, 2, *suffix);
+    }
+
+    return 1;
+}
+#endif
+
+int ossl_trace_init(void)
+{
+#ifndef OPENSSL_NO_TRACE
+    trace_lock = CRYPTO_THREAD_lock_new();
+    if (trace_lock != NULL)
+        return 1;
+#endif
+
+    return 0;
+}
+
+void ossl_trace_cleanup(void)
+{
+#ifndef OPENSSL_NO_TRACE
+    int category;
+    BIO *channel = NULL;
+    const char *prefix = NULL;
+    const char *suffix = NULL;
+
+    for (category = 0; category &lt; OSSL_TRACE_CATEGORY_NUM; category++) {
+        /* We force the TRACE category to be treated last */
+        if (category == OSSL_TRACE_CATEGORY_TRACE)
+            continue;
+        set_trace_data(category, &amp;channel, &amp;prefix, &amp;suffix,
+                       trace_attach_cb, trace_detach_cb);
+    }
+    set_trace_data(OSSL_TRACE_CATEGORY_TRACE, &amp;channel, &amp;prefix, &amp;suffix,
+                   trace_attach_cb, trace_detach_cb);
+    CRYPTO_THREAD_lock_free(trace_lock);
+#endif
+}
+
+int OSSL_trace_set_channel(int category, BIO *channel)
+{
+#ifndef OPENSSL_NO_TRACE
+    if (category &lt; 0 || category &gt;= OSSL_TRACE_CATEGORY_NUM
+        || !set_trace_data(category, &amp;channel, NULL, NULL,
+                           trace_attach_cb, trace_detach_cb))
+        goto err;
+
+    trace_channels[category].type = t_channel;
+    return 1;
+
+ err:
+#endif
+
+    return 0;
+}
+
+#ifndef OPENSSL_NO_TRACE
+static int trace_attach_w_callback_cb(int category, int type, const void *data)
+{
+    switch (type) {
+    case 0:                      /* Channel */
+        OSSL_TRACE2(TRACE,
+                    &quot;Attach channel %p to category '%s' (with callback)\n&quot;,
+                    data, trace_categories[category].name);
+        break;
+    case 1:                      /* Prefix */
+        OSSL_TRACE2(TRACE, &quot;Attach prefix \&quot;%s\&quot; to category '%s'\n&quot;,
+                    (const char *)data, trace_categories[category].name);
+        break;
+    case 2:                      /* Suffix */
+        OSSL_TRACE2(TRACE, &quot;Attach suffix \&quot;%s\&quot; to category '%s'\n&quot;,
+                    (const char *)data, trace_categories[category].name);
+        break;
+    default:                     /* No clue */
+        break;
+    }
+    return 1;
+}
+#endif
+
+int OSSL_trace_set_callback(int category, OSSL_trace_cb callback, void *data)
+{
+#ifndef OPENSSL_NO_TRACE
+    BIO *channel = NULL;
+    struct trace_data_st *trace_data = NULL;
+
+    if (category &lt; 0 || category &gt;= OSSL_TRACE_CATEGORY_NUM)
+        goto err;
+
+    if (callback != NULL) {
+        if ((channel = BIO_new(&amp;trace_method)) == NULL
+            || (trace_data =
+                OPENSSL_zalloc(sizeof(struct trace_data_st))) == NULL)
+            goto err;
+
+        trace_data-&gt;callback = callback;
+        trace_data-&gt;category = category;
+        trace_data-&gt;data = data;
+
+        BIO_set_data(channel, trace_data);
+    }
+
+    if (!set_trace_data(category, &amp;channel, NULL, NULL,
+                        trace_attach_w_callback_cb, trace_detach_cb))
+        goto err;
+
+    trace_channels[category].type = t_callback;
+    return 1;
+
+ err:
+    BIO_free(channel);
+    OPENSSL_free(trace_data);
+#endif
+
+    return 0;
+}
+
+int OSSL_trace_set_prefix(int category, const char *prefix)
+{
+#ifndef OPENSSL_NO_TRACE
+    if (category &gt;= 0 || category &lt; OSSL_TRACE_CATEGORY_NUM)
+        return set_trace_data(category, NULL, &amp;prefix, NULL,
+                              trace_attach_cb, trace_detach_cb);
+#endif
+
+    return 0;
+}
+
+int OSSL_trace_set_suffix(int category, const char *suffix)
+{
+#ifndef OPENSSL_NO_TRACE
+    if (category &gt;= 0 || category &lt; OSSL_TRACE_CATEGORY_NUM)
+        return set_trace_data(category, NULL, NULL, &amp;suffix,
+                              trace_attach_cb, trace_detach_cb);
+#endif
+
+    return 0;
+}
+
+#ifndef OPENSSL_NO_TRACE
+static int ossl_trace_get_category(int category)
+{
+    if (category &lt; 0 || category &gt;= OSSL_TRACE_CATEGORY_NUM)
+        return -1;
+    if (trace_channels[category].bio != NULL)
+        return category;
+    return OSSL_TRACE_CATEGORY_ANY;
+}
+#endif
+
+int OSSL_trace_enabled(int category)
+{
+    int ret = 0;
+#ifndef OPENSSL_NO_TRACE
+    category = ossl_trace_get_category(category);
+    ret = trace_channels[category].bio != NULL;
+#endif
+    return ret;
+}
+
+BIO *OSSL_trace_begin(int category)
+{
+    BIO *channel = NULL;
+#ifndef OPENSSL_NO_TRACE
+    char *prefix = NULL;
+
+    category = ossl_trace_get_category(category);
+    channel = trace_channels[category].bio;
+    prefix = trace_channels[category].prefix;
+
+    if (channel != NULL) {
+        CRYPTO_THREAD_write_lock(trace_lock);
+        current_channel = channel;
+        switch (trace_channels[category].type) {
+        case t_channel:
+            if (prefix != NULL) {
+                (void)BIO_puts(channel, prefix);
+                (void)BIO_puts(channel, &quot;\n&quot;);
+            }
+            break;
+        case t_callback:
+            (void)BIO_ctrl(channel, OSSL_TRACE_CTRL_BEGIN,
+                           prefix == NULL ? 0 : strlen(prefix), prefix);
+            break;
+        }
+    }
+#endif
+    return channel;
+}
+
+void OSSL_trace_end(int category, BIO * channel)
+{
+#ifndef OPENSSL_NO_TRACE
+    char *suffix = NULL;
+
+    category = ossl_trace_get_category(category);
+    suffix = trace_channels[category].suffix;
+    if (channel != NULL
+        &amp;&amp; ossl_assert(channel == current_channel)) {
+        (void)BIO_flush(channel);
+        switch (trace_channels[category].type) {
+        case t_channel:
+            if (suffix != NULL) {
+                (void)BIO_puts(channel, suffix);
+                (void)BIO_puts(channel, &quot;\n&quot;);
+            }
+            break;
+        case t_callback:
+            (void)BIO_ctrl(channel, OSSL_TRACE_CTRL_END,
+                           suffix == NULL ? 0 : strlen(suffix), suffix);
+            break;
+        }
+        current_channel = NULL;
+        CRYPTO_THREAD_unlock(trace_lock);
+    }
+#endif
+}
diff --git a/crypto/x509v3/pcy_tree.c b/crypto/x509v3/pcy_tree.c
index 860e4bf..0c5887c 100644
--- a/crypto/x509v3/pcy_tree.c
+++ b/crypto/x509v3/pcy_tree.c
@@ -8,76 +8,71 @@
  */
 
 #include &quot;internal/cryptlib.h&quot;
+#include &lt;openssl/trace.h&gt;
 #include &lt;openssl/x509.h&gt;
 #include &lt;openssl/x509v3.h&gt;
 
 #include &quot;pcy_int.h&quot;
 
-/*
- * Enable this to print out the complete policy tree at various point during
- * evaluation.
- */
-
-/*
- * #define OPENSSL_POLICY_DEBUG
- */
-
-#ifdef OPENSSL_POLICY_DEBUG
-
-static void expected_print(BIO *err, X509_POLICY_LEVEL *lev,
-                           X509_POLICY_NODE *node, int indent)
+static void expected_print(BIO *channel,
+                           X509_POLICY_LEVEL *lev, X509_POLICY_NODE *node,
+                           int indent)
 {
     if ((lev-&gt;flags &amp; X509_V_FLAG_INHIBIT_MAP)
         || !(node-&gt;data-&gt;flags &amp; POLICY_DATA_FLAG_MAP_MASK))
-        BIO_puts(err, &quot;  Not Mapped\n&quot;);
+        BIO_puts(channel, &quot;  Not Mapped\n&quot;);
     else {
         int i;
+
         STACK_OF(ASN1_OBJECT) *pset = node-&gt;data-&gt;expected_policy_set;
         ASN1_OBJECT *oid;
-        BIO_puts(err, &quot;  Expected: &quot;);
+        BIO_puts(channel, &quot;  Expected: &quot;);
         for (i = 0; i &lt; sk_ASN1_OBJECT_num(pset); i++) {
             oid = sk_ASN1_OBJECT_value(pset, i);
             if (i)
-                BIO_puts(err, &quot;, &quot;);
-            i2a_ASN1_OBJECT(err, oid);
+                BIO_puts(channel, &quot;, &quot;);
+            i2a_ASN1_OBJECT(channel, oid);
         }
-        BIO_puts(err, &quot;\n&quot;);
+        BIO_puts(channel, &quot;\n&quot;);
     }
 }
 
-static void tree_print(char *str, X509_POLICY_TREE *tree,
+static void tree_print(BIO *channel,
+                       char *str, X509_POLICY_TREE *tree,
                        X509_POLICY_LEVEL *curr)
 {
-    BIO *err = BIO_new_fp(stderr, BIO_NOCLOSE);
     X509_POLICY_LEVEL *plev;
 
-    if (err == NULL)
-        return;
     if (!curr)
         curr = tree-&gt;levels + tree-&gt;nlevel;
     else
         curr++;
 
-    BIO_printf(err, &quot;Level print after %s\n&quot;, str);
-    BIO_printf(err, &quot;Printing Up to Level %ld\n&quot;, curr - tree-&gt;levels);
+    BIO_printf(channel, &quot;Level print after %s\n&quot;, str);
+    BIO_printf(channel, &quot;Printing Up to Level %ld\n&quot;,
+               curr - tree-&gt;levels);
     for (plev = tree-&gt;levels; plev != curr; plev++) {
         int i;
 
-        BIO_printf(err, &quot;Level %ld, flags = %x\n&quot;,
+        BIO_printf(channel, &quot;Level %ld, flags = %x\n&quot;,
                    (long)(plev - tree-&gt;levels), plev-&gt;flags);
         for (i = 0; i &lt; sk_X509_POLICY_NODE_num(plev-&gt;nodes); i++) {
-            X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(plev-&gt;nodes, i);
+            X509_POLICY_NODE *node =
+                sk_X509_POLICY_NODE_value(plev-&gt;nodes, i);
 
-            X509_POLICY_NODE_print(err, node, 2);
-            expected_print(err, plev, node, 2);
-            BIO_printf(err, &quot;  Flags: %x\n&quot;, node-&gt;data-&gt;flags);
+            X509_POLICY_NODE_print(channel, node, 2);
+            expected_print(channel, plev, node, 2);
+            BIO_printf(channel, &quot;  Flags: %x\n&quot;, node-&gt;data-&gt;flags);
         }
         if (plev-&gt;anyPolicy)
-            X509_POLICY_NODE_print(err, plev-&gt;anyPolicy, 2);
+            X509_POLICY_NODE_print(channel, plev-&gt;anyPolicy, 2);
     }
-    BIO_free(err);
 }
-#endif
+
+#define TREE_PRINT(str, tree, curr) \
+    OSSL_TRACE_BEGIN(X509V3_POLICY) { \
+        tree_print(trc_out, &quot;before tree_prune()&quot;, tree, curr); \
+    } OSSL_TRACE_END(X509V3_POLICY)
 
 /*-
  * Return value: &lt;= 0 on error, or positive bit mask:
@@ -588,9 +583,7 @@ static int tree_evaluate(X509_POLICY_TREE *tree)
         if (!(curr-&gt;flags &amp; X509_V_FLAG_INHIBIT_ANY)
             &amp;&amp; !tree_link_any(curr, cache, tree))
             return X509_PCY_TREE_INTERNAL;
-#ifdef OPENSSL_POLICY_DEBUG
-        tree_print(&quot;before tree_prune()&quot;, tree, curr);
-#endif
+        TREE_PRINT(&quot;before tree_prune()&quot;, tree, curr);
         ret = tree_prune(tree, curr);
         if (ret != X509_PCY_TREE_VALID)
             return ret;
@@ -665,9 +658,7 @@ int X509_policy_check(X509_POLICY_TREE **ptree, int *pexplicit_policy,
     }
 
     ret = tree_evaluate(tree);
-#ifdef OPENSSL_POLICY_DEBUG
-    tree_print(&quot;tree_evaluate()&quot;, tree, NULL);
-#endif
+    TREE_PRINT(&quot;tree_evaluate()&quot;, tree, NULL);
     if (ret &lt;= 0)
         goto error;
 
diff --git a/doc/man1/openssl.pod b/doc/man1/openssl.pod
index a2002d4..ca4f78c 100644
--- a/doc/man1/openssl.pod
+++ b/doc/man1/openssl.pod
@@ -531,6 +531,74 @@ Read the password from standard input.
 
 =back
 
+=head1 ENVIRONMENT
+
+=over 4
+
+=item B&lt;OPENSSL_TRACE=&gt;I&lt;name,...&gt;
+
+Enable tracing output of OpenSSL library, by name.
+This output will only make sense if you know OpenSSL internals well.
+Also, it might not give you any output at all, depending on how
+OpenSSL was built.
+
+The value is a comma separated list of names, with the following
+available:
+
+=over 4
+
+=item B&lt;TRACE&gt;
+
+The tracing functionality.
+
+=item B&lt;TLS&gt;
+
+General SSL/TLS.
+
+=item B&lt;TLS_CIPHER&gt;
+
+SSL/TLS cipher.
+
+=item B&lt;ENGINE_CONF&gt;
+
+ENGINE configuration.
+
+=item B&lt;ENGINE_TABLE&gt;
+
+The function that is used by RSA, DSA (etc) code to select registered
+ENGINEs, cache defaults and functional references (etc), will generate
+debugging summaries.
+
+=item B&lt;ENGINE_REF_COUNT&gt;
+
+Reference counts in the ENGINE structure will be monitored with a line
+of generated for each change.
+
+=item B&lt;PKCS5V2&gt;
+
+PKCS#5 v2 keygen.
+
+=item B&lt;PKCS12_KEYGEN&gt;
+
+PKCS#12 key generation.
+
+=item B&lt;PKCS12_DECRYPT&gt;
+
+PKCS#12 decryption.
+
+=item B&lt;X509V3_POLICY&gt;
+
+Generates the complete policy tree at various point during X.509 v3
+policy evaluation.
+
+=item B&lt;BN_CTX&gt;
+
+BIGNUM context.
+
+=back
+
+=back
+
 =head1 SEE ALSO
 
 L&lt;asn1parse(1)&gt;, L&lt;ca(1)&gt;, L&lt;ciphers(1)&gt;, L&lt;cms(1)&gt;, L&lt;config(5)&gt;,
diff --git a/doc/man3/OSSL_trace_enabled.pod b/doc/man3/OSSL_trace_enabled.pod
new file mode 100644
index 0000000..ecb88ab
--- /dev/null
+++ b/doc/man3/OSSL_trace_enabled.pod
@@ -0,0 +1,183 @@
+=pod
+
+=head1 NAME
+
+OSSL_trace_enabled, OSSL_trace_begin, OSSL_trace_end
+- OpenSSL Tracing API
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/trace.h&gt;
+
+ int OSSL_trace_enabled(int category);
+
+ BIO *OSSL_trace_begin(int category);
+ void OSSL_trace_end(int category, BIO *channel);
+
+=head1 DESCRIPTION
+
+The functions described here are mainly interesting for those who provide
+OpenSSL functionality, either in OpenSSL itself or in engine modules
+or similar.
+
+If operational (see L&lt;/NOTES&gt; below), these functions are used to
+generate free text tracing output.
+
+The tracing output is divided into types which are enabled
+individually by the application.
+The tracing types are described in detail in
+L&lt;OSSL_trace_set_callback(3)/Trace types&gt;.
+The fallback type C&lt;OSSL_TRACE_CATEGORY_ANY&gt; should I&lt;not&gt; be used
+with the functions described here.
+
+=head2 Functions
+
+OSSL_trace_enabled() can be used to check if tracing for the given
+C&lt;category&gt; is enabled.
+
+OSSL_trace_begin() is used to starts a tracing section, and get the
+channel for the given C&lt;category&gt; in form of a BIO.
+This BIO can only be used for output.
+
+OSSL_trace_end() is used to end a tracing section.
+
+Using OSSL_trace_begin() and OSSL_trace_end() to wrap tracing sections
+is I&lt;mandatory&gt;.
+The result of trying to produce tracing output outside of such
+sections is undefined.
+
+=head2 Convenience Macros
+
+There are a number of convenience macros defined, to make tracing
+easy and consistent.
+
+C&lt;OSSL_TRACE_BEGIN(category)&gt; and C&lt;OSSL_TRACE_END(category)&gt; reserve
+the B&lt;BIO&gt; C&lt;trc_out&gt; and are used as follows to wrap a trace section:
+
+ OSSL_TRACE_BEGIN(TLS) {
+
+     BIO_fprintf(trc_out, ... );
+
+ } OSSL_TRACE_END(TLS);
+
+This will normally expands to:
+
+ do {
+     BIO *trc_out = OSSL_trace_begin(OSSL_TRACE_CATEGORY_TLS);
+     if (trc_out != NULL) {
+         ...
+         BIO_fprintf(trc_out, ...);
+     }
+     OSSL_trace_end(OSSL_TRACE_CATEGORY_TLS, trc_out);
+ } while (0);
+
+C&lt;OSSL_TRACE_CANCEL(category)&gt; must be used before returning from or
+jumping out of a trace section:
+
+ OSSL_TRACE_BEGIN(TLS) {
+
+     if (condition) {
+         OSSL_TRACE_CANCEL(TLS);
+         goto err;
+     }
+     BIO_fprintf(trc_out, ... );
+
+ } OSSL_TRACE_END(TLS);
+
+This will normally expand to:
+
+ do {
+     BIO *trc_out = OSSL_trace_begin(OSSL_TRACE_CATEGORY_TLS);
+     if (trc_out != NULL) {
+         if (condition) {
+             OSSL_trace_end(OSSL_TRACE_CATEGORY_TLS, trc_out);
+             goto err;
+         }
+         BIO_fprintf(trc_out, ... );
+     }
+     OSSL_trace_end(OSSL_TRACE_CATEGORY_TLS, trc_out);
+ } while (0);
+
+=head1 NOTES
+
+It is advisable to always check that a trace type is enabled with
+OSSL_trace_enabled() before generating any output, for example:
+
+    if (OSSL_trace_enabled(OSSL_TRACE_CATEGORY_TLS)) {
+        BIO *trace = OSSL_trace_begin(OSSL_TRACE_CATEGORY_TLS);
+        BIO_printf(trace, &quot;FOO %d\n&quot;, somevalue);
+        BIO_dump(trace, somememory, somememory_l);
+        OSSL_trace_end(OSSL_TRACE_CATEGORY_TLS, trace);
+    }
+
+=head2 Tracing disabled
+
+The OpenSSL library may be built with tracing disabled, which makes
+everything documented here inoperational.
+
+When the library is built with tracing disabled:
+
+=over 4
+
+=item *
+
+The macro C&lt;OPENSSL_NO_TRACE&gt; is defined in C&lt;openssl/opensslconf.h&gt;.
+
+=item *
+
+all functions are still present, bu OSSL_trace_enabled() will always
+report the categories as disabled, and all other functions will do
+nothing.
+
+=item *
+
+the convenience macros are defined to produce dead code.
+For example, take this example from L&lt;/Convenience Macros&gt; above:
+
+ OSSL_TRACE_BEGIN(TLS) {
+
+     if (condition) {
+         OSSL_TRACE_CANCEL(TLS);
+         goto err;
+     }
+     BIO_fprintf(trc_out, ... );
+
+ } OSSL_TRACE_END(TLS);
+
+When the tracing API isn't operational, that will expand to:
+
+ do {
+     BIO *trc_out = NULL;
+     if (0) {
+         if (condition) {
+             ((void)0);
+             goto err;
+         }
+         BIO_fprintf(trc_out, ... );
+     }
+ } while (0);
+
+=back
+
+=head1 RETURN VALUES
+
+OSSL_trace_enabled() returns 1 if tracing for the given B&lt;type&gt; is
+operational and enabled, otherwise 0.
+
+OSSL_trace_begin() returns a C&lt;BIO *&gt; if the given B&lt;type&gt; is enabled,
+otherwise C&lt;NULL&gt;.
+
+=head1 HISTORY
+
+The OpenSSL Tracing API was added ino OpenSSL 3.0.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man3/OSSL_trace_get_category_num.pod b/doc/man3/OSSL_trace_get_category_num.pod
new file mode 100644
index 0000000..886d0f1
--- /dev/null
+++ b/doc/man3/OSSL_trace_get_category_num.pod
@@ -0,0 +1,44 @@
+=pod
+
+=head1 NAME
+
+OSSL_trace_get_category_num, OSSL_trace_get_category_name
+- OpenSSL tracing information functions
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/trace.h&gt;
+
+ int OSSL_trace_get_category_num(const char *name);
+ const char *OSSL_trace_get_category_name(int num);
+
+=head1 DESCRIPTION
+
+OSSL_trace_get_category_num() gives the category number corresponding
+to the given C&lt;name&gt;.
+
+OSSL_trace_get_category_name() gives the category name corresponding
+to the given C&lt;num&gt;.
+
+=head1 RETURN VALUES
+
+OSSL_trace_get_category_num() returns the category number if the given
+C&lt;name&gt; is a recognised category name, otherwise -1.
+
+OSSL_trace_get_category_name() returns the category name if the given
+C&lt;num&gt; is a recognised category number, otherwise NULL.
+
+=head1 HISTORY
+
+The OpenSSL Tracing API was added ino OpenSSL 3.0.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/doc/man3/OSSL_trace_set_channel.pod b/doc/man3/OSSL_trace_set_channel.pod
new file mode 100644
index 0000000..6981dbc
--- /dev/null
+++ b/doc/man3/OSSL_trace_set_channel.pod
@@ -0,0 +1,288 @@
+=pod
+
+=head1 NAME
+
+OSSL_trace_set_channel, OSSL_trace_set_prefix, OSSL_trace_set_suffix,
+OSSL_trace_set_callback, OSSL_trace_cb - Enabling trace output
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/trace.h&gt;
+
+ typedef size_t (*OSSL_trace_cb)(const char *buf, size_t cnt,
+                                 int category, int cmd, void *data);
+
+ void OSSL_trace_set_channel(int category, BIO *bio);
+ void OSSL_trace_set_prefix(int category, const char *prefix);
+ void OSSL_trace_set_suffix(int category, const char *suffix);
+ void OSSL_trace_set_callback(int category, OSSL_trace_cb cb, void  *data);
+
+=head1 DESCRIPTION
+
+If available (see L&lt;/NOTES&gt; below), the application can request
+internal trace output.
+This output comes in form of free text for humans to read.
+
+The trace output is divided into categories which can be
+enabled individually.
+They are enabled by giving them a channel in form of a BIO, or a
+tracer callback, which is responsible for performing the actual
+output.
+
+=head2 Functions
+
+OSSL_trace_set_channel() is used to enable the given trace C&lt;category&gt;
+by giving it the B&lt;BIO&gt; C&lt;bio&gt;.
+
+OSSL_trace_set_prefix() and OSSL_trace_set_suffix() can be used to add
+an extra line for each channel, to be output before and after group of
+tracing output.
+What constitues an output group is decided by the code that produces
+the output.
+The lines given here are considered immutable; for more dynamic
+tracing prefixes, consider setting a callback with
+OSSL_trace_set_callback() instead.
+
+OSSL_trace_set_callback() is used to enable the given trace
+C&lt;category&gt; by giving it the tracer callback C&lt;cb&gt; with the associated
+data C&lt;data&gt;, which will simply be passed through to C&lt;cb&gt; whenever
+it's called.
+This should be used when it's desirable to do form the trace output to
+something suitable for application needs where a prefix and suffix
+line aren't enough.
+
+OSSL_trace_set_channel() and OSSL_trace_set_callback() are mutually
+exclusive, calling one of them will clear whatever was set by the
+previous call.
+
+Calling OSSL_trace_set_channel() with C&lt;NULL&gt; for C&lt;channel&gt; or
+OSSL_trace_set_callback() with C&lt;NULL&gt; for C&lt;cb&gt; disables tracing for
+the given C&lt;category&gt;
+
+=head2 Trace callback
+
+The tracer callback must return a C&lt;size_t&gt;, which must be zero on
+error and otherwise return the number of bytes that were output.
+It receives a text buffer C&lt;buf&gt; with C&lt;cnt&gt; bytes of text, as well as
+the C&lt;category&gt;, a control number C&lt;cmd&gt;, and the C&lt;data&gt; that was
+passed to OSSL_trace_set_callback().
+
+The possible control numbers are:
+
+=over 4
+
+=item C&lt;OSSL_TRACE_CTRL_BEGIN&gt;
+
+The callback is called from OSSL_trace_begin(), which gives the
+callback the possibility to output a dynamic starting line, or set a
+prefix that should be output at the beginning of each line, or
+something other.
+
+=item C&lt;OSSL_TRACE_CTRL_DURING&gt;
+
+The callback is called from any regular BIO output routine.
+
+=item C&lt;OSSL_TRACE_CTRL_END&gt;
+
+The callback is called from OSSL_trace_end(), which gives the callback
+the possibility to output a dynamic ending line, or reset the line
+prefix that was set with OSSL_TRACE_CTRL_BEGIN, or something other.
+
+=back
+
+=head2 Trace categories
+
+The trace categories are simple numbers available through macros.
+
+=over 4
+
+=item C&lt;OSSL_TRACE_CATEGORY_TRACE&gt;
+
+Traces the OpenSSL trace API itself.
+
+More precisely, this will generate trace output any time a new
+trace hook is set.
+
+=item C&lt;OSSL_TRACE_CATEGORY_INIT&gt;
+
+Traces OpenSSL library initialization and cleanup.
+
+This needs special care, as OpenSSL will do automatic cleanup after
+exit from C&lt;main()&gt;, and any tracing output done during this cleanup
+will be lost if the tracing channel or callback were cleaned away
+prematurely.
+A suggestion is to make such cleanup part of a function that's
+registered very early with L&lt;atexit(3)&gt;.
+
+=item C&lt;OSSL_TRACE_CATEGORY_TLS&gt;
+
+Traces the TLS/SSL protocoll.
+
+=item C&lt;OSSL_TRACE_CATEGORY_TLS_CIPHER&gt;
+
+Traces the ciphers used by the TLS/SSL protocoll.
+
+=item C&lt;OSSL_TRACE_CATEGORY_ENGINE_CONF&gt;
+
+Traces the ENGINE configuration.
+
+=item C&lt;OSSL_TRACE_CATEGORY_ENGINE_TABLE&gt;
+
+Traces the ENGINE algorithm table selection.
+
+More precisely, engine_table_select(), the function that is used by
+RSA, DSA (etc) code to select registered ENGINEs, cache defaults and
+functional references (etc), will generate trace summaries.
+
+=item C&lt;OSSL_TRACE_CATEGORY_ENGINE_REF_COUNT&gt;
+
+Tracds the ENGINE reference counting.
+
+More precisely, both reference counts in the ENGINE structure will be
+monitored with a line of trace output generated for each change.
+
+=item C&lt;OSSL_TRACE_CATEGORY_PKCS5V2&gt;
+
+Traces PKCS#5 v2 key generation.
+
+=item C&lt;OSSL_TRACE_CATEGORY_PKCS12_KEYGEN&gt;
+
+Traces PKCS#12 key generation.
+
+=item C&lt;OSSL_TRACE_CATEGORY_PKCS12_DECRYPT&gt;
+
+Traces PKCS#12 decryption.
+
+=item C&lt;OSSL_TRACE_CATEGORY_X509V3_POLICY&gt;
+
+Traces X509v3 policy processing.
+
+More precisely, this generates the complete policy tree at various
+point during evaluation.
+
+=item C&lt;OSSL_TRACE_CATEGORY_BN_CTX&gt;
+
+Traces BIGNUM context operations.
+
+=back
+
+There is also C&lt;OSSL_TRACE_CATEGORY_ANY&gt;, which works as a fallback
+and can be used to get I&lt;all&gt; trace output.
+
+=head1 RETURN VALUES
+
+OSSL_trace_set_channel(), OSSL_trace_set_prefix(),
+OSSL_trace_set_suffix(), and OSSL_trace_set_callback() return 1 on
+success, or 0 on failure.
+
+=head1 EXAMPLES
+
+In all examples below, we assume that the trace producing code is
+this:
+
+ int foo = 42;
+ const char bar[] = { 0,  1,  2,  3,  4,  5,  6,  7,
+                      8,  9, 10, 11, 12, 13, 14, 15 };
+
+ OSSL_TRACE_BEGIN(TLS) {
+     BIO_puts(trc_out, &quot;foo: &quot;);
+     BIO_printf(trc_out, &quot;%d\n&quot;, foo);
+     BIO_dump(trc_out, bar, sizeof(bar));
+ } OSSL_TRACE_END(TLS);
+
+=head1 Simple example
+
+An example with just a channel and constant prefix / suffix.
+
+ int main(int argc, char *argv[])
+ {
+     BIO *err = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);
+     OSSL_trace_set_channel(OSSL_TRACE_CATEGORY_SSL, err);
+     OSSL_trace_set_prefix(OSSL_TRACE_CATEGORY_SSL, &quot;BEGIN TRACE[TLS]&quot;);
+     OSSL_trace_set_suffix(OSSL_TRACE_CATEGORY_SSL, &quot;END TRACE[TLS]&quot;);
+
+     /* ... work ... */
+ }
+
+When the trace producing code above is performed, this will be output
+on standard error:
+
+ BEGIN TRACE[TLS]
+ foo: 42
+ 0000 - 00 01 02 03 04 05 06 07-08 09 0a 0b 0c 0d 0e 0f   ................
+ END TRACE[TLS]
+
+=head2 Advanced example
+
+This example uses the callback, and depends on pthreads functionality.
+
+ static size_t cb(const char *buf, size_t cnt,
+                 int category, int cmd, void *vdata)
+ {
+     BIO *bio = vdata;
+     const char *label = NULL;
+
+     switch (cmd) {
+     case OSSL_TRACE_CTRL_BEGIN:
+         label = &quot;BEGIN&quot;;
+         break;
+     case OSSL_TRACE_CTRL_END:
+         label = &quot;END&quot;;
+         break;
+     }
+
+     if (label != NULL) {
+         union {
+             pthread_t tid;
+             unsigned long ltid;
+         } tid;
+
+         tid.tid = pthread_self();
+         BIO_printf(bio, &quot;%s TRACE[%s]:%lx\n&quot;,
+                    label, OSSL_trace_get_category_name(category), tid.ltid);
+     }
+     return (size_t)BIO_puts(bio, buf);
+ }
+
+ int main(int argc, char *argv[])
+ {
+     BIO *err = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);
+     OSSL_trace_set_callback(OSSL_TRACE_CATEGORY_SSL, cb, err);
+
+     /* ... work ... */
+ }
+
+The output is almost the same as for the simple example above.
+
+ BEGIN TRACE[TLS]:7f9eb0193b80
+ foo: 42
+ 0000 - 00 01 02 03 04 05 06 07-08 09 0a 0b 0c 0d 0e 0f   ................
+ END TRACE[TLS]:7f9eb0193b80
+
+=head1 NOTES
+
+=head2 Tracing disabled
+
+The OpenSSL library may be built with tracing disabled, which makes
+everything documented here inoperational.
+
+When the library is built with tracing disabled, the macro
+C&lt;OPENSSL_NO_TRACE&gt; is defined in C&lt;openssl/opensslconf.h&gt; and all
+functions described here are inoperational, i.e. will do nothing.
+
+=head1 HISTORY
+
+OSSL_trace_set_channel(), OSSL_trace_set_prefix(),
+OSSL_trace_set_suffix(), and OSSL_trace_set_callback() were all added
+in OpenSSL 3.0.0.
+
+=head1 COPYRIGHT
+
+Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/include/openssl/trace.h b/include/openssl/trace.h
new file mode 100644
index 0000000..da0ba0b
--- /dev/null
+++ b/include/openssl/trace.h
@@ -0,0 +1,291 @@
+/*
+ * Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef OSSL_TRACE_H
+# define OSSL_TRACE_H
+
+# include &lt;stdarg.h&gt;
+
+# include &lt;openssl/bio.h&gt;
+
+# ifdef  __cplusplus
+extern &quot;C&quot; {
+# endif
+
+/*
+ * TRACE CATEGORIES
+ */
+
+/*
+ * The trace messages of the OpenSSL libraries are organized into different
+ * categories. For every trace category, the application can register a separate
+ * tracer callback. When a callback is registered, a so called trace channel is
+ * created for this category. This channel consists essentially of an internal
+ * BIO which sends all trace output it receives to the registered application
+ * callback.
+ *
+ * The ANY category is used as a fallback category.
+ */
+# define OSSL_TRACE_CATEGORY_ANY                 0 /* The fallback */
+# define OSSL_TRACE_CATEGORY_TRACE               1
+# define OSSL_TRACE_CATEGORY_INIT                2
+# define OSSL_TRACE_CATEGORY_TLS                 3
+# define OSSL_TRACE_CATEGORY_TLS_CIPHER          4
+# define OSSL_TRACE_CATEGORY_ENGINE_CONF         5
+# define OSSL_TRACE_CATEGORY_ENGINE_TABLE        6
+# define OSSL_TRACE_CATEGORY_ENGINE_REF_COUNT    7
+# define OSSL_TRACE_CATEGORY_PKCS5V2             8
+# define OSSL_TRACE_CATEGORY_PKCS12_KEYGEN       9
+# define OSSL_TRACE_CATEGORY_PKCS12_DECRYPT     10
+# define OSSL_TRACE_CATEGORY_X509V3_POLICY      11
+# define OSSL_TRACE_CATEGORY_BN_CTX             12
+# define OSSL_TRACE_CATEGORY_NUM                13
+
+/* Returns the trace category number for the given |name| */
+int OSSL_trace_get_category_num(const char *name);
+
+/* Returns the trace category name for the given |num| */
+const char *OSSL_trace_get_category_name(int num);
+
+/*
+ * TRACE CONSUMERS
+ */
+
+/*
+ * Enables tracing for the given |category| by providing a BIO sink
+ * as |channel|. If a null pointer is passed as |channel|, an existing
+ * trace channel is removed and tracing for the category is disabled.
+ *
+ * Returns 1 on success and 0 on failure
+ */
+int OSSL_trace_set_channel(int category, BIO* channel);
+
+/*
+ * Attach a prefix and a suffix to the given |category|, to be printed at the
+ * beginning and at the end of each trace output group, i.e. when
+ * OSSL_trace_begin() and OSSL_trace_end() are called.
+ * If a null pointer is passed as argument, the existing prefix or suffix is
+ * removed.
+ *
+ * They return 1 on success and 0 on failure
+ */
+int OSSL_trace_set_prefix(int category, const char *prefix);
+int OSSL_trace_set_suffix(int category, const char *suffix);
+
+/*
+ * OSSL_trace_cb is the type tracing callback provided by the application.
+ * It MUST return the number of bytes written, or 0 on error (in other words,
+ * it can never write zero bytes).
+ *
+ * The |buffer| will always contain text, which may consist of several lines.
+ * The |data| argument points to whatever data was provided by the application
+ * when registering the tracer function.
+ *
+ * The |category| number is given, as well as a |cmd| number, described below.
+ */
+typedef size_t (*OSSL_trace_cb)(const char *buffer, size_t count,
+                                int category, int cmd, void *data);
+/*
+ * Possible |cmd| numbers.
+ */
+# define OSSL_TRACE_CTRL_BEGIN  0
+# define OSSL_TRACE_CTRL_DURING 1
+# define OSSL_TRACE_CTRL_END    2
+
+/*
+ * Enables tracing for the given |category| by creating an internal
+ * trace channel which sends the output to the given |callback|.
+ * If a null pointer is passed as callback, an existing trace channel
+ * is removed and tracing for the category is disabled.
+ *
+ * NOTE: OSSL_trace_set_channel() and OSSL_trace_set_callback() are mutually
+ *       exclusive.
+ *
+ * Returns 1 on success and 0 on failure
+ */
+int OSSL_trace_set_callback(int category, OSSL_trace_cb callback, void *data);
+
+/*
+ * TRACE PRODUCERS
+ */
+
+/*
+ * Returns 1 if tracing for the specified category is enabled, otherwise 0
+ */
+int OSSL_trace_enabled(int category);
+
+/*
+ * Wrap a group of tracing output calls.  OSSL_trace_begin() locks tracing and
+ * returns the trace channel associated with the given category, or NULL if no
+ * channel is associated with the category.  OSSL_trace_end() unlocks tracing.
+ *
+ * Usage:
+ *
+ *    BIO *out;
+ *    if ((out = OSSL_trace_begin(category)) != NULL) {
+ *        ...
+ *        BIO_fprintf(out, ...);
+ *        ...
+ *        OSSL_trace_end(category, out);
+ *    }
+ *
+ * See also the convenience macros OSSL_TRACE_BEGIN and OSSL_TRACE_END below.
+ */
+BIO *OSSL_trace_begin(int category);
+void OSSL_trace_end(int category, BIO *channel);
+
+/*
+ * OSSL_TRACE* Convenience Macros
+ */
+
+/*
+ * When the tracing feature is disabled, these macros are defined to
+ * produce dead code, which a good compiler should eliminate.
+ */
+
+/*
+ * OSSL_TRACE_BEGIN, OSSL_TRACE_END - Define a Trace Group
+ *
+ * These two macros can be used to create a block which is executed only
+ * if the corresponding trace category is enabled. Inside this block, a
+ * local variable named |trc_out| is defined, which points to the channel
+ * associated with the given trace category.
+ *
+ * Usage: (using 'TLS' as an example category)
+ *
+ *     OSSL_TRACE_BEGIN(TLS) {
+ *
+ *         BIO_fprintf(trc_out, ... );
+ *
+ *     } OSSL_TRACE_END(TLS);
+ *
+ *
+ * This expands to the following code
+ *
+ *     do {
+ *         BIO *trc_out = OSSL_trace_begin(OSSL_TRACE_CATEGORY_TLS);
+ *         if (trc_out != NULL) {
+ *             ...
+ *             BIO_fprintf(trc_out, ...);
+ *         }
+ *         OSSL_trace_end(OSSL_TRACE_CATEGORY_TLS, trc_out);
+ *     } while (0);
+ *
+ * The use of the inner '{...}' group and the trailing ';' is enforced
+ * by the definition of the macros in order to make the code look as much
+ * like C code as possible.
+ *
+ * Before returning from inside the trace block, it is necessary to
+ * call OSSL_TRACE_CANCEL(category).
+ */
+
+# ifndef OPENSSL_NO_TRACE
+
+#  define OSSL_TRACE_BEGIN(category) \
+    do { \
+        BIO *trc_out = OSSL_trace_begin(OSSL_TRACE_CATEGORY_##category); \
+ \
+        if (trc_out != NULL)
+
+#  define OSSL_TRACE_END(category) \
+        OSSL_trace_end(OSSL_TRACE_CATEGORY_##category, trc_out); \
+    } while (0)
+
+#  define OSSL_TRACE_CANCEL(category) \
+        OSSL_trace_end(OSSL_TRACE_CATEGORY_##category, trc_out) \
+
+# else
+
+#  define OSSL_TRACE_BEGIN(category)           \
+    do {                                        \
+        BIO *trc_out = NULL;                    \
+        if (0)
+
+#  define OSSL_TRACE_END(category)             \
+    } while(0)
+
+#  define OSSL_TRACE_CANCEL(category)          \
+    ((void)0)
+
+# endif
+
+/*
+ * OSSL_TRACE_ENABLED() - Check whether tracing is enabled for |category|
+ *
+ * Usage:
+ *
+ *     if (OSSL_TRACE_ENABLED(TLS)) {
+ *         ...
+ *     }
+ */
+# ifndef OPENSSL_NO_TRACE
+
+#  define OSSL_TRACE_ENABLED(category) \
+    OSSL_trace_enabled(OSSL_TRACE_CATEGORY_##category)
+
+# else
+
+#  define OSSL_TRACE_ENABLED(category) (0)
+
+# endif
+
+/*
+ * OSSL_TRACE*() - OneShot Trace Macros
+ *
+ * These macros are intended to produce a simple printf-style trace output.
+ * Unfortunately, C90 macros don't support variable arguments, so the
+ * &quot;vararg&quot; OSSL_TRACEV() macro has a rather weird usage pattern:
+ *
+ *    OSSL_TRACEV(category, (trc_out, &quot;format string&quot;, ...args...));
+ *
+ * Where 'channel' is the literal symbol of this name, not a variable.
+ * For that reason, it is currently not intended to be used directly,
+ * but only as helper macro for the other oneshot trace macros
+ * OSSL_TRACE(), OSSL_TRACE1(), OSSL_TRACE2(), ...
+ *
+ * Usage:
+ *
+ *    OSSL_TRACE(INIT, &quot;Hello world!\n&quot;);
+ *    OSSL_TRACE1(TLS, &quot;The answer is %d\n&quot;, 42);
+ *    OSSL_TRACE2(TLS, &quot;The ultimate question to answer %d is '%s'\n&quot;,
+ *                42, &quot;What do you get when you multiply six by nine?&quot;);
+ */
+
+# define OSSL_TRACEV(category, args) \
+    OSSL_TRACE_BEGIN(category) \
+        BIO_printf args; \
+    OSSL_TRACE_END(category)
+
+# define OSSL_TRACE(category, text) \
+    OSSL_TRACEV(category, (trc_out, &quot;%s&quot;, text))
+
+# define OSSL_TRACE1(category, format, arg1) \
+    OSSL_TRACEV(category, (trc_out, format, arg1))
+# define OSSL_TRACE2(category, format, arg1, arg2) \
+    OSSL_TRACEV(category, (trc_out, format, arg1, arg2))
+# define OSSL_TRACE3(category, format, arg1, arg2, arg3) \
+    OSSL_TRACEV(category, (trc_out, format, arg1, arg2, arg3))
+# define OSSL_TRACE4(category, format, arg1, arg2, arg3, arg4) \
+    OSSL_TRACEV(category, (trc_out, format, arg1, arg2, arg3, arg4))
+# define OSSL_TRACE5(category, format, arg1, arg2, arg3, arg4, arg5) \
+    OSSL_TRACEV(category, (trc_out, format, arg1, arg2, arg3, arg4, arg5))
+# define OSSL_TRACE6(category, format, arg1, arg2, arg3, arg4, arg5, arg6) \
+    OSSL_TRACEV(category, (trc_out, format, arg1, arg2, arg3, arg4, arg5, arg6))
+# define OSSL_TRACE7(category, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7) \
+    OSSL_TRACEV(category, (trc_out, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7))
+# define OSSL_TRACE8(category, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) \
+    OSSL_TRACEV(category, (trc_out, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8))
+# define OSSL_TRACE9(category, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) \
+    OSSL_TRACEV(category, (trc_out, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9))
+
+# ifdef  __cplusplus
+}
+# endif
+
+#endif
diff --git a/ssl/record/ssl3_record.c b/ssl/record/ssl3_record.c
index 3f5f796..e1231d2 100644
--- a/ssl/record/ssl3_record.c
+++ b/ssl/record/ssl3_record.c
@@ -9,6 +9,7 @@
 
 #include &quot;../ssl_locl.h&quot;
 #include &quot;internal/constant_time_locl.h&quot;
+#include &lt;openssl/trace.h&gt;
 #include &lt;openssl/rand.h&gt;
 #include &quot;record_locl.h&quot;
 #include &quot;internal/cryptlib.h&quot;
@@ -563,15 +564,10 @@ int ssl3_get_record(SSL *s)
                  SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);
         return -1;
     }
-#ifdef SSL_DEBUG
-    printf(&quot;dec %lu\n&quot;, (unsigned long)rr[0].length);
-    {
-        size_t z;
-        for (z = 0; z &lt; rr[0].length; z++)
-            printf(&quot;%02X%c&quot;, rr[0].data[z], ((z + 1) % 16) ? ' ' : '\n');
-    }
-    printf(&quot;\n&quot;);
-#endif
+    OSSL_TRACE_BEGIN(TLS) {
+        BIO_printf(trc_out, &quot;dec %lu\n&quot;, (unsigned long)rr[0].length);
+        BIO_dump_indent(trc_out, rr[0].data, rr[0].length, 4);
+    } OSSL_TRACE_END(TLS);
 
     /* r-&gt;length is now the compressed data plus mac */
     if ((sess != NULL) &amp;&amp;
@@ -1361,22 +1357,12 @@ int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int sending)
 
     EVP_MD_CTX_free(hmac);
 
-#ifdef SSL_DEBUG
-    fprintf(stderr, &quot;seq=&quot;);
-    {
-        int z;
-        for (z = 0; z &lt; 8; z++)
-            fprintf(stderr, &quot;%02X &quot;, seq[z]);
-        fprintf(stderr, &quot;\n&quot;);
-    }
-    fprintf(stderr, &quot;rec=&quot;);
-    {
-        size_t z;
-        for (z = 0; z &lt; rec-&gt;length; z++)
-            fprintf(stderr, &quot;%02X &quot;, rec-&gt;data[z]);
-        fprintf(stderr, &quot;\n&quot;);
-    }
-#endif
+    OSSL_TRACE_BEGIN(TLS) {
+        BIO_printf(trc_out, &quot;seq:\n&quot;);
+        BIO_dump_indent(trc_out, seq, 8, 4);
+        BIO_printf(trc_out, &quot;rec:\n&quot;);
+        BIO_dump_indent(trc_out, rec-&gt;data, rec-&gt;length, 4);
+    } OSSL_TRACE_END(TLS);
 
     if (!SSL_IS_DTLS(ssl)) {
         for (i = 7; i &gt;= 0; i--) {
@@ -1385,14 +1371,10 @@ int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int sending)
                 break;
         }
     }
-#ifdef SSL_DEBUG
-    {
-        unsigned int z;
-        for (z = 0; z &lt; md_size; z++)
-            fprintf(stderr, &quot;%02X &quot;, md[z]);
-        fprintf(stderr, &quot;\n&quot;);
-    }
-#endif
+    OSSL_TRACE_BEGIN(TLS) {
+        BIO_printf(trc_out, &quot;md:\n&quot;);
+        BIO_dump_indent(trc_out, md, md_size, 4);
+    } OSSL_TRACE_END(TLS);
     return 1;
 }
 
@@ -1683,15 +1665,10 @@ int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)
         RECORD_LAYER_reset_packet_length(&amp;s-&gt;rlayer);
         return 0;
     }
-#ifdef SSL_DEBUG
-    printf(&quot;dec %ld\n&quot;, rr-&gt;length);
-    {
-        size_t z;
-        for (z = 0; z &lt; rr-&gt;length; z++)
-            printf(&quot;%02X%c&quot;, rr-&gt;data[z], ((z + 1) % 16) ? ' ' : '\n');
-    }
-    printf(&quot;\n&quot;);
-#endif
+    OSSL_TRACE_BEGIN(TLS) {
+        BIO_printf(trc_out, &quot;dec %ld\n&quot;, rr-&gt;length);
+        BIO_dump_indent(trc_out, rr-&gt;data, rr-&gt;length, 4);
+    } OSSL_TRACE_END(TLS);
 
     /* r-&gt;length is now the compressed data plus mac */
     if ((sess != NULL) &amp;&amp; !SSL_READ_ETM(s) &amp;&amp;
diff --git a/ssl/s3_lib.c b/ssl/s3_lib.c
index a5b3dbb..a3639fd 100644
--- a/ssl/s3_lib.c
+++ b/ssl/s3_lib.c
@@ -16,6 +16,7 @@
 #include &lt;openssl/md5.h&gt;
 #include &lt;openssl/dh.h&gt;
 #include &lt;openssl/rand.h&gt;
+#include &lt;openssl/trace.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 
 #define TLS13_NUM_CIPHERS       OSSL_NELEM(tls13_ciphers)
@@ -4153,20 +4154,20 @@ const SSL_CIPHER *ssl3_choose_cipher(SSL *s, STACK_OF(SSL_CIPHER) *clnt,
      * pay with the price of sk_SSL_CIPHER_dup().
      */
 
-#ifdef CIPHER_DEBUG
-    fprintf(stderr, &quot;Server has %d from %p:\n&quot;, sk_SSL_CIPHER_num(srvr),
-            (void *)srvr);
-    for (i = 0; i &lt; sk_SSL_CIPHER_num(srvr); ++i) {
-        c = sk_SSL_CIPHER_value(srvr, i);
-        fprintf(stderr, &quot;%p:%s\n&quot;, (void *)c, c-&gt;name);
-    }
-    fprintf(stderr, &quot;Client sent %d from %p:\n&quot;, sk_SSL_CIPHER_num(clnt),
-            (void *)clnt);
-    for (i = 0; i &lt; sk_SSL_CIPHER_num(clnt); ++i) {
-        c = sk_SSL_CIPHER_value(clnt, i);
-        fprintf(stderr, &quot;%p:%s\n&quot;, (void *)c, c-&gt;name);
-    }
-#endif
+    OSSL_TRACE_BEGIN(TLS_CIPHER) {
+        BIO_printf(trc_out, &quot;Server has %d from %p:\n&quot;,
+                   sk_SSL_CIPHER_num(srvr), (void *)srvr);
+        for (i = 0; i &lt; sk_SSL_CIPHER_num(srvr); ++i) {
+            c = sk_SSL_CIPHER_value(srvr, i);
+            BIO_printf(trc_out, &quot;%p:%s\n&quot;, (void *)c, c-&gt;name);
+        }
+        BIO_printf(trc_out, &quot;Client sent %d from %p:\n&quot;,
+                   sk_SSL_CIPHER_num(clnt), (void *)clnt);
+        for (i = 0; i &lt; sk_SSL_CIPHER_num(clnt); ++i) {
+            c = sk_SSL_CIPHER_value(clnt, i);
+            BIO_printf(trc_out, &quot;%p:%s\n&quot;, (void *)c, c-&gt;name);
+        }
+    } OSSL_TRACE_END(TLS_CIPHER);
 
     /* SUITE-B takes precedence over server preference and ChaCha priortiy */
     if (tls1_suiteb(s)) {
@@ -4280,10 +4281,9 @@ const SSL_CIPHER *ssl3_choose_cipher(SSL *s, STACK_OF(SSL_CIPHER) *clnt,
 #endif                          /* OPENSSL_NO_PSK */
 
             ok = (alg_k &amp; mask_k) &amp;&amp; (alg_a &amp; mask_a);
-#ifdef CIPHER_DEBUG
-            fprintf(stderr, &quot;%d:[%08lX:%08lX:%08lX:%08lX]%p:%s\n&quot;, ok, alg_k,
-                    alg_a, mask_k, mask_a, (void *)c, c-&gt;name);
-#endif
+            OSSL_TRACE7(TLS_CIPHER,
+                        &quot;%d:[%08lX:%08lX:%08lX:%08lX]%p:%s\n&quot;,
+                        ok, alg_k, alg_a, mask_k, mask_a, (void *)c, c-&gt;name);
 
 #ifndef OPENSSL_NO_EC
             /*
diff --git a/ssl/ssl_ciph.c b/ssl/ssl_ciph.c
index 461a9de..5aa04db 100644
--- a/ssl/ssl_ciph.c
+++ b/ssl/ssl_ciph.c
@@ -16,6 +16,7 @@
 #include &lt;openssl/engine.h&gt;
 #include &lt;openssl/crypto.h&gt;
 #include &lt;openssl/conf.h&gt;
+#include &lt;openssl/trace.h&gt;
 #include &quot;internal/nelem.h&quot;
 #include &quot;ssl_locl.h&quot;
 #include &quot;internal/thread_once.h&quot;
@@ -781,12 +782,12 @@ static void ssl_cipher_apply_rule(uint32_t cipher_id, uint32_t alg_mkey,
     const SSL_CIPHER *cp;
     int reverse = 0;
 
-#ifdef CIPHER_DEBUG
-    fprintf(stderr,
-            &quot;Applying rule %d with %08x/%08x/%08x/%08x/%08x %08x (%d)\n&quot;,
-            rule, alg_mkey, alg_auth, alg_enc, alg_mac, min_tls,
-            algo_strength, strength_bits);
-#endif
+    OSSL_TRACE_BEGIN(TLS_CIPHER){
+        BIO_printf(trc_out,
+                   &quot;Applying rule %d with %08x/%08x/%08x/%08x/%08x %08x (%d)\n&quot;,
+                   rule, alg_mkey, alg_auth, alg_enc, alg_mac, min_tls,
+                   algo_strength, strength_bits);
+    }
 
     if (rule == CIPHER_DEL || rule == CIPHER_BUMP)
         reverse = 1;            /* needed to maintain sorting between currently
@@ -825,13 +826,14 @@ static void ssl_cipher_apply_rule(uint32_t cipher_id, uint32_t alg_mkey,
             if (strength_bits != cp-&gt;strength_bits)
                 continue;
         } else {
-#ifdef CIPHER_DEBUG
-            fprintf(stderr,
-                    &quot;\nName: %s:\nAlgo = %08x/%08x/%08x/%08x/%08x Algo_strength = %08x\n&quot;,
-                    cp-&gt;name, cp-&gt;algorithm_mkey, cp-&gt;algorithm_auth,
-                    cp-&gt;algorithm_enc, cp-&gt;algorithm_mac, cp-&gt;min_tls,
-                    cp-&gt;algo_strength);
-#endif
+            if (trc_out != NULL) {
+                BIO_printf(trc_out,
+                           &quot;\nName: %s:&quot;
+                           &quot;\nAlgo = %08x/%08x/%08x/%08x/%08x Algo_strength = %08x\n&quot;,
+                           cp-&gt;name, cp-&gt;algorithm_mkey, cp-&gt;algorithm_auth,
+                           cp-&gt;algorithm_enc, cp-&gt;algorithm_mac, cp-&gt;min_tls,
+                           cp-&gt;algo_strength);
+            }
             if (cipher_id != 0 &amp;&amp; (cipher_id != cp-&gt;id))
                 continue;
             if (alg_mkey &amp;&amp; !(alg_mkey &amp; cp-&gt;algorithm_mkey))
@@ -852,9 +854,8 @@ static void ssl_cipher_apply_rule(uint32_t cipher_id, uint32_t alg_mkey,
                 continue;
         }
 
-#ifdef CIPHER_DEBUG
-        fprintf(stderr, &quot;Action = %d\n&quot;, rule);
-#endif
+        if (trc_out != NULL)
+            BIO_printf(trc_out, &quot;Action = %d\n&quot;, rule);
 
         /* add the cipher if it has not been added yet. */
         if (rule == CIPHER_ADD) {
@@ -904,6 +905,8 @@ static void ssl_cipher_apply_rule(uint32_t cipher_id, uint32_t alg_mkey,
 
     *head_p = head;
     *tail_p = tail;
+
+    OSSL_TRACE_END(TLS_CIPHER);
 }
 
 static int ssl_cipher_strength_sort(CIPHER_ORDER **head_p,
@@ -1605,6 +1608,9 @@ STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(const SSL_METHOD *ssl_method,
         }
     }
 
+    OSSL_TRACE_BEGIN(TLS_CIPHER) {
+        BIO_printf(trc_out, &quot;cipher selection:\n&quot;);
+    }
     /*
      * The cipher selection for the list is done. The ciphers are added
      * to the resulting precedence to the STACK_OF(SSL_CIPHER).
@@ -1614,14 +1620,15 @@ STACK_OF(SSL_CIPHER) *ssl_create_cipher_list(const SSL_METHOD *ssl_method,
             if (!sk_SSL_CIPHER_push(cipherstack, curr-&gt;cipher)) {
                 OPENSSL_free(co_list);
                 sk_SSL_CIPHER_free(cipherstack);
+                OSSL_TRACE_CANCEL(TLS_CIPHER);
                 return NULL;
             }
-#ifdef CIPHER_DEBUG
-            fprintf(stderr, &quot;&lt;%s&gt;\n&quot;, curr-&gt;cipher-&gt;name);
-#endif
+            if (trc_out != NULL)
+                BIO_printf(trc_out, &quot;&lt;%s&gt;\n&quot;, curr-&gt;cipher-&gt;name);
         }
     }
     OPENSSL_free(co_list);      /* Not needed any longer */
+    OSSL_TRACE_END(TLS_CIPHER);
 
     if (!update_cipher_list_by_id(cipher_list_by_id, cipherstack)) {
         sk_SSL_CIPHER_free(cipherstack);
diff --git a/ssl/ssl_init.c b/ssl/ssl_init.c
index e766ee1..0451d19 100644
--- a/ssl/ssl_init.c
+++ b/ssl/ssl_init.c
@@ -12,6 +12,7 @@
 #include &quot;internal/err.h&quot;
 #include &lt;openssl/crypto.h&gt;
 #include &lt;openssl/evp.h&gt;
+#include &lt;openssl/trace.h&gt;
 #include &quot;ssl_locl.h&quot;
 #include &quot;internal/thread_once.h&quot;
 
@@ -23,10 +24,7 @@ static CRYPTO_ONCE ssl_base = CRYPTO_ONCE_STATIC_INIT;
 static int ssl_base_inited = 0;
 DEFINE_RUN_ONCE_STATIC(ossl_init_ssl_base)
 {
-#ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_ssl_base: &quot;
-            &quot;Adding SSL ciphers and digests\n&quot;);
-#endif
+    OSSL_TRACE(INIT, &quot;ossl_init_ssl_base: adding SSL ciphers and digests\n&quot;);
 #ifndef OPENSSL_NO_DES
     EVP_add_cipher(EVP_des_cbc());
     EVP_add_cipher(EVP_des_ede3_cbc());
@@ -88,10 +86,8 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_ssl_base)
     EVP_add_digest(EVP_sha384());
     EVP_add_digest(EVP_sha512());
 #ifndef OPENSSL_NO_COMP
-# ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_ssl_base: &quot;
-            &quot;SSL_COMP_get_compression_methods()\n&quot;);
-# endif
+    OSSL_TRACE(INIT, &quot;ossl_init_ssl_base: &quot;
+               &quot;SSL_COMP_get_compression_methods()\n&quot;);
     /*
      * This will initialise the built-in compression algorithms. The value
      * returned is a STACK_OF(SSL_COMP), but that can be discarded safely
@@ -102,10 +98,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_ssl_base)
     if (!ssl_load_ciphers())
         return 0;
 
-#ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_ssl_base: &quot;
-            &quot;SSL_add_ssl_module()\n&quot;);
-#endif
+    OSSL_TRACE(INIT,&quot;ossl_init_ssl_base: SSL_add_ssl_module()\n&quot;);
     /*
      * We ignore an error return here. Not much we can do - but not that bad
      * either. We can still safely continue.
@@ -124,10 +117,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_load_ssl_strings)
      * pulling in all the error strings during static linking
      */
 #if !defined(OPENSSL_NO_ERR) &amp;&amp; !defined(OPENSSL_NO_AUTOERRINIT)
-# ifdef OPENSSL_INIT_DEBUG
-    fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_load_ssl_strings: &quot;
-            &quot;ERR_load_SSL_strings()\n&quot;);
-# endif
+    OSSL_TRACE(INIT, &quot;ossl_init_load_ssl_strings: ERR_load_SSL_strings()\n&quot;);
     ERR_load_SSL_strings();
     ssl_strings_inited = 1;
 #endif
@@ -150,19 +140,14 @@ static void ssl_library_stop(void)
 
     if (ssl_base_inited) {
 #ifndef OPENSSL_NO_COMP
-# ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: ssl_library_stop: &quot;
-                &quot;ssl_comp_free_compression_methods_int()\n&quot;);
-# endif
+        OSSL_TRACE(INIT, &quot;ssl_library_stop: &quot;
+                   &quot;ssl_comp_free_compression_methods_int()\n&quot;);
         ssl_comp_free_compression_methods_int();
 #endif
     }
 
     if (ssl_strings_inited) {
-#ifdef OPENSSL_INIT_DEBUG
-        fprintf(stderr, &quot;OPENSSL_INIT: ssl_library_stop: &quot;
-                &quot;err_free_strings_int()\n&quot;);
-#endif
+        OSSL_TRACE(INIT, &quot;ssl_library_stop: err_free_strings_int()\n&quot;);
         /*
          * If both crypto and ssl error strings are inited we will end up
          * calling err_free_strings_int() twice - but that's ok. The second
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index 322a438..f63e16b 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -20,6 +20,7 @@
 #include &lt;openssl/engine.h&gt;
 #include &lt;openssl/async.h&gt;
 #include &lt;openssl/ct.h&gt;
+#include &lt;openssl/trace.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &quot;internal/refcount.h&quot;
 #include &quot;internal/ktls.h&quot;
@@ -3329,10 +3330,8 @@ void ssl_set_masks(SSL *s)
     mask_k = 0;
     mask_a = 0;
 
-#ifdef CIPHER_DEBUG
-    fprintf(stderr, &quot;dht=%d re=%d rs=%d ds=%d\n&quot;,
-            dh_tmp, rsa_enc, rsa_sign, dsa_sign);
-#endif
+    OSSL_TRACE4(TLS_CIPHER, &quot;dh_tmp=%d rsa_enc=%d rsa_sign=%d dsa_sign=%d\n&quot;,
+               dh_tmp, rsa_enc, rsa_sign, dsa_sign);
 
 #ifndef OPENSSL_NO_GOST
     if (ssl_has_cert(s, SSL_PKEY_GOST12_512)) {
diff --git a/ssl/statem/statem_clnt.c b/ssl/statem/statem_clnt.c
index 2a9b737..356dc89 100644
--- a/ssl/statem/statem_clnt.c
+++ b/ssl/statem/statem_clnt.c
@@ -22,6 +22,7 @@
 #include &lt;openssl/dh.h&gt;
 #include &lt;openssl/bn.h&gt;
 #include &lt;openssl/engine.h&gt;
+#include &lt;openssl/trace.h&gt;
 #include &lt;internal/cryptlib.h&gt;
 
 static MSG_PROCESS_RETURN tls_process_as_hello_retry_request(SSL *s, PACKET *pkt);
@@ -2347,11 +2348,9 @@ MSG_PROCESS_RETURN tls_process_key_exchange(SSL *s, PACKET *pkt)
                      ERR_R_INTERNAL_ERROR);
             goto err;
         }
-#ifdef SSL_DEBUG
         if (SSL_USE_SIGALGS(s))
-            fprintf(stderr, &quot;USING TLSv1.2 HASH %s\n&quot;,
-                    md == NULL ? &quot;n/a&quot; : EVP_MD_name(md));
-#endif
+            OSSL_TRACE1(TLS, &quot;USING TLSv1.2 HASH %s\n&quot;,
+                        md == NULL ? &quot;n/a&quot; : EVP_MD_name(md));
 
         if (!PACKET_get_length_prefixed_2(pkt, &amp;signature)
             || PACKET_remaining(pkt) != 0) {
diff --git a/ssl/statem/statem_lib.c b/ssl/statem/statem_lib.c
index a18c5cc..10cf635 100644
--- a/ssl/statem/statem_lib.c
+++ b/ssl/statem/statem_lib.c
@@ -18,6 +18,7 @@
 #include &lt;openssl/objects.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/x509.h&gt;
+#include &lt;openssl/trace.h&gt;
 
 /*
  * Map error codes to TLS/SSL alart types.
@@ -394,11 +395,9 @@ MSG_PROCESS_RETURN tls_process_cert_verify(SSL *s, PACKET *pkt)
         goto err;
     }
 
-#ifdef SSL_DEBUG
     if (SSL_USE_SIGALGS(s))
-        fprintf(stderr, &quot;USING TLSv1.2 HASH %s\n&quot;,
-                md == NULL ? &quot;n/a&quot; : EVP_MD_name(md));
-#endif
+        OSSL_TRACE1(TLS, &quot;USING TLSv1.2 HASH %s\n&quot;,
+                    md == NULL ? &quot;n/a&quot; : EVP_MD_name(md));
 
     /* Check for broken implementations of GOST ciphersuites */
     /*
@@ -439,10 +438,9 @@ MSG_PROCESS_RETURN tls_process_cert_verify(SSL *s, PACKET *pkt)
         goto err;
     }
 
-#ifdef SSL_DEBUG
-    fprintf(stderr, &quot;Using client verify alg %s\n&quot;,
-            md == NULL ? &quot;n/a&quot; : EVP_MD_name(md));
-#endif
+    OSSL_TRACE1(TLS, &quot;Using client verify alg %s\n&quot;,
+                md == NULL ? &quot;n/a&quot; : EVP_MD_name(md));
+
     if (EVP_DigestVerifyInit(mctx, &amp;pctx, md, NULL, pkey) &lt;= 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PROCESS_CERT_VERIFY,
                  ERR_R_EVP_LIB);
diff --git a/ssl/statem/statem_srvr.c b/ssl/statem/statem_srvr.c
index bf1819d..e482e2d 100644
--- a/ssl/statem/statem_srvr.c
+++ b/ssl/statem/statem_srvr.c
@@ -23,6 +23,7 @@
 #include &lt;openssl/dh.h&gt;
 #include &lt;openssl/bn.h&gt;
 #include &lt;openssl/md5.h&gt;
+#include &lt;openssl/trace.h&gt;
 
 #define TICKET_NONCE_SIZE       8
 
@@ -1835,15 +1836,15 @@ static int tls_early_post_process_client_hello(SSL *s)
         j = 0;
         id = s-&gt;session-&gt;cipher-&gt;id;
 
-#ifdef CIPHER_DEBUG
-        fprintf(stderr, &quot;client sent %d ciphers\n&quot;, sk_SSL_CIPHER_num(ciphers));
-#endif
+        OSSL_TRACE_BEGIN(TLS_CIPHER) {
+            BIO_printf(trc_out, &quot;client sent %d ciphers\n&quot;,
+                       sk_SSL_CIPHER_num(ciphers));
+        }
         for (i = 0; i &lt; sk_SSL_CIPHER_num(ciphers); i++) {
             c = sk_SSL_CIPHER_value(ciphers, i);
-#ifdef CIPHER_DEBUG
-            fprintf(stderr, &quot;client [%2d of %2d]:%s\n&quot;,
-                    i, sk_SSL_CIPHER_num(ciphers), SSL_CIPHER_get_name(c));
-#endif
+            if (trc_out != NULL)
+                BIO_printf(trc_out, &quot;client [%2d of %2d]:%s\n&quot;, i,
+                           sk_SSL_CIPHER_num(ciphers), SSL_CIPHER_get_name(c));
             if (c-&gt;id == id) {
                 j = 1;
                 break;
@@ -1857,8 +1858,10 @@ static int tls_early_post_process_client_hello(SSL *s)
             SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER,
                      SSL_F_TLS_EARLY_POST_PROCESS_CLIENT_HELLO,
                      SSL_R_REQUIRED_CIPHER_MISSING);
+            OSSL_TRACE_CANCEL(TLS_CIPHER);
             goto err;
         }
+        OSSL_TRACE_END(TLS_CIPHER);
     }
 
     for (loop = 0; loop &lt; clienthello-&gt;compressions_len; loop++) {
diff --git a/ssl/t1_enc.c b/ssl/t1_enc.c
index 9b58bd8..fe4ba93 100644
--- a/ssl/t1_enc.c
+++ b/ssl/t1_enc.c
@@ -18,6 +18,7 @@
 #include &lt;openssl/kdf.h&gt;
 #include &lt;openssl/rand.h&gt;
 #include &lt;openssl/obj_mac.h&gt;
+#include &lt;openssl/trace.h&gt;
 
 /* seed1 through seed5 are concatenated */
 static int tls1_PRF(SSL *s,
@@ -276,14 +277,11 @@ int tls1_change_cipher_state(SSL *s, int which)
         }
         EVP_PKEY_free(mac_key);
     }
-#ifdef SSL_DEBUG
-    printf(&quot;which = %04X\nmac key=&quot;, which);
-    {
-        size_t z;
-        for (z = 0; z &lt; i; z++)
-            printf(&quot;%02X%c&quot;, ms[z], ((z + 1) % 16) ? ' ' : '\n');
-    }
-#endif
+
+    OSSL_TRACE_BEGIN(TLS) {
+        BIO_printf(trc_out, &quot;which = %04X, mac key:\n&quot;, which);
+        BIO_dump_indent(trc_out, ms, i, 4);
+    } OSSL_TRACE_END(TLS);
 
     if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) {
         if (!EVP_CipherInit_ex(dd, c, NULL, key, NULL, (which &amp; SSL3_CC_WRITE))
@@ -388,21 +386,12 @@ int tls1_change_cipher_state(SSL *s, int which)
 #endif                          /* OPENSSL_NO_KTLS */
     s-&gt;statem.enc_write_state = ENC_WRITE_STATE_VALID;
 
-#ifdef SSL_DEBUG
-    printf(&quot;which = %04X\nkey=&quot;, which);
-    {
-        int z;
-        for (z = 0; z &lt; EVP_CIPHER_key_length(c); z++)
-            printf(&quot;%02X%c&quot;, key[z], ((z + 1) % 16) ? ' ' : '\n');
-    }
-    printf(&quot;\niv=&quot;);
-    {
-        size_t z;
-        for (z = 0; z &lt; k; z++)
-            printf(&quot;%02X%c&quot;, iv[z], ((z + 1) % 16) ? ' ' : '\n');
-    }
-    printf(&quot;\n&quot;);
-#endif
+    OSSL_TRACE_BEGIN(TLS) {
+        BIO_printf(trc_out, &quot;which = %04X, key:\n&quot;, which);
+        BIO_dump_indent(trc_out, key, EVP_CIPHER_key_length(c), 4);
+        BIO_printf(trc_out, &quot;iv:\n&quot;);
+        BIO_dump_indent(trc_out, iv, k, 4);
+    } OSSL_TRACE_END(TLS);
 
     return 1;
  err:
@@ -447,41 +436,26 @@ int tls1_setup_key_block(SSL *s)
     s-&gt;s3-&gt;tmp.key_block_length = num;
     s-&gt;s3-&gt;tmp.key_block = p;
 
-#ifdef SSL_DEBUG
-    printf(&quot;client random\n&quot;);
-    {
-        int z;
-        for (z = 0; z &lt; SSL3_RANDOM_SIZE; z++)
-            printf(&quot;%02X%c&quot;, s-&gt;s3-&gt;client_random[z],
-                   ((z + 1) % 16) ? ' ' : '\n');
-    }
-    printf(&quot;server random\n&quot;);
-    {
-        int z;
-        for (z = 0; z &lt; SSL3_RANDOM_SIZE; z++)
-            printf(&quot;%02X%c&quot;, s-&gt;s3-&gt;server_random[z],
-                   ((z + 1) % 16) ? ' ' : '\n');
-    }
-    printf(&quot;master key\n&quot;);
-    {
-        size_t z;
-        for (z = 0; z &lt; s-&gt;session-&gt;master_key_length; z++)
-            printf(&quot;%02X%c&quot;, s-&gt;session-&gt;master_key[z],
-                   ((z + 1) % 16) ? ' ' : '\n');
-    }
-#endif
+    OSSL_TRACE_BEGIN(TLS) {
+        BIO_printf(trc_out, &quot;client random\n&quot;);
+        BIO_dump_indent(trc_out, s-&gt;s3-&gt;client_random, SSL3_RANDOM_SIZE, 4);
+        BIO_printf(trc_out, &quot;server random\n&quot;);
+        BIO_dump_indent(trc_out, s-&gt;s3-&gt;server_random, SSL3_RANDOM_SIZE, 4);
+        BIO_printf(trc_out, &quot;master key\n&quot;);
+        BIO_dump_indent(trc_out,
+                        s-&gt;session-&gt;master_key,
+                        s-&gt;session-&gt;master_key_length, 4);
+    } OSSL_TRACE_END(TLS);
+
     if (!tls1_generate_key_block(s, p, num)) {
         /* SSLfatal() already called */
         goto err;
     }
-#ifdef SSL_DEBUG
-    printf(&quot;\nkey block\n&quot;);
-    {
-        size_t z;
-        for (z = 0; z &lt; num; z++)
-            printf(&quot;%02X%c&quot;, p[z], ((z + 1) % 16) ? ' ' : '\n');
-    }
-#endif
+
+    OSSL_TRACE_BEGIN(TLS) {
+        BIO_printf(trc_out, &quot;key block\n&quot;);
+        BIO_dump_indent(trc_out, p, num, 4);
+    } OSSL_TRACE_END(TLS);
 
     if (!(s-&gt;options &amp; SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)
         &amp;&amp; s-&gt;method-&gt;version &lt;= TLS1_VERSION) {
@@ -549,10 +523,10 @@ int tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
             /* SSLfatal() already called */
             return 0;
         }
-#ifdef SSL_DEBUG
-        fprintf(stderr, &quot;Handshake hashes:\n&quot;);
-        BIO_dump_fp(stderr, (char *)hash, hashlen);
-#endif
+        OSSL_TRACE_BEGIN(TLS) {
+            BIO_printf(trc_out, &quot;Handshake hashes:\n&quot;);
+            BIO_dump(trc_out, (char *)hash, hashlen);
+        } OSSL_TRACE_END(TLS);
         if (!tls1_PRF(s,
                       TLS_MD_EXTENDED_MASTER_SECRET_CONST,
                       TLS_MD_EXTENDED_MASTER_SECRET_CONST_SIZE,
@@ -578,17 +552,19 @@ int tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,
             return 0;
         }
     }
-#ifdef SSL_DEBUG
-    fprintf(stderr, &quot;Premaster Secret:\n&quot;);
-    BIO_dump_fp(stderr, (char *)p, len);
-    fprintf(stderr, &quot;Client Random:\n&quot;);
-    BIO_dump_fp(stderr, (char *)s-&gt;s3-&gt;client_random, SSL3_RANDOM_SIZE);
-    fprintf(stderr, &quot;Server Random:\n&quot;);
-    BIO_dump_fp(stderr, (char *)s-&gt;s3-&gt;server_random, SSL3_RANDOM_SIZE);
-    fprintf(stderr, &quot;Master Secret:\n&quot;);
-    BIO_dump_fp(stderr, (char *)s-&gt;session-&gt;master_key,
-                SSL3_MASTER_SECRET_SIZE);
-#endif
+
+    OSSL_TRACE_BEGIN(TLS) {
+        BIO_printf(trc_out, &quot;Premaster Secret:\n&quot;);
+        BIO_dump_indent(trc_out, p, len, 4);
+        BIO_printf(trc_out, &quot;Client Random:\n&quot;);
+        BIO_dump_indent(trc_out, s-&gt;s3-&gt;client_random, SSL3_RANDOM_SIZE, 4);
+        BIO_printf(trc_out, &quot;Server Random:\n&quot;);
+        BIO_dump_indent(trc_out, s-&gt;s3-&gt;server_random, SSL3_RANDOM_SIZE, 4);
+        BIO_printf(trc_out, &quot;Master Secret:\n&quot;);
+        BIO_dump_indent(trc_out,
+                        s-&gt;session-&gt;master_key,
+                        SSL3_MASTER_SECRET_SIZE, 4);
+    } OSSL_TRACE_END(TLS);
 
     *secret_size = SSL3_MASTER_SECRET_SIZE;
     return 1;
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 9957cf8..cb0cb22 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4646,3 +4646,12 @@ OPENSSL_CTX_free                        4601	3_0_0	EXIST::FUNCTION:
 OPENSSL_LH_flush                        4602	3_0_0	EXIST::FUNCTION:
 BN_native2bn                            4603	3_0_0	EXIST::FUNCTION:
 BN_bn2nativepad                         4604	3_0_0	EXIST::FUNCTION:
+OSSL_trace_get_category_num             4605	3_0_0	EXIST::FUNCTION:
+OSSL_trace_get_category_name            4606	3_0_0	EXIST::FUNCTION:
+OSSL_trace_set_channel                  4607	3_0_0	EXIST::FUNCTION:
+OSSL_trace_set_prefix                   4608	3_0_0	EXIST::FUNCTION:
+OSSL_trace_set_suffix                   4609	3_0_0	EXIST::FUNCTION:
+OSSL_trace_set_callback                 4610	3_0_0	EXIST::FUNCTION:
+OSSL_trace_enabled                      4611	3_0_0	EXIST::FUNCTION:
+OSSL_trace_begin                        4612	3_0_0	EXIST::FUNCTION:
+OSSL_trace_end                          4613	3_0_0	EXIST::FUNCTION:
diff --git a/util/private.num b/util/private.num
index d8aba4d..ad1865f 100644
--- a/util/private.num
+++ b/util/private.num
@@ -47,6 +47,7 @@ OSSL_STORE_error_fn                     datatype
 OSSL_STORE_load_fn                      datatype
 OSSL_STORE_open_fn                      datatype
 OSSL_STORE_post_process_info_fn         datatype
+OSSL_trace_cb                           datatype
 PROFESSION_INFO                         datatype
 PROFESSION_INFOS                        datatype
 RAND_DRBG_cleanup_entropy_fn            datatype
</PRE>








<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="022207.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="022213.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22210">[ date ]</a>
              <a href="thread.html#22210">[ thread ]</a>
              <a href="subject.html#22210">[ subject ]</a>
              <a href="author.html#22210">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
