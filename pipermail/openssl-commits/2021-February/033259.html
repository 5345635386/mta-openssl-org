<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2021-February/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1614303361.499890.29386.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="033258.html">
   <LINK REL="Next"  HREF="033261.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>shane.lontis at oracle.com</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1614303361.499890.29386.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">shane.lontis at oracle.com
       </A><BR>
    <I>Fri Feb 26 01:36:01 UTC 2021</I>
    <P><UL>
        <LI>Previous message: <A HREF="033258.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="033261.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33259">[ date ]</a>
              <a href="thread.html#33259">[ thread ]</a>
              <a href="subject.html#33259">[ subject ]</a>
              <a href="author.html#33259">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  32ab57cbb4877ce7e6b4eb3f9b3cfbb0ff7cd10b (commit)
       via  5af02212a5331cc30389246bb94f97fbcdebc23a (commit)
       via  19dbb742cdf68d8ada6338a025491a3b46b9ebe1 (commit)
      from  94553e85b68af4513a8ee89cd2a0d4e044d75139 (commit)


- Log -----------------------------------------------------------------
commit 32ab57cbb4877ce7e6b4eb3f9b3cfbb0ff7cd10b
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Thu Feb 18 20:27:26 2021 +1000

    Fix external symbols related to ec &amp; sm2 keys
    
    Partial fix for #12964
    
    This adds ossl_ names for the following symbols:
    
    ec_*, ecx_*, ecdh_*, ecdsa_*, sm2_*
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/14231">https://github.com/openssl/openssl/pull/14231</A>)

commit 5af02212a5331cc30389246bb94f97fbcdebc23a
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Thu Feb 18 16:30:37 2021 +1000

    Fix external symbols related to dsa keys
    
    Partial fix for #12964
    
    This adds ossl_ names for the following symbols:
    
    dsa_check_pairwise, dsa_check_params, dsa_check_priv_key, dsa_check_pub_key, dsa_check_pub_key_partial,
    dsa_do_sign_int, dsa_ffc_params_fromdata,
    dsa_generate_ffc_parameters, dsa_generate_public_key,
    dsa_get0_params, dsa_key_fromdata, dsa_new_with_ctx, dsa_pkey_method, dsa_sign_int
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/14231">https://github.com/openssl/openssl/pull/14231</A>)

commit 19dbb742cdf68d8ada6338a025491a3b46b9ebe1
Author: Shane Lontis &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">shane.lontis at oracle.com</A>&gt;
Date:   Thu Feb 18 15:56:53 2021 +1000

    Fix external symbols related to dh keys
    
    Partial fix for #12964
    
    This adds ossl_ names for the following symbols:
    
    dh_new_by_nid_ex, dh_new_ex, dh_generate_ffc_parameters, dh_generate_public_key,
    dh_get_named_group_uid_from_size, dh_gen_type_id2name, dh_gen_type_name2id,
    dh_cache_named_group, dh_get0_params, dh_get0_nid,
    dh_params_fromdata, dh_key_fromdata, dh_params_todata, dh_key_todata,
    dh_check_pub_key_partial, dh_check_priv_key, dh_check_pairwise,
    dh_get_method, dh_buf2key, dh_key2buf, dh_KDF_X9_42_asn1,
    dh_pkey_method, dhx_pkey_method
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/14231">https://github.com/openssl/openssl/pull/14231</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/dh/dh_ameth.c                               |  12 +-
 crypto/dh/dh_asn1.c                                |   2 +-
 crypto/dh/dh_backend.c                             |  14 +-
 crypto/dh/dh_check.c                               |   8 +-
 crypto/dh/dh_gen.c                                 |  10 +-
 crypto/dh/dh_group_params.c                        |   8 +-
 crypto/dh/dh_kdf.c                                 |  15 +-
 crypto/dh/dh_key.c                                 |  11 +-
 crypto/dh/dh_lib.c                                 |  10 +-
 crypto/dh/dh_pmeth.c                               |   4 +-
 crypto/dsa/dsa_ameth.c                             |   6 +-
 crypto/dsa/dsa_backend.c                           |   2 +-
 crypto/dsa/dsa_check.c                             |  12 +-
 crypto/dsa/dsa_gen.c                               |  12 +-
 crypto/dsa/dsa_key.c                               |   6 +-
 crypto/dsa/dsa_lib.c                               |  10 +-
 crypto/dsa/dsa_local.h                             |   2 +-
 crypto/dsa/dsa_ossl.c                              |   4 +-
 crypto/dsa/dsa_pmeth.c                             |   2 +-
 crypto/dsa/dsa_sign.c                              |   9 +-
 crypto/ec/ec2_oct.c                                |  21 +-
 crypto/ec/ec2_smpl.c                               | 180 ++++----
 crypto/ec/ec_ameth.c                               |   8 +-
 crypto/ec/ec_asn1.c                                |   2 +-
 crypto/ec/ec_backend.c                             |  52 +--
 crypto/ec/ec_check.c                               |   2 +-
 crypto/ec/ec_curve.c                               |  12 +-
 crypto/ec/ec_cvt.c                                 |   4 +-
 crypto/ec/ec_key.c                                 |  46 +-
 crypto/ec/ec_kmeth.c                               |   6 +-
 crypto/ec/ec_lib.c                                 |  45 +-
 crypto/ec/ec_local.h                               | 498 +++++++++++----------
 crypto/ec/ec_mult.c                                |  29 +-
 crypto/ec/ec_oct.c                                 |  19 +-
 crypto/ec/ec_pmeth.c                               |   8 +-
 crypto/ec/ecdh_kdf.c                               |  13 +-
 crypto/ec/ecdh_ossl.c                              |   4 +-
 crypto/ec/ecdsa_ossl.c                             |  18 +-
 crypto/ec/ecp_mont.c                               | 133 +++---
 crypto/ec/ecp_nist.c                               |  99 ++--
 crypto/ec/ecp_nistp224.c                           | 160 +++----
 crypto/ec/ecp_nistp256.c                           | 158 +++----
 crypto/ec/ecp_nistp521.c                           | 164 +++----
 crypto/ec/ecp_nistputil.c                          |   7 +-
 crypto/ec/ecp_nistz256.c                           |  76 ++--
 crypto/ec/ecp_oct.c                                |  19 +-
 crypto/ec/ecp_s390x_nistp.c                        |  80 ++--
 crypto/ec/ecp_smpl.c                               | 215 ++++-----
 crypto/ec/ecx_backend.c                            |   8 +-
 crypto/ec/ecx_key.c                                |  12 +-
 crypto/ec/ecx_meth.c                               |  58 +--
 crypto/evp/ctrl_params_translate.c                 |  10 +-
 crypto/evp/dh_support.c                            |   4 +-
 crypto/evp/ec_support.c                            |  12 +-
 crypto/evp/p_lib.c                                 |   4 +-
 crypto/evp/pmeth_lib.c                             |  17 +-
 crypto/sm2/sm2_crypt.c                             |  42 +-
 crypto/sm2/sm2_key.c                               |   2 +-
 crypto/sm2/sm2_sign.c                              |  58 +--
 include/crypto/dh.h                                |  65 +--
 include/crypto/dsa.h                               |  31 +-
 include/crypto/ec.h                                |  68 +--
 include/crypto/ecx.h                               |  29 +-
 include/crypto/evp.h                               |  16 +-
 include/crypto/sm2.h                               |  66 +--
 providers/implementations/asymciphers/sm2_enc.c    |   8 +-
 .../implementations/encode_decode/decode_der2key.c |  20 +-
 .../encode_decode/encode_key2text.c                |  12 +-
 providers/implementations/exchange/dh_exch.c       |  14 +-
 providers/implementations/exchange/ecdh_exch.c     |  14 +-
 providers/implementations/exchange/ecx_exch.c      |  18 +-
 providers/implementations/keymgmt/dh_kmgmt.c       |  54 +--
 providers/implementations/keymgmt/dsa_kmgmt.c      |  34 +-
 providers/implementations/keymgmt/ec_kmgmt.c       |  68 +--
 providers/implementations/keymgmt/ecx_kmgmt.c      |  55 +--
 providers/implementations/signature/dsa.c          |   2 +-
 providers/implementations/signature/eddsa.c        |   6 +-
 providers/implementations/signature/sm2sig.c       |   7 +-
 test/ec_internal_test.c                            |   4 +-
 test/ffc_internal_test.c                           |   8 +-
 test/sm2_internal_test.c                           |  21 +-
 81 files changed, 1565 insertions(+), 1519 deletions(-)

diff --git a/crypto/dh/dh_ameth.c b/crypto/dh/dh_ameth.c
index 1cf692ee13..338f308934 100644
--- a/crypto/dh/dh_ameth.c
+++ b/crypto/dh/dh_ameth.c
@@ -433,9 +433,9 @@ static int dh_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
 {
     switch (op) {
     case ASN1_PKEY_CTRL_SET1_TLS_ENCPT:
-        return dh_buf2key(EVP_PKEY_get0_DH(pkey), arg2, arg1);
+        return ossl_dh_buf2key(EVP_PKEY_get0_DH(pkey), arg2, arg1);
     case ASN1_PKEY_CTRL_GET1_TLS_ENCPT:
-        return dh_key2buf(EVP_PKEY_get0_DH(pkey), arg2, 0, 1);
+        return ossl_dh_key2buf(EVP_PKEY_get0_DH(pkey), arg2, 0, 1);
     default:
         return -2;
     }
@@ -492,7 +492,7 @@ static int dh_pkey_export_to(const EVP_PKEY *from, void *to_keydata,
      * If the DH method is foreign, then we can't be sure of anything, and
      * can therefore not export or pretend to export.
      */
-    if (dh_get_method(dh) != DH_OpenSSL())
+    if (ossl_dh_get_method(dh) != DH_OpenSSL())
         return 0;
 
     if (p == NULL || g == NULL)
@@ -543,7 +543,7 @@ static int dh_pkey_import_from_type(const OSSL_PARAM params[], void *vpctx,
 {
     EVP_PKEY_CTX *pctx = vpctx;
     EVP_PKEY *pkey = EVP_PKEY_CTX_get0_pkey(pctx);
-    DH *dh = dh_new_ex(pctx-&gt;libctx);
+    DH *dh = ossl_dh_new_ex(pctx-&gt;libctx);
 
     if (dh == NULL) {
         ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
@@ -552,8 +552,8 @@ static int dh_pkey_import_from_type(const OSSL_PARAM params[], void *vpctx,
     DH_clear_flags(dh, DH_FLAG_TYPE_MASK);
     DH_set_flags(dh, type == EVP_PKEY_DH ? DH_FLAG_TYPE_DH : DH_FLAG_TYPE_DHX);
 
-    if (!dh_params_fromdata(dh, params)
-        || !dh_key_fromdata(dh, params)
+    if (!ossl_dh_params_fromdata(dh, params)
+        || !ossl_dh_key_fromdata(dh, params)
         || !EVP_PKEY_assign(pkey, type, dh)) {
         DH_free(dh);
         return 0;
diff --git a/crypto/dh/dh_asn1.c b/crypto/dh/dh_asn1.c
index 68013219e7..5c8af108f5 100644
--- a/crypto/dh/dh_asn1.c
+++ b/crypto/dh/dh_asn1.c
@@ -39,7 +39,7 @@ static int dh_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
 
         DH_clear_flags(dh, DH_FLAG_TYPE_MASK);
         DH_set_flags(dh, DH_FLAG_TYPE_DH);
-        dh_cache_named_group(dh);
+        ossl_dh_cache_named_group(dh);
         dh-&gt;dirty_cnt++;
     }
     return 1;
diff --git a/crypto/dh/dh_backend.c b/crypto/dh/dh_backend.c
index 41de7b9006..c848cb4870 100644
--- a/crypto/dh/dh_backend.c
+++ b/crypto/dh/dh_backend.c
@@ -30,17 +30,17 @@ static int dh_ffc_params_fromdata(DH *dh, const OSSL_PARAM params[])
 
     if (dh == NULL)
         return 0;
-    ffc = dh_get0_params(dh);
+    ffc = ossl_dh_get0_params(dh);
     if (ffc == NULL)
         return 0;
 
     ret = ossl_ffc_params_fromdata(ffc, params);
     if (ret)
-        dh_cache_named_group(dh); /* This increments dh-&gt;dirty_cnt */
+        ossl_dh_cache_named_group(dh); /* This increments dh-&gt;dirty_cnt */
     return ret;
 }
 
-int dh_params_fromdata(DH *dh, const OSSL_PARAM params[])
+int ossl_dh_params_fromdata(DH *dh, const OSSL_PARAM params[])
 {
     const OSSL_PARAM *param_priv_len;
     long priv_len;
@@ -58,7 +58,7 @@ int dh_params_fromdata(DH *dh, const OSSL_PARAM params[])
     return 1;
 }
 
-int dh_key_fromdata(DH *dh, const OSSL_PARAM params[])
+int ossl_dh_key_fromdata(DH *dh, const OSSL_PARAM params[])
 {
     const OSSL_PARAM *param_priv_key, *param_pub_key;
     BIGNUM *priv_key = NULL, *pub_key = NULL;
@@ -86,11 +86,11 @@ int dh_key_fromdata(DH *dh, const OSSL_PARAM params[])
     return 0;
 }
 
-int dh_params_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[])
+int ossl_dh_params_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[])
 {
     long l = DH_get_length(dh);
 
-    if (!ossl_ffc_params_todata(dh_get0_params(dh), bld, params))
+    if (!ossl_ffc_params_todata(ossl_dh_get0_params(dh), bld, params))
         return 0;
     if (l &gt; 0
         &amp;&amp; !ossl_param_build_set_long(bld, params, OSSL_PKEY_PARAM_DH_PRIV_LEN, l))
@@ -98,7 +98,7 @@ int dh_params_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[])
     return 1;
 }
 
-int dh_key_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[])
+int ossl_dh_key_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[])
 {
     const BIGNUM *priv = NULL, *pub = NULL;
 
diff --git a/crypto/dh/dh_check.c b/crypto/dh/dh_check.c
index 5cbbdbf8c5..90697340f7 100644
--- a/crypto/dh/dh_check.c
+++ b/crypto/dh/dh_check.c
@@ -243,12 +243,12 @@ int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)
  * To only be used with ephemeral FFC public keys generated using the approved
  * safe-prime groups.
  */
-int dh_check_pub_key_partial(const DH *dh, const BIGNUM *pub_key, int *ret)
+int ossl_dh_check_pub_key_partial(const DH *dh, const BIGNUM *pub_key, int *ret)
 {
     return ossl_ffc_validate_public_key_partial(&amp;dh-&gt;params, pub_key, ret);
 }
 
-int dh_check_priv_key(const DH *dh, const BIGNUM *priv_key, int *ret)
+int ossl_dh_check_priv_key(const DH *dh, const BIGNUM *priv_key, int *ret)
 {
     int ok = 0;
     BIGNUM *two_powN = NULL, *upper;
@@ -281,7 +281,7 @@ err:
  * FFC pairwise check from SP800-56A R3.
  *    Section 5.6.2.1.4 Owner Assurance of Pair-wise Consistency
  */
-int dh_check_pairwise(const DH *dh)
+int ossl_dh_check_pairwise(const DH *dh)
 {
     int ret = 0;
     BN_CTX *ctx = NULL;
@@ -301,7 +301,7 @@ int dh_check_pairwise(const DH *dh)
         goto err;
 
     /* recalculate the public key = (g ^ priv) mod p */
-    if (!dh_generate_public_key(ctx, dh, dh-&gt;priv_key, pub_key))
+    if (!ossl_dh_generate_public_key(ctx, dh, dh-&gt;priv_key, pub_key))
         goto err;
     /* check it matches the existing pubic_key */
     ret = BN_cmp(pub_key, dh-&gt;pub_key) == 0;
diff --git a/crypto/dh/dh_gen.c b/crypto/dh/dh_gen.c
index bdc0dc79b8..aecf7195d8 100644
--- a/crypto/dh/dh_gen.c
+++ b/crypto/dh/dh_gen.c
@@ -35,8 +35,8 @@ static int dh_builtin_genparams(DH *ret, int prime_len, int generator,
                                 BN_GENCB *cb);
 #endif /* FIPS_MODULE */
 
-int dh_generate_ffc_parameters(DH *dh, int type, int pbits, int qbits,
-                               BN_GENCB *cb)
+int ossl_dh_generate_ffc_parameters(DH *dh, int type, int pbits, int qbits,
+                                    BN_GENCB *cb)
 {
     int ret, res;
 
@@ -55,7 +55,7 @@ int dh_generate_ffc_parameters(DH *dh, int type, int pbits, int qbits,
     return ret;
 }
 
-int dh_get_named_group_uid_from_size(int pbits)
+int ossl_dh_get_named_group_uid_from_size(int pbits)
 {
     /*
      * Just choose an approved safe prime group.
@@ -95,12 +95,12 @@ static int dh_gen_named_group(OSSL_LIB_CTX *libctx, DH *ret, int prime_len)
 {
     DH *dh;
     int ok = 0;
-    int nid = dh_get_named_group_uid_from_size(prime_len);
+    int nid = ossl_dh_get_named_group_uid_from_size(prime_len);
 
     if (nid == NID_undef)
         return 0;
 
-    dh = dh_new_by_nid_ex(libctx, nid);
+    dh = ossl_dh_new_by_nid_ex(libctx, nid);
     if (dh != NULL
         &amp;&amp; ossl_ffc_params_copy(&amp;ret-&gt;params, &amp;dh-&gt;params)) {
         ok = 1;
diff --git a/crypto/dh/dh_group_params.c b/crypto/dh/dh_group_params.c
index 0f66d8969d..72082d6f50 100644
--- a/crypto/dh/dh_group_params.c
+++ b/crypto/dh/dh_group_params.c
@@ -27,7 +27,7 @@
 
 static DH *dh_param_init(OSSL_LIB_CTX *libctx, const DH_NAMED_GROUP *group)
 {
-    DH *dh = dh_new_ex(libctx);
+    DH *dh = ossl_dh_new_ex(libctx);
 
     if (dh == NULL)
         return NULL;
@@ -39,7 +39,7 @@ static DH *dh_param_init(OSSL_LIB_CTX *libctx, const DH_NAMED_GROUP *group)
     return dh;
 }
 
-DH *dh_new_by_nid_ex(OSSL_LIB_CTX *libctx, int nid)
+DH *ossl_dh_new_by_nid_ex(OSSL_LIB_CTX *libctx, int nid)
 {
     const DH_NAMED_GROUP *group;
 
@@ -52,10 +52,10 @@ DH *dh_new_by_nid_ex(OSSL_LIB_CTX *libctx, int nid)
 
 DH *DH_new_by_nid(int nid)
 {
-    return dh_new_by_nid_ex(NULL, nid);
+    return ossl_dh_new_by_nid_ex(NULL, nid);
 }
 
-void dh_cache_named_group(DH *dh)
+void ossl_dh_cache_named_group(DH *dh)
 {
     const DH_NAMED_GROUP *group;
 
diff --git a/crypto/dh/dh_kdf.c b/crypto/dh/dh_kdf.c
index ea2cd6386c..e1753b0b69 100644
--- a/crypto/dh/dh_kdf.c
+++ b/crypto/dh/dh_kdf.c
@@ -25,11 +25,12 @@
 #include &lt;crypto/dh.h&gt;
 
 /* Key derivation function from X9.63/SECG */
-int dh_KDF_X9_42_asn1(unsigned char *out, size_t outlen,
-                      const unsigned char *Z, size_t Zlen,
-                      const char *cek_alg,
-                      const unsigned char *ukm, size_t ukmlen, const EVP_MD *md,
-                      OSSL_LIB_CTX *libctx, const char *propq)
+int ossl_dh_kdf_X9_42_asn1(unsigned char *out, size_t outlen,
+                           const unsigned char *Z, size_t Zlen,
+                           const char *cek_alg,
+                           const unsigned char *ukm, size_t ukmlen,
+                           const EVP_MD *md,
+                           OSSL_LIB_CTX *libctx, const char *propq)
 {
     int ret = 0;
     EVP_KDF_CTX *kctx = NULL;
@@ -78,7 +79,7 @@ int DH_KDF_X9_42(unsigned char *out, size_t outlen,
     if (key_alg == NULL)
         return 0;
 
-    return dh_KDF_X9_42_asn1(out, outlen, Z, Zlen, key_alg,
-                             ukm, ukmlen, md, libctx, NULL);
+    return ossl_dh_kdf_X9_42_asn1(out, outlen, Z, Zlen, key_alg,
+                                  ukm, ukmlen, md, libctx, NULL);
 }
 #endif /* !defined(FIPS_MODULE) */
diff --git a/crypto/dh/dh_key.c b/crypto/dh/dh_key.c
index f8cbbd593b..f282a12b4c 100644
--- a/crypto/dh/dh_key.c
+++ b/crypto/dh/dh_key.c
@@ -210,8 +210,8 @@ int DH_generate_key(DH *dh)
 #endif
 }
 
-int dh_generate_public_key(BN_CTX *ctx, const DH *dh, const BIGNUM *priv_key,
-                           BIGNUM *pub_key)
+int ossl_dh_generate_public_key(BN_CTX *ctx, const DH *dh,
+                                const BIGNUM *priv_key, BIGNUM *pub_key)
 {
     int ret = 0;
     BIGNUM *prk = BN_new();
@@ -344,7 +344,7 @@ static int generate_key(DH *dh)
         }
     }
 
-    if (!dh_generate_public_key(ctx, dh, priv_key, pub_key))
+    if (!ossl_dh_generate_public_key(ctx, dh, priv_key, pub_key))
         goto err;
 
     dh-&gt;pub_key = pub_key;
@@ -363,7 +363,7 @@ static int generate_key(DH *dh)
     return ok;
 }
 
-int dh_buf2key(DH *dh, const unsigned char *buf, size_t len)
+int ossl_dh_buf2key(DH *dh, const unsigned char *buf, size_t len)
 {
     int err_reason = DH_R_BN_ERROR;
     BIGNUM *pubkey = NULL;
@@ -394,7 +394,8 @@ err:
     return 0;
 }
 
-size_t dh_key2buf(const DH *dh, unsigned char **pbuf_out, size_t size, int alloc)
+size_t ossl_dh_key2buf(const DH *dh, unsigned char **pbuf_out, size_t size,
+                       int alloc)
 {
     const BIGNUM *pubkey;
     unsigned char *pbuf = NULL;
diff --git a/crypto/dh/dh_lib.c b/crypto/dh/dh_lib.c
index e3db7a4929..78b984157d 100644
--- a/crypto/dh/dh_lib.c
+++ b/crypto/dh/dh_lib.c
@@ -47,7 +47,7 @@ int DH_set_method(DH *dh, const DH_METHOD *meth)
     return 1;
 }
 
-const DH_METHOD *dh_get_method(const DH *dh)
+const DH_METHOD *ossl_dh_get_method(const DH *dh)
 {
     return dh-&gt;meth;
 }
@@ -64,7 +64,7 @@ DH *DH_new_method(ENGINE *engine)
 }
 #endif /* !FIPS_MODULE */
 
-DH *dh_new_ex(OSSL_LIB_CTX *libctx)
+DH *ossl_dh_new_ex(OSSL_LIB_CTX *libctx)
 {
     return dh_new_intern(NULL, libctx);
 }
@@ -230,7 +230,7 @@ int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)
         return 0;
 
     ossl_ffc_params_set0_pqg(&amp;dh-&gt;params, p, q, g);
-    dh_cache_named_group(dh);
+    ossl_dh_cache_named_group(dh);
     dh-&gt;dirty_cnt++;
     return 1;
 }
@@ -317,11 +317,11 @@ ENGINE *DH_get0_engine(DH *dh)
 }
 #endif /*FIPS_MODULE */
 
-FFC_PARAMS *dh_get0_params(DH *dh)
+FFC_PARAMS *ossl_dh_get0_params(DH *dh)
 {
     return &amp;dh-&gt;params;
 }
-int dh_get0_nid(const DH *dh)
+int ossl_dh_get0_nid(const DH *dh)
 {
     return dh-&gt;params.nid;
 }
diff --git a/crypto/dh/dh_pmeth.c b/crypto/dh/dh_pmeth.c
index 11f30ce702..4a18205a7f 100644
--- a/crypto/dh/dh_pmeth.c
+++ b/crypto/dh/dh_pmeth.c
@@ -509,7 +509,7 @@ static const EVP_PKEY_METHOD dh_pkey_meth = {
     pkey_dh_ctrl_str
 };
 
-const EVP_PKEY_METHOD *dh_pkey_method(void)
+const EVP_PKEY_METHOD *ossl_dh_pkey_method(void)
 {
     return &amp;dh_pkey_meth;
 }
@@ -548,7 +548,7 @@ static const EVP_PKEY_METHOD dhx_pkey_meth = {
     pkey_dh_ctrl_str
 };
 
-const EVP_PKEY_METHOD *dhx_pkey_method(void)
+const EVP_PKEY_METHOD *ossl_dhx_pkey_method(void)
 {
     return &amp;dhx_pkey_meth;
 }
diff --git a/crypto/dsa/dsa_ameth.c b/crypto/dsa/dsa_ameth.c
index 3b35a7005e..c073f6b799 100644
--- a/crypto/dsa/dsa_ameth.c
+++ b/crypto/dsa/dsa_ameth.c
@@ -539,15 +539,15 @@ static int dsa_pkey_import_from(const OSSL_PARAM params[], void *vpctx)
 {
     EVP_PKEY_CTX *pctx = vpctx;
     EVP_PKEY *pkey = EVP_PKEY_CTX_get0_pkey(pctx);
-    DSA *dsa = dsa_new_with_ctx(pctx-&gt;libctx);
+    DSA *dsa = ossl_dsa_new(pctx-&gt;libctx);
 
     if (dsa == NULL) {
         ERR_raise(ERR_LIB_DSA, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
-    if (!dsa_ffc_params_fromdata(dsa, params)
-        || !dsa_key_fromdata(dsa, params)
+    if (!ossl_dsa_ffc_params_fromdata(dsa, params)
+        || !ossl_dsa_key_fromdata(dsa, params)
         || !EVP_PKEY_assign_DSA(pkey, dsa)) {
         DSA_free(dsa);
         return 0;
diff --git a/crypto/dsa/dsa_backend.c b/crypto/dsa/dsa_backend.c
index d24d08eebd..e6f8f3645e 100644
--- a/crypto/dsa/dsa_backend.c
+++ b/crypto/dsa/dsa_backend.c
@@ -22,7 +22,7 @@
  * implementations alike.
  */
 
-int dsa_key_fromdata(DSA *dsa, const OSSL_PARAM params[])
+int ossl_dsa_key_fromdata(DSA *dsa, const OSSL_PARAM params[])
 {
     const OSSL_PARAM *param_priv_key, *param_pub_key;
     BIGNUM *priv_key = NULL, *pub_key = NULL;
diff --git a/crypto/dsa/dsa_check.c b/crypto/dsa/dsa_check.c
index 7f56a785ab..705c7d22a0 100644
--- a/crypto/dsa/dsa_check.c
+++ b/crypto/dsa/dsa_check.c
@@ -19,7 +19,7 @@
 #include &quot;dsa_local.h&quot;
 #include &quot;crypto/dsa.h&quot;
 
-int dsa_check_params(const DSA *dsa, int checktype, int *ret)
+int ossl_dsa_check_params(const DSA *dsa, int checktype, int *ret)
 {
     if (checktype == OSSL_KEYMGMT_VALIDATE_QUICK_CHECK)
         return ossl_ffc_params_simple_validate(dsa-&gt;libctx, &amp;dsa-&gt;params,
@@ -37,7 +37,7 @@ int dsa_check_params(const DSA *dsa, int checktype, int *ret)
 /*
  * See SP800-56Ar3 Section 5.6.2.3.1 : FFC Full public key validation.
  */
-int dsa_check_pub_key(const DSA *dsa, const BIGNUM *pub_key, int *ret)
+int ossl_dsa_check_pub_key(const DSA *dsa, const BIGNUM *pub_key, int *ret)
 {
     return ossl_ffc_validate_public_key(&amp;dsa-&gt;params, pub_key, ret);
 }
@@ -47,12 +47,12 @@ int dsa_check_pub_key(const DSA *dsa, const BIGNUM *pub_key, int *ret)
  * To only be used with ephemeral FFC public keys generated using the approved
  * safe-prime groups.
  */
-int dsa_check_pub_key_partial(const DSA *dsa, const BIGNUM *pub_key, int *ret)
+int ossl_dsa_check_pub_key_partial(const DSA *dsa, const BIGNUM *pub_key, int *ret)
 {
     return ossl_ffc_validate_public_key_partial(&amp;dsa-&gt;params, pub_key, ret);
 }
 
-int dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)
+int ossl_dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)
 {
     *ret = 0;
 
@@ -64,7 +64,7 @@ int dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)
  * FFC pairwise check from SP800-56A R3.
  *    Section 5.6.2.1.4 Owner Assurance of Pair-wise Consistency
  */
-int dsa_check_pairwise(const DSA *dsa)
+int ossl_dsa_check_pairwise(const DSA *dsa)
 {
     int ret = 0;
     BN_CTX *ctx = NULL;
@@ -84,7 +84,7 @@ int dsa_check_pairwise(const DSA *dsa)
         goto err;
 
     /* recalculate the public key = (g ^ priv) mod p */
-    if (!dsa_generate_public_key(ctx, dsa, dsa-&gt;priv_key, pub_key))
+    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa-&gt;priv_key, pub_key))
         goto err;
     /* check it matches the existing pubic_key */
     ret = BN_cmp(pub_key, dsa-&gt;pub_key) == 0;
diff --git a/crypto/dsa/dsa_gen.c b/crypto/dsa/dsa_gen.c
index 9d6d9a8d4a..2be9f48e27 100644
--- a/crypto/dsa/dsa_gen.c
+++ b/crypto/dsa/dsa_gen.c
@@ -23,8 +23,8 @@
 #include &quot;crypto/dsa.h&quot;
 #include &quot;dsa_local.h&quot;
 
-int dsa_generate_ffc_parameters(DSA *dsa, int type, int pbits, int qbits,
-                                BN_GENCB *cb)
+int ossl_dsa_generate_ffc_parameters(DSA *dsa, int type, int pbits, int qbits,
+                                     BN_GENCB *cb)
 {
     int ret = 0, res;
 
@@ -59,12 +59,12 @@ int DSA_generate_parameters_ex(DSA *dsa, int bits,
 
     /* The old code used FIPS 186-2 DSA Parameter generation */
     if (bits &lt;= 1024 &amp;&amp; seed_len == 20) {
-        if (!dsa_generate_ffc_parameters(dsa, DSA_PARAMGEN_TYPE_FIPS_186_2,
-                                         bits, 160, cb))
+        if (!ossl_dsa_generate_ffc_parameters(dsa, DSA_PARAMGEN_TYPE_FIPS_186_2,
+                                              bits, 160, cb))
             return 0;
     } else {
-        if (!dsa_generate_ffc_parameters(dsa, DSA_PARAMGEN_TYPE_FIPS_186_4,
-                                         bits, 0, cb))
+        if (!ossl_dsa_generate_ffc_parameters(dsa, DSA_PARAMGEN_TYPE_FIPS_186_4,
+                                              bits, 0, cb))
             return 0;
     }
 
diff --git a/crypto/dsa/dsa_key.c b/crypto/dsa/dsa_key.c
index 8646d01957..2b7dc4e43d 100644
--- a/crypto/dsa/dsa_key.c
+++ b/crypto/dsa/dsa_key.c
@@ -40,8 +40,8 @@ int DSA_generate_key(DSA *dsa)
     return dsa_keygen(dsa, 0);
 }
 
-int dsa_generate_public_key(BN_CTX *ctx, const DSA *dsa, const BIGNUM *priv_key,
-                            BIGNUM *pub_key)
+int ossl_dsa_generate_public_key(BN_CTX *ctx, const DSA *dsa,
+                                 const BIGNUM *priv_key, BIGNUM *pub_key)
 {
     int ret = 0;
     BIGNUM *prk = BN_new();
@@ -97,7 +97,7 @@ static int dsa_keygen(DSA *dsa, int pairwise_test)
         pub_key = dsa-&gt;pub_key;
     }
 
-    if (!dsa_generate_public_key(ctx, dsa, priv_key, pub_key))
+    if (!ossl_dsa_generate_public_key(ctx, dsa, priv_key, pub_key))
         goto err;
 
     dsa-&gt;priv_key = priv_key;
diff --git a/crypto/dsa/dsa_lib.c b/crypto/dsa/dsa_lib.c
index 7e5be3208d..5de633e11e 100644
--- a/crypto/dsa/dsa_lib.c
+++ b/crypto/dsa/dsa_lib.c
@@ -52,7 +52,7 @@ DH *DSA_dup_DH(const DSA *r)
     if (ret == NULL)
         goto err;
 
-    if (!ossl_ffc_params_copy(dh_get0_params(ret), &amp;r-&gt;params))
+    if (!ossl_ffc_params_copy(ossl_dh_get0_params(ret), &amp;r-&gt;params))
         goto err;
 
     if (r-&gt;pub_key != NULL) {
@@ -190,7 +190,7 @@ DSA *DSA_new_method(ENGINE *engine)
     return dsa_new_intern(engine, NULL);
 }
 
-DSA *dsa_new_with_ctx(OSSL_LIB_CTX *libctx)
+DSA *ossl_dsa_new(OSSL_LIB_CTX *libctx)
 {
     return dsa_new_intern(NULL, libctx);
 }
@@ -336,19 +336,19 @@ int DSA_bits(const DSA *dsa)
     return -1;
 }
 
-FFC_PARAMS *dsa_get0_params(DSA *dsa)
+FFC_PARAMS *ossl_dsa_get0_params(DSA *dsa)
 {
     return &amp;dsa-&gt;params;
 }
 
-int dsa_ffc_params_fromdata(DSA *dsa, const OSSL_PARAM params[])
+int ossl_dsa_ffc_params_fromdata(DSA *dsa, const OSSL_PARAM params[])
 {
     int ret;
     FFC_PARAMS *ffc;
 
     if (dsa == NULL)
         return 0;
-    ffc = dsa_get0_params(dsa);
+    ffc = ossl_dsa_get0_params(dsa);
     if (ffc == NULL)
         return 0;
 
diff --git a/crypto/dsa/dsa_local.h b/crypto/dsa/dsa_local.h
index 240e84f11e..c4ed654b99 100644
--- a/crypto/dsa/dsa_local.h
+++ b/crypto/dsa/dsa_local.h
@@ -69,4 +69,4 @@ struct dsa_method {
     int (*dsa_keygen) (DSA *dsa);
 };
 
-DSA_SIG *dsa_do_sign_int(const unsigned char *dgst, int dlen, DSA *dsa);
+DSA_SIG *ossl_dsa_do_sign_int(const unsigned char *dgst, int dlen, DSA *dsa);
diff --git a/crypto/dsa/dsa_ossl.c b/crypto/dsa/dsa_ossl.c
index bd51a2c716..2f8cbe8ad4 100644
--- a/crypto/dsa/dsa_ossl.c
+++ b/crypto/dsa/dsa_ossl.c
@@ -67,7 +67,7 @@ const DSA_METHOD *DSA_OpenSSL(void)
     return &amp;openssl_dsa_meth;
 }
 
-DSA_SIG *dsa_do_sign_int(const unsigned char *dgst, int dlen, DSA *dsa)
+DSA_SIG *ossl_dsa_do_sign_int(const unsigned char *dgst, int dlen, DSA *dsa)
 {
     BIGNUM *kinv = NULL;
     BIGNUM *m, *blind, *blindm, *tmp;
@@ -185,7 +185,7 @@ DSA_SIG *dsa_do_sign_int(const unsigned char *dgst, int dlen, DSA *dsa)
 
 static DSA_SIG *dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)
 {
-    return dsa_do_sign_int(dgst, dlen, dsa);
+    return ossl_dsa_do_sign_int(dgst, dlen, dsa);
 }
 
 static int dsa_sign_setup_no_digest(DSA *dsa, BN_CTX *ctx_in,
diff --git a/crypto/dsa/dsa_pmeth.c b/crypto/dsa/dsa_pmeth.c
index 909be63867..e5709b62c9 100644
--- a/crypto/dsa/dsa_pmeth.c
+++ b/crypto/dsa/dsa_pmeth.c
@@ -281,7 +281,7 @@ static const EVP_PKEY_METHOD dsa_pkey_meth = {
     pkey_dsa_ctrl_str
 };
 
-const EVP_PKEY_METHOD *dsa_pkey_method(void)
+const EVP_PKEY_METHOD *ossl_dsa_pkey_method(void)
 {
     return &amp;dsa_pkey_meth;
 }
diff --git a/crypto/dsa/dsa_sign.c b/crypto/dsa/dsa_sign.c
index 0f866c12fe..84817d3009 100644
--- a/crypto/dsa/dsa_sign.c
+++ b/crypto/dsa/dsa_sign.c
@@ -150,8 +150,8 @@ int DSA_SIG_set0(DSA_SIG *sig, BIGNUM *r, BIGNUM *s)
     return 1;
 }
 
-int dsa_sign_int(int type, const unsigned char *dgst,
-                 int dlen, unsigned char *sig, unsigned int *siglen, DSA *dsa)
+int ossl_dsa_sign_int(int type, const unsigned char *dgst, int dlen,
+                      unsigned char *sig, unsigned int *siglen, DSA *dsa)
 {
     DSA_SIG *s;
 
@@ -159,7 +159,7 @@ int dsa_sign_int(int type, const unsigned char *dgst,
     if (dsa-&gt;libctx == NULL || dsa-&gt;meth != DSA_get_default_method())
         s = DSA_do_sign(dgst, dlen, dsa);
     else
-        s = dsa_do_sign_int(dgst, dlen, dsa);
+        s = ossl_dsa_do_sign_int(dgst, dlen, dsa);
     if (s == NULL) {
         *siglen = 0;
         return 0;
@@ -172,7 +172,7 @@ int dsa_sign_int(int type, const unsigned char *dgst,
 int DSA_sign(int type, const unsigned char *dgst, int dlen,
              unsigned char *sig, unsigned int *siglen, DSA *dsa)
 {
-    return dsa_sign_int(type, dgst, dlen, sig, siglen, dsa);
+    return ossl_dsa_sign_int(type, dgst, dlen, sig, siglen, dsa);
 }
 
 /* data has already been hashed (probably with SHA or SHA-1). */
@@ -206,4 +206,3 @@ int DSA_verify(int type, const unsigned char *dgst, int dgst_len,
     DSA_SIG_free(s);
     return ret;
 }
-
diff --git a/crypto/ec/ec2_oct.c b/crypto/ec/ec2_oct.c
index 5cfe28325c..7d894c4bef 100644
--- a/crypto/ec/ec2_oct.c
+++ b/crypto/ec/ec2_oct.c
@@ -36,10 +36,10 @@
  * the same method, but claim no priority date earlier than July 29, 1994
  * (and additionally fail to cite the EUROCRYPT '92 publication as prior art).
  */
-int ec_GF2m_simple_set_compressed_coordinates(const EC_GROUP *group,
-                                              EC_POINT *point,
-                                              const BIGNUM *x_, int y_bit,
-                                              BN_CTX *ctx)
+int ossl_ec_GF2m_simple_set_compressed_coordinates(const EC_GROUP *group,
+                                                   EC_POINT *point,
+                                                   const BIGNUM *x_, int y_bit,
+                                                   BN_CTX *ctx)
 {
     BIGNUM *tmp, *x, *y, *z;
     int ret = 0, z0;
@@ -122,9 +122,10 @@ int ec_GF2m_simple_set_compressed_coordinates(const EC_GROUP *group,
  * length will be returned. If the length len of buf is smaller than required
  * an error will be returned.
  */
-size_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
-                                point_conversion_form_t form,
-                                unsigned char *buf, size_t len, BN_CTX *ctx)
+size_t ossl_ec_GF2m_simple_point2oct(const EC_GROUP *group,
+                                     const EC_POINT *point,
+                                     point_conversion_form_t form,
+                                     unsigned char *buf, size_t len, BN_CTX *ctx)
 {
     size_t ret;
     int used_ctx = 0;
@@ -252,9 +253,9 @@ size_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
  * Converts an octet string representation to an EC_POINT. Note that the
  * simple implementation only uses affine coordinates.
  */
-int ec_GF2m_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
-                             const unsigned char *buf, size_t len,
-                             BN_CTX *ctx)
+int ossl_ec_GF2m_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
+                                  const unsigned char *buf, size_t len,
+                                  BN_CTX *ctx)
 {
     point_conversion_form_t form;
     int y_bit, m;
diff --git a/crypto/ec/ec2_smpl.c b/crypto/ec/ec2_smpl.c
index abac2a5cae..f58ce3367f 100644
--- a/crypto/ec/ec2_smpl.c
+++ b/crypto/ec/ec2_smpl.c
@@ -25,7 +25,7 @@
  * Initialize a GF(2^m)-based EC_GROUP structure. Note that all other members
  * are handled by EC_GROUP_new.
  */
-int ec_GF2m_simple_group_init(EC_GROUP *group)
+int ossl_ec_GF2m_simple_group_init(EC_GROUP *group)
 {
     group-&gt;field = BN_new();
     group-&gt;a = BN_new();
@@ -44,7 +44,7 @@ int ec_GF2m_simple_group_init(EC_GROUP *group)
  * Free a GF(2^m)-based EC_GROUP structure. Note that all other members are
  * handled by EC_GROUP_free.
  */
-void ec_GF2m_simple_group_finish(EC_GROUP *group)
+void ossl_ec_GF2m_simple_group_finish(EC_GROUP *group)
 {
     BN_free(group-&gt;field);
     BN_free(group-&gt;a);
@@ -55,7 +55,7 @@ void ec_GF2m_simple_group_finish(EC_GROUP *group)
  * Clear and free a GF(2^m)-based EC_GROUP structure. Note that all other
  * members are handled by EC_GROUP_clear_free.
  */
-void ec_GF2m_simple_group_clear_finish(EC_GROUP *group)
+void ossl_ec_GF2m_simple_group_clear_finish(EC_GROUP *group)
 {
     BN_clear_free(group-&gt;field);
     BN_clear_free(group-&gt;a);
@@ -72,7 +72,7 @@ void ec_GF2m_simple_group_clear_finish(EC_GROUP *group)
  * Copy a GF(2^m)-based EC_GROUP structure. Note that all other members are
  * handled by EC_GROUP_copy.
  */
-int ec_GF2m_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)
+int ossl_ec_GF2m_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)
 {
     if (!BN_copy(dest-&gt;field, src-&gt;field))
         return 0;
@@ -98,9 +98,9 @@ int ec_GF2m_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)
 }
 
 /* Set the curve parameters of an EC_GROUP structure. */
-int ec_GF2m_simple_group_set_curve(EC_GROUP *group,
-                                   const BIGNUM *p, const BIGNUM *a,
-                                   const BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GF2m_simple_group_set_curve(EC_GROUP *group,
+                                        const BIGNUM *p, const BIGNUM *a,
+                                        const BIGNUM *b, BN_CTX *ctx)
 {
     int ret = 0, i;
 
@@ -138,8 +138,8 @@ int ec_GF2m_simple_group_set_curve(EC_GROUP *group,
  * Get the curve parameters of an EC_GROUP structure. If p, a, or b are NULL
  * then there values will not be set but the method will return with success.
  */
-int ec_GF2m_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p,
-                                   BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GF2m_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p,
+                                        BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
 {
     int ret = 0;
 
@@ -168,7 +168,7 @@ int ec_GF2m_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p,
  * Gets the degree of the field.  For a curve over GF(2^m) this is the value
  * m.
  */
-int ec_GF2m_simple_group_get_degree(const EC_GROUP *group)
+int ossl_ec_GF2m_simple_group_get_degree(const EC_GROUP *group)
 {
     return BN_num_bits(group-&gt;field) - 1;
 }
@@ -177,8 +177,8 @@ int ec_GF2m_simple_group_get_degree(const EC_GROUP *group)
  * Checks the discriminant of the curve. y^2 + x*y = x^3 + a*x^2 + b is an
  * elliptic curve &lt;=&gt; b != 0 (mod p)
  */
-int ec_GF2m_simple_group_check_discriminant(const EC_GROUP *group,
-                                            BN_CTX *ctx)
+int ossl_ec_GF2m_simple_group_check_discriminant(const EC_GROUP *group,
+                                                 BN_CTX *ctx)
 {
     int ret = 0;
     BIGNUM *b;
@@ -219,7 +219,7 @@ int ec_GF2m_simple_group_check_discriminant(const EC_GROUP *group,
 }
 
 /* Initializes an EC_POINT. */
-int ec_GF2m_simple_point_init(EC_POINT *point)
+int ossl_ec_GF2m_simple_point_init(EC_POINT *point)
 {
     point-&gt;X = BN_new();
     point-&gt;Y = BN_new();
@@ -235,7 +235,7 @@ int ec_GF2m_simple_point_init(EC_POINT *point)
 }
 
 /* Frees an EC_POINT. */
-void ec_GF2m_simple_point_finish(EC_POINT *point)
+void ossl_ec_GF2m_simple_point_finish(EC_POINT *point)
 {
     BN_free(point-&gt;X);
     BN_free(point-&gt;Y);
@@ -243,7 +243,7 @@ void ec_GF2m_simple_point_finish(EC_POINT *point)
 }
 
 /* Clears and frees an EC_POINT. */
-void ec_GF2m_simple_point_clear_finish(EC_POINT *point)
+void ossl_ec_GF2m_simple_point_clear_finish(EC_POINT *point)
 {
     BN_clear_free(point-&gt;X);
     BN_clear_free(point-&gt;Y);
@@ -255,7 +255,7 @@ void ec_GF2m_simple_point_clear_finish(EC_POINT *point)
  * Copy the contents of one EC_POINT into another.  Assumes dest is
  * initialized.
  */
-int ec_GF2m_simple_point_copy(EC_POINT *dest, const EC_POINT *src)
+int ossl_ec_GF2m_simple_point_copy(EC_POINT *dest, const EC_POINT *src)
 {
     if (!BN_copy(dest-&gt;X, src-&gt;X))
         return 0;
@@ -273,8 +273,8 @@ int ec_GF2m_simple_point_copy(EC_POINT *dest, const EC_POINT *src)
  * Set an EC_POINT to the point at infinity. A point at infinity is
  * represented by having Z=0.
  */
-int ec_GF2m_simple_point_set_to_infinity(const EC_GROUP *group,
-                                         EC_POINT *point)
+int ossl_ec_GF2m_simple_point_set_to_infinity(const EC_GROUP *group,
+                                              EC_POINT *point)
 {
     point-&gt;Z_is_one = 0;
     BN_zero(point-&gt;Z);
@@ -285,10 +285,11 @@ int ec_GF2m_simple_point_set_to_infinity(const EC_GROUP *group,
  * Set the coordinates of an EC_POINT using affine coordinates. Note that
  * the simple implementation only uses affine coordinates.
  */
-int ec_GF2m_simple_point_set_affine_coordinates(const EC_GROUP *group,
-                                                EC_POINT *point,
-                                                const BIGNUM *x,
-                                                const BIGNUM *y, BN_CTX *ctx)
+int ossl_ec_GF2m_simple_point_set_affine_coordinates(const EC_GROUP *group,
+                                                     EC_POINT *point,
+                                                     const BIGNUM *x,
+                                                     const BIGNUM *y,
+                                                     BN_CTX *ctx)
 {
     int ret = 0;
     if (x == NULL || y == NULL) {
@@ -316,10 +317,10 @@ int ec_GF2m_simple_point_set_affine_coordinates(const EC_GROUP *group,
  * Gets the affine coordinates of an EC_POINT. Note that the simple
  * implementation only uses affine coordinates.
  */
-int ec_GF2m_simple_point_get_affine_coordinates(const EC_GROUP *group,
-                                                const EC_POINT *point,
-                                                BIGNUM *x, BIGNUM *y,
-                                                BN_CTX *ctx)
+int ossl_ec_GF2m_simple_point_get_affine_coordinates(const EC_GROUP *group,
+                                                     const EC_POINT *point,
+                                                     BIGNUM *x, BIGNUM *y,
+                                                     BN_CTX *ctx)
 {
     int ret = 0;
 
@@ -352,8 +353,8 @@ int ec_GF2m_simple_point_get_affine_coordinates(const EC_GROUP *group,
  * Computes a + b and stores the result in r.  r could be a or b, a could be
  * b. Uses algorithm A.10.2 of IEEE P1363.
  */
-int ec_GF2m_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
-                       const EC_POINT *b, BN_CTX *ctx)
+int ossl_ec_GF2m_simple_add(const EC_GROUP *group, EC_POINT *r,
+                            const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx)
 {
     BIGNUM *x0, *y0, *x1, *y1, *x2, *y2, *s, *t;
     int ret = 0;
@@ -473,13 +474,14 @@ int ec_GF2m_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
  * Computes 2 * a and stores the result in r.  r could be a. Uses algorithm
  * A.10.2 of IEEE P1363.
  */
-int ec_GF2m_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
-                       BN_CTX *ctx)
+int ossl_ec_GF2m_simple_dbl(const EC_GROUP *group, EC_POINT *r,
+                            const EC_POINT *a, BN_CTX *ctx)
 {
-    return ec_GF2m_simple_add(group, r, a, a, ctx);
+    return ossl_ec_GF2m_simple_add(group, r, a, a, ctx);
 }
 
-int ec_GF2m_simple_invert(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
+int ossl_ec_GF2m_simple_invert(const EC_GROUP *group, EC_POINT *point,
+                               BN_CTX *ctx)
 {
     if (EC_POINT_is_at_infinity(group, point) || BN_is_zero(point-&gt;Y))
         /* point is its own inverse */
@@ -492,8 +494,8 @@ int ec_GF2m_simple_invert(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
 }
 
 /* Indicates whether the given point is the point at infinity. */
-int ec_GF2m_simple_is_at_infinity(const EC_GROUP *group,
-                                  const EC_POINT *point)
+int ossl_ec_GF2m_simple_is_at_infinity(const EC_GROUP *group,
+                                       const EC_POINT *point)
 {
     return BN_is_zero(point-&gt;Z);
 }
@@ -503,8 +505,8 @@ int ec_GF2m_simple_is_at_infinity(const EC_GROUP *group,
  * in the EC_GROUP.  A point is valid if it satisfies the Weierstrass equation:
  *      y^2 + x*y = x^3 + a*x^2 + b.
  */
-int ec_GF2m_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point,
-                               BN_CTX *ctx)
+int ossl_ec_GF2m_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point,
+                                    BN_CTX *ctx)
 {
     int ret = -1;
     BIGNUM *lh, *y2;
@@ -576,8 +578,8 @@ int ec_GF2m_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point,
  *   0   equal (in affine coordinates)
  *   1   not equal
  */
-int ec_GF2m_simple_cmp(const EC_GROUP *group, const EC_POINT *a,
-                       const EC_POINT *b, BN_CTX *ctx)
+int ossl_ec_GF2m_simple_cmp(const EC_GROUP *group, const EC_POINT *a,
+                            const EC_POINT *b, BN_CTX *ctx)
 {
     BIGNUM *aX, *aY, *bX, *bY;
     int ret = -1;
@@ -627,8 +629,8 @@ int ec_GF2m_simple_cmp(const EC_GROUP *group, const EC_POINT *a,
 }
 
 /* Forces the given EC_POINT to internally use affine coordinates. */
-int ec_GF2m_simple_make_affine(const EC_GROUP *group, EC_POINT *point,
-                               BN_CTX *ctx)
+int ossl_ec_GF2m_simple_make_affine(const EC_GROUP *group, EC_POINT *point,
+                                    BN_CTX *ctx)
 {
     BIGNUM *x, *y;
     int ret = 0;
@@ -676,8 +678,8 @@ int ec_GF2m_simple_make_affine(const EC_GROUP *group, EC_POINT *point,
 /*
  * Forces each of the EC_POINTs in the given array to use affine coordinates.
  */
-int ec_GF2m_simple_points_make_affine(const EC_GROUP *group, size_t num,
-                                      EC_POINT *points[], BN_CTX *ctx)
+int ossl_ec_GF2m_simple_points_make_affine(const EC_GROUP *group, size_t num,
+                                           EC_POINT *points[], BN_CTX *ctx)
 {
     size_t i;
 
@@ -690,22 +692,22 @@ int ec_GF2m_simple_points_make_affine(const EC_GROUP *group, size_t num,
 }
 
 /* Wrapper to simple binary polynomial field multiplication implementation. */
-int ec_GF2m_simple_field_mul(const EC_GROUP *group, BIGNUM *r,
-                             const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GF2m_simple_field_mul(const EC_GROUP *group, BIGNUM *r,
+                                  const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
 {
     return BN_GF2m_mod_mul_arr(r, a, b, group-&gt;poly, ctx);
 }
 
 /* Wrapper to simple binary polynomial field squaring implementation. */
-int ec_GF2m_simple_field_sqr(const EC_GROUP *group, BIGNUM *r,
-                             const BIGNUM *a, BN_CTX *ctx)
+int ossl_ec_GF2m_simple_field_sqr(const EC_GROUP *group, BIGNUM *r,
+                                  const BIGNUM *a, BN_CTX *ctx)
 {
     return BN_GF2m_mod_sqr_arr(r, a, group-&gt;poly, ctx);
 }
 
 /* Wrapper to simple binary polynomial field division implementation. */
-int ec_GF2m_simple_field_div(const EC_GROUP *group, BIGNUM *r,
-                             const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GF2m_simple_field_div(const EC_GROUP *group, BIGNUM *r,
+                                  const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
 {
     return BN_GF2m_mod_div(r, a, b, group-&gt;field, ctx);
 }
@@ -887,15 +889,15 @@ int ec_GF2m_simple_points_mul(const EC_GROUP *group, EC_POINT *r,
      * order or cofactor set to 0.
      */
     if (num &gt; 1 || BN_is_zero(group-&gt;order) || BN_is_zero(group-&gt;cofactor))
-        return ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);
+        return ossl_ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);
 
     if (scalar != NULL &amp;&amp; num == 0)
         /* Fixed point multiplication */
-        return ec_scalar_mul_ladder(group, r, scalar, NULL, ctx);
+        return ossl_ec_scalar_mul_ladder(group, r, scalar, NULL, ctx);
 
     if (scalar == NULL &amp;&amp; num == 1)
         /* Variable point multiplication */
-        return ec_scalar_mul_ladder(group, r, scalars[0], points[0], ctx);
+        return ossl_ec_scalar_mul_ladder(group, r, scalars[0], points[0], ctx);
 
     /*-
      * Double point multiplication:
@@ -907,8 +909,8 @@ int ec_GF2m_simple_points_mul(const EC_GROUP *group, EC_POINT *r,
         return 0;
     }
 
-    if (!ec_scalar_mul_ladder(group, t, scalar, NULL, ctx)
-        || !ec_scalar_mul_ladder(group, r, scalars[0], points[0], ctx)
+    if (!ossl_ec_scalar_mul_ladder(group, t, scalar, NULL, ctx)
+        || !ossl_ec_scalar_mul_ladder(group, r, scalars[0], points[0], ctx)
         || !EC_POINT_add(group, r, t, r, ctx))
         goto err;
 
@@ -939,55 +941,55 @@ const EC_METHOD *EC_GF2m_simple_method(void)
     static const EC_METHOD ret = {
         EC_FLAGS_DEFAULT_OCT,
         NID_X9_62_characteristic_two_field,
-        ec_GF2m_simple_group_init,
-        ec_GF2m_simple_group_finish,
-        ec_GF2m_simple_group_clear_finish,
-        ec_GF2m_simple_group_copy,
-        ec_GF2m_simple_group_set_curve,
-        ec_GF2m_simple_group_get_curve,
-        ec_GF2m_simple_group_get_degree,
-        ec_group_simple_order_bits,
-        ec_GF2m_simple_group_check_discriminant,
-        ec_GF2m_simple_point_init,
-        ec_GF2m_simple_point_finish,
-        ec_GF2m_simple_point_clear_finish,
-        ec_GF2m_simple_point_copy,
-        ec_GF2m_simple_point_set_to_infinity,
-        ec_GF2m_simple_point_set_affine_coordinates,
-        ec_GF2m_simple_point_get_affine_coordinates,
+        ossl_ec_GF2m_simple_group_init,
+        ossl_ec_GF2m_simple_group_finish,
+        ossl_ec_GF2m_simple_group_clear_finish,
+        ossl_ec_GF2m_simple_group_copy,
+        ossl_ec_GF2m_simple_group_set_curve,
+        ossl_ec_GF2m_simple_group_get_curve,
+        ossl_ec_GF2m_simple_group_get_degree,
+        ossl_ec_group_simple_order_bits,
+        ossl_ec_GF2m_simple_group_check_discriminant,
+        ossl_ec_GF2m_simple_point_init,
+        ossl_ec_GF2m_simple_point_finish,
+        ossl_ec_GF2m_simple_point_clear_finish,
+        ossl_ec_GF2m_simple_point_copy,
+        ossl_ec_GF2m_simple_point_set_to_infinity,
+        ossl_ec_GF2m_simple_point_set_affine_coordinates,
+        ossl_ec_GF2m_simple_point_get_affine_coordinates,
         0, /* point_set_compressed_coordinates */
         0, /* point2oct */
         0, /* oct2point */
-        ec_GF2m_simple_add,
-        ec_GF2m_simple_dbl,
-        ec_GF2m_simple_invert,
-        ec_GF2m_simple_is_at_infinity,
-        ec_GF2m_simple_is_on_curve,
-        ec_GF2m_simple_cmp,
-        ec_GF2m_simple_make_affine,
-        ec_GF2m_simple_points_make_affine,
+        ossl_ec_GF2m_simple_add,
+        ossl_ec_GF2m_simple_dbl,
+        ossl_ec_GF2m_simple_invert,
+        ossl_ec_GF2m_simple_is_at_infinity,
+        ossl_ec_GF2m_simple_is_on_curve,
+        ossl_ec_GF2m_simple_cmp,
+        ossl_ec_GF2m_simple_make_affine,
+        ossl_ec_GF2m_simple_points_make_affine,
         ec_GF2m_simple_points_mul,
         0, /* precompute_mult */
         0, /* have_precompute_mult */
-        ec_GF2m_simple_field_mul,
-        ec_GF2m_simple_field_sqr,
-        ec_GF2m_simple_field_div,
+        ossl_ec_GF2m_simple_field_mul,
+        ossl_ec_GF2m_simple_field_sqr,
+        ossl_ec_GF2m_simple_field_div,
         ec_GF2m_simple_field_inv,
         0, /* field_encode */
         0, /* field_decode */
         0, /* field_set_to_one */
-        ec_key_simple_priv2oct,
-        ec_key_simple_oct2priv,
+        ossl_ec_key_simple_priv2oct,
+        ossl_ec_key_simple_oct2priv,
         0, /* set private */
-        ec_key_simple_generate_key,
-        ec_key_simple_check_key,
-        ec_key_simple_generate_public_key,
+        ossl_ec_key_simple_generate_key,
+        ossl_ec_key_simple_check_key,
+        ossl_ec_key_simple_generate_public_key,
         0, /* keycopy */
         0, /* keyfinish */
-        ecdh_simple_compute_key,
-        ecdsa_simple_sign_setup,
-        ecdsa_simple_sign_sig,
-        ecdsa_simple_verify_sig,
+        ossl_ecdh_simple_compute_key,
+        ossl_ecdsa_simple_sign_setup,
+        ossl_ecdsa_simple_sign_sig,
+        ossl_ecdsa_simple_verify_sig,
         0, /* field_inverse_mod_ord */
         0, /* blind_coordinates */
         ec_GF2m_simple_ladder_pre,
diff --git a/crypto/ec/ec_ameth.c b/crypto/ec/ec_ameth.c
index fe1e1c9a8f..89241b97c1 100644
--- a/crypto/ec/ec_ameth.c
+++ b/crypto/ec/ec_ameth.c
@@ -584,7 +584,7 @@ int ec_pkey_export_to(const EVP_PKEY *from, void *to_keydata,
     BN_CTX_start(bnctx);
 
     /* export the domain parameters */
-    if (!ec_group_todata(ecg, tmpl, NULL, libctx, propq, bnctx, &amp;gen_buf))
+    if (!ossl_ec_group_todata(ecg, tmpl, NULL, libctx, propq, bnctx, &amp;gen_buf))
         goto err;
     selection |= OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS;
 
@@ -695,9 +695,9 @@ static int ec_pkey_import_from(const OSSL_PARAM params[], void *vpctx)
         return 0;
     }
 
-    if (!ec_group_fromdata(ec, params)
-        || !ec_key_otherparams_fromdata(ec, params)
-        || !ec_key_fromdata(ec, params, 1)
+    if (!ossl_ec_group_fromdata(ec, params)
+        || !ossl_ec_key_otherparams_fromdata(ec, params)
+        || !ossl_ec_key_fromdata(ec, params, 1)
         || !EVP_PKEY_assign_EC_KEY(pkey, ec)) {
         EC_KEY_free(ec);
         return 0;
diff --git a/crypto/ec/ec_asn1.c b/crypto/ec/ec_asn1.c
index cd38ab6b04..b66e4a8b57 100644
--- a/crypto/ec/ec_asn1.c
+++ b/crypto/ec/ec_asn1.c
@@ -768,7 +768,7 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
         ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
         goto err;
     }
-    if ((curve_name = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {
+    if ((curve_name = ossl_ec_curve_nid_from_params(dup, ctx)) != NID_undef) {
         /*
          * The input explicit parameters successfully matched one of the
          * built-in curves: often for built-in curves we have specialized
diff --git a/crypto/ec/ec_backend.c b/crypto/ec/ec_backend.c
index 60c5687602..c4a5a81fda 100644
--- a/crypto/ec/ec_backend.c
+++ b/crypto/ec/ec_backend.c
@@ -41,7 +41,7 @@ static const OSSL_ITEM format_nameid_map[] = {
     { (int)POINT_CONVERSION_HYBRID, OSSL_PKEY_EC_POINT_CONVERSION_FORMAT_HYBRID },
 };
 
-int ec_encoding_name2id(const char *name)
+int ossl_ec_encoding_name2id(const char *name)
 {
     size_t i, sz;
 
@@ -67,7 +67,7 @@ static char *ec_param_encoding_id2name(int id)
     return NULL;
 }
 
-char *ec_check_group_type_id2name(int id)
+char *ossl_ec_check_group_type_id2name(int id)
 {
     size_t i, sz;
 
@@ -93,7 +93,7 @@ static int ec_check_group_type_name2id(const char *name)
     return -1;
 }
 
-int ec_set_check_group_type_from_name(EC_KEY *ec, const char *name)
+int ossl_ec_set_check_group_type_from_name(EC_KEY *ec, const char *name)
 {
     int flags = ec_check_group_type_name2id(name);
 
@@ -119,11 +119,11 @@ static int ec_set_check_group_type_from_param(EC_KEY *ec, const OSSL_PARAM *p)
         break;
     }
     if (status)
-        return ec_set_check_group_type_from_name(ec, name);
+        return ossl_ec_set_check_group_type_from_name(ec, name);
     return 0;
 }
 
-int ec_pt_format_name2id(const char *name)
+int ossl_ec_pt_format_name2id(const char *name)
 {
     size_t i, sz;
 
@@ -138,7 +138,7 @@ int ec_pt_format_name2id(const char *name)
     return -1;
 }
 
-char *ec_pt_format_id2name(int id)
+char *ossl_ec_pt_format_id2name(int id)
 {
     size_t i, sz;
 
@@ -149,10 +149,10 @@ char *ec_pt_format_id2name(int id)
     return NULL;
 }
 
-int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
-                    OSSL_PARAM params[], OSSL_LIB_CTX *libctx,
-                    const char *propq,
-                    BN_CTX *bnctx, unsigned char **genbuf)
+int ossl_ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
+                         OSSL_PARAM params[], OSSL_LIB_CTX *libctx,
+                         const char *propq,
+                         BN_CTX *bnctx, unsigned char **genbuf)
 {
     int ret = 0, curve_nid, encoding_flag;
     const char *field_type, *encoding_name, *pt_form_name;
@@ -169,7 +169,7 @@ int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
     }
 
     genform = EC_GROUP_get_point_conversion_form(group);
-    pt_form_name = ec_pt_format_id2name(genform);
+    pt_form_name = ossl_ec_pt_format_id2name(genform);
     if (pt_form_name == NULL
         || !ossl_param_build_set_utf8_string(
                 tmpl, params,
@@ -271,7 +271,7 @@ int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
 #endif
     } else {
         /* named curve */
-        const char *curve_name = ec_curve_nid2name(curve_nid);
+        const char *curve_name = ossl_ec_curve_nid2name(curve_nid);
 
         if (curve_name == NULL
             || !ossl_param_build_set_utf8_string(tmpl, params,
@@ -291,7 +291,7 @@ err:
  * for legacy backends (EVP_PKEY_ASN1_METHOD and EVP_PKEY_METHOD) and provider
  * implementations alike.
  */
-int ec_set_ecdh_cofactor_mode(EC_KEY *ec, int mode)
+int ossl_ec_set_ecdh_cofactor_mode(EC_KEY *ec, int mode)
 {
     const EC_GROUP *ecg = EC_KEY_get0_group(ec);
     const BIGNUM *cofactor;
@@ -321,14 +321,14 @@ int ec_set_ecdh_cofactor_mode(EC_KEY *ec, int mode)
 }
 
 /*
- * Callers of ec_key_fromdata MUST make sure that ec_key_params_fromdata has
+ * Callers of ossl_ec_key_fromdata MUST make sure that ec_key_params_fromdata has
  * been called before!
  *
  * This function only gets the bare keypair, domain parameters and other
  * parameters are treated separately, and domain parameters are required to
  * define a keypair.
  */
-int ec_key_fromdata(EC_KEY *ec, const OSSL_PARAM params[], int include_private)
+int ossl_ec_key_fromdata(EC_KEY *ec, const OSSL_PARAM params[], int include_private)
 {
     const OSSL_PARAM *param_priv_key = NULL, *param_pub_key = NULL;
     BN_CTX *ctx = NULL;
@@ -349,7 +349,7 @@ int ec_key_fromdata(EC_KEY *ec, const OSSL_PARAM params[], int include_private)
         param_priv_key =
             OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_PRIV_KEY);
 
-    ctx = BN_CTX_new_ex(ec_key_get_libctx(ec));
+    ctx = BN_CTX_new_ex(ossl_ec_key_get_libctx(ec));
     if (ctx == NULL)
         goto err;
 
@@ -431,7 +431,7 @@ int ec_key_fromdata(EC_KEY *ec, const OSSL_PARAM params[], int include_private)
     return ok;
 }
 
-int ec_group_fromdata(EC_KEY *ec, const OSSL_PARAM params[])
+int ossl_ec_group_fromdata(EC_KEY *ec, const OSSL_PARAM params[])
 {
     int ok = 0;
     EC_GROUP *group = NULL;
@@ -439,8 +439,8 @@ int ec_group_fromdata(EC_KEY *ec, const OSSL_PARAM params[])
     if (ec == NULL)
         return 0;
 
-     group = EC_GROUP_new_from_params(params, ec_key_get_libctx(ec),
-                                      ec_key_get0_propq(ec));
+     group = EC_GROUP_new_from_params(params, ossl_ec_key_get_libctx(ec),
+                                      ossl_ec_key_get0_propq(ec));
 
     if (!EC_KEY_set_group(ec, group))
         goto err;
@@ -457,7 +457,7 @@ static int ec_key_point_format_fromdata(EC_KEY *ec, const OSSL_PARAM params[])
 
     p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT);
     if (p != NULL) {
-        if (!ec_pt_format_param2id(p, &amp;format)) {
+        if (!ossl_ec_pt_format_param2id(p, &amp;format)) {
             ECerr(0, EC_R_INVALID_FORM);
             return 0;
         }
@@ -488,7 +488,7 @@ static int ec_set_include_public(EC_KEY *ec, int include)
     return 1;
 }
 
-int ec_key_otherparams_fromdata(EC_KEY *ec, const OSSL_PARAM params[])
+int ossl_ec_key_otherparams_fromdata(EC_KEY *ec, const OSSL_PARAM params[])
 {
     const OSSL_PARAM *p;
 
@@ -500,7 +500,7 @@ int ec_key_otherparams_fromdata(EC_KEY *ec, const OSSL_PARAM params[])
         int mode;
 
         if (!OSSL_PARAM_get_int(p, &amp;mode)
-            || !ec_set_ecdh_cofactor_mode(ec, mode))
+            || !ossl_ec_set_ecdh_cofactor_mode(ec, mode))
             return 0;
     }
 
@@ -519,7 +519,7 @@ int ec_key_otherparams_fromdata(EC_KEY *ec, const OSSL_PARAM params[])
     return 1;
 }
 
-int ec_encoding_param2id(const OSSL_PARAM *p, int *id)
+int ossl_ec_encoding_param2id(const OSSL_PARAM *p, int *id)
 {
     const char *name = NULL;
     int status = 0;
@@ -535,7 +535,7 @@ int ec_encoding_param2id(const OSSL_PARAM *p, int *id)
         break;
     }
     if (status) {
-        int i = ec_encoding_name2id(name);
+        int i = ossl_ec_encoding_name2id(name);
 
         if (i &gt;= 0) {
             *id = i;
@@ -545,7 +545,7 @@ int ec_encoding_param2id(const OSSL_PARAM *p, int *id)
     return 0;
 }
 
-int ec_pt_format_param2id(const OSSL_PARAM *p, int *id)
+int ossl_ec_pt_format_param2id(const OSSL_PARAM *p, int *id)
 {
     const char *name = NULL;
     int status = 0;
@@ -561,7 +561,7 @@ int ec_pt_format_param2id(const OSSL_PARAM *p, int *id)
         break;
     }
     if (status) {
-        int i = ec_pt_format_name2id(name);
+        int i = ossl_ec_pt_format_name2id(name);
 
         if (i &gt;= 0) {
             *id = i;
diff --git a/crypto/ec/ec_check.c b/crypto/ec/ec_check.c
index 6af002c0a8..1d25010394 100644
--- a/crypto/ec/ec_check.c
+++ b/crypto/ec/ec_check.c
@@ -35,7 +35,7 @@ int EC_GROUP_check_named_curve(const EC_GROUP *group, int nist_only,
         }
     }
 
-    nid = ec_curve_nid_from_params(group, ctx);
+    nid = ossl_ec_curve_nid_from_params(group, ctx);
     if (nid &gt; 0 &amp;&amp; nist_only &amp;&amp; EC_curve_nid2nist(nid) == NULL)
         nid = NID_undef;
 
diff --git a/crypto/ec/ec_curve.c b/crypto/ec/ec_curve.c
index 2fedaf0490..31215dc7ab 100644
--- a/crypto/ec/ec_curve.c
+++ b/crypto/ec/ec_curve.c
@@ -3147,8 +3147,8 @@ static EC_GROUP *ec_group_new_from_data(OSSL_LIB_CTX *libctx,
 
     /* If no curve data curve method must handle everything */
     if (curve.data == NULL)
-        return ec_group_new_ex(libctx, propq,
-                               curve.meth != NULL ? curve.meth() : NULL);
+        return ossl_ec_group_new_ex(libctx, propq,
+                                    curve.meth != NULL ? curve.meth() : NULL);
 
     if ((ctx = BN_CTX_new_ex(libctx)) == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
@@ -3170,7 +3170,7 @@ static EC_GROUP *ec_group_new_from_data(OSSL_LIB_CTX *libctx,
 
     if (curve.meth != 0) {
         meth = curve.meth();
-        if (((group = ec_group_new_ex(libctx, propq, meth)) == NULL) ||
+        if (((group = ossl_ec_group_new_ex(libctx, propq, meth)) == NULL) ||
             (!(group-&gt;meth-&gt;group_set_curve(group, p, a, b, ctx)))) {
             ERR_raise(ERR_LIB_EC, ERR_R_EC_LIB);
             goto err;
@@ -3286,12 +3286,12 @@ size_t EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems)
 
 const char *EC_curve_nid2nist(int nid)
 {
-    return ec_curve_nid2nist_int(nid);
+    return ossl_ec_curve_nid2nist_int(nid);
 }
 
 int EC_curve_nist2nid(const char *name)
 {
-    return ec_curve_nist2nid_int(name);
+    return ossl_ec_curve_nist2nid_int(name);
 }
 
 #define NUM_BN_FIELDS 6
@@ -3303,7 +3303,7 @@ int EC_curve_nist2nid(const char *name)
  * Returns: The nid associated with the found named curve, or NID_undef
  *          if not found. If there was an error it returns -1.
  */
-int ec_curve_nid_from_params(const EC_GROUP *group, BN_CTX *ctx)
+int ossl_ec_curve_nid_from_params(const EC_GROUP *group, BN_CTX *ctx)
 {
     int ret = -1, nid, len, field_type, param_len;
     size_t i, seed_len;
diff --git a/crypto/ec/ec_cvt.c b/crypto/ec/ec_cvt.c
index 00a5c48c8f..30ee061123 100644
--- a/crypto/ec/ec_cvt.c
+++ b/crypto/ec/ec_cvt.c
@@ -54,7 +54,7 @@ EC_GROUP *EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a,
         meth = EC_GFp_mont_method();
 #endif
 
-    ret = ec_group_new_ex(ossl_bn_get_libctx(ctx), NULL, meth);
+    ret = ossl_ec_group_new_ex(ossl_bn_get_libctx(ctx), NULL, meth);
     if (ret == NULL)
         return NULL;
 
@@ -75,7 +75,7 @@ EC_GROUP *EC_GROUP_new_curve_GF2m(const BIGNUM *p, const BIGNUM *a,
 
     meth = EC_GF2m_simple_method();
 
-    ret = ec_group_new_ex(ossl_bn_get_libctx(ctx), NULL, meth);
+    ret = ossl_ec_group_new_ex(ossl_bn_get_libctx(ctx), NULL, meth);
     if (ret == NULL)
         return NULL;
 
diff --git a/crypto/ec/ec_key.c b/crypto/ec/ec_key.c
index 30c524726d..50b53f97ed 100644
--- a/crypto/ec/ec_key.c
+++ b/crypto/ec/ec_key.c
@@ -30,13 +30,13 @@ static int ecdsa_keygen_pairwise_test(EC_KEY *eckey, OSSL_CALLBACK *cb,
 #ifndef FIPS_MODULE
 EC_KEY *EC_KEY_new(void)
 {
-    return ec_key_new_method_int(NULL, NULL, NULL);
+    return ossl_ec_key_new_method_int(NULL, NULL, NULL);
 }
 #endif
 
 EC_KEY *EC_KEY_new_ex(OSSL_LIB_CTX *ctx, const char *propq)
 {
-    return ec_key_new_method_int(ctx, propq, NULL);
+    return ossl_ec_key_new_method_int(ctx, propq, NULL);
 }
 
 EC_KEY *EC_KEY_new_by_curve_name_ex(OSSL_LIB_CTX *ctx, const char *propq,
@@ -122,7 +122,8 @@ EC_KEY *EC_KEY_copy(EC_KEY *dest, const EC_KEY *src)
     if (src-&gt;group != NULL) {
         /* clear the old group */
         EC_GROUP_free(dest-&gt;group);
-        dest-&gt;group = ec_group_new_ex(src-&gt;libctx, src-&gt;propq, src-&gt;group-&gt;meth);
+        dest-&gt;group = ossl_ec_group_new_ex(src-&gt;libctx, src-&gt;propq,
+                                           src-&gt;group-&gt;meth);
         if (dest-&gt;group == NULL)
             return NULL;
         if (!EC_GROUP_copy(dest-&gt;group, src-&gt;group))
@@ -183,8 +184,8 @@ EC_KEY *EC_KEY_copy(EC_KEY *dest, const EC_KEY *src)
 
 EC_KEY *EC_KEY_dup(const EC_KEY *ec_key)
 {
-    EC_KEY *ret = ec_key_new_method_int(ec_key-&gt;libctx, ec_key-&gt;propq,
-                                        ec_key-&gt;engine);
+    EC_KEY *ret = ossl_ec_key_new_method_int(ec_key-&gt;libctx, ec_key-&gt;propq,
+                                             ec_key-&gt;engine);
 
     if (ret == NULL)
         return NULL;
@@ -357,12 +358,12 @@ err:
     return ok;
 }
 
-int ec_key_simple_generate_key(EC_KEY *eckey)
+int ossl_ec_key_simple_generate_key(EC_KEY *eckey)
 {
     return ec_generate_key(eckey, 0);
 }
 
-int ec_key_simple_generate_public_key(EC_KEY *eckey)
+int ossl_ec_key_simple_generate_public_key(EC_KEY *eckey)
 {
     int ret;
     BN_CTX *ctx = BN_CTX_new_ex(eckey-&gt;libctx);
@@ -445,7 +446,7 @@ err:
  * ECC Partial Public-Key Validation as specified in SP800-56A R3
  * Section 5.6.2.3.4 ECC Partial Public-Key Validation Routine.
  */
-int ec_key_public_check_quick(const EC_KEY *eckey, BN_CTX *ctx)
+int ossl_ec_key_public_check_quick(const EC_KEY *eckey, BN_CTX *ctx)
 {
     if (eckey == NULL || eckey-&gt;group == NULL || eckey-&gt;pub_key == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
@@ -476,13 +477,13 @@ int ec_key_public_check_quick(const EC_KEY *eckey, BN_CTX *ctx)
  * ECC Key validation as specified in SP800-56A R3.
  * Section 5.6.2.3.3 ECC Full Public-Key Validation Routine.
  */
-int ec_key_public_check(const EC_KEY *eckey, BN_CTX *ctx)
+int ossl_ec_key_public_check(const EC_KEY *eckey, BN_CTX *ctx)
 {
     int ret = 0;
     EC_POINT *point = NULL;
     const BIGNUM *order = NULL;
 
-    if (!ec_key_public_check_quick(eckey, ctx))
+    if (!ossl_ec_key_public_check_quick(eckey, ctx))
         return 0;
 
     point = EC_POINT_new(eckey-&gt;group);
@@ -514,7 +515,7 @@ err:
  * Section 5.6.2.1.2 Owner Assurance of Private-Key Validity
  * The private key is in the range [1, order-1]
  */
-int ec_key_private_check(const EC_KEY *eckey)
+int ossl_ec_key_private_check(const EC_KEY *eckey)
 {
     if (eckey == NULL || eckey-&gt;group == NULL || eckey-&gt;priv_key == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_PASSED_NULL_PARAMETER);
@@ -533,7 +534,7 @@ int ec_key_private_check(const EC_KEY *eckey)
  * Section 5.6.2.1.4 Owner Assurance of Pair-wise Consistency (b)
  * Check if generator * priv_key = pub_key
  */
-int ec_key_pairwise_check(const EC_KEY *eckey, BN_CTX *ctx)
+int ossl_ec_key_pairwise_check(const EC_KEY *eckey, BN_CTX *ctx)
 {
     int ret = 0;
     EC_POINT *point = NULL;
@@ -576,7 +577,7 @@ err:
  *    an approved elliptic-curve group is used.
  * Returns 1 if the key is valid, otherwise it returns 0.
  */
-int ec_key_simple_check_key(const EC_KEY *eckey)
+int ossl_ec_key_simple_check_key(const EC_KEY *eckey)
 {
     int ok = 0;
     BN_CTX *ctx = NULL;
@@ -588,12 +589,12 @@ int ec_key_simple_check_key(const EC_KEY *eckey)
     if ((ctx = BN_CTX_new_ex(eckey-&gt;libctx)) == NULL)
         return 0;
 
-    if (!ec_key_public_check(eckey, ctx))
+    if (!ossl_ec_key_public_check(eckey, ctx))
         goto err;
 
     if (eckey-&gt;priv_key != NULL) {
-        if (!ec_key_private_check(eckey)
-            || !ec_key_pairwise_check(eckey, ctx))
+        if (!ossl_ec_key_private_check(eckey)
+            || !ossl_ec_key_pairwise_check(eckey, ctx))
             goto err;
     }
     ok = 1;
@@ -660,17 +661,17 @@ int EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,
 
 }
 
-OSSL_LIB_CTX *ec_key_get_libctx(const EC_KEY *key)
+OSSL_LIB_CTX *ossl_ec_key_get_libctx(const EC_KEY *key)
 {
     return key-&gt;libctx;
 }
 
-const char *ec_key_get0_propq(const EC_KEY *key)
+const char *ossl_ec_key_get0_propq(const EC_KEY *key)
 {
     return key-&gt;propq;
 }
 
-void ec_key_set0_libctx(EC_KEY *key, OSSL_LIB_CTX *libctx)
+void ossl_ec_key_set0_libctx(EC_KEY *key, OSSL_LIB_CTX *libctx)
 {
     key-&gt;libctx = libctx;
     /* Do we need to propagate this to the group? */
@@ -903,8 +904,8 @@ size_t EC_KEY_priv2oct(const EC_KEY *eckey,
     return eckey-&gt;group-&gt;meth-&gt;priv2oct(eckey, buf, len);
 }
 
-size_t ec_key_simple_priv2oct(const EC_KEY *eckey,
-                              unsigned char *buf, size_t len)
+size_t ossl_ec_key_simple_priv2oct(const EC_KEY *eckey,
+                                   unsigned char *buf, size_t len)
 {
     size_t buf_len;
 
@@ -942,7 +943,8 @@ int EC_KEY_oct2priv(EC_KEY *eckey, const unsigned char *buf, size_t len)
     return ret;
 }
 
-int ec_key_simple_oct2priv(EC_KEY *eckey, const unsigned char *buf, size_t len)
+int ossl_ec_key_simple_oct2priv(EC_KEY *eckey, const unsigned char *buf,
+                                size_t len)
 {
     if (eckey-&gt;priv_key == NULL)
         eckey-&gt;priv_key = BN_secure_new();
diff --git a/crypto/ec/ec_kmeth.c b/crypto/ec/ec_kmeth.c
index ea3a077ad2..4298bcc401 100644
--- a/crypto/ec/ec_kmeth.c
+++ b/crypto/ec/ec_kmeth.c
@@ -76,8 +76,8 @@ int EC_KEY_set_method(EC_KEY *key, const EC_KEY_METHOD *meth)
     return 1;
 }
 
-EC_KEY *ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
-                              ENGINE *engine)
+EC_KEY *ossl_ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
+                                   ENGINE *engine)
 {
     EC_KEY *ret = OPENSSL_zalloc(sizeof(*ret));
 
@@ -145,7 +145,7 @@ EC_KEY *ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
 #ifndef FIPS_MODULE
 EC_KEY *EC_KEY_new_method(ENGINE *engine)
 {
-    return ec_key_new_method_int(NULL, NULL, engine);
+    return ossl_ec_key_new_method_int(NULL, NULL, engine);
 }
 #endif
 
diff --git a/crypto/ec/ec_lib.c b/crypto/ec/ec_lib.c
index 71cb45ca19..3d3cf96962 100644
--- a/crypto/ec/ec_lib.c
+++ b/crypto/ec/ec_lib.c
@@ -26,8 +26,8 @@
 
 /* functions for EC_GROUP objects */
 
-EC_GROUP *ec_group_new_ex(OSSL_LIB_CTX *libctx, const char *propq,
-                          const EC_METHOD *meth)
+EC_GROUP *ossl_ec_group_new_ex(OSSL_LIB_CTX *libctx, const char *propq,
+                               const EC_METHOD *meth)
 {
     EC_GROUP *ret;
 
@@ -81,7 +81,7 @@ EC_GROUP *ec_group_new_ex(OSSL_LIB_CTX *libctx, const char *propq,
 # ifndef FIPS_MODULE
 EC_GROUP *EC_GROUP_new(const EC_METHOD *meth)
 {
-    return ec_group_new_ex(NULL, NULL, meth);
+    return ossl_ec_group_new_ex(NULL, NULL, meth);
 }
 # endif
 #endif
@@ -271,7 +271,7 @@ EC_GROUP *EC_GROUP_dup(const EC_GROUP *a)
     if (a == NULL)
         return NULL;
 
-    if ((t = ec_group_new_ex(a-&gt;libctx, a-&gt;propq, a-&gt;meth)) == NULL)
+    if ((t = ossl_ec_group_new_ex(a-&gt;libctx, a-&gt;propq, a-&gt;meth)) == NULL)
         return NULL;
     if (!EC_GROUP_copy(t, a))
         goto err;
@@ -836,7 +836,8 @@ int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
         ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
-    return ec_GFp_simple_set_Jprojective_coordinates_GFp(group, point, x, y, z, ctx);
+    return ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp(group, point,
+                                                              x, y, z, ctx);
 }
 
 int EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,
@@ -852,7 +853,8 @@ int EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,
         ERR_raise(ERR_LIB_EC, EC_R_INCOMPATIBLE_OBJECTS);
         return 0;
     }
-    return ec_GFp_simple_get_Jprojective_coordinates_GFp(group, point, x, y, z, ctx);
+    return ossl_ec_GFp_simple_get_Jprojective_coordinates_GFp(group, point,
+                                                              x, y, z, ctx);
 }
 #endif
 
@@ -1101,7 +1103,7 @@ int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
         ret = group-&gt;meth-&gt;mul(group, r, scalar, num, points, scalars, ctx);
     else
         /* use default */
-        ret = ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);
+        ret = ossl_ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);
 
 #ifndef FIPS_MODULE
     BN_CTX_free(new_ctx);
@@ -1142,7 +1144,7 @@ int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
         ret = group-&gt;meth-&gt;mul(group, r, g_scalar, num, &amp;point, &amp;p_scalar, ctx);
     else
         /* use default */
-        ret = ec_wNAF_mul(group, r, g_scalar, num, &amp;point, &amp;p_scalar, ctx);
+        ret = ossl_ec_wNAF_mul(group, r, g_scalar, num, &amp;point, &amp;p_scalar, ctx);
 
 #ifndef FIPS_MODULE
     BN_CTX_free(new_ctx);
@@ -1155,7 +1157,7 @@ int EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;mul == 0)
         /* use default */
-        return ec_wNAF_precompute_mult(group, ctx);
+        return ossl_ec_wNAF_precompute_mult(group, ctx);
 
     if (group-&gt;meth-&gt;precompute_mult != 0)
         return group-&gt;meth-&gt;precompute_mult(group, ctx);
@@ -1167,7 +1169,7 @@ int EC_GROUP_have_precompute_mult(const EC_GROUP *group)
 {
     if (group-&gt;meth-&gt;mul == 0)
         /* use default */
-        return ec_wNAF_have_precompute_mult(group);
+        return ossl_ec_wNAF_have_precompute_mult(group);
 
     if (group-&gt;meth-&gt;have_precompute_mult != 0)
         return group-&gt;meth-&gt;have_precompute_mult(group);
@@ -1222,7 +1224,7 @@ void *EC_KEY_get_ex_data(const EC_KEY *key, int idx)
 }
 #endif
 
-int ec_group_simple_order_bits(const EC_GROUP *group)
+int ossl_ec_group_simple_order_bits(const EC_GROUP *group)
 {
     if (group-&gt;order == NULL)
         return 0;
@@ -1290,8 +1292,8 @@ static int ec_field_inverse_mod_ord(const EC_GROUP *group, BIGNUM *r,
  * EC_METHODs must implement their own field_inverse_mod_ord for
  * other functionality.
  */
-int ec_group_do_inverse_ord(const EC_GROUP *group, BIGNUM *res,
-                            const BIGNUM *x, BN_CTX *ctx)
+int ossl_ec_group_do_inverse_ord(const EC_GROUP *group, BIGNUM *res,
+                                 const BIGNUM *x, BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;field_inverse_mod_ord != NULL)
         return group-&gt;meth-&gt;field_inverse_mod_ord(group, res, x, ctx);
@@ -1309,7 +1311,8 @@ int ec_group_do_inverse_ord(const EC_GROUP *group, BIGNUM *res,
  * This wrapper returns 1 in case the underlying EC_METHOD does not
  * support coordinate blinding.
  */
-int ec_point_blind_coordinates(const EC_GROUP *group, EC_POINT *p, BN_CTX *ctx)
+int ossl_ec_point_blind_coordinates(const EC_GROUP *group, EC_POINT *p,
+                                    BN_CTX *ctx)
 {
     if (group-&gt;meth-&gt;blind_coordinates == NULL)
         return 1; /* ignore if not implemented */
@@ -1411,7 +1414,7 @@ static EC_GROUP *ec_group_explicit_to_named(const EC_GROUP *group,
             || EC_GROUP_set_seed(dup, NULL, 0) != 1
             || !EC_GROUP_set_generator(dup, point, order, NULL))
         goto err;
-    if ((curve_name_nid = ec_curve_nid_from_params(dup, ctx)) != NID_undef) {
+    if ((curve_name_nid = ossl_ec_curve_nid_from_params(dup, ctx)) != NID_undef) {
         /*
          * The input explicit parameters successfully matched one of the
          * built-in curves: often for built-in curves we have specialized
@@ -1483,7 +1486,7 @@ static EC_GROUP *group_new_from_name(const OSSL_PARAM *p,
     }
 
     if (ok) {
-        nid = ec_curve_name2nid(curve_name);
+        nid = ossl_ec_curve_name2nid(curve_name);
         if (nid == NID_undef) {
             ERR_raise(ERR_LIB_EC, EC_R_INVALID_CURVE);
             return NULL;
@@ -1495,14 +1498,14 @@ static EC_GROUP *group_new_from_name(const OSSL_PARAM *p,
 }
 
 /* These parameters can be set directly into an EC_GROUP */
-int ec_group_set_params(EC_GROUP *group, const OSSL_PARAM params[])
+int ossl_ec_group_set_params(EC_GROUP *group, const OSSL_PARAM params[])
 {
     int encoding_flag = -1, format = -1;
     const OSSL_PARAM *p;
 
     p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT);
     if (p != NULL) {
-        if (!ec_pt_format_param2id(p, &amp;format)) {
+        if (!ossl_ec_pt_format_param2id(p, &amp;format)) {
             ECerr(0, EC_R_INVALID_FORM);
             return 0;
         }
@@ -1511,7 +1514,7 @@ int ec_group_set_params(EC_GROUP *group, const OSSL_PARAM params[])
 
     p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_ENCODING);
     if (p != NULL) {
-        if (!ec_encoding_param2id(p, &amp;encoding_flag)) {
+        if (!ossl_ec_encoding_param2id(p, &amp;encoding_flag)) {
             ECerr(0, EC_R_INVALID_FORM);
             return 0;
         }
@@ -1549,7 +1552,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
     if (ptmp != NULL) {
         group = group_new_from_name(ptmp, libctx, propq);
         if (group != NULL) {
-            if (!ec_group_set_params(group, params)) {
+            if (!ossl_ec_group_set_params(group, params)) {
                 EC_GROUP_free(group);
                 group = NULL;
             }
@@ -1706,7 +1709,7 @@ EC_GROUP *EC_GROUP_new_from_params(const OSSL_PARAM params[],
          */
         ptmp = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_EC_ENCODING);
         if (ptmp != NULL
-            &amp;&amp; !ec_encoding_param2id(ptmp, &amp;encoding_flag)) {
+            &amp;&amp; !ossl_ec_encoding_param2id(ptmp, &amp;encoding_flag)) {
             ECerr(0, EC_R_INVALID_ENCODING);
             return 0;
         }
diff --git a/crypto/ec/ec_local.h b/crypto/ec/ec_local.h
index 004cfbd8d4..7ab5bd649c 100644
--- a/crypto/ec/ec_local.h
+++ b/crypto/ec/ec_local.h
@@ -349,249 +349,249 @@ void EC_ec_pre_comp_free(EC_PRE_COMP *);
  * method functions in ec_mult.c (ec_lib.c uses these as defaults if
  * group-&gt;method-&gt;mul is 0)
  */
-int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
-                size_t num, const EC_POINT *points[], const BIGNUM *scalars[],
-                BN_CTX *);
-int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *);
-int ec_wNAF_have_precompute_mult(const EC_GROUP *group);
+int ossl_ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
+                     size_t num, const EC_POINT *points[],
+                     const BIGNUM *scalars[], BN_CTX *);
+int ossl_ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *);
+int ossl_ec_wNAF_have_precompute_mult(const EC_GROUP *group);
 
 /* method functions in ecp_smpl.c */
-int ec_GFp_simple_group_init(EC_GROUP *);
-void ec_GFp_simple_group_finish(EC_GROUP *);
-void ec_GFp_simple_group_clear_finish(EC_GROUP *);
-int ec_GFp_simple_group_copy(EC_GROUP *, const EC_GROUP *);
-int ec_GFp_simple_group_set_curve(EC_GROUP *, const BIGNUM *p,
-                                  const BIGNUM *a, const BIGNUM *b, BN_CTX *);
-int ec_GFp_simple_group_get_curve(const EC_GROUP *, BIGNUM *p, BIGNUM *a,
-                                  BIGNUM *b, BN_CTX *);
-int ec_GFp_simple_group_get_degree(const EC_GROUP *);
-int ec_GFp_simple_group_check_discriminant(const EC_GROUP *, BN_CTX *);
-int ec_GFp_simple_point_init(EC_POINT *);
-void ec_GFp_simple_point_finish(EC_POINT *);
-void ec_GFp_simple_point_clear_finish(EC_POINT *);
-int ec_GFp_simple_point_copy(EC_POINT *, const EC_POINT *);
-int ec_GFp_simple_point_set_to_infinity(const EC_GROUP *, EC_POINT *);
-int ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *,
-                                                  EC_POINT *, const BIGNUM *x,
-                                                  const BIGNUM *y,
-                                                  const BIGNUM *z, BN_CTX *);
-int ec_GFp_simple_get_Jprojective_coordinates_GFp(const EC_GROUP *,
-                                                  const EC_POINT *, BIGNUM *x,
-                                                  BIGNUM *y, BIGNUM *z,
+int ossl_ec_GFp_simple_group_init(EC_GROUP *);
+void ossl_ec_GFp_simple_group_finish(EC_GROUP *);
+void ossl_ec_GFp_simple_group_clear_finish(EC_GROUP *);
+int ossl_ec_GFp_simple_group_copy(EC_GROUP *, const EC_GROUP *);
+int ossl_ec_GFp_simple_group_set_curve(EC_GROUP *, const BIGNUM *p,
+                                       const BIGNUM *a, const BIGNUM *b,
+                                       BN_CTX *);
+int ossl_ec_GFp_simple_group_get_curve(const EC_GROUP *, BIGNUM *p, BIGNUM *a,
+                                       BIGNUM *b, BN_CTX *);
+int ossl_ec_GFp_simple_group_get_degree(const EC_GROUP *);
+int ossl_ec_GFp_simple_group_check_discriminant(const EC_GROUP *, BN_CTX *);
+int ossl_ec_GFp_simple_point_init(EC_POINT *);
+void ossl_ec_GFp_simple_point_finish(EC_POINT *);
+void ossl_ec_GFp_simple_point_clear_finish(EC_POINT *);
+int ossl_ec_GFp_simple_point_copy(EC_POINT *, const EC_POINT *);
+int ossl_ec_GFp_simple_point_set_to_infinity(const EC_GROUP *, EC_POINT *);
+int ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *,
+                                                       EC_POINT *,
+                                                       const BIGNUM *x,
+                                                       const BIGNUM *y,
+                                                       const BIGNUM *z,
+                                                       BN_CTX *);
+int ossl_ec_GFp_simple_get_Jprojective_coordinates_GFp(const EC_GROUP *,
+                                                       const EC_POINT *,
+                                                       BIGNUM *x,
+                                                       BIGNUM *y, BIGNUM *z,
+                                                       BN_CTX *);
+int ossl_ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *, EC_POINT *,
+                                                    const BIGNUM *x,
+                                                    const BIGNUM *y, BN_CTX *);
+int ossl_ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *,
+                                                    const EC_POINT *, BIGNUM *x,
+                                                    BIGNUM *y, BN_CTX *);
+int ossl_ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *, EC_POINT *,
+                                                  const BIGNUM *x, int y_bit,
                                                   BN_CTX *);
-int ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *, EC_POINT *,
-                                               const BIGNUM *x,
-                                               const BIGNUM *y, BN_CTX *);
-int ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *,
-                                               const EC_POINT *, BIGNUM *x,
-                                               BIGNUM *y, BN_CTX *);
-int ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *, EC_POINT *,
-                                             const BIGNUM *x, int y_bit,
-                                             BN_CTX *);
-size_t ec_GFp_simple_point2oct(const EC_GROUP *, const EC_POINT *,
-                               point_conversion_form_t form,
-                               unsigned char *buf, size_t len, BN_CTX *);
-int ec_GFp_simple_oct2point(const EC_GROUP *, EC_POINT *,
-                            const unsigned char *buf, size_t len, BN_CTX *);
-int ec_GFp_simple_add(const EC_GROUP *, EC_POINT *r, const EC_POINT *a,
-                      const EC_POINT *b, BN_CTX *);
-int ec_GFp_simple_dbl(const EC_GROUP *, EC_POINT *r, const EC_POINT *a,
-                      BN_CTX *);
-int ec_GFp_simple_invert(const EC_GROUP *, EC_POINT *, BN_CTX *);
-int ec_GFp_simple_is_at_infinity(const EC_GROUP *, const EC_POINT *);
-int ec_GFp_simple_is_on_curve(const EC_GROUP *, const EC_POINT *, BN_CTX *);
-int ec_GFp_simple_cmp(const EC_GROUP *, const EC_POINT *a, const EC_POINT *b,
-                      BN_CTX *);
-int ec_GFp_simple_make_affine(const EC_GROUP *, EC_POINT *, BN_CTX *);
-int ec_GFp_simple_points_make_affine(const EC_GROUP *, size_t num,
-                                     EC_POINT *[], BN_CTX *);
-int ec_GFp_simple_field_mul(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                            const BIGNUM *b, BN_CTX *);
-int ec_GFp_simple_field_sqr(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                            BN_CTX *);
-int ec_GFp_simple_field_inv(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                            BN_CTX *);
-int ec_GFp_simple_blind_coordinates(const EC_GROUP *group, EC_POINT *p,
-                                    BN_CTX *ctx);
-int ec_GFp_simple_ladder_pre(const EC_GROUP *group,
-                             EC_POINT *r, EC_POINT *s,
-                             EC_POINT *p, BN_CTX *ctx);
-int ec_GFp_simple_ladder_step(const EC_GROUP *group,
-                              EC_POINT *r, EC_POINT *s,
-                              EC_POINT *p, BN_CTX *ctx);
-int ec_GFp_simple_ladder_post(const EC_GROUP *group,
-                              EC_POINT *r, EC_POINT *s,
-                              EC_POINT *p, BN_CTX *ctx);
+size_t ossl_ec_GFp_simple_point2oct(const EC_GROUP *, const EC_POINT *,
+                                    point_conversion_form_t form,
+                                    unsigned char *buf, size_t len, BN_CTX *);
+int ossl_ec_GFp_simple_oct2point(const EC_GROUP *, EC_POINT *,
+                                 const unsigned char *buf, size_t len, BN_CTX *);
+int ossl_ec_GFp_simple_add(const EC_GROUP *, EC_POINT *r, const EC_POINT *a,
+                           const EC_POINT *b, BN_CTX *);
+int ossl_ec_GFp_simple_dbl(const EC_GROUP *, EC_POINT *r, const EC_POINT *a,
+                           BN_CTX *);
+int ossl_ec_GFp_simple_invert(const EC_GROUP *, EC_POINT *, BN_CTX *);
+int ossl_ec_GFp_simple_is_at_infinity(const EC_GROUP *, const EC_POINT *);
+int ossl_ec_GFp_simple_is_on_curve(const EC_GROUP *, const EC_POINT *, BN_CTX *);
+int ossl_ec_GFp_simple_cmp(const EC_GROUP *, const EC_POINT *a,
+                           const EC_POINT *b, BN_CTX *);
+int ossl_ec_GFp_simple_make_affine(const EC_GROUP *, EC_POINT *, BN_CTX *);
+int ossl_ec_GFp_simple_points_make_affine(const EC_GROUP *, size_t num,
+                                          EC_POINT *[], BN_CTX *);
+int ossl_ec_GFp_simple_field_mul(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                                 const BIGNUM *b, BN_CTX *);
+int ossl_ec_GFp_simple_field_sqr(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                                 BN_CTX *);
+int ossl_ec_GFp_simple_field_inv(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                                 BN_CTX *);
+int ossl_ec_GFp_simple_blind_coordinates(const EC_GROUP *group, EC_POINT *p,
+                                         BN_CTX *ctx);
+int ossl_ec_GFp_simple_ladder_pre(const EC_GROUP *group,
+                                  EC_POINT *r, EC_POINT *s,
+                                  EC_POINT *p, BN_CTX *ctx);
+int ossl_ec_GFp_simple_ladder_step(const EC_GROUP *group,
+                                   EC_POINT *r, EC_POINT *s,
+                                   EC_POINT *p, BN_CTX *ctx);
+int ossl_ec_GFp_simple_ladder_post(const EC_GROUP *group,
+                                   EC_POINT *r, EC_POINT *s,
+                                   EC_POINT *p, BN_CTX *ctx);
 
 /* method functions in ecp_mont.c */
-int ec_GFp_mont_group_init(EC_GROUP *);
-int ec_GFp_mont_group_set_curve(EC_GROUP *, const BIGNUM *p, const BIGNUM *a,
-                                const BIGNUM *b, BN_CTX *);
-void ec_GFp_mont_group_finish(EC_GROUP *);
-void ec_GFp_mont_group_clear_finish(EC_GROUP *);
-int ec_GFp_mont_group_copy(EC_GROUP *, const EC_GROUP *);
-int ec_GFp_mont_field_mul(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                          const BIGNUM *b, BN_CTX *);
-int ec_GFp_mont_field_sqr(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                          BN_CTX *);
-int ec_GFp_mont_field_inv(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                          BN_CTX *);
-int ec_GFp_mont_field_encode(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                             BN_CTX *);
-int ec_GFp_mont_field_decode(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                             BN_CTX *);
-int ec_GFp_mont_field_set_to_one(const EC_GROUP *, BIGNUM *r, BN_CTX *);
+int ossl_ec_GFp_mont_group_init(EC_GROUP *);
+int ossl_ec_GFp_mont_group_set_curve(EC_GROUP *, const BIGNUM *p,
+                                     const BIGNUM *a,
+                                     const BIGNUM *b, BN_CTX *);
+void ossl_ec_GFp_mont_group_finish(EC_GROUP *);
+void ossl_ec_GFp_mont_group_clear_finish(EC_GROUP *);
+int ossl_ec_GFp_mont_group_copy(EC_GROUP *, const EC_GROUP *);
+int ossl_ec_GFp_mont_field_mul(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                               const BIGNUM *b, BN_CTX *);
+int ossl_ec_GFp_mont_field_sqr(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                               BN_CTX *);
+int ossl_ec_GFp_mont_field_inv(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                               BN_CTX *);
+int ossl_ec_GFp_mont_field_encode(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                                  BN_CTX *);
+int ossl_ec_GFp_mont_field_decode(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                                  BN_CTX *);
+int ossl_ec_GFp_mont_field_set_to_one(const EC_GROUP *, BIGNUM *r, BN_CTX *);
 
 /* method functions in ecp_nist.c */
-int ec_GFp_nist_group_copy(EC_GROUP *dest, const EC_GROUP *src);
-int ec_GFp_nist_group_set_curve(EC_GROUP *, const BIGNUM *p, const BIGNUM *a,
-                                const BIGNUM *b, BN_CTX *);
-int ec_GFp_nist_field_mul(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                          const BIGNUM *b, BN_CTX *);
-int ec_GFp_nist_field_sqr(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                          BN_CTX *);
+int ossl_ec_GFp_nist_group_copy(EC_GROUP *dest, const EC_GROUP *src);
+int ossl_ec_GFp_nist_group_set_curve(EC_GROUP *, const BIGNUM *p,
+                                     const BIGNUM *a, const BIGNUM *b, BN_CTX *);
+int ossl_ec_GFp_nist_field_mul(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                              const BIGNUM *b, BN_CTX *);
+int ossl_ec_GFp_nist_field_sqr(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                               BN_CTX *);
 
 /* method functions in ec2_smpl.c */
-int ec_GF2m_simple_group_init(EC_GROUP *);
-void ec_GF2m_simple_group_finish(EC_GROUP *);
-void ec_GF2m_simple_group_clear_finish(EC_GROUP *);
-int ec_GF2m_simple_group_copy(EC_GROUP *, const EC_GROUP *);
-int ec_GF2m_simple_group_set_curve(EC_GROUP *, const BIGNUM *p,
-                                   const BIGNUM *a, const BIGNUM *b,
-                                   BN_CTX *);
-int ec_GF2m_simple_group_get_curve(const EC_GROUP *, BIGNUM *p, BIGNUM *a,
-                                   BIGNUM *b, BN_CTX *);
-int ec_GF2m_simple_group_get_degree(const EC_GROUP *);
-int ec_GF2m_simple_group_check_discriminant(const EC_GROUP *, BN_CTX *);
-int ec_GF2m_simple_point_init(EC_POINT *);
-void ec_GF2m_simple_point_finish(EC_POINT *);
-void ec_GF2m_simple_point_clear_finish(EC_POINT *);
-int ec_GF2m_simple_point_copy(EC_POINT *, const EC_POINT *);
-int ec_GF2m_simple_point_set_to_infinity(const EC_GROUP *, EC_POINT *);
-int ec_GF2m_simple_point_set_affine_coordinates(const EC_GROUP *, EC_POINT *,
-                                                const BIGNUM *x,
-                                                const BIGNUM *y, BN_CTX *);
-int ec_GF2m_simple_point_get_affine_coordinates(const EC_GROUP *,
-                                                const EC_POINT *, BIGNUM *x,
-                                                BIGNUM *y, BN_CTX *);
-int ec_GF2m_simple_set_compressed_coordinates(const EC_GROUP *, EC_POINT *,
-                                              const BIGNUM *x, int y_bit,
-                                              BN_CTX *);
-size_t ec_GF2m_simple_point2oct(const EC_GROUP *, const EC_POINT *,
-                                point_conversion_form_t form,
-                                unsigned char *buf, size_t len, BN_CTX *);
-int ec_GF2m_simple_oct2point(const EC_GROUP *, EC_POINT *,
-                             const unsigned char *buf, size_t len, BN_CTX *);
-int ec_GF2m_simple_add(const EC_GROUP *, EC_POINT *r, const EC_POINT *a,
-                       const EC_POINT *b, BN_CTX *);
-int ec_GF2m_simple_dbl(const EC_GROUP *, EC_POINT *r, const EC_POINT *a,
-                       BN_CTX *);
-int ec_GF2m_simple_invert(const EC_GROUP *, EC_POINT *, BN_CTX *);
-int ec_GF2m_simple_is_at_infinity(const EC_GROUP *, const EC_POINT *);
-int ec_GF2m_simple_is_on_curve(const EC_GROUP *, const EC_POINT *, BN_CTX *);
-int ec_GF2m_simple_cmp(const EC_GROUP *, const EC_POINT *a, const EC_POINT *b,
-                       BN_CTX *);
-int ec_GF2m_simple_make_affine(const EC_GROUP *, EC_POINT *, BN_CTX *);
-int ec_GF2m_simple_points_make_affine(const EC_GROUP *, size_t num,
-                                      EC_POINT *[], BN_CTX *);
-int ec_GF2m_simple_field_mul(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                             const BIGNUM *b, BN_CTX *);
-int ec_GF2m_simple_field_sqr(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                             BN_CTX *);
-int ec_GF2m_simple_field_div(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
-                             const BIGNUM *b, BN_CTX *);
+int ossl_ec_GF2m_simple_group_init(EC_GROUP *);
+void ossl_ec_GF2m_simple_group_finish(EC_GROUP *);
+void ossl_ec_GF2m_simple_group_clear_finish(EC_GROUP *);
+int ossl_ec_GF2m_simple_group_copy(EC_GROUP *, const EC_GROUP *);
+int ossl_ec_GF2m_simple_group_set_curve(EC_GROUP *, const BIGNUM *p,
+                                        const BIGNUM *a, const BIGNUM *b,
+                                        BN_CTX *);
+int ossl_ec_GF2m_simple_group_get_curve(const EC_GROUP *, BIGNUM *p, BIGNUM *a,
+                                        BIGNUM *b, BN_CTX *);
+int ossl_ec_GF2m_simple_group_get_degree(const EC_GROUP *);
+int ossl_ec_GF2m_simple_group_check_discriminant(const EC_GROUP *, BN_CTX *);
+int ossl_ec_GF2m_simple_point_init(EC_POINT *);
+void ossl_ec_GF2m_simple_point_finish(EC_POINT *);
+void ossl_ec_GF2m_simple_point_clear_finish(EC_POINT *);
+int ossl_ec_GF2m_simple_point_copy(EC_POINT *, const EC_POINT *);
+int ossl_ec_GF2m_simple_point_set_to_infinity(const EC_GROUP *, EC_POINT *);
+int ossl_ec_GF2m_simple_point_set_affine_coordinates(const EC_GROUP *,
+                                                     EC_POINT *,
+                                                     const BIGNUM *x,
+                                                     const BIGNUM *y, BN_CTX *);
+int ossl_ec_GF2m_simple_point_get_affine_coordinates(const EC_GROUP *,
+                                                     const EC_POINT *, BIGNUM *x,
+                                                     BIGNUM *y, BN_CTX *);
+int ossl_ec_GF2m_simple_set_compressed_coordinates(const EC_GROUP *, EC_POINT *,
+                                                   const BIGNUM *x, int y_bit,
+                                                   BN_CTX *);
+size_t ossl_ec_GF2m_simple_point2oct(const EC_GROUP *, const EC_POINT *,
+                                     point_conversion_form_t form,
+                                     unsigned char *buf, size_t len, BN_CTX *);
+int ossl_ec_GF2m_simple_oct2point(const EC_GROUP *, EC_POINT *,
+                                  const unsigned char *buf, size_t len, BN_CTX *);
+int ossl_ec_GF2m_simple_add(const EC_GROUP *, EC_POINT *r, const EC_POINT *a,
+                            const EC_POINT *b, BN_CTX *);
+int ossl_ec_GF2m_simple_dbl(const EC_GROUP *, EC_POINT *r, const EC_POINT *a,
+                            BN_CTX *);
+int ossl_ec_GF2m_simple_invert(const EC_GROUP *, EC_POINT *, BN_CTX *);
+int ossl_ec_GF2m_simple_is_at_infinity(const EC_GROUP *, const EC_POINT *);
+int ossl_ec_GF2m_simple_is_on_curve(const EC_GROUP *, const EC_POINT *, BN_CTX *);
+int ossl_ec_GF2m_simple_cmp(const EC_GROUP *, const EC_POINT *a,
+                            const EC_POINT *b, BN_CTX *);
+int ossl_ec_GF2m_simple_make_affine(const EC_GROUP *, EC_POINT *, BN_CTX *);
+int ossl_ec_GF2m_simple_points_make_affine(const EC_GROUP *, size_t num,
+                                           EC_POINT *[], BN_CTX *);
+int ossl_ec_GF2m_simple_field_mul(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                                  const BIGNUM *b, BN_CTX *);
+int ossl_ec_GF2m_simple_field_sqr(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                                  BN_CTX *);
+int ossl_ec_GF2m_simple_field_div(const EC_GROUP *, BIGNUM *r, const BIGNUM *a,
+                                 const BIGNUM *b, BN_CTX *);
 
 #ifndef OPENSSL_NO_EC_NISTP_64_GCC_128
 /* method functions in ecp_nistp224.c */
-int ec_GFp_nistp224_group_init(EC_GROUP *group);
-int ec_GFp_nistp224_group_set_curve(EC_GROUP *group, const BIGNUM *p,
-                                    const BIGNUM *a, const BIGNUM *n,
-                                    BN_CTX *);
-int ec_GFp_nistp224_point_get_affine_coordinates(const EC_GROUP *group,
-                                                 const EC_POINT *point,
-                                                 BIGNUM *x, BIGNUM *y,
-                                                 BN_CTX *ctx);
-int ec_GFp_nistp224_mul(const EC_GROUP *group, EC_POINT *r,
-                        const BIGNUM *scalar, size_t num,
-                        const EC_POINT *points[], const BIGNUM *scalars[],
-                        BN_CTX *);
-int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
-                               const BIGNUM *scalar, size_t num,
-                               const EC_POINT *points[],
-                               const BIGNUM *scalars[], BN_CTX *ctx);
-int ec_GFp_nistp224_precompute_mult(EC_GROUP *group, BN_CTX *ctx);
-int ec_GFp_nistp224_have_precompute_mult(const EC_GROUP *group);
+int ossl_ec_GFp_nistp224_group_init(EC_GROUP *group);
+int ossl_ec_GFp_nistp224_group_set_curve(EC_GROUP *group, const BIGNUM *p,
+                                         const BIGNUM *a, const BIGNUM *n,
+                                         BN_CTX *);
+int ossl_ec_GFp_nistp224_point_get_affine_coordinates(const EC_GROUP *group,
+                                                      const EC_POINT *point,
+                                                      BIGNUM *x, BIGNUM *y,
+                                                      BN_CTX *ctx);
+int ossl_ec_GFp_nistp224_mul(const EC_GROUP *group, EC_POINT *r,
+                             const BIGNUM *scalar, size_t num,
+                             const EC_POINT *points[], const BIGNUM *scalars[],
+                             BN_CTX *);
+int ossl_ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
+                                    const BIGNUM *scalar, size_t num,
+                                    const EC_POINT *points[],
+                                    const BIGNUM *scalars[], BN_CTX *ctx);
+int ossl_ec_GFp_nistp224_precompute_mult(EC_GROUP *group, BN_CTX *ctx);
+int ossl_ec_GFp_nistp224_have_precompute_mult(const EC_GROUP *group);
 
 /* method functions in ecp_nistp256.c */
-int ec_GFp_nistp256_group_init(EC_GROUP *group);
-int ec_GFp_nistp256_group_set_curve(EC_GROUP *group, const BIGNUM *p,
-                                    const BIGNUM *a, const BIGNUM *n,
-                                    BN_CTX *);
-int ec_GFp_nistp256_point_get_affine_coordinates(const EC_GROUP *group,
-                                                 const EC_POINT *point,
-                                                 BIGNUM *x, BIGNUM *y,
-                                                 BN_CTX *ctx);
-int ec_GFp_nistp256_mul(const EC_GROUP *group, EC_POINT *r,
-                        const BIGNUM *scalar, size_t num,
-                        const EC_POINT *points[], const BIGNUM *scalars[],
-                        BN_CTX *);
-int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
-                               const BIGNUM *scalar, size_t num,
-                               const EC_POINT *points[],
-                               const BIGNUM *scalars[], BN_CTX *ctx);
-int ec_GFp_nistp256_precompute_mult(EC_GROUP *group, BN_CTX *ctx);
-int ec_GFp_nistp256_have_precompute_mult(const EC_GROUP *group);
+int ossl_ec_GFp_nistp256_group_init(EC_GROUP *group);
+int ossl_ec_GFp_nistp256_group_set_curve(EC_GROUP *group, const BIGNUM *p,
+                                         const BIGNUM *a, const BIGNUM *n,
+                                         BN_CTX *);
+int ossl_ec_GFp_nistp256_point_get_affine_coordinates(const EC_GROUP *group,
+                                                      const EC_POINT *point,
+                                                      BIGNUM *x, BIGNUM *y,
+                                                      BN_CTX *ctx);
+int ossl_ec_GFp_nistp256_mul(const EC_GROUP *group, EC_POINT *r,
+                             const BIGNUM *scalar, size_t num,
+                             const EC_POINT *points[], const BIGNUM *scalars[],
+                             BN_CTX *);
+int ossl_ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
+                                    const BIGNUM *scalar, size_t num,
+                                    const EC_POINT *points[],
+                                    const BIGNUM *scalars[], BN_CTX *ctx);
+int ossl_ec_GFp_nistp256_precompute_mult(EC_GROUP *group, BN_CTX *ctx);
+int ossl_ec_GFp_nistp256_have_precompute_mult(const EC_GROUP *group);
 
 /* method functions in ecp_nistp521.c */
-int ec_GFp_nistp521_group_init(EC_GROUP *group);
-int ec_GFp_nistp521_group_set_curve(EC_GROUP *group, const BIGNUM *p,
-                                    const BIGNUM *a, const BIGNUM *n,
-                                    BN_CTX *);
-int ec_GFp_nistp521_point_get_affine_coordinates(const EC_GROUP *group,
-                                                 const EC_POINT *point,
-                                                 BIGNUM *x, BIGNUM *y,
-                                                 BN_CTX *ctx);
-int ec_GFp_nistp521_mul(const EC_GROUP *group, EC_POINT *r,
-                        const BIGNUM *scalar, size_t num,
-                        const EC_POINT *points[], const BIGNUM *scalars[],
-                        BN_CTX *);
-int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
-                               const BIGNUM *scalar, size_t num,
-                               const EC_POINT *points[],
-                               const BIGNUM *scalars[], BN_CTX *ctx);
-int ec_GFp_nistp521_precompute_mult(EC_GROUP *group, BN_CTX *ctx);
-int ec_GFp_nistp521_have_precompute_mult(const EC_GROUP *group);
+int ossl_ec_GFp_nistp521_group_init(EC_GROUP *group);
+int ossl_ec_GFp_nistp521_group_set_curve(EC_GROUP *group, const BIGNUM *p,
+                                         const BIGNUM *a, const BIGNUM *n,
+                                         BN_CTX *);
+int ossl_ec_GFp_nistp521_point_get_affine_coordinates(const EC_GROUP *group,
+                                                      const EC_POINT *point,
+                                                      BIGNUM *x, BIGNUM *y,
+                                                      BN_CTX *ctx);
+int ossl_ec_GFp_nistp521_mul(const EC_GROUP *group, EC_POINT *r,
+                             const BIGNUM *scalar, size_t num,
+                             const EC_POINT *points[], const BIGNUM *scalars[],
+                             BN_CTX *);
+int ossl_ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
+                                    const BIGNUM *scalar, size_t num,
+                                    const EC_POINT *points[],
+                                    const BIGNUM *scalars[], BN_CTX *ctx);
+int ossl_ec_GFp_nistp521_precompute_mult(EC_GROUP *group, BN_CTX *ctx);
+int ossl_ec_GFp_nistp521_have_precompute_mult(const EC_GROUP *group);
 
 /* utility functions in ecp_nistputil.c */
-void ec_GFp_nistp_points_make_affine_internal(size_t num, void *point_array,
-                                              size_t felem_size,
-                                              void *tmp_felems,
-                                              void (*felem_one) (void *out),
-                                              int (*felem_is_zero) (const void
-                                                                    *in),
-                                              void (*felem_assign) (void *out,
-                                                                    const void
-                                                                    *in),
-                                              void (*felem_square) (void *out,
-                                                                    const void
-                                                                    *in),
-                                              void (*felem_mul) (void *out,
-                                                                 const void
-                                                                 *in1,
-                                                                 const void
-                                                                 *in2),
-                                              void (*felem_inv) (void *out,
-                                                                 const void
-                                                                 *in),
-                                              void (*felem_contract) (void
-                                                                      *out,
-                                                                      const
-                                                                      void
-                                                                      *in));
-void ec_GFp_nistp_recode_scalar_bits(unsigned char *sign,
-                                     unsigned char *digit, unsigned char in);
+void ossl_ec_GFp_nistp_points_make_affine_internal(size_t num, void *point_array,
+                                                   size_t felem_size,
+                                                   void *tmp_felems,
+                                                   void (*felem_one) (void *out),
+                                                   int (*felem_is_zero)
+                                                       (const void *in),
+                                                   void (*felem_assign)
+                                                       (void *out, const void *in),
+                                                   void (*felem_square)
+                                                       (void *out, const void *in),
+                                                   void (*felem_mul)
+                                                       (void *out,
+                                                        const void *in1,
+                                                        const void *in2),
+                                                   void (*felem_inv)
+                                                       (void *out, const void *in),
+                                                   void (*felem_contract)
+                                                       (void *out, const void *in));
+void ossl_ec_GFp_nistp_recode_scalar_bits(unsigned char *sign,
+                                          unsigned char *digit,
+                                          unsigned char in);
 #endif
-int ec_group_simple_order_bits(const EC_GROUP *group);
+int ossl_ec_group_simple_order_bits(const EC_GROUP *group);
 
 /**
  *  Creates a new EC_GROUP object
@@ -601,8 +601,8 @@ int ec_group_simple_order_bits(const EC_GROUP *group);
  *  \param   meth   EC_METHOD to use
  *  \return  newly created EC_GROUP object or NULL in case of an error.
  */
-EC_GROUP *ec_group_new_ex(OSSL_LIB_CTX *libctx, const char *propq,
-                          const EC_METHOD *meth);
+EC_GROUP *ossl_ec_group_new_ex(OSSL_LIB_CTX *libctx, const char *propq,
+                               const EC_METHOD *meth);
 
 #ifdef ECP_NISTZ256_ASM
 /** Returns GFp methods using montgomery multiplication, with x86-64 optimized
@@ -617,14 +617,15 @@ const EC_METHOD *EC_GFp_s390x_nistp384_method(void);
 const EC_METHOD *EC_GFp_s390x_nistp521_method(void);
 #endif
 
-size_t ec_key_simple_priv2oct(const EC_KEY *eckey,
-                              unsigned char *buf, size_t len);
-int ec_key_simple_oct2priv(EC_KEY *eckey, const unsigned char *buf, size_t len);
-int ec_key_simple_generate_key(EC_KEY *eckey);
-int ec_key_simple_generate_public_key(EC_KEY *eckey);
-int ec_key_simple_check_key(const EC_KEY *eckey);
+size_t ossl_ec_key_simple_priv2oct(const EC_KEY *eckey,
+                                   unsigned char *buf, size_t len);
+int ossl_ec_key_simple_oct2priv(EC_KEY *eckey, const unsigned char *buf,
+                                size_t len);
+int ossl_ec_key_simple_generate_key(EC_KEY *eckey);
+int ossl_ec_key_simple_generate_public_key(EC_KEY *eckey);
+int ossl_ec_key_simple_check_key(const EC_KEY *eckey);
 
-int ec_curve_nid_from_params(const EC_GROUP *group, BN_CTX *ctx);
+int ossl_ec_curve_nid_from_params(const EC_GROUP *group, BN_CTX *ctx);
 
 /* EC_METHOD definitions */
 
@@ -657,14 +658,14 @@ struct ec_key_method_st {
 
 #define EC_KEY_METHOD_DYNAMIC   1
 
-EC_KEY *ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
-                              ENGINE *engine);
+EC_KEY *ossl_ec_key_new_method_int(OSSL_LIB_CTX *libctx, const char *propq,
+                                   ENGINE *engine);
 
 int ossl_ec_key_gen(EC_KEY *eckey);
 int ossl_ecdh_compute_key(unsigned char **pout, size_t *poutlen,
                           const EC_POINT *pub_key, const EC_KEY *ecdh);
-int ecdh_simple_compute_key(unsigned char **pout, size_t *poutlen,
-                            const EC_POINT *pub_key, const EC_KEY *ecdh);
+int ossl_ecdh_simple_compute_key(unsigned char **pout, size_t *poutlen,
+                                 const EC_POINT *pub_key, const EC_KEY *ecdh);
 
 struct ECDSA_SIG_st {
     BIGNUM *r;
@@ -683,13 +684,13 @@ int ossl_ecdsa_verify(int type, const unsigned char *dgst, int dgst_len,
                       const unsigned char *sigbuf, int sig_len, EC_KEY *eckey);
 int ossl_ecdsa_verify_sig(const unsigned char *dgst, int dgst_len,
                           const ECDSA_SIG *sig, EC_KEY *eckey);
-int ecdsa_simple_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp,
-                            BIGNUM **rp);
-ECDSA_SIG *ecdsa_simple_sign_sig(const unsigned char *dgst, int dgst_len,
-                                 const BIGNUM *in_kinv, const BIGNUM *in_r,
-                                 EC_KEY *eckey);
-int ecdsa_simple_verify_sig(const unsigned char *dgst, int dgst_len,
-                            const ECDSA_SIG *sig, EC_KEY *eckey);
+int ossl_ecdsa_simple_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp,
+                                 BIGNUM **rp);
+ECDSA_SIG *ossl_ecdsa_simple_sign_sig(const unsigned char *dgst, int dgst_len,
+                                      const BIGNUM *in_kinv, const BIGNUM *in_r,
+                                      EC_KEY *eckey);
+int ossl_ecdsa_simple_verify_sig(const unsigned char *dgst, int dgst_len,
+                                 const ECDSA_SIG *sig, EC_KEY *eckey);
 
 
 /*-
@@ -721,11 +722,12 @@ int ecdsa_simple_verify_sig(const unsigned char *dgst, int dgst_len,
  *
  * Returns 1 on success, 0 otherwise.
  */
-int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
-                         const BIGNUM *scalar, const EC_POINT *point,
-                         BN_CTX *ctx);
+int ossl_ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
+                              const BIGNUM *scalar, const EC_POINT *point,
+                              BN_CTX *ctx);
 
-int ec_point_blind_coordinates(const EC_GROUP *group, EC_POINT *p, BN_CTX *ctx);
+int ossl_ec_point_blind_coordinates(const EC_GROUP *group, EC_POINT *p,
+                                    BN_CTX *ctx);
 
 static ossl_inline int ec_point_ladder_pre(const EC_GROUP *group,
                                            EC_POINT *r, EC_POINT *s,
diff --git a/crypto/ec/ec_mult.c b/crypto/ec/ec_mult.c
index c1df0b8af7..ed5d403270 100644
--- a/crypto/ec/ec_mult.c
+++ b/crypto/ec/ec_mult.c
@@ -142,9 +142,9 @@ void EC_ec_pre_comp_free(EC_PRE_COMP *pre)
  *
  * Returns 1 on success, 0 otherwise.
  */
-int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
-                         const BIGNUM *scalar, const EC_POINT *point,
-                         BN_CTX *ctx)
+int ossl_ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
+                              const BIGNUM *scalar, const EC_POINT *point,
+                              BN_CTX *ctx)
 {
     int i, cardinality_bits, group_top, kbit, pbit, Z_is_one;
     EC_POINT *p = NULL;
@@ -407,9 +407,9 @@ int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,
  *      scalar*generator
  * in the addition if scalar != NULL
  */
-int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
-                size_t num, const EC_POINT *points[], const BIGNUM *scalars[],
-                BN_CTX *ctx)
+int ossl_ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
+                     size_t num, const EC_POINT *points[],
+                     const BIGNUM *scalars[], BN_CTX *ctx)
 {
     const EC_POINT *generator = NULL;
     EC_POINT *tmp = NULL;
@@ -450,7 +450,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
              * is why we ignore if BN_FLG_CONSTTIME is actually set and we
              * always call the ladder version.
              */
-            return ec_scalar_mul_ladder(group, r, scalar, NULL, ctx);
+            return ossl_ec_scalar_mul_ladder(group, r, scalar, NULL, ctx);
         }
         if ((scalar == NULL) &amp;&amp; (num == 1) &amp;&amp; (scalars[0] != group-&gt;order)) {
             /*-
@@ -460,7 +460,8 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
              * To protect the secret scalar, we ignore if BN_FLG_CONSTTIME is
              * actually set and we always call the ladder version.
              */
-            return ec_scalar_mul_ladder(group, r, scalars[0], points[0], ctx);
+            return ossl_ec_scalar_mul_ladder(group, r, scalars[0], points[0],
+                                             ctx);
         }
     }
 
@@ -753,11 +754,11 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
                          * Apply coordinate blinding for EC_POINT.
                          *
                          * The underlying EC_METHOD can optionally implement this function:
-                         * ec_point_blind_coordinates() returns 0 in case of errors or 1 on
+                         * ossl_ec_point_blind_coordinates() returns 0 in case of errors or 1 on
                          * success or if coordinate blinding is not implemented for this
                          * group.
                          */
-                        if (!ec_point_blind_coordinates(group, r, ctx)) {
+                        if (!ossl_ec_point_blind_coordinates(group, r, ctx)) {
                             ERR_raise(ERR_LIB_EC, EC_R_POINT_COORDINATES_BLIND_FAILURE);
                             goto err;
                         }
@@ -807,9 +808,9 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
 }
 
 /*-
- * ec_wNAF_precompute_mult()
+ * ossl_ec_wNAF_precompute_mult()
  * creates an EC_PRE_COMP object with preprecomputed multiples of the generator
- * for use with wNAF splitting as implemented in ec_wNAF_mul().
+ * for use with wNAF splitting as implemented in ossl_ec_wNAF_mul().
  *
  * 'pre_comp-&gt;points' is an array of multiples of the generator
  * of the following form:
@@ -826,7 +827,7 @@ int ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,
  * points[2^(w-1)*numblocks-1]     = (2^(w-1)) *  2^(blocksize*(numblocks-1)) * generator
  * points[2^(w-1)*numblocks]       = NULL
  */
-int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
+int ossl_ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
 {
     const EC_POINT *generator;
     EC_POINT *tmp_point = NULL, *base = NULL, **var;
@@ -987,7 +988,7 @@ int ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
     return ret;
 }
 
-int ec_wNAF_have_precompute_mult(const EC_GROUP *group)
+int ossl_ec_wNAF_have_precompute_mult(const EC_GROUP *group)
 {
     return HAVEPRECOMP(group, ec);
 }
diff --git a/crypto/ec/ec_oct.c b/crypto/ec/ec_oct.c
index 0dbe299c41..cb9352d639 100644
--- a/crypto/ec/ec_oct.c
+++ b/crypto/ec/ec_oct.c
@@ -35,8 +35,8 @@ int EC_POINT_set_compressed_coordinates(const EC_GROUP *group, EC_POINT *point,
     }
     if (group-&gt;meth-&gt;flags &amp; EC_FLAGS_DEFAULT_OCT) {
         if (group-&gt;meth-&gt;field_type == NID_X9_62_prime_field)
-            return ec_GFp_simple_set_compressed_coordinates(group, point, x,
-                                                            y_bit, ctx);
+            return ossl_ec_GFp_simple_set_compressed_coordinates(group, point, x,
+                                                                 y_bit, ctx);
         else
 #ifdef OPENSSL_NO_EC2M
         {
@@ -44,8 +44,8 @@ int EC_POINT_set_compressed_coordinates(const EC_GROUP *group, EC_POINT *point,
             return 0;
         }
 #else
-            return ec_GF2m_simple_set_compressed_coordinates(group, point, x,
-                                                             y_bit, ctx);
+            return ossl_ec_GF2m_simple_set_compressed_coordinates(group, point,
+                                                                  x, y_bit, ctx);
 #endif
     }
     return group-&gt;meth-&gt;point_set_compressed_coordinates(group, point, x,
@@ -85,7 +85,8 @@ size_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *point,
     }
     if (group-&gt;meth-&gt;flags &amp; EC_FLAGS_DEFAULT_OCT) {
         if (group-&gt;meth-&gt;field_type == NID_X9_62_prime_field)
-            return ec_GFp_simple_point2oct(group, point, form, buf, len, ctx);
+            return ossl_ec_GFp_simple_point2oct(group, point, form, buf, len,
+                                                ctx);
         else
 #ifdef OPENSSL_NO_EC2M
         {
@@ -93,8 +94,8 @@ size_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *point,
             return 0;
         }
 #else
-            return ec_GF2m_simple_point2oct(group, point,
-                                            form, buf, len, ctx);
+            return ossl_ec_GF2m_simple_point2oct(group, point,
+                                                 form, buf, len, ctx);
 #endif
     }
 
@@ -115,7 +116,7 @@ int EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *point,
     }
     if (group-&gt;meth-&gt;flags &amp; EC_FLAGS_DEFAULT_OCT) {
         if (group-&gt;meth-&gt;field_type == NID_X9_62_prime_field)
-            return ec_GFp_simple_oct2point(group, point, buf, len, ctx);
+            return ossl_ec_GFp_simple_oct2point(group, point, buf, len, ctx);
         else
 #ifdef OPENSSL_NO_EC2M
         {
@@ -123,7 +124,7 @@ int EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *point,
             return 0;
         }
 #else
-            return ec_GF2m_simple_oct2point(group, point, buf, len, ctx);
+            return ossl_ec_GF2m_simple_oct2point(group, point, buf, len, ctx);
 #endif
     }
     return group-&gt;meth-&gt;oct2point(group, point, buf, len, ctx);
diff --git a/crypto/ec/ec_pmeth.c b/crypto/ec/ec_pmeth.c
index d660bf8682..2280189e28 100644
--- a/crypto/ec/ec_pmeth.c
+++ b/crypto/ec/ec_pmeth.c
@@ -218,9 +218,9 @@ static int pkey_ec_kdf_derive(EVP_PKEY_CTX *ctx,
     if (!pkey_ec_derive(ctx, ktmp, &amp;ktmplen))
         goto err;
     /* Do KDF stuff */
-    if (!ecdh_KDF_X9_63(key, *keylen, ktmp, ktmplen,
-                        dctx-&gt;kdf_ukm, dctx-&gt;kdf_ukmlen, dctx-&gt;kdf_md,
-                        ctx-&gt;libctx, ctx-&gt;propquery))
+    if (!ossl_ecdh_kdf_X9_63(key, *keylen, ktmp, ktmplen,
+                             dctx-&gt;kdf_ukm, dctx-&gt;kdf_ukmlen, dctx-&gt;kdf_md,
+                             ctx-&gt;libctx, ctx-&gt;propquery))
         goto err;
     rv = 1;
 
@@ -486,7 +486,7 @@ static const EVP_PKEY_METHOD ec_pkey_meth = {
     pkey_ec_ctrl_str
 };
 
-const EVP_PKEY_METHOD *ec_pkey_method(void)
+const EVP_PKEY_METHOD *ossl_ec_pkey_method(void)
 {
     return &amp;ec_pkey_meth;
 }
diff --git a/crypto/ec/ecdh_kdf.c b/crypto/ec/ecdh_kdf.c
index df0858a032..60e976a95f 100644
--- a/crypto/ec/ecdh_kdf.c
+++ b/crypto/ec/ecdh_kdf.c
@@ -21,11 +21,11 @@
 #include &quot;ec_local.h&quot;
 
 /* Key derivation function from X9.63/SECG */
-int ecdh_KDF_X9_63(unsigned char *out, size_t outlen,
-                   const unsigned char *Z, size_t Zlen,
-                   const unsigned char *sinfo, size_t sinfolen,
-                   const EVP_MD *md,
-                   OSSL_LIB_CTX *libctx, const char *propq)
+int ossl_ecdh_kdf_X9_63(unsigned char *out, size_t outlen,
+                        const unsigned char *Z, size_t Zlen,
+                        const unsigned char *sinfo, size_t sinfolen,
+                        const EVP_MD *md,
+                        OSSL_LIB_CTX *libctx, const char *propq)
 {
     int ret = 0;
     EVP_KDF_CTX *kctx = NULL;
@@ -60,6 +60,7 @@ int ECDH_KDF_X9_62(unsigned char *out, size_t outlen,
                    const unsigned char *sinfo, size_t sinfolen,
                    const EVP_MD *md)
 {
-    return ecdh_KDF_X9_63(out, outlen, Z, Zlen, sinfo, sinfolen, md, NULL, NULL);
+    return ossl_ecdh_kdf_X9_63(out, outlen, Z, Zlen, sinfo, sinfolen, md, NULL,
+                               NULL);
 }
 #endif
diff --git a/crypto/ec/ecdh_ossl.c b/crypto/ec/ecdh_ossl.c
index a42fb55ddc..8a521fd4a5 100644
--- a/crypto/ec/ecdh_ossl.c
+++ b/crypto/ec/ecdh_ossl.c
@@ -46,8 +46,8 @@ int ossl_ecdh_compute_key(unsigned char **psec, size_t *pseclen,
  * See Section 5.7.1.2 &quot;Elliptic Curve Cryptography Cofactor Diffie-Hellman
  * (ECC CDH) Primitive:&quot;. The steps listed below refer to SP800-56A.
  */
-int ecdh_simple_compute_key(unsigned char **pout, size_t *poutlen,
-                            const EC_POINT *pub_key, const EC_KEY *ecdh)
+int ossl_ecdh_simple_compute_key(unsigned char **pout, size_t *poutlen,
+                                 const EC_POINT *pub_key, const EC_KEY *ecdh)
 {
     BN_CTX *ctx;
     EC_POINT *tmp = NULL;
diff --git a/crypto/ec/ecdsa_ossl.c b/crypto/ec/ecdsa_ossl.c
index c697199cce..d6df93a7de 100644
--- a/crypto/ec/ecdsa_ossl.c
+++ b/crypto/ec/ecdsa_ossl.c
@@ -160,7 +160,7 @@ static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,
     } while (BN_is_zero(r));
 
     /* compute the inverse of k */
-    if (!ec_group_do_inverse_ord(group, k, k, ctx)) {
+    if (!ossl_ec_group_do_inverse_ord(group, k, k, ctx)) {
         ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
@@ -184,15 +184,15 @@ static int ecdsa_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in,
     return ret;
 }
 
-int ecdsa_simple_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp,
-                            BIGNUM **rp)
+int ossl_ecdsa_simple_sign_setup(EC_KEY *eckey, BN_CTX *ctx_in, BIGNUM **kinvp,
+                                 BIGNUM **rp)
 {
     return ecdsa_sign_setup(eckey, ctx_in, kinvp, rp, NULL, 0);
 }
 
-ECDSA_SIG *ecdsa_simple_sign_sig(const unsigned char *dgst, int dgst_len,
-                                 const BIGNUM *in_kinv, const BIGNUM *in_r,
-                                 EC_KEY *eckey)
+ECDSA_SIG *ossl_ecdsa_simple_sign_sig(const unsigned char *dgst, int dgst_len,
+                                      const BIGNUM *in_kinv, const BIGNUM *in_r,
+                                      EC_KEY *eckey)
 {
     int ok = 0, i;
     BIGNUM *kinv = NULL, *s, *m = NULL;
@@ -353,8 +353,8 @@ int ossl_ecdsa_verify(int type, const unsigned char *dgst, int dgst_len,
     return ret;
 }
 
-int ecdsa_simple_verify_sig(const unsigned char *dgst, int dgst_len,
-                            const ECDSA_SIG *sig, EC_KEY *eckey)
+int ossl_ecdsa_simple_verify_sig(const unsigned char *dgst, int dgst_len,
+                                 const ECDSA_SIG *sig, EC_KEY *eckey)
 {
     int ret = -1, i;
     BN_CTX *ctx;
@@ -405,7 +405,7 @@ int ecdsa_simple_verify_sig(const unsigned char *dgst, int dgst_len,
         goto err;
     }
     /* calculate tmp1 = inv(S) mod order */
-    if (!ec_group_do_inverse_ord(group, u2, sig-&gt;s, ctx)) {
+    if (!ossl_ec_group_do_inverse_ord(group, u2, sig-&gt;s, ctx)) {
         ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
diff --git a/crypto/ec/ecp_mont.c b/crypto/ec/ecp_mont.c
index def39368e4..8dc1c2f0b3 100644
--- a/crypto/ec/ecp_mont.c
+++ b/crypto/ec/ecp_mont.c
@@ -23,99 +23,99 @@ const EC_METHOD *EC_GFp_mont_method(void)
     static const EC_METHOD ret = {
         EC_FLAGS_DEFAULT_OCT,
         NID_X9_62_prime_field,
-        ec_GFp_mont_group_init,
-        ec_GFp_mont_group_finish,
-        ec_GFp_mont_group_clear_finish,
-        ec_GFp_mont_group_copy,
-        ec_GFp_mont_group_set_curve,
-        ec_GFp_simple_group_get_curve,
-        ec_GFp_simple_group_get_degree,
-        ec_group_simple_order_bits,
-        ec_GFp_simple_group_check_discriminant,
-        ec_GFp_simple_point_init,
-        ec_GFp_simple_point_finish,
-        ec_GFp_simple_point_clear_finish,
-        ec_GFp_simple_point_copy,
-        ec_GFp_simple_point_set_to_infinity,
-        ec_GFp_simple_point_set_affine_coordinates,
-        ec_GFp_simple_point_get_affine_coordinates,
+        ossl_ec_GFp_mont_group_init,
+        ossl_ec_GFp_mont_group_finish,
+        ossl_ec_GFp_mont_group_clear_finish,
+        ossl_ec_GFp_mont_group_copy,
+        ossl_ec_GFp_mont_group_set_curve,
+        ossl_ec_GFp_simple_group_get_curve,
+        ossl_ec_GFp_simple_group_get_degree,
+        ossl_ec_group_simple_order_bits,
+        ossl_ec_GFp_simple_group_check_discriminant,
+        ossl_ec_GFp_simple_point_init,
+        ossl_ec_GFp_simple_point_finish,
+        ossl_ec_GFp_simple_point_clear_finish,
+        ossl_ec_GFp_simple_point_copy,
+        ossl_ec_GFp_simple_point_set_to_infinity,
+        ossl_ec_GFp_simple_point_set_affine_coordinates,
+        ossl_ec_GFp_simple_point_get_affine_coordinates,
         0, 0, 0,
-        ec_GFp_simple_add,
-        ec_GFp_simple_dbl,
-        ec_GFp_simple_invert,
-        ec_GFp_simple_is_at_infinity,
-        ec_GFp_simple_is_on_curve,
-        ec_GFp_simple_cmp,
-        ec_GFp_simple_make_affine,
-        ec_GFp_simple_points_make_affine,
+        ossl_ec_GFp_simple_add,
+        ossl_ec_GFp_simple_dbl,
+        ossl_ec_GFp_simple_invert,
+        ossl_ec_GFp_simple_is_at_infinity,
+        ossl_ec_GFp_simple_is_on_curve,
+        ossl_ec_GFp_simple_cmp,
+        ossl_ec_GFp_simple_make_affine,
+        ossl_ec_GFp_simple_points_make_affine,
         0 /* mul */ ,
         0 /* precompute_mult */ ,
         0 /* have_precompute_mult */ ,
-        ec_GFp_mont_field_mul,
-        ec_GFp_mont_field_sqr,
+        ossl_ec_GFp_mont_field_mul,
+        ossl_ec_GFp_mont_field_sqr,
         0 /* field_div */ ,
-        ec_GFp_mont_field_inv,
-        ec_GFp_mont_field_encode,
-        ec_GFp_mont_field_decode,
-        ec_GFp_mont_field_set_to_one,
-        ec_key_simple_priv2oct,
-        ec_key_simple_oct2priv,
+        ossl_ec_GFp_mont_field_inv,
+        ossl_ec_GFp_mont_field_encode,
+        ossl_ec_GFp_mont_field_decode,
+        ossl_ec_GFp_mont_field_set_to_one,
+        ossl_ec_key_simple_priv2oct,
+        ossl_ec_key_simple_oct2priv,
         0, /* set private */
-        ec_key_simple_generate_key,
-        ec_key_simple_check_key,
-        ec_key_simple_generate_public_key,
+        ossl_ec_key_simple_generate_key,
+        ossl_ec_key_simple_check_key,
+        ossl_ec_key_simple_generate_public_key,
         0, /* keycopy */
         0, /* keyfinish */
-        ecdh_simple_compute_key,
-        ecdsa_simple_sign_setup,
-        ecdsa_simple_sign_sig,
-        ecdsa_simple_verify_sig,
+        ossl_ecdh_simple_compute_key,
+        ossl_ecdsa_simple_sign_setup,
+        ossl_ecdsa_simple_sign_sig,
+        ossl_ecdsa_simple_verify_sig,
         0, /* field_inverse_mod_ord */
-        ec_GFp_simple_blind_coordinates,
-        ec_GFp_simple_ladder_pre,
-        ec_GFp_simple_ladder_step,
-        ec_GFp_simple_ladder_post
+        ossl_ec_GFp_simple_blind_coordinates,
+        ossl_ec_GFp_simple_ladder_pre,
+        ossl_ec_GFp_simple_ladder_step,
+        ossl_ec_GFp_simple_ladder_post
     };
 
     return &ret;
 }
 
-int ec_GFp_mont_group_init(EC_GROUP *group)
+int ossl_ec_GFp_mont_group_init(EC_GROUP *group)
 {
     int ok;
 
-    ok = ec_GFp_simple_group_init(group);
+    ok = ossl_ec_GFp_simple_group_init(group);
     group-&gt;field_data1 = NULL;
     group-&gt;field_data2 = NULL;
     return ok;
 }
 
-void ec_GFp_mont_group_finish(EC_GROUP *group)
+void ossl_ec_GFp_mont_group_finish(EC_GROUP *group)
 {
     BN_MONT_CTX_free(group-&gt;field_data1);
     group-&gt;field_data1 = NULL;
     BN_free(group-&gt;field_data2);
     group-&gt;field_data2 = NULL;
-    ec_GFp_simple_group_finish(group);
+    ossl_ec_GFp_simple_group_finish(group);
 }
 
-void ec_GFp_mont_group_clear_finish(EC_GROUP *group)
+void ossl_ec_GFp_mont_group_clear_finish(EC_GROUP *group)
 {
     BN_MONT_CTX_free(group-&gt;field_data1);
     group-&gt;field_data1 = NULL;
     BN_clear_free(group-&gt;field_data2);
     group-&gt;field_data2 = NULL;
-    ec_GFp_simple_group_clear_finish(group);
+    ossl_ec_GFp_simple_group_clear_finish(group);
 }
 
-int ec_GFp_mont_group_copy(EC_GROUP *dest, const EC_GROUP *src)
+int ossl_ec_GFp_mont_group_copy(EC_GROUP *dest, const EC_GROUP *src)
 {
     BN_MONT_CTX_free(dest-&gt;field_data1);
     dest-&gt;field_data1 = NULL;
     BN_clear_free(dest-&gt;field_data2);
     dest-&gt;field_data2 = NULL;
 
-    if (!ec_GFp_simple_group_copy(dest, src))
+    if (!ossl_ec_GFp_simple_group_copy(dest, src))
         return 0;
 
     if (src-&gt;field_data1 != NULL) {
@@ -139,8 +139,9 @@ int ec_GFp_mont_group_copy(EC_GROUP *dest, const EC_GROUP *src)
     return 0;
 }
 
-int ec_GFp_mont_group_set_curve(EC_GROUP *group, const BIGNUM *p,
-                                const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GFp_mont_group_set_curve(EC_GROUP *group, const BIGNUM *p,
+                                     const BIGNUM *a, const BIGNUM *b,
+                                     BN_CTX *ctx)
 {
     BN_CTX *new_ctx = NULL;
     BN_MONT_CTX *mont = NULL;
@@ -176,7 +177,7 @@ int ec_GFp_mont_group_set_curve(EC_GROUP *group, const BIGNUM *p,
     group-&gt;field_data2 = one;
     one = NULL;
 
-    ret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
+    ret = ossl_ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
 
     if (!ret) {
         BN_MONT_CTX_free(group-&gt;field_data1);
@@ -192,8 +193,8 @@ int ec_GFp_mont_group_set_curve(EC_GROUP *group, const BIGNUM *p,
     return ret;
 }
 
-int ec_GFp_mont_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
-                          const BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GFp_mont_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
+                               const BIGNUM *b, BN_CTX *ctx)
 {
     if (group-&gt;field_data1 == NULL) {
         ERR_raise(ERR_LIB_EC, EC_R_NOT_INITIALIZED);
@@ -203,8 +204,8 @@ int ec_GFp_mont_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
     return BN_mod_mul_montgomery(r, a, b, group-&gt;field_data1, ctx);
 }
 
-int ec_GFp_mont_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
-                          BN_CTX *ctx)
+int ossl_ec_GFp_mont_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
+                               BN_CTX *ctx)
 {
     if (group-&gt;field_data1 == NULL) {
         ERR_raise(ERR_LIB_EC, EC_R_NOT_INITIALIZED);
@@ -219,8 +220,8 @@ int ec_GFp_mont_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
  * If a is zero (or equivalent), you'll get a EC_R_CANNOT_INVERT error.
  * We have a Mont structure, so SCA hardening is FLT inversion.
  */
-int ec_GFp_mont_field_inv(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
-                            BN_CTX *ctx)
+int ossl_ec_GFp_mont_field_inv(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
+                               BN_CTX *ctx)
 {
     BIGNUM *e = NULL;
     BN_CTX *new_ctx = NULL;
@@ -263,8 +264,8 @@ int ec_GFp_mont_field_inv(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
     return ret;
 }
 
-int ec_GFp_mont_field_encode(const EC_GROUP *group, BIGNUM *r,
-                             const BIGNUM *a, BN_CTX *ctx)
+int ossl_ec_GFp_mont_field_encode(const EC_GROUP *group, BIGNUM *r,
+                                  const BIGNUM *a, BN_CTX *ctx)
 {
     if (group-&gt;field_data1 == NULL) {
         ERR_raise(ERR_LIB_EC, EC_R_NOT_INITIALIZED);
@@ -274,8 +275,8 @@ int ec_GFp_mont_field_encode(const EC_GROUP *group, BIGNUM *r,
     return BN_to_montgomery(r, a, (BN_MONT_CTX *)group-&gt;field_data1, ctx);
 }
 
-int ec_GFp_mont_field_decode(const EC_GROUP *group, BIGNUM *r,
-                             const BIGNUM *a, BN_CTX *ctx)
+int ossl_ec_GFp_mont_field_decode(const EC_GROUP *group, BIGNUM *r,
+                                  const BIGNUM *a, BN_CTX *ctx)
 {
     if (group-&gt;field_data1 == NULL) {
         ERR_raise(ERR_LIB_EC, EC_R_NOT_INITIALIZED);
@@ -285,8 +286,8 @@ int ec_GFp_mont_field_decode(const EC_GROUP *group, BIGNUM *r,
     return BN_from_montgomery(r, a, group-&gt;field_data1, ctx);
 }
 
-int ec_GFp_mont_field_set_to_one(const EC_GROUP *group, BIGNUM *r,
-                                 BN_CTX *ctx)
+int ossl_ec_GFp_mont_field_set_to_one(const EC_GROUP *group, BIGNUM *r,
+                                      BN_CTX *ctx)
 {
     if (group-&gt;field_data2 == NULL) {
         ERR_raise(ERR_LIB_EC, EC_R_NOT_INITIALIZED);
diff --git a/crypto/ec/ecp_nist.c b/crypto/ec/ecp_nist.c
index 2809043dac..e41a67f647 100644
--- a/crypto/ec/ecp_nist.c
+++ b/crypto/ec/ecp_nist.c
@@ -25,72 +25,73 @@ const EC_METHOD *EC_GFp_nist_method(void)
     static const EC_METHOD ret = {
         EC_FLAGS_DEFAULT_OCT,
         NID_X9_62_prime_field,
-        ec_GFp_simple_group_init,
-        ec_GFp_simple_group_finish,
-        ec_GFp_simple_group_clear_finish,
-        ec_GFp_nist_group_copy,
-        ec_GFp_nist_group_set_curve,
-        ec_GFp_simple_group_get_curve,
-        ec_GFp_simple_group_get_degree,
-        ec_group_simple_order_bits,
-        ec_GFp_simple_group_check_discriminant,
-        ec_GFp_simple_point_init,
-        ec_GFp_simple_point_finish,
-        ec_GFp_simple_point_clear_finish,
-        ec_GFp_simple_point_copy,
-        ec_GFp_simple_point_set_to_infinity,
-        ec_GFp_simple_point_set_affine_coordinates,
-        ec_GFp_simple_point_get_affine_coordinates,
+        ossl_ec_GFp_simple_group_init,
+        ossl_ec_GFp_simple_group_finish,
+        ossl_ec_GFp_simple_group_clear_finish,
+        ossl_ec_GFp_nist_group_copy,
+        ossl_ec_GFp_nist_group_set_curve,
+        ossl_ec_GFp_simple_group_get_curve,
+        ossl_ec_GFp_simple_group_get_degree,
+        ossl_ec_group_simple_order_bits,
+        ossl_ec_GFp_simple_group_check_discriminant,
+        ossl_ec_GFp_simple_point_init,
+        ossl_ec_GFp_simple_point_finish,
+        ossl_ec_GFp_simple_point_clear_finish,
+        ossl_ec_GFp_simple_point_copy,
+        ossl_ec_GFp_simple_point_set_to_infinity,
+        ossl_ec_GFp_simple_point_set_affine_coordinates,
+        ossl_ec_GFp_simple_point_get_affine_coordinates,
         0, 0, 0,
-        ec_GFp_simple_add,
-        ec_GFp_simple_dbl,
-        ec_GFp_simple_invert,
-        ec_GFp_simple_is_at_infinity,
-        ec_GFp_simple_is_on_curve,
-        ec_GFp_simple_cmp,
-        ec_GFp_simple_make_affine,
-        ec_GFp_simple_points_make_affine,
+        ossl_ec_GFp_simple_add,
+        ossl_ec_GFp_simple_dbl,
+        ossl_ec_GFp_simple_invert,
+        ossl_ec_GFp_simple_is_at_infinity,
+        ossl_ec_GFp_simple_is_on_curve,
+        ossl_ec_GFp_simple_cmp,
+        ossl_ec_GFp_simple_make_affine,
+        ossl_ec_GFp_simple_points_make_affine,
         0 /* mul */ ,
         0 /* precompute_mult */ ,
         0 /* have_precompute_mult */ ,
-        ec_GFp_nist_field_mul,
-        ec_GFp_nist_field_sqr,
+        ossl_ec_GFp_nist_field_mul,
+        ossl_ec_GFp_nist_field_sqr,
         0 /* field_div */ ,
-        ec_GFp_simple_field_inv,
+        ossl_ec_GFp_simple_field_inv,
         0 /* field_encode */ ,
         0 /* field_decode */ ,
         0,                      /* field_set_to_one */
-        ec_key_simple_priv2oct,
-        ec_key_simple_oct2priv,
+        ossl_ec_key_simple_priv2oct,
+        ossl_ec_key_simple_oct2priv,
         0, /* set private */
-        ec_key_simple_generate_key,
-        ec_key_simple_check_key,
-        ec_key_simple_generate_public_key,
+        ossl_ec_key_simple_generate_key,
+        ossl_ec_key_simple_check_key,
+        ossl_ec_key_simple_generate_public_key,
         0, /* keycopy */
         0, /* keyfinish */
-        ecdh_simple_compute_key,
-        ecdsa_simple_sign_setup,
-        ecdsa_simple_sign_sig,
-        ecdsa_simple_verify_sig,
+        ossl_ecdh_simple_compute_key,
+        ossl_ecdsa_simple_sign_setup,
+        ossl_ecdsa_simple_sign_sig,
+        ossl_ecdsa_simple_verify_sig,
         0, /* field_inverse_mod_ord */
-        ec_GFp_simple_blind_coordinates,
-        ec_GFp_simple_ladder_pre,
-        ec_GFp_simple_ladder_step,
-        ec_GFp_simple_ladder_post
+        ossl_ec_GFp_simple_blind_coordinates,
+        ossl_ec_GFp_simple_ladder_pre,
+        ossl_ec_GFp_simple_ladder_step,
+        ossl_ec_GFp_simple_ladder_post
     };
 
     return &ret;
 }
 
-int ec_GFp_nist_group_copy(EC_GROUP *dest, const EC_GROUP *src)
+int ossl_ec_GFp_nist_group_copy(EC_GROUP *dest, const EC_GROUP *src)
 {
     dest-&gt;field_mod_func = src-&gt;field_mod_func;
 
-    return ec_GFp_simple_group_copy(dest, src);
+    return ossl_ec_GFp_simple_group_copy(dest, src);
 }
 
-int ec_GFp_nist_group_set_curve(EC_GROUP *group, const BIGNUM *p,
-                                const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GFp_nist_group_set_curve(EC_GROUP *group, const BIGNUM *p,
+                                     const BIGNUM *a, const BIGNUM *b,
+                                     BN_CTX *ctx)
 {
     int ret = 0;
     BN_CTX *new_ctx = NULL;
@@ -116,7 +117,7 @@ int ec_GFp_nist_group_set_curve(EC_GROUP *group, const BIGNUM *p,
         goto err;
     }
 
-    ret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
+    ret = ossl_ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
 
  err:
     BN_CTX_end(ctx);
@@ -124,8 +125,8 @@ int ec_GFp_nist_group_set_curve(EC_GROUP *group, const BIGNUM *p,
     return ret;
 }
 
-int ec_GFp_nist_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
-                          const BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GFp_nist_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
+                               const BIGNUM *b, BN_CTX *ctx)
 {
     int ret = 0;
     BN_CTX *ctx_new = NULL;
@@ -149,8 +150,8 @@ int ec_GFp_nist_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
     return ret;
 }
 
-int ec_GFp_nist_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
-                          BN_CTX *ctx)
+int ossl_ec_GFp_nist_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
+                               BN_CTX *ctx)
 {
     int ret = 0;
     BN_CTX *ctx_new = NULL;
diff --git a/crypto/ec/ecp_nistp224.c b/crypto/ec/ecp_nistp224.c
index 40a9582921..aa470efd8d 100644
--- a/crypto/ec/ecp_nistp224.c
+++ b/crypto/ec/ecp_nistp224.c
@@ -248,55 +248,55 @@ const EC_METHOD *EC_GFp_nistp224_method(void)
     static const EC_METHOD ret = {
         EC_FLAGS_DEFAULT_OCT,
         NID_X9_62_prime_field,
-        ec_GFp_nistp224_group_init,
-        ec_GFp_simple_group_finish,
-        ec_GFp_simple_group_clear_finish,
-        ec_GFp_nist_group_copy,
-        ec_GFp_nistp224_group_set_curve,
-        ec_GFp_simple_group_get_curve,
-        ec_GFp_simple_group_get_degree,
-        ec_group_simple_order_bits,
-        ec_GFp_simple_group_check_discriminant,
-        ec_GFp_simple_point_init,
-        ec_GFp_simple_point_finish,
-        ec_GFp_simple_point_clear_finish,
-        ec_GFp_simple_point_copy,
-        ec_GFp_simple_point_set_to_infinity,
-        ec_GFp_simple_point_set_affine_coordinates,
-        ec_GFp_nistp224_point_get_affine_coordinates,
+        ossl_ec_GFp_nistp224_group_init,
+        ossl_ec_GFp_simple_group_finish,
+        ossl_ec_GFp_simple_group_clear_finish,
+        ossl_ec_GFp_nist_group_copy,
+        ossl_ec_GFp_nistp224_group_set_curve,
+        ossl_ec_GFp_simple_group_get_curve,
+        ossl_ec_GFp_simple_group_get_degree,
+        ossl_ec_group_simple_order_bits,
+        ossl_ec_GFp_simple_group_check_discriminant,
+        ossl_ec_GFp_simple_point_init,
+        ossl_ec_GFp_simple_point_finish,
+        ossl_ec_GFp_simple_point_clear_finish,
+        ossl_ec_GFp_simple_point_copy,
+        ossl_ec_GFp_simple_point_set_to_infinity,
+        ossl_ec_GFp_simple_point_set_affine_coordinates,
+        ossl_ec_GFp_nistp224_point_get_affine_coordinates,
         0 /* point_set_compressed_coordinates */ ,
         0 /* point2oct */ ,
         0 /* oct2point */ ,
-        ec_GFp_simple_add,
-        ec_GFp_simple_dbl,
-        ec_GFp_simple_invert,
-        ec_GFp_simple_is_at_infinity,
-        ec_GFp_simple_is_on_curve,
-        ec_GFp_simple_cmp,
-        ec_GFp_simple_make_affine,
-        ec_GFp_simple_points_make_affine,
-        ec_GFp_nistp224_points_mul,
-        ec_GFp_nistp224_precompute_mult,
-        ec_GFp_nistp224_have_precompute_mult,
-        ec_GFp_nist_field_mul,
-        ec_GFp_nist_field_sqr,
+        ossl_ec_GFp_simple_add,
+        ossl_ec_GFp_simple_dbl,
+        ossl_ec_GFp_simple_invert,
+        ossl_ec_GFp_simple_is_at_infinity,
+        ossl_ec_GFp_simple_is_on_curve,
+        ossl_ec_GFp_simple_cmp,
+        ossl_ec_GFp_simple_make_affine,
+        ossl_ec_GFp_simple_points_make_affine,
+        ossl_ec_GFp_nistp224_points_mul,
+        ossl_ec_GFp_nistp224_precompute_mult,
+        ossl_ec_GFp_nistp224_have_precompute_mult,
+        ossl_ec_GFp_nist_field_mul,
+        ossl_ec_GFp_nist_field_sqr,
         0 /* field_div */ ,
-        ec_GFp_simple_field_inv,
+        ossl_ec_GFp_simple_field_inv,
         0 /* field_encode */ ,
         0 /* field_decode */ ,
         0,                      /* field_set_to_one */
-        ec_key_simple_priv2oct,
-        ec_key_simple_oct2priv,
+        ossl_ec_key_simple_priv2oct,
+        ossl_ec_key_simple_oct2priv,
         0, /* set private */
-        ec_key_simple_generate_key,
-        ec_key_simple_check_key,
-        ec_key_simple_generate_public_key,
+        ossl_ec_key_simple_generate_key,
+        ossl_ec_key_simple_check_key,
+        ossl_ec_key_simple_generate_public_key,
         0, /* keycopy */
         0, /* keyfinish */
-        ecdh_simple_compute_key,
-        ecdsa_simple_sign_setup,
-        ecdsa_simple_sign_sig,
-        ecdsa_simple_verify_sig,
+        ossl_ecdh_simple_compute_key,
+        ossl_ecdsa_simple_sign_setup,
+        ossl_ecdsa_simple_sign_sig,
+        ossl_ecdsa_simple_verify_sig,
         0, /* field_inverse_mod_ord */
         0, /* blind_coordinates */
         0, /* ladder_pre */
@@ -1207,7 +1207,7 @@ static void batch_mul(felem x_out, felem y_out, felem z_out,
                 bits |= get_bit(scalars[num], i + 1) &lt;&lt; 2;
                 bits |= get_bit(scalars[num], i) &lt;&lt; 1;
                 bits |= get_bit(scalars[num], i - 1);
-                ec_GFp_nistp_recode_scalar_bits(&amp;sign, &amp;digit, bits);
+                ossl_ec_GFp_nistp_recode_scalar_bits(&amp;sign, &amp;digit, bits);
 
                 /* select the point to add or subtract */
                 select_point(digit, 17, pre_comp[num], tmp);
@@ -1286,17 +1286,17 @@ void EC_nistp224_pre_comp_free(NISTP224_PRE_COMP *p)
  * OPENSSL EC_METHOD FUNCTIONS
  */
 
-int ec_GFp_nistp224_group_init(EC_GROUP *group)
+int ossl_ec_GFp_nistp224_group_init(EC_GROUP *group)
 {
     int ret;
-    ret = ec_GFp_simple_group_init(group);
+    ret = ossl_ec_GFp_simple_group_init(group);
     group-&gt;a_is_minus3 = 1;
     return ret;
 }
 
-int ec_GFp_nistp224_group_set_curve(EC_GROUP *group, const BIGNUM *p,
-                                    const BIGNUM *a, const BIGNUM *b,
-                                    BN_CTX *ctx)
+int ossl_ec_GFp_nistp224_group_set_curve(EC_GROUP *group, const BIGNUM *p,
+                                         const BIGNUM *a, const BIGNUM *b,
+                                         BN_CTX *ctx)
 {
     int ret = 0;
     BIGNUM *curve_p, *curve_a, *curve_b;
@@ -1323,7 +1323,7 @@ int ec_GFp_nistp224_group_set_curve(EC_GROUP *group, const BIGNUM *p,
         goto err;
     }
     group-&gt;field_mod_func = BN_nist_mod_224;
-    ret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
+    ret = ossl_ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
  err:
     BN_CTX_end(ctx);
 #ifndef FIPS_MODULE
@@ -1336,10 +1336,10 @@ int ec_GFp_nistp224_group_set_curve(EC_GROUP *group, const BIGNUM *p,
  * Takes the Jacobian coordinates (X, Y, Z) of a point and returns (X', Y') =
  * (X/Z^2, Y/Z^3)
  */
-int ec_GFp_nistp224_point_get_affine_coordinates(const EC_GROUP *group,
-                                                 const EC_POINT *point,
-                                                 BIGNUM *x, BIGNUM *y,
-                                                 BN_CTX *ctx)
+int ossl_ec_GFp_nistp224_point_get_affine_coordinates(const EC_GROUP *group,
+                                                      const EC_POINT *point,
+                                                      BIGNUM *x, BIGNUM *y,
+                                                      BN_CTX *ctx)
 {
     felem z1, z2, x_in, y_in, x_out, y_out;
     widefelem tmp;
@@ -1384,36 +1384,36 @@ static void make_points_affine(size_t num, felem points[ /* num */ ][3],
      * Runs in constant time, unless an input is the point at infinity (which
      * normally shouldn't happen).
      */
-    ec_GFp_nistp_points_make_affine_internal(num,
-                                             points,
-                                             sizeof(felem),
-                                             tmp_felems,
-                                             (void (*)(void *))felem_one,
-                                             felem_is_zero_int,
-                                             (void (*)(void *, const void *))
-                                             felem_assign,
-                                             (void (*)(void *, const void *))
-                                             felem_square_reduce, (void (*)
-                                                                   (void *,
-                                                                    const void
-                                                                    *,
-                                                                    const void
-                                                                    *))
-                                             felem_mul_reduce,
-                                             (void (*)(void *, const void *))
-                                             felem_inv,
-                                             (void (*)(void *, const void *))
-                                             felem_contract);
+    ossl_ec_GFp_nistp_points_make_affine_internal(num,
+                                                  points,
+                                                  sizeof(felem),
+                                                  tmp_felems,
+                                                  (void (*)(void *))felem_one,
+                                                  felem_is_zero_int,
+                                                  (void (*)(void *, const void *))
+                                                  felem_assign,
+                                                  (void (*)(void *, const void *))
+                                                  felem_square_reduce, (void (*)
+                                                                        (void *,
+                                                                         const void
+                                                                         *,
+                                                                         const void
+                                                                         *))
+                                                  felem_mul_reduce,
+                                                  (void (*)(void *, const void *))
+                                                  felem_inv,
+                                                  (void (*)(void *, const void *))
+                                                  felem_contract);
 }
 
 /*
  * Computes scalar*generator + \sum scalars[i]*points[i], ignoring NULL
  * values Result is stored in r (r can equal one of the inputs).
  */
-int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
-                               const BIGNUM *scalar, size_t num,
-                               const EC_POINT *points[],
-                               const BIGNUM *scalars[], BN_CTX *ctx)
+int ossl_ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
+                                    const BIGNUM *scalar, size_t num,
+                                    const EC_POINT *points[],
+                                    const BIGNUM *scalars[], BN_CTX *ctx)
 {
     int ret = 0;
     int j;
@@ -1460,8 +1460,9 @@ int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
             ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
-        if (!ec_GFp_simple_set_Jprojective_coordinates_GFp(group, generator, x,
-                                                           y, z, ctx))
+        if (!ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp(group,
+                                                                generator,
+                                                                x, y, z, ctx))
             goto err;
         if (0 == EC_POINT_cmp(group, generator, group-&gt;generator, ctx))
             /* precomputation matches generator */
@@ -1595,7 +1596,8 @@ int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
         ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
-    ret = ec_GFp_simple_set_Jprojective_coordinates_GFp(group, r, x, y, z, ctx);
+    ret = ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp(group, r, x, y, z,
+                                                             ctx);
 
  err:
     BN_CTX_end(ctx);
@@ -1606,7 +1608,7 @@ int ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,
     return ret;
 }
 
-int ec_GFp_nistp224_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
+int ossl_ec_GFp_nistp224_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
 {
     int ret = 0;
     NISTP224_PRE_COMP *pre = NULL;
@@ -1742,7 +1744,7 @@ int ec_GFp_nistp224_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
     return ret;
 }
 
-int ec_GFp_nistp224_have_precompute_mult(const EC_GROUP *group)
+int ossl_ec_GFp_nistp224_have_precompute_mult(const EC_GROUP *group)
 {
     return HAVEPRECOMP(group, nistp224);
 }
diff --git a/crypto/ec/ecp_nistp256.c b/crypto/ec/ecp_nistp256.c
index f81481f0d3..7fed6ccf57 100644
--- a/crypto/ec/ecp_nistp256.c
+++ b/crypto/ec/ecp_nistp256.c
@@ -1743,7 +1743,7 @@ static void batch_mul(felem x_out, felem y_out, felem z_out,
                 bits |= get_bit(scalars[num], i + 1) &lt;&lt; 2;
                 bits |= get_bit(scalars[num], i) &lt;&lt; 1;
                 bits |= get_bit(scalars[num], i - 1);
-                ec_GFp_nistp_recode_scalar_bits(&amp;sign, &amp;digit, bits);
+                ossl_ec_GFp_nistp_recode_scalar_bits(&amp;sign, &amp;digit, bits);
 
                 /*
                  * select the point to add or subtract, in constant time
@@ -1784,55 +1784,55 @@ const EC_METHOD *EC_GFp_nistp256_method(void)
     static const EC_METHOD ret = {
         EC_FLAGS_DEFAULT_OCT,
         NID_X9_62_prime_field,
-        ec_GFp_nistp256_group_init,
-        ec_GFp_simple_group_finish,
-        ec_GFp_simple_group_clear_finish,
-        ec_GFp_nist_group_copy,
-        ec_GFp_nistp256_group_set_curve,
-        ec_GFp_simple_group_get_curve,
-        ec_GFp_simple_group_get_degree,
-        ec_group_simple_order_bits,
-        ec_GFp_simple_group_check_discriminant,
-        ec_GFp_simple_point_init,
-        ec_GFp_simple_point_finish,
-        ec_GFp_simple_point_clear_finish,
-        ec_GFp_simple_point_copy,
-        ec_GFp_simple_point_set_to_infinity,
-        ec_GFp_simple_point_set_affine_coordinates,
-        ec_GFp_nistp256_point_get_affine_coordinates,
+        ossl_ec_GFp_nistp256_group_init,
+        ossl_ec_GFp_simple_group_finish,
+        ossl_ec_GFp_simple_group_clear_finish,
+        ossl_ec_GFp_nist_group_copy,
+        ossl_ec_GFp_nistp256_group_set_curve,
+        ossl_ec_GFp_simple_group_get_curve,
+        ossl_ec_GFp_simple_group_get_degree,
+        ossl_ec_group_simple_order_bits,
+        ossl_ec_GFp_simple_group_check_discriminant,
+        ossl_ec_GFp_simple_point_init,
+        ossl_ec_GFp_simple_point_finish,
+        ossl_ec_GFp_simple_point_clear_finish,
+        ossl_ec_GFp_simple_point_copy,
+        ossl_ec_GFp_simple_point_set_to_infinity,
+        ossl_ec_GFp_simple_point_set_affine_coordinates,
+        ossl_ec_GFp_nistp256_point_get_affine_coordinates,
         0 /* point_set_compressed_coordinates */ ,
         0 /* point2oct */ ,
         0 /* oct2point */ ,
-        ec_GFp_simple_add,
-        ec_GFp_simple_dbl,
-        ec_GFp_simple_invert,
-        ec_GFp_simple_is_at_infinity,
-        ec_GFp_simple_is_on_curve,
-        ec_GFp_simple_cmp,
-        ec_GFp_simple_make_affine,
-        ec_GFp_simple_points_make_affine,
-        ec_GFp_nistp256_points_mul,
-        ec_GFp_nistp256_precompute_mult,
-        ec_GFp_nistp256_have_precompute_mult,
-        ec_GFp_nist_field_mul,
-        ec_GFp_nist_field_sqr,
+        ossl_ec_GFp_simple_add,
+        ossl_ec_GFp_simple_dbl,
+        ossl_ec_GFp_simple_invert,
+        ossl_ec_GFp_simple_is_at_infinity,
+        ossl_ec_GFp_simple_is_on_curve,
+        ossl_ec_GFp_simple_cmp,
+        ossl_ec_GFp_simple_make_affine,
+        ossl_ec_GFp_simple_points_make_affine,
+        ossl_ec_GFp_nistp256_points_mul,
+        ossl_ec_GFp_nistp256_precompute_mult,
+        ossl_ec_GFp_nistp256_have_precompute_mult,
+        ossl_ec_GFp_nist_field_mul,
+        ossl_ec_GFp_nist_field_sqr,
         0 /* field_div */ ,
-        ec_GFp_simple_field_inv,
+        ossl_ec_GFp_simple_field_inv,
         0 /* field_encode */ ,
         0 /* field_decode */ ,
         0,                      /* field_set_to_one */
-        ec_key_simple_priv2oct,
-        ec_key_simple_oct2priv,
+        ossl_ec_key_simple_priv2oct,
+        ossl_ec_key_simple_oct2priv,
         0, /* set private */
-        ec_key_simple_generate_key,
-        ec_key_simple_check_key,
-        ec_key_simple_generate_public_key,
+        ossl_ec_key_simple_generate_key,
+        ossl_ec_key_simple_check_key,
+        ossl_ec_key_simple_generate_public_key,
         0, /* keycopy */
         0, /* keyfinish */
-        ecdh_simple_compute_key,
-        ecdsa_simple_sign_setup,
-        ecdsa_simple_sign_sig,
-        ecdsa_simple_verify_sig,
+        ossl_ecdh_simple_compute_key,
+        ossl_ecdsa_simple_sign_setup,
+        ossl_ecdsa_simple_sign_sig,
+        ossl_ecdsa_simple_verify_sig,
         0, /* field_inverse_mod_ord */
         0, /* blind_coordinates */
         0, /* ladder_pre */
@@ -1898,17 +1898,17 @@ void EC_nistp256_pre_comp_free(NISTP256_PRE_COMP *pre)
  * OPENSSL EC_METHOD FUNCTIONS
  */
 
-int ec_GFp_nistp256_group_init(EC_GROUP *group)
+int ossl_ec_GFp_nistp256_group_init(EC_GROUP *group)
 {
     int ret;
-    ret = ec_GFp_simple_group_init(group);
+    ret = ossl_ec_GFp_simple_group_init(group);
     group-&gt;a_is_minus3 = 1;
     return ret;
 }
 
-int ec_GFp_nistp256_group_set_curve(EC_GROUP *group, const BIGNUM *p,
-                                    const BIGNUM *a, const BIGNUM *b,
-                                    BN_CTX *ctx)
+int ossl_ec_GFp_nistp256_group_set_curve(EC_GROUP *group, const BIGNUM *p,
+                                         const BIGNUM *a, const BIGNUM *b,
+                                         BN_CTX *ctx)
 {
     int ret = 0;
     BIGNUM *curve_p, *curve_a, *curve_b;
@@ -1935,7 +1935,7 @@ int ec_GFp_nistp256_group_set_curve(EC_GROUP *group, const BIGNUM *p,
         goto err;
     }
     group-&gt;field_mod_func = BN_nist_mod_256;
-    ret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
+    ret = ossl_ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
  err:
     BN_CTX_end(ctx);
 #ifndef FIPS_MODULE
@@ -1948,10 +1948,10 @@ int ec_GFp_nistp256_group_set_curve(EC_GROUP *group, const BIGNUM *p,
  * Takes the Jacobian coordinates (X, Y, Z) of a point and returns (X', Y') =
  * (X/Z^2, Y/Z^3)
  */
-int ec_GFp_nistp256_point_get_affine_coordinates(const EC_GROUP *group,
-                                                 const EC_POINT *point,
-                                                 BIGNUM *x, BIGNUM *y,
-                                                 BN_CTX *ctx)
+int ossl_ec_GFp_nistp256_point_get_affine_coordinates(const EC_GROUP *group,
+                                                      const EC_POINT *point,
+                                                      BIGNUM *x, BIGNUM *y,
+                                                      BN_CTX *ctx)
 {
     felem z1, z2, x_in, y_in;
     smallfelem x_out, y_out;
@@ -1998,35 +1998,35 @@ static void make_points_affine(size_t num, smallfelem points[][3],
      * Runs in constant time, unless an input is the point at infinity (which
      * normally shouldn't happen).
      */
-    ec_GFp_nistp_points_make_affine_internal(num,
-                                             points,
-                                             sizeof(smallfelem),
-                                             tmp_smallfelems,
-                                             (void (*)(void *))smallfelem_one,
-                                             smallfelem_is_zero_int,
-                                             (void (*)(void *, const void *))
-                                             smallfelem_assign,
-                                             (void (*)(void *, const void *))
-                                             smallfelem_square_contract,
-                                             (void (*)
-                                              (void *, const void *,
-                                               const void *))
-                                             smallfelem_mul_contract,
-                                             (void (*)(void *, const void *))
-                                             smallfelem_inv_contract,
-                                             /* nothing to contract */
-                                             (void (*)(void *, const void *))
-                                             smallfelem_assign);
+    ossl_ec_GFp_nistp_points_make_affine_internal(num,
+                                                  points,
+                                                  sizeof(smallfelem),
+                                                  tmp_smallfelems,
+                                                  (void (*)(void *))smallfelem_one,
+                                                  smallfelem_is_zero_int,
+                                                  (void (*)(void *, const void *))
+                                                  smallfelem_assign,
+                                                  (void (*)(void *, const void *))
+                                                  smallfelem_square_contract,
+                                                  (void (*)
+                                                   (void *, const void *,
+                                                    const void *))
+                                                  smallfelem_mul_contract,
+                                                  (void (*)(void *, const void *))
+                                                  smallfelem_inv_contract,
+                                                  /* nothing to contract */
+                                                  (void (*)(void *, const void *))
+                                                  smallfelem_assign);
 }
 
 /*
  * Computes scalar*generator + \sum scalars[i]*points[i], ignoring NULL
  * values Result is stored in r (r can equal one of the inputs).
  */
-int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
-                               const BIGNUM *scalar, size_t num,
-                               const EC_POINT *points[],
-                               const BIGNUM *scalars[], BN_CTX *ctx)
+int ossl_ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
+                                    const BIGNUM *scalar, size_t num,
+                                    const EC_POINT *points[],
+                                    const BIGNUM *scalars[], BN_CTX *ctx)
 {
     int ret = 0;
     int j;
@@ -2074,8 +2074,9 @@ int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
             ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
-        if (!ec_GFp_simple_set_Jprojective_coordinates_GFp(group, generator, x,
-                                                           y, z, ctx))
+        if (!ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp(group,
+                                                                generator,
+                                                                x, y, z, ctx))
             goto err;
         if (0 == EC_POINT_cmp(group, generator, group-&gt;generator, ctx))
             /* precomputation matches generator */
@@ -2215,7 +2216,8 @@ int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
         ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
-    ret = ec_GFp_simple_set_Jprojective_coordinates_GFp(group, r, x, y, z, ctx);
+    ret = ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp(group, r, x, y, z,
+                                                             ctx);
 
  err:
     BN_CTX_end(ctx);
@@ -2226,7 +2228,7 @@ int ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,
     return ret;
 }
 
-int ec_GFp_nistp256_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
+int ossl_ec_GFp_nistp256_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
 {
     int ret = 0;
     NISTP256_PRE_COMP *pre = NULL;
@@ -2373,7 +2375,7 @@ int ec_GFp_nistp256_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
     return ret;
 }
 
-int ec_GFp_nistp256_have_precompute_mult(const EC_GROUP *group)
+int ossl_ec_GFp_nistp256_have_precompute_mult(const EC_GROUP *group)
 {
     return HAVEPRECOMP(group, nistp256);
 }
diff --git a/crypto/ec/ecp_nistp521.c b/crypto/ec/ecp_nistp521.c
index dc9312b957..5c64477e97 100644
--- a/crypto/ec/ecp_nistp521.c
+++ b/crypto/ec/ecp_nistp521.c
@@ -1269,8 +1269,8 @@ static void point_add(felem x3, felem y3, felem z3,
          * This is obviously not constant-time but it will almost-never happen
          * for ECDH / ECDSA. The case where it can happen is during scalar-mult
          * where the intermediate value gets very close to the group order.
-         * Since |ec_GFp_nistp_recode_scalar_bits| produces signed digits for
-         * the scalar, it's possible for the intermediate value to be a small
+         * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits
+         * for the scalar, it's possible for the intermediate value to be a small
          * negative multiple of the base point, and for the final signed digit
          * to be the same value. We believe that this only occurs for the scalar
          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
@@ -1587,7 +1587,7 @@ static void batch_mul(felem x_out, felem y_out, felem z_out,
                 bits |= get_bit(scalars[num], i + 1) &lt;&lt; 2;
                 bits |= get_bit(scalars[num], i) &lt;&lt; 1;
                 bits |= get_bit(scalars[num], i - 1);
-                ec_GFp_nistp_recode_scalar_bits(&amp;sign, &amp;digit, bits);
+                ossl_ec_GFp_nistp_recode_scalar_bits(&amp;sign, &amp;digit, bits);
 
                 /*
                  * select the point to add or subtract, in constant time
@@ -1625,55 +1625,55 @@ const EC_METHOD *EC_GFp_nistp521_method(void)
     static const EC_METHOD ret = {
         EC_FLAGS_DEFAULT_OCT,
         NID_X9_62_prime_field,
-        ec_GFp_nistp521_group_init,
-        ec_GFp_simple_group_finish,
-        ec_GFp_simple_group_clear_finish,
-        ec_GFp_nist_group_copy,
-        ec_GFp_nistp521_group_set_curve,
-        ec_GFp_simple_group_get_curve,
-        ec_GFp_simple_group_get_degree,
-        ec_group_simple_order_bits,
-        ec_GFp_simple_group_check_discriminant,
-        ec_GFp_simple_point_init,
-        ec_GFp_simple_point_finish,
-        ec_GFp_simple_point_clear_finish,
-        ec_GFp_simple_point_copy,
-        ec_GFp_simple_point_set_to_infinity,
-        ec_GFp_simple_point_set_affine_coordinates,
-        ec_GFp_nistp521_point_get_affine_coordinates,
+        ossl_ec_GFp_nistp521_group_init,
+        ossl_ec_GFp_simple_group_finish,
+        ossl_ec_GFp_simple_group_clear_finish,
+        ossl_ec_GFp_nist_group_copy,
+        ossl_ec_GFp_nistp521_group_set_curve,
+        ossl_ec_GFp_simple_group_get_curve,
+        ossl_ec_GFp_simple_group_get_degree,
+        ossl_ec_group_simple_order_bits,
+        ossl_ec_GFp_simple_group_check_discriminant,
+        ossl_ec_GFp_simple_point_init,
+        ossl_ec_GFp_simple_point_finish,
+        ossl_ec_GFp_simple_point_clear_finish,
+        ossl_ec_GFp_simple_point_copy,
+        ossl_ec_GFp_simple_point_set_to_infinity,
+        ossl_ec_GFp_simple_point_set_affine_coordinates,
+        ossl_ec_GFp_nistp521_point_get_affine_coordinates,
         0 /* point_set_compressed_coordinates */ ,
         0 /* point2oct */ ,
         0 /* oct2point */ ,
-        ec_GFp_simple_add,
-        ec_GFp_simple_dbl,
-        ec_GFp_simple_invert,
-        ec_GFp_simple_is_at_infinity,
-        ec_GFp_simple_is_on_curve,
-        ec_GFp_simple_cmp,
-        ec_GFp_simple_make_affine,
-        ec_GFp_simple_points_make_affine,
-        ec_GFp_nistp521_points_mul,
-        ec_GFp_nistp521_precompute_mult,
-        ec_GFp_nistp521_have_precompute_mult,
-        ec_GFp_nist_field_mul,
-        ec_GFp_nist_field_sqr,
+        ossl_ec_GFp_simple_add,
+        ossl_ec_GFp_simple_dbl,
+        ossl_ec_GFp_simple_invert,
+        ossl_ec_GFp_simple_is_at_infinity,
+        ossl_ec_GFp_simple_is_on_curve,
+        ossl_ec_GFp_simple_cmp,
+        ossl_ec_GFp_simple_make_affine,
+        ossl_ec_GFp_simple_points_make_affine,
+        ossl_ec_GFp_nistp521_points_mul,
+        ossl_ec_GFp_nistp521_precompute_mult,
+        ossl_ec_GFp_nistp521_have_precompute_mult,
+        ossl_ec_GFp_nist_field_mul,
+        ossl_ec_GFp_nist_field_sqr,
         0 /* field_div */ ,
-        ec_GFp_simple_field_inv,
+        ossl_ec_GFp_simple_field_inv,
         0 /* field_encode */ ,
         0 /* field_decode */ ,
         0,                      /* field_set_to_one */
-        ec_key_simple_priv2oct,
-        ec_key_simple_oct2priv,
+        ossl_ec_key_simple_priv2oct,
+        ossl_ec_key_simple_oct2priv,
         0, /* set private */
-        ec_key_simple_generate_key,
-        ec_key_simple_check_key,
-        ec_key_simple_generate_public_key,
+        ossl_ec_key_simple_generate_key,
+        ossl_ec_key_simple_check_key,
+        ossl_ec_key_simple_generate_public_key,
         0, /* keycopy */
         0, /* keyfinish */
-        ecdh_simple_compute_key,
-        ecdsa_simple_sign_setup,
-        ecdsa_simple_sign_sig,
-        ecdsa_simple_verify_sig,
+        ossl_ecdh_simple_compute_key,
+        ossl_ecdsa_simple_sign_setup,
+        ossl_ecdsa_simple_sign_sig,
+        ossl_ecdsa_simple_verify_sig,
         0, /* field_inverse_mod_ord */
         0, /* blind_coordinates */
         0, /* ladder_pre */
@@ -1739,17 +1739,17 @@ void EC_nistp521_pre_comp_free(NISTP521_PRE_COMP *p)
  * OPENSSL EC_METHOD FUNCTIONS
  */
 
-int ec_GFp_nistp521_group_init(EC_GROUP *group)
+int ossl_ec_GFp_nistp521_group_init(EC_GROUP *group)
 {
     int ret;
-    ret = ec_GFp_simple_group_init(group);
+    ret = ossl_ec_GFp_simple_group_init(group);
     group-&gt;a_is_minus3 = 1;
     return ret;
 }
 
-int ec_GFp_nistp521_group_set_curve(EC_GROUP *group, const BIGNUM *p,
-                                    const BIGNUM *a, const BIGNUM *b,
-                                    BN_CTX *ctx)
+int ossl_ec_GFp_nistp521_group_set_curve(EC_GROUP *group, const BIGNUM *p,
+                                         const BIGNUM *a, const BIGNUM *b,
+                                         BN_CTX *ctx)
 {
     int ret = 0;
     BIGNUM *curve_p, *curve_a, *curve_b;
@@ -1776,7 +1776,7 @@ int ec_GFp_nistp521_group_set_curve(EC_GROUP *group, const BIGNUM *p,
         goto err;
     }
     group-&gt;field_mod_func = BN_nist_mod_521;
-    ret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
+    ret = ossl_ec_GFp_simple_group_set_curve(group, p, a, b, ctx);
  err:
     BN_CTX_end(ctx);
 #ifndef FIPS_MODULE
@@ -1789,10 +1789,10 @@ int ec_GFp_nistp521_group_set_curve(EC_GROUP *group, const BIGNUM *p,
  * Takes the Jacobian coordinates (X, Y, Z) of a point and returns (X', Y') =
  * (X/Z^2, Y/Z^3)
  */
-int ec_GFp_nistp521_point_get_affine_coordinates(const EC_GROUP *group,
-                                                 const EC_POINT *point,
-                                                 BIGNUM *x, BIGNUM *y,
-                                                 BN_CTX *ctx)
+int ossl_ec_GFp_nistp521_point_get_affine_coordinates(const EC_GROUP *group,
+                                                      const EC_POINT *point,
+                                                      BIGNUM *x, BIGNUM *y,
+                                                      BN_CTX *ctx)
 {
     felem z1, z2, x_in, y_in, x_out, y_out;
     largefelem tmp;
@@ -1838,36 +1838,36 @@ static void make_points_affine(size_t num, felem points[][3],
      * Runs in constant time, unless an input is the point at infinity (which
      * normally shouldn't happen).
      */
-    ec_GFp_nistp_points_make_affine_internal(num,
-                                             points,
-                                             sizeof(felem),
-                                             tmp_felems,
-                                             (void (*)(void *))felem_one,
-                                             felem_is_zero_int,
-                                             (void (*)(void *, const void *))
-                                             felem_assign,
-                                             (void (*)(void *, const void *))
-                                             felem_square_reduce, (void (*)
-                                                                   (void *,
-                                                                    const void
-                                                                    *,
-                                                                    const void
-                                                                    *))
-                                             felem_mul_reduce,
-                                             (void (*)(void *, const void *))
-                                             felem_inv,
-                                             (void (*)(void *, const void *))
-                                             felem_contract);
+    ossl_ec_GFp_nistp_points_make_affine_internal(num,
+                                                  points,
+                                                  sizeof(felem),
+                                                  tmp_felems,
+                                                  (void (*)(void *))felem_one,
+                                                  felem_is_zero_int,
+                                                  (void (*)(void *, const void *))
+                                                  felem_assign,
+                                                  (void (*)(void *, const void *))
+                                                  felem_square_reduce, (void (*)
+                                                                        (void *,
+                                                                         const void
+                                                                         *,
+                                                                         const void
+                                                                         *))
+                                                  felem_mul_reduce,
+                                                  (void (*)(void *, const void *))
+                                                  felem_inv,
+                                                  (void (*)(void *, const void *))
+                                                  felem_contract);
 }
 
 /*
  * Computes scalar*generator + \sum scalars[i]*points[i], ignoring NULL
  * values Result is stored in r (r can equal one of the inputs).
  */
-int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
-                               const BIGNUM *scalar, size_t num,
-                               const EC_POINT *points[],
-                               const BIGNUM *scalars[], BN_CTX *ctx)
+int ossl_ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
+                                    const BIGNUM *scalar, size_t num,
+                                    const EC_POINT *points[],
+                                    const BIGNUM *scalars[], BN_CTX *ctx)
 {
     int ret = 0;
     int j;
@@ -1914,8 +1914,9 @@ int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
             ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto err;
         }
-        if (!ec_GFp_simple_set_Jprojective_coordinates_GFp(group, generator, x,
-                                                           y, z, ctx))
+        if (!ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp(group,
+                                                                generator,
+                                                                x, y, z, ctx))
             goto err;
         if (0 == EC_POINT_cmp(group, generator, group-&gt;generator, ctx))
             /* precomputation matches generator */
@@ -2053,7 +2054,8 @@ int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
         ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         goto err;
     }
-    ret = ec_GFp_simple_set_Jprojective_coordinates_GFp(group, r, x, y, z, ctx);
+    ret = ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp(group, r, x, y, z,
+                                                             ctx);
 
  err:
     BN_CTX_end(ctx);
@@ -2064,7 +2066,7 @@ int ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,
     return ret;
 }
 
-int ec_GFp_nistp521_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
+int ossl_ec_GFp_nistp521_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
 {
     int ret = 0;
     NISTP521_PRE_COMP *pre = NULL;
@@ -2180,7 +2182,7 @@ int ec_GFp_nistp521_precompute_mult(EC_GROUP *group, BN_CTX *ctx)
     return ret;
 }
 
-int ec_GFp_nistp521_have_precompute_mult(const EC_GROUP *group)
+int ossl_ec_GFp_nistp521_have_precompute_mult(const EC_GROUP *group)
 {
     return HAVEPRECOMP(group, nistp521);
 }
diff --git a/crypto/ec/ecp_nistputil.c b/crypto/ec/ecp_nistputil.c
index 814a3083c3..2c3dc26f6e 100644
--- a/crypto/ec/ecp_nistputil.c
+++ b/crypto/ec/ecp_nistputil.c
@@ -49,7 +49,8 @@
  * of size 'felem_size'. tmp_felems needs to point to a temporary array of
  * 'num'+1 field elements for storage of intermediate values.
  */
-void ec_GFp_nistp_points_make_affine_internal(size_t num, void *point_array,
+void
+ossl_ec_GFp_nistp_points_make_affine_internal(size_t num, void *point_array,
                                               size_t felem_size,
                                               void *tmp_felems,
                                               void (*felem_one) (void *out),
@@ -209,8 +210,8 @@ void ec_GFp_nistp_points_make_affine_internal(size_t num, void *point_array,
  * b_-1, has to be b_4 b_3 b_2 b_1 b_0 0.
  *
  */
-void ec_GFp_nistp_recode_scalar_bits(unsigned char *sign,
-                                     unsigned char *digit, unsigned char in)
+void ossl_ec_GFp_nistp_recode_scalar_bits(unsigned char *sign,
+                                          unsigned char *digit, unsigned char in)
 {
     unsigned char s, d;
 
diff --git a/crypto/ec/ecp_nistz256.c b/crypto/ec/ecp_nistz256.c
index 64970d53bf..f348f97da1 100644
--- a/crypto/ec/ecp_nistz256.c
+++ b/crypto/ec/ecp_nistz256.c
@@ -1471,53 +1471,53 @@ const EC_METHOD *EC_GFp_nistz256_method(void)
     static const EC_METHOD ret = {
         EC_FLAGS_DEFAULT_OCT,
         NID_X9_62_prime_field,
-        ec_GFp_mont_group_init,
-        ec_GFp_mont_group_finish,
-        ec_GFp_mont_group_clear_finish,
-        ec_GFp_mont_group_copy,
-        ec_GFp_mont_group_set_curve,
-        ec_GFp_simple_group_get_curve,
-        ec_GFp_simple_group_get_degree,
-        ec_group_simple_order_bits,
-        ec_GFp_simple_group_check_discriminant,
-        ec_GFp_simple_point_init,
-        ec_GFp_simple_point_finish,
-        ec_GFp_simple_point_clear_finish,
-        ec_GFp_simple_point_copy,
-        ec_GFp_simple_point_set_to_infinity,
-        ec_GFp_simple_point_set_affine_coordinates,
+        ossl_ec_GFp_mont_group_init,
+        ossl_ec_GFp_mont_group_finish,
+        ossl_ec_GFp_mont_group_clear_finish,
+        ossl_ec_GFp_mont_group_copy,
+        ossl_ec_GFp_mont_group_set_curve,
+        ossl_ec_GFp_simple_group_get_curve,
+        ossl_ec_GFp_simple_group_get_degree,
+        ossl_ec_group_simple_order_bits,
+        ossl_ec_GFp_simple_group_check_discriminant,
+        ossl_ec_GFp_simple_point_init,
+        ossl_ec_GFp_simple_point_finish,
+        ossl_ec_GFp_simple_point_clear_finish,
+        ossl_ec_GFp_simple_point_copy,
+        ossl_ec_GFp_simple_point_set_to_infinity,
+        ossl_ec_GFp_simple_point_set_affine_coordinates,
         ecp_nistz256_get_affine,
         0, 0, 0,
-        ec_GFp_simple_add,
-        ec_GFp_simple_dbl,
-        ec_GFp_simple_invert,
-        ec_GFp_simple_is_at_infinity,
-        ec_GFp_simple_is_on_curve,
-        ec_GFp_simple_cmp,
-        ec_GFp_simple_make_affine,
-        ec_GFp_simple_points_make_affine,
+        ossl_ec_GFp_simple_add,
+        ossl_ec_GFp_simple_dbl,
+        ossl_ec_GFp_simple_invert,
+        ossl_ec_GFp_simple_is_at_infinity,
+        ossl_ec_GFp_simple_is_on_curve,
+        ossl_ec_GFp_simple_cmp,
+        ossl_ec_GFp_simple_make_affine,
+        ossl_ec_GFp_simple_points_make_affine,
         ecp_nistz256_points_mul,                    /* mul */
         ecp_nistz256_mult_precompute,               /* precompute_mult */
         ecp_nistz256_window_have_precompute_mult,   /* have_precompute_mult */
-        ec_GFp_mont_field_mul,
-        ec_GFp_mont_field_sqr,
+        ossl_ec_GFp_mont_field_mul,
+        ossl_ec_GFp_mont_field_sqr,
         0,                                          /* field_div */
-        ec_GFp_mont_field_inv,
-        ec_GFp_mont_field_encode,
-        ec_GFp_mont_field_decode,
-        ec_GFp_mont_field_set_to_one,
-        ec_key_simple_priv2oct,
-        ec_key_simple_oct2priv,
+        ossl_ec_GFp_mont_field_inv,
+        ossl_ec_GFp_mont_field_encode,
+        ossl_ec_GFp_mont_field_decode,
+        ossl_ec_GFp_mont_field_set_to_one,
+        ossl_ec_key_simple_priv2oct,
+        ossl_ec_key_simple_oct2priv,
         0, /* set private */
-        ec_key_simple_generate_key,
-        ec_key_simple_check_key,
-        ec_key_simple_generate_public_key,
+        ossl_ec_key_simple_generate_key,
+        ossl_ec_key_simple_check_key,
+        ossl_ec_key_simple_generate_public_key,
         0, /* keycopy */
         0, /* keyfinish */
-        ecdh_simple_compute_key,
-        ecdsa_simple_sign_setup,
-        ecdsa_simple_sign_sig,
-        ecdsa_simple_verify_sig,
+        ossl_ecdh_simple_compute_key,
+        ossl_ecdsa_simple_sign_setup,
+        ossl_ecdsa_simple_sign_sig,
+        ossl_ecdsa_simple_verify_sig,
         ecp_nistz256_inv_mod_ord,                   /* can be #define-d NULL */
         0,                                          /* blind_coordinates */
         0,                                          /* ladder_pre */
diff --git a/crypto/ec/ecp_oct.c b/crypto/ec/ecp_oct.c
index b1c8e3ed8a..a8408b029b 100644
--- a/crypto/ec/ecp_oct.c
+++ b/crypto/ec/ecp_oct.c
@@ -19,10 +19,10 @@
 
 #include &quot;ec_local.h&quot;
 
-int ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *group,
-                                             EC_POINT *point,
-                                             const BIGNUM *x_, int y_bit,
-                                             BN_CTX *ctx)
+int ossl_ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *group,
+                                                  EC_POINT *point,
+                                                  const BIGNUM *x_, int y_bit,
+                                                  BN_CTX *ctx)
 {
     BN_CTX *new_ctx = NULL;
     BIGNUM *tmp1, *tmp2, *x, *y;
@@ -158,9 +158,9 @@ int ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *group,
     return ret;
 }
 
-size_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
-                               point_conversion_form_t form,
-                               unsigned char *buf, size_t len, BN_CTX *ctx)
+size_t ossl_ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
+                                    point_conversion_form_t form,
+                                    unsigned char *buf, size_t len, BN_CTX *ctx)
 {
     size_t ret;
     BN_CTX *new_ctx = NULL;
@@ -273,8 +273,9 @@ size_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,
     return 0;
 }
 
-int ec_GFp_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
-                            const unsigned char *buf, size_t len, BN_CTX *ctx)
+int ossl_ec_GFp_simple_oct2point(const EC_GROUP *group, EC_POINT *point,
+                                 const unsigned char *buf, size_t len,
+                                 BN_CTX *ctx)
 {
     point_conversion_form_t form;
     int y_bit;
diff --git a/crypto/ec/ecp_s390x_nistp.c b/crypto/ec/ecp_s390x_nistp.c
index c4b490e3be..ddaee93975 100644
--- a/crypto/ec/ecp_s390x_nistp.c
+++ b/crypto/ec/ecp_s390x_nistp.c
@@ -115,7 +115,7 @@ static int ec_GFp_s390x_nistp_mul(const EC_GROUP *group, EC_POINT *r,
 ret:
     /* Otherwise use default. */
     if (rc == -1)
-        rc = ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);
+        rc = ossl_ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);
     OPENSSL_cleanse(param + S390X_OFF_SCALAR(len), len);
     BN_CTX_end(ctx);
     BN_CTX_free(new_ctx);
@@ -186,7 +186,7 @@ static ECDSA_SIG *ecdsa_s390x_nistp_sign_sig(const unsigned char *dgst,
          }
     } else {
         /* Reconstruct k = (k^-1)^-1. */
-        if (ec_group_do_inverse_ord(group, k, kinv, NULL) == 0
+        if (ossl_ec_group_do_inverse_ord(group, k, kinv, NULL) == 0
             || BN_bn2binpad(k, param + S390X_OFF_RN(len), len) == -1) {
             ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
             goto ret;
@@ -321,60 +321,60 @@ const EC_METHOD *EC_GFp_s390x_nistp##bits##_method(void)                \
     static const EC_METHOD EC_GFp_s390x_nistp##bits##_meth = {          \
         EC_FLAGS_DEFAULT_OCT,                                           \
         NID_X9_62_prime_field,                                          \
-        ec_GFp_simple_group_init,                                       \
-        ec_GFp_simple_group_finish,                                     \
-        ec_GFp_simple_group_clear_finish,                               \
-        ec_GFp_simple_group_copy,                                       \
-        ec_GFp_simple_group_set_curve,                                  \
-        ec_GFp_simple_group_get_curve,                                  \
-        ec_GFp_simple_group_get_degree,                                 \
-        ec_group_simple_order_bits,                                     \
-        ec_GFp_simple_group_check_discriminant,                         \
-        ec_GFp_simple_point_init,                                       \
-        ec_GFp_simple_point_finish,                                     \
-        ec_GFp_simple_point_clear_finish,                               \
-        ec_GFp_simple_point_copy,                                       \
-        ec_GFp_simple_point_set_to_infinity,                            \
-        ec_GFp_simple_point_set_affine_coordinates,                     \
-        ec_GFp_simple_point_get_affine_coordinates,                     \
+        ossl_ec_GFp_simple_group_init,                                  \
+        ossl_ec_GFp_simple_group_finish,                                \
+        ossl_ec_GFp_simple_group_clear_finish,                          \
+        ossl_ec_GFp_simple_group_copy,                                  \
+        ossl_ec_GFp_simple_group_set_curve,                             \
+        ossl_ec_GFp_simple_group_get_curve,                             \
+        ossl_ec_GFp_simple_group_get_degree,                            \
+        ossl_ec_group_simple_order_bits,                                \
+        ossl_ec_GFp_simple_group_check_discriminant,                    \
+        ossl_ec_GFp_simple_point_init,                                  \
+        ossl_ec_GFp_simple_point_finish,                                \
+        ossl_ec_GFp_simple_point_clear_finish,                          \
+        ossl_ec_GFp_simple_point_copy,                                  \
+        ossl_ec_GFp_simple_point_set_to_infinity,                       \
+        ossl_ec_GFp_simple_point_set_affine_coordinates,                \
+        ossl_ec_GFp_simple_point_get_affine_coordinates,                \
         NULL, /* point_set_compressed_coordinates */                    \
         NULL, /* point2oct */                                           \
         NULL, /* oct2point */                                           \
-        ec_GFp_simple_add,                                              \
-        ec_GFp_simple_dbl,                                              \
-        ec_GFp_simple_invert,                                           \
-        ec_GFp_simple_is_at_infinity,                                   \
-        ec_GFp_simple_is_on_curve,                                      \
-        ec_GFp_simple_cmp,                                              \
-        ec_GFp_simple_make_affine,                                      \
-        ec_GFp_simple_points_make_affine,                               \
+        ossl_ec_GFp_simple_add,                                         \
+        ossl_ec_GFp_simple_dbl,                                         \
+        ossl_ec_GFp_simple_invert,                                      \
+        ossl_ec_GFp_simple_is_at_infinity,                              \
+        ossl_ec_GFp_simple_is_on_curve,                                 \
+        ossl_ec_GFp_simple_cmp,                                         \
+        ossl_ec_GFp_simple_make_affine,                                 \
+        ossl_ec_GFp_simple_points_make_affine,                          \
         ec_GFp_s390x_nistp##bits##_mul,                                 \
         NULL, /* precompute_mult */                                     \
         NULL, /* have_precompute_mult */                                \
-        ec_GFp_simple_field_mul,                                        \
-        ec_GFp_simple_field_sqr,                                        \
+        ossl_ec_GFp_simple_field_mul,                                   \
+        ossl_ec_GFp_simple_field_sqr,                                   \
         NULL, /* field_div */                                           \
-        ec_GFp_simple_field_inv,                                        \
+        ossl_ec_GFp_simple_field_inv,                                   \
         NULL, /* field_encode */                                        \
         NULL, /* field_decode */                                        \
         NULL, /* field_set_to_one */                                    \
-        ec_key_simple_priv2oct,                                         \
-        ec_key_simple_oct2priv,                                         \
+        ossl_ec_key_simple_priv2oct,                                    \
+        ossl_ec_key_simple_oct2priv,                                    \
         NULL, /* set_private */                                         \
-        ec_key_simple_generate_key,                                     \
-        ec_key_simple_check_key,                                        \
-        ec_key_simple_generate_public_key,                              \
+        ossl_ec_key_simple_generate_key,                                \
+        ossl_ec_key_simple_check_key,                                   \
+        ossl_ec_key_simple_generate_public_key,                         \
         NULL, /* keycopy */                                             \
         NULL, /* keyfinish */                                           \
-        ecdh_simple_compute_key,                                        \
-        ecdsa_simple_sign_setup,                                        \
+        ossl_ecdh_simple_compute_key,                                   \
+        ossl_ecdsa_simple_sign_setup,                                   \
         ecdsa_s390x_nistp##bits##_sign_sig,                             \
         ecdsa_s390x_nistp##bits##_verify_sig,                           \
         NULL, /* field_inverse_mod_ord */                               \
-        ec_GFp_simple_blind_coordinates,                                \
-        ec_GFp_simple_ladder_pre,                                       \
-        ec_GFp_simple_ladder_step,                                      \
-        ec_GFp_simple_ladder_post                                       \
+        ossl_ec_GFp_simple_blind_coordinates,                           \
+        ossl_ec_GFp_simple_ladder_pre,                                  \
+        ossl_ec_GFp_simple_ladder_step,                                 \
+        ossl_ec_GFp_simple_ladder_post                                  \
     };                                                                  \
     static const EC_METHOD *ret;                                        \
                                                                         \
diff --git a/crypto/ec/ecp_smpl.c b/crypto/ec/ecp_smpl.c
index 94b819829f..bca9da3e7e 100644
--- a/crypto/ec/ecp_smpl.c
+++ b/crypto/ec/ecp_smpl.c
@@ -24,58 +24,58 @@ const EC_METHOD *EC_GFp_simple_method(void)
     static const EC_METHOD ret = {
         EC_FLAGS_DEFAULT_OCT,
         NID_X9_62_prime_field,
-        ec_GFp_simple_group_init,
-        ec_GFp_simple_group_finish,
-        ec_GFp_simple_group_clear_finish,
-        ec_GFp_simple_group_copy,
-        ec_GFp_simple_group_set_curve,
-        ec_GFp_simple_group_get_curve,
-        ec_GFp_simple_group_get_degree,
-        ec_group_simple_order_bits,
-        ec_GFp_simple_group_check_discriminant,
-        ec_GFp_simple_point_init,
-        ec_GFp_simple_point_finish,
-        ec_GFp_simple_point_clear_finish,
-        ec_GFp_simple_point_copy,
-        ec_GFp_simple_point_set_to_infinity,
-        ec_GFp_simple_point_set_affine_coordinates,
-        ec_GFp_simple_point_get_affine_coordinates,
+        ossl_ec_GFp_simple_group_init,
+        ossl_ec_GFp_simple_group_finish,
+        ossl_ec_GFp_simple_group_clear_finish,
+        ossl_ec_GFp_simple_group_copy,
+        ossl_ec_GFp_simple_group_set_curve,
+        ossl_ec_GFp_simple_group_get_curve,
+        ossl_ec_GFp_simple_group_get_degree,
+        ossl_ec_group_simple_order_bits,
+        ossl_ec_GFp_simple_group_check_discriminant,
+        ossl_ec_GFp_simple_point_init,
+        ossl_ec_GFp_simple_point_finish,
+        ossl_ec_GFp_simple_point_clear_finish,
+        ossl_ec_GFp_simple_point_copy,
+        ossl_ec_GFp_simple_point_set_to_infinity,
+        ossl_ec_GFp_simple_point_set_affine_coordinates,
+        ossl_ec_GFp_simple_point_get_affine_coordinates,
         0, 0, 0,
-        ec_GFp_simple_add,
-        ec_GFp_simple_dbl,
-        ec_GFp_simple_invert,
-        ec_GFp_simple_is_at_infinity,
-        ec_GFp_simple_is_on_curve,
-        ec_GFp_simple_cmp,
-        ec_GFp_simple_make_affine,
-        ec_GFp_simple_points_make_affine,
+        ossl_ec_GFp_simple_add,
+        ossl_ec_GFp_simple_dbl,
+        ossl_ec_GFp_simple_invert,
+        ossl_ec_GFp_simple_is_at_infinity,
+        ossl_ec_GFp_simple_is_on_curve,
+        ossl_ec_GFp_simple_cmp,
+        ossl_ec_GFp_simple_make_affine,
+        ossl_ec_GFp_simple_points_make_affine,
         0 /* mul */ ,
         0 /* precompute_mult */ ,
         0 /* have_precompute_mult */ ,
-        ec_GFp_simple_field_mul,
-        ec_GFp_simple_field_sqr,
+        ossl_ec_GFp_simple_field_mul,
+        ossl_ec_GFp_simple_field_sqr,
         0 /* field_div */ ,
-        ec_GFp_simple_field_inv,
+        ossl_ec_GFp_simple_field_inv,
         0 /* field_encode */ ,
         0 /* field_decode */ ,
         0,                      /* field_set_to_one */
-        ec_key_simple_priv2oct,
-        ec_key_simple_oct2priv,
+        ossl_ec_key_simple_priv2oct,
+        ossl_ec_key_simple_oct2priv,
         0, /* set private */
-        ec_key_simple_generate_key,
-        ec_key_simple_check_key,
-        ec_key_simple_generate_public_key,
+        ossl_ec_key_simple_generate_key,
+        ossl_ec_key_simple_check_key,
+        ossl_ec_key_simple_generate_public_key,
         0, /* keycopy */
         0, /* keyfinish */
-        ecdh_simple_compute_key,
-        ecdsa_simple_sign_setup,
-        ecdsa_simple_sign_sig,
-        ecdsa_simple_verify_sig,
+        ossl_ecdh_simple_compute_key,
+        ossl_ecdsa_simple_sign_setup,
+        ossl_ecdsa_simple_sign_sig,
+        ossl_ecdsa_simple_verify_sig,
         0, /* field_inverse_mod_ord */
-        ec_GFp_simple_blind_coordinates,
-        ec_GFp_simple_ladder_pre,
-        ec_GFp_simple_ladder_step,
-        ec_GFp_simple_ladder_post
+        ossl_ec_GFp_simple_blind_coordinates,
+        ossl_ec_GFp_simple_ladder_pre,
+        ossl_ec_GFp_simple_ladder_step,
+        ossl_ec_GFp_simple_ladder_post
     };
 
     return &ret;
@@ -95,7 +95,7 @@ const EC_METHOD *EC_GFp_simple_method(void)
  * representation (i.e. 'encoding' means multiplying by some factor R).
  */
 
-int ec_GFp_simple_group_init(EC_GROUP *group)
+int ossl_ec_GFp_simple_group_init(EC_GROUP *group)
 {
     group-&gt;field = BN_new();
     group-&gt;a = BN_new();
@@ -110,21 +110,21 @@ int ec_GFp_simple_group_init(EC_GROUP *group)
     return 1;
 }
 
-void ec_GFp_simple_group_finish(EC_GROUP *group)
+void ossl_ec_GFp_simple_group_finish(EC_GROUP *group)
 {
     BN_free(group-&gt;field);
     BN_free(group-&gt;a);
     BN_free(group-&gt;b);
 }
 
-void ec_GFp_simple_group_clear_finish(EC_GROUP *group)
+void ossl_ec_GFp_simple_group_clear_finish(EC_GROUP *group)
 {
     BN_clear_free(group-&gt;field);
     BN_clear_free(group-&gt;a);
     BN_clear_free(group-&gt;b);
 }
 
-int ec_GFp_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)
+int ossl_ec_GFp_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)
 {
     if (!BN_copy(dest-&gt;field, src-&gt;field))
         return 0;
@@ -138,9 +138,9 @@ int ec_GFp_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)
     return 1;
 }
 
-int ec_GFp_simple_group_set_curve(EC_GROUP *group,
-                                  const BIGNUM *p, const BIGNUM *a,
-                                  const BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GFp_simple_group_set_curve(EC_GROUP *group,
+                                       const BIGNUM *p, const BIGNUM *a,
+                                       const BIGNUM *b, BN_CTX *ctx)
 {
     int ret = 0;
     BN_CTX *new_ctx = NULL;
@@ -197,8 +197,8 @@ int ec_GFp_simple_group_set_curve(EC_GROUP *group,
     return ret;
 }
 
-int ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a,
-                                  BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p,
+                                       BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
 {
     int ret = 0;
     BN_CTX *new_ctx = NULL;
@@ -242,12 +242,13 @@ int ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a,
     return ret;
 }
 
-int ec_GFp_simple_group_get_degree(const EC_GROUP *group)
+int ossl_ec_GFp_simple_group_get_degree(const EC_GROUP *group)
 {
     return BN_num_bits(group-&gt;field);
 }
 
-int ec_GFp_simple_group_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)
+int ossl_ec_GFp_simple_group_check_discriminant(const EC_GROUP *group,
+                                                BN_CTX *ctx)
 {
     int ret = 0;
     BIGNUM *a, *b, *order, *tmp_1, *tmp_2;
@@ -318,7 +319,7 @@ int ec_GFp_simple_group_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)
     return ret;
 }
 
-int ec_GFp_simple_point_init(EC_POINT *point)
+int ossl_ec_GFp_simple_point_init(EC_POINT *point)
 {
     point-&gt;X = BN_new();
     point-&gt;Y = BN_new();
@@ -334,14 +335,14 @@ int ec_GFp_simple_point_init(EC_POINT *point)
     return 1;
 }
 
-void ec_GFp_simple_point_finish(EC_POINT *point)
+void ossl_ec_GFp_simple_point_finish(EC_POINT *point)
 {
     BN_free(point-&gt;X);
     BN_free(point-&gt;Y);
     BN_free(point-&gt;Z);
 }
 
-void ec_GFp_simple_point_clear_finish(EC_POINT *point)
+void ossl_ec_GFp_simple_point_clear_finish(EC_POINT *point)
 {
     BN_clear_free(point-&gt;X);
     BN_clear_free(point-&gt;Y);
@@ -349,7 +350,7 @@ void ec_GFp_simple_point_clear_finish(EC_POINT *point)
     point-&gt;Z_is_one = 0;
 }
 
-int ec_GFp_simple_point_copy(EC_POINT *dest, const EC_POINT *src)
+int ossl_ec_GFp_simple_point_copy(EC_POINT *dest, const EC_POINT *src)
 {
     if (!BN_copy(dest-&gt;X, src-&gt;X))
         return 0;
@@ -363,20 +364,20 @@ int ec_GFp_simple_point_copy(EC_POINT *dest, const EC_POINT *src)
     return 1;
 }
 
-int ec_GFp_simple_point_set_to_infinity(const EC_GROUP *group,
-                                        EC_POINT *point)
+int ossl_ec_GFp_simple_point_set_to_infinity(const EC_GROUP *group,
+                                             EC_POINT *point)
 {
     point-&gt;Z_is_one = 0;
     BN_zero(point-&gt;Z);
     return 1;
 }
 
-int ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
-                                                  EC_POINT *point,
-                                                  const BIGNUM *x,
-                                                  const BIGNUM *y,
-                                                  const BIGNUM *z,
-                                                  BN_CTX *ctx)
+int ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
+                                                       EC_POINT *point,
+                                                       const BIGNUM *x,
+                                                       const BIGNUM *y,
+                                                       const BIGNUM *z,
+                                                       BN_CTX *ctx)
 {
     BN_CTX *new_ctx = NULL;
     int ret = 0;
@@ -431,10 +432,10 @@ int ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
     return ret;
 }
 
-int ec_GFp_simple_get_Jprojective_coordinates_GFp(const EC_GROUP *group,
-                                                  const EC_POINT *point,
-                                                  BIGNUM *x, BIGNUM *y,
-                                                  BIGNUM *z, BN_CTX *ctx)
+int ossl_ec_GFp_simple_get_Jprojective_coordinates_GFp(const EC_GROUP *group,
+                                                       const EC_POINT *point,
+                                                       BIGNUM *x, BIGNUM *y,
+                                                       BIGNUM *z, BN_CTX *ctx)
 {
     BN_CTX *new_ctx = NULL;
     int ret = 0;
@@ -480,10 +481,10 @@ int ec_GFp_simple_get_Jprojective_coordinates_GFp(const EC_GROUP *group,
     return ret;
 }
 
-int ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *group,
-                                               EC_POINT *point,
-                                               const BIGNUM *x,
-                                               const BIGNUM *y, BN_CTX *ctx)
+int ossl_ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *group,
+                                                    EC_POINT *point,
+                                                    const BIGNUM *x,
+                                                    const BIGNUM *y, BN_CTX *ctx)
 {
     if (x == NULL || y == NULL) {
         /*
@@ -497,10 +498,10 @@ int ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *group,
                                                     BN_value_one(), ctx);
 }
 
-int ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *group,
-                                               const EC_POINT *point,
-                                               BIGNUM *x, BIGNUM *y,
-                                               BN_CTX *ctx)
+int ossl_ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *group,
+                                                    const EC_POINT *point,
+                                                    BIGNUM *x, BIGNUM *y,
+                                                    BN_CTX *ctx)
 {
     BN_CTX *new_ctx = NULL;
     BIGNUM *Z, *Z_1, *Z_2, *Z_3;
@@ -609,8 +610,8 @@ int ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *group,
     return ret;
 }
 
-int ec_GFp_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
-                      const EC_POINT *b, BN_CTX *ctx)
+int ossl_ec_GFp_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                           const EC_POINT *b, BN_CTX *ctx)
 {
     int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,
                       const BIGNUM *, BN_CTX *);
@@ -794,8 +795,8 @@ int ec_GFp_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
     return ret;
 }
 
-int ec_GFp_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
-                      BN_CTX *ctx)
+int ossl_ec_GFp_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
+                           BN_CTX *ctx)
 {
     int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,
                       const BIGNUM *, BN_CTX *);
@@ -936,7 +937,8 @@ int ec_GFp_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
     return ret;
 }
 
-int ec_GFp_simple_invert(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
+int ossl_ec_GFp_simple_invert(const EC_GROUP *group, EC_POINT *point,
+                              BN_CTX *ctx)
 {
     if (EC_POINT_is_at_infinity(group, point) || BN_is_zero(point-&gt;Y))
         /* point is its own inverse */
@@ -945,13 +947,14 @@ int ec_GFp_simple_invert(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)
     return BN_usub(point-&gt;Y, group-&gt;field, point-&gt;Y);
 }
 
-int ec_GFp_simple_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)
+int ossl_ec_GFp_simple_is_at_infinity(const EC_GROUP *group,
+                                      const EC_POINT *point)
 {
     return BN_is_zero(point-&gt;Z);
 }
 
-int ec_GFp_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point,
-                              BN_CTX *ctx)
+int ossl_ec_GFp_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point,
+                                   BN_CTX *ctx)
 {
     int (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,
                       const BIGNUM *, BN_CTX *);
@@ -1053,8 +1056,8 @@ int ec_GFp_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point,
     return ret;
 }
 
-int ec_GFp_simple_cmp(const EC_GROUP *group, const EC_POINT *a,
-                      const EC_POINT *b, BN_CTX *ctx)
+int ossl_ec_GFp_simple_cmp(const EC_GROUP *group, const EC_POINT *a,
+                           const EC_POINT *b, BN_CTX *ctx)
 {
     /*-
      * return values:
@@ -1161,8 +1164,8 @@ int ec_GFp_simple_cmp(const EC_GROUP *group, const EC_POINT *a,
     return ret;
 }
 
-int ec_GFp_simple_make_affine(const EC_GROUP *group, EC_POINT *point,
-                              BN_CTX *ctx)
+int ossl_ec_GFp_simple_make_affine(const EC_GROUP *group, EC_POINT *point,
+                                   BN_CTX *ctx)
 {
     BN_CTX *new_ctx = NULL;
     BIGNUM *x, *y;
@@ -1200,8 +1203,8 @@ int ec_GFp_simple_make_affine(const EC_GROUP *group, EC_POINT *point,
     return ret;
 }
 
-int ec_GFp_simple_points_make_affine(const EC_GROUP *group, size_t num,
-                                     EC_POINT *points[], BN_CTX *ctx)
+int ossl_ec_GFp_simple_points_make_affine(const EC_GROUP *group, size_t num,
+                                          EC_POINT *points[], BN_CTX *ctx)
 {
     BN_CTX *new_ctx = NULL;
     BIGNUM *tmp, *tmp_Z;
@@ -1359,14 +1362,14 @@ int ec_GFp_simple_points_make_affine(const EC_GROUP *group, size_t num,
     return ret;
 }
 
-int ec_GFp_simple_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
-                            const BIGNUM *b, BN_CTX *ctx)
+int ossl_ec_GFp_simple_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
+                                 const BIGNUM *b, BN_CTX *ctx)
 {
     return BN_mod_mul(r, a, b, group-&gt;field, ctx);
 }
 
-int ec_GFp_simple_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
-                            BN_CTX *ctx)
+int ossl_ec_GFp_simple_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
+                                 BN_CTX *ctx)
 {
     return BN_mod_sqr(r, a, group-&gt;field, ctx);
 }
@@ -1377,8 +1380,8 @@ int ec_GFp_simple_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
  * Since we don't have a Mont structure here, SCA hardening is with blinding.
  * NB: &quot;a&quot; must be in _decoded_ form. (i.e. field_decode must precede.)
  */
-int ec_GFp_simple_field_inv(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
-                            BN_CTX *ctx)
+int ossl_ec_GFp_simple_field_inv(const EC_GROUP *group, BIGNUM *r,
+                                 const BIGNUM *a, BN_CTX *ctx)
 {
     BIGNUM *e = NULL;
     BN_CTX *new_ctx = NULL;
@@ -1424,8 +1427,8 @@ int ec_GFp_simple_field_inv(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,
  *   lambda = [1,group-&gt;field)
  *
  */
-int ec_GFp_simple_blind_coordinates(const EC_GROUP *group, EC_POINT *p,
-                                    BN_CTX *ctx)
+int ossl_ec_GFp_simple_blind_coordinates(const EC_GROUP *group, EC_POINT *p,
+                                         BN_CTX *ctx)
 {
     int ret = 0;
     BIGNUM *lambda = NULL;
@@ -1487,9 +1490,9 @@ int ec_GFp_simple_blind_coordinates(const EC_GROUP *group, EC_POINT *p,
  * Blinding uses the equivalence relation (\lambda X, \lambda Y, \lambda Z)
  * for any non-zero \lambda that holds for projective (homogeneous) coords.
  */
-int ec_GFp_simple_ladder_pre(const EC_GROUP *group,
-                             EC_POINT *r, EC_POINT *s,
-                             EC_POINT *p, BN_CTX *ctx)
+int ossl_ec_GFp_simple_ladder_pre(const EC_GROUP *group,
+                                  EC_POINT *r, EC_POINT *s,
+                                  EC_POINT *p, BN_CTX *ctx)
 {
     BIGNUM *t1, *t2, *t3, *t4, *t5 = NULL;
 
@@ -1557,9 +1560,9 @@ int ec_GFp_simple_ladder_pre(const EC_GROUP *group,
  * attacks&quot;, as described at
  * <A HREF="https://hyperelliptic.org/EFD/g1p/auto-shortw-xz.html#ladder-mladd-2002-it-4">https://hyperelliptic.org/EFD/g1p/auto-shortw-xz.html#ladder-mladd-2002-it-4</A>
  */
-int ec_GFp_simple_ladder_step(const EC_GROUP *group,
-                              EC_POINT *r, EC_POINT *s,
-                              EC_POINT *p, BN_CTX *ctx)
+int ossl_ec_GFp_simple_ladder_step(const EC_GROUP *group,
+                                   EC_POINT *r, EC_POINT *s,
+                                   EC_POINT *p, BN_CTX *ctx)
 {
     int ret = 0;
     BIGNUM *t0, *t1, *t2, *t3, *t4, *t5, *t6 = NULL;
@@ -1645,9 +1648,9 @@ int ec_GFp_simple_ladder_step(const EC_GROUP *group,
  *  - Y1==0 implies p has order 2, so either r or s are infinity and handled by
  *    one of the BN_is_zero(...) branches.
  */
-int ec_GFp_simple_ladder_post(const EC_GROUP *group,
-                              EC_POINT *r, EC_POINT *s,
-                              EC_POINT *p, BN_CTX *ctx)
+int ossl_ec_GFp_simple_ladder_post(const EC_GROUP *group,
+                                   EC_POINT *r, EC_POINT *s,
+                                   EC_POINT *p, BN_CTX *ctx)
 {
     int ret = 0;
     BIGNUM *t0, *t1, *t2, *t3, *t4, *t5, *t6 = NULL;
diff --git a/crypto/ec/ecx_backend.c b/crypto/ec/ecx_backend.c
index 8bd96474bd..f9f9d45f2d 100644
--- a/crypto/ec/ecx_backend.c
+++ b/crypto/ec/ecx_backend.c
@@ -20,7 +20,7 @@
  * implementations alike.
  */
 
-int ecx_public_from_private(ECX_KEY *key)
+int ossl_ecx_public_from_private(ECX_KEY *key)
 {
     switch (key-&gt;type) {
     case ECX_KEY_TYPE_X25519:
@@ -47,8 +47,8 @@ int ecx_public_from_private(ECX_KEY *key)
     return 1;
 }
 
-int ecx_key_fromdata(ECX_KEY *ecx, const OSSL_PARAM params[],
-                     int include_private)
+int ossl_ecx_key_fromdata(ECX_KEY *ecx, const OSSL_PARAM params[],
+                          int include_private)
 {
     size_t privkeylen = 0, pubkeylen = 0;
     const OSSL_PARAM *param_priv_key = NULL, *param_pub_key;
@@ -82,7 +82,7 @@ int ecx_key_fromdata(ECX_KEY *ecx, const OSSL_PARAM params[],
         || (param_priv_key != NULL &amp;&amp; privkeylen != ecx-&gt;keylen))
         return 0;
 
-    if (param_pub_key == NULL &amp;&amp; !ecx_public_from_private(ecx))
+    if (param_pub_key == NULL &amp;&amp; !ossl_ecx_public_from_private(ecx))
         return 0;
 
     ecx-&gt;haspubkey = 1;
diff --git a/crypto/ec/ecx_key.c b/crypto/ec/ecx_key.c
index 2b9386d522..45d55b5132 100644
--- a/crypto/ec/ecx_key.c
+++ b/crypto/ec/ecx_key.c
@@ -10,8 +10,8 @@
 #include &lt;openssl/err.h&gt;
 #include &quot;crypto/ecx.h&quot;
 
-ECX_KEY *ecx_key_new(OSSL_LIB_CTX *libctx, ECX_KEY_TYPE type, int haspubkey,
-                     const char *propq)
+ECX_KEY *ossl_ecx_key_new(OSSL_LIB_CTX *libctx, ECX_KEY_TYPE type, int haspubkey,
+                          const char *propq)
 {
     ECX_KEY *ret = OPENSSL_zalloc(sizeof(*ret));
 
@@ -54,7 +54,7 @@ err:
     return NULL;
 }
 
-void ecx_key_free(ECX_KEY *key)
+void ossl_ecx_key_free(ECX_KEY *key)
 {
     int i;
 
@@ -73,12 +73,12 @@ void ecx_key_free(ECX_KEY *key)
     OPENSSL_free(key);
 }
 
-void ecx_key_set0_libctx(ECX_KEY *key, OSSL_LIB_CTX *libctx)
+void ossl_ecx_key_set0_libctx(ECX_KEY *key, OSSL_LIB_CTX *libctx)
 {
     key-&gt;libctx = libctx;
 }
 
-int ecx_key_up_ref(ECX_KEY *key)
+int ossl_ecx_key_up_ref(ECX_KEY *key)
 {
     int i;
 
@@ -90,7 +90,7 @@ int ecx_key_up_ref(ECX_KEY *key)
     return ((i &gt; 1) ? 1 : 0);
 }
 
-unsigned char *ecx_key_allocate_privkey(ECX_KEY *key)
+unsigned char *ossl_ecx_key_allocate_privkey(ECX_KEY *key)
 {
     key-&gt;privkey = OPENSSL_secure_zalloc(key-&gt;keylen);
 
diff --git a/crypto/ec/ecx_meth.c b/crypto/ec/ecx_meth.c
index 3178cc2d31..269e270ea6 100644
--- a/crypto/ec/ecx_meth.c
+++ b/crypto/ec/ecx_meth.c
@@ -59,7 +59,7 @@ static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
         }
     }
 
-    key = ecx_key_new(libctx, KEYNID2TYPE(id), 1, propq);
+    key = ossl_ecx_key_new(libctx, KEYNID2TYPE(id), 1, propq);
     if (key == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
@@ -69,7 +69,7 @@ static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
     if (op == KEY_OP_PUBLIC) {
         memcpy(pubkey, p, plen);
     } else {
-        privkey = ecx_key_allocate_privkey(key);
+        privkey = ossl_ecx_key_allocate_privkey(key);
         if (privkey == NULL) {
             ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
             goto err;
@@ -88,7 +88,7 @@ static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
         } else {
             memcpy(privkey, p, KEYLENID(id));
         }
-        if (!ecx_public_from_private(key)) {
+        if (!ossl_ecx_public_from_private(key)) {
             ERR_raise(ERR_LIB_EC, EC_R_FAILED_MAKING_PUBLIC_KEY);
             goto err;
         }
@@ -97,7 +97,7 @@ static int ecx_key_op(EVP_PKEY *pkey, int id, const X509_ALGOR *palg,
     EVP_PKEY_assign(pkey, id, key);
     return 1;
  err:
-    ecx_key_free(key);
+    ossl_ecx_key_free(key);
     return 0;
 }
 
@@ -235,7 +235,7 @@ static int ecx_security_bits(const EVP_PKEY *pkey)
 
 static void ecx_free(EVP_PKEY *pkey)
 {
-    ecx_key_free(pkey-&gt;pkey.ecx);
+    ossl_ecx_key_free(pkey-&gt;pkey.ecx);
 }
 
 /* &quot;parameters&quot; are always equal */
@@ -438,17 +438,17 @@ static int ecx_generic_import_from(const OSSL_PARAM params[], void *vpctx,
 {
     EVP_PKEY_CTX *pctx = vpctx;
     EVP_PKEY *pkey = EVP_PKEY_CTX_get0_pkey(pctx);
-    ECX_KEY *ecx = ecx_key_new(pctx-&gt;libctx, KEYNID2TYPE(keytype), 0,
-                               pctx-&gt;propquery);
+    ECX_KEY *ecx = ossl_ecx_key_new(pctx-&gt;libctx, KEYNID2TYPE(keytype), 0,
+                                    pctx-&gt;propquery);
 
     if (ecx == NULL) {
         ERR_raise(ERR_LIB_DH, ERR_R_MALLOC_FAILURE);
         return 0;
     }
 
-    if (!ecx_key_fromdata(ecx, params, 1)
+    if (!ossl_ecx_key_fromdata(ecx, params, 1)
         || !EVP_PKEY_assign(pkey, keytype, ecx)) {
-        ecx_key_free(ecx);
+        ossl_ecx_key_free(ecx);
         return 0;
     }
     return 1;
@@ -943,8 +943,8 @@ static int s390x_pkey_ecx_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
     };
-    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_X25519, 1,
-                               ctx-&gt;propquery);
+    ECX_KEY *key = ossl_ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_X25519, 1,
+                                    ctx-&gt;propquery);
     unsigned char *privkey = NULL, *pubkey;
 
     if (key == NULL) {
@@ -954,7 +954,7 @@ static int s390x_pkey_ecx_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 
     pubkey = key-&gt;pubkey;
 
-    privkey = ecx_key_allocate_privkey(key);
+    privkey = ossl_ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
@@ -973,7 +973,7 @@ static int s390x_pkey_ecx_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     EVP_PKEY_assign(pkey, ctx-&gt;pmeth-&gt;pkey_id, key);
     return 1;
  err:
-    ecx_key_free(key);
+    ossl_ecx_key_free(key);
     return 0;
 }
 
@@ -986,8 +986,8 @@ static int s390x_pkey_ecx_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
     };
-    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_X448, 1,
-                               ctx-&gt;propquery);
+    ECX_KEY *key = ossl_ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_X448, 1,
+                                    ctx-&gt;propquery);
     unsigned char *privkey = NULL, *pubkey;
 
     if (key == NULL) {
@@ -997,7 +997,7 @@ static int s390x_pkey_ecx_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 
     pubkey = key-&gt;pubkey;
 
-    privkey = ecx_key_allocate_privkey(key);
+    privkey = ossl_ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
@@ -1015,7 +1015,7 @@ static int s390x_pkey_ecx_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     EVP_PKEY_assign(pkey, ctx-&gt;pmeth-&gt;pkey_id, key);
     return 1;
  err:
-    ecx_key_free(key);
+    ossl_ecx_key_free(key);
     return 0;
 }
 
@@ -1032,8 +1032,8 @@ static int s390x_pkey_ecd_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
     };
     unsigned char x_dst[32], buff[SHA512_DIGEST_LENGTH];
-    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_ED25519, 1,
-                               ctx-&gt;propquery);
+    ECX_KEY *key = ossl_ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_ED25519, 1,
+                                    ctx-&gt;propquery);
     unsigned char *privkey = NULL, *pubkey;
     unsigned int sz;
 
@@ -1044,7 +1044,7 @@ static int s390x_pkey_ecd_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 
     pubkey = key-&gt;pubkey;
 
-    privkey = ecx_key_allocate_privkey(key);
+    privkey = ossl_ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
@@ -1069,7 +1069,7 @@ static int s390x_pkey_ecd_keygen25519(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     EVP_PKEY_assign(pkey, ctx-&gt;pmeth-&gt;pkey_id, key);
     return 1;
  err:
-    ecx_key_free(key);
+    ossl_ecx_key_free(key);
     return 0;
 }
 
@@ -1090,8 +1090,8 @@ static int s390x_pkey_ecd_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
         0x24, 0xbc, 0xb6, 0x6e, 0x71, 0x46, 0x3f, 0x69, 0x00
     };
     unsigned char x_dst[57], buff[114];
-    ECX_KEY *key = ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_ED448, 1,
-                               ctx-&gt;propquery);
+    ECX_KEY *key = ossl_ecx_key_new(ctx-&gt;libctx, ECX_KEY_TYPE_ED448, 1,
+                                    ctx-&gt;propquery);
     unsigned char *privkey = NULL, *pubkey;
     EVP_MD_CTX *hashctx = NULL;
 
@@ -1102,7 +1102,7 @@ static int s390x_pkey_ecd_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
 
     pubkey = key-&gt;pubkey;
 
-    privkey = ecx_key_allocate_privkey(key);
+    privkey = ossl_ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         goto err;
@@ -1135,7 +1135,7 @@ static int s390x_pkey_ecd_keygen448(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
     EVP_MD_CTX_free(hashctx);
     return 1;
  err:
-    ecx_key_free(key);
+    ossl_ecx_key_free(key);
     EVP_MD_CTX_free(hashctx);
     return 0;
 }
@@ -1351,7 +1351,7 @@ static const EVP_PKEY_METHOD ed448_s390x_pkey_meth = {
 };
 #endif
 
-const EVP_PKEY_METHOD *ecx25519_pkey_method(void)
+const EVP_PKEY_METHOD *ossl_ecx25519_pkey_method(void)
 {
 #ifdef S390X_EC_ASM
     if (OPENSSL_s390xcap_P.pcc[1] &amp; S390X_CAPBIT(S390X_SCALAR_MULTIPLY_X25519))
@@ -1360,7 +1360,7 @@ const EVP_PKEY_METHOD *ecx25519_pkey_method(void)
     return &amp;ecx25519_pkey_meth;
 }
 
-const EVP_PKEY_METHOD *ecx448_pkey_method(void)
+const EVP_PKEY_METHOD *ossl_ecx448_pkey_method(void)
 {
 #ifdef S390X_EC_ASM
     if (OPENSSL_s390xcap_P.pcc[1] &amp; S390X_CAPBIT(S390X_SCALAR_MULTIPLY_X448))
@@ -1369,7 +1369,7 @@ const EVP_PKEY_METHOD *ecx448_pkey_method(void)
     return &amp;ecx448_pkey_meth;
 }
 
-const EVP_PKEY_METHOD *ed25519_pkey_method(void)
+const EVP_PKEY_METHOD *ossl_ed25519_pkey_method(void)
 {
 #ifdef S390X_EC_ASM
     if (OPENSSL_s390xcap_P.pcc[1] &amp; S390X_CAPBIT(S390X_SCALAR_MULTIPLY_ED25519)
@@ -1381,7 +1381,7 @@ const EVP_PKEY_METHOD *ed25519_pkey_method(void)
     return &amp;ed25519_pkey_meth;
 }
 
-const EVP_PKEY_METHOD *ed448_pkey_method(void)
+const EVP_PKEY_METHOD *ossl_ed448_pkey_method(void)
 {
 #ifdef S390X_EC_ASM
     if (OPENSSL_s390xcap_P.pcc[1] &amp; S390X_CAPBIT(S390X_SCALAR_MULTIPLY_ED448)
diff --git a/crypto/evp/ctrl_params_translate.c b/crypto/evp/ctrl_params_translate.c
index 04f8fdbcab..e0f849d236 100644
--- a/crypto/evp/ctrl_params_translate.c
+++ b/crypto/evp/ctrl_params_translate.c
@@ -1023,7 +1023,7 @@ static int fix_dh_paramgen_type(enum state state,
         return 0;
 
     if (state == PRE_CTRL_TO_PARAMS) {
-        ctx-&gt;p2 = (char *)dh_gen_type_id2name(ctx-&gt;p1);
+        ctx-&gt;p2 = (char *)ossl_dh_gen_type_id2name(ctx-&gt;p1);
         ctx-&gt;p1 = 0;
     }
 
@@ -1031,7 +1031,7 @@ static int fix_dh_paramgen_type(enum state state,
         return ret;
 
     if (state == PRE_PARAMS_TO_CTRL) {
-        ctx-&gt;p1 = dh_gen_type_name2id(ctx-&gt;p2);
+        ctx-&gt;p1 = ossl_dh_gen_type_name2id(ctx-&gt;p2);
         ctx-&gt;p2 = NULL;
     }
 
@@ -1504,7 +1504,7 @@ static int get_payload_group_name(enum state state,
             if (grp != NULL)
                 nid = EC_GROUP_get_curve_name(grp);
             if (nid != NID_undef)
-                ctx-&gt;p2 = (char *)ec_curve_nid2name(nid);
+                ctx-&gt;p2 = (char *)ossl_ec_curve_nid2name(nid);
         }
         break;
 #endif
@@ -1569,7 +1569,7 @@ static int get_payload_public_key(enum state state,
     case EVP_PKEY_DH:
         switch (ctx-&gt;params-&gt;data_type) {
         case OSSL_PARAM_OCTET_STRING:
-            ctx-&gt;sz = dh_key2buf(EVP_PKEY_get0_DH(pkey), &amp;buf, 0, 1);
+            ctx-&gt;sz = ossl_dh_key2buf(EVP_PKEY_get0_DH(pkey), &amp;buf, 0, 1);
             ctx-&gt;p2 = buf;
             break;
         case OSSL_PARAM_UNSIGNED_INTEGER:
@@ -1592,7 +1592,7 @@ static int get_payload_public_key(enum state state,
     case EVP_PKEY_EC:
         if (ctx-&gt;params-&gt;data_type == OSSL_PARAM_OCTET_STRING) {
             EC_KEY *eckey = EVP_PKEY_get0_EC_KEY(pkey);
-            BN_CTX *bnctx = BN_CTX_new_ex(ec_key_get_libctx(eckey));
+            BN_CTX *bnctx = BN_CTX_new_ex(ossl_ec_key_get_libctx(eckey));
             const EC_GROUP *ecg = EC_KEY_get0_group(eckey);
             const EC_POINT *point = EC_KEY_get0_public_key(eckey);
 
diff --git a/crypto/evp/dh_support.c b/crypto/evp/dh_support.c
index 212cf908eb..0f33b28122 100644
--- a/crypto/evp/dh_support.c
+++ b/crypto/evp/dh_support.c
@@ -25,7 +25,7 @@ static const DH_GENTYPE_NAME2ID dhtype2id[]=
     { &quot;generator&quot;, DH_PARAMGEN_TYPE_GENERATOR }
 };
 
-const char *dh_gen_type_id2name(int id)
+const char *ossl_dh_gen_type_id2name(int id)
 {
     size_t i;
 
@@ -36,7 +36,7 @@ const char *dh_gen_type_id2name(int id)
     return NULL;
 }
 
-int dh_gen_type_name2id(const char *name)
+int ossl_dh_gen_type_name2id(const char *name)
 {
     size_t i;
 
diff --git a/crypto/evp/ec_support.c b/crypto/evp/ec_support.c
index 7afd307435..a1eca28b79 100644
--- a/crypto/evp/ec_support.c
+++ b/crypto/evp/ec_support.c
@@ -115,7 +115,7 @@ static const EC_NAME2NID curve_list[] = {
     {&quot;SM2&quot;, NID_sm2 },
 };
 
-const char *ec_curve_nid2name(int nid)
+const char *ossl_ec_curve_nid2name(int nid)
 {
     size_t i;
 
@@ -126,7 +126,7 @@ const char *ec_curve_nid2name(int nid)
      * TODO(3.0) Figure out if we should try to find the nid with
      * EC_curve_nid2nist() first, i.e. make it a priority to return
      * NIST names if there is one for the NID.  This is related to
-     * the TODO comment in ec_curve_name2nid().
+     * the TODO comment in ossl_ec_curve_name2nid().
      */
 
     for (i = 0; i &lt; OSSL_NELEM(curve_list); i++) {
@@ -136,13 +136,13 @@ const char *ec_curve_nid2name(int nid)
     return NULL;
 }
 
-int ec_curve_name2nid(const char *name)
+int ossl_ec_curve_name2nid(const char *name)
 {
     size_t i;
     int nid;
 
     if (name != NULL) {
-        if ((nid = ec_curve_nist2nid_int(name)) != NID_undef)
+        if ((nid = ossl_ec_curve_nist2nid_int(name)) != NID_undef)
             return nid;
 
         for (i = 0; i &lt; OSSL_NELEM(curve_list); i++) {
@@ -174,7 +174,7 @@ static const EC_NAME2NID nist_curves[] = {
     {&quot;P-521&quot;, NID_secp521r1}
 };
 
-const char *ec_curve_nid2nist_int(int nid)
+const char *ossl_ec_curve_nid2nist_int(int nid)
 {
     size_t i;
     for (i = 0; i &lt; OSSL_NELEM(nist_curves); i++) {
@@ -184,7 +184,7 @@ const char *ec_curve_nid2nist_int(int nid)
     return NULL;
 }
 
-int ec_curve_nist2nid_int(const char *name)
+int ossl_ec_curve_nist2nid_int(const char *name)
 {
     size_t i;
     for (i = 0; i &lt; OSSL_NELEM(nist_curves); i++) {
diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
index 9f3256c191..63f3f4cbc7 100644
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -838,12 +838,12 @@ static ECX_KEY *evp_pkey_get1_ECX_KEY(EVP_PKEY *pkey, int type)
 {
     ECX_KEY *ret = evp_pkey_get0_ECX_KEY(pkey, type);
     if (ret != NULL)
-        ecx_key_up_ref(ret);
+        ossl_ecx_key_up_ref(ret);
     return ret;
 }
 
 #  define IMPLEMENT_ECX_VARIANT(NAME)                                   \
-    ECX_KEY *evp_pkey_get1_##NAME(EVP_PKEY *pkey)                       \
+    ECX_KEY *ossl_evp_pkey_get1_##NAME(EVP_PKEY *pkey)                  \
     {                                                                   \
         return evp_pkey_get1_ECX_KEY(pkey, EVP_PKEY_##NAME);            \
     }
diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index 500e056479..478ae40a26 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -51,25 +51,25 @@ static STACK_OF(EVP_PKEY_METHOD) *app_pkey_methods = NULL;
 static pmeth_fn standard_methods[] = {
     ossl_rsa_pkey_method,
 # ifndef OPENSSL_NO_DH
-    dh_pkey_method,
+    ossl_dh_pkey_method,
 # endif
 # ifndef OPENSSL_NO_DSA
-    dsa_pkey_method,
+    ossl_dsa_pkey_method,
 # endif
 # ifndef OPENSSL_NO_EC
-    ec_pkey_method,
+    ossl_ec_pkey_method,
 # endif
     ossl_rsa_pss_pkey_method,
 # ifndef OPENSSL_NO_DH
-    dhx_pkey_method,
+    ossl_dhx_pkey_method,
 # endif
 # ifndef OPENSSL_NO_EC
-    ecx25519_pkey_method,
-    ecx448_pkey_method,
+    ossl_ecx25519_pkey_method,
+    ossl_ecx448_pkey_method,
 # endif
 # ifndef OPENSSL_NO_EC
-    ed25519_pkey_method,
-    ed448_pkey_method,
+    ossl_ed25519_pkey_method,
+    ossl_ed448_pkey_method,
 # endif
 };
 
@@ -1326,6 +1326,7 @@ int EVP_PKEY_CTX_ctrl_uint64(EVP_PKEY_CTX *ctx, int keytype, int optype,
     return EVP_PKEY_CTX_ctrl(ctx, keytype, optype, cmd, 0, &amp;value);
 }
 
+
 static int evp_pkey_ctx_ctrl_str_int(EVP_PKEY_CTX *ctx,
                                      const char *name, const char *value)
 {
diff --git a/crypto/sm2/sm2_crypt.c b/crypto/sm2/sm2_crypt.c
index 9201d712c1..5e455d0613 100644
--- a/crypto/sm2/sm2_crypt.c
+++ b/crypto/sm2/sm2_crypt.c
@@ -17,7 +17,7 @@
 
 #include &quot;crypto/sm2.h&quot;
 #include &quot;crypto/sm2err.h&quot;
-#include &quot;crypto/ec.h&quot; /* ecdh_KDF_X9_63() */
+#include &quot;crypto/ec.h&quot; /* ossl_ecdh_kdf_X9_63() */
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/bn.h&gt;
@@ -67,8 +67,8 @@ static size_t ec_field_size(const EC_GROUP *group)
     return field_size;
 }
 
-int sm2_plaintext_size(const EC_KEY *key, const EVP_MD *digest, size_t msg_len,
-                       size_t *pt_size)
+int ossl_sm2_plaintext_size(const EC_KEY *key, const EVP_MD *digest,
+                            size_t msg_len, size_t *pt_size)
 {
     const size_t field_size = ec_field_size(EC_KEY_get0_group(key));
     const int md_size = EVP_MD_size(digest);
@@ -93,8 +93,8 @@ int sm2_plaintext_size(const EC_KEY *key, const EVP_MD *digest, size_t msg_len,
     return 1;
 }
 
-int sm2_ciphertext_size(const EC_KEY *key, const EVP_MD *digest, size_t msg_len,
-                        size_t *ct_size)
+int ossl_sm2_ciphertext_size(const EC_KEY *key, const EVP_MD *digest,
+                             size_t msg_len, size_t *ct_size)
 {
     const size_t field_size = ec_field_size(EC_KEY_get0_group(key));
     const int md_size = EVP_MD_size(digest);
@@ -113,10 +113,10 @@ int sm2_ciphertext_size(const EC_KEY *key, const EVP_MD *digest, size_t msg_len,
     return 1;
 }
 
-int sm2_encrypt(const EC_KEY *key,
-                const EVP_MD *digest,
-                const uint8_t *msg,
-                size_t msg_len, uint8_t *ciphertext_buf, size_t *ciphertext_len)
+int ossl_sm2_encrypt(const EC_KEY *key,
+                     const EVP_MD *digest,
+                     const uint8_t *msg, size_t msg_len,
+                     uint8_t *ciphertext_buf, size_t *ciphertext_len)
 {
     int rc = 0, ciphertext_leni;
     size_t i;
@@ -139,8 +139,8 @@ int sm2_encrypt(const EC_KEY *key,
     size_t field_size;
     const int C3_size = EVP_MD_size(digest);
     EVP_MD *fetched_digest = NULL;
-    OSSL_LIB_CTX *libctx = ec_key_get_libctx(key);
-    const char *propq = ec_key_get0_propq(key);
+    OSSL_LIB_CTX *libctx = ossl_ec_key_get_libctx(key);
+    const char *propq = ossl_ec_key_get0_propq(key);
 
     /* NULL these before any &quot;goto done&quot; */
     ctext_struct.C2 = NULL;
@@ -213,8 +213,8 @@ int sm2_encrypt(const EC_KEY *key,
    }
 
     /* X9.63 with no salt happens to match the KDF used in SM2 */
-    if (!ecdh_KDF_X9_63(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,
-                        digest, libctx, propq)) {
+    if (!ossl_ecdh_kdf_X9_63(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,
+                             digest, libctx, propq)) {
         ERR_raise(ERR_LIB_SM2, ERR_R_EVP_LIB);
         goto done;
     }
@@ -275,10 +275,10 @@ int sm2_encrypt(const EC_KEY *key,
     return rc;
 }
 
-int sm2_decrypt(const EC_KEY *key,
-                const EVP_MD *digest,
-                const uint8_t *ciphertext,
-                size_t ciphertext_len, uint8_t *ptext_buf, size_t *ptext_len)
+int ossl_sm2_decrypt(const EC_KEY *key,
+                     const EVP_MD *digest,
+                     const uint8_t *ciphertext, size_t ciphertext_len,
+                     uint8_t *ptext_buf, size_t *ptext_len)
 {
     int rc = 0;
     int i;
@@ -297,8 +297,8 @@ int sm2_decrypt(const EC_KEY *key,
     const uint8_t *C3 = NULL;
     int msg_len = 0;
     EVP_MD_CTX *hash = NULL;
-    OSSL_LIB_CTX *libctx = ec_key_get_libctx(key);
-    const char *propq = ec_key_get0_propq(key);
+    OSSL_LIB_CTX *libctx = ossl_ec_key_get_libctx(key);
+    const char *propq = ossl_ec_key_get0_propq(key);
 
     if (field_size == 0 || hash_size &lt;= 0)
        goto done;
@@ -362,8 +362,8 @@ int sm2_decrypt(const EC_KEY *key,
 
     if (BN_bn2binpad(x2, x2y2, field_size) &lt; 0
             || BN_bn2binpad(y2, x2y2 + field_size, field_size) &lt; 0
-            || !ecdh_KDF_X9_63(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,
-                               digest, libctx, propq)) {
+            || !ossl_ecdh_kdf_X9_63(msg_mask, msg_len, x2y2, 2 * field_size,
+                                    NULL, 0, digest, libctx, propq)) {
         ERR_raise(ERR_LIB_SM2, ERR_R_INTERNAL_ERROR);
         goto done;
     }
diff --git a/crypto/sm2/sm2_key.c b/crypto/sm2/sm2_key.c
index ec96737a84..9d0b9208fa 100644
--- a/crypto/sm2/sm2_key.c
+++ b/crypto/sm2/sm2_key.c
@@ -19,7 +19,7 @@
  * crypto/ec/ec_key.c
  */
 
-int sm2_key_private_check(const EC_KEY *eckey)
+int ossl_sm2_key_private_check(const EC_KEY *eckey)
 {
     int ret = 0;
     BIGNUM *max = NULL;
diff --git a/crypto/sm2/sm2_sign.c b/crypto/sm2/sm2_sign.c
index e36e0710b7..d9e16e1f98 100644
--- a/crypto/sm2/sm2_sign.c
+++ b/crypto/sm2/sm2_sign.c
@@ -13,7 +13,7 @@
 
 #include &quot;crypto/sm2.h&quot;
 #include &quot;crypto/sm2err.h&quot;
-#include &quot;crypto/ec.h&quot; /* ec_group_do_inverse_ord() */
+#include &quot;crypto/ec.h&quot; /* ossl_ec_group_do_inverse_ord() */
 #include &quot;internal/numbers.h&quot;
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/evp.h&gt;
@@ -21,11 +21,11 @@
 #include &lt;openssl/bn.h&gt;
 #include &lt;string.h&gt;
 
-int sm2_compute_z_digest(uint8_t *out,
-                         const EVP_MD *digest,
-                         const uint8_t *id,
-                         const size_t id_len,
-                         const EC_KEY *key)
+int ossl_sm2_compute_z_digest(uint8_t *out,
+                              const EVP_MD *digest,
+                              const uint8_t *id,
+                              const size_t id_len,
+                              const EC_KEY *key)
 {
     int rc = 0;
     const EC_GROUP *group = EC_KEY_get0_group(key);
@@ -44,7 +44,7 @@ int sm2_compute_z_digest(uint8_t *out,
     uint8_t e_byte = 0;
 
     hash = EVP_MD_CTX_new();
-    ctx = BN_CTX_new_ex(ec_key_get_libctx(key));
+    ctx = BN_CTX_new_ex(ossl_ec_key_get_libctx(key));
     if (hash == NULL || ctx == NULL) {
         ERR_raise(ERR_LIB_SM2, ERR_R_MALLOC_FAILURE);
         goto done;
@@ -149,8 +149,8 @@ static BIGNUM *sm2_compute_msg_hash(const EVP_MD *digest,
     uint8_t *z = NULL;
     BIGNUM *e = NULL;
     EVP_MD *fetched_digest = NULL;
-    OSSL_LIB_CTX *libctx = ec_key_get_libctx(key);
-    const char *propq = ec_key_get0_propq(key);
+    OSSL_LIB_CTX *libctx = ossl_ec_key_get_libctx(key);
+    const char *propq = ossl_ec_key_get0_propq(key);
 
     if (md_size &lt; 0) {
         ERR_raise(ERR_LIB_SM2, SM2_R_INVALID_DIGEST);
@@ -169,7 +169,7 @@ static BIGNUM *sm2_compute_msg_hash(const EVP_MD *digest,
         goto done;
     }
 
-    if (!sm2_compute_z_digest(z, fetched_digest, id, id_len, key)) {
+    if (!ossl_sm2_compute_z_digest(z, fetched_digest, id, id_len, key)) {
         /* SM2err already called */
         goto done;
     }
@@ -208,7 +208,7 @@ static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)
     BIGNUM *s = NULL;
     BIGNUM *x1 = NULL;
     BIGNUM *tmp = NULL;
-    OSSL_LIB_CTX *libctx = ec_key_get_libctx(key);
+    OSSL_LIB_CTX *libctx = ossl_ec_key_get_libctx(key);
 
     kG = EC_POINT_new(group);
     ctx = BN_CTX_new_ex(libctx);
@@ -266,7 +266,7 @@ static ECDSA_SIG *sm2_sig_gen(const EC_KEY *key, const BIGNUM *e)
             continue;
 
         if (!BN_add(s, dA, BN_value_one())
-                || !ec_group_do_inverse_ord(group, s, s, ctx)
+                || !ossl_ec_group_do_inverse_ord(group, s, s, ctx)
                 || !BN_mod_mul(tmp, dA, r, order, ctx)
                 || !BN_sub(tmp, k, tmp)
                 || !BN_mod_mul(s, s, tmp, order, ctx)) {
@@ -308,7 +308,7 @@ static int sm2_sig_verify(const EC_KEY *key, const ECDSA_SIG *sig,
     BIGNUM *x1 = NULL;
     const BIGNUM *r = NULL;
     const BIGNUM *s = NULL;
-    OSSL_LIB_CTX *libctx = ec_key_get_libctx(key);
+    OSSL_LIB_CTX *libctx = ossl_ec_key_get_libctx(key);
 
     ctx = BN_CTX_new_ex(libctx);
     pt = EC_POINT_new(group);
@@ -375,11 +375,11 @@ static int sm2_sig_verify(const EC_KEY *key, const ECDSA_SIG *sig,
     return ret;
 }
 
-ECDSA_SIG *sm2_do_sign(const EC_KEY *key,
-                       const EVP_MD *digest,
-                       const uint8_t *id,
-                       const size_t id_len,
-                       const uint8_t *msg, size_t msg_len)
+ECDSA_SIG *ossl_sm2_do_sign(const EC_KEY *key,
+                            const EVP_MD *digest,
+                            const uint8_t *id,
+                            const size_t id_len,
+                            const uint8_t *msg, size_t msg_len)
 {
     BIGNUM *e = NULL;
     ECDSA_SIG *sig = NULL;
@@ -397,12 +397,12 @@ ECDSA_SIG *sm2_do_sign(const EC_KEY *key,
     return sig;
 }
 
-int sm2_do_verify(const EC_KEY *key,
-                  const EVP_MD *digest,
-                  const ECDSA_SIG *sig,
-                  const uint8_t *id,
-                  const size_t id_len,
-                  const uint8_t *msg, size_t msg_len)
+int ossl_sm2_do_verify(const EC_KEY *key,
+                       const EVP_MD *digest,
+                       const ECDSA_SIG *sig,
+                       const uint8_t *id,
+                       const size_t id_len,
+                       const uint8_t *msg, size_t msg_len)
 {
     BIGNUM *e = NULL;
     int ret = 0;
@@ -420,8 +420,9 @@ int sm2_do_verify(const EC_KEY *key,
     return ret;
 }
 
-int sm2_internal_sign(const unsigned char *dgst, int dgstlen,
-                      unsigned char *sig, unsigned int *siglen, EC_KEY *eckey)
+int ossl_sm2_internal_sign(const unsigned char *dgst, int dgstlen,
+                           unsigned char *sig, unsigned int *siglen,
+                           EC_KEY *eckey)
 {
     BIGNUM *e = NULL;
     ECDSA_SIG *s = NULL;
@@ -455,8 +456,9 @@ int sm2_internal_sign(const unsigned char *dgst, int dgstlen,
     return ret;
 }
 
-int sm2_internal_verify(const unsigned char *dgst, int dgstlen,
-                        const unsigned char *sig, int sig_len, EC_KEY *eckey)
+int ossl_sm2_internal_verify(const unsigned char *dgst, int dgstlen,
+                             const unsigned char *sig, int sig_len,
+                             EC_KEY *eckey)
 {
     ECDSA_SIG *s = NULL;
     BIGNUM *e = NULL;
diff --git a/include/crypto/dh.h b/include/crypto/dh.h
index eca2a03056..d8b597a0f1 100644
--- a/include/crypto/dh.h
+++ b/include/crypto/dh.h
@@ -16,40 +16,41 @@
 # include &lt;openssl/dh.h&gt;
 # include &quot;internal/ffc.h&quot;
 
-DH *dh_new_by_nid_ex(OSSL_LIB_CTX *libctx, int nid);
-DH *dh_new_ex(OSSL_LIB_CTX *libctx);
+DH *ossl_dh_new_by_nid_ex(OSSL_LIB_CTX *libctx, int nid);
+DH *ossl_dh_new_ex(OSSL_LIB_CTX *libctx);
 void ossl_dh_set0_libctx(DH *d, OSSL_LIB_CTX *libctx);
-
-int dh_generate_ffc_parameters(DH *dh, int type, int pbits, int qbits,
-                               BN_GENCB *cb);
-int dh_generate_public_key(BN_CTX *ctx, const DH *dh, const BIGNUM *priv_key,
-                           BIGNUM *pub_key);
-int dh_get_named_group_uid_from_size(int pbits);
-const char *dh_gen_type_id2name(int id);
-int dh_gen_type_name2id(const char *name);
-void dh_cache_named_group(DH *dh);
+int ossl_dh_generate_ffc_parameters(DH *dh, int type, int pbits, int qbits,
+                                    BN_GENCB *cb);
+int ossl_dh_generate_public_key(BN_CTX *ctx, const DH *dh,
+                                const BIGNUM *priv_key, BIGNUM *pub_key);
+int ossl_dh_get_named_group_uid_from_size(int pbits);
+const char *ossl_dh_gen_type_id2name(int id);
+int ossl_dh_gen_type_name2id(const char *name);
+void ossl_dh_cache_named_group(DH *dh);
 int ossl_dh_is_named_safe_prime_group(const DH *dh);
 
-FFC_PARAMS *dh_get0_params(DH *dh);
-int dh_get0_nid(const DH *dh);
-int dh_params_fromdata(DH *dh, const OSSL_PARAM params[]);
-int dh_key_fromdata(DH *dh, const OSSL_PARAM params[]);
-int dh_params_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[]);
-int dh_key_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[]);
-
-int dh_check_pub_key_partial(const DH *dh, const BIGNUM *pub_key, int *ret);
-int dh_check_priv_key(const DH *dh, const BIGNUM *priv_key, int *ret);
-int dh_check_pairwise(const DH *dh);
-
-const DH_METHOD *dh_get_method(const DH *dh);
-
-int dh_buf2key(DH *key, const unsigned char *buf, size_t len);
-size_t dh_key2buf(const DH *dh, unsigned char **pbuf, size_t size, int alloc);
-
-int dh_KDF_X9_42_asn1(unsigned char *out, size_t outlen,
-                      const unsigned char *Z, size_t Zlen,
-                      const char *cek_alg,
-                      const unsigned char *ukm, size_t ukmlen, const EVP_MD *md,
-                      OSSL_LIB_CTX *libctx, const char *propq);
+FFC_PARAMS *ossl_dh_get0_params(DH *dh);
+int ossl_dh_get0_nid(const DH *dh);
+int ossl_dh_params_fromdata(DH *dh, const OSSL_PARAM params[]);
+int ossl_dh_key_fromdata(DH *dh, const OSSL_PARAM params[]);
+int ossl_dh_params_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[]);
+int ossl_dh_key_todata(DH *dh, OSSL_PARAM_BLD *bld, OSSL_PARAM params[]);
+
+int ossl_dh_check_pub_key_partial(const DH *dh, const BIGNUM *pub_key, int *ret);
+int ossl_dh_check_priv_key(const DH *dh, const BIGNUM *priv_key, int *ret);
+int ossl_dh_check_pairwise(const DH *dh);
+
+const DH_METHOD *ossl_dh_get_method(const DH *dh);
+
+int ossl_dh_buf2key(DH *key, const unsigned char *buf, size_t len);
+size_t ossl_dh_key2buf(const DH *dh, unsigned char **pbuf, size_t size,
+                       int alloc);
+
+int ossl_dh_kdf_X9_42_asn1(unsigned char *out, size_t outlen,
+                           const unsigned char *Z, size_t Zlen,
+                           const char *cek_alg,
+                           const unsigned char *ukm, size_t ukmlen,
+                           const EVP_MD *md,
+                           OSSL_LIB_CTX *libctx, const char *propq);
 
 #endif  /* OSSL_CRYPTO_DH_H */
diff --git a/include/crypto/dsa.h b/include/crypto/dsa.h
index a47fbcd841..331baf320e 100644
--- a/include/crypto/dsa.h
+++ b/include/crypto/dsa.h
@@ -18,25 +18,26 @@
 #define DSA_PARAMGEN_TYPE_FIPS_186_4   0   /* Use FIPS186-4 standard */
 #define DSA_PARAMGEN_TYPE_FIPS_186_2   1   /* Use legacy FIPS186-2 standard */
 
-DSA *dsa_new_with_ctx(OSSL_LIB_CTX *libctx);
+DSA *ossl_dsa_new(OSSL_LIB_CTX *libctx);
 void ossl_dsa_set0_libctx(DSA *d, OSSL_LIB_CTX *libctx);
 
-int dsa_generate_ffc_parameters(DSA *dsa, int type, int pbits, int qbits,
-                                BN_GENCB *cb);
+int ossl_dsa_generate_ffc_parameters(DSA *dsa, int type, int pbits, int qbits,
+                                     BN_GENCB *cb);
 
-int dsa_sign_int(int type, const unsigned char *dgst,
-                 int dlen, unsigned char *sig, unsigned int *siglen, DSA *dsa);
+int ossl_dsa_sign_int(int type, const unsigned char *dgst, int dlen,
+                      unsigned char *sig, unsigned int *siglen, DSA *dsa);
 
-FFC_PARAMS *dsa_get0_params(DSA *dsa);
-int dsa_ffc_params_fromdata(DSA *dsa, const OSSL_PARAM params[]);
-int dsa_key_fromdata(DSA *dsa, const OSSL_PARAM params[]);
+FFC_PARAMS *ossl_dsa_get0_params(DSA *dsa);
+int ossl_dsa_ffc_params_fromdata(DSA *dsa, const OSSL_PARAM params[]);
+int ossl_dsa_key_fromdata(DSA *dsa, const OSSL_PARAM params[]);
 
-int dsa_generate_public_key(BN_CTX *ctx, const DSA *dsa, const BIGNUM *priv_key,
-                            BIGNUM *pub_key);
-int dsa_check_params(const DSA *dsa, int checktype, int *ret);
-int dsa_check_pub_key(const DSA *dsa, const BIGNUM *pub_key, int *ret);
-int dsa_check_pub_key_partial(const DSA *dsa, const BIGNUM *pub_key, int *ret);
-int dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret);
-int dsa_check_pairwise(const DSA *dsa);
+int ossl_dsa_generate_public_key(BN_CTX *ctx, const DSA *dsa,
+                                 const BIGNUM *priv_key, BIGNUM *pub_key);
+int ossl_dsa_check_params(const DSA *dsa, int checktype, int *ret);
+int ossl_dsa_check_pub_key(const DSA *dsa, const BIGNUM *pub_key, int *ret);
+int ossl_dsa_check_pub_key_partial(const DSA *dsa, const BIGNUM *pub_key,
+                                   int *ret);
+int ossl_dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret);
+int ossl_dsa_check_pairwise(const DSA *dsa);
 
 #endif
diff --git a/include/crypto/ec.h b/include/crypto/ec.h
index 347474a37b..a3d87e9d1a 100644
--- a/include/crypto/ec.h
+++ b/include/crypto/ec.h
@@ -16,10 +16,10 @@
 # include &lt;openssl/opensslconf.h&gt;
 # include &lt;openssl/evp.h&gt;
 
-const char *ec_curve_nid2name(int nid);
-int ec_curve_name2nid(const char *name);
-const char *ec_curve_nid2nist_int(int nid);
-int ec_curve_nist2nid_int(const char *name);
+const char *ossl_ec_curve_nid2name(int nid);
+int ossl_ec_curve_name2nid(const char *name);
+const char *ossl_ec_curve_nid2nist_int(int nid);
+int ossl_ec_curve_nist2nid_int(const char *name);
 int evp_pkey_ctx_set_ec_param_enc_prov(EVP_PKEY_CTX *ctx, int param_enc);
 
 # ifndef OPENSSL_NO_EC
@@ -48,43 +48,45 @@ int evp_pkey_ctx_set_ec_param_enc_prov(EVP_PKEY_CTX *ctx, int param_enc);
  * reduction round on the input can be omitted by the underlying
  * implementations for better SCA properties on regular input values).
  */
-__owur int ec_group_do_inverse_ord(const EC_GROUP *group, BIGNUM *res,
-                                   const BIGNUM *x, BN_CTX *ctx);
+__owur int ossl_ec_group_do_inverse_ord(const EC_GROUP *group, BIGNUM *res,
+                                        const BIGNUM *x, BN_CTX *ctx);
 
 /*-
  * ECDH Key Derivation Function as defined in ANSI X9.63
  */
-int ecdh_KDF_X9_63(unsigned char *out, size_t outlen,
-                   const unsigned char *Z, size_t Zlen,
-                   const unsigned char *sinfo, size_t sinfolen,
-                   const EVP_MD *md, OSSL_LIB_CTX *libctx, const char *propq);
+int ossl_ecdh_kdf_X9_63(unsigned char *out, size_t outlen,
+                        const unsigned char *Z, size_t Zlen,
+                        const unsigned char *sinfo, size_t sinfolen,
+                        const EVP_MD *md, OSSL_LIB_CTX *libctx,
+                        const char *propq);
 
-int ec_key_public_check(const EC_KEY *eckey, BN_CTX *ctx);
-int ec_key_public_check_quick(const EC_KEY *eckey, BN_CTX *ctx);
-int ec_key_private_check(const EC_KEY *eckey);
-int ec_key_pairwise_check(const EC_KEY *eckey, BN_CTX *ctx);
-OSSL_LIB_CTX *ec_key_get_libctx(const EC_KEY *eckey);
-const char *ec_key_get0_propq(const EC_KEY *eckey);
-void ec_key_set0_libctx(EC_KEY *key, OSSL_LIB_CTX *libctx);
+int ossl_ec_key_public_check(const EC_KEY *eckey, BN_CTX *ctx);
+int ossl_ec_key_public_check_quick(const EC_KEY *eckey, BN_CTX *ctx);
+int ossl_ec_key_private_check(const EC_KEY *eckey);
+int ossl_ec_key_pairwise_check(const EC_KEY *eckey, BN_CTX *ctx);
+OSSL_LIB_CTX *ossl_ec_key_get_libctx(const EC_KEY *eckey);
+const char *ossl_ec_key_get0_propq(const EC_KEY *eckey);
+void ossl_ec_key_set0_libctx(EC_KEY *key, OSSL_LIB_CTX *libctx);
 
 /* Backend support */
-int ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
-                    OSSL_PARAM params[], OSSL_LIB_CTX *libctx,
-                    const char *propq,
-                    BN_CTX *bnctx, unsigned char **genbuf);
-int ec_group_fromdata(EC_KEY *ec, const OSSL_PARAM params[]);
-int ec_group_set_params(EC_GROUP *group, const OSSL_PARAM params[]);
-int ec_key_fromdata(EC_KEY *ecx, const OSSL_PARAM params[], int include_private);
-int ec_key_otherparams_fromdata(EC_KEY *ec, const OSSL_PARAM params[]);
-int ec_set_ecdh_cofactor_mode(EC_KEY *ec, int mode);
-int ec_encoding_name2id(const char *name);
-int ec_encoding_param2id(const OSSL_PARAM *p, int *id);
-int ec_pt_format_name2id(const char *name);
-int ec_pt_format_param2id(const OSSL_PARAM *p, int *id);
-char *ec_pt_format_id2name(int id);
+int ossl_ec_group_todata(const EC_GROUP *group, OSSL_PARAM_BLD *tmpl,
+                         OSSL_PARAM params[], OSSL_LIB_CTX *libctx,
+                         const char *propq,
+                         BN_CTX *bnctx, unsigned char **genbuf);
+int ossl_ec_group_fromdata(EC_KEY *ec, const OSSL_PARAM params[]);
+int ossl_ec_group_set_params(EC_GROUP *group, const OSSL_PARAM params[]);
+int ossl_ec_key_fromdata(EC_KEY *ecx, const OSSL_PARAM params[],
+                         int include_private);
+int ossl_ec_key_otherparams_fromdata(EC_KEY *ec, const OSSL_PARAM params[]);
+int ossl_ec_set_ecdh_cofactor_mode(EC_KEY *ec, int mode);
+int ossl_ec_encoding_name2id(const char *name);
+int ossl_ec_encoding_param2id(const OSSL_PARAM *p, int *id);
+int ossl_ec_pt_format_name2id(const char *name);
+int ossl_ec_pt_format_param2id(const OSSL_PARAM *p, int *id);
+char *ossl_ec_pt_format_id2name(int id);
 
-char *ec_check_group_type_id2name(int flags);
-int ec_set_check_group_type_from_name(EC_KEY *ec, const char *name);
+char *ossl_ec_check_group_type_id2name(int flags);
+int ossl_ec_set_check_group_type_from_name(EC_KEY *ec, const char *name);
 
 # endif /* OPENSSL_NO_EC */
 #endif
diff --git a/include/crypto/ecx.h b/include/crypto/ecx.h
index 678cfcccea..af03d32587 100644
--- a/include/crypto/ecx.h
+++ b/include/crypto/ecx.h
@@ -76,13 +76,12 @@ struct ecx_key_st {
 
 typedef struct ecx_key_st ECX_KEY;
 
-size_t ecx_key_length(ECX_KEY_TYPE type);
-ECX_KEY *ecx_key_new(OSSL_LIB_CTX *libctx, ECX_KEY_TYPE type, int haspubkey,
-                     const char *propq);
-void ecx_key_set0_libctx(ECX_KEY *key, OSSL_LIB_CTX *libctx);
-unsigned char *ecx_key_allocate_privkey(ECX_KEY *key);
-void ecx_key_free(ECX_KEY *key);
-int ecx_key_up_ref(ECX_KEY *key);
+ECX_KEY *ossl_ecx_key_new(OSSL_LIB_CTX *libctx, ECX_KEY_TYPE type,
+                          int haspubkey, const char *propq);
+void ossl_ecx_key_set0_libctx(ECX_KEY *key, OSSL_LIB_CTX *libctx);
+unsigned char *ossl_ecx_key_allocate_privkey(ECX_KEY *key);
+void ossl_ecx_key_free(ECX_KEY *key);
+int ossl_ecx_key_up_ref(ECX_KEY *key);
 
 int X25519(uint8_t out_shared_key[32], const uint8_t private_key[32],
            const uint8_t peer_public_value[32]);
@@ -116,13 +115,13 @@ void X448_public_from_private(uint8_t out_public_value[56],
 
 
 /* Backend support */
-int ecx_public_from_private(ECX_KEY *key);
-int ecx_key_fromdata(ECX_KEY *ecx, const OSSL_PARAM params[],
-                     int include_private);
-
-ECX_KEY *evp_pkey_get1_X25519(EVP_PKEY *pkey);
-ECX_KEY *evp_pkey_get1_X448(EVP_PKEY *pkey);
-ECX_KEY *evp_pkey_get1_ED25519(EVP_PKEY *pkey);
-ECX_KEY *evp_pkey_get1_ED448(EVP_PKEY *pkey);
+int ossl_ecx_public_from_private(ECX_KEY *key);
+int ossl_ecx_key_fromdata(ECX_KEY *ecx, const OSSL_PARAM params[],
+                          int include_private);
+
+ECX_KEY *ossl_evp_pkey_get1_X25519(EVP_PKEY *pkey);
+ECX_KEY *ossl_evp_pkey_get1_X448(EVP_PKEY *pkey);
+ECX_KEY *ossl_evp_pkey_get1_ED25519(EVP_PKEY *pkey);
+ECX_KEY *ossl_evp_pkey_get1_ED448(EVP_PKEY *pkey);
 # endif /* OPENSSL_NO_EC */
 #endif
diff --git a/include/crypto/evp.h b/include/crypto/evp.h
index 0ed9a02396..9115f47c1f 100644
--- a/include/crypto/evp.h
+++ b/include/crypto/evp.h
@@ -179,14 +179,14 @@ DEFINE_STACK_OF_CONST(EVP_PKEY_METHOD)
 
 void evp_pkey_set_cb_translate(BN_GENCB *cb, EVP_PKEY_CTX *ctx);
 
-const EVP_PKEY_METHOD *dh_pkey_method(void);
-const EVP_PKEY_METHOD *dhx_pkey_method(void);
-const EVP_PKEY_METHOD *dsa_pkey_method(void);
-const EVP_PKEY_METHOD *ec_pkey_method(void);
-const EVP_PKEY_METHOD *ecx25519_pkey_method(void);
-const EVP_PKEY_METHOD *ecx448_pkey_method(void);
-const EVP_PKEY_METHOD *ed25519_pkey_method(void);
-const EVP_PKEY_METHOD *ed448_pkey_method(void);
+const EVP_PKEY_METHOD *ossl_dh_pkey_method(void);
+const EVP_PKEY_METHOD *ossl_dhx_pkey_method(void);
+const EVP_PKEY_METHOD *ossl_dsa_pkey_method(void);
+const EVP_PKEY_METHOD *ossl_ec_pkey_method(void);
+const EVP_PKEY_METHOD *ossl_ecx25519_pkey_method(void);
+const EVP_PKEY_METHOD *ossl_ecx448_pkey_method(void);
+const EVP_PKEY_METHOD *ossl_ed25519_pkey_method(void);
+const EVP_PKEY_METHOD *ossl_ed448_pkey_method(void);
 const EVP_PKEY_METHOD *ossl_rsa_pkey_method(void);
 const EVP_PKEY_METHOD *ossl_rsa_pss_pkey_method(void);
 
diff --git a/include/crypto/sm2.h b/include/crypto/sm2.h
index 2bd0af03d6..e3278a31e6 100644
--- a/include/crypto/sm2.h
+++ b/include/crypto/sm2.h
@@ -20,65 +20,67 @@
 #  include &lt;openssl/ec.h&gt;
 #  include &quot;crypto/types.h&quot;
 
-int sm2_key_private_check(const EC_KEY *eckey);
+int ossl_sm2_key_private_check(const EC_KEY *eckey);
 
 /* The default user id as specified in GM/T 0009-2012 */
 #  define SM2_DEFAULT_USERID &quot;1234567812345678&quot;
 
-int sm2_compute_z_digest(uint8_t *out,
-                         const EVP_MD *digest,
-                         const uint8_t *id,
-                         const size_t id_len,
-                         const EC_KEY *key);
+int ossl_sm2_compute_z_digest(uint8_t *out,
+                              const EVP_MD *digest,
+                              const uint8_t *id,
+                              const size_t id_len,
+                              const EC_KEY *key);
 
 /*
  * SM2 signature operation. Computes Z and then signs H(Z || msg) using SM2
  */
-ECDSA_SIG *sm2_do_sign(const EC_KEY *key,
+ECDSA_SIG *ossl_sm2_do_sign(const EC_KEY *key,
+                            const EVP_MD *digest,
+                            const uint8_t *id,
+                            const size_t id_len,
+                            const uint8_t *msg, size_t msg_len);
+
+int ossl_sm2_do_verify(const EC_KEY *key,
                        const EVP_MD *digest,
+                       const ECDSA_SIG *signature,
                        const uint8_t *id,
                        const size_t id_len,
                        const uint8_t *msg, size_t msg_len);
 
-int sm2_do_verify(const EC_KEY *key,
-                  const EVP_MD *digest,
-                  const ECDSA_SIG *signature,
-                  const uint8_t *id,
-                  const size_t id_len,
-                  const uint8_t *msg, size_t msg_len);
-
 /*
  * SM2 signature generation.
  */
-int sm2_internal_sign(const unsigned char *dgst, int dgstlen,
-                      unsigned char *sig, unsigned int *siglen, EC_KEY *eckey);
+int ossl_sm2_internal_sign(const unsigned char *dgst, int dgstlen,
+                           unsigned char *sig, unsigned int *siglen,
+                           EC_KEY *eckey);
 
 /*
  * SM2 signature verification.
  */
-int sm2_internal_verify(const unsigned char *dgst, int dgstlen,
-                        const unsigned char *sig, int siglen, EC_KEY *eckey);
+int ossl_sm2_internal_verify(const unsigned char *dgst, int dgstlen,
+                             const unsigned char *sig, int siglen,
+                             EC_KEY *eckey);
 
 /*
  * SM2 encryption
  */
-int sm2_ciphertext_size(const EC_KEY *key, const EVP_MD *digest, size_t msg_len,
-                        size_t *ct_size);
+int ossl_sm2_ciphertext_size(const EC_KEY *key, const EVP_MD *digest,
+                             size_t msg_len, size_t *ct_size);
 
-int sm2_plaintext_size(const EC_KEY *key, const EVP_MD *digest, size_t msg_len,
-                       size_t *pt_size);
+int ossl_sm2_plaintext_size(const EC_KEY *key, const EVP_MD *digest,
+                            size_t msg_len, size_t *pt_size);
 
-int sm2_encrypt(const EC_KEY *key,
-                const EVP_MD *digest,
-                const uint8_t *msg,
-                size_t msg_len,
-                uint8_t *ciphertext_buf, size_t *ciphertext_len);
+int ossl_sm2_encrypt(const EC_KEY *key,
+                     const EVP_MD *digest,
+                     const uint8_t *msg, size_t msg_len,
+                     uint8_t *ciphertext_buf, size_t *ciphertext_len);
 
-int sm2_decrypt(const EC_KEY *key,
-                const EVP_MD *digest,
-                const uint8_t *ciphertext,
-                size_t ciphertext_len, uint8_t *ptext_buf, size_t *ptext_len);
+int ossl_sm2_decrypt(const EC_KEY *key,
+                     const EVP_MD *digest,
+                     const uint8_t *ciphertext, size_t ciphertext_len,
+                     uint8_t *ptext_buf, size_t *ptext_len);
 
-const unsigned char *sm2_algorithmidentifier_encoding(int md_nid, size_t *len);
+const unsigned char *ossl_sm2_algorithmidentifier_encoding(int md_nid,
+                                                           size_t *len);
 # endif /* OPENSSL_NO_SM2 */
 #endif
diff --git a/providers/implementations/asymciphers/sm2_enc.c b/providers/implementations/asymciphers/sm2_enc.c
index 923ee5694a..0068e504e2 100644
--- a/providers/implementations/asymciphers/sm2_enc.c
+++ b/providers/implementations/asymciphers/sm2_enc.c
@@ -89,14 +89,14 @@ static int sm2_asym_encrypt(void *vpsm2ctx, unsigned char *out, size_t *outlen,
         return 0;
 
     if (out == NULL) {
-        if (!sm2_ciphertext_size(psm2ctx-&gt;key, md, inlen, outlen)) {
+        if (!ossl_sm2_ciphertext_size(psm2ctx-&gt;key, md, inlen, outlen)) {
             ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_KEY);
             return 0;
         }
         return 1;
     }
 
-    return sm2_encrypt(psm2ctx-&gt;key, md, in, inlen, out, outlen);
+    return ossl_sm2_encrypt(psm2ctx-&gt;key, md, in, inlen, out, outlen);
 }
 
 static int sm2_asym_decrypt(void *vpsm2ctx, unsigned char *out, size_t *outlen,
@@ -110,12 +110,12 @@ static int sm2_asym_decrypt(void *vpsm2ctx, unsigned char *out, size_t *outlen,
         return 0;
 
     if (out == NULL) {
-        if (!sm2_plaintext_size(psm2ctx-&gt;key, md, inlen, outlen))
+        if (!ossl_sm2_plaintext_size(psm2ctx-&gt;key, md, inlen, outlen))
             return 0;
         return 1;
     }
 
-    return sm2_decrypt(psm2ctx-&gt;key, md, in, inlen, out, outlen);
+    return ossl_sm2_decrypt(psm2ctx-&gt;key, md, in, inlen, out, outlen);
 }
 
 static void sm2_freectx(void *vpsm2ctx)
diff --git a/providers/implementations/encode_decode/decode_der2key.c b/providers/implementations/encode_decode/decode_der2key.c
index 5073e660cd..fed30bf952 100644
--- a/providers/implementations/encode_decode/decode_der2key.c
+++ b/providers/implementations/encode_decode/decode_der2key.c
@@ -462,7 +462,7 @@ static void dsa_adjust(void *key, struct der2key_ctx_st *ctx)
 
 static void ec_adjust(void *key, struct der2key_ctx_st *ctx)
 {
-    ec_key_set0_libctx(key, PROV_LIBCTX_OF(ctx-&gt;provctx));
+    ossl_ec_key_set0_libctx(key, PROV_LIBCTX_OF(ctx-&gt;provctx));
 }
 
 /*
@@ -472,39 +472,39 @@ static void ec_adjust(void *key, struct der2key_ctx_st *ctx)
 
 static void ecx_key_adjust(void *key, struct der2key_ctx_st *ctx)
 {
-    ecx_key_set0_libctx(key, PROV_LIBCTX_OF(ctx-&gt;provctx));
+    ossl_ecx_key_set0_libctx(key, PROV_LIBCTX_OF(ctx-&gt;provctx));
 }
 
 # define ed25519_evp_type               EVP_PKEY_ED25519
-# define ed25519_evp_extract            (extract_key_fn *)evp_pkey_get1_ED25519
+# define ed25519_evp_extract            (extract_key_fn *)ossl_evp_pkey_get1_ED25519
 # define ed25519_d2i_private_key        NULL
 # define ed25519_d2i_public_key         NULL
 # define ed25519_d2i_key_params         NULL
-# define ed25519_free                   (free_key_fn *)ecx_key_free
+# define ed25519_free                   (free_key_fn *)ossl_ecx_key_free
 # define ed25519_adjust                 ecx_key_adjust
 
 # define ed448_evp_type                 EVP_PKEY_ED448
-# define ed448_evp_extract              (extract_key_fn *)evp_pkey_get1_ED448
+# define ed448_evp_extract              (extract_key_fn *)ossl_evp_pkey_get1_ED448
 # define ed448_d2i_private_key          NULL
 # define ed448_d2i_public_key           NULL
 # define ed448_d2i_key_params           NULL
-# define ed448_free                     (free_key_fn *)ecx_key_free
+# define ed448_free                     (free_key_fn *)ossl_ecx_key_free
 # define ed448_adjust                   ecx_key_adjust
 
 # define x25519_evp_type                EVP_PKEY_X25519
-# define x25519_evp_extract             (extract_key_fn *)evp_pkey_get1_X25519
+# define x25519_evp_extract             (extract_key_fn *)ossl_evp_pkey_get1_X25519
 # define x25519_d2i_private_key         NULL
 # define x25519_d2i_public_key          NULL
 # define x25519_d2i_key_params          NULL
-# define x25519_free                    (free_key_fn *)ecx_key_free
+# define x25519_free                    (free_key_fn *)ossl_ecx_key_free
 # define x25519_adjust                  ecx_key_adjust
 
 # define x448_evp_type                  EVP_PKEY_X448
-# define x448_evp_extract               (extract_key_fn *)evp_pkey_get1_X448
+# define x448_evp_extract               (extract_key_fn *)ossl_evp_pkey_get1_X448
 # define x448_d2i_private_key           NULL
 # define x448_d2i_public_key            NULL
 # define x448_d2i_key_params            NULL
-# define x448_free                      (free_key_fn *)ecx_key_free
+# define x448_free                      (free_key_fn *)ossl_ecx_key_free
 # define x448_adjust                    ecx_key_adjust
 
 # ifndef OPENSSL_NO_SM2
diff --git a/providers/implementations/encode_decode/encode_key2text.c b/providers/implementations/encode_decode/encode_key2text.c
index 8be3478102..2c6c5d70db 100644
--- a/providers/implementations/encode_decode/encode_key2text.c
+++ b/providers/implementations/encode_decode/encode_key2text.c
@@ -23,9 +23,9 @@
 #include &lt;openssl/proverr.h&gt;
 #include &quot;internal/ffc.h&quot;
 #include &quot;crypto/bn.h&quot;           /* bn_get_words() */
-#include &quot;crypto/dh.h&quot;           /* dh_get0_params() */
-#include &quot;crypto/dsa.h&quot;          /* dsa_get0_params() */
-#include &quot;crypto/ec.h&quot;           /* ec_key_get_libctx */
+#include &quot;crypto/dh.h&quot;           /* ossl_dh_get0_params() */
+#include &quot;crypto/dsa.h&quot;          /* ossl_dsa_get0_params() */
+#include &quot;crypto/ec.h&quot;           /* ossl_ec_key_get_libctx */
 #include &quot;crypto/ecx.h&quot;          /* ECX_KEY, etc... */
 #include &quot;crypto/rsa.h&quot;          /* RSA_PSS_PARAMS_30, etc... */
 #include &quot;prov/bio.h&quot;
@@ -245,7 +245,7 @@ static int dh_to_text(BIO *out, const void *key, int selection)
         }
     }
     if ((selection &amp; OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS) != 0) {
-        params = dh_get0_params((DH *)dh);
+        params = ossl_dh_get0_params((DH *)dh);
         if (params == NULL) {
             ERR_raise(ERR_LIB_PROV, PROV_R_NOT_PARAMETERS);
             return 0;
@@ -315,7 +315,7 @@ static int dsa_to_text(BIO *out, const void *key, int selection)
         }
     }
     if ((selection &amp; OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS) != 0) {
-        params = dsa_get0_params((DSA *)dsa);
+        params = ossl_dsa_get0_params((DSA *)dsa);
         if (params == NULL) {
             ERR_raise(ERR_LIB_PROV, PROV_R_NOT_PARAMETERS);
             return 0;
@@ -539,7 +539,7 @@ static int ec_to_text(BIO *out, const void *key, int selection)
         &amp;&amp; !print_labeled_buf(out, &quot;pub:&quot;, pub, pub_len))
         goto err;
     if ((selection &amp; OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS) != 0)
-        ret = ec_param_to_text(out, group, ec_key_get_libctx(ec));
+        ret = ec_param_to_text(out, group, ossl_ec_key_get_libctx(ec));
 err:
     OPENSSL_clear_free(priv, priv_len);
     OPENSSL_free(pub);
diff --git a/providers/implementations/exchange/dh_exch.c b/providers/implementations/exchange/dh_exch.c
index 32ce2ee0ed..2638675da5 100644
--- a/providers/implementations/exchange/dh_exch.c
+++ b/providers/implementations/exchange/dh_exch.c
@@ -180,13 +180,13 @@ static int dh_X9_42_kdf_derive(void *vpdhctx, unsigned char *secret,
 
     /* Do KDF stuff */
     if (pdhctx-&gt;kdf_type == PROV_DH_KDF_X9_42_ASN1) {
-        if (!dh_KDF_X9_42_asn1(secret, pdhctx-&gt;kdf_outlen,
-                               stmp, stmplen,
-                               pdhctx-&gt;kdf_cekalg,
-                               pdhctx-&gt;kdf_ukm,
-                               pdhctx-&gt;kdf_ukmlen,
-                               pdhctx-&gt;kdf_md,
-                               pdhctx-&gt;libctx, NULL))
+        if (!ossl_dh_kdf_X9_42_asn1(secret, pdhctx-&gt;kdf_outlen,
+                                    stmp, stmplen,
+                                    pdhctx-&gt;kdf_cekalg,
+                                    pdhctx-&gt;kdf_ukm,
+                                    pdhctx-&gt;kdf_ukmlen,
+                                    pdhctx-&gt;kdf_md,
+                                    pdhctx-&gt;libctx, NULL))
             goto err;
     }
     *secretlen = pdhctx-&gt;kdf_outlen;
diff --git a/providers/implementations/exchange/ecdh_exch.c b/providers/implementations/exchange/ecdh_exch.c
index 8d3f748f9b..6c24643255 100644
--- a/providers/implementations/exchange/ecdh_exch.c
+++ b/providers/implementations/exchange/ecdh_exch.c
@@ -25,7 +25,7 @@
 #include &quot;prov/providercommon.h&quot;
 #include &quot;prov/implementations.h&quot;
 #include &quot;prov/securitycheck.h&quot;
-#include &quot;crypto/ec.h&quot; /* ecdh_KDF_X9_63() */
+#include &quot;crypto/ec.h&quot; /* ossl_ecdh_kdf_X9_63() */
 
 static OSSL_FUNC_keyexch_newctx_fn ecdh_newctx;
 static OSSL_FUNC_keyexch_init_fn ecdh_init;
@@ -498,12 +498,12 @@ int ecdh_X9_63_kdf_derive(void *vpecdhctx, unsigned char *secret,
         goto err;
 
     /* Do KDF stuff */
-    if (!ecdh_KDF_X9_63(secret, pecdhctx-&gt;kdf_outlen,
-                        stmp, stmplen,
-                        pecdhctx-&gt;kdf_ukm,
-                        pecdhctx-&gt;kdf_ukmlen,
-                        pecdhctx-&gt;kdf_md,
-                        pecdhctx-&gt;libctx, NULL))
+    if (!ossl_ecdh_kdf_X9_63(secret, pecdhctx-&gt;kdf_outlen,
+                             stmp, stmplen,
+                             pecdhctx-&gt;kdf_ukm,
+                             pecdhctx-&gt;kdf_ukmlen,
+                             pecdhctx-&gt;kdf_md,
+                             pecdhctx-&gt;libctx, NULL))
         goto err;
     *psecretlen = pecdhctx-&gt;kdf_outlen;
     ret = 1;
diff --git a/providers/implementations/exchange/ecx_exch.c b/providers/implementations/exchange/ecx_exch.c
index 17118f0e6c..6d4471be3c 100644
--- a/providers/implementations/exchange/ecx_exch.c
+++ b/providers/implementations/exchange/ecx_exch.c
@@ -80,12 +80,12 @@ static int ecx_init(void *vecxctx, void *vkey)
     if (ecxctx == NULL
             || key == NULL
             || key-&gt;keylen != ecxctx-&gt;keylen
-            || !ecx_key_up_ref(key)) {
+            || !ossl_ecx_key_up_ref(key)) {
         ERR_raise(ERR_LIB_PROV, ERR_R_INTERNAL_ERROR);
         return 0;
     }
 
-    ecx_key_free(ecxctx-&gt;key);
+    ossl_ecx_key_free(ecxctx-&gt;key);
     ecxctx-&gt;key = key;
 
     return 1;
@@ -102,11 +102,11 @@ static int ecx_set_peer(void *vecxctx, void *vkey)
     if (ecxctx == NULL
             || key == NULL
             || key-&gt;keylen != ecxctx-&gt;keylen
-            || !ecx_key_up_ref(key)) {
+            || !ossl_ecx_key_up_ref(key)) {
         ERR_raise(ERR_LIB_PROV, ERR_R_INTERNAL_ERROR);
         return 0;
     }
-    ecx_key_free(ecxctx-&gt;peerkey);
+    ossl_ecx_key_free(ecxctx-&gt;peerkey);
     ecxctx-&gt;peerkey = key;
 
     return 1;
@@ -182,8 +182,8 @@ static void ecx_freectx(void *vecxctx)
 {
     PROV_ECX_CTX *ecxctx = (PROV_ECX_CTX *)vecxctx;
 
-    ecx_key_free(ecxctx-&gt;key);
-    ecx_key_free(ecxctx-&gt;peerkey);
+    ossl_ecx_key_free(ecxctx-&gt;key);
+    ossl_ecx_key_free(ecxctx-&gt;peerkey);
 
     OPENSSL_free(ecxctx);
 }
@@ -203,15 +203,15 @@ static void *ecx_dupctx(void *vecxctx)
     }
 
     *dstctx = *srcctx;
-    if (dstctx-&gt;key != NULL &amp;&amp; !ecx_key_up_ref(dstctx-&gt;key)) {
+    if (dstctx-&gt;key != NULL &amp;&amp; !ossl_ecx_key_up_ref(dstctx-&gt;key)) {
         ERR_raise(ERR_LIB_PROV, ERR_R_INTERNAL_ERROR);
         OPENSSL_free(dstctx);
         return NULL;
     }
 
-    if (dstctx-&gt;peerkey != NULL &amp;&amp; !ecx_key_up_ref(dstctx-&gt;peerkey)) {
+    if (dstctx-&gt;peerkey != NULL &amp;&amp; !ossl_ecx_key_up_ref(dstctx-&gt;peerkey)) {
         ERR_raise(ERR_LIB_PROV, ERR_R_INTERNAL_ERROR);
-        ecx_key_free(dstctx-&gt;key);
+        ossl_ecx_key_free(dstctx-&gt;key);
         OPENSSL_free(dstctx);
         return NULL;
     }
diff --git a/providers/implementations/keymgmt/dh_kmgmt.c b/providers/implementations/keymgmt/dh_kmgmt.c
index a967309644..9b1679e4fa 100644
--- a/providers/implementations/keymgmt/dh_kmgmt.c
+++ b/providers/implementations/keymgmt/dh_kmgmt.c
@@ -91,7 +91,7 @@ static int dh_gen_type_name2id_w_default(const char *name, int type)
 #endif
     }
 
-    return dh_gen_type_name2id(name);
+    return ossl_dh_gen_type_name2id(name);
 }
 
 static void *dh_newdata(void *provctx)
@@ -99,7 +99,7 @@ static void *dh_newdata(void *provctx)
     DH *dh = NULL;
 
     if (ossl_prov_is_running()) {
-        dh = dh_new_ex(PROV_LIBCTX_OF(provctx));
+        dh = ossl_dh_new_ex(PROV_LIBCTX_OF(provctx));
         if (dh != NULL) {
             DH_clear_flags(dh, DH_FLAG_TYPE_MASK);
             DH_set_flags(dh, DH_FLAG_TYPE_DH);
@@ -112,7 +112,7 @@ static void *dhx_newdata(void *provctx)
 {
     DH *dh = NULL;
 
-    dh = dh_new_ex(PROV_LIBCTX_OF(provctx));
+    dh = ossl_dh_new_ex(PROV_LIBCTX_OF(provctx));
     if (dh != NULL) {
         DH_clear_flags(dh, DH_FLAG_TYPE_MASK);
         DH_set_flags(dh, DH_FLAG_TYPE_DHX);
@@ -158,8 +158,8 @@ static int dh_match(const void *keydata1, const void *keydata2, int selection)
     if ((selection &amp; OSSL_KEYMGMT_SELECT_PRIVATE_KEY) != 0)
         ok = ok &amp;&amp; BN_cmp(DH_get0_priv_key(dh1), DH_get0_priv_key(dh2)) == 0;
     if ((selection &amp; OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS) != 0) {
-        FFC_PARAMS *dhparams1 = dh_get0_params((DH *)dh1);
-        FFC_PARAMS *dhparams2 = dh_get0_params((DH *)dh2);
+        FFC_PARAMS *dhparams1 = ossl_dh_get0_params((DH *)dh1);
+        FFC_PARAMS *dhparams2 = ossl_dh_get0_params((DH *)dh2);
 
         ok = ok &amp;&amp; ossl_ffc_params_cmp(dhparams1, dhparams2, 1);
     }
@@ -178,10 +178,10 @@ static int dh_import(void *keydata, int selection, const OSSL_PARAM params[])
         return 0;
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_ALL_PARAMETERS) != 0)
-        ok = ok &amp;&amp; dh_params_fromdata(dh, params);
+        ok = ok &amp;&amp; ossl_dh_params_fromdata(dh, params);
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR) != 0)
-        ok = ok &amp;&amp; dh_key_fromdata(dh, params);
+        ok = ok &amp;&amp; ossl_dh_key_fromdata(dh, params);
 
     return ok;
 }
@@ -202,9 +202,9 @@ static int dh_export(void *keydata, int selection, OSSL_CALLBACK *param_cb,
         return 0;
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_ALL_PARAMETERS) != 0)
-        ok = ok &amp;&amp; dh_params_todata(dh, tmpl, NULL);
+        ok = ok &amp;&amp; ossl_dh_params_todata(dh, tmpl, NULL);
     if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR) != 0)
-        ok = ok &amp;&amp; dh_key_todata(dh, tmpl, NULL);
+        ok = ok &amp;&amp; ossl_dh_key_todata(dh, tmpl, NULL);
 
     if (!ok
         || (params = OSSL_PARAM_BLD_to_param(tmpl)) == NULL) {
@@ -295,14 +295,14 @@ static ossl_inline int dh_get_params(void *key, OSSL_PARAM params[])
     if ((p = OSSL_PARAM_locate(params, OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY)) != NULL) {
         if (p-&gt;data_type != OSSL_PARAM_OCTET_STRING)
             return 0;
-        p-&gt;return_size = dh_key2buf(dh, (unsigned char **)&amp;p-&gt;data,
-                                    p-&gt;data_size, 0);
+        p-&gt;return_size = ossl_dh_key2buf(dh, (unsigned char **)&amp;p-&gt;data,
+                                         p-&gt;data_size, 0);
         if (p-&gt;return_size == 0)
             return 0;
     }
 
-    return dh_params_todata(dh, NULL, params)
-        &amp;&amp; dh_key_todata(dh, NULL, params);
+    return ossl_dh_params_todata(dh, NULL, params)
+        &amp;&amp; ossl_dh_key_todata(dh, NULL, params);
 }
 
 static const OSSL_PARAM dh_params[] = {
@@ -339,7 +339,7 @@ static int dh_set_params(void *key, const OSSL_PARAM params[])
     p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY);
     if (p != NULL
             &amp;&amp; (p-&gt;data_type != OSSL_PARAM_OCTET_STRING
-                || !dh_buf2key(dh, p-&gt;data, p-&gt;data_size)))
+                || !ossl_dh_buf2key(dh, p-&gt;data, p-&gt;data_size)))
         return 0;
 
     return 1;
@@ -357,7 +357,7 @@ static int dh_validate_public(const DH *dh, int checktype)
     /* The partial test is only valid for named group's with q = (p - 1) / 2 */
     if (checktype == OSSL_KEYMGMT_VALIDATE_QUICK_CHECK
         &amp;&amp; ossl_dh_is_named_safe_prime_group(dh))
-        return dh_check_pub_key_partial(dh, pub_key, &amp;res);
+        return ossl_dh_check_pub_key_partial(dh, pub_key, &amp;res);
 
     return DH_check_pub_key(dh, pub_key, &amp;res);
 }
@@ -370,7 +370,7 @@ static int dh_validate_private(const DH *dh)
     DH_get0_key(dh, NULL, &amp;priv_key);
     if (priv_key == NULL)
         return 0;
-    return dh_check_priv_key(dh, priv_key, &amp;status);;
+    return ossl_dh_check_priv_key(dh, priv_key, &amp;status);;
 }
 
 static int dh_validate(const void *keydata, int selection, int checktype)
@@ -404,7 +404,7 @@ static int dh_validate(const void *keydata, int selection, int checktype)
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR)
             == OSSL_KEYMGMT_SELECT_KEYPAIR)
-        ok = ok &amp;&amp; dh_check_pairwise(dh);
+        ok = ok &amp;&amp; ossl_dh_check_pairwise(dh);
     return ok;
 }
 
@@ -461,7 +461,7 @@ static int dh_gen_set_template(void *genctx, void *templ)
 
     if (!ossl_prov_is_running() || gctx == NULL || dh == NULL)
         return 0;
-    gctx-&gt;ffc_params = dh_get0_params(dh);
+    gctx-&gt;ffc_params = ossl_dh_get0_params(dh);
     return 1;
 }
 
@@ -492,8 +492,7 @@ static int dh_gen_set_params(void *genctx, const OSSL_PARAM params[])
     if (p != NULL) {
         if (p-&gt;data_type != OSSL_PARAM_UTF8_STRING
             || ((gctx-&gt;gen_type =
-                 dh_gen_type_name2id_w_default(p-&gt;data,
-                                               gctx-&gt;dh_type)) == -1)) {
+                 dh_gen_type_name2id_w_default(p-&gt;data, gctx-&gt;dh_type)) == -1)) {
             ERR_raise(ERR_LIB_PROV, ERR_R_PASSED_INVALID_ARGUMENT);
             return 0;
         }
@@ -606,18 +605,18 @@ static void *dh_gen(void *genctx, OSSL_CALLBACK *osslcb, void *cbarg)
             &amp;&amp; gctx-&gt;ffc_params == NULL) {
         /* Select a named group if there is not one already */
         if (gctx-&gt;group_nid == NID_undef)
-            gctx-&gt;group_nid = dh_get_named_group_uid_from_size(gctx-&gt;pbits);
+            gctx-&gt;group_nid = ossl_dh_get_named_group_uid_from_size(gctx-&gt;pbits);
         if (gctx-&gt;group_nid == NID_undef)
             return NULL;
-        dh = dh_new_by_nid_ex(gctx-&gt;libctx, gctx-&gt;group_nid);
+        dh = ossl_dh_new_by_nid_ex(gctx-&gt;libctx, gctx-&gt;group_nid);
         if (dh == NULL)
             return NULL;
-        ffc = dh_get0_params(dh);
+        ffc = ossl_dh_get0_params(dh);
     } else {
-        dh = dh_new_ex(gctx-&gt;libctx);
+        dh = ossl_dh_new_ex(gctx-&gt;libctx);
         if (dh == NULL)
             return NULL;
-        ffc = dh_get0_params(dh);
+        ffc = ossl_dh_get0_params(dh);
 
         /* Copy the template value if one was passed */
         if (gctx-&gt;ffc_params != NULL
@@ -653,8 +652,9 @@ static void *dh_gen(void *genctx, OSSL_CALLBACK *osslcb, void *cbarg)
                 ret = DH_generate_parameters_ex(dh, gctx-&gt;pbits,
                                                 gctx-&gt;generator, gencb);
             else
-                ret = dh_generate_ffc_parameters(dh, gctx-&gt;gen_type, gctx-&gt;pbits,
-                                                 gctx-&gt;qbits, gencb);
+                ret = ossl_dh_generate_ffc_parameters(dh, gctx-&gt;gen_type,
+                                                      gctx-&gt;pbits, gctx-&gt;qbits,
+                                                      gencb);
             if (ret &lt;= 0)
                 goto end;
         }
diff --git a/providers/implementations/keymgmt/dsa_kmgmt.c b/providers/implementations/keymgmt/dsa_kmgmt.c
index a02a3e6b01..18313aa329 100644
--- a/providers/implementations/keymgmt/dsa_kmgmt.c
+++ b/providers/implementations/keymgmt/dsa_kmgmt.c
@@ -117,7 +117,7 @@ static void *dsa_newdata(void *provctx)
 {
     if (!ossl_prov_is_running())
         return NULL;
-    return dsa_new_with_ctx(PROV_LIBCTX_OF(provctx));
+    return ossl_dsa_new(PROV_LIBCTX_OF(provctx));
 }
 
 static void dsa_freedata(void *keydata)
@@ -160,8 +160,8 @@ static int dsa_match(const void *keydata1, const void *keydata2, int selection)
         ok = ok
             &amp;&amp; BN_cmp(DSA_get0_priv_key(dsa1), DSA_get0_priv_key(dsa2)) == 0;
     if ((selection &amp; OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS) != 0) {
-        FFC_PARAMS *dsaparams1 = dsa_get0_params((DSA *)dsa1);
-        FFC_PARAMS *dsaparams2 = dsa_get0_params((DSA *)dsa2);
+        FFC_PARAMS *dsaparams1 = ossl_dsa_get0_params((DSA *)dsa1);
+        FFC_PARAMS *dsaparams2 = ossl_dsa_get0_params((DSA *)dsa2);
 
         ok = ok &amp;&amp; ossl_ffc_params_cmp(dsaparams1, dsaparams2, 1);
     }
@@ -180,9 +180,9 @@ static int dsa_import(void *keydata, int selection, const OSSL_PARAM params[])
         return 0;
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_ALL_PARAMETERS) != 0)
-        ok = ok &amp;&amp; dsa_ffc_params_fromdata(dsa, params);
+        ok = ok &amp;&amp; ossl_dsa_ffc_params_fromdata(dsa, params);
     if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR) != 0)
-        ok = ok &amp;&amp; dsa_key_fromdata(dsa, params);
+        ok = ok &amp;&amp; ossl_dsa_key_fromdata(dsa, params);
 
     return ok;
 }
@@ -199,7 +199,7 @@ static int dsa_export(void *keydata, int selection, OSSL_CALLBACK *param_cb,
         goto err;
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_ALL_PARAMETERS) != 0)
-        ok = ok &amp;&amp; ossl_ffc_params_todata(dsa_get0_params(dsa), tmpl, NULL);
+        ok = ok &amp;&amp; ossl_ffc_params_todata(ossl_dsa_get0_params(dsa), tmpl, NULL);
     if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR) != 0)
         ok = ok &amp;&amp; dsa_key_todata(dsa, tmpl, NULL);
 
@@ -289,7 +289,7 @@ static ossl_inline int dsa_get_params(void *key, OSSL_PARAM params[])
     if ((p = OSSL_PARAM_locate(params, OSSL_PKEY_PARAM_DEFAULT_DIGEST)) != NULL
         &amp;&amp; !OSSL_PARAM_set_utf8_string(p, DSA_DEFAULT_MD))
         return 0;
-    return ossl_ffc_params_todata(dsa_get0_params(dsa), NULL, params)
+    return ossl_ffc_params_todata(ossl_dsa_get0_params(dsa), NULL, params)
            &amp;&amp; dsa_key_todata(dsa, NULL, params);
 }
 
@@ -313,7 +313,7 @@ static int dsa_validate_domparams(const DSA *dsa, int checktype)
 {
     int status = 0;
 
-    return dsa_check_params(dsa, checktype, &amp;status);
+    return ossl_dsa_check_params(dsa, checktype, &amp;status);
 }
 
 static int dsa_validate_public(const DSA *dsa)
@@ -324,7 +324,7 @@ static int dsa_validate_public(const DSA *dsa)
     DSA_get0_key(dsa, &amp;pub_key, NULL);
     if (pub_key == NULL)
         return 0;
-    return dsa_check_pub_key(dsa, pub_key, &amp;status);
+    return ossl_dsa_check_pub_key(dsa, pub_key, &amp;status);
 }
 
 static int dsa_validate_private(const DSA *dsa)
@@ -335,7 +335,7 @@ static int dsa_validate_private(const DSA *dsa)
     DSA_get0_key(dsa, NULL, &amp;priv_key);
     if (priv_key == NULL)
         return 0;
-    return dsa_check_priv_key(dsa, priv_key, &amp;status);
+    return ossl_dsa_check_priv_key(dsa, priv_key, &amp;status);
 }
 
 static int dsa_validate(const void *keydata, int selection, int checktype)
@@ -361,7 +361,7 @@ static int dsa_validate(const void *keydata, int selection, int checktype)
     /* If the whole key is selected, we do a pairwise validation */
     if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR)
         == OSSL_KEYMGMT_SELECT_KEYPAIR)
-        ok = ok &amp;&amp; dsa_check_pairwise(dsa);
+        ok = ok &amp;&amp; ossl_dsa_check_pairwise(dsa);
     return ok;
 }
 
@@ -397,7 +397,7 @@ static int dsa_gen_set_template(void *genctx, void *templ)
 
     if (!ossl_prov_is_running() || gctx == NULL || dsa == NULL)
         return 0;
-    gctx-&gt;ffc_params = dsa_get0_params(dsa);
+    gctx-&gt;ffc_params = ossl_dsa_get0_params(dsa);
     return 1;
 }
 
@@ -514,7 +514,7 @@ static void *dsa_gen(void *genctx, OSSL_CALLBACK *osslcb, void *cbarg)
 
     if (!ossl_prov_is_running() || gctx == NULL)
         return NULL;
-    dsa = dsa_new_with_ctx(gctx-&gt;libctx);
+    dsa = ossl_dsa_new(gctx-&gt;libctx);
     if (dsa == NULL)
         return NULL;
 
@@ -524,7 +524,7 @@ static void *dsa_gen(void *genctx, OSSL_CALLBACK *osslcb, void *cbarg)
     if (gencb != NULL)
         BN_GENCB_set(gencb, dsa_gencb, genctx);
 
-    ffc = dsa_get0_params(dsa);
+    ffc = ossl_dsa_get0_params(dsa);
     /* Copy the template value if one was passed */
     if (gctx-&gt;ffc_params != NULL
         &amp;&amp; !ossl_ffc_params_copy(ffc, gctx-&gt;ffc_params))
@@ -546,9 +546,9 @@ static void *dsa_gen(void *genctx, OSSL_CALLBACK *osslcb, void *cbarg)
     }
     if ((gctx-&gt;selection &amp; OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS) != 0) {
 
-         if (dsa_generate_ffc_parameters(dsa, gctx-&gt;gen_type,
-                                         gctx-&gt;pbits, gctx-&gt;qbits,
-                                         gencb) &lt;= 0)
+         if (ossl_dsa_generate_ffc_parameters(dsa, gctx-&gt;gen_type,
+                                              gctx-&gt;pbits, gctx-&gt;qbits,
+                                              gencb) &lt;= 0)
              goto end;
     }
     ossl_ffc_params_enable_flags(ffc, FFC_PARAM_FLAG_VALIDATE_LEGACY,
diff --git a/providers/implementations/keymgmt/ec_kmgmt.c b/providers/implementations/keymgmt/ec_kmgmt.c
index f612d8ed0e..6a74196600 100644
--- a/providers/implementations/keymgmt/ec_kmgmt.c
+++ b/providers/implementations/keymgmt/ec_kmgmt.c
@@ -131,7 +131,7 @@ int key_to_params(const EC_KEY *eckey, OSSL_PARAM_BLD *tmpl,
          * EC_POINT_point2buf() can generate random numbers in some
          * implementations so we need to ensure we use the correct libctx.
          */
-        bnctx = BN_CTX_new_ex(ec_key_get_libctx(eckey));
+        bnctx = BN_CTX_new_ex(ossl_ec_key_get_libctx(eckey));
         if (bnctx == NULL)
             goto err;
 
@@ -237,7 +237,7 @@ int otherparams_to_params(const EC_KEY *ec, OSSL_PARAM_BLD *tmpl,
         return 0;
 
     format = EC_KEY_get_conv_form(ec);
-    name = ec_pt_format_id2name((int)format);
+    name = ossl_ec_pt_format_id2name((int)format);
     if (name != NULL
         &amp;&amp; !ossl_param_build_set_utf8_string(tmpl, params,
                                              OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT,
@@ -245,7 +245,7 @@ int otherparams_to_params(const EC_KEY *ec, OSSL_PARAM_BLD *tmpl,
         return 0;
 
     group_check = EC_KEY_get_flags(ec) &amp; EC_FLAG_CHECK_NAMED_GROUP_MASK;
-    name = ec_check_group_type_id2name(group_check);
+    name = ossl_ec_check_group_type_id2name(group_check);
     if (name != NULL
         &amp;&amp; !ossl_param_build_set_utf8_string(tmpl, params,
                                              OSSL_PKEY_PARAM_EC_GROUP_CHECK_TYPE,
@@ -314,7 +314,7 @@ static int ec_match(const void *keydata1, const void *keydata2, int selection)
     if (!ossl_prov_is_running())
         return 0;
 
-    ctx = BN_CTX_new_ex(ec_key_get_libctx(ec1));
+    ctx = BN_CTX_new_ex(ossl_ec_key_get_libctx(ec1));
     if (ctx == NULL)
         return 0;
 
@@ -377,7 +377,7 @@ int common_import(void *keydata, int selection, const OSSL_PARAM params[],
     if ((selection &amp; OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS) == 0)
         return 0;
 
-    ok = ok &amp;&amp; ec_group_fromdata(ec, params);
+    ok = ok &amp;&amp; ossl_ec_group_fromdata(ec, params);
 
     if (!common_check_sm2(ec, sm2_wanted))
         return 0;
@@ -386,10 +386,10 @@ int common_import(void *keydata, int selection, const OSSL_PARAM params[],
         int include_private =
             selection &amp; OSSL_KEYMGMT_SELECT_PRIVATE_KEY ? 1 : 0;
 
-        ok = ok &amp;&amp; ec_key_fromdata(ec, params, include_private);
+        ok = ok &amp;&amp; ossl_ec_key_fromdata(ec, params, include_private);
     }
     if ((selection &amp; OSSL_KEYMGMT_SELECT_OTHER_PARAMETERS) != 0)
-        ok = ok &amp;&amp; ec_key_otherparams_fromdata(ec, params);
+        ok = ok &amp;&amp; ossl_ec_key_otherparams_fromdata(ec, params);
 
     return ok;
 }
@@ -451,15 +451,16 @@ int ec_export(void *keydata, int selection, OSSL_CALLBACK *param_cb,
         return 0;
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS) != 0) {
-        bnctx = BN_CTX_new_ex(ec_key_get_libctx(ec));
+        bnctx = BN_CTX_new_ex(ossl_ec_key_get_libctx(ec));
         if (bnctx == NULL) {
             ok = 0;
             goto end;
         }
         BN_CTX_start(bnctx);
-        ok = ok &amp;&amp; ec_group_todata(EC_KEY_get0_group(ec), tmpl, NULL,
-                                   ec_key_get_libctx(ec), ec_key_get0_propq(ec),
-                                   bnctx, &amp;genbuf);
+        ok = ok &amp;&amp; ossl_ec_group_todata(EC_KEY_get0_group(ec), tmpl, NULL,
+                                        ossl_ec_key_get_libctx(ec),
+                                        ossl_ec_key_get0_propq(ec),
+                                        bnctx, &amp;genbuf);
     }
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR) != 0) {
@@ -610,8 +611,8 @@ int common_get_params(void *key, OSSL_PARAM params[], int sm2)
     if (ecg == NULL)
         return 0;
 
-    libctx = ec_key_get_libctx(eck);
-    propq = ec_key_get0_propq(eck);
+    libctx = ossl_ec_key_get_libctx(eck);
+    propq = ossl_ec_key_get0_propq(eck);
 
     bnctx = BN_CTX_new_ex(libctx);
     if (bnctx == NULL)
@@ -696,7 +697,8 @@ int common_get_params(void *key, OSSL_PARAM params[], int sm2)
     }
 
     ret = ec_get_ecm_params(ecg, params)
-          &amp;&amp; ec_group_todata(ecg, NULL, params, libctx, propq, bnctx, &amp;genbuf)
+          &amp;&amp; ossl_ec_group_todata(ecg, NULL, params, libctx, propq, bnctx,
+                                  &amp;genbuf)
           &amp;&amp; key_to_params(eck, NULL, params, 1, &amp;pub_key)
           &amp;&amp; otherparams_to_params(eck, NULL, params);
 err:
@@ -773,12 +775,12 @@ int ec_set_params(void *key, const OSSL_PARAM params[])
     if (key == NULL)
         return 0;
 
-    if (!ec_group_set_params((EC_GROUP *)EC_KEY_get0_group(key), params))
+    if (!ossl_ec_group_set_params((EC_GROUP *)EC_KEY_get0_group(key), params))
         return 0;
 
     p = OSSL_PARAM_locate_const(params, OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY);
     if (p != NULL) {
-        BN_CTX *ctx = BN_CTX_new_ex(ec_key_get_libctx(key));
+        BN_CTX *ctx = BN_CTX_new_ex(ossl_ec_key_get_libctx(key));
         int ret = 1;
 
         if (ctx == NULL
@@ -790,7 +792,7 @@ int ec_set_params(void *key, const OSSL_PARAM params[])
             return 0;
     }
 
-    return ec_key_otherparams_fromdata(eck, params);
+    return ossl_ec_key_otherparams_fromdata(eck, params);
 }
 
 #ifndef FIPS_MODULE
@@ -842,7 +844,7 @@ int sm2_validate(const void *keydata, int selection, int checktype)
     if (!ossl_prov_is_running())
         return 0;
 
-    ctx = BN_CTX_new_ex(ec_key_get_libctx(eck));
+    ctx = BN_CTX_new_ex(ossl_ec_key_get_libctx(eck));
     if  (ctx == NULL)
         return 0;
 
@@ -854,16 +856,16 @@ int sm2_validate(const void *keydata, int selection, int checktype)
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_PUBLIC_KEY) != 0) {
         if (checktype == OSSL_KEYMGMT_VALIDATE_QUICK_CHECK)
-            ok = ok &amp;&amp; ec_key_public_check_quick(eck, ctx);
+            ok = ok &amp;&amp; ossl_ec_key_public_check_quick(eck, ctx);
         else
-            ok = ok &amp;&amp; ec_key_public_check(eck, ctx);
+            ok = ok &amp;&amp; ossl_ec_key_public_check(eck, ctx);
     }
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_PRIVATE_KEY) != 0)
-        ok = ok &amp;&amp; sm2_key_private_check(eck);
+        ok = ok &amp;&amp; ossl_sm2_key_private_check(eck);
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR) == OSSL_KEYMGMT_SELECT_KEYPAIR)
-        ok = ok &amp;&amp; ec_key_pairwise_check(eck, ctx);
+        ok = ok &amp;&amp; ossl_ec_key_pairwise_check(eck, ctx);
 
     BN_CTX_free(ctx);
     return ok;
@@ -881,7 +883,7 @@ int ec_validate(const void *keydata, int selection, int checktype)
     if (!ossl_prov_is_running())
         return 0;
 
-    ctx = BN_CTX_new_ex(ec_key_get_libctx(eck));
+    ctx = BN_CTX_new_ex(ossl_ec_key_get_libctx(eck));
     if  (ctx == NULL)
         return 0;
 
@@ -900,16 +902,16 @@ int ec_validate(const void *keydata, int selection, int checktype)
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_PUBLIC_KEY) != 0) {
         if (checktype == OSSL_KEYMGMT_VALIDATE_QUICK_CHECK)
-            ok = ok &amp;&amp; ec_key_public_check_quick(eck, ctx);
+            ok = ok &amp;&amp; ossl_ec_key_public_check_quick(eck, ctx);
         else
-            ok = ok &amp;&amp; ec_key_public_check(eck, ctx);
+            ok = ok &amp;&amp; ossl_ec_key_public_check(eck, ctx);
     }
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_PRIVATE_KEY) != 0)
-        ok = ok &amp;&amp; ec_key_private_check(eck);
+        ok = ok &amp;&amp; ossl_ec_key_private_check(eck);
 
     if ((selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR) == OSSL_KEYMGMT_SELECT_KEYPAIR)
-        ok = ok &amp;&amp; ec_key_pairwise_check(eck, ctx);
+        ok = ok &amp;&amp; ossl_ec_key_pairwise_check(eck, ctx);
 
     BN_CTX_free(ctx);
     return ok;
@@ -1168,14 +1170,14 @@ static void *ec_gen(void *genctx, OSSL_CALLBACK *osslcb, void *cbarg)
             goto err;
     } else {
         if (gctx-&gt;encoding != NULL) {
-            int flags = ec_encoding_name2id(gctx-&gt;encoding);
+            int flags = ossl_ec_encoding_name2id(gctx-&gt;encoding);
 
             if (flags &lt; 0)
                 goto err;
             EC_GROUP_set_asn1_flag(gctx-&gt;gen_group, flags);
         }
         if (gctx-&gt;pt_format != NULL) {
-            int format = ec_pt_format_name2id(gctx-&gt;pt_format);
+            int format = ossl_ec_pt_format_name2id(gctx-&gt;pt_format);
 
             if (format &lt; 0)
                 goto err;
@@ -1191,10 +1193,10 @@ static void *ec_gen(void *genctx, OSSL_CALLBACK *osslcb, void *cbarg)
         ret = ret &amp;&amp; EC_KEY_generate_key(ec);
 
     if (gctx-&gt;ecdh_mode != -1)
-        ret = ret &amp;&amp; ec_set_ecdh_cofactor_mode(ec, gctx-&gt;ecdh_mode);
+        ret = ret &amp;&amp; ossl_ec_set_ecdh_cofactor_mode(ec, gctx-&gt;ecdh_mode);
 
     if (gctx-&gt;group_check != NULL)
-        ret = ret &amp;&amp; ec_set_check_group_type_from_name(ec, gctx-&gt;group_check);
+        ret = ret &amp;&amp; ossl_ec_set_check_group_type_from_name(ec, gctx-&gt;group_check);
     if (ret)
         return ec;
 err:
@@ -1223,14 +1225,14 @@ static void *sm2_gen(void *genctx, OSSL_CALLBACK *osslcb, void *cbarg)
             goto err;
     } else {
         if (gctx-&gt;encoding) {
-            int flags = ec_encoding_name2id(gctx-&gt;encoding);
+            int flags = ossl_ec_encoding_name2id(gctx-&gt;encoding);
 
             if (flags &lt; 0)
                 goto err;
             EC_GROUP_set_asn1_flag(gctx-&gt;gen_group, flags);
         }
         if (gctx-&gt;pt_format != NULL) {
-            int format = ec_pt_format_name2id(gctx-&gt;pt_format);
+            int format = ossl_ec_pt_format_name2id(gctx-&gt;pt_format);
 
             if (format &lt; 0)
                 goto err;
diff --git a/providers/implementations/keymgmt/ecx_kmgmt.c b/providers/implementations/keymgmt/ecx_kmgmt.c
index 86deae8561..6cb0e9bc41 100644
--- a/providers/implementations/keymgmt/ecx_kmgmt.c
+++ b/providers/implementations/keymgmt/ecx_kmgmt.c
@@ -89,32 +89,32 @@ static void *x25519_new_key(void *provctx)
 {
     if (!ossl_prov_is_running())
         return 0;
-    return ecx_key_new(PROV_LIBCTX_OF(provctx), ECX_KEY_TYPE_X25519, 0,
-                       NULL);
+    return ossl_ecx_key_new(PROV_LIBCTX_OF(provctx), ECX_KEY_TYPE_X25519, 0,
+                            NULL);
 }
 
 static void *x448_new_key(void *provctx)
 {
     if (!ossl_prov_is_running())
         return 0;
-    return ecx_key_new(PROV_LIBCTX_OF(provctx), ECX_KEY_TYPE_X448, 0,
-                       NULL);
+    return ossl_ecx_key_new(PROV_LIBCTX_OF(provctx), ECX_KEY_TYPE_X448, 0,
+                            NULL);
 }
 
 static void *ed25519_new_key(void *provctx)
 {
     if (!ossl_prov_is_running())
         return 0;
-    return ecx_key_new(PROV_LIBCTX_OF(provctx), ECX_KEY_TYPE_ED25519, 0,
-                       NULL);
+    return ossl_ecx_key_new(PROV_LIBCTX_OF(provctx), ECX_KEY_TYPE_ED25519, 0,
+                            NULL);
 }
 
 static void *ed448_new_key(void *provctx)
 {
     if (!ossl_prov_is_running())
         return 0;
-    return ecx_key_new(PROV_LIBCTX_OF(provctx), ECX_KEY_TYPE_ED448, 0,
-                       NULL);
+    return ossl_ecx_key_new(PROV_LIBCTX_OF(provctx), ECX_KEY_TYPE_ED448, 0,
+                            NULL);
 }
 
 static int ecx_has(const void *keydata, int selection)
@@ -184,7 +184,7 @@ static int ecx_import(void *keydata, int selection, const OSSL_PARAM params[])
         return 0;
 
     include_private = ((selection &amp; OSSL_KEYMGMT_SELECT_PRIVATE_KEY) != 0);
-    ok = ok &amp;&amp; ecx_key_fromdata(key, params, include_private);
+    ok = ok &amp;&amp; ossl_ecx_key_fromdata(key, params, include_private);
 
     return ok;
 }
@@ -546,7 +546,8 @@ static void *ecx_gen(struct ecx_gen_ctx *gctx)
 
     if (gctx == NULL)
         return NULL;
-    if ((key = ecx_key_new(gctx-&gt;libctx, gctx-&gt;type, 0, gctx-&gt;propq)) == NULL) {
+    if ((key = ossl_ecx_key_new(gctx-&gt;libctx, gctx-&gt;type, 0,
+                                gctx-&gt;propq)) == NULL) {
         ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
         return NULL;
     }
@@ -555,7 +556,7 @@ static void *ecx_gen(struct ecx_gen_ctx *gctx)
     if ((gctx-&gt;selection &amp; OSSL_KEYMGMT_SELECT_KEYPAIR) == 0)
         return key;
 
-    if ((privkey = ecx_key_allocate_privkey(key)) == NULL) {
+    if ((privkey = ossl_ecx_key_allocate_privkey(key)) == NULL) {
         ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
         goto err;
     }
@@ -587,7 +588,7 @@ static void *ecx_gen(struct ecx_gen_ctx *gctx)
     key-&gt;haspubkey = 1;
     return key;
 err:
-    ecx_key_free(key);
+    ossl_ecx_key_free(key);
     return NULL;
 }
 
@@ -749,7 +750,7 @@ static int ed448_validate(const void *keydata, int selection, int checktype)
 #define MAKE_KEYMGMT_FUNCTIONS(alg) \
     const OSSL_DISPATCH ossl_##alg##_keymgmt_functions[] = { \
         { OSSL_FUNC_KEYMGMT_NEW, (void (*)(void))alg##_new_key }, \
-        { OSSL_FUNC_KEYMGMT_FREE, (void (*)(void))ecx_key_free }, \
+        { OSSL_FUNC_KEYMGMT_FREE, (void (*)(void))ossl_ecx_key_free }, \
         { OSSL_FUNC_KEYMGMT_GET_PARAMS, (void (*) (void))alg##_get_params }, \
         { OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS, (void (*) (void))alg##_gettable_params }, \
         { OSSL_FUNC_KEYMGMT_SET_PARAMS, (void (*) (void))alg##_set_params }, \
@@ -786,7 +787,8 @@ static void *s390x_ecx_keygen25519(struct ecx_gen_ctx *gctx)
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
     };
-    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_X25519, 1, gctx-&gt;propq);
+    ECX_KEY *key = ossl_ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_X25519, 1,
+                                    gctx-&gt;propq);
     unsigned char *privkey = NULL, *pubkey;
 
     if (key == NULL) {
@@ -800,7 +802,7 @@ static void *s390x_ecx_keygen25519(struct ecx_gen_ctx *gctx)
 
     pubkey = key-&gt;pubkey;
 
-    privkey = ecx_key_allocate_privkey(key);
+    privkey = ossl_ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
         ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
         goto err;
@@ -818,7 +820,7 @@ static void *s390x_ecx_keygen25519(struct ecx_gen_ctx *gctx)
     key-&gt;haspubkey = 1;
     return key;
  err:
-    ecx_key_free(key);
+    ossl_ecx_key_free(key);
     return NULL;
 }
 
@@ -831,7 +833,8 @@ static void *s390x_ecx_keygen448(struct ecx_gen_ctx *gctx)
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
     };
-    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_X448, 1, gctx-&gt;propq);
+    ECX_KEY *key = ossl_ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_X448, 1,
+                                    gctx-&gt;propq);
     unsigned char *privkey = NULL, *pubkey;
 
     if (key == NULL) {
@@ -845,7 +848,7 @@ static void *s390x_ecx_keygen448(struct ecx_gen_ctx *gctx)
 
     pubkey = key-&gt;pubkey;
 
-    privkey = ecx_key_allocate_privkey(key);
+    privkey = ossl_ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
         ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
         goto err;
@@ -862,7 +865,7 @@ static void *s390x_ecx_keygen448(struct ecx_gen_ctx *gctx)
     key-&gt;haspubkey = 1;
     return key;
  err:
-    ecx_key_free(key);
+    ossl_ecx_key_free(key);
     return NULL;
 }
 
@@ -879,7 +882,8 @@ static void *s390x_ecd_keygen25519(struct ecx_gen_ctx *gctx)
         0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
     };
     unsigned char x_dst[32], buff[SHA512_DIGEST_LENGTH];
-    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_ED25519, 1, gctx-&gt;propq);
+    ECX_KEY *key = ossl_ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_ED25519, 1,
+                                    gctx-&gt;propq);
     unsigned char *privkey = NULL, *pubkey;
     unsigned int sz;
     EVP_MD *sha = NULL;
@@ -896,7 +900,7 @@ static void *s390x_ecd_keygen25519(struct ecx_gen_ctx *gctx)
 
     pubkey = key-&gt;pubkey;
 
-    privkey = ecx_key_allocate_privkey(key);
+    privkey = ossl_ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
         ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
         goto err;
@@ -925,7 +929,7 @@ static void *s390x_ecd_keygen25519(struct ecx_gen_ctx *gctx)
     key-&gt;haspubkey = 1;
     return key;
  err:
-    ecx_key_free(key);
+    ossl_ecx_key_free(key);
     return NULL;
 }
 
@@ -946,7 +950,8 @@ static void *s390x_ecd_keygen448(struct ecx_gen_ctx *gctx)
         0x24, 0xbc, 0xb6, 0x6e, 0x71, 0x46, 0x3f, 0x69, 0x00
     };
     unsigned char x_dst[57], buff[114];
-    ECX_KEY *key = ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_ED448, 1, gctx-&gt;propq);
+    ECX_KEY *key = ossl_ecx_key_new(gctx-&gt;libctx, ECX_KEY_TYPE_ED448, 1,
+                                    gctx-&gt;propq);
     unsigned char *privkey = NULL, *pubkey;
     EVP_MD_CTX *hashctx = NULL;
     EVP_MD *shake = NULL;
@@ -962,7 +967,7 @@ static void *s390x_ecd_keygen448(struct ecx_gen_ctx *gctx)
 
     pubkey = key-&gt;pubkey;
 
-    privkey = ecx_key_allocate_privkey(key);
+    privkey = ossl_ecx_key_allocate_privkey(key);
     if (privkey == NULL) {
         ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);
         goto err;
@@ -998,7 +1003,7 @@ static void *s390x_ecd_keygen448(struct ecx_gen_ctx *gctx)
     key-&gt;haspubkey = 1;
     return key;
  err:
-    ecx_key_free(key);
+    ossl_ecx_key_free(key);
     EVP_MD_CTX_free(hashctx);
     EVP_MD_free(shake);
     return NULL;
diff --git a/providers/implementations/signature/dsa.c b/providers/implementations/signature/dsa.c
index 620bfa845c..81e435c419 100644
--- a/providers/implementations/signature/dsa.c
+++ b/providers/implementations/signature/dsa.c
@@ -223,7 +223,7 @@ static int dsa_sign(void *vpdsactx, unsigned char *sig, size_t *siglen,
     if (mdsize != 0 &amp;&amp; tbslen != mdsize)
         return 0;
 
-    ret = dsa_sign_int(0, tbs, tbslen, sig, &amp;sltmp, pdsactx-&gt;dsa);
+    ret = ossl_dsa_sign_int(0, tbs, tbslen, sig, &amp;sltmp, pdsactx-&gt;dsa);
     if (ret &lt;= 0)
         return 0;
 
diff --git a/providers/implementations/signature/eddsa.c b/providers/implementations/signature/eddsa.c
index 9813545381..71b57d70ea 100644
--- a/providers/implementations/signature/eddsa.c
+++ b/providers/implementations/signature/eddsa.c
@@ -99,7 +99,7 @@ static int eddsa_digest_signverify_init(void *vpeddsactx, const char *mdname,
         return 0;
     }
 
-    if (!ecx_key_up_ref(edkey)) {
+    if (!ossl_ecx_key_up_ref(edkey)) {
         ERR_raise(ERR_LIB_PROV, ERR_R_INTERNAL_ERROR);
         return 0;
     }
@@ -240,7 +240,7 @@ static void eddsa_freectx(void *vpeddsactx)
 {
     PROV_EDDSA_CTX *peddsactx = (PROV_EDDSA_CTX *)vpeddsactx;
 
-    ecx_key_free(peddsactx-&gt;key);
+    ossl_ecx_key_free(peddsactx-&gt;key);
 
     OPENSSL_free(peddsactx);
 }
@@ -260,7 +260,7 @@ static void *eddsa_dupctx(void *vpeddsactx)
     *dstctx = *srcctx;
     dstctx-&gt;key = NULL;
 
-    if (srcctx-&gt;key != NULL &amp;&amp; !ecx_key_up_ref(srcctx-&gt;key)) {
+    if (srcctx-&gt;key != NULL &amp;&amp; !ossl_ecx_key_up_ref(srcctx-&gt;key)) {
         ERR_raise(ERR_LIB_PROV, ERR_R_INTERNAL_ERROR);
         goto err;
     }
diff --git a/providers/implementations/signature/sm2sig.c b/providers/implementations/signature/sm2sig.c
index 84c3853f23..d12c7191fb 100644
--- a/providers/implementations/signature/sm2sig.c
+++ b/providers/implementations/signature/sm2sig.c
@@ -144,7 +144,7 @@ static int sm2sig_sign(void *vpsm2ctx, unsigned char *sig, size_t *siglen,
     if (ctx-&gt;mdsize != 0 &amp;&amp; tbslen != ctx-&gt;mdsize)
         return 0;
 
-    ret = sm2_internal_sign(tbs, tbslen, sig, &amp;sltmp, ctx-&gt;ec);
+    ret = ossl_sm2_internal_sign(tbs, tbslen, sig, &amp;sltmp, ctx-&gt;ec);
     if (ret &lt;= 0)
         return 0;
 
@@ -160,7 +160,7 @@ static int sm2sig_verify(void *vpsm2ctx, const unsigned char *sig, size_t siglen
     if (ctx-&gt;mdsize != 0 &amp;&amp; tbslen != ctx-&gt;mdsize)
         return 0;
 
-    return sm2_internal_verify(tbs, tbslen, sig, siglen, ctx-&gt;ec);
+    return ossl_sm2_internal_verify(tbs, tbslen, sig, siglen, ctx-&gt;ec);
 }
 
 static void free_md(PROV_SM2_CTX *ctx)
@@ -231,7 +231,8 @@ static int sm2sig_compute_z_digest(PROV_SM2_CTX *ctx)
 
         if ((z = OPENSSL_zalloc(ctx-&gt;mdsize)) == NULL
             /* get hashed prefix 'z' of tbs message */
-            || !sm2_compute_z_digest(z, ctx-&gt;md, ctx-&gt;id, ctx-&gt;id_len, ctx-&gt;ec)
+            || !ossl_sm2_compute_z_digest(z, ctx-&gt;md, ctx-&gt;id, ctx-&gt;id_len,
+                                          ctx-&gt;ec)
             || !EVP_DigestUpdate(ctx-&gt;mdctx, z, ctx-&gt;mdsize))
             ret = 0;
         OPENSSL_free(z);
diff --git a/test/ec_internal_test.c b/test/ec_internal_test.c
index e2ea65b885..e0e6a859cb 100644
--- a/test/ec_internal_test.c
+++ b/test/ec_internal_test.c
@@ -233,8 +233,8 @@ static int underflow_test(void)
             || !TEST_int_gt(BN_hex2bn(&amp;y1, p521m1), 0)
             || !TEST_int_gt(BN_hex2bn(&amp;z1, p521m1), 0)
             || !TEST_int_gt(BN_hex2bn(&amp;k, &quot;02&quot;), 0)
-            || !TEST_true(ec_GFp_simple_set_Jprojective_coordinates_GFp(grp, P, x1,
-                                                                        y1, z1, ctx))
+            || !TEST_true(ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp(grp, P, x1,
+                                                                             y1, z1, ctx))
             || !TEST_true(EC_POINT_mul(grp, Q, NULL, P, k, ctx))
             || !TEST_true(EC_POINT_get_affine_coordinates(grp, Q, x1, y1, ctx))
             || !TEST_true(EC_POINT_dbl(grp, R, P, ctx))
diff --git a/test/ffc_internal_test.c b/test/ffc_internal_test.c
index 1cbaec891b..3c54d68010 100644
--- a/test/ffc_internal_test.c
+++ b/test/ffc_internal_test.c
@@ -435,7 +435,7 @@ err:
     return ret;
 }
 
-extern FFC_PARAMS *dh_get0_params(DH *dh);
+extern FFC_PARAMS *ossl_dh_get0_params(DH *dh);
 
 static int ffc_public_validate_test(void)
 {
@@ -449,7 +449,7 @@ static int ffc_public_validate_test(void)
 
     if (!TEST_ptr(dh = DH_new_by_nid(NID_ffdhe2048)))
         goto err;
-    params = dh_get0_params(dh);
+    params = ossl_dh_get0_params(dh);
 
     if (!TEST_true(BN_set_word(pub, 1)))
         goto err;
@@ -528,7 +528,7 @@ static int ffc_private_validate_test(void)
 
     if (!TEST_ptr(dh = DH_new_by_nid(NID_ffdhe2048)))
         goto err;
-    params = dh_get0_params(dh);
+    params = ossl_dh_get0_params(dh);
 
     if (!TEST_true(BN_set_word(priv, 1)))
         goto err;
@@ -589,7 +589,7 @@ static int ffc_private_gen_test(int index)
 
     if (!TEST_ptr(dh = DH_new_by_nid(NID_ffdhe2048)))
         goto err;
-    params = dh_get0_params(dh);
+    params = ossl_dh_get0_params(dh);
 
     N = BN_num_bits(params-&gt;q);
     /* Fail since N &lt; 2*s - where s = 112*/
diff --git a/test/sm2_internal_test.c b/test/sm2_internal_test.c
index 77b76e64f8..aaa337b57b 100644
--- a/test/sm2_internal_test.c
+++ b/test/sm2_internal_test.c
@@ -159,7 +159,8 @@ static int test_sm2_crypt(const EC_GROUP *group,
     if (!TEST_ptr(pt)
             || !TEST_true(EC_POINT_mul(group, pt, priv, NULL, NULL, NULL))
             || !TEST_true(EC_KEY_set_public_key(key, pt))
-            || !TEST_true(sm2_ciphertext_size(key, digest, msg_len, &amp;ctext_len)))
+            || !TEST_true(ossl_sm2_ciphertext_size(key, digest, msg_len,
+                                                   &amp;ctext_len)))
         goto done;
 
     ctext = OPENSSL_zalloc(ctext_len);
@@ -167,8 +168,9 @@ static int test_sm2_crypt(const EC_GROUP *group,
         goto done;
 
     start_fake_rand(k_hex);
-    if (!TEST_true(sm2_encrypt(key, digest, (const uint8_t *)message, msg_len,
-                               ctext, &amp;ctext_len))) {
+    if (!TEST_true(ossl_sm2_encrypt(key, digest,
+                                    (const uint8_t *)message, msg_len,
+                                    ctext, &amp;ctext_len))) {
         restore_rand();
         goto done;
     }
@@ -177,13 +179,14 @@ static int test_sm2_crypt(const EC_GROUP *group,
     if (!TEST_mem_eq(ctext, ctext_len, expected, ctext_len))
         goto done;
 
-    if (!TEST_true(sm2_plaintext_size(key, digest, ctext_len, &amp;ptext_len))
+    if (!TEST_true(ossl_sm2_plaintext_size(key, digest, ctext_len, &amp;ptext_len))
             || !TEST_int_eq(ptext_len, msg_len))
         goto done;
 
     recovered = OPENSSL_zalloc(ptext_len);
     if (!TEST_ptr(recovered)
-            || !TEST_true(sm2_decrypt(key, digest, ctext, ctext_len, recovered, &amp;recovered_len))
+            || !TEST_true(ossl_sm2_decrypt(key, digest, ctext, ctext_len,
+                                           recovered, &amp;recovered_len))
             || !TEST_int_eq(recovered_len, msg_len)
             || !TEST_mem_eq(recovered, recovered_len, message, msg_len))
         goto done;
@@ -286,8 +289,8 @@ static int test_sm2_sign(const EC_GROUP *group,
         goto done;
 
     start_fake_rand(k_hex);
-    sig = sm2_do_sign(key, EVP_sm3(), (const uint8_t *)userid, strlen(userid),
-                      (const uint8_t *)message, msg_len);
+    sig = ossl_sm2_do_sign(key, EVP_sm3(), (const uint8_t *)userid,
+                           strlen(userid), (const uint8_t *)message, msg_len);
     if (!TEST_ptr(sig)) {
         restore_rand();
         goto done;
@@ -302,8 +305,8 @@ static int test_sm2_sign(const EC_GROUP *group,
             || !TEST_BN_eq(s, sig_s))
         goto done;
 
-    ok = sm2_do_verify(key, EVP_sm3(), sig, (const uint8_t *)userid,
-                       strlen(userid), (const uint8_t *)message, msg_len);
+    ok = ossl_sm2_do_verify(key, EVP_sm3(), sig, (const uint8_t *)userid,
+                            strlen(userid), (const uint8_t *)message, msg_len);
 
     /* We goto done whether this passes or fails */
     TEST_true(ok);
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="033258.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="033261.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33259">[ date ]</a>
              <a href="thread.html#33259">[ thread ]</a>
              <a href="subject.html#33259">[ subject ]</a>
              <a href="author.html#33259">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
