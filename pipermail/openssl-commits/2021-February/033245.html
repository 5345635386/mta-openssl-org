<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2021-February/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1614182030.651257.18268.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="033244.html">
   <LINK REL="Next"  HREF="033246.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>tomas at openssl.org</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1614182030.651257.18268.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">tomas at openssl.org
       </A><BR>
    <I>Wed Feb 24 15:53:50 UTC 2021</I>
    <P><UL>
        <LI>Previous message: <A HREF="033244.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="033246.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33245">[ date ]</a>
              <a href="thread.html#33245">[ thread ]</a>
              <a href="subject.html#33245">[ subject ]</a>
              <a href="author.html#33245">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  861f265a407d5de81c79b6917139e66cdfb0f367 (commit)
       via  f3ccfc76fe3b73190e3de60fb8c8c39d88203db1 (commit)
       via  a89cd8d87c48b1d3561ce74af79e1d4fbaa034b7 (commit)
       via  ee1d7f1d25ef24f111f13dc742474cd9c39c2753 (commit)
      from  af9f2ee339acd3958c0a8262e7e1012a632025da (commit)


- Log -----------------------------------------------------------------
commit 861f265a407d5de81c79b6917139e66cdfb0f367
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tomas at openssl.org</A>&gt;
Date:   Mon Feb 22 13:20:28 2021 +0100

    speed: Drop deprecated &lt;ALG&gt;_options() calls
    
    Also correction of some code format issues.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/14228">https://github.com/openssl/openssl/pull/14228</A>)

commit f3ccfc76fe3b73190e3de60fb8c8c39d88203db1
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tomas at openssl.org</A>&gt;
Date:   Thu Feb 18 10:48:18 2021 +0100

    speed: Use EVP for ciphers, cmac, ghash, rsa, dsa, and ecdsa
    
    Fixes #13909
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/14228">https://github.com/openssl/openssl/pull/14228</A>)

commit a89cd8d87c48b1d3561ce74af79e1d4fbaa034b7
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tomas at openssl.org</A>&gt;
Date:   Mon Feb 15 19:45:01 2021 +0100

    speed: Adapt digests and hmac to always use non-deprecated APIs
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/14228">https://github.com/openssl/openssl/pull/14228</A>)

commit ee1d7f1d25ef24f111f13dc742474cd9c39c2753
Author: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tomas at openssl.org</A>&gt;
Date:   Mon Feb 15 17:24:44 2021 +0100

    speed: Drop code to handle platforms without SIGALRM
    
    (except for Windows where a separate thread stops the looping)
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/14228">https://github.com/openssl/openssl/pull/14228</A>)

-----------------------------------------------------------------------

Summary of changes:
 CHANGES.md     |    7 +
 apps/speed.c   | 2472 +++++++++++++++++++-------------------------------------
 apps/testdsa.h |   47 +-
 3 files changed, 872 insertions(+), 1654 deletions(-)

diff --git a/CHANGES.md b/CHANGES.md
index c7a2c0baa5..335b492e4f 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -47,6 +47,13 @@ OpenSSL 3.0
 
    *Paul Dale*
 
+ * The openssl speed command does not use low-level API calls anymore. This
+   implies some of the performance numbers might not be fully comparable
+   with the previous releases due to higher overhead. This applies
+   particularly to measuring performance on smaller data chunks.
+
+   *Tom&#225;&#353; Mr&#225;z*
+
  * Combining the Configure options no-ec and no-dh no longer disables TLSv1.3.
    Typically if OpenSSL has no EC or DH algorithms then it cannot support
    connections with TLSv1.3. However OpenSSL now supports &quot;pluggable&quot; groups
diff --git a/apps/speed.c b/apps/speed.c
index e867448015..92eb0585fc 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -9,14 +9,16 @@
  */
 
 #undef SECONDS
-#define SECONDS                 3
-#define RSA_SECONDS             10
-#define DSA_SECONDS             10
-#define ECDSA_SECONDS   10
-#define ECDH_SECONDS    10
-#define EdDSA_SECONDS   10
-#define SM2_SECONDS     10
-#define FFDH_SECONDS    10
+#define SECONDS          3
+#define PKEY_SECONDS    10
+
+#define RSA_SECONDS     PKEY_SECONDS
+#define DSA_SECONDS     PKEY_SECONDS
+#define ECDSA_SECONDS   PKEY_SECONDS
+#define ECDH_SECONDS    PKEY_SECONDS
+#define EdDSA_SECONDS   PKEY_SECONDS
+#define SM2_SECONDS     PKEY_SECONDS
+#define FFDH_SECONDS    PKEY_SECONDS
 
 /* We need to use some deprecated APIs */
 #define OPENSSL_SUPPRESS_DEPRECATED
@@ -32,6 +34,7 @@
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/objects.h&gt;
+#include &lt;openssl/core_names.h&gt;
 #include &lt;openssl/async.h&gt;
 #if !defined(OPENSSL_SYS_MSDOS)
 # include &lt;unistd.h&gt;
@@ -48,74 +51,14 @@
 #endif
 
 #include &lt;openssl/bn.h&gt;
-#ifndef OPENSSL_NO_DES
-# include &lt;openssl/des.h&gt;
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-#include &lt;openssl/aes.h&gt;
-#endif
-#ifndef OPENSSL_NO_CAMELLIA
-# include &lt;openssl/camellia.h&gt;
-#endif
-#ifndef OPENSSL_NO_MD2
-# include &lt;openssl/md2.h&gt;
-#endif
-#ifndef OPENSSL_NO_MDC2
-# include &lt;openssl/mdc2.h&gt;
-#endif
-#ifndef OPENSSL_NO_MD4
-# include &lt;openssl/md4.h&gt;
-#endif
-#ifndef OPENSSL_NO_MD5
-# include &lt;openssl/md5.h&gt;
-#endif
-#include &lt;openssl/hmac.h&gt;
-#ifndef OPENSSL_NO_CMAC
-#include &lt;openssl/cmac.h&gt;
-#endif
-#include &lt;openssl/sha.h&gt;
-#ifndef OPENSSL_NO_RMD160
-# include &lt;openssl/ripemd.h&gt;
-#endif
-#ifndef OPENSSL_NO_WHIRLPOOL
-# include &lt;openssl/whrlpool.h&gt;
-#endif
-#ifndef OPENSSL_NO_RC4
-# include &lt;openssl/rc4.h&gt;
-#endif
-#ifndef OPENSSL_NO_RC5
-# include &lt;openssl/rc5.h&gt;
-#endif
-#ifndef OPENSSL_NO_RC2
-# include &lt;openssl/rc2.h&gt;
-#endif
-#ifndef OPENSSL_NO_IDEA
-# include &lt;openssl/idea.h&gt;
-#endif
-#ifndef OPENSSL_NO_SEED
-# include &lt;openssl/seed.h&gt;
-#endif
-#ifndef OPENSSL_NO_BF
-# include &lt;openssl/blowfish.h&gt;
-#endif
-#ifndef OPENSSL_NO_CAST
-# include &lt;openssl/cast.h&gt;
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-# include &lt;openssl/rsa.h&gt;
-# include &quot;./testrsa.h&quot;
-#endif
+#include &lt;openssl/rsa.h&gt;
+#include &quot;./testrsa.h&quot;
 #ifndef OPENSSL_NO_DH
 # include &lt;openssl/dh.h&gt;
 #endif
 #include &lt;openssl/x509.h&gt;
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-# include &lt;openssl/dsa.h&gt;
-# include &quot;./testdsa.h&quot;
-#endif
-#ifndef OPENSSL_NO_EC
-# include &lt;openssl/ec.h&gt;
-#endif
+#include &lt;openssl/dsa.h&gt;
+#include &quot;./testdsa.h&quot;
 #include &lt;openssl/modes.h&gt;
 
 #ifndef HAVE_FORK
@@ -137,6 +80,10 @@
 #define MISALIGN        64
 #define MAX_FFDH_SIZE 1024
 
+#ifndef RSA_DEFAULT_PRIME_NUM
+# define RSA_DEFAULT_PRIME_NUM 2
+#endif
+
 typedef struct openssl_speed_sec_st {
     int sym;
     int rsa;
@@ -155,13 +102,8 @@ static int usertime = 1;
 
 static double Time_F(int s);
 static void print_message(const char *s, long num, int length, int tm);
-#if !defined(OPENSSL_NO_DEPRECATED_3_0)         \
-    || !defined(OPENSSL_NO_DSA)                 \
-    || !defined(OPENSSL_NO_DH)                  \
-    || !defined(OPENSSL_NO_EC)
 static void pkey_print_message(const char *str, const char *str2,
                                long num, unsigned int bits, int sec);
-#endif
 static void print_result(int alg, int run_no, int count, double time_used);
 #ifndef NO_FORK
 static int do_multi(int multi, int size_num);
@@ -243,10 +185,7 @@ static double Time_F(int s)
     return ret;
 }
 #else
-static double Time_F(int s)
-{
-    return app_tminterval(s, usertime);
-}
+# error &quot;SIGALRM not defined and the platform is not Windows&quot;
 #endif
 
 static void multiblock_speed(const EVP_CIPHER *evp_cipher, int lengths_single,
@@ -296,12 +235,8 @@ const OPTIONS speed_options[] = {
 
     OPT_SECTION(&quot;Selection&quot;),
     {&quot;evp&quot;, OPT_EVP, 's', &quot;Use EVP-named cipher or digest&quot;},
-#ifndef OPENSSL_NO_DEPRECATED_3_0
     {&quot;hmac&quot;, OPT_HMAC, 's', &quot;HMAC using EVP-named digest&quot;},
-#endif
-#if !defined(OPENSSL_NO_CMAC) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;cmac&quot;, OPT_CMAC, 's', &quot;CMAC using EVP-named cipher&quot;},
-#endif
     {&quot;decrypt&quot;, OPT_DECRYPT, '-',
      &quot;Time decryption instead of encryption (only EVP)&quot;},
     {&quot;aead&quot;, OPT_AEAD, '-',
@@ -326,105 +261,68 @@ const OPTIONS speed_options[] = {
 };
 
 enum {
-    D_MD2, D_MDC2, D_MD4, D_MD5 , D_HMAC, D_SHA1, D_RMD160, D_RC4,
-    D_CBC_DES, D_EDE3_DES, D_CBC_IDEA, D_CBC_SEED,
+    D_MD2, D_MDC2, D_MD4, D_MD5, D_SHA1, D_RMD160,
+    D_SHA256, D_SHA512, D_WHIRLPOOL, D_HMAC,
+    D_CBC_DES, D_EDE3_DES, D_RC4, D_CBC_IDEA, D_CBC_SEED,
     D_CBC_RC2, D_CBC_RC5, D_CBC_BF, D_CBC_CAST,
     D_CBC_128_AES, D_CBC_192_AES, D_CBC_256_AES,
     D_CBC_128_CML, D_CBC_192_CML, D_CBC_256_CML,
-    D_EVP, D_SHA256, D_SHA512, D_WHIRLPOOL,
-    D_IGE_128_AES, D_IGE_192_AES, D_IGE_256_AES,
-    D_GHASH, D_RAND, D_EVP_HMAC, D_EVP_CMAC, ALGOR_NUM 
+    D_EVP, D_GHASH, D_RAND, D_EVP_CMAC, ALGOR_NUM
 };
 /* name of algorithms to test. MUST BE KEEP IN SYNC with above enum ! */
 static const char *names[ALGOR_NUM] = {
-    &quot;md2&quot;, &quot;mdc2&quot;, &quot;md4&quot;, &quot;md5&quot;, &quot;hmac(md5)&quot;, &quot;sha1&quot;, &quot;rmd160&quot;, &quot;rc4&quot;,
-    &quot;des cbc&quot;, &quot;des ede3&quot;, &quot;idea cbc&quot;, &quot;seed cbc&quot;,
-    &quot;rc2 cbc&quot;, &quot;rc5-32/12 cbc&quot;, &quot;blowfish cbc&quot;, &quot;cast cbc&quot;,
-    &quot;aes-128 cbc&quot;, &quot;aes-192 cbc&quot;, &quot;aes-256 cbc&quot;,
-    &quot;camellia-128 cbc&quot;, &quot;camellia-192 cbc&quot;, &quot;camellia-256 cbc&quot;,
-    &quot;evp&quot;, &quot;sha256&quot;, &quot;sha512&quot;, &quot;whirlpool&quot;,
-    &quot;aes-128 ige&quot;, &quot;aes-192 ige&quot;, &quot;aes-256 ige&quot;, &quot;ghash&quot;,
-    &quot;rand&quot;, &quot;hmac&quot;, &quot;cmac&quot;
+    &quot;md2&quot;, &quot;mdc2&quot;, &quot;md4&quot;, &quot;md5&quot;, &quot;sha1&quot;, &quot;rmd160&quot;,
+    &quot;sha256&quot;, &quot;sha512&quot;, &quot;whirlpool&quot;, &quot;hmac(md5)&quot;,
+    &quot;des-cbc&quot;, &quot;des-ede3&quot;, &quot;rc4&quot;, &quot;idea-cbc&quot;, &quot;seed-cbc&quot;,
+    &quot;rc2-cbc&quot;, &quot;rc5-cbc&quot;, &quot;blowfish&quot;, &quot;cast-cbc&quot;,
+    &quot;aes-128-cbc&quot;, &quot;aes-192-cbc&quot;, &quot;aes-256-cbc&quot;,
+    &quot;camellia-128-cbc&quot;, &quot;camellia-192-cbc&quot;, &quot;camellia-256-cbc&quot;,
+    &quot;evp&quot;, &quot;ghash&quot;, &quot;rand&quot;, &quot;cmac&quot;
 };
 
 /* list of configured algorithm (remaining), with some few alias */
 static const OPT_PAIR doit_choices[] = {
-#if !defined(OPENSSL_NO_MD2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;md2&quot;, D_MD2},
-#endif
-#if !defined(OPENSSL_NO_MDC2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;mdc2&quot;, D_MDC2},
-#endif
-#if !defined(OPENSSL_NO_MD4) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;md4&quot;, D_MD4},
-#endif
-#if !defined(OPENSSL_NO_MD5) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;md5&quot;, D_MD5},
-# ifndef OPENSSL_NO_DEPRECATED_3_0
     {&quot;hmac&quot;, D_HMAC},
-# endif
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
     {&quot;sha1&quot;, D_SHA1},
     {&quot;sha256&quot;, D_SHA256},
     {&quot;sha512&quot;, D_SHA512},
-#endif
-#if !defined(OPENSSL_NO_WHIRLPOOL) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;whirlpool&quot;, D_WHIRLPOOL},
-#endif
-#if !defined(OPENSSL_NO_RMD160) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;ripemd&quot;, D_RMD160},
     {&quot;rmd160&quot;, D_RMD160},
     {&quot;ripemd160&quot;, D_RMD160},
-#endif
-#if !defined(OPENSSL_NO_RC4) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;rc4&quot;, D_RC4},
-#endif
-#if !defined(OPENSSL_NO_DES) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;des-cbc&quot;, D_CBC_DES},
     {&quot;des-ede3&quot;, D_EDE3_DES},
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
     {&quot;aes-128-cbc&quot;, D_CBC_128_AES},
     {&quot;aes-192-cbc&quot;, D_CBC_192_AES},
     {&quot;aes-256-cbc&quot;, D_CBC_256_AES},
-    {&quot;aes-128-ige&quot;, D_IGE_128_AES},
-    {&quot;aes-192-ige&quot;, D_IGE_192_AES},
-    {&quot;aes-256-ige&quot;, D_IGE_256_AES},
-#endif
-#if !defined(OPENSSL_NO_RC2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
+    {&quot;camellia-128-cbc&quot;, D_CBC_128_CML},
+    {&quot;camellia-192-cbc&quot;, D_CBC_192_CML},
+    {&quot;camellia-256-cbc&quot;, D_CBC_256_CML},
     {&quot;rc2-cbc&quot;, D_CBC_RC2},
     {&quot;rc2&quot;, D_CBC_RC2},
-#endif
-#if !defined(OPENSSL_NO_RC5) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;rc5-cbc&quot;, D_CBC_RC5},
     {&quot;rc5&quot;, D_CBC_RC5},
-#endif
-#if !defined(OPENSSL_NO_IDEA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;idea-cbc&quot;, D_CBC_IDEA},
     {&quot;idea&quot;, D_CBC_IDEA},
-#endif
-#if !defined(OPENSSL_NO_SEED) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;seed-cbc&quot;, D_CBC_SEED},
     {&quot;seed&quot;, D_CBC_SEED},
-#endif
-#if !defined(OPENSSL_NO_BF) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;bf-cbc&quot;, D_CBC_BF},
     {&quot;blowfish&quot;, D_CBC_BF},
     {&quot;bf&quot;, D_CBC_BF},
-#endif
-#if !defined(OPENSSL_NO_CAST) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     {&quot;cast-cbc&quot;, D_CBC_CAST},
     {&quot;cast&quot;, D_CBC_CAST},
     {&quot;cast5&quot;, D_CBC_CAST},
-#endif
     {&quot;ghash&quot;, D_GHASH},
     {&quot;rand&quot;, D_RAND}
 };
 
 static double results[ALGOR_NUM][SIZE_NUM];
 
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
 enum { R_DSA_512, R_DSA_1024, R_DSA_2048, DSA_NUM };
 static const OPT_PAIR dsa_choices[DSA_NUM] = {
     {&quot;dsa512&quot;, R_DSA_512},
@@ -432,9 +330,7 @@ static const OPT_PAIR dsa_choices[DSA_NUM] = {
     {&quot;dsa2048&quot;, R_DSA_2048}
 };
 static double dsa_results[DSA_NUM][2];  /* 2 ops: sign then verify */
-#endif  /* OPENSSL_NO_DSA */
 
-#ifndef OPENSSL_NO_DEPRECATED_3_0
 enum {
     R_RSA_512, R_RSA_1024, R_RSA_2048, R_RSA_3072, R_RSA_4096, R_RSA_7680,
     R_RSA_15360, RSA_NUM
@@ -450,7 +346,6 @@ static const OPT_PAIR rsa_choices[RSA_NUM] = {
 };
 
 static double rsa_results[RSA_NUM][2];  /* 2 ops: sign then verify */
-#endif /* OPENSSL_NO_DEPRECATED_3_0 */
 
 #ifndef OPENSSL_NO_DH
 enum ff_params_t {
@@ -468,13 +363,12 @@ static const OPT_PAIR ffdh_choices[FFDH_NUM] = {
 static double ffdh_results[FFDH_NUM][1];  /* 1 op: derivation */
 #endif /* OPENSSL_NO_DH */
 
-#ifndef OPENSSL_NO_EC
 enum ec_curves_t {
     R_EC_P160, R_EC_P192, R_EC_P224, R_EC_P256, R_EC_P384, R_EC_P521,
-# ifndef OPENSSL_NO_EC2M
+#ifndef OPENSSL_NO_EC2M
     R_EC_K163, R_EC_K233, R_EC_K283, R_EC_K409, R_EC_K571,
     R_EC_B163, R_EC_B233, R_EC_B283, R_EC_B409, R_EC_B571,
-# endif
+#endif
     R_EC_BRP256R1, R_EC_BRP256T1, R_EC_BRP384R1, R_EC_BRP384T1,
     R_EC_BRP512R1, R_EC_BRP512T1, ECDSA_NUM
 };
@@ -486,7 +380,7 @@ static const OPT_PAIR ecdsa_choices[ECDSA_NUM] = {
     {&quot;ecdsap256&quot;, R_EC_P256},
     {&quot;ecdsap384&quot;, R_EC_P384},
     {&quot;ecdsap521&quot;, R_EC_P521},
-# ifndef OPENSSL_NO_EC2M
+#ifndef OPENSSL_NO_EC2M
     {&quot;ecdsak163&quot;, R_EC_K163},
     {&quot;ecdsak233&quot;, R_EC_K233},
     {&quot;ecdsak283&quot;, R_EC_K283},
@@ -497,7 +391,7 @@ static const OPT_PAIR ecdsa_choices[ECDSA_NUM] = {
     {&quot;ecdsab283&quot;, R_EC_B283},
     {&quot;ecdsab409&quot;, R_EC_B409},
     {&quot;ecdsab571&quot;, R_EC_B571},
-# endif
+#endif
     {&quot;ecdsabrp256r1&quot;, R_EC_BRP256R1},
     {&quot;ecdsabrp256t1&quot;, R_EC_BRP256T1},
     {&quot;ecdsabrp384r1&quot;, R_EC_BRP384R1},
@@ -514,7 +408,7 @@ static const OPT_PAIR ecdh_choices[EC_NUM] = {
     {&quot;ecdhp256&quot;, R_EC_P256},
     {&quot;ecdhp384&quot;, R_EC_P384},
     {&quot;ecdhp521&quot;, R_EC_P521},
-# ifndef OPENSSL_NO_EC2M
+#ifndef OPENSSL_NO_EC2M
     {&quot;ecdhk163&quot;, R_EC_K163},
     {&quot;ecdhk233&quot;, R_EC_K233},
     {&quot;ecdhk283&quot;, R_EC_K283},
@@ -525,7 +419,7 @@ static const OPT_PAIR ecdh_choices[EC_NUM] = {
     {&quot;ecdhb283&quot;, R_EC_B283},
     {&quot;ecdhb409&quot;, R_EC_B409},
     {&quot;ecdhb571&quot;, R_EC_B571},
-# endif
+#endif
     {&quot;ecdhbrp256r1&quot;, R_EC_BRP256R1},
     {&quot;ecdhbrp256t1&quot;, R_EC_BRP256T1},
     {&quot;ecdhbrp384r1&quot;, R_EC_BRP384R1},
@@ -547,24 +441,18 @@ static const OPT_PAIR eddsa_choices[EdDSA_NUM] = {
 };
 static double eddsa_results[EdDSA_NUM][2];    /* 2 ops: sign then verify */
 
-# ifndef OPENSSL_NO_SM2
+#ifndef OPENSSL_NO_SM2
 enum { R_EC_CURVESM2, SM2_NUM };
 static const OPT_PAIR sm2_choices[SM2_NUM] = {
     {&quot;curveSM2&quot;, R_EC_CURVESM2}
 };
-#  define SM2_ID        &quot;TLSv1.3+GM+Cipher+Suite&quot;
-#  define SM2_ID_LEN    sizeof(&quot;TLSv1.3+GM+Cipher+Suite&quot;) - 1
+# define SM2_ID        &quot;TLSv1.3+GM+Cipher+Suite&quot;
+# define SM2_ID_LEN    sizeof(&quot;TLSv1.3+GM+Cipher+Suite&quot;) - 1
 static double sm2_results[SM2_NUM][2];    /* 2 ops: sign then verify */
-# endif /* OPENSSL_NO_SM2 */
-#endif /* OPENSSL_NO_EC */
+#endif /* OPENSSL_NO_SM2 */
 
-#ifndef SIGALRM
-# define COND(d) (count &lt; (d))
-# define COUNT(d) (d)
-#else
-# define COND(unused_cond) (run &amp;&amp; count&lt;0x7fffffff)
-# define COUNT(d) (count)
-#endif                          /* SIGALRM */
+#define COND(unused_cond) (run &amp;&amp; count &lt; 0x7fffffff)
+#define COUNT(d) (count)
 
 typedef struct loopargs_st {
     ASYNC_JOB *inprogress_job;
@@ -574,43 +462,31 @@ typedef struct loopargs_st {
     unsigned char *buf_malloc;
     unsigned char *buf2_malloc;
     unsigned char *key;
-    unsigned int siglen;
     size_t sigsize;
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-    RSA *rsa_key[RSA_NUM];
-#endif
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    DSA *dsa_key[DSA_NUM];
-#endif
-#ifndef OPENSSL_NO_EC
-# ifndef OPENSSL_NO_DEPRECATED_3_0
-    EC_KEY *ecdsa[ECDSA_NUM];
-# endif
+    EVP_PKEY_CTX *rsa_sign_ctx[RSA_NUM];
+    EVP_PKEY_CTX *rsa_verify_ctx[RSA_NUM];
+    EVP_PKEY_CTX *dsa_sign_ctx[DSA_NUM];
+    EVP_PKEY_CTX *dsa_verify_ctx[DSA_NUM];
+    EVP_PKEY_CTX *ecdsa_sign_ctx[ECDSA_NUM];
+    EVP_PKEY_CTX *ecdsa_verify_ctx[ECDSA_NUM];
     EVP_PKEY_CTX *ecdh_ctx[EC_NUM];
     EVP_MD_CTX *eddsa_ctx[EdDSA_NUM];
     EVP_MD_CTX *eddsa_ctx2[EdDSA_NUM];
-# ifndef OPENSSL_NO_SM2
+#ifndef OPENSSL_NO_SM2
     EVP_MD_CTX *sm2_ctx[SM2_NUM];
     EVP_MD_CTX *sm2_vfy_ctx[SM2_NUM];
     EVP_PKEY *sm2_pkey[SM2_NUM];
-# endif
+#endif
     unsigned char *secret_a;
     unsigned char *secret_b;
     size_t outlen[EC_NUM];
-#endif
 #ifndef OPENSSL_NO_DH
     EVP_PKEY_CTX *ffdh_ctx[FFDH_NUM];
     unsigned char *secret_ff_a;
     unsigned char *secret_ff_b;
 #endif
     EVP_CIPHER_CTX *ctx;
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-    HMAC_CTX *hctx;
-#endif
-#if !defined(OPENSSL_NO_CMAC) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    CMAC_CTX *cmac_ctx;
-#endif
-    GCM128_CONTEXT *gcm_ctx;
+    EVP_MAC_CTX *mctx;
 } loopargs_t;
 static int run_benchmark(int async_jobs, int (*loop_function) (void *),
                          loopargs_t * loopargs);
@@ -620,277 +496,252 @@ static unsigned int testnum;
 /* Nb of iterations to do per algorithm and key-size */
 static long c[ALGOR_NUM][SIZE_NUM];
 
-#if !defined(OPENSSL_NO_MD2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-static int EVP_Digest_MD2_loop(void *args)
+static char *evp_mac_mdname = &quot;md5&quot;;
+static char *evp_hmac_name = NULL;
+static const char *evp_md_name = NULL;
+static char *evp_mac_ciphername = &quot;aes-128-cbc&quot;;
+static char *evp_cmac_name = NULL;
+
+static EVP_MD *obtain_md(const char *name, int *fetched)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char md2[MD2_DIGEST_LENGTH];
-    int count;
+    EVP_MD *md = NULL;
 
-    for (count = 0; COND(c[D_MD2][testnum]); count++) {
-        if (!EVP_Digest(buf, (size_t)lengths[testnum], md2, NULL, EVP_md2(),
-                        NULL))
-            return -1;
+    *fetched = 0;
+    /* Look through providers' digests */
+    ERR_set_mark();
+    md = EVP_MD_fetch(NULL, name, NULL);
+    ERR_pop_to_mark();
+    if (md != NULL) {
+        *fetched = 1;
+        return md;
     }
-    return count;
+
+    return (EVP_MD *)EVP_get_digestbyname(name);
 }
-#endif
 
-#if !defined(OPENSSL_NO_MDC2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-static int EVP_Digest_MDC2_loop(void *args)
+static int have_md(const char *name)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char mdc2[MDC2_DIGEST_LENGTH];
-    int count;
+    int fetched = 0;
+    int ret = 0;
+    EVP_MD *md = obtain_md(name, &amp;fetched);
 
-    for (count = 0; COND(c[D_MDC2][testnum]); count++) {
-        if (!EVP_Digest(buf, (size_t)lengths[testnum], mdc2, NULL, EVP_mdc2(),
-                        NULL))
-            return -1;
+    if (md != NULL) {
+        EVP_MD_CTX *ctx = EVP_MD_CTX_new();
+
+        if (ctx != NULL &amp;&amp; EVP_DigestInit(ctx, md) &gt; 0)
+            ret = 1;
+        EVP_MD_CTX_free(ctx);
+        if (fetched)
+            EVP_MD_free(md);
     }
-    return count;
+    return ret;
 }
-#endif
 
-#if !defined(OPENSSL_NO_MD4) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-static int EVP_Digest_MD4_loop(void *args)
+static EVP_CIPHER *obtain_cipher(const char *name, int *fetched)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char md4[MD4_DIGEST_LENGTH];
-    int count;
+    EVP_CIPHER *cipher = NULL;
 
-    for (count = 0; COND(c[D_MD4][testnum]); count++) {
-        if (!EVP_Digest(buf, (size_t)lengths[testnum], md4, NULL, EVP_md4(),
-                        NULL))
-            return -1;
+    *fetched = 0;
+    /* Look through providers' digests */
+    ERR_set_mark();
+    cipher = EVP_CIPHER_fetch(NULL, name, NULL);
+    ERR_pop_to_mark();
+    if (cipher != NULL) {
+        *fetched = 1;
+        return cipher;
     }
-    return count;
+
+    return (EVP_CIPHER *)EVP_get_cipherbyname(name);
 }
-#endif
 
-#if !defined(OPENSSL_NO_MD5) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-static int MD5_loop(void *args)
+static int have_cipher(const char *name)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char md5[MD5_DIGEST_LENGTH];
-    int count;
-    for (count = 0; COND(c[D_MD5][testnum]); count++)
-        MD5(buf, lengths[testnum], md5);
-    return count;
+    int fetched = 0;
+    int ret = 0;
+    EVP_CIPHER *cipher = obtain_cipher(name, &amp;fetched);
+
+    if (cipher != NULL) {
+        EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
+
+        if (ctx != NULL
+            &amp;&amp; EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, 1) &gt; 0)
+            ret = 1;
+        EVP_CIPHER_CTX_free(ctx);
+        if (fetched)
+            EVP_CIPHER_free(cipher);
+    }
+    return ret;
 }
 
-# ifndef OPENSSL_NO_DEPRECATED_3_0
-static int HMAC_loop(void *args)
+static int EVP_Digest_loop(const char *mdname, int algindex, void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
-    HMAC_CTX *hctx = tempargs-&gt;hctx;
-    unsigned char hmac[MD5_DIGEST_LENGTH];
-    int count;
-
-    for (count = 0; COND(c[D_HMAC][testnum]); count++) {
-        HMAC_Init_ex(hctx, NULL, 0, NULL, NULL);
-        HMAC_Update(hctx, buf, lengths[testnum]);
-        HMAC_Final(hctx, hmac, NULL);
+    unsigned char digest[EVP_MAX_MD_SIZE];
+    int count, fetched = 0;
+    EVP_MD *md = obtain_md(mdname, &amp;fetched);
+
+    if (md == NULL)
+        return -1;
+    for (count = 0; COND(c[algindex][testnum]); count++) {
+        if (!EVP_Digest(buf, (size_t)lengths[testnum], digest, NULL, md,
+                        NULL)) {
+            count = -1;
+            break;
+        }
     }
+    if (fetched)
+        EVP_MD_free(md);
     return count;
 }
-# endif
-#endif
 
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-static int SHA1_loop(void *args)
+static int EVP_Digest_md_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char sha[SHA_DIGEST_LENGTH];
-    int count;
-    for (count = 0; COND(c[D_SHA1][testnum]); count++)
-        SHA1(buf, lengths[testnum], sha);
-    return count;
+    return EVP_Digest_loop(evp_md_name, D_EVP, args);
 }
 
-static int SHA256_loop(void *args)
+static int EVP_Digest_MD2_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char sha256[SHA256_DIGEST_LENGTH];
-    int count;
-    for (count = 0; COND(c[D_SHA256][testnum]); count++)
-        SHA256(buf, lengths[testnum], sha256);
-    return count;
+    return EVP_Digest_loop(&quot;md2&quot;, D_MD2, args);
 }
 
-static int SHA512_loop(void *args)
+static int EVP_Digest_MDC2_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char sha512[SHA512_DIGEST_LENGTH];
-    int count;
-    for (count = 0; COND(c[D_SHA512][testnum]); count++)
-        SHA512(buf, lengths[testnum], sha512);
-    return count;
+    return EVP_Digest_loop(&quot;mdc2&quot;, D_MDC2, args);
 }
-#endif
 
-#if !defined(OPENSSL_NO_WHIRLPOOL) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-static int WHIRLPOOL_loop(void *args)
+static int EVP_Digest_MD4_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char whirlpool[WHIRLPOOL_DIGEST_LENGTH];
-    int count;
-    for (count = 0; COND(c[D_WHIRLPOOL][testnum]); count++)
-        WHIRLPOOL(buf, lengths[testnum], whirlpool);
-    return count;
+    return EVP_Digest_loop(&quot;md4&quot;, D_MD4, args);
 }
-#endif
 
-#if !defined(OPENSSL_NO_RMD160) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-static int EVP_Digest_RMD160_loop(void *args)
+static int MD5_loop(void *args)
+{
+    return EVP_Digest_loop(&quot;md5&quot;, D_MD5, args);
+}
+
+static int EVP_MAC_loop(int algindex, void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
-    unsigned char rmd160[RIPEMD160_DIGEST_LENGTH];
+    EVP_MAC_CTX *mctx = tempargs-&gt;mctx;
+    unsigned char mac[EVP_MAX_MD_SIZE];
     int count;
-    for (count = 0; COND(c[D_RMD160][testnum]); count++) {
-        if (!EVP_Digest(buf, (size_t)lengths[testnum], &amp;(rmd160[0]),
-                        NULL, EVP_ripemd160(), NULL))
+
+    for (count = 0; COND(c[algindex][testnum]); count++) {
+        size_t outl;
+
+        if (!EVP_MAC_init(mctx)
+            || !EVP_MAC_update(mctx, buf, lengths[testnum])
+            || !EVP_MAC_final(mctx, mac, &amp;outl, sizeof(mac)))
             return -1;
     }
     return count;
 }
-#endif
 
-#if !defined(OPENSSL_NO_RC4) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-static RC4_KEY rc4_ks;
-static int RC4_loop(void *args)
+static int HMAC_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    int count;
-    for (count = 0; COND(c[D_RC4][testnum]); count++)
-        RC4(&amp;rc4_ks, (size_t)lengths[testnum], buf, buf);
-    return count;
+    return EVP_MAC_loop(D_HMAC, args);
 }
-#endif
 
-#if !defined(OPENSSL_NO_DES) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-static unsigned char DES_iv[8];
-static DES_key_schedule sch[3];
-static int DES_ncbc_encrypt_loop(void *args)
+static int CMAC_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    int count;
-    for (count = 0; COND(c[D_CBC_DES][testnum]); count++)
-        DES_ncbc_encrypt(buf, buf, lengths[testnum], &amp;sch[0],
-                         &amp;DES_iv, DES_ENCRYPT);
-    return count;
+    return EVP_MAC_loop(D_EVP_CMAC, args);
 }
 
-static int DES_ede3_cbc_encrypt_loop(void *args)
+static int SHA1_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    int count;
-    for (count = 0; COND(c[D_EDE3_DES][testnum]); count++)
-        DES_ede3_cbc_encrypt(buf, buf, lengths[testnum],
-                             &amp;sch[0], &amp;sch[1], &amp;sch[2], &amp;DES_iv, DES_ENCRYPT);
-    return count;
+    return EVP_Digest_loop(&quot;sha1&quot;, D_SHA1, args);
 }
-#endif
-
-#define MAX_BLOCK_SIZE 128
-
-static unsigned char iv[2 * MAX_BLOCK_SIZE / 8];
 
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-static AES_KEY aes_ks1, aes_ks2, aes_ks3;
-static int AES_cbc_128_encrypt_loop(void *args)
+static int SHA256_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    int count;
-    for (count = 0; COND(c[D_CBC_128_AES][testnum]); count++)
-        AES_cbc_encrypt(buf, buf,
-                        (size_t)lengths[testnum], &amp;aes_ks1, iv, AES_ENCRYPT);
-    return count;
+    return EVP_Digest_loop(&quot;sha256&quot;, D_SHA256, args);
 }
 
-static int AES_cbc_192_encrypt_loop(void *args)
+static int SHA512_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    int count;
-    for (count = 0; COND(c[D_CBC_192_AES][testnum]); count++)
-        AES_cbc_encrypt(buf, buf,
-                        (size_t)lengths[testnum], &amp;aes_ks2, iv, AES_ENCRYPT);
-    return count;
+    return EVP_Digest_loop(&quot;sha512&quot;, D_SHA512, args);
 }
 
-static int AES_cbc_256_encrypt_loop(void *args)
+static int WHIRLPOOL_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    int count;
-    for (count = 0; COND(c[D_CBC_256_AES][testnum]); count++)
-        AES_cbc_encrypt(buf, buf,
-                        (size_t)lengths[testnum], &amp;aes_ks3, iv, AES_ENCRYPT);
-    return count;
+    return EVP_Digest_loop(&quot;whirlpool&quot;, D_WHIRLPOOL, args);
 }
 
-static int AES_ige_128_encrypt_loop(void *args)
+static int EVP_Digest_RMD160_loop(void *args)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char *buf2 = tempargs-&gt;buf2;
-    int count;
-    for (count = 0; COND(c[D_IGE_128_AES][testnum]); count++)
-        AES_ige_encrypt(buf, buf2,
-                        (size_t)lengths[testnum], &amp;aes_ks1, iv, AES_ENCRYPT);
-    return count;
+    return EVP_Digest_loop(&quot;ripemd160&quot;, D_RMD160, args);
 }
 
-static int AES_ige_192_encrypt_loop(void *args)
+static int algindex;
+
+static int EVP_Cipher_loop(void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
-    unsigned char *buf2 = tempargs-&gt;buf2;
     int count;
-    for (count = 0; COND(c[D_IGE_192_AES][testnum]); count++)
-        AES_ige_encrypt(buf, buf2,
-                        (size_t)lengths[testnum], &amp;aes_ks2, iv, AES_ENCRYPT);
+
+    if (tempargs-&gt;ctx == NULL)
+        return -1;
+    for (count = 0; COND(c[algindex][testnum]); count++)
+        if (EVP_Cipher(tempargs-&gt;ctx, buf, buf, (size_t)lengths[testnum]) &lt;= 0)
+            return -1;
     return count;
 }
 
-static int AES_ige_256_encrypt_loop(void *args)
+static int GHASH_loop(void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
-    unsigned char *buf2 = tempargs-&gt;buf2;
+    EVP_MAC_CTX *mctx = tempargs-&gt;mctx;
     int count;
-    for (count = 0; COND(c[D_IGE_256_AES][testnum]); count++)
-        AES_ige_encrypt(buf, buf2,
-                        (size_t)lengths[testnum], &amp;aes_ks3, iv, AES_ENCRYPT);
+
+    /* just do the update in the loop to be comparable with 1.1.1 */
+    for (count = 0; COND(c[D_GHASH][testnum]); count++) {
+        if (!EVP_MAC_update(mctx, buf, lengths[testnum]))
+            return -1;
+    }
     return count;
 }
 
-static int CRYPTO_gcm128_aad_loop(void *args)
+#define MAX_BLOCK_SIZE 128
+
+static unsigned char iv[2 * MAX_BLOCK_SIZE / 8];
+
+static EVP_CIPHER_CTX *init_evp_cipher_ctx(const char *ciphername,
+                                           const unsigned char *key,
+                                           int keylen)
 {
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    GCM128_CONTEXT *gcm_ctx = tempargs-&gt;gcm_ctx;
-    int count;
-    for (count = 0; COND(c[D_GHASH][testnum]); count++)
-        CRYPTO_gcm128_aad(gcm_ctx, buf, lengths[testnum]);
-    return count;
+    EVP_CIPHER_CTX *ctx = NULL;
+    int fetched = 0;
+    EVP_CIPHER *cipher = obtain_cipher(ciphername, &amp;fetched);
+
+    if (cipher == NULL)
+        return NULL;
+
+    if ((ctx = EVP_CIPHER_CTX_new()) == NULL)
+        goto end;
+
+    if (!EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, 1)) {
+        EVP_CIPHER_CTX_free(ctx);
+        ctx = NULL;
+        goto end;
+    }
+
+    EVP_CIPHER_CTX_set_key_length(ctx, keylen);
+
+    if (!EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, 1)) {
+        EVP_CIPHER_CTX_free(ctx);
+        ctx = NULL;
+        goto end;
+    }
+
+end:
+    if (fetched)
+        EVP_CIPHER_free(cipher);
+    return ctx;
 }
-#endif
 
 static int RAND_bytes_loop(void *args)
 {
@@ -1005,100 +856,40 @@ static int EVP_Update_loop_aead(void *args)
     return count;
 }
 
-static EVP_MD *evp_md = NULL;
-static int fetched_alg = 0;
+static long rsa_c[RSA_NUM][2];  /* # RSA iteration test */
 
-static int EVP_Digest_loop(void *args)
+static int RSA_sign_loop(void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
-    unsigned char md[EVP_MAX_MD_SIZE];
-    int count;
+    unsigned char *buf2 = tempargs-&gt;buf2;
+    size_t *rsa_num = &amp;tempargs-&gt;sigsize;
+    EVP_PKEY_CTX **rsa_sign_ctx = tempargs-&gt;rsa_sign_ctx;
+    int ret, count;
 
-    for (count = 0; COND(c[D_EVP][testnum]); count++) {
-        if (!EVP_Digest(buf, lengths[testnum], md, NULL, evp_md, NULL))
-            return -1;
+    for (count = 0; COND(rsa_c[testnum][0]); count++) {
+        ret = EVP_PKEY_sign(rsa_sign_ctx[testnum], buf2, rsa_num, buf, 36);
+        if (ret &lt;= 0) {
+            BIO_printf(bio_err, &quot;RSA sign failure\n&quot;);
+            ERR_print_errors(bio_err);
+            count = -1;
+            break;
+        }
     }
     return count;
 }
 
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-static const EVP_MD *evp_hmac_md = NULL;
-static char *evp_hmac_name = NULL;
-static int EVP_HMAC_loop(void *args)
-{
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char no_key[32];
-    int count;
-
-    for (count = 0; COND(c[D_EVP_HMAC][testnum]); count++) {
-        if (HMAC(evp_hmac_md, no_key, sizeof(no_key), buf, lengths[testnum],
-                 NULL, NULL) == NULL)
-            return -1;
-    }
-    return count;
-}
-#endif
-
-#if !defined(OPENSSL_NO_CMAC) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-static const EVP_CIPHER *evp_cmac_cipher = NULL;
-static char *evp_cmac_name = NULL;
-
-static int EVP_CMAC_loop(void *args)
-{
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    CMAC_CTX *cmac_ctx = tempargs-&gt;cmac_ctx;
-    static const char key[16] = &quot;This is a key...&quot;;
-    unsigned char mac[16];
-    size_t len = sizeof(mac);
-    int count;
-
-    for (count = 0; COND(c[D_EVP_CMAC][testnum]); count++) {
-        if (!CMAC_Init(cmac_ctx, key, sizeof(key), evp_cmac_cipher, NULL)
-                || !CMAC_Update(cmac_ctx, buf, lengths[testnum])
-                || !CMAC_Final(cmac_ctx, mac, &amp;len))
-            return -1;
-    }
-    return count;
-}
-#endif
-
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-static long rsa_c[RSA_NUM][2];  /* # RSA iteration test */
-
-static int RSA_sign_loop(void *args)
+static int RSA_verify_loop(void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
-    unsigned int *rsa_num = &amp;tempargs-&gt;siglen;
-    RSA **rsa_key = tempargs-&gt;rsa_key;
+    size_t rsa_num = tempargs-&gt;sigsize;
+    EVP_PKEY_CTX **rsa_verify_ctx = tempargs-&gt;rsa_verify_ctx;
     int ret, count;
-    for (count = 0; COND(rsa_c[testnum][0]); count++) {
-        ret = RSA_sign(NID_md5_sha1, buf, 36, buf2, rsa_num, rsa_key[testnum]);
-        if (ret == 0) {
-            BIO_printf(bio_err, &quot;RSA sign failure\n&quot;);
-            ERR_print_errors(bio_err);
-            count = -1;
-            break;
-        }
-    }
-    return count;
-}
 
-static int RSA_verify_loop(void *args)
-{
-    loopargs_t *tempargs = *(loopargs_t **) args;
-    unsigned char *buf = tempargs-&gt;buf;
-    unsigned char *buf2 = tempargs-&gt;buf2;
-    unsigned int rsa_num = tempargs-&gt;siglen;
-    RSA **rsa_key = tempargs-&gt;rsa_key;
-    int ret, count;
     for (count = 0; COND(rsa_c[testnum][1]); count++) {
-        ret =
-            RSA_verify(NID_md5_sha1, buf, 36, buf2, rsa_num, rsa_key[testnum]);
+        ret = EVP_PKEY_verify(rsa_verify_ctx[testnum], buf2, rsa_num, buf, 36);
         if (ret &lt;= 0) {
             BIO_printf(bio_err, &quot;RSA verify failure\n&quot;);
             ERR_print_errors(bio_err);
@@ -1108,39 +899,37 @@ static int RSA_verify_loop(void *args)
     }
     return count;
 }
-#endif
 
 #ifndef OPENSSL_NO_DH
 static long ffdh_c[FFDH_NUM][1];
 
 static int FFDH_derive_key_loop(void *args)
 {
-        loopargs_t *tempargs = *(loopargs_t **) args;
-        EVP_PKEY_CTX *ffdh_ctx = tempargs-&gt;ffdh_ctx[testnum];
-        unsigned char *derived_secret = tempargs-&gt;secret_ff_a;
-        size_t outlen = MAX_FFDH_SIZE;
-        int count;
-
-        for (count = 0; COND(ffdh_c[testnum][0]); count++)
-            EVP_PKEY_derive(ffdh_ctx, derived_secret, &amp;outlen);
+    loopargs_t *tempargs = *(loopargs_t **) args;
+    EVP_PKEY_CTX *ffdh_ctx = tempargs-&gt;ffdh_ctx[testnum];
+    unsigned char *derived_secret = tempargs-&gt;secret_ff_a;
+    size_t outlen = MAX_FFDH_SIZE;
+    int count;
 
-        return count;
+    for (count = 0; COND(ffdh_c[testnum][0]); count++)
+        EVP_PKEY_derive(ffdh_ctx, derived_secret, &amp;outlen);
+    return count;
 }
 #endif /* OPENSSL_NO_DH */
 
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
 static long dsa_c[DSA_NUM][2];
 static int DSA_sign_loop(void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
-    DSA **dsa_key = tempargs-&gt;dsa_key;
-    unsigned int *siglen = &amp;tempargs-&gt;siglen;
+    size_t *dsa_num = &amp;tempargs-&gt;sigsize;
+    EVP_PKEY_CTX **dsa_sign_ctx = tempargs-&gt;dsa_sign_ctx;
     int ret, count;
+
     for (count = 0; COND(dsa_c[testnum][0]); count++) {
-        ret = DSA_sign(0, buf, 20, buf2, siglen, dsa_key[testnum]);
-        if (ret == 0) {
+        ret = EVP_PKEY_sign(dsa_sign_ctx[testnum], buf2, dsa_num, buf, 20);
+        if (ret &lt;= 0) {
             BIO_printf(bio_err, &quot;DSA sign failure\n&quot;);
             ERR_print_errors(bio_err);
             count = -1;
@@ -1155,11 +944,12 @@ static int DSA_verify_loop(void *args)
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
-    DSA **dsa_key = tempargs-&gt;dsa_key;
-    unsigned int siglen = tempargs-&gt;siglen;
+    size_t dsa_num = tempargs-&gt;sigsize;
+    EVP_PKEY_CTX **dsa_verify_ctx = tempargs-&gt;dsa_verify_ctx;
     int ret, count;
+
     for (count = 0; COND(dsa_c[testnum][1]); count++) {
-        ret = DSA_verify(0, buf, 20, buf2, siglen, dsa_key[testnum]);
+        ret = EVP_PKEY_verify(dsa_verify_ctx[testnum], buf2, dsa_num, buf, 20);
         if (ret &lt;= 0) {
             BIO_printf(bio_err, &quot;DSA verify failure\n&quot;);
             ERR_print_errors(bio_err);
@@ -1169,22 +959,20 @@ static int DSA_verify_loop(void *args)
     }
     return count;
 }
-#endif
 
-#ifndef OPENSSL_NO_EC
-# ifndef OPENSSL_NO_DEPRECATED_3_0
 static long ecdsa_c[ECDSA_NUM][2];
 static int ECDSA_sign_loop(void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
-    EC_KEY **ecdsa = tempargs-&gt;ecdsa;
-    unsigned char *ecdsasig = tempargs-&gt;buf2;
-    unsigned int *ecdsasiglen = &amp;tempargs-&gt;siglen;
+    unsigned char *buf2 = tempargs-&gt;buf2;
+    size_t *ecdsa_num = &amp;tempargs-&gt;sigsize;
+    EVP_PKEY_CTX **ecdsa_sign_ctx = tempargs-&gt;ecdsa_sign_ctx;
     int ret, count;
+
     for (count = 0; COND(ecdsa_c[testnum][0]); count++) {
-        ret = ECDSA_sign(0, buf, 20, ecdsasig, ecdsasiglen, ecdsa[testnum]);
-        if (ret == 0) {
+        ret = EVP_PKEY_sign(ecdsa_sign_ctx[testnum], buf2, ecdsa_num, buf, 20);
+        if (ret &lt;= 0) {
             BIO_printf(bio_err, &quot;ECDSA sign failure\n&quot;);
             ERR_print_errors(bio_err);
             count = -1;
@@ -1198,13 +986,15 @@ static int ECDSA_verify_loop(void *args)
 {
     loopargs_t *tempargs = *(loopargs_t **) args;
     unsigned char *buf = tempargs-&gt;buf;
-    EC_KEY **ecdsa = tempargs-&gt;ecdsa;
-    unsigned char *ecdsasig = tempargs-&gt;buf2;
-    unsigned int ecdsasiglen = tempargs-&gt;siglen;
+    unsigned char *buf2 = tempargs-&gt;buf2;
+    size_t ecdsa_num = tempargs-&gt;sigsize;
+    EVP_PKEY_CTX **ecdsa_verify_ctx = tempargs-&gt;ecdsa_verify_ctx;
     int ret, count;
+
     for (count = 0; COND(ecdsa_c[testnum][1]); count++) {
-        ret = ECDSA_verify(0, buf, 20, ecdsasig, ecdsasiglen, ecdsa[testnum]);
-        if (ret != 1) {
+        ret = EVP_PKEY_verify(ecdsa_verify_ctx[testnum], buf2, ecdsa_num,
+                              buf, 20);
+        if (ret &lt;= 0) {
             BIO_printf(bio_err, &quot;ECDSA verify failure\n&quot;);
             ERR_print_errors(bio_err);
             count = -1;
@@ -1213,7 +1003,6 @@ static int ECDSA_verify_loop(void *args)
     }
     return count;
 }
-# endif
 
 /* ******************************************************************** */
 static long ecdh_c[EC_NUM][1];
@@ -1275,7 +1064,7 @@ static int EdDSA_verify_loop(void *args)
     return count;
 }
 
-# ifndef OPENSSL_NO_SM2
+#ifndef OPENSSL_NO_SM2
 static long sm2_c[SM2_NUM][2];
 static int SM2_sign_loop(void *args)
 {
@@ -1342,8 +1131,7 @@ static int SM2_verify_loop(void *args)
     }
     return count;
 }
-# endif                         /* OPENSSL_NO_SM2 */
-#endif                          /* OPENSSL_NO_EC */
+#endif                         /* OPENSSL_NO_SM2 */
 
 static int run_benchmark(int async_jobs,
                          int (*loop_function) (void *), loopargs_t * loopargs)
@@ -1496,36 +1284,84 @@ static int run_benchmark(int async_jobs,
     return error ? -1 : total_op_count;
 }
 
-static EVP_MD *obtain_md(const char *name)
+typedef struct ec_curve_st {
+    const char *name;
+    unsigned int nid;
+    unsigned int bits;
+    size_t sigsize; /* only used for EdDSA curves */
+} EC_CURVE;
+
+static EVP_PKEY *get_ecdsa(const EC_CURVE *curve)
 {
-    EVP_MD *md = NULL;
+    EVP_PKEY_CTX *kctx = NULL;
+    EVP_PKEY *key = NULL;
 
-    /* Look through providers' digests */
-    ERR_set_mark();
-    md = EVP_MD_fetch(NULL, name, NULL);
-    ERR_pop_to_mark();
-    if (md != NULL) {
-        fetched_alg = 1;
-        return md;
+    /* Ensure that the error queue is empty */
+    if (ERR_peek_error()) {
+        BIO_printf(bio_err,
+                   &quot;WARNING: the error queue contains previous unhandled errors.\n&quot;);
+        ERR_print_errors(bio_err);
     }
 
-    return (EVP_MD *)EVP_get_digestbyname(name);
-}
+    /*
+     * Let's try to create a ctx directly from the NID: this works for
+     * curves like Curve25519 that are not implemented through the low
+     * level EC interface.
+     * If this fails we try creating a EVP_PKEY_EC generic param ctx,
+     * then we set the curve by NID before deriving the actual keygen
+     * ctx for that specific curve.
+     */
+    kctx = EVP_PKEY_CTX_new_id(curve-&gt;nid, NULL);
+    if (kctx == NULL) {
+        EVP_PKEY_CTX *pctx = NULL;
+        EVP_PKEY *params = NULL;
+        /*
+         * If we reach this code EVP_PKEY_CTX_new_id() failed and a
+         * &quot;int_ctx_new:unsupported algorithm&quot; error was added to the
+         * error queue.
+         * We remove it from the error queue as we are handling it.
+         */
+        unsigned long error = ERR_peek_error();
+
+        if (error == ERR_peek_last_error() /* oldest and latest errors match */
+            /* check that the error origin matches */
+            &amp;&amp; ERR_GET_LIB(error) == ERR_LIB_EVP
+            &amp;&amp; (ERR_GET_REASON(error) == EVP_R_UNSUPPORTED_ALGORITHM
+                || ERR_GET_REASON(error) == ERR_R_UNSUPPORTED))
+            ERR_get_error(); /* pop error from queue */
+        if (ERR_peek_error()) {
+            BIO_printf(bio_err,
+                       &quot;Unhandled error in the error queue during EC key setup.\n&quot;);
+            ERR_print_errors(bio_err);
+            return NULL;
+        }
 
-static EVP_CIPHER *obtain_cipher(const char *name)
-{
-    EVP_CIPHER *cipher = NULL;
+        /* Create the context for parameter generation */
+        if ((pctx = EVP_PKEY_CTX_new_from_name(NULL, &quot;EC&quot;, NULL)) == NULL
+            || EVP_PKEY_paramgen_init(pctx) &lt;= 0
+            || EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx,
+                                                      curve-&gt;nid) &lt;= 0
+            || EVP_PKEY_paramgen(pctx, &amp;params) &lt;= 0) {
+            BIO_printf(bio_err, &quot;EC params init failure.\n&quot;);
+            ERR_print_errors(bio_err);
+            EVP_PKEY_CTX_free(pctx);
+            return NULL;
+        }
+        EVP_PKEY_CTX_free(pctx);
 
-    /* Look through providers' ciphers */
-    ERR_set_mark();
-    cipher = EVP_CIPHER_fetch(NULL, name, NULL);
-    ERR_pop_to_mark();
-    if (cipher != NULL) {
-        fetched_alg = 1;
-        return cipher;
+        /* Create the context for the key generation */
+        kctx = EVP_PKEY_CTX_new(params, NULL);
+        EVP_PKEY_free(params);
     }
-
-    return (EVP_CIPHER *)EVP_get_cipherbyname(name);
+    if (kctx == NULL
+        || EVP_PKEY_keygen_init(kctx) &lt;= 0
+        || EVP_PKEY_keygen(kctx, &amp;key) &lt;= 0) {
+        BIO_printf(bio_err, &quot;EC key generation failure.\n&quot;);
+        ERR_print_errors(bio_err);
+        key = NULL;
+    }
+    EVP_PKEY_CTX_free(kctx);
+    return key;
 }
 
 #define stop_it(do_it, test_num)\
@@ -1548,60 +1384,29 @@ int speed_main(int argc, char **argv)
     unsigned int i, k, loopargs_len = 0, async_jobs = 0;
     int keylen;
     int buflen;
+    int fetched_cipher = 0;
+    BIGNUM *bn = NULL;
+    EVP_PKEY_CTX *genctx = NULL;
 #ifndef NO_FORK
     int multi = 0;
 #endif
-#if !defined(OPENSSL_NO_DEPRECATED_3_0)         \
-    || !defined(OPENSSL_NO_DSA)                 \
-    || !defined(OPENSSL_NO_DH)                  \
-    || !defined(OPENSSL_NO_EC)
-     long op_count = 1;
-#endif
+    long op_count = 1;
     openssl_speed_sec_t seconds = { SECONDS, RSA_SECONDS, DSA_SECONDS,
                                     ECDSA_SECONDS, ECDH_SECONDS,
                                     EdDSA_SECONDS, SM2_SECONDS,
                                     FFDH_SECONDS };
 
-    /* What follows are the buffers and key material. */
-#if !defined(OPENSSL_NO_RC5) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    RC5_32_KEY rc5_ks;
-#endif
-#if !defined(OPENSSL_NO_RC2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    RC2_KEY rc2_ks;
-#endif
-#if !defined(OPENSSL_NO_IDEA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    IDEA_KEY_SCHEDULE idea_ks;
-#endif
-#if !defined(OPENSSL_NO_SEED) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    SEED_KEY_SCHEDULE seed_ks;
-#endif
-#if !defined(OPENSSL_NO_BF) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    BF_KEY bf_ks;
-#endif
-#if !defined(OPENSSL_NO_CAST) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    CAST_KEY cast_ks;
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-    static const unsigned char key16[16] = {
-        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
-        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12
-    };
-    static const unsigned char key24[24] = {
-        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
-        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
-        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34
-    };
     static const unsigned char key32[32] = {
         0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
         0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,
         0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,
         0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56
     };
-#endif
-#if !defined(OPENSSL_NO_CAMELLIA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    CAMELLIA_KEY camellia_ks[3];
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
+    static const unsigned char deskey[] = {
+        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, /* key1 */
+        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, /* key2 */
+        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34  /* key3 */
+    };
     static const struct {
         const unsigned char *data;
         unsigned int length;
@@ -1611,13 +1416,12 @@ int speed_main(int argc, char **argv)
         {  test1024,  sizeof(test1024),  1024 },
         {  test2048,  sizeof(test2048),  2048 },
         {  test3072,  sizeof(test3072),  3072 },
-        {  test4096,  sizeof(test4096),  4092 },
+        {  test4096,  sizeof(test4096),  4096 },
         {  test7680,  sizeof(test7680),  7680 },
         { test15360, sizeof(test15360), 15360 }
     };
     uint8_t rsa_doit[RSA_NUM] = { 0 };
     int primes = RSA_DEFAULT_PRIME_NUM;
-#endif
 #ifndef OPENSSL_NO_DH
     typedef struct ffdh_params_st {
         const char *name;
@@ -1635,17 +1439,8 @@ int speed_main(int argc, char **argv)
     uint8_t ffdh_doit[FFDH_NUM] = { 0 };
 
 #endif /* OPENSSL_NO_DH */
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     static const unsigned int dsa_bits[DSA_NUM] = { 512, 1024, 2048 };
     uint8_t dsa_doit[DSA_NUM] = { 0 };
-#endif
-#ifndef OPENSSL_NO_EC
-    typedef struct ec_curve_st {
-        const char *name;
-        unsigned int nid;
-        unsigned int bits;
-        size_t sigsize; /* only used for EdDSA curves */
-    } EC_CURVE;
     /*
      * We only test over the following curves as they are representative, To
      * add tests over more curves, simply add the curve NID and curve name to
@@ -1660,7 +1455,7 @@ int speed_main(int argc, char **argv)
         {&quot;nistp256&quot;, NID_X9_62_prime256v1, 256},
         {&quot;nistp384&quot;, NID_secp384r1, 384},
         {&quot;nistp521&quot;, NID_secp521r1, 521},
-# ifndef OPENSSL_NO_EC2M
+#ifndef OPENSSL_NO_EC2M
         /* Binary Curves */
         {&quot;nistk163&quot;, NID_sect163k1, 163},
         {&quot;nistk233&quot;, NID_sect233k1, 233},
@@ -1672,7 +1467,7 @@ int speed_main(int argc, char **argv)
         {&quot;nistb283&quot;, NID_sect283r1, 283},
         {&quot;nistb409&quot;, NID_sect409r1, 409},
         {&quot;nistb571&quot;, NID_sect571r1, 571},
-# endif
+#endif
         {&quot;brainpoolP256r1&quot;, NID_brainpoolP256r1, 256},
         {&quot;brainpoolP256t1&quot;, NID_brainpoolP256t1, 256},
         {&quot;brainpoolP384r1&quot;, NID_brainpoolP384r1, 384},
@@ -1688,13 +1483,13 @@ int speed_main(int argc, char **argv)
         {&quot;Ed25519&quot;, NID_ED25519, 253, 64},
         {&quot;Ed448&quot;, NID_ED448, 456, 114}
     };
-# ifndef OPENSSL_NO_SM2
+#ifndef OPENSSL_NO_SM2
     static const EC_CURVE sm2_curves[SM2_NUM] = {
         /* SM2 */
         {&quot;CurveSM2&quot;, NID_sm2, 256}
     };
     uint8_t sm2_doit[SM2_NUM] = { 0 };
-# endif
+#endif
     uint8_t ecdsa_doit[ECDSA_NUM] = { 0 };
     uint8_t ecdh_doit[EC_NUM] = { 0 };
     uint8_t eddsa_doit[EdDSA_NUM] = { 0 };
@@ -1709,11 +1504,10 @@ int speed_main(int argc, char **argv)
     OPENSSL_assert(ec_curves[ECDSA_NUM - 1].nid == NID_brainpoolP512t1);
     OPENSSL_assert(strcmp(ecdsa_choices[ECDSA_NUM - 1].name, &quot;ecdsabrp512t1&quot;) == 0);
 
-# ifndef OPENSSL_NO_SM2
+#ifndef OPENSSL_NO_SM2
     OPENSSL_assert(sm2_curves[SM2_NUM - 1].nid == NID_sm2);
     OPENSSL_assert(strcmp(sm2_choices[SM2_NUM - 1].name, &quot;curveSM2&quot;) == 0);
-# endif
-#endif                          /* ndef OPENSSL_NO_EC */
+#endif
 
     prog = opt_init(argc, argv, speed_options);
     while ((o = opt_next()) != OPT_EOF) {
@@ -1735,11 +1529,12 @@ int speed_main(int argc, char **argv)
                 BIO_printf(bio_err, &quot;%s: -evp option cannot be used more than once\n&quot;, prog);
                 goto opterr;
             }
-            evp_md = NULL;
-            evp_cipher = obtain_cipher(opt_arg());
-            if (evp_cipher == NULL)
-                evp_md = obtain_md(opt_arg());
-            if (evp_cipher == NULL &amp;&amp; evp_md == NULL) {
+            evp_cipher = obtain_cipher(opt_arg(), &amp;fetched_cipher);
+            if (evp_cipher == NULL) {
+                if (have_md(opt_arg()))
+                    evp_md_name = opt_arg();
+            }
+            if (evp_cipher == NULL &amp;&amp; evp_md_name == NULL) {
                 BIO_printf(bio_err,
                            &quot;%s: %s is an unknown cipher or digest\n&quot;,
                            prog, opt_arg());
@@ -1748,26 +1543,22 @@ int speed_main(int argc, char **argv)
             doit[D_EVP] = 1;
             break;
         case OPT_HMAC:
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-            evp_hmac_md = EVP_get_digestbyname(opt_arg());
-            if (evp_hmac_md == NULL) {
+            if (!have_md(opt_arg())) {
                 BIO_printf(bio_err, &quot;%s: %s is an unknown digest\n&quot;,
                            prog, opt_arg());
                 goto end;
             }
-            doit[D_EVP_HMAC] = 1;
+            evp_mac_mdname = opt_arg();
+            doit[D_HMAC] = 1;
             break;
-#endif
         case OPT_CMAC:
-#if !defined(OPENSSL_NO_CMAC) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-            evp_cmac_cipher = EVP_get_cipherbyname(opt_arg());
-            if (evp_cmac_cipher == NULL) {
+            if (!have_cipher(opt_arg())) {
                 BIO_printf(bio_err, &quot;%s: %s is an unknown cipher\n&quot;,
                            prog, opt_arg());
                 goto end;
             }
+            evp_mac_ciphername = opt_arg();
             doit[D_EVP_CMAC] = 1;
-#endif
             break;
         case OPT_DECRYPT:
             decrypt = 1;
@@ -1830,10 +1621,8 @@ int speed_main(int argc, char **argv)
                 goto end;
             break;
         case OPT_PRIMES:
-#ifndef OPENSSL_NO_DEPRECATED_3_0
             if (!opt_int(opt_arg(), &amp;primes))
                 goto end;
-#endif
             break;
         case OPT_SECONDS:
             seconds.sym = seconds.rsa = seconds.dsa = seconds.ecdsa
@@ -1863,12 +1652,10 @@ int speed_main(int argc, char **argv)
             doit[i] = 1;
             continue;
         }
-#if !defined(OPENSSL_NO_DES) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
         if (strcmp(algo, &quot;des&quot;) == 0) {
             doit[D_CBC_DES] = doit[D_EDE3_DES] = 1;
             continue;
         }
-#endif
         if (strcmp(algo, &quot;sha&quot;) == 0) {
             doit[D_SHA1] = doit[D_SHA256] = doit[D_SHA512] = 1;
             continue;
@@ -1876,6 +1663,7 @@ int speed_main(int argc, char **argv)
 #ifndef OPENSSL_NO_DEPRECATED_3_0
         if (strcmp(algo, &quot;openssl&quot;) == 0) /* just for compatibility */
             continue;
+#endif
         if (strncmp(algo, &quot;rsa&quot;, 3) == 0) {
             if (algo[3] == '\0') {
                 memset(rsa_doit, 1, sizeof(rsa_doit));
@@ -1886,7 +1674,6 @@ int speed_main(int argc, char **argv)
                 continue;
             }
         }
-#endif
 #ifndef OPENSSL_NO_DH
         if (strncmp(algo, &quot;ffdh&quot;, 4) == 0) {
             if (algo[4] == '\0') {
@@ -1899,7 +1686,6 @@ int speed_main(int argc, char **argv)
             }
         }
 #endif
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
         if (strncmp(algo, &quot;dsa&quot;, 3) == 0) {
             if (algo[3] == '\0') {
                 memset(dsa_doit, 1, sizeof(dsa_doit));
@@ -1910,20 +1696,14 @@ int speed_main(int argc, char **argv)
                 continue;
             }
         }
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
         if (strcmp(algo, &quot;aes&quot;) == 0) {
             doit[D_CBC_128_AES] = doit[D_CBC_192_AES] = doit[D_CBC_256_AES] = 1;
             continue;
         }
-#endif
-#if !defined(OPENSSL_NO_CAMELLIA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
         if (strcmp(algo, &quot;camellia&quot;) == 0) {
             doit[D_CBC_128_CML] = doit[D_CBC_192_CML] = doit[D_CBC_256_CML] = 1;
             continue;
         }
-#endif
-#ifndef OPENSSL_NO_EC
         if (strncmp(algo, &quot;ecdsa&quot;, 5) == 0) {
             if (algo[5] == '\0') {
                 memset(ecdsa_doit, 1, sizeof(ecdsa_doit));
@@ -1952,7 +1732,7 @@ int speed_main(int argc, char **argv)
             eddsa_doit[i] = 2;
             continue;
         }
-# ifndef OPENSSL_NO_SM2
+#ifndef OPENSSL_NO_SM2
         if (strcmp(algo, &quot;sm2&quot;) == 0) {
             memset(sm2_doit, 1, sizeof(sm2_doit));
             continue;
@@ -1961,8 +1741,7 @@ int speed_main(int argc, char **argv)
             sm2_doit[i] = 2;
             continue;
         }
-# endif
-#endif  /* OPENSSL_NO_EC */
+#endif
         BIO_printf(bio_err, &quot;%s: Unknown algorithm %s\n&quot;, prog, algo);
         goto end;
     }
@@ -1981,8 +1760,8 @@ int speed_main(int argc, char **argv)
     }
     if (multiblock) {
         if (evp_cipher == NULL) {
-            BIO_printf(bio_err,&quot;-mb can be used only with a multi-block&quot;
-                               &quot; capable cipher\n&quot;);
+            BIO_printf(bio_err, &quot;-mb can be used only with a multi-block&quot;
+                                &quot; capable cipher\n&quot;);
             goto end;
         } else if (!(EVP_CIPHER_flags(evp_cipher) &amp;
                      EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) {
@@ -2030,10 +1809,8 @@ int speed_main(int argc, char **argv)
         /* Align the start of buffers on a 64 byte boundary */
         loopargs[i].buf = loopargs[i].buf_malloc + misalign;
         loopargs[i].buf2 = loopargs[i].buf2_malloc + misalign;
-#ifndef OPENSSL_NO_EC
         loopargs[i].secret_a = app_malloc(MAX_ECDH_SIZE, &quot;ECDH secret a&quot;);
         loopargs[i].secret_b = app_malloc(MAX_ECDH_SIZE, &quot;ECDH secret b&quot;);
-#endif
 #ifndef OPENSSL_NO_DH
         loopargs[i].secret_ff_a = app_malloc(MAX_FFDH_SIZE, &quot;FFDH secret a&quot;);
         loopargs[i].secret_ff_b = app_malloc(MAX_FFDH_SIZE, &quot;FFDH secret b&quot;);
@@ -2049,34 +1826,39 @@ int speed_main(int argc, char **argv)
     e = setup_engine(engine_id, 0);
 
     /* No parameters; turn on everything. */
-    if (argc == 0 &amp;&amp; !doit[D_EVP] &amp;&amp; !doit[D_EVP_HMAC] &amp;&amp; !doit[D_EVP_CMAC]) {
+    if (argc == 0 &amp;&amp; !doit[D_EVP] &amp;&amp; !doit[D_HMAC] &amp;&amp; !doit[D_EVP_CMAC]) {
+        EVP_MAC *mac;
+
         memset(doit, 1, sizeof(doit));
-        doit[D_EVP] = doit[D_EVP_HMAC] = doit[D_EVP_CMAC] = 0;
-#if !defined(OPENSSL_NO_MDC2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-        doit[D_MDC2] = 0;
-#endif
-#if !defined(OPENSSL_NO_MD4) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-        doit[D_MD4] = 0;
-#endif
-#if !defined(OPENSSL_NO_RMD160) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-        doit[D_RMD160] = 0;
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
+        doit[D_EVP] = doit[D_EVP_CMAC] = 0;
+        ERR_set_mark();
+        for (i = D_MD2; i &lt;= D_WHIRLPOOL; i++) {
+            if (!have_md(names[i]))
+                doit[i] = 0;
+        }
+        for (i = D_CBC_DES; i &lt;= D_CBC_256_CML; i++) {
+            if (!have_cipher(names[i]))
+                doit[i] = 0;
+        }
+        if ((mac = EVP_MAC_fetch(NULL, &quot;GMAC&quot;, NULL)) != NULL)
+            EVP_MAC_free(mac);
+        else
+            doit[D_GHASH] = 0;
+        if ((mac = EVP_MAC_fetch(NULL, &quot;HMAC&quot;, NULL)) != NULL)
+            EVP_MAC_free(mac);
+        else
+            doit[D_HMAC] = 0;
+        ERR_pop_to_mark();
         memset(rsa_doit, 1, sizeof(rsa_doit));
-#endif
 #ifndef OPENSSL_NO_DH
         memset(ffdh_doit, 1, sizeof(ffdh_doit));
 #endif
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
         memset(dsa_doit, 1, sizeof(dsa_doit));
-#endif
-#ifndef OPENSSL_NO_EC
         memset(ecdsa_doit, 1, sizeof(ecdsa_doit));
         memset(ecdh_doit, 1, sizeof(ecdh_doit));
         memset(eddsa_doit, 1, sizeof(eddsa_doit));
-# ifndef OPENSSL_NO_SM2
+#ifndef OPENSSL_NO_SM2
         memset(sm2_doit, 1, sizeof(sm2_doit));
-# endif
 #endif
     }
     for (i = 0; i &lt; ALGOR_NUM; i++)
@@ -2088,348 +1870,10 @@ int speed_main(int argc, char **argv)
                    &quot;You have chosen to measure elapsed time &quot;
                    &quot;instead of user CPU time.\n&quot;);
 
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-    for (i = 0; i &lt; loopargs_len; i++) {
-        if (primes &gt; RSA_DEFAULT_PRIME_NUM) {
-            /* for multi-prime RSA, skip this */
-            break;
-        }
-        for (k = 0; k &lt; RSA_NUM; k++) {
-            const unsigned char *p = rsa_keys[k].data;
-
-            loopargs[i].rsa_key[k] =
-                d2i_RSAPrivateKey(NULL, &amp;p, rsa_keys[k].length);
-            if (loopargs[i].rsa_key[k] == NULL) {
-                BIO_printf(bio_err,
-                           &quot;internal error loading RSA key number %d\n&quot;, k);
-                goto end;
-            }
-        }
-    }
-#endif
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    for (i = 0; i &lt; loopargs_len; i++) {
-        loopargs[i].dsa_key[0] = get_dsa(512);
-        loopargs[i].dsa_key[1] = get_dsa(1024);
-        loopargs[i].dsa_key[2] = get_dsa(2048);
-    }
-#endif
-#if !defined(OPENSSL_NO_DES) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_DES] || doit[D_EDE3_DES]) {
-        static DES_cblock keys[] = {
-            { 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0 }, /* keys[0] */
-            { 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12 }, /* keys[1] */
-            { 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34 }  /* keys[3] */
-        };
-        DES_set_key_unchecked(&amp;keys[0], &amp;sch[0]);
-        DES_set_key_unchecked(&amp;keys[1], &amp;sch[1]);
-        DES_set_key_unchecked(&amp;keys[2], &amp;sch[2]);
-    }
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-    AES_set_encrypt_key(key16, 128, &amp;aes_ks1);
-    AES_set_encrypt_key(key24, 192, &amp;aes_ks2);
-    AES_set_encrypt_key(key32, 256, &amp;aes_ks3);
-#endif
-#if !defined(OPENSSL_NO_CAMELLIA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_128_CML] || doit[D_CBC_192_CML] || doit[D_CBC_256_CML]) {
-        Camellia_set_key(key16, 128, &amp;camellia_ks[0]);
-        Camellia_set_key(key24, 192, &amp;camellia_ks[1]);
-        Camellia_set_key(key32, 256, &amp;camellia_ks[2]);
-    }
-#endif
-#if !defined(OPENSSL_NO_IDEA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_IDEA])
-        IDEA_set_encrypt_key(key16, &amp;idea_ks);
-#endif
-#if !defined(OPENSSL_NO_SEED) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_SEED])
-        SEED_set_key(key16, &amp;seed_ks);
-#endif
-#if !defined(OPENSSL_NO_RC4) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_RC4])
-        RC4_set_key(&amp;rc4_ks, 16, key16);
-#endif
-#if !defined(OPENSSL_NO_RC2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_RC2])
-        RC2_set_key(&amp;rc2_ks, 16, key16, 128);
-#endif
-#if !defined(OPENSSL_NO_RC5) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_RC5])
-        if (!RC5_32_set_key(&amp;rc5_ks, 16, key16, 12)) {
-            BIO_printf(bio_err, &quot;Failed setting RC5 key\n&quot;);
-            goto end;
-        }
-#endif
-#if !defined(OPENSSL_NO_BF) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_BF])
-        BF_set_key(&amp;bf_ks, 16, key16);
-#endif
-#if !defined(OPENSSL_NO_CAST) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_CAST]) 
-        CAST_set_key(&amp;cast_ks, 16, key16);
-#endif
-#ifndef SIGALRM
-#if !defined(OPENSSL_NO_DES) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    BIO_printf(bio_err, &quot;First we calculate the approximate speed ...\n&quot;);
-    count = 10;
-    do {
-        long it;
-        count *= 2;
-        Time_F(START);
-        for (it = count; it; it--)
-            DES_ecb_encrypt((DES_cblock *)loopargs[0].buf,
-                            (DES_cblock *)loopargs[0].buf, &amp;sch, DES_ENCRYPT);
-        d = Time_F(STOP);
-    } while (d &lt; 3);
-    c[D_MD2][0] = count / 10;
-    c[D_MDC2][0] = count / 10;
-    c[D_MD4][0] = count;
-    c[D_MD5][0] = count;
-    c[D_HMAC][0] = count;
-    c[D_SHA1][0] = count;
-    c[D_RMD160][0] = count;
-    c[D_RC4][0] = count * 5;
-    c[D_CBC_DES][0] = count;
-    c[D_EDE3_DES][0] = count / 3;
-    c[D_CBC_IDEA][0] = count;
-    c[D_CBC_SEED][0] = count;
-    c[D_CBC_RC2][0] = count;
-    c[D_CBC_RC5][0] = count;
-    c[D_CBC_BF][0] = count;
-    c[D_CBC_CAST][0] = count;
-    c[D_CBC_128_AES][0] = count;
-    c[D_CBC_192_AES][0] = count;
-    c[D_CBC_256_AES][0] = count;
-    c[D_CBC_128_CML][0] = count;
-    c[D_CBC_192_CML][0] = count;
-    c[D_CBC_256_CML][0] = count;
-    c[D_EVP][0] = count;
-    c[D_SHA256][0] = count;
-    c[D_SHA512][0] = count;
-    c[D_WHIRLPOOL][0] = count;
-    c[D_IGE_128_AES][0] = count;
-    c[D_IGE_192_AES][0] = count;
-    c[D_IGE_256_AES][0] = count;
-    c[D_GHASH][0] = count;
-    c[D_RAND][0] = count;
-    c[D_EVP_HMAC][0] = count;
-    c[D_EVP_CMAC][0] = count;
-
-    for (i = 1; i &lt; size_num; i++) {
-        long l0 = (long)lengths[0];
-        long l1 = (long)lengths[i];
-
-        c[D_MD2][i] = c[D_MD2][0] * 4 * l0 / l1;
-        c[D_MDC2][i] = c[D_MDC2][0] * 4 * l0 / l1;
-        c[D_MD4][i] = c[D_MD4][0] * 4 * l0 / l1;
-        c[D_MD5][i] = c[D_MD5][0] * 4 * l0 / l1;
-        c[D_HMAC][i] = c[D_HMAC][0] * 4 * l0 / l1;
-        c[D_SHA1][i] = c[D_SHA1][0] * 4 * l0 / l1;
-        c[D_RMD160][i] = c[D_RMD160][0] * 4 * l0 / l1;
-        c[D_EVP][i] = = c[D_EVP][0] * 4 * l0 / l1;
-        c[D_SHA256][i] = c[D_SHA256][0] * 4 * l0 / l1;
-        c[D_SHA512][i] = c[D_SHA512][0] * 4 * l0 / l1;
-        c[D_WHIRLPOOL][i] = c[D_WHIRLPOOL][0] * 4 * l0 / l1;
-        c[D_GHASH][i] = c[D_GHASH][0] * 4 * l0 / l1;
-        c[D_RAND][i] = c[D_RAND][0] * 4 * l0 / l1;
-        c[D_EVP_HMAC][i] = = c[D_EVP_HMAC][0] * 4 * l0 / l1;
-        c[D_EVP_CMAC][i] = = c[D_EVP_CMAC][0] * 4 * l0 / l1;
-
-        l0 = (long)lengths[i - 1];
-
-        c[D_RC4][i] = c[D_RC4][i - 1] * l0 / l1;
-        c[D_CBC_DES][i] = c[D_CBC_DES][i - 1] * l0 / l1;
-        c[D_EDE3_DES][i] = c[D_EDE3_DES][i - 1] * l0 / l1;
-        c[D_CBC_IDEA][i] = c[D_CBC_IDEA][i - 1] * l0 / l1;
-        c[D_CBC_SEED][i] = c[D_CBC_SEED][i - 1] * l0 / l1;
-        c[D_CBC_RC2][i] = c[D_CBC_RC2][i - 1] * l0 / l1;
-        c[D_CBC_RC5][i] = c[D_CBC_RC5][i - 1] * l0 / l1;
-        c[D_CBC_BF][i] = c[D_CBC_BF][i - 1] * l0 / l1;
-        c[D_CBC_CAST][i] = c[D_CBC_CAST][i - 1] * l0 / l1;
-        c[D_CBC_128_AES][i] = c[D_CBC_128_AES][i - 1] * l0 / l1;
-        c[D_CBC_192_AES][i] = c[D_CBC_192_AES][i - 1] * l0 / l1;
-        c[D_CBC_256_AES][i] = c[D_CBC_256_AES][i - 1] * l0 / l1;
-        c[D_CBC_128_CML][i] = c[D_CBC_128_CML][i - 1] * l0 / l1;
-        c[D_CBC_192_CML][i] = c[D_CBC_192_CML][i - 1] * l0 / l1;
-        c[D_CBC_256_CML][i] = c[D_CBC_256_CML][i - 1] * l0 / l1;
-        c[D_IGE_128_AES][i] = c[D_IGE_128_AES][i - 1] * l0 / l1;
-        c[D_IGE_192_AES][i] = c[D_IGE_192_AES][i - 1] * l0 / l1;
-        c[D_IGE_256_AES][i] = c[D_IGE_256_AES][i - 1] * l0 / l1;
-    }
-
-#  ifndef OPENSSL_NO_DEPRECATED_3_0
-    rsa_c[R_RSA_512][0] = count / 2000;
-    rsa_c[R_RSA_512][1] = count / 400;
-    for (i = 1; i &lt; RSA_NUM; i++) {
-        rsa_c[i][0] = rsa_c[i - 1][0] / 8;
-        rsa_c[i][1] = rsa_c[i - 1][1] / 4;
-        if (rsa_doit[i] &lt;= 1 &amp;&amp; rsa_c[i][0] == 0)
-            rsa_doit[i] = 0;
-        else {
-            if (rsa_c[i][0] == 0) {
-                rsa_c[i][0] = 1; /* Set minimum iteration Nb to 1. */
-                rsa_c[i][1] = 20;
-            }
-        }
-    }
-#  endif
-
-#  if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    dsa_c[R_DSA_512][0] = count / 1000;
-    dsa_c[R_DSA_512][1] = count / 1000 / 2;
-    for (i = 1; i &lt; DSA_NUM; i++) {
-        dsa_c[i][0] = dsa_c[i - 1][0] / 4;
-        dsa_c[i][1] = dsa_c[i - 1][1] / 4;
-        if (dsa_doit[i] &lt;= 1 &amp;&amp; dsa_c[i][0] == 0)
-            dsa_doit[i] = 0;
-        else {
-            if (dsa_c[i][0] == 0) {
-                dsa_c[i][0] = 1; /* Set minimum iteration Nb to 1. */
-                dsa_c[i][1] = 1;
-            }
-        }
-    }
-#  endif
-
-#  ifndef OPENSSL_NO_EC
-    ecdsa_c[R_EC_P160][0] = count / 1000;
-    ecdsa_c[R_EC_P160][1] = count / 1000 / 2;
-    for (i = R_EC_P192; i &lt;= R_EC_P521; i++) {
-        ecdsa_c[i][0] = ecdsa_c[i - 1][0] / 2;
-        ecdsa_c[i][1] = ecdsa_c[i - 1][1] / 2;
-        if (ecdsa_doit[i] &lt;= 1 &amp;&amp; ecdsa_c[i][0] == 0)
-            ecdsa_doit[i] = 0;
-        else {
-            if (ecdsa_c[i][0] == 0) {
-                ecdsa_c[i][0] = 1;
-                ecdsa_c[i][1] = 1;
-            }
-        }
-    }
-#   ifndef OPENSSL_NO_EC2M
-    ecdsa_c[R_EC_K163][0] = count / 1000;
-    ecdsa_c[R_EC_K163][1] = count / 1000 / 2;
-    for (i = R_EC_K233; i &lt;= R_EC_K571; i++) {
-        ecdsa_c[i][0] = ecdsa_c[i - 1][0] / 2;
-        ecdsa_c[i][1] = ecdsa_c[i - 1][1] / 2;
-        if (ecdsa_doit[i] &lt;= 1 &amp;&amp; ecdsa_c[i][0] == 0)
-            ecdsa_doit[i] = 0;
-        else {
-            if (ecdsa_c[i][0] == 0) {
-                ecdsa_c[i][0] = 1;
-                ecdsa_c[i][1] = 1;
-            }
-        }
-    }
-    ecdsa_c[R_EC_B163][0] = count / 1000;
-    ecdsa_c[R_EC_B163][1] = count / 1000 / 2;
-    for (i = R_EC_B233; i &lt;= R_EC_B571; i++) {
-        ecdsa_c[i][0] = ecdsa_c[i - 1][0] / 2;
-        ecdsa_c[i][1] = ecdsa_c[i - 1][1] / 2;
-        if (ecdsa_doit[i] &lt;= 1 &amp;&amp; ecdsa_c[i][0] == 0)
-            ecdsa_doit[i] = 0;
-        else {
-            if (ecdsa_c[i][0] == 0) {
-                ecdsa_c[i][0] = 1;
-                ecdsa_c[i][1] = 1;
-            }
-        }
-    }
-#   endif
-
-    ecdh_c[R_EC_P160][0] = count / 1000;
-    for (i = R_EC_P192; i &lt;= R_EC_P521; i++) {
-        ecdh_c[i][0] = ecdh_c[i - 1][0] / 2;
-        if (ecdh_doit[i] &lt;= 1 &amp;&amp; ecdh_c[i][0] == 0)
-            ecdh_doit[i] = 0;
-        else {
-            if (ecdh_c[i][0] == 0) {
-                ecdh_c[i][0] = 1;
-            }
-        }
-    }
-#   ifndef OPENSSL_NO_EC2M
-    ecdh_c[R_EC_K163][0] = count / 1000;
-    for (i = R_EC_K233; i &lt;= R_EC_K571; i++) {
-        ecdh_c[i][0] = ecdh_c[i - 1][0] / 2;
-        if (ecdh_doit[i] &lt;= 1 &amp;&amp; ecdh_c[i][0] == 0)
-            ecdh_doit[i] = 0;
-        else {
-            if (ecdh_c[i][0] == 0) {
-                ecdh_c[i][0] = 1;
-            }
-        }
-    }
-    ecdh_c[R_EC_B163][0] = count / 1000;
-    for (i = R_EC_B233; i &lt;= R_EC_B571; i++) {
-        ecdh_c[i][0] = ecdh_c[i - 1][0] / 2;
-        if (ecdh_doit[i] &lt;= 1 &amp;&amp; ecdh_c[i][0] == 0)
-            ecdh_doit[i] = 0;
-        else {
-            if (ecdh_c[i][0] == 0) {
-                ecdh_c[i][0] = 1;
-            }
-        }
-    }
-#   endif
-    /* repeated code good to factorize */
-    ecdh_c[R_EC_BRP256R1][0] = count / 1000;
-    for (i = R_EC_BRP384R1; i &lt;= R_EC_BRP512R1; i += 2) {
-        ecdh_c[i][0] = ecdh_c[i - 2][0] / 2;
-        if (ecdh_doit[i] &lt;= 1 &amp;&amp; ecdh_c[i][0] == 0)
-            ecdh_doit[i] = 0;
-        else {
-            if (ecdh_c[i][0] == 0) {
-                ecdh_c[i][0] = 1;
-            }
-        }
-    }
-    ecdh_c[R_EC_BRP256T1][0] = count / 1000;
-    for (i = R_EC_BRP384T1; i &lt;= R_EC_BRP512T1; i += 2) {
-        ecdh_c[i][0] = ecdh_c[i - 2][0] / 2;
-        if (ecdh_doit[i] &lt;= 1 &amp;&amp; ecdh_c[i][0] == 0)
-            ecdh_doit[i] = 0;
-        else {
-            if (ecdh_c[i][0] == 0) {
-                ecdh_c[i][0] = 1;
-            }
-        }
-    }
-    /* default iteration count for the last two EC Curves */
-    ecdh_c[R_EC_X25519][0] = count / 1800;
-    ecdh_c[R_EC_X448][0] = count / 7200;
-
-    eddsa_c[R_EC_Ed25519][0] = count / 1800;
-    eddsa_c[R_EC_Ed448][0] = count / 7200;
-
-#   ifndef OPENSSL_NO_SM2
-    sm2_c[R_EC_SM2P256][0] = count / 1800;
-#   endif
-#  endif                          /* OPENSSL_NO_EC */
-
-#  ifndef OPENSSL_NO_DH
-    ffdh_c[R_FFDH_2048][0] = count / 1000;
-    for (i = R_FFDH_3072; i &lt;= R_FFDH_8192; i++) {
-        ffdh_c[i][0] = ffdh_c[i - 1][0] / 2;
-        if (ffdh_doit[i] &lt;= 1 &amp;&amp; ffdh_c[i][0] == 0) {
-            ffdh_doit[i] = 0;
-        } else {
-            if (ffdh_c[i][0] == 0)
-                ffdh_c[i][0] = 1;
-        }
-    }
-#  endif /* OPENSSL_NO_DH */
-
-# else
-/* not worth fixing */
-#  error &quot;You cannot disable DES on systems without SIGALRM.&quot;
-# endif                         /* OPENSSL_NO_DES */
-#elif SIGALRM &gt; 0
+#if SIGALRM &gt; 0
     signal(SIGALRM, alarmed);
-#endif                          /* SIGALRM */
+#endif
 
-#if !defined(OPENSSL_NO_MD2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     if (doit[D_MD2]) {
         for (testnum = 0; testnum &lt; size_num; testnum++) {
             print_message(names[D_MD2], c[D_MD2][testnum], lengths[testnum],
@@ -2438,10 +1882,11 @@ int speed_main(int argc, char **argv)
             count = run_benchmark(async_jobs, EVP_Digest_MD2_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_MD2, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
     }
-#endif
-#if !defined(OPENSSL_NO_MDC2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
+
     if (doit[D_MDC2]) {
         for (testnum = 0; testnum &lt; size_num; testnum++) {
             print_message(names[D_MDC2], c[D_MDC2][testnum], lengths[testnum],
@@ -2454,9 +1899,7 @@ int speed_main(int argc, char **argv)
                 break;
         }
     }
-#endif
 
-#if !defined(OPENSSL_NO_MD4) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     if (doit[D_MD4]) {
         for (testnum = 0; testnum &lt; size_num; testnum++) {
             print_message(names[D_MD4], c[D_MD4][testnum], lengths[testnum],
@@ -2469,9 +1912,7 @@ int speed_main(int argc, char **argv)
                 break;
         }
     }
-#endif
 
-#if !defined(OPENSSL_NO_MD5) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     if (doit[D_MD5]) {
         for (testnum = 0; testnum &lt; size_num; testnum++) {
             print_message(names[D_MD5], c[D_MD5][testnum], lengths[testnum],
@@ -2480,37 +1921,11 @@ int speed_main(int argc, char **argv)
             count = run_benchmark(async_jobs, MD5_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_MD5, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
     }
 
-# ifndef OPENSSL_NO_DEPRECATED_3_0
-    if (doit[D_HMAC]) {
-        static const char hmac_key[] = &quot;This is a key...&quot;;
-        int len = strlen(hmac_key);
-
-        for (i = 0; i &lt; loopargs_len; i++) {
-            loopargs[i].hctx = HMAC_CTX_new();
-            if (loopargs[i].hctx == NULL) {
-                BIO_printf(bio_err, &quot;HMAC malloc failure, exiting...&quot;);
-                exit(1);
-            }
-
-            HMAC_Init_ex(loopargs[i].hctx, hmac_key, len, EVP_md5(), NULL);
-        }
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_HMAC], c[D_HMAC][testnum], lengths[testnum],
-                          seconds.sym);
-            Time_F(START);
-            count = run_benchmark(async_jobs, HMAC_loop, loopargs);
-            d = Time_F(STOP);
-            print_result(D_HMAC, testnum, count, d);
-        }
-        for (i = 0; i &lt; loopargs_len; i++)
-            HMAC_CTX_free(loopargs[i].hctx);
-    }
-# endif
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
     if (doit[D_SHA1]) {
         for (testnum = 0; testnum &lt; size_num; testnum++) {
             print_message(names[D_SHA1], c[D_SHA1][testnum], lengths[testnum],
@@ -2519,8 +1934,11 @@ int speed_main(int argc, char **argv)
             count = run_benchmark(async_jobs, SHA1_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_SHA1, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
     }
+
     if (doit[D_SHA256]) {
         for (testnum = 0; testnum &lt; size_num; testnum++) {
             print_message(names[D_SHA256], c[D_SHA256][testnum],
@@ -2529,8 +1947,11 @@ int speed_main(int argc, char **argv)
             count = run_benchmark(async_jobs, SHA256_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_SHA256, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
     }
+
     if (doit[D_SHA512]) {
         for (testnum = 0; testnum &lt; size_num; testnum++) {
             print_message(names[D_SHA512], c[D_SHA512][testnum],
@@ -2539,10 +1960,11 @@ int speed_main(int argc, char **argv)
             count = run_benchmark(async_jobs, SHA512_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_SHA512, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
     }
-#endif
-#if !defined(OPENSSL_NO_WHIRLPOOL) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
+
     if (doit[D_WHIRLPOOL]) {
         for (testnum = 0; testnum &lt; size_num; testnum++) {
             print_message(names[D_WHIRLPOOL], c[D_WHIRLPOOL][testnum],
@@ -2551,11 +1973,11 @@ int speed_main(int argc, char **argv)
             count = run_benchmark(async_jobs, WHIRLPOOL_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_WHIRLPOOL, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
     }
-#endif
 
-#if !defined(OPENSSL_NO_RMD160) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     if (doit[D_RMD160]) {
         for (testnum = 0; testnum &lt; size_num; testnum++) {
             print_message(names[D_RMD160], c[D_RMD160][testnum],
@@ -2568,320 +1990,213 @@ int speed_main(int argc, char **argv)
                 break;
         }
     }
-#endif
-#if !defined(OPENSSL_NO_RC4) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_RC4]) {
+
+    if (doit[D_HMAC]) {
+        static const char hmac_key[] = &quot;This is a key...&quot;;
+        int len = strlen(hmac_key);
+        EVP_MAC *mac = EVP_MAC_fetch(NULL, &quot;HMAC&quot;, NULL);
+        OSSL_PARAM params[3];
+
+        if (mac == NULL || evp_mac_mdname == NULL)
+            goto end;
+
+        evp_hmac_name = app_malloc(sizeof(&quot;hmac()&quot;) + strlen(evp_mac_mdname),
+                                   &quot;HMAC name&quot;);
+        sprintf(evp_hmac_name, &quot;hmac(%s)&quot;, evp_mac_mdname);
+        names[D_HMAC] = evp_hmac_name;
+
+        params[0] =
+            OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,
+                                             evp_mac_mdname, 0);
+        params[1] =
+            OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,
+                                              (char *)hmac_key, len);
+        params[2] = OSSL_PARAM_construct_end();
+
+        for (i = 0; i &lt; loopargs_len; i++) {
+            loopargs[i].mctx = EVP_MAC_CTX_new(mac);
+            if (loopargs[i].mctx == NULL)
+                goto end;
+
+            if (!EVP_MAC_CTX_set_params(loopargs[i].mctx, params))
+                goto end;
+        }
         for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_RC4], c[D_RC4][testnum], lengths[testnum],
+            print_message(names[D_HMAC], c[D_HMAC][testnum], lengths[testnum],
                           seconds.sym);
             Time_F(START);
-            count = run_benchmark(async_jobs, RC4_loop, loopargs);
+            count = run_benchmark(async_jobs, HMAC_loop, loopargs);
             d = Time_F(STOP);
-            print_result(D_RC4, testnum, count, d);
+            print_result(D_HMAC, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
+        for (i = 0; i &lt; loopargs_len; i++)
+            EVP_MAC_CTX_free(loopargs[i].mctx);
+        EVP_MAC_free(mac);
     }
-#endif
-#if !defined(OPENSSL_NO_DES) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
+
     if (doit[D_CBC_DES]) {
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
+        int st = 1;
+
+        for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+            loopargs[i].ctx = init_evp_cipher_ctx(&quot;des-cbc&quot;, deskey,
+                                                  sizeof(deskey) / 3);
+            st = loopargs[i].ctx != NULL;
+        }
+        algindex = D_CBC_DES;
+        for (testnum = 0; st &amp;&amp; testnum &lt; size_num; testnum++) {
             print_message(names[D_CBC_DES], c[D_CBC_DES][testnum],
                           lengths[testnum], seconds.sym);
             Time_F(START);
-            count = run_benchmark(async_jobs, DES_ncbc_encrypt_loop, loopargs);
+            count = run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_CBC_DES, testnum, count, d);
         }
+        for (i = 0; i &lt; loopargs_len; i++)
+            EVP_CIPHER_CTX_free(loopargs[i].ctx);
     }
 
     if (doit[D_EDE3_DES]) {
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_EDE3_DES], c[D_EDE3_DES][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            count =
-                run_benchmark(async_jobs, DES_ede3_cbc_encrypt_loop, loopargs);
-            d = Time_F(STOP);
-            print_result(D_EDE3_DES, testnum, count, d);
-        }
-    }
-#endif
+        int st = 1;
 
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-    if (doit[D_CBC_128_AES]) {
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_CBC_128_AES], c[D_CBC_128_AES][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            count =
-                run_benchmark(async_jobs, AES_cbc_128_encrypt_loop, loopargs);
-            d = Time_F(STOP);
-            print_result(D_CBC_128_AES, testnum, count, d);
+        for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+            loopargs[i].ctx = init_evp_cipher_ctx(&quot;des-ede3-cbc&quot;, deskey,
+                                                  sizeof(deskey));
+            st = loopargs[i].ctx != NULL;
         }
-    }
-    if (doit[D_CBC_192_AES]) {
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_CBC_192_AES], c[D_CBC_192_AES][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            count =
-                run_benchmark(async_jobs, AES_cbc_192_encrypt_loop, loopargs);
-            d = Time_F(STOP);
-            print_result(D_CBC_192_AES, testnum, count, d);
-        }
-    }
-    if (doit[D_CBC_256_AES]) {
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_CBC_256_AES], c[D_CBC_256_AES][testnum],
+        algindex = D_EDE3_DES;
+        for (testnum = 0; st &amp;&amp; testnum &lt; size_num; testnum++) {
+            print_message(names[D_EDE3_DES], c[D_EDE3_DES][testnum],
                           lengths[testnum], seconds.sym);
             Time_F(START);
             count =
-                run_benchmark(async_jobs, AES_cbc_256_encrypt_loop, loopargs);
+                run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);
             d = Time_F(STOP);
-            print_result(D_CBC_256_AES, testnum, count, d);
+            print_result(D_EDE3_DES, testnum, count, d);
         }
+        for (i = 0; i &lt; loopargs_len; i++)
+            EVP_CIPHER_CTX_free(loopargs[i].ctx);
     }
 
+    for (k = 0; k &lt; 3; k++) {
+        algindex = D_CBC_128_AES + k;
+        if (doit[algindex]) {
+            int st = 1;
 
-    if (doit[D_IGE_128_AES]) {
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_IGE_128_AES], c[D_IGE_128_AES][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            count =
-                run_benchmark(async_jobs, AES_ige_128_encrypt_loop, loopargs);
-            d = Time_F(STOP);
-            print_result(D_IGE_128_AES, testnum, count, d);
-        }
-    }
-    if (doit[D_IGE_192_AES]) {
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_IGE_192_AES], c[D_IGE_192_AES][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            count =
-                run_benchmark(async_jobs, AES_ige_192_encrypt_loop, loopargs);
-            d = Time_F(STOP);
-            print_result(D_IGE_192_AES, testnum, count, d);
-        }
-    }
-    if (doit[D_IGE_256_AES]) {
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_IGE_256_AES], c[D_IGE_256_AES][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            count =
-                run_benchmark(async_jobs, AES_ige_256_encrypt_loop, loopargs);
-            d = Time_F(STOP);
-            print_result(D_IGE_256_AES, testnum, count, d);
-        }
-    }
-    if (doit[D_GHASH]) {
-        for (i = 0; i &lt; loopargs_len; i++) {
-            loopargs[i].gcm_ctx =
-                CRYPTO_gcm128_new(&amp;aes_ks1, (block128_f) AES_encrypt);
-            CRYPTO_gcm128_setiv(loopargs[i].gcm_ctx,
-                                (unsigned char *)&quot;0123456789ab&quot;, 12);
-        }
-
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_GHASH], c[D_GHASH][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            count = run_benchmark(async_jobs, CRYPTO_gcm128_aad_loop, loopargs);
-            d = Time_F(STOP);
-            print_result(D_GHASH, testnum, count, d);
-        }
-        for (i = 0; i &lt; loopargs_len; i++)
-            CRYPTO_gcm128_release(loopargs[i].gcm_ctx);
-    }
-#endif /* OPENSSL_NO_DEPRECATED_3_0 */
-#if !defined(OPENSSL_NO_CAMELLIA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_128_CML]) {
-        if (async_jobs &gt; 0) {
-            BIO_printf(bio_err, &quot;Async mode is not supported with %s\n&quot;,
-                       names[D_CBC_128_CML]);
-            doit[D_CBC_128_CML] = 0;
-        }
-        for (testnum = 0; testnum &lt; size_num &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_128_CML], c[D_CBC_128_CML][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            for (count = 0; COND(c[D_CBC_128_CML][testnum]); count++)
-                Camellia_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                     (size_t)lengths[testnum], &amp;camellia_ks[0],
-                                     iv, CAMELLIA_ENCRYPT);
-            d = Time_F(STOP);
-            print_result(D_CBC_128_CML, testnum, count, d);
-        }
-    }
-    if (doit[D_CBC_192_CML]) {
-        if (async_jobs &gt; 0) {
-            BIO_printf(bio_err, &quot;Async mode is not supported with %s\n&quot;,
-                       names[D_CBC_192_CML]);
-            doit[D_CBC_192_CML] = 0;
-        }
-        for (testnum = 0; testnum &lt; size_num &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_192_CML], c[D_CBC_192_CML][testnum],
-                          lengths[testnum], seconds.sym);
-            if (async_jobs &gt; 0) {
-                BIO_printf(bio_err, &quot;Async mode is not supported, exiting...&quot;);
-                exit(1);
-            }
-            Time_F(START);
-            for (count = 0; COND(c[D_CBC_192_CML][testnum]); count++)
-                Camellia_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                     (size_t)lengths[testnum], &amp;camellia_ks[1],
-                                     iv, CAMELLIA_ENCRYPT);
-            d = Time_F(STOP);
-            print_result(D_CBC_192_CML, testnum, count, d);
-        }
-    }
-    if (doit[D_CBC_256_CML]) {
-        if (async_jobs &gt; 0) {
-            BIO_printf(bio_err, &quot;Async mode is not supported with %s\n&quot;,
-                       names[D_CBC_256_CML]);
-            doit[D_CBC_256_CML] = 0;
-        }
-        for (testnum = 0; testnum &lt; size_num &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_256_CML], c[D_CBC_256_CML][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            for (count = 0; COND(c[D_CBC_256_CML][testnum]); count++)
-                Camellia_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                     (size_t)lengths[testnum], &amp;camellia_ks[2],
-                                     iv, CAMELLIA_ENCRYPT);
-            d = Time_F(STOP);
-            print_result(D_CBC_256_CML, testnum, count, d);
-        }
-    }
-#endif
-#if !defined(OPENSSL_NO_IDEA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_IDEA]) {
-        if (async_jobs &gt; 0) {
-            BIO_printf(bio_err, &quot;Async mode is not supported with %s\n&quot;,
-                       names[D_CBC_IDEA]);
-            doit[D_CBC_IDEA] = 0;
-        }
-        for (testnum = 0; testnum &lt; size_num &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_IDEA], c[D_CBC_IDEA][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            for (count = 0; COND(c[D_CBC_IDEA][testnum]); count++)
-                IDEA_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                 (size_t)lengths[testnum], &amp;idea_ks,
-                                 iv, IDEA_ENCRYPT);
-            d = Time_F(STOP);
-            print_result(D_CBC_IDEA, testnum, count, d);
-        }
-    }
-#endif
-#if !defined(OPENSSL_NO_SEED) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_SEED]) {
-        if (async_jobs &gt; 0) {
-            BIO_printf(bio_err, &quot;Async mode is not supported with %s\n&quot;,
-                       names[D_CBC_SEED]);
-            doit[D_CBC_SEED] = 0;
-        }
-        for (testnum = 0; testnum &lt; size_num &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_SEED], c[D_CBC_SEED][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            for (count = 0; COND(c[D_CBC_SEED][testnum]); count++)
-                SEED_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                 (size_t)lengths[testnum], &amp;seed_ks, iv, 1);
-            d = Time_F(STOP);
-            print_result(D_CBC_SEED, testnum, count, d);
-        }
-    }
-#endif
-#if !defined(OPENSSL_NO_RC2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_RC2]) {
-        if (async_jobs &gt; 0) {
-            BIO_printf(bio_err, &quot;Async mode is not supported with %s\n&quot;,
-                       names[D_CBC_RC2]);
-            doit[D_CBC_RC2] = 0;
-        }
-        for (testnum = 0; testnum &lt; size_num &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_RC2], c[D_CBC_RC2][testnum],
-                          lengths[testnum], seconds.sym);
-            if (async_jobs &gt; 0) {
-                BIO_printf(bio_err, &quot;Async mode is not supported, exiting...&quot;);
-                exit(1);
+            keylen = 16 + i * 8;
+            for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],
+                                                      key32, keylen);
+                st = loopargs[i].ctx != NULL;
             }
-            Time_F(START);
-            for (count = 0; COND(c[D_CBC_RC2][testnum]); count++)
-                RC2_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                (size_t)lengths[testnum], &amp;rc2_ks,
-                                iv, RC2_ENCRYPT);
-            d = Time_F(STOP);
-            print_result(D_CBC_RC2, testnum, count, d);
+
+            for (testnum = 0; st &amp;&amp; testnum &lt; size_num; testnum++) {
+                print_message(names[algindex], c[algindex][testnum],
+                              lengths[testnum], seconds.sym);
+                Time_F(START);
+                count =
+                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);
+                d = Time_F(STOP);
+                print_result(algindex, testnum, count, d);
+            }
+            for (i = 0; i &lt; loopargs_len; i++)
+                EVP_CIPHER_CTX_free(loopargs[i].ctx);
         }
     }
-#endif
-#if !defined(OPENSSL_NO_RC5) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_RC5]) {
-        if (async_jobs &gt; 0) {
-            BIO_printf(bio_err, &quot;Async mode is not supported with %s\n&quot;,
-                       names[D_CBC_RC5]);
-            doit[D_CBC_RC5] = 0;
-        }
-        for (testnum = 0; testnum &lt; size_num &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_RC5], c[D_CBC_RC5][testnum],
-                          lengths[testnum], seconds.sym);
-            if (async_jobs &gt; 0) {
-                BIO_printf(bio_err, &quot;Async mode is not supported, exiting...&quot;);
-                exit(1);
+
+    for (k = 0; k &lt; 3; k++) {
+        algindex = D_CBC_128_CML + k;
+        if (doit[algindex]) {
+            int st = 1;
+
+            keylen = 16 + i * 8;
+            for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],
+                                                      key32, keylen);
+                st = loopargs[i].ctx != NULL;
             }
-            Time_F(START);
-            for (count = 0; COND(c[D_CBC_RC5][testnum]); count++)
-                RC5_32_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                   (size_t)lengths[testnum], &amp;rc5_ks,
-                                   iv, RC5_ENCRYPT);
-            d = Time_F(STOP);
-            print_result(D_CBC_RC5, testnum, count, d);
+
+            for (testnum = 0; st &amp;&amp; testnum &lt; size_num; testnum++) {
+                print_message(names[algindex], c[algindex][testnum],
+                              lengths[testnum], seconds.sym);
+                Time_F(START);
+                count =
+                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);
+                d = Time_F(STOP);
+                print_result(algindex, testnum, count, d);
+            }
+            for (i = 0; i &lt; loopargs_len; i++)
+                EVP_CIPHER_CTX_free(loopargs[i].ctx);
         }
     }
-#endif
-#if !defined(OPENSSL_NO_BF) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_BF]) {
-        if (async_jobs &gt; 0) {
-            BIO_printf(bio_err, &quot;Async mode is not supported with %s\n&quot;,
-                       names[D_CBC_BF]);
-            doit[D_CBC_BF] = 0;
-        }
-        for (testnum = 0; testnum &lt; size_num &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_BF], c[D_CBC_BF][testnum],
-                          lengths[testnum], seconds.sym);
-            Time_F(START);
-            for (count = 0; COND(c[D_CBC_BF][testnum]); count++)
-                BF_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                               (size_t)lengths[testnum], &amp;bf_ks,
-                               iv, BF_ENCRYPT);
-            d = Time_F(STOP);
-            print_result(D_CBC_BF, testnum, count, d);
+
+    for (algindex = D_RC4; algindex &lt;= D_CBC_CAST; algindex++) {
+        if (doit[algindex]) {
+            int st = 1;
+
+            keylen = 16;
+            for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],
+                                                      key32, keylen);
+                st = loopargs[i].ctx != NULL;
+            }
+
+            for (testnum = 0; st &amp;&amp; testnum &lt; size_num; testnum++) {
+                print_message(names[algindex], c[algindex][testnum],
+                              lengths[testnum], seconds.sym);
+                Time_F(START);
+                count =
+                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);
+                d = Time_F(STOP);
+                print_result(algindex, testnum, count, d);
+            }
+            for (i = 0; i &lt; loopargs_len; i++)
+                EVP_CIPHER_CTX_free(loopargs[i].ctx);
         }
     }
-#endif
-#if !defined(OPENSSL_NO_CAST) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_CBC_CAST]) {
-        if (async_jobs &gt; 0) {
-            BIO_printf(bio_err, &quot;Async mode is not supported with %s\n&quot;,
-                       names[D_CBC_CAST]);
-            doit[D_CBC_CAST] = 0;
+    if (doit[D_GHASH]) {
+        static const char gmac_iv[] = &quot;0123456789ab&quot;;
+        EVP_MAC *mac = EVP_MAC_fetch(NULL, &quot;GMAC&quot;, NULL);
+        OSSL_PARAM params[4];
+
+        if (mac == NULL)
+            goto end;
+
+        params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_CIPHER,
+                                                     &quot;aes-128-gcm&quot;, 0);
+        params[1] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,
+                                                      (char *)key32, 16);
+        params[2] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_IV,
+                                                      (char *)gmac_iv,
+                                                      sizeof(gmac_iv) - 1);
+        params[3] = OSSL_PARAM_construct_end();
+
+        for (i = 0; i &lt; loopargs_len; i++) {
+            loopargs[i].mctx = EVP_MAC_CTX_new(mac);
+            if (loopargs[i].mctx == NULL)
+                goto end;
+
+            if (!EVP_MAC_CTX_set_params(loopargs[i].mctx, params))
+                goto end;
+            if (!EVP_MAC_init(loopargs[i].mctx))
+                goto end;
         }
-        for (testnum = 0; testnum &lt; size_num &amp;&amp; async_init == 0; testnum++) {
-            print_message(names[D_CBC_CAST], c[D_CBC_CAST][testnum],
-                          lengths[testnum], seconds.sym);
+        for (testnum = 0; testnum &lt; size_num; testnum++) {
+            print_message(names[D_GHASH], c[D_GHASH][testnum], lengths[testnum],
+                          seconds.sym);
             Time_F(START);
-            for (count = 0; COND(c[D_CBC_CAST][testnum]); count++)
-                CAST_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                 (size_t)lengths[testnum], &amp;cast_ks,
-                                 iv, CAST_ENCRYPT);
+            count = run_benchmark(async_jobs, GHASH_loop, loopargs);
             d = Time_F(STOP);
-            print_result(D_CBC_CAST, testnum, count, d);
+            print_result(D_GHASH, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
+        for (i = 0; i &lt; loopargs_len; i++)
+            EVP_MAC_CTX_free(loopargs[i].mctx);
+        EVP_MAC_free(mac);
     }
-#endif
+
     if (doit[D_RAND]) {
         for (testnum = 0; testnum &lt; size_num; testnum++) {
             print_message(names[D_RAND], c[D_RAND][testnum], lengths[testnum],
@@ -2949,126 +2264,131 @@ int speed_main(int argc, char **argv)
 
                     /* SIV mode only allows for a single Update operation */
                     if (EVP_CIPHER_mode(evp_cipher) == EVP_CIPH_SIV_MODE)
-                        EVP_CIPHER_CTX_ctrl(loopargs[k].ctx, EVP_CTRL_SET_SPEED, 1, NULL);
+                        EVP_CIPHER_CTX_ctrl(loopargs[k].ctx, EVP_CTRL_SET_SPEED,
+                                            1, NULL);
                 }
 
                 Time_F(START);
                 count = run_benchmark(async_jobs, loopfunc, loopargs);
                 d = Time_F(STOP);
-                for (k = 0; k &lt; loopargs_len; k++) {
+                for (k = 0; k &lt; loopargs_len; k++)
                     EVP_CIPHER_CTX_free(loopargs[k].ctx);
-                }
                 print_result(D_EVP, testnum, count, d);
             }
-        } else if (evp_md != NULL) {
-            names[D_EVP] = OBJ_nid2ln(EVP_MD_type(evp_md));
+        } else if (evp_md_name != NULL) {
+            names[D_EVP] = evp_md_name;
 
             for (testnum = 0; testnum &lt; size_num; testnum++) {
                 print_message(names[D_EVP], c[D_EVP][testnum], lengths[testnum],
                               seconds.sym);
                 Time_F(START);
-                count = run_benchmark(async_jobs, EVP_Digest_loop, loopargs);
+                count = run_benchmark(async_jobs, EVP_Digest_md_loop, loopargs);
                 d = Time_F(STOP);
                 print_result(D_EVP, testnum, count, d);
+                if (count &lt; 0)
+                    break;
             }
         }
     }
 
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-    if (doit[D_EVP_HMAC] &amp;&amp; evp_hmac_md != NULL) {
-        const char *md_name = OBJ_nid2ln(EVP_MD_type(evp_hmac_md));
+    if (doit[D_EVP_CMAC]) {
+        EVP_MAC *mac = EVP_MAC_fetch(NULL, &quot;CMAC&quot;, NULL);
+        OSSL_PARAM params[3];
+        EVP_CIPHER *cipher;
+        int fetched = 0;
 
-        evp_hmac_name = app_malloc(sizeof(&quot;HMAC()&quot;) + strlen(md_name),
-                                   &quot;HMAC name&quot;);
-        sprintf(evp_hmac_name, &quot;HMAC(%s)&quot;, md_name);
-        names[D_EVP_HMAC] = evp_hmac_name;
+        if (mac == NULL || evp_mac_ciphername == NULL)
+            goto end;
+        if ((cipher = obtain_cipher(evp_mac_ciphername, &amp;fetched)) == NULL)
+            goto end;
 
-        for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_EVP_HMAC], c[D_EVP_HMAC][testnum], lengths[testnum],
-                          seconds.sym);
-            Time_F(START);
-            count = run_benchmark(async_jobs, EVP_HMAC_loop, loopargs);
-            d = Time_F(STOP);
-            print_result(D_EVP_HMAC, testnum, count, d);
+        keylen = EVP_CIPHER_key_length(cipher);
+        if (fetched)
+            EVP_CIPHER_free(cipher);
+        if (keylen &lt;= 0 || keylen &gt; (int)sizeof(key32)) {
+            BIO_printf(bio_err, &quot;\nRequested CMAC cipher with unsupported key length.\n&quot;);
+            goto end;
         }
-    }
-#endif
-
-#if !defined(OPENSSL_NO_CMAC) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-    if (doit[D_EVP_CMAC] &amp;&amp; evp_cmac_cipher != NULL) {
-        const char *cipher_name = OBJ_nid2ln(EVP_CIPHER_type(evp_cmac_cipher));
-
-        evp_cmac_name = app_malloc(sizeof(&quot;CMAC()&quot;) + strlen(cipher_name),
-                                   &quot;CMAC name&quot;);
-        sprintf(evp_cmac_name, &quot;CMAC(%s)&quot;, cipher_name);
+        evp_cmac_name = app_malloc(sizeof(&quot;cmac()&quot;)
+                                   + strlen(evp_mac_ciphername), &quot;CMAC name&quot;);
+        sprintf(evp_cmac_name, &quot;cmac(%s)&quot;, evp_mac_ciphername);
         names[D_EVP_CMAC] = evp_cmac_name;
 
+        params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_CIPHER,
+                                                     evp_mac_ciphername, 0);
+        params[1] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,
+                                                      (char *)key32, keylen);
+        params[2] = OSSL_PARAM_construct_end();
+
         for (i = 0; i &lt; loopargs_len; i++) {
-            loopargs[i].cmac_ctx = CMAC_CTX_new();
-            if (loopargs[i].cmac_ctx == NULL) {
-                BIO_printf(bio_err, &quot;CMAC malloc failure, exiting...&quot;);
-                exit(1);
-            }
+            loopargs[i].mctx = EVP_MAC_CTX_new(mac);
+            if (loopargs[i].mctx == NULL)
+                goto end;
+
+            if (!EVP_MAC_CTX_set_params(loopargs[i].mctx, params))
+                goto end;
         }
+
         for (testnum = 0; testnum &lt; size_num; testnum++) {
-            print_message(names[D_EVP_CMAC], c[D_EVP_CMAC][testnum], lengths[testnum],
-                          seconds.sym);
+            print_message(names[D_EVP_CMAC], c[D_EVP_CMAC][testnum],
+                          lengths[testnum], seconds.sym);
             Time_F(START);
-            count = run_benchmark(async_jobs, EVP_CMAC_loop, loopargs);
+            count = run_benchmark(async_jobs, CMAC_loop, loopargs);
             d = Time_F(STOP);
             print_result(D_EVP_CMAC, testnum, count, d);
+            if (count &lt; 0)
+                break;
         }
         for (i = 0; i &lt; loopargs_len; i++)
-            CMAC_CTX_free(loopargs[i].cmac_ctx);
+            EVP_MAC_CTX_free(loopargs[i].mctx);
+        EVP_MAC_free(mac);
     }
-#endif
 
     for (i = 0; i &lt; loopargs_len; i++)
         if (RAND_bytes(loopargs[i].buf, 36) &lt;= 0)
             goto end;
 
-#ifndef OPENSSL_NO_DEPRECATED_3_0
     for (testnum = 0; testnum &lt; RSA_NUM; testnum++) {
+        EVP_PKEY *rsa_key = NULL;
         int st = 0;
+
         if (!rsa_doit[testnum])
             continue;
-        for (i = 0; i &lt; loopargs_len; i++) {
-            if (primes &gt; RSA_DEFAULT_PRIME_NUM) {
-                /* we haven't set keys yet,  generate multi-prime RSA keys */
-                BIGNUM *bn = BN_new();
-
-                if (bn == NULL)
-                    goto end;
-                if (!BN_set_word(bn, RSA_F4)) {
-                    BN_free(bn);
-                    goto end;
-                }
 
-                BIO_printf(bio_err, &quot;Generate multi-prime RSA key for %s\n&quot;,
-                           rsa_choices[testnum].name);
+        if (primes &gt; RSA_DEFAULT_PRIME_NUM) {
+            /* we haven't set keys yet,  generate multi-prime RSA keys */
+            bn = BN_new();
+            st = bn != NULL
+                &amp;&amp; BN_set_word(bn, RSA_F4)
+                &amp;&amp; init_gen_str(&amp;genctx, &quot;RSA&quot;, NULL, 0, NULL, NULL)
+                &amp;&amp; EVP_PKEY_CTX_set_rsa_keygen_bits(genctx, rsa_keys[testnum].bits) &gt; 0
+                &amp;&amp; EVP_PKEY_CTX_set1_rsa_keygen_pubexp(genctx, bn) &gt; 0
+                &amp;&amp; EVP_PKEY_CTX_set_rsa_keygen_primes(genctx, primes) &gt; 0
+                &amp;&amp; EVP_PKEY_keygen(genctx, &amp;rsa_key);
+            BN_free(bn);
+            bn = NULL;
+            EVP_PKEY_CTX_free(genctx);
+            genctx = NULL;
+        } else {
+            const unsigned char *p = rsa_keys[testnum].data;
 
-                loopargs[i].rsa_key[testnum] = RSA_new();
-                if (loopargs[i].rsa_key[testnum] == NULL) {
-                    BN_free(bn);
-                    goto end;
-                }
+            st = (rsa_key = d2i_PrivateKey(EVP_PKEY_RSA, NULL, &amp;p,
+                                           rsa_keys[testnum].length)) != NULL;
+        }
 
-                if (!RSA_generate_multi_prime_key(loopargs[i].rsa_key[testnum],
-                                                  rsa_keys[testnum].bits,
-                                                  primes, bn, NULL)) {
-                    BN_free(bn);
-                    goto end;
-                }
-                BN_free(bn);
-            }
-            st = RSA_sign(NID_md5_sha1, loopargs[i].buf, 36, loopargs[i].buf2,
-                          &amp;loopargs[i].siglen, loopargs[i].rsa_key[testnum]);
-            if (st == 0)
-                break;
+        for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+            loopargs[i].rsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key, NULL);
+            if (loopargs[i].rsa_sign_ctx[testnum] == NULL
+                || EVP_PKEY_sign_init(loopargs[i].rsa_sign_ctx[testnum]) &lt;= 0
+                || EVP_PKEY_sign(loopargs[i].rsa_sign_ctx[testnum],
+                                 loopargs[i].buf2,
+                                 &amp;loopargs[i].sigsize,
+                                 loopargs[i].buf, 36) &lt;= 0)
+                st = 0;
         }
-        if (st == 0) {
+        if (!st) {
             BIO_printf(bio_err,
-                       &quot;RSA sign failure.  No RSA sign will be done.\n&quot;);
+                       &quot;RSA sign setup failure.  No RSA sign will be done.\n&quot;);
             ERR_print_errors(bio_err);
             op_count = 1;
         } else {
@@ -3087,15 +2407,20 @@ int speed_main(int argc, char **argv)
             op_count = count;
         }
 
-        for (i = 0; i &lt; loopargs_len; i++) {
-            st = RSA_verify(NID_md5_sha1, loopargs[i].buf, 36, loopargs[i].buf2,
-                            loopargs[i].siglen, loopargs[i].rsa_key[testnum]);
-            if (st &lt;= 0)
-                break;
+        for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+            loopargs[i].rsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key,
+                                                                   NULL);
+            if (loopargs[i].rsa_verify_ctx[testnum] == NULL
+                || EVP_PKEY_verify_init(loopargs[i].rsa_verify_ctx[testnum]) &lt;= 0
+                || EVP_PKEY_verify(loopargs[i].rsa_verify_ctx[testnum],
+                                   loopargs[i].buf2,
+                                   loopargs[i].sigsize,
+                                   loopargs[i].buf, 36) &lt;= 0)
+                st = 0;
         }
-        if (st &lt;= 0) {
+        if (!st) {
             BIO_printf(bio_err,
-                       &quot;RSA verify failure.  No RSA verify will be done.\n&quot;);
+                       &quot;RSA verify setup failure.  No RSA verify will be done.\n&quot;);
             ERR_print_errors(bio_err);
             rsa_doit[testnum] = 0;
         } else {
@@ -3116,30 +2441,33 @@ int speed_main(int argc, char **argv)
             /* if longer than 10s, don't do any more */
             stop_it(rsa_doit, testnum);
         }
+        EVP_PKEY_free(rsa_key);
     }
-#endif  /* OPENSSL_NO_DEPRECATED_3_0 */
-
-    for (i = 0; i &lt; loopargs_len; i++)
-        if (RAND_bytes(loopargs[i].buf, 36) &lt;= 0)
-            goto end;
 
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     for (testnum = 0; testnum &lt; DSA_NUM; testnum++) {
-        int st = 0;
+        EVP_PKEY *dsa_key = NULL;
+        int st;
+
         if (!dsa_doit[testnum])
             continue;
 
-        /* DSA_generate_key(dsa_key[testnum]); */
-        /* DSA_sign_setup(dsa_key[testnum],NULL); */
-        for (i = 0; i &lt; loopargs_len; i++) {
-            st = DSA_sign(0, loopargs[i].buf, 20, loopargs[i].buf2,
-                          &amp;loopargs[i].siglen, loopargs[i].dsa_key[testnum]);
-            if (st == 0)
-                break;
+        st = (dsa_key = get_dsa(dsa_bits[testnum])) != NULL;
+
+        for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+            loopargs[i].dsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(dsa_key,
+                                                                 NULL);
+            if (loopargs[i].dsa_sign_ctx[testnum] == NULL
+                || EVP_PKEY_sign_init(loopargs[i].dsa_sign_ctx[testnum]) &lt;= 0
+
+                || EVP_PKEY_sign(loopargs[i].dsa_sign_ctx[testnum],
+                                 loopargs[i].buf2,
+                                 &amp;loopargs[i].sigsize,
+                                 loopargs[i].buf, 20) &lt;= 0)
+                st = 0;
         }
-        if (st == 0) {
+        if (!st) {
             BIO_printf(bio_err,
-                       &quot;DSA sign failure.  No DSA sign will be done.\n&quot;);
+                       &quot;DSA sign setup failure.  No DSA sign will be done.\n&quot;);
             ERR_print_errors(bio_err);
             op_count = 1;
         } else {
@@ -3157,15 +2485,20 @@ int speed_main(int argc, char **argv)
             op_count = count;
         }
 
-        for (i = 0; i &lt; loopargs_len; i++) {
-            st = DSA_verify(0, loopargs[i].buf, 20, loopargs[i].buf2,
-                            loopargs[i].siglen, loopargs[i].dsa_key[testnum]);
-            if (st &lt;= 0)
-                break;
+        for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+            loopargs[i].dsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(dsa_key,
+                                                                   NULL);
+            if (loopargs[i].dsa_verify_ctx[testnum] == NULL
+                || EVP_PKEY_verify_init(loopargs[i].dsa_verify_ctx[testnum]) &lt;= 0
+                || EVP_PKEY_verify(loopargs[i].dsa_verify_ctx[testnum],
+                                   loopargs[i].buf2,
+                                   loopargs[i].sigsize,
+                                   loopargs[i].buf, 36) &lt;= 0)
+                st = 0;
         }
-        if (st &lt;= 0) {
+        if (!st) {
             BIO_printf(bio_err,
-                       &quot;DSA verify failure.  No DSA verify will be done.\n&quot;);
+                       &quot;DSA verify setup failure.  No DSA verify will be done.\n&quot;);
             ERR_print_errors(bio_err);
             dsa_doit[testnum] = 0;
         } else {
@@ -3186,93 +2519,85 @@ int speed_main(int argc, char **argv)
             /* if longer than 10s, don't do any more */
             stop_it(dsa_doit, testnum);
         }
+        EVP_PKEY_free(dsa_key);
     }
-#endif                          /* OPENSSL_NO_DSA */
 
-#ifndef OPENSSL_NO_EC
-# ifndef OPENSSL_NO_DEPRECATED_3_0
     for (testnum = 0; testnum &lt; ECDSA_NUM; testnum++) {
-        int st = 1;
+        EVP_PKEY *ecdsa_key = NULL;
+        int st;
 
         if (!ecdsa_doit[testnum])
-            continue;           /* Ignore Curve */
-        for (i = 0; i &lt; loopargs_len; i++) {
-            loopargs[i].ecdsa[testnum] =
-                EC_KEY_new_by_curve_name(ec_curves[testnum].nid);
-            if (loopargs[i].ecdsa[testnum] == NULL) {
+            continue;
+
+        st = (ecdsa_key = get_ecdsa(&amp;ec_curves[testnum])) != NULL;
+
+        for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+            loopargs[i].ecdsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(ecdsa_key,
+                                                                   NULL);
+            if (loopargs[i].ecdsa_sign_ctx[testnum] == NULL
+                || EVP_PKEY_sign_init(loopargs[i].ecdsa_sign_ctx[testnum]) &lt;= 0
+
+                || EVP_PKEY_sign(loopargs[i].ecdsa_sign_ctx[testnum],
+                                 loopargs[i].buf2,
+                                 &amp;loopargs[i].sigsize,
+                                 loopargs[i].buf, 20) &lt;= 0)
                 st = 0;
-                break;
-            }
         }
-        if (st == 0) {
-            BIO_printf(bio_err, &quot;ECDSA failure.\n&quot;);
+        if (!st) {
+            BIO_printf(bio_err,
+                       &quot;ECDSA sign setup failure.  No ECDSA sign will be done.\n&quot;);
             ERR_print_errors(bio_err);
             op_count = 1;
         } else {
-            for (i = 0; i &lt; loopargs_len; i++) {
-                /* Perform ECDSA signature test */
-                EC_KEY_generate_key(loopargs[i].ecdsa[testnum]);
-                st = ECDSA_sign(0, loopargs[i].buf, 20, loopargs[i].buf2,
-                                &amp;loopargs[i].siglen,
-                                loopargs[i].ecdsa[testnum]);
-                if (st == 0)
-                    break;
-            }
-            if (st == 0) {
-                BIO_printf(bio_err,
-                           &quot;ECDSA sign failure.  No ECDSA sign will be done.\n&quot;);
-                ERR_print_errors(bio_err);
-                op_count = 1;
-            } else {
-                pkey_print_message(&quot;sign&quot;, &quot;ecdsa&quot;,
-                                   ecdsa_c[testnum][0],
-                                   ec_curves[testnum].bits, seconds.ecdsa);
-                Time_F(START);
-                count = run_benchmark(async_jobs, ECDSA_sign_loop, loopargs);
-                d = Time_F(STOP);
-
-                BIO_printf(bio_err,
-                           mr ? &quot;+R5:%ld:%u:%.2f\n&quot; :
-                           &quot;%ld %u bits ECDSA signs in %.2fs \n&quot;,
-                           count, ec_curves[testnum].bits, d);
-                ecdsa_results[testnum][0] = (double)count / d;
-                op_count = count;
-            }
+            pkey_print_message(&quot;sign&quot;, &quot;ecdsa&quot;,
+                               ecdsa_c[testnum][0], ec_curves[testnum].bits,
+                               seconds.ecdsa);
+            Time_F(START);
+            count = run_benchmark(async_jobs, ECDSA_sign_loop, loopargs);
+            d = Time_F(STOP);
+            BIO_printf(bio_err,
+                       mr ? &quot;+R5:%ld:%u:%.2f\n&quot;
+                       : &quot;%ld %u bits ECDSA signs in %.2fs\n&quot;,
+                       count, ec_curves[testnum].bits, d);
+            ecdsa_results[testnum][0] = (double)count / d;
+            op_count = count;
+        }
 
-            /* Perform ECDSA verification test */
-            for (i = 0; i &lt; loopargs_len; i++) {
-                st = ECDSA_verify(0, loopargs[i].buf, 20, loopargs[i].buf2,
-                                  loopargs[i].siglen,
-                                  loopargs[i].ecdsa[testnum]);
-                if (st != 1)
-                    break;
-            }
-            if (st != 1) {
-                BIO_printf(bio_err,
-                           &quot;ECDSA verify failure.  No ECDSA verify will be done.\n&quot;);
-                ERR_print_errors(bio_err);
-                ecdsa_doit[testnum] = 0;
-            } else {
-                pkey_print_message(&quot;verify&quot;, &quot;ecdsa&quot;,
-                                   ecdsa_c[testnum][1],
-                                   ec_curves[testnum].bits, seconds.ecdsa);
-                Time_F(START);
-                count = run_benchmark(async_jobs, ECDSA_verify_loop, loopargs);
-                d = Time_F(STOP);
-                BIO_printf(bio_err,
-                           mr ? &quot;+R6:%ld:%u:%.2f\n&quot;
-                           : &quot;%ld %u bits ECDSA verify in %.2fs\n&quot;,
-                           count, ec_curves[testnum].bits, d);
-                ecdsa_results[testnum][1] = (double)count / d;
-            }
+        for (i = 0; st &amp;&amp; i &lt; loopargs_len; i++) {
+            loopargs[i].ecdsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(ecdsa_key,
+                                                                     NULL);
+            if (loopargs[i].ecdsa_verify_ctx[testnum] == NULL
+                || EVP_PKEY_verify_init(loopargs[i].ecdsa_verify_ctx[testnum]) &lt;= 0
+                || EVP_PKEY_verify(loopargs[i].ecdsa_verify_ctx[testnum],
+                                   loopargs[i].buf2,
+                                   loopargs[i].sigsize,
+                                   loopargs[i].buf, 20) &lt;= 0)
+                st = 0;
+        }
+        if (!st) {
+            BIO_printf(bio_err,
+                       &quot;ECDSA verify setup failure.  No ECDSA verify will be done.\n&quot;);
+            ERR_print_errors(bio_err);
+            ecdsa_doit[testnum] = 0;
+        } else {
+            pkey_print_message(&quot;verify&quot;, &quot;ecdsa&quot;,
+                               ecdsa_c[testnum][1], ec_curves[testnum].bits,
+                               seconds.ecdsa);
+            Time_F(START);
+            count = run_benchmark(async_jobs, ECDSA_verify_loop, loopargs);
+            d = Time_F(STOP);
+            BIO_printf(bio_err,
+                       mr ? &quot;+R6:%ld:%u:%.2f\n&quot;
+                       : &quot;%ld %u bits ECDSA verify in %.2fs\n&quot;,
+                       count, ec_curves[testnum].bits, d);
+            ecdsa_results[testnum][1] = (double)count / d;
+        }
 
-            if (op_count &lt;= 1) {
-                /* if longer than 10s, don't do any more */
-                stop_it(ecdsa_doit, testnum);
-            }
+        if (op_count &lt;= 1) {
+            /* if longer than 10s, don't do any more */
+            stop_it(ecdsa_doit, testnum);
         }
     }
-# endif /* OPENSSL_NO_DEPRECATED_3_0 */
 
     for (testnum = 0; testnum &lt; EC_NUM; testnum++) {
         int ecdh_checks = 1;
@@ -3281,7 +2606,6 @@ int speed_main(int argc, char **argv)
             continue;
 
         for (i = 0; i &lt; loopargs_len; i++) {
-            EVP_PKEY_CTX *kctx = NULL;
             EVP_PKEY_CTX *test_ctx = NULL;
             EVP_PKEY_CTX *ctx = NULL;
             EVP_PKEY *key_A = NULL;
@@ -3289,83 +2613,14 @@ int speed_main(int argc, char **argv)
             size_t outlen;
             size_t test_outlen;
 
-            /* Ensure that the error queue is empty */
-            if (ERR_peek_error()) {
-                BIO_printf(bio_err,
-                           &quot;WARNING: the error queue contains previous unhandled errors.\n&quot;);
-                ERR_print_errors(bio_err);
-            }
-
-            /* Let's try to create a ctx directly from the NID: this works for
-             * curves like Curve25519 that are not implemented through the low
-             * level EC interface.
-             * If this fails we try creating a EVP_PKEY_EC generic param ctx,
-             * then we set the curve by NID before deriving the actual keygen
-             * ctx for that specific curve. */
-            kctx = EVP_PKEY_CTX_new_id(ec_curves[testnum].nid, NULL); /* keygen ctx from NID */
-            if (!kctx) {
-                EVP_PKEY_CTX *pctx = NULL;
-                EVP_PKEY *params = NULL;
-
-                /* If we reach this code EVP_PKEY_CTX_new_id() failed and a
-                 * &quot;int_ctx_new:unsupported algorithm&quot; error was added to the
-                 * error queue.
-                 * We remove it from the error queue as we are handling it. */
-                unsigned long error = ERR_peek_error(); /* peek the latest error in the queue */
-                if (error == ERR_peek_last_error() &amp;&amp; /* oldest and latest errors match */
-                    /* check that the error origin matches */
-                    ERR_GET_LIB(error) == ERR_LIB_EVP &amp;&amp;
-                    ERR_GET_REASON(error) == EVP_R_UNSUPPORTED_ALGORITHM)
-                    ERR_get_error(); /* pop error from queue */
-                if (ERR_peek_error()) {
-                    BIO_printf(bio_err,
-                               &quot;Unhandled error in the error queue during ECDH init.\n&quot;);
-                    ERR_print_errors(bio_err);
-                    op_count = 1;
-                    break;
-                }
-
-                /* Create the context for parameter generation */
-                if (!(pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL)) ||
-                       /* Initialise the parameter generation */
-                       !EVP_PKEY_paramgen_init(pctx) ||
-                       /* Set the curve by NID */
-                       !EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx,
-                                                               ec_curves
-                                                               [testnum].nid) ||
-                       /* Create the parameter object params */
-                       !EVP_PKEY_paramgen(pctx, &amp;params)) {
-                    ecdh_checks = 0;
-                    BIO_printf(bio_err, &quot;ECDH EC params init failure.\n&quot;);
-                    ERR_print_errors(bio_err);
-                    op_count = 1;
-                    break;
-                }
-                /* Create the context for the key generation */
-                kctx = EVP_PKEY_CTX_new(params, NULL);
-
-                EVP_PKEY_free(params);
-                params = NULL;
-                EVP_PKEY_CTX_free(pctx);
-                pctx = NULL;
-            }
-            if (kctx == NULL ||      /* keygen ctx is not null */
-                EVP_PKEY_keygen_init(kctx) &lt;= 0/* init keygen ctx */ ) {
-                ecdh_checks = 0;
-                BIO_printf(bio_err, &quot;ECDH keygen failure.\n&quot;);
-                ERR_print_errors(bio_err);
-                op_count = 1;
-                break;
-            }
-
-            if (EVP_PKEY_keygen(kctx, &amp;key_A) &lt;= 0 || /* generate secret key A */
-                EVP_PKEY_keygen(kctx, &amp;key_B) &lt;= 0 || /* generate secret key B */
-                !(ctx = EVP_PKEY_CTX_new(key_A, NULL)) || /* derivation ctx from skeyA */
-                EVP_PKEY_derive_init(ctx) &lt;= 0 || /* init derivation ctx */
-                EVP_PKEY_derive_set_peer(ctx, key_B) &lt;= 0 || /* set peer pubkey in ctx */
-                EVP_PKEY_derive(ctx, NULL, &amp;outlen) &lt;= 0 || /* determine max length */
-                outlen == 0 ||  /* ensure outlen is a valid size */
-                outlen &gt; MAX_ECDH_SIZE /* avoid buffer overflow */ ) {
+            if ((key_A = get_ecdsa(&amp;ec_curves[testnum])) == NULL /* generate secret key A */
+                || (key_B = get_ecdsa(&amp;ec_curves[testnum])) == NULL /* generate secret key B */
+                || (ctx = EVP_PKEY_CTX_new(key_A, NULL)) == NULL /* derivation ctx from skeyA */
+                || EVP_PKEY_derive_init(ctx) &lt;= 0 /* init derivation ctx */
+                || EVP_PKEY_derive_set_peer(ctx, key_B) &lt;= 0 /* set peer pubkey in ctx */
+                || EVP_PKEY_derive(ctx, NULL, &amp;outlen) &lt;= 0 /* determine max length */
+                || outlen == 0 /* ensure outlen is a valid size */
+                || outlen &gt; MAX_ECDH_SIZE /* avoid buffer overflow */) {
                 ecdh_checks = 0;
                 BIO_printf(bio_err, &quot;ECDH key generation failure.\n&quot;);
                 ERR_print_errors(bio_err);
@@ -3373,17 +2628,19 @@ int speed_main(int argc, char **argv)
                 break;
             }
 
-            /* Here we perform a test run, comparing the output of a*B and b*A;
+            /*
+             * Here we perform a test run, comparing the output of a*B and b*A;
              * we try this here and assume that further EVP_PKEY_derive calls
              * never fail, so we can skip checks in the actually benchmarked
-             * code, for maximum performance. */
-            if (!(test_ctx = EVP_PKEY_CTX_new(key_B, NULL)) || /* test ctx from skeyB */
-                !EVP_PKEY_derive_init(test_ctx) || /* init derivation test_ctx */
-                !EVP_PKEY_derive_set_peer(test_ctx, key_A) || /* set peer pubkey in test_ctx */
-                !EVP_PKEY_derive(test_ctx, NULL, &amp;test_outlen) || /* determine max length */
-                !EVP_PKEY_derive(ctx, loopargs[i].secret_a, &amp;outlen) || /* compute a*B */
-                !EVP_PKEY_derive(test_ctx, loopargs[i].secret_b, &amp;test_outlen) || /* compute b*A */
-                test_outlen != outlen /* compare output length */ ) {
+             * code, for maximum performance.
+             */
+            if ((test_ctx = EVP_PKEY_CTX_new(key_B, NULL)) == NULL /* test ctx from skeyB */
+                || !EVP_PKEY_derive_init(test_ctx) /* init derivation test_ctx */
+                || !EVP_PKEY_derive_set_peer(test_ctx, key_A) /* set peer pubkey in test_ctx */
+                || !EVP_PKEY_derive(test_ctx, NULL, &amp;test_outlen) /* determine max length */
+                || !EVP_PKEY_derive(ctx, loopargs[i].secret_a, &amp;outlen) /* compute a*B */
+                || !EVP_PKEY_derive(test_ctx, loopargs[i].secret_b, &amp;test_outlen) /* compute b*A */
+                || test_outlen != outlen /* compare output length */) {
                 ecdh_checks = 0;
                 BIO_printf(bio_err, &quot;ECDH computation failure.\n&quot;);
                 ERR_print_errors(bio_err);
@@ -3406,8 +2663,6 @@ int speed_main(int argc, char **argv)
 
             EVP_PKEY_free(key_A);
             EVP_PKEY_free(key_B);
-            EVP_PKEY_CTX_free(kctx);
-            kctx = NULL;
             EVP_PKEY_CTX_free(test_ctx);
             test_ctx = NULL;
         }
@@ -3452,8 +2707,8 @@ int speed_main(int argc, char **argv)
                 break;
             }
 
-            if ((ed_pctx = EVP_PKEY_CTX_new_id(ed_curves[testnum].nid, NULL))
-                    == NULL
+            if ((ed_pctx = EVP_PKEY_CTX_new_id(ed_curves[testnum].nid,
+                                               NULL)) == NULL
                 || EVP_PKEY_keygen_init(ed_pctx) &lt;= 0
                 || EVP_PKEY_keygen(ed_pctx, &amp;ed_pkey) &lt;= 0) {
                 st = 0;
@@ -3468,8 +2723,8 @@ int speed_main(int argc, char **argv)
                 EVP_PKEY_free(ed_pkey);
                 break;
             }
-           if (!EVP_DigestVerifyInit(loopargs[i].eddsa_ctx2[testnum], NULL,
-                                     NULL, NULL, ed_pkey)) {
+            if (!EVP_DigestVerifyInit(loopargs[i].eddsa_ctx2[testnum], NULL,
+                                      NULL, NULL, ed_pkey)) {
                 st = 0;
                 EVP_PKEY_free(ed_pkey);
                 break;
@@ -3548,7 +2803,7 @@ int speed_main(int argc, char **argv)
         }
     }
 
-# ifndef OPENSSL_NO_SM2
+#ifndef OPENSSL_NO_SM2
     for (testnum = 0; testnum &lt; SM2_NUM; testnum++) {
         int st = 1;
         EVP_PKEY *sm2_pkey = NULL;
@@ -3681,8 +2936,7 @@ int speed_main(int argc, char **argv)
             }
         }
     }
-# endif                         /* OPENSSL_NO_SM2 */
-#endif                          /* OPENSSL_NO_EC */
+#endif                         /* OPENSSL_NO_SM2 */
 
 #ifndef OPENSSL_NO_DH
     for (testnum = 0; testnum &lt; FFDH_NUM; testnum++) {
@@ -3758,11 +3012,13 @@ int speed_main(int argc, char **argv)
 
             EVP_PKEY_CTX_free(ffdh_ctx);
 
-            /* check if the derivation works correctly both ways so that
+            /*
+             * check if the derivation works correctly both ways so that
              * we know if future derive calls will fail, and we can skip
-             * error checking in benchmarked code */
+             * error checking in benchmarked code
+             */
             ffdh_ctx = EVP_PKEY_CTX_new(pkey_A, NULL);
-            if (!ffdh_ctx) {
+            if (ffdh_ctx == NULL) {
                 BIO_printf(bio_err, &quot;Error while allocating EVP_PKEY_CTX.\n&quot;);
                 ERR_print_errors(bio_err);
                 op_count = 1;
@@ -3857,7 +3113,7 @@ int speed_main(int argc, char **argv)
                        ffdh_params[testnum].bits, d);
             ffdh_results[testnum][0] = (double)count / d;
             op_count = count;
-        };
+        }
         if (op_count &lt;= 1) {
             /* if longer than 10s, don't do any more */
             stop_it(ffdh_doit, testnum);
@@ -3872,34 +3128,15 @@ int speed_main(int argc, char **argv)
         printf(&quot;built on: %s\n&quot;, OpenSSL_version(OPENSSL_BUILT_ON));
         printf(&quot;options:&quot;);
         printf(&quot;%s &quot;, BN_options());
-#if !defined(OPENSSL_NO_MD2) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-        printf(&quot;%s &quot;, MD2_options());
-#endif
-#if !defined(OPENSSL_NO_RC4) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-        printf(&quot;%s &quot;, RC4_options());
-#endif
-#if !defined(OPENSSL_NO_DES) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-        printf(&quot;%s &quot;, DES_options());
-#endif
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-        printf(&quot;%s &quot;, AES_options());
-#endif
-#if !defined(OPENSSL_NO_IDEA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-        printf(&quot;%s &quot;, IDEA_options());
-#endif
-#if !defined(OPENSSL_NO_BF) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-        printf(&quot;%s &quot;, BF_options());
-#endif
         printf(&quot;\n%s\n&quot;, OpenSSL_version(OPENSSL_CFLAGS));
         printf(&quot;%s\n&quot;, OpenSSL_version(OPENSSL_CPU_INFO));
     }
 
     if (pr_header) {
-        if (mr)
+        if (mr) {
             printf(&quot;+H&quot;);
-        else {
-            printf
-                (&quot;The 'numbers' are in 1000s of bytes per second processed.\n&quot;);
+        } else {
+            printf(&quot;The 'numbers' are in 1000s of bytes per second processed.\n&quot;);
             printf(&quot;type        &quot;);
         }
         for (testnum = 0; testnum &lt; size_num; testnum++)
@@ -3922,7 +3159,6 @@ int speed_main(int argc, char **argv)
         }
         printf(&quot;\n&quot;);
     }
-#ifndef OPENSSL_NO_DEPRECATED_3_0
     testnum = 1;
     for (k = 0; k &lt; RSA_NUM; k++) {
         if (!rsa_doit[k])
@@ -3939,8 +3175,6 @@ int speed_main(int argc, char **argv)
                    rsa_keys[k].bits, 1.0 / rsa_results[k][0], 1.0 / rsa_results[k][1],
                    rsa_results[k][0], rsa_results[k][1]);
     }
-#endif
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     testnum = 1;
     for (k = 0; k &lt; DSA_NUM; k++) {
         if (!dsa_doit[k])
@@ -3957,8 +3191,6 @@ int speed_main(int argc, char **argv)
                    dsa_bits[k], 1.0 / dsa_results[k][0], 1.0 / dsa_results[k][1],
                    dsa_results[k][0], dsa_results[k][1]);
     }
-#endif
-#ifndef OPENSSL_NO_EC
     testnum = 1;
     for (k = 0; k &lt; OSSL_NELEM(ecdsa_doit); k++) {
         if (!ecdsa_doit[k])
@@ -4018,7 +3250,7 @@ int speed_main(int argc, char **argv)
                    eddsa_results[k][0], eddsa_results[k][1]);
     }
 
-# ifndef OPENSSL_NO_SM2
+#ifndef OPENSSL_NO_SM2
     testnum = 1;
     for (k = 0; k &lt; OSSL_NELEM(sm2_doit); k++) {
         if (!sm2_doit[k])
@@ -4038,8 +3270,7 @@ int speed_main(int argc, char **argv)
                    1.0 / sm2_results[k][0], 1.0 / sm2_results[k][1],
                    sm2_results[k][0], sm2_results[k][1]);
     }
-# endif
-#endif                          /* OPENSSL_NO_EC */
+#endif
 #ifndef OPENSSL_NO_DH
     testnum = 1;
     for (k = 0; k &lt; FFDH_NUM; k++) {
@@ -4069,33 +3300,33 @@ int speed_main(int argc, char **argv)
         OPENSSL_free(loopargs[i].buf_malloc);
         OPENSSL_free(loopargs[i].buf2_malloc);
 
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-        for (k = 0; k &lt; RSA_NUM; k++)
-            RSA_free(loopargs[i].rsa_key[k]);
-#endif
+        BN_free(bn);
+        EVP_PKEY_CTX_free(genctx);
+        for (k = 0; k &lt; RSA_NUM; k++) {
+            EVP_PKEY_CTX_free(loopargs[i].rsa_sign_ctx[k]);
+            EVP_PKEY_CTX_free(loopargs[i].rsa_verify_ctx[k]);
+        }
 #ifndef OPENSSL_NO_DH
         OPENSSL_free(loopargs[i].secret_ff_a);
         OPENSSL_free(loopargs[i].secret_ff_b);
-        for (k = 0; k &lt; FFDH_NUM; k++) {
+        for (k = 0; k &lt; FFDH_NUM; k++)
             EVP_PKEY_CTX_free(loopargs[i].ffdh_ctx[k]);
-        }
-#endif
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-        for (k = 0; k &lt; DSA_NUM; k++)
-            DSA_free(loopargs[i].dsa_key[k]);
 #endif
-#ifndef OPENSSL_NO_EC
-# if !defined(OPENSSL_NO_DEPRECATED_3_0)
-        for (k = 0; k &lt; ECDSA_NUM; k++)
-            EC_KEY_free(loopargs[i].ecdsa[k]);
-# endif
+        for (k = 0; k &lt; DSA_NUM; k++) {
+            EVP_PKEY_CTX_free(loopargs[i].dsa_sign_ctx[k]);
+            EVP_PKEY_CTX_free(loopargs[i].dsa_verify_ctx[k]);
+        }
+        for (k = 0; k &lt; ECDSA_NUM; k++) {
+            EVP_PKEY_CTX_free(loopargs[i].ecdsa_sign_ctx[k]);
+            EVP_PKEY_CTX_free(loopargs[i].ecdsa_verify_ctx[k]);
+        }
         for (k = 0; k &lt; EC_NUM; k++)
             EVP_PKEY_CTX_free(loopargs[i].ecdh_ctx[k]);
         for (k = 0; k &lt; EdDSA_NUM; k++) {
             EVP_MD_CTX_free(loopargs[i].eddsa_ctx[k]);
             EVP_MD_CTX_free(loopargs[i].eddsa_ctx2[k]);
-	}
-# ifndef OPENSSL_NO_SM2
+        }
+#ifndef OPENSSL_NO_SM2
         for (k = 0; k &lt; SM2_NUM; k++) {
             EVP_PKEY_CTX *pctx = NULL;
 
@@ -4112,17 +3343,12 @@ int speed_main(int argc, char **argv)
             /* free pkey */
             EVP_PKEY_free(loopargs[i].sm2_pkey[k]);
         }
-# endif
+#endif
         OPENSSL_free(loopargs[i].secret_a);
         OPENSSL_free(loopargs[i].secret_b);
-#endif
     }
-#ifndef OPENSSL_NO_DEPRECATED_3_0
     OPENSSL_free(evp_hmac_name);
-#endif
-#if !defined(OPENSSL_NO_CMAC) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
     OPENSSL_free(evp_cmac_name);
-#endif
 
     if (async_jobs &gt; 0) {
         for (i = 0; i &lt; loopargs_len; i++)
@@ -4134,8 +3360,7 @@ int speed_main(int argc, char **argv)
     }
     OPENSSL_free(loopargs);
     release_engine(e);
-    if (fetched_alg) {
-        EVP_MD_free(evp_md);
+    if (fetched_cipher) {
         EVP_CIPHER_free(evp_cipher);
     }
     return ret;
@@ -4143,50 +3368,30 @@ int speed_main(int argc, char **argv)
 
 static void print_message(const char *s, long num, int length, int tm)
 {
-#ifdef SIGALRM
     BIO_printf(bio_err,
                mr ? &quot;+DT:%s:%d:%d\n&quot;
                : &quot;Doing %s for %ds on %d size blocks: &quot;, s, tm, length);
     (void)BIO_flush(bio_err);
     run = 1;
     alarm(tm);
-#else
-    BIO_printf(bio_err,
-               mr ? &quot;+DN:%s:%ld:%d\n&quot;
-               : &quot;Doing %s %ld times on %d size blocks: &quot;, s, num, length);
-    (void)BIO_flush(bio_err);
-#endif
 }
 
-#if !defined(OPENSSL_NO_DEPRECATED_3_0)         \
-    || !defined(OPENSSL_NO_DSA)                 \
-    || !defined(OPENSSL_NO_DH)                  \
-    || !defined(OPENSSL_NO_EC)
 static void pkey_print_message(const char *str, const char *str2, long num,
                                unsigned int bits, int tm)
 {
-# ifdef SIGALRM
     BIO_printf(bio_err,
                mr ? &quot;+DTP:%d:%s:%s:%d\n&quot;
                : &quot;Doing %u bits %s %s's for %ds: &quot;, bits, str, str2, tm);
     (void)BIO_flush(bio_err);
     run = 1;
     alarm(tm);
-# else
-    BIO_printf(bio_err,
-               mr ? &quot;+DNP:%ld:%d:%s:%s\n&quot;
-               : &quot;Doing %ld %u bits %s %s's: &quot;, num, bits, str, str2);
-    (void)BIO_flush(bio_err);
-# endif
 }
-#endif
 
 static void print_result(int alg, int run_no, int count, double time_used)
 {
     if (count == -1) {
         BIO_printf(bio_err, &quot;%s error!\n&quot;, names[alg]);
         ERR_print_errors(bio_err);
-        /* exit(1);  disable exit until default provider enabled */
         return;
     }
     BIO_printf(bio_err,
@@ -4212,9 +3417,8 @@ static char *sstrsep(char **string, const char *delim)
         delim++;
     }
 
-    while (!isdelim[(unsigned char)(**string)]) {
+    while (!isdelim[(unsigned char)(**string)])
         (*string)++;
-    }
 
     if (**string) {
         **string = 0;
@@ -4285,9 +3489,7 @@ static int do_multi(int multi, int size_num)
                 sstrsep(&amp;p, sep);
                 for (j = 0; j &lt; size_num; ++j)
                     results[alg][j] += atof(sstrsep(&amp;p, sep));
-            }
-#ifndef OPENSSL_NO_DEPRECATED_3_0
-            else if (strncmp(buf, &quot;+F2:&quot;, 4) == 0) {
+            } else if (strncmp(buf, &quot;+F2:&quot;, 4) == 0) {
                 int k;
                 double d;
 
@@ -4300,10 +3502,7 @@ static int do_multi(int multi, int size_num)
 
                 d = atof(sstrsep(&amp;p, sep));
                 rsa_results[k][1] += d;
-            }
-#endif
-#if !defined(OPENSSL_NO_DSA) &amp;&amp; !defined(OPENSSL_NO_DEPRECATED_3_0)
-            else if (strncmp(buf, &quot;+F3:&quot;, 4) == 0) {
+            } else if (strncmp(buf, &quot;+F3:&quot;, 4) == 0) {
                 int k;
                 double d;
 
@@ -4316,10 +3515,7 @@ static int do_multi(int multi, int size_num)
 
                 d = atof(sstrsep(&amp;p, sep));
                 dsa_results[k][1] += d;
-            }
-# endif
-# ifndef OPENSSL_NO_EC
-            else if (strncmp(buf, &quot;+F4:&quot;, 4) == 0) {
+            } else if (strncmp(buf, &quot;+F4:&quot;, 4) == 0) {
                 int k;
                 double d;
 
@@ -4356,9 +3552,8 @@ static int do_multi(int multi, int size_num)
 
                 d = atof(sstrsep(&amp;p, sep));
                 eddsa_results[k][1] += d;
-            }
-#  ifndef OPENSSL_NO_SM2
-            else if (strncmp(buf, &quot;+F7:&quot;, 4) == 0) {
+# ifndef OPENSSL_NO_SM2
+            } else if (strncmp(buf, &quot;+F7:&quot;, 4) == 0) {
                 int k;
                 double d;
 
@@ -4372,11 +3567,9 @@ static int do_multi(int multi, int size_num)
 
                 d = atof(sstrsep(&amp;p, sep));
                 sm2_results[k][1] += d;
-            }
-#  endif /* OPENSSL_NO_SM2 */
-# endif /* OPENSSL_NO_EC */
+# endif /* OPENSSL_NO_SM2 */
 # ifndef OPENSSL_NO_DH
-            else if (strncmp(buf, &quot;+F8:&quot;, 4) == 0) {
+            } else if (strncmp(buf, &quot;+F8:&quot;, 4) == 0) {
                 int k;
                 double d;
 
@@ -4386,14 +3579,13 @@ static int do_multi(int multi, int size_num)
 
                 d = atof(sstrsep(&amp;p, sep));
                 ffdh_results[k][0] += d;
-            }
 # endif /* OPENSSL_NO_DH */
-
-            else if (strncmp(buf, &quot;+H:&quot;, 3) == 0) {
+            } else if (strncmp(buf, &quot;+H:&quot;, 3) == 0) {
                 ;
-            } else
+            } else {
                 BIO_printf(bio_err, &quot;Unknown type '%s' from child %d\n&quot;, buf,
                            n);
+            }
         }
 
         fclose(f);
diff --git a/apps/testdsa.h b/apps/testdsa.h
index b7d288a66b..65028be46f 100644
--- a/apps/testdsa.h
+++ b/apps/testdsa.h
@@ -7,8 +7,10 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
+#include &lt;openssl/param_build.h&gt;
+
 /* used by speed.c */
-DSA *get_dsa(int);
+EVP_PKEY *get_dsa(int);
 
 static unsigned char dsa512_priv[] = {
     0x65, 0xe5, 0xc7, 0x38, 0x60, 0x24, 0xb5, 0x89, 0xd4, 0x9c, 0xeb, 0x4c,
@@ -211,11 +213,14 @@ typedef struct testdsa_st {
         st.q_l = sizeof(dsa##bits##_q); \
     } while (0)
 
-DSA *get_dsa(int dsa_bits)
+EVP_PKEY *get_dsa(int dsa_bits)
 {
-    DSA *dsa;
+    EVP_PKEY *pkey = NULL;
     BIGNUM *priv_key, *pub_key, *p, *q, *g;
+    EVP_PKEY_CTX *pctx;
     testdsa dsa_t;
+    OSSL_PARAM_BLD *tmpl = NULL;
+    OSSL_PARAM *params = NULL;
 
     switch (dsa_bits) {
     case 512:
@@ -231,30 +236,44 @@ DSA *get_dsa(int dsa_bits)
         return NULL;
     }
 
-    if ((dsa = DSA_new()) == NULL)
+    if ((pctx = EVP_PKEY_CTX_new_from_name(NULL, &quot;DSA&quot;, NULL)) == NULL)
         return NULL;
+
     priv_key = BN_bin2bn(dsa_t.priv, dsa_t.priv_l, NULL);
     pub_key = BN_bin2bn(dsa_t.pub, dsa_t.pub_l, NULL);
     p = BN_bin2bn(dsa_t.p, dsa_t.p_l, NULL);
     q = BN_bin2bn(dsa_t.q, dsa_t.q_l, NULL);
     g = BN_bin2bn(dsa_t.g, dsa_t.g_l, NULL);
-    if ((priv_key == NULL) || (pub_key == NULL) || (p == NULL) || (q == NULL)
-         || (g == NULL)) {
+    if (priv_key == NULL || pub_key == NULL || p == NULL || q == NULL
+        || g == NULL) {
         goto err;
     }
-    if (!DSA_set0_pqg(dsa, p, q, g))
-        goto err;
-
-    if (!DSA_set0_key(dsa, pub_key, priv_key))
+    if ((tmpl = OSSL_PARAM_BLD_new()) == NULL
+        || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_FFC_P,
+                                   p)
+        || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_FFC_Q,
+                                   q)
+        || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_FFC_G,
+                                   g)
+        || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_PRIV_KEY,
+                                   priv_key)
+        || !OSSL_PARAM_BLD_push_BN(tmpl, OSSL_PKEY_PARAM_PUB_KEY,
+                                   pub_key)
+        || (params = OSSL_PARAM_BLD_to_param(tmpl)) == NULL)
         goto err;
 
-    return dsa;
- err:
-    DSA_free(dsa);
+    if (EVP_PKEY_fromdata_init(pctx) &lt;= 0
+        || EVP_PKEY_fromdata(pctx, &amp;pkey, EVP_PKEY_KEYPAIR,
+                             params) &lt;= 0)
+        pkey = NULL;
+err:
+    OSSL_PARAM_BLD_free_params(params);
+    OSSL_PARAM_BLD_free(tmpl);
     BN_free(priv_key);
     BN_free(pub_key);
     BN_free(p);
     BN_free(q);
     BN_free(g);
-    return NULL;
+    EVP_PKEY_CTX_free(pctx);
+    return pkey;
 }
</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="033244.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="033246.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33245">[ date ]</a>
              <a href="thread.html#33245">[ thread ]</a>
              <a href="subject.html#33245">[ subject ]</a>
              <a href="author.html#33245">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
