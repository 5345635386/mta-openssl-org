<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1463755719.721478.21470.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007426.html">
   <LINK REL="Next"  HREF="007439.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1463755719.721478.21470.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Fri May 20 14:48:39 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="007426.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="007439.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7428">[ date ]</a>
              <a href="thread.html#7428">[ thread ]</a>
              <a href="subject.html#7428">[ subject ]</a>
              <a href="author.html#7428">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  739a1eb1961cdc3b1597a040766f3cb359d095f6 (commit)
      from  06593767b21d4ebacc3e6ecc8daedd9d5c5f9f97 (commit)


- Log -----------------------------------------------------------------
commit 739a1eb1961cdc3b1597a040766f3cb359d095f6
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
Date:   Fri May 20 10:46:29 2016 -0400

    Rename lh_xxx,sk_xxx tp OPENSSL_{LH,SK}_xxx
    
    Rename sk_xxx to OPENSSL_sk_xxx and _STACK to OPENSSL_STACK
    Rename lh_xxx API to OPENSSL_LH_xxx and LHASH_NODE to OPENSSL_LH_NODE
    Make lhash stuff opaque.
    Use typedefs for function pointers; makes the code simpler.
    Remove CHECKED_xxx macros.
    Add documentation; remove old X509-oriented doc.
    Add API-compat names for entire old API
    
    Reviewed-by: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 CHANGES                     |   5 ++
 apps/apps.c                 |   4 +-
 apps/openssl.c              |   2 +-
 crypto/asn1/tasn_dec.c      |   2 +-
 crypto/conf/conf_api.c      |   2 +-
 crypto/lhash/lh_stats.c     |  32 ++++---
 crypto/lhash/lhash.c        | 124 +++++++++-----------------
 crypto/lhash/lhash_lcl.h    |  42 +++++++++
 crypto/objects/o_names.c    |   4 +-
 crypto/objects/obj_dat.c    |   4 +-
 crypto/stack/stack.c        | 106 ++++++++++------------
 crypto/txt_db/txt_db.c      |   4 +-
 doc/crypto/lh_stats.pod     |  25 +++---
 doc/crypto/lhash.pod        |  84 ++++++++---------
 doc/crypto/sk_X509_num.pod  | 213 --------------------------------------------
 doc/crypto/stack.pod        | 212 +++++++++++++++++++++++++++++++++++++++++++
 include/openssl/lhash.h     | 142 +++++++++++++----------------
 include/openssl/safestack.h |  84 +++++++----------
 include/openssl/stack.h     |  83 +++++++++++------
 include/openssl/txt_db.h    |   2 +-
 ssl/ssl_sess.c              |   6 +-
 util/libcrypto.num          |  80 ++++++++---------
 22 files changed, 623 insertions(+), 639 deletions(-)
 create mode 100644 crypto/lhash/lhash_lcl.h
 delete mode 100644 doc/crypto/sk_X509_num.pod
 create mode 100644 doc/crypto/stack.pod

diff --git a/CHANGES b/CHANGES
index 10ec93f..541efc3 100644
--- a/CHANGES
+++ b/CHANGES
@@ -4,6 +4,11 @@
 
  Changes between 1.0.2h and 1.1.0  [xx XXX 2016]
 
+  *) The stack and lhash API's were renamed to start with OPENSSL_SK_
+     and OPENSSL_LH_, respectively.  The old names are available
+     with API compatibility.  They new names are now completely documented.
+     [Rich Salz]
+
   *) Unify TYPE_up_ref(obj) methods signature.
      SSL_CTX_up_ref(), SSL_up_ref(), X509_up_ref(), EVP_PKEY_up_ref(),
      X509_CRL_up_ref(), X509_OBJECT_up_ref_count() methods are now returning an
diff --git a/apps/apps.c b/apps/apps.c
index 37f423b..5db4b22 100644
--- a/apps/apps.c
+++ b/apps/apps.c
@@ -1283,7 +1283,7 @@ static unsigned long index_serial_hash(const OPENSSL_CSTRING *a)
     n = a[DB_serial];
     while (*n == '0')
         n++;
-    return (lh_strhash(n));
+    return OPENSSL_LH_strhash(n);
 }
 
 static int index_serial_cmp(const OPENSSL_CSTRING *a,
@@ -1303,7 +1303,7 @@ static int index_name_qual(char **a)
 
 static unsigned long index_name_hash(const OPENSSL_CSTRING *a)
 {
-    return (lh_strhash(a[DB_name]));
+    return OPENSSL_LH_strhash(a[DB_name]);
 }
 
 int index_name_cmp(const OPENSSL_CSTRING *a, const OPENSSL_CSTRING *b)
diff --git a/apps/openssl.c b/apps/openssl.c
index e554010..f069277 100644
--- a/apps/openssl.c
+++ b/apps/openssl.c
@@ -525,7 +525,7 @@ static int function_cmp(const FUNCTION * a, const FUNCTION * b)
 
 static unsigned long function_hash(const FUNCTION * a)
 {
-    return lh_strhash(a-&gt;name);
+    return OPENSSL_LH_strhash(a-&gt;name);
 }
 
 static int SortFnByName(const void *_f1, const void *_f2)
diff --git a/crypto/asn1/tasn_dec.c b/crypto/asn1/tasn_dec.c
index cc49197..64bbe40 100644
--- a/crypto/asn1/tasn_dec.c
+++ b/crypto/asn1/tasn_dec.c
@@ -535,7 +535,7 @@ static int asn1_template_noexp_d2i(ASN1_VALUE **val,
         } else if (ret == -1)
             return -1;
         if (!*val)
-            *val = (ASN1_VALUE *)sk_new_null();
+            *val = (ASN1_VALUE *)OPENSSL_sk_new_null();
         else {
             /*
              * We've got a valid STACK: free up any items present
diff --git a/crypto/conf/conf_api.c b/crypto/conf/conf_api.c
index 0d4b23f..5535416 100644
--- a/crypto/conf/conf_api.c
+++ b/crypto/conf/conf_api.c
@@ -100,7 +100,7 @@ char *_CONF_get_string(const CONF *conf, const char *section,
 
 static unsigned long conf_value_hash(const CONF_VALUE *v)
 {
-    return (lh_strhash(v-&gt;section) &lt;&lt; 2) ^ lh_strhash(v-&gt;name);
+    return (OPENSSL_LH_strhash(v-&gt;section) &lt;&lt; 2) ^ OPENSSL_LH_strhash(v-&gt;name);
 }
 
 static int conf_value_cmp(const CONF_VALUE *a, const CONF_VALUE *b)
diff --git a/crypto/lhash/lh_stats.c b/crypto/lhash/lh_stats.c
index 0644c75..7337832 100644
--- a/crypto/lhash/lh_stats.c
+++ b/crypto/lhash/lh_stats.c
@@ -18,50 +18,48 @@
 
 #include &lt;openssl/bio.h&gt;
 #include &lt;openssl/lhash.h&gt;
+#include &quot;lhash_lcl.h&quot;
 
 # ifndef OPENSSL_NO_STDIO
-void lh_stats(const _LHASH *lh, FILE *fp)
+void OPENSSL_LH_stats(const OPENSSL_LHASH *lh, FILE *fp)
 {
     BIO *bp;
 
     bp = BIO_new(BIO_s_file());
     if (bp == NULL)
-        goto end;
+        return;
     BIO_set_fp(bp, fp, BIO_NOCLOSE);
-    lh_stats_bio(lh, bp);
+    OPENSSL_LH_stats_bio(lh, bp);
     BIO_free(bp);
- end:;
 }
 
-void lh_node_stats(const _LHASH *lh, FILE *fp)
+void OPENSSL_LH_node_stats(const OPENSSL_LHASH *lh, FILE *fp)
 {
     BIO *bp;
 
     bp = BIO_new(BIO_s_file());
     if (bp == NULL)
-        goto end;
+        return;
     BIO_set_fp(bp, fp, BIO_NOCLOSE);
-    lh_node_stats_bio(lh, bp);
+    OPENSSL_LH_node_stats_bio(lh, bp);
     BIO_free(bp);
- end:;
 }
 
-void lh_node_usage_stats(const _LHASH *lh, FILE *fp)
+void OPENSSL_LH_node_usage_stats(const OPENSSL_LHASH *lh, FILE *fp)
 {
     BIO *bp;
 
     bp = BIO_new(BIO_s_file());
     if (bp == NULL)
-        goto end;
+        return;
     BIO_set_fp(bp, fp, BIO_NOCLOSE);
-    lh_node_usage_stats_bio(lh, bp);
+    OPENSSL_LH_node_usage_stats_bio(lh, bp);
     BIO_free(bp);
- end:;
 }
 
 # endif
 
-void lh_stats_bio(const _LHASH *lh, BIO *out)
+void OPENSSL_LH_stats_bio(const OPENSSL_LHASH *lh, BIO *out)
 {
     BIO_printf(out, &quot;num_items             = %lu\n&quot;, lh-&gt;num_items);
     BIO_printf(out, &quot;num_nodes             = %u\n&quot;, lh-&gt;num_nodes);
@@ -82,9 +80,9 @@ void lh_stats_bio(const _LHASH *lh, BIO *out)
     BIO_printf(out, &quot;num_hash_comps        = %lu\n&quot;, lh-&gt;num_hash_comps);
 }
 
-void lh_node_stats_bio(const _LHASH *lh, BIO *out)
+void OPENSSL_LH_node_stats_bio(const OPENSSL_LHASH *lh, BIO *out)
 {
-    LHASH_NODE *n;
+    OPENSSL_LH_NODE *n;
     unsigned int i, num;
 
     for (i = 0; i &lt; lh-&gt;num_nodes; i++) {
@@ -94,9 +92,9 @@ void lh_node_stats_bio(const _LHASH *lh, BIO *out)
     }
 }
 
-void lh_node_usage_stats_bio(const _LHASH *lh, BIO *out)
+void OPENSSL_LH_node_usage_stats_bio(const OPENSSL_LHASH *lh, BIO *out)
 {
-    LHASH_NODE *n;
+    OPENSSL_LH_NODE *n;
     unsigned long num;
     unsigned int i;
     unsigned long total = 0, n_used = 0;
diff --git a/crypto/lhash/lhash.c b/crypto/lhash/lhash.c
index 9fa46b0..3e58eea 100644
--- a/crypto/lhash/lhash.c
+++ b/crypto/lhash/lhash.c
@@ -7,70 +7,33 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-/*-
- * Code for dynamic hash table routines
- * Author - Eric Young v 2.0
- *
- * 2.2 eay - added #include &quot;crypto.h&quot; so the memory leak checking code is
- *           present. eay 18-Jun-98
- *
- * 2.1 eay - Added an 'error in last operation' flag. eay 6-May-98
- *
- * 2.0 eay - Fixed a bug that occurred when using lh_delete
- *           from inside lh_doall().  As entries were deleted,
- *           the 'table' was 'contract()ed', making some entries
- *           jump from the end of the table to the start, there by
- *           skipping the lh_doall() processing. eay - 4/12/95
- *
- * 1.9 eay - Fixed a memory leak in lh_free, the LHASH_NODEs
- *           were not being free()ed. 21/11/95
- *
- * 1.8 eay - Put the stats routines into a separate file, lh_stats.c
- *           19/09/95
- *
- * 1.7 eay - Removed the fputs() for realloc failures - the code
- *           should silently tolerate them.  I have also fixed things
- *           lint complained about 04/05/95
- *
- * 1.6 eay - Fixed an invalid pointers in contract/expand 27/07/92
- *
- * 1.5 eay - Fixed a misuse of realloc in expand 02/03/1992
- *
- * 1.4 eay - Fixed lh_doall so the function can call lh_delete 28/05/91
- *
- * 1.3 eay - Fixed a few lint problems 19/3/1991
- *
- * 1.2 eay - Fixed lh_doall problem 13/3/1991
- *
- * 1.1 eay - Added lh_doall
- *
- * 1.0 eay - First version
- */
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;openssl/crypto.h&gt;
 #include &lt;openssl/lhash.h&gt;
+#include &quot;lhash_lcl.h&quot;
+
 
 #undef MIN_NODES
 #define MIN_NODES       16
 #define UP_LOAD         (2*LH_LOAD_MULT) /* load times 256 (default 2) */
 #define DOWN_LOAD       (LH_LOAD_MULT) /* load times 256 (default 1) */
 
-static void expand(_LHASH *lh);
-static void contract(_LHASH *lh);
-static LHASH_NODE **getrn(_LHASH *lh, const void *data, unsigned long *rhash);
+static void expand(OPENSSL_LHASH *lh);
+static void contract(OPENSSL_LHASH *lh);
+static OPENSSL_LH_NODE **getrn(OPENSSL_LHASH *lh, const void *data, unsigned long *rhash);
 
-_LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)
+OPENSSL_LHASH *OPENSSL_LH_new(OPENSSL_LH_HASHFUNC h, OPENSSL_LH_COMPFUNC c)
 {
-    _LHASH *ret;
+    OPENSSL_LHASH *ret;
 
     if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL)
         goto err0;
     if ((ret-&gt;b = OPENSSL_zalloc(sizeof(*ret-&gt;b) * MIN_NODES)) == NULL)
         goto err1;
-    ret-&gt;comp = ((c == NULL) ? (LHASH_COMP_FN_TYPE)strcmp : c);
-    ret-&gt;hash = ((h == NULL) ? (LHASH_HASH_FN_TYPE)lh_strhash : h);
+    ret-&gt;comp = ((c == NULL) ? (OPENSSL_LH_COMPFUNC)strcmp : c);
+    ret-&gt;hash = ((h == NULL) ? (OPENSSL_LH_HASHFUNC)OPENSSL_LH_strhash : h);
     ret-&gt;num_nodes = MIN_NODES / 2;
     ret-&gt;num_alloc_nodes = MIN_NODES;
     ret-&gt;pmax = MIN_NODES / 2;
@@ -84,10 +47,10 @@ _LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)
     return (NULL);
 }
 
-void lh_free(_LHASH *lh)
+void OPENSSL_LH_free(OPENSSL_LHASH *lh)
 {
     unsigned int i;
-    LHASH_NODE *n, *nn;
+    OPENSSL_LH_NODE *n, *nn;
 
     if (lh == NULL)
         return;
@@ -104,10 +67,10 @@ void lh_free(_LHASH *lh)
     OPENSSL_free(lh);
 }
 
-void *lh_insert(_LHASH *lh, void *data)
+void *OPENSSL_LH_insert(OPENSSL_LHASH *lh, void *data)
 {
     unsigned long hash;
-    LHASH_NODE *nn, **rn;
+    OPENSSL_LH_NODE *nn, **rn;
     void *ret;
 
     lh-&gt;error = 0;
@@ -137,10 +100,10 @@ void *lh_insert(_LHASH *lh, void *data)
     return (ret);
 }
 
-void *lh_delete(_LHASH *lh, const void *data)
+void *OPENSSL_LH_delete(OPENSSL_LHASH *lh, const void *data)
 {
     unsigned long hash;
-    LHASH_NODE *nn, **rn;
+    OPENSSL_LH_NODE *nn, **rn;
     void *ret;
 
     lh-&gt;error = 0;
@@ -165,10 +128,10 @@ void *lh_delete(_LHASH *lh, const void *data)
     return (ret);
 }
 
-void *lh_retrieve(_LHASH *lh, const void *data)
+void *OPENSSL_LH_retrieve(OPENSSL_LHASH *lh, const void *data)
 {
     unsigned long hash;
-    LHASH_NODE **rn;
+    OPENSSL_LH_NODE **rn;
     void *ret;
 
     lh-&gt;error = 0;
@@ -184,11 +147,12 @@ void *lh_retrieve(_LHASH *lh, const void *data)
     return (ret);
 }
 
-static void doall_util_fn(_LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,
-                          LHASH_DOALL_ARG_FN_TYPE func_arg, void *arg)
+static void doall_util_fn(OPENSSL_LHASH *lh, int use_arg,
+                          OPENSSL_LH_DOALL_FUNC func,
+                          OPENSSL_LH_DOALL_FUNCARG func_arg, void *arg)
 {
     int i;
-    LHASH_NODE *a, *n;
+    OPENSSL_LH_NODE *a, *n;
 
     if (lh == NULL)
         return;
@@ -200,13 +164,6 @@ static void doall_util_fn(_LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,
     for (i = lh-&gt;num_nodes - 1; i &gt;= 0; i--) {
         a = lh-&gt;b[i];
         while (a != NULL) {
-            /*
-             * 28/05/91 - eay - n added so items can be deleted via lh_doall
-             */
-            /*
-             * 22/05/08 - ben - eh? since a is not passed, this should not be
-             * needed
-             */
             n = a-&gt;next;
             if (use_arg)
                 func_arg(a-&gt;data, arg);
@@ -217,19 +174,19 @@ static void doall_util_fn(_LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,
     }
 }
 
-void lh_doall(_LHASH *lh, LHASH_DOALL_FN_TYPE func)
+void OPENSSL_LH_doall(OPENSSL_LHASH *lh, OPENSSL_LH_DOALL_FUNC func)
 {
-    doall_util_fn(lh, 0, func, (LHASH_DOALL_ARG_FN_TYPE)0, NULL);
+    doall_util_fn(lh, 0, func, (OPENSSL_LH_DOALL_FUNCARG)0, NULL);
 }
 
-void lh_doall_arg(_LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)
+void OPENSSL_LH_doall_arg(OPENSSL_LHASH *lh, OPENSSL_LH_DOALL_FUNCARG func, void *arg)
 {
-    doall_util_fn(lh, 1, (LHASH_DOALL_FN_TYPE)0, func, arg);
+    doall_util_fn(lh, 1, (OPENSSL_LH_DOALL_FUNC)0, func, arg);
 }
 
-static void expand(_LHASH *lh)
+static void expand(OPENSSL_LHASH *lh)
 {
-    LHASH_NODE **n, **n1, **n2, *np;
+    OPENSSL_LH_NODE **n, **n1, **n2, *np;
     unsigned int p, i, j;
     unsigned long hash, nni;
 
@@ -238,7 +195,7 @@ static void expand(_LHASH *lh)
     p = (int)lh-&gt;p++;
     n1 = &amp;(lh-&gt;b[p]);
     n2 = &amp;(lh-&gt;b[p + (int)lh-&gt;pmax]);
-    *n2 = NULL;                 /* 27/07/92 - eay - undefined pointer bug */
+    *n2 = NULL;
     nni = lh-&gt;num_alloc_nodes;
 
     for (np = *n1; np != NULL;) {
@@ -254,7 +211,7 @@ static void expand(_LHASH *lh)
 
     if ((lh-&gt;p) &gt;= lh-&gt;pmax) {
         j = (int)lh-&gt;num_alloc_nodes * 2;
-        n = OPENSSL_realloc(lh-&gt;b, (int)(sizeof(LHASH_NODE *) * j));
+        n = OPENSSL_realloc(lh-&gt;b, (int)(sizeof(OPENSSL_LH_NODE *) * j));
         if (n == NULL) {
             /* fputs(&quot;realloc error in lhash&quot;,stderr); */
             lh-&gt;error++;
@@ -271,15 +228,15 @@ static void expand(_LHASH *lh)
     }
 }
 
-static void contract(_LHASH *lh)
+static void contract(OPENSSL_LHASH *lh)
 {
-    LHASH_NODE **n, *n1, *np;
+    OPENSSL_LH_NODE **n, *n1, *np;
 
     np = lh-&gt;b[lh-&gt;p + lh-&gt;pmax - 1];
     lh-&gt;b[lh-&gt;p + lh-&gt;pmax - 1] = NULL; /* 24/07-92 - eay - weird but :-( */
     if (lh-&gt;p == 0) {
         n = OPENSSL_realloc(lh-&gt;b,
-                            (unsigned int)(sizeof(LHASH_NODE *) * lh-&gt;pmax));
+                            (unsigned int)(sizeof(OPENSSL_LH_NODE *) * lh-&gt;pmax));
         if (n == NULL) {
             /* fputs(&quot;realloc error in lhash&quot;,stderr); */
             lh-&gt;error++;
@@ -306,11 +263,12 @@ static void contract(_LHASH *lh)
     }
 }
 
-static LHASH_NODE **getrn(_LHASH *lh, const void *data, unsigned long *rhash)
+static OPENSSL_LH_NODE **getrn(OPENSSL_LHASH *lh,
+                               const void *data, unsigned long *rhash)
 {
-    LHASH_NODE **ret, *n1;
+    OPENSSL_LH_NODE **ret, *n1;
     unsigned long hash, nn;
-    LHASH_COMP_FN_TYPE cf;
+    OPENSSL_LH_COMPFUNC cf;
 
     hash = (*(lh-&gt;hash)) (data);
     lh-&gt;num_hash_calls++;
@@ -341,7 +299,7 @@ static LHASH_NODE **getrn(_LHASH *lh, const void *data, unsigned long *rhash)
  * collisions on /usr/dict/words and it distributes on %2^n quite well, not
  * as good as MD5, but still good.
  */
-unsigned long lh_strhash(const char *c)
+unsigned long OPENSSL_LH_strhash(const char *c)
 {
     unsigned long ret = 0;
     long n;
@@ -369,22 +327,22 @@ unsigned long lh_strhash(const char *c)
     return ((ret &gt;&gt; 16) ^ ret);
 }
 
-unsigned long lh_num_items(const _LHASH *lh)
+unsigned long OPENSSL_LH_num_items(const OPENSSL_LHASH *lh)
 {
     return lh ? lh-&gt;num_items : 0;
 }
 
-unsigned long lh_get_down_load(const _LHASH *lh)
+unsigned long OPENSSL_LH_get_down_load(const OPENSSL_LHASH *lh)
 {
     return lh-&gt;down_load;
 }
 
-void lh_set_down_load(_LHASH *lh, unsigned long down_load)
+void OPENSSL_LH_set_down_load(OPENSSL_LHASH *lh, unsigned long down_load)
 {
     lh-&gt;down_load = down_load;
 }
 
-int lh_error(_LHASH *lh)
+int OPENSSL_LH_error(OPENSSL_LHASH *lh)
 {
     return lh-&gt;error;
 }
diff --git a/crypto/lhash/lhash_lcl.h b/crypto/lhash/lhash_lcl.h
new file mode 100644
index 0000000..cfb0e1a
--- /dev/null
+++ b/crypto/lhash/lhash_lcl.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+
+struct lhash_node_st {
+    void *data;
+    struct lhash_node_st *next;
+    unsigned long hash;
+};
+
+struct lhash_st {
+    LHASH_NODE **b;
+    OPENSSL_LH_COMPFUNC comp;
+    OPENSSL_LH_HASHFUNC hash;
+    unsigned int num_nodes;
+    unsigned int num_alloc_nodes;
+    unsigned int p;
+    unsigned int pmax;
+    unsigned long up_load;      /* load times 256 */
+    unsigned long down_load;    /* load times 256 */
+    unsigned long num_items;
+    unsigned long num_expands;
+    unsigned long num_expand_reallocs;
+    unsigned long num_contracts;
+    unsigned long num_contract_reallocs;
+    unsigned long num_hash_calls;
+    unsigned long num_comp_calls;
+    unsigned long num_insert;
+    unsigned long num_replace;
+    unsigned long num_delete;
+    unsigned long num_no_delete;
+    unsigned long num_retrieve;
+    unsigned long num_retrieve_miss;
+    unsigned long num_hash_comps;
+    int error;
+};
diff --git a/crypto/objects/o_names.c b/crypto/objects/o_names.c
index 321a342..e43fb30 100644
--- a/crypto/objects/o_names.c
+++ b/crypto/objects/o_names.c
@@ -99,7 +99,7 @@ int OBJ_NAME_new_index(unsigned long (*hash_func) (const char *),
             OBJerr(OBJ_F_OBJ_NAME_NEW_INDEX, ERR_R_MALLOC_FAILURE);
             return (0);
         }
-        name_funcs-&gt;hash_func = lh_strhash;
+        name_funcs-&gt;hash_func = OPENSSL_LH_strhash;
         name_funcs-&gt;cmp_func = obj_strcmp;
         CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_DISABLE);
         sk_NAME_FUNCS_push(name_funcs_stack, name_funcs);
@@ -141,7 +141,7 @@ static unsigned long obj_name_hash(const OBJ_NAME *a)
             sk_NAME_FUNCS_value(name_funcs_stack,
                                 a-&gt;type)-&gt;hash_func(a-&gt;name);
     } else {
-        ret = lh_strhash(a-&gt;name);
+        ret = OPENSSL_LH_strhash(a-&gt;name);
     }
     ret ^= a-&gt;type;
     return (ret);
diff --git a/crypto/objects/obj_dat.c b/crypto/objects/obj_dat.c
index 3b836fe..46f98cb 100644
--- a/crypto/objects/obj_dat.c
+++ b/crypto/objects/obj_dat.c
@@ -68,10 +68,10 @@ static unsigned long added_obj_hash(const ADDED_OBJ *ca)
             ret ^= p[i] &lt;&lt; ((i * 3) % 24);
         break;
     case ADDED_SNAME:
-        ret = lh_strhash(a-&gt;sn);
+        ret = OPENSSL_LH_strhash(a-&gt;sn);
         break;
     case ADDED_LNAME:
-        ret = lh_strhash(a-&gt;ln);
+        ret = OPENSSL_LH_strhash(a-&gt;ln);
         break;
     case ADDED_NID:
         ret = a-&gt;nid;
diff --git a/crypto/stack/stack.c b/crypto/stack/stack.c
index c23f305..36fc921 100644
--- a/crypto/stack/stack.c
+++ b/crypto/stack/stack.c
@@ -17,7 +17,7 @@ struct stack_st {
     char **data;
     int sorted;
     int num_alloc;
-    int (*comp) (const void *, const void *);
+    OPENSSL_sk_compfunc comp;
 };
 
 #undef MIN_NODES
@@ -25,9 +25,9 @@ struct stack_st {
 
 #include &lt;errno.h&gt;
 
-int (*sk_set_cmp_func(_STACK *sk, int (*c) (const void *, const void *)))
- (const void *, const void *) {
-    int (*old) (const void *, const void *) = sk-&gt;comp;
+OPENSSL_sk_compfunc OPENSSL_sk_set_cmp_func(OPENSSL_STACK *sk, OPENSSL_sk_compfunc c)
+{
+    OPENSSL_sk_compfunc old = sk-&gt;comp;
 
     if (sk-&gt;comp != c)
         sk-&gt;sorted = 0;
@@ -36,12 +36,12 @@ int (*sk_set_cmp_func(_STACK *sk, int (*c) (const void *, const void *)))
     return old;
 }
 
-_STACK *sk_dup(_STACK *sk)
+OPENSSL_STACK *OPENSSL_sk_dup(OPENSSL_STACK *sk)
 {
-    _STACK *ret;
+    OPENSSL_STACK *ret;
     char **s;
 
-    if ((ret = sk_new(sk-&gt;comp)) == NULL)
+    if ((ret = OPENSSL_sk_new(sk-&gt;comp)) == NULL)
         goto err;
     s = OPENSSL_realloc((char *)ret-&gt;data,
                         (unsigned int)sizeof(char *) * sk-&gt;num_alloc);
@@ -56,17 +56,17 @@ _STACK *sk_dup(_STACK *sk)
     ret-&gt;comp = sk-&gt;comp;
     return (ret);
  err:
-    sk_free(ret);
+    OPENSSL_sk_free(ret);
     return (NULL);
 }
 
-_STACK *sk_deep_copy(_STACK *sk, void *(*copy_func) (void *),
-                     void (*free_func) (void *))
+OPENSSL_STACK *OPENSSL_sk_deep_copy(OPENSSL_STACK *sk, OPENSSL_sk_copyfunc copy_func,
+                             OPENSSL_sk_freefunc free_func)
 {
-    _STACK *ret;
+    OPENSSL_STACK *ret;
     int i;
 
-    if ((ret = OPENSSL_malloc(sizeof(_STACK))) == NULL)
+    if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL)
         return ret;
     ret-&gt;comp = sk-&gt;comp;
     ret-&gt;sorted = sk-&gt;sorted;
@@ -87,23 +87,23 @@ _STACK *sk_deep_copy(_STACK *sk, void *(*copy_func) (void *),
             while (--i &gt;= 0)
                 if (ret-&gt;data[i] != NULL)
                     free_func(ret-&gt;data[i]);
-            sk_free(ret);
+            OPENSSL_sk_free(ret);
             return NULL;
         }
     }
     return ret;
 }
 
-_STACK *sk_new_null(void)
+OPENSSL_STACK *OPENSSL_sk_new_null(void)
 {
-    return sk_new((int (*)(const void *, const void *))0);
+    return OPENSSL_sk_new((OPENSSL_sk_compfunc)NULL);
 }
 
-_STACK *sk_new(int (*c) (const void *, const void *))
+OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_compfunc c)
 {
-    _STACK *ret;
+    OPENSSL_STACK *ret;
 
-    if ((ret = OPENSSL_zalloc(sizeof(_STACK))) == NULL)
+    if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL)
         goto err;
     if ((ret-&gt;data = OPENSSL_zalloc(sizeof(*ret-&gt;data) * MIN_NODES)) == NULL)
         goto err;
@@ -116,7 +116,7 @@ _STACK *sk_new(int (*c) (const void *, const void *))
     return (NULL);
 }
 
-int sk_insert(_STACK *st, void *data, int loc)
+int OPENSSL_sk_insert(OPENSSL_STACK *st, void *data, int loc)
 {
     char **s;
 
@@ -142,22 +142,22 @@ int sk_insert(_STACK *st, void *data, int loc)
     return (st-&gt;num);
 }
 
-void *sk_delete_ptr(_STACK *st, void *p)
+void *OPENSSL_sk_delete_ptr(OPENSSL_STACK *st, void *p)
 {
     int i;
 
     for (i = 0; i &lt; st-&gt;num; i++)
         if (st-&gt;data[i] == p)
-            return (sk_delete(st, i));
+            return (OPENSSL_sk_delete(st, i));
     return (NULL);
 }
 
-void *sk_delete(_STACK *st, int loc)
+void *OPENSSL_sk_delete(OPENSSL_STACK *st, int loc)
 {
     char *ret;
     int i, j;
 
-    if (!st || (loc &lt; 0) || (loc &gt;= st-&gt;num))
+    if (st == NULL || loc &lt; 0 || loc &gt;= st-&gt;num)
         return NULL;
 
     ret = st-&gt;data[loc];
@@ -174,7 +174,7 @@ void *sk_delete(_STACK *st, int loc)
     return (ret);
 }
 
-static int internal_find(_STACK *st, void *data, int ret_val_options)
+static int internal_find(OPENSSL_STACK *st, void *data, int ret_val_options)
 {
     const void *const *r;
     int i;
@@ -188,7 +188,7 @@ static int internal_find(_STACK *st, void *data, int ret_val_options)
                 return (i);
         return (-1);
     }
-    sk_sort(st);
+    OPENSSL_sk_sort(st);
     if (data == NULL)
         return (-1);
     r = OBJ_bsearch_ex_(&amp;data, st-&gt;data, st-&gt;num, sizeof(void *), st-&gt;comp,
@@ -198,45 +198,45 @@ static int internal_find(_STACK *st, void *data, int ret_val_options)
     return (int)((char **)r - st-&gt;data);
 }
 
-int sk_find(_STACK *st, void *data)
+int OPENSSL_sk_find(OPENSSL_STACK *st, void *data)
 {
     return internal_find(st, data, OBJ_BSEARCH_FIRST_VALUE_ON_MATCH);
 }
 
-int sk_find_ex(_STACK *st, void *data)
+int OPENSSL_sk_find_ex(OPENSSL_STACK *st, void *data)
 {
     return internal_find(st, data, OBJ_BSEARCH_VALUE_ON_NOMATCH);
 }
 
-int sk_push(_STACK *st, void *data)
+int OPENSSL_sk_push(OPENSSL_STACK *st, void *data)
 {
-    return (sk_insert(st, data, st-&gt;num));
+    return (OPENSSL_sk_insert(st, data, st-&gt;num));
 }
 
-int sk_unshift(_STACK *st, void *data)
+int OPENSSL_sk_unshift(OPENSSL_STACK *st, void *data)
 {
-    return (sk_insert(st, data, 0));
+    return (OPENSSL_sk_insert(st, data, 0));
 }
 
-void *sk_shift(_STACK *st)
+void *OPENSSL_sk_shift(OPENSSL_STACK *st)
 {
     if (st == NULL)
         return (NULL);
     if (st-&gt;num &lt;= 0)
         return (NULL);
-    return (sk_delete(st, 0));
+    return (OPENSSL_sk_delete(st, 0));
 }
 
-void *sk_pop(_STACK *st)
+void *OPENSSL_sk_pop(OPENSSL_STACK *st)
 {
     if (st == NULL)
         return (NULL);
     if (st-&gt;num &lt;= 0)
         return (NULL);
-    return (sk_delete(st, st-&gt;num - 1));
+    return (OPENSSL_sk_delete(st, st-&gt;num - 1));
 }
 
-void sk_zero(_STACK *st)
+void OPENSSL_sk_zero(OPENSSL_STACK *st)
 {
     if (st == NULL)
         return;
@@ -246,7 +246,7 @@ void sk_zero(_STACK *st)
     st-&gt;num = 0;
 }
 
-void sk_pop_free(_STACK *st, void (*func) (void *))
+void OPENSSL_sk_pop_free(OPENSSL_STACK *st, OPENSSL_sk_freefunc func)
 {
     int i;
 
@@ -255,10 +255,10 @@ void sk_pop_free(_STACK *st, void (*func) (void *))
     for (i = 0; i &lt; st-&gt;num; i++)
         if (st-&gt;data[i] != NULL)
             func(st-&gt;data[i]);
-    sk_free(st);
+    OPENSSL_sk_free(st);
 }
 
-void sk_free(_STACK *st)
+void OPENSSL_sk_free(OPENSSL_STACK *st)
 {
     if (st == NULL)
         return;
@@ -266,48 +266,38 @@ void sk_free(_STACK *st)
     OPENSSL_free(st);
 }
 
-int sk_num(const _STACK *st)
+int OPENSSL_sk_num(const OPENSSL_STACK *st)
 {
     if (st == NULL)
         return -1;
     return st-&gt;num;
 }
 
-void *sk_value(const _STACK *st, int i)
+void *OPENSSL_sk_value(const OPENSSL_STACK *st, int i)
 {
-    if (!st || (i &lt; 0) || (i &gt;= st-&gt;num))
+    if (st == NULL || i &lt; 0 || i &gt;= st-&gt;num)
         return NULL;
     return st-&gt;data[i];
 }
 
-void *sk_set(_STACK *st, int i, void *value)
+void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, void *value)
 {
-    if (!st || (i &lt; 0) || (i &gt;= st-&gt;num))
+    if (st == NULL || i &lt; 0 || i &gt;= st-&gt;num)
         return NULL;
     return (st-&gt;data[i] = value);
 }
 
-void sk_sort(_STACK *st)
+void OPENSSL_sk_sort(OPENSSL_STACK *st)
 {
     if (st &amp;&amp; !st-&gt;sorted &amp;&amp; st-&gt;comp != NULL) {
-        int (*comp_func) (const void *, const void *);
-
-        /*
-         * same comment as in sk_find ... previously st-&gt;comp was declared as
-         * a (void*,void*) callback type, but this made the population of the
-         * callback pointer illogical - our callbacks compare type** with
-         * type**, so we leave the casting until absolutely necessary (ie.
-         * &quot;now&quot;).
-         */
-        comp_func = (int (*)(const void *, const void *))(st-&gt;comp);
-        qsort(st-&gt;data, st-&gt;num, sizeof(char *), comp_func);
+        qsort(st-&gt;data, st-&gt;num, sizeof(char *), st-&gt;comp);
         st-&gt;sorted = 1;
     }
 }
 
-int sk_is_sorted(const _STACK *st)
+int OPENSSL_sk_is_sorted(const OPENSSL_STACK *st)
 {
-    if (!st)
+    if (st == NULL)
         return 1;
     return st-&gt;sorted;
 }
diff --git a/crypto/txt_db/txt_db.c b/crypto/txt_db/txt_db.c
index 6bc0262..1432230 100644
--- a/crypto/txt_db/txt_db.c
+++ b/crypto/txt_db/txt_db.c
@@ -145,7 +145,7 @@ OPENSSL_STRING *TXT_DB_get_by_index(TXT_DB *db, int idx,
 }
 
 int TXT_DB_create_index(TXT_DB *db, int field, int (*qual) (OPENSSL_STRING *),
-                        LHASH_HASH_FN_TYPE hash, LHASH_COMP_FN_TYPE cmp)
+                        OPENSSL_LH_HASHFUNC hash, OPENSSL_LH_COMPFUNC cmp)
 {
     LHASH_OF(OPENSSL_STRING) *idx;
     OPENSSL_STRING *r;
@@ -156,7 +156,7 @@ int TXT_DB_create_index(TXT_DB *db, int field, int (*qual) (OPENSSL_STRING *),
         return (0);
     }
     /* FIXME: we lose type checking at this point */
-    if ((idx = (LHASH_OF(OPENSSL_STRING) *)lh_new(hash, cmp)) == NULL) {
+    if ((idx = (LHASH_OF(OPENSSL_STRING) *)OPENSSL_LH_new(hash, cmp)) == NULL) {
         db-&gt;error = DB_ERROR_MALLOC;
         return (0);
     }
diff --git a/doc/crypto/lh_stats.pod b/doc/crypto/lh_stats.pod
index 12b4a16..bdc19b4 100644
--- a/doc/crypto/lh_stats.pod
+++ b/doc/crypto/lh_stats.pod
@@ -2,20 +2,21 @@
 
 =head1 NAME
 
-lh_stats, lh_node_stats, lh_node_usage_stats, lh_stats_bio,
-lh_node_stats_bio, lh_node_usage_stats_bio - LHASH statistics
+OPENSSL_LH_stats, OPENSSL_LH_node_stats, OPENSSL_LH_node_usage_stats,
+OPENSSL_LH_stats_bio,
+OPENSSL_LH_node_stats_bio, OPENSSL_LH_node_usage_stats_bio - LHASH statistics
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/lhash.h&gt;
 
- void lh_stats(LHASH *table, FILE *out);
- void lh_node_stats(LHASH *table, FILE *out);
- void lh_node_usage_stats(LHASH *table, FILE *out);
+ void OPENSSL_LH_stats(LHASH *table, FILE *out);
+ void OPENSSL_LH_node_stats(LHASH *table, FILE *out);
+ void OPENSSL_LH_node_usage_stats(LHASH *table, FILE *out);
 
- void lh_stats_bio(LHASH *table, BIO *out);
- void lh_node_stats_bio(LHASH *table, BIO *out);
- void lh_node_usage_stats_bio(LHASH *table, BIO *out);
+ void OPENSSL_LH_stats_bio(LHASH *table, BIO *out);
+ void OPENSSL_LH_node_stats_bio(LHASH *table, BIO *out);
+ void OPENSSL_LH_node_usage_stats_bio(LHASH *table, BIO *out);
 
 =head1 DESCRIPTION
 
@@ -24,14 +25,14 @@ accessing the hash table.  This is mostly a legacy of Eric Young
 writing this library for the reasons of implementing what looked like
 a nice algorithm rather than for a particular software product.
 
-lh_stats() prints out statistics on the size of the hash table, how
+OPENSSL_LH_stats() prints out statistics on the size of the hash table, how
 many entries are in it, and the number and result of calls to the
 routines in this library.
 
-lh_node_stats() prints the number of entries for each 'bucket' in the
+OPENSSL_LH_node_stats() prints the number of entries for each 'bucket' in the
 hash table.
 
-lh_node_usage_stats() prints out a short summary of the state of the
+OPENSSL_LH_node_usage_stats() prints out a short summary of the state of the
 hash table.  It prints the 'load' and the 'actual load'.  The load is
 the average number of data items per 'bucket' in the hash table.  The
 'actual load' is the average number of items per 'bucket', but only
@@ -40,7 +41,7 @@ average number of searches that will need to find an item in the hash
 table, while the 'load' is the average number that will be done to
 record a miss.
 
-lh_stats_bio(), lh_node_stats_bio() and lh_node_usage_stats_bio()
+OPENSSL_LH_stats_bio(), OPENSSL_LH_node_stats_bio() and OPENSSL_LH_node_usage_stats_bio()
 are the same as the above, except that the output goes to a B&lt;BIO&gt;.
 
 =head1 RETURN VALUES
diff --git a/doc/crypto/lhash.pod b/doc/crypto/lhash.pod
index acc0821..9e29617 100644
--- a/doc/crypto/lhash.pod
+++ b/doc/crypto/lhash.pod
@@ -2,39 +2,45 @@
 
 =head1 NAME
 
-lh_new, lh_free, lh_insert, lh_delete, lh_retrieve, lh_doall, lh_doall_arg, lh_error - dynamic hash table
+DECLARE_LHASH_OF,
+OPENSSL_LH_COMPFUNC, OPENSSL_LH_HASHFUNC, OPENSSL_LH_DOALL_FUNC,
+LHASH_DOALL_ARG_FN_TYPE,
+lh_TYPE_new, lh_TYPE_free,
+lh_TYPE_insert, lh_TYPE_delete, lh_TYPE_retrieve,
+lh_TYPE_doall, lh_TYPE_doall_arg, lh_TYPE_error - dynamic hash table
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/lhash.h&gt;
 
- DECLARE_LHASH_OF(&lt;type&gt;);
+ DECLARE_LHASH_OF(TYPE);
 
- LHASH *lh_&lt;type&gt;_new();
- void lh_&lt;type&gt;_free(LHASH_OF(&lt;type&gt; *table);
+ LHASH *lh_TYPE_new();
+ void lh_TYPE_free(LHASH_OF(TYPE *table);
 
- &lt;type&gt; *lh_&lt;type&gt;_insert(LHASH_OF(&lt;type&gt; *table, &lt;type&gt; *data);
- &lt;type&gt; *lh_&lt;type&gt;_delete(LHASH_OF(&lt;type&gt; *table, &lt;type&gt; *data);
- &lt;type&gt; *lh_retrieve(LHASH_OF&lt;type&gt; *table, &lt;type&gt; *data);
+ TYPE *lh_TYPE_insert(LHASH_OF(TYPE *table, TYPE *data);
+ TYPE *lh_TYPE_delete(LHASH_OF(TYPE *table, TYPE *data);
+ TYPE *lh_retrieve(LHASH_OFTYPE *table, TYPE *data);
 
- void lh_&lt;type&gt;_doall(LHASH_OF(&lt;type&gt; *table, LHASH_DOALL_FN_TYPE func);
- void lh_&lt;type&gt;_doall_arg(LHASH_OF(&lt;type&gt; *table, LHASH_DOALL_ARG_FN_TYPE func,
-          &lt;type2&gt;, &lt;type2&gt; *arg);
+ void lh_TYPE_doall(LHASH_OF(TYPE *table, OPENSSL_LH_DOALL_FUNC func);
+ void lh_TYPE_doall_arg(LHASH_OF(TYPE) *table, OPENSSL_LH_DOALL_FUNCARG func,
+          TYPE, TYPE *arg);
 
- int lh_&lt;type&gt;_error(LHASH_OF(&lt;type&gt; *table);
+ int lh_TYPE_error(LHASH_OF(TYPE) *table);
 
- typedef int (*LHASH_COMP_FN_TYPE)(const void *, const void *);
- typedef unsigned long (*LHASH_HASH_FN_TYPE)(const void *);
- typedef void (*LHASH_DOALL_FN_TYPE)(const void *);
+ typedef int (*OPENSSL_LH_COMPFUNC)(const void *, const void *);
+ typedef unsigned long (*OPENSSL_LH_HASHFUNC)(const void *);
+ typedef void (*OPENSSL_LH_DOALL_FUNC)(const void *);
  typedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const void *);
 
 =head1 DESCRIPTION
 
 This library implements type-checked dynamic hash tables. The hash
 table entries can be arbitrary structures. Usually they consist of key
-and value fields.
+and value fields.  In the description here, I&lt;TYPE&gt; is used a placeholder
+for any of the OpenSSL datatypes, such as I&lt;SSL_SESSION&gt;.
 
-lh_&lt;type&gt;_new() creates a new B&lt;LHASH_OF(&lt;type&gt;&gt; structure to store
+lh_TYPE_new() creates a new B&lt;LHASH_OF(TYPE)&gt; structure to store
 arbitrary data entries, and provides the 'hash' and 'compare'
 callbacks to be used in organising the table's entries.  The B&lt;hash&gt;
 callback takes a pointer to a table entry as its argument and returns
@@ -47,7 +53,7 @@ will contain items of some particular type and the B&lt;hash&gt; and
 B&lt;compare&gt; callbacks hash/compare these types, then the
 B&lt;DECLARE_LHASH_HASH_FN&gt; and B&lt;IMPLEMENT_LHASH_COMP_FN&gt; macros can be
 used to create callback wrappers of the prototypes required by
-lh_&lt;type&gt;_new().  These provide per-variable casts before calling the
+lh_TYPE_new().  These provide per-variable casts before calling the
 type-specific callbacks written by the application author.  These
 macros, as well as those used for the &quot;doall&quot; callbacks, are defined
 as;
@@ -104,25 +110,25 @@ as;
          /* ... */
  }
 
-lh_&lt;type&gt;_free() frees the B&lt;LHASH_OF(&lt;type&gt;&gt; structure
+lh_TYPE_free() frees the B&lt;LHASH_OF(TYPE)&gt; structure
 B&lt;table&gt;. Allocated hash table entries will not be freed; consider
-using lh_&lt;type&gt;_doall() to deallocate any remaining entries in the
+using lh_TYPE_doall() to deallocate any remaining entries in the
 hash table (see below).
 
-lh_&lt;type&gt;_insert() inserts the structure pointed to by B&lt;data&gt; into
+lh_TYPE_insert() inserts the structure pointed to by B&lt;data&gt; into
 B&lt;table&gt;.  If there already is an entry with the same key, the old
-value is replaced. Note that lh_&lt;type&gt;_insert() stores pointers, the
+value is replaced. Note that lh_TYPE_insert() stores pointers, the
 data are not copied.
 
-lh_&lt;type&gt;_delete() deletes an entry from B&lt;table&gt;.
+lh_TYPE_delete() deletes an entry from B&lt;table&gt;.
 
-lh_&lt;type&gt;_retrieve() looks up an entry in B&lt;table&gt;. Normally, B&lt;data&gt;
+lh_TYPE_retrieve() looks up an entry in B&lt;table&gt;. Normally, B&lt;data&gt;
 is a structure with the key field(s) set; the function will return a
 pointer to a fully populated structure.
 
-lh_&lt;type&gt;_doall() will, for every entry in the hash table, call
-B&lt;func&gt; with the data item as its parameter.  For lh_&lt;type&gt;_doall()
-and lh_&lt;type&gt;_doall_arg(), function pointer casting should be avoided
+lh_TYPE_doall() will, for every entry in the hash table, call
+B&lt;func&gt; with the data item as its parameter.  For lh_TYPE_doall()
+and lh_TYPE_doall_arg(), function pointer casting should be avoided
 in the callbacks (see B&lt;NOTE&gt;) - instead use the declare/implement
 macros to create type-checked wrappers that cast variables prior to
 calling your type-specific callbacks.  An example of this is
@@ -149,7 +155,7 @@ you start (which will stop the hash table ever decreasing in size).
 The best solution is probably to avoid deleting items from the hash
 table inside a &quot;doall&quot; callback!
 
-lh_&lt;type&gt;_doall_arg() is the same as lh_&lt;type&gt;_doall() except that
+lh_TYPE_doall_arg() is the same as lh_TYPE_doall() except that
 B&lt;func&gt; will be called with B&lt;arg&gt; as the second argument and B&lt;func&gt;
 should be of type B&lt;LHASH_DOALL_ARG_FN_TYPE&gt; (a callback prototype
 that is passed both the table entry and an extra argument).  As with
@@ -169,27 +175,28 @@ that is provided by the caller):
  lh_STUFF_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), BIO,
                     logging_bio);
 
-lh_&lt;type&gt;_error() can be used to determine if an error occurred in the last
-operation. lh_&lt;type&gt;_error() is a macro.
+
+lh_TYPE_error() can be used to determine if an error occurred in the last
+operation.
 
 =head1 RETURN VALUES
 
-lh_&lt;type&gt;_new() returns B&lt;NULL&gt; on error, otherwise a pointer to the new
+lh_TYPE_new() returns B&lt;NULL&gt; on error, otherwise a pointer to the new
 B&lt;LHASH&gt; structure.
 
-When a hash table entry is replaced, lh_&lt;type&gt;_insert() returns the value
+When a hash table entry is replaced, lh_TYPE_insert() returns the value
 being replaced. B&lt;NULL&gt; is returned on normal operation and on error.
 
-lh_&lt;type&gt;_delete() returns the entry being deleted.  B&lt;NULL&gt; is returned if
+lh_TYPE_delete() returns the entry being deleted.  B&lt;NULL&gt; is returned if
 there is no such value in the hash table.
 
-lh_&lt;type&gt;_retrieve() returns the hash table entry if it has been found,
+lh_TYPE_retrieve() returns the hash table entry if it has been found,
 B&lt;NULL&gt; otherwise.
 
-lh_&lt;type&gt;_error() returns 1 if an error occurred in the last operation, 0
+lh_TYPE_error() returns 1 if an error occurred in the last operation, 0
 otherwise.
 
-lh_&lt;type&gt;_free(), lh_&lt;type&gt;_doall() and lh_&lt;type&gt;_doall_arg() return no values.
+lh_TYPE_free(), lh_TYPE_doall() and lh_TYPE_doall_arg() return no values.
 
 =head1 NOTE
 
@@ -232,17 +239,12 @@ without any &quot;const&quot; qualifiers.
 
 =head1 BUGS
 
-lh_&lt;type&gt;_insert() returns B&lt;NULL&gt; both for success and error.
+lh_TYPE_insert() returns B&lt;NULL&gt; both for success and error.
 
 =head1 SEE ALSO
 
 L&lt;lh_stats(3)&gt;
 
-=head1 HISTORY
-
-In OpenSSL 1.0.0, the lhash interface was revamped for better
-type checking.
-
 =cut
 
 =head1 COPYRIGHT
diff --git a/doc/crypto/sk_X509_num.pod b/doc/crypto/sk_X509_num.pod
deleted file mode 100644
index 1f16e81..0000000
--- a/doc/crypto/sk_X509_num.pod
+++ /dev/null
@@ -1,213 +0,0 @@
-=pod
-
-=head1 NAME
-
-sk_X509_num, sk_X509_value, sk_X509_new, sk_X509_new_null, sk_X509_free,
-sk_X509_zero, sk_X509_delete, sk_X509_delete_ptr, sk_X509_push,
-sk_X509_unshift, sk_X509_pop, sk_X509_shift, sk_X509_pop_free, sk_X509_insert,
-sk_X509_set, sk_X509_find, sk_X509_find_ex, sk_X509_sort, sk_X509_is_sorted,
-sk_X509_dup, sk_X509_deep_copy, sk_X509_set_cmp_func - X509 stack
-
-=head1 SYNOPSIS
-
- #include &lt;openssl/x509.h&gt;
-
- int sk_X509_num(const STACK_OF(X509) *sk);
- X509 *sk_X509_value(const STACK_OF(X509) *sk, int idx);
- STACK_OF(X509) *sk_X509_new(int (*cmpf)(const X509 * const *a,
-                                         const X509 * const *b));
- STACK_OF(X509) *sk_X509_new_null(void);
- int (*sk_X509_set_cmp_func (STACK_OF(X509) *sk,
-                             int (*cmpf) (const X509 * const *a,
-                                          const X509 * const *b)))
-                             (const X509 * const *, const X509 * const *);
- void sk_X509_free(const STACK_OF(X509) *sk);
- void sk_X509_zero(const STACK_OF(X509) *sk);
- void sk_X509_pop_free(STACK_OF(X509) *sk, void (*func) (X509 *a));
- X509 *sk_X509_delete(STACK_OF(X509) *sk, int i);
- X509 *sk_X509_delete_ptr(STACK_OF(X509) *sk, X509 *ptr);
- int sk_X509_insert(STACK_OF(X509) *sk, X509 *ptr, int idx);
- int sk_X509_push(STACK_OF(X509) *sk, X509 *ptr);
- int sk_X509_unshift(STACK_OF(X509) *sk, X509 *ptr);
- X509 *sk_X509_pop(STACK_OF(X509) *sk);
- X509 *sk_X509_shift(STACK_OF(X509) *sk);
- X509 *sk_X509_set(STACK_OF(X509) *sk, int idx, X509 *ptr);
- int sk_X509_find(STACK_OF(X509) *sk, X509 *ptr);
- int sk_X509_find_ex(STACK_OF(X509) *sk, X509 *ptr);
- void sk_X509_sort(const STACK_OF(X509) *sk);
- int sk_X509_is_sorted(const STACK_OF(X509) *sk);
- STACK_OF(X509) *sk_X509_dup(STACK_OF(X509) *sk);
- STACK_OF(X509) *sk_X509_deep_copy(STACK_OF(X509) *sk,
-                                   X509 * (*copyfn) (const X509 *),
-                                   void (*freefn) (X509 *));
-
-=head1 DESCRIPTION
-
-sk_X509_num() returns the number of elements in B&lt;sk&gt; or -1 if B&lt;sk&gt; is
-B&lt;NULL&gt;.
-
-sk_X509_value() returns element B&lt;idx&gt; in B&lt;sk&gt;. Where B&lt;idx&gt; runs from 0
-to sk_X509_num(sk) - 1 inclusive. If B&lt;idx&gt; is out of range then B&lt;NULL&gt;
-is returned.
-
-sk_X509_new() allocates a new empty stack using comparison function B&lt;cmpf&gt;.
-If B&lt;cmpf&gt; is B&lt;0&gt; then no comparison function is used.
-
-sk_X509_new_null() allocates a new empty stack with no comparison function.
-
-sk_X509_set_cmp_func() sets the comparison function of B&lt;sk&gt; to B&lt;cmpf&gt;.
-The previous comparison function is returned or B&lt;0&gt; if there was
-no previous comparison function.
-
-sk_X509_free() frees up the B&lt;sk&gt; structure. It does B&lt;not&gt; free up any
-elements of B&lt;sk&gt;. After this call B&lt;sk&gt; is no longer valid.
-
-sk_X509_zero() sets the number of elements in B&lt;sk&gt; to zero. It does not free
-B&lt;sk&gt; so after this call B&lt;sk&gt; is still valid.
-
-sk_X509_pop_free() frees up all elements of B&lt;sk&gt; and B&lt;sk&gt; itself. The
-free function func() is called on each element to free it.
-
-sk_X509_delete() deletes element B&lt;i&gt; from B&lt;sk&gt;. It returns the deleted
-element or B&lt;NULL&gt; if B&lt;i&gt; is out of range.
-
-sk_X509_delete_ptr() deletes element matching B&lt;ptr&gt; from B&lt;sk&gt;. It returns
-the deleted element or B&lt;NULL&gt; if no element matching B&lt;ptr&gt; was found.
-
-sk_X509_insert() inserts B&lt;ptr&gt; into B&lt;sk&gt; at position B&lt;idx&gt;. Any existing
-elements at or after B&lt;idx&gt; are moved downwards. If B&lt;idx&gt; is out of range
-the new element is appended to B&lt;sk&gt;. sk_X509_insert() either returns the
-number of elements in B&lt;sk&gt; after the new element is inserted or zero if
-an error occurred: which will happen if there is a memory allocation failure.
-
-sk_X509_push() appends B&lt;ptr&gt; to B&lt;sk&gt; it is equivalent to:
-
- sk_X509_insert(sk, ptr, -1);
-
-sk_X509_unshift() inserts B&lt;ptr&gt; at the start of B&lt;sk&gt; it is equivalent to:
-
- sk_X509_insert(sk, ptr, 0);
-
-sk_X509_pop() returns and removes the last element from B&lt;sk&gt;.
-
-sk_X509_shift() returns and removes the first element from B&lt;sk&gt;.
-
-sk_X509_set() sets element B&lt;idx&gt; of B&lt;sk&gt; to B&lt;ptr&gt; replacing the current
-element. The new element value is returned or B&lt;NULL&gt; if an error occurred:
-this will only happen if B&lt;sk&gt; is B&lt;NULL&gt; or B&lt;idx&gt; is out of range.
-
-sk_X509_find() and int sk_X509_find_ex() search B&lt;sk&gt; using the supplied
-comparison function for an element matching B&lt;ptr&gt;. sk_X509_find() returns
-the index of the first matching element or B&lt;-1&gt; if there is no match.
-sk_X509_find_ex() returns a matching element or the nearest element that
-does not match B&lt;ptr&gt;. Note: if a comparison function is set then  B&lt;sk&gt; is
-sorted before the search which may change its order. If no comparison
-function is set then a linear search is made for a pointer matching B&lt;ptr&gt;
-and the stack is not reordered.
-
-sk_X509_sort() sorts B&lt;sk&gt; using the supplied comparison function.
-
-sk_X509_is_sorted() returns B&lt;1&gt; if B&lt;sk&gt; is sorted and B&lt;0&gt; otherwise.
-
-sk_X509_dup() returns a copy of B&lt;sk&gt;. Note the pointers in the copy
-are identical to the original.
-
-sk_X509_deep_copy() returns a new stack where each element has been copied.
-Copying is performed by the supplied copyfn() and freeing by freefn(). The
-function freefn() is only called if an error occurs.
-
-=head1 NOTES
-
-This manual page documents the functions which operate on a stack of
-B&lt;X509&gt; pointers. A stack can contain pointers to any structure with B&lt;X509&gt;
-replaced by the appropriate structure name.
-
-Care should be taken when accessing stacks in multi-threaded environments.
-Any operation which increases the size of a stack such as sk_X509_insert() or
-sk_push() can &quot;grow&quot; the size of an internal array and cause race conditions
-if the same stack is accessed in a different thread. Operations such as
-sk_find() and sk_sort() can also reorder the stack.
-
-Any comparison function supplied should use a metric suitable
-for use in a binary search operation. That is it should return zero, a
-positive or negative value if B&lt;a&gt; is equal to, greater than
-or less than B&lt;b&gt; respectively.
-
-Care should be taken when checking the return values of the functions
-sk_X509_find() and sk_X509_find_ex(). They return an index to the
-matching element. In particular B&lt;0&gt; indicates a matching first element.
-A failed search is indicated by a B&lt;-1&gt; return value.
-
-=head1 APPLICATION DEFINED STACKS
-
-Applications can create and use their own stacks by placing any of the macros
-described below in a header file.
-
-DEFINE_STACK_OF(NAME) creates set of functions for a stack of B&lt;NAME&gt;. This
-will mean that type B&lt;NAME&gt; is stored in each stack, the type is referenced by
-STACK_OF(NAME) and each function name begins with sk_NAME_. For example:
-
- NAME *sk_NAME_value(STACK_OF(NAME) *sk, int idx);
-
-DEFINE_STACK_OF_CONST(NAME) is identical to DEFINE_STACK_OF(NAME) except
-each element is constant for example:
-
- const NAME *sk_name_value(STACK_OF(NAME) *sk, int idx);
-
-DEFINE_SPECIAL_STACK_OF(FNAME, STNAME) defines a stack of B&lt;STNAME&gt; but
-each function uses B&lt;FNAME&gt;. For example:
-
- STNAME *sk_FNAME_value(STACK_OF(STNAME) *sk, int idx);
-
-=head1 RETURN VALUES
-
-sk_X509_num() returns the number of elements in the stack or B&lt;-1&gt; if the
-passed stack is B&lt;NULL&gt;.
-
-sk_X509_value() returns a pointer to a stack element or B&lt;NULL&gt; if the
-index is out of range.
-
-sk_X509_new() and sk_X509_new_null() return an empty stack or B&lt;NULL&gt; if
-an error occurs.
-
-sk_X509_set_cmp_func() returns the old comparison function or B&lt;NULL&gt; if
-there was no old comparison function.
-
-sk_X509_free(), sk_X509_zero(), sk_X509_pop_free() and sk_X509_sort() do
-not return values.
-
-sk_X509_pop(), sk_X509_shift(), sk_X509_delete() and sk_X509_delete_ptr()
-return a pointer to the deleted element or B&lt;NULL&gt; on error.
-
-sk_X509_insert(), sk_X509_push() and sk_X509_unshift() return the total
-number of elements in the stack and 0 if an error occurred.
-
-sk_X509_set() returns a pointer to the replacement element or B&lt;NULL&gt; on
-error.
-
-sk_X509_find() and sk_X509_find_ex() return an index to the found element
-or B&lt;-1&gt; on error.
-
-sk_X509_is_sorted() returns B&lt;1&gt; if the stack is sorted and B&lt;0&gt; if it is
-not.
-
-sk_X509_dup() and sk_X509_deep_copy() return a pointer to the copy of the
-stack.
-
-=head1 HISTORY
-
-Use of inline functions and application defined stacks first appeared in
-OpenSSL 1.1.0. Previous versions of OpenSSL implemented stacks as macros.
-
-=cut
-
-=head1 COPYRIGHT
-
-Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
-
-Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
-this file except in compliance with the License.  You can obtain a copy
-in the file LICENSE in the source distribution or at
-L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
-
-=cut
diff --git a/doc/crypto/stack.pod b/doc/crypto/stack.pod
new file mode 100644
index 0000000..1defff0
--- /dev/null
+++ b/doc/crypto/stack.pod
@@ -0,0 +1,212 @@
+=pod
+
+=head1 NAME
+
+DEFINE_STACK_OF, DEFINE_STACK_OF_CONST, DEFINE_SPECIAL_STACK_OF,
+sk_TYPE_num, sk_TYPE_value, sk_TYPE_new, sk_TYPE_new_null, sk_TYPE_free,
+sk_TYPE_zero, sk_TYPE_delete, sk_TYPE_delete_ptr, sk_TYPE_push,
+sk_TYPE_unshift, sk_TYPE_pop, sk_TYPE_shift, sk_TYPE_pop_free,
+sk_TYPE_insert, sk_TYPE_set, sk_TYPE_find, sk_TYPE_find_ex, sk_TYPE_sort,
+sk_TYPE_is_sorted, sk_TYPE_dup, sk_TYPE_deep_copy, sk_TYPE_set_cmp_func -
+stack container
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/safestack.h&gt;
+
+ #define STACK_OF(TYPE)
+ #define DEFINE_STACK_OF
+ #define DEFINE_STACK_OF_CONST
+ #define DEFINE_SPECIAL_STACK_OF
+
+ typedef int (*sk_TYPE_compfunc)(const TYPE *const *a, const TYPE *const *b);
+ typedef TYPE * (*sk_TYPE_copyfunc)(const TYPE *a);
+ typedef void (*sk_TYPE_freefunc)(TYPE *a);
+
+ int sk_TYPE_num(const STACK_OF(TYPE) *sk);
+ TYPE *sk_TYPE_value(const STACK_OF(TYPE) *sk, int idx);
+ STACK_OF(TYPE) *sk_TYPE_new(sk_TYPE_compfunc compare);
+ STACK_OF(TYPE) *sk_TYPE_new_null(void);
+ void sk_TYPE_free(const STACK_OF(TYPE) *sk);
+ void sk_TYPE_zero(const STACK_OF(TYPE) *sk);
+ TYPE *sk_TYPE_delete(STACK_OF(TYPE) *sk, int i);
+ TYPE *sk_TYPE_delete_ptr(STACK_OF(TYPE) *sk, TYPE *ptr);
+ int sk_TYPE_push(STACK_OF(TYPE) *sk, TYPE *ptr);
+ int sk_TYPE_unshift(STACK_OF(TYPE) *sk, TYPE *ptr);
+ TYPE *sk_TYPE_pop(STACK_OF(TYPE) *sk);
+ TYPE *sk_TYPE_shift(STACK_OF(TYPE) *sk);
+ void sk_TYPE_pop_free(STACK_OF(TYPE) *sk, sk_TYPE_freefunc freefunc);
+ int sk_TYPE_insert(STACK_OF(TYPE) *sk, TYPE *ptr, int idx);
+ TYPE *sk_TYPE_set(STACK_OF(TYPE) *sk, int idx, TYPE *ptr);
+ int sk_TYPE_find(STACK_OF(TYPE) *sk, TYPE *ptr);
+ int sk_TYPE_find_ex(STACK_OF(TYPE) *sk, TYPE *ptr);
+ void sk_TYPE_sort(const STACK_OF(TYPE) *sk);
+ int sk_TYPE_is_sorted(const STACK_OF(TYPE) *sk);
+ STACK_OF(TYPE) *sk_TYPE_dup(STACK_OF(TYPE) *sk);
+ STACK_OF(TYPE) *sk_TYPE_deep_copy(STACK_OF(TYPE) *sk,
+                                   sk_TYPE_copyfunc copyfunc,
+                                   sk_TYPE_freefunc freefunc);
+ sk_TYPE_compfunc (*sk_TYPE_set_cmp_func(STACK_OF(TYPE) *sk, sk_TYPE_compfunc compare);
+
+=head1 DESCRIPTION
+
+Applications can create and use their own stacks by placing any of the macros
+described below in a header file.  In the description below, I&lt;TYPE&gt; is used
+as a placeholder for any of the OpenSSL datatypes, such as I&lt;X509&gt;.
+
+DEFINE_STACK_OF(TYPE) creates set of functions for a stack of B&lt;TYPE&gt;. This
+will mean that type B&lt;TYPE&gt; is stored in each stack, the type is referenced by
+STACK_OF(TYPE) and each function name begins with I&lt;sk_TYPE_&gt;. For example:
+
+ TYPE *sk_TYPE_value(STACK_OF(TYPE) *sk, int idx);
+
+DEFINE_STACK_OF_CONST(TYPE) is identical to DEFINE_STACK_OF(TYPE) except
+each element is constant. For example:
+
+ const TYPE *sk_TYPE_value(STACK_OF(TYPE) *sk, int idx);
+
+DEFINE_SPECIAL_STACK_OF(FUNCNAME, TYPE) defines a stack of B&lt;TYPE&gt; but
+each function uses B&lt;FUNCNAME&gt; in the function name. For example:
+
+ TYPE *sk_FUNCNAME_value(STACK_OF(TYPE) *sk, int idx);
+
+sk_TYPE_num() returns the number of elements in B&lt;sk&gt; or -1 if B&lt;sk&gt; is
+B&lt;NULL&gt;.
+
+sk_TYPE_value() returns element B&lt;idx&gt; in B&lt;sk&gt;, where B&lt;idx&gt; starts at
+zero. If B&lt;idx&gt; is out of range then B&lt;NULL&gt; is returned.
+
+sk_TYPE_new() allocates a new empty stack using comparison function B&lt;compar&gt;.
+If B&lt;compar&gt; is B&lt;NULL&gt; then no comparison function is used.
+
+sk_TYPE_new_null() allocates a new empty stack with no comparison function.
+
+sk_TYPE_set_cmp_func() sets the comparison function of B&lt;sk&gt; to B&lt;compar&gt;.
+The previous comparison function is returned or B&lt;NULL&gt; if there was
+no previous comparison function.
+
+sk_TYPE_free() frees up the B&lt;sk&gt; structure. It does B&lt;not&gt; free up any
+elements of B&lt;sk&gt;. After this call B&lt;sk&gt; is no longer valid.
+
+sk_TYPE_zero() sets the number of elements in B&lt;sk&gt; to zero. It does not free
+B&lt;sk&gt; so after this call B&lt;sk&gt; is still valid.
+
+sk_TYPE_pop_free() frees up all elements of B&lt;sk&gt; and B&lt;sk&gt; itself. The
+free function freefunc() is called on each element to free it.
+
+sk_TYPE_delete() deletes element B&lt;i&gt; from B&lt;sk&gt;. It returns the deleted
+element or B&lt;NULL&gt; if B&lt;i&gt; is out of range.
+
+sk_TYPE_delete_ptr() deletes element matching B&lt;ptr&gt; from B&lt;sk&gt;. It returns
+the deleted element or B&lt;NULL&gt; if no element matching B&lt;ptr&gt; was found.
+
+sk_TYPE_insert() inserts B&lt;ptr&gt; into B&lt;sk&gt; at position B&lt;idx&gt;. Any existing
+elements at or after B&lt;idx&gt; are moved downwards. If B&lt;idx&gt; is out of range
+the new element is appended to B&lt;sk&gt;. sk_TYPE_insert() either returns the
+number of elements in B&lt;sk&gt; after the new element is inserted or zero if
+an error (such as memory allocation failure) occurred.
+
+sk_TYPE_push() appends B&lt;ptr&gt; to B&lt;sk&gt; it is equivalent to:
+
+ sk_TYPE_insert(sk, ptr, -1);
+
+sk_TYPE_unshift() inserts B&lt;ptr&gt; at the start of B&lt;sk&gt; it is equivalent to:
+
+ sk_TYPE_insert(sk, ptr, 0);
+
+sk_TYPE_pop() returns and removes the last element from B&lt;sk&gt;.
+
+sk_TYPE_shift() returns and removes the first element from B&lt;sk&gt;.
+
+sk_TYPE_set() sets element B&lt;idx&gt; of B&lt;sk&gt; to B&lt;ptr&gt; replacing the current
+element. The new element value is returned or B&lt;NULL&gt; if an error occurred:
+this will only happen if B&lt;sk&gt; is B&lt;NULL&gt; or B&lt;idx&gt; is out of range.
+
+sk_TYPE_find() and sk_TYPE_find_ex() search B&lt;sk&gt; using the supplied
+comparison function for an element matching B&lt;ptr&gt;. sk_TYPE_find() returns
+the index of the first matching element or B&lt;-1&gt; if there is no match.
+sk_TYPE_find_ex() returns a matching element or the nearest element that
+does not match B&lt;ptr&gt;. Note: if a comparison function is set then  B&lt;sk&gt; is
+sorted before the search which may change its order. If no comparison
+function is set then a linear search is made for a pointer matching B&lt;ptr&gt;
+and the stack is not reordered.
+
+sk_TYPE_sort() sorts B&lt;sk&gt; using the supplied comparison function.
+
+sk_TYPE_is_sorted() returns B&lt;1&gt; if B&lt;sk&gt; is sorted and B&lt;0&gt; otherwise.
+
+sk_TYPE_dup() returns a copy of B&lt;sk&gt;. Note the pointers in the copy
+are identical to the original.
+
+sk_TYPE_deep_copy() returns a new stack where each element has been copied.
+Copying is performed by the supplied copyfunc() and freeing by freefunc(). The
+function freefunc() is only called if an error occurs.
+
+=head1 NOTES
+
+Care should be taken when accessing stacks in multi-threaded environments.
+Any operation which increases the size of a stack such as sk_TYPE_insert() or
+sk_push() can &quot;grow&quot; the size of an internal array and cause race conditions
+if the same stack is accessed in a different thread. Operations such as
+sk_find() and sk_sort() can also reorder the stack.
+
+Any comparison function supplied should use a metric suitable
+for use in a binary search operation. That is it should return zero, a
+positive or negative value if B&lt;a&gt; is equal to, greater than
+or less than B&lt;b&gt; respectively.
+
+Care should be taken when checking the return values of the functions
+sk_TYPE_find() and sk_TYPE_find_ex(). They return an index to the
+matching element. In particular B&lt;0&gt; indicates a matching first element.
+A failed search is indicated by a B&lt;-1&gt; return value.
+
+=head1 RETURN VALUES
+
+sk_TYPE_num() returns the number of elements in the stack or B&lt;-1&gt; if the
+passed stack is B&lt;NULL&gt;.
+
+sk_TYPE_value() returns a pointer to a stack element or B&lt;NULL&gt; if the
+index is out of range.
+
+sk_TYPE_new() and sk_TYPE_new_null() return an empty stack or B&lt;NULL&gt; if
+an error occurs.
+
+sk_TYPE_set_cmp_func() returns the old comparison function or B&lt;NULL&gt; if
+there was no old comparison function.
+
+sk_TYPE_free(), sk_TYPE_zero(), sk_TYPE_pop_free() and sk_TYPE_sort() do
+not return values.
+
+sk_TYPE_pop(), sk_TYPE_shift(), sk_TYPE_delete() and sk_TYPE_delete_ptr()
+return a pointer to the deleted element or B&lt;NULL&gt; on error.
+
+sk_TYPE_insert(), sk_TYPE_push() and sk_TYPE_unshift() return the total
+number of elements in the stack and 0 if an error occurred.
+
+sk_TYPE_set() returns a pointer to the replacement element or B&lt;NULL&gt; on
+error.
+
+sk_TYPE_find() and sk_TYPE_find_ex() return an index to the found element
+or B&lt;-1&gt; on error.
+
+sk_TYPE_is_sorted() returns B&lt;1&gt; if the stack is sorted and B&lt;0&gt; if it is
+not.
+
+sk_TYPE_dup() and sk_TYPE_deep_copy() return a pointer to the copy of the
+stack.
+
+=head1 HISTORY
+
+Before OpenSSL 1.1.0, this was implemented via macros and not inline functions
+and was not a public API.
+
+=head1 COPYRIGHT
+
+Copyright 2000-2016 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/include/openssl/lhash.h b/include/openssl/lhash.h
index 158300f..7c568ac 100644
--- a/include/openssl/lhash.h
+++ b/include/openssl/lhash.h
@@ -21,16 +21,12 @@
 extern &quot;C&quot; {
 #endif
 
-typedef struct lhash_node_st {
-    void *data;
-    struct lhash_node_st *next;
-    unsigned long hash;
-} LHASH_NODE;
-
-typedef int (*LHASH_COMP_FN_TYPE) (const void *, const void *);
-typedef unsigned long (*LHASH_HASH_FN_TYPE) (const void *);
-typedef void (*LHASH_DOALL_FN_TYPE) (void *);
-typedef void (*LHASH_DOALL_ARG_FN_TYPE) (void *, void *);
+typedef struct lhash_node_st OPENSSL_LH_NODE;
+typedef int (*OPENSSL_LH_COMPFUNC) (const void *, const void *);
+typedef unsigned long (*OPENSSL_LH_HASHFUNC) (const void *);
+typedef void (*OPENSSL_LH_DOALL_FUNC) (void *);
+typedef void (*OPENSSL_LH_DOALL_FUNCARG) (void *, void *);
+typedef struct lhash_st OPENSSL_LHASH;
 
 /*
  * Macros for declaring and implementing type-safe wrappers for LHASH
@@ -70,62 +66,53 @@ typedef void (*LHASH_DOALL_ARG_FN_TYPE) (void *, void *);
                 name##_doall_arg(a, b); }
 # define LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG
 
-typedef struct lhash_st {
-    LHASH_NODE **b;
-    LHASH_COMP_FN_TYPE comp;
-    LHASH_HASH_FN_TYPE hash;
-    unsigned int num_nodes;
-    unsigned int num_alloc_nodes;
-    unsigned int p;
-    unsigned int pmax;
-    unsigned long up_load;      /* load times 256 */
-    unsigned long down_load;    /* load times 256 */
-    unsigned long num_items;
-    unsigned long num_expands;
-    unsigned long num_expand_reallocs;
-    unsigned long num_contracts;
-    unsigned long num_contract_reallocs;
-    unsigned long num_hash_calls;
-    unsigned long num_comp_calls;
-    unsigned long num_insert;
-    unsigned long num_replace;
-    unsigned long num_delete;
-    unsigned long num_no_delete;
-    unsigned long num_retrieve;
-    unsigned long num_retrieve_miss;
-    unsigned long num_hash_comps;
-    int error;
-} _LHASH;                       /* Do not use _LHASH directly, use LHASH_OF
-                                 * and friends */
 
 # define LH_LOAD_MULT    256
 
-/*
- * Indicates a malloc() error in the last call, this is only bad in
- * lh_insert().
- */
-int lh_error(_LHASH *lh);
-
-_LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c);
-void lh_free(_LHASH *lh);
-void *lh_insert(_LHASH *lh, void *data);
-void *lh_delete(_LHASH *lh, const void *data);
-void *lh_retrieve(_LHASH *lh, const void *data);
-void lh_doall(_LHASH *lh, LHASH_DOALL_FN_TYPE func);
-void lh_doall_arg(_LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg);
-unsigned long lh_strhash(const char *c);
-unsigned long lh_num_items(const _LHASH *lh);
-unsigned long lh_get_down_load(const _LHASH *lh);
-void lh_set_down_load(_LHASH *lh, unsigned long down_load);
+int OPENSSL_LH_error(OPENSSL_LHASH *lh);
+OPENSSL_LHASH *OPENSSL_LH_new(OPENSSL_LH_HASHFUNC h, OPENSSL_LH_COMPFUNC c);
+void OPENSSL_LH_free(OPENSSL_LHASH *lh);
+void *OPENSSL_LH_insert(OPENSSL_LHASH *lh, void *data);
+void *OPENSSL_LH_delete(OPENSSL_LHASH *lh, const void *data);
+void *OPENSSL_LH_retrieve(OPENSSL_LHASH *lh, const void *data);
+void OPENSSL_LH_doall(OPENSSL_LHASH *lh, OPENSSL_LH_DOALL_FUNC func);
+void OPENSSL_LH_doall_arg(OPENSSL_LHASH *lh, OPENSSL_LH_DOALL_FUNCARG func, void *arg);
+unsigned long OPENSSL_LH_strhash(const char *c);
+unsigned long OPENSSL_LH_num_items(const OPENSSL_LHASH *lh);
+unsigned long OPENSSL_LH_get_down_load(const OPENSSL_LHASH *lh);
+void OPENSSL_LH_set_down_load(OPENSSL_LHASH *lh, unsigned long down_load);
 
 # ifndef OPENSSL_NO_STDIO
-void lh_stats(const _LHASH *lh, FILE *fp);
-void lh_node_stats(const _LHASH *lh, FILE *fp);
-void lh_node_usage_stats(const _LHASH *lh, FILE *fp);
+void OPENSSL_LH_stats(const OPENSSL_LHASH *lh, FILE *fp);
+void OPENSSL_LH_node_stats(const OPENSSL_LHASH *lh, FILE *fp);
+void OPENSSL_LH_node_usage_stats(const OPENSSL_LHASH *lh, FILE *fp);
+# endif
+void OPENSSL_LH_stats_bio(const OPENSSL_LHASH *lh, BIO *out);
+void OPENSSL_LH_node_stats_bio(const OPENSSL_LHASH *lh, BIO *out);
+void OPENSSL_LH_node_usage_stats_bio(const OPENSSL_LHASH *lh, BIO *out);
+
+# if OPENSSL_API_COMPAT &lt; 0x10100000L
+#  define _LHASH OPENSSL_LHASH
+#  define LHASH_NODE OPENSSL_LH_NODE
+#  define lh_error OPENSSL_LH_error
+#  define lh_new OPENSSL_lh_new
+#  define lh_free OPENSSL_LH_free
+#  define lh_insert OPENSSL_LH_insert
+#  define lh_delete OPENSSL_LH_delete
+#  define lh_retrieve OPENSSL_LH_retrieve
+#  define lh_doall OPENSSL_LH_doall
+#  define lh_doall_arg OPENSSL_LH_doall_arg
+#  define lh_strhash OPENSSL_LH_strhash
+#  define lh_num_items OPENSSL_LH_num_items
+#  ifndef OPENSSL_NO_STDIO
+#   define lh_stats OPENSSL_LH_stats
+#   define lh_node_stats OPENSSL_LH_node_stats
+#   define lh_node_usage_stats OPENSSL_LH_node_usage_stats
+#  endif
+#  define lh_stats_bio OPENSSL_LH_stats_bio
+#  define lh_node_stats_bio OPENSSL_LH_node_stats_bio
+#  define lh_node_usage_stats_bio OPENSSL_LH_node_usage_stats_bio
 # endif
-void lh_stats_bio(const _LHASH *lh, BIO *out);
-void lh_node_stats_bio(const _LHASH *lh, BIO *out);
-void lh_node_usage_stats_bio(const _LHASH *lh, BIO *out);
 
 /* Type checking... */
 
@@ -138,56 +125,56 @@ void lh_node_usage_stats_bio(const _LHASH *lh, BIO *out);
                         int (*cfn)(const type *, const type *)) \
     { \
         return (LHASH_OF(type) *) \
-            lh_new((LHASH_HASH_FN_TYPE) hfn, (LHASH_COMP_FN_TYPE)cfn); \
+            OPENSSL_LH_new((OPENSSL_LH_HASHFUNC)hfn, (OPENSSL_LH_COMPFUNC)cfn); \
     } \
     static ossl_inline void lh_##type##_free(LHASH_OF(type) *lh) \
     { \
-        lh_free((_LHASH *)lh); \
+        OPENSSL_LH_free((OPENSSL_LHASH *)lh); \
     } \
     static ossl_inline type *lh_##type##_insert(LHASH_OF(type) *lh, type *d) \
     { \
-        return (type *)lh_insert((_LHASH *)lh, d); \
+        return (type *)OPENSSL_LH_insert((OPENSSL_LHASH *)lh, d); \
     } \
     static ossl_inline type *lh_##type##_delete(LHASH_OF(type) *lh, const type *d) \
     { \
-        return (type *)lh_delete((_LHASH *)lh, d); \
+        return (type *)OPENSSL_LH_delete((OPENSSL_LHASH *)lh, d); \
     } \
     static ossl_inline type *lh_##type##_retrieve(LHASH_OF(type) *lh, const type *d) \
     { \
-        return (type *)lh_retrieve((_LHASH *)lh, d); \
+        return (type *)OPENSSL_LH_retrieve((OPENSSL_LHASH *)lh, d); \
     } \
     static ossl_inline int lh_##type##_error(LHASH_OF(type) *lh) \
     { \
-        return lh_error((_LHASH *)lh); \
+        return OPENSSL_LH_error((OPENSSL_LHASH *)lh); \
     } \
     static ossl_inline unsigned long lh_##type##_num_items(LHASH_OF(type) *lh) \
     { \
-        return lh_num_items((_LHASH *)lh); \
+        return OPENSSL_LH_num_items((OPENSSL_LHASH *)lh); \
     } \
     static ossl_inline void lh_##type##_node_stats_bio(const LHASH_OF(type) *lh, BIO *out) \
     { \
-        lh_node_stats_bio((_LHASH *)lh, out); \
+        OPENSSL_LH_node_stats_bio((OPENSSL_LHASH *)lh, out); \
     } \
     static ossl_inline void lh_##type##_node_usage_stats_bio(const LHASH_OF(type) *lh, BIO *out) \
     { \
-        lh_node_usage_stats_bio((_LHASH *)lh, out); \
+        OPENSSL_LH_node_usage_stats_bio((OPENSSL_LHASH *)lh, out); \
     } \
     static ossl_inline void lh_##type##_stats_bio(const LHASH_OF(type) *lh, BIO *out) \
     { \
-        lh_stats_bio((_LHASH *)lh, out); \
+        OPENSSL_LH_stats_bio((OPENSSL_LHASH *)lh, out); \
     } \
     static ossl_inline unsigned long lh_##type##_get_down_load(LHASH_OF(type) *lh) \
     { \
-        return lh_get_down_load((_LHASH *)lh); \
+        return OPENSSL_LH_get_down_load((OPENSSL_LHASH *)lh); \
     } \
     static ossl_inline void lh_##type##_set_down_load(LHASH_OF(type) *lh, unsigned long dl) \
     { \
-        lh_set_down_load((_LHASH *)lh, dl); \
+        OPENSSL_LH_set_down_load((OPENSSL_LHASH *)lh, dl); \
     } \
     static ossl_inline void lh_##type##_doall(LHASH_OF(type) *lh, \
                                          void (*doall)(type *)) \
     { \
-        lh_doall((_LHASH *)lh, (LHASH_DOALL_FN_TYPE)doall); \
+        OPENSSL_LH_doall((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNC)doall); \
     } \
     LHASH_OF(type)
 
@@ -203,17 +190,10 @@ void lh_node_usage_stats_bio(const _LHASH *lh, BIO *out);
                                    void (*fn)(cbargtype *, argtype *), \
                                    argtype *arg) \
     { \
-        lh_doall_arg((_LHASH *)lh, (LHASH_DOALL_ARG_FN_TYPE)fn, (void *)arg); \
+        OPENSSL_LH_doall_arg((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNCARG)fn, (void *)arg); \
     } \
     LHASH_OF(type)
 
-# define CHECKED_LHASH_OF(type,lh) \
-  ((_LHASH *)CHECKED_PTR_OF(LHASH_OF(type),lh))
-
-/* Define wrapper functions. */
-# define LHM_lh_doall_arg(type, lh, fn, arg_type, arg) \
-  lh_doall_arg(CHECKED_LHASH_OF(type, lh), fn, CHECKED_PTR_OF(arg_type, arg))
-
 DEFINE_LHASH_OF(OPENSSL_STRING);
 DEFINE_LHASH_OF(OPENSSL_CSTRING);
 
diff --git a/include/openssl/safestack.h b/include/openssl/safestack.h
index e12f60d..d0af0eb 100644
--- a/include/openssl/safestack.h
+++ b/include/openssl/safestack.h
@@ -17,124 +17,104 @@
 extern &quot;C&quot; {
 #endif
 
-# ifndef CHECKED_PTR_OF
-#  define CHECKED_PTR_OF(type, p) ((void*) (1 ? p : (type*)0))
-# endif
-
-/*
- * In C++ we get problems because an explicit cast is needed from (void *) we
- * use CHECKED_STACK_OF to ensure the correct type is passed in the macros
- * below.
- */
-
-# define CHECKED_STACK_OF(type, p) \
-    ((_STACK*) (1 ? p : (STACK_OF(type)*)0))
-
-# define CHECKED_SK_COPY_FUNC(type, p) \
-    ((void *(*)(void *)) ((1 ? p : (type *(*)(const type *))0)))
-
-# define CHECKED_SK_FREE_FUNC(type, p) \
-    ((void (*)(void *)) ((1 ? p : (void (*)(type *))0)))
-
-# define CHECKED_SK_CMP_FUNC(type, p) \
-    ((int (*)(const void *, const void *)) \
-        ((1 ? p : (int (*)(const type * const *, const type * const *))0)))
-
 # define STACK_OF(type) struct stack_st_##type
 
 # define SKM_DEFINE_STACK_OF(t1, t2, t3) \
     STACK_OF(t1); \
+    typedef int (*sk_##t1##_compfunc)(const t3 * const *a, const t3 *const *b); \
+    typedef void (*sk_##t1##_freefunc)(t3 *a); \
+    typedef t3 * (*sk_##t1##_copyfunc)(const t3 *a); \
     static ossl_inline int sk_##t1##_num(const STACK_OF(t1) *sk) \
     { \
-        return sk_num((const _STACK *)sk); \
+        return OPENSSL_sk_num((const OPENSSL_STACK *)sk); \
     } \
     static ossl_inline t2 *sk_##t1##_value(const STACK_OF(t1) *sk, int idx) \
     { \
-        return (t2 *)sk_value((const _STACK *)sk, idx); \
+        return (t2 *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); \
     } \
-    static ossl_inline STACK_OF(t1) *sk_##t1##_new(int (*cmpf)(const t3 * const *a, const t3 * const *b)) \
+    static ossl_inline STACK_OF(t1) *sk_##t1##_new(sk_##t1##_compfunc compare) \
     { \
-        return (STACK_OF(t1) *)sk_new((int (*)(const void *a, const void *b))cmpf); \
+        return (STACK_OF(t1) *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); \
     } \
     static ossl_inline STACK_OF(t1) *sk_##t1##_new_null(void) \
     { \
-        return (STACK_OF(t1) *)sk_new_null(); \
+        return (STACK_OF(t1) *)OPENSSL_sk_new_null(); \
     } \
     static ossl_inline void sk_##t1##_free(STACK_OF(t1) *sk) \
     { \
-        sk_free((_STACK *)sk); \
+        OPENSSL_sk_free((OPENSSL_STACK *)sk); \
     } \
     static ossl_inline void sk_##t1##_zero(STACK_OF(t1) *sk) \
     { \
-        sk_zero((_STACK *)sk); \
+        OPENSSL_sk_zero((OPENSSL_STACK *)sk); \
     } \
     static ossl_inline t2 *sk_##t1##_delete(STACK_OF(t1) *sk, int i) \
     { \
-        return (t2 *)sk_delete((_STACK *)sk, i); \
+        return (t2 *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); \
     } \
     static ossl_inline t2 *sk_##t1##_delete_ptr(STACK_OF(t1) *sk, t2 *ptr) \
     { \
-        return (t2 *)sk_delete_ptr((_STACK *)sk, (void *)ptr); \
+        return (t2 *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (void *)ptr); \
     } \
     static ossl_inline int sk_##t1##_push(STACK_OF(t1) *sk, t2 *ptr) \
     { \
-        return sk_push((_STACK *)sk, (void *)ptr); \
+        return OPENSSL_sk_push((OPENSSL_STACK *)sk, (void *)ptr); \
     } \
     static ossl_inline int sk_##t1##_unshift(STACK_OF(t1) *sk, t2 *ptr) \
     { \
-        return sk_unshift((_STACK *)sk, (void *)ptr); \
+        return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (void *)ptr); \
     } \
     static ossl_inline t2 *sk_##t1##_pop(STACK_OF(t1) *sk) \
     { \
-        return (t2 *)sk_pop((_STACK *)sk); \
+        return (t2 *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); \
     } \
     static ossl_inline t2 *sk_##t1##_shift(STACK_OF(t1) *sk) \
     { \
-        return (t2 *)sk_shift((_STACK *)sk); \
+        return (t2 *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); \
     } \
-    static ossl_inline void sk_##t1##_pop_free(STACK_OF(t1) *sk, void (*func)(t3 *a)) \
+    static ossl_inline void sk_##t1##_pop_free(STACK_OF(t1) *sk, sk_##t1##_freefunc freefunc) \
     { \
-        sk_pop_free((_STACK *)sk, (void (*)(void *))func); \
+        OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); \
     } \
     static ossl_inline int sk_##t1##_insert(STACK_OF(t1) *sk, t2 *ptr, int idx) \
     { \
-        return sk_insert((_STACK *)sk, (void *)ptr, idx); \
+        return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (void *)ptr, idx); \
     } \
     static ossl_inline t2 *sk_##t1##_set(STACK_OF(t1) *sk, int idx, t2 *ptr) \
     { \
-        return (t2 *)sk_set((_STACK *)sk, idx, (void *)ptr); \
+        return (t2 *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (void *)ptr); \
     } \
     static ossl_inline int sk_##t1##_find(STACK_OF(t1) *sk, t2 *ptr) \
     { \
-        return sk_find((_STACK *)sk, (void *)ptr); \
+        return OPENSSL_sk_find((OPENSSL_STACK *)sk, (void *)ptr); \
     } \
     static ossl_inline int sk_##t1##_find_ex(STACK_OF(t1) *sk, t2 *ptr) \
     { \
-        return sk_find_ex((_STACK *)sk, (void *)ptr); \
+        return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (void *)ptr); \
     } \
     static ossl_inline void sk_##t1##_sort(STACK_OF(t1) *sk) \
     { \
-        sk_sort((_STACK *)sk); \
+        OPENSSL_sk_sort((OPENSSL_STACK *)sk); \
     } \
     static ossl_inline int sk_##t1##_is_sorted(const STACK_OF(t1) *sk) \
     { \
-        return sk_is_sorted((const _STACK *)sk); \
+        return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); \
     } \
     static ossl_inline STACK_OF(t1) * sk_##t1##_dup(STACK_OF(t1) *sk) \
     { \
-        return (STACK_OF(t1) *)sk_dup((_STACK *)sk); \
+        return (STACK_OF(t1) *)OPENSSL_sk_dup((OPENSSL_STACK *)sk); \
     } \
     static ossl_inline STACK_OF(t1) *sk_##t1##_deep_copy(STACK_OF(t1) *sk, \
-                                                    t3 *(*copyfn)(const t3 *), \
-                                                    void (*freefn)(t3 *)) \
+                                                    sk_##t1##_copyfunc copyfunc, \
+                                                    sk_##t1##_freefunc freefunc) \
     { \
-        return (STACK_OF(t1) *)sk_deep_copy((_STACK *)sk, \
-                                            (void * (*)(void *a))copyfn, \
-                                            (void (*)(void *a))freefn); \
+        return (STACK_OF(t1) *)OPENSSL_sk_deep_copy((OPENSSL_STACK *)sk, \
+                                            (OPENSSL_sk_copyfunc)copyfunc, \
+                                            (OPENSSL_sk_freefunc)freefunc); \
     } \
-    static ossl_inline int (*sk_##t1##_set_cmp_func(STACK_OF(t1) *sk, int (*cmpf)(const t3 * const *a, const t3 * const *b)))(const t3 * const *, const t3 * const *) \
+    static ossl_inline sk_##t1##_compfunc sk_##t1##_set_cmp_func(STACK_OF(t1) *sk, sk_##t1##_compfunc compare) \
     { \
-        return (int (*)(const t3 * const *,const t3 * const *))sk_set_cmp_func((_STACK *)sk, (int (*)(const void *a, const void *b))cmpf); \
+        return (sk_##t1##_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); \
     }
 
 # define DEFINE_SPECIAL_STACK_OF(t1, t2) SKM_DEFINE_STACK_OF(t1, t2, t2)
diff --git a/include/openssl/stack.h b/include/openssl/stack.h
index 5a90de6..6fab33b 100644
--- a/include/openssl/stack.h
+++ b/include/openssl/stack.h
@@ -14,33 +14,62 @@
 extern &quot;C&quot; {
 #endif
 
-typedef struct stack_st _STACK; /* Use STACK_OF(...) instead */
-
-int sk_num(const _STACK *);
-void *sk_value(const _STACK *, int);
-
-void *sk_set(_STACK *, int, void *);
-
-_STACK *sk_new(int (*cmp) (const void *, const void *));
-_STACK *sk_new_null(void);
-void sk_free(_STACK *);
-void sk_pop_free(_STACK *st, void (*func) (void *));
-_STACK *sk_deep_copy(_STACK *, void *(*)(void *), void (*)(void *));
-int sk_insert(_STACK *sk, void *data, int where);
-void *sk_delete(_STACK *st, int loc);
-void *sk_delete_ptr(_STACK *st, void *p);
-int sk_find(_STACK *st, void *data);
-int sk_find_ex(_STACK *st, void *data);
-int sk_push(_STACK *st, void *data);
-int sk_unshift(_STACK *st, void *data);
-void *sk_shift(_STACK *st);
-void *sk_pop(_STACK *st);
-void sk_zero(_STACK *st);
-int (*sk_set_cmp_func(_STACK *sk, int (*c) (const void *, const void *)))
- (const void *, const void *);
-_STACK *sk_dup(_STACK *st);
-void sk_sort(_STACK *st);
-int sk_is_sorted(const _STACK *st);
+typedef struct stack_st OPENSSL_STACK; /* Use STACK_OF(...) instead */
+
+typedef int (*OPENSSL_sk_compfunc)(const void *, const void *);
+typedef void (*OPENSSL_sk_freefunc)(void *);
+typedef void *(*OPENSSL_sk_copyfunc)(const void *);
+
+int OPENSSL_sk_num(const OPENSSL_STACK *);
+void *OPENSSL_sk_value(const OPENSSL_STACK *, int);
+
+void *OPENSSL_sk_set(OPENSSL_STACK *, int, void *);
+
+OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_compfunc cmp);
+OPENSSL_STACK *OPENSSL_sk_new_null(void);
+void OPENSSL_sk_free(OPENSSL_STACK *);
+void OPENSSL_sk_pop_free(OPENSSL_STACK *st, void (*func) (void *));
+OPENSSL_STACK *OPENSSL_sk_deep_copy(OPENSSL_STACK *, OPENSSL_sk_copyfunc c, OPENSSL_sk_freefunc f);
+int OPENSSL_sk_insert(OPENSSL_STACK *sk, void *data, int where);
+void *OPENSSL_sk_delete(OPENSSL_STACK *st, int loc);
+void *OPENSSL_sk_delete_ptr(OPENSSL_STACK *st, void *p);
+int OPENSSL_sk_find(OPENSSL_STACK *st, void *data);
+int OPENSSL_sk_find_ex(OPENSSL_STACK *st, void *data);
+int OPENSSL_sk_push(OPENSSL_STACK *st, void *data);
+int OPENSSL_sk_unshift(OPENSSL_STACK *st, void *data);
+void *OPENSSL_sk_shift(OPENSSL_STACK *st);
+void *OPENSSL_sk_pop(OPENSSL_STACK *st);
+void OPENSSL_sk_zero(OPENSSL_STACK *st);
+OPENSSL_sk_compfunc OPENSSL_sk_set_cmp_func(OPENSSL_STACK *sk, OPENSSL_sk_compfunc cmp);
+OPENSSL_STACK *OPENSSL_sk_dup(OPENSSL_STACK *st);
+void OPENSSL_sk_sort(OPENSSL_STACK *st);
+int OPENSSL_sk_is_sorted(const OPENSSL_STACK *st);
+
+# if OPENSSL_API_COMPAT &lt; 0x10100000L
+#  define _STACK OPENSSL_STACK
+#  define sk_num OPENSSL_sk_num
+#  define sk_value OPENSSL_sk_value
+#  define sk_set OPENSSL_sk_set
+#  define sk_new OPENSSL_sk_new
+#  define sk_new_null OPENSSL_sk_new_null
+#  define sk_free OPENSSL_sk_free
+#  define sk_pop_free OPENSSL_sk_pop_free
+#  define sk_deep_copy OPENSSL_sk_deep_copy
+#  define sk_insert OPENSSL_sk_insert
+#  define sk_delete OPENSSL_sk_delete
+#  define sk_delete_ptr OPENSSL_sk_delete_ptr
+#  define sk_find OPENSSL_sk_find
+#  define sk_find_ex OPENSSL_sk_find_ex
+#  define sk_push OPENSSL_sk_push
+#  define sk_unshift OPENSSL_sk_unshift
+#  define sk_shift OPENSSL_sk_shift
+#  define sk_pop OPENSSL_sk_pop
+#  define sk_zero OPENSSL_sk_zero
+#  define sk_set_cmp_func OPENSSL_sk_set_cmp_func
+#  define sk_dup OPENSSL_sk_dup
+#  define sk_sort OPENSSL_sk_sort
+#  define sk_is_sorted OPENSSL_sk_is_sorted
+# endif
 
 #ifdef  __cplusplus
 }
diff --git a/include/openssl/txt_db.h b/include/openssl/txt_db.h
index a12d62f..0e6c943 100644
--- a/include/openssl/txt_db.h
+++ b/include/openssl/txt_db.h
@@ -44,7 +44,7 @@ typedef struct txt_db_st {
 TXT_DB *TXT_DB_read(BIO *in, int num);
 long TXT_DB_write(BIO *out, TXT_DB *db);
 int TXT_DB_create_index(TXT_DB *db, int field, int (*qual) (OPENSSL_STRING *),
-                        LHASH_HASH_FN_TYPE hash, LHASH_COMP_FN_TYPE cmp);
+                        OPENSSL_LH_HASHFUNC hash, OPENSSL_LH_COMPFUNC cmp);
 void TXT_DB_free(TXT_DB *db);
 OPENSSL_STRING *TXT_DB_get_by_index(TXT_DB *db, int idx,
                                     OPENSSL_STRING *value);
diff --git a/ssl/ssl_sess.c b/ssl/ssl_sess.c
index f602134..f168900 100644
--- a/ssl/ssl_sess.c
+++ b/ssl/ssl_sess.c
@@ -977,10 +977,10 @@ void SSL_CTX_flush_sessions(SSL_CTX *s, long t)
         return;
     tp.time = t;
     CRYPTO_THREAD_write_lock(s-&gt;lock);
-    i = CHECKED_LHASH_OF(SSL_SESSION, tp.cache)-&gt;down_load;
-    CHECKED_LHASH_OF(SSL_SESSION, tp.cache)-&gt;down_load = 0;
+    i = lh_SSL_SESSION_get_down_load(s-&gt;sessions);
+    lh_SSL_SESSION_set_down_load(s-&gt;sessions, 0);
     lh_SSL_SESSION_doall_TIMEOUT_PARAM(tp.cache, timeout_cb, &amp;tp);
-    CHECKED_LHASH_OF(SSL_SESSION, tp.cache)-&gt;down_load = i;
+    lh_SSL_SESSION_set_down_load(s-&gt;sessions, i);
     CRYPTO_THREAD_unlock(s-&gt;lock);
 }
 
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 9511d90..ccd37f8 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -348,7 +348,7 @@ X509_NAME_cmp                           343	1_1_0	EXIST::FUNCTION:
 DIST_POINT_it                           344	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 DIST_POINT_it                           344	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 PEM_read_X509_CRL                       345	1_1_0	EXIST::FUNCTION:
-sk_sort                                 346	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_sort                         346	1_1_0	EXIST::FUNCTION:
 CTLOG_STORE_load_file                   347	1_1_0	EXIST::FUNCTION:CT
 ASN1_SEQUENCE_it                        348	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 ASN1_SEQUENCE_it                        348	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
@@ -489,7 +489,7 @@ X509_CRL_sort                           480	1_1_0	EXIST::FUNCTION:
 i2d_RSA_PUBKEY_bio                      481	1_1_0	EXIST::FUNCTION:RSA
 ASN1_T61STRING_free                     482	1_1_0	EXIST::FUNCTION:
 PEM_write_CMS                           483	1_1_0	EXIST::FUNCTION:CMS
-sk_find                                 484	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_find                         484	1_1_0	EXIST::FUNCTION:
 ENGINE_get_ciphers                      485	1_1_0	EXIST::FUNCTION:ENGINE
 EVP_rc2_ofb                             486	1_1_0	EXIST::FUNCTION:RC2
 EVP_PKEY_set1_RSA                       487	1_1_0	EXIST::FUNCTION:RSA
@@ -746,7 +746,7 @@ EC_POINT_hex2point                      727	1_1_0	EXIST::FUNCTION:EC
 X509v3_get_ext_by_critical              728	1_1_0	EXIST::FUNCTION:
 ENGINE_get_default_RSA                  729	1_1_0	EXIST::FUNCTION:ENGINE
 DSA_sign_setup                          730	1_1_0	EXIST::FUNCTION:DSA
-sk_new_null                             731	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_new_null                     731	1_1_0	EXIST::FUNCTION:
 PEM_read_PKCS8                          732	1_1_0	EXIST::FUNCTION:
 BN_mod_sqr                              733	1_1_0	EXIST::FUNCTION:
 CAST_ofb64_encrypt                      734	1_1_0	EXIST::FUNCTION:CAST
@@ -761,7 +761,7 @@ ENGINE_get_pkey_meth_engine             742	1_1_0	EXIST::FUNCTION:ENGINE
 OCSP_BASICRESP_free                     743	1_1_0	EXIST::FUNCTION:OCSP
 BN_set_params                           744	1_1_0	EXIST::FUNCTION:DEPRECATEDIN_0_9_8
 BN_add                                  745	1_1_0	EXIST::FUNCTION:
-sk_free                                 746	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_free                         746	1_1_0	EXIST::FUNCTION:
 TS_TST_INFO_get_ext_d2i                 747	1_1_0	EXIST::FUNCTION:TS
 RSA_check_key                           748	1_1_0	EXIST::FUNCTION:RSA
 TS_MSG_IMPRINT_set_algo                 749	1_1_0	EXIST::FUNCTION:TS
@@ -859,7 +859,7 @@ CRYPTO_gcm128_new                       838	1_1_0	EXIST::FUNCTION:
 SMIME_read_PKCS7                        839	1_1_0	EXIST::FUNCTION:
 EC_GROUP_copy                           840	1_1_0	EXIST::FUNCTION:EC
 ENGINE_set_ciphers                      841	1_1_0	EXIST::FUNCTION:ENGINE
-lh_doall_arg                            842	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_doall_arg                    842	1_1_0	EXIST::FUNCTION:
 OCSP_REQUEST_get_ext_by_NID             843	1_1_0	EXIST::FUNCTION:OCSP
 X509_REQ_get_attr_by_NID                844	1_1_0	EXIST::FUNCTION:
 PBE2PARAM_new                           845	1_1_0	EXIST::FUNCTION:
@@ -923,7 +923,7 @@ PKCS7_add_recipient                     899	1_1_0	EXIST::FUNCTION:
 OCSP_SINGLERESP_add_ext                 900	1_1_0	EXIST::FUNCTION:OCSP
 d2i_X509_SIG                            901	1_1_0	EXIST::FUNCTION:
 X509_NAME_set                           902	1_1_0	EXIST::FUNCTION:
-sk_pop                                  903	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_pop                          903	1_1_0	EXIST::FUNCTION:
 ENGINE_register_ciphers                 904	1_1_0	EXIST::FUNCTION:ENGINE
 PKCS5_pbe2_set_iv                       905	1_1_0	EXIST::FUNCTION:
 ASN1_add_stable_module                  906	1_1_0	EXIST::FUNCTION:
@@ -1044,12 +1044,12 @@ i2d_DSA_PUBKEY_fp                       1014	1_1_0	EXIST::FUNCTION:DSA,STDIO
 X509at_get_attr_by_OBJ                  1015	1_1_0	EXIST::FUNCTION:
 EVP_MD_CTX_copy_ex                      1016	1_1_0	EXIST::FUNCTION:
 UI_dup_error_string                     1017	1_1_0	EXIST::FUNCTION:UI
-lh_num_items                            1018	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_num_items                    1018	1_1_0	EXIST::FUNCTION:
 ERR_get_err_state_table                 1019	1_1_0	NOEXIST::FUNCTION:
 ASN1_INTEGER_cmp                        1020	1_1_0	EXIST::FUNCTION:
 X509_NAME_entry_count                   1021	1_1_0	EXIST::FUNCTION:
 UI_method_set_closer                    1022	1_1_0	EXIST::FUNCTION:UI
-lh_get_down_load                        1023	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_get_down_load                1023	1_1_0	EXIST::FUNCTION:
 EVP_md4                                 1024	1_1_0	EXIST::FUNCTION:MD4
 X509_set_subject_name                   1025	1_1_0	EXIST::FUNCTION:
 i2d_PKCS8PrivateKey_nid_bio             1026	1_1_0	EXIST::FUNCTION:
@@ -1103,7 +1103,7 @@ X509_EXTENSION_set_data                 1071	1_1_0	EXIST::FUNCTION:
 ENGINE_get_EC                           1072	1_1_0	EXIST::FUNCTION:ENGINE
 ASN1_STRING_copy                        1073	1_1_0	EXIST::FUNCTION:
 EVP_PKEY_encrypt_old                    1074	1_1_0	EXIST::FUNCTION:
-lh_free                                 1075	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_free                         1075	1_1_0	EXIST::FUNCTION:
 DES_is_weak_key                         1076	1_1_0	EXIST::FUNCTION:DES
 EVP_PKEY_verify                         1077	1_1_0	EXIST::FUNCTION:
 ERR_load_BIO_strings                    1078	1_1_0	EXIST::FUNCTION:
@@ -1241,7 +1241,7 @@ OPENSSL_uni2asc                         1205	1_1_0	EXIST::FUNCTION:
 SCT_validation_status_string            1206	1_1_0	EXIST::FUNCTION:CT
 PKCS7_add_attribute                     1207	1_1_0	EXIST::FUNCTION:
 ENGINE_register_DSA                     1208	1_1_0	EXIST::FUNCTION:ENGINE
-lh_node_stats                           1209	1_1_0	EXIST::FUNCTION:STDIO
+OPENSSL_LH_node_stats                   1209	1_1_0	EXIST::FUNCTION:STDIO
 X509_policy_tree_free                   1210	1_1_0	EXIST::FUNCTION:
 EC_GFp_simple_method                    1211	1_1_0	EXIST::FUNCTION:EC
 X509_it                                 1212	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
@@ -1293,7 +1293,7 @@ EVP_aes_192_gcm                         1255	1_1_0	EXIST::FUNCTION:
 TS_CONF_set_tsa_name                    1256	1_1_0	EXIST::FUNCTION:TS
 X509_email_free                         1257	1_1_0	EXIST::FUNCTION:
 BIO_get_callback                        1258	1_1_0	EXIST::FUNCTION:
-sk_shift                                1259	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_shift                        1259	1_1_0	EXIST::FUNCTION:
 i2d_X509_REVOKED                        1260	1_1_0	EXIST::FUNCTION:
 CMS_sign                                1261	1_1_0	EXIST::FUNCTION:CMS
 X509_STORE_add_cert                     1262	1_1_0	EXIST::FUNCTION:
@@ -1388,7 +1388,7 @@ BIO_f_linebuffer                        1346	1_1_0	EXIST::FUNCTION:
 ASN1_item_d2i_bio                       1347	1_1_0	EXIST::FUNCTION:
 ENGINE_get_flags                        1348	1_1_0	EXIST::FUNCTION:ENGINE
 OCSP_resp_find                          1349	1_1_0	EXIST::FUNCTION:OCSP
-lh_node_usage_stats_bio                 1350	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_node_usage_stats_bio         1350	1_1_0	EXIST::FUNCTION:
 EVP_PKEY_encrypt                        1351	1_1_0	EXIST::FUNCTION:
 CRYPTO_cfb128_8_encrypt                 1352	1_1_0	EXIST::FUNCTION:
 SXNET_get_id_INTEGER                    1353	1_1_0	EXIST::FUNCTION:
@@ -1410,7 +1410,7 @@ d2i_X509_VAL                            1368	1_1_0	EXIST::FUNCTION:
 _shadow_DES_rw_mode                     1369	1_1_0	NOEXIST::FUNCTION:
 CRYPTO_gcm128_decrypt_ctr32             1370	1_1_0	EXIST::FUNCTION:
 DHparams_print                          1371	1_1_0	EXIST::FUNCTION:DH
-sk_unshift                              1372	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_unshift                      1372	1_1_0	EXIST::FUNCTION:
 BN_GENCB_set_old                        1373	1_1_0	EXIST::FUNCTION:
 PEM_write_bio_X509                      1374	1_1_0	EXIST::FUNCTION:
 EVP_PKEY_asn1_free                      1375	1_1_0	EXIST::FUNCTION:
@@ -1606,7 +1606,7 @@ EVP_MD_meth_set_app_datasize            1560	1_1_0	EXIST::FUNCTION:
 DSO_free                                1561	1_1_0	EXIST::FUNCTION:
 TS_TST_INFO_get_tsa                     1562	1_1_0	EXIST::FUNCTION:TS
 EC_GROUP_check                          1563	1_1_0	EXIST::FUNCTION:EC
-sk_delete                               1564	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_delete                       1564	1_1_0	EXIST::FUNCTION:
 TS_RESP_CTX_set_extension_cb            1565	1_1_0	EXIST::FUNCTION:TS
 EVP_CIPHER_CTX_nid                      1566	1_1_0	EXIST::FUNCTION:
 TS_RESP_CTX_add_md                      1567	1_1_0	EXIST::FUNCTION:TS
@@ -1797,7 +1797,7 @@ EVP_PKEY_CTX_hex2ctrl                   1747	1_1_0	EXIST::FUNCTION:
 PEM_write_bio_PKCS8PrivateKey           1748	1_1_0	EXIST::FUNCTION:
 CMAC_Update                             1749	1_1_0	EXIST::FUNCTION:CMAC
 d2i_ASN1_UTCTIME                        1750	1_1_0	EXIST::FUNCTION:
-sk_insert                               1751	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_insert                       1751	1_1_0	EXIST::FUNCTION:
 DSO_up_ref                              1752	1_1_0	EXIST::FUNCTION:
 EVP_rc2_cbc                             1753	1_1_0	EXIST::FUNCTION:RC2
 i2d_NETSCAPE_SPKI                       1754	1_1_0	EXIST::FUNCTION:
@@ -1861,7 +1861,7 @@ ASN1_BIT_STRING_new                     1808	1_1_0	EXIST::FUNCTION:
 BIO_new_file                            1809	1_1_0	EXIST::FUNCTION:
 PKCS7_SIGNER_INFO_get0_algs             1810	1_1_0	EXIST::FUNCTION:
 TS_RESP_set_status_info                 1811	1_1_0	EXIST::FUNCTION:TS
-lh_delete                               1812	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_delete                       1812	1_1_0	EXIST::FUNCTION:
 TS_STATUS_INFO_dup                      1813	1_1_0	EXIST::FUNCTION:TS
 X509v3_addr_get_range                   1814	1_1_0	EXIST::FUNCTION:RFC3779
 X509_EXTENSION_get_data                 1815	1_1_0	EXIST::FUNCTION:
@@ -1876,7 +1876,7 @@ X509_get_ext_by_critical                1823	1_1_0	EXIST::FUNCTION:
 ASYNC_WAIT_CTX_clear_fd                 1824	1_1_0	EXIST::FUNCTION:
 ZLONG_it                                1825	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 ZLONG_it                                1825	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
-sk_find_ex                              1826	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_find_ex                      1826	1_1_0	EXIST::FUNCTION:
 ASN1_ENUMERATED_to_BN                   1827	1_1_0	EXIST::FUNCTION:
 X509_CRL_get_ext_d2i                    1828	1_1_0	EXIST::FUNCTION:
 i2d_AUTHORITY_KEYID                     1829	1_1_0	EXIST::FUNCTION:
@@ -1888,7 +1888,7 @@ ASN1_STRING_to_UTF8                     1833	1_1_0	EXIST::FUNCTION:
 DSO_METHOD_null                         1834	1_1_0	NOEXIST::FUNCTION:
 EVP_MD_meth_set_update                  1835	1_1_0	EXIST::FUNCTION:
 EVP_camellia_192_cbc                    1836	1_1_0	EXIST::FUNCTION:CAMELLIA
-lh_stats_bio                            1837	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_stats_bio                    1837	1_1_0	EXIST::FUNCTION:
 PKCS7_set_signed_attributes             1838	1_1_0	EXIST::FUNCTION:
 EC_KEY_priv2buf                         1839	1_1_0	EXIST::FUNCTION:EC
 BN_BLINDING_free                        1840	1_1_0	EXIST::FUNCTION:
@@ -1968,7 +1968,7 @@ SRP_Calc_B                              1910	1_1_0	EXIST::FUNCTION:SRP
 CMS_decrypt_set1_key                    1911	1_1_0	EXIST::FUNCTION:CMS
 EC_GROUP_get_degree                     1912	1_1_0	EXIST::FUNCTION:EC
 X509_ALGOR_set0                         1913	1_1_0	EXIST::FUNCTION:
-lh_set_down_load                        1914	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_set_down_load                1914	1_1_0	EXIST::FUNCTION:
 X509v3_asid_inherits                    1915	1_1_0	EXIST::FUNCTION:RFC3779
 EVP_MD_meth_get_app_datasize            1916	1_1_0	EXIST::FUNCTION:
 X509_STORE_CTX_get_num_untrusted        1917	1_1_0	EXIST::FUNCTION:
@@ -2067,7 +2067,7 @@ TS_REQ_get_version                      2006	1_1_0	EXIST::FUNCTION:TS
 BN_exp                                  2007	1_1_0	EXIST::FUNCTION:
 i2d_SXNET                               2008	1_1_0	EXIST::FUNCTION:
 OBJ_bsearch_                            2009	1_1_0	EXIST::FUNCTION:
-lh_new                                  2010	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_new                          2010	1_1_0	EXIST::FUNCTION:
 ENGINE_register_all_pkey_meths          2011	1_1_0	EXIST::FUNCTION:ENGINE
 ENGINE_get_init_function                2012	1_1_0	EXIST::FUNCTION:ENGINE
 EC_POINT_point2hex                      2013	1_1_0	EXIST::FUNCTION:EC
@@ -2080,7 +2080,7 @@ i2d_TS_REQ_fp                           2019	1_1_0	EXIST::FUNCTION:STDIO,TS
 i2d_OTHERNAME                           2020	1_1_0	EXIST::FUNCTION:
 EC_KEY_get0_private_key                 2021	1_1_0	EXIST::FUNCTION:EC
 SCT_get0_extensions                     2022	1_1_0	EXIST::FUNCTION:CT
-lh_node_stats_bio                       2023	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_node_stats_bio               2023	1_1_0	EXIST::FUNCTION:
 i2d_DIRECTORYSTRING                     2024	1_1_0	EXIST::FUNCTION:
 BN_X931_derive_prime_ex                 2025	1_1_0	EXIST::FUNCTION:
 ENGINE_get_pkey_asn1_meth_str           2026	1_1_0	EXIST::FUNCTION:ENGINE
@@ -2093,7 +2093,7 @@ UI_construct_prompt                     2032	1_1_0	EXIST::FUNCTION:UI
 ENGINE_unregister_RSA                   2033	1_1_0	EXIST::FUNCTION:ENGINE
 EC_GROUP_order_bits                     2034	1_1_0	EXIST::FUNCTION:EC
 d2i_CMS_bio                             2035	1_1_0	EXIST::FUNCTION:CMS
-sk_num                                  2036	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_num                          2036	1_1_0	EXIST::FUNCTION:
 _shadow_DES_check_key                   2037	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:DES
 _shadow_DES_check_key                   2037	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:DES
 CMS_RecipientInfo_set0_pkey             2038	1_1_0	EXIST::FUNCTION:CMS
@@ -2227,7 +2227,7 @@ PEM_write_X509                          2158	1_1_0	EXIST::FUNCTION:
 BN_CTX_free                             2159	1_1_0	EXIST::FUNCTION:
 EC_GROUP_get_curve_GF2m                 2160	1_1_0	EXIST::FUNCTION:EC,EC2M
 EVP_MD_flags                            2161	1_1_0	EXIST::FUNCTION:
-sk_set                                  2162	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_set                          2162	1_1_0	EXIST::FUNCTION:
 OCSP_request_sign                       2163	1_1_0	EXIST::FUNCTION:OCSP
 BN_GF2m_mod_solve_quad                  2164	1_1_0	EXIST::FUNCTION:EC2M
 EC_POINT_method_of                      2165	1_1_0	EXIST::FUNCTION:EC
@@ -2282,7 +2282,7 @@ i2d_TS_ACCURACY                         2210	1_1_0	EXIST::FUNCTION:TS
 ASN1_VISIBLESTRING_free                 2211	1_1_0	EXIST::FUNCTION:
 NCONF_load_bio                          2212	1_1_0	EXIST::FUNCTION:
 DSA_get_default_method                  2213	1_1_0	EXIST::FUNCTION:DSA
-lh_retrieve                             2214	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_retrieve                     2214	1_1_0	EXIST::FUNCTION:
 CRYPTO_ccm128_decrypt_ccm64             2215	1_1_0	EXIST::FUNCTION:
 TS_RESP_CTX_set_clock_precision_digits  2216	1_1_0	EXIST::FUNCTION:TS
 SCT_LIST_validate                       2217	1_1_0	EXIST::FUNCTION:CT
@@ -2326,7 +2326,7 @@ CMS_signed_get_attr_by_NID              2253	1_1_0	EXIST::FUNCTION:CMS
 X509_STORE_CTX_get_by_subject           2254	1_1_0	EXIST::FUNCTION:
 ASN1_OCTET_STRING_it                    2255	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 ASN1_OCTET_STRING_it                    2255	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
-sk_set_cmp_func                         2256	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_set_cmp_func                 2256	1_1_0	EXIST::FUNCTION:
 X509_VERIFY_PARAM_table_cleanup         2257	1_1_0	EXIST::FUNCTION:
 i2d_re_X509_REQ_tbs                     2258	1_1_0	EXIST::FUNCTION:
 CONF_load_bio                           2259	1_1_0	EXIST::FUNCTION:
@@ -2408,7 +2408,7 @@ EVP_aes_256_xts                         2333	1_1_0	EXIST::FUNCTION:
 EVP_DigestSignFinal                     2334	1_1_0	EXIST::FUNCTION:
 ASN1_STRING_cmp                         2335	1_1_0	EXIST::FUNCTION:
 EVP_chacha20_poly1305                   2336	1_1_0	EXIST::FUNCTION:CHACHA,POLY1305
-sk_zero                                 2337	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_zero                         2337	1_1_0	EXIST::FUNCTION:
 ASN1_PRINTABLE_type                     2338	1_1_0	EXIST::FUNCTION:
 TS_CONF_set_ess_cert_id_chain           2339	1_1_0	EXIST::FUNCTION:TS
 PEM_read_DSAPrivateKey                  2340	1_1_0	EXIST::FUNCTION:DSA
@@ -2651,7 +2651,7 @@ EVP_sha256                              2569	1_1_0	EXIST::FUNCTION:
 CMS_unsigned_delete_attr                2570	1_1_0	EXIST::FUNCTION:CMS
 EVP_md5_sha1                            2571	1_1_0	EXIST::FUNCTION:MD5
 EVP_PKEY_sign_init                      2572	1_1_0	EXIST::FUNCTION:
-lh_insert                               2573	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_insert                       2573	1_1_0	EXIST::FUNCTION:
 EVP_CIPHER_meth_get_cleanup             2574	1_1_0	EXIST::FUNCTION:
 ASN1_item_ex_d2i                        2575	1_1_0	EXIST::FUNCTION:
 EVP_MD_meth_free                        2576	1_1_0	EXIST::FUNCTION:
@@ -2692,7 +2692,7 @@ EVP_DecodeUpdate                        2609	1_1_0	EXIST::FUNCTION:
 ENGINE_get_default_RAND                 2610	1_1_0	EXIST::FUNCTION:ENGINE
 ERR_peek_last_error_line                2611	1_1_0	EXIST::FUNCTION:
 ENGINE_get_ssl_client_cert_function     2612	1_1_0	EXIST::FUNCTION:ENGINE
-lh_node_usage_stats                     2613	1_1_0	EXIST::FUNCTION:STDIO
+OPENSSL_LH_node_usage_stats             2613	1_1_0	EXIST::FUNCTION:STDIO
 DIRECTORYSTRING_it                      2614	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 DIRECTORYSTRING_it                      2614	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 BIO_write                               2615	1_1_0	EXIST::FUNCTION:
@@ -2740,7 +2740,7 @@ EVP_aes_256_cbc_hmac_sha1               2652	1_1_0	EXIST::FUNCTION:
 SCT_validate                            2653	1_1_0	EXIST::FUNCTION:CT
 EC_GROUP_dup                            2654	1_1_0	EXIST::FUNCTION:EC
 EVP_sha1                                2655	1_1_0	EXIST::FUNCTION:
-sk_new                                  2656	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_new                          2656	1_1_0	EXIST::FUNCTION:
 BN_dup                                  2657	1_1_0	EXIST::FUNCTION:
 TS_MSG_IMPRINT_print_bio                2658	1_1_0	EXIST::FUNCTION:TS
 CONF_module_set_usr_data                2659	1_1_0	EXIST::FUNCTION:
@@ -2872,7 +2872,7 @@ RSAPrivateKey_it                        2777	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:
 X509_NAME_ENTRY_free                    2778	1_1_0	EXIST::FUNCTION:
 BIO_new_fd                              2779	1_1_0	EXIST::FUNCTION:
 ENGINE_cleanup                          2780	1_1_0	NOEXIST::FUNCTION:
-sk_value                                2781	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_value                        2781	1_1_0	EXIST::FUNCTION:
 NCONF_get_section                       2782	1_1_0	EXIST::FUNCTION:
 PKCS12_MAC_DATA_it                      2783	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 PKCS12_MAC_DATA_it                      2783	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
@@ -3219,7 +3219,7 @@ i2s_ASN1_ENUMERATED                     3112	1_1_0	EXIST::FUNCTION:
 X509v3_get_ext_by_OBJ                   3113	1_1_0	EXIST::FUNCTION:
 OCSP_REQUEST_free                       3114	1_1_0	EXIST::FUNCTION:OCSP
 CRYPTO_ocb128_aad                       3115	1_1_0	EXIST::FUNCTION:OCB
-sk_deep_copy                            3116	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_deep_copy                    3116	1_1_0	EXIST::FUNCTION:
 i2d_RSA_PSS_PARAMS                      3117	1_1_0	EXIST::FUNCTION:RSA
 EVP_aes_128_wrap_pad                    3118	1_1_0	EXIST::FUNCTION:
 ASN1_BIT_STRING_set                     3119	1_1_0	EXIST::FUNCTION:
@@ -3247,10 +3247,10 @@ TXT_DB_free                             3139	1_1_0	EXIST::FUNCTION:
 ASN1_STRING_set                         3140	1_1_0	EXIST::FUNCTION:
 d2i_ESS_CERT_ID                         3141	1_1_0	EXIST::FUNCTION:TS
 EVP_PKEY_meth_set_derive                3142	1_1_0	EXIST::FUNCTION:
-lh_stats                                3143	1_1_0	EXIST::FUNCTION:STDIO
+OPENSSL_LH_stats                        3143	1_1_0	EXIST::FUNCTION:STDIO
 NCONF_dump_fp                           3144	1_1_0	EXIST::FUNCTION:STDIO
 TS_STATUS_INFO_print_bio                3145	1_1_0	EXIST::FUNCTION:TS
-sk_dup                                  3146	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_dup                          3146	1_1_0	EXIST::FUNCTION:
 BF_cfb64_encrypt                        3147	1_1_0	EXIST::FUNCTION:BF
 ASN1_GENERALIZEDTIME_adj                3148	1_1_0	EXIST::FUNCTION:
 ECDSA_verify                            3149	1_1_0	EXIST::FUNCTION:EC
@@ -3391,7 +3391,7 @@ CRYPTO_set_mem_debug                    3282	1_1_0	EXIST::FUNCTION:
 TS_VERIFY_CTX_init                      3283	1_1_0	EXIST::FUNCTION:TS
 OCSP_cert_id_new                        3284	1_1_0	EXIST::FUNCTION:OCSP
 GENERAL_SUBTREE_new                     3285	1_1_0	EXIST::FUNCTION:
-sk_push                                 3286	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_push                         3286	1_1_0	EXIST::FUNCTION:
 X509_LOOKUP_ctrl                        3287	1_1_0	EXIST::FUNCTION:
 SRP_check_known_gN_param                3288	1_1_0	EXIST::FUNCTION:SRP
 d2i_DIST_POINT                          3289	1_1_0	EXIST::FUNCTION:
@@ -3411,7 +3411,7 @@ DSA_SIG_free                            3301	1_1_0	EXIST::FUNCTION:DSA
 BIO_asn1_set_suffix                     3302	1_1_0	EXIST::FUNCTION:
 EVP_PKEY_set_type_str                   3303	1_1_0	EXIST::FUNCTION:
 i2d_X509_SIG                            3304	1_1_0	EXIST::FUNCTION:
-lh_strhash                              3305	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_strhash                      3305	1_1_0	EXIST::FUNCTION:
 X509_STORE_CTX_set_trust                3306	1_1_0	EXIST::FUNCTION:
 TS_ACCURACY_set_micros                  3307	1_1_0	EXIST::FUNCTION:TS
 EVP_DigestFinal_ex                      3308	1_1_0	EXIST::FUNCTION:
@@ -3460,7 +3460,7 @@ ASN1_SEQUENCE_ANY_it                    3350	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION
 ASN1_SEQUENCE_ANY_it                    3350	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 ASN1_UTCTIME_adj                        3351	1_1_0	EXIST::FUNCTION:
 BN_mod_sqrt                             3352	1_1_0	EXIST::FUNCTION:
-sk_is_sorted                            3353	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_is_sorted                    3353	1_1_0	EXIST::FUNCTION:
 OCSP_SIGNATURE_new                      3354	1_1_0	EXIST::FUNCTION:OCSP
 EVP_PKEY_meth_get_paramgen              3355	1_1_0	EXIST::FUNCTION:
 X509_ATTRIBUTE_create_by_OBJ            3356	1_1_0	EXIST::FUNCTION:
@@ -3488,7 +3488,7 @@ PKCS12_PBE_add                          3376	1_1_0	EXIST::FUNCTION:
 EC_KEY_set_public_key_affine_coordinates 3377	1_1_0	EXIST::FUNCTION:EC
 EVP_EncryptInit_ex                      3378	1_1_0	EXIST::FUNCTION:
 ENGINE_add                              3379	1_1_0	EXIST::FUNCTION:ENGINE
-lh_error                                3380	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_error                        3380	1_1_0	EXIST::FUNCTION:
 PKCS7_DIGEST_it                         3381	1_1_0	EXIST:!EXPORT_VAR_AS_FUNCTION:VARIABLE:
 PKCS7_DIGEST_it                         3381	1_1_0	EXIST:EXPORT_VAR_AS_FUNCTION:FUNCTION:
 X509_CINF_new                           3382	1_1_0	EXIST::FUNCTION:
@@ -3839,7 +3839,7 @@ X509_VERIFY_PARAM_free                  3721	1_1_0	EXIST::FUNCTION:
 ASN1_TYPE_new                           3722	1_1_0	EXIST::FUNCTION:
 CMAC_CTX_cleanup                        3723	1_1_0	EXIST::FUNCTION:CMAC
 i2d_PKCS7_NDEF                          3724	1_1_0	EXIST::FUNCTION:
-sk_pop_free                             3725	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_pop_free                     3725	1_1_0	EXIST::FUNCTION:
 X509_STORE_CTX_get0_policy_tree         3726	1_1_0	EXIST::FUNCTION:
 DES_set_key_checked                     3727	1_1_0	EXIST::FUNCTION:DES
 EVP_PKEY_meth_free                      3728	1_1_0	EXIST::FUNCTION:
@@ -4001,7 +4001,7 @@ X509_get_default_cert_dir               3875	1_1_0	EXIST::FUNCTION:
 DSO_get_method                          3876	1_1_0	NOEXIST::FUNCTION:
 PROXY_POLICY_free                       3877	1_1_0	EXIST::FUNCTION:
 PEM_write_DSAPrivateKey                 3878	1_1_0	EXIST::FUNCTION:DSA
-sk_delete_ptr                           3879	1_1_0	EXIST::FUNCTION:
+OPENSSL_sk_delete_ptr                   3879	1_1_0	EXIST::FUNCTION:
 CMS_add0_RevocationInfoChoice           3880	1_1_0	EXIST::FUNCTION:CMS
 ASN1_PCTX_get_flags                     3881	1_1_0	EXIST::FUNCTION:
 EVP_MD_meth_set_result_size             3882	1_1_0	EXIST::FUNCTION:
@@ -4030,7 +4030,7 @@ EVP_PKEY_verify_recover_init            3902	1_1_0	EXIST::FUNCTION:
 SHA512_Init                             3903	1_1_0	EXIST:!VMSVAX:FUNCTION:
 TS_MSG_IMPRINT_set_msg                  3904	1_1_0	EXIST::FUNCTION:TS
 CMS_unsigned_add1_attr                  3905	1_1_0	EXIST::FUNCTION:CMS
-lh_doall                                3906	1_1_0	EXIST::FUNCTION:
+OPENSSL_LH_doall                        3906	1_1_0	EXIST::FUNCTION:
 PKCS8_pkey_get0_attrs                   3907	1_1_0	EXIST::FUNCTION:
 PKCS8_pkey_add1_attr_by_NID             3908	1_1_0	EXIST::FUNCTION:
 ASYNC_is_capable                        3909	1_1_0	EXIST::FUNCTION:
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007426.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="007439.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7428">[ date ]</a>
              <a href="thread.html#7428">[ thread ]</a>
              <a href="subject.html#7428">[ subject ]</a>
              <a href="author.html#7428">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
