<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2018-January/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1515358332.248827.14572.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017452.html">
   <LINK REL="Next"  HREF="017454.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Andy Polyakov</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1515358332.248827.14572.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">appro at openssl.org
       </A><BR>
    <I>Sun Jan  7 20:52:12 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="017452.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="017454.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17453">[ date ]</a>
              <a href="thread.html#17453">[ thread ]</a>
              <a href="subject.html#17453">[ subject ]</a>
              <a href="author.html#17453">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  96530eea93d27e536f4e93956256cf8dcda7d469 (commit)
       via  e21a84308c02df63715f8867beb4a2b1036bcb35 (commit)
       via  1c3a23e44648524755b74595ad816f5cc881102c (commit)
      from  26b05245f0d3a6cea970f104f6aff388948fe318 (commit)


- Log -----------------------------------------------------------------
commit 96530eea93d27e536f4e93956256cf8dcda7d469
Author: Patrick Steuer &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">patrick.steuer at de.ibm.com</A>&gt;
Date:   Mon Oct 2 15:53:00 2017 +0200

    s390x assembly pack: add KMA code path for aes-gcm.
    
    Signed-off-by: Patrick Steuer &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">patrick.steuer at de.ibm.com</A>&gt;
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/4634">https://github.com/openssl/openssl/pull/4634</A>)

commit e21a84308c02df63715f8867beb4a2b1036bcb35
Author: Patrick Steuer &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">patrick.steuer at de.ibm.com</A>&gt;
Date:   Tue Oct 24 13:29:40 2017 +0200

    crypto/aes/asm/aes-s390x.pl: replace decrypt flag by macro.
    
    Signed-off-by: Patrick Steuer &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">patrick.steuer at de.ibm.com</A>&gt;
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/4634">https://github.com/openssl/openssl/pull/4634</A>)

commit 1c3a23e44648524755b74595ad816f5cc881102c
Author: Patrick Steuer &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">patrick.steuer at de.ibm.com</A>&gt;
Date:   Tue Feb 14 02:07:37 2017 +0100

    s390x assembly pack: add KMA code path for aes-ctr.
    
    Signed-off-by: Patrick Steuer &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">patrick.steuer at de.ibm.com</A>&gt;
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/4634">https://github.com/openssl/openssl/pull/4634</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/aes/asm/aes-s390x.pl            |  60 ++-
 crypto/build.info                      |   2 +
 crypto/evp/e_aes.c                     | 735 +++++++++++++++++++++++++++++++++
 crypto/s390x_arch.h                    |  11 +
 crypto/{s390xcpuid.S =&gt; s390xcpuid.pl} | 127 ++++--
 5 files changed, 904 insertions(+), 31 deletions(-)
 rename crypto/{s390xcpuid.S =&gt; s390xcpuid.pl} (66%)
 mode change 100644 =&gt; 100755

diff --git a/crypto/aes/asm/aes-s390x.pl b/crypto/aes/asm/aes-s390x.pl
index 0ef1f6b..bab5662 100644
--- a/crypto/aes/asm/aes-s390x.pl
+++ b/crypto/aes/asm/aes-s390x.pl
@@ -1086,7 +1086,7 @@ $code.=&lt;&lt;___ if (!$softonly);
 	lhi	$t1,16
 	cr	$t0,$t1
 	jl	.Lgo
-	oill	$t0,0x80	# set &quot;decrypt&quot; bit
+	oill	$t0,S390X_DECRYPT	# set &quot;decrypt&quot; bit
 	st	$t0,240($key)
 	br	$ra
 ___
@@ -1225,7 +1225,7 @@ $code.=&lt;&lt;___ if (!$softonly);
 .align	16
 .Lkmc_truncated:
 	ahi	$key,-1		# it's the way it's encoded in mvc
-	tmll	%r0,0x80
+	tmll	%r0,S390X_DECRYPT
 	jnz	.Lkmc_truncated_dec
 	lghi	%r1,0
 	stg	%r1,16*$SIZE_T($sp)
@@ -1405,7 +1405,61 @@ $code.=&lt;&lt;___ if (!$softonly);
 	clr	%r0,%r1
 	jl	.Lctr32_software
 
-	stm${g}	%r6,$s3,6*$SIZE_T($sp)
+	st${g}	$s2,10*$SIZE_T($sp)
+	st${g}	$s3,11*$SIZE_T($sp)
+
+	clr	$len,%r1		# does work even in 64-bit mode
+	jle	.Lctr32_nokma		# kma is slower for &lt;= 16 blocks
+
+	larl	%r1,OPENSSL_s390xcap_P
+	lr	$s2,%r0
+	llihh	$s3,0x8000
+	srlg	$s3,$s3,0($s2)
+	ng	$s3,S390X_KMA(%r1)		# check kma capability vector
+	jz	.Lctr32_nokma
+
+	l${g}hi	%r1,-$stdframe-112
+	l${g}r	$s3,$sp
+	la	$sp,0(%r1,$sp)			# prepare parameter block
+
+	lhi	%r1,0x0600
+	sllg	$len,$len,4
+	or	%r0,%r1				# set HS and LAAD flags
+
+	st${g}	$s3,0($sp)			# backchain
+	la	%r1,$stdframe($sp)
+
+	lmg	$s2,$s3,0($key)			# copy key
+	stg	$s2,$stdframe+80($sp)
+	stg	$s3,$stdframe+88($sp)
+	lmg	$s2,$s3,16($key)
+	stg	$s2,$stdframe+96($sp)
+	stg	$s3,$stdframe+104($sp)
+
+	lmg	$s2,$s3,0($ivp)			# copy iv
+	stg	$s2,$stdframe+64($sp)
+	ahi	$s3,-1				# kma requires counter-1
+	stg	$s3,$stdframe+72($sp)
+	st	$s3,$stdframe+12($sp)		# copy counter
+
+	lghi	$s2,0				# no AAD
+	lghi	$s3,0
+
+	.long	0xb929a042	# kma $out,$s2,$inp
+	brc	1,.-4		# pay attention to &quot;partial completion&quot;
+
+	stg	%r0,$stdframe+80($sp)		# wipe key
+	stg	%r0,$stdframe+88($sp)
+	stg	%r0,$stdframe+96($sp)
+	stg	%r0,$stdframe+104($sp)
+	la	$sp,$stdframe+112($sp)
+
+	lm${g}	$s2,$s3,10*$SIZE_T($sp)
+	br	$ra
+
+.align	16
+.Lctr32_nokma:
+	stm${g}	%r6,$s1,6*$SIZE_T($sp)
 
 	slgr	$out,$inp
 	la	%r1,0($key)	# %r1 is permanent copy of $key
diff --git a/crypto/build.info b/crypto/build.info
index 983708a..0d34750 100644
--- a/crypto/build.info
+++ b/crypto/build.info
@@ -31,6 +31,8 @@ GENERATE[arm64cpuid.S]=arm64cpuid.pl $(PERLASM_SCHEME)
 INCLUDE[arm64cpuid.o]=.
 GENERATE[armv4cpuid.S]=armv4cpuid.pl $(PERLASM_SCHEME)
 INCLUDE[armv4cpuid.o]=.
+GENERATE[s390xcpuid.S]=s390xcpuid.pl $(PERLASM_SCHEME)
+INCLUDE[s390xcpuid.o]=.
 
 IF[{- $config{target} =~ /^(?:Cygwin|mingw|VC-)/ -}]
   SHARED_SOURCE[../libcrypto]=dllmain.c
diff --git a/crypto/evp/e_aes.c b/crypto/evp/e_aes.c
index 802b1d8..3986a48 100644
--- a/crypto/evp/e_aes.c
+++ b/crypto/evp/e_aes.c
@@ -950,6 +950,741 @@ static const EVP_CIPHER aes_##keylen##_##mode = { \
 const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
 { return SPARC_AES_CAPABLE?&amp;aes_t4_##keylen##_##mode:&amp;aes_##keylen##_##mode; }
 
+#elif defined(OPENSSL_CPUID_OBJ) &amp;&amp; defined(__s390__)
+/*
+ * IBM S390X support
+ */
+# include &quot;s390x_arch.h&quot;
+
+typedef struct {
+    union {
+        double align;
+        /*-
+         * KMA-GCM-AES parameter block
+         * (see z/Architecture Principles of Operation SA22-7832-11)
+         */
+        struct {
+            unsigned char reserved[12];
+            union {
+                unsigned int w;
+                unsigned char b[4];
+            } cv;
+            union {
+                unsigned long long g[2];
+                unsigned char b[16];
+            } t;
+            unsigned char h[16];
+            unsigned long long taadl;
+            unsigned long long tpcl;
+            union {
+                unsigned long long g[2];
+                unsigned int w[4];
+            } j0;
+            unsigned char k[32];
+        } param;
+    } kma;
+    unsigned int fc;
+    int key_set;
+
+    unsigned char *iv;
+    int ivlen;
+    int iv_set;
+    int iv_gen;
+
+    int taglen;
+
+    unsigned char ares[16];
+    unsigned char mres[16];
+    unsigned char kres[16];
+    int areslen;
+    int mreslen;
+    int kreslen;
+
+    int tls_aad_len;
+} S390X_AES_GCM_CTX;
+
+# define S390X_aes_128_CAPABLE ((OPENSSL_s390xcap_P.km[0] &amp;	\
+                                 S390X_CAPBIT(S390X_AES_128)) &amp;&amp;\
+                                (OPENSSL_s390xcap_P.kmc[0] &amp;	\
+                                 S390X_CAPBIT(S390X_AES_128)))
+# define S390X_aes_192_CAPABLE ((OPENSSL_s390xcap_P.km[0] &amp;	\
+                                 S390X_CAPBIT(S390X_AES_192)) &amp;&amp;\
+                                (OPENSSL_s390xcap_P.kmc[0] &amp;	\
+                                 S390X_CAPBIT(S390X_AES_192)))
+# define S390X_aes_256_CAPABLE ((OPENSSL_s390xcap_P.km[0] &amp;	\
+                                 S390X_CAPBIT(S390X_AES_256)) &amp;&amp;\
+                                (OPENSSL_s390xcap_P.kmc[0] &amp;	\
+                                 S390X_CAPBIT(S390X_AES_256)))
+
+# define s390x_aes_init_key aes_init_key
+static int s390x_aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+                              const unsigned char *iv, int enc);
+
+# define S390X_aes_128_cbc_CAPABLE	1	/* checked by callee */
+# define S390X_aes_192_cbc_CAPABLE	1
+# define S390X_aes_256_cbc_CAPABLE	1
+
+# define s390x_aes_cbc_cipher aes_cbc_cipher
+static int s390x_aes_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                const unsigned char *in, size_t len);
+
+# define S390X_aes_128_ecb_CAPABLE	0
+# define S390X_aes_192_ecb_CAPABLE	0
+# define S390X_aes_256_ecb_CAPABLE	0
+
+# define s390x_aes_ecb_cipher aes_ecb_cipher
+static int s390x_aes_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                const unsigned char *in, size_t len);
+
+# define S390X_aes_128_ofb_CAPABLE	0
+# define S390X_aes_192_ofb_CAPABLE	0
+# define S390X_aes_256_ofb_CAPABLE	0
+
+# define s390x_aes_ofb_cipher aes_ofb_cipher
+static int s390x_aes_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                const unsigned char *in, size_t len);
+
+# define S390X_aes_128_cfb_CAPABLE	0
+# define S390X_aes_192_cfb_CAPABLE	0
+# define S390X_aes_256_cfb_CAPABLE	0
+
+# define s390x_aes_cfb_cipher aes_cfb_cipher
+static int s390x_aes_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                const unsigned char *in, size_t len);
+
+# define S390X_aes_128_cfb8_CAPABLE	0
+# define S390X_aes_192_cfb8_CAPABLE	0
+# define S390X_aes_256_cfb8_CAPABLE	0
+
+# define s390x_aes_cfb8_cipher aes_cfb8_cipher
+static int s390x_aes_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                 const unsigned char *in, size_t len);
+
+# define S390X_aes_128_cfb1_CAPABLE	0
+# define S390X_aes_192_cfb1_CAPABLE	0
+# define S390X_aes_256_cfb1_CAPABLE	0
+
+# define s390x_aes_cfb1_cipher aes_cfb1_cipher
+static int s390x_aes_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                 const unsigned char *in, size_t len);
+
+# define S390X_aes_128_ctr_CAPABLE	1	/* checked by callee */
+# define S390X_aes_192_ctr_CAPABLE	1
+# define S390X_aes_256_ctr_CAPABLE	1
+
+# define s390x_aes_ctr_cipher aes_ctr_cipher
+static int s390x_aes_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                const unsigned char *in, size_t len);
+
+# define S390X_aes_128_gcm_CAPABLE (S390X_aes_128_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kma[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_128)))
+# define S390X_aes_192_gcm_CAPABLE (S390X_aes_192_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kma[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_192)))
+# define S390X_aes_256_gcm_CAPABLE (S390X_aes_256_CAPABLE &amp;&amp;		\
+                                    (OPENSSL_s390xcap_P.kma[0] &amp;	\
+                                     S390X_CAPBIT(S390X_AES_256)))
+
+/* iv + padding length for iv lenghts != 12 */
+# define S390X_gcm_ivpadlen(i)	((((i) + 15) &gt;&gt; 4 &lt;&lt; 4) + 16)
+
+static int s390x_aes_gcm_aad(S390X_AES_GCM_CTX *ctx, const unsigned char *aad,
+                             size_t len)
+{
+    unsigned long long alen;
+    int n, rem;
+
+    if (ctx-&gt;kma.param.tpcl)
+        return -2;
+
+    alen = ctx-&gt;kma.param.taadl + len;
+    if (alen &gt; (U64(1) &lt;&lt; 61) || (sizeof(len) == 8 &amp;&amp; alen &lt; len))
+        return -1;
+    ctx-&gt;kma.param.taadl = alen;
+
+    n = ctx-&gt;areslen;
+    if (n) {
+        while (n &amp;&amp; len) {
+            ctx-&gt;ares[n] = *aad;
+            n = (n + 1) &amp; 0xf;
+            ++aad;
+            --len;
+        }
+        /* ctx-&gt;ares contains a complete block if offset has wrapped around */
+        if (!n) {
+            s390x_kma(ctx-&gt;ares, 16, NULL, 0, NULL, ctx-&gt;fc, &amp;ctx-&gt;kma.param);
+            ctx-&gt;fc |= S390X_KMA_HS;
+        }
+        ctx-&gt;areslen = n;
+    }
+
+    rem = len &amp; 0xf;
+
+    len &amp;= ~0xf;
+    if (len) {
+        s390x_kma(aad, len, NULL, 0, NULL, ctx-&gt;fc, &amp;ctx-&gt;kma.param);
+        aad += len;
+        ctx-&gt;fc |= S390X_KMA_HS;
+    }
+
+    if (rem) {
+        ctx-&gt;areslen = rem;
+
+        do {
+            --rem;
+            ctx-&gt;ares[rem] = aad[rem];
+        } while (rem);
+    }
+    return 0;
+}
+
+static int s390x_aes_gcm(S390X_AES_GCM_CTX *ctx, const unsigned char *in,
+                         unsigned char *out, size_t len)
+{
+    const unsigned char *inptr;
+    unsigned long long mlen;
+    union {
+        unsigned int w[4];
+        unsigned char b[16];
+    } buf;
+    size_t inlen;
+    int n, rem, i;
+
+    mlen = ctx-&gt;kma.param.tpcl + len;
+    if (mlen &gt; ((U64(1) &lt;&lt; 36) - 32) || (sizeof(len) == 8 &amp;&amp; mlen &lt; len))
+        return -1;
+    ctx-&gt;kma.param.tpcl = mlen;
+
+    n = ctx-&gt;mreslen;
+    if (n) {
+        inptr = in;
+        inlen = len;
+        while (n &amp;&amp; inlen) {
+            ctx-&gt;mres[n] = *inptr;
+            n = (n + 1) &amp; 0xf;
+            ++inptr;
+            --inlen;
+        }
+        /* ctx-&gt;mres contains a complete block if offset has wrapped around */
+        if (!n) {
+            s390x_kma(ctx-&gt;ares, ctx-&gt;areslen, ctx-&gt;mres, 16, buf.b,
+                      ctx-&gt;fc | S390X_KMA_LAAD, &amp;ctx-&gt;kma.param);
+            ctx-&gt;fc |= S390X_KMA_HS;
+            ctx-&gt;areslen = 0;
+
+            /* previous call already encrypted/decrypted its remainder,
+             * see comment below */
+            n = ctx-&gt;mreslen;
+            while (n) {
+                *out = buf.b[n];
+                n = (n + 1) &amp; 0xf;
+                ++out;
+                ++in;
+                --len;
+            }
+            ctx-&gt;mreslen = 0;
+        }
+    }
+
+    rem = len &amp; 0xf;
+
+    len &amp;= ~0xf;
+    if (len) {
+        s390x_kma(ctx-&gt;ares, ctx-&gt;areslen, in, len, out,
+                  ctx-&gt;fc | S390X_KMA_LAAD, &amp;ctx-&gt;kma.param);
+        in += len;
+        out += len;
+        ctx-&gt;fc |= S390X_KMA_HS;
+        ctx-&gt;areslen = 0;
+    }
+
+    /*-
+     * If there is a remainder, it has to be saved such that it can be
+     * processed by kma later. However, we also have to do the for-now
+     * unauthenticated encryption/decryption part here and now...
+     */
+    if (rem) {
+        if (!ctx-&gt;mreslen) {
+            buf.w[0] = ctx-&gt;kma.param.j0.w[0];
+            buf.w[1] = ctx-&gt;kma.param.j0.w[1];
+            buf.w[2] = ctx-&gt;kma.param.j0.w[2];
+            buf.w[3] = ctx-&gt;kma.param.cv.w + 1;
+            s390x_km(buf.b, 16, ctx-&gt;kres, ctx-&gt;fc &amp; 0x1f, &amp;ctx-&gt;kma.param.k);
+        }
+
+        n = ctx-&gt;mreslen;
+        for (i = 0; i &lt; rem; i++) {
+            ctx-&gt;mres[n + i] = in[i];
+            out[i] = in[i] ^ ctx-&gt;kres[n + i];
+        }
+
+        ctx-&gt;mreslen += rem;
+    }
+    return 0;
+}
+
+static void s390x_aes_gcm_setiv(S390X_AES_GCM_CTX *ctx,
+                                const unsigned char *iv)
+{
+    ctx-&gt;kma.param.t.g[0] = 0;
+    ctx-&gt;kma.param.t.g[1] = 0;
+    ctx-&gt;kma.param.tpcl = 0;
+    ctx-&gt;kma.param.taadl = 0;
+    ctx-&gt;mreslen = 0;
+    ctx-&gt;areslen = 0;
+    ctx-&gt;kreslen = 0;
+
+    if (ctx-&gt;ivlen == 12) {
+        memcpy(&amp;ctx-&gt;kma.param.j0, iv, ctx-&gt;ivlen);
+        ctx-&gt;kma.param.j0.w[3] = 1;
+        ctx-&gt;kma.param.cv.w = 1;
+    } else {
+        /* ctx-&gt;iv has the right size and is already padded. */
+        memcpy(ctx-&gt;iv, iv, ctx-&gt;ivlen);
+        s390x_kma(ctx-&gt;iv, S390X_gcm_ivpadlen(ctx-&gt;ivlen), NULL, 0, NULL,
+                  ctx-&gt;fc, &amp;ctx-&gt;kma.param);
+        ctx-&gt;fc |= S390X_KMA_HS;
+
+        ctx-&gt;kma.param.j0.g[0] = ctx-&gt;kma.param.t.g[0];
+        ctx-&gt;kma.param.j0.g[1] = ctx-&gt;kma.param.t.g[1];
+        ctx-&gt;kma.param.cv.w = ctx-&gt;kma.param.j0.w[3];
+        ctx-&gt;kma.param.t.g[0] = 0;
+        ctx-&gt;kma.param.t.g[1] = 0;
+    }
+}
+
+static int s390x_aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)
+{
+    S390X_AES_GCM_CTX *gctx = EVP_C_DATA(S390X_AES_GCM_CTX, c);
+    S390X_AES_GCM_CTX *gctx_out;
+    EVP_CIPHER_CTX *out;
+    unsigned char *buf, *iv;
+    int ivlen, enc, len;
+
+    switch (type) {
+    case EVP_CTRL_INIT:
+        ivlen = EVP_CIPHER_CTX_iv_length(c);
+        iv = EVP_CIPHER_CTX_iv_noconst(c);
+        gctx-&gt;key_set = 0;
+        gctx-&gt;iv_set = 0;
+        gctx-&gt;ivlen = ivlen;
+        gctx-&gt;iv = iv;
+        gctx-&gt;taglen = -1;
+        gctx-&gt;iv_gen = 0;
+        gctx-&gt;tls_aad_len = -1;
+        return 1;
+
+    case EVP_CTRL_AEAD_SET_IVLEN:
+        if (arg &lt;= 0)
+            return 0;
+
+        if (arg != 12) {
+            iv = EVP_CIPHER_CTX_iv_noconst(c);
+            len = S390X_gcm_ivpadlen(arg);
+
+            /* Allocate memory for iv if needed. */
+            if (gctx-&gt;ivlen == 12 || len &gt; S390X_gcm_ivpadlen(gctx-&gt;ivlen)) {
+                if (gctx-&gt;iv != iv)
+                    OPENSSL_free(gctx-&gt;iv);
+
+                gctx-&gt;iv = OPENSSL_malloc(len);
+                if (gctx-&gt;iv == NULL)
+                    return 0;
+            }
+            /* Add padding. */
+            memset(gctx-&gt;iv + arg, 0, len - arg - 8);
+            *((unsigned long long *)(gctx-&gt;iv + len - 8)) = arg &lt;&lt; 3;
+        }
+        gctx-&gt;ivlen = arg;
+        return 1;
+
+    case EVP_CTRL_AEAD_SET_TAG:
+        buf = EVP_CIPHER_CTX_buf_noconst(c);
+        enc = EVP_CIPHER_CTX_encrypting(c);
+        if (arg &lt;= 0 || arg &gt; 16 || enc)
+            return 0;
+
+        memcpy(buf, ptr, arg);
+        gctx-&gt;taglen = arg;
+        return 1;
+
+    case EVP_CTRL_AEAD_GET_TAG:
+        enc = EVP_CIPHER_CTX_encrypting(c);
+        if (arg &lt;= 0 || arg &gt; 16 || !enc || gctx-&gt;taglen &lt; 0)
+            return 0;
+
+        memcpy(ptr, gctx-&gt;kma.param.t.b, arg);
+        return 1;
+
+    case EVP_CTRL_GCM_SET_IV_FIXED:
+        /* Special case: -1 length restores whole iv */
+        if (arg == -1) {
+            memcpy(gctx-&gt;iv, ptr, gctx-&gt;ivlen);
+            gctx-&gt;iv_gen = 1;
+            return 1;
+        }
+        /*
+         * Fixed field must be at least 4 bytes and invocation field at least
+         * 8.
+         */
+        if ((arg &lt; 4) || (gctx-&gt;ivlen - arg) &lt; 8)
+            return 0;
+
+        if (arg)
+            memcpy(gctx-&gt;iv, ptr, arg);
+
+        enc = EVP_CIPHER_CTX_encrypting(c);
+        if (enc &amp;&amp; RAND_bytes(gctx-&gt;iv + arg, gctx-&gt;ivlen - arg) &lt;= 0)
+            return 0;
+
+        gctx-&gt;iv_gen = 1;
+        return 1;
+
+    case EVP_CTRL_GCM_IV_GEN:
+        if (gctx-&gt;iv_gen == 0 || gctx-&gt;key_set == 0)
+            return 0;
+
+        s390x_aes_gcm_setiv(gctx, gctx-&gt;iv);
+
+        if (arg &lt;= 0 || arg &gt; gctx-&gt;ivlen)
+            arg = gctx-&gt;ivlen;
+
+        memcpy(ptr, gctx-&gt;iv + gctx-&gt;ivlen - arg, arg);
+        /*
+         * Invocation field will be at least 8 bytes in size and so no need
+         * to check wrap around or increment more than last 8 bytes.
+         */
+        (*(unsigned long long *)(gctx-&gt;iv + gctx-&gt;ivlen - 8))++;
+        gctx-&gt;iv_set = 1;
+        return 1;
+
+    case EVP_CTRL_GCM_SET_IV_INV:
+        enc = EVP_CIPHER_CTX_encrypting(c);
+        if (gctx-&gt;iv_gen == 0 || gctx-&gt;key_set == 0 || enc)
+            return 0;
+
+        memcpy(gctx-&gt;iv + gctx-&gt;ivlen - arg, ptr, arg);
+        s390x_aes_gcm_setiv(gctx, gctx-&gt;iv);
+        gctx-&gt;iv_set = 1;
+        return 1;
+
+    case EVP_CTRL_AEAD_TLS1_AAD:
+        /* Save the aad for later use. */
+        if (arg != EVP_AEAD_TLS1_AAD_LEN)
+            return 0;
+
+        buf = EVP_CIPHER_CTX_buf_noconst(c);
+        memcpy(buf, ptr, arg);
+        gctx-&gt;tls_aad_len = arg;
+
+        len = buf[arg - 2] &lt;&lt; 8 | buf[arg - 1];
+        /* Correct length for explicit iv. */
+        if (len &lt; EVP_GCM_TLS_EXPLICIT_IV_LEN)
+            return 0;
+        len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;
+
+        /* If decrypting correct for tag too. */
+        enc = EVP_CIPHER_CTX_encrypting(c);
+        if (!enc) {
+            if (len &lt; EVP_GCM_TLS_TAG_LEN)
+                return 0;
+            len -= EVP_GCM_TLS_TAG_LEN;
+        }
+        buf[arg - 2] = len &gt;&gt; 8;
+        buf[arg - 1] = len &amp; 0xff;
+        /* Extra padding: tag appended to record. */
+        return EVP_GCM_TLS_TAG_LEN;
+
+    case EVP_CTRL_COPY:
+        out = ptr;
+        gctx_out = EVP_C_DATA(S390X_AES_GCM_CTX, out);
+        iv = EVP_CIPHER_CTX_iv_noconst(c);
+
+        if (gctx-&gt;iv == iv) {
+            gctx_out-&gt;iv = EVP_CIPHER_CTX_iv_noconst(out);
+        } else {
+            len = S390X_gcm_ivpadlen(gctx-&gt;ivlen);
+
+            gctx_out-&gt;iv = OPENSSL_malloc(len);
+            if (gctx_out-&gt;iv == NULL)
+                return 0;
+
+            memcpy(gctx_out-&gt;iv, gctx-&gt;iv, len);
+        }
+        return 1;
+
+    default:
+        return -1;
+    }
+}
+
+static int s390x_aes_gcm_init_key(EVP_CIPHER_CTX *ctx,
+                                  const unsigned char *key,
+                                  const unsigned char *iv, int enc)
+{
+    S390X_AES_GCM_CTX *gctx = EVP_C_DATA(S390X_AES_GCM_CTX, ctx);
+    int keylen;
+
+    if (iv == NULL &amp;&amp; key == NULL)
+        return 1;
+
+    if (key != NULL) {
+        keylen = EVP_CIPHER_CTX_key_length(ctx);
+        memcpy(&amp;gctx-&gt;kma.param.k, key, keylen);
+
+        /* Convert key size to function code. */
+        gctx-&gt;fc = S390X_AES_128 + (((keylen &lt;&lt; 3) - 128) &gt;&gt; 6);
+        if (!enc)
+            gctx-&gt;fc |= S390X_DECRYPT;
+
+        if (iv == NULL &amp;&amp; gctx-&gt;iv_set)
+            iv = gctx-&gt;iv;
+
+        if (iv != NULL) {
+            s390x_aes_gcm_setiv(gctx, iv);
+            gctx-&gt;iv_set = 1;
+        }
+        gctx-&gt;key_set = 1;
+    } else {
+        if (gctx-&gt;key_set)
+            s390x_aes_gcm_setiv(gctx, iv);
+        else
+            memcpy(gctx-&gt;iv, iv, gctx-&gt;ivlen);
+
+        gctx-&gt;iv_set = 1;
+        gctx-&gt;iv_gen = 0;
+    }
+    return 1;
+}
+
+static int s390x_aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                    const unsigned char *in, size_t len)
+{
+    S390X_AES_GCM_CTX *gctx = EVP_C_DATA(S390X_AES_GCM_CTX, ctx);
+    const unsigned char *buf = EVP_CIPHER_CTX_buf_noconst(ctx);
+    const int enc = EVP_CIPHER_CTX_encrypting(ctx);
+    int rv = -1;
+
+    if (out != in || len &lt; (EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN))
+        return -1;
+
+    if (EVP_CIPHER_CTX_ctrl(ctx, enc ? EVP_CTRL_GCM_IV_GEN
+                                     : EVP_CTRL_GCM_SET_IV_INV,
+                            EVP_GCM_TLS_EXPLICIT_IV_LEN, out) &lt;= 0)
+        goto err;
+
+    in += EVP_GCM_TLS_EXPLICIT_IV_LEN;
+    out += EVP_GCM_TLS_EXPLICIT_IV_LEN;
+    len -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;
+
+    gctx-&gt;kma.param.taadl = gctx-&gt;tls_aad_len &lt;&lt; 3;
+    gctx-&gt;kma.param.tpcl = len &lt;&lt; 3;
+    s390x_kma(buf, gctx-&gt;tls_aad_len, in, len, out,
+              gctx-&gt;fc | S390X_KMA_LAAD | S390X_KMA_LPC, &amp;gctx-&gt;kma.param);
+
+    if (enc) {
+        memcpy(out + len, gctx-&gt;kma.param.t.b, EVP_GCM_TLS_TAG_LEN);
+        rv = len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;
+    } else {
+        if (CRYPTO_memcmp(gctx-&gt;kma.param.t.b, in + len,
+                          EVP_GCM_TLS_TAG_LEN)) {
+            OPENSSL_cleanse(out, len);
+            goto err;
+        }
+        rv = len;
+    }
+err:
+    gctx-&gt;iv_set = 0;
+    gctx-&gt;tls_aad_len = -1;
+    return rv;
+}
+
+static int s390x_aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                const unsigned char *in, size_t len)
+{
+    S390X_AES_GCM_CTX *gctx = EVP_C_DATA(S390X_AES_GCM_CTX, ctx);
+    unsigned char *buf, tmp[16];
+    int enc;
+
+    if (!gctx-&gt;key_set)
+        return -1;
+
+    if (gctx-&gt;tls_aad_len &gt;= 0)
+        return s390x_aes_gcm_tls_cipher(ctx, out, in, len);
+
+    if (!gctx-&gt;iv_set)
+        return -1;
+
+    if (in != NULL) {
+        if (out == NULL) {
+            if (s390x_aes_gcm_aad(gctx, in, len))
+                return -1;
+        } else {
+            if (s390x_aes_gcm(gctx, in, out, len))
+                return -1;
+        }
+        return len;
+    } else {
+        gctx-&gt;kma.param.taadl &lt;&lt;= 3;
+        gctx-&gt;kma.param.tpcl &lt;&lt;= 3;
+        s390x_kma(gctx-&gt;ares, gctx-&gt;areslen, gctx-&gt;mres, gctx-&gt;mreslen, tmp,
+                  gctx-&gt;fc | S390X_KMA_LAAD | S390X_KMA_LPC, &amp;gctx-&gt;kma.param);
+        /* recall that we already did en-/decrypt gctx-&gt;mres
+         * and returned it to caller... */
+        OPENSSL_cleanse(tmp, gctx-&gt;mreslen);
+        gctx-&gt;iv_set = 0;
+
+        enc = EVP_CIPHER_CTX_encrypting(ctx);
+        if (enc) {
+            gctx-&gt;taglen = 16;
+        } else {
+            if (gctx-&gt;taglen &lt; 0)
+                return -1;
+
+            buf = EVP_CIPHER_CTX_buf_noconst(ctx);
+            if (CRYPTO_memcmp(buf, gctx-&gt;kma.param.t.b, gctx-&gt;taglen))
+                return -1;
+        }
+        return 0;
+    }
+}
+
+static int s390x_aes_gcm_cleanup(EVP_CIPHER_CTX *c)
+{
+    S390X_AES_GCM_CTX *gctx = EVP_C_DATA(S390X_AES_GCM_CTX, c);
+    const unsigned char *iv;
+
+    if (gctx == NULL)
+        return 0;
+
+    iv = EVP_CIPHER_CTX_iv(c);
+    if (iv != gctx-&gt;iv)
+        OPENSSL_free(gctx-&gt;iv);
+
+    OPENSSL_cleanse(gctx, sizeof(*gctx));
+    return 1;
+}
+
+# define S390X_AES_XTS_CTX		EVP_AES_XTS_CTX
+# define S390X_aes_128_xts_CAPABLE	1	/* checked by callee */
+# define S390X_aes_256_xts_CAPABLE	1
+
+# define s390x_aes_xts_init_key aes_xts_init_key
+static int s390x_aes_xts_init_key(EVP_CIPHER_CTX *ctx,
+                                  const unsigned char *key,
+                                  const unsigned char *iv, int enc);
+# define s390x_aes_xts_cipher aes_xts_cipher
+static int s390x_aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                const unsigned char *in, size_t len);
+# define s390x_aes_xts_ctrl aes_xts_ctrl
+static int s390x_aes_xts_ctrl(EVP_CIPHER_CTX *, int type, int arg, void *ptr);
+# define s390x_aes_xts_cleanup aes_xts_cleanup
+
+# define S390X_AES_CCM_CTX		EVP_AES_CCM_CTX
+# define S390X_aes_128_ccm_CAPABLE	0
+# define S390X_aes_192_ccm_CAPABLE	0
+# define S390X_aes_256_ccm_CAPABLE	0
+
+# define s390x_aes_ccm_init_key aes_ccm_init_key
+static int s390x_aes_ccm_init_key(EVP_CIPHER_CTX *ctx,
+                                  const unsigned char *key,
+                                  const unsigned char *iv, int enc);
+# define s390x_aes_ccm_cipher aes_ccm_cipher
+static int s390x_aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                const unsigned char *in, size_t len);
+# define s390x_aes_ccm_ctrl aes_ccm_ctrl
+static int s390x_aes_ccm_ctrl(EVP_CIPHER_CTX *, int type, int arg, void *ptr);
+# define s390x_aes_ccm_cleanup aes_ccm_cleanup
+
+# ifndef OPENSSL_NO_OCB
+#  define S390X_AES_OCB_CTX		EVP_AES_OCB_CTX
+#  define S390X_aes_128_ocb_CAPABLE	0
+#  define S390X_aes_192_ocb_CAPABLE	0
+#  define S390X_aes_256_ocb_CAPABLE	0
+
+#  define s390x_aes_ocb_init_key aes_ocb_init_key
+static int s390x_aes_ocb_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+                                  const unsigned char *iv, int enc);
+#  define s390x_aes_ocb_cipher aes_ocb_cipher
+static int s390x_aes_ocb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                                const unsigned char *in, size_t len);
+#  define s390x_aes_ocb_cleanup aes_ocb_cleanup
+static int s390x_aes_ocb_cleanup(EVP_CIPHER_CTX *);
+#  define s390x_aes_ocb_ctrl aes_ocb_ctrl
+static int s390x_aes_ocb_ctrl(EVP_CIPHER_CTX *, int type, int arg, void *ptr);
+# endif
+
+# define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,	\
+                              MODE,flags)				\
+static const EVP_CIPHER s390x_aes_##keylen##_##mode = {			\
+    nid##_##keylen##_##nmode,blocksize,					\
+    keylen / 8,								\
+    ivlen,								\
+    flags | EVP_CIPH_##MODE##_MODE,					\
+    s390x_aes_init_key,							\
+    s390x_aes_##mode##_cipher,						\
+    NULL,								\
+    sizeof(EVP_AES_KEY),						\
+    NULL,								\
+    NULL,								\
+    NULL,								\
+    NULL								\
+};									\
+static const EVP_CIPHER aes_##keylen##_##mode = {			\
+    nid##_##keylen##_##nmode,						\
+    blocksize,								\
+    keylen / 8,								\
+    ivlen,								\
+    flags | EVP_CIPH_##MODE##_MODE,					\
+    aes_init_key,							\
+    aes_##mode##_cipher,						\
+    NULL,								\
+    sizeof(EVP_AES_KEY),						\
+    NULL,NULL,NULL,NULL							\
+};									\
+const EVP_CIPHER *EVP_aes_##keylen##_##mode(void)			\
+{									\
+    return S390X_aes_##keylen##_##mode##_CAPABLE ?			\
+           &amp;s390x_aes_##keylen##_##mode : &amp;aes_##keylen##_##mode;	\
+}
+
+# define BLOCK_CIPHER_custom(nid,keylen,blocksize,ivlen,mode,MODE,flags)\
+static const EVP_CIPHER s390x_aes_##keylen##_##mode = {			\
+    nid##_##keylen##_##mode,						\
+    blocksize,								\
+    (EVP_CIPH_##MODE##_MODE == EVP_CIPH_XTS_MODE ? 2 : 1) * keylen / 8,	\
+    ivlen,								\
+    flags | EVP_CIPH_##MODE##_MODE,					\
+    s390x_aes_##mode##_init_key,					\
+    s390x_aes_##mode##_cipher,						\
+    s390x_aes_##mode##_cleanup,						\
+    sizeof(S390X_AES_##MODE##_CTX),					\
+    NULL,								\
+    NULL,								\
+    s390x_aes_##mode##_ctrl,						\
+    NULL								\
+};									\
+static const EVP_CIPHER aes_##keylen##_##mode = {			\
+    nid##_##keylen##_##mode,blocksize,					\
+    (EVP_CIPH_##MODE##_MODE == EVP_CIPH_XTS_MODE ? 2 : 1) * keylen / 8,	\
+    ivlen,								\
+    flags | EVP_CIPH_##MODE##_MODE,					\
+    aes_##mode##_init_key,						\
+    aes_##mode##_cipher,						\
+    aes_##mode##_cleanup,						\
+    sizeof(EVP_AES_##MODE##_CTX),					\
+    NULL,								\
+    NULL,								\
+    aes_##mode##_ctrl,							\
+    NULL								\
+};									\
+const EVP_CIPHER *EVP_aes_##keylen##_##mode(void)			\
+{									\
+    return S390X_aes_##keylen##_##mode##_CAPABLE ?			\
+           &amp;s390x_aes_##keylen##_##mode : &amp;aes_##keylen##_##mode;	\
+}
+
 #else
 
 # define BLOCK_CIPHER_generic(nid,keylen,blocksize,ivlen,nmode,mode,MODE,flags) \
diff --git a/crypto/s390x_arch.h b/crypto/s390x_arch.h
index 2585985..d447d33 100644
--- a/crypto/s390x_arch.h
+++ b/crypto/s390x_arch.h
@@ -12,6 +12,11 @@
 
 # ifndef __ASSEMBLER__
 
+void s390x_km(const unsigned char *in, size_t len, unsigned char *out,
+              unsigned int fc, void *param);
+void s390x_kma(const unsigned char *aad, size_t alen, const unsigned char *in,
+               size_t len, unsigned char *out, unsigned int fc, void *param);
+
 /*
  * The field elements of OPENSSL_s390xcap_P are the 64-bit words returned by
  * the STFLE instruction followed by the 64-bit word pairs returned by
@@ -79,4 +84,10 @@ extern struct OPENSSL_s390xcap_st OPENSSL_s390xcap_P;
 /* prno */
 # define S390X_TRNG		114
 
+/* Register 0 Flags */
+# define S390X_DECRYPT		0x80
+# define S390X_KMA_LPC		0x100
+# define S390X_KMA_LAAD		0x200
+# define S390X_KMA_HS		0x400
+
 #endif
diff --git a/crypto/s390xcpuid.S b/crypto/s390xcpuid.pl
old mode 100644
new mode 100755
similarity index 66%
rename from crypto/s390xcpuid.S
rename to crypto/s390xcpuid.pl
index 9aa23c3..03e89a4
--- a/crypto/s390xcpuid.S
+++ b/crypto/s390xcpuid.pl
@@ -1,15 +1,35 @@
-.text
-// Copyright 2009-2016 The OpenSSL Project Authors. All Rights Reserved.
-//
-// Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
-// this file except in compliance with the License.  You can obtain a copy
-// in the file LICENSE in the source distribution or at
-// <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+#! /usr/bin/env perl
+# Copyright 2009-2017 The OpenSSL Project Authors. All Rights Reserved.
+#
+# Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+# this file except in compliance with the License.  You can obtain a copy
+# in the file LICENSE in the source distribution or at
+# <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+
+$flavour = shift;
+
+if ($flavour =~ /3[12]/) {
+	$SIZE_T=4;
+	$g=&quot;&quot;;
+} else {
+	$SIZE_T=8;
+	$g=&quot;g&quot;;
+}
 
+while (($output=shift) &amp;&amp; ($output!~/\w[\w\-]*\.\w+$/)) {}
+open STDOUT,&quot;&gt;$output&quot;;
+
+$ra=&quot;%r14&quot;;
+$sp=&quot;%r15&quot;;
+$stdframe=16*$SIZE_T+4*8;
+
+$code=&lt;&lt;___;
 #include &quot;s390x_arch.h&quot;
 
+.text
+
 .globl	OPENSSL_s390x_facilities
-.type	<A HREF="../../../mailman/listinfo/openssl-commits.html">OPENSSL_s390x_facilities, at function</A>
+.type	OPENSSL_s390x_facilities,\@function
 .align	16
 OPENSSL_s390x_facilities:
 	lghi	%r0,0
@@ -102,20 +122,20 @@ OPENSSL_s390x_facilities:
 	.long	0xb9294022		# kma %r2,%r4,%r2
 
 .Lret:
-	br	%r14
+	br	$ra
 .size	OPENSSL_s390x_facilities,.-OPENSSL_s390x_facilities
 
 .globl	OPENSSL_rdtsc
-.type	<A HREF="../../../mailman/listinfo/openssl-commits.html">OPENSSL_rdtsc, at function</A>
+.type	OPENSSL_rdtsc,\@function
 .align	16
 OPENSSL_rdtsc:
-	stck	16(%r15)
-	lg	%r2,16(%r15)
-	br	%r14
+	stck	16($sp)
+	lg	%r2,16($sp)
+	br	$ra
 .size	OPENSSL_rdtsc,.-OPENSSL_rdtsc
 
 .globl	OPENSSL_atomic_add
-.type	<A HREF="../../../mailman/listinfo/openssl-commits.html">OPENSSL_atomic_add, at function</A>
+.type	OPENSSL_atomic_add,\@function
 .align	16
 OPENSSL_atomic_add:
 	l	%r1,0(%r2)
@@ -124,16 +144,16 @@ OPENSSL_atomic_add:
 	cs	%r1,%r0,0(%r2)
 	brc	4,.Lspin
 	lgfr	%r2,%r0		# OpenSSL expects the new value
-	br	%r14
+	br	$ra
 .size	OPENSSL_atomic_add,.-OPENSSL_atomic_add
 
 .globl	OPENSSL_wipe_cpu
-.type	<A HREF="../../../mailman/listinfo/openssl-commits.html">OPENSSL_wipe_cpu, at function</A>
+.type	OPENSSL_wipe_cpu,\@function
 .align	16
 OPENSSL_wipe_cpu:
 	xgr	%r0,%r0
 	xgr	%r1,%r1
-	lgr	%r2,%r15
+	lgr	%r2,$sp
 	xgr	%r3,%r3
 	xgr	%r4,%r4
 	lzdr	%f0
@@ -144,11 +164,11 @@ OPENSSL_wipe_cpu:
 	lzdr	%f5
 	lzdr	%f6
 	lzdr	%f7
-	br	%r14
+	br	$ra
 .size	OPENSSL_wipe_cpu,.-OPENSSL_wipe_cpu
 
 .globl	OPENSSL_cleanse
-.type	<A HREF="../../../mailman/listinfo/openssl-commits.html">OPENSSL_cleanse, at function</A>
+.type	OPENSSL_cleanse,\@function
 .align	16
 OPENSSL_cleanse:
 #if !defined(__s390x__) &amp;&amp; !defined(__s390x)
@@ -179,11 +199,11 @@ OPENSSL_cleanse:
 	lghi	%r4,7
 	ngr	%r3,%r4
 	jnz	.Little
-	br	%r14
+	br	$ra
 .size	OPENSSL_cleanse,.-OPENSSL_cleanse
 
 .globl	CRYPTO_memcmp
-.type	<A HREF="../../../mailman/listinfo/openssl-commits.html">CRYPTO_memcmp, at function</A>
+.type	CRYPTO_memcmp,\@function
 .align	16
 CRYPTO_memcmp:
 #if !defined(__s390x__) &amp;&amp; !defined(__s390x)
@@ -206,11 +226,11 @@ CRYPTO_memcmp:
 	srl	%r5,31
 .Lno_data:
 	lgr	%r2,%r5
-	br	%r14
+	br	$ra
 .size	CRYPTO_memcmp,.-CRYPTO_memcmp
 
 .globl	OPENSSL_instrument_bus
-.type	<A HREF="../../../mailman/listinfo/openssl-commits.html">OPENSSL_instrument_bus, at function</A>
+.type	OPENSSL_instrument_bus,\@function
 .align	16
 OPENSSL_instrument_bus:
 	lghi	%r2,0
@@ -218,20 +238,71 @@ OPENSSL_instrument_bus:
 .size	OPENSSL_instrument_bus,.-OPENSSL_instrument_bus
 
 .globl	OPENSSL_instrument_bus2
-.type	<A HREF="../../../mailman/listinfo/openssl-commits.html">OPENSSL_instrument_bus2, at function</A>
+.type	OPENSSL_instrument_bus2,\@function
 .align	16
 OPENSSL_instrument_bus2:
 	lghi	%r2,0
-	br	%r14
+	br	$ra
 .size	OPENSSL_instrument_bus2,.-OPENSSL_instrument_bus2
 
 .globl	OPENSSL_vx_probe
-.type	<A HREF="../../../mailman/listinfo/openssl-commits.html">OPENSSL_vx_probe, at function</A>
+.type	OPENSSL_vx_probe,\@function
 .align	16
 OPENSSL_vx_probe:
 	.word	0xe700,0x0000,0x0044	# vzero %v0
-	br	%r14
+	br	$ra
 .size	OPENSSL_vx_probe,.-OPENSSL_vx_probe
+___
+
+################
+# void s390x_km(const unsigned char *in, size_t len, unsigned char *out,
+#               unsigned int fc, void *param)
+{
+my ($in,$len,$out,$fc,$param) = map(&quot;%r$_&quot;,(2..6));
+$code.=&lt;&lt;___;
+.globl	s390x_km
+.type	s390x_km,\@function
+.align	16
+s390x_km:
+	lr	%r0,$fc
+	l${g}r	%r1,$param
+
+	.long	0xb92e0042	# km $out,$in
+	brc	1,.-4		# pay attention to &quot;partial completion&quot;
 
+	br	$ra
+.size	s390x_km,.-s390x_km
+___
+}
+
+################
+# void s390x_kma(const unsigned char *aad, size_t alen,
+#                const unsigned char *in, size_t len,
+#                unsigned char *out, unsigned int fc, void *param)
+{
+my ($aad,$alen,$in,$len,$out) = map(&quot;%r$_&quot;,(2..6));
+$code.=&lt;&lt;___;
+.globl	s390x_kma
+.type	s390x_kma,\@function
+.align	16
+s390x_kma:
+	st${g}	$out,6*$SIZE_T($sp)
+	lm${g}	%r0,%r1,$stdframe($sp)
+
+	.long	0xb9292064	# kma $out,$aad,$in
+	brc	1,.-4		# pay attention to &quot;partial completion&quot;
+
+	l${g}	$out,6*$SIZE_T($sp)
+	br	$ra
+.size	s390x_kma,.-s390x_kma
+___
+}
+
+$code.=&lt;&lt;___;
 .section	.init
-	brasl	%r14,OPENSSL_cpuid_setup
+	brasl	$ra,OPENSSL_cpuid_setup
+___
+
+$code =~ s/\`([^\`]*)\`/eval $1/gem;
+print $code;
+close STDOUT;	# force flush
</PRE>


































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017452.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="017454.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17453">[ date ]</a>
              <a href="thread.html#17453">[ thread ]</a>
              <a href="subject.html#17453">[ subject ]</a>
              <a href="author.html#17453">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
