<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [web] OpenSSL Web Pages branch master updated.	e5c274d21c041d789fc2be297e29130194f83095
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2014-December/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bweb%5D%20OpenSSL%20Web%20Pages%20branch%20master%20updated.%0A%09e5c274d21c041d789fc2be297e29130194f83095&In-Reply-To=%3C20141209232656.608691E177D%40openssl.net%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000021.html">
   <LINK REL="Next"  HREF="000023.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [web] OpenSSL Web Pages branch master updated.	e5c274d21c041d789fc2be297e29130194f83095</H1>
    <B>root</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bweb%5D%20OpenSSL%20Web%20Pages%20branch%20master%20updated.%0A%09e5c274d21c041d789fc2be297e29130194f83095&In-Reply-To=%3C20141209232656.608691E177D%40openssl.net%3E"
       TITLE="[openssl-commits] [web] OpenSSL Web Pages branch master updated.	e5c274d21c041d789fc2be297e29130194f83095">root at openssl.org
       </A><BR>
    <I>Tue Dec  9 18:26:56 EST 2014</I>
    <P><UL>
        <LI>Previous message: <A HREF="000021.html">[openssl-commits] [web] OpenSSL Web Pages branch master updated.	4ac5045451ac48d5538f4b43ad86b837e40c461d
</A></li>
        <LI>Next message: <A HREF="000023.html">[openssl-commits] [openssl] OpenSSL source code branch master	updated. 5b17b79a895bb9eace11d4596acadaa2ed69cf2d
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22">[ date ]</a>
              <a href="thread.html#22">[ thread ]</a>
              <a href="subject.html#22">[ subject ]</a>
              <a href="author.html#22">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;OpenSSL Web Pages &quot;.

The branch, master has been updated
       via  e5c274d21c041d789fc2be297e29130194f83095 (commit)
      from  4ac5045451ac48d5538f4b43ad86b837e40c461d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e5c274d21c041d789fc2be297e29130194f83095
Author: root &lt;<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">root at openssl.net</A>&gt;
Date:   Tue Dec 9 18:26:51 2014 -0500

    Remove old pod html.pm

-----------------------------------------------------------------------

Summary of changes:
 docs/Pod/Html.pm | 1607 ------------------------------------------------------
 1 file changed, 1607 deletions(-)
 delete mode 100644 docs/Pod/Html.pm

diff --git a/docs/Pod/Html.pm b/docs/Pod/Html.pm
deleted file mode 100644
index 8b91b79..0000000
--- a/docs/Pod/Html.pm
+++ /dev/null
@@ -1,1607 +0,0 @@
-# Hacked to actually work
-
-package Pod::Html;
-
-use Pod::Functions;
-use Getopt::Long;	# package for handling command-line parameters
-require Exporter;
-use vars qw($VERSION);
-$VERSION = 1.01;
<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">- at ISA</A> = Exporter;
<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">- at EXPORT</A> = qw(pod2html htmlify);
-use Cwd;
-
-use Carp;
-
-use locale;	# make \w work right in non-ASCII lands
-
-use strict;
-
-use Config;
-
-=head1 NAME
-
-Pod::Html - module to convert pod files to HTML
-
-=head1 SYNOPSIS
-
-    use Pod::Html;
-    pod2html([options]);
-
-=head1 DESCRIPTION
-
-Converts files from pod format (see L&lt;perlpod&gt;) to HTML format.  It
-can automatically generate indexes and cross-references, and it keeps
-a cache of things it knows how to cross-reference.
-
-=head1 ARGUMENTS
-
-Pod::Html takes the following arguments:
-
-=over 4
-
-=item help
-
-    --help
-
-Displays the usage message.
-
-=item htmlroot
-
-    --htmlroot=name
-
-Sets the base URL for the HTML files.  When cross-references are made,
-the HTML root is prepended to the URL.
-
-=item infile
-
-    --infile=name
-
-Specify the pod file to convert.  Input is taken from STDIN if no
-infile is specified.
-
-=item outfile
-
-    --outfile=name
-
-Specify the HTML file to create.  Output goes to STDOUT if no outfile
-is specified.
-
-=item podroot
-
-    --podroot=name
-
-Specify the base directory for finding library pods.
-
-=item podpath
-
-    --podpath=name:...:name
-
-Specify which subdirectories of the podroot contain pod files whose
-HTML converted forms can be linked-to in cross-references.
-
-=item libpods
-
-    --libpods=name:...:name
-
-List of page names (eg, &quot;perlfunc&quot;) which contain linkable C&lt;=item&gt;s.
-
-=item netscape
-
-    --netscape
-
-Use Netscape HTML directives when applicable.
-
-=item nonetscape
-
-    --nonetscape
-
-Do not use Netscape HTML directives (default).
-
-=item index
-
-    --index
-
-Generate an index at the top of the HTML file (default behaviour).
-
-=item noindex
-
-    --noindex
-
-Do not generate an index at the top of the HTML file.
-
-
-=item recurse
-
-    --recurse
-
-Recurse into subdirectories specified in podpath (default behaviour).
-
-=item norecurse
-
-    --norecurse
-
-Do not recurse into subdirectories specified in podpath.
-
-=item title
-
-    --title=title
-
-Specify the title of the resulting HTML file.
-
-=item verbose
-
-    --verbose
-
-Display progress messages.
-
-=back
-
-=head1 EXAMPLE
-
-    pod2html(&quot;pod2html&quot;,
-	     &quot;--podpath=lib:ext:pod:vms&quot;, 
-	     &quot;--podroot=/usr/src/perl&quot;,
-	     &quot;--htmlroot=/perl/nmanual&quot;,
-	     &quot;--libpods=perlfunc:perlguts:perlvar:perlrun:perlop&quot;,
-	     &quot;--recurse&quot;,
-	     &quot;--infile=foo.pod&quot;,
-	     &quot;--outfile=/perl/nmanual/foo.html&quot;);
-
-=head1 AUTHOR
-
-Tom Christiansen, E&lt;lt&gt;<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">tchrist at perl.comE</A>&lt;gt&gt;.
-
-=head1 BUGS
-
-Has trouble with C&lt;&gt; etc in = commands.
-
-=head1 SEE ALSO
-
-L&lt;perlpod&gt;
-
-=head1 COPYRIGHT
-
-This program is distributed under the Artistic License.
-
-=cut
-
-my $dircache = &quot;pod2html-dircache&quot;;
-my $itemcache = &quot;pod2html-itemcache&quot;;
-
-my @begin_stack = ();		# begin/end stack
-
-my @libpods = ();	    	# files to search for links from C&lt;&gt; directives
-my $htmlroot = &quot;/&quot;;	    	# http-server base directory from which all
-				#   relative paths in $podpath stem.
-my $htmlfile = &quot;&quot;;		# write to stdout by default
-my $podfile = &quot;&quot;;		# read from stdin by default
-my @podpath = ();		# list of directories containing library pods.
-my $podroot = &quot;.&quot;;		# filesystem base directory from which all
-				#   relative paths in $podpath stem.
-my $recurse = 1;		# recurse on subdirectories in $podpath.
-my $verbose = 0;		# not verbose by default
-my $doindex = 1;   	    	# non-zero if we should generate an index
-my $listlevel = 0;		# current list depth
-my @listitem = ();		# stack of HTML commands to use when a =item is
-				#   encountered.  the top of the stack is the
-				#   current list.
-my @listdata = ();		# similar to @listitem, but for the text after
-				#   an =item
-my @listend = ();		# similar to @listitem, but the text to use to
-				#   end the list.
-my $ignore = 1;			# whether or not to format text.  we don't
-				#   format text until we hit our first pod
-				#   directive.
-
-my %items_named = ();		# for the multiples of the same item in perlfunc
-my @items_seen = ();
-my $netscape = 0;		# whether or not to use netscape directives.
-my $title;			# title to give the pod(s)
-my $top = 1;			# true if we are at the top of the doc.  used
-				#   to prevent the first &lt;HR&gt; directive.
-my $paragraph;			# which paragraph we're processing (used
-				#   for error messages)
-my %pages = ();			# associative array used to find the location
-				#   of pages referenced by L&lt;&gt; links.
-my %sections = ();		# sections within this page
-my %items = ();			# associative array used to find the location
-				#   of =item directives referenced by C&lt;&gt; links
-my $Is83;                       # is dos with short filenames (8.3)
-
-sub init_globals {
-$dircache = &quot;pod2html-dircache&quot;;
-$itemcache = &quot;pod2html-itemcache&quot;;
-
<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">- at begin_stack</A> = ();		# begin/end stack
-
<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">- at libpods</A> = ();	    	# files to search for links from C&lt;&gt; directives
-$htmlroot = &quot;/&quot;;	    	# http-server base directory from which all
-				#   relative paths in $podpath stem.
-$htmlfile = &quot;&quot;;		# write to stdout by default
-$podfile = &quot;&quot;;		# read from stdin by default
<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">- at podpath</A> = ();		# list of directories containing library pods.
-$podroot = &quot;.&quot;;		# filesystem base directory from which all
-				#   relative paths in $podpath stem.
-$recurse = 1;		# recurse on subdirectories in $podpath.
-$verbose = 0;		# not verbose by default
-$doindex = 1;   	    	# non-zero if we should generate an index
-$listlevel = 0;		# current list depth
<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">- at listitem</A> = ();		# stack of HTML commands to use when a =item is
-				#   encountered.  the top of the stack is the
-				#   current list.
<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">- at listdata</A> = ();		# similar to @listitem, but for the text after
-				#   an =item
<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">- at listend</A> = ();		# similar to @listitem, but the text to use to
-				#   end the list.
-$ignore = 1;			# whether or not to format text.  we don't
-				#   format text until we hit our first pod
-				#   directive.
-
<A HREF="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">- at items_seen</A> = ();
-%items_named = ();
-$netscape = 0;		# whether or not to use netscape directives.
-$title = '';			# title to give the pod(s)
-$top = 1;			# true if we are at the top of the doc.  used
-				#   to prevent the first &lt;HR&gt; directive.
-$paragraph = '';			# which paragraph we're processing (used
-				#   for error messages)
-%sections = ();		# sections within this page
-
-# These are not reinitialised here but are kept as a cache.
-# See get_cache and related cache management code.
-#%pages = ();			# associative array used to find the location
-				#   of pages referenced by L&lt;&gt; links.
-#%items = ();			# associative array used to find the location
-				#   of =item directives referenced by C&lt;&gt; links
-$Is83=$^O eq 'dos';
-}
-
-sub pod2html {
-    local(@ARGV) = @_;
-    local($/);
-    local $_;
-
-    init_globals();
-
-    $Is83 = 0 if (defined (&amp;Dos::UseLFN) &amp;&amp; Dos::UseLFN());
-
-    # cache of %pages and %items from last time we ran pod2html
-
-    #undef $opt_help if defined $opt_help;
-
-    # parse the command-line parameters
-    parse_command_line();
-
-    # set some variables to their default values if necessary
-    local *POD;
-    unless (@ARGV &amp;&amp; $ARGV[0]) { 
-	$podfile  = &quot;-&quot; unless $podfile;	# stdin
-	open(POD, &quot;&lt;$podfile&quot;)
-		|| die &quot;$0: cannot open $podfile file for input: $!\n&quot;;
-    } else {
-	$podfile = $ARGV[0];  # XXX: might be more filenames
-	*POD = *ARGV;
-    } 
-    $htmlfile = &quot;-&quot; unless $htmlfile;	# stdout
-    $htmlroot = &quot;&quot; if $htmlroot eq &quot;/&quot;;	# so we don't get a //
-
-    # read the pod a paragraph at a time
-    warn &quot;Scanning for sections in input file(s)\n&quot; if $verbose;
-    $/ = &quot;&quot;;
-    my @poddata  = &lt;POD&gt;;
-    close(POD);
-
-    # scan the pod for =head[1-6] directives and build an index
-    my $index = scan_headings(\%sections, @poddata);
-
-    unless($index) {
-	warn &quot;No pod in $podfile\n&quot; if $verbose;
-	return;
-    }
-
-    # open the output file
-    open(HTML, &quot;&gt;$htmlfile&quot;)
-	    || die &quot;$0: cannot open $htmlfile file for output: $!\n&quot;;
-
-    # put a title in the HTML file if one wasn't specified
-    if ($title eq '') {
-	TITLE_SEARCH: {
-	    for (my $i = 0; $i &lt; @poddata; $i++) { 
-		if ($poddata[$i] =~ /^=head1\s*NAME\b/m) {
-		    for my $para ( @poddata[$i, $i+1] ) { 
-			last TITLE_SEARCH
-			    if (($title) = $para =~ /(\S+\s+-+.*\S)/s)
-				|| (($title) = $para =~ /(.*)/s);
-		    }
-		} 
-
-	    } 
-	}
-    }
-    if (!$title and $podfile =~ /\.pod$/) {
-	# probably a split pod so take first =head[12] as title
-	for (my $i = 0; $i &lt; @poddata; $i++) { 
-	    last if ($title) = $poddata[$i] =~ /^=head[12]\s*(.*)/;
-	} 
-	warn &quot;adopted '$title' as title for $podfile\n&quot;
-	    if $verbose and $title;
-    } 
-    if ($title) {
-	$title =~ s/\s*\(.*\)//;
-    } else {
-	warn &quot;$0: no title for $podfile&quot;;
-	$podfile =~ /^(.*)(\.[^.\/]+)?$/;
-	$title = ($podfile eq &quot;-&quot; ? 'No Title' : $1);
-	warn &quot;using $title&quot; if $verbose;
-    }
-    print HTML &lt;&lt;END_OF_HEAD;
-&lt;HTML&gt;
-&lt;HEAD&gt;
-&lt;TITLE&gt;$title&lt;/TITLE&gt;
-&lt;LINK REV=&quot;made&quot; HREF=&quot;mailto:$Config{perladmin}&quot;&gt;
-&lt;/HEAD&gt;
-
-&lt;BODY&gt;
-
-END_OF_HEAD
-
-    # load/reload/validate/cache %pages and %items
-    get_cache($dircache, $itemcache, \@podpath, $podroot, $recurse);
-
-    # scan the pod for =item directives
-    scan_items(&quot;&quot;, \%items, @poddata);
-
-    # put an index at the top of the file.  note, if $doindex is 0 we
-    # still generate an index, but surround it with an html comment.
-    # that way some other program can extract it if desired.
-    $index =~ s/--+/-/g;
-    print HTML &quot;&lt;!-- INDEX BEGIN --&gt;\n&quot;;
-    print HTML &quot;&lt;!--\n&quot; unless $doindex;
-    print HTML $index;
-    print HTML &quot;--&gt;\n&quot; unless $doindex;
-    print HTML &quot;&lt;!-- INDEX END --&gt;\n\n&quot;;
-    print HTML &quot;&lt;HR&gt;\n&quot; if $doindex;
-
-    # now convert this file
-    warn &quot;Converting input file\n&quot; if $verbose;
-    foreach my $i (0..$#poddata) {
-	$_ = $poddata[$i];
-	$paragraph = $i+1;
-	if (/^(=.*)/s) {	# is it a pod directive?
-	    $ignore = 0;
-	    $_ = $1;
-	    if (/^=begin\s+(\S+)\s*(.*)/si) {# =begin
-		process_begin($1, $2);
-	    } elsif (/^=end\s+(\S+)\s*(.*)/si) {# =end
-		process_end($1, $2);
-	    } elsif (/^=cut/) {			# =cut
-		process_cut();
-	    } elsif (/^=pod/) {			# =pod
-		process_pod();
-	    } else {
-		next if @begin_stack &amp;&amp; $begin_stack[-1] ne 'html';
-
-		if (/^=(head[1-6])\s+(.*\S)/s) {	# =head[1-6] heading
-		    process_head($1, $2);
-		} elsif (/^=item\s*(.*\S)/sm) {	# =item text
-		    process_item($1);
-		} elsif (/^=over\s*(.*)/) {		# =over N
-		    process_over();
-		} elsif (/^=back/) {		# =back
-		    process_back();
-		} elsif (/^=for\s+(\S+)\s+(.*)/si) {# =for
-		    process_for($1,$2);
-		} else {
-		    /^=(\S*)\s*/;
-		    warn &quot;$0: $podfile: unknown pod directive '$1' in &quot;
-		       . &quot;paragraph $paragraph.  ignoring.\n&quot;;
-		}
-	    }
-	    $top = 0;
-	}
-	else {
-	    next if $ignore;
-	    next if @begin_stack &amp;&amp; $begin_stack[-1] ne 'html';
-	    my $text = $_;
-	    process_text(\$text, 1);
-	    if ($text =~ /^&lt;PRE&gt;/) {
-		print HTML &quot;$text&quot;;
-	    } else {
-		print HTML &quot;&lt;P&gt;\n$text&lt;/P&gt;\n&quot;;
-	    }
-	}
-    }
-
-    # finish off any pending directives
-    finish_list();
-    print HTML &lt;&lt;END_OF_TAIL;
-&lt;/BODY&gt;
-
-&lt;/HTML&gt;
-END_OF_TAIL
-
-    # close the html file
-    close(HTML);
-
-    warn &quot;Finished\n&quot; if $verbose;
-}
-
-##############################################################################
-
-my $usage;			# see below
-sub usage {
-    my $podfile = shift;
-    warn &quot;$0: $podfile: @_\n&quot; if @_;
-    die $usage;
-}
-
-$usage =&lt;&lt;END_OF_USAGE;
-Usage:  $0 --help --htmlroot=&lt;name&gt; --infile=&lt;name&gt; --outfile=&lt;name&gt;
-           --podpath=&lt;name&gt;:...:&lt;name&gt; --podroot=&lt;name&gt;
-           --libpods=&lt;name&gt;:...:&lt;name&gt; --recurse --verbose --index
-           --netscape --norecurse --noindex
-
-  --flush      - flushes the item and directory caches.
-  --help       - prints this message.
-  --htmlroot   - http-server base directory from which all relative paths
-                 in podpath stem (default is /).
-  --index      - generate an index at the top of the resulting html
-                 (default).
-  --infile     - filename for the pod to convert (input taken from stdin
-                 by default).
-  --libpods    - colon-separated list of pages to search for =item pod
-                 directives in as targets of C&lt;&gt; and implicit links (empty
-                 by default).  note, these are not filenames, but rather
-                 page names like those that appear in L&lt;&gt; links.
-  --netscape   - will use netscape html directives when applicable.
-  --nonetscape - will not use netscape directives (default).
-  --outfile    - filename for the resulting html file (output sent to
-                 stdout by default).
-  --podpath    - colon-separated list of directories containing library
-                 pods.  empty by default.
-  --podroot    - filesystem base directory from which all relative paths
-                 in podpath stem (default is .).
-  --noindex    - don't generate an index at the top of the resulting html.
-  --norecurse  - don't recurse on those subdirectories listed in podpath.
-  --recurse    - recurse on those subdirectories listed in podpath
-                 (default behavior).
-  --title      - title that will appear in resulting html file.
-  --verbose    - self-explanatory
-
-END_OF_USAGE
-
-sub parse_command_line {
-    my ($opt_flush,$opt_help,$opt_htmlroot,$opt_index,$opt_infile,$opt_libpods,$opt_netscape,$opt_outfile,$opt_podpath,$opt_podroot,$opt_norecurse,$opt_recurse,$opt_title,$opt_verbose);
-    my $result = GetOptions(
-			    'flush'      =&gt; \$opt_flush,
-			    'help'       =&gt; \$opt_help,
-			    'htmlroot=s' =&gt; \$opt_htmlroot,
-			    'index!'     =&gt; \$opt_index,
-			    'infile=s'   =&gt; \$opt_infile,
-			    'libpods=s'  =&gt; \$opt_libpods,
-			    'netscape!'  =&gt; \$opt_netscape,
-			    'outfile=s'  =&gt; \$opt_outfile,
-			    'podpath=s'  =&gt; \$opt_podpath,
-			    'podroot=s'  =&gt; \$opt_podroot,
-			    'norecurse'  =&gt; \$opt_norecurse,
-			    'recurse!'   =&gt; \$opt_recurse,
-			    'title=s'    =&gt; \$opt_title,
-			    'verbose'    =&gt; \$opt_verbose,
-			   );
-    usage(&quot;-&quot;, &quot;invalid parameters&quot;) if not $result;
-
-    usage(&quot;-&quot;) if defined $opt_help;	# see if the user asked for help
-    $opt_help = &quot;&quot;;			# just to make -w shut-up.
-
-    $podfile  = $opt_infile if defined $opt_infile;
-    $htmlfile = $opt_outfile if defined $opt_outfile;
-
-    @podpath  = split(&quot;:&quot;, $opt_podpath) if defined $opt_podpath;
-    @libpods  = split(&quot;:&quot;, $opt_libpods) if defined $opt_libpods;
-
-    warn &quot;Flushing item and directory caches\n&quot;
-	if $opt_verbose &amp;&amp; defined $opt_flush;
-    unlink($dircache, $itemcache) if defined $opt_flush;
-
-    $htmlroot = $opt_htmlroot if defined $opt_htmlroot;
-    $podroot  = $opt_podroot if defined $opt_podroot;
-
-    $doindex  = $opt_index if defined $opt_index;
-    $recurse  = $opt_recurse if defined $opt_recurse;
-    $title    = $opt_title if defined $opt_title;
-    $verbose  = defined $opt_verbose ? 1 : 0;
-    $netscape = $opt_netscape if defined $opt_netscape;
-}
-
-
-my $saved_cache_key;
-
-sub get_cache {
-    my($dircache, $itemcache, $podpath, $podroot, $recurse) = @_;
-    my @cache_key_args = @_;
-
-    # A first-level cache:
-    # Don't bother reading the cache files if they still apply
-    # and haven't changed since we last read them.
-
-    my $this_cache_key = cache_key(@cache_key_args);
-
-    return if $saved_cache_key and $this_cache_key eq $saved_cache_key;
-
-    # load the cache of %pages and %items if possible.  $tests will be
-    # non-zero if successful.
-    my $tests = 0;
-    if (-f $dircache &amp;&amp; -f $itemcache) {
-	warn &quot;scanning for item cache\n&quot; if $verbose;
-	$tests = load_cache($dircache, $itemcache, $podpath, $podroot);
-    }
-
-    # if we didn't succeed in loading the cache then we must (re)build
-    #  %pages and %items.
-    if (!$tests) {
-	warn &quot;scanning directories in pod-path\n&quot; if $verbose;
-	scan_podpath($podroot, $recurse, 0);
-    }
-    $saved_cache_key = cache_key(@cache_key_args);
-}
-
-sub cache_key {
-    my($dircache, $itemcache, $podpath, $podroot, $recurse) = @_;
-    return join('!', $dircache, $itemcache, $recurse,
-		@$podpath, $podroot, stat($dircache), stat($itemcache));
-}
-
-#
-# load_cache - tries to find if the caches stored in $dircache and $itemcache
-#  are valid caches of %pages and %items.  if they are valid then it loads
-#  them and returns a non-zero value.
-#
-
-sub load_cache {
-    my($dircache, $itemcache, $podpath, $podroot) = @_;
-    my($tests);
-    local $_;
-
-    $tests = 0;
-
-    open(CACHE, &quot;&lt;$itemcache&quot;) ||
-	die &quot;$0: error opening $itemcache for reading: $!\n&quot;;
-    $/ = &quot;\n&quot;;
-
-    # is it the same podpath?
-    $_ = &lt;CACHE&gt;;
-    chomp($_);
-    $tests++ if (join(&quot;:&quot;, @$podpath) eq $_);
-
-    # is it the same podroot?
-    $_ = &lt;CACHE&gt;;
-    chomp($_);
-    $tests++ if ($podroot eq $_);
-
-    # load the cache if its good
-    if ($tests != 2) {
-	close(CACHE);
-	return 0;
-    }
-
-    warn &quot;loading item cache\n&quot; if $verbose;
-    while (&lt;CACHE&gt;) {
-	/(.*?) (.*)$/;
-	$items{$1} = $2;
-    }
-    close(CACHE);
-
-    warn &quot;scanning for directory cache\n&quot; if $verbose;
-    open(CACHE, &quot;&lt;$dircache&quot;) ||
-	die &quot;$0: error opening $dircache for reading: $!\n&quot;;
-    $/ = &quot;\n&quot;;
-    $tests = 0;
-
-    # is it the same podpath?
-    $_ = &lt;CACHE&gt;;
-    chomp($_);
-    $tests++ if (join(&quot;:&quot;, @$podpath) eq $_);
-
-    # is it the same podroot?
-    $_ = &lt;CACHE&gt;;
-    chomp($_);
-    $tests++ if ($podroot eq $_);
-
-    # load the cache if its good
-    if ($tests != 2) {
-	close(CACHE);
-	return 0;
-    }
-
-    warn &quot;loading directory cache\n&quot; if $verbose;
-    while (&lt;CACHE&gt;) {
-	/(.*?) (.*)$/;
-	$pages{$1} = $2;
-    }
-
-    close(CACHE);
-
-    return 1;
-}
-
-#
-# scan_podpath - scans the directories specified in @podpath for directories,
-#  .pod files, and .pm files.  it also scans the pod files specified in
-#  @libpods for =item directives.
-#
-sub scan_podpath {
-    my($podroot, $recurse, $append) = @_;
-    my($pwd, $dir);
-    my($libpod, $dirname, $pod, @files, @poddata);
-
-    unless($append) {
-	%items = ();
-	%pages = ();
-    }
-
-    # scan each directory listed in @podpath
-    $pwd = getcwd();
-    chdir($podroot)
-	|| die &quot;$0: error changing to directory $podroot: $!\n&quot;;
-    foreach $dir (@podpath) {
-	scan_dir($dir, $recurse);
-    }
-
-    # scan the pods listed in @libpods for =item directives
-    foreach $libpod (@libpods) {
-	# if the page isn't defined then we won't know where to find it
-	# on the system.
-	next unless defined $pages{$libpod} &amp;&amp; $pages{$libpod};
-
-	# if there is a directory then use the .pod and .pm files within it.
-	if ($pages{$libpod} =~ /([^:]*[^(\.pod|\.pm)]):/) {
-	    #  find all the .pod and .pm files within the directory
-	    $dirname = $1;
-	    opendir(DIR, $dirname) ||
-		die &quot;$0: error opening directory $dirname: $!\n&quot;;
-	    @files = grep(/(\.pod|\.pm)$/ &amp;&amp; ! -d $_, readdir(DIR));
-	    closedir(DIR);
-
-	    # scan each .pod and .pm file for =item directives
-	    foreach $pod (@files) {
-		open(POD, &quot;&lt;$dirname/$pod&quot;) ||
-		    die &quot;$0: error opening $dirname/$pod for input: $!\n&quot;;
-		@poddata = &lt;POD&gt;;
-		close(POD);
-
-		scan_items(&quot;$dirname/$pod&quot;, @poddata);
-	    }
-
-	    # use the names of files as =item directives too.
-	    foreach $pod (@files) {
-		$pod =~ /^(.*)(\.pod|\.pm)$/;
-		$items{$1} = &quot;$dirname/$1.html&quot; if $1;
-	    }
-	} elsif ($pages{$libpod} =~ /([^:]*\.pod):/ ||
-		 $pages{$libpod} =~ /([^:]*\.pm):/) {
-	    # scan the .pod or .pm file for =item directives
-	    $pod = $1;
-	    open(POD, &quot;&lt;$pod&quot;) ||
-		die &quot;$0: error opening $pod for input: $!\n&quot;;
-	    @poddata = &lt;POD&gt;;
-	    close(POD);
-
-	    scan_items(&quot;$pod&quot;, @poddata);
-	} else {
-	    warn &quot;$0: shouldn't be here (line &quot;.__LINE__.&quot;\n&quot;;
-	}
-    }
-    @poddata = ();	# clean-up a bit
-
-    chdir($pwd)
-	|| die &quot;$0: error changing to directory $pwd: $!\n&quot;;
-
-    # cache the item list for later use
-    warn &quot;caching items for later use\n&quot; if $verbose;
-    open(CACHE, &quot;&gt;$itemcache&quot;) ||
-	die &quot;$0: error open $itemcache for writing: $!\n&quot;;
-
-    print CACHE join(&quot;:&quot;, @podpath) . &quot;\n$podroot\n&quot;;
-    foreach my $key (keys %items) {
-	print CACHE &quot;$key $items{$key}\n&quot;;
-    }
-
-    close(CACHE);
-
-    # cache the directory list for later use
-    warn &quot;caching directories for later use\n&quot; if $verbose;
-    open(CACHE, &quot;&gt;$dircache&quot;) ||
-	die &quot;$0: error open $dircache for writing: $!\n&quot;;
-
-    print CACHE join(&quot;:&quot;, @podpath) . &quot;\n$podroot\n&quot;;
-    foreach my $key (keys %pages) {
-	print CACHE &quot;$key $pages{$key}\n&quot;;
-    }
-
-    close(CACHE);
-}
-
-#
-# scan_dir - scans the directory specified in $dir for subdirectories, .pod
-#  files, and .pm files.  notes those that it finds.  this information will
-#  be used later in order to figure out where the pages specified in L&lt;&gt;
-#  links are on the filesystem.
-#
-sub scan_dir {
-    my($dir, $recurse) = @_;
-    my($t, @subdirs, @pods, $pod, $dirname, @dirs);
-    local $_;
-
-    @subdirs = ();
-    @pods = ();
-
-    opendir(DIR, $dir) ||
-	die &quot;$0: error opening directory $dir: $!\n&quot;;
-    while (defined($_ = readdir(DIR))) {
-	if (-d &quot;$dir/$_&quot; &amp;&amp; $_ ne &quot;.&quot; &amp;&amp; $_ ne &quot;..&quot;) {	    # directory
-	    $pages{$_}  = &quot;&quot; unless defined $pages{$_};
-	    $pages{$_} .= &quot;$dir/$_:&quot;;
-	    push(@subdirs, $_);
-	} elsif (/\.pod$/) {	    	    	    	    # .pod
-	    s/\.pod$//;
-	    $pages{$_}  = &quot;&quot; unless defined $pages{$_};
-	    $pages{$_} .= &quot;$dir/$_.pod:&quot;;
-	    push(@pods, &quot;$dir/$_.pod&quot;);
-	} elsif (/\.pm$/) { 	    	    	    	    # .pm
-	    s/\.pm$//;
-	    $pages{$_}  = &quot;&quot; unless defined $pages{$_};
-	    $pages{$_} .= &quot;$dir/$_.pm:&quot;;
-	    push(@pods, &quot;$dir/$_.pm&quot;);
-	}
-    }
-    closedir(DIR);
-
-    # recurse on the subdirectories if necessary
-    if ($recurse) {
-	foreach my $subdir (@subdirs) {
-	    scan_dir(&quot;$dir/$subdir&quot;, $recurse);
-	}
-    }
-}
-
-#
-# scan_headings - scan a pod file for head[1-6] tags, note the tags, and
-#  build an index.
-#
-sub scan_headings {
-    my($sections, @data) = @_;
-    my($tag, $which_head, $title, $listdepth, $index);
-
-    # here we need	local $ignore = 0;
-    #  unfortunately, we can't have it, because $ignore is lexical
-    $ignore = 0;
-
-    $listdepth = 0;
-    $index = &quot;&quot;;
-
-    # scan for =head directives, note their name, and build an index
-    #  pointing to each of them.
-    foreach my $line (@data) {
-	if ($line =~ /^=(head)([1-6])\s+(.*)/) {
-	    ($tag,$which_head, $title) = ($1,$2,$3);
-	    chomp($title);
-	    $$sections{htmlify(0,$title)} = 1;
-
-	    while ($which_head != $listdepth) {
-		if ($which_head &gt; $listdepth) {
-		    $index .= &quot;\n&quot; . (&quot;\t&quot; x $listdepth) . &quot;&lt;UL&gt;\n&quot;;
-		    $listdepth++;
-		} elsif ($which_head &lt; $listdepth) {
-		    $listdepth--;
-		    $index .= &quot;\n&quot; . (&quot;\t&quot; x $listdepth) . &quot;&lt;/UL&gt;\n&quot;;
-		}
-	    }
-
-	    $index .= &quot;\n&quot; . (&quot;\t&quot; x $listdepth) . &quot;&lt;LI&gt;&quot; .
-	              &quot;&lt;A HREF=\&quot;#&quot; . htmlify(0,$title) . &quot;\&quot;&gt;&quot; .
-		      html_escape(process_text(\$title, 0)) . &quot;&lt;/A&gt;&quot;;
-	}
-    }
-
-    # finish off the lists
-    while ($listdepth--) {
-	$index .= &quot;\n&quot; . (&quot;\t&quot; x $listdepth) . &quot;&lt;/UL&gt;\n&quot;;
-    }
-
-    # get rid of bogus lists
-    $index =~ s,\t*&lt;UL&gt;\s*&lt;/UL&gt;\n,,g;
-
-    $ignore = 1;	# restore old value;
-
-    return $index;
-}
-
-#
-# scan_items - scans the pod specified by $pod for =item directives.  we
-#  will use this information later on in resolving C&lt;&gt; links.
-#
-sub scan_items {
-    my($pod, @poddata) = @_;
-    my($i, $item);
-    local $_;
-
-    $pod =~ s/\.pod$//;
-    $pod .= &quot;.html&quot; if $pod;
-
-    foreach $i (0..$#poddata) {
-	$_ = $poddata[$i];
-
-	# remove any formatting instructions
-	s,[A-Z]&lt;([^&lt;&gt;]*)&gt;,$1,g;
-
-	# figure out what kind of item it is and get the first word of
-	#  it's name.
-	if (/^=item\s+(\w*)\s*.*$/s) {
-	    if ($1 eq &quot;*&quot;) {		# bullet list
-		/\A=item\s+\*\s*(.*?)\s*\Z/s;
-		$item = $1;
-	    } elsif ($1 =~ /^\d+/) {	# numbered list
-		/\A=item\s+\d+\.?(.*?)\s*\Z/s;
-		$item = $1;
-	    } else {
-#		/\A=item\s+(.*?)\s*\Z/s;
-		/\A=item\s+(\w*)/s;
-		$item = $1;
-	    }
-
-	    $items{$item} = &quot;$pod&quot; if $item;
-	}
-    }
-}
-
-#
-# process_head - convert a pod head[1-6] tag and convert it to HTML format.
-#
-sub process_head {
-    my($tag, $heading) = @_;
-    my $firstword;
-
-    # figure out the level of the =head
-    $tag =~ /head([1-6])/;
-    my $level = $1;
-
-    # can't have a heading full of spaces and speechmarks and so on
-    $firstword = $heading; $firstword =~ s/\s*(\w+)\s.*/$1/;
-
-    print HTML &quot;&lt;P&gt;\n&quot; unless $listlevel;
-    print HTML &quot;&lt;HR&gt;\n&quot; unless $listlevel || $top;
-    print HTML &quot;&lt;H$level&gt;&quot;; # unless $listlevel;
-    #print HTML &quot;&lt;H$level&gt;&quot; unless $listlevel;
-    my $convert = $heading; process_text(\$convert, 0);
-    $convert = html_escape($convert);
-    print HTML '&lt;A NAME=&quot;' . htmlify(0,$heading) . &quot;\&quot;&gt;$convert&lt;/A&gt;&quot;;
-    print HTML &quot;&lt;/H$level&gt;&quot;; # unless $listlevel;
-    print HTML &quot;\n&quot;;
-}
-
-#
-# process_item - convert a pod item tag and convert it to HTML format.
-#
-sub process_item {
-    my $text = $_[0];
-    my($i, $quote, $name);
-
-    my $need_preamble = 0;
-    my $this_entry;
-    my $rawtext;
-    my $rawitem;
-
-
-    # lots of documents start a list without doing an =over.  this is
-    # bad!  but, the proper thing to do seems to be to just assume
-    # they did do an =over.  so warn them once and then continue.
-    warn &quot;$0: $podfile: unexpected =item directive in paragraph $paragraph.  ignoring.\n&quot;
-	unless $listlevel;
-    process_over() unless $listlevel;
-
-    return unless $listlevel;
-
-    $need_preamble = $items_seen[$listlevel]++ == 0;
-
-    # check if this is the first =item after an =over
-    $i = $listlevel - 1;
-    my $need_new = $listlevel &gt;= @listitem;
-
-    if ($text =~ /\A\*/) {		# bullet
-
-	if ($need_preamble) {
-	    push(@listend,  &quot;&lt;/UL&gt;&quot;);
-	    print HTML &quot;&lt;UL&gt;\n&quot;;
-	}
-
-	print HTML '&lt;LI&gt;';
-	if ($text =~ /\A\*\s*(.+)\Z/s) {
-	    $text = $1;
-	    # remove formatting instructions from the text, save in $rawtext
-	    $rawtext = $text;
-	    1 while $rawtext =~ s/[A-Z]&lt;([^&lt;&gt;]*)&gt;/$1/g;
-	    pre_escape(\$rawtext);
-	    process_text(\$text);
-
-	    print HTML '&lt;STRONG&gt;';
-	    if ($items_named{$rawtext}++) {
-		print HTML $text;
-	    } else {
-		my $name = 'item_' . htmlify(1,$rawtext);
-		print HTML qq(&lt;A NAME=&quot;$name&quot;&gt;), $text, '&lt;/A&gt;';
-	    }
-	    print HTML '&lt;/STRONG&gt;';
-	}
-
-# Numbered lists disabled because this code turns every list with numerical
-# tags into an &lt;OL&gt; without looking at the actual tag values.
-# Obviously this is in general not acceptable when a &quot;RETURN VALUES&quot; or
-# &quot;EXIT CODES&quot; section is organized like this (doc/apps/smime.pod in OpenSSL).
-
-#    } elsif ($text =~ /\A[\d#]+/) {	# numbered list
-#
-#	if ($need_preamble) {
-#	    push(@listend,  &quot;&lt;/OL&gt;&quot;);
-#	    print HTML &quot;&lt;OL&gt;\n&quot;;
-#	}
-#
-#	print HTML '&lt;LI&gt;';
-#	if ($text =~ /\A\d+\.?\s*(.+)\Z/s) {
-#	    $text = $1;
-#	    # remove formatting instructions from the text, save in $rawtext
-#	    $rawtext = $text;
-#	    1 while $rawtext =~ s/[A-Z]&lt;([^&lt;&gt;]*)&gt;/$1/g;
-#	    pre_escape(\$rawtext);
-#	    process_text(\$text);
-#
-#	    print HTML '&lt;STRONG&gt;';
-#	    if ($items_named{$rawtext}++) {
-#		print HTML $text;
-#	    } else {
-#		my $name = 'item_' . htmlify(0,$rawtext);
-#		print HTML qq(&lt;A NAME=&quot;$name&quot;&gt;), $text, '&lt;/A&gt;';
-#	    }
-#	    print HTML '&lt;/STRONG&gt;';
-#	}
-
-    } else {			# all others
-
-	if ($need_preamble) {
-	    push(@listend,  '&lt;/DL&gt;');
-	    print HTML &quot;&lt;DL&gt;\n&quot;;
-	}
-
-	$rawtext = $text;
-	# remove formatting instructions from the text, save in $rawtext
-	1 while $rawtext =~ s/[A-Z]&lt;([^&lt;&gt;]*)&gt;/$1/g;
-	pre_escape(\$rawtext);
-	process_text(\$text);
-
-	print HTML '&lt;DT&gt;';
-	if ($rawtext =~ /(\S+)/) {
-	    print HTML '&lt;STRONG&gt;';
-	    if ($items_named{$1}++) {
-		print HTML $text;
-	    } else {
-		my $name = 'item_' . htmlify(1,$rawtext);
-		print HTML qq(&lt;A NAME=&quot;$name&quot;&gt;), $text, '&lt;/A&gt;';
-	    }
-	    print HTML '&lt;/STRONG&gt;';
-	}
-       print HTML '&lt;DD&gt;';
-    }
-
-    print HTML &quot;\n&quot;;
-}
-
-#
-# process_over - process a pod over tag and start a corresponding HTML
-# list.
-#
-sub process_over {
-    # start a new list
-    $listlevel++;
-}
-
-#
-# process_back - process a pod back tag and convert it to HTML format.
-#
-sub process_back {
-    warn &quot;$0: $podfile: unexpected =back directive in paragraph $paragraph.  ignoring.\n&quot;
-	unless $listlevel;
-    return unless $listlevel;
-
-    # close off the list.  note, I check to see if $listend[$listlevel] is
-    # defined because an =item directive may have never appeared and thus
-    # $listend[$listlevel] may have never been initialized.
-    $listlevel--;
-    print HTML $listend[$listlevel] if defined $listend[$listlevel];
-    print HTML &quot;\n&quot;;
-
-    # don't need the corresponding perl code anymore
-    pop(@listitem);
-    pop(@listdata);
-    pop(@listend);
-
-    pop(@items_seen);
-}
-
-#
-# process_cut - process a pod cut tag, thus stop ignoring pod directives.
-#
-sub process_cut {
-    $ignore = 1;
-}
-
-#
-# process_pod - process a pod pod tag, thus ignore pod directives until we see a
-# corresponding cut.
-#
-sub process_pod {
-    # no need to set $ignore to 0 cause the main loop did it
-}
-
-#
-# process_for - process a =for pod tag.  if it's for html, split
-# it out verbatim, if illustration, center it, otherwise ignore it.
-#
-sub process_for {
-    my($whom, $text) = @_;
-    if ( $whom =~ /^(pod2)?html$/i) {
-	print HTML $text;
-    } elsif ($whom =~ /^illustration$/i) {
-        1 while chomp $text;
-	for my $ext (qw[.png .gif .jpeg .jpg .tga .pcl .bmp]) {
-	  $text .= $ext, last if -r &quot;$text$ext&quot;;
-	}
-        print HTML qq{&lt;p align = &quot;center&quot;&gt;&lt;img src = &quot;$text&quot; alt = &quot;$text illustration&quot;&gt;&lt;/p&gt;};
-    }
-}
-
-#
-# process_begin - process a =begin pod tag.  this pushes
-# whom we're beginning on the begin stack.  if there's a
-# begin stack, we only print if it us.
-#
-sub process_begin {
-    my($whom, $text) = @_;
-    $whom = lc($whom);
-    push (@begin_stack, $whom);
-    if ( $whom =~ /^(pod2)?html$/) {
-	print HTML $text if $text;
-    }
-}
-
-#
-# process_end - process a =end pod tag.  pop the
-# begin stack.  die if we're mismatched.
-#
-sub process_end {
-    my($whom, $text) = @_;
-    $whom = lc($whom);
-    if ($begin_stack[-1] ne $whom ) {
-	die &quot;Unmatched begin/end at chunk $paragraph\n&quot;
-    } 
-    pop @begin_stack;
-}
-
-#
-# process_text - handles plaintext that appears in the input pod file.
-# there may be pod commands embedded within the text so those must be
-# converted to html commands.
-#
-sub process_text {
-    my($text, $escapeQuotes) = @_;
-    my($result, $rest, $s1, $s2, $s3, $s4, $match, $bf);
-    my($podcommand, $params, $tag, $quote);
-
-    return if $ignore;
-
-    $quote  = 0;    	    	# status of double-quote conversion
-    $result = &quot;&quot;;
-    $rest = $$text;
-
-    if ($rest =~ /^\s+/) {	# preformatted text, no pod directives
-	$rest =~ s/\n+\Z//;
-	$rest =~ s#.*#
-	    my $line = $&amp;;
-	    1 while $line =~ s/\t+/' ' x (length($&amp;) * 8 - length($`) % 8)/e;
-	    $line;
-	#eg;
-
-	$rest   =~ s/&amp;/&amp;/g;
-	$rest   =~ s/&lt;/&lt;/g;
-	$rest   =~ s/&gt;/&gt;/g;
-	$rest   =~ s/&quot;/&quot;/g;
-
-	# try and create links for all occurrences of perl.* within
-	# the preformatted text.
-	$rest =~ s{
-		    (\s*)(perl\w+)
-		  }{
-		    if (defined $pages{$2}) {	# is a link
-			qq($1&lt;A HREF=&quot;$htmlroot/$pages{$2}&quot;&gt;$2&lt;/A&gt;);
-		    } elsif (defined $pages{dosify($2)}) {	# is a link
-			qq($1&lt;A HREF=&quot;$htmlroot/$pages{dosify($2)}&quot;&gt;$2&lt;/A&gt;);
-		    } else {
-			&quot;$1$2&quot;;
-		    }
-		  }xeg;
-	$rest =~ s/(&lt;A HREF=)([^&gt;:]*:)?([^&gt;:]*)\.pod:([^&gt;:]*:)?/$1$3.html/g;
-
-  my $urls = '(' . join ('|', qw{
-                http
-                telnet
-		mailto
-		news
-                gopher
-                file
-                wais
-                ftp
-            } ) 
-        . ')';
-  
-  my $ltrs = '\w';
-  my $gunk = '/#~:.?+=&amp;%@!\-';
-  my $punc = '.:?\-';
-  my $any  = &quot;${ltrs}${gunk}${punc}&quot;;
-
-  $rest =~ s{
-        \b                          # start at word boundary
-        (                           # begin $1  {
-          $urls     :               # need resource and a colon
-          [$any] +?                 # followed by on or more
-                                    #  of any valid character, but
-                                    #  be conservative and take only
-                                    #  what you need to....
-        )                           # end   $1  }
-        (?=                         # look-ahead non-consumptive assertion
-                [$punc]*            # either 0 or more puntuation
-                [^$any]             #   followed by a non-url char
-            |                       # or else
-                $                   #   then end of the string
-        )
-      }{&lt;A HREF=&quot;$1&quot;&gt;$1&lt;/A&gt;}igox;
-
-	$result =   &quot;&lt;PRE&gt;&quot;	# text should be as it is (verbatim)
-		  . &quot;$rest\n&quot;
-		  . &quot;&lt;/PRE&gt;\n&quot;;
-    } else {			# formatted text
-	# parse through the string, stopping each time we find a
-	# pod-escape.  once the string has been throughly processed
-	# we can output it.
-	while (length $rest) {
-	    # check to see if there are any possible pod directives in
-	    # the remaining part of the text.
-	    if ($rest =~ m/[BCEIFLSZ]&lt;/) {
-		warn &quot;\$rest\t= $rest\n&quot; unless
-		    $rest =~ /\A
-			   ([^&lt;]*?)
-			   ([BCEIFLSZ]?)
-			   &lt;
-			   (.*)\Z/xs;
-
-		$s1 = $1;	# pure text
-		$s2 = $2;	# the type of pod-escape that follows
-		$s3 = '&lt;';	# '&lt;'
-		$s4 = $3;	# the rest of the string
-	    } else {
-		$s1 = $rest;
-		$s2 = &quot;&quot;;
-		$s3 = &quot;&quot;;
-		$s4 = &quot;&quot;;
-	    }
-
-	    if ($s3 eq '&lt;' &amp;&amp; $s2) {	# a pod-escape
-		$result    .= ($escapeQuotes ? process_puretext($s1, \$quote) : $s1);
-		$podcommand = &quot;$s2&lt;&quot;;
-		$rest       = $s4;
-
-		# find the matching '&gt;'
-		$match = 1;
-		$bf = 0;
-		while ($match &amp;&amp; !$bf) {
-		    $bf = 1;
-		    if ($rest =~ /\A([^&lt;&gt;]*[BCEIFLSZ]&lt;)(.*)\Z/s) {
-			$bf = 0;
-			$match++;
-			$podcommand .= $1;
-			$rest        = $2;
-		    } elsif ($rest =~ /\A([^&gt;]*&gt;)(.*)\Z/s) {
-			$bf = 0;
-			$match--;
-			$podcommand .= $1;
-			$rest        = $2;
-		    }
-		}
-
-		if ($match != 0) {
-		    warn &lt;&lt;WARN;
-$0: $podfile: cannot find matching &gt; for $s2 in paragraph $paragraph.
-WARN
-		    $result .= substr $podcommand, 0, 2;
-		    $rest = substr($podcommand, 2) . $rest;
-		    next;
-		}
-
-		# pull out the parameters to the pod-escape
-		$podcommand =~ /^([BCFEILSZ]?)&lt;(.*)&gt;$/s;
-		$tag    = $1;
-		$params = $2;
-
-		# process the text within the pod-escape so that any escapes
-		# which must occur do.
-		process_text(\$params, 0) unless $tag eq 'L';
-
-		$s1 = $params;
-		if (!$tag || $tag eq &quot; &quot;) {	#  &lt;&gt; : no tag
-		    $s1 = &quot;&lt;$params&gt;&quot;;
-		} elsif ($tag eq &quot;L&quot;) {		# L&lt;&gt; : link 
-		    $s1 = process_L($params);
-		} elsif ($tag eq &quot;I&quot; ||		# I&lt;&gt; : italicize text
-			 $tag eq &quot;B&quot; ||		# B&lt;&gt; : bold text
-			 $tag eq &quot;F&quot;) {		# F&lt;&gt; : file specification
-		    $s1 = process_BFI($tag, $params);
-		} elsif ($tag eq &quot;C&quot;) {		# C&lt;&gt; : literal code
-		    $s1 = process_C($params, 1);
-		} elsif ($tag eq &quot;E&quot;) {		# E&lt;&gt; : escape
-		    $s1 = process_E($params);
-		} elsif ($tag eq &quot;Z&quot;) {		# Z&lt;&gt; : zero-width character
-		    $s1 = process_Z($params);
-		} elsif ($tag eq &quot;S&quot;) {		# S&lt;&gt; : non-breaking space
-		    $s1 = process_S($params);
-		} elsif ($tag eq &quot;X&quot;) {		# S&lt;&gt; : non-breaking space
-		    $s1 = process_X($params);
-		} else {
-		    warn &quot;$0: $podfile: unhandled tag '$tag' in paragraph $paragraph\n&quot;;
-		}
-
-		$result .= &quot;$s1&quot;;
-	    } else {
-		# for pure text we must deal with implicit links and
-		# double-quotes among other things.
-		$result .= ($escapeQuotes ? process_puretext(&quot;$s1$s2$s3&quot;, \$quote) : &quot;$s1$s2$s3&quot;);
-		$rest    = $s4;
-	    }
-	}
-    }
-    $$text = $result;
-}
-
-sub html_escape {
-    my $rest = $_[0];
-    $rest   =~ s/&amp;/&amp;/g;
-    $rest   =~ s/&lt;/&lt;/g;
-    $rest   =~ s/&gt;/&gt;/g;
-    $rest   =~ s/&quot;/&quot;/g;
-    return $rest;
-} 
-
-#
-# process_puretext - process pure text (without pod-escapes) converting
-#  double-quotes and handling implicit C&lt;&gt; links.
-#
-sub process_puretext {
-    my($text, $quote) = @_;
-    my(@words, $result, $rest, $lead, $trail);
-
-    # convert double-quotes to single-quotes
-    $text =~ s/\A([^&quot;]*)&quot;/$1''/s if $$quote;
-    while ($text =~ s/\A([^&quot;]*)[&quot;]([^&quot;]*)[&quot;]/$1``$2''/sg) {}
-
-    $$quote = ($text =~ m/&quot;/ ? 1 : 0);
-    $text =~ s/\A([^&quot;]*)&quot;/$1``/s if $$quote;
-
-    # keep track of leading and trailing white-space
-    $lead  = ($text =~ /\A(\s*)/s ? $1 : &quot;&quot;);
-    $trail = ($text =~ /(\s*)\Z/s ? $1 : &quot;&quot;);
-
-    # collapse all white space into a single space
-    $text =~ s/\s+/ /g;
-    @words = split(&quot; &quot;, $text);
-
-    # process each word individually
-    foreach my $word (@words) {
-	# see if we can infer a link
-	if ($word =~ /^\w+\(/) {
-	    # has parenthesis so should have been a C&lt;&gt; ref
-	    $word = process_C($word);
-#	    $word =~ /^[^()]*]\(/;
-#	    if (defined $items{$1} &amp;&amp; $items{$1}) {
-#		$word =   &quot;\n&lt;CODE&gt;&lt;A HREF=\&quot;$htmlroot/$items{$1}#item_&quot;
-#			. htmlify(0,$word)
-#			. &quot;\&quot;&gt;$word&lt;/A&gt;&lt;/CODE&gt;&quot;;
-#	    } elsif (defined $items{$word} &amp;&amp; $items{$word}) {
-#		$word =   &quot;\n&lt;CODE&gt;&lt;A HREF=\&quot;$htmlroot/$items{$word}#item_&quot;
-#			. htmlify(0,$word)
-#			. &quot;\&quot;&gt;$word&lt;/A&gt;&lt;/CODE&gt;&quot;;
-#	    } else {
-#		$word =   &quot;\n&lt;CODE&gt;&lt;A HREF=\&quot;#item_&quot;
-#			. htmlify(0,$word)
-#			. &quot;\&quot;&gt;$word&lt;/A&gt;&lt;/CODE&gt;&quot;;
-#	    }
-	} elsif ($word =~ /^[\$\@%&amp;*]+\w+$/) {
-	    # perl variables, should be a C&lt;&gt; ref
-	    $word = process_C($word, 1);
-	} elsif ($word =~ m,^\w+://\w,) {
-	    # looks like a URL
-	    $word = qq(&lt;A HREF=&quot;$word&quot;&gt;$word&lt;/A&gt;);
-	} elsif ($word =~ /[\w.-]+\@[\w-]+\.\w/) {
-	    # looks like an e-mail address
-	    my ($w1, $w2, $w3) = (&quot;&quot;, $word, &quot;&quot;);
-	    ($w1, $w2, $w3) = (&quot;(&quot;, $1, &quot;)$2&quot;) if $word =~ /^\((.*?)\)(,?)/;
-	    ($w1, $w2, $w3) = (&quot;&lt;&quot;, $1, &quot;&gt;$2&quot;) if $word =~ /^&lt;(.*?)&gt;(,?)/;
-	    $word = qq($w1&lt;A HREF=&quot;mailto:$w2&quot;&gt;$w2&lt;/A&gt;$w3);
-	} elsif ($word !~ /[a-z]/ &amp;&amp; $word =~ /[A-Z]/) {  # all uppercase?
-	    $word = html_escape($word) if $word =~ /[&quot;&amp;&lt;&gt;]/;
-	    $word = &quot;\n&lt;FONT SIZE=-1&gt;$word&lt;/FONT&gt;&quot; if $netscape;
-	} else { 
-	    $word = html_escape($word) if $word =~ /[&quot;&amp;&lt;&gt;]/;
-	}
-    }
-
-    # build a new string based upon our conversion
-    $result = &quot;&quot;;
-    $rest   = join(&quot; &quot;, @words);
-    while (length($rest) &gt; 75) {
-	if ( $rest =~ m/^(.{0,75})\s(.*?)$/o ||
-	     $rest =~ m/^(\S*)\s(.*?)$/o) {
-
-	    $result .= &quot;$1\n&quot;;
-	    $rest    = $2;
-	} else {
-	    $result .= &quot;$rest\n&quot;;
-	    $rest    = &quot;&quot;;
-	}
-    }
-    $result .= $rest if $rest;
-
-    # restore the leading and trailing white-space
-    $result = &quot;$lead$result$trail&quot;;
-
-    return $result;
-}
-
-#
-# pre_escape - convert &amp; in text to $amp;
-#
-sub pre_escape {
-    my($str) = @_;
-
-    $$str =~ s,&amp;,&amp;,g;
-}
-
-#
-# dosify - convert filenames to 8.3
-#
-sub dosify {
-    my($str) = @_;
-    if ($Is83) {
-        $str = lc $str;
-        $str =~ s/(\.\w+)/substr ($1,0,4)/ge;
-        $str =~ s/(\w+)/substr ($1,0,8)/ge;
-    }
-    return $str;
-}
-
-#
-# process_L - convert a pod L&lt;&gt; directive to a corresponding HTML link.
-#  most of the links made are inferred rather than known about directly
-#  (i.e it's not known whether the =head\d section exists in the target file,
-#   or whether a .pod file exists in the case of split files).  however, the
-#  guessing usually works.
-#
-# Unlike the other directives, this should be called with an unprocessed
-# string, else tags in the link won't be matched.
-#
-sub process_L {
-    my($str) = @_;
-    my($s1, $s2, $linktext, $page, $page83, $section, $link);	# work strings
-
-    $str =~ s/\n/ /g;			# undo word-wrapped tags
-    $s1 = $str;
-    for ($s1) {
-	# LREF: a la HREF L&lt;show this text|man/section&gt;
-	$linktext = $1 if s:^([^|]+)\|::;
-
-	# make sure sections start with a /
-	s,^&quot;,/&quot;,g;
-	s,^,/,g if (!m,/, &amp;&amp; / /);
-
-	# check if there's a section specified
-	if (m,^(.*?)/&quot;?(.*?)&quot;?$,) {	# yes
-	    ($page, $section) = ($1, $2);
-	} else {			# no
-	    ($page, $section) = ($_, &quot;&quot;);
-	}
-
-	# check if we know that this is a section in this page
-	if (!defined $pages{$page} &amp;&amp; defined $sections{$page}) {
-	    $section = $page;
-	    $page = &quot;&quot;;
-	}
-    }
-
-    $page83=dosify($page);
-    $page=$page83 if (defined $pages{$page83});
-    if ($page eq &quot;&quot;) {
-	$link = &quot;#&quot; . htmlify(0,$section);
-	$linktext = $section unless defined($linktext);
-    } elsif ( $page =~ /::/ ) {
-	$linktext  = ($section ? &quot;$section&quot; : &quot;$page&quot;);
-	$page =~ s,::,/,g;
-	$link = &quot;$htmlroot/$page.html&quot;;
-	$link .= &quot;#&quot; . htmlify(0,$section) if ($section);
-    } elsif (!defined $pages{$page}) {
-	warn &quot;$0: $podfile: cannot resolve L&lt;$str&gt; in paragraph $paragraph: no such page '$page'\n&quot;;
-	$link = &quot;&quot;;
-	$linktext = $page unless defined($linktext);
-    } else {
-	$linktext  = ($section ? &quot;$section&quot; : &quot;the $page manpage&quot;) unless defined($linktext);
-	$section = htmlify(0,$section) if $section ne &quot;&quot;;
-
-	# if there is a directory by the name of the page, then assume that an
-	# appropriate section will exist in the subdirectory
-	if ($section ne &quot;&quot; &amp;&amp; $pages{$page} =~ /([^:]*[^(\.pod|\.pm)]):/) {
-	    $link = &quot;$htmlroot/$1/$section.html&quot;;
-
-	# since there is no directory by the name of the page, the section will
-	# have to exist within a .html of the same name.  thus, make sure there
-	# is a .pod or .pm that might become that .html
-	} else {
-	    $section = &quot;#$section&quot;;
-	    # check if there is a .pod with the page name
-	    if ($pages{$page} =~ /([^:]*)\.pod:/) {
-		$link = &quot;$htmlroot/$1.html$section&quot;;
-	    } elsif ($pages{$page} =~ /([^:]*)\.pm:/) {
-		$link = &quot;$htmlroot/$1.html$section&quot;;
-	    } else {
-		warn &quot;$0: $podfile: cannot resolve L$str in paragraph $paragraph: &quot;.
-			     &quot;no .pod or .pm found\n&quot;;
-		$link = &quot;&quot;;
-		$linktext = $section unless defined($linktext);
-	    }
-	}
-    }
-
-    process_text(\$linktext, 0);
-    if ($link) {
-	$s1 = &quot;&lt;A HREF=\&quot;$link\&quot;&gt;$linktext&lt;/A&gt;&quot;;
-    } else {
-	$s1 = &quot;&lt;EM&gt;$linktext&lt;/EM&gt;&quot;;
-    }
-    return $s1;
-}
-
-#
-# process_BFI - process any of the B&lt;&gt;, F&lt;&gt;, or I&lt;&gt; pod-escapes and
-# convert them to corresponding HTML directives.
-#
-sub process_BFI {
-    my($tag, $str) = @_;
-    my($s1);			# work string
-    my(%repltext) = (	'B' =&gt; 'STRONG',
-			'F' =&gt; 'EM',
-			'I' =&gt; 'EM');
-
-    # extract the modified text and convert to HTML
-    $s1 = &quot;&lt;$repltext{$tag}&gt;$str&lt;/$repltext{$tag}&gt;&quot;;
-    return $s1;
-}
-
-#
-# process_C - process the C&lt;&gt; pod-escape.
-#
-sub process_C {
-    my($str, $doref) = @_;
-    my($s1, $s2);
-
-    $s1 = $str;
-    $s1 =~ s/\([^()]*\)//g;	# delete parentheses
-    $s2 = $s1;
-    $s1 =~ s/\W//g;		# delete bogus characters
-    $str = html_escape($str);
-
-    # if there was a pod file that we found earlier with an appropriate
-    # =item directive, then create a link to that page.
-    if ($doref &amp;&amp; defined $items{$s1}) {
-	$s1 = ($items{$s1} ?
-	       &quot;&lt;A HREF=\&quot;$htmlroot/$items{$s1}#item_&quot; . htmlify(0,$s2) .  &quot;\&quot;&gt;$str&lt;/A&gt;&quot; :
-	       &quot;&lt;A HREF=\&quot;#item_&quot; . htmlify(0,$s2) .  &quot;\&quot;&gt;$str&lt;/A&gt;&quot;);
-	$s1 =~ s,(perl\w+/(\S+)\.html)#item_\2\b,$1,; 
-	confess &quot;s1 has space: $s1&quot; if $s1 =~ /HREF=&quot;[^&quot;]*\s[^&quot;]*&quot;/;
-    } else {
-	$s1 = &quot;&lt;CODE&gt;$str&lt;/CODE&gt;&quot;;
-	# warn &quot;$0: $podfile: cannot resolve C&lt;$str&gt; in paragraph $paragraph\n&quot; if $verbose
-    }
-
-
-    return $s1;
-}
-
-#
-# process_E - process the E&lt;&gt; pod directive which seems to escape a character.
-#
-sub process_E {
-    my($str) = @_;
-
-    for ($str) {
-	s,([^/].*),\&amp;$1\;,g;
-    }
-
-    return $str;
-}
-
-#
-# process_Z - process the Z&lt;&gt; pod directive which really just amounts to
-# ignoring it.  this allows someone to start a paragraph with an =
-#
-sub process_Z {
-    my($str) = @_;
-
-    # there is no equivalent in HTML for this so just ignore it.
-    $str = &quot;&quot;;
-    return $str;
-}
-
-#
-# process_S - process the S&lt;&gt; pod directive which means to convert all
-# spaces in the string to non-breaking spaces (in HTML-eze).
-#
-sub process_S {
-    my($str) = @_;
-
-    # convert all spaces in the text to non-breaking spaces in HTML.
-    $str =~ s/ /&nbsp;/g;
-    return $str;
-}
-
-#
-# process_X - this is supposed to make an index entry.  we'll just 
-# ignore it.
-#
-sub process_X {
-    return '';
-}
-
-
-#
-# finish_list - finish off any pending HTML lists.  this should be called
-# after the entire pod file has been read and converted.
-#
-sub finish_list {
-    while ($listlevel &gt; 0) {
-	print HTML &quot;&lt;/DL&gt;\n&quot;;
-	$listlevel--;
-    }
-}
-
-#
-# htmlify - converts a pod section specification to a suitable section
-# specification for HTML.  if first arg is 1, only takes 1st word.
-#
-sub htmlify {
-    my($compact, $heading) = @_;
-
-    if ($compact) {
-      $heading =~ /^(\w+)/;
-      $heading = $1;
-    } 
-
-  # $heading = lc($heading);
-  $heading =~ s/[^\w\s]/_/g;
-  $heading =~ s/(\s+)/ /g;
-  $heading =~ s/^\s*(.*?)\s*$/$1/s;
-  $heading =~ s/ /_/g;
-  $heading =~ s/\A(.{32}).*\Z/$1/s;
-  $heading =~ s/\s+\Z//;
-  $heading =~ s/_{2,}/_/g;
-
-  return $heading;
-}
-
-BEGIN {
-}
-
-1;


hooks/post-receive
-- 
OpenSSL Web Pages 
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000021.html">[openssl-commits] [web] OpenSSL Web Pages branch master updated.	4ac5045451ac48d5538f4b43ad86b837e40c461d
</A></li>
	<LI>Next message: <A HREF="000023.html">[openssl-commits] [openssl] OpenSSL source code branch master	updated. 5b17b79a895bb9eace11d4596acadaa2ed69cf2d
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#22">[ date ]</a>
              <a href="thread.html#22">[ thread ]</a>
              <a href="subject.html#22">[ subject ]</a>
              <a href="author.html#22">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://mta.opensslfoundation.net/mailman/listinfo/openssl-commits">More information about the openssl-commits
mailing list</a><br>
</body></html>
