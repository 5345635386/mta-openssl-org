<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2019-November/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1572989037.487222.31895.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="025996.html">
   <LINK REL="Next"  HREF="025998.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1572989037.487222.31895.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Tue Nov  5 21:23:57 UTC 2019</I>
    <P><UL>
        <LI>Previous message: <A HREF="025996.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="025998.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25997">[ date ]</a>
              <a href="thread.html#25997">[ thread ]</a>
              <a href="subject.html#25997">[ subject ]</a>
              <a href="author.html#25997">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  c9c4a356b778d042fee3d86f7178012ec0077205 (commit)
       via  0e52100400e647aeb5b8ac1b92c74d53918d39a0 (commit)
      from  c0e0984f125ee30820520829c4c112b1e166f871 (commit)


- Log -----------------------------------------------------------------
commit c9c4a356b778d042fee3d86f7178012ec0077205
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Oct 30 17:06:48 2019 +0100

    Minimal adaptation of tests back to how it was before
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10303">https://github.com/openssl/openssl/pull/10303</A>)

commit 0e52100400e647aeb5b8ac1b92c74d53918d39a0
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Oct 30 16:59:34 2019 +0100

    EVP: Make the SIGNATURE implementation leaner
    
    Because the algorithm to use is decided already when creating an
    EVP_PKEY_CTX regardless of how it was created, it turns out that it's
    unnecessary to provide the SIGNATURE method explicitly, and rather
    always have it be fetched implicitly.
    
    This means fewer changes for applications that want to use new
    signature algorithms / implementations.
    
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/10303">https://github.com/openssl/openssl/pull/10303</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/evp/evp_local.h               |   2 -
 crypto/evp/m_sigver.c                | 122 +++++++++++++++++++----------------
 crypto/evp/pmeth_fn.c                | 116 ++++++++++-----------------------
 doc/man3/EVP_DigestSignInit.pod      |  83 ++++++++++++------------
 doc/man3/EVP_PKEY_sign.pod           |  32 ++++-----
 doc/man3/EVP_PKEY_verify.pod         |  27 +++-----
 doc/man3/EVP_PKEY_verify_recover.pod |  37 ++++-------
 include/openssl/evp.h                |   9 +--
 test/evp_extra_test.c                |   7 +-
 util/libcrypto.num                   |   6 +-
 10 files changed, 183 insertions(+), 258 deletions(-)

diff --git a/crypto/evp/evp_local.h b/crypto/evp/evp_local.h
index 5795dcbe51..259805db80 100644
--- a/crypto/evp/evp_local.h
+++ b/crypto/evp/evp_local.h
@@ -118,8 +118,6 @@ struct evp_signature_st {
     CRYPTO_REF_COUNT refcnt;
     CRYPTO_RWLOCK *lock;
 
-    EVP_KEYMGMT *keymgmt;
-
     OSSL_OP_signature_newctx_fn *newctx;
     OSSL_OP_signature_sign_init_fn *sign_init;
     OSSL_OP_signature_sign_fn *sign;
diff --git a/crypto/evp/m_sigver.c b/crypto/evp/m_sigver.c
index c02325cf6b..7a21f680b9 100644
--- a/crypto/evp/m_sigver.c
+++ b/crypto/evp/m_sigver.c
@@ -27,9 +27,10 @@ static int update(EVP_MD_CTX *ctx, const void *data, size_t datalen)
 static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                           const EVP_MD *type, const char *mdname,
                           const char *props, ENGINE *e, EVP_PKEY *pkey,
-                          EVP_SIGNATURE *signature, int ver)
+                          int ver)
 {
     EVP_PKEY_CTX *locpctx = NULL;
+    EVP_SIGNATURE *signature = NULL;
     void *provkey = NULL;
     int ret;
 
@@ -43,51 +44,69 @@ static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
         ctx-&gt;provctx = NULL;
     }
 
-    if (ctx-&gt;pctx == NULL) {
+    if (ctx-&gt;pctx == NULL)
         ctx-&gt;pctx = EVP_PKEY_CTX_new(pkey, e);
-        if (ctx-&gt;pctx == NULL)
-            return 0;
-    } else if (pkey != NULL) {
-        if (!EVP_PKEY_up_ref(pkey))
-            return 0;
-        EVP_PKEY_free(ctx-&gt;pctx-&gt;pkey);
-        ctx-&gt;pctx-&gt;pkey = pkey;
-    }
+    if (ctx-&gt;pctx == NULL)
+        return 0;
+
     locpctx = ctx-&gt;pctx;
     evp_pkey_ctx_free_old_ops(locpctx);
-    if (locpctx-&gt;pkey == NULL)
-        goto legacy;
 
-    if (e != NULL || locpctx-&gt;engine != NULL)
+    if (locpctx-&gt;algorithm == NULL)
         goto legacy;
 
-    if (signature != NULL) {
-        if (!EVP_SIGNATURE_up_ref(signature))
-            goto err;
-    } else {
-        /*
-         * TODO(3.0): Check for legacy handling. Remove this once all all
-         * algorithms are moved to providers.
-         */
-        switch (locpctx-&gt;pkey-&gt;type) {
-        case NID_dsa:
-            break;
-        default:
-            goto legacy;
+    if (mdname == NULL) {
+        if (type != NULL) {
+            mdname = EVP_MD_name(type);
+        } else if (pkey != NULL) {
+            /*
+             * TODO(v3.0) work out a better way for EVP_PKEYs with no legacy
+             * component.
+             */
+            if (pkey-&gt;pkey.ptr != NULL) {
+                int def_nid;
+                if (EVP_PKEY_get_default_digest_nid(pkey, &amp;def_nid) &gt; 0)
+                    mdname = OBJ_nid2sn(def_nid);
+            }
         }
-        signature
-            = EVP_SIGNATURE_fetch(NULL, OBJ_nid2sn(locpctx-&gt;pkey-&gt;type), NULL);
+    }
 
-        if (signature == NULL) {
-            ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
-            goto err;
-        }
+    /*
+     * Because we cleared out old ops, we shouldn't need to worry about
+     * checking if signature is already there.  Keymgmt is a different
+     * matter, as it isn't tied to a specific EVP_PKEY op.
+     */
+    signature = EVP_SIGNATURE_fetch(locpctx-&gt;libctx, locpctx-&gt;algorithm,
+                                    locpctx-&gt;propquery);
+    if (signature != NULL &amp;&amp; locpctx-&gt;keymgmt == NULL) {
+        int name_id = EVP_SIGNATURE_number(signature);
+
+        locpctx-&gt;keymgmt =
+            evp_keymgmt_fetch_by_number(locpctx-&gt;libctx, name_id,
+                                        locpctx-&gt;propquery);
     }
-    locpctx-&gt;operation = ver ? EVP_PKEY_OP_VERIFYCTX
-                             : EVP_PKEY_OP_SIGNCTX;
+
+    if (locpctx-&gt;keymgmt == NULL
+        || signature == NULL
+        || (EVP_KEYMGMT_provider(locpctx-&gt;keymgmt)
+            != EVP_SIGNATURE_provider(signature))) {
+        /*
+         * We don't have the full support we need with provided methods,
+         * let's go see if legacy does.  Also, we don't need to free
+         * ctx-&gt;keymgmt here, as it's not necessarily tied to this
+         * operation.  It will be freed by EVP_PKEY_CTX_free().
+         */
+        EVP_SIGNATURE_free(signature);
+        goto legacy;
+    }
+
+    /* No more legacy from here down to legacy: */
 
     locpctx-&gt;op.sig.signature = signature;
 
+    locpctx-&gt;operation = ver ? EVP_PKEY_OP_VERIFYCTX
+                             : EVP_PKEY_OP_SIGNCTX;
+
     locpctx-&gt;op.sig.sigprovctx
         = signature-&gt;newctx(ossl_provider_ctx(signature-&gt;prov));
     if (locpctx-&gt;op.sig.sigprovctx == NULL) {
@@ -95,14 +114,13 @@ static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
         goto err;
     }
     provkey =
-        evp_keymgmt_export_to_provider(locpctx-&gt;pkey, signature-&gt;keymgmt, 0);
+        evp_keymgmt_export_to_provider(locpctx-&gt;pkey, locpctx-&gt;keymgmt, 0);
     if (provkey == NULL) {
         ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
         goto err;
     }
 
-    if (mdname == NULL) {
-        mdname = EVP_MD_name(type);
+    if (type != NULL) {
         ctx-&gt;reqdigest = type;
     } else {
         /*
@@ -111,11 +129,8 @@ static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
          * man pages), i.e. the ref count is not updated so the EVP_MD should
          * not be used beyound the lifetime of the EVP_MD_CTX.
          */
-        ctx-&gt;reqdigest
-            = ctx-&gt;fetched_digest
-            = EVP_MD_fetch(
-                ossl_provider_library_context(EVP_SIGNATURE_provider(signature)),
-                mdname, props);
+        ctx-&gt;reqdigest = ctx-&gt;fetched_digest =
+            EVP_MD_fetch(locpctx-&gt;libctx, mdname, props);
     }
 
     if (ver) {
@@ -123,15 +138,15 @@ static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
             ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
             goto err;
         }
-        ret = signature-&gt;digest_verify_init(locpctx-&gt;op.sig.sigprovctx, mdname,
-                                            props, provkey);
+        ret = signature-&gt;digest_verify_init(locpctx-&gt;op.sig.sigprovctx,
+                                            mdname, props, provkey);
     } else {
         if (signature-&gt;digest_sign_init == NULL) {
             ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
             goto err;
         }
-        ret = signature-&gt;digest_sign_init(locpctx-&gt;op.sig.sigprovctx, mdname,
-                                          props, provkey);
+        ret = signature-&gt;digest_sign_init(locpctx-&gt;op.sig.sigprovctx,
+                                          mdname, props, provkey);
     }
 
     return ret ? 1 : 0;
@@ -197,31 +212,28 @@ static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
 }
 
 int EVP_DigestSignInit_ex(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
-                          const char *mdname, const char *props, EVP_PKEY *pkey,
-                          EVP_SIGNATURE *signature)
+                          const char *mdname, const char *props, EVP_PKEY *pkey)
 {
-    return do_sigver_init(ctx, pctx, NULL, mdname, props, NULL, pkey, signature,
-                          0);
+    return do_sigver_init(ctx, pctx, NULL, mdname, props, NULL, pkey, 0);
 }
 
 int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                        const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey)
 {
-    return do_sigver_init(ctx, pctx, type, NULL, NULL, e, pkey, NULL, 0);
+    return do_sigver_init(ctx, pctx, type, NULL, NULL, e, pkey, 0);
 }
 
 int EVP_DigestVerifyInit_ex(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                             const char *mdname, const char *props,
-                            EVP_PKEY *pkey, EVP_SIGNATURE *signature)
+                            EVP_PKEY *pkey)
 {
-    return do_sigver_init(ctx, pctx, NULL, mdname, props, NULL, pkey, signature,
-                          1);
+    return do_sigver_init(ctx, pctx, NULL, mdname, props, NULL, pkey, 1);
 }
 
 int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                          const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey)
 {
-    return do_sigver_init(ctx, pctx, type, NULL, NULL, e, pkey, NULL, 1);
+    return do_sigver_init(ctx, pctx, type, NULL, NULL, e, pkey, 1);
 }
 #endif /* FIPS_MDOE */
 
diff --git a/crypto/evp/pmeth_fn.c b/crypto/evp/pmeth_fn.c
index d06edb218b..4a8ece5fac 100644
--- a/crypto/evp/pmeth_fn.c
+++ b/crypto/evp/pmeth_fn.c
@@ -35,39 +35,19 @@ static EVP_SIGNATURE *evp_signature_new(OSSL_PROVIDER *prov)
 static void *evp_signature_from_dispatch(int name_id,
                                          const OSSL_DISPATCH *fns,
                                          OSSL_PROVIDER *prov,
-                                         void *vkeymgmt_data)
+                                         void *unused)
 {
-    /*
-     * Signature functions cannot work without a key, and key management
-     * from the same provider to manage its keys.  We therefore fetch
-     * a key management method using the same algorithm and properties
-     * and pass that down to evp_generic_fetch to be passed on to our
-     * evp_signature_from_dispatch, which will attach the key management
-     * method to the newly created key exchange method as long as the
-     * provider matches.
-     */
-    struct keymgmt_data_st *keymgmt_data = vkeymgmt_data;
-    EVP_KEYMGMT *keymgmt =
-        evp_keymgmt_fetch_by_number(keymgmt_data-&gt;ctx, name_id,
-                                    keymgmt_data-&gt;properties);
     EVP_SIGNATURE *signature = NULL;
     int ctxfncnt = 0, signfncnt = 0, verifyfncnt = 0, verifyrecfncnt = 0;
     int digsignfncnt = 0, digverifyfncnt = 0;
     int gparamfncnt = 0, sparamfncnt = 0, gmdparamfncnt = 0, smdparamfncnt = 0;
 
-    if (keymgmt == NULL || EVP_KEYMGMT_provider(keymgmt) != prov) {
-        ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEYMGMT_AVAILABLE);
-        goto err;
-    }
-
     if ((signature = evp_signature_new(prov)) == NULL) {
         ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     signature-&gt;name_id = name_id;
-    signature-&gt;keymgmt = keymgmt;
-    keymgmt = NULL;              /* avoid double free on failure below */
 
     for (; fns-&gt;function_id != 0; fns++) {
         switch (fns-&gt;function_id) {
@@ -263,7 +243,6 @@ static void *evp_signature_from_dispatch(int name_id,
     return signature;
  err:
     EVP_SIGNATURE_free(signature);
-    EVP_KEYMGMT_free(keymgmt);
     return NULL;
 }
 
@@ -275,7 +254,6 @@ void EVP_SIGNATURE_free(EVP_SIGNATURE *signature)
         CRYPTO_DOWN_REF(&amp;signature-&gt;refcnt, &amp;i, signature-&gt;lock);
         if (i &gt; 0)
             return;
-        EVP_KEYMGMT_free(signature-&gt;keymgmt);
         ossl_provider_free(signature-&gt;prov);
         CRYPTO_THREAD_lock_free(signature-&gt;lock);
         OPENSSL_free(signature);
@@ -298,16 +276,8 @@ OSSL_PROVIDER *EVP_SIGNATURE_provider(const EVP_SIGNATURE *signature)
 EVP_SIGNATURE *EVP_SIGNATURE_fetch(OPENSSL_CTX *ctx, const char *algorithm,
                                    const char *properties)
 {
-    struct keymgmt_data_st keymgmt_data;
-
-    /*
-     * A signature operation cannot work without a key, so we need key
-     * management from the same provider to manage its keys.
-     */
-    keymgmt_data.ctx = ctx;
-    keymgmt_data.properties = properties;
     return evp_generic_fetch(ctx, OSSL_OP_SIGNATURE, algorithm, properties,
-                             evp_signature_from_dispatch, &amp;keymgmt_data,
+                             evp_signature_from_dispatch, NULL,
                              (int (*)(void *))EVP_SIGNATURE_up_ref,
                              (void (*)(void *))EVP_SIGNATURE_free);
 }
@@ -327,13 +297,9 @@ void EVP_SIGNATURE_do_all_provided(OPENSSL_CTX *libctx,
                                               void *arg),
                                    void *arg)
 {
-    struct keymgmt_data_st keymgmt_data;
-
-    keymgmt_data.ctx = libctx;
-    keymgmt_data.properties = NULL;
     evp_generic_do_all(libctx, OSSL_OP_SIGNATURE,
                        (void (*)(void *, void *))fn, arg,
-                       evp_signature_from_dispatch, &amp;keymgmt_data,
+                       evp_signature_from_dispatch, NULL,
                        (void (*)(void *))EVP_SIGNATURE_free);
 }
 
@@ -346,11 +312,11 @@ void EVP_SIGNATURE_names_do_all(const EVP_SIGNATURE *signature,
         evp_names_do_all(signature-&gt;prov, signature-&gt;name_id, fn, data);
 }
 
-static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature,
-                                   int operation)
+static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, int operation)
 {
     int ret = 0;
     void *provkey = NULL;
+    EVP_SIGNATURE *signature = NULL;
 
     if (ctx == NULL) {
         EVPerr(0, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
@@ -360,41 +326,42 @@ static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature,
     evp_pkey_ctx_free_old_ops(ctx);
     ctx-&gt;operation = operation;
 
-    if (ctx-&gt;engine != NULL)
+    if (ctx-&gt;algorithm == NULL)
         goto legacy;
 
-    if (signature != NULL) {
-        if (!EVP_SIGNATURE_up_ref(signature))
-            goto err;
-    } else {
-        int nid = ctx-&gt;pkey != NULL ? ctx-&gt;pkey-&gt;type : ctx-&gt;pmeth-&gt;pkey_id;
+    /*
+     * Because we cleared out old ops, we shouldn't need to worry about
+     * checking if signature is already there.  Keymgmt is a different
+     * matter, as it isn't tied to a specific EVP_PKEY op.
+     */
+    signature = EVP_SIGNATURE_fetch(ctx-&gt;libctx, ctx-&gt;algorithm,
+                                    ctx-&gt;propquery);
+    if (signature != NULL &amp;&amp; ctx-&gt;keymgmt == NULL) {
+        int name_id = EVP_SIGNATURE_number(signature);
+
+        ctx-&gt;keymgmt = evp_keymgmt_fetch_by_number(ctx-&gt;libctx, name_id,
+                                                   ctx-&gt;propquery);
+    }
 
+    if (ctx-&gt;keymgmt == NULL
+        || signature == NULL
+        || (EVP_KEYMGMT_provider(ctx-&gt;keymgmt)
+            != EVP_SIGNATURE_provider(signature))) {
         /*
-         * TODO(3.0): Check for legacy handling. Remove this once all all
-         * algorithms are moved to providers.
+         * We don't have the full support we need with provided methods,
+         * let's go see if legacy does.  Also, we don't need to free
+         * ctx-&gt;keymgmt here, as it's not necessarily tied to this
+         * operation.  It will be freed by EVP_PKEY_CTX_free().
          */
-        if (ctx-&gt;pkey != NULL) {
-            switch (ctx-&gt;pkey-&gt;type) {
-            case NID_dsa:
-                break;
-            default:
-                goto legacy;
-            }
-            signature = EVP_SIGNATURE_fetch(NULL, OBJ_nid2sn(nid), NULL);
-        } else {
-            goto legacy;
-        }
-
-        if (signature == NULL) {
-            EVPerr(0, EVP_R_INITIALIZATION_ERROR);
-            goto err;
-        }
+        EVP_SIGNATURE_free(signature);
+        goto legacy;
     }
 
     ctx-&gt;op.sig.signature = signature;
+
     if (ctx-&gt;pkey != NULL) {
         provkey =
-            evp_keymgmt_export_to_provider(ctx-&gt;pkey, signature-&gt;keymgmt, 0);
+            evp_keymgmt_export_to_provider(ctx-&gt;pkey, ctx-&gt;keymgmt, 0);
         if (provkey == NULL) {
             EVPerr(0, EVP_R_INITIALIZATION_ERROR);
             goto err;
@@ -483,14 +450,9 @@ static int evp_pkey_signature_init(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature,
     return ret;
 }
 
-int EVP_PKEY_sign_init_ex(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature)
-{
-    return evp_pkey_signature_init(ctx, signature, EVP_PKEY_OP_SIGN);
-}
-
 int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx)
 {
-    return evp_pkey_signature_init(ctx, NULL, EVP_PKEY_OP_SIGN);
+    return evp_pkey_signature_init(ctx, EVP_PKEY_OP_SIGN);
 }
 
 int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
@@ -527,14 +489,9 @@ int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
         return ctx-&gt;pmeth-&gt;sign(ctx, sig, siglen, tbs, tbslen);
 }
 
-int EVP_PKEY_verify_init_ex(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature)
-{
-    return evp_pkey_signature_init(ctx, signature, EVP_PKEY_OP_VERIFY);
-}
-
 int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx)
 {
-    return evp_pkey_signature_init(ctx, NULL, EVP_PKEY_OP_VERIFY);
+    return evp_pkey_signature_init(ctx, EVP_PKEY_OP_VERIFY);
 }
 
 int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
@@ -569,14 +526,9 @@ int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
     return ctx-&gt;pmeth-&gt;verify(ctx, sig, siglen, tbs, tbslen);
 }
 
-int EVP_PKEY_verify_recover_init_ex(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature)
-{
-    return evp_pkey_signature_init(ctx, signature, EVP_PKEY_OP_VERIFYRECOVER);
-}
-
 int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx)
 {
-    return evp_pkey_signature_init(ctx, NULL, EVP_PKEY_OP_VERIFYRECOVER);
+    return evp_pkey_signature_init(ctx, EVP_PKEY_OP_VERIFYRECOVER);
 }
 
 int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
diff --git a/doc/man3/EVP_DigestSignInit.pod b/doc/man3/EVP_DigestSignInit.pod
index f730ba7b03..dbcd38e7ca 100644
--- a/doc/man3/EVP_DigestSignInit.pod
+++ b/doc/man3/EVP_DigestSignInit.pod
@@ -11,7 +11,7 @@ EVP_DigestSignFinal, EVP_DigestSign - EVP signing functions
 
  int EVP_DigestSignInit_ex(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                            const char *mdname, const char *props,
-                           EVP_PKEY *pkey, EVP_SIGNATURE *signature);
+                           EVP_PKEY *pkey);
  int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                         const EVP_MD *type, ENGINE *e, EVP_PKEY *pkey);
  int EVP_DigestSignUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);
@@ -26,41 +26,38 @@ EVP_DigestSignFinal, EVP_DigestSign - EVP signing functions
 The EVP signature routines are a high level interface to digital signatures.
 Input data is digested first before the signing takes place.
 
-EVP_DigestSignInit_ex() sets up signing context B&lt;ctx&gt; to use a digest with the
-name B&lt;mdname&gt; and private key B&lt;pkey&gt;. The signature algorithm B&lt;signature&gt;
-will be used for the actual signing which must be compatible with the private
-key. The name of the digest to be used is passed to the provider of the
-signature algorithm in use. How that provider interprets the digest name is
-provider specific. The provider may implement that digest directly itself or it
-may (optionally) choose to fetch it (which could result in a digest from a
-different provider being selected). If the provider supports fetching the digest
-then it may use the B&lt;props&gt; argument for the properties to be used during the
-fetch.
-
-The B&lt;signature&gt; parameter may be NULL in which case a suitable signature
-algorithm implementation will be implicitly fetched based on the type of key in
-use. See L&lt;provider(7)&gt; for further information about providers and fetching
-algorithms.
+EVP_DigestSignInit_ex() sets up signing context I&lt;ctx&gt; to use a digest with the
+name I&lt;mdname&gt; and private key I&lt;pkey&gt;. The name of the digest to be used is
+passed to the provider of the signature algorithm in use. How that provider
+interprets the digest name is provider specific. The provider may implement
+that digest directly itself or it may (optionally) choose to fetch it (which
+could result in a digest from a different provider being selected). If the
+provider supports fetching the digest then it may use the I&lt;props&gt; argument for
+the properties to be used during the fetch.
+
+The I&lt;pkey&gt; algorithm is used to fetch a B&lt;EVP_SIGNATURE&gt; method implicitly, to
+be used for the actual signing. See L&lt;provider(7)/Implicit fetch&gt; for
+more information about implict fetches.
 
 The OpenSSL default and legacy providers support fetching digests and can fetch
 those digests from any available provider. The OpenSSL fips provider also
 supports fetching digests but will only fetch digests that are themselves
 implemented inside the fips provider.
 
-B&lt;ctx&gt; must be created with EVP_MD_CTX_new() before calling this function. If
-B&lt;pctx&gt; is not NULL, the EVP_PKEY_CTX of the signing operation will be written
-to B&lt;*pctx&gt;: this can be used to set alternative signing options. Note that any
-existing value in B&lt;*pctx&gt; is overwritten. The EVP_PKEY_CTX value returned must
-not be freed directly by the application if B&lt;ctx&gt; is not assigned an
+I&lt;ctx&gt; must be created with EVP_MD_CTX_new() before calling this function. If
+I&lt;pctx&gt; is not NULL, the EVP_PKEY_CTX of the signing operation will be written
+to I&lt;*pctx&gt;: this can be used to set alternative signing options. Note that any
+existing value in I&lt;*pctx&gt; is overwritten. The EVP_PKEY_CTX value returned must
+not be freed directly by the application if I&lt;ctx&gt; is not assigned an
 EVP_PKEY_CTX value before being passed to EVP_DigestSignInit_ex() (which means
 the EVP_PKEY_CTX is created inside EVP_DigestSignInit_ex() and it will be freed
 automatically when the EVP_MD_CTX is freed).
 
-The digest B&lt;mdname&gt; may be NULL if the signing algorithm supports it. The
-B&lt;props&gt; argument can always be NULL.
+The digest I&lt;mdname&gt; may be NULL if the signing algorithm supports it. The
+I&lt;props&gt; argument can always be NULL.
 
 No B&lt;EVP_PKEY_CTX&gt; will be created by EVP_DigestSignInit_ex() if the passed
-B&lt;ctx&gt; has already been assigned one via L&lt;EVP_MD_CTX_set_ctx(3)&gt;. See also
+I&lt;ctx&gt; has already been assigned one via L&lt;EVP_MD_CTX_set_ctx(3)&gt;. See also
 L&lt;SM2(7)&gt;.
 
 Only EVP_PKEY types that support signing can be used with these functions. This
@@ -82,7 +79,7 @@ Supports SHA1, SHA224, SHA256, SHA384, SHA512 and SM3
 
 =item RSA with no padding
 
-Supports no digests (the digest B&lt;type&gt; must be NULL)
+Supports no digests (the digest I&lt;type&gt; must be NULL)
 
 =item RSA with X931 padding
 
@@ -95,7 +92,7 @@ SHA3-224, SHA3-256, SHA3-384, SHA3-512
 
 =item Ed25519 and Ed448
 
-Support no digests (the digest B&lt;type&gt; must be NULL)
+Support no digests (the digest I&lt;type&gt; must be NULL)
 
 =item HMAC
 
@@ -110,23 +107,23 @@ Will ignore any digest provided.
 If RSA-PSS is used and restrictions apply then the digest must match.
 
 EVP_DigestSignInit() works in the same way as EVP_DigestSignInit_ex() except
-that the B&lt;mdname&gt; parameter will be inferred from the supplied digest B&lt;type&gt;,
-and B&lt;props&gt; will be NULL. Where supplied the ENGINE B&lt;e&gt; will be used for the
-signing and digest algorithm implementations. B&lt;e&gt; may be NULL.
-
-EVP_DigestSignUpdate() hashes B&lt;cnt&gt; bytes of data at B&lt;d&gt; into the
-signature context B&lt;ctx&gt;. This function can be called several times on the
-same B&lt;ctx&gt; to include additional data.
-
-EVP_DigestSignFinal() signs the data in B&lt;ctx&gt; and places the signature in B&lt;sig&gt;.
-If B&lt;sig&gt; is B&lt;NULL&gt; then the maximum size of the output buffer is written to
-the B&lt;siglen&gt; parameter. If B&lt;sig&gt; is not B&lt;NULL&gt; then before the call the
-B&lt;siglen&gt; parameter should contain the length of the B&lt;sig&gt; buffer. If the
-call is successful the signature is written to B&lt;sig&gt; and the amount of data
-written to B&lt;siglen&gt;.
-
-EVP_DigestSign() signs B&lt;tbslen&gt; bytes of data at B&lt;tbs&gt; and places the
-signature in B&lt;sig&gt; and its length in B&lt;siglen&gt; in a similar way to
+that the I&lt;mdname&gt; parameter will be inferred from the supplied digest I&lt;type&gt;,
+and I&lt;props&gt; will be NULL. Where supplied the ENGINE I&lt;e&gt; will be used for the
+signing and digest algorithm implementations. I&lt;e&gt; may be NULL.
+
+EVP_DigestSignUpdate() hashes I&lt;cnt&gt; bytes of data at I&lt;d&gt; into the
+signature context I&lt;ctx&gt;. This function can be called several times on the
+same I&lt;ctx&gt; to include additional data.
+
+EVP_DigestSignFinal() signs the data in I&lt;ctx&gt; and places the signature in I&lt;sig&gt;.
+If I&lt;sig&gt; is NULL then the maximum size of the output buffer is written to
+the I&lt;siglen&gt; parameter. If I&lt;sig&gt; is not NULL then before the call the
+I&lt;siglen&gt; parameter should contain the length of the I&lt;sig&gt; buffer. If the
+call is successful the signature is written to I&lt;sig&gt; and the amount of data
+written to I&lt;siglen&gt;.
+
+EVP_DigestSign() signs I&lt;tbslen&gt; bytes of data at I&lt;tbs&gt; and places the
+signature in I&lt;sig&gt; and its length in I&lt;siglen&gt; in a similar way to
 EVP_DigestSignFinal().
 
 =head1 RETURN VALUES
diff --git a/doc/man3/EVP_PKEY_sign.pod b/doc/man3/EVP_PKEY_sign.pod
index f30affd459..68788921da 100644
--- a/doc/man3/EVP_PKEY_sign.pod
+++ b/doc/man3/EVP_PKEY_sign.pod
@@ -2,14 +2,13 @@
 
 =head1 NAME
 
-EVP_PKEY_sign_init_ex, EVP_PKEY_sign_init, EVP_PKEY_sign
+EVP_PKEY_sign_init, EVP_PKEY_sign
 - sign using a public key algorithm
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/evp.h&gt;
 
- int EVP_PKEY_sign_init_ex(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature);
  int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
                    unsigned char *sig, size_t *siglen,
@@ -17,26 +16,19 @@ EVP_PKEY_sign_init_ex, EVP_PKEY_sign_init, EVP_PKEY_sign
 
 =head1 DESCRIPTION
 
-The EVP_PKEY_sign_init_ex() function initializes a public key algorithm
-context for performing signing using the signature algorithm B&lt;signature&gt;.
-The signature algorithm B&lt;signature&gt; should be fetched using a call to
-L&lt;EVP_SIGNATURE_fetch(3)&gt;.
-The EVP_PKEY object associated with B&lt;ctx&gt; must be compatible with that
-algorithm.
-B&lt;signature&gt; may be NULL in which case the EVP_SIGNATURE algorithm is fetched
-implicitly based on the type of EVP_PKEY associated with B&lt;ctx&gt;.
-See L&lt;provider(7)/Implicit fetch&gt; for more information about implict fetches.
-
-The EVP_PKEY_sign_init() function is the same as EVP_PKEY_sign_init_ex() except
-that the EVP_SIGNATURE algorithm is always implicitly fetched.
+EVP_PKEY_sign_init() initializes a public key algorithm context I&lt;ctx&gt; for
+signing using the algorithm given when the context was created
+using L&lt;EVP_PKEY_CTX_new(3)&gt; or variants thereof.  The algorithm is used to
+fetch a B&lt;EVP_SIGNATURE&gt; method implicitly, see L&lt;provider(7)/Implicit fetch&gt;
+for more information about implict fetches.
 
 The EVP_PKEY_sign() function performs a public key signing operation
-using B&lt;ctx&gt;. The data to be signed is specified using the B&lt;tbs&gt; and
-B&lt;tbslen&gt; parameters. If B&lt;sig&gt; is B&lt;NULL&gt; then the maximum size of the output
-buffer is written to the B&lt;siglen&gt; parameter. If B&lt;sig&gt; is not B&lt;NULL&gt; then
-before the call the B&lt;siglen&gt; parameter should contain the length of the
-B&lt;sig&gt; buffer, if the call is successful the signature is written to
-B&lt;sig&gt; and the amount of data written to B&lt;siglen&gt;.
+using I&lt;ctx&gt;. The data to be signed is specified using the I&lt;tbs&gt; and
+I&lt;tbslen&gt; parameters. If I&lt;sig&gt; is NULL then the maximum size of the output
+buffer is written to the I&lt;siglen&gt; parameter. If I&lt;sig&gt; is not NULL then
+before the call the I&lt;siglen&gt; parameter should contain the length of the
+I&lt;sig&gt; buffer, if the call is successful the signature is written to
+I&lt;sig&gt; and the amount of data written to I&lt;siglen&gt;.
 
 =head1 NOTES
 
diff --git a/doc/man3/EVP_PKEY_verify.pod b/doc/man3/EVP_PKEY_verify.pod
index 1e04a85ca9..ed63cdae84 100644
--- a/doc/man3/EVP_PKEY_verify.pod
+++ b/doc/man3/EVP_PKEY_verify.pod
@@ -2,14 +2,13 @@
 
 =head1 NAME
 
-EVP_PKEY_verify_init_ex, EVP_PKEY_verify_init, EVP_PKEY_verify
+EVP_PKEY_verify_init, EVP_PKEY_verify
 - signature verification using a public key algorithm
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/evp.h&gt;
 
- int EVP_PKEY_verify_init_ex(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature);
  int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
                      const unsigned char *sig, size_t siglen,
@@ -17,24 +16,16 @@ EVP_PKEY_verify_init_ex, EVP_PKEY_verify_init, EVP_PKEY_verify
 
 =head1 DESCRIPTION
 
-The EVP_PKEY_verify_init_ex() function initializes a public key algorithm
-context for performing signature verification using the signature algorithm
-B&lt;signature&gt;.
-The signature algorithm B&lt;signature&gt; should be fetched using a call to
-L&lt;EVP_SIGNATURE_fetch(3)&gt;.
-The EVP_PKEY object associated with B&lt;ctx&gt; must be compatible with that
-algorithm.
-B&lt;signature&gt; may be NULL in which case the EVP_SIGNATURE algorithm is fetched
-implicitly based on the type of EVP_PKEY associated with B&lt;ctx&gt;.
-See L&lt;provider(7)/Implicit fetch&gt; for more information about implict fetches.
-
-The EVP_PKEY_verify_init() function is the same as EVP_PKEY_verify_init_ex()
-except that the EVP_SIGNATURE algorithm is always implicitly fetched.
+EVP_PKEY_verify_init() initializes a public key algorithm context I&lt;ctx&gt; for
+signing using the algorithm given when the context was created
+using L&lt;EVP_PKEY_CTX_new(3)&gt; or variants thereof.  The algorithm is used to
+fetch a B&lt;EVP_SIGNATURE&gt; method implicitly, see L&lt;provider(7)/Implicit fetch&gt;
+for more information about implict fetches.
 
 The EVP_PKEY_verify() function performs a public key verification operation
-using B&lt;ctx&gt;. The signature is specified using the B&lt;sig&gt; and
-B&lt;siglen&gt; parameters. The verified data (i.e. the data believed originally
-signed) is specified using the B&lt;tbs&gt; and B&lt;tbslen&gt; parameters.
+using I&lt;ctx&gt;. The signature is specified using the I&lt;sig&gt; and
+I&lt;siglen&gt; parameters. The verified data (i.e. the data believed originally
+signed) is specified using the I&lt;tbs&gt; and I&lt;tbslen&gt; parameters.
 
 =head1 NOTES
 
diff --git a/doc/man3/EVP_PKEY_verify_recover.pod b/doc/man3/EVP_PKEY_verify_recover.pod
index 737c372dd1..8be999333b 100644
--- a/doc/man3/EVP_PKEY_verify_recover.pod
+++ b/doc/man3/EVP_PKEY_verify_recover.pod
@@ -2,15 +2,13 @@
 
 =head1 NAME
 
-EVP_PKEY_verify_recover_init_ex, EVP_PKEY_verify_recover_init,
-EVP_PKEY_verify_recover - recover signature using a public key algorithm
+EVP_PKEY_verify_recover_init, EVP_PKEY_verify_recover
+- recover signature using a public key algorithm
 
 =head1 SYNOPSIS
 
  #include &lt;openssl/evp.h&gt;
 
- int EVP_PKEY_verify_recover_init_ex(EVP_PKEY_CTX *ctx,
-                                     EVP_SIGNATURE *signature);
  int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
                              unsigned char *rout, size_t *routlen,
@@ -18,28 +16,19 @@ EVP_PKEY_verify_recover - recover signature using a public key algorithm
 
 =head1 DESCRIPTION
 
-The EVP_PKEY_verify_recover_init_ex() function initializes a public key
-algorithm context for performing signature signed data recovery using the
-signature algorithm B&lt;signature&gt;.
-The signature algorithm B&lt;signature&gt; should be fetched using a call to
-L&lt;EVP_SIGNATURE_fetch(3)&gt;.
-The EVP_PKEY object associated with B&lt;ctx&gt; must be compatible with that
-algorithm.
-B&lt;signature&gt; may be NULL in which case the EVP_SIGNATURE algorithm is fetched
-implicitly based on the type of EVP_PKEY associated with B&lt;ctx&gt;.
-See L&lt;provider(7)/Implicit fetch&gt; for more information about implict fetches.
-
-The EVP_PKEY_verify_recover_init() function is the same as
-EVP_PKEY_verify_recover_init_ex() except that the EVP_SIGNATURE algorithm is
-always implicitly fetched.
+EVP_PKEY_verify_recover_init() initializes a public key algorithm context
+I&lt;ctx&gt; for signing using the algorithm given when the context was created
+using L&lt;EVP_PKEY_CTX_new(3)&gt; or variants thereof.  The algorithm is used to
+fetch a B&lt;EVP_SIGNATURE&gt; method implicitly, see L&lt;provider(7)/Implicit fetch&gt;
+for more information about implict fetches.
 
 The EVP_PKEY_verify_recover() function recovers signed data
-using B&lt;ctx&gt;. The signature is specified using the B&lt;sig&gt; and
-B&lt;siglen&gt; parameters. If B&lt;rout&gt; is B&lt;NULL&gt; then the maximum size of the output
-buffer is written to the B&lt;routlen&gt; parameter. If B&lt;rout&gt; is not B&lt;NULL&gt; then
-before the call the B&lt;routlen&gt; parameter should contain the length of the
-B&lt;rout&gt; buffer, if the call is successful recovered data is written to
-B&lt;rout&gt; and the amount of data written to B&lt;routlen&gt;.
+using I&lt;ctx&gt;. The signature is specified using the I&lt;sig&gt; and
+I&lt;siglen&gt; parameters. If I&lt;rout&gt; is NULL then the maximum size of the output
+buffer is written to the I&lt;routlen&gt; parameter. If I&lt;rout&gt; is not NULL then
+before the call the I&lt;routlen&gt; parameter should contain the length of the
+I&lt;rout&gt; buffer, if the call is successful recovered data is written to
+I&lt;rout&gt; and the amount of data written to I&lt;routlen&gt;.
 
 =head1 NOTES
 
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 5de6f8b08e..c1c253c1e3 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -678,8 +678,8 @@ __owur int EVP_DigestVerify(EVP_MD_CTX *ctx, const unsigned char *sigret,
                             size_t tbslen);
 
 int EVP_DigestSignInit_ex(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
-                          const char *mdname, const char *props, EVP_PKEY *pkey,
-                          EVP_SIGNATURE *signature);
+                          const char *mdname, const char *props,
+                          EVP_PKEY *pkey);
 /*__owur*/ int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                                   const EVP_MD *type, ENGINE *e,
                                   EVP_PKEY *pkey);
@@ -689,7 +689,7 @@ __owur int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,
 
 int EVP_DigestVerifyInit_ex(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                             const char *mdname, const char *props,
-                            EVP_PKEY *pkey, EVP_SIGNATURE *signature);
+                            EVP_PKEY *pkey);
 __owur int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                                 const EVP_MD *type, ENGINE *e,
                                 EVP_PKEY *pkey);
@@ -1526,17 +1526,14 @@ void EVP_SIGNATURE_names_do_all(const EVP_SIGNATURE *signature,
                                 void (*fn)(const char *name, void *data),
                                 void *data);
 
-int EVP_PKEY_sign_init_ex(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature);
 int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
                   unsigned char *sig, size_t *siglen,
                   const unsigned char *tbs, size_t tbslen);
-int EVP_PKEY_verify_init_ex(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature);
 int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
                     const unsigned char *sig, size_t siglen,
                     const unsigned char *tbs, size_t tbslen);
-int EVP_PKEY_verify_recover_init_ex(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *signature);
 int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);
 int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
                             unsigned char *rout, size_t *routlen,
diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c
index cea1c318c6..e7409619fd 100644
--- a/test/evp_extra_test.c
+++ b/test/evp_extra_test.c
@@ -1237,10 +1237,8 @@ static int test_EVP_PKEY_CTX_get_set_params(void)
 
     /* Initialise a sign operation */
     ctx = EVP_PKEY_CTX_new(pkey, NULL);
-    dsaimpl = EVP_SIGNATURE_fetch(NULL, &quot;DSA&quot;, NULL);
     if (!TEST_ptr(ctx)
-            || !TEST_ptr(dsaimpl)
-            || !TEST_int_gt(EVP_PKEY_sign_init_ex(ctx, dsaimpl), 0))
+            || !TEST_int_gt(EVP_PKEY_sign_init(ctx), 0))
         goto err;
 
     /*
@@ -1299,8 +1297,7 @@ static int test_EVP_PKEY_CTX_get_set_params(void)
      */
     mdctx = EVP_MD_CTX_new();
     if (!TEST_ptr(mdctx)
-            || !TEST_true(EVP_DigestSignInit_ex(mdctx, NULL, &quot;SHA1&quot;, NULL,
-                                                pkey, dsaimpl)))
+        || !TEST_true(EVP_DigestSignInit_ex(mdctx, NULL, &quot;SHA1&quot;, NULL, pkey)))
         goto err;
 
     /*
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 737a2aba98..f63949484c 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4742,10 +4742,10 @@ EVP_SIGNATURE_free                      4858	3_0_0	EXIST::FUNCTION:
 EVP_SIGNATURE_up_ref                    4859	3_0_0	EXIST::FUNCTION:
 EVP_SIGNATURE_provider                  4860	3_0_0	EXIST::FUNCTION:
 EVP_SIGNATURE_fetch                     4861	3_0_0	EXIST::FUNCTION:
-EVP_PKEY_sign_init_ex                   4862	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_sign_init_ex                   4862	3_0_0	NOEXIST::FUNCTION:
 EVP_PKEY_CTX_set_signature_md           4863	3_0_0	EXIST::FUNCTION:
-EVP_PKEY_verify_init_ex                 4864	3_0_0	EXIST::FUNCTION:
-EVP_PKEY_verify_recover_init_ex         4865	3_0_0	EXIST::FUNCTION:
+EVP_PKEY_verify_init_ex                 4864	3_0_0	NOEXIST::FUNCTION:
+EVP_PKEY_verify_recover_init_ex         4865	3_0_0	NOEXIST::FUNCTION:
 EVP_PKEY_CTX_get_signature_md           4866	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_get_params                 4867	3_0_0	EXIST::FUNCTION:
 EVP_PKEY_CTX_gettable_params            4868	3_0_0	EXIST::FUNCTION:
</PRE>

















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="025996.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="025998.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25997">[ date ]</a>
              <a href="thread.html#25997">[ thread ]</a>
              <a href="subject.html#25997">[ subject ]</a>
              <a href="author.html#25997">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
