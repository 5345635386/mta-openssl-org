<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2015-October/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1445621615.237471.22333.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002034.html">
   <LINK REL="Next"  HREF="002041.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1445621615.237471.22333.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Fri Oct 23 17:33:35 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="002034.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="002041.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2040">[ date ]</a>
              <a href="thread.html#2040">[ thread ]</a>
              <a href="subject.html#2040">[ subject ]</a>
              <a href="author.html#2040">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  dad0b512e649336440e2b3cc9d667c56d9a91eff (commit)
      from  8cbb048c3ea416f2bd8a3706d027f3aa26ef08d9 (commit)


- Log -----------------------------------------------------------------
commit dad0b512e649336440e2b3cc9d667c56d9a91eff
Author: Alessandro Ghedini &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">alessandro at ghedini.me</A>&gt;
Date:   Fri Oct 23 17:55:27 2015 +0200

    Remove bugs/ and crypto/threads/
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 bugs/MS                         |    7 -
 bugs/SSLv3                      |   49 --
 bugs/alpha.c                    |   92 ----
 bugs/sgiccbug.c                 |   60 ---
 bugs/sslref.dif                 |   26 -
 bugs/stream.c                   |  132 -----
 bugs/ultrixcc.c                 |   44 --
 crypto/threads/mttest.c         | 1071 ---------------------------------------
 crypto/threads/netware.bat      |   79 ---
 crypto/threads/profile.sh       |    4 -
 crypto/threads/ptest.bat        |    4 -
 crypto/threads/pthread.sh       |    9 -
 crypto/threads/pthread2.sh      |    6 -
 crypto/threads/pthreads-vms.com |   14 -
 crypto/threads/purify.sh        |    4 -
 crypto/threads/solaris.sh       |    4 -
 crypto/threads/th-lock.c        |  364 -------------
 crypto/threads/win32.bat        |    4 -
 18 files changed, 1973 deletions(-)
 delete mode 100644 bugs/MS
 delete mode 100644 bugs/SSLv3
 delete mode 100644 bugs/alpha.c
 delete mode 100644 bugs/sgiccbug.c
 delete mode 100644 bugs/sslref.dif
 delete mode 100644 bugs/stream.c
 delete mode 100644 bugs/ultrixcc.c
 delete mode 100644 crypto/threads/mttest.c
 delete mode 100644 crypto/threads/netware.bat
 delete mode 100644 crypto/threads/profile.sh
 delete mode 100755 crypto/threads/ptest.bat
 delete mode 100644 crypto/threads/pthread.sh
 delete mode 100755 crypto/threads/pthread2.sh
 delete mode 100644 crypto/threads/pthreads-vms.com
 delete mode 100644 crypto/threads/purify.sh
 delete mode 100644 crypto/threads/solaris.sh
 delete mode 100644 crypto/threads/th-lock.c
 delete mode 100755 crypto/threads/win32.bat

diff --git a/bugs/MS b/bugs/MS
deleted file mode 100644
index a1dcfb9..0000000
--- a/bugs/MS
+++ /dev/null
@@ -1,7 +0,0 @@
-If you use the function that does an fopen inside the DLL, it's malloc
-will be used and when the function is then written inside, more
-hassles
-....
-
-
-think about it.
diff --git a/bugs/SSLv3 b/bugs/SSLv3
deleted file mode 100644
index a75a165..0000000
--- a/bugs/SSLv3
+++ /dev/null
@@ -1,49 +0,0 @@
-So far...
-
-ssl3.netscape.com:443 does not support client side dynamic
-session-renegotiation.
-
-ssl3.netscape.com:444 (asks for client cert) sends out all the CA RDN
-in an invalid format (the outer sequence is removed).
-
-Netscape-Commerce/1.12, when talking SSLv2, accepts a 32 byte
-challenge but then appears to only use 16 bytes when generating the
-encryption keys.  Using 16 bytes is ok but it should be ok to use 32.
-According to the SSLv3 spec, one should use 32 bytes for the challenge
-when opperating in SSLv2/v3 compatablity mode, but as mentioned above,
-this breaks this server so 16 bytes is the way to go.
-
-www.microsoft.com - when talking SSLv2, if session-id reuse is
-performed, the session-id passed back in the server-finished message
-is different from the one decided upon.
-
-ssl3.netscape.com:443, first a connection is established with RC4-MD5.
-If it is then resumed, we end up using DES-CBC3-SHA.  It should be
-RC4-MD5 according to 7.6.1.3, 'cipher_suite'.
-Netscape-Enterprise/2.01 (<A HREF="https://merchant.netscape.com">https://merchant.netscape.com</A>) has this bug.
-It only really shows up when connecting via SSLv2/v3 then reconnecting
-via SSLv3. The cipher list changes....
-NEW INFORMATION.  Try connecting with a cipher list of just
-DES-CBC-SHA:RC4-MD5.  For some weird reason, each new connection uses
-RC4-MD5, but a re-connect tries to use DES-CBC-SHA.  So netscape, when
-doing a re-connect, always takes the first cipher in the cipher list.
-
-If we accept a netscape connection, demand a client cert, have a
-non-self-signed CA which does not have it's CA in netscape, and the
-browser has a cert, it will crash/hang.  Works for 3.x and 4.xbeta
-
-Netscape browsers do not really notice the server sending a
-close notify message.  I was sending one, and then some invalid data.
-netscape complained of an invalid mac. (a fork()ed child doing a
-SSL_shutdown() and still sharing the socket with its parent).
-
-Netscape, when using export ciphers, will accept a 1024 bit temporary
-RSA key.  It is supposed to only accept 512.
-
-If Netscape connects to a server which requests a client certificate
-it will frequently hang after the user has selected one and never
-complete the connection. Hitting &quot;Stop&quot; and reload fixes this and
-all subsequent connections work fine. This appears to be because 
-Netscape wont read any new records in when it is awaiting a server
-done message at this point. The fix is to send the certificate request
-and server done messages in one record.
diff --git a/bugs/alpha.c b/bugs/alpha.c
deleted file mode 100644
index 3b4bc93..0000000
--- a/bugs/alpha.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/* bugs/alpha.c */
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-/*
- * while not exactly a bug (ASN1 C leaves this undefined) it is something to
- * watch out for.  This was fine on linux/NT/Solaris but not Alpha
- */
-
-/*-
- * it is basically an example of
- * func(*(a++),*(a++))
- * which parameter is evaluated first?  It is not defined in ASN1 C.
- */
-
-#include &lt;stdio.h&gt;
-
-#define TYPE    unsigned int
-
-void func(a, b)
-TYPE *a;
-TYPE b;
-{
-    printf(&quot;%ld -1 == %ld\n&quot;, a[0], b);
-}
-
-main()
-{
-    TYPE data[5] = { 1L, 2L, 3L, 4L, 5L };
-    TYPE *p;
-    int i;
-
-    p = data;
-
-    for (i = 0; i &lt; 4; i++) {
-        func(p, *(p++));
-    }
-}
diff --git a/bugs/sgiccbug.c b/bugs/sgiccbug.c
deleted file mode 100644
index 6b1b3d4..0000000
--- a/bugs/sgiccbug.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/* NOCW */
-/* sgibug.c */
-/* bug found by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at mincom.oz.au</A>) May 95 */
-
-#include &lt;stdio.h&gt;
-
-/*
- * This compiler bug it present on IRIX 5.3, 5.1 and 4.0.5 (these are the
- * only versions of IRIX I have access to. defining FIXBUG removes the bug.
- * (bug is still present in IRIX 6.3 according to Gage
- * &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">agage at forgetmenot.Mines.EDU</A>&gt;
- */
-
-/*-
- * Compare the output from
- * cc sgiccbug.c; ./a.out
- * and
- * cc -O sgiccbug.c; ./a.out
- */
-
-static unsigned long a[4] =
-    { 0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210 };
-static unsigned long b[4] =
-    { 0x89ABCDEF, 0xFEDCBA98, 0x76543210, 0x01234567 };
-static unsigned long c[4] =
-    { 0x77777778, 0x8ACF1357, 0x88888888, 0x7530ECA9 };
-
-main()
-{
-    unsigned long r[4];
-    sub(r, a, b);
-    fprintf(stderr, &quot;input a= %08X %08X %08X %08X\n&quot;, a[3], a[2], a[1], a[0]);
-    fprintf(stderr, &quot;input b= %08X %08X %08X %08X\n&quot;, b[3], b[2], b[1], b[0]);
-    fprintf(stderr, &quot;output = %08X %08X %08X %08X\n&quot;, r[3], r[2], r[1], r[0]);
-    fprintf(stderr, &quot;correct= %08X %08X %08X %08X\n&quot;, c[3], c[2], c[1], c[0]);
-}
-
-int sub(r, a, b)
-unsigned long *r, *a, *b;
-{
-    register unsigned long t1, t2, *ap, *bp, *rp;
-    int i, carry;
-#ifdef FIXBUG
-    unsigned long dummy;
-#endif
-
-    ap = a;
-    bp = b;
-    rp = r;
-    carry = 0;
-    for (i = 0; i &lt; 4; i++) {
-        t1 = *(ap++);
-        t2 = *(bp++);
-        t1 = (t1 - t2);
-#ifdef FIXBUG
-        dummy = t1;
-#endif
-        *(rp++) = t1 &amp; 0xffffffff;
-    }
-}
diff --git a/bugs/sslref.dif b/bugs/sslref.dif
deleted file mode 100644
index 0817009..0000000
--- a/bugs/sslref.dif
+++ /dev/null
@@ -1,26 +0,0 @@
-The February 9th, 1995 version of the SSL document differs from
-<A HREF="https://www.netscape.com">https://www.netscape.com</A> in the following ways.
-=====
-The key material for generating a SSL_CK_DES_64_CBC_WITH_MD5 key is
-KEY-MATERIAL-0 = MD5[MASTER-KEY,&quot;0&quot;,CHALLENGE,CONNECTION-ID]
-not
-KEY-MATERIAL-0 = MD5[MASTER-KEY,CHALLENGE,CONNECTION-ID]
-as specified in the documentation.
-=====
-From the section 2.6 Server Only Protocol Messages
-
-If the SESSION-ID-HIT flag is non-zero then the CERTIFICATE-TYPE,
-CERTIFICATE-LENGTH and CIPHER-SPECS-LENGTH fields will be zero. 
-
-This is not true for <A HREF="https://www.netscape.com.">https://www.netscape.com.</A>  The CERTIFICATE-TYPE
-is returned as 1.
-=====
-I have not tested the following but it is reported by <A HREF="../../../mailman/listinfo/openssl-commits.html">holtzman at mit.edu.</A>
-
-SSLref clients wait to receive a server-verify before they send a
-client-finished.  Besides this not being evident from the examples in
-2.2.1, it makes more sense to always send all packets you can before
-reading.  SSLeay was waiting in the server to receive a client-finish
-before sending the server-verify :-).  I have changed SSLeay to send a
-server-verify before trying to read the client-finished.
-
diff --git a/bugs/stream.c b/bugs/stream.c
deleted file mode 100644
index 9af2395..0000000
--- a/bugs/stream.c
+++ /dev/null
@@ -1,132 +0,0 @@
-/* bugs/stream.c */
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;openssl/rc4.h&gt;
-#ifdef OPENSSL_NO_DES
-# include &lt;des.h&gt;
-#else
-# include &lt;openssl/des.h&gt;
-#endif
-
-/*
- * show how stream ciphers are not very good.  The mac has no affect on RC4
- * while it does for cfb DES
- */
-
-main()
-{
-    fprintf(stderr, &quot;rc4\n&quot;);
-    rc4();
-    fprintf(stderr, &quot;cfb des\n&quot;);
-    des();
-}
-
-int des()
-{
-    des_key_schedule ks;
-    des_cblock iv, key;
-    int num;
-    static char *keystr = &quot;01234567&quot;;
-    static char *in1 = &quot;0123456789ABCEDFdata 12345&quot;;
-    static char *in2 = &quot;9876543210abcdefdata 12345&quot;;
-    unsigned char out[100];
-    int i;
-
-    des_set_key((des_cblock *)keystr, ks);
-
-    num = 0;
-    memset(iv, 0, 8);
-    des_cfb64_encrypt(in1, out, 26, ks, (des_cblock *)iv, &amp;num, 1);
-    for (i = 0; i &lt; 26; i++)
-        fprintf(stderr, &quot;%02X &quot;, out[i]);
-    fprintf(stderr, &quot;\n&quot;);
-
-    num = 0;
-    memset(iv, 0, 8);
-    des_cfb64_encrypt(in2, out, 26, ks, (des_cblock *)iv, &amp;num, 1);
-    for (i = 0; i &lt; 26; i++)
-        fprintf(stderr, &quot;%02X &quot;, out[i]);
-    fprintf(stderr, &quot;\n&quot;);
-}
-
-int rc4()
-{
-    static char *keystr = &quot;0123456789abcdef&quot;;
-    RC4_KEY key;
-    unsigned char in[100], out[100];
-    int i;
-
-    RC4_set_key(&amp;key, 16, keystr);
-    in[0] = '\0';
-    strcpy(in, &quot;0123456789ABCEDFdata 12345&quot;);
-    RC4(key, 26, in, out);
-
-    for (i = 0; i &lt; 26; i++)
-        fprintf(stderr, &quot;%02X &quot;, out[i]);
-    fprintf(stderr, &quot;\n&quot;);
-
-    RC4_set_key(&amp;key, 16, keystr);
-    in[0] = '\0';
-    strcpy(in, &quot;9876543210abcdefdata 12345&quot;);
-    RC4(key, 26, in, out);
-
-    for (i = 0; i &lt; 26; i++)
-        fprintf(stderr, &quot;%02X &quot;, out[i]);
-    fprintf(stderr, &quot;\n&quot;);
-}
diff --git a/bugs/ultrixcc.c b/bugs/ultrixcc.c
deleted file mode 100644
index 6e24549..0000000
--- a/bugs/ultrixcc.c
+++ /dev/null
@@ -1,44 +0,0 @@
-#include &lt;stdio.h&gt;
-
-/*-
- * This is a cc optimiser bug for ultrix 4.3, mips CPU.
- * What happens is that the compiler, due to the (a)&amp;7,
- * does
- * i=a&amp;7;
- * i--;
- * i*=4;
- * Then uses i as the offset into a jump table.
- * The problem is that a value of 0 generates an offset of
- * 0xfffffffc.
- */
-
-main()
-{
-    f(5);
-    f(0);
-}
-
-int f(a)
-int a;
-{
-    switch (a &amp; 7) {
-    case 7:
-        printf(&quot;7\n&quot;);
-    case 6:
-        printf(&quot;6\n&quot;);
-    case 5:
-        printf(&quot;5\n&quot;);
-    case 4:
-        printf(&quot;4\n&quot;);
-    case 3:
-        printf(&quot;3\n&quot;);
-    case 2:
-        printf(&quot;2\n&quot;);
-    case 1:
-        printf(&quot;1\n&quot;);
-#ifdef FIX_BUG
-    case 0:
-        ;
-#endif
-    }
-}
diff --git a/crypto/threads/mttest.c b/crypto/threads/mttest.c
deleted file mode 100644
index 914ba7b..0000000
--- a/crypto/threads/mttest.c
+++ /dev/null
@@ -1,1071 +0,0 @@
-/* crypto/threads/mttest.c */
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-#ifdef LINUX
-# include &lt;typedefs.h&gt;
-#endif
-#ifdef OPENSSL_SYS_WIN32
-# include &lt;windows.h&gt;
-#endif
-#ifdef SOLARIS
-# include &lt;synch.h&gt;
-# include &lt;thread.h&gt;
-#endif
-#ifdef IRIX
-# include &lt;ulocks.h&gt;
-# include &lt;sys/prctl.h&gt;
-#endif
-#ifdef PTHREADS
-# include &lt;pthread.h&gt;
-#endif
-#ifdef OPENSSL_SYS_NETWARE
-# if !defined __int64
-#  define __int64 long long
-# endif
-# include &lt;nwmpk.h&gt;
-#endif
-#include &lt;openssl/lhash.h&gt;
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/buffer.h&gt;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/ssl.h&gt;
-#include &lt;openssl/err.h&gt;
-#include &lt;openssl/rand.h&gt;
-
-#ifdef OPENSSL_SYS_NETWARE
-# define TEST_SERVER_CERT &quot;/openssl/apps/server.pem&quot;
-# define TEST_CLIENT_CERT &quot;/openssl/apps/client.pem&quot;
-#else
-# define TEST_SERVER_CERT &quot;../../apps/server.pem&quot;
-# define TEST_CLIENT_CERT &quot;../../apps/client.pem&quot;
-#endif
-
-#define MAX_THREAD_NUMBER       100
-
-int verify_callback(int ok, X509_STORE_CTX *xs);
-void thread_setup(void);
-void thread_cleanup(void);
-void do_threads(SSL_CTX *s_ctx, SSL_CTX *c_ctx);
-
-void irix_locking_callback(int mode, int type, const char *file, int line);
-void solaris_locking_callback(int mode, int type, const char *file, int line);
-void win32_locking_callback(int mode, int type, const char *file, int line);
-void pthreads_locking_callback(int mode, int type, const char *file, int line);
-void netware_locking_callback(int mode, int type, const char *file, int line);
-void beos_locking_callback(int mode, int type, const char *file, int line);
-
-void irix_thread_id(CRYPTO_THREADID *tid);
-void solaris_thread_id(CRYPTO_THREADID *tid);
-void pthreads_thread_id(CRYPTO_THREADID *tid);
-void netware_thread_id(CRYPTO_THREADID *tid);
-void beos_thread_id(CRYPTO_THREADID *tid);
-
-#if defined(OPENSSL_SYS_NETWARE)
-static MPKMutex *lock_cs;
-static MPKSema ThreadSem;
-static long *lock_count;
-#endif
-
-BIO *bio_err = NULL;
-BIO *bio_stdout = NULL;
-
-static char *cipher = NULL;
-int verbose = 0;
-#ifdef FIONBIO
-static int s_nbio = 0;
-#endif
-
-int thread_number = 10;
-int number_of_loops = 10;
-int reconnect = 0;
-int cache_stats = 0;
-
-static const char rnd_seed[] =
-    &quot;string to make the random number generator think it has entropy&quot;;
-
-int doit(char *ctx[4]);
-static void print_stats(BIO *bio, SSL_CTX *ctx)
-{
-    BIO_printf(bio, &quot;%4ld items in the session cache\n&quot;,
-	       SSL_CTX_sess_number(ctx));
-    BIO_printf(bio, &quot;%4d client connects (SSL_connect())\n&quot;,
-	       SSL_CTX_sess_connect(ctx));
-    BIO_printf(bio, &quot;%4d client connects that finished\n&quot;,
-	       SSL_CTX_sess_connect_good(ctx));
-    BIO_printf(bio, &quot;%4d server connects (SSL_accept())\n&quot;,
-	       SSL_CTX_sess_accept(ctx));
-    BIO_printf(bio, &quot;%4d server connects that finished\n&quot;,
-	       SSL_CTX_sess_accept_good(ctx));
-    BIO_printf(bio, &quot;%4d session cache hits\n&quot;, SSL_CTX_sess_hits(ctx));
-    BIO_printf(bio, &quot;%4d session cache misses\n&quot;, SSL_CTX_sess_misses(ctx));
-    BIO_printf(bio, &quot;%4d session cache timeouts\n&quot;, SSL_CTX_sess_timeouts(ctx));
-}
-
-static void sv_usage(void)
-{
-    BIO_printf(bio_err, &quot;usage: ssltest [args ...]\n&quot;);
-    BIO_printf(bio_err, &quot;\n&quot;);
-    BIO_printf(bio_err, &quot; -server_auth  - check server certificate\n&quot;);
-    BIO_printf(bio_err, &quot; -client_auth  - do client authentication\n&quot;);
-    BIO_printf(bio_err, &quot; -v            - more output\n&quot;);
-    BIO_printf(bio_err, &quot; -CApath arg   - PEM format directory of CA's\n&quot;);
-    BIO_printf(bio_err, &quot; -CAfile arg   - PEM format file of CA's\n&quot;);
-    BIO_printf(bio_err, &quot; -threads arg  - number of threads\n&quot;);
-    BIO_printf(bio_err, &quot; -loops arg    - number of 'connections', per thread\n&quot;);
-    BIO_printf(bio_err, &quot; -reconnect    - reuse session-id's\n&quot;);
-    BIO_printf(bio_err, &quot; -stats        - server session-id cache stats\n&quot;);
-    BIO_printf(bio_err, &quot; -cert arg     - server certificate/key\n&quot;);
-    BIO_printf(bio_err, &quot; -ccert arg    - client certificate/key\n&quot;);
-    BIO_printf(bio_err, &quot; -ssl3         - just SSLv3n\n&quot;);
-}
-
-int main(int argc, char *argv[])
-{
-    char *CApath = NULL, *CAfile = NULL;
-    int badop = 0;
-    int ret = 1;
-    int client_auth = 0;
-    int server_auth = 0;
-    SSL_CTX *s_ctx = NULL;
-    SSL_CTX *c_ctx = NULL;
-    char *scert = TEST_SERVER_CERT;
-    char *ccert = TEST_CLIENT_CERT;
-    const SSL_METHOD *ssl_method = TLS_method();
-
-    RAND_seed(rnd_seed, sizeof rnd_seed);
-
-    if (bio_err == NULL)
-        bio_err = BIO_new_fd(2, BIO_NOCLOSE);
-    if (bio_stdout == NULL)
-        bio_stdout = BIO_new_fd(1, BIO_NOCLOSE);
-    argc--;
-    argv++;
-
-    while (argc &gt;= 1) {
-        if (strcmp(*argv, &quot;-server_auth&quot;) == 0)
-            server_auth = 1;
-        else if (strcmp(*argv, &quot;-client_auth&quot;) == 0)
-            client_auth = 1;
-        else if (strcmp(*argv, &quot;-reconnect&quot;) == 0)
-            reconnect = 1;
-        else if (strcmp(*argv, &quot;-stats&quot;) == 0)
-            cache_stats = 1;
-        else if (strcmp(*argv, &quot;-ssl3&quot;) == 0)
-            ssl_method = SSLv3_method();
-        else if (strcmp(*argv, &quot;-CApath&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            CApath = *(++argv);
-        } else if (strcmp(*argv, &quot;-CAfile&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            CAfile = *(++argv);
-        } else if (strcmp(*argv, &quot;-cert&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            scert = *(++argv);
-        } else if (strcmp(*argv, &quot;-ccert&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            ccert = *(++argv);
-        } else if (strcmp(*argv, &quot;-threads&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            thread_number = atoi(*(++argv));
-            if (thread_number == 0)
-                thread_number = 1;
-            if (thread_number &gt; MAX_THREAD_NUMBER)
-                thread_number = MAX_THREAD_NUMBER;
-        } else if (strcmp(*argv, &quot;-loops&quot;) == 0) {
-            if (--argc &lt; 1)
-                goto bad;
-            number_of_loops = atoi(*(++argv));
-            if (number_of_loops == 0)
-                number_of_loops = 1;
-        } else {
-            BIO_printf(bio_err, &quot;unknown option %s\n&quot;, *argv);
-            badop = 1;
-            break;
-        }
-        argc--;
-        argv++;
-    }
-    if (badop) {
- bad:
-        sv_usage();
-        goto end;
-    }
-
-    if (cipher == NULL &amp;&amp; OPENSSL_issetugid() == 0)
-        cipher = getenv(&quot;SSL_CIPHER&quot;);
-
-    SSL_load_error_strings();
-    OpenSSL_add_ssl_algorithms();
-
-    c_ctx = SSL_CTX_new(ssl_method);
-    s_ctx = SSL_CTX_new(ssl_method);
-    if ((c_ctx == NULL) || (s_ctx == NULL)) {
-        ERR_print_errors(bio_err);
-        goto end;
-    }
-
-    SSL_CTX_set_session_cache_mode(s_ctx,
-                                   SSL_SESS_CACHE_NO_AUTO_CLEAR |
-                                   SSL_SESS_CACHE_SERVER);
-    SSL_CTX_set_session_cache_mode(c_ctx,
-                                   SSL_SESS_CACHE_NO_AUTO_CLEAR |
-                                   SSL_SESS_CACHE_SERVER);
-
-    if (!SSL_CTX_use_certificate_file(s_ctx, scert, SSL_FILETYPE_PEM)) {
-        BIO_printf(bio_err, &quot;SSL_CTX_use_certificate_file (%s)\n&quot;, scert);
-        ERR_print_errors(bio_err);
-        goto end;
-    } else
-        if (!SSL_CTX_use_RSAPrivateKey_file(s_ctx, scert, SSL_FILETYPE_PEM)) {
-        BIO_printf(bio_err, &quot;SSL_CTX_use_RSAPrivateKey_file (%s)\n&quot;, scert);
-        ERR_print_errors(bio_err);
-        goto end;
-    }
-
-    if (client_auth) {
-        SSL_CTX_use_certificate_file(c_ctx, ccert, SSL_FILETYPE_PEM);
-        SSL_CTX_use_RSAPrivateKey_file(c_ctx, ccert, SSL_FILETYPE_PEM);
-    }
-
-    if ((!SSL_CTX_load_verify_locations(s_ctx, CAfile, CApath)) ||
-        (!SSL_CTX_set_default_verify_paths(s_ctx)) ||
-        (!SSL_CTX_load_verify_locations(c_ctx, CAfile, CApath)) ||
-        (!SSL_CTX_set_default_verify_paths(c_ctx))) {
-        BIO_printf(bio_err, &quot;SSL_load_verify_locations\n&quot;);
-        ERR_print_errors(bio_err);
-        goto end;
-    }
-
-    if (client_auth) {
-        BIO_printf(bio_err, &quot;client authentication\n&quot;);
-        SSL_CTX_set_verify(s_ctx,
-                           SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
-                           verify_callback);
-    }
-    if (server_auth) {
-        BIO_printf(bio_err, &quot;server authentication\n&quot;);
-        SSL_CTX_set_verify(c_ctx, SSL_VERIFY_PEER, verify_callback);
-    }
-
-    thread_setup();
-    do_threads(s_ctx, c_ctx);
-    thread_cleanup();
- end:
-
-    if (c_ctx != NULL) {
-        BIO_printf(bio_err, &quot;Client SSL_CTX stats then free it\n&quot;);
-        print_stats(bio_err, c_ctx);
-        SSL_CTX_free(c_ctx);
-    }
-    if (s_ctx != NULL) {
-        BIO_printf(bio_err, &quot;Server SSL_CTX stats then free it\n&quot;);
-        print_stats(bio_err, s_ctx);
-        if (cache_stats) {
-            BIO_printf(bio_err, &quot;-----\n&quot;);
-            lh_SSL_SESSION_stats_bio(SSL_CTX_sessions(s_ctx), bio_err);
-            BIO_printf(bio_err, &quot;-----\n&quot;);
-    /*-     lh_SSL_SESSION_node_stats_bio(SSL_CTX_sessions(s_ctx),bio_err);
-            BIO_printf(bio_err,&quot;-----\n&quot;); */
-            lh_SSL_SESSION_node_usage_stats_bio(SSL_CTX_sessions(s_ctx), bio_err);
-            BIO_printf(bio_err, &quot;-----\n&quot;);
-        }
-        SSL_CTX_free(s_ctx);
-        BIO_printf(bio_err, &quot;done free\n&quot;);
-    }
-    exit(ret);
-    return (0);
-}
-
-#define W_READ  1
-#define W_WRITE 2
-#define C_DONE  1
-#define S_DONE  2
-
-int ndoit(SSL_CTX *ssl_ctx[2])
-{
-    int i;
-    int ret;
-    char *ctx[4];
-    CRYPTO_THREADID thread_id;
-
-    ctx[0] = (char *)ssl_ctx[0];
-    ctx[1] = (char *)ssl_ctx[1];
-
-    if (reconnect) {
-        ctx[2] = (char *)SSL_new(ssl_ctx[0]);
-        ctx[3] = (char *)SSL_new(ssl_ctx[1]);
-    } else {
-        ctx[2] = NULL;
-        ctx[3] = NULL;
-    }
-
-    CRYPTO_THREADID_current(&amp;thread_id);
-    BIO_printf(bio_stdout, &quot;started thread %lu\n&quot;,
-	       CRYPTO_THREADID_hash(&amp;thread_id));
-    for (i = 0; i &lt; number_of_loops; i++) {
-/*-     BIO_printf(bio_err,&quot;%4d %2d ctx-&gt;ref (%3d,%3d)\n&quot;,
-                   CRYPTO_THREADID_hash(&amp;thread_id),i,
-                   ssl_ctx[0]-&gt;references,
-                   ssl_ctx[1]-&gt;references); */
-/*      pthread_delay_np(&amp;tm); */
-
-        ret = doit(ctx);
-        if (ret != 0) {
-            BIO_printf(bio_stdout, &quot;error[%d] %lu - %d\n&quot;,
-                       i, CRYPTO_THREADID_hash(&amp;thread_id), ret);
-            return (ret);
-        }
-    }
-    BIO_printf(bio_stdout, &quot;DONE %lu\n&quot;, CRYPTO_THREADID_hash(&amp;thread_id));
-    if (reconnect) {
-        SSL_free((SSL *)ctx[2]);
-        SSL_free((SSL *)ctx[3]);
-    }
-#ifdef OPENSSL_SYS_NETWARE
-    MPKSemaphoreSignal(ThreadSem);
-#endif
-    return (0);
-}
-
-int doit(char *ctx[4])
-{
-    SSL_CTX *s_ctx, *c_ctx;
-    static char cbuf[200], sbuf[200];
-    SSL *c_ssl = NULL;
-    SSL *s_ssl = NULL;
-    BIO *c_to_s = NULL;
-    BIO *s_to_c = NULL;
-    BIO *c_bio = NULL;
-    BIO *s_bio = NULL;
-    int c_r, c_w, s_r, s_w;
-    int c_want, s_want;
-    int i;
-    int done = 0;
-    int c_write, s_write;
-    int do_server = 0, do_client = 0;
-
-    s_ctx = (SSL_CTX *)ctx[0];
-    c_ctx = (SSL_CTX *)ctx[1];
-
-    if (ctx[2] != NULL)
-        s_ssl = (SSL *)ctx[2];
-    else
-        s_ssl = SSL_new(s_ctx);
-
-    if (ctx[3] != NULL)
-        c_ssl = (SSL *)ctx[3];
-    else
-        c_ssl = SSL_new(c_ctx);
-
-    if ((s_ssl == NULL) || (c_ssl == NULL))
-        goto err;
-
-    c_to_s = BIO_new(BIO_s_mem());
-    s_to_c = BIO_new(BIO_s_mem());
-    if ((s_to_c == NULL) || (c_to_s == NULL))
-        goto err;
-
-    c_bio = BIO_new(BIO_f_ssl());
-    s_bio = BIO_new(BIO_f_ssl());
-    if ((c_bio == NULL) || (s_bio == NULL))
-        goto err;
-
-    SSL_set_connect_state(c_ssl);
-    SSL_set_bio(c_ssl, s_to_c, c_to_s);
-    BIO_set_ssl(c_bio, c_ssl, (ctx[2] == NULL) ? BIO_CLOSE : BIO_NOCLOSE);
-
-    SSL_set_accept_state(s_ssl);
-    SSL_set_bio(s_ssl, c_to_s, s_to_c);
-    BIO_set_ssl(s_bio, s_ssl, (ctx[3] == NULL) ? BIO_CLOSE : BIO_NOCLOSE);
-
-    c_r = 0;
-    s_r = 1;
-    c_w = 1;
-    s_w = 0;
-    c_want = W_WRITE;
-    s_want = 0;
-    c_write = 1, s_write = 0;
-
-    /* We can always do writes */
-    for (;;) {
-        do_server = 0;
-        do_client = 0;
-
-        i = (int)BIO_pending(s_bio);
-        if ((i &amp;&amp; s_r) || s_w)
-            do_server = 1;
-
-        i = (int)BIO_pending(c_bio);
-        if ((i &amp;&amp; c_r) || c_w)
-            do_client = 1;
-
-        if (do_server &amp;&amp; verbose) {
-            if (SSL_in_init(s_ssl))
-                BIO_printf(bio_stdout, &quot;server waiting in SSL_accept - %s\n&quot;,
-                           SSL_state_string_long(s_ssl));
-            else if (s_write)
-                BIO_printf(bio_stdout, &quot;server:SSL_write()\n&quot;);
-            else
-                BIO_printf(bio_stdout, &quot;server:SSL_read()\n&quot;);
-        }
-
-        if (do_client &amp;&amp; verbose) {
-            if (SSL_in_init(c_ssl))
-                BIO_printf(bio_stdout, &quot;client waiting in SSL_connect - %s\n&quot;,
-                           SSL_state_string_long(c_ssl));
-            else if (c_write)
-                BIO_printf(bio_stdout, &quot;client:SSL_write()\n&quot;);
-            else
-                BIO_printf(bio_stdout, &quot;client:SSL_read()\n&quot;);
-        }
-
-        if (!do_client &amp;&amp; !do_server) {
-            BIO_printf(bio_stdout, &quot;ERROR IN STARTUP\n&quot;);
-            break;
-        }
-        if (do_client &amp;&amp; !(done &amp; C_DONE)) {
-            if (c_write) {
-                i = BIO_write(c_bio, &quot;hello from client\n&quot;, 18);
-                if (i &lt; 0) {
-                    c_r = 0;
-                    c_w = 0;
-                    if (BIO_should_retry(c_bio)) {
-                        if (BIO_should_read(c_bio))
-                            c_r = 1;
-                        if (BIO_should_write(c_bio))
-                            c_w = 1;
-                    } else {
-                        BIO_printf(bio_err, &quot;ERROR in CLIENT\n&quot;);
-                        ERR_print_errors_fp(stderr);
-                        return (1);
-                    }
-                } else if (i == 0) {
-                    BIO_printf(bio_err, &quot;SSL CLIENT STARTUP FAILED\n&quot;);
-                    return (1);
-                } else {
-                    /* ok */
-                    c_write = 0;
-                }
-            } else {
-                i = BIO_read(c_bio, cbuf, 100);
-                if (i &lt; 0) {
-                    c_r = 0;
-                    c_w = 0;
-                    if (BIO_should_retry(c_bio)) {
-                        if (BIO_should_read(c_bio))
-                            c_r = 1;
-                        if (BIO_should_write(c_bio))
-                            c_w = 1;
-                    } else {
-                        BIO_printf(bio_err, &quot;ERROR in CLIENT\n&quot;);
-                        ERR_print_errors_fp(stderr);
-                        return (1);
-                    }
-                } else if (i == 0) {
-                    BIO_printf(bio_err, &quot;SSL CLIENT STARTUP FAILED\n&quot;);
-                    return (1);
-                } else {
-                    done |= C_DONE;
-                }
-            }
-        }
-
-        if (do_server &amp;&amp; !(done &amp; S_DONE)) {
-            if (!s_write) {
-                i = BIO_read(s_bio, sbuf, 100);
-                if (i &lt; 0) {
-                    s_r = 0;
-                    s_w = 0;
-                    if (BIO_should_retry(s_bio)) {
-                        if (BIO_should_read(s_bio))
-                            s_r = 1;
-                        if (BIO_should_write(s_bio))
-                            s_w = 1;
-                    } else {
-                        BIO_printf(bio_err, &quot;ERROR in SERVER\n&quot;);
-                        ERR_print_errors_fp(stderr);
-                        return (1);
-                    }
-                } else if (i == 0) {
-                    BIO_printf(bio_err, &quot;SSL SERVER STARTUP FAILED\n&quot;);
-                    return (1);
-                } else {
-                    s_write = 1;
-                    s_w = 1;
-                }
-            } else {
-                i = BIO_write(s_bio, &quot;hello from server\n&quot;, 18);
-                if (i &lt; 0) {
-                    s_r = 0;
-                    s_w = 0;
-                    if (BIO_should_retry(s_bio)) {
-                        if (BIO_should_read(s_bio))
-                            s_r = 1;
-                        if (BIO_should_write(s_bio))
-                            s_w = 1;
-                    } else {
-                        BIO_printf(bio_err, &quot;ERROR in SERVER\n&quot;);
-                        ERR_print_errors_fp(stderr);
-                        return (1);
-                    }
-                } else if (i == 0) {
-                    BIO_printf(bio_err, &quot;SSL SERVER STARTUP FAILED\n&quot;);
-                    return (1);
-                } else {
-                    s_write = 0;
-                    s_r = 1;
-                    done |= S_DONE;
-                }
-            }
-        }
-
-        if ((done &amp; S_DONE) &amp;&amp; (done &amp; C_DONE))
-            break;
-#if defined(OPENSSL_SYS_NETWARE)
-        ThreadSwitchWithDelay();
-#endif
-    }
-
-    SSL_set_shutdown(c_ssl, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
-    SSL_set_shutdown(s_ssl, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);
-
- err:
-#if 0
-    /*
-     * We have to set the BIO's to NULL otherwise they will be free()ed
-     * twice.  Once when th s_ssl is SSL_free()ed and again when c_ssl is
-     * SSL_free()ed. This is a hack required because s_ssl and c_ssl are
-     * sharing the same BIO structure and SSL_set_bio() and SSL_free()
-     * automatically BIO_free non NULL entries. You should not normally do
-     * this or be required to do this
-     */
-
-    if (s_ssl != NULL) {
-        s_ssl-&gt;rbio = NULL;
-        s_ssl-&gt;wbio = NULL;
-    }
-    if (c_ssl != NULL) {
-        c_ssl-&gt;rbio = NULL;
-        c_ssl-&gt;wbio = NULL;
-    }
-
-    /* The SSL's are optionally freed in the following calls */
-    BIO_free(c_to_s);
-    BIO_free(s_to_c);
-#endif
-
-    BIO_free(c_bio);
-    BIO_free(s_bio);
-    return (0);
-}
-
-int verify_callback(int ok, X509_STORE_CTX *ctx)
-{
-    char *s, buf[256];
-
-    if (verbose) {
-        s = X509_NAME_oneline(X509_get_subject_name(ctx-&gt;current_cert),
-                              buf, 256);
-        if (s != NULL) {
-            if (ok)
-                BIO_printf(bio_err, &quot;depth=%d %s\n&quot;, ctx-&gt;error_depth, buf);
-            else
-                BIO_printf(bio_err, &quot;depth=%d error=%d %s\n&quot;,
-                        ctx-&gt;error_depth, ctx-&gt;error, buf);
-        }
-    }
-    return (ok);
-}
-
-#define THREAD_STACK_SIZE (16*1024)
-
-#ifdef OPENSSL_SYS_WIN32
-
-static HANDLE *lock_cs;
-
-void thread_setup(void)
-{
-    int i;
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(HANDLE));
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_cs[i] = CreateMutex(NULL, FALSE, NULL);
-    }
-
-    CRYPTO_set_locking_callback((void (*)(int, int, char *, int))
-                                win32_locking_callback);
-    /* id callback defined */
-}
-
-void thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++)
-        CloseHandle(lock_cs[i]);
-    OPENSSL_free(lock_cs);
-}
-
-void win32_locking_callback(int mode, int type, const char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        WaitForSingleObject(lock_cs[type], INFINITE);
-    } else {
-        ReleaseMutex(lock_cs[type]);
-    }
-}
-
-void do_threads(SSL_CTX *s_ctx, SSL_CTX *c_ctx)
-{
-    double ret;
-    SSL_CTX *ssl_ctx[2];
-    DWORD thread_id[MAX_THREAD_NUMBER];
-    HANDLE thread_handle[MAX_THREAD_NUMBER];
-    int i;
-    SYSTEMTIME start, end;
-
-    ssl_ctx[0] = s_ctx;
-    ssl_ctx[1] = c_ctx;
-
-    GetSystemTime(&amp;start);
-    for (i = 0; i &lt; thread_number; i++) {
-        thread_handle[i] = CreateThread(NULL,
-                                        THREAD_STACK_SIZE,
-                                        (LPTHREAD_START_ROUTINE) ndoit,
-                                        (void *)ssl_ctx, 0L, &amp;(thread_id[i]));
-    }
-
-    BIO_printf(bio_stdout, &quot;reaping\n&quot;);
-    for (i = 0; i &lt; thread_number; i += 50) {
-        int j;
-
-        j = (thread_number &lt; (i + 50)) ? (thread_number - i) : 50;
-
-        if (WaitForMultipleObjects(j,
-                                   (CONST HANDLE *) &amp; (thread_handle[i]),
-                                   TRUE, INFINITE)
-            == WAIT_FAILED) {
-            BIO_printf(bio_err, &quot;WaitForMultipleObjects failed:%d\n&quot;,
-                    GetLastError());
-            exit(1);
-        }
-    }
-    GetSystemTime(&amp;end);
-
-    if (start.wDayOfWeek &gt; end.wDayOfWeek)
-        end.wDayOfWeek += 7;
-    ret = (end.wDayOfWeek - start.wDayOfWeek) * 24;
-
-    ret = (ret + end.wHour - start.wHour) * 60;
-    ret = (ret + end.wMinute - start.wMinute) * 60;
-    ret = (ret + end.wSecond - start.wSecond);
-    ret += (end.wMilliseconds - start.wMilliseconds) / 1000.0;
-
-    BIO_printf(bio_stdout, &quot;win32 threads done - %.3f seconds\n&quot;, ret);
-}
-
-#endif                          /* OPENSSL_SYS_WIN32 */
-
-#ifdef SOLARIS
-
-static mutex_t *lock_cs;
-/*
- * static rwlock_t *lock_cs;
- */
-static long *lock_count;
-
-void thread_setup(void)
-{
-    int i;
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(mutex_t));
-    lock_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_count[i] = 0;
-        /* rwlock_init(&amp;(lock_cs[i]),USYNC_THREAD,NULL); */
-        mutex_init(&amp;(lock_cs[i]), USYNC_THREAD, NULL);
-    }
-
-    CRYPTO_set_id_callback(solaris_thread_id);
-    CRYPTO_set_locking_callback(solaris_locking_callback);
-}
-
-void thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-
-    BIO_printf(bio_err, &quot;cleanup\n&quot;);
-
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        /* rwlock_destroy(&amp;(lock_cs[i])); */
-        mutex_destroy(&amp;(lock_cs[i]));
-        BIO_printf(bio_err, &quot;%8ld:%s\n&quot;, lock_count[i], CRYPTO_get_lock_name(i));
-    }
-    OPENSSL_free(lock_cs);
-    OPENSSL_free(lock_count);
-
-    BIO_printf(bio_err, &quot;done cleanup\n&quot;);
-
-}
-
-void solaris_locking_callback(int mode, int type, const char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        mutex_lock(&amp;(lock_cs[type]));
-        lock_count[type]++;
-    } else {
-        mutex_unlock(&amp;(lock_cs[type]));
-    }
-}
-
-void do_threads(SSL_CTX *s_ctx, SSL_CTX *c_ctx)
-{
-    SSL_CTX *ssl_ctx[2];
-    thread_t thread_ctx[MAX_THREAD_NUMBER];
-    int i;
-
-    ssl_ctx[0] = s_ctx;
-    ssl_ctx[1] = c_ctx;
-
-    thr_setconcurrency(thread_number);
-    for (i = 0; i &lt; thread_number; i++) {
-        thr_create(NULL, THREAD_STACK_SIZE,
-                   (void *(*)())ndoit, (void *)ssl_ctx, 0L, &amp;(thread_ctx[i]));
-    }
-
-    BIO_printf(bio_stdout, &quot;reaping\n&quot;);
-    for (i = 0; i &lt; thread_number; i++) {
-        thr_join(thread_ctx[i], NULL, NULL);
-    }
-
-#if 0 /* We can't currently find out the reference amount */
-    BIO_printf(bio_stdout, &quot;solaris threads done (%d,%d)\n&quot;,
-               s_ctx-&gt;references, c_ctx-&gt;references);
-#else
-    BIO_printf(bio_stdout, &quot;solaris threads done\n&quot;);
-#endif
-}
-
-void solaris_thread_id(CRYPTO_THREADID *tid)
-{
-    CRYPTO_THREADID_set_numeric((unsigned long)thr_self());
-}
-#endif                          /* SOLARIS */
-
-#ifdef IRIX
-
-static usptr_t *arena;
-static usema_t **lock_cs;
-
-void thread_setup(void)
-{
-    int i;
-    char filename[20];
-
-    strcpy(filename, &quot;/tmp/mttest.XXXXXX&quot;);
-    mktemp(filename);
-
-    usconfig(CONF_STHREADIOOFF);
-    usconfig(CONF_STHREADMALLOCOFF);
-    usconfig(CONF_INITUSERS, 100);
-    usconfig(CONF_LOCKTYPE, US_DEBUGPLUS);
-    arena = usinit(filename);
-    unlink(filename);
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(usema_t *));
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_cs[i] = usnewsema(arena, 1);
-    }
-
-    CRYPTO_set_id_callback(irix_thread_id);
-    CRYPTO_set_locking_callback(irix_locking_callback);
-}
-
-void thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        char buf[10];
-
-        sprintf(buf, &quot;%2d:&quot;, i);
-        usdumpsema(lock_cs[i], stdout, buf);
-        usfreesema(lock_cs[i], arena);
-    }
-    OPENSSL_free(lock_cs);
-}
-
-void irix_locking_callback(int mode, int type, const char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        BIO_printf(bio_stdout, &quot;lock %d\n&quot;, type);
-        uspsema(lock_cs[type]);
-    } else {
-        BIO_printf(bio_stdout, &quot;unlock %d\n&quot;, type);
-        usvsema(lock_cs[type]);
-    }
-}
-
-void do_threads(SSL_CTX *s_ctx, SSL_CTX *c_ctx)
-{
-    SSL_CTX *ssl_ctx[2];
-    int thread_ctx[MAX_THREAD_NUMBER];
-    int i;
-
-    ssl_ctx[0] = s_ctx;
-    ssl_ctx[1] = c_ctx;
-
-    for (i = 0; i &lt; thread_number; i++) {
-        thread_ctx[i] = sproc((void (*)())ndoit,
-                              PR_SADDR | PR_SFDS, (void *)ssl_ctx);
-    }
-
-    BIO_printf(bio_stdout, &quot;reaping\n&quot;);
-    for (i = 0; i &lt; thread_number; i++) {
-        wait(NULL);
-    }
-
-#if 0 /* We can't currently find out the reference amount */
-    BIO_printf(bio_stdout, &quot;irix threads done (%d,%d)\n&quot;,
-               s_ctx-&gt;references, c_ctx-&gt;references);
-#else
-    BIO_printf(bio_stdout, &quot;irix threads done\n&quot;);
-#endif
-}
-
-unsigned long irix_thread_id(void)
-{
-    CRYPTO_THREADID_set_numeric((unsigned long)getpid());
-}
-#endif                          /* IRIX */
-
-#ifdef PTHREADS
-
-static pthread_mutex_t *lock_cs;
-static long *lock_count;
-
-void thread_setup(void)
-{
-    int i;
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));
-    lock_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_count[i] = 0;
-        pthread_mutex_init(&amp;(lock_cs[i]), NULL);
-    }
-
-    CRYPTO_THREADID_set_callback(pthreads_thread_id);
-    CRYPTO_set_locking_callback(pthreads_locking_callback);
-}
-
-void thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    BIO_printf(bio_err, &quot;cleanup\n&quot;);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        pthread_mutex_destroy(&amp;(lock_cs[i]));
-        BIO_printf(bio_err, &quot;%8ld:%s\n&quot;, lock_count[i], CRYPTO_get_lock_name(i));
-    }
-    OPENSSL_free(lock_cs);
-    OPENSSL_free(lock_count);
-
-    BIO_printf(bio_err, &quot;done cleanup\n&quot;);
-}
-
-void pthreads_locking_callback(int mode, int type, const char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        pthread_mutex_lock(&amp;(lock_cs[type]));
-        lock_count[type]++;
-    } else {
-        pthread_mutex_unlock(&amp;(lock_cs[type]));
-    }
-}
-
-void do_threads(SSL_CTX *s_ctx, SSL_CTX *c_ctx)
-{
-    SSL_CTX *ssl_ctx[2];
-    pthread_t thread_ctx[MAX_THREAD_NUMBER];
-    int i;
-
-    ssl_ctx[0] = s_ctx;
-    ssl_ctx[1] = c_ctx;
-
-    /*
-     * thr_setconcurrency(thread_number);
-     */
-    for (i = 0; i &lt; thread_number; i++) {
-        pthread_create(&amp;(thread_ctx[i]), NULL,
-                       (void *(*)())ndoit, (void *)ssl_ctx);
-    }
-
-    BIO_printf(bio_stdout, &quot;reaping\n&quot;);
-    for (i = 0; i &lt; thread_number; i++) {
-        pthread_join(thread_ctx[i], NULL);
-    }
-
-#if 0 /* We can't currently find out the reference amount */
-    BIO_printf(bio_stdout, &quot;pthreads threads done (%d,%d)\n&quot;,
-               s_ctx-&gt;references, c_ctx-&gt;references);
-#else
-    BIO_printf(bio_stdout, &quot;pthreads threads done\n&quot;);
-#endif
-}
-
-void pthreads_thread_id(CRYPTO_THREADID *tid)
-{
-    CRYPTO_THREADID_set_numeric(tid, (unsigned long)pthread_self());
-}
-
-#endif                          /* PTHREADS */
-
-#ifdef OPENSSL_SYS_NETWARE
-
-void thread_setup(void)
-{
-    int i;
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(MPKMutex));
-    lock_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_count[i] = 0;
-        lock_cs[i] = MPKMutexAlloc(&quot;OpenSSL mutex&quot;);
-    }
-
-    ThreadSem = MPKSemaphoreAlloc(&quot;OpenSSL mttest semaphore&quot;, 0);
-
-    CRYPTO_set_id_callback(netware_thread_id);
-    CRYPTO_set_locking_callback(netware_locking_callback);
-}
-
-void thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-
-    BIO_printf(bio_stdout, &quot;thread_cleanup\n&quot;);
-
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        MPKMutexFree(lock_cs[i]);
-        BIO_printf(bio_stdout, &quot;%8ld:%s\n&quot;, lock_count[i], CRYPTO_get_lock_name(i));
-    }
-    OPENSSL_free(lock_cs);
-    OPENSSL_free(lock_count);
-
-    MPKSemaphoreFree(ThreadSem);
-
-    BIO_printf(bio_stdout, &quot;done cleanup\n&quot;);
-}
-
-void netware_locking_callback(int mode, int type, const char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        MPKMutexLock(lock_cs[type]);
-        lock_count[type]++;
-    } else
-        MPKMutexUnlock(lock_cs[type]);
-}
-
-void do_threads(SSL_CTX *s_ctx, SSL_CTX *c_ctx)
-{
-    SSL_CTX *ssl_ctx[2];
-    int i;
-    ssl_ctx[0] = s_ctx;
-    ssl_ctx[1] = c_ctx;
-
-    for (i = 0; i &lt; thread_number; i++) {
-        BeginThread((void (*)(void *))ndoit, NULL, THREAD_STACK_SIZE,
-                    (void *)ssl_ctx);
-        ThreadSwitchWithDelay();
-    }
-
-    BIO_printf(bio_stdout, &quot;reaping\n&quot;);
-
-    /* loop until all threads have signaled the semaphore */
-    for (i = 0; i &lt; thread_number; i++) {
-        MPKSemaphoreWait(ThreadSem);
-    }
-#if 0 /* We can't currently find out the reference amount */
-    BIO_printf(bio_stdout, &quot;netware threads done (%d,%d)\n&quot;,
-               s_ctx-&gt;references, c_ctx-&gt;references);
-#else
-    BIO_printf(bio_stdout, &quot;netware threads done\n&quot;);
-#endif
-}
-
-unsigned long netware_thread_id(void)
-{
-    CRYPTO_THREADID_set_numeric((unsigned long)GetThreadID());
-}
-#endif                          /* NETWARE */
diff --git a/crypto/threads/netware.bat b/crypto/threads/netware.bat
deleted file mode 100644
index 0b3eca3..0000000
--- a/crypto/threads/netware.bat
+++ /dev/null
@@ -1,79 +0,0 @@
<A HREF="../../../mailman/listinfo/openssl-commits.html">- at echo</A> off
-rem batch file to build multi-thread test ( mttest.nlm )
-
-rem command line arguments:
-rem      debug =&gt; build using debug settings
-
-rem
-rem After building, copy mttest.nlm to the server and run it, you'll probably
-rem want to redirect stdout and stderr.  An example command line would be
-rem &quot;mttest.nlm -thread 20 -loops 10 -CAfile \openssl\apps\server.pem &gt;mttest.out 2&gt;mttest.err&quot;
-rem 
-
-del mttest.nlm
-
-set BLD_DEBUG=
-set CFLAGS=
-set LFLAGS=
-set LIBS=
-
-if &quot;%1&quot; == &quot;DEBUG&quot; set BLD_DEBUG=YES
-if &quot;%1&quot; == &quot;debug&quot; set BLD_DEBUG=YES
-
-if &quot;%MWCIncludes%&quot; == &quot;&quot; goto inc_error
-if &quot;%PRELUDE%&quot; == &quot;&quot; goto prelude_error
-if &quot;%IMPORTS%&quot; == &quot;&quot; goto imports_error
-
-set CFLAGS=-c -I..\..\outinc_nw -nosyspath -DOPENSSL_SYS_NETWARE -opt off -g -sym internal -maxerrors 20
-
-if &quot;%BLD_DEBUG%&quot; == &quot;YES&quot; set LIBS=..\..\out_nw.dbg\ssl.lib ..\..\out_nw.dbg\crypto.lib
-if &quot;%BLD_DEBUG%&quot; == &quot;&quot;  set LIBS=..\..\out_nw\ssl.lib ..\..\out_nw\crypto.lib
-
-set LFLAGS=-msgstyle gcc -zerobss -stacksize 32768 -nostdlib -sym internal 
-  
-rem generate command file for metrowerks
-echo.
-echo Generating Metrowerks command file: mttest.def
-echo # dynamically generated command file for metrowerks build &gt; mttest.def
-echo IMPORT @%IMPORTS%\clib.imp              &gt;&gt; mttest.def 
-echo IMPORT @%IMPORTS%\threads.imp           &gt;&gt; mttest.def 
-echo IMPORT @%IMPORTS%\ws2nlm.imp            &gt;&gt; mttest.def 
-echo IMPORT GetProcessSwitchCount            &gt;&gt; mttest.def
-echo MODULE clib                             &gt;&gt; mttest.def 
-
-rem compile
-echo.
-echo Compiling mttest.c
-mwccnlm.exe mttest.c %CFLAGS% 
-if errorlevel 1 goto end
-
-rem link               
-echo.
-echo Linking mttest.nlm
-mwldnlm.exe %LFLAGS% -screenname mttest -commandfile mttest.def mttest.o &quot;%PRELUDE%&quot; %LIBS% -o mttest.nlm
-if errorlevel 1 goto end
-
-goto end
-
-:inc_error
-echo.
-echo Environment variable MWCIncludes is not set - see install.nw
-goto end
-
-:prelude_error
-echo.
-echo Environment variable PRELUDE is not set - see install.nw
-goto end
-
-:imports_error
-echo.
-echo Environment variable IMPORTS is not set - see install.nw
-goto end
-    
-    
-:end
-set BLD_DEBUG=
-set CFLAGS=
-set LFLAGS=
-set LIBS=
-
diff --git a/crypto/threads/profile.sh b/crypto/threads/profile.sh
deleted file mode 100644
index 6e3e342..0000000
--- a/crypto/threads/profile.sh
+++ /dev/null
@@ -1,4 +0,0 @@
-#!/bin/sh
-/bin/rm -f mttest
-cc -p -DSOLARIS -I../../include -g mttest.c -o mttest -L/usr/lib/libc -ldl -L../.. -lthread  -lssl -lcrypto -lnsl -lsocket
-
diff --git a/crypto/threads/ptest.bat b/crypto/threads/ptest.bat
deleted file mode 100755
index 4071b5f..0000000
--- a/crypto/threads/ptest.bat
+++ /dev/null
@@ -1,4 +0,0 @@
-del mttest.exe
-
-purify cl /O2 -DWIN32 /MD -I..\..\out mttest.c /Femttest ..\..\out\ssl32.lib ..\..\out\crypt32.lib
-
diff --git a/crypto/threads/pthread.sh b/crypto/threads/pthread.sh
deleted file mode 100644
index f1c4982..0000000
--- a/crypto/threads/pthread.sh
+++ /dev/null
@@ -1,9 +0,0 @@
-#!/bin/sh
-#
-# build using pthreads
-#
-# <A HREF="http://www.mit.edu:8001/people/proven/pthreads.html">http://www.mit.edu:8001/people/proven/pthreads.html</A>
-#
-/bin/rm -f mttest
-pgcc -DPTHREADS -I../../include -g mttest.c -o mttest -L../.. -lssl -lcrypto 
-
diff --git a/crypto/threads/pthread2.sh b/crypto/threads/pthread2.sh
deleted file mode 100755
index ec945c4..0000000
--- a/crypto/threads/pthread2.sh
+++ /dev/null
@@ -1,6 +0,0 @@
-#!/bin/sh
-#
-# build using pthreads where it's already built into the system
-#
-/bin/rm -f mttest
-gcc -DPTHREADS -I../../include -g mttest.c -o mttest -L../.. -lssl -lcrypto -lpthread -ldl
diff --git a/crypto/threads/pthreads-vms.com b/crypto/threads/pthreads-vms.com
deleted file mode 100644
index 1cf92bd..0000000
--- a/crypto/threads/pthreads-vms.com
+++ /dev/null
@@ -1,14 +0,0 @@
-$! To compile mttest on VMS.
-$!
-$! WARNING: only tested with DEC C so far.
-$
-$ if (f$getsyi(&quot;cpu&quot;).lt.128)
-$ then
-$     arch := VAX
-$ else
-$     arch = f$edit( f$getsyi( &quot;ARCH_NAME&quot;), &quot;UPCASE&quot;)
-$     if (arch .eqs. &quot;&quot;) then arch = &quot;UNK&quot;
-$ endif
-$ define/user openssl [--.include.openssl]
-$ cc/def=PTHREADS mttest.c
-$ link mttest,[--.'arch'.exe.ssl]libssl/lib,[--.'arch'.exe.crypto]libcrypto/lib
diff --git a/crypto/threads/purify.sh b/crypto/threads/purify.sh
deleted file mode 100644
index 6d44fe2..0000000
--- a/crypto/threads/purify.sh
+++ /dev/null
@@ -1,4 +0,0 @@
-#!/bin/sh
-/bin/rm -f mttest
-purify cc -DSOLARIS -I../../include -g mttest.c -o mttest -L../.. -lthread  -lssl -lcrypto -lnsl -lsocket
-
diff --git a/crypto/threads/solaris.sh b/crypto/threads/solaris.sh
deleted file mode 100644
index bc93094..0000000
--- a/crypto/threads/solaris.sh
+++ /dev/null
@@ -1,4 +0,0 @@
-#!/bin/sh
-/bin/rm -f mttest
-cc -DSOLARIS -I../../include -g mttest.c -o mttest -L../.. -lthread  -lssl -lcrypto -lnsl -lsocket
-
diff --git a/crypto/threads/th-lock.c b/crypto/threads/th-lock.c
deleted file mode 100644
index e74474a..0000000
--- a/crypto/threads/th-lock.c
+++ /dev/null
@@ -1,364 +0,0 @@
-/* crypto/threads/th-lock.c */
-/* Copyright (C) 1995-1998 Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)
- * All rights reserved.
- *
- * This package is an SSL implementation written
- * by Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).
- * The implementation was written so as to conform with Netscapes SSL.
- *
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    &quot;This product includes cryptographic software written by
- *     Eric Young (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>)&quot;
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from
- *    the apps directory (application code) you must include an acknowledgement:
- *    &quot;This product includes software written by Tim Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;errno.h&gt;
-#ifdef LINUX
-# include &lt;typedefs.h&gt;
-#endif
-#ifdef OPENSSL_SYS_WIN32
-# include &lt;windows.h&gt;
-#endif
-#ifdef SOLARIS
-# include &lt;synch.h&gt;
-# include &lt;thread.h&gt;
-#endif
-#ifdef IRIX
-# include &lt;ulocks.h&gt;
-# include &lt;sys/prctl.h&gt;
-#endif
-#ifdef PTHREADS
-# include &lt;pthread.h&gt;
-#endif
-#include &lt;openssl/lhash.h&gt;
-#include &lt;openssl/crypto.h&gt;
-#include &lt;openssl/buffer.h&gt;
-#include &quot;../../e_os.h&quot;
-#include &lt;openssl/x509.h&gt;
-#include &lt;openssl/ssl.h&gt;
-#include &lt;openssl/err.h&gt;
-
-void CRYPTO_thread_setup(void);
-void CRYPTO_thread_cleanup(void);
-
-static void irix_locking_callback(int mode, int type, char *file, int line);
-static void solaris_locking_callback(int mode, int type, char *file,
-                                     int line);
-static void win32_locking_callback(int mode, int type, char *file, int line);
-static void pthreads_locking_callback(int mode, int type, char *file,
-                                      int line);
-
-static unsigned long irix_thread_id(void);
-static unsigned long solaris_thread_id(void);
-static unsigned long pthreads_thread_id(void);
-
-/*-
- * usage:
- * CRYPTO_thread_setup();
- * application code
- * CRYPTO_thread_cleanup();
- */
-
-#define THREAD_STACK_SIZE (16*1024)
-
-#ifdef OPENSSL_SYS_WIN32
-
-static HANDLE *lock_cs;
-
-void CRYPTO_thread_setup(void)
-{
-    int i;
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(HANDLE));
-    if (!lock_cs) {
-        /* Nothing we can do about this...void function! */
-        return;
-    }
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_cs[i] = CreateMutex(NULL, FALSE, NULL);
-    }
-
-    CRYPTO_set_locking_callback((void (*)(int, int, char *, int))
-                                win32_locking_callback);
-    /* id callback defined */
-    return (1);
-}
-
-static void CRYPTO_thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++)
-        CloseHandle(lock_cs[i]);
-    OPENSSL_free(lock_cs);
-}
-
-void win32_locking_callback(int mode, int type, char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        WaitForSingleObject(lock_cs[type], INFINITE);
-    } else {
-        ReleaseMutex(lock_cs[type]);
-    }
-}
-
-#endif                          /* OPENSSL_SYS_WIN32 */
-
-#ifdef SOLARIS
-
-# define USE_MUTEX
-
-# ifdef USE_MUTEX
-static mutex_t *lock_cs;
-# else
-static rwlock_t *lock_cs;
-# endif
-static long *lock_count;
-
-void CRYPTO_thread_setup(void)
-{
-    int i;
-
-# ifdef USE_MUTEX
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(mutex_t));
-# else
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(rwlock_t));
-# endif
-    if (!lock_cs) {
-        /* Nothing we can do about this...void function! */
-        return;
-    }
-    lock_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_count[i] = 0;
-# ifdef USE_MUTEX
-        mutex_init(&amp;(lock_cs[i]), USYNC_THREAD, NULL);
-# else
-        rwlock_init(&amp;(lock_cs[i]), USYNC_THREAD, NULL);
-# endif
-    }
-
-    CRYPTO_set_id_callback((unsigned long (*)())solaris_thread_id);
-    CRYPTO_set_locking_callback((void (*)())solaris_locking_callback);
-}
-
-void CRYPTO_thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-# ifdef USE_MUTEX
-        mutex_destroy(&amp;(lock_cs[i]));
-# else
-        rwlock_destroy(&amp;(lock_cs[i]));
-# endif
-    }
-    OPENSSL_free(lock_cs);
-    OPENSSL_free(lock_count);
-}
-
-void solaris_locking_callback(int mode, int type, char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-# ifdef USE_MUTEX
-        mutex_lock(&amp;(lock_cs[type]));
-# else
-        if (mode &amp; CRYPTO_READ)
-            rw_rdlock(&amp;(lock_cs[type]));
-        else
-            rw_wrlock(&amp;(lock_cs[type]));
-# endif
-        lock_count[type]++;
-    } else {
-# ifdef USE_MUTEX
-        mutex_unlock(&amp;(lock_cs[type]));
-# else
-        rw_unlock(&amp;(lock_cs[type]));
-# endif
-    }
-}
-
-unsigned long solaris_thread_id(void)
-{
-    unsigned long ret;
-
-    ret = (unsigned long)thr_self();
-    return (ret);
-}
-#endif                          /* SOLARIS */
-
-#ifdef IRIX
-/* I don't think this works..... */
-
-static usptr_t *arena;
-static usema_t **lock_cs;
-
-void CRYPTO_thread_setup(void)
-{
-    int i;
-    char filename[20];
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(usema_t *));
-    if (!lock_cs) {
-        /* Nothing we can do about this...void function! */
-        return;
-    }
-
-    strcpy(filename, &quot;/tmp/mttest.XXXXXX&quot;);
-    mktemp(filename);
-
-    usconfig(CONF_STHREADIOOFF);
-    usconfig(CONF_STHREADMALLOCOFF);
-    usconfig(CONF_INITUSERS, 100);
-    usconfig(CONF_LOCKTYPE, US_DEBUGPLUS);
-    arena = usinit(filename);
-    unlink(filename);
-
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_cs[i] = usnewsema(arena, 1);
-    }
-
-    CRYPTO_set_id_callback((unsigned long (*)())irix_thread_id);
-    CRYPTO_set_locking_callback((void (*)())irix_locking_callback);
-}
-
-void CRYPTO_thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        char buf[10];
-
-        sprintf(buf, &quot;%2d:&quot;, i);
-        usdumpsema(lock_cs[i], stdout, buf);
-        usfreesema(lock_cs[i], arena);
-    }
-    OPENSSL_free(lock_cs);
-}
-
-void irix_locking_callback(int mode, int type, char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        uspsema(lock_cs[type]);
-    } else {
-        usvsema(lock_cs[type]);
-    }
-}
-
-unsigned long irix_thread_id(void)
-{
-    unsigned long ret;
-
-    ret = (unsigned long)getpid();
-    return (ret);
-}
-#endif                          /* IRIX */
-
-/* Linux and a few others */
-#ifdef PTHREADS
-
-static pthread_mutex_t *lock_cs;
-static long *lock_count;
-
-void CRYPTO_thread_setup(void)
-{
-    int i;
-
-    lock_cs = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));
-    lock_count = OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));
-    if (!lock_cs || !lock_count) {
-        /* Nothing we can do about this...void function! */
-        OPENSSL_free(lock_cs);
-        OPENSSL_free(lock_count);
-        return;
-    }
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        lock_count[i] = 0;
-        pthread_mutex_init(&amp;(lock_cs[i]), NULL);
-    }
-
-    CRYPTO_set_id_callback((unsigned long (*)())pthreads_thread_id);
-    CRYPTO_set_locking_callback((void (*)())pthreads_locking_callback);
-}
-
-void thread_cleanup(void)
-{
-    int i;
-
-    CRYPTO_set_locking_callback(NULL);
-    for (i = 0; i &lt; CRYPTO_num_locks(); i++) {
-        pthread_mutex_destroy(&amp;(lock_cs[i]));
-    }
-    OPENSSL_free(lock_cs);
-    OPENSSL_free(lock_count);
-}
-
-void pthreads_locking_callback(int mode, int type, char *file, int line)
-{
-    if (mode &amp; CRYPTO_LOCK) {
-        pthread_mutex_lock(&amp;(lock_cs[type]));
-        lock_count[type]++;
-    } else {
-        pthread_mutex_unlock(&amp;(lock_cs[type]));
-    }
-}
-
-unsigned long pthreads_thread_id(void)
-{
-    unsigned long ret;
-
-    ret = (unsigned long)pthread_self();
-    return (ret);
-}
-
-#endif                          /* PTHREADS */
diff --git a/crypto/threads/win32.bat b/crypto/threads/win32.bat
deleted file mode 100755
index ee6da80..0000000
--- a/crypto/threads/win32.bat
+++ /dev/null
@@ -1,4 +0,0 @@
-del mttest.exe
-
-cl /O2 -DWIN32 /MD -I..\..\out mttest.c /Femttest ..\..\out\ssleay32.lib ..\..\out\libeay32.lib
-
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002034.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="002041.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2040">[ date ]</a>
              <a href="thread.html#2040">[ thread ]</a>
              <a href="subject.html#2040">[ subject ]</a>
              <a href="author.html#2040">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
