<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-August/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1470058330.288062.11848.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009405.html">
   <LINK REL="Next"  HREF="009407.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1470058330.288062.11848.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Mon Aug  1 13:32:10 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="009405.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="009407.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9406">[ date ]</a>
              <a href="thread.html#9406">[ thread ]</a>
              <a href="subject.html#9406">[ subject ]</a>
              <a href="author.html#9406">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  0930e07d1eb522e663abe543ee865a508749946e (commit)
       via  fd4b0c0832044cc10031cdb2abf656980fbf8eb1 (commit)
       via  55b09fe69aebe862777b9797c7334bbf2fc07fba (commit)
       via  70c4e15612f6dad9e7e82f74e8d3ebe7ef119f50 (commit)
       via  5f986ed32d3bc7f1a431cf149a421e6599dbe556 (commit)
       via  4d82c58b97b01d07ef215ce338be35d28748cde7 (commit)
       via  8829ce30200bd5fd66eeb05782a25f707341355f (commit)
       via  3331e43b169ef447ea7cde20642b28d411835e43 (commit)
       via  c5baa26663e2f7cf46248291125b01c9e79cc7ac (commit)
       via  19075d58a7e48f7e4d7a8d845e03fc2622ec5654 (commit)
      from  2a600d7afd55ed71076e9c41469f6bba72d1f313 (commit)


- Log -----------------------------------------------------------------
commit 0930e07d1eb522e663abe543ee865a508749946e
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Thu Jul 28 23:20:19 2016 +0200

    Useless allocation
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1342">https://github.com/openssl/openssl/pull/1342</A>)

commit fd4b0c0832044cc10031cdb2abf656980fbf8eb1
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Thu Jul 28 22:51:18 2016 +0200

    Fix some style issues
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1342">https://github.com/openssl/openssl/pull/1342</A>)

commit 55b09fe69aebe862777b9797c7334bbf2fc07fba
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Sat Jul 23 15:39:49 2016 +0200

    Add missing help string
    
    Fix an error message
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1342">https://github.com/openssl/openssl/pull/1342</A>)

commit 70c4e15612f6dad9e7e82f74e8d3ebe7ef119f50
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Sat Jul 23 14:45:08 2016 +0200

    Fix some awkward tests
    
    Add some explanatory comments
    Discard some useless parenthesis.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1342">https://github.com/openssl/openssl/pull/1342</A>)

commit 5f986ed32d3bc7f1a431cf149a421e6599dbe556
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Fri Jul 29 13:22:42 2016 +0200

    Merge some conditional blocks of code.
    
    Fix an #if check about rsa_count...
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1342">https://github.com/openssl/openssl/pull/1342</A>)

commit 4d82c58b97b01d07ef215ce338be35d28748cde7
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Tue Jul 19 23:54:21 2016 +0200

    Simplify default inits, add const qualifiers
    Simplify some loops to reuse k variable
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1342">https://github.com/openssl/openssl/pull/1342</A>)

commit 8829ce30200bd5fd66eeb05782a25f707341355f
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Tue Jul 19 23:57:18 2016 +0200

    Cast to right type, simplify array args
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1342">https://github.com/openssl/openssl/pull/1342</A>)

commit 3331e43b169ef447ea7cde20642b28d411835e43
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Tue Jul 12 23:13:20 2016 +0200

    Fix sharing of two static variables
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1342">https://github.com/openssl/openssl/pull/1342</A>)

commit c5baa26663e2f7cf46248291125b01c9e79cc7ac
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Wed Jul 20 00:16:45 2016 +0200

    ECDH test is only one operation to run
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1342">https://github.com/openssl/openssl/pull/1342</A>)

commit 19075d58a7e48f7e4d7a8d845e03fc2622ec5654
Author: FdaSilvaYY &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">fdasilvayy at gmail.com</A>&gt;
Date:   Sat Jul 23 14:26:07 2016 +0200

    Fix three missing global declarations.
    
    Fix compilation without SIGALRM.
    It don't link because of remaning alarm(0); call.
    
    Convert engine_id variable to local one
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1342">https://github.com/openssl/openssl/pull/1342</A>)

-----------------------------------------------------------------------

Summary of changes:
 apps/speed.c | 409 ++++++++++++++++++++++++++++-------------------------------
 1 file changed, 191 insertions(+), 218 deletions(-)

diff --git a/apps/speed.c b/apps/speed.c
index f5f3b8c..6a62ab7 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -144,6 +144,9 @@ static volatile int run = 0;
 static int mr = 0;
 static int usertime = 1;
 
+typedef void *(*kdf_fn) (
+        const void *in, size_t inlen, void *out, size_t *xoutlen);
+
 typedef struct loopargs_st {
     ASYNC_JOB *inprogress_job;
     ASYNC_WAIT_CTX *wait_ctx;
@@ -151,7 +154,7 @@ typedef struct loopargs_st {
     unsigned char *buf2;
     unsigned char *buf_malloc;
     unsigned char *buf2_malloc;
-    unsigned int *siglen;
+    unsigned int siglen;
 #ifndef OPENSSL_NO_RSA
     RSA *rsa_key[RSA_NUM];
 #endif
@@ -164,6 +167,8 @@ typedef struct loopargs_st {
     EC_KEY *ecdh_b[EC_NUM];
     unsigned char *secret_a;
     unsigned char *secret_b;
+    int         outlen;
+    kdf_fn      kdf;
 #endif
     EVP_CIPHER_CTX *ctx;
     HMAC_CTX *hctx;
@@ -244,7 +249,8 @@ static const char *names[ALGOR_NUM] = {
 };
 
 static double results[ALGOR_NUM][SIZE_NUM];
-static int lengths[SIZE_NUM] = {
+
+static const int lengths[SIZE_NUM] = {
     16, 64, 256, 1024, 8 * 1024, 16 * 1024
 };
 
@@ -339,18 +345,6 @@ static double Time_F(int s)
 }
 #endif
 
-#ifndef OPENSSL_NO_EC
-static const int KDF1_SHA1_len = 20;
-static void *KDF1_SHA1(const void *in, size_t inlen, void *out,
-                       size_t *outlen)
-{
-    if (*outlen &lt; SHA_DIGEST_LENGTH)
-        return NULL;
-    *outlen = SHA_DIGEST_LENGTH;
-    return SHA1(in, inlen, out);
-}
-#endif                         /* OPENSSL_NO_EC */
-
 static void multiblock_speed(const EVP_CIPHER *evp_cipher);
 
 static int found(const char *name, const OPT_PAIR * pairs, int *result)
@@ -377,7 +371,8 @@ OPTIONS speed_options[] = {
     {&quot;decrypt&quot;, OPT_DECRYPT, '-',
      &quot;Time decryption instead of encryption (only EVP)&quot;},
     {&quot;mr&quot;, OPT_MR, '-', &quot;Produce machine readable output&quot;},
-    {&quot;mb&quot;, OPT_MB, '-'},
+    {&quot;mb&quot;, OPT_MB, '-', 
+        &quot;Enable (tls1.1) multi-block mode on evp_cipher requested with -evp&quot;},
     {&quot;misalign&quot;, OPT_MISALIGN, 'n', &quot;Amount to mis-align buffers&quot;},
     {&quot;elapsed&quot;, OPT_ELAPSED, '-',
      &quot;Measure time in real time instead of CPU user time&quot;},
@@ -586,13 +581,14 @@ static OPT_PAIR ecdh_choices[] = {
 # define COND(d) (count &lt; (d))
 # define COUNT(d) (d)
 #else
-# define COND(c) (run &amp;&amp; count&lt;0x7fffffff)
+# define COND(unused_cond) (run &amp;&amp; count&lt;0x7fffffff)
 # define COUNT(d) (count)
 #endif                         /* SIGALRM */
 
 static int testnum;
-static char *engine_id = NULL;
 
+/* Nb of iterations to do per algorithm and key-size */
+static long c[ALGOR_NUM][SIZE_NUM];
 
 #ifndef OPENSSL_NO_MD2
 static int EVP_Digest_MD2_loop(void *args)
@@ -601,9 +597,10 @@ static int EVP_Digest_MD2_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char md2[MD2_DIGEST_LENGTH];
     int count;
+
     for (count = 0; COND(c[D_MD2][testnum]); count++) {
-        if (!EVP_Digest(buf, (unsigned long)lengths[testnum], &amp;(md2[0]), NULL,
-                EVP_md2(), NULL))
+        if (!EVP_Digest(buf, (size_t)lengths[testnum], md2, NULL, EVP_md2(),
+                NULL))
             return -1;
     }
     return count;
@@ -617,9 +614,10 @@ static int EVP_Digest_MDC2_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char mdc2[MDC2_DIGEST_LENGTH];
     int count;
+
     for (count = 0; COND(c[D_MDC2][testnum]); count++) {
-        if (!EVP_Digest(buf, (unsigned long)lengths[testnum], &amp;(mdc2[0]), NULL,
-                EVP_mdc2(), NULL))
+        if (!EVP_Digest(buf, (size_t)lengths[testnum], mdc2, NULL, EVP_mdc2(),
+                NULL))
             return -1;
     }
     return count;
@@ -633,9 +631,10 @@ static int EVP_Digest_MD4_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char md4[MD4_DIGEST_LENGTH];
     int count;
+
     for (count = 0; COND(c[D_MD4][testnum]); count++) {
-        if (!EVP_Digest(&amp;(buf[0]), (unsigned long)lengths[testnum], &amp;(md4[0]),
-                NULL, EVP_md4(), NULL))
+        if (!EVP_Digest(buf, (size_t)lengths[testnum], md4, NULL, EVP_md4(),
+                NULL))
             return -1;
     }
     return count;
@@ -661,10 +660,11 @@ static int HMAC_loop(void *args)
     HMAC_CTX *hctx = tempargs-&gt;hctx;
     unsigned char hmac[MD5_DIGEST_LENGTH];
     int count;
+
     for (count = 0; COND(c[D_HMAC][testnum]); count++) {
         HMAC_Init_ex(hctx, NULL, 0, NULL, NULL);
         HMAC_Update(hctx, buf, lengths[testnum]);
-        HMAC_Final(hctx, &amp;(hmac[0]), NULL);
+        HMAC_Final(hctx, hmac, NULL);
     }
     return count;
 }
@@ -724,7 +724,7 @@ static int EVP_Digest_RMD160_loop(void *args)
     unsigned char rmd160[RIPEMD160_DIGEST_LENGTH];
     int count;
     for (count = 0; COND(c[D_RMD160][testnum]); count++) {
-        if (!EVP_Digest(buf, (unsigned long)lengths[testnum], &amp;(rmd160[0]),
+        if (!EVP_Digest(buf, (size_t)lengths[testnum], &amp;(rmd160[0]),
                 NULL, EVP_ripemd160(), NULL))
             return -1;
     }
@@ -740,7 +740,7 @@ static int RC4_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     int count;
     for (count = 0; COND(c[D_RC4][testnum]); count++)
-        RC4(&amp;rc4_ks, (unsigned int)lengths[testnum], buf, buf);
+        RC4(&amp;rc4_ks, (size_t)lengths[testnum], buf, buf);
     return count;
 }
 #endif
@@ -785,7 +785,7 @@ static int AES_cbc_128_encrypt_loop(void *args)
     int count;
     for (count = 0; COND(c[D_CBC_128_AES][testnum]); count++)
         AES_cbc_encrypt(buf, buf,
-                (unsigned long)lengths[testnum], &amp;aes_ks1,
+                (size_t)lengths[testnum], &amp;aes_ks1,
                 iv, AES_ENCRYPT);
     return count;
 }
@@ -797,7 +797,7 @@ static int AES_cbc_192_encrypt_loop(void *args)
     int count;
     for (count = 0; COND(c[D_CBC_192_AES][testnum]); count++)
         AES_cbc_encrypt(buf, buf,
-                (unsigned long)lengths[testnum], &amp;aes_ks2,
+                (size_t)lengths[testnum], &amp;aes_ks2,
                 iv, AES_ENCRYPT);
     return count;
 }
@@ -809,7 +809,7 @@ static int AES_cbc_256_encrypt_loop(void *args)
     int count;
     for (count = 0; COND(c[D_CBC_256_AES][testnum]); count++)
         AES_cbc_encrypt(buf, buf,
-                (unsigned long)lengths[testnum], &amp;aes_ks3,
+                (size_t)lengths[testnum], &amp;aes_ks3,
                 iv, AES_ENCRYPT);
     return count;
 }
@@ -822,7 +822,7 @@ static int AES_ige_128_encrypt_loop(void *args)
     int count;
     for (count = 0; COND(c[D_IGE_128_AES][testnum]); count++)
         AES_ige_encrypt(buf, buf2,
-                (unsigned long)lengths[testnum], &amp;aes_ks1,
+                (size_t)lengths[testnum], &amp;aes_ks1,
                 iv, AES_ENCRYPT);
     return count;
 }
@@ -835,7 +835,7 @@ static int AES_ige_192_encrypt_loop(void *args)
     int count;
     for (count = 0; COND(c[D_IGE_192_AES][testnum]); count++)
         AES_ige_encrypt(buf, buf2,
-                (unsigned long)lengths[testnum], &amp;aes_ks2,
+                (size_t)lengths[testnum], &amp;aes_ks2,
                 iv, AES_ENCRYPT);
     return count;
 }
@@ -848,7 +848,7 @@ static int AES_ige_256_encrypt_loop(void *args)
     int count;
     for (count = 0; COND(c[D_IGE_256_AES][testnum]); count++)
         AES_ige_encrypt(buf, buf2,
-                (unsigned long)lengths[testnum], &amp;aes_ks3,
+                (size_t)lengths[testnum], &amp;aes_ks3,
                 iv, AES_ENCRYPT);
     return count;
 }
@@ -864,6 +864,7 @@ static int CRYPTO_gcm128_aad_loop(void *args)
     return count;
 }
 
+static long save_count = 0;
 static int decrypt = 0;
 static int EVP_Update_loop(void *args)
 {
@@ -871,15 +872,14 @@ static int EVP_Update_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     EVP_CIPHER_CTX *ctx = tempargs-&gt;ctx;
     int outl, count;
+#ifndef SIGALRM
+    int nb_iter = save_count * 4 * lengths[0] / lengths[testnum];
+#endif
     if (decrypt)
-        for (count = 0;
-                COND(save_count * 4 * lengths[0] / lengths[testnum]);
-                count++)
+        for (count = 0; COND(nb_iter); count++)
             EVP_DecryptUpdate(ctx, buf, &amp;outl, buf, lengths[testnum]);
     else
-        for (count = 0;
-                COND(save_count * 4 * lengths[0] / lengths[testnum]);
-                count++)
+        for (count = 0; COND(nb_iter); count++)
             EVP_EncryptUpdate(ctx, buf, &amp;outl, buf, lengths[testnum]);
     if (decrypt)
         EVP_DecryptFinal_ex(ctx, buf, &amp;outl);
@@ -895,23 +895,26 @@ static int EVP_Digest_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char md[EVP_MAX_MD_SIZE];
     int count;
-    for (count = 0;
-            COND(save_count * 4 * lengths[0] / lengths[testnum]); count++) {
-        if (!EVP_Digest(buf, lengths[testnum], &amp;(md[0]), NULL, evp_md, NULL))
+#ifndef SIGALRM
+    int nb_iter = save_count * 4 * lengths[0] / lengths[testnum];
+#endif
+
+    for (count = 0; COND(nb_iter); count++) {
+        if (!EVP_Digest(buf, lengths[testnum], md, NULL, evp_md, NULL))
             return -1;
     }
     return count;
 }
 
 #ifndef OPENSSL_NO_RSA
-static long rsa_c[RSA_NUM][2];
+static long rsa_c[RSA_NUM][2];  /* # RSA iteration test */
 
 static int RSA_sign_loop(void *args)
 {
     loopargs_t *tempargs = (loopargs_t *)args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
-    unsigned int *rsa_num = tempargs-&gt;siglen;
+    unsigned int *rsa_num = &amp;tempargs-&gt;siglen;
     RSA **rsa_key = tempargs-&gt;rsa_key;
     int ret, count;
     for (count = 0; COND(rsa_c[testnum][0]); count++) {
@@ -931,7 +934,7 @@ static int RSA_verify_loop(void *args)
     loopargs_t *tempargs = (loopargs_t *)args;
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
-    unsigned int rsa_num = *(tempargs-&gt;siglen);
+    unsigned int rsa_num = tempargs-&gt;siglen;
     RSA **rsa_key = tempargs-&gt;rsa_key;
     int ret, count;
     for (count = 0; COND(rsa_c[testnum][1]); count++) {
@@ -955,7 +958,7 @@ static int DSA_sign_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
     DSA **dsa_key = tempargs-&gt;dsa_key;
-    unsigned int *siglen = tempargs-&gt;siglen;
+    unsigned int *siglen = &amp;tempargs-&gt;siglen;
     int ret, count;
     for (count = 0; COND(dsa_c[testnum][0]); count++) {
         ret = DSA_sign(0, buf, 20, buf2, siglen, dsa_key[testnum]);
@@ -975,7 +978,7 @@ static int DSA_verify_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     unsigned char *buf2 = tempargs-&gt;buf2;
     DSA **dsa_key = tempargs-&gt;dsa_key;
-    unsigned int siglen = *(tempargs-&gt;siglen);
+    unsigned int siglen = tempargs-&gt;siglen;
     int ret, count;
     for (count = 0; COND(dsa_c[testnum][1]); count++) {
         ret = DSA_verify(0, buf, 20, buf2, siglen, dsa_key[testnum]);
@@ -998,7 +1001,7 @@ static int ECDSA_sign_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     EC_KEY **ecdsa = tempargs-&gt;ecdsa;
     unsigned char *ecdsasig = tempargs-&gt;buf2;
-    unsigned int *ecdsasiglen = tempargs-&gt;siglen;
+    unsigned int *ecdsasiglen = &amp;tempargs-&gt;siglen;
     int ret, count;
     for (count = 0; COND(ecdsa_c[testnum][0]); count++) {
         ret = ECDSA_sign(0, buf, 20,
@@ -1019,7 +1022,7 @@ static int ECDSA_verify_loop(void *args)
     unsigned char *buf = tempargs-&gt;buf;
     EC_KEY **ecdsa = tempargs-&gt;ecdsa;
     unsigned char *ecdsasig = tempargs-&gt;buf2;
-    unsigned int ecdsasiglen = *(tempargs-&gt;siglen);
+    unsigned int ecdsasiglen = tempargs-&gt;siglen;
     int ret, count;
     for (count = 0; COND(ecdsa_c[testnum][1]); count++) {
         ret = ECDSA_verify(0, buf, 20, ecdsasig, ecdsasiglen,
@@ -1034,9 +1037,8 @@ static int ECDSA_verify_loop(void *args)
     return count;
 }
 
-static int outlen;
-static void *(*kdf) (const void *in, size_t inlen, void *out,
-        size_t *xoutlen);
+/* ******************************************************************** */
+static long ecdh_c[EC_NUM][1];
 
 static int ECDH_compute_key_loop(void *args)
 {
@@ -1044,7 +1046,9 @@ static int ECDH_compute_key_loop(void *args)
     EC_KEY **ecdh_a = tempargs-&gt;ecdh_a;
     EC_KEY **ecdh_b = tempargs-&gt;ecdh_b;
     unsigned char *secret_a = tempargs-&gt;secret_a;
-    int count;
+    int count, outlen = tempargs-&gt;outlen;
+    kdf_fn kdf = tempargs-&gt;kdf;
+
     for (count = 0; COND(ecdh_c[testnum][0]); count++) {
         ECDH_compute_key(secret_a, outlen,
                 EC_KEY_get0_public_key(ecdh_b[testnum]),
@@ -1052,7 +1056,18 @@ static int ECDH_compute_key_loop(void *args)
     }
     return count;
 }
-#endif
+
+static const int KDF1_SHA1_len = 20;
+static void *KDF1_SHA1(const void *in, size_t inlen, void *out,
+                       size_t *outlen)
+{
+    if (*outlen &lt; SHA_DIGEST_LENGTH)
+        return NULL;
+    *outlen = SHA_DIGEST_LENGTH;
+    return SHA1(in, inlen, out);
+}
+
+#endif      /* ndef OPENSSL_NO_EC */
 
 
 static int run_benchmark(int async_jobs, int (*loop_function)(void *), loopargs_t *loopargs)
@@ -1060,8 +1075,7 @@ static int run_benchmark(int async_jobs, int (*loop_function)(void *), loopargs_
     int job_op_count = 0;
     int total_op_count = 0;
     int num_inprogress = 0;
-    int error = 0;
-    int i = 0;
+    int error = 0, i = 0, async = 0;
     OSSL_ASYNC_FD job_fd = 0;
     size_t num_job_fds = 0;
 
@@ -1071,27 +1085,27 @@ static int run_benchmark(int async_jobs, int (*loop_function)(void *), loopargs_
         return loop_function((void *)loopargs);
     }
 
-
     for (i = 0; i &lt; async_jobs &amp;&amp; !error; i++) {
-        switch (ASYNC_start_job(&amp;(loopargs[i].inprogress_job), loopargs[i].wait_ctx,
+        async = ASYNC_start_job(&amp;(loopargs[i].inprogress_job), loopargs[i].wait_ctx,
                                 &amp;job_op_count, loop_function,
-                                (void *)(loopargs + i), sizeof(loopargs_t))) {
-            case ASYNC_PAUSE:
-                ++num_inprogress;
-                break;
-            case ASYNC_FINISH:
-                if (job_op_count == -1) {
-                    error = 1;
-                } else {
-                    total_op_count += job_op_count;
-                }
-                break;
-            case ASYNC_NO_JOBS:
-            case ASYNC_ERR:
-                BIO_printf(bio_err, &quot;Failure in the job\n&quot;);
-                ERR_print_errors(bio_err);
+                                (void *)(loopargs + i), sizeof(loopargs_t));
+        switch (async) {
+        case ASYNC_PAUSE:
+            ++num_inprogress;
+            break;
+        case ASYNC_FINISH:
+            if (job_op_count == -1) {
                 error = 1;
-                break;
+            } else {
+                total_op_count += job_op_count;
+            }
+            break;
+        case ASYNC_NO_JOBS:
+        case ASYNC_ERR:
+            BIO_printf(bio_err, &quot;Failure in the job\n&quot;);
+            ERR_print_errors(bio_err);
+            error = 1;
+            break;
         }
     }
 
@@ -1164,33 +1178,35 @@ static int run_benchmark(int async_jobs, int (*loop_function)(void *), loopargs_
             if (num_job_fds == 1 &amp;&amp; !FD_ISSET(job_fd, &amp;waitfdset))
                 continue;
 #elif defined(OPENSSL_SYS_WINDOWS)
-            if (num_job_fds == 1 &amp;&amp;
-                    !PeekNamedPipe(job_fd, NULL, 0, NULL, &amp;avail, NULL) &amp;&amp; avail &gt; 0)
+            if (num_job_fds == 1
+                &amp;&amp; !PeekNamedPipe(job_fd, NULL, 0, NULL, &amp;avail, NULL) 
+                &amp;&amp; avail &gt; 0)
                 continue;
 #endif
 
-            switch (ASYNC_start_job(&amp;(loopargs[i].inprogress_job), loopargs[i].wait_ctx,
+            async = ASYNC_start_job(&amp;(loopargs[i].inprogress_job), loopargs[i].wait_ctx,
                         &amp;job_op_count, loop_function, (void *)(loopargs + i),
-                        sizeof(loopargs_t))) {
-                case ASYNC_PAUSE:
-                    break;
-                case ASYNC_FINISH:
-                    if (job_op_count == -1) {
-                        error = 1;
-                    } else {
-                        total_op_count += job_op_count;
-                    }
-                    --num_inprogress;
-                    loopargs[i].inprogress_job = NULL;
-                    break;
-                case ASYNC_NO_JOBS:
-                case ASYNC_ERR:
-                    --num_inprogress;
-                    loopargs[i].inprogress_job = NULL;
-                    BIO_printf(bio_err, &quot;Failure in the job\n&quot;);
-                    ERR_print_errors(bio_err);
+                        sizeof(loopargs_t));
+            switch (async) {
+            case ASYNC_PAUSE:
+                break;
+            case ASYNC_FINISH:
+                if (job_op_count == -1) {
                     error = 1;
-                    break;
+                } else {
+                    total_op_count += job_op_count;
+                }
+                --num_inprogress;
+                loopargs[i].inprogress_job = NULL;
+                break;
+            case ASYNC_NO_JOBS:
+            case ASYNC_ERR:
+                --num_inprogress;
+                loopargs[i].inprogress_job = NULL;
+                BIO_printf(bio_err, &quot;Failure in the job\n&quot;);
+                ERR_print_errors(bio_err);
+                error = 1;
+                break;
             }
         }
     }
@@ -1204,24 +1220,26 @@ int speed_main(int argc, char **argv)
     int async_init = 0;
     int loopargs_len = 0;
     char *prog;
+#ifndef OPENSSL_NO_ENGINE
+    const char *engine_id = NULL;
+#endif
     const EVP_CIPHER *evp_cipher = NULL;
     double d = 0.0;
     OPTION_CHOICE o;
-    int multiblock = 0, doit[ALGOR_NUM], pr_header = 0;
-#ifndef OPENSSL_NO_DSA
-    int dsa_doit[DSA_NUM];
-#endif
-    int rsa_doit[RSA_NUM];
+    int multiblock = 0, pr_header = 0;
+    int doit[ALGOR_NUM] = { 0 };
     int ret = 1, i, k, misalign = 0;
-    long c[ALGOR_NUM][SIZE_NUM], count = 0, save_count = 0;
+    long count = 0;
 #ifndef NO_FORK
     int multi = 0;
 #endif
     int async_jobs = 0;
-    /* What follows are the buffers and key material. */
-#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA)
+#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA) \
+    || !defined(OPENSSL_NO_EC)
     long rsa_count = 1;
 #endif
+
+    /* What follows are the buffers and key material. */
 #ifndef OPENSSL_NO_RC5
     RC5_32_KEY rc5_ks;
 #endif
@@ -1281,21 +1299,23 @@ int speed_main(int argc, char **argv)
     };
 #endif
 #ifndef OPENSSL_NO_RSA
-    static unsigned int rsa_bits[RSA_NUM] = {
+    static const unsigned int rsa_bits[RSA_NUM] = {
         512, 1024, 2048, 3072, 4096, 7680, 15360
     };
-    static unsigned char *rsa_data[RSA_NUM] = {
+    static const unsigned char *rsa_data[RSA_NUM] = {
         test512, test1024, test2048, test3072, test4096, test7680, test15360
     };
-    static int rsa_data_length[RSA_NUM] = {
+    static const int rsa_data_length[RSA_NUM] = {
         sizeof(test512), sizeof(test1024),
         sizeof(test2048), sizeof(test3072),
         sizeof(test4096), sizeof(test7680),
         sizeof(test15360)
     };
+    int rsa_doit[RSA_NUM] = { 0 };
 #endif
 #ifndef OPENSSL_NO_DSA
-    static unsigned int dsa_bits[DSA_NUM] = { 512, 1024, 2048 };
+    static const unsigned int dsa_bits[DSA_NUM] = { 512, 1024, 2048 };
+    int dsa_doit[DSA_NUM] = { 0 };
 #endif
 #ifndef OPENSSL_NO_EC
     /*
@@ -1303,7 +1323,7 @@ int speed_main(int argc, char **argv)
      * add tests over more curves, simply add the curve NID and curve name to
      * the following arrays and increase the EC_NUM value accordingly.
      */
-    static unsigned int test_curves[EC_NUM] = {
+    static const unsigned int test_curves[EC_NUM] = {
         /* Prime Curves */
         NID_secp160r1, NID_X9_62_prime192v1, NID_secp224r1,
         NID_X9_62_prime256v1, NID_secp384r1, NID_secp521r1,
@@ -1327,7 +1347,7 @@ int speed_main(int argc, char **argv)
         /* Other */
         &quot;X25519&quot;
     };
-    static int test_curves_bits[EC_NUM] = {
+    static const int test_curves_bits[EC_NUM] = {
         160, 192, 224,
         256, 384, 521,
         163, 233, 283,
@@ -1335,40 +1355,10 @@ int speed_main(int argc, char **argv)
         233, 283, 409,
         571, 253 /* X25519 */
     };
-#endif
-#ifndef OPENSSL_NO_EC
-    int ecdsa_doit[EC_NUM];
-    int secret_size_a, secret_size_b;
-    int ecdh_checks = 1;
-    int secret_idx = 0;
-    long ecdh_c[EC_NUM][2];
-    int ecdh_doit[EC_NUM];
-#endif
-
-    memset(results, 0, sizeof(results));
-
-    memset(c, 0, sizeof(c));
-#ifndef OPENSSL_NO_DES
-    memset(DES_iv, 0, sizeof(DES_iv));
-#endif
-    memset(iv, 0, sizeof(iv));
-
-    for (i = 0; i &lt; ALGOR_NUM; i++)
-        doit[i] = 0;
-    for (i = 0; i &lt; RSA_NUM; i++)
-        rsa_doit[i] = 0;
-#ifndef OPENSSL_NO_DSA
-    for (i = 0; i &lt; DSA_NUM; i++)
-        dsa_doit[i] = 0;
-#endif
-#ifndef OPENSSL_NO_EC
-    for (i = 0; i &lt; EC_NUM; i++)
-        ecdsa_doit[i] = 0;
-    for (i = 0; i &lt; EC_NUM; i++)
-        ecdh_doit[i] = 0;
-#endif
 
-    misalign = 0;
+    int ecdsa_doit[EC_NUM] = { 0 };
+    int ecdh_doit[EC_NUM] = { 0 };
+#endif  /* ndef OPENSSL_NO_EC */
 
     prog = opt_init(argc, argv, speed_options);
     while ((o = opt_next()) != OPT_EOF) {
@@ -1391,7 +1381,7 @@ int speed_main(int argc, char **argv)
                 evp_md = EVP_get_digestbyname(opt_arg());
             if (evp_cipher == NULL &amp;&amp; evp_md == NULL) {
                 BIO_printf(bio_err,
-                           &quot;%s: %s  an unknown cipher or digest\n&quot;,
+                           &quot;%s: %s is an unknown cipher or digest\n&quot;,
                            prog, opt_arg());
                 goto end;
             }
@@ -1406,7 +1396,9 @@ int speed_main(int argc, char **argv)
              * initialised by each child process, not by the parent.
              * So store the name here and run setup_engine() later on.
              */
+#ifndef OPENSSL_NO_ENGINE
             engine_id = opt_arg();
+#endif
             break;
         case OPT_MULTI:
 #ifndef NO_FORK
@@ -1553,7 +1545,6 @@ int speed_main(int argc, char **argv)
         /* Align the start of buffers on a 64 byte boundary */
         loopargs[i].buf = loopargs[i].buf_malloc + misalign;
         loopargs[i].buf2 = loopargs[i].buf2_malloc + misalign;
-        loopargs[i].siglen = app_malloc(sizeof(unsigned int), &quot;signature length&quot;);
 #ifndef OPENSSL_NO_EC
         loopargs[i].secret_a = app_malloc(MAX_ECDH_SIZE, &quot;ECDH secret a&quot;);
         loopargs[i].secret_b = app_malloc(MAX_ECDH_SIZE, &quot;ECDH secret b&quot;);
@@ -1651,9 +1642,6 @@ int speed_main(int argc, char **argv)
 #ifndef OPENSSL_NO_CAST
     CAST_set_key(&amp;cast_ks, 16, key16);
 #endif
-#ifndef OPENSSL_NO_RSA
-    memset(rsa_c, 0, sizeof(rsa_c));
-#endif
 #ifndef SIGALRM
 # ifndef OPENSSL_NO_DES
     BIO_printf(bio_err, &quot;First we calculate the approximate speed ...\n&quot;);
@@ -1744,11 +1732,11 @@ int speed_main(int argc, char **argv)
     for (i = 1; i &lt; RSA_NUM; i++) {
         rsa_c[i][0] = rsa_c[i - 1][0] / 8;
         rsa_c[i][1] = rsa_c[i - 1][1] / 4;
-        if ((rsa_doit[i] &lt;= 1) &amp;&amp; (rsa_c[i][0] == 0))
+        if (rsa_doit[i] &lt;= 1 &amp;&amp; rsa_c[i][0] == 0)
             rsa_doit[i] = 0;
         else {
             if (rsa_c[i][0] == 0) {
-                rsa_c[i][0] = 1;
+                rsa_c[i][0] = 1;            /* Set minimum iteration Nb to 1. */
                 rsa_c[i][1] = 20;
             }
         }
@@ -1761,11 +1749,11 @@ int speed_main(int argc, char **argv)
     for (i = 1; i &lt; DSA_NUM; i++) {
         dsa_c[i][0] = dsa_c[i - 1][0] / 4;
         dsa_c[i][1] = dsa_c[i - 1][1] / 4;
-        if ((dsa_doit[i] &lt;= 1) &amp;&amp; (dsa_c[i][0] == 0))
+        if (dsa_doit[i] &lt;= 1 &amp;&amp; dsa_c[i][0] == 0)
             dsa_doit[i] = 0;
         else {
-            if (dsa_c[i] == 0) {
-                dsa_c[i][0] = 1;
+            if (dsa_c[i][0] == 0) {
+                dsa_c[i][0] = 1;            /* Set minimum iteration Nb to 1. */
                 dsa_c[i][1] = 1;
             }
         }
@@ -1778,10 +1766,10 @@ int speed_main(int argc, char **argv)
     for (i = R_EC_P192; i &lt;= R_EC_P521; i++) {
         ecdsa_c[i][0] = ecdsa_c[i - 1][0] / 2;
         ecdsa_c[i][1] = ecdsa_c[i - 1][1] / 2;
-        if ((ecdsa_doit[i] &lt;= 1) &amp;&amp; (ecdsa_c[i][0] == 0))
+        if (ecdsa_doit[i] &lt;= 1 &amp;&amp; ecdsa_c[i][0] == 0)
             ecdsa_doit[i] = 0;
         else {
-            if (ecdsa_c[i] == 0) {
+            if (ecdsa_c[i][0] == 0) {
                 ecdsa_c[i][0] = 1;
                 ecdsa_c[i][1] = 1;
             }
@@ -1792,10 +1780,10 @@ int speed_main(int argc, char **argv)
     for (i = R_EC_K233; i &lt;= R_EC_K571; i++) {
         ecdsa_c[i][0] = ecdsa_c[i - 1][0] / 2;
         ecdsa_c[i][1] = ecdsa_c[i - 1][1] / 2;
-        if ((ecdsa_doit[i] &lt;= 1) &amp;&amp; (ecdsa_c[i][0] == 0))
+        if (ecdsa_doit[i] &lt;= 1 &amp;&amp; ecdsa_c[i][0] == 0)
             ecdsa_doit[i] = 0;
         else {
-            if (ecdsa_c[i] == 0) {
+            if (ecdsa_c[i][0] == 0) {
                 ecdsa_c[i][0] = 1;
                 ecdsa_c[i][1] = 1;
             }
@@ -1806,10 +1794,10 @@ int speed_main(int argc, char **argv)
     for (i = R_EC_B233; i &lt;= R_EC_B571; i++) {
         ecdsa_c[i][0] = ecdsa_c[i - 1][0] / 2;
         ecdsa_c[i][1] = ecdsa_c[i - 1][1] / 2;
-        if ((ecdsa_doit[i] &lt;= 1) &amp;&amp; (ecdsa_c[i][0] == 0))
+        if (ecdsa_doit[i] &lt;= 1 &amp;&amp; ecdsa_c[i][0] == 0)
             ecdsa_doit[i] = 0;
         else {
-            if (ecdsa_c[i] == 0) {
+            if (ecdsa_c[i][0] == 0) {
                 ecdsa_c[i][0] = 1;
                 ecdsa_c[i][1] = 1;
             }
@@ -1817,44 +1805,35 @@ int speed_main(int argc, char **argv)
     }
 
     ecdh_c[R_EC_P160][0] = count / 1000;
-    ecdh_c[R_EC_P160][1] = count / 1000;
     for (i = R_EC_P192; i &lt;= R_EC_P521; i++) {
         ecdh_c[i][0] = ecdh_c[i - 1][0] / 2;
-        ecdh_c[i][1] = ecdh_c[i - 1][1] / 2;
-        if ((ecdh_doit[i] &lt;= 1) &amp;&amp; (ecdh_c[i][0] == 0))
+        if (ecdh_doit[i] &lt;= 1 &amp;&amp; ecdh_c[i][0] == 0)
             ecdh_doit[i] = 0;
         else {
-            if (ecdh_c[i] == 0) {
+            if (ecdh_c[i][0] == 0) {
                 ecdh_c[i][0] = 1;
-                ecdh_c[i][1] = 1;
             }
         }
     }
     ecdh_c[R_EC_K163][0] = count / 1000;
-    ecdh_c[R_EC_K163][1] = count / 1000;
     for (i = R_EC_K233; i &lt;= R_EC_K571; i++) {
         ecdh_c[i][0] = ecdh_c[i - 1][0] / 2;
-        ecdh_c[i][1] = ecdh_c[i - 1][1] / 2;
-        if ((ecdh_doit[i] &lt;= 1) &amp;&amp; (ecdh_c[i][0] == 0))
+        if (ecdh_doit[i] &lt;= 1 &amp;&amp; ecdh_c[i][0] == 0)
             ecdh_doit[i] = 0;
         else {
-            if (ecdh_c[i] == 0) {
+            if (ecdh_c[i][0] == 0) {
                 ecdh_c[i][0] = 1;
-                ecdh_c[i][1] = 1;
             }
         }
     }
     ecdh_c[R_EC_B163][0] = count / 1000;
-    ecdh_c[R_EC_B163][1] = count / 1000;
     for (i = R_EC_B233; i &lt;= R_EC_B571; i++) {
         ecdh_c[i][0] = ecdh_c[i - 1][0] / 2;
-        ecdh_c[i][1] = ecdh_c[i - 1][1] / 2;
-        if ((ecdh_doit[i] &lt;= 1) &amp;&amp; (ecdh_c[i][0] == 0))
+        if (ecdh_doit[i] &lt;= 1 &amp;&amp; ecdh_c[i][0] == 0)
             ecdh_doit[i] = 0;
         else {
-            if (ecdh_c[i] == 0) {
+            if (ecdh_c[i][0] == 0) {
                 ecdh_c[i][0] = 1;
-                ecdh_c[i][1] = 1;
             }
         }
     }
@@ -1919,6 +1898,9 @@ int speed_main(int argc, char **argv)
 
 #ifndef OPENSSL_NO_MD5
     if (doit[D_HMAC]) {
+        char hmac_key[] = &quot;This is a key...&quot;;
+        int len = strlen(hmac_key);
+
         for (i = 0; i &lt; loopargs_len; i++) {
             loopargs[i].hctx = HMAC_CTX_new();
             if (loopargs[i].hctx == NULL) {
@@ -1926,8 +1908,7 @@ int speed_main(int argc, char **argv)
                 exit(1);
             }
 
-            HMAC_Init_ex(loopargs[i].hctx, (unsigned char *)&quot;This is a key...&quot;,
-                    16, EVP_md5(), NULL);
+            HMAC_Init_ex(loopargs[i].hctx, hmac_key, len, EVP_md5(), NULL);
         }
         for (testnum = 0; testnum &lt; SIZE_NUM; testnum++) {
             print_message(names[D_HMAC], c[D_HMAC][testnum], lengths[testnum]);
@@ -2115,7 +2096,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_128_CML][testnum]); count++)
                 Camellia_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                     (unsigned long)lengths[testnum], &amp;camellia_ks1,
+                                     (size_t)lengths[testnum], &amp;camellia_ks1,
                                      iv, CAMELLIA_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_128_CML, testnum, count, d);
@@ -2132,7 +2113,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_192_CML][testnum]); count++)
                 Camellia_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                     (unsigned long)lengths[testnum], &amp;camellia_ks2,
+                                     (size_t)lengths[testnum], &amp;camellia_ks2,
                                      iv, CAMELLIA_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_192_CML, testnum, count, d);
@@ -2149,7 +2130,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_256_CML][testnum]); count++)
                 Camellia_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                     (unsigned long)lengths[testnum], &amp;camellia_ks3,
+                                     (size_t)lengths[testnum], &amp;camellia_ks3,
                                      iv, CAMELLIA_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_256_CML, testnum, count, d);
@@ -2167,7 +2148,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_IDEA][testnum]); count++)
                 IDEA_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                 (unsigned long)lengths[testnum], &amp;idea_ks,
+                                 (size_t)lengths[testnum], &amp;idea_ks,
                                  iv, IDEA_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_IDEA, testnum, count, d);
@@ -2185,7 +2166,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_SEED][testnum]); count++)
                 SEED_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                 (unsigned long)lengths[testnum], &amp;seed_ks, iv, 1);
+                                 (size_t)lengths[testnum], &amp;seed_ks, iv, 1);
             d = Time_F(STOP);
             print_result(D_CBC_SEED, testnum, count, d);
         }
@@ -2202,7 +2183,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_RC2][testnum]); count++)
                 RC2_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                (unsigned long)lengths[testnum], &amp;rc2_ks,
+                                (size_t)lengths[testnum], &amp;rc2_ks,
                                 iv, RC2_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_RC2, testnum, count, d);
@@ -2220,7 +2201,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_RC5][testnum]); count++)
                 RC5_32_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                   (unsigned long)lengths[testnum], &amp;rc5_ks,
+                                   (size_t)lengths[testnum], &amp;rc5_ks,
                                    iv, RC5_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_RC5, testnum, count, d);
@@ -2238,7 +2219,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_BF][testnum]); count++)
                 BF_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                               (unsigned long)lengths[testnum], &amp;bf_ks,
+                               (size_t)lengths[testnum], &amp;bf_ks,
                                iv, BF_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_BF, testnum, count, d);
@@ -2256,7 +2237,7 @@ int speed_main(int argc, char **argv)
             Time_F(START);
             for (count = 0, run = 1; COND(c[D_CBC_CAST][testnum]); count++)
                 CAST_cbc_encrypt(loopargs[0].buf, loopargs[0].buf,
-                                 (unsigned long)lengths[testnum], &amp;cast_ks,
+                                 (size_t)lengths[testnum], &amp;cast_ks,
                                  iv, CAST_ENCRYPT);
             d = Time_F(STOP);
             print_result(D_CBC_CAST, testnum, count, d);
@@ -2330,7 +2311,7 @@ int speed_main(int argc, char **argv)
             continue;
         for (i = 0; i &lt; loopargs_len; i++) {
             st = RSA_sign(NID_md5_sha1, loopargs[i].buf, 36, loopargs[i].buf2,
-                          loopargs[i].siglen, loopargs[i].rsa_key[testnum]);
+                          &amp;loopargs[i].siglen, loopargs[i].rsa_key[testnum]);
             if (st == 0)
                 break;
         }
@@ -2356,7 +2337,7 @@ int speed_main(int argc, char **argv)
 
         for (i = 0; i &lt; loopargs_len; i++) {
             st = RSA_verify(NID_md5_sha1, loopargs[i].buf, 36, loopargs[i].buf2,
-                            *(loopargs[i].siglen), loopargs[i].rsa_key[testnum]);
+                            loopargs[i].siglen, loopargs[i].rsa_key[testnum]);
             if (st &lt;= 0)
                 break;
         }
@@ -2402,7 +2383,7 @@ int speed_main(int argc, char **argv)
         /* DSA_sign_setup(dsa_key[testnum],NULL); */
         for (i = 0; i &lt; loopargs_len; i++) {
             st = DSA_sign(0, loopargs[i].buf, 20, loopargs[i].buf2,
-                          loopargs[i].siglen, loopargs[i].dsa_key[testnum]);
+                          &amp;loopargs[i].siglen, loopargs[i].dsa_key[testnum]);
             if (st == 0)
                 break;
         }
@@ -2427,7 +2408,7 @@ int speed_main(int argc, char **argv)
 
         for (i = 0; i &lt; loopargs_len; i++) {
             st = DSA_verify(0, loopargs[i].buf, 20, loopargs[i].buf2,
-                            *(loopargs[i].siglen), loopargs[i].dsa_key[testnum]);
+                            loopargs[i].siglen, loopargs[i].dsa_key[testnum]);
             if (st &lt;= 0)
                 break;
         }
@@ -2483,7 +2464,7 @@ int speed_main(int argc, char **argv)
                 /* Perform ECDSA signature test */
                 EC_KEY_generate_key(loopargs[i].ecdsa[testnum]);
                 st = ECDSA_sign(0, loopargs[i].buf, 20, loopargs[i].buf2,
-                                loopargs[i].siglen, loopargs[i].ecdsa[testnum]);
+                                &amp;loopargs[i].siglen, loopargs[i].ecdsa[testnum]);
                 if (st == 0)
                     break;
             }
@@ -2511,7 +2492,7 @@ int speed_main(int argc, char **argv)
             /* Perform ECDSA verification test */
             for (i = 0; i &lt; loopargs_len; i++) {
                 st = ECDSA_verify(0, loopargs[i].buf, 20, loopargs[i].buf2,
-                                  *(loopargs[i].siglen), loopargs[i].ecdsa[testnum]);
+                                  loopargs[i].siglen, loopargs[i].ecdsa[testnum]);
                 if (st != 1)
                     break;
             }
@@ -2541,13 +2522,13 @@ int speed_main(int argc, char **argv)
             }
         }
     }
-#endif
 
-#ifndef OPENSSL_NO_EC
     if (RAND_status() != 1) {
         RAND_seed(rnd_seed, sizeof rnd_seed);
     }
     for (testnum = 0; testnum &lt; EC_NUM; testnum++) {
+        int ecdh_checks = 1;
+
         if (!ecdh_doit[testnum])
             continue;
         for (i = 0; i &lt; loopargs_len; i++) {
@@ -2573,37 +2554,37 @@ int speed_main(int argc, char **argv)
                     ecdh_checks = 0;
                     rsa_count = 1;
                 } else {
+                    int secret_size_a, secret_size_b;
                     /*
                      * If field size is not more than 24 octets, then use SHA-1
                      * hash of result; otherwise, use result (see section 4.8 of
                      * draft-ietf-tls-ecc-03.txt).
                      */
-                    int field_size;
-                    field_size =
-                        EC_GROUP_get_degree(EC_KEY_get0_group(loopargs[i].ecdh_a[testnum]));
-                    if (field_size &lt;= 24 * 8) {
-                        outlen = KDF1_SHA1_len;
-                        kdf = KDF1_SHA1;
+                    int field_size = EC_GROUP_get_degree(
+                            EC_KEY_get0_group(loopargs[i].ecdh_a[testnum]));
+
+                    if (field_size &lt;= 24 * 8) {                 /* 192 bits */
+                        loopargs[i].outlen = KDF1_SHA1_len;
+                        loopargs[i].kdf = KDF1_SHA1;
                     } else {
-                        outlen = (field_size + 7) / 8;
-                        kdf = NULL;
+                        loopargs[i].outlen = (field_size + 7) / 8;
+                        loopargs[i].kdf = NULL;
                     }
                     secret_size_a =
-                        ECDH_compute_key(loopargs[i].secret_a, outlen,
+                        ECDH_compute_key(loopargs[i].secret_a, loopargs[i].outlen,
                                 EC_KEY_get0_public_key(loopargs[i].ecdh_b[testnum]),
-                                loopargs[i].ecdh_a[testnum], kdf);
+                                loopargs[i].ecdh_a[testnum], loopargs[i].kdf);
                     secret_size_b =
-                        ECDH_compute_key(loopargs[i].secret_b, outlen,
+                        ECDH_compute_key(loopargs[i].secret_b, loopargs[i].outlen,
                                 EC_KEY_get0_public_key(loopargs[i].ecdh_a[testnum]),
-                                loopargs[i].ecdh_b[testnum], kdf);
+                                loopargs[i].ecdh_b[testnum], loopargs[i].kdf);
                     if (secret_size_a != secret_size_b)
                         ecdh_checks = 0;
                     else
                         ecdh_checks = 1;
 
-                    for (secret_idx = 0; (secret_idx &lt; secret_size_a)
-                            &amp;&amp; (ecdh_checks == 1); secret_idx++) {
-                        if (loopargs[i].secret_a[secret_idx] != loopargs[i].secret_b[secret_idx])
+                    for (k = 0; k &lt; secret_size_a &amp;&amp; ecdh_checks == 1; k++) {
+                        if (loopargs[i].secret_a[k] != loopargs[i].secret_b[k])
                             ecdh_checks = 0;
                     }
 
@@ -2750,9 +2731,7 @@ int speed_main(int argc, char **argv)
                    ecdsa_results[k][0], ecdsa_results[k][1],
                    1.0 / ecdsa_results[k][0], 1.0 / ecdsa_results[k][1]);
     }
-#endif
 
-#ifndef OPENSSL_NO_EC
     testnum = 1;
     for (k = 0; k &lt; EC_NUM; k++) {
         if (!ecdh_doit[k])
@@ -2781,23 +2760,16 @@ int speed_main(int argc, char **argv)
     for (i = 0; i &lt; loopargs_len; i++) {
         OPENSSL_free(loopargs[i].buf_malloc);
         OPENSSL_free(loopargs[i].buf2_malloc);
-        OPENSSL_free(loopargs[i].siglen);
-    }
+
 #ifndef OPENSSL_NO_RSA
-    for (i = 0; i &lt; loopargs_len; i++) {
         for (k = 0; k &lt; RSA_NUM; k++)
             RSA_free(loopargs[i].rsa_key[k]);
-    }
 #endif
 #ifndef OPENSSL_NO_DSA
-    for (i = 0; i &lt; loopargs_len; i++) {
         for (k = 0; k &lt; DSA_NUM; k++)
             DSA_free(loopargs[i].dsa_key[k]);
-    }
 #endif
-
 #ifndef OPENSSL_NO_EC
-    for (i = 0; i &lt; loopargs_len; i++) {
         for (k = 0; k &lt; EC_NUM; k++) {
             EC_KEY_free(loopargs[i].ecdsa[k]);
             EC_KEY_free(loopargs[i].ecdh_a[k]);
@@ -2805,8 +2777,9 @@ int speed_main(int argc, char **argv)
         }
         OPENSSL_free(loopargs[i].secret_a);
         OPENSSL_free(loopargs[i].secret_b);
-    }
 #endif
+    }
+
     if (async_jobs &gt; 0) {
         for (i = 0; i &lt; loopargs_len; i++)
             ASYNC_WAIT_CTX_free(loopargs[i].wait_ctx);
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009405.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="009407.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9406">[ date ]</a>
              <a href="thread.html#9406">[ thread ]</a>
              <a href="subject.html#9406">[ subject ]</a>
              <a href="author.html#9406">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
