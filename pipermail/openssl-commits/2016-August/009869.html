<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  OpenSSL_1_0_2-stable update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-August/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20OpenSSL_1_0_2-stable%20update&In-Reply-To=%3C1471612121.225180.24954.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009866.html">
   <LINK REL="Next"  HREF="009874.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  OpenSSL_1_0_2-stable update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20OpenSSL_1_0_2-stable%20update&In-Reply-To=%3C1471612121.225180.24954.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  OpenSSL_1_0_2-stable update">matt at openssl.org
       </A><BR>
    <I>Fri Aug 19 13:08:41 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="009866.html">[openssl-commits] [openssl]  OpenSSL_1_0_2-stable update
</A></li>
        <LI>Next message: <A HREF="009874.html">[openssl-commits] [openssl]  OpenSSL_1_0_2-stable update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9869">[ date ]</a>
              <a href="thread.html#9869">[ thread ]</a>
              <a href="subject.html#9869">[ subject ]</a>
              <a href="author.html#9869">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch OpenSSL_1_0_2-stable has been updated
       via  26aebca74e38ae09f673c2045cc8e2ef762d265a (commit)
       via  3884b47b7c255c2e94d9b387ee83c7e8bb981258 (commit)
       via  30ea36e69543f28d8d84e565d29c8a4b7f61005d (commit)
       via  20744f6b40b5ded059a848f66d6ba922f2a62eb3 (commit)
       via  bc4d7e1230bfb10cc3154b3d11ac2ff95f48bc94 (commit)
       via  48e8df6e399ec1bef53500457f16b54d798198d3 (commit)
      from  7b415b0ec383df9bbc71a59c3a6e84947a84ac45 (commit)


- Log -----------------------------------------------------------------
commit 26aebca74e38ae09f673c2045cc8e2ef762d265a
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Aug 17 17:55:36 2016 +0100

    Update function error code
    
    A function error code needed updating due to merge issues.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 3884b47b7c255c2e94d9b387ee83c7e8bb981258
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Jul 5 12:04:37 2016 +0100

    Fix DTLS replay protection
    
    The DTLS implementation provides some protection against replay attacks
    in accordance with RFC6347 section 4.1.2.6.
    
    A sliding &quot;window&quot; of valid record sequence numbers is maintained with
    the &quot;right&quot; hand edge of the window set to the highest sequence number we
    have received so far. Records that arrive that are off the &quot;left&quot; hand
    edge of the window are rejected. Records within the window are checked
    against a list of records received so far. If we already received it then
    we also reject the new record.
    
    If we have not already received the record, or the sequence number is off
    the right hand edge of the window then we verify the MAC of the record.
    If MAC verification fails then we discard the record. Otherwise we mark
    the record as received. If the sequence number was off the right hand edge
    of the window, then we slide the window along so that the right hand edge
    is in line with the newly received sequence number.
    
    Records may arrive for future epochs, i.e. a record from after a CCS being
    sent, can arrive before the CCS does if the packets get re-ordered. As we
    have not yet received the CCS we are not yet in a position to decrypt or
    validate the MAC of those records. OpenSSL places those records on an
    unprocessed records queue. It additionally updates the window immediately,
    even though we have not yet verified the MAC. This will only occur if
    currently in a handshake/renegotiation.
    
    This could be exploited by an attacker by sending a record for the next
    epoch (which does not have to decrypt or have a valid MAC), with a very
    large sequence number. This means the right hand edge of the window is
    moved very far to the right, and all subsequent legitimate packets are
    dropped causing a denial of service.
    
    A similar effect can be achieved during the initial handshake. In this
    case there is no MAC key negotiated yet. Therefore an attacker can send a
    message for the current epoch with a very large sequence number. The code
    will process the record as normal. If the hanshake message sequence number
    (as opposed to the record sequence number that we have been talking about
    so far) is in the future then the injected message is bufferred to be
    handled later, but the window is still updated. Therefore all subsequent
    legitimate handshake records are dropped. This aspect is not considered a
    security issue because there are many ways for an attacker to disrupt the
    initial handshake and prevent it from completing successfully (e.g.
    injection of a handshake message will cause the Finished MAC to fail and
    the handshake to be aborted). This issue comes about as a result of trying
    to do replay protection, but having no integrity mechanism in place yet.
    Does it even make sense to have replay protection in epoch 0? That
    issue isn't addressed here though.
    
    This addressed an OCAP Audit issue.
    
    CVE-2016-2181
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 30ea36e69543f28d8d84e565d29c8a4b7f61005d
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Jul 5 11:52:43 2016 +0100

    Add DTLS replay protection test
    
    Injects a record from epoch 1 during epoch 0 handshake, with a record
    sequence number in the future, to test that the record replay protection
    feature works as expected. This is described more fully in the next commit.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 20744f6b40b5ded059a848f66d6ba922f2a62eb3
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Jul 5 11:46:26 2016 +0100

    Fix DTLS unprocessed records bug
    
    During a DTLS handshake we may get records destined for the next epoch
    arrive before we have processed the CCS. In that case we can't decrypt or
    verify the record yet, so we buffer it for later use. When we do receive
    the CCS we work through the queue of unprocessed records and process them.
    
    Unfortunately the act of processing wipes out any existing packet data
    that we were still working through. This includes any records from the new
    epoch that were in the same packet as the CCS. We should only process the
    buffered records if we've not got any data left.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit bc4d7e1230bfb10cc3154b3d11ac2ff95f48bc94
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Jul 5 11:37:40 2016 +0100

    Add a DTLS unprocesed records test
    
    Add a test to inject a record from the next epoch during the handshake and
    make sure it doesn't get processed immediately.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 48e8df6e399ec1bef53500457f16b54d798198d3
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Jul 5 11:36:10 2016 +0100

    Back port ssltestlib code to 1.0.2
    
    Enables the testing of DTLS code in 1.0.2
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 .gitignore        |   1 +
 ssl/Makefile      |   2 +-
 ssl/d1_pkt.c      |  83 +++++--
 ssl/dtlstest.c    | 147 ++++++++++++
 ssl/ssl.h         |   1 +
 ssl/ssl_err.c     |   4 +-
 test/Makefile     |  58 ++++-
 test/ssltestlib.c | 687 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 test/ssltestlib.h |  36 +++
 9 files changed, 997 insertions(+), 22 deletions(-)
 create mode 100644 ssl/dtlstest.c
 create mode 100644 test/ssltestlib.c
 create mode 100644 test/ssltestlib.h

diff --git a/.gitignore b/.gitignore
index 36c3a37..cf88779 100644
--- a/.gitignore
+++ b/.gitignore
@@ -31,6 +31,7 @@
 !/test/igetest.c
 !/test/r160test.c
 !/test/fips_algvs.c
+!/test/ssltestlib.c
 
 /test/*.ss
 /test/*.srl
diff --git a/ssl/Makefile b/ssl/Makefile
index b6dee5b..775d8ec 100644
--- a/ssl/Makefile
+++ b/ssl/Makefile
@@ -15,7 +15,7 @@ KRB5_INCLUDES=
 CFLAGS= $(INCLUDES) $(CFLAG)
 
 GENERAL=Makefile README ssl-lib.com install.com
-TEST=ssltest.c heartbeat_test.c clienthellotest.c sslv2conftest.c
+TEST=ssltest.c heartbeat_test.c clienthellotest.c sslv2conftest.c dtlstest.c
 APPS=
 
 LIB=$(TOP)/libssl.a
diff --git a/ssl/d1_pkt.c b/ssl/d1_pkt.c
index fe30ec7..589bf9e 100644
--- a/ssl/d1_pkt.c
+++ b/ssl/d1_pkt.c
@@ -194,7 +194,7 @@ static int dtls1_record_needs_buffering(SSL *s, SSL3_RECORD *rr,
 #endif
 static int dtls1_buffer_record(SSL *s, record_pqueue *q,
                                unsigned char *priority);
-static int dtls1_process_record(SSL *s);
+static int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap);
 
 /* copy buffered record into SSL structure */
 static int dtls1_copy_record(SSL *s, pitem *item)
@@ -319,21 +319,70 @@ static int dtls1_retrieve_buffered_record(SSL *s, record_pqueue *queue)
 static int dtls1_process_buffered_records(SSL *s)
 {
     pitem *item;
+    SSL3_BUFFER *rb;
+    SSL3_RECORD *rr;
+    DTLS1_BITMAP *bitmap;
+    unsigned int is_next_epoch;
+    int replayok = 1;
 
     item = pqueue_peek(s-&gt;d1-&gt;unprocessed_rcds.q);
     if (item) {
         /* Check if epoch is current. */
         if (s-&gt;d1-&gt;unprocessed_rcds.epoch != s-&gt;d1-&gt;r_epoch)
-            return (1);         /* Nothing to do. */
+            return 1;         /* Nothing to do. */
+
+        rr = &amp;s-&gt;s3-&gt;rrec;
+        rb = &amp;s-&gt;s3-&gt;rbuf;
+
+        if (rb-&gt;left &gt; 0) {
+            /*
+             * We've still got data from the current packet to read. There could
+             * be a record from the new epoch in it - so don't overwrite it
+             * with the unprocessed records yet (we'll do it when we've
+             * finished reading the current packet).
+             */
+            return 1;
+        }
+
 
         /* Process all the records. */
         while (pqueue_peek(s-&gt;d1-&gt;unprocessed_rcds.q)) {
             dtls1_get_unprocessed_record(s);
-            if (!dtls1_process_record(s))
-                return (0);
+            bitmap = dtls1_get_bitmap(s, rr, &amp;is_next_epoch);
+            if (bitmap == NULL) {
+                /*
+                 * Should not happen. This will only ever be NULL when the
+                 * current record is from a different epoch. But that cannot
+                 * be the case because we already checked the epoch above
+                 */
+                 SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,
+                        ERR_R_INTERNAL_ERROR);
+                 return 0;
+            }
+#ifndef OPENSSL_NO_SCTP
+            /* Only do replay check if no SCTP bio */
+            if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))
+#endif
+            {
+                /*
+                 * Check whether this is a repeat, or aged record. We did this
+                 * check once already when we first received the record - but
+                 * we might have updated the window since then due to
+                 * records we subsequently processed.
+                 */
+                replayok = dtls1_record_replay_check(s, bitmap);
+            }
+
+            if (!replayok || !dtls1_process_record(s, bitmap)) {
+                /* dump this record */
+                rr-&gt;length = 0;
+                s-&gt;packet_length = 0;
+                continue;
+            }
+
             if (dtls1_buffer_record(s, &amp;(s-&gt;d1-&gt;processed_rcds),
                                     s-&gt;s3-&gt;rrec.seq_num) &lt; 0)
-                return -1;
+                return 0;
         }
     }
 
@@ -344,7 +393,7 @@ static int dtls1_process_buffered_records(SSL *s)
     s-&gt;d1-&gt;processed_rcds.epoch = s-&gt;d1-&gt;r_epoch;
     s-&gt;d1-&gt;unprocessed_rcds.epoch = s-&gt;d1-&gt;r_epoch + 1;
 
-    return (1);
+    return 1;
 }
 
 #if 0
@@ -391,7 +440,7 @@ static int dtls1_get_buffered_record(SSL *s)
 
 #endif
 
-static int dtls1_process_record(SSL *s)
+static int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)
 {
     int i, al;
     int enc_err;
@@ -551,6 +600,10 @@ static int dtls1_process_record(SSL *s)
 
     /* we have pulled in a full packet so zero things */
     s-&gt;packet_length = 0;
+
+    /* Mark receipt of record. */
+    dtls1_record_bitmap_update(s, bitmap);
+
     return (1);
 
  f_err:
@@ -581,11 +634,12 @@ int dtls1_get_record(SSL *s)
 
     rr = &amp;(s-&gt;s3-&gt;rrec);
 
+ again:
     /*
      * The epoch may have changed.  If so, process all the pending records.
      * This is a non-blocking operation.
      */
-    if (dtls1_process_buffered_records(s) &lt; 0)
+    if (!dtls1_process_buffered_records(s))
         return -1;
 
     /* if we're renegotiating, then there may be buffered records */
@@ -593,7 +647,6 @@ int dtls1_get_record(SSL *s)
         return 1;
 
     /* get something from the wire */
- again:
     /* check if we have the header */
     if ((s-&gt;rstate != SSL_ST_READ_BODY) ||
         (s-&gt;packet_length &lt; DTLS1_RT_HEADER_LENGTH)) {
@@ -721,20 +774,17 @@ int dtls1_get_record(SSL *s)
             if (dtls1_buffer_record
                 (s, &amp;(s-&gt;d1-&gt;unprocessed_rcds), rr-&gt;seq_num) &lt; 0)
                 return -1;
-            /* Mark receipt of record. */
-            dtls1_record_bitmap_update(s, bitmap);
         }
         rr-&gt;length = 0;
         s-&gt;packet_length = 0;
         goto again;
     }
 
-    if (!dtls1_process_record(s)) {
+    if (!dtls1_process_record(s, bitmap)) {
         rr-&gt;length = 0;
         s-&gt;packet_length = 0;   /* dump this record */
         goto again;             /* get another record */
     }
-    dtls1_record_bitmap_update(s, bitmap); /* Mark receipt of record. */
 
     return (1);
 
@@ -1830,8 +1880,13 @@ static DTLS1_BITMAP *dtls1_get_bitmap(SSL *s, SSL3_RECORD *rr,
     if (rr-&gt;epoch == s-&gt;d1-&gt;r_epoch)
         return &amp;s-&gt;d1-&gt;bitmap;
 
-    /* Only HM and ALERT messages can be from the next epoch */
+    /*
+     * Only HM and ALERT messages can be from the next epoch and only if we
+     * have already processed all of the unprocessed records from the last
+     * epoch
+     */
     else if (rr-&gt;epoch == (unsigned long)(s-&gt;d1-&gt;r_epoch + 1) &amp;&amp;
+             s-&gt;d1-&gt;unprocessed_rcds.epoch != s-&gt;d1-&gt;r_epoch &amp;&amp;
              (rr-&gt;type == SSL3_RT_HANDSHAKE || rr-&gt;type == SSL3_RT_ALERT)) {
         *is_next_epoch = 1;
         return &amp;s-&gt;d1-&gt;next_bitmap;
diff --git a/ssl/dtlstest.c b/ssl/dtlstest.c
new file mode 100644
index 0000000..94e3ef1
--- /dev/null
+++ b/ssl/dtlstest.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;openssl/bio.h&gt;
+#include &lt;openssl/crypto.h&gt;
+#include &lt;openssl/ssl.h&gt;
+#include &lt;openssl/err.h&gt;
+
+#include &quot;ssltestlib.h&quot;
+#include &quot;testutil.h&quot;
+
+static char *cert = NULL;
+static char *privkey = NULL;
+
+#define NUM_TESTS   2
+
+
+#define DUMMY_CERT_STATUS_LEN  12
+
+unsigned char certstatus[] = {
+    SSL3_RT_HANDSHAKE, /* Content type */
+    0xfe, 0xfd, /* Record version */
+    0, 1, /* Epoch */
+    0, 0, 0, 0, 0, 0x0f, /* Record sequence number */
+    0, DTLS1_HM_HEADER_LENGTH + DUMMY_CERT_STATUS_LEN - 2,
+    SSL3_MT_CERTIFICATE_STATUS, /* Cert Status handshake message type */
+    0, 0, DUMMY_CERT_STATUS_LEN, /* Message len */
+    0, 5, /* Message sequence */
+    0, 0, 0, /* Fragment offset */
+    0, 0, DUMMY_CERT_STATUS_LEN - 2, /* Fragment len */
+    0x80, 0x80, 0x80, 0x80, 0x80,
+    0x80, 0x80, 0x80, 0x80, 0x80 /* Dummy data */
+};
+
+#define RECORD_SEQUENCE 10
+
+static int test_dtls_unprocessed(int testidx)
+{
+    SSL_CTX *sctx = NULL, *cctx = NULL;
+    SSL *serverssl1 = NULL, *clientssl1 = NULL;
+    BIO *c_to_s_fbio, *c_to_s_mempacket;
+    int testresult = 0;
+
+    printf(&quot;Starting Test %d\n&quot;, testidx);
+
+    if (!create_ssl_ctx_pair(DTLS_server_method(), DTLS_client_method(), &amp;sctx,
+                             &amp;cctx, cert, privkey)) {
+        printf(&quot;Unable to create SSL_CTX pair\n&quot;);
+        return 0;
+    }
+
+    if (!SSL_CTX_set_ecdh_auto(sctx, 1)) {
+        printf(&quot;Failed configuring auto ECDH\n&quot;);
+    }
+
+    if (!SSL_CTX_set_cipher_list(cctx, &quot;ECDHE-RSA-AES256-SHA384&quot;)) {
+        printf(&quot;Failed setting cipher list\n&quot;);
+    }
+
+    c_to_s_fbio = BIO_new(bio_f_tls_dump_filter());
+    if (c_to_s_fbio == NULL) {
+        printf(&quot;Failed to create filter BIO\n&quot;);
+        goto end;
+    }
+
+    /* BIO is freed by create_ssl_connection on error */
+    if (!create_ssl_objects(sctx, cctx, &amp;serverssl1, &amp;clientssl1, NULL,
+                               c_to_s_fbio)) {
+        printf(&quot;Unable to create SSL objects\n&quot;);
+        ERR_print_errors_fp(stdout);
+        goto end;
+    }
+
+    if (testidx == 1)
+        certstatus[RECORD_SEQUENCE] = 0xff;
+
+    /*
+     * Inject a dummy record from the next epoch. In test 0, this should never
+     * get used because the message sequence number is too big. In test 1 we set
+     * the record sequence number to be way off in the future. This should not
+     * have an impact on the record replay protection because the record should
+     * be dropped before it is marked as arrivedg
+     */
+    c_to_s_mempacket = SSL_get_wbio(clientssl1);
+    c_to_s_mempacket = BIO_next(c_to_s_mempacket);
+    mempacket_test_inject(c_to_s_mempacket, (char *)certstatus,
+                          sizeof(certstatus), 1, INJECT_PACKET_IGNORE_REC_SEQ);
+
+    if (!create_ssl_connection(serverssl1, clientssl1)) {
+        printf(&quot;Unable to create SSL connection\n&quot;);
+        ERR_print_errors_fp(stdout);
+        goto end;
+    }
+
+    testresult = 1;
+ end:
+    SSL_free(serverssl1);
+    SSL_free(clientssl1);
+    SSL_CTX_free(sctx);
+    SSL_CTX_free(cctx);
+
+    return testresult;
+}
+
+int main(int argc, char *argv[])
+{
+    BIO *err = NULL;
+    int testresult = 0;
+
+    if (argc != 3) {
+        printf(&quot;Invalid argument count\n&quot;);
+        return 1;
+    }
+
+    cert = argv[1];
+    privkey = argv[2];
+
+    err = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);
+
+    SSL_library_init();
+    SSL_load_error_strings();
+
+    CRYPTO_malloc_debug_init();
+    CRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
+    if (!test_dtls_unprocessed(0) || !test_dtls_unprocessed(1))
+        testresult = 1;
+
+    ERR_free_strings();
+    ERR_remove_thread_state(NULL);
+    EVP_cleanup();
+    CRYPTO_cleanup_all_ex_data();
+    CRYPTO_mem_leaks(err);
+    BIO_free(err);
+
+    if (!testresult)
+        printf(&quot;PASS\n&quot;);
+
+    return testresult;
+}
diff --git a/ssl/ssl.h b/ssl/ssl.h
index 028681a..2638755 100644
--- a/ssl/ssl.h
+++ b/ssl/ssl.h
@@ -2615,6 +2615,7 @@ void ERR_load_SSL_strings(void);
 # define SSL_F_DTLS1_HEARTBEAT                            305
 # define SSL_F_DTLS1_OUTPUT_CERT_CHAIN                    255
 # define SSL_F_DTLS1_PREPROCESS_FRAGMENT                  288
+# define SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS             424
 # define SSL_F_DTLS1_PROCESS_OUT_OF_SEQ_MESSAGE           256
 # define SSL_F_DTLS1_PROCESS_RECORD                       257
 # define SSL_F_DTLS1_READ_BYTES                           258
diff --git a/ssl/ssl_err.c b/ssl/ssl_err.c
index 704088d..79aaf1a 100644
--- a/ssl/ssl_err.c
+++ b/ssl/ssl_err.c
@@ -1,6 +1,6 @@
 /* ssl/ssl_err.c */
 /* ====================================================================
- * Copyright (c) 1999-2015 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1999-2016 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -93,6 +93,8 @@ static ERR_STRING_DATA SSL_str_functs[] = {
     {ERR_FUNC(SSL_F_DTLS1_HEARTBEAT), &quot;dtls1_heartbeat&quot;},
     {ERR_FUNC(SSL_F_DTLS1_OUTPUT_CERT_CHAIN), &quot;dtls1_output_cert_chain&quot;},
     {ERR_FUNC(SSL_F_DTLS1_PREPROCESS_FRAGMENT), &quot;DTLS1_PREPROCESS_FRAGMENT&quot;},
+    {ERR_FUNC(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS),
+     &quot;DTLS1_PROCESS_BUFFERED_RECORDS&quot;},
     {ERR_FUNC(SSL_F_DTLS1_PROCESS_OUT_OF_SEQ_MESSAGE),
      &quot;DTLS1_PROCESS_OUT_OF_SEQ_MESSAGE&quot;},
     {ERR_FUNC(SSL_F_DTLS1_PROCESS_RECORD), &quot;DTLS1_PROCESS_RECORD&quot;},
diff --git a/test/Makefile b/test/Makefile
index e566bab..a3a7483 100644
--- a/test/Makefile
+++ b/test/Makefile
@@ -71,6 +71,7 @@ CONSTTIMETEST=  constant_time_test
 VERIFYEXTRATEST=	verify_extra_test
 CLIENTHELLOTEST=	clienthellotest
 SSLV2CONFTEST = 	sslv2conftest
+DTLSTEST =	dtlstest
 
 TESTS=		alltests
 
@@ -84,7 +85,7 @@ EXE=	$(BNTEST)$(EXE_EXT) $(ECTEST)$(EXE_EXT)  $(ECDSATEST)$(EXE_EXT) $(ECDHTEST)
 	$(EVPTEST)$(EXE_EXT) $(EVPEXTRATEST)$(EXE_EXT) $(IGETEST)$(EXE_EXT) $(JPAKETEST)$(EXE_EXT) $(SRPTEST)$(EXE_EXT) \
 	$(ASN1TEST)$(EXE_EXT) $(V3NAMETEST)$(EXE_EXT) $(HEARTBEATTEST)$(EXE_EXT) \
 	$(CONSTTIMETEST)$(EXE_EXT) $(VERIFYEXTRATEST)$(EXE_EXT) \
-	$(CLIENTHELLOTEST)$(EXE_EXT) $(SSLV2CONFTEST)$(EXE_EXT)
+	$(CLIENTHELLOTEST)$(EXE_EXT) $(SSLV2CONFTEST)$(EXE_EXT) $(DTLSTEST)$(EXE_EXT)
 
 # $(METHTEST)$(EXE_EXT)
 
@@ -98,7 +99,7 @@ OBJ=	$(BNTEST).o $(ECTEST).o  $(ECDSATEST).o $(ECDHTEST).o $(IDEATEST).o \
 	$(BFTEST).o  $(SSLTEST).o  $(DSATEST).o  $(EXPTEST).o $(RSATEST).o \
 	$(EVPTEST).o $(EVPEXTRATEST).o $(IGETEST).o $(JPAKETEST).o $(ASN1TEST).o $(V3NAMETEST).o \
 	$(HEARTBEATTEST).o $(CONSTTIMETEST).o $(VERIFYEXTRATEST).o \
-	$(CLIENTHELLOTEST).o  $(SSLV2CONFTEST).o
+	$(CLIENTHELLOTEST).o  $(SSLV2CONFTEST).o $(DTLSTEST).o ssltestlib.o
 
 SRC=	$(BNTEST).c $(ECTEST).c  $(ECDSATEST).c $(ECDHTEST).c $(IDEATEST).c \
 	$(MD2TEST).c  $(MD4TEST).c $(MD5TEST).c \
@@ -109,10 +110,10 @@ SRC=	$(BNTEST).c $(ECTEST).c  $(ECDSATEST).c $(ECDHTEST).c $(IDEATEST).c \
 	$(BFTEST).c  $(SSLTEST).c $(DSATEST).c   $(EXPTEST).c $(RSATEST).c \
 	$(EVPTEST).c $(EVPEXTRATEST).c $(IGETEST).c $(JPAKETEST).c $(SRPTEST).c $(ASN1TEST).c \
 	$(V3NAMETEST).c $(HEARTBEATTEST).c $(CONSTTIMETEST).c $(VERIFYEXTRATEST).c \
-	$(CLIENTHELLOTEST).c  $(SSLV2CONFTEST).c
+	$(CLIENTHELLOTEST).c  $(SSLV2CONFTEST).c $(DTLSTEST).c ssltestlib.c
 
 EXHEADER= 
-HEADER=	testutil.h $(EXHEADER)
+HEADER=	testutil.h ssltestlib.h $(EXHEADER)
 
 ALL=    $(GENERAL) $(SRC) $(HEADER)
 
@@ -153,7 +154,8 @@ alltests: \
 	test_gen test_req test_pkcs7 test_verify test_dh test_dsa \
 	test_ss test_ca test_engine test_evp test_evp_extra test_ssl test_tsa test_ige \
 	test_jpake test_srp test_cms test_ocsp test_v3name test_heartbeat \
-	test_constant_time test_verify_extra test_clienthello test_sslv2conftest
+	test_constant_time test_verify_extra test_clienthello test_sslv2conftest \
+	test_dtls
 
 test_evp: $(EVPTEST)$(EXE_EXT) evptests.txt
 	../util/shlib_wrap.sh ./$(EVPTEST) evptests.txt
@@ -366,6 +368,10 @@ test_sslv2conftest: $(SSLV2CONFTEST)$(EXE_EXT)
 	@echo $(START) $@
 	../util/shlib_wrap.sh ./$(SSLV2CONFTEST)
 
+test_dtls: $(DTLSTEST)$(EXE_EXT)
+	@echo $(START) $@
+	../util/shlib_wrap.sh ./$(DTLSTEST) ../apps/server.pem ../apps/server.pem
+
 lint:
 	lint -DLINT $(INCLUDES) $(SRC)&gt;fluff
 
@@ -397,7 +403,7 @@ BUILD_CMD=shlib_target=; if [ -n &quot;$(SHARED_LIBS)&quot; ]; then \
 	fi; \
 	LIBRARIES=&quot;$(LIBSSL) $(LIBCRYPTO) $(LIBKRB5)&quot;; \
 	$(MAKE) -f $(TOP)/Makefile.shared -e \
-		CC=&quot;$${CC}&quot; APPNAME=$$target$(EXE_EXT) OBJECTS=&quot;$$target.o&quot; \
+		CC=&quot;$${CC}&quot; APPNAME=$$target$(EXE_EXT) OBJECTS=&quot;$$target.o $$exobj&quot; \
 		LIBDEPS=&quot;$(PEX_LIBS) $$LIBRARIES $(EX_LIBS)&quot; \
 		link_app.$${shlib_target}
 
@@ -546,6 +552,9 @@ $(CLIENTHELLOTEST)$(EXE_EXT): $(CLIENTHELLOTEST).o
 $(SSLV2CONFTEST)$(EXE_EXT): $(SSLV2CONFTEST).o
 	@target=$(SSLV2CONFTEST) $(BUILD_CMD)
 
+$(DTLSTEST)$(EXE_EXT): $(DTLSTEST).o ssltestlib.o $(DLIBSSL) $(DLIBCRYPTO)
+	@target=$(DTLSTEST); exobj=ssltestlib.o; $(BUILD_CMD)
+
 #$(AESTEST).o: $(AESTEST).c
 #	$(CC) -c $(CFLAGS) -DINTERMEDIATE_VALUE_KAT -DTRACE_KAT_MCT $(AESTEST).c
 
@@ -634,6 +643,25 @@ dsatest.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
 dsatest.o: ../include/openssl/ossl_typ.h ../include/openssl/rand.h
 dsatest.o: ../include/openssl/safestack.h ../include/openssl/stack.h
 dsatest.o: ../include/openssl/symhacks.h dsatest.c
+dtlstest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+dtlstest.o: ../include/openssl/buffer.h ../include/openssl/comp.h
+dtlstest.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
+dtlstest.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+dtlstest.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+dtlstest.o: ../include/openssl/err.h ../include/openssl/evp.h
+dtlstest.o: ../include/openssl/hmac.h ../include/openssl/kssl.h
+dtlstest.o: ../include/openssl/lhash.h ../include/openssl/obj_mac.h
+dtlstest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+dtlstest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+dtlstest.o: ../include/openssl/pem.h ../include/openssl/pem2.h
+dtlstest.o: ../include/openssl/pkcs7.h ../include/openssl/pqueue.h
+dtlstest.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+dtlstest.o: ../include/openssl/srtp.h ../include/openssl/ssl.h
+dtlstest.o: ../include/openssl/ssl2.h ../include/openssl/ssl23.h
+dtlstest.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
+dtlstest.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
+dtlstest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h dtlstest.c
+dtlstest.o: ssltestlib.h testutil.h
 ecdhtest.o: ../e_os.h ../include/openssl/asn1.h ../include/openssl/bio.h
 ecdhtest.o: ../include/openssl/bn.h ../include/openssl/crypto.h
 ecdhtest.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
@@ -856,6 +884,24 @@ ssltest.o: ../include/openssl/ssl3.h ../include/openssl/stack.h
 ssltest.o: ../include/openssl/symhacks.h ../include/openssl/tls1.h
 ssltest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
 ssltest.o: ../include/openssl/x509v3.h ssltest.c
+ssltestlib.o: ../include/openssl/asn1.h ../include/openssl/bio.h
+ssltestlib.o: ../include/openssl/buffer.h ../include/openssl/comp.h
+ssltestlib.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
+ssltestlib.o: ../include/openssl/e_os2.h ../include/openssl/ec.h
+ssltestlib.o: ../include/openssl/ecdh.h ../include/openssl/ecdsa.h
+ssltestlib.o: ../include/openssl/evp.h ../include/openssl/hmac.h
+ssltestlib.o: ../include/openssl/kssl.h ../include/openssl/lhash.h
+ssltestlib.o: ../include/openssl/obj_mac.h ../include/openssl/objects.h
+ssltestlib.o: ../include/openssl/opensslconf.h ../include/openssl/opensslv.h
+ssltestlib.o: ../include/openssl/ossl_typ.h ../include/openssl/pem.h
+ssltestlib.o: ../include/openssl/pem2.h ../include/openssl/pkcs7.h
+ssltestlib.o: ../include/openssl/pqueue.h ../include/openssl/safestack.h
+ssltestlib.o: ../include/openssl/sha.h ../include/openssl/srtp.h
+ssltestlib.o: ../include/openssl/ssl.h ../include/openssl/ssl2.h
+ssltestlib.o: ../include/openssl/ssl23.h ../include/openssl/ssl3.h
+ssltestlib.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+ssltestlib.o: ../include/openssl/tls1.h ../include/openssl/x509.h
+ssltestlib.o: ../include/openssl/x509_vfy.h ssltestlib.c ssltestlib.h
 sslv2conftest.o: ../include/openssl/asn1.h ../include/openssl/bio.h
 sslv2conftest.o: ../include/openssl/buffer.h ../include/openssl/comp.h
 sslv2conftest.o: ../include/openssl/crypto.h ../include/openssl/dtls1.h
diff --git a/test/ssltestlib.c b/test/ssltestlib.c
new file mode 100644
index 0000000..1592514
--- /dev/null
+++ b/test/ssltestlib.c
@@ -0,0 +1,687 @@
+/*
+ * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;string.h&gt;
+#include &lt;openssl/safestack.h&gt;
+
+#include &quot;ssltestlib.h&quot;
+
+#define SSL_IS_DTLS(s)  (s-&gt;method-&gt;version == DTLS_ANY_VERSION \
+    || s-&gt;method-&gt;version == DTLS1_2_VERSION \
+    || s-&gt;method-&gt;version == DTLS1_VERSION)
+
+static int tls_dump_new(BIO *bi);
+static int tls_dump_free(BIO *a);
+static int tls_dump_read(BIO *b, char *out, int outl);
+static int tls_dump_write(BIO *b, const char *in, int inl);
+static long tls_dump_ctrl(BIO *b, int cmd, long num, void *ptr);
+static int tls_dump_gets(BIO *bp, char *buf, int size);
+static int tls_dump_puts(BIO *bp, const char *str);
+
+/* Choose a sufficiently large type likely to be unused for this custom BIO */
+# define BIO_TYPE_TLS_DUMP_FILTER  (0x80 | BIO_TYPE_FILTER)
+
+# define BIO_TYPE_MEMPACKET_TEST      0x81
+
+static BIO_METHOD method_tls_dump = {
+    BIO_TYPE_TLS_DUMP_FILTER,
+    &quot;TLS dump filter&quot;,
+    tls_dump_write,
+    tls_dump_read,
+    tls_dump_puts,
+    tls_dump_gets,
+    tls_dump_ctrl,
+    tls_dump_new,
+    tls_dump_free
+};
+
+BIO_METHOD *bio_f_tls_dump_filter(void)
+{
+    return &amp;method_tls_dump;
+}
+
+static int tls_dump_new(BIO *bio)
+{
+    bio-&gt;init = 1;
+    return 1;
+}
+
+static int tls_dump_free(BIO *bio)
+{
+    bio-&gt;init = 0;
+
+    return 1;
+}
+
+static void copy_flags(BIO *bio)
+{
+    int flags;
+    BIO *next = BIO_next(bio);
+
+    flags = BIO_test_flags(next, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);
+    BIO_clear_flags(bio, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);
+    BIO_set_flags(bio, flags);
+}
+
+#define RECORD_CONTENT_TYPE     0
+#define RECORD_VERSION_HI       1
+#define RECORD_VERSION_LO       2
+#define RECORD_EPOCH_HI         3
+#define RECORD_EPOCH_LO         4
+#define RECORD_SEQUENCE_START   5
+#define RECORD_SEQUENCE_END     10
+#define RECORD_LEN_HI           11
+#define RECORD_LEN_LO           12
+
+#define MSG_TYPE                0
+#define MSG_LEN_HI              1
+#define MSG_LEN_MID             2
+#define MSG_LEN_LO              3
+#define MSG_SEQ_HI              4
+#define MSG_SEQ_LO              5
+#define MSG_FRAG_OFF_HI         6
+#define MSG_FRAG_OFF_MID        7
+#define MSG_FRAG_OFF_LO         8
+#define MSG_FRAG_LEN_HI         9
+#define MSG_FRAG_LEN_MID        10
+#define MSG_FRAG_LEN_LO         11
+
+
+static void dump_data(const char *data, int len)
+{
+    int rem, i, content, reclen, msglen, fragoff, fraglen, epoch;
+    unsigned char *rec;
+
+    printf(&quot;---- START OF PACKET ----\n&quot;);
+
+    rem = len;
+    rec = (unsigned char *)data;
+
+    while (rem &gt; 0) {
+        if (rem != len)
+            printf(&quot;*\n&quot;);
+        printf(&quot;*---- START OF RECORD ----\n&quot;);
+        if (rem &lt; DTLS1_RT_HEADER_LENGTH) {
+            printf(&quot;*---- RECORD TRUNCATED ----\n&quot;);
+            break;
+        }
+        content = rec[RECORD_CONTENT_TYPE];
+        printf(&quot;** Record Content-type: %d\n&quot;, content);
+        printf(&quot;** Record Version: %02x%02x\n&quot;,
+               rec[RECORD_VERSION_HI], rec[RECORD_VERSION_LO]);
+        epoch = (rec[RECORD_EPOCH_HI] &lt;&lt; 8) | rec[RECORD_EPOCH_LO];
+        printf(&quot;** Record Epoch: %d\n&quot;, epoch);
+        printf(&quot;** Record Sequence: &quot;);
+        for (i = RECORD_SEQUENCE_START; i &lt;= RECORD_SEQUENCE_END; i++)
+            printf(&quot;%02x&quot;, rec[i]);
+        reclen = (rec[RECORD_LEN_HI] &lt;&lt; 8) | rec[RECORD_LEN_LO];
+        printf(&quot;\n** Record Length: %d\n&quot;, reclen);
+
+        /* Now look at message */
+        rec += DTLS1_RT_HEADER_LENGTH;
+        rem -= DTLS1_RT_HEADER_LENGTH;
+        if (content == SSL3_RT_HANDSHAKE) {
+            printf(&quot;**---- START OF HANDSHAKE MESSAGE FRAGMENT ----\n&quot;);
+            if (epoch &gt; 0) {
+                printf(&quot;**---- HANDSHAKE MESSAGE FRAGMENT ENCRYPTED ----\n&quot;);
+            } else if (rem &lt; DTLS1_HM_HEADER_LENGTH
+                    || reclen &lt; DTLS1_HM_HEADER_LENGTH) {
+                printf(&quot;**---- HANDSHAKE MESSAGE FRAGMENT TRUNCATED ----\n&quot;);
+            } else {
+                printf(&quot;*** Message Type: %d\n&quot;, rec[MSG_TYPE]);
+                msglen = (rec[MSG_LEN_HI] &lt;&lt; 16) | (rec[MSG_LEN_MID] &lt;&lt; 8)
+                         | rec[MSG_LEN_LO];
+                printf(&quot;*** Message Length: %d\n&quot;, msglen);
+                printf(&quot;*** Message sequence: %d\n&quot;,
+                       (rec[MSG_SEQ_HI] &lt;&lt; 8) | rec[MSG_SEQ_LO]);
+                fragoff = (rec[MSG_FRAG_OFF_HI] &lt;&lt; 16)
+                          | (rec[MSG_FRAG_OFF_MID] &lt;&lt; 8)
+                          | rec[MSG_FRAG_OFF_LO];
+                printf(&quot;*** Message Fragment offset: %d\n&quot;, fragoff);
+                fraglen = (rec[MSG_FRAG_LEN_HI] &lt;&lt; 16)
+                          | (rec[MSG_FRAG_LEN_MID] &lt;&lt; 8)
+                          | rec[MSG_FRAG_LEN_LO];
+                printf(&quot;*** Message Fragment len: %d\n&quot;, fraglen);
+                if (fragoff + fraglen &gt; msglen)
+                    printf(&quot;***---- HANDSHAKE MESSAGE FRAGMENT INVALID ----\n&quot;);
+                else if(reclen &lt; fraglen)
+                    printf(&quot;**---- HANDSHAKE MESSAGE FRAGMENT TRUNCATED ----\n&quot;);
+                else
+                    printf(&quot;**---- END OF HANDSHAKE MESSAGE FRAGMENT ----\n&quot;);
+            }
+        }
+        if (rem &lt; reclen) {
+            printf(&quot;*---- RECORD TRUNCATED ----\n&quot;);
+            rem = 0;
+        } else {
+            rec += reclen;
+            rem -= reclen;
+            printf(&quot;*---- END OF RECORD ----\n&quot;);
+        }
+    }
+    printf(&quot;---- END OF PACKET ----\n\n&quot;);
+    fflush(stdout);
+}
+
+static int tls_dump_read(BIO *bio, char *out, int outl)
+{
+    int ret;
+    BIO *next = BIO_next(bio);
+
+    ret = BIO_read(next, out, outl);
+    copy_flags(bio);
+
+    if (ret &gt; 0) {
+        dump_data(out, ret);
+    }
+
+    return ret;
+}
+
+static int tls_dump_write(BIO *bio, const char *in, int inl)
+{
+    int ret;
+    BIO *next = BIO_next(bio);
+
+    ret = BIO_write(next, in, inl);
+    copy_flags(bio);
+
+    return ret;
+}
+
+static long tls_dump_ctrl(BIO *bio, int cmd, long num, void *ptr)
+{
+    long ret;
+    BIO *next = BIO_next(bio);
+
+    if (next == NULL)
+        return 0;
+
+    switch (cmd) {
+    case BIO_CTRL_DUP:
+        ret = 0L;
+        break;
+    default:
+        ret = BIO_ctrl(next, cmd, num, ptr);
+        break;
+    }
+    return ret;
+}
+
+static int tls_dump_gets(BIO *bio, char *buf, int size)
+{
+    /* We don't support this - not needed anyway */
+    return -1;
+}
+
+static int tls_dump_puts(BIO *bio, const char *str)
+{
+    return tls_dump_write(bio, str, strlen(str));
+}
+
+
+typedef struct mempacket_st {
+    unsigned char *data;
+    int len;
+    unsigned int num;
+    unsigned int type;
+} MEMPACKET;
+
+/*
+ * These defines would normally be auto-generated and in safestack.h...but this
+ * is just for tests so its probably not an appropriate place
+ */
+# define sk_MEMPACKET_new(cmp) SKM_sk_new(MEMPACKET, (cmp))
+# define sk_MEMPACKET_new_null() SKM_sk_new_null(MEMPACKET)
+# define sk_MEMPACKET_free(st) SKM_sk_free(MEMPACKET, (st))
+# define sk_MEMPACKET_num(st) SKM_sk_num(MEMPACKET, (st))
+# define sk_MEMPACKET_value(st, i) SKM_sk_value(MEMPACKET, (st), (i))
+# define sk_MEMPACKET_set(st, i, val) SKM_sk_set(MEMPACKET, (st), (i), (val))
+# define sk_MEMPACKET_zero(st) SKM_sk_zero(MEMPACKET, (st))
+# define sk_MEMPACKET_push(st, val) SKM_sk_push(MEMPACKET, (st), (val))
+# define sk_MEMPACKET_unshift(st, val) SKM_sk_unshift(MEMPACKET, (st), (val))
+# define sk_MEMPACKET_find(st, val) SKM_sk_find(MEMPACKET, (st), (val))
+# define sk_MEMPACKET_find_ex(st, val) SKM_sk_find_ex(MEMPACKET, (st), (val))
+# define sk_MEMPACKET_delete(st, i) SKM_sk_delete(MEMPACKET, (st), (i))
+# define sk_MEMPACKET_delete_ptr(st, ptr) SKM_sk_delete_ptr(MEMPACKET, (st), (ptr))
+# define sk_MEMPACKET_insert(st, val, i) SKM_sk_insert(MEMPACKET, (st), (val), (i))
+# define sk_MEMPACKET_set_cmp_func(st, cmp) SKM_sk_set_cmp_func(MEMPACKET, (st), (cmp))
+# define sk_MEMPACKET_dup(st) SKM_sk_dup(MEMPACKET, st)
+# define sk_MEMPACKET_pop_free(st, free_func) SKM_sk_pop_free(MEMPACKET, (st), (free_func))
+# define sk_MEMPACKET_deep_copy(st, copy_func, free_func) SKM_sk_deep_copy(MEMPACKET, (st), (copy_func), (free_func))
+# define sk_MEMPACKET_shift(st) SKM_sk_shift(MEMPACKET, (st))
+# define sk_MEMPACKET_pop(st) SKM_sk_pop(MEMPACKET, (st))
+# define sk_MEMPACKET_sort(st) SKM_sk_sort(MEMPACKET, (st))
+# define sk_MEMPACKET_is_sorted(st) SKM_sk_is_sorted(MEMPACKET, (st))
+
+static void mempacket_free(MEMPACKET *pkt)
+{
+    if (pkt-&gt;data != NULL)
+        OPENSSL_free(pkt-&gt;data);
+    OPENSSL_free(pkt);
+}
+
+typedef struct mempacket_test_ctx_st {
+    STACK_OF(MEMPACKET) *pkts;
+    unsigned int epoch;
+    unsigned int currrec;
+    unsigned int currpkt;
+    unsigned int lastpkt;
+    unsigned int noinject;
+} MEMPACKET_TEST_CTX;
+
+static int mempacket_test_new(BIO *bi);
+static int mempacket_test_free(BIO *a);
+static int mempacket_test_read(BIO *b, char *out, int outl);
+static int mempacket_test_write(BIO *b, const char *in, int inl);
+static long mempacket_test_ctrl(BIO *b, int cmd, long num, void *ptr);
+static int mempacket_test_gets(BIO *bp, char *buf, int size);
+static int mempacket_test_puts(BIO *bp, const char *str);
+
+static BIO_METHOD method_mempacket_test = {
+    BIO_TYPE_MEMPACKET_TEST,
+    &quot;Mem Packet Test&quot;,
+    mempacket_test_write,
+    mempacket_test_read,
+    mempacket_test_puts,
+    mempacket_test_gets,
+    mempacket_test_ctrl,
+    mempacket_test_new,
+    mempacket_test_free
+};
+
+BIO_METHOD *bio_s_mempacket_test(void)
+{
+    return &amp;method_mempacket_test;
+}
+
+static int mempacket_test_new(BIO *bio)
+{
+    MEMPACKET_TEST_CTX *ctx = OPENSSL_malloc(sizeof(*ctx));
+    if (ctx == NULL)
+        return 0;
+    memset(ctx, 0, sizeof(*ctx));
+
+    ctx-&gt;pkts = sk_MEMPACKET_new_null();
+    if (ctx-&gt;pkts == NULL) {
+        OPENSSL_free(ctx);
+        return 0;
+    }
+    bio-&gt;init = 1;
+    bio-&gt;ptr = ctx;
+    return 1;
+}
+
+static int mempacket_test_free(BIO *bio)
+{
+    MEMPACKET_TEST_CTX *ctx = bio-&gt;ptr;
+
+    sk_MEMPACKET_pop_free(ctx-&gt;pkts, mempacket_free);
+    OPENSSL_free(ctx);
+    bio-&gt;ptr = NULL;
+    bio-&gt;init = 0;
+
+    return 1;
+}
+
+/* Record Header values */
+#define EPOCH_HI        4
+#define EPOCH_LO        5
+#define RECORD_SEQUENCE 10
+#define RECORD_LEN_HI   11
+#define RECORD_LEN_LO   12
+
+#define STANDARD_PACKET                 0
+
+static int mempacket_test_read(BIO *bio, char *out, int outl)
+{
+    MEMPACKET_TEST_CTX *ctx = bio-&gt;ptr;
+    MEMPACKET *thispkt;
+    unsigned char *rec;
+    int rem;
+    unsigned int seq, offset, len, epoch;
+
+    BIO_clear_retry_flags(bio);
+
+    thispkt = sk_MEMPACKET_value(ctx-&gt;pkts, 0);
+    if (thispkt == NULL || thispkt-&gt;num != ctx-&gt;currpkt) {
+        /* Probably run out of data */
+        BIO_set_retry_read(bio);
+        return -1;
+    }
+    sk_MEMPACKET_shift(ctx-&gt;pkts);
+    ctx-&gt;currpkt++;
+
+    if (outl &gt; thispkt-&gt;len)
+        outl = thispkt-&gt;len;
+
+    if (thispkt-&gt;type != INJECT_PACKET_IGNORE_REC_SEQ) {
+        /*
+         * Overwrite the record sequence number. We strictly number them in
+         * the order received. Since we are actually a reliable transport
+         * we know that there won't be any re-ordering. We overwrite to deal
+         * with any packets that have been injected
+         */
+        rem = thispkt-&gt;len;
+        rec = thispkt-&gt;data;
+        while (rem &gt; 0) {
+            if (rem &lt; DTLS1_RT_HEADER_LENGTH) {
+                return -1;
+            }
+            epoch = (rec[EPOCH_HI] &lt;&lt; 8) | rec[EPOCH_LO];
+            if (epoch != ctx-&gt;epoch) {
+                ctx-&gt;epoch = epoch;
+                ctx-&gt;currrec = 0;
+            }
+            seq = ctx-&gt;currrec;
+            offset = 0;
+            do {
+                rec[RECORD_SEQUENCE - offset] = seq &amp; 0xFF;
+                seq &gt;&gt;= 8;
+                offset++;
+            } while (seq &gt; 0);
+            ctx-&gt;currrec++;
+
+            len = ((rec[RECORD_LEN_HI] &lt;&lt; 8) | rec[RECORD_LEN_LO])
+                  + DTLS1_RT_HEADER_LENGTH;
+
+            rec += len;
+            rem -= len;
+        }
+    }
+
+    memcpy(out, thispkt-&gt;data, outl);
+
+    mempacket_free(thispkt);
+
+    return outl;
+}
+
+int mempacket_test_inject(BIO *bio, const char *in, int inl, int pktnum,
+                          int type)
+{
+    MEMPACKET_TEST_CTX *ctx = bio-&gt;ptr;
+    MEMPACKET *thispkt, *looppkt, *nextpkt;
+    int i;
+
+    if (ctx == NULL)
+        return -1;
+
+    /* We only allow injection before we've started writing any data */
+    if (pktnum &gt;= 0) {
+        if (ctx-&gt;noinject)
+            return -1;
+    } else {
+        ctx-&gt;noinject = 1;
+    }
+
+    thispkt = OPENSSL_malloc(sizeof(MEMPACKET));
+    if (thispkt == NULL)
+        return -1;
+
+    thispkt-&gt;data = OPENSSL_malloc(inl);
+    if (thispkt-&gt;data == NULL) {
+        mempacket_free(thispkt);
+        return -1;
+    }
+
+    memcpy(thispkt-&gt;data, in, inl);
+    thispkt-&gt;len = inl;
+    thispkt-&gt;num = (pktnum &gt;= 0) ? (unsigned int)pktnum : ctx-&gt;lastpkt;
+    thispkt-&gt;type = type;
+
+    for(i = 0; (looppkt = sk_MEMPACKET_value(ctx-&gt;pkts, i)) != NULL; i++) {
+        /* Check if we found the right place to insert this packet */
+        if (looppkt-&gt;num &gt; thispkt-&gt;num) {
+            if (sk_MEMPACKET_insert(ctx-&gt;pkts, thispkt, i) == 0) {
+                mempacket_free(thispkt);
+                return -1;
+            }
+            /* If we're doing up front injection then we're done */
+            if (pktnum &gt;= 0)
+                return inl;
+            /*
+             * We need to do some accounting on lastpkt. We increment it first,
+             * but it might now equal the value of injected packets, so we need
+             * to skip over those
+             */
+            ctx-&gt;lastpkt++;
+            do {
+                i++;
+                nextpkt = sk_MEMPACKET_value(ctx-&gt;pkts, i);
+                if (nextpkt != NULL &amp;&amp; nextpkt-&gt;num == ctx-&gt;lastpkt)
+                    ctx-&gt;lastpkt++;
+                else
+                    return inl;
+            } while(1);
+        } else if(looppkt-&gt;num == thispkt-&gt;num) {
+            if (!ctx-&gt;noinject) {
+                /* We injected two packets with the same packet number! */
+                return -1;
+            }
+            ctx-&gt;lastpkt++;
+            thispkt-&gt;num++;
+        }
+    }
+    /*
+     * We didn't find any packets with a packet number equal to or greater than
+     * this one, so we just add it onto the end
+     */
+    if (!sk_MEMPACKET_push(ctx-&gt;pkts, thispkt)) {
+        mempacket_free(thispkt);
+        return -1;
+    }
+
+    if (pktnum &lt; 0)
+        ctx-&gt;lastpkt++;
+
+    return inl;
+}
+
+static int mempacket_test_write(BIO *bio, const char *in, int inl)
+{
+    return mempacket_test_inject(bio, in, inl, -1, STANDARD_PACKET);
+}
+
+static long mempacket_test_ctrl(BIO *bio, int cmd, long num, void *ptr)
+{
+    long ret = 1;
+    MEMPACKET_TEST_CTX *ctx = bio-&gt;ptr;
+    MEMPACKET *thispkt;
+
+    switch (cmd) {
+    case BIO_CTRL_EOF:
+        ret = (long)(sk_MEMPACKET_num(ctx-&gt;pkts) == 0);
+        break;
+    case BIO_CTRL_GET_CLOSE:
+        ret = bio-&gt;shutdown;
+        break;
+    case BIO_CTRL_SET_CLOSE:
+        bio-&gt;shutdown = (int)num;
+        break;
+    case BIO_CTRL_WPENDING:
+        ret = 0L;
+        break;
+    case BIO_CTRL_PENDING:
+        thispkt = sk_MEMPACKET_value(ctx-&gt;pkts, 0);
+        if (thispkt == NULL)
+            ret = 0;
+        else
+            ret = thispkt-&gt;len;
+        break;
+    case BIO_CTRL_FLUSH:
+        ret = 1;
+        break;
+    case BIO_CTRL_RESET:
+    case BIO_CTRL_DUP:
+    case BIO_CTRL_PUSH:
+    case BIO_CTRL_POP:
+    default:
+        ret = 0;
+        break;
+    }
+    return ret;
+}
+
+static int mempacket_test_gets(BIO *bio, char *buf, int size)
+{
+    /* We don't support this - not needed anyway */
+    return -1;
+}
+
+static int mempacket_test_puts(BIO *bio, const char *str)
+{
+    return mempacket_test_write(bio, str, strlen(str));
+}
+
+int create_ssl_ctx_pair(const SSL_METHOD *sm, const SSL_METHOD *cm,
+                        SSL_CTX **sctx, SSL_CTX **cctx, char *certfile,
+                        char *privkeyfile)
+{
+    SSL_CTX *serverctx = NULL;
+    SSL_CTX *clientctx = NULL;
+
+    serverctx = SSL_CTX_new(sm);
+    clientctx = SSL_CTX_new(cm);
+    if (serverctx == NULL || clientctx == NULL) {
+        printf(&quot;Failed to create SSL_CTX\n&quot;);
+        goto err;
+    }
+
+    if (SSL_CTX_use_certificate_file(serverctx, certfile,
+                                     SSL_FILETYPE_PEM) &lt;= 0) {
+        printf(&quot;Failed to load server certificate\n&quot;);
+        goto err;
+    }
+    if (SSL_CTX_use_PrivateKey_file(serverctx, privkeyfile,
+                                    SSL_FILETYPE_PEM) &lt;= 0) {
+        printf(&quot;Failed to load server private key\n&quot;);
+    }
+    if (SSL_CTX_check_private_key(serverctx) &lt;= 0) {
+        printf(&quot;Failed to check private key\n&quot;);
+        goto err;
+    }
+
+    *sctx = serverctx;
+    *cctx = clientctx;
+
+    return 1;
+ err:
+    SSL_CTX_free(serverctx);
+    SSL_CTX_free(clientctx);
+    return 0;
+}
+
+#define MAXLOOPS    100000
+
+/*
+ * NOTE: Transfers control of the BIOs - this function will free them on error
+ */
+int create_ssl_objects(SSL_CTX *serverctx, SSL_CTX *clientctx, SSL **sssl,
+                          SSL **cssl, BIO *s_to_c_fbio, BIO *c_to_s_fbio)
+{
+    SSL *serverssl, *clientssl;
+    BIO *s_to_c_bio = NULL, *c_to_s_bio = NULL;
+
+    serverssl = SSL_new(serverctx);
+    clientssl = SSL_new(clientctx);
+
+    if (serverssl == NULL || clientssl == NULL) {
+        printf(&quot;Failed to create SSL object\n&quot;);
+        goto error;
+    }
+
+    if (SSL_IS_DTLS(clientssl)) {
+        s_to_c_bio = BIO_new(bio_s_mempacket_test());
+        c_to_s_bio = BIO_new(bio_s_mempacket_test());;
+    } else {
+        s_to_c_bio = BIO_new(BIO_s_mem());
+        c_to_s_bio = BIO_new(BIO_s_mem());
+    }
+    if (s_to_c_bio == NULL || c_to_s_bio == NULL) {
+        printf(&quot;Failed to create mem BIOs\n&quot;);
+        goto error;
+    }
+
+    if (s_to_c_fbio != NULL)
+        s_to_c_bio = BIO_push(s_to_c_fbio, s_to_c_bio);
+    if (c_to_s_fbio != NULL)
+        c_to_s_bio = BIO_push(c_to_s_fbio, c_to_s_bio);
+    if (s_to_c_bio == NULL || c_to_s_bio == NULL) {
+        printf(&quot;Failed to create chained BIOs\n&quot;);
+        goto error;
+    }
+
+    /* Set Non-blocking IO behaviour */
+    BIO_set_mem_eof_return(s_to_c_bio, -1);
+    BIO_set_mem_eof_return(c_to_s_bio, -1);
+
+    /* Up ref these as we are passing them to two SSL objects */
+    CRYPTO_add(&amp;s_to_c_bio-&gt;references, 1, CRYPTO_LOCK_BIO);
+    CRYPTO_add(&amp;c_to_s_bio-&gt;references, 1, CRYPTO_LOCK_BIO);
+
+    SSL_set_bio(serverssl, c_to_s_bio, s_to_c_bio);
+    SSL_set_bio(clientssl, s_to_c_bio, c_to_s_bio);
+
+    /* BIOs will now be freed when SSL objects are freed */
+    s_to_c_bio = c_to_s_bio = NULL;
+    s_to_c_fbio = c_to_s_fbio = NULL;
+
+    *sssl = serverssl;
+    *cssl = clientssl;
+
+    return 1;
+
+ error:
+    SSL_free(serverssl);
+    SSL_free(clientssl);
+    BIO_free(s_to_c_bio);
+    BIO_free(c_to_s_bio);
+    BIO_free(s_to_c_fbio);
+    BIO_free(c_to_s_fbio);
+
+    return 0;
+}
+
+int create_ssl_connection(SSL *serverssl, SSL *clientssl)
+{
+    int retc = -1, rets = -1, err, abortctr = 0;
+
+    do {
+        err = SSL_ERROR_WANT_WRITE;
+        while (retc &lt;= 0 &amp;&amp; err == SSL_ERROR_WANT_WRITE) {
+            retc = SSL_connect(clientssl);
+            if (retc &lt;= 0)
+                err = SSL_get_error(clientssl, retc);
+        }
+
+        if (retc &lt;= 0 &amp;&amp; err != SSL_ERROR_WANT_READ) {
+            printf(&quot;SSL_connect() failed %d, %d\n&quot;, retc, err);
+            return 0;
+        }
+
+        err = SSL_ERROR_WANT_WRITE;
+        while (rets &lt;= 0 &amp;&amp; err == SSL_ERROR_WANT_WRITE) {
+            rets = SSL_accept(serverssl);
+            if (rets &lt;= 0)
+                err = SSL_get_error(serverssl, rets);
+        }
+
+        if (rets &lt;= 0 &amp;&amp; err != SSL_ERROR_WANT_READ) {
+            printf(&quot;SSL_accept() failed %d, %d\n&quot;, retc, err);
+            return 0;
+        }
+        if (++abortctr == MAXLOOPS) {
+            printf(&quot;No progress made\n&quot;);
+            return 0;
+        }
+    } while (retc &lt;=0 || rets &lt;= 0);
+
+    return 1;
+}
diff --git a/test/ssltestlib.h b/test/ssltestlib.h
new file mode 100644
index 0000000..b23d8f4
--- /dev/null
+++ b/test/ssltestlib.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef HEADER_SSLTESTLIB_H
+# define HEADER_SSLTESTLIB_H
+
+# include &lt;openssl/ssl.h&gt;
+
+int create_ssl_ctx_pair(const SSL_METHOD *sm, const SSL_METHOD *cm,
+                        SSL_CTX **sctx, SSL_CTX **cctx, char *certfile,
+                        char *privkeyfile);
+int create_ssl_objects(SSL_CTX *serverctx, SSL_CTX *clientctx, SSL **sssl,
+                       SSL **cssl, BIO *s_to_c_fbio, BIO *c_to_s_fbio);
+int create_ssl_connection(SSL *serverssl, SSL *clientssl);
+
+/* Note: Not thread safe! */
+BIO_METHOD *bio_f_tls_dump_filter(void);
+void bio_f_tls_dump_filter_free(void);
+
+BIO_METHOD *bio_s_mempacket_test(void);
+void bio_s_mempacket_test_free(void);
+
+/* Packet types - value 0 is reserved */
+#define INJECT_PACKET                   1
+#define INJECT_PACKET_IGNORE_REC_SEQ    2
+
+int mempacket_test_inject(BIO *bio, const char *in, int inl, int pktnum,
+                          int type);
+
+#endif /* HEADER_SSLTESTLIB_H */
</PRE>






































































































<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009866.html">[openssl-commits] [openssl]  OpenSSL_1_0_2-stable update
</A></li>
	<LI>Next message: <A HREF="009874.html">[openssl-commits] [openssl]  OpenSSL_1_0_2-stable update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9869">[ date ]</a>
              <a href="thread.html#9869">[ thread ]</a>
              <a href="subject.html#9869">[ subject ]</a>
              <a href="author.html#9869">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
