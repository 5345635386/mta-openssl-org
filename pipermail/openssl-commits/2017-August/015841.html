<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2017-August/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1502203683.457961.28410.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015833.html">
   <LINK REL="Next"  HREF="015845.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Dr. Stephen Henson</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1502203683.457961.28410.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">steve at openssl.org
       </A><BR>
    <I>Tue Aug  8 14:48:03 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="015833.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="015845.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15841">[ date ]</a>
              <a href="thread.html#15841">[ thread ]</a>
              <a href="subject.html#15841">[ subject ]</a>
              <a href="author.html#15841">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  6d8aba7b8c5dc63bd8f4592538af3d41a274659b (commit)
       via  6aa907a6bf4d533da657dbb7176012fab40a0544 (commit)
       via  cefa762ee5c28359986c6af5bf4db4e901f75846 (commit)
      from  9ed79d8ee1ef845fce94739787d45ad03f675eaa (commit)


- Log -----------------------------------------------------------------
commit 6d8aba7b8c5dc63bd8f4592538af3d41a274659b
Author: Johannes Bauer &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">joe at johannes-bauer.com</A>&gt;
Date:   Tue Aug 8 00:21:30 2017 +0200

    Add documentation for the scrypt PKEY_METHOD
    
    Added manpage for the new scrypt EVP_PKEY_METHOD KDF interface.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    Reviewed-by: Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/4026">https://github.com/openssl/openssl/pull/4026</A>)

commit 6aa907a6bf4d533da657dbb7176012fab40a0544
Author: Johannes Bauer &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">joe at johannes-bauer.com</A>&gt;
Date:   Thu Aug 3 21:44:18 2017 +0200

    Add PKEY_METHOD macro tests
    
    Added the pkey_meth_kdf_test tests which test the PKEY_METHOD macros (at
    the moment, of HKDF and scrypt).
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    Reviewed-by: Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/4026">https://github.com/openssl/openssl/pull/4026</A>)

commit cefa762ee5c28359986c6af5bf4db4e901f75846
Author: Johannes Bauer &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">joe at johannes-bauer.com</A>&gt;
Date:   Sat Jul 22 20:04:55 2017 +0200

    Add interface to the scrypt KDF by means of PKEY_METHOD
    
    Add an interface that allows accessing the scrypt KDF as a PKEY_METHOD.
    This fixes #4021 (at least for the scrypt portion of the issue).
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    Reviewed-by: Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/4026">https://github.com/openssl/openssl/pull/4026</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/err/openssl.txt                             |   7 +
 crypto/evp/pmeth_lib.c                             |  10 +
 crypto/include/internal/evp_int.h                  |   1 +
 crypto/kdf/build.info                              |   2 +-
 crypto/kdf/kdf_err.c                               |  10 +
 crypto/kdf/scrypt.c                                | 258 +++++++++++++++++++++
 crypto/objects/obj_dat.h                           |   4 +-
 crypto/objects/objects.txt                         |   3 +-
 doc/man7/scrypt.pod                                | 158 +++++++++++++
 include/openssl/evp.h                              |   3 +
 include/openssl/kdf.h                              |  31 +++
 include/openssl/kdferr.h                           |   7 +
 include/openssl/obj_mac.h                          |   1 +
 test/build.info                                    |   7 +-
 test/pkey_meth_kdf_test.c                          | 135 +++++++++++
 test/recipes/30-test_evp_data/evpkdf.txt           |  50 ++++
 ...60-test_x509_time.t =&gt; 30-test_pkey_meth_kdf.t} |   2 +-
 util/libcrypto.num                                 |   1 +
 18 files changed, 684 insertions(+), 6 deletions(-)
 create mode 100644 crypto/kdf/scrypt.c
 create mode 100644 doc/man7/scrypt.pod
 create mode 100644 test/pkey_meth_kdf_test.c
 copy test/recipes/{60-test_x509_time.t =&gt; 30-test_pkey_meth_kdf.t} (86%)

diff --git a/crypto/err/openssl.txt b/crypto/err/openssl.txt
index 6d7ac4e..cbbbdae 100644
--- a/crypto/err/openssl.txt
+++ b/crypto/err/openssl.txt
@@ -703,6 +703,9 @@ EVP_F_RC5_CTRL:125:rc5_ctrl
 EVP_F_UPDATE:173:update
 KDF_F_PKEY_HKDF_CTRL_STR:103:pkey_hkdf_ctrl_str
 KDF_F_PKEY_HKDF_DERIVE:102:pkey_hkdf_derive
+KDF_F_PKEY_SCRYPT_CTRL_STR:104:pkey_scrypt_ctrl_str
+KDF_F_PKEY_SCRYPT_CTRL_UINT64:105:pkey_scrypt_ctrl_uint64
+KDF_F_PKEY_SCRYPT_DERIVE:109:pkey_scrypt_derive
 KDF_F_PKEY_TLS1_PRF_CTRL_STR:100:pkey_tls1_prf_ctrl_str
 KDF_F_PKEY_TLS1_PRF_DERIVE:101:pkey_tls1_prf_derive
 OBJ_F_OBJ_ADD_OBJECT:105:OBJ_add_object
@@ -1966,12 +1969,16 @@ EVP_R_UNSUPPORTED_SALT_TYPE:126:unsupported salt type
 EVP_R_WRAP_MODE_NOT_ALLOWED:170:wrap mode not allowed
 EVP_R_WRONG_FINAL_BLOCK_LENGTH:109:wrong final block length
 KDF_R_INVALID_DIGEST:100:invalid digest
+KDF_R_MISSING_ITERATION_COUNT:109:missing iteration count
 KDF_R_MISSING_KEY:104:missing key
 KDF_R_MISSING_MESSAGE_DIGEST:105:missing message digest
 KDF_R_MISSING_PARAMETER:101:missing parameter
+KDF_R_MISSING_PASS:110:missing pass
+KDF_R_MISSING_SALT:111:missing salt
 KDF_R_MISSING_SECRET:107:missing secret
 KDF_R_MISSING_SEED:106:missing seed
 KDF_R_UNKNOWN_PARAMETER_TYPE:103:unknown parameter type
+KDF_R_VALUE_ERROR:108:value error
 KDF_R_VALUE_MISSING:102:value missing
 OBJ_R_OID_EXISTS:102:oid exists
 OBJ_R_UNKNOWN_NID:101:unknown nid
diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index b317e41..322fdb4 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -21,6 +21,7 @@ typedef int sk_cmp_fn_type(const char *const *a, const char *const *b);
 
 static STACK_OF(EVP_PKEY_METHOD) *app_pkey_methods = NULL;
 
+/* This array needs to be in order of NIDs */
 static const EVP_PKEY_METHOD *standard_methods[] = {
 #ifndef OPENSSL_NO_RSA
     &amp;rsa_pkey_meth,
@@ -44,6 +45,9 @@ static const EVP_PKEY_METHOD *standard_methods[] = {
 #ifndef OPENSSL_NO_DH
     &amp;dhx_pkey_meth,
 #endif
+#ifndef OPENSSL_NO_SCRYPT
+    &amp;scrypt_pkey_meth,
+#endif
     &amp;tls1_prf_pkey_meth,
 #ifndef OPENSSL_NO_EC
     &amp;ecx25519_pkey_meth,
@@ -355,6 +359,12 @@ int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
 
 }
 
+int EVP_PKEY_CTX_ctrl_uint64(EVP_PKEY_CTX *ctx, int keytype, int optype,
+                                int cmd, uint64_t value)
+{
+    return EVP_PKEY_CTX_ctrl(ctx, keytype, optype, cmd, 0, &amp;value);
+}
+
 int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx,
                           const char *name, const char *value)
 {
diff --git a/crypto/include/internal/evp_int.h b/crypto/include/internal/evp_int.h
index 635e7b5..be1b9be 100644
--- a/crypto/include/internal/evp_int.h
+++ b/crypto/include/internal/evp_int.h
@@ -91,6 +91,7 @@ extern const EVP_PKEY_METHOD ed25519_pkey_meth;
 extern const EVP_PKEY_METHOD hmac_pkey_meth;
 extern const EVP_PKEY_METHOD rsa_pkey_meth;
 extern const EVP_PKEY_METHOD rsa_pss_pkey_meth;
+extern const EVP_PKEY_METHOD scrypt_pkey_meth;
 extern const EVP_PKEY_METHOD tls1_prf_pkey_meth;
 extern const EVP_PKEY_METHOD hkdf_pkey_meth;
 extern const EVP_PKEY_METHOD poly1305_pkey_meth;
diff --git a/crypto/kdf/build.info b/crypto/kdf/build.info
index cbe2080..c166399 100644
--- a/crypto/kdf/build.info
+++ b/crypto/kdf/build.info
@@ -1,3 +1,3 @@
 LIBS=../../libcrypto
 SOURCE[../../libcrypto]=\
-        tls1_prf.c kdf_err.c hkdf.c
+        tls1_prf.c kdf_err.c hkdf.c scrypt.c
diff --git a/crypto/kdf/kdf_err.c b/crypto/kdf/kdf_err.c
index 8d27272..c7b84b0 100644
--- a/crypto/kdf/kdf_err.c
+++ b/crypto/kdf/kdf_err.c
@@ -16,6 +16,11 @@
 static const ERR_STRING_DATA KDF_str_functs[] = {
     {ERR_PACK(ERR_LIB_KDF, KDF_F_PKEY_HKDF_CTRL_STR, 0), &quot;pkey_hkdf_ctrl_str&quot;},
     {ERR_PACK(ERR_LIB_KDF, KDF_F_PKEY_HKDF_DERIVE, 0), &quot;pkey_hkdf_derive&quot;},
+    {ERR_PACK(ERR_LIB_KDF, KDF_F_PKEY_SCRYPT_CTRL_STR, 0),
+     &quot;pkey_scrypt_ctrl_str&quot;},
+    {ERR_PACK(ERR_LIB_KDF, KDF_F_PKEY_SCRYPT_CTRL_UINT64, 0),
+     &quot;pkey_scrypt_ctrl_uint64&quot;},
+    {ERR_PACK(ERR_LIB_KDF, KDF_F_PKEY_SCRYPT_DERIVE, 0), &quot;pkey_scrypt_derive&quot;},
     {ERR_PACK(ERR_LIB_KDF, KDF_F_PKEY_TLS1_PRF_CTRL_STR, 0),
      &quot;pkey_tls1_prf_ctrl_str&quot;},
     {ERR_PACK(ERR_LIB_KDF, KDF_F_PKEY_TLS1_PRF_DERIVE, 0),
@@ -25,14 +30,19 @@ static const ERR_STRING_DATA KDF_str_functs[] = {
 
 static const ERR_STRING_DATA KDF_str_reasons[] = {
     {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_INVALID_DIGEST), &quot;invalid digest&quot;},
+    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_ITERATION_COUNT),
+    &quot;missing iteration count&quot;},
     {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_KEY), &quot;missing key&quot;},
     {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_MESSAGE_DIGEST),
     &quot;missing message digest&quot;},
     {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_PARAMETER), &quot;missing parameter&quot;},
+    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_PASS), &quot;missing pass&quot;},
+    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_SALT), &quot;missing salt&quot;},
     {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_SECRET), &quot;missing secret&quot;},
     {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_MISSING_SEED), &quot;missing seed&quot;},
     {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_UNKNOWN_PARAMETER_TYPE),
     &quot;unknown parameter type&quot;},
+    {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_VALUE_ERROR), &quot;value error&quot;},
     {ERR_PACK(ERR_LIB_KDF, 0, KDF_R_VALUE_MISSING), &quot;value missing&quot;},
     {0, NULL}
 };
diff --git a/crypto/kdf/scrypt.c b/crypto/kdf/scrypt.c
new file mode 100644
index 0000000..c7aa823
--- /dev/null
+++ b/crypto/kdf/scrypt.c
@@ -0,0 +1,258 @@
+/*
+ * Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;openssl/hmac.h&gt;
+#include &lt;openssl/kdf.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &quot;internal/cryptlib.h&quot;
+#include &quot;internal/evp_int.h&quot;
+
+static int atou64(const char *nptr, uint64_t *result);
+
+typedef struct {
+    unsigned char *pass;
+    size_t pass_len;
+    unsigned char *salt;
+    size_t salt_len;
+    uint64_t N, r, p;
+    uint64_t maxmem_bytes;
+} SCRYPT_PKEY_CTX;
+
+/* Custom uint64_t parser since we do not have strtoull */
+static int atou64(const char *nptr, uint64_t *result)
+{
+    uint64_t value = 0;
+
+    while (*nptr) {
+        unsigned int digit;
+        uint64_t new_value;
+
+        if ((*nptr &lt; '0') || (*nptr &gt; '9')) {
+            return 0;
+        }
+        digit = (unsigned int)(*nptr - '0');
+        new_value = (value * 10) + digit;
+        if ((new_value &lt; digit) || ((new_value - digit) / 10 != value)) {
+            /* Overflow */
+            return 0;
+        }
+        value = new_value;
+        nptr++;
+    }
+    *result = value;
+    return 1;
+}
+
+static int pkey_scrypt_init(EVP_PKEY_CTX *ctx)
+{
+    SCRYPT_PKEY_CTX *kctx;
+
+    kctx = OPENSSL_zalloc(sizeof(*kctx));
+    if (kctx == NULL)
+        return 0;
+
+    /* Default values are the most conservative recommendation given in the
+     * original paper of C. Percival. Derivation uses roughly 1 GiB of memory
+     * for this parameter choice (approx. 128 * r * (N + p) bytes).
+     */
+    kctx-&gt;N = 1 &lt;&lt; 20;
+    kctx-&gt;r = 8;
+    kctx-&gt;p = 1;
+    kctx-&gt;maxmem_bytes = 1025 * 1024 * 1024;
+
+    ctx-&gt;data = kctx;
+
+    return 1;
+}
+
+static void pkey_scrypt_cleanup(EVP_PKEY_CTX *ctx)
+{
+    SCRYPT_PKEY_CTX *kctx = ctx-&gt;data;
+
+    OPENSSL_clear_free(kctx-&gt;salt, kctx-&gt;salt_len);
+    OPENSSL_clear_free(kctx-&gt;pass, kctx-&gt;pass_len);
+    OPENSSL_free(kctx);
+}
+
+static int pkey_scrypt_set_membuf(unsigned char **buffer, size_t *buflen,
+                                  const unsigned char *new_buffer,
+                                  const int new_buflen)
+{
+    if (new_buffer == NULL)
+        return 1;
+
+    if (new_buflen &lt; 0)
+        return 0;
+
+    if (*buffer != NULL)
+        OPENSSL_clear_free(*buffer, *buflen);
+
+    if (new_buflen &gt; 0) {
+        *buffer = OPENSSL_memdup(new_buffer, new_buflen);
+    } else {
+        *buffer = OPENSSL_malloc(1);
+    }
+    if (*buffer == NULL)
+        return 0;
+
+    *buflen = new_buflen;
+    return 1;
+}
+
+static int is_power_of_two(uint64_t value)
+{
+    return (value != 0) &amp;&amp; ((value &amp; (value - 1)) == 0);
+}
+
+static int pkey_scrypt_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
+{
+    SCRYPT_PKEY_CTX *kctx = ctx-&gt;data;
+    uint64_t u64_value;
+
+    switch (type) {
+    case EVP_PKEY_CTRL_PASS:
+        return pkey_scrypt_set_membuf(&amp;kctx-&gt;pass, &amp;kctx-&gt;pass_len, p2, p1);
+
+    case EVP_PKEY_CTRL_SCRYPT_SALT:
+        return pkey_scrypt_set_membuf(&amp;kctx-&gt;salt, &amp;kctx-&gt;salt_len, p2, p1);
+
+    case EVP_PKEY_CTRL_SCRYPT_N:
+        u64_value = *((uint64_t *)p2);
+        if ((u64_value &lt;= 1) || !is_power_of_two(u64_value))
+            return 0;
+        kctx-&gt;N = u64_value;
+        return 1;
+
+    case EVP_PKEY_CTRL_SCRYPT_R:
+        u64_value = *((uint64_t *)p2);
+        if (u64_value &lt; 1)
+            return 0;
+        kctx-&gt;r = u64_value;
+        return 1;
+
+    case EVP_PKEY_CTRL_SCRYPT_P:
+        u64_value = *((uint64_t *)p2);
+        if (u64_value &lt; 1)
+            return 0;
+        kctx-&gt;p = u64_value;
+        return 1;
+
+    case EVP_PKEY_CTRL_SCRYPT_MAXMEM_BYTES:
+        u64_value = *((uint64_t *)p2);
+        if (u64_value &lt; 1)
+            return 0;
+        kctx-&gt;maxmem_bytes = u64_value;
+        return 1;
+
+    default:
+        return -2;
+
+    }
+}
+
+static int pkey_scrypt_ctrl_uint64(EVP_PKEY_CTX *ctx, int type,
+                                   const char *value)
+{
+    uint64_t int_value;
+
+    if (!atou64(value, &amp;int_value)) {
+        KDFerr(KDF_F_PKEY_SCRYPT_CTRL_UINT64, KDF_R_VALUE_ERROR);
+        return 0;
+    }
+    return pkey_scrypt_ctrl(ctx, type, 0, &amp;int_value);
+}
+
+static int pkey_scrypt_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
+                                const char *value)
+{
+    if (value == NULL) {
+        KDFerr(KDF_F_PKEY_SCRYPT_CTRL_STR, KDF_R_VALUE_MISSING);
+        return 0;
+    }
+
+    if (strcmp(type, &quot;pass&quot;) == 0)
+        return EVP_PKEY_CTX_str2ctrl(ctx, EVP_PKEY_CTRL_PASS, value);
+
+    if (strcmp(type, &quot;hexpass&quot;) == 0)
+        return EVP_PKEY_CTX_hex2ctrl(ctx, EVP_PKEY_CTRL_PASS, value);
+
+    if (strcmp(type, &quot;salt&quot;) == 0)
+        return EVP_PKEY_CTX_str2ctrl(ctx, EVP_PKEY_CTRL_SCRYPT_SALT, value);
+
+    if (strcmp(type, &quot;hexsalt&quot;) == 0)
+        return EVP_PKEY_CTX_hex2ctrl(ctx, EVP_PKEY_CTRL_SCRYPT_SALT, value);
+
+    if (strcmp(type, &quot;N&quot;) == 0)
+        return pkey_scrypt_ctrl_uint64(ctx, EVP_PKEY_CTRL_SCRYPT_N, value);
+
+    if (strcmp(type, &quot;r&quot;) == 0)
+        return pkey_scrypt_ctrl_uint64(ctx, EVP_PKEY_CTRL_SCRYPT_R, value);
+
+    if (strcmp(type, &quot;p&quot;) == 0)
+        return pkey_scrypt_ctrl_uint64(ctx, EVP_PKEY_CTRL_SCRYPT_P, value);
+
+    if (strcmp(type, &quot;maxmem_bytes&quot;) == 0)
+        return pkey_scrypt_ctrl_uint64(ctx, EVP_PKEY_CTRL_SCRYPT_MAXMEM_BYTES,
+                                       value);
+
+    KDFerr(KDF_F_PKEY_SCRYPT_CTRL_STR, KDF_R_UNKNOWN_PARAMETER_TYPE);
+    return -2;
+}
+
+static int pkey_scrypt_derive(EVP_PKEY_CTX *ctx, unsigned char *key,
+                              size_t *keylen)
+{
+    SCRYPT_PKEY_CTX *kctx = ctx-&gt;data;
+
+    if (kctx-&gt;pass == NULL) {
+        KDFerr(KDF_F_PKEY_SCRYPT_DERIVE, KDF_R_MISSING_PASS);
+        return 0;
+    }
+
+    if (kctx-&gt;salt == NULL) {
+        KDFerr(KDF_F_PKEY_SCRYPT_DERIVE, KDF_R_MISSING_SALT);
+        return 0;
+    }
+
+    return EVP_PBE_scrypt((char *)kctx-&gt;pass, kctx-&gt;pass_len, kctx-&gt;salt,
+                          kctx-&gt;salt_len, kctx-&gt;N, kctx-&gt;r, kctx-&gt;p,
+                          kctx-&gt;maxmem_bytes, key, *keylen);
+}
+
+const EVP_PKEY_METHOD scrypt_pkey_meth = {
+    EVP_PKEY_SCRYPT,
+    0,
+    pkey_scrypt_init,
+    0,
+    pkey_scrypt_cleanup,
+
+    0, 0,
+    0, 0,
+
+    0,
+    0,
+
+    0,
+    0,
+
+    0, 0,
+
+    0, 0, 0, 0,
+
+    0, 0,
+
+    0, 0,
+
+    0,
+    pkey_scrypt_derive,
+    pkey_scrypt_ctrl,
+    pkey_scrypt_ctrl_str
+};
diff --git a/crypto/objects/obj_dat.h b/crypto/objects/obj_dat.h
index 3de3110..9647e31 100644
--- a/crypto/objects/obj_dat.h
+++ b/crypto/objects/obj_dat.h
@@ -1987,7 +1987,7 @@ static const ASN1_OBJECT nid_objs[NUM_NID] = {
     {&quot;CAMELLIA-256-CCM&quot;, &quot;camellia-256-ccm&quot;, NID_camellia_256_ccm, 8, &amp;so[6330]},
     {&quot;CAMELLIA-256-CTR&quot;, &quot;camellia-256-ctr&quot;, NID_camellia_256_ctr, 8, &amp;so[6338]},
     {&quot;CAMELLIA-256-CMAC&quot;, &quot;camellia-256-cmac&quot;, NID_camellia_256_cmac, 8, &amp;so[6346]},
-    {&quot;id-scrypt&quot;, &quot;id-scrypt&quot;, NID_id_scrypt, 9, &amp;so[6354]},
+    {&quot;id-scrypt&quot;, &quot;scrypt&quot;, NID_id_scrypt, 9, &amp;so[6354]},
     {&quot;id-tc26&quot;, &quot;id-tc26&quot;, NID_id_tc26, 5, &amp;so[6363]},
     {&quot;gost89-cnt-12&quot;, &quot;gost89-cnt-12&quot;, NID_gost89_cnt_12},
     {&quot;gost-mac-12&quot;, &quot;gost-mac-12&quot;, NID_gost_mac_12},
@@ -3883,7 +3883,6 @@ static const unsigned int ln_objs[NUM_LN] = {
      314,    /* &quot;id-regInfo&quot; */
      322,    /* &quot;id-regInfo-certReq&quot; */
      321,    /* &quot;id-regInfo-utf8Pairs&quot; */
-     973,    /* &quot;id-scrypt&quot; */
      191,    /* &quot;id-smime-aa&quot; */
      215,    /* &quot;id-smime-aa-contentHint&quot; */
      218,    /* &quot;id-smime-aa-contentIdentifier&quot; */
@@ -4135,6 +4134,7 @@ static const unsigned int ln_objs[NUM_LN] = {
      291,    /* &quot;sbgp-autonomousSysNum&quot; */
      290,    /* &quot;sbgp-ipAddrBlock&quot; */
      292,    /* &quot;sbgp-routerIdentifier&quot; */
+     973,    /* &quot;scrypt&quot; */
      159,    /* &quot;sdsiCertificate&quot; */
      859,    /* &quot;searchGuide&quot; */
      704,    /* &quot;secp112r1&quot; */
diff --git a/crypto/objects/objects.txt b/crypto/objects/objects.txt
index 8f17cc4..7464d67 100644
--- a/crypto/objects/objects.txt
+++ b/crypto/objects/objects.txt
@@ -1524,7 +1524,8 @@ secg-scheme 14 3 : dhSinglePass-cofactorDH-sha512kdf-scheme
 1 3 6 1 4 1 311 60 2 1 3	: jurisdictionC		: jurisdictionCountryName
 
 # SCRYPT algorithm
-1 3 6 1 4 1 11591 4 11		: id-scrypt
+!Cname id-scrypt
+1 3 6 1 4 1 11591 4 11		: id-scrypt         : scrypt
 
 # NID for TLS1 PRF
                             : TLS1-PRF          : tls1-prf
diff --git a/doc/man7/scrypt.pod b/doc/man7/scrypt.pod
new file mode 100644
index 0000000..4de0c72
--- /dev/null
+++ b/doc/man7/scrypt.pod
@@ -0,0 +1,158 @@
+=pod
+
+=head1 NAME
+
+scrypt - EVP_PKEY scrypt KDF support
+
+=head1 SYNOPSIS
+
+ #include &lt;openssl/kdf.h&gt;
+
+ int EVP_PKEY_CTX_set1_pbe_pass(EVP_PKEY_CTX *pctx, unsigned char *pass,
+                                int passlen);
+
+ int EVP_PKEY_CTX_set1_scrypt_salt(EVP_PKEY_CTX *pctx, unsigned char *salt,
+                                   int saltlen);
+
+ int EVP_PKEY_CTX_set_scrypt_N(EVP_PKEY_CTX *pctx, uint64_t N);
+
+ int EVP_PKEY_CTX_set_scrypt_r(EVP_PKEY_CTX *pctx, uint64_t r);
+
+ int EVP_PKEY_CTX_set_scrypt_p(EVP_PKEY_CTX *pctx, uint64_t p);
+
+ int EVP_PKEY_CTX_set_scrypt_maxmem_bytes(EVP_PKEY_CTX *pctx, uint64_t maxmem);
+
+=head1 DESCRIPTION
+
+The EVP_PKEY_SCRYPT algorithm implements the scrypt password based key
+derivation function, as described in RFC 7914.  It is memory-hard in the sense
+that it deliberately requires a significant amount of RAM for efficient
+computation. The intention of this is to render brute forcing of passwords on
+systems that lack large amounts of main memory (such as GPUs or ASICs)
+computationally infeasible.
+
+scrypt provides three work factors that can be customized: N, r and p. N, which
+has to be a positive power of two, is the general work factor and scales CPU
+time in an approximately linear fashion. r is the block size of the internally
+used hash function and p is the parallelization factor. Both r and p need to be
+greater than zero. The amount of RAM that scrypt requires for its computation
+is roughly (128 * N * r * p) bytes.
+
+In the original paper of Colin Percival (&quot;Stronger Key Derivation via
+Sequential Memory-Hard Functions&quot;, 2009), the suggested values that give a
+computation time of less than 5 seconds on a 2.5 GHz Intel Core 2 Duo are N =
+2^20 = 1048576, r = 8, p = 1. Consequently, the required amount of memory for
+this computation is roughly 1 GiB. On a more recent CPU (Intel i7-5930K at 3.5
+GHz), this computation takes about 3 seconds. When N, r or p are not specified,
+they default to 1048576, 8, and 1, respectively. The default amount of RAM that
+may be used by scrypt defaults to 1025 MiB.
+
+EVP_PKEY_CTX_set1_pbe_pass() sets the B&lt;passlen&gt; bytes long password.
+
+EVP_PKEY_CTX_set1_scrypt_salt() sets the B&lt;saltlen&gt; bytes long salt value.
+
+EVP_PKEY_CTX_set_scrypt_N(), EVP_PKEY_CTX_set_scrypt_r() and
+EVP_PKEY_CTX_set_scrypt_p() configure the work factors N, r and p.
+
+EVP_PKEY_CTX_set_scrypt_maxmem_bytes() sets how much RAM key derivation may
+maximally use, given in bytes. If RAM is exceeded because the load factors are
+chosen too high, the key derivation will fail.
+
+=head1 STRING CTRLS
+
+scrypt also supports string based control operations via
+L&lt;EVP_PKEY_CTX_ctrl_str(3)&gt;.
+The B&lt;password&gt; can be directly specified using the B&lt;type&gt; parameter &quot;pass&quot; or
+given in hex encoding using the &quot;hexpass&quot; parameter. Similarly, the B&lt;salt&gt; can
+either be specified using the B&lt;type&gt; parameter &quot;salt&quot; or in hex encoding by
+using the &quot;hexsalt&quot; parameter. The work factors B&lt;N&gt;, B&lt;r&gt; and B&lt;p&gt; as well as
+B&lt;maxmem_bytes&gt; can be set by using the parameters &quot;N&quot;, &quot;r&quot;, &quot;p&quot; and
+&quot;maxmem_bytes&quot;, respectively.
+
+=head1 NOTES
+
+All these functions are implemented as macros.
+
+A context for scrypt can be obtained by calling:
+
+ EVP_PKEY_CTX *pctx = EVP_PKEY_new_id(EVP_PKEY_SCRYPT, NULL);
+
+The output length of an scrypt key derivation is specified via the length
+parameter to the L&lt;EVP_PKEY_derive(3)&gt; function.
+
+=head1 RETURN VALUES
+
+All these functions return 1 for success and 0 or a negative value for failure.
+In particular a return value of -2 indicates the operation is not supported by
+the public key algorithm.
+
+=head1 EXAMPLE
+
+This example derives a 64-byte long test vector using scrypt using the password
+&quot;password&quot;, salt &quot;NaCl&quot; and N = 1024, r = 8, p = 16.
+
+ EVP_PKEY_CTX *pctx;
+ unsigned char out[64];
+
+ size_t outlen = sizeof(out);
+ pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_SCRYPT, NULL);
+
+ if (EVP_PKEY_derive_init(pctx) &lt;= 0) {
+     error(&quot;EVP_PKEY_derive_init&quot;);
+ }
+ if (EVP_PKEY_CTX_set1_pbe_pass(pctx, &quot;password&quot;, 8) &lt;= 0) {
+     error(&quot;EVP_PKEY_CTX_set1_pbe_pass&quot;);
+ }
+ if (EVP_PKEY_CTX_set1_scrypt_salt(pctx, &quot;NaCl&quot;, 4) &lt;= 0) {
+     error(&quot;EVP_PKEY_CTX_set1_scrypt_salt&quot;);
+ }
+ if (EVP_PKEY_CTX_set_scrypt_N(pctx, 1024) &lt;= 0) {
+     error(&quot;EVP_PKEY_CTX_set_scrypt_N&quot;);
+ }
+ if (EVP_PKEY_CTX_set_scrypt_r(pctx, 8) &lt;= 0) {
+     error(&quot;EVP_PKEY_CTX_set_scrypt_r&quot;);
+ }
+ if (EVP_PKEY_CTX_set_scrypt_p(pctx, 16) &lt;= 0) {
+     error(&quot;EVP_PKEY_CTX_set_scrypt_p&quot;);
+ }
+ if (EVP_PKEY_derive(pctx, out, &amp;outlen) &lt;= 0) {
+     error(&quot;EVP_PKEY_derive&quot;);
+ }
+
+ {
+     const unsigned char expected[sizeof(out)] = {
+         0xfd, 0xba, 0xbe, 0x1c, 0x9d, 0x34, 0x72, 0x00,
+         0x78, 0x56, 0xe7, 0x19, 0x0d, 0x01, 0xe9, 0xfe,
+         0x7c, 0x6a, 0xd7, 0xcb, 0xc8, 0x23, 0x78, 0x30,
+         0xe7, 0x73, 0x76, 0x63, 0x4b, 0x37, 0x31, 0x62,
+         0x2e, 0xaf, 0x30, 0xd9, 0x2e, 0x22, 0xa3, 0x88,
+         0x6f, 0xf1, 0x09, 0x27, 0x9d, 0x98, 0x30, 0xda,
+         0xc7, 0x27, 0xaf, 0xb9, 0x4a, 0x83, 0xee, 0x6d,
+         0x83, 0x60, 0xcb, 0xdf, 0xa2, 0xcc, 0x06, 0x40
+     };
+
+     assert(!memcmp(out, expected, sizeof(out)));
+ }
+
+ EVP_PKEY_CTX_free(pctx);
+
+=head1 CONFORMING TO
+
+RFC 7914
+
+=head1 SEE ALSO
+
+L&lt;EVP_PKEY_CTX_new(3)&gt;,
+L&lt;EVP_PKEY_CTX_ctrl_str(3)&gt;,
+L&lt;EVP_PKEY_derive(3)&gt;
+
+=head1 COPYRIGHT
+
+Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.
+
+Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+this file except in compliance with the License.  You can obtain a copy
+in the file LICENSE in the source distribution or at
+L&lt;<A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>&gt;.
+
+=cut
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index af7043b..dd02077 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -52,6 +52,7 @@
 # define EVP_PKEY_EC     NID_X9_62_id_ecPublicKey
 # define EVP_PKEY_HMAC   NID_hmac
 # define EVP_PKEY_CMAC   NID_cmac
+# define EVP_PKEY_SCRYPT NID_id_scrypt
 # define EVP_PKEY_TLS1_PRF NID_tls1_prf
 # define EVP_PKEY_HKDF   NID_hkdf
 # define EVP_PKEY_POLY1305 NID_poly1305
@@ -1275,6 +1276,8 @@ int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
                       int cmd, int p1, void *p2);
 int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
                           const char *value);
+int EVP_PKEY_CTX_ctrl_uint64(EVP_PKEY_CTX *ctx, int keytype, int optype,
+                                int cmd, uint64_t value);
 
 int EVP_PKEY_CTX_str2ctrl(EVP_PKEY_CTX *ctx, int cmd, const char *str);
 int EVP_PKEY_CTX_hex2ctrl(EVP_PKEY_CTX *ctx, int cmd, const char *hex);
diff --git a/include/openssl/kdf.h b/include/openssl/kdf.h
index bd74515..26380ca 100644
--- a/include/openssl/kdf.h
+++ b/include/openssl/kdf.h
@@ -23,6 +23,12 @@ extern &quot;C&quot; {
 # define EVP_PKEY_CTRL_HKDF_KEY                 (EVP_PKEY_ALG_CTRL + 5)
 # define EVP_PKEY_CTRL_HKDF_INFO                (EVP_PKEY_ALG_CTRL + 6)
 # define EVP_PKEY_CTRL_HKDF_MODE                (EVP_PKEY_ALG_CTRL + 7)
+# define EVP_PKEY_CTRL_PASS                     (EVP_PKEY_ALG_CTRL + 8)
+# define EVP_PKEY_CTRL_SCRYPT_SALT              (EVP_PKEY_ALG_CTRL + 9)
+# define EVP_PKEY_CTRL_SCRYPT_N                 (EVP_PKEY_ALG_CTRL + 10)
+# define EVP_PKEY_CTRL_SCRYPT_R                 (EVP_PKEY_ALG_CTRL + 11)
+# define EVP_PKEY_CTRL_SCRYPT_P                 (EVP_PKEY_ALG_CTRL + 12)
+# define EVP_PKEY_CTRL_SCRYPT_MAXMEM_BYTES      (EVP_PKEY_ALG_CTRL + 13)
 
 # define EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND 0
 # define EVP_PKEY_HKDEF_MODE_EXTRACT_ONLY       1
@@ -59,6 +65,31 @@ extern &quot;C&quot; {
 # define EVP_PKEY_CTX_hkdf_mode(pctx, mode) \
             EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
                               EVP_PKEY_CTRL_HKDF_MODE, mode, NULL)
+
+# define EVP_PKEY_CTX_set1_pbe_pass(pctx, pass, passlen) \
+            EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                            EVP_PKEY_CTRL_PASS, passlen, (void *)(pass))
+
+# define EVP_PKEY_CTX_set1_scrypt_salt(pctx, salt, saltlen) \
+            EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                            EVP_PKEY_CTRL_SCRYPT_SALT, saltlen, (void *)(salt))
+
+# define EVP_PKEY_CTX_set_scrypt_N(pctx, n) \
+            EVP_PKEY_CTX_ctrl_uint64(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                            EVP_PKEY_CTRL_SCRYPT_N, n)
+
+# define EVP_PKEY_CTX_set_scrypt_r(pctx, r) \
+            EVP_PKEY_CTX_ctrl_uint64(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                            EVP_PKEY_CTRL_SCRYPT_R, r)
+
+# define EVP_PKEY_CTX_set_scrypt_p(pctx, p) \
+            EVP_PKEY_CTX_ctrl_uint64(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                            EVP_PKEY_CTRL_SCRYPT_P, p)
+
+# define EVP_PKEY_CTX_set_scrypt_maxmem_bytes(pctx, maxmem_bytes) \
+            EVP_PKEY_CTX_ctrl_uint64(pctx, -1, EVP_PKEY_OP_DERIVE, \
+                            EVP_PKEY_CTRL_SCRYPT_MAXMEM_BYTES, maxmem_bytes)
+
 int ERR_load_KDF_strings(void);
 
 # ifdef  __cplusplus
diff --git a/include/openssl/kdferr.h b/include/openssl/kdferr.h
index c01b735..8f045f0 100644
--- a/include/openssl/kdferr.h
+++ b/include/openssl/kdferr.h
@@ -24,6 +24,9 @@ int ERR_load_KDF_strings(void);
  */
 # define KDF_F_PKEY_HKDF_CTRL_STR                         103
 # define KDF_F_PKEY_HKDF_DERIVE                           102
+# define KDF_F_PKEY_SCRYPT_CTRL_STR                       104
+# define KDF_F_PKEY_SCRYPT_CTRL_UINT64                    105
+# define KDF_F_PKEY_SCRYPT_DERIVE                         109
 # define KDF_F_PKEY_TLS1_PRF_CTRL_STR                     100
 # define KDF_F_PKEY_TLS1_PRF_DERIVE                       101
 
@@ -31,12 +34,16 @@ int ERR_load_KDF_strings(void);
  * KDF reason codes.
  */
 # define KDF_R_INVALID_DIGEST                             100
+# define KDF_R_MISSING_ITERATION_COUNT                    109
 # define KDF_R_MISSING_KEY                                104
 # define KDF_R_MISSING_MESSAGE_DIGEST                     105
 # define KDF_R_MISSING_PARAMETER                          101
+# define KDF_R_MISSING_PASS                               110
+# define KDF_R_MISSING_SALT                               111
 # define KDF_R_MISSING_SECRET                             107
 # define KDF_R_MISSING_SEED                               106
 # define KDF_R_UNKNOWN_PARAMETER_TYPE                     103
+# define KDF_R_VALUE_ERROR                                108
 # define KDF_R_VALUE_MISSING                              102
 
 #endif
diff --git a/include/openssl/obj_mac.h b/include/openssl/obj_mac.h
index cd2c60b..9751117 100644
--- a/include/openssl/obj_mac.h
+++ b/include/openssl/obj_mac.h
@@ -4735,6 +4735,7 @@
 #define OBJ_jurisdictionCountryName             1L,3L,6L,1L,4L,1L,311L,60L,2L,1L,3L
 
 #define SN_id_scrypt            &quot;id-scrypt&quot;
+#define LN_id_scrypt            &quot;scrypt&quot;
 #define NID_id_scrypt           973
 #define OBJ_id_scrypt           1L,3L,6L,1L,4L,1L,11591L,4L,11L
 
diff --git a/test/build.info b/test/build.info
index 2fe336b..e798260 100644
--- a/test/build.info
+++ b/test/build.info
@@ -41,7 +41,8 @@ INCLUDE_MAIN___test_libtestutil_OLB = /INCLUDE=MAIN
           dtlsv1listentest ct_test threadstest afalgtest d2i_test \
           ssl_test_ctx_test ssl_test x509aux cipherlist_test asynciotest \
           bioprinttest sslapitest dtlstest sslcorrupttest bio_enc_test \
-          pkey_meth_test uitest cipherbytes_test asn1_encode_test asn1_string_table_test \
+          pkey_meth_test pkey_meth_kdf_test uitest cipherbytes_test \
+          asn1_encode_test asn1_string_table_test \
           x509_time_test x509_dup_cert_test x509_check_cert_pkey_test \
           recordlentest drbgtest sslbuffertest \
           time_offset_test pemtest ssl_cert_table_internal_test ciphername_test \
@@ -292,6 +293,10 @@ INCLUDE_MAIN___test_libtestutil_OLB = /INCLUDE=MAIN
   INCLUDE[pkey_meth_test]=../include
   DEPEND[pkey_meth_test]=../libcrypto libtestutil.a
 
+  SOURCE[pkey_meth_kdf_test]=pkey_meth_kdf_test.c
+  INCLUDE[pkey_meth_kdf_test]=../include
+  DEPEND[pkey_meth_kdf_test]=../libcrypto libtestutil.a
+
   SOURCE[x509_time_test]=x509_time_test.c
   INCLUDE[x509_time_test]=.. ../include
   DEPEND[x509_time_test]=../libcrypto libtestutil.a
diff --git a/test/pkey_meth_kdf_test.c b/test/pkey_meth_kdf_test.c
new file mode 100644
index 0000000..a2ad91e
--- /dev/null
+++ b/test/pkey_meth_kdf_test.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+/* Tests of the EVP_PKEY_CTX_set_* macro family */
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/kdf.h&gt;
+#include &quot;testutil.h&quot;
+
+static int test_kdf_hkdf(void)
+{
+    EVP_PKEY_CTX *pctx;
+    unsigned char out[10];
+    size_t outlen = sizeof(out);
+    pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, NULL);
+
+    if (EVP_PKEY_derive_init(pctx) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_derive_init&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_set_hkdf_md(pctx, EVP_sha256()) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set_hkdf_md&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_set1_hkdf_salt(pctx, &quot;salt&quot;, 4) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set1_hkdf_salt&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_set1_hkdf_key(pctx, &quot;secret&quot;, 6) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set1_hkdf_key&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_add1_hkdf_info(pctx, &quot;label&quot;, 5) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set1_hkdf_info&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_derive(pctx, out, &amp;outlen) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_derive&quot;);
+        return 0;
+    }
+
+    {
+        const unsigned char expected[sizeof(out)] = {
+            0x2a, 0xc4, 0x36, 0x9f, 0x52, 0x59, 0x96, 0xf8, 0xde, 0x13
+        };
+        if (!TEST_mem_eq(out, sizeof(out), expected, sizeof(expected))) {
+            return 0;
+        }
+    }
+    EVP_PKEY_CTX_free(pctx);
+    return 1;
+}
+
+static int test_kdf_scrypt(void)
+{
+    EVP_PKEY_CTX *pctx;
+    unsigned char out[64];
+    size_t outlen = sizeof(out);
+    pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_SCRYPT, NULL);
+
+    if (EVP_PKEY_derive_init(pctx) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_derive_init&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_set1_pbe_pass(pctx, &quot;password&quot;, 8) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set1_pbe_pass&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_set1_scrypt_salt(pctx, &quot;NaCl&quot;, 4) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set1_scrypt_salt&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_set_scrypt_N(pctx, 1024) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set_scrypt_N&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_set_scrypt_r(pctx, 8) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set_scrypt_r&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_set_scrypt_p(pctx, 16) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set_scrypt_p&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_set_scrypt_maxmem_bytes(pctx, 16) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set_maxmem_bytes&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_derive(pctx, out, &amp;outlen) &gt; 0) {
+        TEST_error(&quot;EVP_PKEY_derive should have failed&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_CTX_set_scrypt_maxmem_bytes(pctx, 10 * 1024 * 1024) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_CTX_set_maxmem_bytes&quot;);
+        return 0;
+    }
+    if (EVP_PKEY_derive(pctx, out, &amp;outlen) &lt;= 0) {
+        TEST_error(&quot;EVP_PKEY_derive&quot;);
+        return 0;
+    }
+
+    {
+        const unsigned char expected[sizeof(out)] = {
+            0xfd, 0xba, 0xbe, 0x1c, 0x9d, 0x34, 0x72, 0x00,
+            0x78, 0x56, 0xe7, 0x19, 0x0d, 0x01, 0xe9, 0xfe,
+            0x7c, 0x6a, 0xd7, 0xcb, 0xc8, 0x23, 0x78, 0x30,
+            0xe7, 0x73, 0x76, 0x63, 0x4b, 0x37, 0x31, 0x62,
+            0x2e, 0xaf, 0x30, 0xd9, 0x2e, 0x22, 0xa3, 0x88,
+            0x6f, 0xf1, 0x09, 0x27, 0x9d, 0x98, 0x30, 0xda,
+            0xc7, 0x27, 0xaf, 0xb9, 0x4a, 0x83, 0xee, 0x6d,
+            0x83, 0x60, 0xcb, 0xdf, 0xa2, 0xcc, 0x06, 0x40
+        };
+        if (!TEST_mem_eq(out, sizeof(out), expected, sizeof(expected))) {
+            return 0;
+        }
+    }
+    EVP_PKEY_CTX_free(pctx);
+    return 1;
+}
+
+int setup_tests()
+{
+    ADD_TEST(test_kdf_hkdf);
+    ADD_TEST(test_kdf_scrypt);
+    return 1;
+}
diff --git a/test/recipes/30-test_evp_data/evpkdf.txt b/test/recipes/30-test_evp_data/evpkdf.txt
index 4df8f8f..9a6cc28 100644
--- a/test/recipes/30-test_evp_data/evpkdf.txt
+++ b/test/recipes/30-test_evp_data/evpkdf.txt
@@ -252,4 +252,54 @@ Ctrl.IKM = hexkey:0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c
 Ctrl.salt = salt:
 Output = 2c91117204d745f3500d636a62f64f0ab3bae548aa53d423b0d1f27ebba6f5e5673a081d70cce7acfc48
 
+Title = id-scrypt tests (from draft-josefsson-id-scrypt-kdf-03 and others)
+
+KDF = scrypt
+Ctrl.pass = pass:
+Ctrl.salt = salt:
+Ctrl.N = N:16
+Ctrl.r = r:1
+Ctrl.p = p:1
+Output = 77d6576238657b203b19ca42c18a0497f16b4844e3074ae8dfdffa3fede21442fcd0069ded0948f8326a753a0fc81f17e8d3e0fb2e0d3628cf35e20c38d18906
+
+KDF = scrypt
+Ctrl.pass = pass:password
+Ctrl.salt = salt:NaCl
+Ctrl.N = N:1024
+Ctrl.r = r:8
+Ctrl.p = p:16
+Output = fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b3731622eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640
+
+KDF = scrypt
+Ctrl.hexpass = hexpass:70617373776f7264
+Ctrl.salt = salt:NaCl
+Ctrl.N = N:1024
+Ctrl.r = r:8
+Ctrl.p = p:16
+Output = fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b3731622eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640
+
+KDF = scrypt
+Ctrl.pass = pass:password
+Ctrl.hexsalt = hexsalt:4e61436c
+Ctrl.N = N:1024
+Ctrl.r = r:8
+Ctrl.p = p:16
+Output = fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e77376634b3731622eaf30d92e22a3886ff109279d9830dac727afb94a83ee6d8360cbdfa2cc0640
+
+KDF = scrypt
+Ctrl.pass = pass:pleaseletmein
+Ctrl.salt = salt:SodiumChloride
+Ctrl.N = N:16384
+Ctrl.r = r:8
+Ctrl.p = p:1
+Output = 7023bdcb3afd7348461c06cd81fd38ebfda8fbba904f8e3ea9b543f6545da1f2d5432955613f0fcf62d49705242a9af9e61e85dc0d651e40dfcf017b45575887
+
+# Out of memory
+KDF = scrypt
+Ctrl.pass = pass:pleaseletmein
+Ctrl.salt = salt:SodiumChloride
+Ctrl.N = N:1048576
+Ctrl.r = r:8
+Ctrl.p = p:1
+Result = INTERNAL_ERROR
 
diff --git a/test/recipes/60-test_x509_time.t b/test/recipes/30-test_pkey_meth_kdf.t
similarity index 86%
copy from test/recipes/60-test_x509_time.t
copy to test/recipes/30-test_pkey_meth_kdf.t
index 8b311ad..9289df2 100644
--- a/test/recipes/60-test_x509_time.t
+++ b/test/recipes/30-test_pkey_meth_kdf.t
@@ -9,4 +9,4 @@
 
 use OpenSSL::Test::Simple;
 
-simple_test(&quot;test_x509_time&quot;, &quot;x509_time_test&quot;);
+simple_test(&quot;test_pkey_meth_kdf&quot;, &quot;pkey_meth_kdf_test&quot;);
diff --git a/util/libcrypto.num b/util/libcrypto.num
index fbfcb5c..42284ec 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4379,3 +4379,4 @@ BN_priv_rand_range                      4322	1_1_1	EXIST::FUNCTION:
 ASN1_TIME_normalize                     4323	1_1_1	EXIST::FUNCTION:
 ASN1_TIME_cmp_time_t                    4324	1_1_1	EXIST::FUNCTION:
 ASN1_TIME_compare                       4325	1_1_1	EXIST::FUNCTION:
+EVP_PKEY_CTX_ctrl_uint64                4326	1_1_1	EXIST::FUNCTION:
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015833.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="015845.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15841">[ date ]</a>
              <a href="thread.html#15841">[ thread ]</a>
              <a href="subject.html#15841">[ subject ]</a>
              <a href="author.html#15841">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
