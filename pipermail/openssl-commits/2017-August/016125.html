<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2017-August/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1503674937.286302.23264.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016123.html">
   <LINK REL="Next"  HREF="016128.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1503674937.286302.23264.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Fri Aug 25 15:28:57 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="016123.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="016128.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16125">[ date ]</a>
              <a href="thread.html#16125">[ thread ]</a>
              <a href="subject.html#16125">[ subject ]</a>
              <a href="author.html#16125">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  90862ab4b2fb80ebbc89849bc28393da393022fb (commit)
       via  8686c474807d3c7bcb722294f39ac4e5627e9fa2 (commit)
      from  b5fe5dfbdaf8ee25e45c9a94736a1478a355e136 (commit)


- Log -----------------------------------------------------------------
commit 90862ab4b2fb80ebbc89849bc28393da393022fb
Author: Paul Yang &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">yang.yang at baishancloud.com</A>&gt;
Date:   Wed Aug 23 01:36:49 2017 +0800

    This part fixes braces around if-else.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/4223">https://github.com/openssl/openssl/pull/4223</A>)

commit 8686c474807d3c7bcb722294f39ac4e5627e9fa2
Author: Paul Yang &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">yang.yang at baishancloud.com</A>&gt;
Date:   Wed Aug 23 01:25:23 2017 +0800

    Fix coding style in crypto/rsa directory
    
    this part contains only the return (x) fix.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/4223">https://github.com/openssl/openssl/pull/4223</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/rsa/rsa_ameth.c | 21 +++++++++++++--------
 crypto/rsa/rsa_crpt.c  | 24 +++++++++++++-----------
 crypto/rsa/rsa_lib.c   | 11 ++++++-----
 crypto/rsa/rsa_none.c  | 12 ++++++------
 crypto/rsa/rsa_ossl.c  | 21 +++++++++++----------
 crypto/rsa/rsa_pk1.c   | 26 +++++++++++++-------------
 crypto/rsa/rsa_pmeth.c | 42 +++++++++++++++++++++++++-----------------
 crypto/rsa/rsa_prn.c   |  6 +++---
 crypto/rsa/rsa_pss.c   | 15 ++++++++-------
 crypto/rsa/rsa_saos.c  | 15 ++++++++-------
 crypto/rsa/rsa_ssl.c   | 22 +++++++++++-----------
 crypto/rsa/rsa_x931.c  | 13 +++++++------
 crypto/rsa/rsa_x931g.c |  5 +++--
 13 files changed, 127 insertions(+), 106 deletions(-)

diff --git a/crypto/rsa/rsa_ameth.c b/crypto/rsa/rsa_ameth.c
index 0527d1a..42138ce 100644
--- a/crypto/rsa/rsa_ameth.c
+++ b/crypto/rsa/rsa_ameth.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2006-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -250,8 +250,9 @@ static int rsa_pss_param_print(BIO *bp, int pss_key, RSA_PSS_PARAMS *pss,
     if (pss-&gt;hashAlgorithm) {
         if (i2a_ASN1_OBJECT(bp, pss-&gt;hashAlgorithm-&gt;algorithm) &lt;= 0)
             goto err;
-    } else if (BIO_puts(bp, &quot;sha1 (default)&quot;) &lt;= 0)
+    } else if (BIO_puts(bp, &quot;sha1 (default)&quot;) &lt;= 0) {
         goto err;
+    }
 
     if (BIO_puts(bp, &quot;\n&quot;) &lt;= 0)
         goto err;
@@ -270,10 +271,12 @@ static int rsa_pss_param_print(BIO *bp, int pss_key, RSA_PSS_PARAMS *pss,
         if (maskHash != NULL) {
             if (i2a_ASN1_OBJECT(bp, maskHash-&gt;algorithm) &lt;= 0)
                 goto err;
-        } else if (BIO_puts(bp, &quot;INVALID&quot;) &lt;= 0)
+        } else if (BIO_puts(bp, &quot;INVALID&quot;) &lt;= 0) {
             goto err;
-    } else if (BIO_puts(bp, &quot;mgf1 with sha1 (default)&quot;) &lt;= 0)
+        }
+    } else if (BIO_puts(bp, &quot;mgf1 with sha1 (default)&quot;) &lt;= 0) {
         goto err;
+    }
     BIO_puts(bp, &quot;\n&quot;);
 
     if (!BIO_indent(bp, indent, 128))
@@ -283,8 +286,9 @@ static int rsa_pss_param_print(BIO *bp, int pss_key, RSA_PSS_PARAMS *pss,
     if (pss-&gt;saltLength) {
         if (i2a_ASN1_INTEGER(bp, pss-&gt;saltLength) &lt;= 0)
             goto err;
-    } else if (BIO_puts(bp, &quot;14 (default)&quot;) &lt;= 0)
+    } else if (BIO_puts(bp, &quot;14 (default)&quot;) &lt;= 0) {
         goto err;
+    }
     BIO_puts(bp, &quot;\n&quot;);
 
     if (!BIO_indent(bp, indent, 128))
@@ -294,8 +298,9 @@ static int rsa_pss_param_print(BIO *bp, int pss_key, RSA_PSS_PARAMS *pss,
     if (pss-&gt;trailerField) {
         if (i2a_ASN1_INTEGER(bp, pss-&gt;trailerField) &lt;= 0)
             goto err;
-    } else if (BIO_puts(bp, &quot;BC (default)&quot;) &lt;= 0)
+    } else if (BIO_puts(bp, &quot;BC (default)&quot;) &lt;= 0) {
         goto err;
+    }
     BIO_puts(bp, &quot;\n&quot;);
 
     rv = 1;
@@ -536,9 +541,9 @@ static RSA_PSS_PARAMS *rsa_ctx_to_pss(EVP_PKEY_CTX *pkctx)
         return NULL;
     if (!EVP_PKEY_CTX_get_rsa_pss_saltlen(pkctx, &amp;saltlen))
         return NULL;
-    if (saltlen == -1)
+    if (saltlen == -1) {
         saltlen = EVP_MD_size(sigmd);
-    else if (saltlen == -2) {
+    } else if (saltlen == -2) {
         saltlen = EVP_PKEY_size(pk) - EVP_MD_size(sigmd) - 2;
         if ((EVP_PKEY_bits(pk) &amp; 0x7) == 1)
             saltlen--;
diff --git a/crypto/rsa/rsa_crpt.c b/crypto/rsa/rsa_crpt.c
index 2b676fd..cc62153 100644
--- a/crypto/rsa/rsa_crpt.c
+++ b/crypto/rsa/rsa_crpt.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -17,41 +17,41 @@
 
 int RSA_bits(const RSA *r)
 {
-    return (BN_num_bits(r-&gt;n));
+    return BN_num_bits(r-&gt;n);
 }
 
 int RSA_size(const RSA *r)
 {
-    return (BN_num_bytes(r-&gt;n));
+    return BN_num_bytes(r-&gt;n);
 }
 
 int RSA_public_encrypt(int flen, const unsigned char *from, unsigned char *to,
                        RSA *rsa, int padding)
 {
-    return (rsa-&gt;meth-&gt;rsa_pub_enc(flen, from, to, rsa, padding));
+    return rsa-&gt;meth-&gt;rsa_pub_enc(flen, from, to, rsa, padding);
 }
 
 int RSA_private_encrypt(int flen, const unsigned char *from,
                         unsigned char *to, RSA *rsa, int padding)
 {
-    return (rsa-&gt;meth-&gt;rsa_priv_enc(flen, from, to, rsa, padding));
+    return rsa-&gt;meth-&gt;rsa_priv_enc(flen, from, to, rsa, padding);
 }
 
 int RSA_private_decrypt(int flen, const unsigned char *from,
                         unsigned char *to, RSA *rsa, int padding)
 {
-    return (rsa-&gt;meth-&gt;rsa_priv_dec(flen, from, to, rsa, padding));
+    return rsa-&gt;meth-&gt;rsa_priv_dec(flen, from, to, rsa, padding);
 }
 
 int RSA_public_decrypt(int flen, const unsigned char *from, unsigned char *to,
                        RSA *rsa, int padding)
 {
-    return (rsa-&gt;meth-&gt;rsa_pub_dec(flen, from, to, rsa, padding));
+    return rsa-&gt;meth-&gt;rsa_pub_dec(flen, from, to, rsa, padding);
 }
 
 int RSA_flags(const RSA *r)
 {
-    return ((r == NULL) ? 0 : r-&gt;meth-&gt;flags);
+    return r == NULL ? 0 : r-&gt;meth-&gt;flags;
 }
 
 void RSA_blinding_off(RSA *rsa)
@@ -77,7 +77,7 @@ int RSA_blinding_on(RSA *rsa, BN_CTX *ctx)
     rsa-&gt;flags &amp;= ~RSA_FLAG_NO_BLINDING;
     ret = 1;
  err:
-    return (ret);
+    return ret;
 }
 
 static BIGNUM *rsa_get_public_exp(const BIGNUM *d, const BIGNUM *p,
@@ -117,8 +117,9 @@ BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *in_ctx)
     if (in_ctx == NULL) {
         if ((ctx = BN_CTX_new()) == NULL)
             return 0;
-    } else
+    } else {
         ctx = in_ctx;
+    }
 
     BN_CTX_start(ctx);
     e = BN_CTX_get(ctx);
@@ -133,8 +134,9 @@ BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *in_ctx)
             RSAerr(RSA_F_RSA_SETUP_BLINDING, RSA_R_NO_PUBLIC_EXPONENT);
             goto err;
         }
-    } else
+    } else {
         e = rsa-&gt;e;
+    }
 
     {
         BIGNUM *n = BN_new();
diff --git a/crypto/rsa/rsa_lib.c b/crypto/rsa/rsa_lib.c
index 3c2354b..7a1d81c 100644
--- a/crypto/rsa/rsa_lib.c
+++ b/crypto/rsa/rsa_lib.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -73,8 +73,9 @@ RSA *RSA_new_method(ENGINE *engine)
             goto err;
         }
         ret-&gt;engine = engine;
-    } else
+    } else {
         ret-&gt;engine = ENGINE_get_default_RSA();
+    }
     if (ret-&gt;engine) {
         ret-&gt;meth = ENGINE_get_RSA(ret-&gt;engine);
         if (ret-&gt;meth == NULL) {
@@ -148,17 +149,17 @@ int RSA_up_ref(RSA *r)
 
     REF_PRINT_COUNT(&quot;RSA&quot;, r);
     REF_ASSERT_ISNT(i &lt; 2);
-    return ((i &gt; 1) ? 1 : 0);
+    return i &gt; 1 ? 1 : 0;
 }
 
 int RSA_set_ex_data(RSA *r, int idx, void *arg)
 {
-    return (CRYPTO_set_ex_data(&amp;r-&gt;ex_data, idx, arg));
+    return CRYPTO_set_ex_data(&amp;r-&gt;ex_data, idx, arg);
 }
 
 void *RSA_get_ex_data(const RSA *r, int idx)
 {
-    return (CRYPTO_get_ex_data(&amp;r-&gt;ex_data, idx));
+    return CRYPTO_get_ex_data(&amp;r-&gt;ex_data, idx);
 }
 
 int RSA_security_bits(const RSA *rsa)
diff --git a/crypto/rsa/rsa_none.c b/crypto/rsa/rsa_none.c
index b78756d..f16cc67 100644
--- a/crypto/rsa/rsa_none.c
+++ b/crypto/rsa/rsa_none.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -16,16 +16,16 @@ int RSA_padding_add_none(unsigned char *to, int tlen,
 {
     if (flen &gt; tlen) {
         RSAerr(RSA_F_RSA_PADDING_ADD_NONE, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
-        return (0);
+        return 0;
     }
 
     if (flen &lt; tlen) {
         RSAerr(RSA_F_RSA_PADDING_ADD_NONE, RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE);
-        return (0);
+        return 0;
     }
 
     memcpy(to, from, (unsigned int)flen);
-    return (1);
+    return 1;
 }
 
 int RSA_padding_check_none(unsigned char *to, int tlen,
@@ -34,10 +34,10 @@ int RSA_padding_check_none(unsigned char *to, int tlen,
 
     if (flen &gt; tlen) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_NONE, RSA_R_DATA_TOO_LARGE);
-        return (-1);
+        return -1;
     }
 
     memset(to, 0, tlen - flen);
     memcpy(to + tlen - flen, from, flen);
-    return (tlen);
+    return tlen;
 }
diff --git a/crypto/rsa/rsa_ossl.c b/crypto/rsa/rsa_ossl.c
index c4feb9d..40c84dd 100644
--- a/crypto/rsa/rsa_ossl.c
+++ b/crypto/rsa/rsa_ossl.c
@@ -155,7 +155,7 @@ static int rsa_ossl_public_encrypt(int flen, const unsigned char *from,
         BN_CTX_end(ctx);
     BN_CTX_free(ctx);
     OPENSSL_clear_free(buf, num);
-    return (r);
+    return r;
 }
 
 static BN_BLINDING *rsa_get_blinding(RSA *rsa, int *local, BN_CTX *ctx)
@@ -200,12 +200,12 @@ static BN_BLINDING *rsa_get_blinding(RSA *rsa, int *local, BN_CTX *ctx)
 static int rsa_blinding_convert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,
                                 BN_CTX *ctx)
 {
-    if (unblind == NULL)
+    if (unblind == NULL) {
         /*
          * Local blinding: store the unblinding factor in BN_BLINDING.
          */
         return BN_BLINDING_convert_ex(f, NULL, b, ctx);
-    else {
+    } else {
         /*
          * Shared blinding: store the unblinding factor outside BN_BLINDING.
          */
@@ -347,8 +347,9 @@ static int rsa_ossl_private_encrypt(int flen, const unsigned char *from,
             res = f;
         else
             res = ret;
-    } else
+    } else {
         res = ret;
+    }
 
     /*
      * put in leading 0 bytes if the number is less than the length of the
@@ -365,7 +366,7 @@ static int rsa_ossl_private_encrypt(int flen, const unsigned char *from,
         BN_CTX_end(ctx);
     BN_CTX_free(ctx);
     OPENSSL_clear_free(buf, num);
-    return (r);
+    return r;
 }
 
 static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,
@@ -496,7 +497,7 @@ static int rsa_ossl_private_decrypt(int flen, const unsigned char *from,
         BN_CTX_end(ctx);
     BN_CTX_free(ctx);
     OPENSSL_clear_free(buf, num);
-    return (r);
+    return r;
 }
 
 /* signature verification */
@@ -595,7 +596,7 @@ static int rsa_ossl_public_decrypt(int flen, const unsigned char *from,
         BN_CTX_end(ctx);
     BN_CTX_free(ctx);
     OPENSSL_clear_free(buf, num);
-    return (r);
+    return r;
 }
 
 static int rsa_ossl_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
@@ -787,13 +788,13 @@ static int rsa_ossl_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
     ret = 1;
  err:
     BN_CTX_end(ctx);
-    return (ret);
+    return ret;
 }
 
 static int rsa_ossl_init(RSA *rsa)
 {
     rsa-&gt;flags |= RSA_FLAG_CACHE_PUBLIC | RSA_FLAG_CACHE_PRIVATE;
-    return (1);
+    return 1;
 }
 
 static int rsa_ossl_finish(RSA *rsa)
@@ -801,5 +802,5 @@ static int rsa_ossl_finish(RSA *rsa)
     BN_MONT_CTX_free(rsa-&gt;_method_mod_n);
     BN_MONT_CTX_free(rsa-&gt;_method_mod_p);
     BN_MONT_CTX_free(rsa-&gt;_method_mod_q);
-    return (1);
+    return 1;
 }
diff --git a/crypto/rsa/rsa_pk1.c b/crypto/rsa/rsa_pk1.c
index aeeb32c..7d453ff 100644
--- a/crypto/rsa/rsa_pk1.c
+++ b/crypto/rsa/rsa_pk1.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -24,7 +24,7 @@ int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,
     if (flen &gt; (tlen - RSA_PKCS1_PADDING_SIZE)) {
         RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1,
                RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
-        return (0);
+        return 0;
     }
 
     p = (unsigned char *)to;
@@ -38,7 +38,7 @@ int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,
     p += j;
     *(p++) = '\0';
     memcpy(p, from, (unsigned int)flen);
-    return (1);
+    return 1;
 }
 
 int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
@@ -73,7 +73,7 @@ int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
     if ((num != (flen + 1)) || (*(p++) != 0x01)) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,
                RSA_R_BLOCK_TYPE_IS_NOT_01);
-        return (-1);
+        return -1;
     }
 
     /* scan over padding data */
@@ -86,7 +86,7 @@ int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
             } else {
                 RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,
                        RSA_R_BAD_FIXED_HEADER_DECRYPT);
-                return (-1);
+                return -1;
             }
         }
         p++;
@@ -95,23 +95,23 @@ int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
     if (i == j) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,
                RSA_R_NULL_BEFORE_BLOCK_MISSING);
-        return (-1);
+        return -1;
     }
 
     if (i &lt; 8) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,
                RSA_R_BAD_PAD_BYTE_COUNT);
-        return (-1);
+        return -1;
     }
     i++;                        /* Skip over the '\0' */
     j -= i;
     if (j &gt; tlen) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1, RSA_R_DATA_TOO_LARGE);
-        return (-1);
+        return -1;
     }
     memcpy(to, p, (unsigned int)j);
 
-    return (j);
+    return j;
 }
 
 int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,
@@ -123,7 +123,7 @@ int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,
     if (flen &gt; (tlen - 11)) {
         RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2,
                RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
-        return (0);
+        return 0;
     }
 
     p = (unsigned char *)to;
@@ -135,12 +135,12 @@ int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,
     j = tlen - 3 - flen;
 
     if (RAND_bytes(p, j) &lt;= 0)
-        return (0);
+        return 0;
     for (i = 0; i &lt; j; i++) {
         if (*p == '\0')
             do {
                 if (RAND_bytes(p, 1) &lt;= 0)
-                    return (0);
+                    return 0;
             } while (*p == '\0');
         p++;
     }
@@ -148,7 +148,7 @@ int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,
     *(p++) = '\0';
 
     memcpy(p, from, (unsigned int)flen);
-    return (1);
+    return 1;
 }
 
 int RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,
diff --git a/crypto/rsa/rsa_pmeth.c b/crypto/rsa/rsa_pmeth.c
index bd7b47f..886ce27 100644
--- a/crypto/rsa/rsa_pmeth.c
+++ b/crypto/rsa/rsa_pmeth.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2006-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -170,11 +170,13 @@ static int pkey_rsa_sign(EVP_PKEY_CTX *ctx, unsigned char *sig,
                 return -1;
             ret = RSA_private_encrypt(RSA_size(rsa), rctx-&gt;tbuf,
                                       sig, rsa, RSA_NO_PADDING);
-        } else
+        } else {
             return -1;
-    } else
+        }
+    } else {
         ret = RSA_private_encrypt(tbslen, tbs, sig, ctx-&gt;pkey-&gt;pkey.rsa,
                                   rctx-&gt;pad_mode);
+    }
     if (ret &lt; 0)
         return ret;
     *siglen = ret;
@@ -218,11 +220,13 @@ static int pkey_rsa_verifyrecover(EVP_PKEY_CTX *ctx,
             if (ret &lt;= 0)
                 return 0;
             ret = sltmp;
-        } else
+        } else {
             return -1;
-    } else
+        }
+    } else {
         ret = RSA_public_decrypt(siglen, sig, rout, ctx-&gt;pkey-&gt;pkey.rsa,
                                  rctx-&gt;pad_mode);
+    }
     if (ret &lt; 0)
         return ret;
     *routlen = ret;
@@ -262,8 +266,9 @@ static int pkey_rsa_verify(EVP_PKEY_CTX *ctx,
             if (ret &lt;= 0)
                 return 0;
             return 1;
-        } else
+        } else {
             return -1;
+        }
     } else {
         if (!setup_tbuf(rctx, ctx))
             return -1;
@@ -299,9 +304,10 @@ static int pkey_rsa_encrypt(EVP_PKEY_CTX *ctx,
             return -1;
         ret = RSA_public_encrypt(klen, rctx-&gt;tbuf, out,
                                  ctx-&gt;pkey-&gt;pkey.rsa, RSA_NO_PADDING);
-    } else
+    } else {
         ret = RSA_public_encrypt(inlen, in, out, ctx-&gt;pkey-&gt;pkey.rsa,
                                  rctx-&gt;pad_mode);
+    }
     if (ret &lt; 0)
         return ret;
     *outlen = ret;
@@ -327,9 +333,10 @@ static int pkey_rsa_decrypt(EVP_PKEY_CTX *ctx,
                                                 rctx-&gt;oaep_label,
                                                 rctx-&gt;oaep_labellen,
                                                 rctx-&gt;md, rctx-&gt;mgf1md);
-    } else
+    } else {
         ret = RSA_private_decrypt(inlen, in, out, ctx-&gt;pkey-&gt;pkey.rsa,
                                   rctx-&gt;pad_mode);
+    }
     if (ret &lt; 0)
         return ret;
     *outlen = ret;
@@ -572,21 +579,21 @@ static int pkey_rsa_ctrl_str(EVP_PKEY_CTX *ctx,
     }
     if (strcmp(type, &quot;rsa_padding_mode&quot;) == 0) {
         int pm;
-        if (strcmp(value, &quot;pkcs1&quot;) == 0)
+        if (strcmp(value, &quot;pkcs1&quot;) == 0) {
             pm = RSA_PKCS1_PADDING;
-        else if (strcmp(value, &quot;sslv23&quot;) == 0)
+        } else if (strcmp(value, &quot;sslv23&quot;) == 0) {
             pm = RSA_SSLV23_PADDING;
-        else if (strcmp(value, &quot;none&quot;) == 0)
+        } else if (strcmp(value, &quot;none&quot;) == 0) {
             pm = RSA_NO_PADDING;
-        else if (strcmp(value, &quot;oeap&quot;) == 0)
+        } else if (strcmp(value, &quot;oeap&quot;) == 0) {
             pm = RSA_PKCS1_OAEP_PADDING;
-        else if (strcmp(value, &quot;oaep&quot;) == 0)
+        } else if (strcmp(value, &quot;oaep&quot;) == 0) {
             pm = RSA_PKCS1_OAEP_PADDING;
-        else if (strcmp(value, &quot;x931&quot;) == 0)
+        } else if (strcmp(value, &quot;x931&quot;) == 0) {
             pm = RSA_X931_PADDING;
-        else if (strcmp(value, &quot;pss&quot;) == 0)
+        } else if (strcmp(value, &quot;pss&quot;) == 0) {
             pm = RSA_PKCS1_PSS_PADDING;
-        else {
+        } else {
             RSAerr(RSA_F_PKEY_RSA_CTRL_STR, RSA_R_UNKNOWN_PADDING_TYPE);
             return -2;
         }
@@ -704,8 +711,9 @@ static int pkey_rsa_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
             return 0;
         }
         evp_pkey_set_cb_translate(pcb, ctx);
-    } else
+    } else {
         pcb = NULL;
+    }
     ret = RSA_generate_key_ex(rsa, rctx-&gt;nbits, rctx-&gt;pub_exp, pcb);
     BN_GENCB_free(pcb);
     if (ret &gt; 0 &amp;&amp; !rsa_set_pss_param(rsa, ctx)) {
diff --git a/crypto/rsa/rsa_prn.c b/crypto/rsa/rsa_prn.c
index 5e6c599..b5f4bce 100644
--- a/crypto/rsa/rsa_prn.c
+++ b/crypto/rsa/rsa_prn.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2006-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -20,12 +20,12 @@ int RSA_print_fp(FILE *fp, const RSA *x, int off)
 
     if ((b = BIO_new(BIO_s_file())) == NULL) {
         RSAerr(RSA_F_RSA_PRINT_FP, ERR_R_BUF_LIB);
-        return (0);
+        return 0;
     }
     BIO_set_fp(b, fp, BIO_NOCLOSE);
     ret = RSA_print(b, x, off);
     BIO_free(b);
-    return (ret);
+    return ret;
 }
 #endif
 
diff --git a/crypto/rsa/rsa_pss.c b/crypto/rsa/rsa_pss.c
index ab9b8e8..03c1ab2 100644
--- a/crypto/rsa/rsa_pss.c
+++ b/crypto/rsa/rsa_pss.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2005-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -57,9 +57,9 @@ int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
      *      -3      salt length is maximized
      *      -N      reserved
      */
-    if (sLen == RSA_PSS_SALTLEN_DIGEST)
+    if (sLen == RSA_PSS_SALTLEN_DIGEST) {
         sLen = hLen;
-    else if (sLen &lt; RSA_PSS_SALTLEN_MAX) {
+    } else if (sLen &lt; RSA_PSS_SALTLEN_MAX) {
         RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_SLEN_CHECK_FAILED);
         goto err;
     }
@@ -123,8 +123,9 @@ int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
     if (memcmp(H_, H, hLen)) {
         RSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_BAD_SIGNATURE);
         ret = 0;
-    } else
+    } else {
         ret = 1;
+    }
 
  err:
     OPENSSL_free(DB);
@@ -165,11 +166,11 @@ int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,
      *      -3      same as above (on signing)
      *      -N      reserved
      */
-    if (sLen == RSA_PSS_SALTLEN_DIGEST)
+    if (sLen == RSA_PSS_SALTLEN_DIGEST) {
         sLen = hLen;
-    else if (sLen == RSA_PSS_SALTLEN_MAX_SIGN)
+    } else if (sLen == RSA_PSS_SALTLEN_MAX_SIGN) {
         sLen = RSA_PSS_SALTLEN_MAX;
-    else if (sLen &lt; RSA_PSS_SALTLEN_MAX) {
+    } else if (sLen &lt; RSA_PSS_SALTLEN_MAX) {
         RSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1, RSA_R_SLEN_CHECK_FAILED);
         goto err;
     }
diff --git a/crypto/rsa/rsa_saos.c b/crypto/rsa/rsa_saos.c
index 9e5fff4..8336f32 100644
--- a/crypto/rsa/rsa_saos.c
+++ b/crypto/rsa/rsa_saos.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -32,12 +32,12 @@ int RSA_sign_ASN1_OCTET_STRING(int type,
     if (i &gt; (j - RSA_PKCS1_PADDING_SIZE)) {
         RSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING,
                RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);
-        return (0);
+        return 0;
     }
     s = OPENSSL_malloc((unsigned int)j + 1);
     if (s == NULL) {
         RSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING, ERR_R_MALLOC_FAILURE);
-        return (0);
+        return 0;
     }
     p = s;
     i2d_ASN1_OCTET_STRING(&amp;sig, &amp;p);
@@ -48,7 +48,7 @@ int RSA_sign_ASN1_OCTET_STRING(int type,
         *siglen = i;
 
     OPENSSL_clear_free(s, (unsigned int)j + 1);
-    return (ret);
+    return ret;
 }
 
 int RSA_verify_ASN1_OCTET_STRING(int dtype,
@@ -64,7 +64,7 @@ int RSA_verify_ASN1_OCTET_STRING(int dtype,
     if (siglen != (unsigned int)RSA_size(rsa)) {
         RSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,
                RSA_R_WRONG_SIGNATURE_LENGTH);
-        return (0);
+        return 0;
     }
 
     s = OPENSSL_malloc((unsigned int)siglen);
@@ -85,10 +85,11 @@ int RSA_verify_ASN1_OCTET_STRING(int dtype,
     if (((unsigned int)sig-&gt;length != m_len) ||
         (memcmp(m, sig-&gt;data, m_len) != 0)) {
         RSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING, RSA_R_BAD_SIGNATURE);
-    } else
+    } else {
         ret = 1;
+    }
  err:
     ASN1_OCTET_STRING_free(sig);
     OPENSSL_clear_free(s, (unsigned int)siglen);
-    return (ret);
+    return ret;
 }
diff --git a/crypto/rsa/rsa_ssl.c b/crypto/rsa/rsa_ssl.c
index 9ef6b80..cd98584 100644
--- a/crypto/rsa/rsa_ssl.c
+++ b/crypto/rsa/rsa_ssl.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -22,7 +22,7 @@ int RSA_padding_add_SSLv23(unsigned char *to, int tlen,
     if (flen &gt; (tlen - 11)) {
         RSAerr(RSA_F_RSA_PADDING_ADD_SSLV23,
                RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);
-        return (0);
+        return 0;
     }
 
     p = (unsigned char *)to;
@@ -34,12 +34,12 @@ int RSA_padding_add_SSLv23(unsigned char *to, int tlen,
     j = tlen - 3 - 8 - flen;
 
     if (RAND_bytes(p, j) &lt;= 0)
-        return (0);
+        return 0;
     for (i = 0; i &lt; j; i++) {
         if (*p == '\0')
             do {
                 if (RAND_bytes(p, 1) &lt;= 0)
-                    return (0);
+                    return 0;
             } while (*p == '\0');
         p++;
     }
@@ -49,7 +49,7 @@ int RSA_padding_add_SSLv23(unsigned char *to, int tlen,
     *(p++) = '\0';
 
     memcpy(p, from, (unsigned int)flen);
-    return (1);
+    return 1;
 }
 
 int RSA_padding_check_SSLv23(unsigned char *to, int tlen,
@@ -61,11 +61,11 @@ int RSA_padding_check_SSLv23(unsigned char *to, int tlen,
     p = from;
     if (flen &lt; 10) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_DATA_TOO_SMALL);
-        return (-1);
+        return -1;
     }
     if ((num != (flen + 1)) || (*(p++) != 02)) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_BLOCK_TYPE_IS_NOT_02);
-        return (-1);
+        return -1;
     }
 
     /* scan over padding data */
@@ -77,7 +77,7 @@ int RSA_padding_check_SSLv23(unsigned char *to, int tlen,
     if ((i == j) || (i &lt; 8)) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,
                RSA_R_NULL_BEFORE_BLOCK_MISSING);
-        return (-1);
+        return -1;
     }
     for (k = -9; k &lt; -1; k++) {
         if (p[k] != 0x03)
@@ -85,16 +85,16 @@ int RSA_padding_check_SSLv23(unsigned char *to, int tlen,
     }
     if (k == -1) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_SSLV3_ROLLBACK_ATTACK);
-        return (-1);
+        return -1;
     }
 
     i++;                        /* Skip over the '\0' */
     j -= i;
     if (j &gt; tlen) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_DATA_TOO_LARGE);
-        return (-1);
+        return -1;
     }
     memcpy(to, p, (unsigned int)j);
 
-    return (j);
+    return j;
 }
diff --git a/crypto/rsa/rsa_x931.c b/crypto/rsa/rsa_x931.c
index b9301f3..7b0486c 100644
--- a/crypto/rsa/rsa_x931.c
+++ b/crypto/rsa/rsa_x931.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 2005-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -34,9 +34,9 @@ int RSA_padding_add_X931(unsigned char *to, int tlen,
     p = (unsigned char *)to;
 
     /* If no padding start and end nibbles are in one byte */
-    if (j == 0)
+    if (j == 0) {
         *p++ = 0x6A;
-    else {
+    } else {
         *p++ = 0x6B;
         if (j &gt; 1) {
             memset(p, 0xBB, j - 1);
@@ -47,7 +47,7 @@ int RSA_padding_add_X931(unsigned char *to, int tlen,
     memcpy(p, from, (unsigned int)flen);
     p += flen;
     *p = 0xCC;
-    return (1);
+    return 1;
 }
 
 int RSA_padding_check_X931(unsigned char *to, int tlen,
@@ -81,8 +81,9 @@ int RSA_padding_check_X931(unsigned char *to, int tlen,
             return -1;
         }
 
-    } else
+    } else {
         j = flen - 2;
+    }
 
     if (p[j] != 0xCC) {
         RSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_TRAILER);
@@ -91,7 +92,7 @@ int RSA_padding_check_X931(unsigned char *to, int tlen,
 
     memcpy(to, p, (unsigned int)j);
 
-    return (j);
+    return j;
 }
 
 /* Translate between X931 hash ids and NIDs */
diff --git a/crypto/rsa/rsa_x931g.c b/crypto/rsa/rsa_x931g.c
index 877ee22..3563670 100644
--- a/crypto/rsa/rsa_x931g.c
+++ b/crypto/rsa/rsa_x931g.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 1995-2016 The OpenSSL Project Authors. All Rights Reserved.
+ * Copyright 1995-2017 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
  * this file except in compliance with the License.  You can obtain a copy
@@ -44,8 +44,9 @@ int RSA_X931_derive_ex(RSA *rsa, BIGNUM *p1, BIGNUM *p2, BIGNUM *q1,
         rsa-&gt;e = BN_dup(e);
         if (!rsa-&gt;e)
             goto err;
-    } else
+    } else {
         e = rsa-&gt;e;
+    }
 
     /*
      * If not all parameters present only calculate what we can. This allows
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016123.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="016128.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16125">[ date ]</a>
              <a href="thread.html#16125">[ thread ]</a>
              <a href="subject.html#16125">[ subject ]</a>
              <a href="author.html#16125">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
