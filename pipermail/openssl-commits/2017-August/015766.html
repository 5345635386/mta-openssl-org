<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2017-August/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1501809843.470726.8985.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015763.html">
   <LINK REL="Next"  HREF="015787.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>paul.dale at oracle.com</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1501809843.470726.8985.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">paul.dale at oracle.com
       </A><BR>
    <I>Fri Aug  4 01:24:03 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="015763.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="015787.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15766">[ date ]</a>
              <a href="thread.html#15766">[ thread ]</a>
              <a href="subject.html#15766">[ subject ]</a>
              <a href="author.html#15766">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  cf37aaa335965902c6a022bc3c3e0162f59c0f3a (commit)
      from  2326bba0e5cbe98f4d00855a6909b1f14b6f5427 (commit)


- Log -----------------------------------------------------------------
commit cf37aaa335965902c6a022bc3c3e0162f59c0f3a
Author: Todd Short &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tshort at akamai.com</A>&gt;
Date:   Fri Aug 4 11:24:03 2017 +1000

    Consolidate to a single asn1_time_from_tm() function
    
    Add missing ASN1_TIME functions
    
    Do some cleanup of the ASN1_TIME code.
    Add ASN1_TIME_normalize() to normalize ASN1_TIME structures.
    Add ASN1_TIME_compare() to compare two ASN1_TIME structures.
    Add ASN1_TIME_cmp_time_t() to compare an ASN1_TIME to time_t
    (generic version of ASN1_UTCTIME_cmp_time_t()).
    
    Replace '0' .. '9' compares with isdigit()
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">paul.dale at oracle.com</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/2753">https://github.com/openssl/openssl/pull/2753</A>)

-----------------------------------------------------------------------

Summary of changes:
 crypto/asn1/a_gentm.c                              |  57 +---
 crypto/asn1/a_object.c                             |   3 +-
 crypto/asn1/a_time.c                               | 187 ++++++++-----
 crypto/asn1/a_utctm.c                              |  68 ++---
 crypto/asn1/asn1_locl.h                            |   2 +
 doc/man3/ASN1_TIME_set.pod                         | 154 ++++++++---
 include/openssl/asn1.h                             |   4 +
 test/asn1_time_test.c                              | 296 +++++++++++++++++++++
 test/build.info                                    |   5 +
 test/recipes/{05-test_bf.t =&gt; 90-test_asn1_time.t} |   4 +-
 test/time_offset_test.c                            |   5 +-
 util/libcrypto.num                                 |   3 +
 12 files changed, 587 insertions(+), 201 deletions(-)
 create mode 100644 test/asn1_time_test.c
 copy test/recipes/{05-test_bf.t =&gt; 90-test_asn1_time.t} (73%)

diff --git a/crypto/asn1/a_gentm.c b/crypto/asn1/a_gentm.c
index 8547e22..4e2e815 100644
--- a/crypto/asn1/a_gentm.c
+++ b/crypto/asn1/a_gentm.c
@@ -13,10 +13,12 @@
 
 #include &lt;stdio.h&gt;
 #include &lt;time.h&gt;
+#include &lt;ctype.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/asn1.h&gt;
 #include &quot;asn1_locl.h&quot;
 
+/* This is the primary function used to parse ASN1_GENERALIZEDTIME */
 int asn1_generalizedtime_to_tm(struct tm *tm, const ASN1_GENERALIZEDTIME *d)
 {
     /* wrapper around asn1_time_to_tm */
@@ -39,15 +41,13 @@ int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, const char *str)
     t.data = (unsigned char *)str;
     t.flags = 0;
 
-    if (ASN1_GENERALIZEDTIME_check(&amp;t)) {
-        if (s != NULL) {
-            if (!ASN1_STRING_set((ASN1_STRING *)s, str, t.length))
-                return 0;
-            s-&gt;type = V_ASN1_GENERALIZEDTIME;
-        }
-        return 1;
-    }
-    return 0;
+    if (!ASN1_GENERALIZEDTIME_check(&amp;t))
+        return 0;
+
+    if (s != NULL &amp;&amp; !ASN1_STRING_copy(s, &amp;t))
+        return 0;
+
+    return 1;
 }
 
 ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s,
@@ -60,52 +60,19 @@ ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s,
                                                time_t t, int offset_day,
                                                long offset_sec)
 {
-    char *p;
     struct tm *ts;
     struct tm data;
-    const size_t len = 20;
-    ASN1_GENERALIZEDTIME *tmps = NULL;
-
-    if (s == NULL)
-        tmps = ASN1_GENERALIZEDTIME_new();
-    else
-        tmps = s;
-    if (tmps == NULL)
-        return NULL;
 
     ts = OPENSSL_gmtime(&amp;t, &amp;data);
     if (ts == NULL)
-        goto err;
+        return NULL;
 
     if (offset_day || offset_sec) {
         if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))
-            goto err;
-    }
-
-    p = (char *)tmps-&gt;data;
-    if ((p == NULL) || ((size_t)tmps-&gt;length &lt; len)) {
-        p = OPENSSL_malloc(len);
-        if (p == NULL) {
-            ASN1err(ASN1_F_ASN1_GENERALIZEDTIME_ADJ, ERR_R_MALLOC_FAILURE);
-            goto err;
-        }
-        OPENSSL_free(tmps-&gt;data);
-        tmps-&gt;data = (unsigned char *)p;
+            return NULL;
     }
 
-    tmps-&gt;length = BIO_snprintf(p, len, &quot;%04d%02d%02d%02d%02d%02dZ&quot;,
-                                ts-&gt;tm_year + 1900, ts-&gt;tm_mon + 1,
-                                ts-&gt;tm_mday, ts-&gt;tm_hour, ts-&gt;tm_min,
-                                ts-&gt;tm_sec);
-    tmps-&gt;type = V_ASN1_GENERALIZEDTIME;
-#ifdef CHARSET_EBCDIC_not
-    ebcdic2ascii(tmps-&gt;data, tmps-&gt;data, tmps-&gt;length);
-#endif
-    return tmps;
- err:
-    if (s == NULL)
-        ASN1_GENERALIZEDTIME_free(tmps);
-    return NULL;
+    return asn1_time_from_tm(s, ts, V_ASN1_GENERALIZEDTIME);
 }
 
 int ASN1_GENERALIZEDTIME_print(BIO *bp, const ASN1_GENERALIZEDTIME *tm)
diff --git a/crypto/asn1/a_object.c b/crypto/asn1/a_object.c
index 79f0ecd..5ae56a2 100644
--- a/crypto/asn1/a_object.c
+++ b/crypto/asn1/a_object.c
@@ -9,6 +9,7 @@
 
 #include &lt;stdio.h&gt;
 #include &lt;limits.h&gt;
+#include &lt;ctype.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/buffer.h&gt;
 #include &lt;openssl/asn1.h&gt;
@@ -84,7 +85,7 @@ int a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num)
             c = *(p++);
             if ((c == ' ') || (c == '.'))
                 break;
-            if ((c &lt; '0') || (c &gt; '9')) {
+            if (!isdigit(c)) {
                 ASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_INVALID_DIGIT);
                 goto err;
             }
diff --git a/crypto/asn1/a_time.c b/crypto/asn1/a_time.c
index b85f917..507292b 100644
--- a/crypto/asn1/a_time.c
+++ b/crypto/asn1/a_time.c
@@ -16,6 +16,7 @@
 
 #include &lt;stdio.h&gt;
 #include &lt;time.h&gt;
+#include &lt;ctype.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/asn1t.h&gt;
 #include &quot;asn1_locl.h&quot;
@@ -24,6 +25,13 @@ IMPLEMENT_ASN1_MSTRING(ASN1_TIME, B_ASN1_TIME)
 
 IMPLEMENT_ASN1_FUNCTIONS(ASN1_TIME)
 
+static int is_utc(const int year)
+{
+    if (50 &lt;= year &amp;&amp; year &lt;= 149)
+        return 1;
+    return 0;
+}
+
 static int leap_year(const int year)
 {
     if (year % 400 == 0 || (year % 100 != 0 &amp;&amp; year % 4 == 0))
@@ -116,14 +124,14 @@ int asn1_time_to_tm(struct tm *tm, const ASN1_TIME *d)
             i++;
             break;
         }
-        if ((a[o] &lt; '0') || (a[o] &gt; '9'))
+        if (!isdigit(a[o]))
             goto err;
         n = a[o] - '0';
         /* incomplete 2-digital number */
         if (++o == l)
             goto err;
 
-        if ((a[o] &lt; '0') || (a[o] &gt; '9'))
+        if (!isdigit(a[o]))
             goto err;
         n = (n * 10) + a[o] - '0';
         /* no more bytes to read, but we haven't seen time-zone yet */
@@ -184,7 +192,7 @@ int asn1_time_to_tm(struct tm *tm, const ASN1_TIME *d)
         if (++o == l)
             goto err;
         i = o;
-        while ((o &lt; l) &amp;&amp; (a[o] &gt;= '0') &amp;&amp; (a[o] &lt;= '9'))
+        while ((o &lt; l) &amp;&amp; isdigit(a[o]))
             o++;
         /* Must have at least one digit after decimal point */
         if (i == o)
@@ -215,11 +223,11 @@ int asn1_time_to_tm(struct tm *tm, const ASN1_TIME *d)
         if (o + 4 != l)
             goto err;
         for (i = end; i &lt; end + 2; i++) {
-            if ((a[o] &lt; '0') || (a[o] &gt; '9'))
+            if (!isdigit(a[o]))
                 goto err;
             n = a[o] - '0';
             o++;
-            if ((a[o] &lt; '0') || (a[o] &gt; '9'))
+            if (!isdigit(a[o]))
                 goto err;
             n = (n * 10) + a[o] - '0';
             i2 = (d-&gt;type == V_ASN1_UTCTIME) ? i + 1 : i;
@@ -250,6 +258,58 @@ int asn1_time_to_tm(struct tm *tm, const ASN1_TIME *d)
     return 0;
 }
 
+ASN1_TIME *asn1_time_from_tm(ASN1_TIME *s, struct tm *ts, int type)
+{
+    char* p;
+    ASN1_TIME *tmps = NULL;
+    const size_t len = 20;
+
+    if (type == V_ASN1_UNDEF) {
+        if (is_utc(ts-&gt;tm_year))
+            type = V_ASN1_UTCTIME;
+        else
+            type = V_ASN1_GENERALIZEDTIME;
+    } else if (type == V_ASN1_UTCTIME) {
+        if (!is_utc(ts-&gt;tm_year))
+            goto err;
+    } else if (type != V_ASN1_GENERALIZEDTIME) {
+        goto err;
+    }
+
+    if (s == NULL)
+        tmps = ASN1_STRING_new();
+    else
+        tmps = s;
+    if (tmps == NULL)
+        return NULL;
+
+    if (!ASN1_STRING_set(tmps, NULL, len))
+        goto err;
+
+    tmps-&gt;type = type;
+    p = (char*)tmps-&gt;data;
+
+    if (type == V_ASN1_GENERALIZEDTIME)
+        tmps-&gt;length = BIO_snprintf(p, len, &quot;%04d%02d%02d%02d%02d%02dZ&quot;,
+                                    ts-&gt;tm_year + 1900, ts-&gt;tm_mon + 1,
+                                    ts-&gt;tm_mday, ts-&gt;tm_hour, ts-&gt;tm_min,
+                                    ts-&gt;tm_sec);
+    else
+        tmps-&gt;length = BIO_snprintf(p, len, &quot;%02d%02d%02d%02d%02d%02dZ&quot;,
+                                    ts-&gt;tm_year % 100, ts-&gt;tm_mon + 1,
+                                    ts-&gt;tm_mday, ts-&gt;tm_hour, ts-&gt;tm_min,
+                                    ts-&gt;tm_sec);
+
+#ifdef CHARSET_EBCDIC_not
+    ebcdic2ascii(tmps-&gt;data, tmps-&gt;data, tmps-&gt;length);
+#endif
+    return tmps;
+ err:
+    if (tmps != s)
+        ASN1_STRING_free(tmps);
+    return NULL;
+}
+
 ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t t)
 {
     return ASN1_TIME_adj(s, t, 0, 0);
@@ -270,9 +330,7 @@ ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t,
         if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))
             return NULL;
     }
-    if ((ts-&gt;tm_year &gt;= 50) &amp;&amp; (ts-&gt;tm_year &lt; 150))
-        return ASN1_UTCTIME_adj(s, t, offset_day, offset_sec);
-    return ASN1_GENERALIZEDTIME_adj(s, t, offset_day, offset_sec);
+    return asn1_time_from_tm(s, ts, V_ASN1_UNDEF);
 }
 
 int ASN1_TIME_check(const ASN1_TIME *t)
@@ -289,71 +347,28 @@ ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(const ASN1_TIME *t,
                                                    ASN1_GENERALIZEDTIME **out)
 {
     ASN1_GENERALIZEDTIME *ret = NULL;
-    char *str;
+    struct tm tm;
 
-    if (!ASN1_TIME_check(t))
+    if (!ASN1_TIME_to_tm(t, &amp;tm))
         return NULL;
 
-    if (out == NULL || *out == NULL) {
-        if ((ret = ASN1_GENERALIZEDTIME_new()) == NULL)
-            goto err;
-    } else {
+    if (out != NULL)
         ret = *out;
-    }
 
-    /* If already GeneralizedTime just copy across */
-    if (t-&gt;type == V_ASN1_GENERALIZEDTIME) {
-        if (!ASN1_STRING_set(ret, t-&gt;data, t-&gt;length))
-            goto err;
-        goto done;
-    }
+    ret = asn1_time_from_tm(ret, &amp;tm, V_ASN1_GENERALIZEDTIME);
 
-    /*
-     * Grow the string by two bytes.
-     * The actual allocation is t-&gt;length + 3 to include a terminator byte.
-     */
-    if (!ASN1_STRING_set(ret, NULL, t-&gt;length + 2))
-        goto err;
-    str = (char *)ret-&gt;data;
-    /* Work out the century and prepend */
-    memcpy(str, t-&gt;data[0] &gt;= '5' ? &quot;19&quot; : &quot;20&quot;, 2);
-    /*
-     * t-&gt;length + 1 is the size of the data and the allocated buffer has
-     * this much space after the first two characters.
-     */
-    OPENSSL_strlcpy(str + 2, (const char *)t-&gt;data, t-&gt;length + 1);
+    if (out != NULL &amp;&amp; ret != NULL)
+        *out = ret;
 
- done:
-   if (out != NULL &amp;&amp; *out == NULL)
-       *out = ret;
-   return ret;
-
- err:
-    if (out == NULL || *out != ret)
-        ASN1_GENERALIZEDTIME_free(ret);
-    return NULL;
+    return ret;
 }
 
 int ASN1_TIME_set_string(ASN1_TIME *s, const char *str)
 {
-    ASN1_TIME t;
-
-    t.length = strlen(str);
-    t.data = (unsigned char *)str;
-    t.flags = 0;
-
-    t.type = V_ASN1_UTCTIME;
-
-    if (!ASN1_TIME_check(&amp;t)) {
-        t.type = V_ASN1_GENERALIZEDTIME;
-        if (!ASN1_TIME_check(&amp;t))
-            return 0;
-    }
-
-    if (s != NULL &amp;&amp; !ASN1_STRING_copy((ASN1_STRING *)s, (ASN1_STRING *)&amp;t))
-        return 0;
-
-    return 1;
+    /* Try UTC, if that fails, try GENERALIZED */
+    if (ASN1_UTCTIME_set_string(s, str))
+        return 1;
+    return ASN1_GENERALIZEDTIME_set_string(s, str);
 }
 
 int ASN1_TIME_set_string_X509(ASN1_TIME *s, const char *str)
@@ -391,7 +406,7 @@ int ASN1_TIME_set_string_X509(ASN1_TIME *s, const char *str)
     if (s != NULL &amp;&amp; t.type == V_ASN1_GENERALIZEDTIME) {
         if (!asn1_time_to_tm(&amp;tm, &amp;t))
             goto out;
-        if (tm.tm_year &gt;= 50 &amp;&amp; tm.tm_year &lt; 150) {
+        if (is_utc(tm.tm_year)) {
             t.length -= 2;
             /*
              * it's OK to let original t.data go since that's assigned
@@ -474,7 +489,7 @@ int ASN1_TIME_print(BIO *bp, const ASN1_TIME *tm)
         if (tm-&gt;length &gt; 15 &amp;&amp; v[14] == '.') {
             f = &amp;v[14];
             f_len = 1;
-            while (14 + f_len &lt; l &amp;&amp; f[f_len] &gt;= '0' &amp;&amp; f[f_len] &lt;= '9')
+            while (14 + f_len &lt; l &amp;&amp; isdigit(f[f_len]))
                 ++f_len;
         }
 
@@ -492,3 +507,47 @@ int ASN1_TIME_print(BIO *bp, const ASN1_TIME *tm)
     BIO_write(bp, &quot;Bad time value&quot;, 14);
     return 0;
 }
+
+int ASN1_TIME_cmp_time_t(const ASN1_TIME *s, time_t t)
+{
+    struct tm stm, ttm;
+    int day, sec;
+
+    if (!ASN1_TIME_to_tm(s, &amp;stm))
+        return -2;
+
+    if (!OPENSSL_gmtime(&amp;t, &amp;ttm))
+        return -2;
+
+    if (!OPENSSL_gmtime_diff(&amp;day, &amp;sec, &amp;ttm, &amp;stm))
+        return -2;
+
+    if (day &gt; 0 || sec &gt; 0)
+        return 1;
+    if (day &lt; 0 || sec &lt; 0)
+        return -1;
+    return 0;
+}
+
+int ASN1_TIME_normalize(ASN1_TIME *t)
+{
+    struct tm tm;
+
+    if (!ASN1_TIME_to_tm(t, &amp;tm))
+        return 0;
+
+    return asn1_time_from_tm(t, &amp;tm, V_ASN1_UNDEF) != NULL;
+}
+
+int ASN1_TIME_compare(const ASN1_TIME *a, const ASN1_TIME *b)
+{
+    int day, sec;
+
+    if (!ASN1_TIME_diff(&amp;day, &amp;sec, a, b))
+        return -2;
+    if (day &gt; 0 || sec &gt; 0)
+        return 1;
+    if (day &lt; 0 || sec &lt; 0)
+        return -1;
+    return 0;
+}
diff --git a/crypto/asn1/a_utctm.c b/crypto/asn1/a_utctm.c
index 1f24508..b88aa42 100644
--- a/crypto/asn1/a_utctm.c
+++ b/crypto/asn1/a_utctm.c
@@ -9,10 +9,12 @@
 
 #include &lt;stdio.h&gt;
 #include &lt;time.h&gt;
+#include &lt;ctype.h&gt;
 #include &quot;internal/cryptlib.h&quot;
 #include &lt;openssl/asn1.h&gt;
 #include &quot;asn1_locl.h&quot;
 
+/* This is the primary function used to parse ASN1_UTCTIME */
 int asn1_utctime_to_tm(struct tm *tm, const ASN1_UTCTIME *d)
 {
     /* wrapper around ans1_time_to_tm */
@@ -26,6 +28,7 @@ int ASN1_UTCTIME_check(const ASN1_UTCTIME *d)
     return asn1_utctime_to_tm(NULL, d);
 }
 
+/* Sets the string via simple copy without cleaning it up */
 int ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str)
 {
     ASN1_UTCTIME t;
@@ -35,15 +38,13 @@ int ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str)
     t.data = (unsigned char *)str;
     t.flags = 0;
 
-    if (ASN1_UTCTIME_check(&amp;t)) {
-        if (s != NULL) {
-            if (!ASN1_STRING_set((ASN1_STRING *)s, str, t.length))
-                return 0;
-            s-&gt;type = V_ASN1_UTCTIME;
-        }
-        return 1;
-    }
-    return 0;
+    if (!ASN1_UTCTIME_check(&amp;t))
+        return 0;
+
+    if (s != NULL &amp;&amp; !ASN1_STRING_copy(s, &amp;t))
+        return 0;
+
+    return 1;
 }
 
 ASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t)
@@ -54,54 +55,19 @@ ASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t)
 ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,
                                int offset_day, long offset_sec)
 {
-    char *p;
     struct tm *ts;
     struct tm data;
-    const size_t len = 20;
-    int free_s = 0;
-
-    if (s == NULL) {
-        s = ASN1_UTCTIME_new();
-        if (s == NULL)
-            goto err;
-        free_s = 1;
-    }
 
     ts = OPENSSL_gmtime(&amp;t, &amp;data);
     if (ts == NULL)
-        goto err;
+        return NULL;
 
     if (offset_day || offset_sec) {
         if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))
-            goto err;
-    }
-
-    if ((ts-&gt;tm_year &lt; 50) || (ts-&gt;tm_year &gt;= 150))
-        goto err;
-
-    p = (char *)s-&gt;data;
-    if ((p == NULL) || ((size_t)s-&gt;length &lt; len)) {
-        p = OPENSSL_malloc(len);
-        if (p == NULL) {
-            ASN1err(ASN1_F_ASN1_UTCTIME_ADJ, ERR_R_MALLOC_FAILURE);
-            goto err;
-        }
-        OPENSSL_free(s-&gt;data);
-        s-&gt;data = (unsigned char *)p;
+            return NULL;
     }
 
-    s-&gt;length = BIO_snprintf(p, len, &quot;%02d%02d%02d%02d%02d%02dZ&quot;,
-                             ts-&gt;tm_year % 100, ts-&gt;tm_mon + 1, ts-&gt;tm_mday,
-                             ts-&gt;tm_hour, ts-&gt;tm_min, ts-&gt;tm_sec);
-    s-&gt;type = V_ASN1_UTCTIME;
-#ifdef CHARSET_EBCDIC_not
-    ebcdic2ascii(s-&gt;data, s-&gt;data, s-&gt;length);
-#endif
-    return s;
- err:
-    if (free_s)
-        ASN1_UTCTIME_free(s);
-    return NULL;
+    return asn1_time_from_tm(s, ts, V_ASN1_UTCTIME);
 }
 
 int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t)
@@ -118,13 +84,9 @@ int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t)
     if (!OPENSSL_gmtime_diff(&amp;day, &amp;sec, &amp;ttm, &amp;stm))
         return -2;
 
-    if (day &gt; 0)
-        return 1;
-    if (day &lt; 0)
-        return -1;
-    if (sec &gt; 0)
+    if (day &gt; 0 || sec &gt; 0)
         return 1;
-    if (sec &lt; 0)
+    if (day &lt; 0 || sec &lt; 0)
         return -1;
     return 0;
 }
diff --git a/crypto/asn1/asn1_locl.h b/crypto/asn1/asn1_locl.h
index cee97ab..35cbd8d 100644
--- a/crypto/asn1/asn1_locl.h
+++ b/crypto/asn1/asn1_locl.h
@@ -78,3 +78,5 @@ ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,
 /* Internal functions used by x_int64.c */
 int c2i_uint64_int(uint64_t *ret, int *neg, const unsigned char **pp, long len);
 int i2c_uint64_int(unsigned char *p, uint64_t r, int neg);
+
+ASN1_TIME *asn1_time_from_tm(ASN1_TIME *s, struct tm *ts, int type);
diff --git a/doc/man3/ASN1_TIME_set.pod b/doc/man3/ASN1_TIME_set.pod
index 2296296..1bb5672 100644
--- a/doc/man3/ASN1_TIME_set.pod
+++ b/doc/man3/ASN1_TIME_set.pod
@@ -2,41 +2,82 @@
 
 =head1 NAME
 
-ASN1_TIME_set, ASN1_TIME_adj, ASN1_TIME_check,
-ASN1_TIME_set_string, ASN1_TIME_set_string_X509,
-ASN1_TIME_print, ASN1_TIME_to_tm, ASN1_TIME_diff - ASN.1 Time functions
+ASN1_TIME_set, ASN1_UTCTIME_set, ASN1_GENERALIZEDTIME_set,
+ASN1_TIME_adj, ASN1_UTCTIME_adj, ASN1_GENERALIZEDTIME_adj,
+ASN1_TIME_check, ASN1_UTCTIME_check, ASN1_GENERALIZEDTIME_check,
+ASN1_TIME_set_string, ASN1_UTCTIME_set_string, ASN1_GENERALIZEDTIME_set_string,
+ASN1_TIME_set_string_X509,
+ASN1_TIME_normalize,
+ASN1_TIME_to_tm,
+ASN1_TIME_print, ASN1_UTCTIME_print, ASN1_GENERALIZEDTIME_print,
+ASN1_TIME_diff,
+ASN1_TIME_cmp_time_t, ASN1_UTCTIME_cmp_time_t,
+ASN1_TIME_compare,
+ASN1_TIME_to_generalizedtime - ASN.1 Time functions
 
 =head1 SYNOPSIS
 
  ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t t);
- ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t,
-                          int offset_day, long offset_sec);
+ ASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t);
+ ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s,
+                                                time_t t);
+
+ ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t, int offset_day,
+                          long offset_sec);
+ ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,
+                                int offset_day, long offset_sec);
+ ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s,
+                                                time_t t, int offset_day,
+                                                long offset_sec);
+
  int ASN1_TIME_set_string(ASN1_TIME *s, const char *str);
  int ASN1_TIME_set_string_X509(ASN1_TIME *s, const char *str);
+ int ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str);
+ int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s,
+                                     const char *str);
+
+ int ASN1_TIME_normalize(ASN1_TIME *s);
+
  int ASN1_TIME_check(const ASN1_TIME *t);
+ int ASN1_UTCTIME_check(const ASN1_UTCTIME *t);
+ int ASN1_GENERALIZEDTIME_check(const ASN1_GENERALIZEDTIME *t);
+
  int ASN1_TIME_print(BIO *b, const ASN1_TIME *s);
+ int ASN1_UTCTIME_print(BIO *b, const ASN1_UTCTIME *s);
+ int ASN1_GENERALIZEDTIME_print(BIO *b, const ASN1_GENERALIZEDTIME *s);
+
  int ASN1_TIME_to_tm(const ASN1_TIME *s, struct tm *tm);
+ int ASN1_TIME_diff(int *pday, int *psec, const ASN1_TIME *from,
+                    const ASN1_TIME *to);
 
- int ASN1_TIME_diff(int *pday, int *psec,
-                    const ASN1_TIME *from, const ASN1_TIME *to);
+ int ASN1_TIME_cmp_time_t(const ASN1_TIME *s, time_t t);
+ int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t);
+
+ int ASN1_TIME_compare(const ASN1_TIME *a, const ASN1_TIME *b);
+
+ ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t,
+                                                    ASN1_GENERALIZEDTIME **out);
 
 =head1 DESCRIPTION
 
-The function ASN1_TIME_set() sets the ASN1_TIME structure B&lt;s&gt; to the
-time represented by the time_t value B&lt;t&gt;. If B&lt;s&gt; is NULL a new ASN1_TIME
-structure is allocated and returned.
+The ASN1_TIME_set(), ASN1_UTCTIME_set() and ASN1_GENERALIZEDTIME_set()
+functions set the structure B&lt;s&gt; to the time represented by the time_t
+value B&lt;t&gt;. If B&lt;s&gt; is NULL a new time structure is allocated and returned.
 
-ASN1_TIME_adj() sets the ASN1_TIME structure B&lt;s&gt; to the time represented
+The ASN1_TIME_adj(), ASN1_UTCTIME_adj() and ASN1_GENERALIZEDTIME_adj()
+functions set the time structure B&lt;s&gt; to the time represented
 by the time B&lt;offset_day&gt; and B&lt;offset_sec&gt; after the time_t value B&lt;t&gt;.
 The values of B&lt;offset_day&gt; or B&lt;offset_sec&gt; can be negative to set a
 time before B&lt;t&gt;. The B&lt;offset_sec&gt; value can also exceed the number of
-seconds in a day. If B&lt;s&gt; is NULL a new ASN1_TIME structure is allocated
+seconds in a day. If B&lt;s&gt; is NULL a new structure is allocated
 and returned.
 
-ASN1_TIME_set_string() sets ASN1_TIME structure B&lt;s&gt; to the time
-represented by string B&lt;str&gt; which must be in appropriate ASN.1 time
-format (for example YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ). If B&lt;s&gt; is NULL
-this function performs a format check on B&lt;str&gt; only.
+The ASN1_TIME_set_string(), ASN1_UTCTIME_set_string() and
+ASN1_GENERALIZEDTIME_set_string() functions set the time structure B&lt;s&gt;
+to the time represented by string B&lt;str&gt; which must be in appropriate ASN.1
+time format (for example YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ). If B&lt;s&gt; is NULL
+this function performs a format check on B&lt;str&gt; only. The string B&lt;str&gt;
+is copied into B&lt;s&gt;.
 
 ASN1_TIME_set_string_X509() sets ASN1_TIME structure B&lt;s&gt; to the time
 represented by string B&lt;str&gt; which must be in appropriate time format
@@ -45,13 +86,21 @@ YYYYMMDDHHMMSSZ (leap second is rejected), all other ASN.1 time format
 are not allowed. If B&lt;s&gt; is NULL this function performs a format check
 on B&lt;str&gt; only.
 
-ASN1_TIME_check() checks the syntax of ASN1_TIME structure B&lt;s&gt;.
+The ASN1_TIME_normalize() function converts an ASN1_GENERALIZEDTIME or
+ASN1_UTCTIME into a time value that can be used in a certificate. It
+should be used after the ASN1_TIME_set_string() functions and before
+ASN1_TIME_print() functions to get consistent (i.e. GMT) results.
+
+The ASN1_TIME_check(), ASN1_UTCTIME_check() and ASN1_GENERALIZEDTIME_check()
+functions check the syntax of the time structure B&lt;s&gt;.
 
-ASN1_TIME_print() prints out the time B&lt;s&gt; to BIO B&lt;b&gt; in human readable
+The ASN1_TIME_print(), ASN1_UTCTIME_print() and ASN1_GENERALIZEDTIME_print()
+functions print the time structure B&lt;s&gt; to BIO B&lt;b&gt; in human readable
 format. It will be of the format MMM DD HH:MM:SS YYYY [GMT], for example
 &quot;Feb  3 00:55:52 2015 GMT&quot; it does not include a newline. If the time
 structure has invalid format it prints out &quot;Bad time value&quot; and returns
-an error.
+an error. The output for generalized time may include a fractional part
+following the second.
 
 ASN1_TIME_to_tm() converts the time B&lt;s&gt; to the standard B&lt;tm&gt; structure.
 If B&lt;s&gt; is NULL, then the current time is converted. The output time is GMT.
@@ -72,6 +121,16 @@ If both B&lt;*pday&gt; and B&lt;*psec&gt; are non-zero they will always have the same
 sign. The value of B&lt;*psec&gt; will always be less than the number of seconds
 in a day. If B&lt;from&gt; or B&lt;to&gt; is NULL the current time is used.
 
+The ASN1_TIME_cmp_time_t() and ASN1_UTCTIME_cmp_time_t() functions compare
+the two times represented by the time structure B&lt;s&gt; and the time_t B&lt;t&gt;.
+
+The ASN1_TIME_compare() function compares the two times represented by the
+time structures B&lt;a&gt; and B&lt;b&gt;.
+
+The ASN1_TIME_to_generalizedtime() function converts an ASN1_TIME to an
+ASN1_GENERALIZEDTIME, regardless of year. If either B&lt;out&gt; or
+B&lt;*out&gt; are NULL, then a new object is allocated and must be freed after use.
+
 =head1 NOTES
 
 The ASN1_TIME structure corresponds to the ASN.1 structure B&lt;Time&gt;
@@ -79,13 +138,15 @@ defined in RFC5280 et al. The time setting functions obey the rules outlined
 in RFC5280: if the date can be represented by UTCTime it is used, else
 GeneralizedTime is used.
 
-The ASN1_TIME structure is represented as an ASN1_STRING internally and can
-be freed up using ASN1_STRING_free().
+The ASN1_TIME, ASN1_UTCTIME and ASN1_GENERALIZEDTIME structures are represented
+as an ASN1_STRING internally and can be freed up using ASN1_STRING_free().
 
 The ASN1_TIME structure can represent years from 0000 to 9999 but no attempt
 is made to correct ancient calendar changes (for example from Julian to
 Gregorian calendars).
 
+ASN1_UTCTIME is limited to a year range of 1950 through 2049.
+
 Some applications add offset times directly to a time_t value and pass the
 results to ASN1_TIME_set() (or equivalent). This can cause problems as the
 time_t value can overflow on some systems resulting in unexpected results.
@@ -93,11 +154,24 @@ New applications should use ASN1_TIME_adj() instead and pass the offset value
 in the B&lt;offset_sec&gt; and B&lt;offset_day&gt; parameters instead of directly
 manipulating a time_t value.
 
+ASN1_TIME_adj() may change the type from ASN1_GENERALIZEDTIME to ASN1_UTCTIME,
+or vise-versa, based on the resulting year. The ASN1_GENERALIZEDTIME_adj() and
+ASN1_UTCTIME_adj() functions will not modify the type of the return structure.
+
+It is recommended that functions starting with ASN1_TIME be used instead of
+those starting with ASN1_UTCTIME or ASN1_GENERALIZEDTIME. The functions
+starting with ASN1_UTCTIME and ASN1_GENERALIZEDTIME act only on that specific
+time format. The functions starting with ASN1_TIME will operate on either
+format.
+
 =head1 BUGS
 
-ASN1_TIME_print() currently does not print out the time zone: it either prints
-out &quot;GMT&quot; or nothing. But all certificates complying with RFC5280 et al use GMT
-anyway.
+ASN1_TIME_print(), ASN1_UTCTIME_print() and ASN1_GENERALIZEDTIME_print()
+do not print out the time zone: it either prints out &quot;GMT&quot; or nothing. But all
+certificates complying with RFC5280 et al use GMT anyway.
+
+Use the ASN1_TIME_normalize() function to normalize the time value before
+printing to get GMT results.
 
 =head1 EXAMPLES
 
@@ -133,28 +207,44 @@ Determine if one time is later or sooner than the current time:
 
 =head1 RETURN VALUES
 
-ASN1_TIME_set() and ASN1_TIME_adj() return a pointer to an ASN1_TIME structure
+ASN1_TIME_set(), ASN1_UTCTIME_set(), ASN1_GENERALIZEDTIME_set(), ASN1_TIME_adj(),
+ASN1_UTCTIME_adj and ASN1_GENERALIZEDTIME_set return a pointer to a time structure
 or NULL if an error occurred.
 
-ASN1_TIME_set_string() and ASN1_TIME_set_string_X509() return 1 if the time
-value is successfully set and 0 otherwise.
+ASN1_TIME_set_string(), ASN1_UTCTIME_set_string(), ASN1_GENERALIZEDTIME_set_string()
+ASN1_TIME_set_string_X509() return 1 if the time value is successfully set and 0 otherwise.
 
-ASN1_TIME_check() returns 1 if the structure is syntactically correct and 0
-otherwise.
+ASN1_TIME_normalize() returns 1 on success, and 0 on error.
 
-ASN1_TIME_print() returns 1 if the time is successfully printed out and 0 if
-an error occurred (I/O error or invalid time format).
+ASN1_TIME_check(), ASN1_UTCTIME_check and ASN1_GENERALIZEDTIME_check() return 1
+if the structure is syntactically correct and 0 otherwise.
+
+ASN1_TIME_print(), ASN1_UTCTIME_print() and ASN1_GENERALIZEDTIME_print() return 1
+if the time is successfully printed out and 0 if an error occurred (I/O error or
+invalid time format).
 
 ASN1_TIME_to_tm() returns 1 if the time is successfully parsed and 0 if an
 error occured (invalid time format).
 
 ASN1_TIME_diff() returns 1 for success and 0 for failure. It can fail if the
-pass ASN1_TIME structure has invalid syntax for example.
+passed-in time structure has invalid syntax, for example.
+
+ASN1_TIME_cmp_time_t() and ASN1_UTCTIME_cmp_time_t() return -1 if B&lt;s&gt; is
+before B&lt;t&gt;, 0 if B&lt;s&gt; equals B&lt;t&gt;, or 1 if B&lt;s&gt; is after B&lt;t&gt;. -2 is returned
+on error.
+
+ASN1_TIME_compare() returns -1 if B&lt;a&gt; is before B&lt;b&gt;, 0 if B&lt;a&gt; equals B&lt;b&gt;, or 1 if B&lt;a&gt; is after B&lt;b&gt;. -2 is returned on error.
+
+ASN1_TIME_to_generalizedtime() returns a pointer to
+the appropriate time structure on success or NULL if an error occurred.
 
 =head1 HISTORY
 
 The ASN1_TIME_to_tm() function was added in OpenSSL 1.1.1.
 The ASN1_TIME_set_string_X509() function was added in OpenSSL 1.1.1.
+The ASN1_TIME_normalize() function was added in OpenSSL 1.1.1.
+The ASN1_TIME_cmp_time_t() function was added in OpenSSL 1.1.1.
+The ASN1_TIME_compare() function was added in OpenSSL 1.1.1.
 
 =head1 COPYRIGHT
 
diff --git a/include/openssl/asn1.h b/include/openssl/asn1.h
index 6040992..54aa038 100644
--- a/include/openssl/asn1.h
+++ b/include/openssl/asn1.h
@@ -590,6 +590,7 @@ ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s,
                                                time_t t, int offset_day,
                                                long offset_sec);
 int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, const char *str);
+
 int ASN1_TIME_diff(int *pday, int *psec,
                    const ASN1_TIME *from, const ASN1_TIME *to);
 
@@ -632,6 +633,9 @@ ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(const ASN1_TIME *t,
 int ASN1_TIME_set_string(ASN1_TIME *s, const char *str);
 int ASN1_TIME_set_string_X509(ASN1_TIME *s, const char *str);
 int ASN1_TIME_to_tm(const ASN1_TIME *s, struct tm *tm);
+int ASN1_TIME_normalize(ASN1_TIME *s);
+int ASN1_TIME_cmp_time_t(const ASN1_TIME *s, time_t t);
+int ASN1_TIME_compare(const ASN1_TIME *a, const ASN1_TIME *b);
 
 int i2a_ASN1_INTEGER(BIO *bp, const ASN1_INTEGER *a);
 int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size);
diff --git a/test/asn1_time_test.c b/test/asn1_time_test.c
new file mode 100644
index 0000000..184a18a
--- /dev/null
+++ b/test/asn1_time_test.c
@@ -0,0 +1,296 @@
+/*
+ * Copyright 1999-2017 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+/* Time tests for the asn1 module */
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;openssl/asn1.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/objects.h&gt;
+#include &quot;testutil.h&quot;
+#include &quot;e_os.h&quot;
+
+struct testdata {
+    char *data;             /* TIME string value */
+    int type;               /* GENERALIZED OR UTC */
+    int expected_type;      /* expected type after set/set_string_gmt */
+    int check_result;       /* check result */
+    time_t t;               /* expected time_t*/
+    int cmp_result;         /* compariston to baseline result */
+    int convert_result;     /* convertion result */
+};
+
+static struct testdata tbl_testdata_pos[] = {
+    { &quot;0&quot;,                 V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, }, /* Bad time */
+    { &quot;ABCD&quot;,              V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;0ABCD&quot;,             V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;1-700101000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;`9700101000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;19700101000000Z&quot;,   V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         0,           0,  0, 0, },
+    { &quot;A00101000000Z&quot;,     V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         0,           0,  0, 0, },
+    { &quot;A9700101000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;1A700101000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;19A00101000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;197A0101000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;1970A101000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;19700A01000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;197001A1000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;1970010A000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;19700101A00000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;197001010A0000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;1970010100A000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;19700101000A00Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;197001010000A0Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;1970010100000AZ&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;700101000000X&quot;,     V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         0,           0,  0, 0, },
+    { &quot;19700101000000X&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 0,           0,  0, 0, },
+    { &quot;19700101000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,           0, -1, 1, }, /* Epoch begins */
+    { &quot;700101000000Z&quot;,     V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,           0, -1, 1, }, /* ditto */
+    { &quot;20380119031407Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,  0x7FFFFFFF,  1, 1, }, /* Max 32bit time_t */
+    { &quot;380119031407Z&quot;,     V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,  0x7FFFFFFF,  1, 1, },
+    { &quot;20371231235959Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,  2145916799,  1, 1, }, /* Just before 2038 */
+    { &quot;20371231235959Z&quot;,   V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         0,           0,  0, 1, }, /* Bad UTC time */
+    { &quot;371231235959Z&quot;,     V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,  2145916799,  1, 1, },
+    { &quot;19701006121456Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,    24063296, -1, 1, },
+    { &quot;701006121456Z&quot;,     V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,    24063296, -1, 1, },
+    { &quot;19991231000000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,   946598400,  0, 1, }, /* Match baseline */
+    { &quot;199912310000Z&quot;,     V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,   946598400,  0, 1, }, /* In various flavors */
+    { &quot;991231000000Z&quot;,     V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,   946598400,  0, 1, },
+    { &quot;9912310000Z&quot;,       V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,   946598400,  0, 1, },
+    { &quot;9912310000+0000&quot;,   V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,   946598400,  0, 1, },
+    { &quot;199912310000+0000&quot;, V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,   946598400,  0, 1, },
+    { &quot;9912310000-0000&quot;,   V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,   946598400,  0, 1, },
+    { &quot;199912310000-0000&quot;, V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,   946598400,  0, 1, },
+    { &quot;199912310100+0100&quot;, V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,   946598400,  0, 1, },
+    { &quot;199912302300-0100&quot;, V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,   946598400,  0, 1, },
+    { &quot;199912302300-A000&quot;, V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         0,   946598400,  0, 1, },
+    { &quot;199912302300-0A00&quot;, V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         0,   946598400,  0, 1, },
+    { &quot;9912310100+0100&quot;,   V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,   946598400,  0, 1, },
+    { &quot;9912302300-0100&quot;,   V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,   946598400,  0, 1, },
+};
+
+/* ASSUMES SIGNED TIME_T */
+static struct testdata tbl_testdata_neg[] = {
+    { &quot;19011213204552Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 1, -2147483648, -1, 0, },
+    { &quot;691006121456Z&quot;,     V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,    -7472704, -1, 1, },
+    { &quot;19691006121456Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,    -7472704, -1, 1, },
+};
+
+static struct testdata tbl_testdata_pos_64bit[] = {
+    { &quot;20380119031408Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,  0x80000000,  1, 1, },
+    { &quot;20380119031409Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_UTCTIME,         1,  0x80000001,  1, 1, },
+    { &quot;380119031408Z&quot;,     V_ASN1_UTCTIME,         V_ASN1_UTCTIME,         1,  0x80000000,  1, 1, },
+    { &quot;20500101120000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 1,  2524651200,  1, 0, },
+};
+
+/* ASSUMES SIGNED TIME_T */
+static struct testdata tbl_testdata_neg_64bit[] = {
+    { &quot;19011213204551Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 1, -2147483649, -1, 0, },
+    { &quot;19000101120000Z&quot;,   V_ASN1_GENERALIZEDTIME, V_ASN1_GENERALIZEDTIME, 1, -2208945600, -1, 0, },
+};
+
+/* A baseline time to compare to */
+static ASN1_TIME gtime = {
+    15,
+    V_ASN1_GENERALIZEDTIME,
+    (unsigned char*)&quot;19991231000000Z&quot;,
+    0
+};
+static time_t gtime_t = 946598400;
+
+static int test_table(struct testdata *tbl, int idx)
+{
+    int error = 0;
+    ASN1_TIME atime;
+    ASN1_TIME *ptime;
+    struct testdata *td = &amp;tbl[idx];
+    int day, sec;
+
+    atime.data = (unsigned char*)td-&gt;data;
+    atime.length = strlen((char*)atime.data);
+    atime.type = td-&gt;type;
+    atime.flags = 0;
+
+    if (!TEST_int_eq(ASN1_TIME_check(&amp;atime), td-&gt;check_result)) {
+        TEST_info(&quot;ASN1_TIME_check(%s) unexpected result&quot;, atime.data);
+        error = 1;
+    }
+    if (td-&gt;check_result == 0)
+        return 1;
+
+    if (!TEST_int_eq(ASN1_TIME_cmp_time_t(&amp;atime, td-&gt;t), 0)) {
+        TEST_info(&quot;ASN1_TIME_cmp_time_t(%s vs %ld) compare failed&quot;, atime.data, (long)td-&gt;t);
+        error = 1;
+    }
+
+    if (!TEST_true(ASN1_TIME_diff(&amp;day, &amp;sec, &amp;atime, &amp;atime))) {
+        TEST_info(&quot;ASN1_TIME_diff(%s) to self failed&quot;, atime.data);
+        error = 1;
+    }
+    if (!TEST_int_eq(day, 0) || !TEST_int_eq(sec, 0)) {
+        TEST_info(&quot;ASN1_TIME_diff(%s) to self not equal&quot;, atime.data);
+        error = 1;
+    }
+
+    if (!TEST_true(ASN1_TIME_diff(&amp;day, &amp;sec, &amp;gtime, &amp;atime))) {
+        TEST_info(&quot;ASN1_TIME_diff(%s) to baseline failed&quot;, atime.data);
+        error = 1;
+    } else if (!((td-&gt;cmp_result == 0 &amp;&amp; TEST_true((day == 0 &amp;&amp; sec == 0))) ||
+                 (td-&gt;cmp_result == -1 &amp;&amp; TEST_true((day &lt; 0 || sec &lt; 0))) ||
+                 (td-&gt;cmp_result == 1 &amp;&amp; TEST_true((day &gt; 0 || sec &gt; 0))))) {
+        TEST_info(&quot;ASN1_TIME_diff(%s) to baseline bad comparison&quot;, atime.data);
+        error = 1;
+    }
+
+    if (!TEST_int_eq(ASN1_TIME_cmp_time_t(&amp;atime, gtime_t), td-&gt;cmp_result)) {
+        TEST_info(&quot;ASN1_TIME_cmp_time_t(%s) to baseline bad comparison&quot;, atime.data);
+        error = 1;
+    }
+
+    ptime = ASN1_TIME_set(NULL, td-&gt;t);
+    if (!TEST_ptr(ptime)) {
+        TEST_info(&quot;ASN1_TIME_set(%ld) failed&quot;, (long)td-&gt;t);
+        error = 1;
+    } else {
+        int local_error = 0;
+        if (!TEST_int_eq(ASN1_TIME_cmp_time_t(ptime, td-&gt;t), 0)) {
+            TEST_info(&quot;ASN1_TIME_set(%ld) compare failed (%s-&gt;%s)&quot;,
+                    (long)td-&gt;t, td-&gt;data, ptime-&gt;data);
+            local_error = error = 1;
+        }
+        if (!TEST_int_eq(ptime-&gt;type, td-&gt;expected_type)) {
+            TEST_info(&quot;ASN1_TIME_set(%ld) unexpected type&quot;, (long)td-&gt;t);
+            local_error = error = 1;
+        }
+        if (local_error)
+            TEST_info(&quot;ASN1_TIME_set() = %*s&quot;, ptime-&gt;length, ptime-&gt;data);
+        ASN1_TIME_free(ptime);
+    }
+
+    ptime = ASN1_TIME_new();
+    if (!TEST_ptr(ptime)) {
+        TEST_info(&quot;ASN1_TIME_new() failed&quot;);
+        error = 1;
+    } else {
+        int local_error = 0;
+        if (!TEST_int_eq(ASN1_TIME_set_string(ptime, td-&gt;data), td-&gt;check_result)) {
+            TEST_info(&quot;ASN1_TIME_set_string_gmt(%s) failed&quot;, td-&gt;data);
+            local_error = error = 1;
+        }
+        if (!TEST_int_eq(ASN1_TIME_normalize(ptime), td-&gt;check_result)) {
+            TEST_info(&quot;ASN1_TIME_normalize(%s) failed&quot;, td-&gt;data);
+            local_error = error = 1;
+        }
+        if (!TEST_int_eq(ptime-&gt;type, td-&gt;expected_type)) {
+            TEST_info(&quot;ASN1_TIME_set_string_gmt(%s) unexpected type&quot;, td-&gt;data);
+            local_error = error = 1;
+        }
+        day = sec = 0;
+        if (!TEST_true(ASN1_TIME_diff(&amp;day, &amp;sec, ptime, &amp;atime)) || !TEST_int_eq(day, 0) || !TEST_int_eq(sec, 0)) {
+            TEST_info(&quot;ASN1_TIME_diff(day=%d, sec=%d, %s) after ASN1_TIME_set_string_gmt() failed&quot;, day, sec, td-&gt;data);
+            local_error = error = 1;
+        }
+        if (!TEST_int_eq(ASN1_TIME_cmp_time_t(ptime, gtime_t), td-&gt;cmp_result)) {
+            TEST_info(&quot;ASN1_TIME_cmp_time_t(%s) after ASN1_TIME_set_string_gnt() to baseline bad comparison&quot;, td-&gt;data);
+            local_error = error = 1;
+        }
+        if (local_error)
+            TEST_info(&quot;ASN1_TIME_set_string_gmt() = %*s&quot;, ptime-&gt;length, ptime-&gt;data);
+        ASN1_TIME_free(ptime);
+    }
+
+    ptime = ASN1_TIME_new();
+    if (!TEST_ptr(ptime)) {
+        TEST_info(&quot;ASN1_TIME_new() failed&quot;);
+        error = 1;
+    } else {
+        int local_error = 0;
+        if (!TEST_int_eq(ASN1_TIME_set_string(ptime, td-&gt;data), td-&gt;check_result)) {
+            TEST_info(&quot;ASN1_TIME_set_string(%s) failed&quot;, td-&gt;data);
+            local_error = error = 1;
+        }
+        day = sec = 0;
+        if (!TEST_true(ASN1_TIME_diff(&amp;day, &amp;sec, ptime, &amp;atime)) || !TEST_int_eq(day, 0) || !TEST_int_eq(sec, 0)) {
+            TEST_info(&quot;ASN1_TIME_diff(day=%d, sec=%d, %s) after ASN1_TIME_set_string() failed&quot;, day, sec, td-&gt;data);
+            local_error = error = 1;
+        }
+        if (!TEST_int_eq(ASN1_TIME_cmp_time_t(ptime, gtime_t), td-&gt;cmp_result)) {
+            TEST_info(&quot;ASN1_TIME_cmp_time_t(%s) after ASN1_TIME_set_string() to baseline bad comparison&quot;, td-&gt;data);
+            local_error = error = 1;
+        }
+        if (local_error)
+            TEST_info(&quot;ASN1_TIME_set_string() = %*s&quot;, ptime-&gt;length, ptime-&gt;data);
+        ASN1_TIME_free(ptime);
+    }
+
+    if (td-&gt;type == V_ASN1_UTCTIME) {
+        ptime = ASN1_TIME_to_generalizedtime(&amp;atime, NULL);
+        if (td-&gt;convert_result == 1 &amp;&amp; !TEST_ptr(ptime)) {
+            TEST_info(&quot;ASN1_TIME_to_generalizedtime(%s) failed&quot;, atime.data);
+            error = 1;
+        } else if (td-&gt;convert_result == 0 &amp;&amp; !TEST_ptr_null(ptime)) {
+            TEST_info(&quot;ASN1_TIME_to_generalizedtime(%s) should have failed&quot;, atime.data);
+            error = 1;
+        }
+        if (ptime != NULL &amp;&amp; !TEST_int_eq(ASN1_TIME_cmp_time_t(ptime, td-&gt;t), 0)) {
+            TEST_info(&quot;ASN1_TIME_to_generalizedtime(%s-&gt;%s) bad result&quot;, atime.data, ptime-&gt;data);
+            error = 1;
+        }
+        ASN1_TIME_free(ptime);
+    }
+    /* else cannot simply convert GENERALIZEDTIME to UTCTIME */
+
+    if (error)
+        TEST_error(&quot;atime=%s&quot;, atime.data);
+
+    return !error;
+}
+
+static int test_table_pos(int idx)
+{
+    return test_table(tbl_testdata_pos, idx);
+}
+
+static int test_table_neg(int idx)
+{
+    return test_table(tbl_testdata_neg, idx);
+}
+
+static int test_table_pos_64bit(int idx)
+{
+    return test_table(tbl_testdata_pos_64bit, idx);
+}
+
+static int test_table_neg_64bit(int idx)
+{
+    return test_table(tbl_testdata_neg_64bit, idx);
+}
+
+int setup_tests(void)
+{
+    time_t t = -1;
+    struct tm *ptm = localtime(&amp;t);
+
+    ADD_ALL_TESTS(test_table_pos, OSSL_NELEM(tbl_testdata_pos));
+    if (ptm != NULL) {
+        TEST_info(&quot;Adding negative-sign time_t tests&quot;);
+        ADD_ALL_TESTS(test_table_neg, OSSL_NELEM(tbl_testdata_neg));
+    }
+    if (sizeof(time_t) &gt; sizeof(uint32_t)) {
+        TEST_info(&quot;Adding 64-bit time_t tests&quot;);
+        ADD_ALL_TESTS(test_table_pos_64bit, OSSL_NELEM(tbl_testdata_pos_64bit));
+        if (ptm != NULL) {
+            TEST_info(&quot;Adding negative-sign 64-bit time_t tests&quot;);
+            ADD_ALL_TESTS(test_table_neg_64bit, OSSL_NELEM(tbl_testdata_neg_64bit));
+        }
+    }
+    return 1;
+}
diff --git a/test/build.info b/test/build.info
index 34d72d7..2fe336b 100644
--- a/test/build.info
+++ b/test/build.info
@@ -432,6 +432,11 @@ INCLUDE_MAIN___test_libtestutil_OLB = /INCLUDE=MAIN
   INCLUDE[mdc2_internal_test]=.. ../include
   DEPEND[mdc2_internal_test]=../libcrypto libtestutil.a
 
+  PROGRAMS_NO_INST=asn1_time_test
+  SOURCE[asn1_time_test]=asn1_time_test.c
+  INCLUDE[asn1_time_test]=.. ../include
+  DEPEND[asn1_time_test]=../libcrypto libtestutil.a
+
   # We disable this test completely in a shared build because it deliberately
   # redefines some internal libssl symbols. This doesn't work in a non-shared
   # build
diff --git a/test/recipes/05-test_bf.t b/test/recipes/90-test_asn1_time.t
similarity index 73%
copy from test/recipes/05-test_bf.t
copy to test/recipes/90-test_asn1_time.t
index 64c9609..d685eea 100644
--- a/test/recipes/05-test_bf.t
+++ b/test/recipes/90-test_asn1_time.t
@@ -1,5 +1,5 @@
 #! /usr/bin/env perl
-# Copyright 2015-2016 The OpenSSL Project Authors. All Rights Reserved.
+# Copyright 2015-2017 The OpenSSL Project Authors. All Rights Reserved.
 #
 # Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
 # this file except in compliance with the License.  You can obtain a copy
@@ -9,4 +9,4 @@
 
 use OpenSSL::Test::Simple;
 
-simple_test(&quot;test_bf&quot;, &quot;bftest&quot;, &quot;bf&quot;);
+simple_test(&quot;test_asn1_time&quot;, &quot;asn1_time_test&quot;);
diff --git a/test/time_offset_test.c b/test/time_offset_test.c
index 3560f4c..b7f1e87 100644
--- a/test/time_offset_test.c
+++ b/test/time_offset_test.c
@@ -96,10 +96,7 @@ static int test_offset(int idx)
         return 0;
     }
 
-    if (at.type == V_ASN1_UTCTIME)
-        ret = ASN1_UTCTIME_cmp_time_t(&amp;at, the_time);
-    else
-        return 1; /* no other cmp_time_t() functions available, yet */
+    ret = ASN1_TIME_cmp_time_t(&amp;at, the_time);
 
     if (!TEST_int_eq(testdata-&gt;time_result, ret)) {
         TEST_info(&quot;ASN1_UTCTIME_cmp_time_t() test failed for %s\n&quot;, at.data);
diff --git a/util/libcrypto.num b/util/libcrypto.num
index 457928c..fbfcb5c 100644
--- a/util/libcrypto.num
+++ b/util/libcrypto.num
@@ -4376,3 +4376,6 @@ RAND_DRBG_get0_global                   4319	1_1_1	EXIST::FUNCTION:
 RAND_priv_bytes                         4320	1_1_1	EXIST::FUNCTION:
 BN_priv_rand                            4321	1_1_1	EXIST::FUNCTION:
 BN_priv_rand_range                      4322	1_1_1	EXIST::FUNCTION:
+ASN1_TIME_normalize                     4323	1_1_1	EXIST::FUNCTION:
+ASN1_TIME_cmp_time_t                    4324	1_1_1	EXIST::FUNCTION:
+ASN1_TIME_compare                       4325	1_1_1	EXIST::FUNCTION:
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015763.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="015787.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15766">[ date ]</a>
              <a href="thread.html#15766">[ thread ]</a>
              <a href="subject.html#15766">[ subject ]</a>
              <a href="author.html#15766">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
