<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2017-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1495458068.261178.16002.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014744.html">
   <LINK REL="Next"  HREF="014755.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1495458068.261178.16002.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Mon May 22 13:01:08 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="014744.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="014755.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14745">[ date ]</a>
              <a href="thread.html#14745">[ thread ]</a>
              <a href="subject.html#14745">[ subject ]</a>
              <a href="author.html#14745">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  42bd7a16d020de40ad166336fe60409aa9256f9b (commit)
       via  b77f3ed17134fe6bf99d143abb1aec3f2bfac555 (commit)
       via  a89325e41f52b4a1f58202f6d8f5597105fc9f5a (commit)
       via  380a522f689252e7f19e0c44ea49461ec7bd040f (commit)
       via  98d132cf6a879faf0147aa83ea0c07ff326260ed (commit)
      from  7ac5b84ea7920343f5c69247251bbc84ac259b2b (commit)


- Log -----------------------------------------------------------------
commit 42bd7a16d020de40ad166336fe60409aa9256f9b
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon May 22 12:36:11 2017 +0100

    Add an error to the stack on failure in dtls1_write_bytes()
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3496">https://github.com/openssl/openssl/pull/3496</A>)

commit b77f3ed17134fe6bf99d143abb1aec3f2bfac555
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon May 22 12:33:42 2017 +0100

    Convert existing usage of assert() to ossl_assert() in libssl
    
    Provides consistent output and approach.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3496">https://github.com/openssl/openssl/pull/3496</A>)

commit a89325e41f52b4a1f58202f6d8f5597105fc9f5a
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Mon May 22 12:33:29 2017 +0100

    Fix some style issues in returns
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3496">https://github.com/openssl/openssl/pull/3496</A>)

commit 380a522f689252e7f19e0c44ea49461ec7bd040f
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri May 19 09:35:19 2017 +0100

    Replace instances of OPENSSL_assert() with soft asserts in libssl
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3496">https://github.com/openssl/openssl/pull/3496</A>)

commit 98d132cf6a879faf0147aa83ea0c07ff326260ed
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri May 19 09:30:37 2017 +0100

    Add a macro for testing assertion in both debug and production builds
    
    If we have an assert then in a debug build we want an abort() to occur.
    In a production build we want the function to return an error.
    
    This introduces a new macro to assist with that. The idea is to replace
    existing use of OPENSSL_assert() with this new macro. The problem with
    OPENSSL_assert() is that it aborts() on an assertion failure in both debug
    and production builds. It should never be a library's decision to abort a
    process (we don't get to decide when to kill the life support machine or
    the nuclear reactor control system). Additionally if an attacker can
    cause a reachable assert to be hit then this can be a source of DoS attacks
    e.g. see CVE-2017-3733, CVE-2015-0293, CVE-2011-4577 and CVE-2002-1568.
    
    Reviewed-by: Tim Hudson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3496">https://github.com/openssl/openssl/pull/3496</A>)

-----------------------------------------------------------------------

Summary of changes:
 e_os.h                         | 18 ++++++++++++++
 include/openssl/ssl.h          |  1 +
 ssl/d1_lib.c                   | 20 +++++++++------
 ssl/packet.c                   | 33 +++++++++----------------
 ssl/record/rec_layer_d1.c      | 15 +++++------
 ssl/record/rec_layer_s3.c      |  1 -
 ssl/record/record_locl.h       |  2 +-
 ssl/record/ssl3_record.c       | 56 +++++++++++++++++++++++++++++++-----------
 ssl/record/ssl3_record_tls13.c |  4 +--
 ssl/s3_cbc.c                   | 18 ++++++++------
 ssl/s3_enc.c                   |  5 +++-
 ssl/s3_lib.c                   | 21 ++++++++++------
 ssl/ssl_ciph.c                 | 13 +++++++---
 ssl/ssl_err.c                  |  1 +
 ssl/ssl_init.c                 |  4 +--
 ssl/ssl_lib.c                  | 29 +++++++++++++---------
 ssl/ssl_locl.h                 | 12 ++++-----
 ssl/statem/extensions_clnt.c   | 13 ++++++----
 ssl/statem/extensions_cust.c   |  6 +++--
 ssl/statem/statem_dtls.c       | 44 ++++++++++++++++++---------------
 ssl/statem/statem_lib.c        | 22 +++++++++++------
 ssl/t1_lib.c                   | 16 ++++++++----
 22 files changed, 221 insertions(+), 133 deletions(-)

diff --git a/e_os.h b/e_os.h
index 914a2bf..49a0c3e 100644
--- a/e_os.h
+++ b/e_os.h
@@ -13,6 +13,7 @@
 # include &lt;openssl/opensslconf.h&gt;
 
 # include &lt;openssl/e_os2.h&gt;
+# include &lt;openssl/crypto.h&gt;
 /*
  * &lt;openssl/e_os2.h&gt; contains what we can justify to make visible to the
  * outside; this file e_os.h is not part of the exported interface.
@@ -544,6 +545,23 @@ struct servent *getservbyname(const char *name, const char *proto);
 # define CRYPTO_memcmp memcmp
 #endif
 
+#ifdef NDEBUG
+# define ossl_assert(x) (int)(x)
+#else
+__owur static ossl_inline int ossl_assert_int(int expr, const char *exprstr,
+                                              const char *file, int line)
+{
+    if (!expr)
+        OPENSSL_die(exprstr, file, line);
+
+    return expr;
+}
+
+# define ossl_assert(x) ossl_assert_int((int)(x), &quot;Assertion failed: &quot;#x, \
+                                         __FILE__, __LINE__)
+
+#endif
+
 #ifdef  __cplusplus
 }
 #endif
diff --git a/include/openssl/ssl.h b/include/openssl/ssl.h
index a2d6862..8eb3c53 100644
--- a/include/openssl/ssl.h
+++ b/include/openssl/ssl.h
@@ -2259,6 +2259,7 @@ int ERR_load_SSL_strings(void);
 # define SSL_F_DTLS1_READ_FAILED                          339
 # define SSL_F_DTLS1_RETRANSMIT_MESSAGE                   390
 # define SSL_F_DTLS1_WRITE_APP_DATA_BYTES                 268
+# define SSL_F_DTLS1_WRITE_BYTES                          545
 # define SSL_F_DTLSV1_LISTEN                              350
 # define SSL_F_DTLS_CONSTRUCT_CHANGE_CIPHER_SPEC          371
 # define SSL_F_DTLS_CONSTRUCT_HELLO_VERIFY_REQUEST        385
diff --git a/ssl/d1_lib.c b/ssl/d1_lib.c
index eb6a0f8..150e875 100644
--- a/ssl/d1_lib.c
+++ b/ssl/d1_lib.c
@@ -79,10 +79,10 @@ int dtls1_new(SSL *s)
     }
 
     if (!ssl3_new(s))
-        return (0);
+        return 0;
     if ((d1 = OPENSSL_zalloc(sizeof(*d1))) == NULL) {
         ssl3_free(s);
-        return (0);
+        return 0;
     }
 
     d1-&gt;buffered_messages = pqueue_new();
@@ -100,12 +100,15 @@ int dtls1_new(SSL *s)
         pqueue_free(d1-&gt;sent_messages);
         OPENSSL_free(d1);
         ssl3_free(s);
-        return (0);
+        return 0;
     }
 
     s-&gt;d1 = d1;
-    s-&gt;method-&gt;ssl_clear(s);
-    return (1);
+
+    if (!s-&gt;method-&gt;ssl_clear(s))
+        return 0;
+
+    return 1;
 }
 
 static void dtls1_clear_queues(SSL *s)
@@ -154,7 +157,7 @@ void dtls1_free(SSL *s)
     s-&gt;d1 = NULL;
 }
 
-void dtls1_clear(SSL *s)
+int dtls1_clear(SSL *s)
 {
     pqueue *buffered_messages;
     pqueue *sent_messages;
@@ -186,7 +189,8 @@ void dtls1_clear(SSL *s)
         s-&gt;d1-&gt;sent_messages = sent_messages;
     }
 
-    ssl3_clear(s);
+    if (!ssl3_clear(s))
+        return 0;
 
     if (s-&gt;method-&gt;version == DTLS_ANY_VERSION)
         s-&gt;version = DTLS_MAX_VERSION;
@@ -196,6 +200,8 @@ void dtls1_clear(SSL *s)
 #endif
     else
         s-&gt;version = s-&gt;method-&gt;version;
+
+    return 1;
 }
 
 long dtls1_ctrl(SSL *s, int cmd, long larg, void *parg)
diff --git a/ssl/packet.c b/ssl/packet.c
index d081f55..7c4be4f 100644
--- a/ssl/packet.c
+++ b/ssl/packet.c
@@ -7,7 +7,7 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;assert.h&gt;
+#include &quot;e_os.h&quot;
 #include &quot;packet_locl.h&quot;
 
 #define DEFAULT_BUF_SIZE    256
@@ -39,8 +39,7 @@ int WPACKET_sub_allocate_bytes__(WPACKET *pkt, size_t len,
 int WPACKET_reserve_bytes(WPACKET *pkt, size_t len, unsigned char **allocbytes)
 {
     /* Internal API, so should not fail */
-    assert(pkt-&gt;subs != NULL &amp;&amp; len != 0);
-    if (pkt-&gt;subs == NULL || len == 0)
+    if (!ossl_assert(pkt-&gt;subs != NULL &amp;&amp; len != 0))
         return 0;
 
     if (pkt-&gt;maxsize - pkt-&gt;written &lt; len)
@@ -120,8 +119,7 @@ int WPACKET_init_static_len(WPACKET *pkt, unsigned char *buf, size_t len,
     size_t max = maxmaxsize(lenbytes);
 
     /* Internal API, so should not fail */
-    assert(buf != NULL &amp;&amp; len &gt; 0);
-    if (buf == NULL || len == 0)
+    if (!ossl_assert(buf != NULL &amp;&amp; len &gt; 0))
         return 0;
 
     pkt-&gt;staticbuf = buf;
@@ -134,8 +132,7 @@ int WPACKET_init_static_len(WPACKET *pkt, unsigned char *buf, size_t len,
 int WPACKET_init_len(WPACKET *pkt, BUF_MEM *buf, size_t lenbytes)
 {
     /* Internal API, so should not fail */
-    assert(buf != NULL);
-    if (buf == NULL)
+    if (!ossl_assert(buf != NULL))
         return 0;
 
     pkt-&gt;staticbuf = NULL;
@@ -153,8 +150,7 @@ int WPACKET_init(WPACKET *pkt, BUF_MEM *buf)
 int WPACKET_set_flags(WPACKET *pkt, unsigned int flags)
 {
     /* Internal API, so should not fail */
-    assert(pkt-&gt;subs != NULL);
-    if (pkt-&gt;subs == NULL)
+    if (!ossl_assert(pkt-&gt;subs != NULL))
         return 0;
 
     pkt-&gt;subs-&gt;flags = flags;
@@ -228,8 +224,7 @@ int WPACKET_fill_lengths(WPACKET *pkt)
 {
     WPACKET_SUB *sub;
 
-    assert(pkt-&gt;subs != NULL);
-    if (pkt-&gt;subs == NULL)
+    if (!ossl_assert(pkt-&gt;subs != NULL))
         return 0;
 
     for (sub = pkt-&gt;subs; sub != NULL; sub = sub-&gt;parent) {
@@ -278,8 +273,7 @@ int WPACKET_start_sub_packet_len__(WPACKET *pkt, size_t lenbytes)
     unsigned char *lenchars;
 
     /* Internal API, so should not fail */
-    assert(pkt-&gt;subs != NULL);
-    if (pkt-&gt;subs == NULL)
+    if (!ossl_assert(pkt-&gt;subs != NULL))
         return 0;
 
     sub = OPENSSL_zalloc(sizeof(*sub));
@@ -314,9 +308,7 @@ int WPACKET_put_bytes__(WPACKET *pkt, unsigned int val, size_t size)
     unsigned char *data;
 
     /* Internal API, so should not fail */
-    assert(size &lt;= sizeof(unsigned int));
-
-    if (size &gt; sizeof(unsigned int)
+    if (!ossl_assert(size &lt;= sizeof(unsigned int))
             || !WPACKET_allocate_bytes(pkt, size, &amp;data)
             || !put_value(data, val, size))
         return 0;
@@ -330,8 +322,7 @@ int WPACKET_set_max_size(WPACKET *pkt, size_t maxsize)
     size_t lenbytes;
 
     /* Internal API, so should not fail */
-    assert(pkt-&gt;subs != NULL);
-    if (pkt-&gt;subs == NULL)
+    if (!ossl_assert(pkt-&gt;subs != NULL))
         return 0;
 
     /* Find the WPACKET_SUB for the top level */
@@ -394,8 +385,7 @@ int WPACKET_sub_memcpy__(WPACKET *pkt, const void *src, size_t len,
 int WPACKET_get_total_written(WPACKET *pkt, size_t *written)
 {
     /* Internal API, so should not fail */
-    assert(written != NULL);
-    if (written == NULL)
+    if (!ossl_assert(written != NULL))
         return 0;
 
     *written = pkt-&gt;written;
@@ -406,8 +396,7 @@ int WPACKET_get_total_written(WPACKET *pkt, size_t *written)
 int WPACKET_get_length(WPACKET *pkt, size_t *len)
 {
     /* Internal API, so should not fail */
-    assert(pkt-&gt;subs != NULL &amp;&amp; len != NULL);
-    if (pkt-&gt;subs == NULL || len == NULL)
+    if (!ossl_assert(pkt-&gt;subs != NULL &amp;&amp; len != NULL))
         return 0;
 
     *len = pkt-&gt;written - pkt-&gt;subs-&gt;pwritten;
diff --git a/ssl/record/rec_layer_d1.c b/ssl/record/rec_layer_d1.c
index 487b096..83f4094 100644
--- a/ssl/record/rec_layer_d1.c
+++ b/ssl/record/rec_layer_d1.c
@@ -14,7 +14,6 @@
 #include &lt;openssl/evp.h&gt;
 #include &lt;openssl/buffer.h&gt;
 #include &quot;record_locl.h&quot;
-#include &lt;assert.h&gt;
 #include &quot;../packet_locl.h&quot;
 
 int DTLS_RECORD_LAYER_new(RECORD_LAYER *rl)
@@ -645,8 +644,7 @@ int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
          * (which is tested for at the top of this function) then init must be
          * finished
          */
-        assert(SSL_is_init_finished(s));
-        if (!SSL_is_init_finished(s)) {
+        if (!ossl_assert(SSL_is_init_finished(s))) {
             al = SSL_AD_INTERNAL_ERROR;
             SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
             goto f_err;
@@ -734,7 +732,10 @@ int dtls1_write_bytes(SSL *s, int type, const void *buf, size_t len,
 {
     int i;
 
-    OPENSSL_assert(len &lt;= SSL3_RT_MAX_PLAIN_LENGTH);
+    if (!ossl_assert(len &lt;= SSL3_RT_MAX_PLAIN_LENGTH)) {
+        SSLerr(SSL_F_DTLS1_WRITE_BYTES, ERR_R_INTERNAL_ERROR);
+        return -1;
+    }
     s-&gt;rwstate = SSL_NOTHING;
     i = do_dtls1_write(s, type, buf, len, 0, written);
     return i;
@@ -757,9 +758,9 @@ int do_dtls1_write(SSL *s, int type, const unsigned char *buf,
      * first check if there is a SSL3_BUFFER still being written out.  This
      * will happen with non blocking IO
      */
-    if (SSL3_BUFFER_get_left(wb) != 0) {
-        OPENSSL_assert(0);      /* XDTLS: want to see if we ever get here */
-        return ssl3_write_pending(s, type, buf, len, written);
+    if (!ossl_assert(SSL3_BUFFER_get_left(wb) == 0)) {
+        SSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR);
+        return 0;
     }
 
     /* If we have an alert to send, lets send it */
diff --git a/ssl/record/rec_layer_s3.c b/ssl/record/rec_layer_s3.c
index dabb02c..fbabdf4 100644
--- a/ssl/record/rec_layer_s3.c
+++ b/ssl/record/rec_layer_s3.c
@@ -8,7 +8,6 @@
  */
 
 #include &lt;stdio.h&gt;
-#include &lt;assert.h&gt;
 #include &lt;limits.h&gt;
 #include &lt;errno.h&gt;
 #define USE_SOCKETS
diff --git a/ssl/record/record_locl.h b/ssl/record/record_locl.h
index e249918..2b55bec 100644
--- a/ssl/record/record_locl.h
+++ b/ssl/record/record_locl.h
@@ -106,7 +106,7 @@ void SSL3_RECORD_set_seq_num(SSL3_RECORD *r, const unsigned char *seq_num);
 int ssl3_get_record(SSL *s);
 __owur int ssl3_do_compress(SSL *ssl, SSL3_RECORD *wr);
 __owur int ssl3_do_uncompress(SSL *ssl, SSL3_RECORD *rr);
-void ssl3_cbc_copy_mac(unsigned char *out,
+int ssl3_cbc_copy_mac(unsigned char *out,
                        const SSL3_RECORD *rec, size_t md_size);
 __owur int ssl3_cbc_remove_padding(SSL3_RECORD *rec,
                                    size_t block_size, size_t mac_size);
diff --git a/ssl/record/ssl3_record.c b/ssl/record/ssl3_record.c
index 8ebb1b9..bd27290 100644
--- a/ssl/record/ssl3_record.c
+++ b/ssl/record/ssl3_record.c
@@ -7,7 +7,6 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;assert.h&gt;
 #include &quot;../ssl_locl.h&quot;
 #include &quot;internal/constant_time_locl.h&quot;
 #include &lt;openssl/rand.h&gt;
@@ -436,8 +435,7 @@ int ssl3_get_record(SSL *s)
         unsigned char *mac;
         /* TODO(size_t): convert this to do size_t properly */
         imac_size = EVP_MD_CTX_size(s-&gt;read_hash);
-        assert(imac_size &gt;= 0 &amp;&amp; imac_size &lt;= EVP_MAX_MD_SIZE);
-        if (imac_size &lt; 0 || imac_size &gt; EVP_MAX_MD_SIZE) {
+        if (!ossl_assert(imac_size &gt;= 0 &amp;&amp; imac_size &lt;= EVP_MAX_MD_SIZE)) {
                 al = SSL_AD_INTERNAL_ERROR;
                 SSLerr(SSL_F_SSL3_GET_RECORD, ERR_LIB_EVP);
                 goto f_err;
@@ -515,7 +513,11 @@ int ssl3_get_record(SSL *s)
         unsigned char mac_tmp[EVP_MAX_MD_SIZE];
 
         mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
-        OPENSSL_assert(mac_size &lt;= EVP_MAX_MD_SIZE);
+        if (!ossl_assert(mac_size &lt;= EVP_MAX_MD_SIZE)) {
+            al = SSL_AD_INTERNAL_ERROR;
+            SSLerr(SSL_F_SSL3_GET_RECORD, ERR_R_INTERNAL_ERROR);
+            goto f_err;
+        }
 
         for (j = 0; j &lt; num_recs; j++) {
             thisrr = &amp;rr[j];
@@ -542,7 +544,11 @@ int ssl3_get_record(SSL *s)
                  * contents of the padding bytes.
                  */
                 mac = mac_tmp;
-                ssl3_cbc_copy_mac(mac_tmp, thisrr, mac_size);
+                if (!ssl3_cbc_copy_mac(mac_tmp, thisrr, mac_size)) {
+                    al = SSL_AD_INTERNAL_ERROR;
+                    SSLerr(SSL_F_SSL3_GET_RECORD, ERR_R_INTERNAL_ERROR);
+                    goto f_err;
+                }
                 thisrr-&gt;length -= mac_size;
             } else {
                 /*
@@ -859,7 +865,10 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending)
     if (sending) {
         if (EVP_MD_CTX_md(s-&gt;write_hash)) {
             int n = EVP_MD_CTX_size(s-&gt;write_hash);
-            OPENSSL_assert(n &gt;= 0);
+            if (!ossl_assert(n &gt;= 0)) {
+                SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR);
+                return -1;
+            }
         }
         ds = s-&gt;enc_write_ctx;
         if (s-&gt;enc_write_ctx == NULL)
@@ -892,7 +901,10 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending)
     } else {
         if (EVP_MD_CTX_md(s-&gt;read_hash)) {
             int n = EVP_MD_CTX_size(s-&gt;read_hash);
-            OPENSSL_assert(n &gt;= 0);
+            if (!ossl_assert(n &gt;= 0)) {
+                SSLerr(SSL_F_TLS1_ENC, ERR_R_INTERNAL_ERROR);
+                return -1;
+            }
         }
         ds = s-&gt;enc_read_ctx;
         if (s-&gt;enc_read_ctx == NULL)
@@ -1179,7 +1191,8 @@ int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int sending)
     }
 
     t = EVP_MD_CTX_size(hash);
-    OPENSSL_assert(t &gt;= 0);
+    if (!ossl_assert(t &gt;= 0))
+        return 0;
     md_size = t;
 
     /* I should fix this up TLS TLS TLS TLS TLS XXXXXXXX */
@@ -1404,7 +1417,7 @@ int tls1_cbc_remove_padding(const SSL *s,
  */
 #define CBC_MAC_ROTATE_IN_PLACE
 
-void ssl3_cbc_copy_mac(unsigned char *out,
+int ssl3_cbc_copy_mac(unsigned char *out,
                        const SSL3_RECORD *rec, size_t md_size)
 {
 #if defined(CBC_MAC_ROTATE_IN_PLACE)
@@ -1428,8 +1441,9 @@ void ssl3_cbc_copy_mac(unsigned char *out,
     size_t i, j;
     size_t rotate_offset;
 
-    OPENSSL_assert(rec-&gt;orig_len &gt;= md_size);
-    OPENSSL_assert(md_size &lt;= EVP_MAX_MD_SIZE);
+    if (!ossl_assert(rec-&gt;orig_len &gt;= md_size
+                     &amp;&amp; md_size &lt;= EVP_MAX_MD_SIZE))
+        return 0;
 
 #if defined(CBC_MAC_ROTATE_IN_PLACE)
     rotated_mac = rotated_mac_buf + ((0 - (size_t)rotated_mac_buf) &amp; 63);
@@ -1474,6 +1488,8 @@ void ssl3_cbc_copy_mac(unsigned char *out,
         rotate_offset &amp;= constant_time_lt_s(rotate_offset, md_size);
     }
 #endif
+
+    return 1;
 }
 
 int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)
@@ -1521,7 +1537,11 @@ int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)
     if (SSL_READ_ETM(s) &amp;&amp; s-&gt;read_hash) {
         unsigned char *mac;
         mac_size = EVP_MD_CTX_size(s-&gt;read_hash);
-        OPENSSL_assert(mac_size &lt;= EVP_MAX_MD_SIZE);
+        if (!ossl_assert(mac_size &lt;= EVP_MAX_MD_SIZE)) {
+            al = SSL_AD_INTERNAL_ERROR;
+            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, ERR_R_INTERNAL_ERROR);
+            goto f_err;
+        }
         if (rr-&gt;orig_len &lt; mac_size) {
             al = SSL_AD_DECODE_ERROR;
             SSLerr(SSL_F_DTLS1_PROCESS_RECORD, SSL_R_LENGTH_TOO_SHORT);
@@ -1576,7 +1596,11 @@ int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)
             goto f_err;
         }
         mac_size = (size_t)imac_size;
-        OPENSSL_assert(mac_size &lt;= EVP_MAX_MD_SIZE);
+        if (!ossl_assert(mac_size &lt;= EVP_MAX_MD_SIZE)) {
+            al = SSL_AD_INTERNAL_ERROR;
+            SSLerr(SSL_F_DTLS1_PROCESS_RECORD, ERR_R_INTERNAL_ERROR);
+            goto f_err;
+        }
 
         /*
          * orig_len is the length of the record before any padding was
@@ -1601,7 +1625,11 @@ int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)
              * contents of the padding bytes.
              */
             mac = mac_tmp;
-            ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);
+            if (!ssl3_cbc_copy_mac(mac_tmp, rr, mac_size)) {
+                al = SSL_AD_INTERNAL_ERROR;
+                SSLerr(SSL_F_DTLS1_PROCESS_RECORD, ERR_R_INTERNAL_ERROR);
+                goto f_err;
+            }
             rr-&gt;length -= mac_size;
         } else {
             /*
diff --git a/ssl/record/ssl3_record_tls13.c b/ssl/record/ssl3_record_tls13.c
index 9e65852..61e2092 100644
--- a/ssl/record/ssl3_record_tls13.c
+++ b/ssl/record/ssl3_record_tls13.c
@@ -7,7 +7,6 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;assert.h&gt;
 #include &quot;../ssl_locl.h&quot;
 #include &quot;record_locl.h&quot;
 
@@ -64,8 +63,7 @@ int tls13_enc(SSL *s, SSL3_RECORD *recs, size_t n_recs, int sending)
          * To get here we must have selected a ciphersuite - otherwise ctx would
          * be NULL
          */
-        assert(s-&gt;s3-&gt;tmp.new_cipher != NULL);
-        if (s-&gt;s3-&gt;tmp.new_cipher == NULL)
+        if (!ossl_assert(s-&gt;s3-&gt;tmp.new_cipher != NULL))
             return -1;
         alg_enc = s-&gt;s3-&gt;tmp.new_cipher-&gt;algorithm_enc;
     }
diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c
index 186ab17..0981360 100644
--- a/ssl/s3_cbc.c
+++ b/ssl/s3_cbc.c
@@ -165,7 +165,8 @@ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,
      * This is a, hopefully redundant, check that allows us to forget about
      * many possible overflows later in this function.
      */
-    OPENSSL_assert(data_plus_mac_plus_padding_size &lt; 1024 * 1024);
+    if (!ossl_assert(data_plus_mac_plus_padding_size &lt; 1024 * 1024))
+        return 0;
 
     switch (EVP_MD_CTX_type(ctx)) {
     case NID_md5:
@@ -227,15 +228,15 @@ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,
          * ssl3_cbc_record_digest_supported should have been called first to
          * check that the hash function is supported.
          */
-        OPENSSL_assert(0);
-        if (md_out_size)
+        if (md_out_size != NULL)
             *md_out_size = 0;
-        return 0;
+        return ossl_assert(0);
     }
 
-    OPENSSL_assert(md_length_size &lt;= MAX_HASH_BIT_COUNT_BYTES);
-    OPENSSL_assert(md_block_size &lt;= MAX_HASH_BLOCK_SIZE);
-    OPENSSL_assert(md_size &lt;= EVP_MAX_MD_SIZE);
+    if (!ossl_assert(md_length_size &lt;= MAX_HASH_BIT_COUNT_BYTES)
+            || !ossl_assert(md_block_size &lt;= MAX_HASH_BLOCK_SIZE)
+            || !ossl_assert(md_size &lt;= EVP_MAX_MD_SIZE))
+        return 0;
 
     header_length = 13;
     if (is_sslv3) {
@@ -331,7 +332,8 @@ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,
          */
         bits += 8 * md_block_size;
         memset(hmac_pad, 0, md_block_size);
-        OPENSSL_assert(mac_secret_length &lt;= sizeof(hmac_pad));
+        if (!ossl_assert(mac_secret_length &lt;= sizeof(hmac_pad)))
+            return 0;
         memcpy(hmac_pad, mac_secret, mac_secret_length);
         for (i = 0; i &lt; md_block_size; i++)
             hmac_pad[i] ^= 0x36;
diff --git a/ssl/s3_enc.c b/ssl/s3_enc.c
index 0d75567..1cd28ee 100644
--- a/ssl/s3_enc.c
+++ b/ssl/s3_enc.c
@@ -120,7 +120,10 @@ int ssl3_change_cipher_state(SSL *s, int which)
     c = s-&gt;s3-&gt;tmp.new_sym_enc;
     m = s-&gt;s3-&gt;tmp.new_hash;
     /* m == NULL will lead to a crash later */
-    OPENSSL_assert(m);
+    if (!ossl_assert(m != NULL)) {
+        SSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);
+        goto err2;
+    }
 #ifndef OPENSSL_NO_COMP
     if (s-&gt;s3-&gt;tmp.new_compression == NULL)
         comp = NULL;
diff --git a/ssl/s3_lib.c b/ssl/s3_lib.c
index 289dc51..2165f62 100644
--- a/ssl/s3_lib.c
+++ b/ssl/s3_lib.c
@@ -48,7 +48,6 @@
  */
 
 #include &lt;stdio.h&gt;
-#include &lt;assert.h&gt;
 #include &lt;openssl/objects.h&gt;
 #include &quot;ssl_locl.h&quot;
 #include &lt;openssl/md5.h&gt;
@@ -2914,10 +2913,13 @@ int ssl3_new(SSL *s)
     if (!SSL_SRP_CTX_init(s))
         goto err;
 #endif
-    s-&gt;method-&gt;ssl_clear(s);
-    return (1);
+
+    if (!s-&gt;method-&gt;ssl_clear(s))
+        return 0;
+
+    return 1;
  err:
-    return (0);
+    return 0;
 }
 
 void ssl3_free(SSL *s)
@@ -2950,7 +2952,7 @@ void ssl3_free(SSL *s)
     s-&gt;s3 = NULL;
 }
 
-void ssl3_clear(SSL *s)
+int ssl3_clear(SSL *s)
 {
     ssl3_cleanup_key_block(s);
     OPENSSL_free(s-&gt;s3-&gt;tmp.ctype);
@@ -2972,7 +2974,8 @@ void ssl3_clear(SSL *s)
     /* NULL/zero-out everything in the s3 struct */
     memset(s-&gt;s3, 0, sizeof(*s-&gt;s3));
 
-    ssl_free_wbio_buffer(s);
+    if (!ssl_free_wbio_buffer(s))
+        return 0;
 
     s-&gt;version = SSL3_VERSION;
 
@@ -2981,6 +2984,8 @@ void ssl3_clear(SSL *s)
     s-&gt;ext.npn = NULL;
     s-&gt;ext.npn_len = 0;
 #endif
+
+    return 1;
 }
 
 #ifndef OPENSSL_NO_SRP
@@ -4038,7 +4043,9 @@ int ssl_fill_hello_random(SSL *s, int server, unsigned char *result, size_t len,
     }
 #ifndef OPENSSL_NO_TLS13DOWNGRADE
     if (ret) {
-        assert(sizeof(tls11downgrade) &lt; len &amp;&amp; sizeof(tls12downgrade) &lt; len);
+        if (!ossl_assert(sizeof(tls11downgrade) &lt; len)
+                || !ossl_assert(sizeof(tls12downgrade) &lt; len))
+             return 0;
         if (dgrd == DOWNGRADE_TO_1_2)
             memcpy(result + len - sizeof(tls12downgrade), tls12downgrade,
                    sizeof(tls12downgrade));
diff --git a/ssl/ssl_ciph.c b/ssl/ssl_ciph.c
index be33ff3..f05e86f 100644
--- a/ssl/ssl_ciph.c
+++ b/ssl/ssl_ciph.c
@@ -371,7 +371,7 @@ static uint32_t disabled_mac_mask;
 static uint32_t disabled_mkey_mask;
 static uint32_t disabled_auth_mask;
 
-void ssl_load_ciphers(void)
+int ssl_load_ciphers(void)
 {
     size_t i;
     const ssl_cipher_table *t;
@@ -396,13 +396,16 @@ void ssl_load_ciphers(void)
             disabled_mac_mask |= t-&gt;mask;
         } else {
             int tmpsize = EVP_MD_size(md);
-            OPENSSL_assert(tmpsize &gt;= 0);
+            if (!ossl_assert(tmpsize &gt;= 0))
+                return 0;
             ssl_mac_secret_size[i] = tmpsize;
         }
     }
     /* Make sure we can access MD5 and SHA1 */
-    OPENSSL_assert(ssl_digest_methods[SSL_MD_MD5_IDX] != NULL);
-    OPENSSL_assert(ssl_digest_methods[SSL_MD_SHA1_IDX] != NULL);
+    if (!ossl_assert(ssl_digest_methods[SSL_MD_MD5_IDX] != NULL))
+        return 0;
+    if (!ossl_assert(ssl_digest_methods[SSL_MD_SHA1_IDX] != NULL))
+        return 0;
 
     disabled_mkey_mask = 0;
     disabled_auth_mask = 0;
@@ -460,6 +463,8 @@ void ssl_load_ciphers(void)
     if ((disabled_auth_mask &amp; (SSL_aGOST01 | SSL_aGOST12)) ==
         (SSL_aGOST01 | SSL_aGOST12))
         disabled_mkey_mask |= SSL_kGOST;
+
+    return 1;
 }
 
 #ifndef OPENSSL_NO_COMP
diff --git a/ssl/ssl_err.c b/ssl/ssl_err.c
index f7de9f6..e334b00 100644
--- a/ssl/ssl_err.c
+++ b/ssl/ssl_err.c
@@ -46,6 +46,7 @@ static ERR_STRING_DATA SSL_str_functs[] = {
     {ERR_FUNC(SSL_F_DTLS1_RETRANSMIT_MESSAGE), &quot;dtls1_retransmit_message&quot;},
     {ERR_FUNC(SSL_F_DTLS1_WRITE_APP_DATA_BYTES),
      &quot;dtls1_write_app_data_bytes&quot;},
+    {ERR_FUNC(SSL_F_DTLS1_WRITE_BYTES), &quot;dtls1_write_bytes&quot;},
     {ERR_FUNC(SSL_F_DTLSV1_LISTEN), &quot;DTLSv1_listen&quot;},
     {ERR_FUNC(SSL_F_DTLS_CONSTRUCT_CHANGE_CIPHER_SPEC),
      &quot;dtls_construct_change_cipher_spec&quot;},
diff --git a/ssl/ssl_init.c b/ssl/ssl_init.c
index b286a98..478a48e 100644
--- a/ssl/ssl_init.c
+++ b/ssl/ssl_init.c
@@ -12,7 +12,6 @@
 #include &quot;internal/err.h&quot;
 #include &lt;openssl/crypto.h&gt;
 #include &lt;openssl/evp.h&gt;
-#include &lt;assert.h&gt;
 #include &quot;ssl_locl.h&quot;
 #include &quot;internal/thread_once.h&quot;
 
@@ -96,7 +95,8 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_ssl_base)
     SSL_COMP_get_compression_methods();
 #endif
     /* initialize cipher/digest methods table */
-    ssl_load_ciphers();
+    if (!ssl_load_ciphers())
+        return 0;
 
 #ifdef OPENSSL_INIT_DEBUG
     fprintf(stderr, &quot;OPENSSL_INIT: ossl_init_ssl_base: &quot;
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index de63f84..028b69d 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -39,7 +39,6 @@
  * OTHERWISE.
  */
 
-#include &lt;assert.h&gt;
 #include &lt;stdio.h&gt;
 #include &quot;ssl_locl.h&quot;
 #include &lt;openssl/objects.h&gt;
@@ -443,7 +442,7 @@ int SSL_clear(SSL *s)
 {
     if (s-&gt;method == NULL) {
         SSLerr(SSL_F_SSL_CLEAR, SSL_R_NO_METHOD_SPECIFIED);
-        return (0);
+        return 0;
     }
 
     if (ssl_clear_bad_session(s)) {
@@ -492,13 +491,15 @@ int SSL_clear(SSL *s)
         s-&gt;method-&gt;ssl_free(s);
         s-&gt;method = s-&gt;ctx-&gt;method;
         if (!s-&gt;method-&gt;ssl_new(s))
-            return (0);
-    } else
-        s-&gt;method-&gt;ssl_clear(s);
+            return 0;
+    } else {
+        if (!s-&gt;method-&gt;ssl_clear(s))
+            return 0;
+    }
 
     RECORD_LAYER_clear(&amp;s-&gt;rlayer);
 
-    return (1);
+    return 1;
 }
 
 /** Used to change an SSL_CTXs default SSL method type */
@@ -575,7 +576,8 @@ SSL *SSL_new(SSL_CTX *ctx)
     s-&gt;record_padding_arg = ctx-&gt;record_padding_arg;
     s-&gt;block_padding = ctx-&gt;block_padding;
     s-&gt;sid_ctx_length = ctx-&gt;sid_ctx_length;
-    OPENSSL_assert(s-&gt;sid_ctx_length &lt;= sizeof s-&gt;sid_ctx);
+    if (!ossl_assert(s-&gt;sid_ctx_length &lt;= sizeof s-&gt;sid_ctx))
+        goto err;
     memcpy(&amp;s-&gt;sid_ctx, &amp;ctx-&gt;sid_ctx, sizeof(s-&gt;sid_ctx));
     s-&gt;verify_callback = ctx-&gt;default_verify_callback;
     s-&gt;generate_session_id = ctx-&gt;generate_session_id;
@@ -980,6 +982,7 @@ void SSL_free(SSL *s)
     dane_final(&amp;s-&gt;dane);
     CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL, s, &amp;s-&gt;ex_data);
 
+    /* Ignore return value */
     ssl_free_wbio_buffer(s);
 
     BIO_free_all(s-&gt;wbio);
@@ -3528,16 +3531,19 @@ int ssl_init_wbio_buffer(SSL *s)
     return 1;
 }
 
-void ssl_free_wbio_buffer(SSL *s)
+int ssl_free_wbio_buffer(SSL *s)
 {
     /* callers ensure s is never null */
     if (s-&gt;bbio == NULL)
-        return;
+        return 1;
 
     s-&gt;wbio = BIO_pop(s-&gt;wbio);
-    assert(s-&gt;wbio != NULL);
+    if (!ossl_assert(s-&gt;wbio != NULL))
+        return 0;
     BIO_free(s-&gt;bbio);
     s-&gt;bbio = NULL;
+
+    return 1;
 }
 
 void SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx, int mode)
@@ -3609,7 +3615,8 @@ SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX *ctx)
      * Program invariant: |sid_ctx| has fixed size (SSL_MAX_SID_CTX_LENGTH),
      * so setter APIs must prevent invalid lengths from entering the system.
      */
-    OPENSSL_assert(ssl-&gt;sid_ctx_length &lt;= sizeof(ssl-&gt;sid_ctx));
+    if (!ossl_assert(ssl-&gt;sid_ctx_length &lt;= sizeof(ssl-&gt;sid_ctx)))
+        return NULL;
 
     /*
      * If the session ID context matches that of the parent SSL_CTX,
diff --git a/ssl/ssl_locl.h b/ssl/ssl_locl.h
index f113854..fe7f7b4 100644
--- a/ssl/ssl_locl.h
+++ b/ssl/ssl_locl.h
@@ -452,7 +452,7 @@ struct ssl_method_st {
     unsigned flags;
     unsigned long mask;
     int (*ssl_new) (SSL *s);
-    void (*ssl_clear) (SSL *s);
+    int (*ssl_clear) (SSL *s);
     void (*ssl_free) (SSL *s);
     int (*ssl_accept) (SSL *s);
     int (*ssl_connect) (SSL *s);
@@ -2136,7 +2136,7 @@ void ssl_set_masks(SSL *s);
 __owur STACK_OF(SSL_CIPHER) *ssl_get_ciphers_by_id(SSL *s);
 __owur int ssl_verify_alarm_type(long type);
 void ssl_sort_cipher_list(void);
-void ssl_load_ciphers(void);
+int ssl_load_ciphers(void);
 __owur int ssl_fill_hello_random(SSL *s, int server, unsigned char *field,
                                  size_t len, DOWNGRADE dgrd);
 __owur int ssl_generate_master_secret(SSL *s, unsigned char *pms, size_t pmslen,
@@ -2181,7 +2181,7 @@ __owur int ssl3_read(SSL *s, void *buf, size_t len, size_t *readbytes);
 __owur int ssl3_peek(SSL *s, void *buf, size_t len, size_t *readbytes);
 __owur int ssl3_write(SSL *s, const void *buf, size_t len, size_t *written);
 __owur int ssl3_shutdown(SSL *s);
-void ssl3_clear(SSL *s);
+int ssl3_clear(SSL *s);
 __owur long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg);
 __owur long ssl3_ctx_ctrl(SSL_CTX *s, int cmd, long larg, void *parg);
 __owur long ssl3_callback_ctrl(SSL *s, int cmd, void (*fp) (void));
@@ -2246,20 +2246,20 @@ __owur int dtls1_query_mtu(SSL *s);
 
 __owur int tls1_new(SSL *s);
 void tls1_free(SSL *s);
-void tls1_clear(SSL *s);
+int tls1_clear(SSL *s);
 long tls1_ctrl(SSL *s, int cmd, long larg, void *parg);
 long tls1_callback_ctrl(SSL *s, int cmd, void (*fp) (void));
 
 __owur int dtls1_new(SSL *s);
 void dtls1_free(SSL *s);
-void dtls1_clear(SSL *s);
+int dtls1_clear(SSL *s);
 long dtls1_ctrl(SSL *s, int cmd, long larg, void *parg);
 __owur int dtls1_shutdown(SSL *s);
 
 __owur int dtls1_dispatch_alert(SSL *s);
 
 __owur int ssl_init_wbio_buffer(SSL *s);
-void ssl_free_wbio_buffer(SSL *s);
+int ssl_free_wbio_buffer(SSL *s);
 
 __owur int tls1_change_cipher_state(SSL *s, int which);
 __owur int tls1_setup_key_block(SSL *s);
diff --git a/ssl/statem/extensions_clnt.c b/ssl/statem/extensions_clnt.c
index c5f8d3d..8aa795e 100644
--- a/ssl/statem/extensions_clnt.c
+++ b/ssl/statem/extensions_clnt.c
@@ -7,7 +7,6 @@
  * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
  */
 
-#include &lt;assert.h&gt;
 #include &lt;openssl/ocsp.h&gt;
 #include &quot;../ssl_locl.h&quot;
 #include &quot;statem_locl.h&quot;
@@ -541,8 +540,7 @@ static int add_key_share(SSL *s, WPACKET *pkt, unsigned int curve_id)
     size_t encodedlen;
 
     if (s-&gt;s3-&gt;tmp.pkey != NULL) {
-        assert(s-&gt;hello_retry_request);
-        if (!s-&gt;hello_retry_request) {
+        if (!ossl_assert(s-&gt;hello_retry_request)) {
             SSLerr(SSL_F_ADD_KEY_SHARE, ERR_R_INTERNAL_ERROR);
             return 0;
         }
@@ -923,8 +921,13 @@ int tls_parse_stoc_renegotiate(SSL *s, PACKET *pkt, unsigned int context,
     const unsigned char *data;
 
     /* Check for logic errors */
-    assert(expected_len == 0 || s-&gt;s3-&gt;previous_client_finished_len != 0);
-    assert(expected_len == 0 || s-&gt;s3-&gt;previous_server_finished_len != 0);
+    if (!ossl_assert(expected_len == 0
+                     || s-&gt;s3-&gt;previous_client_finished_len != 0)
+        || !ossl_assert(expected_len == 0
+                        || s-&gt;s3-&gt;previous_server_finished_len != 0)) {
+        *al = SSL_AD_INTERNAL_ERROR;
+        return 0;
+    }
 
     /* Parse the length byte */
     if (!PACKET_get_1_len(pkt, &amp;ilen)) {
diff --git a/ssl/statem/extensions_cust.c b/ssl/statem/extensions_cust.c
index e06fa9d..cd63d04 100644
--- a/ssl/statem/extensions_cust.c
+++ b/ssl/statem/extensions_cust.c
@@ -9,7 +9,6 @@
 
 /* Custom extension utility functions */
 
-#include &lt;assert.h&gt;
 #include &lt;openssl/ct.h&gt;
 #include &quot;../ssl_locl.h&quot;
 #include &quot;statem_locl.h&quot;
@@ -217,7 +216,10 @@ int custom_ext_add(SSL *s, int context, WPACKET *pkt, X509 *x, size_t chainidx,
             /*
              * We can't send duplicates: code logic should prevent this.
              */
-            assert((meth-&gt;ext_flags &amp; SSL_EXT_FLAG_SENT) == 0);
+            if (!ossl_assert((meth-&gt;ext_flags &amp; SSL_EXT_FLAG_SENT) == 0)) {
+                *al = SSL_AD_INTERNAL_ERROR;
+                return 0;
+            }
             /*
              * Indicate extension has been sent: this is both a sanity check to
              * ensure we don't send duplicate extensions and indicates that it
diff --git a/ssl/statem/statem_dtls.c b/ssl/statem/statem_dtls.c
index 5cab355..83bd8d3 100644
--- a/ssl/statem/statem_dtls.c
+++ b/ssl/statem/statem_dtls.c
@@ -32,7 +32,6 @@
 
 #define RSMBLY_BITMASK_IS_COMPLETE(bitmask, msg_len, is_complete) { \
                         long ii; \
-                        OPENSSL_assert((msg_len) &gt; 0); \
                         is_complete = 1; \
                         if (bitmask[(((msg_len) - 1) &gt;&gt; 3)] != bitmask_end_values[((msg_len) &amp; 7)]) is_complete = 0; \
                         if (is_complete) for (ii = (((msg_len) - 1) &gt;&gt; 3) - 1; ii &gt;= 0 ; ii--) \
@@ -122,9 +121,11 @@ int dtls1_do_write(SSL *s, int type)
         /* should have something reasonable now */
         return -1;
 
-    if (s-&gt;init_off == 0 &amp;&amp; type == SSL3_RT_HANDSHAKE)
-        OPENSSL_assert(s-&gt;init_num ==
-                       s-&gt;d1-&gt;w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH);
+    if (s-&gt;init_off == 0 &amp;&amp; type == SSL3_RT_HANDSHAKE) {
+        if (!ossl_assert(s-&gt;init_num ==
+                         s-&gt;d1-&gt;w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH))
+            return -1;
+    }
 
     if (s-&gt;write_hash) {
         if (s-&gt;enc_write_ctx
@@ -254,7 +255,7 @@ int dtls1_do_write(SSL *s, int type)
                 } else
                     return -1;
             } else {
-                return (-1);
+                return -1;
             }
         } else {
 
@@ -262,7 +263,8 @@ int dtls1_do_write(SSL *s, int type)
              * bad if this assert fails, only part of the handshake message
              * got sent.  but why would this happen?
              */
-            OPENSSL_assert(len == written);
+            if (!ossl_assert(len == written))
+                return -1;
 
             if (type == SSL3_RT_HANDSHAKE &amp;&amp; !s-&gt;d1-&gt;retransmitting) {
                 /*
@@ -578,6 +580,8 @@ dtls1_reassemble_fragment(SSL *s, const struct hm_header_st *msg_hdr)
     RSMBLY_BITMASK_MARK(frag-&gt;reassembly, (long)msg_hdr-&gt;frag_off,
                         (long)(msg_hdr-&gt;frag_off + frag_len));
 
+    if (!ossl_assert(msg_hdr-&gt;msg_len &gt; 0))
+        goto err;
     RSMBLY_BITMASK_IS_COMPLETE(frag-&gt;reassembly, (long)msg_hdr-&gt;msg_len,
                                is_complete);
 
@@ -600,7 +604,8 @@ dtls1_reassemble_fragment(SSL *s, const struct hm_header_st *msg_hdr)
          * would have returned it and control would never have reached this
          * branch.
          */
-        OPENSSL_assert(item != NULL);
+        if (!ossl_assert(item != NULL))
+            goto err;
     }
 
     return DTLS1_HM_FRAGMENT_RETRY;
@@ -697,7 +702,8 @@ dtls1_process_out_of_seq_message(SSL *s, const struct hm_header_st *msg_hdr)
          * have been processed with |dtls1_reassemble_fragment|, above, or
          * the record will have been discarded.
          */
-        OPENSSL_assert(item != NULL);
+        if (!ossl_assert(item != NULL))
+            goto err;
     }
 
     return DTLS1_HM_FRAGMENT_RETRY;
@@ -981,7 +987,8 @@ int dtls1_buffer_message(SSL *s, int is_ccs)
      * this function is called immediately after a message has been
      * serialized
      */
-    OPENSSL_assert(s-&gt;init_off == 0);
+    if (!ossl_assert(s-&gt;init_off == 0))
+        return 0;
 
     frag = dtls1_hm_fragment_new(s-&gt;init_num, 0);
     if (frag == NULL)
@@ -991,13 +998,15 @@ int dtls1_buffer_message(SSL *s, int is_ccs)
 
     if (is_ccs) {
         /* For DTLS1_BAD_VER the header length is non-standard */
-        OPENSSL_assert(s-&gt;d1-&gt;w_msg_hdr.msg_len +
-                       ((s-&gt;version ==
-                         DTLS1_BAD_VER) ? 3 : DTLS1_CCS_HEADER_LENGTH)
-                       == (unsigned int)s-&gt;init_num);
+        if (!ossl_assert(s-&gt;d1-&gt;w_msg_hdr.msg_len +
+                         ((s-&gt;version ==
+                           DTLS1_BAD_VER) ? 3 : DTLS1_CCS_HEADER_LENGTH)
+                         == (unsigned int)s-&gt;init_num))
+            return 0;
     } else {
-        OPENSSL_assert(s-&gt;d1-&gt;w_msg_hdr.msg_len +
-                       DTLS1_HM_HEADER_LENGTH == (unsigned int)s-&gt;init_num);
+        if (!ossl_assert(s-&gt;d1-&gt;w_msg_hdr.msg_len +
+                         DTLS1_HM_HEADER_LENGTH == (unsigned int)s-&gt;init_num))
+            return 0;
     }
 
     frag-&gt;msg_header.msg_len = s-&gt;d1-&gt;w_msg_hdr.msg_len;
@@ -1045,11 +1054,6 @@ int dtls1_retransmit_message(SSL *s, unsigned short seq, int *found)
     unsigned char seq64be[8];
     struct dtls1_retransmit_state saved_state;
 
-    /*-
-      OPENSSL_assert(s-&gt;init_num == 0);
-      OPENSSL_assert(s-&gt;init_off == 0);
-     */
-
     /* XDTLS:  the requested message ought to be found, otherwise error */
     memset(seq64be, 0, sizeof(seq64be));
     seq64be[6] = (unsigned char)(seq &gt;&gt; 8);
diff --git a/ssl/statem/statem_lib.c b/ssl/statem/statem_lib.c
index e6f6293..fbf5a3c 100644
--- a/ssl/statem/statem_lib.c
+++ b/ssl/statem/statem_lib.c
@@ -522,19 +522,23 @@ int tls_construct_finished(SSL *s, WPACKET *pkt)
      */
     if (!SSL_IS_TLS13(s) &amp;&amp; !ssl_log_secret(s, MASTER_SECRET_LABEL,
                                             s-&gt;session-&gt;master_key,
-                                            s-&gt;session-&gt;master_key_length))
-        return 0;
+                                            s-&gt;session-&gt;master_key_length)) {
+        SSLerr(SSL_F_TLS_CONSTRUCT_FINISHED, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
 
     /*
      * Copy the finished so we can use it for renegotiation checks
      */
+    if (!ossl_assert(finish_md_len &lt;= EVP_MAX_MD_SIZE)) {
+        SSLerr(SSL_F_TLS_CONSTRUCT_FINISHED, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
     if (!s-&gt;server) {
-        OPENSSL_assert(finish_md_len &lt;= EVP_MAX_MD_SIZE);
         memcpy(s-&gt;s3-&gt;previous_client_finished, s-&gt;s3-&gt;tmp.finish_md,
                finish_md_len);
         s-&gt;s3-&gt;previous_client_finished_len = finish_md_len;
     } else {
-        OPENSSL_assert(finish_md_len &lt;= EVP_MAX_MD_SIZE);
         memcpy(s-&gt;s3-&gt;previous_server_finished, s-&gt;s3-&gt;tmp.finish_md,
                finish_md_len);
         s-&gt;s3-&gt;previous_server_finished_len = finish_md_len;
@@ -765,13 +769,16 @@ MSG_PROCESS_RETURN tls_process_finished(SSL *s, PACKET *pkt)
     /*
      * Copy the finished so we can use it for renegotiation checks
      */
+    if (!ossl_assert(md_len &lt;= EVP_MAX_MD_SIZE)) {
+        al = SSL_AD_INTERNAL_ERROR;
+        SSLerr(SSL_F_TLS_PROCESS_FINISHED, ERR_R_INTERNAL_ERROR);
+        goto f_err;
+    }
     if (s-&gt;server) {
-        OPENSSL_assert(md_len &lt;= EVP_MAX_MD_SIZE);
         memcpy(s-&gt;s3-&gt;previous_client_finished, s-&gt;s3-&gt;tmp.peer_finish_md,
                md_len);
         s-&gt;s3-&gt;previous_client_finished_len = md_len;
     } else {
-        OPENSSL_assert(md_len &lt;= EVP_MAX_MD_SIZE);
         memcpy(s-&gt;s3-&gt;previous_server_finished, s-&gt;s3-&gt;tmp.peer_finish_md,
                md_len);
         s-&gt;s3-&gt;previous_server_finished_len = md_len;
@@ -988,7 +995,8 @@ WORK_STATE tls_finish_handshake(SSL *s, WORK_STATE wst, int clearbufs)
             BUF_MEM_free(s-&gt;init_buf);
             s-&gt;init_buf = NULL;
         }
-        ssl_free_wbio_buffer(s);
+        if (!ssl_free_wbio_buffer(s))
+            return WORK_ERROR;
         s-&gt;init_num = 0;
     }
 
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index 232bb41..c185a09 100644
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -101,9 +101,11 @@ long tls1_default_timeout(void)
 int tls1_new(SSL *s)
 {
     if (!ssl3_new(s))
-        return (0);
-    s-&gt;method-&gt;ssl_clear(s);
-    return (1);
+        return 0;
+    if (!s-&gt;method-&gt;ssl_clear(s))
+        return 0;
+
+    return 1;
 }
 
 void tls1_free(SSL *s)
@@ -112,13 +114,17 @@ void tls1_free(SSL *s)
     ssl3_free(s);
 }
 
-void tls1_clear(SSL *s)
+int tls1_clear(SSL *s)
 {
-    ssl3_clear(s);
+    if (!ssl3_clear(s))
+        return 0;
+
     if (s-&gt;method-&gt;version == TLS_ANY_VERSION)
         s-&gt;version = TLS_MAX_VERSION;
     else
         s-&gt;version = s-&gt;method-&gt;version;
+
+    return 1;
 }
 
 #ifndef OPENSSL_NO_EC
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014744.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="014755.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14745">[ date ]</a>
              <a href="thread.html#14745">[ thread ]</a>
              <a href="subject.html#14745">[ subject ]</a>
              <a href="author.html#14745">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
