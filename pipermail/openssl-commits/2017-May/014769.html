<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2017-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1495629442.884100.22501.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014763.html">
   <LINK REL="Next"  HREF="014775.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1495629442.884100.22501.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Wed May 24 12:37:22 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="014763.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="014775.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14769">[ date ]</a>
              <a href="thread.html#14769">[ thread ]</a>
              <a href="subject.html#14769">[ subject ]</a>
              <a href="author.html#14769">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  dd5918775aeed51f8a666d151c5bd007e91bc534 (commit)
       via  c49e0b04150e7cd8e8a92cd9f46be98422ce2fc8 (commit)
      from  5a7bc0be97dee9ac715897fe8180a08e211bc6ea (commit)


- Log -----------------------------------------------------------------
commit dd5918775aeed51f8a666d151c5bd007e91bc534
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
Date:   Tue May 23 09:24:12 2017 -0400

    Fix va_arg all in test_error_c90
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3506">https://github.com/openssl/openssl/pull/3506</A>)

commit c49e0b04150e7cd8e8a92cd9f46be98422ce2fc8
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
Date:   Fri May 12 14:19:51 2017 -0400

    Revise evp_test parser; make like bn_test
    
    Re-order and comment on the functions
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3506">https://github.com/openssl/openssl/pull/3506</A>)

-----------------------------------------------------------------------

Summary of changes:
 test/evp_test.c       | 1379 +++++++++++++++++++++++++------------------------
 test/testutil/tests.c |    2 +-
 2 files changed, 714 insertions(+), 667 deletions(-)

diff --git a/test/evp_test.c b/test/evp_test.c
index 0e1781f..97ea807 100644
--- a/test/evp_test.c
+++ b/test/evp_test.c
@@ -21,160 +21,71 @@
 #include &quot;testutil.h&quot;
 #include &quot;evp_test.h&quot;
 
-static const char *current_test_file = &quot;???&quot;;
+
+typedef struct evp_test_method_st EVP_TEST_METHOD;
 
 /*
- * Remove spaces from beginning and end of a string
+ * Structure holding test information
  */
-static void remove_space(char **pval)
-{
-    unsigned char *p = (unsigned char *)*pval, *beginning;
-
-    while (isspace(*p))
-        p++;
-
-    *pval = (char *)(beginning = p);
-
-    p = p + strlen(*pval) - 1;
-
-    /* Remove trailing space */
-    while (p &gt;= beginning &amp;&amp; isspace(*p))
-        *p-- = 0;
-}
+typedef struct evp_test_st {
+    BIO *in;                      /* file being read */
+    int line;                     /* current line being processed */
+    int start_line;               /* start line of current test */
+    int ntests;                   /* Number of tests */
+    int errors;                   /* Error count */
+    int skip;                     /* Current test should be skipped */
+    int nskip;                    /* Number of tests skipped */
+    char buf[10240];              /* Input buffer */
+    BIO *key;                     /* temp memory BIO for reading in keys */
+    const EVP_TEST_METHOD *meth;  /* method for this test */
+    const char *err, *aux_err;    /* Error string for test */
+    char *expected_err;           /* Expected error value of test */
+    char *func;                   /* Expected error function string */
+    char *reason;                 /* Expected error reason string */
+    void *data;                   /* test specific data */
+} EVP_TEST;
 
 /*
- * Given a line of the form:
- *      name = value # comment
- * extract name and value. NB: modifies |linebuf|.
+ * Test method structure
  */
-static int parse_line(char **pkw, char **pval, char *linebuf)
-{
-    char *p = linebuf + strlen(linebuf) - 1;
-
-    if (*p != '\n') {
-        TEST_error(&quot;FATAL: missing EOL&quot;);
-        return 0;
-    }
-
-    /* Look for # */
-    p = strchr(linebuf, '#');
-    if (p != NULL)
-        *p = '\0';
-
-    /* Look for = sign */
-    if ((p = strchr(linebuf, '=')) == NULL)
-        return 0;
-    *p++ = '\0';
+struct evp_test_method_st {
+    /* Name of test as it appears in file */
+    const char *name;
+    /* Initialise test for &quot;alg&quot; */
+    int (*init) (EVP_TEST * t, const char *alg);
+    /* Clean up method */
+    void (*cleanup) (EVP_TEST * t);
+    /* Test specific name value pair processing */
+    int (*parse) (EVP_TEST * t, const char *name, const char *value);
+    /* Run the test itself */
+    int (*run_test) (EVP_TEST * t);
+};
 
-    *pkw = linebuf;
-    *pval = p;
-    remove_space(pkw);
-    remove_space(pval);
-    return 1;
-}
 
 /*
- * Unescape some escape sequences in string literals.
- * Return the result in a newly allocated buffer.
- * Currently only supports '\n'.
- * If the input length is 0, returns a valid 1-byte buffer, but sets
- * the length to 0.
+ * Linked list of named keys.
  */
-static unsigned char* unescape(const char *input, size_t input_len,
-                               size_t *out_len)
-{
-    unsigned char *ret, *p;
-    size_t i;
-
-    if (input_len == 0) {
-        *out_len = 0;
-        return OPENSSL_zalloc(1);
-    }
-
-    /* Escaping is non-expanding; over-allocate original size for simplicity. */
-    ret = p = OPENSSL_malloc(input_len);
-    if (ret == NULL)
-        return NULL;
-
-    for (i = 0; i &lt; input_len; i++) {
-        if (input[i] == '\\') {
-            if (i == input_len - 1 || input[i+1] != 'n')
-                goto err;
-            *p++ = '\n';
-            i++;
-        } else {
-            *p++ = input[i];
-        }
-    }
-
-    *out_len = p - ret;
-    return ret;
-
- err:
-    OPENSSL_free(ret);
-    return NULL;
-}
-
-/* For a hex string &quot;value&quot; convert to a binary allocated buffer */
-static int test_bin(const char *value, unsigned char **buf, size_t *buflen)
-{
-    long len;
-
-    *buflen = 0;
-
-    /* Check for empty value */
-    if (!*value) {
-        /*
-         * Don't return NULL for zero length buffer.
-         * This is needed for some tests with empty keys: HMAC_Init_ex() expects
-         * a non-NULL key buffer even if the key length is 0, in order to detect
-         * key reset.
-         */
-        *buf = OPENSSL_malloc(1);
-        if (!*buf)
-            return 0;
-        **buf = 0;
-        *buflen = 0;
-        return 1;
-    }
+typedef struct key_list_st {
+    char *name;
+    EVP_PKEY *key;
+    struct key_list_st *next;
+} KEY_LIST;
 
-    /* Check for NULL literal */
-    if (strcmp(value, &quot;NULL&quot;) == 0) {
-        *buf = NULL;
-        *buflen = 0;
-        return 1;
-    }
+/*
+ * List of public and private keys
+ */
+static KEY_LIST *private_keys;
+static KEY_LIST *public_keys;
+static int find_key(EVP_PKEY **ppk, const char *name, KEY_LIST *lst);
 
-    /* Check for string literal */
-    if (value[0] == '&quot;') {
-        size_t vlen;
-        value++;
-        vlen = strlen(value);
-        if (value[vlen - 1] != '&quot;')
-            return 0;
-        vlen--;
-        *buf = unescape(value, vlen, buflen);
-        if (*buf == NULL)
-            return 0;
-        return 1;
-    }
+static int parse_bin(const char *value, unsigned char **buf, size_t *buflen);
 
-    /* Otherwise assume as hex literal and convert it to binary buffer */
-    if (!TEST_ptr(*buf = OPENSSL_hexstr2buf(value, &amp;len))) {
-        TEST_info(&quot;Cannot convert %s&quot;, value);
-        ERR_print_errors(bio_err);
-        return -1;
-    }
-    /* Size of input buffer means we'll never overflow */
-    *buflen = len;
-    return 1;
-}
+static const char *current_test_file = &quot;???&quot;;
 
 /*
  * Structure used to hold a list of blocks of memory to test
  * calls to &quot;update&quot; like functions.
  */
-
 struct evp_test_buffer_st {
     unsigned char *buf;
     size_t buflen;
@@ -190,8 +101,9 @@ static void evp_test_buffer_free(EVP_TEST_BUFFER *db)
     }
 }
 
-/* append buffer to a list */
-
+/*
+ * append buffer to a list
+ */
 static int evp_test_buffer_append(const char *value,
                                   STACK_OF(EVP_TEST_BUFFER) **sk)
 {
@@ -200,22 +112,20 @@ static int evp_test_buffer_append(const char *value,
     if (!TEST_ptr(db = OPENSSL_malloc(sizeof(*db))))
         goto err;
 
-    if (!test_bin(value, &amp;db-&gt;buf, &amp;db-&gt;buflen))
+    if (!parse_bin(value, &amp;db-&gt;buf, &amp;db-&gt;buflen))
         goto err;
     db-&gt;count = 1;
     db-&gt;count_set = 0;
 
     if (*sk == NULL &amp;&amp; !TEST_ptr(*sk = sk_EVP_TEST_BUFFER_new_null()))
-            goto err;
-
+        goto err;
     if (!sk_EVP_TEST_BUFFER_push(*sk, db))
         goto err;
 
     return 1;
 
-    err:
+err:
     evp_test_buffer_free(db);
-
     return 0;
 }
 
@@ -249,7 +159,9 @@ static int evp_test_buffer_ncopy(const char *value,
     return 1;
 }
 
-/* set repeat count for last buffer in list */
+/*
+ * set repeat count for last buffer in list
+ */
 static int evp_test_buffer_set_count(const char *value,
                                      STACK_OF(EVP_TEST_BUFFER) *sk)
 {
@@ -263,7 +175,7 @@ static int evp_test_buffer_set_count(const char *value,
         return 0;
 
     db = sk_EVP_TEST_BUFFER_value(sk, sk_EVP_TEST_BUFFER_num(sk) - 1);
-    if (db-&gt;count_set)
+    if (db-&gt;count_set != 0)
         return 0;
 
     db-&gt;count = (size_t)count;
@@ -294,34 +206,6 @@ static int evp_test_buffer_do(STACK_OF(EVP_TEST_BUFFER) *sk,
     return 1;
 }
 
-#ifndef OPENSSL_NO_SCRYPT
-/* Currently only used by scrypt tests */
-/* Parse unsigned decimal 64 bit integer value */
-static int test_uint64(const char *value, uint64_t *pr)
-{
-    const char *p = value;
-
-    if (!TEST_true(*p)) {
-        TEST_info(&quot;Invalid empty integer value&quot;);
-        return -1;
-    }
-    *pr = 0;
-    while (*p) {
-        if (*pr &gt; UINT64_MAX / 10) {
-            TEST_error(&quot;Integer overflow in string %s&quot;, value);
-            return -1;
-        }
-        *pr *= 10;
-        if (!TEST_true(isdigit(*p))) {
-            TEST_error(&quot;Invalid character in string %s&quot;, value);
-            return -1;
-        }
-        *pr += *p - '0';
-        p++;
-    }
-    return 1;
-}
-
 static int compare_mem(unsigned char *expected, size_t expected_len,
                        unsigned char *got, size_t  got_len)
 {
@@ -329,417 +213,105 @@ static int compare_mem(unsigned char *expected, size_t expected_len,
         return 0;
     return 1;
 }
-#endif
-
-typedef struct evp_test_method_st EVP_TEST_METHOD;
-
-/* Structure holding test information */
-typedef struct evp_test_st {
-    /* file being read */
-    BIO *in;
-    /* temp memory BIO for reading in keys */
-    BIO *key;
-    /* method for this test */
-    const EVP_TEST_METHOD *meth;
-    /* current line being processed */
-    unsigned int line;
-    /* start line of current test */
-    unsigned int start_line;
-    /* Error string for test */
-    const char *err, *aux_err;
-    /* Expected error value of test */
-    char *expected_err;
-    /* Expected error function string */
-    char *func;
-    /* Expected error reason string */
-    char *reason;
-    /* Number of tests */
-    int ntests;
-    /* Error count */
-    int errors;
-    /* Number of tests skipped */
-    int nskip;
-    /* test specific data */
-    void *data;
-    /* Current test should be skipped */
-    int skip;
-} EVP_TEST;
 
 /*
- * Linked list of named keys.
+ * Unescape some sequences in string literals (only \n for now).
+ * Return an allocated buffer, set |out_len|.  If |input_len|
+ * is zero, get an empty buffer but set length to zero.
  */
-typedef struct key_list_st {
-    char *name;
-    EVP_PKEY *key;
-    struct key_list_st *next;
-} KEY_LIST;
-
-/* List of public and private keys */
-static KEY_LIST *private_keys;
-static KEY_LIST *public_keys;
+static unsigned char* unescape(const char *input, size_t input_len,
+                               size_t *out_len)
+{
+    unsigned char *ret, *p;
+    size_t i;
 
-/*
- * Test method structure
- */
-struct evp_test_method_st {
-    /* Name of test as it appears in file */
-    const char *name;
-    /* Initialise test for &quot;alg&quot; */
-    int (*init) (EVP_TEST * t, const char *alg);
-    /* Clean up method */
-    void (*cleanup) (EVP_TEST * t);
-    /* Test specific name value pair processing */
-    int (*parse) (EVP_TEST * t, const char *name, const char *value);
-    /* Run the test itself */
-    int (*run_test) (EVP_TEST * t);
-};
+    if (input_len == 0) {
+        *out_len = 0;
+        return OPENSSL_zalloc(1);
+    }
 
-static const EVP_TEST_METHOD digest_test_method, cipher_test_method;
-static const EVP_TEST_METHOD mac_test_method;
-static const EVP_TEST_METHOD psign_test_method, pverify_test_method;
-static const EVP_TEST_METHOD pdecrypt_test_method;
-static const EVP_TEST_METHOD pverify_recover_test_method;
-static const EVP_TEST_METHOD pderive_test_method;
-static const EVP_TEST_METHOD pbe_test_method;
-static const EVP_TEST_METHOD encode_test_method;
-static const EVP_TEST_METHOD kdf_test_method;
-static const EVP_TEST_METHOD keypair_test_method;
-static const EVP_TEST_METHOD digestsign_test_method;
-static const EVP_TEST_METHOD digestverify_test_method;
-static const EVP_TEST_METHOD oneshot_digestsign_test_method;
-static const EVP_TEST_METHOD oneshot_digestverify_test_method;
+    /* Escaping is non-expanding; over-allocate original size for simplicity. */
+    if (!TEST_ptr(ret = p = OPENSSL_malloc(input_len)))
+        return NULL;
 
-static const EVP_TEST_METHOD *evp_test_list[] = {
-    &amp;digest_test_method,
-    &amp;cipher_test_method,
-    &amp;mac_test_method,
-    &amp;psign_test_method,
-    &amp;pverify_test_method,
-    &amp;pdecrypt_test_method,
-    &amp;pverify_recover_test_method,
-    &amp;pderive_test_method,
-    &amp;pbe_test_method,
-    &amp;encode_test_method,
-    &amp;kdf_test_method,
-    &amp;keypair_test_method,
-    &amp;digestsign_test_method,
-    &amp;digestverify_test_method,
-    &amp;oneshot_digestsign_test_method,
-    &amp;oneshot_digestverify_test_method,
-    NULL
-};
+    for (i = 0; i &lt; input_len; i++) {
+        if (*input == '\\') {
+            if (i == input_len - 1 || *++input != 'n') {
+                TEST_error(&quot;Bad escape sequence in file&quot;);
+                goto err;
+            }
+            *p++ = '\n';
+            i++;
+            input++;
+        } else {
+            *p++ = *input++;
+        }
+    }
 
-static const EVP_TEST_METHOD *evp_find_test(const char *name)
-{
-    const EVP_TEST_METHOD **tt;
+    *out_len = p - ret;
+    return ret;
 
-    for (tt = evp_test_list; *tt; tt++) {
-        if (strcmp(name, (*tt)-&gt;name) == 0)
-            return *tt;
-    }
+ err:
+    OPENSSL_free(ret);
     return NULL;
 }
 
-static void clear_test(EVP_TEST *t)
-{
-    OPENSSL_free(t-&gt;expected_err);
-    t-&gt;expected_err = NULL;
-    OPENSSL_free(t-&gt;func);
-    t-&gt;func = NULL;
-    OPENSSL_free(t-&gt;reason);
-    t-&gt;reason = NULL;
-    /* Text literal. */
-    t-&gt;err = NULL;
-}
-
 /*
- * Check for errors in the test structure; return 1 if okay, else 0.
+ * For a hex string &quot;value&quot; convert to a binary allocated buffer.
+ * Return 1 on success or 0 on failure.
  */
-static int check_test_error(EVP_TEST *t)
+static int parse_bin(const char *value, unsigned char **buf, size_t *buflen)
 {
-    unsigned long err;
-    const char *func;
-    const char *reason;
+    long len;
 
-    if (t-&gt;err == NULL &amp;&amp; t-&gt;expected_err == NULL)
+    /* Check for NULL literal */
+    if (strcmp(value, &quot;NULL&quot;) == 0) {
+        *buf = NULL;
+        *buflen = 0;
         return 1;
-    if (t-&gt;err != NULL &amp;&amp; t-&gt;expected_err == NULL) {
-        if (t-&gt;aux_err != NULL) {
-            TEST_info(&quot;Above error from the test at %s:%d &quot;
-                      &quot;(%s) unexpected error %s&quot;,
-                      current_test_file, t-&gt;start_line, t-&gt;aux_err, t-&gt;err);
-        } else {
-            TEST_info(&quot;Above error from the test at %s:%d &quot;
-                      &quot;unexpected error %s&quot;,
-                      current_test_file, t-&gt;start_line, t-&gt;err);
-        }
-        clear_test(t);
-        return 0;
-    }
-    if (t-&gt;err == NULL &amp;&amp; t-&gt;expected_err != NULL) {
-        TEST_info(&quot;Test line %d: succeeded expecting %s&quot;,
-                  t-&gt;start_line, t-&gt;expected_err);
-        return 0;
-    }
-
-    if (strcmp(t-&gt;err, t-&gt;expected_err) != 0) {
-        TEST_info(&quot;Test line %d: expecting %s got %s&quot;,
-                  t-&gt;start_line, t-&gt;expected_err, t-&gt;err);
-        return 0;
-    }
-
-    if (t-&gt;func == NULL &amp;&amp; t-&gt;reason == NULL)
-        return 1;
-
-    if (t-&gt;func == NULL || t-&gt;reason == NULL) {
-        TEST_info(&quot;Test line %d: missing function or reason code&quot;,
-                  t-&gt;start_line);
-        return 0;
-    }
-
-    err = ERR_peek_error();
-    if (err == 0) {
-        TEST_info(&quot;Test line %d, expected error \&quot;%s:%s\&quot; not set&quot;,
-                  t-&gt;start_line, t-&gt;func, t-&gt;reason);
-        return 0;
-    }
-
-    func = ERR_func_error_string(err);
-    reason = ERR_reason_error_string(err);
-    if (func == NULL &amp;&amp; reason == NULL) {
-        TEST_info(&quot;Test line %d: expected error \&quot;%s:%s\&quot;,&quot;
-                  &quot; no strings available.  Skipping...\n&quot;,
-                  t-&gt;start_line, t-&gt;func, t-&gt;reason);
-        return 1;
-    }
-
-    if (strcmp(func, t-&gt;func) == 0 &amp;&amp; strcmp(reason, t-&gt;reason) == 0)
-        return 1;
-
-    TEST_info(&quot;Test line %d: expected error \&quot;%s:%s\&quot;, got \&quot;%s:%s\&quot;&quot;,
-              t-&gt;start_line, t-&gt;func, t-&gt;reason, func, reason);
-
-    return 0;
-}
-
-/*
- * Setup a new test, run any existing test. Log a message and return 0
- * on error.
- */
-static int run_and_get_next(EVP_TEST *t, const EVP_TEST_METHOD *tmeth)
-{
-    /* If we already have a test set up run it */
-    if (t-&gt;meth) {
-        t-&gt;ntests++;
-        if (t-&gt;skip) {
-            /*TEST_info(&quot;Line %d skipped %s test&quot;, t-&gt;start_line, t-&gt;meth-&gt;name);
-             */
-            t-&gt;nskip++;
-        } else {
-            /* run the test */
-            if (t-&gt;err == NULL &amp;&amp; t-&gt;meth-&gt;run_test(t) != 1) {
-                TEST_info(&quot;Line %d error %s&quot;, t-&gt;start_line, t-&gt;meth-&gt;name);
-                return 0;
-            }
-            if (!check_test_error(t)) {
-                test_openssl_errors();
-                t-&gt;errors++;
-            }
-        }
-        /* clean it up */
-        ERR_clear_error();
-        if (t-&gt;data != NULL) {
-            t-&gt;meth-&gt;cleanup(t);
-            OPENSSL_free(t-&gt;data);
-            t-&gt;data = NULL;
-        }
-        clear_test(t);
-    }
-    t-&gt;meth = tmeth;
-    return 1;
-}
-
-static int find_key(EVP_PKEY **ppk, const char *name, KEY_LIST *lst)
-{
-    for (; lst; lst = lst-&gt;next) {
-        if (strcmp(lst-&gt;name, name) == 0) {
-            if (ppk)
-                *ppk = lst-&gt;key;
-            return 1;
-        }
-    }
-    return 0;
-}
-
-static void free_key_list(KEY_LIST *lst)
-{
-    while (lst != NULL) {
-        KEY_LIST *ltmp;
-
-        EVP_PKEY_free(lst-&gt;key);
-        OPENSSL_free(lst-&gt;name);
-        ltmp = lst-&gt;next;
-        OPENSSL_free(lst);
-        lst = ltmp;
-    }
-}
-
-static int check_unsupported()
-{
-    long err = ERR_peek_error();
-
-    if (ERR_GET_LIB(err) == ERR_LIB_EVP
-            &amp;&amp; ERR_GET_REASON(err) == EVP_R_UNSUPPORTED_ALGORITHM) {
-        ERR_clear_error();
-        return 1;
-    }
-#ifndef OPENSSL_NO_EC
-    /*
-     * If EC support is enabled we should catch also EC_R_UNKNOWN_GROUP as an
-     * hint to an unsupported algorithm/curve (e.g. if binary EC support is
-     * disabled).
-     */
-    if (ERR_GET_LIB(err) == ERR_LIB_EC
-        &amp;&amp; ERR_GET_REASON(err) == EC_R_UNKNOWN_GROUP) {
-        ERR_clear_error();
-        return 1;
-    }
-#endif /* OPENSSL_NO_EC */
-    return 0;
-}
-
-
-static int read_key(EVP_TEST *t)
-{
-    char tmpbuf[80];
-
-    if (t-&gt;key == NULL) {
-        if (!TEST_ptr(t-&gt;key = BIO_new(BIO_s_mem())))
-            return 0;
-    } else if (!TEST_int_gt(BIO_reset(t-&gt;key), 0)) {
-        return 0;
-    }
-
-    /* Read to PEM end line and place content in memory BIO */
-    while (BIO_gets(t-&gt;in, tmpbuf, sizeof(tmpbuf))) {
-        t-&gt;line++;
-        if (!TEST_int_gt(BIO_puts(t-&gt;key, tmpbuf), 0))
-            return 0;
-        if (strncmp(tmpbuf, &quot;-----END&quot;, 8) == 0)
-            return 1;
     }
-    TEST_error(&quot;Can't find key end&quot;);
-    return 0;
-}
-
-/*
- * Parse a line into the current test |t|.  Return 0 on error.
- */
-static int parse_test_line(EVP_TEST *t, char *buf)
-{
-    char *keyword = NULL, *value = NULL;
-    int add_key = 0;
-    KEY_LIST **lst = NULL, *key = NULL;
-    EVP_PKEY *pk = NULL;
-    const EVP_TEST_METHOD *tmeth = NULL;
 
-    if (!parse_line(&amp;keyword, &amp;value, buf))
-        return 1;
-    if (strcmp(keyword, &quot;PrivateKey&quot;) == 0) {
-        if (!read_key(t))
-            return 0;
-        pk = PEM_read_bio_PrivateKey(t-&gt;key, NULL, 0, NULL);
-        if (pk == NULL &amp;&amp; !check_unsupported()) {
-            TEST_info(&quot;Error reading private key %s&quot;, value);
-            ERR_print_errors_fp(stderr);
-            return 0;
-        }
-        lst = &amp;private_keys;
-        add_key = 1;
-    }
-    if (strcmp(keyword, &quot;PublicKey&quot;) == 0) {
-        if (!read_key(t))
-            return 0;
-        pk = PEM_read_bio_PUBKEY(t-&gt;key, NULL, 0, NULL);
-        if (pk == NULL &amp;&amp; !check_unsupported()) {
-            TEST_info(&quot;Error reading public key %s&quot;, value);
-            ERR_print_errors_fp(stderr);
-            return 0;
-        }
-        lst = &amp;public_keys;
-        add_key = 1;
-    }
-    /* If we have a key add to list */
-    if (add_key) {
-        if (find_key(NULL, value, *lst)) {
-            TEST_info(&quot;Duplicate key %s&quot;, value);
-            return 0;
-        }
-        if (!TEST_ptr(key = OPENSSL_malloc(sizeof(*key)))
-                || !TEST_ptr(key-&gt;name = OPENSSL_strdup(value)))
+    /* Check for empty value */
+    if (*value == '\0') {
+        /*
+         * Don't return NULL for zero length buffer. This is needed for
+         * some tests with empty keys: HMAC_Init_ex() expects a non-NULL key
+         * buffer even if the key length is 0, in order to detect key reset.
+         */
+        *buf = OPENSSL_malloc(1);
+        if (*buf == NULL)
             return 0;
-        key-&gt;key = pk;
-        key-&gt;next = *lst;
-        *lst = key;
+        **buf = 0;
+        *buflen = 0;
         return 1;
     }
 
-    /* See if keyword corresponds to a test start */
-    if ((tmeth = evp_find_test(keyword)) != NULL) {
-        if (!run_and_get_next(t, tmeth))
-            return 0;
-        t-&gt;start_line = t-&gt;line;
-        t-&gt;skip = 0;
-        if (!tmeth-&gt;init(t, value)) {
-            TEST_info(&quot;Unknown %s: %s&quot;, keyword, value);
+    /* Check for string literal */
+    if (value[0] == '&quot;') {
+        size_t vlen = strlen(++value);
+
+        if (vlen == 0 || value[vlen - 1] != '&quot;')
             return 0;
-        }
-        return 1;
+        vlen--;
+        *buf = unescape(value, vlen, buflen);
+        return *buf == NULL ? 0 : 1;
     }
-    if (t-&gt;skip)
-        return 1;
-    if (strcmp(keyword, &quot;Title&quot;) == 0) {
-        TEST_info(&quot;Starting %s tests&quot;, value);
-        set_test_title(value);
-    } else if (strcmp(keyword, &quot;Result&quot;) == 0) {
-        if (t-&gt;expected_err != NULL) {
-            TEST_info(&quot;Line %d: multiple result lines&quot;, t-&gt;line);
-            return 0;
-        }
-        if (!TEST_ptr(t-&gt;expected_err = OPENSSL_strdup(value)))
-            return 0;
-    } else if (strcmp(keyword, &quot;Function&quot;) == 0) {
-        if (t-&gt;func != NULL) {
-            TEST_info(&quot;Line %d: multiple function lines\n&quot;, t-&gt;line);
-            return 0;
-        }
-        if (!TEST_ptr(t-&gt;func = OPENSSL_strdup(value)))
-            return 0;
-    } else if (strcmp(keyword, &quot;Reason&quot;) == 0) {
-        if (t-&gt;reason != NULL) {
-            TEST_info(&quot;Line %d: multiple reason lines&quot;, t-&gt;line);
-            return 0;
-        }
-        if (!TEST_ptr(t-&gt;reason = OPENSSL_strdup(value)))
-            return 0;
-    } else {
-        /* Must be test specific line: try to parse it */
-        int rv = t-&gt;meth == NULL ? 0 : t-&gt;meth-&gt;parse(t, keyword, value);
 
-        if (rv == 0) {
-            TEST_info(&quot;Line %d: unknown keyword %s&quot;, t-&gt;line, keyword);
-            return 0;
-        }
-        if (rv &lt; 0) {
-            TEST_info(&quot;Line %d: error processing keyword %s\n&quot;,
-                      t-&gt;line, keyword);
-            return 0;
-        }
+    /* Otherwise assume as hex literal and convert it to binary buffer */
+    if (!TEST_ptr(*buf = OPENSSL_hexstr2buf(value, &amp;len))) {
+        TEST_info(&quot;Can't convert %s&quot;, value);
+        ERR_print_errors(bio_err);
+        return -1;
     }
+    /* Size of input buffer means we'll never overflow */
+    *buflen = len;
     return 1;
 }
 
-/* Message digest tests */
+
+/**
+***  MESSAGE DIGEST TESTS
+**/
 
 typedef struct digest_data_st {
     /* Digest this test is for */
@@ -753,11 +325,10 @@ typedef struct digest_data_st {
 
 static int digest_test_init(EVP_TEST *t, const char *alg)
 {
-    const EVP_MD *digest;
     DIGEST_DATA *mdat;
+    const EVP_MD *digest;
 
-    digest = EVP_get_digestbyname(alg);
-    if (!digest) {
+    if ((digest = EVP_get_digestbyname(alg)) == NULL) {
         /* If alg has an OID assume disabled algorithm */
         if (OBJ_sn2nid(alg) != NID_undef || OBJ_ln2nid(alg) != NID_undef) {
             t-&gt;skip = 1;
@@ -765,9 +336,10 @@ static int digest_test_init(EVP_TEST *t, const char *alg)
         }
         return 0;
     }
-    mdat = OPENSSL_zalloc(sizeof(*mdat));
-    mdat-&gt;digest = digest;
+    if (!TEST_ptr(mdat = OPENSSL_zalloc(sizeof(*mdat))))
+        return 0;
     t-&gt;data = mdat;
+    mdat-&gt;digest = digest;
     return 1;
 }
 
@@ -787,7 +359,7 @@ static int digest_test_parse(EVP_TEST *t,
     if (strcmp(keyword, &quot;Input&quot;) == 0)
         return evp_test_buffer_append(value, &amp;mdata-&gt;input);
     if (strcmp(keyword, &quot;Output&quot;) == 0)
-        return test_bin(value, &amp;mdata-&gt;output, &amp;mdata-&gt;output_len);
+        return parse_bin(value, &amp;mdata-&gt;output, &amp;mdata-&gt;output_len);
     if (strcmp(keyword, &quot;Count&quot;) == 0)
         return evp_test_buffer_set_count(value, mdata-&gt;input);
     if (strcmp(keyword, &quot;Ncopy&quot;) == 0)
@@ -847,7 +419,11 @@ static const EVP_TEST_METHOD digest_test_method = {
     digest_test_run
 };
 
-/* Cipher tests */
+
+/**
+***  CIPHER TESTS
+**/
+
 typedef struct cipher_data_st {
     const EVP_CIPHER *cipher;
     int enc;
@@ -871,10 +447,10 @@ typedef struct cipher_data_st {
 static int cipher_test_init(EVP_TEST *t, const char *alg)
 {
     const EVP_CIPHER *cipher;
-    CIPHER_DATA *cdat = t-&gt;data;
+    CIPHER_DATA *cdat;
+    int m;
 
-    cipher = EVP_get_cipherbyname(alg);
-    if (!cipher) {
+    if ((cipher = EVP_get_cipherbyname(alg)) == NULL) {
         /* If alg has an OID assume disabled algorithm */
         if (OBJ_sn2nid(alg) != NID_undef || OBJ_ln2nid(alg) != NID_undef) {
             t-&gt;skip = 1;
@@ -882,25 +458,20 @@ static int cipher_test_init(EVP_TEST *t, const char *alg)
         }
         return 0;
     }
-    cdat = OPENSSL_malloc(sizeof(*cdat));
+    cdat = OPENSSL_zalloc(sizeof(*cdat));
     cdat-&gt;cipher = cipher;
     cdat-&gt;enc = -1;
-    cdat-&gt;key = NULL;
-    cdat-&gt;iv = NULL;
-    cdat-&gt;ciphertext = NULL;
-    cdat-&gt;plaintext = NULL;
-    cdat-&gt;aad = NULL;
-    cdat-&gt;tag = NULL;
-    t-&gt;data = cdat;
-    if (EVP_CIPHER_mode(cipher) == EVP_CIPH_GCM_MODE
-        || EVP_CIPHER_mode(cipher) == EVP_CIPH_OCB_MODE
-        || EVP_CIPHER_mode(cipher) == EVP_CIPH_CCM_MODE)
+    m = EVP_CIPHER_mode(cipher);
+    if (m == EVP_CIPH_GCM_MODE
+            || m == EVP_CIPH_OCB_MODE
+            || m == EVP_CIPH_CCM_MODE)
         cdat-&gt;aead = EVP_CIPHER_mode(cipher);
     else if (EVP_CIPHER_flags(cipher) &amp; EVP_CIPH_FLAG_AEAD_CIPHER)
         cdat-&gt;aead = -1;
     else
         cdat-&gt;aead = 0;
 
+    t-&gt;data = cdat;
     return 1;
 }
 
@@ -922,18 +493,18 @@ static int cipher_test_parse(EVP_TEST *t, const char *keyword,
     CIPHER_DATA *cdat = t-&gt;data;
 
     if (strcmp(keyword, &quot;Key&quot;) == 0)
-        return test_bin(value, &amp;cdat-&gt;key, &amp;cdat-&gt;key_len);
+        return parse_bin(value, &amp;cdat-&gt;key, &amp;cdat-&gt;key_len);
     if (strcmp(keyword, &quot;IV&quot;) == 0)
-        return test_bin(value, &amp;cdat-&gt;iv, &amp;cdat-&gt;iv_len);
+        return parse_bin(value, &amp;cdat-&gt;iv, &amp;cdat-&gt;iv_len);
     if (strcmp(keyword, &quot;Plaintext&quot;) == 0)
-        return test_bin(value, &amp;cdat-&gt;plaintext, &amp;cdat-&gt;plaintext_len);
+        return parse_bin(value, &amp;cdat-&gt;plaintext, &amp;cdat-&gt;plaintext_len);
     if (strcmp(keyword, &quot;Ciphertext&quot;) == 0)
-        return test_bin(value, &amp;cdat-&gt;ciphertext, &amp;cdat-&gt;ciphertext_len);
+        return parse_bin(value, &amp;cdat-&gt;ciphertext, &amp;cdat-&gt;ciphertext_len);
     if (cdat-&gt;aead) {
         if (strcmp(keyword, &quot;AAD&quot;) == 0)
-            return test_bin(value, &amp;cdat-&gt;aad, &amp;cdat-&gt;aad_len);
+            return parse_bin(value, &amp;cdat-&gt;aad, &amp;cdat-&gt;aad_len);
         if (strcmp(keyword, &quot;Tag&quot;) == 0)
-            return test_bin(value, &amp;cdat-&gt;tag, &amp;cdat-&gt;tag_len);
+            return parse_bin(value, &amp;cdat-&gt;tag, &amp;cdat-&gt;tag_len);
     }
 
     if (strcmp(keyword, &quot;Operation&quot;) == 0) {
@@ -1233,6 +804,11 @@ static const EVP_TEST_METHOD cipher_test_method = {
     cipher_test_run
 };
 
+
+/**
+***  MAC TESTS
+**/
+
 typedef struct mac_data_st {
     /* MAC type */
     int type;
@@ -1302,7 +878,7 @@ static int mac_test_parse(EVP_TEST *t,
     MAC_DATA *mdata = t-&gt;data;
 
     if (strcmp(keyword, &quot;Key&quot;) == 0)
-        return test_bin(value, &amp;mdata-&gt;key, &amp;mdata-&gt;key_len);
+        return parse_bin(value, &amp;mdata-&gt;key, &amp;mdata-&gt;key_len);
     if (strcmp(keyword, &quot;Algorithm&quot;) == 0) {
         mdata-&gt;alg = OPENSSL_strdup(value);
         if (!mdata-&gt;alg)
@@ -1310,9 +886,9 @@ static int mac_test_parse(EVP_TEST *t,
         return 1;
     }
     if (strcmp(keyword, &quot;Input&quot;) == 0)
-        return test_bin(value, &amp;mdata-&gt;input, &amp;mdata-&gt;input_len);
+        return parse_bin(value, &amp;mdata-&gt;input, &amp;mdata-&gt;input_len);
     if (strcmp(keyword, &quot;Output&quot;) == 0)
-        return test_bin(value, &amp;mdata-&gt;output, &amp;mdata-&gt;output_len);
+        return parse_bin(value, &amp;mdata-&gt;output, &amp;mdata-&gt;output_len);
     return 0;
 }
 
@@ -1407,10 +983,11 @@ static const EVP_TEST_METHOD mac_test_method = {
     mac_test_run
 };
 
-/*
- * Public key operations. These are all very similar and can share
- * a lot of common code.
- */
+
+/**
+***  PUBLIC KEY TESTS
+***  These are all very similar and share much common code.
+**/
 
 typedef struct pkey_data_st {
     /* Context for this operation */
@@ -1434,11 +1011,10 @@ typedef struct pkey_data_st {
 static int pkey_test_init(EVP_TEST *t, const char *name,
                           int use_public,
                           int (*keyopinit) (EVP_PKEY_CTX *ctx),
-                          int (*keyop) (EVP_PKEY_CTX *ctx,
-                                        unsigned char *sig, size_t *siglen,
-                                        const unsigned char *tbs,
-                                        size_t tbslen)
-    )
+                          int (*keyop)(EVP_PKEY_CTX *ctx,
+                                       unsigned char *sig, size_t *siglen,
+                                       const unsigned char *tbs,
+                                       size_t tbslen))
 {
     PKEY_DATA *kdata;
     EVP_PKEY *pkey = NULL;
@@ -1453,19 +1029,16 @@ static int pkey_test_init(EVP_TEST *t, const char *name,
         return 1;
     }
 
-    if (!TEST_ptr(kdata = OPENSSL_malloc(sizeof(*kdata)))) {
+    if (!TEST_ptr(kdata = OPENSSL_zalloc(sizeof(*kdata)))) {
         EVP_PKEY_free(pkey);
         return 0;
     }
-    kdata-&gt;ctx = NULL;
-    kdata-&gt;input = NULL;
-    kdata-&gt;output = NULL;
     kdata-&gt;keyop = keyop;
-    t-&gt;data = kdata;
     if (!TEST_ptr(kdata-&gt;ctx = EVP_PKEY_CTX_new(pkey, NULL)))
         return 0;
     if (keyopinit(kdata-&gt;ctx) &lt;= 0)
         t-&gt;err = &quot;KEYOP_INIT_ERROR&quot;;
+    t-&gt;data = kdata;
     return 1;
 }
 
@@ -1488,7 +1061,7 @@ static int pkey_test_ctrl(EVP_TEST *t, EVP_PKEY_CTX *pctx,
         return 0;
     p = strchr(tmpval, ':');
     if (p != NULL)
-        *p++ = 0;
+        *p++ = '\0';
     rv = EVP_PKEY_CTX_ctrl_str(pctx, tmpval, p);
     if (rv == -2) {
         t-&gt;err = &quot;PKEY_CTRL_INVALID&quot;;
@@ -1499,8 +1072,9 @@ static int pkey_test_ctrl(EVP_TEST *t, EVP_PKEY_CTX *pctx,
 
         if (nid == NID_undef)
              nid = OBJ_ln2nid(p);
-        if ((nid != NID_undef) &amp;&amp; EVP_get_digestbynid(nid) == NULL &amp;&amp;
-            EVP_get_cipherbynid(nid) == NULL) {
+        if (nid != NID_undef
+                &amp;&amp; EVP_get_digestbynid(nid) == NULL
+                &amp;&amp; EVP_get_cipherbynid(nid) == NULL) {
             t-&gt;skip = 1;
             rv = 1;
         } else {
@@ -1517,9 +1091,9 @@ static int pkey_test_parse(EVP_TEST *t,
 {
     PKEY_DATA *kdata = t-&gt;data;
     if (strcmp(keyword, &quot;Input&quot;) == 0)
-        return test_bin(value, &amp;kdata-&gt;input, &amp;kdata-&gt;input_len);
+        return parse_bin(value, &amp;kdata-&gt;input, &amp;kdata-&gt;input_len);
     if (strcmp(keyword, &quot;Output&quot;) == 0)
-        return test_bin(value, &amp;kdata-&gt;output, &amp;kdata-&gt;output_len);
+        return parse_bin(value, &amp;kdata-&gt;output, &amp;kdata-&gt;output_len);
     if (strcmp(keyword, &quot;Ctrl&quot;) == 0)
         return pkey_test_ctrl(t, kdata-&gt;ctx, value);
     return 0;
@@ -1636,7 +1210,7 @@ static int pderive_test_parse(EVP_TEST *t,
         return 1;
     }
     if (strcmp(keyword, &quot;SharedSecret&quot;) == 0)
-        return test_bin(value, &amp;kdata-&gt;output, &amp;kdata-&gt;output_len);
+        return parse_bin(value, &amp;kdata-&gt;output, &amp;kdata-&gt;output_len);
     if (strcmp(keyword, &quot;Ctrl&quot;) == 0)
         return pkey_test_ctrl(t, kdata-&gt;ctx, value);
     return 0;
@@ -1676,14 +1250,18 @@ static const EVP_TEST_METHOD pderive_test_method = {
     pderive_test_run
 };
 
-/* PBE tests */
 
-#define PBE_TYPE_SCRYPT 1
-#define PBE_TYPE_PBKDF2 2
-#define PBE_TYPE_PKCS12 3
+/**
+***  PBE TESTS
+**/
+
+typedef enum pbe_type_enum {
+    PBE_TYPE_INVALID = 0,
+    PBE_TYPE_SCRYPT, PBE_TYPE_PBKDF2, PBE_TYPE_PKCS12
+} PBE_TYPE;
 
 typedef struct pbe_data_st {
-    int pbe_type;
+    PBE_TYPE pbe_type;
         /* scrypt parameters */
     uint64_t N, r, p, maxmem;
         /* PKCS#12 parameters */
@@ -1701,19 +1279,46 @@ typedef struct pbe_data_st {
 } PBE_DATA;
 
 #ifndef OPENSSL_NO_SCRYPT
+/*
+ * Parse unsigned decimal 64 bit integer value
+ */
+static int parse_uint64(const char *value, uint64_t *pr)
+{
+    const char *p = value;
+
+    if (!TEST_true(*p)) {
+        TEST_info(&quot;Invalid empty integer value&quot;);
+        return -1;
+    }
+    for (*pr = 0; *p; ) {
+        if (*pr &gt; UINT64_MAX / 10) {
+            TEST_error(&quot;Integer overflow in string %s&quot;, value);
+            return -1;
+        }
+        *pr *= 10;
+        if (!TEST_true(isdigit(*p))) {
+            TEST_error(&quot;Invalid character in string %s&quot;, value);
+            return -1;
+        }
+        *pr += *p - '0';
+        p++;
+    }
+    return 1;
+}
+
 static int scrypt_test_parse(EVP_TEST *t,
                              const char *keyword, const char *value)
 {
     PBE_DATA *pdata = t-&gt;data;
 
     if (strcmp(keyword, &quot;N&quot;) == 0)
-        return test_uint64(value, &amp;pdata-&gt;N);
+        return parse_uint64(value, &amp;pdata-&gt;N);
     if (strcmp(keyword, &quot;p&quot;) == 0)
-        return test_uint64(value, &amp;pdata-&gt;p);
+        return parse_uint64(value, &amp;pdata-&gt;p);
     if (strcmp(keyword, &quot;r&quot;) == 0)
-        return test_uint64(value, &amp;pdata-&gt;r);
+        return parse_uint64(value, &amp;pdata-&gt;r);
     if (strcmp(keyword, &quot;maxmem&quot;) == 0)
-        return test_uint64(value, &amp;pdata-&gt;maxmem);
+        return parse_uint64(value, &amp;pdata-&gt;maxmem);
     return 0;
 }
 #endif
@@ -1726,13 +1331,13 @@ static int pbkdf2_test_parse(EVP_TEST *t,
     if (strcmp(keyword, &quot;iter&quot;) == 0) {
         pdata-&gt;iter = atoi(value);
         if (pdata-&gt;iter &lt;= 0)
-            return 0;
+            return -1;
         return 1;
     }
     if (strcmp(keyword, &quot;MD&quot;) == 0) {
         pdata-&gt;md = EVP_get_digestbyname(value);
         if (pdata-&gt;md == NULL)
-            return 0;
+            return -1;
         return 1;
     }
     return 0;
@@ -1746,7 +1351,7 @@ static int pkcs12_test_parse(EVP_TEST *t,
     if (strcmp(keyword, &quot;id&quot;) == 0) {
         pdata-&gt;id = atoi(value);
         if (pdata-&gt;id &lt;= 0)
-            return 0;
+            return -1;
         return 1;
     }
     return pbkdf2_test_parse(t, keyword, value);
@@ -1755,7 +1360,7 @@ static int pkcs12_test_parse(EVP_TEST *t,
 static int pbe_test_init(EVP_TEST *t, const char *alg)
 {
     PBE_DATA *pdat;
-    int pbe_type = 0;
+    PBE_TYPE pbe_type = PBE_TYPE_INVALID;
 
     if (strcmp(alg, &quot;scrypt&quot;) == 0) {
 #ifndef OPENSSL_NO_SCRYPT
@@ -1771,17 +1376,8 @@ static int pbe_test_init(EVP_TEST *t, const char *alg)
     } else {
         TEST_error(&quot;Unknown pbe algorithm %s&quot;, alg);
     }
-    pdat = OPENSSL_malloc(sizeof(*pdat));
+    pdat = OPENSSL_zalloc(sizeof(*pdat));
     pdat-&gt;pbe_type = pbe_type;
-    pdat-&gt;pass = NULL;
-    pdat-&gt;salt = NULL;
-    pdat-&gt;N = 0;
-    pdat-&gt;r = 0;
-    pdat-&gt;p = 0;
-    pdat-&gt;maxmem = 0;
-    pdat-&gt;id = 0;
-    pdat-&gt;iter = 0;
-    pdat-&gt;md = NULL;
     t-&gt;data = pdat;
     return 1;
 }
@@ -1801,11 +1397,11 @@ static int pbe_test_parse(EVP_TEST *t,
     PBE_DATA *pdata = t-&gt;data;
 
     if (strcmp(keyword, &quot;Password&quot;) == 0)
-        return test_bin(value, &amp;pdata-&gt;pass, &amp;pdata-&gt;pass_len);
+        return parse_bin(value, &amp;pdata-&gt;pass, &amp;pdata-&gt;pass_len);
     if (strcmp(keyword, &quot;Salt&quot;) == 0)
-        return test_bin(value, &amp;pdata-&gt;salt, &amp;pdata-&gt;salt_len);
+        return parse_bin(value, &amp;pdata-&gt;salt, &amp;pdata-&gt;salt_len);
     if (strcmp(keyword, &quot;Key&quot;) == 0)
-        return test_bin(value, &amp;pdata-&gt;key, &amp;pdata-&gt;key_len);
+        return parse_bin(value, &amp;pdata-&gt;key, &amp;pdata-&gt;key_len);
     if (pdata-&gt;pbe_type == PBE_TYPE_PBKDF2)
         return pbkdf2_test_parse(t, keyword, value);
     else if (pdata-&gt;pbe_type == PBE_TYPE_PKCS12)
@@ -1871,7 +1467,10 @@ static const EVP_TEST_METHOD pbe_test_method = {
     pbe_test_run
 };
 
-/* Base64 tests */
+
+/**
+***  BASE64 TESTS
+**/
 
 typedef enum {
     BASE64_CANONICAL_ENCODING = 0,
@@ -1891,20 +1490,22 @@ typedef struct encode_data_st {
 
 static int encode_test_init(EVP_TEST *t, const char *encoding)
 {
-    ENCODE_DATA *edata = OPENSSL_zalloc(sizeof(*edata));
+    ENCODE_DATA *edata;
 
+    if (!TEST_ptr(edata = OPENSSL_zalloc(sizeof(*edata))))
+        return 0;
     if (strcmp(encoding, &quot;canonical&quot;) == 0) {
         edata-&gt;encoding = BASE64_CANONICAL_ENCODING;
     } else if (strcmp(encoding, &quot;valid&quot;) == 0) {
         edata-&gt;encoding = BASE64_VALID_ENCODING;
     } else if (strcmp(encoding, &quot;invalid&quot;) == 0) {
         edata-&gt;encoding = BASE64_INVALID_ENCODING;
-        t-&gt;expected_err = OPENSSL_strdup(&quot;DECODE_ERROR&quot;);
-        if (t-&gt;expected_err == NULL)
+        if (!TEST_ptr(t-&gt;expected_err = OPENSSL_strdup(&quot;DECODE_ERROR&quot;)))
             return 0;
     } else {
-        TEST_info(&quot;Bad encoding: %s. Should be one of &quot;
-                  &quot;{canonical, valid, invalid}&quot;, encoding);
+        TEST_error(&quot;Bad encoding: %s.&quot;
+                   &quot; Should be one of {canonical, valid, invalid}&quot;,
+                   encoding);
         return 0;
     }
     t-&gt;data = edata;
@@ -1924,10 +1525,11 @@ static int encode_test_parse(EVP_TEST *t,
                              const char *keyword, const char *value)
 {
     ENCODE_DATA *edata = t-&gt;data;
+
     if (strcmp(keyword, &quot;Input&quot;) == 0)
-        return test_bin(value, &amp;edata-&gt;input, &amp;edata-&gt;input_len);
+        return parse_bin(value, &amp;edata-&gt;input, &amp;edata-&gt;input_len);
     if (strcmp(keyword, &quot;Output&quot;) == 0)
-        return test_bin(value, &amp;edata-&gt;output, &amp;edata-&gt;output_len);
+        return parse_bin(value, &amp;edata-&gt;output, &amp;edata-&gt;output_len);
     return 0;
 }
 
@@ -2009,7 +1611,9 @@ static const EVP_TEST_METHOD encode_test_method = {
     encode_test_run,
 };
 
-/* KDF operations */
+/**
+***  KDF TESTS
+**/
 
 typedef struct kdf_data_st {
     /* Context for this operation */
@@ -2027,17 +1631,14 @@ static int kdf_test_init(EVP_TEST *t, const char *name)
 {
     KDF_DATA *kdata;
 
-    kdata = OPENSSL_malloc(sizeof(*kdata));
-    if (kdata == NULL)
+    if (!TEST_ptr(kdata = OPENSSL_zalloc(sizeof(*kdata))))
         return 0;
-    kdata-&gt;ctx = NULL;
-    kdata-&gt;output = NULL;
-    t-&gt;data = kdata;
     kdata-&gt;ctx = EVP_PKEY_CTX_new_id(OBJ_sn2nid(name), NULL);
     if (kdata-&gt;ctx == NULL)
         return 0;
     if (EVP_PKEY_derive_init(kdata-&gt;ctx) &lt;= 0)
         return 0;
+    t-&gt;data = kdata;
     return 1;
 }
 
@@ -2054,7 +1655,7 @@ static int kdf_test_parse(EVP_TEST *t,
     KDF_DATA *kdata = t-&gt;data;
 
     if (strcmp(keyword, &quot;Output&quot;) == 0)
-        return test_bin(value, &amp;kdata-&gt;output, &amp;kdata-&gt;output_len);
+        return parse_bin(value, &amp;kdata-&gt;output, &amp;kdata-&gt;output_len);
     if (strncmp(keyword, &quot;Ctrl&quot;, 4) == 0)
         return pkey_test_ctrl(t, kdata-&gt;ctx, value);
     return 0;
@@ -2093,32 +1694,38 @@ static const EVP_TEST_METHOD kdf_test_method = {
     kdf_test_run
 };
 
-typedef struct keypair_test_buffer_st {
+
+/**
+***  KEYPAIR TESTS
+**/
+
+typedef struct keypair_test_data_st {
     EVP_PKEY *privk;
     EVP_PKEY *pubk;
 } KEYPAIR_TEST_DATA;
 
 static int keypair_test_init(EVP_TEST *t, const char *pair)
 {
+    KEYPAIR_TEST_DATA *data;
     int rv = 0;
     EVP_PKEY *pk = NULL, *pubk = NULL;
     char *pub, *priv = NULL;
-    KEYPAIR_TEST_DATA *data;
 
+    /* Split private and public names. */
     if (!TEST_ptr(priv = OPENSSL_strdup(pair))
             || !TEST_ptr(pub = strchr(priv, ':'))) {
         t-&gt;err = &quot;PARSING_ERROR&quot;;
         goto end;
     }
-    *pub++ = 0; /* split priv and pub strings */
+    *pub++ = '\0';
 
     if (!TEST_true(find_key(&amp;pk, priv, private_keys))) {
-        TEST_info(&quot;Cannot find private key: %s&quot;, priv);
+        TEST_info(&quot;Can't find private key: %s&quot;, priv);
         t-&gt;err = &quot;MISSING_PRIVATE_KEY&quot;;
         goto end;
     }
     if (!TEST_true(find_key(&amp;pubk, pub, public_keys))) {
-        TEST_info(&quot;Cannot find public key: %s&quot;, pub);
+        TEST_info(&quot;Can't find public key: %s&quot;, pub);
         t-&gt;err = &quot;MISSING_PUBLIC_KEY&quot;;
         goto end;
     }
@@ -2132,7 +1739,6 @@ static int keypair_test_init(EVP_TEST *t, const char *pair)
 
     if (!TEST_ptr(data = OPENSSL_malloc(sizeof(*data))))
         goto end;
-
     data-&gt;privk = pk;
     data-&gt;pubk = pubk;
     t-&gt;data = data;
@@ -2150,8 +1756,8 @@ static void keypair_test_cleanup(EVP_TEST *t)
     t-&gt;data = NULL;
 }
 
-/* For test that do not accept any custom keyword:
- *      return 0 if called
+/*
+ * For tests that do not accept any custom keywords.
  */
 static int void_test_parse(EVP_TEST *t, const char *keyword, const char *value)
 {
@@ -2205,6 +1811,11 @@ static const EVP_TEST_METHOD keypair_test_method = {
     keypair_test_run
 };
 
+
+/**
+***  DIGEST SIGN+VERIFY TESTS
+**/
+
 typedef struct {
     int is_verify; /* Set to 1 if verifying */
     int is_oneshot; /* Set to 1 for one shot operation */
@@ -2295,11 +1906,11 @@ static int digestsigver_test_parse(EVP_TEST *t,
 
     if (strcmp(keyword, &quot;Input&quot;) == 0) {
         if (mdata-&gt;is_oneshot)
-            return test_bin(value, &amp;mdata-&gt;osin, &amp;mdata-&gt;osin_len);
+            return parse_bin(value, &amp;mdata-&gt;osin, &amp;mdata-&gt;osin_len);
         return evp_test_buffer_append(value, &amp;mdata-&gt;input);
     }
     if (strcmp(keyword, &quot;Output&quot;) == 0)
-        return test_bin(value, &amp;mdata-&gt;output, &amp;mdata-&gt;output_len);
+        return parse_bin(value, &amp;mdata-&gt;output, &amp;mdata-&gt;output_len);
 
     if (!mdata-&gt;is_oneshot) {
         if (strcmp(keyword, &quot;Count&quot;) == 0)
@@ -2462,28 +2073,464 @@ static const EVP_TEST_METHOD oneshot_digestverify_test_method = {
     oneshot_digestverify_test_run
 };
 
+
+/**
+***  PARSING AND DISPATCH
+**/
+
+static const EVP_TEST_METHOD *evp_test_list[] = {
+    &amp;cipher_test_method,
+    &amp;digest_test_method,
+    &amp;digestsign_test_method,
+    &amp;digestverify_test_method,
+    &amp;encode_test_method,
+    &amp;kdf_test_method,
+    &amp;keypair_test_method,
+    &amp;mac_test_method,
+    &amp;oneshot_digestsign_test_method,
+    &amp;oneshot_digestverify_test_method,
+    &amp;pbe_test_method,
+    &amp;pdecrypt_test_method,
+    &amp;pderive_test_method,
+    &amp;psign_test_method,
+    &amp;pverify_recover_test_method,
+    &amp;pverify_test_method,
+    NULL
+};
+
+static const EVP_TEST_METHOD *find_test(const char *name)
+{
+    const EVP_TEST_METHOD **tt;
+
+    for (tt = evp_test_list; *tt; tt++) {
+        if (strcmp(name, (*tt)-&gt;name) == 0)
+            return *tt;
+    }
+    return NULL;
+}
+
+static void clear_test(EVP_TEST *t)
+{
+    ERR_clear_error();
+    if (t-&gt;data != NULL) {
+        if (t-&gt;meth != NULL)
+            t-&gt;meth-&gt;cleanup(t);
+        OPENSSL_free(t-&gt;data);
+        t-&gt;data = NULL;
+    }
+    OPENSSL_free(t-&gt;expected_err);
+    t-&gt;expected_err = NULL;
+    OPENSSL_free(t-&gt;func);
+    t-&gt;func = NULL;
+    OPENSSL_free(t-&gt;reason);
+    t-&gt;reason = NULL;
+    /* Text literal. */
+    t-&gt;err = NULL;
+    t-&gt;skip = 0;
+    t-&gt;meth = NULL;
+}
+
+/*
+ * Check for errors in the test structure; return 1 if okay, else 0.
+ */
+static int check_test_error(EVP_TEST *t)
+{
+    unsigned long err;
+    const char *func;
+    const char *reason;
+
+    if (t-&gt;err == NULL &amp;&amp; t-&gt;expected_err == NULL)
+        return 1;
+    if (t-&gt;err != NULL &amp;&amp; t-&gt;expected_err == NULL) {
+        if (t-&gt;aux_err != NULL) {
+            TEST_info(&quot;Above error from the test at %s:%d &quot;
+                      &quot;(%s) unexpected error %s&quot;,
+                      current_test_file, t-&gt;start_line, t-&gt;aux_err, t-&gt;err);
+        } else {
+            TEST_info(&quot;Above error from the test at %s:%d &quot;
+                      &quot;unexpected error %s&quot;,
+                      current_test_file, t-&gt;start_line, t-&gt;err);
+        }
+        return 0;
+    }
+    if (t-&gt;err == NULL &amp;&amp; t-&gt;expected_err != NULL) {
+        TEST_info(&quot;Test line %d: succeeded but was expecting %s&quot;,
+                  t-&gt;start_line, t-&gt;expected_err);
+        return 0;
+    }
+
+    if (strcmp(t-&gt;err, t-&gt;expected_err) != 0) {
+        TEST_info(&quot;Test line %d: expecting %s got %s&quot;,
+                  t-&gt;start_line, t-&gt;expected_err, t-&gt;err);
+        return 0;
+    }
+
+    if (t-&gt;func == NULL &amp;&amp; t-&gt;reason == NULL)
+        return 1;
+
+    if (t-&gt;func == NULL || t-&gt;reason == NULL) {
+        TEST_info(&quot;Test line %d: missing function or reason code&quot;,
+                  t-&gt;start_line);
+        return 0;
+    }
+
+    err = ERR_peek_error();
+    if (err == 0) {
+        TEST_info(&quot;Test line %d, expected error \&quot;%s:%s\&quot; not set&quot;,
+                  t-&gt;start_line, t-&gt;func, t-&gt;reason);
+        return 0;
+    }
+
+    func = ERR_func_error_string(err);
+    reason = ERR_reason_error_string(err);
+    if (func == NULL &amp;&amp; reason == NULL) {
+        TEST_info(&quot;Test line %d: expected error \&quot;%s:%s\&quot;,&quot;
+                  &quot; no strings available.  Skipping...\n&quot;,
+                  t-&gt;start_line, t-&gt;func, t-&gt;reason);
+        return 1;
+    }
+
+    if (strcmp(func, t-&gt;func) == 0 &amp;&amp; strcmp(reason, t-&gt;reason) == 0)
+        return 1;
+
+    TEST_info(&quot;Test line %d: expected error \&quot;%s:%s\&quot;, got \&quot;%s:%s\&quot;&quot;,
+              t-&gt;start_line, t-&gt;func, t-&gt;reason, func, reason);
+
+    return 0;
+}
+
+/*
+ * Run a parsed test. Log a message and return 0 on error.
+ */
+static int run_test(EVP_TEST *t)
+{
+    if (t-&gt;meth == NULL)
+        return 1;
+    t-&gt;ntests++;
+    if (t-&gt;skip) {
+        t-&gt;nskip++;
+    } else {
+        /* run the test */
+        if (t-&gt;err == NULL &amp;&amp; t-&gt;meth-&gt;run_test(t) != 1) {
+            TEST_info(&quot;Line %d error %s&quot;, t-&gt;start_line, t-&gt;meth-&gt;name);
+            return 0;
+        }
+        if (!check_test_error(t)) {
+            test_openssl_errors();
+            t-&gt;errors++;
+        }
+    }
+
+    /* clean it up */
+    return 1;
+}
+
+static int find_key(EVP_PKEY **ppk, const char *name, KEY_LIST *lst)
+{
+    for (; lst != NULL; lst = lst-&gt;next) {
+        if (strcmp(lst-&gt;name, name) == 0) {
+            if (ppk != NULL)
+                *ppk = lst-&gt;key;
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static void free_key_list(KEY_LIST *lst)
+{
+    while (lst != NULL) {
+        KEY_LIST *next = lst-&gt;next;
+
+        EVP_PKEY_free(lst-&gt;key);
+        OPENSSL_free(lst-&gt;name);
+        OPENSSL_free(lst);
+        lst = next;
+    }
+}
+
+
+/*
+ * Read a line, remove the newline, return EOF or first char.
+ * Comment lines are treated like empty lines.
+ */
+static int read_line(EVP_TEST *t)
+{
+    char *p;
+
+    if (!BIO_gets(t-&gt;in, t-&gt;buf, sizeof(t-&gt;buf)))
+        return EOF;
+    t-&gt;line++;
+    if ((p = strchr(t-&gt;buf, '\n')) != NULL)
+        *p = '\0';
+    if (t-&gt;buf[0] == '#')
+        t-&gt;buf[0] = '\0';
+    return t-&gt;buf[0];
+}
+
+/*
+ * Skip leading spaces and remove trailing spaces from string.
+ */
+static char *strip_spaces(char *pval)
+{
+    char *p, *start;
+
+    for (start = pval; isspace(*start); )
+        start++;
+    if (*start == '\0')
+        return start;
+
+    for (p = start + strlen(start); --p &gt;= start &amp;&amp; isspace(*p); )
+        *p = '\0';
+    return start;
+}
+
+/*
+ * Split line into 'key = value'; return 1 if okay, 0 on error.
+ */
+static int split_line(EVP_TEST *t, char **keyword, char **value)
+{
+    char *p;
+
+    /* Look for = sign */
+    if ((p = strchr(t-&gt;buf, '=')) == NULL) {
+        TEST_error(&quot;Line %d: Missing '=' in test file&quot;, t-&gt;line);
+        return 0;
+    }
+    *p++ = '\0';
+    *keyword = strip_spaces(t-&gt;buf);
+    *value = strip_spaces(p);
+    if (**keyword == '\0') {
+        TEST_error(&quot;Line %d: Missing key; malformed input line&quot;, t-&gt;line);
+        return 0;
+    }
+    return 1;
+}
+
+/*
+ * Read a PEM block.  Return 1 if okay, 0 on error.
+ */
+static int read_key(EVP_TEST *t)
+{
+    char tmpbuf[128];
+
+    if (t-&gt;key == NULL) {
+        if (!TEST_ptr(t-&gt;key = BIO_new(BIO_s_mem())))
+            return 0;
+    } else if (!TEST_int_gt(BIO_reset(t-&gt;key), 0)) {
+        return 0;
+    }
+
+    /* Read to PEM end line and place content in memory BIO */
+    while (BIO_gets(t-&gt;in, tmpbuf, sizeof(tmpbuf))) {
+        t-&gt;line++;
+        if (!TEST_int_gt(BIO_puts(t-&gt;key, tmpbuf), 0))
+            return 0;
+        if (strncmp(tmpbuf, &quot;-----END&quot;, 8) == 0)
+            return 1;
+    }
+    TEST_error(&quot;Can't find key end&quot;);
+    return 0;
+}
+
+/*
+ * Is the key type an unsupported algorithm?
+ */
+static int key_unsupported()
+{
+    long err = ERR_peek_error();
+
+    if (ERR_GET_LIB(err) == ERR_LIB_EVP
+            &amp;&amp; ERR_GET_REASON(err) == EVP_R_UNSUPPORTED_ALGORITHM) {
+        ERR_clear_error();
+        return 1;
+    }
+#ifndef OPENSSL_NO_EC
+    /*
+     * If EC support is enabled we should catch also EC_R_UNKNOWN_GROUP as an
+     * hint to an unsupported algorithm/curve (e.g. if binary EC support is
+     * disabled).
+     */
+    if (ERR_GET_LIB(err) == ERR_LIB_EC
+        &amp;&amp; ERR_GET_REASON(err) == EC_R_UNKNOWN_GROUP) {
+        ERR_clear_error();
+        return 1;
+    }
+#endif /* OPENSSL_NO_EC */
+    return 0;
+}
+
+/*
+ * Read, parse, and execute one test.  Return EOF; 0 if failure, 1 if okay.
+ */
+static int read_stanza(EVP_TEST *t)
+{
+    int c;
+    char *keyword, *value;
+    KEY_LIST **klist, *key;
+    EVP_PKEY *pkey;
+
+    clear_test(t);
+top:
+    /* Find the first line of a stanza. */
+    for ( ; ; ) {
+        c = read_line(t);
+        if (c == EOF)
+            return EOF;
+        if (c == '\0')
+            continue;
+        break;
+    }
+    if (!split_line(t, &amp;keyword, &amp;value))
+        return 0;
+
+    /* Handle a few special cases here. */
+    if (strcmp(keyword, &quot;Title&quot;) == 0) {
+        TEST_info(&quot;Starting \&quot;%s\&quot; tests&quot;, value);
+        goto top;
+    }
+
+    klist = NULL;
+    pkey = NULL;
+    if (strcmp(keyword, &quot;PrivateKey&quot;) == 0) {
+        if (!read_key(t))
+            return 0;
+        pkey = PEM_read_bio_PrivateKey(t-&gt;key, NULL, 0, NULL);
+        if (pkey == NULL &amp;&amp; !key_unsupported()) {
+            TEST_info(&quot;Can't read private key %s&quot;, value);
+            ERR_print_errors_fp(stderr);
+            return 0;
+        }
+        klist = &amp;private_keys;
+    }
+    else if (strcmp(keyword, &quot;PublicKey&quot;) == 0) {
+        if (!read_key(t))
+            return 0;
+        pkey = PEM_read_bio_PUBKEY(t-&gt;key, NULL, 0, NULL);
+        if (pkey == NULL &amp;&amp; !key_unsupported()) {
+            TEST_info(&quot;Can't read public key %s&quot;, value);
+            ERR_print_errors_fp(stderr);
+            return 0;
+        }
+        klist = &amp;public_keys;
+    }
+
+    /* If we have a key add to list */
+    if (klist != NULL) {
+        if (find_key(NULL, value, *klist)) {
+            TEST_info(&quot;Duplicate key %s&quot;, value);
+            return 0;
+        }
+        if (!TEST_ptr(key = OPENSSL_malloc(sizeof(*key)))
+                || !TEST_ptr(key-&gt;name = OPENSSL_strdup(value)))
+            return 0;
+        key-&gt;key = pkey;
+        key-&gt;next = *klist;
+        *klist = key;
+
+        /* Go back and start a new stanza. */
+        goto top;
+    }
+
+    /* Start of a new text.  Look it up. */
+    if (!TEST_ptr(t-&gt;meth = find_test(keyword)))
+        goto skiptoend;
+    t-&gt;start_line = t-&gt;line;
+    if (!t-&gt;meth-&gt;init(t, value)) {
+        TEST_error(&quot;unknown %s: %s\n&quot;, keyword, value);
+        goto skiptoend;
+    }
+    if (t-&gt;skip == 1) {
+        /* TEST_info(&quot;skipping %s %s&quot;, keyword, value); */
+        goto skiptoend;
+    }
+
+    /* Read rest of stanza. */
+    for ( ; ; ) {
+        c = read_line(t);
+        if (c == EOF)
+            return c;
+        if (c == '\0')
+            break;
+        if (!split_line(t, &amp;keyword, &amp;value))
+            goto skiptoend;
+        if (strcmp(keyword, &quot;Result&quot;) == 0) {
+            if (t-&gt;expected_err != NULL) {
+                TEST_info(&quot;Line %d: multiple result lines&quot;, t-&gt;line);
+                goto skiptoend;
+            }
+            if (!TEST_ptr(t-&gt;expected_err = OPENSSL_strdup(value)))
+                goto skiptoend;
+        } else if (strcmp(keyword, &quot;Function&quot;) == 0) {
+            if (t-&gt;func != NULL) {
+                TEST_info(&quot;Line %d: multiple function lines\n&quot;, t-&gt;line);
+                goto skiptoend;
+            }
+            if (!TEST_ptr(t-&gt;func = OPENSSL_strdup(value)))
+                goto skiptoend;
+        } else if (strcmp(keyword, &quot;Reason&quot;) == 0) {
+            if (t-&gt;reason != NULL) {
+                TEST_info(&quot;Line %d: multiple reason lines&quot;, t-&gt;line);
+                goto skiptoend;
+            }
+            if (!TEST_ptr(t-&gt;reason = OPENSSL_strdup(value)))
+                goto skiptoend;
+        } else {
+            /* Must be test specific line: try to parse it */
+            int rv = t-&gt;meth-&gt;parse(t, keyword, value);
+
+            if (rv == 0) {
+                TEST_info(&quot;Line %d: unknown keyword %s&quot;, t-&gt;line, keyword);
+                goto skiptoend;
+            }
+            if (rv &lt; 0) {
+                TEST_info(&quot;Line %d: error processing keyword %s\n&quot;,
+                        t-&gt;line, keyword);
+                goto skiptoend;
+            }
+        }
+    }
+
+    return 1;
+
+skiptoend:
+    /* Read to end of stanza and return failure */
+    for ( ; ; ) {
+        c = read_line(t);
+        if (c == EOF)
+            return EOF;
+        if (c == '\0')
+            break;
+    }
+    return 0;
+}
+
 static int do_test_file(const char *testfile)
 {
     BIO *in;
-    char buf[10240];
     EVP_TEST t;
+    int c;
 
     set_test_title(testfile);
     current_test_file = testfile;
     if (!TEST_ptr(in = BIO_new_file(testfile, &quot;rb&quot;)))
         return 0;
     memset(&amp;t, 0, sizeof(t));
-    t.start_line = -1;
     t.in = in;
-    t.err = NULL;
-    while (BIO_gets(in, buf, sizeof(buf))) {
-        t.line++;
-        if (!TEST_true(parse_test_line(&amp;t, buf)))
-            return 0;
+
+    TEST_info(&quot;Reading %s&quot;, testfile);
+    for ( ; ; ) {
+        c = read_stanza(&amp;t);
+        if (t.skip)
+            continue;
+        if (c == 0 || !run_test(&amp;t)) {
+            t.errors++;
+            break;
+        }
+        if (c == EOF)
+            break;
     }
-    /* Run any final test we have */
-    if (!run_and_get_next(&amp;t, NULL))
-        return 0;
+    clear_test(&amp;t);
 
     TEST_info(&quot;Completed %d tests with %d errors and %d skipped&quot;,
               t.ntests, t.errors, t.nskip);
diff --git a/test/testutil/tests.c b/test/testutil/tests.c
index 3f75691..a5538e7 100644
--- a/test/testutil/tests.c
+++ b/test/testutil/tests.c
@@ -524,7 +524,7 @@ void test_error_c90(const char *desc, ...)
     va_list ap;
 
     va_start(ap, desc);
-    test_fail_message(NULL, NULL, -1, NULL, NULL, NULL, NULL, desc, ap);
+    test_fail_message_va(NULL, NULL, -1, NULL, NULL, NULL, NULL, desc, ap);
     va_end(ap);
 }
 
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014763.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="014775.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14769">[ date ]</a>
              <a href="thread.html#14769">[ thread ]</a>
              <a href="subject.html#14769">[ subject ]</a>
              <a href="author.html#14769">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
