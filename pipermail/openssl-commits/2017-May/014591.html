<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2017-May/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1494517027.556478.28837.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014589.html">
   <LINK REL="Next"  HREF="014592.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Rich Salz</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1494517027.556478.28837.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">rsalz at openssl.org
       </A><BR>
    <I>Thu May 11 15:37:07 UTC 2017</I>
    <P><UL>
        <LI>Previous message: <A HREF="014589.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="014592.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14591">[ date ]</a>
              <a href="thread.html#14591">[ thread ]</a>
              <a href="subject.html#14591">[ subject ]</a>
              <a href="author.html#14591">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  7193f8723e42e9b392bb1a60f423e593c8c79be9 (commit)
       via  412486070fd044fa67d8cfd0a195a9f2a572145a (commit)
       via  6c5943c9f619fdad08b8c6d01b12bd500a6c605a (commit)
      from  888adbe064556ff5ab2f1d16a223b0548696614c (commit)


- Log -----------------------------------------------------------------
commit 7193f8723e42e9b392bb1a60f423e593c8c79be9
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
Date:   Mon May 8 14:46:57 2017 -0400

    Use compare_mem wrapper
    
    Add file/line# to test error message.
    Also remove expected/got fields since TEST structure prints them.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3324">https://github.com/openssl/openssl/pull/3324</A>)

commit 412486070fd044fa67d8cfd0a195a9f2a572145a
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
Date:   Sun Apr 30 20:38:39 2017 -0400

    Address some feedback
    
    Report test detail error.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3324">https://github.com/openssl/openssl/pull/3324</A>)

commit 6c5943c9f619fdad08b8c6d01b12bd500a6c605a
Author: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;
Date:   Wed Apr 26 15:33:43 2017 -0400

    Convert of evp_test to framework
    
    Also, allow multiple files on commandline (for future splitup of
    evptests.txt)
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/3324">https://github.com/openssl/openssl/pull/3324</A>)

-----------------------------------------------------------------------

Summary of changes:
 test/build.info |    2 +-
 test/evp_test.c | 1185 ++++++++++++++++++++++++++-----------------------------
 2 files changed, 564 insertions(+), 623 deletions(-)

diff --git a/test/build.info b/test/build.info
index bd80b18..da7620c 100644
--- a/test/build.info
+++ b/test/build.info
@@ -163,7 +163,7 @@ INCLUDE_MAIN___test_libtestutil_OLB = /INCLUDE=MAIN
 
   SOURCE[evp_test]=evp_test.c
   INCLUDE[evp_test]=../include
-  DEPEND[evp_test]=../libcrypto
+  DEPEND[evp_test]=../libcrypto libtestutil.a
 
   SOURCE[evp_extra_test]=evp_extra_test.c
   INCLUDE[evp_extra_test]=../include
diff --git a/test/evp_test.c b/test/evp_test.c
index e7396f7..8a52699 100644
--- a/test/evp_test.c
+++ b/test/evp_test.c
@@ -18,9 +18,13 @@
 #include &lt;openssl/pkcs12.h&gt;
 #include &lt;openssl/kdf.h&gt;
 #include &quot;internal/numbers.h&quot;
+#include &quot;testutil.h&quot;
 
-/* Remove spaces from beginning and end of a string */
+static const char *current_test_file = &quot;???&quot;;
 
+/*
+ * Remove spaces from beginning and end of a string
+ */
 static void remove_space(char **pval)
 {
     unsigned char *p = (unsigned char *)*pval, *beginning;
@@ -40,43 +44,31 @@ static void remove_space(char **pval)
 /*
  * Given a line of the form:
  *      name = value # comment
- * extract name and value. NB: modifies passed buffer.
+ * extract name and value. NB: modifies |linebuf|.
  */
-
 static int parse_line(char **pkw, char **pval, char *linebuf)
 {
-    char *p;
-
-    p = linebuf + strlen(linebuf) - 1;
+    char *p = linebuf + strlen(linebuf) - 1;
 
     if (*p != '\n') {
-        fprintf(stderr, &quot;FATAL: missing EOL\n&quot;);
-        exit(1);
+        TEST_error(&quot;FATAL: missing EOL&quot;);
+        return 0;
     }
 
     /* Look for # */
-
     p = strchr(linebuf, '#');
-
-    if (p)
+    if (p != NULL)
         *p = '\0';
 
     /* Look for = sign */
-    p = strchr(linebuf, '=');
-
-    /* If no '=' exit */
-    if (!p)
+    if ((p = strchr(linebuf, '=')) == NULL)
         return 0;
-
     *p++ = '\0';
 
     *pkw = linebuf;
     *pval = p;
-
-    /* Remove spaces from keyword and value */
     remove_space(pkw);
     remove_space(pval);
-
     return 1;
 }
 
@@ -92,6 +84,7 @@ static unsigned char* unescape(const char *input, size_t input_len,
 {
     unsigned char *ret, *p;
     size_t i;
+
     if (input_len == 0) {
         *out_len = 0;
         return OPENSSL_zalloc(1);
@@ -166,10 +159,9 @@ static int test_bin(const char *value, unsigned char **buf, size_t *buflen)
     }
 
     /* Otherwise assume as hex literal and convert it to binary buffer */
-    *buf = OPENSSL_hexstr2buf(value, &amp;len);
-    if (!*buf) {
-        fprintf(stderr, &quot;Value=%s\n&quot;, value);
-        ERR_print_errors_fp(stderr);
+    if (!TEST_ptr(*buf = OPENSSL_hexstr2buf(value, &amp;len))) {
+        TEST_info(&quot;Cannot convert %s&quot;, value);
+        ERR_print_errors(bio_err);
         return -1;
     }
     /* Size of input buffer means we'll never overflow */
@@ -182,19 +174,20 @@ static int test_bin(const char *value, unsigned char **buf, size_t *buflen)
 static int test_uint64(const char *value, uint64_t *pr)
 {
     const char *p = value;
-    if (!*p) {
-        fprintf(stderr, &quot;Invalid empty integer value\n&quot;);
+
+    if (!TEST_true(*p)) {
+        TEST_info(&quot;Invalid empty integer value&quot;);
         return -1;
     }
     *pr = 0;
     while (*p) {
-        if (*pr &gt; UINT64_MAX/10) {
-            fprintf(stderr, &quot;Integer string overflow value=%s\n&quot;, value);
+        if (*pr &gt; UINT64_MAX / 10) {
+            TEST_error(&quot;Integer overflow in string %s&quot;, value);
             return -1;
         }
         *pr *= 10;
-        if (*p &lt; '0' || *p &gt; '9') {
-            fprintf(stderr, &quot;Invalid integer string value=%s\n&quot;, value);
+        if (!TEST_true(isdigit(*p))) {
+            TEST_error(&quot;Invalid character in string %s&quot;, value);
             return -1;
         }
         *pr += *p - '0';
@@ -202,19 +195,26 @@ static int test_uint64(const char *value, uint64_t *pr)
     }
     return 1;
 }
+
+static int compare_mem(unsigned char *expected, size_t expected_len,
+                       unsigned char *got, size_t  got_len)
+{
+    if (!TEST_mem_eq(expected, expected_len, got, got_len))
+        return 0;
+    return 1;
+}
 #endif
 
+typedef struct evp_test_method_st EVP_TEST_METHOD;
+
 /* Structure holding test information */
-struct evp_test {
+typedef struct evp_test_st {
     /* file being read */
     BIO *in;
     /* temp memory BIO for reading in keys */
     BIO *key;
-    /* List of public and private keys */
-    struct key_list *private;
-    struct key_list *public;
     /* method for this test */
-    const struct evp_test_method *meth;
+    const EVP_TEST_METHOD *meth;
     /* current line being processed */
     unsigned int line;
     /* start line of current test */
@@ -233,49 +233,53 @@ struct evp_test {
     int errors;
     /* Number of tests skipped */
     int nskip;
-    /* If output mismatch expected and got value */
-    unsigned char *out_received;
-    size_t out_received_len;
-    unsigned char *out_expected;
-    size_t out_expected_len;
     /* test specific data */
     void *data;
     /* Current test should be skipped */
     int skip;
-};
+} EVP_TEST;
 
-struct key_list {
+/*
+ * Linked list of named keys.
+ */
+typedef struct key_list_st {
     char *name;
     EVP_PKEY *key;
-    struct key_list *next;
-};
+    struct key_list_st *next;
+} KEY_LIST;
 
-/* Test method structure */
-struct evp_test_method {
+/* List of public and private keys */
+static KEY_LIST *private_keys;
+static KEY_LIST *public_keys;
+
+/*
+ * Test method structure
+ */
+struct evp_test_method_st {
     /* Name of test as it appears in file */
     const char *name;
     /* Initialise test for &quot;alg&quot; */
-    int (*init) (struct evp_test * t, const char *alg);
+    int (*init) (EVP_TEST * t, const char *alg);
     /* Clean up method */
-    void (*cleanup) (struct evp_test * t);
+    void (*cleanup) (EVP_TEST * t);
     /* Test specific name value pair processing */
-    int (*parse) (struct evp_test * t, const char *name, const char *value);
+    int (*parse) (EVP_TEST * t, const char *name, const char *value);
     /* Run the test itself */
-    int (*run_test) (struct evp_test * t);
+    int (*run_test) (EVP_TEST * t);
 };
 
-static const struct evp_test_method digest_test_method, cipher_test_method;
-static const struct evp_test_method mac_test_method;
-static const struct evp_test_method psign_test_method, pverify_test_method;
-static const struct evp_test_method pdecrypt_test_method;
-static const struct evp_test_method pverify_recover_test_method;
-static const struct evp_test_method pderive_test_method;
-static const struct evp_test_method pbe_test_method;
-static const struct evp_test_method encode_test_method;
-static const struct evp_test_method kdf_test_method;
-static const struct evp_test_method keypair_test_method;
-
-static const struct evp_test_method *evp_test_list[] = {
+static const EVP_TEST_METHOD digest_test_method, cipher_test_method;
+static const EVP_TEST_METHOD mac_test_method;
+static const EVP_TEST_METHOD psign_test_method, pverify_test_method;
+static const EVP_TEST_METHOD pdecrypt_test_method;
+static const EVP_TEST_METHOD pverify_recover_test_method;
+static const EVP_TEST_METHOD pderive_test_method;
+static const EVP_TEST_METHOD pbe_test_method;
+static const EVP_TEST_METHOD encode_test_method;
+static const EVP_TEST_METHOD kdf_test_method;
+static const EVP_TEST_METHOD keypair_test_method;
+
+static const EVP_TEST_METHOD *evp_test_list[] = {
     &amp;digest_test_method,
     &amp;cipher_test_method,
     &amp;mac_test_method,
@@ -291,9 +295,9 @@ static const struct evp_test_method *evp_test_list[] = {
     NULL
 };
 
-static const struct evp_test_method *evp_find_test(const char *name)
+static const EVP_TEST_METHOD *evp_find_test(const char *name)
 {
-    const struct evp_test_method **tt;
+    const EVP_TEST_METHOD **tt;
 
     for (tt = evp_test_list; *tt; tt++) {
         if (strcmp(name, (*tt)-&gt;name) == 0)
@@ -302,16 +306,7 @@ static const struct evp_test_method *evp_find_test(const char *name)
     return NULL;
 }
 
-static void hex_print(const char *name, const unsigned char *buf, size_t len)
-{
-    size_t i;
-    fprintf(stderr, &quot;%s &quot;, name);
-    for (i = 0; i &lt; len; i++)
-        fprintf(stderr, &quot;%02X&quot;, buf[i]);
-    fputs(&quot;\n&quot;, stderr);
-}
-
-static void free_expected(struct evp_test *t)
+static void clear_test(EVP_TEST *t)
 {
     OPENSSL_free(t-&gt;expected_err);
     t-&gt;expected_err = NULL;
@@ -319,52 +314,43 @@ static void free_expected(struct evp_test *t)
     t-&gt;func = NULL;
     OPENSSL_free(t-&gt;reason);
     t-&gt;reason = NULL;
-    OPENSSL_free(t-&gt;out_expected);
-    OPENSSL_free(t-&gt;out_received);
-    t-&gt;out_expected = NULL;
-    t-&gt;out_received = NULL;
-    t-&gt;out_expected_len = 0;
-    t-&gt;out_received_len = 0;
-    /* Literals. */
+    /* Text literal. */
     t-&gt;err = NULL;
 }
 
-static void print_expected(struct evp_test *t)
-{
-    if (t-&gt;out_expected == NULL &amp;&amp; t-&gt;out_received == NULL)
-        return;
-    hex_print(&quot;Expected:&quot;, t-&gt;out_expected, t-&gt;out_expected_len);
-    hex_print(&quot;Got:     &quot;, t-&gt;out_received, t-&gt;out_received_len);
-    free_expected(t);
-}
-
-static int check_test_error(struct evp_test *t)
+/*
+ * Check for errors in the test structure; return 1 if okay, else 0.
+ */
+static int check_test_error(EVP_TEST *t)
 {
     unsigned long err;
     const char *func;
     const char *reason;
-    if (!t-&gt;err &amp;&amp; !t-&gt;expected_err)
+
+    if (t-&gt;err == NULL &amp;&amp; t-&gt;expected_err == NULL)
         return 1;
-    if (t-&gt;err &amp;&amp; !t-&gt;expected_err) {
+    if (t-&gt;err != NULL &amp;&amp; t-&gt;expected_err == NULL) {
         if (t-&gt;aux_err != NULL) {
-            fprintf(stderr, &quot;Test line %d(%s): unexpected error %s\n&quot;,
-                    t-&gt;start_line, t-&gt;aux_err, t-&gt;err);
+            TEST_info(&quot;Above error from the test at %s:%d &quot;
+                      &quot;(%s) unexpected error %s&quot;,
+                      current_test_file, t-&gt;start_line, t-&gt;aux_err, t-&gt;err);
         } else {
-            fprintf(stderr, &quot;Test line %d: unexpected error %s\n&quot;,
-                    t-&gt;start_line, t-&gt;err);
+            TEST_info(&quot;Above error from the test at %s:%d &quot;
+                      &quot;unexpected error %s&quot;,
+                      current_test_file, t-&gt;start_line, t-&gt;err);
         }
-        print_expected(t);
+        clear_test(t);
         return 0;
     }
-    if (!t-&gt;err &amp;&amp; t-&gt;expected_err) {
-        fprintf(stderr, &quot;Test line %d: succeeded expecting %s\n&quot;,
-                t-&gt;start_line, t-&gt;expected_err);
+    if (t-&gt;err == NULL &amp;&amp; t-&gt;expected_err != NULL) {
+        TEST_info(&quot;Test line %d: succeeded expecting %s&quot;,
+                  t-&gt;start_line, t-&gt;expected_err);
         return 0;
     }
 
     if (strcmp(t-&gt;err, t-&gt;expected_err) != 0) {
-        fprintf(stderr, &quot;Test line %d: expecting %s got %s\n&quot;,
-                t-&gt;start_line, t-&gt;expected_err, t-&gt;err);
+        TEST_info(&quot;Test line %d: expecting %s got %s&quot;,
+                  t-&gt;start_line, t-&gt;expected_err, t-&gt;err);
         return 0;
     }
 
@@ -372,55 +358,57 @@ static int check_test_error(struct evp_test *t)
         return 1;
 
     if (t-&gt;func == NULL || t-&gt;reason == NULL) {
-        fprintf(stderr, &quot;Test line %d: missing function or reason code\n&quot;,
-                t-&gt;start_line);
+        TEST_info(&quot;Test line %d: missing function or reason code&quot;,
+                  t-&gt;start_line);
         return 0;
     }
 
     err = ERR_peek_error();
     if (err == 0) {
-        fprintf(stderr, &quot;Test line %d, expected error \&quot;%s:%s\&quot; not set\n&quot;,
-                t-&gt;start_line, t-&gt;func, t-&gt;reason);
+        TEST_info(&quot;Test line %d, expected error \&quot;%s:%s\&quot; not set&quot;,
+                  t-&gt;start_line, t-&gt;func, t-&gt;reason);
         return 0;
     }
 
     func = ERR_func_error_string(err);
     reason = ERR_reason_error_string(err);
-
     if (func == NULL &amp;&amp; reason == NULL) {
-        fprintf(stderr, &quot;Test line %d: expected error \&quot;%s:%s\&quot;, no strings available.  Skipping...\n&quot;,
-                t-&gt;start_line, t-&gt;func, t-&gt;reason);
+        TEST_info(&quot;Test line %d: expected error \&quot;%s:%s\&quot;,&quot;
+                  &quot; no strings available.  Skipping...\n&quot;,
+                  t-&gt;start_line, t-&gt;func, t-&gt;reason);
         return 1;
     }
 
     if (strcmp(func, t-&gt;func) == 0 &amp;&amp; strcmp(reason, t-&gt;reason) == 0)
         return 1;
 
-    fprintf(stderr, &quot;Test line %d: expected error \&quot;%s:%s\&quot;, got \&quot;%s:%s\&quot;\n&quot;,
-            t-&gt;start_line, t-&gt;func, t-&gt;reason, func, reason);
+    TEST_info(&quot;Test line %d: expected error \&quot;%s:%s\&quot;, got \&quot;%s:%s\&quot;&quot;,
+              t-&gt;start_line, t-&gt;func, t-&gt;reason, func, reason);
 
     return 0;
 }
 
-/* Setup a new test, run any existing test */
-
-static int setup_test(struct evp_test *t, const struct evp_test_method *tmeth)
+/*
+ * Setup a new test, run any existing test. Log a message and return 0
+ * on error.
+ */
+static int run_and_get_next(EVP_TEST *t, const EVP_TEST_METHOD *tmeth)
 {
     /* If we already have a test set up run it */
     if (t-&gt;meth) {
         t-&gt;ntests++;
         if (t-&gt;skip) {
+            /*TEST_info(&quot;Line %d skipped %s test&quot;, t-&gt;start_line, t-&gt;meth-&gt;name);
+             */
             t-&gt;nskip++;
         } else {
             /* run the test */
             if (t-&gt;err == NULL &amp;&amp; t-&gt;meth-&gt;run_test(t) != 1) {
-                fprintf(stderr, &quot;%s test error line %d\n&quot;,
-                        t-&gt;meth-&gt;name, t-&gt;start_line);
+                TEST_info(&quot;Line %d error %s&quot;, t-&gt;start_line, t-&gt;meth-&gt;name);
                 return 0;
             }
             if (!check_test_error(t)) {
-                if (t-&gt;err)
-                    ERR_print_errors_fp(stderr);
+                test_openssl_errors();
                 t-&gt;errors++;
             }
         }
@@ -431,15 +419,13 @@ static int setup_test(struct evp_test *t, const struct evp_test_method *tmeth)
             OPENSSL_free(t-&gt;data);
             t-&gt;data = NULL;
         }
-        OPENSSL_free(t-&gt;expected_err);
-        t-&gt;expected_err = NULL;
-        free_expected(t);
+        clear_test(t);
     }
     t-&gt;meth = tmeth;
     return 1;
 }
 
-static int find_key(EVP_PKEY **ppk, const char *name, struct key_list *lst)
+static int find_key(EVP_PKEY **ppk, const char *name, KEY_LIST *lst)
 {
     for (; lst; lst = lst-&gt;next) {
         if (strcmp(lst-&gt;name, name) == 0) {
@@ -451,10 +437,11 @@ static int find_key(EVP_PKEY **ppk, const char *name, struct key_list *lst)
     return 0;
 }
 
-static void free_key_list(struct key_list *lst)
+static void free_key_list(KEY_LIST *lst)
 {
     while (lst != NULL) {
-        struct key_list *ltmp;
+        KEY_LIST *ltmp;
+
         EVP_PKEY_free(lst-&gt;key);
         OPENSSL_free(lst-&gt;name);
         ltmp = lst-&gt;next;
@@ -466,8 +453,9 @@ static void free_key_list(struct key_list *lst)
 static int check_unsupported()
 {
     long err = ERR_peek_error();
+
     if (ERR_GET_LIB(err) == ERR_LIB_EVP
-        &amp;&amp; ERR_GET_REASON(err) == EVP_R_UNSUPPORTED_ALGORITHM) {
+            &amp;&amp; ERR_GET_REASON(err) == EVP_R_UNSUPPORTED_ALGORITHM) {
         ERR_clear_error();
         return 1;
     }
@@ -487,40 +475,40 @@ static int check_unsupported()
 }
 
 
-static int read_key(struct evp_test *t)
+static int read_key(EVP_TEST *t)
 {
     char tmpbuf[80];
-    if (t-&gt;key == NULL)
-        t-&gt;key = BIO_new(BIO_s_mem());
-    else if (BIO_reset(t-&gt;key) &lt;= 0)
-        return 0;
+
     if (t-&gt;key == NULL) {
-        fprintf(stderr, &quot;Error allocating key memory BIO\n&quot;);
+        if (!TEST_ptr(t-&gt;key = BIO_new(BIO_s_mem())))
+            return 0;
+    } else if (!TEST_int_gt(BIO_reset(t-&gt;key), 0)) {
         return 0;
     }
+
     /* Read to PEM end line and place content in memory BIO */
     while (BIO_gets(t-&gt;in, tmpbuf, sizeof(tmpbuf))) {
         t-&gt;line++;
-        if (BIO_puts(t-&gt;key, tmpbuf) &lt;= 0) {
-            fprintf(stderr, &quot;Error writing to key memory BIO\n&quot;);
+        if (!TEST_int_gt(BIO_puts(t-&gt;key, tmpbuf), 0))
             return 0;
-        }
         if (strncmp(tmpbuf, &quot;-----END&quot;, 8) == 0)
             return 1;
     }
-    fprintf(stderr, &quot;Can't find key end\n&quot;);
+    TEST_error(&quot;Can't find key end&quot;);
     return 0;
 }
 
-static int process_test(struct evp_test *t, char *buf, int verbose)
+/*
+ * Parse a line into the current test |t|.  Return 0 on error.
+ */
+static int parse_test_line(EVP_TEST *t, char *buf)
 {
     char *keyword = NULL, *value = NULL;
-    int rv = 0, add_key = 0;
-    struct key_list **lst = NULL, *key = NULL;
+    int add_key = 0;
+    KEY_LIST **lst = NULL, *key = NULL;
     EVP_PKEY *pk = NULL;
-    const struct evp_test_method *tmeth = NULL;
-    if (verbose)
-        fputs(buf, stdout);
+    const EVP_TEST_METHOD *tmeth = NULL;
+
     if (!parse_line(&amp;keyword, &amp;value, buf))
         return 1;
     if (strcmp(keyword, &quot;PrivateKey&quot;) == 0) {
@@ -528,11 +516,11 @@ static int process_test(struct evp_test *t, char *buf, int verbose)
             return 0;
         pk = PEM_read_bio_PrivateKey(t-&gt;key, NULL, 0, NULL);
         if (pk == NULL &amp;&amp; !check_unsupported()) {
-            fprintf(stderr, &quot;Error reading private key %s\n&quot;, value);
+            TEST_info(&quot;Error reading private key %s&quot;, value);
             ERR_print_errors_fp(stderr);
             return 0;
         }
-        lst = &amp;t-&gt;private;
+        lst = &amp;private_keys;
         add_key = 1;
     }
     if (strcmp(keyword, &quot;PublicKey&quot;) == 0) {
@@ -540,23 +528,22 @@ static int process_test(struct evp_test *t, char *buf, int verbose)
             return 0;
         pk = PEM_read_bio_PUBKEY(t-&gt;key, NULL, 0, NULL);
         if (pk == NULL &amp;&amp; !check_unsupported()) {
-            fprintf(stderr, &quot;Error reading public key %s\n&quot;, value);
+            TEST_info(&quot;Error reading public key %s&quot;, value);
             ERR_print_errors_fp(stderr);
             return 0;
         }
-        lst = &amp;t-&gt;public;
+        lst = &amp;public_keys;
         add_key = 1;
     }
     /* If we have a key add to list */
     if (add_key) {
         if (find_key(NULL, value, *lst)) {
-            fprintf(stderr, &quot;Duplicate key %s\n&quot;, value);
+            TEST_info(&quot;Duplicate key %s&quot;, value);
             return 0;
         }
-        key = OPENSSL_malloc(sizeof(*key));
-        if (!key)
+        if (!TEST_ptr(key = OPENSSL_malloc(sizeof(*key)))
+                || !TEST_ptr(key-&gt;name = OPENSSL_strdup(value)))
             return 0;
-        key-&gt;name = OPENSSL_strdup(value);
         key-&gt;key = pk;
         key-&gt;next = *lst;
         *lst = key;
@@ -564,146 +551,60 @@ static int process_test(struct evp_test *t, char *buf, int verbose)
     }
 
     /* See if keyword corresponds to a test start */
-    tmeth = evp_find_test(keyword);
-    if (tmeth) {
-        if (!setup_test(t, tmeth))
+    if ((tmeth = evp_find_test(keyword)) != NULL) {
+        if (!run_and_get_next(t, tmeth))
             return 0;
         t-&gt;start_line = t-&gt;line;
         t-&gt;skip = 0;
         if (!tmeth-&gt;init(t, value)) {
-            fprintf(stderr, &quot;Unknown %s: %s\n&quot;, keyword, value);
+            TEST_info(&quot;Unknown %s: %s&quot;, keyword, value);
             return 0;
         }
         return 1;
-    } else if (t-&gt;skip) {
+    }
+    if (t-&gt;skip)
         return 1;
-    } else if (strcmp(keyword, &quot;Result&quot;) == 0) {
+    if (strcmp(keyword, &quot;Result&quot;) == 0) {
         if (t-&gt;expected_err) {
-            fprintf(stderr, &quot;Line %d: multiple result lines\n&quot;, t-&gt;line);
+            TEST_info(&quot;Line %d: multiple result lines&quot;, t-&gt;line);
             return 0;
         }
-        t-&gt;expected_err = OPENSSL_strdup(value);
-        if (t-&gt;expected_err == NULL)
+        if (!TEST_ptr(t-&gt;expected_err = OPENSSL_strdup(value)))
             return 0;
     } else if (strcmp(keyword, &quot;Function&quot;) == 0) {
         if (t-&gt;func != NULL) {
-            fprintf(stderr, &quot;Line %d: multiple function lines\n&quot;, t-&gt;line);
+            TEST_info(&quot;Line %d: multiple function lines\n&quot;, t-&gt;line);
             return 0;
         }
-        t-&gt;func = OPENSSL_strdup(value);
-        if (t-&gt;func == NULL)
+        if (!TEST_ptr(t-&gt;func = OPENSSL_strdup(value)))
             return 0;
     } else if (strcmp(keyword, &quot;Reason&quot;) == 0) {
         if (t-&gt;reason != NULL) {
-            fprintf(stderr, &quot;Line %d: multiple reason lines\n&quot;, t-&gt;line);
+            TEST_info(&quot;Line %d: multiple reason lines&quot;, t-&gt;line);
             return 0;
         }
-        t-&gt;reason = OPENSSL_strdup(value);
-        if (t-&gt;reason == NULL)
+        if (!TEST_ptr(t-&gt;reason = OPENSSL_strdup(value)))
             return 0;
     } else {
         /* Must be test specific line: try to parse it */
-        if (t-&gt;meth)
-            rv = t-&gt;meth-&gt;parse(t, keyword, value);
-
-        if (rv == 0)
-            fprintf(stderr, &quot;line %d: unexpected keyword %s\n&quot;,
-                    t-&gt;line, keyword);
+        int rv = t-&gt;meth == NULL ? 0 : t-&gt;meth-&gt;parse(t, keyword, value);
 
-        if (rv &lt; 0)
-            fprintf(stderr, &quot;line %d: error processing keyword %s\n&quot;,
-                    t-&gt;line, keyword);
-        if (rv &lt;= 0)
+        if (rv == 0) {
+            TEST_info(&quot;Line %d: unknown keyword %s&quot;, t-&gt;line, keyword);
             return 0;
+        }
+        if (rv &lt; 0) {
+            TEST_info(&quot;Line %d: error processing keyword %s\n&quot;,
+                      t-&gt;line, keyword);
+            return 0;
+        }
     }
     return 1;
 }
 
-static int check_var_length_output(struct evp_test *t,
-                                   const unsigned char *expected,
-                                   size_t expected_len,
-                                   const unsigned char *received,
-                                   size_t received_len)
-{
-    if (expected_len == received_len &amp;&amp;
-        memcmp(expected, received, expected_len) == 0) {
-        return 0;
-    }
-
-    /* The result printing code expects a non-NULL buffer. */
-    t-&gt;out_expected = OPENSSL_memdup(expected, expected_len ? expected_len : 1);
-    t-&gt;out_expected_len = expected_len;
-    t-&gt;out_received = OPENSSL_memdup(received, received_len ? received_len : 1);
-    t-&gt;out_received_len = received_len;
-    if (t-&gt;out_expected == NULL || t-&gt;out_received == NULL) {
-        fprintf(stderr, &quot;Memory allocation error!\n&quot;);
-        exit(1);
-    }
-    return 1;
-}
-
-static int check_output(struct evp_test *t,
-                        const unsigned char *expected,
-                        const unsigned char *received,
-                        size_t len)
-{
-    return check_var_length_output(t, expected, len, received, len);
-}
-
-int main(int argc, char **argv)
-{
-    BIO *in = NULL;
-    char buf[10240];
-    struct evp_test t;
-
-    if (argc != 2) {
-        fprintf(stderr, &quot;usage: evp_test testfile.txt\n&quot;);
-        return 1;
-    }
-
-    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
-
-    memset(&amp;t, 0, sizeof(t));
-    t.start_line = -1;
-    in = BIO_new_file(argv[1], &quot;rb&quot;);
-    if (in == NULL) {
-        fprintf(stderr, &quot;Can't open %s for reading\n&quot;, argv[1]);
-        return 1;
-    }
-    t.in = in;
-    t.err = NULL;
-    while (BIO_gets(in, buf, sizeof(buf))) {
-        t.line++;
-        if (!process_test(&amp;t, buf, 0))
-            exit(1);
-    }
-    /* Run any final test we have */
-    if (!setup_test(&amp;t, NULL))
-        exit(1);
-    fprintf(stderr, &quot;%d tests completed with %d errors, %d skipped\n&quot;,
-            t.ntests, t.errors, t.nskip);
-    free_key_list(t.public);
-    free_key_list(t.private);
-    BIO_free(t.key);
-    BIO_free(in);
-
-#ifndef OPENSSL_NO_CRYPTO_MDEBUG
-    if (CRYPTO_mem_leaks_fp(stderr) &lt;= 0)
-        return 1;
-#endif
-    if (t.errors)
-        return 1;
-    return 0;
-}
-
-static void test_free(void *d)
-{
-    OPENSSL_free(d);
-}
-
 /* Message digest tests */
 
-struct digest_data {
+typedef struct digest_data_st {
     /* Digest this test is for */
     const EVP_MD *digest;
     /* Input to digest */
@@ -714,12 +615,13 @@ struct digest_data {
     /* Expected output */
     unsigned char *output;
     size_t output_len;
-};
+} DIGEST_DATA;
 
-static int digest_test_init(struct evp_test *t, const char *alg)
+static int digest_test_init(EVP_TEST *t, const char *alg)
 {
     const EVP_MD *digest;
-    struct digest_data *mdat;
+    DIGEST_DATA *mdat;
+
     digest = EVP_get_digestbyname(alg);
     if (!digest) {
         /* If alg has an OID assume disabled algorithm */
@@ -729,26 +631,26 @@ static int digest_test_init(struct evp_test *t, const char *alg)
         }
         return 0;
     }
-    mdat = OPENSSL_malloc(sizeof(*mdat));
+    mdat = OPENSSL_zalloc(sizeof(*mdat));
     mdat-&gt;digest = digest;
-    mdat-&gt;input = NULL;
-    mdat-&gt;output = NULL;
     mdat-&gt;nrpt = 1;
     t-&gt;data = mdat;
     return 1;
 }
 
-static void digest_test_cleanup(struct evp_test *t)
+static void digest_test_cleanup(EVP_TEST *t)
 {
-    struct digest_data *mdat = t-&gt;data;
-    test_free(mdat-&gt;input);
-    test_free(mdat-&gt;output);
+    DIGEST_DATA *mdat = t-&gt;data;
+
+    OPENSSL_free(mdat-&gt;input);
+    OPENSSL_free(mdat-&gt;output);
 }
 
-static int digest_test_parse(struct evp_test *t,
+static int digest_test_parse(EVP_TEST *t,
                              const char *keyword, const char *value)
 {
-    struct digest_data *mdata = t-&gt;data;
+    DIGEST_DATA *mdata = t-&gt;data;
+
     if (strcmp(keyword, &quot;Input&quot;) == 0)
         return test_bin(value, &amp;mdata-&gt;input, &amp;mdata-&gt;input_len);
     if (strcmp(keyword, &quot;Output&quot;) == 0)
@@ -763,42 +665,47 @@ static int digest_test_parse(struct evp_test *t,
     return 0;
 }
 
-static int digest_test_run(struct evp_test *t)
+static int digest_test_run(EVP_TEST *t)
 {
-    struct digest_data *mdata = t-&gt;data;
+    DIGEST_DATA *mdata = t-&gt;data;
     size_t i;
-    const char *err = &quot;INTERNAL_ERROR&quot;;
     EVP_MD_CTX *mctx;
     unsigned char md[EVP_MAX_MD_SIZE];
     unsigned int md_len;
-    mctx = EVP_MD_CTX_new();
-    if (!mctx)
+
+    t-&gt;err = &quot;TEST_FAILURE&quot;;
+    if (!TEST_ptr(mctx = EVP_MD_CTX_new()))
         goto err;
-    err = &quot;DIGESTINIT_ERROR&quot;;
-    if (!EVP_DigestInit_ex(mctx, mdata-&gt;digest, NULL))
+
+    if (!EVP_DigestInit_ex(mctx, mdata-&gt;digest, NULL)) {
+        t-&gt;err = &quot;DIGESTINIT_ERROR&quot;;
         goto err;
-    err = &quot;DIGESTUPDATE_ERROR&quot;;
-    for (i = 0; i &lt; mdata-&gt;nrpt; i++) {
-        if (!EVP_DigestUpdate(mctx, mdata-&gt;input, mdata-&gt;input_len))
-            goto err;
     }
-    err = &quot;DIGESTFINAL_ERROR&quot;;
-    if (!EVP_DigestFinal(mctx, md, &amp;md_len))
+    for (i = 0; i &lt; mdata-&gt;nrpt; i++)
+        if (!EVP_DigestUpdate(mctx, mdata-&gt;input, mdata-&gt;input_len)) {
+            t-&gt;err = &quot;DIGESTUPDATE_ERROR&quot;;
+            goto err;
+        }
+    if (!EVP_DigestFinal(mctx, md, &amp;md_len)) {
+        t-&gt;err = &quot;DIGESTFINAL_ERROR&quot;;
         goto err;
-    err = &quot;DIGEST_LENGTH_MISMATCH&quot;;
-    if (md_len != mdata-&gt;output_len)
+    }
+    if (md_len != mdata-&gt;output_len) {
+        t-&gt;err = &quot;DIGEST_LENGTH_MISMATCH&quot;;
         goto err;
-    err = &quot;DIGEST_MISMATCH&quot;;
-    if (check_output(t, mdata-&gt;output, md, md_len))
+    }
+    if (!compare_mem(mdata-&gt;output, mdata-&gt;output_len, md, md_len)) {
+        t-&gt;err = &quot;DIGEST_MISMATCH&quot;;
         goto err;
-    err = NULL;
+    }
+    t-&gt;err = NULL;
+
  err:
     EVP_MD_CTX_free(mctx);
-    t-&gt;err = err;
     return 1;
 }
 
-static const struct evp_test_method digest_test_method = {
+static const EVP_TEST_METHOD digest_test_method = {
     &quot;Digest&quot;,
     digest_test_init,
     digest_test_cleanup,
@@ -807,7 +714,7 @@ static const struct evp_test_method digest_test_method = {
 };
 
 /* Cipher tests */
-struct cipher_data {
+typedef struct cipher_data_st {
     const EVP_CIPHER *cipher;
     int enc;
     /* EVP_CIPH_GCM_MODE, EVP_CIPH_CCM_MODE or EVP_CIPH_OCB_MODE if AEAD */
@@ -825,12 +732,13 @@ struct cipher_data {
     size_t aad_len;
     unsigned char *tag;
     size_t tag_len;
-};
+} CIPHER_DATA;
 
-static int cipher_test_init(struct evp_test *t, const char *alg)
+static int cipher_test_init(EVP_TEST *t, const char *alg)
 {
     const EVP_CIPHER *cipher;
-    struct cipher_data *cdat = t-&gt;data;
+    CIPHER_DATA *cdat = t-&gt;data;
+
     cipher = EVP_get_cipherbyname(alg);
     if (!cipher) {
         /* If alg has an OID assume disabled algorithm */
@@ -862,21 +770,23 @@ static int cipher_test_init(struct evp_test *t, const char *alg)
     return 1;
 }
 
-static void cipher_test_cleanup(struct evp_test *t)
+static void cipher_test_cleanup(EVP_TEST *t)
 {
-    struct cipher_data *cdat = t-&gt;data;
-    test_free(cdat-&gt;key);
-    test_free(cdat-&gt;iv);
-    test_free(cdat-&gt;ciphertext);
-    test_free(cdat-&gt;plaintext);
-    test_free(cdat-&gt;aad);
-    test_free(cdat-&gt;tag);
+    CIPHER_DATA *cdat = t-&gt;data;
+
+    OPENSSL_free(cdat-&gt;key);
+    OPENSSL_free(cdat-&gt;iv);
+    OPENSSL_free(cdat-&gt;ciphertext);
+    OPENSSL_free(cdat-&gt;plaintext);
+    OPENSSL_free(cdat-&gt;aad);
+    OPENSSL_free(cdat-&gt;tag);
 }
 
-static int cipher_test_parse(struct evp_test *t, const char *keyword,
+static int cipher_test_parse(EVP_TEST *t, const char *keyword,
                              const char *value)
 {
-    struct cipher_data *cdat = t-&gt;data;
+    CIPHER_DATA *cdat = t-&gt;data;
+
     if (strcmp(keyword, &quot;Key&quot;) == 0)
         return test_bin(value, &amp;cdat-&gt;key, &amp;cdat-&gt;key_len);
     if (strcmp(keyword, &quot;IV&quot;) == 0)
@@ -904,18 +814,17 @@ static int cipher_test_parse(struct evp_test *t, const char *keyword,
     return 0;
 }
 
-static int cipher_test_enc(struct evp_test *t, int enc,
+static int cipher_test_enc(EVP_TEST *t, int enc,
                            size_t out_misalign, size_t inp_misalign, int frag)
 {
-    struct cipher_data *cdat = t-&gt;data;
+    CIPHER_DATA *cdat = t-&gt;data;
     unsigned char *in, *out, *tmp = NULL;
     size_t in_len, out_len, donelen = 0;
-    int tmplen, chunklen, tmpflen;
+    int ok = 0, tmplen, chunklen, tmpflen;
     EVP_CIPHER_CTX *ctx = NULL;
-    const char *err;
-    err = &quot;INTERNAL_ERROR&quot;;
-    ctx = EVP_CIPHER_CTX_new();
-    if (!ctx)
+
+    t-&gt;err = &quot;TEST_FAILURE&quot;;
+    if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new()))
         goto err;
     EVP_CIPHER_CTX_set_flags(ctx, EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
     if (enc) {
@@ -954,17 +863,21 @@ static int cipher_test_enc(struct evp_test *t, int enc,
         in = memcpy(tmp + out_misalign + in_len + 2 * EVP_MAX_BLOCK_LENGTH +
                     inp_misalign, in, in_len);
     }
-    err = &quot;CIPHERINIT_ERROR&quot;;
-    if (!EVP_CipherInit_ex(ctx, cdat-&gt;cipher, NULL, NULL, NULL, enc))
+    if (!EVP_CipherInit_ex(ctx, cdat-&gt;cipher, NULL, NULL, NULL, enc)) {
+        t-&gt;err = &quot;CIPHERINIT_ERROR&quot;;
         goto err;
-    err = &quot;INVALID_IV_LENGTH&quot;;
+    }
     if (cdat-&gt;iv) {
         if (cdat-&gt;aead) {
             if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN,
-                                     cdat-&gt;iv_len, 0))
+                                     cdat-&gt;iv_len, 0)) {
+                t-&gt;err = &quot;INVALID_IV_LENGTH&quot;;
                 goto err;
-        } else if (cdat-&gt;iv_len != (size_t)EVP_CIPHER_CTX_iv_length(ctx))
+            }
+        } else if (cdat-&gt;iv_len != (size_t)EVP_CIPHER_CTX_iv_length(ctx)) {
+            t-&gt;err = &quot;INVALID_IV_LENGTH&quot;;
             goto err;
+        }
     }
     if (cdat-&gt;aead) {
         unsigned char *tag;
@@ -973,10 +886,10 @@ static int cipher_test_enc(struct evp_test *t, int enc,
          * set tag length and value.
          */
         if (enc || cdat-&gt;aead == EVP_CIPH_OCB_MODE) {
-            err = &quot;TAG_LENGTH_SET_ERROR&quot;;
+            t-&gt;err = &quot;TAG_LENGTH_SET_ERROR&quot;;
             tag = NULL;
         } else {
-            err = &quot;TAG_SET_ERROR&quot;;
+            t-&gt;err = &quot;TAG_SET_ERROR&quot;;
             tag = cdat-&gt;tag;
         }
         if (tag || cdat-&gt;aead != EVP_CIPH_GCM_MODE) {
@@ -986,29 +899,31 @@ static int cipher_test_enc(struct evp_test *t, int enc,
         }
     }
 
-    err = &quot;INVALID_KEY_LENGTH&quot;;
-    if (!EVP_CIPHER_CTX_set_key_length(ctx, cdat-&gt;key_len))
+    if (!EVP_CIPHER_CTX_set_key_length(ctx, cdat-&gt;key_len)) {
+        t-&gt;err = &quot;INVALID_KEY_LENGTH&quot;;
         goto err;
-    err = &quot;KEY_SET_ERROR&quot;;
-    if (!EVP_CipherInit_ex(ctx, NULL, NULL, cdat-&gt;key, cdat-&gt;iv, -1))
+    }
+    if (!EVP_CipherInit_ex(ctx, NULL, NULL, cdat-&gt;key, cdat-&gt;iv, -1)) {
+        t-&gt;err = &quot;KEY_SET_ERROR&quot;;
         goto err;
+    }
 
     if (!enc &amp;&amp; cdat-&gt;aead == EVP_CIPH_OCB_MODE) {
         if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,
                                  cdat-&gt;tag_len, cdat-&gt;tag)) {
-            err = &quot;TAG_SET_ERROR&quot;;
+            t-&gt;err = &quot;TAG_SET_ERROR&quot;;
             goto err;
         }
     }
 
     if (cdat-&gt;aead == EVP_CIPH_CCM_MODE) {
         if (!EVP_CipherUpdate(ctx, NULL, &amp;tmplen, NULL, out_len)) {
-            err = &quot;CCM_PLAINTEXT_LENGTH_SET_ERROR&quot;;
+            t-&gt;err = &quot;CCM_PLAINTEXT_LENGTH_SET_ERROR&quot;;
             goto err;
         }
     }
     if (cdat-&gt;aad) {
-        err = &quot;AAD_SET_ERROR&quot;;
+        t-&gt;err = &quot;AAD_SET_ERROR&quot;;
         if (!frag) {
             if (!EVP_CipherUpdate(ctx, NULL, &amp;chunklen, cdat-&gt;aad,
                                   cdat-&gt;aad_len))
@@ -1035,7 +950,7 @@ static int cipher_test_enc(struct evp_test *t, int enc,
         }
     }
     EVP_CIPHER_CTX_set_padding(ctx, 0);
-    err = &quot;CIPHERUPDATE_ERROR&quot;;
+    t-&gt;err = &quot;CIPHERUPDATE_ERROR&quot;;
     tmplen = 0;
     if (!frag) {
         /* We supply the data all in one go */
@@ -1065,42 +980,42 @@ static int cipher_test_enc(struct evp_test *t, int enc,
             tmplen += chunklen;
         }
     }
-    err = &quot;CIPHERFINAL_ERROR&quot;;
-    if (!EVP_CipherFinal_ex(ctx, tmp + out_misalign + tmplen, &amp;tmpflen))
+    if (!EVP_CipherFinal_ex(ctx, tmp + out_misalign + tmplen, &amp;tmpflen)) {
+        t-&gt;err = &quot;CIPHERFINAL_ERROR&quot;;
         goto err;
-    err = &quot;LENGTH_MISMATCH&quot;;
-    if (out_len != (size_t)(tmplen + tmpflen))
-        goto err;
-    err = &quot;VALUE_MISMATCH&quot;;
-    if (check_output(t, out, tmp + out_misalign, out_len))
+    }
+    if (!compare_mem(out, out_len, tmp + out_misalign, tmplen + tmpflen)) {
+        t-&gt;err = &quot;VALUE_MISMATCH&quot;;
         goto err;
+    }
     if (enc &amp;&amp; cdat-&gt;aead) {
         unsigned char rtag[16];
+
         if (cdat-&gt;tag_len &gt; sizeof(rtag)) {
-            err = &quot;TAG_LENGTH_INTERNAL_ERROR&quot;;
+            t-&gt;err = &quot;TAG_LENGTH_INTERNAL_ERROR&quot;;
             goto err;
         }
         if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG,
                                  cdat-&gt;tag_len, rtag)) {
-            err = &quot;TAG_RETRIEVE_ERROR&quot;;
+            t-&gt;err = &quot;TAG_RETRIEVE_ERROR&quot;;
             goto err;
         }
-        if (check_output(t, cdat-&gt;tag, rtag, cdat-&gt;tag_len)) {
-            err = &quot;TAG_VALUE_MISMATCH&quot;;
+        if (!compare_mem(cdat-&gt;tag, cdat-&gt;tag_len, rtag, cdat-&gt;tag_len)) {
+            t-&gt;err = &quot;TAG_VALUE_MISMATCH&quot;;
             goto err;
         }
     }
-    err = NULL;
+    t-&gt;err = NULL;
+    ok = 1;
  err:
     OPENSSL_free(tmp);
     EVP_CIPHER_CTX_free(ctx);
-    t-&gt;err = err;
-    return err ? 0 : 1;
+    return ok;
 }
 
-static int cipher_test_run(struct evp_test *t)
+static int cipher_test_run(EVP_TEST *t)
 {
-    struct cipher_data *cdat = t-&gt;data;
+    CIPHER_DATA *cdat = t-&gt;data;
     int rv, frag = 0;
     size_t out_misalign, inp_misalign;
 
@@ -1176,7 +1091,7 @@ static int cipher_test_run(struct evp_test *t)
     return 1;
 }
 
-static const struct evp_test_method cipher_test_method = {
+static const EVP_TEST_METHOD cipher_test_method = {
     &quot;Cipher&quot;,
     cipher_test_init,
     cipher_test_cleanup,
@@ -1184,7 +1099,7 @@ static const struct evp_test_method cipher_test_method = {
     cipher_test_run
 };
 
-struct mac_data {
+typedef struct mac_data_st {
     /* MAC type */
     int type;
     /* Algorithm string for this MAC */
@@ -1198,12 +1113,13 @@ struct mac_data {
     /* Expected output */
     unsigned char *output;
     size_t output_len;
-};
+} MAC_DATA;
 
-static int mac_test_init(struct evp_test *t, const char *alg)
+static int mac_test_init(EVP_TEST *t, const char *alg)
 {
     int type;
-    struct mac_data *mdat;
+    MAC_DATA *mdat;
+
     if (strcmp(alg, &quot;HMAC&quot;) == 0) {
         type = EVP_PKEY_HMAC;
     } else if (strcmp(alg, &quot;CMAC&quot;) == 0) {
@@ -1230,29 +1146,27 @@ static int mac_test_init(struct evp_test *t, const char *alg)
     } else
         return 0;
 
-    mdat = OPENSSL_malloc(sizeof(*mdat));
+    mdat = OPENSSL_zalloc(sizeof(*mdat));
     mdat-&gt;type = type;
-    mdat-&gt;alg = NULL;
-    mdat-&gt;key = NULL;
-    mdat-&gt;input = NULL;
-    mdat-&gt;output = NULL;
     t-&gt;data = mdat;
     return 1;
 }
 
-static void mac_test_cleanup(struct evp_test *t)
+static void mac_test_cleanup(EVP_TEST *t)
 {
-    struct mac_data *mdat = t-&gt;data;
-    test_free(mdat-&gt;alg);
-    test_free(mdat-&gt;key);
-    test_free(mdat-&gt;input);
-    test_free(mdat-&gt;output);
+    MAC_DATA *mdat = t-&gt;data;
+
+    OPENSSL_free(mdat-&gt;alg);
+    OPENSSL_free(mdat-&gt;key);
+    OPENSSL_free(mdat-&gt;input);
+    OPENSSL_free(mdat-&gt;output);
 }
 
-static int mac_test_parse(struct evp_test *t,
+static int mac_test_parse(EVP_TEST *t,
                           const char *keyword, const char *value)
 {
-    struct mac_data *mdata = t-&gt;data;
+    MAC_DATA *mdata = t-&gt;data;
+
     if (strcmp(keyword, &quot;Key&quot;) == 0)
         return test_bin(value, &amp;mdata-&gt;key, &amp;mdata-&gt;key_len);
     if (strcmp(keyword, &quot;Algorithm&quot;) == 0) {
@@ -1268,10 +1182,9 @@ static int mac_test_parse(struct evp_test *t,
     return 0;
 }
 
-static int mac_test_run(struct evp_test *t)
+static int mac_test_run(EVP_TEST *t)
 {
-    struct mac_data *mdata = t-&gt;data;
-    const char *err = &quot;INTERNAL_ERROR&quot;;
+    MAC_DATA *mdata = t-&gt;data;
     EVP_MD_CTX *mctx = NULL;
     EVP_PKEY_CTX *pctx = NULL, *genctx = NULL;
     EVP_PKEY *key = NULL;
@@ -1282,75 +1195,77 @@ static int mac_test_run(struct evp_test *t)
 #ifdef OPENSSL_NO_DES
     if (mdata-&gt;alg != NULL &amp;&amp; strstr(mdata-&gt;alg, &quot;DES&quot;) != NULL) {
         /* Skip DES */
-        err = NULL;
+        t-&gt;err = NULL;
         goto err;
     }
 #endif
 
-    err = &quot;MAC_PKEY_CTX_ERROR&quot;;
-    genctx = EVP_PKEY_CTX_new_id(mdata-&gt;type, NULL);
-    if (!genctx)
+    if (!TEST_ptr(genctx = EVP_PKEY_CTX_new_id(mdata-&gt;type, NULL))) {
+        t-&gt;err = &quot;MAC_PKEY_CTX_ERROR&quot;;
         goto err;
+    }
 
-    err = &quot;MAC_KEYGEN_INIT_ERROR&quot;;
-    if (EVP_PKEY_keygen_init(genctx) &lt;= 0)
+    if (EVP_PKEY_keygen_init(genctx) &lt;= 0) {
+        t-&gt;err = &quot;MAC_KEYGEN_INIT_ERROR&quot;;
+        goto err;
+    }
+    if (mdata-&gt;type == EVP_PKEY_CMAC
+             &amp;&amp; EVP_PKEY_CTX_ctrl_str(genctx, &quot;cipher&quot;, mdata-&gt;alg) &lt;= 0) {
+        t-&gt;err = &quot;MAC_ALGORITHM_SET_ERROR&quot;;
         goto err;
-    if (mdata-&gt;type == EVP_PKEY_CMAC) {
-        err = &quot;MAC_ALGORITHM_SET_ERROR&quot;;
-        if (EVP_PKEY_CTX_ctrl_str(genctx, &quot;cipher&quot;, mdata-&gt;alg) &lt;= 0)
-            goto err;
     }
 
-    err = &quot;MAC_KEY_SET_ERROR&quot;;
-    if (EVP_PKEY_CTX_set_mac_key(genctx, mdata-&gt;key, mdata-&gt;key_len) &lt;= 0)
+    if (EVP_PKEY_CTX_set_mac_key(genctx, mdata-&gt;key, mdata-&gt;key_len) &lt;= 0) {
+        t-&gt;err = &quot;MAC_KEY_SET_ERROR&quot;;
         goto err;
+    }
 
-    err = &quot;MAC_KEY_GENERATE_ERROR&quot;;
-    if (EVP_PKEY_keygen(genctx, &amp;key) &lt;= 0)
+    if (EVP_PKEY_keygen(genctx, &amp;key) &lt;= 0) {
+        t-&gt;err = &quot;MAC_KEY_GENERATE_ERROR&quot;;
         goto err;
+    }
     if (mdata-&gt;type == EVP_PKEY_HMAC) {
-        err = &quot;MAC_ALGORITHM_SET_ERROR&quot;;
-        md = EVP_get_digestbyname(mdata-&gt;alg);
-        if (!md)
+        if (!TEST_ptr(md = EVP_get_digestbyname(mdata-&gt;alg))) {
+            t-&gt;err = &quot;MAC_ALGORITHM_SET_ERROR&quot;;
             goto err;
+        }
     }
-    mctx = EVP_MD_CTX_new();
-    if (!mctx)
+    if (!TEST_ptr(mctx = EVP_MD_CTX_new())) {
+        t-&gt;err = &quot;INTERNAL_ERROR&quot;;
         goto err;
-    err = &quot;DIGESTSIGNINIT_ERROR&quot;;
-    if (!EVP_DigestSignInit(mctx, &amp;pctx, md, NULL, key))
+    }
+    if (!EVP_DigestSignInit(mctx, &amp;pctx, md, NULL, key)) {
+        t-&gt;err = &quot;DIGESTSIGNINIT_ERROR&quot;;
         goto err;
+    }
 
-    err = &quot;DIGESTSIGNUPDATE_ERROR&quot;;
-    if (!EVP_DigestSignUpdate(mctx, mdata-&gt;input, mdata-&gt;input_len))
+    if (!EVP_DigestSignUpdate(mctx, mdata-&gt;input, mdata-&gt;input_len)) {
+        t-&gt;err = &quot;DIGESTSIGNUPDATE_ERROR&quot;;
         goto err;
-    err = &quot;DIGESTSIGNFINAL_LENGTH_ERROR&quot;;
-    if (!EVP_DigestSignFinal(mctx, NULL, &amp;mac_len))
-        goto err;
-    mac = OPENSSL_malloc(mac_len);
-    if (!mac) {
-        fprintf(stderr, &quot;Error allocating mac buffer!\n&quot;);
-        exit(1);
     }
-    if (!EVP_DigestSignFinal(mctx, mac, &amp;mac_len))
+    if (!EVP_DigestSignFinal(mctx, NULL, &amp;mac_len)) {
+        t-&gt;err = &quot;DIGESTSIGNFINAL_LENGTH_ERROR&quot;;
         goto err;
-    err = &quot;MAC_LENGTH_MISMATCH&quot;;
-    if (mac_len != mdata-&gt;output_len)
+    }
+    if (!TEST_ptr(mac = OPENSSL_malloc(mac_len))) {
+        t-&gt;err = &quot;TEST_FAILURE&quot;;
         goto err;
-    err = &quot;MAC_MISMATCH&quot;;
-    if (check_output(t, mdata-&gt;output, mac, mac_len))
+    }
+    if (!EVP_DigestSignFinal(mctx, mac, &amp;mac_len)
+            || !compare_mem(mdata-&gt;output, mdata-&gt;output_len, mac, mac_len)) {
+        t-&gt;err = &quot;TEST_MAC_ERR&quot;;
         goto err;
-    err = NULL;
+    }
+    t-&gt;err = NULL;
  err:
     EVP_MD_CTX_free(mctx);
     OPENSSL_free(mac);
     EVP_PKEY_CTX_free(genctx);
     EVP_PKEY_free(key);
-    t-&gt;err = err;
     return 1;
 }
 
-static const struct evp_test_method mac_test_method = {
+static const EVP_TEST_METHOD mac_test_method = {
     &quot;MAC&quot;,
     mac_test_init,
     mac_test_cleanup,
@@ -1363,7 +1278,7 @@ static const struct evp_test_method mac_test_method = {
  * a lot of common code.
  */
 
-struct pkey_data {
+typedef struct pkey_data_st {
     /* Context for this operation */
     EVP_PKEY_CTX *ctx;
     /* Key operation to perform */
@@ -1376,13 +1291,13 @@ struct pkey_data {
     /* Expected output */
     unsigned char *output;
     size_t output_len;
-};
+} PKEY_DATA;
 
 /*
  * Perform public key operation setup: lookup key, allocated ctx and call
  * the appropriate initialisation function
  */
-static int pkey_test_init(struct evp_test *t, const char *name,
+static int pkey_test_init(EVP_TEST *t, const char *name,
                           int use_public,
                           int (*keyopinit) (EVP_PKEY_CTX *ctx),
                           int (*keyop) (EVP_PKEY_CTX *ctx,
@@ -1391,20 +1306,20 @@ static int pkey_test_init(struct evp_test *t, const char *name,
                                         size_t tbslen)
     )
 {
-    struct pkey_data *kdata;
+    PKEY_DATA *kdata;
     EVP_PKEY *pkey = NULL;
     int rv = 0;
+
     if (use_public)
-        rv = find_key(&amp;pkey, name, t-&gt;public);
-    if (!rv)
-        rv = find_key(&amp;pkey, name, t-&gt;private);
-    if (!rv || pkey == NULL) {
+        rv = find_key(&amp;pkey, name, public_keys);
+    if (rv == 0)
+        rv = find_key(&amp;pkey, name, private_keys);
+    if (rv == 0 || pkey == NULL) {
         t-&gt;skip = 1;
         return 1;
     }
 
-    kdata = OPENSSL_malloc(sizeof(*kdata));
-    if (!kdata) {
+    if (!TEST_ptr(kdata = OPENSSL_malloc(sizeof(*kdata)))) {
         EVP_PKEY_free(pkey);
         return 0;
     }
@@ -1413,31 +1328,29 @@ static int pkey_test_init(struct evp_test *t, const char *name,
     kdata-&gt;output = NULL;
     kdata-&gt;keyop = keyop;
     t-&gt;data = kdata;
-    kdata-&gt;ctx = EVP_PKEY_CTX_new(pkey, NULL);
-    if (!kdata-&gt;ctx)
+    if (!TEST_ptr(kdata-&gt;ctx = EVP_PKEY_CTX_new(pkey, NULL)))
         return 0;
     if (keyopinit(kdata-&gt;ctx) &lt;= 0)
         t-&gt;err = &quot;KEYOP_INIT_ERROR&quot;;
     return 1;
 }
 
-static void pkey_test_cleanup(struct evp_test *t)
+static void pkey_test_cleanup(EVP_TEST *t)
 {
-    struct pkey_data *kdata = t-&gt;data;
+    PKEY_DATA *kdata = t-&gt;data;
 
     OPENSSL_free(kdata-&gt;input);
     OPENSSL_free(kdata-&gt;output);
     EVP_PKEY_CTX_free(kdata-&gt;ctx);
 }
 
-static int pkey_test_ctrl(struct evp_test *t, EVP_PKEY_CTX *pctx,
+static int pkey_test_ctrl(EVP_TEST *t, EVP_PKEY_CTX *pctx,
                           const char *value)
 {
     int rv;
     char *p, *tmpval;
 
-    tmpval = OPENSSL_strdup(value);
-    if (tmpval == NULL)
+    if (!TEST_ptr(tmpval = OPENSSL_strdup(value)))
         return 0;
     p = strchr(tmpval, ':');
     if (p != NULL)
@@ -1449,6 +1362,7 @@ static int pkey_test_ctrl(struct evp_test *t, EVP_PKEY_CTX *pctx,
     } else if (p != NULL &amp;&amp; rv &lt;= 0) {
         /* If p has an OID and lookup fails assume disabled algorithm */
         int nid = OBJ_sn2nid(p);
+
         if (nid == NID_undef)
              nid = OBJ_ln2nid(p);
         if ((nid != NID_undef) &amp;&amp; EVP_get_digestbynid(nid) == NULL &amp;&amp;
@@ -1464,10 +1378,10 @@ static int pkey_test_ctrl(struct evp_test *t, EVP_PKEY_CTX *pctx,
     return rv &gt; 0;
 }
 
-static int pkey_test_parse(struct evp_test *t,
+static int pkey_test_parse(EVP_TEST *t,
                            const char *keyword, const char *value)
 {
-    struct pkey_data *kdata = t-&gt;data;
+    PKEY_DATA *kdata = t-&gt;data;
     if (strcmp(keyword, &quot;Input&quot;) == 0)
         return test_bin(value, &amp;kdata-&gt;input, &amp;kdata-&gt;input_len);
     if (strcmp(keyword, &quot;Output&quot;) == 0)
@@ -1477,43 +1391,39 @@ static int pkey_test_parse(struct evp_test *t,
     return 0;
 }
 
-static int pkey_test_run(struct evp_test *t)
+static int pkey_test_run(EVP_TEST *t)
 {
-    struct pkey_data *kdata = t-&gt;data;
+    PKEY_DATA *kdata = t-&gt;data;
     unsigned char *out = NULL;
     size_t out_len;
-    const char *err = &quot;KEYOP_LENGTH_ERROR&quot;;
+
     if (kdata-&gt;keyop(kdata-&gt;ctx, NULL, &amp;out_len, kdata-&gt;input,
-                     kdata-&gt;input_len) &lt;= 0)
-        goto err;
-    out = OPENSSL_malloc(out_len);
-    if (!out) {
-        fprintf(stderr, &quot;Error allocating output buffer!\n&quot;);
-        exit(1);
-    }
-    err = &quot;KEYOP_ERROR&quot;;
-    if (kdata-&gt;keyop
-        (kdata-&gt;ctx, out, &amp;out_len, kdata-&gt;input, kdata-&gt;input_len) &lt;= 0)
+                     kdata-&gt;input_len) &lt;= 0
+            || !TEST_ptr(out = OPENSSL_malloc(out_len))) {
+        t-&gt;err = &quot;KEYOP_LENGTH_ERROR&quot;;
         goto err;
-    err = &quot;KEYOP_LENGTH_MISMATCH&quot;;
-    if (out_len != kdata-&gt;output_len)
+    }
+    if (kdata-&gt;keyop(kdata-&gt;ctx, out,
+                     &amp;out_len, kdata-&gt;input, kdata-&gt;input_len) &lt;= 0) {
+        t-&gt;err = &quot;KEYOP_ERROR&quot;;
         goto err;
-    err = &quot;KEYOP_MISMATCH&quot;;
-    if (check_output(t, kdata-&gt;output, out, out_len))
+    }
+    if (!compare_mem(kdata-&gt;output, kdata-&gt;output_len, out, out_len)) {
+        t-&gt;err = &quot;KEYOP_MISMATCH&quot;;
         goto err;
-    err = NULL;
+    }
+    t-&gt;err = NULL;
  err:
     OPENSSL_free(out);
-    t-&gt;err = err;
     return 1;
 }
 
-static int sign_test_init(struct evp_test *t, const char *name)
+static int sign_test_init(EVP_TEST *t, const char *name)
 {
     return pkey_test_init(t, name, 0, EVP_PKEY_sign_init, EVP_PKEY_sign);
 }
 
-static const struct evp_test_method psign_test_method = {
+static const EVP_TEST_METHOD psign_test_method = {
     &quot;Sign&quot;,
     sign_test_init,
     pkey_test_cleanup,
@@ -1521,13 +1431,13 @@ static const struct evp_test_method psign_test_method = {
     pkey_test_run
 };
 
-static int verify_recover_test_init(struct evp_test *t, const char *name)
+static int verify_recover_test_init(EVP_TEST *t, const char *name)
 {
     return pkey_test_init(t, name, 1, EVP_PKEY_verify_recover_init,
                           EVP_PKEY_verify_recover);
 }
 
-static const struct evp_test_method pverify_recover_test_method = {
+static const EVP_TEST_METHOD pverify_recover_test_method = {
     &quot;VerifyRecover&quot;,
     verify_recover_test_init,
     pkey_test_cleanup,
@@ -1535,13 +1445,13 @@ static const struct evp_test_method pverify_recover_test_method = {
     pkey_test_run
 };
 
-static int decrypt_test_init(struct evp_test *t, const char *name)
+static int decrypt_test_init(EVP_TEST *t, const char *name)
 {
     return pkey_test_init(t, name, 0, EVP_PKEY_decrypt_init,
                           EVP_PKEY_decrypt);
 }
 
-static const struct evp_test_method pdecrypt_test_method = {
+static const EVP_TEST_METHOD pdecrypt_test_method = {
     &quot;Decrypt&quot;,
     decrypt_test_init,
     pkey_test_cleanup,
@@ -1549,21 +1459,22 @@ static const struct evp_test_method pdecrypt_test_method = {
     pkey_test_run
 };
 
-static int verify_test_init(struct evp_test *t, const char *name)
+static int verify_test_init(EVP_TEST *t, const char *name)
 {
     return pkey_test_init(t, name, 1, EVP_PKEY_verify_init, 0);
 }
 
-static int verify_test_run(struct evp_test *t)
+static int verify_test_run(EVP_TEST *t)
 {
-    struct pkey_data *kdata = t-&gt;data;
+    PKEY_DATA *kdata = t-&gt;data;
+
     if (EVP_PKEY_verify(kdata-&gt;ctx, kdata-&gt;output, kdata-&gt;output_len,
                         kdata-&gt;input, kdata-&gt;input_len) &lt;= 0)
         t-&gt;err = &quot;VERIFY_ERROR&quot;;
     return 1;
 }
 
-static const struct evp_test_method pverify_test_method = {
+static const EVP_TEST_METHOD pverify_test_method = {
     &quot;Verify&quot;,
     verify_test_init,
     pkey_test_cleanup,
@@ -1572,19 +1483,19 @@ static const struct evp_test_method pverify_test_method = {
 };
 
 
-static int pderive_test_init(struct evp_test *t, const char *name)
+static int pderive_test_init(EVP_TEST *t, const char *name)
 {
     return pkey_test_init(t, name, 0, EVP_PKEY_derive_init, 0);
 }
 
-static int pderive_test_parse(struct evp_test *t,
+static int pderive_test_parse(EVP_TEST *t,
                               const char *keyword, const char *value)
 {
-    struct pkey_data *kdata = t-&gt;data;
+    PKEY_DATA *kdata = t-&gt;data;
 
     if (strcmp(keyword, &quot;PeerKey&quot;) == 0) {
         EVP_PKEY *peer;
-        if (find_key(&amp;peer, value, t-&gt;public) == 0)
+        if (find_key(&amp;peer, value, public_keys) == 0)
             return 0;
         if (EVP_PKEY_derive_set_peer(kdata-&gt;ctx, peer) &lt;= 0)
             return 0;
@@ -1597,36 +1508,33 @@ static int pderive_test_parse(struct evp_test *t,
     return 0;
 }
 
-static int pderive_test_run(struct evp_test *t)
+static int pderive_test_run(EVP_TEST *t)
 {
-    struct pkey_data *kdata = t-&gt;data;
+    PKEY_DATA *kdata = t-&gt;data;
     unsigned char *out = NULL;
     size_t out_len;
-    const char *err = &quot;INTERNAL_ERROR&quot;;
 
     out_len = kdata-&gt;output_len;
-    out = OPENSSL_malloc(out_len);
-    if (!out) {
-        fprintf(stderr, &quot;Error allocating output buffer!\n&quot;);
-        exit(1);
-    }
-    err = &quot;DERIVE_ERROR&quot;;
-    if (EVP_PKEY_derive(kdata-&gt;ctx, out, &amp;out_len) &lt;= 0)
+    if (!TEST_ptr(out = OPENSSL_malloc(out_len))) {
+        t-&gt;err = &quot;DERIVE_ERROR&quot;;
         goto err;
-    err = &quot;SHARED_SECRET_LENGTH_MISMATCH&quot;;
-    if (out_len != kdata-&gt;output_len)
+    }
+    if (EVP_PKEY_derive(kdata-&gt;ctx, out, &amp;out_len) &lt;= 0) {
+        t-&gt;err = &quot;DERIVE_ERROR&quot;;
         goto err;
-    err = &quot;SHARED_SECRET_MISMATCH&quot;;
-    if (check_output(t, kdata-&gt;output, out, out_len))
+    }
+    if (!compare_mem(kdata-&gt;output, kdata-&gt;output_len, out, out_len)) {
+        t-&gt;err = &quot;SHARED_SECRET_MISMATCH&quot;;
         goto err;
-    err = NULL;
+    }
+
+    t-&gt;err = NULL;
  err:
     OPENSSL_free(out);
-    t-&gt;err = err;
     return 1;
 }
 
-static const struct evp_test_method pderive_test_method = {
+static const EVP_TEST_METHOD pderive_test_method = {
     &quot;Derive&quot;,
     pderive_test_init,
     pkey_test_cleanup,
@@ -1640,35 +1548,29 @@ static const struct evp_test_method pderive_test_method = {
 #define PBE_TYPE_PBKDF2 2
 #define PBE_TYPE_PKCS12 3
 
-struct pbe_data {
-
+typedef struct pbe_data_st {
     int pbe_type;
-
-    /* scrypt parameters */
+        /* scrypt parameters */
     uint64_t N, r, p, maxmem;
-
-    /* PKCS#12 parameters */
+        /* PKCS#12 parameters */
     int id, iter;
     const EVP_MD *md;
-
-    /* password */
+        /* password */
     unsigned char *pass;
     size_t pass_len;
-
-    /* salt */
+        /* salt */
     unsigned char *salt;
     size_t salt_len;
-
-    /* Expected output */
+        /* Expected output */
     unsigned char *key;
     size_t key_len;
-};
+} PBE_DATA;
 
 #ifndef OPENSSL_NO_SCRYPT
-static int scrypt_test_parse(struct evp_test *t,
+static int scrypt_test_parse(EVP_TEST *t,
                              const char *keyword, const char *value)
 {
-    struct pbe_data *pdata = t-&gt;data;
+    PBE_DATA *pdata = t-&gt;data;
 
     if (strcmp(keyword, &quot;N&quot;) == 0)
         return test_uint64(value, &amp;pdata-&gt;N);
@@ -1682,10 +1584,10 @@ static int scrypt_test_parse(struct evp_test *t,
 }
 #endif
 
-static int pbkdf2_test_parse(struct evp_test *t,
+static int pbkdf2_test_parse(EVP_TEST *t,
                              const char *keyword, const char *value)
 {
-    struct pbe_data *pdata = t-&gt;data;
+    PBE_DATA *pdata = t-&gt;data;
 
     if (strcmp(keyword, &quot;iter&quot;) == 0) {
         pdata-&gt;iter = atoi(value);
@@ -1702,10 +1604,10 @@ static int pbkdf2_test_parse(struct evp_test *t,
     return 0;
 }
 
-static int pkcs12_test_parse(struct evp_test *t,
+static int pkcs12_test_parse(EVP_TEST *t,
                              const char *keyword, const char *value)
 {
-    struct pbe_data *pdata = t-&gt;data;
+    PBE_DATA *pdata = t-&gt;data;
 
     if (strcmp(keyword, &quot;id&quot;) == 0) {
         pdata-&gt;id = atoi(value);
@@ -1716,9 +1618,9 @@ static int pkcs12_test_parse(struct evp_test *t,
     return pbkdf2_test_parse(t, keyword, value);
 }
 
-static int pbe_test_init(struct evp_test *t, const char *alg)
+static int pbe_test_init(EVP_TEST *t, const char *alg)
 {
-    struct pbe_data *pdat;
+    PBE_DATA *pdat;
     int pbe_type = 0;
 
     if (strcmp(alg, &quot;scrypt&quot;) == 0) {
@@ -1733,7 +1635,7 @@ static int pbe_test_init(struct evp_test *t, const char *alg)
     } else if (strcmp(alg, &quot;pkcs12&quot;) == 0) {
         pbe_type = PBE_TYPE_PKCS12;
     } else {
-        fprintf(stderr, &quot;Unknown pbe algorithm %s\n&quot;, alg);
+        TEST_error(&quot;Unknown pbe algorithm %s&quot;, alg);
     }
     pdat = OPENSSL_malloc(sizeof(*pdat));
     pdat-&gt;pbe_type = pbe_type;
@@ -1750,18 +1652,19 @@ static int pbe_test_init(struct evp_test *t, const char *alg)
     return 1;
 }
 
-static void pbe_test_cleanup(struct evp_test *t)
+static void pbe_test_cleanup(EVP_TEST *t)
 {
-    struct pbe_data *pdat = t-&gt;data;
-    test_free(pdat-&gt;pass);
-    test_free(pdat-&gt;salt);
-    test_free(pdat-&gt;key);
+    PBE_DATA *pdat = t-&gt;data;
+
+    OPENSSL_free(pdat-&gt;pass);
+    OPENSSL_free(pdat-&gt;salt);
+    OPENSSL_free(pdat-&gt;key);
 }
 
-static int pbe_test_parse(struct evp_test *t,
-                             const char *keyword, const char *value)
+static int pbe_test_parse(EVP_TEST *t,
+                          const char *keyword, const char *value)
 {
-    struct pbe_data *pdata = t-&gt;data;
+    PBE_DATA *pdata = t-&gt;data;
 
     if (strcmp(keyword, &quot;Password&quot;) == 0)
         return test_bin(value, &amp;pdata-&gt;pass, &amp;pdata-&gt;pass_len);
@@ -1780,50 +1683,53 @@ static int pbe_test_parse(struct evp_test *t,
     return 0;
 }
 
-static int pbe_test_run(struct evp_test *t)
+static int pbe_test_run(EVP_TEST *t)
 {
-    struct pbe_data *pdata = t-&gt;data;
-    const char *err = &quot;INTERNAL_ERROR&quot;;
+    PBE_DATA *pdata = t-&gt;data;
     unsigned char *key;
 
-    key = OPENSSL_malloc(pdata-&gt;key_len);
-    if (!key)
+    if (!TEST_ptr(key = OPENSSL_malloc(pdata-&gt;key_len))) {
+        t-&gt;err = &quot;INTERNAL_ERROR&quot;;
         goto err;
+    }
     if (pdata-&gt;pbe_type == PBE_TYPE_PBKDF2) {
-        err = &quot;PBKDF2_ERROR&quot;;
         if (PKCS5_PBKDF2_HMAC((char *)pdata-&gt;pass, pdata-&gt;pass_len,
                               pdata-&gt;salt, pdata-&gt;salt_len,
                               pdata-&gt;iter, pdata-&gt;md,
-                              pdata-&gt;key_len, key) == 0)
+                              pdata-&gt;key_len, key) == 0) {
+            t-&gt;err = &quot;PBKDF2_ERROR&quot;;
             goto err;
+        }
 #ifndef OPENSSL_NO_SCRYPT
     } else if (pdata-&gt;pbe_type == PBE_TYPE_SCRYPT) {
-        err = &quot;SCRYPT_ERROR&quot;;
         if (EVP_PBE_scrypt((const char *)pdata-&gt;pass, pdata-&gt;pass_len,
                            pdata-&gt;salt, pdata-&gt;salt_len,
                            pdata-&gt;N, pdata-&gt;r, pdata-&gt;p, pdata-&gt;maxmem,
-                           key, pdata-&gt;key_len) == 0)
+                           key, pdata-&gt;key_len) == 0) {
+            t-&gt;err = &quot;SCRYPT_ERROR&quot;;
             goto err;
+        }
 #endif
     } else if (pdata-&gt;pbe_type == PBE_TYPE_PKCS12) {
-        err = &quot;PKCS12_ERROR&quot;;
         if (PKCS12_key_gen_uni(pdata-&gt;pass, pdata-&gt;pass_len,
                                pdata-&gt;salt, pdata-&gt;salt_len,
                                pdata-&gt;id, pdata-&gt;iter, pdata-&gt;key_len,
-                               key, pdata-&gt;md) == 0)
+                               key, pdata-&gt;md) == 0) {
+            t-&gt;err = &quot;PKCS12_ERROR&quot;;
             goto err;
+        }
     }
-    err = &quot;KEY_MISMATCH&quot;;
-    if (check_output(t, pdata-&gt;key, key, pdata-&gt;key_len))
+    if (!compare_mem(pdata-&gt;key, pdata-&gt;key_len, key, pdata-&gt;key_len)) {
+        t-&gt;err = &quot;KEY_MISMATCH&quot;;
         goto err;
-    err = NULL;
-    err:
+    }
+    t-&gt;err = NULL;
+err:
     OPENSSL_free(key);
-    t-&gt;err = err;
     return 1;
 }
 
-static const struct evp_test_method pbe_test_method = {
+static const EVP_TEST_METHOD pbe_test_method = {
     &quot;PBE&quot;,
     pbe_test_init,
     pbe_test_cleanup,
@@ -1839,7 +1745,7 @@ typedef enum {
     BASE64_INVALID_ENCODING = 2
 } base64_encoding_type;
 
-struct encode_data {
+typedef struct encode_data_st {
     /* Input to encoding */
     unsigned char *input;
     size_t input_len;
@@ -1847,11 +1753,11 @@ struct encode_data {
     unsigned char *output;
     size_t output_len;
     base64_encoding_type encoding;
-};
+} ENCODE_DATA;
 
-static int encode_test_init(struct evp_test *t, const char *encoding)
+static int encode_test_init(EVP_TEST *t, const char *encoding)
 {
-    struct encode_data *edata = OPENSSL_zalloc(sizeof(*edata));
+    ENCODE_DATA *edata = OPENSSL_zalloc(sizeof(*edata));
 
     if (strcmp(encoding, &quot;canonical&quot;) == 0) {
         edata-&gt;encoding = BASE64_CANONICAL_ENCODING;
@@ -1863,26 +1769,27 @@ static int encode_test_init(struct evp_test *t, const char *encoding)
         if (t-&gt;expected_err == NULL)
             return 0;
     } else {
-        fprintf(stderr, &quot;Bad encoding: %s. Should be one of &quot;
-                &quot;{canonical, valid, invalid}\n&quot;, encoding);
+        TEST_info(&quot;Bad encoding: %s. Should be one of &quot;
+                  &quot;{canonical, valid, invalid}&quot;, encoding);
         return 0;
     }
     t-&gt;data = edata;
     return 1;
 }
 
-static void encode_test_cleanup(struct evp_test *t)
+static void encode_test_cleanup(EVP_TEST *t)
 {
-    struct encode_data *edata = t-&gt;data;
-    test_free(edata-&gt;input);
-    test_free(edata-&gt;output);
+    ENCODE_DATA *edata = t-&gt;data;
+
+    OPENSSL_free(edata-&gt;input);
+    OPENSSL_free(edata-&gt;output);
     memset(edata, 0, sizeof(*edata));
 }
 
-static int encode_test_parse(struct evp_test *t,
+static int encode_test_parse(EVP_TEST *t,
                              const char *keyword, const char *value)
 {
-    struct encode_data *edata = t-&gt;data;
+    ENCODE_DATA *edata = t-&gt;data;
     if (strcmp(keyword, &quot;Input&quot;) == 0)
         return test_bin(value, &amp;edata-&gt;input, &amp;edata-&gt;input_len);
     if (strcmp(keyword, &quot;Output&quot;) == 0)
@@ -1890,23 +1797,24 @@ static int encode_test_parse(struct evp_test *t,
     return 0;
 }
 
-static int encode_test_run(struct evp_test *t)
+static int encode_test_run(EVP_TEST *t)
 {
-    struct encode_data *edata = t-&gt;data;
+    ENCODE_DATA *edata = t-&gt;data;
     unsigned char *encode_out = NULL, *decode_out = NULL;
     int output_len, chunk_len;
-    const char *err = &quot;INTERNAL_ERROR&quot;;
-    EVP_ENCODE_CTX *decode_ctx = EVP_ENCODE_CTX_new();
+    EVP_ENCODE_CTX *decode_ctx;
 
-    if (decode_ctx == NULL)
+    if (!TEST_ptr(decode_ctx = EVP_ENCODE_CTX_new())) {
+        t-&gt;err = &quot;INTERNAL_ERROR&quot;;
         goto err;
+    }
 
     if (edata-&gt;encoding == BASE64_CANONICAL_ENCODING) {
-        EVP_ENCODE_CTX *encode_ctx = EVP_ENCODE_CTX_new();
-        if (encode_ctx == NULL)
-            goto err;
-        encode_out = OPENSSL_malloc(EVP_ENCODE_LENGTH(edata-&gt;input_len));
-        if (encode_out == NULL)
+        EVP_ENCODE_CTX *encode_ctx;
+
+        if (!TEST_ptr(encode_ctx = EVP_ENCODE_CTX_new())
+                || !TEST_ptr(encode_out =
+                        OPENSSL_malloc(EVP_ENCODE_LENGTH(edata-&gt;input_len))))
             goto err;
 
         EVP_EncodeInit(encode_ctx);
@@ -1919,48 +1827,47 @@ static int encode_test_run(struct evp_test *t)
 
         EVP_ENCODE_CTX_free(encode_ctx);
 
-        if (check_var_length_output(t, edata-&gt;output, edata-&gt;output_len,
-                                    encode_out, output_len)) {
-            err = &quot;BAD_ENCODING&quot;;
+        if (!compare_mem(edata-&gt;output, edata-&gt;output_len,
+                         encode_out, output_len)) {
+            t-&gt;err = &quot;BAD_ENCODING&quot;;
             goto err;
         }
     }
 
-    decode_out = OPENSSL_malloc(EVP_DECODE_LENGTH(edata-&gt;output_len));
-    if (decode_out == NULL)
+    if (!TEST_ptr(decode_out =
+                OPENSSL_malloc(EVP_DECODE_LENGTH(edata-&gt;output_len))))
         goto err;
 
     EVP_DecodeInit(decode_ctx);
     if (EVP_DecodeUpdate(decode_ctx, decode_out, &amp;chunk_len, edata-&gt;output,
                          edata-&gt;output_len) &lt; 0) {
-        err = &quot;DECODE_ERROR&quot;;
+        t-&gt;err = &quot;DECODE_ERROR&quot;;
         goto err;
     }
     output_len = chunk_len;
 
     if (EVP_DecodeFinal(decode_ctx, decode_out + chunk_len, &amp;chunk_len) != 1) {
-        err = &quot;DECODE_ERROR&quot;;
+        t-&gt;err = &quot;DECODE_ERROR&quot;;
         goto err;
     }
     output_len += chunk_len;
 
-    if (edata-&gt;encoding != BASE64_INVALID_ENCODING &amp;&amp;
-        check_var_length_output(t, edata-&gt;input, edata-&gt;input_len,
-                                decode_out, output_len)) {
-        err = &quot;BAD_DECODING&quot;;
+    if (edata-&gt;encoding != BASE64_INVALID_ENCODING
+            &amp;&amp; !compare_mem(edata-&gt;input, edata-&gt;input_len,
+                            decode_out, output_len)) {
+        t-&gt;err = &quot;BAD_DECODING&quot;;
         goto err;
     }
 
-    err = NULL;
+    t-&gt;err = NULL;
  err:
-    t-&gt;err = err;
     OPENSSL_free(encode_out);
     OPENSSL_free(decode_out);
     EVP_ENCODE_CTX_free(decode_ctx);
     return 1;
 }
 
-static const struct evp_test_method encode_test_method = {
+static const EVP_TEST_METHOD encode_test_method = {
     &quot;Encoding&quot;,
     encode_test_init,
     encode_test_cleanup,
@@ -1970,21 +1877,21 @@ static const struct evp_test_method encode_test_method = {
 
 /* KDF operations */
 
-struct kdf_data {
+typedef struct kdf_data_st {
     /* Context for this operation */
     EVP_PKEY_CTX *ctx;
     /* Expected output */
     unsigned char *output;
     size_t output_len;
-};
+} KDF_DATA;
 
 /*
  * Perform public key operation setup: lookup key, allocated ctx and call
  * the appropriate initialisation function
  */
-static int kdf_test_init(struct evp_test *t, const char *name)
+static int kdf_test_init(EVP_TEST *t, const char *name)
 {
-    struct kdf_data *kdata;
+    KDF_DATA *kdata;
 
     kdata = OPENSSL_malloc(sizeof(*kdata));
     if (kdata == NULL)
@@ -2000,17 +1907,18 @@ static int kdf_test_init(struct evp_test *t, const char *name)
     return 1;
 }
 
-static void kdf_test_cleanup(struct evp_test *t)
+static void kdf_test_cleanup(EVP_TEST *t)
 {
-    struct kdf_data *kdata = t-&gt;data;
+    KDF_DATA *kdata = t-&gt;data;
     OPENSSL_free(kdata-&gt;output);
     EVP_PKEY_CTX_free(kdata-&gt;ctx);
 }
 
-static int kdf_test_parse(struct evp_test *t,
+static int kdf_test_parse(EVP_TEST *t,
                           const char *keyword, const char *value)
 {
-    struct kdf_data *kdata = t-&gt;data;
+    KDF_DATA *kdata = t-&gt;data;
+
     if (strcmp(keyword, &quot;Output&quot;) == 0)
         return test_bin(value, &amp;kdata-&gt;output, &amp;kdata-&gt;output_len);
     if (strncmp(keyword, &quot;Ctrl&quot;, 4) == 0)
@@ -2018,34 +1926,32 @@ static int kdf_test_parse(struct evp_test *t,
     return 0;
 }
 
-static int kdf_test_run(struct evp_test *t)
+static int kdf_test_run(EVP_TEST *t)
 {
-    struct kdf_data *kdata = t-&gt;data;
+    KDF_DATA *kdata = t-&gt;data;
     unsigned char *out = NULL;
     size_t out_len = kdata-&gt;output_len;
-    const char *err = &quot;INTERNAL_ERROR&quot;;
-    out = OPENSSL_malloc(out_len);
-    if (!out) {
-        fprintf(stderr, &quot;Error allocating output buffer!\n&quot;);
-        exit(1);
-    }
-    err = &quot;KDF_DERIVE_ERROR&quot;;
-    if (EVP_PKEY_derive(kdata-&gt;ctx, out, &amp;out_len) &lt;= 0)
+
+    if (!TEST_ptr(out = OPENSSL_malloc(out_len))) {
+        t-&gt;err = &quot;INTERNAL_ERROR&quot;;
         goto err;
-    err = &quot;KDF_LENGTH_MISMATCH&quot;;
-    if (out_len != kdata-&gt;output_len)
+    }
+    if (EVP_PKEY_derive(kdata-&gt;ctx, out, &amp;out_len) &lt;= 0) {
+        t-&gt;err = &quot;KDF_DERIVE_ERROR&quot;;
         goto err;
-    err = &quot;KDF_MISMATCH&quot;;
-    if (check_output(t, kdata-&gt;output, out, out_len))
+    }
+    if (!compare_mem(kdata-&gt;output, kdata-&gt;output_len, out, out_len)) {
+        t-&gt;err = &quot;KDF_MISMATCH&quot;;
         goto err;
-    err = NULL;
+    }
+    t-&gt;err = NULL;
+
  err:
     OPENSSL_free(out);
-    t-&gt;err = err;
     return 1;
 }
 
-static const struct evp_test_method kdf_test_method = {
+static const EVP_TEST_METHOD kdf_test_method = {
     &quot;KDF&quot;,
     kdf_test_init,
     kdf_test_cleanup,
@@ -2053,37 +1959,33 @@ static const struct evp_test_method kdf_test_method = {
     kdf_test_run
 };
 
-struct keypair_test_data {
+typedef struct keypair_test_data_st {
     EVP_PKEY *privk;
     EVP_PKEY *pubk;
-};
+} KEYPAIR_TEST_DATA;
 
-static int keypair_test_init(struct evp_test *t, const char *pair)
+static int keypair_test_init(EVP_TEST *t, const char *pair)
 {
     int rv = 0;
     EVP_PKEY *pk = NULL, *pubk = NULL;
     char *pub, *priv = NULL;
-    const char *err = &quot;INTERNAL_ERROR&quot;;
-    struct keypair_test_data *data;
+    KEYPAIR_TEST_DATA *data;
 
-    priv = OPENSSL_strdup(pair);
-    if (priv == NULL)
-        return 0;
-    pub = strchr(priv, ':');
-    if ( pub == NULL ) {
-        fprintf(stderr, &quot;Wrong syntax \&quot;%s\&quot;\n&quot;, pair);
+    if (!TEST_ptr(priv = OPENSSL_strdup(pair))
+            || !TEST_ptr(pub = strchr(priv, ':'))) {
+        t-&gt;err = &quot;PARSING_ERROR&quot;;
         goto end;
     }
     *pub++ = 0; /* split priv and pub strings */
 
-    if (find_key(&amp;pk, priv, t-&gt;private) == 0) {
-        fprintf(stderr, &quot;Cannot find private key: %s\n&quot;, priv);
-        err = &quot;MISSING_PRIVATE_KEY&quot;;
+    if (!TEST_true(find_key(&amp;pk, priv, private_keys))) {
+        TEST_info(&quot;Cannot find private key: %s&quot;, priv);
+        t-&gt;err = &quot;MISSING_PRIVATE_KEY&quot;;
         goto end;
     }
-    if (find_key(&amp;pubk, pub, t-&gt;public) == 0) {
-        fprintf(stderr, &quot;Cannot find public key: %s\n&quot;, pub);
-        err = &quot;MISSING_PUBLIC_KEY&quot;;
+    if (!TEST_true(find_key(&amp;pubk, pub, public_keys))) {
+        TEST_info(&quot;Cannot find public key: %s&quot;, pub);
+        t-&gt;err = &quot;MISSING_PUBLIC_KEY&quot;;
         goto end;
     }
 
@@ -2094,69 +1996,59 @@ static int keypair_test_init(struct evp_test *t, const char *pair)
         goto end;
     }
 
-    data = OPENSSL_malloc(sizeof(*data));
-    if (data == NULL )
+    if (!TEST_ptr(data = OPENSSL_malloc(sizeof(*data))))
         goto end;
 
     data-&gt;privk = pk;
     data-&gt;pubk = pubk;
     t-&gt;data = data;
-
     rv = 1;
-    err = NULL;
+    t-&gt;err = NULL;
 
 end:
-    if (priv)
-        OPENSSL_free(priv);
-    t-&gt;err = err;
+    OPENSSL_free(priv);
     return rv;
 }
 
-static void keypair_test_cleanup(struct evp_test *t)
+static void keypair_test_cleanup(EVP_TEST *t)
 {
-    struct keypair_test_data *data = t-&gt;data;
+    OPENSSL_free(t-&gt;data);
     t-&gt;data = NULL;
-    if (data)
-        test_free(data);
-    return;
 }
 
 /* For test that do not accept any custom keyword:
  *      return 0 if called
  */
-static int void_test_parse(struct evp_test *t, const char *keyword, const char *value)
+static int void_test_parse(EVP_TEST *t, const char *keyword, const char *value)
 {
     return 0;
 }
 
-static int keypair_test_run(struct evp_test *t)
+static int keypair_test_run(EVP_TEST *t)
 {
     int rv = 0;
-    const struct keypair_test_data *pair = t-&gt;data;
-    const char *err = &quot;INTERNAL_ERROR&quot;;
-
-    if (pair == NULL)
-        goto end;
+    const KEYPAIR_TEST_DATA *pair = t-&gt;data;
 
     if (pair-&gt;privk == NULL || pair-&gt;pubk == NULL) {
-        /* this can only happen if only one of the keys is not set
+        /*
+         * this can only happen if only one of the keys is not set
          * which means that one of them was unsupported while the
          * other isn't: hence a key type mismatch.
          */
-        err = &quot;KEYPAIR_TYPE_MISMATCH&quot;;
+        t-&gt;err = &quot;KEYPAIR_TYPE_MISMATCH&quot;;
         rv = 1;
         goto end;
     }
 
     if ((rv = EVP_PKEY_cmp(pair-&gt;privk, pair-&gt;pubk)) != 1 ) {
         if ( 0 == rv ) {
-            err = &quot;KEYPAIR_MISMATCH&quot;;
+            t-&gt;err = &quot;KEYPAIR_MISMATCH&quot;;
         } else if ( -1 == rv ) {
-            err = &quot;KEYPAIR_TYPE_MISMATCH&quot;;
+            t-&gt;err = &quot;KEYPAIR_TYPE_MISMATCH&quot;;
         } else if ( -2 == rv ) {
-            err = &quot;UNSUPPORTED_KEY_COMPARISON&quot;;
+            t-&gt;err = &quot;UNSUPPORTED_KEY_COMPARISON&quot;;
         } else {
-            fprintf(stderr, &quot;Unexpected error in key comparison\n&quot;);
+            TEST_error(&quot;Unexpected error in key comparison&quot;);
             rv = 0;
             goto end;
         }
@@ -2165,14 +2057,13 @@ static int keypair_test_run(struct evp_test *t)
     }
 
     rv = 1;
-    err = NULL;
+    t-&gt;err = NULL;
 
 end:
-    t-&gt;err = err;
     return rv;
 }
 
-static const struct evp_test_method keypair_test_method = {
+static const EVP_TEST_METHOD keypair_test_method = {
     &quot;PrivPubKeyPair&quot;,
     keypair_test_init,
     keypair_test_cleanup,
@@ -2180,3 +2071,53 @@ static const struct evp_test_method keypair_test_method = {
     keypair_test_run
 };
 
+static int do_test_file(const char *testfile)
+{
+    BIO *in;
+    char buf[10240];
+    EVP_TEST t;
+
+    current_test_file = testfile;
+    if (!TEST_ptr(in = BIO_new_file(testfile, &quot;rb&quot;)))
+        return 0;
+    memset(&amp;t, 0, sizeof(t));
+    t.start_line = -1;
+    t.in = in;
+    t.err = NULL;
+    while (BIO_gets(in, buf, sizeof(buf))) {
+        t.line++;
+        if (!TEST_true(parse_test_line(&amp;t, buf)))
+            return 0;
+    }
+    /* Run any final test we have */
+    if (!run_and_get_next(&amp;t, NULL))
+        return 0;
+
+    TEST_info(&quot;Completed %d tests with %d errors and %d skipped&quot;,
+              t.ntests, t.errors, t.nskip);
+    free_key_list(public_keys);
+    free_key_list(private_keys);
+    BIO_free(t.key);
+    BIO_free(in);
+    return t.errors == 0;
+}
+
+static char * const *testfiles;
+
+static int run_file_tests(int i)
+{
+    return do_test_file(testfiles[i]);
+}
+
+int test_main(int argc, char *argv[])
+{
+    if (argc &lt; 2) {
+        TEST_error(&quot;Usage: %s file...&quot;, argv[0]);
+        return 0;
+    }
+    testfiles = &amp;argv[1];
+
+    ADD_ALL_TESTS(run_file_tests, argc - 1);
+
+    return run_tests(argv[0]);
+}
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014589.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="014592.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14591">[ date ]</a>
              <a href="thread.html#14591">[ thread ]</a>
              <a href="subject.html#14591">[ subject ]</a>
              <a href="author.html#14591">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
