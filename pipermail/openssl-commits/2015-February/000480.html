<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2015-February/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C20150213132945.692A11DF1AB%40butler.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000478.html">
   <LINK REL="Next"  HREF="000481.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Dr. Stephen Henson</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C20150213132945.692A11DF1AB%40butler.localdomain%3E"
       TITLE="[openssl-commits] [openssl]  master update">steve at openssl.org
       </A><BR>
    <I>Fri Feb 13 13:29:45 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="000478.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="000481.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#480">[ date ]</a>
              <a href="thread.html#480">[ thread ]</a>
              <a href="subject.html#480">[ subject ]</a>
              <a href="author.html#480">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  d5ec8efc70d3f9197dd6965d959de7dcda784459 (commit)
       via  b9d4e97c873873340027b47437b09a51bf8ad3d5 (commit)
       via  5824cc298174d462c827cd090675e30fc03f0caf (commit)
       via  16cb8eb0139379f122d3bf3bedb0c5a43e70a30a (commit)
       via  b8c792dc43cbb8585dd5ee90a8b07bc11f6f10f5 (commit)
       via  83251f397b6a4226b9b73ab52666d4999c21512e (commit)
       via  eff1a4d24f3f23b48984b7b60d4c343a3a995f38 (commit)
       via  6906a7c1a34d753b783cb38083bf95f417fef684 (commit)
      from  774ccae63c3a41a3f0762cbc818271d3ef9f369f (commit)


- Log -----------------------------------------------------------------
commit d5ec8efc70d3f9197dd6965d959de7dcda784459
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Thu Feb 12 16:34:10 2015 +0000

    Add leak detection, fix leaks.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit b9d4e97c873873340027b47437b09a51bf8ad3d5
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Thu Feb 12 15:30:48 2015 +0000

    Add EVP_PKEY test data.
    
    Add some EVP_PKEY test data for sign and verify tests including
    failure cases.
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 5824cc298174d462c827cd090675e30fc03f0caf
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Wed Feb 11 17:15:51 2015 +0000

    EVP_PKEY support for evp_test
    
    Add two new keywords &quot;PublicKey&quot; and &quot;PrivateKey&quot;. These will load a key
    in PEM format from the lines immediately following the keyword and assign
    it a name according to the value. These will be used later for public and
    private key testing operations.
    
    Add tests for Sign, Verify, VerifyRecover and Decrypt.
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 16cb8eb0139379f122d3bf3bedb0c5a43e70a30a
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Tue Feb 10 18:33:05 2015 +0000

    Add CMAC test data.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit b8c792dc43cbb8585dd5ee90a8b07bc11f6f10f5
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Tue Feb 10 15:53:12 2015 +0000

    Add HMAC test data.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 83251f397b6a4226b9b73ab52666d4999c21512e
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Tue Feb 10 13:44:17 2015 +0000

    MAC support for evp_test
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit eff1a4d24f3f23b48984b7b60d4c343a3a995f38
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Tue Feb 10 18:06:56 2015 +0000

    New macro to set mac key.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 6906a7c1a34d753b783cb38083bf95f417fef684
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Tue Feb 10 15:53:56 2015 +0000

    Return error code is any tests fail.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 crypto/evp/evp.h        |    4 +
 crypto/evp/evp_test.c   |  460 ++++++++++++++++++++++++++++++++++++++++++++++-
 crypto/evp/evptests.txt |  259 +++++++++++++++++++++++++-
 crypto/evp/pmeth_gn.c   |    4 +-
 4 files changed, 716 insertions(+), 11 deletions(-)

diff --git a/crypto/evp/evp.h b/crypto/evp/evp.h
index 0dbd420..2e9f83f 100644
--- a/crypto/evp/evp.h
+++ b/crypto/evp/evp.h
@@ -1198,6 +1198,10 @@ void EVP_PKEY_asn1_set_security_bits(EVP_PKEY_ASN1_METHOD *ameth,
                 EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_TYPE_SIG,  \
                                         EVP_PKEY_CTRL_GET_MD, 0, (void *)pmd)
 
+# define  EVP_PKEY_CTX_set_mac_key(ctx, key, len)        \
+                EVP_PKEY_CTX_ctrl(ctx, -1, EVP_PKEY_OP_KEYGEN,  \
+                                  EVP_PKEY_CTRL_SET_MAC_KEY, len, (void *)key)
+
 # define EVP_PKEY_CTRL_MD                1
 # define EVP_PKEY_CTRL_PEER_KEY          2
 
diff --git a/crypto/evp/evp_test.c b/crypto/evp/evp_test.c
index 686ca7c..78e8b70 100644
--- a/crypto/evp/evp_test.c
+++ b/crypto/evp/evp_test.c
@@ -57,6 +57,7 @@
 #include &lt;stdlib.h&gt;
 #include &lt;ctype.h&gt;
 #include &lt;openssl/evp.h&gt;
+#include &lt;openssl/pem.h&gt;
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/x509v3.h&gt;
 
@@ -134,6 +135,18 @@ static int test_bin(const char *value, unsigned char **buf, size_t *buflen)
         *buflen = 0;
         return 1;
     }
+    /* Check for string literal */
+    if (value[0] == '&quot;') {
+        size_t vlen;
+        value++;
+        vlen = strlen(value);
+        if (value[vlen - 1] != '&quot;')
+            return 0;
+        vlen--;
+        *buf = BUF_memdup(value, vlen);
+        *buflen = vlen;
+        return 1;
+    }
     *buf = string_to_hex(value, &amp;len);
     if (!*buf) {
         fprintf(stderr, &quot;Value=%s\n&quot;, value);
@@ -147,6 +160,11 @@ static int test_bin(const char *value, unsigned char **buf, size_t *buflen)
 
 /* Structure holding test information */
 struct evp_test {
+    /* file being read */
+    FILE *in;
+    /* List of public and private keys */
+    struct key_list *private;
+    struct key_list *public;
     /* method for this test */
     const struct evp_test_method *meth;
     /* current line being processed */
@@ -168,6 +186,13 @@ struct evp_test {
     /* test specific data */
     void *data;
 };
+
+struct key_list {
+    char *name;
+    EVP_PKEY *key;
+    struct key_list *next;
+};
+
 /* Test method structure */
 struct evp_test_method {
     /* Name of test as it appears in file */
@@ -183,12 +208,20 @@ struct evp_test_method {
 };
 
 static const struct evp_test_method digest_test_method, cipher_test_method;
-static const struct evp_test_method aead_test_method;
+static const struct evp_test_method aead_test_method, mac_test_method;
+static const struct evp_test_method psign_test_method, pverify_test_method;
+static const struct evp_test_method pdecrypt_test_method;
+static const struct evp_test_method pverify_recover_test_method;
 
 static const struct evp_test_method *evp_test_list[] = {
     &amp;digest_test_method,
     &amp;cipher_test_method,
-    NULL,
+    &amp;mac_test_method,
+    &amp;psign_test_method,
+    &amp;pverify_test_method,
+    &amp;pdecrypt_test_method,
+    &amp;pverify_recover_test_method,
+    NULL
 };
 
 static const struct evp_test_method *evp_find_test(const char *name)
@@ -265,11 +298,8 @@ static int setup_test(struct evp_test *t, const struct evp_test_method *tmeth)
         }
         ERR_clear_error();
         t-&gt;meth-&gt;cleanup(t);
-        /* If new test type free old data */
-        if (tmeth != t-&gt;meth &amp;&amp; t-&gt;data) {
-            OPENSSL_free(t-&gt;data);
-            t-&gt;data = NULL;
-        }
+        OPENSSL_free(t-&gt;data);
+        t-&gt;data = NULL;
         if (t-&gt;expected_err) {
             OPENSSL_free(t-&gt;expected_err);
             t-&gt;expected_err = NULL;
@@ -279,15 +309,84 @@ static int setup_test(struct evp_test *t, const struct evp_test_method *tmeth)
     return 1;
 }
 
+static EVP_PKEY *find_key(const char *name, struct key_list *lst)
+{
+    for (; lst; lst = lst-&gt;next) {
+        if (!strcmp(lst-&gt;name, name))
+            return lst-&gt;key;
+    }
+    return NULL;
+}
+
+static void free_key_list(struct key_list *lst)
+{
+    while (lst != NULL) {
+	struct key_list *ltmp;
+        EVP_PKEY_free(lst-&gt;key);
+        OPENSSL_free(lst-&gt;name);
+	ltmp = lst-&gt;next;
+	OPENSSL_free(lst);
+	lst = ltmp;
+    }
+}
+
 static int process_test(struct evp_test *t, char *buf, int verbose)
 {
     char *keyword, *value;
     int rv = 0;
+    long save_pos;
+    struct key_list **lst, *key;
+    EVP_PKEY *pk = NULL;
     const struct evp_test_method *tmeth;
     if (verbose)
         fputs(buf, stdout);
     if (!parse_line(&amp;keyword, &amp;value, buf))
         return 1;
+    if (!strcmp(keyword, &quot;PrivateKey&quot;)) {
+        save_pos = ftell(t-&gt;in);
+        pk = PEM_read_PrivateKey(t-&gt;in, NULL, 0, NULL);
+        if (pk == NULL) {
+            fprintf(stderr, &quot;Error reading private key %s\n&quot;, value);
+            ERR_print_errors_fp(stderr);
+            return 0;
+        }
+        lst = &amp;t-&gt;private;
+    }
+    if (!strcmp(keyword, &quot;PublicKey&quot;)) {
+        save_pos = ftell(t-&gt;in);
+        pk = PEM_read_PUBKEY(t-&gt;in, NULL, 0, NULL);
+        if (pk == NULL) {
+            fprintf(stderr, &quot;Error reading public key %s\n&quot;, value);
+            ERR_print_errors_fp(stderr);
+            return 0;
+        }
+        lst = &amp;t-&gt;public;
+    }
+    /* If we have a key add to list */
+    if (pk) {
+        char tmpbuf[80];
+        if (find_key(value, *lst)) {
+            fprintf(stderr, &quot;Duplicate key %s\n&quot;, value);
+            return 0;
+        }
+        key = OPENSSL_malloc(sizeof(struct key_list));
+        if (!key)
+            return 0;
+        key-&gt;name = BUF_strdup(value);
+        key-&gt;key = pk;
+        key-&gt;next = *lst;
+        *lst = key;
+        /* Rewind input, read to end and update line numbers */
+        fseek(t-&gt;in, save_pos, SEEK_SET);
+        while (fgets(tmpbuf, sizeof(tmpbuf), t-&gt;in)) {
+            t-&gt;line++;
+            if (!strncmp(tmpbuf, &quot;-----END&quot;, 8))
+                return 1;
+        }
+        fprintf(stderr, &quot;Can't find key end\n&quot;);
+        return 0;
+    }
+
     /* See if keyword corresponds to a test start */
     tmeth = evp_find_test(keyword);
     if (tmeth) {
@@ -351,9 +450,13 @@ int main(int argc, char **argv)
         return 1;
     }
 
+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+
     ERR_load_crypto_strings();
     OpenSSL_add_all_algorithms();
     t.meth = NULL;
+    t.public = NULL;
+    t.private = NULL;
     t.err = NULL;
     t.line = 0;
     t.start_line = -1;
@@ -363,6 +466,7 @@ int main(int argc, char **argv)
     t.out_got = NULL;
     t.out_len = 0;
     in = fopen(argv[1], &quot;r&quot;);
+    t.in = in;
     while (fgets(buf, sizeof(buf), in)) {
         t.line++;
         if (!process_test(&amp;t, buf, 0))
@@ -373,7 +477,16 @@ int main(int argc, char **argv)
         exit(1);
     fprintf(stderr, &quot;%d tests completed with %d errors\n&quot;,
             t.ntests, t.errors);
+    free_key_list(t.public);
+    free_key_list(t.private);
     fclose(in);
+    EVP_cleanup();
+    CRYPTO_cleanup_all_ex_data();
+    ERR_remove_thread_state(NULL);
+    ERR_free_strings();
+    CRYPTO_mem_leaks_fp(stderr);
+    if (t.errors)
+        return 1;
     return 0;
 }
 
@@ -735,3 +848,336 @@ static const struct evp_test_method cipher_test_method = {
     cipher_test_parse,
     cipher_test_run
 };
+
+struct mac_data {
+    /* MAC type */
+    int type;
+    /* Algorithm string for this MAC */
+    char *alg;
+    /* MAC key */
+    unsigned char *key;
+    size_t key_len;
+    /* Input to MAC */
+    unsigned char *input;
+    size_t input_len;
+    /* Expected output */
+    unsigned char *output;
+    size_t output_len;
+};
+
+static int mac_test_init(struct evp_test *t, const char *alg)
+{
+    int type;
+    struct mac_data *mdat;
+    if (!strcmp(alg, &quot;HMAC&quot;))
+        type = EVP_PKEY_HMAC;
+    else if (!strcmp(alg, &quot;CMAC&quot;))
+        type = EVP_PKEY_CMAC;
+    else
+        return 0;
+
+    mdat = OPENSSL_malloc(sizeof(struct mac_data));
+    mdat-&gt;type = type;
+    mdat-&gt;alg = NULL;
+    mdat-&gt;key = NULL;
+    mdat-&gt;input = NULL;
+    mdat-&gt;output = NULL;
+    t-&gt;data = mdat;
+    return 1;
+}
+
+static void mac_test_cleanup(struct evp_test *t)
+{
+    struct mac_data *mdat = t-&gt;data;
+    test_free(mdat-&gt;alg);
+    test_free(mdat-&gt;key);
+    test_free(mdat-&gt;input);
+    test_free(mdat-&gt;output);
+}
+
+static int mac_test_parse(struct evp_test *t,
+                          const char *keyword, const char *value)
+{
+    struct mac_data *mdata = t-&gt;data;
+    if (!strcmp(keyword, &quot;Key&quot;))
+        return test_bin(value, &amp;mdata-&gt;key, &amp;mdata-&gt;key_len);
+    if (!strcmp(keyword, &quot;Algorithm&quot;)) {
+        mdata-&gt;alg = BUF_strdup(value);
+        if (!mdata-&gt;alg)
+            return 0;
+        return 1;
+    }
+    if (!strcmp(keyword, &quot;Input&quot;))
+        return test_bin(value, &amp;mdata-&gt;input, &amp;mdata-&gt;input_len);
+    if (!strcmp(keyword, &quot;Output&quot;))
+        return test_bin(value, &amp;mdata-&gt;output, &amp;mdata-&gt;output_len);
+    return 0;
+}
+
+static int mac_test_run(struct evp_test *t)
+{
+    struct mac_data *mdata = t-&gt;data;
+    const char *err = &quot;INTERNAL_ERROR&quot;;
+    EVP_MD_CTX *mctx = NULL;
+    EVP_PKEY_CTX *pctx = NULL, *genctx = NULL;
+    EVP_PKEY *key = NULL;
+    const EVP_MD *md = NULL;
+    unsigned char *mac = NULL;
+    size_t mac_len;
+
+    err = &quot;MAC_PKEY_CTX_ERROR&quot;;
+    genctx = EVP_PKEY_CTX_new_id(mdata-&gt;type, NULL);
+    if (!genctx)
+        goto err;
+
+    err = &quot;MAC_KEYGEN_INIT_ERROR&quot;;
+    if (EVP_PKEY_keygen_init(genctx) &lt;= 0)
+        goto err;
+    if (mdata-&gt;type == EVP_PKEY_CMAC) {
+        err = &quot;MAC_ALGORITHM_SET_ERROR&quot;;
+        if (EVP_PKEY_CTX_ctrl_str(genctx, &quot;cipher&quot;, mdata-&gt;alg) &lt;= 0)
+            goto err;
+    }
+
+    err = &quot;MAC_KEY_SET_ERROR&quot;;
+    if (EVP_PKEY_CTX_set_mac_key(genctx, mdata-&gt;key, mdata-&gt;key_len) &lt;= 0)
+        goto err;
+
+    err = &quot;MAC_KEY_GENERATE_ERROR&quot;;
+    if (EVP_PKEY_keygen(genctx, &amp;key) &lt;= 0)
+        goto err;
+    if (mdata-&gt;type == EVP_PKEY_HMAC) {
+        err = &quot;MAC_ALGORITHM_SET_ERROR&quot;;
+        md = EVP_get_digestbyname(mdata-&gt;alg);
+        if (!md)
+            goto err;
+    }
+    mctx = EVP_MD_CTX_create();
+    if (!mctx)
+        goto err;
+    err = &quot;DIGESTSIGNINIT_ERROR&quot;;
+    if (!EVP_DigestSignInit(mctx, &amp;pctx, md, NULL, key))
+        goto err;
+
+    err = &quot;DIGESTSIGNUPDATE_ERROR&quot;;
+    if (!EVP_DigestSignUpdate(mctx, mdata-&gt;input, mdata-&gt;input_len))
+        goto err;
+    err = &quot;DIGESTSIGNFINAL_LENGTH_ERROR&quot;;
+    if (!EVP_DigestSignFinal(mctx, NULL, &amp;mac_len))
+        goto err;
+    mac = OPENSSL_malloc(mac_len);
+    if (!mac) {
+        fprintf(stderr, &quot;Error allocating mac buffer!\n&quot;);
+        exit(1);
+    }
+    if (!EVP_DigestSignFinal(mctx, mac, &amp;mac_len))
+        goto err;
+    err = &quot;MAC_LENGTH_MISMATCH&quot;;
+    if (mac_len != mdata-&gt;output_len)
+        goto err;
+    err = &quot;MAC_MISMATCH&quot;;
+    if (check_output(t, mdata-&gt;output, mac, mac_len))
+        goto err;
+    err = NULL;
+ err:
+    if (mctx)
+        EVP_MD_CTX_destroy(mctx);
+    if (mac)
+        OPENSSL_free(mac);
+    if (genctx)
+        EVP_PKEY_CTX_free(genctx);
+    if (key)
+        EVP_PKEY_free(key);
+    t-&gt;err = err;
+    return 1;
+}
+
+static const struct evp_test_method mac_test_method = {
+    &quot;MAC&quot;,
+    mac_test_init,
+    mac_test_cleanup,
+    mac_test_parse,
+    mac_test_run
+};
+
+/*
+ * Public key operations. These are all very similar and can share
+ * a lot of common code.
+ */
+
+struct pkey_data {
+    /* Context for this operation */
+    EVP_PKEY_CTX *ctx;
+    /* Key operation to perform */
+    int (*keyop) (EVP_PKEY_CTX *ctx,
+                  unsigned char *sig, size_t *siglen,
+                  const unsigned char *tbs, size_t tbslen);
+    /* Input to MAC */
+    unsigned char *input;
+    size_t input_len;
+    /* Expected output */
+    unsigned char *output;
+    size_t output_len;
+};
+
+/*
+ * Perform public key operation setup: lookup key, allocated ctx and call
+ * the appropriate initialisation function
+ */
+static int pkey_test_init(struct evp_test *t, const char *name,
+                          int use_public,
+                          int (*keyopinit) (EVP_PKEY_CTX *ctx),
+                          int (*keyop) (EVP_PKEY_CTX *ctx,
+                                        unsigned char *sig, size_t *siglen,
+                                        const unsigned char *tbs,
+                                        size_t tbslen)
+    )
+{
+    struct pkey_data *kdata;
+    EVP_PKEY *pkey = NULL;
+    kdata = OPENSSL_malloc(sizeof(struct pkey_data));
+    if (!kdata)
+        return 0;
+    kdata-&gt;ctx = NULL;
+    kdata-&gt;input = NULL;
+    kdata-&gt;output = NULL;
+    kdata-&gt;keyop = keyop;
+    t-&gt;data = kdata;
+    if (use_public)
+        pkey = find_key(name, t-&gt;public);
+    if (!pkey)
+        pkey = find_key(name, t-&gt;private);
+    if (!pkey)
+        return 0;
+    kdata-&gt;ctx = EVP_PKEY_CTX_new(pkey, NULL);
+    if (!kdata-&gt;ctx)
+        return 0;
+    if (keyopinit(kdata-&gt;ctx) &lt;= 0)
+        return 0;
+    return 1;
+}
+
+static void pkey_test_cleanup(struct evp_test *t)
+{
+    struct pkey_data *kdata = t-&gt;data;
+    if (kdata-&gt;input)
+        OPENSSL_free(kdata-&gt;input);
+    if (kdata-&gt;output)
+        OPENSSL_free(kdata-&gt;output);
+    if (kdata-&gt;ctx)
+        EVP_PKEY_CTX_free(kdata-&gt;ctx);
+}
+
+static int pkey_test_parse(struct evp_test *t,
+                           const char *keyword, const char *value)
+{
+    struct pkey_data *kdata = t-&gt;data;
+    if (!strcmp(keyword, &quot;Input&quot;))
+        return test_bin(value, &amp;kdata-&gt;input, &amp;kdata-&gt;input_len);
+    if (!strcmp(keyword, &quot;Output&quot;))
+        return test_bin(value, &amp;kdata-&gt;output, &amp;kdata-&gt;output_len);
+    if (!strcmp(keyword, &quot;Ctrl&quot;)) {
+        char *p = strchr(value, ':');
+        if (p)
+            *p++ = 0;
+        if (EVP_PKEY_CTX_ctrl_str(kdata-&gt;ctx, value, p) &lt;= 0)
+            return 0;
+        return 1;
+    }
+    return 0;
+}
+
+static int pkey_test_run(struct evp_test *t)
+{
+    struct pkey_data *kdata = t-&gt;data;
+    unsigned char *out = NULL;
+    size_t out_len;
+    const char *err = &quot;KEYOP_LENGTH_ERROR&quot;;
+    if (kdata-&gt;keyop(kdata-&gt;ctx, NULL, &amp;out_len, kdata-&gt;input,
+                     kdata-&gt;input_len) &lt;= 0)
+        goto err;
+    out = OPENSSL_malloc(out_len);
+    if (!out) {
+        fprintf(stderr, &quot;Error allocating output buffer!\n&quot;);
+        exit(1);
+    }
+    err = &quot;KEYOP_ERROR&quot;;
+    if (kdata-&gt;keyop
+        (kdata-&gt;ctx, out, &amp;out_len, kdata-&gt;input, kdata-&gt;input_len) &lt;= 0)
+        goto err;
+    err = &quot;KEYOP_LENGTH_MISMATCH&quot;;
+    if (out_len != kdata-&gt;output_len)
+        goto err;
+    err = &quot;KEYOP_MISMATCH&quot;;
+    if (check_output(t, kdata-&gt;output, out, out_len))
+        goto err;
+    err = NULL;
+ err:
+    if (out)
+        OPENSSL_free(out);
+    t-&gt;err = err;
+    return 1;
+}
+
+static int sign_test_init(struct evp_test *t, const char *name)
+{
+    return pkey_test_init(t, name, 0, EVP_PKEY_sign_init, EVP_PKEY_sign);
+}
+
+static const struct evp_test_method psign_test_method = {
+    &quot;Sign&quot;,
+    sign_test_init,
+    pkey_test_cleanup,
+    pkey_test_parse,
+    pkey_test_run
+};
+
+static int verify_recover_test_init(struct evp_test *t, const char *name)
+{
+    return pkey_test_init(t, name, 1, EVP_PKEY_verify_recover_init,
+                          EVP_PKEY_verify_recover);
+}
+
+static const struct evp_test_method pverify_recover_test_method = {
+    &quot;VerifyRecover&quot;,
+    verify_recover_test_init,
+    pkey_test_cleanup,
+    pkey_test_parse,
+    pkey_test_run
+};
+
+static int decrypt_test_init(struct evp_test *t, const char *name)
+{
+    return pkey_test_init(t, name, 0, EVP_PKEY_decrypt_init,
+                          EVP_PKEY_decrypt);
+}
+
+static const struct evp_test_method pdecrypt_test_method = {
+    &quot;Decrypt&quot;,
+    decrypt_test_init,
+    pkey_test_cleanup,
+    pkey_test_parse,
+    pkey_test_run
+};
+
+static int verify_test_init(struct evp_test *t, const char *name)
+{
+    return pkey_test_init(t, name, 1, EVP_PKEY_verify_init, 0);
+}
+
+static int verify_test_run(struct evp_test *t)
+{
+    struct pkey_data *kdata = t-&gt;data;
+    if (EVP_PKEY_verify(kdata-&gt;ctx, kdata-&gt;output, kdata-&gt;output_len,
+                        kdata-&gt;input, kdata-&gt;input_len) &lt;= 0)
+        t-&gt;err = &quot;VERIFY_ERROR&quot;;
+    return 1;
+}
+
+static const struct evp_test_method pverify_test_method = {
+    &quot;Verify&quot;,
+    verify_test_init,
+    pkey_test_cleanup,
+    pkey_test_parse,
+    verify_test_run
+};
diff --git a/crypto/evp/evptests.txt b/crypto/evp/evptests.txt
index 718f723..da85100 100644
--- a/crypto/evp/evptests.txt
+++ b/crypto/evp/evptests.txt
@@ -1790,4 +1790,261 @@ Key = 5840df6e29b02af1ab493b705bf16ea1ae8338f4dcc176a8
 Plaintext = 466f7250617369
 Ciphertext = afbeb0f07dfbf5419200f2ccb50bb24f
 
-
+# HMAC tests from RFC2104
+MAC = HMAC
+Algorithm = MD5
+Key = 0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b
+Input = &quot;Hi There&quot;
+Output = 9294727a3638bb1c13f48ef8158bfc9d
+
+MAC = HMAC
+Algorithm = MD5
+Key = &quot;Jefe&quot;
+Input = &quot;what do ya want for nothing?&quot;
+Output = 750c783e6ab0b503eaa86e310a5db738
+
+MAC = HMAC
+Algorithm = MD5
+Key = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
+Input = DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
+Output = 56be34521d144c88dbb8c733f0e8b3f6
+
+# HMAC tests from NIST test data
+
+MAC = HMAC
+Algorithm = SHA1
+Input = &quot;Sample message for keylen=blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F
+Output = 5FD596EE78D5553C8FF4E72D266DFD192366DA29
+MAC = HMAC
+Algorithm = SHA1
+Input = &quot;Sample message for keylen&lt;blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F10111213
+Output = 4C99FF0CB1B31BD33F8431DBAF4D17FCD356A807
+MAC = HMAC
+Algorithm = SHA1
+Input = &quot;Sample message for keylen=blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F60616263
+Output = 2D51B2F7750E410584662E38F133435F4C4FD42A
+MAC = HMAC
+Algorithm = SHA224
+Input = &quot;Sample message for keylen=blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F
+Output = C7405E3AE058E8CD30B08B4140248581ED174CB34E1224BCC1EFC81B
+MAC = HMAC
+Algorithm = SHA224
+Input = &quot;Sample message for keylen&lt;blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B
+Output = E3D249A8CFB67EF8B7A169E9A0A599714A2CECBA65999A51BEB8FBBE
+MAC = HMAC
+Algorithm = SHA224
+Input = &quot;Sample message for keylen=blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F60616263
+Output = 91C52509E5AF8531601AE6230099D90BEF88AAEFB961F4080ABC014D
+MAC = HMAC
+Algorithm = SHA256
+Input = &quot;Sample message for keylen=blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F
+Output = 8BB9A1DB9806F20DF7F77B82138C7914D174D59E13DC4D0169C9057B133E1D62
+MAC = HMAC
+Algorithm = SHA256
+Input = &quot;Sample message for keylen&lt;blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F
+Output = A28CF43130EE696A98F14A37678B56BCFCBDD9E5CF69717FECF5480F0EBDF790
+MAC = HMAC
+Algorithm = SHA256
+Input = &quot;Sample message for keylen=blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F60616263
+Output = BDCCB6C72DDEADB500AE768386CB38CC41C63DBB0878DDB9C7A38A431B78378D
+MAC = HMAC
+Algorithm = SHA384
+Input = &quot;Sample message for keylen=blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F
+Output = 63C5DAA5E651847CA897C95814AB830BEDEDC7D25E83EEF9195CD45857A37F448947858F5AF50CC2B1B730DDF29671A9
+MAC = HMAC
+Algorithm = SHA384
+Input = &quot;Sample message for keylen&lt;blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F
+Output = 6EB242BDBB582CA17BEBFA481B1E23211464D2B7F8C20B9FF2201637B93646AF5AE9AC316E98DB45D9CAE773675EEED0
+MAC = HMAC
+Algorithm = SHA384
+Input = &quot;Sample message for keylen=blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7
+Output = 5B664436DF69B0CA22551231A3F0A3D5B4F97991713CFA84BFF4D0792EFF96C27DCCBBB6F79B65D548B40E8564CEF594
+MAC = HMAC
+Algorithm = SHA512
+Input = &quot;Sample message for keylen=blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F
+Output = FC25E240658CA785B7A811A8D3F7B4CA48CFA26A8A366BF2CD1F836B05FCB024BD36853081811D6CEA4216EBAD79DA1CFCB95EA4586B8A0CE356596A55FB1347
+MAC = HMAC
+Algorithm = SHA512
+Input = &quot;Sample message for keylen&lt;blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F
+Output = FD44C18BDA0BB0A6CE0E82B031BF2818F6539BD56EC00BDC10A8A2D730B3634DE2545D639B0F2CF710D0692C72A1896F1F211C2B922D1A96C392E07E7EA9FEDC
+MAC = HMAC
+Algorithm = SHA512
+Input = &quot;Sample message for keylen=blocklen&quot;
+Key = 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7
+Output = D93EC8D2DE1AD2A9957CB9B83F14E76AD6B5E0CCE285079A127D3B14BCCB7AA7286D4AC0D4CE64215F2BC9E6870B33D97438BE4AAA20CDA5C5A912B48B8E27F3
+
+# CMAC tests from FIPS module
+
+MAC = CMAC
+Algorithm = AES-128-CBC
+Key = 77A77FAF290C1FA30C683DF16BA7A77B
+Input = 020683E1F0392F4CAC54318B6029259E9C553DBC4B6AD998E64D58E4E7DC2E13
+Output = FBFEA41BF9740CB501F1292C21CEBB40
+
+MAC = CMAC
+Algorithm = AES-192-CBC
+Key = 7B32391369AA4CA97558095BE3C3EC862BD057CEF1E32D62
+Input =
+Output = E4D9340B03E67DEFD4969CC1ED3735E6
+
+MAC = CMAC
+Algorithm = AES-256-CBC
+Key = 0B122AC8F34ED1FE082A3625D157561454167AC145A10BBF77C6A70596D574F1
+Input = 498B53FDEC87EDCBF07097DCCDE93A084BAD7501A224E388DF349CE18959FE8485F8AD1537F0D896EA73BEDC7214713F
+Output = F62C46329B41085625669BAF51DEA66A
+
+MAC = CMAC
+Algorithm = DES-EDE3-CBC
+Key = 89BCD952A8C8AB371AF48AC7D07085D5EFF702E6D62CDC23
+Input = FA620C1BBE97319E9A0CF0492121F7A20EB08A6A709DCBD00AAF38E4F99E754E
+Output = 8F49A1B7D6AA2258
+
+# Public key algorithm tests
+
+# Private keys used for PKEY operations.
+
+# RSA 2048 bit key.
+
+PrivateKey = RSA-2048
+
+-----BEGIN PRIVATE KEY-----
+MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDNAIHqeyrh6gbV
+n3xz2f+5SglhXC5Lp8Y2zvCN01M+wxhVJbAVx2m5mnfWclv5w1Mqm25fZifV+4UW
+B2jT3anL01l0URcX3D0wnS/EfuQfl+Mq23+d2GShxHZ6Zm7NcbwarPXnUX9LOFlP
+6psF5C1a2pkSAIAT5FMWpNm7jtCGuI0odYusr5ItRqhotIXSOcm66w4rZFknEPQr
+LR6gpLSALAvsqzKPimiwBzvbVG/uqYCdKEmRKzkMFTK8finHZY+BdfrkbzQzL/h7
+yrPkBkm5hXeGnaDqcYNT8HInVIhpE2SHYNEivmduD8SD3SD/wxvalqMZZsmqLnWt
+A95H4cRPAgMBAAECggEAYCl6x5kbFnoG1rJHWLjL4gi+ubLZ7Jc4vYD5Ci41AF3X
+ziktnim6iFvTFv7x8gkTvArJDWsICLJBTYIQREHYYkozzgIzyPeApIs3Wv8C12cS
+IopwJITbP56+zM+77hcJ26GCgA2Unp5CFuC/81WDiPi9kNo3Oh2CdD7D+90UJ/0W
+glplejFpEuhpU2URfKL4RckJQF/KxV+JX8FdIDhsJu54yemQdQKaF4psHkzwwgDo
+qc+yfp0Vb4bmwq3CKxqEoc1cpbJ5CHXXlAfISzUjlcuBzD/tW7BDtp7eDAcgRVAC
+XO6MX0QBcLYSC7SOD3R7zY9SIRCFDfBDxCjf0YcFMQKBgQD2+WG0fLwDXTrt68fe
+hQqVa2Xs25z2B2QGPxWqSFU8WNly/mZ1BW413f3De/O58vYi7icTNyVoScm+8hdv
+6PfD+LuRujdN1TuvPeyBTSvewQwf3IjN0Wh28mse36PwlBl+301C/x+ylxEDuJjK
+hZxCcocIaoQqtBC7ac8tNa9r4wKBgQDUfnJKf/QQSLJwwlJKQQGHi3MVm7c9PbwY
+eyIOY1s1NPluJDoYTZP4YLa/u2txwe2aHh9FhYMCPDAelqaSwaCLU9DsnKkQEA2A
+RR47fcagG6xK7O+N95iEa8I1oIy7os9MBoBMwRIZ6VYIxxTj8UMNSR+tu6MqV1Gg
+T5d0WDTJpQKBgCHyRSu5uV39AoyRS/eZ8cp36JqV1Q08FtOE+EVfi9evnrPfo9WR
+2YQt7yNfdjCo5IwIj/ZkLhAXlFNakz4el2+oUJ/HKLLaDEoaCNf883q6rh/zABrK
+HcG7sF2d/7qhoJ9/se7zgjfZ68zHIrkzhDbd5xGREnmMJoCcGo3sQyBhAoGAH3UQ
+qmLC2N5KPFMoJ4H0HgLQ6LQCrnhDLkScSBEBYaEUA/AtAYgKjcyTgVLXlyGkcRpg
+esRHHr+WSBD5W+R6ReYEmeKfTJdzyDdzQE9gZjdyjC0DUbsDwybIu3OnIef6VEDq
+IXK7oUZfzDDcsNn4mTDoFaoff5cpqFfgDgM43VkCgYBNHw11b+d+AQmaZS9QqIt7
+aF3FvwCYHV0jdv0Mb+Kc1bY4c0R5MFpzrTwVmdOerjuuA1+9b+0Hwo3nBZM4eaBu
+SOamA2hu2OJWCl9q8fLCT69KqWDjghhvFe7c6aJJGucwaA3Uz3eLcPqoaCarMiNH
+fMkTd7GabVourqIZdgvu1Q==
+-----END PRIVATE KEY-----
+
+# EC P-256 key
+
+PrivateKey=P-256
+
+-----BEGIN PRIVATE KEY-----
+MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgiocvtiiTxNH/xbnw
++RdYBp+DUuCPoFpJ+NuSbLVyhyWhRANCAAQsFQ9CnOcPIWwlLPXgYs4fY5zV0WXH
++JQkBywnGX14szuSDpXNtmTpkNzwz+oNlOKo5q+dDlgFbmUxBJJbn+bJ
+-----END PRIVATE KEY-----
+
+# RSA tests
+
+Sign = RSA-2048
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF1234&quot;
+Output = c09d402423cbf233d26cae21f954547bc43fe80fd41360a0336cfdbe9aedad05bef6fd2eaee6cd60089a52482d4809a238149520df3bdde4cb9e23d9307b05c0a6f327052325a29adf2cc95b66523be7024e2a585c3d4db15dfbe146efe0ecdc0402e33fe5d40324ee96c5c3edd374a15cdc0f5d84aa243c0f07e188c6518fbfceae158a9943be398e31097da81b62074f626eff738be6160741d5a26957a482b3251fd85d8df78b98148459de10aa93305dbb4a5230aa1da291a9b0e481918f99b7638d72bb687f97661d304ae145d64a474437a4ef39d7b8059332ddeb07e92bf6e0e3acaf8afedc93795e4511737ec1e7aab6d5bc9466afc950c1c17b48ad
+
+Verify = RSA-2048
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF1234&quot;
+Output = c09d402423cbf233d26cae21f954547bc43fe80fd41360a0336cfdbe9aedad05bef6fd2eaee6cd60089a52482d4809a238149520df3bdde4cb9e23d9307b05c0a6f327052325a29adf2cc95b66523be7024e2a585c3d4db15dfbe146efe0ecdc0402e33fe5d40324ee96c5c3edd374a15cdc0f5d84aa243c0f07e188c6518fbfceae158a9943be398e31097da81b62074f626eff738be6160741d5a26957a482b3251fd85d8df78b98148459de10aa93305dbb4a5230aa1da291a9b0e481918f99b7638d72bb687f97661d304ae145d64a474437a4ef39d7b8059332ddeb07e92bf6e0e3acaf8afedc93795e4511737ec1e7aab6d5bc9466afc950c1c17b48ad
+
+# Digest too long
+Sign = RSA-2048
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF12345&quot;
+Output = 00
+Result = KEYOP_ERROR
+
+# Digest too short
+Sign = RSA-2048
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF12345&quot;
+Output = 00
+Result = KEYOP_ERROR
+
+# Mismatched digest
+Verify = RSA-2048
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF1233&quot;
+Output = c09d402423cbf233d26cae21f954547bc43fe80fd41360a0336cfdbe9aedad05bef6fd2eaee6cd60089a52482d4809a238149520df3bdde4cb9e23d9307b05c0a6f327052325a29adf2cc95b66523be7024e2a585c3d4db15dfbe146efe0ecdc0402e33fe5d40324ee96c5c3edd374a15cdc0f5d84aa243c0f07e188c6518fbfceae158a9943be398e31097da81b62074f626eff738be6160741d5a26957a482b3251fd85d8df78b98148459de10aa93305dbb4a5230aa1da291a9b0e481918f99b7638d72bb687f97661d304ae145d64a474437a4ef39d7b8059332ddeb07e92bf6e0e3acaf8afedc93795e4511737ec1e7aab6d5bc9466afc950c1c17b48ad
+Result = VERIFY_ERROR
+
+# Corrupted signature
+Verify = RSA-2048
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF1233&quot;
+Output = c09d402423cbf233d26cae21f954547bc43fe80fd41360a0336cfdbe9aedad05bef6fd2eaee6cd60089a52482d4809a238149520df3bdde4cb9e23d9307b05c0a6f327052325a29adf2cc95b66523be7024e2a585c3d4db15dfbe146efe0ecdc0402e33fe5d40324ee96c5c3edd374a15cdc0f5d84aa243c0f07e188c6518fbfceae158a9943be398e31097da81b62074f626eff738be6160741d5a26957a482b3251fd85d8df78b98148459de10aa93305dbb4a5230aa1da291a9b0e481918f99b7638d72bb687f97661d304ae145d64a474437a4ef39d7b8059332ddeb07e92bf6e0e3acaf8afedc93795e4511737ec1e7aab6d5bc9466afc950c1c17b48ae
+Result = VERIFY_ERROR
+
+# EC tests
+
+Verify = P-256
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF1234&quot;
+Output = 3045022100b1d1cb1a577035bccdd5a86c6148c2cc7c633cd42b7234139b593076d041e15202201898cdd52b41ca502098184b409cf83a21bc945006746e3b7cea52234e043ec8
+
+# Digest too long
+Verify = P-256
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF12345&quot;
+Output = 3045022100b1d1cb1a577035bccdd5a86c6148c2cc7c633cd42b7234139b593076d041e15202201898cdd52b41ca502098184b409cf83a21bc945006746e3b7cea52234e043ec8
+Result = VERIFY_ERROR
+
+# Digest too short
+Verify = P-256
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF123&quot;
+Output = 3045022100b1d1cb1a577035bccdd5a86c6148c2cc7c633cd42b7234139b593076d041e15202201898cdd52b41ca502098184b409cf83a21bc945006746e3b7cea52234e043ec8
+Result = VERIFY_ERROR
+
+# Digest invalid
+Verify = P-256
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF1235&quot;
+Output = 3045022100b1d1cb1a577035bccdd5a86c6148c2cc7c633cd42b7234139b593076d041e15202201898cdd52b41ca502098184b409cf83a21bc945006746e3b7cea52234e043ec8
+Result = VERIFY_ERROR
+
+# Invalid signature
+Verify = P-256
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF1234&quot;
+Output = 3045022100b1d1cb1a577035bccdd5a86c6148c2cc7c633cd42b7234139b593076d041e15202201898cdd52b41ca502098184b409cf83a21bc945006746e3b7cea52234e043ec7
+Result = VERIFY_ERROR
+
+# Garbage after signature
+Verify = P-256
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF1234&quot;
+Output = 3045022100b1d1cb1a577035bccdd5a86c6148c2cc7c633cd42b7234139b593076d041e15202201898cdd52b41ca502098184b409cf83a21bc945006746e3b7cea52234e043ec800
+Result = VERIFY_ERROR
+
+# BER signature
+Verify = P-256
+Ctrl = digest:SHA1
+Input = &quot;0123456789ABCDEF1234&quot;
+Output = 3080022100b1d1cb1a577035bccdd5a86c6148c2cc7c633cd42b7234139b593076d041e15202201898cdd52b41ca502098184b409cf83a21bc945006746e3b7cea52234e043ec80000
+Result = VERIFY_ERROR
diff --git a/crypto/evp/pmeth_gn.c b/crypto/evp/pmeth_gn.c
index 46057cf..45559eb 100644
--- a/crypto/evp/pmeth_gn.c
+++ b/crypto/evp/pmeth_gn.c
@@ -202,9 +202,7 @@ EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,
         return NULL;
     if (EVP_PKEY_keygen_init(mac_ctx) &lt;= 0)
         goto merr;
-    if (EVP_PKEY_CTX_ctrl(mac_ctx, -1, EVP_PKEY_OP_KEYGEN,
-                          EVP_PKEY_CTRL_SET_MAC_KEY,
-                          keylen, (void *)key) &lt;= 0)
+    if (EVP_PKEY_CTX_set_mac_key(mac_ctx, key, keylen) &lt;= 0)
         goto merr;
     if (EVP_PKEY_keygen(mac_ctx, &amp;mac_key) &lt;= 0)
         goto merr;
</PRE>
















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000478.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="000481.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#480">[ date ]</a>
              <a href="thread.html#480">[ thread ]</a>
              <a href="subject.html#480">[ subject ]</a>
              <a href="author.html#480">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
