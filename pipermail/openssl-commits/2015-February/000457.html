<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2015-February/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C20150209222142.C1C1E1DF1AB%40butler.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000456.html">
   <LINK REL="Next"  HREF="000459.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Andy Polyakov</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C20150209222142.C1C1E1DF1AB%40butler.localdomain%3E"
       TITLE="[openssl-commits] [openssl]  master update">appro at openssl.org
       </A><BR>
    <I>Mon Feb  9 22:21:42 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="000456.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="000459.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#457">[ date ]</a>
              <a href="thread.html#457">[ thread ]</a>
              <a href="subject.html#457">[ subject ]</a>
              <a href="author.html#457">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  79ee5afa26da1f2e3d16376d20b273cc759b0c1b (commit)
       via  aa9db2d292f81769f0f48b1740a6b3a36b1c31af (commit)
      from  d6c5462ef84356446ed133f6d28d34a5c7168bf4 (commit)


- Log -----------------------------------------------------------------
commit 79ee5afa26da1f2e3d16376d20b273cc759b0c1b
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon Feb 9 23:21:11 2015 +0100

    Engage ecp_nistz256-x86 module.
    
    Reviewed-by: Emilia K&#228;sper &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">emilia at openssl.org</A>&gt;

commit aa9db2d292f81769f0f48b1740a6b3a36b1c31af
Author: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
Date:   Mon Feb 9 23:19:16 2015 +0100

    Add ec/asm/ecp_nistz256-x86.pl module.
    
    Reviewed-by: Emilia K&#228;sper &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">emilia at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 Configure                         |    2 +-
 TABLE                             |   60 +-
 crypto/ec/Makefile                |    3 +
 crypto/ec/asm/ecp_nistz256-x86.pl | 1823 +++++++++++++++++++++++++++++++++++++
 4 files changed, 1857 insertions(+), 31 deletions(-)
 create mode 100755 crypto/ec/asm/ecp_nistz256-x86.pl

diff --git a/Configure b/Configure
index 5fb5f13..f6dd38e 100755
--- a/Configure
+++ b/Configure
@@ -128,7 +128,7 @@ my $tlib=&quot;-lnsl -lsocket&quot;;
 my $bits1=&quot;THIRTY_TWO_BIT &quot;;
 my $bits2=&quot;SIXTY_FOUR_BIT &quot;;
 
-my $x86_asm=&quot;x86cpuid.o:bn-586.o co-586.o x86-mont.o x86-gf2m.o::des-586.o crypt586.o:aes-586.o vpaes-x86.o aesni-x86.o:bf-586.o:md5-586.o:sha1-586.o sha256-586.o sha512-586.o:cast-586.o:rc4-586.o:rmd-586.o:rc5-586.o:wp_block.o wp-mmx.o:cmll-x86.o:ghash-x86.o:e_padlock-x86.o&quot;;
+my $x86_asm=&quot;x86cpuid.o:bn-586.o co-586.o x86-mont.o x86-gf2m.o:ecp_nistz256.o ecp_nistz256-x86.o:des-586.o crypt586.o:aes-586.o vpaes-x86.o aesni-x86.o:bf-586.o:md5-586.o:sha1-586.o sha256-586.o sha512-586.o:cast-586.o:rc4-586.o:rmd-586.o:rc5-586.o:wp_block.o wp-mmx.o:cmll-x86.o:ghash-x86.o:e_padlock-x86.o&quot;;
 
 my $x86_elf_asm=&quot;$x86_asm:elf&quot;;
 
diff --git a/TABLE b/TABLE
index 6235666..7193a5a 100644
--- a/TABLE
+++ b/TABLE
@@ -248,7 +248,7 @@ $lflags       =
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -282,7 +282,7 @@ $lflags       =
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -350,7 +350,7 @@ $lflags       =
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -418,7 +418,7 @@ $lflags       = -L/dev/env/WATT_ROOT/lib -lwatt
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -588,7 +588,7 @@ $lflags       = -lsocket
 $bn_ops       = DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -690,7 +690,7 @@ $lflags       =
 $bn_ops       = BN_LLONG RC4_INDEX EXPORT_VAR_AS_FN RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -1064,7 +1064,7 @@ $lflags       = -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -1132,7 +1132,7 @@ $lflags       = -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -1200,7 +1200,7 @@ $lflags       = -Wl,-search_paths_first%
 $bn_ops       = BN_LLONG RC4_INT RC4_CHUNK DES_UNROLL BF_PTR
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -1404,7 +1404,7 @@ $lflags       =
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -1438,7 +1438,7 @@ $lflags       =
 $bn_ops       = BN_LLONG RC4_INDEX EXPORT_VAR_AS_FN RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -1948,7 +1948,7 @@ $lflags       = -Wl,-search_paths_first%
 $bn_ops       = BN_LLONG RC4_INT RC4_CHUNK DES_UNROLL BF_PTR
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -2152,7 +2152,7 @@ $lflags       = -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -2186,7 +2186,7 @@ $lflags       = -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -2288,7 +2288,7 @@ $lflags       = -lefence -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -2322,7 +2322,7 @@ $lflags       = -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -2458,7 +2458,7 @@ $lflags       = -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -2492,7 +2492,7 @@ $lflags       = -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -2560,7 +2560,7 @@ $lflags       =
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -2764,7 +2764,7 @@ $lflags       = -rdynamic -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -3478,7 +3478,7 @@ $lflags       = -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -3954,7 +3954,7 @@ $lflags       =
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -4056,7 +4056,7 @@ $lflags       = -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -4158,7 +4158,7 @@ $lflags       = -ldl -no_cpprt
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -4770,7 +4770,7 @@ $lflags       = -lws2_32 -lgdi32 -lcrypt32
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT EXPORT_VAR_AS_FN
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -5314,7 +5314,7 @@ $lflags       = -lsocket -lnsl
 $bn_ops       = DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -5348,7 +5348,7 @@ $lflags       = -lsocket -lnsl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -5620,7 +5620,7 @@ $lflags       = -lsocket -lnsl -ldl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -6028,7 +6028,7 @@ $lflags       = -lsocket -lnsl
 $bn_ops       = BN_LLONG MD2_CHAR RC4_INDEX DES_PTR DES_RISC1 DES_UNROLL
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
@@ -6062,7 +6062,7 @@ $lflags       = -lsocket -lnsl
 $bn_ops       = BN_LLONG DES_PTR DES_RISC1 DES_UNROLL RC4_INDEX MD2_INT
 $cpuid_obj    = x86cpuid.o
 $bn_obj       = bn-586.o co-586.o x86-mont.o x86-gf2m.o
-$ec_obj       = 
+$ec_obj       = ecp_nistz256.o ecp_nistz256-x86.o
 $des_obj      = des-586.o crypt586.o
 $aes_obj      = aes-586.o vpaes-x86.o aesni-x86.o
 $bf_obj       = bf-586.o
diff --git a/crypto/ec/Makefile b/crypto/ec/Makefile
index 852183a..319e003 100644
--- a/crypto/ec/Makefile
+++ b/crypto/ec/Makefile
@@ -48,6 +48,9 @@ lib:	$(LIBOBJ)
 	$(RANLIB) $(LIB) || echo Never mind.
 	@touch lib
 
+ecp_nistz256-x86.s:	asm/ecp_nistz256-x86.pl
+	$(PERL) asm/ecp_nistz256-x86.pl $(PERLASM_SCHEME) $(CFLAGS) $(PROCESSOR) &gt; $@
+
 ecp_nistz256-x86_64.s: asm/ecp_nistz256-x86_64.pl
 	$(PERL) asm/ecp_nistz256-x86_64.pl $(PERLASM_SCHEME) &gt; $@
 
diff --git a/crypto/ec/asm/ecp_nistz256-x86.pl b/crypto/ec/asm/ecp_nistz256-x86.pl
new file mode 100755
index 0000000..0670c69
--- /dev/null
+++ b/crypto/ec/asm/ecp_nistz256-x86.pl
@@ -0,0 +1,1823 @@
+#!/usr/bin/env perl
+
+# ====================================================================
+# Written by Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt; for the OpenSSL
+# project. The module is, however, dual licensed under OpenSSL and
+# CRYPTOGAMS licenses depending on where you obtain it. For further
+# details see <A HREF="http://www.openssl.org/~appro/cryptogams/.">http://www.openssl.org/~appro/cryptogams/.</A>
+# ====================================================================
+#
+# ECP_NISTZ256 module for x86/SSE2.
+#
+# October 2014.
+#
+# Original ECP_NISTZ256 submission targeting x86_64 is detailed in
+# <A HREF="http://eprint.iacr.org/2013/816.">http://eprint.iacr.org/2013/816.</A> In the process of adaptation
+# original .c module was made 32-bit savvy in order to make this
+# implementation possible.
+#
+#		with/without -DECP_NISTZ256_ASM
+# Pentium	+66-163%
+# PIII		+72-172%
+# P4		+65-132%
+# Core2		+90-215%
+# Sandy Bridge	+105-265% (contemporary i[57]-* are all close to this)
+# Atom		+65-155%
+# Opteron	+54-110%
+# Bulldozer	+99-240%
+# VIA Nano	+93-290%
+#
+# Ranges denote minimum and maximum improvement coefficients depending
+# on benchmark. Lower coefficients are for ECDSA sign, server-side
+# operation. Keep in mind that +200% means 3x improvement.
+
+$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+push(@INC,&quot;${dir}&quot;,&quot;${dir}../../perlasm&quot;);
+require &quot;x86asm.pl&quot;;
+
+&amp;asm_init($ARGV[0],&quot;ecp_nistz256-x86.pl&quot;,$ARGV[$#ARGV] eq &quot;386&quot;);
+
+$sse2=0;
+for (@ARGV) { $sse2=1 if (/-DOPENSSL_IA32_SSE2/); }
+
+&amp;external_label(&quot;OPENSSL_ia32cap_P&quot;) if ($sse2);
+
+
+########################################################################
+# Convert ecp_nistz256_table.c to layout expected by ecp_nistz_gather_w7
+#
+open TABLE,&quot;&lt;ecp_nistz256_table.c&quot;		or
+open TABLE,&quot;&lt;${dir}../ecp_nistz256_table.c&quot;	or
+die &quot;failed to open ecp_nistz256_table.c:&quot;,$!;
+
+use integer;
+
+foreach(&lt;TABLE&gt;) {
+	s/TOBN\(\s*(0x[0-9a-f]+),\s*(0x[0-9a-f]+)\s*\)/push @arr,hex($2),hex($1)/geo;
+}
+close TABLE;
+
+# See ecp_nistz256_table.c for explanation for why it's 64*16*37.
+# 64*16*37-1 is because $#arr returns last valid index or @arr, not
+# amount of elements.
+die &quot;insane number of elements&quot; if ($#arr != 64*16*37-1);
+
+&amp;public_label(&quot;ecp_nistz256_precomputed&quot;);
+&amp;align(4096);
+&amp;set_label(&quot;ecp_nistz256_precomputed&quot;);
+
+########################################################################
+# this conversion smashes P256_POINT_AFFINE by individual bytes with
+# 64 byte interval, similar to
+#	1111222233334444
+#	1234123412341234
+for(1..37) {
+	@tbl = splice(@arr,0,64*16);
+	for($i=0;$i&lt;64;$i++) {
+		undef @line;
+		for($j=0;$j&lt;64;$j++) {
+			push @line,(@tbl[$j*16+$i/4]&gt;&gt;(($i%4)*8))&amp;0xff;
+		}
+		&amp;data_byte(join(',',map { sprintf &quot;0x%02x&quot;,$_} @line));
+	}
+}
+
+########################################################################
+# Keep in mind that constants are stored least to most significant word
+&amp;static_label(&quot;RR&quot;);
+&amp;set_label(&quot;RR&quot;,64);
+&amp;data_word(3,0,-1,-5,-2,-1,-3,4);	# 2^512 mod P-256
+
+&amp;static_label(&quot;ONE_mont&quot;);
+&amp;set_label(&quot;ONE_mont&quot;);
+&amp;data_word(1,0,0,-1,-1,-1,-2,0);
+
+&amp;static_label(&quot;ONE&quot;);
+&amp;set_label(&quot;ONE&quot;);
+&amp;data_word(1,0,0,0,0,0,0,0);
+&amp;asciz(&quot;ECP_NISZ256 for x86/SSE2, CRYPTOGAMS by &lt;appro\@openssl.org&gt;&quot;);
+&amp;align(64);
+
+########################################################################
+# void ecp_nistz256_mul_by_2(BN_ULONG edi[8],const BN_ULONG esi[8]);
+&amp;function_begin(&quot;ecp_nistz256_mul_by_2&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;mov	(&quot;ebp&quot;,&quot;esi&quot;);
+########################################################################
+# common pattern for internal functions is that %edi is result pointer,
+# %esi and %ebp are input ones, %ebp being optional. %edi is preserved.
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);
+&amp;function_end(&quot;ecp_nistz256_mul_by_2&quot;);
+
+########################################################################
+# void ecp_nistz256_mul_by_3(BN_ULONG edi[8],const BN_ULONG esi[8]);
+&amp;function_begin(&quot;ecp_nistz256_mul_by_3&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+					# multiplication by 3 is performed
+					# as 2*n+n, but we can't use output
+					# to store 2*n, because if output
+					# pointer equals to input, then
+					# we'll get 2*n+2*n.
+	&amp;stack_push(8);			# therefore we need to allocate
+					# 256-bit intermediate buffer.
+	&amp;mov	(&quot;edi&quot;,&quot;esp&quot;);
+	&amp;mov	(&quot;ebp&quot;,&quot;esi&quot;);
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);
+	&amp;lea	(&quot;esi&quot;,&amp;DWP(0,&quot;edi&quot;));
+	&amp;mov	(&quot;ebp&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);
+	&amp;stack_pop(8);
+&amp;function_end(&quot;ecp_nistz256_mul_by_3&quot;);
+
+########################################################################
+# void ecp_nistz256_div_by_2(BN_ULONG edi[8],const BN_ULONG esi[8]);
+&amp;function_begin(&quot;ecp_nistz256_div_by_2&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;call	(&quot;_ecp_nistz256_div_by_2&quot;);
+&amp;function_end(&quot;ecp_nistz256_div_by_2&quot;);
+
+&amp;function_begin_B(&quot;_ecp_nistz256_div_by_2&quot;);
+	# tmp = a is odd ? a+mod : a
+	#
+	# note that because mod has special form, i.e. consists of
+	# 0xffffffff, 1 and 0s, we can conditionally synthesize it by
+	# assigning least significant bit of input to one register,
+	# %ebp, and its negative to another, %edx.
+
+	&amp;mov	(&quot;ebp&quot;,&amp;DWP(0,&quot;esi&quot;));
+	&amp;xor	(&quot;edx&quot;,&quot;edx&quot;);
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;esi&quot;));
+	&amp;mov	(&quot;eax&quot;,&quot;ebp&quot;);
+	&amp;and	(&quot;ebp&quot;,1);
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;esi&quot;));
+	&amp;sub	(&quot;edx&quot;,&quot;ebp&quot;);
+
+	&amp;add	(&quot;eax&quot;,&quot;edx&quot;);
+	&amp;adc	(&quot;ebx&quot;,&quot;edx&quot;);
+	&amp;mov	(&amp;DWP(0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;adc	(&quot;ecx&quot;,&quot;edx&quot;);
+	&amp;mov	(&amp;DWP(4,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;mov	(&amp;DWP(8,&quot;edi&quot;),&quot;ecx&quot;);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(12,&quot;esi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(16,&quot;esi&quot;));
+	&amp;adc	(&quot;eax&quot;,0);
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(20,&quot;esi&quot;));
+	&amp;adc	(&quot;ebx&quot;,0);
+	&amp;mov	(&amp;DWP(12,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;adc	(&quot;ecx&quot;,0);
+	&amp;mov	(&amp;DWP(16,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;mov	(&amp;DWP(20,&quot;edi&quot;),&quot;ecx&quot;);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(24,&quot;esi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(28,&quot;esi&quot;));
+	&amp;adc	(&quot;eax&quot;,&quot;ebp&quot;);
+	&amp;adc	(&quot;ebx&quot;,&quot;edx&quot;);
+	&amp;mov	(&amp;DWP(24,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;sbb	(&quot;esi&quot;,&quot;esi&quot;);			# broadcast carry bit
+	&amp;mov	(&amp;DWP(28,&quot;edi&quot;),&quot;ebx&quot;);
+
+	# ret = tmp &gt;&gt; 1
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;edi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;edi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;edi&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;edi&quot;));
+
+	&amp;shr	(&quot;eax&quot;,1);
+	&amp;mov	(&quot;ebp&quot;,&quot;ebx&quot;);
+	&amp;shl	(&quot;ebx&quot;,31);
+	&amp;or	(&quot;eax&quot;,&quot;ebx&quot;);
+
+	&amp;shr	(&quot;ebp&quot;,1);
+	&amp;mov	(&quot;ebx&quot;,&quot;ecx&quot;);
+	&amp;shl	(&quot;ecx&quot;,31);
+	&amp;mov	(&amp;DWP(0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;ecx&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(16,&quot;edi&quot;));
+
+	&amp;shr	(&quot;ebx&quot;,1);
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+	&amp;shl	(&quot;edx&quot;,31);
+	&amp;mov	(&amp;DWP(4,&quot;edi&quot;),&quot;ebp&quot;);
+	&amp;or	(&quot;ebx&quot;,&quot;edx&quot;);
+	&amp;mov	(&quot;ebp&quot;,&amp;DWP(20,&quot;edi&quot;));
+
+	&amp;shr	(&quot;ecx&quot;,1);
+	&amp;mov	(&quot;edx&quot;,&quot;eax&quot;);
+	&amp;shl	(&quot;eax&quot;,31);
+	&amp;mov	(&amp;DWP(8,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;or	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(24,&quot;edi&quot;));
+
+	&amp;shr	(&quot;edx&quot;,1);
+	&amp;mov	(&quot;eax&quot;,&quot;ebp&quot;);
+	&amp;shl	(&quot;ebp&quot;,31);
+	&amp;mov	(&amp;DWP(12,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;or	(&quot;edx&quot;,&quot;ebp&quot;);
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(28,&quot;edi&quot;));
+
+	&amp;shr	(&quot;eax&quot;,1);
+	&amp;mov	(&quot;ebp&quot;,&quot;ebx&quot;);
+	&amp;shl	(&quot;ebx&quot;,31);
+	&amp;mov	(&amp;DWP(16,&quot;edi&quot;),&quot;edx&quot;);
+	&amp;or	(&quot;eax&quot;,&quot;ebx&quot;);
+
+	&amp;shr	(&quot;ebp&quot;,1);
+	&amp;mov	(&quot;ebx&quot;,&quot;ecx&quot;);
+	&amp;shl	(&quot;ecx&quot;,31);
+	&amp;mov	(&amp;DWP(20,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;ecx&quot;);
+
+	&amp;shr	(&quot;ebx&quot;,1);
+	&amp;shl	(&quot;esi&quot;,31);
+	&amp;mov	(&amp;DWP(24,&quot;edi&quot;),&quot;ebp&quot;);
+	&amp;or	(&quot;ebx&quot;,&quot;esi&quot;);			# handle top-most carry bit
+	&amp;mov	(&amp;DWP(28,&quot;edi&quot;),&quot;ebx&quot;);
+
+	&amp;ret	();
+&amp;function_end_B(&quot;_ecp_nistz256_div_by_2&quot;);
+
+########################################################################
+# void ecp_nistz256_add(BN_ULONG edi[8],const BN_ULONG esi[8],
+#					const BN_ULONG ebp[8]);
+&amp;function_begin(&quot;ecp_nistz256_add&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;ebp&quot;,&amp;wparam(2));
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);
+&amp;function_end(&quot;ecp_nistz256_add&quot;);
+
+&amp;function_begin_B(&quot;_ecp_nistz256_add&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;esi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;esi&quot;));
+	&amp;add	(&quot;eax&quot;,&amp;DWP(0,&quot;ebp&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;esi&quot;));
+	&amp;adc	(&quot;ebx&quot;,&amp;DWP(4,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;adc	(&quot;ecx&quot;,&amp;DWP(8,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(4,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;adc	(&quot;edx&quot;,&amp;DWP(12,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(8,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(12,&quot;edi&quot;),&quot;edx&quot;);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(16,&quot;esi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(20,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(24,&quot;esi&quot;));
+	&amp;adc	(&quot;eax&quot;,&amp;DWP(16,&quot;ebp&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(28,&quot;esi&quot;));
+	&amp;adc	(&quot;ebx&quot;,&amp;DWP(20,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(16,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;adc	(&quot;ecx&quot;,&amp;DWP(24,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(20,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;adc	(&quot;edx&quot;,&amp;DWP(28,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(24,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;sbb	(&quot;esi&quot;,&quot;esi&quot;);			# broadcast carry bit
+	&amp;mov	(&amp;DWP(28,&quot;edi&quot;),&quot;edx&quot;);
+
+	# if a+b carries, subtract modulus.
+	#
+	# Note that because mod has special form, i.e. consists of
+	# 0xffffffff, 1 and 0s, we can conditionally synthesize it by
+	# assigning carry bit to one register, %ebp, and its negative
+	# to another, %esi. But we started by calculating %esi...
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;edi&quot;));
+	&amp;mov	(&quot;ebp&quot;,&quot;esi&quot;);
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;edi&quot;));
+	&amp;shr	(&quot;ebp&quot;,31);
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;edi&quot;));
+	&amp;sub	(&quot;eax&quot;,&quot;esi&quot;);
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;edi&quot;));
+	&amp;sbb	(&quot;ebx&quot;,&quot;esi&quot;);
+	&amp;mov	(&amp;DWP(0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;sbb	(&quot;ecx&quot;,&quot;esi&quot;);
+	&amp;mov	(&amp;DWP(4,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;sbb	(&quot;edx&quot;,0);
+	&amp;mov	(&amp;DWP(8,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(12,&quot;edi&quot;),&quot;edx&quot;);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(16,&quot;edi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(20,&quot;edi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(24,&quot;edi&quot;));
+	&amp;sbb	(&quot;eax&quot;,0);
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(28,&quot;edi&quot;));
+	&amp;sbb	(&quot;ebx&quot;,0);
+	&amp;mov	(&amp;DWP(16,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;sbb	(&quot;ecx&quot;,&quot;ebp&quot;);
+	&amp;mov	(&amp;DWP(20,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;sbb	(&quot;edx&quot;,&quot;esi&quot;);
+	&amp;mov	(&amp;DWP(24,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(28,&quot;edi&quot;),&quot;edx&quot;);
+
+	&amp;ret	();
+&amp;function_end_B(&quot;_ecp_nistz256_add&quot;);
+
+########################################################################
+# void ecp_nistz256_sub(BN_ULONG edi[8],const BN_ULONG esi[8],
+#					const BN_ULONG ebp[8]);
+&amp;function_begin(&quot;ecp_nistz256_sub&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;ebp&quot;,&amp;wparam(2));
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);
+&amp;function_end(&quot;ecp_nistz256_sub&quot;);
+
+&amp;function_begin_B(&quot;_ecp_nistz256_sub&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;esi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;esi&quot;));
+	&amp;sub	(&quot;eax&quot;,&amp;DWP(0,&quot;ebp&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;esi&quot;));
+	&amp;sbb	(&quot;ebx&quot;,&amp;DWP(4,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;sbb	(&quot;ecx&quot;,&amp;DWP(8,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(4,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;sbb	(&quot;edx&quot;,&amp;DWP(12,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(8,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(12,&quot;edi&quot;),&quot;edx&quot;);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(16,&quot;esi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(20,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(24,&quot;esi&quot;));
+	&amp;sbb	(&quot;eax&quot;,&amp;DWP(16,&quot;ebp&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(28,&quot;esi&quot;));
+	&amp;sbb	(&quot;ebx&quot;,&amp;DWP(20,&quot;ebp&quot;));
+	&amp;sbb	(&quot;ecx&quot;,&amp;DWP(24,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(16,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;sbb	(&quot;edx&quot;,&amp;DWP(28,&quot;ebp&quot;));
+	&amp;mov	(&amp;DWP(20,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;sbb	(&quot;esi&quot;,&quot;esi&quot;);			# broadcast borrow bit
+	&amp;mov	(&amp;DWP(24,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(28,&quot;edi&quot;),&quot;edx&quot;);
+
+	# if a-b borrows, add modulus.
+	#
+	# Note that because mod has special form, i.e. consists of
+	# 0xffffffff, 1 and 0s, we can conditionally synthesize it by
+	# assigning borrow bit to one register, %ebp, and its negative
+	# to another, %esi. But we started by calculating %esi...
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;edi&quot;));
+	&amp;mov	(&quot;ebp&quot;,&quot;esi&quot;);
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;edi&quot;));
+	&amp;shr	(&quot;ebp&quot;,31);
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;edi&quot;));
+	&amp;add	(&quot;eax&quot;,&quot;esi&quot;);
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;edi&quot;));
+	&amp;adc	(&quot;ebx&quot;,&quot;esi&quot;);
+	&amp;mov	(&amp;DWP(0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;adc	(&quot;ecx&quot;,&quot;esi&quot;);
+	&amp;mov	(&amp;DWP(4,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&amp;DWP(8,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(12,&quot;edi&quot;),&quot;edx&quot;);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(16,&quot;edi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(20,&quot;edi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(24,&quot;edi&quot;));
+	&amp;adc	(&quot;eax&quot;,0);
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(28,&quot;edi&quot;));
+	&amp;adc	(&quot;ebx&quot;,0);
+	&amp;mov	(&amp;DWP(16,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;adc	(&quot;ecx&quot;,&quot;ebp&quot;);
+	&amp;mov	(&amp;DWP(20,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;adc	(&quot;edx&quot;,&quot;esi&quot;);
+	&amp;mov	(&amp;DWP(24,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(28,&quot;edi&quot;),&quot;edx&quot;);
+
+	&amp;ret	();
+&amp;function_end_B(&quot;_ecp_nistz256_sub&quot;);
+
+########################################################################
+# void ecp_nistz256_neg(BN_ULONG edi[8],const BN_ULONG esi[8]);
+&amp;function_begin(&quot;ecp_nistz256_neg&quot;);
+	&amp;mov	(&quot;ebp&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+
+	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);
+	&amp;stack_push(8);
+	&amp;mov	(&amp;DWP(0,&quot;esp&quot;),&quot;eax&quot;);
+	&amp;mov	(&quot;esi&quot;,&quot;esp&quot;);
+	&amp;mov	(&amp;DWP(4,&quot;esp&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP(8,&quot;esp&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP(12,&quot;esp&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP(16,&quot;esp&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP(20,&quot;esp&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP(24,&quot;esp&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP(28,&quot;esp&quot;),&quot;eax&quot;);
+	
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);
+
+	&amp;stack_pop(8);
+&amp;function_end(&quot;ecp_nistz256_neg&quot;);
+
+&amp;function_begin_B(&quot;_picup_eax&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;esp&quot;));
+	&amp;ret	();
+&amp;function_end_B(&quot;_picup_eax&quot;);
+
+########################################################################
+# void ecp_nistz256_to_mont(BN_ULONG edi[8],const BN_ULONG esi[8]);
+&amp;function_begin(&quot;ecp_nistz256_to_mont&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;call	(&quot;_picup_eax&quot;);
+    &amp;set_label(&quot;pic&quot;);
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP(&amp;label(&quot;RR&quot;).&quot;-&quot;.&amp;label(&quot;pic&quot;),&quot;eax&quot;));
+						if ($sse2) {
+	&amp;picmeup(&quot;eax&quot;,&quot;OPENSSL_ia32cap_P&quot;,&quot;eax&quot;,&amp;label(&quot;pic&quot;));
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;eax&quot;));		}
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);
+&amp;function_end(&quot;ecp_nistz256_to_mont&quot;);
+
+########################################################################
+# void ecp_nistz256_from_mont(BN_ULONG edi[8],const BN_ULONG esi[8]);
+&amp;function_begin(&quot;ecp_nistz256_from_mont&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;call	(&quot;_picup_eax&quot;);
+    &amp;set_label(&quot;pic&quot;);
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP(&amp;label(&quot;ONE&quot;).&quot;-&quot;.&amp;label(&quot;pic&quot;),&quot;eax&quot;));
+						if ($sse2) {
+	&amp;picmeup(&quot;eax&quot;,&quot;OPENSSL_ia32cap_P&quot;,&quot;eax&quot;,&amp;label(&quot;pic&quot;));
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;eax&quot;));		}
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);
+&amp;function_end(&quot;ecp_nistz256_from_mont&quot;);
+
+########################################################################
+# void ecp_nistz256_mul_mont(BN_ULONG edi[8],const BN_ULONG esi[8],
+#					     const BN_ULONG ebp[8]);
+&amp;function_begin(&quot;ecp_nistz256_mul_mont&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;ebp&quot;,&amp;wparam(2));
+						if ($sse2) {
+	&amp;call	(&quot;_picup_eax&quot;);
+    &amp;set_label(&quot;pic&quot;);
+	&amp;picmeup(&quot;eax&quot;,&quot;OPENSSL_ia32cap_P&quot;,&quot;eax&quot;,&amp;label(&quot;pic&quot;));
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;eax&quot;));		}
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);
+&amp;function_end(&quot;ecp_nistz256_mul_mont&quot;);
+
+########################################################################
+# void ecp_nistz256_sqr_mont(BN_ULONG edi[8],const BN_ULONG esi[8]);
+&amp;function_begin(&quot;ecp_nistz256_sqr_mont&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+						if ($sse2) {
+	&amp;call	(&quot;_picup_eax&quot;);
+    &amp;set_label(&quot;pic&quot;);
+	&amp;picmeup(&quot;eax&quot;,&quot;OPENSSL_ia32cap_P&quot;,&quot;eax&quot;,&amp;label(&quot;pic&quot;));
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;eax&quot;));		}
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;mov	(&quot;ebp&quot;,&quot;esi&quot;);
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);
+&amp;function_end(&quot;ecp_nistz256_sqr_mont&quot;);
+
+&amp;function_begin_B(&quot;_ecp_nistz256_mul_mont&quot;);
+						if ($sse2) {
+	&amp;and	(&quot;eax&quot;,1&lt;&lt;24|1&lt;&lt;26);
+	&amp;cmp	(&quot;eax&quot;,1&lt;&lt;24|1&lt;&lt;26);		# see if XMM+SSE2 is on
+	&amp;jne	(&amp;label(&quot;mul_mont_ialu&quot;));
+
+	########################################
+	# SSE2 code path featuring 32x16-bit
+	# multiplications is ~2x faster than
+	# IALU counterpart (except on Atom)...
+	########################################
+	# stack layout:
+	# +------------------------------------+&lt; %esp
+	# | 7 16-byte temporary XMM words,     |
+	# | &quot;sliding&quot; toward lower address     |
+	# .                                    .
+	# +------------------------------------+
+	# | unused XMM word                    |
+	# +------------------------------------+&lt; +128,%ebx
+	# | 8 16-byte XMM words holding copies |
+	# | of a[i]&lt;&lt;64|a[i]                   |
+	# .                                    .
+	# .                                    .
+	# +------------------------------------+&lt; +256
+	&amp;mov	(&quot;edx&quot;,&quot;esp&quot;);
+	&amp;sub	(&quot;esp&quot;,0x100);
+
+	&amp;movd	(&quot;xmm7&quot;,&amp;DWP(0,&quot;ebp&quot;));		# b[0] -&gt; 0000.00xy
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP(4,&quot;ebp&quot;));
+	&amp;pcmpeqd(&quot;xmm6&quot;,&quot;xmm6&quot;);
+	&amp;psrlq	(&quot;xmm6&quot;,48);			# compose 0xffff&lt;&lt;64|0xffff
+
+	&amp;pshuflw(&quot;xmm7&quot;,&quot;xmm7&quot;,0b11011100);	# 0000.00xy -&gt; 0000.0x0y
+	&amp;and	(&quot;esp&quot;,-64);
+	&amp;pshufd	(&quot;xmm7&quot;,&quot;xmm7&quot;,0b11011100);	# 0000.0x0y -&gt; 000x.000y
+	&amp;lea	(&quot;ebx&quot;,&amp;DWP(0x80,&quot;esp&quot;));
+
+	&amp;movd	(&quot;xmm0&quot;,&amp;DWP(4*0,&quot;esi&quot;));	# a[0] -&gt; 0000.00xy
+	&amp;pshufd	(&quot;xmm0&quot;,&quot;xmm0&quot;,0b11001100);	# 0000.00xy -&gt; 00xy.00xy
+	&amp;movd	(&quot;xmm1&quot;,&amp;DWP(4*1,&quot;esi&quot;));	# a[1] -&gt; ...
+	&amp;movdqa	(&amp;QWP(0x00,&quot;ebx&quot;),&quot;xmm0&quot;);	# offload converted a[0]
+	&amp;pmuludq(&quot;xmm0&quot;,&quot;xmm7&quot;);		# a[0]*b[0]
+
+	&amp;movd	(&quot;xmm2&quot;,&amp;DWP(4*2,&quot;esi&quot;));
+	&amp;pshufd	(&quot;xmm1&quot;,&quot;xmm1&quot;,0b11001100);
+	&amp;movdqa	(&amp;QWP(0x10,&quot;ebx&quot;),&quot;xmm1&quot;);
+	&amp;pmuludq(&quot;xmm1&quot;,&quot;xmm7&quot;);		# a[1]*b[0]
+
+	 &amp;movq	(&quot;xmm4&quot;,&quot;xmm0&quot;);		# clear upper 64 bits
+	 &amp;pslldq(&quot;xmm4&quot;,6);
+	 &amp;paddq	(&quot;xmm4&quot;,&quot;xmm0&quot;);
+	 &amp;movdqa(&quot;xmm5&quot;,&quot;xmm4&quot;);
+	 &amp;psrldq(&quot;xmm4&quot;,10);			# upper 32 bits of a[0]*b[0]
+	 &amp;pand	(&quot;xmm5&quot;,&quot;xmm6&quot;);		# lower 32 bits of a[0]*b[0]
+
+	# Upper half of a[0]*b[i] is carried into next multiplication
+	# iteration, while lower one &quot;participates&quot; in actual reduction.
+	# Normally latter is done by accumulating result of multiplication
+	# of modulus by &quot;magic&quot; digit, but thanks to special form of modulus
+	# and &quot;magic&quot; digit it can be performed only with additions and
+	# subtractions (see note in IALU section below). Note that we are
+	# not bothered with carry bits, they are accumulated in &quot;flatten&quot;
+	# phase after all multiplications and reductions.
+
+	&amp;movd	(&quot;xmm3&quot;,&amp;DWP(4*3,&quot;esi&quot;));
+	&amp;pshufd	(&quot;xmm2&quot;,&quot;xmm2&quot;,0b11001100);
+	&amp;movdqa	(&amp;QWP(0x20,&quot;ebx&quot;),&quot;xmm2&quot;);
+	&amp;pmuludq(&quot;xmm2&quot;,&quot;xmm7&quot;);		# a[2]*b[0]
+	 &amp;paddq	(&quot;xmm1&quot;,&quot;xmm4&quot;);		# a[1]*b[0]+hw(a[0]*b[0]), carry
+	&amp;movdqa	(&amp;QWP(0x00,&quot;esp&quot;),&quot;xmm1&quot;);	# t[0]
+
+	&amp;movd	(&quot;xmm0&quot;,&amp;DWP(4*4,&quot;esi&quot;));
+	&amp;pshufd	(&quot;xmm3&quot;,&quot;xmm3&quot;,0b11001100);
+	&amp;movdqa	(&amp;QWP(0x30,&quot;ebx&quot;),&quot;xmm3&quot;);
+	&amp;pmuludq(&quot;xmm3&quot;,&quot;xmm7&quot;);		# a[3]*b[0]
+	&amp;movdqa	(&amp;QWP(0x10,&quot;esp&quot;),&quot;xmm2&quot;);
+
+	&amp;movd	(&quot;xmm1&quot;,&amp;DWP(4*5,&quot;esi&quot;));
+	&amp;pshufd	(&quot;xmm0&quot;,&quot;xmm0&quot;,0b11001100);
+	&amp;movdqa	(&amp;QWP(0x40,&quot;ebx&quot;),&quot;xmm0&quot;);
+	&amp;pmuludq(&quot;xmm0&quot;,&quot;xmm7&quot;);		# a[4]*b[0]
+	 &amp;paddq	(&quot;xmm3&quot;,&quot;xmm5&quot;);		# a[3]*b[0]+lw(a[0]*b[0]), reduction step
+	&amp;movdqa	(&amp;QWP(0x20,&quot;esp&quot;),&quot;xmm3&quot;);
+
+	&amp;movd	(&quot;xmm2&quot;,&amp;DWP(4*6,&quot;esi&quot;));
+	&amp;pshufd	(&quot;xmm1&quot;,&quot;xmm1&quot;,0b11001100);
+	&amp;movdqa	(&amp;QWP(0x50,&quot;ebx&quot;),&quot;xmm1&quot;);
+	&amp;pmuludq(&quot;xmm1&quot;,&quot;xmm7&quot;);		# a[5]*b[0]
+	&amp;movdqa	(&amp;QWP(0x30,&quot;esp&quot;),&quot;xmm0&quot;);
+	 &amp;pshufd(&quot;xmm4&quot;,&quot;xmm5&quot;,0b10110001);	# xmm4 = xmm5&lt;&lt;32, reduction step
+
+	&amp;movd	(&quot;xmm3&quot;,&amp;DWP(4*7,&quot;esi&quot;));
+	&amp;pshufd	(&quot;xmm2&quot;,&quot;xmm2&quot;,0b11001100);
+	&amp;movdqa	(&amp;QWP(0x60,&quot;ebx&quot;),&quot;xmm2&quot;);
+	&amp;pmuludq(&quot;xmm2&quot;,&quot;xmm7&quot;);		# a[6]*b[0]
+	&amp;movdqa	(&amp;QWP(0x40,&quot;esp&quot;),&quot;xmm1&quot;);
+	 &amp;psubq	(&quot;xmm4&quot;,&quot;xmm5&quot;);		# xmm4 = xmm5*0xffffffff, reduction step
+
+	&amp;movd	(&quot;xmm0&quot;,&amp;DWP(0,&quot;ebp&quot;));		# b[1] -&gt; 0000.00xy
+	&amp;pshufd	(&quot;xmm3&quot;,&quot;xmm3&quot;,0b11001100);
+	&amp;movdqa	(&amp;QWP(0x70,&quot;ebx&quot;),&quot;xmm3&quot;);
+	&amp;pmuludq(&quot;xmm3&quot;,&quot;xmm7&quot;);		# a[7]*b[0]
+
+	&amp;pshuflw(&quot;xmm7&quot;,&quot;xmm0&quot;,0b11011100);	# 0000.00xy -&gt; 0000.0x0y
+	&amp;movdqa	(&quot;xmm0&quot;,&amp;QWP(0x00,&quot;ebx&quot;));	# pre-load converted a[0]
+	&amp;pshufd	(&quot;xmm7&quot;,&quot;xmm7&quot;,0b11011100);	# 0000.0x0y -&gt; 000x.000y
+
+	&amp;mov	(&quot;ecx&quot;,6);
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP(4,&quot;ebp&quot;));
+	&amp;jmp	(&amp;label(&quot;madd_sse2&quot;));
+
+&amp;set_label(&quot;madd_sse2&quot;,16);
+	 &amp;paddq	(&quot;xmm2&quot;,&quot;xmm5&quot;);		# a[6]*b[i-1]+lw(a[0]*b[i-1]), reduction step [modulo-scheduled]
+	 &amp;paddq	(&quot;xmm3&quot;,&quot;xmm4&quot;);		# a[7]*b[i-1]+lw(a[0]*b[i-1])*0xffffffff, reduction step [modulo-scheduled]
+	&amp;movdqa	(&quot;xmm1&quot;,&amp;QWP(0x10,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm0&quot;,&quot;xmm7&quot;);		# a[0]*b[i]
+	 &amp;movdqa(&amp;QWP(0x50,&quot;esp&quot;),&quot;xmm2&quot;);
+
+	&amp;movdqa	(&quot;xmm2&quot;,&amp;QWP(0x20,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm1&quot;,&quot;xmm7&quot;);		# a[1]*b[i]
+	 &amp;movdqa(&amp;QWP(0x60,&quot;esp&quot;),&quot;xmm3&quot;);
+	&amp;paddq	(&quot;xmm0&quot;,&amp;QWP(0x00,&quot;esp&quot;));
+
+	&amp;movdqa	(&quot;xmm3&quot;,&amp;QWP(0x30,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm2&quot;,&quot;xmm7&quot;);		# a[2]*b[i]
+	 &amp;movq	(&quot;xmm4&quot;,&quot;xmm0&quot;);		# clear upper 64 bits
+	 &amp;pslldq(&quot;xmm4&quot;,6);
+	&amp;paddq	(&quot;xmm1&quot;,&amp;QWP(0x10,&quot;esp&quot;));
+	 &amp;paddq	(&quot;xmm4&quot;,&quot;xmm0&quot;);
+	 &amp;movdqa(&quot;xmm5&quot;,&quot;xmm4&quot;);
+	 &amp;psrldq(&quot;xmm4&quot;,10);			# upper 33 bits of a[0]*b[i]+t[0]
+
+	&amp;movdqa	(&quot;xmm0&quot;,&amp;QWP(0x40,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm3&quot;,&quot;xmm7&quot;);		# a[3]*b[i]
+	 &amp;paddq	(&quot;xmm1&quot;,&quot;xmm4&quot;);		# a[1]*b[i]+hw(a[0]*b[i]), carry
+	&amp;paddq	(&quot;xmm2&quot;,&amp;QWP(0x20,&quot;esp&quot;));
+	&amp;movdqa	(&amp;QWP(0x00,&quot;esp&quot;),&quot;xmm1&quot;);
+
+	&amp;movdqa	(&quot;xmm1&quot;,&amp;QWP(0x50,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm0&quot;,&quot;xmm7&quot;);		# a[4]*b[i]
+	&amp;paddq	(&quot;xmm3&quot;,&amp;QWP(0x30,&quot;esp&quot;));
+	&amp;movdqa	(&amp;QWP(0x10,&quot;esp&quot;),&quot;xmm2&quot;);
+	 &amp;pand	(&quot;xmm5&quot;,&quot;xmm6&quot;);		# lower 32 bits of a[0]*b[i]
+
+	&amp;movdqa	(&quot;xmm2&quot;,&amp;DWP(0x60,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm1&quot;,&quot;xmm7&quot;);		# a[5]*b[i]
+	 &amp;paddq	(&quot;xmm3&quot;,&quot;xmm5&quot;);		# a[3]*b[i]+lw(a[0]*b[i]), reduction step
+	&amp;paddq	(&quot;xmm0&quot;,&amp;QWP(0x40,&quot;esp&quot;));
+	&amp;movdqa	(&amp;QWP(0x20,&quot;esp&quot;),&quot;xmm3&quot;);
+	 &amp;pshufd(&quot;xmm4&quot;,&quot;xmm5&quot;,0b10110001);	# xmm4 = xmm5&lt;&lt;32, reduction step
+
+	&amp;movdqa	(&quot;xmm3&quot;,&quot;xmm7&quot;);
+	&amp;pmuludq(&quot;xmm2&quot;,&quot;xmm7&quot;);		# a[6]*b[i]
+	 &amp;movd	(&quot;xmm7&quot;,&amp;DWP(0,&quot;ebp&quot;));		# b[i++] -&gt; 0000.00xy
+	 &amp;lea	(&quot;ebp&quot;,&amp;DWP(4,&quot;ebp&quot;));
+	&amp;paddq	(&quot;xmm1&quot;,&amp;QWP(0x50,&quot;esp&quot;));
+	 &amp;psubq	(&quot;xmm4&quot;,&quot;xmm5&quot;);		# xmm4 = xmm5*0xffffffff, reduction step
+	&amp;movdqa	(&amp;QWP(0x30,&quot;esp&quot;),&quot;xmm0&quot;);
+	 &amp;pshuflw(&quot;xmm7&quot;,&quot;xmm7&quot;,0b11011100);	# 0000.00xy -&gt; 0000.0x0y
+
+	&amp;pmuludq(&quot;xmm3&quot;,&amp;QWP(0x70,&quot;ebx&quot;));	# a[7]*b[i]
+	 &amp;pshufd(&quot;xmm7&quot;,&quot;xmm7&quot;,0b11011100);	# 0000.0x0y -&gt; 000x.000y
+	 &amp;movdqa(&quot;xmm0&quot;,&amp;QWP(0x00,&quot;ebx&quot;));	# pre-load converted a[0]
+	&amp;movdqa	(&amp;QWP(0x40,&quot;esp&quot;),&quot;xmm1&quot;);
+	&amp;paddq	(&quot;xmm2&quot;,&amp;QWP(0x60,&quot;esp&quot;));
+
+	&amp;dec	(&quot;ecx&quot;);
+	&amp;jnz	(&amp;label(&quot;madd_sse2&quot;));
+
+	 &amp;paddq	(&quot;xmm2&quot;,&quot;xmm5&quot;);		# a[6]*b[6]+lw(a[0]*b[6]), reduction step [modulo-scheduled]
+	 &amp;paddq	(&quot;xmm3&quot;,&quot;xmm4&quot;);		# a[7]*b[6]+lw(a[0]*b[6])*0xffffffff, reduction step [modulo-scheduled]
+	&amp;movdqa	(&quot;xmm1&quot;,&amp;QWP(0x10,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm0&quot;,&quot;xmm7&quot;);		# a[0]*b[7]
+	 &amp;movdqa(&amp;QWP(0x50,&quot;esp&quot;),&quot;xmm2&quot;);
+
+	&amp;movdqa	(&quot;xmm2&quot;,&amp;QWP(0x20,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm1&quot;,&quot;xmm7&quot;);		# a[1]*b[7]
+	 &amp;movdqa(&amp;QWP(0x60,&quot;esp&quot;),&quot;xmm3&quot;);
+	&amp;paddq	(&quot;xmm0&quot;,&amp;QWP(0x00,&quot;esp&quot;));
+
+	&amp;movdqa	(&quot;xmm3&quot;,&amp;QWP(0x30,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm2&quot;,&quot;xmm7&quot;);		# a[2]*b[7]
+	 &amp;movq	(&quot;xmm4&quot;,&quot;xmm0&quot;);		# clear upper 64 bits
+	 &amp;pslldq(&quot;xmm4&quot;,6);
+	&amp;paddq	(&quot;xmm1&quot;,&amp;QWP(0x10,&quot;esp&quot;));
+	 &amp;paddq	(&quot;xmm4&quot;,&quot;xmm0&quot;);
+	 &amp;movdqa(&quot;xmm5&quot;,&quot;xmm4&quot;);
+	 &amp;psrldq(&quot;xmm4&quot;,10);			# upper 33 bits of a[0]*b[i]+t[0]
+
+	&amp;movdqa	(&quot;xmm0&quot;,&amp;QWP(0x40,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm3&quot;,&quot;xmm7&quot;);		# a[3]*b[7]
+	 &amp;paddq	(&quot;xmm1&quot;,&quot;xmm4&quot;);		# a[1]*b[7]+hw(a[0]*b[7]), carry
+	&amp;paddq	(&quot;xmm2&quot;,&amp;QWP(0x20,&quot;esp&quot;));
+	&amp;movdqa	(&amp;QWP(0x00,&quot;esp&quot;),&quot;xmm1&quot;);
+
+	&amp;movdqa	(&quot;xmm1&quot;,&amp;QWP(0x50,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm0&quot;,&quot;xmm7&quot;);		# a[4]*b[7]
+	&amp;paddq	(&quot;xmm3&quot;,&amp;QWP(0x30,&quot;esp&quot;));
+	&amp;movdqa	(&amp;QWP(0x10,&quot;esp&quot;),&quot;xmm2&quot;);
+	 &amp;pand	(&quot;xmm5&quot;,&quot;xmm6&quot;);		# lower 32 bits of a[0]*b[i]
+
+	&amp;movdqa	(&quot;xmm2&quot;,&amp;DWP(0x60,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm1&quot;,&quot;xmm7&quot;);		# a[5]*b[7]
+	 &amp;paddq	(&quot;xmm3&quot;,&quot;xmm5&quot;);		# reduction step
+	&amp;paddq	(&quot;xmm0&quot;,&amp;QWP(0x40,&quot;esp&quot;));
+	&amp;movdqa	(&amp;QWP(0x20,&quot;esp&quot;),&quot;xmm3&quot;);
+	 &amp;pshufd(&quot;xmm4&quot;,&quot;xmm5&quot;,0b10110001);	# xmm4 = xmm5&lt;&lt;32, reduction step
+
+	&amp;movdqa	(&quot;xmm3&quot;,&amp;QWP(0x70,&quot;ebx&quot;));
+	&amp;pmuludq(&quot;xmm2&quot;,&quot;xmm7&quot;);		# a[6]*b[7]
+	&amp;paddq	(&quot;xmm1&quot;,&amp;QWP(0x50,&quot;esp&quot;));
+	 &amp;psubq	(&quot;xmm4&quot;,&quot;xmm5&quot;);		# xmm4 = xmm5*0xffffffff, reduction step
+	&amp;movdqa	(&amp;QWP(0x30,&quot;esp&quot;),&quot;xmm0&quot;);
+
+	&amp;pmuludq(&quot;xmm3&quot;,&quot;xmm7&quot;);		# a[7]*b[7]
+	&amp;pcmpeqd(&quot;xmm7&quot;,&quot;xmm7&quot;);
+	&amp;movdqa	(&quot;xmm0&quot;,&amp;QWP(0x00,&quot;esp&quot;));
+	&amp;pslldq	(&quot;xmm7&quot;,8);
+	&amp;movdqa	(&amp;QWP(0x40,&quot;esp&quot;),&quot;xmm1&quot;);
+	&amp;paddq	(&quot;xmm2&quot;,&amp;QWP(0x60,&quot;esp&quot;));
+
+	 &amp;paddq	(&quot;xmm2&quot;,&quot;xmm5&quot;);		# a[6]*b[7]+lw(a[0]*b[7]), reduction step
+	 &amp;paddq	(&quot;xmm3&quot;,&quot;xmm4&quot;);		# a[6]*b[7]+lw(a[0]*b[7])*0xffffffff, reduction step
+	 &amp;movdqa(&amp;QWP(0x50,&quot;esp&quot;),&quot;xmm2&quot;);
+	 &amp;movdqa(&amp;QWP(0x60,&quot;esp&quot;),&quot;xmm3&quot;);
+
+	&amp;movdqa	(&quot;xmm1&quot;,&amp;QWP(0x10,&quot;esp&quot;));
+	&amp;movdqa	(&quot;xmm2&quot;,&amp;QWP(0x20,&quot;esp&quot;));
+	&amp;movdqa	(&quot;xmm3&quot;,&amp;QWP(0x30,&quot;esp&quot;));
+
+	&amp;movq	(&quot;xmm4&quot;,&quot;xmm0&quot;);		# &quot;flatten&quot;
+	&amp;pand	(&quot;xmm0&quot;,&quot;xmm7&quot;);
+	&amp;xor	(&quot;ebp&quot;,&quot;ebp&quot;);
+	&amp;pslldq	(&quot;xmm4&quot;,6);
+	 &amp;movq	(&quot;xmm5&quot;,&quot;xmm1&quot;);
+	&amp;paddq	(&quot;xmm0&quot;,&quot;xmm4&quot;);
+	 &amp;pand	(&quot;xmm1&quot;,&quot;xmm7&quot;);
+	&amp;psrldq	(&quot;xmm0&quot;,6);
+	&amp;movd	(&quot;eax&quot;,&quot;xmm0&quot;);
+	&amp;psrldq	(&quot;xmm0&quot;,4);
+
+	&amp;paddq	(&quot;xmm5&quot;,&quot;xmm0&quot;);
+	&amp;movdqa	(&quot;xmm0&quot;,&amp;QWP(0x40,&quot;esp&quot;));
+	&amp;sub	(&quot;eax&quot;,-1);			# start subtracting modulus,
+						# this is used to determine
+						# if result is larger/smaller
+						# than modulus (see below)
+	&amp;pslldq	(&quot;xmm5&quot;,6);
+	 &amp;movq	(&quot;xmm4&quot;,&quot;xmm2&quot;);
+	&amp;paddq	(&quot;xmm1&quot;,&quot;xmm5&quot;);
+	 &amp;pand	(&quot;xmm2&quot;,&quot;xmm7&quot;);
+	&amp;psrldq	(&quot;xmm1&quot;,6);
+	&amp;mov	(&amp;DWP(4*0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;movd	(&quot;eax&quot;,&quot;xmm1&quot;);
+	&amp;psrldq	(&quot;xmm1&quot;,4);
+
+	&amp;paddq	(&quot;xmm4&quot;,&quot;xmm1&quot;);
+	&amp;movdqa	(&quot;xmm1&quot;,&amp;QWP(0x50,&quot;esp&quot;));
+	&amp;sbb	(&quot;eax&quot;,-1);
+	&amp;pslldq	(&quot;xmm4&quot;,6);
+	 &amp;movq	(&quot;xmm5&quot;,&quot;xmm3&quot;);
+	&amp;paddq	(&quot;xmm2&quot;,&quot;xmm4&quot;);
+	 &amp;pand	(&quot;xmm3&quot;,&quot;xmm7&quot;);
+	&amp;psrldq	(&quot;xmm2&quot;,6);
+	&amp;mov	(&amp;DWP(4*1,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;movd	(&quot;eax&quot;,&quot;xmm2&quot;);
+	&amp;psrldq	(&quot;xmm2&quot;,4);
+
+	&amp;paddq	(&quot;xmm5&quot;,&quot;xmm2&quot;);
+	&amp;movdqa	(&quot;xmm2&quot;,&amp;QWP(0x60,&quot;esp&quot;));
+	&amp;sbb	(&quot;eax&quot;,-1);
+	&amp;pslldq	(&quot;xmm5&quot;,6);
+	 &amp;movq	(&quot;xmm4&quot;,&quot;xmm0&quot;);
+	&amp;paddq	(&quot;xmm3&quot;,&quot;xmm5&quot;);
+	 &amp;pand	(&quot;xmm0&quot;,&quot;xmm7&quot;);
+	&amp;psrldq	(&quot;xmm3&quot;,6);
+	&amp;mov	(&amp;DWP(4*2,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;movd	(&quot;eax&quot;,&quot;xmm3&quot;);
+	&amp;psrldq	(&quot;xmm3&quot;,4);
+
+	&amp;paddq	(&quot;xmm4&quot;,&quot;xmm3&quot;);
+	&amp;sbb	(&quot;eax&quot;,0);
+	&amp;pslldq	(&quot;xmm4&quot;,6);
+	 &amp;movq	(&quot;xmm5&quot;,&quot;xmm1&quot;);
+	&amp;paddq	(&quot;xmm0&quot;,&quot;xmm4&quot;);
+	 &amp;pand	(&quot;xmm1&quot;,&quot;xmm7&quot;);
+	&amp;psrldq	(&quot;xmm0&quot;,6);
+	&amp;mov	(&amp;DWP(4*3,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;movd	(&quot;eax&quot;,&quot;xmm0&quot;);
+	&amp;psrldq	(&quot;xmm0&quot;,4);
+
+	&amp;paddq	(&quot;xmm5&quot;,&quot;xmm0&quot;);
+	&amp;sbb	(&quot;eax&quot;,0);
+	&amp;pslldq	(&quot;xmm5&quot;,6);
+	 &amp;movq	(&quot;xmm4&quot;,&quot;xmm2&quot;);
+	&amp;paddq	(&quot;xmm1&quot;,&quot;xmm5&quot;);
+	 &amp;pand	(&quot;xmm2&quot;,&quot;xmm7&quot;);
+	&amp;psrldq	(&quot;xmm1&quot;,6);
+	&amp;movd	(&quot;ebx&quot;,&quot;xmm1&quot;);
+	&amp;psrldq	(&quot;xmm1&quot;,4);
+	&amp;mov	(&quot;esp&quot;,&quot;edx&quot;);
+
+	&amp;paddq	(&quot;xmm4&quot;,&quot;xmm1&quot;);
+	&amp;pslldq	(&quot;xmm4&quot;,6);
+	&amp;paddq	(&quot;xmm2&quot;,&quot;xmm4&quot;);
+	&amp;psrldq	(&quot;xmm2&quot;,6);
+	&amp;movd	(&quot;ecx&quot;,&quot;xmm2&quot;);
+	&amp;psrldq	(&quot;xmm2&quot;,4);
+	&amp;sbb	(&quot;ebx&quot;,0);
+	&amp;movd	(&quot;edx&quot;,&quot;xmm2&quot;);
+	&amp;pextrw	(&quot;esi&quot;,&quot;xmm2&quot;,2);		# top-most overflow bit
+	&amp;sbb	(&quot;ecx&quot;,1);
+	&amp;sbb	(&quot;edx&quot;,-1);
+	&amp;sbb	(&quot;esi&quot;,0);			# borrow from subtraction
+
+	# Final step is &quot;if result &gt; mod, subtract mod&quot;, and at this point
+	# we have result - mod written to output buffer, as well as borrow
+	# bit from this subtraction, and if borrow bit is set, we add
+	# modulus back.
+	#
+	# Note that because mod has special form, i.e. consists of
+	# 0xffffffff, 1 and 0s, we can conditionally synthesize it by
+	# assigning borrow bit to one register, %ebp, and its negative
+	# to another, %esi. But we started by calculating %esi...
+
+	&amp;sub	(&quot;ebp&quot;,&quot;esi&quot;);
+	&amp;add	(&amp;DWP(4*0,&quot;edi&quot;),&quot;esi&quot;);	# add modulus or zero
+	&amp;adc	(&amp;DWP(4*1,&quot;edi&quot;),&quot;esi&quot;);
+	&amp;adc	(&amp;DWP(4*2,&quot;edi&quot;),&quot;esi&quot;);
+	&amp;adc	(&amp;DWP(4*3,&quot;edi&quot;),0);
+	&amp;adc	(&quot;eax&quot;,0);
+	&amp;adc	(&quot;ebx&quot;,0);
+	&amp;mov	(&amp;DWP(4*4,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;adc	(&quot;ecx&quot;,&quot;ebp&quot;);
+	&amp;mov	(&amp;DWP(4*5,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;adc	(&quot;edx&quot;,&quot;esi&quot;);
+	&amp;mov	(&amp;DWP(4*6,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(4*7,&quot;edi&quot;),&quot;edx&quot;);
+
+	&amp;ret	();
+
+&amp;set_label(&quot;mul_mont_ialu&quot;,16);			}
+
+	########################################
+	# IALU code path suitable for all CPUs.
+	########################################
+	# stack layout:
+	# +------------------------------------+&lt; %esp
+	# | 8 32-bit temporary words, accessed |
+	# | as circular buffer                 |
+	# .                                    .
+	# .                                    .
+	# +------------------------------------+&lt; +32
+	# | offloaded destination pointer      |
+	# +------------------------------------+
+	# | unused                             |
+	# +------------------------------------+&lt; +40
+	&amp;sub	(&quot;esp&quot;,10*4);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0*4,&quot;esi&quot;));		# a[0]
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(0*4,&quot;ebp&quot;));		# b[0]
+	&amp;mov	(&amp;DWP(8*4,&quot;esp&quot;),&quot;edi&quot;);		# off-load dst ptr
+
+	&amp;mul	(&quot;ebx&quot;);				# a[0]*b[0]
+	&amp;mov	(&amp;DWP(0*4,&quot;esp&quot;),&quot;eax&quot;);		# t[0]
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(1*4,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;)
+
+	&amp;mul	(&quot;ebx&quot;);				# a[1]*b[0]
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(2*4,&quot;esi&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&amp;DWP(1*4,&quot;esp&quot;),&quot;ecx&quot;);		# t[1]
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[2]*b[0]
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(3*4,&quot;esi&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&amp;DWP(2*4,&quot;esp&quot;),&quot;ecx&quot;);		# t[2]
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[3]*b[0]
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(4*4,&quot;esi&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&amp;DWP(3*4,&quot;esp&quot;),&quot;ecx&quot;);		# t[3]
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[4]*b[0]
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(5*4,&quot;esi&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&amp;DWP(4*4,&quot;esp&quot;),&quot;ecx&quot;);		# t[4]
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[5]*b[0]
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(6*4,&quot;esi&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&amp;DWP(5*4,&quot;esp&quot;),&quot;ecx&quot;);		# t[5]
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[6]*b[0]
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(7*4,&quot;esi&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&amp;DWP(6*4,&quot;esp&quot;),&quot;ecx&quot;);		# t[6]
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;xor	(&quot;edi&quot;,&quot;edi&quot;);				# initial top-most carry
+	&amp;mul	(&quot;ebx&quot;);				# a[7]*b[0]
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);				# t[7]
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0*4,&quot;esp&quot;));		# t[0]
+	&amp;adc	(&quot;edx&quot;,0);				# t[8]
+
+for ($i=0;$i&lt;7;$i++) {
+	my $j=$i+1;
+
+	# Reduction iteration is normally performed by accumulating
+	# result of multiplication of modulus by &quot;magic&quot; digit [and
+	# omitting least significant word, which is guaranteed to
+	# be 0], but thanks to special form of modulus and &quot;magic&quot;
+	# digit being equal to least significant word, it can be
+	# performed with additions and subtractions alone. Indeed:
+	#
+	#        ffff.0001.0000.0000.0000.ffff.ffff.ffff
+	# *                                         abcd
+	# + xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.abcd
+	#
+	# Now observing that ff..ff*x = (2^n-1)*x = 2^n*x-x, we
+	# rewrite above as:
+	#
+	#   xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.abcd
+	# + abcd.0000.abcd.0000.0000.abcd.0000.0000.0000
+	# -      abcd.0000.0000.0000.0000.0000.0000.abcd
+	#
+	# or marking redundant operations:
+	#
+	#   xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.----
+	# + abcd.0000.abcd.0000.0000.abcd.----.----.----
+	# -      abcd.----.----.----.----.----.----.----
+
+	&amp;add	(&amp;DWP((($i+3)%8)*4,&quot;esp&quot;),&quot;eax&quot;);	# t[3]+=t[0]
+	&amp;adc	(&amp;DWP((($i+4)%8)*4,&quot;esp&quot;),0);		# t[4]+=0
+	&amp;adc	(&amp;DWP((($i+5)%8)*4,&quot;esp&quot;),0);		# t[5]+=0
+	&amp;adc	(&amp;DWP((($i+6)%8)*4,&quot;esp&quot;),&quot;eax&quot;);	# t[6]+=t[0]
+	&amp;adc	(&quot;ecx&quot;,0);				# t[7]+=0
+	&amp;adc	(&quot;edx&quot;,&quot;eax&quot;);				# t[8]+=t[0]
+	&amp;adc	(&quot;edi&quot;,0);				# top-most carry
+	 &amp;mov	(&quot;ebx&quot;,&amp;DWP($j*4,&quot;ebp&quot;));		# b[i]
+	&amp;sub	(&quot;ecx&quot;,&quot;eax&quot;);				# t[7]-=t[0]
+	 &amp;mov	(&quot;eax&quot;,&amp;DWP(0*4,&quot;esi&quot;));		# a[0]
+	&amp;sbb	(&quot;edx&quot;,0);				# t[8]-=0
+	&amp;mov	(&amp;DWP((($i+7)%8)*4,&quot;esp&quot;),&quot;ecx&quot;);
+	&amp;sbb	(&quot;edi&quot;,0);				# top-most carry,
+							# keep in mind that
+							# netto result is
+							# *addition* of value
+							# with (abcd&lt;&lt;32)-abcd
+							# on top, so that
+							# underflow is
+							# impossible, because
+							# (abcd&lt;&lt;32)-abcd
+							# doesn't underflow
+	&amp;mov	(&amp;DWP((($i+8)%8)*4,&quot;esp&quot;),&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[0]*b[i]
+	&amp;add	(&quot;eax&quot;,&amp;DWP((($j+0)%8)*4,&quot;esp&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&amp;DWP((($j+0)%8)*4,&quot;esp&quot;),&quot;eax&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(1*4,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;)
+
+	&amp;mul	(&quot;ebx&quot;);				# a[1]*b[i]
+	&amp;add	(&quot;ecx&quot;,&amp;DWP((($j+1)%8)*4,&quot;esp&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(2*4,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP((($j+1)%8)*4,&quot;esp&quot;),&quot;ecx&quot;);
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[2]*b[i]
+	&amp;add	(&quot;ecx&quot;,&amp;DWP((($j+2)%8)*4,&quot;esp&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(3*4,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP((($j+2)%8)*4,&quot;esp&quot;),&quot;ecx&quot;);
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[3]*b[i]
+	&amp;add	(&quot;ecx&quot;,&amp;DWP((($j+3)%8)*4,&quot;esp&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(4*4,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP((($j+3)%8)*4,&quot;esp&quot;),&quot;ecx&quot;);
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[4]*b[i]
+	&amp;add	(&quot;ecx&quot;,&amp;DWP((($j+4)%8)*4,&quot;esp&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(5*4,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP((($j+4)%8)*4,&quot;esp&quot;),&quot;ecx&quot;);
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[5]*b[i]
+	&amp;add	(&quot;ecx&quot;,&amp;DWP((($j+5)%8)*4,&quot;esp&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(6*4,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP((($j+5)%8)*4,&quot;esp&quot;),&quot;ecx&quot;);
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[6]*b[i]
+	&amp;add	(&quot;ecx&quot;,&amp;DWP((($j+6)%8)*4,&quot;esp&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(7*4,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP((($j+6)%8)*4,&quot;esp&quot;),&quot;ecx&quot;);
+	&amp;mov	(&quot;ecx&quot;,&quot;edx&quot;);
+
+	&amp;mul	(&quot;ebx&quot;);				# a[7]*b[i]
+	&amp;add	(&quot;ecx&quot;,&amp;DWP((($j+7)%8)*4,&quot;esp&quot;));
+	&amp;adc	(&quot;edx&quot;,0);
+	&amp;add	(&quot;ecx&quot;,&quot;eax&quot;);				# t[7]
+	&amp;mov	(&quot;eax&quot;,&amp;DWP((($j+0)%8)*4,&quot;esp&quot;));	# t[0]
+	&amp;adc	(&quot;edx&quot;,&quot;edi&quot;);				# t[8]
+	&amp;mov	(&quot;edi&quot;,0);
+	&amp;adc	(&quot;edi&quot;,0);				# top-most carry
+}
+	&amp;mov	(&quot;ebp&quot;,&amp;DWP(8*4,&quot;esp&quot;));		# restore dst ptr
+	&amp;xor	(&quot;esi&quot;,&quot;esi&quot;);
+	my $j=$i+1;
+
+	# last multiplication-less reduction
+	&amp;add	(&amp;DWP((($i+3)%8)*4,&quot;esp&quot;),&quot;eax&quot;);	# t[3]+=t[0]
+	&amp;adc	(&amp;DWP((($i+4)%8)*4,&quot;esp&quot;),0);		# t[4]+=0
+	&amp;adc	(&amp;DWP((($i+5)%8)*4,&quot;esp&quot;),0);		# t[5]+=0
+	&amp;adc	(&amp;DWP((($i+6)%8)*4,&quot;esp&quot;),&quot;eax&quot;);	# t[6]+=t[0]
+	&amp;adc	(&quot;ecx&quot;,0);				# t[7]+=0
+	&amp;adc	(&quot;edx&quot;,&quot;eax&quot;);				# t[8]+=t[0]
+	&amp;adc	(&quot;edi&quot;,0);				# top-most carry
+	 &amp;mov	(&quot;ebx&quot;,&amp;DWP((($j+1)%8)*4,&quot;esp&quot;));
+	&amp;sub	(&quot;ecx&quot;,&quot;eax&quot;);				# t[7]-=t[0]
+	 &amp;mov	(&quot;eax&quot;,&amp;DWP((($j+0)%8)*4,&quot;esp&quot;));
+	&amp;sbb	(&quot;edx&quot;,0);				# t[8]-=0
+	&amp;mov	(&amp;DWP((($i+7)%8)*4,&quot;esp&quot;),&quot;ecx&quot;);
+	&amp;sbb	(&quot;edi&quot;,0);				# top-most carry
+	&amp;mov	(&amp;DWP((($i+8)%8)*4,&quot;esp&quot;),&quot;edx&quot;);
+
+	# Final step is &quot;if result &gt; mod, subtract mod&quot;, but we do it
+	# &quot;other way around&quot;, namely write result - mod to output buffer
+	# and if subtraction borrowed, add modulus back.
+
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP((($j+2)%8)*4,&quot;esp&quot;));
+	&amp;sub	(&quot;eax&quot;,-1);
+	&amp;mov	(&quot;edx&quot;,&amp;DWP((($j+3)%8)*4,&quot;esp&quot;));
+	&amp;sbb	(&quot;ebx&quot;,-1);
+	&amp;mov	(&amp;DWP(0*4,&quot;ebp&quot;),&quot;eax&quot;);
+	&amp;sbb	(&quot;ecx&quot;,-1);
+	&amp;mov	(&amp;DWP(1*4,&quot;ebp&quot;),&quot;ebx&quot;);
+	&amp;sbb	(&quot;edx&quot;,0);
+	&amp;mov	(&amp;DWP(2*4,&quot;ebp&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(3*4,&quot;ebp&quot;),&quot;edx&quot;);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP((($j+4)%8)*4,&quot;esp&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP((($j+5)%8)*4,&quot;esp&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP((($j+6)%8)*4,&quot;esp&quot;));
+	&amp;sbb	(&quot;eax&quot;,0);
+	&amp;mov	(&quot;edx&quot;,&amp;DWP((($j+7)%8)*4,&quot;esp&quot;));
+	&amp;sbb	(&quot;ebx&quot;,0);
+	&amp;sbb	(&quot;ecx&quot;,1);
+	&amp;sbb	(&quot;edx&quot;,-1);
+	&amp;sbb	(&quot;edi&quot;,0);
+
+	# Note that because mod has special form, i.e. consists of
+	# 0xffffffff, 1 and 0s, we can conditionally synthesize it by
+	# assigning borrow bit to one register, %ebp, and its negative
+	# to another, %esi. But we started by calculating %esi...
+
+	&amp;sub	(&quot;esi&quot;,&quot;edi&quot;);
+	&amp;add	(&amp;DWP(0*4,&quot;ebp&quot;),&quot;edi&quot;);		# add modulus or zero
+	&amp;adc	(&amp;DWP(1*4,&quot;ebp&quot;),&quot;edi&quot;);
+	&amp;adc	(&amp;DWP(2*4,&quot;ebp&quot;),&quot;edi&quot;);
+	&amp;adc	(&amp;DWP(3*4,&quot;ebp&quot;),0);
+	&amp;adc	(&quot;eax&quot;,0);
+	&amp;adc	(&quot;ebx&quot;,0);
+	&amp;mov	(&amp;DWP(4*4,&quot;ebp&quot;),&quot;eax&quot;);
+	&amp;adc	(&quot;ecx&quot;,&quot;esi&quot;);
+	&amp;mov	(&amp;DWP(5*4,&quot;ebp&quot;),&quot;ebx&quot;);
+	&amp;adc	(&quot;edx&quot;,&quot;edi&quot;);
+	&amp;mov	(&amp;DWP(6*4,&quot;ebp&quot;),&quot;ecx&quot;);
+	&amp;mov	(&quot;edi&quot;,&quot;ebp&quot;);				# fulfill contract
+	&amp;mov	(&amp;DWP(7*4,&quot;ebp&quot;),&quot;edx&quot;);
+
+	&amp;add	(&quot;esp&quot;,10*4);
+	&amp;ret	();
+&amp;function_end_B(&quot;_ecp_nistz256_mul_mont&quot;);
+
+########################################################################
+# void ecp_nistz256_scatter_w5(void *edi,const P256_POINT *esi,
+#					 int ebp);
+&amp;function_begin(&quot;ecp_nistz256_scatter_w5&quot;);
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;ebp&quot;,&amp;wparam(2));
+
+	&amp;lea	(&quot;edi&quot;,&amp;DWP(128-4,&quot;edi&quot;,&quot;ebp&quot;,4));
+	&amp;mov	(&quot;ebp&quot;,96/16);
+&amp;set_label(&quot;scatter_w5_loop&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;esi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;esi&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;esi&quot;));
+	&amp;lea	(&quot;esi&quot;,&amp;DWP(16,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP(64*0-128,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP(64*1-128,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;mov	(&amp;DWP(64*2-128,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(64*3-128,&quot;edi&quot;),&quot;edx&quot;);
+	&amp;lea	(&quot;edi&quot;,&amp;DWP(64*4,&quot;edi&quot;));
+	&amp;dec	(&quot;ebp&quot;);
+	&amp;jnz	(&amp;label(&quot;scatter_w5_loop&quot;));
+&amp;function_end(&quot;ecp_nistz256_scatter_w5&quot;);
+
+########################################################################
+# void ecp_nistz256_gather_w5(P256_POINT *edi,const void *esi,
+#					      int ebp);
+&amp;function_begin(&quot;ecp_nistz256_gather_w5&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;ebp&quot;,&amp;wparam(2));
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP(0,&quot;esi&quot;,&quot;ebp&quot;,4));
+	&amp;neg	(&quot;ebp&quot;);
+	&amp;sar	(&quot;ebp&quot;,31);
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;lea	(&quot;esi&quot;,&amp;DWP(0,&quot;esi&quot;,&quot;ebp&quot;,4));
+
+    for($i=0;$i&lt;24;$i+=4) {
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(64*($i+0),&quot;esi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(64*($i+1),&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(64*($i+2),&quot;esi&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(64*($i+3),&quot;esi&quot;));
+	&amp;and	(&quot;eax&quot;,&quot;ebp&quot;);
+	&amp;and	(&quot;ebx&quot;,&quot;ebp&quot;);
+	&amp;and	(&quot;ecx&quot;,&quot;ebp&quot;);
+	&amp;and	(&quot;edx&quot;,&quot;ebp&quot;);
+	&amp;mov	(&amp;DWP(4*($i+0),&quot;edi&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP(4*($i+1),&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;mov	(&amp;DWP(4*($i+2),&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP(4*($i+3),&quot;edi&quot;),&quot;edx&quot;);
+    }
+&amp;function_end(&quot;ecp_nistz256_gather_w5&quot;);
+
+########################################################################
+# void ecp_nistz256_scatter_w7(void *edi,const P256_POINT_AFFINE *esi,
+#					 int ebp);
+&amp;function_begin(&quot;ecp_nistz256_scatter_w7&quot;);
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;ebp&quot;,&amp;wparam(2));
+
+	&amp;lea	(&quot;edi&quot;,&amp;DWP(-1,&quot;edi&quot;,&quot;ebp&quot;));
+	&amp;mov	(&quot;ebp&quot;,64/4);
+&amp;set_label(&quot;scatter_w7_loop&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;esi&quot;));
+	&amp;lea	(&quot;esi&quot;,&amp;DWP(4,&quot;esi&quot;));
+	&amp;mov	(&amp;BP(64*0,&quot;edi&quot;),&quot;al&quot;);
+	&amp;mov	(&amp;BP(64*1,&quot;edi&quot;),&quot;ah&quot;);
+	&amp;shr	(&quot;eax&quot;,16);
+	&amp;mov	(&amp;BP(64*2,&quot;edi&quot;),&quot;al&quot;);
+	&amp;mov	(&amp;BP(64*3,&quot;edi&quot;),&quot;ah&quot;);
+	&amp;lea	(&quot;edi&quot;,&amp;DWP(64*4,&quot;edi&quot;));
+	&amp;dec	(&quot;ebp&quot;);
+	&amp;jnz	(&amp;label(&quot;scatter_w7_loop&quot;));
+&amp;function_end(&quot;ecp_nistz256_scatter_w7&quot;);
+
+########################################################################
+# void ecp_nistz256_gather_w7(P256_POINT_AFFINE *edi,const void *esi,
+#						     int ebp);
+&amp;function_begin(&quot;ecp_nistz256_gather_w7&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;mov	(&quot;ebp&quot;,&amp;wparam(2));
+
+	&amp;add	(&quot;esi&quot;,&quot;ebp&quot;);
+	&amp;neg	(&quot;ebp&quot;),
+	&amp;sar	(&quot;ebp&quot;,31);
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;lea	(&quot;esi&quot;,&amp;DWP(0,&quot;esi&quot;,&quot;ebp&quot;));
+
+    for($i=0;$i&lt;64;$i+=4) {
+	&amp;movz	(&quot;eax&quot;,&amp;BP(64*($i+0),&quot;esi&quot;));
+	&amp;movz	(&quot;ebx&quot;,&amp;BP(64*($i+1),&quot;esi&quot;));
+	&amp;movz	(&quot;ecx&quot;,&amp;BP(64*($i+2),&quot;esi&quot;));
+	&amp;and	(&quot;eax&quot;,&quot;ebp&quot;);
+	&amp;movz	(&quot;edx&quot;,&amp;BP(64*($i+3),&quot;esi&quot;));
+	&amp;and	(&quot;ebx&quot;,&quot;ebp&quot;);
+	&amp;mov	(&amp;BP($i+0,&quot;edi&quot;),&quot;al&quot;);
+	&amp;and	(&quot;ecx&quot;,&quot;ebp&quot;);
+	&amp;mov	(&amp;BP($i+1,&quot;edi&quot;),&quot;bl&quot;);
+	&amp;and	(&quot;edx&quot;,&quot;ebp&quot;);
+	&amp;mov	(&amp;BP($i+2,&quot;edi&quot;),&quot;cl&quot;);
+	&amp;mov	(&amp;BP($i+3,&quot;edi&quot;),&quot;dl&quot;);
+    }
+&amp;function_end(&quot;ecp_nistz256_gather_w7&quot;);
+
+########################################################################
+# following subroutines are &quot;literal&quot; implementation of those found in
+# ecp_nistz256.c
+#
+########################################################################
+# void ecp_nistz256_point_double(P256_POINT *out,const P256_POINT *inp);
+#
+&amp;function_begin(&quot;ecp_nistz256_point_double&quot;);
+{   my ($S,$M,$Zsqr,$in_x,$tmp0)=map(32*$_,(0..4));
+
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+
+	# above map() describes stack layout with 5 temporary
+	# 256-bit vectors on top, then we take extra word for
+	# OPENSS_ia32cap_P copy.
+	&amp;stack_push(8*5+1);
+						if ($sse2) {
+	&amp;call	(&quot;_picup_eax&quot;);
+    &amp;set_label(&quot;pic&quot;);
+	&amp;picmeup(&quot;edx&quot;,&quot;OPENSSL_ia32cap_P&quot;,&quot;eax&quot;,&amp;label(&quot;pic&quot;));
+	&amp;mov	(&quot;ebp&quot;,&amp;DWP(0,&quot;edx&quot;));		}
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(0,&quot;esi&quot;));		# copy in_x
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(4,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(8,&quot;esi&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(12,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP($in_x+0,&quot;esp&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP($in_x+4,&quot;esp&quot;),&quot;ebx&quot;);
+	&amp;mov	(&amp;DWP($in_x+8,&quot;esp&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP($in_x+12,&quot;esp&quot;),&quot;edx&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(16,&quot;esi&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(20,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP(24,&quot;esi&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP(28,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP($in_x+16,&quot;esp&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP($in_x+20,&quot;esp&quot;),&quot;ebx&quot;);
+	&amp;mov	(&amp;DWP($in_x+24,&quot;esp&quot;),&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP($in_x+28,&quot;esp&quot;),&quot;edx&quot;);
+	&amp;mov	(&amp;DWP(32*5,&quot;esp&quot;),&quot;ebp&quot;);	# OPENSSL_ia32cap_P copy
+
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP(32,&quot;esi&quot;));
+	&amp;lea	(&quot;esi&quot;,&amp;DWP(32,&quot;esi&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);		# p256_mul_by_2(S, in_y);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*5,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;mov	(&quot;esi&quot;,64);
+	&amp;add	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Zsqr,&quot;esp&quot;));
+	&amp;mov	(&quot;ebp&quot;,&quot;esi&quot;);
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(Zsqr, in_z);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*5,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(S, S);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*5,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;mov	(&quot;ebp&quot;,&amp;wparam(1));
+	&amp;lea	(&quot;esi&quot;,&amp;DWP(32,&quot;ebp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP(64,&quot;ebp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($tmp0,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(tmp0, in_z, in_y);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in_x,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Zsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($M,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);		# p256_add(M, in_x, Zsqr);
+
+	&amp;mov	(&quot;edi&quot;,64);
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($tmp0,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($tmp0,&quot;esp&quot;));
+	&amp;add	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);		# p256_mul_by_2(res_z, tmp0);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in_x,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Zsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Zsqr,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(Zsqr, in_x, Zsqr);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*5,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($tmp0,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(tmp0, S);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*5,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($M,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Zsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($M,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(M, M, Zsqr);
+
+	&amp;mov	(&quot;edi&quot;,32);
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($tmp0,&quot;esp&quot;));
+	&amp;add	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;call	(&quot;_ecp_nistz256_div_by_2&quot;);	# p256_div_by_2(res_y, tmp0);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($M,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($M,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($tmp0,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);		# 1/2 p256_mul_by_3(M, M);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*5,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in_x,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(S, S, in_x);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($tmp0,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($M,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($M,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);		# 2/2 p256_mul_by_3(M, M);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($tmp0,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);		# p256_mul_by_2(tmp0, S);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*5,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($M,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($M,&quot;esp&quot;));
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(res_x, M);
+
+	&amp;mov	(&quot;esi&quot;,&quot;edi&quot;);			# %edi is still res_x here
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($tmp0,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(res_x, res_x, tmp0);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;mov	(&quot;ebp&quot;,&quot;edi&quot;);			# %edi is still res_x
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(S, S, res_x);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*5,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;mov	(&quot;esi&quot;,&quot;edi&quot;);			# %edi is still &amp;S
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($M,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(S, S, M);
+
+	&amp;mov	(&quot;ebp&quot;,32);
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($S,&quot;esp&quot;));
+	&amp;add	(&quot;ebp&quot;,&amp;wparam(0));
+	&amp;mov	(&quot;edi&quot;,&quot;ebp&quot;);
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(res_y, S, res_y);
+
+	&amp;stack_pop(8*5+1);
+} &amp;function_end(&quot;ecp_nistz256_point_double&quot;);
+
+########################################################################
+# void ecp_nistz256_point_add(P256_POINT *out,const P256_POINT *in1,
+#					      const P256_POINT *in2);
+&amp;function_begin(&quot;ecp_nistz256_point_add&quot;);
+{   my ($res_x,$res_y,$res_z,
+	$in1_x,$in1_y,$in1_z,
+	$in2_x,$in2_y,$in2_z,
+	$H,$Hsqr,$R,$Rsqr,$Hcub,
+	$U1,$U2,$S1,$S2)=map(32*$_,(0..17));
+    my ($Z1sqr, $Z2sqr) = ($Hsqr, $Rsqr);
+
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(2));
+
+	# above map() describes stack layout with 18 temporary
+	# 256-bit vectors on top, then we take extra words for
+	# !in1infty, !in2infty, result of check for zero and
+	# OPENSS_ia32cap_P copy. [one unused word for padding]
+	&amp;stack_push(8*18+5);
+						if ($sse2) {
+	&amp;call	(&quot;_picup_eax&quot;);
+    &amp;set_label(&quot;pic&quot;);
+	&amp;picmeup(&quot;edx&quot;,&quot;OPENSSL_ia32cap_P&quot;,&quot;eax&quot;,&amp;label(&quot;pic&quot;));
+	&amp;mov	(&quot;ebp&quot;,&amp;DWP(0,&quot;edx&quot;));		}
+
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($in2_x,&quot;esp&quot;));
+    for($i=0;$i&lt;96;$i+=16) {
+	&amp;mov	(&quot;eax&quot;,&amp;DWP($i+0,&quot;esi&quot;));	# copy in2
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP($i+4,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP($i+8,&quot;esi&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP($i+12,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP($i+0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP(32*18+12,&quot;esp&quot;),&quot;ebp&quot;)	if ($i==0);
+	&amp;mov	(&quot;ebp&quot;,&quot;eax&quot;)			if ($i==0);
+	&amp;or	(&quot;ebp&quot;,&quot;eax&quot;)			if ($i!=0 &amp;&amp; $i&lt;64);
+	&amp;mov	(&amp;DWP($i+4,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;ebx&quot;)			if ($i&lt;64);
+	&amp;mov	(&amp;DWP($i+8,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;ecx&quot;)			if ($i&lt;64);
+	&amp;mov	(&amp;DWP($i+12,&quot;edi&quot;),&quot;edx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;edx&quot;)			if ($i&lt;64);
+    }
+	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+	&amp;sub	(&quot;eax&quot;,&quot;ebp&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;eax&quot;);
+	&amp;sar	(&quot;ebp&quot;,31);
+	&amp;mov	(&amp;DWP(32*18+4,&quot;esp&quot;),&quot;ebp&quot;);	# !in2infty
+
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($in1_x,&quot;esp&quot;));
+    for($i=0;$i&lt;96;$i+=16) {
+	&amp;mov	(&quot;eax&quot;,&amp;DWP($i+0,&quot;esi&quot;));	# copy in1
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP($i+4,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP($i+8,&quot;esi&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP($i+12,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP($i+0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;mov	(&quot;ebp&quot;,&quot;eax&quot;)			if ($i==0);
+	&amp;or	(&quot;ebp&quot;,&quot;eax&quot;)			if ($i!=0 &amp;&amp; $i&lt;64);
+	&amp;mov	(&amp;DWP($i+4,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;ebx&quot;)			if ($i&lt;64);
+	&amp;mov	(&amp;DWP($i+8,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;ecx&quot;)			if ($i&lt;64);
+	&amp;mov	(&amp;DWP($i+12,&quot;edi&quot;),&quot;edx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;edx&quot;)			if ($i&lt;64);
+    }
+	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);
+	&amp;sub	(&quot;eax&quot;,&quot;ebp&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;eax&quot;);
+	&amp;sar	(&quot;ebp&quot;,31);
+	&amp;mov	(&amp;DWP(32*18+0,&quot;esp&quot;),&quot;ebp&quot;);	# !in1infty
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in2_z,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($in2_z,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Z2sqr,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(Z2sqr, in2_z);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in1_z,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($in1_z,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Z1sqr,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(Z1sqr, in1_z);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($Z2sqr,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($in2_z,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S1,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(S1, Z2sqr, in2_z);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($Z1sqr,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($in1_z,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(S2, Z1sqr, in1_z);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in1_y,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S1,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S1,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(S1, S1, in1_y);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in2_y,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(S2, S2, in2_y);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S1,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($R,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(R, S2, S1);
+
+	&amp;or	(&quot;ebx&quot;,&quot;eax&quot;);			# see if result is zero
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;or	(&quot;ebx&quot;,&quot;ecx&quot;);
+	&amp;or	(&quot;ebx&quot;,&quot;edx&quot;);
+	&amp;or	(&quot;ebx&quot;,&amp;DWP(0,&quot;edi&quot;));
+	&amp;or	(&quot;ebx&quot;,&amp;DWP(4,&quot;edi&quot;));
+	 &amp;lea	(&quot;esi&quot;,&amp;DWP($in1_x,&quot;esp&quot;));
+	&amp;or	(&quot;ebx&quot;,&amp;DWP(8,&quot;edi&quot;));
+	 &amp;lea	(&quot;ebp&quot;,&amp;DWP($Z2sqr,&quot;esp&quot;));
+	&amp;or	(&quot;ebx&quot;,&amp;DWP(12,&quot;edi&quot;));
+	 &amp;lea	(&quot;edi&quot;,&amp;DWP($U1,&quot;esp&quot;));
+	&amp;mov	(&amp;DWP(32*18+8,&quot;esp&quot;),&quot;ebx&quot;);
+
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(U1, in1_x, Z2sqr);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in2_x,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Z1sqr,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(U2, in2_x, Z1sqr);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($U1,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($H,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(H, U2, U1);
+
+	&amp;or	(&quot;eax&quot;,&quot;ebx&quot;);			# see if result is zero
+	&amp;or	(&quot;eax&quot;,&quot;ecx&quot;);
+	&amp;or	(&quot;eax&quot;,&quot;edx&quot;);
+	&amp;or	(&quot;eax&quot;,&amp;DWP(0,&quot;edi&quot;));
+	&amp;or	(&quot;eax&quot;,&amp;DWP(4,&quot;edi&quot;));
+	&amp;or	(&quot;eax&quot;,&amp;DWP(8,&quot;edi&quot;));
+	&amp;or	(&quot;eax&quot;,&amp;DWP(12,&quot;edi&quot;));
+
+	&amp;data_byte(0x3e);			# predict taken
+	&amp;jnz	(&amp;label(&quot;add_proceed&quot;));	# is_equal(U1,U2)?
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+0,&quot;esp&quot;));
+	&amp;and	(&quot;eax&quot;,&amp;DWP(32*18+4,&quot;esp&quot;));
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP(32*18+8,&quot;esp&quot;));
+	&amp;jz	(&amp;label(&quot;add_proceed&quot;));	# (in1infty || in2infty)?
+	&amp;test	(&quot;ebx&quot;,&quot;ebx&quot;);
+	&amp;jz	(&amp;label(&quot;add_proceed&quot;));	# is_equal(S1,S2)?
+
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);
+	&amp;mov	(&quot;ecx&quot;,96/4);
+	&amp;data_byte(0xfc,0xf3,0xab);		# cld; stosd
+	&amp;jmp	(&amp;label(&quot;add_done&quot;));
+
+&amp;set_label(&quot;add_proceed&quot;,16);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($R,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($R,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Rsqr,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(Rsqr, R);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($H,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($in1_z,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_z,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(res_z, H, in1_z);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($H,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($H,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Hsqr,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(Hsqr, H);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in2_z,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($res_z,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_z,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(res_z, res_z, in2_z);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($Hsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($U1,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(U2, U1, Hsqr);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($H,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Hsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Hcub,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(Hcub, Hsqr, H);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Hsqr,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);		# p256_mul_by_2(Hsqr, U2);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($Rsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Hsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_x,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(res_x, Rsqr, Hsqr);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($res_x,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Hcub,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_x,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(res_x, res_x, Hcub);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($res_x,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_y,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(res_y, U2, res_x);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($Hcub,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S1,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(S2, S1, Hcub);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*18+12,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($R,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($res_y,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_y,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(res_y, R, res_y);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($res_y,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_y,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(res_y, res_y, S2);
+
+	&amp;mov	(&quot;ebp&quot;,&amp;DWP(32*18+0,&quot;esp&quot;));	# !in1infty
+	&amp;mov	(&quot;esi&quot;,&amp;DWP(32*18+4,&quot;esp&quot;));	# !in2infty
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;mov	(&quot;edx&quot;,&quot;ebp&quot;);
+	&amp;not	(&quot;ebp&quot;);
+	&amp;and	(&quot;edx&quot;,&quot;esi&quot;);
+	&amp;and	(&quot;ebp&quot;,&quot;esi&quot;);
+	&amp;not	(&quot;esi&quot;);
+
+	########################################
+	# conditional moves
+    for($i=64;$i&lt;96;$i+=4) {
+	&amp;mov	(&quot;eax&quot;,&quot;edx&quot;);
+	&amp;and	(&quot;eax&quot;,&amp;DWP($res_x+$i,&quot;esp&quot;));
+	&amp;mov	(&quot;ebx&quot;,&quot;ebp&quot;);
+	&amp;and	(&quot;ebx&quot;,&amp;DWP($in2_x+$i,&quot;esp&quot;));
+	&amp;mov	(&quot;ecx&quot;,&quot;esi&quot;);
+	&amp;and	(&quot;ecx&quot;,&amp;DWP($in1_x+$i,&quot;esp&quot;));
+	&amp;or	(&quot;eax&quot;,&quot;ebx&quot;);
+	&amp;or	(&quot;eax&quot;,&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP($i,&quot;edi&quot;),&quot;eax&quot;);
+    }
+    for($i=0;$i&lt;64;$i+=4) {
+	&amp;mov	(&quot;eax&quot;,&quot;edx&quot;);
+	&amp;and	(&quot;eax&quot;,&amp;DWP($res_x+$i,&quot;esp&quot;));
+	&amp;mov	(&quot;ebx&quot;,&quot;ebp&quot;);
+	&amp;and	(&quot;ebx&quot;,&amp;DWP($in2_x+$i,&quot;esp&quot;));
+	&amp;mov	(&quot;ecx&quot;,&quot;esi&quot;);
+	&amp;and	(&quot;ecx&quot;,&amp;DWP($in1_x+$i,&quot;esp&quot;));
+	&amp;or	(&quot;eax&quot;,&quot;ebx&quot;);
+	&amp;or	(&quot;eax&quot;,&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP($i,&quot;edi&quot;),&quot;eax&quot;);
+    }
+    &amp;set_label(&quot;add_done&quot;);
+	&amp;stack_pop(8*18+5);
+} &amp;function_end(&quot;ecp_nistz256_point_add&quot;);
+
+########################################################################
+# void ecp_nistz256_point_add_affine(P256_POINT *out,
+#				     const P256_POINT *in1,
+#				     const P256_POINT_AFFINE *in2);
+&amp;function_begin(&quot;ecp_nistz256_point_add_affine&quot;);
+{
+    my ($res_x,$res_y,$res_z,
+	$in1_x,$in1_y,$in1_z,
+	$in2_x,$in2_y,
+	$U2,$S2,$H,$R,$Hsqr,$Hcub,$Rsqr)=map(32*$_,(0..14));
+    my $Z1sqr = $S2;
+    my @ONE_mont=(1,0,0,-1,-1,-1,-2,0);
+
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(1));
+
+	# above map() describes stack layout with 15 temporary
+	# 256-bit vectors on top, then we take extra words for
+	# !in1infty, !in2infty, and OPENSS_ia32cap_P copy.
+	&amp;stack_push(8*15+3);
+						if ($sse2) {
+	&amp;call	(&quot;_picup_eax&quot;);
+    &amp;set_label(&quot;pic&quot;);
+	&amp;picmeup(&quot;edx&quot;,&quot;OPENSSL_ia32cap_P&quot;,&quot;eax&quot;,&amp;label(&quot;pic&quot;));
+	&amp;mov	(&quot;ebp&quot;,&amp;DWP(0,&quot;edx&quot;));		}
+
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($in1_x,&quot;esp&quot;));
+    for($i=0;$i&lt;96;$i+=16) {
+	&amp;mov	(&quot;eax&quot;,&amp;DWP($i+0,&quot;esi&quot;));	# copy in1
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP($i+4,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP($i+8,&quot;esi&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP($i+12,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP($i+0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;mov	(&amp;DWP(32*15+8,&quot;esp&quot;),&quot;ebp&quot;)	if ($i==0);
+	&amp;mov	(&quot;ebp&quot;,&quot;eax&quot;)			if ($i==0);
+	&amp;or	(&quot;ebp&quot;,&quot;eax&quot;)			if ($i!=0 &amp;&amp; $i&lt;64);
+	&amp;mov	(&amp;DWP($i+4,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;ebx&quot;)			if ($i&lt;64);
+	&amp;mov	(&amp;DWP($i+8,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;ecx&quot;)			if ($i&lt;64);
+	&amp;mov	(&amp;DWP($i+12,&quot;edi&quot;),&quot;edx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;edx&quot;)			if ($i&lt;64);
+    }
+	&amp;xor	(&quot;eax&quot;,&quot;eax&quot;);
+	&amp;mov	(&quot;esi&quot;,&amp;wparam(2));
+	&amp;sub	(&quot;eax&quot;,&quot;ebp&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;eax&quot;);
+	&amp;sar	(&quot;ebp&quot;,31);
+	&amp;mov	(&amp;DWP(32*15+0,&quot;esp&quot;),&quot;ebp&quot;);	# !in1infty
+
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($in2_x,&quot;esp&quot;));
+    for($i=0;$i&lt;64;$i+=16) {
+	&amp;mov	(&quot;eax&quot;,&amp;DWP($i+0,&quot;esi&quot;));	# copy in2
+	&amp;mov	(&quot;ebx&quot;,&amp;DWP($i+4,&quot;esi&quot;));
+	&amp;mov	(&quot;ecx&quot;,&amp;DWP($i+8,&quot;esi&quot;));
+	&amp;mov	(&quot;edx&quot;,&amp;DWP($i+12,&quot;esi&quot;));
+	&amp;mov	(&amp;DWP($i+0,&quot;edi&quot;),&quot;eax&quot;);
+	&amp;mov	(&quot;ebp&quot;,&quot;eax&quot;)			if ($i==0);
+	&amp;or	(&quot;ebp&quot;,&quot;eax&quot;)			if ($i!=0);
+	&amp;mov	(&amp;DWP($i+4,&quot;edi&quot;),&quot;ebx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;ebx&quot;);
+	&amp;mov	(&amp;DWP($i+8,&quot;edi&quot;),&quot;ecx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP($i+12,&quot;edi&quot;),&quot;edx&quot;);
+	&amp;or	(&quot;ebp&quot;,&quot;edx&quot;);
+    }
+	&amp;xor	(&quot;ebx&quot;,&quot;ebx&quot;);
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;sub	(&quot;ebx&quot;,&quot;ebp&quot;);
+	 &amp;lea	(&quot;esi&quot;,&amp;DWP($in1_z,&quot;esp&quot;));
+	&amp;or	(&quot;ebx&quot;,&quot;ebp&quot;);
+	 &amp;lea	(&quot;ebp&quot;,&amp;DWP($in1_z,&quot;esp&quot;));
+	&amp;sar	(&quot;ebx&quot;,31);
+	 &amp;lea	(&quot;edi&quot;,&amp;DWP($Z1sqr,&quot;esp&quot;));
+	&amp;mov	(&amp;DWP(32*15+4,&quot;esp&quot;),&quot;ebx&quot;);	# !in2infty
+
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(Z1sqr, in1_z);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in2_x,&quot;esp&quot;));
+	&amp;mov	(&quot;ebp&quot;,&quot;edi&quot;);			# %esi is stull &amp;Z1sqr
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(U2, Z1sqr, in2_x);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in1_z,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Z1sqr,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(S2, Z1sqr, in1_z);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($in1_x,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($H,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(H, U2, in1_x);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in2_y,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(S2, S2, in2_y);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in1_z,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($H,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_z,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(res_z, H, in1_z);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($in1_y,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($R,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(R, S2, in1_y);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($H,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($H,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Hsqr,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(Hsqr, H);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($R,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($R,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Rsqr,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_sqr_mont(Rsqr, R);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($in1_x,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Hsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(U2, in1_x, Hsqr);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($H,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Hsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Hcub,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(Hcub, Hsqr, H);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($Hsqr,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_add&quot;);		# p256_mul_by_2(Hsqr, U2);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($Rsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Hsqr,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_x,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(res_x, Rsqr, Hsqr);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($res_x,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($Hcub,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_x,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(res_x, res_x, Hcub);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($U2,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($res_x,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_y,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(res_y, U2, res_x);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($Hcub,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($in1_y,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(S2, Hcub, in1_y);
+
+	&amp;mov	(&quot;eax&quot;,&amp;DWP(32*15+8,&quot;esp&quot;));	# OPENSSL_ia32cap_P copy
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($R,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($res_y,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_y,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_mul_mont&quot;);	# p256_mul_mont(res_y, res_y, R);
+
+	&amp;lea	(&quot;esi&quot;,&amp;DWP($res_y,&quot;esp&quot;));
+	&amp;lea	(&quot;ebp&quot;,&amp;DWP($S2,&quot;esp&quot;));
+	&amp;lea	(&quot;edi&quot;,&amp;DWP($res_y,&quot;esp&quot;));
+	&amp;call	(&quot;_ecp_nistz256_sub&quot;);		# p256_sub(res_y, res_y, S2);
+
+	&amp;mov	(&quot;ebp&quot;,&amp;DWP(32*15+0,&quot;esp&quot;));	# !in1infty
+	&amp;mov	(&quot;esi&quot;,&amp;DWP(32*15+4,&quot;esp&quot;));	# !in2infty
+	&amp;mov	(&quot;edi&quot;,&amp;wparam(0));
+	&amp;mov	(&quot;edx&quot;,&quot;ebp&quot;);
+	&amp;not	(&quot;ebp&quot;);
+	&amp;and	(&quot;edx&quot;,&quot;esi&quot;);
+	&amp;and	(&quot;ebp&quot;,&quot;esi&quot;);
+	&amp;not	(&quot;esi&quot;);
+
+	########################################
+	# conditional moves
+    for($i=64;$i&lt;96;$i+=4) {
+	my $one=@ONE_mont[($i-64)/4];
+
+	&amp;mov	(&quot;eax&quot;,&quot;edx&quot;);
+	&amp;and	(&quot;eax&quot;,&amp;DWP($res_x+$i,&quot;esp&quot;));
+	&amp;mov	(&quot;ebx&quot;,&quot;ebp&quot;)			if ($one &amp;&amp; $one!=-1);
+	&amp;and	(&quot;ebx&quot;,$one)			if ($one &amp;&amp; $one!=-1);
+	&amp;mov	(&quot;ecx&quot;,&quot;esi&quot;);
+	&amp;and	(&quot;ecx&quot;,&amp;DWP($in1_x+$i,&quot;esp&quot;));
+	&amp;or	(&quot;eax&quot;,$one==-1?&quot;ebp&quot;:&quot;ebx&quot;)	if ($one);
+	&amp;or	(&quot;eax&quot;,&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP($i,&quot;edi&quot;),&quot;eax&quot;);
+    }
+    for($i=0;$i&lt;64;$i+=4) {
+	&amp;mov	(&quot;eax&quot;,&quot;edx&quot;);
+	&amp;and	(&quot;eax&quot;,&amp;DWP($res_x+$i,&quot;esp&quot;));
+	&amp;mov	(&quot;ebx&quot;,&quot;ebp&quot;);
+	&amp;and	(&quot;ebx&quot;,&amp;DWP($in2_x+$i,&quot;esp&quot;));
+	&amp;mov	(&quot;ecx&quot;,&quot;esi&quot;);
+	&amp;and	(&quot;ecx&quot;,&amp;DWP($in1_x+$i,&quot;esp&quot;));
+	&amp;or	(&quot;eax&quot;,&quot;ebx&quot;);
+	&amp;or	(&quot;eax&quot;,&quot;ecx&quot;);
+	&amp;mov	(&amp;DWP($i,&quot;edi&quot;),&quot;eax&quot;);
+    }
+	&amp;stack_pop(8*15+3);
+} &amp;function_end(&quot;ecp_nistz256_point_add_affine&quot;);
+
+&amp;asm_finish();
</PRE>






















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000456.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="000459.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#457">[ date ]</a>
              <a href="thread.html#457">[ thread ]</a>
              <a href="subject.html#457">[ subject ]</a>
              <a href="author.html#457">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
