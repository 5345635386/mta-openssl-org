<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-September/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1473974651.138847.13060.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010496.html">
   <LINK REL="Next"  HREF="010519.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1473974651.138847.13060.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">levitte at openssl.org
       </A><BR>
    <I>Thu Sep 15 21:24:11 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="010496.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="010519.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10515">[ date ]</a>
              <a href="thread.html#10515">[ thread ]</a>
              <a href="subject.html#10515">[ subject ]</a>
              <a href="author.html#10515">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  d602c2b680aefd3e0d00d090783ef5f912caf06a (commit)
       via  51e5133d551b4c132f72fc2ff5bbe076f5a3e052 (commit)
       via  c7bdb6a31ff0fcae66b451d3f80a684ad77f4966 (commit)
       via  0d0723e813870c2e7a009ec47e933668a1548531 (commit)
       via  0d3b65832c6fa94c1d1cfa2f99335f323e3227c1 (commit)
      from  6f0ac0e2f27d9240516edb9a23b7863e7ad02898 (commit)


- Log -----------------------------------------------------------------
commit d602c2b680aefd3e0d00d090783ef5f912caf06a
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Sep 14 23:40:27 2016 +0200

    Finally, make sure vms_term_sock.c is built on VMS
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 51e5133d551b4c132f72fc2ff5bbe076f5a3e052
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Thu Sep 15 11:20:18 2016 +0200

    Refactor to avoid unnecessary preprocessor logic
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit c7bdb6a31ff0fcae66b451d3f80a684ad77f4966
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Sep 14 20:54:30 2016 +0200

    Reformat to fit OpenSSL source code standards
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 0d0723e813870c2e7a009ec47e933668a1548531
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Sep 14 20:52:03 2016 +0200

    Add copyright and license on apps/vms_term_sock.[ch]
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 0d3b65832c6fa94c1d1cfa2f99335f323e3227c1
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Wed Aug 3 21:16:43 2016 +0200

    VSI submission: redirect terminal input through socket
    
    This is needed, because on VMS, select() can only be used on sockets.  being
    able to use select() on all kinds of file descriptors is unique to Unix.
    
    So, the solution for VMS is to create a layer that translates input from
    standard input to socket communication.
    
    Reviewed-by: Andy Polyakov &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">appro at openssl.org</A>&gt;
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 Configurations/10-main.conf |   2 +-
 apps/apps.c                 |  39 ++-
 apps/apps.h                 |   2 +
 apps/s_client.c             |  18 +-
 apps/s_server.c             |  10 +-
 apps/vms_term_sock.c        | 590 ++++++++++++++++++++++++++++++++++++++++++++
 apps/vms_term_sock.h        |  30 +++
 7 files changed, 678 insertions(+), 13 deletions(-)
 create mode 100644 apps/vms_term_sock.c
 create mode 100644 apps/vms_term_sock.h

diff --git a/Configurations/10-main.conf b/Configurations/10-main.conf
index 846a6c8..fc673a1 100644
--- a/Configurations/10-main.conf
+++ b/Configurations/10-main.conf
@@ -1774,7 +1774,7 @@ sub vms_info {
         dso_scheme       =&gt; &quot;vms&quot;,
         thread_scheme    =&gt; &quot;pthreads&quot;,
 
-        apps_aux_src     =&gt; &quot;vms_decc_init.c&quot;,
+        apps_aux_src     =&gt; &quot;vms_decc_init.c vms_term_sock.c&quot;,
     },
 
     &quot;vms-alpha&quot; =&gt; {
diff --git a/apps/apps.c b/apps/apps.c
index 522db71..6ca0f2b 100644
--- a/apps/apps.c
+++ b/apps/apps.c
@@ -2300,6 +2300,36 @@ int app_isdir(const char *name)
 #endif
 
 /* raw_read|write section */
+#if defined(__VMS)
+# include &quot;vms_term_sock.h&quot;
+static int stdin_sock = -1;
+
+static void close_stdin_sock(void)
+{
+    TerminalSocket (TERM_SOCK_DELETE, &amp;stdin_sock);
+}
+
+int fileno_stdin(void)
+{
+    if (stdin_sock == -1) {
+        TerminalSocket(TERM_SOCK_CREATE, &amp;stdin_sock);
+        atexit(close_stdin_sock);
+    }
+
+    return stdin_sock;
+}
+#else
+int fileno_stdin(void)
+{
+    return fileno(stdin);
+}
+#endif
+
+int fileno_stdout(void)
+{
+    return fileno(stdout);
+}
+
 #if defined(_WIN32) &amp;&amp; defined(STD_INPUT_HANDLE)
 int raw_read_stdin(void *buf, int siz)
 {
@@ -2309,10 +2339,15 @@ int raw_read_stdin(void *buf, int siz)
     else
         return (-1);
 }
+#elif defined(__VMS)
+int raw_read_stdin(void *buf, int siz)
+{
+    return recv(fileno_stdin(), buf, siz, 0);
+}
 #else
 int raw_read_stdin(void *buf, int siz)
 {
-    return read(fileno(stdin), buf, siz);
+    return read(fileno_stdin(), buf, siz);
 }
 #endif
 
@@ -2328,7 +2363,7 @@ int raw_write_stdout(const void *buf, int siz)
 #else
 int raw_write_stdout(const void *buf, int siz)
 {
-    return write(fileno(stdout), buf, siz);
+    return write(fileno_stdout(), buf, siz);
 }
 #endif
 
diff --git a/apps/apps.h b/apps/apps.h
index 1761501..6083780 100644
--- a/apps/apps.h
+++ b/apps/apps.h
@@ -549,6 +549,8 @@ void store_setup_crl_download(X509_STORE *st);
 
 int app_isdir(const char *);
 int app_access(const char *, int flag);
+int fileno_stdin(void);
+int fileno_stdout(void);
 int raw_read_stdin(void *, int);
 int raw_write_stdout(const void *, int);
 
diff --git a/apps/s_client.c b/apps/s_client.c
index 9c83d64..0627ae8 100644
--- a/apps/s_client.c
+++ b/apps/s_client.c
@@ -1821,7 +1821,10 @@ int s_client_main(int argc, char **argv)
     SSL_set_connect_state(con);
 
     /* ok, lets connect */
-    width = SSL_get_fd(con) + 1;
+    if (fileno_stdin() &gt; SSL_get_fd(con))
+        width = fileno_stdin() + 1;
+    else
+        width = SSL_get_fd(con) + 1;
 
     read_tty = 1;
     write_tty = 0;
@@ -2150,9 +2153,11 @@ int s_client_main(int argc, char **argv)
                  * set the flag so we exit.
                  */
                 if (read_tty &amp;&amp; !at_eof)
-                    openssl_fdset(fileno(stdin), &amp;readfds);
+                    openssl_fdset(fileno_stdin(), &amp;readfds);
+#if !defined(OPENSSL_SYS_VMS)
                 if (write_tty)
-                    openssl_fdset(fileno(stdout), &amp;writefds);
+                    openssl_fdset(fileno_stdout(), &amp;writefds);
+#endif
             }
             if (read_ssl)
                 openssl_fdset(SSL_get_fd(con), &amp;readfds);
@@ -2278,11 +2283,11 @@ int s_client_main(int argc, char **argv)
                 goto shut;
             }
         }
-#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)
+#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_VMS)
         /* Assume Windows/DOS/BeOS can always write */
         else if (!ssl_pending &amp;&amp; write_tty)
 #else
-        else if (!ssl_pending &amp;&amp; FD_ISSET(fileno(stdout), &amp;writefds))
+        else if (!ssl_pending &amp;&amp; FD_ISSET(fileno_stdout(), &amp;writefds))
 #endif
         {
 #ifdef CHARSET_EBCDIC
@@ -2371,7 +2376,7 @@ int s_client_main(int argc, char **argv)
 #if defined(OPENSSL_SYS_MSDOS)
         else if (has_stdin_waiting())
 #else
-        else if (FD_ISSET(fileno(stdin), &amp;readfds))
+        else if (FD_ISSET(fileno_stdin(), &amp;readfds))
 #endif
         {
             if (crlf) {
@@ -2394,7 +2399,6 @@ int s_client_main(int argc, char **argv)
                 assert(lf_num == 0);
             } else
                 i = raw_read_stdin(cbuf, BUFSIZZ);
-
 #if !defined(OPENSSL_SYS_WINDOWS) &amp;&amp; !defined(OPENSSL_SYS_MSDOS)
             if (i == 0)
                 at_eof = 1;
diff --git a/apps/s_server.c b/apps/s_server.c
index 742cb83..ebab7a2 100644
--- a/apps/s_server.c
+++ b/apps/s_server.c
@@ -2107,7 +2107,10 @@ static int sv_body(int s, int stype, unsigned char *context)
         SSL_set_tlsext_debug_arg(con, bio_s_out);
     }
 
-    width = s + 1;
+    if (fileno_stdin() &gt; s)
+        width = fileno_stdin() + 1;
+    else
+        width = s + 1;
     for (;;) {
         int read_from_terminal;
         int read_from_sslcon;
@@ -2119,7 +2122,7 @@ static int sv_body(int s, int stype, unsigned char *context)
         if (!read_from_sslcon) {
             FD_ZERO(&amp;readfds);
 #if !defined(OPENSSL_SYS_WINDOWS) &amp;&amp; !defined(OPENSSL_SYS_MSDOS)
-            openssl_fdset(fileno(stdin), &amp;readfds);
+            openssl_fdset(fileno_stdin(), &amp;readfds);
 #endif
             openssl_fdset(s, &amp;readfds);
             /*
@@ -2159,7 +2162,7 @@ static int sv_body(int s, int stype, unsigned char *context)
 
             if (i &lt;= 0)
                 continue;
-            if (FD_ISSET(fileno(stdin), &amp;readfds))
+            if (FD_ISSET(fileno_stdin(), &amp;readfds))
                 read_from_terminal = 1;
 #endif
             if (FD_ISSET(s, &amp;readfds))
@@ -2186,6 +2189,7 @@ static int sv_body(int s, int stype, unsigned char *context)
                 assert(lf_num == 0);
             } else
                 i = raw_read_stdin(buf, bufsize);
+
             if (!s_quiet &amp;&amp; !s_brief) {
                 if ((i &lt;= 0) || (buf[0] == 'Q')) {
                     BIO_printf(bio_s_out, &quot;DONE\n&quot;);
diff --git a/apps/vms_term_sock.c b/apps/vms_term_sock.c
new file mode 100644
index 0000000..a7d87ff
--- /dev/null
+++ b/apps/vms_term_sock.c
@@ -0,0 +1,590 @@
+/*
+ * Copyright 2016 VMS Software, Inc. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifdef __VMS
+# define OPENSSL_SYS_VMS
+# pragma message disable DOLLARID
+
+
+# include &lt;openssl/opensslconf.h&gt;
+
+# if !defined(_POSIX_C_SOURCE) &amp;&amp; defined(OPENSSL_SYS_VMS)
+/*
+ * On VMS, you need to define this to get the declaration of fileno().  The
+ * value 2 is to make sure no function defined in POSIX-2 is left undefined.
+ */
+#  define _POSIX_C_SOURCE 2
+# endif
+
+# include &lt;stdio.h&gt;
+
+# undef _POSIX_C_SOURCE
+
+# include &lt;sys/types.h&gt;
+# include &lt;sys/socket.h&gt;
+# include &lt;netinet/in.h&gt;
+# include &lt;inet.h&gt;
+# include &lt;unistd.h&gt;
+# include &lt;string.h&gt;
+# include &lt;errno.h&gt;
+# include &lt;starlet.h&gt;
+# include &lt;iodef.h&gt;
+# ifdef __alpha
+#  include &lt;iosbdef.h&gt;
+# else
+typedef struct _iosb {           /* Copied from IOSBDEF.H for Alpha  */
+#  pragma __nomember_alignment
+    __union  {
+        __struct  {
+            unsigned short int iosb$w_status; /* Final I/O status           */
+            __union  {
+                __struct  {             /* 16-bit byte count variant        */
+                    unsigned short int iosb$w_bcnt; /* 16-bit byte count    */
+                    __union  {
+                        unsigned int iosb$l_dev_depend; /* 32-bit device dependent info */
+                        unsigned int iosb$l_pid; /* 32-bit pid              */
+                    } iosb$r_l;
+                } iosb$r_bcnt_16;
+                __struct  {             /* 32-bit byte count variant        */
+                    unsigned int iosb$l_bcnt; /* 32-bit byte count (unaligned) */
+                    unsigned short int iosb$w_dev_depend_high; /* 16-bit device dependent info */
+                } iosb$r_bcnt_32;
+            } iosb$r_devdepend;
+        } iosb$r_io_64;
+        __struct  {
+            __union  {
+                unsigned int iosb$l_getxxi_status; /* Final GETxxI status   */
+                unsigned int iosb$l_reg_status; /* Final $Registry status   */
+            } iosb$r_l_status;
+            unsigned int iosb$l_reserved; /* Reserved field                 */
+        } iosb$r_get_64;
+    } iosb$r_io_get;
+} IOSB;
+
+#  if !defined(__VAXC)
+#   define iosb$w_status iosb$r_io_get.iosb$r_io_64.iosb$w_status
+#   define iosb$w_bcnt iosb$r_io_get.iosb$r_io_64.iosb$r_devdepend.iosb$r_bcnt_16.iosb$w_bcnt
+#   define iosb$r_l        iosb$r_io_get.iosb$r_io_64.iosb$r_devdepend.iosb$r_bcnt_16.iosb$r_l
+#   define iosb$l_dev_depend iosb$r_l.iosb$l_dev_depend
+#   define iosb$l_pid iosb$r_l.iosb$l_pid
+#   define iosb$l_bcnt iosb$r_io_get.iosb$r_io_64.iosb$r_devdepend.iosb$r_bcnt_32.iosb$l_bcnt
+#   define iosb$w_dev_depend_high iosb$r_io_get.iosb$r_io_64.iosb$r_devdepend.iosb$r_bcnt_32.iosb$w_dev_depend_high
+#   define iosb$l_getxxi_status iosb$r_io_get.iosb$r_get_64.iosb$r_l_status.iosb$l_getxxi_status
+#   define iosb$l_reg_status iosb$r_io_get.iosb$r_get_64.iosb$r_l_status.iosb$l_reg_status
+#  endif          /* #if !defined(__VAXC) */
+
+# endif  /* End of IOSBDEF */
+
+# include &lt;efndef.h&gt;
+# include &lt;stdlib.h&gt;
+# include &lt;ssdef.h&gt;
+# include &lt;time.h&gt;
+# include &lt;stdarg.h&gt;
+# include &lt;descrip.h&gt;
+
+# include &quot;vms_term_sock.h&quot;
+
+# ifdef __alpha
+static struct _iosb TerminalDeviceIosb;
+# else
+IOSB TerminalDeviceIosb;
+# endif
+
+static char TerminalDeviceBuff[255 + 2];
+static int TerminalSocketPair[2] = {0, 0};
+static unsigned short TerminalDeviceChan = 0;
+
+static int CreateSocketPair (int, int, int, int *);
+static void SocketPairTimeoutAst (int);
+static int TerminalDeviceAst (int);
+static void LogMessage (char *, ...);
+
+/*
+** Socket Pair Timeout Value (must be 0-59 seconds)
+*/
+# define SOCKET_PAIR_TIMEOUT_VALUE 20
+
+/*
+** Socket Pair Timeout Block which is passed to timeout AST
+*/
+typedef struct _SocketPairTimeoutBlock {
+    unsigned short SockChan1;
+    unsigned short SockChan2;
+} SPTB;
+
+# ifdef TERM_SOCK_TEST
+

+/*----------------------------------------------------------------------------*/
+/*                                                                            */
+/*----------------------------------------------------------------------------*/
+int main (int argc, char *argv[], char *envp[])
+{
+    char TermBuff[80];
+    int TermSock,
+        status,
+        len;
+
+    LogMessage (&quot;Enter 'q' or 'Q' to quit ...&quot;);
+    while (strcasecmp (TermBuff, &quot;Q&quot;)) {
+        /*
+        ** Create the terminal socket
+        */
+        status = TerminalSocket (TERM_SOCK_CREATE, &amp;TermSock);
+        if (status != TERM_SOCK_SUCCESS)
+            exit (1);
+
+        /*
+        ** Process the terminal input
+        */
+        LogMessage (&quot;Waiting on terminal I/O ...\n&quot;);
+        len = recv (TermSock, TermBuff, sizeof (TermBuff), 0) ;
+        TermBuff[len] = '\0';
+        LogMessage (&quot;Received terminal I/O [%s]&quot;, TermBuff);
+
+        /*
+        ** Delete the terminal socket
+        */
+        status = TerminalSocket (TERM_SOCK_DELETE, &amp;TermSock);
+        if (status != TERM_SOCK_SUCCESS)
+            exit (1);
+    }
+
+    return 1;
+
+}
+# endif
+

+/*----------------------------------------------------------------------------*/
+/*                                                                            */
+/*----------------------------------------------------------------------------*/
+int TerminalSocket (int FunctionCode, int *ReturnSocket)
+{
+    int status;
+    $DESCRIPTOR (TerminalDeviceDesc, &quot;SYS$COMMAND&quot;);
+
+    /*
+    ** Process the requested function code
+    */
+    switch (FunctionCode) {
+    case TERM_SOCK_CREATE:
+        /*
+        ** Create a socket pair
+        */
+        status = CreateSocketPair (AF_INET, SOCK_STREAM, 0, TerminalSocketPair);
+        if (status == -1) {
+            LogMessage (&quot;TerminalSocket: CreateSocketPair () - %08X&quot;, status);
+            if (TerminalSocketPair[0])
+                close (TerminalSocketPair[0]);
+            if (TerminalSocketPair[1])
+                close (TerminalSocketPair[1]);
+            return (TERM_SOCK_FAILURE);
+        }
+
+        /*
+        ** Assign a channel to the terminal device
+        */
+        status = sys$assign (&amp;TerminalDeviceDesc,
+                             &amp;TerminalDeviceChan,
+                             0, 0, 0);
+        if (! (status &amp; 1)) {
+            LogMessage (&quot;TerminalSocket: SYS$ASSIGN () - %08X&quot;, status);
+            close (TerminalSocketPair[0]);
+            close (TerminalSocketPair[1]);
+            return (TERM_SOCK_FAILURE);
+        }
+
+        /*
+        ** Queue an async IO to the terminal device
+        */
+        status = sys$qio (EFN$C_ENF,
+                          TerminalDeviceChan,
+                          IO$_READVBLK,
+                          &amp;TerminalDeviceIosb,
+                          TerminalDeviceAst,
+                          0,
+                          TerminalDeviceBuff,
+                          sizeof (TerminalDeviceBuff) - 2,
+                          0, 0, 0, 0);
+        if (! (status &amp; 1)) {
+            LogMessage (&quot;TerminalSocket: SYS$QIO () - %08X&quot;, status);
+            close (TerminalSocketPair[0]);
+            close (TerminalSocketPair[1]);
+            return (TERM_SOCK_FAILURE);
+        }
+
+        /*
+        ** Return the input side of the socket pair
+        */
+        *ReturnSocket = TerminalSocketPair[1];
+        break;
+
+    case TERM_SOCK_DELETE:
+        /*
+        ** Cancel any pending IO on the terminal channel
+        */
+        status = sys$cancel (TerminalDeviceChan);
+        if (! (status &amp; 1)) {
+            LogMessage (&quot;TerminalSocket: SYS$CANCEL () - %08X&quot;, status);
+            close (TerminalSocketPair[0]);
+            close (TerminalSocketPair[1]);
+            return (TERM_SOCK_FAILURE);
+        }
+
+        /*
+	** Deassign the terminal channel
+	*/
+        status = sys$dassgn (TerminalDeviceChan);
+        if (! (status &amp; 1)) {
+            LogMessage (&quot;TerminalSocket: SYS$DASSGN () - %08X&quot;, status);
+            close (TerminalSocketPair[0]);
+            close (TerminalSocketPair[1]);
+            return (TERM_SOCK_FAILURE);
+        }
+
+        /*
+        ** Close the terminal socket pair
+        */
+        close (TerminalSocketPair[0]);
+        close (TerminalSocketPair[1]);
+
+        /*
+	** Return the initialized socket
+	*/
+        *ReturnSocket = 0;
+        break;
+
+    default:
+        /*
+	** Invalid function code
+	*/
+        LogMessage (&quot;TerminalSocket: Invalid Function Code - %d&quot;, FunctionCode);
+        return (TERM_SOCK_FAILURE);
+        break;
+    }
+
+    /*
+    ** Return success
+    */
+    return (TERM_SOCK_SUCCESS);
+
+}
+

+/*----------------------------------------------------------------------------*/
+/*                                                                            */
+/*----------------------------------------------------------------------------*/
+static int CreateSocketPair (int SocketFamily,
+                             int SocketType,
+                             int SocketProtocol,
+                             int *SocketPair)
+{
+    struct dsc$descriptor AscTimeDesc = {0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL};
+    static const char* LocalHostAddr = {&quot;127.0.0.1&quot;};
+    unsigned short TcpAcceptChan = 0,
+        TcpDeviceChan = 0;
+    unsigned long BinTimeBuff[2];
+    struct sockaddr_in sin;
+    char AscTimeBuff[32];
+    short LocalHostPort;
+    int status;
+    unsigned int slen;
+
+# ifdef __alpha
+    struct _iosb iosb;
+# else
+    IOSB iosb;
+# endif
+
+    int SockDesc1 = 0,
+        SockDesc2 = 0;
+    SPTB sptb;
+    $DESCRIPTOR (TcpDeviceDesc, &quot;TCPIP$DEVICE&quot;);
+
+    /*
+    ** Create a socket
+    */
+    SockDesc1 = socket (SocketFamily, SocketType, 0);
+    if (SockDesc1 &lt; 0) {
+        LogMessage (&quot;CreateSocketPair: socket () - %d&quot;, errno);
+        return (-1);
+    }
+
+    /*
+    ** Initialize the socket information
+    */
+    slen = sizeof (sin);
+    memset ((char *) &amp;sin, 0, slen);
+    sin.sin_family = SocketFamily;
+    sin.sin_addr.s_addr = inet_addr (LocalHostAddr);
+    sin.sin_port = 0;
+
+    /*
+    ** Bind the socket to the local IP
+    */
+    status = bind (SockDesc1, (struct sockaddr *) &amp;sin, slen);
+    if (status &lt; 0) {
+        LogMessage (&quot;CreateSocketPair: bind () - %d&quot;, errno);
+        close (SockDesc1);
+        return (-1);
+    }
+
+    /*
+    ** Get the socket name so we can save the port number
+    */
+    status = getsockname (SockDesc1, (struct sockaddr *) &amp;sin, &amp;slen);
+    if (status &lt; 0) {
+        LogMessage (&quot;CreateSocketPair: getsockname () - %d&quot;, errno);
+        close (SockDesc1);
+        return (-1);
+    } else
+        LocalHostPort = sin.sin_port;
+
+    /*
+    ** Setup a listen for the socket
+    */
+    listen (SockDesc1, 5);
+
+    /*
+    ** Get the binary (64-bit) time of the specified timeout value
+    */
+    sprintf (AscTimeBuff, &quot;0 0:0:%02d.00&quot;, SOCKET_PAIR_TIMEOUT_VALUE);
+    AscTimeDesc.dsc$w_length = strlen (AscTimeBuff);
+    AscTimeDesc.dsc$a_pointer = AscTimeBuff;
+    status = sys$bintim (&amp;AscTimeDesc, BinTimeBuff);
+    if (! (status &amp; 1)) {
+        LogMessage (&quot;CreateSocketPair: SYS$BINTIM () - %08X&quot;, status);
+        close (SockDesc1);
+        return (-1);
+    }
+
+    /*
+    ** Assign another channel to the TCP/IP device for the accept.
+    ** This is the channel that ends up being connected to.
+    */
+    status = sys$assign (&amp;TcpDeviceDesc, &amp;TcpDeviceChan, 0, 0, 0);
+    if (! (status &amp; 1)) {
+        LogMessage (&quot;CreateSocketPair: SYS$ASSIGN () - %08X&quot;, status);
+        close (SockDesc1);
+        return (-1);
+    }
+
+    /*
+    ** Get the channel of the first socket for the accept
+    */
+    TcpAcceptChan = decc$get_sdc (SockDesc1);
+
+    /*
+    ** Perform the accept using $QIO so we can do this asynchronously
+    */
+    status = sys$qio (EFN$C_ENF,
+                      TcpAcceptChan,
+                      IO$_ACCESS | IO$M_ACCEPT,
+                      &amp;iosb,
+                      0, 0, 0, 0, 0,
+                      &amp;TcpDeviceChan,
+                      0, 0);
+    if (! (status &amp; 1)) {
+        LogMessage (&quot;CreateSocketPair: SYS$QIO () - %08X&quot;, status);
+        close (SockDesc1);
+        sys$dassgn (TcpDeviceChan);
+        return (-1);
+    }
+
+    /*
+    ** Create the second socket to do the connect
+    */
+    SockDesc2 = socket (SocketFamily, SocketType, 0);
+    if (SockDesc2 &lt; 0) {
+        LogMessage (&quot;CreateSocketPair: socket () - %d&quot;, errno);
+        sys$cancel (TcpAcceptChan);
+        close (SockDesc1);
+        sys$dassgn (TcpDeviceChan);
+        return (-1) ;
+    }
+
+    /*
+    ** Setup the Socket Pair Timeout Block
+    */
+    sptb.SockChan1 = TcpAcceptChan;
+    sptb.SockChan2 = decc$get_sdc (SockDesc2);
+
+    /*
+    ** Before we block on the connect, set a timer that can cancel I/O on our
+    ** two sockets if it never connects.
+    */
+    status = sys$setimr (EFN$C_ENF,
+                         BinTimeBuff,
+                         SocketPairTimeoutAst,
+                         &amp;sptb,
+                         0);
+    if (! (status &amp; 1)) {
+        LogMessage (&quot;CreateSocketPair: SYS$SETIMR () - %08X&quot;, status);
+        sys$cancel (TcpAcceptChan);
+        close (SockDesc1);
+        close (SockDesc2);
+        sys$dassgn (TcpDeviceChan);
+        return (-1);
+    }
+
+    /*
+    ** Now issue the connect
+    */
+    memset ((char *) &amp;sin, 0, sizeof (sin)) ;
+    sin.sin_family = SocketFamily;
+    sin.sin_addr.s_addr = inet_addr (LocalHostAddr) ;
+    sin.sin_port = LocalHostPort ;
+
+    status = connect (SockDesc2, (struct sockaddr *) &amp;sin, sizeof (sin));
+    if (status &lt; 0 ) {
+        LogMessage (&quot;CreateSocketPair: connect () - %d&quot;, errno);
+        sys$cantim (&amp;sptb, 0);
+        sys$cancel (TcpAcceptChan);
+        close (SockDesc1);
+        close (SockDesc2);
+        sys$dassgn (TcpDeviceChan);
+        return (-1);
+    }
+
+    /*
+    ** Wait for the asynch $QIO to finish.  Note that if the I/O was aborted
+    ** (SS$_ABORT), then we probably canceled it from the AST routine - so log
+    ** a timeout.
+    */
+    status = sys$synch (EFN$C_ENF, &amp;iosb);
+    if (! (iosb.iosb$w_status &amp; 1)) {
+        if (iosb.iosb$w_status == SS$_ABORT)
+            LogMessage (&quot;CreateSocketPair: SYS$QIO(iosb) timeout&quot;);
+        else {
+            LogMessage (&quot;CreateSocketPair: SYS$QIO(iosb) - %d&quot;,
+                        iosb.iosb$w_status);
+            sys$cantim (&amp;sptb, 0);
+        }
+        close (SockDesc1);
+        close (SockDesc2);
+        sys$dassgn (TcpDeviceChan);
+        return (-1);
+    }
+
+    /*
+    ** Here we're successfully connected, so cancel the timer, convert the
+    ** I/O channel to a socket fd, close the listener socket and return the
+    ** connected pair.
+    */
+    sys$cantim (&amp;sptb, 0);
+
+    close (SockDesc1) ;
+    SocketPair[0] = SockDesc2 ;
+    SocketPair[1] = socket_fd (TcpDeviceChan);
+
+    return (0) ;
+
+}
+

+/*----------------------------------------------------------------------------*/
+/*                                                                            */
+/*----------------------------------------------------------------------------*/
+static void SocketPairTimeoutAst (int astparm)
+{
+    SPTB *sptb = (SPTB *) astparm;
+
+    sys$cancel (sptb-&gt;SockChan2); /* Cancel the connect() */
+    sys$cancel (sptb-&gt;SockChan1); /* Cancel the accept() */
+
+    return;
+
+}
+

+/*----------------------------------------------------------------------------*/
+/*                                                                            */
+/*----------------------------------------------------------------------------*/
+static int TerminalDeviceAst (int astparm)
+{
+    int status;
+
+    /*
+    ** Terminate the terminal buffer
+    */
+    TerminalDeviceBuff[TerminalDeviceIosb.iosb$w_bcnt] = '\0';
+    strcat (TerminalDeviceBuff, &quot;\n&quot;);
+
+    /*
+    ** Send the data read from the terminal device throught the socket pair
+    */
+    send (TerminalSocketPair[0], TerminalDeviceBuff,
+          TerminalDeviceIosb.iosb$w_bcnt + 1, 0);
+
+    /*
+    ** Queue another async IO to the terminal device
+    */
+    status = sys$qio (EFN$C_ENF,
+                      TerminalDeviceChan,
+                      IO$_READVBLK,
+                      &amp;TerminalDeviceIosb,
+                      TerminalDeviceAst,
+                      0,
+                      TerminalDeviceBuff,
+                      sizeof (TerminalDeviceBuff) - 1,
+                      0, 0, 0, 0);
+
+    /*
+    ** Return status
+    */
+    return status;
+
+}
+

+/*----------------------------------------------------------------------------*/
+/*                                                                            */
+/*----------------------------------------------------------------------------*/
+static void LogMessage (char *msg, ...)
+{
+    char *Month[] = {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,
+                     &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;};
+    static unsigned int pid = 0;
+    va_list args;
+    time_t CurTime;
+    struct tm *LocTime;
+    char MsgBuff[256];
+
+    /*
+    ** Get the process pid
+    */
+    if (pid == 0)
+        pid = getpid ();
+
+    /*
+    ** Convert the current time into local time
+    */
+    CurTime = time (NULL);
+    LocTime = localtime (&amp;CurTime);
+
+    /*
+    ** Format the message buffer
+    */
+    sprintf (MsgBuff, &quot;%02d-%s-%04d %02d:%02d:%02d [%08X] %s\n&quot;,
+             LocTime-&gt;tm_mday, Month[LocTime-&gt;tm_mon],
+             (LocTime-&gt;tm_year + 1900), LocTime-&gt;tm_hour, LocTime-&gt;tm_min,
+             LocTime-&gt;tm_sec, pid, msg);
+
+    /*
+    ** Get any variable arguments and add them to the print of the message
+    ** buffer
+    */
+    va_start (args, msg);
+    vfprintf (stderr, MsgBuff, args);
+    va_end (args);
+
+    /*
+    ** Flush standard error output
+    */
+    fsync (fileno (stderr));
+
+    return;
+
+}
+#endif
diff --git a/apps/vms_term_sock.h b/apps/vms_term_sock.h
new file mode 100644
index 0000000..662fa0a
--- /dev/null
+++ b/apps/vms_term_sock.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 VMS Software, Inc. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the &quot;License&quot;).  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * <A HREF="https://www.openssl.org/source/license.html">https://www.openssl.org/source/license.html</A>
+ */
+
+#ifndef TERM_SOCK_H
+# define TERM_SOCK_H
+
+/*
+** Terminal Socket Function Codes
+*/
+# define TERM_SOCK_CREATE       1
+# define TERM_SOCK_DELETE       2
+
+/*
+** Terminal Socket Status Codes
+*/
+# define TERM_SOCK_FAILURE      0
+# define TERM_SOCK_SUCCESS      1
+
+/*
+** Terminal Socket Prototype
+*/
+int TerminalSocket (int FunctionCode, int *ReturnSocket);
+
+#endif
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010496.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="010519.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10515">[ date ]</a>
              <a href="thread.html#10515">[ thread ]</a>
              <a href="subject.html#10515">[ subject ]</a>
              <a href="author.html#10515">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
