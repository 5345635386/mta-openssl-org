<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2016-January/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1452535063.462569.10842.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002777.html">
   <LINK REL="Next"  HREF="002782.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Dr. Stephen Henson</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1452535063.462569.10842.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">steve at openssl.org
       </A><BR>
    <I>Mon Jan 11 17:57:43 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="002777.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="002782.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2778">[ date ]</a>
              <a href="thread.html#2778">[ thread ]</a>
              <a href="subject.html#2778">[ subject ]</a>
              <a href="author.html#2778">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  abf81f1f2ec94efcf39df2f5d0773bf8824e03c6 (commit)
       via  89d6aa10a24c0d5195e5a4c21f99919c53fe69ac (commit)
       via  26a884c217b4868ddc7cd2c2006e12a6bd6a7950 (commit)
       via  2a056de832a62f9c6da67779f3764f004df6fdb0 (commit)
       via  63c75cd688352b83afd7f874b89139e282647046 (commit)
       via  62d0577e0d5e3703436d0fba362d516481291810 (commit)
       via  e6b5c341b94d357b0158ad74b12edd51399a4b87 (commit)
      from  8e423bde2561bcddbc1d67f1fcc182d7dfa3f04d (commit)


- Log -----------------------------------------------------------------
commit abf81f1f2ec94efcf39df2f5d0773bf8824e03c6
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Mon Jan 11 15:36:54 2016 +0000

    update ordinals
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 89d6aa10a24c0d5195e5a4c21f99919c53fe69ac
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Mon Jan 11 15:22:30 2016 +0000

    Use ossl_inline and DEFINE_LHASH_OF
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 26a884c217b4868ddc7cd2c2006e12a6bd6a7950
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Thu Dec 24 16:24:15 2015 +0000

    Remove mkstack.pl: it is no longer needed.
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 2a056de832a62f9c6da67779f3764f004df6fdb0
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Thu Dec 24 16:20:54 2015 +0000

    Add lh_doall_arg inlining
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 63c75cd688352b83afd7f874b89139e282647046
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Thu Dec 24 16:07:21 2015 +0000

    Add lh_doall inlining
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit 62d0577e0d5e3703436d0fba362d516481291810
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Thu Dec 24 15:51:23 2015 +0000

    Add lh_new() inlining
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

commit e6b5c341b94d357b0158ad74b12edd51399a4b87
Author: Dr. Stephen Henson &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">steve at openssl.org</A>&gt;
Date:   Mon Jan 11 14:11:13 2016 +0000

    Inline LHASH_OF
    
    Make LHASH_OF use static inline functions.
    
    Add new lh_get_down_load and lh_set_down_load functions and their
    typesafe inline equivalents.
    
    Make lh_error a function instead of a macro.
    
    Reviewed-by: Rich Salz &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">rsalz at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 Makefile.org                       |   5 +-
 apps/openssl.c                     |   7 +-
 apps/progs.h                       |   2 +
 apps/progs.pl                      |   2 +
 crypto/conf/conf_api.c             |  35 ++--
 crypto/conf/conf_def.c             |   7 +-
 crypto/engine/eng_int.h            |   4 +
 crypto/engine/eng_table.c          |  32 ++--
 crypto/err/Makefile                |   2 +-
 crypto/err/err.c                   |  22 +--
 crypto/err/err_lcl.h               |   2 +
 crypto/include/internal/cryptlib.h |   4 +
 crypto/lhash/lhash.c               |  15 ++
 crypto/mem_dbg.c                   |  40 ++---
 crypto/objects/Makefile            |   4 +-
 crypto/objects/o_names.c           |  46 ++----
 crypto/objects/o_names.h           |   4 -
 crypto/objects/obj_dat.c           |  24 +--
 crypto/objects/obj_lcl.h           |   7 +
 include/openssl/conf.h             |   2 +-
 include/openssl/err.h              |   2 +
 include/openssl/lhash.h            | 118 +++++++++-----
 include/openssl/safestack.h        | 227 --------------------------
 ssl/ssl_lib.c                      |   4 +-
 ssl/ssl_locl.h                     |   2 +-
 ssl/ssl_sess.c                     |   7 +-
 util/libeay.num                    |   3 +
 util/mkstack.pl                    | 316 -------------------------------------
 28 files changed, 202 insertions(+), 743 deletions(-)
 create mode 100644 crypto/err/err_lcl.h
 delete mode 100644 crypto/objects/o_names.h
 create mode 100644 crypto/objects/obj_lcl.h
 delete mode 100755 util/mkstack.pl

diff --git a/Makefile.org b/Makefile.org
index b45862e..1fe7bfd 100644
--- a/Makefile.org
+++ b/Makefile.org
@@ -455,7 +455,7 @@ list-tests:
 report:
 	@$(PERL) util/selftest.pl
 
-update: errors stacks util/libeay.num util/ssleay.num TABLE test_ordinals
+update: errors util/libeay.num util/ssleay.num TABLE test_ordinals
 	@set -e; target=update; $(RECURSIVE_BUILD_CMD)
 
 depend:
@@ -477,9 +477,6 @@ errors:
 	(cd engines; $(MAKE) PERL=$(PERL) errors)
 	(cd crypto/ct; $(MAKE) PERL=$(PERL) errors)
 
-stacks:
-	$(PERL) util/mkstack.pl -write
-
 util/libeay.num::
 	$(PERL) util/mkdef.pl crypto update
 
diff --git a/apps/openssl.c b/apps/openssl.c
index 411fe69..6bd14ff 100644
--- a/apps/openssl.c
+++ b/apps/openssl.c
@@ -153,7 +153,6 @@
  * required type of &quot;FUNCTION*&quot;). This removes the necessity for
  * macro-generated wrapper functions.
  */
-DECLARE_LHASH_OF(FUNCTION);
 static LHASH_OF(FUNCTION) *prog_init(void);
 static int do_cmd(LHASH_OF(FUNCTION) *prog, int argc, char *argv[]);
 static void list_pkey(void);
@@ -701,15 +700,11 @@ static int function_cmp(const FUNCTION * a, const FUNCTION * b)
     return strncmp(a-&gt;name, b-&gt;name, 8);
 }
 
-static IMPLEMENT_LHASH_COMP_FN(function, FUNCTION)
-
 static unsigned long function_hash(const FUNCTION * a)
 {
     return lh_strhash(a-&gt;name);
 }
 
-static IMPLEMENT_LHASH_HASH_FN(function, FUNCTION)
-
 static int SortFnByName(const void *_f1, const void *_f2)
 {
     const FUNCTION *f1 = _f1;
@@ -861,7 +856,7 @@ static LHASH_OF(FUNCTION) *prog_init(void)
     for (i = 0, f = functions; f-&gt;name != NULL; ++f, ++i) ;
     qsort(functions, i, sizeof(*functions), SortFnByName);
 
-    if ((ret = lh_FUNCTION_new()) == NULL)
+    if ((ret = lh_FUNCTION_new(function_hash, function_cmp)) == NULL)
         return (NULL);
 
     for (f = functions; f-&gt;name != NULL; f++)
diff --git a/apps/progs.h b/apps/progs.h
index 4a59b64..f3eaf2a 100644
--- a/apps/progs.h
+++ b/apps/progs.h
@@ -16,6 +16,8 @@ typedef struct function_st {
     const OPTIONS *help;
 } FUNCTION;
 
+DEFINE_LHASH_OF(FUNCTION);
+
 extern int asn1parse_main(int argc, char *argv[]);
 extern int ca_main(int argc, char *argv[]);
 extern int ciphers_main(int argc, char *argv[]);
diff --git a/apps/progs.pl b/apps/progs.pl
index 065d954..4ffa1f1 100644
--- a/apps/progs.pl
+++ b/apps/progs.pl
@@ -20,6 +20,8 @@ typedef struct function_st {
     const OPTIONS *help;
 } FUNCTION;
 
+DEFINE_LHASH_OF(FUNCTION);
+
 EOF
 
 grep(s/\.o//, @ARGV);
diff --git a/crypto/conf/conf_api.c b/crypto/conf/conf_api.c
index 3badf7f..eeb2349 100644
--- a/crypto/conf/conf_api.c
+++ b/crypto/conf/conf_api.c
@@ -70,12 +70,8 @@
 #include &lt;openssl/conf_api.h&gt;
 #include &quot;e_os.h&quot;
 
-static void value_free_hash_doall_arg(CONF_VALUE *a,
-                                      LHASH_OF(CONF_VALUE) *conf);
+static void value_free_hash(const CONF_VALUE *a, LHASH_OF(CONF_VALUE) *conf);
 static void value_free_stack_doall(CONF_VALUE *a);
-static IMPLEMENT_LHASH_DOALL_ARG_FN(value_free_hash, CONF_VALUE,
-                                    LHASH_OF(CONF_VALUE))
-static IMPLEMENT_LHASH_DOALL_FN(value_free_stack, CONF_VALUE)
 
 /* Up until OpenSSL 0.9.5a, this was get_section */
 CONF_VALUE *_CONF_get_section(const CONF *conf, const char *section)
@@ -162,8 +158,6 @@ static unsigned long conf_value_hash(const CONF_VALUE *v)
     return (lh_strhash(v-&gt;section) &lt;&lt; 2) ^ lh_strhash(v-&gt;name);
 }
 
-static IMPLEMENT_LHASH_HASH_FN(conf_value, CONF_VALUE)
-
 static int conf_value_cmp(const CONF_VALUE *a, const CONF_VALUE *b)
 {
     int i;
@@ -183,43 +177,42 @@ static int conf_value_cmp(const CONF_VALUE *a, const CONF_VALUE *b)
         return ((a-&gt;name == NULL) ? -1 : 1);
 }
 
-static IMPLEMENT_LHASH_COMP_FN(conf_value, CONF_VALUE)
-
 int _CONF_new_data(CONF *conf)
 {
     if (conf == NULL) {
         return 0;
     }
-    if (conf-&gt;data == NULL)
-        if ((conf-&gt;data = lh_CONF_VALUE_new()) == NULL) {
+    if (conf-&gt;data == NULL) {
+        conf-&gt;data = lh_CONF_VALUE_new(conf_value_hash, conf_value_cmp);
+        if (conf-&gt;data == NULL)
             return 0;
-        }
+    }
     return 1;
 }
 
+typedef LHASH_OF(CONF_VALUE) LH_CONF_VALUE;
+
+IMPLEMENT_LHASH_DOALL_ARG_CONST(CONF_VALUE, LH_CONF_VALUE);
+
 void _CONF_free_data(CONF *conf)
 {
     if (conf == NULL || conf-&gt;data == NULL)
         return;
 
-    lh_CONF_VALUE_down_load(conf-&gt;data) = 0; /* evil thing to make * sure the
-                                              * 'OPENSSL_free()' works as *
-                                              * expected */
-    lh_CONF_VALUE_doall_arg(conf-&gt;data,
-                            LHASH_DOALL_ARG_FN(value_free_hash),
-                            LHASH_OF(CONF_VALUE), conf-&gt;data);
+    /* evil thing to make sure the 'OPENSSL_free()' works as expected */
+    lh_CONF_VALUE_set_down_load(conf-&gt;data, 0);
+    lh_CONF_VALUE_doall_LH_CONF_VALUE(conf-&gt;data, value_free_hash, conf-&gt;data);
 
     /*
      * We now have only 'section' entries in the hash table. Due to problems
      * with
      */
 
-    lh_CONF_VALUE_doall(conf-&gt;data, LHASH_DOALL_FN(value_free_stack));
+    lh_CONF_VALUE_doall(conf-&gt;data, value_free_stack_doall);
     lh_CONF_VALUE_free(conf-&gt;data);
 }
 
-static void value_free_hash_doall_arg(CONF_VALUE *a,
-                                      LHASH_OF(CONF_VALUE) *conf)
+static void value_free_hash(const CONF_VALUE *a, LHASH_OF(CONF_VALUE) *conf)
 {
     if (a-&gt;name != NULL)
         (void)lh_CONF_VALUE_delete(conf, a);
diff --git a/crypto/conf/conf_def.c b/crypto/conf/conf_def.c
index ac07405..5d929f1 100644
--- a/crypto/conf/conf_def.c
+++ b/crypto/conf/conf_def.c
@@ -652,7 +652,7 @@ static char *scan_dquote(CONF *conf, char *p)
     return (p);
 }
 
-static void dump_value_doall_arg(CONF_VALUE *a, BIO *out)
+static void dump_value_doall_arg(const CONF_VALUE *a, BIO *out)
 {
     if (a-&gt;name)
         BIO_printf(out, &quot;[%s] %s=%s\n&quot;, a-&gt;section, a-&gt;name, a-&gt;value);
@@ -660,12 +660,11 @@ static void dump_value_doall_arg(CONF_VALUE *a, BIO *out)
         BIO_printf(out, &quot;[[%s]]\n&quot;, a-&gt;section);
 }
 
-static IMPLEMENT_LHASH_DOALL_ARG_FN(dump_value, CONF_VALUE, BIO)
+IMPLEMENT_LHASH_DOALL_ARG_CONST(CONF_VALUE, BIO);
 
 static int def_dump(const CONF *conf, BIO *out)
 {
-    lh_CONF_VALUE_doall_arg(conf-&gt;data, LHASH_DOALL_ARG_FN(dump_value),
-                            BIO, out);
+    lh_CONF_VALUE_doall_BIO(conf-&gt;data, dump_value_doall_arg, out);
     return 1;
 }
 
diff --git a/crypto/engine/eng_int.h b/crypto/engine/eng_int.h
index 8f775f5..7062bda 100644
--- a/crypto/engine/eng_int.h
+++ b/crypto/engine/eng_int.h
@@ -216,6 +216,10 @@ struct engine_st {
     struct engine_st *next;
 };
 
+typedef struct st_engine_pile ENGINE_PILE;
+
+DEFINE_LHASH_OF(ENGINE_PILE);
+
 #ifdef  __cplusplus
 }
 #endif
diff --git a/crypto/engine/eng_table.c b/crypto/engine/eng_table.c
index 5fd00dd..2907d82 100644
--- a/crypto/engine/eng_table.c
+++ b/crypto/engine/eng_table.c
@@ -58,7 +58,7 @@
 #include &quot;eng_int.h&quot;
 
 /* The type of the items in the table */
-typedef struct st_engine_pile {
+struct st_engine_pile {
     /* The 'nid' of this algorithm/mode */
     int nid;
     /* ENGINEs that implement this algorithm/mode. */
@@ -69,9 +69,7 @@ typedef struct st_engine_pile {
      * Zero if 'sk' is newer than the cached 'funct', non-zero otherwise
      */
     int uptodate;
-} ENGINE_PILE;
-
-DECLARE_LHASH_OF(ENGINE_PILE);
+};
 
 /* The type exposed in eng_int.h */
 struct st_engine_table {
@@ -108,9 +106,6 @@ static int engine_pile_cmp(const ENGINE_PILE *a, const ENGINE_PILE *b)
     return a-&gt;nid - b-&gt;nid;
 }
 
-static IMPLEMENT_LHASH_HASH_FN(engine_pile, ENGINE_PILE)
-static IMPLEMENT_LHASH_COMP_FN(engine_pile, ENGINE_PILE)
-
 static int int_table_check(ENGINE_TABLE **t, int create)
 {
     LHASH_OF(ENGINE_PILE) *lh;
@@ -119,7 +114,7 @@ static int int_table_check(ENGINE_TABLE **t, int create)
         return 1;
     if (!create)
         return 0;
-    if ((lh = lh_ENGINE_PILE_new()) == NULL)
+    if ((lh = lh_ENGINE_PILE_new(engine_pile_hash, engine_pile_cmp)) == NULL)
         return 0;
     *t = (ENGINE_TABLE *)lh;
     return 1;
@@ -188,7 +183,7 @@ int engine_table_register(ENGINE_TABLE **table, ENGINE_CLEANUP_CB *cleanup,
     return ret;
 }
 
-static void int_unregister_cb_doall_arg(ENGINE_PILE *pile, ENGINE *e)
+static void int_unregister_cb(ENGINE_PILE *pile, ENGINE *e)
 {
     int n;
     /* Iterate the 'c-&gt;sk' stack removing any occurrence of 'e' */
@@ -202,15 +197,13 @@ static void int_unregister_cb_doall_arg(ENGINE_PILE *pile, ENGINE *e)
     }
 }
 
-static IMPLEMENT_LHASH_DOALL_ARG_FN(int_unregister_cb, ENGINE_PILE, ENGINE)
+IMPLEMENT_LHASH_DOALL_ARG(ENGINE_PILE, ENGINE);
 
 void engine_table_unregister(ENGINE_TABLE **table, ENGINE *e)
 {
     CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
     if (int_table_check(table, 0))
-        lh_ENGINE_PILE_doall_arg(&amp;(*table)-&gt;piles,
-                                 LHASH_DOALL_ARG_FN(int_unregister_cb),
-                                 ENGINE, e);
+        lh_ENGINE_PILE_doall_ENGINE(&amp;(*table)-&gt;piles, int_unregister_cb, e);
     CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
 }
 
@@ -224,14 +217,11 @@ static void int_cleanup_cb_doall(ENGINE_PILE *p)
     OPENSSL_free(p);
 }
 
-static IMPLEMENT_LHASH_DOALL_FN(int_cleanup_cb, ENGINE_PILE)
-
 void engine_table_cleanup(ENGINE_TABLE **table)
 {
     CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
     if (*table) {
-        lh_ENGINE_PILE_doall(&amp;(*table)-&gt;piles,
-                             LHASH_DOALL_FN(int_cleanup_cb));
+        lh_ENGINE_PILE_doall(&amp;(*table)-&gt;piles, int_cleanup_cb_doall);
         lh_ENGINE_PILE_free(&amp;(*table)-&gt;piles);
         *table = NULL;
     }
@@ -340,12 +330,12 @@ ENGINE *engine_table_select_tmp(ENGINE_TABLE **table, int nid, const char *f,
 
 /* Table enumeration */
 
-static void int_cb_doall_arg(ENGINE_PILE *pile, ENGINE_PILE_DOALL *dall)
+static void int_dall(const ENGINE_PILE *pile, ENGINE_PILE_DOALL *dall)
 {
     dall-&gt;cb(pile-&gt;nid, pile-&gt;sk, pile-&gt;funct, dall-&gt;arg);
 }
 
-static IMPLEMENT_LHASH_DOALL_ARG_FN(int_cb, ENGINE_PILE, ENGINE_PILE_DOALL)
+IMPLEMENT_LHASH_DOALL_ARG_CONST(ENGINE_PILE, ENGINE_PILE_DOALL);
 
 void engine_table_doall(ENGINE_TABLE *table, engine_table_doall_cb *cb,
                         void *arg)
@@ -354,7 +344,5 @@ void engine_table_doall(ENGINE_TABLE *table, engine_table_doall_cb *cb,
     dall.cb = cb;
     dall.arg = arg;
     if (table)
-        lh_ENGINE_PILE_doall_arg(&amp;table-&gt;piles,
-                                 LHASH_DOALL_ARG_FN(int_cb),
-                                 ENGINE_PILE_DOALL, &amp;dall);
+        lh_ENGINE_PILE_doall_ENGINE_PILE_DOALL(&amp;table-&gt;piles, int_dall, &amp;dall);
 }
diff --git a/crypto/err/Makefile b/crypto/err/Makefile
index a49e37b..4db677d 100644
--- a/crypto/err/Makefile
+++ b/crypto/err/Makefile
@@ -20,7 +20,7 @@ LIBOBJ=err.o err_all.o err_prn.o
 
 SRC= $(LIBSRC)
 
-HEADER=	
+HEADER=	err_lcl.h
 
 ALL=    $(GENERAL) $(SRC) $(HEADER)
 
diff --git a/crypto/err/err.c b/crypto/err/err.c
index 77e8223..c78e810 100644
--- a/crypto/err/err.c
+++ b/crypto/err/err.c
@@ -119,9 +119,7 @@
 #include &lt;openssl/bio.h&gt;
 #include &lt;openssl/err.h&gt;
 #include &lt;openssl/opensslconf.h&gt;
-
-DECLARE_LHASH_OF(ERR_STRING_DATA);
-DECLARE_LHASH_OF(ERR_STATE);
+#include &quot;err_lcl.h&quot;
 
 static void err_load_strings(int lib, ERR_STRING_DATA *str);
 
@@ -242,11 +240,6 @@ static LHASH_OF(ERR_STATE) *int_thread_hash = NULL;
 static int int_thread_hash_references = 0;
 static int int_err_library_number = ERR_LIB_USER;
 
-/*
- * These are the callbacks provided to &quot;lh_new()&quot; when creating the LHASH
- * tables internal to the &quot;err_defaults&quot; implementation.
- */
-
 static unsigned long get_error_values(int inc, int top, const char **file,
                                       int *line, const char **data,
                                       int *flags);
@@ -260,16 +253,12 @@ static unsigned long err_string_data_hash(const ERR_STRING_DATA *a)
     return (ret ^ ret % 19 * 13);
 }
 
-static IMPLEMENT_LHASH_HASH_FN(err_string_data, ERR_STRING_DATA)
-
 static int err_string_data_cmp(const ERR_STRING_DATA *a,
                                const ERR_STRING_DATA *b)
 {
     return (int)(a-&gt;error - b-&gt;error);
 }
 
-static IMPLEMENT_LHASH_COMP_FN(err_string_data, ERR_STRING_DATA)
-
 static LHASH_OF(ERR_STRING_DATA) *get_hash(int create, int lockit)
 {
     LHASH_OF(ERR_STRING_DATA) *ret = NULL;
@@ -277,7 +266,8 @@ static LHASH_OF(ERR_STRING_DATA) *get_hash(int create, int lockit)
     if (lockit)
         CRYPTO_w_lock(CRYPTO_LOCK_ERR);
     if (!int_error_hash &amp;&amp; create) {
-        int_error_hash = lh_ERR_STRING_DATA_new();
+        int_error_hash = lh_ERR_STRING_DATA_new(err_string_data_hash,
+                                                err_string_data_cmp);
     }
     if (int_error_hash != NULL)
         ret = int_error_hash;
@@ -306,15 +296,11 @@ static unsigned long err_state_hash(const ERR_STATE *a)
     return CRYPTO_THREADID_hash(&amp;a-&gt;tid) * 13;
 }
 
-static IMPLEMENT_LHASH_HASH_FN(err_state, ERR_STATE)
-
 static int err_state_cmp(const ERR_STATE *a, const ERR_STATE *b)
 {
     return CRYPTO_THREADID_cmp(&amp;a-&gt;tid, &amp;b-&gt;tid);
 }
 
-static IMPLEMENT_LHASH_COMP_FN(err_state, ERR_STATE)
-
 static LHASH_OF(ERR_STATE) *int_thread_get(int create, int lockit)
 {
     LHASH_OF(ERR_STATE) *ret = NULL;
@@ -322,7 +308,7 @@ static LHASH_OF(ERR_STATE) *int_thread_get(int create, int lockit)
     if (lockit)
         CRYPTO_w_lock(CRYPTO_LOCK_ERR);
     if (!int_thread_hash &amp;&amp; create) {
-        int_thread_hash = lh_ERR_STATE_new();
+        int_thread_hash = lh_ERR_STATE_new(err_state_hash, err_state_cmp);
     }
     if (int_thread_hash != NULL) {
         int_thread_hash_references++;
diff --git a/crypto/err/err_lcl.h b/crypto/err/err_lcl.h
new file mode 100644
index 0000000..c9d24f1
--- /dev/null
+++ b/crypto/err/err_lcl.h
@@ -0,0 +1,2 @@
+
+DEFINE_LHASH_OF(ERR_STATE);
diff --git a/crypto/include/internal/cryptlib.h b/crypto/include/internal/cryptlib.h
index 1265a04..45a4d7a 100644
--- a/crypto/include/internal/cryptlib.h
+++ b/crypto/include/internal/cryptlib.h
@@ -85,6 +85,10 @@ DEFINE_STACK_OF(EX_CALLBACK)
 
 DEFINE_STACK_OF(CRYPTO_dynlock)
 
+typedef struct app_mem_info_st APP_INFO;
+DEFINE_LHASH_OF(APP_INFO);
+typedef struct mem_st MEM;
+DEFINE_LHASH_OF(MEM);
 
 # ifndef OPENSSL_SYS_VMS
 #  define X509_CERT_AREA          OPENSSLDIR
diff --git a/crypto/lhash/lhash.c b/crypto/lhash/lhash.c
index 4018b60..4642bda 100644
--- a/crypto/lhash/lhash.c
+++ b/crypto/lhash/lhash.c
@@ -422,3 +422,18 @@ unsigned long lh_num_items(const _LHASH *lh)
 {
     return lh ? lh-&gt;num_items : 0;
 }
+
+unsigned long lh_get_down_load(const _LHASH *lh)
+{
+    return lh-&gt;down_load;
+}
+
+void lh_set_down_load(_LHASH *lh, unsigned long down_load)
+{
+    lh-&gt;down_load = down_load;
+}
+
+int lh_error(_LHASH *lh)
+{
+    return lh-&gt;error;
+}
diff --git a/crypto/mem_dbg.c b/crypto/mem_dbg.c
index 6e93c80..8580447 100644
--- a/crypto/mem_dbg.c
+++ b/crypto/mem_dbg.c
@@ -139,10 +139,6 @@ static int mh_mode = CRYPTO_MEM_CHECK_OFF;
 #ifndef OPENSSL_NO_CRYPTO_MDEBUG
 static unsigned long order = 0; /* number of memory requests */
 
-DECLARE_LHASH_OF(MEM);
-static LHASH_OF(MEM) *mh = NULL; /* hash-table of memory requests (address as
-                                  * key); access requires MALLOC2 lock */
-
 /*-
  * For application-defined information (static C-string `info')
  * to be displayed in memory leak list.
@@ -150,25 +146,24 @@ static LHASH_OF(MEM) *mh = NULL; /* hash-table of memory requests (address as
  *   OPENSSL_mem_debug_push(&quot;...&quot;)     to push an entry,
  *   OPENSSL_mem_debug_pop()     to pop an entry,
  */
-typedef struct app_mem_info_st {
+struct app_mem_info_st {
     CRYPTO_THREADID threadid;
     const char *file;
     int line;
     const char *info;
     struct app_mem_info_st *next; /* tail of thread's stack */
     int references;
-} APP_INFO;
+};
 
 /*
  * hash-table with those app_mem_info_st's that are at the
  * top of their thread's stack (with `thread' as key); access requires
  * MALLOC2 lock
  */
-DECLARE_LHASH_OF(APP_INFO);
 static LHASH_OF(APP_INFO) *amih = NULL;
 
 /* memory-block description */
-typedef struct mem_st {
+struct mem_st {
     void *addr;
     int num;
     const char *file;
@@ -181,7 +176,10 @@ typedef struct mem_st {
     void *array[30];
     size_t array_siz;
 #endif
-} MEM;
+};
+
+static LHASH_OF(MEM) *mh = NULL; /* hash-table of memory requests (address as
+                                  * key); access requires MALLOC2 lock */
 
 /* num_disable &gt; 0 iff mh_mode == CRYPTO_MEM_CHECK_ON (w/o ..._ENABLE) */
 static unsigned int num_disable = 0;
@@ -308,8 +306,6 @@ static int mem_cmp(const MEM *a, const MEM *b)
 #endif
 }
 
-static IMPLEMENT_LHASH_COMP_FN(mem, MEM)
-
 static unsigned long mem_hash(const MEM *a)
 {
     size_t ret;
@@ -320,17 +316,11 @@ static unsigned long mem_hash(const MEM *a)
     return (ret);
 }
 
-static IMPLEMENT_LHASH_HASH_FN(mem, MEM)
-
-/* static int app_info_cmp(APP_INFO *a, APP_INFO *b) */
-static int app_info_cmp(const void *a_void, const void *b_void)
+static int app_info_cmp(const APP_INFO *a, const APP_INFO *b)
 {
-    return CRYPTO_THREADID_cmp(&amp;((const APP_INFO *)a_void)-&gt;threadid,
-                               &amp;((const APP_INFO *)b_void)-&gt;threadid);
+    return CRYPTO_THREADID_cmp(&amp;a-&gt;threadid, &amp;b-&gt;threadid);
 }
 
-static IMPLEMENT_LHASH_COMP_FN(app_info, APP_INFO)
-
 static unsigned long app_info_hash(const APP_INFO *a)
 {
     unsigned long ret;
@@ -341,8 +331,6 @@ static unsigned long app_info_hash(const APP_INFO *a)
     return (ret);
 }
 
-static IMPLEMENT_LHASH_HASH_FN(app_info, APP_INFO)
-
 static APP_INFO *pop_info(void)
 {
     APP_INFO tmp;
@@ -379,7 +367,7 @@ int CRYPTO_mem_debug_push(const char *info, const char *file, int line)
         if ((ami = OPENSSL_malloc(sizeof(*ami))) == NULL)
             goto err;
         if (amih == NULL) {
-            if ((amih = lh_APP_INFO_new()) == NULL) {
+            if ((amih = lh_APP_INFO_new(app_info_hash, app_info_cmp)) == NULL) {
                 OPENSSL_free(ami);
                 goto err;
             }
@@ -437,7 +425,7 @@ void CRYPTO_mem_debug_malloc(void *addr, size_t num, int before_p,
                 return;
             }
             if (mh == NULL) {
-                if ((mh = lh_MEM_new()) == NULL) {
+                if ((mh = lh_MEM_new(mem_hash, mem_cmp)) == NULL) {
                     OPENSSL_free(addr);
                     OPENSSL_free(m);
                     addr = NULL;
@@ -556,7 +544,7 @@ typedef struct mem_leak_st {
     long bytes;
 } MEM_LEAK;
 
-static void print_leak_doall_arg(const MEM *m, MEM_LEAK *l)
+static void print_leak(const MEM *m, MEM_LEAK *l)
 {
     char buf[1024];
     char *bufp = buf;
@@ -641,7 +629,7 @@ static void print_leak_doall_arg(const MEM *m, MEM_LEAK *l)
 #endif
 }
 
-static IMPLEMENT_LHASH_DOALL_ARG_FN(print_leak, const MEM, MEM_LEAK)
+IMPLEMENT_LHASH_DOALL_ARG_CONST(MEM, MEM_LEAK);
 
 int CRYPTO_mem_leaks(BIO *b)
 {
@@ -657,7 +645,7 @@ int CRYPTO_mem_leaks(BIO *b)
     ml.chunks = 0;
     ml.seen = 0;
     if (mh != NULL)
-        lh_MEM_doall_arg(mh, LHASH_DOALL_ARG_FN(print_leak), MEM_LEAK, &amp;ml);
+        lh_MEM_doall_MEM_LEAK(mh, print_leak, &amp;ml);
     /* Don't count the BIO that was passed in as a &quot;leak&quot; */
     if (ml.seen &amp;&amp; ml.chunks &gt;= 1 &amp;&amp; ml.bytes &gt;= (int)sizeof (*b)) {
         ml.chunks--;
diff --git a/crypto/objects/Makefile b/crypto/objects/Makefile
index f413b0f..0cfaf5a 100644
--- a/crypto/objects/Makefile
+++ b/crypto/objects/Makefile
@@ -21,7 +21,7 @@ LIBOBJ= o_names.o obj_dat.o obj_lib.o obj_err.o obj_xref.o
 
 SRC= $(LIBSRC)
 
-HEADER=	obj_dat.h obj_xref.h o_names.h
+HEADER=	obj_dat.h obj_xref.h obj_lcl.h
 
 ALL=    $(GENERAL) $(SRC) $(HEADER)
 
@@ -80,7 +80,7 @@ o_names.o: ../../include/openssl/obj_mac.h ../../include/openssl/objects.h
 o_names.o: ../../include/openssl/opensslconf.h ../../include/openssl/opensslv.h
 o_names.o: ../../include/openssl/ossl_typ.h ../../include/openssl/safestack.h
 o_names.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-o_names.o: o_names.c o_names.h
+o_names.o: o_names.c obj_lcl.h
 obj_dat.o: ../../e_os.h ../../include/openssl/asn1.h
 obj_dat.o: ../../include/openssl/bio.h ../../include/openssl/bn.h
 obj_dat.o: ../../include/openssl/buffer.h ../../include/openssl/crypto.h
diff --git a/crypto/objects/o_names.c b/crypto/objects/o_names.c
index 476c377..6939b9a 100644
--- a/crypto/objects/o_names.c
+++ b/crypto/objects/o_names.c
@@ -7,7 +7,7 @@
 #include &lt;openssl/objects.h&gt;
 #include &lt;openssl/safestack.h&gt;
 #include &lt;openssl/e_os2.h&gt;
-#include &quot;o_names.h&quot;
+#include &quot;obj_lcl.h&quot;
 
 /*
  * Later versions of DEC C has started to add lnkage information to certain
@@ -25,7 +25,6 @@
  * I use the ex_data stuff to manage the identifiers for the obj_name_types
  * that applications may define.  I only really use the free function field.
  */
-DECLARE_LHASH_OF(OBJ_NAME);
 static LHASH_OF(OBJ_NAME) *names_lh = NULL;
 static int names_type_num = OBJ_NAME_TYPE_NUM;
 
@@ -43,20 +42,15 @@ static STACK_OF(NAME_FUNCS) *name_funcs_stack;
  * casting without the need for macro-generated wrapper functions.
  */
 
-/* static unsigned long obj_name_hash(OBJ_NAME *a); */
-static unsigned long obj_name_hash(const void *a_void);
-/* static int obj_name_cmp(OBJ_NAME *a,OBJ_NAME *b); */
-static int obj_name_cmp(const void *a_void, const void *b_void);
-
-static IMPLEMENT_LHASH_HASH_FN(obj_name, OBJ_NAME)
-static IMPLEMENT_LHASH_COMP_FN(obj_name, OBJ_NAME)
+static unsigned long obj_name_hash(const OBJ_NAME *a);
+static int obj_name_cmp(const OBJ_NAME *a, const OBJ_NAME *b);
 
 int OBJ_NAME_init(void)
 {
     if (names_lh != NULL)
         return (1);
     CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_DISABLE);
-    names_lh = lh_OBJ_NAME_new();
+    names_lh = lh_OBJ_NAME_new(obj_name_hash, obj_name_cmp);
     CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ENABLE);
     return (names_lh != NULL);
 }
@@ -104,12 +98,9 @@ int OBJ_NAME_new_index(unsigned long (*hash_func) (const char *),
     return (ret);
 }
 
-/* static int obj_name_cmp(OBJ_NAME *a, OBJ_NAME *b) */
-static int obj_name_cmp(const void *a_void, const void *b_void)
+static int obj_name_cmp(const OBJ_NAME *a, const OBJ_NAME *b)
 {
     int ret;
-    const OBJ_NAME *a = (const OBJ_NAME *)a_void;
-    const OBJ_NAME *b = (const OBJ_NAME *)b_void;
 
     ret = a-&gt;type - b-&gt;type;
     if (ret == 0) {
@@ -123,11 +114,9 @@ static int obj_name_cmp(const void *a_void, const void *b_void)
     return (ret);
 }
 
-/* static unsigned long obj_name_hash(OBJ_NAME *a) */
-static unsigned long obj_name_hash(const void *a_void)
+static unsigned long obj_name_hash(const OBJ_NAME *a)
 {
     unsigned long ret;
-    const OBJ_NAME *a = (const OBJ_NAME *)a_void;
 
     if ((name_funcs_stack != NULL)
         &amp;&amp; (sk_NAME_FUNCS_num(name_funcs_stack) &gt; a-&gt;type)) {
@@ -245,31 +234,30 @@ int OBJ_NAME_remove(const char *name, int type)
         return (0);
 }
 
-struct doall {
+typedef struct {
     int type;
     void (*fn) (const OBJ_NAME *, void *arg);
     void *arg;
-};
+} OBJ_DOALL;
 
-static void do_all_fn_doall_arg(const OBJ_NAME *name, struct doall *d)
+static void do_all_fn(const OBJ_NAME *name, OBJ_DOALL *d)
 {
     if (name-&gt;type == d-&gt;type)
         d-&gt;fn(name, d-&gt;arg);
 }
 
-static IMPLEMENT_LHASH_DOALL_ARG_FN(do_all_fn, const OBJ_NAME, struct doall)
+IMPLEMENT_LHASH_DOALL_ARG_CONST(OBJ_NAME, OBJ_DOALL);
 
 void OBJ_NAME_do_all(int type, void (*fn) (const OBJ_NAME *, void *arg),
                      void *arg)
 {
-    struct doall d;
+    OBJ_DOALL d;
 
     d.type = type;
     d.fn = fn;
     d.arg = arg;
 
-    lh_OBJ_NAME_doall_arg(names_lh, LHASH_DOALL_ARG_FN(do_all_fn),
-                          struct doall, &amp;d);
+    lh_OBJ_NAME_doall_OBJ_DOALL(names_lh, do_all_fn, &amp;d);
 }
 
 struct doall_sorted {
@@ -331,8 +319,6 @@ static void names_lh_free_doall(OBJ_NAME *onp)
         OBJ_NAME_remove(onp-&gt;name, onp-&gt;type);
 }
 
-static IMPLEMENT_LHASH_DOALL_FN(names_lh_free, OBJ_NAME)
-
 static void name_funcs_free(NAME_FUNCS *ptr)
 {
     OPENSSL_free(ptr);
@@ -346,15 +332,15 @@ void OBJ_NAME_cleanup(int type)
         return;
 
     free_type = type;
-    down_load = lh_OBJ_NAME_down_load(names_lh);
-    lh_OBJ_NAME_down_load(names_lh) = 0;
+    down_load = lh_OBJ_NAME_get_down_load(names_lh);
+    lh_OBJ_NAME_set_down_load(names_lh, 0);
 
-    lh_OBJ_NAME_doall(names_lh, LHASH_DOALL_FN(names_lh_free));
+    lh_OBJ_NAME_doall(names_lh, names_lh_free_doall);
     if (type &lt; 0) {
         lh_OBJ_NAME_free(names_lh);
         sk_NAME_FUNCS_pop_free(name_funcs_stack, name_funcs_free);
         names_lh = NULL;
         name_funcs_stack = NULL;
     } else
-        lh_OBJ_NAME_down_load(names_lh) = down_load;
+        lh_OBJ_NAME_set_down_load(names_lh, down_load);
 }
diff --git a/crypto/objects/o_names.h b/crypto/objects/o_names.h
deleted file mode 100644
index 914ed33..0000000
--- a/crypto/objects/o_names.h
+++ /dev/null
@@ -1,4 +0,0 @@
-
-
-typedef struct name_funcs_st NAME_FUNCS;
-DEFINE_STACK_OF(NAME_FUNCS)
diff --git a/crypto/objects/obj_dat.c b/crypto/objects/obj_dat.c
index bda9556..3983ebe 100644
--- a/crypto/objects/obj_dat.c
+++ b/crypto/objects/obj_dat.c
@@ -65,6 +65,7 @@
 #include &lt;openssl/objects.h&gt;
 #include &lt;openssl/bn.h&gt;
 #include &quot;internal/asn1_int.h&quot;
+#include &quot;obj_lcl.h&quot;
 
 /* obj_dat.h is generated from objects.h by obj_dat.pl */
 #include &quot;obj_dat.h&quot;
@@ -78,11 +79,10 @@ DECLARE_OBJ_BSEARCH_CMP_FN(const ASN1_OBJECT *, unsigned int, obj);
 #define ADDED_LNAME     2
 #define ADDED_NID       3
 
-typedef struct added_obj_st {
+struct added_obj_st {
     int type;
     ASN1_OBJECT *obj;
-} ADDED_OBJ;
-DECLARE_LHASH_OF(ADDED_OBJ);
+};
 
 static int new_nid = NUM_NID;
 static LHASH_OF(ADDED_OBJ) *added = NULL;
@@ -134,8 +134,6 @@ static unsigned long added_obj_hash(const ADDED_OBJ *ca)
     return (ret);
 }
 
-static IMPLEMENT_LHASH_HASH_FN(added_obj, ADDED_OBJ)
-
 static int added_obj_cmp(const ADDED_OBJ *ca, const ADDED_OBJ *cb)
 {
     ASN1_OBJECT *a, *b;
@@ -174,13 +172,11 @@ static int added_obj_cmp(const ADDED_OBJ *ca, const ADDED_OBJ *cb)
     }
 }
 
-static IMPLEMENT_LHASH_COMP_FN(added_obj, ADDED_OBJ)
-
 static int init_added(void)
 {
     if (added != NULL)
         return (1);
-    added = lh_ADDED_OBJ_new();
+    added = lh_ADDED_OBJ_new(added_obj_hash, added_obj_cmp);
     return (added != NULL);
 }
 
@@ -203,10 +199,6 @@ static void cleanup3_doall(ADDED_OBJ *a)
     OPENSSL_free(a);
 }
 
-static IMPLEMENT_LHASH_DOALL_FN(cleanup1, ADDED_OBJ)
-static IMPLEMENT_LHASH_DOALL_FN(cleanup2, ADDED_OBJ)
-static IMPLEMENT_LHASH_DOALL_FN(cleanup3, ADDED_OBJ)
-
 /*
  * The purpose of obj_cleanup_defer is to avoid EVP_cleanup() attempting to
  * use freed up OIDs. If necessary the actual freeing up of OIDs is delayed.
@@ -227,10 +219,10 @@ void OBJ_cleanup(void)
     }
     if (added == NULL)
         return;
-    lh_ADDED_OBJ_down_load(added) = 0;
-    lh_ADDED_OBJ_doall(added, LHASH_DOALL_FN(cleanup1)); /* zero counters */
-    lh_ADDED_OBJ_doall(added, LHASH_DOALL_FN(cleanup2)); /* set counters */
-    lh_ADDED_OBJ_doall(added, LHASH_DOALL_FN(cleanup3)); /* free objects */
+    lh_ADDED_OBJ_set_down_load(added, 0);
+    lh_ADDED_OBJ_doall(added, cleanup1_doall); /* zero counters */
+    lh_ADDED_OBJ_doall(added, cleanup2_doall); /* set counters */
+    lh_ADDED_OBJ_doall(added, cleanup3_doall); /* free objects */
     lh_ADDED_OBJ_free(added);
     added = NULL;
 }
diff --git a/crypto/objects/obj_lcl.h b/crypto/objects/obj_lcl.h
new file mode 100644
index 0000000..c451088
--- /dev/null
+++ b/crypto/objects/obj_lcl.h
@@ -0,0 +1,7 @@
+
+
+typedef struct name_funcs_st NAME_FUNCS;
+DEFINE_STACK_OF(NAME_FUNCS)
+DEFINE_LHASH_OF(OBJ_NAME);
+typedef struct added_obj_st ADDED_OBJ;
+DEFINE_LHASH_OF(ADDED_OBJ);
diff --git a/include/openssl/conf.h b/include/openssl/conf.h
index 1183072..81b7b95 100644
--- a/include/openssl/conf.h
+++ b/include/openssl/conf.h
@@ -78,7 +78,7 @@ typedef struct {
 } CONF_VALUE;
 
 DEFINE_STACK_OF(CONF_VALUE)
-DECLARE_LHASH_OF(CONF_VALUE);
+DEFINE_LHASH_OF(CONF_VALUE);
 
 struct conf_st;
 struct conf_method_st;
diff --git a/include/openssl/err.h b/include/openssl/err.h
index e05552b..df9cab2 100644
--- a/include/openssl/err.h
+++ b/include/openssl/err.h
@@ -315,6 +315,8 @@ typedef struct ERR_string_data_st {
     const char *string;
 } ERR_STRING_DATA;
 
+DEFINE_LHASH_OF(ERR_STRING_DATA);
+
 void ERR_put_error(int lib, int func, int reason, const char *file, int line);
 void ERR_set_error_data(char *data, int flags);
 
diff --git a/include/openssl/lhash.h b/include/openssl/lhash.h
index fb92317..b83fc6e 100644
--- a/include/openssl/lhash.h
+++ b/include/openssl/lhash.h
@@ -113,15 +113,6 @@ typedef void (*LHASH_DOALL_ARG_FN_TYPE) (void *, void *);
                 return name##_cmp(a,b); }
 # define LHASH_COMP_FN(name) name##_LHASH_COMP
 
-/* Third: &quot;doall&quot; functions */
-# define DECLARE_LHASH_DOALL_FN(name, o_type) \
-        void name##_LHASH_DOALL(void *);
-# define IMPLEMENT_LHASH_DOALL_FN(name, o_type) \
-        void name##_LHASH_DOALL(void *arg) { \
-                o_type *a = arg; \
-                name##_doall(a); }
-# define LHASH_DOALL_FN(name) name##_LHASH_DOALL
-
 /* Fourth: &quot;doall_arg&quot; functions */
 # define DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \
         void name##_LHASH_DOALL_ARG(void *, void *);
@@ -166,7 +157,7 @@ typedef struct lhash_st {
  * Indicates a malloc() error in the last call, this is only bad in
  * lh_insert().
  */
-# define lh_error(lh)    ((lh)-&gt;error)
+int lh_error(_LHASH *lh);
 
 _LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c);
 void lh_free(_LHASH *lh);
@@ -177,6 +168,8 @@ void lh_doall(_LHASH *lh, LHASH_DOALL_FN_TYPE func);
 void lh_doall_arg(_LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg);
 unsigned long lh_strhash(const char *c);
 unsigned long lh_num_items(const _LHASH *lh);
+unsigned long lh_get_down_load(const _LHASH *lh);
+void lh_set_down_load(_LHASH *lh, unsigned long down_load);
 
 # ifndef OPENSSL_NO_STDIO
 void lh_stats(const _LHASH *lh, FILE *fp);
@@ -191,40 +184,91 @@ void lh_node_usage_stats_bio(const _LHASH *lh, BIO *out);
 
 # define LHASH_OF(type) struct lhash_st_##type
 
-# define DECLARE_LHASH_OF(type) LHASH_OF(type) { int dummy; }
+# define DEFINE_LHASH_OF(type) \
+    LHASH_OF(type) { int dummy; }; \
+    static ossl_inline LHASH_OF(type) * \
+        lh_##type##_new(unsigned long (*hfn)(const type *), \
+                        int (*cfn)(const type *, const type *)) \
+    { \
+        return (LHASH_OF(type) *) \
+            lh_new((LHASH_HASH_FN_TYPE) hfn, (LHASH_COMP_FN_TYPE)cfn); \
+    } \
+    static ossl_inline void lh_##type##_free(LHASH_OF(type) *lh) \
+    { \
+        lh_free((_LHASH *)lh); \
+    } \
+    static ossl_inline type *lh_##type##_insert(LHASH_OF(type) *lh, type *d) \
+    { \
+        return lh_insert((_LHASH *)lh, d); \
+    } \
+    static ossl_inline type *lh_##type##_delete(LHASH_OF(type) *lh, const type *d) \
+    { \
+        return lh_delete((_LHASH *)lh, d); \
+    } \
+    static ossl_inline type *lh_##type##_retrieve(LHASH_OF(type) *lh, const type *d) \
+    { \
+        return lh_retrieve((_LHASH *)lh, d); \
+    } \
+    static ossl_inline int lh_##type##_error(LHASH_OF(type) *lh) \
+    { \
+        return lh_error((_LHASH *)lh); \
+    } \
+    static ossl_inline unsigned long lh_##type##_num_items(LHASH_OF(type) *lh) \
+    { \
+        return lh_num_items((_LHASH *)lh); \
+    } \
+    static ossl_inline void lh_##type##_node_stats_bio(const LHASH_OF(type) *lh, BIO *out) \
+    { \
+        lh_node_stats_bio((_LHASH *)lh, out); \
+    } \
+    static ossl_inline void lh_##type##_node_usage_stats_bio(const LHASH_OF(type) *lh, BIO *out) \
+    { \
+        lh_node_usage_stats_bio((_LHASH *)lh, out); \
+    } \
+    static ossl_inline void lh_##type##_stats_bio(const LHASH_OF(type) *lh, BIO *out) \
+    { \
+        lh_stats_bio((_LHASH *)lh, out); \
+    } \
+    static ossl_inline unsigned long lh_##type##_get_down_load(LHASH_OF(type) *lh) \
+    { \
+        return lh_get_down_load((_LHASH *)lh); \
+    } \
+    static ossl_inline void lh_##type##_set_down_load(LHASH_OF(type) *lh, unsigned long dl) \
+    { \
+        lh_set_down_load((_LHASH *)lh, dl); \
+    } \
+    static ossl_inline void lh_##type##_doall(LHASH_OF(type) *lh, \
+                                         void (*doall)(type *)) \
+    { \
+        lh_doall((_LHASH *)lh, (LHASH_DOALL_FN_TYPE)doall); \
+    } \
+    LHASH_OF(type)
+
+#define IMPLEMENT_LHASH_DOALL_ARG_CONST(type, argtype) \
+    int_implement_lhash_doall(type, argtype, const type)
+
+#define IMPLEMENT_LHASH_DOALL_ARG(type, argtype) \
+    int_implement_lhash_doall(type, argtype, type)
+
+#define int_implement_lhash_doall(type, argtype, cbargtype) \
+    static ossl_inline void \
+        lh_##type##_doall_##argtype(LHASH_OF(type) *lh, \
+                                   void (*fn)(cbargtype *, argtype *), \
+                                   argtype *arg) \
+    { \
+        lh_doall_arg((_LHASH *)lh, (LHASH_DOALL_ARG_FN_TYPE)fn, (void *)arg); \
+    } \
+    LHASH_OF(type)
 
 # define CHECKED_LHASH_OF(type,lh) \
   ((_LHASH *)CHECKED_PTR_OF(LHASH_OF(type),lh))
 
 /* Define wrapper functions. */
-# define LHM_lh_new(type, name) \
-  ((LHASH_OF(type) *)lh_new(LHASH_HASH_FN(name), LHASH_COMP_FN(name)))
-# define LHM_lh_error(type, lh) \
-  lh_error(CHECKED_LHASH_OF(type,lh))
-# define LHM_lh_insert(type, lh, inst) \
-  ((type *)lh_insert(CHECKED_LHASH_OF(type, lh), \
-                     CHECKED_PTR_OF(type, inst)))
-# define LHM_lh_retrieve(type, lh, inst) \
-  ((type *)lh_retrieve(CHECKED_LHASH_OF(type, lh), \
-                       CHECKED_PTR_OF(type, inst)))
-# define LHM_lh_delete(type, lh, inst) \
-  ((type *)lh_delete(CHECKED_LHASH_OF(type, lh),                        \
-                     CHECKED_PTR_OF(type, inst)))
-# define LHM_lh_doall(type, lh,fn) lh_doall(CHECKED_LHASH_OF(type, lh), fn)
 # define LHM_lh_doall_arg(type, lh, fn, arg_type, arg) \
   lh_doall_arg(CHECKED_LHASH_OF(type, lh), fn, CHECKED_PTR_OF(arg_type, arg))
-# define LHM_lh_num_items(type, lh) lh_num_items(CHECKED_LHASH_OF(type, lh))
-# define LHM_lh_down_load(type, lh) (CHECKED_LHASH_OF(type, lh)-&gt;down_load)
-# define LHM_lh_node_stats_bio(type, lh, out) \
-  lh_node_stats_bio(CHECKED_LHASH_OF(type, lh), out)
-# define LHM_lh_node_usage_stats_bio(type, lh, out) \
-  lh_node_usage_stats_bio(CHECKED_LHASH_OF(type, lh), out)
-# define LHM_lh_stats_bio(type, lh, out) \
-  lh_stats_bio(CHECKED_LHASH_OF(type, lh), out)
-# define LHM_lh_free(type, lh) lh_free(CHECKED_LHASH_OF(type, lh))
-
-DECLARE_LHASH_OF(OPENSSL_STRING);
-DECLARE_LHASH_OF(OPENSSL_CSTRING);
+
+DEFINE_LHASH_OF(OPENSSL_STRING);
+DEFINE_LHASH_OF(OPENSSL_CSTRING);
 
 #ifdef  __cplusplus
 }
diff --git a/include/openssl/safestack.h b/include/openssl/safestack.h
index 71d639f..538774d 100644
--- a/include/openssl/safestack.h
+++ b/include/openssl/safestack.h
@@ -220,233 +220,6 @@ DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)
 typedef void *OPENSSL_BLOCK;
 DEFINE_SPECIAL_STACK_OF(OPENSSL_BLOCK, void)
 
-/*
- * This file is automatically generated by util/mkstack.pl
- * Do not edit!
- */
-
-/*
- * SKM_sk_... stack macros are internal to safestack.h: never use them
- * directly, use sk_&lt;type&gt;_... instead
- */
-
-
-# define lh_ADDED_OBJ_new() LHM_lh_new(ADDED_OBJ,added_obj)
-# define lh_ADDED_OBJ_insert(lh,inst) LHM_lh_insert(ADDED_OBJ,lh,inst)
-# define lh_ADDED_OBJ_retrieve(lh,inst) LHM_lh_retrieve(ADDED_OBJ,lh,inst)
-# define lh_ADDED_OBJ_delete(lh,inst) LHM_lh_delete(ADDED_OBJ,lh,inst)
-# define lh_ADDED_OBJ_doall(lh,fn) LHM_lh_doall(ADDED_OBJ,lh,fn)
-# define lh_ADDED_OBJ_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(ADDED_OBJ,lh,fn,arg_type,arg)
-# define lh_ADDED_OBJ_error(lh) LHM_lh_error(ADDED_OBJ,lh)
-# define lh_ADDED_OBJ_num_items(lh) LHM_lh_num_items(ADDED_OBJ,lh)
-# define lh_ADDED_OBJ_down_load(lh) LHM_lh_down_load(ADDED_OBJ,lh)
-# define lh_ADDED_OBJ_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(ADDED_OBJ,lh,out)
-# define lh_ADDED_OBJ_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(ADDED_OBJ,lh,out)
-# define lh_ADDED_OBJ_stats_bio(lh,out) \
-  LHM_lh_stats_bio(ADDED_OBJ,lh,out)
-# define lh_ADDED_OBJ_free(lh) LHM_lh_free(ADDED_OBJ,lh)
-
-# define lh_APP_INFO_new() LHM_lh_new(APP_INFO,app_info)
-# define lh_APP_INFO_insert(lh,inst) LHM_lh_insert(APP_INFO,lh,inst)
-# define lh_APP_INFO_retrieve(lh,inst) LHM_lh_retrieve(APP_INFO,lh,inst)
-# define lh_APP_INFO_delete(lh,inst) LHM_lh_delete(APP_INFO,lh,inst)
-# define lh_APP_INFO_doall(lh,fn) LHM_lh_doall(APP_INFO,lh,fn)
-# define lh_APP_INFO_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(APP_INFO,lh,fn,arg_type,arg)
-# define lh_APP_INFO_error(lh) LHM_lh_error(APP_INFO,lh)
-# define lh_APP_INFO_num_items(lh) LHM_lh_num_items(APP_INFO,lh)
-# define lh_APP_INFO_down_load(lh) LHM_lh_down_load(APP_INFO,lh)
-# define lh_APP_INFO_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(APP_INFO,lh,out)
-# define lh_APP_INFO_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(APP_INFO,lh,out)
-# define lh_APP_INFO_stats_bio(lh,out) \
-  LHM_lh_stats_bio(APP_INFO,lh,out)
-# define lh_APP_INFO_free(lh) LHM_lh_free(APP_INFO,lh)
-
-# define lh_CONF_VALUE_new() LHM_lh_new(CONF_VALUE,conf_value)
-# define lh_CONF_VALUE_insert(lh,inst) LHM_lh_insert(CONF_VALUE,lh,inst)
-# define lh_CONF_VALUE_retrieve(lh,inst) LHM_lh_retrieve(CONF_VALUE,lh,inst)
-# define lh_CONF_VALUE_delete(lh,inst) LHM_lh_delete(CONF_VALUE,lh,inst)
-# define lh_CONF_VALUE_doall(lh,fn) LHM_lh_doall(CONF_VALUE,lh,fn)
-# define lh_CONF_VALUE_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(CONF_VALUE,lh,fn,arg_type,arg)
-# define lh_CONF_VALUE_error(lh) LHM_lh_error(CONF_VALUE,lh)
-# define lh_CONF_VALUE_num_items(lh) LHM_lh_num_items(CONF_VALUE,lh)
-# define lh_CONF_VALUE_down_load(lh) LHM_lh_down_load(CONF_VALUE,lh)
-# define lh_CONF_VALUE_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(CONF_VALUE,lh,out)
-# define lh_CONF_VALUE_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(CONF_VALUE,lh,out)
-# define lh_CONF_VALUE_stats_bio(lh,out) \
-  LHM_lh_stats_bio(CONF_VALUE,lh,out)
-# define lh_CONF_VALUE_free(lh) LHM_lh_free(CONF_VALUE,lh)
-
-# define lh_ENGINE_PILE_new() LHM_lh_new(ENGINE_PILE,engine_pile)
-# define lh_ENGINE_PILE_insert(lh,inst) LHM_lh_insert(ENGINE_PILE,lh,inst)
-# define lh_ENGINE_PILE_retrieve(lh,inst) LHM_lh_retrieve(ENGINE_PILE,lh,inst)
-# define lh_ENGINE_PILE_delete(lh,inst) LHM_lh_delete(ENGINE_PILE,lh,inst)
-# define lh_ENGINE_PILE_doall(lh,fn) LHM_lh_doall(ENGINE_PILE,lh,fn)
-# define lh_ENGINE_PILE_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(ENGINE_PILE,lh,fn,arg_type,arg)
-# define lh_ENGINE_PILE_error(lh) LHM_lh_error(ENGINE_PILE,lh)
-# define lh_ENGINE_PILE_num_items(lh) LHM_lh_num_items(ENGINE_PILE,lh)
-# define lh_ENGINE_PILE_down_load(lh) LHM_lh_down_load(ENGINE_PILE,lh)
-# define lh_ENGINE_PILE_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(ENGINE_PILE,lh,out)
-# define lh_ENGINE_PILE_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(ENGINE_PILE,lh,out)
-# define lh_ENGINE_PILE_stats_bio(lh,out) \
-  LHM_lh_stats_bio(ENGINE_PILE,lh,out)
-# define lh_ENGINE_PILE_free(lh) LHM_lh_free(ENGINE_PILE,lh)
-
-# define lh_ERR_STATE_new() LHM_lh_new(ERR_STATE,err_state)
-# define lh_ERR_STATE_insert(lh,inst) LHM_lh_insert(ERR_STATE,lh,inst)
-# define lh_ERR_STATE_retrieve(lh,inst) LHM_lh_retrieve(ERR_STATE,lh,inst)
-# define lh_ERR_STATE_delete(lh,inst) LHM_lh_delete(ERR_STATE,lh,inst)
-# define lh_ERR_STATE_doall(lh,fn) LHM_lh_doall(ERR_STATE,lh,fn)
-# define lh_ERR_STATE_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(ERR_STATE,lh,fn,arg_type,arg)
-# define lh_ERR_STATE_error(lh) LHM_lh_error(ERR_STATE,lh)
-# define lh_ERR_STATE_num_items(lh) LHM_lh_num_items(ERR_STATE,lh)
-# define lh_ERR_STATE_down_load(lh) LHM_lh_down_load(ERR_STATE,lh)
-# define lh_ERR_STATE_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(ERR_STATE,lh,out)
-# define lh_ERR_STATE_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(ERR_STATE,lh,out)
-# define lh_ERR_STATE_stats_bio(lh,out) \
-  LHM_lh_stats_bio(ERR_STATE,lh,out)
-# define lh_ERR_STATE_free(lh) LHM_lh_free(ERR_STATE,lh)
-
-# define lh_ERR_STRING_DATA_new() LHM_lh_new(ERR_STRING_DATA,err_string_data)
-# define lh_ERR_STRING_DATA_insert(lh,inst) LHM_lh_insert(ERR_STRING_DATA,lh,inst)
-# define lh_ERR_STRING_DATA_retrieve(lh,inst) LHM_lh_retrieve(ERR_STRING_DATA,lh,inst)
-# define lh_ERR_STRING_DATA_delete(lh,inst) LHM_lh_delete(ERR_STRING_DATA,lh,inst)
-# define lh_ERR_STRING_DATA_doall(lh,fn) LHM_lh_doall(ERR_STRING_DATA,lh,fn)
-# define lh_ERR_STRING_DATA_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(ERR_STRING_DATA,lh,fn,arg_type,arg)
-# define lh_ERR_STRING_DATA_error(lh) LHM_lh_error(ERR_STRING_DATA,lh)
-# define lh_ERR_STRING_DATA_num_items(lh) LHM_lh_num_items(ERR_STRING_DATA,lh)
-# define lh_ERR_STRING_DATA_down_load(lh) LHM_lh_down_load(ERR_STRING_DATA,lh)
-# define lh_ERR_STRING_DATA_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(ERR_STRING_DATA,lh,out)
-# define lh_ERR_STRING_DATA_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(ERR_STRING_DATA,lh,out)
-# define lh_ERR_STRING_DATA_stats_bio(lh,out) \
-  LHM_lh_stats_bio(ERR_STRING_DATA,lh,out)
-# define lh_ERR_STRING_DATA_free(lh) LHM_lh_free(ERR_STRING_DATA,lh)
-
-# define lh_FUNCTION_new() LHM_lh_new(FUNCTION,function)
-# define lh_FUNCTION_insert(lh,inst) LHM_lh_insert(FUNCTION,lh,inst)
-# define lh_FUNCTION_retrieve(lh,inst) LHM_lh_retrieve(FUNCTION,lh,inst)
-# define lh_FUNCTION_delete(lh,inst) LHM_lh_delete(FUNCTION,lh,inst)
-# define lh_FUNCTION_doall(lh,fn) LHM_lh_doall(FUNCTION,lh,fn)
-# define lh_FUNCTION_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(FUNCTION,lh,fn,arg_type,arg)
-# define lh_FUNCTION_error(lh) LHM_lh_error(FUNCTION,lh)
-# define lh_FUNCTION_num_items(lh) LHM_lh_num_items(FUNCTION,lh)
-# define lh_FUNCTION_down_load(lh) LHM_lh_down_load(FUNCTION,lh)
-# define lh_FUNCTION_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(FUNCTION,lh,out)
-# define lh_FUNCTION_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(FUNCTION,lh,out)
-# define lh_FUNCTION_stats_bio(lh,out) \
-  LHM_lh_stats_bio(FUNCTION,lh,out)
-# define lh_FUNCTION_free(lh) LHM_lh_free(FUNCTION,lh)
-
-# define lh_MEM_new() LHM_lh_new(MEM,mem)
-# define lh_MEM_insert(lh,inst) LHM_lh_insert(MEM,lh,inst)
-# define lh_MEM_retrieve(lh,inst) LHM_lh_retrieve(MEM,lh,inst)
-# define lh_MEM_delete(lh,inst) LHM_lh_delete(MEM,lh,inst)
-# define lh_MEM_doall(lh,fn) LHM_lh_doall(MEM,lh,fn)
-# define lh_MEM_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(MEM,lh,fn,arg_type,arg)
-# define lh_MEM_error(lh) LHM_lh_error(MEM,lh)
-# define lh_MEM_num_items(lh) LHM_lh_num_items(MEM,lh)
-# define lh_MEM_down_load(lh) LHM_lh_down_load(MEM,lh)
-# define lh_MEM_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(MEM,lh,out)
-# define lh_MEM_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(MEM,lh,out)
-# define lh_MEM_stats_bio(lh,out) \
-  LHM_lh_stats_bio(MEM,lh,out)
-# define lh_MEM_free(lh) LHM_lh_free(MEM,lh)
-
-# define lh_OBJ_NAME_new() LHM_lh_new(OBJ_NAME,obj_name)
-# define lh_OBJ_NAME_insert(lh,inst) LHM_lh_insert(OBJ_NAME,lh,inst)
-# define lh_OBJ_NAME_retrieve(lh,inst) LHM_lh_retrieve(OBJ_NAME,lh,inst)
-# define lh_OBJ_NAME_delete(lh,inst) LHM_lh_delete(OBJ_NAME,lh,inst)
-# define lh_OBJ_NAME_doall(lh,fn) LHM_lh_doall(OBJ_NAME,lh,fn)
-# define lh_OBJ_NAME_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(OBJ_NAME,lh,fn,arg_type,arg)
-# define lh_OBJ_NAME_error(lh) LHM_lh_error(OBJ_NAME,lh)
-# define lh_OBJ_NAME_num_items(lh) LHM_lh_num_items(OBJ_NAME,lh)
-# define lh_OBJ_NAME_down_load(lh) LHM_lh_down_load(OBJ_NAME,lh)
-# define lh_OBJ_NAME_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(OBJ_NAME,lh,out)
-# define lh_OBJ_NAME_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(OBJ_NAME,lh,out)
-# define lh_OBJ_NAME_stats_bio(lh,out) \
-  LHM_lh_stats_bio(OBJ_NAME,lh,out)
-# define lh_OBJ_NAME_free(lh) LHM_lh_free(OBJ_NAME,lh)
-
-# define lh_OPENSSL_CSTRING_new() LHM_lh_new(OPENSSL_CSTRING,openssl_cstring)
-# define lh_OPENSSL_CSTRING_insert(lh,inst) LHM_lh_insert(OPENSSL_CSTRING,lh,inst)
-# define lh_OPENSSL_CSTRING_retrieve(lh,inst) LHM_lh_retrieve(OPENSSL_CSTRING,lh,inst)
-# define lh_OPENSSL_CSTRING_delete(lh,inst) LHM_lh_delete(OPENSSL_CSTRING,lh,inst)
-# define lh_OPENSSL_CSTRING_doall(lh,fn) LHM_lh_doall(OPENSSL_CSTRING,lh,fn)
-# define lh_OPENSSL_CSTRING_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(OPENSSL_CSTRING,lh,fn,arg_type,arg)
-# define lh_OPENSSL_CSTRING_error(lh) LHM_lh_error(OPENSSL_CSTRING,lh)
-# define lh_OPENSSL_CSTRING_num_items(lh) LHM_lh_num_items(OPENSSL_CSTRING,lh)
-# define lh_OPENSSL_CSTRING_down_load(lh) LHM_lh_down_load(OPENSSL_CSTRING,lh)
-# define lh_OPENSSL_CSTRING_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(OPENSSL_CSTRING,lh,out)
-# define lh_OPENSSL_CSTRING_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(OPENSSL_CSTRING,lh,out)
-# define lh_OPENSSL_CSTRING_stats_bio(lh,out) \
-  LHM_lh_stats_bio(OPENSSL_CSTRING,lh,out)
-# define lh_OPENSSL_CSTRING_free(lh) LHM_lh_free(OPENSSL_CSTRING,lh)
-
-# define lh_OPENSSL_STRING_new() LHM_lh_new(OPENSSL_STRING,openssl_string)
-# define lh_OPENSSL_STRING_insert(lh,inst) LHM_lh_insert(OPENSSL_STRING,lh,inst)
-# define lh_OPENSSL_STRING_retrieve(lh,inst) LHM_lh_retrieve(OPENSSL_STRING,lh,inst)
-# define lh_OPENSSL_STRING_delete(lh,inst) LHM_lh_delete(OPENSSL_STRING,lh,inst)
-# define lh_OPENSSL_STRING_doall(lh,fn) LHM_lh_doall(OPENSSL_STRING,lh,fn)
-# define lh_OPENSSL_STRING_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(OPENSSL_STRING,lh,fn,arg_type,arg)
-# define lh_OPENSSL_STRING_error(lh) LHM_lh_error(OPENSSL_STRING,lh)
-# define lh_OPENSSL_STRING_num_items(lh) LHM_lh_num_items(OPENSSL_STRING,lh)
-# define lh_OPENSSL_STRING_down_load(lh) LHM_lh_down_load(OPENSSL_STRING,lh)
-# define lh_OPENSSL_STRING_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(OPENSSL_STRING,lh,out)
-# define lh_OPENSSL_STRING_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(OPENSSL_STRING,lh,out)
-# define lh_OPENSSL_STRING_stats_bio(lh,out) \
-  LHM_lh_stats_bio(OPENSSL_STRING,lh,out)
-# define lh_OPENSSL_STRING_free(lh) LHM_lh_free(OPENSSL_STRING,lh)
-
-# define lh_SSL_SESSION_new() LHM_lh_new(SSL_SESSION,ssl_session)
-# define lh_SSL_SESSION_insert(lh,inst) LHM_lh_insert(SSL_SESSION,lh,inst)
-# define lh_SSL_SESSION_retrieve(lh,inst) LHM_lh_retrieve(SSL_SESSION,lh,inst)
-# define lh_SSL_SESSION_delete(lh,inst) LHM_lh_delete(SSL_SESSION,lh,inst)
-# define lh_SSL_SESSION_doall(lh,fn) LHM_lh_doall(SSL_SESSION,lh,fn)
-# define lh_SSL_SESSION_doall_arg(lh,fn,arg_type,arg) \
-  LHM_lh_doall_arg(SSL_SESSION,lh,fn,arg_type,arg)
-# define lh_SSL_SESSION_error(lh) LHM_lh_error(SSL_SESSION,lh)
-# define lh_SSL_SESSION_num_items(lh) LHM_lh_num_items(SSL_SESSION,lh)
-# define lh_SSL_SESSION_down_load(lh) LHM_lh_down_load(SSL_SESSION,lh)
-# define lh_SSL_SESSION_node_stats_bio(lh,out) \
-  LHM_lh_node_stats_bio(SSL_SESSION,lh,out)
-# define lh_SSL_SESSION_node_usage_stats_bio(lh,out) \
-  LHM_lh_node_usage_stats_bio(SSL_SESSION,lh,out)
-# define lh_SSL_SESSION_stats_bio(lh,out) \
-  LHM_lh_stats_bio(SSL_SESSION,lh,out)
-# define lh_SSL_SESSION_free(lh) LHM_lh_free(SSL_SESSION,lh)
-
 # ifdef  __cplusplus
 }
 # endif
diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c
index 1666cd2..f3eb5b0 100644
--- a/ssl/ssl_lib.c
+++ b/ssl/ssl_lib.c
@@ -2228,8 +2228,6 @@ static int ssl_session_cmp(const SSL_SESSION *a, const SSL_SESSION *b)
  * variable. The reason is that the functions aren't static, they're exposed
  * via ssl.h.
  */
-static IMPLEMENT_LHASH_HASH_FN(ssl_session, SSL_SESSION)
-static IMPLEMENT_LHASH_COMP_FN(ssl_session, SSL_SESSION)
 
 SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth)
 {
@@ -2266,7 +2264,7 @@ SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth)
     if ((ret-&gt;cert = ssl_cert_new()) == NULL)
         goto err;
 
-    ret-&gt;sessions = lh_SSL_SESSION_new();
+    ret-&gt;sessions = lh_SSL_SESSION_new(ssl_session_hash, ssl_session_cmp);
     if (ret-&gt;sessions == NULL)
         goto err;
     ret-&gt;cert_store = X509_STORE_new();
diff --git a/ssl/ssl_locl.h b/ssl/ssl_locl.h
index a9d4f54..a490cd3 100644
--- a/ssl/ssl_locl.h
+++ b/ssl/ssl_locl.h
@@ -694,7 +694,7 @@ struct ssl_comp_st {
 };
 
 DEFINE_STACK_OF(SSL_COMP)
-DECLARE_LHASH_OF(SSL_SESSION);
+DEFINE_LHASH_OF(SSL_SESSION);
 
 
 struct ssl_ctx_st {
diff --git a/ssl/ssl_sess.c b/ssl/ssl_sess.c
index 80895b6..09d0193 100644
--- a/ssl/ssl_sess.c
+++ b/ssl/ssl_sess.c
@@ -1044,7 +1044,7 @@ typedef struct timeout_param_st {
     LHASH_OF(SSL_SESSION) *cache;
 } TIMEOUT_PARAM;
 
-static void timeout_doall_arg(SSL_SESSION *s, TIMEOUT_PARAM *p)
+static void timeout_cb(SSL_SESSION *s, TIMEOUT_PARAM *p)
 {
     if ((p-&gt;time == 0) || (p-&gt;time &gt; (s-&gt;time + s-&gt;timeout))) { /* timeout */
         /*
@@ -1060,7 +1060,7 @@ static void timeout_doall_arg(SSL_SESSION *s, TIMEOUT_PARAM *p)
     }
 }
 
-static IMPLEMENT_LHASH_DOALL_ARG_FN(timeout, SSL_SESSION, TIMEOUT_PARAM)
+IMPLEMENT_LHASH_DOALL_ARG(SSL_SESSION, TIMEOUT_PARAM);
 
 void SSL_CTX_flush_sessions(SSL_CTX *s, long t)
 {
@@ -1075,8 +1075,7 @@ void SSL_CTX_flush_sessions(SSL_CTX *s, long t)
     CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
     i = CHECKED_LHASH_OF(SSL_SESSION, tp.cache)-&gt;down_load;
     CHECKED_LHASH_OF(SSL_SESSION, tp.cache)-&gt;down_load = 0;
-    lh_SSL_SESSION_doall_arg(tp.cache, LHASH_DOALL_ARG_FN(timeout),
-                             TIMEOUT_PARAM, &amp;tp);
+    lh_SSL_SESSION_doall_TIMEOUT_PARAM(tp.cache, timeout_cb, &amp;tp);
     CHECKED_LHASH_OF(SSL_SESSION, tp.cache)-&gt;down_load = i;
     CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
 }
diff --git a/util/libeay.num b/util/libeay.num
index 1af1a2e..997abc0 100755
--- a/util/libeay.num
+++ b/util/libeay.num
@@ -4724,3 +4724,6 @@ CRYPTO_mem_debug_push                   5118	1_1_0	EXIST::FUNCTION:CRYPTO_MDEBUG
 CRYPTO_set_mem_debug                    5119	1_1_0	EXIST::FUNCTION:
 CRYPTO_mem_debug_pop                    5120	1_1_0	EXIST::FUNCTION:CRYPTO_MDEBUG
 CRYPTO_secure_actual_size               5121	1_1_0	EXIST::FUNCTION:
+lh_get_down_load                        5122	1_1_0	EXIST::FUNCTION:
+lh_error                                5123	1_1_0	EXIST::FUNCTION:
+lh_set_down_load                        5124	1_1_0	EXIST::FUNCTION:
diff --git a/util/mkstack.pl b/util/mkstack.pl
deleted file mode 100755
index eae3d55..0000000
--- a/util/mkstack.pl
+++ /dev/null
@@ -1,316 +0,0 @@
-#!/usr/local/bin/perl -w
-
-my $safestack = &quot;include/openssl/safestack.h&quot;;
-my $do_write = 0;
-
-foreach ( @ARGV ) {
-    $do_write = 1 if $_ eq &quot;-write&quot;;
-}
-
-my @asn1setlst;
-my @p12stklst;
-my @lhashlst;
-my @source = (&lt;include/openssl/*.h&gt;, &lt;crypto/include/internal/*.h&gt;, &lt;crypto/*.[ch]&gt;, &lt;crypto/*/*.[ch]&gt;, &lt;ssl/*.[ch]&gt;, &lt;apps/*.[ch]&gt;);
-foreach $file (@source) {
-    next if -l $file;
-
-    # Open the .c/.h file for reading
-    open(IN, &quot;&lt; $file&quot;) || die &quot;Can't open $file for reading, $!&quot;;
-
-    while(&lt;IN&gt;) {
-        next unless /^DECLARE_/;
-        if (/^DECLARE_LHASH_OF\(([^)]+)\)/) {
-            push @lhashlst, $1;
-        }
-    }
-    close(IN);
-}
-
-my $new_stackfile = &lt;&lt;'EOF';
-/* automatically generated by util/mkstack.pl */
-/* ====================================================================
- * Copyright (c) 1999-2015 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
- *
- * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
- *    nor may &quot;OpenSSL&quot; appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    &quot;This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
- * Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
- *
- */
-
-#ifndef HEADER_SAFESTACK_H
-# define HEADER_SAFESTACK_H
-
-# include &lt;openssl/stack.h&gt;
-# include &lt;openssl/e_os2.h&gt;
-
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
-
-# ifndef CHECKED_PTR_OF
-#  define CHECKED_PTR_OF(type, p) ((void*) (1 ? p : (type*)0))
-# endif
-
-/*
- * In C++ we get problems because an explicit cast is needed from (void *) we
- * use CHECKED_STACK_OF to ensure the correct type is passed in the macros
- * below.
- */
-
-# define CHECKED_STACK_OF(type, p) \
-    ((_STACK*) (1 ? p : (STACK_OF(type)*)0))
-
-# define CHECKED_SK_COPY_FUNC(type, p) \
-    ((void *(*)(void *)) ((1 ? p : (type *(*)(const type *))0)))
-
-# define CHECKED_SK_FREE_FUNC(type, p) \
-    ((void (*)(void *)) ((1 ? p : (void (*)(type *))0)))
-
-# define CHECKED_SK_CMP_FUNC(type, p) \
-    ((int (*)(const void *, const void *)) \
-        ((1 ? p : (int (*)(const type * const *, const type * const *))0)))
-
-# define STACK_OF(type) struct stack_st_##type
-
-# define SKM_DEFINE_STACK_OF(t1, t2, t3) \
-    STACK_OF(t1); \
-    static ossl_inline int sk_##t1##_num(const STACK_OF(t1) *sk) \
-    { \
-        return sk_num((_STACK *)sk); \
-    } \
-    static ossl_inline t2 *sk_##t1##_value(const STACK_OF(t1) *sk, int idx) \
-    { \
-        return (t2 *)sk_value((_STACK *)sk, idx); \
-    } \
-    static ossl_inline STACK_OF(t1) *sk_##t1##_new(int (*cmpf)(const t3 * const *a, const t3 * const *b)) \
-    { \
-        return (STACK_OF(t1) *)sk_new((int (*)(const void *a, const void *b))cmpf); \
-    } \
-    static ossl_inline STACK_OF(t1) *sk_##t1##_new_null(void) \
-    { \
-        return (STACK_OF(t1) *)sk_new_null(); \
-    } \
-    static ossl_inline void sk_##t1##_free(const STACK_OF(t1) *sk) \
-    { \
-        sk_free((_STACK *)sk); \
-    } \
-    static ossl_inline void sk_##t1##_zero(const STACK_OF(t1) *sk) \
-    { \
-        sk_zero((_STACK *)sk); \
-    } \
-    static ossl_inline t2 *sk_##t1##_delete(STACK_OF(t1) *sk, int i) \
-    { \
-        return (t2 *)sk_delete((_STACK *)sk, i); \
-    } \
-    static ossl_inline t2 *sk_##t1##_delete_ptr(STACK_OF(t1) *sk, t2 *ptr) \
-    { \
-        return (t2 *)sk_delete_ptr((_STACK *)sk, (void *)ptr); \
-    } \
-    static ossl_inline int sk_##t1##_push(STACK_OF(t1) *sk, t2 *ptr) \
-    { \
-        return sk_push((_STACK *)sk, (void *)ptr); \
-    } \
-    static ossl_inline int sk_##t1##_unshift(STACK_OF(t1) *sk, t2 *ptr) \
-    { \
-        return sk_unshift((_STACK *)sk, (void *)ptr); \
-    } \
-    static ossl_inline t2 *sk_##t1##_pop(STACK_OF(t1) *sk) \
-    { \
-        return (t2 *)sk_pop((_STACK *)sk); \
-    } \
-    static ossl_inline t2 *sk_##t1##_shift(STACK_OF(t1) *sk) \
-    { \
-        return (t2 *)sk_shift((_STACK *)sk); \
-    } \
-    static ossl_inline void sk_##t1##_pop_free(STACK_OF(t1) *sk, void (*func)(t3 *a)) \
-    { \
-        sk_pop_free((_STACK *)sk, (void (*)(void *))func); \
-    } \
-    static ossl_inline int sk_##t1##_insert(STACK_OF(t1) *sk, t2 *ptr, int idx) \
-    { \
-        return sk_insert((_STACK *)sk, (void *)ptr, idx); \
-    } \
-    static ossl_inline t2 *sk_##t1##_set(STACK_OF(t1) *sk, int idx, t2 *ptr) \
-    { \
-        return (t2 *)sk_set((_STACK *)sk, idx, (void *)ptr); \
-    } \
-    static ossl_inline int sk_##t1##_find(STACK_OF(t1) *sk, t2 *ptr) \
-    { \
-        return sk_find((_STACK *)sk, (void *)ptr); \
-    } \
-    static ossl_inline int sk_##t1##_find_ex(STACK_OF(t1) *sk, t2 *ptr) \
-    { \
-        return sk_find_ex((_STACK *)sk, (void *)ptr); \
-    } \
-    static ossl_inline void sk_##t1##_sort(const STACK_OF(t1) *sk) \
-    { \
-        sk_sort((_STACK *)sk); \
-    } \
-    static ossl_inline int sk_##t1##_is_sorted(const STACK_OF(t1) *sk) \
-    { \
-        return sk_is_sorted((_STACK *)sk); \
-    } \
-    static ossl_inline STACK_OF(t1) * sk_##t1##_dup(STACK_OF(t1) *sk) \
-    { \
-        return (STACK_OF(t1) *)sk_dup((_STACK *)sk); \
-    } \
-    static ossl_inline STACK_OF(t1) *sk_##t1##_deep_copy(STACK_OF(t1) *sk, \
-                                                    t3 *(*copyfn)(const t3 *), \
-                                                    void (*freefn)(t3 *)) \
-    { \
-        return (STACK_OF(t1) *)sk_deep_copy((_STACK *)sk, \
-                                            (void * (*)(void *a))copyfn, \
-                                            (void (*)(void *a))freefn); \
-    } \
-    static ossl_inline int (*sk_##t1##_set_cmp_func(STACK_OF(t1) *sk, int (*cmpf)(const t3 * const *a, const t3 * const *b)))(const t3 * const *, const t3 * const *) \
-    { \
-        return (int (*)(const t3 * const *,const t3 * const *))sk_set_cmp_func((_STACK *)sk, (int (*)(const void *a, const void *b))cmpf); \
-    }
-
-# define DEFINE_SPECIAL_STACK_OF(t1, t2) SKM_DEFINE_STACK_OF(t1, t2, t2)
-# define DEFINE_STACK_OF(t) SKM_DEFINE_STACK_OF(t, t, t)
-# define DEFINE_STACK_OF_CONST(t) SKM_DEFINE_STACK_OF(t, const t, t)
-
-/*-
- * Strings are special: normally an lhash entry will point to a single
- * (somewhat) mutable object. In the case of strings:
- *
- * a) Instead of a single char, there is an array of chars, NUL-terminated.
- * b) The string may have be immutable.
- *
- * So, they need their own declarations. Especially important for
- * type-checking tools, such as Deputy.
- *
- * In practice, however, it appears to be hard to have a const
- * string. For now, I'm settling for dealing with the fact it is a
- * string at all.
- */
-typedef char *OPENSSL_STRING;
-typedef const char *OPENSSL_CSTRING;
-
-/*-
- * Confusingly, LHASH_OF(STRING) deals with char ** throughout, but
- * STACK_OF(STRING) is really more like STACK_OF(char), only, as mentioned
- * above, instead of a single char each entry is a NUL-terminated array of
- * chars. So, we have to implement STRING specially for STACK_OF. This is
- * dealt with in the autogenerated macros below.
- */
-DEFINE_SPECIAL_STACK_OF(OPENSSL_STRING, char)
-
-/*
- * Similarly, we sometimes use a block of characters, NOT nul-terminated.
- * These should also be distinguished from &quot;normal&quot; stacks.
- */
-typedef void *OPENSSL_BLOCK;
-DEFINE_SPECIAL_STACK_OF(OPENSSL_BLOCK, void)
-
-/*
- * This file is automatically generated by util/mkstack.pl
- * Do not edit!
- */
-
-/*
- * SKM_sk_... stack macros are internal to safestack.h: never use them
- * directly, use sk_&lt;type&gt;_... instead
- */
-
-EOF
-
-my $old_stackfile;
-{
-    local $/ = undef;
-    open(IN, &quot;$safestack&quot;) || die &quot;Can't open $safestack, $!&quot;;
-    $old_stackfile = &lt;IN&gt;;
-    close(IN);
-}
-
-my $type_thing;
-
-foreach $type_thing (sort @lhashlst) {
-    my $lc_tt = lc $type_thing;
-    $new_stackfile .= &lt;&lt;EOF;
-
-# define lh_${type_thing}_new() LHM_lh_new(${type_thing},${lc_tt})
-# define lh_${type_thing}_insert(lh,inst) LHM_lh_insert(${type_thing},lh,inst)
-# define lh_${type_thing}_retrieve(lh,inst) LHM_lh_retrieve(${type_thing},lh,inst)
-# define lh_${type_thing}_delete(lh,inst) LHM_lh_delete(${type_thing},lh,inst)
-# define lh_${type_thing}_doall(lh,fn) LHM_lh_doall(${type_thing},lh,fn)
-# define lh_${type_thing}_doall_arg(lh,fn,arg_type,arg) \\
-  LHM_lh_doall_arg(${type_thing},lh,fn,arg_type,arg)
-# define lh_${type_thing}_error(lh) LHM_lh_error(${type_thing},lh)
-# define lh_${type_thing}_num_items(lh) LHM_lh_num_items(${type_thing},lh)
-# define lh_${type_thing}_down_load(lh) LHM_lh_down_load(${type_thing},lh)
-# define lh_${type_thing}_node_stats_bio(lh,out) \\
-  LHM_lh_node_stats_bio(${type_thing},lh,out)
-# define lh_${type_thing}_node_usage_stats_bio(lh,out) \\
-  LHM_lh_node_usage_stats_bio(${type_thing},lh,out)
-# define lh_${type_thing}_stats_bio(lh,out) \\
-  LHM_lh_stats_bio(${type_thing},lh,out)
-# define lh_${type_thing}_free(lh) LHM_lh_free(${type_thing},lh)
-EOF
-}
-
-$new_stackfile .= &lt;&lt;'EOF';
-
-# ifdef  __cplusplus
-}
-# endif
-#endif
-EOF
-
-if ($new_stackfile eq $old_stackfile) {
-    print &quot;No changes to $safestack.\n&quot;;
-}
-elsif ($do_write) {
-    print &quot;Writing new $safestack.\n&quot;;
-    open OUT, &quot;&gt;$safestack&quot; || die &quot;Can't open $safestack for writing, $!&quot;;
-    print OUT $new_stackfile;
-    close OUT;
-}
-
-exit 0;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002777.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="002782.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2778">[ date ]</a>
              <a href="thread.html#2778">[ thread ]</a>
              <a href="subject.html#2778">[ subject ]</a>
              <a href="author.html#2778">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
