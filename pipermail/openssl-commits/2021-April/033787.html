<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2021-April/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1617880883.523856.22261.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="033786.html">
   <LINK REL="Next"  HREF="033788.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1617880883.523856.22261.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Thu Apr  8 11:21:23 UTC 2021</I>
    <P><UL>
        <LI>Previous message: <A HREF="033786.html">[openssl]  master update
</A></li>
        <LI>Next message: <A HREF="033788.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33787">[ date ]</a>
              <a href="thread.html#33787">[ thread ]</a>
              <a href="subject.html#33787">[ subject ]</a>
              <a href="author.html#33787">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  71a05dcd33ccdb8e3446d9a0cc7a36e8993a83ce (commit)
       via  906bced110c156f98e5e4725d7d6de5a8da93089 (commit)
       via  4adfbe4c927da1b607ccb7af74872de32d54977f (commit)
       via  7008df2ba5089ab39543c5b519ad3b8f6eed633f (commit)
       via  0666d5318e5b71869b461fa5aae38ed44cd7e4ab (commit)
      from  27947123c9f17deac005b2afd265e38903349918 (commit)


- Log -----------------------------------------------------------------
commit 71a05dcd33ccdb8e3446d9a0cc7a36e8993a83ce
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Mar 25 17:05:49 2021 +0000

    Remove a TODO in EVP_set_default_properties
    
    Fixes #14371
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1487">https://github.com/openssl/openssl/pull/1487</A>)

commit 906bced110c156f98e5e4725d7d6de5a8da93089
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Mar 25 17:02:25 2021 +0000

    Update the algorithm fetching documentation links
    
    The documentation on algorithm fetching has moved. There were a lot of
    references to the old location so we update all of those locations.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1487">https://github.com/openssl/openssl/pull/1487</A>)

commit 4adfbe4c927da1b607ccb7af74872de32d54977f
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Mar 25 16:55:51 2021 +0000

    Update provider.pod
    
    The previous commits moved some content out of provider.pod into other
    pages, so that content is now removed. provider.pod is now exclusively
    focussed on provider authors.
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1487">https://github.com/openssl/openssl/pull/1487</A>)

commit 7008df2ba5089ab39543c5b519ad3b8f6eed633f
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Thu Mar 25 15:54:56 2021 +0000

    Add additional glossary entries
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1487">https://github.com/openssl/openssl/pull/1487</A>)

commit 0666d5318e5b71869b461fa5aae38ed44cd7e4ab
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Wed Mar 24 17:41:01 2021 +0000

    Expand the libcrypto documentation
    
    Reviewed-by: Paul Dale &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">pauli at openssl.org</A>&gt;
    (Merged from <A HREF="https://github.com/openssl/openssl/pull/1487">https://github.com/openssl/openssl/pull/1487</A>)

-----------------------------------------------------------------------

Summary of changes:
 doc/man3/EVP_ASYM_CIPHER_free.pod       |   4 +-
 doc/man3/EVP_DigestInit.pod             |   4 +-
 doc/man3/EVP_EncryptInit.pod            |   2 +-
 doc/man3/EVP_KDF.pod                    |   2 +-
 doc/man3/EVP_KEM_free.pod               |   4 +-
 doc/man3/EVP_KEYEXCH_free.pod           |   4 +-
 doc/man3/EVP_MAC.pod                    |   2 +-
 doc/man3/EVP_RAND.pod                   |   2 +-
 doc/man3/EVP_SIGNATURE_free.pod         |   4 +-
 doc/man3/EVP_set_default_properties.pod |   8 +-
 doc/man3/OCSP_response_status.pod       |   4 +-
 doc/man3/OSSL_CRMF_pbmp_new.pod         |   2 +-
 doc/man3/SRP_Calc_B.pod                 |   2 +-
 doc/man3/SRP_create_verifier.pod        |   2 +-
 doc/man3/SSL_CTX_new.pod                |   2 +-
 doc/man7/crypto.pod                     | 463 ++++++++++++++++++++++++++++++--
 doc/man7/openssl-glossary.pod           | 131 +++++++++
 doc/man7/provider.pod                   | 200 +-------------
 18 files changed, 602 insertions(+), 240 deletions(-)

diff --git a/doc/man3/EVP_ASYM_CIPHER_free.pod b/doc/man3/EVP_ASYM_CIPHER_free.pod
index 2500109e45..dfe67d9993 100644
--- a/doc/man3/EVP_ASYM_CIPHER_free.pod
+++ b/doc/man3/EVP_ASYM_CIPHER_free.pod
@@ -38,7 +38,7 @@ B&lt;algorithm&gt; from any provider offering it, within the criteria given
 by the B&lt;properties&gt; and in the scope of the given library context B&lt;ctx&gt; (see
 L&lt;OSSL_LIB_CTX(3)&gt;). The algorithm will be one offering functions for performing
 asymmetric cipher related tasks such as asymmetric encryption and decryption.
-See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+See L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information.
 
 The returned value must eventually be freed with EVP_ASYM_CIPHER_free().
 
@@ -90,7 +90,7 @@ return a constant B&lt;OSSL_PARAM&gt; array or NULL on error.
 
 =head1 SEE ALSO
 
-L&lt;provider(7)/Fetching algorithms&gt;, L&lt;OSSL_PROVIDER(3)&gt;
+L&lt;crypto(7)/ALGORITHM FETCHING&gt;, L&lt;OSSL_PROVIDER(3)&gt;
 
 =head1 HISTORY
 
diff --git a/doc/man3/EVP_DigestInit.pod b/doc/man3/EVP_DigestInit.pod
index 6299aa3d20..d01414e5e6 100644
--- a/doc/man3/EVP_DigestInit.pod
+++ b/doc/man3/EVP_DigestInit.pod
@@ -122,7 +122,7 @@ The B&lt;EVP_MD&gt; type is a structure for digest method implementation.
 
 Fetches the digest implementation for the given I&lt;algorithm&gt; from any
 provider offering it, within the criteria given by the I&lt;properties&gt;.
-See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+See L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information.
 
 The returned value must eventually be freed with EVP_MD_free().
 
@@ -677,7 +677,7 @@ L&lt;EVP_sha224(3)&gt;,
 L&lt;EVP_sha3_224(3)&gt;,
 L&lt;EVP_sm3(3)&gt;,
 L&lt;EVP_whirlpool(3)&gt;
-L&lt;provider(7)/Fetching algorithms&gt;
+L&lt;crypto(7)/ALGORITHM FETCHING&gt;
 
 =head1 HISTORY
 
diff --git a/doc/man3/EVP_EncryptInit.pod b/doc/man3/EVP_EncryptInit.pod
index 303e93fe06..b07c102e04 100644
--- a/doc/man3/EVP_EncryptInit.pod
+++ b/doc/man3/EVP_EncryptInit.pod
@@ -191,7 +191,7 @@ The B&lt;EVP_CIPHER&gt; type is a structure for cipher method implementation.
 EVP_CIPHER_fetch() fetches the cipher implementation for the given
 B&lt;algorithm&gt; from any provider offering it, within the criteria given
 by the B&lt;properties&gt;.
-See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+See L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information.
 
 The returned value must eventually be freed with EVP_CIPHER_free().
 
diff --git a/doc/man3/EVP_KDF.pod b/doc/man3/EVP_KDF.pod
index c3d0464d2e..08b15f08ab 100644
--- a/doc/man3/EVP_KDF.pod
+++ b/doc/man3/EVP_KDF.pod
@@ -73,7 +73,7 @@ B&lt;EVP_KDF_CTX&gt; is a context type that holds the algorithm inputs.
 
 EVP_KDF_fetch() fetches an implementation of a KDF I&lt;algorithm&gt;, given
 a library context I&lt;libctx&gt; and a set of I&lt;properties&gt;.
-See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+See L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information.
 
 See L&lt;OSSL_PROVIDER-default(7)/Key Derivation Function (KDF)&gt; for the lists of
 algorithms supported by the default provider.
diff --git a/doc/man3/EVP_KEM_free.pod b/doc/man3/EVP_KEM_free.pod
index 0551afcf8d..906f4eebed 100644
--- a/doc/man3/EVP_KEM_free.pod
+++ b/doc/man3/EVP_KEM_free.pod
@@ -34,7 +34,7 @@ provider offering it, within the criteria given by the B&lt;properties&gt; and in the
 scope of the given library context B&lt;ctx&gt; (see L&lt;OSSL_LIB_CTX(3)&gt;). The algorithm
 will be one offering functions for performing asymmetric kem related tasks such
 as key encapsulation and decapsulation.
-See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+See L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information.
 
 The returned value must eventually be freed with EVP_KEM_free().
 
@@ -83,7 +83,7 @@ a constant B&lt;OSSL_PARAM&gt; array or NULL on error.
 
 =head1 SEE ALSO
 
-L&lt;provider(7)/Fetching algorithms&gt;, L&lt;OSSL_PROVIDER(3)&gt;
+L&lt;crypto(7)/ALGORITHM FETCHING&gt;, L&lt;OSSL_PROVIDER(3)&gt;
 
 =head1 HISTORY
 
diff --git a/doc/man3/EVP_KEYEXCH_free.pod b/doc/man3/EVP_KEYEXCH_free.pod
index a040e7d604..1257dd2e5c 100644
--- a/doc/man3/EVP_KEYEXCH_free.pod
+++ b/doc/man3/EVP_KEYEXCH_free.pod
@@ -35,7 +35,7 @@ EVP_KEYEXCH_gettable_ctx_params, EVP_KEYEXCH_settable_ctx_params
 EVP_KEYEXCH_fetch() fetches the key exchange implementation for the given
 I&lt;algorithm&gt; from any provider offering it, within the criteria given
 by the I&lt;properties&gt;.
-See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+See L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information.
 
 The returned value must eventually be freed with EVP_KEYEXCH_free().
 
@@ -92,7 +92,7 @@ a constant B&lt;OSSL_PARAM&gt; array or NULL on error.
 
 =head1 SEE ALSO
 
-L&lt;provider(7)/Fetching algorithms&gt;, L&lt;OSSL_PROVIDER(3)&gt;
+L&lt;crypto(7)/ALGORITHM FETCHING&gt;, L&lt;OSSL_PROVIDER(3)&gt;
 
 =head1 HISTORY
 
diff --git a/doc/man3/EVP_MAC.pod b/doc/man3/EVP_MAC.pod
index a4da280ab4..2a8fb5332e 100644
--- a/doc/man3/EVP_MAC.pod
+++ b/doc/man3/EVP_MAC.pod
@@ -86,7 +86,7 @@ rely on an underlying computation algorithm.
 
 EVP_MAC_fetch() fetches an implementation of a MAC I&lt;algorithm&gt;, given
 a library context I&lt;libctx&gt; and a set of I&lt;properties&gt;.
-See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+See L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information.
 
 See L&lt;OSSL_PROVIDER-default(7)/Message Authentication Code (MAC)&gt; for the list
 of algorithms supported by the default provider.
diff --git a/doc/man3/EVP_RAND.pod b/doc/man3/EVP_RAND.pod
index ab0fdbcb48..23906da5ba 100644
--- a/doc/man3/EVP_RAND.pod
+++ b/doc/man3/EVP_RAND.pod
@@ -97,7 +97,7 @@ B&lt;EVP_RAND_CTX&gt; structures are reference counted.
 
 EVP_RAND_fetch() fetches an implementation of a RAND I&lt;algorithm&gt;, given
 a library context I&lt;libctx&gt; and a set of I&lt;properties&gt;.
-See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+See L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information.
 
 The returned value must eventually be freed with
 L&lt;EVP_RAND_free(3)&gt;.
diff --git a/doc/man3/EVP_SIGNATURE_free.pod b/doc/man3/EVP_SIGNATURE_free.pod
index de1b22f387..71f283fdc6 100644
--- a/doc/man3/EVP_SIGNATURE_free.pod
+++ b/doc/man3/EVP_SIGNATURE_free.pod
@@ -38,7 +38,7 @@ B&lt;algorithm&gt; from any provider offering it, within the criteria given
 by the B&lt;properties&gt;.
 The algorithm will be one offering functions for performing signature related
 tasks such as signing and verifying.
-See L&lt;provider(7)/Fetching algorithms&gt; for further information.
+See L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information.
 
 The returned value must eventually be freed with EVP_SIGNATURE_free().
 
@@ -90,7 +90,7 @@ return a constant B&lt;OSSL_PARAM&gt; array or NULL on error.
 
 =head1 SEE ALSO
 
-L&lt;provider(7)/Fetching algorithms&gt;, L&lt;OSSL_PROVIDER(3)&gt;
+L&lt;crypto(7)/ALGORITHM FETCHING&gt;, L&lt;OSSL_PROVIDER(3)&gt;
 
 =head1 HISTORY
 
diff --git a/doc/man3/EVP_set_default_properties.pod b/doc/man3/EVP_set_default_properties.pod
index 00404bd999..c8385ad1b4 100644
--- a/doc/man3/EVP_set_default_properties.pod
+++ b/doc/man3/EVP_set_default_properties.pod
@@ -17,11 +17,9 @@ EVP_default_properties_is_fips_enabled
 =head1 DESCRIPTION
 
 EVP_set_default_properties() sets the default properties for all
-future EVP algorithm fetches, implicit as well as explicit.
-
-=for comment TODO(3.0) We should consider having an EVP document in
-section 7 that details everything about implicit vs explicit fetches
-and how they relate to properties.
+future EVP algorithm fetches, implicit as well as explicit. See
+L&lt;crypto(7)/ALGORITHM FETCHING&gt; for information about implicit and explicit
+fetching.
 
 EVP_set_default_properties stores the properties given with the string
 I&lt;propq&gt; among the EVP data that's been stored in the library context
diff --git a/doc/man3/OCSP_response_status.pod b/doc/man3/OCSP_response_status.pod
index c97f22c4ed..9113af3836 100644
--- a/doc/man3/OCSP_response_status.pod
+++ b/doc/man3/OCSP_response_status.pod
@@ -54,7 +54,7 @@ OCSP_RESPID_set_by_key_ex() sets the key of the OCSP_RESPID to be the same as th
 key in the supplied X509 certificate I&lt;cert&gt; for the OCSP responder. The key is
 stored as a SHA1 hash. To calculate the hash the SHA1 algorithm is fetched using
 the library ctx I&lt;libctx&gt; and the property query string I&lt;propq&gt; (see
-L&lt;provider(7)/Fetching algorithms&gt; for further information).
+L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information).
 
 OCSP_RESPID_set_by_key() does the same as OCSP_RESPID_set_by_key_ex() except
 that the default library context is used with an empty property query string.
@@ -66,7 +66,7 @@ setting.
 OCSP_RESPID_match_ex() tests whether the OCSP_RESPID given in I&lt;respid&gt; matches
 with the X509 certificate I&lt;cert&gt; based on the SHA1 hash. To calculate the hash
 the SHA1 algorithm is fetched using the library ctx I&lt;libctx&gt; and the property
-query string I&lt;propq&gt; (see L&lt;provider(7)/Fetching algorithms&gt; for further
+query string I&lt;propq&gt; (see L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further
 information).
 
 OCSP_RESPID_match() does the same as OCSP_RESPID_match_ex() except that the
diff --git a/doc/man3/OSSL_CRMF_pbmp_new.pod b/doc/man3/OSSL_CRMF_pbmp_new.pod
index 25368401f1..ff8b3c327c 100644
--- a/doc/man3/OSSL_CRMF_pbmp_new.pod
+++ b/doc/man3/OSSL_CRMF_pbmp_new.pod
@@ -27,7 +27,7 @@ parameters I&lt;pbmp&gt;, message I&lt;msg&gt;, and secret I&lt;sec&gt;, along with the respective
 lengths I&lt;msglen&gt; and I&lt;seclen&gt;.
 The optional library context I&lt;libctx&gt; and I&lt;propq&gt; parameters may be used
 to influence the selection of the MAC algorithm referenced in the I&lt;pbmp&gt;;
-see L&lt;provider(7)/Fetching algorithms&gt; for further information.
+see L&lt;crypto(7)/ALGORITHM FETCHING&gt; for further information.
 On success writes the address of the newly
 allocated MAC via the I&lt;mac&gt; reference parameter and writes the length via the
 I&lt;maclen&gt; reference parameter unless it its NULL.
diff --git a/doc/man3/SRP_Calc_B.pod b/doc/man3/SRP_Calc_B.pod
index 48eb018328..8fa25b0b56 100644
--- a/doc/man3/SRP_Calc_B.pod
+++ b/doc/man3/SRP_Calc_B.pod
@@ -63,7 +63,7 @@ BIGNUM parameters to these functions.
 Most of these functions come in two forms. Those that take a I&lt;libctx&gt; and
 I&lt;propq&gt; parameter, and those that don't. Any cryptogrpahic functions that
 are fetched and used during the calculation use the provided I&lt;libctx&gt; and
-I&lt;propq&gt;. See L&lt;provider(7)/Fetching algorithms&gt; for more details. The variants
+I&lt;propq&gt;. See L&lt;crypto(7)/ALGORITHM FETCHING&gt; for more details. The variants
 that do not take a I&lt;libctx&gt; and I&lt;propq&gt; parameter use the default library
 context and property query string. The SRP_Calc_server_key() and SRP_Calc_A()
 functions do not have a form that takes I&lt;libctx&gt; or I&lt;propq&gt; parameters because
diff --git a/doc/man3/SRP_create_verifier.pod b/doc/man3/SRP_create_verifier.pod
index 74d520199d..37022b7dda 100644
--- a/doc/man3/SRP_create_verifier.pod
+++ b/doc/man3/SRP_create_verifier.pod
@@ -42,7 +42,7 @@ The SRP_create_verifier_BN_ex() function creates an SRP password verifier from
 the supplied parameters as defined in section 2.4 of RFC 5054 using the library
 context I&lt;libctx&gt; and property query string I&lt;propq&gt;. Any cryptographic
 algorithms that need to be fetched will use the I&lt;libctx&gt; and I&lt;propq&gt;. See
-L&lt;provider(7)/Fetching algorithms&gt;.
+L&lt;crypto(7)/ALGORITHM FETCHING&gt;.
 
 SRP_create_verifier_BN() is the same as SRP_create_verifier_BN_ex() except the
 default library context and property query string is used.
diff --git a/doc/man3/SSL_CTX_new.pod b/doc/man3/SSL_CTX_new.pod
index 1c953098e2..6bab45631f 100644
--- a/doc/man3/SSL_CTX_new.pod
+++ b/doc/man3/SSL_CTX_new.pod
@@ -79,7 +79,7 @@ library context I&lt;libctx&gt; (see L&lt;OSSL_LIB_CTX(3)&gt;) is used to provide the
 cryptographic algorithms needed for the session. Any cryptographic algorithms
 that are used by any B&lt;SSL&gt; objects created from this B&lt;SSL_CTX&gt; will be fetched
 from the I&lt;libctx&gt; using the property query string I&lt;propq&gt; (see
-L&lt;provider(7)/Fetching algorithms&gt;. Either or both the I&lt;libctx&gt; or I&lt;propq&gt;
+L&lt;crypto(7)/ALGORITHM FETCHING&gt;. Either or both the I&lt;libctx&gt; or I&lt;propq&gt;
 parameters may be NULL.
 
 SSL_CTX_new() does the same as SSL_CTX_new_ex() except that the default
diff --git a/doc/man7/crypto.pod b/doc/man7/crypto.pod
index aa6b6405ba..cf2c3f01d7 100644
--- a/doc/man7/crypto.pod
+++ b/doc/man7/crypto.pod
@@ -12,41 +12,458 @@ See the individual manual pages for details.
 
 The OpenSSL crypto library (C&lt;libcrypto&gt;) implements a wide range of
 cryptographic algorithms used in various Internet standards. The services
-provided by this library are used by the OpenSSL implementations of SSL, TLS
-and S/MIME, and they have also been used to implement SSH, OpenPGP, and
-other cryptographic standards.
+provided by this library are used by the OpenSSL implementations of TLS and
+CMS, and they have also been used to implement many other third party products
+and protocols.
 
-C&lt;libcrypto&gt; consists of a number of sub-libraries that implement the
-individual algorithms.
+The functionality includes symmetric encryption, public key cryptography, key
+agreement, certificate handling, cryptographic hash functions, cryptographic
+pseudo-random number generators, message authentication codes (MACs), key
+derivation functions (KDFs), and various utilities.
 
-The functionality includes symmetric encryption, public key
-cryptography and key agreement, certificate handling, cryptographic
-hash functions, cryptographic pseudo-random number generator, and
-various utilities.
+=head2 Algorithms
 
-=head1 NOTES
+Cryptographic primitives such as the SHA256 digest, or AES encryption are
+referred to in OpenSSL as &quot;algorithms&quot;. Each algorithm may have multiple
+implementations available for use. For example the RSA algorithm is available as
+a &quot;default&quot; implementation suitable for general use, and a &quot;fips&quot; implementation
+which has been validated to FIPS standards for situations where that is
+important. It is also possible that a third party could add additional
+implementations such as in a hardware security module (HSM).
 
-Some of the newer functions follow a naming convention using the numbers
-B&lt;0&gt; and B&lt;1&gt;. For example the functions:
+=head2 Operations
 
- int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);
- int X509_add1_trust_object(X509 *x, const ASN1_OBJECT *obj);
+Different algorithms can be grouped together by their purpose. For example there
+are algorithms for encryption, and different algorithms for digesting data.
+These different groups are known as &quot;operations&quot; in OpenSSL. Each operation
+has a different set of functions associated with it. For example to perform an
+encryption operation using AES (or any other encryption algorithm) you would use
+the encryption functions detailed on the L&lt;EVP_EncryptInit(3)&gt; page. Or to
+perform a digest operation using SHA256 then you would use the digesting
+functions on the L&lt;EVP_DigestInit(3)&gt; page.
 
-The B&lt;0&gt; version uses the supplied structure pointer directly
-in the parent and it will be freed up when the parent is freed.
-In the above example I&lt;crl&gt; would be freed but I&lt;rev&gt; would not.
+=head2 Providers
 
-The B&lt;1&gt; function uses a copy of the supplied structure pointer
-(or in some cases increases its link count) in the parent and
-so both (I&lt;x&gt; and I&lt;obj&gt; above) should be freed up.
+A provider in OpenSSL is a component that collects together algorithm
+implementations. In order to use an algorithm you must have at least one
+provider loaded that contains an implementation of it. OpenSSL comes with a
+number of providers and they may also be obtained from third parties. If you
+don't load a provider explicitly (either in program code or via config) then the
+OpenSSL built-in &quot;default&quot; provider will be automatically loaded.
 
-=head1 RETURN VALUES
+=head2 Library contexts
 
-See the individual manual pages for details.
+A library context can be thought of as a &quot;scope&quot; within which configuration
+options take effect. When a provider is loaded, it is only loaded within the
+scope of a given library context. In this way it is possible for different
+components of a complex application to each use a different library context and
+have different providers loaded with different configuration settings.
+
+If an application does not explicitly create a library context then the
+&quot;default&quot; library context will be used.
+
+Library contexts are represented by the B&lt;OSSL_LIB_CTX&gt; type. Many OpenSSL API
+functions take a library context as a parameter. Applications can always pass
+B&lt;NULL&gt; for this parameter to just use the default library context.
+
+The default library context is automatically created the first time it is
+needed. This will automatically load any available configuration file and will
+initialise OpenSSL for use. Unlike in earlier versions of OpenSSL (prior to
+1.1.0) no explicit initialisation steps need to be taken.
+
+Similarly when the application exits the default library context is
+automatically destroyed. No explicit de-initialisation steps need to be taken.
+
+See L&lt;OSSL_LIB_CTX(3)&gt; for more information about library contexts.
+
+=head2 Multi-threaded applications
+
+As long as OpenSSL has been built with support for threads (the default case
+on most platforms) then most OpenSSL I&lt;functions&gt; are thread-safe in the sense
+that it is safe to call the same function from multiple threads at the same
+time. However most OpenSSL I&lt;data structures&gt; are not thread-safe. For example
+the L&lt;BIO_write(3)&gt; and L&lt;BIO_read(3)&gt; functions are thread safe. However it
+would not be thread safe to call BIO_write() from one thread while calling
+BIO_read() in another where both functions are passed the same B&lt;BIO&gt; object
+since both of them may attempt to make changes to the same B&lt;BIO&gt; object.
+
+There are exceptions to these rules. A small number of functions are not thread
+safe at all. Where this is the case this restriction should be noted in the
+documentation for the function. Similarly some data structures may be partially
+or fully thread safe. For example it is safe to use an B&lt;OSSL_LIB_CTX&gt; in
+multiple threads.
+
+See L&lt;openssl-threads(7)&gt; for a more detailed discussion on OpenSSL threading
+support.
+
+=head1 ALGORITHM FETCHING
+
+In order to use an algorithm an implementation for it must first be &quot;fetched&quot;.
+Fetching is the process of looking through the available implementations,
+applying selection criteria (via a property query string), and finally choosing
+the implementation that will be used.
+
+Two types of fetching are supported by OpenSSL - explicit fetching and implicit
+fetching.
+
+=head2 Property query strings
+
+When fetching an algorithm it is possible to specify a property query string to
+guide the selection process. For example a property query string of
+&quot;provider=default&quot; could be used to force the selection to only consider
+algorithm implementations in the default provider.
+
+Property query strings can be specified explicitly as an argument to a function.
+It is also possible to specify a default property query string for the whole
+library context using the L&lt;EVP_set_default_properties(3)&gt; function. Where both
+default properties and function specific properties are specified then they are
+combined. Function specific properties will override default properties where
+there is a conflict.
+
+See L&lt;property(7)&gt; for more information about properties.
+
+=head2 Explicit fetching
+
+Users of the OpenSSL libraries never query a provider directly for an algorithm
+implementation. Instead, the diverse OpenSSL APIs often have explicit fetching
+functions that do the work, and they return an appropriate algorithm object back
+to the user. These functions usually have the name C&lt;APINAME_fetch&gt;, where
+C&lt;APINAME&gt; is the name of the operation. For example L&lt;EVP_MD_fetch(3)&gt; can
+be used to explicitly fetch a digest algorithm implementation. The user is
+responsible for freeing the object returned from the C&lt;APINAME_fetch&gt; function
+using C&lt;APINAME_free&gt; when it is no longer needed.
+
+These fetching functions follow a fairly common pattern, where three
+arguments are passed:
+
+=over 4
+
+=item The library context
+
+See L&lt;OSSL_LIB_CTX(3)&gt; for a more detailed description.
+This may be NULL to signify the default (global) library context, or a
+context created by the user. Only providers loaded in this library context (see
+L&lt;OSSL_PROVIDER_load(3)&gt;) will be considered by the fetching function. In case
+no provider has been loaded in this library context then the default provider
+will be loaded as a fallback (see L&lt;OSSL_PROVIDER-default(7)&gt;).
+
+=item An identifier
+
+For all currently implemented fetching functions this is the algorithm name.
+
+=item A property query string
+
+The property query string used to guide selection of the algorithm
+implementation.
+
+=back
+
+The algorithm implementation that is fetched can then be used with other diverse
+functions that use them. For example the L&lt;EVP_DigestInit_ex(3)&gt; function takes
+as a parameter an B&lt;EVP_MD&gt; object which may have been returned from an earlier
+call to L&lt;EVP_MD_fetch(3)&gt;.
+
+=head2 Implicit fetch
+
+OpenSSL has a number of functions that return an algorithm object with no
+associated implementation, such as L&lt;EVP_sha256(3)&gt;,
+L&lt;EVP_blake2b512(3)&gt; or L&lt;EVP_aes_128_cbc(3)&gt;. These are present for
+compatibility with OpenSSL before version 3.0 where explicit fetching was not
+available.
+
+When they are used with functions like L&lt;EVP_DigestInit_ex(3)&gt; or
+L&lt;EVP_CipherInit_ex(3)&gt;, the actual implementation to be used is
+fetched implicitly using default search criteria.
+
+In some cases implicit fetching can also occur when a NULL algorithm parameter
+is supplied. In this case an algorithm implementation is implicitly fetched
+using default search criteria and an algorithm name that is consistent with
+the context in which it is being used.
+
+=head1 FETCHING EXAMPLES
+
+The following section provides a series of examples of fetching algorithm
+implementations.
+
+Fetch any available implementation of SHA2-256 in the default context. Note
+that some algorithms have aliases. So &quot;SHA256&quot; and &quot;SHA2-256&quot; are synonymous:
+
+ EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA2-256&quot;, NULL);
+ ...
+ EVP_MD_free(md);
+
+Fetch any available implementation of AES-128-CBC in the default context:
+
+ EVP_CIPHER *cipher = EVP_CIPHER_fetch(NULL, &quot;AES-128-CBC&quot;, NULL);
+ ...
+ EVP_CIPHER_free(cipher);
+
+Fetch an implementation of SHA2-256 from the default provider in the default
+context:
+
+ EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA2-256&quot;, &quot;provider=default&quot;);
+ ...
+ EVP_MD_free(md);
+
+Fetch an implementation of SHA2-256 that is not from the default provider in the
+default context:
+
+ EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA2-256&quot;, &quot;provider!=default&quot;);
+ ...
+ EVP_MD_free(md);
+
+Fetch an implementation of SHA2-256 from the default provider in the specified
+context:
+
+ EVP_MD *md = EVP_MD_fetch(ctx, &quot;SHA2-256&quot;, &quot;provider=default&quot;);
+ ...
+ EVP_MD_free(md);
+
+Load the legacy provider into the default context and then fetch an
+implementation of WHIRLPOOL from it:
+
+ /* This only needs to be done once - usually at application start up */
+ OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, &quot;legacy&quot;);
+
+ EVP_MD *md = EVP_MD_fetch(NULL, &quot;WHIRLPOOL&quot;, &quot;provider=legacy&quot;);
+ ...
+ EVP_MD_free(md);
+
+Note that in the above example the property string &quot;provider=legacy&quot; is optional
+since, assuming no other providers have been loaded, the only implementation of
+the &quot;whirlpool&quot; algorithm is in the &quot;legacy&quot; provider. Also note that the
+default provider should be explicitly loaded if it is required in addition to
+other providers:
+
+ /* This only needs to be done once - usually at application start up */
+ OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, &quot;legacy&quot;);
+ OSSL_PROVIDER *default = OSSL_PROVIDER_load(NULL, &quot;default&quot;);
+
+ EVP_MD *md_whirlpool = EVP_MD_fetch(NULL, &quot;whirlpool&quot;, NULL);
+ EVP_MD *md_sha256 = EVP_MD_fetch(NULL, &quot;SHA2-256&quot;, NULL);
+ ...
+ EVP_MD_free(md_whirlpool);
+ EVP_MD_free(md_sha256);
+
+=head1 OPENSSL PROVIDERS
+
+OpenSSL comes with a set of providers.
+
+The algorithms available in each of these providers may vary due to build time
+configuration options. The L&lt;openssl-list(1)&gt; command can be used to list the
+currently available algorithms.
+
+The names of the algorithms shown from L&lt;openssl-list(1)&gt; can be used as an
+algorithm identifier to the appropriate fetching function. Also see the provider
+specific manual pages linked below for further details about using the
+algorithms available in each of the providers.
+
+As well as the OpenSSL providers third parties can also implemment providers.
+For information on writing a provider see L&lt;provider(7)&gt;.
+
+=head2 Default provider
+
+The default provider is built in as part of the F&lt;libcrypto&gt; library and
+contains all of the most commonly used algorithm implementations. Should it be
+needed (if other providers are loaded and offer implementations of the same
+algorithms), the property query string &quot;provider=default&quot; can be used as a
+search criterion for these implementations.  The default provider includes all
+of the functionality in the base provider below.
+
+If you don't load any providers at all then the &quot;default&quot; provider will be
+automatically loaded. If you explicitly load any provider then the &quot;default&quot;
+provider would also need to be explicitly loaded if it is required.
+
+See L&lt;OSSL_PROVIDER-default(7)&gt;.
+
+=head2 Base provider
+
+The base provider is built in as part of the F&lt;libcrypto&gt; library and contains
+algorithm implementations for encoding and decoding for OpenSSL keys.
+Should it be needed (if other providers are loaded and offer
+implementations of the same algorithms), the property query string
+&quot;provider=base&quot; can be used as a search criterion for these implementations.
+Some encoding and decoding algorithm implementations are not FIPS algorithm
+implementations in themselves but support algorithms from the FIPS provider and
+are allowed for use in &quot;FIPS mode&quot;. The property query string &quot;fips=yes&quot; can be
+used to select such algorithms.
+
+See L&lt;OSSL_PROVIDER-base(7)&gt;.
+
+=head2 FIPS provider
+
+The FIPS provider is a dynamically loadable module, and must therefore
+be loaded explicitly, either in code or through OpenSSL configuration
+(see L&lt;config(5)&gt;). It contains algorithm implementations that have been
+validated according to the FIPS 140-2 standard. Should it be needed (if other
+providers are loaded and offer implementations of the same algorithms), the
+property query string &quot;provider=fips&quot; can be used as a search criterion for
+these implementations. All approved algorithm implementations in the FIPS
+provider can also be selected with the property &quot;fips=yes&quot;. The FIPS provider
+may also contain non-approved algorithm implementations and these can be
+selected with the property &quot;fips=no&quot;.
+
+See L&lt;OSSL_PROVIDER-FIPS(7)&gt;.
+
+=head2 Legacy provider
+
+The legacy provider is a dynamically loadable module, and must therefore
+be loaded explicitly, either in code or through OpenSSL configuration
+(see L&lt;config(5)&gt;). It contains algorithm implementations that are considered
+insecure, or are no longer in common use such as MD2 or RC4. Should it be needed
+(if other providers are loaded and offer implementations of the same algorithms),
+the property &quot;provider=legacy&quot; can be used as a search criterion for these
+implementations.
+
+See L&lt;OSSL_PROVIDER-legacy(7)&gt;.
+
+=head2 Null provider
+
+The null provider is built in as part of the F&lt;libcrypto&gt; library. It contains
+no algorithms in it at all. When fetching algorithms the default provider will
+be automatically loaded if no other provider has been explicitly loaded. To
+prevent that from happening you can explicitly load the null provider.
+
+See L&lt;OSSL_PROVIDER-null(7)&gt;.
+
+=head1 USING ALGORITHMS IN APPLICATIONS
+
+Cryptographic algorithms are made available to applications through use of the
+&quot;EVP&quot; APIs. Each of the various operations such as encryption, digesting,
+message authentication codes, etc., have a set of EVP function calls that can
+be invoked to use them. See the L&lt;evp(7)&gt; page for further details.
+
+Most of these follow a common pattern. A &quot;context&quot; object is first created. For
+example for a digest operation you would use an B&lt;EVP_MD_CTX&gt;, and for an
+encryption/decryption operation you would use an B&lt;EVP_CIPHER_CTX&gt;. The
+operation is then initialised ready for use via an &quot;init&quot; function - optionally
+passing in a set of parameters (using the B&lt;OSSL_PARAM&gt; type) to configure how
+the operation should behave. Next data is fed into the operation in a series of
+&quot;update&quot; calls. The operation is finalised using a &quot;final&quot; call which will
+typically provide some kind of output. Finally the context is cleaned up and
+freed.
+
+The following shows a complete example for doing this process for digesting
+data using SHA256. The process is similar for other operations such as
+encryption/decryption, signatures, message authentication codes, etc.
+
+ #include &lt;stdio.h&gt;
+ #include &lt;openssl/evp.h&gt;
+ #include &lt;openssl/bio.h&gt;
+
+ int main(void)
+ {
+     EVP_MD_CTX *ctx = NULL;
+     EVP_MD *sha256 = NULL;
+     const unsigned char msg[] = {
+         0x00, 0x01, 0x02, 0x03
+     };
+     unsigned int len = 0;
+     unsigned char *outdigest = NULL;
+
+     /* Create a context for the digest operation */
+     ctx = EVP_MD_CTX_new();
+     if (ctx == NULL)
+         goto err;
+
+     /*
+      * Fetch the SHA256 algorithm implementation for doing the digest. We're
+      * using the &quot;default&quot; library context here (first NULL parameter), and
+      * we're not supplying any particular search criteria for our SHA256
+      * implementation (second NULL parameter). Any SHA256 implementation will
+      * do.
+      */
+     sha256 = EVP_MD_fetch(NULL, &quot;SHA256&quot;, NULL);
+     if (sha256 == NULL)
+         goto err;
+
+    /* Initialise the digest operation */
+    if (!EVP_DigestInit_ex(ctx, sha256, NULL))
+        goto err;
+
+     /*
+      * Pass the message to be digested. This can be passed in over multiple
+      * EVP_DigestUpdate calls if necessary
+      */
+     if (!EVP_DigestUpdate(ctx, msg, sizeof(msg)))
+         goto err;
+
+     /* Allocate the output buffer */
+     outdigest = OPENSSL_malloc(EVP_MD_size(sha256));
+     if (outdigest == NULL)
+         goto err;
+
+     /* Now calculate the digest itself */
+     if (!EVP_DigestFinal_ex(ctx, outdigest, &amp;len))
+         goto err;
+
+     /* Print out the digest result */
+     BIO_dump_fp(stdout, outdigest, len);
+
+  err:
+     /* Clean up all the resources we allocated */
+     OPENSSL_free(outdigest);
+     EVP_MD_free(sha256);
+     EVP_MD_CTX_free(ctx);
+ }
+
+=head1 CONFIGURATION
+
+By default OpenSSL will load a configuration file when it is first used. This
+will set up various configuration settings within the default library context.
+Applications that create their own library contexts may optionally configure
+them with a config file using the L&lt;OSSL_LIB_CTX_load_config(3)&gt; function.
+
+The configuration file can be used to automatically load providers and set up
+default property query strings.
+
+For information on the OpenSSL configuration file format see L&lt;config(5)&gt;.
+
+=head1 ENCODING AND DECODING KEYS
+
+Many algorithms require the use of a key. Keys can be generated dynamically
+using the EVP APIs (for example see L&lt;EVP_PKEY_gen(3)&gt;). However it is often
+necessary to save or load keys (or their associated parameters) to or from some
+external format such as PEM or DER (see L&lt;openssl-glossary(7)&gt;). OpenSSL uses
+encoders and decoders to perform this task.
+
+Encoders and decoders are just algorithm implementations in the same way as
+any other algorithm implementation in OpenSSL. They are implemented by
+providers. The OpenSSL encoders and decoders are available in the default
+provider. They are also duplicated in the base provider.
+
+For information about encoders see L&lt;OSSL_ENCODER_CTX_new_for_pkey(3)&gt;. For
+information about decoders see L&lt;OSSL_DECODER_CTX_new_for_pkey(3)&gt;.
+
+=head1 LIBRARY CONVENTIONS
+
+Many OpenSSL functions that &quot;get&quot; or &quot;set&quot; a value follow a naming convention
+using the numbers B&lt;0&gt; and B&lt;1&gt;, i.e. &quot;get0&quot;, &quot;get1&quot;, &quot;set0&quot; and &quot;set1&quot;. This
+can also apply to some functions that &quot;add&quot; a value to an existing set, i.e.
+&quot;add0&quot; and &quot;add1&quot;.
+
+For example the functions:
+
+ int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);
+ int X509_add1_trust_object(X509 *x, const ASN1_OBJECT *obj);
+
+In the B&lt;0&gt; version the ownership of the object is passed to (for an add or set)
+or retained by (for a get) the parent object. For example after calling the
+X509_CRL_add0_revoked() function above, ownership of the I&lt;rev&gt; object is passed
+to the I&lt;crl&gt; object. Therefore, after calling this function I&lt;rev&gt; should not
+be freed directly. It will be freed implicitly when I&lt;crl&gt; is freed.
+
+In the B&lt;1&gt; version the ownership of the object is not passed to or retained by
+the parent object. Instead a copy or &quot;up ref&quot; of the object is performed. So
+after calling the X509_add1_trust_object() function above the application will
+still be responsible for freeing the I&lt;obj&gt; value where appropriate.
 
 =head1 SEE ALSO
 
-L&lt;openssl(1)&gt;, L&lt;ssl(7)&gt;
+L&lt;openssl(1)&gt;, L&lt;ssl(7)&gt;, L&lt;evp(7)&gt;, L&lt;OSSL_LIB_CTX(3)&gt;, L&lt;openssl-threads(7)&gt;,
+L&lt;property(7)&gt;, L&lt;OSSL_PROVIDER-default(7)&gt;, L&lt;OSSL_PROVIDER-base(7)&gt;,
+L&lt;OSSL_PROVIDER-FIPS(7)&gt;, L&lt;OSSL_PROVIDER-legacy(7)&gt;, L&lt;OSSL_PROVIDER-null(7)&gt;,
+L&lt;openssl-glossary(7)&gt;, L&lt;provider(7)&gt;
 
 =head1 COPYRIGHT
 
diff --git a/doc/man7/openssl-glossary.pod b/doc/man7/openssl-glossary.pod
index 7aa71ea7a5..5f92a8403c 100644
--- a/doc/man7/openssl-glossary.pod
+++ b/doc/man7/openssl-glossary.pod
@@ -10,6 +10,14 @@ openssl-glossary - An OpenSSL Glossary
 
 =over 4
 
+=item Algorithm
+
+Cryptograpic primitives such as the SHA256 digest, or AES encryption are
+referred to in OpenSSL as &quot;algorithms&quot;. There can be more than one
+implementation for any given algorithm available for use.
+
+L&lt;crypto(7)&gt;
+
 =item ASN.1, ASN1
 
 ASN.1 (&quot;Abstract Syntax Notation One&quot;) is a notation for describing abstract
@@ -20,6 +28,30 @@ L&lt;<A HREF="https://www.itu.int/rec/T-REC-X.681">https://www.itu.int/rec/T-REC-X.681</A>&gt;,
 L&lt;<A HREF="https://www.itu.int/rec/T-REC-X.682">https://www.itu.int/rec/T-REC-X.682</A>&gt;,
 L&lt;<A HREF="https://www.itu.int/rec/T-REC-X.683">https://www.itu.int/rec/T-REC-X.683</A>&gt;
 
+=item Base Provider
+
+An OpenSSL Provider that contains encoders and decoders for OpenSSL keys.  All
+the algorithm implementations in the Base Provider are also available in the
+Default Provider.
+
+L&lt;OSSL_PROVIDER-base(7)&gt;
+
+=item Decoder
+
+A decoder is a type of algorithm used for decoding keys and parameters from some
+external format such as PEM or DER.
+
+L&lt;OSSL_DECODER_CTX_new_for_pkey(3)&gt;
+
+=item Default Provider
+
+An OpenSSL Provider that contains the most commmon OpenSSL algorithm
+implementations. It is loaded by default if no other provider is available. All
+the algorithm implementations in the Base Provider are also available in the
+Default Provider.
+
+L&lt;OSSL_PROVIDER-default(7)&gt;
+
 =item DER (&quot;Distinguished Encoding Rules&quot;)
 
 DER is a binary encoding of data, structured according to an ASN.1
@@ -30,11 +62,81 @@ It is defined in ITU-T document X.690:
 
 L&lt;<A HREF="https://www.itu.int/rec/T-REC-X.690">https://www.itu.int/rec/T-REC-X.690</A>&gt;
 
+=item Encoder
+
+An encoder is a type of algorithm used for encoding keys and parameters to some
+external format such as PEM or DER.
+
+L&lt;OSSL_ENCODER_CTX_new_for_pkey(3)&gt;
+
+=item Explicit Fetching
+
+Explicit Fetching is a type of Fetching (see Fetching). Explicit Fetching is
+where a function call is made to obtain an algorithm object representing an
+implementation such as L&lt;EVP_MD_fetch(3)&gt; or L&lt;EVP_CIPHER_fetch(3)&gt;
+
+=item Fetching
+
+Fetching is the process of looking through the available algorithm
+implementations, applying selection criteria (via a property query string), and
+finally choosing the implementation that will be used.
+
+Also see Explicit Fetching and Implict Fetching.
+
+L&lt;crypto(7)&gt;
+
+=item FIPS Provider
+
+An OpenSSL Provider that contains OpenSSL algorithm implementations that have
+been validated according to the FIPS 140-2 standard.
+
+L&lt;OSSL_PROVIDER-FIPS(7)&gt;
+
+=item Implicit Fetching
+
+Implicit Fetching is a type of Fetching (see Fetching). Implicit Fetching is
+where an algorithm object with no associated implementation is used such as the
+return value from L&lt;EVP_sha256(3)&gt; or L&lt;EVP_aes_128_cbc(3)&gt;. With implicit
+fetching an implementation is fetched automatically using default selection
+criteria the first time the algorithm is used.
+
+=item Legacy Provider
+
+An OpenSSL Provider that contains algorithm implementations that are considered
+insecure or are no longer in common use.
+
+L&lt;OSSL_PROVIDER-legacy(7)&gt;
+
+=item Library Context
+
+A Library Context in OpenSSL is represented by the type B&lt;OSSL_LIB_CTX&gt;. It can
+be thought of as a scope within which configuration options apply. If an
+application does not explicitly create a library context then the &quot;default&quot;
+one is used. Many OpenSSL functions can take a library context as an argument.
+A NULL value can always be passed to indicate the default library context.
+
+L&lt;OSSL_LIB_CTX(3)&gt;
+
 =item MSBLOB
 
 MSBLOB is a Microsoft specific binary format for RSA and DSA keys, both
 private and public.  This form is never passphrase protected.
 
+=item Null Provider
+
+An OpenSSL Provider that contains no algorithm implementations. This can be
+useful to prevent the default provider from being automatically loaded in a
+library context.
+
+L&lt;OSSL_PROVIDER-null(7)&gt;
+
+=item Operation
+
+An operation is a group of OpenSSL functions with a common purpose such as 
+encryption, or digesting.
+
+L&lt;crypto(7)&gt;
+
 =item PEM (&quot;Privacy Enhanced Message&quot;)
 
 PEM is a format used for encoding of binary content into a mail and ASCII
@@ -66,6 +168,35 @@ This is specified in RFC 5208:
 
 L&lt;<A HREF="https://tools.ietf.org/html/rfc5208">https://tools.ietf.org/html/rfc5208</A>&gt;
 
+=item Property
+
+A property is a way of classifying and selecting algorithm implementations.
+A property is a key/value pair expressed as a string. For example all algorithm
+implementations in the default provider have the property &quot;provider=default&quot;.
+An algorithm implementation can have multiple properties defined against it.
+
+Also see Property Query String.
+
+L&lt;property(7)&gt;
+
+=item Property Query String
+
+A property query string is a string containing a sequence of properties that
+can be used to select an algorithm implementation. For example the query string
+&quot;provider=example,foo=bar&quot; will select algorithms from the &quot;example&quot; provider
+that have a &quot;foo&quot; property defined for them with a value of &quot;bar&quot;.
+
+Property Query Strings are used during fetching. See Fetching.
+
+L&lt;property(7)&gt;
+
+=item Provider
+
+A provider in OpenSSL is a component that groups together algorithm
+implementations. Providers can come from OpenSSL itself or from third parties.
+
+L&lt;provider(7)&gt;
+
 =item PVK
 
 PVK is a Microsoft specific binary format for RSA and DSA private keys.
diff --git a/doc/man7/provider.pod b/doc/man7/provider.pod
index e9d9c6b7b1..797ef45553 100644
--- a/doc/man7/provider.pod
+++ b/doc/man7/provider.pod
@@ -14,6 +14,8 @@ provider - OpenSSL operation implementation providers
 
 =head2 General
 
+This page contains information useful to provider authors.
+
 A I&lt;provider&gt;, in OpenSSL terms, is a unit of code that provides one
 or more implementations for various operations for diverse algorithms
 that one might want to perform.
@@ -27,9 +29,9 @@ Very often, the algorithms revolve around cryptographic operations,
 but may also revolve around other types of operation, such as managing
 certain types of objects.
 
-=head2 Provider
+See L&lt;crypto(7)&gt; for further details.
 
-I&lt;NOTE: This section is mostly interesting for provider authors.&gt;
+=head2 Provider
 
 A I&lt;provider&gt; offers an initialization function, as a set of base
 functions in the form of an B&lt;OSSL_DISPATCH&gt; array, and by extension,
@@ -90,12 +92,10 @@ implementations.
 The returned B&lt;OSSL_ALGORITHM&gt; is the foundation of any OpenSSL
 library API that uses providers for their implementation, most
 commonly in the I&lt;fetching&gt; type of functions
-(see L&lt;/Fetching algorithms&gt; below).
+(see L&lt;crypto(7)/ALGORITHM FETCHING&gt;).
 
 =head2 Operations
 
-I&lt;NOTE: This section is mostly interesting for provider authors.&gt;
-
 Operations are referred to with numbers, via macros with names
 starting with C&lt;OSSL_OP_&gt;.
 
@@ -170,74 +170,6 @@ L&lt;provider-encoder(7)&gt;
 
 =back
 
-=head2 Fetching algorithms
-
-=head3 Explicit fetch
-
-I&lt;NOTE: This section is mostly interesting to OpenSSL users.&gt;
-
-Users of the OpenSSL libraries never query the provider directly for
-its diverse implementations and dispatch tables.
-Instead, the diverse OpenSSL APIs often have fetching functions that
-do the work, and they return an appropriate method object back to the
-user.
-These functions usually have the name C&lt;APINAME_fetch&gt;, where
-C&lt;APINAME&gt; is the name of the API, for example L&lt;EVP_MD_fetch(3)&gt;.
-
-These fetching functions follow a fairly common pattern, where three
-arguments are passed:
-
-=over 4
-
-=item The library context
-
-See L&lt;OSSL_LIB_CTX(3)&gt; for a more detailed description.
-This may be NULL to signify the default (global) library context, or a
-context created by the user.
-Only providers loaded in this library context (see
-L&lt;OSSL_PROVIDER_load(3)&gt;) will be considered by the fetching
-function. In case no provider has been loaded in this library context
-the default provider will be loaded as fallback (see
-L&lt;OSSL_PROVIDER-default(7)&gt;).
-
-=item An identifier
-
-This is most commonly an algorithm name (this is the case for all EVP
-methods), but may also be called something else.
-
-=for comment For example, an OSSL_STORE implementation would use the
-URI scheme as an identifier.
-
-=item A property query string
-
-See L&lt;property(7)&gt; for a more detailed description.
-This is used to select more exactly which providers will get to offer
-an implementation.
-
-=back
-
-The method object that is fetched can then be used with diverse other
-functions that use them, for example L&lt;EVP_DigestInit_ex(3)&gt;.
-
-=head3 Implicit fetch
-
-I&lt;NOTE: This section is mostly interesting to OpenSSL users.&gt;
-
-OpenSSL has a number of functions that return a method object with no
-associated implementation, such as L&lt;EVP_sha256(3)&gt;,
-L&lt;EVP_blake2b512(3)&gt; or L&lt;EVP_aes_128_cbc(3)&gt;, which are present for
-compatibility with OpenSSL before version 3.0.
-
-When they are used with functions like L&lt;EVP_DigestInit_ex(3)&gt; or
-L&lt;EVP_CipherInit_ex(3)&gt;, the actual implementation to be used is
-fetched implicitly using default search criteria.
-
-Implicit fetching can also occur when a NULL algorithm parameter is
-supplied.
-In this case an algorithm implementation is implicitly fetched using
-default search criteria and an algorithm name that is consistent with
-the type of EVP_PKEY being used.
-
 =head3 Algorithm naming
 
 Algorithm names are case insensitive. Any particular algorithm can have multiple
@@ -262,125 +194,9 @@ use alternative names or names that OpenSSL has used historically.
 
 =head1 OPENSSL PROVIDERS
 
-OpenSSL comes with a set of providers.
-
-The algorithms available in each of these providers may vary due to build time
-configuration options. The L&lt;openssl-list(1)&gt; command can be used to list the
-currently available algorithms.
-
-The names of the algorithms shown from L&lt;openssl-list(1)&gt; can be used as an
-algorithm identifier to the appropriate fetching function.
-
-=head2 Default provider
-
-The default provider is built in as part of the F&lt;libcrypto&gt; library.
-Should it be needed (if other providers are loaded and offer
-implementations of the same algorithms), the property &quot;provider=default&quot;
-can be used as a search criterion for these implementations.  The default
-provider includes all the functionality of the base provider below.
-
-=head2 Base provider
-
-The base provider is built in as part of the F&lt;libcrypto&gt; library.
-Should it be needed (if other providers are loaded and offer
-implementations of the same algorithms), the property &quot;provider=base&quot;
-can be used as a search criterion for these implementations. Some
-non-cryptographic algorithms (such as encoders for loading keys and
-parameters from files) are not FIPS algorithm implementations in themselves but
-support algorithms from the FIPS provider and are allowed for use in &quot;FIPS
-mode&quot;. The property &quot;fips=yes&quot; can be used to select such algorithms.
-
-=head2 FIPS provider
-
-The FIPS provider is a dynamically loadable module, and must therefore
-be loaded explicitly, either in code or through OpenSSL configuration
-(see L&lt;config(5)&gt;).
-Should it be needed (if other providers are loaded and offer
-implementations of the same algorithms), the property &quot;provider=fips&quot; can
-be used as a search criterion for these implementations. All approved algorithm
-implementations in the FIPS provider can also be selected with the property
-&quot;fips=yes&quot;. The FIPS provider also contains a number of non-approved algorithm
-implementations and these can be selected with the property &quot;fips=no&quot;.
-
-=head2 Legacy provider
-
-The legacy provider is a dynamically loadable module, and must therefore
-be loaded explicitly, either in code or through OpenSSL configuration
-(see L&lt;config(5)&gt;).
-Should it be needed (if other providers are loaded and offer
-implementations of the same algorithms), the property &quot;provider=legacy&quot; can be
-used as a search criterion for these implementations.
-
-=head2 Null provider
-
-The null provider is built in as part of the F&lt;libcrypto&gt; library. It contains
-no algorithms in it at all. When fetching algorithms the default provider will
-be automatically loaded if no other provider has been explicitly loaded. To
-prevent that from happening you can explicitly load the null provider.
-
-=head1 EXAMPLES
-
-=head2 Fetching
-
-Fetch any available implementation of SHA2-256 in the default context:
-
- EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA2-256&quot;, NULL);
- ...
- EVP_MD_free(md);
-
-Fetch any available implementation of AES-128-CBC in the default context:
-
- EVP_CIPHER *cipher = EVP_CIPHER_fetch(NULL, &quot;AES-128-CBC&quot;, NULL);
- ...
- EVP_CIPHER_free(cipher);
-
-Fetch an implementation of SHA2-256 from the default provider in the default
-context:
-
- EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA2-256&quot;, &quot;provider=default&quot;);
- ...
- EVP_MD_free(md);
-
-Fetch an implementation of SHA2-256 that is not from the default provider in the
-default context:
-
- EVP_MD *md = EVP_MD_fetch(NULL, &quot;SHA2-256&quot;, &quot;provider!=default&quot;);
- ...
- EVP_MD_free(md);
-
-Fetch an implementation of SHA2-256 from the default provider in the specified
-context:
-
- EVP_MD *md = EVP_MD_fetch(ctx, &quot;SHA2-256&quot;, &quot;provider=default&quot;);
- ...
- EVP_MD_free(md);
-
-Load the legacy provider into the default context and then fetch an
-implementation of WHIRLPOOL from it:
-
- /* This only needs to be done once - usually at application start up */
- OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, &quot;legacy&quot;);
-
- EVP_MD *md = EVP_MD_fetch(NULL, &quot;WHIRLPOOL&quot;, &quot;provider=legacy&quot;);
- ...
- EVP_MD_free(md);
-
-Note that in the above example the property string &quot;provider=legacy&quot; is optional
-since, assuming no other providers have been loaded, the only implementation of
-the &quot;whirlpool&quot; algorithm is in the &quot;legacy&quot; provider. Also note that the
-default provider should be explicitly loaded if it is required in addition to
-other providers:
-
- /* This only needs to be done once - usually at application start up */
- OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, &quot;legacy&quot;);
- OSSL_PROVIDER *default = OSSL_PROVIDER_load(NULL, &quot;default&quot;);
-
- EVP_MD *md_whirlpool = EVP_MD_fetch(NULL, &quot;whirlpool&quot;, NULL);
- EVP_MD *md_sha256 = EVP_MD_fetch(NULL, &quot;SHA2-256&quot;, NULL);
- ...
- EVP_MD_free(md_whirlpool);
- EVP_MD_free(md_sha256);
-
+OpenSSL provides a number of its own providers. These are the default, base,
+fips, legacy and null providers. See L&lt;crypto(7)&gt; for an overview of these
+providers.
 
 =head1 SEE ALSO
 
</PRE>

















<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="033786.html">[openssl]  master update
</A></li>
	<LI>Next message: <A HREF="033788.html">[openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33787">[ date ]</a>
              <a href="thread.html#33787">[ thread ]</a>
              <a href="subject.html#33787">[ subject ]</a>
              <a href="author.html#33787">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
