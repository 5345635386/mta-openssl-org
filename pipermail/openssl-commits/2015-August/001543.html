<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-commits] [openssl]  master update
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-commits/2015-August/index.html" >
   <LINK REL="made" HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1439321699.256684.6586.nullmailer%40dev.openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001540.html">
   <LINK REL="Next"  HREF="001544.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-commits] [openssl]  master update</H1>
    <B>Matt Caswell</B> 
    <A HREF="mailto:openssl-commits%40openssl.org?Subject=Re%3A%20%5Bopenssl-commits%5D%20%5Bopenssl%5D%20%20master%20update&In-Reply-To=%3C1439321699.256684.6586.nullmailer%40dev.openssl.org%3E"
       TITLE="[openssl-commits] [openssl]  master update">matt at openssl.org
       </A><BR>
    <I>Tue Aug 11 19:34:59 UTC 2015</I>
    <P><UL>
        <LI>Previous message: <A HREF="001540.html">[openssl-commits] [openssl]  master update
</A></li>
        <LI>Next message: <A HREF="001544.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1543">[ date ]</a>
              <a href="thread.html#1543">[ thread ]</a>
              <a href="subject.html#1543">[ subject ]</a>
              <a href="author.html#1543">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The branch master has been updated
       via  6142f5c640f98429d4798b8418e8cc2cf6cc1fb8 (commit)
       via  c0cbb4c19bb6e22b338dd17c096be323f7414faf (commit)
       via  c2a34c58f56980b80f034e8295210146b5c247c3 (commit)
       via  a1accbb1d704da9a25b18e7053ee191a8f510d93 (commit)
       via  011467ee55aa82a96cd8a539560c46fd4504a82b (commit)
       via  631c1206334adfb21758220362a56fa157a47596 (commit)
       via  2d5d70b15559f9813054ddb11b30b816daf62ebe (commit)
      from  6a009812b2e249fed01488f6f19f9fbfd9ee74c4 (commit)


- Log -----------------------------------------------------------------
commit 6142f5c640f98429d4798b8418e8cc2cf6cc1fb8
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Aug 11 11:41:51 2015 +0100

    make update
    
    Run a &quot;make update&quot; for the OSSLTest Engine changes
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit c0cbb4c19bb6e22b338dd17c096be323f7414faf
Author: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
Date:   Mon Aug 10 10:46:27 2015 +0100

    Use dynamic engine for libssl test harness
    
    Use a dynamic engine for ossltest engine so that we can build it without
    subsequently deploying it during install. We do not want people accidentally
    using this engine.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;
    Reviewed-by: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;

commit c2a34c58f56980b80f034e8295210146b5c247c3
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Aug 7 14:40:00 2015 +0100

    Add a test for 0 p value in anon DH SKE
    
    When using an anon DH ciphersuite a client should reject a 0 value for p.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit a1accbb1d704da9a25b18e7053ee191a8f510d93
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Fri Aug 7 14:38:21 2015 +0100

    Extend TLSProxy capabilities
    
    Add ServerHello parsing to TLSProxy.
    Also add some (very) limited ServerKeyExchange parsing.
    Add the capability to set client and server cipher lists
    Fix a bug with fragment lengths
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 011467ee55aa82a96cd8a539560c46fd4504a82b
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Jun 16 13:12:37 2015 +0100

    Add some libssl tests
    
    Two tests are added: one is a simple version tolerance test; the second is
    a test to ensure that OpenSSL operates correctly in the case of a zero
    length extensions block. The latter was broken inadvertently (now fixed)
    and it would have been helpful to have a test case for it.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 631c1206334adfb21758220362a56fa157a47596
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Jun 16 13:06:41 2015 +0100

    Add a libssl test harness
    
    This commit provides a set of perl modules that support the testing of
    libssl. The test harness operates as a man-in-the-middle proxy between
    s_server and s_client. Both s_server and s_client must be started using the
    &quot;-testmode&quot; option which loads the new OSSLTEST engine.
    
    The test harness enables scripts to be written that can examine the packets
    sent during a handshake, as well as (potentially) modifying them so that
    otherwise illegal handshake messages can be sent.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

commit 2d5d70b15559f9813054ddb11b30b816daf62ebe
Author: Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>&gt;
Date:   Tue Jun 16 12:59:37 2015 +0100

    Add OSSLTest Engine
    
    This engine is for testing purposes only. It provides crippled crypto
    implementations and therefore must not be used in any instance where
    security is required.
    
    This will be used by the forthcoming libssl test harness which will operate
    as a man-in-the-middle proxy. The test harness will be able to modify
    TLS packets and read their contents. By using this test engine packets are
    not encrypted and MAC codes always verify.
    
    Reviewed-by: Richard Levitte &lt;<A HREF="../../../mailman/listinfo/openssl-commits.html">levitte at openssl.org</A>&gt;

-----------------------------------------------------------------------

Summary of changes:
 engines/Makefile                          |  29 +-
 engines/e_ossltest.c                      | 542 ++++++++++++++++++++++++++++++
 engines/e_ossltest.ec                     |   1 +
 engines/{e_gmp_err.c =&gt; e_ossltest_err.c} |  70 ++--
 engines/{e_gmp_err.h =&gt; e_ossltest_err.h} |  23 +-
 test/Makefile                             |  22 +-
 test/sslextensiontest.pl                  |  89 +++++
 test/sslskewith0ptest.pl                  |  89 +++++
 test/sslvertoltest.pl                     |  93 +++++
 util/TLSProxy/ClientHello.pm              | 272 +++++++++++++++
 util/TLSProxy/Message.pm                  | 457 +++++++++++++++++++++++++
 util/TLSProxy/Proxy.pm                    | 394 ++++++++++++++++++++++
 util/TLSProxy/Record.pm                   | 360 ++++++++++++++++++++
 util/TLSProxy/ServerHello.pm              | 235 +++++++++++++
 util/TLSProxy/ServerKeyExchange.pm        | 176 ++++++++++
 15 files changed, 2796 insertions(+), 56 deletions(-)
 create mode 100644 engines/e_ossltest.c
 create mode 100644 engines/e_ossltest.ec
 copy engines/{e_gmp_err.c =&gt; e_ossltest_err.c} (65%)
 copy engines/{e_gmp_err.h =&gt; e_ossltest_err.h} (80%)
 create mode 100755 test/sslextensiontest.pl
 create mode 100755 test/sslskewith0ptest.pl
 create mode 100755 test/sslvertoltest.pl
 create mode 100644 util/TLSProxy/ClientHello.pm
 create mode 100644 util/TLSProxy/Message.pm
 create mode 100644 util/TLSProxy/Proxy.pm
 create mode 100644 util/TLSProxy/Record.pm
 create mode 100644 util/TLSProxy/ServerHello.pm
 create mode 100644 util/TLSProxy/ServerKeyExchange.pm

diff --git a/engines/Makefile b/engines/Makefile
index e9dc1c4..a1ea0a6 100644
--- a/engines/Makefile
+++ b/engines/Makefile
@@ -32,7 +32,6 @@ GENERAL=Makefile engines.com install.com engine_vector.mar
 
 LIB=$(TOP)/libcrypto.a
 LIBNAMES= 4758cca gmp padlock capi
-
 LIBSRC=	e_4758cca.c \
 	e_gmp.c \
 	e_padlock.c \
@@ -43,6 +42,10 @@ LIBOBJ= e_4758cca.o \
 	e_capi.o \
 	$(ENGINES_ASM_OBJ)
 
+TESTLIBNAMES= ossltest
+TESTLIBSRC= e_ossltest.c
+TESTLIBOBJ= e_ossltest.o
+
 SRC= $(LIBSRC)
 
 HEADER=	e_4758cca_err.c e_4758cca_err.h \
@@ -51,7 +54,8 @@ HEADER=	e_4758cca_err.c e_4758cca_err.h \
 	e_nuron_err.c e_nuron_err.h \
 	e_sureware_err.c e_sureware_err.h \
 	e_ubsec_err.c e_ubsec_err.h \
-	e_capi_err.c e_capi_err.h
+	e_capi_err.c e_capi_err.h \
+	e_ossltest_err.c e_ossltest_err.h
 
 ALL=	$(GENERAL) $(SRC) $(HEADER)
 
@@ -60,10 +64,10 @@ top:
 
 all:	lib subdirs
 
-lib:	$(LIBOBJ)
+lib:	$(LIBOBJ) $(TESTLIBOBJ)
 	@if [ -n &quot;$(SHARED_LIBS)&quot; ]; then \
 		set -e; \
-		for l in $(LIBNAMES); do \
+		for l in $(LIBNAMES) $(TESTLIBNAMES); do \
 			$(MAKE) -f ../Makefile.shared -e \
 				LIBNAME=$$l LIBEXTRAS=&quot;e_$$l*.o&quot; \
 				LIBDEPS='-L.. -lcrypto $(EX_LIBS)' \
@@ -142,7 +146,7 @@ depend: local_depend
 	@if [ -z &quot;$(THIS)&quot; ]; then $(MAKE) -f $(TOP)/Makefile reflect THIS=$@; fi
 	@[ -z &quot;$(THIS)&quot; ] || (set -e; target=depend; $(RECURSIVE_MAKE) )
 local_depend:
-	@[ -z &quot;$(THIS)&quot; ] || $(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC)
+	@[ -z &quot;$(THIS)&quot; ] || $(MAKEDEPEND) -- $(CFLAG) $(INCLUDES) $(DEPFLAG) -- $(PROGS) $(LIBSRC) $(TESTLIBSRC)
 
 dclean:
 	$(PERL) -pe 'if (/^# DO NOT DELETE THIS LINE/) {print; exit(0);}' $(MAKEFILE) &gt;Makefile.new
@@ -196,6 +200,21 @@ e_gmp.o: ../include/openssl/rsa.h ../include/openssl/safestack.h
 e_gmp.o: ../include/openssl/sha.h ../include/openssl/stack.h
 e_gmp.o: ../include/openssl/symhacks.h ../include/openssl/x509.h
 e_gmp.o: ../include/openssl/x509_vfy.h e_gmp.c
+e_ossltest.o: ../include/openssl/aes.h ../include/openssl/asn1.h
+e_ossltest.o: ../include/openssl/bio.h ../include/openssl/buffer.h
+e_ossltest.o: ../include/openssl/crypto.h ../include/openssl/e_os2.h
+e_ossltest.o: ../include/openssl/ec.h ../include/openssl/ecdh.h
+e_ossltest.o: ../include/openssl/ecdsa.h ../include/openssl/engine.h
+e_ossltest.o: ../include/openssl/err.h ../include/openssl/evp.h
+e_ossltest.o: ../include/openssl/lhash.h ../include/openssl/md5.h
+e_ossltest.o: ../include/openssl/modes.h ../include/openssl/obj_mac.h
+e_ossltest.o: ../include/openssl/objects.h ../include/openssl/opensslconf.h
+e_ossltest.o: ../include/openssl/opensslv.h ../include/openssl/ossl_typ.h
+e_ossltest.o: ../include/openssl/pkcs7.h ../include/openssl/rsa.h
+e_ossltest.o: ../include/openssl/safestack.h ../include/openssl/sha.h
+e_ossltest.o: ../include/openssl/stack.h ../include/openssl/symhacks.h
+e_ossltest.o: ../include/openssl/x509.h ../include/openssl/x509_vfy.h
+e_ossltest.o: e_ossltest.c e_ossltest_err.c e_ossltest_err.h
 e_padlock.o: ../include/openssl/aes.h ../include/openssl/asn1.h
 e_padlock.o: ../include/openssl/bio.h ../include/openssl/buffer.h
 e_padlock.o: ../include/openssl/crypto.h ../include/openssl/dso.h
diff --git a/engines/e_ossltest.c b/engines/e_ossltest.c
new file mode 100644
index 0000000..6e50a5f
--- /dev/null
+++ b/engines/e_ossltest.c
@@ -0,0 +1,542 @@
+/* engines/e_ossltest.c */
+/*
+ * Written by Matt Caswell (<A HREF="../../../mailman/listinfo/openssl-commits.html">matt at openssl.org</A>) for the OpenSSL project.
+ */
+/* ====================================================================
+ * Copyright (c) 2015 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
+ *
+ * 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    <A HREF="../../../mailman/listinfo/openssl-commits.html">licensing at OpenSSL.org.</A>
+ *
+ * 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+ *    nor may &quot;OpenSSL&quot; appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    &quot;This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (<A HREF="http://www.OpenSSL.org/">http://www.OpenSSL.org/</A>)&quot;
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+
+/*
+ * This is the OSSLTEST engine. It provides deliberately crippled digest
+ * implementations for test purposes. It is highly insecure and must NOT be
+ * used for any purpose except testing
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;openssl/engine.h&gt;
+#include &lt;openssl/sha.h&gt;
+#include &lt;openssl/md5.h&gt;
+#include &lt;openssl/rsa.h&gt;
+#include &lt;openssl/evp.h&gt;
+#include &lt;openssl/modes.h&gt;
+#include &lt;openssl/aes.h&gt;
+
+#define OSSLTEST_LIB_NAME &quot;OSSLTEST&quot;
+#include &quot;e_ossltest_err.c&quot;
+
+/* Engine Id and Name */
+static const char *engine_ossltest_id = &quot;ossltest&quot;;
+static const char *engine_ossltest_name = &quot;OpenSSL Test engine support&quot;;
+
+
+/* Engine Lifetime functions */
+static int ossltest_destroy(ENGINE *e);
+static int ossltest_init(ENGINE *e);
+static int ossltest_finish(ENGINE *e);
+void ENGINE_load_ossltest(void);
+
+
+/* Set up digests */
+static int ossltest_digests(ENGINE *e, const EVP_MD **digest,
+                          const int **nids, int nid);
+
+static int ossltest_digest_nids[] = {
+    NID_md5, NID_sha1, NID_sha256, NID_sha384, NID_sha512, 0
+};
+
+/* MD5 */
+static int digest_md5_init(EVP_MD_CTX *ctx);
+static int digest_md5_update(EVP_MD_CTX *ctx, const void *data,
+                             unsigned long count);
+static int digest_md5_final(EVP_MD_CTX *ctx, unsigned char *md);
+
+static const EVP_MD digest_md5 = {
+    NID_md5,
+    NID_md5WithRSAEncryption,
+    MD5_DIGEST_LENGTH,
+    0,
+    digest_md5_init,
+    digest_md5_update,
+    digest_md5_final,
+    NULL,
+    NULL,
+    EVP_PKEY_RSA_method,
+    MD5_CBLOCK,
+    sizeof(EVP_MD *) + sizeof(MD5_CTX),
+};
+
+/* SHA1 */
+static int digest_sha1_init(EVP_MD_CTX *ctx);
+static int digest_sha1_update(EVP_MD_CTX *ctx, const void *data,
+                             unsigned long count);
+static int digest_sha1_final(EVP_MD_CTX *ctx, unsigned char *md);
+
+static const EVP_MD digest_sha1 = {
+    NID_sha1,
+    NID_sha1WithRSAEncryption,
+    SHA_DIGEST_LENGTH,
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE | EVP_MD_FLAG_DIGALGID_ABSENT,
+    digest_sha1_init,
+    digest_sha1_update,
+    digest_sha1_final,
+    NULL,
+    NULL,
+    EVP_PKEY_NULL_method,
+    SHA_CBLOCK,
+    sizeof(EVP_MD *) + sizeof(SHA_CTX),
+};
+
+/* SHA256 */
+static int digest_sha256_init(EVP_MD_CTX *ctx);
+static int digest_sha256_update(EVP_MD_CTX *ctx, const void *data,
+                             unsigned long count);
+static int digest_sha256_final(EVP_MD_CTX *ctx, unsigned char *md);
+
+static const EVP_MD digest_sha256 = {
+    NID_sha256,
+    NID_sha256WithRSAEncryption,
+    SHA256_DIGEST_LENGTH,
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE | EVP_MD_FLAG_DIGALGID_ABSENT,
+    digest_sha256_init,
+    digest_sha256_update,
+    digest_sha256_final,
+    NULL,
+    NULL,
+    EVP_PKEY_NULL_method,
+    SHA256_CBLOCK,
+    sizeof(EVP_MD *) + sizeof(SHA256_CTX),
+};
+
+/* SHA384/SHA512 */
+static int digest_sha384_init(EVP_MD_CTX *ctx);
+static int digest_sha512_init(EVP_MD_CTX *ctx);
+static int digest_sha512_update(EVP_MD_CTX *ctx, const void *data,
+                             unsigned long count);
+static int digest_sha384_final(EVP_MD_CTX *ctx, unsigned char *md);
+static int digest_sha512_final(EVP_MD_CTX *ctx, unsigned char *md);
+
+static const EVP_MD digest_sha384 = {
+    NID_sha384,
+    NID_sha384WithRSAEncryption,
+    SHA384_DIGEST_LENGTH,
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE | EVP_MD_FLAG_DIGALGID_ABSENT,
+    digest_sha384_init,
+    digest_sha512_update,
+    digest_sha384_final,
+    NULL,
+    NULL,
+    EVP_PKEY_NULL_method,
+    SHA512_CBLOCK,
+    sizeof(EVP_MD *) + sizeof(SHA512_CTX),
+};
+
+static const EVP_MD digest_sha512 = {
+    NID_sha512,
+    NID_sha512WithRSAEncryption,
+    SHA512_DIGEST_LENGTH,
+    EVP_MD_FLAG_PKEY_METHOD_SIGNATURE | EVP_MD_FLAG_DIGALGID_ABSENT,
+    digest_sha512_init,
+    digest_sha512_update,
+    digest_sha512_final,
+    NULL,
+    NULL,
+    EVP_PKEY_NULL_method,
+    SHA512_CBLOCK,
+    sizeof(EVP_MD *) + sizeof(SHA512_CTX),
+};
+
+/* Setup ciphers */
+static int ossltest_ciphers(ENGINE *, const EVP_CIPHER **,
+                            const int **, int);
+
+static int ossltest_cipher_nids[] = {
+    NID_aes_128_cbc, 0
+};
+
+/* AES128 */
+
+int ossltest_aes128_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+                             const unsigned char *iv, int enc);
+int ossltest_aes128_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                               const unsigned char *in, size_t inl);
+
+/*
+ * Copy of the definition in crypto/evp/e_aes.c. Only used for the &quot;sizeof&quot;
+ * below
+ */
+typedef struct {
+    union {
+        double align;
+        AES_KEY ks;
+    } ks;
+    block128_f block;
+    union {
+        cbc128_f cbc;
+        ctr128_f ctr;
+    } stream;
+} EVP_AES_KEY;
+
+
+static const EVP_CIPHER ossltest_aes_128_cbc = { \
+    NID_aes_128_cbc,
+    16, /* block size */
+    16, /* key len */
+    16, /* iv len */
+    EVP_CIPH_FLAG_DEFAULT_ASN1 | EVP_CIPH_CBC_MODE,
+    ossltest_aes128_init_key,
+    ossltest_aes128_cbc_cipher,
+    NULL,
+    sizeof(EVP_AES_KEY),
+    NULL,NULL,NULL,NULL
+};
+
+
+static int bind_ossltest(ENGINE *e)
+{
+    /* Ensure the ossltest error handling is set up */
+    ERR_load_OSSLTEST_strings();
+
+    if (!ENGINE_set_id(e, engine_ossltest_id)
+        || !ENGINE_set_name(e, engine_ossltest_name)
+        || !ENGINE_set_digests(e, ossltest_digests)
+        || !ENGINE_set_ciphers(e, ossltest_ciphers)
+        || !ENGINE_set_destroy_function(e, ossltest_destroy)
+        || !ENGINE_set_init_function(e, ossltest_init)
+        || !ENGINE_set_finish_function(e, ossltest_finish)) {
+        OSSLTESTerr(OSSLTEST_F_BIND_OSSLTEST, OSSLTEST_R_INIT_FAILED);
+        return 0;
+    }
+
+    return 1;
+}
+
+#ifndef OPENSSL_NO_DYNAMIC_ENGINE
+static int bind_helper(ENGINE *e, const char *id)
+{
+    if (id &amp;&amp; (strcmp(id, engine_ossltest_id) != 0))
+        return 0;
+    if (!bind_ossltest(e))
+        return 0;
+    return 1;
+}
+
+IMPLEMENT_DYNAMIC_CHECK_FN()
+    IMPLEMENT_DYNAMIC_BIND_FN(bind_helper)
+#endif
+
+static ENGINE *engine_ossltest(void)
+{
+    ENGINE *ret = ENGINE_new();
+    if (!ret)
+        return NULL;
+    if (!bind_ossltest(ret)) {
+        ENGINE_free(ret);
+        return NULL;
+    }
+    return ret;
+}
+
+void ENGINE_load_ossltest(void)
+{
+    /* Copied from eng_[openssl|dyn].c */
+    ENGINE *toadd = engine_ossltest();
+    if (!toadd)
+        return;
+    ENGINE_add(toadd);
+    ENGINE_free(toadd);
+    ERR_clear_error();
+}
+
+
+static int ossltest_init(ENGINE *e)
+{
+    return 1;
+}
+
+
+static int ossltest_finish(ENGINE *e)
+{
+    return 1;
+}
+
+
+static int ossltest_destroy(ENGINE *e)
+{
+    ERR_unload_OSSLTEST_strings();
+    return 1;
+}
+
+static int ossltest_digests(ENGINE *e, const EVP_MD **digest,
+                          const int **nids, int nid)
+{
+    int ok = 1;
+    if (!digest) {
+        /* We are returning a list of supported nids */
+        *nids = ossltest_digest_nids;
+        return (sizeof(ossltest_digest_nids) -
+                1) / sizeof(ossltest_digest_nids[0]);
+    }
+    /* We are being asked for a specific digest */
+    switch (nid) {
+    case NID_md5:
+        *digest = &amp;digest_md5;
+        break;
+    case NID_sha1:
+        *digest = &amp;digest_sha1;
+        break;
+    case NID_sha256:
+        *digest = &amp;digest_sha256;
+        break;
+    case NID_sha384:
+        *digest = &amp;digest_sha384;
+        break;
+    case NID_sha512:
+        *digest = &amp;digest_sha512;
+        break;
+    default:
+        ok = 0;
+        *digest = NULL;
+        break;
+    }
+    return ok;
+}
+
+static int ossltest_ciphers(ENGINE *e, const EVP_CIPHER **cipher,
+                          const int **nids, int nid)
+{
+    int ok = 1;
+    if (!cipher) {
+        /* We are returning a list of supported nids */
+        *nids = ossltest_cipher_nids;
+        return (sizeof(ossltest_cipher_nids) - 1)
+               / sizeof(ossltest_cipher_nids[0]);
+    }
+    /* We are being asked for a specific cipher */
+    switch (nid) {
+    case NID_aes_128_cbc:
+        *cipher = &amp;ossltest_aes_128_cbc;
+        break;
+    default:
+        ok = 0;
+        *cipher = NULL;
+        break;
+    }
+    return ok;
+}
+
+static void fill_known_data(unsigned char *md, unsigned int len)
+{
+    unsigned int i;
+
+    for (i=0; i&lt;len; i++) {
+        md[i] = (unsigned char)(i &amp; 0xff);
+    }
+}
+
+/*
+ * MD5 implementation. We go through the motions of doing MD5 by deferring to
+ * the standard implementation. Then we overwrite the result with a will defined
+ * value, so that all &quot;MD5&quot; digests using the test engine always end up with
+ * the same value.
+ */
+#undef data
+#define data(ctx) ((MD5_CTX *)(ctx)-&gt;md_data)
+static int digest_md5_init(EVP_MD_CTX *ctx)
+{
+    return MD5_Init(data(ctx));
+}
+
+static int digest_md5_update(EVP_MD_CTX *ctx, const void *data,
+          unsigned long count)
+{
+    return MD5_Update(data(ctx), data, (size_t)count);
+}
+
+static int digest_md5_final(EVP_MD_CTX *ctx, unsigned char *md)
+{
+    int ret;
+    ret = MD5_Final(md, data(ctx));
+
+    if (ret &gt; 0) {
+        fill_known_data(md, MD5_DIGEST_LENGTH);
+    }
+    return ret;
+}
+
+/*
+ * SHA1 implementation.
+ */
+#undef data
+#define data(ctx) ((SHA_CTX *)(ctx)-&gt;md_data)
+static int digest_sha1_init(EVP_MD_CTX *ctx)
+{
+    return SHA1_Init(data(ctx));
+}
+
+static int digest_sha1_update(EVP_MD_CTX *ctx, const void *data,
+                             unsigned long count)
+{
+    return SHA1_Update(data(ctx), data, (size_t)count);
+}
+
+static int digest_sha1_final(EVP_MD_CTX *ctx, unsigned char *md)
+{
+    int ret;
+    ret = SHA1_Final(md, data(ctx));
+
+    if (ret &gt; 0) {
+        fill_known_data(md, SHA_DIGEST_LENGTH);
+    }
+    return ret;
+}
+
+/*
+ * SHA256 implementation.
+ */
+#undef data
+#define data(ctx) ((SHA256_CTX *)(ctx)-&gt;md_data)
+static int digest_sha256_init(EVP_MD_CTX *ctx)
+{
+    return SHA256_Init(data(ctx));
+}
+
+static int digest_sha256_update(EVP_MD_CTX *ctx, const void *data,
+                             unsigned long count)
+{
+    return SHA256_Update(data(ctx), data, (size_t)count);
+}
+
+static int digest_sha256_final(EVP_MD_CTX *ctx, unsigned char *md)
+{
+    int ret;
+    ret = SHA256_Final(md, data(ctx));
+
+    if (ret &gt; 0) {
+        fill_known_data(md, SHA256_DIGEST_LENGTH);
+    }
+    return ret;
+}
+
+/*
+ * SHA384/512 implementation.
+ */
+#undef data
+#define data(ctx) ((SHA512_CTX *)(ctx)-&gt;md_data)
+static int digest_sha384_init(EVP_MD_CTX *ctx)
+{
+    return SHA384_Init(data(ctx));
+}
+
+static int digest_sha512_init(EVP_MD_CTX *ctx)
+{
+    return SHA512_Init(data(ctx));
+}
+
+static int digest_sha512_update(EVP_MD_CTX *ctx, const void *data,
+                             unsigned long count)
+{
+    return SHA512_Update(data(ctx), data, (size_t)count);
+}
+
+static int digest_sha384_final(EVP_MD_CTX *ctx, unsigned char *md)
+{
+    int ret;
+    /* Actually uses SHA512_Final! */
+    ret = SHA512_Final(md, data(ctx));
+
+    if (ret &gt; 0) {
+        fill_known_data(md, SHA384_DIGEST_LENGTH);
+    }
+    return ret;
+}
+
+static int digest_sha512_final(EVP_MD_CTX *ctx, unsigned char *md)
+{
+    int ret;
+    ret = SHA512_Final(md, data(ctx));
+
+    if (ret &gt; 0) {
+        fill_known_data(md, SHA512_DIGEST_LENGTH);
+    }
+    return ret;
+}
+
+/*
+ * AES128 Implementation
+ */
+
+int ossltest_aes128_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,
+                             const unsigned char *iv, int enc)
+{
+    return EVP_aes_128_cbc()-&gt;init(ctx, key, iv, enc);
+}
+
+int ossltest_aes128_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,
+                               const unsigned char *in, size_t inl)
+{
+    unsigned char *tmpbuf;
+    int ret;
+
+    tmpbuf = OPENSSL_malloc(inl);
+    if (tmpbuf == NULL)
+        return -1;
+
+    /* Remember what we were asked to encrypt */
+    memcpy(tmpbuf, in, inl);
+
+    /* Go through the motions of encrypting it */
+    ret = EVP_aes_128_cbc()-&gt;do_cipher(ctx, out, in, inl);
+
+    /* Throw it all away and just use the plaintext as the output */
+    memcpy(out, tmpbuf, inl);
+    OPENSSL_free(tmpbuf);
+
+    return ret;
+}
diff --git a/engines/e_ossltest.ec b/engines/e_ossltest.ec
new file mode 100644
index 0000000..d8a1bef
--- /dev/null
+++ b/engines/e_ossltest.ec
@@ -0,0 +1 @@
+L       OSSLTEST    e_ossltest_err.h e_ossltest_err.c
diff --git a/engines/e_gmp_err.c b/engines/e_ossltest_err.c
similarity index 65%
copy from engines/e_gmp_err.c
copy to engines/e_ossltest_err.c
index 002a3ab..c1b0063 100644
--- a/engines/e_gmp_err.c
+++ b/engines/e_ossltest_err.c
@@ -1,6 +1,6 @@
-/* e_gmp_err.c */
+/* e_ossltest_err.c */
 /* ====================================================================
- * Copyright (c) 1999-2005 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 1999-2015 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -61,7 +61,7 @@
 
 #include &lt;stdio.h&gt;
 #include &lt;openssl/err.h&gt;
-#include &quot;e_gmp_err.h&quot;
+#include &quot;e_ossltest_err.h&quot;
 
 /* BEGIN ERROR CODES */
 #ifndef OPENSSL_NO_ERR
@@ -69,69 +69,65 @@
 # define ERR_FUNC(func) ERR_PACK(0,func,0)
 # define ERR_REASON(reason) ERR_PACK(0,0,reason)
 
-static ERR_STRING_DATA GMP_str_functs[] = {
-    {ERR_FUNC(GMP_F_E_GMP_CTRL), &quot;E_GMP_CTRL&quot;},
-    {ERR_FUNC(GMP_F_E_GMP_RSA_MOD_EXP), &quot;E_GMP_RSA_MOD_EXP&quot;},
+static ERR_STRING_DATA OSSLTEST_str_functs[] = {
+    {ERR_FUNC(OSSLTEST_F_BIND_OSSLTEST), &quot;BIND_OSSLTEST&quot;},
     {0, NULL}
 };
 
-static ERR_STRING_DATA GMP_str_reasons[] = {
-    {ERR_REASON(GMP_R_CTRL_COMMAND_NOT_IMPLEMENTED),
-     &quot;ctrl command not implemented&quot;},
-    {ERR_REASON(GMP_R_KEY_CONTEXT_ERROR), &quot;key context error&quot;},
-    {ERR_REASON(GMP_R_MISSING_KEY_COMPONENTS), &quot;missing key components&quot;},
+static ERR_STRING_DATA OSSLTEST_str_reasons[] = {
+    {ERR_REASON(OSSLTEST_R_INIT_FAILED), &quot;init failed&quot;},
     {0, NULL}
 };
 
 #endif
 
-#ifdef GMP_LIB_NAME
-static ERR_STRING_DATA GMP_lib_name[] = {
-    {0, GMP_LIB_NAME},
+#ifdef OSSLTEST_LIB_NAME
+static ERR_STRING_DATA OSSLTEST_lib_name[] = {
+    {0, OSSLTEST_LIB_NAME},
     {0, NULL}
 };
 #endif
 
-static int GMP_lib_error_code = 0;
-static int GMP_error_init = 1;
+static int OSSLTEST_lib_error_code = 0;
+static int OSSLTEST_error_init = 1;
 
-static void ERR_load_GMP_strings(void)
+static void ERR_load_OSSLTEST_strings(void)
 {
-    if (GMP_lib_error_code == 0)
-        GMP_lib_error_code = ERR_get_next_error_library();
+    if (OSSLTEST_lib_error_code == 0)
+        OSSLTEST_lib_error_code = ERR_get_next_error_library();
 
-    if (GMP_error_init) {
-        GMP_error_init = 0;
+    if (OSSLTEST_error_init) {
+        OSSLTEST_error_init = 0;
 #ifndef OPENSSL_NO_ERR
-        ERR_load_strings(GMP_lib_error_code, GMP_str_functs);
-        ERR_load_strings(GMP_lib_error_code, GMP_str_reasons);
+        ERR_load_strings(OSSLTEST_lib_error_code, OSSLTEST_str_functs);
+        ERR_load_strings(OSSLTEST_lib_error_code, OSSLTEST_str_reasons);
 #endif
 
-#ifdef GMP_LIB_NAME
-        GMP_lib_name-&gt;error = ERR_PACK(GMP_lib_error_code, 0, 0);
-        ERR_load_strings(0, GMP_lib_name);
+#ifdef OSSLTEST_LIB_NAME
+        OSSLTEST_lib_name-&gt;error = ERR_PACK(OSSLTEST_lib_error_code, 0, 0);
+        ERR_load_strings(0, OSSLTEST_lib_name);
 #endif
     }
 }
 
-static void ERR_unload_GMP_strings(void)
+static void ERR_unload_OSSLTEST_strings(void)
 {
-    if (GMP_error_init == 0) {
+    if (OSSLTEST_error_init == 0) {
 #ifndef OPENSSL_NO_ERR
-        ERR_unload_strings(GMP_lib_error_code, GMP_str_functs);
-        ERR_unload_strings(GMP_lib_error_code, GMP_str_reasons);
+        ERR_unload_strings(OSSLTEST_lib_error_code, OSSLTEST_str_functs);
+        ERR_unload_strings(OSSLTEST_lib_error_code, OSSLTEST_str_reasons);
 #endif
 
-#ifdef GMP_LIB_NAME
-        ERR_unload_strings(0, GMP_lib_name);
+#ifdef OSSLTEST_LIB_NAME
+        ERR_unload_strings(0, OSSLTEST_lib_name);
 #endif
-        GMP_error_init = 1;
+        OSSLTEST_error_init = 1;
     }
 }
 
-static void ERR_GMP_error(int function, int reason, char *file, int line)
+static void ERR_OSSLTEST_error(int function, int reason, char *file, int line)
 {
-    if (GMP_lib_error_code == 0)
-        GMP_lib_error_code = ERR_get_next_error_library();
-    ERR_PUT_error(GMP_lib_error_code, function, reason, file, line);
+    if (OSSLTEST_lib_error_code == 0)
+        OSSLTEST_lib_error_code = ERR_get_next_error_library();
+    ERR_PUT_error(OSSLTEST_lib_error_code, function, reason, file, line);
 }
diff --git a/engines/e_gmp_err.h b/engines/e_ossltest_err.h
similarity index 80%
copy from engines/e_gmp_err.h
copy to engines/e_ossltest_err.h
index 637abbc..8f874e0 100644
--- a/engines/e_gmp_err.h
+++ b/engines/e_ossltest_err.h
@@ -1,5 +1,5 @@
 /* ====================================================================
- * Copyright (c) 2001-2002 The OpenSSL Project.  All rights reserved.
+ * Copyright (c) 2015 The OpenSSL Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -52,8 +52,8 @@
  *
  */
 
-#ifndef HEADER_GMP_ERR_H
-# define HEADER_GMP_ERR_H
+#ifndef HEADER_OSSLTEST_ERR_H
+# define HEADER_OSSLTEST_ERR_H
 
 #ifdef  __cplusplus
 extern &quot;C&quot; {
@@ -64,21 +64,18 @@ extern &quot;C&quot; {
  * The following lines are auto generated by the script mkerr.pl. Any changes
  * made after this point may be overwritten when the script is next run.
  */
-static void ERR_load_GMP_strings(void);
-static void ERR_unload_GMP_strings(void);
-static void ERR_GMP_error(int function, int reason, char *file, int line);
-# define GMPerr(f,r) ERR_GMP_error((f),(r),__FILE__,__LINE__)
+static void ERR_load_OSSLTEST_strings(void);
+static void ERR_unload_OSSLTEST_strings(void);
+static void ERR_OSSLTEST_error(int function, int reason, char *file, int line);
+# define OSSLTESTerr(f,r) ERR_OSSLTEST_error((f),(r),__FILE__,__LINE__)
 
-/* Error codes for the GMP functions. */
+/* Error codes for the OSSLTEST functions. */
 
 /* Function codes. */
-# define GMP_F_E_GMP_CTRL                                 100
-# define GMP_F_E_GMP_RSA_MOD_EXP                          101
+# define OSSLTEST_F_BIND_OSSLTEST                         100
 
 /* Reason codes. */
-# define GMP_R_CTRL_COMMAND_NOT_IMPLEMENTED               100
-# define GMP_R_KEY_CONTEXT_ERROR                          101
-# define GMP_R_MISSING_KEY_COMPONENTS                     102
+# define OSSLTEST_R_INIT_FAILED                           100
 
 #ifdef  __cplusplus
 }
diff --git a/test/Makefile b/test/Makefile
index f49dc76..31b3796 100644
--- a/test/Makefile
+++ b/test/Makefile
@@ -71,6 +71,9 @@ CONSTTIMETEST=  constant_time_test
 VERIFYEXTRATEST=	verify_extra_test
 CLIENTHELLOTEST=	clienthellotest
 PACKETTEST=	packettest
+SSLVERTOLTEST=	sslvertoltest.pl
+SSLEXTENSIONTEST=	sslextensiontest.pl
+SSLSKEWITH0PTEST=	sslskewith0ptest.pl
 
 TESTS=		alltests
 
@@ -156,7 +159,8 @@ alltests: \
 	test_ige test_jpake test_secmem \
 	test_srp test_cms test_v3name test_ocsp \
 	test_gost2814789 test_heartbeat test_p5_crpt2 \
-	test_constant_time test_verify_extra test_clienthello test_packet
+	test_constant_time test_verify_extra test_clienthello test_packet \
+	test_sslvertol test_sslextension test_sslskewith0p
 
 test_evp: $(EVPTEST)$(EXE_EXT) evptests.txt
 	@echo $(START) $@
@@ -417,6 +421,22 @@ test_packet: $(PACKETTEST)$(EXE_EXT)
 	@echo $(START) $@
 	../util/shlib_wrap.sh ./$(PACKETTEST)
 
+#OPENSSL_ia32cap=... in ssl tests below ensures AES-NI is switched off (AES-NI does not go through the testmode engine)
+test_sslvertol: ../apps/openssl$(EXE_EXT)
+	@echo $(START) $@
+	[ -z &quot;$(SHARED_LIBS)&quot; ] || PERL5LIB=$$PERL5LIB:../util OPENSSL_ENGINES=../engines ../util/shlib_wrap.sh ./$(SSLVERTOLTEST) &quot;OPENSSL_ia32cap='~0x200000200000000' ../apps/openssl$(EXE_EXT)&quot; ../apps/server.pem
+	@[ -n &quot;$(SHARED_LIBS)&quot; ] || echo test_sslvertol can only be performed with OpenSSL configured shared
+
+test_sslextension: ../apps/openssl$(EXE_EXT)
+	@echo $(START) $@
+	[ -z &quot;$(SHARED_LIBS)&quot; ] || PERL5LIB=$$PERL5LIB:../util OPENSSL_ENGINES=../engines ../util/shlib_wrap.sh ./$(SSLEXTENSIONTEST) &quot;OPENSSL_ia32cap='~0x200000200000000' ../apps/openssl$(EXE_EXT)&quot; ../apps/server.pem
+	@[ -n &quot;$(SHARED_LIBS)&quot; ] || echo test_sslextension can only be performed with OpenSSL configured shared
+
+test_sslskewith0p: ../apps/openssl$(EXE_EXT)
+	@echo $(START) $@
+	[ -z &quot;$(SHARED_LIBS)&quot; ] || PERL5LIB=$$PERL5LIB:../util OPENSSL_ENGINES=../engines ../util/shlib_wrap.sh ./$(SSLSKEWITH0PTEST) &quot;OPENSSL_ia32cap='~0x200000200000000' ../apps/openssl$(EXE_EXT)&quot; ../apps/server.pem
+	@[ -n &quot;$(SHARED_LIBS)&quot; ] || echo test_sslskewith0p can only be performed with OpenSSL configured shared
+
 update: local_depend
 	@if [ -z &quot;$(THIS)&quot; ]; then $(MAKE) -f $(TOP)/Makefile reflect THIS=$@; fi
 
diff --git a/test/sslextensiontest.pl b/test/sslextensiontest.pl
new file mode 100755
index 0000000..802bac1
--- /dev/null
+++ b/test/sslextensiontest.pl
@@ -0,0 +1,89 @@
+#!/usr/bin/perl
+# Written by Matt Caswell for the OpenSSL project.
+# ====================================================================
+# Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# 3. All advertising materials mentioning features or use of this
+#    software must display the following acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+#    endorse or promote products derived from this software without
+#    prior written permission. For written permission, please contact
+#    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+#
+# 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+#    nor may &quot;OpenSSL&quot; appear in their names without prior written
+#    permission of the OpenSSL Project.
+#
+# 6. Redistributions of any form whatsoever must retain the following
+#    acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+# ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGE.
+# ====================================================================
+#
+# This product includes cryptographic software written by Eric Young
+# (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+# Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+
+use strict;
+use TLSProxy::Proxy;
+
+my $proxy = TLSProxy::Proxy-&gt;new(
+    \&amp;extension_filter,
+    @ARGV
+);
+
+#Test 1: Sending a zero length extension block should pass
+$proxy-&gt;start();
+TLSProxy::Message-&gt;success or die &quot;FAILED: Zero extension length test\n&quot;;
+
+print &quot;SUCCESS: Extension test\n&quot;;
+
+sub extension_filter
+{
+    my $proxy = shift;
+
+    # We're only interested in the initial ClientHello
+    if ($proxy-&gt;flight != 0) {
+        return;
+    }
+
+    foreach my $message (@{$proxy-&gt;message_list}) {
+        if ($message-&gt;mt == TLSProxy::Message::MT_CLIENT_HELLO) {
+            #Remove all extensions and set the extension len to zero
+            $message-&gt;extension_data({});
+            $message-&gt;extensions_len(0);
+            #Extensions have been removed so make sure we don't try to use them
+            $message-&gt;process_extensions();
+
+            $message-&gt;repack();
+        }
+    }
+}
diff --git a/test/sslskewith0ptest.pl b/test/sslskewith0ptest.pl
new file mode 100755
index 0000000..63f8398
--- /dev/null
+++ b/test/sslskewith0ptest.pl
@@ -0,0 +1,89 @@
+#!/usr/bin/perl
+# Written by Matt Caswell for the OpenSSL project.
+# ====================================================================
+# Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# 3. All advertising materials mentioning features or use of this
+#    software must display the following acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+#    endorse or promote products derived from this software without
+#    prior written permission. For written permission, please contact
+#    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+#
+# 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+#    nor may &quot;OpenSSL&quot; appear in their names without prior written
+#    permission of the OpenSSL Project.
+#
+# 6. Redistributions of any form whatsoever must retain the following
+#    acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+# ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGE.
+# ====================================================================
+#
+# This product includes cryptographic software written by Eric Young
+# (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+# Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+
+use strict;
+use TLSProxy::Proxy;
+
+my $proxy = TLSProxy::Proxy-&gt;new(
+    \&amp;ske_0_p_filter,
+    @ARGV
+);
+
+#We must use an anon DHE cipher for this test
+$proxy-&gt;cipherc('ADH-AES128-SHA:@SECLEVEL=0');
+$proxy-&gt;ciphers('ADH-AES128-SHA:@SECLEVEL=0');
+
+$proxy-&gt;start();
+TLSProxy::Message-&gt;fail or die &quot;FAILED: ServerKeyExchange with 0 p\n&quot;;
+
+print &quot;SUCCESS: ServerKeyExchange with 0 p\n&quot;;
+
+sub ske_0_p_filter
+{
+    my $proxy = shift;
+
+    # We're only interested in the SKE - always in flight 1
+    if ($proxy-&gt;flight != 1) {
+        return;
+    }
+
+    foreach my $message (@{$proxy-&gt;message_list}) {
+        if ($message-&gt;mt == TLSProxy::Message::MT_SERVER_KEY_EXCHANGE) {
+            #Set p to a value of 0
+            $message-&gt;p(pack('C', 0));
+
+            $message-&gt;repack();
+        }
+    }
+}
diff --git a/test/sslvertoltest.pl b/test/sslvertoltest.pl
new file mode 100755
index 0000000..1828a7d
--- /dev/null
+++ b/test/sslvertoltest.pl
@@ -0,0 +1,93 @@
+#!/usr/bin/perl
+# Written by Matt Caswell for the OpenSSL project.
+# ====================================================================
+# Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# 3. All advertising materials mentioning features or use of this
+#    software must display the following acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+#    endorse or promote products derived from this software without
+#    prior written permission. For written permission, please contact
+#    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+#
+# 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+#    nor may &quot;OpenSSL&quot; appear in their names without prior written
+#    permission of the OpenSSL Project.
+#
+# 6. Redistributions of any form whatsoever must retain the following
+#    acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+# ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGE.
+# ====================================================================
+#
+# This product includes cryptographic software written by Eric Young
+# (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+# Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+
+use strict;
+use TLSProxy::Proxy;
+
+my $proxy = TLSProxy::Proxy-&gt;new(
+    \&amp;vers_tolerance_filter,
+    @ARGV
+);
+
+#Test 1: Asking for TLS1.3 should pass
+my $client_version = TLSProxy::Record::VERS_TLS_1_3;
+$proxy-&gt;start();
+TLSProxy::Message-&gt;success or die &quot;FAILED: Version tolerance test\n&quot;;
+
+#Test 2: Testing something below SSLv3 should fail
+$client_version = TLSProxy::Record::VERS_SSL_3_0 - 1;
+$proxy-&gt;restart();
+TLSProxy::Message-&gt;success and die &quot;FAILED: Version tolerance test\n&quot;;
+
+print &quot;SUCCESS: Version tolerance test\n&quot;;
+
+sub vers_tolerance_filter
+{
+    my $proxy = shift;
+
+    # We're only interested in the initial ClientHello
+    if ($proxy-&gt;flight != 0) {
+        return;
+    }
+
+    foreach my $message (@{$proxy-&gt;message_list}) {
+        if ($message-&gt;mt == TLSProxy::Message::MT_CLIENT_HELLO) {
+            #Set the client version
+            #Anything above the max supported version (TLS1.2) should succeed
+            #Anything below SSLv3 should fail
+            $message-&gt;client_version($client_version);
+            $message-&gt;repack();
+        }
+    }
+}
diff --git a/util/TLSProxy/ClientHello.pm b/util/TLSProxy/ClientHello.pm
new file mode 100644
index 0000000..54fb5bb
--- /dev/null
+++ b/util/TLSProxy/ClientHello.pm
@@ -0,0 +1,272 @@
+# Written by Matt Caswell for the OpenSSL project.
+# ====================================================================
+# Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# 3. All advertising materials mentioning features or use of this
+#    software must display the following acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+#    endorse or promote products derived from this software without
+#    prior written permission. For written permission, please contact
+#    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+#
+# 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+#    nor may &quot;OpenSSL&quot; appear in their names without prior written
+#    permission of the OpenSSL Project.
+#
+# 6. Redistributions of any form whatsoever must retain the following
+#    acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+# ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGE.
+# ====================================================================
+#
+# This product includes cryptographic software written by Eric Young
+# (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+# Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+
+use strict;
+
+package TLSProxy::ClientHello;
+
+use parent 'TLSProxy::Message';
+
+use constant {
+    EXT_ENCRYPT_THEN_MAC =&gt; 22
+};
+
+sub new
+{
+    my $class = shift;
+    my ($server,
+        $data,
+        $records,
+        $startoffset,
+        $message_frag_lens) = @_;
+    
+    my $self = $class-&gt;SUPER::new(
+        $server,
+        1,
+        $data,
+        $records,
+        $startoffset,
+        $message_frag_lens);
+
+    $self-&gt;{client_version} = 0;
+    $self-&gt;{random} = [];
+    $self-&gt;{session_id_len} = 0;
+    $self-&gt;{session} = &quot;&quot;;
+    $self-&gt;{ciphersuite_len} = 0;
+    $self-&gt;{ciphersuites} = [];
+    $self-&gt;{comp_meth_len} = 0;
+    $self-&gt;{comp_meths} = [];
+    $self-&gt;{extensions_len} = 0;
+    $self-&gt;{extensions_data} = &quot;&quot;;
+
+    return $self;
+}
+
+sub parse
+{
+    my $self = shift;
+    my $ptr = 2;
+    my ($client_version) = unpack('n', $self-&gt;data);
+    my $random = substr($self-&gt;data, $ptr, 32);
+    $ptr += 32;
+    my $session_id_len = unpack('C', substr($self-&gt;data, $ptr));
+    $ptr++;
+    my $session = substr($self-&gt;data, $ptr, $session_id_len);
+    $ptr += $session_id_len;
+    my $ciphersuite_len = unpack('n', substr($self-&gt;data, $ptr));
+    $ptr += 2;
+    my @ciphersuites = unpack('n*', substr($self-&gt;data, $ptr,
+                                           $ciphersuite_len));
+    $ptr += $ciphersuite_len;
+    my $comp_meth_len = unpack('C', substr($self-&gt;data, $ptr));
+    $ptr++;
+    my @comp_meths = unpack('C*', substr($self-&gt;data, $ptr, $comp_meth_len));
+    $ptr += $comp_meth_len;
+    my $extensions_len = unpack('n', substr($self-&gt;data, $ptr));
+    $ptr += 2;
+    #For now we just deal with this as a block of data. In the future we will
+    #want to parse this
+    my $extension_data = substr($self-&gt;data, $ptr);
+    
+    if (length($extension_data) != $extensions_len) {
+        die &quot;Invalid extension length\n&quot;;
+    }
+    my %extensions = ();
+    while (length($extension_data) &gt;= 4) {
+        my ($type, $size) = unpack(&quot;nn&quot;, $extension_data);
+        my $extdata = substr($extension_data, 4, $size);
+        $extension_data = substr($extension_data, 4 + $size);
+        $extensions{$type} = $extdata;
+    }
+
+    $self-&gt;client_version($client_version);
+    $self-&gt;random($random);
+    $self-&gt;session_id_len($session_id_len);
+    $self-&gt;session($session);
+    $self-&gt;ciphersuite_len($ciphersuite_len);
+    $self-&gt;ciphersuites(\@ciphersuites);
+    $self-&gt;comp_meth_len($comp_meth_len);
+    $self-&gt;comp_meths(\@comp_meths);
+    $self-&gt;extensions_len($extensions_len);
+    $self-&gt;extension_data(\%extensions);
+
+    $self-&gt;process_extensions();
+
+    print &quot;    Client Version:&quot;.$client_version.&quot;\n&quot;;
+    print &quot;    Session ID Len:&quot;.$session_id_len.&quot;\n&quot;;
+    print &quot;    Ciphersuite len:&quot;.$ciphersuite_len.&quot;\n&quot;;
+    print &quot;    Compression Method Len:&quot;.$comp_meth_len.&quot;\n&quot;;
+    print &quot;    Extensions Len:&quot;.$extensions_len.&quot;\n&quot;;
+}
+
+#Perform any actions necessary based on the extensions we've seen
+sub process_extensions
+{
+    my $self = shift;
+    my %extensions = %{$self-&gt;extension_data};
+
+    #Clear any state from a previous run
+    TLSProxy::Record-&gt;etm(0);
+
+    if (exists $extensions{&amp;EXT_ENCRYPT_THEN_MAC}) {
+        TLSProxy::Record-&gt;etm(1);
+    }
+}
+
+#Reconstruct the on-the-wire message data following changes
+sub set_message_contents
+{
+    my $self = shift;
+    my $data;
+
+    $data = pack('n', $self-&gt;client_version);
+    $data .= $self-&gt;random;
+    $data .= pack('C', $self-&gt;session_id_len);
+    $data .= $self-&gt;session;
+    $data .= pack('n', $self-&gt;ciphersuite_len);
+    $data .= pack(&quot;n*&quot;, @{$self-&gt;ciphersuites});
+    $data .= pack('C', $self-&gt;comp_meth_len);
+    $data .= pack(&quot;C*&quot;, @{$self-&gt;comp_meths});
+    $data .= pack('n', $self-&gt;extensions_len);
+    foreach my $key (keys %{$self-&gt;extension_data}) {
+        my $extdata = ${$self-&gt;extension_data}{$key};
+        $data .= pack(&quot;n&quot;, $key);
+        $data .= pack(&quot;n&quot;, length($extdata));
+        $data .= $extdata;
+    }
+
+    $self-&gt;data($data);
+}
+
+#Read/write accessors
+sub client_version
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{client_version} = shift;
+    }
+    return $self-&gt;{client_version};
+}
+sub random
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{random} = shift;
+    }
+    return $self-&gt;{random};
+}
+sub session_id_len
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{session_id_len} = shift;
+    }
+    return $self-&gt;{session_id_len};
+}
+sub session
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{session} = shift;
+    }
+    return $self-&gt;{session};
+}
+sub ciphersuite_len
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{ciphersuite_len} = shift;
+    }
+    return $self-&gt;{ciphersuite_len};
+}
+sub ciphersuites
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{ciphersuites} = shift;
+    }
+    return $self-&gt;{ciphersuites};
+}
+sub comp_meth_len
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{comp_meth_len} = shift;
+    }
+    return $self-&gt;{comp_meth_len};
+}
+sub comp_meths
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{comp_meths} = shift;
+    }
+    return $self-&gt;{comp_meths};
+}
+sub extensions_len
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{extensions_len} = shift;
+    }
+    return $self-&gt;{extensions_len};
+}
+sub extension_data
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{extension_data} = shift;
+    }
+    return $self-&gt;{extension_data};
+}
+1;
diff --git a/util/TLSProxy/Message.pm b/util/TLSProxy/Message.pm
new file mode 100644
index 0000000..66a4a7b
--- /dev/null
+++ b/util/TLSProxy/Message.pm
@@ -0,0 +1,457 @@
+# Written by Matt Caswell for the OpenSSL project.
+# ====================================================================
+# Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# 3. All advertising materials mentioning features or use of this
+#    software must display the following acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+#    endorse or promote products derived from this software without
+#    prior written permission. For written permission, please contact
+#    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+#
+# 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+#    nor may &quot;OpenSSL&quot; appear in their names without prior written
+#    permission of the OpenSSL Project.
+#
+# 6. Redistributions of any form whatsoever must retain the following
+#    acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+# ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGE.
+# ====================================================================
+#
+# This product includes cryptographic software written by Eric Young
+# (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+# Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+
+use strict;
+
+package TLSProxy::Message;
+
+use constant TLS_MESSAGE_HEADER_LENGTH =&gt; 4;
+
+#Message types
+use constant {
+    MT_HELLO_REQUEST =&gt; 0,
+    MT_CLIENT_HELLO =&gt; 1,
+    MT_SERVER_HELLO =&gt; 2,
+    MT_NEW_SESSION_TICKET =&gt; 4,
+    MT_CERTIFICATE =&gt; 11,
+    MT_SERVER_KEY_EXCHANGE =&gt; 12,
+    MT_CERTIFICATE_REQUEST =&gt; 13,
+    MT_SERVER_HELLO_DONE =&gt; 14,
+    MT_CERTIFICATE_VERIFY =&gt; 15,
+    MT_CLIENT_KEY_EXCHANGE =&gt; 16,
+    MT_FINISHED =&gt; 20,
+    MT_CERTIFICATE_STATUS =&gt; 22,
+    MT_NEXT_PROTO =&gt; 67
+};
+my %message_type = (
+    MT_HELLO_REQUEST, &quot;HelloRequest&quot;,
+    MT_CLIENT_HELLO, &quot;ClientHello&quot;,
+    MT_SERVER_HELLO, &quot;ServerHello&quot;,
+    MT_NEW_SESSION_TICKET, &quot;NewSessionTicket&quot;,
+    MT_CERTIFICATE, &quot;Certificate&quot;,
+    MT_SERVER_KEY_EXCHANGE, &quot;ServerKeyExchange&quot;,
+    MT_CERTIFICATE_REQUEST, &quot;CertificateRequest&quot;,
+    MT_SERVER_HELLO_DONE, &quot;ServerHelloDone&quot;,
+    MT_CERTIFICATE_VERIFY, &quot;CertificateVerify&quot;,
+    MT_CLIENT_KEY_EXCHANGE, &quot;ClientKeyExchange&quot;,
+    MT_FINISHED, &quot;Finished&quot;,
+    MT_CERTIFICATE_STATUS, &quot;CertificateStatus&quot;,
+    MT_NEXT_PROTO, &quot;NextProto&quot;
+);
+
+my $payload = &quot;&quot;;
+my $messlen = -1;
+my $mt;
+my $startoffset = -1;
+my $server = 0;
+my $success = 0;
+my $end = 0;
+my @message_rec_list = ();
+my @message_frag_lens = ();
+my $ciphersuite = 0;
+
+sub clear
+{
+    $payload = &quot;&quot;;
+    $messlen = -1;
+    $startoffset = -1;
+    $server = 0;
+    $success = 0;
+    $end = 0;
+    @message_rec_list = ();
+    @message_frag_lens = ();
+}
+
+#Class method to extract messages from a record
+sub get_messages
+{
+    my $class = shift;
+    my $serverin = shift;
+    my $record = shift;
+    my @messages = ();
+    my $message;
+
+    @message_frag_lens = ();
+
+    if ($serverin != $server &amp;&amp; length($payload) != 0) {
+        die &quot;Changed peer, but we still have fragment data\n&quot;;
+    }
+    $server = $serverin;
+
+    if ($record-&gt;content_type == TLSProxy::Record::RT_CCS) {
+        if ($payload ne &quot;&quot;) {
+            #We can't handle this yet
+            die &quot;CCS received before message data complete\n&quot;;
+        }
+        if ($server) {
+            TLSProxy::Record-&gt;server_ccs_seen(1);
+        } else {
+            TLSProxy::Record-&gt;client_ccs_seen(1);
+        }
+    } elsif ($record-&gt;content_type == TLSProxy::Record::RT_HANDSHAKE) {
+        if ($record-&gt;len == 0 || $record-&gt;len_real == 0) {
+            print &quot;  Message truncated\n&quot;;
+        } else {
+            my $recoffset = 0;
+
+            if (length $payload &gt; 0) {
+                #We are continuing processing a message started in a previous
+                #record. Add this record to the list associated with this
+                #message
+                push @message_rec_list, $record;
+
+                if ($messlen &lt;= length($payload)) {
+                    #Shouldn't happen
+                    die &quot;Internal error: invalid messlen: &quot;.$messlen
+                        .&quot; payload length:&quot;.length($payload).&quot;\n&quot;;
+                }
+                if (length($payload) + $record-&gt;decrypt_len &gt;= $messlen) {
+                    #We can complete the message with this record
+                    $recoffset = $messlen - length($payload);
+                    $payload .= substr($record-&gt;decrypt_data, 0, $recoffset);
+                    push @message_frag_lens, $recoffset;
+                    $message = create_message($server, $mt, $payload,
+                                              $startoffset);
+                    push @messages, $message;
+
+                    #Check if we have finished the handshake
+                    if ($mt == MT_FINISHED &amp;&amp; $server) {
+                        $success = 1;
+                        $end = 1;
+                    }
+                    $payload = &quot;&quot;;
+                } else {
+                    #This is just part of the total message
+                    $payload .= $record-&gt;decrypt_data;
+                    $recoffset = $record-&gt;decrypt_len;
+                    push @message_frag_lens, $record-&gt;decrypt_len;
+                }
+                print &quot;  Partial message data read: &quot;.$recoffset.&quot; bytes\n&quot;;
+            }
+
+            while ($record-&gt;decrypt_len &gt; $recoffset) {
+                #We are at the start of a new message
+                if ($record-&gt;decrypt_len - $recoffset &lt; 4) {
+                    #Whilst technically probably valid we can't cope with this
+                    die &quot;End of record in the middle of a message header\n&quot;;
+                }
+                @message_rec_list = ($record);
+                my $lenhi;
+                my $lenlo;
+                ($mt, $lenhi, $lenlo) = unpack('CnC',
+                                               substr($record-&gt;decrypt_data,
+                                                      $recoffset));
+                $messlen = ($lenhi &lt;&lt; 8) | $lenlo;
+                print &quot;  Message type: $message_type{$mt}\n&quot;;
+                print &quot;  Message Length: $messlen\n&quot;;
+                $startoffset = $recoffset;
+                $recoffset += 4;
+                $payload = &quot;&quot;;
+                
+                if ($recoffset &lt; $record-&gt;decrypt_len) {
+                    #Some payload data is present in this record
+                    if ($record-&gt;decrypt_len - $recoffset &gt;= $messlen) {
+                        #We can complete the message with this record
+                        $payload .= substr($record-&gt;decrypt_data, $recoffset,
+                                           $messlen);
+                        $recoffset += $messlen;
+                        push @message_frag_lens, $messlen;
+                        $message = create_message($server, $mt, $payload,
+                                                  $startoffset);
+                        push @messages, $message;
+
+                        #Check if we have finished the handshake
+                        if ($mt == MT_FINISHED &amp;&amp; $server) {
+                            $success = 1;
+                            $end = 1;
+                        }
+                        $payload = &quot;&quot;;
+                    } else {
+                        #This is just part of the total message
+                        $payload .= substr($record-&gt;decrypt_data, $recoffset,
+                                           $record-&gt;decrypt_len - $recoffset);
+                        $recoffset = $record-&gt;decrypt_len;
+                        push @message_frag_lens, $recoffset;
+                    }
+                }
+            }
+        }
+    } elsif ($record-&gt;content_type == TLSProxy::Record::RT_APPLICATION_DATA) {
+        print &quot;  [ENCRYPTED APPLICATION DATA]\n&quot;;
+        print &quot;  [&quot;.$record-&gt;decrypt_data.&quot;]\n&quot;;
+    } elsif ($record-&gt;content_type == TLSProxy::Record::RT_ALERT) {
+        #For now assume all alerts are fatal
+        $end = 1;
+    }
+
+    return @messages;
+}
+
+#Function to work out which sub-class we need to create and then
+#construct it
+sub create_message
+{
+    my ($server, $mt, $data, $startoffset) = @_;
+    my $message;
+
+    #We only support ClientHello in this version...needs to be extended for
+    #others
+    if ($mt == MT_CLIENT_HELLO) {
+        $message = TLSProxy::ClientHello-&gt;new(
+            $server,
+            $data,
+            [@message_rec_list],
+            $startoffset,
+            [@message_frag_lens]
+        );
+        $message-&gt;parse();
+    } elsif ($mt == MT_SERVER_HELLO) {
+        $message = TLSProxy::ServerHello-&gt;new(
+            $server,
+            $data,
+            [@message_rec_list],
+            $startoffset,
+            [@message_frag_lens]
+        );
+        $message-&gt;parse();
+    } elsif ($mt == MT_SERVER_KEY_EXCHANGE) {
+        $message = TLSProxy::ServerKeyExchange-&gt;new(
+            $server,
+            $data,
+            [@message_rec_list],
+            $startoffset,
+            [@message_frag_lens]
+        );
+        $message-&gt;parse();
+    } else {
+        #Unknown message type
+        $message = TLSProxy::Message-&gt;new(
+            $server,
+            $mt,
+            $data,
+            [@message_rec_list],
+            $startoffset,
+            [@message_frag_lens]
+        );
+    }
+
+    return $message;
+}
+
+sub end
+{
+    my $class = shift;
+    return $end;
+}
+sub success
+{
+    my $class = shift;
+    return $success;
+}
+sub fail
+{
+    my $class = shift;
+    return !$success &amp;&amp; $end;
+}
+sub new
+{
+    my $class = shift;
+    my ($server,
+        $mt,
+        $data,
+        $records,
+        $startoffset,
+        $message_frag_lens) = @_;
+    
+    my $self = {
+        server =&gt; $server,
+        data =&gt; $data,
+        records =&gt; $records,
+        mt =&gt; $mt,
+        startoffset =&gt; $startoffset,
+        message_frag_lens =&gt; $message_frag_lens
+    };
+
+    return bless $self, $class;
+}
+
+sub ciphersuite
+{
+    my $class = shift;
+    if (@_) {
+      $ciphersuite = shift;
+    }
+    return $ciphersuite;
+}
+
+#Update all the underlying records with the modified data from this message
+#Note: Does not currently support re-encrypting
+sub repack
+{
+    my $self = shift;
+    my $msgdata;
+
+    my $numrecs = $#{$self-&gt;records};
+
+    $self-&gt;set_message_contents();
+
+    my $lenhi;
+    my $lenlo;
+
+    $lenlo = length($self-&gt;data) &amp; 0xff;
+    $lenhi = length($self-&gt;data) &gt;&gt; 8;
+    my $msgdata = pack('CnC', $self-&gt;mt, $lenhi, $lenlo).$self-&gt;data;
+
+
+    if ($numrecs == 0) {
+        #The message is fully contained within one record
+        my ($rec) = @{$self-&gt;records};
+        my $recdata = $rec-&gt;decrypt_data;
+
+        if (length($msgdata) != ${$self-&gt;message_frag_lens}[0]
+                                + TLS_MESSAGE_HEADER_LENGTH) {
+            #Message length has changed! Better adjust the record length
+            my $diff = length($msgdata) - ${$self-&gt;message_frag_lens}[0]
+                                        - TLS_MESSAGE_HEADER_LENGTH;
+            $rec-&gt;len($rec-&gt;len + $diff);
+        }
+
+        $rec-&gt;data(substr($recdata, 0, $self-&gt;startoffset)
+                   .($msgdata)
+                   .substr($recdata, ${$self-&gt;message_frag_lens}[0]
+                                     + TLS_MESSAGE_HEADER_LENGTH));
+
+        #Update the fragment len in case we changed it above
+        ${$self-&gt;message_frag_lens}[0] = length($msgdata)
+                                         - TLS_MESSAGE_HEADER_LENGTH;
+        return;
+    }
+
+    #Note we don't currently support changing a fragmented message length
+    my $recctr = 0;
+    my $datadone = 0;
+    foreach my $rec (@{$self-&gt;records}) {
+        my $recdata = $rec-&gt;decrypt_data;
+        if ($recctr == 0) {
+            #This is the first record
+            my $remainlen = length($recdata) - $self-&gt;startoffset;
+            $rec-&gt;data(substr($recdata, 0, $self-&gt;startoffset)
+                       .substr(($msgdata), 0, $remainlen));
+            $datadone += $remainlen;
+        } elsif ($recctr + 1 == $numrecs) {
+            #This is the last record
+            $rec-&gt;data(substr($msgdata, $datadone));
+        } else {
+            #This is a middle record
+            $rec-&gt;data(substr($msgdata, $datadone, length($rec-&gt;data)));
+            $datadone += length($rec-&gt;data);
+        }
+        $recctr++;
+    }
+}
+
+#To be overridden by sub-classes
+sub set_message_contents
+{
+}
+
+#Read only accessors
+sub server
+{
+    my $self = shift;
+    return $self-&gt;{server};
+}
+
+#Read/write accessors
+sub mt
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{mt} = shift;
+    }
+    return $self-&gt;{mt};
+}
+sub data
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{data} = shift;
+    }
+    return $self-&gt;{data};
+}
+sub records
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{records} = shift;
+    }
+    return $self-&gt;{records};
+}
+sub startoffset
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{startoffset} = shift;
+    }
+    return $self-&gt;{startoffset};
+}
+sub message_frag_lens
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{message_frag_lens} = shift;
+    }
+    return $self-&gt;{message_frag_lens};
+}
+
+1;
diff --git a/util/TLSProxy/Proxy.pm b/util/TLSProxy/Proxy.pm
new file mode 100644
index 0000000..c033c29
--- /dev/null
+++ b/util/TLSProxy/Proxy.pm
@@ -0,0 +1,394 @@
+# Written by Matt Caswell for the OpenSSL project.
+# ====================================================================
+# Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# 3. All advertising materials mentioning features or use of this
+#    software must display the following acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+#    endorse or promote products derived from this software without
+#    prior written permission. For written permission, please contact
+#    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+#
+# 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+#    nor may &quot;OpenSSL&quot; appear in their names without prior written
+#    permission of the OpenSSL Project.
+#
+# 6. Redistributions of any form whatsoever must retain the following
+#    acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+# ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGE.
+# ====================================================================
+#
+# This product includes cryptographic software written by Eric Young
+# (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+# Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+
+use strict;
+
+package TLSProxy::Proxy;
+
+use File::Spec;
+use IO::Socket;
+use IO::Select;
+use TLSProxy::Record;
+use TLSProxy::Message;
+use TLSProxy::ClientHello;
+use TLSProxy::ServerHello;
+use TLSProxy::ServerKeyExchange;
+
+sub new
+{
+    my $class = shift;
+    my ($filter,
+        $execute,
+        $cert,
+        $debug) = @_;
+
+    my $self = {
+        #Public read/write
+        proxy_addr =&gt; &quot;localhost&quot;,
+        proxy_port =&gt; 4453,
+        server_addr =&gt; &quot;localhost&quot;,
+        server_port =&gt; 4443,
+        filter =&gt; $filter,
+
+        #Public read
+        execute =&gt; $execute,
+        cert =&gt; $cert,
+        debug =&gt; $debug,
+        cipherc =&gt; &quot;AES128-SHA&quot;,
+        ciphers =&gt; &quot;&quot;,
+        flight =&gt; 0,
+        record_list =&gt; [],
+        message_list =&gt; [],
+
+        #Private
+        message_rec_list =&gt; []
+    };
+
+    return bless $self, $class;
+}
+
+sub clear
+{
+    my $self = shift;
+
+    $self-&gt;{cipherc} = &quot;AES128-SHA&quot;;
+    $self-&gt;{ciphers} = &quot;&quot;;
+    $self-&gt;{flight} = 0;
+    $self-&gt;{record_list} = [];
+    $self-&gt;{message_list} = [];
+    $self-&gt;{message_rec_list} = [];
+
+    TLSProxy::Message-&gt;clear();
+    TLSProxy::Record-&gt;clear();
+}
+
+sub restart
+{
+    my $self = shift;
+
+    $self-&gt;clear;
+    $self-&gt;start;
+}
+
+sub start
+{
+    my ($self) = shift;
+    my $pid;
+
+    $pid = fork();
+    if ($pid == 0) {
+        open(STDOUT, &quot;&gt;&quot;, File::Spec-&gt;devnull())
+            or die &quot;Failed to redirect stdout&quot;;
+        open(STDERR, &quot;&gt;&amp;STDOUT&quot;);
+        my $execcmd = $self-&gt;execute.&quot; s_server -engine ossltest -accept &quot;
+            .($self-&gt;server_port)
+            .&quot; -cert &quot;.$self-&gt;cert.&quot; -naccept 1&quot;;
+        if ($self-&gt;ciphers ne &quot;&quot;) {
+            $execcmd .= &quot; -cipher &quot;.$self-&gt;ciphers;
+        }
+        exec($execcmd);
+    }
+
+    my $oldstdout;
+
+    if(!$self-&gt;debug) {
+        $oldstdout = select(File::Spec-&gt;devnull());
+    }
+
+    # Create the Proxy socket
+    my $proxy_sock = new IO::Socket::INET(
+        LocalHost   =&gt; $self-&gt;proxy_addr,
+        LocalPort   =&gt; $self-&gt;proxy_port,
+        Proto       =&gt; &quot;tcp&quot;,
+        Listen      =&gt; SOMAXCONN,
+        Reuse       =&gt; 1
+    );
+
+    if ($proxy_sock) {
+        print &quot;Proxy started on port &quot;.$self-&gt;proxy_port.&quot;\n&quot;;
+    } else {
+        die &quot;Failed creating proxy socket\n&quot;;
+    }
+
+    if ($self-&gt;execute) {
+        my $pid = fork();
+        if ($pid == 0) {
+            open(STDOUT, &quot;&gt;&quot;, File::Spec-&gt;devnull())
+                or die &quot;Failed to redirect stdout&quot;;
+            open(STDERR, &quot;&gt;&amp;STDOUT&quot;);
+            my $execcmd = $self-&gt;execute
+                 .&quot; s_client -engine ossltest -connect &quot;
+                 .($self-&gt;proxy_addr).&quot;:&quot;.($self-&gt;proxy_port);
+            if ($self-&gt;cipherc ne &quot;&quot;) {
+                $execcmd .= &quot; -cipher &quot;.$self-&gt;cipherc;
+            }
+            exec($execcmd);
+        }
+    }
+
+    # Wait for incoming connection from client
+    my $client_sock = $proxy_sock-&gt;accept() 
+        or die &quot;Failed accepting incoming connection\n&quot;;
+
+    print &quot;Connection opened\n&quot;;
+
+    # Now connect to the server
+    my $retry = 3;
+    my $server_sock;
+    #We loop over this a few times because sometimes s_server can take a while
+    #to start up
+    do {
+        $server_sock = new IO::Socket::INET(
+            PeerAddr =&gt; $self-&gt;server_addr,
+            PeerPort =&gt; $self-&gt;server_port,
+            Proto =&gt; 'tcp'
+        ); 
+
+        $retry--;
+        if (!$server_sock) {
+            if ($retry) {
+                #Sleep for a short while
+                select(undef, undef, undef, 0.1);
+            } else {
+                die &quot;Failed to start up server\n&quot;;
+            }
+        }
+    } while (!$server_sock);
+
+    my $sel = IO::Select-&gt;new($server_sock, $client_sock);
+    my $indata;
+    my @handles = ($server_sock, $client_sock);
+
+    #Wait for either the server socket or the client socket to become readable
+    my @ready;
+    while(!(TLSProxy::Message-&gt;end) &amp;&amp; (@ready = $sel-&gt;can_read)) {
+        foreach my $hand (@ready) {
+            if ($hand == $server_sock) {
+                $server_sock-&gt;sysread($indata, 16384) or goto END;
+                $indata = $self-&gt;process_packet(1, $indata);
+                $client_sock-&gt;syswrite($indata);
+            } elsif ($hand == $client_sock) {
+                $client_sock-&gt;sysread($indata, 16384) or goto END;
+                $indata = $self-&gt;process_packet(0, $indata);
+                $server_sock-&gt;syswrite($indata);
+            } else {
+                print &quot;Err\n&quot;;
+                goto END;
+            }
+        }
+    }
+
+    END:
+    print &quot;Connection closed\n&quot;;
+    if($server_sock) {
+        $server_sock-&gt;close();
+    }
+    if($client_sock) {
+        #Closing this also kills the child process
+        $client_sock-&gt;close();
+    }
+    if($proxy_sock) {
+        $proxy_sock-&gt;close();
+    }
+    if(!$self-&gt;debug) {
+        select($oldstdout);
+    }
+}
+
+
+sub process_packet
+{
+    my ($self, $server, $packet) = @_;
+    my $len_real;
+    my $decrypt_len;
+    my $data;
+    my $recnum;
+
+    if ($server) {
+        print &quot;Received server packet\n&quot;;
+    } else {
+        print &quot;Received client packet\n&quot;;
+    }
+
+    print &quot;Packet length = &quot;.length($packet).&quot;\n&quot;;
+    print &quot;Processing flight &quot;.$self-&gt;flight.&quot;\n&quot;;
+
+    #Return contains the list of record found in the packet followed by the
+    #list of messages in those records
+    my @ret = TLSProxy::Record-&gt;get_records($server, $self-&gt;flight, $packet);
+    push @{$self-&gt;record_list}, @{$ret[0]};
+    $self-&gt;{message_rec_list} = $ret[0];
+    push @{$self-&gt;{message_list}}, @{$ret[1]};
+
+    print &quot;\n&quot;;
+
+    #Finished parsing. Call user provided filter here
+    $self-&gt;filter-&gt;($self);
+
+    #Reconstruct the packet
+    $packet = &quot;&quot;;
+    foreach my $record (@{$self-&gt;record_list}) {
+        #We only replay the records for the current flight
+        if ($record-&gt;flight != $self-&gt;flight) {
+            next;
+        }
+        $packet .= $record-&gt;reconstruct_record();
+    }
+
+    $self-&gt;{flight} = $self-&gt;{flight} + 1;
+
+    print &quot;Forwarded packet length = &quot;.length($packet).&quot;\n\n&quot;;
+
+    return $packet;
+}
+
+#Read accessors
+sub execute
+{
+    my $self = shift;
+    return $self-&gt;{execute};
+}
+sub cert
+{
+    my $self = shift;
+    return $self-&gt;{cert};
+}
+sub debug
+{
+    my $self = shift;
+    return $self-&gt;{debug};
+}
+sub flight
+{
+    my $self = shift;
+    return $self-&gt;{flight};
+}
+sub record_list
+{
+    my $self = shift;
+    return $self-&gt;{record_list};
+}
+sub message_list
+{
+    my $self = shift;
+    return $self-&gt;{message_list};
+}
+sub success
+{
+    my $self = shift;
+    return $self-&gt;{success};
+}
+sub end
+{
+    my $self = shift;
+    return $self-&gt;{end};
+}
+
+#Read/write accessors
+sub proxy_addr
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{proxy_addr} = shift;
+    }
+    return $self-&gt;{proxy_addr};
+}
+sub proxy_port
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{proxy_port} = shift;
+    }
+    return $self-&gt;{proxy_port};
+}
+sub server_addr
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{server_addr} = shift;
+    }
+    return $self-&gt;{server_addr};
+}
+sub server_port
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{server_port} = shift;
+    }
+    return $self-&gt;{server_port};
+}
+sub filter
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{filter} = shift;
+    }
+    return $self-&gt;{filter};
+}
+sub cipherc
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{cipherc} = shift;
+    }
+    return $self-&gt;{cipherc};
+}
+sub ciphers
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{ciphers} = shift;
+    }
+    return $self-&gt;{ciphers};
+}
+1;
diff --git a/util/TLSProxy/Record.pm b/util/TLSProxy/Record.pm
new file mode 100644
index 0000000..1d10508
--- /dev/null
+++ b/util/TLSProxy/Record.pm
@@ -0,0 +1,360 @@
+# Written by Matt Caswell for the OpenSSL project.
+# ====================================================================
+# Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# 3. All advertising materials mentioning features or use of this
+#    software must display the following acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+#    endorse or promote products derived from this software without
+#    prior written permission. For written permission, please contact
+#    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+#
+# 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+#    nor may &quot;OpenSSL&quot; appear in their names without prior written
+#    permission of the OpenSSL Project.
+#
+# 6. Redistributions of any form whatsoever must retain the following
+#    acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+# ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGE.
+# ====================================================================
+#
+# This product includes cryptographic software written by Eric Young
+# (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+# Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+
+use strict;
+
+use TLSProxy::Proxy;
+
+package TLSProxy::Record;
+
+my $server_ccs_seen = 0;
+my $client_ccs_seen = 0;
+my $etm = 0;
+
+use constant TLS_RECORD_HEADER_LENGTH =&gt; 5;
+
+#Record types
+use constant {
+    RT_APPLICATION_DATA =&gt; 23,
+    RT_HANDSHAKE =&gt; 22,
+    RT_ALERT =&gt; 21,
+    RT_CCS =&gt; 20
+};
+
+my %record_type = (
+    RT_APPLICATION_DATA, &quot;APPLICATION DATA&quot;,
+    RT_HANDSHAKE, &quot;HANDSHAKE&quot;,
+    RT_ALERT, &quot;ALERT&quot;,
+    RT_CCS, &quot;CCS&quot;
+);
+
+use constant {
+    VERS_TLS_1_3 =&gt; 772,
+    VERS_TLS_1_2 =&gt; 771,
+    VERS_TLS_1_1 =&gt; 770,
+    VERS_TLS_1_0 =&gt; 769,
+    VERS_SSL_3_0 =&gt; 768
+};
+
+my %tls_version = (
+    VERS_TLS_1_3, &quot;TLS1.3&quot;,
+    VERS_TLS_1_2, &quot;TLS1.2&quot;,
+    VERS_TLS_1_1, &quot;TLS1.1&quot;,
+    VERS_TLS_1_0, &quot;TLS1.0&quot;,
+    VERS_SSL_3_0, &quot;SSL3&quot;
+);
+
+#Class method to extract records from a packet of data
+sub get_records
+{
+    my $class = shift;
+    my $server = shift;
+    my $flight = shift;
+    my $packet = shift;
+    my @record_list = ();
+    my @message_list = ();
+    my $data;
+    my $content_type;
+    my $version;
+    my $len;
+    my $len_real;
+    my $decrypt_len;
+
+    my $recnum = 1;
+    while (length ($packet) &gt; 0) {
+        print &quot; Record $recnum&quot;;
+        if ($server) {
+            print &quot; (server -&gt; client)\n&quot;;
+        } else {
+            print &quot; (client -&gt; server)\n&quot;;
+        }
+        #Get the record header
+        if (length($packet) &lt; TLS_RECORD_HEADER_LENGTH) {
+            print &quot;Partial data : &quot;.length($packet).&quot; bytes\n&quot;;
+            $packet = &quot;&quot;;
+        } else {
+            ($content_type, $version, $len) = unpack('CnnC*', $packet);
+            $data = substr($packet, 5, $len);
+
+            print &quot;  Content type: &quot;.$record_type{$content_type}.&quot;\n&quot;;
+            print &quot;  Version: $tls_version{$version}\n&quot;;
+            print &quot;  Length: $len&quot;;
+            if ($len == length($data)) {
+                print &quot;\n&quot;;
+                $decrypt_len = $len_real = $len;
+            } else {
+                print &quot; (expected), &quot;.length($data).&quot; (actual)\n&quot;;
+                $decrypt_len = $len_real = length($data);
+            }
+
+            my $record = TLSProxy::Record-&gt;new(
+                $flight,
+                $content_type,
+                $version,
+                $len,
+                $len_real,
+                $decrypt_len,
+                substr($packet, TLS_RECORD_HEADER_LENGTH, $len_real),
+                substr($packet, TLS_RECORD_HEADER_LENGTH, $len_real)
+            );
+
+            if (($server &amp;&amp; $server_ccs_seen)
+                     || (!$server &amp;&amp; $client_ccs_seen)) {
+                if ($etm) {
+                    $record-&gt;decryptETM();
+                } else {
+                    $record-&gt;decrypt();
+                }
+            }
+
+            push @record_list, $record;
+
+            #Now figure out what messages are contained within this record
+            my @messages = TLSProxy::Message-&gt;get_messages($server, $record);
+            push @message_list, @messages;
+
+            $packet = substr($packet, TLS_RECORD_HEADER_LENGTH + $len_real);
+            $recnum++;
+        }
+    }
+
+    return (\@record_list, \@message_list);
+}
+
+sub clear
+{
+    $server_ccs_seen = 0;
+    $client_ccs_seen = 0;
+}
+
+#Class level accessors
+sub server_ccs_seen
+{
+    my $class = shift;
+    if (@_) {
+      $server_ccs_seen = shift;
+    }
+    return $server_ccs_seen;
+}
+sub client_ccs_seen
+{
+    my $class = shift;
+    if (@_) {
+      $client_ccs_seen = shift;
+    }
+    return $client_ccs_seen;
+}
+#Enable/Disable Encrypt-then-MAC
+sub etm
+{
+    my $class = shift;
+    if (@_) {
+      $etm = shift;
+    }
+    return $etm;
+}
+
+sub new
+{
+    my $class = shift;
+    my ($flight,
+        $content_type,
+        $version,
+        $len,
+        $len_real,
+        $decrypt_len,
+        $data,
+        $decrypt_data) = @_;
+    
+    my $self = {
+        flight =&gt; $flight,
+        content_type =&gt; $content_type,
+        version =&gt; $version,
+        len =&gt; $len,
+        len_real =&gt; $len_real,
+        decrypt_len =&gt; $decrypt_len,
+        data =&gt; $data,
+        decrypt_data =&gt; $decrypt_data,
+        orig_decrypt_data =&gt; $decrypt_data
+    };
+
+    return bless $self, $class;
+}
+
+#Decrypt using encrypt-then-MAC
+sub decryptETM
+{
+    my ($self) = shift;
+
+    my $data = $self-&gt;data;
+
+    if($self-&gt;version &gt;= VERS_TLS_1_1()) {
+        #TLS1.1+ has an explicit IV. Throw it away
+        $data = substr($data, 16);
+    }
+
+    #Throw away the MAC (assumes MAC is 20 bytes for now. FIXME)
+    $data = substr($data, 0, length($data) - 20);
+
+    #Find out what the padding byte is
+    my $padval = unpack(&quot;C&quot;, substr($data, length($data) - 1));
+
+    #Throw away the padding
+    $data = substr($data, 0, length($data) - ($padval + 1));
+
+    $self-&gt;decrypt_data($data);
+    $self-&gt;decrypt_len(length($data));
+
+    return $data;
+}
+
+#Standard decrypt
+sub decrypt()
+{
+    my ($self) = shift;
+
+    my $data = $self-&gt;data;
+
+    if($self-&gt;version &gt;= VERS_TLS_1_1()) {
+        #TLS1.1+ has an explicit IV. Throw it away
+        $data = substr($data, 16);
+    }
+
+    #Find out what the padding byte is
+    my $padval = unpack(&quot;C&quot;, substr($data, length($data) - 1));
+
+    #Throw away the padding
+    $data = substr($data, 0, length($data) - ($padval + 1));
+
+    #Throw away the MAC (assumes MAC is 20 bytes for now. FIXME)
+    $data = substr($data, 0, length($data) - 20);
+
+    $self-&gt;decrypt_data($data);
+    $self-&gt;decrypt_len(length($data));
+
+    return $data;
+}
+
+#Reconstruct the on-the-wire record representation
+sub reconstruct_record
+{
+    my $self = shift;
+    my $data;
+
+    $data = pack('Cnn', $self-&gt;content_type, $self-&gt;version, $self-&gt;len);
+    $data .= $self-&gt;data;
+
+    return $data;
+}
+
+#Read only accessors
+sub flight
+{
+    my $self = shift;
+    return $self-&gt;{flight};
+}
+sub content_type
+{
+    my $self = shift;
+    return $self-&gt;{content_type};
+}
+sub version
+{
+    my $self = shift;
+    return $self-&gt;{version};
+}
+sub len_real
+{
+    my $self = shift;
+    return $self-&gt;{len_real};
+}
+sub orig_decrypt_data
+{
+    my $self = shift;
+    return $self-&gt;{orig_decrypt_data};
+}
+
+#Read/write accessors
+sub decrypt_len
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{decrypt_len} = shift;
+    }
+    return $self-&gt;{decrypt_len};
+}
+sub data
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{data} = shift;
+    }
+    return $self-&gt;{data};
+}
+sub decrypt_data
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{decrypt_data} = shift;
+    }
+    return $self-&gt;{decrypt_data};
+}
+sub len
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{len} = shift;
+    }
+    return $self-&gt;{len};
+}
+1;
diff --git a/util/TLSProxy/ServerHello.pm b/util/TLSProxy/ServerHello.pm
new file mode 100644
index 0000000..693430e
--- /dev/null
+++ b/util/TLSProxy/ServerHello.pm
@@ -0,0 +1,235 @@
+# Written by Matt Caswell for the OpenSSL project.
+# ====================================================================
+# Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# 3. All advertising materials mentioning features or use of this
+#    software must display the following acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+#    endorse or promote products derived from this software without
+#    prior written permission. For written permission, please contact
+#    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+#
+# 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+#    nor may &quot;OpenSSL&quot; appear in their names without prior written
+#    permission of the OpenSSL Project.
+#
+# 6. Redistributions of any form whatsoever must retain the following
+#    acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+# ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGE.
+# ====================================================================
+#
+# This product includes cryptographic software written by Eric Young
+# (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+# Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+
+use strict;
+
+package TLSProxy::ServerHello;
+
+use parent 'TLSProxy::Message';
+
+sub new
+{
+    my $class = shift;
+    my ($server,
+        $data,
+        $records,
+        $startoffset,
+        $message_frag_lens) = @_;
+    
+    my $self = $class-&gt;SUPER::new(
+        $server,
+        TLSProxy::Message::MT_SERVER_HELLO,
+        $data,
+        $records,
+        $startoffset,
+        $message_frag_lens);
+
+    $self-&gt;{server_version} = 0;
+    $self-&gt;{random} = [];
+    $self-&gt;{session_id_len} = 0;
+    $self-&gt;{session} = &quot;&quot;;
+    $self-&gt;{ciphersuite} = 0;
+    $self-&gt;{comp_meth} = 0;
+    $self-&gt;{extensions_len} = 0;
+    $self-&gt;{extensions_data} = &quot;&quot;;
+
+    return $self;
+}
+
+sub parse
+{
+    my $self = shift;
+    my $ptr = 2;
+    my ($server_version) = unpack('n', $self-&gt;data);
+    my $random = substr($self-&gt;data, $ptr, 32);
+    $ptr += 32;
+    my $session_id_len = unpack('C', substr($self-&gt;data, $ptr));
+    $ptr++;
+    my $session = substr($self-&gt;data, $ptr, $session_id_len);
+    $ptr += $session_id_len;
+    my $ciphersuite = unpack('n', substr($self-&gt;data, $ptr));
+    $ptr += 2;
+    my $comp_meth = unpack('C', substr($self-&gt;data, $ptr));
+    $ptr++;
+    my $extensions_len = unpack('n', substr($self-&gt;data, $ptr));
+    $ptr += 2;
+    #For now we just deal with this as a block of data. In the future we will
+    #want to parse this
+    my $extension_data = substr($self-&gt;data, $ptr);
+    
+    if (length($extension_data) != $extensions_len) {
+        die &quot;Invalid extension length\n&quot;;
+    }
+    my %extensions = ();
+    while (length($extension_data) &gt;= 4) {
+        my ($type, $size) = unpack(&quot;nn&quot;, $extension_data);
+        my $extdata = substr($extension_data, 4, $size);
+        $extension_data = substr($extension_data, 4 + $size);
+        $extensions{$type} = $extdata;
+    }
+
+    $self-&gt;server_version($server_version);
+    $self-&gt;random($random);
+    $self-&gt;session_id_len($session_id_len);
+    $self-&gt;session($session);
+    $self-&gt;ciphersuite($ciphersuite);
+    $self-&gt;comp_meth($comp_meth);
+    $self-&gt;extensions_len($extensions_len);
+    $self-&gt;extension_data(\%extensions);
+
+    $self-&gt;process_data();
+
+    print &quot;    Server Version:&quot;.$server_version.&quot;\n&quot;;
+    print &quot;    Session ID Len:&quot;.$session_id_len.&quot;\n&quot;;
+    print &quot;    Ciphersuite:&quot;.$ciphersuite.&quot;\n&quot;;
+    print &quot;    Compression Method:&quot;.$comp_meth.&quot;\n&quot;;
+    print &quot;    Extensions Len:&quot;.$extensions_len.&quot;\n&quot;;
+}
+
+#Perform any actions necessary based on the data we've seen
+sub process_data
+{
+    my $self = shift;
+
+    TLSProxy::Message-&gt;ciphersuite($self-&gt;ciphersuite);
+}
+
+#Reconstruct the on-the-wire message data following changes
+sub set_message_contents
+{
+    my $self = shift;
+    my $data;
+
+    $data = pack('n', $self-&gt;server_version);
+    $data .= $self-&gt;random;
+    $data .= pack('C', $self-&gt;session_id_len);
+    $data .= $self-&gt;session;
+    $data .= pack('n', $self-&gt;ciphersuite);
+    $data .= pack('C', $self-&gt;comp_meth);
+    $data .= pack('n', $self-&gt;extensions_len);
+    foreach my $key (keys %{$self-&gt;extension_data}) {
+        my $extdata = ${$self-&gt;extension_data}{$key};
+        $data .= pack(&quot;n&quot;, $key);
+        $data .= pack(&quot;n&quot;, length($extdata));
+        $data .= $extdata;
+    }
+
+    $self-&gt;data($data);
+}
+
+#Read/write accessors
+sub server_version
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{client_version} = shift;
+    }
+    return $self-&gt;{client_version};
+}
+sub random
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{random} = shift;
+    }
+    return $self-&gt;{random};
+}
+sub session_id_len
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{session_id_len} = shift;
+    }
+    return $self-&gt;{session_id_len};
+}
+sub session
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{session} = shift;
+    }
+    return $self-&gt;{session};
+}
+sub ciphersuite
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{ciphersuite} = shift;
+    }
+    return $self-&gt;{ciphersuite};
+}
+sub comp_meth
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{comp_meth} = shift;
+    }
+    return $self-&gt;{comp_meth};
+}
+sub extensions_len
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{extensions_len} = shift;
+    }
+    return $self-&gt;{extensions_len};
+}
+sub extension_data
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{extension_data} = shift;
+    }
+    return $self-&gt;{extension_data};
+}
+1;
diff --git a/util/TLSProxy/ServerKeyExchange.pm b/util/TLSProxy/ServerKeyExchange.pm
new file mode 100644
index 0000000..3a91d17
--- /dev/null
+++ b/util/TLSProxy/ServerKeyExchange.pm
@@ -0,0 +1,176 @@
+# Written by Matt Caswell for the OpenSSL project.
+# ====================================================================
+# Copyright (c) 1998-2015 The OpenSSL Project.  All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in
+#    the documentation and/or other materials provided with the
+#    distribution.
+#
+# 3. All advertising materials mentioning features or use of this
+#    software must display the following acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit. (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# 4. The names &quot;OpenSSL Toolkit&quot; and &quot;OpenSSL Project&quot; must not be used to
+#    endorse or promote products derived from this software without
+#    prior written permission. For written permission, please contact
+#    <A HREF="../../../mailman/listinfo/openssl-commits.html">openssl-core at openssl.org.</A>
+#
+# 5. Products derived from this software may not be called &quot;OpenSSL&quot;
+#    nor may &quot;OpenSSL&quot; appear in their names without prior written
+#    permission of the OpenSSL Project.
+#
+# 6. Redistributions of any form whatsoever must retain the following
+#    acknowledgment:
+#    &quot;This product includes software developed by the OpenSSL Project
+#    for use in the OpenSSL Toolkit (<A HREF="http://www.openssl.org/">http://www.openssl.org/</A>)&quot;
+#
+# THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+# EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+# ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+# OF THE POSSIBILITY OF SUCH DAMAGE.
+# ====================================================================
+#
+# This product includes cryptographic software written by Eric Young
+# (<A HREF="../../../mailman/listinfo/openssl-commits.html">eay at cryptsoft.com</A>).  This product includes software written by Tim
+# Hudson (<A HREF="../../../mailman/listinfo/openssl-commits.html">tjh at cryptsoft.com</A>).
+
+use strict;
+
+package TLSProxy::ServerKeyExchange;
+
+use parent 'TLSProxy::Message';
+
+sub new
+{
+    my $class = shift;
+    my ($server,
+        $data,
+        $records,
+        $startoffset,
+        $message_frag_lens) = @_;
+    
+    my $self = $class-&gt;SUPER::new(
+        $server,
+        TLSProxy::Message::MT_SERVER_KEY_EXCHANGE,
+        $data,
+        $records,
+        $startoffset,
+        $message_frag_lens);
+
+    #DHE
+    $self-&gt;{p} = &quot;&quot;;
+    $self-&gt;{g} = &quot;&quot;;
+    $self-&gt;{pub_key} = &quot;&quot;;
+    $self-&gt;{sig} = &quot;&quot;;
+
+    return $self;
+}
+
+sub parse
+{
+    my $self = shift;
+
+    #Minimal SKE parsing. Only supports DHE at the moment (if its not DHE
+    #the parsing data will be trash...which is ok as long as we don't try to
+    #use it)
+
+    my $p_len = unpack('n', $self-&gt;data);
+    my $ptr = 2;
+    my $p = substr($self-&gt;data, $ptr, $p_len);
+    $ptr += $p_len;
+
+    my $g_len = unpack('n', substr($self-&gt;data, $ptr));
+    $ptr += 2;
+    my $g = substr($self-&gt;data, $ptr, $g_len);
+    $ptr += $g_len;
+
+    my $pub_key_len = unpack('n', substr($self-&gt;data, $ptr));
+    $ptr += 2;
+    my $pub_key = substr($self-&gt;data, $ptr, $pub_key_len);
+    $ptr += $g_len;
+
+    #We assume its signed
+    my $sig_len = unpack('n', substr($self-&gt;data, $ptr));
+    $ptr += 2;
+    my $sig = substr($self-&gt;data, $ptr, $sig_len);
+    $ptr += $sig_len;
+
+    $self-&gt;p($p);
+    $self-&gt;g($g);
+    $self-&gt;pub_key($pub_key);
+    $self-&gt;sig($sig);
+}
+
+
+#Reconstruct the on-the-wire message data following changes
+sub set_message_contents
+{
+    my $self = shift;
+    my $data;
+
+    $data = pack('n', length($self-&gt;p));
+    $data .= $self-&gt;p;
+    $data .= pack('n', length($self-&gt;g));
+    $data .= $self-&gt;g;
+    $data .= pack('n', length($self-&gt;pub_key));
+    $data .= $self-&gt;pub_key;
+    if (length($self-&gt;sig) &gt; 0) {
+        $data .= pack('n', length($self-&gt;sig));
+        $data .= $self-&gt;sig;
+    }
+
+    $self-&gt;data($data);
+}
+
+#Read/write accessors
+#DHE
+sub p
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{p} = shift;
+    }
+    return $self-&gt;{p};
+}
+sub g
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{g} = shift;
+    }
+    return $self-&gt;{g};
+}
+sub pub_key
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{pub_key} = shift;
+    }
+    return $self-&gt;{pub_key};
+}
+sub sig
+{
+    my $self = shift;
+    if (@_) {
+      $self-&gt;{sig} = shift;
+    }
+    return $self-&gt;{sig};
+}
+1;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001540.html">[openssl-commits] [openssl]  master update
</A></li>
	<LI>Next message: <A HREF="001544.html">[openssl-commits] [openssl]  master update
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1543">[ date ]</a>
              <a href="thread.html#1543">[ thread ]</a>
              <a href="subject.html#1543">[ subject ]</a>
              <a href="author.html#1543">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-commits.html">More information about the openssl-commits
mailing list</a><br>
</body></html>
