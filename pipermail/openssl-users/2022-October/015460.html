<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Updating RSA public key generation and signature verification from 1.1.1 to 3.0
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-users/2022-October/index.html" >
   <LINK REL="made" HREF="mailto:openssl-users%40openssl.org?Subject=Re%3A%20Updating%20RSA%20public%20key%20generation%20and%20signature%20verification%0A%20from%201.1.1%20to%203.0&In-Reply-To=%3Cbf1a47039b2d5a644a13d0a03b8acbc4d4b59008.camel%40openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="015475.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Updating RSA public key generation and signature verification from 1.1.1 to 3.0</H1>
    <B>Tomas Mraz</B> 
    <A HREF="mailto:openssl-users%40openssl.org?Subject=Re%3A%20Updating%20RSA%20public%20key%20generation%20and%20signature%20verification%0A%20from%201.1.1%20to%203.0&In-Reply-To=%3Cbf1a47039b2d5a644a13d0a03b8acbc4d4b59008.camel%40openssl.org%3E"
       TITLE="Updating RSA public key generation and signature verification from 1.1.1 to 3.0">tomas at openssl.org
       </A><BR>
    <I>Sat Oct  1 08:35:36 UTC 2022</I>
    <P><UL>
        
        <LI>Next message (by thread): <A HREF="015475.html">How to extract .TSR / .TST from .P7M? Or backdating self-signed .TSR file?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15460">[ date ]</a>
              <a href="thread.html#15460">[ thread ]</a>
              <a href="subject.html#15460">[ subject ]</a>
              <a href="author.html#15460">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I am glad to hear that.

Regards,
Tomas Mraz, OpenSSL

On Fri, 2022-09-30 at 17:18 +0000, GonzalezVillalobos, Diego wrote:
&gt;<i> [AMD Official Use Only - General]
</I>&gt;<i> 
</I>&gt;<i> Hello Tomas,
</I>&gt;<i> 
</I>&gt;<i> There was a logic error in my code, I did not realize that the first
</I>&gt;<i> iteration of the verification was supposed to fail. The verification
</I>&gt;<i> is working correctly! I apologize for my last response. I really
</I>&gt;<i> appreciate all your help!
</I>&gt;<i> 
</I>&gt;<i> Thank you very much,
</I>&gt;<i> 
</I>&gt;<i> Diego Gonzalez
</I>&gt;<i> ---------------------------------------------------------------------
</I>&gt;<i> -------------------------------------------------------------
</I>&gt;<i> &#160;
</I>&gt;<i> 
</I>&gt;<i> -----Original Message-----
</I>&gt;<i> From: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-users.html">tomas at openssl.org</A>&gt; 
</I>&gt;<i> Sent: Friday, September 30, 2022 1:22 AM
</I>&gt;<i> To: GonzalezVillalobos, Diego &lt;<A HREF="../../../mailman/listinfo/openssl-users.html">Diego.GonzalezVillalobos at amd.com</A>&gt;;
</I>&gt;<i> <A HREF="../../../mailman/listinfo/openssl-users.html">openssl-users at openssl.org</A>
</I>&gt;<i> Subject: Re: Updating RSA public key generation and signature
</I>&gt;<i> verification from 1.1.1 to 3.0
</I>&gt;<i> 
</I>&gt;<i> Caution: This message originated from an External Source. Use proper
</I>&gt;<i> caution when opening attachments, clicking links, or responding.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Hi,
</I>&gt;<i> 
</I>&gt;<i> unfortunately I do not see anything wrong with the code. Does the
</I>&gt;<i> EVP_DigestVerifyFinal return 0 or negative value? I do not think this
</I>&gt;<i> is a bug in OpenSSL as this API is thoroughly tested and it is highly
</I>&gt;<i> improbable that there would be a bug in the ECDSA verification
</I>&gt;<i> through this API.
</I>&gt;<i> 
</I>&gt;<i> I am currently out of ideas on what could be wrong or how to
</I>&gt;<i> investigate further. Perhaps someone else can chime in on what can be
</I>&gt;<i> wrong?
</I>&gt;<i> 
</I>&gt;<i> Tomas
</I>&gt;<i> 
</I>&gt;<i> On Thu, 2022-09-29 at 19:22 +0000, GonzalezVillalobos, Diego wrote:
</I>&gt;<i> &gt; [AMD Official Use Only - General]
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Hello Tomas,
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; So, I made sure that px_size and py_size are equal to the group
</I>&gt;<i> &gt; order 
</I>&gt;<i> &gt; (48). I was able to verify successfully using our previous method
</I>&gt;<i> &gt; (deprecated) with the new key generation method, but I'm still not 
</I>&gt;<i> &gt; able to get the digestverify to work successfully. As a reminder
</I>&gt;<i> &gt; this 
</I>&gt;<i> &gt; is how we were verifying before:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; // Determine if SHA_TYPE is 256 bit or 384 bit if 
</I>&gt;<i> &gt; (parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_RSA_SHA256 || 
</I>&gt;<i> &gt; parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_ECDSA_SHA256
</I>&gt;<i> &gt; ||parent_cert-
</I>&gt;<i> &gt; &gt; pub_key_algo == SEV_SIG_ALGO_ECDH_SHA256)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sha_type = SHA_TYPE_256;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sha_digest = sha_digest_256;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sha_length = sizeof(hmac_sha_256);
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; else if (parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_RSA_SHA384 || 
</I>&gt;<i> &gt; parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_ECDSA_SHA384 || 
</I>&gt;<i> &gt; parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_ECDH_SHA384)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sha_type = SHA_TYPE_384;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sha_digest = sha_digest_384;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; sha_length = sizeof(hmac_sha_512);
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; else
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; // 1. SHA256 hash the cert from Version through pub_key 
</I>&gt;<i> &gt; parameters
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; // Calculate the digest of the input message&#160;&#160; rsa.c -&gt;
</I>&gt;<i> &gt; rsa_pss_verify_msg()
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; // SHA256/SHA384 hash the cert from the [Version:pub_key] 
</I>&gt;<i> &gt; params
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; uint32_t pub_key_offset = offsetof(sev_cert, sig_1_usage);
</I>&gt;<i> &gt; // 
</I>&gt;<i> &gt; 16 + sizeof(SEV_PUBKEY)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!digest_sha((uint8_t *)child_cert, pub_key_offset, 
</I>&gt;<i> &gt; sha_digest, sha_length, sha_type)) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; if ((parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_ECDSA_SHA256) ||
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (parent_cert-&gt;pub_key_algo ==
</I>&gt;<i> &gt; SEV_SIG_ALGO_ECDSA_SHA384) ||
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (parent_cert-&gt;pub_key_algo ==
</I>&gt;<i> &gt; SEV_SIG_ALGO_ECDH_SHA256)&#160; ||
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (parent_cert-&gt;pub_key_algo ==
</I>&gt;<i> &gt; SEV_SIG_ALGO_ECDH_SHA384)) {&#160;&#160;&#160;&#160;&#160; // ecdsa.c -&gt; sign_verify_msg
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ECDSA_SIG *tmp_ecdsa_sig = ECDSA_SIG_new();
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BIGNUM *r_big_num = BN_new();
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BIGNUM *s_big_num = BN_new();
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Store the x and y components as separate BIGNUM 
</I>&gt;<i> &gt; objects. The values in the
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // SEV certificate are little-endian, must reverse 
</I>&gt;<i> &gt; bytes before storing in BIGNUM
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; r_big_num = BN_lebin2bn(cert_sig[i].ecdsa.r,
</I>&gt;<i> &gt; sizeof(sev_ecdsa_sig::r), r_big_num);&#160;&#160;&#160; // LE to BE
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; s_big_num = BN_lebin2bn(cert_sig[i].ecdsa.s, 
</I>&gt;<i> &gt; sizeof(sev_ecdsa_sig::s), s_big_num);
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Calling ECDSA_SIG_set0() transfers the memory 
</I>&gt;<i> &gt; management of the values to
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // the ECDSA_SIG object, and therefore the values
</I>&gt;<i> &gt; that 
</I>&gt;<i> &gt; have been passed
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // in should not be freed directly after this
</I>&gt;<i> &gt; function 
</I>&gt;<i> &gt; has been called
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ECDSA_SIG_set0(tmp_ecdsa_sig, r_big_num,
</I>&gt;<i> &gt; s_big_num) != 1) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BN_free(s_big_num);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Frees
</I>&gt;<i> &gt; BIGNUMs manually here
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BN_free(r_big_num);
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ECDSA_SIG_free(tmp_ecdsa_sig);
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; continue;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; EC_KEY *tmp_ec_key =
</I>&gt;<i> &gt; EVP_PKEY_get1_EC_KEY(parent_signing_key); // Make a local key so
</I>&gt;<i> &gt; you 
</I>&gt;<i> &gt; can free it later
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ECDSA_do_verify(sha_digest,
</I>&gt;<i> &gt; (uint32_t)sha_length, 
</I>&gt;<i> &gt; tmp_ecdsa_sig, tmp_ec_key) != 1) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; EC_KEY_free(tmp_ec_key);
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ECDSA_SIG_free(tmp_ecdsa_sig);&#160;&#160;&#160;&#160;&#160; // Frees
</I>&gt;<i> &gt; BIGNUMs too
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; continue;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; found_match = true;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; EC_KEY_free(tmp_ec_key);
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ECDSA_SIG_free(tmp_ecdsa_sig);&#160;&#160;&#160;&#160;&#160; // Frees
</I>&gt;<i> &gt; BIGNUMs
</I>&gt;<i> &gt; too
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Digest sha function:
</I>&gt;<i> &gt; bool digest_sha(const void *msg, size_t msg_len, uint8_t *digest,
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; size_t digest_len, SHA_TYPE sha_type) {
</I>&gt;<i> &gt; &#160;&#160;&#160; bool ret = false;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160; do {&#160;&#160;&#160; //TODO 384 vs 512 is all a mess
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; if ((sha_type == SHA_TYPE_256 &amp;&amp; digest_len !=
</I>&gt;<i> &gt; SHA256_DIGEST_LENGTH)/* ||
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (sha_type == SHA_TYPE_384 &amp;&amp; digest_len !=
</I>&gt;<i> &gt; SHA384_DIGEST_LENGTH)*/)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; if (sha_type == SHA_TYPE_256) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; SHA256_CTX context;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (SHA256_Init(&amp;context) != 1)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (SHA256_Update(&amp;context, (void *)msg, msg_len) != 1)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (SHA256_Final(digest, &amp;context) != 1)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; else if (sha_type == SHA_TYPE_384) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; SHA512_CTX context;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (SHA384_Init(&amp;context) != 1)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (SHA384_Update(&amp;context, (void *)msg, msg_len) != 1)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (SHA384_Final(digest, &amp;context) != 1)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; ret = true;
</I>&gt;<i> &gt; &#160;&#160;&#160; } while (0);
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160; return ret;
</I>&gt;<i> &gt; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; This works using the new EC EVP key generation.
</I>&gt;<i> &gt; The current verification method keeps failing:
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; if ((parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_ECDSA_SHA256) ||
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (parent_cert-&gt;pub_key_algo ==
</I>&gt;<i> &gt; SEV_SIG_ALGO_ECDSA_SHA384) ||
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (parent_cert-&gt;pub_key_algo ==
</I>&gt;<i> &gt; SEV_SIG_ALGO_ECDH_SHA256)&#160; ||
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (parent_cert-&gt;pub_key_algo ==
</I>&gt;<i> &gt; SEV_SIG_ALGO_ECDH_SHA384)) {&#160;&#160;&#160;&#160;&#160; // ecdsa.c -&gt; sign_verify_msg
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ECDSA_SIG *tmp_ecdsa_sig = ECDSA_SIG_new();
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BIGNUM *r_big_num = BN_new();
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BIGNUM *s_big_num = BN_new();
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; uint32_t sig_len;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; unsigned char* der_sig = NULL;;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Store the x and y components as separate BIGNUM 
</I>&gt;<i> &gt; objects. The values in the
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // SEV certificate are little-endian, must reverse 
</I>&gt;<i> &gt; bytes before storing in BIGNUM
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; r_big_num = BN_lebin2bn(cert_sig[i].ecdsa.r,
</I>&gt;<i> &gt; sizeof(sev_ecdsa_sig::r), r_big_num);&#160;&#160;&#160; // LE to BE
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; s_big_num = BN_lebin2bn(cert_sig[i].ecdsa.s, 
</I>&gt;<i> &gt; sizeof(sev_ecdsa_sig::s), s_big_num);
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Calling ECDSA_SIG_set0() transfers the memory 
</I>&gt;<i> &gt; management of the values to
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // the ECDSA_SIG object, and therefore the values
</I>&gt;<i> &gt; that 
</I>&gt;<i> &gt; have been passed
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // in should not be freed directly after this
</I>&gt;<i> &gt; function 
</I>&gt;<i> &gt; has been called
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ECDSA_SIG_set0(tmp_ecdsa_sig,
</I>&gt;<i> &gt; r_big_num,s_big_num) != 1) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BN_free(s_big_num); // FreesBIGNUMs manually
</I>&gt;<i> &gt; here
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BN_free(r_big_num);
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ECDSA_SIG_free(tmp_ecdsa_sig);
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int der_sig_len = i2d_ECDSA_SIG(tmp_ecdsa_sig, 
</I>&gt;<i> &gt; &amp;der_sig);
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // der_sig = static_cast&lt;unsigned 
</I>&gt;<i> &gt; char*&gt;(OPENSSL_malloc(der_sig_len));
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // unsigned char* der_iter = der_sig;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // der_sig_len = i2d_ECDSA_SIG(tmp_ecdsa_sig, 
</I>&gt;<i> &gt; &amp;der_iter); // &lt;= bugfix here
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (der_sig_len == 0) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;sig length invalid&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (der_sig == NULL) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;sig generation failed&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // loop through the array elements
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; for (size_t i = 0; i &lt; der_sig_len; i++) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; der_sig[i] &lt;&lt; ' ';
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; verify_md_ctx = EVP_MD_CTX_new();
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!verify_md_ctx) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;Error md verify context &quot; &lt;&lt; endl;;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (EVP_DigestVerifyInit(verify_md_ctx, NULL, 
</I>&gt;<i> &gt; (parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_ECDSA_SHA256 || 
</I>&gt;<i> &gt; parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_ECDH_SHA256) ?
</I>&gt;<i> &gt; EVP_sha256(): EVP_sha384(), NULL, parent_signing_key) &lt;= 0) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;Init fails &quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (EVP_DigestVerifyUpdate(verify_md_ctx, (uint8_t 
</I>&gt;<i> &gt; *)child_cert, pub_key_offset) &lt;= 0){&#160;&#160;&#160; // Calls SHA256_UPDATE
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;updating digest fails&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int ret = EVP_DigestVerifyFinal(verify_md_ctx,
</I>&gt;<i> &gt; der_sig, der_sig_len);
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ret == 0) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;EC Verify digest fails&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else if (ret &lt; 0) {
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; printf(&quot;Failed Final Verify 
</I>&gt;<i> &gt; %s\n&quot;,ERR_error_string(ERR_get_error(),NULL));
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;EC Verify error&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; found_match = true;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;SEV EC verification Succesful&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (verify_md_ctx)
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; EVP_MD_CTX_free(verify_md_ctx);
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; The only difference still is using the der signature; besides that,
</I>&gt;<i> &gt; it 
</I>&gt;<i> &gt; is the same. Could it be a bug?
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Thank you,
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Diego Gonzalez
</I>&gt;<i> &gt; -------------------------------------------------------------------
</I>&gt;<i> &gt; --
</I>&gt;<i> &gt; -------------------------------------------------------------
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; -----Original Message-----
</I>&gt;<i> &gt; From: Tomas Mraz &lt;<A HREF="../../../mailman/listinfo/openssl-users.html">tomas at openssl.org</A>&gt;
</I>&gt;<i> &gt; Sent: Thursday, September 29, 2022 1:12 AM
</I>&gt;<i> &gt; To: GonzalezVillalobos, Diego &lt;<A HREF="../../../mailman/listinfo/openssl-users.html">Diego.GonzalezVillalobos at amd.com</A>&gt;;
</I>&gt;<i> &gt; <A HREF="../../../mailman/listinfo/openssl-users.html">openssl-users at openssl.org</A>
</I>&gt;<i> &gt; Subject: Re: Updating RSA public key generation and signature 
</I>&gt;<i> &gt; verification from 1.1.1 to 3.0
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Caution: This message originated from an External Source. Use
</I>&gt;<i> &gt; proper 
</I>&gt;<i> &gt; caution when opening attachments, clicking links, or responding.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Hi,
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; comments below.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; On Wed, 2022-09-28 at 22:12 +0000, GonzalezVillalobos, Diego wrote:
</I>&gt;<i> &gt; &gt; [AMD Official Use Only - General]
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Hello Tomas,
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; I generated the key as you suggested, and I am no longer getting
</I>&gt;<i> &gt; &gt; an 
</I>&gt;<i> &gt; &gt; error message! Thank you for that. Here is how I'm generating the
</I>&gt;<i> &gt; &gt; key
</I>&gt;<i> &gt; &gt; now:
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; // SEV certificate are little-endian, must reverse bytes before 
</I>&gt;<i> &gt; &gt; generating key
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ((cert-&gt;pub_key_algo == SEV_SIG_ALGO_ECDSA_SHA256)
</I>&gt;<i> &gt; &gt; &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (cert-&gt;pub_key_algo ==
</I>&gt;<i> &gt; &gt; SEV_SIG_ALGO_ECDSA_SHA384)) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //Grab x param and flip bytes to BE
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; memcpy(px, &amp;cert-&gt;pub_key.ecdsa.qx,
</I>&gt;<i> &gt; &gt; ec_group_order);
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(!sev::reverse_bytes(px, sizeof(px)))
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //Grab y param and flip bytes to BE
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; memcpy(py, &amp;cert-&gt;pub_key.ecdsa.qy,
</I>&gt;<i> &gt; &gt; ec_group_order);
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(!sev::reverse_bytes(py, sizeof(py)))
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; else if ((cert-&gt;pub_key_algo ==
</I>&gt;<i> &gt; &gt; SEV_SIG_ALGO_ECDH_SHA256)&#160; ||
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; (cert-&gt;pub_key_algo ==
</I>&gt;<i> &gt; &gt; SEV_SIG_ALGO_ECDH_SHA384))
</I>&gt;<i> &gt; &gt; {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //Grab x param and flip bytes to BE
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; memcpy(px, &amp;cert-&gt;pub_key.ecdh.qx,
</I>&gt;<i> &gt; &gt; ec_group_order);
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(!sev::reverse_bytes(px, sizeof(px)))
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //Grab y param and flip bytes to BE
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; memcpy(py, &amp;cert-&gt;pub_key.ecdh.qy,
</I>&gt;<i> &gt; &gt; ec_group_order);
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(!sev::reverse_bytes(py, sizeof(py)))
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int px_size = sizeof(px)/sizeof(*px);
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int py_size = sizeof(py)/sizeof(*py);
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Will contain x and y components
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; unsigned char public_key_xy[1 + px_size + py_size] = 
</I>&gt;<i> &gt; &gt; {0};
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //Add point conversion as first value
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; public_key_xy[0] = POINT_CONVERSION_UNCOMPRESSED;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //Add x components after point compression
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; memcpy(public_key_xy + 1, px, px_size);
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; //Add y components after x
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; memcpy(public_key_xy + px_size + 1, py ,py_size);
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // int nid = EC_curve_nist2nid(&quot;P-384&quot;);&#160;&#160; //
</I>&gt;<i> &gt; &gt; NID_secp384r1
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OSSL_PARAM_BLD *params_build = OSSL_PARAM_BLD_new();
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ( params_build == NULL ) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;Params build fails&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!OSSL_PARAM_BLD_push_utf8_string(params_build,
</I>&gt;<i> &gt; &gt; OSSL_PKEY_PARAM_GROUP_NAME, &quot;P-384&quot;, 0)) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout&lt;&lt; &quot;Push EC curve to build fails&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!OSSL_PARAM_BLD_push_octet_string(params_build,
</I>&gt;<i> &gt; &gt; OSSL_PKEY_PARAM_PUB_KEY, public_key_xy, sizeof(public_key_xy))) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;Error: failed to push qx into param
</I>&gt;<i> &gt; &gt; build.&quot;
</I>&gt;<i> &gt; &gt; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OSSL_PARAM *params =
</I>&gt;<i> &gt; &gt; OSSL_PARAM_BLD_to_param(params_build);
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ( params == NULL ) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;Error: building parameters.&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; OSSL_PARAM_BLD_free(params_build);
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; key_gen_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(EVP_PKEY_fromdata_init(key_gen_ctx) != 1) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;failed to initialize key creation.&quot; &lt;&lt; 
</I>&gt;<i> &gt; &gt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if(EVP_PKEY_fromdata(key_gen_ctx, &amp;evp_pub_key, 
</I>&gt;<i> &gt; &gt; EVP_PKEY_PUBLIC_KEY, params) != 1) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;key generation breaks&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; printf(&quot;Failed Final Verify 
</I>&gt;<i> &gt; &gt; %s\n&quot;,ERR_error_string(ERR_get_error(),NULL));
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (EVP_PKEY_get_base_id(evp_pub_key) != EVP_PKEY_EC)
</I>&gt;<i> &gt; &gt; {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;wrong key type&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!evp_pub_key) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;no evp pkey&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;compile key succesful&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160; cmd_ret = STATUS_SUCCESS;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Although the key generation works and I'm not getting a verify
</I>&gt;<i> &gt; &gt; error 
</I>&gt;<i> &gt; &gt; anymore, I am still unsuccessful on verifying the digest. It
</I>&gt;<i> &gt; &gt; keeps 
</I>&gt;<i> &gt; &gt; failing (returning 0). Here is how I'm currently trying to do the
</I>&gt;<i> &gt; &gt; verification.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; Are you sure the px_size and py_size is equal to the group order?
</I>&gt;<i> &gt; The 
</I>&gt;<i> &gt; x and y values must be padded to the group order with 0 (at the
</I>&gt;<i> &gt; start 
</I>&gt;<i> &gt; because the values need to be BE).
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt; ECDSA_SIG *tmp_ecdsa_sig = ECDSA_SIG_new();
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BIGNUM *r_big_num = BN_new();
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BIGNUM *s_big_num = BN_new();
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; uint32_t sig_len;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; unsigned char* der_sig;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Store the x and y components as separate
</I>&gt;<i> &gt; &gt; BIGNUM 
</I>&gt;<i> &gt; &gt; objects. The values in the
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // SEV certificate are little-endian, must
</I>&gt;<i> &gt; &gt; reverse 
</I>&gt;<i> &gt; &gt; bytes before storing in BIGNUM
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; r_big_num = BN_lebin2bn(cert_sig[i].ecdsa.r,
</I>&gt;<i> &gt; &gt; sizeof(sev_ecdsa_sig::r), r_big_num);&#160;&#160;&#160; // LE to BE
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; s_big_num = BN_lebin2bn(cert_sig[i].ecdsa.s, 
</I>&gt;<i> &gt; &gt; sizeof(sev_ecdsa_sig::s), s_big_num);
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Calling ECDSA_SIG_set0() transfers the memory 
</I>&gt;<i> &gt; &gt; management of the values to
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // the ECDSA_SIG object, and therefore the values
</I>&gt;<i> &gt; &gt; that have been passed
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; // in should not be freed directly after this 
</I>&gt;<i> &gt; &gt; function has been called
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ECDSA_SIG_set0(tmp_ecdsa_sig,
</I>&gt;<i> &gt; &gt; r_big_num,s_big_num) != 1) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BN_free(s_big_num); // FreesBIGNUMs manually 
</I>&gt;<i> &gt; &gt; here
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; BN_free(r_big_num);
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ECDSA_SIG_free(tmp_ecdsa_sig);
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int der_sig_len = i2d_ECDSA_SIG(tmp_ecdsa_sig, 
</I>&gt;<i> &gt; &gt; NULL);
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; der_sig = static_cast&lt;unsigned 
</I>&gt;<i> &gt; &gt; char*&gt;(OPENSSL_malloc(der_sig_len));
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; unsigned char* der_iter = der_sig;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; der_sig_len = i2d_ECDSA_SIG(tmp_ecdsa_sig, 
</I>&gt;<i> &gt; &gt; &amp;der_iter); // &lt;= bugfix here
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (der_sig_len == 0) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;sig length invalid&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (der_sig == NULL) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;sig generation failed&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; You do not need to call i2d_ECDSA_SIG() twice. Just assign NULL to 
</I>&gt;<i> &gt; der_iter and i2d_ECDSA_SIG(tmp_ecdsa_sig, &amp;der_iter) call will 
</I>&gt;<i> &gt; allocate the buffer for the encoded signature for you.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; verify_md_ctx = EVP_MD_CTX_new();
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!verify_md_ctx) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;Error md verify context &quot; &lt;&lt; endl;;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (EVP_DigestVerifyInit(verify_md_ctx, NULL, 
</I>&gt;<i> &gt; &gt; (parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_ECDSA_SHA256 || 
</I>&gt;<i> &gt; &gt; parent_cert-&gt;pub_key_algo == SEV_SIG_ALGO_ECDH_SHA256) ?
</I>&gt;<i> &gt; &gt; EVP_sha256(): EVP_sha384(), NULL, parent_signing_key) &lt;= 0) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;Init fails &quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (EVP_DigestVerifyUpdate(verify_md_ctx,
</I>&gt;<i> &gt; &gt; (uint8_t 
</I>&gt;<i> &gt; &gt; *)child_cert, pub_key_offset) &lt;= 0){&#160;&#160;&#160; // Calls SHA256_UPDATE
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;updating digest fails&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; int ret = EVP_DigestVerifyFinal(verify_md_ctx,
</I>&gt;<i> &gt; &gt; der_sig, der_sig_len);
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; ret &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (ret == 0) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;EC Verify digest fails&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; } else if (ret &lt; 0) {
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; printf(&quot;Failed Final Verify 
</I>&gt;<i> &gt; &gt; %s\n&quot;,ERR_error_string(ERR_get_error(),NULL));
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;EC Verify error&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; found_match = true;
</I>&gt;<i> &gt; &gt; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; cout &lt;&lt; &quot;SEV EC verification Succesful&quot; &lt;&lt; endl;
</I>&gt;<i> &gt; &gt; 
</I>&gt;<i> &gt; &gt; Could it be because I'm creating a ECDSA SIG object and then
</I>&gt;<i> &gt; &gt; turning 
</I>&gt;<i> &gt; &gt; it into a der format to verify? Again, suggestions would be 
</I>&gt;<i> &gt; &gt; appreciated.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; No, that should be correct. The signature as produced or verified
</I>&gt;<i> &gt; by 
</I>&gt;<i> &gt; the EVP_DigestSignFinal or EVP_DigestVerifyFinal should be in the
</I>&gt;<i> &gt; DER 
</I>&gt;<i> &gt; encoding of the ECDSA_SIG. So you have that correct.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; I do not see any apparent problem with your code apart of the
</I>&gt;<i> &gt; remarks 
</I>&gt;<i> &gt; above.
</I>&gt;<i> &gt; 
</I>&gt;<i> &gt; --
</I>&gt;<i> &gt; Tom&#225;&#353; Mr&#225;z, OpenSSL
</I>&gt;<i> 
</I>&gt;<i> --
</I>&gt;<i> Tom&#225;&#353; Mr&#225;z, OpenSSL
</I>
-- 
Tom&#225;&#353; Mr&#225;z, OpenSSL

</PRE>



<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message (by thread): <A HREF="015475.html">How to extract .TSR / .TST from .P7M? Or backdating self-signed .TSR file?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15460">[ date ]</a>
              <a href="thread.html#15460">[ thread ]</a>
              <a href="subject.html#15460">[ subject ]</a>
              <a href="author.html#15460">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-users.html">More information about the openssl-users
mailing list</a><br>
</body></html>
