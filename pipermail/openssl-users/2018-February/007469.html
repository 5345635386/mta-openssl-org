<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-users] crash in `sha1_block_data_order_avx`
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-users/2018-February/index.html" >
   <LINK REL="made" HREF="mailto:openssl-users%40openssl.org?Subject=Re%3A%20%5Bopenssl-users%5D%20crash%20in%20%60sha1_block_data_order_avx%60&In-Reply-To=%3C1518331057002.naipotz0emlepzfda2roqntx%40android.mail.163.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007468.html">
   <LINK REL="Next"  HREF="007470.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-users] crash in `sha1_block_data_order_avx`</H1>
    <B>Xiang Ren</B> 
    <A HREF="mailto:openssl-users%40openssl.org?Subject=Re%3A%20%5Bopenssl-users%5D%20crash%20in%20%60sha1_block_data_order_avx%60&In-Reply-To=%3C1518331057002.naipotz0emlepzfda2roqntx%40android.mail.163.com%3E"
       TITLE="[openssl-users] crash in `sha1_block_data_order_avx`">renxiang0214 at gmail.com
       </A><BR>
    <I>Sun Feb 11 06:41:02 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="007468.html">[openssl-users] Creating a Json Web Key
</A></li>
        <LI>Next message: <A HREF="007470.html">[openssl-users] crash in `sha1_block_data_order_avx`
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7469">[ date ]</a>
              <a href="thread.html#7469">[ thread ]</a>
              <a href="subject.html#7469">[ subject ]</a>
              <a href="author.html#7469">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Anybody has the same trouble with `sha1_block_data_order_avx`? I'm using openssl-1.0.2n. This is coredump information: &#160; &#160; &#160;# gdb ./channel.old core.58820 &#160; &#160; &#160;GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-80.1 &#160; &#160; &#160;Copyright (C) 2013 Free Software Foundation, Inc. &#160; &#160; &#160;License GPLv3+: GNU GPL version 3 or later &lt;<A HREF="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</A>&gt; &#160; &#160; &#160;This is free software: you are free to change and redistribute it. &#160; &#160; &#160;There is NO WARRANTY, to the extent permitted by law. &#160;Type &quot;show copying&quot; &#160; &#160; &#160;and &quot;show warranty&quot; for details. &#160; &#160; &#160;This GDB was configured as &quot;x86_64-Huawei-linux-gnu&quot;. &#160; &#160; &#160;For bug reporting instructions, please see: &#160; &#160; &#160;&lt;<A HREF="http://www.gnu.org/software/gdb/bugs/">http://www.gnu.org/software/gdb/bugs/</A>&gt;... &#160; &#160; &#160;Reading symbols from /home/imax/chuqq/20180207/channel.old...done. &#160; &#160; &#160;warning: core file may not match specified executable file. &#160; &#160; &#160;[New LWP 59134] &#160; &#160; &#160;[New LWP 59135] &#160; &#160; &#160;[New LWP 59133] &#160; &#160; &#160;[New LWP 59136] &#160; &#160; &#160;[New LWP 59115] &#160; &#160; &#160;[New LWP 59116] &#160; &#160; &#160;[New LWP 59117] &#160; &#160; &#160;[New LWP 59118] &#160; &#160; &#160;[New LWP 59119] &#160; &#160; &#160;[New LWP 59120] &#160; &#160; &#160;[New LWP 59121] &#160; &#160; &#160;[New LWP 59122] &#160; &#160; &#160;[New LWP 59123] &#160; &#160; &#160;[New LWP 59125] &#160; &#160; &#160;[New LWP 59126] &#160; &#160; &#160;[New LWP 59124] &#160; &#160; &#160;[New LWP 59128] &#160; &#160; &#160;[New LWP 59127] &#160; &#160; &#160;[New LWP 59129] &#160; &#160; &#160;[New LWP 59130] &#160; &#160; &#160;[New LWP 59114] &#160; &#160; &#160;[New LWP 59131] &#160; &#160; &#160;[New LWP 59132] &#160; &#160; &#160;[New LWP 58820] &#160; &#160; &#160;[Thread debugging using libthread_db enabled] &#160; &#160; &#160;Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;. &#160; &#160; &#160;Core was generated by `../channel/channel -configPath /channel/channel-1'. &#160; &#160; &#160;Program terminated with signal 11, Segmentation fault. &#160; &#160; &#160;#0 &#160;0x00000000007d591a in sha1_block_data_order_avx () &#160; &#160; &#160;Missing separate debuginfos, use: debuginfo-install glibc-2.17-111.h23.x86_64 libgcc-4.8.5-4.h2.x86_64 numactl-libs-2.0.9-6.x86_64 &#160; &#160; &#160;(gdb) bt &#160; &#160; &#160;#0 &#160;0x00000000007d591a in sha1_block_data_order_avx () &#160; &#160; &#160;#1 &#160;0xca62c1d6ca62c1d6 in ?? () &#160; &#160; &#160;#2 &#160;0xca62c1d6ca62c1d6 in ?? () &#160; &#160; &#160;#3 &#160;0xca62c1d6ca62c1d6 in ?? () &#160; &#160; &#160;#4 &#160;0xca62c1d6ca62c1d6 in ?? () &#160; &#160; &#160;#5 &#160;0xca62c1d6ca62c1d6 in ?? () &#160; &#160; &#160;#6 &#160;0xca62c1d6ca62c1d6 in ?? () &#160; &#160; &#160;#7 &#160;0xca62c1d6ca62c1d6 in ?? () &#160; &#160; &#160;#8 &#160;0xca62c1d6ca62c1d6 in ?? () &#160; &#160; &#160;#9 &#160;0x0000000009c0aeb1 in ?? () &#160; &#160; &#160;#10 0x00007f38d6aac1a4 in malloc () from /lib64/libc.so.6 &#160; &#160; &#160;#11 0x0000000000773c88 in CRYPTO_malloc () &#160; &#160; &#160;#12 0x00000000007cff2f in SHA1_Update () &#160; &#160; &#160;#13 0x00000000007911e5 in ssleay_rand_bytes () &#160; &#160; &#160;#14 0x000000000078738c in RSA_padding_add_PKCS1_OAEP () &#160; &#160; &#160;#15 0x0000000000784d90 in RSA_eay_public_encrypt () &#160; &#160; &#160;#16 0x000000000048bd35 in rsa_public_encrypt (rsa_input=0x7f369c0190d0 &quot;r\215&#23808;\332\350\202\353^$%\215\300s.kz\301?\207p}\363kz\301?\207p}\363EB5E24258DC0732E[*****5.26.157:39044]&quot;, input_len=32, &#160; &#160; &#160;&#160; &#160; &#160;enc_out=0x7f369c019120 &quot;&quot;, public_key=0x7f369c0193d0 &quot;0\202\001\&quot;0\r\006\t*\206H\206\367\r\001\001\001\005&quot;, key_len=294) at /root/1.1.0.11/xchannel-1.1.0.11/channel/mc_util.c:312 &#160; &#160; &#160;#17 0x0000000000488798 in generate_channel_aeskey_reply_by_device (device=0x7f2e13b6fb30, dev_rand=0x7f369c019290 &quot;r\215&#23808;\332&quot;, &lt;incomplete sequence \350\202&gt;, &#160; &#160; &#160;&#160; &#160; &#160;dev_aeskey=0x7f369c0192d0 &quot;kz\301?\207p}\363\064.182:9877,122.11.34.183:9877&quot;, publickey=0x7f369c0193d0 &quot;0\202\001\&quot;0\r\006\t*\206H\206\367\r\001\001\001\005&quot;, type=2, request_id=1966548338) &#160; &#160; &#160;&#160; &#160; &#160;at /root/1.1.0.11/xchannel-1.1.0.11/channel/mc_dpdktcp.c:391 &#160; &#160; &#160;#18 0x000000000049c499 in channel_aeskey_response (device=0x7f2e13b6fb30, &#160; &#160; &#160;&#160; &#160; &#160;message=0x7f2e10455380 &quot;^\304\a8\207(\360R\313k\026\205\220\357C\272\f\373\273@|\342xK}\214\267\367y\255f\245\200d\252\030\257\261\021z&#1047;\v\272\035\332DP2&#671;.\a\357\001\272A&#867;[\335-,\254&#15536;E\216\273\065\367&#10597;}\n\344:\215\237\300\037?\331[\&quot;\210&#170;\230\016\266\243C\362\264Sm\271f\020\373\336&#488;\024\342,(\265\021\257S\356\236\333\340\031\t5\325I\nQ\002&#1779;\345v!\016\237,\t\365n,\233\065\336)\005`\276`Ss\274&lt;\346\357Qw[D\321J\004\265\362\227p\251p\255\215\324\366\006\225\235\326$\204&#1891;\272hP\217\226\245\006\223\274vL\376\201,\017p\037\003\245\310\342&quot;, &lt;incomplete sequence \340\206&gt;..., msg_length=403, request_id=1966548338) &#160; &#160; &#160;&#160; &#160; &#160;at /root/1.1.0.11/xchannel-1.1.0.11/channel/mc_outer.c:1018 &#160; &#160; &#160;#19 0x000000000049a07c in outer_process_engine (arg=0x0) at /root/1.1.0.11/xchannel-1.1.0.11/channel/mc_outer.c:217 &#160; &#160; &#160;#20 0x00000000004e6dc4 in eal_thread_loop () &#160; &#160; &#160;#21 0x00007f38d6df4dc5 in start_thread () from /lib64/libpthread.so.0 &#160; &#160; &#160;#22 0x00007f38d6b227ed in clone () from /lib64/libc.so.6 &#160; &#160; &#160;(gdb) i r a &#160; &#160; &#160;rax &#160; &#160; &#160; &#160; &#160; &#160;0x8a53275e&#160; &#160; &#160;2320705374 &#160; &#160; &#160;rbx &#160; &#160; &#160; &#160; &#160; &#160;0xe4a22b4a&#160; &#160; &#160;3835833162 &#160; &#160; &#160;rcx &#160; &#160; &#160; &#160; &#160; &#160;0x9a663701&#160; &#160; &#160;2590390017 &#160; &#160; &#160;rdx &#160; &#160; &#160; &#160; &#160; &#160;0xd734ba54&#160; &#160; &#160;3610557012 &#160; &#160; &#160;rsi &#160; &#160; &#160; &#160; &#160; &#160;0x2cea828c&#160; &#160; &#160;753566348 &#160; &#160; &#160;rdi &#160; &#160; &#160; &#160; &#160; &#160;0x1a453563&#160; &#160; &#160;440743267 &#160; &#160; &#160;rbp &#160; &#160; &#160; &#160; &#160; &#160;0xdd2d0e5d&#160; &#160; &#160;0xdd2d0e5d &#160; &#160; &#160;rsp &#160; &#160; &#160; &#160; &#160; &#160;0x7f369c018140&#160; &#160; &#160;0x7f369c018140 &#160; &#160; &#160;r8 &#160; &#160; &#160; &#160; &#160; &#160; 0x7a38cb0&#160; &#160; &#160;128158896 &#160; &#160; &#160;r9 &#160; &#160; &#160; &#160; &#160; &#160; 0xd1dfd2&#160; &#160; &#160;13754322 &#160; &#160; &#160;r10 &#160; &#160; &#160; &#160; &#160; &#160;0xc8d592&#160; &#160; &#160;13161874 &#160; &#160; &#160;r11 &#160; &#160; &#160; &#160; &#160; &#160;0x7d7580&#160; &#160; &#160;8222080 &#160; &#160; &#160;r12 &#160; &#160; &#160; &#160; &#160; &#160;0xc8d592&#160; &#160; &#160;13161874 &#160; &#160; &#160;r13 &#160; &#160; &#160; &#160; &#160; &#160;0xffffffffffffffc0&#160; &#160; &#160;-64 &#160; &#160; &#160;r14 &#160; &#160; &#160; &#160; &#160; &#160;0x7f369c0181d8&#160; &#160; &#160;139872522306008 &#160; &#160; &#160;r15 &#160; &#160; &#160; &#160; &#160; &#160;0x9c0aeb1&#160; &#160; &#160;163622577 &#160; &#160; &#160;rip &#160; &#160; &#160; &#160; &#160; &#160;0x7d591a&#160; &#160; &#160;0x7d591a &lt;sha1_block_data_order_avx+2746&gt; &#160; &#160; &#160;eflags &#160; &#160; &#160; &#160; 0x13202&#160; &#160; &#160;[ IF #12 #13 RF ] &#160; &#160; &#160;cs &#160; &#160; &#160; &#160; &#160; &#160; 0x33&#160; &#160; &#160;51 &#160; &#160; &#160;ss &#160; &#160; &#160; &#160; &#160; &#160; 0x2b&#160; &#160; &#160;43 &#160; &#160; &#160;ds &#160; &#160; &#160; &#160; &#160; &#160; 0x0&#160; &#160; &#160;0 &#160; &#160; &#160;es &#160; &#160; &#160; &#160; &#160; &#160; 0x0&#160; &#160; &#160;0 &#160; &#160; &#160;fs &#160; &#160; &#160; &#160; &#160; &#160; 0x0&#160; &#160; &#160;0 &#160; &#160; &#160;gs &#160; &#160; &#160; &#160; &#160; &#160; 0x0&#160; &#160; &#160;0 &#160; &#160; &#160;st0 &#160; &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;st1 &#160; &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;st2 &#160; &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;st3 &#160; &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;st4 &#160; &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;st5 &#160; &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;st6 &#160; &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;st7 &#160; &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;fctrl &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;fstat &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;ftag &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;fiseg &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;fioff &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;foseg &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;fooff &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;fop &#160; &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;mxcsr &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;ymm0 &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;ymm1 &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;ymm2 &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;ymm3 &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;ymm4 &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;ymm5 &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;ymm6 &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit--- &#160; &#160; &#160;ymm7 &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;ymm8 &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;ymm9 &#160; &#160; &#160; &#160; &#160; *value not available* &#160; &#160; &#160;ymm10 &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;ymm11 &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;ymm12 &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;ymm13 &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;ymm14 &#160; &#160; &#160; &#160; &#160;*value not available* &#160; &#160; &#160;ymm15 &#160; &#160; &#160; &#160; &#160;*value not available* This is my code in production enviroment: &#160; &#160; &#160;struct rte_mbuf *generate_channel_aeskey_reply_by_device(device_t *device, uint8_t *dev_rand, uint8_t *dev_aeskey, uint8_t *publickey, int type, uint32_t request_id) &#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;char devicestr[DEVICE_STR_LEN] = {0}; &#160; &#160; &#160;&#160; &#160; &#160;device_str(devicestr, device-&gt;id, device-&gt;ip, device-&gt;port); &#160; &#160; &#160;&#160; &#160; &#160;// returned info&#65306; RSA(ClientPubKey, ClientRand[8]+DeviceID[8]+AesKey+ServerRand[8]) &#160; &#160; &#160;&#160; &#160; &#160;// ServerRand is same as aeskey &#160; &#160; &#160;&#160; &#160; &#160;uint8_t hybrid_key[CHANNEL_DEVICE_RAND_LEN + CHANNEL_DEVICE_ID_LEN + CHANNEL_AESKEY_LEN + CHANNEL_AESKEY_LEN] = {0}; &#160; &#160; &#160;&#160; &#160; &#160;xmemcpy(hybrid_key, dev_rand, CHANNEL_DEVICE_RAND_LEN); &#160; &#160; &#160;&#160; &#160; &#160;xmemcpy(hybrid_key + CHANNEL_DEVICE_RAND_LEN, device-&gt;id, CHANNEL_DEVICE_ID_LEN); &#160; &#160; &#160;&#160; &#160; &#160;xmemcpy(hybrid_key + CHANNEL_DEVICE_RAND_LEN + CHANNEL_DEVICE_ID_LEN, dev_aeskey, CHANNEL_AESKEY_LEN); &#160; &#160; &#160;&#160; &#160; &#160;xmemcpy(hybrid_key + CHANNEL_DEVICE_RAND_LEN + CHANNEL_DEVICE_ID_LEN + CHANNEL_AESKEY_LEN, dev_aeskey, CHANNEL_AESKEY_LEN); &#160; &#160; &#160;&#160; &#160; &#160;// alloc mem for encrypted &#8220;head_pub_key + aes_key&#8221; &#160; &#160; &#160;&#160; &#160; &#160;uint8_t encrypted_hybrid_key[RSA_CLIENT_ENCRYPTED_LEN] = {0}; &#160; &#160; &#160;&#160; &#160; &#160;int encrypted_length = rsa_public_encrypt(hybrid_key, CHANNEL_DEVICE_RAND_LEN + CHANNEL_DEVICE_ID_LEN + CHANNEL_AESKEY_LEN + CHANNEL_AESKEY_LEN, encrypted_hybrid_key, publickey, CHANNEL_PUBKEY_LEN); &#160; &#160; &#160;&#160; &#160; &#160;if (encrypted_length != RSA_CLIENT_ENCRYPTED_LEN) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;TLOGE(&quot;generate_channel_aeskey_reply_by_device&quot;, &quot;%s&quot;, &quot;rsa_public_encrypt failed to encrypted aeskey_reply. encrypted_length : %d&quot;, &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160; &#160;devicestr, encrypted_length); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return NULL; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;// type=(TYPE_PT_AESKEY_RES|TYPE_PT_AESKEY_UPDATE_REQ) &#160; &#160; &#160;&#160; &#160; &#160;struct rte_mbuf *rpl_mbuf = generate_channel_pkt_by_device(device, encrypted_hybrid_key, RSA_CLIENT_ENCRYPTED_LEN, type, request_id); &#160; &#160; &#160;&#160; &#160; &#160;if (rpl_mbuf == NULL) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;TLOGE(&quot;generate_channel_aeskey_reply_by_device&quot;, &quot;%s&quot;, &quot;rte_pktmbuf_alloc failed to allocate mbuf.&quot;, devicestr); &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;return rpl_mbuf; &#160; &#160; &#160;} &#160; &#160; &#160;int rsa_public_encrypt(const uint8_t *rsa_input, const int input_len, uint8_t *enc_out, uint8_t *public_key, const int key_len) &#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;uint8_t public_key_wrapper[RSA_PUBKEY_BUFSIZE]; &#160; &#160; &#160;&#160; &#160; &#160;int wrapper_len = wrapper_rsa_public_key(public_key, key_len, public_key_wrapper); &#160; &#160; &#160;&#160; &#160; &#160;if (wrapper_len &gt;= RSA_PUBKEY_BUFSIZE) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;char pkstr[1024]; // for saving publickey&#65288;294Byte&#65289;, length for printing chars is 294*2 &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;convert_int2string(public_key, key_len, pkstr, sizeof(pkstr)); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;TLOGE(&quot;rsa_public_encrypt&quot;, &quot;&quot;, &quot;Failed to wrapper_rsa_public_key. wrapper_len: %d, max_len: %d, pk: %s&quot;, &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160; &#160;wrapper_len, RSA_PUBKEY_BUFSIZE, pkstr); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return 0; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;RSA *rsa = create_rsa(public_key_wrapper, RSA_KEY_TYPE_PUBLIC); &#160; &#160; &#160;&#160; &#160; &#160;if (rsa == NULL) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;char pkstr[1024]; // for saving publickey&#65288;294Byte&#65289;, length for printing chars is 294*2 &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;convert_int2string(public_key, key_len, pkstr, sizeof(pkstr)); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;TLOGE(&quot;rsa_public_encrypt&quot;, &quot;&quot;, &quot;Failed to create RSA. pk: %s&quot;, pkstr); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return 0; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;uint32_t rsa_size = RSA_size(rsa); &#160; &#160; &#160;&#160; &#160; &#160;if (input_len &gt;= rsa_size - 41) // less than RSA_size(rsa) - 41 for RSA_PKCS1_OAEP_PADDING &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;TLOGE(&quot;rsa_public_encrypt&quot;, &quot;&quot;, &quot;data too long to encrypt, must be less than %d.&quot;, RSA_size(rsa) - 41); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;RSA_free(rsa); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return 0; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;int ret = RSA_public_encrypt(input_len, rsa_input, enc_out, rsa, RSA_PKCS1_OAEP_PADDING); &#160; &#160; &#160;&#160; &#160; &#160;if (ret &lt;= 0) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;TLOGE(&quot;rsa_public_encrypt&quot;, &quot;&quot;, &quot;Failed to encrypt with RSA public key.&quot;); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;RSA_free(rsa); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return 0; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;RSA_free(rsa); &#160; &#160; &#160;&#160; &#160; &#160;return ret; &#160; &#160; &#160;} I've used arguments in the core to reproduce this issue in development enviroment, but failed. This is the code: &#160; &#160; &#160;// gcc test_rsa.c -I./deps/openssl/include/ -L./deps/openssl/lib/ -I./deps/3rd/include/ ./deps/3rd/lib/libbase64.o -lssl -lcrypto -ldl &#160; &#160; &#160;#include &lt;stdio.h&gt; &#160; &#160; &#160;#include &lt;stdint.h&gt; &#160; &#160; &#160;#include &lt;string.h&gt; &#160; &#160; &#160;#include &lt;sys/time.h&gt; &#160; &#160; &#160;#include &lt;assert.h&gt; &#160; &#160; &#160;#include &lt;arpa/inet.h&gt; &#160; &#160; &#160;#include &lt;openssl/ssl.h&gt; &#160; &#160; &#160;#include &lt;openssl/rsa.h&gt; &#160; &#160; &#160;#include &lt;openssl/aes.h&gt; &#160; &#160; &#160;#include &lt;fcntl.h&gt; &#160; &#160; &#160;#include &lt;unistd.h&gt; &#160; &#160; &#160;#include &lt;openssl/ssl.h&gt; &#160; &#160; &#160;#include &lt;openssl/rsa.h&gt; &#160; &#160; &#160;#include &lt;openssl/aes.h&gt; &#160; &#160; &#160;// #define RSA_PUBKEY_BUFSIZE &#160; &#160;600 &#160; &#160; &#160;#define RSA_PUBKEY_BUFSIZE 2048 &#160; &#160; &#160;#define RSA_KEY_LENPERLINE 64 // RSA Pri and Pub keys in base64 format, number of chars per line &#160; &#160; &#160;RSA **private_rsas = NULL; &#160; &#160; &#160;uint32_t RSA_SIZE = 0; &#160; &#160; &#160;#define RSA_KEY_TYPE_PUBLIC 1 &#160; &#160; &#160;#define RSA_KEY_TYPE_PRIVATE 0 &#160; &#160; &#160;#define xmemcpy memcpy &#160; &#160; &#160;#define xmemset memset &#160; &#160; &#160;#define xsnprintf snprintf &#160; &#160; &#160;void convert_int2string(const uint8_t *array, int len, char *str, int dst_len) &#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;if (dst_len &lt; len * 2 + 1) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;int i; &#160; &#160; &#160;&#160; &#160; &#160;for (i = 0; i &lt; len; i++) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;xsnprintf(&amp;(str[i * 2]), 3, &quot;%02X&quot;, *(array + i)); &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;} &#160; &#160; &#160;static RSA *create_rsa(uint8_t *key, int key_type) &#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;RSA *rsa = NULL; &#160; &#160; &#160;&#160; &#160; &#160;BIO *keybio; &#160; &#160; &#160;&#160; &#160; &#160;keybio = BIO_new_mem_buf(key, -1); &#160; &#160; &#160;&#160; &#160; &#160;if (keybio == NULL) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;// TLOGE(&quot;create_rsa&quot;, &quot;&quot;, &quot;Failed to create key BIO.&quot;); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return NULL; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;if (key_type == RSA_KEY_TYPE_PUBLIC) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;rsa = PEM_read_bio_RSA_PUBKEY(keybio, &amp;rsa, NULL, NULL); &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;else &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;rsa = PEM_read_bio_RSAPrivateKey(keybio, &amp;rsa, NULL, NULL); &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;BIO_free(keybio); &#160; &#160; &#160;&#160; &#160; &#160;return rsa; &#160; &#160; &#160;} &#160; &#160; &#160;static int wrapper_rsa_public_key(uint8_t *key, int key_len, uint8_t *wrapper_key) &#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;uint8_t temp[RSA_PUBKEY_BUFSIZE]; &#160; &#160; &#160;&#160; &#160; &#160;uint8_t head[] = &quot;-----BEGIN PUBLIC KEY-----\n&quot;; &#160; &#160; &#160;&#160; &#160; &#160;uint8_t tail[] = &quot;-----END PUBLIC KEY-----\n&quot;; &#160; &#160; &#160;&#160; &#160; &#160;uint8_t *p_wapper = wrapper_key; &#160; &#160; &#160;&#160; &#160; &#160;uint8_t *p_temp = temp; &#160; &#160; &#160;&#160; &#160; &#160;size_t base64_len; &#160; &#160; &#160;&#160; &#160; &#160;base64_encode((char *)key, key_len, (char *)temp, &amp;base64_len, 0); &#160; &#160; &#160;&#160; &#160; &#160;xmemcpy(p_wapper, head, strlen((const char *)head)); &#160; &#160; &#160;&#160; &#160; &#160;p_wapper += strlen((const char *)head); &#160; &#160; &#160;&#160; &#160; &#160;int times = base64_len / RSA_KEY_LENPERLINE; &#160; &#160; &#160;&#160; &#160; &#160;int ret_char_cnt = times; &#160; &#160; &#160;&#160; &#160; &#160;int i; &#160; &#160; &#160;&#160; &#160; &#160;for (i = 0; i &lt; times; i++) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;xmemcpy(p_wapper, p_temp, RSA_KEY_LENPERLINE); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;p_wapper += RSA_KEY_LENPERLINE; &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;p_temp += RSA_KEY_LENPERLINE; &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;xmemset(p_wapper, '\n', 1); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;p_wapper++; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;if (base64_len % RSA_KEY_LENPERLINE &gt; 0) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;xmemcpy(p_wapper, p_temp, base64_len % RSA_KEY_LENPERLINE); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;p_wapper += base64_len % RSA_KEY_LENPERLINE; &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;xmemset(p_wapper, '\n', 1); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;p_wapper++; &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;ret_char_cnt++; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;xmemcpy(p_wapper, tail, strlen((const char *)tail)); &#160; &#160; &#160;&#160; &#160; &#160;return strlen((const char *)head) + base64_len + ret_char_cnt + strlen((const char *)tail); &#160; &#160; &#160;} &#160; &#160; &#160;int rsa_public_encrypt(const uint8_t *rsa_input, const int input_len, uint8_t *enc_out, uint8_t *public_key, const int key_len) &#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;uint8_t public_key_wrapper[RSA_PUBKEY_BUFSIZE]; &#160; &#160; &#160;&#160; &#160; &#160;int wrapper_len = wrapper_rsa_public_key(public_key, key_len, public_key_wrapper); &#160; &#160; &#160;&#160; &#160; &#160;if (wrapper_len &gt;= RSA_PUBKEY_BUFSIZE) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;char pkstr[1024]; &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;convert_int2string(public_key, key_len, pkstr, sizeof(pkstr)); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;// TLOGE(&quot;rsa_public_encrypt&quot;, &quot;&quot;, &quot;Failed to wrapper_rsa_public_key. wrapper_len: %d, max_len: %d, pk: %s&quot;, &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;// &#160; wrapper_len, RSA_PUBKEY_BUFSIZE, pkstr); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return 0; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;RSA *rsa = create_rsa(public_key_wrapper, RSA_KEY_TYPE_PUBLIC); &#160; &#160; &#160;&#160; &#160; &#160;if (rsa == NULL) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;char pkstr[1024]; &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;convert_int2string(public_key, key_len, pkstr, sizeof(pkstr)); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;// TLOGE(&quot;rsa_public_encrypt&quot;, &quot;&quot;, &quot;Failed to create RSA. pk: %s&quot;, pkstr); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return 0; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;uint32_t rsa_size = RSA_size(rsa); &#160; &#160; &#160;&#160; &#160; &#160;if (input_len &gt;= rsa_size - 41) // less than RSA_size(rsa) - 41 for RSA_PKCS1_OAEP_PADDING &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;// TLOGE(&quot;rsa_public_encrypt&quot;, &quot;&quot;, &quot;data too long to encrypt, must be less than %d.&quot;, RSA_size(rsa) - 41); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;RSA_free(rsa); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return 0; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;int ret = RSA_public_encrypt(input_len, rsa_input, enc_out, rsa, RSA_PKCS1_OAEP_PADDING); &#160; &#160; &#160;&#160; &#160; &#160;if (ret &lt;= 0) &#160; &#160; &#160;&#160; &#160; &#160;{ &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;// TLOGE(&quot;rsa_public_encrypt&quot;, &quot;&quot;, &quot;Failed to encrypt with RSA public key.&quot;); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;RSA_free(rsa); &#160; &#160; &#160;&#160; &#160; &#160;&#160; &#160; &#160;return 0; &#160; &#160; &#160;&#160; &#160; &#160;} &#160; &#160; &#160;&#160; &#160; &#160;RSA_free(rsa); &#160; &#160; &#160;&#160; &#160; &#160;return ret; &#160; &#160; &#160;} &#160; &#160; &#160;int main() { &#160; &#160; &#160;&#160; &#160; &#160;uint8_t rsa_input[32] = {0x72, 0x8d, 0xe5, 0xb4, 0x80, 0xda, 0xe8, 0x82, 0xeb, 0x5e, 0x24, 0x25, 0x8d, 0xc0, 0x73, 0x2e, 0x6b, 0x7a, 0xc1, 0x3f, 0x87, 0x70, 0x7d, 0xf3, 0x6b, 0x7a, 0xc1, 0x3f, 0x87, 0x70, 0x7d, 0xf3}; &#160; &#160; &#160;&#160; &#160; &#160;uint8_t enc_out[256] = {0}; &#160; &#160; &#160;&#160; &#160; &#160;uint8_t public_key[294] = {0x30, 0x82, 0x1, 0x22, 0x30
-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://mta.openssl.org/pipermail/openssl-users/attachments/20180211/64d8a9f2/attachment-0001.html">http://mta.openssl.org/pipermail/openssl-users/attachments/20180211/64d8a9f2/attachment-0001.html</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007468.html">[openssl-users] Creating a Json Web Key
</A></li>
	<LI>Next message: <A HREF="007470.html">[openssl-users] crash in `sha1_block_data_order_avx`
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7469">[ date ]</a>
              <a href="thread.html#7469">[ thread ]</a>
              <a href="subject.html#7469">[ subject ]</a>
              <a href="author.html#7469">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-users.html">More information about the openssl-users
mailing list</a><br>
</body></html>
