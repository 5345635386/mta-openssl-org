<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openssl-users] Authentication over ECDHE
   </TITLE>
   <LINK REL="Index" HREF="https://mta.openssl.org/pipermail/openssl-users/2018-December/index.html" >
   <LINK REL="made" HREF="mailto:openssl-users%40openssl.org?Subject=Re%3A%20%5Bopenssl-users%5D%20Authentication%20over%20ECDHE&In-Reply-To=%3C20181231.164342.595806582237525869.levitte%40openssl.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009579.html">
   <LINK REL="Next"  HREF="009581.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openssl-users] Authentication over ECDHE</H1>
    <B>Richard Levitte</B> 
    <A HREF="mailto:openssl-users%40openssl.org?Subject=Re%3A%20%5Bopenssl-users%5D%20Authentication%20over%20ECDHE&In-Reply-To=%3C20181231.164342.595806582237525869.levitte%40openssl.org%3E"
       TITLE="[openssl-users] Authentication over ECDHE">levitte at openssl.org
       </A><BR>
    <I>Mon Dec 31 15:43:42 UTC 2018</I>
    <P><UL>
        <LI>Previous message: <A HREF="009579.html">[openssl-users] Authentication over ECDHE
</A></li>
        <LI>Next message: <A HREF="009581.html">[openssl-users] Authentication over ECDHE
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9580">[ date ]</a>
              <a href="thread.html#9580">[ thread ]</a>
              <a href="subject.html#9580">[ subject ]</a>
              <a href="author.html#9580">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>I'll go ahead and ask, how long do you think such a back door would
stay unnoticed, let alone survive?  I'm considering the fact that we
have a lot of people looking at our code, just judging from the issues
and pull requests raised on github.

I can't say that I have an actual answer, but it's a question worth
asking as well, to see if the T.O.L.A. Act is worth a state of panic
or not.

Cheers,
Richard ( who's on vacation and should stop reading these mails )

In message &lt;<A HREF="../../../mailman/listinfo/openssl-users.html">11EDC036-87D3-4757-AD33-80C6E608F77F at foocrypt.net</A>&gt; on Tue, 1 Jan 2019 01:27:53 +1100, &quot;<A HREF="../../../mailman/listinfo/openssl-users.html">openssl at foocrypt.net</A>&quot; &lt;<A HREF="../../../mailman/listinfo/openssl-users.html">openssl at foocrypt.net</A>&gt; said:

&gt;<i> Matt et al
</I>&gt;<i> 
</I>&gt;<i> 'been reviewed and approved by two current OpenSSL committers (one of whom must
</I>&gt;<i> be on the OpenSSL Management Committee).&#8217;
</I>&gt;<i> 
</I>&gt;<i> Due to the recent legislative changes here in Australia around the T.O.L.A. Act, can a change be
</I>&gt;<i> made to the OpenSSL policy so that the 2 reviewers, don&#8217;t reside in Australia, or are Australian
</I>&gt;<i> citizens ?
</I>&gt;<i> 
</I>&gt;<i> ABI/API changes -&gt; breaks -&gt; back door requests&#8230;.
</I>&gt;<i> 
</I>&gt;<i> --
</I>&gt;<i> 
</I>&gt;<i> Regards,
</I>&gt;<i> 
</I>&gt;<i> Mark A. Lane
</I>&gt;<i> 
</I>&gt;<i> Cryptopocalypse NOW 01 04 2016
</I>&gt;<i> 
</I>&gt;<i> Volumes 0.0 -&gt; 10.0 Now available through iTunes - iBooks @
</I>&gt;<i> <A HREF="https://itunes.apple.com/au/author/mark-a.-lane/id1100062966?mt=11">https://itunes.apple.com/au/author/mark-a.-lane/id1100062966?mt=11</A>
</I>&gt;<i> 
</I>&gt;<i> &#169; Mark A. Lane 1980 - 2019, All Rights Reserved.
</I>&gt;<i> &#169; FooCrypt 1980 - 2019, All Rights Reserved.
</I>&gt;<i> &#169; FooCrypt, A Tale of Cynical Cyclical Encryption. 1980 - 2019, All Rights Reserved.
</I>&gt;<i> &#169; Cryptopocalypse 1980 - 2019, All Rights Reserved.
</I>&gt;<i> 
</I>&gt;<i>  On 1 Jan 2019, at 01:11, Matt Caswell &lt;<A HREF="../../../mailman/listinfo/openssl-users.html">matt at openssl.org</A>&gt; wrote:
</I>&gt;<i> 
</I>&gt;<i>  On 31/12/2018 11:36, C.Wehrmeyer wrote:
</I>&gt;<i> 
</I>&gt;<i>  On 31.12.18 10:12, Richard Levitte wrote:
</I>&gt;<i> 
</I>&gt;<i>  Yes, it's true, new features are going in. And it's true that it's
</I>&gt;<i>  often more exciting to add new features than to do the janitorial
</I>&gt;<i>  work.
</I>&gt;<i> 
</I>&gt;<i>  You realised what I have left unspoken thus far, which is this almost
</I>&gt;<i>  obsession-like preference of OSS coders to add new features rather than
</I>&gt;<i>  improving the old, boring codebase. However, there's a reason why it's still
</I>&gt;<i>  called code*base*. It's the base of everything. And adding more and more
</I>&gt;<i>  features to that base is going to make ripping off the band-aid more painful in
</I>&gt;<i>  the long run.
</I>&gt;<i> 
</I>&gt;<i>  There has been a huge amount of effort put in over the last few years to improve
</I>&gt;<i>  the codebase. Things that immediately spring to mind (and there's probably a
</I>&gt;<i>  whole load more):
</I>&gt;<i> 
</I>&gt;<i>  - Rewrite of the state machine
</I>&gt;<i>  - libssl record layer refactor
</I>&gt;<i>  - Implementation of the PACKET and WPACKET abstractions in libssl
</I>&gt;<i>  - Rewrite of the rand code
</I>&gt;<i>  - Implementation of the new test harness
</I>&gt;<i>  - Significant effort into developing tests
</I>&gt;<i>  - Implementation of the coding style and reformat of the codebase to meet it
</I>&gt;<i>  - Opaque many of the structures (which I know you don't see as an improvement,
</I>&gt;<i>  but I'll answer that point separately)
</I>&gt;<i>  - Implementation of continuous fuzzing
</I>&gt;<i>  - Significant expansion of the documentation coverage
</I>&gt;<i> 
</I>&gt;<i>  It is simply not true to claim that we have &quot;an obsession-like preference...to
</I>&gt;<i>  add new features rather than improving the old, boring codebase&quot;. None of the
</I>&gt;<i>  above things resulted in or were motivated by user visible features. They were
</I>&gt;<i>  all about improving the codebase.
</I>&gt;<i> 
</I>&gt;<i>  Also, infrastructure again. I, as a user, don't care if the kernel gets a new
</I>&gt;<i>  feature that makes some black magic happening. What I care about is that the
</I>&gt;<i>  kernel doesn't throw away my writes (which has happened in May of 2018, see):
</I>&gt;<i> 
</I>&gt;<i>  <A HREF="https://www.postgresql.org/message-id/flat/CAMsr%2BYE5Gs9iPqw2mQ6OHt1aC5Qk5EuBFCyG%2BvzHun1EqMxyQg%40mail.gmail.com#CAMsr+YE5Gs9iPqw2mQ6OHt1aC5Qk5EuBFCyG+vzHun1EqMxyQg@mail.gmail.com">https://www.postgresql.org/message-id/flat/CAMsr%2BYE5Gs9iPqw2mQ6OHt1aC5Qk5EuBFCyG%2BvzHun1EqMxyQg%40mail.gmail.com#CAMsr+YE5Gs9iPqw2mQ6OHt1aC5Qk5EuBFCyG+vzHun1EqMxyQg@mail.gmail.com</A>)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>  Cryptography libs should be equally conservative, considering that cryptography
</I>&gt;<i>  is conservative to begin with. I don't care if TLS 1.3 lets me use new exiting
</I>&gt;<i>  ciphers and handshakes when it unreasonably bogs down my server code.
</I>&gt;<i> 
</I>&gt;<i>  BUT, you also have to appreciate that stuff is happening around us
</I>&gt;<i>  that affects our focus. TLS 1.3 happened, and rather than having to
</I>&gt;<i>  answer the question &quot;why don't you have TLS 1.3 yet?&quot; (there's a LOT
</I>&gt;<i>  of interest in that version), we decided to add it.
</I>&gt;<i> 
</I>&gt;<i>  Sure, but didn't Matt just say that there are a lot of volunteers working on
</I>&gt;<i>  that library? The disadvantage here is that quality assurance is barely a thing
</I>&gt;<i>  - however, the *advantage* of this is that OpenSSL does not have to follow
</I>&gt;<i>  commercial interests. If we look at this at face value you could just say &quot;No,
</I>&gt;<i>  people, it's high time we streamline some of the internal aspects of the
</I>&gt;<i>  library, TLS 1.3 will have to wait. You can't wait that long? Well, sorry&quot;.
</I>&gt;<i> 
</I>&gt;<i>  However, your message is clear, we do need to do some cleanup as
</I>&gt;<i>  well. More than that, I agree with you that it's needed (I've
</I>&gt;<i>  screamed out in angst when stumbling upon particularly ugly or
</I>&gt;<i>  misplaced code, so the feeling is shared, more than you might
</I>&gt;<i>  believe).
</I>&gt;<i> 
</I>&gt;<i>  But what does &quot;cleanup&quot; entail? That's the hot-button question here. I've
</I>&gt;<i>  already made a suggestion, that is to say, getting rid of opaque structures. If
</I>&gt;<i>  that is deemed too insecure (for whatever reasons), export symbols that allow
</I>&gt;<i>  programmers to query the size of structures, and provide two versions of
</I>&gt;<i>  functions: one function expects the caller to pass an object to which the
</I>&gt;<i>  changes are to be made, and the other one allocates the necessary memory
</I>&gt;<i>  dynamically and then calls the first version. Or just don't allocate my object
</I>&gt;<i>  memory dynamically anymore.
</I>&gt;<i> 
</I>&gt;<i>  That being said, cleanup happens, and documentation happens, in a
</I>&gt;<i>  piecemeal fashion, 'cause that's what most people have capacity for.
</I>&gt;<i> 
</I>&gt;<i>  So, what you're effectively saying is that I'm the first one who ever asked for
</I>&gt;<i>  SSL object reuse, right? Because if piecemeal work happens on the documentation,
</I>&gt;<i>  and Viktor says that it's possible, then surely no one would have ever answered
</I>&gt;<i>  that question on the mailing list and *not* put it piecemeal-ly in the OpenSSL
</I>&gt;<i>  documentation, right?
</I>&gt;<i> 
</I>&gt;<i>  Now, here's something else that you need to consider: API/ABI
</I>&gt;<i>  compatibility needs to be preserved.
</I>&gt;<i> 
</I>&gt;<i>  No it doesn't. We *know* it doesn't. When OpenSSL 1.1 was released it broke all
</I>&gt;<i>  *sorts* of applications out there, because all sorts of applications used struct
</I>&gt;<i>  fields rather than accessors. wget, mutt, neon, python, you name it, you broke it.
</I>&gt;<i> 
</I>&gt;<i>  API/ABI stability is absolutely required. Every time we make a breaking change
</I>&gt;<i>  it is painful for our users - and more pain is felt the bigger the scale of the
</I>&gt;<i>  break. We simply cannot go around making wholesale breaks on an ongoing basis.
</I>&gt;<i>  If we did so then OpenSSL would be a lot less useful to our users.
</I>&gt;<i> 
</I>&gt;<i>  This is not to say that we can *never* make breaking changes. Only that when we
</I>&gt;<i>  do so it must be strongly justified and only done relatively infrequently. We
</I>&gt;<i>  made such a decision when we decided to make the structures opaque. It's not a
</I>&gt;<i>  decision we are likely to repeat anytime soon IMO. We are still feeling the pain
</I>&gt;<i>  of that now (and will continue to do so for at least the next year until 1.0.2
</I>&gt;<i>  goes out of support - and probably beyond that).
</I>&gt;<i> 
</I>&gt;<i>  Which brings me onto why structures were made opaque in the first place. A
</I>&gt;<i>  significant driver for this (probably *the* most important one) was to improve
</I>&gt;<i>  the codebase. I have witnessed first hand the harm that non-opaque structures
</I>&gt;<i>  did to OpenSSL. We will be fixing the fallout from them for years to come.
</I>&gt;<i>  Non-opaque structures combined with the requirements for stable API/ABI means
</I>&gt;<i>  you cannot change anything in those structures. Renaming or deleting structure
</I>&gt;<i>  members constitutes an API break. Even *adding* structure members constitutes an
</I>&gt;<i>  ABI break (due to the changed size of the structure). This means the code
</I>&gt;<i>  ossifies over time and cannot easily be refactored. Much of OpenSSL's internal
</I>&gt;<i>  &quot;quirkiness&quot; results from attempting to work around this restriction.
</I>&gt;<i> 
</I>&gt;<i>  Things like the state machine refactor and the record layer refactor would not
</I>&gt;<i>  have been possible without opaque structures. In my mind making the structures
</I>&gt;<i>  opaque was one of the best things that ever happened to OpenSSL.
</I>&gt;<i> 
</I>&gt;<i>  <A HREF="https://breakpoint.cc/openssl-1.1-rebuild-2016-08-26/">https://breakpoint.cc/openssl-1.1-rebuild-2016-08-26/</A>
</I>&gt;<i> 
</I>&gt;<i>  So since when do we need to consider API/ABI compatibility? Did we grow up
</I>&gt;<i>  recently?
</I>&gt;<i> 
</I>&gt;<i>  Or maybe OpenSSL should have switched the language. The point of C is that
</I>&gt;<i>  structures are public. And if I'm going to be honest that approach saved my
</I>&gt;<i>  sorry arse more than a couple times. When zlib choked because it couldn't go
</I>&gt;<i>  past 4 GiBs of data since its fields were uint32_ts, I was able to easily
</I>&gt;<i>  workaround this problem. But what do I know.
</I>&gt;<i> 
</I>&gt;<i>  If you really want to fiddle with OpenSSL internal structures - feel free. Just
</I>&gt;<i>  include the OpenSSL internal header files and away you go. Just do so in the
</I>&gt;<i>  knowledge that they could be changed at any time, and your code might break. If
</I>&gt;<i>  this isn't a concern to you then - no problem. If it is a concern to you - then
</I>&gt;<i>  actually you *do* care about API/ABI stability after all.
</I>&gt;<i> 
</I>&gt;<i>  Counting symbols is, however, nothing other than a blunt instrument.
</I>&gt;<i>  Quite a lot of those symbols are convenience macros and functions that
</I>&gt;<i>  have accumulated over time.
</I>&gt;<i> 
</I>&gt;<i>  You're taking my statement out of context. Counting the symbols wasn't supposed
</I>&gt;<i>  to suggest that there are too *many* of them. I'm in no position to say that,
</I>&gt;<i>  seeing as the original context in which my statement was put is that *I'm not
</I>&gt;<i>  familiar enough with the library*.
</I>&gt;<i> 
</I>&gt;<i>  What I said was that reading the code is easy. Learning what the library
</I>&gt;<i>  provides is hard, and that you won't learn much just by looking at the symbols
</I>&gt;<i>  because there's so many of them.
</I>&gt;<i> 
</I>&gt;<i>  But nevertheless, I do hear you call for a remake of the SSL API as
</I>&gt;<i>  well as cleaner internals. The latter is easier, and I'm sure it will
</I>&gt;<i>  happen piecemeal as per usual so as to not break something /
</I>&gt;<i>  inadvertently change a behavior (i.e. break ABI). The former is a
</I>&gt;<i>  fairly massive project, and is more of creating a new API and library
</I>&gt;<i>  rather than a mere cleanup job. That will be a massive effort, and
</I>&gt;<i>  you do have to keep in mind how much time all involved can put into
</I>&gt;<i>  it.
</I>&gt;<i> 
</I>&gt;<i>  I'm not saying it needs to be done right now. I'm merely suggesting that it
</I>&gt;<i>  might be a good goal post for OpenSSL 2.0.
</I>&gt;<i> 
</I>&gt;<i>  Turning structures opaque doesn't prevent people from still messing
</I>&gt;<i>  with their internal fields.
</I>&gt;<i> 
</I>&gt;<i>  True. But it makes for a clear delineation where people are forced to
</I>&gt;<i>  be aware that they are playing with internal stuff, and that it may
</I>&gt;<i>  not be a safe thing to do.
</I>&gt;<i> 
</I>&gt;<i>  Then why not provide small helper functions for covering the &quot;playing with
</I>&gt;<i>  internal stuff&quot; part? That way it's still controlled, and documented, and
</I>&gt;<i>  unified. You guys must've had some examples to show off in order to justify the
</I>&gt;<i>  process, so surely you know what it is that people do when they use internal
</I>&gt;<i>  stuff. Make functions for those. Don't give them any reason to continue playing
</I>&gt;<i>  with internal stuff.
</I>&gt;<i> 
</I>&gt;<i>  I don't like code that tries to protect programmers from themselves. I like code
</I>&gt;<i>  that lets good programmers do smart things. And if bad programmers use that
</I>&gt;<i>  freedom to do bad stuff, then doesn't that mean your API simply didn't support
</I>&gt;<i>  this, and they had to make it work somehow else? Again, helper functions.
</I>&gt;<i> 
</I>&gt;<i>  Uhmmmm.... this is factually incorrect. OpenSSL doesn't use its own
</I>&gt;<i>  memory pooling. We have thin wrappers around the usual malloc() /
</I>&gt;<i>  realloc() / free(), which allows any application to do its own memory
</I>&gt;<i>  pooling.
</I>&gt;<i> 
</I>&gt;<i>  <A HREF="https://web.archive.org/web/20150207180717/http://article.gmane.org/gmane.os.openbsd.misc/211963">https://web.archive.org/web/20150207180717/http://article.gmane.org/gmane.os.openbsd.misc/211963</A>
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>  The BUF_FREELISTS code that this post references was ripped out years ago. This
</I>&gt;<i>  no longer represents the current state of OpenSSL in any supported version.
</I>&gt;<i> 
</I>&gt;<i>  To conclude, I have a question for you: are you only willing to rant
</I>&gt;<i>  (*), or are you willing to help out in another way?
</I>&gt;<i> 
</I>&gt;<i>  This is not the question I feel you should ask because we haven't even
</I>&gt;<i>  established if I *could* make contributions to the project, as my mindset
</I>&gt;<i>  appears to be so much more different. Especially the idea of not wanting to
</I>&gt;<i>  break APIs/ABIs is a huge limitation - just looking at SSL_new() made me give up
</I>&gt;<i>  hope here.
</I>&gt;<i> 
</I>&gt;<i>  Yes - not breaking APIs/ABIs is a huge limitation. BoringSSL is not suitable for
</I>&gt;<i>  general purpose use precisely because of this. The only users BoringSSL cares
</I>&gt;<i>  about whether they break or not are Google users. As soon as you have a library
</I>&gt;<i>  that wants to cater for large numbers of users (which we do) then you have to
</I>&gt;<i>  accept that limitation.
</I>&gt;<i> 
</I>&gt;<i>  As to whether or not we have established whether you *could* make such
</I>&gt;<i>  contributions - I think you are missing the point. We cannot know whether you
</I>&gt;<i>  are capable or not until you try. It is on the basis of your code that we would
</I>&gt;<i>  make such a judgement. In order for your code to get into OpenSSL it must have
</I>&gt;<i>  been reviewed and approved by two current OpenSSL committers (one of whom must
</I>&gt;<i>  be on the OpenSSL Management Committee). We invite anyone to contribute. In
</I>&gt;<i>  order for this to be a healthy open-source community we *need* those
</I>&gt;<i>  contributions. Only those that make the grade will make it in.
</I>&gt;<i> 
</I>&gt;<i>  Note - this review process wasn't always the case. Things used to be much more
</I>&gt;<i>  informal in pre-heartbleed days. This is no longer the case.
</I>&gt;<i> 
</I>&gt;<i>  I'm no cryptography expert, I've made that clear from mail one, and my cleanup
</I>&gt;<i>  jobs would be more widespread than what seems to be deemed acceptable right now.
</I>&gt;<i>  I can read and write scalable C code, otherwise I wouldn't even have tried to
</I>&gt;<i>  reuse that SSL object from the beginning.
</I>&gt;<i> 
</I>&gt;<i>  So, I ask a question in return: what do you think I *could* be helping with?
</I>&gt;<i> 
</I>&gt;<i>  Well, you have vocally complained about the state of the documentation. You have
</I>&gt;<i>  the benefit of being a new OpenSSL user. You know what things were confusing or
</I>&gt;<i>  unclear in the documentation. More experienced OpenSSL coders often don't have
</I>&gt;<i>  the perspective - because some things are just &quot;obvious&quot; to them. So help with
</I>&gt;<i>  pull requests to improve the documentation.
</I>&gt;<i> 
</I>&gt;<i>  Matt
</I>&gt;<i>  --
</I>&gt;<i>  openssl-users mailing list
</I>&gt;<i>  To unsubscribe: <A HREF="../../../mailman/listinfo/openssl-users.html">https://mta.openssl.org/mailman/listinfo/openssl-users</A>
</I>&gt;<i> 
</I></PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009579.html">[openssl-users] Authentication over ECDHE
</A></li>
	<LI>Next message: <A HREF="009581.html">[openssl-users] Authentication over ECDHE
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9580">[ date ]</a>
              <a href="thread.html#9580">[ thread ]</a>
              <a href="subject.html#9580">[ subject ]</a>
              <a href="author.html#9580">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="../../../mailman/listinfo/openssl-users.html">More information about the openssl-users
mailing list</a><br>
</body></html>
